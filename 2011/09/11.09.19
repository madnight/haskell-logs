00:18:33 <dobblego> is there some "formula" to get otherwise mutually recursive functions to terminate under strict evaluation?
00:19:16 <benmachine> step 1. implement a haskell interpreter in your language
00:19:20 <benmachine> ... jk
00:19:51 <benmachine> well, it *is* usually possibly to simulate laziness in strict languages, if crudely
00:20:11 <benmachine> basically by making things functions and then explicitly demanding them by calling them
00:20:28 <dobblego> yeah I've had to rule that out sadly
00:20:49 <benmachine> but usually I'd expect you'd just write the function in such a way that it didn't unconditionally recurse
00:21:50 <dobblego> the two functions I am thinking of are: list :: Parser a -> Parser [a] and list1 :: Parser a -> Parser [a] {- guarantees non-empty list -}
00:23:29 <dobblego> list p = list1 p ||| return []; list1 = liftA2 (:) <*> list -- something like that anyway
00:23:48 <benmachine> liftA2 (:) p list
00:23:56 <benmachine> oh
00:23:58 <benmachine> I see
00:24:10 <benmachine> liftA2 (:) p (list p) which is the ap thing, right
00:24:35 <dobblego> yeah f <*> g just looks a lot neater to me than \x -> f x (g x)
00:24:58 <benmachine> it confused me having the <*> and the liftA2, I was expecting them to be the same applicative
00:25:03 <benmachine> but anyway
00:25:16 <dobblego> liftA2 on Parser and <*> on ((->) t)
00:26:11 <benmachine> I think your strategy depends a little on what Parser values look like in this language and how they are constructed
00:26:36 <dobblego> [] is strict and finite-length in this language
00:26:50 <benmachine> the language is otherwise similar to haskell?
00:26:51 <dobblego> sadly, I cannot change this
00:27:25 <dobblego> well, it's strict by default and laziness is stack-expensive
00:28:38 <benmachine> sure but I meant in terms of the way types and functions are typically done
00:28:42 <dobblego> right
00:31:06 <benmachine> I sort of imagine Parser values as function types, and ||| constructing a value which, when called, calls its arguments in turn
00:31:43 <benmachine> in that case the recursion is guarded behind calls, like the laziness simulating case
00:31:51 <dobblego> I'm not sure if making ||| lazy is enough to achieve termination
00:32:00 <dobblego> I shall try it
00:34:16 <freeasjesus> Can I please have some examples of popular apps that are written in Haskell? I know only of xmonad. Any games?
00:35:00 <flux> freeasjesus, there's bzflag
00:35:17 <flux> not sure how it measures in the popularity axis, though
00:35:30 <freeasjesus> Is that not C++?
00:35:41 <opqdonut> what?
00:35:46 <opqdonut> "BZFlag is primarily written in the C++ language, but does contain some modules written in Perl, PHP, and Python."
00:35:54 <quicksilver> http://www.haskell.org/haskellwiki/Applications_and_libraries/Games
00:36:00 <quicksilver> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:game
00:36:04 <flux> hmm, I must be mistaking it for something else
00:36:05 <quicksilver> freeasjesus: ^^ two lists of haskell games
00:36:12 <quicksilver> although none of them is "wildly popular" afaik
00:36:13 <ddarius> freeasjesus: There are a lot of popular apps written in C.  You should go to ##c and learn C.
00:36:45 <quicksilver> the ones I have heard mentioned most are monadius and frag
00:36:55 <freeasjesus> ddarius: not looking to learn a language here. quicksilver: thank you very much. Not too fussed about popularity, just need some examples.
00:37:07 <ddarius> quicksilver: You haven't heard of Nikki and the Robots?
00:37:08 <benmachine> freeasjesus: GHC itself is written in haskell, bit of a monster though
00:37:27 <benmachine> (not a game, I realise, just saying)
00:37:48 <benmachine> also darcs
00:38:07 <freeasjesus> benmachine: Yes, but as xmonads it was rather an obvious one. Just trying to present how  Haskell is actually used within the general computer community
00:38:13 <flux> ah, frag indeed wsa the one I was thinking. haven't played either, though :)
00:38:23 <ddarius> freeasjesus: There is a whole page on how it is used.
00:38:36 <freeasjesus> ddarius: I read that, but wasn't interested
00:38:44 <benmachine> freeasjesus: darcs is sometimes used in non-haskell projects
00:38:58 <ddarius> So you are not interested in how it is actually used within the general computer community.
00:39:02 <benmachine> I couldn't comment how often, but I've seen it before
00:40:00 <freeasjesus> Frag's looking interesting and was described in the author's undergrad thesis on functional programming and 3D games.
00:40:04 <freeasjesus> Very interesting.
00:41:06 <quicksilver> ddarius: I didn't say I hadn't heard of it :) I just said I hear monadius and frag mentioned the most.
00:42:37 <freeasjesus> Also, do any of you guys use OS X?
00:43:34 <benmachine> freeasjesus: I do very occasionally
00:44:28 <freeasjesus> benmachine: what do you mean occasionally?
00:44:51 <benmachine> freeasjesus: I have a mac with GHC installed, but I avoid it unless I have no choice :P
00:45:26 <obiwahn> @arrr
00:45:26 <lambdabot> Aye
00:45:31 <obiwahn> http://en.wikipedia.org/wiki/International_Talk_Like_a_Pirate_Day
00:45:53 <freeasjesus> benmachine: why's that? You mean just for Haskell or in general?
00:46:16 <benmachine> freeasjesus: well, it's just not my primary computer, so I don't often have any reason to use it
00:47:11 <freeasjesus> benmachine: have you any comment as to why so many people that know about programming/computers-in-general are using OS X now-days?
00:48:03 <benmachine> no, I don't know about that sort of thing
00:48:22 <benmachine> (maybe it's something to do with the success of the iPhone and etc.)
00:48:23 <tdammers> freeasjesus: probably because of windows
00:48:50 <Botje> compatibility with the rest of the lab, in my case
00:49:03 <freeasjesus> tdammers: what do you think they think of Linux/BSD?
00:49:12 <freeasjesus> BSD not including Darwin
00:52:14 <tdammers> freeasjesus: OS X has a better GUI out-of-the-box
00:52:46 <freeasjesus> Interesting. Thanks for the responses, guys :)
00:52:50 <applicative> freeasjesus, try pandoc http://johnmacfarlane.net/pandoc/try  http://johnmacfarlane.net/pandoc/
01:22:31 <quicksilver> freeasjesus: because it's a pain getting linux working reliably on laptops. (Is my answer and some other people knew)
01:23:00 * Nafai blinks
01:25:36 <Nafai> people have a funny definition of pain
01:25:51 <merijn> Nafai: 1 or 2 years ago it was terrible
01:26:01 <merijn> Supposedly Ubuntu works mostly out of the box nowadays
01:26:15 <merijn> But when I was looking into it, it really sucked balls
01:26:17 <Nafai> merijn: I've been using Linux on a laptop for 5-6 years
01:26:29 <Nafai> and 2 or so years ago, I *hated* my mac book pro because of OS X
01:27:24 <Nafai> I take that back, I've bene using it for a decade, and as long as I had decent hardware (had one dud that sucked no matter what software it was running), worked great :)
01:28:50 <Gagis> I ran ubuntu on my mbp for a few years. 2007 to 2010 or so. worked mostly just fine, except for fglrx
01:30:08 <Gagis> now works better that I got a no-brand laptop
01:30:48 <applicative> it seems it is getting easier to install some of the user friendly linuxes on laptops, I managed to pull it off just yesterday, not having tried for a couple of years.
01:31:14 <erus`> x[x := r] = r; what does that mean?
01:31:29 * ddarius has also been using Linux on a laptop for 5 years.
01:31:34 <applicative> substituing r for x
01:31:53 * ddarius has only had a laptop for about 5 years.
01:32:02 <merijn> I always find it amusing how people who have been using Linux for years seem compelled to argue its no problem whenever someone is talking about problems they had with it :p
01:32:26 <erus`> applicative: why would i need todo this?
01:32:29 <merijn> Like it's somehow not allowed to experience things differently from other people...
01:32:52 <Gagis> its the same effect as with mothers and their kids misbehaving at school merijn :P
01:33:05 <applicative> x ^ 2 * y + y * x [x := 2 + 2]  is (2+2)^2 * y + y * (2+2)  -- might be a better illustration
01:33:34 <applicative> erus`: or I am I guessing the context correctly
01:33:52 <ddarius> merijn: At least they are making statements about their own experience, rather than making statements about everyone's experience.
01:34:10 <erus`> so its just applying a function?
01:34:30 <quicksilver> Nafai: with working wireless and suspend? 10 years ago?
01:34:34 <applicative> I think one thinks about it more syntactically, but it might depend what you're reading
01:34:35 <quicksilver> I'd be impressed/surprised.
01:34:43 <erus`> err i mean passing an arguement
01:34:46 <tdammers> I run debian on my notebook. No problems whatsoever.
01:34:55 <ddarius> Suspend doesn't always work on my work laptop that runs Windows 7.
01:35:30 <erus`> http://en.wikipedia.org/wiki/Lambda_calculus i follow all the way until "Capture-avoiding substitutions"
01:35:55 <ddarius> erus`: Unfortunately, capture-avoiding substitution is pretty much the heart of the lambda calculus.
01:36:12 <erus`> im just not familiar with that syntax...
01:37:01 <applicative> capture avoid substitution is the most tedious topic in the world.  You can dry off reading a discussion of it.
01:37:08 <applicative> erus`: We write t[x := r] for the substitution of r for x in t, in a capture-avoiding manner.
01:37:57 <erus`> so its just substituting a arguement/variable/label ?
01:37:59 <applicative> here t and r are complex expressions.  x is a genuine 'free variable'.  t in particular is likely to contain some appearances of x
01:38:04 <Nafai> quicksilver: uh, yeah.  had to be more picky on hardware choices then, but yeah.
01:39:08 <applicative> erus` it is all a consequence of 1D representation.
01:39:21 <merijn> Nafai: Not everyone think the research into what hardware combination to get is worth that time investment
01:39:50 <Nafai> merijn: don't have to these days.
01:39:59 <applicative> in a graphical symbolism the whole topic vanishes, but unfortunately, you'll have trouble handing any such representation to a compiler
01:39:59 <Gagis> its in the past mostly anyways, but just 5 years ago it was much more unpleasant than it is now
01:40:27 <quicksilver> applicative: de bruijn!
01:40:35 <zzo38> Would it be possible to define monad in terms of Kleisli composition?
01:41:01 <quicksilver> zzo38: yes, but you still need 'return'
01:41:18 <zzo38> quicksilver: Yes, I expected that.
01:41:21 <quicksilver> and fmap/liftM
01:41:53 <applicative> de bruijnism is an attempt to have it both ways.  de bruijn ism is the ONLY thing in the civilized literature of humanity that is more dull than studying 'capture avoiding substitution'
01:42:27 <zzo38> You need fmap? You don't need fmap or join if you define (>>=)
01:42:42 <quicksilver> applicative: well, doing de bruijn by hand is dull. It's not a bad solution for computers so you don't have to worry about capture in your implementation
01:42:54 <applicative> one of the best features of Frege's late -- contradictory -- system is that he was able to define substitution rules for indefinitely higher-order logic
01:42:55 <MHD> ... How good is Template Haskell with Numbers?
01:43:33 <zzo38> MHD: Can you be specific, please?
01:44:02 <MHD> zzo38: I have this boilerplate nighmare with continuation based StateT's that carry 1 to 4 states
01:44:12 <MHD> StateCont1T through StateCont4T
01:44:39 <MHD> Actually "nightmare" is an overstatement, but still.
01:44:43 <ddarius> quicksilver: You still have to worry about "capture" it just looks different.
01:45:14 <zzo38> Template Haskell can use any Haskell codes; you can use numbers or whatever you need to.
01:45:56 <MHD> zzo38: Can it generate argument lists?
01:46:19 <erus`> where can i read the rules for capture avoiding substitution ? like for a newbie
01:46:20 <zzo38> MHD: Yes. However, you need to generate it as part of the function call.
01:46:27 <erus`> if i know haskell will i know this allready?
01:47:16 <MHD> zzo38: Umm... like i give it "3" and it makes "s1 s2 s3" ?
01:47:22 <zzo38> Know that functions in haskell take only one argument. If you need more than one, they use currying.
01:47:27 <applicative> erus` yes you know it implicitly.
01:48:01 <applicative> erus` attempts to make the matter explicit are generally fatal
01:48:14 <zzo38> MHD: Yes it can do that, but the name of the function must also be specified. It cannot generate function arguments separately because of currying.
01:48:24 <applicative> erus` the reason for this is that, in thought, the problem does not arise.
01:48:33 <ddarius> I agree with applicative here.  If you aren't formalizing a system with binders, the details are painfully dull and not very enlightening.
01:48:40 <applicative> only where thought is expressed in a sequence of characters
01:48:58 <merijn> Capture avoiding substitution is so intuitively obvious and so boring to formalize that I never bothered to try and fully understand any of the formalizations...
01:49:02 <MHD> zzo38: Maybe I should show some code
01:49:06 <zzo38> quicksilver: Can you describe the codes for making return and bind in terms of Kleisli composition and whatever else would be needed?
01:49:20 <applicative> ddarius, can you give an obvious example where erus` has found himself avoiding capture, i'm devoid of imagination at the moment
01:49:21 <zzo38> MHD: OK. Please do so; that way is better to understand.
01:49:49 <ddarius> merijn: I would not say that it is completely intuitively obvious.  The wrong choice has been made by many systems and many people have some trouble with binders.
01:49:59 <hpaste_> MHD pasted “Boilerplate "nightmare"” at http://hpaste.org/51521
01:50:13 <MHD> zzo38: here you go
01:50:13 <applicative> erus` problems frequently arise with where clauses in haskell if you like to use variables that suggest the type of the argument
01:50:21 <ddarius> applicative: I'm not erus`, I don't know his life experiences.
01:50:32 <merijn> ddarius: I meant for a person doing substitutions, not for automated solutions, of course
01:50:46 <applicative> foo str x = blah x where blah str = "hi
01:50:50 <applicative> foo str x = blah x where blah str = "hi"
01:50:54 <ddarius> merijn: That would be covered by the latter part of my statement.
01:51:24 <applicative> erus` this is the constant function of two arguments yielding "hi"
01:51:31 <merijn> erus`: The problem boils down to having the following lambda term "(\x -> \y -> x y) y", normally you'd be allowed to substitute the x in "x y" with "y", but the outside y is different from the y inside the term. That's the main problem
01:51:33 <applicative> of two strings I'm thinking
01:51:51 <zzo38> MHD: OK.
01:52:06 <ddarius> applicative: However, one of the reasons we can't just say "Barendregt convention" and be done with it, is unfolding recursive applications, and even some non-recursive cases.
01:52:09 <applicative> the second use of str is slightly dangerous, in a way that will be familiar
01:53:00 <erus`> so its like scoping ?
01:53:18 <applicative> erus` basically wherever you decide to use a new letter or variable for reasons other than elegance, you are trying to 'avoid capture'. It is the reason for the variation of letters
01:53:59 <MHD> zzo38: Any suggestions? It is easy to generate with, say, python, but it is a little ugly...
01:54:57 <zzo38> MHD: Yes, you can use Template Haskell to generate those things. However, it might not be best to have it the way you have. Why exactly do you need what you have there?
01:55:12 <erus`> ah
01:55:17 <erus`> it clicked
01:55:46 <MHD> zzo38: for fun and premature optimization. More seriously I was thinking of using it for an OpenGL-like linear algebra system
01:56:17 <zzo38> MHD: Do you know the curry and uncurry functions?
01:57:09 <MHD> zzo38: yeah?
01:57:49 <MHD> zzo38: i think my connectiom might die soon...
01:57:55 <zzo38> But your runSC1T_, runSC2T_, etc can be implemented with Template Haskell without too much difficulty, same with runSC1T and runSC2T and so on.
01:59:19 <MHD> zzo38: yeah, but it's te whole MultiState instance mess...
01:59:59 <applicative> erus` now you will be able to give interminable carefully worded lectures on the topic, though nothing you say will have any effect
02:00:20 <zzo38> Yes it does seems very messy.
02:01:57 <zzo38> It seem a very messy way to do that.
02:02:47 <zzo38> Why do you need multiple states anyways? Can't you do simply with record states or tuple states?
02:21:30 <tdammers> I'm looking for a way to split monadic actions into chunks, so that a function that now returns M () can return [M ()] instead
02:22:12 <tdammers> something like a wrapper that allows me to pass actions to the wrapped monad, but instead of running them, accumulates them
02:22:29 <tdammers> and then exposes a special action to start a new chunk
02:23:06 <quicksilver> you can't do that directly
02:23:16 <Botje> how would you split m >>= f ?
02:23:27 <quicksilver> as in, you can't have a monad such that "do bar; baz; bam" actually accumulates without acting
02:23:40 <tdammers> let me illustrate
02:23:41 <quicksilver> because flow control can depend on execution of earlier actions
02:23:52 <quicksilver> do a <- bar; if a then baz else bam
02:23:57 <tdammers> ^ oh yeah
02:24:03 <tdammers> that is probably why i can't do it
02:24:08 <quicksilver> you could do it with an applicative.
02:24:18 <tdammers> so... out of luck>
02:24:20 <quicksilver> because applicatives can't do dependent flow control
02:25:26 <tdammers> I was hoping I could somehow get Cairo to produce individual files for each page
02:25:57 <tdammers> the alternative I can come up with is pass the desired page number into the rendering function, and just discard all render actions that don't happen on that page
02:26:03 <tdammers> but it feels wasteful
02:28:39 <quicksilver> well if your actions happen not to be interdependent nothing to stop you writing a render pages function which returns a list of Cairo actions (one per page)
02:29:18 <tdammers> quicksilver: that's what I was planning to do
02:29:44 <tdammers> but the problem is, in order to know what goes on page 2, I need to read stuff back from cairo to calculate margins and such
02:30:00 <tdammers> it boils down to knowing the width of a piece of text
02:30:40 <quicksilver> aha.
02:30:49 <quicksilver> that's OK, I think
02:30:50 <tdammers> so what I imagined was that I just step through the entire rendering, but instead of actually executing render actions, I'd collect them into a list
02:30:59 <quicksilver> you just have a cairo action which returns a list of cairo actions
02:31:10 <tdammers> ?
02:31:10 <quicksilver> paginate :: Cairo [Cairo ()]
02:31:24 <quicksilver> the paginate function does enough measuring to work out the page boundaries
02:31:30 <quicksilver> and then returns a list of page rendering actions
02:31:46 <tdammers> hold on... let me check...
02:34:57 <dalaing_> so I've decided to have a look at fclabels and/or data-lens and I'm wondering - how do people typically mix code that uses Prelude (.) and Category (.)?
02:35:09 <tdammers> quicksilver: any documentation on that one?
02:35:19 <tdammers> or did you mean I have to write it myself?
02:35:38 <quicksilver> tdammers: I mean you have to write it yourself :)
02:35:42 <tdammers> right
02:35:50 <rostayob> dalaing_: (.) from category is just more general
02:36:28 <kowey> so I'm working with some (Allegro) Common Lisp users who are calling my Haskell code via the FFI...
02:36:46 <kowey> and they want me to give them sort of function that tells them how much memory Haskell is using
02:37:03 <Botje> kowey: didn't ezyang add something like that recently?
02:37:08 <kowey> do I understand correctly that this isn't really possible, http://www.haskell.org/pipermail/haskell-cafe/2011-April/090922.html  ?
02:37:19 <kowey> oh! that sounds interesting, Botje
02:37:44 <Botje> http://blog.ezyang.com/2011/08/in-program-gc-stats-redux/
02:38:33 <kowey> excellent, thanks for pointing me that way
02:38:36 <Botje> (everytime I read one of his posts I feel like a slacker)
02:38:41 <kowey> :-)
02:39:29 <quicksilver> Botje: you are, though. (me too ;)
02:40:15 <dalaing_> rostayob: thanks! that's kind of trippy
02:40:48 <dalaing_> and heaps better than import Control.Category as C and having "C.." littered through my code :)
02:42:03 <rostayob> dalaing_: :) (->) is a category so you'll be fine ehe
02:42:40 <dalaing_> rostayob: yeah, took me a little while to figure that must be what was going on, should have just checked the Category haddocks for the instance
02:42:51 <Kaidelong> what rostayob said
02:42:58 <Kaidelong> just hide (.) in prelude and you're set
02:43:08 <dalaing_> I've hidden id as well, just in case
02:43:16 <rostayob> dalaing_: also, (->) a is a functor!
02:43:35 <rostayob> I wish we could write (a ->)
02:43:45 <keep_learning> hello all
02:43:54 <Kaidelong> well the prelude id might add in monomorphism where you want it
02:44:04 <keep_learning> i am going through this tutorial of quickcheck http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
02:44:07 <Kaidelong> while that's less likely to happen with (.)
02:44:28 <Kaidelong> however so long as you write top level type signatures I suppose it hardly matters
02:44:47 <keep_learning> i am curious about how to write quickcheck testing for algebric data type .
02:45:13 <dalaing_> on one hand I'm not using id from Category at the moment, on the other hand I pretty much always write top level type signatures
02:45:23 <Kaidelong> I think hiding both (.) and id is fine
02:45:28 <rostayob> keep_learning: you have to write an instance for the Alternative type class
02:45:34 <dalaing_> cool - thanks
02:45:53 <Kaidelong> even if something turns out to be more polymorphic than you intended to be I think it's rarely a problem in practice anyway
02:46:10 <rostayob> keep_learning: basically what alternative does is to provide a way for quickcheck to generate random instances of your data type
02:46:30 <rostayob> keep_learning: RWH has a nice chapter on quickcheck
02:46:33 <rostayob> @where RWH
02:46:34 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:47:06 <Kaidelong> hmm can quickcheck also test things that are enum and bounded?
02:47:22 <rostayob> Kaidelong: enum and bounded are type classes, not data types
02:47:22 <moriramar> omnipotent @where...
02:47:24 <Kaidelong> oh right
02:47:29 <Kaidelong> then
02:47:37 <Kaidelong> it won't know which instance of Arbitrary to use
02:47:48 <Kaidelong> if something is enum, bounded, and alternative
02:47:51 <rostayob> Kaidelong: yes, you need to provide monomorphic types
02:48:01 <tdammers> RWH is nice
02:48:19 <Kaidelong> rostayob: not sure what the fact that they are type classes have to do with this
02:48:27 <Kaidelong> didn't really follow you at all sorry
02:48:49 <Kaidelong> oh do you mean that to test a proposition the proposition has to have monomorphic types?
02:48:59 <rostayob> Kaidelong: yes
02:49:02 <Kaidelong> okay
02:49:19 <keep_learning> rostayob: thank you
02:50:18 <Kaidelong> @instances-importing Arbitrary
02:50:19 <lambdabot> Couldn't find class `Arbitrary'. Try @instances-importing
02:50:30 <Kaidelong> think I misspelled it
02:50:51 <Kaidelong> @instances-importing Arbitary
02:50:51 <lambdabot> Couldn't find class `Arbitary'. Try @instances-importing
02:51:04 <rostayob> no you didn't, what's instances-importing?
02:51:06 <Kaidelong> or perhaps lambdabot just doesn't know
02:51:14 <Kaidelong> @instances-importing Ord
02:51:14 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:51:23 <Kaidelong> @instances-importing Alternative
02:51:23 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
02:51:49 <rostayob> keep_learning: oh it's Arbitrary not Alternative :P
02:51:57 <rostayob> I realized now I said alternative ehe
02:52:36 <keep_learning> rostayob: no problem :)
02:54:25 <applicative> erus` for your amusement, see http://hpaste.org/51522
02:54:34 <Kaidelong> @hoogle (Enum a, Bounded a) => Gen a
02:54:34 <lambdabot> Prelude maxBound :: Bounded a => a
02:54:35 <lambdabot> Prelude minBound :: Bounded a => a
02:54:35 <lambdabot> Test.QuickCheck sized :: (Int -> Gen a) -> Gen a
02:54:44 <Kaidelong> this makes me sad
02:55:15 <Kaidelong> @hoogle boundedEnumStdUniform
02:55:15 <lambdabot> No results found
02:55:16 <rostayob> Kaidelong: you can instantiate Arbitrary for Enum if you turn on the right language extensions
02:55:43 <rostayob> I mean you can do something like "instance Enum a => Arbitrary a ..."
02:55:58 <Kaidelong> yeah but the trouble is that instances don't play nice with scoping
02:56:03 <Kaidelong> so that's not a great solution
02:56:11 <rostayob> no you'd have overlapping instances all over the place eheh
02:56:34 <erus`> applicative: did you write that?
02:56:34 <rostayob> it's a really bad solution but you can do it eheh
02:56:39 <Kaidelong> a helper function with the type (Enum a, Bounded a) => Gen a would be nice to make your own instances
02:56:58 <applicative> yeah, just fiddling, trying to recover ancient knowledge I had
02:57:13 <Kaidelong> since there is a uniform distribution for any bounded enumeration
02:57:24 <Kaidelong> well for any enumeration I suppose
02:57:34 <rostayob> Kaidelong: well nothing stops you I guess
02:57:37 <Kaidelong> but in this case you would need the bounds to make toEnum total
02:58:08 <Kaidelong> I will take a look at the source code and see if I can implement that then
02:58:35 <rostayob> Kaidelong: well considering that Gen is "MkGen (StdGen -> Int -> a)"
02:58:39 <tdammers> quicksilver: right, now I get it :)
02:58:48 <tdammers> took a while to settle in
02:59:00 <Kaidelong> okay it shouldn't be terribly hard then
02:59:03 <rostayob> Kaidelong: no
02:59:08 <tdammers> Render [ Render () ]... duh
02:59:33 <tdammers> I was stuck in (Render (), [Render ()])
03:00:22 <mysticc> Any body using Control.Exception.finally here .... Why if does not handles the case when I externally send sigterm to the process .. It works for ctrl+c
03:00:50 <quicksilver> Kaidelong: it's almost fmap toEnum (choose (fromEnum minBound,fromEnum maxBound))
03:01:05 <quicksilver> except you need type annotations on the maxBound/minBound
03:01:27 <Kaidelong> you could probably just do it
03:01:34 <Kaidelong> elements [minBound..maxBound]
03:01:51 <Kaidelong> which suddenly makes this exercise uninteresting
03:02:05 <Kaidelong> although I suspect that's horrendously inefficient compared to using toEnum
03:02:47 <benmachine> Kaidelong: there's not a uniform distribution for any enumeration, cf. Integer
03:03:14 <Kaidelong> benmachine: What stops you from doing that in a wholly abstract way?
03:03:19 <Kaidelong> I know you couldn't implement it
03:03:30 <benmachine> there's no such thing as a uniform distribution on the integers
03:03:35 <Kaidelong> interesting
03:03:45 <Kaidelong> does it create a contradiction?
03:03:47 <benmachine> well, what would it look like?
03:04:12 <benmachine> you'd be exactly as likely to get 10 as a googol as skewes' number as graham's number
03:04:14 <quicksilver> benmachine: bounded Enumeration, he said
03:04:23 <Kaidelong> each integer would have an infinitessimal chance of being selected
03:04:32 <quicksilver> benmachine: there is a uniform distribution on bounded enums
03:04:32 <benmachine> quicksilver: going on 11:53:11 < Kaidelong> well for any enumeration I suppose
03:04:35 <quicksilver> ah
03:04:36 <quicksilver> :)
03:04:52 <Kaidelong> so it's not just that you can't get one for the integers in haskell?
03:04:54 <quicksilver> the "infinite uniform" distribut
03:05:00 <quicksilver> isn't really uniform in the normal sense
03:05:17 <quicksilver> it defies intuition because there isn't a sensible way to implement it
03:05:46 <benmachine> quicksilver: does it even make sense as an idea?
03:06:18 <tdammers> I'd expect an infinitely large probability for a number too large to represent on any given real-world hardware
03:06:41 <tdammers> so the first run would run out of memory or something
03:06:50 <everyonemines> a random number from 0 to infinity = infinity
03:07:06 <Kaidelong> no question that this couldn't be implemented
03:07:13 <everyonemines> so there you go, it's easy to implement
03:07:15 <quicksilver> benmachine: it might make sense as a formal distribution function but I'm not sure. It's a very long time ago I did any distribution theory.
03:07:24 <everyonemines> just return INF
03:07:31 <tdammers> infinity is not a number
03:07:42 <benmachine> infinity is not a natural number or an integer or a real number
03:07:44 <Kaidelong> everyonemines: But what on the infinitessimal chance that it returns a sensible number?
03:07:52 <benmachine> you can treat it as a number in some circumstances
03:07:54 <Kaidelong> I don't think that's really a working implementation
03:08:10 <everyonemines> you don't seem to understand infinity very well
03:08:36 <benmachine> Kaidelong: implementations aside, I don't think your distribution makes any sense
03:08:37 <Kaidelong> the chance of it returning any single number approaches 0
03:08:48 <benmachine> you can't have a chance approaching anything
03:09:04 <benmachine> chances just gotta *be*
03:09:09 <Kaidelong> well then it's fine, it doesn't make sense then
03:09:20 <benmachine> it doesn't make sense under any probability theory I've learnt
03:09:24 <benmachine> but there's much I haven't
03:09:31 <tdammers> hmm... if the probability for any particular number is nonzero...
03:09:32 <Kaidelong> in which case I suppose _|_ is a sensible implementation
03:10:03 <tdammers> then the probability for every other number must also be nonzero, otherwise it's not a uniform distribution
03:10:14 <tdammers> but then the total probability would be infinite
03:10:19 <benmachine> right
03:10:25 <tdammers> hence, the probability for any number must be zero
03:10:33 <quicksilver> benmachine: it doesn't, you're right. Here is a partial explanation of why not - http://cscs.umich.edu/~crshalizi/weblog/635.html
03:10:39 <tdammers> so you end up with a distribution that cannot ever return anything
03:10:45 <Kaidelong> that makes sense
03:11:04 <Kaidelong> so then you need bounds to have a uniform distribution
03:11:09 <Kaidelong> that's actually kind of relieving
03:11:29 <tdammers> probably, if you want it to be non-esoteric
03:11:53 <tdammers> maybe one could do mathematically interesting things with a uniform distribution over an infinite set, I don't know
03:12:07 <chrisdone> http://hackage.haskell.org/packages/archive/MonadCatchIO-mtl/0.3.0.4/doc/html/Control-Monad-CatchIO.html
03:12:16 <chrisdone> references MonadIO, which goes to the transformers package http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Control-Monad-IO-Class.html#t:MonadIO
03:12:30 <chrisdone> but transformers is not in the dependencies of monadcatchio-mtl http://hackage.haskell.org/package/MonadCatchIO-mtl-0.3.0.4
03:12:55 <qnikst> hello. is there any way to hadle 'error' call?
03:13:01 <benmachine> quicksilver: nice
03:13:10 <Kaidelong> qnikst: Only in IO code
03:13:23 <quicksilver> benmachine: it's obviously close enough to making sense that lots of people have discussed it / thought about it :)
03:13:23 <Kaidelong> but what are you doing, first?
03:13:26 <chrisdone> is this a hackage bug?
03:13:31 <Kaidelong> there is probably a way to avoid the error altogether
03:13:39 <benmachine> quicksilver: sure :)
03:13:49 <Kaidelong> post what you are doing at hpaste so we can take a look at it
03:13:54 <qnikst> I know, I'm trying to catch it with Exception.catch, but it was useless
03:14:06 <benmachine> chrisdone: mtl is a dependency, and mtl re-exports transformers
03:14:15 <benmachine> (nowadays, at least)
03:14:23 <qnikst> Kaidelong: I'm trying to decrypt file with AES decrypt package
03:14:59 <benmachine> Kaidelong: you *can* have uniform distributions over [0,1], though
03:15:06 <qnikst> error is thrown in AES package
03:15:24 <benmachine> (i.e. real numbers in some range)
03:16:10 <benmachine> conclusion: probability is weird
03:16:37 <Kaidelong> qnikst: what does your exception handler look like at this point?
03:17:50 <qnikst>             keyStorage <- catch (doesFileExist f >>= \x -> if x then loadBS f >>= loadFromBS else newUMStorage)
03:17:50 <qnikst>                        ( \(e::SomeException) -> newUMStorage)
03:18:07 <chrisdone> benmachine: oh. great. just great.
03:18:21 <tdammers> benmachine: it's not weird, really, or is it?
03:18:21 <benmachine> chrisdone: does this upset you?
03:18:22 * chrisdone tries not to stab someone
03:18:36 <benmachine> tdammers: I think it's weird, but I was never very good at probability
03:18:54 <Kaidelong> qnikst: Are you sure you shouldn't be using finally for that?
03:18:55 <tdammers> I mean, uniform probability over [0,1] means 0.1 probability that you'll get something in [x..x+0.1]
03:19:08 <tdammers> makes sense to me
03:19:14 <Kaidelong> or onException
03:19:24 <qnikst> Kaidelong: didn't think about it, thanks
03:19:47 <chrisdone> i wake up one morning and try to load my project in GHCi and i can't because of god damn mtl mismatches. it builds with cabal but doesn't load with cabal-dev ghci. FML
03:20:23 <Kaidelong> that said it is strange that e::SomeException is not being caught
03:20:33 <chrisdone> the hours i've wasted not working but fixing cabal dependency crap. honestly
03:20:35 <hvr> chrisdone: ...and then you went back to bad?
03:20:37 <chrisdone> rage
03:21:02 <benmachine> tdammers: right, but the probability that you get any specific value is 0
03:21:03 <chrisdone> hvr: i tell my boss i'm trying to write that feature but my build system is broken :)
03:21:30 <qnikst> Kaidelong: hm.. it seems i fail some time later
03:21:45 <qnikst> anyway thanks for advice about ''finally
03:21:59 <tdammers> yup
03:22:08 <tdammers> that's the weird part
03:22:17 <Kaidelong> qnikst: Where is the exception getting thrown from? pure code?
03:22:28 <qnikst> yes
03:22:30 <Kaidelong> you might have to use evaluate
03:22:42 <Kaidelong> not entirely sure on that, but it can't hurt to try it
03:22:53 <Kaidelong> evaluate :: a -> IO a
03:22:53 <qnikst> hmm. loadBS and loadFromBS are inside IO
03:23:02 <qnikst> so I need no evaluate here
03:23:05 <tdammers> the key to understanding is how real numbers aren't countable
03:23:30 <tdammers> i.o.w., you cannot find the 'next larger' real number for any given real number
03:23:31 <benmachine> tdammers: I understand the mathematics, but I still think it's weird that in some sense an event of probability 0 is guaranteed to happen
03:23:39 <tdammers> :o)
03:23:57 <benmachine> (also, you cannot find the next larger rational number, but they're still countable :) )
03:24:07 <tdammers> touceh
03:24:12 <tdammers> s/eh/he/
03:24:51 <qnikst> Kaidelong: it was another error, I've catch exception in loading but saving was still with errors
03:25:40 <benmachine> hmm, one can come up with a uniform distribution on rationals in [0,1] that works intuitively, but I guess countable additivity breaks it anyway
03:25:40 <ddarius> benmachine: Come over to us Finitist.  The water's warm.
03:25:56 <Kaidelong> qnikst: What library are you using?
03:26:04 <Kaidelong> wel, what hackage package
03:26:12 <benmachine> ddarius: ew, no thx
03:26:14 * benmachine <3 infinity
03:26:46 <qnikst> Kaidelong: http://hackage.haskell.org/package/AES
03:27:01 <tdammers> I read about this one mathematician guy who didn't believe in computers... said something like, computers can only deal with finite things, but those don't interest me
03:27:26 <milo_> does anyone know if the is a version of assert which resides in the IO monad? (GHC)
03:28:19 <milo_> or how one would lift assert properly into it
03:28:31 <ddarius> tdammers: I'm sure all his proofs were infinitely long.
03:28:39 <Kaidelong> benmachine: I have no idea how that would work, could you spoil for me?
03:28:57 <benmachine> Kaidelong: which, the rational thing? it doesn't :P but it feels like it should
03:29:10 <Kaidelong> It doesn't feel like it should for me
03:29:17 <hvr> ddarius: is there something like non-terminating proofs?
03:29:20 <tdammers> ddarius: I'm still waiting for the first one
03:29:21 <Kaidelong> it seems like you'd need a uniform distribution for integers to make it work
03:29:34 <tdammers> I guess we'll never no
03:29:40 <tdammers> s/no/know/
03:30:06 <Kaidelong> qnikst: I'm stumped. Sorry, and good luck~
03:30:46 <qnikst> thanks
03:30:56 <benmachine> Kaidelong: oh, well I could imagine it working like on the reals - the probability of getting a rational in [0, 1/2] being 1/2
03:31:03 <benmachine> etc.
03:31:06 <Kaidelong> yeah I can see it working on the reals
03:31:09 <Kaidelong> but not on rationals
03:31:19 <benmachine> why's it different?
03:31:20 <benmachine> well
03:31:21 <benmachine> I know why
03:31:26 <benmachine> but why is it *obviously* different :P
03:31:31 <Jafet> I believe you'd need an infinite number of random bits to uniformly pick a rational in [0,1].
03:31:49 <Kaidelong> because you can't encode all the rationals using all the integers
03:31:50 <benmachine> Jafet: sure, just like with the reals
03:31:53 <Veinor> and you don't need an infinite number of bits to pick a real?
03:31:53 <Kaidelong> err
03:31:57 <Kaidelong> you can't encode all the reals
03:31:58 <Kaidelong> I mean
03:32:03 <Kaidelong> but you can for the rationals
03:32:12 <Jafet> Well, the rationals are enumerable, so it's a bit more complicated.
03:32:18 <Eduard_Munteanu> tdammers: Zeilberger?
03:32:24 <Kaidelong> so if you manage to make a uniform distribution for the rationals
03:32:38 <Kaidelong> you'd have gotten one for the integers by neccessity
03:32:55 <Eduard_Munteanu> Actually, probably not, he's a finitist, but he said something along the lines of "theorems provable by humans are trivial"
03:33:35 <Kaidelong> for some definitions of trivial all provable theorems are trivial
03:33:47 <Eduard_Munteanu> Kaidelong: yeah, that too
03:33:53 <benmachine> *for unhelpful definitions of trivial
03:33:55 <Jafet> For some definitions of provable
03:33:56 <benmachine> >_>
03:34:19 <flux> benmachine, *for trivial definitions of unhelpful?
03:34:25 <benmachine> :P
03:34:43 <benmachine> > fix "for trivial definitions of \""
03:34:44 <lambdabot>   Couldn't match expected type `a -> a'
03:34:44 <lambdabot>         against inferred type `[GHC.T...
03:34:45 <benmachine> er
03:34:50 <benmachine> > fix ("for trivial definitions of \"" ++)
03:34:52 <lambdabot>   "for trivial definitions of \"for trivial definitions of \"for trivial defi...
03:34:55 <tdammers> all provably provable theorems are theoretically proven already
03:35:20 <benmachine> tdammers: what about the weaker version of goldbach's conjecture?
03:35:29 <benmachine> er wait
03:35:33 <benmachine> let me look this up
03:35:38 <tdammers> :D
03:35:43 <ion> > fix ((++) "for trivial definitions of " . show)
03:35:45 <lambdabot>   "for trivial definitions of \"for trivial definitions of \\\"for trivial de...
03:35:48 <Eduard_Munteanu> All constructively provably provable theorems ... maybe.
03:35:52 <Eduard_Munteanu> :)
03:36:20 <benmachine> yeah, goldbach's weak conjecture is true for sufficiently large numbers
03:36:24 <benmachine> so it's certainly provable
03:36:30 <benmachine> but we don't know if it's true or false... yet
03:37:00 <tdammers> "true for sufficiently large numbers" /= "provable"
03:38:01 <benmachine> tdammers: well, every case below that takes finite time to check
03:38:30 <benmachine> you could write a program that would prove goldbach's weak conjecture (probably even with current technology)
03:38:45 <benmachine> it would just take ages
03:38:47 <tdammers> but we don't know if an upper bound exists
03:38:56 <Jafet> What's the upper bound now?
03:39:05 <tdammers> it might, but if it doesn't, the calculation would never terminate
03:39:14 <benmachine> tdammers: we do! http://en.wikipedia.org/wiki/Goldbach%27s_weak_conjecture
03:39:16 <Jafet> I recall there is a finite bound now
03:39:27 <Jafet> Not sure if it's smaller than Skewes' constant though
03:39:42 <benmachine> without the Riemann hypothesis, it's about e^3100, according to that article
03:39:50 <Jafet> Nope, looks like it ain't
03:40:07 <benmachine> I thought skewes' number was e^e^something
03:40:13 <benmachine> or do you mean the updated ones
03:40:34 <Eduard_Munteanu> Could there be true propositions having infinite proofs?
03:40:43 <benmachine> the original skewes' number was e^e^e^79
03:40:57 <Jafet> All proofs are finite.
03:41:01 <benmachine> Eduard_Munteanu: I think by definition no
03:41:02 <Kaidelong> Eduard_Munteanu: I suppose they would be true but not provably so
03:41:14 <Jafet> Unless you admit transfinite constructions in your logic
03:41:16 <tdammers> in that case, yes, it's theoretically proven already
03:41:22 <Kaidelong> so if you have a system of logic where truth is equated to your ability to prove things
03:41:25 <tdammers> we just have to wait until the run finishes
03:41:26 <tdammers> :P
03:41:34 <benmachine> tdammers: it's strange to call a proposition proven when we don't know if it's true
03:41:35 <Kaidelong> then it would not be true there
03:41:47 <tdammers> theoretically proven
03:41:47 <Eduard_Munteanu> Well, assuming a non-constructive logic.
03:41:52 <tdammers> in a lazy-evaluation way
03:41:54 <Kaidelong> I don't think it'd be false either. Not sure if you'd be able to talk about it at all.
03:41:56 <Jafet> If you mean a proposition that is true but its proof would be infinitely long in a system, then sure
03:42:13 <jacobian> <Eduard_Munteanu> Could there be true propositions having infinite proofs?
03:42:14 <jacobian> Yes
03:42:14 <Kaidelong> actually yes I guess it would be false
03:42:16 <tdammers> there is an upper bound, so it's not going to be infinite
03:42:17 <jacobian> You can have infinite proofs
03:42:22 <benmachine> tdammers: I guess we only disagree on terminology then
03:42:26 <Jafet> I think the Presburger system has some examples that are only provable with the axiom of induction
03:42:26 <tdammers> :)
03:42:27 <Eduard_Munteanu> Uh, that's kinda grim.
03:42:29 <jacobian> You can have unbounded infinite proofs
03:43:03 <Eduard_Munteanu> Jafet: that's definitional, no?
03:43:07 <jacobian> Parks principle essentially assures the ability to produce the next proof step on demand.
03:43:17 <Kaidelong> I think there are still useful things you can do with infinite proofs with systems of infinitary logic
03:43:18 <Eduard_Munteanu> I mean, you can only define multiplication for finitely many cases.
03:43:18 <jacobian> since you can always make the next step, the proofs are infinite
03:43:22 <Kaidelong> but since you can't check infinite proofs
03:43:41 <jacobian> Yes, you can check some classes of finitely presentable infinite proofs
03:43:41 <Kaidelong> you can't consider it a proof in constructivist logic, I don't think
03:43:49 <jacobian> I think you can
03:43:57 <Eduard_Munteanu> Wait, I don't mean that.
03:44:12 <Eduard_Munteanu> I actually mean, are there propositions for which the smallest proof is infinite?
03:44:22 <Jafet> Eduard_Munteanu: what is a proof?
03:44:22 <jacobian> Yes
03:44:27 <Eduard_Munteanu> (assuming that makes sense, I'm not a model theory expert at all)
03:45:09 <Kaidelong> hmm is an infinite proof really a proof at all?
03:45:15 <Eduard_Munteanu> Jafet: we could even take the Curry-Howard view
03:45:22 <Eduard_Munteanu> Actually, I'm more familiar with that.
03:45:32 <Kaidelong> since you can't actually use it to prove its associated proposition
03:45:37 <jacobian> The Curry-Howard view is a good way to think about infinite proofs
03:45:41 <cwl> guard (isValid s)
03:45:43 <cwl> return s
03:45:52 <Eduard_Munteanu> Are there types whose inhabitants can only be expressed as non-closed terms?
03:46:03 <cwl> the question is, does  return s has type m ()
03:46:04 <Eduard_Munteanu> *inhabited types
03:46:15 <benmachine> cwl: iff s has type ()
03:46:25 <benmachine> (which it probably doesn't)
03:46:25 <Jafet> Okay, I won't try to see the corresponding proof for Omega.
03:46:45 <cwl> getValidPassword :: MaybeT IO String
03:46:49 <jacobian> Well, for instance, take the equality of two programs over stream transforming programs.
03:46:57 <jacobian> The output of the two terms will be some infinite stream
03:46:57 <cwl> getValidPassword = do s <- lift getLine
03:47:02 <Kaidelong> Eduard_Munteanu: I don't think so. Even with types like "the set of all infinite binary strings" the ones you can work with in practice have finite definitions.
03:47:08 <jacobian> To demonstrate that they are the same we need to show they are the same infinitely
03:47:09 <cwl> benmachine: does s have type ()? I don't think so
03:47:20 <benmachine> cwl: no, it has type String
03:47:23 <jacobian> The proof will have to have some cyclic character to it if it is to be finitely presentable.
03:47:32 <Kaidelong> so it's definitely not "only" inhabited by non-closed values
03:47:32 <benmachine> so return s has type MaybeT IO String
03:47:35 <jacobian> However, each proof step can be demanded by some inspecting program, infinitely
03:47:40 <cwl> do s <- lift getLine
03:47:47 <cwl>     guard (isValid s)
03:47:49 <cwl> return s
03:47:54 <Kaidelong> I wouldn't be surprised if the only type only inhabited by non-closed values would be Void
03:47:57 <benmachine> cwl: at a wild guess, check your indentation
03:48:06 <benmachine> cwl: don't use tabs, and make sure the statements of the do line up
03:48:08 <Jafet> jacobian: of course, you'd need a meta-proof of that
03:48:08 <cwl> benmachine: sorry
03:48:10 <Eduard_Munteanu> jacobian: does the proof have to "progress" in some way?
03:48:16 <jacobian> Yeah
03:48:17 <cwl> do s <- lift getLine
03:48:24 <benmachine> cwl: I'm offering advice, you've nothing to apologise for :P
03:48:26 * Jafet doesn't know model theory either.
03:48:28 <Eduard_Munteanu> Ah, hm.
03:48:28 <jacobian> I mean, not necessarily, but if you want a sound logic, it does.
03:48:29 <cwl>     guard (isValid s)
03:48:34 <cwl>     return s
03:48:43 <jacobian> Haskell for instance allows you to inhabit types with loops :)
03:48:55 <Eduard_Munteanu> Kaidelong: yeah, tho' I'm viewing it as a convenient representation for math at large.
03:48:55 <Botje> cwl: don't paste here :) your guard should start at the same column as the s
03:49:17 <Kaidelong> well I think it depends on what system of logic you want to work in
03:49:19 <cwl> benmachine: in one line do {s <- lift getLine; guard (isValid s); return s}
03:49:22 <Eduard_Munteanu> jacobian: Haskell doesn't count, it's inconsistent :)
03:49:35 <benmachine> cwl: what about it?
03:49:35 <Kaidelong> in classical logic you can assume your thing is true even though you could never actually check the proof, I suppose
03:49:52 <Kaidelong> by declaring that it's an axiom
03:49:52 <cwl> benmachine: guard has type Bool -> m ()
03:49:55 <jacobian> But that's even more broad than just allowing coinductive proofs for instance.
03:50:01 <benmachine> cwl: right
03:50:04 <cwl> benmachine: but mzero don't match m ()
03:50:12 <jacobian> Allowing coinductive equivalence relations still has a very constructive character
03:50:13 <benmachine> :t mzero
03:50:14 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
03:50:17 <benmachine> sounds like it matches to me
03:50:20 <Eduard_Munteanu> Yeah.
03:50:35 <Kaidelong> @ty guard
03:50:36 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
03:50:37 <Eduard_Munteanu> Well, we can only talk about the existence of such theorems, if I'm not mistaken.
03:50:50 <cwl> in this case, getValidPassword, mzero is MaybeT $ return Nothing
03:51:36 <Eduard_Munteanu> Anyway, this is interesting: not only we (could) have theorems where the smallest proof would be intractable, but it could also be infinite.
03:51:45 <cwl> mzero has type MaybeT IO String?
03:51:52 <Kaidelong> well MaybeT should be an instance of MonadPlus if the transformer is an instance of MonadPlus too
03:51:56 <Kaidelong> err
03:52:01 <Kaidelong> transformed-over... monad
03:52:03 <Kaidelong> inner monad?
03:52:15 <Jafet> Unleash thine inner monad
03:52:28 <Eduard_Munteanu> The fun thing is, intuitionistic logic would discard such cases.
03:52:28 <jacobian> I'm not a model theory expert, and I have to admit to being confused about the small model property and how it relates.
03:52:30 <Kaidelong> which IO isn't
03:52:33 <Kaidelong> but String is a monoid
03:52:37 <Kaidelong> so it could still work
03:52:51 <Eduard_Munteanu> (I guess)
03:52:51 <cwl> @_@
03:52:59 <benmachine> Kaidelong: MaybeT is MonadPlus regardless of the underlying monad
03:53:07 <Eduard_Munteanu> LEM--
03:53:11 <Eduard_Munteanu> :)
03:53:16 <Kaidelong> benmachine: Mmm, how does mplus work then?
03:53:16 <benmachine> cwl: mzero *can* have type MaybeT IO String
03:53:18 <qnikst> Kaidelong: I've found that finally doesn't catch ''error'' call
03:53:23 <benmachine> Kaidelong: takes the first non-Nothing
03:53:25 <jacobian> I think the real danger with these infinite objects is that it's sort of impossible to have an intentional type theory.
03:53:49 <jacobian> I'm not sure what I mean by sort of, but there are probably ways to chew off fragments with decidable equivalence.
03:53:54 <benmachine> cwl: mzero :: forall m a. MonadPlus m => m a -- in particular, we can take m = MaybeT IO, and a = String
03:53:57 <cwl> benmachine: do you mean mzero can *also* have type MaybeT IO ()?
03:54:04 <benmachine> yep
03:54:37 <Kaidelong> benmachine: So it works like Left?
03:54:44 <benmachine> Kaidelong: it works like Nothing :P
03:55:14 <Kaidelong> the monoid instance for Left I mean
03:55:21 <Kaidelong> as opposed to the monoid instance for Maybe
03:55:22 <cwl> @type mplus x y
03:55:23 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
03:55:23 <lambdabot>     In the first argument of `mplus', namely `x'
03:55:23 <lambdabot>     In the expression: mplus x y
03:55:25 <Kaidelong> err
03:55:26 <Kaidelong> First
03:55:28 <Kaidelong> not Left
03:55:30 <benmachine> it works like the MonadPlus for Maybe
03:55:33 <Kaidelong> I got them confused
03:55:34 <benmachine> which yes, is like First
03:55:42 <cwl> @type let x="", y="" in mplus x y
03:55:43 <lambdabot> parse error on input `,'
03:55:49 <cwl> @type let x=""  y="" in mplus x y
03:55:49 <lambdabot> parse error on input `='
03:56:01 <benmachine> @type let x = ""; y = "" in mplus x y
03:56:02 <lambdabot> [Char]
03:56:13 <cwl> @type let (x,y)=("","") in mplus x y
03:56:14 <lambdabot> [Char]
03:56:17 <Kaidelong> hmm why have the Monoid instance different from the MonadPlus instance?
03:56:38 <benmachine> Kaidelong: the Monoid instance is more capable
03:56:55 <cwl> @type let (x,y)=(MaybeT $ return "",MaybeT $ return "") in mplus x y
03:56:56 <lambdabot> Not in scope: data constructor `MaybeT'
03:56:56 <lambdabot> Not in scope: data constructor `MaybeT'
03:56:57 <benmachine> in particular, Monoids have kind *, whereas MonadPlus is a class for * -> *
03:57:28 <Eduard_Munteanu> jacobian: do you think lack of LEM would rule such things out by definition?
03:57:33 <benmachine> cwl: Monad m => MaybeT m String
03:57:44 <Kaidelong> right but you can get the neccessary information about the first * by constraining its type
03:58:04 <Kaidelong> just like you do for the Maybe monoid
03:58:07 <cwl> @type getLine
03:58:08 <lambdabot> IO String
03:58:12 <Kaidelong> oh wait
03:58:14 <Kaidelong> that's right
03:58:15 <Kaidelong> you can't
03:58:18 <Eduard_Munteanu> I'm assuming you can't do this constructively, but might be wrong in my interpretation.
03:58:25 <Kaidelong> I see now!
03:58:31 <Kaidelong> thanks benmachine
03:58:34 <benmachine> :
03:58:36 <benmachine> er
03:58:36 <benmachine> :)
03:58:58 <Kaidelong> same problem you run into with tying to make Set a monad then
03:59:02 <cwl> @type lift
03:59:03 <lambdabot>     Ambiguous occurrence `lift'
03:59:03 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
03:59:03 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
03:59:03 <Kaidelong> trying even
03:59:26 <rostayob> Kaidelong: Set a monad?
03:59:30 <jacobian> Eduard_Munteanu: I'm not sure what the implications of adding LEM are.
03:59:50 <rostayob> set is not even a monoid
03:59:53 <rostayob> ah no it is
03:59:56 <jacobian> Eduard_Munteanu: I've heard vaguely about semi-constructive restricted LEM
04:00:04 <benmachine> Kaidelong: similar, yes
04:00:07 <jacobian> I really know nothing about it though
04:00:21 <Kaidelong> Although in the case of Set it is related to Set's implementation details
04:00:29 <Kaidelong> rather than the fundamental nature of a set
04:00:42 <Eduard_Munteanu> Ah. Well, for one thing, Agda + LEM is pretty much classical logic AFAIK.
04:01:01 <benmachine> Kaidelong: well, the fundamental nature of a set makes sets of arbitrary types not terribly sensible
04:01:04 <ddarius> Classical propositional (and I believe a similar statement for first order logic holds as well) can be embedded into intuitionistic propositional logic.
04:01:15 <ddarius> This gives a constructive way of explain LEM.
04:01:18 <benmachine> unless you go with type Set a = a -> Bool
04:01:44 <ddarius> Parigot's λµ-calculus is the place to go.
04:02:46 <Eduard_Munteanu> ddarius: yeah, I've seen something like that, you can just wrap classical propositions into Not Not
04:02:48 <jacobian> Has  λµ-calculus been extended to dependent types?
04:02:53 <Kaidelong> benmachine: A monad for sets still makes perfect sense, conceptually
04:03:08 <Kaidelong> in the Set a = a -> Bool case
04:03:13 <Kaidelong> it would even be straightforward
04:03:32 <benmachine> actually I think type Set a = a -> Bool isn't even a functor
04:03:43 <Kaidelong> oh that's right
04:03:47 <dibblego> it has contramap
04:03:47 <Kaidelong> monads have to be functors
04:04:28 <rostayob> Kaidelong: well every monad is a functor but the typeclass is not "Functor m => Monad m"
04:04:41 <Veinor> @djinn (a -> b) -> ((a -> Bool) -> (b -> Bool))
04:04:41 <lambdabot> f _ _ _ = False
04:04:45 <benmachine> rostayob: anything that can be made Monad can also be made Functor
04:04:47 <Kaidelong> so yeah I guess you simply can't make Set a monad
04:04:54 <Veinor> yep :P
04:04:59 <benmachine> wow, djinn cheats :o
04:04:59 <Kaidelong> hi Veinor
04:05:03 <benmachine> oh
04:05:05 <benmachine> no it doesn't
04:05:06 <benmachine> fair
04:05:12 <benmachine> not fmap though :P
04:05:18 <dibblego> it has contramap :: (b -> a) -> f a -> f b -- to be clear
04:05:26 <benmachine> dibblego: right
04:05:34 <Eduard_Munteanu> http://www.galois.com/~emertens/Classical.html   -- that sort of stuff
04:05:35 <Veinor> does contramap have an associated class?
04:05:39 <rostayob> benmachine: yes ofc, but every Monad isn't automatically a Functor in haskell
04:05:39 * benmachine wonders vaguely if f (b -> a) -> f a -> f b is an interesting structure
04:05:44 <dibblego> not in the GHC libs no
04:05:53 <benmachine> or (b -> f a) -> f a -> f b
04:05:53 <Eduard_Munteanu> And you can even get a monad from that.
04:06:02 <Veinor> google says 'cofunctor'
04:06:13 <dibblego> "cofunctor" is the wrong name
04:06:21 <benmachine> cofunctors are functors, so I've herad
04:06:23 <benmachine> *heard
04:06:27 <dibblego> it has been corrected to "Contravariant" iirc
04:06:33 <Veinor> ah, ok
04:06:55 <Kaidelong> well it's a contravariant functor as opposed to a covariant functor in fact, isn't it?
04:07:06 <dibblego> http://hackage.haskell.org/packages/archive/category-extras/0.44.1/doc/html/Control-Functor-Contravariant.html
04:07:09 <Kaidelong> but I guess you can't call both Functor
04:07:32 <dibblego> "Co" is used to mean categorical dual, as in Comonad
04:11:07 <cwl> how to instances Show for a (MaybeT m a)
04:11:28 <cwl> I cannot pattern match  (m Just x)
04:11:40 <dibblego> Copointed m =>
04:11:50 <benmachine> nah
04:11:55 <benmachine> Show (m a), probability
04:11:56 <benmachine> er
04:11:57 <benmachine> probably
04:12:38 <Kaidelong> cwl: No idea why that would be an instance of show
04:13:44 <cwl> Kaidelong: I have a function has MaybeT IO String as result, if i run it in ghci, it raise up an error
04:14:04 <rostayob> cwl: well paste the function somewhere and show us ehe
04:15:16 <benmachine> cwl: try running it
04:15:20 <benmachine> runMaybeT thing
04:15:47 <benmachine> I mean, try running it with runMaybeT
04:16:14 <hpaste_> cwl pasted “maybet” at http://hpaste.org/51523
04:16:39 <cwl> benmachine: rostayob
04:17:17 <benmachine> cwl: runMaybeT askPassword
04:17:23 <rostayob> cwl: yes you have to run it
04:17:40 <cwl> aha
04:17:55 <rostayob> cwl: the ghci prompt runs IO functions
04:17:55 <benmachine> (also, why not use the MaybeT from the transformers package? saves you having to define it yourself)
04:18:32 <rostayob> cwl: and calls show and the others :P
04:18:34 <cwl> benmachine: I am learning step by step
04:19:46 <rostayob> *on the others
04:20:49 <hpc> rostayob: strictly speaking, it runs IO /actions/, and calls print on the rest
04:22:14 <rostayob> hpc: well, it runs everything that is :: IO a. Is "actions" the correct term for those?
04:22:27 <hpc> rostayob: yeah; a function has to have (->) in the type
04:22:49 <rostayob> hpc: does it? I always tought that everything can be called "function" in haskell
04:23:03 <hpc> everything is a value; functions are values
04:23:15 <hpc> it's easy to get sloppy with the terminology though
04:23:41 <cwl> value <- msum $ repeat getValidPassword
04:23:43 <benmachine> conal wrote a blog post about this: http://conal.net/blog/posts/everything-is-a-function-in-haskell
04:23:45 <rostayob> hpc: well then why is the (->) required to qualify :P?
04:23:58 <benmachine> rostayob: because it's a function arrow
04:23:59 <cwl> ghc knows where top stop !!!
04:24:12 <benmachine> cwl: clever, right?
04:24:13 <cwl> how clever
04:24:23 <cwl> benmachine: but how
04:24:23 <hpc> wow, conal.net is still crazy slow
04:24:44 <rostayob> benmachine: well, aren't "main" or "minBound" or whatever functions?
04:24:45 <cwl> foldr mplus mzero
04:24:50 <benmachine> cwl: because of the way the msum thing works
04:24:54 <benmachine> rostayob: no
04:25:00 <cwl> @src foldr
04:25:01 <lambdabot> foldr f z []     = z
04:25:01 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:25:05 <benmachine> rostayob: why would they be?
04:25:09 <benmachine> is False a function?
04:25:10 <hpc> :t repeat
04:25:10 <lambdabot> forall a. a -> [a]
04:25:38 <rostayob> benmachine: so how do you define something like "minBound"? a polymorphic value/variable?
04:25:45 <benmachine> rostayob: yes
04:25:51 <rostayob> well definitely not a variable
04:26:04 <cwl> mzero mplus (m1 mplus (m2 ...))
04:26:09 <benmachine> well, what people mean by 'variable' is, well, variable
04:26:28 <mux> :t msum
04:26:28 <rostayob> benmachine: yeah, so I always thought that variable is always inappropriate for haskell
04:26:29 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
04:26:43 <mux> @src msum
04:26:43 <lambdabot> msum =  foldr mplus mzero
04:27:54 <benmachine> rostayob: sometimes the term 'variable' is used to refer to function parameters
04:28:00 <benmachine> on the basis that they vary between calls to the funcion
04:28:03 <benmachine> even if not during them
04:28:32 <hpc> huh
04:28:42 <hpc> it occurs to me that every MonadPlus should also be an Alternative
04:28:59 <hpc> where empty = mzero, (<|>) = mplus
04:29:20 <benmachine> hpc: yeah, much like the Monad/Applicative situation
04:29:50 <rostayob> benmachine: I quickly read Conal post, it makes sense I guess
04:29:59 <erus`> you guys care more about theory than implementation
04:30:07 <benmachine> rostayob: the haskell report does actually use the word 'variable'
04:30:08 <Eduard_Munteanu> rostayob: minBound is a typeclass method
04:30:17 <benmachine> Eduard_Munteanu: is it really a method?
04:30:26 <Eduard_Munteanu> IIRC yes.
04:30:37 * Eduard_Munteanu looks at enum
04:30:41 <hpc> benmachine: sure; it's a value that is different for each instance
04:30:58 <hpc> it may happen to also be a function if the chips fall that way
04:31:15 <Botje> erus`: you say that like it's a bad thing :]
04:32:01 * hpc is often confused by theory, and has to find an application to see what it does
04:32:03 <Eduard_Munteanu> benmachine: yeah, it is, but it's in Bounded :)
04:32:03 <cwl> > foldr (||) True : (repeat False)
04:32:03 <erus`> it is when you spend all day trying to got some convoluted monad to compile rather than writing something that actually does something
04:32:04 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool] -> GHC.Bool.Bool'
04:32:04 <lambdabot>         aga...
04:32:05 <benmachine> hpc: well, if you choose to define method like that then fine, but the analogy with OO methods breaks down a bit
04:32:10 <cwl> > foldr (||) (True : (repeat False))
04:32:11 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
04:32:12 <lambdabot>         against inferred type ...
04:32:17 <Eduard_Munteanu> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:minBound
04:32:22 <cwl> > foldr (||) (True : (repeat False)) False
04:32:22 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
04:32:23 <lambdabot>         against inferred type ...
04:32:29 <cwl> @type foldr
04:32:29 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
04:32:33 <benmachine> erus`: I care about fun, and theory tends to be fun
04:32:33 <hpc> > foldr (||) False (True : repeat False)
04:32:34 <lambdabot>   True
04:32:38 <benmachine> other people care about other stuff
04:32:43 <cwl> > foldr (||) False (True : (repeat False))
04:32:44 <lambdabot>   True
04:32:46 <hpc> cwl: foldr plus zero
04:32:59 <hpc> er, foldr plus zero list
04:33:29 <cwl> foldr (+) 0 [1..10]
04:33:35 <cwl> > foldr (+) 0 [1..10]
04:33:35 <lambdabot>   55
04:34:03 <hpc> @src msum
04:34:03 <lambdabot> msum =  foldr mplus mzero
04:34:06 <hpc> @src mconcat
04:34:06 <lambdabot> Source not found. I am sorry.
04:34:09 <hpc> :(
04:34:38 <hpc> mconcat = foldr mappend mempty -- it shows up a lot, especially among things with monoidal properties
04:34:48 <rostayob> mconcat = foldr mappend mempty?
04:34:50 <rostayob> oh.
04:35:04 <rostayob> 10 seconds late.
04:35:20 <cwl> > foldr mplus mzero Nothing : (Just 1) : repeat Nothing
04:35:21 <JuanDaugherty> hackage should send out link to a digest as a tweet. I stopped following it because it was too much shit.
04:35:21 <lambdabot>   Couldn't match expected type `[m a]'
04:35:21 <lambdabot>         against inferred type `Data.Ma...
04:35:30 <cwl> > foldr mplus mzero (Nothing : (Just 1) : repeat Nothing)
04:35:31 <lambdabot>   Just 1
04:35:33 <hpc> foldr (.) id -- composes a list of (a -> a) into a single (a -> a)
04:35:53 <cwl> > foldr mplus mzero (Nothing : (Just 1) : repeat Just 2)
04:35:53 <lambdabot>   Couldn't match expected type `t -> [Data.Maybe.Maybe a]'
04:35:53 <lambdabot>         against in...
04:36:12 <cwl> > foldr mplus mzero (Nothing : (Just 1) : (repeat (Just 2))
04:36:13 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
04:36:15 <cwl> > foldr mplus mzero (Nothing : (Just 1) : (repeat (Just 2)))
04:36:16 <lambdabot>   Just 1
04:36:31 <benmachine> mempty = mconcat []
04:36:36 <benmachine> mappend x y = mconcat [x,y]
04:36:44 <benmachine> define everything in terms of mconcat!
04:36:54 <benmachine> subject to the laws that erm
04:36:55 <hpc> play around with it in ghci so you don't get caleskell screwing you up, and so the channel isn't flooded with bot text
04:36:56 <benmachine> hmm
04:37:11 <benmachine> mconcat . map mconcat = mconcat . concat
04:37:15 <benmachine> I think that's right
04:37:48 <hpc> benmachine: that looks similar to the functor law
04:37:55 <benmachine> hpc: I know right
04:38:12 <hpc> >todo study mconcat . map mconcat = mconcat . concat -- there's something cool here
04:38:16 <hpc> whoops, wrong channel
04:38:59 * benmachine tries to work out if that implies associativity *and* identity
04:39:18 <Kaidelong> to me that just looks like associativity
04:39:47 <Kaidelong> err in response to hpc's out of channel comment
04:39:50 <benmachine> oh I think I need mconcat [x] = x
04:39:55 <Kaidelong> not benmachine's
04:40:16 <rostayob> identity as in x `mappend` mempty = x?
04:40:53 <benmachine> mappend mempty x = mconcat [mempty, x] = mconcat [mconcat [], mconcat [x]] = mconcat (map mconcat [[],[x]]) = mconcat (concat [[],[x]]) = mconcat [x] = x
04:41:00 <benmachine> yes
04:41:12 <rostayob> well isn't that one of the monoid laws?
04:41:38 <benmachine> sure
04:41:44 <benmachine> I'm testing a reformulation of the monoid laws
04:42:38 <benmachine> instead of defining mempty and mappend subject to identity and associativity, you can just define mconcat, subject to mconcat . map mconcat = mconcat . concat, and mconcat [x] = x
04:43:56 <magicman> Does that give you associativity?
04:44:19 <magicman> Ah, yes, it does. I see.
05:10:26 <Botje> kind-of OT: is anyone aware of type inference for const types (a la c++)?
05:11:07 <tdammers> does a const concept even make sense in a pure functional language?
05:12:18 <Botje> it's the closest analog I can think of
05:12:28 <Botje> that and up/downcasting in OO
05:13:14 <quicksilver> Botje: well C++ compilers do check const, which is not very different from inferring it in terms of the work you have to do
05:13:21 <quicksilver> they just don't actually infer it
05:14:26 <Botje> i'm currently working on type inference for a language that makes a distinction between local and remote objects
05:14:59 <Botje> when you pass objects as arguments to a remote method call, they're turned into references
05:15:11 <Botje> but primitive values are passed as-is
05:15:47 <Botje> I'm thinking of making objects subclasses of references
05:15:51 <b_jonas> Botje: is that done in a way that the distinction is user-visible?
05:15:55 <Botje> but not sure how well it will work with inference
05:16:08 <Botje> b_jonas: yes. you cannot use the dot operator on a reference
05:16:30 <Botje> you can only send asynchronous messages to a reference
05:17:36 <frerich> I'm sorry for starting such a bikeshedding-quality discussion, but I recently wondered: does the distinction about 'pure' and 'impure' functions which e.g. RWH gives actually make sense? By now, it seems to me that there are only pure functions. You cannot ever execute monadic actions - you can only chain them to form new actions. The only part which actually executes an action is the run time system. So all the
05:17:36 <Botje> and I thought it was similar to const values, in that you cannot do mutation on const values
05:17:37 <frerich>  functions you write in Haskell are pure - they just happen to yield values of the IO monad at times.
05:18:33 <Botje> frerich: writing IO code feels like it's impure :]
05:19:32 <benmachine> frerich: but the advantages of purity are arguably lost somewhat in IO-heavy code
05:19:35 <Jafet> RWH, the real-world book about Haskell
05:19:57 <benmachine> frerich: and anyway, execution *is* impure, and *is* integral to haskell
05:20:09 <Jafet> It introduces haskell to people from the real world
05:20:44 <tdammers> benmachine: that's kind of a given with I/O, isn't it? I mean, I/O consists of side effects by definition, so it's kind of impossible to avoid them
05:21:03 <benmachine> tdammers: probably you're right, although some people believe we can do better than we do at the moment
05:21:22 <benmachine> frerich: see also http://conal.net/blog/posts/the-c-language-is-purely-functional
05:34:32 <geheimdienst> i wonder if it would help to have a notion of "half-pure" functions that are referentially transparent within one execution of the program, but may change from one program execution to the next
05:34:59 <geheimdienst> ... examples would be getArgs, getEnv, reading "what system am i running on", "how many cores do i have", etc
05:35:35 <benmachine> geheimdienst: getEnv can change
05:35:43 <benmachine> and due to withArgs, so can getArgs >_>
05:36:07 <benmachine> plus, conal argues (and may be right) that distributed execution will happen one day
05:36:39 <Maxdamantus> or .. Float's *
05:36:44 <Maxdamantus> (I think)
05:37:25 <geheimdienst> i'm pretty sure changing getEnv is a hack. iirc you have to write around in some half-binary file in /proc. i wouldn't expect any program to handle it correctly that its environment changes during execution
05:37:56 <benmachine> @hoogle setEnv
05:37:57 <lambdabot> No results found
05:37:59 <benmachine> hm
05:38:14 <benmachine> :t System.Posix.setEnv -- geheimdienst?
05:38:15 <lambdabot> String -> String -> Bool -> IO ()
05:38:41 <geheimdienst> isn't that only for processes that you fork subsequently ...?
05:39:06 <Veinor> geheimdienst: to take a silly example, if i do FOO=bar in bash, then my process's env obviously has changed
05:39:30 <benmachine> environments are mutable, pretty sure
05:39:42 <benmachine> quoting man setenv:
05:39:42 <benmachine>        setenv - change or add an environment variable
05:39:54 <geheimdienst> all i know is, if you change your PATH for instance, you generally need to log out and back. there's no way i know of that you could propagate that change through all processes
05:39:58 <Veinor> Prelude System.Posix.Env> getEnv "FOO"
05:40:00 <Veinor> Nothing
05:40:02 <Veinor> Prelude System.Posix.Env> setEnv "FOO" "BAR" True
05:40:04 <Veinor> Prelude System.Posix.Env> getEnv "FOO"
05:40:06 <Veinor> Just "BAR"
05:40:29 <benmachine> geheimdienst: that's only if you change it in /etc/profile or something
05:40:34 <benmachine> because that file is only read on login
05:40:35 <Veinor> you only need to log out and back if you change your path in your .bashrc or whatever; if you do export PATH=/my/new/directory:$PATH, everything's fine
05:40:49 <koeien> you can, of course, just say source ~/.bashrc
05:40:52 <rwbarton> FOO=bar doesn't change the contents of /proc/$$/environ
05:40:52 <lambdabot> rwbarton: You have 1 new message. '/msg lambdabot @messages' to read it.
05:41:08 <koeien> instead of logging out and in
05:41:38 <engla> sillies how environment is passed on between processes doesn't tell us if the function is "half-pure" or not
05:41:43 <benmachine> rwbarton: interesting
05:41:58 <rwbarton> so it doesn't change the "real" environment, the fact that getenv() shows changes made with setenv() is an invention of libc AFAIK
05:41:59 <Veinor> the point is that setEnv's return value can change
05:42:06 <rwbarton> yes
05:42:33 <koeien> so if you promise to never call setEnv, even indirectly, it's "half-pure"
05:42:35 <rwbarton> (by invention I mean it's implemented by libc, probably the behavior is specified by POSIX)
05:43:10 <benmachine> I think I believe POSIX more than I believe linux
05:43:20 <benmachine> I wonder what the **environ pointer thinks
05:44:47 <engla> if you want a pure version of getEnv, then copy all the environ and provide a way to get it
05:45:30 <koeien> TBH if you want the number of cores I'd unsafePerformIO it and not feel too bad about it
05:46:12 <frerich> benmachine: Thanks so much for the "The C language is purely functional" link, I think it's great :-)
05:46:22 <benmachine> :)
05:46:27 <benmachine> conal writes some good stuff
05:46:28 <Maxdamantus> But what about in the case of hot-swappable CPUs?
05:46:30 <frerich> benmachine: "Haskell also had some shameful pre-teen influences from hooligans like Church, Curry, Landin, and Milner [..]" haha
05:59:42 * hackagebot swish 0.6.1.1 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.6.1.1 (DouglasBurke)
06:04:42 * hackagebot biocore 0.1 - A bioinformatics library  http://hackage.haskell.org/package/biocore-0.1 (KetilMalde)
06:04:44 * hackagebot biopsl 0.1 - Library and executables for working with PSL files  http://hackage.haskell.org/package/biopsl-0.1 (KetilMalde)
06:04:50 <ketil> Whee!
06:04:55 <ketil> And.. and...
06:05:14 * ketil sighs.
06:05:19 <dmwit> There are definitely people who would feel bad about using unsafePerformIO to find the number of cores.
06:05:22 <dmwit> Nice work, ketil!
06:06:08 <ketil> (Just a refactoring, but hopefully a foundation for the other library authors out there)
06:09:46 * hackagebot biosff 0.1 - Library and executables for working with SFF files  http://hackage.haskell.org/package/biosff-0.1 (KetilMalde)
06:21:25 <bscarlet> Can I do the equivalent of -package-conf from within ghci? :set -package-conf doesn't seem to work for me...
06:21:53 <Palmik> Hi guys, is Grapfruit still active? From hackage and here http://code.haskell.org/grapefruit/main/ it seems that it's not, but mayhaps they have just changed the repository.
06:21:58 <Palmik> *Grapefruit :)
06:33:19 <dmwit> bscarlet: I don't think so. I tried it the other day, too.
06:33:28 <bscarlet> dmwit: thanks
06:33:40 <dmwit> Palmik: I haven't heard of any updates to Grapefruit in a while.
06:33:56 <dmwit> bscarlet: (Are you the StackOverflow cabal-dev guy?)
06:35:07 <bscarlet> dmwit: I don't think so.
06:35:23 <bscarlet> dmwit: i.e. - I don't know who that is, so probably not.
06:35:49 <dmwit> =)
06:36:37 <tromp> @hoogle importtURL
06:36:37 <lambdabot> No results found
06:37:34 <Axman6> @hoogle importURL
06:37:35 <lambdabot> No results found
06:40:13 <TheLemonMan> yo, i have a value wrapped in a Data.Binary.Get, do i want a lift to extract the value from it ?
06:40:40 <rostayob> TheLemonMan: runGet?
06:40:48 <rostayob> well what do you mean a value wrapped in a Get?
06:41:49 <TheLemonMan> i came up with this
06:41:51 <TheLemonMan> liftM (\x -> if x then Nothing else getWord16be) isEmpty
06:42:19 <rostayob> :t getWord16be
06:42:20 <lambdabot> Not in scope: `getWord16be'
06:42:45 <koeien> do { p <- isEmpty ; if p then return Nothing else Just <$> getWord16be }
06:42:48 <rostayob> I suppose that getWord16be is :: Get Word16 or something like that?
06:42:53 <koeien> rostayob: it is.
06:42:56 <rostayob> anyway, I'd imagine that that won't typecheck
06:43:10 <rostayob> so yeah, what koeien said
06:43:35 <rostayob> TheLemonMan: try to write down the type of that lambda
06:45:03 <TheLemonMan> well my lambda is obiviously wrong
06:45:16 <TheLemonMan> as it returns a maybe value and a get word16
06:45:29 <hpaste_> “Mukesh Tiwari” pasted “Making IntMap Index as Instance of Arbitrary” at http://hpaste.org/51529
06:45:34 <rostayob> TheLemonMan: yeah, you want something like the code posted by koeien
06:45:50 <keep_learning> Hello all
06:46:18 <koeien> TheLemonMan: getWord16be is an action that, when executed, returns a Word16
06:46:19 <keep_learning> Could some please tell me how to make IntMap as instance of arbitrary .
06:46:21 <keep_learning> http://hpaste.org/51529
06:46:22 <TheLemonMan> yep, the fmap makes sense there
06:46:27 <koeien> it is very different from a Word16
06:46:38 <koeien> getWord16be :: Get Word16
06:46:56 <koeien> yes <$> = fmap :)
06:47:01 <TheLemonMan> but i think i made a mistake in the function type declaration as ghc keeps complaining about types
06:47:14 <rostayob> that function is :: Get (Maybe Word16)
06:47:21 <TheLemonMan> BG.Get (Maybe Word16)
06:47:22 <koeien> it's not a function
06:47:32 <rostayob> oh, right. it's not a function.
06:47:36 <TheLemonMan> oh, then it's correct
06:47:52 <koeien> but the type sig is correct
06:48:23 <TheLemonMan> ghc says "Expected type: a0 -> Word16"
06:48:37 <TheLemonMan> but shouldnt that be Maybe Word16 ?
06:49:03 <koeien> well if you have incorrect code GHC cannot always be very accurate
06:49:08 <rostayob> TheLemonMan: if what koeien said is the body of the function, I doubt ghc is inferring that :P
06:50:28 <TheLemonMan> its the same except i kept my liftm
06:50:40 <rostayob> TheLemonMan: the liftM is not necessary there
06:50:52 <koeien> :t liftM
06:50:53 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
06:50:57 <TheLemonMan> to have it as an oneliner
06:51:16 <rostayob> TheLemonMan: isn't do { p <- isEmpty ; if p then return Nothing else Just <$> getWord16be } one line?
06:52:01 <rostayob> jokes aside, you don't need liftM here
06:52:25 <TheLemonMan> well, yeah, in the end it does the same
06:52:27 <koeien> TheLemonMan: your argument to liftM should have type a -> b, the second argument m a, and the result m b
06:52:52 <rostayob> if you really dislike do you can write "isEmpty >>= \p -> if p then return Nothing else Just <$> getWord16be" :P
06:52:58 <koeien> specializing, (Bool -> b) -> Get Bool -> Get b
06:53:08 <benmachine> keep_learning: you need to build an IntMap somehow, possibly using fromList
06:53:19 <koeien> but your lambda function is not of this type, it's Bool -> Get (Maybe Word16)
06:55:00 <TheLemonMan> huh, isn't Bool -> Maybe Word16 ?
06:55:05 <koeien> no.
06:55:10 <rostayob> TheLemonMan: no, you have getWord16
06:55:17 <koeien> getWord16be is :: Get Word16
06:55:26 <koeien> Just <$> getWord16be :: Get (Maybe Word16)
06:56:04 <TheLemonMan> oh, right, i didnt read the Get in the return
06:56:50 <benmachine> keep_learning: try arbitrary = fromList arbitrary
06:57:06 <benmachine> (although it depends what exactly you want the intmap to do)
06:57:58 <koeien> you could solve this with join :: m (m a) -> m a, but that probably confuses you more :)
06:58:11 <bscarlet> benmachine: don't you need a liftM or such in there somewhere?
06:58:23 <TheLemonMan> oh, found why ghc keeps complaining, Nothing isn't Get (Maybe Word16)
06:58:24 <benmachine> bscarlet: yes.
06:58:30 <koeien> TheLemonMan: exactly.
06:58:36 <benmachine> arbitrary = fmap fromList arbitrary
06:59:15 <TheLemonMan> should i just wrap Nothing into a Get monad ?
06:59:25 <koeien> TheLemonMan: return Nothing :: Get (Maybe Word16)
06:59:40 <koeien> (it's even more general than that)
07:00:25 <koeien> but liftM is exactly like fmap
07:00:34 <koeien> it has a different name for historical reasons
07:00:43 <keep_learning> benmachine: when I am using arbitrary = fromList arbitrary then it suggest Not in scope: `fromList'     Perhaps you meant `IntMap.fromList' (imported from Data.IntMap)
07:01:04 <keep_learning> benmachine: and when i am changing IntMap.fromList
07:01:10 <keep_learning> its giving error
07:01:14 <copumpkin> we should have a liftF, too
07:01:15 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
07:01:17 <copumpkin> liftF, liftA, liftM
07:01:19 <benmachine> keep_learning: yeah, sorry, I forgot fmap
07:01:40 <koeien> copumpkin: nah, just fmap, and Functor => Monad
07:01:48 <benmachine> arbitrary = fmap IntMap.fromList arbitrary
07:01:48 <copumpkin> koeien: I wish :)
07:01:52 <ion> koeien: He was joking.
07:01:59 <benmachine> liftA is actually still useful
07:02:04 <benmachine> in that case
07:02:09 <benmachine> but solely for writing Functor instances
07:02:10 <Veinor> copumpkin: we can call it the liftFAMily!
07:02:14 <koeien> lol
07:02:17 <copumpkin> :P
07:02:30 <benmachine> (likewise liftM and ap)
07:02:41 <keep_learning> benmachine: can we do arbitary = IntMap.fromList  zip arbitrary arbitrary
07:02:49 <bscarlet> Veinor: for that you need liftily too.
07:02:59 <keep_learning> benmachine: can we do arbitary = IntMap.fromList  $ zip arbitrary arbitrary
07:03:00 <Veinor> liftI is for iteratees
07:03:09 <Veinor> liftL is for lists (liftL = map)
07:03:23 <benmachine> keep_learning: not quite. arbitrary is in the Gen monad
07:03:49 <Veinor> and liftY does... something with the yoneda lemma
07:03:50 * bscarlet hopes Veinor gets the Y combinator in there somehow
07:04:09 <Veinor> or the Y combinator!
07:04:34 <benmachine> keep_learning: the easiest way is to do something like arbitrary = do xs <- arbitrary; return (IntMap.fromList xs)
07:04:42 * hackagebot DSH 0.7 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.7 (GeorgeGiorgidze)
07:04:53 <benmachine> keep_learning: except with line breaks, hold on I'll paste it
07:06:24 <copumpkin> Veinor: excellent
07:07:05 <ion> @@ @pl @undo do xs <- arbitrary; return (fromList xs)
07:07:05 <lambdabot>  fromList `fmap` arbitrary
07:07:18 <ion> or IntMap.fromList <$> arbitrary
07:15:56 <hpaste_> “Mukesh Tiwari” annotated “Making IntMap Index as Instance of Arbitrary” with “Making IntMap Index as Instance of Arbitrary (annotation)” at http://hpaste.org/51529#a51531
07:17:26 <keep_learning> benmachine: my last  fucntion indexDown return ( IntMap Index ) so my question is my Arbitrary instance should  be just IntMap  or IntMap Index ?
07:17:52 <benmachine> keep_learning: probably Arbitrary a => IntMap a
07:21:00 <keep_learning> benmachine: it say `arbitrary' is not a (visible) method of class `IntMap'
07:21:12 <benmachine> keep_learning: oh, erm
07:21:19 <benmachine> Arbitrary a => Arbitrary (IntMap a)
07:21:26 <benmachine> sorry
07:22:40 <tac-tics> What is Arbitrary a for?
07:23:02 <tac-tics> "Random generation and "shrinking" of values". What is 'shrinking' here?
07:23:15 <copumpkin> you need to be able to generate random values of the IntMap payload if you want to generate random IntMaps
07:23:31 <copumpkin> shrinking is finding smaller failing testcases if you find a failing testcase
07:23:35 <keep_learning> benmachine: how i can know how many instance it can deduce itself like Int , Float , [ Int ] ?
07:23:54 <ion> When encountering a failing property, QuickCheck tries to shrink it to the simplest value that causes it to fail.
07:24:06 <tac-tics> copumpkin: So for Peano numbers, if you find a test fails for a milion, it's a search to find numbers smaller than a million to fail on?
07:24:15 <tac-tics> ion: copumpkin: ah, I get it. Thanks
07:24:24 <copumpkin> yeah, for some notion of "smaller" that the type gets to specify
07:24:29 <benmachine> keep_learning: open ghci, do :m +Test.QuickCheck, then :i Arbitrary
07:25:16 <Veinor> shrink means 'if i give you an a, give me a list of all the things that are immediately smaller than it'
07:25:39 <Veinor> so the shrinks on a graph would be deleting a node/edge, the shrinks on an integer is 'moving towards 0'
07:26:24 <keep_learning> benmachine: thank you
07:27:12 <keep_learning> benmachine: i learn every day some thing in Haskell :)
07:28:02 <benmachine> keep_learning: np :)
07:31:16 <tac-tics> keep_learning: If only it were something practical or useful every day :)
07:31:16 <tac-tics> But we keep at it anyway
07:31:30 <benmachine> tac-tics: what are you implying :o
07:31:40 <benmachine> everything I do is very important
07:32:09 <nooodl> my hobby: writing oneliners that get progressively more insane to read
07:32:11 <nooodl> main = print $ take 20 $ map length $ iterate _'[[]] where _'[]=[];_'([]:__)=[()]:_' __;_'([()]:__)=[()]:[]:_' __
07:32:23 <wjt> hmm. I have a Cabalized package that doesn't contain any Haddock API documentation, because it's a single trivial executable. how can I stop `cabal install` installing useless empty documentation?
07:32:35 <tac-tics> benmachine: Same here. Vacuously in my case, because I never end up doing anything at all.
07:32:51 <benmachine> :P
07:32:59 <tac-tics> For all things x I do, x is important, damnit!
07:33:17 <benmachine> wjt: do you mean when you do cabal install, or when the user does?
07:34:07 <wjt> benmachine: the latter: I can tell them to use `cabal install --disable-documentation` but it seems like Cabal should be able to figure out for itself that there is no documentation, or at least I'd like to make that the default
07:34:37 <benmachine> wjt: hmm. I don't know, then
07:34:51 <wjt> benmachine: for now I'm just recommending that :)
07:40:38 <dylukes> Do any of you paper-publishing folks know how to make amsart two column with a centered abstract?
07:41:23 <blabla> Is there a name for something like Functor only backwards : "toMap :: (x a -> x b) -> a -> b" ? I.e. we can make a normal function (a -> b)  from an (x a -> x b), but not all functions (a -> b) can be made into (x a -> x b)
07:41:43 <tac-tics> blabla: A cofunctor maybe?
07:41:58 <tac-tics> a functor goes from (f a -> f b) -> (a -> b)
07:42:02 <dylukes> Yeah, but a cofunctor is still a functor
07:42:06 <dylukes> :|
07:42:11 <dylukes> @hoogle (x a -> b) -> a -> b
07:42:12 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (t e -> q) -> d -> q
07:42:12 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
07:42:12 <lambdabot> System.Console.GetOpt ReqArg :: (String -> a) -> String -> ArgDescr a
07:42:41 <dylukes> Control.Compose contains cofunctors, but they seem to be CONTRAVARIANT functors
07:42:44 <blabla> @ty fmap
07:42:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:42:49 <tac-tics> Yeah, it would be a cofunctor, I think. You just reverse the arrows.
07:43:00 <tac-tics> (f a <- f b) <- (a <- b)
07:43:18 <tac-tics> err
07:43:29 <tac-tics> I got all the right letters, but I put them in the wrong order >_>
07:43:38 <lgm> Good morning!
07:43:39 <blabla> no a cofunctor would be (a -> b) -> (f b -> f a)..I think.
07:43:44 <dylukes> blabla: ^
07:44:05 <dylukes> yeah, you're switching the functor arrow between the categories (a->b) and (f b -> a)
07:44:15 <dylukes> fa->fb*
07:44:25 <dylukes> a->b and fa->fb are arrows within the two categories, I believe.
07:44:49 <lgm> i've a question regarding Atkey's presentation of shift and reset in terms of parametrized monads
07:44:52 <dylukes> and the middle -> corresponds to a functor between them. (i.e, a functor from the Identity functor to the f functor)
07:45:20 <dylukes> lgm: I'm amusingly reminded that in any other channel, people would think you were trolling with that vocabulary.
07:45:26 <tac-tics> dylukes: A functor from a functor to a functor? Something sounds not right about that
07:45:33 <tac-tics> lol
07:45:38 <dylukes> tac-tics: a functor in Cat1
07:45:50 <blabla> "Control.Compose contains cofunctors, but they seem to be CONTRAVARIANT functors" ahh so haskel cofunctors are misnamed?
07:45:51 <dylukes> or switch the objects and arrows
07:46:06 <lgm> dylukes:lol!
07:46:37 <copumpkin> cofunctors?
07:46:40 <copumpkin> who calls them that?
07:46:54 <copumpkin> blabla?
07:47:01 <blabla> Yes?
07:47:05 <dylukes> anyways about tex
07:47:10 <lgm> Atkey claims that the unit is given by \k -> kx
07:47:11 <copumpkin> blabla: what are you quoting?
07:47:24 <blabla> dylukes.
07:47:40 <copumpkin> ah
07:47:42 <dylukes> I'm just quoting what Control.Compose says
07:47:55 <copumpkin> oh okay, where is Control.Compose then? :P
07:48:05 <dylukes> hackage? :D
07:48:09 <lgm> but this doesn't type
07:48:23 <Palmik> dmwit, OK, thanks... :)
07:48:26 <copumpkin> ah, the answer to my question would be TypeCompose
07:48:29 <copumpkin> not "hackage?"
07:48:30 <copumpkin> :P
07:48:42 <lgm> for the term to type correctly, kx : C
07:49:21 <lgm> this implies, k : (X -> B) -> C
07:49:49 <lgm> x : X -> B
07:50:20 <lgm> but, the unit takes as input x : X
07:51:21 <lgm> intuitively, without being given either a B or a C how would one construct a function from (X -> B) ->C
07:52:00 <lgm> So, let's be generous and assume that we've oriented wrongly and he's talking about the morphism map
07:52:22 <lgm> so, x : X -> Y
07:53:25 <TNA-MichaelK> lgm, my analysis notation is rusty, does that translate to: "There is an x such that x maps to y" ...?
07:53:55 <lgm> then given data v : ( X -> B ) -> C, k : Y -> C, f : X -> Y, we can build v( \x -> k( f( x ) ) )
07:54:32 <lgm> These map directly to Haskell types
07:55:07 <lgm> TNA-MichaelK: these map directly to Haskell types
07:55:11 <dylukes> copumpkin: I should call my language "Funktor"
07:55:20 <dylukes> It's like functors, but more snazzy.
07:55:27 <Cale> TNA-MichaelK: x: X -> Y means that x is a function from the set (or type) X to the set Y.
07:55:29 <dcoutts__> wjt: cabal doesn't generate docs by default for executables, you would have had to turn that on explicitly
07:55:51 <Cale> (or more generally that it's an arrow from X to Y in some category)
07:55:53 <TNA-MichaelK> lgm, So, analysists are great at haskell then.  I'm fresh in the subject.
07:56:04 <lgm> no worries
07:56:27 <Cale> It's not just analysis. Category theory provides a notation that's used throughout mathematics, and mimicked a little bit in Haskell.
07:56:33 <wjt> dcoutts__: huh. my ~/.cabal/config does contain 'documentation: True'—I must have set that thinking it was for libraries, I suppose
07:56:40 <TNA-MichaelK> Cale, thanks for clarifying, are the meanings not equivalent though?
07:56:53 <dcoutts__> wjt: it is for libraries
07:57:41 <dcoutts__> wjt: hmm, seems I have no idea why it should install empty docs
07:58:07 <wjt> dcoutts__: i get a warning from (I guess) Haddock saying “Warning: No documentation was generated as this package does not contain a library. Perhaps you want to use the --executables flag.”
07:58:16 <dcoutts__> I thought that it would not, because I thought the enable-documentation did not also use cabal haddock --executables
07:58:29 <dcoutts__> wjt: that sounds right
07:58:42 <dcoutts__> wjt: so then what do you mean about it installing empty docs?
07:58:45 <Cale> TNA-MichaelK: Well, x: X -> Y isn't exactly what you'd normally think of as an existence statement, and x and X are fundamentally a different sort of thing here.
07:59:00 <Cale> x is a function, X is a set
07:59:06 <Cale> (or type)
07:59:46 <lgm> Let me back up. Atkey claims to be able to present the semantics of shift and reset using parameterized monads
08:00:03 <wjt> dcoutts__: if i just run `cabal install`, with 'documentation: True' in my ~/.cabal/config, I get “documentation” as follows installed: http://willthompson.co.uk/misc/empty-docs/
08:00:20 <lgm> To do so he needs to define a unit, multiplication and strength
08:00:34 <Cale> lgm: link to paper?
08:00:37 <lgm> i'm stumbling on the unit
08:00:53 <dcoutts__> wjt: oh, that's the overall haddock index of all your installed packages
08:01:03 <dcoutts__> wjt: which apparently is empty
08:01:11 <dcoutts__> wjt: that's not specific to one package
08:01:26 <Cale> Is it "Parameterised Notions of Computation"?
08:01:27 <lgm> Cale: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.159.2355&rep=rep1&type=pdf
08:01:59 <Cale> WHOA, wtf. When I opened <http://homepages.inf.ed.ac.uk/ratkey/param-notions.pdf>, all widgets in Gnome changed to oldschool ones...
08:02:03 <lgm> pg: 11
08:02:24 <Cale> bizarre
08:02:33 <dylukes> So about that LaTeX thing
08:02:39 <dylukes> one column abstract/two column text
08:02:41 <dylukes> ideas?
08:02:53 <Cale> lgm: okay
08:03:02 <Cale> So return x = \k -> k x
08:03:15 <lgm> Cale: that doesn't type correctly
08:03:19 <lgm> see my argument above
08:03:19 <Cale> sure it does
08:03:34 <lgm> for this to type correctly, kx : C
08:03:37 <Cale> return :: a -> ((a -> r) -> r)
08:04:01 <Cale> If x :: a, then  \k -> k x :: (a -> r) -> r
08:04:21 <lgm> aha!
08:04:29 <copumpkin> dylukes: call it Profunctor
08:04:31 <lgm> i was off by one!
08:04:33 <copumpkin> only the pros use it
08:04:34 <lgm> thanks
08:04:39 <ion> Antifunctor
08:04:49 <copumpkin> Anafunctor
08:04:51 <dcoutts__> wjt: is that plausible or is there still something going wrong?
08:05:09 <lgm> call it fn-ctor!
08:05:10 <Ptival> Functerior
08:05:17 <ion> cale: gnome-settings-daemon probably crashed and Gnome programs reverted to the default Gtk theme.
08:05:30 <Cale> ion: Yeah, something weird like that happened
08:05:46 <Cale> ion: Things mostly came back when I opened the Appearance panel.
08:06:06 <Cale> Though X-chat seems to still be stuck :)
08:09:56 <rostayob> any good haskell related papers to read? i've got a long trip ahead eheh
08:10:35 <tac-tics> rostayob: What topic?
08:10:42 <tac-tics> rostayob: There are so very many :)
08:10:56 <engla> how do I make a zipper datastructure over the tiles in an asymmetrical tiling (penrose tiles) :-)
08:11:01 <tac-tics> The Awkward Squad and the Beautiful Code's STM by SPJ are good.
08:11:08 <rostayob> tac-tics: the topic is not that important, but something readable and useful
08:11:24 <rostayob> tac-tics: I read that a while ago, is the one in which they write a web server right?
08:11:36 <tac-tics> Also the spineless tagless g machine for writing a good runtime engine for haskell in haskell
08:11:58 <tac-tics> rostayob: The STM paper actually writes a concurrent Santa Clause Program >_>
08:12:01 <RomyEatsDrupal> hello.  anyone know of any blog written in Haskell, with its source code open/available?  I am learning Haskell right now and would love to try using it for web development
08:12:05 <tac-tics> But the STM library is amazing
08:12:06 <c_wraith> engla: zippers don't work so well on highly interconnected structures..  What's your internal representation of the tiling?
08:12:37 <engla> c_wraith: I don't have one, I can't find out a nice way to represent either the tiles or the vertices
08:13:05 <wjt> dcoutts__: sorry, someone came to speak to me in real life
08:13:10 <tac-tics> rostayob: If you like practical programs, try Ben Lippmeier's thesis on DDC, which combines Haskell purity and a powerful type effect system
08:13:19 <rostayob> tac-tics: oh, it's a chapter of the "beautiful code" book. looks good, thanks
08:13:27 <tac-tics> It's the clostest thing, IMO, to a practical pure language
08:13:28 <wjt> dcoutts__: oh! riiiiight—there's a mismatch between my GHC version and the version my Haddock was built with. Makes sense :)
08:13:37 <engla> c_wraith: the internal representation is just a list of tiles and their positions, bascially
08:14:39 <c_wraith> engla: if the internal representation carries no spatial reflection of the structure, a simple list zipper would work...  But it sounds not very useful.
08:14:40 <tac-tics> Lippemeier's thesis is really easy reading, as far as papers go, and I find the idea of "masking" effects in impure functions to get pure functions fascinating
08:15:19 <tac-tics> rostayob: There's also Benjamin's Pierce's software foundations: http://www.cis.upenn.edu/~bcpierce/sf/index.html
08:15:29 <tac-tics> Which is on Coq and formal proof systems
08:15:32 <dcoutts__> wjt: oh ok, well that's a different problem
08:15:43 <tac-tics> Not so much Coq, but more formal proofs
08:16:10 <dcoutts__> wjt: could you email me the error message that haddock gives, it seems like it ought really to fail with an error code so cabal would detect it
08:16:33 <engla> c_wraith: right.
08:17:04 <rostayob> tac-tics: I think I'll go for beautiful concurrency
08:17:13 <rostayob> looks really readable, and I don't want to be bored
08:17:15 <tac-tics> enjoy :D
08:17:21 <TNA-MichaelK> Cale, thanks for the clarification
08:17:39 <parcs> dcoutts__: hi, quick question: are you aware that cabal-install's --enable-executable-dynamic doesn't work on source files that use TH?
08:17:42 <c_wraith> engla: I don't have a brilliant answer for you, this is a relatively tough problem.  But is a zipper what you want, anyway?  Zippers are best for "modifying" a structure locally without changing its global structure.  That doesn't seem like it would apply to penrose tiling
08:18:27 <wjt> dcoutts__: yup, will do. this will teach me to ignore glaring warnings :)
08:18:29 <dcoutts__> parcs: not specifically, but yes it makes sense and we can solve it the same way as we do for profiling with TH
08:18:43 <engla> c_wraith: when generating a new tiling gradually, I was thinking that I need a datastructure where the neighbors of each vertex are immediately available
08:18:54 <engla> so that I can add new tiles, and even possibly rollback when it conflicts
08:20:10 <wjt> dcoutts__: misread the messages: it's a haddock interface file version mismatch for all the libraries I got from Debian. http://pastie.org/2558355 It looks like something, sometime, has pulled a haddock into ~/.cabal/bin, besides the Debian-supplied one.
08:22:05 <parcs> dcoutts__: great. i will be awaiting the patch in HEAD :P
08:22:23 <dcoutts__> parcs: you'd better file a ticket in the trac or I will forget
08:23:31 <dcoutts__> wjt: mm, tricky. If it was just one then we probably don't want to fail. If it's all of them we probably do.
08:24:00 <parcs> dcoutts__: will do
08:24:32 <dcoutts__> parcs: ta
08:25:21 <wjt> dcoutts__: i'll file a wishlist ticket
08:26:01 <parcs> oh, someone beat me to it: http://hackage.haskell.org/trac/hackage/ticket/869
08:26:04 <dcoutts__> wjt: ta
08:26:14 <dcoutts__> parcs: oh heh, ok good
08:27:24 <lgm> Cale: thanks again! Sometimes i get a brain fart and it helps to have another pair of eyes.
08:27:52 <Cale> lgm: no problem
08:28:41 <Cale> lgm: You can think of a function (a -> r) -> r as a box which answers r-valued questions about a value of type a
08:29:46 <Cale> lgm: and eta/return is the natural embedding which produces the honest box that always answers those questions by testing them against a specific value of type a
08:32:23 <Cale> lgm: (and there can be boxes which lie, of course)
08:33:29 <TNA-MichaelK> Cale, do you think it'd be advantageous to brush up on set theory to learn this language?
08:34:05 <BlankVerse> http://paste.pocoo.org/show/478593/
08:34:07 <Cale> TNA-MichaelK: I wouldn't bother, but you might find yourself interested in category theory at some point.
08:34:17 <Cale> TNA-MichaelK: It's by no means a prerequisite.
08:34:48 <BlankVerse> whats  No instance for (Num (IO a10))
08:34:49 <TNA-MichaelK> Cale, category theory sounds quite a bit different, but perhaps a special case of set theory?
08:35:28 <Cale> It can be viewed as a generalisation of set theory (though that's a little bit misleading)
08:35:38 <Cale> There is a category of sets and functions
08:35:48 <tac-tics> Category theory is a weird thing. It feels like a more textured variant on set theory.
08:36:17 <tac-tics> Instead of the basic "thing" being a set, the basic "things" are functions (and what they point to). But they are called morphisms and objects.
08:36:18 <Cale> I think of category theory as a cross between the theory of monoids, and order theory.
08:36:31 <Cale> They aren't quite functions :)
08:36:38 <Cale> They're arrows
08:36:38 <tac-tics> Cale: true
08:36:46 <Cale> (which can be anything)
08:37:00 <tac-tics> But for practical purposes, they are almost always visualizable as some kind of function or another.
08:37:02 <TNA-MichaelK> So more or just the study of relations?
08:37:05 <tac-tics> But no, they just need to point
08:37:46 <TNA-MichaelK> It sounds like functional analysis
08:37:50 <Cale> Well, perhaps I should just define it clearly :P
08:37:58 <Cale> A category C consists of:
08:38:23 <Cale> A collection Ob(C) of objects of C. (often a set, possibly a proper class)
08:38:24 <quicksilver> tac-tics: really, the interesting parts of category theory come when the arrows aren't functions.
08:38:52 <Cale> For each pair X and Y of objects of C, a collection C(X,Y) of arrows. When f is an arrow in C(X,Y), we write f: X -> Y
08:39:15 <tac-tics> quicksilver: Demonstrate one example without using the axiom of choice or law of excluded middle
08:39:44 <Cale> For each three objects, X, Y, and Z, a composition map C(Y,Z) x C(X,Y) -> C(X,Z)
08:40:30 <Cale> That is, it takes an arrow g: Y -> Z and f: X -> Y and composes them into an arrow g . f: X -> Z
08:40:30 <TNA-MichaelK> x here is the Cartesian product?
08:40:33 <Cale> yeah
08:40:54 <Cale> (possibly on proper classes or something, let's not worry about the details of that case too much though)
08:42:29 <TNA-MichaelK> That just seems like the basic study of functions at this point
08:42:42 <Cale> also, for each object X, there is an arrow 1_X (or id_X, or simply 1 or id when it's clear which X we want) such that for every object Y and arrows f: X -> Y, g: Y -> X, we have f . 1_X = f and 1_X . g = g
08:42:45 <TNA-MichaelK> It makes me want to read rudin again ; )
08:42:45 <Cale> So an identity map
08:43:51 <quicksilver> tac-tics: partial orders. groupoids. deductive systems.
08:43:52 <Cale> and then also, for any 4 objects, X,Y,Z,W and arrows h: X -> Y, g: Y -> Z, f: Z -> W, we have f . (g . h) = (f . g) . h
08:44:14 <TNA-MichaelK> what's the dot?
08:44:17 <Cale> Composition
08:44:46 <Cale> the maps C(Y,Z) x C(X,Y) -> C(X,Z)
08:44:51 <Cale> for each X,Y,Z
08:45:12 <Cale> So, if a category has only one object, it's the same thing as a monoid
08:45:21 <Cale> (if you know what that is)
08:45:37 <Cale> For example, there's a category with one object, say, *
08:45:43 <Cale> and the arrows * -> * are real numbers
08:45:48 <Cale> and composition is addition of real numbers
08:45:55 <TNA-MichaelK> is C(X,Y) x C(Y,Z) -> C(X,Z) then?
08:45:56 <Cale> and 1_* = 0
08:46:26 <Cale> TNA-MichaelK: yeah, though that's flipped over
08:47:16 <TNA-MichaelK> it seems like the way you wrote it is flipped, because x->y -> z is more obvious
08:47:21 <Cale> Because of the heritage of set theory, and the way that functions (f . g)(x) = f(g(x)) compose, we have the domains and codomains like that
08:47:49 <Cale> Yeah?
08:47:54 <TNA-MichaelK> ohhh that kind of composition (fog)(x)
08:47:59 <Cale> yeah
08:48:04 <Cale> that's a special case of this kind
08:48:22 <Cale> We're generalising so that composition can do "anything" to the arrows
08:48:30 <Cale> so long as it has identities and is associative
08:49:14 <c_wraith> Heh.  I told a friend about it being possible to generalize function composition.  She was like "I'll accept that it's true, and not think about it for now" :)
08:49:28 <TNA-MichaelK> Could you reference me some tutorials/books?
08:49:46 <Cale> Oh, another way to put it is that for any two arrows: f: X -> Y and g: Y -> Z, there is an arrow g . f: X -> Z, the composite
08:49:48 <TNA-MichaelK> c_wraith, nice response
08:49:59 <Cale> That avoids talking about C(X,Y) confusingly
08:50:04 <Cale> yeah?
08:50:13 <TNA-MichaelK> Cale, I like that last one best.
08:50:14 <Cale> So, let me go over a few examples
08:50:23 <Cale> Do you already know what a monoid is?
08:50:35 <TNA-MichaelK> Wow, thank you very much for helping me get started.
08:51:05 <TNA-MichaelK> It's when you have one object and it... no, I don't know
08:51:33 <Cale> Traditionally, a monoid is a set M with a binary operation *: M x M -> M which 1) is associative, so that (a * b) * c = a * (b * c) for every a,b,c in M, and 2) has an identity, so there is 1 in M so that for every a in M, we have a * 1 = 1 * a = a
08:52:04 <Cale> For example, M could be the set of all strings on some alphabet, and * could be concatenation
08:52:07 <Cale> and 1 would be the empty string
08:52:26 <Cale> Or M could be the real numbers, and * could be multiplication and 1 could be 1
08:52:34 <Cale> Or * could be addition and the 1 would be 0
08:52:41 <Cale> Yeah?
08:53:54 <TNA-MichaelK> Yes, I got ya, it's similar to a group then
08:54:06 <Cale> yes, it's exactly a group without the requirement of inverses
08:54:15 <Cale> So all groups are monoids
08:54:19 <tac-tics> It's a group that's been neutered
08:54:27 <Cale> Now suppose we have a category with only one object
08:54:37 <Cale> and so it just has a bunch of arrows from that one object to itself
08:54:39 <TNA-MichaelK> Though, not all monoids are groups because of closure and inverse?
08:54:45 * hackagebot cabal2nix 1.17 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.17 (PeterSimons)
08:54:48 <Cale> Because of inverses
08:54:57 <TNA-MichaelK> so monoides are closed too?
08:55:07 <Cale> The monoid operation is still "closed" in the sense that it's a function M x M -> M
08:55:17 <Cale> So it's defined for all pairs of values
08:55:20 <gwern> @quote monoid
08:55:20 <lambdabot> stepcut says: I wish someone had told the designers of XML about monoids :(
08:55:37 <tac-tics> I don't get that quote...
08:55:53 <BlankVerse> http://hackage.haskell.org/packages/archive/gsl-random/0.3.1/doc/html/src/GSL-Random-Dist.html
08:56:09 <BlankVerse> how do i call getPoisson .. what is the type of mu
08:56:13 <TNA-MichaelK> gwern, thanks
08:56:16 <Cale> So if we have a category with one object, it has a bunch of arrows from that object to itself
08:56:24 <Cale> and an identity arrow
08:56:30 <copumpkin> BlankVerse: call the fisherman
08:56:31 <Cale> and composition is associative
08:56:40 <Cale> So a category with one object is the same thing as a monoid
08:56:55 <Cale> So all monoids (including all groups) are examples of categories.
08:57:29 <TNA-MichaelK> So, a real world monoid might be how many ways you can go for a run in your neighborhood and get back to your house?
08:57:44 <Cale> Sure.
08:57:46 <TNA-MichaelK> and the identity would just be you saying at your house?
08:57:49 <Cale> yes
08:57:56 <Cale> The empty run :)
08:57:56 <TNA-MichaelK> ok, crystal clear now
08:58:13 <Cale> and the composition would concatenate the runs together
08:58:17 <tac-tics> Cale: TNA-MichaelK: That is one of my favorite exercises.
08:58:32 <Cale> Okay, now let's look at a seemingly very different thing
08:59:07 <Cale> If S is any set, we define a preorder on S to be a binary relation <= on S satisfying the conditions that
08:59:13 <TNA-MichaelK> tac-tics, you mean the identity jog?
08:59:15 <Cale> 1) it's reflexive: a <= a for every a in S
08:59:29 <Cale> 2) it's transitive: if a <= b and b <= c, then a <= c for every a,b,c in S
08:59:46 <tac-tics> TNA-MichaelK: yeah, aka: staying at home :)
09:00:04 <ClaudiusMaximus> BlankVerse: http://www.haskell.org/hoogle/?hoogle=%3a%3a+IO+RNG+%2bgsl-random http://www.haskell.org/hoogle/?hoogle=%3A%3A+RNG+-%3E+IO+Int+%2Bgsl-random
09:00:20 <Cale> But now if we have a preorder (S,<=), we can make a category from it, where the objects of the category are the elements of S, and there's a single arrow x -> y if and only if x <= y
09:00:35 <Cale> (so arrows point in "increasing" order)
09:00:59 <Cale> There are lots of preorders, including every partial (and thus every total) order
09:01:40 <Cale> For example, we can take the real numbers under their usual ordering, and make them into the objects of a category where there's an arrow x -> y iff x <= y as real numbers.
09:01:45 <TNA-MichaelK> Cale, backwards arrows mean a binary relation?  Which is an equivalence relation?
09:01:52 <TNA-MichaelK> no... hmm
09:02:04 <TNA-MichaelK> I'm still a few lines behind
09:02:09 <Cale> TNA-MichaelK: That's meant to be read "less than or equivalent to"
09:02:11 <rostayob> less or equal :P
09:02:25 <ClaudiusMaximus> BlankVerse: so something like:  do{ rng <- newRNG someRNG ; replicateM 42 $ getPoisson rng 6.66 }
09:02:26 <rostayob> which is an example of such relation
09:02:36 <TNA-MichaelK> oh, like 4<=5
09:02:37 <Cale> Note that in a preorder, it's possible to have distinct x,y with x <= y and y <= x
09:02:40 <Cale> yeah
09:02:56 <rostayob> Cale: is there a tutorial or some text similar to what you are doing now?
09:02:56 <Cale> (we allow things like cycles, but it has to be transitive)
09:03:13 <Cale> http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf
09:03:19 <benmachine> Cale: so composition corresponds to transitivity, and identity to reflexivity?
09:03:27 <Cale> yeah
09:03:34 <TNA-MichaelK> so with integers....  1->2 iff 1<=2
09:03:42 <Cale> the existence of composite arrows corresponds to transitivity
09:03:49 <Cale> and the existence of identity arrows corresponds to reflexivity
09:03:55 <Cale> TNA-MichaelK: yeah
09:03:55 <benmachine> what does it mean in this case to say composition is associative?
09:04:09 <TNA-MichaelK> let me catch up
09:04:12 <Cale> benmachine: not much, because there's at most one arrow between any two objects
09:04:19 <benmachine> oh right
09:04:20 <Cale> So if the arrow exists, we know what it has to be
09:04:20 <rostayob> Cale: thanks
09:05:43 <Athas> I need to run fairly simple parsers across Data.Text.Texts, and it needs to be quite fast.  Which parser combinator library should I use?
09:05:47 <Cale> http://tartarus.org/simon/2008-olympics-hasse/ -- for an interesting example of a partial order, which again is an example of a preorder we can make a category from
09:06:13 <Cale> That diagram has the arrows pointed in the opposite direction from our convention, but it doesn't really matter.
09:06:37 <Cale> If we have any category, we can make another category by reversing the direction of all the arrows, called the opposite category.
09:07:39 <Cale> Athas: In my experience, it's usually not that hard to switch between parser combinator libraries
09:07:45 <BlankVerse> ClaudiusMaximus: can you give a runnable example?
09:07:46 <TNA-MichaelK> Cale, 1 arrow between any two objects, but potentially many paths between them, right?
09:07:55 <BlankVerse> ClaudiusMaximus: what is someRNG?
09:08:00 <Cale> Athas: maybe something like attoparsec-text
09:08:12 <Cale> TNA-MichaelK: yeah, though those paths will compose to the same thing
09:08:14 <Athas> Cale: thanks, I'll check it out.  My current Parsec parsers are too slow.
09:08:57 <ClaudiusMaximus> BlankVerse: looks like mt19937 should work from the haddocks
09:09:54 <TNA-MichaelK> Cale, How did you learn all of this?  Masters? PhD? Professor?
09:10:05 <Cale> TNA-MichaelK: BMath + self study
09:10:19 <Cale> I have a BMath from Waterloo
09:11:11 <TNA-MichaelK> How is the opposite category notated?
09:11:11 <Cale> C^op
09:11:11 <ClaudiusMaximus> BlankVerse: i've not used gsl-random, but a runnable example might be   main = do{ rng <- newRNG mt19937 ; rnds <- replicateM 42 $ getPoisson rng 6.66 ; mapM_ print rnds }
09:11:24 <tromp> i did a postdoc at UWaterloo
09:11:29 <Cale> tromp: cool
09:11:30 <TNA-MichaelK> C(X) would be a category of object X? and C(X)^op would be the opposite?
09:11:41 <tromp> in 94/95
09:11:53 <Cale> TNA-MichaelK: I'm not sure what you mean by a category of object X
09:12:16 <TNA-MichaelK> tromp, I did a B.S. Physics, I'm still a beginner in abstract math, but I've been trying to learn on my own
09:12:18 <Cale> tromp: That would be before me, I was 2001-*
09:12:31 <TNA-MichaelK> tromp, what field
09:12:36 <copumpkin> TNA-MichaelK: bullshit physics? I'm sorry :(
09:12:52 <tromp> theoretical computer science
09:13:14 <Cale> TNA-MichaelK: Another good example is the category of vector spaces over some field k, and the linear transformations between those.
09:13:28 <tromp> i was back in Waterloo in 2001, working at a spinoff
09:13:31 <tac-tics> Less calculus, more calculate!
09:13:58 <TNA-MichaelK> copumpkin, huh? computational physics was my specialty if I had one... but it was a general degree, you could call it a bull shit degree, but I did like the B.S. because it initialized Bull Shit and I felt it gave me the license to BS in physics ; )
09:14:01 <Cale> Or of course, you can be pedestrian, and take the category whose objects are natural numbers, and where the arrows n -> m are n-by-m matrices of real numbers.
09:14:05 <tromp> founded by CS professor Ming Li
09:14:11 <Cale> (and composition is by matrix multiplication)
09:14:39 <TNA-MichaelK> tromp, that's quite impressive, have you found it to be useful?
09:15:00 <BlankVerse> ClaudiusMaximus: not in scope replicateM?
09:15:09 <ClaudiusMaximus> BlankVerse: import Control.Monad
09:15:25 <tromp> my postdoc was more useful than my software engineering stint:)
09:15:48 <TNA-MichaelK> cale, the vector space one is more interesting than your pedestrian example
09:15:56 <Cale> TNA-MichaelK: sure :)
09:15:59 <tromp> campus life is more fun too
09:16:06 <Cale> TNA-MichaelK: though it's secretly the same example
09:16:13 <tgeeky> does anyone have the "parsing with derivatives" paper listed here? http://www.icfpconference.org/icfp2011/accepted.html
09:16:17 <Cale> Well... almost :)
09:16:28 <Cale> Ignoring the infinite dimensional spaces :P
09:16:59 <Cale> There's a category of groups and group homomorphisms, a category of graphs and graph homomorphisms
09:17:19 <Cale> a category of types of some programming language (like Haskell) and functions between those types definable in the language
09:17:35 <tac-tics> I remember in my theory of computation class, my teacher was a cool guy, but unfortunately, he was kinda homophobic
09:17:46 <TNA-MichaelK> so it'd be rank 2 matricies or order 2? rank 3 is nxmxp, right?
09:17:47 <tac-tics> It was very awkward for him to write the word "homomorphism" on the blackboard
09:17:49 <Cale> a category of finite automata and strings sending one automaton to another
09:18:19 <Cale> (or homomorphisms of automata, another example)
09:18:25 <tromp> we were pondering the name of our homology search program. we considered "homohunter" :)
09:18:36 <Cale> There's a category of categories and functors between them (we haven't said what a functor is yet though)
09:18:52 <Cale> and for any two parallel functors in that category, there's a category of natural transformations between those :)
09:19:05 <copumpkin> TNA-MichaelK: oh, I was just poking fun at the B.S. title :)
09:19:20 <Cale> TNA-MichaelK: yeah, rank 2
09:19:29 <Cale> TNA-MichaelK: the ones which correspond to linear maps ;)
09:19:34 <TNA-MichaelK> tromp, that's a hilarious, yet terrible name
09:19:41 <wreel> tromp, nice
09:19:47 <tromp> we had a lot of laughs over that:)
09:20:14 <Cale> tromp: Or just go one step further and call it gaydar.
09:21:14 <TNA-MichaelK> I am having to reread this several times Cale, that's normal for the first time, right?
09:21:19 <Cale> TNA-MichaelK: sure
09:21:26 <Cale> TNA-MichaelK: You might not even relate to all the examples
09:21:38 <Cale> and I'm not doing a great job of being clear about them all
09:21:47 <Cale> Just trying to convey a rough picture of the scope of things
09:21:59 <Cale> We also get a category of topological spaces and continuous functions between them
09:22:14 <Cale> Also metric spaces and contraction maps
09:22:31 <TNA-MichaelK> I'm following, though have limited experience so need more examples before the generalization.
09:22:38 <TheLemonMan> are Data.Bits operators with higher priority than arithmetic ops ?
09:22:47 <Cale> and manifolds and smooth maps (of various classes)
09:23:05 <TNA-MichaelK> speaking about manifolds, ever read Neverness?
09:23:09 <tromp> > 1+2 `xor` 3
09:23:10 <lambdabot>   Ambiguous type variable `a' in the constraint:
09:23:10 <lambdabot>    `Data.Bits.Bits a'
09:23:10 <lambdabot>      a...
09:23:17 <tromp> > 1+2 `xor` 3 ::Int
09:23:18 <lambdabot>   0
09:23:26 <Cale> I haven't, it's a novel?
09:23:34 <tac-tics> tromp: You killed that poor integer!
09:23:43 <tac-tics> reduced him to 0 :(
09:23:54 <tromp> but 0 is the bestest of integers!
09:24:06 <TheLemonMan> i guess i need a couple of parenthesis more
09:24:24 <TNA-MichaelK> Yes, it's a sci fi novel where the main character navigates the manifold (of spacetime) by creating maps
09:25:05 <TNA-MichaelK> A general question that I've been personally struggling with...  Is it possible for humans to visualize 4 space?
09:25:27 <Cale> It's possible to do a reasonably decent job of it.
09:25:48 <Cale> I can picture a fair variety of 4D objects in my head.
09:25:50 <tac-tics> TNA-MichaelK: I thought you said you did physics. Isn't 4 dimensional space all you guys use?
09:26:15 <tac-tics> Be it space + time or Complex space to complex space
09:26:25 <TNA-MichaelK> tac-tics, it depends on what you mean by dimensions really
09:26:46 <TNA-MichaelK> Really, dimension in physics is just a degree of freedom, we have problems with hundreds of dimensions
09:26:46 <Cale> Heck, I've spent enough time working with infinite dimensional stuff that 4D seems kinda normal.
09:26:55 <tac-tics> R^3 x R is congruent to R^4, C->C is congruent to R^4
09:27:15 <joachi> Cale: wtf?
09:27:19 <TNA-MichaelK> The thing is, I can see the 4th dimensional transformations on 3D objects, but I can't see the 4 space natively
09:27:22 <Cale> Though R^4 itself has some mysterious properties that other R^n don't.
09:27:25 <rostayob> oh, #haskell.
09:27:37 <tgeeky> (i am also a physicist) -- in general, it is possible to visualize/understand features of 4D or higher) space, and it's also possible to develop analogies to them -- these aren't necessarily the same task.
09:27:42 <tac-tics> Cale: What's your favorite mysterious property of R^4?
09:27:59 <tgeeky> tac-tics: Minkowski space is pretty mysterious
09:28:17 <Cale> tac-tics: I'm thinking about the existence of exotic differential structures.
09:28:41 <tgeeky> I think most physicists see 2D *or* their preferred 8,9,11,24,26,42, dimensional space as "the most interesting"
09:28:55 <TNA-MichaelK> tgeeky, yes, seeing properties of them at different times isn't the same as seeing it all together, speaking of which someone made a 4D maze game which is kind of cool, but it's still very much 3D feeling
09:29:40 <TNA-MichaelK> Minkowski space is my favorite probably, it took me some time to realize that the sun is actually touching the earth...
09:31:07 <tac-tics> tgeeky: More generally, "the most complicated space you feel comfortable working with"
09:31:15 <tac-tics> TNA-MichaelK: only in the limit, right o_O
09:32:00 <TNA-MichaelK> tac-tics: perhaps, what actually happens at that value I don't know...
09:32:13 <TNA-MichaelK> It may be what the limit is...
09:32:22 <tgeeky> tac-tics: hehe, I would work in 3D space if I thought I'd get somewhere :o
09:32:27 <tgeeky> screw time!
09:32:41 <tac-tics> tgeeky: "screw time" is the subtle idea underlying Haskell
09:32:45 <TNA-MichaelK> My feel is that real infinities reflect a need of an extra dimension, but I've seen limited support of this idea
09:32:50 <tac-tics> "You're variables do not change in time."
09:33:20 <TNA-MichaelK> tac-tics, that is a strange concept
09:33:39 <tgeeky> tac-tics: sort of. I've seen disussions on it in here. I think we're (the haskell community) is waiting for a reasonable, sensible definition of discrete time (for things like FRP specifically, but also useful in general)
09:33:40 <TNA-MichaelK> Does that mean it may be more efficient for quantum computing?
09:34:01 <tgeeky> TNA-MichaelK: nobody knows the answer to that question
09:34:05 <tgeeky> TNA-MichaelK: nobody on Earth, at least
09:34:16 <TNA-MichaelK> Well, I'm saying as an educated guess
09:34:24 <TNA-MichaelK> it seems like that answer would be yes
09:34:49 * hackagebot tokenize 0.1.3 - Simple tokenizer for English text.  http://hackage.haskell.org/package/tokenize-0.1.3 (GrzegorzChrupala)
09:34:52 <TNA-MichaelK> it'd reach out in all paths and converge on the path of least resistance which would be the most efficient
09:35:23 <TNA-MichaelK> I figured that they may have done something like that for the D-Wave
09:36:37 <TNA-MichaelK> Cale, anyway, functors?
09:37:01 <Cale> TNA-MichaelK: Okay, so if we have categories C and D, a functor F: C -> D consists of two mappings:
09:37:14 <Cale> A mapping sending objects X in C to objects FX in D
09:37:28 <Cale> and a mapping sending arrows X -> Y in C to arrows FX -> FY in D
09:37:38 <Cale> such that F(1_X) = 1_(FX)
09:38:00 <Cale> and F(u . v) = (Fu) . (Fv) for any arrows u and v in Cwhich compose
09:38:05 <Cale> C which*
09:38:19 <JoeyA> Is it possible to supply a type class instance dynamically?
09:38:52 <JoeyA> For example, suppose I want to call sort with a custom comparison function (I know there's sortBy)
09:39:08 <Cale> JoeyA: no, not really
09:39:14 <JoeyA> okay, thanks
09:39:19 <Cale> JoeyA: You can make a newtype and write an instance for the newtype
09:39:38 <Cale> JoeyA: But that'll require wrapping things in the newtype's data constructor of course
09:40:03 <Cale> If you find yourself wanting to do that a lot, then it's possible you don't want typeclasses.
09:40:12 <Cale> (but records of functions instead)
09:40:27 <Cale> There's a lot to be said for good ol' functional programming :)
09:42:42 <tac-tics> JoeyA: You could write a newtype that is the data type and the custom comparison function, and then instance the sortable class using the comparison functions stored IN the data
09:43:30 <tac-tics> data CustomOrderable a = CustomOrderable a (a -> a -> Ord)
09:43:33 <tac-tics> or something to that tune
09:43:42 <Cale> TNA-MichaelK: you brought up that monoid of paths earlier which seems to suggest you're at least familiar in passing with homotopy groups?
09:44:08 <TheLemonMan> huh, i can transform an int in a word16 but not the other way round ?
09:44:14 <TNA-MichaelK> The structure of this reminds me of calculus of variations... I may conceptually understand it, but the term is unfamiliar
09:44:27 <hpaste_> ocharle pasted “Ref type class, ambiguous type variable” at http://hpaste.org/51533
09:44:28 <ocharles_> I'm trying to write a type class that indicates that I can get a "reference" to a value, given some value.
09:44:30 <TNA-MichaelK> Cale, all of this is at the very edge of my familiarity
09:44:30 <Cale> TNA-MichaelK: The fundamental group gives rise to a functor from the category of based topological spaces (or connected topological spaces) to the category of groups.
09:44:43 <ocharles_> The above paste shows what I'm trying to do, however, I'm getting burnt by an ambiguous type variable
09:44:58 <ocharles_> I thought that the type signature for withBob or withAlice would make this unambiguous, but evidently it does not
09:45:10 <Cale> So, it sends topological spacs to groups, and continuous maps between them to group homomorphisms
09:45:36 <ocharles_> I also had a look at functional dependencies on the type class, but I don't think there is one
09:46:06 <TNA-MichaelK> That seems sensible, what of it?
09:46:20 <Cale> ocharles_: I think you don't really want a typeclass?
09:46:57 <Cale> ocharles_: Do you know about lenses (like the fc-labels package provides)?
09:47:01 <ocharles_> I do, yea
09:47:37 <TNA-MichaelK> Cale: So, what were you leading into with your mention of homotopy (before you had to explain another area of my ignorance)
09:48:49 <parcs> is threadDelay reliable enough to use to implement an interval timer?
09:48:59 <ocharles_> Cale: I chose a type class because in my actually code you may have a value of "Ref Alice", or you might actually have an Alice (which contains the id for alice too)
09:49:18 <Cale> TNA-MichaelK: oh, I just meant that it gives a nice example of a functor
09:49:30 <Cale> TNA-MichaelK: between the category of based topological spaces and the category of groups
09:56:47 <ocharles_> Cale: I've had a brief look at lenses, but I can't see how that would help either. For "withAlice" it would need a lens to go from something to an Int, but in this case something could be an Alice, or a (Ref Alice)
09:57:35 <Cale> ocharles_: Perhaps I just don't understand your problem quite fully.
09:57:47 <Cale> ocharles_: Why can't you always arrange to have one or the other?
09:58:25 <ocharles_> I'll try and expand on the example then
09:58:39 <ocharles_> (but it's mostly for convenience)
09:59:48 <ocharles_> Hrm, actually, I think I'm trying to provide convenience to a case that doesn't actually exist
10:06:06 <hpaste_> ocharles pasted “Type class/ambiguous type variable, example 2” at http://hpaste.org/51534
10:06:16 <ocharles_> Ok, I've expanded on my initial problem with the motivation
10:06:22 <ocharles_> maybe that helps explain things a little better?
10:08:21 <TheLemonMan> can i pattern match against a singleton list ?
10:08:32 <monochrom> I wonder why "t" is unused in class Ref
10:08:56 <monochrom> actually, no, I don't wonder why. I want it gone, that's it.
10:09:07 <Cale> TheLemonMan: yes
10:09:17 <monochrom> > case [0] of [x] -> x
10:09:19 <lambdabot>   0
10:09:41 <tac-tics> monochrom: Unpack those lists!
10:10:29 <ocharles_> monochrom: want it gone? I put it there to stop be being able to pass a (Ref Bob) into something that really wants a (Ref Alice)
10:10:42 <ClaudiusMaximus> @pl (\[x,y,z] -> x y z)
10:10:43 <lambdabot> (line 1, column 3):
10:10:43 <lambdabot> unexpected "["
10:10:43 <lambdabot> expecting pattern
10:11:27 <dmwit> ClaudiusMaximus: That function looks kind of hard to type.
10:11:34 <dmwit> :t \[x,y,z] -> x y z
10:11:35 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t -> t1
10:11:35 <lambdabot>     Probable cause: `x' is applied to too many arguments
10:11:35 <lambdabot>     In the expression: x y z
10:12:16 <ClaudiusMaximus> dmwit: i know, but pl doesn't care
10:12:51 <ClaudiusMaximus> @pl \x -> x x
10:12:51 <lambdabot> join id
10:13:43 <dmwit> ?pl \xs -> (xs !! 0) (xs !! 1) (xs !! 2)
10:13:43 <lambdabot> ap (ap (!! 0) (!! 1)) (!! 2)
10:14:42 <dmwit> ocharles_: That may be why you put it there, but that's not what it's doing.
10:15:46 <ocharles_> right
10:16:54 <monochrom> you already have "a" to control the distinction between use case 1 and use case 2.
10:17:58 <ocharles_> That just lets me take a distinction between a (Ref anything) and a Book
10:18:03 <ocharles_> no?
10:18:35 <monochrom> I don't know what you mean by "Ref anything"
10:19:07 <ocharles_> I mean (Ref String), (Ref Rainbow), but more specifically (Ref Book) and (Ref Edition)
10:19:08 <monochrom> class Ref a where ...; instance Ref Book where ...; instance Ref ForeignBook where ... ;  seems sufficient
10:19:19 <Cale> ocharles_: The t is unused in the type of refKey, so it'll always be ambiguous. It lets you define multiple instances, but never use any of them, because it's necessarily ambiguous which t you want.
10:19:27 <ocharles_> except you can now pass a (Ref Book) to something which operates on editions
10:19:34 <Cale> ocharles_: You could add a fundep a -> t
10:19:48 <Cale> ocharles_: but since t isn't used anyway, that would be no better than just deleting t
10:19:48 <ocharles_> Cale: I looked at fun deps, but I couldn't get that to work either
10:19:53 <ocharles_> let me try and work out if I can explain why
10:19:59 <Cale> Don't add a funder
10:20:04 <Cale> fundep*
10:20:08 <ocharles_> right, I tried it, and it didn't work, so I won't be :)
10:20:09 <Cale> Just remove t from the class
10:20:14 <Cale> It would "work"
10:20:17 <monochrom> I don't know what can possibly be meant by "pass a (Ref Book)". can't be passed.
10:20:25 <Cale> class Ref t a | a -> t where ...
10:20:49 <Cale> Yeah, Ref isn't a type and it doesn't have any values so you can't pass it to a function.
10:21:00 <Cale> Can't pass values of a type that doesn't exist :)
10:21:12 <ocharles_> monochrom: findBookEditions :: Ref a => a -> IO [Edition] -- that will work with a (Ref Book), and a (Ref Edition). But it doesn't make sense to findBookEditions for an edition
10:21:35 <monochrom> well, then don't write an "instance Ref Edition"
10:21:53 <ocharles_> but other things will work on references to editions... like findEditionRoles
10:22:01 <ocharles_> Which works on Edition, or Ref Edition
10:22:37 <monochrom> I haven't heard of findEditionRoles
10:22:53 <Cale> ocharles_: It seems like you want to pass things of an arbitrary type which supports this refKey operation, but the funny thing with that is that the only thing you can possibly do with that knowledge is to apply refKey and get an Int. So why not just use Int?
10:23:00 <monochrom> TBH I don't even know too much about findBookEditions
10:24:02 <ocharles_> Cale: because I don't want to have to get the Int out of a Book, I'd rather just pass the Book, and let this plumb it together as it needs
10:24:27 <Cale> What?
10:24:44 <ocharles_> book <- getBookById 5; editions <- findBookEditions book; display (book, editions)
10:25:01 <Cale> ... okay
10:25:08 <monochrom> I'm actually pretty sure that findBookEditions is better off a class method of its own class rather than a standalone method that relies on an ill-conceived class
10:25:14 <ocharles_> something like that - I'd rather not have to say "findBookEditions $ (bookId book)" every time I want editions of a book
10:25:22 <Cale> I don't see why code like that requires typeclasses *at all*
10:25:36 <ocharles_> i never said it did! I'm just trying to make it work, with my limited experience
10:25:54 <Cale> So make it take a book?
10:26:13 <Cale> findBookEditions :: Book -> IO [Edition] ?
10:26:15 <ocharles_> Which now means I always have to load a book if I want to find editions for it
10:26:18 <Cale> ?
10:26:34 <Cale> Well, a Book is just an Int anyway, right?
10:26:35 <ocharles_> You can only get a book by doing getBookById :: Int -> IO Book
10:26:54 <ocharles_> I think I may have simplified this example down too much :(
10:27:24 <Cale> Why not just paste your actual code?
10:27:59 <Cale> But I'm figuring that getting the ID of a book is not going to be very hard because your representation for books will make that easy (or at least it could make it easy)
10:28:09 <ocharles_> I thought it would be easier to make an example of just my error at first, and thought people might have insight from that - but it now seems maybe my design is wrong
10:28:34 <Cale> If you're capable of writing  findBookEditions (bookId book), then you have to be able to redefine findBookEditions to apply bookId for you
10:28:56 <Cale> If that's what you want :)
10:29:09 <Cale> and if the problem is that bookId is inefficient, that's another problem
10:29:20 <hpaste_> monochrom annotated “Type class/ambiguous type variable, example 2” with “Type class/ambiguous type variable, example 2 (annotation)” at http://hpaste.org/51534#a51536
10:29:50 * hackagebot configurator 0.1.0.0 - Configuration management  http://hackage.haskell.org/package/configurator-0.1.0.0 (BryanOSullivan)
10:29:58 <ocharles_> that's still not quite the problem :) I will try a 3rd explanation, thanks for bearing with me...
10:30:00 <Cale> and of course you can do something type directed like monochrom pasted there.
10:30:37 <Cale> But... it still seems mildly questionable to conflate those operations to me.
10:31:34 <monochrom> forget fixing the type error. erase everything, re-design from scratch the waterfall way.
10:35:09 <monochrom> if you don't have experience with type class, here is how to acquire more experience:
10:35:19 <monochrom> 1. start by not using type class
10:36:00 <monochrom> 2. wait until you feel that you have a lot of boilerplate
10:36:44 <monochrom> 3. consult someone who knows type class on whether type class can reduce the boilerplate. but don't be surprised if the answer is no. type class does not reduce all boilerplates.
10:36:47 <ocharles_> I think my use of type classes is otherwise fine
10:36:53 <ocharles_> in this project anyway
10:37:01 <ocharles_> but this case might not be right. anyway, working on a better example
10:37:05 <dmwit> Type classes don't really reduce boilerplate. They just give the same name to lots of different (still hand-written) functions.
10:37:51 <monochrom> well, it reduces boilerplate in client code
10:38:15 <dmwit> If what you want to do is different than "call two differently-typed things by the same name", then type classes aren't really the right solution.
10:38:49 <monochrom> so for example, I have one print rather than a printInteger, a printDouble, and a printListOfInteger
10:38:59 <dmwit> right
10:39:19 <dmwit> (...but in the instance declarations, you've still got the code you wrote for printInteger, printDouble, printListOfInteger)
10:40:11 <mdwright> dmwit: well, you have an instance for print list of printable items.
10:40:27 <dmwit> As you say.
10:40:30 <monochrom> well, I factor about the common part into "print x = putStrLn (show x)", and the uncommon parts into Show instances
10:40:45 <monochrom> s/factor about/factor out/
10:41:18 <mdwright> dmwit: so if you have a list of doubles, you don't have to write a separate functions for printing a list of doubles vs. printing a list of integers. you just write something that prints a list of printables.
10:41:28 <mdwright> so in some sense, you do get to remove boilerplate there
10:41:54 <monochrom> presumably there are longer code than print that will benefit from the Show class, too.
10:42:12 <CarsonLynn> what what
10:42:30 <dmwit> ocharles_: Perhaps you meant something like this: data Book = {- ... -}; data Edition = {- ... -}; newtype BookId = BookId Int; newtype EditionId = EditionId Int
10:42:42 <dmwit> class Ref t a where getId :: t -> a
10:42:53 <dmwit> instance Ref Book BookId; instance Ref Edition EditionId
10:43:11 <hpaste_> ocharles pasted “Book, editions and references” at http://hpaste.org/51538
10:43:24 <ocharles_> Ok, that's a paste that's true to how my app is actually structured
10:43:38 <ocharles_> All I'm trying to do is avoid that "toRef" bit on line 54
10:45:19 <monochrom> I would not avoid the toRef bit. it's just fine.
10:45:29 <ocharles_> Which means letting findBookEditions be able to take a (Loaded Book) or a (Ref Book)
10:45:48 <ocharles_> well, that's one option
10:45:56 <ocharles_> (and what I have at the moment :))
10:46:29 <dmwit> class Edited f where findEditions :: f Book -> IO [Loaded Edition] -- ?
10:47:02 <TheLemonMan> is manually consuming a list deprecated by haskell conventions or i can just go with that ?
10:47:13 <monochrom> oh, smart, yeah a *->* class is in order
10:47:46 <tac-tics> TheLemonMan: manually consuming a list?
10:47:48 <dmwit> TheLemonMan: If "manually" means pattern-matching, that's normal.
10:48:00 <ocharles_> dmwit: hrm, where the LoadedEntity one just calls "toRef" and defers to the Ref instanceL
10:48:02 <ocharles_> ?*
10:48:02 <lambdabot> Maybe you meant: . ? @ v
10:48:07 <dmwit> TheLemonMan: Though many such things can be done with a fold, map, or filter instead.
10:48:32 <TheLemonMan> without pattern matching, i mean by using stuff like "tail $ tail $ xs"
10:48:49 <dmwit> ocharles_: I would guess the Loaded instance calls objId.
10:48:54 <tac-tics> TheLemonMan: It's not deprecated, but it's generally preferred to pattern match
10:49:12 <dmwit> But calling out to the Ref instance is probably fine, too. I dunno.
10:49:15 <dmwit> It's your code.
10:49:25 <TheLemonMan> well, you can't pattern match ByteStrings for example
10:49:28 <tac-tics> TheLemonMan: When you see "tail xs", you don't know whether or not that will fail at runtime
10:49:28 <tac-tics> But looking at "case xs of ..." you know you're cases are handled
10:49:43 <dmwit> TheLemonMan: That kind of thing is generally a sign you're doing something wrong.
10:50:07 <tac-tics> TheLemonMan: Either case ... of or using a function defined on the structure you want
10:50:12 <dmwit> For abstract data types like ByteStrings there's not much else you can do, of course.
10:50:25 <tac-tics> ByteString has things like map and foldl defined on it as well
10:50:42 <monochrom> ok, you don't mean to get rid of toRef
10:50:47 <TheLemonMan> but that doesnt allow me to access list two elements a time
10:51:17 <monochrom> you mean to factor out what's common and what's uncommon in "findBookEditions $ toRef book" and "findBookEditions $ (editionBook $ copoint edition)"
10:51:24 <dmwit> TheLemonMan: What do you mean?
10:51:33 <tac-tics> TheLemonMan: Like I said, though, you can use partial functions. They aren't preferred, but in practice, you use them well enough.
10:51:59 <TheLemonMan> if i need to access array[i] and array[i+1] in the same iteration i can't use a fold or a map
10:51:59 <tac-tics> TheLemonMan: Think of partial functions (like tail, head, and (!!)) as using explicit down-casting in C++ or Java
10:52:04 <dmwit> > case [0..5] of (x:y:rest) -> printf "first I accessed %d, then I accessed %d!" x y :: String
10:52:05 <lambdabot>   "first I accessed 0, then I accessed 1!"
10:52:07 <monochrom> actually I don't see enough benefit to factor that out
10:52:24 <ocharles_> monochrom: maybe, but the only thing that is common is "findBookEditions"
10:52:26 <dmwit> TheLemonMan: First either chunk it or zip it with itself.
10:52:46 <dmwit> > let twoAtOnce xs = zip xs (drop 1 xs) in twoAtOnce [0..5]
10:52:47 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5)]
10:52:59 <ocharles_> monochrom: basically, this function is not the only one like this - there are others like "findAssociatedUrls" "findRoles" "addRole", and a bunch more
10:53:21 <ocharles_> and (at the moment) I usually have Loaded objects to work with, but know I won't in the future. it's just annoying to have to call toRef everywhere
10:53:28 <ocharles_> at least haskell forces me to remember
10:53:41 <TheLemonMan> i taught about chunking it an pairing it in tuples but doesnt sound so clean
10:53:56 <monochrom> well I don't know findRoles etc, so no comment on whether there is anything more to factor out
10:53:56 <tac-tics> > let twoAtOnce xs = zip xs (drop 1 xs) in twoAtOnce "Hello"
10:53:57 <lambdabot>   [('H','e'),('e','l'),('l','l'),('l','o')]
10:54:20 <TheLemonMan> or, better, i could get rid of bytestrings if i doscover how to unpack an integer into a list
10:54:34 <ocharles_> monochrom: it's just the same so far - turn a loaded object into a reference, and work with that.
10:54:42 <TheLemonMan> i saw serialization is possible using Data.Binary but it uses Bytestrings
10:54:43 <ocharles_> meh, Ref and toRef it is
10:54:48 <dmwit> TheLemonMan: "Unpack an integer into a list"?
10:55:07 <dmwit> > show 12345 -- you mean like this, or what?
10:55:08 <lambdabot>   "12345"
10:55:34 <shachaf> > (flip replicate ()) 12
10:55:36 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),()]
10:55:48 <TheLemonMan> like 0xdeadbeef -> [0xDE, 0xAD, 0xBE, 0xEF]
10:56:16 <dmwit> > showIntAtBase 1 (const '0') 12 ""
10:56:17 <lambdabot>   "*Exception: Numeric.showIntAtBase: applied to unsupported base 1
10:56:21 <TheLemonMan> i could just write a function using bit ops to do so but i think there's something better
10:56:21 <dmwit> aww
10:56:42 <TheLemonMan> sort of the struct.pack/unpack in python
10:57:09 <dmwit> You're doing that via ByteString? O_o
10:57:34 <tac-tics> dmwit: Data.Binary apparently uses ByteString
10:57:42 <TheLemonMan> im using Data.Binary
10:59:07 <dmwit> > showIntAtBase 16 intToDigit 0xdeadbeef ""
10:59:08 <lambdabot>   "deadbeef"
10:59:28 <rwbarton> @hoogle putWord32be
10:59:29 <lambdabot> No results found
10:59:49 * hackagebot aeson 0.3.2.12 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.3.2.12 (BryanOSullivan)
11:00:16 <dmwit> TheLemonMan: Is the integer bounded or not?
11:00:59 <TheLemonMan> its bounded to 32bit if its what you want to know
11:01:09 <dmwit> > map ord . showIntAtBase 256 chr $ 0xdeadbeef
11:01:11 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
11:01:11 <lambdabot>         against inferred ty...
11:01:19 <dmwit> :t chr
11:01:20 <lambdabot> Int -> Char
11:01:28 <dmwit> > map ord . showIntAtBase 256 chr 0xdeadbeef $ ""
11:01:30 <lambdabot>   [222,173,190,239]
11:01:42 <dmwit> > [0xde, 0xad, 0xbe, 0xef]
11:01:44 <lambdabot>   [222,173,190,239]
11:01:49 <rwbarton> what are you actually trying to do? I'm lots
11:01:51 <rwbarton> *lost
11:02:00 <dmwit> rwbarton: He's struggling to write that one-liner above.
11:02:10 <dmwit> =P
11:02:29 <rwbarton> right, but does he actually want that or putWord32be or something involving zip and tail or ...
11:06:11 <dmwit> I guess unpack . runPut . putWord32be is pretty legitimate, too.
11:06:28 <hpaste_> monochrom annotated “Book, editions and references” with “Book, editions and references (annotation)” at http://hpaste.org/51538#a51539
11:06:53 <monochrom> that is the only refactoring seen so far
11:07:24 <monochrom> and screw camel case
11:08:09 <monochrom> when you change from "length" to "genericLength" or back, that's when camel case is frustrating
11:09:02 <Veinor> arg, i hate dealing with optional arguments
11:09:23 <Veinor> i'm not sure whether to split this function into two or have a Maybe [a] argument
11:09:25 <dmwit> Veinor: You know the "record" trick, right?
11:09:41 <tomh> hmm what converts a double to float in haskell?
11:09:46 <Veinor> dmwit: yeah, i feel like this case is too simple for that
11:10:38 <dmwit> > fromRational . toRational $ (3.14 :: Double) :: Float
11:10:39 <lambdabot>   3.14
11:10:49 <dmwit> tomh: fromRational . toRational =)
11:10:50 <Veinor> specifically, i'm writing a markov chain based text generator, and the optional argument is the initial context/history/whatever to use
11:10:56 <tomh> hehe ok thanks
11:11:00 <dmwit> tomh: (And I wasn't sure that was the answer until I tried it. =P)
11:11:01 <tomh> seems overly complicated :P
11:11:23 <tac-tics> tomh: It's even worse when you think about how fromRational . toRational should be the same as id
11:11:31 <tac-tics> @type fromRational . toRational
11:11:32 <lambdabot> forall a a1. (Fractional a, Real a1) => a1 -> a
11:11:38 <tac-tics> @type id
11:11:39 <lambdabot> forall a. a -> a
11:12:06 <zachk> you forget about the real world
11:12:29 <Veinor> so, the user can either specify a context or ask the function to pick one
11:13:11 <Veinor> right now i therefore have markov, markovWithContext, markovM, and markovWithContextM
11:14:59 <Veinor> i could have just markov and markovM, and have them each take a Maybe [a] that's Just a context or Nothing to have one be chosen
11:15:06 <Veinor> but i dislike that for reasons i can't explain
11:15:38 <dmwit> I'm confused.
11:15:55 <dmwit> When I compile int main() { float x = (double)3.14; }, it doesn't seem to do any conversion.
11:16:33 <hpaste_> dmwit pasted “assembly? in MY #haskell?” at http://hpaste.org/51540
11:16:34 <Veinor> blah, i hate having to learn style
11:19:24 <monochrom> I am even surprised that it bothers to store something into a local variable at all
11:19:37 <dmwit> Well, I didn't turn on any optimizations.
11:20:05 <dmwit> I also tried double x = 3.14; float y = x; and it still doesn't do conversion, it just has two different constants in the assembly text.
11:20:26 <monochrom> oh, that's fun
11:20:43 <dmwit> But I know what to do.
11:20:52 <dmwit> Now I'm compiling float f(double x) { return x; }
11:20:54 <Veinor> -O-1
11:22:45 <dmwit> I don't really know what fldl and fstps do.
11:23:22 <hpaste_> dmwit pasted “float f(double x) { return x; }” at http://hpaste.org/51541
11:23:38 <Veinor> i'm leaning towards just using Maybe and biting the bullet
11:23:49 * olsner makes some meanings up for dmwit: float load long, float store packed single
11:24:14 <dmwit> Seems likely enough.
11:24:15 <monochrom> ld is load, st is store, f is floating-point
11:24:32 <monochrom> l and s are long and short
11:24:46 <dmwit> So, yeah, probably converting from double to float will be significantly faster in C than in Haskell.
11:25:02 <dmwit> Good ol' hardware support.
11:25:08 <monochrom> p may be pop
11:26:24 <olsner> fldl might be at&t syntax for FLD (which loads a float from memory) plus an -l suffix
11:27:22 <olsner> and there is an FSTP meaning store (to memory) and pop (from x87 stack)
11:27:33 <koala_man> what kind of catchy papers are there on why strong, static typing is awesome? like Theorems for Free
11:27:55 <monochrom> "well-typed programs can't be blamed"
11:27:55 <koala_man> s/papers/&, articles, books, whatever/
11:28:20 <mrlemao> Anyone knows of a 1-day haskell course in the US (preferrably in the NYC area)? Maybe there are such course in universities where outsiders can participate?
11:28:22 <shawn> hi i am new i want to know if this software is usefull with pd or csound
11:28:33 <koala_man> monochrom: thanks, I'll check it out!
11:29:03 <shawn> is it better?
11:29:55 <shawn> ?
11:29:57 <shawn> ?
11:35:11 <shawn>  if this is a chat room why arnt we talking
11:35:23 <HugoDaniel> :)
11:35:45 <HugoDaniel> haskell is not a software
11:35:48 <HugoDaniel> its a programming language
11:35:49 <monochrom> what is a chat room?
11:36:01 <Clint> it's a room with padded walls
11:36:05 <HugoDaniel> pd is a tool and visual programming language
11:37:01 <HugoDaniel> most programming languages provide a way to import/export "modules" written in C (which is another programming language, a much older one)
11:38:15 <shawn> so can i make music with it like csound
11:38:29 <shawn> or make games with it
11:38:33 <dmwit> ?faq so can i make music with it like csound
11:38:33 <lambdabot> The answer is: Yes! Haskell can do that.
11:38:34 <HugoDaniel> if pd can do that (export/import C), then you can use haskell with pd (because haskell can do that too)
11:38:43 <ClaudiusMaximus> shawn: i started recently writing (in haskell) a compiler from pd to c++, didn't get very far so far; in 2007 i used plugins to embed haskell code in pd (project now bitrotten); i've also communicated between pd and haskell via network and offline files
11:38:48 <monochrom> have you already made a game?
11:39:09 <HugoDaniel> shawn: so, with csound the thing is different, you can use some packages in haskell that use csound to allow you to be more expressive in doing your stuff
11:39:25 <HugoDaniel> haskell is quite an expressive language, and a very rewarding experience if you want to learn it well
11:39:36 <HugoDaniel> shawn: look: http://hackage.haskell.org/package/csound-expression
11:39:52 <HugoDaniel> with that package you can kick away with your csound beats and experimental stuff
11:40:20 <ClaudiusMaximus> there are also haskell bindings to supercollider (sc3)
11:41:15 <HugoDaniel> :)
11:41:34 <HugoDaniel> so, feel welcome to try all your ideas with haskell
11:41:46 <HugoDaniel> if you need help getting started just ask away
11:41:50 <HugoDaniel> we are here to help
11:41:52 <shawn> embed haskell code in pd?
11:42:04 <HugoDaniel> well, sort of
11:42:17 <HugoDaniel> most likely the easiest approach is the one that ClaudiusMaximus talked about
11:42:26 <HugoDaniel> trying to communicate with pd through some sort of protocol
11:42:49 <ClaudiusMaximus> shawn: yeah. that embedding was a nightmare! lost most of the benefits of haskell's expressiveness...
11:44:28 <ClaudiusMaximus> so i now tend to keeping them separate..  say by using haskell to write a "score" and getting pd to play it back
11:44:46 <shawn> Claudius your on the pd form right
11:44:50 * hackagebot GA 0.2 - Genetic algorithm library  http://hackage.haskell.org/package/GA-0.2 (KennethHoste)
11:44:53 <shawn> ?
11:45:13 <ClaudiusMaximus> shawn: very rarely these days; i tend to like mailing lists more
11:45:49 <ClaudiusMaximus> shawn: there's also a pd channel, #dataflow
11:54:19 <dmwit> tomh: I just benchmarked "fromRational . toRational" vs. calling out to C via the FFI.
11:54:37 <dmwit> tomh: Here, it's 250ns via the FFI and 450ns in pure Haskell.
11:55:16 <dmwit> 263+-5/432+-15 more precisely
11:55:19 <Cale> realToFrac can be mildly obscene performance-wise
11:55:23 <parcs> @hoogle comparing
11:55:23 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
11:55:25 <shawn> will i think i have all that i need, blue csound , sc  and pd and processing i just think i just need to learn java and c++  then
11:55:26 <dmwit> :t realToFrac
11:55:27 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
11:55:36 <dmwit> ah, that's a handy abbreviation
11:55:42 <dmwit> (I assume.)
11:55:45 <Cale> yes
11:56:04 <ClaudiusMaximus> > realToFrac 1e1000
11:56:05 <lambdabot>   Infinity
11:56:14 <Cale> In our code, we have a bunch of RULES for eliminating realToFrac when we can get away with the unsafeCoerce implementation.
11:56:56 <ClaudiusMaximus> i imagine going via rational to take varying amounts of time/space for small or big numbers
11:57:27 <dmwit> Oops, with optimization, it's 150ns via C. (Still 450ns in pure Haskell, though.)
11:58:48 <dmwit> The guy across from me is surprised GHC doesn't have some atoms for the conversions that can be done quickly in hardware.
11:58:59 <dmwit> (I'm surprised about it, too, now that it's been suggested. =)
11:59:14 <Cale> It's pretty easy to do at the library level.
11:59:23 <dmwit> Really?
11:59:27 <Cale> yes
11:59:43 <dmwit> Doesn't invoking the FFI have a bit more overhead than is really necessary for this kind of thing?
11:59:45 <Cale> The RULES thing that I mentioned is essentially that, though we only handle the trivial case.
11:59:59 <Cale> Oh, well, I guess you could do even better.
12:00:11 <dmwit> Right.
12:00:17 <Cale> But I mean, if you have better special case implementations, you can use them like that
12:01:03 <dmwit> Yeah, I mean, I'm surprised there aren't a handful of (monomorphic) functions like GHC.Num.doubleToFloat or so.
12:01:20 <dmwit> That get compiled to something insanely fast on hardware that offer it.
12:01:41 <Cale> GHC.Prim has appropriate unboxed primitives for all that.
12:02:35 * dmwit has a peek
12:02:37 <Cale> float2Double# :: Float# -> Double#, double2Int# :: Double# -> Int#, double2Float# :: Double# -> Float#, etc.
12:02:51 <kelvie_> Has the planet haskell RSS feed not been updating?
12:03:03 <dmwit> aha, float2Double#
12:03:08 <dmwit> Oh, yup, you pasted them.
12:06:38 <dmwit> Oh, wow, the GHC.Prim version is much, much faster.
12:06:52 <dmwit> 18ns +- 0.24
12:06:56 <tomh> dmwit: how did you did the call via FFI?
12:07:20 <dmwit> tomh: I'll hpaste. One second.
12:07:20 <copumpkin> the GHC.Prim one probably just expands to an instruction or two in the codegen
12:07:25 <tomh> cool thanks
12:07:26 <dmwit> copumpkin: Right.
12:07:48 <shawn> any one doing any idm\break-core  things
12:08:05 <hpaste_> dmwit pasted “test.hs” at http://hpaste.org/51542
12:08:37 <hpaste_> dmwit pasted “double_to_float.c” at http://hpaste.org/51543
12:08:44 <dmwit> tomh: There you go.
12:08:52 <dmwit> tomh: f_ghc is fastest, of course =)
12:09:23 <tomh> do I need the double_to_float.c too?
12:10:07 <dmwit> tomh: Yes.
12:10:23 <tomh> but if I use f_ghc I dont need it or?
12:10:34 <dmwit> tomh: But really, you should only use that if you care about supporting compilers other than GHC...
12:10:46 <dmwit> tomh: Correct, f_ghc is pure Haskell.
12:11:00 <tomh> I only care about GHC currently :)
12:11:05 <dmwit> right
12:11:20 <cgroza> Hello everyone. I have encountered a "\_" being passed as a function. What is it and what does in do?
12:11:22 <tomh> probably UHC at some point, but dont think the rest compiles with that anyway
12:11:42 <tac-tics> cgroza: _ is a variable name (kinda)
12:12:02 <tac-tics> \_ -> ... means "pass me anything, but I'm not going to actually do anything with it"
12:12:07 <tac-tics> @src const
12:12:07 <lambdabot> const x _ = x
12:12:16 <tac-tics> takes two arguments, x, and _ (which is just thrown away)
12:12:31 <cgroza> tac-tics: and what does \_ ->  return?
12:12:39 <cgroza> tac-tics: its first argument?
12:12:50 <tac-tics> cgroza: it's not a full function. It's missing a body
12:12:55 <Cale> cgroza: \ is lambda
12:12:56 <tac-tics> for example
12:13:00 <dmwit> tac-tics: No, (\_ -> e) returns e.
12:13:03 <tac-tics> > (\_ -> 5) 0
12:13:04 <lambdabot>   5
12:13:09 <Cale> cgroza: _ is a wildcard pattern which matches anything and discards it
12:13:21 <saati> isn't this just a confusing way to write const?
12:13:21 <tomh> dmwit: but thanks for the benchmark, probably gonna be useful for me as I use it in a game :)
12:13:25 <Cale> -> separates the parameters of a lambda from the body of the function
12:13:25 <cgroza> I think I get it. Thank you.
12:13:31 <tac-tics> > (\x -> \_ -> x) "a" "b"
12:13:32 <lambdabot>   "a"
12:13:58 <dmwit> err... sorry tac-tics, that was supposed to be aimed at cgroza
12:14:10 <cgroza> thanks, it all makes sense now :).
12:14:31 <dafis> dmwit: On which compiler have you benchmarked fromRational . toRational?
12:14:38 * tac-tics is so offended by dmwit's typo 
12:14:38 <tac-tics> :)
12:14:50 <dmwit> dafis: GHC 7.3.20110726
12:15:20 <dafis> dmwit: out of curiosity, can you benchmark it on ghc <= 7.0?
12:15:31 <dmwit> I'd rather not. The code is there, benchmark it yourself.
12:16:32 <cgroza> Ok, I have this:   (>>) a b = a >>= \_ -> b . How does the lambda return the b? I haven't passed b to it? Or there is something I don't know about Haskell?
12:16:55 <Cale> cgroza: b is in scope there
12:17:02 <Cale> cgroza: It's one of the parameters to >>
12:17:18 <Cale> btw, this is the same as  a >> b = a >>= const b
12:17:31 <cgroza> Cale: thanks. I thought you get onother scope in a lambda. :D thanks.
12:17:44 <Cale> cgroza: Well, it's a nested scope
12:18:03 <Cale> So all the things which were in scope outside are still in scope, plus the parameters of the lambda
12:18:31 <cgroza> Cale: It makes sense now. Thanks.
12:26:10 <dafis> dmwit: c/Rational/double2Float; 7.2.1: 119.7ns / 287.7ns / 18.8ns; 7.0.4: 119.5ns / 10996.7ns / 18.3ns
12:26:38 <monochrom> dmwit: try to use realToFrac, try not to use fromRational.toRational
12:27:43 <monochrom> if realToFrac is equally slow, I'm convinced. if you only find that fromRational.toRational is slow, that isn't the whole story
12:28:27 <monochrom> GHC has some "specialize" pragmas for fromIntegral and realToFrac for many pairs of types
12:28:31 <tromp> @pl \c (_:t) ->  '.':c t
12:28:31 <lambdabot> (. tail) . (('.' :) .)
12:29:12 <monochrom> (and perhaps some rewrite rules, I don't remember)
12:29:23 <dafis> monochrom: rewrite rules, but they aren't guaranteed to fire
12:29:40 <monochrom> right, still test it, but test the right thing
12:29:48 <ben> hm
12:30:05 <ben> turns out that let loop = forever $ forkIO loop in loop is not a forkbomb but still really annoying to get rid of
12:30:49 <tac-tics> ben answers that hard questions :)
12:31:48 * monochrom wonders in what sense it is not a forkbomb
12:32:09 <tac-tics> monochrom: Maybe it's that there lazy evaluation
12:32:26 <ben> monochrom: It doesn't actually spawn new processes, only "light" threads?
12:32:45 <ClaudiusMaximus> ben: now try adding some safe foreign calls into the loop :)
12:33:16 <monochrom> yes it only spawns new green threads, but unboundedly many
12:35:01 <monochrom> safe FFI inside those forkIO's is worse because every invocation spawns a new OS thread as far as a recent paper promises
12:35:51 <jonny> this is a awesome high level programming language
12:36:20 <monochrom> the full story is a bit more complicated than that, but many OS threads are still spawned
12:37:42 <monochrom> if you are waiting for N safe foreign calls in parallel, you have at least N OS threads
12:48:10 <dmwit> monochrom: Good tip; realToFrac is considerably faster than fromRational . toRational (and on par with double2Float#).
12:48:49 <dmwit> tomh: (Also aimed at you, I guess.)
12:51:33 <dmwit> Sorry for the slow reply, I got engrossed in an analysis of a go position. =P
12:51:46 <ion> fromRational . toRational can’t be optimized by the compiler?
12:52:08 <tac-tics> @type realToFrac
12:52:09 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
12:52:15 <dmwit> Perhaps it *could* be, in an ideal world.
12:52:21 <dmwit> But it seems not to be, in the current world.
12:52:46 <dmwit> You could probably add a rewrite rule like rewrite fromRational . toRational to realToFrac, and then it would be.
12:53:03 <dmwit> But if you knew enough to do that, you already knew enough not to write fromRational . toRational in the first place. =P
12:53:11 <monochrom> you could write 3 or more rewrite rules for it. one for fromRational . toRational, one for fromRational (toRational x), one for fromRational $ toRational x, one for (f . fromRational) . toRational ...
12:53:26 <dmwit> ugh
12:53:41 <dafis> dmwit: realToFrac is rewritten into double2Float - if the rule fires
12:53:45 <dmwit> This makes me so happy that I haven't had to do low-level optimizations to make my code fast enough (yet).
12:53:48 <monochrom> and yes I now actually have written 4 rules, not 3. that's the point.
12:54:16 <dmwit> dafis: Yes, I understand the import of monochrom's suggestion.
12:55:42 <dmwit> It seems to be consistently 1.5ns slower, who knows why.
12:56:06 <dafis> dmwit: a rewrite rule fromRational . toRational -> realToFrac wouldn't be a good idea, since realToFrac = fromRational . toRational ~> loop, if you're lucky
12:56:33 <dmwit> okay
12:57:43 <monochrom> oh hehehe
13:03:33 <cgroza>  
13:04:19 <cgroza> where do I find the type signature of (<-)? I want to see how it works....
13:04:34 <monochrom> it is a reserved word, no type
13:04:58 <cgroza> monochrom: so it is not a function?
13:05:12 <monochrom> do { x<-m; blah x } is translated to m >>= \x -> blah x systematically
13:05:17 <dibblego> no, it is syntax
13:05:19 <hpc> cgroza: it has the same type as "module" :P
13:06:03 <cgroza> monochrom: thanks. that is what I wanted to know.
13:07:10 <applicative> cgroza, usually people mistake the 'operators' in Haskell for reserved words ...
13:07:21 <applicative> but this really is one
13:07:37 <tac-tics> @src otherwise
13:07:37 <lambdabot> otherwise = True
13:07:41 <tac-tics> @type otherwise
13:07:42 <lambdabot> Bool
13:08:00 <applicative> > not otherwise
13:08:01 <lambdabot>   False
13:08:12 <monochrom> "<-", "\", "->" are reserved words. ">>=" is user-defined, although the Prelude already defines something for it
13:14:54 * hackagebot hakyll 3.2.0.7 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.2.0.7 (JasperVanDerJeugt)
13:19:26 <duairc> Hey, I'm trying to get gitit to compile on GHC 7.2. The offending line of code is the setContext line in this module: https://raw.github.com/jgm/gitit/master/Network/Gitit/Plugins.hs
13:20:08 <duairc> The type of setContext changed from GHC 7 to GHC 7.2, and I don't know what I need to change to get it to work. Could anybody who's more familiar with this stuff give me a hand?
13:22:57 <Veinor> is there anything like Network.HTTP, but with bytestrings?
13:23:44 <ion> Perhaps http://hackage.haskell.org/package/http-enumerator is useful to you.
13:23:52 <Veinor> i'm using it to wget a couple of 500kb files and getting a hundred megabytes of memory usage.
13:24:38 <Veinor> oh, that looks promising
13:24:54 * hackagebot cofunctor 0.1.0 - A small library providing a contravariant functor class  http://hackage.haskell.org/package/cofunctor-0.1.0 (BrandonSimmons)
13:24:56 * hackagebot contravariant 0.1.3 - Haskell 98 contravariant functors  http://hackage.haskell.org/package/contravariant-0.1.3 (EdwardKmett)
13:25:07 <monadic> Going to ask this again, but it seems nobody has an answer... Is there a good way to make a global table-of-contents similar to the other GHC provides for most of the core libraries, but for all installed libraries on your system?
13:25:16 <edwardk_> interesting timing
13:27:06 <edwardk_> does anyone know who brandon simmons is?
13:28:08 <monadic> ListInstance.hs:5:8: Could not find module `GHC.Generic' Perhaps you meant GHC.Generics (from ghc-prim)
13:28:14 <monadic> So happy I upgraded to 7.2 right now. :)
13:28:23 <byorgey> monadic: you should already have such a table of contents.  check in ~/.cabal/share/doc/index.html, or wherever cabal installs stuff
13:29:09 <monadic> byorgey: What about stuff globally?
13:29:34 <monadic> byorgey: My docs are in /usr/share/doc
13:30:06 <byorgey> monadic: hmm, not sure about that
13:30:08 <edwardk_> preflex: xseen jberryman
13:30:08 <preflex>  jberryman was last seen on freenode/#haskell 147 days, 13 minutes and 59 seconds ago, saying: ezyang: btw, always enjoy the blogs :)
13:30:23 <byorgey> monadic: the only things in there should be the Haskell Platform packages anyway
13:30:31 <gienah> monadic: you can run a script like: http://hpaste.org/42236
13:31:27 <monadic> byorgey: Yeah I want it for everything
13:32:20 <monadic> gienah: Brilliant.
13:35:15 <gwern> @quote brilliant
13:35:15 <lambdabot> No quotes match. My mind is going. I can feel it.
13:37:59 <duairc> Has anybody used GHC 7.2's GHC.setContext?
13:38:17 <noremac> heyy guys supp!!!!!!!!!!!
13:38:39 <byorgey> hi noremac
13:39:15 <byorgey> I guess I wasn't enthusiastic enough
13:39:23 <edwardk_> preflex: xseen deewiant
13:39:23 <preflex>  deewiant was last seen on freenode/#haskell 360 days, 1 hour and 27 seconds ago, saying: > Data.Traversable.traverse pure $ [[1,2,3],[1,2,3]] :: [[[Int]]]
13:40:33 <eigenweave> is it a good idea to use a parser expression grammar as a type system?
13:40:33 <dafis> hi noremac
13:42:23 <edwardk_> eigenweave: ?
13:42:51 <edwardk_> well folks have done regular expression types, you might get away with it
13:42:57 <k0ral> hi, I've got troubles generating a haddock for my project
13:42:58 <edwardk_> but in practice i'd want a lot of things it doesn't cover
13:43:18 <k0ral> I'm always getting the error message: "cabal: Can't find transitive deps for haddock"
13:43:26 <noremac> do any of you guys play goldeneye online on the Wii?
13:43:39 <monochrom> what is Wii?
13:43:39 <k0ral> I'm using the command "cabal haddock" which used to work for other projects
13:43:52 <dafis> what is goldeneye?
13:44:12 <noremac> the game system the Wii
13:44:47 <noremac> goldeneye is the james bond game where you kill people
13:44:47 <benmachine> my wii stopped working recently :(
13:44:47 <monochrom> I play goldeneye online on Game Boy
13:44:50 <eigenweave> edwardk_: it's for javascript, I'm using PEG.js to create an embedded language
13:44:59 <eigenweave> PEGs seemed very similar to Haskell's algebraic data types
13:45:07 <eigenweave> but I couldn't find a clear comparison of the two
13:45:23 <benmachine> in this regard my N64 has outlasted it by a decade or so
13:45:23 <noremac> do you know whats wrong with your wii benmachine
13:45:27 * benmachine still plays perfect dark
13:45:40 <benmachine> noremac: no, but I suspect it's just dirty; cleaning discs makes it work again, but only temporarily
13:45:48 <noremac> i know that game its sooo sick
13:46:04 <noremac> and ohh thats good...sorta
13:46:06 <monochrom> it's perfectly dark
13:46:14 <ddarius> Feel free to have conversations about old video games in #haskell-blah.
13:46:17 <kmc> so this is #videogames now?
13:46:34 <monochrom> o hai can you make video games in haskell?
13:46:44 <dafis> @faq
13:46:44 <lambdabot> The answer is: Yes! Haskell can do that.
13:46:45 <noremac> idk
13:46:47 <kmc> monochrom, no, it is forbidden by the Haskell Report
13:47:00 <dafis> kmc++
13:47:03 <monochrom> (my latest strategy against that is "have you already made a video game?")
13:47:34 <noremac> so do you guys know how to hack computers?
13:47:44 <kmc> yeah
13:47:52 <ddarius> noremac: That is also not on-topic here.
13:48:01 <Nafai> monochrom: yay, a question I can say yes to!
13:48:02 <kmc> i usually start with a sledgehammer to break them into a couple manageable pieces
13:48:08 <monochrom> nice!
13:48:10 <kmc> then you can go at it with a hatchet
13:48:17 <kmc> dropping them off the roof works too
13:48:28 <monochrom> kmc, don't you have to heat it and almost melt it too?
13:48:33 <Nafai> kmc: there's a great video on youtube of Ice T destroying a broken Mac Book Pro
13:48:46 <monochrom> ok, sword-making is off-topic too I guess
13:49:33 <noremac> so what do you guys usually talk about on haskell
13:49:53 <b_jonas> sword-making is off-topic? wtf
13:49:58 <kmc> noremac, how much Java sucks
13:50:13 <noremac> peace i gotta go
13:50:20 <kmc> also how everyone is dumb for not using Haskell
13:50:25 <kmc> haha
13:50:30 <jrk> a java fanboy
13:50:34 <jrk> in disguise
13:51:05 <ClaudiusMaximus> i wish i could figure out this algorithm :(  these maths papers are so.. terse.  i figured out the algorithm to turn external angle into angled internal address, but i need the reverse - the paper says "this algorithm can be inverted" but doesn't show how. my brain hurts..
13:51:39 <jrk> just do f^-1
13:51:43 <jrk> (sorry :)
13:51:47 <monochrom> angle and address don't sound compatible with each other
13:52:05 <tsuraan> is it a bug that the functions in Data.Enumerator.List eat EOF instead of passing it down the chain?  It seems sort of odd.
13:52:13 <monochrom> unless "address" refers to some funky math idea
13:52:51 <byorgey> monochrom: I'm guessing some sort of fractal/tiling sort of thing, and "address" refers to a system for identifying some sort of subpiece of it
13:53:06 <ClaudiusMaximus> it's maths - two ways of describing parts of the Mandelbrot set that this paper shows are equivalent, and gives an algorithm for converting one to the other
13:53:52 <byorgey> ClaudiusMaximus: how complex is the algorithm?  Can you write it down as a function composition chain?
13:54:19 <ClaudiusMaximus> byorgey: let me see if the version on hackage isn't way out of date compared to my working copy...
13:54:19 <byorgey> then you only have to worry about how to invert each individual function in the chain
13:56:10 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/ruff/0.1/doc/html/Fractal-RUFF-Mandelbrot-Address.html#v:angledInternalAddress is the algorithm from the paper.  my attempt at inverting it was via search, which is somewhat.. slow
13:58:00 <ClaudiusMaximus> but i probably shouldn't work on it (or anything else) any more tonight
14:05:00 * hackagebot chan-split 0.2.0 - Concurrent Chans as read/write pairs. Also provides generic  Chan, Cofunctor classes.  http://hackage.haskell.org/package/chan-split-0.2.0 (BrandonSimmons)
14:07:39 <roconnor_> I'm confused by the Kleisli adjunction.  We have F(X) = X and G(Y) = M(Y) for how the two functors operate on objects. but then FGF(X) = MX, but I thought FGF was supposed to equal F in an adjuction?
14:08:56 <JoeyA> Does (un)wrapping a value in a newtype have any overhead?
14:09:37 <tromp> none whatsoever
14:10:04 <tromp> there's no wrapper at runtime
14:10:20 <JoeyA> thanks
14:10:36 <benmachine> it can sometimes interfere with optimisations, thoug
14:10:42 <JoeyA> hmm
14:11:08 <JoeyA> What about f $ x versus f x?
14:11:21 <benmachine> that will be inlined if you optimise, almost certainly
14:11:45 <JoeyA> Are there any weird strictness differences between f $ x and f x?
14:12:05 <dafis> no
14:12:10 <JoeyA> thanks
14:12:31 <ben> who's the guy with the yesod book
14:14:34 <monochrom> there is only type-checking weirdness for $, and even that is worked around by some other weirdness
14:14:43 <Veinor> the more i wrangle with haskell and bytestrings and memory usage, the less i enjoy doing it
14:14:57 <byorgey> roconnor_: no, there is a natural transformation  eps . F : FGF -> F
14:15:03 <byorgey> roconnor_: but they do not have to be equal
14:15:14 <roconnor_> oh
14:15:24 <ben> http://www.yesodweb.com/book/enumerator seems to have the same 'exercises' and 'summary' sections three times and i'm not sure who to bother about it
14:15:51 <roconnor_> byorgey: I guess we have left the land of galois connections
14:15:51 <byorgey> roconnor_: perhaps you are thinking of the requirement that  doing (F eta) followed by (eps F) must be the identity from F -> F
14:16:05 <Veinor> this seems to be the problem that i keep running into: haskell's basic types ar esimple and easy to define, yes, but they're also slow/memory-inefficient/what-have-you
14:16:22 <byorgey> roconnor_: indeed
14:17:40 <Veinor> i love the language, but... egh. it feels too intellectual.
14:17:41 <JoeyA> Veinor: I haven't run into that problem myself yet.  If you're feeling adventurous, you could look into rewrite rules and fusion.
14:17:51 <JoeyA> (for better performance)
14:18:22 <Veinor> well like
14:18:28 <JoeyA> I find type signatures in Haskell easier to read than in other languages, but code harder to read.
14:19:01 <Veinor> i'm writing what should be a very simple program and it's taking 100M of memory because String is so inefficient, and i can't get ByteString to take less than 300M
14:19:05 <JoeyA> Veinor: Also, are you aware of strictness annotations?
14:19:16 <rwbarton> for example if I take the free monoid on a set, then forget the monoid structure, then take the free monoid on *that*, I get a different thing than if I just took the free monoid once
14:19:24 <JoeyA> Veinor: Are you doing a lot of bytestring concatenation?
14:19:33 <benmachine> Veinor: are you profiling the shit out of everything?
14:19:41 <Veinor> yeah; i have lazy bytestrings and i need strict ones
14:20:41 <bos> Veinor: what's your code do?
14:20:48 * bos knows a little bit about this stuff
14:20:48 <JoeyA> I'm wondering if you are ending up with a lot of unforced thunks which are just bytestring concatenations.
14:21:06 <Veinor> pulls down about 500KB of JSON and extracts data from it
14:21:12 <JoeyA> Or maybe a lot of small lazy bytestring chunks?  (I don't know if ByteString.Lazy optimizes that or not)
14:21:19 <JoeyA> 500KB only?
14:21:25 <Veinor> either way it really annoys me that i have to microoptimize my string handling
14:21:33 <Veinor> JoeyA: yeah.
14:21:37 <JoeyA> Only one time?
14:21:46 <Veinor> only one time.
14:21:51 <JoeyA> What JSON library are you using?
14:21:56 <Veinor> AttoJSON
14:21:58 <JoeyA> okay
14:22:41 <JoeyA> It uses strict ByteStrings in its constructors, so that's not the problem.
14:23:01 <JoeyA> "either way it really annoys me that i have to microoptimize my string handling"  In other languages, you often have to use string builders.
14:23:31 <JoeyA> If I'm not mistaken, PHP and maybe JavaScript optimize string building automatically.
14:24:05 <Veinor> true
14:24:30 <Veinor> but like... i dunno. i just keep running into annoying issues every time i try to write something in haskell, whereas when i write in python it just works
14:25:30 <eigenweave> any good papers on the relation between grammars and type systems?
14:26:15 <Veinor> though that might be in part because the general set of things that i write is more suited to python than haskell
14:26:20 <monochrom> do you write haskell by direct translation of what you would write in python? that will easily yield inefficient programs
14:26:35 <JoeyA> Veinor: from what I can tell, lazy ByteString concatenation is not optimized.  I could be wrong.
14:26:42 <JoeyA> (err, lazy ByteString append)
14:26:53 <JoeyA> You just get a bunch of small chunks, from what I can tell.
14:27:12 <Veinor> well, like
14:27:13 <monochrom> the other direction is also true. if I write python by direct translation of what I would write in haskell, that will easily yield inefficient programs
14:27:18 <JoeyA> but I'm not dons, so I wouldn't know.
14:27:32 <Veinor> Network.HTTP gives me a String. that's no good. http-enumerator gives me a lazy bytestring, which i need to convert into a strict one.
14:28:12 <JoeyA> Veinor: If you have to concatenate a lot of ByteStrings, you could make a list out of them, then use concat :: [ByteString] -> ByteString
14:28:32 <Veinor> i don't have to concatenate a lot of bytestrings, though
14:28:43 <JoeyA> oh
14:28:46 <Veinor> all i need to do is turn a lazy bytestring into a strict one
14:30:07 <monochrom> Network.HTTP can give a lazy bytestring. it can also give a strict bytestring.
14:30:16 <benmachine> I'm sure Network.HTTP has a bytestring interface
14:30:41 <Veinor> monochrom: really? how?
14:30:42 <monochrom> otoh if you like the look&feel of http-enumerator that's cool too
14:30:57 <edwardk_> i just wish i could extend the primitive types that HTTP knows how to write to =(
14:31:11 <edwardk_> i would really like to be able to write to a rope for instance
14:31:37 <Veinor> oh, huh, it does
14:32:02 <monochrom> then again it doesn't really change the inefficiency of your program
14:32:14 <edwardk_> mainly because it constantly appends to the resulting lazy bytestring which is pretty awful
14:32:52 <monochrom> it only changes how many lines of code you need to write and how many libraries you have to import to get the same inefficiency
14:33:37 <edwardk_> mind you its O(n^2) in the number of chunks, so it only gets expensive if you toss a lot of chunks, but that is still disturbingly non-linear
14:34:25 <monochrom> so yes basically I am unconvinced that converting the received http response wholesale to strict bytestring helps, and I am unconvinced that the inefficiency is not just due to an inefficient algorithm
14:34:41 <Veinor> hm.
14:35:13 <monochrom> as in, the algorithm is inefficient even theoretically, so never mind in practice
14:38:24 <ocharles_> Hrm, I was playing around with a 1 type class CoreEntity, which has getByGid and some other functions; and another type class (DBCoreEntity) which can be used to create an instance of CoreEntity: instance DBCoreEntity a => CoreEntity a, but this requires UndecidableInstances, which seems to be bad
14:38:46 <ocharles_> I wonder if I should just merge those 2 type classes
14:39:30 <ocharles_> the DBCoreEntity type class implements all the CoreEntity functions with SQL string interpolation type stuff based on a "config" function that DBCoreEntity requires (table name, column names)
14:40:00 * hackagebot hbro 0.6.8 - A minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-0.6.8 (koral)
14:40:05 <hpaste_> veinor pasted “json” at http://hpaste.org/51546
14:40:51 <hpaste_> veinor pasted “json” at http://hpaste.org/51547
14:41:10 <Veinor> that latter one is the thing that's using up all the RAM
14:41:25 <monochrom> and the former one?
14:41:29 <Veinor> a typo
14:42:24 <Veinor> (i'm using overloadedstrings so I don't have pack everywhere)
14:45:47 <Veinor> the json files it's dealing with are about 500KB in size
14:48:39 <bos> Veinor: don't use attojson
14:48:54 <bos> Veinor: also, big json files are *always* expensive to parse
14:49:00 <Veinor> then what should i use?
14:49:18 <bos> aeson
14:49:43 <benmachine> bos: completely impartial in this debate? :)
14:50:02 <bos> benmachine: yes. i only recommend the very very finest code.
14:50:19 <Veinor> haha
14:50:22 <Veinor> ok, i'll try aeson
14:50:40 <bos> Veinor: it will help *some* with your problem, because it represents text as Text, not String
14:50:53 <bos> Veinor: but beware: big json files are most definitely expensive
14:50:57 <bos> no matter what library you use
14:51:09 <Veinor> noted
14:51:36 <monochrom> why are big json files expensive to parse?
14:51:47 <Veinor> the other question is: in the Main.hs that i'm using, i grab a file, parse it, print out the length of the result of titlesOfPosts, then continue on to the next URL
14:52:02 <Veinor> why doesn't parsing n such URLs happen in constant memory?
14:52:17 <bos> monochrom: lots of deeply nested structure, lots of bits that are individually expensive (parsing a Double is *slow*)
14:52:49 <monochrom> alright, but then it is sensitive to the contents and intended types of the file
14:53:02 <bos> Veinor: can't tell without seeing your main
14:53:09 <bos> monochrom: yes
14:53:40 <monochrom> wait, what does a list of three integers look like in json? make up extra types and records if you like
14:53:48 <hpaste_> Veinor pasted “JSON main” at http://hpaste.org/51548
14:53:51 <ion> There are no integers in JavaScript.
14:53:56 <Veinor> ^^^^^
14:54:01 <Veinor> that thing
14:54:13 <Maxdamantus> There are integers in JavaScript.
14:54:13 <monochrom> oh, only doubles? then a list of three doubles
14:54:22 <Maxdamantus> They're just not represented using an integer type.
14:54:30 <bos> Veinor: you're constructing the entire list before you start printing it
14:54:32 <monochrom> or three booleans. or three records of your choice
14:54:39 <bos> Veinor: so it can't possibly run in constant memory
14:54:44 <Veinor> bos: I mean
14:54:49 <Veinor> if I remove the second url-parsing bit
14:54:52 <Veinor> it runs in half the memory
14:55:24 <Veinor> i assume if i were to have it parse 3 urls it'd run in 3 times the memory
14:55:26 <bos> Veinor: ah. could just be that the garbage collector isn't running before your program exits.
14:55:54 <Veinor> ah
14:56:15 <JoeyA> JSON's syntax doesn't talk about the representation of integers.  In theory, 1267650600228229401496703205376 is a valid JSON number.
14:56:28 <JoeyA> However, JavaScript uses IEEE doubles, so in practice that's how JSON numbers are represented (I think).
14:56:35 <bos> monochrom: a list of 3 numbers would be "[1,2,3]"
14:56:47 <bos> JoeyA: actually, no.
14:57:02 <JoeyA> bos: Hmm?
14:57:22 <bos> JoeyA: to handle numbers properly, you need a type that can handle either arbitrarily large integers or Doubles
14:57:37 <Maxdamantus> I think that's still considered a valid JSON number.
14:57:48 <Maxdamantus> It'll just get rounded somewhere.
14:57:53 <Maxdamantus> (in practice)
14:57:54 <monochrom> so if I have a 500KB json file, but it's just a long list of pretty short records, that shouldn't be expensive? (modulo "I need to see the whole thing so I know it's a syntax error or not")
14:57:56 <bos> JoeyA: quite a few sources of JSON data will pump out very big integers and expect precision to be preserved by consumers
14:58:03 <Maxdamantus> (at least in JS, using JSON.parse)
14:58:40 <JoeyA> Interesting
14:58:46 <bos> e.g. the twitter API uses big integers that get truncated if represented as Double
14:59:02 <bos> monochrom: it's less expensive, at least
14:59:34 <bos> monochrom: there are some JSON libraries that lazily hand out a stream of events, instead of giving back an entire parse tree
14:59:56 <bos> those obviously have much much lower memory requirements, but they're also much much more awkward to use
14:59:57 * Maxdamantus wouldn't call it a parse tree.
15:00:25 <Maxdamantus> Handling is lazily sounds more like a parse tree.
15:00:37 <monochrom> ok, but OTOH even if I have a deep tree structure, if the file is 500KB then that's a hard limit on my tree depth, so it can't be expensive either? :)
15:00:38 <bos> Maxdamantus: uh, no.
15:01:07 <bos> monochrom: well, it takes a lot of memory.
15:01:08 <hpc> monochrom: technically, the size limit on the file means you can evaluate it in O(1) time :P
15:02:21 <Veinor> basically i just feel like a lot of the time, the things i like doing are a better fit for python than haskell
15:02:24 <ion> O(1) for large values of 1
15:03:55 <monochrom> someone should conceive a json iteratee
15:03:58 <Veinor> like, i can write programs to do the stuff i want without too much difficulty. but invariably making them time/space efficient winds up being a massive effort
15:04:07 <Veinor> and this very well might be partly me writing python in haskell
15:04:38 <bos> Veinor: there's undoubtedly a learning curve.
15:04:59 <bos> Veinor: and in general, "scripting" style tasks are (in my experience) easier to write in python than haskell.
15:05:07 <Veinor> yeah.
15:05:15 <Veinor> and 'scripting' tasks tends to be what I do
15:05:24 <bos> but e.g. aeson is about as fast as the python json package
15:05:26 <monochrom> yes, consider "map". the way to implement it efficiently in python and the way to implement it efficient in haskell are opposites
15:06:16 <monochrom> though at the end they share the same slogan, so it can be paradoxical
15:07:03 <monochrom> for python: you should use a buffer and keep adding things at the end, so that "you don't involve a stack-intensive recursion"
15:08:19 <monochrom> for haskell: you should immediately return the beginning item and its consing to the rest (i.e., f x : map f xs), so that "you don't involve a stack-intensive recursion"
15:08:40 <ion> edwardk’s dyck language skeleton stuff might be useful for JSON (if i’ve understood the idea correctly). Especially if you want to get some specific keys and stop parsing unnecessary parts as early as possible.
15:08:44 <monochrom> see? same slogan, "don't involve a stack-intensive recursion", completely opposite consequences
15:20:05 <monadic> Is there any way to merge GHC's big contents of modules and the one I generated using packages from /usr/share/doc with a script someone gave me? I tried modifying the ls command but it didn't work. I can post the script if needed.
15:34:22 <JoeyA> Could Data.DList use O(n) stack space in some circumstances?
15:34:54 <slack1256> JoeyA: which function?
15:35:01 <slack1256> Data.List is a module
15:35:07 <JoeyA> Data.DList
15:35:10 <JoeyA> http://hackage.haskell.org/packages/archive/dlist/0.3/doc/html/Data-DList.html
15:35:28 <slack1256> oh my bad.
15:35:37 <JoeyA> Namely, if I do a lot of snoc calls, could it use O(n) stack space?
15:40:40 <byorgey> JoeyA: yes, it could
15:42:12 <byorgey> actually, I think that is more likely if you do a lot of cons calls
15:42:34 <byorgey> because then the DList will end up looking like a right-nested chain of function compositions
15:43:11 <byorgey> so in order to find the first function to actually apply to the input list at the end it has to traverse the whole chain, pushing thunks onto the stack along the way
15:43:51 <byorgey> this is just speculation though, there may be some optimization that takes place
15:44:19 <JoeyA> thanks
15:44:48 <parcs> > [0..pi]
15:44:48 <lambdabot>   [0.0,1.0,2.0,3.0]
15:45:26 <slack1256> > [0.0..pi]
15:45:27 <lambdabot>   [0.0,1.0,2.0,3.0]
15:47:33 <Rotaerk> >[(pi - 3.0)..pi]
15:47:36 <Rotaerk> > [(pi - 3.0)..pi]
15:47:37 <lambdabot>   [0.14159265358979312,1.1415926535897931,2.141592653589793,3.141592653589793]
15:48:10 <AfC> bos: just reading the documentation for the aeson library you cited a few minutes ago...
15:48:14 <AfC> bos: one of the things I find challenging as a newcomer to Haskell is that almost all of the documentation is in reference style;
15:48:22 <AfC> bos: it often seems difficult to figure out what the entry point of a given library is.
15:48:25 <byorgey> > [2.0, 2.2 .. pi]
15:48:25 <lambdabot>   [2.0,2.2,2.4000000000000004,2.6000000000000005,2.8000000000000007,3.0000000...
15:48:38 <byorgey> > [2.8, 3.0 .. pi]
15:48:39 <lambdabot>   [2.8,3.0,3.2]
15:48:50 <bos> AfC: funny thing you mention that
15:48:57 <bos> AfC: i'm actively writing better docs today
15:48:57 <AfC> So, I'm guessing that http://hackage.haskell.org/packages/archive/aeson/0.3.2.12/doc/html/Data-Aeson.html is where I'm supposed to start, but...
15:49:31 <AfC> [and having read your book recently, I can imagine where that code comes from and how to use it, but...]
15:52:08 <AfC> bos: the snipptet at the top of http://hackage.haskell.org/packages/archive/HTTP/4000.1.2/doc/html/Network-HTTP.html wasn't bad (again just from the perspective of an somewhat experienced programer flailing about in a new language) which I guessed / navigated to.
15:56:50 <Cale> AfC: On the other hand, with Aeson, there's not a lot of possibilities for where to start :)
15:57:40 <Cale> In particular, parseJSON and toJSON seem pretty conspicuous :)
15:59:01 <monochrom> monadic: when you run a "cabal install blah" with documentation enabled, it ends with re-generating a huge content page with links to all haddocks it can get its hands on. it's in ~/.cabal/share/doc/index.html
15:59:18 * JoeyA wonders if the maintainer of Aeson got my email with a patch adding a decode frontend.
16:00:00 <monadic> monochrom: Don't have that file, I'm forced to due it by hand (I'm using distributions packaging manager)
16:00:17 <Cale> So parseJSON :: (FromJSON a) => Value -> Parser a takes a Value, which we see is a data structure representing some JSON stuff, and produces a Parser for values of type a, whatever type of value we want to parse.
16:00:19 <monochrom> of course, it doesn't re-generate docs that it didn't generate previously (because you did not ask for it), but the huge content page always includes docs that come with GHC because cabal knows about it
16:00:24 <dobblego> JoeyA: you just missed bos
16:00:27 <JoeyA> Indeed
16:01:01 <monochrom> monadic: just install a package with documentation enabled now, and it will suddenly appear
16:01:08 <monadic> I almost have it working but the links it generates aren't necessarily correct
16:01:17 <Cale> Oh, weird, Value implements IsString, but not Read
16:02:48 <monochrom> if you swear by distribution package manager and never "cabal install", you're at the mercy of distribution package manager, sure
16:02:59 <benmachine> Cale: if you want to make Values I assume you use 'json'
16:03:12 <benmachine> :: Parser Value
16:04:00 <Cale> yeah
16:04:39 <Cale> AfC: The way to find your way around new libraries is by focusing on the types
16:04:44 <monadic> monochrom: Well its because I don't have cabal-install. Running 7.2 and can't get cabal-install to work
16:04:58 <monadic> Don't care enough to try to fool with it until the right packages come out
16:05:00 <monochrom> oh, see the topic, 1st item covers that
16:05:04 <Cale> Most libraries are really straightforward if you're paying attention to what the types of things are.
16:05:27 <Cale> There'll be only so many ways you can get a value of the type you want.
16:05:50 <monochrom> but there is a distribution package manager that already does 7.2?!
16:06:29 <monochrom> that's almost like Red Hat doing egcs back then...
16:07:14 <monadic> Gentoo Haskell Overlay.
16:07:50 * monochrom wonders if anyone still remembers Red Hat's egcs incident back then
16:08:09 <monochrom> s/anyone/anyone else/ # of course I remember
16:08:10 <monadic> Nope.
16:09:10 <monochrom> one version of Red Hat had the fiasco of choosing a pre-release version of gcc or egcs and breaking certain important things
16:09:34 <monochrom> now, 7.2 is not exactly pre-release, but close
16:09:47 <monadic> So with my current script I have the problem that anything from the ghc-packages uses ghc-7.2.1/bleh instead of packagename-version/bleh.,
16:10:30 <monochrom> the official wording is "it's a preview of all the great things in 7.4. 7.4 will happen right after ICFP" which is like 0.5-1 month away
16:11:05 <monochrom> the way I put it is "7.2 when released is at once both too new and too old already" :)
16:11:05 <monadic> I'm working on making GHC.Generics versions of several packages (namely Binary)
16:11:13 <monadic> Which is why I need 7.2
16:11:54 <monadic> oh hey figured out the error. Neat.
16:12:57 <monochrom> you can't avoid needing two cases, one for packages from GHC, one for all other packages though they be global
16:13:20 <monadic> monochrom: Yeah I split most of it into cases I just missed one part
16:13:51 <monadic> Yay it works.
16:15:27 <monadic> Yeah 7.2 really isn't -in- the package manager, its hardmasked and everything so if you don't really want it you won
16:15:30 <monadic> won't get it
16:22:58 <mamalujo> monochrom: wait, what, 7.4 is a month or so away only? why? isn't it usually one major release per year?
16:23:18 <dylukes> Ahem.
16:23:25 <dylukes> What happens if Kirby swallow a Klein bottle?
16:23:28 <monadic> 7.4 is just that much cooler than 7.0 :)
16:24:33 <mamalujo> I saw in a reply to some feature request ticket that any code a dev might wish to end up in 7.4 must be in the repo by end of october. thought that was strange
16:25:25 <dreixel> monadic: great to hear you are making those generic instances
16:25:45 <dreixel> btw, can't you just use any cabal install with 7.2 using the --with-compiler flag?
16:26:05 <monadic> dreixel: I have to compile cabal-install first
16:26:40 <dreixel> monadic: but that doesn't have to be with 7.2, right?
16:27:03 <monadic> dreixel: Well I don't have another compiler on my system
16:27:18 <dreixel> oh ok
16:27:19 <monadic> using a binary would be an option but I don't really use cabal-install anyways.
16:30:10 <monadic> Intesting, is there a reason the non-strictable integral data types (aka Integer) don't have Generic instances?
16:30:29 <monadic> but Int, etc do
16:30:42 <monadic> Not that it would be that useful, but Int doesn't seem useful either...
16:31:44 <dreixel> monadic: no, there is no good reason. There is no Generic Integer instance? that's actually bad
16:32:18 <Saizan> mamalujo: 7.2 was meant to be shortlived from the start
16:32:21 <monadic> dreixel: By the looks of it, no...
16:32:23 <dreixel> .. or maybe it's not that bad, because those instances are really not that useful
16:32:57 <monadic> dreixel: Also seems odd that I think I have to have access to the typeclass definition itself to be able to add the generic defaulting support! Adding a package like binary-generic like I planned to do will not work. :(
16:33:53 <mamalujo> Saizan: right, thx. just went to read the announcement on haskell@haskell.org . Seems like an odd experiment though
16:36:53 <dreixel> monadic: I do not see why. can you explain that in more detail?
16:37:28 <monadic> dreixel: Adding the line of code that tells GHC how to default derive based on Generics [special syntax, not the same as default implementations for type class functions] has to be in the class definition
16:37:50 <monadic> Hence I can't just make an extra package to add it. This is a pain because obviously packages like binary won't want to be dependent on GHC-7.2...
16:39:44 <monadic> dreixel: Essentially it looks like GHC.Generics won't be applicable until 7.4 becomes mainstream
16:40:55 <slack1256> about 7.4 ghc on arm says they merged some good patches to ghc-head, so this means it will be present in 7.4
16:41:11 <slack1256> because the rasberri-pi !
16:41:29 <DukeDave> Hey gang, in my project I don't want modified times updated unless the file is actually modified; so I replaced instances of 'writeFile' with this:
16:41:29 <DukeDave> writeFileIfRequired f str = readFile f >>= \str' -> when (str /= str') (writeFile f str)
16:41:29 <DukeDave> However I'm seeing this: openFile: resource busy (file is locked)
16:42:38 <DukeDave> Do I just need to sequence if differently?
16:44:05 <Jafet> DukeDave: readFile is lazy
16:44:23 <DukeDave> Jafet: So it won't close the file?
16:44:32 <DukeDave> Once the equality check is done?
16:44:33 <Jafet> So str' is not fully read (as it differs from str) and so the file remains open.
16:44:44 <DukeDave> Ah I see
16:44:44 <Jafet> Remember that (/=) is also lazy.
16:44:58 <DukeDave> I guess I'll just rewrite with System.IO calls
16:45:11 <Jafet> A cheap fix might be to pseq (length str').
16:45:26 <Jafet> Well, the problem is that reads the entire file each time.
16:46:51 <DukeDave> Jafet: Thanks
16:51:06 <inetic> hi, it seems that the "L.hPut handle $ encode (fromIntegral num :: Word32)" writes the num in big endian, can I somehow change it to use little endian?
16:52:33 <parcs> is that the binary package?
16:53:08 <parcs> try replacing encode (...) with runPut (putWord32le num)
16:53:58 <Jafet> fromIntegral in a serializer?
16:54:00 <dreixel> monadic: oh, yes, I'm afraid that is the case
16:54:00 * Jafet sniffs
16:54:15 <inetic> parcs, yes, it's from Daata.Binary
16:54:27 <ESchultz-Rodrigu> Tired of niggers?
16:54:54 <parcs> inetic: okay, then my suggestion applies
16:55:11 <inetic> parcs, will try
16:56:44 <parcs> you might have to import Data.Binary.Put
16:58:46 <inetic> parcs, it works!! :-) many thanks, I was trying to avoid the Put monad for a while, never realized I can use it with hPut :-)
17:04:01 <DukeDave> Hmm, can anyone spot the error in this logic:
17:04:01 <DukeDave> writeFileIfRequired f str = withFile f ReadMode (\handle -> hGetContents handle >>= \str' -> return (str /= str') ) >>= \modfied -> when modfied (writeFile f str)
17:04:34 <Cale> Y U NO DO NOTATION?
17:04:36 <DukeDave> (Other than the misspelling!)
17:04:46 <monochrom> haha Cale
17:05:15 <DukeDave> Cale: I've run out of sugar :P
17:05:24 <monochrom> withFile closes the handle. afterwards, you start reading
17:05:31 <Cale> @redo writeFileIfRequired f str = withFile f ReadMode (\handle -> hGetContents handle >>= \str' -> return (str /= str') ) >>= \modfied -> when modfied (writeFile f str)
17:05:31 <lambdabot> Maybe you meant: do read todo undo
17:05:36 <Cale> @do writeFileIfRequired f str = withFile f ReadMode (\handle -> hGetContents handle >>= \str' -> return (str /= str') ) >>= \modfied -> when modfied (writeFile f str)
17:05:36 <lambdabot> writeFileIfRequired f str = do { modfied <- withFile f ReadMode (\ handle -> do { str' <- hGetContents handle; return (str /= str')}); when modfied (writeFile f str)}
17:06:02 <Jafet> It's longer!
17:06:07 <monochrom> yes yes I know that is not the order of your syntax, but the order of your syntax does not matter. hGetContents postpones reading; return blah doesn't help either
17:06:16 <Cale> It's not important that it's longer :P
17:06:43 <Cale> If you apply hGetContents to a handle, you must not close that handle.
17:07:17 <DukeDave> If you didn't spot it, this is in relation to my previous question:
17:07:17 <DukeDave> Hey gang, in my project I don't want modified times updated unless the file is actually modified; so I replaced instances of 'writeFile' with this:
17:07:17 <DukeDave> writeFileIfRequired f str = readFile f >>= \str' -> when (str /= str') (writeFile f str)
17:07:17 <DukeDave> However I'm seeing this: openFile: resource busy (file is locked)
17:07:25 <Cale> Also, try not to write directly to a file you're reading from.
17:07:45 <Jafet> writeAtomicallySomehow
17:07:59 <monochrom> readFile also postpones reading
17:08:01 <Cale> It's really not a good policy to do that. You usually should write to another file, and then move that file over the original once you're finished writing it.
17:08:03 <DukeDave> Cale: I'd rather hoped that once I've established the equality I can close the file
17:08:21 <DukeDave> Cale: For why?
17:08:34 <Jafet> Because moving is usually atomic; writing is usually not.
17:09:05 <monochrom> "return (str /= str') does not evalute str/=str' immediately
17:09:17 <edwardk> executable meme of the day:  (\/)(o,,o)(\/) "Why not Zoidberg?"
17:09:17 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
17:09:34 <monochrom> but perhaps you do not see me
17:09:34 <Cale> edwardk: lol
17:09:41 <DukeDave> monochrom: But it has to before that 'return' can be evaluated, no?
17:09:48 <Jafet> @index (\/)
17:09:49 <lambdabot> bzzt
17:09:55 <Cale> DukeDave: no, it just returns that expression unevaluated
17:10:08 <edwardk> jafet: you of course need to put the right identifiers in scope ;)
17:10:08 <Cale> and only evaluates it when it needs to
17:10:24 <monochrom> try this some day: do { return (1/0); putStrLn "hello" }  see if you get any runtime error
17:10:33 <DukeDave> Cale: I kind of thought that's why we use (>>=) though, to evaluate things in order
17:10:46 <Cale> >>= doesn't control order of evaluation at all
17:10:53 <Cale> it only controls order of execution
17:10:55 <Jafet> Or 1 `div` 0
17:11:10 <edwardk> monochrom: sure you might.. if there is something wrong with stdout ;)
17:11:10 <monochrom> no, (>>=) only orders I/O, and even then, readFile and hGetContents etc conspire to circumvent that
17:11:17 <DukeDave> That makes sense, because you aren't evaluating (1/0)
17:12:05 <DukeDave> So what should I do?
17:12:19 <DukeDave> Is creating temporary files really the best we can come up with?
17:12:26 <edwardk> DukeDave: you need to be careful because a number of monads have illegal behavior in that regard. the strict identity monad used by parallel.strategies and oleg's iteratees for instance
17:12:32 <monochrom> I guess actually, with 99% probability, "return $! (str /= str')" will work
17:12:50 <Jafet> monochrom: won't close the file
17:12:57 <monochrom> withFile closes the file
17:13:04 <Jafet> Okay.
17:13:06 <parcs> > runIdentity $ do return $! (0/0); return 1
17:13:07 <lambdabot>   1
17:13:40 <monochrom> it's actually fine to combine hGetContents and close, if you know what's the actual order. (99% of people don't.)
17:13:41 <Jafet> > runIdentity $ do return $! (div 0 0); return 1
17:13:42 <lambdabot>   1
17:14:00 <edwardk> btw- infixl 4 <$!>; (<$!>) :: Monad m => (a -> b) -> m a -> m b; f <$!> m = do a <- m; return $! f a -- is a very useful combinator for this sort of thing
17:14:12 <Jafet> I don't think even IO is strict, you need evaluate
17:14:43 <DukeDave> monochrom: I'm afraid using (!) didn't work :(
17:14:51 <Jafet> Yup, it isn't
17:15:19 <monochrom> but $! is not !
17:16:05 <DukeDave> Okay, what you pasted didn't work..
17:17:01 <DukeDave> I guess ($!) is just (!) with ($)s precedence?
17:17:10 <DukeDave> A fun sentence :)
17:17:16 <monochrom> no
17:17:51 <monochrom> @type (!)
17:17:52 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
17:17:55 <monochrom> not even related
17:18:40 <DukeDave> Oh, I thought the ! was to force evaluation, a bang pattern?
17:20:06 <Jafet> It is not an operator, so you cannot call it (!).
17:20:24 <DukeDave> Jafet: Aha, okay
17:21:07 <DukeDave> Is there any way I can do this then? :|
17:21:47 <Jafet> :t withFile
17:21:48 <lambdabot> Not in scope: `withFile'
17:22:23 <Jafet> Oh, withFile is a fancy way to not type hClose.
17:22:35 <monochrom> import Control.Exception(evaluate) and use "evaluate (str /= str')"
17:27:45 <DukeDave> monochrom: Hmm, suspiciously that didn't work either :O
17:28:03 <DukeDave> Here's the exact line I've got:
17:28:03 <DukeDave> writeFileIfRequired f str = withFile f ReadMode (\handle -> hGetContents handle >>= \str' -> evaluate (str /= str') ) >>= \modfied -> putStrLn ("WRITE " ++ f) >> when modfied (putStrLn "WRITTEN" >> writeFile f str)
17:28:11 <DukeDave> Thanks by the way :)
17:28:52 <monochrom> or it works but you haven't detected it
17:29:40 <DukeDave> It seems like a simple enough function :(
17:31:46 <DukeDave> Ooh, and it works
17:31:49 <DukeDave> In a simple case
17:36:39 <deliium> @help
17:36:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:37:07 <deliium> @type map
17:37:08 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:47:17 <parcs> :t (:%)
17:47:18 <lambdabot> Not in scope: data constructor `:%'
17:47:19 * DukeDave is upset this is so hard
17:47:48 <DukeDave> I've moved to the 'create a temporary file' approach, but now I can't find anything to ask if two files are the same :|
17:48:02 <aavogt> @src Rational
17:48:02 <lambdabot> type Rational = Ratio Integer
17:48:26 <parcs> @src Ratio
17:48:26 <lambdabot> data (Integral a) => Ratio a = !a :% !a
17:48:35 <parcs> data type contexts!!!
17:48:40 <parcs> run!!!!
17:50:29 <aavogt> well :% isn't exported so in the worst case it's just a performance issue (considering that % reduces the fraction)
17:51:17 <aavogt> fand something is off if you care about performance with Rational
17:51:37 <deliium> @run
17:51:38 <lambdabot>   not an expression: `'
17:52:05 <deliium> @run map (+1) [1..10]
17:52:06 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
17:52:29 <aavogt> > 1 + [1..10]
17:52:30 <lambdabot>   No instance for (GHC.Num.Num [t])
17:52:30 <lambdabot>    arising from a use of `e_11110' at <in...
17:53:19 <matthiasgorgens> Is there a combinator like foldM that also allows to break the recursion upon some condition other than the end of the list?
17:54:01 <parcs> what would be its type?
17:54:15 <matthiasgorgens> something like a mix between unfold und fold.
17:54:32 <matthiasgorgens> I'll come up with the type.
17:54:37 <aavogt> you can probably do such a thing with the existing foldM and ContT
17:54:46 <parcs> yeah
17:54:53 <parcs> was going to suggest that
17:54:55 <parcs> damn you
17:55:30 <matthiasgorgens> something like un_foldM :: Monad m => (a -> b -> (m a, Bool)) -> a -> [b] -> m a
17:55:55 <parcs> :t foldM
17:55:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:56:10 <matthiasgorgens> it's nothing important, I'm just trying to remove an explicit recursion.
17:56:50 <matthiasgorgens> The Monad in question is build up-on the IO monad.
17:56:56 <matthiasgorgens> (but it's not io itself.)
17:57:10 <matthiasgorgens> ContT seems like a good joice.
17:57:39 <monochrom> you could also throw and catch an exception XD
17:58:01 <matthiasgorgens> that would be ugly.
17:58:19 <matthiasgorgens> we don't do ugly here. ;o)
17:58:19 <monochrom> I find it beautiful
17:58:27 <matthiasgorgens> ok,
17:58:34 <matthiasgorgens> ok, we don't do beautiful here.
17:59:10 <matthiasgorgens> a monadic if would be useful.
17:59:16 <matthiasgorgens> I guess I'll have to write it myself.
17:59:21 <aavogt> :t \f p x0 xs -> callCC $ \k -> foldM (\a b -> if p a b then k a else f a b) x0 xs
17:59:22 <lambdabot> forall (m :: * -> *) b b1. (MonadCont m) => (b -> b1 -> m b) -> (b -> b1 -> Bool) -> b -> [b1] -> m b
17:59:36 <matthiasgorgens> ifM :: m Bool -> m a -> m a -> m a
17:59:52 <monochrom> I think you're just saying you don't do exeptions. but see my http://www.vex.net/~trebla/haskell/exception.xhtml
18:01:31 <matthiasgorgens> monochrom, you are trying to lead me from the straight and narrow path.
18:01:56 <monochrom> to freedom
18:02:16 <monochrom> to the freedom of the whole design space
18:09:00 <byorgey> ifM = liftM3 if'
18:09:12 <byorgey> where if' b x y = if b then x else y
18:10:50 <dobblego> ifM = \t f -> liftM (\p -> if p then t else f)
18:13:24 <DukeDave> Hahahaa, monochrom: So the reason that little snippet wasn't working in my application, even though the test case worked: My application writes out a "file generated time" line, which unsurprisingly changes every time the code runs. Not impressed.
18:13:27 <Saizan> byorgey: that's an if that runs both branches and then discards one result :)
18:13:43 <byorgey> Saizan: ah, hehe, whoops, you're right =)
18:14:55 <monochrom> you can go back to check that "return $! (str /= str')" is sufficient
18:27:27 <cwl> cabal install yesod failed
18:28:06 <hpaste_> cwl pasted “cabal install yesod failed” at http://hpaste.org/51552
18:30:22 <byorgey> cwl: what error do you get if you run 'cabal install syb-0.3.3' ?
18:31:14 <hpaste_> cwl pasted “cabal install syb error” at http://hpaste.org/51553
18:31:35 <cwl> byorgey:
18:34:34 <byorgey> cwl: what version of ghc do you have?
18:34:57 <cwl> byorgey: The Glorious Glasgow Haskell Compilation System, version 7.0.3
18:35:02 * hackagebot swish 0.6.1.2 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.6.1.2 (DouglasBurke)
18:35:06 <cwl> byorgey: ArchLinux
18:36:04 <byorgey> cwl: what is the output of  ghc-pkg list Cabal  ?
18:36:42 <cwl> byorgey: WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
18:36:45 <cwl> /usr/lib/ghc-7.0.3/package.conf.d
18:36:47 <cwl> /home/admin/.ghc/i386-linux-7.0.3/package.conf.d
18:37:36 <byorgey> that's not good, ghc 7.0.3 is supposed to come with Cabal-1.10.1.0
18:37:51 <byorgey> cwl: and what do you get if you run  'ghc-pkg check' ?
18:38:11 <cwl> byorgey: There are problems in package json-0.4.4: dependency "syb-0.3-0b301293b4d755f469c06cc5701b6102" doesn't exist
18:38:14 <cwl> There are problems in package ConfigFile-1.0.6: dependency "MissingH-1.1.1.0-91e850e5a6463e89f7e7847a6a4b7e0b" doesn't exist
18:38:17 <cwl> There are problems in package haskell98-1.1.0.1: dependency "directory-1.1.0.0-1d3891a7968d4bd1071691d7ac96a1da" doesn't exist
18:38:20 <cwl> The following packages are broken, either because they have a problem
18:38:23 <cwl> listed above, or because they depend on a broken package.
18:38:25 <cwl> json-0.4.4
18:38:28 <cwl> ConfigFile-1.0.6
18:38:30 <cwl> haskell98-1.1.0.1
18:38:54 <cwl> byorgey: btw, how to uninstall cabal package
18:39:24 <byorgey> cwl: you can do   'ghc-pkg unregister foo' to unregister package foo
18:39:48 <byorgey> that leaves the files in place but makes ghc forget about it.
18:39:48 <cwl> byorgey: will it be removed from .cabal
18:39:51 <byorgey> no
18:40:00 <byorgey> you must do that manually if that's what you want to do
18:40:07 <cwl> i c
18:40:25 <byorgey> cwl: well, it looks like your installation is hosed.
18:40:55 <cwl> byorgey: how to fix it
18:41:21 <byorgey> I would recommand  rm -rf ~/.ghc; pacman -R ghc; pacman -S haskell-platform
18:41:45 <cwl> byorgey: ok
18:41:51 <cwl> byorgey: what about .cabal?
18:42:06 <cwl> why haskell-platform not ghc
18:42:47 <byorgey> cwl: .cabal doesn't matter, you can leave it, unless you ever ran cabal with sudo in which case the permissions could be screwed up
18:43:17 <cwl> byorgey: ok
18:43:28 <byorgey> cwl: haskell-platform includes ghc and also a bunch of other standard tools (such as cabal) and standard libraries
18:43:43 <byorgey> if you are going to be installing yesod then you will certainly want all of that to start.
18:44:40 <mm_freak_> does anyone know of a pure rendering library, which doesn't force me into any framework?  i.e. not gloss
18:45:16 <cwl> byorgey: checking dependencies...
18:45:16 <cwl> error: failed to prepare transaction (could not satisfy dependencies)
18:45:16 <cwl> :: haskell-mtl: requires ghc=7.0.3-2
18:45:16 <cwl> :: haskell-parsec: requires ghc=7.0.3-2
18:45:16 <cwl> :: haskell-quickcheck: requires ghc=7.0.3-2
18:45:18 <cwl> :: haskell-random-shuffle: requires ghc=7.0.3-2
18:45:21 <cwl> :: haskell-random-shuffle: requires haskell-random=1.0.0.3
18:45:23 <cwl> :: haskell-transformers: requires ghc=7.0.3-2
18:45:25 <mm_freak_> pure not in the sense of referentially transparent, but in the sense of /only/ depending on opengl, not on SDL or GLUT or anything
18:45:26 <cwl> should I remove them also
18:46:28 <byorgey> cwl: sure, remove those too.  I don't remember whether there is a way to make pacman -R recursive, or whether you just have to manually uninstall each of those
18:47:15 <byorgey> cwl: by the way, try not to paste more than a couple lines in the channel
18:47:38 <cwl> byorgey: paste to hpaste.org?
18:47:50 <byorgey> yes
18:55:16 <jefferai> Hi there...not sure if this is the right channel to ask, but I'm having some issues with a cabal package, specifically old-time...when I try to run "cabal install cabal" (since some packages seem to want a local version instead of being happy with the system version), I get the following during compilation of old-time: "System/Time.hsc:253:67:    Not in scope: type constructor or class `CSUSeconds'" -- I'm not sure what to do about it
18:59:18 <dalaing> mm_freak_: there's http://hackage.haskell.org/package/OpenGLRaw, although I haven't done any GL stuff in Haskell yet so I can't really comment on it much
19:11:25 <moriramar> http://www.acfun.tv/v/ac242183/
19:11:37 <moriramar> sorry, i copied the wrong address
19:12:36 <moriramar> excuse me, is there any special problem with iter' a b = if a = b then return () else getLine >>= doSth >>= putStrLn , iter = iter' 10.
19:13:16 <moriramar> The program is like this http://pastebin.com/GN1tGnJn
19:14:44 <moriramar> When I write it in the way like "iter a b = if a == b then return () else getLine >>= xxx >>= putStrLn", it works; while writting it in the way like "iter = iter' 10 where ...", it does not stop.
19:17:03 <moriramar> Sorry, i found the problem in prime...
19:31:20 <scooty-puff> is c2hs still used often?
19:35:16 <djahandarie> Does anyone know how timeout from System.Timeout actually goes about working? It works 90% of the time for me but sometimes it fails to return within the time specified
19:36:51 <monochrom> spawn new thread for the victim. spawn new thread for threadDelay. wait for one of them to finish (takeMVar). kill the other.
19:37:54 <monochrom> first weakness is that threadDelay is rather soft. though not as bad as 10%
19:38:57 <monochrom> second weakness is GHC threads are rescheduled at "allocation points" only. if you have lengthy Int# number crunching (for example) many threads are starved.
19:39:34 <djahandarie> Well, when it doesn't finish "within the time specified", it actually doesn't finish at all
19:40:06 <djahandarie> Also, the only thing it's doing is opening a socket and reading a few characters from it
19:40:20 <monochrom> third weakness is if you don't link with -threaded, blocking FFI calls stop the world
19:40:44 <Eduard_Munteanu> djahandarie: most such delay functions only guarantee it sleeps *at least* that amount of time
19:40:47 <djahandarie> I do indeed have -threaded -- I imagine the network libs involve FFI calls.
19:41:14 <djahandarie> Eduard_Munteanu, 'timeout' seems awfully useless if things never stopping is not a failure condition semantically
19:41:36 <Eduard_Munteanu> Yeah, never stopping is another thing I guess :)
19:46:32 <monochrom> if you have -threaded, "unsafe" FFI calls still stop the world (foreign import unsafe blahblah)
19:52:34 <djahandarie> Hmm... I need some sort of tool to track down where this problem is happening
19:59:46 <scooty-puff> what is the most efficient way to get any arbitrary element out of an Data.Set?
20:00:35 <monochrom> perhaps findMin
20:00:42 <scooty-puff> k
20:00:58 <copumpkin> or deleteFindMin :: Set a -> (a, Set a)
20:01:03 <copumpkin> that way you can do it iteratively
20:01:08 <copumpkin> :t state
20:01:09 <lambdabot> forall s a. (s -> (a, s)) -> State s a
20:01:15 <copumpkin> :t state deleteFindMin
20:01:16 <lambdabot> Not in scope: `deleteFindMin'
20:01:21 <copumpkin> :t state S.deleteFindMin
20:01:22 <lambdabot> forall a. State (S.Set a) a
20:01:48 <monochrom> minView is better than both if you do it iteratively, so you know when to stop
20:01:49 <copumpkin> :t replicateM 10 (state S.deleteFindMin)
20:01:50 <lambdabot> forall a. StateT (S.Set a) Identity [a]
20:03:20 <copumpkin> > (evalState $ replicateM 10 (state S.deleteFindMin)) . S.fromList $ [50,49..20]
20:03:21 <lambdabot>   [20,21,22,23,24,25,26,27,28,29]
20:03:30 <copumpkin> and I call this copumpkinsort
20:05:36 <monochrom> "do not trust people of the copumpkin sort" XD
20:06:01 <copumpkin> :(
20:35:04 * hackagebot json 0.5 - Support for serialising Haskell to and from JSON  http://hackage.haskell.org/package/json-0.5 (IavorDiatchki)
20:40:23 <kmc> does Parsec or Applicative define a synonym for «liftA2 (:)» ?
20:42:22 <copumpkin> I don't think so
20:42:40 <copumpkin> you want to use it on its own and not iteratively?
20:48:05 <kmc> yeah, writing a simplified definition of 'many' for didactic purposes
20:54:17 <newb_> pardon me, where can I find a compact reference to syntax and common/standard functions? I
20:55:01 <kmc> http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/start.html
20:55:05 <newb_> I've read quite a bit but find myself forgetful as to the particulars of the langauge even though my understanding of the concepts is fairly sound
20:55:09 <kmc> http://www.google.com/url?sa=t&source=web&cd=1&sqi=2&ved=0CCEQFjAA&url=http%3A%2F%2Fblog.codeslower.com%2Fstatic%2FCheatSheet.pdf&ei=zBt4Tp60KorBtge529yhDA&usg=AFQjCNHXrnXzj-diQRZ-NfzsJEcqB8QFlw
20:55:11 <kmc> bah
20:55:16 <kmc> blog.codeslower.com/static/CheatSheet.pdf
20:55:55 <kmc> also you can use ":i" in GHCi to ask for the module where something was defined, and then look up docs there
20:56:00 <kmc> or you can use Hoogle
20:56:02 <kmc> @hoogle zipWith3
20:56:03 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
20:56:03 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
20:56:34 <newb_> fantastic answer! thanks for completeness and promptness
20:57:03 <newb_> the cheatsheet looks like exactly what I need though I'm sure the other resources will be helpful in the future
20:57:58 <kmc> :)
20:58:52 <newb_> I'd heard this community was friendly and helpful but that was better even than most linux groups (to someone who doesn't mind reading documentation)
21:04:07 <newb_> One more, slightly more general, question. I understand that through C(++?) integration full Haskell desktop applications can be created. But how good is Haskell's built in support for data I/O and graphical user interfaces? As I understand it, it's not really intended for that sort of thing.
21:10:48 <shachaf> Oh, he's gone.
21:11:08 <shachaf> Be on your guard, #haskell!
21:11:50 * absentia isn't here either.
21:15:37 <kmc> naturally
21:18:46 <smop_> so haskell isn't really intended for data i/o and gui's?
21:19:54 * DukeDave is working on it!
21:20:59 <elliott_> Is there a way to depend on a package in a cabal file without exposing its modules to my code? A package I want to depend on has overly-lax dependencies and fails to build with the version of one of its dependencies cabal picks by default.
21:21:11 <DukeDave> smop_: And now you can help too: http://haskell.org/haskellwiki/WxHaskell
21:21:14 <elliott_> So I'd like to specify a more strict version of that package as a dependency of my package as a stop-gap.
21:26:01 <smop_> DukeDave: i am still learning haskell really bad so far
21:26:51 <DukeDave> smop_: Ah, okay, no problem :)
21:27:14 <DukeDave> You can use Haskell for just about anything
21:29:54 <smop_> so it seems
21:30:05 <smop_> working my way through the wikibooks and lyah, rwh should be up next
21:31:21 <DukeDave> smop_: Ah yes, they are really helpful
21:32:03 <DukeDave> I was lucky in some sense that I was taught Haskell at university, but I did come away thinking that it wasn't a particularly practical language, until I discovered how big the community way..
21:32:05 <DukeDave> *was...
21:33:07 <smop_> did you enjoy learning it at the time?
21:36:06 <nexx> It seems a bit strange that wxWidgets is a cross-platform library including GTK which itself is a cross-platform library
21:40:33 <shachaf> nexx: Gtk doesn't use native widgets on most platforms, does it?
21:41:18 <Maxdamantus> Probably just depends on the widget engine
21:41:52 <Maxdamantus> Well, you can probably use that (create an engine) for any platform.
21:42:19 * Maxdamantus thinks GUIs should generally be made per-platform.
21:42:31 <nexx> Dunno. I don't use it much
21:43:06 * Maxdamantus thinks Apple have some rules that GUIs have to follow.
21:57:59 <kmc> smop_, what's "data i/o"?
21:59:19 <kmc> Haskell is a practical language, but it takes a lot of learning to get to that point
22:00:01 <ben> You're never done learning either, are you
22:00:17 <Enigmagic> i stopped a while ago
22:00:26 <ben> You just figure out how to use a monad transformer to make coffee or whatever, and then some guy invents a caffeeinated iteratee or something
22:00:44 * Enigmagic sticks his fingers in his ears
22:00:51 <kmc> hehe
22:01:07 <kmc> a lot of people are done after 1 week.  but those people usually decide Haskell is only useful for computing the Fibonacci sequence
22:01:47 <smop_> kmc: i have no idea, i was repeating what this guy newb_ was saying, it wasn't my question
22:01:59 <kmc> oh
22:02:07 <kmc> yeah, i've no idea what that meant
22:02:42 <shachaf> > nubBy(((>1).).gcd)[2..] -- *Just* the Fibonacci sequence? I don't think so!
22:02:44 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
22:03:32 <dolio> Data i/o is when you do input and output of data.
22:03:42 <dolio> In contrast to the input/output of non-data.
22:03:59 * shachaf does input/output of metadata.
22:04:18 <dolio> Like how at work we have the REPL and the InteractiveREPL.
22:04:25 <kmc> haha
22:04:25 <dolio> Because the normal REPL isn't interactive.
22:04:33 <kmc> does it read, evaluate, print from a file?
22:04:48 <kmc> alias irepl='rlwrap repl' #?
22:04:49 <shachaf> It just reads, evaluates, and prints from itself.
22:04:52 <shachaf> In a loop, as it were.
22:04:55 <shachaf> fix repl
22:08:58 <dolio> The normal REPL is in fact interactive.
22:09:51 <kmc> and the InteractiveREPL?
22:09:55 <kmc> is it double interactive?
22:10:21 <dolio> It's just different.
22:11:06 <dolio> One of those situations where someone was looking for a name, and there isn't a good one, so you come up with something that doesn't make a lot of sense when you think about it.
22:11:20 <dolio> I didn't even notice for a couple weeks.
22:11:30 <kmc> is it a Java class?
22:11:40 <dolio> It's a Scala class.
22:11:47 <kmc> you should have used Haskell
22:11:51 <kmc> then you could name them "x" and "xs"
22:11:55 <dolio> I would love to.
22:13:18 <shachaf> Haskell should support patterns like ((x,y):(x,y)s).
22:13:25 <djahandarie> Heh
22:13:31 <kmc> a real time-saver
22:13:49 <kmc> i've met some people who think that the xs name is magically linked to x
22:14:09 <djahandarie> "Over 50% increases in productivity reported since new syntax addition for Haskell programmers..."
22:14:21 <kmc> > 0 * 0.5
22:14:21 <lambdabot>   0.0
22:14:32 <djahandarie> My degrading grammar is sign that I should be sleeping.
22:14:33 <kmc> > 0 * 1.5
22:14:34 <lambdabot>   0.0
22:16:00 <shachaf> > 0 ∗ 2.5
22:16:02 <lambdabot>   1.0e-3
22:17:14 <aspect> wat
22:17:35 <kmc> > fromEnum '∗'
22:17:36 <lambdabot>   8727
22:17:53 <kmc> Unicode Character 'ASTERISK OPERATOR' (U+2217)
22:18:03 <kmc> does λb have a function that will look up the name of a Char?
22:18:31 <dalaing> I figured it was unicode, but wasn't sure until I checked with ghci
22:18:33 <dalaing> it's been a long day
22:18:43 <kmc> it's all unicode!
22:18:48 <kmc> it's the universal code!
22:19:14 <shachaf> kmc: Only if you write it and submit it!
22:19:17 <shachaf> It would be useful.
22:19:24 <shachaf> We would get you a cake.
22:19:38 <dalaing> ebcdic forever!
22:20:30 <kmc> what kind of cake shachaf?
22:20:32 <kmc> > cake
22:20:33 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
22:20:38 <shachaf> > map last cake
22:20:40 <lambdabot>   "........:................'................"
22:20:46 <shachaf> Punctuation cake.
22:21:14 <kmc> > reverse $ sortBy (comparing length `mappend` compare) (words $ concat cake)
22:21:15 <lambdabot>   ["positioner.Slaughter","resins.Unsaturated","injector.Injector","injector....
22:21:36 <kmc> > reverse $ sortBy (comparing length `mappend` compare) (words $ unlines cake)
22:21:38 <lambdabot>   ["electro-magnetic","preservatives,","impoundments.","ethylbenzene.","geosy...
22:22:25 <kmc> > filter ("ethylbenzene" `isInfixOf`) cake
22:22:26 <lambdabot>   ["Fish shaped ethylbenzene."]
22:24:54 <shachaf> @ty (=~)
22:24:55 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
22:24:59 <shachaf> Doesn't that type just make you smile?
22:27:20 <kmc> y u troll shachaf
22:27:46 <kmc> (=~) :: (C t) => t
22:27:47 <shachaf> kmc: I was trying to use =~ instead of isInfixOf and got annoyed.
22:28:17 <shachaf> I thought everyone in this channel deserved to partake.
22:28:29 <kmc> cool
22:28:55 <kmc> > filter ("ethylbenzene" =~) cake
22:28:57 <lambdabot>   []
22:29:07 <kmc> > filter (".*ethylbenzene.*" =~) cake
22:29:08 <lambdabot>   []
22:29:19 <shachaf> > filter (=~ "ethylbenzene") cake
22:29:20 <kmc> o_O
22:29:21 <lambdabot>   ["Fish shaped ethylbenzene."]
22:29:23 <shachaf> See?
22:29:37 * shachaf 's problem is that he can't tell the difference between source and source1.
22:30:08 * kmc 's problem is that he forgot the Perl syntax
22:30:25 <shachaf> True.
22:30:25 <kmc> afaik that is the one guiding principle of that operator
22:30:39 <kmc> "be like Perl at all costs or people will make fun of Haskell for being impractical and will shove us into lockers after school"
22:30:56 <kmc> fortunately this strategy was not followed in other libraries
22:31:04 <coppro> > cake
22:31:06 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
22:31:20 <kmc> if you want a language which strives to be like Perl at all costs, might i recommend Perl
22:32:30 <kmc> :t ($&
22:32:31 <lambdabot> parse error (possibly incorrect indentation)
22:32:32 <kmc> :t ($&)
22:32:32 <lambdabot> Not in scope: `$&'
22:34:59 <Enigmagic> Types.hs:3600:19: Warning: Pattern match(es) are overlapped
22:35:12 <Enigmagic> more than 3600 lines = manly.
22:35:36 <Enigmagic> i congratulate the author of this module.
22:41:53 <swarles> I was reading the haskell tutorial Write Yourself A Scheme in Haskell in 48 Hours, and I tried to run the first example and it produced an error. [hello.hs:6:1: parse error on input `putStrLn']. Could someone show me what i did wrong? http://pastebin.com/wTbcLAwd
22:41:55 <mauke> The paste wTbcLAwd has been copied to http://hpaste.org/51557
22:42:57 <kmc> swarles, you should indent putStrLn to line up with ars
22:42:58 <kmc> args*
22:43:10 <kmc> are you using tab characters?
22:43:16 <swarles> kmc, yes i tried that
22:43:27 <kmc> don't use tab characters
22:43:40 <swarles> oh, so make it visually align?
22:43:48 <kmc> different editors display them differently and there's no guarantee your editor uses the same tabstop as ghc
22:43:49 <kmc> note how it doesn't line up on hpaste
22:43:54 <kmc> only use spaces for alignment
22:43:55 <shachaf> Spatially align.
22:44:09 <shachaf> Does Haskell respect tabs for indentation at all?
22:44:26 <kmc> shachaf, it either uses an 8-space tab stop or treats each tab as 8 spaces
22:44:28 <kmc> i forgot which
22:44:36 * shachaf considers himself vaguely fortunate not to be aware of the answer.
22:44:45 <Rotsor> I think Tab is worth 8 spaces in Haskell
22:44:50 <dalaing> swarles: I finished that last week - it's a great tutorial
22:44:56 <swarles> That produced, hello.hs:4:10: Not in scope: `args', hello.hs:4:15: Not in scope: `<−', hello.hs:5:34: Not in scope: `args'
22:45:17 <kmc> can you hpaste the new code?
22:45:20 <swarles> yes
22:45:27 * kmc thinks ghc should warn on \t, and this warning should be on by default
22:45:33 <kmc> in fact all warnings should be on by default
22:45:39 <kmc> alias ghci='ghci -Wall'
22:45:47 <hpaste_> swarles pasted “Untitled” at http://hpaste.org/51558
22:46:25 <kmc> swarles, you wrote "<−" not "<-"
22:46:28 <kmc> > "<−"
22:46:29 <lambdabot>   "<\8722"
22:46:38 <shachaf> kmc to the rescue!
22:46:45 * shachaf shamefully did not catch that.
22:46:51 <swarles> thats odd
22:46:51 <kmc> you used the Unicode minus sign rather than the ASCII hyphen-minus
22:46:57 <swarles> i dont know how i managed that
22:47:29 <swarles> It compiled! Thank you :)
22:47:29 <kmc> with GHC -XUnicodeSyntax you can instead use ← 'LEFTWARDS ARROW'
22:47:32 <kmc> no problem :)
22:47:34 <shachaf> - − – —
22:48:05 <shachaf> ←O→
22:48:07 <shachaf> blah blah
22:48:10 <shachaf> →O←
22:48:33 <shachaf> That wasn't as effective an optical illusion as I'd hoped.
22:48:40 <shachaf> kmc: What do you use to figure out names of Unicode characters?
22:48:45 <kmc> google
22:48:54 <Maxdamantus> grep
22:49:07 * shachaf uses ~/bin/unic and is only mildly pleased with it.
22:49:17 <shachaf> How does one use the Google for it?
22:49:22 <Enigmagic> unicode.org has all of the tables online
22:49:38 <shachaf> Oh, 03b1 etc.?
22:49:51 <Enigmagic> http://www.unicode.org/charts/
22:50:39 <kmc> @. google run printf "U+%04x" (ord '←')
22:50:41 <lambdabot> http://stackoverflow.com/questions/431527/ambiguous-type-variable-error-msg
22:50:41 <lambdabot> Title: haskell - Ambiguous type variable error msg - Stack Overflow
22:50:45 <kmc> o_O
22:50:50 <kmc> > run printf "U+%04x" (ord '←')
22:50:51 <lambdabot>   Not in scope: `run'
22:50:53 <kmc> buh
22:50:55 <kmc> > printf "U+%04x" (ord '←')
22:50:55 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:50:55 <lambdabot>    `GHC.Show.Show a'
22:50:55 <lambdabot>      a...
22:51:06 <kmc> > printf "U+%04x" (ord '←') :: String
22:51:06 <lambdabot>   "U+2190"
22:51:11 <kmc> hahaha
22:51:14 <kmc> i see what happened
22:51:22 <kmc> @. google run printf "U+%04x" (ord '←') :: String
22:51:24 <lambdabot> http://www.fileformat.info/info/unicode/char/2190/index.htm
22:51:24 <lambdabot> Title: Unicode Character 'LEFTWARDS ARROW' (U+2190)
22:51:25 <Maxdamantus> > printf
22:51:26 <lambdabot>   Overlapping instances for GHC.Show.Show (GHC.Base.String -> r)
22:51:26 <lambdabot>    arising f...
22:51:27 <Maxdamantus> egh
22:51:42 <kmc> @. google run printf "U+%04x" (ord '☭') :: String
22:51:44 <lambdabot> http://www.fileformat.info/info/unicode/char/262d/index.htm
22:51:44 <lambdabot> Title: Unicode Character 'HAMMER AND SICKLE' (U+262D)
22:51:58 <kmc> @. google run printf "U+%04x" (ord 'ꙮ') :: String
22:52:00 <lambdabot> http://www.fileformat.info/info/unicode/char/a66e/index.htm
22:52:00 <lambdabot> Title: Unicode Character 'CYRILLIC LETTER MULTIOCULAR O' (U+A66E)
22:52:02 <Maxdamantus> $ grep ^$(printf "%X" 8722)\; /usr/share/unicode-data/UnicodeData.txt
22:52:02 <Maxdamantus> 2212;MINUS SIGN;Sm;0;ES;;;;;N;;;;;
22:52:18 <Enigmagic> @. google run printf "U+%04x" (ord '?fp') :: String
22:52:20 <lambdabot> http://stackoverflow.com/questions/4910017/haskell-lexical-error-in-string-character-literal-at-character-i
22:52:20 <lambdabot> Title: recursion - Haskell: lexical error in string/character literal at character 'i'  ...
22:52:48 <kmc> 'recursion' tag very appropriate
22:53:27 <Enigmagic> :|
22:53:30 <shachaf> > (::String) $ printf "U+%04x" (ord '←')
22:53:31 <lambdabot>   <no location info>: parse error on input `::'
22:53:31 <Enigmagic> 'PHAISTOS DISC SIGN TATTOOED HEAD' (U+101D2)
22:53:32 <shachaf> Cuses.
22:53:36 <Enigmagic> still one of my favorites ;-)
22:55:03 * hackagebot iterIO 0.2 - Iteratee-based IO with pipe operators  http://hackage.haskell.org/package/iterIO-0.2 (DavidMazieres)
22:56:40 <shachaf> @show ←
22:56:40 <lambdabot> "\226\134\144"
22:56:47 <shachaf> Stupid lambdabot.
22:56:53 <kmc> > iterate show "←"
22:56:54 <lambdabot>   ["\8592","\"\\8592\"","\"\\\"\\\\8592\\\"\"","\"\\\"\\\\\\\"\\\\\\\\8592\\\...
22:57:14 <kmc> > "\226\134\144"
22:57:15 <lambdabot>   "\226\134\144"
22:57:32 <kmc> what? is that the utf-8 or something?
22:57:36 <kmc> sigh
22:57:44 <Axman6> > fix show
22:57:45 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
22:58:47 * shachaf is unsuccessfully trying to make a meta-command with @where.
22:58:52 <Axman6> > text "\226\134\144"
22:58:53 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
22:59:11 <kmc> > map length . group $ fix show
22:59:14 <lambdabot>   mueval-core: Time limit exceeded
22:59:24 <kmc> > map length . group . take 1000 $ fix show
22:59:27 <lambdabot>   [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,489]
22:59:58 <kmc> > map length . iterate (filter (=='\\') . show) $ ""
22:59:59 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
23:00:04 <kmc> > map length . iterate (filter (=='\\') . show) $ "\\"
23:00:08 <lambdabot>   mueval-core: Time limit exceeded
23:00:08 <shachaf> Wow, @@ respects quotes. :-(
23:01:40 <kmc> http://en.wikipedia.org/wiki/CESU-8 sigh
23:02:35 <copumpkin> why would anyone do that?
23:04:44 <kmc> by mistake
23:17:55 <olsner> "Oracle's UTF8 character set (unfortunately, a misnomer), available since version 8.0 of the database, is actually CESU-8. The character set AL32UTF8, introduced in version 9.0, is UTF-8 compliant." :(
23:22:40 <elliott_> Has anyone had a "unknown symbol `X509_CRL_get0_by_serial'" error when using HsOpenSSL-0.10.1? Seems like it might want a newer OpenSSL than I have, or something.
23:23:21 <zzo38> This is the program I used, and maybe it is too long; is there shorter way to derive Lift?  http://hpaste.org/51559
23:24:50 <zzo38> Did I wrote it too long?????
23:25:39 <zzo38> Oops, I realized, I didn't mention what extractQ is, now I can do so:   extractQ = maybe (error "No value in Quasi") id . runQ;
23:30:24 <danikar> I am trying to follow a tutorial that uses the eval function in haskell, but ghc says it is not in scope. Is there a module that it is included in?
23:31:09 <ben> @hoogle eval
23:31:10 <lambdabot> Control.Monad.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
23:31:10 <lambdabot> Control.Monad.RWS.Strict evalRWS :: RWS r w s a -> r -> s -> (a, w)
23:31:10 <lambdabot> Control.Monad.RWS.Lazy evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
23:31:27 <ben> What tutorial?
23:32:13 <danikar> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
23:32:35 <danikar> its in part 3
23:34:37 <danikar> bleh nvm im suppose to implement it
23:35:39 <elliott_> danikar: I see eval:http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot#A_simple_interpreter
23:35:45 <elliott_> Doesn't look unimplemented to me.
23:37:27 <danikar> i meant i am suppose to copy and paste what is there and not use a core library function which is what i thought it was.
23:56:12 <Rotsor> Is there a better way of transferring a value from the Q monad to the generated code than something like (AppE (VarE 'read) (LitE (StringL $ show x)))?
