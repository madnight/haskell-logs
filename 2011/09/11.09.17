00:01:50 <siracusa> tkahn6: Probably by fixing the things "ghc-pkg check" tell you (if any)
00:02:03 <tkahn6> siracusa: thanks i'll try that
00:02:58 <tkahn6> siracusa: tells me nothing :(
00:03:00 <tkahn6> haha
00:03:28 <siracusa> Hhm, no I dea then
00:03:37 <siracusa> *idea
00:03:51 <napping> sounds like something is pretty broken, though
00:04:41 <applicative> tkahn6 does ghc-pkg list show the two time libraries?  is one global, the other local?
00:04:48 <applicative> i mean, the two versions
00:05:02 <tkahn6> applicative: checking...
00:05:03 <gienah> tkahn6: it probably means a dependency is built with time-1.1.4, and some other dependency or the pkg you are building is built with time-1.4, and cabal would have warned earlier that this is likely to result in a build failure
00:07:13 <applicative> tkahn6 those errors were from inside ghci?
00:07:24 <tkahn6> applicative: yes
00:08:01 <tkahn6> ok so i think the problem might have to do with the fact that time-1.4 is installed to my $USER package place
00:08:17 <tkahn6> and time-1.1.4 is in the global package place
00:08:26 <applicative> yes, that must remain so, though
00:08:34 <tkahn6> ah ok
00:08:59 <tkahn6> so should i try compiling with ghc and see if i get any errors?
00:09:23 <applicative> at least on the principle employed by dimwits like myself, that you dont mess with the global install stuff from the Haskell platform etc
00:09:39 <tkahn6> yeah that makes sense
00:10:16 <applicative> you can still use more up to date packages locally or in separate development or whatever, so in principle there should be no problem
00:12:54 * applicative contemplates a possible `cabal rebase`
00:15:28 <applicative> but I think if you had somehow made a hash of the globally installed packages, it would be much uglier :)
00:16:59 <tactics> Why are so many authors insistent on putting "let" in the core of their calculii?
00:17:20 <tactics> Why don't they just make it sugar for a function call and application?
00:17:33 <jeltsch> () is the canonical one-value type. Is there some library that defines a canonical empty type?
00:17:39 <ddarius> Because it has different typing rules and often different semantics.
00:18:02 <ddarius> () has two values and there are no empty types in Haskell.
00:18:54 <elliott> jeltsch: http://hackage.haskell.org/package/void
00:19:03 <applicative> tkahn6 here's another simple plan, try ghc-pkg unregister time --user   if it has dependencies, ghc-pkg will warn you
00:19:13 <elliott> tactics: Because let provides fix too?
00:19:41 <tactics> elliott: That would make sense for some systems. But I've seen fix-less calculii with it too
00:19:45 <tkahn6> applicative: ghc-pkg: unregistering time would break the following packages: pcap-0.4.5.1 (use --force to override)
00:19:46 <jeltsch> elliott: Thanks.
00:19:51 <elliott> jeltsch: np
00:19:54 <elliott> tactics: Dunno then.
00:20:23 <jeltsch> By the way, the docs for the void package say that it is a Haskell¬†98 type, which it isn‚Äôt since it uses EmptyDataDecls.
00:20:47 <applicative> tkahn6, i suggest the minimal plan of "ghc-pkg unregister pcap time --user  " then trying to reinstall them and studying any warnings you get
00:21:02 <cwl> how pattern matching match a type of Ratio Integer
00:21:12 <jeltsch> Only early versions were Haskell-98-compatible, since they used this definition:
00:21:12 <jeltsch>     newtype Void = Void Void
00:21:13 <tkahn6> applicative: I tried installing pcap to global and that seemed to fix it
00:21:22 <tkahn6> applicative: or at least i think that's what fixed it
00:21:29 <tkahn6> lol
00:21:49 <ddarius> This is the source code to the latest version on Hackage: http://hackage.haskell.org/packages/archive/void/0.5.5/doc/html/src/Data-Void.html#Void
00:21:54 <tkahn6> applicative: thanks for your help. this community is pretty amazing
00:22:08 <applicative> oh, so now it is built with the older time, which is okay, still I don't think it should have been necessary.  or does ghc-pkg list show both versions now global?
00:23:14 <tkahn6> applicative: ... oddly it doesn't show pcap in global
00:25:45 <applicative> does it show the later version of time in global
00:26:36 <applicative> or just the original one, that perhaps came with Haskell Platform,
00:30:09 <applicative> if the later version of Time is only local, or doesn't exist at all, and you're getting no error import pcap, then everything would be looking normal, I think
00:34:40 <tkahn6> applicative: old version of time in global
00:35:25 <applicative> then it looks like you somehow joggled it into the state originally desired, good luck with pcap
00:38:23 * applicative is so happy that Data.Void now has an Ix index for Void; he can drop that orphan instance he's been using so often....
00:38:31 <applicative> Ix instance rather
00:40:38 <elliott> applicative: I wonder if you can actually do that to get a single-element array indexed by _|_.
00:46:48 <applicative> yipe :: Array Void Int; yipe = listArray (x,x) [] where x = absurd x
00:47:22 <applicative> not enough elements....
00:58:05 <cwl> how to convert rational to double
00:58:28 <cwl> @info Rational
00:58:28 <lambdabot> Rational
00:59:25 <chrisdone> hey
00:59:25 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
01:00:31 <kmc> cwl, realToFrac
01:00:32 <chrisdone> quicksilver: quote marks best used for ''quotation'' not for *emphasis* kthxbye :)
01:00:32 <chrisdone> quicksilver: I used *emphasis* originally, then i pasted it into the wiki and discovered the wiki uses '' for emphasis, so i replaced. then decided to post it on the mailing list. only noticed later i forgot to replace again ;)
01:00:43 <cwl> :t realToFrac
01:00:44 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
01:01:15 <cwl> > realToFrac (1 %2)
01:01:15 <lambdabot>   0.5
01:11:38 <napping> > cabal install cabal-install
01:11:38 <lambdabot>   Not in scope: `cabal'Not in scope: `install'Not in scope: `cabal'Not in sco...
01:11:53 <napping> cabal: cannot configure unix-2.4.2.0. It requires base >=4.2 && <4.4
01:12:01 <napping> Does cabal not work with 7.2.1?
01:19:17 <chrisdone> napping: with these patches my friend was able to use cabal on 7.2.1 https://gist.github.com/1169332
01:20:00 <napping> I'll go with 7.0.4 for now (getting a system I hadn't used for a while back up to date)
01:28:40 * chrisdone trying for the third time to migrate his project to ghc 7
01:30:43 <chrisdone> so the State constructor was removed from Control.Monad.State in mtl and now the encoding package doesn't build
01:34:19 <chrisdone> man i cannot be bothered
01:34:26 <chrisdone> 6.12.3 for life
01:34:50 <napping> How about when DPH comes out?
01:35:19 <chrisdone> huh?
01:35:42 <napping> Data Parallel Haskell
01:41:16 <dibblego> chrisdone: the State constructor was removed and replaced with the state/runState functions iirc
01:41:29 <dibblego> type State s a = StateT s Identity a
01:43:18 <chrisdone> yep
01:45:52 * hackagebot iptadmin 1.2.0 - web-interface for iptables  http://hackage.haskell.org/package/iptadmin-1.2.0 (EvgenyTarasov)
01:51:54 <bwright> Given a file of integers seperated by spaces in ASCII how can I convert that to a list of ints where each int is seperated by a space in the file?
01:54:41 <napping> If you want something quick, words and read
01:55:06 <napping> like, parse text = map read (words text)
01:55:17 <applicative> the numbers themselves cannot be separated by spaces, only characters can be
01:56:12 <napping> > map read (words "123 2 44 -15") :: [Int]
01:56:13 <lambdabot>   [123,2,44,-15]
01:56:52 <bwright> Cheers :)
01:57:28 <applicative> > unwords . map (show . read) $ (words "123 2 44 -15") :: [Int]
01:57:29 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
01:57:29 <lambdabot>         against inferred type ...
01:57:41 <applicative> > unwords . map (show . read) $ ((words "123 2 44 -15") :: [Int])
01:57:42 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
01:57:43 <lambdabot>         against inferred type ...
01:57:48 <applicative> what an idiot
01:57:50 <napping> uh, show . read doesn't work
01:58:23 <napping> also, (words "123 2 44 -15") :: [String], not [Int]
01:58:42 <applicative> yes too quick interpolation in yours.  i wanted the 'spaces' back
02:00:24 <engla> you can use (read :: String -> Int)
02:00:29 <applicative> > unwords $ map show (map read (words "123 2 44 -15") :: [Int])
02:00:31 <lambdabot>   "123 2 44 -15"
02:10:15 <bwright> What is going to be the most generic way to tokenize some data in a file seperated by some token into some type?
02:10:43 <bwright> I am doing a bunch of informatics problems just to try out haskell and this type of IO always comes up.
02:11:04 <ion> sepBy in Parsec and equivalents.
02:11:26 <ion> Dunno about the most generic, but that‚Äôs probably the most convenient. :-)
02:15:49 <applicative> bwright, some of the combinators in Data.List.Split can give you a poor man's version
02:38:29 <npouillard> Anyone in Tokyo near the ICFP place to have dinner?
02:42:39 <iwtu> Hi. I need define new data type. newtype Cyklus a = Cyklus {zoznam :: [a]} deriving (Eq a,Show)
02:43:07 <iwtu> just need to "a" be instance of Eq
02:43:26 <Botje> you cannot put such constraints on a
02:43:35 <Botje> just put deriving (Eq, Show)
02:44:00 <iwtu> will be works?
02:45:01 <Botje> you will get errors if you do something wrong, yes
03:03:09 <erus`> when does A = B but B /= A ?
03:05:36 <erus`> is it only outside of math?
03:06:23 <dankna> well
03:06:26 <dankna> for example
03:06:48 <dankna> "Like the ski resort full of young women looking for husbands, and husbands looking for young women, the situation is not as symmetric as it may seem."
03:07:23 <morphles> So a /= b  and b /= a :)
03:07:38 <dibblego> is there a package with multiple executables?
03:09:18 <ClaudiusMaximus> dibblego: yes. haxml is one, http://hackage.haskell.org/packages/archive/HaXml/1.22.5/HaXml.cabal
03:09:18 <dibblego> ta
03:10:35 <ClaudiusMaximus> there are probably others that have the executables depending on its library to avoid recompilation of the whole thing multiple times..
03:13:28 <konan234> Hullo everyone. I am new to Haskell. I am having hard time understanding what Haskell's traverse function does. Can someone explain it to me in simple terms? Preferably in terms of fold?
03:13:57 <dibblego> konan234: The Essence of the Iterator Pattern is the paper that covers that function in detail
03:14:03 <simon> konan234, did you read http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Traversable.html ?
03:14:51 <konan234> dibblego: Thanks. Yes, I have seen the paper. The material is quite dense for me. I am not quite there yet to understand that paper.
03:15:04 <konan234> simon: Yes. I still don't get it.
03:17:32 <dalaing_> is Traverable covered in the Typeclassopedia?
03:27:51 <konan234> Can traverse be thought of as a combination of map and sequence?
03:28:08 <dibblego> Yes.
03:28:16 <dibblego> sequence and traverse can be derived from each other
03:28:32 <dibblego> @type Data.Traversable.traverse id -- sequence
03:28:32 <lambdabot> forall (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => t (f b) -> f (t b)
03:28:59 <konan234> dalaing_: Yes it does. Thanks for the pointer. Reading it now.
03:29:42 <dalaing_> konan234: I'm new as well, I end up googling like mad whenever I come across a new concept that might bear fruit :)
03:30:04 <konan234> dibblego: Can traverse be implemented in terms of fold?
03:30:12 <konan234> dalaing_: Same here, mate!
03:30:13 <dibblego> konan234: no, other way around
03:30:28 <dalaing_> hanging out in this channel has resulting in much googling on my part
03:31:18 <konan234> dibblego: Can you please show me an implementation?
03:31:33 <konan234> dalaing_: I am here for the first time. :-)
03:31:43 <dibblego> konan234: bit busy sorry, the paper covers it
03:32:11 <dalaing_> konan234: 17/11/2011, mark it down :)
03:32:13 <konan234> dibblego: Okay. Thanks for all the pointers!
03:32:27 <dalaing_> gah 17/09/2011
03:32:29 <dalaing_> not enough sleep
03:32:42 <konan234> dalaing_: LOL. Marked.
03:32:56 <konan234> That lambdabot thing was cool.
03:34:32 <dalaing_> konan234: have you seen lambdabot doing any points free magic yet?
03:34:44 <konan234> It might be a blasphemy to ask these here, but can someone show me an implementation of traverse in terms of an imperative loop? A sort of pseudocode. I come from imperative background, so it will be easier for me to grok it I guess.
03:34:52 <dalaing_> she knows quite a few tricks
03:34:58 <konan234> dalaing_: Wow. Can it do that too?
03:35:00 <ion> @pl \a b c d e f g -> c a b b a g e
03:35:01 <lambdabot> (((const . (const .) . flip) .) .) . (flip =<< (flip .) . join . (flip .) . flip . flip id)
03:35:17 <dalaing_> I knew someone would oblige :)
03:35:22 <konan234> ion: dead impressed!
03:39:37 <konan234> @pl \x -> x * x
03:39:37 <lambdabot> join (*)
03:40:08 <konan234> @pl \x -> x + x * x
03:40:08 <lambdabot> ap (+) (join (*))
03:41:12 <konan234> @pl \x -> x + x + x + x + x
03:41:13 <lambdabot> (+) =<< (+) =<< (+) =<< join (+)
03:42:51 <Jaxan> @pl \x -> x x
03:42:51 <lambdabot> join id
03:52:09 <konan234> @pl a b c -> c b a a
03:52:10 <lambdabot> (line 1, column 7):
03:52:10 <lambdabot> unexpected ">" or "-"
03:52:10 <lambdabot> expecting variable, "(", operator or end of input
03:52:19 <konan234> @pl \a b c -> c b a a
03:52:19 <lambdabot> flip =<< (flip .) . flip (flip . flip id)
03:55:27 <incluye> what does @pl do exactly?
03:55:39 <incluye> Or better yet are there some lambdabot docs so I can go look up all its commands
03:57:30 <dibblego> incluye: http://www.haskell.org/haskellwiki/Pointfree
03:59:09 <incluye> it makes it point-free?
03:59:25 <freeasjesus> what about CPU? Anyone use CPU before?
03:59:40 <incluye> i'm using one right now
04:01:45 <freeasjesus> I'm having trouble using my CPU
04:02:30 <Nimatek> It's okay, soon enough there will be a paper on CPU-less Haskell.
04:02:52 <incluye> I would like to see haskell running on a potato
04:03:09 <Nimatek> Potatoes support many different morphisms.
04:03:19 <Ke> freeasjesus: http://xkcd.com/722/ perhaps this is your problem
04:03:25 <freeasjesus> what's that mean? I'm a bit confused...
04:03:29 <simon> incluye, that seems like a morbid fascination of dead mathematicians.
04:03:54 <incluye> I'm not eclectic enough to make a haskell joke involving potatoes
04:05:34 <Nimatek> Potato -> Fries is a perfectly fine anamorphism, for example.
04:07:29 <ziman> I find it the most natural transformation. :)
04:09:11 <ion> Is it just me or are most of the pages blank? http://www.scribd.com/doc/27352065/Modern-Benchmarking-in-Haskell
04:10:16 <incluye> Holy crap, today I realized what the haskell logo is
04:10:42 <Nimatek> ion: Looks fine to me.
04:13:26 <ion> huh
04:16:25 <saml> i need moar smart
04:17:09 <freeasjesus> incluye: isn't it just H for Haskell...? kinda obvious :P
04:17:24 <incluye> freeasjesus: i'm talking about the one that is the bind operator with a lambda instead of a >
04:19:22 <rostayob1> Is there some FRP package with some decend documentation & examples?
04:20:12 <saml> yes. code is good documentation in haskell
04:20:48 <rostayob1> saml: right. someone else?
04:21:14 <saml> seriously, just read the code.
04:21:46 <rostayob1> saml: no, that's no documentation. I want to know what FRP is as a start, and what can I do with it
04:22:04 <saml> usually codes start with a comment linking to a paper
04:22:10 <saml> that explains what FRP is
04:23:03 <rostayob1> saml: http://hackage.haskell.org/package/Yampa http://hackage.haskell.org/package/Animas http://hackage.haskell.org/package/netwire no papers, no documentation, nothing
04:23:42 <saml> then give up. don't learn FRP
04:24:10 <rostayob1> uff trolls on #haskell
04:24:36 <ion> I‚Äôd like to find a ‚ÄúLYAH‚Äù for FRP, too.
04:25:32 <rostayob1> LYAH is asking too much. I'm just looking for an hands-on tutorial with software that works with GHC 7
04:25:35 <saml> http://www.haskell.org/haskellwiki/Functional_Reactive_Programming
04:26:25 <ClaudiusMaximus> reactive-banana (iirc) had a call for example programs to be implemented recently; i don't know what the progress on that is
04:26:41 <rostayob1> saml: I looked at that page already, and most of the software is outdated
04:26:53 <ClaudiusMaximus> http://comments.gmane.org/gmane.comp.lang.haskell.cafe/90908
04:27:19 <rostayob1> actually, this looks like something http://haskell.org/haskellwiki/Yampa#Introduction
04:27:37 <rostayob1> the problem is that most of yampa's graphic stuff doesn't work with GHC 7
04:28:13 <saml> what do you mean by outdated? frp is a concept
04:28:24 <saml> each library might have different nuances
04:28:44 <geekosaur> it's a concept, but last time I looked at the haskellwiki FRP page the featured packages were all long dormant
04:28:56 <rostayob1> saml: I want something I can work on
04:29:17 <saml> baby steps first.
04:29:39 <incluye> what is ***
04:29:42 <geekosaur> there are other packages that are more current but the wiki page doesn't focus on them (or didn;t last time I looked)
04:29:56 <ClaudiusMaximus> @hoogle (***)
04:29:56 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
04:30:28 <incluye> odd
04:30:41 <rostayob1> geekosaur: the most current package seems to be netwire
04:30:54 <ClaudiusMaximus> :t (***) :: (b -> c) -> (b' -> c') -> (b, b') -> (c, c')  -- with Arrow (->)
04:30:55 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
04:30:57 <ion> :t (***) `asAppliedTo` (undefined :: a -> b)
04:30:58 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
04:31:30 <saml> http://www.formicite.com/dopage.php?frp/frp.html
04:32:05 <incluye> @unpl (. return) . (:)
04:32:06 <lambdabot> (\ d g -> ((:)) d (return g))
04:33:26 <geekosaur> yes, although it's new enugh I wouldn't expect it to actually be mentioned there in any significant way just yet
04:48:22 <freeasjesus> oh, how many mb is in a GB guys? 1000 or 1024?
04:48:49 <ion> $ units GB mbit * 8e+12
04:49:05 <ion> Oh, paste_join_multiline combined the lines.
04:51:18 <freeasjesus> :t (***) :: (b -> c) -> (b' -> c') -> (b, b') -> (c, c')  -- with Arrow (->)
04:51:18 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
04:52:31 <freeasjesus> :t what is usb stand for?
04:52:32 <lambdabot> parse error (possibly incorrect indentation)
04:52:52 <engla> freeasjesus: mb as in millibit?
04:53:09 <rostayob1> saml: uff, I can't install Stream, but that looks cool anyway
04:53:18 <freeasjesus> megabyte
05:16:19 <FredOverflow> @pl \x y -> f (g x)
05:16:19 <lambdabot> const . f . g
05:16:25 <FredOverflow> @pl \x y -> f (g x y)
05:16:25 <lambdabot> (f .) . g
05:19:55 <jack902> @pl mfilter p . Just
05:19:56 <lambdabot> mfilter p . Just
05:20:11 <jack902> @pl \p -> mfilter p . Just
05:20:11 <lambdabot> (. Just) . mfilter
05:30:29 <lysgaard> I have a strange problem with cabal-install. It whines that it can't satisfy a -any dependency, even though i have that package installed? Anyone experienced the same?
05:30:52 * hackagebot ivy-web 0.1 - A lightweight web framework, with type safe routes, based on invertible-syntax, and i18n support.  http://hackage.haskell.org/package/ivy-web-0.1 (JamesDeng)
05:32:57 <Axman6> lysgaard: ping dcoutts (or dcoutts_ not sure which is active at the moment, if any), he should be able to help, and if not, he's the one to talk to about submitting a bug report
05:36:42 <Jafet> Perhaps it failed to get any version of that package working.
05:37:52 <Jafet> Try playing ghc-pkg check.
05:40:29 <hatomic> Dows anyone know how to use wxhaskell with windows 7 appearance? Every widget I play with looks like windows 98. Ugly.
05:42:08 <lysgaard> Jafet: ghc-pkg check returns nothing
05:43:52 <lysgaard> Jafet: Axman6: When i run ghc-pkg list the package i need is listed as version remote-0.1, still cabal complains that it can't find any version of remote that satisifies -any
05:45:52 * hackagebot ivy-web 0.1.1 - A lightweight web framework  http://hackage.haskell.org/package/ivy-web-0.1.1 (JamesDeng)
05:45:59 <Jafet> Where are you installing it to?
05:46:38 <lysgaard> Jafet: installing what?
05:47:07 <Jafet> Whatever it is you're installing.
05:48:41 <lysgaard> Jafet: It seems that the problem only appears when i use cabal-dev, and not when i use cabal-install, does that make sense?
05:50:28 <Jafet> What's cabal-dev?
05:50:43 <dafis> @hackage cabal-dev
05:50:43 <lambdabot> http://hackage.haskell.org/package/cabal-dev
05:50:52 * hackagebot cabal2nix 1.16 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.16 (PeterSimons)
05:51:38 <Jafet> Is "remote" installed in the global repository, or the repository cabal-dev is using?
05:53:36 <lysgaard> Jafet: "remote" is installed in my cabal-install repository, that is it's in ~/.cabal/... or userspace repository if you want.
05:54:37 <dafis> lysgaard: so it's in your normal user package db?
05:54:40 <Jafet> <lambdabot> Wrong! Try again!
05:54:54 <dafis> methinks cabal-dev doesn't use that by default
05:55:59 <lysgaard> dafis: Yup
05:56:19 <lysgaard> dafis: But what if i have a package that depends on something outside hackage, w
05:56:33 <lysgaard> dafis: *how would one use cabal-dev then?
05:57:08 <Jafet> Why not install that globally as well?
05:57:56 <dafis> lysgaard: I have no experience with cabal-dev, I don't know, but it should be possible to tell it to use the user db too, or to install it in the sandbox db it uses
05:58:17 <dafis> Jafet: global installs not appreciated
05:59:08 <Saizan> Jafet: remember there's global, then user, and then different ones at a third level introduced by cabal-dev
05:59:31 <Jafet> In that case, it should have found the dependency.
05:59:45 <lysgaard> dafis: I think i got it! I had to use an "add-source" flag to cabal-dev to inform it of the "remote" package.
06:00:16 <dafis> good
06:00:35 <rostayob1> How can I say "if ghc version < this" in CPP?
06:01:06 <rostayob1> or anyway, I need to hide a part of the code if base is >= 4.4
06:01:14 <Axman6> i think there's a __GHC__ variable or something. check the ghc docs
06:01:31 <dafis> rostayob1: if __GLASGOW_HASKELL__ < 702
06:01:41 <dafis> erm, #if
06:02:00 <dafis> rostayob1: that is true for ghc < 7.2
06:02:01 <rostayob1> dafis: cool
06:03:45 <dafis> rostayob1: the __GLASGOW_HASKELL__ value is a three digit number, first is major-major, next two minor-major, so 6.8 -> 608, 6.12 -> 612
06:04:38 <rostayob1> dafis: yep, I found something in the ghc manual
06:04:47 <rostayob1> but it only said about equality
06:05:04 <dafis> ?
06:05:14 <Saizan> rostayob1: cabal defines macros to test package versions
06:05:33 <Saizan> rostayob1: see dist/build/autogen/*.h
06:05:52 * hackagebot haskdogs 0.3 - Generate ctags file for haskell project directory and it's deps  http://hackage.haskell.org/package/haskdogs-0.3 (SergeyMironov)
06:07:21 <rostayob1> Saizan: oh cool, thanks
06:15:18 <rostayob1> Oh god, I had no idea about the RULES pragma
06:15:47 <cebrian> hello, just a little bit of gossip
06:15:53 <cebrian> what happened with the Yi editor?
06:16:10 <cebrian> why development seems stopped?
06:24:28 <DevHC> what is this '°' char (kind of like 'i') at the end of wiki link texts? :o
06:28:39 <benmachine> DevHC: where?
06:34:36 <dafis> DevHC: inverted exclamation mark
06:34:43 <DevHC_> http://haskell.org/haskellwiki/GHC/FAQ
06:34:50 <DevHC_> ¥RTS options for hackers, debuggers, and over-interested souls°
06:35:03 <DevHC_> ¥Hooks° to change RTS behaviour°.
06:35:09 <DevHC_> etc.
06:35:43 <Eduard_Munteanu> That's the spanish one, no?
06:37:06 <DevHC_> behaviouri is the plural of behaviour :}
06:37:14 <DevHC_> hooksi is the plural of hooks xD
06:37:37 <DevHC_> that is pure engrish
06:38:08 <DevHC_> i can haz edits ur wikii?
06:38:48 <DevHC_> ima remoov sum plurali from teh linkzi
06:41:51 <benmachine> DevHC_: http://haskell.org/haskellwiki/index.php?title=Special:Userlogin&type=signup&returnto=GHC/FAQ
06:42:39 <DevHC_> gimme ur username & password
06:42:49 <benmachine> no
06:42:52 <DevHC_> :<
06:43:04 <parcs> i think there's a guest login
06:43:09 <parcs> guest/haskell'
06:43:28 <benmachine> isn't that the haskell' trac
06:43:36 <parcs> yeah
06:43:39 <parcs> oops
06:44:41 <DevHC_> WAT?
06:47:33 <rostayob1> can someone install category-extras with GHC 7.0.3?
06:48:25 <rostayob1> I get an error related to some code in a RULES pragma, without those it compiles fine
06:48:57 <parcs> category-extras is obsolete
06:49:53 <rostayob1> parcs: I was trying to install the "reactive" package and it's a dependency
06:51:01 <parcs> try installing version 0.53.5 specifically
06:53:33 <rostayob1> parcs: that has the same problems, anyway I just removed the RULES pragmas
06:57:32 <rostayob1> parcs: I give up, too many problems
06:57:39 <rostayob1> it even depends on mtl 1
07:02:34 <parcs> oh damn
07:09:04 <hpaste_> insomnia pasted ‚ÄúisOrderedBy‚Äù at http://hpaste.org/51456
07:13:58 <mamalujo> hm, I was reading 'pattern synonyms' trac page; apparently simonmar made some code for this this summer in http://www.haskell.org/haskellwiki/CamHac/PostHackathonReport . while that's great, I've noticed reading the page on pattern synonyms that its using the alternative, pattern-guard like syntax for view patters in all examples. Is this to mean, views could be changing their syntax soon?
07:14:48 <Jafet> It sounds like it could replace view patterns
07:15:36 <auastro> hi all
07:15:50 <auastro> possibly deep question
07:16:16 <auastro> is it possible to combine a ContT and a StateT monad transformer
07:16:39 <incluye> @unpl ((.)$(.))
07:16:39 <lambdabot> (\ b c e f -> b c (e f))
07:16:44 <auastro> in such a way that continuations captured can be stored in the state?
07:17:39 <mamalujo> Jafet: well, not quite; the pattern synonyms as proposed require view patterns for some functionality - just allow one to make their use invisible through a synonym. But, this proposal writes view patterns like this:  size (x | Arrow t1 t2 <- x) = size t1 + size t2, rather than as currently,    size (view -> Arrow t1 t2) = size t1 + size t2
07:18:11 <auastro> One seems to be able to get the same effect by wrapping the IO monad with a ContT and storing continuations inside IORefs
07:18:37 <auastro> However when trying to replace the use of the IORef with a StateT it seems to become impossible to type
07:19:13 <hpaste_> insomnia pasted ‚ÄúisOrderedBy‚Äù at http://hpaste.org/51457
07:19:19 <incluye> @pl \a b c d -> a b (c d)
07:19:19 <lambdabot> ((.) .)
07:19:33 <parcs> auastro: i tried this a couple of days ago actually
07:19:38 <parcs> i don't think it's possible
07:19:52 <parcs> well actually
07:20:02 <parcs> maybe with an existential wrapper it is
07:20:11 <auastro> parcs: hmmm
07:21:29 <auastro> parcs: use an existential wrapper with some type not unlike (forall a r. (a -> r) -> r)
07:21:30 <insomnia_> ups sorry u can ignore the hpaste links
07:22:28 <auastro> parcs: StateT (forall a r. (a -> r) -> r) (ContT ...) ...
07:25:29 <parcs> yeah, you can now store it but you can't use the continuation anywhere
07:27:50 <auastro> parcs: perhaps some applicative style typeclass?
07:31:07 <auastro> parcs: did you find any good reading material on the subject
07:31:54 <aoeuaoeu> http://pastebin.com/pQPw2mTs what am I doing wrong?
07:31:55 <mauke> The paste pQPw2mTs has been copied to http://hpaste.org/51459
07:32:05 <copumpkin> you're using pastebin
07:33:18 <parcs> auastro: i don't know of any
07:33:26 <auastro> parcs: damn
07:33:51 <mauke> aoeuaoeu: I give up. what are you doing wrong?
07:36:13 <incluye> > (\(a,b,c) -> (a,b,c))(1,2,3)
07:36:14 <lambdabot>   (1,2,3)
07:36:21 <incluye> :/
07:36:30 <dafis> aoeuaoeu: needs show
07:36:43 <dafis> @ty writeFile
07:36:44 <lambdabot> FilePath -> String -> IO ()
07:37:12 <incluye> @pl \(a,b,c) -> (a,b,c)
07:37:12 <lambdabot> (line 1, column 6):
07:37:12 <lambdabot> unexpected ","
07:37:12 <lambdabot> expecting letter or digit, operator or ")"
07:37:12 <lambdabot> ambiguous use of a non associative operator
07:38:18 <aoeuaoeu> dafis: as sum returns a num and writeFile requires a string so I need a -> string thus show makes sense
07:41:35 <dafis> yep
07:44:01 <insomnia_> question:  is there a simple way to give to function a value, which gets a list as a parameter and this list has only one element in it. Like this:
07:44:04 <hpaste_> insomnia pasted ‚Äútest‚Äù at http://hpaste.org/51460
07:45:14 <Jafet> > (,,) 1 2 3
07:45:15 <lambdabot>   (1,2,3)
07:45:36 <Jafet> @hoogle a -> b -> c -> (a,b,c)
07:45:36 <lambdabot> Prelude zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
07:45:36 <lambdabot> Data.List zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
07:47:44 <elliott> I take it that Haddock does not support including e.g. data types generated by Template Haskell in the documentation?
07:49:03 <insomnia_> I mean if I declare test _ [a] = True, haskel will interpret [a] as a generalisation for any list.
07:49:51 <ClaudiusMaximus> @src null
07:49:51 <lambdabot> null []     = True
07:49:51 <lambdabot> null (_:_)  = False
07:52:00 <dafis> insomnia_: [a] matches only lists with precisely one element
07:52:26 <dolio> Man....
07:52:49 <dolio> I think all the code in this paper on yield was in CC-delcont like four years ago.
07:53:29 <dolio> All the Haskel code, that is.
07:54:01 <elliott> dolio: You expect them to write code _before_ Oleg does?
07:54:16 <dolio> I expect them to write the code before I do.
07:54:22 <dolio> If they're going to publish it. :)
07:54:32 <elliott> Hmm, I thought CC-delcont was an Oleg thing.
07:54:50 <dolio> It contains some of his stuff, too.
07:54:57 <elliott> Right. I'll credit it all to him, then.
07:55:16 <dolio> The delimited continuations weren't him at all.
07:55:38 <elliott> Oh.
07:55:43 <dolio> They came from A Monadic Framework for Delimited Continuations by a few people.
07:55:44 <elliott> Give me /someone/ to blame.
07:55:59 <dolio> Amr Sabry and SPJ among them.
07:56:27 <insomnia_> thanks dafis, you are right
07:57:25 <dolio> That paper has several implementations, though, so Oleg did benchmark them and pick the best one, which is what I used.
08:07:25 <ourfrank> I create a simple module, Testing.hs, which contains a single exported top-level definition "testval = 2". I compile it, creating Testing.o and Testing.hi. I delete Testing.hs. I load Testing.o in ghci using "ghci Testing.o". Why is the Testing module not put into scope? Why cannot I access testval? How can I accomplish this without access to the source file?
08:08:29 <ourfrank> Also, if you know of a way to accomplish this using the hint package, I'd be very grateful.
08:13:30 <TheLemonMan> hi, can anyone review the style of my little test program? im satisfied with it but i don't know wether it can be further optimized
08:14:08 <hatomic> by style you mean the coding style?
08:14:52 <TheLemonMan> yep, im trying to learn haskell and its coding style
08:15:13 <shachaf> Not unless you let them see the code.
08:16:05 <TheLemonMan> http://hpaste.org/51461 here it is
08:18:12 <Clint> why is www.haskell.org broken over ipv6?
08:18:32 <Jafet> Ehh, who uses IPv6?
08:18:48 <Clint> www.haskell.org
08:20:43 <hatomic> TheLemonMan: I don't know if indentation misaligned because of hpaste. I use to follow these guidelines in http://www.haskell.org/haskellwiki/Programming_guidelines
08:20:50 <earthy> um, I can simply connect to haskell.org over ipv6
08:20:55 <earthy> no problems
08:24:53 <TheLemonMan> hatomic: misaligned ?
08:28:53 <hatomic> TheLemonMan: this site talks about the usage of whitespace vs tabs. Maybe it's also handy http://urchin.earth.li/~ian/style/haskell.html
08:34:32 <aoeuaoeu> If I have a file with two lines and I wish to apply a different function to each line
08:34:36 <aoeuaoeu> how do I go about it?
08:37:39 <earthy> do  file <- getContents "file"; let [firstline,secondline,otherlines] = lines file; return (f firstline, g secondline)
08:37:42 <earthy> something like that
08:38:22 <monochrom> @bots
08:38:23 <lambdabot> :)
08:39:10 <hpaste_> Cale annotated ‚ÄúHints about style‚Äù with ‚ÄúHints about style (annotation)‚Äù at http://hpaste.org/51461#a51462
08:39:46 <Cale> TheLemonMan: It might be nice to do something like that instead of the explicit recursion
08:40:16 <stribor> why cant you do this ["abc","efg"]:"something"
08:40:34 <Cale> stribor: Because "something" isn't a list of lists of strings
08:40:50 <Cale> and so adding a list of strings to it as a first element makes no sense
08:41:03 <stribor> so how can you add "string" to the list of strings
08:41:15 <Cale> To the end?
08:41:30 <Cale> > ["abc", "efg"] ++ ["string"]
08:41:31 <lambdabot>   ["abc","efg","string"]
08:41:48 <stribor> oh i thought ++ was only for strings
08:41:56 <Cale> :t (++)
08:41:57 <lambdabot> forall m. (Monoid m) => m -> m -> m
08:42:00 <Cale> hehehe
08:42:07 <Cale> That's the general one :)
08:42:20 <Cale> The one in the prelude is (++) :: [a] -> [a] -> [a]
08:42:48 <stribor> ok cool...
08:42:49 <stribor> Cale: thank you
08:43:26 <Cale> stribor: You should be cautious with adding elements to the end of a list in general though
08:43:33 <stribor> why?
08:43:45 <Cale> stribor: because it will always take time proportional to the length of the original list
08:43:55 <Cale> [] ++ ys = ys
08:44:00 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
08:44:16 <Cale> ^^ xs ++ ys will take O(length xs) steps to reduce
08:44:26 <stribor> oh...thats cool tip
08:44:49 <stribor> i am trying here to code recursive functions and in tutorial it says make base case....and assume that recursice call will work
08:44:56 <Cale> So if you constantly add elements to the end of a list, you'll easily end up with something quadratic time
08:45:14 <Cale> Yeah, if you're just worried about correctness for now, don't worry too much about it
08:45:29 <Cale> There are some nice tricks you can use to get efficient appending.
08:46:29 <Cale> One nice trick is to replace lists with functions that add elements to the beginning of a list. So [a] becomes [a] -> [a] at the type level, the empty list [] becomes id (the identity function), and (++) becomes (.) (function composition)
08:46:54 <stribor> nice
08:46:54 <Cale> The singleton list [x] is replaced with the function (x:)
08:47:08 <Cale> and since function composition is O(1)
08:47:17 <Cale> you can concatenate in O(1) time then :)
08:47:20 <stribor> :)
08:47:27 <stribor> i am stil fighting with recursion:)
08:47:29 <Cale> and apply the result to an empty list at the end
08:47:54 <Cale> Let's look at an example of some recursion with (++)
08:48:16 <stribor> ok
08:48:30 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
08:48:34 <Cale> Here's a binary tree datatype
08:48:44 <stribor> can we do list rather then tree
08:48:50 <stribor> i am not that far with haseklkl:)
08:48:59 <Cale> Well, sure...
08:49:03 <copumpkin> there are many other ways you can make trees
08:49:12 <copumpkin> with different properties
08:49:35 <Cale> Kinda changes the example I wanted to do though :)
08:49:55 <Cale> (an inorder traversal to flatten a tree into a list)
08:50:04 <stribor> sorry
08:50:08 <stribor> ):
08:50:13 <Cale> nah, it's okay
08:52:57 <monochrom> how do you sum up a list of numbers?
08:53:13 <stribor> add each element of the lst
08:53:18 <monochrom> base case: I know how to sum up the empty list. that's piece of cake. sum [] = 0
08:53:24 <stribor> yes
08:53:31 <stribor> sum of empty is empy
08:53:34 <stribor> thats base case
08:53:56 <monochrom> induction step: suppose "sum xs" already knows how to sum up xs. then I know how to sum up a list with just one more element: sum (x:xs) = x + sum xs
08:54:30 <stribor> hang on.....how can you say "supose sum xs " knows how to do it
08:54:38 <monochrom> the induction hypothesis is that "sum xs" already works, so I can exploit it to do sum (x:xs)
08:55:00 <stribor> yeah but thats the things...you write function and you assume it works
08:55:02 <monochrom> "and assume that recursice call will work" like you said
08:55:10 <Cale> stribor: because if it works on all smaller lists, we just need it to be able to work on a list with one more element
08:55:22 <Cale> and it'll work for all lists
08:55:31 <stribor> Cale: yeah that mase sense what you saying when function is really simple
08:55:41 <Cale> It always makes sense ;)
08:55:44 <stribor> like i am writing function we talked about lasdt night
08:55:46 <monochrom> I haven't proved termination. that is the only thing I have left open in this scheme.
08:55:50 <stribor> i have base case
08:56:04 <stribor> i have first condition
08:56:17 <monochrom> but at least you can now test that it terminates for at least a few examples, and marvel at it
08:56:24 <stribor> monochrom: true
08:56:25 <Cale> If something is true of 0, and for any n, given that it's true of n, we know that it's true of n+1, then that thing is true for all natural numbers.
08:56:42 <stribor> i wish there is System.out.println:)
08:56:51 <Cale> Right?
08:56:54 <monochrom> what you must accept at this stage is that either it non-terminates or it must give the right answer by induction
08:57:26 <stribor> how would i test my function ...i want to see that it NOT terminates
08:57:32 <stribor> just take base case out?
08:57:42 <epsilonhalbe> stribor try putStrLn
08:57:42 <monochrom> you can try
08:57:58 <Cale> So if our function works for lists of length 0, and, given that it works on lists of length n, we can see that it would work on lists of length n+1, then it must work on lists of any (finite) length.
08:58:15 <stribor> Cale: yeah i can see that
08:58:30 <TheLemonMan> Cale: are there any advantages by using monoids instead of recursion ?
08:58:32 <stribor> like how would you print intermediate syteps reciursive function is taking
08:59:12 <monochrom> I wouldn't worry about intermediate steps. I would just prove correctness by induction. that is all I need.
08:59:28 <stribor> monochrom: i'll play with that for now
08:59:36 <Cale> TheLemonMan: I think it makes the code a little clearer. You don't necessarily have to use the Monoid class if you don't want. The main thing is breaking the problem up into a solution for characters, along with a way to combine solutions for substrings.
09:00:28 <codemarine> exit
09:00:29 <codemarine> quit
09:00:31 <Cale> TheLemonMan: Avoiding explicit recursion is good style, because it leaves you less ways to mess things up :)
09:00:32 <codemarine> bye
09:01:24 <monochrom> I and a friend have observed this. I and her do not "unfold the recursion to see the intermediate steps", we just check the induction proof. other classmates spent all their time unfolding the intermediate recursive steps. end result: we understood it almost immediately and went on to use recursion to get many things done; other classmates remained stuck for the whole semester.
09:01:53 <monochrom> you can choose your fate now.
09:02:06 <Cale> stribor: The key to understanding recursion is to not worry about the intermediate steps.
09:02:53 <Cale> stribor: You can make almost anything really complicated by looking at the intermediate steps involved. It's usually easier to understand the big picture.
09:03:11 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/f2b477068bfc05aa
09:03:13 <stribor> Cale: yeah you right....i am trying to trace it and just wasdting time on that....and my assignment is due in 2 weeks:)
09:04:14 <Cale> stribor: If I tell you to wash all the dishes, you're not going to start out ordering them all and seeing your way through the whole process before getting any work done. You'll wash one dish, and then you'll wash all the rest.
09:04:41 <Cale> and all the dishes will get clean that way
09:04:51 <olsner> wash any number of dishes in only two steps :)
09:04:59 <stribor> true....as i try to write piece of code in haskell i sometimes wish "gosh ni wish i can store this in some variable and then come and grab it later"
09:05:15 <Cale> Well, you can use let
09:05:22 <Cale> let x = ... in ... use x here ...
09:06:06 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
09:06:08 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
09:06:37 <Cale> Okay, that's kind of a mindbending example of let ;)
09:06:54 <Cale> > let x = 5 + 10 in x + x
09:06:54 <lambdabot>   30
09:07:11 <stribor> yeah but i dont think let saves it in memory?...does it?
09:07:16 <stribor> what does it actually do
09:07:42 <Cale> It gives a name to the value which you can refer to later. If the value gets evaluated, it will keep it, as long as it stays in scope.
09:07:56 <Cale> If it goes out of scope, the garbage collector will pick it up.
09:08:22 <Cale> let doesn't cause evaluation to occur on its own
09:08:28 <stribor> so it is kind of like variable stored in memory
09:09:03 <stribor> yeah like whole haskell lazy evaluatioin
09:09:09 <Cale> Yeah, whose value will never change
09:09:09 <monochrom> it is a shorthand
09:09:09 <stribor> doesnt  use it unless is needed
09:09:09 <djahandarie> Does anyone know if  timeout  from  System.Timeout  works well with sockets and such? It doesn't seem to do much of anything for me
09:09:16 <stribor> does haskell gets used in real world?
09:09:34 <Cale> stribor: I'm working for a company where we're writing an iPhone game in Haskell.
09:09:46 <stribor> you serious?
09:10:00 <Cale> stribor: It's an overhead, kinda Diablo-ish action RPG
09:10:04 <KirinDave> Cale: How does that work?
09:10:10 <KirinDave> Do you actually run the interpreter on the phone?
09:10:20 <KirinDave> Or is it like the ardunio stuff where it ends up being codegen?
09:10:22 <Cale> KirinDave: We compile Haskell code to native ARM code.
09:10:26 <stribor> its probably compiled?
09:10:28 <stribor> oh ok
09:10:31 <Cale> and run it on the device
09:10:36 <KirinDave> Cale: Does the evaluator run more-or-less the same?
09:10:37 <stribor> why would you guys chose haskell
09:10:52 <KirinDave> stribor: I've deployed haskell in the "real world" of enterprise coding.
09:11:02 <Cale> stribor: Because it's the nicest available practical programming language.
09:11:17 <Cale> stribor: and we think that it would be a really good language in which to write games
09:11:19 <stribor> probably and also probably hardest programming langugae
09:11:24 <Cale> nah
09:11:32 <Cale> It's WAY easier than C++ :)
09:11:46 <monochrom> the hardest part is unlearning other languages
09:11:51 <Cale> Not that that's saying much, but hey, that's what most people write games in :P
09:12:08 <monochrom> such as the "I must execute the program step by step" dogma
09:12:09 <Cale> Easier than Objective C too
09:12:15 <parcs> Cale: any ETA on that game?
09:12:16 <stribor> brb
09:14:27 <Cale> parcs: I don't have any clear estimate, but it's looking more and more like a proper game every week. We have the terrain and models and such loading, and you can run around in the giant world that the artists have built, but apart from all the props, and some monsters which get spawned near the starting location, it's kinda empty still.
09:15:01 <Cale> The AIs for the monsters are coming together nicely.
09:16:11 <leod> too bad it's proprietary... i'd love to read the source :D
09:16:26 <Cale> and our FRP system still needs improving, but it's pretty usable.
09:16:40 <Cale> We may release that part at some point after the game is done
09:16:48 <leod> yay!
09:19:24 <Cale> It's an arrow-based FRP system. We have a custom preprocessor for the do/proc notation, since the one which is built into GHC has the problem that it uses 'arr' everywhere to route the values around, which is bad because it's impossible at runtime to do any inspection of what each 'arr' is doing, and dependency analysis becomes impossible.
09:19:52 <Cale> (which is for most users of Arrow, probably the main reason that they're using Arrow in the first place)
09:21:59 <Cale> So we have a class Arrow (~>) => ArrowPair (~>) where { fst :: (a,b) ~> a; snd :: (a,b) ~> b; swap :: (a,b) ~> (b,a); lassoc :: (a,(b,c)) ~> ((a,b),c); rassoc :: ((a,b),c) ~> (a,(b,c)) }, (rather inspired by symmetric/braided monoidal categories) and a preprocessor which makes use of those things.
09:22:42 <Cale> and doing that sped up our code by about 3 to 7 times, even when it was a good bit simpler than it is now (it's probably actually a quadratic performance improvement or something)
09:24:19 <Cale> I like the way that in Haskell, you generally get rewarded for making use of abstractions :)
09:27:12 <Cale> The cute thing here is that 'fst' can then take that behaviour of pairs apart in such a way that only updates to the first component of the pair will cause the result to be invalidated.
09:27:43 <Cale> and so you save recomputing the result of 'fst' every time that the second part of the pair changes
09:35:53 * hackagebot iptadmin 1.2.1 - web-interface for iptables  http://hackage.haskell.org/package/iptadmin-1.2.1 (EvgenyTarasov)
09:37:48 <stribor> >  [[Char]]==[String]
09:37:49 <lambdabot>   Not in scope: data constructor `Char'Not in scope: data constructor `String'
09:38:07 <stribor> >  [[Char]]==[String]
09:38:08 <lambdabot>   Not in scope: data constructor `Char'Not in scope: data constructor `String'
09:38:45 <dafis> stribor: if you want to know whether String is just a list of Char: yes
09:39:07 <stribor> "name":["abc","ggg"]
09:39:14 <leod> @src String
09:39:14 <lambdabot> type String = [Char]
09:39:16 <stribor> it says type of above is [[Char]]
09:39:40 <dafis> stribor: yes, which is the same as [String]
09:39:45 <stribor> ok
09:39:45 <stribor> tx\
09:39:50 <Cale> type String = [Char]
09:39:54 <Cale> ^^ is defined in the Prelude
09:40:18 <Cale> Ah, heh, missed the lambdabot response there :)
09:40:36 <hpaste_> ‚Äúmd2perpe+hpaste@gmail.com‚Äù annotated ‚ÄúCan I use a GADT (Phantom Type) to solve my problem?‚Äù with ‚ÄúCan I use a GADT (Phantom Type) to solve my problem? (annotation)‚Äù at http://hpaste.org/51357#a51465
09:41:44 <copumpkin> you make a paste with a link to gist?
09:42:36 <Cale> hehe, and the use of email address for name is cute, though it seems hpaste doesn't display that information anymore anyway
09:42:47 <Cale> (which is extra hilarious because it forces you to put something in that field)
09:42:59 <Cale> oh "expand"
09:43:08 <Cale> it's there, but default hidden :P
09:45:27 <Cale> I don't think int80_h includes enough information about his problem there to really say what he should do.
09:45:29 <monochrom> someone mistook hpaste for a web forum or blog site
09:45:48 <stribor> ok i have coded my function no errors but when i execute it it just hangs there
09:46:03 <Cale> stribor: interesting, could you put it on hpaste?
09:46:07 <monochrom> (time to prove termination!)
09:46:27 <dafis> if it doesn't, you have enough time
09:46:30 <hpaste_> stribor pasted ‚Äúrecursive‚Äù at http://hpaste.org/51466
09:47:31 <dafis> stribor: if the combined length is >= 10, you hang swapping head with the other param
09:47:34 <Cale> stribor: In the case where length (a ++ x) > 10, you apply myFunction to x and (a:xs)
09:47:46 <Cale> stribor: and length (x ++ a) > 10 as well
09:47:55 <Cale> so you'll apply myFunction to a and (x:xs) again
09:48:01 <Cale> and that'll be an infinite loop
09:48:53 <stribor> i will change it to first case to <=10
09:48:54 <Cale> stribor: In other words, the recursive problem that you offer is not any smaller than the problem you're trying to solve
09:49:09 <Cale> So, it doesn't eventually reach the base case.
09:49:37 <Cale> stribor: What is this function trying to do?
09:50:11 <stribor> just concatinate first parametar with first element of string....if less or equal to 10 then concatinate again with second item in list
09:50:17 <stribor> oits hard to explain it
09:51:18 <Cale> Maybe the otherwise case should just be  a:x:xs ?
09:51:28 <Cale> i.e. not recursively applying the function?
09:52:32 <stribor> second case does this : if its not smaller or equal (i changed it to <=) then  call recursive on head and concat input string with tail
09:52:42 <Cale> I think that once you properly understand what function you're trying to write, it'll be much easier to write the code and have it work :)
09:52:52 <Cale> So figure it out in English first :)
09:53:32 <stribor> is my first case ok when <= 10?
09:53:45 <Cale> Well, it's hard to say
09:54:08 <Cale> 'myFunction' isn't all that descriptive. I feel like if we could give it a better name, we might be able to tell if it was doing what we intended it to do
09:54:32 <stribor> k
09:55:18 <Cale> Is the goal that myFunction a xs should add a to the beginning of the first string in xs where the combined result is 10 or fewer characters, and otherwise, add it to the end?
09:55:18 <monochrom> the specification (as far as I've heard) is so complicated that a descriptive name would be 140 letters long
09:55:40 <stribor> monochrom: lol
09:55:51 <monochrom> and to date I still haven't seen the full specification
09:56:06 <monochrom> it is slowly degenerating to a Mensa entrance exam
09:56:08 <stribor> ill figure it out eventually
09:56:15 <mauke> monochrom: https://twitter.com/#!/DEVOPS_BORAT/status/114704077304233984
09:56:20 <Cale> monochrom: That is reaching Twitter proportions
09:57:20 <monochrom> haha, devops_borat is a fun guy
09:59:11 <Cale> "I watch movie The Social Network with Russian subtitle. I like part when main character is mention Apache and subtitle say nginx!"
09:59:16 <Cale> http://wiki.nginx.org/
09:59:33 <stribor> Cale: are you ripping movies off the torrent:)
09:59:53 <Cale> (that was a devops_borat quote)
10:00:10 <stribor> i know..i was just kidding
10:00:12 <stribor> :)
10:00:52 <stribor> i must go now and showel the snow:)
10:01:21 <tgeeky> hopefully that's not a monad metaphor
10:03:40 <Eduard_Munteanu> Hah, Cale
10:06:35 <copumpkin> Cale: you're on twitter?
10:07:21 <copumpkin> oh, he is
10:10:22 <scooty-puff> is there a version of the Data.Binary.Get.Get monad that is lazy?
10:10:33 <scooty-puff> not in the ByteString, but in the Monad operations
10:10:55 <Cale> copumpkin: fsvo 'on'
10:11:19 <Cale> copumpkin: I made an account in order to vote for someone in this thing, and then it turned out that my vote didn't count because the account was new.
10:11:25 <copumpkin> lol
10:11:29 <copumpkin> tsk tsk
10:11:35 <scooty-puff> can i define such a monad with just data Box a = ..., instance Monad (Box a) ...
10:11:46 <copumpkin> sure
10:11:56 <copumpkin> assuming ... = Box a
10:12:04 <copumpkin> or something monadish :)
10:13:03 <monochrom> "instance Monad Box where"
10:13:18 <scooty-puff> o right
10:13:20 <scooty-puff> k
10:13:25 <juliohm> Dear all, we can say that "case of" and "where bindings" are a matter of taste? Forgetting we can use case of almost anywhere.
10:13:55 <monochrom> unless you have "data Binary a b = ...", then it's "instance Monad (Binary a)"
10:14:57 <monochrom> data Box a = Bye; instance Monad Box where { return _ = Bye; _ >>= f = Bye; fail _ = error "bye bye!" }
10:16:27 <juliohm> Also, i've tried to play with GHCI and i've got a strange behavior regarding CPU usage. I've did the not so great command "length (repeat 5)" and as expected the CPU blows up. The problem was i've closed Gnome-Terminal and the process still running! I've logout, and the process still running. I had to restart my laptop to get my CPU freed.
10:17:51 <mauke> are you using screen?
10:18:50 <juliohm> mauke, no.
10:18:51 <ben> killing the process directly did not do it?
10:19:06 <davean_> juliohm: why didn't you just use "kill"?
10:19:41 <ben> I tried it and it survives losing the terminal and sigterm, but kill -9 gets rid of it.
10:19:45 <juliohm> davean_, because this is not the normal behavior of any program. When we kill the parent process (Gnome-Terminal), it kills the child processes.
10:20:12 <juliohm> It's not happening with GHCI
10:20:13 <mauke> juliohm: no, it doesn't
10:20:18 <davean_> juliohm: not really, it sends a HUP signal
10:20:23 <davean_> it doesn't kill it
10:20:31 <ben> To be fair, ignoring sigterm is pretty mean
10:20:36 <Eduard_Munteanu> The worst part is ghci doesn't break reliably on ctrl+c
10:20:38 <juliohm> davean_, oh, it's a HUP signal?
10:21:10 <davean_> It jsut gets told it lost the terminal, it doesn't get killed
10:21:17 <davean_> most decided to die at that point though
10:21:18 <juliohm> Why GHCI doesn't handle the HUP signal then?
10:21:37 <Eduard_Munteanu> I don't think it handles signals in general reliably.
10:21:39 <ben> juliohm: "length (repeat 5)" is apparently a sufficiently tight loop that it doesn't get around to it
10:21:43 <davean_> juliohm: http://en.wikipedia.org/wiki/SIGHUP
10:21:56 <Eduard_Munteanu> KILL can't be handled / caught, so that does the job
10:22:15 <Eduard_Munteanu> STOP too
10:22:24 <Eduard_Munteanu> (so you can ctrl+z and kill it yourself)
10:22:42 <davean_> STOP won't get it out of memory though
10:22:53 <ben> yes, but it will get you back to your shell so you can send KILL
10:23:00 <ben> assuming it's currently blocking your only shell or something
10:23:01 <Eduard_Munteanu> Yeah, it just gets you back to the shell.
10:23:16 <davean_> juliohm: in short though, You didn't tell it to die, and it was to busy to get around to the secondary thing it was informed about in passing
10:23:22 <mauke> (ctrl+z doesn't send STOP)
10:23:30 <davean_> catrl+\ :)
10:23:45 <juliohm> davean_, i know what SIGHUP means, but normally, we need to use nohup when wanting to avoid kill the process
10:23:45 <ben> mauke: ctrl-z induces the shell to send StoP?
10:23:47 <ben> STOP*
10:24:06 <juliohm> davean_, i logout my account
10:24:20 <juliohm> and the process was not killed. o.O
10:24:20 <mauke> ben: no, it sends SIGTSTP
10:24:22 <davean_> juliohm: logging out your account has NOTHING to do with your running proccesses
10:24:36 <juliohm> i'm the creator of the process, no?
10:24:36 <davean_> juliohm: there is no reason at all that that acction would in ANY case kill a proccess
10:24:39 <davean_> juliohm: so?
10:24:41 <mauke> juliohm: no
10:24:49 <juliohm> if i logout, the process is orphan?
10:24:50 <mauke> humans have no place in the machine
10:25:07 <ben> mauke: ?
10:25:08 <davean_> juliohm: you've got a bad machine model
10:25:10 <mauke> "orphan" describes relationships between processes
10:25:20 <mauke> ben: ?
10:25:41 <ben> mauke: What's SIGSTP and how is it different to SIGSTOP?
10:25:52 <juliohm> Well, i'm just thinking this is the first time i see an interpreter continues running after close it's terminal
10:26:08 <Eduard_Munteanu> mauke: oh, hrm... so I guess ghci doesn't change the default handling behavior for SIGTSTP then?
10:26:14 <mauke> ben: it's a signal and it can be caught
10:26:18 <mauke> Eduard_Munteanu: right
10:26:36 <monochrom> I think it's a bug. normally you can kill ghci with sigterm or sigint or even just ctrl-c
10:26:40 <davean_> juliohm: the machine doesn't even know your "session" exists
10:26:56 <ben> mauke: Are you sure you do not hve that backwards? I'm probably confused by now but the manpage says "The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored."
10:27:04 <monochrom> err, sorry, sigint or ctrl-c just kills the computation and gives you back the ghci prompt
10:27:18 <juliohm> davean_, if you run a process and logout, the process stills running? make a test case.
10:27:27 <Eduard_Munteanu> ben: SIGTSTP   18,20,24    Stop    Stop typed at tty        -- and it can be caught just fine
10:27:29 <davean_> juliohm: EVERY PROCCESS EVER :-p
10:27:35 <davean_> juliohm: webservers, screen, etc
10:27:44 <davean_> juliohm: Basic component of the OS model
10:27:49 <davean_> Actually, the most basic
10:27:54 <Eduard_Munteanu> ben: it's just that ghci doesn't mess with it
10:27:56 <davean_> the session is a construct of proccesses
10:28:10 <Eduard_Munteanu> (unlike with TERM and others)
10:29:22 <kmc> UNIX does have a concept of "controlling tty" and login sessions etc
10:29:30 <kmc> which give rise to much weirdness
10:29:40 <kmc> for example if you are added to a group, it's not visible until all sessions have ended
10:30:00 <kmc> i guess you already covered SIGHUP and nohup
10:30:50 <davean_> kmc: that is a matter of inheritance
10:31:35 <davean_> kmc: note newgrp and such
10:31:53 <scooty-puff> i'm having some trouble making a binary deserialization lazy enough
10:32:05 <scooty-puff> the idea is to use a RecT monad
10:32:25 <scooty-puff> RecT's "ask" gives the final result, while "tell" puts to what will be the final result
10:32:39 <scooty-puff> are Data.Array.Array's lazy in the array method?
10:32:57 <scooty-puff> it tell's to a list, while ask returns the array created from that list
10:33:09 <scooty-puff> all stacked on a lazy Get monad
10:35:34 <incluye> @pl \(a,b) -> a:b:[]
10:35:34 <lambdabot> uncurry ((. return) . (:))
10:38:05 <juliohm> Oh, Haskell is so beautiful.
10:38:08 <scooty-puff> or maybe its too lazy - getting stack space overflows - newly read values depend on the ask'ed Array
10:38:21 <scooty-puff> which contains those newly read values, because they are tell'd
10:44:02 <byorgey> juliohm: =)
10:44:44 <byorgey> scooty-puff: I don't see how the array method could be lazy
10:45:25 <byorgey> scooty-puff: what would that even mean?
10:45:37 <juliohm> What i liked in Haskell is the Math-like syntax. It's really readable to the eyes.
10:45:51 <byorgey> juliohm: I agree
10:46:39 <byorgey> juliohm: not only does it have math-like syntax, it also has math-like semantics, where names stand for values and you cannot "mutate" anything    From the point of view of algebraic geometry, fields are points, because the spectrum Spec F has only one point, corresponding to the 0-ideal. This entails that a commutative ring is a field if and only if it has no ideals except {0} and itself. Equivalently, an integral domain is field if and only if i
10:46:45 <byorgey>     Isomorphism extension theorem
10:46:56 <byorgey> whoops, sorry for the accidental paste
10:47:18 <byorgey> stop reading when you get to "From the point of view" =)
10:48:37 <juliohm> byorgey, what a Spec means, anyway. :-)
10:48:52 <juliohm> Spectrum of a a Field.
10:48:52 <parcs> > let x = 2 - x in x
10:48:56 <lambdabot>   mueval-core: Time limit exceeded
10:52:46 * juliohm never studied commutative algebra before, just Algebra.
10:54:37 <scooty-puff> is there a good reason this doesn't work?
10:54:37 <scooty-puff> rec (a, s) <- runReaderT (runWriterT m) (array (1, sum' s) s)
10:54:54 <scooty-puff> sum' = foldl' (\a b -> a + fst b) 1
10:55:00 <scooty-puff> its not <<loop>>'ing
10:55:03 <scooty-puff> its stack overflowing
10:55:26 <scooty-puff> is (!) strict?
10:58:37 <monochrom> as in, "is b!i strict in b and i?" yes
10:59:03 <benmachine> although arrays can be lazy in their elements iirc
10:59:27 <dafis> yes, but the thunks have to be written on construction
10:59:48 <monochrom> but since b (an array) is a rich data structure, "strict in b" is ambiguous. b!i is shallowly strict in b if b is an ordinary array (as opposed to unboxed array)
11:01:07 <benmachine> wait, s :: (Num (i,e), Ix i) => [(i,e)]?
11:01:15 <benmachine> oh no wait
11:01:33 <benmachine> s :: (Num i, Ix i) => [(i,e)]
11:01:36 <benmachine> because of the fst
11:02:02 <ksk_> I keep listening String is dead slow . Should I avoid it at all costs or are they slow for just some operations?
11:02:17 <monochrom> not at all costs
11:02:41 <ksk_> when then?
11:02:54 <benmachine> when you need things to be fast?
11:02:55 <dafis> ksk_: when you deal with huge Strings
11:03:02 <monochrom> when your program is slow
11:03:32 <benmachine> if you're having problems with performance and you're using string IO, that'll be one of the first things you'll want to change, but if you're not having problems with performance then don't worry about it
11:03:40 <ksk_> but if my program is going to be slow, shoud not i design it for speed from the beguinning?
11:03:46 <benmachine> not always
11:03:50 <benmachine> sometimes speed is irrelevant
11:04:10 <dylukes> ksk_: That's called premature optimization.
11:04:17 <dylukes> It's commonly referred to as an evil of the highest degree.
11:04:28 <dylukes> Thankfully, in a language like Haskell, refactoring is very easy.
11:04:41 <dylukes> So just write code that works, and then optimize later after profiling.
11:04:46 <benmachine> dylukes: I dunno, it's not premature if you know it's going to be an issue
11:04:55 <dylukes> benmachine: Sure...
11:04:57 <benmachine> and quite often you do know that
11:04:57 <tkahn6> does anyone know of a function of the signature: Int -> [a] -> [[a]] ? I'm looking for it to split a list every N elements
11:04:58 <dafis> benmachine++
11:05:08 <monochrom> design for speed is fine, but first you need an accurate theory of program speed so you can predict correctly. do you have such a theory already? no. so stop guessing.
11:05:10 <ksk_> what i'm doing is website, and there people can edit texts
11:05:14 <dylukes> @hoogle Num a => a -> [b] -> [[b]]
11:05:14 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
11:05:14 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
11:05:14 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
11:05:23 <dylukes> @hoogle Int -> [a] -> [[a]]
11:05:24 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
11:05:24 <lambdabot> Prelude drop :: Int -> [a] -> [a]
11:05:24 <lambdabot> Prelude take :: Int -> [a] -> [a]
11:05:32 <dylukes> @hoogle split
11:05:32 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
11:05:32 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
11:05:32 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
11:05:34 <dafis> tkahn6: look at the split package, it has that under a few names, iirc
11:05:50 <dylukes> @hackage split
11:05:50 <lambdabot> http://hackage.haskell.org/package/split
11:05:50 <tkahn6> dafis: i'll do that
11:05:54 <benmachine> tkahn6: there are also some clever things you can do with splitAt and unfoldr
11:06:20 <dylukes> tkahn6: splitEvery looks like what you're looking for.
11:06:28 <tkahn6> dylukes: yep! thanks
11:06:34 <tkahn6> thanks for your help guys
11:07:55 <monochrom> I wouldn't be saying all these if programming with String were harder than programming with bytestring or text, actually.
11:09:03 <benmachine> :t \n -> unfoldr (ap (<$) (guard . not . null . fst) . splitAt n)
11:09:03 <lambdabot> forall a. Int -> [a] -> [[a]]
11:09:24 <benmachine> > unfoldr (ap (<$) (guard . not . null . fst) . splitAt n) 3 [1 .. 20]
11:09:25 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:09:25 <lambdabot>         against inferred type ...
11:09:31 <benmachine> oh drat it
11:09:40 <benmachine> > (\n -> unfoldr (ap (<$) (guard . not . null . fst) . splitAt n)) 3 [1 .. 20]
11:09:42 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
11:10:01 <benmachine> pointfree 4eva
11:10:50 <copumpkin> @pl (\n -> unfoldr (ap (<$) (guard . not . null . fst) . splitAt n))
11:10:50 <lambdabot> unfoldr . (ap (<$) (guard . not . null . fst) .) . splitAt
11:10:53 <copumpkin> duh
11:11:37 <dafis> @pl \f x -> f x
11:11:37 <lambdabot> id
11:14:13 <benmachine> copumpkin: heh, I'm not a fan of composing sections of composition
11:14:51 <benmachine> also, I reckon ap (<$) (guard . p) should have a name
11:15:04 <benmachine> @type ap (<$) (guard . ?p)
11:15:05 <lambdabot> forall a (f :: * -> *). (Functor f, MonadPlus f, ?p::a -> Bool) => a -> f a
11:15:37 <benmachine> @type \p -> ap (liftM . const) (guard . p) -- perhaps
11:15:38 <lambdabot> forall r (m :: * -> *). (MonadPlus m) => (r -> Bool) -> r -> m r
11:18:35 <tkahn6> anyone have any experience converting between Word types? like i'm looking for something with the signature Word8 -> Word8 -> Word16
11:18:44 <Cale> Shit, now I have followers on Twitter. I'll have to delete my account :P
11:20:16 <kadoban> just spam them until they beg for mercy :/
11:21:50 <monochrom> slowly teach them haskell via your tweets
11:21:55 <dylukes> monochrom: ^
11:22:01 <kamatsu> Okay, so, I have a GHC API question
11:22:07 <dylukes> whats your twitter Cale?
11:22:10 <kamatsu> looking at the haddock is quite daunting
11:22:15 <Cale> dylukes: It's gone, I just deleted it.
11:22:20 <kamatsu> I just want to get a Haskell AST post typechecker.
11:22:20 <dylukes> lol
11:22:20 <monochrom> boo
11:22:26 <copumpkin> failcale
11:22:35 <kamatsu> starting with a collection of hs filenames
11:22:37 <kamatsu> what do I do?
11:22:43 <monochrom> then use google+ instead :)
11:22:47 <Cale> tkahn6: shiftL 8 (fromIntegral x) .|. fromIntegral y
11:23:03 <Cale> I have a Google+ account, but I don't understand Google+
11:23:11 <tkahn6> Cale:  thanks i'll try that
11:23:17 <Cale> I haven't been bothered to work out what the fuck circles are.
11:23:20 <kamatsu> Cale, it's long-post twitter with friend lists
11:23:57 <kamatsu> so you can post to specific circles, and filter your feed to only include specific circles
11:23:59 <kamatsu> that's about it
11:24:01 <Rc43> Hi, guyz.
11:24:25 <Rc43> How should I implement fromInteger for tuple and why I should do it?
11:24:40 <Rc43> (I want to use tuples like a summable points.)
11:24:53 <Rc43> (E.g. (x,y) + (a,b) = (x+a,y+b))
11:24:54 <kamatsu> so you're making tuples instance of num?
11:25:01 <Rc43> kamatsu, yes
11:25:12 <Cale> Rc43: You should make fromInteger n = (n,n)
11:25:24 <Cale> So that 0 = (0,0) and 1 = (1,1)
11:25:39 <Cale> and then 0 will still be the additive unit and 1 will still be the multiplicative unit
11:25:41 <Rc43> kamatzu, Cale, thanks, but why I need this function for Num?
11:25:50 <Rc43> A
11:26:00 <kamatsu> Numbers refers to numeric types
11:26:01 <Cale> Think of it as a shorthand way of defining the units for (+) and (*)
11:26:04 <Rc43> ok, so it is necessary for forming monoid ?
11:26:04 <kamatsu> points aren't actually numbers
11:26:13 <kamatsu> no
11:26:26 <Cale> Sure they are. If R is any ring, then so is R x R
11:26:28 <simon> is there a built-in type for 'state transformers'? (type ST a = State -> (a, State))
11:26:29 <kamatsu> monoid is just an operation and an identity, as far as i remember
11:26:45 <Cale> Well, for forming two monoids :)
11:26:48 <kamatsu> Cale, "fromInteger" suggests the more mundane numbers
11:26:58 <Rc43> kamatsu, I mean ring or smthng with two operations
11:27:42 <kamatsu> is there any reason why you want points to be an instance of Num?
11:28:06 <Cale> Every ring R has a natural map Z -> R from the integers, which sends the integer 1 to the multiplicative unit of the ring (and is determined from there by the requirement that it's a ring homomorphism)
11:28:08 <Rc43> kamatsu, I have points and "ways", so point + way is a new paint
11:28:29 <Rc43> btw, it would be better if it were paths or something
11:28:48 <Cale> So, the crucial property that fromInteger has is that fromInteger (n+m) = fromInteger n + fromInteger m, and that fromInteger (n*m) = fromInteger n * fromInteger m
11:28:51 <copumpkin> there exist five three-dimensional algebras over fields, apparently
11:29:02 <monochrom> a circle is a set of people. no restriction on relating circles with people (e.g., no one-to-many restriction). for every circle c, for every person p in c, for every post q of p, q shows up on your google+ portal if p allows you to read q. when you post, you select who can read it; for convenience, you can make it public, or pick a whole circle with one click, or pick persons individual, or many combinations of the above.
11:29:05 <Cale> and that fromInteger 1 * x = x for all x.
11:29:30 <Rc43> Cale, there is a homomorphism between Z and any ring?
11:29:34 <hello_haskell> hello all
11:29:36 <Cale> Rc43: yes
11:29:41 <kamatsu> it was just explained
11:29:48 <Cale> Rc43: and fromInteger is meant to be that homomorphism
11:29:48 <hello_haskell> i just download ghc-7.2.1
11:29:55 <byorgey> hello hello_haskell
11:29:58 <Rc43> Cale, cool, didn't know, thanks
11:30:05 <Cale> (In the cases where your Num instance is anything like a ring, anyway :P)
11:30:20 <monochrom> there are other social-networking-effecting things like when I look at your google+ profile, I can see the union of all of your circles, but I do not see how you divide them.
11:30:30 <Cale> monochrom: okay
11:30:58 <hello_haskell> and installed it Ubuntu 10.10
11:31:05 <monochrom> if you add p to one or more of your circles, p knows that he/she is in one or more of your circles, but not which ones.
11:31:10 <byorgey> Rc43: note that Num does also contain some extra cruft beyond just rings (abs, signum) but they are often considered a wart
11:31:10 <hello_haskell> when i am trying to run ghc
11:31:28 <byorgey> Rc43: if you ignore those methods in your Num instance no one will complain
11:32:11 <hpaste_> Arvind pasted ‚Äúerror in ghc installation in ubuntu‚Äù at http://hpaste.org/51472
11:32:37 <Rc43> byorgey, at first I had just + - in instance definition, but somehow it fails on max operation
11:32:52 <dafis> hello_haskell: have you a gmp installed?
11:33:06 <kamatsu> so, no GHC API experts available?
11:33:29 <byorgey> Rc43: max has nothing to do with Num, it is defined by the Ord instance
11:33:37 <Rc43> byorgey, may be it will be better to define Eq for tupple
11:34:02 <Rc43> byorgey, can ghc use Num definition for eq defining when there is no eq defining?
11:34:16 <byorgey> Rc43: no
11:34:22 <Rc43> byorgey, I mean I have no Eq for (x,y), but have Num
11:34:29 <Cale> Also note that there are some Num instances which aren't rings.
11:34:33 <Cale> Like Float and Double
11:34:40 <byorgey> Rc43: there is already a built-in Eq instance for tuples
11:34:55 <byorgey> Cale: good point
11:35:01 <Cale> But they're trying their best to be rings, so we let them in even if they're a bit derpy.
11:35:18 <dafis> derpy?
11:35:18 <byorgey> hehehe
11:35:22 <Cale> But for that reason, I like the name Num better than Ring
11:35:23 <byorgey> you heard him.
11:35:32 <Cale> Because it doesn't imply anything.
11:35:36 <hello_haskell> dafis: locate gmp shows /usr/include/linux/igmp.h /usr/include/netinet/igmp.h /usr/lib/libgmp.so.3 /usr/lib/libgmp.so.3.5.2
11:35:54 <byorgey> in a future version of Haskell I think we ought to have a Ring class, and a Nummish class
11:35:56 <Rc43> Cale, byorhey, understood, thanks
11:36:03 <Rc43> Nummish?
11:36:12 <byorgey> yes, for things that are Num-ish
11:36:29 <dafis> hello_haskell: I think you need to symlink one of the libgmp.so.3* to libgmp.so
11:36:30 <Cale> heh, I think we should have Additive and Multiplicative
11:36:37 <Cale> and make Num from those
11:36:40 <byorgey> Cale: well, those too, of course
11:36:53 <Cale> Once you guys have your kind fanciness implemented :)
11:37:15 <Cale> and then separate off abs and signum
11:37:25 <Cale> and drop the Show/Eq requirement
11:37:34 <Cale> and it'll be fine :)
11:37:59 <byorgey> Cale: how will kind fanciness help?
11:38:24 <Cale> Well, it subsumes class aliases, yeah?
11:38:43 <byorgey> oh, you mean ConstraintKinds?
11:38:46 <Cale> yeah
11:38:55 <byorgey> that's already implemented and in HEAD
11:38:57 <Cale> yes
11:39:09 <hello_haskell> dafis: could you please tell me how to create that link ?
11:39:09 <byorgey> yep, it does subsume class aliases
11:39:10 <Cale> (Oh, it's 100% complete?)
11:39:13 <byorgey> I didn't work on it though
11:39:17 <byorgey> Cale: yes!
11:39:21 <Cale> ah, sorry, I thought you had
11:39:26 <Cale> for some reason
11:39:33 <byorgey> I am working on *other* sorts of kind fanciness =)
11:39:43 <Cale> ah, that's probably it. What are you doing?
11:40:02 <dafis> hello_haskell: better read the man page, man ln
11:40:11 <dolio> Better type programming, no?
11:40:18 <hello_haskell> dafis: thank you
11:40:20 <byorgey> Cale: lifting of types to the kind level, and kind polymorphism
11:40:25 <Cale> ah, okay
11:40:26 <byorgey> http://hackage.haskell.org/trac/ghc/wiki/GhcKinds
11:40:44 <byorgey> dolio: right, that's the goal
11:40:49 <Cale> Somehow I must have lumped those two proposals together in my head.
11:41:05 <byorgey> they do play well together
11:41:13 <Cale> rofl, database is locked
11:41:27 <byorgey> doh
11:41:40 <Cale> Bugs in the bug tracker.
11:41:50 <yitz> byorgey: so once fancier kinds gives us better type-level programming, i suppose we'll start wondering about how to achieve better kind-level programming.
11:41:52 <byorgey> for example, ConstraintKinds + kind polymorphism means we can treat (~) as just a normal type constructor with kind  forall k. k -> k -> Constraint =)
11:42:07 <dolio> So, with constraint kinds, can I write 'type Num a = (Ring a, Eq a, Show a)'?
11:42:14 <byorgey> dolio: yes
11:42:15 <dolio> Or does it have to be a type family with a single instance?
11:42:53 <Cale> yitz: We'll slowly claw our way toward Tim Sheard's language.
11:42:55 <byorgey> yitz: indeed.  that's the point at which we'll collapse things to create a dependent kind system, so you get all the levels at once
11:43:08 <byorgey> but we don't quite know how to do it yet.
11:43:19 <dolio> Cale: Except, with a fast implementation. :)
11:43:24 <byorgey> =)
11:47:58 <Rc43> yep
11:48:09 <Rc43> I have solved 11 problem on project euler :D
11:48:35 <dafis> which one was that?
11:50:57 <Rc43> to find max product of 4 numbers in line  http://projecteuler.net/index.php?section=problems&id=11
11:51:20 <edwardk> copumpkin: i think you should name the combinator for your thunk inspection code ‡≤†_‡≤†
11:51:38 <copumpkin> lol
11:51:45 <jmcarthur> kind polymorphism. mmm.
11:51:49 <edwardk> > let ‡≤†_‡≤† = 12 in ‡≤†_‡≤†
11:51:50 <lambdabot>   12
11:51:53 <edwardk> its legal ;)
11:52:14 <monochrom> \‚à©/
11:52:19 <monochrom> edwardk++
11:52:53 <monochrom> there is also the cyrillic many-eyes letter if you feel like it :)
11:53:39 <monochrom> that may be suitable for a later version of multi-threaded thunk inspector
11:58:06 <edwardk> i can almost get (‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ ‚îª‚îÅ‚îª  to type check, but i need to swap out the Ô∏µ and put something on the right
11:58:14 <tkahn6> lol
11:58:33 <Nimatek> Haha.
11:58:36 <tkahn6> this might be a dumb question but is there anything like apply in haskell?
11:58:46 <edwardk> :t ($)
11:58:47 <lambdabot> forall a b. (a -> b) -> a -> b
11:59:24 <hpc> f $ x = f x
11:59:27 <tkahn6> i mean like if i have: a -> a -> b and [a]
12:00:02 <hpc> no, that's not possible
12:00:12 <tkahn6> hpc: thanks
12:00:12 <dafis> :t foldr1
12:00:13 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
12:00:13 <hpc> suppose the [a]
12:00:17 <hpc> suppose the [a] is an infinite list
12:00:28 <hpc> the function you are applying must have an infinite type
12:00:56 <tkahn6> yeah right i see the issues. i was just wondering if someone smarter than me had resolved them or something :)
12:01:07 <monochrom> don't you have a->b and [a] instead?
12:01:14 <monochrom> @type map
12:01:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:01:30 <hpc> in lisp, (apply f a b '(c d e)) => (f a b c d e)
12:01:38 <monochrom> eww, no wonder
12:01:54 <edwardk> > let („ÉÑ) = error "too happy" in („ÉÑ)
12:01:55 <lambdabot>   *Exception: too happy
12:01:56 <hpc> tkahn6: you might be interested in curry
12:02:01 <Peaker> hpc: surely that's just in the tasteless CL, and not in the somewhat elegant Racket variants...
12:02:02 <hpc> curry f (a, b) = f a b
12:02:13 <hpc> > curry (+) (1, 2)
12:02:14 <lambdabot>   Overlapping instances for GHC.Show.Show
12:02:14 <lambdabot>                              (b -> ...
12:02:26 <tkahn6> hpc: yeah i'm familiar with curry that could be useful
12:02:26 <hpc> > uncurry (+) (1, 2) -- get the two confused
12:02:27 <lambdabot>   3
12:02:28 <dafis> uncurry
12:02:43 <tkahn6> yeah uncurry
12:02:45 <tkahn6> heh
12:03:09 <Guest92470> [Casd
12:07:58 <edwardk> > let  ò_ ò = error "pupils dilated" in  ò_ ò
12:07:59 <lambdabot>   *Exception: pupils dilated
12:09:07 <ben> So if I have a program that sits in a blocking loop reading from a socket, what's the easiest way to add functionality to exit when I type a 'q' into stdin or something?
12:09:19 <benmachine> ben: threads!
12:09:25 <benmachine> yaaay
12:09:28 <ben> Yay
12:09:43 <JoeyA> Just wondering, if I invoke the select() system call (using foreign import ccall safe), can the RTS preempt it?
12:09:51 <benmachine> you can have something like an MVar (Maybe Data), then read that instead of the socket
12:09:52 <JoeyA> (assuming the program is linked with the -threaded option)
12:10:08 <benmachine> then you have two threads, one of which does getSocket >>= putMVar datavar . Just
12:10:09 <ben> Who's gonna write to the mvar?
12:10:13 <hpc> JoeyA: why would you use select() instead of existing threading mechanisms?
12:10:13 <ben> ah
12:10:30 <JoeyA> hpc: threadWaitRead only checks a single socket.
12:10:32 <benmachine> and the other does getStdinOrSomething >> putMVar datavar Nothing
12:10:50 <ben> How do I tell the threads reading from stdin or the socket that the respective other thread has exited?
12:11:13 <benmachine> umm
12:11:33 <benmachine> you throw exceptions at them, or use a thread library that does it for you
12:11:39 <ben> Cripes, that sounds evil.
12:11:45 <benmachine> it's not too bad
12:12:05 <benmachine> if the respective other thread is the main thread then you don't need to tell them, of course
12:12:12 <benmachine> they just die anyway
12:12:22 <benmachine> oh wait no
12:12:24 <benmachine> I see what you mean
12:13:02 <ben> I have asked a similar, less specific question before and have heard that killing threads with aysnchronous exceptions from other threads is usually a bad idea.
12:13:02 <benmachine> http://hackage.haskell.org/package/threads this package makes it easy to group threads and kill them all at once
12:13:38 <benmachine> well, there are more mundane ways to signal the threads as well
12:13:53 <benmachine> but if you want to interrupt them reading the socekt or stdin or whatever, async exceptions are the thing to do I reckon
12:13:57 <benmachine> *socket
12:14:05 <edwardk> > let (~.^) = "wink" in (~.^)
12:14:05 <edwardk> wonder what other random emoticons work
12:14:06 <lambdabot>   "wink"
12:14:17 <ben> I think my core problem is that I always want to set a thread up so it blocks on a thing that can either feed it data or tell it to exit or something
12:14:28 <ben> and then I can't figure out how to implement that without using more threads that will suffer from the same problem
12:14:33 <benmachine> heh
12:14:35 <parcs> > let (^_^) = "happey" in (^_^)
12:14:36 <lambdabot>   <no location info>: parse error on input `)'
12:14:49 <dylukes> Sounds like a job for Coroutines.
12:14:52 <benmachine> parcs: _ is not a symbol character unfortunately
12:14:52 <parcs> oh, well ^.^ then
12:14:59 <parcs> > let (^.^) = "happey" in (^.^)
12:14:59 <lambdabot>   "happey"
12:15:27 <benmachine> ben: do not fear async exceptions, if you use them wisely
12:15:43 <benmachine> and you may need more threads than you think but with enough it *will* work
12:15:59 <ben> It just seems it would be so much easier if there was a function that took a number of handles and told me which on was ready to be read from.
12:16:33 <benmachine> you want me to write that function? :P
12:16:58 <ben> Well, sure
12:17:10 <parcs> 'threads' seems neat
12:17:15 <benmachine> parcs: it is
12:17:22 <ben> (I don't feel like "wait until either of these is ready, then react to that" is an inherently concurrent thing to do)
12:17:37 <benmachine> ben: why shouldn't it be?
12:17:39 <edwardk> > let ‡≤† = id; (‚Äø) = id in ‡≤†‚Äø‡≤† "hi there!"
12:17:40 <lambdabot>   "hi there!"
12:18:05 <ben> benmachine: Because it's not like there's multiple things that need to happen at the same time.
12:18:16 <benmachine> ben: depends what you think of as a thing
12:18:33 <benmachine> if waiting for a thing is a thing, then you need to wait for multiple things at the same time
12:18:39 <ben> Well, it also seems like it would not be a big deal for the rts to give me such a function without requiring more threads
12:18:52 <ben> but I probably have misconceptions of how the rts does its things.
12:19:08 <benmachine> well, threads end up being select calls anyway
12:19:11 <benmachine> or epoll or whatever
12:19:15 <ben> Yeah, that's what I mean
12:19:37 <benmachine> the lesson is that requiring more threads isn't inherently a terrible thing
12:19:43 <ben> Just exposing that back to me in some integrated-with-all-the-other-epolls way seems straightforwad :(
12:19:46 <ben> forward*
12:20:29 <JoeyA> My question is answered here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#v:forkOS
12:20:32 <ben> I dunno. Maybe I'm afraid of keeping them under control, or not terminating them properly, or accidentally reading from some socket and then losing data because the rest of the threads already went ahead.
12:20:43 <JoeyA> "It is a common misconception that you need to use forkOS instead of forkIO to avoid blocking all the Haskell threads when making a foreign call; this isn't the case."
12:21:05 <dfjklaaf>   ["GHC 7.2 and cabal-install: http://is.gd/LXRBhh (all archs not just mac)", "Paste code/errors: http://h
12:21:08 <dfjklaaf> 22:12 -!- Palmik [~palmik@man-208-80.pks.muni.cz] has quit [Remote host closed the connection]
12:21:11 <dfjklaaf> 22:13 < benmachine> you want me to write that function? :P
12:21:13 <dfjklaaf> 22:13 -!- hiptobecubic [~john@unaffiliated/hiptobecubic] has joined #haskell
12:21:16 <dfjklaaf> 22:13 -!- SeroPositief [~SeroPosit@h44083.upc-h.chello.nl] has quit [Quit: IRQL_LESS_OR_EQUAL]
12:21:19 <dfjklaaf> 22:13 -!- colbseton` [~colbseton@AClermont-Ferrand-551-1-135-156.w92-157.abo.wanadoo.fr] has quit [Read
12:21:20 <ben> oh dear
12:21:22 <dfjklaaf>           error: Connection reset by peer]
12:21:24 <dfjklaaf> 22:13 < ben> Well, sure
12:21:27 <dfjklaaf> 22:13 < parcs> 'threads' seems neat
12:21:28 --- mode: ChanServ set +o Saizan
12:21:29 <dfjklaaf> 22:13 < benmachine> parcs: it is
12:21:31 <benmachine> ben: remind me, where's threadWaitRead, and is that what you want?
12:21:32 <dfjklaaf> 22:14 -!- colbseton` [~colbseton@AClermont-Ferrand-551-1-135-156.w92-157.abo.wanadoo.fr] has joined
12:21:35 <dfjklaaf>           #haskell
12:21:37 <dfjklaaf> 22:14 < ben> (I don't feel like "wait until either of these is ready, then react to that" is an
12:21:39 --- mode: Saizan set +b *!*paulh@*.onsnetstudenten.nl
12:21:48 <JoeyA> whoops
12:22:09 <benmachine> whatever, I'll just parametrise over it :P
12:22:17 <ben> benmachine: Well, I figure it would be more like [(Handle, IO a)] -> IO a
12:22:50 <benmachine> ben: ah, so whenever a handle becomes ready, the corresponding IO a is executed
12:22:52 <SonicvanaJr> What's the best way to get a certain value of a data type out of a list of that data type.
12:23:19 <ben> benmachine: well, I figured only the first, and then the function would return
12:23:20 <SonicvanaJr> like if data Z = A | B and I have a list with A's and B's, but I just like the list of A's
12:23:26 <ben> not 'whenever' meaning it'll loop or anything
12:23:31 <benmachine> ben: right, hmm
12:23:38 <JoeyA> > filter isJust [Just 5, Just 3, Nothing, Nothing, Just 17]
12:23:39 <lambdabot>   [Just 5,Just 3,Just 17]
12:24:09 <ben> I suppose this would work with a thread for each handle that blocks on threadWaitRead and sends back something through an MVar, and the main thread would block on that mvar and then kill all the threads
12:24:14 <hpc> @src catMaybes
12:24:14 <lambdabot> catMaybes ls = [x | Just x <- ls]
12:24:20 <JoeyA> > filter (\x -> case x of {Just _ -> True; _ -> False})  [Just 5, Just 3, Nothing, Nothing, Just 17]
12:24:20 <lambdabot>   [Just 5,Just 3,Just 17]
12:24:30 <ben> but I'm still stuck in my C++ mindset of asynchronously killing things being evil
12:24:31 <Eduard_Munteanu> :t lefts
12:24:32 <lambdabot> forall a b. [Either a b] -> [a]
12:24:37 <JoeyA> In the future, you will be able to write it even shorter:
12:24:42 <JoeyA> > filter (case of {Just _ -> True; _ -> False})  [Just 5, Just 3, Nothing, Nothing, Just 17]
12:24:43 <lambdabot>   <no location info>: parse error on input `of'
12:24:53 <benmachine> ben: heh. async exceptions *can* be unpleasant, but if you use them wisely they're fine
12:24:56 <Eduard_Munteanu> :t rights
12:24:57 <lambdabot> forall a b. [Either a b] -> [b]
12:25:11 <hpc> :t rights &&& lefts
12:25:12 <lambdabot> forall a b. [Either a b] -> ([b], [a])
12:25:18 <hpc> have fun with that one :P
12:25:21 <ben> Also, cripes, I can deal with threads being cheap relative to real OS threads but surely all their bookkeeping overhead is still orders of magnitude worse than if I were using epoll directly
12:25:28 <SonicvanaJr> thanks
12:25:32 <ben> Not that in my case of n = 2, it's really a big deal
12:25:33 <JoeyA> http://hackage.haskell.org/trac/ghc/ticket/4359
12:25:48 <benmachine> ben: haskell can effectively manage literally millions of threads, iirc
12:25:52 * hackagebot HaskellForMaths 0.4.0 - Combinatorics, group theory, commutative algebra, non-commutative algebra  http://hackage.haskell.org/package/HaskellForMaths-0.4.0 (DavidAmos)
12:25:52 <benmachine> uh, by haskell I mean GHC
12:26:28 <dylukes> ben: look at the cost of C native threads (i.e pthreads),
12:26:34 <dylukes> and then look at haskell or erlang threads.
12:26:43 <dylukes> well, haskell threads, erlang processes.
12:26:53 <ben> How do I quantify the cost of haskell threads anyway?
12:27:20 <benmachine> ben: what do you mean?
12:27:32 <ben> I figured I was looking at the size of some bookkeeping data structure and some N deep inside of a O(log N) algorithm getting slightly larger
12:27:43 <ben> what is there to making a new thread? :3
12:28:07 <benmachine> ben: that I don't know, just that it's very small :P
12:29:22 <edwardk> @hpaste
12:29:22 <lambdabot> Haskell pastebin: http://hpaste.org/
12:30:29 <hpaste_> edwardk pasted ‚ÄúA play in one act‚Äù at http://hpaste.org/51474
12:30:42 <edwardk> it even typechecks
12:31:18 <kadoban> haha, that's cute
12:31:20 <benmachine> is the result some large number of "ow!"?
12:31:26 <edwardk> yeah =)
12:31:28 <Reaganomicon> Dear #haskell, the y combinator is crushing my puny non-mathematician mind. How the fuck does this arcane artifact of the elder gods work?
12:31:52 <edwardk> the dude got a table flipped on him, so of course it is
12:32:04 <benmachine> Reaganomicon: tell us what you know so far
12:32:32 <JoeyA> > fix (\msg -> "The Y combinator works because " ++ msg)
12:32:33 <lambdabot>   "The Y combinator works because The Y combinator works because The Y combin...
12:32:46 <Reaganomicon> Regarding l-calc, nothing. I just enountered the y combinator out of nowhere and can't understand how it works.
12:32:51 <ben> benmachine: Is there a handle version of threadWaitRead? Or should I extract the Fd from the handle?
12:33:07 <benmachine> ben: hmmm
12:33:14 <benmachine> there is a handleToFd somewhere
12:33:24 <JoeyA> Reaganomicon: Do you understand what it does?
12:33:33 <ben> It's in the unix package, so I'm scared of it
12:33:35 <Reaganomicon> JoeyA: no, no, that's the problem.
12:33:50 <Reaganomicon> I can see code use it. I can see the input, the intention and the output.
12:33:55 <Reaganomicon> The combinator itself is magic.
12:33:57 <JoeyA> In essence, the fixpoint combinator provides an expression with its own return value.
12:33:58 <ben> Oh, threadWaitRead is ghc only anyway.
12:33:59 <ben> hmm.
12:34:13 <ben> there's probably a handle variant somewhere in system.io itself
12:34:14 <JoeyA> The fixpoint combinator does not make sense... in a strict setting.
12:34:35 <benmachine> Reaganomicon: http://www.vex.net/~trebla/haskell/fix.xhtml this might help
12:34:38 <ben> hWaitForInput sounds about right
12:35:05 <monochrom> thank you for choosing monochrom! :)
12:35:07 <JoeyA> In the example I posted above, the program doesn't go into an infinite loop because it doesn't need to evaluate msg right away.
12:35:22 <benmachine> monochrom: thank you for being... choosable?
12:35:27 <monochrom> haha
12:35:42 <ben> haskell is my favourite imperative language
12:35:44 <Reaganomicon> benmachine: that seems to be comprehensible, cheers!
12:35:46 <JoeyA> The expression inside returns a head normal form: "The Y combinator works because" ++ <thunk>
12:35:55 <monochrom> there is no magic in fix. it's just plain haskell.
12:36:04 <JoeyA> fix f = f (fix f)
12:36:05 <Reaganomicon> JoeyA: I saw the ycomb in a strict language, OCaml.
12:36:09 <Reaganomicon> And it blew my mind :|
12:36:21 <monochrom> unless you find plain haskell recursion is magic too, then I'm wordless
12:36:47 <Eduard_Munteanu> You can type Z in OCaml? :/
12:36:56 <Reaganomicon> Recursion is fun, I just seize up on the ycomb
12:37:00 <Eduard_Munteanu> (plain Z, not a wrapping)
12:37:05 <JoeyA> It probably uses a variant that avoids the problem a pure fixpoint combinator has, e.g. by requiring it to be a function.
12:37:13 <monochrom> the for-strict-languages version is not called Y. it is called Z or something.
12:37:31 <Reaganomicon> JoeyA: Yes, that's the example on wikipedia. Apparently rectypes bypasses that restriction.
12:37:41 <Eduard_Munteanu> Z, yeah.
12:37:56 <JoeyA> If I'm not mistaken, Y strictly refers to \f (\x f (x x)) (\x f (x x)), which is a specific fixpoint combinator.
12:38:09 <monochrom> yes, Y refers to that one, no one else
12:38:35 <Reaganomicon> I guess I'm wrong in using Y comb to refer to fixpoint combs in general.
12:39:21 <JoeyA> You could implement a fixpoint combinator in JavaScript by making the thunk explicit.
12:39:23 <monochrom> use the words "fixed point combinator" to refer to the whole class of these things
12:40:01 <JoeyA> e.g. fix(function(x) {print("the fixpoint combinator works because "); x(); });
12:40:18 <JoeyA> Of course, you'll get a stack overflow pretty quickly.
12:40:18 <hpaste_> benmachine pasted ‚Äúselect‚Äù at http://hpaste.org/51475
12:40:26 <benmachine> ben: ^ that's the sort of thing I'd do
12:40:33 <parcs> is there an api for hpaste?
12:41:13 <monochrom> I believe there isn't yet, but once you mention it to chrisdone, he'll happily add one
12:41:18 <ben> oh that's fairly generic
12:41:28 <benmachine> ben: that's the idea :P
12:41:49 <benmachine> but notice I'm putting IO actions into an MVar because they're lovely and first-class like that
12:41:58 <ben> Yeah, I was gonna do that too
12:42:08 <ben> lemme finish writing my thing up
12:42:11 <benmachine> :)
12:42:43 <benmachine> (I didn't end up using the threads library in the end; seems like you can't easily kill a whole group, only wait for it)
12:43:26 <Ptival> > lex "A B C D"
12:43:27 <lambdabot>   [("A"," B C D")]
12:43:32 <ben> I got a bit stuck on io errors
12:43:51 <Ptival> @hoogle lex
12:43:52 <lambdabot> Prelude lex :: ReadS String
12:43:52 <lambdabot> Text.Read lex :: ReadS String
12:43:52 <lambdabot> Text.Read.Lex lex :: ReadP Lexeme
12:43:55 <joeyh> trying to build some code with ghc 6.12, and it fails, seems it cannot derive an instance of Applicative for a newtype of StateT. Help?
12:43:58 <parcs> :t state
12:43:59 <lambdabot> forall s a. (s -> (a, s)) -> State s a
12:44:00 <Ptival> where is lex!?
12:44:02 <parcs> :t state lex
12:44:03 <lambdabot>     Couldn't match expected type `(a, String)'
12:44:03 <lambdabot>            against inferred type `[(String, String)]'
12:44:03 <lambdabot>     In the first argument of `state', namely `lex'
12:44:20 <JoeyA> It's defined in the Prelude.
12:44:22 <parcs> :t state (head . lex)
12:44:22 <lambdabot> State String String
12:44:37 <Ptival> > :t lex
12:44:38 <lambdabot>   <no location info>: parse error on input `:'
12:44:42 <Ptival> @type lex
12:44:43 <lambdabot> String -> [(String, String)]
12:44:45 <Ptival> this one ^
12:45:05 <Ptival> oh is ReadS just this?
12:45:19 <monochrom> I love first-class IO values too. for STM work, I sometimes suggest: join (atomically ((readTChan c1 >>= \x -> return (action1 x)) `orElse` (readTChan c2 >>= \y -> return (action2 y)))
12:45:20 <JoeyA> @i ReadS
12:45:20 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
12:45:26 <Ptival> @info ReadS
12:45:27 <lambdabot> ReadS
12:45:29 <JoeyA> :i ReadS
12:45:47 <benmachine> JoeyA: unfortunately that doesn't work
12:45:52 <JoeyA> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:ReadS
12:46:15 <benmachine> but yes, ReadS a = String -> [(a,String)]
12:46:37 <benmachine> (isomorphic to StateT String [] a)
12:47:35 <JoeyA> I wish I knew when to use the word "isomorphic".
12:48:04 <benmachine> JoeyA: a literal translation is "same shape" I think
12:48:33 <parcs> "essentially the same" :P
12:48:34 <JoeyA> Right.  What about a valid parse tree and valid text using the same syntax.  Could those be called isomorphic?
12:48:36 <benmachine> I use it for types A and B when there is a function f :: A -> B and g :: B -> A such that f . g = g . f = id
12:48:50 <elliott> "the same, sort of, if you ignore _|_s, oh and there's this pesky extra constructor, but nobody uses that"
12:48:53 <Ptival> when you can univoquely change one into the other and vice versa
12:49:07 <benmachine> elliott: there are no extra _|_s because StateT is a newtype
12:49:22 <elliott> benmachine: I was joking out of context.
12:49:35 <benmachine> elliott: sure, just clairfyin'
12:49:52 <monochrom> "data X = X1 Int | X2 Bool" and "data Y = Y1 Int | Y2 Bool" are isomorphic. you just relabel.
12:49:54 <benmachine> (f . g = g . f is really a bit of a cheat, because they have different types, but the point is that f and g are inverses)
12:50:04 <monochrom> (of course, X is isomorphic to X, too)
12:50:44 <monochrom> in general, every time you have to decide what's relevant and what's irrelevant, then you ignore the irrelevant, and you compare the relevant for equality
12:51:11 <benmachine> right; isomorphism may mean different things in different contexts
12:51:28 <benmachine> but "the same apart from in boring ways" is close enough :P
12:52:01 <JoeyA> What about a parse tree and its text?
12:52:10 <hpaste_> ben pasted ‚Äúselect‚Äù at http://hpaste.org/51476
12:52:20 <ben> benmachine: ^ I have no idea what I am doing, but it seems to work in the trivial case
12:53:37 <Saizan> ?type \f g -> (f Prelude.. g, g Prelude.. f) -- no cheat?
12:53:38 <lambdabot> forall b c. (b -> c) -> (c -> b) -> (c -> c, b -> b)
12:53:43 <monochrom> this is why {0, 1, 2, ... the natural numbers} and {0, 1, 2, ... the natural numbers, Infinity} are isomorphic if you just care about cardinality (bijection), but not isomorphic if you also care about order.
12:53:58 <Saizan> ah, i see where the cheat is
12:54:37 <benmachine> ben: I'd make the Right False case an 'error', since I can't see any way it would happen
12:54:40 <parcs> any way to do something like this purely: http://paste.pocoo.org/show/477655/
12:54:50 <benmachine> error "Waited an infinite amount of time, and handle still isn't ready"
12:54:58 <monochrom> how to decide relevant/irrelevant is equivalent to how to design an API
12:55:03 <ben> Ah
12:55:27 <ben> I figured it would be triggered on eof but apparently that's still something that makes hWaitForInput itself error
12:56:15 <Saizan> the decision can be expressed by choosing a category btw
12:56:16 <benmachine> ben: also, trivial things: the 'either' function may interest you, and you could write the case in 'fork' as putMVar mVar $ case result of ...
12:57:21 <benmachine> ben: furthermore, prefer throwIO to throw when possible
12:57:29 <hpc> :t throwIO
12:57:30 <lambdabot> Not in scope: `throwIO'
12:57:35 <benmachine> throwIO :: Exception e => e -> IO a
12:57:41 <ben> I couldn't find it in System.IO so I thought I misremembered and it didn't exist <:)
12:57:48 <benmachine> it's in Control.Exception
12:58:41 <ben> Did you mean plain error out of the whole function if hWaitForInput returns False?
12:58:58 <ben> I kind of wanted to somehow pass back which handle ended up failing, I dunno
13:00:25 <benmachine> ben: hWaitForInput should never return False, imo your function should reflect this
13:00:36 <luite> I have some code that uses MonadSupply, with an extra Generate class. http://hpaste.org/51477 , but now I want to restrict supplyTest to only accept SupplyRunners that consume the same number of supplies for both fields. how would you do that?
13:00:43 <ben> I'm afraid of making statements about what IO code should never do :v
13:01:08 <benmachine> ben: :P the point is that you as the programmer aren't expecting it to ever return false, so if it does you need to change the code
13:01:28 <ben> Did you suggest to use 'either' just in mySelectRead directly or also in fork? I don't see how to cleanly do it in the latter
13:01:41 <ben> I was just gonna pass on the problem of dealing with it to the user of the function.
13:02:02 <benmachine> just in mySelectRead directly
13:02:16 <benmachine> and, you shouldn't do that, imo, but admittedly this is a stylistic decision
13:02:41 <ben> Isn't it just an issue of which error I throw?
13:03:00 <benmachine> well, sure
13:03:14 <benmachine> but I like 'error' for assertion-failure type things
13:03:30 <ben> I'd want to pass it back to the original thread through the mvar in either case, no?
13:03:44 <benmachine> hmm, good point
13:03:47 <benmachine> it could be ignored otherwise
13:03:59 <ben> It might still get ignored if another thread was quicker
13:04:09 <benmachine> well yeah but there's nothing we can do about that :P
13:04:16 <ben> but if I blow up, say, the only child thread the whole thing might end up hanging
13:05:00 <benmachine> you could put an error call in the mvar?
13:05:18 <ben> That's fair I suppose
13:05:24 <ben> (though kind of treacherous!)
13:06:18 <benmachine> :P
13:06:23 <ben> Thanks for the advice!
13:06:27 <benmachine> np :)
13:07:37 <ben> is "if' a b c = if c then a else b" or something similar a standard function yet?
13:08:28 <hpc> ben: usually written (a ?? b) c, and no
13:08:38 <hpc> (well, is how i write it at least)
13:08:41 <benmachine> heh
13:08:44 <ben> Oh, that's neat
13:09:08 <benmachine> it can also be called 'bool'
13:09:21 <benmachine> I think there actually is an ifThenElse somewhere now
13:09:24 <benmachine> @hoogle ifThenElse
13:09:25 <lambdabot> No results found
13:09:27 <benmachine> oh hm
13:09:48 <benmachine> it's supported in rebindablesyntax but apparently no default is provided
13:15:55 <ben> forkIO $ try (hWaitForInput handle (-1)) >>= putMVar mVar . either Left (Right . (action ?? error "mySelectRead: hWaitForInput returned False")) <- this points-free thing quickly gets out of control, doesn't it
13:17:19 <mm_freak_> ben: what's (??)?
13:17:49 <ben> after hpc's suggestion, i made it \a b c -> if c then a else b
13:17:52 <benmachine> ben: psh, that's fine :P try fmap on the either, though
13:18:41 <mm_freak_> ben: if it works, it's almost fine‚Ä¶  just replace 'error' by throwIO
13:18:47 <mm_freak_> or map over the exception
13:19:07 <parcs> does ghc have mixfix support yet?
13:19:11 * benmachine thinks error is fine there :P
13:19:51 <ben> Where's the Functor instance for Either a from?
13:19:56 <mm_freak_> well, it might be, but if you want to pass errors to other threads, you should encode it as Either or Maybe, not as an error
13:20:02 <hpc> Control.Functor.Instances perhaps?
13:20:12 <mm_freak_> 'error' makes code unpredictable, when it gets more complicated
13:20:39 <ben> It's in Control.Monad.Instancs anyway
13:20:42 <mm_freak_> hpc: or Control.Monad.Instances
13:25:41 <hjulle> How is the type of "4" determined in the code "show 4"?
13:26:11 <hpc> hjulle: defaulting
13:26:31 <hpc> hjulle: it just decides 4 is an Integer
13:26:48 <hpc> you are running this in ghci yes?
13:26:53 <hjulle> How and where is that declared
13:26:56 <hjulle> Yes
13:27:40 <hpc> hjulle: honestly, all you need to know about defaulting is that it's there and can make show and number manipulation do stupid things
13:27:52 <hjulle> :P
13:27:58 <hpc> hjulle: and that you fix any bugs by putting a type signature on the offending term
13:28:06 <hjulle> thanks
13:29:09 <hjulle> Well, what I'm currently doing is trying to make haskell do stupid things. :P
13:30:52 * hackagebot TreeT 0.0 - Transformer for Data.Tree  http://hackage.haskell.org/package/TreeT-0.0 (RahulGopinath)
13:34:10 <hjulle> hpc: How can I see in the Prelude (or elsewhere) what is default?
13:34:38 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html -- assuming latest version of ghc
13:34:50 <hpc> it shouldn't be too different
13:34:57 <hpc> if at all
13:35:52 <JoeyA> How do you make two .hs files be able to depend on each other?
13:36:15 <hpc> JoeyA: close your eyes and say "there's no place like home"
13:36:42 <hpc> there's another way which i am having trouble finding
13:37:02 <kmc> JoeyA, you really really really shouldn't
13:37:20 <luqui> g'day
13:37:24 <kmc> but you can do it in GHC, with this hs-boot and "SOURCE" pragma stuff
13:37:26 <kmc> it's in the manual somewhere
13:37:28 <hpc> http://haskell.org/haskellwiki/Mutually_recursive_modules
13:37:31 <JoeyA> aight.  I may be able to work around it by putting my types and base stuff in a separate module.
13:37:36 <kmc> JoeyA, really, you ought to... yeah, that
13:49:44 <mm_freak_> JoeyA: having a separate module for types is a common style‚Ä¶  you should go with that one instead of boot files
13:50:03 <luqui> the necessity for boot files is embarrassing
13:50:10 <luqui> but on the other hand it encourages better abstraction
13:51:12 <ddarius> Pseudonym would say that it's due to the fact that there is no concept of signature which really makes this much simpler and would be useful on its own.  In fact, the hs-boot files are basically signature files.
13:51:55 <ddarius> Basically, without any notion of signature, every module would have to be type-checked together.
13:53:20 <mm_freak_> well, it takes some time to come up with a clean concept for module trees
13:53:45 <mm_freak_> although i like Yesod, this is what can make it a PITA sometimes
13:53:59 <mm_freak_> (unless you use the scaffolding tool, which i don't use)
14:05:51 <zzo38> Is there any standard function for "foldr (.) id"?
14:05:52 * hackagebot mtree 0.1 - Tree with Meta and Content parameters  http://hackage.haskell.org/package/mtree-0.1 (RahulGopinath)
14:07:51 <luqui> @zzo38, nope
14:07:51 <lambdabot> Unknown command, try @list
14:08:00 <luqui> lol, too much twitter
14:09:16 <copumpkin> omg it's luqui
14:09:27 <copumpkin> zzo: there sort of is
14:09:31 <copumpkin> :t mconcat
14:09:32 <lambdabot> forall a. (Monoid a) => [a] -> a
14:09:49 <luqui> appEndo . mconcat . map Endo
14:09:57 <copumpkin> :t Data.Foldable.foldMap Endo
14:09:59 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> Endo a
14:10:00 <luqui> semantically clean, but wordy
14:10:07 <copumpkin> :t ala Endo Data.Foldable.foldMap
14:10:08 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> a -> a
14:10:21 <luqui> i still don't grok ala
14:10:26 <copumpkin> > ala Endo Data.Foldable.foldMap [(+1), (*3), (^2)] 5
14:10:27 <lambdabot>   76
14:10:37 * copumpkin slaps luqui 
14:10:51 <JoeyA> :t ala
14:10:52 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
14:11:06 <copumpkin> it'd be so much more obvious with a type family
14:11:07 * copumpkin prods djahandarie 
14:11:13 <copumpkin> fuck compatibility with broken GHCs
14:12:24 <djahandarie> lol
14:12:49 <Peaker> it would also be nice if the isomorphic-wrapper class was called something better than "Newtype"
14:13:03 <bfig> shouldn't ala give you a n' ?
14:13:14 <copumpkin> I'm fine with the Newtype name :P
14:13:20 <copumpkin> in fact, it should be derivable
14:13:25 <copumpkin> if you like to expose your guys
14:13:27 <copumpkin> guts
14:15:43 <erus`> i want a data type like this   data Value = Constant Id Expression | Function Id Expression
14:15:58 <erus`> but they both have Id's so i feel like im duplicating data
14:19:08 <ian_mi> well, you could write it (Id, Either Expression Function) if you'd like
14:19:14 <ian_mi> but it's not really duplicating data
14:19:27 <benmachine> it's not Either Expression Function
14:19:32 <benmachine> it's Either Expression Expression
14:19:36 <luqui> oh
14:19:45 <luqui> (Tag, Id, Expression)
14:19:46 <benmachine> so you actually have something a bit like (Id, Bool, Expression)
14:19:51 <erus`> i think i can store the ID in a map outside the type actually
14:19:53 <luqui> data Tag = Constant | Functio
14:19:58 <benmachine> erus`: that seems wise
14:20:04 <luqui> agree
14:21:25 <erus`> also, is there a name for an argument used inside a function body
14:21:49 <luqui> erus`, what do you mean?
14:22:13 <erus`> i need to name a type for everything in an expression
14:22:18 <erus`> so
14:22:30 <luqui> I usually call that "Var"
14:22:54 <erus`> data Expression = Global Id | Argument ArgumentIndex? | Application Expression Expression
14:22:57 <erus`> if that makes sense
14:23:17 <luqui> de bruijn?
14:24:32 <erus`> Arguement will work but i imagine i will need that type somewhere else
14:24:55 <luqui> erus` what does it represent?
14:25:31 <erus`> arguements are a list and its the index of the arguement it uses
14:25:56 <erus`> this is like my final intermediate language. so everything has Int ID's rather than full names
14:28:19 <erus`> lol i will post an example in a sec
14:31:09 <ben> When exactly do I get "thread blocked indefinitely in an MVar operation" and can I rely on it throwing that error whenever it is the case
14:32:02 <Peaker> The semantics of a forever-sleep in IO, and those of throwing "indefinitely blocked" are different. Does GHC allow itself to change the former to the latter?
14:33:33 <hpaste_> erus` pasted ‚ÄúFinal Syntax Representation‚Äù at http://hpaste.org/51479
14:38:44 <Athas> Can someone point me at a package with a good test suite that I can use as inspiration for my own?  I know how to write good QuickCheck properties, but not how to best structure my tests into units (one per module?) or integrate it with cabal.
14:44:18 <erus`> can i define a literal map?
14:44:27 <kmc> what's that mean?
14:49:44 <wavewave> anyone read pearls of functional algorithm design by Richard Bird?
14:50:18 <wavewave> I just bought it and am reading it.
14:50:38 <wavewave> this book is a real pearl.
14:51:07 <erus`> never mind fromList works good enough
14:52:30 <SonicvanaJr> thanks
14:52:32 <SonicvanaJr> lsls
14:52:33 <SonicvanaJr> ls
14:52:35 <kmc> erus`, for Data.Map? yeah, i'd use fromList
14:52:35 <SonicvanaJr> ls
14:52:49 <erus`> kmc I have an Abstract Syntax Tree with comments and stuff included and then i have a simplified representation after that. What is the right name for the later?
14:53:03 <wavewave> now I cannot understand what fusion exactly means in chap 7 in the book..
14:54:32 <Peaker> wavewave: like, list fusion?
14:55:43 <wavewave> I only heard of list fusion but here Bird seems to mean something else...
14:56:19 <wavewave> list fusion is more like some inlineing technique..
14:58:17 <wavewave> generally, this book is very great, but it is a little to difficult to follow... It assues some familiarity to some jargons.
14:59:20 <wavewave> but all the algorithm presented here are quite nontrivial as usual functional pearls are..
15:02:36 <wavewave> hmm.. what I understand here from fusion is just some statement of equivalence.
15:02:56 <wavewave> h (foldrn f g xs) = foldrn f' g' xs
15:03:19 <wavewave> h (g x) = g' x
15:03:35 <monochrom> you judge which side of the equation is more efficient, then you always use the equation to rewrite to the efficient side
15:03:53 <wavewave> h ( f x y ) = f' x (h y)
15:04:12 <Eduard_Munteanu> Fusion in Haskell is achieved using rewrite rules.
15:04:31 <Eduard_Munteanu> Like   map f . map g = map (f . g)
15:05:15 <jmcarthur> actually, stream fusion doesn't inherently need rewrite rules if you don't need sharing at all
15:05:19 <Eduard_Munteanu> E.g. so you don't go over the list twice.
15:05:50 <jmcarthur> that is, you could make your data type just be the stream version and that's it
15:05:54 <wavewave> Eduard_Munteanu: yes. but here he does not say anything about some ghc rewriting rule.
15:05:59 <jmcarthur> it has limitations though
15:06:23 <wavewave> he just use term 'fusion' for explaining the idea.
15:06:54 <monochrom> sometimes, you don't judge which side is more efficient, but rather which side helps you prove things
15:07:07 <wavewave> anyway.. this fusion is quite interesting.. since it reduces exponential to linear
15:07:52 <Eduard_Munteanu> I guess that depends what you use it for.
15:08:20 <wavewave> Eduard_Munteanu: absolutely. ;-)
15:08:43 <wavewave> this is a chapter titled "Building a tree with minimum height'
15:09:22 <wavewave> problem is making a tree from a list.
15:09:52 <kmc> erus`, that's a good question.  maybe "annotated AST" versus "AST",  or "AST" versus "intermediate representation"
15:09:57 <kmc> erus`, in general compilers will have many IRs
15:10:05 <wavewave> when you serialize the tree, you should get the same list as original in order..
15:10:23 <wavewave> serialize means left-to-right tree traversing.
15:10:32 <erus`> how on earth are they all named :(
15:11:47 <wavewave> now I understand that he tried to explain this with very naive algorithm and use 'fusion rule' to make an efficient algorithm.
15:11:48 <monochrom> if you have 15 children, you will know
15:15:12 <DevHC> in http://haskell.org/haskellwiki/GHC/FAQ, 7.2.1 Does GHC do common subexpression elimination?:
15:15:22 <hpc> DevHC: no
15:15:24 <DevHC> the transformation is:
15:15:29 <hpc> oh, misread
15:15:44 <DevHC> let { x = case e of ...;  y = case e of ... } in ... to let { v = e; x = case v of ...; y = case v of ... } in ...
15:15:48 <DevHC> what's the difference?
15:16:29 <wavewave> DevHC : e must be an expression. right?
15:17:35 <wavewave> I guess some CSE is done if you turn on optimization.
15:17:42 <DevHC> whatever formally expression means...
15:17:46 <DevHC> what is v compared to e?
15:18:22 <wavewave> once you do let-float of some expression, then its's shared.
15:18:49 <wavewave> let v= e automatically means sharing of e in the scope of v
15:19:27 <luite> is there a package that defines liftM6 and higher?
15:19:29 <wavewave> so in the second example, e is calculated only once.
15:19:53 <DevHC> why isn't it calculated once in the first one?
15:20:02 <DevHC> e is just e, like v is just v
15:20:38 <wavewave> DevHC: it depends on how compiler do optimization.
15:21:09 <wavewave> I remember that that depends on the flag -O0, -O1, -O2..
15:21:28 <wavewave> let me check
15:21:41 <DevHC> what's the difference between
15:21:49 <bfig> luite, TH it :)
15:21:58 <DevHC> > let { f e = (e,e) } in f 1337
15:21:59 <lambdabot>   (1337,1337)
15:21:59 <DevHC> and
15:22:11 <DevHC> > let { f e = let v = e in (v,v) } in f 1337
15:22:11 <lambdabot>   (1337,1337)
15:22:12 <DevHC> ?
15:22:41 <wavewave> use Debug.Trace and see whether it calculate once or twice.
15:22:42 <napping> > 1 + 1
15:22:43 <lambdabot>   2
15:22:59 <luite> bfig: hehe maybe later
15:24:21 <parcs> DevHC: i wouldn't imagine a difference in that case, but in `let f e = (e^e, e^e) in f 1337` vs `let f e = let v = e^e in (v, v) in f 1337`
15:26:26 <erus`> any tips on writing an interpreter for a strick language in haskell?
15:27:46 <DevHC> someone needs to fix the wiki to make it more clear that e is not a variable as written
15:27:48 <erus`> this is a mind fuck
15:28:14 <napping> erus`: depends how you structure your interpreter, but sometimes it just works
15:28:28 <erus`> how can i force evaluation of anything?
15:28:38 <ddarius> @google definitional interpreters for higher order languages
15:28:40 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.110.5892&rep=rep1&type=pdf
15:28:40 <lambdabot> Title: Definitional Interpreters for Higher-Order Programming Languages*
15:28:46 <ddarius> Read that.
15:31:58 <napping> that's long but thorough
15:32:35 <napping> the point is, if you use an abstract machine or CPS style in your interpreter, than it doesn't matter whether the interpreter runs under lazy or strict evaluation
15:32:46 <napping> also, you could try to seq results
15:33:47 <wavewave> hmm. ghc is now not doing CSE any more even with -O9
15:34:49 <monochrom> seq or pseq changes the efficiency of your interpreter. that's all
15:35:08 <gentleben> Hi. I am trying to pattern match an Exception from Control.Failure to a specific exception type. I keep getting errors saying that it could not deduce (e ~ S3Error) which is an instance of Exception. What should I be doing so as to not get this error or help the compiler understand that it is the correct type
15:35:15 <napping> monochrom: It can also change the semantics of the interpreted language!
15:35:38 <napping> erus`: if you have something like eval :: Env -> Exp -> Value, apply :: Value -> Value -> Value
15:35:42 <hpaste_> wavewave pasted ‚ÄúCSE‚Äù at http://hpaste.org/51480
15:35:48 <monochrom> yes, but I'm assuming the interpreter is already written properly for a strict language
15:36:15 <napping> monochrom: then simply running it in Haskell might change the semantics of the interpreted language to lazy
15:36:48 <wavewave> DevHC: see my example.
15:36:54 <monochrom> no, I'm using your "if you use an abstract machine or CPS style in your interpreter, than it doesn't matter whether the interpreter runs under lazy or strict evaluation"
15:36:57 <napping> erus`: then a clause like eval env (Call f x) = apply (eval env f) (eval env x) will tend to give you lazy application semantics
15:37:08 <sshc> wavewave: I think there are only 3 defined optimization levels
15:37:22 <erus`> yeah i figured
15:37:28 <napping> monochrom: yeah, if you already use one of those styles it doesn't matter. I was rather suggesting to use seq in a more direct style interpreter
15:37:39 <monochrom> I see
15:37:49 <napping> erus`: so one option is to make it eval :: Env -> Exp -> (Value -> a) -> a
15:37:59 <wavewave> sshc: yes. I checked -O0 -O1 -O2 -O3 -O9  ;-)
15:38:15 <napping> then eval env (Call f x) k = eval env f (\fv -> eval env x (\xv -> k (apply fv xv)))
15:38:20 <wavewave> just in case that there is a hidden optimization.
15:38:24 <napping> or something like that - maybe apply needs to be cps too
15:38:40 <erus`> :|
15:38:40 <monochrom> I suggest abstract machine then. it's harder to get wrong, as long as you have a large stack
15:38:57 <napping> yeah, I think you're right
15:39:04 <napping> abstract machine is probably cleanest
15:39:32 <wavewave> not rely on automatic CSE by compiler..
15:39:49 <napping> using seq would be like: eval env (Call f x) = apply $! eval env f $! eval env x
15:40:00 <ddarius> CPS is a global (non-local) transformation.
15:40:05 <wavewave> long time ago, I remember I did the same experiments and -O2 gave CSE result.
15:40:21 <wavewave> ghc 6.10 time... I guess.
15:40:36 <napping> Does @seen still work?
15:40:42 <wavewave> Ah.. my previous hpaste was done with ghc 7.0.3
15:41:04 <ddarius> napping: No, it just talks to preflex.
15:41:24 <ddarius> wavewave: CSE is often not an optimization.
15:41:56 <wavewave> ddarius: Yes, I guess so.
15:42:04 <monochrom> I suggest most papers of Graham Hutton. they tend to contain very simple interpreters, target language is strict, implementation language is haskell. goes a long way to show you how easy it is, doesn't matter if haskell is non-strict
15:42:27 <wavewave> if the expression is very simple.
15:43:07 <wavewave> and of course, if it is very simple, it appears as just a bare expression more often.
15:43:20 <monochrom> I think http://www.cs.nott.ac.uk/~gmh/bib.html#exceptions is worth a try
15:43:21 <Nisstyre> What's the simplest way of working with graphics in Haskell? All I want are 2D geometric shapes.
15:44:03 <monochrom> @summon GrahamHutton !
15:44:04 <lambdabot> Unknown command, try @list
15:44:22 <wavewave> anyway.. to have sharing, we need explicit let-float.
15:44:29 <napping> Nisstyre: gloss, I think
15:44:38 <Nisstyre> I'm reading a textbook on analytic geometry and I want to write some Haskell to visualize the formulas.
15:44:43 <Nisstyre> napping: I'll check it out.
15:44:50 <napping> have you seen cdsmiths class: http://cdsmith.wordpress.com/2011/09/14/haskell-for-kids-week-5/
15:45:04 <napping> even has an online interpreter page
15:45:16 <ddarius> 2D geometric shapes will suffice for that?
15:45:18 <napping> well, might be down at the moment, but I've seen it working
15:45:19 * wavewave wonders if we can make an extension changing evaluation scheme in a certain box of code. 
15:45:44 <Nisstyre> ddarius: for the first part of it, yes
15:45:45 <ddarius> wavewave: You can easily write a TH quote that will add $! at every application.
15:46:04 <wavewave> I really want to see how some code change if we use default fully-lazy language.
15:46:26 <wavewave> or default completely-lazy language..
15:46:36 <jmcarthur> completely lazy ++
15:47:33 <wavewave> I guess fully-laziness makes a global function call nexus easily..
15:48:04 <wavewave> making modular memoization possible?
15:49:21 <wavewave> generally fully laziness is bad for performance. but if we limit fully laziness scope in some way, then maybe it's useful.
15:50:12 <wavewave> for example... calculate some complicated polynomial.
15:50:35 <Nisstyre> wavewave: like the bang pattern extension for GHC?
15:51:25 * jmcarthur wishes liftA2 was in the Applicative type class. i use it so much more than (<*>) and it would be nice to optimize for that
15:51:34 <erus`> so i have todo seq a a if i want to strictly evaluate a single thing?
15:51:59 <napping> erus`: It's not necessary if you just want to evaluate a strict language
15:51:59 <wavewave> Nisstyre: yes.. but I do not know how to mix it with ordinary laziness.
15:52:14 <napping> oh, and (seq a a) is never useful
15:52:17 <Nimatek> lambdabot is surprisingly resistant to being built.
15:52:21 <ddarius> seq a a = a
15:52:34 <wavewave> consider some polynomial. x^7+x^5 + x^3 + ...
15:52:39 <Nisstyre> wavewave: what do you mean you don't know how to mix it?
15:52:40 <napping> (seq a b) just returns a lazy value that, if examined, will force a before b
15:52:48 <Nisstyre> wavewave: ok
15:52:57 <hpaste_> erus` pasted ‚Äúexample‚Äù at http://hpaste.org/51481
15:53:03 <wavewave> it repeatedly calculate x^2, x^4, ...
15:53:06 <napping> so, (seq a a) makes a lazy value that if examined, forces a before a
15:53:07 <Nisstyre> yes
15:53:09 <jmcarthur> napping: not quite correct
15:53:16 <erus`> napping i need the impure evalBinding to be strict
15:53:24 <jmcarthur> napping: seq a b forces a when b is forced, but doesn't specify the relative ordering
15:53:33 <Nisstyre> wavewave: have you seen http://www.haskell.org/haskellwiki/Blow_your_mind#Polynomials ?
15:53:35 <napping> well, yeah, "before" is a bit strong. it doesn't quite guarantee order
15:53:38 <Nisstyre> why can't you mix that with bang patterns?
15:53:45 <jmcarthur> pseq guarantees order though
15:53:47 <ddarius> napping: Be careful with the word "before."
15:54:22 <jmcarthur> (in fact i think ghc will happily evaluate b before a sometimes)
15:54:34 <ddarius> It will.
15:55:12 <ddarius> Store the polynomial in Horner form.
15:55:33 <wavewave> Nisstyre: I am talking about "fully laziness" not ordinary laziness.
15:55:51 <Nisstyre> wavewave: can you point me to an explanation of "fully laziness" ?
15:56:09 <erus`> can i do that then?
15:56:24 <erus`> or do i need to redesign?
15:56:26 <wavewave> it's basically 'let-float' every maximal free expression .
15:56:50 <erus`> otherwise my IO actions will be in the wrong order
15:56:57 <wavewave> it's explained in Simon Peyton Jones' implementation of ... : I don't remember the name of book.
15:57:02 <Nisstyre> wavewave: Ok
15:57:03 <wavewave> wait a minute.
15:57:09 <Nisstyre> I've encountered that concept in Haskell before
15:57:22 <Nisstyre> I just didn't know what it was called
15:57:34 <napping> erus`: if you're in IO, that my be enough
15:57:40 <wavewave> currently laziness is evaluate up to weak head normal form.
15:57:51 <napping> like, eval (Call f x) = do fv <- eval f; xv <- eval x; apply fv xv
15:57:51 <erus`> oh cool
15:58:00 <napping> at least, that will make sure the effects happen in order
15:58:05 <erus`> oh but it wont be lazy at all then ?
15:58:09 <Nisstyre> wavewave: is this what you mean? http://foldoc.org/let+floating
15:58:47 <wavewave> yes.
15:58:55 <jmcarthur> ghc is almost fully lazy, isn't it? i think it chooses not to be fully lazy every once in a while
15:59:24 <napping> erus`: you probably shouldn't be lazy in the parts that have side effects
15:59:38 <wavewave> jmcarthur: I believe that ghc is not fully lazy any more.
15:59:51 <ddarius> There are multiple CPS transforms depending on whether you want a call-by-value or call-by-name.  There are likewise (almost equivalently) multiple monadic style "transforms" for call-by-value and call-by-name.  The way monads are usually used in Haskell, is using a call-by-value style.
15:59:57 <erus`> i split evalValue into two type, one is an IO Val and the other is not. that should work
16:00:07 <Nisstyre> napping: isn't lazily reading a file a good thing to do?
16:00:17 <Nisstyre> especially if that file is larger than your memory
16:00:34 <jmcarthur> wavewave: no more -ffull-laziness?
16:00:42 <ddarius> jmcarthur: let-floating has pretty negative effects on memory retention.
16:00:44 <napping> that one might be arguable, but stuff like output happening randomly as you force a lazy value is not good
16:00:54 <jmcarthur> it was never fully lazy to begin with... just mostly, i thought
16:01:06 <jmcarthur> ddarius: yeah
16:01:14 <Nisstyre> I thought it tried to be lazy by default everywhere
16:01:22 <erus`> or maybe i should just return a list of pseudo IO actions....
16:01:31 <jmcarthur> Nisstyre: "full laziness" is a specific kind of laziness
16:02:00 <napping> and with lazy input, you are basically assuming that the file won't be written to, so you can pretend it is read all at once
16:02:03 <Nisstyre> jmcarthur: I've got that now
16:02:24 <jmcarthur> Nisstyre: oh you are talking about IO
16:02:25 <Nisstyre> so only evaluating local expressions once if they don't use the parameter of the function
16:02:30 <Nisstyre> jmcarthur: yeah
16:02:44 <wavewave> jmcarthur: I experimented -ffull-laziness before, but I remember it was not implementing fully-laziness in the sense that SPJ explained as in his book.
16:02:57 <jmcarthur> wavewave: correct
16:03:00 <Peaker> Nisstyre: Laziness is about an increase in composability/modularity.  Laziness + side-effects is not very composable, so somewhat defeats the point
16:03:02 <Nisstyre> wavewave: which book?
16:03:44 <wavewave> The Implementation of Functional Programming Languages
16:03:45 <jmcarthur> every once in a while somebody comes in with a crazy space leak and it turns out that -fno-full-laziness fixes it
16:03:48 <Peaker> Nisstyre: Haskell separate "evaluation" (computation of values), where evaluation order should only have effects on operational concerns and termination,  and "execution", where change of order changes the meaning of the code
16:04:06 <eyebloom> Anyone on who can answer  a question about "Comprehending Monads" by Wadler?
16:04:22 <Peaker> eyebloom: if you ask, there will probably be (too many) answers
16:04:24 <napping> erus`: how close is the interpreter to working?
16:04:28 <Nisstyre> Peaker: I understand that
16:04:40 <Nisstyre> it's the reason why it's so easy to parallelize haskell that is pure
16:04:44 <wavewave> Nisstyre: you can download the book.
16:04:48 <erus`> no so close
16:04:49 <Peaker> Nisstyre: are you looking for examples of when lazy IO is a bad idea?
16:04:51 <Nisstyre> wavewave: awesome
16:04:54 <Nisstyre> Peaker: yes
16:05:04 <napping> maybe just get something working, and then see what parts are lazy and strict
16:05:15 <Nisstyre> well, actually I said that I thought lazy IO was good sometimes
16:05:22 <Peaker> Nisstyre: I have some recent painful examples.. consider:  processFile f filename = do { content <- readFile filename ; writeFile filename (f content) }
16:05:25 <wavewave> that book is really good. kind of must-read
16:05:40 <erus`> i shouldnt have included a 'getc' in the spec
16:05:45 <erus`> its fucked everything up
16:05:49 <eyebloom> The definition of strict is strict f x = if xÃ∏ /=‚ä•then f x else‚ä•
16:06:21 <eyebloom> Can't find the definition of ‚ä•.
16:06:22 <Peaker> Nisstyre: another really annoying example:  consider a  withTimeout action decorator (Timeout -> IO a -> IO (Maybe a)) that puts your action behind a timeout. Then using something like:  mContent <- withTimeout (3 seconds) getContents ; ...
16:06:39 <Peaker> Nisstyre: the getContents is "immediate" and so the timeout doesn't work
16:06:45 <wavewave> http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
16:06:46 <Nisstyre> Peaker: ok
16:06:57 <Nisstyre> So laziness can be bad because of ordering concerns
16:07:07 <Nisstyre> makes sense
16:07:30 <eyebloom> I'm assuming that by putting an if statement in the function is a way of forcing evaluation of x
16:07:38 <Peaker> Nisstyre: laziness which reorders meaningful effects can be bad.. if it's reordering just pure evaluations, then it's less problematic
16:07:43 <eyebloom> but I'm still a little unclear about the definition.
16:07:52 <Nisstyre> Peaker: mhmm
16:08:09 <Nisstyre> wavewave: thanks for the link
16:08:20 <Nisstyre> SPJ is awesome
16:08:50 <Nisstyre> wavewave: I wouldn't mind getting it in print as well
16:09:11 <ddarius> ‚ä• is the non-terminating computation.  Say, undefined or bottom = bottom.
16:09:12 <wavewave> i am not sure if it is still being sold.
16:09:22 <Nisstyre> it's out of print according to that page
16:09:33 <geheimdienst> > let b = b in 42
16:09:34 <lambdabot>   42
16:09:34 <Nisstyre> but maybe I can find it somewhere used
16:10:51 * hackagebot swish 0.6.1.0 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.6.1.0 (DouglasBurke)
16:11:09 <wavewave> laziness is not good for some. but without it, all our monad would be very obscure.
16:11:13 <eyebloom> ddarius: ok maybe I need to see that in code rather than math.
16:11:35 <wavewave> it's very ironical.
16:12:49 <ddarius> bottom = bottom is code.
16:12:49 <wavewave> but I think laziness becomes more and more important in future.... simply our software become more and more complex and every exression will be expensive eventually.
16:13:23 <ddarius> wavewave: Monads have essentially nothing to do with laziness.
16:13:46 <wavewave> ddarius: yes. but without laziness, it will be very clumsy.
16:14:14 <wavewave> like ...  when (predicate) action
16:14:20 <Peaker> wavewave: laziness is not really about expensiveness of expressions -- and it generally makes expressions even more expensive. It's about what computations can terminate.. Avoiding expensive extra computation is just a (relatively small) benefit of laziness that's very easy to achieve otherwise, too
16:14:26 <ddarius> wavewave: Nope.
16:14:47 <ddarius> There are some things that will be slighly more awkward, but not much difference overall.
16:15:12 <Peaker> Monads have circumstantial relationships to laziness, possibly (laziness encourages seriousness about purity, which may have encouraged applying monads to programming/Haskell?)
16:15:14 <ddarius> when predicate action can be used exactly in a strict language using monadic IO, say, as in an eager language.
16:15:27 <cgroza> Hello every one. Lets say  I have a type named MyInt: data MyInt = MyInt Int. Once I create one MyInt, is there a way to change the Int in it besides making a new one?
16:15:42 <ddarius> One example that couldn't be used in a strict language is forever m = m >> forever m.
16:15:49 <wavewave> Peaker: I am basically meaning that composability of software.
16:15:54 <ddarius> In general, (>>) will be slightly less useful.
16:16:07 <Peaker> cgroza: No, values of data types are generally immutable. Mutability is possible, via a "mutable reference" type that's basically only readable/writable via IO actions
16:17:07 <cgroza> Peaker: thanks. But does it impact on performance? Or there is some compiler level trick?
16:17:14 <Peaker> wavewave: well, laziness helps with composability, but I think it mostly does this on the "low end".. composability of larger components benefits less from laziness, as it is trivial to encode laziness for those (for small components, encoding laziness can easily outweigh the component itself)
16:17:44 <Eduard_Munteanu> cgroza: it does impact performance
16:17:47 <Peaker> cgroza: Sometimes the compiler will be smart enough to convert the copying into in-place mutating.. but I wouldn't worry about it
16:18:20 <cgroza> Eduard_Munteanu: Peaker, thank you for your help.
16:18:29 <Peaker> cgroza: It is nice, though, that the whole notion of "mutability" is captured by reference types, and not baked in each and every data-type..
16:18:42 <eyebloom> ddarius: how is strict actually defined?
16:18:54 <Eduard_Munteanu> cgroza: OTOH, it's easier to reason about things if they don't change, so concurrency and all that have less to worry about.
16:18:54 <cgroza> Peaker: thanks.
16:18:56 <ddarius> eyebloom: What you saw was the actual definition.
16:19:09 <Peaker> eyebloom: The function f is strict in its argument, iff:  f _|_ = _|_
16:19:38 <cgroza> Eduard_Munteanu: interesting. The whole logic of haskell is new to me. Multumesc.
16:20:02 <Eduard_Munteanu> cgroza: oh. Nicio problema. :)
16:20:17 <cgroza> Eduard_Munteanu: :D
16:20:49 <jmcarthur> cgroza: even many imperative languages wouldn't necessarily mutate it in place like that. for example, considering assigning a variable with a non-primitive type in java. only the reference itself changes (as in haskell). the underlying object is not immediately overwritten at all
16:21:20 <jmcarthur> i hope i phrased that well. this is the first time i have tried to raise this point
16:22:11 <jmcarthur> *(as in haskell's IORefs)
16:22:48 <wavewave> Peaker: hmm, I do not get that encoding laziness for large component is so trivial.
16:23:51 <wavewave> at some point, somebody needs to build spineless G-machine -like object.
16:24:37 <wavewave> ffro a certain composability, that's overkill. but that's quite general enouhgh I think.
16:26:07 <wavewave> we take it granted that we have such arbitrary ordering of computation, but without that run time system, I think it's not that trivail.ial.ial.
16:26:26 <wavewave> Hmm.. my nework is killing me...
16:28:14 <wavewave> what I mean is that we are using laziness as it is very trivial to use, but that's because we are on the shoulders of giants.
16:29:11 <ahkurtz> I want to use cabal-dev, but seem to be mucking something up. I can't find any good examples of how to use it. I try: cabal-dev install; it complains: cabal: There is no installed version of base
16:31:27 <wavewave> I am still a very enthusastic advocate of  laziness. ;-)
16:31:58 <dylukes> wavewave: Would you call yourself an eager proponent of laziness?
16:32:05 <Eduard_Munteanu> Heh.
16:32:13 <wavewave> until very nice notation of and data and codata emerges.
16:32:21 <jmcarthur> if wavewave made a language it would be strictly lazy
16:32:39 <wavewave> strictly eagerly fully completely lazy
16:32:49 <jmcarthur> would it be very lazy?
16:33:12 <Eduard_Munteanu> But wouldn't he be too lazy to make such a language? :P
16:33:33 <wavewave> it's thunk in my head already.
16:33:35 <Nisstyre> Eduard_Munteanu: no, he would make each part of it as needed
16:33:39 <Nisstyre> and discard the previous parts
16:33:53 <Nisstyre> the ones he no longer needed
16:33:53 <wavewave> just take me to some IO monad..
16:34:30 <jmcarthur> wavewave is demand-driven
16:34:38 * jmcarthur demands that wavewave make a completely lazy language
16:35:06 <wavewave> there was an interesting thesis about complete laziness implementatin in fact.
16:35:15 <jmcarthur> thyer's?
16:35:31 <wavewave> some thing like a supercomiplation..
16:35:31 <wavewave> yes....
16:35:47 <wavewave> let me look it up again.
16:35:55 <jmcarthur> yeah, it boiled down to a symbolic interpreter, unfortunately. i don't know of any better way to do it though
16:36:29 <wavewave> also I remember optimisitc evaluation.
16:36:44 <jmcarthur> optimal, you mean?
16:36:44 <wavewave> somewhere between strict and laziness
16:37:00 <jmcarthur> err
16:37:36 <wavewave> that's again SPJ's paper.
16:37:53 <jmcarthur> ah
16:38:17 <jmcarthur> i don't remember optimistic evaluation. is it basically the same as speculative execution?
16:38:36 <wavewave> I guess so.. may be..
16:39:15 <ahkurtz> if anyone could point me to some docs or examples for cabal-dev that they like, I would greatly appreciate it and get out of your hair
16:40:48 <jmcarthur> i'd say what was interesting about thyer's thesis is that it demonstrates that completely lazy evaluation has a specialization effect that optimal evaluation does not
16:41:54 <wavewave> yes.
16:42:03 <jmcarthur> i hate the memo tables in his implementation though :(
16:42:48 <wavewave> ahkurtz: github documentaion isn't good enough?
16:42:58 <ahkurtz> well, it left me in a lurch
16:43:19 <ahkurtz> since it won't perform many of the basic operations advertised
16:43:27 <ahkurtz> which weren't totally explained
16:43:37 <ahkurtz> which could all be my fault, misunderstanding
16:43:52 <wavewave> ahkurtz: I haven't used it yet but if you can show some logs, that will be great.
16:46:18 <ahkurtz> http://gist.github.com/1224530
16:47:30 <wavewave> it says there is no installed version of base ;-)
16:47:58 <wavewave> install base .... sorry I am joking.
16:48:10 <ahkurtz> well. I have globally installed packages successfully with plain cabal. I ran install base. It also fails. I will paste that as well.
16:48:46 <wavewave> I am installing cabal-dev now..
16:48:51 <Olathe> What does coarbitrary mean in QuickCheck?
16:48:58 <ahkurtz> I'm flying blind because I don't know much about cabal, so the extra layer throws me
16:49:58 <jmcarthur> ahkurtz: base is a package you should never have to install manually
16:50:16 <jmcarthur> and in fact if you manage to install it manually you probably broke something
16:50:18 <ahkurtz> yeah, I figured as much, I tried a lot of things that didn't make sense to me
16:50:39 <wavewave> hmm.. in my case, it's working out of the box.
16:50:50 <wavewave> I guess your .cabal setup is not good?
16:50:51 <ahkurtz> first it said I had no cabal file
16:50:58 <ahkurtz> I ran cabal-dev init
16:51:06 <ahkurtz> answered the qs
16:51:17 <ahkurtz> then tried cabal-dev install as you see
16:51:25 <ahkurtz> I also compiled and tried to run Setup.hs
16:51:31 <ahkurtz> but it seemed like not what I wanted
16:52:40 <ahkurtz> something that concerns me is that it seems like ghc using llvm requires llvm 3, and I have built in OS X llvm, which is like 2.9ish
16:52:47 <wavewave> aha.. I see what's wrong.
16:53:03 <ahkurtz> unsure if that's actually problematic, or related
16:53:19 <wavewave> You should specify base library in your cabal file.
16:53:34 <ahkurtz> shouldn't the init tool do that?
16:53:35 <wavewave> you just created empty cabal directory.
16:53:55 <wavewave> it generate a stub.. but no content. even base library link.
16:54:17 <wavewave> so first make an example.
16:54:18 <ahkurtz> mmm. if I just install a single package will it fill that in for me anyway?
16:54:54 <wavewave> ahkurtz: anyway, you had better fill those in by yourself for other packages.
16:55:10 <wavewave> just go inside cabal file.
16:55:17 <wavewave> xxx.cabal file. I mean.
16:55:41 <wavewave> In Library section
16:55:51 * hackagebot LTree 0.0 - Tree with only leaves carrying the data.  http://hackage.haskell.org/package/LTree-0.0 (RahulGopinath)
16:55:57 <wavewave> you can see Build-depends : that 's commented out.
16:56:14 <wavewave> uncomment it and fill base>4 or something like that.
16:56:59 <wavewave> that's working with me.
16:57:50 <wavewave> anyway cabal-dev is not for scaffolding. (that's a kind of bonus.) cabal-dev is for isolating your dev environment from global repository.
16:58:16 <ahkurtz> https://gist.github.com/1224537
16:58:17 <parcs> ahkurtz: llvw 3?
16:58:56 <ahkurtz> parcs: http://llvm.org/docs/ReleaseNotes.html#whatsnew
16:59:23 <wavewave> ahkurtz: would you show us your cabal file?
16:59:36 <wavewave> supercollider-test.cabal.
17:00:19 <parcs> i'm not sure that llvm 3 has been released
17:00:22 <wavewave> kind of music project?
17:01:14 <ahkurtz> https://gist.github.com/1224540
17:01:36 <ahkurtz> yeah so, I want a test-bed for trying out music libraries
17:01:41 <ahkurtz> there are two of interest to me
17:01:54 <ahkurtz> I want to install them in a sandbox, and use that sandbox, and eventually build a package
17:02:15 <ahkurtz> supercollider is another language, kind of smalltalky, super rad at music
17:02:35 <ahkurtz> there is a haskell library that talks to its server api, and kind of apes the client api
17:03:43 <wavewave> ahkurtz: you need space before build-depends
17:03:43 <ahkurtz> the haskell library looks to have many advantages over using supercollider directly.
17:04:01 <wavewave> build-depends is in LIbrary section.
17:04:10 <wavewave> cabal is indent-sensitive.
17:04:51 <wavewave> give 2 space characters in front of Build-dpends.
17:05:35 <ahkurtz> thank you! so if I understand I can use the ghci loading functionality once I actually have at least one sourcefile in my project?
17:05:42 <stribor> how do you look if function is avaibale to use before you actually implement it yourself.....
17:05:45 <wavewave> (how many spaces are not important though. but in the same section all the subcommand should have the same indentation. )
17:05:47 <stribor> just by going to hoogle and giving parametars
17:07:36 <wavewave> ahkurtz: hmm. actually I do not understand what you are saying... probably you need to know how cabal package is constructed..
17:08:39 <parcs> stribor: hoogle is one way. the other way is to ask here :)
17:09:05 <stribor> well id like to compare 2 lists for equality of each elements
17:09:12 <ahkurtz> k, I'll go figure that out. cabal-dev says you can run ghci through it and it will load up your deps you've installed
17:09:16 <stribor> whatever i find equal id like to put into new list
17:09:19 <ahkurtz> that's what I'm trying to do
17:10:02 <wavewave> ahkurtz: I see. but I think you had better use ghci directly for that purpose.
17:10:11 <ahkurtz> I guess knowing completely what I'm trying to do is more helpful than my confused guesses
17:10:12 <Olathe> How do I make an Arbitrary instance for, say, data Blah = Blah Int Integer Char?
17:10:16 <wavewave> you don't have to use cabal-dev when using ghci
17:10:32 <ahkurtz> oh, alright. I can load them as a relative path or something?
17:10:46 <parcs> > intersect [0..7] [1,3..10]
17:10:47 <lambdabot>   [1,3,5,7]
17:10:47 <wavewave> you can load modules directly.
17:10:56 <wavewave> by :m command
17:10:56 <parcs> stribor: like that?
17:11:15 <ahkurtz> if they are installed by cabal dev, they are sandboxed. they will be available without some extra options?
17:11:30 <stribor> well for example [1,2,3,4,5] [2,5,3,4]
17:11:38 <stribor> will return [2,3,4]
17:12:01 <parcs> what about 5?
17:12:10 <stribor> yes sorry
17:12:10 <wavewave> Ah.. if it is installed using cabal-dev, then I do not know.
17:12:11 <stribor> lol
17:12:11 <stribor> :)
17:12:25 <parcs> > intersect [1,2,3,4,5] [2,5,3,4]
17:12:25 <lambdabot>   [2,3,4,5]
17:12:30 <dcoutts__> ahkurtz: I think you then need to specify the sandbox package db
17:13:09 <ahkurtz> I always have productivity sapping problems with dependency management in every language
17:13:19 <ahkurtz> I just want to figure it out up front this time.
17:13:31 <stribor> parcs: thank you
17:13:46 <ahkurtz> Thanks a lot for your assistance.
17:13:53 <ddarius> Olathe: liftA3 Blah arbitrary arbitrary arbitrary
17:13:55 <wavewave> if available, just make a sandbox user id in your computer.. try some experiment...
17:14:25 <wavewave> cabal-dev is under heavy development and still lack of information yet, so use standard tools first
17:15:17 <wavewave> then after understanding whats going on inside, you can try the bleeding edge tool.
17:16:17 <djahandarie> Man, System.Timeout.timeout is pretty unreliable.
17:16:20 <wavewave> basically cabal-dev assumes your knowledge on cabal package system.
17:18:29 <wavewave> since I happened to install cabal-dev, I will play with cabal-dev tonight. hehe
17:18:56 <ahkurtz> I thought python's virtualenv works fine, and cabal-dev is the same idea
17:19:24 <djahandarie> wavewave, I met you at hacphi, right?
17:20:24 <Olathe> ddarius: Thanks :)
17:21:30 <wavewave> yes.
17:22:06 <wavewave> I was participating in hacphi.
17:23:54 <wavewave> djahandarie: sorry that I cannot recognize you by your id. would you tell me where you sat down, please?
17:24:18 <djahandarie> Hmm, I moved
17:24:24 <djahandarie> First I was at the middle table
17:24:32 <djahandarie> Then the small table to the side ("Agda" table? :P)
17:24:49 <Eduard_Munteanu> LOL, was that the punishment corner?
17:25:06 <djahandarie> Haha we just ended up sitting there
17:25:29 <wavewave> lots of arrows.. very dangerous place.
17:26:17 <djahandarie> Heh
17:26:59 <wavewave> that was great experience to me. I attended to such an event for the first time.
17:27:15 <Eduard_Munteanu> "If you don't behave, you'll sit there until you formally prove you won't do that again!"
17:28:37 <djahandarie> Yeah it was great
17:28:48 <djahandarie> Too bad xplat isn't in Boston
17:29:03 <djahandarie> That would make meeting up for CT library again easy!
17:31:27 <wavewave> so when is next big meeting again?
17:32:07 <djahandarie> Hmmm
17:32:24 <djahandarie> I think there is one somewhat planned to happen in Boston at some point...
17:32:33 <djahandarie> edwardk would know but he isn't around
17:33:01 <wavewave> I saw reddit article on VirtualHac right now.
17:34:10 <wavewave> having a meeting in boston sounds good.. but it's too far from here again.
17:34:13 <djahandarie> Oh, huh, interesting
17:34:27 <djahandarie> Hmm, where are you at?
17:34:29 <wavewave> I am now in Michigan.
17:34:36 <wavewave> at Ann Arbor.
17:35:01 <djahandarie> Ah
17:35:03 <djahandarie> That's pretty far
17:35:09 <wavewave> I went to hacphi as a kind of vacation. .. (weird kk )
17:35:14 <djahandarie> Haha
17:35:36 <wavewave> see Philadelphia and UPenn and the "hackers"
17:35:51 * hackagebot LambdaHack 0.1.20110918 - A roguelike game engine in early development  http://hackage.haskell.org/package/LambdaHack-0.1.20110918 (MikolajKonarski)
17:36:24 <wavewave> hope that there are some haskellers here..
17:36:37 <djahandarie> In michigan?
17:36:50 <wavewave> yes.
17:37:18 <wavewave> also in physics. ;-)
17:37:24 <djahandarie> Hmmm... I think there is at least one
17:37:34 <djahandarie> dstcruz
17:37:58 <wavewave> oh.. really. maybe sometime it will be great to chat with the person.
17:38:15 <djahandarie> I wish I knew more physics though
17:38:21 <djahandarie> That would be cool
17:38:30 <djahandarie> There is a lot of CT stuff used in physics...
17:39:32 <wavewave> yes.. in my area, computing is a real deal.
17:39:35 <Olathe> How do I fix `coarbitrary' is not a (visible) method of class `Arbitrary'?
17:40:09 <jmcarthur> is there a general method for taking two mutually recursive data structures and making one equivalent, directly recursive data structure?
17:40:24 <jmcarthur> i assume there is one, but i think my mind is just working slowly right now
17:40:26 <Olathe> Ahh, never mind. Got it.
17:40:42 <djahandarie> jmcarthur, there sounds like there should be one
17:41:08 <wavewave> kind of nexus merging?
17:41:26 <wavewave> arbitrary naming.
17:41:59 <wavewave> anyway... some technique for observing shared strucutre can be helpful
17:42:03 <wavewave> data-reify?
17:42:33 <Nimatek> I just found out that Well-Typed LLP have an office in my town.
17:42:53 <jmcarthur> i'm thinking along the lines of just doing code transformation
17:43:38 <stribor> can anyone explain why this call List.lookup ("jerry",1,2,3,4,5) [(("jerry",1,2,3,4,5),(1,2,3)),(("george",2,3,4,5,6),(3,4,5))]
17:43:49 <stribor> returns Just (1,2,3)
17:44:08 <Veinor> as opposed to what?
17:44:17 <stribor> as oppose to nothing
17:44:23 <Olathe> @type lookup
17:44:24 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
17:44:26 <stribor> just dont know what it means
17:44:33 <wavewave> ("jerry",1,2,3,4,5) is the key.
17:44:39 <stribor> yes
17:44:42 <wavewave> (1,2,3,) is value
17:44:51 <djahandarie> stribor, do you know what   lookup "a" [("a", 3), ("b", 5)]   evalutes to?
17:45:03 <stribor> oh ok3
17:45:05 <stribor> 3
17:45:07 <djahandarie> Yeah
17:45:13 <wavewave> you look up ("jerry",1,2,3,4,5) and it found its corresponding value
17:45:15 <djahandarie> Same idea with your example, just more complicated keys and values
17:45:27 <stribor> ok since it returns type Maybe
17:45:36 <stribor> is there way to convert this type Maybe
17:45:40 <stribor> into something else
17:45:44 <Olathe> What else?
17:45:47 <ion> :t fromMaybe
17:45:48 <lambdabot> forall a. a -> Maybe a -> a
17:45:50 <ion> :t maybe
17:45:51 * hackagebot git-annex 3.20110915 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20110915 (JoeyHess)
17:45:51 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:46:05 <wavewave> :t fromJust
17:46:06 <lambdabot> forall a. Maybe a -> a
17:46:09 <djahandarie> Noooo wavewave
17:46:10 <stribor> well if (1,2,3) is Maybe type....can we return it inot list [1,2,3]
17:46:11 <ion> NO
17:46:19 <wavewave> I know... kk
17:46:28 <Olathe> fromJust is the work of SATAN!
17:46:33 <wavewave> well I should not tell this..
17:46:43 <Jafet> The type of (1,2,3) is not a Maybe.
17:46:57 <Olathe> > fromMaybe (error "zomg") Nothing
17:46:58 <lambdabot>   *Exception: zomg
17:47:01 <ion> > let f (a,b,c) = [a,b,c] in f (1,2,3)
17:47:02 <lambdabot>   [1,2,3]
17:47:03 <wavewave> you know...you are playing with devil... once you know it.
17:47:14 <Veinor> Olathe: i've used fromJust before!
17:47:21 <stribor> but can i use type Maybe to compare it to element of another list?
17:47:23 <ion> (If you want lists out of it, just store lists in the first place.)
17:47:26 <Olathe> Veinor: You've used the work of SATAN!
17:47:31 <Veinor> though i probably should use fromMaybe (error "something descriptive") instead
17:47:32 <ion> Compare how?
17:47:57 <stribor> well what if i have another list such as [(,1,2,3),(4,5,6),(4,5,6)]
17:48:10 <stribor> and i want to compare maybe (1,2,3) to that list
17:48:16 <ion> Compare how?
17:48:48 <stribor> well like this well if we compare maybe (1,2,3) tp [(1,2,3),(4,5,6),(4,5,6)
17:48:54 <stribor> we can see that first triple is same
17:49:01 <stribor> and we et it out from the list
17:49:07 <stribor> we get it out from list
17:49:34 <napping> partition (==(1,2,3))?
17:49:44 <stribor> napping: ?
17:50:02 <Olathe> stribor: What do you mean by getting it out?
17:50:06 <wavewave> he may be asking (Just (1,2,3)) and comparing..
17:50:15 <stribor> yes waave
17:50:17 <Jafet> stribor is taking the scenic detour of wtf
17:50:22 <Olathe> Haha
17:50:23 <stribor> hahaha
17:50:24 <wavewave> from Just kkkk
17:50:26 <stribor> nice jafet
17:50:49 <Jafet> What do you want your program to do?
17:50:54 <napping> > partition (==(1,2,3)) [(1,2,4),(1,2,3),(1,0,3)]
17:50:55 <lambdabot>   ([(1,2,3)],[(1,2,4),(1,0,3)])
17:51:06 <ion> > let ma = Just 42; xs = [0,42,99] in fromMaybe False ((`elem` xs) <$> ma)
17:51:07 <lambdabot>   True
17:51:15 <stribor> napping: how can you compare elements like that that are not same
17:52:26 <napping> how is it not the same? A tuple of numbers and a list of such tuple
17:53:03 <wavewave> > (1,2,3) == (1,2,3)
17:53:04 <lambdabot>   True
17:53:15 <wavewave> > (1,2,3) == (1,2,4)
17:53:17 <lambdabot>   False
17:53:26 <stribor> i mean how can you compare Maybe 1 == Int 1
17:53:42 <Jafet> Okay, so everyone is taking the scenic detour.
17:54:21 <ion> http://mywiki.wooledge.org/XyProblem
17:54:23 <wavewave> :t fmap (==)
17:54:24 <lambdabot> forall a (f :: * -> *). (Eq a, Functor f) => f a -> f (a -> Bool)
17:54:38 <Olathe> stribor: fmap (==1) (Maybe 1)
17:54:45 <Olathe> > fmap (==1) (Maybe 1)
17:54:46 <lambdabot>   Not in scope: data constructor `Maybe'
17:54:51 <Olathe> > fmap (==1) (Just 1)
17:54:52 <lambdabot>   Just True
17:54:55 <wavewave> fmap (==(1,2,3)) (Just (1,2,3))
17:54:58 <napping> Ah, I see more context now
17:55:13 <djahandarie> The context is that stribor is very confused and no one is helping properly ;)
17:55:24 <napping> > lookup "x" [("x",1),("y",2)]
17:55:25 <stribor> djahandarie: :)
17:55:25 <lambdabot>   Just 1
17:55:34 <wavewave> stribor: any action defined for a can be defined in Maybe a
17:55:48 <stribor> wavewave: i did not know that):
17:55:54 <wavewave> and you can do the action by fmap
17:55:55 <napping> I've been afk awhile. Was the original question about ("jerry",1,2,3,4,5)  [(("jerry",1,2,3,4,5),(1,2,3)),(("george",2,3,4,5,6),(3,4,5))]
17:55:58 <napping> ?
17:56:01 <djahandarie> Yes
17:56:21 <wavewave> stribor: define f :: Int -> Int
17:56:34 <napping> stribor: the big tuples make that a bit hard to parse. Did my smaller example make more sense?
17:56:44 <stribor> yes napping
17:56:44 <napping> > lookup "z" [("x",1),("y",2)]
17:56:45 <lambdabot>   Nothing
17:56:45 <parcs> stribor: seinfeld fan eh?
17:56:55 <stribor> parcs: big fan:)
17:56:56 <wavewave> and then you automatically define fmap f :: Maybe Int -> Maybe Int
17:57:12 <Olathe> > let f _ Nothing = False; f n (Just x) = n == x in f 1 (Just 1)
17:57:14 <lambdabot>   True
17:57:22 <wavewave> Maybe Int = Nothing or  Just Int
17:57:38 <stribor> thank you guys
17:58:03 <wavewave> if input is Nothing, (fmap f) Nothing = Nothing
17:58:22 <wavewave> input is Just x , (fmap f)  (Just x) = f x
17:58:43 <wavewave> this procedure is called 'lifting'
17:59:22 <wavewave> the data type in which you can define lifting is "Functor"
17:59:57 <stribor> wavewave: thanks
18:00:30 <djahandarie> wavewave, I think your introducing too many advanced concepts for a simple question.
18:00:40 <wavewave> so you think there are two worlds :   ordinary vs liftd world
18:01:17 <parcs> > lookup "bye" [("bye", 0), ("hi", 1)] == 0
18:01:18 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
18:01:18 <lambdabot>    arising from the lite...
18:01:23 <parcs> > lookup "bye" [("bye", 0), ("hi", 1)] == Just 0
18:01:24 <lambdabot>   True
18:01:25 <wavewave> I am cleaning myself for introducing him 'fromJust' ;)
18:01:33 <parcs> stribor: see what i did there?
18:01:34 <djahandarie> lol
18:01:35 <napping> "lifted" already means something else
18:01:52 <stribor> yes
18:01:56 <stribor> i see that
18:02:01 <stribor> 0 == Just 0
18:02:11 <parcs> ok. that's how you compare a Maybe Int to an Int
18:03:37 <wavewave> napping: sorry in sloppy termininology
18:03:43 <dibblego> > Data.Foldable.any (==0) (Just 0)
18:03:44 <lambdabot>   True
18:07:29 <wavewave> stribor: so you decide where your calculation will be.. orinary world or lifted world
18:07:55 <stribor> wavewave: yeah i am trying to see what is best for me
18:08:03 <djahandarie> Hmm, I forget, is there is nice function for doing  [1,2,3,4,5,6,7]   |->   ([1,3,5,7], [2,4,6])   ?
18:08:43 <ion> > partition odd [1..7]  -- I wonder if this works?
18:08:44 <lambdabot>   ([1,3,5,7],[2,4,6])
18:08:49 <djahandarie> Bah :P
18:09:04 <djahandarie> Though I could zip with [1..] and do something like that
18:09:21 <stribor> like i have two lists such as [a] [(a,b)]
18:09:24 <djahandarie> (I meant for it to work regardless of values.)
18:09:32 <stribor> id like to compare the 2
18:09:59 <Jafet> > fmap (map snd) . partition (odd.fst) . zip [1..] $ "djahandarie"
18:10:01 <lambdabot>   ([(1,'d'),(3,'a'),(5,'a'),(7,'d'),(9,'r'),(11,'e')],"jhnai")
18:10:32 <Jafet> Bah, no binary functor
18:10:44 <wavewave> stribor: you want to compare [a] and [(a,b)], you mean?
18:10:51 * hackagebot chell 0.2 - A quiet test runner  http://hackage.haskell.org/package/chell-0.2 (JohnMillikin)
18:10:52 <ion> stribor: Please explain what you‚Äôre *actually* trying to do. What program are you writing? How would you document what it does?
18:10:57 <Jafet> > (map snd *** map snd) . partition (odd.fst) . zip [1..] $ "djahandarie"
18:10:59 <lambdabot>   ("daadre","jhnai")
18:11:14 <djahandarie> Thanks. :P
18:12:31 <Jafet> Haha, chell
18:13:07 <HugoDaniel> :D
18:13:10 <HugoDaniel> truly the great
18:13:29 <wavewave> Type constructor is quite difficult in the begining.
18:14:49 <ion> What‚Äôs the funneh in chell?
18:15:01 <napping> Portal
18:15:40 <ion> Ah. Haven‚Äôt played it. I did download it just yesterday, though, since they‚Äôre giving it away for free at the moment.
18:16:09 <jmcarthur> > join (***) (map snd) . partition fst . zip (cycle [True,False]) $ "djahandarie"
18:16:10 <lambdabot>   ("daadre","jhnai")
18:17:15 <djahandarie> > swap . join (***) (snd .) . partition fst . zip (cycle [False..]) $ "djahandarie"
18:17:16 <lambdabot>   <no location info>: parse error on input `]'
18:17:23 <djahandarie> > swap . join (***) (snd .) . partition fst . zip (cycle [False ..]) $ "djahandarie"
18:17:24 <lambdabot>   Not in scope: `swap'
18:17:28 <djahandarie> Damn!
18:17:36 <Jafet> @let swap (x,y) = (y,x)
18:17:37 <lambdabot>  Defined.
18:17:41 <djahandarie> > swap . join (***) (snd .) . partition fst . zip (cycle [False ..]) $ "djahandarie"
18:17:43 <lambdabot>   ("daadre","jhnai")
18:18:05 <ion> lambdabot seems to have a slightly old version of Data.Tuple.
18:18:05 <jmcarthur> > snd &&& fst <<< join (***) (snd .) . partition fst . zip (cycle [False ..]) $ "djahandarie"
18:18:06 <lambdabot>   ("daadre","jhnai")
18:18:13 <djahandarie> Heh
18:18:55 <jmcarthur> ew.... "(snd .)"
18:18:59 <djahandarie> :P
18:19:54 <Jafet> What Arrow needs is both
18:19:56 <jmcarthur> @src partition
18:19:57 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
18:19:57 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
18:19:57 <lambdabot>                               | otherwise = (ts, x:fs)
18:19:57 <Jafet> :t first
18:19:58 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
18:20:01 <Jafet> :t both
18:20:02 <lambdabot> Not in scope: `both'
18:20:10 <jmcarthur> @let both = join (***)
18:20:11 <lambdabot>  Defined.
18:20:16 <Jafet> :t both
18:20:17 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
18:20:51 * hackagebot chell-hunit 0.1.0.1 - HUnit support for Chell, a quiet test runner  http://hackage.haskell.org/package/chell-hunit-0.1.0.1 (JohnMillikin)
18:20:53 * hackagebot chell-quickcheck 0.1.0.1 - QuickCheck support for Chell, a quiet test runner  http://hackage.haskell.org/package/chell-quickcheck-0.1.0.1 (JohnMillikin)
18:21:13 <jmcarthur> i wish for a different thing a lot, too....
18:21:13 <Jafet> This is the worst pun of the day
18:21:51 <HugoDaniel> :)
18:21:52 <jmcarthur> (a -> b -> c) -> (d -> e -> f) -> (a, d) -> (b, e) -> (c, f)
18:22:07 <slack1256> do you know some step by step evaluator for haskell
18:22:12 <jmcarthur> hat?
18:22:17 <Axman6> ghci can do that can't it?
18:22:18 <jmcarthur> i think it's dead though
18:22:25 <Jafet> @where stepeval
18:22:26 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
18:22:28 <slack1256> something that show the intermediate result of expressions
18:22:30 <jmcarthur> the ghci debugger is pretty bad
18:23:33 <jmcarthur> well, bad in that it kind of naively applies traditional debugging tricks to a lazy language
18:23:38 <jmcarthur> *traditionally
18:23:41 <jmcarthur> err
18:23:45 <jmcarthur> had that right the first time
18:23:49 <jmcarthur> i misread what i just wrote
18:26:19 <slack1256> stepeval seems to be what i am looking for, thanks Jafet
18:27:39 <Jafet> Unfortunately, stepeval implements a small subset of Haskell, and I believe it doesn't implement lazy evaluation
18:28:15 <slack1256> yeah, but is not for me. is for my litle cousin
18:28:21 <slack1256> just enough(tm)
18:32:14 <jmcarthur> huh, annotated splay trees
18:32:28 <jmcarthur> ?hackage splaytree
18:32:28 <lambdabot> http://hackage.haskell.org/package/splaytree
18:51:37 <dylukes> heh
18:51:42 <dylukes> I was just told that this sucks
18:51:42 <dylukes> https://github.com/DylanLukes/STGMA/blob/master/src/Compiler/STGMA/Parse.hs#L42
18:51:46 <dylukes> because its not "at least 1000 lines"
18:51:50 <dylukes> "theres no hard work"
18:52:44 <Kaidelong> dylukes: what manner of person was the person complaining?
18:53:05 <dylukes> Uh
18:53:09 <dylukes> let me just quote him
18:53:16 <dylukes> "LibOpenCraft: haha asm is hard to read but jmp makes it easier"
18:53:20 <napping> do you have to care what they think?
18:53:25 <dylukes> No not really.
18:53:27 <dylukes> But its funny.
18:53:34 <dylukes> "LibOpenCraft: dylukes any real program has over 1000 lines"
18:53:45 <gwern> > 50 * 7
18:53:59 <Kaidelong> bah I'm so confused
18:54:07 <Kaidelong> I think that guy is a troll but I can't tell
18:54:09 <gwern> lambdabot why y no eval
18:54:17 <Kaidelong> @botsnack
18:54:17 <dylukes> http://cl.ly/ADYi
18:54:26 <dylukes> I'm not even sure anymore.
18:55:21 <lambdabot>   350
18:55:21 <lambdabot> :)
18:56:11 <Kaidelong> hi lambdabot, you sure took your time didn't you
18:56:16 <dylukes> Oh god guys
18:56:17 <dylukes> http://cl.ly/ADaj
18:56:20 <dylukes> he knows MICROCHIP.
18:57:22 <dylukes> I'm just going to leave this trollfest.
18:57:28 <dylukes> It's not even funny anymore ¬¨_¬¨
18:58:20 <napping> is microchip that bad?
18:58:33 <dylukes> No, its just that he doesn't actually mean microchip the architecture.
18:58:40 <dylukes> He means micro controller (MIPS in the actual case it seems).
18:58:42 <Kaidelong> microchip is a pretty cool architecture. It does demuxing interpolation and doesn't afraid of anything
18:58:49 <dylukes> Kaidelong: ^
19:01:12 <dylukes> http://cl.ly/ADga
19:01:14 <dylukes> this is amusing.
19:05:29 <edwardk> dylukes: well transmeta did hire linus for a while ;) so a linux processor isn't that far from the truth ;)
19:06:14 <shachaf> edwardk: Was it for Linux-specific purposes?
19:06:23 <edwardk> nah
19:10:33 <dylukes> SET THE CHANNEL
19:10:36 <dylukes> FOR MAXIMUM OVERTROLL
19:10:37 <dylukes> "SpaceManiac: WHY YES MY PROCESSOR IS WRITTEN IN PYTHON"
19:11:00 <Axman6> o.O
19:11:01 <kmc> set the controls for the heart of the sun
19:15:49 <Kaidelong> I can't speak for the minecraft people dylukes
19:15:56 <Kaidelong> but what is this supposed to accomplish
19:16:09 <dylukes> Kaidelong: He's just generally either an idiot or a troll.
19:16:28 <dylukes> He insisted I was wrong and that its correct to do malloc(sizeof(struct some_struct *))
19:16:50 <dylukes> and when the other guys code kept crashing from SIGSEGV, he still insisted he must be doing something wrong.
19:16:52 <shachaf> dylukes: I'm pretty sure only one person in that screenshot can really be described as "trolling".
19:17:40 <napping> anyway, not exactly on topic
19:17:42 <shachaf> dylukes: It *is* correct if you're trying to allocate a pointer on the heap. :-)
19:17:53 <shachaf> Yes, #-blah would be a better place.
19:18:04 <Axman6> dylukes: what, that's not how you allocate pointers to pointers of some_struct?
19:22:06 <dalaing_> I'd be tempted to raise the troll stakes and start talking about how pointer sizes will be different between 32 and 64 bit platforms...
19:23:22 <dalaing_> although knowing my luck that would escape and circulate, and years from now I'd end up having junior software engineers lecture me on how it's the right thing to do
19:27:26 <dylukes> shachaf: yes but that wasnt the goal ;P
19:27:37 <dylukes> and the LHS was struct blah *myBlah
20:55:59 <eyu100> > fix
20:56:00 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a) -> a)
20:56:00 <lambdabot>    arising from a u...
21:16:36 <mzero> nothin' like building GHC from scratch only to discover that you've built it with the wrong configuration settings....
21:16:38 <mzero> :-P
21:17:37 <ddarius> It's not exactly an arduous task.
21:17:58 <ddarius> "nothin' like climbing a mountain, only to discover that you've climbed the wrong mountain"
21:20:45 <edwardk> fiddling with a design for a nicely packed utf-8 charset
21:21:20 <edwardk> basically the bastard child of the HAMT stuff tibbe has been working and joachim's dense intsets and my trifecta charsets
21:21:20 * mzero wonders what that could possibly mean
21:21:54 <dolio> Yeah. The GHC version is more like, "nothing like sitting on your ass for an hour only to find out your computer has been running the wrong thing."
21:23:03 <shachaf> Opportunity cost, dolio!
21:23:12 <shachaf> Think of all the exciting things mzero could have been compiling.
21:23:21 <edwardk> data CharSet = CharSet {-# UNPACK #-} !Int64 {-# UNPACK #-} !Int64 {-# UNPACK #-} !Int64 ByteArray! {-# UNPACK #-} !(Array Leaf) {-# UNPACK #-} !(Array (Node Leaf))  -- with data Leaf = Leaf {-# UNPACK #-} !Int64 ByteArray#  and data Node a = Node {-# UNPACK #-} !Int64 {-# UNPACK #-} !(Array a)
21:24:19 <edwardk> basically storing int64s to indicate which of [0..0x3f] and [0x40..0x7f] can be present covering the ascii range directly with the first two numbers
21:24:39 <edwardk> then using the third to indicate which of [0xc2..0xf4] are valid first bytes
21:26:21 <edwardk> then the least significant 32 bits of that are used HAMT-style abusing popcount as an index into the ByteArray# to find an Int64 representing the tail bytes for the 2 byte unicode characters
21:26:38 <edwardk> and the higher bits are used popcount/hamt style to index into the other two arrays
21:27:10 <edwardk> so every structure there serves multiple purposes
21:27:41 <edwardk> and the shape directly correlates with what i have to do to decode
21:30:08 <edwardk> it winds up with a pretty wide fanout for a hamt, but it correlates directly with the structure of the chars
21:30:28 <edwardk> preflex: xseen tibbe
21:30:28 <preflex>  tibbe was last seen on freenode/#haskell 5 days, 16 hours, 55 minutes and 6 seconds ago, saying: ah
21:36:26 <edwardk> and the overhead for any pure ascii set is 48 bytes, anything which uses a single european 64 byte range is ~64 bytes, the entire <0x7ff european range is ~78 bytes, and the full unicode charset is pretty tiny, so i can avoid using complemented intsets in the charset code
21:40:47 <monochrom> "nothing like looking for a new sea route, only to discover that you've discovered a new continent" XD
21:41:27 <mzero> edwardk - do you know how to force GHC's ./configure to configure the build for 64-bit on Mac OS X?
21:41:38 <edwardk> not off hand
21:41:41 <edwardk> i try to avoid building ghc
21:45:22 <mzero> I generally do too... but the 7.0.4 version of GHC that is available doesn't work on my system due to odd link errors
22:00:51 <ddarius> edwardk: So if I wanted to detect everything that was a valid Unicode code point but not "European," how much space would that tak?
22:01:49 <edwardk> well if 'european' is <0x7ff then that would be about 46 bytes fewer than the full unicode set
22:02:14 <mzero> is all this so you can encode information from the UniData infoset?
22:02:19 <edwardk> if it is more nuanced, then it'd probably be the same size
22:02:49 <edwardk> mzero: i already have some pretty crazily complicated sets for dealing with characters, with all of the unicode and posix blocks marked out
22:02:53 <edwardk> not all are in unidata
22:03:30 <edwardk> http://hackage.haskell.org/packages/archive/trifecta/0.36.3/doc/html/Text-Trifecta-CharSet-Unicode.html and http://hackage.haskell.org/packages/archive/trifecta/0.36.3/doc/html/Text-Trifecta-CharSet-Posix-Unicode.html etc
22:03:40 <edwardk> well those are old versions but still
22:04:32 <edwardk> my main concern is being able to build big charsets correctly and to be able to quickly union, intersect and difference them
22:04:58 <edwardk> and most importantly to know what legal lead bytes there are
22:05:06 <edwardk> currently i cache that
22:05:14 <edwardk> this would make it intrinsic to how i do the decoding
22:31:26 <KirinDave> Damn
22:31:31 <KirinDave> That monad zipper paper blew my mind
22:32:09 <kmc> nice
22:32:27 <shachaf> Should I read that paper?
22:33:06 <kmc> probably
22:41:35 <dalaing_> someone was saying the other day that it was either brilliant or mad
22:42:27 <dalaing_> I only think I "got" monad transformers properly the other day, but the bits I understood / took away from it seemed pretty cool
22:42:46 <hpaste_> cwl pasted ‚Äúlet expr‚Äù at http://hpaste.org/51484
22:43:06 <dalaing_> I'm probably not immersed in it enough to see the madness though
22:43:12 <cwl> please see why this let expression cause error
22:43:35 <cwl> let (!) = flip valFromObj
22:46:01 <cwl> hello?
22:53:39 <ddarius> If the Monad Zipper paper is the one I think it is, I think I filed it under "too cumbersome to use and not much gain."
22:57:34 <dalaing_> I don't know enough to be able to tell :)
22:58:00 <dalaing_> or :( , depending
23:41:38 <kmc> ddarius, i was impressed with one of the things in the intro, modular interpreters or something
23:41:42 <kmc> i guess i have more reading to do
23:42:20 <ddarius> @google modular interpreters and monad transformers
23:42:21 <lambdabot> http://web.cecs.pdx.edu/~mpj/pubs/modinterp.html
23:42:21 <lambdabot> Title: Monad Transformers and Modular Interpreters
23:53:07 <xyz_> pl (\x -> x)
23:54:01 <xyz_> > pl (\x -> x)
23:54:02 <lambdabot>   Not in scope: `pl'
23:55:07 <xyz_> Excuse me, does anyone know how to use lambdabot to compute point-free code?
23:55:31 <dalaing_> @pl (\x -> x x)
23:55:31 <lambdabot> join id
23:55:39 <copumpkin> I'd avoid that one
23:55:40 <xyz_> Thank you.
23:56:04 <dalaing_> I was just trying to see if I remembered :)
23:56:34 <kmc> haha
23:56:40 <kmc> brilliant
23:56:42 <copumpkin> ?
23:56:48 <xyz_> @pl (\f xs ys -> foldr (\x ys -> f x : ys) ys xs)
23:56:48 <lambdabot> flip . foldr . ((:) .)
23:57:05 <kmc> just like the idea of golfing type errors
23:57:50 <ddarius> It's only a type error if one lacks equirecursive types.
