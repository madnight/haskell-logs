00:00:37 <erus`> why not?
00:01:07 <kmc> FastPackedNotAString
00:01:19 <ddarius> erus`: You'll have to ask him.
00:01:22 <kmc> FastPackedStringOnlyForPeopleWhoSpeakEnglish
00:01:56 <ddarius> kmc: So everyone?
00:24:52 <wavewave> Enigmagic: succeed in making the fortran file incorporated in cabal !! thx again!
00:24:56 <wavewave> Enigmagic++
00:29:36 <kmc> this file has 85 lines of code and 15 of them are imports...
00:31:11 <wavewave> import automation would be great
00:31:19 <wavewave> combined with hoogle
00:32:37 <wavewave> more and more, programming is like searching.
00:33:03 <kmc> yeah, that would be cool
00:33:12 <ivanm> I think chrisdone is working on that...
00:33:22 <ivanm> or else would consider adding such functionality to haskell-emacs :p
00:33:27 <wavewave> spending most of the time on googling.
00:41:12 <mgsloan>  /me is working on some stuff along these lines as well
00:42:01 <mgsloan> I was working on something with a much broader scope, along the lines of coding as search
00:43:18 <mgsloan> but was bogged down by the enormity / complexity, so narrowed the scope to useful haskell utilities in the short term
00:44:47 <mgsloan> I'd be happy with just automatic import reduction / enumeration of all top-level items
00:44:59 <Nafai> mgsloan: that would be awesome
00:45:17 <blackdog> kmc: i've been playing around with having modules that just re-export other modules
00:45:22 <blackdog> it works ok until you want them qualified
00:45:56 <ivanm> blackdog: it'd be nice if you could specify which modules you want to re-import in an import list in those cases as well
00:46:16 <ivanm> rather than the module statements in the export lists being replaced with the functions, etc. that are being re-exported :s
00:46:24 <Nafai> can you have one module re-export a single item from another?
00:46:39 <mgsloan> yup
00:46:39 <ivanm> Nafai: sure
00:46:48 <ivanm> but you need an explicit export list
00:46:59 <Nafai> right, I imagined so
00:47:19 <Nafai> cool, that might work for something I'm thinking about
00:47:24 <Nafai> I'll have to do some experimentation
00:52:31 <blackdog> ivanm: not sure what you mean. you can do "module Foo(module OtherModule, somefunc)"
00:52:55 <ivanm> blackdog: well, import Foo hiding (module Bar) or something, yeah
00:59:35 <quicksilver> @tell Cale that update and construction are not first class (and, therefore, field names aren't really first class). Yes, Lenses would be better than extractor functions.
00:59:35 <lambdabot> Consider it noted.
01:01:24 <blackdog> ivanm: ah, so you can't pick and choose when you import. yeah, it all seems to get mixed in
01:04:22 <jules2> has a real world application been written using FRP?
01:04:30 <dibblego> is there a zipper for Data.Map?
01:05:18 <ivanm> don't think so
01:05:25 <ivanm> (to dibblego; no idea bout FRP)
01:06:18 <jules2> i have trouble writing even a simple FRP application like a todo list manager, but I'd like to learn how and perhaps there is some example somewhere?
01:08:41 <mgsloan> wasn't frag kinda frp-ed
01:08:43 <mgsloan> ?
01:09:15 <mgsloan> then again 2005 frp probably looks a lot different than 2011
01:11:09 <ivanm> I think apfelmus was working on some examples using reactive-banana
01:11:16 <ivanm> @google frp examples
01:11:23 <lambdabot> http://www.fiberglasstechnologies.com/Examples.asp
01:11:23 <lambdabot> Title: Examples of Fiberglass Columns, Cornices, Decorative Medallions & Moldings
01:11:23 <ivanm> bah
01:11:24 <ivanm> @google frp examples site:reddit.com/r/haskell
01:11:27 <lambdabot> http://www.reddit.com/r/haskell/comments/g943x/demonstrating_a_time_leak_in_arrowized_frp/
01:11:27 <lambdabot> Title: Demonstrating a Time Leak in Arrowized FRP : haskell
01:11:31 <ivanm> that's not it
01:12:05 <ivanm> ahhh, apfelmus wanted examples for FRP GUIs
01:12:37 <ivanm> jules2: there's this, but I don't know how up-to-date it is: http://www.formicite.com/dopage.php?frp/frp.html
01:13:14 <ivanm> jules2: the dow package on hackage apparently is a game using FRP
01:13:23 <ivanm> and then there's http://apfelmus.nfshost.com/blog/2011/07/08-call-for-gui-examples.html
01:14:05 <jules2> actually i'm looking more for information on how to write GUI applications in a composable way, not games or simulations
01:14:17 <ivanm> jules2: well, that's what the last link is for!
01:14:34 <ivanm> so it seems apfelmus wants to write said examples, so maybe contact him and see if he's done anything already
01:15:23 <jules2> yup what he is looking for is exactly what i'm looking for
01:15:55 <ivanm> he might have written something already but not released it
01:16:39 <hpaste> cwl pasted “callCC” at http://hpaste.org/51319
01:17:09 <cwl> I am puzzled with the when
01:17:29 <ion> over NINE THOUSAND
01:18:15 <cwl> @src when
01:18:15 <lambdabot> when p s = if p then s else return ()
01:19:34 <Axman6> :t callCC
01:19:34 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
01:20:06 <Axman6> load error? never seen that before...
01:20:28 <cwl> Axman6: load foo.hs failed
01:21:19 <Axman6> is that the only error you get?
01:21:27 <Axman6> when you do :load foo.hs?
01:21:44 <quicksilver> well (Just "over twenty") does not have type Cont r String
01:21:50 <quicksilver> it has type Maybe String
01:22:13 <quicksilver> showing us the error message is good in general though :)
01:22:16 <cwl> Axman6: after write the file foo.hs with function foo
01:22:40 <Axman6> cwl: can you paste exactly what error you get? we can't help without all the information
01:22:59 <ivanm> Axman6: you want the error? YOU CAN"T HANDLE THE ERROR!
01:23:05 <ivanm> sorry, don't know what got into me...
01:23:06 <ivanm> :p
01:23:06 <Axman6> D:
01:23:09 <jules2> ivanm: stalking apfelmus' online identity I arrived at this list of examples via his stackoverflow profile: http://www.haskell.org/haskellwiki/Reactive-banana/Examples
01:23:20 <jules2> thanks for your help :)
01:23:23 <ivanm> np
01:23:41 <hpaste> cwl pasted “foo.hs” at http://hpaste.org/51320
01:24:17 <cwl> Axman6: http://hpaste.org/51320
01:24:46 <ivanm> so it's a type-mismatch
01:24:51 <Axman6> well, the error is pretty clear
01:24:57 <Axman6> :t Just "foo"
01:24:58 <lambdabot> Maybe [Char]
01:25:13 <Axman6> :t when True (Just "foo")
01:25:14 <lambdabot>     Couldn't match expected type `()' against inferred type `[Char]'
01:25:14 <lambdabot>     In the first argument of `Just', namely `"foo"'
01:25:14 <lambdabot>     In the second argument of `when', namely `(Just "foo")'
01:25:15 <ivanm> @type calCC
01:25:16 <lambdabot> Not in scope: `calCC'
01:25:20 <ivanm> @type callCC
01:25:21 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
01:25:27 <ivanm> oh, right, just in the when
01:25:44 <ivanm> cwl: it works in your first example, because there you might have that k :: String -> ()
01:26:37 <cwl> ivanm: in the first Example, k is Just
01:26:43 <cwl> :t Just
01:26:44 <lambdabot> forall a. a -> Maybe a
01:27:03 <Axman6> no it's not
01:27:27 <Axman6> :t callCC (\k -> when True (k "Hello"))
01:27:28 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `()'
01:27:28 <lambdabot>       Expected type: m [Char]
01:27:28 <lambdabot>       Inferred type: m ()
01:27:30 <ivanm> @type runCont
01:27:31 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
01:29:03 <cwl> :t callCC $ \k -> when True (k "hi")
01:29:04 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `()'
01:29:04 <lambdabot>       Expected type: m [Char]
01:29:04 <lambdabot>       Inferred type: m ()
01:29:42 <quicksilver> cwl: in (callCC $ \k -> .....), callCC's parameter has type (a -> m b) -> m a
01:30:05 <quicksilver> cwl: so "k" (which is the lambda binding the first parameter of this) has type (a -> m b)
01:30:20 <quicksilver> in your example, the monad was polymorphic Cont r
01:30:26 <binsh> :t tail
01:30:27 <lambdabot> forall a. [a] -> [a]
01:30:33 <binsh> nice
01:30:33 <quicksilver> so "k" has type (a -> Cont r b)
01:32:09 <kmc> ugh, i hate making decisions about concrete syntax
01:32:17 <kmc> it's so subjective / arbitrary / underspecified
01:32:30 <cwl> :t when
01:32:31 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
01:32:36 <kmc> and yet it has a huge effect for the people who use your language / library
01:32:46 <kmc> and largely determines success / failure
01:33:11 <kmc> @src when
01:33:11 <lambdabot> when p s = if p then s else return ()
01:33:21 <cwl> quicksilver: when True $ k "xxx" should fail then
01:37:41 <quicksilver> cwl: why?
01:37:50 <hpaste> cat pasted “cat” at http://hpaste.org/51321
01:38:44 <andras> can anyone tell me why this program: http://hpaste.org/51321 behaves differently when run using runghc than when compiled using ghc?
01:39:20 <andras> if I compile it (ghc -o test test.hs) and run the executable, it works as expected (does nothing forever)
01:40:14 <andras> if I run it using "runghc test.hs", it "timeouts" after a few seconds, it doesn't wait for the output from cat forever
01:40:17 <andras> any ideas?
01:41:03 <andras> I use ghc 6.12.1
01:42:54 <andras> (from debian stable)
01:53:26 * hackagebot OpenCL 1.0.1.3 - Haskell high-level wrapper for OpenCL  http://hackage.haskell.org/package/OpenCL-1.0.1.3 (LuisCabellos)
02:02:18 <hpaste> “md2perpe+hpaste@gmail.com” annotated “trying to build an exception predicate for catchJust” with “trying to build an exception predicate for catchJust (annotation)” at http://hpaste.org/51318#a51323
02:08:35 <hpaste> “md2perpe+hpaste@gmail.com” annotated “Pattern Match Overlap” with “Pattern Match Overlap (annotation)” at http://hpaste.org/51313#a51324
02:12:46 <cwl> http://hpaste.org/51319
02:13:11 <cwl> (runCont $ foo 2) read :: Int
02:13:51 <cwl> can return be used for non-monad
02:14:32 <geekosaur> no; it's defined specifically in the context of Monad
02:14:42 <kmc> :t return
02:14:43 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
02:14:47 <geekosaur> (but in your paste, it's in the context of a Cont monad)
02:14:57 <kmc> return :: (Monad m) => a -> m a
02:15:47 <cwl> foo n :: Int -> Cont r String; foo n = callCC $ \k -> return (show "4")
02:15:59 <kmc> > show "4"
02:16:00 <lambdabot>   "\"4\""
02:16:09 <cwl> sorry
02:16:12 <cwl> show 4
02:16:15 <cwl> not "4"
02:16:32 <cwl> (runCont $ foo 10) read :: Int
02:16:54 <geekosaur> > let foo n :: Int -> Cont r String; foo n = callCC $ \k -> return (show 4) in (runCont $ foo 10) read :: Int
02:16:55 <lambdabot>   <no location info>: Invalid type signature
02:16:58 <geekosaur> bah
02:17:04 <cwl> return (show 4) is just "4" not m "4"
02:17:47 <geekosaur> actually it is m "4" for m = Cont; than's then unwrapped by runCont
02:22:14 <cwl> geekosaur: unwrapped by runCont will result in a function
02:22:18 <cwl> \k -> ..
02:23:13 <Phyx-> :t runCont
02:23:14 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
02:23:18 <erus`> cwl:  i thought     return :: a -> M a
02:23:55 <Phyx-> cwl: geekosaur the argument passed to runCont is a Cont. which is a monad so return would be in the Cont monad
02:24:01 <Phyx-> err
02:24:05 <Phyx-> geekosaur means
02:24:11 <Phyx-> should be before that sentence
02:27:04 <cwl> :t when
02:27:04 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
02:27:24 <cwl> when (n' > 20) $ k "over twenty"
02:27:38 <cwl> k "over twenty" must have type m () ?
02:27:59 <quicksilver> correct.
02:28:10 <quicksilver> and the monad in your case is Cont r
02:28:13 <quicksilver> so, Cont r ()
02:28:50 <cwl> and k has type String -> Cont r ()
02:28:55 <quicksilver> right
02:29:16 <cwl> (runCont $ foo 10) Just
02:29:27 <cwl> Just has type String -> Cont r () ?
02:29:37 <quicksilver> nope
02:29:53 <cwl> Just is not placed with k?
02:29:54 <quicksilver> look at the type of runCont
02:30:04 <cwl> :t runCont
02:30:05 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
02:30:07 <quicksilver> Just is not placed with k, no.
02:30:23 <quicksilver> Just has type a -> r here
02:31:00 <cwl> doesn't runCont just extract the function \k -> .. out?
02:31:13 <quicksilver> it's not that simple, no.
02:31:33 <cwl> @src runCont
02:31:33 <lambdabot> Source not found. Maybe if you used more than just two fingers...
02:31:37 <geekosaur> Cont is a bit mind-bending
02:31:40 <cwl> @src Cont
02:31:41 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
02:31:59 <cwl> @src callCC
02:31:59 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
02:32:05 <cwl> :t callCC
02:32:06 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
02:33:39 <cwl> it is callCC not that simple, I think
02:34:45 <cwl> another question of when
02:34:55 <quicksilver> http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
02:34:59 <quicksilver> might be helpful, cwl
02:35:03 <quicksilver> although I've not read it myself
02:35:25 <cwl> quicksilver: my question comes from there :-)
02:35:42 <cwl> at the callCC section
02:35:57 <quicksilver> :)
02:36:02 <cwl> another question of when
02:36:09 <cwl> when True monad1
02:36:14 <cwl> when True monad2
02:36:39 <cwl> both monad1 and mond2 will be execute
02:36:42 <cwl> right?
02:36:59 <cwl> and monad2 as result
02:37:13 <quicksilver> there will be no result
02:37:18 <quicksilver> when statements don't have a result
02:37:30 <cwl> do
02:37:33 <quicksilver> but yes, they will both be executed... depending exactly what executed :)
02:37:40 <cwl> when True (return 1)
02:37:41 <quicksilver> sorry...
02:37:44 <cwl> when True (return 2)
02:37:50 <geekosaur> usually.  Cont is a form of non-local flow control; executing the computation "k" aborts evaluation and produces whatever argument is given to k
02:37:55 <quicksilver> depending exactly what executed means in this monad context.
02:38:00 <quicksilver> cwl: that's illegal.
02:38:07 <quicksilver> :t when True (return 1)
02:38:08 <lambdabot>     No instance for (Num ())
02:38:08 <lambdabot>       arising from the literal `1' at <interactive>:1:18
02:38:08 <lambdabot>     Possible fix: add an instance declaration for (Num ())
02:38:12 <geekosaur> those are type errors, since when expects the monads to produce ()
02:38:17 <cwl> a
02:38:22 <quicksilver> cwl: 'when' only takes things which product no result - m ()
02:38:32 <cwl> quicksilver: my mistake
02:38:37 <cwl> do
02:38:41 <quicksilver> because that's the only way to be consistent with the condidtion being false.
02:38:44 <cwl> when True (return ())
02:38:49 <cwl> return 2
02:39:26 <cwl> http://monads.haskell.cz/html/contmonad.html
02:39:42 <cwl> I don't understand example18
02:40:00 <andras> can anyone tell me why this program: http://hpaste.org/51321 behaves differently when run using runghc than when compiled using ghc?
02:40:03 <cwl> when ((length ns) < 3) (exit2 (length ns))
02:40:15 <andras> if I compile it (ghc -o test test.hs) and run the executable, it works as expected (does nothing forever)
02:40:18 <andras> if I run it using "runghc test.hs", it "timeouts" after a few seconds, it doesn't wait for the output from cat forever
02:40:23 <andras> any ideas?
02:40:26 <cwl> when ((length ns) <5) (exit2 n)
02:40:58 <quicksilver> cwl: calling the continuation immediately exits that particular callCC, with that value as the result.
02:41:20 <quicksilver> cwl: so, calling exit2 exits the inner callCC and gives a value to n'
02:41:23 <osfameron> yay! matrixMultiply m1 m2 = [[ sum (zipWith (*) row col) | col <- transpose m2 ] | row <- m1 ]
02:41:38 <quicksilver> calling exit1 exits the outer one.
02:41:40 <osfameron> (I'm sure there's a good library to use instead of course)
02:42:37 <geekosaur> andras: what platform, what ghc version?  It sounds like a bug in the runtime, of which there have been several at various times
02:43:45 <geekosaur> (one difference:  runghc uses the threaded runtime.  does ghc --threaded fail the same way?)
02:46:10 <andras> geekosaur: it's ghc 6.12.1 on debian stable
02:46:27 <cwl> >_< haskell kill brain cells
02:47:03 <geekosaur> Cont kills brain cells...
02:47:08 <erus`> I tried Haskell once... Now I'm gay.
02:47:19 <andras> geekosaur: yes, ghc with -threaded causes the same issue...
02:47:31 <knoc> What is the common way to capitalize strings? I did it with 'toUpper (head xs) : tail xs'
02:47:37 <Phyx-> erus`: i'm not sure those two are related...
02:47:59 <koeien> knoc: try not to use head and tail, but instead use pattern matching
02:48:14 <cwl> geekosaur: callCC kills more
02:48:14 <koeien> knoc: capitalize [] = -- What is the empty word that is capitalize
02:48:26 <koeien> knoc: capitalize (x:xs) = toUpper x : xs
02:49:02 <knoc> ah, I see the problem ;) thanks
02:49:09 <quicksilver> cwl: callCC provides you with an 'exit' function you can use to exit early.
02:49:31 <quicksilver> the examples on monads.haskell.cz demonstrate this better than the ones on the wikibook, IMO.
02:49:39 <erus`> koeien: knoc: capitalize (x:xs) = toUpper x : capitalize xs
02:49:52 <andras> geekosaur: so why does the threaded runtime do that?
02:50:03 <cwl> quicksilver: callCC f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k
02:50:12 <cwl>         when (n' > 20) $ k "over twenty"
02:50:19 <koeien> erus`: ah, I thought only the first character. otherwise, just map toUpper
02:50:20 <knoc> I would get trouble with empty strings
02:50:24 <cwl>         return (show $ n' - 4)
02:50:44 <quicksilver> cwl: and your question is?
02:50:46 <cwl> I know return (show $ n' - 4) should have type Cont
02:50:58 <koeien> Cont is not a type.
02:51:00 <erus`> ah maybe im wrong
02:51:04 <quicksilver> Cont r String, yes.
02:51:05 <cwl> Cont r a
02:51:07 <knoc> koeien: your solution is what I wanted^^
02:51:16 <cwl> the type of a when expr
02:51:49 <cwl> :t when (n' > 20) $ k "over twenty"
02:51:49 <lambdabot> Not in scope: `n''
02:51:58 <cwl> :t when True $ k "over twenty"
02:51:58 <lambdabot>     Couldn't match expected type `[Char] -> m ()'
02:51:59 <lambdabot>            against inferred type `Expr'
02:51:59 <lambdabot>     In the second argument of `($)', namely `k "over twenty"'
02:52:41 <geekosaur> andras: it's a bug.  I think a known bug in 6.12.1; there are later versions
02:52:42 <quicksilver> cwl: lambdabot doesn't know what k is; it only makes sense when k is bound by \k ->
02:52:54 <quicksilver> cwl: what are you trying to work out?
02:53:14 <applicative> knoc, theres also capitalize xs = map toUpper xs
02:53:27 <quicksilver> applicative: that's precisely what he doesn't want?
02:53:38 <cwl> :t \k -> when True $ k "over"
02:53:38 <lambdabot> forall (m :: * -> *). (Monad m) => ([Char] -> m ()) -> m ()
02:53:39 <quicksilver> applicative: toUpper (head xs) : tail xs is not map toUpper xs :P
02:53:54 <applicative> initial capital; got it
02:54:02 <cwl> when True $ k "over" has type m ()
02:54:10 <cwl> but we need Cont r String
02:56:29 <quicksilver> cwl: what makes you think you need Cont r String?
02:56:40 <quicksilver> cwl: not every statement in a do block needs to have the same type.
02:56:44 <andras> geekosaur: thanks, will avoid -threaded for the time being.
02:56:51 <quicksilver> consider this one : do { putStrLn "hi"; return 5 }
02:57:00 <erus`> how do people stub out there whole program?
02:57:00 <quicksilver> cwl: the first statement is IO (), the second is IO Int
02:57:08 <erus`> just make functions return error ?
02:57:11 <kamaji> Gentlemen.
02:57:20 <geekosaur> (where? :)
02:57:27 <koeien> erus`: yes, usually error "TODO" or just undefined
02:57:39 <kamaji> hoho
02:58:28 <erus`> > let moo _ = undefined in moo 123
02:58:29 <lambdabot>   *Exception: Prelude.undefined
02:58:34 <quicksilver> erus`: I tend to develop bottom-up not top-down
02:58:44 <erus`> i didnt know about undefined :)
02:58:50 <koeien> @src undefined
02:58:50 <lambdabot> undefined =  error "Prelude.undefined"
02:58:53 <quicksilver> so I don't stub out at all. I make small parts which work, test them independently, and then join them together.
02:59:31 <applicative> erus' did you see the amusing progress of modules in http://cdsmith.wordpress.com/2011/09/10/haskell-for-kids-week-4/ (it used 'blank' the empty diagram)
02:59:37 <erus`> quicksilver: yeah but when i go to fit all the small things together I like to test it while I am still fitting
03:00:01 <erus`> well compile/prove
03:00:21 <quicksilver> I do that when I have enough parts to make a minimal big thing
03:00:24 <quicksilver> and then there is no need for stubs
03:00:32 <quicksilver> the big thing only connects the little things I currently have.
03:00:45 <quicksilver> I'm not saying it's the only way, though :) Lots of people like stubs.
03:17:29 <epsilonhalbe> hey is there a function that generates all subsets of a list with n elements, if yes what is its name ?
03:17:52 <epsilonhalbe> or do i have to write it myself (no problem i think)
03:18:33 <quicksilver> > subsequences [1..4]
03:18:34 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,...
03:18:39 <quicksilver> epsilonhalbe: ^^
03:18:50 <quicksilver> see http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html for more useful stuff.
03:19:10 <cwl> quicksilver: I understand now
03:19:16 <cwl>     callCC f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k
03:19:36 <rexim> filter ((n==).length) $ subsequences xs
03:19:42 <quicksilver> understanding the *definition* of callCC is rather different from understanding how to use it, I'd say.
03:19:43 <ivanm> quicksilver: that's not quite what he asked for
03:19:44 <cwl> f (\a -> Cont $ \_ -> k a) :: Cont a ()
03:20:00 <cwl> quicksilver: so it suit for when
03:20:03 <ivanm> epsilonhalbe: you want to get all combinations of size n?
03:20:10 <quicksilver> ivanm: subsequences (in that sense) are the same as subsets.
03:20:16 <ivanm> epsilonhalbe: if so, do you have possibly repeats?
03:20:21 <quicksilver> ivanm: he asked for subsets, not combinations.
03:20:23 <ivanm> quicksilver: he did say "with n elements"
03:20:29 <cwl> quicksilver: you are right, but before know how to use it I should know the definition
03:20:47 <quicksilver> I read that as "list with n elements"
03:20:55 <ivanm> hmmm.... maybe
03:21:04 <quicksilver> if it was "subset with n elements" then, yes, it wasn't right :)
03:21:09 <quicksilver> cwl: I don't really agree.
03:21:16 <epsilonhalbe> i thought of rexim's ide but doesn't have to be all subsequences of [1..100] be generated and most of them filtered out  -isn't this overkill
03:21:23 <cwl> quicksilver: why
03:21:39 <quicksilver> cwl: I don't think understanding the definition of callCC is particularly relevant to using it.
03:21:47 <quicksilver> in particular, I can't explain the defintion, but I can use it.
03:22:05 <quicksilver> I'm sure if I sat down with a pen and a paper and a couple of spare hours I could decode it, but I'm not inclined to :)
03:22:09 <cwl> quicksilver: you may got good documentation for it
03:22:14 <geekosaur> I worked through the definition once.  figured it out but can't recall now and need to go through it again
03:22:20 <geekosaur> *but* it exists and I can use it fine
03:22:24 <ivanm> epsilonhalbe: so you want all combinations of size n?
03:22:30 <geekosaur> don't need to know the magic behind it
03:22:34 <epsilonhalbe> yes ivanm
03:22:41 <ivanm> epsilonhalbe: do you have repeats?
03:22:42 <epsilonhalbe> i think so
03:22:46 <epsilonhalbe> no repeats
03:22:53 <ivanm> OK, that makes it simpler
03:23:05 <quicksilver> if you want the N-subsets then the subsequences definition is horribly inefficient
03:23:05 <geekosaur> (in a certain sense, that's what Monad is about:  hiding the plumbing so you don't need to think about it, you can just use it and it works)
03:23:09 <quicksilver> so, don't do it that way :)
03:23:19 <quicksilver> except for small lists where the inefficiency doesn't matter.
03:23:20 <ivanm> I don't think there's an existing function in Data.List, but there are some libraries that have something like that defined
03:23:21 <epsilonhalbe> n over k - many, choose k elements from a n- element set
03:23:22 <cwl> quicksilver: shouldn't a newer work on understanding the definition?
03:23:31 <quicksilver> ivanm: I disagree, repeats is easier :)
03:23:41 <geekosaur> in general yes, but Cont is fairly advanced hackery
03:23:43 <quicksilver> > replicateM 4 [1..7]
03:23:44 <lambdabot>   [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,1,4],[1,1,1,5],[1,1,1,6],[1,1,1,7],[1,1...
03:23:50 <ivanm> quicksilver: there are more pre-defined definitions without repeats than with repeats
03:23:56 <moriramar> Excuse me, while Pointfree at HaskellWiki takes "fn = f . g . h better than fn x = f (g (h x))" as example, is it really suggested to write "flip compare x $ div y z" instead of "compare (div y z) x"?
03:23:59 <ivanm> quicksilver: oh, that works if you don't care how many repeats
03:24:00 <quicksilver> ivanm: ^^ with repeats is a library function.
03:24:03 * quicksilver ndos
03:24:14 <ivanm> quicksilver: I've had to do cases of something like comb 3 [1,2,1,5,2]
03:24:21 <quicksilver> ah right
03:24:22 * quicksilver nods
03:24:25 <ivanm> i.e. you have a fixed multiplicity
03:25:19 <epsilonhalbe> choose 2 [0..2] -> [[0,1],[0,2],[1,2]] should be the result
03:26:00 <ivanm> epsilonhalbe: what about choose 2 [0,1,0,2] ?
03:26:30 <epsilonhalbe> i only have distinct elements
03:26:34 <epsilonhalbe> no doubles
03:26:56 <ivanm> oh, right, sorry, missed that
03:27:21 <osfameron> moriramar: I think it's a matter of personal preference.  Using whichever is clearest (to you) is probably the best.
03:27:54 <ivanm> epsilonhalbe: have a look through http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=combinations
03:28:51 <epsilonhalbe> it's always worth to ask here - i knew about hoogle but not hayoo - thx
03:28:54 <epsilonhalbe> ;-)
03:29:09 <ivanm> epsilonhalbe: hayoo searches all of hackage, but isn't quite as precise as hoogle
03:29:49 <ivanm> epsilonhalbe: also http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=Int+-%3E+[a]+-%3E+[[a]]
03:29:50 <moriramar> osfameron: Ahhh, I see. Thank you! :)
03:29:59 <epsilonhalbe> aah - that's something i looked for a while ago
03:32:25 <hpaste> cwl pasted “why the last return is skipped” at http://hpaste.org/51326
03:32:42 <epsilonhalbe> thanksalot ivanm
03:32:44 <cwl> still callCC
03:32:49 <ivanm> np
03:33:01 <ivanm> cwl: how is it being skipped?
03:33:23 * ivanm isn't familiar with callCC
03:33:36 <cwl> ivanm: if expr after when is True, then the return ... make no sense
03:33:53 <ivanm> why doesn't it make sense?
03:34:06 <ivanm> cwl: do you mean that if the condition is true, then callCC doesn't continue on?
03:34:07 <cwl> ivanm: it is not 'returned'
03:34:13 <cwl> ivanm: yes
03:34:13 <ivanm> or that you don't see the value from inside the when?
03:34:22 <ivanm> yes to which? :p
03:34:36 <arcatan> i know nothing about callCC, but maybe that should be like k $ if n' > 20 then "over twenty" else show (n' - 4)
03:34:44 <ivanm> I would guess that depends upon the Monad instance
03:34:49 <cwl> ivanm: I don't see the value of (show $ n' - 4)
03:35:02 <ivanm> arcatan: well, inside IO a when statement is just a side-effect, it doesn't change control flow
03:35:13 <ivanm> but maybe in callCC it does
03:35:22 <quicksilver> cwl: that's the whole point, yes.
03:35:29 <quicksilver> cwl: the cont monad is a control flow monad
03:35:43 <quicksilver> cwl: so if you use the 'escape continuation' then some statements don't take effect.
03:36:19 <quicksilver> ivanm: the 'when' isn't changing control flow.
03:36:26 <quicksilver> when True is id, after all.
03:36:47 <quicksilver> it's the use of the callCC continuation - called "k" in that example - which changes control flow.
03:36:47 <cwl> quicksilver: how callCC change the control flow
03:37:14 <quicksilver> when you call "k" the value you pass to it is immediately returned from the callCC
03:37:25 <quicksilver> and the rest of the action "doesn't happen"
03:37:40 <ivanm> quicksilver: oh, so it's the k that changes the control flow?
03:37:42 <quicksilver> a similar effect to throwing an exception, in languages which support them.
03:37:43 <quicksilver> ivanm: yes.
03:37:55 <quicksilver> ivanm: (or it's the callCC which does, depending how philosophical you are being)
03:38:12 <quicksilver> indeed, you can implement callCC using exceptions, generally
03:39:02 <aspect> only upward continuations
03:39:03 <arcatan> i guess you could implement exceptions using callCC, then :)
03:39:47 <cwl> :t callCC $ \k -> do when True $ k "true"
03:39:48 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `()'
03:39:48 <lambdabot>       Expected type: m [Char]
03:39:48 <lambdabot>       Inferred type: m ()
03:40:15 <cwl> :t callCC $ \k -> do {when True $ k "true"}
03:40:16 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `()'
03:40:16 <lambdabot>       Expected type: m [Char]
03:40:16 <lambdabot>       Inferred type: m ()
03:40:17 <ivanm> cwl: using $ there will cause problems
03:40:30 <cwl> :t callCC $ \k -> do {when True (k "true")}
03:40:31 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `()'
03:40:31 <lambdabot>       Expected type: m [Char]
03:40:31 <lambdabot>       Inferred type: m ()
03:40:33 <ivanm> :t callCC $ \ k -> when True (k "true")
03:40:34 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `()'
03:40:34 <lambdabot>       Expected type: m [Char]
03:40:34 <lambdabot>       Inferred type: m ()
03:40:37 <quicksilver> cwl: that's just an ambigous type error
03:40:45 <quicksilver> annoying confused by lambdabot's stupid defaulting.
03:41:10 <cwl> :t callCC $ \k -> do {when True (k "true") ; return "false"}
03:41:11 <lambdabot> forall (m :: * -> *). (MonadCont m) => m [Char]
03:41:17 <cwl> quicksilver: see that?
03:41:21 <ivanm> quicksilver: I was wondering if lambdabot had extra defaulting
03:41:23 <quicksilver> yeah, sorry, I saw wrong.
03:41:24 <cwl> strange
03:41:26 <quicksilver> it wasn't defaulting.
03:41:53 <quicksilver> it's that the main return type of the callCC block has to match the escape return type
03:42:15 <quicksilver> so the last statement in the callCC block must be "m a" where "a" is also the type you pass to k
03:42:19 <quicksilver> if you ever use k.
03:42:37 <quicksilver> because callCC must return a consistent type in the end
03:43:49 <cwl> >runCont (callCC $ \k -> do {when True (k "true") ; return "false"}) Just
03:43:57 <cwl> > runCont (callCC $ \k -> do {when True (k "true") ; return "false"}) Just
03:43:58 <lambdabot>   Just "true"
03:44:21 <quicksilver> it's probably simpler to use id as the final parameter to runCont in examples
03:44:41 <quicksilver> the purpose of having anything other than 'id' there is to allow an escape path of a different type to the main path
03:44:49 <quicksilver> ...which is required for useful compostionality
03:45:01 <quicksilver> but not necessarily used in final code.
03:45:08 <quicksilver> that's why the examples on monads.haskell.cz all use id
03:46:07 <cwl> runCont (callCC $ \k -> do {when True (k "true") ; return  "false"} ) id
03:46:12 <cwl> > runCont (callCC $ \k -> do {when True (k "true") ; return  "false"} ) id
03:46:13 <lambdabot>   "true"
03:46:32 <cwl> > runCont (callCC $ \k -> do {when True (k "true") ; return  "false"; return "xxx"} ) id
03:46:33 <lambdabot>   "true"
03:46:50 <cwl> > runCont (callCC $ \k -> do {when False (k "true") ; return  "false"; return "xxx"} ) id
03:46:50 <lambdabot>   "xxx"
03:47:15 <cwl> > runCont (callCC $ \k -> do {when False (k "true") ; when True (return  ()); return "xxx"} ) id
03:47:16 <lambdabot>   "xxx"
03:47:33 <erus`> :t callCC
03:47:34 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
03:48:13 <cwl> quicksilver: know the behaviour of callCC, but very confused how it does
03:48:20 * erus` brain asplode
03:48:42 <hpc> cwl: look on the haskell wikibook sometime; it's one damned ugly function
03:48:53 <hpc> just worry about what it does for now
03:49:01 <hpc> so you don't go crazy
03:49:49 <cwl> hpc: ok, just take use of it
03:50:27 <hpc> @src callCC
03:50:27 <lambdabot> Source not found. Where did you learn to type?
03:53:11 <rostayob> @dijinn callCC
03:53:11 <lambdabot> -- f cannot be realized.
03:53:17 <rostayob> :t callCC
03:53:18 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
03:53:34 <rostayob> @dijinn callCC :: ((a -> m b) -> m a) -> m a
03:53:34 <lambdabot> Cannot parse command
03:53:45 <rostayob> @djinn callCC :: ((a -> m b) -> m a) -> m a
03:53:45 <lambdabot> Cannot parse command
03:53:57 <rostayob> @djinn callCC ? ((a -> m b) -> m a) -> m a
03:53:57 <lambdabot> Cannot parse command
03:54:00 <rostayob> aaaahhh
03:54:01 <magicman> @djinn ((a -> m b) -> m a) -> m a
03:54:01 <lambdabot> -- f cannot be realized.
03:54:18 <magicman> @djinn Monad m => ((a -> m b) -> m a) -> m a
03:54:18 <lambdabot> -- f cannot be realized.
03:54:29 <hpc> @djinn ((a -> (b -> r)) -> (a -> r)) -> (a -> r)
03:54:29 <lambdabot> -- f cannot be realized.
03:54:36 <rostayob> @djinn callCC ? ((a -> C b) -> C a) -> C a
03:54:37 <lambdabot> Cannot parse command
03:54:42 <rostayob> @djinn ((a -> C b) -> C a) -> C a
03:54:42 <lambdabot> Error: Undefined type C
03:55:11 <ivanm> @djinn ((a -> m b) -> m a) -> m a
03:55:11 <lambdabot> -- f cannot be realized.
03:55:30 <ivanm> oh, magicman tried that one already
03:55:45 <rostayob> @djinn ((a -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> ((a -> r) -> r)
03:55:46 <lambdabot> f a b = a (\ c _ -> b c) b
03:55:48 <rostayob> YES
03:56:17 <rostayob> @djinn ((a -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> (a -> r) -> r
03:56:18 <lambdabot> f a b = a (\ c _ -> b c) b
03:59:35 <erus`> @djinn m a -> (m (m (m a -> b) -> b) -> a) -> b) -> b
03:59:36 <lambdabot> Cannot parse command
03:59:44 <erus`> @djinn m a -> (m (m (m a -> b) -> b) -> a) -> b
03:59:45 <lambdabot> -- f cannot be realized.
03:59:52 <erus`> @djinn m a -> (m (m (m a -> b) -> b) -> a) -> a
03:59:53 <lambdabot> -- f cannot be realized.
03:59:57 <erus`> damn :|
04:05:42 <ivanm> @djinn (a -> m b) -> m a -> m b
04:05:42 <lambdabot> -- f cannot be realized.
04:06:00 <ivanm> OK, what _can_ djinn do with monads?
04:06:30 <applicative> @djinn Monad m => x -> m x
04:06:30 <lambdabot> -- f cannot be realized.
04:07:04 <applicative> @djinn  Monad m => a -> m a
04:07:05 <lambdabot> f = return
04:07:29 * applicative is trying to be shocked
04:08:08 <ivanm> O...K...
04:08:32 <quicksilver> that's very odd
04:08:42 <quicksilver> surely djinn doesn't care what variables are called?
04:08:47 <quicksilver> @djinn x -> x
04:08:47 <lambdabot> f a = a
04:08:48 <ivanm> maybe to do with how monads are defined? i.e. only m a, m b, etc.
04:08:54 <ivanm> I think I might have seen something along those lines
04:08:57 <ivanm> @google djinn monads
04:08:59 <lambdabot> http://swik.net/djinn+monads
04:08:59 <lambdabot> Title: djinn + monads - SWiK
04:09:30 <quicksilver> weird
04:09:31 <ivanm> great, that swik page has only one link, which doesn't work :/
04:09:48 <quicksilver> I wonder why they even bothered with making that example work if that's all it can do
04:10:24 <dmwit> ?djinn-env
04:10:24 <lambdabot> data () = ()
04:10:24 <lambdabot> data Either a b = Left a | Right b
04:10:24 <lambdabot> data Maybe a = Nothing | Just a
04:10:24 <lambdabot> data Bool = False | True
04:10:24 <lambdabot> data Void
04:10:26 <lambdabot> type Not x = x -> Void
04:10:28 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
04:10:30 <lambdabot> class Eq a where (==) :: a -> a -> Bool
04:10:49 <dmwit> ?djinn Eq x => x -> x -> Bool
04:10:49 <lambdabot> f = (==)
04:11:08 <dmwit> ?djinn Monad foo => a -> foo a
04:11:08 <lambdabot> f = return
04:11:18 <dmwit> ?djinn Monad foo => x -> foo x
04:11:19 <lambdabot> -- f cannot be realized.
04:11:26 <dmwit> O_o
04:11:33 <ivanm> oh, so it can't get flip >>= ...
04:11:38 <rostayob> ivanm: how could djinn derive that for callCC with "m" only? I think it can derive the monad laws with m only, but that's all
04:11:57 <ivanm> @djinn Monad m => (a -> m b) -> m a -> m b
04:11:57 <lambdabot> f a b = b >>= a
04:12:06 <ivanm> OK, so it needs the explicit Monad constraint
04:12:31 <ivanm> http://lambda-the-ultimate.org/node/1178
04:12:31 <ivanm> rostayob: ^^ has callCC stuff in there
04:12:53 <rostayob> ivanm: yes, and the type is explicit, it's not just a generic monad
04:13:12 <rostayob> @djinn ((a -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> (a -> r) -> r
04:13:12 <lambdabot> f a b = a (\ c _ -> b c) b
04:13:43 <quicksilver> @djinn Monad m => a -> m (m a)
04:13:44 <lambdabot> -- f cannot be realized.
04:14:06 <rostayob> but if instead of type C a = ((a -> r) -> a) you give it Monad m => m a... it can't do much
04:22:55 <applicative> we can't give the lambdabot djinn new classes or types to work with?
04:23:44 <ivanm> probably could
04:23:54 <ivanm> I'm sure patches are accepted :p
04:26:56 <quicksilver> you can add new rules to djinn AFAIK
04:27:00 <quicksilver> but that's nto really the problem here
04:27:15 <quicksilver> the problem is the theorem prover just isn't smart enough to handle the monad primitives correctly
04:27:55 <kalven> is there a version of lines that can break a string at some arbitrary char rather than just '\n'?
04:28:13 <rostayob> quicksilver: are you referring to callCC or to a -> m (m a)?
04:28:24 <ivanm> kalven: see the split package on hackage
04:28:25 <hpc> @src lines
04:28:25 <lambdabot> Source not found. That's something I cannot allow to happen.
04:28:26 <ivanm> @hackage split
04:28:26 <lambdabot> http://hackage.haskell.org/package/split
04:28:28 <rostayob> because I can't see how it could possibly derive callCC withouth knowing the type
04:28:55 <rostayob> :t breakAt
04:28:55 <lambdabot> Not in scope: `breakAt'
04:28:58 <rostayob> :t break
04:28:59 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
04:29:13 <rostayob> @hoogle split
04:29:13 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
04:29:13 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
04:29:13 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
04:29:59 <hpc> > break (const False) "bacon"
04:29:59 <lambdabot>   ("bacon","")
04:30:29 <Olathe> BACON!
04:30:31 <quicksilver> rostayob: well a -> m (m a) is a good example of something very easy to prove that it can't prove
04:30:44 <quicksilver> rostayob: I think that demonstrates that it's not really working correctly with those ones.
04:30:47 <hpc> i feel like there's something you could do with mfix and Writer to write an arbitrary version of lines
04:30:54 <rostayob> quicksilver: yeah that's true
04:31:07 <kalven> ivanm: hrm.. ok
04:31:09 <rostayob> hpc: well isn't unfold + break enough?
04:31:48 <rostayob> quicksilver: is djinn aware of type classes anyway?
04:32:09 <ivanm> kalven: you can do it by hand using span/break from Data.List and recursing, but the split package does that for you
04:32:14 <hpc> rostayob: oh, yes it would be
04:32:18 <hpc> forgot about unfolds
04:32:42 <hpc> still, this will be a good way for me to get used to mfix
04:33:38 <rostayob> :t \c -> unfoldr (\s -> if null s then Nothing else Just (break (/= c) s)
04:33:38 <lambdabot> parse error (possibly incorrect indentation)
04:33:51 <rostayob> :t \c -> unfoldr (\s -> if null s then Nothing else Just (break (/= c) s))
04:33:52 <lambdabot> forall a. (Eq a) => a -> [a] -> [[a]]
04:34:19 <quicksilver> rostayob: well I would argue that the answer is 'no' :)
04:34:21 <rostayob> (\c -> unfoldr (\s -> if null s then Nothing else Just (break (/= c) s))) 'x' "aaaxdsfasxbg"
04:34:25 <rostayob> >(\c -> unfoldr (\s -> if null s then Nothing else Just (break (/= c) s))) 'x' "aaaxdsfasxbg"
04:34:28 <rostayob> > (\c -> unfoldr (\s -> if null s then Nothing else Just (break (/= c) s))) 'x' "aaaxdsfasxbg"
04:34:29 <lambdabot>   ["","","","","","","","","","","","","","","","","","","","","","","","",""...
04:34:30 <quicksilver> rostayob: but it must have some limited ability to parse the type sigs at least.
04:34:34 <rostayob> ops
04:34:48 <hpc> you want break (==c)
04:34:52 <rostayob> > (\c -> unfoldr (\s -> if null s then Nothing else Just (break (== c) s))) 'x' "aaaxdsfasxbg"
04:34:53 <lambdabot>   ["aaa","","","","","","","","","","","","","","","","","","","","","","",""...
04:35:05 <rostayob> ah
04:35:08 <hpc> lol
04:35:11 <rostayob> you have to get the tail
04:35:13 <rostayob> of the second
04:35:29 <rostayob> (\c -> unfoldr (\s -> if null s then Nothing else Just (second tail (break (== c) s)))) 'x' "aaaxdsfasxbg"
04:35:32 <rostayob> > (\c -> unfoldr (\s -> if null s then Nothing else Just (second tail (break (== c) s)))) 'x' "aaaxdsfasxbg"
04:35:33 <lambdabot>   ["aaa","dsfas","bg"*Exception: Prelude.tail: empty list
04:35:37 <rostayob> gnnnn
04:35:42 <rostayob> ok whatever. you get the idea eheh
04:35:47 <hpc> ^^
04:36:25 <rostayob> quicksilver: well it's definitely aware of the types :P
04:41:08 <yitz> let splitOn c = unfoldr (\s -> if null s then Nothing else Just . second (drop1 ) $ break (== c) s) in splitOn 'x' "aaaxdsfasxbg"
04:41:14 <yitz> > let splitOn c = unfoldr (\s -> if null s then Nothing else Just . second (drop1 ) $ break (== c) s) in splitOn 'x' "aaaxdsfasxbg"
04:41:15 <lambdabot>   Not in scope: `drop1'
04:41:21 <yitz> > let splitOn c = unfoldr (\s -> if null s then Nothing else Just . second (drop 1 ) $ break (== c) s) in splitOn 'x' "aaaxdsfasxbg"
04:41:22 <lambdabot>   ["aaa","dsfas","bg"]
04:41:35 <rostayob> yitz: excellent
04:41:55 <yitz> rostayob: credit goes to you. i just changed tail to drop 1.
04:42:16 <rostayob> yitz: we will be both remembered.
04:43:14 <yitz> rostayob: here's my favorite:
04:44:36 <yitz> > let readMany = unfoldr . listToMaybe . concatMap reads . tails in readMany "The numbers are 3, 7, and 42. Oh, also 127."
04:44:36 <lambdabot>   Couldn't match expected type `b -> Data.Maybe.Maybe (a, b)'
04:44:37 <lambdabot>         against...
04:44:41 <yitz> wait
04:44:46 <rostayob> here is my favourite
04:44:48 <quicksilver> "if null xs then Nothing else Just" can be spelt "guard (null xs) >> return"
04:44:52 <rostayob> @pl \f g (a,b) -> (f a, g b)
04:44:52 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
04:45:25 <rostayob> quicksilver: true true, didn't want to throw monads into the equation ehe
04:45:28 <dmwit> let (&&&) = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
04:45:56 <dmwit> I have "ensure p x = guard (p x) >> return x" in Dmwit.Prelude.
04:46:50 <rostayob> dmwit: yeah they should add the arrow functions to pl
04:47:04 <yitz> d'uh
04:47:07 <yitz> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "The numbers are 3, 7, and 42. Oh, also 127." :: [Int]
04:47:09 <lambdabot>   [3,7,42,127]
04:48:13 <rostayob> yitz: cool
04:49:04 <yitz> Score: ReadS 1, Parsec 0.
04:49:16 <dmwit> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "-2v-1w0x1y2z"
04:49:18 <lambdabot>   []
04:49:32 <yitz> dmwit: give it an explicit type\
04:49:37 <dmwit> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "-2v-1w0x1y2z" :: [Int]
04:49:39 <lambdabot>   [-2,-1,1,2]
04:49:43 <dmwit> surprise!
04:50:15 <Olathe> Zero isn't in there :(
04:50:21 <Olathe> Probably 0x1.
04:50:24 <rostayob> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "-2v-1w0x1y2z" :: forall a. Read a => [a]
04:50:26 <lambdabot>   []
04:50:26 <dmwit> Yes, exactly.
04:50:32 <rostayob> right that can't work
04:50:48 <dmwit> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "-2v -1w 0x 1y 2z" :: [Int] -- still might not be what you want
04:50:49 <lambdabot>   [-2,-1,0,1,2]
04:50:51 <yitz>  > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "-2v-1w0x1e2z" :: [Int]
04:50:56 <dmwit> Oh, this time it was. So that's nice.
04:50:59 <Olathe> read: Parsing Haskell source code rather than doing the normal thing since 1990.
04:51:00 <yitz> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "-2v-1w0x1e2z" :: [Int]
04:51:02 <lambdabot>   [-2,-1,482]
04:51:08 <rostayob> :t readMany
04:51:09 <lambdabot> Not in scope: `readMany'
04:51:31 <rostayob> :t unfoldr $ listToMaybe . concatMap reads . tails in readMany
04:51:32 <lambdabot> parse error on input `in'
04:51:36 <rostayob> :t unfoldr $ listToMaybe . concatMap reads . tails
04:51:37 <lambdabot> forall a. (Read a) => String -> [a]
04:51:46 <Olathe> @type let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany
04:51:47 <lambdabot> forall a. (Read a) => String -> [a]
04:54:14 <rostayob> > (unfoldr $ listToMaybe . concatMap reads . tails) "12"
04:54:15 <lambdabot>   []
04:54:20 <rostayob> > (unfoldr $ listToMaybe . concatMap reads . tails) "12" :: [Int]
04:54:21 <lambdabot>   [12]
04:54:32 <rostayob> why doesn't it get the "2" as well?
04:54:36 <rostayob> > tails "12"
04:54:37 <lambdabot>   ["12","2",""]
04:54:40 <dmwit> rostayob: listToMaybe
04:54:49 <rostayob> > concatMap reads (tails "12")
04:54:49 <lambdabot>   []
04:55:02 <yitz> > reads "12" :: [(Int,String)]
04:55:03 <lambdabot>   [(12,"")]
04:55:03 <rostayob> > concatMap reads (tails "12") :: [Maybe Int]
04:55:04 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
04:55:04 <lambdabot>         again...
04:55:08 <dmwit> > concatMap reads (tails "12") :: [(Int, String)]
04:55:09 <lambdabot>   [(12,""),(2,"")]
04:55:52 <rostayob> > listToMaybe [(12,""),(2,"")]
04:55:52 <lambdabot>   Just (12,"")
04:55:56 <yitz> > listToMaybe $ concatMap reads "12" :: [(Int,String)]
04:55:57 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
04:55:57 <lambdabot>         against inferred ty...
04:56:16 <dmwit> > listToMaybe $ concatMap reads "12" :: Maybe (Int,String)
04:56:16 <rostayob> concatMap reads (tails "12..4") :: [(Int, String)]
04:56:17 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
04:56:17 <lambdabot>         against inferred ty...
04:56:19 <rostayob> > concatMap reads (tails "12..4") :: [(Int, String)]
04:56:20 <lambdabot>   [(12,"..4"),(2,"..4"),(4,"")]
04:56:40 <rostayob> > listToMaybe [(12,"..4"),(2,"..4"),(4,"")]
04:56:40 <lambdabot>   Just (12,"..4")
04:56:58 <rostayob> ah, right.
04:57:03 <rostayob> the unfoldr
04:57:13 <rostayob> this is smart.
04:58:27 <erus`> what are some more simple functions like id, zero, succ ?
04:58:29 <yitz> @type Dmwit.Prelude.ensure
04:58:29 <lambdabot> Couldn't find qualified module.
04:58:38 <yitz> alright then
04:58:44 <yitz> @type Cale.Prelude.ensure
04:58:45 <lambdabot> Couldn't find qualified module.
04:58:45 <dmwit> :t guard
04:58:46 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:58:50 <yitz> oh well
04:59:08 <dmwit> ensure :: MonadPlus m => (a -> Bool) -> a -> m a
05:17:19 <cwl> @zipWith
05:17:19 <lambdabot> Unknown command, try @list
05:17:25 <cwl> @src zipWith
05:17:25 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
05:17:25 <lambdabot> zipWith _ _      _      = []
05:18:03 <cwl> zipWith (+) [1..5] [11..20]
05:18:06 <yitz> :t let guardA x = if x then pure () else empty; ensure p x = flip const <$> guardA (p x) <*> pure x in ensure --dmwit
05:18:06 <lambdabot>     Ambiguous occurrence `empty'
05:18:06 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
05:18:06 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:56:0-22
05:18:12 <cwl> > zipWith (+) [1..5] [11..20]
05:18:12 <lambdabot>   [12,14,16,18,20]
05:18:16 <yitz> dmwit: that's a
05:18:26 <yitz> dmwit: that's a \bot bug, but you know the type :)
05:18:46 <rostayob> cwl: the cool kid would say "zipWith f = map (uncurry f) . zip"
05:19:25 <Olathe> @pl \f -> map (uncurry f) . zip
05:19:26 <lambdabot> (. zip) . map . uncurry
05:20:25 <engla> (. zip) looks confusing
05:20:32 <yitz> @src zip
05:20:32 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
05:20:32 <lambdabot> zip _      _      = []
05:20:35 <rostayob> point free is confusing
05:20:44 <yitz> > zip [] undefined
05:20:45 <lambdabot>   []
05:21:16 <yitz> > zipWith const [1..5] undefined
05:21:17 <lambdabot>   *Exception: Prelude.undefined
05:21:59 <Olathe> > zipWith const [1..5] (repeat undefined)
05:22:00 <lambdabot>   [1,2,3,4,5]
05:22:49 <yitz> @type map (uncurry f) . zip
05:22:49 <lambdabot>     Couldn't match expected type `[(a, b)]'
05:22:50 <lambdabot>            against inferred type `[b1] -> [(a1, b1)]'
05:22:50 <lambdabot>     Probable cause: `zip' is applied to too few arguments
05:22:51 <mah_b> is there some sort of hash-function shipped in the haskell platform? (md5/sha1)
05:23:25 <rostayob> mah_b: there is a Hasable type class but a "universal" hashing function would be impossible
05:23:39 <rostayob> mah_b: ah no sorry, I misunderstood
05:23:40 <yitz> @pl \f xs ys -> map (uncurry f) $ zip xs ys
05:23:41 <lambdabot> (. zip) . (.) . map . uncurry
05:23:55 <mah_b> cryptographic hash
05:24:21 <engla> yitz: that's worse
05:24:31 <rostayob> mah_b: yep sorry. I'm not sure if they're included in the haskell platform http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html
05:25:01 <rostayob> it doesn't look like.
05:25:36 <valberg> http://www.castingcode.tv/?s=8W9 - watch others code :D
05:25:57 <Cale> wtf, why are the top 15 links on my Reddit main page all from the programming reddit?
05:25:57 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
05:26:17 <yitz> engla: what, the @pl version? sure.
05:26:44 <rostayob> yitz: yeah the snippets I posted wouldn't work, more like \f xs -> map (uncurry f) . (zip xs)
05:26:45 <koeien> Cale: for me the same :/
05:26:48 <rostayob> *snippet
05:26:55 <yitz> rostayob: right
05:27:22 <rostayob> @pl \xs -> map (uncurry f) . (zip xs)
05:27:22 <lambdabot> zipWith f
05:27:25 <rostayob> damnit
05:27:31 <yitz> Cale: how do you refer to Control.Applicative.empty in lambdabot?
05:27:42 <yitz> haha
05:27:58 <Olathe> @pl \xs -> map (uncrry f) . (zp xs)
05:27:58 <lambdabot> (map (uncrry f) .) . zp
05:28:02 <Cale> :t empty
05:28:03 <lambdabot>     Ambiguous occurrence `empty'
05:28:03 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
05:28:03 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:56:0-22
05:28:06 <Cale> oic
05:28:15 <Cale> :t Control.Applicative.empty
05:28:16 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a
05:28:23 <Cale> Well, that works
05:28:28 <yitz> oh. thought i tried that.
05:28:57 <rostayob> Olathe: yeah, the point free version is confusing. when dots start appearing in sections like that...
05:29:11 <yitz> Cale: anyway, seems there should be something better than that.
05:29:48 <yitz> :t Text.Regex.Posix.empty
05:29:49 <lambdabot> forall source. (Extract source) => source
05:29:50 <applicative> > Control.Applicative.empty :: [Int]
05:29:51 <lambdabot>   []
05:30:34 <yitz> applicative: oh, does your irc client beep every time someone mentions that class? that must be annoying.
05:31:29 <yitz> applicative: you should switch to applicative' or coapplicative or something.
05:31:33 <erus`> i thought i might be able to explain lambda calc in 500 words
05:31:39 <erus`> i dont think i can
05:31:59 <yitz> @google alligator eggs
05:32:00 <lambdabot> http://en.wikipedia.org/wiki/Alligator
05:32:00 <lambdabot> Title: Alligator - Wikipedia, the free encyclopedia
05:32:07 <yitz> @google alligatoreggs
05:32:07 <lambdabot> http://worrydream.com/AlligatorEggs/
05:32:08 <lambdabot> Title: Alligator Eggs!
05:32:15 <yitz> erus`: there
05:32:26 <yitz> erus`: a picture is worth a thousand words
05:32:33 <applicative> yitz, it is highlighted.  I could do with a proper nick, admittedly
05:33:34 <yitz> applicative: it's not improper, it's nice. only i just realized that annoyance.
05:33:48 * hackagebot factory 0.1.0.3 - Rational arithmetic in an irrational world.  http://hackage.haskell.org/package/factory-0.1.0.3 (AlistairWard)
05:34:12 <yitz> applicative: i have an idea. you can switch your nick to yitz++
05:34:32 <rostayob> erus`: lambda calculus is a language with three expression forms: variable reference, eg. a, foo; function application (f x), (f (g x)); and anonymous functions, e.g. (\ (v) (+ v 1)). done.
05:35:52 <erus`> hmm
05:36:19 <erus`> i have spent two pages (of mostly diagrams) trying to explain what a function is
05:36:29 <rostayob> erus`: and then you can explain how to encode numbers/lists. probably less than 500 words
05:36:34 <yitz> mah_b: no. install it from hackage. there are a number of libraries there to choose from.
05:36:49 <mah_b> yitzcan you recommend one?
05:37:25 <yitz> mah_b: not sure. anyone else?
05:37:52 <rostayob> Crypto? the name is promising
05:39:23 <rostayob> thinking about it, I often see SHA in dependency lists
05:39:51 <rostayob> so if you need just one  cryptographic function...
05:43:12 * Cale semi-trolls... If X and Y are two sets, then a function f: X -> Y is a triple (X,Y,G) where G is a set of pairs (x,y) with x in X and y in Y such that for any x in X, there is exactly one y in Y such that (x,y) is in G.
05:43:49 * hackagebot template 0.2.0.5 - Simple string substitution  http://hackage.haskell.org/package/template-0.2.0.5 (JohanTibell)
05:44:46 <yitz> Cale: interesting. i always though it was a morphism in the category of sets.
05:45:00 * yitz bits
05:45:05 * yitz bites
05:45:05 <erus`> aligator eggs is awesome
05:45:15 <erus`> i wanna write a simulation
05:48:24 <yitz> mah_b: hopenssl provides a binding to the openssl md5. pureMD5 and cryptohash are pure haskell implementations; pureMD5 supports crypto-api (so it's easy to switch to something else easily later), cryptohash claims to be extremely fast for a pure haskell implementations.
05:53:34 <yitz> erus`: at the opposite extreme: a lambda expression is a string satisfying the following syntax... a lambda expression A is an alpha substitution of B if... a beta reduction of B if.. equivalence of lambda expressions is the completion of alpha substitution and beta reduction to an equivalence relation. you could probably get that down to under 500 words.
05:54:24 <dmwit> Cale: X is completely determined by G, why not leave it out?
05:56:23 <yitz> dmwit: he his defining "f : X -> Y". should he write instead "f : " ++ x ++ " -> Y" for some string x such that length x == 1 and isAsciiUpper x?
05:57:14 <dmwit> yitz: I'm proposing that the definition be a pair (Y,G) rather than a triple (X,Y,G).
05:58:03 <yitz> dmwit: "a function f: X -> Y is a pair (Y,G) such that..." ?
05:58:07 <dmwit> yes
05:58:37 <yitz> dmwit: it's not clear whether X is a literal part of the notation or a free variable
05:58:52 <dmwit> X = map fst G
06:00:25 <yitz> a function is a relation R such that every right-section of R has exactly one element
06:02:38 <dmwit> While true, that doesn't specify the domain and range (while Cale's definition explicitly tries to specify those).
06:02:45 <dmwit> (as does mine)
06:03:03 <dmwit> s/domain and//
06:03:38 <yitz> a function is an equivalence class of lambdas whose scott model is total
06:03:53 <Cale> dmwit: You can do that, of course.
06:03:57 <yitz> s/lambdas/lambda expressions/
06:04:09 <Cale> dmwit: But it's easier working with the triple.
06:05:31 <yitz> Cale: are you teaching a class?
06:05:42 <Cale> nope
06:05:46 <Cale> why?
06:06:38 <yitz> oh just sounded like it.
06:07:04 <Saizan> while we're here, if i have injection from A to the naturals and A is infinite, is that enough to deduce there's a bijection between A and the naturals?
06:07:16 <Saizan> *an injection
06:07:25 <dafis> Saizan: it is enough
06:07:34 <yitz> Saizan: in what system?
06:08:01 <yitz> Saizan: in classical ZFC it certainly is enough.
06:08:28 <Cale> You can define the bijection recursively.
06:08:28 <dafis> don't need C, ZF or NBG is enough
06:08:41 <Saizan> well, this is in a rather informal context anyway
06:09:17 <quicksilver> if this is an informal context, why are so many of us wearing bowties?
06:09:28 <Cale> Saizan: the range of your injection is a nonempty subset of the naturals, and thus has a least element
06:09:43 * yitz hides his long tie
06:10:06 <companion_cube> quicksilver: because bowties are cool.
06:10:15 <quicksilver> companion_cube: you're probably thinking of Fezzes
06:10:20 <companion_cube> also
06:10:33 <companion_cube> but he also says "bowties are cool" iirc
06:13:36 <Saizan> Cale: so the idea is to scale that least element down to zero and then recursse for the range without that element?
06:15:07 <Botje> I thought stetsons were the hot new thing?
06:15:57 <tromp> each a in A corresponds to number of a' such that inject(a')<inject(a)
06:17:41 <Saizan> ah, nice
06:18:25 <darrint> Can ghc generate core for a single module with no main function?
06:19:01 <dafis> darrint: sure
06:19:19 <Phyx-> hm, is there a haskell package to read pdf files?
06:19:38 <dafis> ghc -ddump-simpl Module (--make if ghc < 7)
06:19:44 <rostayob> dafis: try -ddump-cse
06:24:54 <kamaji> if I have to return a list of one element, is [a] or a:[] preferred?
06:25:03 <Nalim> hello all!
06:25:08 <kamaji> hello!
06:25:09 <int-e> kamaji: [a]
06:25:10 <koeien> [a] is a bit cleaner
06:25:18 <kamaji> okey
06:25:20 <koeien> but it means the same thing
06:25:27 <kamaji> I was just wondering what people considered more readable really
06:25:55 <Botje> less is more ;)
06:26:13 <kamaji> I was thinking with tuples really
06:26:16 <int-e> Botje: heh, so you'd prefer [] over [a]? :)
06:26:22 <kamaji> [(a,b)] vs (a,b):[]
06:26:37 <dmwit> Same answer: [(a,b)] is preferable
06:26:43 <Botje> [] is the ideal inhabitant of its type >:)
06:27:10 <dmwit> data WeirdList a = NilA | NilB | Cons a (WeirdList a) -- what is the ideal inhabitant of this type?
06:27:12 <kamaji> overhead/storage ratio is bad though~
06:27:24 <int-e> kamaji: same answer. My main reason, actually, is that one can write f [(a,b)] but would need parentheses for f ((a,b):[]). And those hurt readability.
06:27:30 <kamaji> oh true
06:27:32 <Botje> undefined! :P
06:27:40 <darrint> turned out my problem was lack of a module declaration in my module.
06:27:58 <Nalim> I am encountering an error ['Server error: /var/folders/bg/szy711t55qqgs0sssfxdj36h0000gn/T/gitit-tmp-pdf.0/export.log: openBinaryFile: does not exist (No such file or directory)'] when I try to use the PDF export feature. I did some searches but I only found this problem for DARCS mainly and did not find any relevant solutions for gitit. Would anyone have an idea of the problem (or, better, the solution!)
06:28:24 <quicksilver> dmwit: "Ideal" ?
06:28:43 <dmwit> quicksilver: 10:18 < Botje> [] is the ideal inhabitant of its type >:)
06:28:51 <quicksilver> ah ;)
06:29:37 <byorgey> Cons 3 NilB  -- this is it
06:29:43 <byorgey> it rhymes
06:30:13 <dmwit> :3
06:30:22 <rostayob> no way. you can use this character in kind signatures: ★
06:30:27 <Nalim> In fact I suppose the openBinaryFile executable is missing on my system, but I have no idea how to install it (cabal failed to find it)
06:30:43 <dmwit> openBinaryFile is a Haskell function, not an executable.
06:30:48 <rostayob> > 3 ★ 4
06:30:49 <lambdabot>   Not in scope: `
06:30:56 <dmwit> ?hoogle openBinaryFile
06:30:56 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
06:31:06 <Botje> Nalim: I surmise openBinaryFile is trying to create a file in a FilePath that does not exist
06:31:53 <LazyAxe> Let we have some types, serializable to and  deserializable from JSON, and function between such types,
06:31:53 <LazyAxe> defined in terms only destructing and constructing values and maybe some actions, well defined on JSON data (arithmetics, concatenation).
06:31:53 <LazyAxe> How can I get its "structure" to generate associated javascript function?
06:32:25 <rostayob> LazyAxe: well afaik there is no such tool
06:32:30 <scooty-puff> is it possible to have the ghc compiler statically link libc, libffi, etc., into rts, or wherever its referenced?
06:32:36 <rostayob> you're looking for a restricted hs -> js compiler if I understand correctly
06:32:45 <scooty-puff> i assume just change the build.mk somewhere to include -static -lc -lm -shared
06:32:49 <Botje> encode the steps taken to create that structure in each element of your data type
06:32:50 <scooty-puff> well, conditional on the -shared
06:32:56 <Nalim> dmwit > ok, it is indeed an function!
06:33:13 <rostayob> LazyAxe: using a small DSL, possibly based on some lenses library, is probably a lot more convenient.
06:33:22 <scooty-puff> i think a few may exist
06:33:36 <scooty-puff> for the js thing - if i understand the part i've read
06:33:39 <Nalim> Botje > yep, the directory seems not to have been created before the operation; I do not find it
06:33:40 <scooty-puff> try hackage
06:33:50 <rostayob> LazyAxe: since you want to do something really specific
06:36:41 <LazyAxe> rostayob: but this compilation is absolutely trivial — composition of standard functions. May be, there exists a way to get info about function in compile time?
06:36:55 <rostayob> LazyAxe: yes, template haskell
06:37:27 <herself> how do I check what packages have I installed with cabal?
06:37:44 <merijn> herself: If you are using GHC then "ghc-pkg list"
06:38:03 <rostayob> LazyAxe: but using a DSL would be more solid, imho.
06:38:19 <rostayob> LazyAxe: (if I understood correctly what you want to do)
06:38:20 <herself> merijn: thanks!
06:38:50 <Nalim> to create the pdf, gitit uses latex. As an export to a .tex works, I suppose that there is a problem running the latex executable
06:39:14 <Nalim> is there a way to check that gitit has the authorization to run latex?
06:39:27 <rostayob> Nalim: ls -a latexbin ?
06:39:34 <rostayob> and check what user is running gitit?
06:39:50 <rostayob> gitit is that wiki thing right?
06:40:00 <Nalim> yep, it is the wiki
06:40:04 <Nalim> based on git
06:40:34 <rostayob> Nalim: well if it's a permission issue just check the files permissions
06:40:47 <LazyAxe>  rostayob: It would be very comfortably to do such things for web applications: transparent conversion between haskell and javascript types, pattern matching in js and more strict typing.
06:40:47 <LazyAxe>  rostayob: but TH doesnot check types, I can create incorrect declaration.
06:41:05 <rostayob> LazyAxe: no you can't, it won't compile
06:41:06 <Nalim> yes, I am checking the permissions
06:41:14 <rostayob> LazyAxe: I mean you can but it won't be compiled
06:41:45 <rostayob> template haskell is just a macro system to create code at compile time, but in the end it gets compiled normally
06:42:10 <rostayob> what I wouldn't like is that you'd have to be really careful in writing functions that are compilable by your mini haskell->js compiler
06:42:40 <rostayob> it would also be a lot more complicated. while you could create a simple DSL representing lenses operation and compile that to javascript
06:42:58 <rostayob> this is actually a cool idea I might do it myself :P
06:44:25 <kamaji> Should I be able to read a list of an instance of Read just by annotating :: [MyType]  ?
06:44:48 <koeien> > read "[1,2,3]" :: [Integer]
06:44:49 <lambdabot>   [1,2,3]
06:45:00 <kamaji> that means I fucked up~
06:46:03 <kamaji> oh snap, I just forgot the [, ,, and ]
06:46:25 <Nalim> permissions seem to be ok since gitit is launched on my behalf and I can run latex by typing ./latex
06:46:32 <koeien> > map read . words $ "1 2 3 4" :: [Integer]
06:46:33 <lambdabot>   [1,2,3,4]
06:46:55 <kamaji> oh snap
06:47:47 <kamaji> pity my code is so ugly
06:48:16 <LazyAxe> rostayob: that is, I  write function, put it in quasiquotes, result use in my "compiler", which translates AST to JS, and in splice to define haskell function, which will be checked by compiler. Maybe so, thank. While it would be very cool to do so without templates…
06:48:34 <Entroacceptor> Nalim: ./latex?
06:48:42 <Entroacceptor> gitit probably searches PATH
06:49:39 <Nalim> no, by typing latex sorry
06:49:53 <Nalim> however, latex is owned by the root
06:50:06 <rostayob> LazyAxe: you can simply write your haskell function "foo :: JSON -> JSON" and then do something like $(generateJS 'foo) when you need the JS. there is no need for quasi quoting
06:50:31 <Nalim> ok, I check if this directory is included in PATH
06:51:00 <scooty-puff> i'd asked earlier, but may have been lost in the conversion: it is possible to have rts, etc., linked to a static libc, libffi, etc., i assume a change to build.mk?
06:51:04 <LazyAxe> rostayob: oh, exactly.
06:51:27 <jobehd> hello all - you know the +rts -k option, for increasing heap. i got an error saying stack space overflow, use -k to fix it, and i used -k32m, so only setting the heap to a very small 32mb, and this worked! how come the default stack space is sooo tiny?
06:51:28 <scooty-puff> the reason is i have a plugin (cabalized), but requires a ghc compiler that was compiled with -fPIC
06:51:29 <Nalim> the variable /usr/texbin  is present in my path
06:51:32 <scooty-puff> or its rts atleast
06:51:46 <scooty-puff> and would like to distribute without that requirement
06:52:32 <Nalim> so I suppose gitit have access to the same PATH variable, and so should be able to use latex as I am since it is run on my behalf
06:52:35 <Entroacceptor> maybe it's some temporary file problem
06:52:41 <dafis> jobehd: -K sets stack size, not heap
06:53:15 <jobehd> ah right, so i must be allocating lots and lots of local values then
06:53:15 <Cale> jobehd: -k only sets the *initial* thread stack size, not the heap size, or even the upper bound on stack...
06:53:20 <Nalim> Entroacceptor > do you think I have a way to repair it?
06:53:26 <dafis> jobehd: heap is unlimited by default, stack is 8m
06:53:58 <Cale> jobehd: The stack consists of pattern matches (case expressions) which are waiting for their scrutinee to be sufficiently evaluated to pattern match
06:54:16 <Cale> (It's not a call stack)
06:54:32 <Cale> Nor is it a stack of locally allocated variables
06:54:38 <nomadmonad> Hello! I hope this is not a FAQ question, but how would I find a Haskell programmer who would like to prepare a small prototype with me (I'm a coder too), which might then grow into real project or job position? Now, he/she would preferably be in Finland, but I guess we could hack on the prototype over the internet too.
06:54:39 <jiyunatori> hi. I'm playing with a octree (tree with 8 children), and it looks like I need zippers to manipulate it. I think I understand how zippers work, but which package should I use ?
06:54:58 <Nalim> I am on a Mac, I suppose I can try to repair the permissions ...
06:55:19 <Cale> Oh, jobehd quit :P
06:55:31 <dankna> nomadmonad: you might check haskellers.com, it's a jobs site
06:55:33 <arcatan> `/wi nomadmonad
06:56:42 <Entroacceptor> Nalim: it tries to compile the latex in what haskell thinks is the temp-dir/gitit-tmp-pdf
06:56:46 <nomadmonad> dankna: great! Thanks, I'm going to check it out!
06:56:49 <dankna> sure thing
06:57:24 <Nalim> so I have to check whether haskell has permissions to write in my tmp folder I supose
06:57:24 <nomadmonad> At first I thought that would be for "job offers", whereas I try to find great guys to talk with, hack a little, and later on, yes, maybe we could make this a real job, for both of us. :]
06:58:07 <dankna> well, I'm happy to talk about your plans, as I suspect many people in here would be.
06:58:09 <Entroacceptor> yeah
06:58:29 <dankna> I'm all booked up as far as coding time goes though
06:58:38 <Entroacceptor> do you have ghci? if, check what get getTemporaryDirectory says
06:58:50 <Nalim> Entroacceptor > I think you found something, the temp var indicated is drwx------ and owned by the root
06:58:56 * hackagebot tokenize 0.1.0 - Simple tokenizer for English text.  http://hackage.haskell.org/package/tokenize-0.1.0 (GrzegorzChrupala)
06:59:06 <nomadmonad> that sounds great!
06:59:18 <dankna> well, cool :)
06:59:51 <Nalim> so, do I have a mean to correct the path of the temp folder Haskell uses?
07:00:09 <alpounet> any "lambdabot operator" around ?
07:00:46 <scooty-puff> is code like this: https://github.com/sonyandy/gtagsjs/blob/master/Setup.hs#L34 required to handle cabal and exported __stginit root functions?
07:00:46 <arcatan> nomadmonad: what kind of project are you developing?
07:00:57 <scooty-puff> or is there something in cabal that can already do this?
07:01:12 <Nalim> shame on me, I did a mistake, the temporary directory used by haskell is owned by staff, and not the root
07:01:35 <Entroacceptor> Nalim: try setting the TMPDIR environment variable
07:01:39 <Nalim> not staff user, staff group...
07:02:21 <Nalim> the TMPDIR links to this folder where I can write
07:02:39 <Nalim> so gitit should be able to write inside too
07:04:39 <koeien> you could try strace to see where it's failing
07:05:08 <Nalim> koeien > are you talking to me?
07:05:35 <koeien> Nalim: yes, unless you already know what is the cause, obviously :)
07:05:59 <Nalim> ok, no I did not found yet, I am going to try strace
07:08:57 <LazyAxe> What is the best way to index nodes in type-level lists (and naybe trees)? I want to decompose tree of DOM elements into tree of composite widgets, so primitive widget have some low-level presentation and several slots (holes, in which other widgets may be inserted), and composite widgets are built from primitive and other composite; type of widget include his slots. I need some indexing of slots to write combinators of widgets.
07:12:28 <erus`> LazyAxe: whats wrong with the DOM element id?
07:12:37 <indianguy> Hello
07:13:00 <erus`> hey indianguy, where are you from?
07:13:29 <koeien> indianguy: hello, how can we help?
07:13:36 <indianguy> bye
07:13:54 <erus`> koeien: you came on too strong
07:18:22 <LazyAxe> erus`: some slots may contain a list of subwidgets, and we can't associate with slots one id; also widget of such type may be created multiple times. I want compile-time ids for using in haskell and declaring types of composite widgets. (I use haskell as macros for javascript.)
07:19:57 <Nalim> I have to investigate more to use strace (I have to install it etc.)
07:20:15 <Nalim> So I think I will try myself and come back if I have an interesting result
07:21:01 <koeien> Nalim: ah, what platform is this?
07:21:49 <Nalim> Mac OS
07:22:21 <Nalim> I suspect it is related to the Lion update since I have an error message in the console that have already been reported in forums
07:22:24 <Axman6> strace doesn't run on OS X
07:23:09 <Axman6> Nalim: have you read https://gist.github.com/1169332 ?
07:23:53 * Axman6 -> bed
07:25:58 <Nalim> Axman6 > No, I missed it! I am going to apply this process
07:26:06 <Nalim> thank you very much for this pointer :)
07:29:03 * hackagebot sundown 0.3 - Bindings to the sundown markdown library  http://hackage.haskell.org/package/sundown-0.3 (FrancescoMazzoli)
07:31:13 <kamaji> What would be the best way of generating N unique integers?
07:31:26 <kamaji> or: the best way of selecting N items without replacement from a list
07:31:27 <tac-tics> > \n -> [1..n]
07:31:27 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> [t])
07:31:27 <lambdabot>    arising from a use of...
07:31:32 <kamaji> oops
07:31:33 <kamaji> I meant random
07:31:36 <kamaji> how droll~
07:31:57 <kamaji> assuming the randomness is taken care of, anyway
07:32:18 <kamaji> the "trying again" approach will end up being pretty bad if N -> list size
07:32:42 <Olathe> kamaji: Make a list n long and take a random permutation.
07:33:16 <kamaji> That seems like it could be slow for large lists
07:33:24 <Olathe> kamaji: Then take the first however many you want to select as the ones to select from the original list.
07:33:32 <koeien> take a random permutation. then take the first n elements.
07:33:35 <tac-tics> kamaji: Use a Random type
07:33:44 <tac-tics> @type next
07:33:45 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
07:33:56 <kamaji> that doesn't guarantee uniqueness though, does it?
07:34:03 <Olathe> kamaji: Compared to the trying again approach, it's faster.
07:34:08 <tac-tics> you want a unique list of random numbers?
07:34:25 <Olathe> kamaji: Uniqueness in what way?
07:34:46 <kamaji> not equal , but I guess that's just specific to me
07:35:02 <kamaji> i'm trying to take k random items from a list without replacement
07:35:05 <tac-tics> You could create an infinite random list then take n . nub it
07:35:06 <Olathe> kamaji: I thought you were looking to take n items without replacement. Taking the first n items from a random permutation of 1..length will do that.
07:35:19 <Olathe> kamaji: ...regardless of uniqueness issues.
07:35:21 <kamaji> But the shuffle is quite expensive
07:35:22 <tac-tics> kamaji: ah
07:35:35 <Olathe> kamaji: Oh, you can use an array.
07:35:45 <Olathe> kamaji: Then, it should be relatively inexpensive to swap.
07:35:45 <tac-tics> So you just want a random permutation of [0..n] or whatnot?
07:35:50 <rwbarton> I think how to do this most efficiently depends on how close N is to the length of the list
07:36:12 <kamaji> rwbarton: yeah, that's what I was thinking, but i'm not sure if there's a good general way to do it
07:36:14 <Olathe> tac-tics: Ultimately, kamaji wants to take n random items without replacement from a list.
07:36:24 <kamaji> Yeah
07:36:33 <rwbarton> can we give the length of the list a name?
07:36:34 <Olathe> tac-tics: If there's a faster way than the first n items of a random permutation, that would be preferred.
07:36:42 <kamaji> Which happens to be equivalent (for this problem at least) to generating n random unique integers
07:36:49 <kamaji> rwbarton: 52
07:36:54 <rwbarton> oh
07:36:56 <kamaji> hehe
07:37:09 <kamaji> I'm kinda interested in a general way though just for curiosity's sake
07:38:36 <Olathe> You can randomly permute the list itself (in an array) and take the first n items.
07:38:43 <Olathe> Then the rest of the items are there in case you want more.
07:39:05 <kamaji> trouble is, I want to do it lots of times, and doing lots of shuffles will end up being costly I think
07:39:13 <kamaji> also, monte carlo poker ^^
07:39:33 <Olathe> kamaji: I don't personally know of a cheaper way.
07:39:45 <rwbarton> well if N is, say, 1, then obviously there is a cheaper way :)
07:39:48 <kamaji> haha
07:39:53 <Olathe> :)
07:39:54 <kamaji> well then the permutation doesn't cost much :p
07:39:56 <tac-tics> In Haskell, at least it's free until you want the first item
07:40:14 <Olathe> Is there some more lazy way to do it where you only pay for the items you take?
07:40:34 <Olathe> Like a sort of reverse sort?
07:40:36 <kamaji> That would be generating unique indices, right?
07:40:47 <rwbarton> that's what I don't know how to do without an extra log N factor
07:40:55 <tac-tics> Olathe: Probably, but I think when you do that, the cost is just moved into the bookkeeping needed to know when an item has been "took"
07:41:03 <Olathe> Ahh.
07:41:37 <rwbarton> although frankly worrying about log N factors is a bit silly when N is less than your word size
07:41:57 <kamaji> word size?
07:42:10 <rwbarton> like on a 64-bit system you could check whether you've already used a card with a single bit test
07:42:23 <kamaji> oh right yeah
07:42:30 <Olathe> swap i (rand remaining), prepend i onto the result list, increment i.
07:42:48 <Olathe> That should avoid permuting the entire list, just permutes enough to give you the items you want.
07:42:53 <kamaji> Ooh i have an idea
07:42:55 <kamaji> how about this
07:43:09 <kamaji> this relies on the fact I need lots and lots of groups of 5
07:43:13 <kamaji> (or 7)
07:43:23 <kamaji> so you take a 64-bit integer representing the group
07:43:35 <kamaji> generate random integers between 0 and 51
07:43:54 <kamaji> give each random to a large set of 'groups'
07:44:03 <kamaji> they are updated until popcount is 7
07:44:07 <kamaji> then put into a 'results' pile
07:44:32 <kamaji> you'd have to maintain order as well actually, but close enough
07:44:33 * roconnor__ thinks there is only one group of order 5 upto isomorphism.
07:44:44 <kamaji> what's an isomorphism? :D
07:44:53 <roconnor__> oops
07:44:56 <roconnor__> ignore me
07:45:18 * benmachine agrees with roconnor 
07:45:37 <rwbarton> probably you shouldn't get too clever with the bookkeeping, since at the point where you're implementing it with bit operations it is probably negligible compared to the cost of generating random numbers 0..51 in the first place
07:46:33 <kamaji> rwbarton: that's why i'm trying not to 'lose' any of the numbers I generate
07:46:42 <rwbarton> yeah
07:46:45 <kamaji> oh that would skew it though wouldn't it
07:46:48 <kamaji> harumph
07:48:11 <Olathe> kamaji: All this stuff should be pretty fast (like on the nanoseconds range).
07:48:24 <Olathe> kamaji: Especially if you use an array when you swap things around.
07:48:39 <rwbarton> even if you just reject numbers you've used, on average you reject 0/52+1/52+2/52+3/52+4/52 = 10/52 times
07:48:47 <rwbarton> wait
07:49:05 * hackagebot yesod 0.9.2.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.9.2.2 (MichaelSnoyman)
07:49:07 * hackagebot tokenize 0.1.1 - Simple tokenizer for English text.  http://hackage.haskell.org/package/tokenize-0.1.1 (GrzegorzChrupala)
07:49:25 <rwbarton> actually it's 1/51+2/50+3/49+4/48
07:49:47 <kamaji> isn't that ignoring rejection?
07:49:51 <rwbarton> which is still only about 1/5 total
07:50:23 <rostayob> what are the allowed characters for haskell modules?
07:50:31 <rostayob> is it just latin letters and dots?
07:50:50 <kamaji> rwbarton: ooh, idea
07:51:11 <kamaji> rwbarton: just put 'rejected' numbers into their own list, and use that as the randoms to generate the next group
07:51:27 <roconnor> rostayob: it is broader than that, but I don't recall the details of the limits
07:51:43 <merijn> rostayob: Since everything else allows unicode to, I would expect modules would allow more than just those
07:51:59 <b_jonas> rostayob: module names have to start with uppercase, but I think underscores and apostrophes are allowed
07:52:20 <dafis> rostayob: all unicode characters, but probably only utf-8 encoded files will be understood
07:52:20 <b_jonas> rostayob: also digits. see http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002 for full story
07:53:12 <dafis> rostayob: were you asking about module names? Then identifier chars
07:55:51 <rostayob> b_jonas, roconnor, merijn, dafis: thanks
08:20:37 <bfig_> is there a string compare function?
08:20:49 <dafis> bfig_: (==) ?
08:20:50 <earthy> bfig_: ==
08:20:57 <jacobian> If I want to take f g and apply it to pairs, how do I do that?
08:21:00 <bfig_> ty
08:21:34 <earthy> jacobian: f *** g
08:21:41 <Olathe> > (\(a, b) -> (f a, g b)) (1, 2)
08:21:42 <lambdabot>   Ambiguous type variable `t' in the constraints:
08:21:42 <lambdabot>    `SimpleReflect.FromExpr ...
08:21:44 <quicksilver> jacobian: your question is a bit non specific, but (f *** g) maybe
08:21:49 <dafis> jacobian: like \(a,b) -> (f a, g b)?
08:22:04 <earthy> > (+ 1) *** (* 2) $ (2,2)
08:22:05 <lambdabot>   (3,4)
08:22:07 <quicksilver> > ((+1) *** (*2)) $ (7,6)
08:22:08 <lambdabot>   (8,12)
08:22:18 <quicksilver> see also
08:22:25 <quicksilver> > ((+1) &&& (*2)) $ 7
08:22:25 <lambdabot>   (8,14)
08:22:37 <rexim> there is "compare" function
08:27:20 <jacobian> dafis, quicksilver, sorry: something :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
08:28:13 <earthy> jacobian: that is (***)
08:28:31 <tac-tics> @type (***)
08:28:32 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:28:53 <earthy> applied to  ->  :)
08:29:05 <jacobian> right, got it
08:29:12 <jacobian> thanks all
08:32:31 <bfig_> is Logica.pr2 an illegal module name?
08:32:39 <quicksilver> yes
08:32:46 <earthy> P should be capitalised
08:32:52 <quicksilver> each segment must beging with a capital letter
08:32:55 <bfig_> ok, ty
08:33:06 <quicksilver> Logica.pr2 is the name of the identifier pr2 in the module Logica
08:33:15 <quicksilver> (or the module locally aliased to Logica)
08:35:10 <Olathe> irccloud.com went boom?
08:41:34 <bfig_> file name does not match module name, saw: 'main', expected: 'LogicaPr2' : what does that mean?
08:41:47 <shachaf> bfig_: Exactly what it says.
08:42:07 <shachaf> Which part is unclear?
08:42:19 <bfig_> but main is in the module that imports LogicaPr2, and there is no main function in LogicaPr2.hs
08:42:56 <bfig_> module names are in the first line always?
08:43:01 <shachaf> Are you sure there's no file that starts with "module LogicaPr2" and has a filename "main.hs"?
08:43:08 <bfig_> imports first ?
08:43:11 <shachaf> Or something along those lines, I don't know. You're providing very little information.
08:43:39 <bfig_> let me paste the code
08:43:40 <shachaf> This would be easier if, for instance, you @pasted the contents of the various files along with their filenames.
08:45:06 <hpaste> bfig pasted “compilation error” at http://hpaste.org/51333
08:47:16 <shachaf> If the file contains main you probably want to call the module and the file Main.
08:47:56 <bfig> module Main where ?
08:48:04 <bfig> and Main.hs?
08:48:27 <shachaf> I guess.
08:49:03 <shachaf> What's "onClicked buttondostuff <- execEncDec entrysrc destsrc buttonencdec" supposed to mean?
08:49:49 <bfig> it's registering the event handler for the onClicked action
08:50:05 <bfig> wait
08:50:32 <shachaf> I don't think you even have valid Haskell there. :-)
08:50:34 <bfig> i think the syntax is wrong, but that is what i intended to do at least
08:50:41 <bfig> >_>
08:51:21 <bfig> i just let myself get carried away by <-'s :p
08:53:06 <bfig> shachaf, i changed the names, it still complains about main defined two times
08:53:24 <shachaf> Maybe main is defined two times, then.
08:53:26 * shachaf recommends grep.
08:54:12 <bfig> pfft. it got old versions copied to the dir, the module xxx where was not in the first line
08:55:02 <bfig> how do i if.. then.. else with monads?
08:55:17 <benmachine> the same way as always?
08:55:47 <bfig> mmm sorry, indented wrong :)
09:13:39 <zzo38> Is it possible to represent anything masthematically correct in category theory in Haskell?
09:14:30 <zzo38> s/masthematically/mathematically/
09:15:40 <int-e> @faq
09:15:41 <lambdabot> The answer is: Yes! Haskell can do that.
09:16:22 <int-e> zzo38: your question is not specific enough. you can represent all that as text strings. you can represent text strings in haskell.
09:20:45 <zzo38> int-e: No, I mean as a program.
09:24:45 <aaandroid> would it be accurate to say that since data (state) is the basis of all computations, it makes sense for a language to place emphasis on functions rather than "objects"?
09:26:06 <aaandroid> i mean, oop is a good way to encapsulate data to model the real world
09:27:34 <rostayob> aaandroid: is it?
09:27:37 <DasIch> aaandroid: not really
09:27:39 <benmachine> aaandroid: what does it mean to say data is the basis of all computations?
09:28:25 <rostayob> aaandroid: http://www.sics.se/~joe/bluetail/vol1/v1_oo.html
09:28:26 <aaandroid> functions operate on data and return data
09:28:29 <DasIch> aaandroid: your program is not about data, working on data
09:28:59 <applicative> what does it mean to say "data (state)"
09:29:14 <DasIch> aaandroid: you could say that the program itself is a function
09:29:37 <aaandroid> so it makes sense to classify data types rather than objects
09:30:24 <aaandroid> functions are then organized and composed according to how they operate on the data types
09:30:34 <aaandroid> ?
09:31:22 <aaandroid> coming from oop, i'm trying to make sense of fp
09:31:29 <applicative> @type ord
09:31:30 <lambdabot> Char -> Int
09:31:40 <applicative> @type chr
09:31:41 <lambdabot> Int -> Char
09:31:58 <applicative> @type ord . chr
09:31:59 <lambdabot> Int -> Int
09:32:05 <aaandroid> rostayob: i'm looking at the link now
09:33:12 <rostayob> aaandroid: the guy talking is joe armstrong (he did erlang) and I mostly agree with what he says
09:33:49 <applicative> @faq Does Haskell sometimes overlook the fact that the real world is constantly changing, that it's mutable?
09:33:50 <lambdabot> The answer is: Yes! Haskell can do that.
09:34:14 <rostayob> applicative: there are plenty of ways to handle mutable state in haskell
09:35:10 <aaandroid> how is a type constructor different from a data structure?
09:36:02 <tac-tics> A type constructor is a function from types to types
09:36:05 <tac-tics> List isn't a type
09:36:10 <tac-tics> List Int *is*
09:36:15 <rostayob> aaandroid: a type constructor is a function that returns a data type
09:37:14 <tac-tics> There's term space, with lambdas and 1,2,3 and "a", "b", "c"... and there's type space, with Int, Char, List, Either
09:37:19 <applicative> @kind Maybe
09:37:21 <lambdabot> * -> *
09:37:28 <Cale> When we define data structures in Haskell using data declarations, we define both type constructors and data constructors.
09:37:31 <Cale> For example:
09:37:37 <tac-tics> Each thing in type space has a type.. but since it's a "type of a type" we call it a kind instead
09:37:39 <applicative> @kind []
09:37:39 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
09:37:40 <lambdabot> * -> *
09:37:47 <Cale> defines a type constructor Tree
09:37:54 <Cale> and two data constructors Tip and Branch
09:38:51 <Cale> Tree exists in the world of types, i.e. it only occurs on the right hand side of ::
09:39:04 <rostayob> aaandroid: this is likely to be confusing, check out "learn you a haskell"
09:39:06 <rostayob> @where LYAH
09:39:07 <lambdabot> http://www.learnyouahaskell.com/
09:39:14 <Cale> and Tip/Branch exist in the world of values, on the left hand side of ::
09:39:33 * hackagebot Glob 0.6.1 - Globbing library  http://hackage.haskell.org/package/Glob-0.6.1 (MattiNiemenmaa)
09:39:33 <Cale> Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip) :: Tree Integer
09:39:45 <koeien> yes, so "Tree" has no type. it does have a "kind", namely * -> *
09:39:46 <aaandroid> i'm reading that now as well, but it's still not clicking
09:39:59 <applicative> @kind ()
09:40:00 <lambdabot> *
09:40:32 <Cale> I don't know how much Haskell you know already, so it's a little hard to tune my description of this to what you know
09:41:06 <Cale> But yeah, if you define some data structure, it will tend to have a type constructor associated with it
09:41:18 <c_wraith> The more I think about it, the more I support the idea of deprecating standard data syntax, and replacing it with GADT syntax.  (Still not allowing GADTs unless the extension is used.)  This would separate data constructors from their types in a much more clean way.
09:41:26 <applicative> @kind StateT
09:41:27 <lambdabot> * -> (* -> *) -> * -> *
09:41:33 <Cale> as well as some ways to build values of that datatype, which are data constructors
09:41:47 <tac-tics> @kind stateT Int List Char
09:41:48 <lambdabot> Not in scope: type variable `stateT'
09:41:48 <lambdabot> Not in scope: type constructor or class `List'
09:41:52 <zzo38> Is there way by using Template Haskell to write programs in other categories instead of (but as well as) Hask?
09:41:54 <Cale> Yeah, in GADT syntax, the tree type looks like:
09:41:54 <tac-tics> @kind StateT Int List Char
09:41:55 <lambdabot> Not in scope: type constructor or class `List'
09:41:58 <Cale> data Tree a where
09:42:03 <Cale>   Tip :: Tree a
09:42:12 <Cale>   Branch :: a -> Tree a -> Tree a -> Tree a
09:42:43 <parcs> are types of kind * type constructors?
09:42:51 <applicative> @kind StateT Int [] Char
09:42:52 <lambdabot> *
09:42:52 <tac-tics> GADT is overly verbose for most boring datatypes
09:43:01 <Cale> parcs: they can be (nullary) type constructors
09:43:20 <applicative> parcs, I would have thought you'd have to say that
09:43:27 <parcs> oh, like nullary functions :P
09:43:27 <Cale> tac-tics: but then, most boring datatypes will still only be a couple lines
09:43:53 <Cale> parcs: data constructors can also be nullary
09:43:54 <applicative> Similarly Nothing and [] are data constructors, in the jargon
09:44:10 <Cale> even though they're not functions then
09:44:28 <tac-tics> Cale: In Java, writting your own setters and getters is still only a few lines, but it's still kinda tedious >___>
09:44:48 <applicative> the haskell98 syntax for data type declarations is incredibly beautiful.
09:45:16 <Cale> The Haskell 98 syntax is beautiful, but it doesn't extend very nicely.
09:45:34 <tac-tics> I also happen to love hating on haskell's part-wise function defs where you have to repeat the function name over and over.
09:45:54 <Cale> If you want to cram any other features in there, it starts becoming ugly.
09:45:58 <parcs> tac-tics: some prefer GADT syntax for its consistency with the rest of the syntax
09:46:00 <applicative> true enough, but there is a genuine idea attached to it, it has its own integrity
09:46:07 <zzo38> Other feature I would like in there, is macros, both hygienic and unhygienic, that can be used to make up things such as do notation and list notation and so on, even if you do not already have do notation and list notation.
09:46:13 <parcs> haskell syntax*
09:46:14 <Cale> tac-tics: If you don't like that, then use a case expression.
09:46:39 <parcs> i think 7.2 even introduced a GADTSyntax language extension that provides just that
09:46:53 <Cale> parcs: ?
09:47:04 <cheater> what is the difference between haskell 98 syntax and gadt syntax?
09:47:08 <Cale> GADTs have been around for a long time
09:47:10 <cheater> can you guys give me an example of each?
09:47:17 <Cale> cheater: I just did
09:47:29 <Cale> (I defined a binary tree datatype in two ways)
09:47:49 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a) -- Haskell98 syntax
09:47:55 <Cale> data Tree a where
09:47:56 <koeien> cheater: data T = A | B vs data T :: * where { A :: T; B :: T}
09:47:57 <Cale>   Tip :: Tree a
09:47:59 <Cale>   Branch :: a -> Tree a -> Tree a -> Tree a
09:48:04 <parcs> Cale: GADTSyntax just provides the syntax, not the extra power
09:48:05 <koeien> but Cale's example is nicer.
09:48:10 <Cale> parcs: ah
09:48:10 <obiwahn> > (\x-> x x)
09:48:11 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
09:48:31 <zzo38> Is there any possibility to have such macros like I described?
09:48:33 <obiwahn> > (\x-> x x) (\x-> x x) :P
09:48:34 <lambdabot>   Not in scope: data constructor `P'
09:49:03 <hpaste> applicative pasted “gadt v. 98” at http://hpaste.org/51335
09:49:04 <obiwahn> > disable typechecking
09:49:05 <lambdabot>   Not in scope: `disable'Not in scope: `typechecking'
09:49:05 <koeien> zzo38: the syntax is fixed. you can, of course, write your own combinators. You can also use quasiquoting
09:49:07 <cheater> koeien, the left one is haskell 98 right?
09:49:09 <Cale> zzo38: Kinda
09:49:11 <koeien> cheater: yes.
09:49:37 <koeien> cheater: I think there is an article on GADTs on the wiki
09:49:39 <Cale> zzo38: There's a quasiquoting TH extension which gives you the ability to take over parsing of the code.
09:49:39 <applicative> cheater ^^^ see my illustration, not that its needed
09:49:57 <aaandroid> let me rephrase my earlier question: how is a data type different from a data structure?
09:50:08 <Cale> zzo38: But you have to start your quasiquoted expressions in a particular way. It's not like you get to preprocess everything.
09:50:11 <parcs> cheater: data `Maybe a = Nothing | Just a` vs `data Maybe a where Nothing :: Maybe a; Just :: a -> Maybe a` is another example
09:50:36 <Cale> zzo38: Of course, you can also write custom preprocessors and tell GHC to apply them.
09:51:01 <koeien> [f| ... |]   is the syntax I believe. You define or import the function f that parses whatever is given, and returns Haskell definitions/expressions
09:51:25 <Cale> aaandroid: A type is a property of the program which is checked at compile time and then discarded. It doesn't (generally) exist at runtime.
09:51:32 <koeien> Yesod makes heavy use of quasiquoting
09:51:39 <Cale> aaandroid: A data structure is a value which exists in some form in the running program.
09:52:31 <Cale> aaandroid: Of course, you don't necessarily have to have compilation erase types, but type erasure is certainly something which can be done in Haskell.
09:52:39 <applicative> @type "hello world"
09:52:40 <lambdabot> [Char]
09:52:59 * applicative is trying to think of "hello world" as a program
09:53:10 <Cale> sure, it's a program
09:53:17 <Cale> it's just a very simple one
09:54:23 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
09:54:25 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
09:54:31 * applicative is trying to erase the type from "hello world"
09:54:36 <Cale> ^^ that list might be easier to think about as a program
09:54:45 <Cale> Well, the type is [Char]
09:54:56 <Cale> You can just forget that it's a list of characters
09:55:17 <Cale> and it just becomes a bunch of pointers and so on in memory.
09:55:48 <cheater> applicative, what illustration?
09:55:51 <geheimdienst> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in map chr primes
09:55:53 <lambdabot>   "\STX\ETX\ENQ\a\v\r\DC1\DC3\ETB\GS\US%)+/5;=CGIOSYaegkmq\DEL\131\137\139\14...
09:55:59 <Cale> lol
09:56:09 <aaandroid> Cale: the Tree you declared, is it a type or a structure?
09:56:25 <int-e> CGI is a sequence of primes?
09:56:27 <Cale> aaandroid: 'Tree' is a type constructor
09:56:35 <int-e> funny.
09:56:38 <applicative> cheater http://hpaste.org/51335 Not of any use now.
09:56:39 <Cale> 'Tree Integer' is a type, which actual values can have
09:56:53 <Cale> The tree value I described...
09:57:01 <cheater> why not of any use?
09:57:09 <Cale> Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip) :: Tree Integer
09:57:10 <aaandroid> Cale: sorry, i meant the result of calling the Tree constructor
09:57:35 <applicative> cheater, just that the same and similar examples were given here
09:57:40 <Cale> This thing built from the data constructors Branch and Tip, along with 1,2,3 is a value.
09:57:52 <Cale> Which you could also call a data structure
09:58:17 <cheater> ahh ok :)
09:58:41 <Cale> I guess people also sometimes use the words "data structure" to refer to the type
09:58:47 <Cale> So it's a little vague in that regard
09:59:02 <Cale> But value/type are clear terminology
09:59:26 <applicative> cheater, this is an example of gadt syntax that can be rewritten in Haskell 98 form.  An example requiring Gadt syntax would be different
09:59:26 <aaandroid> Cale: so the type describes the structure?
09:59:46 <aaandroid> among other things?
09:59:54 <Cale> aaandroid: Yeah, it describes something about how the value is built up.
10:00:34 <cheater> what is an example of gadt syntax that cannot be put in h98 form?
10:00:48 <Cale> If t is some type, then every value of type Tree t is either the constant Tip, or it consists of the data constructor Branch applied to a value of type t along with two other values of type Tree t.
10:01:05 <Cale> cheater: okay
10:01:10 <tac-tics> cheater: data Foo x = bar :: Foo Int
10:01:10 <Cale> data Expr a where
10:01:19 <Cale>    Lit :: Integer -> Expr Integer
10:01:31 <Cale>    IsZero :: Expr Integer -> Expr Bool
10:01:48 <Cale>    If :: Expr Bool -> Expr a -> Expr a -> Expr a
10:01:55 <cheater> why can those not be put in h98 form?
10:02:04 <hpaste> applicative annotated “gadt v. 98” with “gadt v. 98 (annotation)” at http://hpaste.org/51335#a51336
10:02:15 <applicative> cheater ^^^ see data Perhaps a
10:02:16 <Cale> Because the H98 notation doesn't give you any way to restrict the parameter type of the result
10:02:20 <koeien> cheater: because Lit 3, would then be Expr a (in H98).
10:03:07 <nus> @google Types are Calling Conventions
10:03:09 <lambdabot> http://www.cl.cam.ac.uk/~mb566/papers/tacc-hs09.pdf
10:03:09 <lambdabot> Title: Types Are Calling Conventions
10:03:19 <Cale> The best approximation we can do in H98 would be   data Expr a = Lit Integer | IsZero (Expr Integer) | If (Expr Bool) (Expr a) (Expr a)
10:03:24 <Cale> but this has problems
10:03:51 <Cale> In particular, IsZero (Lit 2) isn't necessarily Expr Bool
10:03:58 <Cale> (it's more polymorphic)
10:04:09 <Cale> With the GADT, we can write:
10:04:14 <Cale> eval :: Expr a -> a
10:04:17 <aaandroid> so impure functions are needed for inputting/outputting data that is operated on by pure functions?
10:04:19 <Cale> eval (Lit n) = n
10:04:40 <Cale> eval (IsZero e) = eval e == 0
10:04:57 <Cale> eval (If b t e) = if eval b then eval t else eval e
10:04:57 <applicative> @type interact
10:04:58 <lambdabot> (String -> String) -> IO ()
10:05:10 <Cale> aaandroid: Well, not necessarily impure functions.
10:05:32 <Cale> aaandroid: Haskell defines a type for IO actions, which describe input and output to be performed.
10:05:33 <nus> hmm, looks like Max Bolingbroke decided to pursue supercompilators instead of working on strict core
10:05:48 <Cale> IO actions aren't functions, because they don't have parameters
10:06:18 <applicative> aaandroid, i guess interact is an impure function, which takes a pure function as argument.  the compiled main = interact reverse would take the string from stdin, apply the pure function "reverse" and output the result
10:06:25 <Cale> If t is any type, then a value of type IO t abstractly describes some I/O which could be performed to produce a value of type t.
10:07:05 <Cale> Performing that IO action is impure, but thankfully, since it's just a *description*, we can evaluate it without causing anything to occur.
10:07:31 <Cale> There's a separation between evalution of expressions describing IO actions, and execution of the resulting actions by the runtime system.
10:07:31 <koeien> the only way to perform IO actions in by sticking them in "main"
10:08:09 <tac-tics> It's like freedom of speech
10:08:15 <hpaste> applicative annotated “gadt v. 98” with “gadt v. 98 (annotation) (annotation)” at http://hpaste.org/51335#a51337
10:08:16 <tac-tics> You can talk about launching nukes all you want
10:08:19 <koeien> but the actions are first-class values. You can pass them to other functions.
10:08:22 <obiwahn> > let olo = "lol" in let tr x = show x in tr olo
10:08:23 <lambdabot>   "\"lol\""
10:08:24 <tac-tics> But you're not actually launching them until you run it
10:08:55 <applicative> cheater, pardon my idiotic Blah vs. Perhaps nonsense,  the emended version is http://hpaste.org/51337
10:08:58 <Cale> aaandroid: To make this more concrete, we can look at some example code, it's actually a lot simpler than it sounds :)
10:09:10 <obiwahn> waht can i do to get rid of the superfluous "
10:09:19 <Cale> aaandroid: getLine :: IO String is an action which when executed gets a line of text from the user
10:09:26 <cheater> applicative, heheh
10:09:27 <koeien> obiwahn: don't use show.
10:09:55 <Cale> putStrLn :: String -> IO () is a function which constructs an action for printing a line of text on the screen (that action produces an empty tuple as its result)
10:09:57 <applicative> obiwahn you can drop show?
10:09:59 <obiwahn> > let olo = 4 in let tr x = show x in tr olo
10:09:59 <lambdabot>   "4"
10:10:03 <obiwahn> ok:)
10:10:11 <applicative> > let olo = "lol" in let tr x = x in tr olo
10:10:12 <obiwahn> > let olo = 4 in let tr x = x in tr olo
10:10:12 <lambdabot>   "lol"
10:10:13 <lambdabot>   4
10:10:33 <obiwahn> show != putStr ....
10:10:56 <koeien> an empty tuple just means, "we are not interested." it could, in theory, also return the number of characters output. Then it would be putStrLn :: String -> IO Integer
10:11:02 <Cale> We can glue simpler actions into more complicated ones using do-notation:  (do x <- getLine; putStrLn x) :: IO ()  will get a line of text from the user and print it back out
10:11:11 <applicative> obiwahn, inside ghci you can use prettyprinting functions
10:11:49 <applicative> > let olo = "lol" in let tr x = text x in tr olo
10:11:50 <lambdabot>   lol
10:11:53 <Cale> In that code, x :: String is the result of executing getLine. It scopes over the remainder of the do-block.
10:11:55 <tac-tics> In Haskell, you can't return nothing from a function. But you can return something totally worthless. () is totally worthless.
10:12:15 <Cale> You can return Nothing from a function ;)
10:12:24 <Cale> lol
10:12:27 <benmachine> tac-tics: I wouldn't say worthless! it's just... not that informative
10:12:37 <darrint> But you can't not return something.
10:12:46 <aaandroid> Cale: what do you mean by action?
10:12:56 <applicative> > let f :: Int -> Maybe Int ; f x = Nothing in f 3
10:12:58 <lambdabot>   Nothing
10:13:07 <Cale> aaandroid: An action is one of these values which describes some I/O that could be performed.
10:13:14 <koeien> aaandroid: an action is different from a function. It's somewhat like a "function" in an imperative language
10:13:27 <Cale> More like a procedure with no paramters.
10:13:30 <Cale> parameters*
10:13:41 <koeien> yes, that is more accurate.
10:15:01 <Cale> You can think of an IO action as being represented internally by some source code for a C program, perhaps. Evaluating it won't cause anything to happen, any more than loading the source code into a text editor would cause that program to run. Executing it will cause arbitrary things to occur.
10:15:25 <applicative> aaandroid, an action is what you ask the compiler to make your computer capable of
10:15:55 <Cale> ... I guess that works :)
10:17:10 <Cale> You could also think of it as an abstract syntax tree internally. It turns out that the actual implementation in GHC is uglier and cheats by using impure functions that pass around a meaningless token (so that it can use GHC's dependency analysis to keep things ordered), but you don't have to think of it like that.
10:17:26 <tac-tics> benmachine: Fine. () isn't useless. It's use *is* its own uselessness.
10:17:27 <tac-tics> :)
10:17:36 <benmachine> :P
10:18:29 <Cale> aaandroid: The nice thing about having actions which are first class values is that we can write functions which take them as parameters and do stuff to transform them -- that is, control structures. :)
10:18:36 <Cale> For example...
10:18:39 <koeien> :t forever
10:18:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:18:53 <Cale> loop 0 x = return ()
10:18:54 <koeien> this actually says, forever :: IO a -> IO a
10:19:05 <Cale> loop n x = do x; loop (n-1) x
10:19:29 <Cale> Then  loop 5 (putStrLn "hello") :: IO ()
10:19:41 <Cale> will be an action which prints hello 5 times
10:19:44 <applicative> the return type of forever is pretty wonderful.
10:19:56 <Cale> koeien: IO a -> IO b
10:20:06 <koeien> Cale: ah, ty.
10:20:25 <koeien> forever x = do x; forever x -- you could write forever like this
10:20:44 <Cale> indeed
10:21:06 <Cale> aaandroid: We could also collect up a list of the results of our action in our definition of loop:
10:21:12 <Cale> loop 0 x = return []
10:21:33 <Cale> loop n x = do v <- x; vs <- loop (n-1) x; return (v:vs)
10:22:04 <Cale> then  loop 5 getLine  will get 5 lines of text from the user and produce a list of them
10:22:08 <Cale> (when run)
10:22:18 <Ptival> can we invite lambdabot to #haskell-fr?
10:22:29 <Cale> lambdabot: @join #haskell-fr
10:22:39 <aaandroid> Cale: I have to go now, bbl...thanks for your help!
10:22:41 <Ptival> says I need privileges :(
10:23:09 <Ptival> oh it's ok
10:23:13 <Ptival> well thanks
10:23:19 <Cale> Ptival: It's autojoining #haskell.fr
10:23:41 <Ptival> yeah but we're moving away from it for technical reasons
10:23:50 <Cale> okay...
10:23:57 <Cale> should I change it?
10:24:02 <Ptival> yes please
10:24:14 <Cale> done
10:24:34 <Ptival> thanks
10:25:27 <geheimdienst> <fake-french-accent> oh, la monade est simplement une monoide dans la categorie d'endofuncteurs ...
10:25:38 <monochrom> hahaha
10:25:47 <applicative> wow, they talk about Haskell in French in #haskell-fr
10:25:58 <benmachine> that is amazing
10:26:05 <applicative> geheimdienst: how do they say "burrito" in French?
10:26:09 <geheimdienst> wait, i forgot to randomly sprinkle ` and ´ onto the vowels
10:26:20 <geheimdienst> applicative: baguette?
10:26:27 <olsner> l'burritó?
10:28:07 * applicative proposes #haskell-haskell in which you can only talk about Haskell in valid Haskell
10:28:30 * geheimdienst doesn't know french but joined #haskell-fr anyways. geheimdienst is now giggling that the topic says the channel is a "salon"
10:28:33 <monochrom> putStrLn "that's easy"
10:28:48 <applicative> how wonderful
10:29:02 <monochrom> "oh, you want no side effects. here it is."
10:29:25 * applicative concedes its easier than he thought
10:29:41 * monochrom hacks every system!
10:31:05 <applicative> well i'm once again defeated building the tarball for ghc 7.3.  ... but I want ConstraintKinds!
10:31:36 <tac-tics> applicative: What's an example of a usecase for constraint kinds?
10:32:04 <olsner> ... just using constraint kinds isn't a valid usecase? :)
10:32:16 * monochrom was the first inventor of the putStrLn "<IO ()>" hack. actually, back then, the error message was different, something like "no Show for IO () etc", so the first hack was putStrLn "no Show for IO () etc"
10:32:25 <applicative> well, I was sort of wanting to find out  http://blog.omega-prime.co.uk/?p=127
10:33:14 * applicative is with olsner, he wants ConstraintKinds for their own sakes
10:33:44 <monochrom> "a whacking great load of extensions" haha
10:33:51 <tac-tics> Also, can someone explain why literate haskell is so popular? I have never felt a need to execute your blog's HTML output :/
10:33:56 <olsner> monochrom: so you replaced the error message with a show instance that printed the same message?
10:34:02 * applicative is still listening in on #haskell-fr  It's clear the exposition is much more lucid there
10:34:32 <monochrom> no, I putStrLn the error message
10:34:36 <applicative> tac-tics, in the standard web use of literate haskell, the underlying html is not literate haskell
10:34:52 <applicative> what you cut and paste is literate haskell
10:35:18 <applicative> i would never read a literate haskell post without compiling it first!
10:35:27 * koeien wants <script language="text/haskell">
10:35:29 <tac-tics> lawl
10:35:30 <monochrom> except that the blog post is not in literal haskell if you copy and paste
10:37:10 * applicative is not sure what the real blog post is.  he's inclined to think it's the same as what you copy and paste, not the html that offers this to the eyes and the copy and paste mechanism
10:37:13 <geheimdienst> tac-tics: i think the idea is that if documentation is best and most up-to-date when it's closest to the code. if your documentation is in some microsoft word file in some faraway directory, chances are it's drifted out of sync with the code
10:38:51 <tac-tics> I'm unconvinced of its legitimacy.
10:38:56 <applicative> literate haskell is totally awesome, that other programming languages don't have it when it's been around since before Miranda, is more proof that they have something to hide
10:39:23 * byorgey supports adding literate Haskell to other languages
10:40:07 <Cale> Including the Haskell part?
10:40:10 <Cale> ;)
10:40:18 <byorgey> yes, that's the point!
10:40:20 <dafis> Cale: particularly that
10:40:24 <kmc> heh, haskell-fr
10:40:35 * applicative agrees, we will destroy them from within!
10:40:35 <kmc> "Les Monades"
10:40:36 <Ptival> geheimdienst: it's actually "un monoïde" :D
10:40:44 <kmc> lemonades?
10:40:46 <Ptival> and burrito is transparent... we didn't name this
10:40:51 <olsner> applicative: when I try writing literate haskell what I get is a program with no lines not starting with >
10:40:58 <geheimdienst> Ptival: ;)
10:40:59 <applicative> Ptival, your salon is wonderful
10:41:13 <dafis> olsner: wrong style, \begin{code}
10:41:20 <kmc> lhs is good for blog posts
10:41:21 <byorgey> as the one who did name burritos, I give #haskell-fr permission to use an appropriate French word instead
10:41:48 <Ptival> applicative: haha, never had that much people in there :D
10:41:49 <applicative> it's insanely good for blog posts, it's like it was a prophecy
10:41:52 <monochrom> el burrito
10:41:55 <Ptival> -much+many
10:41:55 <kmc> une monade est comme une crêpe
10:42:04 <tac-tics> I guess if your major contribution to the world is blog posts and postscript papers, literate haskell is pretty cool -.-;;
10:42:11 <tac-tics> heh
10:42:14 <dafis> olsner: and, do you get a reasonabl fraction of lines beginning with "> --"?
10:42:15 <tac-tics> I don't know why I hate it so much
10:42:20 <olsner> ah, crêpe, sounds like a good translation
10:42:24 <kmc> specifically markdown+pandoc+lhs
10:42:25 <Ptival> yep, crêpe is quite the idea
10:42:25 <geheimdienst> kmc: +1 for a good translation
10:42:35 <monochrom> crêpe delicious!
10:42:51 <monochrom> @remember kmc une monade est comme une crêpe
10:42:51 <lambdabot> Nice!
10:42:52 <Ptival> crêpe suzette is a MonadPlus
10:43:01 <kmc> una mónada es como un burrito
10:43:09 <olsner> dafis: no, but sometimes i get "> [code] -- comment"
10:43:36 <applicative> tac-tics, if you are writing about programming and don't use a literate language, you are lying
10:43:46 <applicative> thats really all there is to it
10:43:47 <kmc> eine Monade ist wie ein Strudel
10:43:54 <Ptival> kmc: hahaha
10:44:00 <byorgey> hehehe
10:44:03 <tac-tics> applicative: I thought your type system was the thing that was supposed to keep you honest
10:44:04 <monochrom> @forget kmc une monade est comme une crêpe
10:44:04 <lambdabot> Done.
10:44:23 <monochrom> @remember kmc une monade est comme une crêpe. una mónada es como un burrito. eine Monade ist wie ein Strudel
10:44:23 <applicative> in welcher Weise, kmc?
10:44:24 <lambdabot> Okay.
10:44:24 <Ptival> note sure you can unwrap a strudel that easily :s
10:44:31 <Ptival> not*
10:44:43 <geheimdienst> unwrapping strudels is unsafe
10:44:55 <dafis> applicative: Skylla (or was it Charybdis?)
10:45:00 <olsner> applicative: wie ein Strudel
10:45:10 <dafis> i.e.: dangerous, best to be avoided
10:45:14 <kmc> when i gtranslate "monad" to Chinese it comes back as "list"
10:45:44 <TheLemonMan> hello, im having some problems with the tail call
10:45:46 <applicative> tac tics don't worry, the type checker checks lhs files
10:45:56 <applicative> to see if the writer is lying
10:46:05 <TheLemonMan> ghc keeps bitching about types
10:46:14 <c_wraith> TheLemonMan: that means you made a mistake.
10:46:15 <dafis> TheLemonMan: more specifically?
10:46:20 <geheimdienst> wasn't there some tutorial explaining monads in terms of apples? we could extend it with the apfelstrudel metaphor
10:46:25 <monochrom> then it is a type problem, not a tail call problem
10:46:25 <Ptival> wow, China is doing crazy type coercion!
10:46:45 <TheLemonMan> it's linked to tail return
10:46:47 * monochrom doesn't like beginners assigning blames prematurely
10:46:48 <Ptival> at least it's kind safe :\
10:46:51 <kmc> 单子 ≡ "monad" but 一个单子 ≡ "a list"
10:46:51 <c_wraith> do monads and cheese even have the same kind?
10:47:00 <rwbarton> kmc: probably the monomorphism restriction at work
10:47:09 <c_wraith> oh.  list.  holy heck, I read that wrong.
10:47:13 <obiwahn> > \x -> puls x
10:47:14 <lambdabot>   Not in scope: `puls'
10:47:20 <obiwahn> > \x -> plus x
10:47:21 <lambdabot>   Not in scope: `plus'
10:47:24 <byorgey> c_wraith: only certain cheeses.
10:47:26 <kmc> rwbarton, hahaha
10:47:46 <Ptival> wow c_wraith, you really crave cheese to read this instead of list, don't you? @__@
10:47:54 <Cale> Do monads have the same kind as a 6 pool?
10:47:57 <c_wraith> Ptival: I'm hungry.  is it lunch time?
10:48:13 <applicative> > (\x -> (+x)) 2 3
10:48:14 <lambdabot>   5
10:48:22 <TheLemonMan> http://pastie.org/2533215
10:48:30 <kmc> the monad chapter of LYAH hasn't been translated to czech yet :/
10:48:31 <Ptival> so cheese is not a burrito...
10:48:37 <Gracenotes> monads are containers which fit polymorphic values into cheese holes
10:48:45 <obiwahn> > \x -> f x
10:48:46 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1)
10:48:46 <lambdabot>    arising from a use of ...
10:48:47 <koeien> TheLemonMan: try to indent "else"
10:48:53 <monochrom> 单 can mean "unit", "one", "unary". so 单子 is the "monad" as in "monadic second order logic", i.e., just "unary".
10:48:56 <dafis> TheLemonMan: if x == last xs
10:49:12 <kmc> aha
10:49:21 <koeien> TheLemonMan: yes, "tail" and "last" are different
10:49:24 <koeien> > tail [1,2,3]
10:49:24 <lambdabot>   [2,3]
10:49:26 <koeien> > last [1,2,3]
10:49:26 <lambdabot>   3
10:49:27 <applicative> obiwan, you just asked lambdabot to show you id
10:49:29 <obiwahn> why does the bot give that error
10:49:39 <TheLemonMan> ooh, i see
10:49:42 <monochrom> 单 can also mean bill
10:49:46 <obiwahn> and why is n-reduction not useful in haskell
10:49:52 <c_wraith> obiwahn: because lambdabot has multiple show instances for functions in scope
10:49:57 <obiwahn> \x -> f x -> f
10:50:08 <kmc> η-reduction?
10:50:09 <koeien> it's very useful.
10:50:11 <Nimatek> > let isPalindrome xs = xs == reverse xs in isPalindrome "lol"
10:50:11 <kmc> who said it's not useful?
10:50:12 <lambdabot>   True
10:50:15 <Cale> obiwahn: You mean eta reduction?
10:50:23 <koeien> the only thing is the monomorphism restriction.
10:50:25 <obiwahn> jep
10:50:49 <TheLemonMan> huh, now it says "arising from a use of `/='"
10:51:03 <koeien> TheLemonMan: could you update your paste?
10:51:25 <c_wraith> Cale: Can you find a way to get lambdabot down to just one show instance for functions in scope?
10:51:28 <TheLemonMan> is /= the equivalent of != in C ?
10:51:33 <monochrom> yes
10:51:40 <koeien> yes, /= means "is not equal to"
10:51:56 <koeien> is looks more like the symbol commonly used in mathematics
10:51:56 <dafis> TheLemonMan: you need an Eq a => [a] -> Bool as the type
10:52:01 <Nimatek> TheLemonMan: you're trying to compare x which is of type a with tail xs, which is of type [a]
10:52:02 <c_wraith> ≠, give or take
10:52:26 <hpaste> int80_h pasted “abort evaluation of a list of  functions after catching an exception” at http://hpaste.org/51338
10:52:29 <TheLemonMan> i updated the paste
10:52:34 <koeien> TheLemonMan: what dafis says is right. It means that only for types for which the equality operator is defined, you can use /= and ==
10:53:41 <koeien> TheLemonMan: what dafis said. Use Eq a => [a] -> Bool. (Also, you forgot some cases. You will find out when it typechecks. For example, is [] a palindrome? What about [1]?)
10:54:33 <applicative> pastie.org where "All your pastes are belong to us. "
10:55:03 <monochrom> I don't actually mind that
10:55:39 <monochrom> I only mind paste bins that for no reason contains flash
10:55:46 <dafis> TheLemonMan: in addition to what koeien said, your (init (tail xs)) is wrong, you don't want the tail
10:56:08 <TheLemonMan> yeah, i replaced it with last
10:56:22 <hpaste> applicative pasted “palindrome” at http://hpaste.org/51339
10:57:12 <TheLemonMan> is it allowed to declare guards after the do ?
10:57:36 <Nimatek> You don't need the do.
10:57:52 <TheLemonMan> isn't that part of the haskell style ?
10:57:55 <koeien> no.
10:58:09 <koeien> the haskell way is more declarative
10:58:38 <monochrom> the haskell style is "be minimal"
10:58:47 <hpaste> applicative annotated “palindrome” with “palindrome (annotation)” at http://hpaste.org/51339#a51340
10:59:18 <Nimatek> Also, while it is a good mental practice to define recursive functions, you can save yourself some time by leaving the 'step by step' imperative thinking behind and using better abstractions where possible.
10:59:38 <obiwahn> with my ghci i get fnot in scope .. in the lecture i watch the prof said that there will be problem with show but i still do not really get waht is going on:(
10:59:45 <hpaste> koeien annotated “palindrome” with “palindrome (annotation) (annotation)” at http://hpaste.org/51339#a51341
11:00:03 <int-e> applicative: hmm, 'init' is rather expensive. why don't you compare xs to reverse xs?
11:00:06 <applicative> TheLemonMan: note that hlint complains about the excessive 'do's in the version I put on hpaste
11:00:07 <dafis> int80_h: if you catch within the mapM'ed function, there is no reason to stop the execution. Does it do what you want if you mapM foo [funs] `catch` exceptionHandler?
11:00:11 <koeien> obiwahn: what are you trying to do?
11:00:13 <Nimatek> TheLemonMan: As I wrote above, that function could be a simple oneliner: isPalindrome xs = xs == reverse xs
11:00:40 <applicative> int-e, it's LemonMan's definition, I was just starting to think about it
11:00:40 <monochrom> solve the not-in-scope problem first
11:00:49 <obiwahn> koeien: atm i am learning about alpha, beta, delta reduction
11:00:57 <TheLemonMan> i still have to detach my mind from the imperative model, its really hard heh
11:01:21 <obiwahn> and the eta reduction was given as kind of bonus that is not required but can be nice
11:02:15 <monochrom> what is delta reduction?
11:03:06 <obiwahn> something like c t1 t2 t3 where c stands for a builtin function
11:03:40 <obiwahn> but you need 4 additional rules to keep confluence (church ross.. property)
11:03:50 <monochrom> so something like 0+0 --> 0 is a delta reduction?
11:04:02 <int-e> obiwahn: Rosser
11:04:04 <conal> roconnor: ping
11:04:04 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:04:30 <TheLemonMan> i guess the if evaluation behaves the same as in C, so if <expr> then checks if the expression is true
11:04:33 <hpaste> dafis annotated “abort evaluation of a list of  functions after catching an exception” with “abort evaluation of a list of  functions after catching an exception (annotation)” at http://hpaste.org/51338#a51342
11:06:28 <Nimatek> TheLemonMan: Do not confuse the two though. The Haskell if-then-else is more like the C ?: ternary operator. It's not like the C if-else control flow.
11:06:29 <koeien> TheLemonMan: if is very different from the if in C
11:06:39 <koeien> TheLemonMan: in particular, if requires both then and else
11:07:04 <koeien> also, you can write,
11:07:04 <conal> @tell roconnor GtkTV shows a simpler way to rewrite GuiTV (more aptly named wxTV) without needing reactive or phooey.
11:07:05 <lambdabot> Consider it noted.
11:07:22 <koeien> @def if' c t f = if c then t else f
11:07:22 <lambdabot> Maybe you meant: bf do let
11:07:27 <koeien> @let if' c t f = if c then t else f
11:07:28 <lambdabot>  Defined.
11:07:33 <koeien> and now you never need "if" again.
11:07:42 <koeien> :t ifc'
11:07:43 <lambdabot> Not in scope: `ifc''
11:07:45 <koeien> :t if'
11:07:46 <lambdabot> forall t. Bool -> t -> t -> t
11:08:10 <copumpkin> koeien: I think the other order is more useful
11:08:20 <koeien> t -> t -> Bool -> t ?
11:08:21 <copumpkin> @def bool t f c = if c then t else f
11:08:21 <lambdabot> Maybe you meant: bf do let
11:08:35 <copumpkin> @define bool t f c = if c then t else f
11:08:41 <copumpkin> @let bool t f c = if c then t else f
11:08:42 <lambdabot>  Defined.
11:09:17 <roconnor> conal: GuiTV (aka wxTV) must rely on phooey because phooey is the interface to wxHaskell ... unless you mean GuiTV should bypass phooey and deal with wxHaskell directly.
11:09:17 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
11:09:42 <conal> roconnor: exactly. bypass phooey.
11:09:52 <roconnor> i see
11:10:12 <roconnor> I'd actually have to learn how GuiTV/GtkTV are implemented to do that :)
11:10:26 <conal> roconnor: just GtkTV
11:10:29 <applicative> TheLemonMan: your isPalindrome fails for "aa"
11:11:41 <dyn> what was the code for isPalindrome>
11:11:43 <dyn> hi
11:11:53 <copumpkin> :t ap (==) reverse
11:11:54 <lambdabot> forall a. (Eq a) => [a] -> Bool
11:11:59 <monochrom> hehe
11:12:05 <copumpkin> > (==) <*> reverse
11:12:06 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> GHC.Bool.Bool)
11:12:06 <lambdabot>    arising f...
11:12:08 <int-e> applicative: err it should work for strings of even length
11:12:10 <copumpkin> > (==) <*> reverse $ [1..10]
11:12:12 <lambdabot>   False
11:12:17 <copumpkin> > (==) <*> reverse $ [1,2,3,2,1]
11:12:17 <int-e> applicative: unless I'm missing something?
11:12:18 <lambdabot>   True
11:12:18 <bayesian> haskell
11:12:33 <conal> roconnor: if i'm able to install wxHaskell on my mac, i could help.
11:13:04 <roconnor> conal: are you going to be at ICFP?
11:13:06 <Eidel> Does anyone know the best way to search a tree structure (where each child only has one child)?
11:13:19 <hpaste> applicative annotated “palindrome” with “palindrome (annotation) (annotation)” at http://hpaste.org/51339#a51343
11:13:20 <hpaste> applicative annotated “palindrome” with “palindrome (annotation) (annotation)” at http://hpaste.org/51339#a51344
11:13:21 <bayesian> the best way is breadth first
11:13:36 <bayesian> anyone who recommends depth first is a liar
11:13:52 <conal> roconnor: or maybe you could use GtkTV instead (and gtk underneath it).
11:13:55 <copumpkin> bayesian: each has its pros and cons
11:14:07 <roconnor> wow, cybernetics means something totally different from what I had thought.
11:14:13 <conal> roconnor: no, i won't be at ICFP this year. will you?
11:14:31 <bayesian> depth apologist
11:14:32 <obiwahn> :t <*>
11:14:33 <lambdabot> parse error on input `<*>'
11:14:47 <monochrom> each child has only one child? branching factor 1? then every known search algorithm does the same thing
11:14:50 <roconnor> conal: Ya I'll probably switch to GtkTV.  It didn't immediately build properly because I needed some dependencies.  I haven't pursued it further yet.
11:14:51 <dafis> :t (<*>)
11:14:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:15:02 <roconnor> conal: Yes, I'm going to ICFP.
11:17:21 * roconnor needs to learn some control theory
11:17:39 <applicative> bayesian, you breadth denialist, you!
11:18:36 <bayesian> could you consider haskell programming as music oscillating from a field of of infinite computational xylophones?
11:18:43 <KirinDave> How does one display a float in haskell with fixed precision?
11:18:45 <monochrom> I could not.
11:18:51 <KirinDave> Is it printf?
11:19:00 <geheimdienst> > print 5.2
11:19:01 <lambdabot>   <IO ()>
11:19:05 <geheimdienst> oh grate
11:19:15 <hpaste> dafis annotated “abort evaluation of a list of  functions after catching an exception” with “abort evaluation of a list of  functions after catching an exception (annotation)” at http://hpaste.org/51338#a51346
11:19:16 <geheimdienst> KirinDave: something like that
11:19:16 <KirinDave> I mena, if I have .91666
11:19:17 <bayesian> I view type systems as rythem an algorithms as inverse arrangementproblems
11:19:21 <geheimdienst> > show 0.91
11:19:21 <KirinDave> I'd like to say .92
11:19:22 <monochrom> printf is one way. there is another way in module Numeric
11:19:22 <applicative> KirinDave: when people ask that, printf is always suggested
11:19:22 <lambdabot>   "0.91"
11:19:34 <roconnor> @hoogle showF
11:19:35 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
11:19:35 <lambdabot> Data.Fixed showFixed :: HasResolution a => Bool -> Fixed a -> String
11:19:35 <lambdabot> Numeric showFloat :: RealFloat a => a -> ShowS
11:19:48 <roconnor> KirinDave: showFFloat maybe?
11:19:53 <bayesian> timber pitch and tone allocate different date structueres
11:19:57 <roconnor> showFloat?
11:20:01 <roconnor> @hoogle showGFloat
11:20:01 <lambdabot> Numeric showGFloat :: RealFloat a => Maybe Int -> a -> ShowS
11:20:05 <roconnor> showGFloat?
11:20:09 <roconnor> I forget what these all do
11:20:12 <benmachine> bayesian: both BF and DF are inadequate, long live diagonal searches
11:20:17 <int-e> > printf "%2.2f" 0.9166 :: String
11:20:18 <lambdabot>   "0.92"
11:20:23 <roconnor> benmachine++
11:20:39 <KirinDave> Is it really in base?
11:20:40 <mah_b> bayesian: seen http://www.amazon.de/Haskell-School-Expression-Functional-Programming/dp/0521644089?
11:20:45 <KirinDave> Not in scope on my ghci
11:20:50 <int-e> (printf is not very nice, but perhaps easiest)
11:20:56 <roconnor> KirinDave: it is in the Numeric module
11:21:09 <dafis> > showFFloat (Just 3) (pi*1e20) ""
11:21:10 <lambdabot>   "314159265358979330000.000"
11:21:19 <dafis> > showGFloat (Just 3) (pi*1e20) ""
11:21:20 <lambdabot>   "3.142e20"
11:21:26 <hpaste> whald pasted “vector shuffle” at http://hpaste.org/51347
11:21:28 <dafis> > showEFloat (Just 3) (pi*1e20) ""
11:21:29 <lambdabot>   "3.142e20"
11:21:34 <bayesian> true hasdkell programming is more beafitul than the best mozart smphony
11:21:40 <dafis> > showGFloat (Just 3) (pi) ""
11:21:41 <lambdabot>   "3.142"
11:21:43 <roconnor> dafis: showFloat?
11:21:54 <KirinDave> Ahh that's perfect!
11:22:00 <dafis> roconnor: is showFloat, basically
11:22:09 <dafis> showGFloat*
11:22:18 <dafis> > showFloat (Just 3) (pi*1e20) ""
11:22:19 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
11:22:19 <lambdabot>         against inferr...
11:22:29 <dafis> > showFloat (pi*1e20) ""
11:22:29 <whald> is there some clever way to shuffle the elements of an vector? I have this: http://hpaste.org/51347 -- but it's obviously broken because it generates duplicates in the resulting vector
11:22:30 <lambdabot>   "3.1415926535897933e20"
11:22:58 <dafis> > showEFloat Nothing (pi*1e20) ""
11:22:59 <lambdabot>   "3.1415926535897933e20"
11:23:30 <dafis> > showGFloat Nothing (pi*1e20) ""
11:23:31 <lambdabot>   "3.1415926535897933e20"
11:25:27 <benmachine> whald: make the generate-permutation-vector code into a separate function, and test it separately?
11:28:42 <JoeyA> Cool, MissingH apparently went BSD3, as of last week.
11:29:05 <JoeyA> (it was GPL)
11:29:08 <roconnor> people still use MissingH?
11:29:32 <roconnor> I figured Hackage obliviated the need for MissingH
11:30:00 <kmc> i've never felt like searching inside MissingH even if searching hackage fails
11:30:07 <JoeyA> Is there a fairly standard monad that builds a list or Vector of items?
11:30:10 <osfameron> how do you do (-1) as a section again?
11:30:12 <bayesian> OBLIVIATE!
11:30:16 <JoeyA> subtract 1
11:30:22 <roconnor> JoeyA: the list monad?
11:30:22 <kmc> JoeyA, writer monad.  but, why do you need a monad at all?
11:30:34 <roconnor> @type (-1)
11:30:34 <lambdabot> forall a. (Num a) => a
11:30:36 <roconnor> @type (- 1)
11:30:36 <lambdabot> forall a. (Num a) => a
11:30:39 <roconnor> @type (subtract 1)
11:30:40 <lambdabot> forall t. (Num t) => t -> t
11:30:42 <osfameron> JoeyA: ta
11:30:43 <kmc> also using writer with lists is prone to quadratic slowdown with left-associated (++)
11:30:52 <kmc> use dlist or Data.Sequence or something
11:31:07 <roconnor> kmc: Writer (Endo [a]) is fine
11:31:10 <monochrom> what are going to be in the items?
11:31:11 <JoeyA> kmc: It has to do with my application's structure.  A particular class I'm implementing will take a monad argument
11:31:42 <kmc> i think there's a lot of code of the form «do x; y; z» which could be rewritten as «mconcat [x, y, z]»
11:31:42 <roconnor> kmc: Connor and I had some designs on runWriterLeft and runWriterRight that would automatically associate the monoid operator for you
11:31:50 <kmc> e.g. the PutM monad from 'binary'
11:31:51 <JoeyA> (rather than being redundant and building a list as well.  It's redundant because it's two monoids when we only need one)
11:31:53 <monochrom> (return xs) is a fine monad argument. then you can use whatever method to create xs
11:31:58 <kmc> roconnor, cool
11:33:07 <JoeyA> kmc: Not if the "run" function reverses the list at the end.
11:33:26 * JoeyA looks at dlist and Data.Sequence, and doesn't understand Writer (Endo [a])
11:33:46 <kmc> Endo [a] = [a] -> [a]
11:33:50 <kmc> modulo newtype wrapping
11:33:54 <kmc> dlist is the same trick
11:33:58 <roconnor> JoeyA: you can look at dlist which is just an implementaion of (Endo [a])
11:34:00 <kmc> ShowS is the same trick
11:34:21 <kmc> instead of concatenating lists, you use (.) (i.e. function composition) on values of type (a -> a)
11:34:35 <kmc> building up an implicit tree of "stuff to concatenate"
11:34:39 <JoeyA> Is it just as efficient?
11:34:48 <kmc> it's more efficient, that's the whole point
11:34:52 <bayesian> WHATS A GOOD CHANNEL TO TALK ABOUT NOTING IN
11:34:53 <JoeyA> cool
11:34:58 <hpaste> tgeeky pasted “what should I do here? I don't care about safe” at http://hpaste.org/51348
11:35:09 <monochrom> #haskell-blah is a good channel to talk about nothing in
11:35:12 <kmc> it avoids the problem where «(x ++ y) ++ z» effectively traverses x twice
11:35:25 * tgeeky choughs ^^
11:35:32 <kmc> and in general n left-associated ++'s use O(n^2) time
11:35:34 <monochrom> there is also /dev/null but I doubt you'll accept it as an IRC channel :)
11:35:58 <kmc> JoeyA, once you have the final ([a] -> [a]) then you convert it to a list with ($ []), which walks that tree once only
11:36:11 <kmc> anyway dlist implements this trick and provides a more standard list-like API
11:36:44 <dafis> tgeeky: ghc-pkg trust base
11:37:15 <tgeeky> dafis++
11:37:46 <applicative> ++dafis
11:37:58 <dafis> @karma dafis
11:37:58 <lambdabot> You have a karma of 4
11:37:59 <tgeeky> it lines up. nice.
11:38:15 <Cale> I don't know why exactly, but I usually find it convenient enough just to use functions directly rather than DList or some other newtype.
11:38:30 <kmc> i prefer Data.Sequence to either
11:38:36 <kmc> i haven't rigorously profiled the difference
11:38:40 <kmc> but you get a lot more stuff
11:38:48 <kmc> you can't inspect a dlist at all...
11:38:50 <Cale> Well, Data.Sequence is better if you're cutting things apart
11:39:03 <whald> benmachine: I'm a bit stuck with my vector shuffle problem. the "generate permutation vector" algorithm should generate an permutation of [1..n], which will be used to permutate the original vector. this is pretty pointless. if there was a "swap" for vector lements, I'd simply do a fisher-yates shuffle. I don't see how to use backpermute for this. :-/
11:39:07 <Cale> or inspecting them before finished, sure
11:39:34 <Cale> But I'd expect functions to be a good deal faster for lots of just plain concatenation.
11:39:44 <bayesian> #vegan are  abunch of stuck up ****s
11:40:28 <kmc> bayesian, this is not the place
11:41:04 <geheimdienst> what's an elegant, idiomatic way of saying "use this string, but if it's empty, use this other default string"?
11:41:15 <geheimdienst> ... except for the obvious "if null then else"
11:41:25 <tac-tics> geheimdienst: case statement
11:41:32 <monochrom> case x of [] -> "whee"; _ -> x
11:41:46 <monochrom> but I like: case x of [] -> "whee"; x -> x
11:41:48 <tac-tics> let useThis = case origString of "" -> defaultString; otherwise -> origString
11:42:20 <geheimdienst> mmh, okay. hadn't thought of case ...
11:42:26 <geheimdienst> monochrom: rebinding x, eh?
11:42:32 <monochrom> yes!
11:42:57 * monochrom likes this kind of linear type shadowing
11:43:31 <kmc> bayesian, didn't you already get kicked for being a troll? under the nick turtlesalltheway?
11:45:48 <geheimdienst> cause i ended up with a function «fromEmpty s = if null s then Nothing else Just s». then i did «fromMaybe defaultstring (fromEmpty otherstring)». i think i still like this a little better than case-of
11:45:50 <int80_h> kmc, are feeding the troll?
11:45:57 <geheimdienst> although i'm not too happy about the name fromEmpty
11:46:07 * applicative notes that if so, then in any case bayesian has an excellent bag of nicks
11:46:14 <int80_h> are you!...grr one day I will be able to assemble a complete sentence consistently.
11:46:25 <kmc> bayesian, and you been adding noise here with zero content since the 10th
11:47:21 <monochrom> going through an intermediate Maybe may be less efficient
11:47:56 <shachaf> geheimdienst: Clearly you want a one-level catamorphism of a list.
11:48:58 <dafis> > let orDefault str def = fromJust $ fmap (const str) (listToMaybe str) `mplus` return def in "foo" `orDefault` "bar"
11:48:59 <lambdabot>   "foo"
11:49:00 <shachaf> @ty let f z _ [] = z; f _ cons (x:xs) = cons x xs in f
11:49:01 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
11:49:04 <dafis> > let orDefault str def = fromJust $ fmap (const str) (listToMaybe str) `mplus` return def in "" `orDefault` "bar"
11:49:05 <lambdabot>   "bar"
11:49:09 <kmc> int80_h, feeding the troll would be engaging in a serious argument about veganism or whatever
11:49:26 * dafis prefers martianism
11:49:39 <kmc> int80_h, whereas calling out trolls as trolls and linking them to past behavior which merited a kick/ban is the first step towards another kick/ban
11:49:46 <int80_h> ahhh
11:49:47 <tac-tics> kmc: More relavent to this channel, argueAbout "vegan" is a bottom-valued term
11:51:59 <Olathe> How do I display a Double without an exponent?
11:52:15 <Olathe> Like 0.01 instead of 1.0e-2
11:52:21 <monochrom> printf or Numeric.showFFloat
11:52:34 <Olathe> @hoogle showFFloat
11:52:35 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
11:52:36 <dafis> > showFFloat (Just 4) 0.02 ""
11:52:38 <lambdabot>   "0.0200"
11:52:41 <Olathe> Thanks :)
11:52:57 <monochrom> > showFFloat (Just 8) 0.0000001 ""
11:52:58 <lambdabot>   "0.00000010"
11:53:13 <bayesian> stop abusing me kmc
11:53:15 <monochrom> > show 0.00000001
11:53:16 <lambdabot>   "1.0e-8"
11:53:44 <monochrom> kmc is not abusing bayesian. for the record.
11:53:50 <joe6> how do i get the vim syntax file for .hsc files?
11:54:07 <geheimdienst> monochrom: i used Maybe because earlier, i had a function that took two strings. i then decided against it because when calling you could mix up the argument order, which means you'd have a bug that might not show for a long time. therefore the fromEmpty thing to mark up the value that might be empty
11:54:25 <geheimdienst> shachaf: i'm sure i don't want that :) kids these days
11:54:40 <geheimdienst> dafis: i kinda like it, but the implementation is less than clear to me
11:55:30 <monochrom> newtype Default a = Default a
11:56:25 <monochrom> what'did'I'do (Default d) [] = d; what'did'I'do _ v = v  may be a type-safe alternative
11:56:51 <obiwahn> let fact=fix (\g -> \x -> x <= 0 then 1 else g (x-1)*x) in fact 3
11:57:02 <obiwahn> > let fact=fix (\g -> \x -> x <= 0 then 1 else g (x-1)*x) in fact 3
11:57:03 <lambdabot>   <no location info>: parse error on input `then'
11:57:14 <dafis> geheimdienst: orDefault "" def = def; orDefault str _ = str, but that's far too clear, isn't it?
11:57:16 <monochrom> (at call sites: what'did'I'do "hello" (Default "bank is broke")  will be a catchable mistake)
11:57:32 <bayesian> why are you haskell people so unfrindly
11:57:37 <bayesian> its worse than lisp in here
11:57:48 <koeien> @ops
11:57:48 <lambdabot> Maybe you meant: docs oeis pl
11:57:55 <obiwahn> > let fact=fix (\g -> \x -> if x <= 0 then 1 else g (x-1)*x) in fact 3
11:57:56 <lambdabot>   6
11:58:08 <monochrom> bayesian, a lot of your chats are better of in #haskell-blah, and I already said that.
11:58:21 <monochrom> s/of/off/
11:58:36 <kmc> bayesian: for the record, i'm not an op, but monochrom is
11:58:38 <obiwahn> @src fix
11:58:38 <lambdabot> fix f = let x = f x in x
11:58:48 <geheimdienst> monochrom: good idea with the newtype. that gives the same result as my solution :) "something defaultstring (marker maybeemptystring)"
11:59:39 <obiwahn> in my lecture let is constructed with the help of fix but here it seems to be the other way round?!
12:00:01 <bayesian> both are wrong
12:00:05 <geheimdienst> dafis: you're right, your earlier solution is both longer and more difficult. let's go with that :)
12:00:11 <monochrom> I have lately used newtypes to do many fun things. including {-# RankNTypes #-} then newtype X = X (forall t. t -> t -> t) to smuggle impredicativity into haskell
12:00:46 <keep_learning> hello all
12:01:00 <int80_h> monochrom: have a link link about impredicativity?
12:01:07 <int80_h> erm
12:01:21 <int80_h> keep_learning: hiya
12:01:24 <keep_learning> is there any haskell library for accessing web content of any url using public proxy server
12:01:55 <int80_h> keep_learning: I htink Network.Curl would work.
12:01:59 <geheimdienst> keep_learning: you might try curl
12:01:59 <geheimdienst> http://hackage.haskell.org/package/curl
12:02:04 <augur> anyone know how to do hasse diagrams in latex?
12:02:21 <keep_learning> let say i want to access google.com but rather then going directly to
12:02:37 <keep_learning> first i go to http://internetopenproxy.tk and then
12:02:45 <keep_learning> go to google.com
12:02:50 <monochrom> int80_h: http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#impredicative-polymorphism may be good enough
12:02:59 <koeien> augur: xy-something. there is alibrary for commutative diagrams
12:03:00 <keep_learning> which eventually redirects to me google.de
12:03:16 <koeien> xymatrix i think
12:03:27 <augur> ill check it out
12:04:24 <mah_b> keep_learning: use network.http and analyze the network traffic with wireshark.
12:04:41 <erus`> uh oh
12:04:50 <erus`> see you on the other side of the netsplit
12:05:25 <applicative> monochrom, I thought {-#LANGUAGE ImpredicativeTypes#-} had been turned off
12:06:11 <monochrom> that's kind of right. it is still allowed, but what it does varies
12:06:34 <applicative> hm, but your trick makes more possible?
12:06:58 <monochrom> consider "Maybe X" :)
12:07:25 <monochrom> which has an example value "Just (X id)"
12:10:16 <monochrom> preflex: seen chrisdone
12:10:16 <preflex>  chrisdone was last seen on #haskell 7 days, 13 hours, 53 minutes and 46 seconds ago, saying: @tell edwark i think your " Ambiguous infix expression." comes from hscolour
12:11:50 <obiwahn> >let fix2 f=fix2 f in let fact=fix2 (\g -> \x -> if x <= 0 then 1 else g (x-1)*x) in fact 3
12:12:07 <obiwahn> >let fix2 f= f fix2 f in let fact=fix2 (\g -> \x -> if x <= 0 then 1 else g (x-1)*x) in fact 3
12:12:18 <monochrom> you need one more space
12:12:27 <obiwahn> >let fix2 f= f (fix2 f) in let fact=fix2 (\g -> \x -> if x <= 0 then 1 else g (x-1)*x) in fact 3
12:12:31 <applicative> wow, this is like an electrical storm or something
12:12:33 <obiwahn> > let fix2 f= f (fix2 f) in let fact=fix2 (\g -> \x -> if x <= 0 then 1 else g (x-1)*x) in fact 3
12:12:34 <lambdabot>   6
12:12:50 <int80_h> sunspots
12:12:54 <monochrom> you now get the hang of fix
12:13:09 <applicative> sunspots is more like it
12:13:54 <int80_h> could it be sunspots and aliens? That's more interesting.
12:15:22 <bayesian> aliens invented haskell
12:16:20 <saati> haskell was reverse engineered from the systems of the roswell ufo
12:16:27 --- mode: ChanServ set +o mauke
12:16:28 --- kick: bayesian was kicked by mauke (no)
12:16:45 <kmc> thanks
12:16:57 <geheimdienst> haskell was reverse-engineered from SPJ's brain
12:16:59 <bayesian> mauke you can censor me but you cant censor the truth
12:17:03 <Cale> Simon Peyton Jones is a grey alien wearing a human suit.
12:17:17 <mauke> bayesian: yes, but I can kick you
12:17:18 --- mode: mauke set -o mauke
12:17:30 <kmc> Cale, no, he's one of those shape-shifting alien bounty hunters
12:17:35 <Cale> and that human suit is wearing a garish red sweater
12:17:39 <mauke> bayesian: please stop being noise
12:18:21 <geheimdienst> he requires new host bodies roughly every 7 years. luckily MSR provides that
12:18:35 <c_wraith> Cale, are you sure you didn't mean "otherworldy"?
12:23:12 <jacobian> :pl (\ (a,l) -> map (*a) l)
12:25:37 <byorgey> jacobian: uncurry (map . (*))
12:25:49 <geheimdienst> http://www.haskell.org/haskellwiki/Questions_and_answers <- this is different from the thing kmc is working on, right?
12:28:16 <kmc> geheimdienst, yep, that's different -- perhaps the two should be merged or cross-linked
12:28:48 <geheimdienst> yeah
12:28:50 <Ptival> hey #haskell, do you know of any 20-lines non-deterministic parsing example using the list monad?
12:29:07 <monochrom> must it be 20 lines?
12:29:36 <Ptival> monochrom: fit in a slide would be cool, maybe two if you want to separate data types and algorithm
12:30:02 <jacobian> :pl zipWith (\ a l -> map (*a) l) v m
12:31:28 <monochrom> I parse "123" non-deterministically into two strings. a choice is ("1", "23"). another choice is ("12", "3"). there are two other choices.
12:32:12 <byorgey> jacobian: use @pl, not :pl
12:32:39 <monochrom> hmm, I have to go. find someone else.
12:33:07 <byorgey> jacobian: \a l -> map (*a) l === map . (*)
12:35:47 <Ptival> monochrom: yeah sure, this should already be convincing enough for the purpose, I'll write something
12:38:54 <TheLemonMan> does \\ modifies the list in place ?
12:39:00 <koeien> no
12:39:04 <koeien> that is not possible
12:39:10 <kmc> you can't modify values in place
12:39:12 <Eduard_Munteanu> :t (\\)
12:39:13 <TheLemonMan> immutable lists ?
12:39:13 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
12:39:13 <kmc> by definition, in any language
12:39:21 <kmc> if something can be modified it's not a value
12:39:26 <koeien> haskell functions are "pure", they never change their arguments.
12:39:39 <koeien> their arguments are not "variables", they are "values"
12:40:16 <kmc> in Haskell a variable is a name for a value.  in most languages it's a name for a mutable cell which can hold different values from time to time
12:40:41 <TheLemonMan> mmh, got it
12:41:26 <Eduard_Munteanu> That doesn't say much about in-place behavior.
12:41:27 <tac-tics> TheLemonMan: Haskell doesn't "do" mutation.
12:41:28 <Cale> > "abracadabra" \\ "darcs"
12:41:29 <lambdabot>   "baaabra"
12:42:14 <byorgey> > "aaaaaaaaa" \\ "a"
12:42:14 <lambdabot>   "aaaaaaaa"
12:42:18 <Cale> > "abracadabra" \\ "aaaaa"
12:42:18 <lambdabot>   "brcdbr"
12:42:25 <Cale> > "abracadabra" \\ "aaaa"
12:42:26 <lambdabot>   "brcdbra"
12:42:30 <Eduard_Munteanu> In Haskell, when you "modify" a value by, e.g. pattern-matching, it gets recreated. The new instance is passed around, while GC collects the old one (as long as no references are left)
12:42:45 <koeien> (this is not as inefficient as it sounds, though.)
12:42:55 <kmc> TheLemonMan, there are things in Haskell which can be modified in-place, but they are not values
12:42:59 <Eduard_Munteanu> So there's some amount of copying involved.
12:43:20 <Cale> Mostly when you "copy" some structure, you're just copying a single pointer in memory anyway
12:43:32 <TheLemonMan> so, i guess `list = list \\ anotherlist` is the right way
12:43:39 <kmc> no, that's a recursive equation
12:43:42 <koeien> that does not what you expect at all !
12:43:43 <kmc> it will loop forever
12:43:46 <kmc> what are you actually trying to do?
12:43:54 <koeien> > let x = x + 1 in x
12:43:55 * Eduard_Munteanu wishes GHC tried (harder?) to use in-place mutation in at least some cases.
12:43:59 <lambdabot>   mueval-core: Time limit exceeded
12:44:11 <tac-tics> You could say "let newList = list \\ anotherList"
12:44:37 <TheLemonMan> i'm confused. why isn't that valid ?
12:44:43 <koeien> it's valid.
12:44:46 <kmc> yeah, if you're only using immutable data half the time, you have to deep-copy things on nondestructive updates.  but if it's all immutable, then you can just copy the pointer
12:44:48 <shachaf> It's a recursive definition.
12:44:50 <koeien> it's just not what you expect.
12:44:53 <kmc> TheLemonMan, "let" isn't assignment
12:45:00 <koeien> let binds names to values
12:45:00 <kmc> > let xs = 1 : xs in xs
12:45:01 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:45:04 <Eduard_Munteanu> TheLemonMan: think of it like an equation, rather than plain imperative assignment.
12:45:36 <Eduard_Munteanu> so xs = 1 : xs = 1 : (1 : xs) ...
12:45:43 <kmc> TheLemonMan, again, what are you trying to do?
12:47:25 <TheLemonMan> understand a bit how lists are working
12:47:37 <kmc> okay
12:47:40 <Olathe> @pl flip forM_
12:47:41 <lambdabot> flip forM_
12:47:48 <TheLemonMan> ive read of the \\ operator and was curious if haskell treated lists like python strings
12:47:53 <Olathe> @hoogle forM_
12:47:53 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
12:47:53 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
12:47:55 <Eduard_Munteanu> That definition is more like    xs() { return 1 : xs() }   in imperative languages.
12:48:08 <koeien> python strings are immutable as well
12:48:08 <Olathe> @hoogle (a -> m b) -> [a] -> m ()
12:48:09 <kmc> a list is either empty, or it's a pair of an element and a list
12:48:09 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
12:48:09 <mauke> Eduard_Munteanu: no
12:48:09 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
12:48:09 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
12:48:18 <kmc> TheLemonMan, data List a = Nil | Cons a (List a)
12:48:25 <kmc> aside from special syntax, that's how Haskell lists work
12:48:35 <Eduard_Munteanu> mauke: well, of course not, just giving some intuition.
12:48:47 <mauke> Eduard_Munteanu: not just no, but hell no
12:48:47 <kmc> they're algebraic data values like any other
12:49:06 <kmc> TheLemonMan, analogies from Haskell to Python (or any other language) will break down at some confusing point
12:49:11 <kmc> i advise against learning Haskell by analogy
12:49:23 <mauke> Eduard_Munteanu: your code doesn't use any imperative features, and it's an infinite loop in a strict language
12:49:26 <koeien> kmc: agreed.
12:50:02 <mauke> the equivalent of xs = 1 : xs in, say, C would be struct node xs = { 1, &xs };
12:50:36 <kmc> it depends on whether you focus on the denotational semantics specified in the Haskell report, or the operational semantics implemented by every practical Haskell compiler
12:51:04 <Eduard_Munteanu> I just meant to replace the "assignment" by something a bit more familiar. Of course it's wrong in strict languages.
12:51:06 <luite> mauke: that doesn't really capture the ADT-ness of the list constructors
12:51:12 <Eduard_Munteanu> But yeah, maybe analogies suck.
12:51:19 <shachaf> Why is there no one-page version of the report?
12:51:26 <shachaf> Searching it is so annoying.
12:51:34 <Eduard_Munteanu> shachaf: a cheatsheet of sorts?
12:51:48 <mauke> s/page/file/
12:51:49 <Eduard_Munteanu> Ah, no, I misread.
12:52:06 <shachaf> mauke: "web page"
12:52:47 <mauke> shachaf: there's a pdf version
12:53:15 * shachaf would prefer something he could search in his browser.
12:53:47 <Eduard_Munteanu> Maybe there's some Google trick to help with that :/
12:53:57 <mauke> get a browser with pdf support :-)
12:54:18 <shachaf> "Haskell 98 Language and Libraries: The Revised Report"
12:54:25 <nus> @google site::http://www.haskell.org/onlinereport/ comma
12:54:27 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch12.html
12:54:27 <lambdabot> Title: 12 Compiler Pragmas
12:54:30 <shachaf> I thought only Scheme was allowed to call things "revised reports"
12:54:49 <shachaf> nus: ...No, that's not really sufficient.
12:55:58 <TheLemonMan> what's the main difference between = and <- ?
12:56:08 <nus> hmm,  http://cvs.haskell.org/cgi-bin/cvsweb.cgi/haskell-report/report gives 404
12:56:12 <TheLemonMan> if i understood it correctly the latter binds a value to a name
12:56:22 <koeien> = binds names to values. it defines. <- is used in do-notation.
12:56:39 <koeien> for example, do { x <- getLine; putStrLn x }
12:56:53 <koeien> <- extracts values from computations
12:57:00 <koeien> you can also find it in list comprehesions
12:57:09 <kmc> TheLemonMan, do { x <- a; b }  is sugar for  a >>= (\x -> b)
12:57:14 <kmc> and (>>=) is an ordinary infix operator
12:57:16 <Eduard_Munteanu> @undo do {x <- f a; g x}
12:57:16 <lambdabot> f a >>= \ x -> g x
12:57:22 <kmc> it's overloaded using a typeclass, the way (+) is overloaded
12:57:43 <kmc> TheLemonMan, so while you can construct sketchy analogies about "what <- does", the real answer is "whatever (>>=) does for that particular type"
12:57:58 <Eduard_Munteanu> You can also use let ... = ... in do-notation, and it's just like everywhere else, but it's not a replacement for '<-'
12:58:33 <Ptival> wow, explaining monads to someone who just learned let bindings!
12:58:43 <kmc> shhh i i didn't say the m-word
12:58:45 <kmc> you had to bring it up
12:58:49 <Ptival> oh shi-
12:58:52 <Eduard_Munteanu> We just said "do-notation" :)
12:58:56 <Nimatek> But monads are just endofunctors!
12:58:59 <antgeth> can help for the extremely haskelly-challenged be found here?
12:59:04 <kmc> yes antgeth
12:59:05 <mauke> antgeth: yes
12:59:05 <Olathe> Monads are like things you don't tell children about.
12:59:11 <Eduard_Munteanu> Not just, but close... :)
12:59:16 <koeien> antgeth: sure, feel free to ask your questions :)
13:00:08 <Nimatek> They are also like helicopter-priests.
13:00:12 <antgeth> ok, neat
13:00:12 <Nimatek> A monad in action: http://ompldr.org/vYWN0eg
13:00:18 <antgeth> i can't stick around right now
13:00:21 <koeien> TheLemonMan: which resource are you using to learn haskell by the way?
13:00:28 <antgeth> but i will return later with some questions later
13:00:29 <koeien> TheLemonMan: Learn You a Haskell has a good reputation around here
13:00:32 <Ptival> damn, now he's off googling the m-word and preparing hellot of questions! my bad :D
13:00:33 <koeien> @where lyah
13:00:33 <lambdabot> http://www.learnyouahaskell.com/
13:00:36 <antgeth> i'm just starting to learn it right now
13:00:45 <TheLemonMan> yep, im using that
13:02:36 <Eduard_Munteanu> Nimatek: heh, orthodox heli-priest? :)
13:02:53 <Nimatek> Eduard_Munteanu: Yes, a metaphor for monads.
13:04:05 <Ptival> they seem to be dependent on your location though, as byorgey acknowledged they were crêpes in France
13:04:39 <Ptival> I guess they adapt to the predominant religion in your area and stuff like that
13:04:46 <Ptival> you know how they try to preserve the context :)
13:05:36 <Olathe> :r
13:06:22 <Ptival> Olathe: don't you dare judge the monad laws!
13:06:35 <jacobian> @pl \ f -> foldr ((:).f) []
13:06:35 <lambdabot> flip foldr [] . ((:) .)
13:07:42 <Olathe> I was trying to reload this channel from source.
13:08:04 <shachaf> :г
13:08:17 <shachaf> :Г
13:08:44 <Ptival> I thought it was a smiley of disapproval
13:09:02 <Olathe> <interactive>: out of memory
13:09:04 <Olathe> :(
13:12:56 <hpaste> tgeeky pasted “getting past error: #error Unknown GHC version for haddock” at http://hpaste.org/51349
13:13:08 * tgeeky coughs again. :/ ^^
13:14:15 <benmachine> tgeeky: so, ghc version?
13:14:20 <tgeeky> 7.2.1
13:18:31 <tgeeky> i can't find anything that would prevent 7.2.1
13:18:36 <tgeeky> a lot of GHC_VER_MIN..
13:19:10 <TubeSteak> hi
13:19:24 <TubeSteak> I have a question about Control.Monad.Exception.Asynchronous
13:19:36 <TubeSteak> I'm not sure how it's supposed to be used
13:19:47 <benmachine> TubeSteak: what package does it come from?
13:19:55 <TubeSteak> spreadsheet
13:20:02 <TubeSteak> oops
13:20:03 <TubeSteak> sorry
13:20:16 <TubeSteak> explicit-exception
13:20:21 <benmachine> right
13:20:34 <TubeSteak> I'm using actually the spreadsheet package
13:20:52 <TubeSteak> and it parsing function (fromString) return Exceptional String [[String]]
13:21:12 <TubeSteak> and it's supposed to parse the string lazily
13:21:51 <TubeSteak> if I just do a "mapM_ print $ result r" (where r is the result of the parsing) everything is fine and top memory usage is 2MB
13:22:22 <TubeSteak> if in addition to that i do "print $ exception r", the lazily generated [[String]] is never gc'ed
13:23:00 <TubeSteak> I guess it's because if I reference r again later, there will be a reference to the Exceptional value and that in turns keep a reference to the result
13:23:10 <TubeSteak> so the result is not eligible for gc
13:24:08 <TubeSteak> which in my opinion defeats the purpose of exceptions for lazily computed results
13:24:08 <joe6> which is better for haskell editing? vim or emacs?
13:24:14 <Olathe> Is there a way to figure out when my program is not lazily generating and immediately throwing away list entries as it traverses the list?
13:24:21 <benmachine> TubeSteak: that sounds like a reasonable explanation, and I'm not sure if I can help, don't know much about GC
13:24:30 * Eduard_Munteanu announces a new edition of editor wars :)
13:24:32 <benmachine> TubeSteak: however, I'd try doing a case-expression on the result
13:24:43 <benmachine> joe6: both are in common usage
13:24:52 <benmachine> I use vim
13:24:54 * dsouza M-x editor-wars-mode
13:25:04 <Eduard_Munteanu> joe6: there's a haskell-mode for Emacs which seems to implement lots of stuff. OTOH, Vim probably doesn't do as much.
13:25:06 <TubeSteak> benmachine: that wouldn't work very well, as I understand the errors will be produce as the string is parsed
13:25:14 <TubeSteak> that's why the error is actually a Maybe
13:25:25 <Eduard_Munteanu> I use Vim, though.
13:25:35 <joe6> any screenshots for emacs and haskell?
13:25:52 <benmachine> TubeSteak: try, case fromString str of Exceptional e a -> print a >> print e
13:25:55 <Olathe> Is there a reason why minimumBy would be strict?
13:26:03 <Eduard_Munteanu> BTW does the Emacs thingy implement something like holes, akin to Agda stuff?
13:26:05 <dsouza> joe6: I like using emacs. the haskell-mode has ghci as a inferior process which is very handy
13:26:11 <benmachine> TubeSteak: that won't force e until necessary, so it should still be processed lazily
13:26:21 <TubeSteak> let me try that
13:26:27 <benmachine> TubeSteak: and since you don't give the result a name, I'm hoping e and a will be GCed separately
13:26:31 <Olathe> My program has a huge space leak when I use minimumBy.
13:26:49 <benmachine> Olathe: strict in what sense?
13:26:50 <joe6> dsouza, ok, thanks.
13:27:16 <Olathe> benmachine: Not able to lazily go through the list, throwing out all but the minimum entry as it goes.
13:27:19 <Eduard_Munteanu> @src minimumBy
13:27:20 <lambdabot> Source not found. Take a stress pill and think things over.
13:27:20 <monochrom> minimumBy is strict if the comparator is strict in both arguments, which is 99.9% of the time
13:27:26 <Olathe> benmachine: Instead, it runs out of memory.
13:27:36 <Olathe> Ahh.
13:27:42 <benmachine> Olathe: ah. that's not really strictness
13:27:49 <Olathe> Oh, what is it?
13:27:53 <benmachine> hmm
13:28:01 <monochrom> information-theoretically, until you see the end of the list, you can't be sure who is a minimum
13:28:08 <byorgey> joe6: for emacs there is also ghc-mod which is nice, it compiles your code in the background on the fly and highlights code with errors and warnings
13:28:11 <benmachine> it's sort-of strictness
13:28:19 <Olathe> Yeah, but you can keep the current minimum and drop the rest.
13:28:28 * Eduard_Munteanu figures that'd be   minimumBy f = head . sortBy f
13:28:34 <benmachine> Olathe: are you keeping a reference to the front of the list?
13:28:53 <joe6> i am a vim guy and i am eye'ing the emacs world with envy. but, it is such a big switch to change the editor.
13:28:59 <benmachine> Eduard_Munteanu: that's an implementation that would work, as long as sortBy was sufficiently clever (which I think it is)
13:29:06 <monochrom> minimumBy drops the seen prefix of the list, yes
13:29:30 <Olathe> benmachine: Nope, I put minimumBy (...) . f a b c whatsit
13:29:39 <Olathe> benmachine: Nope, I put minimumBy (...) $ f a b c whatsit
13:29:52 <benmachine> Olathe: ah, hmm
13:29:55 <byorgey> joe6: in my opinion vim seems much more logical/elegant, but emacs has better tools.
13:30:13 <koeien> byorgey: but the scripting language...
13:30:15 <monochrom> I would love to see a simplified counterexample
13:30:34 <Olathe> monochrom: Let me try.
13:30:34 <byorgey> koeien: good point.  And that's probably why emacs has better tools.
13:30:40 <byorgey> s/probably//
13:30:47 <tac-tics> joe6: You can also eat your own dogfood </yi>
13:31:00 <tac-tics> Although I don't think anyone maintains yi any more
13:31:27 <byorgey> tac-tics: no? that's too bad
13:31:28 <monochrom> 99.9% of the time, until you have a simplified counterexample (controlled experiment), you don't know what to blame
13:31:33 <TubeSteak> benmachine: same thing :(
13:32:24 <tac-tics> byorgey: or at least it's really sporatic. Last update to the google code db was actually only back in May
13:32:48 <monochrom> vim is not logical to me. vi may be logical.
13:32:55 <dsouza> byorgey: i used to think the same, but after switching over emacs for almost a 1 year now, i think differently: using lisp as it does makes emacs much more logical.
13:33:03 <benmachine> TubeSteak: hm. tricky.
13:33:25 * dsouza logical might not be the best word here
13:33:31 <benmachine> I don't think of vim as logical particularly; but it knows more about what I want to do than I do
13:33:39 <Olathe> > minimum [1..1000000] -- monochrom
13:33:41 <lambdabot>   *Exception: stack overflow
13:33:46 <franny> In my opinion, plain old vi is an elegant small editor, while emacs is an elegant big editor; vim is big and inelegant.
13:33:51 <benmachine> I discovered 'J' by accident; when I first did it I thought "why would you ever want a key that did that"
13:33:54 <benmachine> now I do it all the time
13:34:00 <Olathe> minimum does it, too.
13:34:16 <benmachine> Olathe: are you compiling with optimisations?
13:34:21 <Olathe> Hmm...
13:34:32 <benmachine> TubeSteak: are *you* compiling with optimisations?
13:34:42 <TubeSteak> yeah -O2
13:34:43 * Eduard_Munteanu thinks it's actually possible to implement such magic for Vim as well, but being a less commonly known scripting language than LISP... :/
13:34:51 <monochrom> oh, it's foldl1, that's why
13:35:01 <Olathe> Ahh, that fixed it :)
13:35:03 <Olathe> Thanks
13:35:10 <Eduard_Munteanu> joe6: mind you could try Emacs' viper mode
13:35:25 <joe6> benmachine, what does J do?
13:35:27 <Eduard_Munteanu> ... which emulates the look and feel of Vim
13:35:38 <monochrom> it throws away your list but it builds its own deep thunk
13:35:43 <koeien> last time I tried it i found it lacking somehow.
13:35:45 <benmachine> joe6: joins lines
13:36:01 <benmachine> the next line to the current line iirc
13:36:10 <joe6> oh, yes.
13:36:13 <mauke> Eduard_Munteanu: viper is a bad joke
13:36:13 <dsouza> vim supports other languanges: ruby at least, i think
13:36:15 <Eduard_Munteanu> It beats using del / backspace manually.
13:36:21 <mauke> dsouza: scheme
13:36:25 <Eduard_Munteanu> mauke: yeah, I didn't like it either :(
13:36:39 <Olathe> Is there a way to easily parallelize minimumBy?
13:36:53 <monochrom> (this is why I am skeptic about those "one-pass" solutions to those repmin, repsum problems. sure, they read your tree once. meanwhile, they build a new thunk that mirrors your tree. there are still two traversals altogether)
13:37:05 <dsouza> mauke: interesting, didn't know scheme was on the list
13:37:06 <Eduard_Munteanu> Olathe: possibly.
13:37:33 <Eduard_Munteanu> Olathe: I think you can break the input into pieces, find the minimum of each and so on
13:37:45 <benmachine> Olathe: you could easily parallelise it for some data structures, but it might be tricky for linked lists, unless your comparison was expensive
13:37:54 <TubeSteak> well, I guess I will switch to csv-enumerator
13:38:05 <Olathe> Ahh, OK
13:38:17 <monochrom> chunk the list into several chunks. minimize each. etc. some things in Control.Parallel.Strategies may help
13:38:19 <joe6> why is yi not being actively worked on?
13:38:23 <joe6> anyone tried it?
13:38:26 <joe6> was it any good?
13:38:40 <joe6> was it slow or was there something wrong with it?
13:40:57 <benmachine> I suppose the comparison would be (relatively) expensive if you were talking about complex datastructures, especially if they were largely equal
13:41:28 <benmachine> I was just thinking of, like, [Integer], where half the cost of minimum is probably traversal which is inherently sequential
13:43:18 <jacobian> @pl foldr (\ c r -> zipWith ($) (map (:) c) r) (repeat []) m
13:43:18 <lambdabot> foldr (zipWith id . map (:)) (repeat []) m
13:44:39 <edwardk> @tell dylukes identifier is part of the new Language plumbing. basically Language is a Parser transformer that adds info to parse identifiers and reserved keywords. you can avoid it if you don't want it, but it will export names that conflict with those youa re using in stgma otherwise
13:44:40 <lambdabot> Consider it noted.
13:45:39 <dylukes> edwardk: I just excluded it.
13:45:39 <lambdabot> dylukes: You have 1 new message. '/msg lambdabot @messages' to read it.
13:45:45 <edwardk> thats fine
13:46:02 <Olathe> @messages
13:46:02 <lambdabot> You don't have any new messages.
13:46:05 <Olathe> :(
13:46:11 <edwardk> if you wanted to you could avoid having to define your own parser type, and just use Language with an appropriate comment style and identifier style
13:46:38 <edwardk> its just basically ReaderT (CommentStyle, IdentifierStyle m, IdentifierStye m)
13:46:56 <edwardk> (though it doesn't take 'ask' away from you)
13:47:13 <edwardk> otoh, the approach you are using now would have a tidge less overhead
13:47:54 <edwardk> dylukes: be warned i'm about to change MonadParser a bit more, so that mark and release aren't going to be part of the base parser class
13:47:59 <edwardk> they'll be in MonadMark.
13:48:04 <edwardk> not sure if you use those or not
13:48:11 <dylukes> go ahead
13:48:16 <dylukes> 1) I dont use them
13:48:17 <dylukes> m2)
13:48:27 <dylukes> 2) I chose to use trifecta knowing its unstable/indev
13:48:33 <edwardk> fair nuff
13:48:47 <edwardk> just figured it was worth mentioning the change was in flight
13:49:15 <edwardk> also the identifier module is moving out of Token. and just up to Parser, but those kinds of cosmetic changes should be fast
13:49:20 <jacobian> is there a less messy way of doing tranpose than this: foldr (\ c r -> zipWith ($) (map (:) c) r) (repeat []) m
13:49:28 <edwardk> :t transpose
13:49:28 <lambdabot> forall a. [[a]] -> [[a]]
13:49:33 <jacobian> hah!
13:49:47 <edwardk> mind you it does more or less that internally
13:52:03 <koeien> @src transpose
13:52:03 <lambdabot> transpose []             = []
13:52:04 <lambdabot> transpose ([]   : xss)   = transpose xss
13:52:04 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
13:52:15 <edwardk> dylukes: the reason i had to refactor MonadParser is that i didn't want to make it pick up a type parameter, but to properly mark and release in the literate parser you need to track in the mark whether you were in a bird track or a \begin{code} block when the mark was taken
13:52:27 <benmachine> beware @src, it contains lies
13:52:31 <dylukes> idk what mark/release/bird trakc is
13:52:33 <edwardk> so i couldn't just use Delta
13:52:36 <dylukes> and caleskell
13:52:39 <edwardk> literate haskell
13:52:40 <dylukes> @src (.)
13:52:40 <lambdabot> (f . g) x = f (g x)
13:52:40 <lambdabot> NB: In lambdabot,  (.) = fmap
13:52:46 <dylukes> see NB
13:53:04 <edwardk> code lines start are on lines that start with >  or which are surrounded in \begin{code} … \end{code}
13:53:17 <edwardk> er code lines are on lines that start with
13:53:43 <edwardk> that way you can make the rest of your file into a latex document or what have you
13:54:58 <edwardk> the Literate parser transformer takes a simple parser and adds understanding of that comment style. you can then layer another comment style on top to get both >'s for code and --'s inside of them or {-   -}'s that can even straddle the literate comments
13:55:20 <DukeDave> Are there many people familiar with "cabal-dev buildopts" here?#
13:55:33 <DukeDave> I get: "cabal-dev: user error (cabal: No cabal file found...."
13:55:37 <edwardk> so to parse haskell you could use Language (Literate (Parser String)) as your monad and avoid the boilerplate you had to go through as an early adopter
13:55:57 * DukeDave may not understand the purpose of buildopts, but can't find docs anywhere :|
13:56:03 <dainanaki> hey all, I've been working with Vacuum a bit and was wondering if there's a way to use it such that I can see where thunks are in expressions. Does anyone know if vacuum can do this?
13:56:27 <edwardk> dainanaki: not sure, but i know copumpkin has been working on something for that
13:56:41 <edwardk> dainanaki: you can probably also get there using my tag-bits package
13:56:41 <Olathe> Doesn't Vacuum suck?
13:56:54 <c_wraith> dainanaki: vacuumLazy will tell you where thunks are.  It won't tell you about their contents.
13:56:56 <edwardk> dainanaki: which can at least tell you if a given thunk is evaluated
13:57:03 <monochrom> hahahah Olathe
13:58:53 <dainanaki> hrm, it looks like vacuumLazy is what I needed. I didn't expect that vacuum would force the whole structure.
13:59:38 <c_wraith> I'm still waiting for something like vacuumLazy that introspects the thunks, and tells me what they're holding in their closures.
13:59:39 <Ptival> @pl (\(x, y) -> (foo . read x, y))
13:59:39 <lambdabot> first ((foo .) . read)
14:00:12 <c_wraith> :t first (foo . read)
14:00:12 <lambdabot> Not in scope: `foo'
14:00:17 <c_wraith> :t first (?foo . read)
14:00:17 <lambdabot> forall a c d. (?foo::a -> c, Read a) => (String, d) -> (c, d)
14:00:31 <c_wraith> Ptival: is that what you wanted?
14:00:40 <Ptival> yes
14:00:46 <c_wraith> first is in Control.Arrow
14:01:18 <Ptival> well, I think I won't write it point-free since it's to present Haskell to newbies :)
14:01:29 <Ptival> the lambda will do
14:01:43 <c_wraith> first, if you ignore its full generality, is pretty cool, though.
14:01:58 <koeien> also (***) and (&&&)
14:01:59 <c_wraith> maybe add your own first and second combinators, just to show that it can be done, and how it makes the code
14:02:16 <c_wraith> err, how it makes the code look
14:02:25 <Ptival> @pl map (first ((foo .) . read))
14:02:25 <lambdabot> map (first ((foo .) . read))
14:02:34 <monochrom> . o O ( or how to make the code disappear :) )
14:06:30 <Ptival> :t map (first ((?foo .) . read))
14:06:31 <lambdabot> forall a b (f :: * -> *) d. (?foo::a -> b, Functor f, Read (f a)) => [(String, d)] -> [(f b, d)]
14:07:47 <Ptival> Functor?
14:08:42 <dthurn> Currently on hour 6 of building the haskell platform on my server. Building "regex-compat-0.93.1" right now, hoping this is done in alphabetical order.
14:09:27 <monochrom> actually not alphabetical order. dependency order.
14:09:48 <dthurn> yeah, just noticed. Damn, I hope I'm almost done.
14:09:48 <tgeeky> yikes
14:10:01 <monochrom> but building the haskell platform ought not take 6 hours (if you already have ghc done)
14:10:13 <Ptival> :t map (first (?foo . read))
14:10:14 <lambdabot> forall a c d. (?foo::a -> c, Read a) => [(String, d)] -> [(c, d)]
14:10:16 <dthurn> The link time is killing me
14:10:20 <Ptival> ah, that's better :)
14:10:23 <monochrom> oh, no wonder :)
14:10:42 <dthurn> Probably the lack of RAM on my Linode (I have the cheapest one)
14:10:50 * monochrom uses the "gold" linker for linux. very fast for ghc-generated code. not sure about other kinds of code
14:11:13 <dthurn> *now* you tell me
14:11:30 <monochrom> yeah, 128MB is not quite enough for the traditional linker. I tried it in a virtual machine.
14:12:25 <monochrom> well, the worst scenerio is just it declaring OOM and aborting. if it doesn't abort, there is still hope.
14:12:56 <enzuru> helllp
14:14:48 <c_wraith> enzuru: that's available here, but you'll need to provide some more info
14:15:17 <antgeth> soo, if you fine folks could help me a bit with some functions that i'm struggling with due to my ineptitude, that'd be great
14:15:35 <enzuru> c_wraith: I want to leave work early, smoke a bowl, and program in Haskell for the rest of the day. But I can't.
14:15:40 <enzuru> Is there anyone who can help me with that?
14:15:52 <antgeth> http://pastebin.com/7kVfQD0m i'm clearly doing something wrong here but i don't know what
14:15:54 <mauke> I have copied your paste 7kVfQD0m to http://hpaste.org/51350 - pray I don't copy it any further.
14:15:58 <antgeth> (perhaps several wrong things)
14:16:20 <mauke> why doesn't it return Bool?
14:16:37 <mauke> 'head [ls]' better written as 'ls'
14:16:49 <mauke> 'drop 1 [ls]' better written as '[]'
14:16:59 <c_wraith> enzuru: some people might be able to do that in your place.  May not help *you* though
14:17:18 <Cale> antgeth: You've only defined isMemberOf for lists of length 0 and 1
14:17:20 <mauke> antgeth: missing argument in call to isMemberOf
14:17:54 <antgeth> ...could you show me how to fix it?
14:18:01 <kmc> enzuru, you should quit your job, then you can smoke dope and code in Haskell all day
14:18:18 <enzuru> c_wraith: I think I need to just make a run for it. Go home, drop by a dealer, start up emacs in haskell-mode, grab the SDL library, and live a little.
14:18:31 <mauke> antgeth: lists have two cases, [] and _ : _
14:18:42 <enzuru> That's true. But then I won't have money for dope or power a computer with emacs.
14:18:51 <mauke> antgeth: your pattern matching should reflect that
14:18:51 <kmc> emacs is notoriously energy-intensive
14:19:01 <hpaste> Cale annotated “pastebin.com/7kVfQD0m” with “pastebin.com/7kVfQD0m (annotation)” at http://hpaste.org/51350#a51351
14:19:08 <mauke> antgeth: isMemberOf x [] = ...; isMemberOf x (y : ys) = ...
14:19:25 <Cale> Or:
14:19:39 <Cale> isMemberOf x ys = any (== x) ys
14:19:39 <mauke> isMemberOf = elem
14:19:50 <Cale> Or that, sure. ;)
14:19:53 <elliottt> does anyone know if it's possible to get a handle to the gmp integer that underlies a haskell integer?
14:19:56 <elliottt> (in ghc)
14:20:01 <enzuru> At least I get to code in ruby here, and not PHP.
14:20:20 <elliottt> i have a c++ library that uses gmp integers, and i'd like to use the haskell ones there :)
14:20:22 <antgeth> thank you cale
14:20:23 <kniu> :t (sequenceA .) . map
14:20:23 <lambdabot> Not in scope: `sequenceA'
14:20:29 <kniu> @hoogle sequenceA
14:20:29 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
14:20:29 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
14:20:40 <mauke> :t (fmap (0 ==) product .) . (-)
14:20:41 <lambdabot> forall a. (Num a, Num [a]) => [a] -> [a] -> Bool
14:21:09 <c_wraith> elliott: sure, but the code is very ugly.  You need access to an otherwise-hidden package, and the MagicHash extension turn on...
14:21:10 <mauke> :t (fmap (0 ==) product .) . map . (-)
14:21:11 <lambdabot> forall a. (Num a) => a -> [a] -> Bool
14:21:14 <kniu> @hoogle (Traversable t, Applicative f) => t (f a) -> (a -> f b) -> f (t b)
14:21:14 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
14:21:15 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:21:15 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
14:21:19 <c_wraith> @src Integer
14:21:19 <lambdabot> data Integer = S# Int#
14:21:20 <lambdabot>              | J# Int# ByteArray#
14:21:21 <elliottt> c_wraith: sounds like a fun time :(
14:21:34 <mauke> > ((fmap (0 ==) product .) . map . (-)) 2 [1,2,3]
14:21:35 <lambdabot>   True
14:21:38 <elliottt> c_wraith: i think the benefits outweigh code nastyness, do you have a pointer?
14:21:46 <c_wraith> The ByteArray# value in the J# argument is the gmp number
14:21:52 <c_wraith> err, J# constructor
14:21:55 <elliottt> ah ha
14:22:07 <kmc> elliottt, in GHC, sure.  just import the right module and pattern match on J#
14:22:08 <kmc> @src Integer
14:22:08 <c_wraith> if it's using the S# constructor, it's not using GMP
14:22:08 <lambdabot> data Integer = S# Int#
14:22:08 <lambdabot>              | J# Int# ByteArray#
14:22:10 <elliottt> so in the case that it's just a normal int, i have to manufacture a gmp int?
14:22:27 <kmc_> hmm, i lagged or something :/
14:22:31 <elliottt> hehe
14:22:38 <elliottt> is there an easy way to force a gmp int?
14:22:45 <elliottt> the library i'm using will always expect a gmp int.
14:22:49 <kmc> there might be a function for it in GHC.Integer.whatever
14:22:53 <c_wraith> sure.  multiply then divide by a big value.
14:22:58 <elliottt> hehe
14:22:59 <kmc> go source-diving in integer-gmp
14:23:07 <elliottt> thanks, i'll take a look :)
14:23:15 <mkscrg> newbie question about composing nested monadic functions. wrote it up in a paste: http://hpaste.org/51352 thoughts?
14:23:28 <kmc> elliottt, also, is the library you're using okay with the fact that ghc links a chopped&screwed version of GMP that uses the GHC heap allocator?
14:23:56 <elliottt> kmc: i believe so.
14:23:58 <tac-tics> mkscrg: You can't do Monad m => over several lines like that, afaik
14:24:08 <mauke> tac-tics: pseudocode
14:24:14 <edwardk> elliottt: you generally can't use ghc with any library that links against gmp itself
14:24:20 <elliottt> it'll do its own gmp allocation elsewhere, so as long as gmp works externally with ghc-heap-allocated gmp values, then it'll be fine
14:24:25 <elliottt> ah, shoot
14:24:31 <mkscrg> tac-tics: pseudocode indeed
14:24:37 <edwardk> elliottt: we hook the custom allocator
14:24:49 <Eduard_Munteanu> You probably want something like Traversable, and/or transformers.
14:24:51 <edwardk> elliottt: so if they do their own allocation of gmp ints, ghc won't see them, and it'll gc them
14:24:56 <tac-tics> mkscrg: also, return x >>= blah is the same as just x, I believe
14:25:26 <edwardk> basically the moment you come back from FFI the state of any gmp'd ints in their library is pretty well unknowable
14:25:27 <elliottt> so is the issue that the gmp ints coming back from the library will be collected by ghc, but not seen by it?
14:25:29 <benmachine> tac-tics: blah x
14:25:34 <edwardk> worse
14:25:39 <mauke> mkscrg: >>= return . is liftM
14:25:41 <tac-tics> yeah,
14:25:46 <edwardk> gmp ints allocated by the library will be moved behind the library's back without telling it
14:25:55 <elliottt> hah
14:25:58 <elliottt> that's worse :)
14:26:09 <elliottt> ok, so i shouldn't try to use ghc's gmp with another library then.
14:26:12 <mkscrg> mauke: good to know
14:26:13 <edwardk> thats why we have the S# and J# constructors for integer
14:26:34 <edwardk> we take them right out of the gmp internal structure then hold onto the limbs ourselves
14:26:40 <edwardk> now
14:26:54 <mkscrg> tac-tics: where do you see the (return x >>= f x)?
14:26:54 <edwardk> you _can_ sometimes work around this
14:27:16 <edwardk> i have a "precision" package that hooks into MPFR by using custom prim ops
14:27:30 <edwardk> but even there we run into problems because their constant-cache uses the gmp allocator
14:27:34 <tac-tics> ah there's a paren in there
14:27:37 <edwardk> and doesn't tell me about it
14:27:46 <edwardk> so i can't use their definitions for pi, etc.
14:27:55 <elliottt> fun times.
14:28:07 <elliottt> i'm looking to bind to ntl: http://www.shoup.net/ntl/
14:28:30 <elliottt> which can use gmp, but i'm not convinced that i should try to use ghc-gmp integers now.
14:28:34 <edwardk> copumpkin has some hacks he's been working on that'll let us _re_hook the allocator and make it not hook the calls to alloc and free from the cache, but its totally a hack
14:28:37 <dmoctezuma> is there a work around Control.Exception.catch to avoid clash with Prelude.catch? ghc keeps saying about ambiguity
14:28:57 <elliottt> dmoctezuma: import it qualified, or hide it in prelude
14:29:00 <dmoctezuma> hiding seems not to work
14:29:01 <edwardk> your best bet if you just want it to work is to compile linked to integer-simple
14:29:06 <edwardk> then the allocator hooks don't get made
14:29:17 <edwardk> but Integers in ghc become a lot slower since they are done in pure haskell
14:29:17 <elliottt> hmmmm
14:29:32 <elliottt> yeah, that's not so ideal.
14:29:45 <elliottt> ok.  it seems like i'm better off just binding to their bignum implementation
14:30:07 <elliottt> from what i recall, it's not easy to get something to build with integer-simple.  has that changed recently?
14:30:15 <elliottt> (rebuild ghc with it, etc.)
14:30:43 <dmoctezuma> elliottt, is it relevant if the catch function is being used inside a where block?
14:32:00 <elliottt> dmoctezuma: shouldn't be.
14:32:03 <ClaudiusMaximus> elliottt: it's not that hard, get ghc binary, get ghc source, add a couple of lines in a build config file, build ghc from source, then bootstrap cabal-install and get stuff from hackage
14:32:36 <elliottt> ClaudiusMaximus: we did that for the HaLVM, and i remember it being tough.  that might have been because of the other changes we had to make, though :)
14:33:22 <ClaudiusMaximus> $ grep simple ~/opt/src/ghc-7.0.4-src/mk/build.mk
14:33:22 <ClaudiusMaximus> INTEGER_LIBRARY=integer-simple
14:33:39 <ClaudiusMaximus> i think that's all you need
14:33:43 <elliottt> excellent
14:33:45 <elliottt> thanks :)
14:37:29 <ClaudiusMaximus> edwardk: is your precision library released?  does it work with ghc/integer-simple?
14:37:47 <edwardk> it is on github but not hackage
14:37:59 <edwardk> it works with ghc using the normal integer library actually
14:38:16 <edwardk> the thing that doesn't work is if you call pi basically the whole thing crashes
14:38:39 <edwardk> once we get that worked out i'd be happy to release it, or even to just hack a value or cache for pi and cross my fingers ;)
14:38:54 <mkscrg> ok, liftM is great. brings that ugly mess down to a pretty reasonable one liner: http://hpaste.org/51353
14:39:05 <kmc> liftM = fmap = (<$>)
14:39:10 <edwardk> it is also missing a few other classes
14:39:25 <edwardk> but mostly coz we were busy trying to figure out how to make pi not crash
14:39:51 <kmc> circles are deprecated
14:39:53 <ClaudiusMaximus> edwardk: ok.  i have some algorithms i've written in C using mpfr that i'd like to call from haskell (or rewrite in haskell with not unsane mpfr bindings)
14:39:54 <KirinDave> mkscrg: The dreaded double liftM
14:39:57 <kmc> it's all about clouds now
14:40:03 <mkscrg> K
14:40:13 <kmc> the ratio of a cloud's circumference to its diameter is not π
14:40:26 <mkscrg> KirinDave: right, so is there a better way? This is easy enough to read with these simple types, but it gets hairy fast
14:40:26 <edwardk> ClaudiusMaximus: you can check the way the hooks are implemented in precision. they are tedious but not terribly hard to do
14:40:38 <KirinDave> mkscrg: I can't read it. :)
14:40:53 <edwardk> ClaudiusMaximus: the main problem we had to work around was that we needed primops that had a lot of arguments, and parts of ghc aren't happy calling things that want more than 8 args
14:41:13 <edwardk> whereas addition of 2 mpfr floats takes 9 arguments unless you play silly games
14:41:51 <edwardk> rounding-mode and (sign, precision, exponent, limbs)*2
14:41:57 <monochrom> 9 arguments! that's a lot
14:42:17 <ClaudiusMaximus> edwardk: ok - if i have time i'll give it a try some time in the next couple of weeks, and report back
14:42:19 <edwardk> i finally hacked around the bug it was causing by mashing sign and precision together and manually unpacking them in c--
14:42:29 <monochrom> you may have to proliferate the number of primops in exchange of fewer arguments
14:42:34 <edwardk> that got us down t 7 args and below ghc's hard cap
14:42:45 <mkscrg> it's hard to read (i think) because those liftM's are acting on two different monads
14:43:04 <mkscrg> there must be a better way to deal with nested monads like this, no?
14:43:04 <edwardk> well, we have a bug filed, and they expressed willingness to change the way dispatch worked so you can have more uniformly
14:43:35 <edwardk> monochrom: putting sign and precision together got us down to few enough args that we can avoid making 6 copies of each operation at least
14:44:03 <monochrom> I'm thinking each primop fixes a rounding mode, too
14:44:08 <edwardk> the main open issue is the constant cache
14:44:15 <edwardk> yes, that was the '6 copies' i was referring to
14:44:22 <edwardk> we're down to 7 args, so we're safe
14:47:47 <dainanaki> man, it really would be nice to traverse down vacuum to see closures inside of other closures when being lazy.
14:48:18 <kmc> yeah, i thought it could do that, but it turns out it can't
14:48:25 <kmc> at least, i hit a PAP and couldn't see anything inside
14:48:43 <kmc> my code contains this string:   \"@_@\"
14:48:46 <dainanaki> PAP is partial application
14:48:49 <kmc> haddock markup or smiley face
14:48:53 <kmc> dainanaki, yeah
14:48:56 <dainanaki> you sure you didn't hit AP?
14:49:40 <kmc> pretty sure
14:50:14 <dainanaki> hrm
14:51:12 * Maxdamantus wonders if vacuum is restrictive enough to allow old bits to be GCed.
14:53:50 <dainanaki> :( I really hoped there would be a good way to visualise thunks.
14:54:15 <hpc> dainanaki: not without evaluating them, i would think?
14:57:17 <dainanaki> I was hoping something along the lines of making a tree of (isThunk, expression in string format) with its children being sub thunks in the same format.
14:58:35 <dainanaki> or if it isn't a thunk, that is, that it's fully evaluated, then it would just have the value in the node.
15:15:06 <joe6> i have a bunch of c global variables. I want to monitor the changes in those variables after  running a haskell command. I have haskell bindings to all the C variables.
15:15:19 <joe6> Just wondering if there might be a smart way of doing something like that.
15:15:35 <kmc> unmap the pages where those variables are stored
15:15:37 <kmc> catch SIGSEGV
15:15:49 <joe6> I can generate the code, but was just curious if there might be a smarter way of doing so.
15:15:57 <kmc> generate the code?
15:15:58 <dainanaki> kmc, that's disturbing.
15:16:15 <shachaf> dainanaki: The discussion from #-blah is leaking over.
15:16:53 <joe6> kmc, something like: do x <- get variable; run haskell IO function; y<- get variable; compare x and y
15:17:03 <kmc> oh
15:17:10 <joe6> but, there will be a lot of the get variable's commands
15:17:18 <joe6> one for each c global variable.
15:17:22 <kmc> so make a list or something
15:17:28 <kmc> [Ptr CInt]
15:17:52 <joe6> i have haskell types for each of the global variables.
15:18:12 <joe6> and also a get function and a set function for them, similar to data.Statevar
15:18:26 <kmc> ah, so you can make a list of get functions
15:18:33 <kmc> might need an existential wrapper or something
15:18:52 <joe6> kmc, oh, ok. will check up on existential wrapper
15:19:06 <shachaf> Existential wrapper? Why?
15:19:07 <joe6> kmc, is it similar to existential types?
15:19:12 <shachaf> Oh, never mind.
15:19:49 <kmc> yeah, by "existential wrapper" i mean to wrap the values in an algebraic data type that is defined with existential quantification
15:19:54 * shachaf wants "exists".
15:20:00 <kmc> UHC has it
15:20:02 <shachaf> How difficult would it be to implement it in GHC?
15:20:04 <kmc> but it doesn't work with type classes
15:20:08 <shachaf> Is there a reason it hasn't been done?
15:20:26 <joe6> kmc, do you have any links on how to do it in haskell?
15:20:35 <kmc> joe6, no
15:20:39 <shachaf> @google existential types haskell
15:20:40 <lambdabot> http://www.haskell.org/haskellwiki/Existential_type
15:20:40 <lambdabot> Title: Existential type - HaskellWiki
15:20:43 <joe6> uri: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
15:20:58 <joe6> kmc, is that what you were referring to?
15:21:06 <kmc> i was not referring to a document
15:21:09 <kmc> just an idea
15:21:15 <kmc> that document is probably about the idea i meant
15:21:18 <kmc> judging from the uri
15:23:22 <c_wraith> it's actually about the ghc extension
15:23:31 <c_wraith> which offers existentials in a weird indirect way
15:25:59 <dainanaki> I don't understand how existentials offer performance benefits, but I've heard that they do in some cases. Could someone elaborate on this?
15:26:03 <koninkje> @tell augur yo!
15:26:03 <lambdabot> Consider it noted.
15:27:32 <shachaf> dainanaki: Performance benefits?
15:27:36 <shachaf> For doing what?
15:27:41 <joe6> it is almost like a data type, but with a forall on it, correct?
15:27:53 <A1kmm> hmm, has anyone linked a dynamic library using Cabal and FFI on Windows? I'm getting problems since linkers on Windows don't like producing DLLs with undefined symbols.
15:27:56 <shachaf> joe6: I'm not sure what that's supposed to mean.
15:28:15 <joe6> uri: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists
15:28:28 <dainanaki> shachaf: I'm not sure. I've seen mention that existentially quantified types can grant some sort of speed benefits with GHC, but I don't know how or in what circumstances.
15:28:30 <joe6> the data ShowBox, there has a forall on it.
15:28:48 <A1kmm> (and Cabal / ghc are not adding any command line arguments for the library being imported)
15:29:00 <shachaf> joe6: It is a data type.
15:29:12 <shachaf> That's what the word "data" means when you declare it. :-)
15:39:30 <ivanm> preflex: seen Axman6
15:39:31 <preflex>  Axman6 was last seen on #haskell 8 hours, 15 minutes and 54 seconds ago, saying: * Axman6 -> bed
15:39:48 <Axman6> o/
15:42:43 <john_____> lambdabot: pl map
15:43:09 <ivanm> @pl map
15:43:09 <lambdabot> map
15:43:14 <ivanm> john_____: ^^ is that what you wanted?
15:43:17 <ivanm> @unpl map
15:43:17 <lambdabot> map
15:43:23 <leod> @src map
15:43:24 <lambdabot> map _ []     = []
15:43:24 <lambdabot> map f (x:xs) = f x : map f xs
15:44:03 <john_____> thanks ivanm
15:44:17 <john_____> I wanted to see how we can have a parameterless map
15:44:34 <ivanm> alternatively: map f = foldr ((:) . f) []
15:44:46 <ivanm> @pl \ f -> foldr ((:) . f) []
15:44:47 <lambdabot> flip foldr [] . ((:) .)
15:44:56 <ivanm> john_____: ^^
15:46:17 <john_____> @ivanm thrying to gasp looks intense
15:46:18 <lambdabot> Unknown command, try @list
15:46:29 <john_____> ivanm thrying to gasp looks intense
15:46:33 <ivanm> @src foldr
15:46:34 <lambdabot> foldr f z []     = z
15:46:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:46:38 <Axman6> john_____: pointfree code is not something you should be aiming for when writing haskell, as it greatly reduces clarity is almost all cases
15:47:17 <ivanm> well, not for complicated ones anyway
15:47:35 <ivanm> I tend to use @pl to see about maybe removing one parameter, that's about it
15:47:39 <edwardk> in general pointfree code is really only a good idea when you have one argument that you need to interact with, beyond that it usually devolves quickly
15:47:47 <Axman6> yeah
15:47:50 <kmc> Axman6, john_____, i find it's common that going partway to @pl makes my code clearer, and going all the way makes it worse
15:47:58 <antgeth> http://hpaste.org/51354 would folks mind helping me out with this function which is incredibly wrong?
15:48:11 <Axman6> kmc: yeah
15:48:19 <antgeth> it has multiple problems but i am totally lost
15:48:26 <john_____> You guys are great! this is immensely helpful
15:48:29 <ivanm> antgeth: such as?
15:48:42 <kmc> «h = (f .) . g»  <  «h x y = f (g x y)»  <  «h x = f . g x»
15:48:50 <john_____> I am preparing for an exam which might have pointless implementations of common functions
15:48:52 <kmc> concatMap f = concat . map f
15:48:57 <edwardk> worse partially applied functions don't inline, so you need to be careful with the performance characteristics of aggressively pointfreed code
15:48:57 <ivanm> antgeth: your intDiv definition will never end...
15:49:20 <antgeth> huh?
15:49:28 <ivanm> antgeth: intDiv n d = intDiv (n-d) d
15:49:34 <antgeth> oh you mean i need to set it up so that it wil stop at some point?
15:49:35 <ivanm> that's a recursion without a base case
15:49:40 <ivanm> antgeth: yes :)
15:49:48 <ivanm> assuming you _want_ it to stop
15:49:52 <ivanm> antgeth: what are you trying to do?
15:50:02 <ivanm> note that divMod is more efficient than doing div and mod separately
15:50:05 <antgeth> well the description is there
15:50:36 <ivanm> well, yeah, but it doesn't tell me why you would want to do that
15:50:42 <ivanm> when you're just using mod under the hood anyway
15:50:50 <ivanm> and divMod is more efficient than your intDivMod could be
15:51:27 <antgeth> it's just an practice exercise for a class i'm taking
15:51:37 <antgeth> how would i set up the base case in this one
15:51:38 <antgeth> ?
15:52:09 <ivanm> antgeth: well.... what are you trying to actually do?
15:52:16 <ivanm> what is your algorithm in words?
15:52:39 <edwardk> oh neat. my buddy tom finally released his haskell photon mapper: https://github.com/TomHammersley/HaskellRenderer/blob/master/Gallery/photon-map-wip-14-5-2011.jpg
15:52:42 <ivanm> and I question why any course would want you to define div by hand :/
15:53:18 <ivanm> edwardk: is "photon mapper" the new name for "ray tracer"?
15:53:37 <edwardk> not quite: http://en.wikipedia.org/wiki/Photon_mapping
15:54:07 <ivanm> ahhh, it adds stuff to ray tracing
15:54:09 <antgeth> well basically, to get it to subtract d from n until it can't (i.e. d is greater than n)
15:54:22 <edwardk> i tend to prefer MLT because of the lack of bias, but it gets nice results
15:54:46 <ivanm> antgeth: so, it only works on positive values?
15:54:51 <ivanm> div isn't that great a name then! :p
15:55:01 <ivanm> OK, let's think about this: do the base case first
15:55:22 <ivanm> intDiv n d | n < d = 0
15:55:32 <jwpowell> does anyone have a good recommendation for an introduction to monads?
15:55:34 <ivanm> ^^ when n is less than d, return 0
15:55:36 <jwpowell> i know there are a lot of them out there
15:55:41 <ivanm> jwpowell: just use them and pick them up as you go along
15:55:52 <ivanm> jwpowell: and learn IO separately from Monads
15:55:56 <antgeth> oh, damn i'm silly, i was trying to do it without the |
15:56:00 <ivanm> RWH has the best intro to monads I've seen though
15:56:01 <jwpowell> without worrying about overarching philosophy
15:56:12 <ivanm> as it builds them up over several chapters
15:56:33 <kmc> jwpowell, http://haskell.org/haskellwiki/FAQ#The_M-word
15:57:22 <ivanm> kmc: though that definition of monads is wrong...
15:57:32 <kmc> which?
15:57:33 <ivanm> oh, wait, _part_ of the definition
15:57:43 <ivanm> it was missing return
15:58:32 <jwpowell> i'm taking a look now
15:58:47 <AfC> I found Read World Haskell laborious; but after I'd read its Monad section (and was confused by it) I came across this http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html - which was somewhat concise, but then re-reading RWH I started to see the pattern (which I gather is the whole point).
15:59:04 <jwpowell> got a copy of wadler's notes from the first advanced functional programming conference
15:59:14 <antgeth> ok, now the thing actually loads, but it's not working right :P
15:59:17 <jwpowell> but i'm definitely not advanced :)
15:59:39 <jwpowell> yeah i just finished learn you
15:59:50 <antgeth> intMod is working but intDiv is not
15:59:50 <jwpowell> and feel like there's more to know before jumping into RWH
15:59:56 <Axman6> jwpowell: i found that it's much easier to start using monads without learning what it is that a monad really is. once you can use them, the idea will start to sink in
15:59:59 <antgeth> it's returning 0 no matter what
16:00:04 <jwpowell> okay
16:00:21 <ivanm> antgeth: yeah, but your intmod is just the normal definition of mod
16:00:41 <ivanm> do you _really_ need to re-implement div from scratch?
16:00:51 <antgeth> that is the instruction
16:00:59 <antgeth> and i would like to figure out how
16:01:06 <edwardk> the key to monads for me was looking at the type signatures of each of the methods. then it just became a game of figuring out how to put the pieces together to get the shape i wanted
16:01:07 <antgeth> having difficulty with recursion in general
16:01:32 <ivanm> antgeth: maybe read through some tutorials on recursion first then?
16:01:36 <antgeth> i have
16:01:39 <edwardk> all the laws state is that it doesn't really matter the order in which you use those types
16:01:49 <ivanm> if you're still stuck, read through more of them then! :p
16:02:01 <Axman6> jwpowell: the Maybe monad is probably the easiest to understand in terms of its definition, so take a look at that. also things like the Get and Put monads in the Binary package are quite fun to play with, and at least show you that Monad can be  very powerful abstraction, providing a very simple interface
16:02:22 <kmc> meh, the PutM monad is dumb
16:02:31 <kmc> nobody ever uses a PutM action not of type (PutM ())
16:02:44 <edwardk> kmc: well, not for very long at least
16:02:49 <ivanm> kmc: I do
16:02:51 <Axman6> > let intDiv n d | n < d = 0; intDiv n d = 1 + intDiv (n-d) d in intDiv 22 7
16:02:51 <kmc> it's basically a way to abuse the "do" notation for monoids
16:02:51 <lambdabot>   3
16:02:54 <kmc> ivanm, really?
16:02:56 <ivanm> but I have to dump it because it doesn't work...
16:03:08 <antgeth> i just figured out the 1+
16:03:10 <antgeth> : )
16:03:22 <ivanm> I had a function of type: [a] -> PutM Int
16:03:32 <ivanm> which was meant to count how many values were in the list whilst serialising them
16:03:38 <kmc> ah
16:03:43 <ivanm> but it ends up chewing through all the RAM :s
16:03:53 <ivanm> so I have to re-write that to go and do the counting at the IO stage
16:04:36 <shachaf> Axman6: Identity > Maybe
16:04:40 <shachaf> Null > Identity
16:04:47 <ivanm> what's the Null Monad?
16:05:04 <kmc> data Null a = Null -- ?
16:05:06 <shachaf> data Null a = Null
16:05:16 <Axman6> Identity isn't useful for learning monads because it doesn't give you any advantages from its use
16:05:18 <shachaf> It's the best monad.
16:05:19 * hackagebot hexquote 0.1 - Hexadecimal ByteString literals, with placeholders that bind variables  http://hackage.haskell.org/package/hexquote-0.1 (KeeganMcAllister)
16:05:23 <edwardk> kmc: heh i went to go dig up my counter example from trifecta then realized i'd refactored it so i was only using the HTML () type from Blaze heh
16:05:34 <Axman6> well, i've only ever seen one advantage from using Identity
16:05:48 <kmc> there's also «newtype Const a b = Const a»
16:05:49 <ivanm> shachaf: heh
16:05:55 <kmc> and (Const a) is a monad like Null
16:06:06 <ivanm> Axman6: which is easier stack definition?
16:06:46 <antgeth> ivanm, axman6; thank you for your help... i may return later with one more question :P
16:06:56 <edwardk> Identity is kinda nice as a sort of base case for the 'pattern' of how to build up a monad. you start with Identity, then you can tweak it to add an argument or a result, etc.
16:07:38 <john_____> ivanm failing to understand why map= flip foldr [] . ( (:) . ) is working. in this definition which two arguments are flipped by flip?
16:07:40 <Axman6> someone was running into an infinite loop that was caused by using the wrong name for a variable, and using the identity monad avoided the loop because it meant variables couldn't be used self-recursively
16:07:52 <Axman6> > let intDiv n d | n < d = 0; intDiv n d = 1 + intDiv (n-d) d in intDiv (2^62) 2
16:07:53 <lambdabot>   *Exception: stack overflow
16:07:58 <ivanm> john_____: well, map only takes two arguments... :p
16:08:17 <ivanm> john_____: OK, the `f' argument is absorbed by the ((:) .)
16:08:40 <ivanm> so you now have: map f xs = (flip foldr []) ((:) . f) xs
16:08:42 <john_____> ivanm: so f is composed with ( (:) . )
16:08:53 <edwardk> john: the first two arguments to foldr
16:09:00 <edwardk> :t flip foldr
16:09:01 <lambdabot> forall a a1. a1 -> (a -> a1 -> a1) -> [a] -> a1
16:09:05 <Axman6> john_____: the flip is on foldr, it's flipping the first two arguments of foldr f x xs (ie f and z, or ((:) . f) and [])
16:09:06 <edwardk> :t foldr
16:09:07 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:09:15 <edwardk> :t flip foldr []
16:09:16 <lambdabot> forall a a1. (a -> [a1] -> [a1]) -> [a] -> [a1]
16:09:20 <ivanm> yeah, I kinda mislead you... :/
16:09:52 <edwardk> :t ((:).)
16:09:53 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ([a] -> [a])
16:10:02 <edwardk> bah
16:10:10 <edwardk> :t ((:) Prelude..)
16:10:11 <lambdabot> forall b a. (a -> b) -> a -> [b] -> [b]
16:10:17 <john_____> what i am not getting is why [] is composed with ( (:) . )
16:10:27 <Axman6> it's not
16:10:33 <Axman6> it's an argument to foldr
16:10:42 <edwardk> flip foldr []   is being composed with ((:).)
16:10:42 <ivanm> john_____: you have: flip foldr [] ((:) . f) xs
16:10:45 <edwardk> :t flip foldr []
16:10:45 <lambdabot> forall a a1. (a -> [a1] -> [a1]) -> [a] -> [a1]
16:10:50 <Axman6> it's foldr's second argument, but it becomes its first because of the flip
16:10:54 <edwardk> that expects a (a -> [a1] -> [a1])
16:10:56 <ivanm> the flip applies to the first two arguments, so it becomes: foldr ((:) . f) [] xs
16:11:01 <john_____> edwardk: thanks that was what i am looking for
16:11:03 <edwardk> :t ((:) Prelude..)
16:11:08 <lambdabot> forall b a. (a -> b) -> a -> [b] -> [b]
16:11:25 <edwardk> and given a function from (a -> b)    that is exactly what ((:) .) gives you
16:11:35 <edwardk> which coincidentally yields the signature of map
16:12:37 <edwardk> @pl \f x xs -> foldr f (\a b -> f a : b) [] xs
16:12:37 <lambdabot> const . flip (ap foldr ((:) .)) []
16:12:41 <edwardk> er
16:12:55 <edwardk> @pl \f xs -> foldr f (\a b -> f a : b) [] xs
16:12:55 <lambdabot> flip (ap foldr ((:) .)) []
16:13:07 <edwardk> wow i mangled that again
16:13:14 <edwardk> @pl \f xs -> foldr (\a b -> f a : b) [] xs
16:13:15 <lambdabot> flip foldr [] . ((:) .)
16:13:39 <john_____> thanks all.. i think this is more readable for me - (flip foldr [] ) . ( (:) .)
16:13:42 <edwardk> dropping the xs is easy, then to get the f into the right place it has to swap the args to foldr then use . to get under the lambda
16:14:16 <john_____> edwardk: so the point was composing f with foldr and flip is doing the job by taking the empty list first so the function can compose itself with f
16:14:48 <edwardk> john_____: you'll find you want to drop the prophylactic parentheses eventually, the rule is simple 'nothing binds tighter than application' -- er.. except record syntax bang patterns and as-patterns
16:15:09 <edwardk> yeah
16:15:19 <edwardk> we need to get f into (\a b -> f a : b)
16:15:26 <edwardk> @pl (\a b -> f a : b)
16:15:26 <lambdabot> (:) . f
16:15:45 <edwardk> which is ((:) . )
16:17:04 <jwpowell> is using a fixed point combinator any faster than recursion?
16:17:11 <edwardk> jwpowell: no
16:17:17 <jwpowell> okay
16:17:53 <edwardk> in particular cases you might write some kind of rewrite rule from the general form, which is the basis of some of the fusion techniques, but that caveat is more confusing than useful ;)
16:17:54 <hpc> jwpowell: it can occasionally make faster algorithms easier to read
16:19:51 <joe6> is there any way to "show" a type?
16:20:05 <dobblego> @type show
16:20:05 <lambdabot> forall a. (Show a) => a -> String
16:20:15 <c_wraith> :t show . typeOf
16:20:16 <lambdabot> forall a. (Typeable a) => a -> String
16:20:23 <joe6> c_wraith, thanks.
16:21:04 <hpc> > show "bacon"
16:21:05 <lambdabot>   "\"bacon\""
16:21:29 <joe6> i created a custom typeclass. Do I have to do anything to be able to use "typeOf"
16:21:39 <shachaf> deriving Typeable
16:21:42 <shachaf> @ty typeOf
16:21:43 <lambdabot> forall a. (Typeable a) => a -> TypeRep
16:21:59 <hpc> joe6: you shouldn't need it though, barring extreme circumstances
16:22:17 <joe6> hpc, why do you say that?
16:22:36 <parcs> > show . typeOf $ True
16:22:38 <lambdabot>   "Bool"
16:22:43 <parcs> neat
16:22:43 <hpc> sameType a b = typeOf a == typeOf b -- perfectly reasonable function?
16:22:59 <hpc> or sameType :: a -> a -> a; sameType a b = a
16:23:00 <ion> joe6: You already know the types of everything in compile time because haskell is statically typed.
16:23:54 <joe6> ion, yes, but I do not want to write out: show :: CGlobal -> String; show type = show $ typeOf (undefined::type)
16:24:01 <joe6> for each CGlobal
16:24:14 <joe6> i have a bunch of instances for the CGlobal typeclass.
16:24:28 <kmc> :t let x === y = case cast y of Just z | x == z -> True; _ -> False in (===)
16:24:29 <lambdabot> forall b a. (Eq b, Typeable b, Typeable a) => b -> a -> Bool
16:24:46 <kmc> @let x === y = case cast y of Just z | x == z -> True; _ -> False in
16:24:47 <lambdabot>   Parse error: in
16:24:48 <hpc> joe6: that sounds like a good case for Typeable, to me
16:24:49 <kmc> @let x === y = case cast y of Just z | x == z -> True; _ -> False
16:24:50 <lambdabot>  Defined.
16:24:52 <kmc> > 2 === 2
16:24:53 <lambdabot>   True
16:24:54 <kmc> > 2 === 3
16:24:55 <lambdabot>   False
16:24:57 <kmc> > 2 === "blah"
16:24:58 <lambdabot>   False
16:25:04 <hpc> (someone else will probably correct me)
16:25:25 <Axman6> > 2 === "2"
16:25:26 <lambdabot>   False
16:25:37 <Axman6> damn, PHP/JS mode is turned off
16:26:54 <hpc> > 2 === '2'
16:26:56 <lambdabot>   False
16:27:00 <hpc> C mode is turned off too :P
16:27:08 <parcs> :t cast
16:27:09 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
16:27:53 <parcs> when does cast return Just _ ?
16:28:08 <parcs> except for when a ~ b
16:28:27 <hpc> > cast (5 :: Int) :: Integer
16:28:27 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
16:28:28 <lambdabot>         against inf...
16:28:36 <ion> > cast (5 :: Int) :: Maybe Integer
16:28:36 <lambdabot>   Nothing
16:28:50 <hpc> that's strange
16:28:59 <hpc> > cast 'a' :: Int
16:29:00 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:29:00 <lambdabot>         against inferred type ...
16:29:04 <hpc> > cast 'a' :: Maybe Int
16:29:04 <lambdabot>   Nothing
16:30:30 <Eduard_Munteanu> > cast (256 :: Word16) :: Word8
16:30:31 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
16:30:31 <lambdabot>         against inferred type...
16:30:51 <ion> :set -XDoWhatIMean
16:33:47 <hpc> :set -XDontDoWhatThisExtensionMeans
16:38:42 <leod> doesn't cast require that the types have the same representation?
16:38:47 <leod> as it basically comes down to an unsafeCoerce
16:39:33 <ddarius> You could implement cast without unsafeCoerce.
16:39:35 <pikhq> Eduard_Munteanu: Um.
16:39:44 <pikhq> > cast (256 :: Word16) :: Maybe Wor8
16:39:45 <lambdabot>   Not in scope: type constructor or class `Wor8'
16:39:47 <pikhq> > cast (256 :: Word16) :: Maybe Word8
16:39:48 <lambdabot>   Nothing
16:39:50 <pikhq> Even.
16:39:54 <ion> > cast (42 :: Word16) :: Maybe Int16
16:39:55 <lambdabot>   Nothing
16:40:17 <pikhq> Hmm. Seems a bit more strict than I would've expected. *shrug*
16:41:34 <pikhq> ddarius: Well, cast _ = Nothing *technically* implements it.
16:49:21 <ddarius> No it doesn't.
16:49:58 <joe6>  is it possible to derive a Typeable to all instances of a typeclass?
16:50:25 <joe6> instead of having to write deriving Typeable to each instance definition?
16:55:13 <DukeDave> Can anyone recommend a good approach to debugging a segfault which has occurred using wxHaskell?
16:55:32 <DukeDave> (I'm wrapping some new functionality, but it segfaults when I mouse over something)
17:05:22 <joe6> something like this: http://codepad.org/hjsHT1DL
17:10:19 <Eduard_Munteanu> DukeDave: use a wxWindows build that includes debugging info?
17:10:24 <Eduard_Munteanu> erm, wxWidgets
17:11:12 * Eduard_Munteanu isn't sure of wxHaskell's state/quality
17:11:30 <Eduard_Munteanu> But wxWidgets can be particularly quirky,
17:12:10 <Eduard_Munteanu> (actually that'd be a wxWidgets debug build)
17:12:55 <DukeDave> Eduard_Munteanu: That is an idea..
17:13:01 <dainanaki> let reverseMap fs x = map ($ x) fs
17:13:10 <dainanaki> > let reverseMap fs x = map ($ x) fs
17:13:11 <lambdabot>   not an expression: `let reverseMap fs x = map ($ x) fs'
17:13:28 <dainanaki> hrm, how do I define function again?
17:13:42 <Eduard_Munteanu> dainanaki: you have to use let ... in ...
17:13:48 <dainanaki> ah.
17:13:51 <Eduard_Munteanu> or @let definition
17:14:18 <Eduard_Munteanu> @let reverseMap fs x = map ($ x) fs
17:14:19 <lambdabot>  Defined.
17:14:21 <Eduard_Munteanu> @undefine
17:14:36 <dainanaki> alright then. thanks.
17:15:00 <Eduard_Munteanu> Unless you have lots of definitions, just go for   > let ... in ...
17:19:39 <hpc> :t reverseMap
17:19:40 <lambdabot> Not in scope: `reverseMap'
17:19:49 <hpc> oh, undefined
17:21:00 <antgeth> hey so
17:21:10 <antgeth> a list can be expressed as a head plus the rest
17:21:16 <antgeth> like n:list
17:21:20 <kmc> "Generates an integral number from a bounded domain. The number is chosen from the entire range of the type, but small numbers are generated more often than big numbers. Inspired by demands from Phil Wadler." -- QuickCheck docs
17:21:23 <antgeth> can they also expressed as a tail?
17:21:24 <antgeth> like
17:21:26 <antgeth> list:n
17:21:37 <kmc> i think "Inspired by demands from Phil Wadler" is probably the best possible thing to put in docs
17:21:58 <kmc> antgeth, no, Haskell lists are single-linked lists
17:21:58 <c_wraith> Hmm.
17:22:02 <kmc> data List a = Nil | Cons a (List a)
17:22:13 <kmc> antgeth, but look at Data.Sequence if you want something you can destructure from both ends
17:22:24 <c_wraith> I want something that generates something from the entire range of Integer, potentially.
17:22:48 <c_wraith> ...  I can actually see how to do that with an exponential decay.
17:22:52 <c_wraith> So it's not impossible!
17:23:13 <c_wraith> Next question, can it be done with a normal distribution?
17:23:35 <monochrom> as in guassian distribution? sure, pick the mean.
17:23:46 <c_wraith> 0, of course. :)
17:23:46 <Cale> What does that mean?
17:24:17 <monochrom> alright, then do the gaussian as usual, then some truncation to integerize
17:24:18 <Cale> You can't put a normal distribution on Integer, because Integer is countable?
17:24:54 <Jafet> You can pick integers with fractional probability
17:25:34 <c_wraith> well, in a sense, it'll always be a bar graph
17:25:54 <monochrom> I'm happy enough with an exponential distribution actually
17:26:01 <Cale> There's the geometric distribution, which is probably the most natural thing to do.
17:26:38 <Cale> (Is that what you mean by exponential?)
17:26:52 <c_wraith> yeah
17:28:52 <Cale> and then there's the binomial distributions, which I guess look kinda like the normal distribution in a formalisable way :)
17:29:37 * monochrom adds a million binomial variables to get an even better gaussian
17:30:32 <Jafet> My binomials have two variables
17:30:35 * Jafet shame
17:31:19 * Axman6 only works with trinomials, gotta use the latest tech!
17:32:46 <Eduard_Munteanu> With complex numbers you kinda get 6, akin to HT :P
17:34:02 <Axman6> hexanomials?
17:37:10 <kniu> what happened with cabal-install?
17:37:17 <kniu> why isn't it up to date with cabal?
17:37:26 <ivanm> kniu: it is
17:37:40 <ivanm> well, maybe not for the snapshot that comes with 7.2.1 ...
17:37:40 <kniu> ivanm, really?
17:37:45 <ivanm> but then, you're not meant to use 7.2.1
17:37:46 <kniu> I mean 7.2.1, yeah
17:37:50 <kniu> oh
17:37:52 <kniu> bummer
17:37:57 <ivanm> kniu: because that wasn't an official Cabal release
17:38:05 <ivanm> the GHC devs just took a snapshot from the repo
17:43:44 <stribor> ok can anyone help stribor with something
17:44:16 <hpaste> stribor pasted “my goal” at http://hpaste.org/51356
17:44:58 <c_wraith> Hmm.  That's not exactly the simplest thing.
17:45:07 <c_wraith> However, it's not *too* hard.
17:45:15 <c_wraith> You just have to treat it as having two independent steps
17:45:32 <c_wraith> also, what do you do if the last string in the list is ""?
17:46:05 <stribor> nothing ...just add it  at the end
17:46:15 <stribor> if you can maybe give me some directonis on this
17:46:19 <c_wraith> but you don't change the preceding string?
17:46:36 <stribor> wel you see how i start with input string...and concat it with first element in the list
17:46:45 <stribor> once it reaches length of 5
17:47:04 <stribor> we stoop and we start filling again in the second element in the output list
17:47:08 <c_wraith> I had no clue it was length 5 in that example.
17:47:27 <c_wraith> since it was exactly "move one character from each"
17:47:50 <stribor> this is actually for my assgn and just for you to know i dont want solution
17:47:54 <c_wraith> yeah.
17:48:06 <stribor> and this seems too hard for beggining course in haskell
17:48:08 <c_wraith> So what's the exact specification?  Your sample input and output left some room for interpretation
17:48:15 <stribor> otr maybe i am overthinking this
17:48:45 <monochrom> I don't understand why there are two separate parameters rather than one single list parameter
17:48:51 <stribor> well he wants me to have input strinf and also list of strings
17:49:11 <stribor> he wants me to create list of lines that will be of some certain length or less
17:49:43 <c_wraith> Everything you say is making it more confusing.  Please tell us what the *exact* specification is.
17:50:24 * monochrom expects answer "it's an assignment so there is no exact specification"
17:50:25 <stribor> like you add input string to first element of list....you check lenght.....if llength is <50(lets say) you keep adding from second item in list....
17:50:56 <stribor> once you rech the limit....you start doing same thing but place result in second element of the list
17:51:06 <stribor> i know i am having troubles even explaining this
17:51:46 <c_wraith> stribor, does the splitting in the input list matter?  Could you solve the problem by first concatenating all the strings, then just working from that?
17:52:33 <monochrom> you know, if you type in the assignment question verbatim, then there is nothing to explain...
17:52:36 <stribor> i guess it could be done but i dont even know how to write complicated function like this
17:52:46 <stribor> monochrom: i know..lol...sorry
17:53:04 <c_wraith> if it's long, put it in a paste site, though.
17:53:42 * monochrom doesn't understand the logic behind "I must explain everything in my own words to prove that I understand nothing"
17:55:30 <stribor> first input is just string that has been produced....while input list is just list of words
17:56:02 <stribor> then result is just list of lines of certain length
17:56:25 <stribor> if length is 50 then resulting list will be list of lines with length 50 or less
17:56:44 <BMeph> stribor: Yeah, but what variable do you use to keep track of where in the list you are? ;)
17:57:10 <stribor> exactly
17:57:14 <stribor> thats why i am lost
17:57:20 * BMeph sighs
17:58:30 * BMeph feels like stribor is trying to push a Ferrari...
17:58:34 <stribor> i i am suppose to add new world to the line (first input string) if it stays under 50
17:58:41 <stribor> otherwise i start new line
17:58:44 <stribor> lol
17:58:45 <stribor> hahaha
17:59:32 <BMeph> Quote: " <c_wraith> stribor, does the splitting in the input list matter?  Could you solve the problem by first concatenating all the strings, then just working from that?"
18:00:12 <BMeph> stribor: I think you need to sit and re-read that sentence, and figure out what c_wraith meant. ;)
18:00:19 <augur> whats the best way to use haskell in obj-c?
18:00:50 <ion> #include <unistd.h>
18:01:03 <ion> exec("runhaskell", …);
18:01:08 <augur> hm!
18:01:18 <stribor> if i concatinate whole stirng and then try spliting it...how would i know when i am splitting it at what position i should split
18:01:48 <stribor> if input is "jerry" ["elaine","kramer","george"]
18:01:50 <Axman6> augur: well, Objective-C is a strict superset of C, so anything you can do in C you can do in Obj-C
18:01:59 <BMeph> stribor: When you tell it, "split this string 'here'"... ;)
18:02:03 <stribor> then output is "jerryelainekramergeorge"
18:02:17 <Eduard_Munteanu> stribor: every length + 1 of your first string?
18:02:30 <ion> why "jerry" ["elaine","kramer","george"] and not ["jerry","elaine","kramer","george"]?
18:02:45 <Axman6> because jerry earns more money
18:02:52 <Axman6> or, earned anyway
18:02:55 <stribor> ion: because input is string and list of string
18:02:58 <stribor> lol
18:03:02 <monochrom> because the question designer is a pervert
18:03:08 <Eduard_Munteanu> :)
18:03:11 <Axman6> now he does shitty ads for an insurance company here in Australia
18:05:13 <applicative> something about stribor's description makes it seem like he is supposed to format text to less than fifty chars per line, without breaking words
18:05:33 <rwbarton> my theory is that the problem is line wrapping with the greedy algorithm and the example test case is wrong
18:06:29 <applicative> right
18:06:50 <BMeph> My theory is that stribor has a Ferrari, but he's so used to skateboards, that he insists on pushoing the bloody thing... ;)
18:07:04 <BMeph> *pushing
18:07:09 <rwbarton> and maybe the first argument is separate because it's sort of helpful for writing the solution (though not really)
18:10:29 <joe6> drop (length x - 2) x where x = splitOn "." "test.test1"; is there a better way of picking the last 2 elements of a list?
18:11:21 <Axman6> i would suggest using init.init there
18:11:38 <Axman6> > init . init $ "Hello"
18:11:39 <lambdabot>   "Hel"
18:11:48 <Axman6> oh, drop, sorry
18:12:46 <Axman6> > let f [a,b] = [a,b]; f (x:xs) = f xs; f _ = error "List not long enough" in f "Hello"
18:12:46 <lambdabot>   "lo"
18:13:19 <kmc> > iterate (`div` 256) (4 :: Word8)
18:13:19 <lambdabot>   [4,*Exception: divide by zero
18:13:25 <kmc> why?
18:13:34 <ion> Why not?
18:13:35 <kmc> why should (`div` 256) ever divide by zero?
18:13:43 <ion> > 256 :: Word8
18:13:46 <lambdabot>   0
18:13:48 <kmc> > 0 `div` 256
18:13:48 <lambdabot>   0
18:13:55 <kmc> oh, durr
18:13:55 <parcs> @hoogle sleep
18:13:56 <lambdabot> No results found
18:13:56 <kmc> ok
18:14:02 <kmc> > 256 :: Word8
18:14:03 <lambdabot>   0
18:14:04 <kmc> that's why
18:14:05 <kmc> sigh
18:14:38 <luite> hehe time to stop coding today kmc ;)
18:14:47 <kmc> never
18:15:08 <luite> or demand larger bytes
18:15:11 <kmc> it's a generic function for all Integral...
18:15:15 <kmc> but it fails on Word8 ;P
18:17:02 <joe6> intercalate "," $ drop (length x - 2) x where x = splitOn "." "test.test1.test2.test3"; this is what I ended up with.. just curious if there is a better way?
18:17:35 <joe6> i want "test2.test3" from "test.test1.test2.test3"
18:20:34 <Eduard_Munteanu> :t div
18:20:35 <lambdabot> forall a. (Integral a) => a -> a -> a
18:22:11 <ion> > tails "foobarbaz" !! 2
18:22:12 <lambdabot>   "obarbaz"
18:22:17 <ion> Err. sorry
18:22:23 <applicative> rbarton I was thinking the first argument is separate because it's the word the user just entered at the cursor. the list is the lines as they were wrapped, the result is the new wrapping
18:22:43 <Axman6> @ check (\x -> x `rem` (255 :: Word8) == x)
18:22:47 <Axman6> @check (\x -> x `rem` (255 :: Word8) == x)
18:22:48 <lambdabot>   "Falsifiable, after 6 tests:\n255\n"
18:24:09 <ivanm> Axman6: did you expect anything different?
18:24:35 <Axman6> not really. couldn't remember if that would work or not =)
18:27:23 <joe6> just curious if there is a better way of writing this: http://codepad.org/UXV1mpzQ
18:27:30 <kmc> does QuickCheck 2 have an equivalent to QuickCheck 1's runTests?
18:30:51 <applicative> joe6 where is "result" coming from
18:31:08 <joe6> applicative, from the where clause.
18:31:23 <applicative> ah yes
18:32:59 <joe6>  check Ep0InBd (0::Word32) (return $ 1 :: IO Word32)  = Just "Usb_H.Ep0InBd: 0   =>   1"
18:33:08 <joe6> http://codepad.org/qFDpNH2Z
18:38:22 <hpaste> int80_h pasted “Can I use a GADT (Phantom Type) to solve my problem?” at http://hpaste.org/51357
18:42:51 <Eduard_Munteanu> int80_h: why not simply have JobState in one of your constructors?
18:44:18 <Eduard_Munteanu> What GADTs do is allow constructors to choose the index of a type.
18:45:37 <Eduard_Munteanu> But your datatype doesn't even have a parameter.
18:50:22 <int80_h>  Eduard_Munteanu : What would that look like? When I tried it I would get conplains about JobState not having a Show instance. JobSite is a type synonym for an MVar
18:51:16 <int80_h>  Eduard_Munteanu: What would that look like? When I tried it I would get conplains about JobState not having a Show instance. JobSite is a type synonym for an MVar
18:52:11 <int80_h> Erm s/JobSite/JobState
18:52:26 <Eduard_Munteanu> int80_h: you could either write your own Show instance for JobException, or write a Show instance for MVars.
18:53:10 <int80_h> Eduard_Munteanu: the first one makes more sense. I can visualize what that would oook like.
18:53:46 <Eduard_Munteanu> If you don't care about it, it could simply be   instance Show (MVar a) where show _ = "<mvar>"
18:53:48 <int80_h> oh well, I thought I could have some fun with phantom types
18:54:50 <Eduard_Munteanu> A phantom type is something different.
18:55:25 <int80_h> I was reading in "Fun With Phantom Types a description of a Dynamic type and it looked exactly like what I wanted.
18:55:54 <int80_h> but you are right, if this does the job I'll stay with simple
19:01:43 <kmc> int80_h, don't write bizarre instances for standard types
19:02:31 <kmc> it's usually not the right solution
19:02:37 <kmc> usually an indication that you should have defined a new type
19:03:00 <int80_h> kmc: you mean EMs example for MVar?
19:03:08 <kmc> yeah
19:03:27 <Eduard_Munteanu> There isn't much in the way of a sensible MVar Show instance, anyway.
19:03:38 <int80_h> kmc: you're familiar with Fun With Phantom Types right? Is the description of Dynamic Types there what I am loking for?
19:03:43 <Eduard_Munteanu> unless you want to perform unsafePerformIO tricks, which is worse.
19:04:05 <kmc> yeah, that's not very sensible either
19:04:10 <kmc> int80_h, i don't recall what's in the document
19:04:17 <kmc> and i didn't read the whole of your paste
19:04:23 <int80_h> kmc: I can find it very quickly and paste on hpaste
19:04:36 <kmc> shrug
19:04:38 <kmc> i'm kind of busy, sorry
19:04:46 <int80_h> I bookmarked it. The notation is new to me but otherwise I like it.
19:04:51 <Eduard_Munteanu> The right thing indeed is writing a proper instance for JobException yourself.
19:04:53 <int80_h> no worries
19:05:30 <Eduard_Munteanu> (one which ignores the embedded mvar)
19:05:30 <kmc> crazy GHC extensions and type hacks are fun, but there's often a simpler solution
19:05:53 <int80_h> Eduard_Munteau : So I need to add a data constructor to JobException and include a field for a ProcessState?
19:06:11 <Eduard_Munteanu> int80_h: or use an existing constructor if that's ok.
19:07:15 <int80_h> Eduard_Munteau: I thought each data constructor had to be unique to a data record.
19:09:45 <int80_h> I'm confused still. I don't see how I can get away with adding a field for a JobState to JobException, and avoid having to write a Show instance for MVar at the same time
19:10:22 <Eduard_Munteanu> You could have  data JobFailure = JobFailure JobException JobState
19:10:57 <Eduard_Munteanu> Or just a tuple.
19:11:18 <int80_h> Eduard_Munteanu: I thought about the tuple, but ghci barfed
19:11:48 <int80_h> something like data JobFailure = JobFailure (JobException, JobState)
19:11:55 <Eduard_Munteanu> I initially meant extending any of your constructors to contain JobState, but it looks like all of them might need it.
19:12:22 <Eduard_Munteanu> int80_h: no, I mean using (JobException, JobState) directly
19:12:38 <Eduard_Munteanu> or a type synonym
19:13:09 <int80_h> I need to be able to pass an Exception, has to be an Exception.
19:14:14 <int80_h> Eduard_Munteau: I could wrap that tuple in a newtype and then make that newtype an instance of Exception, right?
19:15:26 <int80_h> I can wrap my head around that, if it makes sense to do
19:19:43 <kniu> I have written a simple typechecker
19:19:44 <kniu> now
19:20:04 <Eduard_Munteanu> int80_h: ah, right. Yeah, thats one way.
19:20:05 <kniu> I can't find any tutorials on how to typecheck recursive let-definitions
19:20:13 <int80_h> excellent!
19:20:18 <int80_h> I can do that
19:20:37 <int80_h> Thanks for your help, I've needed someone to talk this out with.
19:20:40 <kniu> all these papers only deal with lets that have only one binding
19:21:01 <Eduard_Munteanu> No problem.
19:21:04 <kmc> kniu, "Typing Haskell in Haskell" covers it, no?
19:21:12 <kniu> kmc, it does?
19:21:15 <kniu> gonna look it up
19:21:25 <kmc> i think so.  i think it presents a complete typechecker for Haskell 98
19:21:27 <dolio> Just do the same thing as you would for one definition, but with all of them.
19:21:47 <kmc> the Haskell 98 rules are a little weird
19:22:13 <dolio> Unless you want to get as polymorphic as possible, in which case you have to do a little analysis of what depends on what.
19:22:20 <kniu> wow
19:22:22 <kniu> this paper's from 2000
19:22:25 <kniu> that's p. old
19:22:31 <kmc> > 2000 > 1998
19:22:32 <lambdabot>   True
19:23:19 <Eduard_Munteanu> Haskell2010 isn't exactly revolutionary either. :)
19:25:33 <JoeyA> But it finally has lambdas!  Oh wait, I'm thinking of another language.
19:26:01 * JoeyA waits for C++ to implement GADTs.
19:26:40 <JoeyA> meh, it's taking too long
19:27:04 <kniu> dude you waited for only like 30 seconds
19:27:15 <JoeyA> lol
19:27:29 <Eduard_Munteanu> @shapr C++
19:27:29 * lambdabot smacks C++ about with a large trout
19:28:21 <Eduard_Munteanu> Oops, that might've highlighted him unintentionally.
19:28:48 <JoeyA> > What's a good date/time library for Haskell?
19:28:49 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:28:51 <Eduard_Munteanu> @slap C++
19:28:51 * lambdabot locks up C++ in a Monad
19:28:53 <JoeyA> Oops
19:30:10 * ksf refuses to shave that yak.
19:30:27 <tensorpudding> an unshaved yak stays warm in the winter
19:30:36 <kmc> but yak fur is so valuable
19:31:14 <int80_h> Eduard_Munteau: That newtype now requires me to write a Show instance for MVar again. Back where I started.
19:31:15 <kniu> I want
19:31:18 <kniu> monadic view patterns
19:31:36 <ksf> I just hacked up my .vimrc to grep package info out of cabal_macros.h and pass them to haskellmode, but I *don't* feel inclined to hack up the rest of what'd constitute half-way decent cabal integration.
19:32:23 <ksf> there ought to be a cabal options <file> command, that looks for the .cabal belonging to <file> and gives you all the options ghc needs to compile/ghci it.
19:32:24 <kmc> int80_h, why does it require that?
19:32:33 <ksf> yak fur is actually quite cheap.
19:32:39 <int80_h> > newtype ExceptionState = EState (JobException, JobState)
19:32:39 <int80_h> >                             deriving (Show)
19:32:39 <lambdabot>   <no location info>: parse error on input `newtype'
19:32:40 <lambdabot>   <no location info>: parse error on input `deriving'
19:32:43 <ksf> at least according to dwarf fortress.
19:32:52 <kmc> int80_h, don't derive Show; implement it yourself
19:32:57 <int80_h> JobState is a type synonym for an MVar
19:33:09 <tensorpudding> hmm
19:33:25 <ksf> ...in the meantime, it's a matter of manually adding -isrc -idist/build/autogen -Wall -fno...
19:33:32 <int80_h> won't I still have to implent it for MVar? I need ExceptionState to be an instance of Exception
19:33:39 <kmc> why would you?
19:34:01 <int80_h> kmc: Well I came to that comclusion due to the error messages I've been getting all day
19:34:08 <kmc> don't derive Show; implement it yourself
19:34:28 <kmc> when you derive Show, it wants a Show instance for each data field
19:34:48 <int80_h> ah!
19:34:51 <kmc> that need not be true if you write the instance yourself
19:34:57 <int80_h> hahahah!
19:35:00 <int80_h> oh I see
19:35:07 <int80_h> TIL
19:35:13 <kmc> writing an instance for Exception requires Typeable and Show, but it doesn't require that you *derive* either of those
19:35:17 <kmc> you should always derive Typeable, though
19:35:32 <kmc> if you write a Typeable instance yourself, you can make the type system unsound
19:35:44 <kmc> but MVar should already be an instance of Typeable, so no problem
19:35:53 <int80_h> thanks man :)
19:36:09 <int80_h> when I get this working I'll have to update my stackoverflow question.
19:36:13 <kmc> newtype T = T (MVar Int); instance Show T where show _ = "no way"
19:36:55 <kmc> 'deriving' just asks the compiler to write the instance for you, in a standard way
19:36:59 <kniu> re: binding groups
19:37:03 <kniu> > this is the most complex, and most subtle component of type inference.
19:37:03 <lambdabot>   <no location info>: parse error on input `,'
19:37:04 <kniu> oh boy.
19:37:08 <Eduard_Munteanu> int80_h: use tab completion ;)
19:37:16 <kmc> but the standard instances for Show involve calling "show" on each data field
19:37:33 <kmc> but a custom instance does not have to
19:38:39 <int80_h> Complies!
19:38:42 <int80_h> yes
19:38:49 <mike-burns> Ship it!
19:39:06 <int80_h> we don't neeed no stiiinking uni testing.
19:39:15 <kmc> tests fail? no problem, ship anyway
19:39:15 <int80_h> unit
19:40:16 <int80_h> kmc: advanced research has demonstreated that the "Customer Bitch Call" method of bug discovery yields the most economical results. ;)
19:40:35 <kmc> yeah, because standards are absurdly low
19:40:44 <punkk> Going through problem set, need help: trying to create function Parity :: [Int] -> [Int] that would work as follows: Parity [2,3,4] --> [0,1,0]
19:40:47 <mike-burns> It's true; that's what Zynga does, among others.
19:40:50 <int80_h> but the reasearch! It's advanced and all!
19:40:57 <tactics> Does anyone have a link to a tutorial on DeBruijn indices?
19:40:58 <kmc> people who buy software are used to getting something that doesn't work at all, and then having to spend their own time getting it fixed, maybe
19:41:08 <kmc> that's because they don't know they can demand better
19:41:12 <kmc> "all software sucks, what can you do"
19:41:25 <tactics> I get the general idea of DeBruijn indexes, but I can't for the life of me figure out how to calculate the substitution function
19:41:47 <kmc> > map (fromEnum . odd) [2,3,4]
19:41:48 <lambdabot>   [0,1,0]
19:41:53 <Axman6> punkk: well, what do the numbers that produce a 0 have in common?
19:42:34 <punkk> divisible by 2 without remainders, even.
19:42:40 * int80_h raises his hand and jumps up and down.
19:42:58 <ion> > map (`mod` 2) [2..]
19:42:59 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
19:43:02 <Axman6> so, what about something that checks is a number is even, if it is, return 0 else return 1?
19:43:26 <Axman6> or, as ion showed, compute the remainder
19:43:36 <kmc> > cycle [0,1]
19:43:37 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
19:43:42 <mike-burns> Hah.
19:43:51 <int80_h> cheater!
19:43:54 <Axman6> > [maxBound - 2..] :: [Int]
19:43:55 <lambdabot>   [9223372036854775805,9223372036854775806,9223372036854775807]
19:43:55 <ion> > map (cycle [0,1] !!) [2..]
19:43:55 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
19:43:56 <kmc> > map (cycle [0,1] !!) [2,3,4]  -- don't do this
19:43:56 <lambdabot>   [0,1,0]
19:43:57 <kmc> hehe
19:43:59 <JoeyA> tactics: You could traverse the expression, pushing the parameter when you enter a lambda and popping it when you leave.
19:44:12 <Axman6> XD
19:44:31 <JoeyA> To get the DeBruijn index, just walk up the stack and count how many links it takes to get to the variable.
19:45:01 <JoeyA> It corresponds to the number of links you'd traverse if you implemented a lambda expression interpreter using cactus stacks.
19:45:15 <JoeyA> If all that was complete nonsense, I apologize.
19:45:24 <JoeyA> I had a bike accident a year ago.
19:45:54 <tactics> JoeyA: I'm trying to do substitution in D.B. terms. Not to convert them. Just to be clear.
19:46:21 <JoeyA> oh
19:47:07 <JoeyA> So you already have the terms, and are trying to implement expression application?
19:47:11 <punkk> when I write the code...I do what? Parities x...then what?
19:47:11 <JoeyA> (err, have the indices)
19:47:31 <punkk> where does map (`mod` 2...) go?
19:47:52 <kmc> punkk, what book are you using to learn Haskell?
19:48:01 <tactics> JoeyA: yeah.
19:48:18 <tactics> JoeyA: I did it the other day for a STLC I wrote. But I just copied the definition from the book directly.
19:48:23 <tactics> I don't really have an intuition on how it works
19:48:24 <tactics> >___>
19:48:38 <cadabra> I'm profiling my program, and it looks like 95% of my time is spent in (x `isInfixOf` str). Does that include building str, or would that appear in another cost centre?
19:48:57 <kmc> that's not surprising, because isInfixOf uses a dumb string search algorithm
19:49:00 <kmc> @src isInfixOf
19:49:00 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
19:49:21 <monochrom> I forgot the direction of de Bruijn indexing. please remind me. (\x y. x (\z. x z)) what does this become?
19:49:48 <kmc> λ → λ → 1 (λ → 2 0)
19:49:50 <kmc> i think
19:49:57 <cadabra> I can imagine that isInfixOf isn't fast, but before I go about replacing it, I need to know if what's actually slow is building the string..
19:50:11 <kmc> yeah, i think it would include
19:50:13 <kmc> not positive
19:50:16 <JoeyA> tactics: If you're simply interested in implementing a lambda expression evaluator (which I might recommend, for the sake of "getting it"), application is simply pushing a value to the stack (implemented as an *immutable* list) and calling the function.
19:50:36 <JoeyA> err, evaluating the lambda's inner expression.
19:50:41 <kmc> monochrom, innermost lambda is 0, i think
19:51:02 <tactics> JoeyA: What I'm trying to do is write a nameless dependently typed lambda calculus
19:51:59 <JoeyA> Sounds fun
19:52:31 <tactics> So I could have terms like Forall *. 0 (which would be the type of List)
19:52:38 <tactics> :kind []
19:52:39 <monochrom> ok, so suppose I do application (\x. \y. x (\z. x z)) (\v. v) which is (\. \. 1 (\. 2 0)) (\. 0), what do I get?
19:52:49 <tactics> @kind []
19:52:50 <lambdabot> * -> *
19:53:05 <tactics> (err something like that)
19:53:13 <monochrom> the human form will be (\y. (\v.v) (\z. (\v.v) z))
19:53:43 <tactics> Forall *. 0 would be the type of the identity function on types actually
19:54:44 <tactics> or... I don't know. Thus, I want to write a program so I can learn :)
19:55:12 <monochrom> the de Bruijn form will be (\. (\. 0) (\. (\. 0) 0))
19:55:21 * hackagebot spool 0.1 - Convert between ByteString and Vector.Storable without copying  http://hackage.haskell.org/package/spool-0.1 (KeeganMcAllister)
19:55:44 <wavewave> I hope haddock has a search functionality inside a package.
19:56:04 <monochrom> ok, so first of all, you just plug the parameter into the function body, there is no renumbering inside the parameter
19:56:24 <incluye> Oh my god, there are actually things called "cactus stacks"
19:56:28 <incluye> I love CS
19:56:37 <JoeyA> a.k.a. "spaghetti stacks"
19:56:43 <wavewave> on the upper-right corner, we can put a small text input box in haddock documentation.
19:56:47 <incluye> or "saguaro stacks"
19:56:56 <monochrom> but you need to keep a count on how many lambda levels you're in, when you traverse the function body to find "where is x" for plugging in
19:57:32 <wavewave> navigating through index is very cumbersome.
19:57:56 <monochrom> and I think that's it. there is no renumbering in the rest of the function body either
19:58:56 <ksf> my oop lecturer always talked about clothing lines and cellars.
19:59:17 <ksf> "it's simple: you put something into your cellar, and can't access anything under that, any more"
20:00:10 <ksf> ...he also called C# "cee lattice fence"
20:00:28 <mm_freak_> wavewave: there is no search functionality in haddock, but you can install a local copy of one of the haskell search engines
20:00:37 <monochrom> so there was a time I was young and rebellious and I said "why is de Bruijn indexing in this direction? why not have the outermost lambda being 0?"  then I grew older and tried application and saw that de Bruijn was wise
20:00:52 <Axman6> i have a lecturer who referrs to C# as "C hash" :\
20:01:15 <monochrom> the opposite direction would require renumbering everything for every application
20:01:37 <ksf> well...
20:01:44 <ksf> > '♯' == '#"
20:01:45 <lambdabot>   <no location info>:
20:01:45 <lambdabot>      lexical error in string/character literal at chara...
20:01:49 <monochrom> and humans would be error-prone in coding up that delicate renumbering
20:02:07 <ksf> > '♯' == '#'
20:02:08 <lambdabot>   False
20:02:56 <monochrom> to be sure, there is a bit of work in parsing (\x. \y. x (\z. x z)) into (\. \. 1 (\. 2 0)), but that is much less error-prone (just a little bit)
20:03:00 <Eduard_Munteanu> > compare '♯' '#'
20:03:01 <lambdabot>   GT
20:07:36 <wavewave> mm_freak_ : I know. I am just suggesting such a functionality.
20:07:42 <monochrom> so the application algorithm goes like this: to apply (\. b) to e, call "plug 0 b".
20:08:16 <bfig> anyone around has programmed a neural network before?
20:08:34 <wavewave> mm_freak_ : since haddock already indexes function names, a simple javascript code may be enough for that function.
20:08:35 <copumpkin> kmc: I like hexquote!
20:08:45 <monochrom> in general, "plug n b" does this. plug n (\. b) = (\. plug (n+1) b)
20:08:56 <mm_freak_> bfig: see the 'instinct' library on hackage…  that's my implementation
20:09:05 <monochrom> plug n (c d) = ((plug n c) (plug n d))
20:09:36 <mm_freak_> wavewave: dunno, i guess, most people just go with the search engines
20:09:37 <monochrom> and finally plug n <variable number i> = if n==i then e else <variable number i again>
20:09:39 <bfig> mm_freak_, gonna check it out :). by the way, can i ask you a simple question?
20:10:24 <mm_freak_> bfig: ask
20:10:27 <monochrom> there is no renumbering. but you count the number of lambdas to recognize which variable is to be replaced by the parameter
20:10:57 <int80_h> :q
20:11:20 <bfig> i need to build one to understand backpropagation, and i'm trying to understand how the gradient descent works. (more coming...)
20:11:57 <wavewave> BTW, did anybody implement generic deriving of  SafeCopy from Data.Data instances?
20:13:38 <wavewave> probably.. deriveSafeCopy is okay... hmm.
20:16:05 <Peaker_> What is SafeCopy?
20:16:07 <bfig> say you have only three layers, input, hidden, output. single unit on input/output, N hidden. the computation should go like this when you have (x,y) training value (this is a question): singleinput x >>= hidden >>= output. let's assume for a second that what i wrote means 'compute the f in the first neuron, pass that to all the neurons in the hidden layer, compute the f in the hidden layer, get that ordered list of results and f
20:16:07 <bfig> eed that to the output layer, compute the output layer function
20:16:13 <eyebloom> Curious if anyone thinks that in the future all of Haskell syntax
20:16:34 <eyebloom> might be overloadable.
20:16:43 <tactics> cool, I think I got the damn debruijn substitution working
20:17:09 <tactics> Thanks to the helper function "incFree" which increments all free indexes in a term by 1 <3
20:17:13 <Peaker> cadabra: if you care about performance, why are you using [Char]?
20:17:37 <mm_freak_> bfig: i don't understand your question…  and note that my library does not work in the traditional way, where every neuron has an activation…  there is only a connection matrix and the activations are computed on the fly using lazy vectors
20:17:57 <bfig> mm_freak_, i haven't finished writing :p
20:18:03 <mm_freak_> ah, ok
20:18:09 <mm_freak_> hurry up, i'm about to go =)
20:18:17 <bfig> mm_freak_, i want to make sure i understand if this is the right process :). ok, i'll try to speed up
20:18:48 <bfig> once you have the approx output, say approx x, you find y-x, and apply the training rule backrecursively
20:18:56 <cadabra> Peaker: because I started simply, and figured I'd see what happens.
20:19:15 <wavewave> Peaker: http://acid-state.seize.it/safecopy
20:19:21 <Peaker> cadabra: String can make Haskell go slower than Python :)
20:19:26 <mm_freak_> bfig: usually not exactly y - x, but go on
20:19:34 <wavewave> Peaker: basically extension of Data.Serialize
20:19:43 <Peaker> In fact, each of the (few) benchmarks I saw of Haskell going slower than Python -- was due to Strings
20:19:44 <wavewave> with some version control..
20:20:06 <cadabra> I can believe it, but I figured IO would be my main concern here, I read and write a lot of files. Turns out it wasn't.
20:20:22 <wavewave> I haven't used its advanced version control stuff yet. It is needed for acid-state, so I am using it.
20:20:46 <joe6> what is the use of forall? is that not assumed in every case?
20:20:49 <bfig> that means for what i get, pick the output function and the place where you evaluated it, compute the derivative df := doutputf/dinput, then recompute the function as inputW_i = -df_i * learning * error
20:21:00 <wavewave> joe6: See ScopedTypeVariables
20:21:00 <bfig> mm_freak_, would that be correct?
20:21:31 <monochrom> the use of forall is when you want it appear at unassumed places, such as (forall s. ST s a) -> a
20:21:38 <Peaker> wavewave: I am not sure I understand what it's doing there -- do you have to keep around your type declarations of the old schema?
20:21:42 <bfig> modulo trapping the function in a certain domain (say, save the sigmoid from overflowing the constants)
20:21:50 <cadabra> Well, I brought in the stringsearch and used B.pack src and B.pack pattern without swapping out for ByteString:s everywhere, and runtime went down from 2 s to 0.5 s.
20:21:51 <wavewave> joe6: sometimes, explicit forall is needed for type variable with local scope .
20:22:18 <Peaker> cadabra: if you get rid of String and replace it with Text or ByteString I'm speculating that you'll see a big reduction
20:22:19 <bfig> sorry, inputW_i = inputW_i - df_i *learning * error
20:22:29 <Peaker> cadabra: (additional one)
20:23:22 <mm_freak_> bfig: the learning rule adjusts only the weights, not any activations…  in fact activations should be a runtime feature
20:23:37 <joe6> wavewave: ok, thanks.
20:24:01 <mm_freak_> bfig: http://hackage.haskell.org/packages/archive/instinct/0.1.0/doc/html/src/AI-Instinct-Train-Delta.html#learnPat ⇐ see the 'delta' vector, which models the error function
20:24:12 <mm_freak_> bfig: and see how it is used in the main formula
20:24:23 <bfig> ok, gonna check it out. thanks :)
20:24:24 <mm_freak_> cmMap just maps a function over the connection matrix
20:24:44 <wavewave> Peaker: I do not know much about it yet. Probably you need both old schema and new schema only you do migration.
20:25:10 <joe6> what is the difference between (forall a. Show a) => a -> String vs (Show a) => a -> String?
20:25:18 <joe6> aren't they both the same?
20:25:27 <joe6> isn't forall redundant here?
20:25:30 <kmc> yes
20:25:35 <kmc> (except i think you put it in the wrong place)
20:25:40 <kmc> but there are other types you can only write with explicit forall
20:25:43 <mm_freak_> joe6: the first one is invalid, but when you put it out of the parentheses it's redundant
20:25:44 <kmc> (forall s. ST s a) -> a
20:25:45 <monochrom> I don't think (forall a. Show a) => blah is valid
20:25:58 <mm_freak_> joe6: however, if that one is used in a type synonym, then it's not redundant anymore
20:25:59 <kmc> the forall syntax is a GHC extension, and is used by several other extensions
20:26:15 <wavewave> Peaker: then you can use only new schema but later you can come back to old schema since safecopy has a version..
20:26:16 <kmc> ExistentialQuantification, ScopedTypeVariables, PolymorphicComponents, Rank{2,N}Types
20:26:24 <kmc> it has a different meaning in each case
20:26:37 <wavewave> that's my guess. ..
20:26:38 <kmc> :t runST
20:26:39 <lambdabot> forall a. (forall s. ST s a) -> a
20:27:13 <Peaker> kmc: you could say it has the same meaning in all, just different consequences
20:27:22 <monochrom> eek
20:27:27 <kmc> joe6, (forall a.  S a -> T) is a function which promises to be polymorphic over argument types, but ((forall a. S a) -> T) is a function which *demands* an argument which is itself polymorphic
20:27:27 <dolio> It has the same meaning in all of those cases.
20:27:40 <kmc> and the latter isn't in standard Haskell
20:27:57 <mm_freak_> bfig: note that my library takes a pure approach to neural networks, hence it has a slightly different concept of neuron activations based on lazy vectors…  see how the 'activation' function works, then the rest should be fairly clear
20:28:01 <dolio> Unless you count the fact that its use in existential quantification is confusing.
20:28:14 <punkk> working through a problem--stuck. With function Parity :: [Int] -> [Int], trying to get it to work so that Parity [1,2,3,0] = [1,0,1,0]--I have no idea how to write this and I'm new to haskell
20:28:22 <Peaker> dolio: I think it's confusing enough that the paper "From Lists to Streams to Nothing at all" got it wrong :)
20:28:29 <joe6> this is a typeclass that I have: http://codepad.org/V4CnL2aR, and I have this function: g (T x) = get x
20:28:29 <kmc> punkk, what book are you using to learn Haskell?
20:28:45 <punkk> not using one
20:28:47 <joe6> the type inference tells me that the type is: g :: forall a. T -> IO (UsedType a)
20:28:52 <joe6> data T = forall a. (CGlobal a) => T a
20:28:53 <kmc> punkk, you should probably read a book, then
20:28:55 <kmc> @where LYAH
20:28:55 <lambdabot> http://www.learnyouahaskell.com/
20:28:56 <bfig> mm_freak_, are you using arrows or that stateful trickery? :p
20:28:56 <kmc> @where RWH
20:28:56 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
20:28:58 <kmc> both are free online
20:29:04 <Axman6> punkk: didn't we already tell you how to get the answer several different ways?
20:29:06 <wavewave> basically :: a -> XXX is implcitly (forall a. a -> XXX )   with parenthesis outer most.
20:29:10 <mm_freak_> bfig: just lazy vectors
20:29:11 <bfig> *arrowLoop :D
20:29:35 <Axman6> > let parity = map (\x -> if even x then 0 else 1) in parity [1,2,3,0]
20:29:36 <joe6> and I am trying to figure out what the use of "forall a." in the type signature is.
20:29:36 <lambdabot>   [1,0,1,0]
20:29:53 <Axman6> > let parity = map (\x -> mod x 2) in parity [1,2,3,0]
20:29:54 <lambdabot>   [1,0,1,0]
20:29:56 <joe6> g :: T -> IO (UsedType a)
20:29:59 <joe6> is wrong.
20:30:12 <mm_freak_> bfig: even though i fell in love with arrows i'm importing Control.Arrow only for the function arrow in this case =)
20:30:14 <kmc> joe6, forall isn't always necessary.  sometimes it's redundant
20:30:23 <kmc> joe6, you know it's not necessary because standard Haskell doesn't have it at all
20:30:30 <Peaker> damn, "From lists to streams .." was a free PDF, now it's behind a paywall
20:30:34 <bfig> :)
20:30:40 <joe6> it appears to have different meanings depending on the context, too.
20:30:45 <kmc> in standard Haskell, all type variables are implicitly quantified at the outermost level
20:30:46 <wavewave> forall that appear with parenthesis has different 'existential' meaning as in logics.
20:30:56 <bfig> Peaker, is that the one about bytestrings?
20:31:02 <Axman6> Peaker: is that Don Stewart's paper?
20:31:17 <kmc> it's about stream fusion
20:31:26 <Peaker> Axman6: I don't remember. IIRC dcoutts was on it
20:31:37 <Peaker> Axman6: I think dons wasn't on it but I'm not sure
20:31:53 <punkk> Axman6, I'm trying to create a function not limited to [1,2,3,4]
20:32:10 <Axman6> punkk: what should it be able to take?
20:32:26 <joe6> the type inference warns me that this is the type signature, g :: forall a. T -> IO (UsedType a)
20:32:36 <wavewave> If you have f :: a -> (b -> b) -> c, depending on where you use the function f, the second argument (b->b) can be Int->Int, or Double -> Double
20:32:36 <joe6> but, when I use that type signature, it does not work.
20:32:42 <kmc> you're sure? what error do you get?
20:33:04 <kmc> joe6, are you using the type variable 'a' in another signature in the defininion of g?
20:33:13 <Axman6> Peaker: http://donsbot.wordpress.com/papers/ under Papers
20:33:19 <punkk> Axman6: Should be able to take whatever I put into it--should work for [1,2,3] or [4,5,6]
20:33:22 <wavewave> because type variable b is visible in signature. b will be bound in context.
20:33:26 <Axman6> punkk: it does
20:33:43 <wavewave> but if you have f :: a -> (forall b. b-> b) ->c ...
20:33:47 <Peaker> "Stream Fusion: From Lists to Streams to Nothing at All, by Duncan Coutts, Roman Leshchinskiy and Don Stwwart, ICFP 2007."
20:33:52 <Peaker> Axman6: I was wrong, dons was on it
20:33:53 <Axman6> > let parity = map (`mod` 2) in (parity [1,2,3], parity [4,6,4,2,5,455])
20:33:53 <lambdabot>   ([1,0,1],[0,0,0,0,1,1])
20:34:06 <bfig> Peaker, :)
20:34:07 <wavewave> then now b is not viewable outside.... that means...
20:34:11 <bfig> Peaker, got the link?
20:34:18 <Peaker> nope, disconnected
20:34:36 <wavewave> in the second argument, a function which satisfy (forall b. b->b) must come.
20:34:49 <wavewave> there is only one function satisfying this..
20:34:57 <wavewave> that's id :: forall b. b -> b
20:35:12 <joe6> function: http://codepad.org/bhki4E5F, error: http://codepad.org/6SktvYky, without the type signature: http://codepad.org/Y9svZwCf
20:35:18 <wavewave> as I said id :: b -> b means id :: (forall b. b -> b)
20:35:52 <ion> :t id
20:35:53 <lambdabot> forall a. a -> a
20:35:54 <Axman6> @tell dons All your papers that used to be available at http://www.cse.unsw.edu.au/%7Edons/papers/ are no longer accessible. Any chance you could reupload them somewhere, and fix the links on http://donsbot.wordpress.com/papers/ ?
20:35:54 <lambdabot> Consider it noted.
20:36:19 <monochrom> joe6, is this code you wrote and you know why you wrote it this way, or is it random stranger's code?
20:36:21 <wavewave> so forall together with parenthesis is sensible.
20:36:32 <joe6> wavewave, it is my code.
20:36:41 <punkk> damn I'm a noob...thanks Axman6--its always easier than I'm thinking
20:36:46 <Peaker> in the paper, they write:   "data Stream a = ∃s. Stream (s → Step a s) s"
20:36:48 <monochrom> could you say why you wrote this way?
20:36:55 <joe6> wavewave, I have a list of types that I am trying to construct a heterogenous list
20:36:59 <Axman6> Peaker: http://web.archive.org/web/20110607033251/http://www.cse.unsw.edu.au/~dons/papers/stream-fusion.pdf
20:37:04 <dolio> Yes, that's incorrect.
20:37:05 <bfig> i've never realized, all the papers i've been reading about haskell and monads and all functional paraphernalia are written by people i've been talking to, in this channel :p
20:37:06 <joe6> as in uri: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
20:37:13 <wavewave> joe6: you are using Existential type.
20:37:24 <Peaker> Axman6: thanks
20:37:30 <bfig> haskellers are awesome :)
20:37:36 <monochrom> what is "get"?
20:37:37 <kmc> bfig, some of them are here, yeah
20:37:40 <joe6> wavewave, yes this is my data T = forall a. (CGlobal a) => T a
20:38:00 <joe6> and the CGlobal typeclass implements get
20:38:17 <Peaker> bfig: SPJ/marlow are never here apparently.. maybe they never procrastinate :)
20:38:18 <monochrom> what is the type of "get"?
20:38:23 <joe6> get :: CGlobal cGlobalValue =>  cGlobalValue -> IO (UsedType cGlobalValue)
20:38:23 <bfig> lol
20:38:25 <kmc> marlow is in #ghc often
20:38:28 <kmc> JaffaCake
20:38:33 <Peaker> kmc: ah, cool
20:38:37 <bfig> that streamfusion paper is pretty cool :)
20:38:44 <kmc> it's true though, that time spent in #haskell inversely correlates with time spent coding in Haskell
20:38:46 <Peaker> bfig: yeah, I loved it
20:38:56 <joe6> and, i am trying to come up with a function that I can use to map get over a list of types
20:39:01 <bfig> just a bit =)
20:39:05 <joe6> and, i am trying to come up with a function that I can use to map "get" over a list of types
20:39:10 <joe6> g (T x) = get x
20:39:14 <joe6> like this
20:39:19 <monochrom> that leaks the type hidden by the existential type. you are not supposed to do it
20:39:19 <Peaker> bfig: it strengthens my idea that existential quantifications are a performance thing :)
20:39:22 <bfig> i really like haskell as a programming language, i just need more experience. it seems you can never get enough experience :)
20:39:31 <kmc> bfig, you can
20:39:34 <kmc> it does take a while
20:39:37 <joe6> it works without a type signature. I am trying to understand the type signature.
20:39:58 <wavewave> joe6: okay.. I modified your code a little bit.
20:40:08 <parcs> in http://www.haskell.org/pipermail/haskell-prime/2011-June/003423.html, the author says that a type equality predicate is possible through fundeps. however, the code he provides won't compile fundeps conflicts, even with OverlappingInstances
20:40:13 <parcs> what am i missing?
20:40:24 <joe6> wavewave, do you mind posting the link?
20:40:39 <hpaste> wavewave pasted “forall” at http://hpaste.org/51358
20:41:02 <wavewave> I am now compiling it.
20:41:31 <rwbarton> parcs, the rest of that thread has relevant information, but the short answer is you need to change the second instance to "instance (r ~ False) => Eq j k r"
20:41:49 <joe6> wavewave, what did you change?
20:41:57 <hpaste> wavewave annotated “forall” with “forall (annotation)” at http://hpaste.org/51358#a51359
20:41:59 <monochrom> "get"'s type is changed
20:42:42 <joe6> this is the CGlobal class: http://codepad.org/j0oaoNpM
20:42:43 <monochrom> why are there so many spaces after each line?
20:42:52 <parcs> rwbarton: that's strange.. thanks
20:44:57 <joe6> monochrom: the example has this: foo (MkT x) = ... -- what is the type of x?
20:45:07 <joe6> As we've just stated, x could be of any type. That means it's a member of some arbitrary type, so has the type x :: exists a. a. In other words, our declaration for T is isomorphic to the following one:
20:45:21 <joe6> is that not a working example, here: uri: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
20:45:33 <joe6> about heterogenous lists
20:46:33 <joe6> oh, i think i get it now. get has different types.
20:47:17 <wavewave> joe6: mm, I am sorry. I made a mistake in type signature of your 'get'
20:47:32 <monochrom> in fact, I tried both 6.12.3 and 7.0.2, "g (T x) = get x" without type sig still does not compile
20:47:51 <joe6> wavewave, no need to apologize. you were trying to help.
20:48:07 <joe6> i am on 7.0.4, i think
20:48:18 <joe6> The Glorious Glasgow Haskell Compilation System, version 7.0.4
20:48:44 <monochrom> well, what is the inferred type of g then?
20:48:52 <hpaste> wavewave annotated “forall” with “forall (annotation) (annotation)” at http://hpaste.org/51358#a51360
20:49:16 <monochrom> also still doesn't compile in 7.2.1
20:49:27 <wavewave> joe6: the last one is the same error as you get now?
20:49:35 <joe6> monochrom: http://codepad.org/IJOzjhov
20:50:02 <monochrom> I wouldn't trust that as inferred type
20:50:16 <joe6> monochrom: that is what I am realizing
20:50:19 <monochrom> I only trust loading into ghci and getting an answer from ":type g"
20:50:24 <joe6> the type inference is not correct all the time.
20:50:45 <joe6> *State Foreign.Storable CGlobal Bindings.SnsrUsb.Usb_H Text.Printf Data.Typeable> :t g
20:50:47 <wavewave> joe6: anyway.. this is illigal in its meaning.
20:50:48 <joe6> g :: T -> IO (UsedType a)
20:51:05 <joe6> wavewave, yes, that is what I am realizing too.
20:51:08 <wavewave> basically you are now getting a type out of existential type.
20:51:09 <joe6> g (T x) = return . T $ get x
20:51:16 <wavewave> joe6: that's impossible.
20:51:36 <joe6> should probably be something like that. get it out of T, get the value, put it back in T.
20:51:48 <wavewave> from T, you try to get a which is inside (T a)
20:51:57 <monochrom> yes, you have to hide the type or get rid of it
20:52:38 <wavewave> there is no way to get a type from existential type. that's why ST monad is safe for example.
20:53:04 <JoeyA> tactics: A 22-line lambda expression evaluator: http://codepad.org/AePdpD70
20:53:10 <JoeyA> It steals laziness from Haskell.
20:54:00 <JoeyA> (the whole program is 73 lines)
20:54:05 <wavewave> In existential type, only by pattern matching, you can do some type-dependent job inside an inner function, but outer signature should not see the type.
20:54:15 <JoeyA> I did that in about 600 lines in C several months ago.
20:54:36 <joe6> wavewave: oh, ok. thanks.
20:54:42 <joe6> it makes sense.
20:54:44 <JoeyA> It's dynamically typed, though.
20:55:04 <wavewave> joe6: so if you want to do some work with x in T x..
20:55:33 <wavewave> so if there is a function,  action :: (CGlobal a) => a -> IO ()
20:55:46 <JoeyA> The basic idea is: to evaluate a variable (encoded as a De Bruijn index), take the nth value from the stack.  to apply an argument to a closure, push an argument to the closure's stack, and evaluate the closure's expression.
20:56:22 <wavewave> joe6: let me modify your function g
20:57:57 <joe6> data T = forall a. (CGlobal a) => T a
20:57:57 <joe6> data R = forall a. (CGlobal a, (UsedType a) b) => R b
20:58:12 <joe6> R is into dependent type territory, correct?
20:58:41 <hpaste> wavewave annotated “forall” with “forall (annotation) (annotation) (annotation)” at http://hpaste.org/51358#a51361
20:58:50 <joe6> where (CGlobal a) => UsedType a :: *
20:59:42 <wavewave> joe6: now you need forall .
20:59:45 <joe6> if you do not mind me asking, is this easier/doable in agda?
20:59:54 <joe6> wavewave, thanks.
21:00:25 <wavewave> joe6: actually this is independent of dependent types.
21:00:28 <punkk> may i summon your assistance again?
21:00:31 <joe6> i mean things like this, where the types are more dynamic
21:00:40 <wavewave> joe6: but of course, it's related.
21:01:00 <wavewave> joe6: to implement dependent types in haskell easily, you need GADTs
21:01:13 <wavewave> let me show you something.
21:01:25 <joe6> wavewave, shouldn't i be using gadt's then, instead of existential types?
21:01:28 <punkk> with function Member :: Int -> [Int] -> Bool, I'm trying to create a function to work as such: Member 1 [1,2,3] = True, and Member 1 [2,3,4] = False
21:01:34 <joe6> is it a wrong design choice?
21:01:38 <wavewave> joe6: actually you need both.
21:01:43 <joe6> on my part?
21:01:54 <dobblego> punkk: you cannot have the name Member for a function, since it starts with a capital letter
21:01:55 <wavewave> for implementing what you want.
21:02:19 <wavewave> you want to have some existential type to implement some "virtual" method.
21:02:20 <punkk> *member
21:02:35 <wavewave> but sometimes you want to have downcasting.
21:02:52 <wavewave> joe6: that's what you want right now. isn't it?
21:03:02 <dobblego> punkk: also, are you trying to implement this as an exercise? if not, the function already exists in the library (called elem)
21:03:14 <joe6> wavewave, i do not know what downcasting is.
21:03:26 <wavewave> I mean you want to see inside T..
21:03:32 <wavewave> that's downcasting in fact.
21:03:56 <wavewave> T is a collection of all (CGlobal )
21:04:01 <joe6> i have a list of types, i want to map a function over that list, the function returns a different type for each item again.
21:04:10 <joe6> wavewave, yes, i want to see inside T.
21:04:22 <wavewave> that's downcasting..
21:04:34 <rwbarton> what's the question here? when I remove the type signature in the original code and ask for ":t g", I get g :: (CGlobal a) => T -> IO (UsedType a), which seems right to me...
21:05:01 <joe6> rwbarton: but, using that type signature in the .hs file does not work.
21:05:07 <joe6> it gives a compile error.
21:05:26 <Cale> punkk: What trouble are you having?
21:05:26 <rwbarton> yes it does, note this is not the same signature you gave!
21:05:29 <punkk> ohhh, thank you
21:05:29 <wavewave> Seeing inside existential type is not allowed by type system. and actually not safe.
21:05:37 <rwbarton> there is a (CGlobal a) context
21:05:42 <Cale> oh
21:05:43 <punkk> I didnt know elem existed
21:05:50 <punkk> was trying to create from scratch
21:06:09 <Cale> It's a good little exercise to be able to write that from scratch too :)
21:06:13 <rwbarton> (in case it matters I'm using 6.12.1)
21:06:31 <Cale> It can be written in terms of 'all' really nicely, or recursively in terms of == and ||
21:06:32 <wavewave> but you know this T has only case A, B and C.
21:06:34 <cadabra> I have a lot of code like data A... data B... data C.... data Foo = FooA A | FooB B | FooC C. Is there some way to get rid of the dummy Foo[ABC] ctors?
21:06:42 <Cale> er, 'any' rather
21:06:47 <joe6> rwbarton: this is the type signature ghci gave and the error when I use that type signature: http://codepad.org/UO6lMLrD
21:07:10 <wavewave> If I write down all the cases of functions for type A, type B, type C... then it's safe.
21:07:13 <Cale> :t any
21:07:14 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
21:07:25 <Cale> > any (== 7) [1..10]
21:07:26 <lambdabot>   True
21:07:30 <Cale> > any (== 12) [1..10]
21:07:31 <lambdabot>   False
21:07:33 <rwbarton> pretty sure, as monochrom said, ghc is just failing to display the context in that warning
21:07:34 <joe6> wavewave, i understand what you are saying and it makes sense.
21:07:52 <wavewave> now for that case, we have GADTs.
21:08:05 <rwbarton> try defining "g x = x + 1" and see what it has to say about that
21:08:36 <wavewave> GADT type has a polymorphic parameter a, so it's seemingly arbitrary.
21:08:45 <joe6> wavewave, just curious of how to solve something like that. GADTs? Any urls that you would recommend?
21:09:15 <joe6> wavewave, yes, gadt's make sense. let me read up on it.
21:09:27 <wavewave> but in it's definition, it has a finite number of cases.. type variable a is actually closed in certain cases only.
21:09:47 <joe6> wavewave, so I would have to define all the different types.
21:09:50 <joe6> ?
21:09:51 <Cale> cadabra: That usually takes a bit closer inspection of what you're trying to do with the types...
21:10:16 <Cale> cadabra: Like, do you really want the types A, B, C to be separate?
21:10:42 <rwbarton> joe6: do you have some extra code in your file such as an instance for CGlobal a?
21:10:54 <rwbarton> as there is no line 28 in the hpaste
21:11:02 <joe6> rwbarton, sure, give me one second and I will post it.
21:12:05 <cadabra> Well, consider this. C++ has a number of possible top-level constructs, one of which is a function. So you create data CXXTopLevel = CXXFunction ... | CXXClass ...; Now what happens when you need to reuse function in the CXXClass body?
21:12:39 <cadabra> Cale: ^^
21:13:12 <joe6> CGlobal.hs: http://codepad.org/WdyUfUnC, instance of CGlobal: http://codepad.org/Wr0uLLGO, I have a list of such types that I want to map with a "get" to get their values.
21:13:18 <Cale> cadabra: ah, okay
21:14:00 <joe6> rwbarton: this is the file that I am compiling:
21:14:06 <wavewave> joe6: I'm making an example.. wait a minute.
21:14:08 <cadabra> So I end up extracting a bunch of stuff into data CXXFunction = CXXFunction..., and then doing things like data CXXTopLevel = CXXTLF CXXFunction, etc. My pattern matches get really ugly.
21:14:21 <joe6> rwbarton: http://codepad.org/ChLg6CFv
21:15:01 <joe6> wavewave: ok, cool. thanks. I can just hardcode the types, but it would be cool to just have a list of types and work on that list.
21:16:25 <Cale> cadabra: another option is to just enforce less of the syntax at the type level, but I guess that kinda sucks to give up
21:16:50 <rwbarton> oh UsedType is a type function!
21:16:54 <rwbarton> that changes everything
21:17:02 <joe6> rwbarton: yes.
21:17:25 <Cale> cadabra: Perhaps you can capture a general declaration of some sort? C++'s syntax seems really messy, and I'm not quite sure how it looks from a formal standpoint.
21:18:10 <tactics> DeBruijn doesn't play as nicely with dependent types
21:18:37 <hpaste> wavewave annotated “forall” with “forall (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/51358#a51362
21:19:27 <wavewave> okay it compiled.
21:19:52 <rwbarton> well, also the CGlobal class is rather different here
21:20:06 <wavewave> now assume CGlobal has only A B and C types
21:20:52 <wavewave> then I define a GADT for it.
21:20:52 <joe6> wavewave: i have a hundred such types. I could write/autogenerate the functions. or, I could autogenerate a big do statement.
21:21:14 <joe6> what about something like this: http://codepad.org/CP7DAAb8
21:21:15 <wavewave> joe6: normally, this kind of type hackery is not needed.
21:22:47 <rwbarton> this forall a. R a is useless anyways, may as well return IO ()
21:22:47 <punkk> Last time. Trying to creating a function countdown :: Int -> Int where countdown 4 yields [4,3,2,1], or countdown 3 yields [3,2,1]--I have absolutely no idea where to begin
21:22:47 <wavewave> just use existential type and send a function of type (forall a. a -> whatever) is doing what we usually want.
21:22:47 <Cale> punkk: You mean countdown :: Int -> [Int]
21:22:56 <Cale> punkk: Well, start with countdown 0
21:23:03 <Cale> what should it produce?
21:26:20 <punkk> it should yield a []
21:26:20 <Cale> right, so
21:26:20 <Cale> countdown 0 = []
21:26:20 <wavewave> but if you need 'downcasting'.... some specific function for a certain type and have some safety guarantee from type system.
21:26:20 <wavewave> You can use this GADT technique.
21:26:20 <joe6> wavewave: rwbarton: http://codepad.org/TsUZFVch, http://codepad.org/o39ITdJV
21:26:20 <Cale> and now for positive n, can we write what countdown n should be in terms of countdown (n-1)?
21:26:20 <rwbarton> you cannot get any information out of a value of type R though
21:26:20 <punkk> I've gotten up to there
21:26:20 <wavewave> joe6: that's basically upcasting
21:26:20 <wavewave> smaller type to bigger type is always okay.
21:26:20 <wavewave> smaller/bigger in a sense of Set
21:26:20 <monochrom> there is something wrong with "return . R $ get x". shouldn't it be "R <$> get x" or use fmap or use liftM. similarly "return . T $ get x"
21:26:24 <rwbarton> the real question is why do you want to put these things into a list, when they have different types
21:26:41 <punkk> dont know how to write it out
21:27:01 <joe6> rwbarton: hetero list: uri: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
21:27:14 <rwbarton> yes, I know
21:27:17 <rwbarton> but why a list here
21:27:20 <punkk> i have: | x == 0 = []            | otherwise = ??
21:27:36 <Cale> You can even write the line of code I wrote
21:27:40 <Cale> countdown 0 = []
21:27:52 <Cale> countdown n | n > 0 = ...
21:27:58 <monochrom> countdown n = n : countdown (n-1)
21:28:21 <wavewave> joe6: so in fact you don't need to make R.
21:28:23 <monochrom> because you want countdown 4 = 4 : countdown 3 = ... = 4:3:2:1:[]
21:28:42 <monochrom> actually s/.../by induction/
21:28:45 <rwbarton> joe6: what I mean is, what do you plan to do with this list
21:29:03 <wavewave> if you define data R = forall a. MkR a
21:29:26 <wavewave> (to distinguish, I change Type constructor to MkR )
21:29:46 <wavewave> MkR :: forall a. a  -> R
21:29:48 <joe6> rwbarton: i have a bunch of C functions that I want to test and see how they change the state. Each C Global variable, I have implemented it with a type. and added some wrapper functions to peek/poke their values
21:30:08 <wavewave> If you want to use some function f :: R -> XXX
21:30:19 <joe6> now, i want to write a wrapper function over the c functions, that will get the values of each type before and compare with after
21:30:25 <joe6> and show me the differences.
21:30:36 <m3ga> in one of SPJ's presentations, he has a slide which plots purity against some other variable and contrasts haskell against "everyone else". is that familiar to anyone? link?
21:30:37 <rwbarton> ah
21:31:13 <joe6> and, this list of types is around 100. I could generate a big do statement, read each value and then run the function and then read each value again and compare them.
21:31:20 <wavewave> it's nothing but using (f. MkR) :: forall a. a -> XXX
21:31:35 <punkk> thanks!
21:31:38 <joe6> instead, I am hoping to just generate the list of types and let some haskell magic do the rest.
21:31:44 <wavewave> so just use k :: forall a . a -> XXX
21:31:53 <Peaker> m3ga: the one with an arrow of Envy? Where Haskell envies the power of the unsafe languages?
21:31:59 <joe6> wavewave, ok. thanks. I understand what you are saying. let me try it out.
21:32:17 <m3ga> Peaker: yeah, i think thats it
21:32:44 <wavewave> joe6: you're welcome. Existential type is not so magical. It just makes sense once you get it.
21:33:52 <rwbarton> joe6: I would use something like data R = forall t. R (IO t, t -> IO ())
21:34:16 <rwbarton> where the first action is run before you test your C function, and the result it returns is passed to the second action
21:34:49 <Peaker> m3ga: http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-tutorial/TasteOfHaskell.pdf <-- this one has Envy in it
21:34:50 <kmc> m3ga, i've seen it.  i think it was in "a taste of haskell" among others
21:34:59 <joe6> rwbarton, yup that is what I am trying to get to.
21:35:02 <kmc> m3ga, as i recall the axes were "safe" and "useful"
21:35:18 <kmc> idea being that Haskell started out safe & useless, and became more useful as people hacked at it
21:35:31 <kmc> while other languages start unsafe & useful, and safety is added by ad-hoc means
21:35:59 * monochrom equates "hack" and "ad-hoc"
21:36:18 <kmc> if you like
21:36:35 <kmc> maybe the claim is just "better to be useful by ad-hoc means than safe by ad-hoc means"
21:36:43 <kmc> shrug
21:37:16 <Peaker> kmc: I don't think it mentioned ad-hoc means.. It doesn't even seem to try to claim which approach is better
21:37:24 <m3ga> kmc: yeah, safe and useful
21:37:25 <Peaker> but it does say "Haskell's contribution is taking purity seriously"
21:37:29 <kmc> yeah
21:37:39 <Peaker> so basically it's saying both approaches are good, and it is good to have Haskell explore the other approach
21:37:54 <kmc> this also explains the unusual adoption curve of Haskell
21:38:04 <kmc> useful languages will attract a lot of people from the beginning
21:38:20 <kmc> while a useless, safe language will only gradually attract people and thereby become more useful
21:38:26 <rwbarton> joe6: or you can simplify and write something like testAction :: [T] -> IO () -> IO () ; testAction [] a = a; testAction (T x : xs) a = do { r <- get x; testAction xs a; r' <- get x; when (r /= r') $ ... }
21:38:27 <Peaker> when was the contemporary IO solution devised? (As opposed to earlier conversation types)
21:38:35 <monochrom> I don't find haskell ad-hoc useful. ad-hoc efficient, sure.
21:38:46 <kmc> Peaker, I don't know... before 1998, anyway
21:39:09 <Peaker> Well, since then, Haskell has been just as useful, though it does put that usefulness behind a higher learning barrier
21:39:11 <joe6> rwbartan, that is smart. thanks.
21:39:12 <shachaf> It's indeed in _A Taste of Haskell_.
21:39:16 <Peaker> (just as useful&dangerous)
21:39:35 <joe6> rwbarton, really cool. Thanks.
21:39:48 <kmc> Peaker, i don't see that as the one usefulness barrier...
21:40:11 <Peaker> kmc: why not?
21:40:16 <kmc> usefulness includes a lot of practical things like "can I manipulate a reasonable-sized binary file without running out of memory" and "can i get libraries for diverse tasks" and "can i find people to work with"
21:40:19 <hpaste> ksf pasted “vimmode cabal "integration"” at http://hpaste.org/51363
21:40:32 <kmc> you're saying that Haskell 98 contains the theoretical fundamental ground-work to be a useful language, and I agree there
21:41:10 <Peaker> kmc: ah, I don't think that's the kind of useful alluded to in Taste of Haskell though
21:41:16 <Peaker> but maybe it is, I'm not sure
21:41:18 <kmc> shrug
21:41:31 <kmc> i'm not talking about the presentation still
21:44:00 <Peaker> In that sense, though, Haskell is really two languages, and the useful&dangerous one is not a very interesting one..
21:45:52 <m3ga> Peaker: thanks that was the one i as after. page 110 and on.
21:46:04 <ksf> I find disciple more interesting when it comes to useful&"dangerous"
21:46:39 <ksf> ...where unsafePerformIO and IORefs don't constitute unsafeCoerce
21:46:59 <Axman6> how do you use those two to make unsafeCoerce?
21:47:22 <ksf> it's in the docs to unsafePerformIO
21:47:35 <Axman6> huh, i'll have to check that out =)
21:47:52 <dobblego> also, Erik Meijer showed it in the keynote at the YOW conference 2008
21:48:00 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-IO-Unsafe.html#v:unsafePerformIO
21:48:27 <Axman6> how does that typecheck... o.O
21:48:48 <ksf> [a]
21:49:00 <ksf> ...and the ref stays polymorphic no matter what.
21:49:16 <Axman6> huh. there's no need for a forall there then?
21:49:18 <Axman6> how odd
21:53:29 <wavewave> I am reading that unsafePerformIO document.. it's really odd.
21:53:44 <Axman6> indeed
21:53:50 <Axman6> it doesn
21:53:57 <Axman6> doesn't look like that should work*
21:54:56 <joe6> rwbarton: this is how I ended up using it: http://codepad.org/BJN9Dx4b
21:56:11 <rwbarton> joe6, neat
22:04:22 <applicative> rwbarton, none of the monadic actions depends on the others, why not applicativize -- http://codepad.org/NFFmo6fJ  :)
22:04:32 <applicative> joe6 rather
22:05:36 <joe6> applicative: applicative confuses the code. I find it hard to read.
22:05:44 <joe6> must be my inexperience.
22:06:40 <applicative> could be; i'm not pretending it's better.
22:07:27 <dobblego> I think applicativizing makes it easier to read by virtue of the fact that you know for sure that action results cannot be depended on
22:08:11 <shachaf> applicative: You confuse the code? :-(
22:08:36 <applicative> it's not quite right, now that I think of it. i couldn't appeal to my compiler...
22:09:56 <applicative> i should have struck the returns from the definition of manage.
22:12:02 <applicative> i think this is right http://codepad.org/F37miO3E
22:13:25 <applicative> just confusing code wherever possible
22:17:43 <applicative> joe6 maybe liftM3 is clearer http://codepad.org/vUdxBAlN
22:18:36 <rwbarton> I realize you're not at a haskell compiler, but you have the arguments to manage in the wrong order :P
22:18:43 <rwbarton> which is a mistake you couldn't make in do-notation, I think
22:18:53 <rwbarton> and on another day might not fail to type check
22:19:09 <joe6> applicative: that is definitely better. thanks.
22:19:10 <applicative> wouldn't surprise me
22:19:20 <applicative> watch out though, joe6
22:19:31 <joe6> ok, will do.
22:23:19 <applicative> yes, manage o n r should be manage o r n  I was shadowing at first then repented
22:24:26 <applicative> i think maybe the use of get speaks in favor of do notation, on reflection, as definitely clearer
22:26:10 <applicative> the 'sequencing' provided by application order here is a little too invisible maybe...
22:29:02 <dennis_> Has anyone here tried to run a program that uses `par` on a mac?
22:29:25 <applicative> dennis_ yes, not lately
22:29:37 <applicative> what's the matter
22:30:02 <dennis_> Running with the -s flag, I see no sparks were created: SPARKS: 0 (0 converted, 0 pruned)
22:30:07 <dennis_> I'm on a quadcore machine
22:30:26 <dennis_> Did you run into this?
22:30:39 <koeien> did you compile with -threaded
22:30:50 <dennis_> yep: ghc --make -threaded -rtsopts para.hs
22:31:06 <dennis_> and then ./para +RTS -N2 -s
22:33:38 <hpaste> applicative pasted “sparks” at http://hpaste.org/51364
22:34:19 <applicative> dennis_ i used coins.hs from the monad-par tutorial
22:34:45 <applicative> does that look any better?
22:35:36 <dennis_> oh interesting, I'll check that out. There's something wrong with the example I'm using I think...I just tried another example and saw sparks.
22:36:01 <dennis_> Sadly the example is from a paper by Simon :/
22:36:04 <dennis_> Thanks!
22:36:32 <applicative> there are a couple decent tutorials with examples this one is on github i think.  dons made a much simpler pile of them for a talk, I'm not sure where it is.
22:39:23 <dennis_> Hmm, Google didn't turn up anything, but I found this: http://www.macs.hw.ac.uk/~dsg/gph/docs/Gentle-GPH/sec-gph.html
22:39:34 <dennis_> Seems to work better
22:40:05 <applicative> https://github.com/simonmar/monad-par it's on hackage too i guess
22:40:58 <dennis_> Oh neat thanks
22:44:45 <applicative> dennis_ this is the dons tutorial i was thinking of, it's very straightforward but I can't find the code http://donsbot.wordpress.com/2010/06/01/open-source-bridge-talk-multicore-haskell-now/
22:46:38 <dennis_> Oh sweet!
22:47:25 <applicative> the code must be around somewhere, it's nice, exhibits the obvious mistakes, too fine grained, not fine grained enough etc.
22:50:23 <dennis_> Yeah I wonder why he deleted the tar :-/
22:51:34 <Enigmagic> probably because they deleted his account
22:51:42 <Enigmagic> since he doesn't work at galois
22:52:14 <applicative> yeah, i think it's due to moving,
22:52:19 <kmc> wait, dons left galois?
22:52:28 <Enigmagic> yes
22:52:58 <Enigmagic> he works at standard chartered in nyc now
22:53:04 * applicative isn't sure how he knows, but he does.  'standard chartered' is the word in his mind
22:53:33 <dennis_> ah ok
22:57:45 <ksf> hmmm... use dbus and stm with an internal "virtual" bus to unify intra- and interPC?
22:58:17 <ksf> that is, the internal bus would broker TChans
22:58:36 <tactics> What's the term for functions which can't be reduced until all their arguments have been supplied?
22:59:01 <tactics> I thought it was Constant Applicative Form, but I'm not so sure
22:59:15 <ksf> CAFs don't take arguments.
22:59:31 <ksf> that's a highly reduction-strategy dependent measure.
23:00:19 <ksf> ...and surely isn't covered by haskell semantics.
23:00:43 <tactics> ksf: it was just a curiosity, no matter
23:00:51 <kmc> i'm not sure there's a term for that
23:01:00 <kmc> tactics, a CAF is an expression at top level,  which is an application
23:01:11 <ksf> "unapplied normal form"?
23:01:12 <kmc> x = 2 + 3  --- this is a CAF, it will be evaluated at most once, to x=5
23:01:55 <tactics> I spent all night throwing together a debruijn-style dependent type system. I'm finding adding Nat and its associated primitives zero, succ, and natrec are causing a lot of complexity in my normalization function
23:02:32 <kmc> tactics, i think what you're asking about is arbitrary, because you can slice off the outer lambdas and call that "the arguments", and then any further lambda yielded by β-reduction on the inside is "a result of function type" not a further argument
23:02:34 <ksf> yeah, goedel is a bugger.
23:03:09 <tactics> the problem is natrec, which takes 3 arguments.
23:03:18 <ksf> and that's not even considering reducing under lambdas.
23:03:20 <tactics> er 4*
23:03:27 <kmc> though for efficiently implementing a language like Haskell, it's useful to identify the "true" arity of a function, usually from the syntax of its definition
23:03:35 <tactics> I was reducing natrec only after it got all 4 arguments
23:04:07 <ksf> but something involving "normal form" seems sensible for "you have to tell me what some argument is, otherwise I can't reduce any more"
23:04:38 <tactics> but waiting for all the arguments doesn't work because if I don't have all 4, I still need to normalize the ones I do have
23:06:06 <tactics> Oh well, I have my system adding numbers
23:06:15 <tactics> multiplying them is harder >___>
23:29:42 <tactics> sweet jesus
23:29:57 <tactics> Trying to calculate 5! in unary using a naive interpreter is just death
23:46:41 <hpaste> cwl pasted “nest do, ok version” at http://hpaste.org/51366
23:47:27 <hpaste> cwl pasted “nest do, wrong version” at http://hpaste.org/51367
23:47:50 <cwl> why the 2nd nest do is wrong
23:48:52 <kosmikus> cwl: because another ; is inserted before <|>
23:50:06 <cwl> kosmikus, the second has no ;
23:50:26 <kosmikus> cwl: no, I was talking in terms of translating to the first version
23:50:41 <kosmikus> cwl: the last line starts at the same column as the outer do
23:50:50 <kosmikus> cwl: so it's a new statement in the outer do
23:51:20 <cwl> yes
23:51:35 <cwl> it is in the outer do
23:52:40 <kosmikus> so just indent that last line by one space and all is fine
23:54:01 <cwl> kosmikus: it is ok now, but I don't understand
23:56:08 <kosmikus> cwl: as I said, the second version behaves like the first version you wrote, but with an extra ; inserted before the <|> on the last line (which is wrong, hence the error)
