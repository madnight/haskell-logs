00:16:33 <_mmi_> Hi, I'm searching for a datastructure that allows head, tail, member, append efficiently (= no list). Is there a queue that allows a efficient member-test (backed by tree/hashmap)?
00:17:02 <tomberek> _mmi_ i was just looking for exactly that
00:17:26 <tomberek> would you also need to have membership for items that have passed through the queue?
00:17:57 <b_jonas> _mmi_: a pair of a seq and a multiset,
00:18:27 <_mmi_> tomberek: that would be really nice-to-have
00:18:29 <b_jonas> whenever you edit the seq, you also add the elements to the multiset to know what you have where
00:18:31 <tomberek> I used a pair of queue (the list reversing kind) and IntMap (I wanted to use a map at the same time)
00:18:54 <b_jonas> or you may want a seq and a map to indices if you also want to know what element is where
00:19:29 <_mmi_> ok, thank you, will try that out
00:20:48 <tomberek> b_jonas: so a paired structure works, but is there another structure that has these capabilities built in?
00:21:44 <ian__> anything like "reduce (+) [1, 2, 3]" => [3, 5]
00:21:53 <tomberek> _mmi_ i can send you over what i have
00:21:56 <ian__> where it applies a binary function to each neighbor in a list
00:22:19 <ian__> i implemented something myself, just want to know if something like that exist
00:23:09 <Maxdamantus> @hoogle (f -> a -> a) -> [a] -> (a, a)
00:23:09 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
00:23:32 <shachaf> > zipWith (+) [1,2,3] (tail [1,2,3])
00:23:33 <lambdabot>   [3,5]
00:23:39 <ian__> yeah that's what i'm doing shachaf
00:23:48 <Maxdamantus> Ah.
00:24:12 <shachaf> > zipWith (+) <*> tail $ [1,2,3]
00:24:12 <lambdabot>   [3,5]
00:24:26 <ian__> oo
00:24:34 <Maxdamantus> > ap (+) tail [1,2,3]
00:24:34 <lambdabot>   No instance for (GHC.Num.Num [a])
00:24:34 <lambdabot>    arising from a use of `e_1123' at <int...
00:24:59 <shachaf> I think zipWith and tail express what you want pretty clearly.
00:26:22 <Maxdamantus> > ap (zipWith (+)) tail [1,2,3]
00:26:23 <lambdabot>   [3,5]
00:26:32 <_mmi_> tomberek: that would be really nice
00:26:40 <ion> mmi: See also http://en.wikipedia.org/wiki/Finger_tree
00:29:10 <hpaste> tomberek pasted “queue with membership” at http://hpaste.org/51173
00:30:53 <ion> mmi: http://hackage.haskell.org/package/rope http://hackage.haskell.org/package/fingertree
00:31:41 <tomberek> _mmi_ I basically didn't want to queue anything I've seen before, but you can switch things around pretty easily
00:32:33 <ddarius> tomberek: Read Okasaki.
00:33:07 <ion> mmi: Oh, i misinterpreted “member”. Yeah, you probably need an additional set of members.
00:33:41 <tomberek> ddarius: i have, in fact, i did a quick search for something like this, but didn't see anything.... what are you referring to? PSQs?
00:34:12 <hpaste> ian__ pasted “point-free applicative functor” at http://hpaste.org/51174
00:34:32 <ian__> yeah, not working as expected :(
00:35:15 <tomberek> ian__ seems like all you need is a class contraint
00:35:18 <shachaf> ian__: I didn't mean the use of <*> as a serious suggestion.
00:35:21 <ion> ian: Try doing exactly what it proposes as a fix.
00:35:38 <ian__> Why not tomberek?
00:35:52 <shachaf> ian__: Anyway, yes, do what it says. That function doesn't work for any a, only for a value in Ord (and Eq).
00:35:57 <ian__> okay
00:36:08 <tomberek> yeah, add (Ord a) =>
00:36:16 <ian__> great, works
00:36:23 <shachaf> If you must use Applicative-style, at least use "ap (zipWith compare) tail", or something like that.
00:36:29 <ddarius> I'm referring to the fact that that queue type only gives amortized constant bounds if used linearly.
00:36:31 * shachaf wonders if <*> is readable with practiec.
00:36:48 <ian__> i can read it
00:37:03 <tomberek> ddarius: ah, yeah, I remember something about some that get O(1) un-ammortized
00:37:18 <ion> shachaf: I find that completely readable. Of course, that’s not the case with someone who isn’t familiar with the (→) a instance.
00:37:32 <ddarius> tomberek: There's that too, but that's not what I'm talking about.
00:37:45 <tomberek> ddarius: eh?
00:38:11 <ddarius> If you have a queue just before a reverse and you use it multiple times, you will get multiple O(n) costs.
00:38:25 <ddarius> Your queues are not O(1) amortized.
00:38:38 <shachaf> ion: I'm familiar with the instance (I initially mentioned it :-) ), but when I read it I more or less convert the <*> to prefix in my head, then turn it into a lambda, before I can figure out what it does.
00:38:44 <ddarius> (Ignoring the Set aspect.)
00:40:19 <ddarius> shachaf: The pattern is f <$> m <*> n = liftA2 f m n = do a <- m; b <- n; f a b
00:40:31 <ddarius> return (f a b)
00:40:46 <shachaf> ian__: What's isBouncy supposed to do? Test that a list decreases in value at least once and increases in value at least once?
00:40:53 <ian__> yes
00:41:12 <tomberek> ddarius: i'm not sure I understand. do you mean if you have a queue that you keep reusing exactly during the degenerative case.  So you are throwing away the resulting queue after the reverse and keep reusing the just-prior-to-reverse one?
00:41:37 <shachaf> ddarius: Right, I'm talking about use of <*> as S specifically.
00:41:55 <ian__> do you tink it's a decent solution?
00:42:27 <ddarius> shachaf: Just think of it as "impure" application.
00:42:34 <shachaf> ian__: Well, it'll force the entire list, even if it only needs a few values.
00:43:02 <shachaf> Oh, wait, it won't.
00:43:11 <shachaf> Because intersect sees that the first list only has two elements.
00:43:14 <ddarius> tomberek: Say you wanted to do map (flip queuePut q) xs
00:43:44 <ion> shachaf: In my head, i visualize (f <*> g) directly as f x (g x) where x is implicit. Well, it’s kind of like thinking \x → f x (g x) but i don’t need to think about it that abstracly, i “see” where the x goes visually.
00:44:04 <tomberek> ddarius: so you are making a bunch of queues?
00:44:13 <shachaf> ddarius: Oh, I see what you mean, I think.
00:44:36 <ddarius> Yes, that is what would be required for nonlinear usage.
00:44:40 <tomberek> ddarius: i just don't see that sort of thing happening often, because normally that would be a fold
00:45:05 <Jafet> Okasaki's queues are true amortized O(1) under any sequence of operations
00:45:21 <ddarius> tomberek: If you use it linearly there is no problem.  Okasaki covers this case and a simple generalization that doesn't have this problem.
00:45:23 <Jafet> Including nonlinear ones
00:45:28 <ddarius> Hence my recommendation to read Okasaki.
00:46:20 <tomberek> i see, yeah, I wasn't planning on using it nonlinerarly, so I'm using this for now, but as I refine, I'll look into more advanced structures
00:46:51 <tomberek> ddarius: Jafet: but any other ideas on _mmi_'s question? a queue with membership? or is pairing the queue with a set the only way to go
00:47:06 <ddarius> My point is that the "more advanced" structure that avoids this is only slightly more complicated.
00:47:17 <ddarius> tomberek: Again, read Okasaki.
00:47:39 <Jafet> I'd just use Sequence and Set
00:48:16 <Jafet> I wonder how the amortized queue performs with regard to multiprocessing
00:48:48 <Jafet> parmap (`queuePut` q) xs
01:21:38 <mstrlu> I would like to use the gio package, but this very simple test program segfaults.. any ideas what I am doing wrong?
01:22:32 <hpaste> mstrlu pasted “Segfault using gio” at http://hpaste.org/51175
01:25:07 <jpcooper> does anyone know how to convert DiffTime to time of day since epoch?
01:31:26 <jpcooper> or in the least, how can I convert from DiffTime to NominalDiffTime?
02:07:26 <rostayob> Is there a type class like "class MaybeEmpty where; empty :: a -> Bool"?
02:07:40 <rostayob> could be useful for list, maps, sets etc
02:08:45 <rostayob> I could say empty = (== mempty)
02:15:17 <efie> i tried to install Gtk2Hs on windows following this guide http://www.cse.chalmers.se/edu/year/2010/course/TDA451_Functional_Programming/labs/4/gtk2hs-install.html, but it failed: http://pastebin.com/aSjUWfb4 can anyone tell me how to fix this?
02:15:18 <mauke> The paste aSjUWfb4 has been copied to http://hpaste.org/51176
02:35:59 <rostayob> @pl foldr (\x xs -> [f x] : xs) []
02:35:59 <lambdabot> foldr ((:) . return . f) []
02:36:45 <tomberek> how can you find in Core where things are being allocated to the heap?
02:36:59 <tomberek> let?
02:37:43 <rostayob> @pl foldr (\x xs -> [f x : xs) []
02:37:43 <lambdabot> (line 1, column 17):
02:37:43 <lambdabot> unexpected "["
02:37:43 <lambdabot> expecting lambda abstraction or expression
02:37:47 <rostayob> @pl foldr (\x xs -> f x : xs) []
02:37:47 <lambdabot> foldr ((:) . f) []
02:46:57 <Saizan> tomberek: yeah
02:48:05 <tomberek> Saizan: ok, that's what I though, i'm looking and don't see allocation going on, or I can't find it
02:49:03 <tomberek> Saizan: so case statements won't allocate to heap?
02:49:15 <tomberek> i have to see a let in Core?
02:58:13 <Saizan> afaiu that's how it works, can't say i'm too much of an expert at reading code for performance though
02:59:44 <tomberek> Saizan: i have been halfway successful in rewriting modifySTRef to be stricter and not allocate that much, but it's still doing some., It gets GC'd, but I'd like it to do it without even touching the heap
03:01:29 <tomberek> Saizan: i suspect that the result of the modification is created, put into the heap, then written to the STRef, then the original copy is GC'd
03:03:02 <hpaste> tomberek pasted “GC'ing modifySTRef” at http://hpaste.org/51177
03:03:13 <tomberek> Saizan: here's the relevant section
03:16:52 <Saizan> well, you can't get better than that with STRef's they point to boxed stuff on the heap by design
03:17:25 <Saizan> you can't just overwrite the original, because the original might be references by something else too
03:17:32 <Saizan> *referenced
03:20:19 <tomberek> Saizan: hm
03:21:07 * hackagebot FilePather 0.0.2 - Functions on System.FilePath  http://hackage.haskell.org/package/FilePather-0.0.2 (TonyMorris)
03:21:13 <tomberek> Saizan: i thought you'd be able to modify in-place, the fact that it's an STRef should allow that
03:22:09 <Saizan> what you modify in-place is the pointer to the stuff on the heap that an STRef contains
03:22:39 <tomberek> ah! so that's why when the function is (+0) it doesn't allocate, but (+1) does?
03:22:44 <Saizan> but what that pointer points to is still supposed to be immutable
03:23:34 <tomberek> gr... so I can't prevent that?.  there's no unboxed STRef? or something
03:24:12 <Saizan> a singleton unboxed array?:)
03:24:21 <Saizan> i don't know of anything else
03:24:47 <tomberek> Saizan: i guess I can try that out
03:25:29 <Saizan> (my guess is that (+0) gets optimized away to id, so that there's nothing new to allocate)
03:25:36 <tomberek> yeah
03:27:17 <tomberek> so what would you suggest? STUArray?
03:27:21 <Saizan> an array will have the overhead of checking bounds though
03:27:28 <Saizan> yeah, that's the one
03:27:58 <tomberek> well, I can create a version that doesn't check bounds, it's a singleton, no need to
03:28:20 <Saizan> there's also the vector package
03:28:45 <tomberek> i'm not sure how that helps
03:29:42 <Saizan> just a newer package for dealing with contiguous chunks of memory
03:39:45 <tomberek> Saizan: ah, i see.  so, then how would this work? I would need to pass modifySTRef a function that modifies the Vector?
03:40:28 <Saizan> you'd make your own reference type that's just a newtype of STUArray or the unboxed vector type
03:41:13 <Saizan> i was suggesting vector as an alternative library providing unboxed arrays
03:41:38 <tomberek> and use that instead of STRef?
03:41:56 <Saizan> yep
03:41:58 <tomberek> ah!, ok, i think I got it
03:42:11 <tomberek> because STRef is boxed? and there isn't an STURef?
03:42:18 <Saizan> yeah
03:42:30 <tomberek> hm... perhaps there should be a STURef?
03:43:13 <Saizan> it'd make sense
03:43:37 <mstrlu> 13:31 <tomberek> hm... perhaps there should be a STURef?
03:44:12 <tomberek> would it be easy to make? right now it's :  data STRef s a = STRef (MutVar# s a)
03:44:16 <mstrlu> sorry... pasting mistake
03:45:00 <tomberek> I don't think there's a MutUVar# anywhere
03:45:05 <Saizan> i don't know
03:45:10 <tomberek> but i could be wrong
03:57:10 <k0ral> oO I'm getting this error message: /usr/lib/ghc-7.0.3/package.conf.d/package.cache: openBinaryFile: permission denied (Permission denied)
03:57:28 <k0ral> while recompiling an executable with dyre
03:57:37 <k0ral> any clue ?
03:57:39 <knoc> hello, is there some way to specify the length of the inner lists creaed by this: allKeys = [[a,b,c,d] | a <- pool, b <- pool, c <- pool, d <- pool]
03:57:56 <knoc> like if I want 5 elements long lists instead of 4
03:58:27 <Axman6> > replicateM 5 [1,2,3]
03:58:28 <lambdabot>   [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,2,1],[1,1,1,2,2],[1,1,1,2,3],[1...
03:58:34 <Axman6> > replicateM 3 [1,2,3]
03:58:35 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
03:58:53 <knoc> ohh, thats great :]
03:58:57 <Axman6> > replicateM 3 [0,1]
03:58:58 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
03:59:09 <obiwahn> nice
03:59:16 <tomberek> k0ral: sorry not familiar with dyre, but probably a global vs user install issue
03:59:33 <obiwahn> what was the comman ot look at the source?
03:59:41 <obiwahn> src replicateM
03:59:42 <Axman6> @src map
03:59:42 <lambdabot> map _ []     = []
03:59:43 <lambdabot> map f (x:xs) = f x : map f xs
03:59:50 <obiwahn> @what was the comman ot look at the source?
03:59:50 <lambdabot> I know nothing about was.
03:59:55 <obiwahn> @src replicateM
03:59:55 <lambdabot> replicateM n x = sequence (replicate n x)
04:00:04 <obiwahn> @src replicate
04:00:04 <lambdabot> replicate n x = take n (repeat x)
04:00:23 <obiwahn> @src sequence
04:00:23 <lambdabot> sequence []     = return []
04:00:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:00:23 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
04:00:35 <k0ral> tomberek: I didn't change anything in my config, always installed everything in a global context
04:01:22 <tomberek> eh.... I don't know, but I've gotten similar errors, sudo type issues
04:01:43 <poliquin> How can I define a Char c  such that  "foo" ++ [c] == "foo"   ?
04:02:47 <Axman6> you can't
04:03:48 <poliquin> Thanks .. I'll stop looking for a way to do it ..
04:04:29 <Eduard_Munteanu> poliquin: [] is your identity for (++)
04:05:15 <Eduard_Munteanu> k0ral: are the permissions on that file ok?
04:07:46 <poliquin> Eduard_Munteanu, Thanks but I'm passing c in a function and [] is not ::Char
04:08:07 <koeien> then pass Maybe Char
04:08:19 <koeien> or do some other thing :)
04:08:43 <k0ral> Eduard_Munteanu: -rw-r-----
04:08:47 <k0ral> Eduard_Munteanu: root:root
04:08:57 <Axman6> poliquin: the only value you x for which x ++ z == x is []
04:09:19 <Axman6> poliquin: remember that strings are just lists of characters. there's nothing about them having characters in them
04:09:35 <k0ral> Eduard_Munteanu: chmod o+r solves the problem, but is it supposed to be readable by all ?
04:09:37 <Axman6> if you can't do it for a string of numbers, you can't do it for a string of chars either
04:09:50 <Eduard_Munteanu> k0ral: it's -rw-r--r-- here on Gentoo
04:09:52 <poliquin> Ah, Maybe Char .. I didn't think of that ...
04:09:59 <poliquin> Duh
04:10:02 <Eduard_Munteanu> So I suppose it's safe.
04:11:14 <poliquin> It just seemed to me that a dual of "", namely '' would exist.
04:11:37 <k0ral> Eduard_Munteanu: thank you, don't know why it wasn't readable but now it works
04:11:47 <Axman6> the closest thing would be '\NUL'
04:11:57 <Axman6> > '\NUL'
04:11:58 <lambdabot>   '\NUL'
04:11:59 <Eduard_Munteanu> poliquin: the only reason that works for strings is they can have a variable-length, including 0. 'x' always denote one character
04:12:08 <Axman6> > "\NUL"
04:12:08 <lambdabot>   "\NUL"
04:12:10 <Eduard_Munteanu> s/-//
04:12:13 <Axman6> > text "\NUL"
04:12:14 <poliquin> I tried '\&
04:12:25 <Axman6> > text "a\NULb"
04:12:25 <lambdabot>   ab
04:12:28 <poliquin> which gave me \NUL in the string
04:12:34 <Axman6> yes
04:12:44 <Eduard_Munteanu> However, it might be possible to get a character that doesn't change the string when printed.
04:12:57 <Eduard_Munteanu> (at least by writing your own Show)
04:13:09 <Eduard_Munteanu> But I guess that's not what you want.
04:13:29 <poliquin> It's being parsed later so I didn't think \NUL would be a good thing to have around
04:13:39 <Eduard_Munteanu> k0ral: how did you install it?
04:14:03 <Eduard_Munteanu> Distro package?
04:14:03 <Axman6> poliquin: why are you not just not calling the function that does foo ++ [c]?
04:14:06 <Axman6> what a terrible sentense
04:16:17 <poliquin> Axman6, I have a function that does that and I'm passing c as a ::Char ..
04:17:03 <poliquin> Axman6, I guess I could pass it as a string and do the [c] stuff in the function call.
04:17:24 <k0ral> Eduard_Munteanu: no, cabal distribution system
04:18:02 <k0ral> Eduard_Munteanu: oh, wait, talking about ghc, I think I had no choice but using the distro package
04:18:23 <k0ral> Eduard_Munteanu: since cabal needs ghc in the first place
04:18:29 <Eduard_Munteanu> Ah.
04:18:36 <Eduard_Munteanu> Well, I'd expect those to work fine :/
04:18:42 <hvr> is Array# a "boxed unlifted" type?
04:18:57 <poliquin> Thanks everyone for the help !
04:25:07 <obiwahn> how do i get the least fp do i have to build the chains and take the lub?
04:25:26 <obiwahn> or is there some other way?
04:25:38 <Eduard_Munteanu> obiwahn: fix?
04:25:49 <obiwahn> jep
04:26:03 <Eduard_Munteanu> Use fix then. :)
04:26:13 <obiwahn> no
04:26:29 <obiwahn> What is fix?
04:26:34 <koeien> :t fix
04:26:34 <lambdabot> forall a. (a -> a) -> a
04:26:39 <koeien> > fix (1:)
04:26:40 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:26:43 <Eduard_Munteanu> Ah, is this about doing theoretical stuff on paper?
04:26:45 <koeien> @src fix
04:26:45 <lambdabot> fix f = let x = f x in x
04:27:29 <obiwahn> yes theeoretical stuff:)
04:27:36 <b_jonas> but it's also useful in practice
04:29:04 <obiwahn> > fix 17
04:29:05 <lambdabot>   17
04:29:19 <obiwahn> > fix (x+1)
04:29:19 <lambdabot>   Couldn't match expected type `a -> a'
04:29:19 <lambdabot>         against inferred type `Simple...
04:29:42 <obiwahn> > fix (\x->x+1)
04:29:46 <lambdabot>   mueval-core: Time limit exceeded
04:29:49 <obiwahn> ^^
04:35:49 <obiwahn> > let g = \x -> inf x <=0 then 1 else g(x-1) * x in fix g
04:35:50 <lambdabot>   <no location info>: parse error on input `then'
04:36:00 <obiwahn> > let g = \x -> if x <=0 then 1 else g(x-1) * x in fix g
04:36:04 <lambdabot>   mueval-core: Time limit exceeded
04:37:21 <obiwahn>  let fun g = \x -> if x <=0 then 1 else g(x-1) * x in fix fun
04:37:30 <obiwahn> > let fun g = \x -> if x <=0 then 1 else g(x-1) * x in fix fun
04:37:31 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
04:37:31 <lambdabot>    arising from a use of `...
04:40:39 <obiwahn> the src of fix is the mathematical def but how does haskell find the fp?
04:41:32 <Eduard_Munteanu> obiwahn: it doesn't do anything special
04:41:51 <Eduard_Munteanu> It's just what the definition says.
04:42:06 <Eduard_Munteanu> Well, being lazy plays a part in it.
04:43:02 <Eduard_Munteanu> Also...
04:43:04 <Eduard_Munteanu> @src Mu
04:43:04 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
04:43:33 <Eduard_Munteanu> ... for a type-level fixed point combinator.
04:43:48 <koeien> didn't that crash ghc?
04:44:15 <Eduard_Munteanu> Maybe just in some cases? :/
04:44:30 <Saizan> no, that's quite fine
04:44:38 <Eduard_Munteanu> I think List = Mu ListF works fine
04:45:10 <Saizan> building the y combinator though newtype Rec a = Wrap (Rec a -> a) will make the inliner loop though, unless you add a NOINLINE pragma
04:45:33 <Saizan> s/though newtype/through newtype/
04:47:55 <obiwahn> when i use nonterm nonterm = \x -> nonterm (x+1) then i can build a approximative fun nn g = \x -> g(x+1)   so i do not have to deal with recursion. then the sematicis are something like (nns (g)) (x) = g(x+1) ... door - sh*t
04:50:38 <Saizan> (Rec a ~ Mu (F a) where F a x = x -> a btw)
04:53:27 <obiwahn> i do not understnad Mu Rec etc at all:(
04:54:38 <obiwahn> what does newtype Mu f = In { out :: f (Mu f) } say? What does Mu abbreviate?
04:54:52 <kqr> how come i can't do "True or False" in ghci to test out how the logic works?
04:55:02 <koeien> kqr: or is something else, use ||
04:55:03 <Botje> kqr: because or :: [Bool] -> Bool
04:55:09 <kqr> oh
04:55:11 <kqr> right
04:55:12 <kqr> thanks
04:55:17 <Botje> obiwahn: it's a trick to create recursive types
04:55:17 <b_jonas> obiwahn: I don't think it abbreviates anything. it's just the name of the greek letter.
04:55:20 <koeien> and && for binary and, likewise
04:55:26 <kqr> that's why the data type hade a [Bool] in it
04:55:32 <koeien> yup :)
04:55:53 <kqr> cool
04:57:48 <tomberek> Saizan: it works!, Using unboxed mutable Vector I can do the same thing, but better than using STRef.  I'm thinking I should make an STURef based on Vector
05:03:28 <jmcarthur> obiwahn: do you understand the fix function? if so, then you already understand Mu :)
05:04:01 <bayesian> what percentage of haskell programmers are vegetarian
05:04:08 <jmcarthur> less than 100%
05:04:41 <bayesian> any estimate
05:05:12 <jmcarthur> that was my best
05:05:25 <bayesian> jmcarthur, im pursuaded by this http://www.youtube.com/watch?v=THIODWTqx5E
05:05:46 <jmcarthur> not all meat production is like that
05:05:53 <jmcarthur> hmm, this is off topic though
05:06:00 <jmcarthur> we certainly shouldn't debate here
05:06:01 <bayesian> yeah you're right
05:06:04 <jmcarthur> #haskell-blah?
05:06:06 <bayesian> also they made some tehcnical mistakes
05:06:48 <Saizan> obiwahn: seen this? http://www.vex.net/~trebla/haskell/fix.xhtml
05:16:21 <obiwahn> thanks
05:19:26 <raichoo> Kind of offtopic, but is there a freenode-channel that just deals with functional programming? Not #math :P
05:19:36 <joe6> any thoughts on how I can structure this function: http://codepad.org/srhhlrUl, error: http://codepad.org/tSlshgps , setThenGet function signature: http://codepad.org/o0Iea7Dx
05:21:13 <Younder> Rydheard D.E Burstall Computational Category theory
05:21:43 <hpaste> Clint pasted “clientsession build failure” at http://hpaste.org/51180
05:21:51 <bayesian> is anyone doing ai class
05:21:55 <Clint> anyone know what ^ that's about?
05:22:39 <Younder> Bayesian: no, but I'd studied it for 20 years
05:23:40 <bayesian> is it possible to make a thinking machine?
05:25:41 <Younder> Bayesian: Well we can make a program that leans. What we need is Hypothesis testing and creation. That no-one is capable of yet as i am aware. But there is a grout at the University at Edinburgh that is working on it.
05:26:36 <Younder> Bayesian: oh my god.. the spelling errors
05:27:47 <Younder> I tend to get a bit carried away on that topic and I am a bit dyslectic
05:27:57 <Jafet> "When we write programs that learn, it turns out that we do and they don't."
05:28:13 <bayesian> Younder, Hypothesis testing and creation interesting idea and what group is this?
05:28:14 <Younder> Nevertheless it is factually correct
05:29:33 <Younder> Bayesian: ty my knowlege it is only a small group at the University of Edinburgh that is working on it. You would have to talk to them directly.
05:29:59 <bayesian> Hypothesis testing and creation
05:30:04 <bayesian> what is that
05:30:44 <Younder> http://ideas.repec.org/p/jhu/papers/474.html
05:31:28 <Younder> And something on Physics
05:35:26 <bayesian> today can AI do any real reason?
05:35:28 <bayesian> reasoning
05:35:38 <bayesian> or is just path finding
05:35:42 <Younder> Bayesian, I failed you badly. I didn't find that article I was looking for. Nevertheless there are 6 AI departements at University of Edinburgh and one one of the is Hypothesis testing and Creation. I just cant find their released article. (Which quite frankly leaves a lot to be desired)
05:37:19 <Younder> Bayesian: They can learn. But that is not enough. Existence is about discovering. This they can not do.
05:37:39 <bayesian> discovering new ideas?
05:37:53 <Younder> Bayesian: yes
05:38:06 <bayesian> I wonder how that is done in humans
05:38:33 <Younder> Bayesian: Or discarding ones that don't fit. They blindly trust their input.
05:41:15 <Younder> Bayesian: no-one knows
05:41:28 <bayesian> interesting
05:42:03 <Younder> Bayesian: I warn you it can become an obsession
05:42:16 <bayesian> :D
05:46:18 <Younder> I fell in love with AI 20 years ago and I made some major discoveries. Like how to remember. How to co-late. How to recognize. I even discovered the nature of intuition. But I have never found the answer to  hypothesis creation.
05:46:45 <bayesian> how to remember?
05:46:59 <Younder> yes
05:47:38 <Younder> You need interest to know what to remember. That is a feeling.
05:48:00 <Younder> How do you quantify relevance.
05:50:43 <tomberek> Younder: similar to content fixation?
05:50:45 <Younder> It turn out you can by knowing about a universe of discourse, a topic if you will. Again for that you need self awareness which is achieved with a topic tree and function of proximity.
05:51:01 <Younder> tomberek, yes
05:52:20 <Younder> The key here is coupling
05:52:30 <tomberek> Younder: I recently read some of Daniel Dennett's books on consciousness and was impressed. What are your opinions on some of those ideas?
05:52:54 <Younder> tightly coupled things tend to hang together loosely coupled things dont
05:53:36 <Younder> tomberek, never red them or even heard of them
05:54:23 <tomberek> Younder: they're great, I highly recommend them
05:55:11 <tomberek> Younder: nowadays he's focused on religion/atheism/etc, but earlier his work was highly concentrated on figuring out how the mind works
05:55:51 <bayesian> what does he say
05:55:53 <bayesian> Daniel Dennett?
05:55:55 <tomberek> Consciousness Explained is a good read
05:56:00 <Juz30> Hello, I've been working on a program that involves running a loop until a key is pressed.  So far I've had no luck finding a function that will tell me whether reading from stdin will block or not.  Is there a function for this purpose or a better way to do this?
05:56:00 <bayesian> is consciousness explained?
05:56:22 <Younder> tomberek: have you red the emperors new mind?
05:57:20 <sbrg> Juz30: you want to run something until someone presses a key? If so, why not just use forkIO?
05:57:25 <tomberek> Younder: if not exactly that book (i don't remember), but a similar one
05:57:34 <Younder> Byesian consciousness was one of the things I was able to figure out
05:57:57 <tomberek> Yonder, dennett argues that determinism isn't necessarily a bad thing
05:58:06 <sbrg> :hoogle ThreadId -> IO (9
05:58:07 <sbrg> ff
05:58:13 <sbrg> @hoogle ThreadId -> IO ()
05:58:13 <lambdabot> Control.Concurrent killThread :: ThreadId -> IO ()
05:58:13 <lambdabot> Control.OldException throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
05:58:13 <lambdabot> Control.Concurrent throwTo :: Exception e => ThreadId -> e -> IO ()
05:58:36 <Jafet> Juz30: you can use a terminal library like vty, which internally uses ncurses which internally polls stdin or something
05:58:50 <Jafet> Or you can use ghc threads which internally do the same thing anyway
05:58:50 <sbrg> Juz30: do { tid <- forkIO foo; getChar; killThread tid; }
05:58:58 <bayesian> Younder, how?
05:59:15 <tomberek> Younder: Dennett would probably disagree with Penrose, that much of consciousness, if not all, can be algorithmic
06:00:11 <Younder> It isn't a place it's a wave function travelling around the brain at about 10 times pr. second. There is a fracta composure of sub elements each contributing a small amount of information to the prime integrator (that wave is consciousness)
06:00:52 <Younder> tomberek: so do I
06:01:11 <tomberek> Younder: that's the sort of thing he argues for, that it cannot be a place
06:01:58 <Juz30> killThread immediately stops said thread, doesn't it?  Because that thread will be repeatedly running calculations, and I'd like it to cancel only after it has finished a calculation.
06:02:02 <Younder> Tomberec: neither is water on a waterfall. It travels on. Water is water.
06:02:12 <sbrg> Juz30: yes, it was just an example
06:02:18 <Jafet> Then synchronize the threads with an MVar, etc.
06:02:21 <sbrg> you can use a channel and make the thread watch the channel, or something
06:02:22 <bayesian> lol
06:02:22 <sbrg> yeah, mvar
06:02:25 <Jafet> Work it out for yourself
06:02:39 <tomberek> Younder: See if you can find his books. I think you'll find him interesting.
06:03:28 <Juz30> Ok, I'll use MVars then.  I was just hoping there was a simple non-blocking function to check stdin, to make it simpler
06:04:08 <Jafet> There is. Use a terminal control library.
06:04:25 <Jafet> Well, it doesn't input from stdin, but from a terminal.
06:05:14 <Axman6> Juz30: why use an MVar when an IORef Bool would make more sense?
06:05:32 <hpaste> Ivoz pasted “currying?” at http://hpaste.org/51182
06:05:40 <tomberek> to all: STRef's have cause be problems recently due to heap allocation and laziness.  Seems like much of the issues can be fixed using a singleton mutable vector from the Vector package.  Would a STVRef be useful for anyone else?
06:05:51 <Jafet> Because atomicModifyIORef is such a mouthful
06:05:52 <Ivoz> Can you guys help me where I'm going wrong ^^?
06:06:02 <Axman6> pressed <- newIORef False; forkIO <check for key loop with pressed>; foo pressed
06:06:06 <Jafet> (It's not atomic by default, right?)
06:06:16 <Axman6> there's no need for atomicity here
06:06:34 <Axman6> and it should be atomic if you do writeIORef passed True
06:06:51 <Botje> Ivoz: your lengths returns [Int]
06:06:53 <Jafet> Your wording is not very reassuring!
06:07:01 <Botje> Ivoz: sum can't magically turn that [Int] into any number.
06:07:03 <Axman6> the beauty of atomicModifyIORef is that you get to perform some mutation action atomically
06:07:07 <Juz30> Jafet: I would use a terminal control library of some sort, although I'm planning on hooking this up to a control program, so it would be reading from stdin rather than a terminal
06:07:10 <tomberek> Ivoz, Int isn't Num a
06:07:21 <Botje> Ivoz: so either make sumLengths return an Int, or add a fromIntegral to your sumLengths function
06:07:24 <Ivoz> so you can't get more general with the type
06:07:32 <Axman6> Juz30: why is atomicity needed?
06:07:33 <Botje> Ivoz: alternatively, use genericLength in lenghts
06:07:37 <Axman6> uh, Jafet
06:07:51 <Jafet> Then a terminal library is inappropriate, because it probably expects a tty
06:07:54 <tomberek> Axman6: it was with modifySTRef that some of my issues came up, I think I can make a lot of that allocation go away using Vector
06:08:14 <Axman6> tomberek: hmm?
06:08:27 <Ivoz> @src (.)
06:08:27 <lambdabot> (f . g) x = f (g x)
06:08:27 <lambdabot> NB: In lambdabot,  (.) = fmap
06:08:40 <Jafet> Axman6: well, I thought using the same IORef from different threads could have undefined results
06:08:48 <Ivoz> @src ($)
06:08:48 <lambdabot> f $ x = f x
06:08:57 <Axman6> not if you're just reading from one, and writing with another
06:09:15 <tomberek> Axman6: I've been using STRef, but I'm finding much better results using a mutable Vector, so I was thinking of creating a "STVRef"
06:09:37 <jpcooper> @info (->)
06:09:37 <lambdabot>  Parse error at "->)" (column 2)
06:09:52 <Ivoz> @src (->)
06:09:52 <lambdabot> Source not found. My mind is going. I can feel it.
06:10:12 <Ivoz> @src (,)
06:10:12 <lambdabot> Source not found. Are you on drugs?
06:10:29 <Axman6> Jafet: to turn an IORef from False to True, it's just changing a pointer, which in any architecture should be atomic
06:10:56 <Axman6> (in fact, in the case of Bool, i think it's just setting a bit in a pointer, thanks to pointer tagging)
06:11:49 <Jafet> Yeah, that's real reassuring...
06:12:01 <Axman6> eh?
06:12:01 <Jafet> To change the bit, you have to read the pointer, flip the bit, and write it back
06:12:07 <hpaste> ScriptDevil pasted “Building template-haskell fails” at http://hpaste.org/51183
06:12:13 <Jafet> Most CPUs don't have an atomicModifyBitAt
06:12:13 <ScriptDevil> Hey.I was trying to cabal install hakyll when building template-haskell failed. Is there anything I can do about it?
06:12:27 <Axman6> sure, but to just ... urgh, there's no possibility of conflict in this exact situation
06:12:38 <Jafet> So you say...
06:13:16 <Axman6> since it is only ever written to twice, once at creation, and once to set it to true. since nothing else will ever modify it, you cannot, ever, have an issue with this. it's not a hard concept
06:14:21 <Axman6> at some point, it will from pointing to the position representint False to the position representing True. you can only have conclicts if there's more than one writer
06:14:24 <Axman6> conflicts*
06:14:34 <Jafet> Look, I just stopped listening when you mentioned pointers, sorry
06:14:58 <Younder> tomberek: I just bought Consciousness explained and have it. (kindle)
06:15:05 <Axman6> wow...
06:15:26 <Jafet> IORef might be safe for multiprocessing, but you're doing a pretty bad job convincing me of that
06:15:26 <tomberek> Younder, the magic of tech. It's a long read, but I couldn't put it down
06:15:28 <Axman6> i've spelt it out for you as clearly as i possibly can, and you still don't get it? i'm amazed
06:15:39 <Jafet> You shouldn't need pointers to explain any of this
06:15:45 <Axman6> no, it's not safe, but this situation is safe >_<
06:15:50 <Jafet> Oh
06:15:59 <Jafet> Then fuck you and your shitty advice to newbies
06:16:02 <Axman6> that's all i have been saying
06:16:03 <Jafet> Go away
06:16:13 <Axman6> what the fuck?
06:16:47 <kamaji> 'ello 'ello 'ello, what's goin' on 'ere then
06:16:59 <Axman6> it's not at all shitty advice. it's a frigging binary flag, with a single writer. there's no need to make it an MVar, which you only need to use if you're trying tyo guarantee mutual exclusion, and that is not needed here. far out
06:17:28 <Axman6> just because you can't understand such a simple concept doesn't make me wrong
06:17:31 <Younder> later
06:17:42 <tomberek> later
06:23:28 <ScriptDevil> Is there a way to pass -XTypeSynonymInstances flag to ghc when I am building using cabal?
06:23:42 <tomberek> does anyone know how Vector works internally? with the mutable Vectors in ST and IO?
06:23:43 <Saizan> it's not like you lose much by erring on the side of safety and use MVar
06:24:05 <ScriptDevil> I want to install Hakyll and template-haskell build fails because of not using this.
06:24:07 <tomberek> Saizan: hey, your idea worked perfectly, i'm trying to find out why
06:24:10 <Jafet> ScriptDevil: hm, why do you need to do that? If a module needs it, it's better to add a language pragma to the module
06:24:39 <Jafet> Oh, you're building someone else's package. That sounds like a bug
06:25:35 <ScriptDevil> Jafet: Yes, it does. It built yesterday night in my lab :( I wonder what changed overnight.
06:25:39 <Axman6> Saizan: sure, but it (potentially) adds a blocking operation where it's not needed.
06:26:32 <Jafet> ScriptDevil: are you using a ghc version that the package expects?
06:27:00 <Juz30> Ok, the MVar way is working fine
06:27:05 <Juz30> thanks for the help! :)
06:27:26 <ScriptDevil> Jafet: I am using version 7.0.2 which is the latest update on Fedora. It says 7.0 is ok.
06:27:58 <ScriptDevil> Jafet: Wait. It says 7.2 for the latest 2.6.0 release
06:29:24 <Saizan> tomberek: still not clear?
06:29:30 <ScriptDevil> Jafet: So, what can I do about it?
06:29:52 <tomberek> Saizan: i can't get to the instance declarations in Vector, I can't see how it works internally
06:30:14 <Saizan> tomberek: ah, ok
06:30:37 <Axman6> doesn't Vector use stream fusion for a hell of a lot of what it does?
06:31:06 <tomberek> But it seems to work well... I'll make STVRef's, out of singleton Vectors, but then again, if i can figure out how it works internally, that's a level of indirection gone
06:31:11 <Axman6> maybe only if you import certain modules
06:31:14 <tomberek> Axman6: yes
06:31:21 <Ivoz> is there a way to reverse the way (x:xs) matches, i.e conceptually (xs:x) ?
06:31:52 <Axman6> Ivoz: not really.
06:32:00 <koeien> no, unless you're willing to use view patterns
06:32:03 <Ivoz> ok.
06:32:10 <Jafet> ScriptDevil: you can try to monkey-patch it with pragmas until it (possibly) compiles, or you can use an older version of the package, or you can upgrade ghc
06:32:24 <Axman6> it's pretty common for bnewbies to want to do things like f (x1:xs:x2:[]) and expect xs to be everything but the middle of the list
06:32:28 <koeien> tbh it would also be confusing for people reading your code
06:32:56 <Ivoz> I'm supposed to write a blowup function, where abc becomes abbccc
06:33:07 <brisingr> remember that : is the cons operator i.e. takes an element on the left side, not a list
06:33:09 <Ivoz> managed to get abccbcc so far
06:33:51 <Ivoz> (String -> String)
06:33:54 <Axman6> that's pretty simple. hint: zip [1..]
06:34:04 <Ivoz> we don't know about zip yet, afaik
06:34:13 <koeien> Ivoz: you can also explicitly write out the recursion
06:34:30 <koeien> if you're not willing to use zip
06:34:42 <koeien> blowup xs = f xs 1 -- what should f be ?
06:35:02 <Ivoz> use a helper function?
06:35:15 <Kaidelong> f' _ [] = []
06:35:38 <Ivoz> can you think of a way without a helper function?
06:35:40 <Kaidelong> f' n (x:xs) = replicate n x ++ f' (n+1) xs
06:35:44 <Kaidelong> f = f' 0
06:36:01 <bayesian> wow Kaidelong how long have you been doing haskal
06:36:01 <ScriptDevil> Jafet: Well, I installed template-haskell-2.5.0.0. Thanks a lot. I expected the version dependencies in hamlet to be hard-coded. Fortunately it wasn't. Thanks again :)
06:36:24 <koeien> Ivoz: I think you will need the current index, so you would need zip [1..] or a helper function that keeps track of the position
06:37:31 <Kaidelong> if you want tokeep things in place you'd need two helper functions I think
06:37:44 <Kaidelong> basically you'd need your own version of replicate
06:38:02 <koeien> :t concat . zipWith replicate [1..]
06:38:02 <lambdabot> forall a. [a] -> [a]
06:38:12 <Axman6> > zipWith replicate [1..] "hello"
06:38:13 <lambdabot>   ["h","ee","lll","llll","ooooo"]
06:38:39 <Axman6> > concat . zipWith replicate [1..] $ "hello"
06:38:43 <lambdabot>   mueval-core: Time limit exceeded
06:38:46 <Ivoz> lol
06:38:50 <Axman6> o.O
06:38:50 <tomberek> Saizan: ok, here's what I got so far:   Vector uses MutableArray while STRef uses MutVar, both from GHC.Prim, so is this a GHC internal thing?
06:38:56 <Axman6> > concat . zipWith replicate [1..] $ "hello"
06:38:58 <lambdabot>   "heelllllllooooo"
06:39:04 <koeien> lambdabot was busy for a sec
06:39:05 <Axman6> thank you! o.O
06:39:07 <koeien> :)
06:39:09 <Axman6> aye
06:39:59 <Saizan> tomberek: yep, primitive types provided by GHC
06:40:10 <koeien> Ivoz: i don't really see a direct way using fold e.g.
06:40:20 <Ivoz> Axman6: too many l's
06:40:33 <brisingr> Ivoz: h ee lll llll ooooo
06:40:37 <koeien> Ivoz: no.
06:40:40 <Axman6> heh
06:40:41 <Ivoz> oh
06:40:42 <Ivoz> right
06:40:43 <Ivoz> woops
06:40:46 <Axman6> =
06:40:47 <Axman6> =)
06:41:08 <tomberek> Saizan: so I have to pretend that my Vector of length 1 is a MutVar? There's not a more direct way? or can i alter STRef in some manner?
06:41:37 <Kaidelong> @ty foldr
06:41:37 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:42:14 <Shigi> help
06:42:16 <Shigi> :D
06:42:27 <tomberek> Shigi, what's up?
06:42:50 <Shigi> nothing 4while, just tryin smting, but thx
06:44:09 <brisingr> you know,
06:44:35 <brisingr> after doing haskell for two weeks or so, vector field calculus is a walk in the park
06:44:46 <Olathe> > let zomgTree xs = concat . takeWhile (not . null) . tail . map (\(r, _, (ys, _)) -> if r then reverse ys else ys) . iterate (\(r, a, (_, b)) -> (not r, a + a, splitAt a b)) $ (True, 1, (undefined, xs)) in zomgTree [1..7]
06:44:47 <lambdabot>   [1,3,2,4,5,6,7]
06:45:06 <Jafet> zomg
06:45:15 <brisingr> zomg
06:45:26 <Ivoz> I got this solution :<
06:45:29 <hpaste> Ivoz annotated “currying?” with “blowing stuff up” at http://hpaste.org/51182#a51184
06:46:00 <Ivoz> asif you need three functions :<
06:46:01 <Saizan> tomberek: i'm not so familiar with the details of these types to help you here
06:46:33 <tomberek> Saizan: thanks anyway, it's just odd that an array type works better as a MutVar, than MutVar itself!
06:47:23 <sbrg> > let foo n c = repeat c n in map (foo 2) "abc"
06:47:24 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
06:47:29 <koeien> Ivoz: "conc" is replicate
06:47:34 <sbrg> ah, replicate
06:47:36 <sbrg> :t replicate
06:47:36 <koeien> well, flip replicate
06:47:36 <lambdabot> forall a. Int -> a -> [a]
06:47:50 <sbrg> > let foo n c = replicate n c in map (foo 2) "abc"
06:47:51 <lambdabot>   ["aa","bb","cc"]
06:47:59 <sbrg> > let foo n c = replicate n c in concatMap (foo 2) "abc"
06:47:59 <lambdabot>   "aabbcc"
06:48:07 <sbrg> guess I don't need foo etc
06:48:23 <koeien> Ivoz: also, your functions can be generalized to arbitrary lists, not just String
06:48:44 <sbrg> Ivoz: you're not allowed to use standard functions?
06:48:51 <sbrg> as in, is the exercise to implement them yourself?
06:49:00 <Ivoz> well he hasn't told us to research prelude yet
06:49:08 <koeien> sbrg: then (++) would also be disallowed, I suppose
06:49:14 <Ivoz> following the haskell road to logic, maths and programming
06:49:36 <Ivoz> koeien: he told us about  (++) just for this exercise
06:49:47 <hpc> koeien: so would [] in general :D
06:49:51 <sbrg> koeien: Yes yes, if you want to be pedantic, but you know what I mean
06:50:09 <koeien> sbrg: i don't see the essential difference between (++) and replicate tbh :/
06:50:17 <Jafet> Well, [] isn't a function
06:50:22 <Ivoz> the exercise is to write blowup :: String -> String
06:50:24 <Jafet> (:) is, though
06:50:34 <Ivoz> koeien: how do you replicate replicate with (++) ?
06:50:35 <Olathe> > let lengths :: [[a]] -> Integer; lengths = f 0 where f n [] = n; f n ([]:ys) = f n ys; f n ((_:xs):ys) = f (n + 1) (xs:ys) in lengths [[1, 2], [], [3, 4, 5]]
06:50:36 <lambdabot>   5
06:50:51 <koeien> Ivoz: i don't understand you?
06:50:52 <sbrg> Ivoz: which replicates each element in the string n times?
06:51:02 <Ivoz> sbrg: yar
06:51:19 <koeien> concatMap (replicate n)
06:51:32 <Ivoz> using (++)
06:51:44 <Ivoz> @src (++)
06:51:44 <lambdabot> []     ++ ys = ys
06:51:44 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
06:51:44 <lambdabot> -- OR
06:51:44 <lambdabot> xs ++ ys = foldr (:) ys xs
06:51:44 <koeien> concat = foldr (++) []
06:52:10 <Ivoz> @src concat
06:52:10 <lambdabot> concat = foldr (++) []
06:52:16 <Jafet> > let lengths = sum . (length .) in lengths [[1, 2], [], [3, 4, 5]]
06:52:17 <lambdabot>   5
06:52:30 <Ivoz> are you guys doing this book too?
06:52:50 <koeien> Ivoz: which book are you using?
06:53:00 <Ivoz> The Haskell road to logic, maths and programming
06:53:22 <Ivoz> Olathe and Jafet just >'ed some stuff relating to the exercises
06:53:25 <obiwahn> > replicateM 3 {1,0}
06:53:26 <lambdabot>   <no location info>: parse error on input `1'
06:53:54 <Olathe> > let blowup :: [a] -> [a]; blowup = f 1 1 where f _ _ [] = []; f n 0 (_:xs) = let n' = n + 1 in f n' n' xs; f n r xxs@(x:_) = x:f n (r - 1) xxs in blowup [1..5]
06:53:54 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5]
06:54:02 <obiwahn> > replicateM 3 [1,0]
06:54:03 <lambdabot>   [[1,1,1],[1,1,0],[1,0,1],[1,0,0],[0,1,1],[0,1,0],[0,0,1],[0,0,0]]
06:54:20 <obiwahn> from wich lib is replicateM?
06:54:35 <sbrg> @hoogle replicateM
06:54:35 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
06:54:35 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
06:54:35 <Axman6> Control.Monad
06:54:43 <sbrg> when in doubt, hoogle it
06:54:47 <koeien> try importing Control.Monad I think
06:54:49 <Ivoz> > let blowup :: [a] -> [a]; blowup = f 1 1 where f _ _ [] = []; f n 0 (_:xs) = let n' = n + 1 in f n' n' xs; f n r xxs@(x:_) = x:f n (r - 1) xxs in blowup "bang!"
06:54:50 <lambdabot>   "baannngggg!!!!!"
06:54:57 <koeien> it's in base
06:55:08 <sbrg> @hoogle Will I ever be loved?
06:55:08 <lambdabot> Parse error:
06:55:08 <lambdabot>   --count=20 "Will I ever be loved?"
06:55:08 <lambdabot>                                   ^
06:55:13 <sbrg> meh
06:55:23 <Jafet> @vixen will sbrg ever be loved?
06:55:24 <lambdabot> let's don't talk about that
06:55:28 <Ivoz> where you getting that from Olathe ?
06:55:39 <sbrg> @vixen will you love me?
06:55:39 <lambdabot> whoa whoa whoa, one question at a time!
06:55:43 <sbrg> o.o
06:55:46 <Olathe> Ivoz: Oh, I wrote it.
06:55:57 <Ivoz> just now, or previously?
06:56:23 <Olathe> Just now when I saw the paste.
06:56:46 <Axman6> Ivoz: if you've used haskell for a while, it's a pretty simple task :)
06:56:59 <Ivoz> nice
06:57:16 <sbrg> > "TR"
06:57:17 <lambdabot>   "TR"
06:57:18 <sbrg> ff
06:57:27 <Ivoz> so that's still 'technically' using a helper function f there?
06:57:32 <sbrg> > "TR" ++ repeat "OL"
06:57:33 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:57:33 <lambdabot>         against inferred type...
06:57:42 <Axman6> cycle
06:57:42 <sbrg> :t repeat
06:57:43 <lambdabot> forall a. a -> [a]
06:57:44 <sbrg> ah
06:57:45 <sbrg> yeah
06:57:52 <koeien> Ivoz: we're always using helper functions. I used replicate, for instance
06:57:52 <sbrg> > "TR" ++ cycle "OL"
06:57:52 <Axman6> > "TR" ++ cycle "OL"
06:57:53 <lambdabot>   "TROLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOL...
06:57:54 <lambdabot>   "TROLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOL...
06:57:57 <latros> ....
06:57:59 <latros> lol
06:58:00 <Ivoz> take 5 (repeat 'a')
06:58:03 <Axman6> @quote stereo
06:58:03 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
06:58:04 <Ivoz> > take 5 (repeat 'a')
06:58:05 <lambdabot>   "aaaaa"
06:58:07 <Olathe> Ivoz: Yep.
06:58:15 <bwright> If I am coming from typed lambda calculus to haskell how should I approach it?
06:58:16 <Olathe> Ivoz: Are you trying to do without?
06:58:29 <Ivoz> was seeing if it might be possible, yes
06:59:00 <SamB_XP> bwright: what implementation of typed lambda calculus have you been using?
06:59:49 <Olathe> > let lengths :: [a] -> Integer; lengths = foldl' (+) 0 . map genericLength in lengths [[1, 2], [], [3, 4, 5]]
06:59:50 <lambdabot>   Couldn't match expected type `a' against inferred type `[b]'
06:59:50 <lambdabot>    `a' is a ri...
06:59:59 <bwright> SamB_XP: No implementation. I have been just doing manual beta reductions, drawing my own type inferance trees exploring it, implementing datastructures such as lists on paper.
07:00:15 <SamB_XP> Haskell
07:00:21 <SamB_XP> is going to be a lot less work
07:00:24 <SamB_XP> ;-)
07:01:19 <Olathe> > let lengths :: [[a]] -> Integer; lengths = foldl' (+) 0 . map genericLength in lengths [[1, 2], [], [3, 4, 5]]
07:01:20 <lambdabot>   5
07:02:29 <bwright> I noticed haskell uses x:xs notation for lists I was wondering if it could be thought of the same as λx xs.λf n.f x (xs f n)
07:02:49 <Jafet> > let lengths = length . join in lengths [[1, 2], [], [3, 4, 5]]
07:02:50 <lambdabot>  Terminated
07:03:24 <Ivoz> Olathe: that's sumLengths
07:03:26 <Ivoz> :P
07:03:56 <Ivoz> @src join
07:03:56 <lambdabot> join x =  x >>= id
07:04:00 <Olathe> > let lengths :: [[a]] -> Integer; lengths = foldl' (+) 0 . map (foldl' (+) 0 . map (const 1)) in lengths [[1, 2], [], [3, 4, 5]]
07:04:02 <lambdabot>   5
07:04:08 <Olathe> Without genericLength
07:04:39 <Ivoz> lengths should return [2,0,3]
07:04:48 <Olathe> Oh, OK.
07:05:58 <Ivoz> bwright: you might like my book
07:06:41 <bwright> Ivoz: Link?
07:07:00 <ashp> someone needs to write a 'learn haskell the hard way' rip off of that python book so I can do lots of exercises :)
07:07:38 <Ivoz> bwright: info: http://homepages.cwi.nl/~jve/HR/ book: http://fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf (they're both googable)
07:07:59 <Olathe> > let blowup = concat . zipWith (\n -> take n . repeat) [1..] in blowup [1..5]
07:08:00 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5]
07:08:06 <Jafet> > let lengths = foldl' (.) id . map (foldl' (.) id . map (const succ)) in lengths [[1, 2], [], [3, 4, 5]] 0
07:08:08 <lambdabot>   5
07:08:26 <ashp> Ivoz: Oh this looks awesome.
07:08:52 <Olathe> That's pretty nice.
07:08:56 <Ivoz> it's haskell as applied mathematically and logically
07:09:06 <ashp> Considering I have no math beyond what I learnt when I was about 12 and that's one of my major weaknesses with trying to learn anything new like Haskell.. this is going to be an interesting read for me.
07:09:43 <Ivoz> ashp: there's "A gentle introduction to haskell" http://www.haskell.org/tutorial/ which apparently isn't really gentle
07:10:10 <Jafet> "A gentle introduction to Haskell for expert ML programmers"
07:10:11 <Ivoz> how's haskell at code golf?
07:10:17 <ashp> Ivoz: Ha, I noticed that!  I think your approach might be more interesting to me as generally with this stuff I grasp the basics just fine but it's the logic/math stuff that throws me.
07:10:51 <ashp> Ivoz: I've been running through learnyouahaskell just to make sure I grasp all the basic syntax/building blocks, then I was looking for where to go from there.  I don't expect to ever be a coder, this is just so my brain doesn't fail now I'm an ancient old man (at age 30)
07:11:32 <Ivoz> http://www.haskell.org/haskellwiki/Books_and_tutorials
07:11:52 <bwright> Ivoz: Thanks. I just figured out that \ means lambda in haskell I will see if I can replicate some of my knowledge with this.
07:15:09 <Jafet> Ivoz: generally inferior to perl
07:15:22 <sbrg> ashp: have a look at some of the practical examples at LYAH
07:15:26 <sbrg> like the rpn calculator and stuff
07:15:28 <Ivoz> haha D:
07:15:42 <sbrg> those are really cool examples that walk you through the process of design a working program for haskell
07:15:45 <sbrg> in haskell*
07:15:47 <vikramverma> In Graham Hutton's 'Programming in Haskell', he prints '\' as a lambda.
07:15:57 <vikramverma> That had me confused for a little bit.
07:16:11 <vikramverma> I mean, I tried using the unicode character.
07:16:17 <sbrg> ghc supports the unicode symbols for lambda and so on, does't it?
07:16:20 <sbrg> doesn't*
07:16:40 <vikramverma> I don't think it worked at the time, I'll try again.
07:16:47 <sbrg> > (λx -> id x) 1
07:16:48 <lambdabot>   Pattern syntax in expression context:
07:16:54 <vikramverma> It'll give me a reason to set a compose key ^_^.
07:17:08 <Jafet> Well, λ is actually a letter.
07:17:19 <Ivoz> ashp: \ p q -> p && (not q)
07:17:22 <Jafet> UnicodeSyntax will enable the reinterpretation.
07:17:47 <vikramverma> Jafet: Oh, excellent! I'll be doing this in future.
07:17:48 <sbrg> Jafet: extension?
07:18:06 <Jafet> Extension.
07:19:02 <Olathe> > (\x -> id x) 1
07:19:03 <lambdabot>   1
07:19:08 <Ivoz> > let a = \ p q -> p && (not q) in a True False
07:19:08 <lambdabot>   True
07:19:12 <Shigi> Hi guys, I've got a problem with binding of patterns of function's parameters - would you help me? The issue is to implement Dijkstra's algorithm so I have a directed graph, a start - vertex and I want to get all shortest path. My graph is already represented, just problem with binding..
07:19:23 <Ivoz> @src id
07:19:23 <lambdabot> id x = x
07:19:52 <Ivoz> Shigi: paste in hpaste.org
07:20:26 <Shigi> Ivoz: ok, I'll try xD
07:20:45 <sbrg> Do or do not!
07:20:47 <sbrg> There is no try!
07:21:37 <hpaste> Shigi pasted “Dijkstra” at http://hpaste.org/51185
07:24:28 <bwright> If I have some type say succ :: ChurchEncoding Nat -> ChurchEncoding Nat
07:25:10 <bwright> and I want to use that exact same "ChurchEncoding Nat -> ChurchEncoding Nat" for another func is that possible?
07:25:29 <bwright> (without manually specifying)
07:25:41 <Shigi> sbrg: I did ;) xD
07:26:27 <bwright> will it just work as I expect a :: succ -> someOtherType?
07:26:55 <dolio> succ is not a type in your example.
07:27:26 <sbrg> bwright: use a type synonym
07:27:27 <bwright> Oh I see ugh
07:27:29 <sbrg> if that's what you mean
07:27:35 <bwright> kk.
07:27:48 <sbrg> type Whatever = CurchEncoding Nat -> ChurchEncoding Nat
07:27:56 <sbrg> foo :: Whatever -> FooBar
07:29:33 <hpaste> “Mukesh Tiwari” pasted “STArray in State Monad” at http://hpaste.org/51186
07:29:58 <keep_learning> hello all
07:30:13 <keep_learning> i am trying to learn State monad
07:30:26 <keep_learning> i tried to put STArray as state
07:30:34 <keep_learning> but i am getting lot of errors
07:31:04 <keep_learning> could some one please tell me how to get rid of errors
07:32:46 <hpc> keep_learning: State isn't ST
07:32:57 <hpc> which are you trying to learn?
07:33:01 <brisingr> I've yet to learn state monad but that return on line 21 seems out of place
07:33:13 <brisingr> or not
07:33:23 <Ivoz> can you use case with pattern matching?
07:33:25 <bwright> For example say I want to write  λn f x.f(n f x) in haskell. Can I just say succ = \n f x -> f(n f x)?
07:33:45 <latros> I think the name succ is taken
07:33:51 <latros> in Enum
07:34:04 <latros> yes, you can, ivoz, that's pretty much the point
07:34:14 <rwbarton> aside from that, yes
07:34:20 <hpc> keep_learning: i know just enough about the types of all those things to know that code is a mess of type errors; i don't know enough to help you fix it though
07:34:24 <keep_learning> hpc, Just trying to pass STArray
07:34:39 <latros> ST is an entirely different animal from State
07:34:47 <latros> I'm not sure why you would use them in combination, really
07:35:25 <Ivoz> so case is just another form of if else?
07:35:33 <keep_learning> hpc, what i am trying is , first i am creating a STArray and calling a function [ buildPair ] from which i am return a pair
07:35:35 <latros> uh
07:35:46 <sbrg> Ivoz: so to speak
07:35:47 <latros> I don't think you can use if-then-else with pattern matching without a language extension
07:36:07 <brisingr> Ivoz: case is the if...else of pattern matching
07:36:23 <sbrg> brisingr: ERAGON!
07:36:26 <latros> keep_learning: why are you using ST in the first place
07:36:29 <sbrg> wow, now I feel sad.
07:36:39 <Ivoz> > let succ = \n f x -> f(n f x)  in succ 1 1
07:36:40 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1)
07:36:40 <lambdabot>    arising from a use of ...
07:36:44 <Saizan> Ivoz: if/then/else is a specialization of case to Bool
07:37:02 <keep_learning> latros, Nothing special , i was reading this http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays
07:37:05 <Saizan> Ivoz: if b then x else y = case b of True -> x; False -> y
07:37:09 <brisingr> brisingr >>= object
07:37:13 <Ivoz> > let succ = \n f x -> f(n f x)  in succ (+) 1
07:37:14 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
07:37:30 <keep_learning> and tried to mix state and STArray
07:37:31 <latros> yeah, you don't use State and ST at the same time for stuff like this
07:37:40 <latros> ST has its own state modification functions
07:38:10 <Ivoz> > let succ = \n f x -> f(n f x)  in succ 1 (+) 1
07:38:10 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
07:38:10 <lambdabot>    arising from a use of `...
07:38:20 <latros> you can't use the name succ
07:38:30 <Ivoz> > let s = \n f x -> f(n f x)  in s 1 (+) 1
07:38:30 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
07:38:31 <lambdabot>    arising from a use of `...
07:38:34 <brisingr> you can overload it
07:38:42 <brisingr> if you really want to
07:38:44 <latros> not sure it would have the right type
07:38:54 <latros> anyway
07:39:00 <keep_learning> latros, Lets say i have a STArray which i pass to function and do modification and return it
07:39:07 <Ivoz> > (1+) 1
07:39:08 <lambdabot>   2
07:39:13 <Ivoz> > let s = \n f x -> f(n f x)  in s 1 (1+) 1
07:39:13 <latros> > let successor = \n f x -> f(n f x)
07:39:14 <lambdabot>   2
07:39:14 <lambdabot>   not an expression: `let successor = \n f x -> f(n f x)'
07:39:22 <latros> oh
07:39:23 <keep_learning> so would it not be good to use it as state in State monad
07:39:23 <latros> right
07:39:31 <Ivoz> > let s = \n f x -> f(n f x)  in s 1 (1x) 1
07:39:32 <lambdabot>   1
07:39:35 <keep_learning> latros, i am just curious
07:39:35 <Ivoz> > let s = \n f x -> f(n f x)  in s 1 (1*) 1
07:39:36 <lambdabot>   1
07:39:41 <latros> you can do all that in ST
07:40:00 <Ivoz> > let s = \n f x -> f(n f x)  in s 1 (2*) 1
07:40:01 <lambdabot>   2
07:40:04 <keep_learning> latros, no need to use State monad at all ?
07:40:08 <latros> at least, as far as I know, I'm not very good with ST
07:40:13 <latros> not *in combination* with ST, no
07:40:19 <Ivoz> > let s = \n f x -> f(n f x)  in s (3+) (2*) 1
07:40:20 <lambdabot>   10
07:40:23 <latros> ST is sort of the sledgehammer of stateful computation
07:40:33 <Ivoz> bwright: > let s = \n f x -> f(n f x)  in s (3+) (2*) 1
07:40:52 <Ivoz> is how I understand what you wanted to do
07:41:07 <hpaste> “Mukesh Tiwari” pasted “Primes generation using IOArray” at http://hpaste.org/51187
07:41:25 <Ivoz> > let s = \n f x -> f(n f x)  in s 3 (2*) 1
07:41:26 <lambdabot>   6
07:41:31 <keep_learning> latros, see this http://hpaste.org/51187
07:41:45 <Ivoz> > (2*)(3)
07:41:46 <lambdabot>   6
07:41:50 <Ivoz> > (2*)(2 3)
07:41:50 <latros> what about it
07:41:51 <lambdabot>   4
07:41:54 <keep_learning> latros, i have generated prime using IOArray
07:42:01 <latros> ok
07:42:03 <keep_learning> latros, so i have to pass it and again return it
07:42:05 <latros> not sure why you would do that, but ok
07:42:27 <keep_learning> latros, so i think this array can be used as state in State monad
07:42:28 <latros> yeah, you can do the transformations inside the same monad
07:42:33 <keep_learning> so no explicit passing
07:42:40 <latros> oh you mean without explicit passing, hm
07:42:40 <Ivoz> bwright: what was the lambda function you wrote supposed to do
07:42:47 <latros> see, I suspect that's gonna be a problem
07:42:48 <latros> because
07:42:53 <latros> the state modifications in ST
07:42:54 <keep_learning> latros, just learning and playing
07:42:59 <latros> use the ST monadic functions
07:43:08 <latros> which are not really functions per se but rather actions
07:43:13 <Ivoz> bwright: I take it as meaning apply f to param x, then apply n, then apply f
07:43:15 <latros> whereas State expects regular function application
07:43:24 <latros> (in its >>=, that is)
07:44:24 <keep_learning> latros, is it something related State Monad Transformer ?
07:44:42 <latros> uh, sorta
07:45:00 <keep_learning> latros, thank you
07:45:20 <keep_learning> latros, i will try to learn state monad transformer
07:45:36 <latros> I don't think State and ST are going to stack very well, though
07:45:57 <Ivoz> is any and all, like multiple ||'s and &&'s, respectively?
07:46:24 <hpc> :t any
07:46:25 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:46:30 <koeien> Ivoz: yes.
07:46:34 <koeien> @src any
07:46:34 <lambdabot> any p =  or . map p
07:46:35 <latros> @src ||
07:46:35 <lambdabot> True  || _ =  True
07:46:35 <lambdabot> False || x =  x
07:46:37 <latros> er
07:46:41 <latros> @src any
07:46:41 <lambdabot> any p =  or . map p
07:46:48 <koeien> Ivoz: it also applies a predicate
07:46:49 <latros> @src all
07:46:49 <lambdabot> all p =  and . map p
07:46:53 <hpc> or = foldr (||) True
07:46:53 <latros> that's disappointing
07:46:54 <koeien> > all (>0) [1,2,3,-2]
07:46:54 <lambdabot>   False
07:47:07 <hpc> er, foldr... False
07:47:14 <hpc> and = foldr (&&) True
07:47:14 <dolio> @type ala Any foldMap
07:47:15 <lambdabot> Not in scope: `foldMap'
07:47:16 <latros> I was expecting them to do a foldr
07:47:25 <latros> er, it
07:47:42 <hpc> latros: it is, but after mapping the predicate over the list
07:48:00 <latros> oh, right right
07:48:01 <latros> nvm
07:48:09 <FredOverflow> What is the desugared version of "var <- exp"? That is, how does that look outside of do notation?
07:48:17 <Ivoz> oh so I'm thining of 'and' and 'or'
07:48:17 <koeien> FredOverflow: exp >>= \var -> ...
07:48:17 <latros> exp >>= (var -> ...)
07:48:32 <latros> parens aren't necessary here, as koeien points out
07:48:35 <koeien> @undo do { x <- [1..2]; return (x*2) }
07:48:35 <lambdabot> [1 .. 2] >>= \ x -> return (x * 2)
07:48:52 <FredOverflow> Ah, it's just bind then.
07:48:55 <Ivoz> what's >>=
07:49:01 <latros> depends on the monad
07:49:06 <FredOverflow> :t (>>=)
07:49:07 <Ivoz> :[
07:49:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:49:09 <koeien> FredOverflow: yes, almost. (except for "fail")
07:49:15 <bwright> Ivoz: I was trying to implement succ     λnfx.f (n f x)
07:49:21 <Ivoz> that looks complicated
07:49:24 <koeien> FredOverflow: do { x <- Nothing; return 3 }
07:49:46 <hpc> :t \n f x -> f (n f x)
07:49:47 <lambdabot> forall t t1 t2. ((t1 -> t2) -> t -> t1) -> (t1 -> t2) -> t -> t2
07:49:47 <latros> if you ignore the forall bit, it's not quite so bad
07:50:03 <koeien> Ivoz: first you'd need to know what a typeclass is
07:50:09 <latros> but yeah you would need that much
07:50:13 <FredOverflow> How can lambdabot show me the >>= implementation for lists?
07:50:20 <koeien> @src (>>=) []
07:50:20 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:50:21 <hpc> @src [] (>>=)
07:50:21 <lambdabot> xs >>= f     = concatMap f xs
07:50:29 <koeien> argh, inverted. but it's flip concatMap
07:50:34 <FredOverflow> :t concatMap
07:50:34 <hpc> @src concatMap
07:50:34 <lambdabot> concatMap f = foldr ((++) . f) []
07:50:35 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
07:50:41 <FredOverflow> :t concat . map
07:50:42 <lambdabot>     Couldn't match expected type `[[a]]'
07:50:42 <lambdabot>            against inferred type `[a1] -> [b]'
07:50:42 <lambdabot>     Probable cause: `map' is applied to too few arguments
07:50:48 <koeien> :t (concat.).map
07:50:49 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
07:51:20 <FredOverflow> :t concat
07:51:21 <lambdabot> forall a. [[a]] -> [a]
07:51:22 <FredOverflow> :t (concat .)
07:51:22 <bwright> can a type declaration be reused in another type declaration?
07:51:22 <lambdabot> forall a (f :: * -> *). (Functor f) => f [[a]] -> f [a]
07:51:34 <latros> what do you mean, bwright?
07:51:45 <koeien> bwright: use a type synonym. or use a,b,c :: t -> u
07:51:56 <bwright> koeien: Thanks that solves the problem.
07:52:03 <latros> oh, k
07:52:06 <latros> now I see
07:52:38 <Ivoz> bwright: natural numbers are much simpler than successor functions :3
07:52:40 <bwright> koeien: What if c :: t -> u -> r?
07:53:08 <koeien> bwright: that's very different from t -> u
07:53:32 <bwright> koeien: Sure.
07:53:38 <Ivoz> bwright: that's a function which takes the function (t -> u) and produces r
07:53:49 <koeien> bwright: but if you want to reuse "parts" of the definition, I'd go for a type synonym
07:53:51 <latros> uh
07:53:51 <latros> no
07:53:53 <latros> no it isn't
07:53:57 <Ivoz> gah.
07:54:00 <latros> -> is not left associative
07:54:19 <koeien> Ivoz: no, a->b->c means a -> (b -> c)
07:54:25 <Ivoz> yeah
07:54:35 <Ivoz> just returned to that page in my book
07:54:36 <koeien> e.g. (+) :: Integer -> (Integer -> Integer), so (+1) :: Integer -> Integer
07:54:44 <Ivoz> right associative.
07:54:46 <Ivoz> >_<
07:55:01 <Kaidelong> (1+) is what I think you meant
07:55:08 <latros> both work
07:55:09 <koeien> Kaidelong: yeah
07:55:14 <koeien> (+) 1
07:55:26 <latros> although yeah I see why you would want (1+) for the clarification
07:55:37 <latros> how does the type system deal with sections like that btw
07:55:38 <latros> like (/3)
07:55:46 <koeien> flip (/) 3
07:55:48 <latros> ...
07:55:49 <latros> oh
07:55:50 <latros> yeah
07:55:53 <latros> carry on
07:55:54 <latros> >.>
07:56:48 <bwright> So your saying + is a function that takes an integer and return a function that takes an integer and returns an integer.
07:56:55 <latros> yep
07:57:00 <Ivoz> good spotting
07:57:09 <Ivoz> it's notated as (+)
07:57:24 <bwright> Yes alright. So this is exactly the same notation I am familiar with awesome!
07:57:27 <koeien> yes. (ignoring type classes)
07:57:44 <Ivoz> (+) is prefix form of + which is infix
07:58:14 <Kaidelong> ah ML guy?
07:58:27 <Ivoz> lambda calculus guy
07:58:29 <ion> > ("o hai" `length`)
07:58:29 <lambdabot>   5
07:58:34 <latros> unrelated, has anyone ever run into a conceptual monad that you can't actually write in codee
07:58:36 <latros> *code
07:58:41 * latros ran into this last night :(
07:58:55 <Kaidelong> Haskell is a kind of lambda calculus afaik
07:58:57 <Ivoz> that's sounds like I never want to run into one
07:58:59 <bwright> So it follows this rule. s :: α ⇒ β and t :: α then (s t) :: β
07:59:00 <Kaidelong> not church's one
07:59:09 <Ivoz> *that
07:59:12 <latros> continuous probability distributions form a nice monad...conceptually
07:59:26 <bwright> for (s t) to make sense s must be a function, t must be the right type for the function.
07:59:33 <latros> but then inverse functions and differentiation pop up in fmap, and the >>= is just completely wtf
07:59:48 <Kaidelong> latros: Well, there is that silly thing with Haskell sets not being monads
07:59:50 <koeien> yes, we write f :: a -> b and x :: a, then (f x) :: b
07:59:58 <latros> hm, true
08:00:25 <ion> koeien: Isn’t that what he wrote?
08:00:40 <latros> also, haskell's type system is a lot more restrictive than the typed lambda calculus iirc
08:00:49 <koeien> ion: yes, but the ? suggests something different to me.. like _
08:01:02 <Kaidelong> well which typed lambda calculus?
08:01:03 <ion> What ‘?’?
08:01:10 <Kaidelong> I think Haskell and ML are based on System F
08:01:28 <koeien> ion: maybe my terminal is borked then
08:01:44 <Kaidelong> oh
08:01:50 <latros> I used "the typed lambda calculus" which I think is used to refer to the least axiomatically restricted one
08:01:51 <Kaidelong> a restricted subset of system F
08:01:56 <Kaidelong> okay
08:01:58 <bwright> koeien: For a slightly more complex example in that case.
08:02:38 <latros> anyway, backing up a sec, it's irritating that continuous distributions don't seem to make a computational monad
08:02:44 <latros> while discrete ones make a beautiful computational monad
08:02:48 <latros> =/
08:02:54 <monochrom> there is actually no least axiomatically restricted typed one, i.e., if you think you have a least one, I can weaken its axioms a little bit further
08:03:12 <latros> you can't do an infimum sort of thing on that?
08:03:18 <monochrom> I can
08:03:23 <latros> then...do that?
08:03:28 <latros> then you have the least restricted one
08:03:33 <ion> Ah, he did use ⇒ instead of →. Perhaps my font should be bigger. I’m IRCing from the sofa meters away from the monitor. :-P
08:03:52 <monochrom> whereas if you go untyped, then it's already least restricted
08:03:52 <bwright> koeien: Given part of the y combinator \f x. f x x :: (T1 => T1 => T2) => T1 => T2
08:04:24 <Kaidelong> latros: Pretty sure the way distributions are done in Data.Random.Distribution
08:04:28 <monochrom> well then, I guess untyped is a degenerate special case of typed, so untyped is the least one and I can't weaken it further
08:04:29 <Kaidelong> lets them form a monad
08:04:32 <Kaidelong> even the continuous ones
08:04:36 <latros> oh?
08:04:37 <bwright> koeien: Will haskell be able to resolve the types as [f <- T1 => T1 => T2 x <- T1]
08:04:41 <bwright> koeien: Will haskell be able to resolve the types as [f <- T1 => T1 => T2, x <- T1]
08:04:47 <latros> maybe they do a different fmap from what I was thinking of then
08:05:04 <koeien> :t (\f x -> f x x) -- :(
08:05:04 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t1
08:05:05 <navaati> hi
08:05:13 <Ivoz> koeien: that ? (to you?) was a double sided arrow, I think
08:05:21 <Ivoz> *double line
08:05:23 <monochrom> oh, misread, cannot do an infinum, unless you go untyped
08:05:35 <latros> huh
08:05:36 <latros> k
08:05:52 <bwright> koeien: But can it resolve f and x?
08:05:58 <Kaidelong> wait no I misread
08:05:59 <bwright> koeien: Individually?
08:06:01 <latros> also
08:06:03 <Kaidelong> RVar is a monad
08:06:03 <latros> kaidelong
08:06:07 <Kaidelong> Distribution is not
08:06:08 <latros> oh
08:06:09 <latros> k
08:06:40 <Kaidelong> but an RVar is a lot like a distribution
08:07:14 <ion> bwright: Haskell uses ⇒ for type constraints, e.g. «f :: (Num a) ⇒ a → a» is a function from any Num to a value of the same type.
08:07:17 <latros> yeah I know what a random variable is, although this implementation is somewhat opaque
08:07:20 <Kaidelong> not sure how RVar/Distribution in random-fu relate to the mathematical idea of a distribution
08:07:24 <latros> idk what PromptT is, for example
08:07:24 <Kaidelong> or a random variable
08:07:38 <latros> but, well
08:07:40 <latros> here was my problem
08:07:56 <monochrom> it doesn't look very promising to relate haskell to system f. haskell has letrec; system f doesn't. haskell has type constructors (e.g., Maybe a), system f doesn't. system Fω has type constructors but still no letrec.
08:07:58 <ion> bwright: «f :: (Num a) => a -> a» in ASCII.
08:08:26 <latros> if X has pdf f, then g(X) has pdf h(y) =  f(g^(-1)(y))*|dg^(-1)(y)/dy|
08:08:32 <navaati> i have an indetation error with this http://pastebin.com/M7TetkC3 and i don't know why
08:08:34 <latros> which requires g to be invertible and differentiable
08:08:34 <mauke> The paste M7TetkC3 has been copied to http://hpaste.org/51188
08:08:44 <bwright> ion: oh ok.
08:08:45 <navaati> can someone here figure it out ?
08:08:46 <latros> you can relax the invertibility
08:08:52 <latros> but
08:08:54 <latros> yeah
08:09:01 <Axman6> navaati: are you using tabs?
08:09:04 <monochrom> but then of course system F and system Fω have impredicativity but haskell doesn't, at least not directly
08:09:27 <navaati> no, only spaces
08:10:36 <Kaidelong> hmm wellyou can use Distribution values as RVar values anyway
08:10:43 <Kaidelong> and thus use them like a monad if you want
08:11:49 <latros> perhaps they're doing something somewhat different, then
08:11:52 <latros> I suspect they must be
08:12:02 <latros> because there's no way they compute that density function
08:12:23 <latros> they didn't put a computer algebra system in there for this >.>
08:12:37 <latros> even if they did there are obstacles if you try to relax the requirement that g is invertible
08:14:27 <latros> ...prompt-based computation
08:14:34 <latros> ok, yeah, they're doing something completely unrelated to what I'm doing
08:18:42 <merijn> Does anyone know how/when Network.HTTP does encoding (if it does encoding to begin with). There is a "Request String" type, but obviously it can't send the string directly
08:20:36 <sbrg> merijn: I'm can't answer your question but I personally prefer using http-enumerator. network.http has a strange inconsistent interface and was in a few cases quite bugged for me
08:22:33 <merijn> sbrg: I'll check out http-enumerator then, I guess
08:24:50 <hpaste> “Shigi @ Miroslav Siagi” pasted “A draft for Dijkstra's algorithm” at http://hpaste.org/51189
08:25:34 <Shigi> Now, it's alright xD
08:32:00 <merijn> @hoogle String -> ByteString
08:32:00 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
08:32:00 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
08:32:00 <lambdabot> Prelude read :: Read a => String -> a
08:32:31 <merijn> > read "Test" :: ByteString
08:32:32 <lambdabot>   Not in scope: type constructor or class `ByteString'
08:32:39 <merijn> > read "Test" :: Data.ByteString
08:32:40 <lambdabot>   Not in scope: type constructor or class `Data.ByteString'
08:33:18 <Jafet> > show (BS.pack . map (toEnum.ord) $ "Test")
08:33:20 <lambdabot>   "\"Test\""
08:33:32 <merijn> I don't suppose there are ByteString literals for when I just have ASCII?
08:33:48 <Jafet> OverloadedStrings?
08:34:29 <merijn> Ah, nvm. I fail at reading package documentation apperently
08:34:41 <merijn> What I really wanted was
08:34:53 <Jafet> > read (show "Test") :: BS.ByteString
08:34:54 <lambdabot>   "Test"
08:35:04 <merijn> > Network.HTTP.Types.methodPost
08:35:04 <lambdabot>   Not in scope: `Network.HTTP.Types.methodPost'
08:35:50 <Jafet> > read (show "Téşt") :: BS.ByteString
08:35:51 <lambdabot>   "T\233_t"
08:36:02 <Jafet> Ew, Char8!
08:36:02 <Olathe> @type read (show "Test") :: BS.ByteString
08:36:02 <Olathe> :t read (show "Test") :: BS.ByteString
08:36:03 * Olathe knocks on lambdabot.
08:36:03 <lambdabot> BSC.ByteString
08:36:03 <lambdabot> BSC.ByteString
08:37:00 <Olathe> lambdabot is out of order!
08:45:12 <Shigi> how can I get "Int.Max" value in haskell?
08:45:24 <rwbarton> > maxBound :: Int
08:45:24 <lambdabot>   9223372036854775807
08:45:28 <Shigi> thx xD
08:46:21 <monochrom> > maxBound :: Float
08:46:22 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
08:46:22 <lambdabot>    arising from a use of...
08:46:31 <monochrom> oh well
08:46:47 <koeien> Shigi: be aware that Integer exists. it is an unbounded integer type
08:46:54 <koeien> for a lot of purposes it's better than Int
08:47:07 <Jafet> Like manipulating lists!
08:47:18 <Jafet> @instances Bounded
08:47:18 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
08:48:34 * Jafet skipped a heartbeat reading "Any".
08:49:30 <Saizan> heh
08:49:36 <Shigi> koeien: yeah, thx, I know :) I just needed a big number
08:49:49 <ddarius> 2^64-1 isn't big.
08:50:06 <ion> > [minBound..maxBound] :: [Any]
08:50:06 <lambdabot>   No instance for (GHC.Enum.Enum Data.Monoid.Any)
08:50:06 <lambdabot>    arising from the arithme...
08:50:07 <koeien> try graham's number
08:50:11 <ion> err
08:50:14 <monochrom> > let {f 0 n = n+1; f m 0 = f (m-1) 1; f m n = f (m-1) (f m (n-1))} in f 3 8
08:50:14 <ion> > [minBound,maxBound] :: [Any]
08:50:15 <lambdabot>   [Any {getAny = False},Any {getAny = True}]
08:50:17 <lambdabot>   2045
08:50:23 <monochrom> > let {f 0 n = n+1; f m 0 = f (m-1) 1; f m n = f (m-1) (f m (n-1))} in f 3 10
08:50:26 <lambdabot>   mueval-core: Time limit exceeded
08:50:27 <rostayob> graham's number seems to be a #haskell meme ehee
08:50:30 <monochrom> oops!
08:52:55 <ion> > fix (\a -> encodeFloat (floatRadix a ^ floatDigits a - 1) ((snd . floatRange) a - floatDigits a)) :: Double  -- big float
08:52:59 <lambdabot>   1.7976931348623157e308
08:53:33 <ddarius>  > (fix (\a -> encodeFloat (floatRadix a ^ floatDigits a - 1) ((snd . floatRange) a - floatDigits a)) :: Double) < 1/0
08:53:36 <latros> A(A(g64,g64),A(g64,g64))
08:53:37 <ddarius> > (fix (\a -> encodeFloat (floatRadix a ^ floatDigits a - 1) ((snd . floatRange) a - floatDigits a)) :: Double) < 1/0
08:53:39 <lambdabot>   True
08:54:57 <ion> -- big finite float :-P
08:56:00 <monochrom> @tell chrisdone (time is about Sat 16:45 UTC) http://tryhaskell.org/haskell.json?method=eval&expr=1&contents=x=1 gives 500 Internal Server Error /usr/local/nginx/html/res/282900212246248657150608266957210177231347297243624398343184.hs: openFile: does not exist (No such file or directory)
08:56:00 <lambdabot> Consider it noted.
08:56:28 <byorgey> oh, looks like it's just missing 282900212246248657150608266957210177231347297243624398343184.hs
08:56:37 <byorgey> I think I have a copy of that one here
08:57:03 <bayesian> L O L
08:57:39 <ion> > fix (encodeFloat 1 . liftA2 (-) (fst . floatRange) floatDigits) :: Double  -- Small positive, non-zero float
08:57:41 <lambdabot>   5.0e-324
08:58:44 <hvr> does anyone here know whether the Haskell Report actually defines how to reduce an expression such as "(\x -> 1 + x) 2" down to 3?
08:59:51 <ddarius> hvr: There is only one possible reduction of that under any order.
09:00:17 <hvr> ddarius: yes... but I'm missing any reference to something like beta-reduction or similiar
09:01:11 <Phyx-> isn't that more evaluation than reduction?
09:01:41 <ddarius> The Report doesn't say what how to evaluate anything, just what the meaning should be, and even then is severly lacking.
09:02:00 <hvr> ddarius: what do you mean by 'meaning'?
09:02:05 <ddarius> I doubt the Report says that (+) is addition so hoping for 3 is just fanciful whimsy on your part.
09:02:33 <ddarius> The Report tends to characterize things denotationally to the extent that it characterizes them at all.
09:03:16 <hvr> ddarius: what I'm actually after is the meaning of 'seq'
09:03:35 <byorgey> hvr: well, why didn't you say so =)
09:03:37 <hvr> ddarius: I tried to ask on SO : http://stackoverflow.com/questions/7372120/is-x-x-equal-under-seq-to-x-or-nothing-at-all
09:03:56 <hvr> byorgey: does that change everything? ;)
09:04:14 <dolio> seq _|_ x = _|_, seq y x = x for y /= _|_
09:04:44 <hvr> dolio: yeah, but when does an expression actually "mean" _|_ ?
09:06:05 <hvr> "seq" must have some means to 'reduce' the expression
09:06:17 <monochrom> when the expression has no information. "let x=x in x" is an example
09:06:20 <hvr> in order to be ever able to return its second argument
09:06:40 <dolio> How seq works in practice is implementation specific.
09:06:43 <hpc> @src seq
09:06:43 <lambdabot> Source not found. Are you on drugs?
09:06:47 <byorgey> hvr: an expression means _|_ when it reduces to _|_.
09:07:02 <byorgey> hvr: note that  \x -> _|_  cannot reduce.
09:07:03 <hvr> byorgey: isn't that undecidable in general? :)
09:07:38 <hpc> hvr: it doesn't have to decide
09:07:41 <byorgey> hvr: yes.  But note that it is perfectly acceptable for seq to diverge if its first argument does.
09:07:49 <byorgey> so seq does not have to decide anything, only semi-decide
09:07:53 <hpc> hvr: it just has to be defined for defined inputs, and then what byorgey said
09:07:56 <hvr> byorgey: yeah, I understand that
09:08:01 <monochrom> I think you are still refusing to accept that the haskell report does not talk about reduction, evaluation, all that
09:08:16 <hvr> hpc: and how does seq detect that the input is defined? which rules may be applied?
09:08:27 <monochrom> if you want to talk about reducing, pick a compiler first
09:08:44 <hpc> hvr: we don't care; the implementation decides how, and we just see the properties it has
09:08:52 <hpc> hvr: and the report defines those properties
09:09:50 <byorgey> well, I think hvr's point is that the report doesn't even formally answer the question: when is an expression equivalent to _|_ ?
09:09:53 <hvr> monochrom: are you saying the report doesn't tell me wether 'seq (undefined 1) ()` returns () or _
09:09:56 <hvr> |_ ?
09:10:08 <byorgey> implicitly, the answer seems to be that it considers beta-equivalence only, NOT eta-equivalence
09:10:38 <hvr> byorgey: yeah, that's what I'm trying to, thanks :-)
09:11:14 <hpc> the other way to think of it is, the lambda is a constructor for functions and application is the destructor
09:11:21 <hpc> to use a different data type, you have
09:11:23 <hpc> g :: Maybe a
09:11:26 <hpc> g = undefined
09:11:32 <hpc> f = Just (fromJust g)
09:12:17 <hpc> g = _|_, f = Just _|_
09:12:30 <hpc> in the same way that your g = _|_ but your f = \_ -> _|_
09:12:31 <monochrom> the report tells you that seq (undefined 1) () is _|_
09:13:12 <byorgey> hvr: re: your comments on SO, I think the answer to your question "where does the report specify whether eta-conversion is used for reduction" is precisely where it says "_|_ is not the same as \x -> _|_"
09:13:12 <hpc> seq f () would yield Just (THUNK) in my example
09:13:21 <byorgey> hvr: that implies it cannot use eta-reduction.
09:13:23 <hpc> and in your example, would yield \x -> (THUNK)
09:13:53 <monochrom> the report says how to obtain _|_ when doing pattern matching
09:14:30 <hvr> monochrom: does `seq` do pattern matching on its first argument?
09:14:38 <monochrom> not specified
09:14:43 <hpc> hvr: it does magic on the first argument
09:14:59 <hpc> afaik there isn't a way to write seq in plain haskell
09:15:06 <hpc> maybe with a bang pattern?
09:15:08 <dolio> That's why it's baked in.
09:15:44 <monochrom> you can use a bang pattern to get seq, but then you have to ask how to implement bang patterns
09:15:57 <koeien> bang patterns are desugared using seq again...
09:16:13 <hpc> hehe
09:16:27 <dolio> The only way you could define seq in Haskell 98 would be to use data S a = S !a.
09:16:29 <monochrom> similarly, you can use strictness annotation in data declarations to obtain seq, but then it begs the same question
09:16:38 <merijn> It's bangs all the way down!]
09:16:38 <dolio> But those ! are specified in terms of seq, I believe.
09:17:18 <monochrom> yeah, the way the report puts it, "S !a" is translated to something involving $!, which is a seq again
09:17:42 <hvr> monochrom: \x -> S $! x
09:17:42 <monochrom> to be fair, you could consider either one fundamental and the other derived
09:18:10 <hvr> monochrom: \x -> (S $! x)
09:18:55 <dolio> The only possibly missing thing appears to be that fix f = _|_ if f is strict.
09:19:03 <dolio> Since they use fix in some desugaring.
09:19:27 <dolio> You may be expected to know that from fix being described as the "least fixpoint operator."
09:20:28 <monochrom> they say their "fix" is least fixed point. if you further assume the common knowledge of denotational semantics, CPOs, etc, that is enough to derive e.g., "let x=x in x" is another way to get ⊥
09:20:50 <monochrom> "where fix is the least fixpoint operator"
09:21:10 <hvr> so... the Haskell Report also doesn't mention anything about any WHNF?
09:21:31 <any-key> I'm having an issue with typeclasses with the following code if anyone wants to tell me what I'm doing wrong: http://pastebin.com/MbfcaHAd
09:21:33 <mauke> The paste MbfcaHAd has been copied to http://hpaste.org/51191
09:23:22 <roconnor> anyone here build wxHaskell?
09:23:34 <roconnor> what version of wxwidgets is needed?
09:25:44 <byorgey> any-key: are you intending for isTriangular to be called on integral values only?
09:26:02 <any-key> Yes
09:26:04 <ddarius> hvr: There is no requirement to stop evaluating at WHNF.
09:26:23 <hvr> ddarius: what is the minimum requirement?
09:26:23 <byorgey> any-key: you cannot take the square root of integral values, you must convert to a floting-point value first
09:26:30 <ddarius> hvr: Non-strictness.
09:26:35 <monochrom> it probably can get away with being neutral about "is (\x -> blah) in WHNF?" because as far as denotational semantics is concerned, that doesn't matter. the only question is "(\x -> blah) = ⊥ true or false?", and the sentence "Since Haskell is a non-strict language" says false.
09:26:37 <byorgey> any-key: so instead of rowSize = (-1+sqrt(8*size+1))/2,  use  rowSize = (-1+sqrt(8*fromIntegral size+1))/2
09:26:48 <any-key> byorgey: thanks
09:26:56 <any-key> that makes sense
09:27:10 <byorgey> any-key: also, comparing floating point values to 0.0 is usually a mistake
09:27:24 <byorgey> any-key: because you could have  0.0000000000000001 or something
09:28:00 <any-key> good point
09:28:18 <any-key> but for integers it's always going to be 0.0
09:28:24 <ddarius> Comparing integers to zero is usually a mistake because you could have 10.
09:28:51 * ddarius advocates treating floating point like an insane algebraic structure.
09:28:57 <any-key> it is
09:29:24 <ddarius> any-key: It is but people pretend that it is an approximation to the real numbers.
09:29:58 <hpc> ddarius: it's an insane algebraic approximation of the real numbers ;)
09:30:18 <hvr> monochrom: what I'm still abit confused is that "_|_ :: a -> a" albeit being typed a lambda abstraction is already deemed non-terminating
09:30:54 <dolio> That isn't a lambda abstration.
09:31:13 <ddarius> \x -> _|_ and _|_ are distinct in Haskell.
09:31:21 <monochrom> s/typed a lambda abstractin/typed a function type/
09:32:17 <monochrom> "let {f :: a->a; f = f} in f
09:32:49 <hvr> ok... but I couldn't ever pattern match against something like 'a->a'?
09:33:26 <monochrom> correct, apart from the non-strict pattern "variable"
09:33:31 <dolio> So?
09:34:18 <latros> actually, they should be distinct pretty much everywhere
09:34:24 <latros> (\x -> _|_ and _|_)
09:34:25 <latros> hell
09:34:41 <latros> \x -> _|_ is instantiated
09:34:47 <latros> _|_ is not
09:34:47 <hvr> dolio: this was just a thought because for 'normal' values, I could use pattern matching do detect _|_ w/o seq, but for functions this isn't possible
09:35:19 <dolio> That's why seq is defined specially by the report.
09:36:52 <ddarius> latros: If what you mean is that they have different types, I mean _|_ at a function type.
09:36:55 <monochrom> seq is the only way to tell you have a ⊥ for a function. without seq, well you can tell as a mathematician at the meta level, but you can't write a program to tell it
09:37:25 <taotree> Could someone help me implement this function::    mkDyn :: (Typeable a) => ((a -> IO()) -> IO ()) -> ((Dynamic -> IO()) -> IO ())
09:37:26 <ddarius> Can I tell as a plumber at the meta level?
09:37:43 <meditans> @type ((>1) . gcd)
09:37:44 <lambdabot> forall a. (Integral a) => a -> Bool
09:37:45 <latros> oh
09:37:53 <latros> nvm, now I see what you're doing
09:38:30 <hvr> monochrom: curiously, 'seq' doesn't help me detect seq 'K _|_' () == _|_  for data K = K !Int !Int
09:38:32 <monochrom> plumber alone doesn't even know CPOs :)
09:38:47 <meditans> i really don't unterstand the ghci response when I ask for the type of ((>1).gcd)
09:39:03 <meditans> which imho has to be a -> a -> Bool
09:39:06 <ddarius> CPO is far simpler than hydrodynamics and plumbing codes.
09:39:08 <latros> no
09:39:09 <copumpkin> @type ((>1) .) . gcd)
09:39:10 <lambdabot> parse error on input `)'
09:39:10 <latros> because
09:39:11 <hvr> monochrom: maybe plumber is a poor math student?
09:39:15 <copumpkin> @type ((>1) .) . gcd
09:39:16 <lambdabot> forall a. (Integral a) => a -> a -> Bool
09:39:19 <latros> it'll pass 1 arg
09:39:20 <latros> to gcd
09:39:25 <latros> and then try to pass the result to (>1)
09:39:31 <latros> but the result will be a function
09:39:41 <latros> if you want to pass two args first you need to do what copumpkin did
09:39:48 <copumpkin> @type (>1) .: gcd
09:39:49 <lambdabot> forall a. (Integral a) => a -> a -> Bool
09:40:03 <meditans> where can I learn about this?
09:40:12 <latros> about what?
09:40:13 <latros> .?
09:40:15 <latros> because
09:40:21 <latros> this is actually in the definition
09:40:21 <copumpkin> just by working through the definition of (.)
09:40:29 <monochrom> not about which is simpler. about which special education is received.
09:40:33 <latros> if your issue is with *currying*
09:40:41 <merijn> argh
09:40:41 <copumpkin> (.) f g = \x -> f (g x)
09:40:48 <latros> then virtually any piece of learning material will cover that
09:40:59 <monochrom> as for "what if the plumber is also blah blah", you should read that I wrote carefully "plumber alone"
09:41:04 <merijn> Why do the HTTP libraries make it so freaking impossible to print their Request instances? >.>
09:41:11 <meditans> but I unterstood the principle of currying
09:41:22 <copumpkin> meditans: you didn't work through it hard enough then ;)
09:41:33 <meditans> probably :D
09:41:43 <meditans> i'll try harder ;)
09:41:46 <latros> the definition (.) right there passes one arg to g before passing the result to f
09:42:04 * hvr is getting ravenous appetite for curry chicken
09:42:12 <latros> it is not a "general composition" operator that will take in all the args and then pass the result
09:42:28 <ddarius> It would be if we used tuples everywhere.
09:42:52 <latros> true
09:42:53 <meditans> ahhhh
09:42:54 <latros> but we don't
09:43:09 <copumpkin> :t curry ((>1) . uncurry gcd)
09:43:10 <lambdabot> forall a. (Integral a) => a -> a -> Bool
09:43:16 <latros> yeah
09:43:16 <meditans> ok.. I thougth about it as a "general composition" operator, as you said
09:44:11 <ddarius> meditans: Always go to the definitions.
09:44:27 <merijn> @hoogle Network.HTTP.Enumerator.Request a -> String
09:44:28 <lambdabot> Parse error:
09:44:28 <lambdabot>   --count=20 "Network.HTTP.Enumerator.Request a -> String"
09:44:28 <lambdabot>                     ^
09:44:52 <azaq23> @unpl \f g a b c -> (f . g) a b c
09:44:52 <lambdabot> \ f g a b c -> f (g a) b c
09:52:18 <merijn> @pl \x -> x *** x
09:52:18 <lambdabot> join (***)
09:53:20 <meditans> :D, thanks, I did it. Another answer than, which sounds a bit silly:
09:53:47 <meditans> when I write gcd a b, what kind of "operator" is space?
09:53:50 <meditans> I mean: why
09:54:00 <latros> gcd a b = (gcd a) b
09:54:09 <latros> does that help?
09:54:33 <meditans> can i write gcd a $ b but not gcd $ a b
09:54:36 <byorgey> meditans: space is the function application operator
09:54:47 <meditans> id est $?
09:55:11 <latros> no; $ is a low-precedence version of id
09:55:16 <latros> with a silly type constraint
09:55:17 <byorgey> meditans: gcd a $ b  means to apply (gcd a) to b.  gcd $ a b means to apply gcd to (a b)
09:55:25 <byorgey> meditans: but (a b) means apply the function a to b
09:55:35 <hvr> byorgey: ...the 'space operator' is quite overloaded ;)
09:55:55 <byorgey> hvr: well, that's true =)
09:57:56 <monochrom> when you're still learning, you should write "(gcd a) b" or "gcd a b" explicitly, and not jump to "$"
10:00:16 <_mmi_> Hi, is there any library for detecting a natural alnguage similar to https://github.com/feedbackmine/language_detector (ruby) or http://www.nltk.org (python)?
10:00:35 <monochrom> I think no
10:01:01 <dmwit> Can template-haskell be upgraded independently from GHC?
10:01:24 <byorgey> _mmi_: check out the libraries listed under http://hackage.haskell.org/package/#cat:natural%20language%20processing
10:01:33 <dmwit> (If I have two versions installed, is my installation broken?)
10:02:08 <byorgey> dmwit: I think I've had multiple versions installed at once.  But I think it depends which versions.
10:02:13 <aristid> atomicModifyIORef ftw
10:02:17 <monochrom> you will find something else broken, such as the "ghc" package (GHC API)
10:03:00 <dmwit> ghc-pkg check doesn't report any brokenness, but QuickCheck fails to build.
10:03:14 <meditans> ok I unterstood: in effect I could write (gcd$a)$b if I want. Now the question is: why $ has not the precedence so that I can write gcd$a$b?
10:03:17 <monochrom> "ghc-pkg check" is incomplete
10:03:24 <moriramar> Excuse me, as the man page of bindtextdomain says its second parameter should be an absolute path, is it the same with Distribution.Simple.I18N.GetText.bindTextDomain? What's the suggested way to handle this path when packages might be installed in different places? Thank you.
10:03:27 <dmwit> Let me try again (just finished reinstalling template-haskell); if it fails again I'll paste some output.
10:03:31 <monochrom> "ghc -v" is the trustworthy one
10:03:51 <aristid> meditans: because $ has the precedence so you can write foo $ 1 + 2
10:03:51 <monochrom> "cabal install -vvvvvvvvv" will also tell you nothing
10:04:10 <monochrom> (neither will "-v 1000000"
10:04:30 <dmwit> monochrom: I don't know how to read the output of ghc -v.
10:04:38 <dmwit> I can't tell if it's telling me there's a problem or not.
10:04:47 <monochrom> for the full story see my http://www.vex.net/~trebla/haskell/sicp.xhtml
10:04:48 <dmwit> What command's output should I paste to get help?
10:05:30 <monochrom> "package blahblah is unusable due to ..." is an error
10:05:33 <stribor> is there simple way to get if else in haskel
10:05:41 <latros> uh
10:05:47 <latros> guards is probably the prettiest way
10:06:04 <dmwit> stribor: if condition then branch1 else branch2
10:06:10 <meditans> yes, that is the precedence over +, but why $ is defined as infixr instead of infixl?
10:06:20 <dmwit> > if "Haskell" > "C" then "yup we're awesome" else "awww"
10:06:21 <lambdabot>   "yup we're awesome"
10:06:30 <latros> ...
10:06:32 <latros> lol
10:06:56 <byorgey> meditans: no one knows
10:06:57 <stribor> dmwit: so there is no difference ?
10:06:59 <dmwit> monochrom: ghc -v 2>&1 | grep -i usab
10:07:02 <dmwit> monochrom: gives no output
10:07:05 <dmwit> stribor: Hm?
10:07:12 <dmwit> stribor: No difference between what and what?
10:07:27 <stribor> dmwit: you said if conditioon then branck 1 else branch 2
10:07:39 <meditans> :byorgey how can that be?
10:07:47 <dmwit> stribor: ...yes, and?
10:07:56 <stribor> dmwit:  nothing just wanna make sure:)
10:07:58 <dmwit> stribor: (I don't understand what you're asking, can you spell it out for me?)
10:08:32 <byorgey> meditans: presumably someone on the original Haskell Committee knows why they chose infixr for $.  But many people (including me) think it ought to be infixl instead.
10:08:34 <stribor> dmwit: is there difference between using guards vs if then else
10:08:47 <dmwit> stribor: Ah, yes, there's a difference.
10:08:57 <dmwit> stribor: Guards don't commit to a pattern unless they match.
10:09:03 <byorgey> meditans: since it is infixr you can write  f $ g $ h $ x, but that is not helpful because you can already write  f . g . h $ x
10:09:07 <byorgey> which is better style anyway.
10:09:08 <dmwit> stribor: Whereas "if" can only appear after a commit.
10:09:18 <stribor> dmwit: you lost me:)
10:09:33 <dmwit> stribor: Consider this definition
10:10:10 <dmwit> foo (Bar baz) | baz > 3 = "hi!"; foo (Quux a b c) = "yo!"; foo zap = "blegh"
10:10:32 <dmwit> stribor: If you were doing this with if/then/else, you'd have to duplicate "blegh" as follows:
10:10:49 <tromp> so in what cases would you write x $ y $ z when ($) is infixl?
10:10:50 <dmwit> foo (Bar baz) = if baz > 3 then "hi!" else "blegh"; foo (Quux a b c) = "yo!"; foo zap = "blegh"
10:11:12 <tromp> that is just x y z after all
10:11:23 <dmwit> tromp: It's the difference between (x y) z and x (y z).
10:11:26 <stribor> dmwit: thank you
10:12:05 <hpaste> dmwit pasted “can't install species!” at http://hpaste.org/51193
10:12:14 <tromp> ok, so you'd use it not for x y z but for to replace x (y z) with x $ y z
10:12:35 <monochrom> bad interface file?! file corruption?
10:12:40 <tromp> wait, i need multiple $
10:12:52 <dmwit> monochrom: I just finished manually re-installing template-haskell-2.4.0.1, so...
10:13:19 <dmwit> (via cabal install --reinstall template-haskell-2.4.0.1 in case that matters)
10:13:25 <tromp> to write x $ y z $ u v   instead of x (y z) $ u v
10:13:38 <dmwit> tromp: yes
10:13:45 <monochrom> template-haskell 2.4.0.1 is even older than what comes with ghc 7.0.3. are you sure you need it?
10:13:51 <dmwit> No.
10:13:56 <dmwit> I didn't install it on purpose.
10:14:07 <dmwit> Let's see what happens if I unregister it.
10:14:11 <copumpkin> SO
10:14:17 <copumpkin> who's excited for constraint kinds in 7.4!?
10:14:21 * copumpkin raises hand
10:14:35 <tromp> which of ($) and (.) has lower precedence?
10:14:38 <stribor> is this good way to test list   length xs == 0
10:14:49 <monochrom> it is a bad way
10:14:50 <dmwit> monochrom: Ah, it seems the version of species on hackage demands it. =P
10:14:54 <dmwit> byorgey: ping!
10:14:55 <copumpkin> tromp ($) has the lowest
10:15:00 <copumpkin> of everything
10:15:05 <copumpkin> tromp: in ghci, type :i ($)
10:15:08 <copumpkin> and :i (.)
10:15:20 <tromp> right. so now you can write a . b $ c . d $ e
10:15:35 <tromp> how would that be with infixl ($) ?
10:16:14 <tromp> dumb example:(
10:16:42 <tromp> ok, i see no point in infixr ($) either
10:17:02 <monochrom> why does "cabal install species" pull in QuickCheck?
10:17:57 <dmwit> Hm, now the numeric prelude isn't building.
10:18:00 <dmwit> blech
10:18:00 <monochrom> alright, because numeric-prelude etc pull in QuickCheck
10:18:38 <stribor> wats difference between if length xs == 0 vs null xs
10:18:54 <hpc> stribor: strictness
10:19:14 <stribor> hpc: ?
10:19:21 <hpc> null [1..] = False, (length [1..] == 0) = nontermination
10:19:25 <dmwit> stribor: Also, the former requires an Eq instance on the contained values, whereas the latter does not.
10:20:05 <stribor> iisnt that null xs more safer to test
10:20:31 <dmwit> Yes, for the reasons both hpc and I gave.
10:21:56 <monochrom> pattern matching is best
10:22:26 <Kaidelong> dmwit: What
10:22:42 <Kaidelong> length xs == 0 requires the values in xs to instantiate Eq?
10:22:42 <Kaidelong> why?
10:23:12 <monochrom> null is fine but I doubt that all you do to a list is asking null. if you do anything more, you may as well pattern-match
10:24:32 <dmwit> Kaidelong: ...it doesn't
10:24:45 <dmwit> Kaidelong: In my head I was comparing to xs == [] by accident.
10:25:01 <stribor> if i have definition myFunction :: Ord a => a -> [a] -> [a] versus myFunction::a->[a]->[a]........what is diference
10:25:24 <dmwit> stribor: The difference is that the latter may not do comparisons, like (<) or max.
10:25:25 <stribor> Puting Ord a in signature make sit comparable
10:25:28 <monochrom> the first one doesn't work for [id, id, id]
10:25:51 <dmwit> (However, the former may be applied to more things.)
10:25:55 <stribor> myFunction::a->[a]->[a] cant compare???
10:26:05 <monochrom> you could try
10:26:15 <dmwit> stribor: Correct.
10:26:27 <stribor> myFunction 2 [1,2,3]....why cant you compare that?
10:28:49 <monochrom> you should try and see. write your myFunction and see its inferred type
10:30:08 <ddarius> copumpkin: What are you going to do with constraint kinds?
10:30:31 <copumpkin> write instance Monad Set and then feel smug
10:30:44 <copumpkin> or maybe instance Monad U.Vector
10:30:50 <dmwit> eh... my Google-fu is failing me
10:30:57 <copumpkin> or just play with the crazy stuff
10:31:11 <copumpkin> data Proxy (ctxt :: * -> Constraint) = Proxy
10:31:13 <dmwit> What do I need to do for conditional compilation where the condition is which version of a Haskell library is being used?
10:31:47 <copumpkin> what would it mean to have constraint classes?
10:31:57 <dmwit> I vaguely recall something like #if NUMERIC_PRELUDE_VERSION >= 0.2.2 or something like that.
10:32:21 <copumpkin> class Moo (c :: Constraint) where
10:32:28 <copumpkin> instance Moo (Ord Int) where
10:32:45 <copumpkin> seems funky
10:32:45 <monochrom> have a lot of flags and if-then-else in the *.cabal file. contrary to typical programming language semantics, it is the then-branches and the else-branches that determine which flags are turned on, unless you override
10:34:27 <monochrom> I haven't used it myself. see the cabal manual and existing *.cabal files for details and examples
10:34:30 <ddarius> copumpkin: A class is a predicate.  It would simply be a higher order predicate.
10:34:37 <copumpkin> yeah
10:34:47 <ddarius> What we need are associated classes or a generalization of such.
10:34:56 <copumpkin> it already supports that
10:35:01 <copumpkin> or what do you mean?
10:35:23 <copumpkin> type families can work over the Constraint kind too
10:35:44 <ddarius> Associated types let me put type declarations in a class.  Associated classes would let me put class declarations in a class.
10:36:38 <copumpkin> I can write instance Functor Set where type Ctx Set = Ord
10:36:55 <copumpkin> you want to declare entire new classes in there?
10:37:01 <ddarius> copumpkin: Yes.
10:37:12 <copumpkin> :O
10:37:22 <dmwit> Found it, it's #if MIN_VERSION_numeric-prelude(blah,blah,blah).
10:38:50 <ciaranm> constraint kinds exist?
10:38:58 * ciaranm needs something like that
10:39:07 <copumpkin> yes, they'll be in 7.4
10:39:22 <ciaranm> is there documentation?
10:44:14 <ddarius> I guess a type parameterized class could just be lambda lifted making A -> B -> Bool be (A, B) -> Bool.
10:44:44 <bayesian> haskjell can never felel love
10:44:56 <bayesian> so whybring it to life
10:44:59 <ddarius> Which I guess was what I was thinking the other day, though it may still be useful and nice to have associated classes like associated types.
10:45:27 <dmwit> Hm, perhaps fixing this is beyond my ken.
10:46:54 <bayesian> guys
10:47:13 <ddarius> copumpkin: Essentially we can do first class modules today, except since we can't put classes in classes and we'd be using classes as modules, we wouldn't be able to put classes in modules, though we could put modules in modules.  That said, how classes should work in the face of first class modules isn't entirely clear.
10:47:19 <bayesian> "you are a believer in the promise of functional programming. And suppose more and more FP features and FP languages are becoming mainstream. Does this mean nothing remains to be done?"
10:47:47 <ddarius> bayesian: Is this a choose your own adventure story?
10:48:01 <bayesian> :D
10:50:30 <byorgey> You are in a maze of twisty programming languages, all alike.
10:50:46 <byorgey> There is a bayesian here.
10:50:59 <ion> CLispScript the game
10:51:23 <hpc> byorgey: you have been eaten by a Mu
10:51:30 * ddarius makes the most boring but efficient choose-your-own adventure story.  2^N stories in just 3N pages.
10:51:45 <byorgey> hehe =)
10:52:05 <ddarius> Well I could make it even more boring and/or efficient, but I feel -that- would be cheating.
10:52:07 <byorgey> hpc: You have scored 0 out of a possible 9223372036854775807 points.
10:54:53 <ian__> I have a list of Bools, ex. [True, False, False, True]
10:55:04 <ddarius> ian__: That's a strange thing to have.
10:55:10 <tomh> anyone here knows how to use the yaml objects package from hackage?
10:55:10 <ian__> rly
10:55:13 <ddarius> Though I guess that's all a number usually is.
10:55:24 <hpc> ian__: get another list and see if they breed
10:55:50 <ian__> I want to efficiently calculate what percentage of the elements are True at position n
10:55:58 <ian__> ex. at index 0 100% are True
10:56:03 <ian__> index 1 50% are True
10:56:28 <ian__> So I want to end up with something like [1.0, 0.5, 0.333...]
10:56:59 <ian__> I came up with a solution using 'zip' but it sucked
10:57:12 <ddarius> > scanl (\b acc -> if b then acc else acc/2) 1.0 [True, False, False, True]
10:57:12 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Bool.Bool)
10:57:12 <lambdabot>    arising from a use o...
10:57:21 <ddarius> > scanl (\acc b -> if b then acc else acc/2) 1.0 [True, False, False, True]
10:57:22 <lambdabot>   [1.0,1.0,0.5,0.25,0.25]
10:57:36 <ddarius> Ah yes, I need to count too.
10:57:46 <byorgey> ian__: you mean what percentage of elements are true *up to* position n?
10:57:53 <ian__> yeah
10:57:55 <dmwit> > scanl (\(ts, fs) b -> if b then (ts+1,fs) els (ts,fs+1)) (0, 0) [True, False, False, True]
10:57:55 <lambdabot>   <no location info>: parse error on input `)'
10:58:14 <dmwit> > scanl (\(ts, fs) b -> if b then (ts+1,fs) else (ts,fs+1)) (0, 0) [True, False, False, True]
10:58:15 <lambdabot>   [(0,0),(1,0),(1,1),(1,2),(2,2)]
10:58:55 <dmwit> > map (\(ts, fs) -> ts / (ts + fs)) $ scanl (\(ts, fs) b -> if b then (ts+1,fs) else (ts,fs+1)) (0, 0) [True, False, False, True]
10:58:55 <lambdabot>   [NaN,1.0,0.5,0.3333333333333333,0.5]
10:59:16 <ian__> thanks
10:59:34 <dmwit> Remember the StackOverflow motto: never use code you don't understand.
10:59:51 <ion> :(){:|:;};:
10:59:51 <ddarius> dmwit: Hypocrites.
11:00:10 <ian__> i understand it but i thought there'd be a more concise solution
11:00:14 <byorgey> > map (flip (uncurry (/))) . scanl1 (sum *** sum) (0,0) . map ((,) 1 . fromEnum) $ [True, False, False, True]
11:00:14 <lambdabot>   Couldn't match expected type `([a], [a1]) -> ([a], [a1])'
11:00:14 <lambdabot>         against i...
11:00:48 <rwbarton> would it really kill lambdabot to print the rest of that second line
11:00:56 <byorgey> > map (uncurry (flip (/))) . scanl1 (sum *** sum) (0,0) . map ((,) 1 . fromEnum) $ [True, False, False, True]
11:00:57 <lambdabot>   Couldn't match expected type `([a], [a1]) -> ([a], [a1])'
11:00:57 <lambdabot>         against i...
11:01:02 <ddarius> Well, if you make a concise running average then you could do byorgey's thing and runningAverage . map fromEnum
11:01:12 <ddarius> (well fromIntegral . fromEnum)
11:01:28 <dmwit> I like that.
11:01:33 <tomh> no one haskell and yaml experience? :/
11:01:33 <byorgey> > map (uncurry (flip (/))) . scanl1 (sum *** sum) . map ((,) 1 . fromEnum) $ [True, False, False, True]
11:01:34 <lambdabot>   Couldn't match expected type `([a], [a]) -> ([a], [a])'
11:01:34 <lambdabot>         against inf...
11:01:38 <dmwit> ddarius++
11:02:00 <byorgey> oh, sum *** sum doesn't work, boo
11:02:13 <hpc> :t (sum *** sum)
11:02:14 <lambdabot> forall c a. (Num c, Num a) => ([c], [a]) -> (c, a)
11:02:30 <byorgey> man, sum *** sum is super wrong
11:02:40 <byorgey> not only did I actually mean  (+) *** (+), that doesn't even work anyway
11:02:48 <byorgey> there's no nice way to lift binary functions to work over tuples
11:03:11 <ddarius> Of course, runningAverage is just the same function with a different monoid.
11:03:49 <ciaranm> aren't tuples functors?
11:04:04 <mux> yeah but they map only the first component
11:04:16 <mux> > (+1) (2,3)
11:04:17 <lambdabot>   (3,4)
11:04:21 <mux> well, not.
11:04:32 <mux> oh
11:04:39 <mux> > (+1) `fmap` (2,3)
11:04:39 <lambdabot>   (2,4)
11:04:47 <mux> so, they map only the second component
11:04:53 <ddarius> @src scanl
11:04:53 <lambdabot> scanl f q ls = q : case ls of
11:04:53 <lambdabot>     []   -> []
11:04:53 <lambdabot>     x:xs -> scanl f (f q x) xs
11:04:59 <monochrom> > (a,b) + (c,d)
11:05:00 <lambdabot>   (a + c,b + d)
11:05:04 * mux wonders where that Num instance for tuples comes fm
11:05:05 * monochrom cringes
11:05:10 <mux> from*
11:05:11 <dmwit> > (($) &&& ($)) (((+) &&& (+)) (1, 2)) (3, 4)
11:05:11 <lambdabot>   Couldn't match expected type `t1 -> t'
11:05:11 <lambdabot>         against inferred type `(a ->...
11:05:11 <hpc> you might want arrowapply
11:05:15 <mux> is that Caleskell again?
11:05:34 <ddarius> No, it's vector-space
11:05:43 <dmwit> ack
11:05:49 <mux> that's handy
11:05:56 <rwbarton> > (a,b) * (c,d)
11:05:56 <lambdabot>   (a * c,b * d)
11:06:08 <ciaranm> that doesn't look like a vector space
11:06:09 <dmwit> Neat! *shutter click*
11:06:12 <monochrom> > (5,6) `div` (2, 3)
11:06:13 <lambdabot>   No instance for (GHC.Real.Integral (t, t1))
11:06:13 <lambdabot>    arising from a use of `e_156...
11:06:48 <ddarius> @let scanlM = scanlM' mempty where scanlM' q ls = q : case ls of [] -> []; x:xs -> scanlM' (mappend q x) xs
11:06:49 <lambdabot>  Defined.
11:06:51 <ddarius> :t scanlM
11:06:51 <lambdabot> forall a. (Monoid a) => [a] -> [a]
11:07:09 <ddarius> > ala Sum scanlM [1..10]
11:07:09 <lambdabot>   Couldn't match expected type `o -> Data.Monoid.Sum o'
11:07:09 <lambdabot>         against infer...
11:07:16 <ddarius> :t ala
11:07:17 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
11:07:56 <ddarius> > ala Sum scanlM [Sum 1..Sum 10]
11:07:57 <lambdabot>   Couldn't match expected type `o -> Data.Monoid.Sum o'
11:07:57 <lambdabot>         against infer...
11:08:02 <ddarius> > scanlM [Sum 1..Sum 10]
11:08:03 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Monoid.Sum t))
11:08:03 <lambdabot>    arising from a use o...
11:08:14 <ddarius> > scanlM (map Sum [1..10])
11:08:16 <lambdabot>   [Sum {getSum = 0},Sum {getSum = 1},Sum {getSum = 3},Sum {getSum = 6},Sum {g...
11:09:05 <hpaste> dmwit pasted “Num constraints missing” at http://hpaste.org/51195
11:09:12 <dmwit> byorgey: Have you seen errors like that before?
11:09:30 <ddarius> Too bad I can't define new types or instances in lambdabot
11:09:30 <dmwit> (I'm trying to update np-extras to numeric-prelude-0.2, since numeric-prelude-0.1.3.4 doesn't build for me.)
11:11:15 <igstan> Is there a ghci equivalent to the @src command used here?
11:11:22 <dmwit> No.
11:11:37 <dmwit> However, Hoogle will link to documentation that lets you look at source code.
11:11:38 <ddarius> igstan: You could try to get GoA working.
11:12:15 <dmwit> (Note that GoA won't give you access to the source of things ?src doesn't have.)
11:12:31 <ddarius> Which would be even more equivalent to @src no?
11:12:45 <monochrom> real source code is not equivalent to @src
11:12:51 <rostayob> igstan: you can just use the haddock docs
11:13:05 <monochrom> (to have an equivalent to @src, you have to make stuff up)
11:13:23 <rostayob> but yeah the snippets in @src are examples of simple implementations
11:13:23 <ddarius> @src (++)
11:13:23 <lambdabot> []     ++ ys = ys
11:13:23 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
11:13:23 <lambdabot> -- OR
11:13:23 <lambdabot> xs ++ ys = foldr (:) ys xs
11:13:51 <monochrom> (and also to omit stuff)
11:13:54 <igstan> oh, I thought it actually displays the real implementation
11:14:13 <hpaste> ion pasted “Running average with a monoid” at http://hpaste.org/51196
11:14:24 <rostayob> igstan: nope. again haddock does quite a good job whenyou want to browse the source
11:14:57 <ddarius> ion: Exactly.
11:15:08 <igstan> rostayob: I use haddock, but I think a :src command in ghci would improve things. for me at least
11:15:29 <rostayob> igstan: well ghci itself doesn't know about the source
11:15:59 <ddarius> Though Average 1 should probably be a primitive and Average (softly) hidden.
11:16:07 <rostayob> there are modes for emacs/vim to jump to definitions in haddock
11:16:09 <ddarius> Also, you'd want more !s.
11:16:16 <ion> ddarius: yeah
11:16:50 <ddarius> Note that type Average a = (Sum Integer, Sum a) already is this Monoid instance.
11:17:05 <ion> Good point.
11:17:15 <monochrom> ghci throws away source code after compilation
11:17:34 <monochrom> although, the debugger part  kind of retrieves the source code again
11:17:38 <hpaste> ciaranm pasted “snail” at http://hpaste.org/51197
11:17:48 <ciaranm> there's got to be a nice way of doing ^^. and i can't see it...
11:18:01 <ddarius> > map (uncurry $ flip (/)) . scanl mappend mempty . map ((,) 1 . fromIntegral . fromEnum) $ [True, False, False, True]
11:18:02 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:18:02 <lambdabot>    `Data.Monoid.Monoid a'
11:18:02 <lambdabot>  ...
11:19:09 <ddarius> Sum needs to derive everything that numbers typically have.
11:20:23 <tomberek> is there a GADT or type-way to prevent a constructor from being used, so ONLY a smart constructor can be used?  (other than just not exporting it)
11:21:18 <ion> map (\(Sum c, Sum s) -> s/c) . scanl mappend mempty . map ((,) (Sum 1) . Sum . fromIntegral . fromEnum) $ [True, False, False, True]
11:21:22 <ion> > map (\(Sum c, Sum s) -> s/c) . scanl mappend mempty . map ((,) (Sum 1) . Sum . fromIntegral . fromEnum) $ [True, False, False, True]
11:21:23 <lambdabot>   [NaN,1.0,0.5,0.3333333333333333,0.5]
11:21:57 <monochrom> data X where NoUse :: H -> X. do not export H or anything that builds an H. then NoUse can be exported but unusable in practice. unless someone does NoUse undefined. oh well. is there a way to make it strict?
11:22:15 <bayesian> tomberek, obviously not, how would you implement the smart constructor?
11:22:44 <tomberek> bayesian: i couldn't think of a way
11:22:50 <tomberek> monochrom: one sec... parsing...
11:23:05 <bayesian> so prove that it's impossible
11:23:06 <monochrom> tomberek means s/used/used by users/
11:23:26 <rwbarton> the idea is you want to allow pattern matching on it but not constructing values with it?
11:23:40 <tomberek> rwbarton: yes, i think
11:24:14 <monochrom> you will have to use view patterns for that. it means you design yet another data type
11:24:21 <tomberek> yes, though I'd be ok with 'smart' deconstructor, I'm just curious how it would be done, I think monochrom's idea might work
11:24:45 <ddarius> > let snail n = snail' 0 where snail' k n = [k+1..l]:transpose (snail' l (n-1) ++ [[l+1..l+n-1]]) where l = k+n in snail 4
11:24:45 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> [[t]])
11:24:45 <lambdabot>    arising from a use ...
11:24:53 <bayesian> > let smartcons x y k | even x = k x y ; car cons = cons (\x y -> x) in car (smartcons 2 3)
11:24:54 <lambdabot>   2
11:24:55 <monochrom> or you provide a "fold" function
11:24:56 <ddarius> > let snail n = snail' 0 n where snail' k n = [k+1..l]:transpose (snail' l (n-1) ++ [[l+1..l+n-1]]) where l = k+n in snail 4
11:24:59 <lambdabot>   [[1,2,3,4],[5,8,9*Exception: stack overflow
11:25:25 <tomberek> monochrom: GADTs allow strictness annotations   data X where NoUse :: !H -> X
11:25:36 <ddarius> At any rate, transpose would be the wrong function.
11:25:50 <ddarius> And I probably need a base case.
11:26:07 <tomberek> then again, that's still just an export/don't export trick, one level removed
11:26:07 <ciaranm> it's annoying because it looks like one of those things that should have a really elegant functional solution
11:26:23 <ciaranm> but doing it by repeated rotation ends up being horrible
11:27:15 <ddarius> Using lists is probably the wrong thing to do here too.
11:27:19 <tomberek> monochrom, bayesian: i want to make/ a constructor that has a monadic side-effect, so everytime it creates, it has a side effect
11:27:38 <monochrom> that's scary!
11:27:40 <tomberek> i just don't know how to disallow the un-side-effecting constructor
11:27:41 <roconnor> category-extras-0.53.5 failed during the building phase. The exception was:
11:27:43 <roconnor> ExitFailure 1
11:27:52 <copumpkin> it's deprecated
11:28:08 <roconnor> copumpkin: unfortunately that doesn't stop packages from depending on it :(
11:28:32 <roconnor> oh crap, duplicate instance declairations for MOnad (Either e)
11:29:10 <roconnor> damn you orphan instances :P
11:29:47 <monochrom> eh? hpaste no longer has expiration?
11:31:34 <tomberek> ok, how about this: type class constraints, I see these are being depreciated, can the desired effect be obtained with GADTs? (or any other way?)
11:31:55 <copumpkin> what was the desired effect?
11:32:07 <hpaste> asfdg annotated “snail” with “snail (annotation)” at http://hpaste.org/51197#a51198
11:32:16 <tomberek> copumpkin: so the class constraint doesn't pollute everything
11:32:26 <tomberek> but is just in the datatype declaration
11:32:27 <copumpkin> they didn't work that way
11:32:43 <tomberek> yeah, i know they had little effect
11:33:05 <tomberek> but that's what people assume when they first see them, then learn otherwise
11:33:14 <tomberek> can that effect be obtained?
11:33:52 <copumpkin> I think the typeclass constraint should pollute everything
11:34:06 <copumpkin> insert :: a -> Set a -> Set a
11:34:15 <copumpkin> Set has a secret Ord attached?
11:34:18 <copumpkin> that's kind of weird
11:34:18 <any-key> I've got another stupid question regarding type weirdness: let foo = map ( `replicate` True ) , and call "foo [1..3]"
11:34:28 <tomberek> hm...... yeah, the Set example and being unable to make it a Monad
11:34:36 <copumpkin> no, I mean in general
11:34:38 <any-key> It wants an int for replicate, but the type of [1..3] is Integer...
11:34:40 <copumpkin> hidden constraints are weird
11:35:00 <tomberek> but that's part of it, no?    ok, i guess that makes sense
11:35:11 <roconnor> when were either instances added to Control.Monad.Instances?
11:35:22 * roconnor is tempted to upload a new category-extras
11:35:56 <tomberek> roconnor: i would like that, i've learned a lot just by browsing through that stuff
11:36:13 <any-key> the goal is to end up with an array such as [[True],[True, True],[True,True,True]]
11:36:54 <any-key> So my problem is the fact that "[1..3]" returns an Integer rather than an Int
11:37:02 <tomberek> copumpkin, in that case, i would like to specialize certain MVector's to their unboxed versions (though I would suspect the Vector package does this already)
11:37:14 <rwbarton> No it doesn't
11:37:14 <roconnor> any-key: use fromInteger
11:37:20 <copumpkin> Data.Vector.Unboxed.Mutable ?
11:37:30 * Olathe presses any-key.
11:37:32 <tomberek> rwbarton: gar!!!
11:37:45 <tomberek> copumpkin, yeah
11:37:49 <rwbarton> tomberek: sorry, I was replying to any-key
11:37:58 <tomberek> oh
11:38:02 <tomberek> hope is alive!
11:38:06 <Olathe> > let foo = map (flip replicate True) in foo [1..3]
11:38:08 <lambdabot>   [[True],[True,True],[True,True,True]]
11:38:17 <rwbarton> :t [1..3]
11:38:17 <lambdabot> forall t. (Num t, Enum t) => [t]
11:38:26 <Olathe> > let foo = map (`replicate` True) in foo [1..3]
11:38:27 <lambdabot>   [[True],[True,True],[True,True,True]]
11:38:29 <hpaste> adfadsf annotated “snail” with “snail (annotation) (annotation)” at http://hpaste.org/51197#a51199
11:39:14 <any-key> Thanks guys!
11:39:15 <ion> any-key: As rwbarton showed, number literals are polymorphic.
11:39:28 <any-key> yeah
11:39:57 <any-key> still getting a feel for TypeClasses :\
11:40:02 <rwbarton> you must actually have a definition like "let x = [1..3]" and either the type of x is constrained by some other use or you're encounting defaulting/the monomorphism restriction/ghci peculiarities
11:40:04 <Melvar> Huff. Apparently a caseless letter counts as lowercase for identifiers.
11:41:07 * hackagebot Ansi2Html 0.9 - Convert ANSI Terminal Sequences to nice HTML markup  http://hackage.haskell.org/package/Ansi2Html-0.9 (JensStimpfle)
11:44:11 <roconnor> @tell edwardk I'm going to uploade category-extras 0.53.5.1 to hackage.
11:44:11 <lambdabot> Consider it noted.
11:44:35 <tomberek> dang, it looks like Vector does NOT automatically use the Unboxed version
11:44:43 <copumpkin> tomberek: yes it does
11:44:54 <copumpkin> but only if you use Data.Vector.Unboxed :)
11:45:03 <tomberek> not for mutable?
11:45:26 <copumpkin> http://hackage.haskell.org/packages/archive/vector/0.9/doc/html/Data-Vector-Unboxed-Mutable.html
11:46:53 <tomberek> arg!!!, but then you have Unbox a on everything, and I'm back to the problem with desiring disappearing constraints
11:48:33 <tomh> anyone knows how to resolve this error on mac: <command line>: can't load .so/.DLL for: stdc++ (dlopen(libstdc++.dylib, 9): image not found)
11:48:48 <copumpkin> tomberek: that's the only way it can be done
11:48:52 <copumpkin> without constraints, types are parametric
11:48:57 <copumpkin> which means you can't know what they are
11:49:01 <copumpkin> and can't unbox :P
11:49:31 <copumpkin> I really don't see the issue with carrying constraints around
11:49:37 <tomberek> copumpkin: there's no way to specialize, ie. use the Data.Vector.Mutable as default and use the Data.Vector.Unboxed.Mutable when it is 'unboxable'
11:49:38 <copumpkin> they're not just there for shits and giggles
11:49:55 <copumpkin> no, that wouldn't be parametric, and it's not always what you want either
11:49:57 <tomberek> copumpkin: i'd like to make it a Functor instance, can't do that with the constraint
11:50:09 <copumpkin> yes, that's an issue with functor, not with the constraint
11:50:13 <roconnor> Distribution quality warnings:
11:50:15 <roconnor> 'ghc-options: -O2' is rarely needed.
11:50:15 <tomberek> oh
11:50:19 <roconnor> Is that really true
11:50:25 <roconnor> I always use -O2
11:50:30 <copumpkin> roconnor: fail
11:50:39 <roconnor> what should I be using?
11:50:41 <roconnor> -O
11:50:46 <ddarius> > let snail n = snail' n (1,1) (n, n) where snail' n (ulc, ulr) (lrc, lrr) p@(i, j) | j == ulr = i | i == lrc = n+j-1 | j == lrr = 3*n - j - 1 | i == ulc = 4*n - i - 2 | otherwise = snail' (n-2) (ulc+1, ulr+1) (lrc-1, lrr-1) p; makeSnail n = [[snail n (i,j) | i <- [1..n]] | j <- [1..n]] in makeSnail 4
11:50:47 <lambdabot>   Not in scope: `makeSnail'
11:50:54 <tomberek> copumpkin, so this is a known issue with Functor, and Monad by extension? what is the standard solution?
11:51:12 <copumpkin> tomberek: it's an issue that haskell can't really fix cleanly right now
11:51:14 <copumpkin> @hackage rmonad
11:51:14 <lambdabot> http://hackage.haskell.org/package/rmonad
11:51:20 <copumpkin> that has a workaround with different classes
11:51:21 <ddarius> > let snail n = snail' n (1,1) (n, n) where { snail' n (ulc, ulr) (lrc, lrr) p@(i, j) | j == ulr = i | i == lrc = n+j-1 | j == lrr = 3*n - j - 1 | i == ulc = 4*n - i - 2 | otherwise = snail' (n-2) (ulc+1, ulr+1) (lrc-1, lrr-1) p; } makeSnail n = [[snail n (i,j) | i <- [1..n]] | j <- [1..n]] in makeSnail 4
11:51:22 <lambdabot>   <no location info>: parse error on input `makeSnail'
11:51:30 <ddarius> > let snail n = snail' n (1,1) (n, n) where { snail' n (ulc, ulr) (lrc, lrr) p@(i, j) | j == ulr = i | i == lrc = n+j-1 | j == lrr = 3*n - j - 1 | i == ulc = 4*n - i - 2 | otherwise = snail' (n-2) (ulc+1, ulr+1) (lrc-1, lrr-1) p; }; makeSnail n = [[snail n (i,j) | i <- [1..n]] | j <- [1..n]] in makeSnail 4
11:51:31 <lambdabot>   [[1,2,3,4],[13,2,3,5],[13,2,4,6],[7,7,7,7]]
11:51:57 <copumpkin> GHC 7.4 supports new features that will make it possible to write functor/monad classes that would let you make Data.Vector.Unboxed instances for them
11:51:58 <roconnor> what value should I use for the base dependency?
11:52:04 <roconnor> how do I tell what version of base I'm using?
11:52:06 <copumpkin> but that doesn't mean the classes will be updated immediately :P
11:52:07 <copumpkin> or ever
11:52:17 <byorgey> roconnor: ghc-pkg list base
11:52:24 <copumpkin> I'm sure huge quantities of bikeshedding will have to occur
11:52:27 <copumpkin> before the classes get changed
11:52:42 <ciaranm> ddarius: that's horrible!
11:52:48 <roconnor> byorgey: that didn't work :(
11:53:09 <tomberek> copumpkin: hm..... there always seems talk or rewriting many classes.  Seems like it almost requires a complete overhaul now that people have experimented and learned.
11:53:27 <tomberek> but it would break a lot
11:53:38 <copumpkin> possibly :) although with the new features existing instances should not break
11:53:45 <copumpkin> if you added a default constraint of ()
11:54:31 <tomberek> hm... is there any penalty from using rmonad? seems like wrapping it still allows use of do-notation
11:54:46 <hpaste> monochrom pasted “Two Face” at http://hpaste.org/51201
11:54:58 <ddarius> > let snail n = snail' 0 n (1,1) (n, n) where { snail' b n (ulc, ulr) (lrc, lrr) p@(i, j) | j == ulr = b+i | i == lrc = b+n+j-1 | j == lrr = b+3*n-i-1 | i == ulc = b+4*n-j-2 | otherwise = snail' (4*n-4) (n-2) (ulc+1, ulr+1) (lrc-1, lrr-1) p; }; makeSnail n = [[snail n (i,j) | i <- [1..n]] | j <- [1..n]] in makeSnail 4
11:54:58 <copumpkin> tomberek: you don't get to use the constraint unless you pattern match on the witness first
11:54:59 <lambdabot>   [[1,2,3,4],[12,14,15,5],[11,15,16,6],[10,9,8,7]]
11:55:02 <DonGruby> http://dongruby.minitroopers.com
11:55:16 <monochrom> tomberek: the paste is a way to abstract a type and still let users read its values
11:55:29 <tomberek> monochrom: ooooh, very cool
11:55:30 <monochrom> actually two ways to read its values
11:55:30 <tomh> anyone with macosx snow leopard can try to install JsonGrammar?
11:55:36 <byorgey> roconnor: it didn't?  why not?
11:55:46 <roconnor> maybe something to do with nixos
11:56:22 <tomberek> copumpkin: dang, i'm foiled at every turn
11:56:25 <byorgey> roconnor: what did it actually do?
11:56:41 <copumpkin> tomberek: :)
11:56:42 <roconnor> print a small list of packages I have, none of which were base
11:56:49 <byorgey> bizarre
11:57:12 <byorgey> roconnor: how about  ghc-pkg list | grep base ?
11:57:24 <roconnor> nothing
11:57:28 <roconnor> probably a nixos thing
11:57:29 <ddarius> > let snail n = snail' 0 n (1,1) (n, n) where { snail' b n (ulc, ulr) (lrc, lrr) p@(i, j) | j == ulr = b+i' | i == lrc = b+n+j'-1 | j == lrr = b+3*n-i'-1 | i == ulc = b+4*n-j'-2 | otherwise = snail' (4*n-4) (n-2) (ulc+1, ulr+1) (lrc-1, lrr-1) p where i' = i-ulc+1; j' = j-ulr+1 }; makeSnail n = [[snail n (i,j) | i <- [1..n]] | j <- [1..n]] in makeSnail 4
11:57:30 <lambdabot>   [[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]]
11:57:43 <ddarius> Fertig.
11:57:43 <roconnor> it has a bunch of wrappers around all the ghc programs and things don't entirely work well
11:57:57 <byorgey> roconnor: I see.  does cabal-install work for you at all?
11:58:04 <dmwit> "up" and "dn" as opposites are absolutely sublime.
11:58:11 <roconnor> byorgey: only for things that don't depend on system packages
11:58:18 <byorgey> I see.
11:58:24 <byorgey> dmwit: haha, awesome =D
11:58:24 <ddarius> > makeSnail 3
11:58:26 <lambdabot>   [[1,2,3],[8,9,4],[7,6,5]]
11:58:43 <roconnor> damn it
11:58:49 <roconnor> phooey doesn't install
11:58:56 <byorgey> dmwit: if only they meant the opposite, they would even be pointing in the right directions =)
11:59:00 <roconnor> Configuring phooey-2.0...
11:59:01 <roconnor> Warning: No 'build-type' specified. If you do not need a custom Setup.hs or
11:59:03 <roconnor> ./configure script then use 'build-type: Simple'.
11:59:09 <roconnor> I've never had that error
11:59:14 <roconnor> what does it mean?
11:59:35 <ddarius> > snail 4 (10, 10)
11:59:36 <byorgey> roconnor: it means you need to add  'build-type: Simple' to the phooey.cabal file
11:59:37 <lambdabot>   -51
11:59:50 <byorgey> roconnor: last upload of phooey was from 2007, when there was no build-type: field
11:59:55 <roconnor> oh
12:00:04 <tomberek> monochrom: that's pretty cool, allows creation only via smart constructor, but also allows pattern match
12:00:11 <roconnor> I guess I'll have to update phooey too
12:00:13 <ddarius> > [[snail 3 (i,j) | i <- [0..4]] | j <- [0..4]]
12:00:14 <lambdabot>   [[-15,10,7,2,-19],[0,1,2,3,4],[7,8,9,4,11],[8,7,6,5,4],[-11,6,11,6,-7]]
12:00:25 <ciaranm> you make kitty scared
12:01:01 <byorgey> roconnor: what are you working on?
12:01:18 <roconnor> byorgey: Trying to install GuiTV
12:01:27 <roconnor> so I can make UI code
12:01:40 <jpcooper> could someone explain what it means that ((->) r) is a functor? What is (->) called?
12:01:44 <dmwit> byorgey: I'm having fun going through the entire species codebase (including np-extras) changing 0 to zero, 1 to one, and -1 to negate one everywhere.
12:01:47 <dmwit> =P
12:01:52 <monochrom> "No 'build-type' specified" means a very old *.cabal file format, i.e., old package
12:01:53 <roconnor> oh that build-type field thing is just a warning
12:02:05 <roconnor> src/Graphics/UI/Phooey/WinEvents.hs:66:7:
12:02:06 <roconnor>     Could not find module `Data.Reactive':
12:02:06 <ciaranm> jpcooper: ((->) r) is like "r ->"
12:02:08 <roconnor>       Use -v to see a list of the files searched for.
12:02:09 <roconnor> is more serious
12:02:43 <jpcooper> ciaranm: is that called a kind?
12:02:43 <roconnor> my build of reactive is too new
12:02:48 <ciaranm> jpcooper: functors need something of type * -> * , i.e. given a type, create a type.
12:02:58 <byorgey> dmwit: sounds like fun. why?
12:03:26 <ciaranm> jpcooper: as i recall the explanation in lyah is quite good
12:03:38 <rwbarton> (->) is called a type constructor
12:03:39 <tomberek> monochrom: I've had to re-read stuff about view patterns, they seem useful
12:03:41 <jpcooper> right, I'll have a look
12:03:42 <byorgey> jpcooper: (->) is the function type constructor, which we usually write infix, like  Int -> Bool
12:03:47 <rwbarton> at least in this context
12:03:52 <byorgey> but it can also be written (->) Int Bool
12:04:17 <jpcooper> okay, I didn't know that
12:04:30 <dmwit> byorgey: To make it build. Seems recent GHC's use GHC.Num.fromInteger even if you don't import Prelude.
12:04:37 <dmwit> ...or something
12:04:42 <jpcooper> it's not a function, though, is it?
12:04:49 <byorgey> dmwit: oh, I see.  thanks!
12:04:53 <dmwit> I don't know exactly what changed, just that it doesn't build, and doing this change seems to make it build. =P
12:05:08 <byorgey> dmwit: I've known for a while it's needed updating to build properly but haven't yet gotten around to it
12:05:10 <ddarius> dmwit: -fno-implicit-prelude is being used?
12:05:12 <ciaranm> jpcooper: it's a type constructor that, given a type, gives you a type. like [] is.
12:05:55 <ciaranm> jpcooper: if you've got [] , given a type a, you can create [a] . if you've got ((->) r) , given a type a, you can create r -> a .
12:06:00 <dmwit> ddarius: No, but {-# LANGUAGE NoImplicitPrelude #-} is.
12:06:02 <jpcooper> right
12:06:07 * hackagebot category-extras 0.53.5.1 - Various modules and constructs inspired by category theory  http://hackage.haskell.org/package/category-extras-0.53.5.1 (RussellOConnor)
12:06:07 <dmwit> I guess they're mostly the same.
12:06:29 <ddarius> > [[snail 1 (i,j) | i <- [0..2]] | j <- [0..2]]
12:06:31 <lambdabot>   [[-3,0,-5],[0,1,2],[-1,2,1]]
12:07:28 <roconnor> boo
12:07:42 <roconnor> my newly upload category-extras isn't marked as obsolate  :(
12:08:31 <ddarius> You've just broken everything.
12:08:46 <roconnor> I blame Hackage
12:08:46 <tomberek> roconnor, this happens sometimes, why can't I click on the modules?
12:08:59 <roconnor> tomberek: you mean for documentation?
12:09:04 <tomberek> ya
12:09:09 <roconnor> tomberek: it takes a few hours for the documantation to build
12:09:42 <stribor> is there better way to print error message rather then doing error("some error")
12:10:06 <roconnor> @tell edwardk for some reason the new category-extras isn't marked as obsolete. :(
12:10:06 <lambdabot> Consider it noted.
12:10:14 <tomberek> roconnor: i see... well, i still have the old doc pulled up, i figure you know about this stuff, can you explain Control.Comonad.Context?
12:10:40 <roconnor> tomberek: you can click on older versions of the package
12:10:43 <ddarius> roconnor: You have to request one of the Hackage admins to mark it, is my understanding.
12:11:01 <tomberek> roconnor: yeah, i got an older version up
12:11:02 <roconnor> tomberek: Context is the "old" name for the Store comonad
12:11:21 <tomberek> i guess I'm unfamiliar with both then
12:11:32 <roconnor> also called the costate comonad
12:11:41 <roconnor> tomberek: what do you want to know about it?
12:12:17 <tomberek> i can almost understand it's purpose, but it might be too late/early
12:12:37 <roconnor> late/early?
12:12:50 <roconnor> crap reactive-0.5 doesn't build
12:13:01 <tomberek> roconnor: yeah, I'm transitioning from days to nights right now, barely know what time it is
12:13:07 <roconnor> :)
12:13:26 <roconnor> costate i a = (i -> a, i)
12:14:30 <roconnor> I wonder what would happen if I tried to upload reactive-0.5.0.1
12:14:44 <tomberek> Ok, so is this allows the same thing as extract, but perhaps 'larger'
12:15:10 <roconnor> well it is a comonad so it has, extract, duplicate, etc.
12:15:28 <tomberek> so for the infinite spreadsheet, getC might extract not just the focused element, but perhaps the focused plus one on either side?
12:15:40 <bayesian> roconnor, is a 3D voxel movie of someone down to the planck scale that includes pictures of all the neuronal activity conscious or not?
12:15:46 <roconnor> I think of store i a = (i -> a, i) as a warehouse full of a's indexed by i with a forklift parked at the location marked.
12:16:34 <roconnor> bayesian: hard to say
12:17:21 <roconnor> bayesian: seems unlikely
12:17:27 <roconnor> a movie cannot make predictions
12:17:42 <aristid> is there some trick to getting double-conversion to actually work? whenever i try to load it, be it from another package, or from ghci, i get: Loading package double-conversion-0.2.0.1 ... can't load .so/.DLL for: stdc++ (libstdc++.so: cannot open shared object file: No such file or directory)
12:17:46 <roconnor> well maybe it can
12:17:54 <diracdelta> Hi! If i am constructing a hashmap, and the input to the construction function is two sets of integers, is there any way for me to declare the types of the two sets into the construction function to be different so that I can have different types for keys and values?
12:18:08 <aristid> it appears that the error appears on both os x and linux, and with ghc 6.12, 7.0 and even 7.2
12:18:28 <aristid> at least for some people
12:18:39 <tomberek> roconnor: and how does experiment fit in?
12:19:07 <roconnor> I've never used experiment.  I forget what it does
12:19:39 <roconnor> when was the last time Control.Arrow exported pure?
12:19:56 <tomberek> experiment is modifyC with some fmap'ing
12:20:31 <roconnor> ya, I think experiment is some sort of random function that someone made once
12:20:41 <roconnor> I doesn't occur in the new libraries AFAIK
12:21:46 <tomberek> well, modifyC then
12:23:17 <byorgey> roconnor: Control.Arrow last exported pure in the last version of base < 4, I think, which would have been like ghc 6.6 or 6.8
12:23:29 <roconnor> hmm
12:23:42 <roconnor> I added base < 4 to reactive 5.0's cabal but it still doesn't build
12:24:19 <byorgey> roconnor: yeah, that's not going to work, since you don't have such a version of base installed
12:24:28 <byorgey> roconnor: and cabal-install will not (for good reason) install base for you
12:24:29 <roconnor> sure I do
12:24:36 <roconnor>  base-3.0.3.2-260693a92016991a03206b5a55f6a411
12:24:37 <byorgey> what version of ghc are you using?
12:24:45 <roconnor> 6.12.3
12:24:54 <dcoutts> ghc-6.10 and 6.12 come with both base 3 and 4
12:25:05 <byorgey> ah, I see
12:25:13 <byorgey> roconnor: hmm, what error message do you get then?
12:25:28 <roconnor> src/Data/Fun.hs:18:29:
12:25:30 <roconnor>     Module `Control.Arrow' does not export `pure'
12:25:41 <roconnor>  /home/roconnor/.nix-profile/bin/ghc --make -package-name reactive-0.5 -hide-all-packages -fbuilding-cabal-package -i -idist/build -isrc -idist/build/autogen -Idist/build/autogen -Idist/build -optP-include -optPdist/build/autogen/cabal_macros.h -odir dist/build -hidir dist/build -stubdir dist/build -package-id TypeCompose-0.8.3-4ff471e4f68058998f14f11761ef7f9b -package-id base-3.0.3.2-260693a92016991a03206b5a55f6a411 -O -Wall Data.SFuture Data.Future
12:25:43 <roconnor> Data.Fun Data.Reactive
12:26:06 <ian__> how to check if float is even, i.e. 4.0, 1337.0
12:26:30 <monochrom> is 4.5 even?
12:26:37 <ian__> no
12:26:53 <byorgey> how about 4.4?
12:26:58 <ian__> something point zero
12:27:19 <monochrom> @type truncate
12:27:20 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
12:27:27 <roconnor> ian__: you shouldn't be doing this with floating point numbers
12:27:42 <ian__> truncate x == x okay
12:27:44 <byorgey> I suppose you can truncate and then fromIntegral and see if what you get is equal to the original.  But don't.
12:27:53 <monochrom> \x -> let t = truncate x in x == fromIntegral t && even t
12:27:55 <byorgey> no, fromIntegral (truncate x) == x
12:28:36 <ian__> well i want to check to see if logBase x y is even, i.e. XX.0
12:28:41 <ddarius> Need more Galois connections.
12:28:52 <roconnor> why doesn't base 3.0.3.2 export pure from Control.Arrow?
12:29:16 <roconnor> $ cat base-3.0.3.2/Control/Arrow.hs
12:29:17 <roconnor> module Control.Arrow (module X___) where
12:29:19 <roconnor> import "base" Control.Arrow as X___
12:29:20 <monochrom> does base 3 even have Control.Arrow ?
12:29:30 <roconnor> yes
12:29:31 <monochrom> ok, it does
12:30:00 <monochrom> was it called "pure" back then?
12:30:01 <roconnor> I don't even know what import "base" Control.Arrow as X___ means
12:30:25 <roconnor> according to hackage base-3.0.3.1 has pure
12:30:34 <roconnor> and 3.0.3.2 should be more or less compatable
12:30:38 <roconnor> which is why I'm confused
12:30:47 <ddarius> Both pure and arr were in the original Arrow class.
12:30:48 <djh__> does anyone have any experience of using WAI/Warp etc?
12:30:55 <hpc> roconnor: import Control.Arrow from the package base, and import it as X__, so you can annoy haskell coders with your C-like conventions
12:31:04 <monochrom> can you craft a small test case to confirm that base 3 hides "pure"?
12:31:07 <Olathe> ian__: Like this?
12:31:08 <Olathe> > let logBaseEven b n = (==n) . head . dropWhile (< n) . iterate (\b -> b*b) $ b in logBaseEven 3 9
12:31:09 <lambdabot>   True
12:31:14 <obiwahn> > let fun ll = [head l| l<-ll, l /= []] in fun [[1,2],[2,3],[3,4]]
12:31:15 <lambdabot>   [1,2,3]
12:31:31 <roconnor> monochrom: I don't know how to do that
12:31:35 <ian__> yes thanks
12:31:53 <monochrom> i.e., a small module that imports Control.Arrow and uses "pure". then a small *.cabal file that asks for base-3
12:31:54 <ddarius> obiwahn: Don't do l /= [].
12:32:01 <Olathe> > let logBaseEven _ 1 = True; logBaseEven b n = (==n) . head . dropWhile (< n) . iterate (\b -> b*b) $ b in map (logBaseEven 3) [1, 3, 9, 27, 81, 243]
12:32:02 <lambdabot>   [True,True,True,False,True,False]
12:32:07 <Olathe> Hmmm...
12:32:16 <Olathe> Not quite right.
12:32:18 <monochrom> (asks for base-3 and rejects base-4 just to be sure)
12:32:42 <mmos1127> I want to catch several possible exceptions (using Control.Exception) with different handlers in each case. How do I do this? Does this have something to do with 'tryJust' and 'guard'?
12:32:42 <Olathe> > let logBaseEven b n = (==n) . head . dropWhile (< n) . (1:) . tail . iterate (\b -> b*b) $ b in map (logBaseEven 3) [1, 3, 9, 27, 81, 243]
12:32:44 <lambdabot>   [True,False,True,False,True,False]
12:32:48 <Olathe> There we go :)
12:33:13 <monochrom> (and don't do anything else, so you have a controlled experiment, rather than 10MLOC that could fail for any arbitrary reason)
12:33:37 <obiwahn> ddarius: how would you do it? it is annoying that it forces Eq a =>
12:34:16 <dcoutts> monochrom: I don't get the point of the test, it's certainly true that base-3.0.3.1 and 3.0.3.2 do not export pure from Control.Arrow
12:34:24 <roconnor> monochrom: okay
12:34:28 <roconnor> but I'm doing base < 4
12:34:30 * dcoutts must have missed something
12:34:32 <obiwahn> > let fun ll = [x| x:_<-ll] in fun [[1,2],[2,3],[3,4]]
12:34:32 <lambdabot>   [1,2,3]
12:34:38 <ddarius> obiwahn: not (null l)
12:34:47 <roconnor> monochrom: done.  Now what?
12:34:53 <roconnor> Test.hs:3:22: Module `Control.Arrow' does not export `pure'
12:34:56 <ddarius> In fact, in that case there is a better way altogether.
12:35:11 <obiwahn> @src null
12:35:11 <lambdabot> null []     = True
12:35:11 <lambdabot> null (_:_)  = False
12:35:27 <roconnor> /home/roconnor/.nix-profile/bin/ghc --make -package-name test-0.1 -hide-all-packages -fbuilding-cabal-package -i -idist/build -i. -idist/build/autogen -Idist/build/autogen -Idist/build -optP-include -optPdist/build/autogen/cabal_macros.h -odir dist/build -hidir dist/build -stubdir dist/build -package-id base-3.0.3.2-260693a92016991a03206b5a55f6a411 -O -Wall Test
12:35:28 <roconnor> [1 of 1] Compiling Test             ( Test.hs, dist/build/Test.o )
12:35:30 <roconnor> Test.hs:3:22: Module `Control.Arrow' does not export `pure'
12:35:33 <ddarius> > let fun ll = [h | (h:_) <- ll] in fun [[1,2],[],[3,4]]
12:35:34 <lambdabot>   [1,3]
12:35:35 <monochrom> well then, base 3 does not export "pure". I don't know why but you can despair now
12:35:50 <roconnor> monochrom: why would they change the interface under a minor revision?
12:35:54 <obiwahn> > let fun ll = [x| x:_<-ll] in fun [[1,2],[2,3],[3,4],[]]
12:35:54 <lambdabot>   [1,2,3]
12:35:55 * Olathe despairs.
12:36:27 <monochrom> (but then what does base-3 export)
12:36:28 <obiwahn> ddarius: thanks for the hint:)
12:36:30 <mmos1127> oh I just noticed 'catches'
12:37:09 <hpaste> roconnor pasted “base-3.0.3.2” at http://hpaste.org/51205
12:37:45 <roconnor> how can the source code for base-3.0.3.2 rexport the Control.Arrow from base when it is the base package itself?!
12:37:53 <monochrom> in fact I can't find "pure" in recent versions of base 4 either
12:38:15 <dcoutts> roconnor: can't you just use 'arr' rather than 'pure' ?
12:38:36 <monochrom> well it's some package on hackage that uses "pure" apparently
12:38:38 <roconnor> dcoutts: why should I do that?
12:38:54 <dcoutts> roconnor: pure was a synonym for arr.
12:38:59 <dcoutts> but clearly it got removed
12:39:09 <roconnor> monochrom: actually all reactive does is import Control.Arrow hiding (pure)
12:39:13 <roconnor> that's the source of the error
12:39:28 <dcoutts> arr is still there, pure got removed
12:39:34 <monochrom> "pure" became later taken for Control.Applicative
12:39:46 <roconnor> dcoutts: is it standard to bump the minor revision number when *REMOVING* functions?
12:39:57 <dcoutts> roconnor: no it's not, that's clearly a mistake
12:40:13 <monochrom> but in any case if the source code says "import Control.Arrow hiding (pure)" then it knows what it's doing?
12:40:35 <monochrom> I'm unconvinced that it's a minor version bump
12:40:41 <hpc> roconnor: start the numbering at zero again :D
12:40:53 <roconnor> monochrom: pure is in the hackage docs for 3.0.3.1
12:41:20 * shapr grumbles at cabal
12:41:30 <merijn> Is there a way to see the HTTP request produced by Network.HTTP.Enumerator in plain text? (other then sniffing the network)
12:41:49 <mmos1127> Regarding writing code that catches multiple possible exception types, what are tradeoffs between  'catches' , 'catchJust', flavors of 'try' etc.? Basically I have code that translates MusicXML into Csound code, so there can be multiple types of processing errors inside pure code, and also IO errors
12:42:00 <roconnor> shapr: conal did everything write: added base < 4 and everything and it still fails
12:42:01 <monochrom> ok, it's in 3.0.3.1. what about 3.0.3.2?
12:42:04 <roconnor> *right
12:42:21 <shapr> roconnor: wait what?
12:42:25 <roconnor> monochrom: the docs for 3.0.3.2 don't exist anywhere and the source code makes no sense to me
12:42:32 <roconnor> shapr: s/write/right/
12:42:33 <roconnor> sorry
12:42:37 <roconnor> brain lapse
12:42:44 <dcoutts> roconnor: no it's not in 3.0.3.1, at least not in Control.Arrow
12:42:47 <shapr> roconnor: no no, I mean .. I'm grumbling about failing to install hakyll.
12:42:52 <dcoutts> http://www.haskell.org/ghc/docs/6.10.4/html/libraries/base/Control-Arrow.html
12:43:05 <roconnor> dcoutts: http://hackage.haskell.org/packages/archive/base/3.0.3.1/doc/html/Control-Arrow.html#v%3Apure
12:43:08 <roconnor> dcoutts: ta
12:43:22 <dcoutts> roconnor: oh, wait, that's the wrong docs
12:43:33 <roconnor> which one is the wrong docs?
12:43:35 <kniu> @hoogle unless
12:43:35 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
12:43:38 <kniu> hm
12:43:38 <monochrom> dcoutts: I hope you know see the point of the test. I was receiving bloody conflicting information!
12:43:42 <dcoutts> roconnor: the link I just pasted
12:43:45 <ddarius> shapr: We should go back to the days of ./configure;make;make install, unless you were building YHC which used scons for some reason.
12:43:46 <roconnor> ah right
12:43:53 <dcoutts> monochrom: ok :-)
12:44:12 <shapr> ddarius: no no, minor grumbles only, I remember how much worse it hurt in the past :-)
12:44:12 <monochrom> every scientific experiment has a point
12:44:29 <ddarius> monochrom: I doubt that.
12:44:32 <dcoutts> I was basing my info on running ghci-6.10.4 -package base-3.0.3.1
12:45:05 <roconnor> how many different base-3.0.3.1's are there?
12:45:09 <roconnor> WTF
12:45:20 <roconnor> now I'm getting:
12:45:21 <roconnor> src/Data/Fun.hs:52:8:
12:45:23 <roconnor>     `>>>' is not a (visible) method of class `Arrow'
12:45:34 <monochrom> haha
12:45:46 <roconnor> how did this ever build :D
12:45:54 <dcoutts> roconnor: mm, that is odd, the one on hackage does have Control.Arrow exporting pure
12:46:08 <dcoutts> roconnor, monochrom: ok I see where the confusion comes in :-)
12:47:01 * ddarius doesn't know why docs were consulted at all.  dcoutts test is the right thing to do.
12:47:15 <dcoutts> ddarius: usually the docs reflect reality :-)
12:47:23 <roconnor> what is dcoutts test?
12:47:25 <dcoutts> and not everyone has lots of old ghc versions installed
12:47:35 <dcoutts> roconnor: running ghci, using the version of base in quesion
12:47:44 <shapr> Oh I see, hakyll now requires ghc7 ... is there a package for ubuntu?
12:47:47 * shapr googles around
12:47:52 <ddarius> dcoutts probably read that the docs usually reflect reality in some documentation.
12:48:02 <dcoutts> ddarius: hah
12:48:12 <monochrom> "in docs, docs reflect reality..."?
12:48:14 <roconnor> dcoutts: but how did reactive-0.5 ever build?
12:48:47 <dcoutts> roconnor: using ghc-6.6 or early versions of ghc-6.8
12:49:02 <roconnor> what's different about them?
12:49:11 * shapr install haskell-platform
12:49:48 <mmos1127> Regarding writing code that catches multiple possible exception types, what are tradeoffs between  'catches' , 'catchJust', flavors of 'try' etc.? Basically I have code that translates MusicXML into Csound code, so there can be multiple types of processing errors inside pure code, and also IO errors
12:49:49 <dcoutts> roconnor: they have versions of base where the Arrow class contains the method pure
12:50:09 <roconnor> dcoutts: shouldn't the interface of base depend on its version number?
12:50:33 <shapr> Um, haskell-platform 2010.1? do not want!
12:50:34 <dcoutts> roconnor: sure, so the versions of base that shipped with 6.6 etc
12:51:05 <roconnor> so why doesn't it build under ghc 6.12?
12:51:10 <roconnor> I said base < 4
12:51:19 <roconnor> it is using base 3.something
12:51:23 <roconnor> what's the problem?
12:51:38 <hpc> mmos1127: what i would do is write a function that lets you catch any of those sorts of errors
12:51:49 <yitz> roconnor: what's the error?
12:52:06 <hpc> mmos1127: without you ever having to know which sort of error it is
12:52:33 <dmwit> ?src filterM
12:52:33 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:52:35 <roconnor>  Module `Control.Arrow' does not export `pure'
12:53:36 <monochrom> perhaps what you need is base-2
12:53:45 <mmos1127> hpc: hmm, what I wonder -- at least the distinction between errors in pure code vs. IO might be important
12:53:53 <dcoutts> roconnor: so it was there in base-3.0.2.0 and gone in 3.0.3.0
12:53:54 <yitz> roconnor: ugh. so it wants an old version of Arrow, which is going to ricochet into all kinds of other dependency problems.
12:54:05 <mmos1127> BUT.. my handler will be pretty simple.. it will display the error and that's it
12:54:16 <roconnor> dcoutts: and the hackage docs are lies?
12:54:23 <mmos1127> the only reason to catch an exception is to avoid busting out of the main input loop
12:54:36 <roconnor> yitz: I've almost got it to build
12:54:43 <tomberek> it is possible to use equality constraints on data families. Is it possible to have in-equality constraints?
12:54:50 <dcoutts> roconnor: apparently so
12:55:16 <monochrom> ok, then it was a wrong version increment
12:55:35 <dcoutts> roconnor: I'm basing this on the ghc docs, which is consistent with the ghc instances I've got installed
12:56:03 <mmos1127> can 'error' be caught?
12:56:12 <roconnor> @src (>>>)
12:56:13 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:56:33 <jpcooper_> is there an actual if function in Haskell?
12:56:40 <ddarius> jpcooper_: No.
12:56:40 <dcoutts> roconnor: so, can't you fix this just by deleting the bit where it says "hiding (pure)" ?
12:56:47 <byorgey> jcapper: no. this makes me a sad panda.
12:57:13 <yitz> roconnor: haddocks broken on hackage for 3.0.3.2 :(
12:57:17 <jpcooper_> I was just wondering how if is represented in the lower level of Haskell. Whether it's parsed to some kind of application of a function
12:57:21 <earthy> > let if' c t f = if c then t else f in if' True 1 2
12:57:22 <lambdabot>   1
12:57:30 <ddarius> jpcooper_: It's desugared into case.
12:57:42 <jpcooper_> okay
12:57:59 <byorgey> case test of True -> then_part; False -> else_part
12:58:17 <dcoutts> yitz: the hackage docs for base 3.0.3.1 do not match the ghc docs for base 3.0.3.1
12:58:23 <yitz> @pl \ c t f -> if c then t else f
12:58:23 <lambdabot> if'
12:58:56 <yitz> dcoutts: ouch
12:59:16 <dcoutts> yitz: they were uploaded later and clearly were a slightly different version
12:59:35 <dcoutts> I remember that at first we didn't have base on hackage at all
12:59:42 <tomh> anyone know of a lib which interfaces with FSEvents ?
12:59:58 <mmos1127> can 'error' be caught? I just tried to catch it as SomeException and I don't think it worked
13:00:05 <yitz> dcoutts: even now it's not healthy for it to be a manual step to be done with a ghc release
13:00:31 <roconnor> dcoutts: I tried that but the entire arrow instaces are fucked up
13:00:52 <roconnor> dcoutts: because someone switched arrow to require Category and shit
13:00:58 <dcoutts> roconnor: right
13:01:05 <roconnor> in a minor verion bump
13:01:07 <byorgey> mmos1127: is the error coming from someone else's code? or from code you wrote?
13:01:41 <yitz> dcoutts: why can't arrow be broken out of base? ghc really uses arrow stuff in an essential way?
13:01:58 <mmos1127> code I wrote. I plan on getting rid of it, but just wondering
13:01:59 <dcoutts> yitz: I don't think there's any special reason
13:02:55 <byorgey> mmos1127: you should get rid of it asap =)
13:03:03 <dcoutts> yitz: otoh, I think it's actually a good thing generally to have classes like this very far down the library stack, otherwise it causes lots of problems about where you put the instances.
13:03:09 <byorgey> mmos1127: return a Maybe value, or an Either String  if you want to include an error message
13:03:18 <mmos1127> editor is open and delete key is pressed as we speak
13:03:26 <byorgey> mmos1127: but FYI, there is the spoon package which can catch errors and turn them into Maybe
13:03:29 <byorgey> @package spoon
13:03:29 <lambdabot> http://hackage.haskell.org/package/spoon
13:03:35 <merijn> I assume that "pack" is not the function I want if I need to know the encoding of the resulting ByteString?
13:03:40 <mmos1127> what about Control.Exception?
13:03:40 <byorgey> I am not sure why it is called spoon
13:03:48 <byorgey> mmos1127: what about it?
13:04:04 <yitz> dcoutts: it can be down the library stack without being in base. i thought everything not part of the boot tangle was already broken out of base.
13:04:22 <mmos1127> is that not useful? it means I don't have to rewrite a couple hundred functions to return Maybe or Either
13:04:45 <dcoutts> yitz: no, more could be broken out, Igloo had a go at it, but apparently it didn't seem worth it, I don't recall the details.
13:04:55 <byorgey> mmos1127: it's hard to answer without knowing what you're doing
13:05:06 <merijn> mmos1127: But what if the function returns Nothing instead of Just?
13:05:14 <yitz> dcoutts: i see.
13:05:26 <dcoutts> yitz: it wouldn't make things much more flexible, you'd still need to rebuild all your libraries
13:05:40 <Igloo> Some people were against more, smaller packages
13:05:45 <dcoutts> yitz: and it'd still be in a core package
13:05:53 <merijn> mmos1127: Depending on what you need maybe "fromMaybe" can help in avoiding rewriting the functions to return Maybe?
13:06:08 <byorgey> mmos1127: is the error call really an error?  i..e should it never happen unless there's a bug? or are you using it to jump early out of some computation? or does it only happen if the user gives bad input? or what?
13:06:21 <roconnor> dcoutts: okay, I've hacked up a version of reactive-0.5.0.1 so that it builds.  What base constraint should I put on it?
13:06:32 <thetallguy> shapr: yes, there is ghc 7.x, but it's just called ghc now
13:06:35 <dcoutts> roconnor: building with base 4 now?
13:06:42 <roconnor> dcoutts: I didn't try
13:07:07 <dcoutts> roconnor: if possible make it work with base 4 and then just say build-depends: base == 4.*
13:07:18 <merijn> What's the correct way to encode unicode to ByteString? Anyone?
13:07:21 <roconnor> it seems to build with base 4
13:07:31 <dcoutts> roconnor: great
13:07:37 <roconnor> dcoutts: If I say base == 4.* then it is lies
13:07:42 <roconnor> it works with base 3.0.3.2
13:07:55 <dcoutts> roconnor: do you need to support users of ghc-6.8?
13:08:01 <roconnor> probably
13:08:09 <yitz> roconnor: are you building in a cabal-dev sandbox?
13:08:28 <roconnor> dcoutts: I'm building reactive 0.5.0.1 and the latest version of reactive is 0.11.5
13:08:48 <yitz> roconnor: if not it is harder to know what versions of everything are really being used.
13:08:50 <dcoutts> roconnor: really? we're talking about the previous (now unsupported) version of debian stable that has anything pre-ghc-6.10
13:09:00 <mmos1127> byorgey: it happens on bad input. I realize 'error' is a bad idea, but this program started life as a hack and gradually turned into something I need to use a lot and need a more graceful UI.
13:09:00 <roconnor> I have no idea
13:09:16 <roconnor> yitz: I'm not using cabal dev
13:09:19 <thetallguy> merijn: pack?  strings in haskell are unicode
13:09:32 <dcoutts> roconnor: at this stage, unless you know you need to support really old ghc, just specify base 4 only
13:09:41 <merijn> thetallguy: Pack doesn't specify anywhere in the documentation which encoding it uses....
13:09:50 <byorgey> mmos1127: well, can you screen the input first before you pass it to your hundreds of functions?  or is it hard to know in advance what inputs will be bad?
13:09:52 <roconnor> I'm going to say base >= 3.0.3.2
13:10:18 <dcoutts> merijn: in a sense your question doesn't make sense, bytestring is bytes, not unicode
13:10:37 <thetallguy> merijn: what dcoutts said
13:10:38 <dcoutts> merijn: if you want to represent unicode strings, use Text or String.
13:10:44 <merijn> dcoutts: I was asking which function to use to encode unicode strings into bytes
13:10:52 <merijn> I know String is unicode
13:11:15 <merijn> But I'm dealing with a network protocol expecting bytes. So I need something "String -> Encoding -> ByteString"
13:11:23 <dcoutts> merijn: do you mean something like converting String into UTF8 ?
13:11:28 <merijn> dcoutts: Yes
13:11:40 <yitz> merijn: that's in Data.Text.Encoding
13:11:53 <dcoutts> merijn: if you use Text, there's a function for it, if you're using String, there's some other package I think
13:12:09 <mmos1127> byorgey: bad input is discovered during processing, so it can't be prescreened like that. Basically I've got tons of code peppered with 'error'-- so please accept my humble contrition for abusing haskell so badly
13:12:36 <copumpkin> cute:
13:12:36 <copumpkin> data Dict ctxt where
13:12:36 <copumpkin>   Dict :: ctxt => Dict ctxt
13:12:45 <ddarius> mmos1127: So the problem sounds like you shouldn't have peppered your code with error.
13:13:18 <yitz> merijn: use the encoding/decoding functions in Data.Text.Encoding. if you really need to, you can go between Text and String using pack/unpack.
13:13:19 <efie> when i try to install gtk2hs on windows i get the error "setup.exe: internal error: unexpected package db stack: [UserPackageDB]", similar to this http://stackoverflow.com/questions/6288942/cabal-install-glib-makes-error ... the solution is to modify the "Gtk2HsSetup.hs" file, but this file does not exist in my folder. can anyone help me?
13:13:20 <ddarius> copumpkin: With that we'll be able to make our code even more object-oriented.
13:13:22 <mmos1127> the program is translating MusicXML files to Csound code. many errors happen when arriving at cases that can't be translated properly. (Csound is a software synthesizer)_
13:13:31 <copumpkin> ddarius: yay!
13:13:40 <ddarius> mmos1127: Yes and those errors should have been handled with something other than error.
13:13:47 <mmos1127> It's a cool project by the way. Very fun and turning out to be more useful than I originally planned
13:14:05 <yitz> merijn: but you're probably better off sticking with Text if you can.
13:14:28 <dcoutts> efie: try these pre-release tarballs: http://projects.haskell.org/gtk2hs/archives/2011/09/07/gtk2hs-0121-pre-release-packages-available/
13:14:28 <merijn> dcoutts: I have a String, I was using Hoogle to try and see if there were any "String -> ByteString", "String -> a -> ByteString" functions which looked like they did encoding but didn't find any. I guess I'll just convert String to Text then encode the text
13:14:42 <byorgey> mmos1127: awesome =)
13:15:09 <dcoutts> merijn: if you want to go direct String -> ByteString as utf8, there's probably something in the utf8-string package
13:15:13 <ddarius> merijn: There are multiple packages that encode to/from String and ByteString.
13:15:15 <efie> dcoutts: thanks!
13:15:28 <dcoutts> merijn: but a better policy would be to use Text from the beginning, imho
13:15:52 <byorgey> mmos1127: yeah, to really do things right you would have to go back through and change everything to be in some sort of error/logging monad or something like that
13:16:03 <merijn> dcoutts: Well, there's no way to type Text literals, I think? So I'd have to convert from String regardless of what I do...
13:16:08 <byorgey> mmos1127: but in the meantime I suppose you could look and see how spoon is implemented
13:16:16 <byorgey> mmos1127: spoon doesn't give you access to the error message
13:16:21 <mmos1127> I just started working on my Bachelor of Music in composition. There are many existing programs that can assist with turning musical scores into playback sound, but I wasn't happy with them, and as a programmer I decided to write my own. I'm not sure whether being a programmer is a blessing or a curse (i.e. huge time-sink when I could just learn to be happy with the status quo)
13:16:34 <roconnor> ah
13:16:36 <roconnor> http://www.haskell.org/haskellwiki/Upgrading_packages/Updating_to_GHC_6.10
13:16:43 <roconnor> says I should be using ifdefs everywhere
13:16:50 <dcoutts> efie: windows instructions here http://sourceforge.net/mailarchive/message.php?msg_id=28045875
13:17:02 <merijn> dcoutts, ddarius, yitz: Anyway, that should be enough to get me further, thanks!
13:17:12 <byorgey> mmos1127: usually in that sort of situation I find that I end up with a tool that still isn't any better than existing ones, except I learned a lot and I know how to use it pretty well since I wrote it myself, so it ends up being a win =)
13:17:13 <dcoutts> merijn: yes, the IsString class gives you literals
13:17:20 <Olathe> mmos1127: That would also eliminate you becoming a composer, with all the music already written.
13:17:52 <dcoutts> merijn: and the OverloadedStrings language extension
13:17:52 <mmos1127> Olathe: good point
13:18:51 <dcoutts> roconnor: that was relevant when people were still using ghc-6.8 and earlier. Unless you're sure you need to support really old ghc versions, then it's easier not to bother.
13:19:34 <roconnor> dcoutts: wow, you guys really like hanging people out to dry
13:19:42 <merijn> dcoutts: So I do "{-# LANGUAGE OverloadedString #-}" and do fromString before all the literals?
13:20:10 <dcoutts> merijn: no, that's the nice thing, OverloadedString means you don't need to use fromString manually
13:20:15 <yitz> mmos1127: there is a lot of existing Haskell work on that kind of stuff, including CSound. have you seen it?
13:20:18 <merijn> Ah
13:20:35 <merijn> That's much better, yes :p
13:20:54 <yitz> mmos1127: there is a Haskore backend for CSound
13:21:16 <dcoutts> roconnor: I try to support old versions where possible, but even I've got to the stage where ghc-6.8 is on the boundary of being plausible
13:21:20 <ezyang> Are there any wrappers on vector for one-indexed vectors?
13:21:32 <ezyang> or even arbitrary indexes?
13:22:15 <yitz> merijn: no you just write string literals and they magically become Text at runtime.
13:22:36 <ddarius> ezyang: repa?
13:22:48 <ezyang> oh, does repa do that?
13:24:08 <copumpkin> I don't think it does
13:25:13 <yitz> merijn: i.e., the OverloadedString extension causes the compiler to treat every string literal as if it were wrapped in a call to fromString, for better or for worse.
13:25:56 <mmos1127> yitz: yeah, not sure what all Haskore does but pretty sure it doesn't take MusicXML as input. What is specific to my system is "human touch/style" algorithms, allowing me to experiment with my own algorithms and tailor them to my own compositions.
13:26:46 <mmos1127> MIDI does not work as input because it cannot represent any of the traditional musical score markings, like staccato, or dynamic "hairpins". So I need MusicXML as input.
13:26:54 <yitz> mmos1127: Haskore is a higher-level description of music than MusicML.
13:27:38 <mmos1127> yitz: but I create my scores in notation editors (i.e. traditional graphic representation of music) and can export MusicXML.
13:29:12 <yitz> mmos1127: i know the feeling. i'm a lilypond user, that makes things even harder.
13:30:34 <ezyang> repa has shape thingies, which aren't too useful, afaict.
13:30:40 <ezyang> (for my case, that is)
13:31:37 <dibblego> is there a zipper in any of the JSON parsers?
13:31:44 <roconnor> yay I got phooey to build
13:31:53 <roconnor> almost made it to GuiTV
13:32:13 <ezyang> Hmm. GHC doesn't seem to let me do index = Data.Vector.(!), since it thinks I'm diong function composition. Is there a way to fix this?
13:33:01 <roconnor> oh fuck!
13:33:10 <roconnor> I just realized there is a GtkTV!
13:34:20 <engla_> ezyang: (Data.Vector.!)  maybe
13:35:16 <mmos1127> yitz: I would like to use Lilypond for the advantages in appearance of visual output, but I make some compromises for practicality. In sharing my music, most people want a Finale file. Also Finale does offer a decent playback feature (although my own system goes way beyond it) and Lilypond has essentially no playback (or very primitive)
13:35:47 <ezyang> I think that parse errors.
13:36:14 <dibblego> https://gist.github.com/868042/a851d67020402a35947c78d94c2236c8f41d7af8 that toZipper function looks wrong (where are the lefts and rights?)
13:36:52 <shachaf> ezyang: No, (Data.Vector.!) is correct.
13:37:22 <shachaf> The whole qualified identifier counts as infix, even though it starts with a letter.
13:39:28 <fryguybob> @type (Prelude..) -- ezyang ?
13:39:29 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:39:57 <fryguybob> oops missed shachaf's response.
13:40:01 <engla_> @type (.)
13:40:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:40:28 <shachaf> @ty ?a `Data.List.isInfixOf` ?b
13:40:29 <lambdabot> forall a. (?a::[a], ?b::[a], Eq a) => Bool
13:41:07 * hackagebot hamlet 0.10.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.10.1 (MichaelSnoyman)
13:41:09 * hackagebot persistent 0.6.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.6.2 (MichaelSnoyman)
13:41:12 <yitz> mmos1127: yes lilypond playback is primitive. i usually find it adequate for finding typos, but that's about it.
13:42:23 <yitz> mmos1127: there is an old package for reading and rendering MusicXML files on hackage:
13:42:35 <yitz> @hackage musicxml
13:42:35 <lambdabot> http://hackage.haskell.org/package/musicxml
13:43:59 <yitz> mmos1127: not sure how usable it is now, but you could use it as the basis of an updated package if you want to work in musicxml
13:44:57 <yitz> mmos1127: there is a mailing list for art-related haskell programming: http://lists.lurk.org/mailman/listinfo/haskell-art
13:45:30 <yitz> mmos1127: not too active in recent months, but there still seem to be some people listening in who know a lot about what's available.
13:48:57 <roconnor> Installing library in /home/roconnor/.cabal/lib/GuiTV-0.4/ghc-6.12.3
13:48:59 <roconnor> Registering GuiTV-0.4...
13:49:00 <roconnor> horray
13:50:48 <yitz> mmos1127: there's also this, which seems to be actively maintained:
13:50:54 <yitz> @hackage hCsound
13:50:54 <lambdabot> http://hackage.haskell.org/package/hCsound
13:50:59 <hpaste> int80_h pasted “help with error message” at http://hpaste.org/51211
13:51:06 * hackagebot persistent-sqlite 0.6.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.6.1 (MichaelSnoyman)
13:51:09 * hackagebot persistent-template 0.6.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.6.2 (MichaelSnoyman)
13:51:11 * hackagebot shakespeare 0.10.1 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-0.10.1 (MichaelSnoyman)
13:51:13 * hackagebot shakespeare-css 0.10.1 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-0.10.1 (MichaelSnoyman)
13:51:15 * hackagebot wai 0.4.2 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.4.2 (MichaelSnoyman)
13:51:58 <dcoutts> yitz, mmos1127: there's also gstreamer, but perhaps that's more than is needed
13:52:04 <int80_h> http://hpaste.org/51211
13:52:09 <merijn> Ha, now I know why I was so uncertain about how to encode HTTP request bodies. Apparently there is no standard way to deal with their encoding >.>
13:52:24 * merijn just got a little more depressed by the world
13:52:29 <yitz> int80_h: the lines that start with | are not going to work
13:53:03 <edwardk> roconnor: send me a patch and i'll apply it
13:53:03 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:53:13 <roconnor> edwardk: patch for what?
13:53:19 <int80_h> yitz: I'm trying to use guards, can I do that in a do construct?
13:53:24 <yitz> int80_h: no
13:53:25 <edwardk> category-extras
13:53:25 <roconnor> edwardk: heh
13:53:26 <tomberek> is there a way to use type families to specialize data types for a few types, but then also provide a default for all types not specialized?
13:53:28 <roconnor> edwardk: too late
13:53:34 <edwardk> ?
13:53:56 <roconnor> edwardk: http://hackage.haskell.org/package/category-extras-0.53.5.1
13:54:00 <edwardk> oh you uploaded one
13:54:12 <roconnor> but it isn't marked as obsolete
13:54:15 <edwardk> i'll figure out how to port that back into the repo
13:54:26 <edwardk> it de-obsolesces whenever a new upload is made
13:54:29 <tomberek> for example:  Set Int and Set Bool can be specialized, but can one still provide a default Set a
13:54:32 <edwardk> i made one a while back for 7.0
13:54:39 <edwardk> and it lost the flag
13:54:45 <yitz> int80_h: just use if then
13:54:54 <edwardk> its still obsolete, just not marked as such
13:55:03 <tomberek> i guess it's overlapping instances for typefamilies
13:55:08 <yitz> int80_h: or an auxilliary function with guards
13:55:16 <dcoutts> merijn: there's no need to feel so bad, HTTP request bodies are arbitrary entities, like files, so the encoding depends on the entity
13:55:36 <edwardk> what'd you want from it, anyways?
13:55:51 <roconnor> edwardk: I want GuiTV to build
13:56:04 <roconnor> edwardk: and GuiTV depends on phooey which depends on reactive which depends on category-extras
13:56:16 * hackagebot warp 0.4.5 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.4.5 (MichaelSnoyman)
13:56:19 * hackagebot yesod 0.9.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.9.2 (MichaelSnoyman)
13:56:21 * hackagebot yesod-auth 0.7.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.7.2 (MichaelSnoyman)
13:56:23 * hackagebot yesod-core 0.9.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.9.2 (MichaelSnoyman)
13:56:25 * hackagebot yesod-form 0.3.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.3.2 (MichaelSnoyman)
13:56:30 <edwardk> ah. i gave conal a patch for reactive that dropped the category-extras dependency, but it apparently never got applied
13:56:55 <roconnor> edwardk: I'm just trying to do the minimal amount of work needed to get things to build in hackage
13:57:04 <roconnor> edwardk: normally that should just be adding upperbounds to packages
13:57:15 <roconnor> edwardk: but for some reason base 3 is a big mess in 2007
13:58:24 <roconnor> edwardk: oh but the base 3 thing was to get reactive to build
13:58:31 <roconnor> category-extras was fine
13:58:34 <merijn> dcoutts: Well, it's kinda annoying in the case where you want to submit "plain text" to a form field. Right now I'm just submitting UTF-8 encoded ByteStrings, which seems to work...
13:58:37 <roconnor> just needed mtl < 2
13:58:58 <yitz> mmos1127: probably a good idea to browse around the pages here: http://www.haskell.org/haskellwiki/Category:Music
13:59:03 <merijn> I just have no clue if that makes my code correct
13:59:04 <edwardk> if i can garner the energy to care i'll fork off my copy of reactive with another name and put it on hackage so i can continue my quest to replace all the category-extras dependencies
13:59:12 <roconnor> damn it
13:59:13 <dcoutts> merijn: right, for plain text, utf8 has become the de facto standard on the web
13:59:21 <roconnor> hackage wants a stupoid licence-file
13:59:23 <roconnor> why?
13:59:30 <edwardk> for which?
13:59:37 <roconnor> for uploading anything
13:59:47 <dcoutts> roconnor: because it's not clear that saying "license: BSD3" is legally meaningful
14:00:03 <roconnor> dcoutts: ya but maybe the licenses are in each source file, like it should be
14:00:13 <merijn> dcoutts: As it should, but the obsessive part of me is still annoyed that there is no way to be "properly" correct
14:00:37 <merijn> roconnor: There's absolutely no legal need to put a license in every single file
14:00:46 <roconnor> merijn: but it really really helps
14:01:10 <yitz> roconnor: whom does it help?
14:01:13 <dcoutts> merijn: you might like to look at this: http://www.w3.org/International/O-HTTP-charset
14:01:22 <roconnor> yitz: the people cherry picking files
14:01:27 * hackagebot reactive 0.5.0.1 - Simple foundation for functional reactive programming  http://hackage.haskell.org/package/reactive-0.5.0.1 (RussellOConnor)
14:02:37 <merijn> dcoutts: Oh, right. Time to submit a patch to fix this in the library!
14:03:50 <roconnor> oh
14:04:00 <roconnor> the upload succeeded anyways
14:04:13 <roconnor> no problem then I guess
14:05:05 <dcoutts> roconnor: hmm, I guess it's not very obvious what are errors and what are warnings
14:05:17 <dcoutts> roconnor: did you upload via the website or via cabal upload?
14:05:22 <roconnor> website
14:05:28 <dcoutts> ok, thanks
14:06:36 <hpaste> roconnor pasted “cabal error” at http://hpaste.org/51213
14:06:59 <roconnor> doing cabal sdist on phooey gives me an error
14:07:07 <roconnor> Building source dist for phooey-2.0.0.1...
14:07:08 <roconnor> cabal: Examples.Monad: does not exist
14:07:13 <roconnor> but the thing is that it does exist
14:07:23 <roconnor> oh wait
14:07:32 <roconnor> this syntax for extra-source-files looks wrong
14:07:51 <dcoutts> roconnor: right, Extra-Source-Files refers to files, not modules.
14:10:22 <roconnor> there
14:10:33 <roconnor> I think GuiTV might build for everone now
14:10:57 <roconnor> it's like it is 2007 all over again
14:11:20 <ourfrank> Can the GHC API be used to import new types or new type instances at runtime?
14:11:46 <roconnor> @tell conal I've taken the liberty to upload a new version of reactive: reactive-0.5.0.1 and a new version of phooey: phooey-2.0.0.1
14:11:47 <lambdabot> Consider it noted.
14:11:58 <roconnor> @tell conal I think GuiTV will now build
14:11:58 <lambdabot> Consider it noted.
14:12:11 <conal> roconnor: do you have patches?
14:12:11 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:12:25 <roconnor> conal: no I've just uploaded directly to hackage
14:13:06 <conal> roconnor: there are darcs repos for reactive & phooey. if you send me patches, i can record them so they won't get lost.
14:13:40 <roconnor> conal: are the repos tagged?
14:14:10 <conal> roconnor: my release script (cabal-make) tags with version number whenever i make a new release.
14:14:38 <roconnor> let me see what I can do then
14:14:49 <conal> k
14:15:37 <roconnor> conal: I don't suppose you know how to "check out" a specific tagged version in darcs?
14:15:48 <conal> roconnor: not offhand
14:18:51 <conal> looks like i might be able to get back to work on functional guis & graphics soon. i'd been blocked waiting for a cross-platform, ghci-friendly gui & graphics lib, but there is some encouraging recent progress.
14:19:53 <merijn> If I want to update an installed library I can just run "cabal install" for the new version, right?
14:21:06 * hackagebot phooey 2.0.0.1 - Functional user interfaces  http://hackage.haskell.org/package/phooey-2.0.0.1 (RussellOConnor)
14:21:54 <conal> roconnor: what sort of changes did you make to reactive & phooey?
14:23:11 <roconnor> conal: for phooey I think I said mtl <2 and reactive <0.6
14:23:17 <roconnor> and base <5
14:23:43 <roconnor> oh and added Language rank2polymorphism to Graphics.UI.Phooey.Monad
14:23:57 <conal> ah.
14:24:22 <roconnor> and reactive needed a lot of Arrow/Category massaging to work in GHC 6.12
14:24:25 <roconnor> well
14:24:29 <roconnor> reactive-0.5 did
14:24:46 <conal> cool
14:24:56 <roconnor> I wasn't very happy about that :/
14:25:06 <conal> no?
14:25:29 <conal> roconnor: oh! 6.12.
14:25:30 <roconnor> well base should have been well versioned enough so that all I need was to add some upper bounds
14:25:54 <roconnor> but things are pretty screwy passing form ghc 6.8 to ghc 6.12
14:26:12 <conal> roconnor: there's still more trouble with ghc 7.*
14:26:18 <roconnor> I don't have ghc 7
14:27:16 <conal> roconnor: i hate to see my libraries rot so badly. i didn't think it'd take nearly so long for the problems with underlying graphics & gui libs to get straightened out.
14:27:50 <roconnor> conal: only reactive has "rotted"
14:27:56 <conal> roconnor: what OS(es) are you using?
14:27:58 <roconnor> acutally I guess reactive has been updated
14:28:09 <roconnor> it is phooey that has rotted then
14:28:17 <roconnor> conal: Linux
14:28:49 <roconnor> conal: I cannot find a 2.0 tag in Phooey
14:29:04 <conal> ah. i miss my linux days, when haskell libs just worked.
14:29:25 <roconnor> conal: there is a simple solution :)
14:29:50 <conal> roconnor: yeah, there is.
14:30:14 <roconnor> $ darcs get --tag="2.0" http://conal.net/repos/phooey
14:30:15 <roconnor> Copying patches, to get lazy repository hit ctrl-C...
14:30:17 <roconnor> darcs: Couldn't find a tag matching "tag-name 2.0"
14:30:25 <conal> hm.
14:31:00 <conal> i wonder whether that repo is behind. hm.
14:31:12 <conal> roconnor: what's the latest version in the repo?
14:31:17 <roconnor> 2.3
14:32:10 <roconnor>  darcs show tags
14:32:11 <roconnor> 0.2.1
14:32:13 <roconnor> phooey 0.0
14:32:24 <conal> hm. that's what i see also. and "darcs changes" shows a comment of "2.0". hm.
14:32:27 <roconnor> conal: so much for tagging releases
14:33:02 <int80_h> :q
14:33:05 <roconnor> conal: unfortunately tagging a patch isn't sufficent to identify the release
14:33:20 <conal> roconnor: hm.
14:33:44 <roconnor> conal: at this point I'm tempted to pass the ball to your court to say if you want the patches you can run a diff on the two versions of those packages.
14:34:19 <conal> roconnor: sure. i'm signing off now. riding the ragged edge of limited bandwidth.
14:34:22 <roconnor> conal: but really my works is simply to make things build, and whenever you relase a new GuiTV, you will do that, so losing these changes isn't a big deal
14:34:32 <roconnor> conal: one more question?
14:34:38 <conal> roconnor: yeah
14:34:40 <roconnor> conal: is GtkTV a replacement for GuiTV?
14:35:07 <conal> roconnor: it's a Gtk version. i wish i'd called GuiTV "wxTV".
14:35:18 <roconnor> thanks
14:35:21 <conal> roconnor: so an alternative, not a replacement.
14:35:26 <conal> later!
14:47:57 <knoc> I have some trouble combining "lines" with Data.ByteString
14:48:14 <knoc> I did an qualified import, but there is no B.lines available
14:48:52 <dcoutts> knoc: import qualified Data.ByteString as B ?
14:48:54 <merijn> I'm pretty sure ByteString's don't have lines as there is no sane way to define lines in this context?
14:49:02 <merijn> Or am I an idiot
14:49:12 <dcoutts> knoc: oh, you need Data.ByteString.Char8
14:49:38 <dcoutts> because as merijn says, it only makes sense in the context of ascii, not bytes
14:49:54 <dcoutts> since a line ending is a character concept, and requires a character encoding, like ascii
14:49:55 <knoc> that makes sense :]
14:50:50 <knoc> I wrote some code that counts words in a file, and replace every String function with a ByteString equivalent
14:54:07 <copumpkin> kmc: char '(' <*> many expr <* char ')'
14:54:32 <copumpkin> in fact
14:56:20 <knoc> is that import statement valid: import qualified Data.ByteString.Char8 as C (lines,words)
14:57:38 <Louis11> I'm looking at some old haskell code of mine (been years since I coded it), and I'm seeing in regards to a list: (a1:a2:as) if I recall it's referencing the first element (a1) the second element (a2) and the rest of the list, as?
14:58:50 <ourfrank> Are interface files (*.hi) necessary for a module we wish to access via the GHC API?
14:59:15 <shachaf> ourfrank: Well, ghci gets by somehow.
14:59:47 <shachaf> Louis11: Yep. : is right-associative, so it's parsed as (a1:(a2:as)), and : is cons.
15:00:05 <Louis11> shachaf: Thanks, working on refreshing my haskell knowledge :)
15:00:14 <ourfrank> If I only have the *.o file (no source file!), GHC complains interface files are missing when I try to access a top-level definition within.
15:00:43 <shachaf> Oh, you mean if you don't have the source.
15:00:44 <ourfrank> With access to a source file, I can compile it to get the *.hi file.
15:00:47 <shachaf> I'd guess that you need .hi.
15:00:51 <ourfrank> Yes. :)
15:00:57 <ourfrank> shachaf: Thanks.
15:01:21 <hpc> wait, how does ghci do it?
15:02:05 <ourfrank> hpc: I don't think ghci can access arbitrary top-level definitions with access to just an *.o file. Can it?
15:02:36 <hpc> shachaf seems to think so
15:02:45 <hpc> im not about to try with anything in my codebase
15:02:48 <shachaf> hpc: No, I meant that ghci can do it with the source.
15:02:53 <hpc> oh
15:02:59 <hpc> but it still wants the hi
15:03:09 <shachaf> Yes. I doubt .o is sufficient.
15:04:53 <latros> I'm a bit new at installing anything with cabal, does anyone know how I can fix this:
15:04:55 <latros> http://pastebin.com/VuPEq48U
15:04:56 <mauke> The paste VuPEq48U has been copied to http://hpaste.org/51216
15:05:16 <Olathe> Copier!
15:05:20 <latros> wait
15:05:21 <latros> derp
15:05:24 <latros> sorry
15:05:34 <latros> lemme make sure that it's not as trivial as I suspect it is
15:05:47 <jlouis> ourfrank: if I remember correctly, there is some very important information int he .hi you can't do without
15:06:39 <latros> yep that was the problem
15:06:42 <latros> didn't have gsl
15:06:49 <latros> ty anyway
15:08:27 <ourfrank> jlouis: Thanks, additional confirmation is welcomed. I needed to be very sure.
15:08:33 <copumpkin> lol, http://www.ugcs.caltech.edu/~keegan/complexity.html
15:09:06 <monochrom> haha copumpkin
15:10:45 <dmwit> ?pl \k f -> k (\a -> f (toDyn a))
15:10:45 <lambdabot> (. (. toDyn))
15:11:36 <jlouis> copumpkin: heheh
15:12:20 <jlouis> ourfrank: I think the .hi files contains parameterized versions of functions which are then inlined at link-time
15:13:11 <monochrom> I clicked on β-D and followed the link. "At about an hour and a half I was rather out of my body (at least I wasn't aware of my body, it felt so light). I was listening to Berlioz Requiem, and it took me to the highest realm." hahaha
15:15:29 <nolrai23> @hoogle Idenity
15:15:29 <lambdabot> No results found
15:18:12 <byorgey> nolrai23: http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Identity.html
15:21:07 * hackagebot hscurses 1.4.1.0 - NCurses bindings for Haskell  http://hackage.haskell.org/package/hscurses-1.4.1.0 (StefanWehr)
15:23:09 <byorgey> for anyone who likes a large enough subset of {git, github, diagrams, being a guinea pig}, I'm experimenting with mirroring diagrams repos on github: https://github.com/byorgey/diagrams-lib
15:23:11 <ourfrank> I have access to a module's *.o and *.hi file and am trying to load it in ghci. However, ghci complains of an unknown symbol: a definition from an installed package that the module imports. How can I tell ghci where to look for the installed packages (something which it usually does by default)?
15:23:39 <byorgey> if you want to send me a pull request (even a trivial one) I can test importing patches git -> darcs
15:23:45 <djahandarie> Whoa, did ConstraintKinds go into HEAD?
15:23:56 <byorgey> yup, it just did the other day
15:24:01 <djahandarie> Hell yeah
15:24:11 <djahandarie> Time to rewrite some shit
15:24:21 <byorgey> supposedly it's going to be in 7.4 which should be out not too long from now
15:24:28 <byorgey> djahandarie: =)
15:24:42 <shachaf> byorgey: What's "not too long from now"?
15:24:59 <djahandarie> 3.14 fortnights
15:25:06 <byorgey> shachaf: not sure exactly, the goal IIUC is to put it out "sometime around ICFP"
15:25:35 <byorgey> ourfrank: when you start ghci, is there an asterisk in front of your loaded module name in the prompt?
15:27:04 <byorgey> ourfrank: if not, i.e. if the module is not being interpreted, then only things it exports are in scope
15:27:07 <ourfrank> byorgey: I don't get that far. I get the error message "final link ... ghc: ModuleName.o: unknown symbol `(Data.PolyTypeable.Typeable closure)`", and I'm returned to the shell.
15:27:17 <byorgey> ourfrank: oh! strange.
15:28:14 <nolrai23> Is there a way to keep implicit variables from screwing up meimoization(sp?)?
15:29:21 <nolrai23> I probobly should just change it too a complie time constant..
15:29:43 <shachaf> nolrai23: Not really, because they're pretty much syntax sugar for actual parameters.
15:35:37 <nolrai23> > [1..0]
15:35:37 <lambdabot>   []
15:37:59 * roconnor enters dll hell
15:38:12 <roconnor>     Couldn't match expected type `network-2.3.0.2:Network.URI.URI'
15:38:14 <roconnor>            against inferred type `URI'
15:39:40 <byorgey> roconnor: at least that's better than "Couldn't match expected type `URI' against inferred type `URI'" =P
15:41:42 <Phyx-> roconnor: i get that alot. it happens when i have the source of the package (or another version of the package) on my path. ghc randomly picks up modules, so it might pick some from the one on your path and some from the lib, cauzing a mismatch and hence the version in the error aswel
15:42:25 <roconnor> Phyx-: hmm, doesn't seem to be happening in my case
15:42:31 <roconnor> reinstalling HTTP fixed the problem
15:42:38 <roconnor> however it broke GuiTV
15:42:46 <roconnor> now I'm reinstalling GuiTV
15:42:56 <roconnor> though I fear I'm caught in the Cabal Butterfly
15:46:42 <djahandarie> Hmm
15:47:16 <djahandarie> Trying to make install one of the GHC nightlys, and it's complaining:  ghc-cabal: Installed package ID not registered: "deepseq-1.2.0.1-inplace"
15:47:48 <monochrom> w00t conal, have you heard of the coming ICFP 2011 paper "A Semantic Model for Graphical User Interfaces"? (I got wind on LtU)
15:48:15 <Eduard_Munteanu> Is that available already?
15:48:30 <Eduard_Munteanu> (the paper I mean)
15:48:32 <monochrom> "We give a denotational model for graphical user interface (GUI) programming"
15:48:35 <monochrom> \∩/
15:48:51 <djahandarie> monochrom, authors?
15:48:55 <Eduard_Munteanu> FRP monkey business? :)
15:48:58 <monochrom> yes, LtU links to a pdf
15:49:05 <djahandarie> Nice, *search*
15:49:07 <monochrom> Nick Benton and Neel Krishnaswami
15:49:10 <djahandarie> Aha
15:49:12 <djahandarie> I had a feeling
15:49:23 <djahandarie> They've been doing a lot of that recently
15:49:55 <djahandarie> (For those who are interested: http://www.cs.cmu.edu/~neelk/icfp11-krishnaswami-benton.pdf )
15:50:03 <Eduard_Munteanu> Interesting.
15:50:09 <roconnor> help, I'm being attacked by butterflies
15:50:27 <Eduard_Munteanu> (Yeah, I already found it on LtU's frontpage)
15:50:36 <monochrom> use spiders to fight butterflies. or just wait for autumn to kill them
15:50:37 <djahandarie> Ah crap, ultrametric spaces
15:51:11 * Eduard_Munteanu used to be attacked by large moths in some places
15:51:12 <cads> djahandarie: that's awesome!
15:51:13 <roconnor> installing GuiTV removes network and installing network removes GuiTV
15:51:28 <roconnor> and I'm not sure why
15:52:17 <monochrom> the only current known way to reliably remove butterflies is hack into some of the packages involved to update dependencies and migrate to new dependencies
15:52:59 <roconnor> how do I debug this?
15:53:04 <monochrom> (assuming you have a clean suite of packages to begin with, of course)
15:53:40 <roconnor> I don't know how network and GuiTV are related
15:54:02 <latros> am I missing something? in http://hackage.haskell.org/packages/archive/hmatrix/0.9.3.0/doc/html/Data-Packed-Vector.html they do "linspace 5 (-3,7)" and get output
15:54:04 <latros> but
15:54:06 <roconnor> presumably they have some shared dependency that is problematic
15:54:11 <roconnor> but I have no idea which one
15:54:30 <latros> Prelude Data.Packed.Vector> linspace 5 (-3,7)
15:54:31 <latros> <interactive>:1:1: Not in scope: `linspace'
15:57:10 <merijn> monochrom: Ah, but after looking at the abstract it seems to only cover the IO aspect and not the tedious GUI creation problem?
15:57:31 <monochrom> I don't know. haven't read yet
16:01:27 <roconnor> yay
16:01:41 <roconnor> "cabal install network GuiTV HTTP" works
16:01:49 <roconnor> magically figures everything out
16:02:33 <roconnor> what langauge pragma do I need to enable sections of 1-argument functions?
16:03:47 <latros> no help? =/
16:04:06 <benmachine> roconnor: I thought GHC just enabled them
16:04:13 <benmachine> (in minor violation of the spec)
16:04:37 <roconnor> oh right
16:04:44 <roconnor> this is some sort of different type error
16:05:27 <benmachine> I could be wrong
16:05:50 <roconnor> ah
16:06:09 <roconnor> enabling PostfixOperators works
16:06:11 <roconnor> wow
16:06:16 <benmachine> I was wrong
16:06:17 <benmachine> how about that
16:06:30 <roconnor> benmachine: I hadn't needed a pragma in the past
16:06:36 <roconnor> but this is probably a good thing to require a pragma
16:06:42 <benmachine> mm
16:06:46 <roconnor> yay my 4 year old code now compiles
16:06:52 <benmachine> the pragma existed in 6.12.3 apparently
16:07:01 <benmachine> (that's the oldest GHC I have installed)
16:07:17 <rpglover64> I think these two codes functions should do exactly the same thing, based on my understanding of fmap in the IO monad; am I crazy?
16:07:21 <hpaste> “Alex R” pasted “Am I crazy” at http://hpaste.org/51218
16:07:22 <roconnor> benmachine: that is the newest GHC I have installed
16:07:38 <rpglover64> (that="Alex R" was me)
16:08:22 <benmachine> roconnor: I tried to bootstrap 6.10 with 6.12 but it didn't really work :(
16:08:27 <rwbarton> yes, you are crazy :)
16:08:39 <benmachine> (not that I was expecting it to :P)
16:08:50 <rwbarton> f2 is equivalent to  "do a <- readFile "grammar"; return $ printLn a"
16:09:29 <rpglover64> *headdesk*
16:09:33 <rpglover64> rwbarton: thanks
16:09:40 <rpglover64> I should know better
16:10:19 <byorgey> conversely, f1 is equivalent to  join . fmap printLn $ readFile "grammar"
16:10:48 <shachaf> join . fmap foo is usually called >>= foo. :-)
16:13:54 <byorgey> right, I was just showing what was "missing"
16:13:54 <byorgey> but yeah, I would never write it that way =)
16:27:30 <roconnor> benmachine: There is a nix isntallation of 6.10
16:27:35 <roconnor> maybe it is prebuilt
16:27:47 <benmachine> roconnor: my nix installation is still a WIP
16:27:56 * roconnor checks
16:27:57 * benmachine stuck on arch for the time being
16:28:02 <roconnor> benmachine: so sorry
16:28:06 <benmachine> :P
16:28:16 <roconnor> granted there are minor cabal/nix issues
16:31:55 <roconnor> it is prebuilt
16:31:59 <roconnor> let me fetch it
16:33:31 <roconnor> benmachine: what is the test?
16:36:08 <roconnor> @tell conal: sadly GuiTV appears to not be working.  Although my little GUI app from 2007 builds, its behaviour isn't correct.
16:36:08 <lambdabot> Consider it noted.
16:36:17 <roconnor> @tell conal sadly GuiTV appears to not be working.  Although my little GUI app from 2007 builds, its behaviour isn't correct.
16:36:17 <lambdabot> Consider it noted.
16:38:05 <roconnor> benmachine: hmm, the section appears not to work in GHC 6.10.4 either
16:38:17 <roconnor> maybe I've always enabled glasgow-exts in the past
16:42:15 <Peaker> the Constraint kinds seem like an interesting extension
16:42:23 <Peaker> Making type-classes more first-class-y
16:46:42 <Eduard_Munteanu> Peaker: any link?
16:47:07 <Peaker> Link: http://blog.omega-prime.co.uk/?p=127    Reddit: http://www.reddit.com/r/haskell/comments/kbf14/constraint_kinds_for_ghc/
16:47:14 <Eduard_Munteanu> Thanks.
16:48:44 * Eduard_Munteanu feels an urge to utter "dependent types"
16:54:15 <tomberek> roconnor
16:55:16 <zzo38> If I have:   class Which w l r t | w t -> l r where { which :: l -> r -> w -> t; };   then how can I make up the "makeL" and "makeR" such that:  which makeL makeR = id
16:55:47 <tomberek> monochrom
16:56:36 <zzo38> Is there such a thing?
16:57:25 <Peaker> zzo38: the semantics of 'which' are defined by the instances, not the class, so I don't think you can answer that in general
16:57:56 <Eduard_Munteanu> tomberek
16:58:09 <tomberek> hiya Eduard_Munteanu
16:58:15 <Peaker> and you probably can't even make a "makeL/R" such that the type of which makeL makeR is (w->w) because w and t are not derived from l and r
16:58:21 <Eduard_Munteanu> tomberek tomberek
16:58:29 <Eduard_Munteanu> Hi. :P
16:58:39 <Peaker> zzo38: what is behind this question? what are you trying to do?
16:59:05 <tomberek> I know.  You got a minute, I've got a result I thought was impossible, trying to figure it out.
16:59:28 <Peaker> tomberek: are you asking whether you should ask a question? :)
16:59:35 <Eduard_Munteanu> Hm, just ask the question, maybe somebody has an answer.
17:01:35 <Cale> I wonder why all the process monitoring tools for linux don't have network traffic statistics columns. That seems like it would be useful.
17:02:27 <shachaf> Cale: Can you get that information per-process?
17:02:38 <Cale> Pretty sure that you can.
17:02:46 <Cale> There are other tools which can provide it
17:02:58 <Cale> http://gnetworkmonitor.sourceforge.net/
17:03:17 <Eduard_Munteanu> nettop / ntop?
17:03:38 <Eduard_Munteanu> Similarly, plain old top doesn't show I/O, but iotop does. :/
17:04:03 <tomberek> well.... earlier we were talking about Data.Vector.Mutable and Data.Vector.Unboxed.Mutable and I was trying to allow them to be used in the same way, ie.  allowing a Functor instance... I think it is possible to specialize a data type to use Unboxed.Mutable while still having a default of just Mutable, hence getting around the Unbox a class contraint that Functor doesn't allow you to provide.
17:05:37 <stribor> can anyone help me with this function
17:06:08 <latros> maybe
17:06:11 <latros> shoot
17:06:20 <hpaste> me pasted “function” at http://hpaste.org/51220
17:06:24 <Eduard_Munteanu> @faq Can anyone help stribor with his question?
17:06:24 <lambdabot> The answer is: Yes! Haskell can do that.
17:06:34 <stribor> lol
17:06:36 <stribor> http://hpaste.org/51220
17:06:43 <latros> "Jerry" is not a [String]
17:06:52 <latros> that's the entire problem
17:06:52 <stribor> its list of chars?
17:06:57 <Cale> yeah
17:07:01 <latros> type String = [Char]
17:07:10 <latros> is a built in type synonym
17:07:18 <latros> so it's either String or [Char], your choice
17:07:33 <stribor> so Jerry = ['J','e','r'...]
17:07:37 <tomberek> aye, otherwise it would work, makeName undefined undefined would return "Jerry"
17:07:37 <Cale> yeah
17:07:38 <Eduard_Munteanu> But [String] = [[Char]].
17:07:50 <Eduard_Munteanu> Not [Char].
17:07:56 <Cale> "Jerry" = ['J','e','r','r','y']
17:08:32 <Cale> = 'J':('e':('r':('r':('y':[]))))
17:08:40 <zzo38> Peaker: Yes, they can be defined by the instance such that they follow the laws:  which makeL makeR = id   (as long as it typechecks)
17:08:45 <zzo38> But how can that be made?
17:09:01 <zzo38> When I tried it it didn't work, but "which" still works but "makeL" and "makeR" doesn't work
17:09:20 <stribor> if Jerry = ['J','e','r'...] than why cant you say makeName  a xs             = "Jerry"
17:09:21 <Cale> zzo38: I think we need to see more of your code
17:09:43 <stribor> isnt that same as makeName  a xs             = Jerry
17:09:49 <Cale> stribor: You've declared makeName to produce a list of strings as its result, but it's producing just one string.
17:10:02 <Cale> stribor: Perhaps you wanted  makeName a xs = ["Jerry"] ?
17:10:10 <stribor> Cale: oops
17:10:11 <stribor> you right
17:10:13 <stribor> sorry
17:10:22 <Eduard_Munteanu> stribor: identifiers don't expand within quotes
17:10:49 <Eduard_Munteanu> e.g. you can't say f = 3, g = "f"  and have g be "3"
17:10:59 <Eduard_Munteanu> (if that's what you meant)
17:11:07 * hackagebot JSONb 1.0.5 - JSON parser that uses byte strings.  http://hackage.haskell.org/package/JSONb-1.0.5 (JasonDusek)
17:11:28 <Eduard_Munteanu> Oh, wait you probably didn't go that far :)
17:11:28 <Cale> oh, yeah, you really want to say that "Jerry" (with quotes) is equal to ['J','e','r',...]
17:11:40 <zzo38> Cale: OK.  instance Which (Maybe x) t (x -> t) t where { which = maybe; };
17:11:43 <Cale> Jerry without quotes looks like a data constructor
17:11:46 <stribor> yeah i see now what you mean
17:11:56 <Jafet> Eduard_Munteanu: that's a preposterous haskell proposal
17:12:01 <Eduard_Munteanu> :)
17:12:21 * Eduard_Munteanu merely tried to identify the source of the confusion
17:12:31 <stribor> :)
17:12:43 <Jafet> (:)
17:12:55 <zzo38> So, how does it do?
17:14:18 <Eduard_Munteanu> zzo38: are you asking if a class can enforce specific laws upon its instances?
17:14:41 <zzo38> Eduard_Munteanu: No. I can enforce the law by myself.
17:14:59 <Eduard_Munteanu> Or if Haskell can check a certain law is obeyed by a particular instance?
17:15:02 <Jafet> Like Dredd.
17:15:03 <zzo38> No.
17:16:18 <zzo38> What I mean, is, what should be written to make it so that I can have the method "makeL" and "makeR" such that it will be accepted when I write their implementation in the instance declarations. (I can write the implementation myself too but it is still error)
17:18:19 <zzo38> Example, with the instance I have described, it would have:  makeL = Nothing; makeR = Just;   but whether it is same class or different class, it won't work. Sometimes it is compile error, but sometimes it is just error when trying to call that function in GHCi.
17:19:32 <zzo38> Do you understand my question now?
17:25:14 <latros> has anyone actually used Graphics.Rendering.Plot?
17:25:19 <latros> I'm finding it completely opaque
17:25:20 <latros> :(
17:27:27 <joe6> is it possible to have haskell ffi bindings that can call a c function that returns a struct by value?
17:27:55 <BMeph> joe6: Returns it to what? :)
17:28:20 <zzo38> joe6: You could use pointers and copy the stuff in Haskell, I think the specification says to make marshalling in Haskell for doing that kind of things
17:28:41 <joe6> ok, will check out the marshalling stuff.
17:32:10 <joe6> BMeph, I was thinking about getting the data to memory alloca'ed.
17:32:13 <zzo38> In addition to my question I wrote now (which it seems you don't know), note I made up section 5 and 6 of proposal of more-notation which probably explains a bit better some uses of it
17:34:33 <latros> has anyone done plotting at all in haskell, in here?
17:42:20 <gwern> @quote
17:42:20 <lambdabot> tnks says: I'm astounded that LYAH makes an FP language accessible, while Why's Poignant Guide makes a straight-forward imperative language look arcane.
17:48:23 <mm_freak_> question about arrow laws:  given two statements:
17:48:44 <mm_freak_> (x, y) <- f &&& g -< x
17:48:50 <mm_freak_> (y, x) <- g &&& f -< x
17:49:13 <mm_freak_> is there any law requiring that x and y are equal in both statements?
17:49:16 <mm_freak_> uhm
17:49:31 <mm_freak_> replace the rightmost x by something like i
17:51:36 <Peaker> mm_freak_: The Kleisli arrow will fail such a law, I think
17:52:40 <mm_freak_> true
17:52:44 <roconnor> tomberek
17:53:49 <mm_freak_> Peaker: although that's probably only true for IO
17:54:13 <mm_freak_> or for side-effecting monads with failure in general
17:54:19 <mm_freak_> like StateT+MaybeT
17:54:21 <sohum> is there a quickcheck in lambdabot?
17:54:26 <magicman> Or anything which keeps track of state, I think?
17:54:52 <mm_freak_> ok, i suppose there is no such law
17:55:01 <magicman> f could get+update, g could get+update, and stuff blows up.
17:55:04 <Peaker> mm_freak_: I don't think you need the failure part
17:55:17 <mm_freak_> yeah
17:55:35 <sohum> > quickCheck x == x
17:55:36 <lambdabot>   Not in scope: `quickCheck'
17:55:48 <mm_freak_> so only a commutative monad would obey the law, i guess
17:55:51 <sohum> > check x == x
17:55:52 <lambdabot>   Not in scope: `check'
17:55:57 <magicman> @check x == x
17:55:57 <lambdabot>   "OK, passed 500 tests."
17:56:11 <sohum> oh, there we go
17:56:12 <sohum> thank you
17:56:25 <cmccann> mm_freak_, well, you've still got the reader monad
17:56:36 <cmccann> it's nice that way
17:57:14 <mm_freak_> cmccann: i'm asking, because i'm changing the semantics of my arrow, which is not (and cannot be) a kleisli anyway
17:57:24 <sohum> @check let logOdds x = log (x/(1-x)); unLogOdds x = (exp x)/(1+exp x) in unLogOdds (logOdds x) == x
17:57:24 <lambdabot>   "Falsifiable, after 0 tests:\n"
17:57:31 <mm_freak_> wanna do some optimization by slightly changed semantics
17:57:43 <magicman> I don't think there are Arrow laws that involve (&&&) and (***), other than their definitions in terms of first/second/(\x -> (x,x)) and other arrow combinators.
17:57:45 <cmccann> mm_freak_, what's the definition of your arrow?
17:57:54 <sohum> um.
17:58:18 <mm_freak_> cmccann: http://hackage.haskell.org/packages/archive/netwire/1.2.3/doc/html/FRP-NetWire-Wire.html#t:Wire
17:59:22 <mm_freak_> right now, for w1 &&& w2 (and similarly for (***)), both are run in any case
17:59:33 <sohum> @check let f x = x + 1 in x + 1 == f x
17:59:33 <lambdabot>   "OK, passed 500 tests."
17:59:34 <mm_freak_> i want to prevent w2 from running, if w1 inhibits (produces a Left value)
17:59:49 <sohum> @check let f x = x + 1; g x = x - 1 in g x + 2 == f x
17:59:49 <lambdabot>   "Falsifiable, after 0 tests:\n"
17:59:58 <sohum> @check let f x = x + 1; g x = x - 1 in (g x) + 2 == f x
17:59:59 <lambdabot>   "Falsifiable, after 0 tests:\n"
18:00:17 <sohum> @check let f x = x + 1 in let g x = x - 1 in (g x) + 2 == f x
18:00:17 <lambdabot>   "Falsifiable, after 0 tests:\n"
18:01:01 <magicman> Too bad lambdabot doesn't display the counterexample >_>
18:01:16 <sohum> how is there even a counterexample there?
18:01:18 <kmc> @more
18:01:44 <magicman> Ah!
18:01:52 <magicman> It's because of (x :: Exp)
18:02:00 <mm_freak_> sohum: note:
18:02:13 <mm_freak_> > let def1 = 0; def2 = 1 in def1 + def2
18:02:14 <lambdabot>   1
18:02:23 <magicman> > (x + 1) == ((x - 1) + 2) -- way too many parentheses
18:02:23 <lambdabot>   False
18:02:32 <JoeyA> Can Foreign.Marshal.Alloc.free be used to free a block allocated with C's malloc?
18:02:46 <Guest15068> how can that be false
18:02:49 <tgeeky> JoeyA: maybe
18:02:51 <Guest15068> o.O
18:02:51 <dmwit> > 1e15 + 1 == 1e15 - 1 + 2
18:02:52 <lambdabot>   True
18:02:54 <magicman> > (x + 1, x - 1 + 2)
18:02:55 <lambdabot>   (x + 1,x - 1 + 2)
18:03:03 <magicman> :t (x + 1)
18:03:04 <lambdabot> Expr
18:03:23 * sohum headdesk
18:03:26 <sohum> right, of course
18:03:26 <magicman> @check \x -> let f x = x + 1 in let g x = x - 1 in (g x) + 2 == f x
18:03:26 <lambdabot>   "OK, passed 500 tests."
18:03:29 <dmwit> @check let f x = x + 1; g x = x - 1 in \x -> g x + 2 == f x
18:03:30 <lambdabot>   "OK, passed 500 tests."
18:03:33 <tgeeky> magicman: some variables in the range [a .. z] are reified to ::Expr
18:03:43 <mm_freak_> conclusion:  don't test with lambdabot
18:03:53 <magicman> tgeeky: I know, I was showing that to sohum ;)
18:03:54 <sohum> @check let logOdds x = log (x/(1-x)); unLogOdds x = (exp x)/(1+exp x) in \x -> unLogOdds (logOdds x) == x
18:03:54 <lambdabot>   "Falsifiable, after 0 tests:\n1.0\n"
18:04:23 <tgeeky> magicman: oh, then s/magicman/sohum/
18:04:43 <sohum> tgeeky: yea; that makes sense
18:04:58 <sohum> @check let logOdds x = log (x/(1-x)); unLogOdds x = (exp x)/(1+exp x) in \x -> logOdds (unLogOdds x) == x
18:04:58 <lambdabot>   "Falsifiable, after 3 tests:\n1.3333333333333335\n"
18:05:02 <tgeeky> sohum: I happen to think it's really quite arbitrary, but that's the way it's done
18:05:22 <tgeeky> sohum: I do suggest that you try things in private message to lambdabot, and only paste those you want to share with everyone in here
18:05:35 <sohum> yes, of course
18:05:36 <sohum> sorry about that
18:06:07 * hackagebot JSONb 1.0.6 - JSON parser that uses byte strings.  http://hackage.haskell.org/package/JSONb-1.0.6 (JasonDusek)
18:06:23 <cmccann> mm_freak_, ah yeah, that looks like a pain given how many things you need to juggle :P
18:06:42 <cmccann> dealing with effects inside an arrow like that usually seems more hassle than it's worth to me :T
18:14:14 <some> the Control.Parallel module expososes only two function par and pseq. is that enough for parallelism?
18:14:58 <kmc> enough fundamentally, yes
18:15:12 <kmc> but it's more pleasant to use the higher-level strategy combinators
18:15:16 <kmc> in Control.Parallel.Strategies
18:15:36 <some> where can I learn more then?
18:16:08 <kmc> by reading the docs for Control.Parallel.Strategies
18:16:20 <kmc> and the paper " Seq no more: Better Strategies for Parallel Haskell"
18:19:40 <mm_freak_> cmccann: no, the thing looks more compicated than it really is…  and in fact only one constructor is necessary (WGen)…  the others are just optimization
18:19:51 <Jafet> I am seq of seq. It is pseq me off
18:20:39 <cmccann> mm_freak_, yeah, I would imagine. seems like the end result ought to be very pleasant to work with.
18:20:51 <mm_freak_> cmccann: it is =)
18:21:31 <mm_freak_> it's a working library, but i want to change the semantics of time a bit to be more useful
18:36:07 * hackagebot zot 0.0.1 - Zot language  http://hackage.haskell.org/package/zot-0.0.1 (YoshikuniJujo)
18:36:50 <tgeeky> is that package description some sort of zen koan?
18:39:43 * cmccann guesses it's a variant on Jot
18:40:14 <Jafet> How much sense would a koan make if a koan could make sense?
18:40:31 <cmccann> Jot being a slightly more awkward than usual esoteric/turing tarpit/etc. language based on combinatory logic
18:40:59 <cmccann> and when I say more awkward than usual I mean it's not as pleasant to code in as, say, Unlambda
18:42:20 <edwardk> ooh the constraint kind stuff brings along associated type defaults. NICE!
18:42:21 <tgeeky> cmccann: when comparing an esoteric language to an esoteric language, you los me
18:42:40 <tgeeky> edwardk: that what was just put in 7.2.1 or something else?
18:42:49 <edwardk> iirc its going into 7.4.1
18:43:01 <edwardk> so in  month or two
18:43:06 <cmccann> tgeeky, you familiar with combinatory logic?
18:43:08 <edwardk> not very far away at all
18:43:42 <tgeeky> cmccann: I am not very good in that area, though I am working on it right now. I assume comb. species is closely related
18:43:49 <tgeeky> which I've read (by's paper)
18:43:49 <cmccann> tgeeky, nope
18:44:00 * tgeeky -> wikipedia
18:44:11 <cmccann> combinatory here means "combinator" as in higher-order functions
18:44:20 <tgeeky> cmccann: oh, that's simpler than I thought.
18:44:23 <cmccann> it's basically the point-free version of lambda calculus
18:44:24 <tgeeky> yea, I know what that is
18:44:41 <cmccann> the standard basis is SKI
18:44:52 <tgeeky> cmccann: ok
18:44:56 <cmccann> lots of turing tarpit esolangs use combinatory logic as their basic approach
18:45:11 <Jafet> Jot is a constructive proof that between every two useful programs there exists a useless one.
18:45:13 <cmccann> unlambda is SKI with a few extras thrown in for I/O and such
18:45:15 <tgeeky> cmccann: bf, unlambda?
18:45:32 <cmccann> unlambda also includes call/cc just to be especially perverse
18:45:57 <tgeeky> jot does?
18:46:00 <cmccann> bf is a pathologically stupid model of computation based on a turing machine
18:46:13 <cmccann> jot is similar to iota, I think, in using a single-combinator basis
18:46:30 <cmccann> so basically the language has one function, and some way of indicating application order
18:47:00 <cmccann> unlambda is at least vaguely comprehensible, like bf or such, since the combinators have a clear meaning
18:47:24 <cmccann> whereas the iota combinator mostly exists to be a single-combinator basis that's still turing complete
18:49:12 <cmccann> personally I prefer Lazy K, which is a lazy, pure implementation of the SKI basis :]
18:50:53 * cmccann also thinks it behooves any Haskell programmer to have at least a passing familiarity with combinatory logic :]
18:54:15 <Jafet> Besides, Haskell already has a combinatory logic tarpit, a constraint logic tarpit...
18:57:43 <cmccann> yes, type-level metaprogramming with fundeps is about the same degree of tarpititude as brainfuck or unlambda
19:02:29 * shachaf snaps fingers.
19:04:38 <tactics> yay types
19:06:46 <tactics> boo imperative languages
19:11:39 <Cale> Yay combinatory logic!
19:15:37 <roconnor> wow, even IO based Tangable Values seems broken
19:16:17 <Cale> bitrot?
19:16:23 <roconnor> I guess
19:16:29 <roconnor> but it builds
19:16:30 <roconnor> and runs
19:16:36 <roconnor> so it upsets me that it doesn't work
19:16:47 <roconnor> if it isn't going to work it shouldn't build
19:17:02 <cmccann> aw man, I thought haskell programs always worked if they build :[
19:17:12 <Cale> yeah, that does suck
19:17:30 <Cale> I wonder what changed
19:18:43 <roconnor> wxhaskell probably changed
19:19:20 <roconnor> $ ./Examples
19:19:21 <roconnor> Examples: <<loop>>
19:19:23 <roconnor> heh
19:19:46 <roconnor> I don't think I know enough about phooey or wxHaskell to fix this
19:19:58 <roconnor> my whole reason for using GuiTV is so I don't have to know.
19:21:23 * cmccann thinks the problem could have been avoided if TV were defined over continuously varying library dependencies
19:27:32 * tgeeky can't tell if joke or serious
19:36:29 <LordBrain> Anyone here use leksah?
19:36:44 <hamishmack> LordBrain: Ys
19:36:53 <hamishmack> LordBrain: Yes
19:37:14 <LordBrain> would you mind helping/advising me a little with the initial setup?
19:37:54 <LordBrain> i just installed the debian package
19:38:02 <LordBrain> which maybe isnt the best way to go
19:38:28 <LordBrain> are you a linux user too?
19:39:05 <dave1231> LordBrain: I installed it on ubuntu via cabal the other day
19:39:06 <Eduard_Munteanu> I think it's better to ask directly. What are you having problems with?
19:39:32 <LordBrain> well, i am totally unfamiliar with leksah, and it pops this window up when i start
19:40:00 <LordBrain> here. i'll start it and see what it asks me
19:40:11 <LordBrain> i just remember trying this earlier and not really knowing what to do here
19:40:24 <LordBrain> oh wait
19:40:32 <LordBrain> it gives me an error
19:40:36 <hamishmack> LordBrain: If you are not sure the defaults should work ok
19:40:44 <LordBrain> leksah-server: Config file not found: prefscoll.lkshp
19:40:55 <LordBrain> it doesnt even start now
19:41:11 <LordBrain> says internal IDE error
19:41:12 <hamishmack> LordBrain: hmm
19:41:27 <LordBrain> i'm not complaining, i just wonder if someone can help me get over this initial hump
19:41:52 <hamishmack> LordBrain: try "rm ~/.leksah-0.10"
19:41:57 <LordBrain> ok
19:42:07 <hamishmack> that should get you back to the "first start" dialog
19:42:23 <LordBrain> oh it is .leksah-0.8/ for me
19:42:29 <LordBrain> i guess the debian package is old
19:43:00 <mm_freak_> @src returnA
19:43:00 <lambdabot> returnA = arr id
19:43:20 <LordBrain> ok, now i got the funky window
19:43:39 <mm_freak_> does proc/do syntax optimize returnA away?
19:43:51 <LordBrain> it has all sorts of weird looking quotes on it, that looks like a bug, but maybe they intend that... i dont know
19:44:12 <LordBrain> so i just click ok here?
19:44:58 <LordBrain> how do i take a screen shot in gnome?  I will show you what i mean
19:46:37 <Eduard_Munteanu> LordBrain: gimp springs to mind
19:46:53 <LordBrain> http://tinypic.com/r/214p021/7
19:47:08 <LordBrain> nah i found something that starts up a lot quicker than gimp
19:47:23 <LordBrain> i didnt know gimp could do screen shots anyway
19:48:09 <LordBrain> see all those weird quote symbols under "At first start... "
19:48:20 <ion> A screenshot in Gnome? Hit PrintScreen.
19:48:22 <LordBrain> does everyone get htat?
19:50:39 <LordBrain> anyway.. i just clicked ok... seem to be up and running now
19:51:46 <LordBrain> Is there a tutorial somewhere
19:52:09 <Eduard_Munteanu> @google leksah tutorial
19:52:11 <lambdabot> http://leksah.org/leksah_manual.pdf
19:52:11 <lambdabot> Title: Leksah: An Integrated Development Environment for Haskell Version 0.8
19:52:24 <LordBrain> eh i already have that
19:52:27 <Eduard_Munteanu> Some youtube vids show up as well.
19:52:48 * Eduard_Munteanu can't recommend anything though, he never used Leksah
19:52:52 <LordBrain> shoot, rsi in my wrist
20:00:26 <parcs_> > 5, 6
20:00:27 <lambdabot>   <no location info>: parse error on input `,'
20:24:16 <shachaf> Is there a simple way to define (++) = mappend in all my modules without manually hiding it from Prelude in each one?
20:25:40 <cmccann> shachaf, probably could do some stuff with compiler flags
20:25:49 <cmccann> but I suspect it'd cause more trouble than it solves
20:26:34 <Jafet> Double-plus good?
20:26:45 <SailorReality> *Main> let 2 + 2 = 5
20:26:45 <SailorReality> *Main> 2 + 2 == 5
20:26:45 <SailorReality> True
20:26:48 <SailorReality> LOL ^
20:26:52 <SailorReality> haskell is a buggy piece of shit
20:26:53 <Jafet> ⧺
20:26:57 <SailorReality> it doesnt even do basic logic
20:26:58 <SailorReality> hahahha
20:26:59 <SailorReality> its unstable
20:27:12 <SailorReality> its all hacked together it cant even valuate 2+2==5 lmfao
20:27:13 <kmc> hahahha
20:27:17 <SailorReality> youre all living a lie
20:27:18 <kmc> shut the fuck up
20:27:26 <Jafet> Oh, sailor finally got banned from all the other channels.
20:27:29 <SamB_XP> SailorReality: hey, you lie to it, it gives dumb answers
20:27:30 * cmccann thinks that (++) should be multiplication, anyway
20:27:34 <SamB_XP> duh
20:29:00 <kmc> i'm really disappointed with the quality of trolls in this channel
20:29:12 <SamB_XP> me too
20:29:27 <SamB_XP> I want some really thought-proviking trolling, pronto
20:29:36 <SamB_XP> only spelled correctly
20:29:47 <Jafet> Pro viking trolls
20:29:56 <Jafet> @quote troll
20:29:56 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
20:29:58 <kmc> i guess Haskell is so hard to learn that even the would-be trolls can't figure out how
20:30:47 <cmccann> other than a handful of ML programmers who willfully misunderstand Haskell and then complain about it
20:31:00 <rwbarton> "how do I use a hash table in Haskell?"
20:31:21 <copumpkin> "no, fuck you"
20:31:29 <kmc> "hash table" is a synonym for "associative data structure", right?
20:31:32 <kmc> ;)
20:31:35 <copumpkin> "hashtables are for assholes"
20:31:40 <kmc> hashholes
20:31:44 <copumpkin> lol
20:31:47 <SamB_XP> rwbarton: you import the approrpriate modules, then wonder why your programs are so slow
20:31:55 <cmccann> "haskell's round holes are slightly smaller than the ones I'm used to, so now my square pegs don't fit anymore, your language sucks"
20:32:07 <Jafet> {-# LANGUAGE MagicHash #-}
20:32:16 <copumpkin> Jafet: that's the illegal stuff
20:32:18 <copumpkin> mmm
20:32:20 <diabolix> so, I have a monadic function (a :: Foo -> IO ()), And I am writing another monadic function (b :: Maybe Foo -> IO ()), and I want to apply a to the first argument of b, like fmap does. Is there something built in, thats like fmap, that I can use from a monadic function?
20:32:23 <Jafet> kmc, in your talks you should mention that haskell has magic hash
20:32:23 <copumpkin> I use it all the time
20:33:04 <LordBrain> is it customary to be root to install cabal packages system wide?
20:33:12 <shachaf> kmc: That's "associative array".
20:33:12 <kmc> diabolix, i think you want (>>=) or (>=>)
20:33:14 <kmc> :t (>=>)
20:33:15 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
20:33:27 <kmc> hmm
20:33:37 <kmc> diabolix, so (b (Just x)) = a x
20:33:39 <shachaf> cmccann: I guess one way would be to compile with -NoImplicitPrelude and then reexport Prelude \\ (++) from my module. Or something like that.
20:33:43 <ion> {-# LANGUAGE MagicQuotes #-}
20:33:43 <kmc> but b Nothing = ?
20:33:49 <shachaf> @slap ion
20:33:49 * lambdabot smashes a lamp on ion's head
20:34:06 <rwbarton> are you asking how to write "b (Just x) = a x; b Nothing = return ()"?
20:34:16 <cmccann> shachaf, or some variation on such. like I said, probably more hassle than it's worth.
20:34:17 <rwbarton> in a higher-level sort of way?
20:34:27 <kmc> you can write that as is
20:34:43 * shachaf is tempted to make a module called All.hs with all my imports.
20:34:54 <kmc> or you can write «b = maybe (return ()) a»
20:34:57 <shachaf> Dozens of import lines in every file is a bit excessive, isn't it?
20:34:59 <Jafet> rwbarton: to make it hard to read, it must be hard to write!
20:35:10 <kmc> shachaf, unfortunately you can't do qualified imports that way
20:35:14 <kmc> but you could use #include
20:35:15 <shachaf> Of course you -- right.
20:36:06 <shachaf> Qualified imports are overrated anyway.
20:36:07 * hackagebot plot-gtk 0.1.0.8 - GTK plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk-0.1.0.8 (VivianMcPhail)
20:36:19 * shachaf mangles all his symbols instead.
20:36:38 <shachaf> Does foldr (.) id have a name in the standard library?
20:36:54 <kmc> appEndo . mconcat . map Endo
20:36:58 <kmc> that's a "name", right?
20:37:00 <copumpkin> lol
20:37:08 <copumpkin> that's a synonym, I thnk
20:37:18 <kmc> the great appendo
20:37:21 <shachaf> syno"nym" -- name.
20:37:27 <copumpkin> :t appEndo . Data.Foldable.foldMap Endo
20:37:27 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> a -> a
20:38:11 <ion> :t ala Endo Data.Foldable.foldMap
20:38:11 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t (a -> a) -> a -> a
20:38:15 <Jafet> Call it innuEndo
20:38:27 * cmccann occasionally wishes (a -> a) was a Monoid instance directly
20:38:31 <cmccann> :t ala
20:38:31 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
20:38:35 <cmccann> hahaha nice
20:38:40 <cmccann> didn't know lambdabot had that
20:38:49 * cmccann likes that package
20:38:51 <ion> :t ala `asTypeIn` \ala -> ala Endo
20:38:52 <lambdabot> forall b n' o' a. (Newtype n' o') => ((a -> a) -> Endo a) -> (((a -> a) -> Endo a) -> b -> n') -> b -> o'
20:38:56 <Jafet> I thought it was written for lambdabot.
20:39:11 <huangyi> Enumerator a m b -> Iteratee a m b -> (m b, Enumerator a m c) , I've spend some time to figure out how to implement this, but i don't succeed. I got a data source, i want to run a iteratee which consume parts of the data and return both the result and a new Enumerator which generate rest of the data.
20:39:13 <ion> :t ala `asTypeIn` \ala -> ala Endo Data.Foldable.foldMap
20:39:14 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => ((a -> a) -> Endo a) -> (((a -> a) -> Endo a) -> t (a -> a) -> Endo a) -> t (a -> a) -> a -> a
20:39:38 <ion> :t ala `asTypeIn` \ala -> ala undefined Data.Foldable.foldMap
20:39:38 <lambdabot> forall n o' (t :: * -> *). (Monoid n, Data.Foldable.Foldable t, Newtype n o') => (o' -> n) -> ((o' -> n) -> t o' -> n) -> t o' -> o'
20:40:08 <kmc> diabolix, i'm not sure it's useful to think about "monadic functions"... they really are just ordinary Haskell functions, and you can use them with stuff that has nothing to do with monads (like that 'maybe' function)
20:40:42 <cmccann> all haskell functions are monadic (as opposed to dyadic)
20:40:46 * cmccann ducks
20:41:49 <shachaf> cmccann: Not zero-argument functions! Everything is a function, remember?
20:41:51 * shachaf geese
20:42:08 <diabolix> I'm trying to find out what >=> is exactly, I don't see it in the prelude docs and these things are impossible to search for.
20:42:12 <shachaf> cmccann: (You neglected to mention the (r ->) instance, of course.)
20:42:32 <shachaf> diabolix: Hoogle.
20:42:34 <kmc> @hoogle (>=>)
20:42:34 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:42:41 <kmc> diabolix, anyway, i don't think it's what you want here
20:42:42 <shachaf> http://www.haskell.org/hoogle/?hoogle=%3E%3D%3E
20:42:44 <cmccann> shachaf, no, that's legitimate and uses the same meaning of "monadic" people expect :P
20:42:51 <kmc> i think what you want is probably «maybe (return ()) a»
20:43:01 <shachaf> cmccann: Right.
20:43:09 * shachaf wonders what "monadic" actually means.
20:43:27 <shachaf> As far as I can tell it means "vaguely has anything at all to do with an instance of Monad".
20:43:31 <ion> :t ala `asTypeIn` \ala -> ala undefined Data.Foldable.foldMap [undefined]
20:43:32 <cmccann> yes
20:43:32 <lambdabot> forall n o'. (Monoid n, Newtype n o') => (o' -> n) -> ((o' -> n) -> [o'] -> n) -> [o'] -> o'
20:43:35 <cmccann> that's pretty much it
20:43:41 <kmc> "In the novel The World Inside by Robert Silverberg, almost a hundred billion humans live in megastructure skyscrapers called monads"
20:43:46 <cmccann> haha
20:44:01 <shachaf> Are they trapped in there?
20:44:16 <copumpkin> :O
20:44:24 <cmccann> yes, along with the nuclear waste and burrito filling
20:44:26 <Jafet> I hope they don't get executed.
20:44:29 <kmc> oh no
20:44:30 <ion> @tell djahandarie Something like «:t ala `asTypeIn` \ala -> ala undefined Data.Foldable.foldMap [undefined]» gives a very explanatory, partially specialized, type for ala.
20:44:30 <lambdabot> Consider it noted.
20:44:40 <shachaf> Are there also luxurious residences that area difficult to get into but easy to leave?
20:45:26 <djahandarie> :t ala `asTypeIn` \ala -> ala undefined Data.Foldable.foldMap [undefined]
20:45:26 <lambdabot> djahandarie: You have 1 new message. '/msg lambdabot @messages' to read it.
20:45:27 <lambdabot> forall n o'. (Monoid n, Newtype n o') => (o' -> n) -> ((o' -> n) -> [o'] -> n) -> [o'] -> o'
20:45:29 <kmc> nuclear burrito waste, you say
20:45:31 <diabolix> how do you search for examples that use these crazy operators, they are completely un-googleable.
20:45:49 <Jafet> @where hoogle
20:45:49 <lambdabot> http://haskell.org/hoogle
20:46:01 <kmc> hoogle will only find you examples if those examples are in the Haddock docs
20:46:19 <kmc> anyway, everything you need to know about (>=>) is visible from its type
20:46:21 <kmc> :t (>=>)
20:46:22 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
20:46:24 <djahandarie> :t ala `asTypeIn` \ala -> ala undefined Data.Traversable.traverse [undefined]
20:46:25 <lambdabot> forall o o' (f :: * -> *) b. (Newtype (f b) o, Newtype (f [b]) o', Applicative f) => (o -> f b) -> ((o -> f b) -> [o] -> f [b]) -> [o] -> o'
20:48:32 <ion> :t ala `asTypeIn` \ala -> ala (undefined :: a -> Maybe a) Data.Traversable.traverse [undefined]
20:48:32 <lambdabot> forall o o'. (Newtype (Maybe o) o, Newtype (Maybe [o]) o') => (o -> Maybe o) -> ((o -> Maybe o) -> [o] -> Maybe [o]) -> [o] -> o'
20:51:16 <ddarius> kmc: That it should be associative is not visible from its type.
20:51:35 <kmc> diabolix, it's better to search for examples of using a whole library rather than individual operators defined by that library
20:51:42 <kmc> a lot of operators don't make sense in isolation
20:52:06 <kmc> in this case the libraries are the standard Haskell monad libraries
20:52:19 <kmc> and there are many documents about how to use those
20:52:27 <kmc> many of them confusing or outright incorrect
20:52:56 <SamB_XP> do we have a tutorial on how to avoid monad tutorials yet?
20:53:13 <cmccann> see, >=> is like laying two burritos end-to-end, then sort of squishing some of the filling from one to the other
20:53:35 <ddarius> SamB_XP: Yes.
20:53:35 <djahandarie> >=> is my face when reading monad tutorials
20:54:10 <SamB_XP> cmccann: where do the space suits come in?"
20:54:16 * ddarius doesn't know what djahandarie's face would become Kleisli composition.
20:54:30 <ddarius> s/what/why
20:54:44 * shachaf wonders if there are any burrito tutorials.
20:54:48 <kmc> @where burrito
20:54:48 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
20:54:50 <shachaf> "a burrito is like a monad"
20:54:53 <kmc> @google burrito tutorial
20:54:54 <lambdabot> http://www.youtube.com/watch?v=S0XlEaArgtM
20:54:54 <lambdabot> Title: A Burrito Tutorial for TheCamerAndy - YouTube
20:54:56 <aspect> :t flip
20:54:57 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
20:55:03 <kmc> :t Prelude.flip
20:55:04 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
20:55:04 <cmccann> haha
20:55:14 <SamB_XP> oh, the burrito tutorial is fictional?
20:55:16 * SamB_XP forgot
20:55:33 <kmc> i think somebody wrote one post-hoc
20:55:51 <cmccann> yes, the burrito analogy was supposed to be a reductio ad absurdum of monad tutorial analogies
20:56:12 <cmccann> after giving the matter some thought I personally think it actually holds up better than most of the ones meant seriously
20:56:15 <shachaf> A burrito is a lot like a monoid in the category of endofunctors.
20:56:18 <cmccann> which I guess gives you some idea of how silly the whole business is
20:56:46 <shachaf> I wonder what the burrito laws are. Do you need a food handler's license?
20:57:10 <SamB_XP> yes, when some of the actual tutorials exceed the aburdity of the reductio-ad-, that's pretty pathetic
20:57:13 * ddarius tries to recall if he's seen a newer way of chararterizing monads as something other than lax functors or monoid objects.
20:57:41 <ddarius> SamB_XP: Yeah.  You call that absurdum?  Brent should be ashamed of himself.
20:57:44 <cmccann> ddarius, the interpretation via modal logic is rather nice, but I don't recall the details
20:57:59 <kmc> i assume byorgey had just eaten or was in the process of eating a burrito when writing that article
20:58:01 <ddarius> cmccann: Monads model S5 modal logic.
20:58:02 <SamB_XP> of the actual tutorials, I meant
20:58:36 <diabolix> rwbarton, sorry, going between type errors and here, 'b (Just x) = a x; b Nothing = return ()' sounds like what I want, I was doing this by making my function that takes a 'Maybe' and does this for me, but is there something built in?
20:58:49 <SamB_XP> so, anyway, I want to see someone explain monads in terms of bikesheds
20:58:55 <kmc> diabolix, you can just write "b (Just x) = a x; b Nothing = return ()"
20:58:58 <kmc> that's valid Haskell code
20:59:23 <kmc> diabolix, but you can also write:  b = maybe (return ()) a
20:59:25 <ddarius> It needs a to be in scope.
20:59:27 <kmc> :t maybe (return ())
20:59:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
20:59:39 <SamB_XP> @pl maybe (return ()) a
20:59:39 <lambdabot> maybe (return ()) a
21:01:02 <diabolix> that hurts my head… what does maybe (return ()) a mean?
21:01:10 <kmc> what do you mean?
21:01:21 <kmc> it's applying the function "maybe" to the arguments "return ()" and "a"
21:01:33 <kmc> "return" itself is an ordinary function, not special syntax
21:01:40 <kmc> @src maybe
21:01:40 <lambdabot> maybe n _ Nothing  = n
21:01:40 <lambdabot> maybe _ f (Just x) = f x
21:01:45 <diabolix> oh, I was thinking 'maybe' was the type maybe.
21:01:48 <kmc> no
21:01:51 <kmc> maybe ≠ Maybe
21:01:57 <diabolix> thre is a function maybe?
21:02:00 <kmc> yes
21:02:01 <kmc> :t maybe
21:02:01 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:02:34 <SamB_XP> @src maybe
21:02:34 <lambdabot> maybe n _ Nothing  = n
21:02:34 <lambdabot> maybe _ f (Just x) = f x
21:03:14 * cmccann defines a conditional function named "bool" and a foldr with different argument order named "list"
21:03:31 <kmc> it's conventional to name an "extracting" function after the type, but with a lower-case name
21:03:33 <kmc> e.g.
21:03:34 <kmc> :t either
21:03:34 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
21:03:44 <cmccann> conventional meaning what, all two examples?
21:03:44 * djahandarie defines cata and calls it a day
21:03:52 <kmc> yep
21:03:56 <diabolix> ahhh, thats it.
21:03:59 <kmc> 2 makes a convention, right?
21:04:00 <copumpkin> I wouldn't call it cata
21:04:31 <djahandarie> I would if I'm making a joke about it since otherwise it's too vague to be funny :(
21:04:46 * cmccann defines lolcata
21:04:59 <kmc> cata :: (Functor f) => (f a -> a) -> Mu f -> a
21:05:08 <kmc> cata g = g . fmap (cata g) . out
21:05:10 <ddarius> @let cata alg = alg . fmap (cata alg) . out
21:05:11 <lambdabot>  Defined.
21:05:20 <kmc> :t cata
21:05:20 <lambdabot> forall (f :: * -> *) b. (Functor f) => (f b -> b) -> Mu f -> b
21:05:41 <ddarius> @let ana coalg = In . fmap (ana coalg) . coalg
21:05:42 <lambdabot>  Defined.
21:06:00 <kmc> :t ana
21:06:01 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> f a) -> a -> Mu f
21:06:55 <kmc> > let f 0 = []; f n = [n-1, n-2] in ana f 4
21:06:57 <lambdabot>   In [In [In [In [In [],In [In [In [In [In [In [In [In [In [In [In [In [In [I...
21:07:20 * cmccann puts up a sign saying "free burritos"
21:07:26 <kmc> > let f 0 = []; f 1 = []; f n = [n-1, n-2] in ana f 4
21:07:28 <lambdabot>   In [In [In [In [],In []],In []],In [In [],In []]]
21:09:06 <kmc> > let f 0 = []; f 1 = []; f n = [n-1, n-2]; g = succ . sum in cata g (ana f 4)
21:09:07 <lambdabot>   9
21:09:19 <diabolix> awesome. 'maybe' is what I needed. this language is very hard to google about.
21:09:42 <kmc> > let f 0 = []; f 1 = []; f n = [n-1, n-2]; g = succ . sum in map (cata g . ana f) [2..]
21:09:42 <aspect> hm monad burritos ... I think there's room for an article which models monad tutorials as monads
21:09:45 <lambdabot>   mueval-core: Time limit exceeded
21:09:51 <kmc> > let f 0 = []; f 1 = []; f n = [n-1, n-2]; g = succ . sum in map (cata g . ana f) [2..10]
21:09:52 <lambdabot>   [3,5,9,15,25,41,67,109,177]
21:10:03 <diabolix> thanks for the help!
21:10:08 <aspect> that would surely make it clear, as there are so many monad tutorials around people certainly understand those
21:10:36 <kmc> @quote analogies.are.endofunctors
21:10:36 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
21:10:47 <cmccann> hahaha
21:11:20 <ddarius> cmccann: What kind of burritos?
21:11:40 * shachaf is currently in San Francisco.
21:11:48 <shachaf> Maybe I should go have a burrito.
21:11:53 <kmc> who needs Google's dumb machine learning when you have the social, mobile, crowd-sourced search capabilities of #haskell
21:12:02 <ddarius> Or hoogle.
21:12:08 <kmc> #haskell is a second-generation, outside-in, pull-based, multiple-stakeholder, multiple-scale, high-automation, agile methodology
21:12:13 <cmccann> ddarius, the free kind. pick whatever functor you want.
21:12:41 <cmccann> kmc, that was physically painful to read
21:13:12 <kmc> if I lived in SF i would probably eat burritos for every meal, get burrito poisoning, and die
21:13:50 * shachaf fortunately lives in the South Bay.
21:13:52 <kmc> @oeis 3,5,9,15,25,41,67,109,177
21:13:53 <lambdabot>  a(n) = a(n-1) + a(n-2) + 1, with a(0) = a(1) = 1.
21:13:53 <lambdabot>  [1,1,3,5,9,15,25,41,67,109,177,287,465,753,1219,1973,3193,5167,8361,13529,21...
21:14:13 <shachaf> cmccann: That's a quote, you know.
21:14:17 <shachaf> http://en.wikipedia.org/wiki/Behavior_Driven_Development
21:14:27 <kmc> > let f 0 = []; f 1 = []; f n = [n-1, n-2]; g [] = 1; g x = sum x in map (cata g . ana f) [2..10]
21:14:28 <lambdabot>   [2,3,5,8,13,21,34,55,89]
21:14:30 <kmc> there we go
21:14:59 <cmccann> shachaf, welp. ok then.
21:15:03 <kmc> > let f 0 = []; f 1 = []; f n = [n-1, n-2]; g [] = 1; g = max 1 . sum in map (cata g . ana f) [2..10]
21:15:04 <lambdabot>   Equations for `g' have different numbers of arguments
21:15:04 <lambdabot>    <interactive>:1:42...
21:15:10 <kmc> > let f 0 = []; f 1 = []; f n = [n-1, n-2]; g = max 1 . sum in map (cata g . ana f) [2..10]
21:15:12 <lambdabot>   [2,3,5,8,13,21,34,55,89]
21:15:13 <cmccann> another example of why reductio ad absurdum doesn't work well in real life.
21:15:21 <wavewave> hi
21:15:26 <kmc> it's so weird to see a *finite* list of fibonacci numbers
21:15:28 <ddarius> cmccann: Real life is more absurd?
21:15:45 <wavewave> hi everyone
21:15:50 <kmc> hi wavewave
21:16:26 <wavewave> how come does haskell community become so fast in advancing our beloved language? ;-)
21:16:58 <cmccann> ddarius, so it seems
21:17:42 <kmc> > text ("hi " ++ concat (zipWith ((. return) . (:)) "everyone" "wavewave"))
21:17:44 <lambdabot>   hi ewvaevreywoanvee
21:18:38 <wavewave> hmm sounds eery
21:18:55 <kmc> > concat . transpose $ words "everyone wavewave"
21:18:57 <lambdabot>   "ewvaevreywoanvee"
21:19:17 <armlesshobo> i'm still having trouble understanding how all functions get curried
21:19:31 <armlesshobo> in haskell
21:19:33 <wavewave> I just read an article about constraint kind
21:19:41 <shachaf> > mapM_ (forkIO . putStr) ["everyone","wavewave"]
21:19:41 <lambdabot>   Not in scope: `forkIO'
21:19:53 <kmc> armlesshobo, it's just what the Haskell function-definition syntax means
21:19:59 <ddarius> armlesshobo: They don't.
21:20:10 <kmc> "f = \x y z -> ..." is sugar for "f = \x -> \y -> \z -> ..."
21:20:17 <armlesshobo> kmc, so, it's just another way of expressing a function?
21:20:19 <kmc> it's really just a syntactic property
21:20:21 <cmccann> it's lambdas all the way down
21:20:35 <cmccann> (except actually not)
21:20:39 <kmc> as far as the evaluation semantics of Haskell are concerned, there are only single-argument functions
21:20:45 <kmc> so there's no "partial application" per se
21:20:47 <ddarius> cmccann: All the way down to the algebraic data types and integers and abstract types and ...
21:21:03 <kmc> armlesshobo, i'm not sure what you mean by "another way of expressing a function"
21:21:11 <mzero> armlesshobo: are you asking how to think about it as a programmer? or how it is implemented?
21:21:13 <cmccann> ddarius, yes, that would be the "except actually not" part.
21:21:13 <kmc> that's a very general property which i think holds of most things in CS
21:21:20 <ddarius> "Partial application" is tricky to define in any meaningful way.  It's just application.
21:21:54 <armlesshobo> see, I'm reading about currying in the haskell wiki, but I don't think it means what I think it means.
21:22:13 <armlesshobo> I imagine that the functions we define as programmers are then curried by haskell
21:22:18 <wavewave> yes, "every function has a single argument" is a realization of eye-opening Tao...
21:22:19 <ddarius> No.
21:22:34 <kmc> maybe somebody has written a misleading wiki article
21:22:46 <shachaf> A curry burrito?
21:22:47 * cmccann figures a partial application comes from taking the partial derivative of an application with respect to something
21:22:48 <kmc> "f = \x y z -> ..." is merely shorthand syntax for "f = \x -> \y -> \z -> ..."
21:22:51 <armlesshobo> I am probably reading it incorrectly
21:22:51 <kmc> that's all
21:22:56 <ddarius> There's a curried style.  Haskell syntax encourages one to define functions in this style.  There is no "real function" that is being curried.
21:23:01 <mzero> armlesshobo: there is no "then curried" --- they just are ---- if you are used to multiple argument functions in other languages, then think of it like this....
21:23:26 <kmc> a multi-argument function is like a burrito
21:23:39 <wavewave> (X^Y)^Z = X^(Y*Z)
21:24:22 <ddarius> cmccann: Do you call force partial momentum?
21:24:24 <cmccann> kmc, and the uncurry function is like wadding the burrito up so you can shove the whole thing in your mouth at once
21:24:30 <kmc> om nom nom
21:24:33 <cmccann> ddarius, maybe I should
21:24:51 <cmccann> it sounds like a great way to confuse people
21:24:51 <kmc> maybe "uncurry" is where you carefully unwrap the burrito and eat it with a fork and knife
21:24:54 <kmc> and your friends stare at you
21:25:16 <cmccann> kmc, sounds plausible
21:25:19 <armlesshobo> but, how does curried function know about the other arguments?
21:25:22 <cmccann> add that to your faq
21:25:36 <kmc> armlesshobo, i don't understand the question
21:25:37 <ddarius> armlesshobo: What other arguments and why does it need to know about them?
21:25:38 <shachaf> armlesshobo: There is no "curried function".
21:26:00 <kmc> i think you're looking for answers to invalid questions
21:26:05 <kmc> Haskell only has single-argument functions
21:26:15 <armlesshobo> ...
21:26:16 <armlesshobo> so
21:26:20 <wavewave> By the way, what is the best way of writing Data.Data instance of existential type?
21:26:23 <kmc> "f = \x y z -> ..." is just shorthand for "f = \x -> \y -> \z -> ..."
21:26:24 <mzero> You define a function   f a b = ..... and, sure, there's some code that given two arguments computes a result.  But f is a critter that is hungry for one argument --- when applied to one argument, it produces a new critter that is hungry for yet another argument ---- finally, when THAT critter gets applied to an argument,  you get...... (warning, laziness) .... a blob that says... okay, if you REALLY want to know, I'll compute that value for you
21:26:25 * ddarius thinks armlesshobo doesn't understand lexical scoping(?)
21:26:25 <shachaf> f = \x -> \y -> x + y ... f 5 = \y -> 5 + y ... (f 5 3) = 5 + 3
21:26:25 <armlesshobo> i think i got it...
21:26:27 <cmccann> ddarius, oh, did I mention that I had some conformal GA stuff working using edwardk's coalgebra nonense?
21:26:31 <kmc> armlesshobo, that's the whole story
21:26:39 <ddarius> cmccann: What were you using it for?
21:26:51 <wavewave> DeriveDataTypeable is not successful for existential type.
21:27:04 <kmc> well, the other bit of the story is that (f x y z) is shorthand for (((f x) y) z)
21:27:09 <armlesshobo> kmc, so instead of looking at 'x' and 'y' in f x y as two arguments, 'x' and 'y' are just one argument?
21:27:14 <kmc> no
21:27:22 <kmc> (f x y) is ((f x) y)
21:27:30 <shachaf> armlesshobo: x is an argument; (f x) is a function that takes y, which is another argument.
21:27:38 <kmc> and the definition «f x y = ...» is actually «f = \x -> \y -> ...»
21:27:38 <mm_freak_> is there a data structure like Map, which alles me to search both the key and the value space in O(log n) or better?
21:27:43 <wavewave> function can spit out a function
21:27:46 <mm_freak_> alles → allows
21:27:46 <cmccann> ddarius, nothing much. trying to decide if I wanted to use it for things mostly. just defined some geometric elements, applied transformations, then projected to 2D for displaying on screen
21:27:47 <ddarius> armlesshobo: What is the result of (\x -> \y -> x+y) 5 ?
21:28:20 <wavewave> then spitted function can take next argument.
21:28:42 <shachaf> Functions can spit out functions?
21:28:43 <cmccann> ddarius, I have some rough notes on a geometry-oriented library I want to use for other things and would like to base it on something using GA
21:28:47 <shachaf> That sounds like monads-as-monsters.
21:28:54 <ddarius> mm_freak_: There is a bijective map somewhere probably on hackage.  It's been asked for enough.  If it isn't handy, you can just stick two maps together.
21:29:12 <Jafet> > map last . sort . init . (zipWith (++) . tails <*> inits) $ "everyone wavewave"
21:29:13 <lambdabot>   "ewwnvvevoyeaeae r"
21:29:19 <armlesshobo> ddarius: i don't know
21:29:28 <ddarius> armlesshobo: That would be your problem then.
21:29:34 <ddarius> Figure that out and the rest will make sense.
21:29:52 <mm_freak_> ddarius: ok, i'll go with the two maps…  thanks
21:30:24 <wavewave> Jefet: lonely r ... rrrrrrrrrrrrrrrr
21:30:27 <shachaf> armlesshobo: Do you know another language with first-class functions that this could be expressed in terms of, maybe?
21:30:49 * cmccann found that spending some time figuring out how to accomplish anything at all in plain lambda calculus is relatively enlightening for working in actual functional languages
21:31:07 * hackagebot xsd 0.3.5 - XML Schema data structures  http://hackage.haskell.org/package/xsd-0.3.5 (ThomasDuBuisson)
21:31:09 * hackagebot hxt-extras 0.4.1 - Extra functions for HXT  http://hackage.haskell.org/package/hxt-extras-0.4.1 (ThomasDuBuisson)
21:31:40 <armlesshobo> shacaf, C i guess
21:31:44 <mm_freak_> ddarius: what if the mapping is not bijective?  i need duplicates
21:32:13 <kmc> C doesn't have first-class functions
21:32:31 <mzero> armlesshobo: OK, C it is. Let's say you wanted to define a function "add" that takes two ints, and returns their sum
21:32:33 <kmc> in fact ddarius's example is the canonical demonstration of why not
21:32:41 <kmc> no, don't do this, it's not going to end well
21:32:46 <mzero> BUT - you're in wierdo-C land... and your functions can only take ONE argument
21:32:51 <cmccann> mm_freak_, (Map a (Integer, b), Map b (Integer, a)) ?
21:33:12 <kmc> armlesshobo, you don't know Perl or Python or Ruby or Javascript or C# or...?
21:33:12 <cmccann> mm_freak_, or do you mean something more than simple counts of multiplicity
21:33:21 <mzero> er - never mind - that ins't going to work well....
21:33:32 <armlesshobo> kmc, Perl
21:33:40 <wavewave> today, I read a book called "effective C++"
21:33:46 <kmc> armlesshobo, ((\x -> \y -> x+y) 5)  is  (\y -> 5+y)
21:33:48 <kmc> do you see why?
21:33:53 <mzero> okay - forget other languages.... let's just work on ......    f x y = x + y
21:34:00 <mzero> er, what kmc said
21:34:06 <wavewave> for some reason.
21:34:25 <wavewave> the author boast off how great C++ is..
21:34:38 <kmc> i imagine that a book called "effective C++" would be one of those hollowed-out books with a flask of whiskey inside
21:34:51 <cmccann> wavewave, "effective C++" sounds like a good title for an introductory book on learning some other language
21:34:53 <armlesshobo> kmc, i don't. in fact, that means nothing to me :\
21:34:58 <wavewave> it's really nothing compared with what we are talking mundanely.
21:35:01 <mm_freak_> cmccann: i have a set of values (contexts) and associated with each of them a time…  my computation should collect incoming contexts, but be limited in how many it keeps…  if the limit is exceeded, then the oldest context should be deleted
21:35:06 <kmc> armlesshobo, ok, let's step back
21:35:13 <kmc> do you know what the Haskell syntax (\x -> ...) means?
21:35:22 <kmc> what book etc. are you learning Haskell from?
21:36:05 <mm_freak_> cmccann: for each context i keep its last occurence and another (complicated) value
21:36:07 * hackagebot GPX 0.5 - Parse GPX files  http://hackage.haskell.org/package/GPX-0.5 (ThomasDuBuisson)
21:36:12 <armlesshobo> kmc, various places
21:36:14 <mm_freak_> complicated in that you can't have Eq or Ord for it
21:36:31 <Jafet> mm_freak: a queue, or a cache?
21:36:32 <kmc> armlesshobo, i suggest you pick a good book (LYAH or RWH) and read through it
21:36:38 <wavewave> anyway, I am very amazed by how fast our language is evolving compared with others.
21:36:45 <kmc> it doesn't make much sense to ask about currying if you don't know the lambda syntax yet
21:37:02 <kmc> wavewave, two language spec releases in 13 years?
21:37:04 <cmccann> haskell is mostly based on cutting edge research from several years ago
21:37:23 <mm_freak_> Jafet: i need O(log n) lookup for contexts in general and O(log n) lookup for the least recent context for my current problem
21:37:32 <kmc> Haskell is based on cutting-edge research from 20 years ago, which makes it more sophisticated than other languages, which are based on cutting-edge research from 60 years ago
21:37:41 <cmccann> other languages tend to be based on outdated research from decades ago and/or no research at all
21:37:43 <Jafet> Uh, I was only asking if you wanted the semantics of a queue or a cache.
21:38:16 <mm_freak_> Jafet: both…  i need queue semantics for deleting and cache semantics for lookup
21:38:20 <mzero> armlesshobo: http://learnyouahaskell.com/higher-order-functions#curried-functions
21:38:32 <ddarius> The 1930s was 80 years ago.
21:38:43 <cmccann> kmc, haskell is advanced by virtue of building on concepts that are younger than most people using the language
21:38:53 <mm_freak_> Jafet: it is in fact sort of a limited memory cache
21:38:54 <djahandarie> 3 - 1 is 2.
21:38:55 <kmc> hehe
21:39:06 <mm_freak_> (or should be, it is not right now)
21:39:13 <kmc> there is cutting-edge research in GHC's implementation details, though
21:39:20 <kmc> and in some of the language extensions
21:39:23 <wavewave> in terms of the language age, haskell is not that young in fact.
21:39:31 * ddarius remembers when "Practical Lock-Freedom" was new.
21:39:37 <wavewave> I think this is just haskell's own merit.
21:39:38 <kmc> i really really really want per-thread local GC
21:39:43 <kmc> i'm reading the paper about it
21:39:50 <kmc> apparently there's a branch in ghc.git
21:40:17 <mm_freak_> i think i know how to do it…  i'll keep a Map Time (Set a)
21:40:23 <wavewave> pursuing purity is finally rewarding.
21:40:26 <cmccann> kmc, true, but somewhat trivial, since GHC itself is a vehicle for current research
21:41:00 <cmccann> there's a pretty direct mapping from "shiny new features in GHC" to "papers listing SPJ as a coauthor"
21:41:25 <kmc> wavewave, yeah, people say "Haskell forces pure functional style" which is false... it's more that Haskell takes pure functional style seriously, and provides the tools so you can use pure FP if you want to
21:41:27 <Jafet> mm_freak: why not (Queue (Time, Label), Map Label Xyzzy)
21:41:34 <armlesshobo> how does it return a function? i think this is what is troubling me the most.
21:41:36 <kmc> whereas most languages have unnecessary mutation all throughout the standard library, etc
21:41:49 <ddarius> djahandarie: You writing Prolog?
21:41:50 <wavewave> also very diligent and brilliant effort on implementation, too
21:41:50 <kmc> armlesshobo, it just does... functions can take functions as arguments, and return functions as results
21:42:01 <kmc> that's the basis of functional programming
21:42:02 <Jafet> armlesshobo: irrelevant details
21:42:06 <cmccann> kmc, from everything I've heard clojure is pretty good about pure functional style, compared to most else out there
21:42:09 <kmc> > let f = (+) 2 in f 3
21:42:09 <lambdabot>   5
21:42:16 <kmc> cmccann, indeed. it'd rank high on my list
21:42:29 <ddarius> cmccann: It's not hard to be "good about pure functional style, compared to most else out there."
21:42:41 <kmc> Rich Hickey clearly Gets It in terms of pure FP, lock-free transactional concurrency, etc.
21:42:44 <wavewave> armlesshobo: Think every function as an object like number.
21:42:59 <cmccann> ddarius, yes, in that it actually tries at all
21:43:06 <ddarius> cmccann: Indeed.
21:43:13 <wavewave> armlesshobo: there is nothing special in being a function.
21:43:17 <kmc> armlesshobo, see my example with "let" above
21:43:23 <mm_freak_> Jafet: because a context can reappear, at which point its last seen time is updated
21:43:38 <wavewave> + is  a function
21:43:45 <cmccann> kmc, have you read the page detailing clojure's philosophy about state, mutation, identity, etc.?
21:43:52 <kmc> cmccann, i saw a talk of his about it
21:43:58 <cmccann> kmc, haha, ok
21:44:03 <wavewave> I can hold (+) like holding 3
21:44:19 <wavewave> return (+) like returning apple
21:44:27 <Jafet> mm_freak: you could keep its most recent time in Xyzzy then
21:44:29 <tommd> preflex: seen donws
21:44:30 <preflex>  Sorry, I haven't seen donws
21:44:33 <tommd> preflex: seen dons
21:44:33 <preflex>  dons was last seen on #haskell 5 days, 14 hours, 4 minutes and 59 seconds ago, saying: cheers byorgey
21:45:19 <Jafet> (+) is a function that is also a bunch of functions
21:45:22 <wavewave> get (+) like getting a diamond.
21:45:24 <Jafet> (yo dawg)
21:45:35 <tommd> @tell dons download-curl has a badly outdated tagsoup build-dep.  Could you update or give me an OK to upload a new one?
21:45:35 <lambdabot> Consider it noted.
21:46:11 <ddarius> (+) is a function that implicitly takes a record of functions, selects one, and returns it.
21:46:31 <armlesshobo> could you perhaps give the example in Perl?
21:46:51 <wavewave> mmm, sorry I don't know perl..
21:47:01 <kmc> armlesshobo, the expression (\x -> e) evaluates to a function (which is a value like any other) that takes an argument x and returns e
21:47:23 <kmc> armlesshobo, this "lambda abstraction" is the literal syntax for function values, the same way 3 is the literal syntax for Int values
21:47:24 <mm_freak_> Jafet: but i need to move the element in the queue
21:47:49 <ion> Which example in Perl?
21:47:50 <Jafet> mm_freak: you could just tack the new time to the queue, so there are two time records
21:47:51 <wavewave> would you give me a function which always add 3 to the original number?
21:47:52 <kmc> armlesshobo, anyway, explaining the basic idea of functional programming is a bit beyond the scope of this channel
21:48:00 <kmc> it's written about all over the Web in many different languages
21:48:03 <kmc> including perl
21:48:12 <Jafet> When you drop a time off the queue and it matches the time in the cache, drop it from the cache
21:48:23 <kmc> http://perl.plover.com/yak/fp/ http://hop.perl.plover.com/
21:49:12 <wavewave> sure.. (? + 3) : if you put any number in the place of ?
21:49:44 <Jafet> Hm, you'd have to look it up in the map then... unless Xyzzy is an IORef
21:50:06 <Jafet> Your queue would also be a bit longer than it had to be
21:50:10 <mm_freak_> Jafet: doesn't really work well with repeated contexts
21:50:33 <mm_freak_> because on repeated contexts, elements can fall off the queue, which would then never be deleted
21:50:39 <wavewave> in appreviation, this is a function named (+3), Formally, \x -> x +3
21:50:42 <mm_freak_> unless the queue is unlimited, which would destroy the point
21:50:46 <ion> $ perl -lwe 'print sub { my $a = shift; sub { my $b = shift; $a+$b } }->(42)->(1)'
21:50:49 <ion> 43
21:50:59 <ion> Was this the example you meant?
21:51:13 <Jafet> mm_freak: if it wasn't deleted from the cache, wouldn't that imply that there was another "context" in the queue?
21:51:29 <ddarius> "Simplifying is a modern concept.  In Perl we don't strive to simplify things."
21:51:47 <kmc> because Perl is post-modern?
21:52:18 <mm_freak_> Jafet: given a limit of 100, you get context A, then 99 times context B and finally a context C…  the least recent context would be B, because A would have fallen off the queue
21:52:39 <mm_freak_> unless the queue is twice as large as the map i suppose
21:52:52 <Jafet> Oh, I thought you wanted a limit based on time, not space
21:53:16 <mm_freak_> but i would still need O(n) search to find the least recent context
21:53:38 <LordBrain> whats the correct way to uninstall a cabal package?
21:53:40 <mm_freak_> i guess for now i'll use a simple bulk seek and destroy algorithm
21:53:44 <shachaf> LordBrain: There is none.
21:53:47 <Jafet> If you want that, it just doesn't work
21:53:55 <shachaf> LordBrain: ghc-pkg unregister will unregister it from GHC's database.
21:54:17 * ddarius recommends setting your computer on fire.
21:54:33 <ddarius> @vera HCF
21:54:34 <lambdabot> *** "hcf" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
21:54:34 <lambdabot> HCF
21:54:34 <lambdabot>      Hybrid Coordination Function (MAC, 802.11a)
21:54:34 <lambdabot>  
21:54:40 <Jafet> mm_freak: in that case I'd say (Map Time Context, Map Context Xyzzy)
21:55:06 <mm_freak_> Jafet: Map Time (Set Context)
21:55:17 <mm_freak_> the time difference between contexts can be 0
21:55:34 <wavewave> by the way, what's going on in making haskell 2011 or 2012 or something like that?
21:55:43 <kmc> wavewave, there will be no Haskell 2011
21:56:00 <wavewave> kmc: what's current decision?
21:56:10 <kmc> the committee produced one recommendation for Haskell 2012 and then went back into its burrow for six more weeks of winter
21:56:13 * Jafet gives mm_freak a magic monotone clock
21:56:29 <shachaf> The Haskell committee is a lot like the NetHack DevTeam.
21:56:58 <Jafet> shachaf: fictional?
21:56:59 <wavewave> where can I see haskell 2012 recommendation?
21:57:24 <mm_freak_> Jafet: just gimme a nondiscrete clock =)
21:58:05 <wavewave> I feel haskell 2010 is too distant from what I am using right now..
21:58:36 <LordBrain> heh
21:58:59 * cmccann wonders if a blessed scroll of genocide would suffice to get rid of Num
21:59:07 <LordBrain> well, rewind a year or two and think about how distant 98 was heh
21:59:59 <wavewave> at least we should have multi parameter type classes in standard.
22:00:17 <ddarius> cmccann: Enough genocide will get rid of any problem.
22:00:39 <kmc> wavewave, i disagree.  the situation between mptc, fundeps, and associated types in GHC still hasn't sorted out
22:01:08 <ddarius> kmc: There is no issue with MPTCs.
22:01:09 <wavewave> kmc: but all monad tools we are using are mptc.
22:01:26 <kmc> wavewave, no they aren't.  'transformers' is Haskell 98 and 'monads-tf' is sptc + asstypes
22:01:28 <wavewave> fundeps and associated types are differnt.
22:01:56 <kmc> ddarius, no theoretical issue, but maybe they fit in with these other features in some yet-undiscovered nicer way
22:02:53 <edwardk> as far as i'm concerned the situation with mptcs, fundeps, associated types is pretty well sorted. they overlap but neither subsumes the other at least from a user perspective. what you use to implement it in the back end is irrelevant
22:02:56 <Jafet> cmccann: Wiped out all Int. Wiped out all Integer. Wiped out all Double. Wiped out all Complex. Wiped out all Ratio. Wiped out all Fixed. Wiped out all (a, b). Wiped out all (a, b, c). Wiped out all (a, b, c, d). Wiped out all (a -> b).
22:03:19 <ddarius> There's no reason to remove multiparameter type classes and as far as I know nothing reasonably replaces them.  -Some- uses of multiparameter type classes can be replaced by typem families, but not all (namely the ones involving functional dependencies.)
22:03:28 <kmc> edwardk, so you think the fundep syntactic sugar is worthwhile even though you can implement the same thing with asstypes and superclass equality constraints?
22:03:34 <cmccann> "You hit the class instance. The instance resolution diverges! --More-- The context resolution stack overflows! You die... --More-- Would you like your types identified? [y/n]"
22:03:41 <tgeeky> ddarius: what? are you sure that's right?
22:03:41 <Jafet> Didn't wipe out CReal, because its instances are partial.
22:03:51 <djahandarie> ddarius, can't we do it all with superclass constraints?
22:03:54 <kmc> yeah, btw, will GHC ever support backtracking instance resolution?
22:03:55 <djahandarie> Or a lot of it at least.
22:04:18 <edwardk> kmc: yes. i have many MPTCs that have 3 or 4 different fundeps. that is hell with mere associative types.
22:04:20 <kmc> djahandarie, a pure «class C a b» with no fundep can't be replaced with that
22:04:24 <kmc> yeah
22:04:33 <tgeeky> ddarius: my reading of typefams implied that fundeps are central to the the idea, not prohibitive
22:04:38 <edwardk> er associated
22:04:40 <kmc> i'm just uncomfortable adding this many not-similar-but-not-quite-the-same language features
22:04:46 <ddarius> tgeeky: No.
22:04:48 <kmc> also asstypes + type families
22:04:49 <edwardk> haskell has always had rich surface syntax
22:04:52 <kmc> are another duplicated pair
22:05:03 <edwardk> where vs. let, case vs. pattern matching
22:05:13 <edwardk> i have no problem retaining two overlapping language features
22:05:18 <shurane> So uh... quick question: can I generate intermediate code in C? ghc --make --keep-hc-file doesn't quite do that. I'm guessing it's because Haskell generates assembly-code directly now?
22:05:21 <edwardk> when neither subsumes the other for all cases
22:05:30 <tgeeky> ddarius: go on...
22:05:35 <kmc> "Haskell" doesn't generate anything
22:05:44 * cmccann just wishes fundeps were either a saner logic language, or type families were saner type functions
22:05:47 <kmc> shurane, the short answer is "use -fvia-C"
22:05:48 <wavewave> I agree.. it's about 10 years. It's enough time for maturing.
22:06:01 <kmc> shurane, but that's deprecated in GHC 7, and disabled by default in GHC 7.2
22:06:11 <kmc> the currently supported backends are the direct native codegen and the LLVM backend
22:06:13 <ddarius> tgeeky: Functional dependencies never had a proper formal description.  Type families do, and so do functional dependencies now... in terms of type families.
22:06:19 <Jafet> -fvia-some-pseudo-C-thingy
22:06:21 <kmc> shurane, why do you want some C code?
22:06:36 <kmc> it's not like the C code is readable or will link with anything else sanely
22:07:41 <shurane> Well, for one, I imagined the c-code would be readable, but if it isn't...
22:08:06 <shachaf> shurane: The C code GHC generates is very different from C code you would write.
22:08:08 <kmc> shurane, it's not even C.  the stuff produced by GHC 7.0 and earlier's -fvia-C by default is a mess of GCC extensions and fake function calls which get post-processed by *a Perl script* which runs on the assembly output of gcc
22:08:11 <dankna> yeah, it's really not.  for example, functions in the low-level representation don't correspond 1:1 with functions in the Haskell code.
22:08:22 <wavewave> anyway, I wish we will see some progress MPTCs in the next standardization.
22:08:35 <Olathe> Wait, GHC uses Perl?
22:08:40 <cmccann> kmc, please don't bring up the Evil Mangler
22:08:42 <cmccann> it's dead now
22:08:44 <cmccann> leave it be
22:08:46 <kmc> heh
22:08:47 <wavewave> Olathe : no
22:08:55 <wavewave> Perl uses haskell ;-)
22:08:55 <Olathe> Oh, good.
22:08:58 <cmccann> Olathe, google for "Evil Mangler"
22:09:03 <tgeeky> ddarius: my bad. I re-read your sentence a few times. You were making a point about MultiP type classes, comparing to (both) FunDeps and TypeFams.
22:09:04 <shurane> Also, an idea I had was to using haskell at a code competition (maybe), where they only accept C/C++ and Java...
22:09:06 <Olathe> OK :)
22:09:14 <ddarius> wavewave: The problem there is that you -really- want functional dependencies or type families if you add multiparameter type classes, so MPTCs are going to be added until we figure out what we are going to do with those.
22:09:15 <kmc> ah, C/C++, the famous language
22:09:23 <dankna> shurane: you're best off not gaming the rules at those things
22:09:33 <kmc> Olathe: GHC's registerized fvia-C backend uses a Perl script to mangle the assembly output of gcc
22:09:58 <kmc> Olathe, the registerized via-C backend was removed in 7.2.  now if you want C it's the more portable but much slower "unregisterized" C code
22:10:03 <kmc> and iirc that backend is disabled by default
22:10:16 <cmccann> ddarius, MPTCs make sense without either of those. they just don't apply to most things people want to use them for.
22:10:30 <ddarius> cmccann: I believe that's what I've been saying.
22:10:56 <wavewave> ddarius: I understand the issue. maybe we need some time since type families are relatively new.
22:10:57 <ddarius> though "so MPTCs are going to be added" should be "MTPCs aren't going to be added"
22:11:06 * hackagebot authenticate 0.10.2.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.10.2.1 (MichaelSnoyman)
22:11:16 <ddarius> wavewave: Yeah.  I think another 15 years or so will do.
22:11:17 <kmc> shurane, are the jugdes going to read your code?
22:11:32 <shachaf> We will add MPTCs, and *keep* adding them, until we figure out what to do with them!
22:11:34 <kmc> shurane, also, will they mind that you include hundreds of .c files consisting of the entire GHC runtime system and base libraries?
22:11:34 <cmccann> ddarius, it sounded like you were saying MPTCs aren't useful at all without either of those, which isn't really true.
22:11:36 <wavewave> Another thing is existential type.
22:11:54 <kmc> shurane, for what you're doing, JHC's C output might be a lot more useful than GHC's
22:11:56 <tgeeky> cmccann: no, that was my ignorance reflecting in the chatroom
22:11:58 <wavewave> It is not in haskell 2010, am I right/
22:12:15 <kmc> MPTC are not in H2010, correct
22:12:20 <ddarius> cmccann: I don't know why it would sound that way.  It should sound like you probably don't -want- MPTCs without the other two.
22:12:26 <kmc> almost nothing interesting was added from H98 to H10
22:12:33 <kmc> just PatternGuards ;P
22:12:48 <cmccann> ddarius, ok.
22:12:53 <dave1231> armlesshobo: this might be helpful - http://learnyouahaskell.com/higher-order-functions#curried-functions
22:13:11 <wavewave> I guess that Existential Type is easier to add than MPTCs.
22:13:41 <kmc> eww, don't add existentials yet
22:13:43 * cmccann adds an existential type to haskell. you can't do anything with it, but it definitely exists
22:13:50 <ddarius> kmc wants free existentials.
22:13:54 <kmc> GHC and UHC have different incomplete implementations of existentials
22:14:08 <ddarius> HBC has an implementation of existentials.
22:14:15 <kmc> full on?
22:14:19 <tgeeky> ddarius: correct if wrong?:  MPTCs can be used to write classes that are arbitrarily vague. FunDeps and TypeFams are two ways to inform GHC of relationships between paramters, which happen to be interrelated.
22:14:22 <wavewave> what's free existentials?
22:14:28 <kmc> full on double rainbow all the way?
22:14:52 <tgeeky> so MPTCs can be used to constrct things that are too general to be useful, and FunDeps and TFs can be used to specialize them into utility?
22:14:58 <wavewave> there is  always  something to learn here ;-)
22:14:59 <cmccann> tgeeky, MPTCs alone have completely independent type parameters.
22:15:09 <ddarius> tgeeky: MPTCs allow you to write type relations rather than just type predicates.  FunDeps and AssociatedTypes are two equivalent ways of saying that that relation is functional.
22:15:10 <tgeeky> cmccann: that's what I picture
22:15:23 <cmccann> tgeeky, it's not so much too general to be useful, just usually not what people actually want
22:15:53 <tgeeky> cmccann: that statement is hard for me to understand, because I don't know what *I* want, no less other people
22:16:14 <tgeeky> I'm looking at multiplate right now...
22:16:34 <tgeeky> applyNaturalTransform :: forall p f g. (Multiplate p) => (forall a. f a -> g a) -> p f -> p g
22:16:43 <ddarius> kmc: I thought it did at one point, but I had difficulty verifying it.
22:16:56 <tgeeky> type Projector p a = forall f. p f -> a -> f a
22:17:16 <tgeeky> this "only" uses RankNTypes and ScopedTypeVars
22:17:20 <ddarius> Finding information about hbc is difficult, other than by yelling at Lennart.
22:17:36 <ddarius> ScopedTypeVars is a pretty mild and useful extension.
22:17:51 <wavewave> ddarius: I agree !
22:17:52 <tgeeky> ddarius: yeah, so it appears.
22:18:04 <ddarius> Rank2Types is a widely supported extension that has been implemented for, I think, the entire history of GHC.
22:18:23 <ddarius> RankNTypes is fancier and has some more problems, but will likely get standardized sooner or later.
22:18:25 <wavewave> in fact, I am trying all kind of type extensions whenever I can do.
22:18:25 <kmc> GHC's ScopedTypeVariables abuses the forall syntax somewhat
22:18:37 <ddarius> Your example probably doesn't actually require RankNTypes.  It probably only requires Rank2Types.
22:18:49 <ddarius> There is no forall syntax to abuse.
22:18:52 <kmc> is there any chance they'd standardize Rank2Types and not RankNTypes
22:18:52 <wavewave> my source codes are full of LANGUAGE pragma, lol
22:18:58 <tgeeky> ddarius: I think roconnor's paper explicitly says it requires RankN
22:19:00 <ddarius> To the extent that it "abuses" it, it makes it mean what it should mean.
22:19:08 <ddarius> kmc: Probably not nowadays.
22:19:15 <ddarius> I hope they don't.
22:19:36 <kmc> nowadays because working with RankN in GHC for n+1 years has convinced people that inference issues are minor?
22:19:59 <wavewave> from Rank2Types, type checker is undecidable, is it right?
22:20:05 <kmc> no
22:20:09 <wavewave> or Rank3?
22:20:12 <cmccann> type inference, not checking.
22:20:12 <ddarius> kmc: Something like that.  There's enough experience about it to know it doesn't blow up and kill people and that it is useful.  It's also rather foundationally important.
22:20:14 <kmc> i think you mean type inference
22:20:14 <wavewave> I am confused.
22:20:27 <wavewave> ahh type inference..
22:20:43 <ddarius> Also, we understand how to implement it.
22:20:51 <mm_freak_> > sortBy (flip $ comparing id) $ [1,3,2,4,6,5]
22:20:51 <wavewave> hmmm... I am confused..
22:20:52 <lambdabot>   [6,5,4,3,2,1]
22:20:54 <kmc> there's no way to abuse rank-3 types to do arbitrary computation at the type level
22:21:07 <wavewave> type inference is undecidable but type checking is okay.. is it right?
22:21:11 <kmc> yes
22:21:35 <kmc> to get undecidable type-checking you usually need to allow arbitrary functions at type level
22:21:45 <shachaf> Rank-3 types are useful.
22:21:48 <wavewave> so we need some explicit type signature sometimes? then checking is okay?
22:21:49 <ddarius> s/functions/computations/
22:21:50 <kmc> callCC has a rank-3 type
22:21:52 <kmc> or should ;P
22:21:54 <kmc> wavewave, yes
22:21:59 <tgeeky> kmc: I take that to mean, for instance, if I wanted to build some complicated thing in Haskell using multiplate (which requires rank3), I'd have to list type signatures for everything?
22:22:02 <wavewave> I see. thanks.
22:22:15 <ddarius> tgeeky: No.
22:22:15 <kmc> wavewave, but inference is useless if you can't predict when it will fail -- ask anyone who programs in Scala
22:22:34 <kmc> so it's also important that even with rank-3 types, inference mostly still works
22:22:49 <kmc> not for everything, but perhaps for everything with a rank-3 type
22:22:49 <tgeeky> no, that's not right - because I only need explicit types for this module
22:22:50 <wavewave> what's special about Scala? (I don't know the language at all.)
22:23:18 <ddarius> tgeeky: You pretty much only need explicit types when your types will be higher rank.
22:23:41 <armlesshobo> ... i got it now...
22:23:44 <kmc> i'm going to claim that Scala is Java++
22:23:53 <shachaf> @karma Java
22:23:53 <lambdabot> Java has a karma of -10
22:24:05 <wavewave> haha..
22:24:07 <tommd> @karma jvm
22:24:07 <lambdabot> jvm has a karma of 0
22:24:15 <wavewave> that's funny
22:24:21 <ddarius> @karma
22:24:21 <lambdabot> You have a karma of 20
22:24:24 <ddarius> Java++
22:24:28 <wavewave> @haskell
22:24:28 <lambdabot> Unknown command, try @list
22:24:31 <ddarius> @karma Java
22:24:31 <lambdabot> Java has a karma of -10
22:24:35 <kmc> in the 1990s, a scramble to add OOP buzzword-compliance to everything
22:24:37 <wavewave> @karma haskell
22:24:37 <lambdabot> haskell has a karma of 62
22:24:42 <kmc> now, a scramble to add FP buzzword-compliance to everything
22:24:43 <ddarius> I think it's only with the explicit @karma+ command.
22:24:46 <ddarius> @karma
22:24:46 <lambdabot> You have a karma of 19
22:24:50 <wavewave> @karma
22:24:50 <lambdabot> You have a karma of 0
22:24:54 <wavewave> kek
22:24:54 <dankna> @karma
22:24:54 <lambdabot> You have a karma of 3
22:25:00 <ddarius> So incrementing Java's karma decrements yours.
22:25:02 <dankna> wavewave, die hordie!
22:25:06 <dankna> (WoW thing)
22:25:26 <ddarius> And I think incrementing Java's karma decrements it if you use the more explicit interface, but maybe it just always does nothing.
22:25:46 <LordBrain> if a compiler is gpl v3 is that an issue for the programs that users create with it?
22:25:52 <ddarius> No.
22:26:21 <ddarius> Though the standard libraries linked in or any run-time system could presumably be a problem.
22:26:30 <wavewave> in fact, I am quite new in irc world. How can I give and take karma?
22:26:37 <dankna> you just type username++
22:26:39 <dankna> @karma username
22:26:39 <lambdabot> username has a karma of 1
22:26:47 <wavewave> wavewave++
22:26:49 <ddarius> This karma is a lambdabot thing.
22:26:49 <dankna> or username-- to take it away
22:26:52 <dankna> @karma username
22:26:53 <lambdabot> username has a karma of 0
22:26:55 <dankna> thusly
22:26:57 <cmccann> @karma lambdabot
22:26:57 <lambdabot> lambdabot has a karma of 11
22:26:58 <wavewave> this doesn't count.
22:27:01 <Jafet> You get karma by doing good things
22:27:04 <shachaf> preflex: karma ddarius
22:27:04 <preflex>  ddarius: 31
22:27:07 <wavewave> dankna++
22:27:13 <dankna> this is just for channels that lambdabot sits in though, it's not an IRC generic thing
22:27:18 <dankna>  /whois lambdabot
22:27:20 <wavewave> @karma
22:27:21 <lambdabot> You have a karma of 0
22:27:27 <wavewave> @karma dankna
22:27:27 <lambdabot> dankna has a karma of 4
22:27:29 <ddarius> Though lambdabot is a little promiscuous.
22:27:41 <wavewave> oh... I gave you a karma point.
22:27:45 <tommd> If a language uses the entire text of the GPL3 license as a primitive is that an issue for the source code users create in that language?
22:27:53 <dankna> you did, I thank you haha
22:28:19 <dankna> tommd: inasmuch as it hurts readability
22:28:43 <kmc> LordBrain, it is an issue, socially.  because many people have an irrational fear of the GPL
22:28:50 <dankna> or a rational one, too
22:28:54 <dankna> many people fear it, anyway
22:29:03 <wavewave> how can a language have GPL3 license?
22:29:05 <kmc> your company might categorically ban the use of GPL software, even when you're clearly within your rights to use it
22:29:06 <Jafet> Isn't the GPL licensed with the GFDL
22:29:13 <kmc> the GFDL is a non-Free license!
22:29:22 <Jafet> Oh, you're right!
22:29:29 * cmccann encourages the use of the WTFPL
22:29:41 <Jafet> So what license does the GPL use.
22:29:50 <kmc> maybe the GFDL ;P
22:29:51 <cmccann> sadly cabal doesn't know about WTFPL :[
22:30:12 <kmc> just because Debian considers the GFDL a non-Free license does not mean GNU / FSF do
22:30:19 <dankna> I heard once that legal text can't be copyrighted, hence licensing it would be irrelevant, but I'm not sure whether a license agreement counts as legal text for that purpose.
22:30:51 <dankna> the real question is, what license is THAT license under
22:30:55 <dankna> or is it licenses all the way down
22:30:56 <kmc> and yes, in saying there exists irrational fear of GPL i do not mean to exclude the possibility of rational fear
22:31:01 <dankna> fair enough
22:31:04 <wavewave> hmm complicated issue.
22:31:55 <cmccann> as a first order of approximation I assume that all opinions about licenses are irrational
22:32:22 <wavewave> after having four bottles of beer, I am dreaming of some old days of free hackers........
22:32:23 <LordBrain> lol
22:32:54 <dankna> cmccann: sounds likely
22:33:02 <ddarius> A world where software didn't matter so no one gave a damn.
22:33:03 <wavewave> feel like haskell community is probably close to when linux bursted out.
22:33:20 <dankna> 95 bottles of beer on the wall?
22:33:31 <kmc> like a chest-burster?
22:33:44 <ddarius> dankna: You're assuming he's already taken down the 96th.
22:33:54 <dankna> how would he drink it otherwise?
22:33:56 <kmc> ddarius, you have to pipeline these things
22:34:09 <dankna> take one down while passing around the one before it
22:35:07 <wavewave> is haskell already in success or success in avoiding success?
22:35:31 <ddarius> kmc: You don't play racquetball do you?
22:35:44 <wavewave> very charming catchphrase : avoiding success.
22:35:47 <dankna> define success
22:36:01 <ddarius> success = return ()
22:36:10 * dankna chortles out loud :)
22:36:16 <wavewave> return _|_
22:36:27 <wavewave> I like the symbol _|_
22:36:33 <ddarius> I believe that definition is in LogicT or some similar "logic monad" library.
22:36:48 <kmc> i like the symbol ⊥
22:37:00 <wavewave> that's better
22:37:12 <cmccann> yay. unicode
22:37:29 <wavewave> are there any way to typing lazyness?
22:37:35 <cmccann> everyone loves unicode
22:37:53 <kmc> wavewave?
22:38:19 * ddarius can't wait for UCS16.
22:38:21 <wavewave> I mean.....make a type-system present laziness
22:38:38 <kmc> wavewave, have you seen Disciple?
22:38:52 <wavewave> kmc: I didn't look into it.
22:39:04 <wavewave> kmc: does it have a way?
22:39:09 <kmc> i guess so
22:39:10 * cmccann thinks distinguishing data from codata and such would be more useful than worrying about laziness as such
22:39:12 <kmc> i don't know much about it either
22:40:12 <wavewave> cmccann: would you elaborate it a little bit more for me?
22:40:16 <kmc> dankna, presumably a license can be licensed under itself, too
22:40:43 <ddarius> @google paradox of self-amendment
22:40:44 <lambdabot> http://www.earlham.edu/~peters/writing/psa/
22:40:44 <lambdabot> Title: Peter Suber, Paradox of Self-Amendment, Table of Contents
22:40:56 <wavewave> I just wonder if there is a way to explicit say that this library is lazy like this as the type stands.
22:41:01 <cmccann> wavewave, distinguishing between finite data that you can consume with structural recursion vs. possibly infinite data that you can consume incrementally
22:41:45 <wavewave> for example, can we distinguish foldl from foldl' without looking inside?
22:42:07 <dankna> kmc: yeah, but that's not necessarily appropriate when the license is designed for code
22:42:14 <dankna> kmc: anyway that is the obvious solution for documentation licenses
22:42:25 <ddarius> wavewave: Yes.
22:43:15 <wavewave> ddarius: this is something new to me. Please explain. o.o
22:44:15 * cmccann should find more places to use the ⊢ symbol
22:44:24 <ddarius> wavewave: You can write a function, f, such that f foldl terminates but f foldl' does not.
22:44:52 <shachaf> Unicode needs support for arbitrary rotations.
22:45:01 <shachaf> It would make things so much simpler.
22:45:19 <wavewave> ddarius: hmm. but that is not so explicit.
22:45:44 <wavewave> ddarius: I would like to have some explicitness like a type signature.
22:46:08 <wavewave> or something corresponding to that (it does not have to be a type.)
22:46:23 <shachaf> A Seq type class would be a way to indicate that, sort of.
22:46:45 <wavewave> Seq..
22:46:55 <ddarius> shachaf: You mean Eval?
22:47:29 <shachaf> ddarius: Eval?
22:47:43 <shachaf> Oh, a Haskell 1.4 thing?
22:47:53 <shachaf> Huh.
22:48:07 * shachaf didn't know about this.
22:48:10 <kmc> have a capacitor: ⊣⊢
22:48:10 <wavewave> if it is not expressible in type but in some other way, I suggest that we should show it in haddock!
22:48:20 * shachaf mad
22:48:28 <wavewave> kmc: look like a +
22:48:38 <ddarius> For cmccann, ⋌.
22:48:41 <shachaf> kmc: Well? wavewave gave you an order!
22:49:13 <wavewave> kmc: prove me it's disconnnected.
22:50:44 <wavewave> How can I write a saying only for myself in irc?
22:50:56 <ddarius> ⋌∘⋋   ⋌∘⋋
22:50:58 <wavewave> like "shachaf didn't know about this."
22:51:09 <wavewave> like "shachaf mad"
22:51:26 <shachaf> wavewave: Depends on your client.
22:51:35 <wavewave> I am using xchat
22:51:43 <shachaf> wavewave: \001ACTION ...\001
22:51:46 <shachaf> Oh, in that case, /me ...
22:51:56 <mm_freak_> what exactly is strict in the strict state monad?
22:51:57 <wavewave> \001 is doing a test \001
22:51:59 <JoeyA> You prefix it with your password.
22:52:04 * JoeyA nobody sees my password but me.
22:52:05 <wavewave> \001ACTION is doing a test \001
22:52:11 <cmccann> ddarius, ah, a vertical lambda, clearly. must be useful for writing functions from bottom to top.
22:52:17 <wavewave> hm.
22:52:26 <shachaf> ג is a nice lambda.
22:52:32 * wavewave is doing a test
22:52:36 <wavewave> AHA!!!
22:52:40 <JoeyA> just kidding.  /me blah blah
22:52:46 <JoeyA> http://bash.org/?244321
22:52:46 <ddarius> It's a nice gimel.
22:53:02 <shachaf> My father always confuses lambda and gamma because of gimel.
22:53:22 <copumpkin> anyone see anything wrong with peekCAString =<< (#peek Dl_info, dli_fname) ptr, assuming the dli_fname is a char *?
22:53:46 <wavewave> shachaf++
22:54:04 <wavewave> @karma shachaf
22:54:04 <lambdabot> shachaf has a karma of 6
22:54:18 <ddarius> @hoogle peekCAString
22:54:18 <lambdabot> Foreign.C.String peekCAString :: CString -> IO String
22:54:18 <lambdabot> Foreign.C.String peekCAStringLen :: CStringLen -> IO String
22:54:29 <shachaf> copumpkin: peekCAString takes a CString, not a CStringLen.
22:55:08 <copumpkin> shachaf: and?
22:55:09 * cmccann wonders what would be an appropriate use for ‽ as an operator
22:55:27 <JoeyA> Something having to do with Maybe?
22:55:35 * wavewave fought with ghc in figuring why Data.Data cannot be automatically derived for existential types. 
22:55:36 <JoeyA> or nondeterminism?
22:55:36 <copumpkin> it compiles just fine
22:55:39 <copumpkin> it just produces garbage
22:57:19 <ddarius> copumpkin: Is dli_fname nul terminated?  Is it ASCII?
22:57:27 <copumpkin> oh nevermind
22:57:28 <copumpkin> yes, it is
22:57:33 <copumpkin> it was working all along
22:57:52 <ddarius> * In, Garbage Out
22:57:56 <copumpkin> :)
22:57:56 <shachaf> copumpkin: Oh, I misread.
22:58:09 <copumpkin> SymInfo {objName = "/usr/lib/libSystem.B.dylib", objBase = 0x00007fff83a30000, symName = "printf", symAddr = 0x00007fff83aae3b6}
22:58:46 <ddarius> copumpkin: Going to create reversing tools in Haskell?
22:58:57 <copumpkin> oh yes, that's been a plan all along
22:59:05 <copumpkin> but this is a lightweight library for talking to libdl
22:59:14 <copumpkin> and my main goal for it is to serialize me some closures
22:59:28 <copumpkin> assuming nobody strips out the symbols :)
22:59:29 <ddarius> Imagine applying Hoopl to reversing.
22:59:36 <copumpkin> :P
22:59:58 <copumpkin> you mocking me for going on about that?
23:00:21 <ddarius> No.  Hoopl would be pretty cool and I suspect very useful for reversing.
23:00:24 <copumpkin> oh yes
23:00:46 <copumpkin> I assumed I'd already given you my long spiel about everything I wanted to do with it for reversing
23:00:55 <ddarius> Binary analysis (and maybe also optimization) is something that I have some unrealized interest in.
23:01:06 <copumpkin> before I got sucked into all this category theory stuff it was my main haskell project
23:01:19 <wavewave> start fifth beer, lol
23:01:20 <copumpkin> then I went off into lala land but now I'm feeling a bit more concrete again
23:01:21 <ddarius> copumpkin: Possibly, but it might have been that time we went to the Thai place which was like 8 months ago or more.
23:01:28 <copumpkin> ah yeah
23:01:35 <copumpkin> but anyway, definitely something I want to work on :)
23:01:39 <copumpkin> I think kmc might too
23:01:44 <copumpkin> although maybe not hoopl specifically
23:02:01 <ddarius> Maybe I should enter the reversing field.  You and I will just trade places.
23:02:22 <copumpkin> :D
23:02:37 <copumpkin> I'd be quite happy to steal all your knowledge
23:03:22 <ddarius> There are cobwebs on my electric.
23:03:23 <ddarius> ...
23:03:45 <hpaste> wavewave pasted “Existential, Derive Data” at http://hpaste.org/51222
23:04:15 <kmc> what did i do
23:04:24 <copumpkin> oh, just talking about reversing tools
23:04:28 <kmc> yeah
23:04:28 <copumpkin> and how much we want to throw hoopl into the mix
23:04:30 <kmc> good stuff
23:04:31 <wavewave> oh.. now hpaste automatically shows what I did.
23:04:36 <kmc> hooplheads
23:04:39 <copumpkin> :)
23:05:17 <ddarius> Hoopl takes out the part of a dataflow analysis you really don't want to write and also puts in equality saturating sexiness.
23:05:17 <copumpkin> what's a nice way to represent or'd together flags in a C API?
23:05:23 <wavewave> Why existential type cannot be automatically derived? http://hpaste.org/51222
23:05:40 <ddarius> copumpkin: In Haskell you mean?
23:06:06 * hackagebot netwire 1.2.4 - Arrowized FRP implementation  http://hackage.haskell.org/package/netwire-1.2.4 (ErtugrulSoeylemez)
23:07:20 <copumpkin> yeah, in a binding to a C API that uses them
23:07:31 <ddarius> copumpkin: How many flags are there?
23:08:11 <copumpkin> I have two mutually exlusive required ones, two mutually exclusive optional ones, and then three miscallaneous ones that can be thrown in too
23:10:02 <ddarius> copumpkin: Well, your options are 1) to make a data type that meaningfully represents this and disallows e.g. mutually exclusive choices, 2) do exactly what C does, 3) have the fields be represented by lists of values from an enumeration that represents each bitfield.
23:10:31 <copumpkin> yeah
23:10:31 <copumpkin> hmm
23:10:55 <Jafet> Make your users type cocks
23:15:46 <copumpkin> :O
23:19:51 * cmccann develops a bad habit of giving non-exported record field accessors incredibly silly names
23:21:03 <cmccann> "data Natural = N { denature :: Integer }"
23:21:20 <ddarius> unNatural wasn't okay?
23:21:28 <kmc> haha
23:22:19 <wavewave> denature sounds good.
23:22:20 <cmccann> ddarius, I considered that as being slightly less ridiculous, but I already had a pun on "unnatural" in the haddock comments so I figured I shouldn't reuse material
23:22:43 <ddarius> It's a "standard" convention.
23:22:52 <cmccann> elsewhere I have a continued fraction type with an accessor named "discontinue"
23:23:24 <kmc> (also, not "newtype"?)
23:23:27 <ddarius> Also, do you need that bottom.
23:23:35 <cmccann> oh, sorry
23:23:42 <cmccann> yes, it's a newtype
23:23:54 <cmccann> that wasn't a copy and paste
23:24:19 <shachaf> Is there a standard lifted data Unit x = Unit x in the standard library anywhere?
23:24:21 <wavewave> I don't like much unXXX thing.
23:24:30 <cmccann> shachaf, Identity?
23:24:36 <shachaf> That's a newtype.
23:24:50 <ddarius> shachaf: I don't think so.  I'd call it Box or Lazy.
23:24:57 <cmccann> oh, heh, didn't notice you said lifted
23:25:18 <kmc> ezyang calls it Box
23:25:24 <ddarius> type Unit x = (forall a.a, x)
23:25:29 <roeluu> hello
23:25:31 <kmc> and had a beautiful blog post about functions of type Box a -> Box a
23:25:35 <kmc> hi roeluu
23:25:39 <shachaf> Maybe we need some sort of first-class pattern match instead of the unX thing.
23:26:12 <roeluu> are here peoples who can speak german? :)
23:26:18 <shachaf> roeluu: #haskell.de
23:26:21 <Jafet> Niemand
23:26:23 <shachaf> (Also, yes.)
23:26:27 <roeluu> :D
23:26:51 <shachaf> {N _} :: Natural -> Integer, or something of the sort.
23:27:11 <wavewave> how about "original" for all newtype.
23:27:13 <shachaf> Also there should be first-class pattern syntax that generates functions like isJust.
23:27:33 <Jafet> itym ViewPatterns
23:27:38 <kmc> @vixen sprechen Sie Deutsch?
23:27:38 <lambdabot> first you tell me.
23:27:42 * shachaf wonders why he's calling it first-class.
23:27:42 <cmccann> incidentally, anyone think it's reasonable to have types Natural and Nat with the same relationship as Integer and Int?
23:27:52 <roeluu> @kmc ich spreche deutsch ;)
23:27:52 <lambdabot> Maybe you meant: ghc rc src
23:27:58 <Jafet> Nat is Word, there is no Natural
23:27:58 <cmccann> and by same relationship I mean probably newtypes of the them respectively
23:27:58 <shachaf> cmccann: No, because Int is evil.
23:28:06 <wavewave> or un
23:28:16 <ddarius> roeluu: You aren't lambdabot.
23:28:17 <wavewave> un (N xxx) = xxx
23:28:19 <kmc> ich spreche kein Deutsch :(
23:28:30 <ddarius> kmc: "Ich kann Deutsch nicht."
23:28:37 <kmc> "i cannot German"?
23:28:40 <cmccann> Jafet, there's a Natural if you make the type abstract and preserve your invariants
23:28:55 <Jafet> @remember cmccann newtype Natural = N { denature :: Integer }
23:28:55 <lambdabot> Nice!
23:29:01 <roeluu> bye
23:29:07 <cmccann> shachaf, evil in what sense
23:29:12 <roeluu> I wish you a nice day ;)
23:29:24 <wavewave> bye
23:29:32 <shachaf> cmccann: Evil that it's the default, and that it's shorter.
23:29:34 <cmccann> though yeah I guess using a Word type makes more sense
23:29:38 <Jafet> > iterate (*2) 0 :: [Int]
23:29:39 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
23:29:43 <Jafet> > iterate (*2) 1 :: [Int]
23:29:43 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
23:30:04 * wavewave is still perflexed when gunfold is used.
23:30:48 <copumpkin> Since the value of the symbol could actually be NULL (so that a NULL return from dlsym() need not indicate an error), the correct way to test for an error is to call dlerror() to clear any old error conditions, then call dlsym(), and then call dlerror() again, saving its return value into a variable, and check whether this saved value is not NULL.
23:30:59 <cmccann> shachaf, for context I'm writing a partial Prelude replacement mostly for my own use but trying to keep things somewhat sensible
23:31:29 <shachaf> cmccann: Oh. Why not make Integer the default, and call it Int?
23:31:41 <Jafet> copumpkin: at least they didn't make it return (void*)-1, like with mmap
23:31:46 <copumpkin> lol
23:31:51 <kmc> (void*) -ENOENT
23:32:06 <kmc> Linux uses lots of those...
23:32:13 <edwardk> finally figured out the right way to add layout to trifecta. took enough iterations
23:32:26 <Jafet> Actually, mmap has (PAGE_SIZE-1) possible error codes to return, starting with -1
23:32:27 <cmccann> shachaf, because the three number types it exports by default currently are Natural, Integer, and Rational, aliased as ℕ, ℤ, and ℚ
23:32:50 <shachaf> edwardk: Is it a multifecta yet?
23:32:51 <kmc> > generalCategory 'ℚ'
23:32:51 <lambdabot>   UppercaseLetter
23:33:02 <edwardk> =)
23:33:15 <cmccann> stuff like Int I'm shoving into a submodule, along with nonsense like Float that aren't really numbers at all
23:33:17 <wavewave> I like the unicode!!
23:33:31 <kmc> it's all unicode
23:33:48 <ddarius> copumpkin: Mutable APIs with global variables so we don't have to allocate memory.
23:33:55 <copumpkin> hell yeah!
23:34:02 <copumpkin> gotta love wrapping shit in a lock
23:34:15 <wavewave> trifecta
23:34:30 <wavewave> wow it's already v0.41
23:34:31 <edwardk> ?
23:34:35 <edwardk> yeah
23:34:37 <copumpkin> is there an easy abstract way to say "this must not happen more than once at a time?
23:34:44 <edwardk> release early and often ;)
23:35:03 <edwardk> the PVP keeps me bumping that major number like crazy
23:35:19 <wavewave> that's true.
23:35:47 <wavewave> whenever you break some old dependency, you need to bump up +0.1
23:35:47 <ddarius> The PVP shouldn't be -too- relevant (as in you should be bumping it anyway.)
23:36:06 * cmccann currently forecasts roughly two years and three months until the average major version number of edwardk's packages is ω
23:36:08 <ivanm> edwardk: isn't it more like "release every time you add/change a line of code" ?
23:36:11 <edwardk> well, it just effectively picks which digit i update
23:36:16 <edwardk> ivanm: =P
23:36:19 <wavewave> @karma edwardk
23:36:19 <lambdabot> edwardk has a karma of 11
23:36:25 <shachaf> preflex: karma edwardk
23:36:26 <preflex>  edwardk: 21
23:36:41 <wavewave> what's preflex?
23:36:42 <ddarius> ivanm: It would be a bit ridiculous for him to release earlier and oftener than that, don't you think?
23:36:44 <edwardk> lambdabot is a bit forgetful
23:36:45 <kmc> make a git commit hook which uploads to hackage
23:36:46 <wavewave> preflex: karma
23:36:46 <preflex>  wavewave: 1
23:36:50 <kmc> or an editor hook
23:37:00 <cmccann> kmc, keypress event
23:37:00 <wavewave> oh.. I have one karma point.
23:37:02 <shachaf> superflex: karma edwardk
23:37:07 <lambdabot> edwardk's karma = 2^28-1
23:37:21 <wavewave> superflex: karma
23:37:42 <lambdabot> wavewave's karma = 1.4
23:37:43 <wavewave> superflex: karma wavewave
23:37:50 <edwardk> the main issue is bumping the version numbers correctly. its a bit of a pain in the ass. so i tend to wait a LITTLE while between uploads ;)
23:38:02 <wavewave> hmmm .
23:38:15 <shachaf> edwardk: Version numbers are old-hat.
23:38:36 <edwardk> well, the problem is bumping one tends to push up ~10 packages downstream =P
23:38:36 <shachaf> Just have one repository, and if things break it's not your problem.
23:38:38 <wavewave> as long as you are consistent in what you are doing, I think it's okay.
23:39:20 <wavewave> I would rather bump versions more often than wait since it feels good
23:39:25 <edwardk> cabal has gotten a bit nicer about this sort of thing though over the last year or so though, now i don't have to bump the indirect dependencies as often at least
23:39:54 * cmccann suggests that version numbers be expressed as functions of the versions of dependencies
23:40:12 <ddarius> edwardk: I suggest picking physical constants for each version number and adding a digit with each release.  That should slow you down before too long.
23:40:28 <edwardk> heh
23:40:45 <edwardk> i'm asymptotically approaching a number. that number is just very large
23:40:51 <wavewave> like tex? 3.14159.
23:41:36 <wavewave> do not use physical constant since it depends on the unit
23:41:37 <ddarius> wavewave: No, because the digits of pi are unlimited and pretty readily computable.  If nothing else, they do not require new atom smashers to be built so that they can be extended another digit.
23:41:43 <edwardk> not sure if cabal will flip out if one of the digits in the x.y.z exceeds the range of an Int
23:41:59 <cmccann> edwardk, you'll probably find out soon enough
23:42:03 <edwardk> hahaha
23:42:27 <ddarius> trifecta-0.-12045935
23:43:36 <ivanm> edwardk: maybe you need to make a proposal to libraries@ that Version switches to [Integer] rather than [Int] then...
23:43:42 <wavewave> or suddenly it changes it's radix to 16.
23:43:42 <edwardk> =)
23:44:22 <cmccann> trifecta-0.(2↑↑↑5).3
23:44:23 <shachaf> Version = [Word8]
23:44:38 <shachaf> Should be enough for anybody.
23:45:11 <edwardk> the problem is you then get limited to 65536 different major versions
23:45:36 <ddarius> Which should be enough for anybody.
23:45:59 <wavewave> it's not enough for haskell 3010
23:58:47 <copumpkin> I have a fuckingGlobalLock :: MVar ()
23:59:00 <copumpkin> is there a better way to do that?
23:59:16 <cmccann> perhaps adding more profanity
23:59:20 <cmccann> might help a bit
23:59:22 <copumpkin> good idea
23:59:28 <kmc> yeah, i think "motherfuckingGlobalLock" is a better name
23:59:38 <cmccann> it's self-documenting that way
