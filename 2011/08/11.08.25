00:00:03 <Saizan> _Ray_: such that X = f X
00:00:27 <Saizan> modulo the data constructor
00:00:41 <_Ray_> yeah, Fix was the data constructor
00:00:53 <cmccann> Axman6, also a maybe in that I have a couple ideas about how to encode in a reasonably usable manner some sort of pseudo-lambda hackery using something akin to de bruijn indices
00:01:00 <cmccann> but I'm not certain it will work
00:01:03 <shachaf> _Ray_: Well, you need the data constructor on every level.
00:01:13 <_Ray_> Huh?
00:01:15 <cmccann> and even less certain it'd be worth it
00:01:15 <shachaf> Er, never mind.
00:01:30 * shachaf recommends equirecursive types.
00:01:51 <edwardk> copumpkin: o.O the order of multiplication mattered?
00:02:08 <_Ray_> fucking hell, math and cs need to stop having awesome interesting things. it's ruining my life.
00:02:38 <cmccann> _Ray_, the benefit of Haskell is that you can at least combine them in one place most of the time.
00:02:47 <solrize> @remember <_Ray_> fucking hell, math and cs need to stop having awesome interesting things. it's ruining my life.
00:02:48 <_Ray_> hence my joining, yes
00:02:48 <lambdabot> Done.
00:02:59 <Rotsor> Can one take a Haskell snippet and turn it into TH code generating it easily?
00:03:08 <shachaf> solrize: Please don't use <> around a nick for @remember. :-(
00:03:09 <Rotsor> _Ray_, same problem with me
00:03:24 <solrize> @remember _Ray_ fucking hell, math and cs need to stop having awesome interesting things. it's ruining my life.
00:03:25 <lambdabot> Good to know.
00:03:38 <shachaf> @forget <_Ray_> fucking hell, math and cs need to stop having awesome interesting things. it's ruining my life.
00:03:39 <lambdabot> Done.
00:03:47 <cmccann> Rotsor, can't you just quote the expression you want to get the AST for it?
00:04:25 <Rotsor> cmccann, Well, I'd like to generate similar expression, not exactly that.
00:04:40 <cmccann> Rotsor, you can manipulate the AST you get from the quote, of course
00:04:59 <Rotsor> cmccann, ah, probably including printing it... :)
00:05:01 <Gracenotes> or, I assume, call 'show'? :.
00:05:21 <Gracenotes> assuming show doesn't try to do a pretty-printing thingy
00:05:27 <_Ray_> what's this notion that two state machines are not isomorphic, but all walks through them are? like, consider the state machine x_1-(a)->x_2-(a)->x_3-(a)->x_4-(a)->..., and the state machine x_1-(a)->x_1. what is this "they might as well be the same thing" called?
00:06:07 <Gracenotes> recognizing the same language?
00:06:44 <_Ray_> could be
00:07:12 <Gracenotes> DFA equivalence
00:07:22 <opqdonut> _Ray_: DFAs have normal forms
00:07:42 <Gracenotes> you can put them through minimalization, which are guaranteed optimal
00:07:43 <opqdonut> look up minimization algorithms
00:07:43 <_Ray_> the first one isn't F tho
00:07:45 * hackagebot dimensional 0.10.1.1 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.10.1.1 (BjornBuckwalter)
00:07:53 <opqdonut> (or is it minimalization?)
00:08:15 <Gracenotes> nope, you were right
00:08:31 <Gracenotes> but both are words :)
00:08:54 <olsner> since the minimized result is guaranteed minimal, "minimalization" should work too :)
00:10:06 <Gracenotes> although, minimal and minumum aren't quite the same thing. thanks, order theory!
00:10:36 <olsner> darn
00:11:04 <Axman6> is there's anything interesting infinite state machines?
00:11:25 <Axman6> i mean, they can obviously be used for recognising any language... but, is that useful?
00:12:18 <Gracenotes> hard to think of how it could work without just being simulated by something with finite states
00:12:25 <edwardk> Axman6: sure, we use applicatives to represent them all the time
00:13:41 <Axman6> do we?
00:17:31 <cwraith> hey, monochrom, what's with your last -cafe post? :)
00:18:18 <jophish> Hi all!
00:18:41 <shachaf> @ahoy jophish
00:18:42 <lambdabot> "jophish"
00:18:54 <Saizan> Axman6: consider the automaton corresponding to as = pure () <|> (char 'a' *> as)
00:19:15 <Saizan> (i.e. many (char 'a'))
00:19:42 <Saizan> (except for the list..)
00:19:46 <Axman6> ah right
00:20:11 <Axman6> i never understood why Alternative is part of Control.Applicative
00:20:14 <Gracenotes> Saizan: where are the infinite states?
00:20:26 <Gracenotes> :/ <- confused.
00:20:34 <Axman6> hmm, indeed
00:21:00 <olsner> Axman6: it's like MonadPlus being in Control.Monad
00:21:14 <Saizan> true, brain fart
00:21:30 <Saizan> that's just cyclic :)
00:21:35 <Axman6> edwardk: how do we represent infinite state automata with applicative?
00:21:37 <companion_cube> it's regular :)
00:21:41 <Gracenotes> well. hm. actually, you could consider a push-down automaton an infinite state machine. or, at least, according to the input given.
00:21:59 <olsner> which is not an explanation :) but it's still more convenient than having to import another module to get alternative for your applicatives
00:22:03 <Gracenotes> if you consider state as not just the automaton state, but also the contents of the stack.
00:22:19 <Axman6> Gracenotes: sure, the state is the tape and the current state
00:22:20 <edwardk> Axman6: as a subset of the ways we represent infinite context-free-grammars with applicative
00:22:52 <Gracenotes> yeah. ... it's a bit more obvious when I say it like that :P considering I wrote a history of math paper about the history of automata
00:23:03 <Gracenotes> which is fairly interesting, as they become less and less powerful over time
00:23:18 <Gracenotes> starting with Turing machines
00:23:23 <Axman6> heh
00:23:37 <Axman6> i didn't know they'd been studied in that order
00:23:52 <edwardk> @tell copumpkin thanks. now we can actually finish precision =)
00:23:52 <lambdabot> Consider it noted.
00:24:12 <Gracenotes> not intentionally >_> it took until 1959 for the current DFA definition to be solidified
00:24:17 <Rotsor> What about the obvious as = char '(' *> as *> char ')' ?
00:24:42 <edwardk> rotsors: i hope you meant <* for the latter
00:24:56 <Rotsor> whatever, the value does not matter
00:26:29 <Saizan> a good one: l = msum $ map (\n -> replicateA n (char 'a') >> replicateA n (char 'b') >> replicate A n (char 'c')) [0..]
00:27:37 <Rotsor> It doesn't even accept any finite string, right?
00:27:41 <danr> Is that a parser for the a^n b^n c^n language?
00:27:48 <Saizan> danr: yep
00:27:51 <Rotsor> Ah, msum
00:28:04 <danr> Saizan: ah, nice :)
00:28:26 <Gracenotes> Rotsor: depending on definition of "accept"? ... confused >_>
00:28:48 <Rotsor> Gracenotes, I thought it was sequence instead of msum
00:29:10 <Gracenotes> oh, I mean the S = (S) one
00:29:40 <Rotsor> Gracenotes, oh, I forgot the empty case then!
00:29:49 <Gracenotes> which, I guess formally, you'd say recognizes an empty language
00:29:52 <Gracenotes> oh :P
00:37:45 * hackagebot amqp 0.3.1 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.3.1 (HolgerReinhardt)
00:59:16 <jim``> hi
01:01:36 <jim``> ghc-7.2.1-src.tar.bz won't build my archlinux box using ghc-7.0.3.
01:01:44 <aki> morning
01:02:06 <jophish> hah, haskell has a lcm function
01:02:18 <jophish> minutes of my life wasted
01:02:19 <jophish> :D
01:02:25 <jim``> Missing System.Process in a distribution utils file. Can anyone suggest a fix?
01:08:00 <silver> @hoogle lcm
01:08:00 <lambdabot> Prelude lcm :: Integral a => a -> a -> a
01:08:10 <silver> @sec lcm
01:08:11 <lambdabot> lcm _ 0     =  0
01:08:11 <lambdabot> lcm 0 _     =  0
01:08:11 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
01:08:32 <silver> oh
01:10:10 <hpaste_> erus` pasted “hmm” at http://hpaste.org/50649
01:10:34 <erus`> why is it letting me mix and match types there?
01:10:57 <shachaf> erus`: Because that's what "type" is.
01:11:46 <erus`> do i have to use data?
01:12:21 <koeien> erus`: type defines a type synonym
01:12:47 <koeien> erus`: if you want to have an isomorphic type with a different name, I'd suggest "newtype"
01:12:54 <koeien> newtype Checked = Checked String
01:13:21 <koeien> (data is also fine. There is a subtle difference which is not so important at this point.)
01:13:47 <shachaf> newtype would be better than data.
01:14:04 <koeien> for this particular case, yes
01:16:38 <koeien> jim``: did you install the haskell platform?
01:18:50 <Rotsor> I would like to make a modular parser, proceeding in separate stages -- like, first strip the comments, second tokenize everything, then parse, then something else. I'd also like to be able to trace the errors on any stage to the source code location. On the other hand, adding the source code location info to every intermediate data structure seems non-practical. Any suggestions?
01:22:02 <Saizan> trifecta seems perfect for that
01:22:09 <Saizan> it's fairly new though
01:22:24 <edwardk> rotsor: also, the usual parsec idiom is to have the whiteSpace parser strip comments as you go
01:23:06 <edwardk> so you just use 'lexeme' to recognize the next token, and it munches whitespace including comments after the token
01:24:40 <Rotsor> Actually what I need is more like a compiler than a parser
01:25:09 <Rotsor> Because I'll need something like simple typechecking of expressions
01:25:33 <edwardk> well, parsing is the first step in that
01:25:53 <DrTeggy> Above, you were talking about modularity, Rotsor.  Don't lump everything together.  Parsing goes first.
01:27:01 <Rotsor> Indeed, and the tricky thing is how to preserve the file location info so that the typechecker doesn't know that it exists, but still type errors are reported with source code location.
01:27:33 <Rotsor> trifecta, you say? I'll have a look at it, thanks.
01:27:38 <edwardk> rotsor: what i do in trifecta is track it during parsing, and any place im going to need it potentially later i annotate the intermediat rep
01:27:42 <edwardk> er intermediate rep
01:27:53 <edwardk> then when i'm done type checking i throw it out
01:28:11 <edwardk> well, in the parsers i build with trifecta i should say
01:28:47 <Botje> are there any good paper on annotating type errors with source locations, btw?
01:29:01 <Botje> I can imagine the "GHC has better errors now" paper is one
01:29:02 <edwardk> not really, most of us have just kind of figured it out as we went
01:29:36 <Botje> boo :(
01:29:45 <edwardk> i'm currently trying to bolt nominolo's type error slices on top of trifecta errors for a toy parser
01:30:03 <edwardk> that way i can highlight the portions of the term on a line that actually contributed to the type error
01:30:56 <edwardk> not sure i can package that up generically though
01:32:59 <erus`> someone should write a tiny haskell compiler. as small as possible
01:33:05 <erus`> like tcc
01:33:11 <shachaf> erus`: You should!
01:33:19 <Botje> erus`: I already have an ML compiler.
01:33:22 <edwardk> erus`: sounds like fun. let us know how it goes
01:33:25 <Botje> it's 3kLOC
01:33:44 <erus`> Botje: do you output x86?
01:33:47 <Botje> C.
01:33:58 <Botje> couldn't be bothered with all this icky assembly stuff
01:35:11 <erus`> Botje: did you handle recursion ?
01:35:42 <Botje> i think so
01:35:45 <Botje> it was two years ago
01:36:30 <Botje> yep, it could compile factoril.
01:36:31 <kmc> erus`, you should!
01:36:32 <Botje> *factorial
01:36:38 <kmc> erus`, read "Typing Haskell in Haskell", it's a good paper
01:37:04 <kmc> i started working on a tiny Haskell compiler (named THC)
01:37:13 <kmc> but now i think the GHC decompiler is a more fun project
01:37:32 <shachaf> kmc: Does it by any chance involve a bytecode interpreter written in portable C? :-)
01:39:40 <erus`> isnt a haskell compiler in haskell cheating?
01:39:56 <koeien> erus`: gcc is written in C. why is it cheating?
01:40:21 <shachaf> koeien: Perhaps erus` means in the general sense that Haskell makes writing a compiler too easy. :-)
01:40:22 <erus`> well C is fairly low level
01:40:24 <kmc> erus`, GHC is written (mostly) in Haskell
01:40:58 <kmc> it's written in exciting pre-modern Haskell too :)
01:41:07 <kmc> GHC and Haskell kind of co-evolved
01:41:15 <shachaf> kmc: Not completely!
01:41:24 <shachaf> GHC uses at least som non-Haskell-98 extensions.
01:41:30 <koeien> i thought GHC required GHC
01:41:32 <kmc> *nod*
01:41:47 <kmc> but, for example, it mostly avoids hierarchical module names
01:42:15 <flux> erus`, I would say it's rather a good thing that programming languages are written in themselves. it proves that they are able to solve non-trivial problems.
01:42:33 <kmc> and Haskell is just a good language for writing compilers
01:42:38 <kmc> no matter what language you're compiling
01:42:54 <kmc> if I had to write a C compiler it'd certainly be in Haskell and not C
01:43:01 <kmc> (unless there were some other pertinent requirement)
01:43:18 <mux> s/a C compiler/anything/
01:43:47 <shachaf> There are plenty of things that C is a better language for than Haskell.
01:44:10 <flux> shachaf, but if the problem lends itself to C, perhaps it's a pertinent requirement :)
01:44:11 <Feuerbach> "The last good thing written in C was Franz Schubert's Symphony number 9"
01:44:22 <_Ray_> boom, roasted.
01:44:27 <mux> Feuerbach: I'd have said unix ;-)
01:44:50 <kmc> unix is good now?
01:45:15 <mux> that is all a matter of point of view
01:45:17 <shachaf> By being bad. Worse is better.
01:46:26 <edwardk> > signum (0/0)
01:46:27 <lambdabot>   -1.0
01:47:02 * shachaf wonders what the reasoning behind that is.
01:47:11 <mux> > signum Infinity
01:47:12 <lambdabot>   Not in scope: data constructor `Infinity'
01:47:15 <Rotsor> > signum (0/0 :: Rational)
01:47:16 <lambdabot>   *Exception: Ratio.%: zero denominator
01:51:54 <kmc> worser is betterer
01:53:30 <ion> Yay, figured out callCC. It’s rather simple, just had to peel out the Cont newtype wrapper manually to see it clearly.
01:54:12 <shachaf> ion: Have you figured out how to derive the law of excluded middle from it yet? :-)
01:54:45 <edwardk> ion: now, the next step, callCC has too simple a type ;)
01:54:56 <edwardk> ion: or alternately too complex a type
01:55:13 <erus`> :t (->)
01:55:19 <kmc> i love that proof
01:55:19 <lambdabot> parse error on input `->'
01:55:22 <kmc> i think i might blog about it
01:56:47 <erus`> representing the haskell type system is no easy feat :|
01:56:58 <koeien> :k (->)
01:56:59 <lambdabot> ?? -> ? -> *
01:57:46 * hackagebot AC-Random 0.1 - A pure Haskell PRNG.  http://hackage.haskell.org/package/AC-Random-0.1 (AndrewCoppin)
01:59:20 <ion> shachaf: Might be a bit too advanced topic for my present knowledge. :-)
01:59:40 <shachaf> ion: No, it's simple.
01:59:51 <shachaf> Well, pretty simple. And neat.
01:59:58 <shachaf> Read kmc's weblog post.
02:00:03 <ion> I haven’t studied logical proofs.
02:00:17 <shachaf> ion: You've studied type systems and writing programs, right?
02:00:20 <shachaf> Same thing. :-)
02:00:56 * ion opens WayForwardMachine and reads kmc’s blog post.
02:01:24 <ion> edwardk: Please elaborate.
02:01:28 <shachaf> I recommend that you take a continuation now, and then, once kmc publishes his post, resume it.
02:01:38 <shachaf> edwardk: Yes, what do you mean?
02:01:57 <edwardk> ion: the type of callCC is rank1, but the real type of callCC is rank3
02:02:33 <shachaf> You mean ((forall b. a -> b) -> a) -> a?
02:02:34 <edwardk> ((a -> m b) -> m a) -> m a   should really be ((forall b. a -> m b) -> m a) -> m a
02:02:38 <edwardk> yeah
02:02:40 <jim``> #koeien haskell platform ghc-7.0.3
02:02:43 <shachaf> Makes sense.
02:02:56 <edwardk> that way you can use the continuation in multiple differently typed contexts
02:02:57 <shachaf> Alternatively, ((a -> Void) -> a) -> a?
02:03:00 <edwardk> yes
02:03:11 <edwardk> and you can fix this two ways
02:03:17 <edwardk> one by making the rank 3  type
02:03:20 <ion> Ah
02:03:23 <edwardk> the other is to make a new class for MonadCont
02:03:49 <edwardk> class Monad m => MonadLabel l m | m -> l where label :: (l a -> m a) -> m a; break :: l a -> a -> m a
02:04:17 <edwardk> you can do that by seeing that (forall b. (b -> r) -> r) = r
02:04:34 <jim``> koeien haskell platform ghc-7.0.3 installed
02:04:38 <edwardk> since the quantifier ruled out calling the function
02:04:49 <koeien> jim``: which platform?
02:04:54 <Saizan> not "break :: l a -> a -> m b" ?
02:04:59 <koeien> jim``: osx / linux / windows?
02:05:07 <edwardk> Saizan: you got it right, i wrote it wrong in haste
02:05:35 <jim``> koeien sorry archlinux
02:05:52 <edwardk> that gives you the power of the rank3 type, but using only rank1 machinery
02:06:17 <koeien> jim``: any particular reason that you're using the source version? it's generally easier to install the binary version
02:06:44 <shachaf> Wouldn't using Void be simpler?
02:07:37 <koeien> jim``: can you paste the error somewhere (hpaste.org) ?
02:07:44 <edwardk> no, because then they'd have to explicitly convert out of it
02:07:46 <jim``> Apologies for bad messages haven't used irc for years so reading destructions ATM.
02:08:05 <edwardk> and it adds a package dependency, etc.
02:08:20 <edwardk> in general i prefer to just use quantified variables where possible
02:08:45 <edwardk> if they choose to instantiate that to void, then so be it ;)
02:09:14 <shachaf> That type class seems much more complicated than a rank-3 type.
02:09:55 <edwardk> shachaf: its merely deferring the decision of which type to instantiate to call time
02:10:02 <edwardk> you can make the rank 3 type on top of that
02:10:09 <edwardk> by just pre-applying break
02:10:24 <edwardk> but the rank3 type goes beyond the scope of what the mtl allows
02:10:29 <edwardk> whereas the label class does not
02:11:44 <jim``> \MSG koeien can't even read destruction properly :)
02:15:54 <jophish_> I'm liking haskell very much
02:16:21 <edwardk> copumpkin: ah i see, REP_MPFR__mpfr_sign = b32 whereas prec is b64
02:17:57 <edwardk> 2 hours later, i find the bug. a missing {
02:18:11 <jophish_> Just out of interest, is there a better way to do something like this: let sumto i f | i == 0 = f i | otherwise = f i + sumto ( i - 1 ) f
02:18:17 <shachaf> edwardk: Should've used a trifecta-based parser!
02:18:31 <edwardk> shachaf: its c-- =/
02:19:31 <kmc> jophish_, let sumto 0 f = f i; sumto i f = ...
02:19:50 <kmc> jophish_, but i think it simplifies further
02:20:09 <jophish_> ah, that is better
02:20:10 <kmc> sumto n f = sum (map f [0..n])
02:20:11 <shachaf> sumto f n = sum (map f [0..n]) ?
02:20:25 <jophish_> shachaf, bingo
02:20:35 <jophish_> Thanks!
02:20:44 <shachaf> kmc, bingo
02:20:59 <kmc> bazinga
02:21:13 <jophish_> hah, missed that line completely! bingo to you too kmc
02:21:21 <kmc> :D
02:21:51 <jophish_> sumto n f = sum (map f [0..n-1])
02:22:03 <shachaf> Of course, if you're using a Num where addition isn't commutative, you might want [n,n-1..0], or something of the sort. :-)
02:22:03 <jophish_> although that's not what my example did :/
02:22:10 <kmc> @pl sumto n f = sum (map f [0..n-1])
02:22:10 <lambdabot> sumto = (sum .) . flip map . enumFromTo 0 . subtract 1
02:25:32 <edwardk> yay. i now have mpfr working through Floating. now I just need to get all the RealFloat nonsense working again
02:25:32 <kmc> nice!
02:25:49 <edwardk> Eq, Ord, properly handling NaNs, etc.
02:26:14 <kmc> who really needs proper NaN handling
02:26:25 <kmc> ;)
02:26:26 <edwardk> no, i mean i have that in ;)
02:26:32 <kmc> ah, cool
02:26:35 <edwardk> that was the hard part
02:26:43 <shachaf> Mmm, ИаИ.
02:28:27 <kmc> иа иа ктулху фхтагн
02:31:13 <ion> It seems i have accumulated just enough knowledge of cyrillic characters by accident to read that.
02:31:46 <ion> Extrapolated the х, though.
02:39:22 <erus`> where is roconner?
02:39:32 <edwardk> sleeping?
02:39:44 <kmc> yeah, it's worth learning to read cyrillic letters
02:39:51 <kmc> russian and english actually have a lot of cognates
02:42:32 <erus`> is the quickest way to test if a point is inside a mesh: cast a ray from that point in any direction and check that the ray/tri intersections are odd and more than 0 ?
02:46:19 <wires> erus`: if you need to check many points, and your mesh is big and static, then probably a space partitioning datastructure (eg. octree) can give big speedups
02:46:27 <wires> i think...
02:49:56 <wires> (you basically fill your mesh with a tree of smaller and smaller cubes, for which you can quickly check if the point is contained within.)
02:50:26 <Jafet> kd-tree is often better
03:02:49 * hackagebot async 1.3 - Asynchronous Computations  http://hackage.haskell.org/package/async-1.3 (PeterSimons)
03:12:17 <erus`> imagine immutable C...
03:13:19 <true_droid> not that hard
03:13:24 <true_droid> it's C in SSA
03:13:29 <erus`> haskell has a C parser right?
03:13:37 <Jafet> C is pretty immutable; it hasn't changed for 12 years
03:14:03 <edwardk> erus`: there is a Language.C parser floating around, not sure how well supported it is
03:15:09 <erus`> is there anything i couldnt use scanf
03:17:26 <liyang> Fancy a hackathon, anyone? http://www.reddit.com/r/haskell/comments/jtwe6/hakkutaikai_haskell_hackathon_in_tokyo_25th/
03:18:29 <erus`> are there many haskellers in tokyo?
03:18:54 <kmc> there's a fair number in japan, anyway
03:19:17 <kmc> http://www.starling-software.com/en/tsac.html
03:19:24 <kmc> hmm, this looks semi-defunct
03:19:25 <liyang> erus`: most of the bigwigs in the Haskell world is going to be in Tokyo around then.
03:19:39 <liyang> Yes. Starling doesn't exist anymore.
03:20:21 <erus`> how do people have the money to jet set all over the world?
03:21:05 <liyang> Research grants mostly, I'd say.
03:21:10 <Jafet> Some companies have the money to jet set other people all over the world
03:21:25 <liyang> It's the Sunday after ICFP.
03:21:41 <Jafet> Like Axman
03:22:01 <liyang> Jafet: who's been bankrolling him?
03:22:25 <Jafet> I thought he was with Tsuru
03:22:43 <kmc> erus`, good software engineering jobs pay pretty well
03:23:05 <liyang> Jafet: he was an intern, now back to uni.
03:23:06 <erus`> do you think its a social or biological reason that there are so few female programmers?
03:23:16 <kmc> oh this is gonna be fun.
03:23:21 <Jafet> Yeah, that works too
03:23:26 <liyang> oh dear.
03:23:42 <liyang> erus`: historically most programmers started off being female.
03:23:54 <kmc> propose to move this out of #haskell?
03:23:57 <Jafet> Heh
03:23:57 * liyang will let that ambiguity lie.
03:24:04 <kmc> haha
03:24:11 <sp3ctum_> haha this is interesting
03:24:24 <Jafet> @vixen how long have you been female?
03:24:25 <lambdabot> very long
03:25:45 <Saizan> most computers were female, even
03:26:42 <erus`> so where did they all go?
03:27:07 <Jafet> With the cowboys.
03:27:38 <kmc> erus`, http://blog.fogcreek.com/girls-go-geek-again/
03:30:36 <erus`> so why is it not 50/50
03:30:57 <kmc> this is off topic
03:31:08 <_Ray_> females are never off topic
03:31:27 <kmc> maybe it's shit like that
03:31:38 <Igloo> Take this to -blah please
03:31:45 <erus`> kmc thinks social
03:31:53 <erus`> any for biological?
03:32:07 --- mode: ChanServ set +o Igloo
03:32:15 <edwardk> -> blah
03:34:30 <edwardk> @tell copumpkin while that fixed many of the immediate crashes, if you call performGC after allocating with MPFR it dies then
03:34:30 <lambdabot> Consider it noted.
03:37:52 * hackagebot async 1.4 - Asynchronous Computations  http://hackage.haskell.org/package/async-1.4 (PeterSimons)
03:40:21 <edwardk> preflex: xseen nominolo
04:21:21 <ktosiek> Is there any tool that would tell me which imports are not needed in a given module?
04:23:15 <ktosiek> or even list, for every import in a module, what exactly is it needed for
04:24:17 <zomg> Delete import, compile. Read error message, put import back and only import what the error message complained about
04:24:20 <zomg> Repeat until no error message
04:24:21 <zomg> :D
04:24:45 <ktosiek> well, that's a last resort :-P
04:26:04 <roconnor_> I think there is some GHC flag that warns about unused inports
04:26:06 <roconnor_> *imports
04:31:47 <koeien>  -fwarn-unused-imports
04:32:09 <hpc> isn't there a -Wall flag?
04:32:15 <koeien> sure.
04:32:28 <ktosiek> hpc: that's too verbose
04:32:54 <ktosiek> it's -fwarn-unused-imports that I was looking for :-)
04:33:06 <ktosiek> koeien: thanks :-D
04:37:19 <kmc> ktosiek, your code fails a lot of other -Wall warnings?
04:37:22 <kmc> you might want to fix those
04:37:42 <kmc> in my experience it's not that hard to make code -Wall-clean, and well worth it
04:37:52 <kmc> sometimes i have to turn off one or two individual warnings for a particular file
04:38:31 <kmc> ktosiek, see also ghc -ddump-minimal-imports
04:38:46 * kmc doesn't see why any compiler ships with -Wall -Werror not the default
04:40:32 <kmc> @quote quine
04:40:32 <lambdabot> quine says: A quine is a computer program which produces a copy of its own source code as its only output. The standard terms for these programs in the computability theory and computer science
04:40:32 <lambdabot> scalabot: println("@quote quine")
04:41:53 <ktosiek> kmc: I'm fixing it, ghc is almost happy now
04:43:54 <ktosiek> well, default -Werror would be good for people who couldn't change compiler flags if their life depended on it
04:46:56 <kmc> cool
04:51:03 <jophish_> Alrighty, is there a handy function to take a section of a list
04:51:12 <jophish_> like take, but for any position in the list
04:51:26 <Eduard_Munteanu> kmc: then you'd complain about people going out of their way to *silence* static analysis tools :P
04:51:56 <kmc> jophish_, take (m-n) . drop n -- ?
04:51:57 <ehamberg> jophish_: drop + take
04:52:11 <kmc> lists aren't meant to be used as random-access data structures, though
04:52:37 <jophish_> kmc, ehamberg thanks!
04:52:41 <kmc> Data.Sequence is probably a better choice
04:52:54 <kmc> depending on circumstances and the actual sizes involved
04:53:05 <Eduard_Munteanu> Or arrays.
04:53:19 <jophish_> kmc, Eduard_Munteanu ok, I'll be sure to look into those
04:53:33 <jophish_> kmc, this is 1000 chars long at the moment
04:53:39 <kmc> Eduard_Munteanu, i've found the Array API pretty unpleasant to use, but that's personal taste i suppose
04:53:49 <kmc> jophish_, oh, it's text? look at the 'text' package also
04:54:04 <kmc> unfortunately that doesn't have random access either
04:54:32 <jophish_> kmc, well, it's a problem from project euler. Find the largest multiple of five consecutive digits in this 1000 digit number
04:54:33 <Eduard_Munteanu> Yeah, it's not really nice.
04:54:44 <kmc> also Arrays suck if you want to make modifications
04:54:54 <jophish_> I should probably make this into a list of integers
04:55:15 <jophish_> Thanks for your help
04:55:18 <kmc> with only 1000 elements list ops are probably fine
04:55:55 <jophish_> yeah, we've spent more time chatting than it would have taken to calculate
04:56:04 <kmc> :)
04:56:29 <tomberek> ski: I started using that "a:_ <- " trick.  Ran into an issue. It means something different than using head. One is strict while the other is lazy. Using ~(a:_) re-created standard head behavior, where it ran quickly in GC'd constant space.   The other variant (a:_) never GC'd or allocated at all, but was actually slower.
04:57:51 * hackagebot Win32 2.2.1.0 - A binding to part of the Win32 library  http://hackage.haskell.org/package/Win32-2.2.1.0 (IanLynagh)
04:57:53 * hackagebot array 0.3.0.3 - Mutable and immutable arrays  http://hackage.haskell.org/package/array-0.3.0.3 (IanLynagh)
04:57:56 * hackagebot base 4.4.0.0 - Basic libraries  http://hackage.haskell.org/package/base-4.4.0.0 (IanLynagh)
04:57:58 * hackagebot bytestring 0.9.2.0 - Fast, packed, strict and lazy byte arrays with a list interface  http://hackage.haskell.org/package/bytestring-0.9.2.0 (IanLynagh)
04:58:00 * hackagebot containers 0.4.1.0 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.4.1.0 (IanLynagh)
04:58:01 <Axman6> :D
04:58:36 <tomberek> hi sanjoyd
04:58:41 <Botje> hmm, concrete container types.
04:58:46 <Botje> must be heavy.
05:00:13 <ski> tomberek : yes, it's stricter
05:02:32 <tomberek> yeah, i didn't see that at first, and was shocked that i went from 7600 GC's to 1
05:03:02 * hackagebot directory 1.1.0.1 - library for directory handling  http://hackage.haskell.org/package/directory-1.1.0.1 (IanLynagh)
05:03:04 * hackagebot extensible-exceptions 0.1.1.3 - Extensible exceptions  http://hackage.haskell.org/package/extensible-exceptions-0.1.1.3 (IanLynagh)
05:03:06 * hackagebot filepath 1.2.0.1 - Library for manipulating FilePaths in a cross platform way.  http://hackage.haskell.org/package/filepath-1.2.0.1 (IanLynagh)
05:03:08 * hackagebot haskell2010 1.1.0.0 - Compatibility with Haskell 2010  http://hackage.haskell.org/package/haskell2010-1.1.0.0 (IanLynagh)
05:03:10 * hackagebot haskell98 2.0.0.0 - Compatibility with Haskell 98  http://hackage.haskell.org/package/haskell98-2.0.0.0 (IanLynagh)
05:03:27 <kmc> woah
05:03:43 <tomberek> ski: still don't understand though why the allocating version was slightly faster, I'm redoing the experiment this time with an immutable structure
05:03:45 <kmc> these are the GHC libs
05:03:46 <kmc> from 7.2?
05:03:51 * Axman6 senses a potential new ghc release?
05:04:14 <Botje> I don't even have 7.0 yet :/
05:04:31 <kmc> 7.2 has been out for a few weeks, but maybe the libs didn't make it to Hackage yet
05:04:40 <Botje> or 6.12 for that matter :P
05:04:44 <kmc> oh dear
05:04:52 <kmc> Botje, you're missing out
05:06:09 <stulli> Hm, why do i need haskell98 in my .cabal file to be able to use the System module? Isn't System part of base?
05:06:52 <ski> tomberek : i'm not sure, but i'd prefer any error to occur at that point, `arg:_ <- getArgs', instead of it happening whenever `arg' gets forced later
05:06:54 <Botje> kmc: I'm not doing much haskell atm, to be honest.
05:07:52 <tomberek> ski:   no, that's not where the difference was made,, it was in the inner loop. I was using head (and now (a:_)) in the traversal
05:08:12 * hackagebot hpc 0.5.1.0 - Code Coverage Library for Haskell  http://hackage.haskell.org/package/hpc-0.5.1.0 (IanLynagh)
05:08:14 * hackagebot old-locale 1.0.0.3 - locale library  http://hackage.haskell.org/package/old-locale-1.0.0.3 (IanLynagh)
05:08:14 <ski> oh
05:08:16 * hackagebot old-time 1.0.0.7 - Time library  http://hackage.haskell.org/package/old-time-1.0.0.7 (IanLynagh)
05:08:18 * hackagebot process 1.1.0.0 - Process libraries  http://hackage.haskell.org/package/process-1.1.0.0 (IanLynagh)
05:08:20 * hackagebot template-haskell 2.6.0.0 -   http://hackage.haskell.org/package/template-haskell-2.6.0.0 (IanLynagh)
05:08:59 <kmc> stulli, no, it moved to 'haskell98'
05:09:09 <kmc> afaik all of the base modules have at least 2 path components
05:09:20 <ski> in `nextFirst' ?
05:09:28 <tomberek> ski: yeah
05:09:51 <kmc> stulli, see System.Environment, System.Process, System.Exit, etc
05:10:27 <tomberek> ski: I am trying to reproduce the effect with simpler code, immutable this time. to see that memory vs speed tradeoff
05:11:48 <tomberek> ski: (but the speeds of traversal are almost identical. It looks like I can get a little more than 100 million steps of traversing per second either way.  I'd have to get into the core to get any faster I think. It's a bit beyond me.
05:12:38 <ski> is there any specific bottleneck that you're trying to avoid ?
05:13:20 <tomberek> no, i am just usually accustomed to memory and allocation being a bottleneck, this time it wasn't, hence my surprise and desire to learn why, because once I learn WHY, i understand
05:13:22 * hackagebot unix 2.5.0.0 - POSIX functionality  http://hackage.haskell.org/package/unix-2.5.0.0 (IanLynagh)
05:13:24 * hackagebot utf8-string 0.3.7 - Support for reading and writing UTF8 Strings  http://hackage.haskell.org/package/utf8-string-0.3.7 (IanLynagh)
05:15:52 * ski wonders whether it was considered to use `NOTICE's in hackagebot
05:16:23 <flux> I think it would the right way, but unfortunately some irc clients are way too noisy about NOTICEs
05:16:48 <ion> And some clients are less noisy about NOTICEs than PRIVMSGs. And the broken one can probably be configured to be less broken.
05:16:55 <tomberek> ski: but something on the order of 10-20 clock cycles per 'step' is pretty respectable i think
05:17:11 <Peaker> clock cycles is such an outdated measure IMO :-)
05:17:36 <Peaker> (I'd measure count of L1 cache miss, L2 cache miss, L3 cache miss for single-core performance.. :)
05:18:03 <tomberek> ghc does a pretty good job, no annotations or PRAGMAs...... Peaker, true, but it's not like 100-1000 like in Hugs
05:18:13 <tomberek> GHC seems to do pretty well
05:18:21 <tomberek> that was all I was trying to say
05:18:38 <Peaker> well, a single L1 miss costs hundreds of cycles -- so the computational cycles are virtually irrelevant for most things
05:19:25 <tomberek> Peaker, hence my confusion about why my 'allocating' version is faster than my non-allocating version. I would have thought that the GC's etc, would slow things down.
05:20:21 <stulli> kmc: Ah i see, and here i thought i messed up my cabal packages
05:21:09 <tomberek> Peaker, but that also brings up a good point. Are there optimizations in GHC that take the effect of cache misses into account?
05:21:37 <Peaker> tomberek: Have no idea
05:21:43 <kmc> i think cache effects are one reason pointer tagging is a big win
05:22:11 <kmc> (i can explain this particular optimization if anyone cares)
05:22:20 <kmc> though it's not an optimization in the sense of a code transformation
05:22:51 * hackagebot pcap-enumerator 0.2 - Convert a pcap into an enumerator.  http://hackage.haskell.org/package/pcap-enumerator-0.2 (KatsutoshiItoh)
05:23:04 <tomberek> kmc: i am interested
05:23:30 <tomberek> kmc: i read a little about cache-oblivious structures, cool stuff
05:24:49 <kmc> so consider an expression of type (Maybe Int)
05:25:07 <kmc> GHC is going to represent this as a pointer to a struct in the heap
05:25:41 <kmc> which itself has a pointer to an "info table", which is static data
05:26:04 <DrTeggy> Peaker, an L1 miss will cost in the 10s of cycles on a modern CPU.
05:26:04 <tomberek> sure, or something saying "i'm a thunk"?
05:26:07 <kmc> this heap object could represent a Nothing constructor or a Just constructor, or it could represent an unevaluated thunk
05:26:15 <DrTeggy> (not 100s)
05:26:24 <kmc> (that's why i said "expression" and not "value" above)
05:26:45 <kmc> but in any case the representation is the same: pointer to struct with pointer to info table
05:27:13 <kmc> and if you want to pattern-match on the value, you call a function pointed to by that info table
05:27:27 <kmc> and it returns back to you a machine int saying whether the constructor was Nothing or Just
05:27:37 <kmc> and it might also force the thunk in the process, and do arbitrarily much other computation
05:27:42 <Peaker> DrTeggy: many 10s of cycles on our platform, iirc
05:28:23 <kmc> anyway this is a pretty roundabout way to check the constructor of an already-evaluated value
05:28:30 <Peaker> DrTeggy: still computational instructions that cost a few cycles are almost negligible compared to memory accesses (unless they're in a tight loop that only hits the cache)
05:28:53 <DrTeggy> Peaker, that's true.  Memory is the new disk, so to say.
05:29:04 <kmc> pointer tagging takes advantage of the fact that heap objects are aligned to 4 (resp. 8) bytes on 32-bit (resp 64-bit) platforms
05:29:15 <tomberek> kmc: yep, several jumps just to get simple result.... so do they hide it in some insignificant bits?
05:29:26 <kmc> so you can use the bottom 2 (resp 3) bits of a pointer to record the constructor and the fact that the value is evaluated
05:29:31 <kmc> in cases where you know it to be
05:29:43 <Peaker> DrTeggy: which makes pointer-chasing bad for performance.. which should suggest compiling some things differently perhaps (e.g: unboxing more products)
05:31:19 <kmc> so an evaluated algebraic value of a type with no more than 3 (resp. 7) constructors can sometimes be pattern-matched without those indirect jumps, but also without pulling the info table into cache
05:31:46 <kmc> there's another older optimization named "tables next to code", which removes one of those indirections, by putting the info table just before the entry code, and pointing to the latter
05:37:04 <tomberek> kmc: got it
05:37:52 <kmc> those tables next to code are one reason GHC-produced binaries look weird if you disassemble them
05:38:14 <kmc> and it's one reason targeting C from GHC was fugly
05:38:21 <tomberek> copy
05:39:22 <DrTeggy> kmc, but instruction and data cache are separate on typical contemporary CPUs.  How does a data able next to code help?
05:39:34 <DrTeggy> *table
05:39:42 <kmc> it eliminates an indirection
05:40:10 <kmc> calling the entry code is by far the most common thing you need to do with the info table
05:40:21 <kmc> so instead of following a pointer to the info table, and another from there to the entry code
05:40:23 <DrTeggy> OK, an indirection turned into a PC-relative address?
05:40:32 <kmc> you just point at the entry code directly
05:40:42 <kmc> and when you need the info table itself, you subtract n from that pointer
05:40:49 <DrTeggy> I see.
05:41:00 <kmc> but this only works when they have a known spatial relation in memory
05:41:17 <kmc> "tables 0x100000 after code" would be fine too
05:41:31 <kmc> but i think that's harder to implement in practice
05:41:51 <DrTeggy> Didn't the LLVM back-end struggle with this?
05:41:54 <kmc> yeah
05:41:59 <kmc> they had to add a feature to LLVM, iirc
05:42:03 <DrTeggy> I recall the discussion.
05:42:04 <tomberek> kmc: is there a difference between the accessor functions of a record, pattern matching, or a separately defined unboxer?
05:42:05 <kmc> and they had a mini-mangler in the interim
05:42:15 <DrTeggy> yep
05:42:40 <kmc> tomberek, not sure.  i'd expect not, in cases where the accessor gets inlined
05:43:03 <kmc> the accessor functions themselves are also values
05:43:43 <kmc> heh, you can actually do struct foo __attribute__((section(".text"))) in GCC and it... kind of works?
05:43:58 <thoughtpolice_> there's still a mini mangler inside GHC, that's used for LLVM on all platforms actually
05:44:28 <thoughtpolice_> originally the LLVM mangler was there to deal with GNU as being like a trillion years old on OS X or whatever, but other problems arose and david ended up making it the default on every platform
05:44:43 <thoughtpolice_> (seriously, as on OS X is ooooold)
05:45:04 <kmc> ah
05:45:16 <kmc> and it does textual post-processing on platform-specific assembly code?
05:45:31 <thoughtpolice_> yep, i can't exactly remember what it does
05:45:33 <thoughtpolice_> hold on
05:45:49 <saml> hello haskell i come with mona
05:45:51 <saml> d
05:45:51 <thoughtpolice_> (on the good side it's like maybe 100 lines long last I saw it?)
05:46:07 <saml> 100 lines ?
05:46:33 <saml> 100 lines in monad means 100 actions
05:46:44 <saml> that means your computation is long
05:50:27 <thoughtpolice_> kmc: ah, nvm, it does some info-table fixing and additionally on OS X it's not that 'as' is old, it does some swizzling to make sure the stack is 16 byte aligned (you always need 16 bit alignment for e.g. SSE and stuff, but OS X generally enforces a 16b alignment whereas windows/os x enforce a page sized/4 or 8kb alignment
05:50:37 <ktosiek> what to do if I have a top-level binding with signature longer than itself? Is there any way to tell GHC "this function is from 'A (whatever)' to 'A (guess yourself)'"?
05:50:42 <thoughtpolice_> er, windows/linux, my bad
05:50:44 * thoughtpolice_ just woke up
05:51:09 <thoughtpolice_> ktosiek: there's no way to have a partial type signature, no.
05:51:15 <ktosiek> :-C
05:52:07 <thoughtpolice_> well, for GHC at least. i don't think there's anything impossible about it though, UHC does it for instance
05:53:12 <kmc> there's some ways to hack it
05:53:17 <kmc> i think oleg wrote about it
05:53:29 <byorgey> I imagine it would actually be fairly easy to implement.  The hardest part is coming up with a good syntax and giving good error messages.
05:53:42 <aavogt> ktosiek: you can put a signature in the pattern (with some extension)
05:53:56 <Saizan> the actual implementation just smuggles a meta-variable in there
05:54:34 <Saizan> we could use _ as the syntax, unless we want to let the user refer to the same meta-variable twice
05:54:45 <kmc> it is useful to do so
05:54:46 <aavogt>  _1 _2 ...
05:54:50 <kmc> bleh
05:54:52 <kmc> i guess
05:55:00 <Entroacceptor> why not just define new types?
05:55:08 <aavogt> or  __ ___ ____ ... python!?
05:56:08 <aavogt> Entroacceptor: sometimes the type is a long as the expression which defines the value
05:56:33 <Entroacceptor> then you're probably going to need it more often
05:57:07 <erus`> ___python___
05:57:08 <aavogt> well it comes up in some approaches to faking better records
05:57:28 <ktosiek> Entroacceptor: not really, it's in xmonad config and needed exactly once
05:58:14 <aavogt> in the xmonad config you can wrap the massive layout type with  Layout
05:59:05 <aavogt> then define    xmonadLayout conf @ XConfig { layoutHook = Layout l } = xmonad conf{ layoutHook = l }
06:13:43 <ski> hm, Miranda uses `*',`**',`***',&c. for type variables
06:16:17 <EvanR-work> ew miranda
06:17:32 <byorgey> How silly.  Everyone knows * is the kind of inhabited types, ** is exponentiation, and *** is parallel composition of arrows  ;)
06:20:17 <roconnor> ugh, hackathon on the day I'm leaving Japan. :(
06:30:56 <Guest71890> cabal: Couldn't read cabal file "bytestring\\0.9.2.0\\bytestring.cabal"
06:31:32 <Guest71890> what wrong with bytesring?
06:34:00 <roconnor> byorgey: is Void an inhabited type?
06:36:05 <byorgey> roconnor: yes, _|_.  Whereas 'Maybe' is not even inhabited by _|_.
06:36:12 <int-e> Guest71890: dunno, works fine with Cabal-1.12 library, fails with Cabal-1.10.1.0
06:36:58 <byorgey> Perhaps I should have said something more like "inhabitable types*
06:37:08 <int-e> Guest71890: which complains about the test-suite missing a type field, which is clearly there, so I guess it's a bug in Cabal.
06:37:28 <byorgey> although very soon * will not be the only kind to classify inhabitable types.
06:37:39 <Feuerbach> byorgey: or simply "types" (I think Maybe is not a type)
06:37:50 * roconnor agrees with Feuerbach
06:37:53 <byorgey> Feuerbach: it depends on how you define the terminology.
06:38:01 <Guest71890> yes, my cabal is 1.10.1.0
06:38:06 <roconnor> I always call Maybe a type constructor
06:38:41 <byorgey> I do too.  But it confuses lots of people.
06:38:46 <roconnor> I see
06:39:36 <Philonous_> byorgey:  People who don't know what a type is?
06:40:00 <byorgey> Philonous_: people who don't realize they are supposed to use different terminology to refer to 'Maybe' as opposed to 'Maybe Int'.
06:40:28 <byorgey> and honestly, sometimes it gets tedious sticking the word 'constructor' everywhere, and you just want to say "types" to refer to anything classified by a kind
06:40:34 <roconnor> Unfortunately, no one can be told what a type is. You have to see it for yourself.
06:40:38 <Guest71890> but bytestring 0.9.2.0 is required to upgrade Cabal-1.10.1.0 to Cabal-1.12
06:40:40 <Saizan> well, id :: () -> () is still a avlue
06:40:42 <Saizan> *value
06:40:52 <hpc> roconnor: they might also get confused by value constructors being values
06:41:02 <roconnor> hpc: that is confusing
06:41:02 <Saizan> so i don't see anything wrong with Maybe :: * -> * being a type
06:41:58 <Saizan> the type level is still higher order :)
06:42:57 <byorgey> yikes, big thunderstorm here... back later
06:42:59 <Feuerbach> It seems that Haskell report doesn't differentiate between types and type constructors. E.g. "a :: Maybe" satisfies formal syntax http://www.haskell.org/onlinereport/syntax-iso.html
06:43:02 <Gracenotes> byorgey: NYC?
06:43:09 <roconnor> Feuerbach: yep
06:43:22 <Gracenotes> or, hm, more likely south-er. NYC isn't the only place expecting a big thunderstorm >A_>
06:45:00 <roconnor> maybe it is a hurricane
06:45:18 <int-e> Guest71890: yes, that's unfortunate. Best idea I have is to  'cabal unpack Cabal', then cd Cabal-1.10.2.0; runhaskell Setup.lhs configure; runhaskell Setup.lhs build; runhaskell Setup.lhs install, then the same for cabal-install, after which cabal-install seems to work again
06:45:29 <int-e> hmpf, he left.
06:46:54 <int-e> (otoh I just tried this out and it works for me. so if anybody has trouble with cabal-install on ghc-7.0.3 right now - and I expect there will be quite a few people - this is a suitable work-around to get things going again)
06:51:45 <int-e> Oh, somebody removed bytestring-0.9.2.0 from hackage - but the http://hackage.haskell.org/package/bytestring (sym)link(?) is broken now.
06:53:05 <int-e> and it's still included in the package index.
06:53:39 <Saizan> i wish i realized what you were referring to before i ran cabal update..
06:55:38 * ski calls `Maybe' a type constructor, as well as a type; while `Either String' is not a type constructor, just a type
06:56:03 <roconnor> what do we call values that are not functions?
06:56:31 <int-e> Saizan: does  tar -f ~/.cabal/packages/hackage.haskell.org/00-index.tar --delete bytestring/0.9.2.0  help?
06:56:46 <ski> do we need to call them something special ?
06:58:14 <Saizan> int-e: seems so, thanks!
06:59:42 <lorienor> @roconnor literals
06:59:42 <lambdabot> Unknown command, try @list
06:59:53 <roconnor> lorienor: nope.
07:00:00 <lorienor> scalar ?
07:00:14 <roconnor> don't think so
07:00:31 <lorienor> a function always stands in place of another value
07:00:45 <roconnor> ?
07:01:17 <lorienor> a function is a path to follow to get a particular value
07:01:43 <Saizan> more like many paths
07:01:57 <Saizan> leading to many values
07:02:52 <roconnor> must resist talking about homotopies
07:05:02 <Andreas___> Is there a package of STM-based concurrent data structures? In particular, I'd like an STM-based hash table.
07:05:19 <Andreas___> I searched on hackage but didn't find anything there.
07:21:52 <coco> hi
07:22:02 <roconnor> hi
07:22:06 <dyn> hi
07:22:37 <coco> i am trying haskell interactively!
07:22:40 <coco> fun!
07:22:55 <dyn> as a 0-day haskell noob, i'm trying to write a prime generator. i wonder what's wrong with my round $ sqrt stuff at the end:   prime num = foldl1 (&&) $ map (\x -> mod num x /= 0) [2..(round $ sqrt num)]
07:23:17 <dyn> it causes a type error but I fail to understand why :(
07:23:19 <roconnor> you need to convert num into a floating point number with (fromIntegral)
07:23:21 <roconnor> ie
07:23:30 <roconnor> sqrt $ fromIntegral num
07:23:41 <roconnor> that said floating point numbers are bad
07:23:52 <Axman6> :t sqrt
07:23:53 <roconnor> that said we don't have an integer square root function :(
07:23:53 <lambdabot> forall a. (Floating a) => a -> a
07:24:16 <dyn> i wouldn't want to use any floating stuff myself
07:24:30 <Axman6> well you have to to use sqrt
07:24:31 <roconnor> also foldl1 (&&) is "and"
07:24:35 <roconnor> @type and
07:24:36 <lambdabot> [Bool] -> Bool
07:24:36 <dyn> roconnor, thanks that made the trick
07:24:49 <roconnor> also and $ map is "forall"
07:24:51 <Axman6> a much better idea is to use a check for x*x <= n
07:24:52 <roconnor> @type forall
07:24:53 <lambdabot> Not in scope: `forall'
07:24:58 <roconnor> er
07:25:01 <roconnor> @type all
07:25:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
07:25:06 <roconnor> also and $ map is "all"
07:25:09 <dyn> roconnor, phew give me a sec to track this down
07:25:12 <Axman6> heh, nice brainfart =)
07:26:27 <dyn> 'and' is ok
07:26:36 <dyn> i'm not sure about that forall though..
07:27:02 <roconnor> dyn: Axman6 is suggesting replacing [2..(round $ sqrt $ fromIntegral num)] with "takeWhile (\n -> n^2 <= num) [2..]"
07:27:20 <roconnor> dyn: and $ map f x  == all f x
07:27:21 <Axman6> dyn: ignore the forall
07:27:24 <roconnor> @src all
07:27:25 <lambdabot> all p =  and . map p
07:27:39 <roconnor> dyn: ya sorry it is called "all" instead of "forall"
07:28:57 <dyn> so it becomes let prime num = all (\x -> mod num x /= 0) $ takeWhile (\n -> n^2 <= num) [3,5..]
07:29:33 <dyn> nicer indeed, especially getting rid of the sqrt + type convert stuff
07:30:01 <roconnor> > let prime num = all (\x -> mod num x /= 0) $ takeWhile (\n -> n^2 <= num) [3,5..] in map prime [2,3,4,5]
07:30:03 <lambdabot>   [True,True,True,True]
07:30:23 <roconnor> > let prime num = all (\x -> mod num x /= 0) $ takeWhile (\n -> n^2 <= num) [3,5..] in map prime [2,3,4,5,6,7]
07:30:24 <lambdabot>   [True,True,True,True,True,True]
07:30:31 <roconnor> > let prime num = all (\x -> mod num x /= 0) $ takeWhile (\n -> n^2 <= num) [3,5..] in map prime [2,3,4,5,6,7,8,9]
07:30:32 <lambdabot>   [True,True,True,True,True,True,True,False]
07:30:42 <copumpkin> epic win
07:30:53 <roconnor> dyn: I think you are going to have to replace "[3,5..]" with "2:[3,5..]
07:30:57 <tromp> > 117/8
07:30:58 <lambdabot>   14.625
07:31:03 <roconnor> > let prime num = all (\x -> mod num x /= 0) $ takeWhile (\n -> n^2 <= num) (2:[3,5..]) in map prime [2,3,4,5,6,7,8,9]
07:31:04 <lambdabot>   [True,True,False,True,False,True,False,False]
07:31:05 <Axman6> > let prime num = all (\x -> mod num x /= 0) $ takeWhile (\n -> n^2 <= num) [3,5..] in filter prime [2..]
07:31:06 <lambdabot>   [2,3,4,5,6,7,8,10,11,13,14,16,17,19,20,22,23,26,28,29,31,32,34,37,38,41,43,...
07:31:12 <Axman6> :(
07:31:44 <Axman6> > let prime num = all (\x -> mod num x /= 0) $ takeWhile (\n -> n^2 <= num) (2:[3,5..]) in filter prime [2..]
07:31:45 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:32:37 <tromp> > nubBy(\x y->y`mod`x==0)[2..]
07:32:38 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
07:32:47 <tromp> > nubBy(\x y->x`mod`y==0)[2..]
07:32:48 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:33:01 <roconnor> tromp: less lambdas
07:33:47 <tromp> @pl \x y->x`mod`y==0
07:33:47 <lambdabot> flip flip 0 . ((==) .) . mod
07:33:53 <roconnor> > nubBy((0==).:mod)[2..]
07:33:57 <lambdabot>   mueval-core: Time limit exceeded
07:34:05 <roconnor> :(
07:34:11 <int-e> > nubBy (((>1).).gcd)[2..]
07:34:13 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
07:35:07 <roconnor> @unpl (((0==).).mod
07:35:07 <lambdabot> Unbalanced parentheses
07:35:08 <gwern> @quote shit
07:35:09 <lambdabot> shit says: "don't shit your pants!"
07:35:10 <roconnor> @unpl ((0==).).mod
07:35:11 <lambdabot> (\ e h -> 0 == (mod e h))
07:35:15 <gwern> what on earth
07:35:28 <gwern> anyone mind if I delete that one?
07:35:32 <roconnor> nope
07:35:35 <int-e> (the gcd variant gives a nice symmetric relation)
07:35:38 <tromp> @hoogle gcd
07:35:38 <lambdabot> Prelude gcd :: Integral a => a -> a -> a
07:35:51 <gwern> @forget shit don't shit your pants!
07:35:52 <lambdabot> No match.
07:35:56 <gwern> @forget shit "don't shit your pants!"
07:35:57 <lambdabot> Done.
07:36:00 <gwern> @flush
07:36:01 <gwern> @quote shit
07:36:02 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
07:36:18 <roconnor> @src (.:)
07:36:19 <lambdabot> Source not found. Wrong!  You cheating scum!
07:36:21 <gwern> @remember jmcarthur your opinions all suck. i'm going back to #haskell (...) oh shit, i'm already there
07:36:21 <lambdabot> I will remember.
07:36:24 <gwern> @quote shit
07:36:24 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
07:36:28 <gwern> hm.
07:36:40 <gwern> @flush
07:36:45 <gwern> @quote shit
07:36:45 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
07:36:50 <roconnor> @quote
07:36:51 <lambdabot> kmc_ says: Haskell may have syntactic sugar, but C++ has syntactic strychnine
07:37:02 <gwern> @quote oh.*shit
07:37:03 <lambdabot> jmcarthur says: your opinions all suck. i'm going back to #haskell (...) oh shit, i'm already there
07:37:07 <gwern> oh, now I remember
07:37:14 <dyn> roconnor, what's the point with replacing [3,5..] with 2:[3,5..]
07:37:18 <gwern> if it's a single word, it searches by author first, doesn't it
07:37:20 <mambo> @pl \x (a, v1) =  if a == "id" && x == v1 then True else False
07:37:20 <lambdabot> (line 1, column 12):
07:37:20 <lambdabot> unexpected "="
07:37:20 <lambdabot> expecting pattern or "->"
07:37:27 <mambo> @pl \x (a, v1) ->  if a == "id" && x == v1 then True else False
07:37:27 <lambdabot> (`ap` snd) . (. fst) . flip flip False . (flip .) . flip flip True . ((flip . (if' .)) .) . flip ((.) . (&&) . ("id" ==)) . (==)
07:37:27 <tromp> i;m trying to copmuting characteristic sequence of primes in 25 bytes
07:37:29 <gwern> @quote few.*research
07:37:29 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
07:37:33 <roconnor> dyn: it makes your program correct instead of incorrect :D
07:37:39 <dyn> roconnor, haha
07:37:41 <gwern> @quote accel
07:37:42 <lambdabot> accel says: fuck; *.lhs files are unreadable
07:37:43 <roconnor> dyn: try testing if 4 is prime
07:37:46 <int-e> @quote stereo
07:37:47 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
07:37:55 * dyn goes hmm
07:37:55 <gwern> @remember accel next time I'll read a few research papers before I start trolling hakell
07:37:55 <lambdabot> Nice!
07:37:58 <gwern> @flush
07:38:02 <tromp> my best attempt so far is 25.5 bytes:(
07:38:09 <int-e> @quote fugue
07:38:09 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
07:38:40 <roconnor> dyn: once you are satified with your prime function, read this blog post: http://r6.ca/blog/20081116T213644Z.html
07:38:59 <dyn> roconnor, i like it a lot now.. :)
07:40:16 <roconnor> dyn: and then after that maybe read this comment: http://www.reddit.com/r/haskell/comments/7du1b/a_haskell_zen_moment/c06e9bz?context=1
07:41:22 <roconnor> if we are lucky dyn's head will explode in a few minutes. :)
07:42:15 * ski grins
07:42:30 <dyn> i've read over 100 pages from learn you a haskell.. very carefully to always avoid a load higher than 5.0..
07:45:53 <int-e> tromp: that'd be 25 bytes in your binary lambda calculus?
07:48:24 <tromp> kkkright:)
07:50:21 <tromp> $25 dollars if you can do it
07:51:26 <erus`> anyone good with C++ in here?
07:51:31 <copumpkin> nope
07:51:44 <roconnor> try #haskell-blah
07:52:20 <alpounet> try ##C++ ? :P
07:52:38 <roconnor> alpounet: that doesn't seem like it would be helpful :D
07:52:59 <da> If I have, say, "Data A = A1 Int Double | A2 Int String" and a function f :: A -> whatever, is there a way to distinguish whether an argument to f is A1 or A2 without deconstructing it?
07:53:12 <HugoDaniel> http://hpaste.org/50656 <- help please
07:53:17 <HugoDaniel> im trying to compile haskell code in windows
07:53:25 <mauke> da: what do you mean by "without deconstructing"?
07:53:41 <int-e> da: no. You can shorten the match though,  f A1{} = 1; f A2{} = 2
07:53:42 <roconnor> da: not really; though you may be able to only directly deconstruct it using a helper function.
07:54:00 <int-e> (if you don't care about the fields)
07:54:05 <roconnor> da: are you interested in projecting out the Int field?
07:54:31 <da> what does projecting out mean?
07:54:56 <HugoDaniel> how can i solve that error ?
07:55:06 <mauke> da: extracting
07:56:14 <roconnor> da: if you write something like "data A = A1 {foo :: Int; Double} | A2 {foo :: Int; String}"  you can use foo :: A -> Int.
07:56:25 * roconnor isn't sure he got the syntax quite right there
07:56:32 <da> I want to figure out whether the argument is A1 or A2, then use functions to access the fields in the function body, avoiding having a whole bunch of fields in the pattern.
07:57:12 <mauke> da: but those functions to access the fields have to pattern match again
07:57:21 <mauke> seems inefficient
07:57:26 <roconnor> da: you can do f x@(A1{}) = foo x; f x@(A2{}) = bar x
07:57:37 <da> I'm using record syntax
07:57:39 <mauke> you don't need those parens
07:57:40 <roconnor> though I don't think this is better.
07:57:49 <da> so they don't have to pattern match again
07:57:55 <mauke> da: what
07:58:04 <mauke> real code, please
07:58:07 <roconnor> mauke: da doesn't expliticly have to pattern match.
07:58:18 <mauke> roconnor: "explicitly" is irrelevant
07:58:48 <roconnor> mauke: depends on if your concerns are operational concerns, or if they are ledgablitly concerns.
07:59:11 <mauke> I'm picturing code of the shape: if null xs then foo else bar (head xs) (tail xs)
07:59:30 <roconnor> ya me too :(
07:59:46 <roconnor> da: this style you are advancing seems unsafe.
07:59:49 <int-e> HugoDaniel: http://hackage.haskell.org/trac/ghc/ticket/5289 (see in particular the 3rd comment from the end unless you're on windows)
08:00:22 <da> why is that?
08:01:07 <roconnor> da: the record field access functions (aka projections) are partial functions and can throw runtime errors on incorrect inputs.
08:01:39 <roconnor> da: If you use pattern matching instead these runtime errors are impossible.
08:04:47 <da> rconnor: ok, thanks
08:06:04 <dyn> roconnor, thanks for your help
08:06:09 <dyn> gotta go now, see yas later
08:06:15 <roconnor> dyn: bye
08:06:34 <Overlord> hi, I'm trying to learn haskell can anyone tell me whats wrong with this code?
08:06:40 <roconnor> Is it just me, or is programming with exceptions in Ocaml kinda error prone?
08:06:58 <Overlord> a :: (Integral a, Char b) => a -> b
08:07:01 <Overlord> a _ = 'A'
08:07:21 <roconnor>  Overlord Char isn't a type class it is a type
08:07:31 <roconnor> a :: (Integral a) => a -> Char
08:07:32 <Overlord> yes the compiler tells me that
08:07:41 <Overlord> ah so easy :)
08:07:42 <Overlord> thanks
08:07:52 <rostayob> has anybody read "Backtracking, Interleaving, and Terminating
08:07:54 <rostayob> Monad Transformers"
08:07:56 <rostayob> ops
08:10:18 <rostayob> anyway, I have trouble understanding the type used for the implementation with continuations, which basically is newtype SFKT = SFKT (∀ ans. (a -> m ans -> a) -> m ans -> m ans)
08:11:31 <rostayob> now, I understand the Cont monad, the difference here is that we have a failure continuation as well, right?
08:11:47 <rostayob> but why is it a rank-2 type?
08:11:58 <Entroacceptor> @src filter
08:11:58 <lambdabot> filter _ []     = []
08:11:58 <lambdabot> filter p (x:xs)
08:11:58 <lambdabot>     | p x       = x : filter p xs
08:11:58 <lambdabot>     | otherwise = filter p xs
08:12:36 <rostayob> couldn't it be newtype SFKT ans m a = SFKT (∀ ans. (a -> m ans -> a) -> m ans -> m ans)?
08:14:14 <roconnor> rostayob: usually the reason for rank2ness in continutation is so they can be called multiple types in different contexts
08:14:44 <roconnor> rostayob: oh wait
08:14:52 <roconnor> but maybe this rank2ness is different
08:14:54 <roconnor> nevermind me
08:15:09 <int-e> Funny, ghc 7.0.3 chokes on n+k-patterns by default.
08:16:33 <HugoDaniel> in windows how do i convert iso-8859-1 characters to utf-8 in haskell ?
08:16:44 <rostayob> roconnor: all it says is "The answer type is fully polymorphic" but it doesn't really explain why
08:17:00 <int-e> (Since they got removed in Haskell2010. The funny part is that I had not noticed until now.)
08:17:48 <roconnor> HugoDaniel: have you looked into the new encoding mechanism?
08:18:04 <int-e> tromp: This removal of n+k patterns breaks your AIT stuff.
08:18:37 <roconnor> HugoDaniel: hSetEncoding and whatnot
08:18:40 <rostayob> weren't n+k patterns removed in ghc 7?
08:19:07 <int-e> tromp: (Fix is easy, in AIT.lhs, replace  prebin (DBVar (i+1)) s = '1':(prebin (DBVar i) s)  by  prebin (DBVar i) s = '1':(prebin (DBVar (i-1)) s).
08:19:19 <int-e> rostayob: You can get them if you use -XHaskell98
08:19:40 <rostayob> int-e: yeah but the fact that they're disabled by default was introduced in ghc 7 afaik
08:19:47 <tromp> yes, i fixed it privately, need to put it online
08:20:13 <int-e> rostayob: it was. as I said, the funny thing is that I had not noticed so far.
08:20:34 <rostayob> int-e: ah, ok :)
08:25:59 <HugoDaniel> roconnor: no
08:26:13 <ski> roconnor : .. you mean that exceptions aren't checked by the type system ?
08:26:20 <ski> rostayob : the `forall ans. ' enforces effect-freeness, in a sense
08:26:55 <rostayob> ski: effect freeness?
08:27:06 <ski> yes
08:27:10 <rostayob> what effects?
08:27:19 <ski> continuation effects
08:27:52 <ski> consider something of type `(a -> ans) -> ans'
08:27:54 <HugoDaniel> ok, this seems nice, now i need to find out how i use it with hdbc
08:28:15 <ski> @type cont . flip all
08:28:16 <lambdabot> forall a. [a] -> Cont Bool a
08:29:07 <Axman6> :t cont
08:29:08 <ski> if you have `(a -> ans) -> ans' with a free variable `ans' instead of `forall ans. (a -> ans) -> ans', then any function of that type can use the continuation more than once
08:29:08 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
08:29:24 <ski> (which `flip all' does)
08:29:53 <ski> to ensure it being basically the same as a plain `a', you need `forall ans. (a -> ans) -> ans'
08:29:55 <rostayob> ski: ah, in this case with lists of different types
08:30:18 <ski> the `forall ans. (a -> m ans -> a) -> m ans -> m ans' case is somewhat more involved, but it's the same idea
08:30:42 * ski wonders whether rostayob quoted that type correctly
08:31:00 <kowey> hi all, I just started getting "cabal: Couldn't read cabal file "bytestring/0.9.2.0/bytestring.cabal" after a recent cabal update
08:31:03 * ski would have expected `forall ans. (a -> m ans -> m ans) -> m ans -> m ans'
08:31:13 <kowey> anybody know what that's about?
08:31:13 <rostayob> ski: yes sorry, you're right
08:31:38 <ski> in this case `m' is concrete, but `ans' is generic
08:31:58 <ski> so it can't manipulate the `ans', but it can perform arbitrary `m'-effects
08:33:20 <rostayob> ski: mhm. I'm not sure I follow you. If we get back to the "cont . flip all" example, in this case it's not rank-2
08:33:22 <int-e> tromp: is this supposed to work? # make quine.blc; ./blc u @uni.lam @quine.blc++@quine.blc  (./blc u @uni.lam $(cat quine.blc)$(cat quine.blc)  does work)
08:33:23 <ski> to a first approximation, a value of that type has to be of the form `\cons nil -> cons a0 (cons a1 (cons a2 (..nil..)))'
08:33:30 <HugoDaniel> i dont know how i can get the hdbc connection handle to set the encoding :/
08:33:31 <rostayob> I mean the Cont monad is not defined with the rank-2 type
08:34:07 <tromp> there seems to be a problem with trailing newlines, int-e
08:34:38 <tromp> i have a fixed AIT.lhs that avoids the newline when you do make blah.blc
08:35:16 <ski> rostayob : in the `cont . flip all', you get a computation that performs continuation-effects
08:35:27 <rostayob> ski: I get what it means to make the type rank-2 ("you can't manipulate the ans") but I don't get what the point is
08:35:35 <tromp> are you getting an error, int-e ?
08:35:45 <ski> it calls the continuation of type `a -> Bool' on all elements of the list, `and'ing the results together
08:35:55 <rostayob> ski: yep, right
08:35:56 <byorgey> kowey: there is an email explaining the problem (and a workaround) on haskell-cafe
08:36:10 <kowey> ah brilliant, thanks!
08:36:12 <ski> rostayob : point being to disallows stuff like that `cont . flip all' example
08:36:35 <rostayob> ski: why? I mean why disallow it?
08:36:54 <ski> presumably they only want to use continuations as an optimization
08:37:21 <rostayob> ski: in that case is to construct a monad that does backtracking
08:38:04 <ski> they might as well define `newtype List m a = L (m (Cell m a)); data Cell m a = Nil | Cons a (List m a)'
08:38:14 <tromp> but yes, i have ./blc u @uni.lam @quine.blc++#quine.blc producing same output as ./blc u @id.lam @quine.blc++@quine.blc or just cat quine.blc quine.blc
08:38:23 <tromp> oops, replace that # by @
08:38:35 <ski> and then use `List' instead of `SFKT'
08:38:40 <rostayob> ski: you mean implement the monad with streams? they go on why that doesn't work well
08:38:56 <rostayob> this is the paper btw http://okmij.org/ftp/Computation/LogicT.pdf
08:39:13 <int-e> tromp: Ok I added a filter (not . isSpace) to bitstoLC.
08:39:38 <rostayob> ski: I mean the goal is to create a backtracking monadtrans
08:39:53 <rostayob> so that you can perform backtracking on the computation in the inner monad
08:40:44 <rostayob> ski: it's pretty cool but I missed that bit... and I'm still confused now
08:40:52 <HugoDaniel> anyone knows how can i convert iso-8859-1 to utf-8 in windows ?
08:40:53 <orbisvicis> I want to examine the value in a (Monitor String) monad, so in ghci I do: let b = a >>= (io . print) and nothing happens
08:41:56 <byorgey> orbisvicis: that just defines b as a Monitor String action
08:42:02 <byorgey> orbisvicis: you have to run it if you want it to do something
08:43:22 <ski> rostayob : on a quick skim i miss the rationale in the paper for doing CPS
08:43:33 <ski> but i assume they do it to get better efficiency
08:44:12 <rostayob> ski: As Hinze explains, this “context-passing” implementation improves on the naïve term implementation by removing an interpretive layer.
08:44:39 <ski> yes, also i think it "right-associates" everything
08:45:17 <orbisvicis> byorgey: ah i assumed everything in ghci was run
08:46:01 <orbisvicis> byorgey: anyway if I run b, i get a type error: Control.Monad.Trans.Reader.ReaderT MConfig IO () doesnt derive show, but I don't care about the final value, I only want what print does, if I understand correctly
08:46:14 <rostayob> ski: no, the point is that you can't use streams to create that kind of monad transformer
08:47:04 <rostayob> ski: well it probably has to do with what you said
08:47:22 <ski> rostayob : by "streams" do you mean something like `m [a]' or `[m a]', or do you mean something like the `List m a' i outlined above ?
08:48:00 * ski is amused at initially misspelling `List' as `Must'
08:48:58 <rostayob> ski: simple lists, at a first glance your List looked similar
08:49:04 <ski> it's not the same
08:49:14 <rostayob> yeah
08:49:29 <ski> the `List' allows interleaving `m'-computations with generating the next cell in the list
08:49:56 <rostayob> ski: mhm. i see
08:50:16 <ski> i think it should be equivalent to (but possibly less efficient than) the `SFKT' version (*if* the `forall ans. ' part is included in it)
08:51:00 <rostayob> i think my brain is not fully ready for this stuff, what do i have to read to understand better this kind of programs with complex types?
08:51:17 <ski> if you remove the `forall ans. ', then you can suddenly express stranger computations
08:51:39 <ski> i'm not sure .. maybe play more with them yourselves
08:52:01 <rostayob> ski: I see what it mean, I don't fully see the implications... with that rank-2 type you want be able to do much with the data you have in that monad, and that's clear
08:52:04 <dbpatterson> does anyone know of a good library for image resizing (and other basic manipulation)? Looking at hackage, the only thing I could find was hsmagick, but it has no haddocks which doesn't give me much confidence
08:52:16 <ski> i implemented an `n'-level continuation monad (for arbitrary, callee-decides, `n'), for a logic programming monad
08:52:44 <rostayob> ski: yeah actually my idea in the first place was to implement some logic programming constructs in haskell
08:52:51 <rostayob> and I ended up there
08:52:54 <ski> well, adding the `forall ans. ' *restricts* which computations you can express
08:53:17 <rostayob> ski: it doesn't restrict, it removes every possible computation on the ans
08:53:20 <zhasha> dbpatterson: being brand-spanking new to haskell, this might be a stupid suggestion, but isn't image resizing incredibly easy provided you have random access data structures?
08:53:24 <ski> (and so you can do more with each such computation, i.e. instantiating it at different `ans' types .. i'm not sure whether the code in that paper does that, though)
08:53:30 <byorgey> orbisvicis: sorry, by 'run' I meant run the outer monad to get an IO action
08:53:55 <ski> rostayob : it restricts in that you can't rely on `ans' being any type in particular
08:53:58 <byorgey> orbisvicis: so you want to type  'runReaderT b foo'  where foo is some sort of default MConfig value
08:54:14 <ski> @type cont . flip all  -- this relies on the answer type being `Bool'
08:54:14 <lambdabot> forall a. [a] -> Cont Bool a
08:54:21 <byorgey> orbisvicis: ghci knows how to run IO actions but it does not know what to do with ReaderT MConfig IO actions
08:54:21 <rostayob> ski: yeah but doesn't that render "ans" completely opaque?
08:54:24 <dbpatterson> zhasha: hmm. well I'm looking to resize PNGs and JPEGs and I don't know the file format and would prefer not to learn it, as it is pretty tangential to what I'm working on
08:54:35 <ski> you can't express that in `[a] -> forall ans. (a -> ans) -> ans'
08:54:55 <ski> rostayob : exactly, so you can do less with it, so it restricts what you can do
08:54:56 <tommd> glguy_: I'm here now...
08:55:10 <tommd> preflex: seen glguy_
08:55:18 <zhasha> dbpatterson: no matter how you look at it, you're going to have to put it through memory at some point. Maybe look for a library to load and save images and implement your own lanczos resizer (or similar)
08:55:24 <tommd> @preflex seen glguy_
08:55:24 <lambdabot> Unknown command, try @list
08:55:31 <rostayob> ski: that was clear from the beginning, I just can't see why they put it there, that's all :P. also considering that the Cont monad (which is kind of similar to that) doesn't use that
08:55:33 <tommd> grr
08:56:03 <tommd> glguy: I'm here for about 30 minutes.
08:56:41 <rostayob> ski: mhm. actually yeah I think I get why
08:56:45 <mauke> tommd: dude, tab completion
08:56:47 <glguy> tommd: I saw that Intel AES RNG library which had your name on it and I thought you might know off the top of your head what kind of AES performance you can get out of those intel instructions
08:56:55 <ski> rostayob : i don't know, but i'd expect either (or both) of (a) they want to disallow general continuation effects; (b) they actually want to instantiate `ans' to many different things (or calle-choose, which is more or less the same thing)
08:57:11 <tommd> mauke: Yeah, I was going by a msg from last night.
08:57:34 <tommd> glguy: Really good performance, but no - I have no numbers.
08:57:38 <tommd> glguy: Ask Ryan.
08:57:42 <rostayob> ski: I think that the point is that that continuation mechanism is all internal, and it just serves the purpose of writing the backtracking monad
08:57:46 <glguy> OK, thanks!
08:58:22 <ski> rostayob : i suppose that's another way to look at it
09:00:20 <rostayob> ski: also, they define that type in an absurd reason for some reason (or at least, it makes it harder for me to see what's going on)
09:00:44 <ski> rostayob : in my monad, i had `newtype Logic m o a = L (forall n p. ContStack m n => (a -> (o -> n p) -> n p) -> (o -> n p) -> n p)', and in this case the `forall' on `n' at least was essential
09:00:59 <rostayob> with two helper type synonyms (SK and FK, for the success/failure continuation)
09:01:18 <erus`> which programming language has the highest percent of successful and attractive users?
09:01:20 <ski> yeah, i think those `SK' and `FK' only makes it harder to follow
09:01:37 <rostayob> ski: yeah I think I can see now. thanks
09:01:48 <ski> erus` : would one with no users at all qualify ?
09:01:58 <rostayob> still, I still need some time to penetrate those types eheh
09:02:01 <rostayob> maybe it's just practice
09:02:04 <erus`> would that be 0% or inf% ?
09:02:23 <erus`> /0 error
09:02:26 <ski> well, it's unconstrained, so it's whichever you like, no ?
09:03:45 <ski> rostayob : anyway, i needed/wanted `n'-level continuations, to be able to implement my implication .. and the way i thought of to do that was to do a `forall' on the monad `n' there, relating it to `m' by a custom type class
09:04:16 <ski> rostayob : so, the caller would determine whether an action was to be a 2-level, or a 3-level, or a ... continuation monad
09:04:53 <ski> (here `m' is the base monad, in my case either `IO' or `ST s')
09:05:22 * ski suspects this makes no sense to rostayob
09:05:49 <rostayob> ski: eheheh wait a sec, I'm at work as well
09:07:02 <rostayob> ski: ok...
09:07:12 * ski . o O ( "Dependent Types at Work" by Ana Bove and Peter Dybjer in 2008-02 at <http://www.cse.chalmers.se/~peterd/papers/DependentTypesAtWork.pdf> )
09:08:00 <rostayob> ski: wait, where did dependent types come into play?
09:08:33 <rostayob> ski: if you have time, could you elaborate on that Logic type?
09:08:36 <ski> eheheh, i thought i'd heard the phrase "types at work" somewhere :)
09:09:09 <tromp> int-e i'm preparing a new tarball to put online
09:09:24 <ski> rostayob : the basic idea was that i wanted to implement a (useful) implication for my logic monad
09:09:29 <tromp> just testing all my examples
09:09:41 <ski> (in fact that was the thing motivating me to implement it at all)
09:09:54 <ski> rostayob : do you know Prolog ?
09:10:16 <rostayob> ski: yes
09:11:09 <rostayob> ski: first, what's the "ContStack m n"?
09:11:10 <ski> so, one can implement an (=>)/2 operator (called forall/2 for obscure reasons, in SWI), such that you can do e.g. `?- ( member(X,[2,3,5,7]) => prime(X) )'
09:11:34 <rostayob> ski: yeah I remember forall
09:11:42 <rostayob> the implementation was with \+
09:11:43 <ski> so you can use this to *check* (implicitly universally quantified) implications
09:11:47 <ski> indeed
09:12:10 <rostayob> forall(A, B) :- \+ (A, \+ B)
09:12:14 <ski> however, you can't use this to *compute* solutions (because of it being defined in terms of negation-as-failure)
09:12:19 <rostayob> yesw
09:12:21 <rostayob> *yes
09:12:26 <ski> so, i wanted to allow that
09:12:32 <coppro>  /win 2
09:12:49 <ski> the standard continuation monad here is a two-level one
09:13:14 <ski> but it turns out that to interpret `( Antecedent => Consequent )' i need *three* levels in `Antecedent'
09:13:16 <rostayob> ski: you're talking about Cont?
09:13:39 <ski> i'm talking about implementing a backtracking monad
09:14:07 <rostayob> ok but what do you mean with "level"?
09:14:35 <ski> and if i want to allow `( ( foo => bar ) => baz )' (and naturally i do), then i need *four* levels for `foo'
09:14:52 <ski> well, consider `(a -> ans) -> ans'
09:14:55 <tromp> maybe blc is not a good name for a programming language
09:15:01 <ski> this is one continuation level
09:15:10 <ski> @unmtl Cont ans a
09:15:10 <lambdabot> (a -> ans) -> ans
09:15:20 <ski> we can allow any base monad in there
09:15:26 <ski> @unmtl ContT ans m a
09:15:26 <lambdabot> (a -> m ans) -> m ans
09:15:31 <rostayob> yep
09:15:40 <ski> now, let's say the base monad `m' is also a continuation monad
09:15:52 <ski> @unmtl ContT ans0 (Cont ans1) a
09:15:53 <lambdabot> (a -> (ans0 -> ans1) -> ans1) -> (ans0 -> ans1) -> ans1
09:15:54 <tromp> i'm pondering alternatives like bitgolf, or lambdagolf
09:15:55 <ski> or
09:15:59 <ski> @unmtl ContT ans0 (ContT ans1 m) a
09:15:59 <lambdabot> (a -> (ans0 -> m ans1) -> m ans1) -> (ans0 -> m ans1) -> m ans1
09:16:08 <ski> this is a two-level continuation monad
09:16:25 <ski> basically what they have in that paper modulo the `forall ans. '
09:16:38 <ski> @unmtl ContT ans0 (ContT ans1 (ContT ans2 m)) a
09:16:38 <lambdabot> (a -> (ans0 -> (ans1 -> m ans2) -> m ans2) -> (ans1 -> m ans2) -> m ans2) -> (ans0 -> (ans1 -> m ans2) -> m ans2) -> (ans1 -> m ans2) -> m ans2
09:16:47 <ski> is then a three-level continuation-monad
09:16:50 <ski> ok ?
09:16:53 <rostayob> ok
09:17:05 <dbpatterson> is hackage messed up right now with bytestring? when I try to install packages I get this: cabal: Couldn't read cabal file "bytestring/0.9.2.0/bytestring.cabal" and on hackage (http://hackage.haskell.org/package/bytestring-0.9.1.10), that version is listed but when you click on it it 404s
09:17:28 <ski> so, to interpret `( Antecedent => Consequent )' as an action in a two-level continuation monad (for backtracking), i needed to interpret `Antecedent' in a three-level continuation monad
09:17:54 <ski> and if a left-nested implication more, i would need more nested levels of continuations
09:18:08 <rostayob> ski: ok, so that ContStack m n encodes the depth?
09:18:16 <ski> not quite :)
09:18:45 <ski> but i'd like to be able to use the same `foo' in `foo ==> foo' (in the Haskell embedding)
09:19:08 <ski> so i need a type that gives you `n' levels of continuations, for any level the *caller* wants
09:19:25 <ski> s/any level/any number of levels/
09:19:45 <hpc> ski: may want to try using Mu
09:19:48 <hpc> @src Mu
09:19:49 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
09:20:04 <ski> hpc : that wouldn't work
09:20:15 <ski> that gives an infinite number of levels, so to speak
09:20:25 <kowey> dbpatterson: see the recent mail on Haskell Cafe :-)
09:20:27 <ski> i also need a bottom level
09:20:38 <kowey> if you're on a Mac, use gnutar
09:21:03 <dbpatterson> kowey: thanks!
09:21:26 <ski> something like `newtype List t m a = Nil (m a) | Cons (List t (t m) a)' might be closer to what i wanted
09:21:28 <rostayob> ski: ok, I don't get how the type "gives you" that. the type tells you what it is
09:21:37 <kowey> and now if somebody else comes on #haskell and asks the same question, you can answer and we'll have a 4 person chain
09:21:47 <ski> anyway, i needed to ensure that i had access to mutable reference cells at the "bottom" level
09:21:53 <dbpatterson> kowey: will do! :)
09:21:58 <kowey> heehee
09:22:58 <ski> rostayob : i want a type which can be used as any of `ContT ans m a',`ContT ans (ContT () m) a',`ContT ans (ContT () (ContT () m)) a',&c.
09:23:14 <rostayob> ski: yep I got that
09:23:39 <rostayob> i can't picture such a thing
09:23:44 <rostayob> but ok
09:23:56 <ski> rostayob : the definition for `ContStack' i had was `class (Monad m,Monad n) => ContStack m n | n -> m where liftStack :: m a -> n a; trailedWriteRef :: MonadRef ref m => ref a -> a -> a -> (() -> (o -> n p) -> n p) -> (o -> n p) -> n p'
09:24:20 <ski> `liftStack' should speak for itself
09:24:51 <ski> i wanted to be able to update `IORef's/`STRef s's, in the base monad
09:25:12 <ski> but those updates should be backtrackable, so should restore the old value on backtracking
09:25:40 <ski> but the thing with these more-than-two-levels-of-continuations is that even backtracking can be backtracked :)
09:26:38 <ski> i have two instances for this type class, first a base case `instance Monad m => ContStack m (IdentityT m)'
09:27:02 <rostayob> ski: that's what you lift to?
09:27:02 <ski> that just calls `writeRef' twice in `trailedWriteRef' (write and undo write)
09:27:16 <ski> well, this is the base case
09:27:31 <ski> `instance ContStack m n => ContStack m (ContT q n)' is the recursive case
09:27:55 <ski> that extends a stacked continuation monad with one more level of continuations
09:28:35 <rostayob> no, you're losing me :P
09:28:48 <ski> so `IdentityT m' has zero levels, `ContT q (IdentityT m)' has one level, `ContT q (ContT q (IdentityT m))' has two levels, &c.
09:28:51 <rostayob> what is the "o" and the "p" in the definition of ContStack? did you forget a forall?
09:29:40 <rostayob> ah no
09:30:09 <rostayob> no this is to much you lost me :P
09:30:23 <ski> oh that, i suppose i could have said `ContT o (ContT p n) ()' instead, in the type for `trailedWriteRef'
09:30:34 <ski> (instead of `(() -> (o -> n p) -> n p) -> (o -> n p) -> n p', i.e.)
09:31:43 <ski> anyway, the main point is : i made a type class for expressing `n'-levels of continuation above a base monad, together with a lift operation, and an operation for trailed update to a reference cell
09:31:47 <rostayob> ski: I understand the concepts, but I really fail to see what you're doing here
09:32:11 <tromp> ok, int-e, new tarball online at http://www.cwi.nl/~tromp/cl/AIT.tgz
09:32:21 <ski> then, in `Logic' i make sure that the action stored inside it is *polymorphic* in the monad used, constrained only by `ContStack'
09:32:48 <ski> which means that any action you put in there must work regardless of how many continuation levels you actually want in the end
09:33:12 <rostayob> ski: for example why having () in ContT? Couldn't you create a type without the "a" in ContT?
09:33:52 <ski> oh, that was mostly convenience
09:34:22 <rostayob> ski: ?
09:34:25 <ski> i was experimenting a little with using something more interesting than `()' there, but i didn't finish that
09:34:27 <rostayob> to be able to reuse ContT
09:34:31 <rostayob> mh
09:35:20 <ski> yeah, note that at the "top level" i use `ContT o (ContT p) a'
09:36:27 <ski> so, when i need to "shift" that, to add another level, it's easier if i can just instantiate `p' to `()' to get `ContT o (ContT () n) a' then add another level around that to get `ContT o2 (ContT o (ContT () n)) a'
09:36:28 <ion> Ooh, Data.Label.Maybe seems nice. edwardk: Does Data.Lens.Template have something equivalent? That is, in data Foo = A { _a :: Integer } | B { _b :: Integer }, _a and _b are partial. Data.Label.Maybe provides safe lenses for them.
09:36:46 <ski> i suppose i'm not sure how to best explain it in words ..
09:36:59 <int-e> tromp: \p p (\x \y x) (\p p (\x \y x) (\x \y y))  (i.e., cons 0 (cons 0 false)) -- why does that print only one 0 when executed with uni.lam?
09:37:15 <int-e> tromp: and the new tarball still contains that (i+1) pattern in AIT.lhs
09:37:16 <edwardk> ion: i don't have partial lenses at this point
09:37:41 <ion> edwardk: ok
09:37:46 <edwardk> ion: partially because the laws are uglier and i haven't needed them
09:37:54 * hackagebot RepLib 0.5.1 - Generic programming library with representation types  http://hackage.haskell.org/package/RepLib-0.5.1 (BrentYorgey)
09:37:56 * hackagebot unbound 0.3.1 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.3.1 (BrentYorgey)
09:38:04 <edwardk> you need something like a (Store b :+: Id) comonad coalgebra
09:38:26 <edwardk> or Store :*: Id, i haven't checked
09:38:30 <roconnor> :+:
09:38:32 <rostayob> ski: i'm not sure, but i don't understand the types
09:38:39 <roconnor> are we talking about partial lenses?
09:38:43 <tromp> sounds like you got the old tarball
09:38:54 <rostayob> ski: like the type for trailedWriteRef
09:39:01 <int-e> tromp: I got a different than when I started today
09:39:05 <ski> rostayob : the main point was that by using `forall n.' in there, i could delay the choice on how many continuation levels are needed
09:39:08 <int-e> *different one.
09:39:24 <roconnor> edwardk: do you have transpose defined for representable functors somewhere?
09:39:25 <tromp> does it have new .lam files like primes.lam ?
09:39:34 <int-e> tromp: yeah
09:39:48 <ski> rostayob : the `ContStack' type class and its `liftStack' and `trailedWriteRef' operations are internal operations, that you don't need to *use* the logic programming monad
09:40:18 <tromp> oh, I see. i fixed the +1 pattern in another directory:(
09:40:52 <rostayob> ski: yeah but while this is about rank-n types, i'm not sure i see why it's related to my original questions
09:40:58 <rostayob> apart being about rank-n types as well :P
09:41:07 <ski> rostayob : let's say i'm excecuting an action `foo ==> bar', with `n+2' continuation levels, then my code would execute `bar' with `n+2' continuation levels still, but execute `foo' with `n+3' continuation levels
09:41:11 <ski> that was the goal
09:41:48 <ski> well, i see it more as being about polymorphic actions (/values) than about rank-n
09:41:58 <ski> certainly nothing more than rank-2 is needed here
09:42:01 <tromp> for the other question: uni *applies* the decoded lambda term on rest of input
09:42:12 <rostayob> ski: yes, I see the point of your Logic monad, you are going to change that type while computing stuff to add levels
09:42:20 <tromp> so you need to put extra \dummy in front
09:42:46 <int-e> tromp: ok, thanks
09:43:15 <ski> so, requiring the action to be polymorphic does two things (a) it restricts producers to only generate polymorphic data (naturally)
09:43:35 <ski> (b) it allows consumers to reuse the polymorphic data at different instances
09:43:51 <ski> the (a) is what forbids general continuation effects
09:44:17 <ski> (b) is what i needed, to be able to interpret an action with whatever number of continuations i wanted
09:44:49 <rostayob> ski: how can you actually "hit the bottom" with a type like that?
09:44:57 <ski> hehe
09:45:07 <ski> you just instantiate it to some concrete type
09:45:12 <tromp> ok, tarball now has the fixed AIT.lhs without i+1 pattern
09:45:13 <rostayob> "instantiate it"?
09:45:23 <ski> in my case, i instantiate the `n' to `IdentityT m' in my `run' function
09:45:39 <tromp> thanks for finding problems, int-e
09:46:17 <ski> like if you have `length :: forall a. [a] -> Int' and call it like `length [False,True]', then you "instantiate it" by setting the type variable `a' to `Bool'
09:46:27 <rostayob> ski: oh, right
09:46:45 <rostayob> this is weird
09:46:49 <ski> so i always set `n' to `IdentityT m'
09:46:55 <rostayob> do you actually have this code around somewhere?
09:47:15 <ski> i have it lying around somewhere
09:47:45 <ski> (i don't recall it being in a very polished state, though)
09:48:37 <rostayob> ski: but it's not currently public, right?
09:49:16 <ski> well, i've already showed it to two or three other people
09:49:31 <ski> but atm i don't have a good place to put it online
09:50:53 * ski smiles at the `-- This is probably wrong' comment
09:51:22 <rostayob> ski: ok, because usually reading the code helps a lot
09:53:26 <rostayob> ski: anyway thanks a lot
09:55:06 <ski> probably it would help to first understand a standard 2-level continuation monad for backtracking (and logic variables as well, i assume)
09:55:27 <ski> my version is an extra complication over that
09:56:04 <dsouza> hi everyone. I'm having a problem with cabal. The error is cabal: Couldn't read cabal file "bytestring/0.9.2.0/bytestring.cabal"
09:56:10 <rostayob> ski: yeah, where can I find an example of that?
09:56:32 <dsouza> I've managed to get around it by removing that specific version from from 00-index.tar.
09:56:43 <dsouza> does anyone know why this happened?
09:57:49 <dcoutts> dsouza: hmm, that's not good
09:57:51 <dsouza> btw, the error tiggers when I fire `cabal install <something>'. apparently any package triggers the error.
09:58:01 <dcoutts> dsouza: what does cabal --version say?
09:58:09 <ski> rostayob : hm, i'm not sure. i think i looked at various papers on continuation monads, like Hinze, and in particular Koen Claessen's "Typed Logical Variables in Haskell"
09:58:19 <dsouza> cabal-install version 0.10.2
09:58:20 <dsouza> using version 1.10.1.0 of the Cabal library
09:58:32 <dsouza> and for ghc:
09:58:37 <dsouza> 7.0.4
09:58:48 <ski> (rostayob : the code i did was for a project on an AFP class .. incidentally under Claessen :)
09:58:54 <dsouza> dcoutts: maybe bytestring cabal file got corrupted somehow?
09:59:22 <dsouza> I've tried to remove ~/.cabal too and it didn't help.
09:59:30 <rostayob> ski: oh ok! I don't know who claessen his but ok
09:59:43 <rostayob> ski: wait afp = advanced functional programming?
09:59:49 <ski> yes
09:59:55 <sm_> hi all, is tested-with:    GHC==6.12, GHC==7.0, GHC==7.2  good or is there a better way to spell that ?
10:00:03 <rostayob> ski: which university?
10:00:12 <ski> Gothenburg
10:00:28 <ski> (~= Chalmers)
10:00:28 <rostayob> ahhaha I'm working next to a guy that did the same course
10:00:40 <rostayob> a few years ago
10:01:02 <rostayob> we were talking about it at lunch, he said that it was hard, mostly about DSLs
10:01:26 * ski doesn't remember it as being *that* hard ..
10:01:37 <ski> but DSLs, yes
10:01:39 <rostayob> i think he said that lennart augusston was the lecturer
10:02:06 <ski> (and i'm forever confused about the terms "shallow embedding" vs. "deep embedding" thanks to that course)
10:02:27 <rostayob> ahahah he was saying the same thing. something about the difference in describing the problem with data types or with functions
10:02:46 <rostayob> the fp world is a small world
10:02:58 <rostayob> he doesn't like haskell anyway. he likes scala :P
10:03:05 <byorgey> sm_: if you have really tested with all minor versions of 6.12 and 7.0 then you can write  == 6.12.* and == 7.0.*
10:03:17 <byorgey> sm_: otherwise you ought to list the particular minor versions you have tested with.
10:03:24 <byorgey> oh, and same goes for 7.0 of course
10:03:28 <byorgey> *7.2
10:03:49 <sm_> byorgey: aha, thanks
10:04:03 <rostayob> ski: I asked because chalmers is the first uni I hear of with an "advanced fp" course
10:04:10 <rostayob> well mine doesn't have one for sure
10:04:27 <sm_> I guess few of us are going to test a release with every major & minor version
10:05:09 <ski> rostayob : i think Utrecht has one, as well
10:05:16 <byorgey> sm_: yes, that would be quite a feat
10:05:35 <byorgey> sm_: although it would be possible if you set up some automated testing process
10:05:37 <maurer_> Hey, is there an easy way to set up something like "deriving Storable" ?
10:05:44 <rostayob> maurer_: TH?
10:06:09 <rostayob> maurer_: there is no way to define something that works with the deriving syntax
10:06:09 <maurer_> rostayob: Specifically, I'm wondering if someone else has already written the requisite TH to do that, or whether I'd need to do so myself.
10:06:17 <sm_> yes I think you'd have to. Maybe hackage will incorporate a build farm at some point
10:06:45 <rostayob> maurer_: you mean something that peeks and pokes automatically?
10:07:16 <rostayob> maurer_: you could easily define a template haskell function to derive the instance
10:07:18 <maurer_> rostayob: Essentially, I want it to just sequentially invoke the storable instance on each member of the datatype in order to make it storable
10:07:19 <ski> Advanced functional programming course at Utrecht <http://www.cs.uu.nl/education/vak.php?vak=INFOAFP&jaar=2009>
10:07:40 <maurer_> rostayob: OK, I guess it's time to learn TH. I was hoping to avoid this >_>
10:08:02 <rostayob> maurer_: I don't know if it's there already, but if it isn't, either you use Data or TH
10:08:30 <byorgey> maurer_: I checked out derive and DrIFT, but it seems neither of them supports Storable
10:08:42 <byorgey> but you may want to look at extending one of those instead of starting from scratch
10:08:55 <rostayob> maurer_: but with Data you can't generate the instance
10:09:00 <maurer_> http://hackage.haskell.org/package/storable-record looks promising, I'm going to try it
10:09:14 <byorgey> maurer_: avoid learning TH as long as possible!
10:09:42 <rostayob> ski: cool
10:09:43 <maurer_> byorgey: I am primarily avoiding TH because I still look at macro systems (including TH) as a hack
10:09:55 <byorgey> someone had a problem and said "I know, I'll solve this with TH".  Now they have two problems.  ;)
10:10:00 <rostayob> :)
10:10:35 <kmc> people often want their Storable instance to line up with some C struct
10:10:45 <kmc> which is usually something you can't infer from the Haskell type directly
10:11:15 <edwardk> maurer: you can't make deriving, you can do a few things. one is you can use Hinze-style generics, so you can make most instances with just instance MyStorable
10:11:28 <edwardk> maurer: the other is you can make a TH function that defines your instances
10:11:29 <maurer_> kmc: Other than alignment, you should be able to
10:11:37 <rostayob> ski: anyway, I have to go now but thanks
10:11:45 <ski> rostayob : yw
10:11:55 <maurer_> kmc: Like, the C packing rules are pretty straightforward, making something which derived that should be possible.
10:12:38 <edwardk> maurer: http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/generic-classes.html
10:13:49 <kmc> edwardk, that stuff is deprecated in 7.2
10:13:53 <kmc> there's a new shinier mechanism
10:14:04 <edwardk> kmc: yeah i know it changed somehow but i haven't used the new version
10:14:36 <edwardk> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/generic-programming.html
10:15:14 <maurer_> Looks like it's time to upgrade my ghc then >_>
10:15:15 <edwardk> oh that is much better
10:15:51 <tromp> int-e, I just improved my primes program to 197 bits
10:17:06 * maurer_ reads up on the new version of generic programming
10:19:05 <int-e> tromp: 215 here atm.
10:19:23 <edwardk> kmc: i'd seen someone use the generic types for a pretty printer, but thats spiffy
10:19:32 <tromp> wow, you're good
10:20:23 <tromp> btw, what's your real name, int-e?
10:21:04 <monochrom> isn't that a bit personal? :)
10:21:09 <tromp> i'm assuming that's using trial division, rather than a sieve like in primes.lam ?
10:21:18 <tromp> yes, it is.
10:21:45 <tromp> i shld add, if you dont mind my asking:)
10:21:46 <maurer_> kmc: Do you think people would be interested in a C-like storable derivation? I'm wondering if this should be local to my private packages or whether I should make a new package that contains this
10:22:10 * edwardkmett makes obvious fact obvious.
10:22:18 <kmc> i think people would definitely be interested
10:22:23 <maurer_> OK
10:22:33 <maurer_> Like, I am dealing with lots of structs like
10:22:38 <int-e> tromp: it's actually a sieve.
10:22:51 <hpaste_> maurer_ pasted “sample struct” at http://hpaste.org/50659
10:23:11 <maurer_> Which are not particularly nice to deal with.
10:23:18 <dsouza> dcoutts: any ideas? I'm thinking it might be something with the cabal file itself inside the 00-index.tar. I'll take a look on this, it may help (also I don't know where else to look).
10:23:18 <maurer_> But which can be pretty easily inferred
10:30:47 <dmwit> Does Conor McBride ever come here?
10:31:01 <dmwit> That's not my real question.
10:31:09 <dmwit> What nick does Conor McBride use on IRC, if any?
10:33:55 <wires> pigworker?
10:34:19 <fryguybob> preflex: seen pigworker
10:34:20 <preflex>  Sorry, I haven't seen pigworker
10:34:49 <dmwit> Yeah, he goes by pigworker on Stack Overflow.
10:34:54 <dmwit> I'll just use that.
10:35:36 <dmwit> ?remember pigworker Keeping layout keywords at the end of line displays admirable horizontal thrift.
10:35:37 <lambdabot> It is stored.
10:35:56 <wires> try #agda
10:36:09 <wires> he pops up there every now and then
10:38:39 <rtharper> where do the foldr/build definitions of Data.List live these days?
10:39:02 <rtharper> They don't seem to be in the Prelude or Data.List on haskell.org
10:41:36 <ktosiek> rtharper: foldr is in GHC.Base
10:41:43 <rtharper> ktosiek: cheers
10:45:03 <k0ral> hi, I would like to perform a "map fun list" where list :: [Type1] and fun :: Class1 a => Type1 -> a, but it won't work since fun can output different types while a map can't afford containing elements from several types
10:45:37 <k0ral> what's the trick to get it working ?
10:45:38 <copumpkin> fun has the wrong type if that's what you're saying
10:45:55 <copumpkin> and if it has the right type, then there's no problem
10:46:14 <k0ral> well, it does complain so there is a problem
10:46:26 <copumpkin> fun :: forall a. Class1 a => Type1 -> a
10:46:30 <copumpkin> notice a problem there?
10:46:43 <k0ral> no but "map fun list" won't compile
10:46:51 <copumpkin> no, I'm saying the problem is there
10:46:54 <k0ral> ah
10:47:13 <copumpkin> that type says that for all types `a`, if you have a Class1 instance for `a`, you have a Type1 -> a function
10:47:23 <copumpkin> that means the caller gets to choose the `a`
10:47:26 <copumpkin> not the function
10:47:39 <copumpkin> if the function returns a specific instance of Class1 depending on Type1
10:47:49 <copumpkin> that's a different type
10:48:17 <k0ral> sorry man but I'm not following you, could you clarify it please ?
10:48:26 * ski . o O ( `cofun :: Type1 -> exists a. Class1 a *> a' )
10:48:57 <copumpkin> what you're trying to say
10:49:07 <monochrom> @let myfun () = 0
10:49:08 <lambdabot>  Defined.
10:49:12 <monochrom> @type myfun
10:49:12 <lambdabot> forall t. (Num t) => () -> t
10:49:15 <copumpkin> is that when provided with a Type1, the function will return "some instance of Class1"
10:49:26 <monochrom> > map myfun [(), (), ()] :: [Int]
10:49:26 <k0ral> yes
10:49:27 <lambdabot>   [0,0,0]
10:49:29 <monochrom> works
10:49:33 <dmwit> "map fun list" looks like it ought to work to me...
10:49:38 <copumpkin> it should, yeah
10:49:42 <dmwit> So if it's not working, it's the context you used it in that's broken.
10:49:43 <copumpkin> it's the fun that's broken, not the map
10:49:50 <monochrom> myfun is not broken
10:49:56 <k0ral> yes, I fed it with some data
10:49:57 <dmwit> fun is not broken
10:50:05 <copumpkin> yes it is
10:50:10 <k0ral> and in my data the "a" type varies
10:50:14 <copumpkin> according to his spec of how it works
10:50:21 <dmwit> k0ral: No, it doesn't.
10:50:23 <ski> k0ral : what is the type you expected `map fun list' to have ?
10:50:30 <dmwit> k0ral: The return type is [a] for some specific a.
10:50:32 <k0ral> Class1 a => [a]
10:50:39 <monochrom> @type map myfun [(), (), ()]
10:50:39 <k0ral> does it exist ?
10:50:39 <lambdabot> forall t. (Num t) => [t]
10:50:43 <dmwit> k0ral: Yes.
10:50:46 <dmwit> k0ral: No problem there.
10:50:55 <dmwit> k0ral: But keep in mind that *every element has the same type a*.
10:50:59 <ski> `forall a. Class1 a => [a]' is very different from `[exists a. Class1 a *> a]'
10:51:23 <k0ral> that's my point: here I feed fun with a list of elements that won't result in the same "a"
10:51:26 <dmwit> k0ral: If you're expecting it to return a list where each element can be a different type (but nevertheless one that implements the Class1 interface), then your expectations are broken.
10:51:39 <monochrom> you can't have different "a"s
10:51:48 <k0ral> I'm aware of that
10:51:53 <copumpkin> k0ral: my point is that with the type you gave it, your function doesn't get to choose what type it returns
10:51:55 <k0ral> read my question again
10:52:07 <ski> k0ral : `fun :: forall a. Class1 a => Type1 -> a' promises to return something of a type `a' which the caller will choose
10:52:14 <copumpkin> k0ral: what you want is an existential type
10:52:28 <ski> k0ral : `map fun list' will then return a list of type `[a]', where the caller will choose the (single) type `a'
10:52:29 <dmwit> k0ral: Your question is malformed. The input to the function doesn't choose the output type, the caller of the function chooses the output type.
10:52:40 <copumpkin> although many would argue that you don't actually want one, and are approaching the problem in an unidiomatic manner :)
10:52:47 <copumpkin> but strictly speaking, what you want is an existential type
10:52:54 <k0ral> actually, I just want not to write several lines of "fun element" by using map, but I can't find how to do this because of the several types it can generate
10:53:05 <monochrom> > (map myfun [()] :: [Int], map myfun [()] :: [Double])
10:53:06 <lambdabot>   ([0],[0.0])
10:53:11 <ski> k0ral : if you want the function `fun' itself to choose the type `a' (possibly depending on the `Type1' input), then you want `fun :: Type1 -> exists a. Class1 a *> a'
10:53:58 <monochrom> you are really better off writing several lines. that's right, even existential type doesn't save you for this purpose
10:54:05 <dmwit> (But that will be painful, because then you lose all the information about what 'a' is -- you are *only* allowed to use the fact that it implements Class1 functions.)
10:54:23 <ion> ski: Thanks for the clear explanation. Now i have some understanding of the difference between exists and forall. :-)
10:54:27 <k0ral> monochrom: that's kind of the answer I'm expecting
10:54:34 <monochrom> or else you could use TH or something
10:54:48 <ski> ion : note also the difference between `Class1 a =>' and `Class1 a *>' :)
10:54:53 <k0ral> in a few words: that's not possible
10:54:56 <k0ral> right ?
10:54:57 <ion> Yeah, noticed it.
10:55:23 <k0ral> ski: thought you misstyped the "=>" at first ^^
10:55:24 <solrize> aww, "type level multitasking" gets no google hits. :(
10:55:42 <ski> k0ral : you can do an existential, but since we don't have first-class such, you'll have to do a temporary data type for it ..
10:56:07 <ion> I take it the *> couldn’t be written as => but overloaded as the appropriate operator based on whether it’s with ‘forall’ or ‘exists’? Please excuse my ignorance. :-)
10:56:20 <k0ral> I don't know what is an existential, but from what was said formerly, I'm not committed to use them :)
10:57:06 <k0ral> however, I could still use "map fun list" as long as I know the generated "a"s are the same, right ?
10:57:15 <monochrom> yes
10:57:22 <k0ral> so I can at least partition my list into sublists of for the same "a"s
10:57:27 <monochrom> > map myfun [(), ()] :: [CReal]
10:57:28 <lambdabot>   [0.0,0.0]
10:57:31 <ski> k0ral : i.e. in practice, instead of doing `fun :: Type1 -> exists a. Class1 a *> a', you have to do `fun :: Type1 -> SomeClass1' with `data SomeClass1 = forall a. Class1 a => WrapClass1 a', which also can be written in GADT syntax like `data SomeClass1 where WrapClass1 :: Class1 a => a -> SomeClass1'
10:58:11 <ski> k0ral : yeah, iiuc that should be ok
10:58:23 <ion> How do you read the *> operator aloud?
10:58:24 <k0ral> ski: thank you for the explanation :)
10:58:31 <ski> (also see monochrom's helpful examples)
10:58:41 <ion> That is, what do i type into Google? :-)
10:58:44 <ski> ion : hum, i've never thought of that :)
10:58:48 <monochrom> oh no one cares what I say
10:59:15 <k0ral> monochrom: I do :)
11:00:10 <ski> ion : afaik, no system has implemented the `*>' syntax. it's something i've used here, to explain existentials together with the `exists' syntax (which iirc a few implementations support, at least to some extent)
11:00:35 <ski> k0ral : that's just what they all say !
11:00:38 <ski> ;)
11:01:19 <k0ral> :)
11:01:31 <monochrom> generally, the 3rd explanation you read is the best explanation
11:01:54 * k0ral scroll-up to find out the 3rd one
11:02:35 <k0ral> hmmm hard to say, that was a mess of help from all of you
11:03:30 <ion> I think i have some understanding of the difference between forall (the caller gets to decide the type) and exists (the callee gets to decide the type) but i still lack a proper understanding of the difference between => and *>, except for “the => but for exists instead”. =>: a restriction on what the caller can choose, *>: a restriction on what the callee can choose – and nothing more elaborate than that?
11:06:38 <ski> in `Foo a => ..a..', the caller has to provide the `Foo a' instance
11:06:43 <Cale> ion: I believe the idea is that, say, (Ord t) *> (t,t) is a pairing of a typeclass dictionary for Ord t with a pair of values of type t.
11:06:55 <ski> in `Foo a *> ..a..', the callee promises to provide the `Foo a' instance
11:07:03 <ion> aye
11:07:34 <maurer_> kmc: Still upgrading my ghc so I can play with the new generic stuff, but do you think it would be more suitable for the C storable instance to be separate, and if someone wants to use it as the cannonical storable instance, they wire it in?
11:07:46 <ski> (so, e.g. `forall a. Foo a *> ..a..' would probably not be very useful)
11:09:08 <elliott> ski: so (Foo a *> a) is (exists a. (Foo a) => a)?
11:09:31 <ski> not at all
11:09:40 <elliott> hmm
11:09:44 <ski> the first has `a' as a free type variable, to second doesn't
11:09:50 <maurer_> kmc: The main reason for doing this would be that I need to put in a "default" declarator to get this to work.
11:09:53 <elliott> touche :P
11:09:59 <ski> so they're not even comparable
11:10:08 <ski> ("Not even wrong !" :)
11:10:51 <ion> (a == b) == FileNotFound
11:12:35 <ski> i suppose `forall a. Foo a => Bar (T a) *> ()' could be useful, if it could be allowed
11:22:55 * hackagebot shelltestrunner 1.1 - A tool for testing command-line programs.  http://hackage.haskell.org/package/shelltestrunner-1.1 (SimonMichael)
11:24:19 <roconnor> @check \a b c -> ((a == b) == c)  ==  (a == (b == c))
11:24:20 <lambdabot>   "OK, passed 500 tests."
11:24:24 <roconnor> == is associative.
11:24:44 <ovrskr> @check 1 == 5
11:24:45 <lambdabot>   "Falsifiable, after 0 tests:\n"
11:24:49 <ovrskr> @check 1 == 1
11:24:50 <lambdabot>   "OK, passed 500 tests."
11:25:05 <elliott> Is there any documentation on using AccelGroups with Gtk2Hs? They are referenced in the Graphics.UI.Gtk.Windows.Window, but the type is unlinked, and it seems to only exist in a hidden module.
11:26:51 <kmc> ion, (=>) is like (->); (*>) is like (,)
11:27:20 <kmc> (C a) => T a  ===  Dict (C a) -> T a
11:27:30 <kmc> (C a) *> T a  ===  (Dict (C a), T a)
11:28:37 * ski . o O ( `data Dict cl where It :: cl => Dict cl' )
11:28:59 <elliott> ski: we need first-class classes :(
11:29:07 <elliott> the amount of times I've wanted a higher-order class...
11:29:09 <copumpkin> elliott: we will have them soon
11:29:15 <elliott> copumpkin: omg, is it christmas???
11:29:16 <elliott> tell me more
11:29:26 <ion> kmc: Thanks, that makes sense.
11:29:30 <erasmas> are there any recommended haskell libraries for https connections? I want to establish a connection, send .
11:29:41 <erasmas> send a post request with xml data, and possibly send another depending on the reply
11:32:42 <ski> elliott : we also need polymorphic classes and types ..
11:33:25 <elliott> ski: class (forall a. c (t a)) => Lift c t
11:33:27 <elliott> ski: one day.
11:34:56 <ski> elliott : ok, that's universal constraints -- another thing, but yes we want that as well
11:35:45 <erasmas> would Network.HTTP.Enumerator + any XML library be a good combo for https transactions of xml data? I want to make sure I'm not missing a good library that does both
11:35:45 <elliott> ski: it's a second-order class with a universal constraint :P
11:35:51 <elliott> ooh, ooh, existential constraints
11:35:57 <elliott> hmm, I guess you can already do that
11:37:00 <dcoutts> elliott: check the C docs on AccelGroups
11:37:01 <zong_sharo> why did derive extensions (traversable, typeable, etc) implemented as extensions, opposing to plain th library code?
11:37:27 <elliott> dcoutts: I did, but I'm unable to create an AccelGroup -- the obvious translation of the C function name, "accelGroupNew", doesn't seem to be in scope...
11:37:46 <ski> elliott : well, if we get constraint synonyms, then we probably want to have existentials in constraints as well
11:38:20 <dcoutts> elliott: sounds like they're missing from the binding, I doubt they'd be much work to add, I'm actually helping out with the next gtk2hs release so if you did a binding patch now you might be in time for the release
11:38:42 <elliott> ski: hmm, I guess my Lift would actually be more useful as "constraint Lift c t = forall a. c (t a)"
11:39:11 <elliott> dcoutts: I'll look into it, although I don't have much experience with the FFI and even less with Gtk2Hs :)
11:39:21 <elliott> dcoutts: Until then I guess I'll just use keyPressEvent and hack my own stuff
11:40:01 <dcoutts> elliott: it's pretty straightforward, copy & paste & edit
11:40:17 <dcoutts> unless there's anything quirky about AccepGroups
11:40:28 <elliott> dcoutts: they look pretty vanilla to me
11:43:05 <ski> elliott : by polymorphic classes, i mean something like a single `Functor' class, being polymorphic in what the source and target categories should be
11:43:27 <elliott> ski: hmm, how is that different to just taking two categories as typeclass parameters?
11:43:32 <ski> i'm not sure how to sensibly type the `fmap' operation in that, though
11:43:52 <ski> well, the categories would be kinds, instead of types
11:44:02 <ski> otherwise it's more or less the same
11:44:15 <elliott> dcoutts: but, hmm, do you know what the "expected" way to handle keybindings is with gtk2hs? I was under the impression that accelgroups were the standard thing for gtk...
11:44:18 <elliott> ski: ah
11:44:50 <dcoutts> elliott: yeah, accel groups were the new way to do it, added a few years back
11:45:01 <elliott> ah
11:45:05 <elliott> what's the old way? just keyPressEvent? :p
11:45:14 <dcoutts> honestly, I'm not sure
11:45:17 <elliott> heh
11:45:24 <dcoutts> I should find out, since I need it for ThreadScope too
11:48:03 <sm_> why would cabal install say Couldn't read cabal file "bytestring/0.9.2.0/bytestring.cabal" - https://gist.github.com/edfd1d771d7f541de788 ?
11:48:23 <Blackheart> Booyah.
11:51:06 <romildo> Is there any binary operator in the libraries that can replace fmap?
11:51:19 <elliott> romildo: Control.Applicative.(<$>)
11:51:21 <maurer_> <$>
11:51:21 * sm_ has ghc 7.0.4 on osx 10.6 and one bytestring-0.9.1.10 global package installed
11:51:40 <elliott> :t (<$>)
11:51:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:53:03 <ski> > even `fmap` Just 2
11:53:04 <lambdabot>   Just True
11:53:21 <kmc> @pl \f g xs -> any f xs && all g xs
11:53:21 <lambdabot> (. all) . ap . ((&&) .) . any
11:53:39 <erus`> if evolution is real then who wrote the bible? checkmate atheists
11:54:18 <elliott> spj
11:54:28 <Blackheart> If you want to troll, try #haskell-blah
11:55:00 <kmc> Blackheart++
11:55:06 <Blackheart> I will happily oblige you.
11:55:09 <qwertyuiop> hi, I'm probably being really stupid but I just can't get this to work - http://hpaste.org/50665
11:55:17 <erus`> what good is trolling a channel that doesnt mind trolling ?
11:55:24 <dcoutts> sm_: turns out, it's because older versions of the Cabal lib find an error in that .cabal file, but newer ones (including the one used by hackage) don't have a problem with it
11:55:38 * ski is for some reason reminded of <http://www.besse.at/sms/descent.html>
11:56:11 <sm_> dcoutts: thanks for looking. I have cabal-install 0.10.2/Cabal 1.10.1.0
11:56:45 <dcoutts> sm_: yep, I can reproduce it with Cabal-1.10. The bug was fixed in the 1.11 dev version, so is in 1.12
11:56:59 <erus`> qwertyuiop: line 11
11:57:08 <erus`> i think you mean = l
11:57:24 <mustelo> qwertyuiop, what's wrong with group . sort ?
11:57:29 <erus`> or not :|
11:57:44 <qwertyuiop> erus`, YES! thanks, spent about 30 minutes looking at this thing haha
11:57:55 <sm_> dcoutts: can I work around by cabal install http://darcs.haskell.org/cabal/cabal do you think ?
11:57:56 * hackagebot random 1.0.1.0 - random number library  http://hackage.haskell.org/package/random-1.0.1.0 (RyanNewton)
11:57:58 <erus`> concat l ?
11:58:04 <qwertyuiop> mustelo, nothing, I'm just trying to learn
11:58:09 <dcoutts> sm_: should be able to
11:58:13 <Peaker> qwertyuiop: you should avoid "head" in favor of explicit pattern matching in most cases
11:58:30 <sm_> hm, "data is not in tar format"
11:58:32 <mustelo> qwertyuiop, okay, sounds good. are you sure about the type of group?
11:59:04 <mustelo> your example makes me think you want myGroup :: Eq a => [a] -> [[a]] -> [[a]]
11:59:21 <mustelo> in which case erus`'s suggestion would be right on
12:00:03 <erus`> my first haskell answer :D
12:00:06 <qwertyuiop> mustelo, yup, thanks.
12:00:39 <hpaste_> Peaker annotated “asda” with “asda (annotation)” at http://hpaste.org/50665#a50666
12:00:44 <erus`> soon i will be answering questions on stackoverflow rather than asking 1 a day
12:01:20 <tromp> > 186/8
12:01:20 <lambdabot>   23.25
12:05:35 <hpaste_> mustelo annotated “asda” with “asda (annotation)” at http://hpaste.org/50665#a50667
12:05:51 <mustelo> qwertyuiop, there's my take on it, trying to stay as close to your ideas as possible
12:07:57 * hackagebot wl-pprint-terminfo 0.7.0 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.7.0 (EdwardKmett)
12:07:59 * hackagebot trifecta 0.35 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.35 (EdwardKmett)
12:09:04 <edwardkmett> that should remove the hscurses dependency and let the haddocks build for trifecta on hackage again
12:28:15 <Clint> what's the best way to extract the lines in a text file between two delimiters?
12:29:06 <mustelo> sed -n '/delim1/,/delim2/p'
12:29:28 * Clint sighs.
12:29:40 <mustelo> heh, I assume you wanted a haskell solution? :)
12:29:50 <Clint> did i really need to specify that?
12:30:42 <ion> runSed [sed|/delim1/,/delim2/p|]
12:30:43 <ion> ;-)
12:30:54 <fryguybob> Anyone know what is going on with this:  http://hackage.haskell.org/package/bytestring -- 404?
12:31:27 <sm_> dcoutts: I got around it by getting the cabal repo, installing both Cabal and cabal-install via Setup.hs - thx
12:31:40 <dcoutts> np
12:31:45 <ion> clint: What kind of text? What do you wish to do with the lines?
12:31:46 * dcoutts should make a cabal-install release
12:32:16 <Clint> ion: i wanna grab small YAML blocks out of larger text files and process only the YAML
12:32:32 <ion> How are they delimited?
12:33:04 <fryguybob> Similarly when I use cabal now I'm getting:  cabal.exe: Couldn't read cabal file "bytestring\\0.9.2.0\\bytestring.cabal"
12:33:28 <dsouza> dcoutts: thx, I'll try that.
12:34:20 <kmc> haha, a sed quasiquoter would be boss
12:34:51 <kmc> takeWhile p1 . dropWhile (not . p2) . lines <$> getContents
12:34:51 <mustelo> slippery slope: next up, perl
12:34:53 <kmc> something like
12:35:19 * edwardkmett frowns, there is no 'lines' in Data.ByteString.Lazy
12:35:25 <ion> .Char8
12:35:48 <edwardkmett> ah
12:35:49 <edwardkmett> thanks
12:35:57 <edwardkmett> makes sense i guess
12:36:01 <mustelo> Clint, you might also check out the split package. http://hackage.haskell.org/package/split
12:36:37 <kmc> noooooo Char8 :rageface:
12:36:42 <Clint> ion: in this specific case, they're surrounded by --YAML--
12:37:15 <ion> main = [php|<?php print("o hai" + 42 == False) ?>|]
12:37:20 * dsouza realizes his statement makes absolutely no sense :-)
12:38:53 <kmc> ion, i think the PHP embedding should take runtime strings, just so i can have a SQL injection vulnerability inside my PHP injection vulnerability
12:39:25 <ion> PHP can\'t have SQL injection vulnerabilities, it secures unsafe strings with magic quotes.
12:39:36 <Cale> ion: haha
12:39:39 <maurer_> Anyone know a way to include only the macro definitions from a C header?
12:39:48 <maurer_> I want to use PTRACE_O_SYSGOOD
12:39:54 <ebe_> eugh. DC
12:39:58 <maurer_> Without just manually copying the symbol over
12:40:08 <ebe_> Anyway, xmonad.errors doesn't have any content
12:40:19 <ebe_> I got disconnected if anyone said anything D:
12:40:33 <zong_sharo> maurer_: not possible
12:40:39 <maurer_> zong_sharo: OK :(
12:40:45 <maurer_> I'll just copy the constant then
12:40:55 <kmc> some headers have #ifndef __ASSEMBLY__ or whatever
12:40:59 <kmc> if not, you're screwed
12:41:18 * kmc . o O ( grep '^#' )
12:41:33 <mauke> maurer_: well, you could use something like hsc2hs, no?
12:41:39 <csabahruska> hi
12:41:50 <shachaf> maurer_: Didn't someone already make a Linux ptrace library for Haskell with all those constants copied over?
12:41:50 <maurer_> mauke: That seems like overkill for this?
12:41:51 <zong_sharo> maurer_: you'd better to include header, after all. generally speaking, magic numbers can vary from platform to platform and from version to version
12:41:58 <maurer_> shachaf: That library is usuper horrible.
12:42:13 <maurer_> zong_sharo: That's why I want to use the header >_>
12:42:31 <maurer_> *super horrible
12:42:45 <shachaf> #define might not be sufficient. What if the header uses an enum?
12:42:51 <shachaf> (I suppose it doesn't, though.)
12:42:51 <csabahruska> can i ask an important question? is the hackage working now? i've just run a cabal update and since than i constantly got this message: cabal: Couldn't read cabal file "bytestring/0.9.2.0/bytestring.cabal"
12:43:12 <maurer_> shachaf: Annoyingly, it does.
12:43:19 <maurer_> So the CPP trick was never going to work
12:43:37 <shachaf> Oh, they use an enum?
12:43:45 <shachaf> ptrace++
12:43:46 <maurer_> Yes, then manually define it
12:43:49 <Cale> csabahruska: what are you trying to install from hackage? bytestring?
12:44:00 <maurer_> shachaf: ptrace-- Oh my god what a horrible interface
12:44:05 <shachaf> Fair enough.
12:44:11 <shachaf> What's bad about the existing Haskell package?
12:44:22 <csabahruska> Cale: i've got this message no matte what i want install
12:44:27 <csabahruska> *matter
12:44:48 * ski wonders when edwardk grew a "mett"
12:45:01 <kmc> maurer_, i recommend compiling a C program that uses all the constants, then opening it with libbfd and reading the rodata section
12:45:04 <kmc> i'm only half kidding
12:45:05 <Cale> csabahruska: Okay, I'm just trying to install 'unbound', since it's a library I'm interested in checking out and seeing how that goes.
12:45:08 <ion> sysgood = [cc|#include <foo.h>\nvoid main () { printf ("%d", PTRACE_O_SYSGOOD); }|]
12:45:10 <monochrom> was "sudo cabal update" what you did?
12:45:11 <Cale> csabahruska: It seems to be working.
12:45:13 <maurer_> shachaf: No mass buffer data transfer, manually binds several calls which are already bound in the standard library (which can cause problems with newer IO engines) and a few other things.
12:45:25 <kmc> https://github.com/CentOS/ksplice/blob/master/kmodsrc/offsets.c
12:45:27 <csabahruska> Cale: did you run cabal update?
12:45:30 <zong_sharo> csabahruska: http://hackage.haskell.org/package/bytestring-0.9.1.10 worksforme, but http://hackage.haskell.org/package/bytestring-0.9.2.0 does not
12:45:31 <maurer_> kmc: Maybe I'll consider this if I consider the library to be worth releasing
12:45:46 <maurer_> kmc: My library is turning out (in my opinion) better than linux-ptrace, but that doesn't mean that it's any good.
12:45:56 <zong_sharo> csabahruska: can you just do cabal install bytestring-0.9.1.10 ?
12:45:59 <kmc> ok
12:46:01 <Cale> csabahruska: I hadn't, but I just did now and that succeeded.
12:46:02 <csabahruska> ok
12:47:41 <csabahruska> unfortunately cabal is fully dead, i cannpt install any package even bytestring-0.9.1.10
12:50:46 <chrisdone> @tell nominolo any interesting stats on the google analytics?
12:50:46 <lambdabot> Consider it noted.
12:50:52 <csabahruska> after full cabal db clean i run a cabal list and i've got this result: http://pastebin.com/Vy6vvHcn
12:50:56 <edwardkmett> csabahruska: i think dcoutts is hacking on that issue now
12:51:08 <csabahruska> ok
12:52:19 <fryguybob> csabahruska: Try cabal update again, I think they just removed the package that was triggering a cabal bug.
12:52:20 <dcoutts> csabahruska: try cabal update now
12:52:39 <fryguybob> dcoutts: Works for me now.
12:52:54 <dcoutts> ok good, sorry about that
12:53:30 <dcoutts> hackage checks that it can parse the .cabal file ok, however the problem here was that hackage is using a newer version of the Cabal lib which can parse that .cabal file
12:53:42 <dcoutts> and older release finds a spurious error in the file
12:53:48 <csabahruska> works :) thanks
12:56:14 <lispy> wow, this mailing list is in sad shape: http://www.haskell.org/pipermail/gui/
12:56:19 <lispy> It's just spam for months now
12:56:25 <dcoutts> not just months, years
12:56:28 <Cale> rofl
12:56:52 <dcoutts> it should be shut down really
12:57:54 <Cale> I wonder if it has any subscribers.
12:58:48 <tromp> > 167/8
12:58:49 <lambdabot>   20.875
12:58:57 <Cale> There are still three people getting digests...
12:59:11 <Cale> I don't know whether the other members are real or not.
12:59:19 <Cale> oh, Chris Done is on there
13:01:16 <lispy> I only looked at it because I was thinking I should be on there, but it doesn't actually seem to be relevant afterall
13:01:46 <Cale> lispy: You could join it to get all the same spam as the other people interested in GUIs in Haskell
13:02:39 <lispy> heh
13:02:59 <ion> GU1 L1BR4RIES @re waiting just FOR YOU
13:03:01 <Cale> How else are you going to have the latest deals on cheap azithromycin
13:04:07 <Cale> CH34P 4NT1BI0TIC5
13:05:17 <djahandarie> For a second there I thought viruses had started targetting people's IRC clients.
13:05:42 <Cale> haha
13:11:48 <Clint> mustelo: thanks, split is good enough
13:13:39 <maurer_> So, I'm probably just going to bind it internally, but in general, what are you supposed to do if a common syscall is bound incompletely (in this case waitpid) in the common libraries?
13:14:04 <maurer_> (In this case I want to access the SYSGOOD flag in a SIGTRAP value)
13:14:09 <kmc> fuck it, do it live
13:14:22 <gwern> maurer_: file a bug report and patch?
13:14:22 <erus`> is haskell the only pure language
13:14:23 <kmc> (not helping)
13:14:33 <erus`> (apart from theorem provers)
13:14:46 <kmc> erus`, it's not a sharp line.  Haskell has unsafePerformIO too
13:14:51 <kmc> Agda lets you call arbitrary Haskell code
13:15:05 <kmc> Haskell's "purity" is a matter of community norms and library design
13:15:17 <erus`> i havnt seen anything else like it
13:15:27 <Dashkal> "Safe Haskell"?
13:15:37 <kmc> Haskell is one of few languages to take the idea of purity seriously
13:15:39 <erus`> and it makes alot of sense, so i cant understand why others dont follow
13:15:45 <maurer_> gwern: Sure, but I need the function to continue with my development now. Say I file that patch--how am I supposed to continue? Depend on a nonexistent version of the package from my personal cabal repo?
13:16:02 <kmc> erus`, because it requires learning a new way to think
13:16:04 <Dashkal> Which reminds me.  How does GeneralizedNewtypeDeriving allow one to violate module visibility constraints?
13:16:04 <maurer_> "block on some dude because he made the package first" doesn't seem like a good idea.
13:16:09 <kmc> that's a hard sell
13:16:18 <maurer_> kmc: Is erus` actually saying something reasonable? I have him on ignore
13:16:20 <gwern> maurer_: do you control the environment such that you can simply run with your patched version? doesn't sound like a bad idea to me
13:16:20 <kmc> maurer_, include your own C stub for now?
13:16:27 <maurer_> kmc: That's what I'm doing for now.
13:16:29 <dcoutts> maurer_: using your local modified version of someone else's package is fine
13:17:03 <kmc> maurer_, i'd stick with that until the fixed lib is on hackage
13:17:20 <erus`> im famous? :)
13:17:26 <maurer_> OK.
13:17:33 * maurer_ patches unix
13:18:09 <Dashkal> You mean you didn't already?  You're running stock?!?
13:19:11 <maurer_> Dashkal: Was that directed at me?
13:19:23 <Dashkal> maurer_: Sorta?  Just being a smartass.
13:19:26 <maurer_> I am in fact running stock unix-2.5.0.0 >_>
13:20:01 <Dashkal> Seriously?  That's pretty cool.  I've only used the one *nix.  The 20 minutes with FreeBSD in a vm years back doesn't count.
13:20:11 <maurer_> Dashkal: No, the unix haskell package!
13:20:15 <Dashkal> ahh, ha
13:20:17 <Dashkal> ok
13:20:40 <maurer_> I'm running Gentoo at the moment though, so I'm still running a *nix
13:21:00 <kmc> think of the CFLAGS
13:21:03 <Dashkal> I should give that another try sometime.
13:21:13 <Dashkal> USE flags were the end of me last time
13:21:16 <maurer_> kmc: Certainly makes having a reasonable ghc easier.
13:21:21 <kmc> Dashkal, you should run Debian GNU/kFreeBSD
13:21:23 <Dashkal> I kept getting into states where upgrading would give compile errors
13:21:32 <maurer_> Dashkal: I don't reccomend gentoo as a starting Linux
13:21:38 <Dashkal> Not starting
13:21:46 <Dashkal> I'm old hat.  The one Nix is Linux
13:21:55 <chrisdone_> I accidentally opened a Carl Sagan YouTube video, now I'm trapped
13:21:56 <Dashkal> Lumping all my various distros into one
13:22:10 <Botje> gentoo is pure hate :[
13:22:20 <Dashkal> tomsrtbt -> redhat 6 -> gentoo -> debian -> ubuntu -> arch
13:22:22 <maurer_> Botje: No, you just need to know what you're doing
13:22:57 <Botje> maurer_: I've been running gentoo since 1.0_rc17 (2002ish)
13:23:11 <Botje> it is canned hate. in a can. with hate.
13:23:20 <maurer_> I did knoppix -> gentoo -> debian -> Ubuntu laptop/Gentoo Desktop/Debian servers -> Gentoo laptop/Gentoo Desktop/Debian servers
13:23:32 <maurer_> Botje: OK. I haven't had many problems with it as of late
13:23:35 <maurer_> Other than when I did a stupid
13:23:40 <maurer_> (unmasked the new gcc
13:23:57 <maurer_> Which miscompiles grub!
13:23:58 <maurer_> And I wasn't slotted >_>
13:23:58 <maurer_> So it removed the old one
13:23:58 <Botje> I fondly remember the time when they unmasked 2.0 and immediately remasked it
13:23:58 <Dashkal> I mostly prefer arch to gentoo because arch provides me with what I wanted gentoo to be: bleeding edge with binaries
13:23:58 <RichardBarrell> Botje: if so then _why_ are you _still_ running it? oO
13:24:18 <Botje> RichardBarrell: that box runs a bit over 90 websites
13:24:26 <Botje> + dns + mail + who knows what else
13:24:30 <chrisdone_> Dashkal: doesn't stuff break all the time?
13:24:30 <Dashkal> gentoo as a production server?  *fear*
13:24:31 <RichardBarrell> Right, that would do it.
13:25:13 <ktosiek> wait, so gentoo isn't a toy distro?
13:25:14 <Dashkal> chrisdone_: Not really.  "bleeding edge" in a distro sense.  So I get stable releases of my packages, not betas (unless I ask for it)
13:25:29 <Dashkal> Just not Ubuntu/Debian level integration testing
13:26:28 <ktosiek> Dashkal: is AUR still a mess? I like PKGBUILDs way more than debians, but I like not having to package things myself best :-)
13:26:35 <Botje> https://bugs.gentoo.org/show_bug.cgi?id=375745 # this is the pinnacle of gentoo quality assurance.
13:26:44 <ktosiek> *debians way of packaging
13:26:59 <Dashkal> ktosiek: There are AUR helpers that are completely transparent.  So you can see the AUR as just another package source
13:27:03 <Botje> I report a bug with a possible fix, the guy goes 'oh yeah those patches have been causing problems, we're kicking them out soon'
13:27:34 <Dashkal> I chose to keep that visibility.  Keeps me responsible for my system's stability when I'm forced to care if it's an AUR package or in an official repo
13:27:35 <maurer_> ktosiek: Everything may be always on fire, but you can do things like chose to build the latest checkout of something via -9999
13:27:41 <maurer_> Which is something you can't really get anywhere else
13:28:04 <Dashkal> which reminds me, time to check my aur packages
13:28:20 <kmc> anyone here use NixOS regularly?
13:28:32 <ktosiek> Dashkal: well, like this french tool with unmemorable name - but when I was using Arch half of AUR was broken :-)
13:28:40 <kmc> it's the only distro i've seen which is interestingly different enough that I might switc
13:29:20 <maurer_> I mean, the only reason I'm back to gentoo is because ubuntu grew enough magic that if somethign exploded, I could no longer track down and fix the explosion quickly
13:29:31 <maurer_> Gentoo has more explosions, but they are smaller, and generally fixable
13:29:32 <Dashkal> ktosiek: My experience with AUR packages has been decent.  Be sure to check the comments before using a package, and do comment if things go south for you.
13:29:45 <Dashkal> maurer_: That's exactly what drove me to arch
13:29:49 <maurer_> Dashkal: That's my other problem with arch
13:29:58 <maurer_> You are installing untrusted binaries
13:30:04 <Dashkal> maurer_: Then don't use the AUR?
13:30:13 <maurer_> Dashkal: Then you lose your bleeding edge?
13:30:15 <ktosiek> maurer_: no you don't?
13:30:23 <Dashkal> You can do an emerge world style compile yourself if you like
13:30:30 <ktosiek> packages in AUR come with PKGBUILD script
13:30:41 <kmc> maurer_, "untrusted binaries"?  you audit all the C code you compile in Gentoo?
13:30:45 <Dashkal> mmm, that too.  AUR packages aren't binary
13:30:48 <kmc> and you bootstrapped the C complier by hand?
13:30:53 <ktosiek> and they are pretty simple for most packages
13:31:01 <maurer_> kmc: No, I don't, but it's harder to hide things in source than in binary.
13:31:11 <kmc> not by very much
13:31:14 <Dashkal> Usually they're a quick wrapper around the standard configure/make/make install
13:31:25 <kmc> and source backdoors persist much longer / have wider scope
13:31:46 <Dashkal> Unless teh PKGBUILD is for a binary only product, but you deal with that or don't as normal
13:31:47 <maurer_> Dashkal: If they're source packages, you don't have the binary advantage you claimed earlier...
13:32:05 <Dashkal> maurer_: The binary advantage is that evertything is built the same.  no USE flags
13:32:26 <Dashkal> But this is mnostly a non-issue.  I have maybe 6 AUR packages installed total.
13:32:31 <maurer_> kmc: True. I'm not saying it makes you invincible, but while _I_ may not have audited the C code, someone might do it
13:32:34 <Dashkal> And nothing core
13:32:39 <maurer_> kmc: You're not going to find people auditing binaries
13:32:41 <ktosiek> maurer_: core system is available as binary, AUR (real community repo) is more like Gentoos emerge
13:32:49 <Dashkal> ^^
13:32:50 <kmc> i know people who audit binaries :)
13:32:56 <kmc> but, i agree in general
13:32:59 <kmc> about the direction of this effect
13:33:02 <maurer_> kmc: Well, yes, but there are many fewer of them.
13:33:04 <kmc> i just don't think it contributes all that much
13:33:11 <maurer_> I also have audited binaries, it is not fun.
13:34:00 <maurer_> kmc: Also for popular programs, you get a sort of "peer review" of the code before it gets into the tree
13:34:10 <maurer_> Which you don't have gauranteed for most binary things (like ubuntu ppas)
13:34:17 <tromp> > 1280%720
13:34:18 <lambdabot>   16 % 9
13:35:05 <kmc> i'd be curious to see some stats about past occurrences of things being backdoored
13:35:08 <Botje> I wonder who came up with the idea of squaring the 4:3 aspect ratio
13:35:31 <maurer_> kmc: I don't know what the actual rates are.
13:35:46 <maurer_> What I do know is that I could ship a backdoored mplayer in a ppa and get an install  base
13:35:56 <maurer_> But couldn't get that backdoor into the mplayer source tree as easily
13:36:33 <maurer_> More amusingly, PPAs don't have a scope :P
13:36:37 <kmc> http://stalkr.net/files/unrealircd/Unreal3.2.8.1-vs-Unreal3.2.8.1_backdoor.diff
13:36:57 <maurer_> Which means that you can say, provide one package for a while, which may be known good
13:37:13 <maurer_> Then decide to ship something that clobbers a suid root binary
13:37:19 <maurer_> Or in general rootkits the system
13:37:28 <maurer_> And it won't bitch
13:37:29 <Dashkal> Who would have thought.  Forgetting about a mythtv install eventaully leads to a filled drive
13:37:49 <Dashkal> one DROP DATABASE mythconverg; later...
13:40:06 <dixie> haskell brevity is not only good for less lines of code but also for fast removal of it :)
13:40:51 <Botje> yes, but nuking 500 lines of java just feels *right*
13:41:39 <maurer_> kmc: I mean, that should have been caught, I agree
13:41:44 <maurer_> I don't know why they let that in
13:42:25 <kmc> i mostly just provide this as an example of a not even very well hidden backdoor
13:42:31 <kmc> which is still kind of tricky to spot out of context
13:43:16 <maurer_> He called fucking system. How did they not see that?
13:43:28 <Botje> give it a believable commit message ..
13:43:50 <Botje> "log out-of-bounds reports from peer servers (temp commit)" or somesuch :)
13:45:05 <maurer_> Botje: Don't they read the source though?
13:46:35 <mister_m> When you define functions, do you always have to supply a class constraint? Or is that only when using type variables?
13:47:04 <Botje> maurer_: only if your type variables use functions that belong to a type class
13:47:05 <monochrom> no. no. iff a class constraint is necessary.
13:47:56 <Botje> maurer_: there are teams where everyone has his/her own portion of the code
13:47:57 <ktosiek> only when compiler shouts at you
13:48:00 <ktosiek> :-)
13:48:12 <monochrom> that is a good criterion
13:53:24 <maurer_> Is there any way to tell cabal to ignore version upper bounds?
13:54:52 <dcoutts> maurer_: only by editing the .cabal file in question
13:54:56 <maurer_> :(
13:54:59 <maurer_> That's a _lot_ of cabal files
13:55:10 <ktosiek> is there a `div` that always rounds up?
13:55:30 <ktosiek> that is, integral division
13:55:33 <dcoutts> maurer_: or just don't upgrade to the bleeding edge release of ghc before the Haskell platform is released
13:55:55 <maurer_> dcoutts: I want to use the new version of generics in ghc 7.2
13:56:22 <dcoutts> fair enough
13:57:08 <maurer_> Alternately, is there a way to manually tell it to use a specific version of base?
13:57:08 <Botje> ktosiek: (x + (n-1)) `div` n  ?
13:57:28 <maurer_> It looks like 4.3.1.0 would be valid, but it doesn't want to use anything but 4.4.0.0
13:58:01 <ktosiek> Botje: thanks, I'll name it something myself then
14:11:53 <maurer_> Hm, interestingly, the git version of unix does not build at the moment due to importing System.Posix.Types from base, where base is not a trusted package >_>
14:12:28 <maurer_> (at least against 7.2, no idea about ghc head, maybe it magically makes safety work at a per-module level)
14:14:52 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg92754.html explains the error message with cabal-install and bytestring-0.9.2.0
14:17:58 * hackagebot activehs-base 0.2 - Basic definitions for activehs  http://hackage.haskell.org/package/activehs-base-0.2 (PeterDivianszky)
14:22:59 * hackagebot activehs 0.2 - Haskell code presentation tool  http://hackage.haskell.org/package/activehs-0.2 (PeterDivianszky)
14:26:03 <tgeeky> noice
14:42:35 <DrTeggy> Happy birthday.
14:44:11 * tgeeky looks left, looks right
14:57:02 <monochrom> perhaps he/she refers to #haskell's birthday. but that's still a few days away
14:57:47 <monochrom> oh, nevermind, I misread "Apr 30" as "Aug 30"!
14:58:07 * cmccann would like to note that Haskell's birthday is in fact September 12th
14:58:48 <cmccann> though it feels awfully familiar to refer to the late Dr. Curry by his first name that way ;]
14:58:54 <tromp> > 355/8
14:58:55 <lambdabot>   44.375
15:01:47 <DrTeggy> No, it is my birthday. ;-)
15:03:09 <shachaf> DrTeggy: Happy birthday!
15:03:23 <DrTeggy> Thanks.
15:03:49 <shachaf> (#haskell-blah, by the way. :-) )
15:04:20 <tromp> > 1022/8
15:04:21 <lambdabot>   127.75
15:07:59 <elliott> Is there any way to go from a (Signal object callback) in Gtk2Hs to its corresponding SignalName? (And is there a more appropriate place to ask Gtk2Hs questions? I couldn't find any IRC channel mentioned on its website.)
15:17:14 <monochrom> no, I don't think you can get the SignalName
15:17:21 <chrisdone> https://picasaweb.google.com/105737414684902871009/Zurihac#5451091230776684594
15:17:26 <chrisdone> who is the dude in the middle with the sandwich?
15:18:25 <elliott> monochrom: Yeah, seems not. And there seems to be no way to trace a signal handler ID back to a signal ID -- if I could do that then I could achieve what I want by just FFI-importing the few functions I need, I think
15:18:28 <elliott> Unfortunate.
15:26:07 <int80_h> hey I've built a 3 layer monad transformer. At the top is an ErrotT, then a ReaderT, then StateT, wrapped in IO. I'm just learning how to use transformers and am second-guessing my choice to put the ErrorT at the top. Does it make more sense to have ReaderT, StateT, ErrorT? I'm thinking this would be better as I'm imagining exceptions travelling up the stack until they finally hit ErrorT and I do something with it. Am I on the right track
15:26:44 <kmc> @unmtl ErrorT e (ReaderT r (StateT s IO)) a
15:26:44 <lambdabot> r -> s -> IO (Either e a, s)
15:26:56 <ddarius> The choice of where to put it depends on the semantics you desire.
15:27:44 <kmc> @unmtl ReaderT r (StateT s (ErrorT e IO)) a
15:27:44 <lambdabot> r -> s -> IO (Either e (a, s))
15:27:58 <kmc> i think you want the latter
15:28:15 <kmc> given a reader environment and a state, do IO to produce either an error, or a result and a new state
15:28:30 <int80_h> yeah!
15:28:42 <kmc> yeah, @unmtl is useful
15:28:43 <kmc> however, i'm pretty skeptical of monad transformers in general
15:28:56 <int80_h> kmc: what? why?
15:29:13 <kmc> i feel you don't gain much, versus just writing the monad you want and then using it
15:29:15 <cmccann> monad transformers are an express ticket into an endless pit of despair
15:29:28 <cmccann> they add more obscurity than utility in many cases
15:29:37 <kmc> yeah
15:30:04 <cmccann> the whole point is to let one monad screw with another monad's behavior, and funny thing is that's what actually happens
15:30:05 <kmc> either way (transformers or roll-your-own) i'd keep that isolated to one part of the library, newtype it, and expose only domain-specific primitives to the rest of the code
15:30:08 <cmccann> except not always in the way you expect
15:30:09 <mm_freak_> int80_h: if your monad becomes very complicated, you may consider writing your own…  also large transformer stacks indicate that there may be a totally different abstraction than monads, which may work better
15:30:14 <int80_h> kmc: hmm I can imagine my problem in terms of a transformer stack, but not in the way you suggest. Can you give me an illustration to help me visualize what you are talking about?
15:30:16 <kmc> if all your code is using lift lift lift lift lift, it's a nightmare
15:30:33 <int80_h> ah
15:30:35 <aavogt> you usually don't need lifts with mtl
15:30:45 <mm_freak_> in any case, having the IO monad there is usually little reason to have a separate ErrorT, most notably because the outer ErrorT will not catch your IO exceptions
15:30:56 <kmc> newtype Int80H'sFantasticMonad a = MkM (R -> S -> IO (Either E (a, S)))
15:31:04 <kmc> instance Monad Int80H'sFantasticMonad where ...
15:31:21 <kmc> aavogt, yeah
15:31:23 <int80_h> ah!
15:31:26 <aavogt> there are a whole bunch of instances like:    instance MonadReader m r => (StateT s m)
15:31:30 <kmc> of course if you try to have two StateT's in the same stack, all hell breaks loose
15:31:45 <int80_h> I won't do that
15:31:48 <hpc> orly?
15:31:59 <int80_h> I only have one!
15:32:04 <aavogt> kmc: do you really need to access the inner one?
15:32:12 <mm_freak_> kmc: not always…  multiple StateT can come from combining multiple, independent parts of your code
15:32:40 <aavogt> (if you do, then maybe you can change it to   StateT (s1,s2) )
15:32:46 <kmc> that's why i'd rather newtype the stack and not derive MonadState
15:33:24 <mm_freak_> i think i haven't used monad transformers lately
15:33:36 <int80_h> this is my first try
15:33:45 <mm_freak_> i used to make heavy use of them
15:34:02 <roodyPro> hai gays
15:34:06 <roodyPro> hows it going
15:34:10 <roodyPro> anybody here
15:34:11 <mm_freak_> sometimes having well up to five monads in a single stack
15:34:12 <roodyPro> heloooooooooooooo
15:34:18 <kmc> @where ops
15:34:18 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:34:23 <kmc> the attitude i got as a beginner was "you aren't clever enough to write your own monad! use our friendly building blocks instead"
15:34:30 --- mode: ChanServ set +o glguy
15:34:31 <kmc> and the reality is entirely the opposite
15:34:32 <mm_freak_> ContT + StateT + ReaderT + MaybeT + …
15:34:44 <glguy> kmc: What's up?
15:34:47 <cmccann> kmc, which is funny since monad transformers are harder to use than making your own :]
15:34:51 <kmc> exactly
15:34:53 <int80_h> When I started this project 9 months ago, I didn't understand monads, let alpone transformers. So my code, where I should be using them, doesn't. Now I'm working on a different part, transformers seem perfect for what I want. And now I realize how the other parts of my program need to change and I'll have to do a re-write.
15:34:57 <kmc> brb
15:35:05 <mm_freak_> cmccann: i don't agree
15:35:12 <aavogt> @hackage monadLib -- have you seen this kmc?
15:35:13 <lambdabot> http://hackage.haskell.org/package/monadLib -- have you seen this kmc?
15:35:17 <kmc> no
15:35:22 --- mode: glguy set -o glguy
15:35:29 <kmc> sorry for the false alarm
15:35:34 <kmc> looks like the problem took care of itself :)
15:35:38 <mm_freak_> cmccann: i can totally understand people having a ReaderT or ContT or both on top of IO
15:35:43 <cmccann> mm_freak_, not in all cases, yeah
15:35:44 <glguy> kmc: That's the best kind of problem
15:35:49 <Cale> kmc: Yeah, monad transformers are convenient when you can get them, but I don't feel that they're terribly appropriate for beginners to use.
15:36:04 <kmc> aavogt, what's special about it?
15:36:21 <Cale> Especially as it requires a fair amount of "wisdom" to know when monad transformers are not just going to make your code much uglier without providing much benefit.
15:36:23 <cmccann> putting one or two very distinct transformers on top of something like IO makes sense to me
15:36:30 <aavogt> maybe I'm thinking of another library, but supposedly somebody has had a go at choosing the 'correct' ordering
15:36:33 <aavogt> of the transformers
15:36:35 <kmc> every monad should be ContT IO
15:36:36 <Cale> Putting ContT over IO makes sense to me.
15:36:44 <Cale> Putting StateT over IO is usually bad
15:36:45 <mm_freak_> aavogt: that's the monadLib, yes
15:36:47 <int80_h> Cale: I can spend a week figuring out if I'm right or not.
15:36:48 <kmc> that way your time travel is observable
15:37:02 <Cale> Putting ReaderT over IO is sometimes okay, but often worse than parameter passing
15:37:29 <mm_freak_> kmc: if you want ContT over everything, use the contstuff library…  it's a monadLib-inspired CPS-based transformer library
15:37:42 <int80_h> Cale: ah, I was envisioning what my code looked like if I did paramter passing. I shuddered.
15:38:26 <cmccann> Cale, I like ReaderT + IO/ST/STM/etc. as a way to make a shared environment of mutable references available, when that's what the code actually needs (which it usually isn't)
15:38:30 <int80_h> *would* look like
15:38:32 <Cale> int80_h: It's usually not terrible. If you bundle things together appropriately, it's typically just fine.
15:38:58 <Cale> Just be sure to make a datatype with fields for the various references that you need.
15:39:08 <Cale> OR
15:39:14 <int80_h> yes yes?
15:39:38 <Cale> apply  readIORef/writeIORef to the references ahead of time, and pass the resulting functions around instead of the IORefs
15:39:43 <mm_freak_> OR
15:39:47 <mm_freak_> use FRP ;)
15:39:54 <ddarius> glguy: That's what I always say about things like overpopulation and global warming.
15:39:54 <Cale> Which gives you control over what has read and write access to the state
15:40:32 <Cale> and in addition to that, gives you control over the semantics of reading and writing the state -- for example, you can turn the IORef into a Chan or SampleVar if that suits you better in the future.
15:40:43 <mm_freak_> Cale: i wonder if you can have the same control with a variant of StateT using rank 2 types
15:40:45 <Cale> and the types of things don't have to change
15:41:23 <ddarius> We need a good CML-style library.
15:41:33 <Cale> We have a CML style library
15:41:42 <Cale> but the implementation is horrendous
15:41:55 <int80_h> Cale: can you give an example of what applying readIORef/writeIORef looks like?
15:42:03 <Cale> The interface is fine, though it contains things which I don't understand why you'd ever want them
15:42:08 <cmccann> int80_h, just normal partial application
15:42:10 <Cale> r <- newIORef foo
15:42:12 <mm_freak_> StateT (forall s. (s, m s, s -> m ())) m a
15:42:18 <kmc> :t do { r <- newIORef 3; return (readIORef r) }
15:42:19 <int80_h> oooh!
15:42:19 <lambdabot> Not in scope: `newIORef'
15:42:19 <lambdabot> Not in scope: `readIORef'
15:42:21 <Cale> something (readIORef r)
15:42:27 <cmccann> instead of an IORef and writeIORef, you end up with a function like (String -> IO ()) or whatever
15:42:34 <Cale> forkIO (somethingElse (writeIORef r))
15:42:40 <cmccann> an opaque sink with the same type as something like putStrLn etc.
15:42:49 <Cale> (imagining a concurrent program there)
15:43:01 <Cale> Of course, you can do it just as well without concurrency
15:43:07 <cmccann> Cale, shouldn't that be a TVar then :P
15:43:12 <cmccann> or whatnot
15:43:14 <Cale> cmccann: *maybe*
15:43:26 <Cale> Sometimes you don't want or need locking of any sort.
15:43:34 <Cale> It depends
15:43:39 <cmccann> of course
15:43:53 <int80_h> well when I'm ready to make this concurrent I will def. need locking.
15:44:04 <Cale> Once you have concurrency, there are lots of possible semantics you may want for reads and writes, and this method will make them all look the same to the clients of the mutable state.
15:44:05 * cmccann wouldn't use no locking at all as the default example though
15:44:27 <ddarius> I'm aware of this.  Hence the "good."  I, ideally, want a CML-style library that could be used without thought (i.e. is trustworthy) and is wired up to the main event sources, in an efficient manner.
15:44:31 <Cale> You could just as easily do this with an MVar or a Chan or a TVar
15:45:04 <int80_h> Cale: I thought about using an MVar. It seemed to me I was using the wrong thing for this task and I ended up going the transformer stack way
15:45:16 <cmccann> Cale, though with IO you'd lose the STM aspect for those. But that'd still be easier to change later than passing an IORef directly
15:45:26 <ddarius> I did make my own synchronous channel library with a bidirectional select, but the select function is filled with evil.
15:45:27 <Cale> ddarius: I think that whoever wrote the existing CML library wasn't fully aware of the existing concurrency primitives available in concurrent Haskell.
15:45:31 <ddarius> It works pretty well though.
15:45:43 <int80_h> But you're saying that MVars and TVars are also an option.
15:46:20 <Cale> int80_h: Sure. If you're in IO, try to use all the stuff that IO provides you before going and transforming the monad.
15:46:25 <int80_h> with MVars I didn't like how you had to empty it to extract whatever value you wanted. I need something that will hold a state, even if I extract some data out of it.
15:46:54 <aavogt> @hoogle readMVar
15:46:54 <lambdabot> Control.Concurrent.MVar readMVar :: MVar a -> IO a
15:46:59 <Cale> int80_h: Maybe you *do* want an IORef :)
15:47:36 * copumpkin commences the most ugly hack ever in a foreign library binding
15:47:59 <Cale> Note that writeIORef is at least somewhat atomic in that you'll never see a half-written value in an IORef.
15:48:28 <bos> An IORef is completely atomic
15:48:43 <cmccann> IORef has fine-grained atomicity guarantees, in that the only guarantees you get are for very fine-grained operations
15:48:56 <int80_h> Cale: How would I do exception handling then? I only know about ErrorT.
15:49:13 <Cale> int80_h: The IO monad has exceptions too.
15:49:19 <Cale> See Control.Exception
15:49:27 <Cale> You can define new types of exceptions and throw them.
15:49:51 <int80_h> Ah. I largely went the transformer stack route because I only knew about ErrorT
15:49:57 * cmccann doesn't really like errors that aren't marked in the type signature :[
15:50:09 <Cale> Transforming the IO monad is usually pointless except to add continuations. I actually think the IO monad should have first class continuations too, just to be complete.
15:50:28 <aavogt> @hackage explicit-exception
15:50:28 <lambdabot> http://hackage.haskell.org/package/explicit-exception
15:50:59 <Cale> Transforming the list monad or some other nondeterminism monad though can be quite useful and interesting.
15:51:01 <sm_> I'd like to make a safe version of getDirectoryContents, returning [] on any error. Is `catch` (\_ -> return []) the right way ?
15:51:10 <Cale> StateT over list is one of my favourite monads.
15:51:58 <Cale> sm_: If you're using the new exception library, that'll be  `catch` (\(SomeException e) -> return [])
15:52:21 <monochrom> I want first-class continuations for IO too.
15:52:27 <cmccann> aavogt, yeah, but I tend to fall back on Either and the like just because I'm familiar with using those, even when working in IO :T
15:52:31 <hpaste_> ddarius pasted “O(n) threads, because you can” at http://hpaste.org/50670
15:52:36 <Cale> Though, what kind of error can you get from getDirectoryContents that would reasonably be handled by giving an empty list?
15:52:39 <kmc> i want first-class continuations for pure haskell code :)
15:52:43 <aavogt> this would also work (or are there other exceptions?):   \d -> do b <- doesDirectoryExist d; if b then getDirectoryContents d else return []
15:53:19 <int80_h> I want a pony
15:53:21 <dylukes> kmc: is that hard :<?
15:53:26 <Cale> @hackage pony
15:53:26 <lambdabot> http://hackage.haskell.org/package/pony
15:53:27 <kmc> aavogt, there's a race condition there
15:53:41 <mauke> aavogt: 1) there are other exceptions  2) race condition
15:53:50 <ddarius> dylukes: No, but it would make Haskell not Haskell.
15:54:08 <ski> kmc : *linear* first-class continuations, i'd hope !
15:54:21 <kmc> what's wrong with the non-linear ones?
15:54:25 <ddarius> ski: You can't do anything fun with linear ones.
15:55:15 <sm_> and indeed, how safe/sensible/performant is this.. I am looking for subcommands at startup by searching the contents of all PATH dirs. I think git does the same. https://gist.github.com/1172310
15:55:53 <dylukes> Cale: how does StateT [a] come out?
15:56:00 <dylukes> like ,what's an example application?
15:56:05 <ski> ddarius : well, i think you could do coroutines
15:56:10 <aavogt> kmc, mauke I see
15:56:15 <dylukes> removing intermediates :P?
15:56:26 <ddarius> sm_: It sounds neither safe nor performant, though I don't see performance being a big issue.
15:56:29 <ski> kmc : non-linear ones admit side-effects into the language
15:56:48 <Cale> dylukes: It's good for things like solving puzzles, where you have some puzzle state, and you nondeterministically update it.
15:57:01 <Cale> @unmtl StateT s [] a
15:57:01 <lambdabot> s -> [(a, s)]
15:57:02 <dylukes> Oh, neat.
15:57:13 <mmos1127_> Can someone point me to the easiest way to do the following:  I have a program which reads a line via getLine, acts on it, and calls itself to loop. Depending on the input it reads, it would spawn a subprocess (this is in windows by the way). Other input would cause it to kill that subprocess.
15:57:19 <dylukes> @unmtl ReaderT s [] a
15:57:20 <lambdabot> s -> [a]
15:57:40 <mmos1127_> (clarification this is in Windows XP )
15:58:30 <Cale> mmos1127_: See System.Process. When you spawn the process, you should get a ProcessHandle which you can later terminateProcess on to kill it.
15:59:04 <Cale> The simplest way would be: runCommand :: String -> IO ProcessHandle
15:59:11 <Cale> terminateProcess :: ProcessHandle -> IO ()
15:59:39 <Cale> But there are lots of variations for controlling the stdin and stdout to the child process, passing commandline arguments in a more careful way, and so on.
16:01:21 <mmos1127_> Cale: thanks, I just needed a starting point-- I'll read the System.Process docs
16:04:16 <Cale> mmos1127_: The loop you wrote will presumably then take a Maybe ProcessHandle parameter or something to allow you to hang on to the child process
16:04:37 <Cale> (or you can just stash it in an IORef, whatever :)
16:06:32 <maurer_> This is going to sound dumb, but I'm trying to use the new generics, and am having a hard type getting the types to line up http://hpaste.org/50671
16:08:21 <maurer_> Urr, nevermind, I've found some wrong things, sorry for bothering you all
16:09:17 <sm_> Cale, ddarius: thanks. [] is ok here, I'm just detecting plugins and want to carry on if I can't
16:09:53 <mmos1127_> Cale: well I tried this:  do { h <- runCommand "a command"; s <- getLine; terminateProcess h} and it ran, but didn't terminate the process. Hey I just noticed the System.Process docs say it will only terminate the shell used to run the command, not the command itself
16:10:08 <mmos1127_> clarification: on WINDOWS it only terminates the shell
16:10:33 <Cale> mmos1127_: oh, hmm
16:10:37 <BMeph> sm_: Thanks for bringing it up. I'm psyching myself up to hack away at my translated Io interpreter again...
16:10:50 <Cale> mmos1127_: in that case, maybe try createProcess directly, or runInteractiveProcess
16:10:52 <mmos1127_> apparently I can't use runCommand to accomplish this-- must use createProcess
16:10:56 <Cale> yeah
16:11:05 <blackdog> g'day all. i'm looking for a bit-oriented library - basically want something that can be passed a list of bit indices that should be on and a bounds tuple, and return an immutable data structure that can be queried by index. any ideas what i should be using?
16:12:24 <blackdog> i had a bit of a look at Vector, but couldn't see how to unfold from the list of indices to the vector
16:17:19 <mustelo> blackdog, not sure exactly what you're going for, but maybe Data.Vector.generate is relevant?
16:18:04 <blackdog> mustelo: nah, that's not quite right
16:18:14 <mustelo> can you give an example?
16:18:50 <blackdog> sure. i call "magicfunction (0,10) [3,1,7]"
16:19:18 <blackdog> and get back something i can call "foo ! 3" and get True, "foo!2" and get False
16:19:30 <mustelo> is it always 0 indexed?
16:19:40 <blackdog> O(1) access time, O(n) build time
16:19:45 <dylukes> how do people usually pronounce STG?
16:19:52 <dylukes> S-T-G or like "stig"
16:19:54 <dylukes> :\
16:20:06 <mauke> "starch"
16:20:09 <blackdog> mustelo: actually, for this case it's 1-indexed, but i can cope with 0 indexing.
16:20:20 <blackdog> and i know the top possible value beforehand too.
16:20:41 <blackdog> basically, in C i'd set up a big array and update mutably
16:20:54 <blackdog> but it feels like it shouldn't be necessary. Maybe ST?
16:21:03 <mustelo> nah, one sec
16:21:53 <blackdog> there's bitarray on hackage, but the index type is Int only
16:22:01 <blackdog> which may or may not be a problem.
16:22:30 <mustelo> magicfunction :: (Int,Int) -> [Int] -> Array Int Bool
16:22:30 <mustelo> magicfunction bds l = accumArray (const id) False bds $ zip l (repeat True)
16:22:50 <mustelo> *Main> let a = magicfunction (0,10) [3,1,7]
16:22:50 <mustelo> *Main> a ! 2
16:22:51 <mustelo> False
16:22:51 <mustelo> *Main> a ! 3
16:22:51 <mustelo> True
16:23:02 <blackdog> mustelo: basically i want the bitArray function in http://hackage.haskell.org/packages/archive/bitarray/0.0.1/doc/html/Data-BitArray.html but without the Int constrait
16:23:30 <monochrom> @let magicfunction bds l = accumArray (const id) False bds $ zip l (repeat True)
16:23:31 <lambdabot>  Defined.
16:23:35 <blackdog> ok, so just using Data.Array? that'd be boxed, right?
16:23:44 <monochrom> > magicfunction (0,10) [3,1,7] ! 2
16:23:46 <lambdabot>   False
16:23:48 <monochrom> \∩/
16:23:59 <blackdog> (not that it really matters, just working out the constraints)
16:24:02 <mustelo> blackdog,  sure but that's easy to change if necessary
16:24:07 <monochrom> Data.Array is boxed yes
16:24:14 * edwardk waves hello.
16:24:34 <monochrom> there is also UArray with a similar API
16:25:00 <cmccann> edwardk, so I looked through the trifecta source the other day, had Daft Punk's Technologic stuck in my head for half a day, thanks a lot
16:25:09 <mustelo> hahaha
16:25:12 <roconnor> hi edwardk
16:25:14 <edwardk> cmccann: hahahaha
16:25:40 <edwardk> i'm finishing up an HTML-highlighter for it now
16:25:41 * cmccann doesn't even really like that song :[
16:25:55 <HugoDaniel> :)
16:25:56 <edwardk> the names started out by accident
16:26:42 <cmccann> edwardk, it has a cute naming scheme at least, I'll give you that much
16:26:59 <edwardk> well, that and that module is only used internally
16:27:26 <copumpkin> ohai edwardk
16:27:47 <edwardk> http://ekmett.github.com/trifecta/Text-Trifecta-Parser-It.html is the module in question in case someone doesn't get it
16:28:00 <edwardk> copumpkin: any luck with the collector?
16:28:26 <copumpkin> having trouble even getting my allocator-setting constructor to be called
16:28:28 <copumpkin> not sure what's up
16:28:47 <edwardk> ah
16:29:30 <m3ga> technologic!
16:31:01 <cmccann> and http://www.youtube.com/watch?v=YtdWHFwmd2o is the song in question, which isn't actually the one mentioned in the module source
16:31:11 <kmc> mentioned where?
16:31:26 <cmccann> kmc, see edwardk's link
16:31:43 <kmc> aha
16:32:38 <edwardk> http://www.youtube.com/watch?v=gAjR4_CbPpQ for the completely culturally disconnected
16:33:19 <cmccann> the latter being a better song than technologic anyway
16:39:00 <roconnor> edwardk: where can I find transpose for representable functors?
16:39:10 <edwardk> roconnor: distribute
16:40:09 <ovrskr> I just noticed, is every single haskeller in this channel ?!
16:40:11 <edwardk> (Data.Distributive)
16:40:29 <edwardk> nah, many of the ones I know don't sign in here
16:40:44 <cmccann> pretty sure SPJ doesn't hang out in here
16:40:52 <cmccann> which is a pretty major counterexample
16:40:59 <roconnor> edwardk: I need a guide to your libraries
16:41:09 <edwardk> roconnor: =)
16:41:15 <edwardk> roconnor: byorgey is starting one ;)
16:41:28 <kmc> not everyone in this channel uses Haskell, either
16:41:35 <kmc> neither necessary nor sufficient :)
16:41:38 <edwardk> haha
16:41:57 <cmccann> also, some of us mostly abuse haskell, rather than use it
16:42:31 <ovrskr> well I merely singled out haskellers, but fair enough :)
16:42:46 <ovrskr> whatever that means
16:43:14 <shachaf> There are actually only two Haskell programmers.
16:43:31 <ovrskr> It's just that #haskell is the 10nth most populated channel on FreeNode according to Xchat
16:43:38 <mauke> The Sussman, you, and me
16:44:13 <copumpkin> anyone know under what conditions __attribute__((constructor)) functions might not get called at startup?
16:44:19 <copumpkin> since mine aren't
16:46:30 <edwardk> it is something to do with dynamic loading or some such?
16:47:02 <copumpkin> could be, who knows
16:47:39 <kmc> proof that Haskell is a more popular language than Perl, C, or Ruby
16:48:04 <edwardk> or that it needs a tighter knit support group because it is more traumatizing than Perl, C, or Ruby.
16:48:11 <glguy> I heard that the Perl, C, and Ruby programmers were too busy getting paid to work
16:48:19 <kmc> :D
16:48:20 <blackdog> hi, my name's blackdog ... and i'm a haskeller.
16:48:21 <edwardk> vicious lies
16:48:31 * cmccann can't really give serious consideration to the idea of something being more traumatizing than perl
16:48:37 <blackdog> i've been lambda free for seven minutes
16:48:42 <kmc> cmccann, PHP?
16:48:56 <edwardk> i spend 10 years inoculating myself to the horrors of haskell by using perl every day
16:48:57 <mauke> cmccann: C++?
16:49:08 <cmccann> kmc, turing tarpits don't count
16:49:15 <mustelo> haha
16:49:32 <ovrskr> I find Boost pretty frightening
16:49:42 <mauke> that's the boost.spirit
16:49:56 <edwardk> boost alternately makes me happy and horrified
16:50:00 <ovrskr> Actually got, no kidding, an error message than span 84 lines or something
16:50:09 <cmccann> mauke, and nah, my impression is that it's easier to avoid the traumatic stuff in C++ by closing your eyes and pretending really hard that it's a funny dialect of C
16:50:15 <kmc> why use Haskell when you can use a library that reimplements trivial features from Haskell in 10,000 lines of C++ code?
16:50:23 <ovrskr> an ode, i'm sure. you play it backwards and satanic messages come out
16:50:25 <mauke> cmccann: that only works if you don't use external libraries
16:50:26 <edwardk> kmc++
16:50:35 <blackdog> mustelo: heh, so maybe it does matter - 5gb of memory later, think i maybe should be packing those bits
16:50:38 <mauke> ovrskr: that seems rather small
16:51:59 <kmc> i bet i can get comparable error messages out of GHC very easily
16:52:02 <kmc> with "deriving Generic"
16:52:02 <copumpkin> gah
16:52:05 <copumpkin> wtf
16:52:09 <kmc> it choked on my 500-constructor enum type
16:52:39 <ovrskr> ghc only knows how to say "your types are wrong you suck bye" :P
16:52:41 <cmccann> giant stack traces from complicated type hackery imploding are pretty terrible
16:52:49 <mauke> ghc should be able to output images as errors: http://mauke.dyndns.org/stuff/img/lol,internet/excuse-me-wtf-r-u-doin.jpg
16:53:19 * cmccann declines to say why he knows that
16:53:21 <blackdog> cmccann: there was an interesting paper a little while about programming error messages - something like having one build for error reporting and another for production
16:53:31 <blackdog> i can never remember the name, though
16:53:31 <ovrskr> kmc, is this TH ?
16:53:33 <elliott> I wish "let"s in do blocks were more lenient about indentation.
16:54:50 <monochrom> it is already the most lenient without allowing ambiguity
16:55:32 <hpaste_> elliott pasted “lets in do blocks” at http://hpaste.org/50672
16:55:37 <elliott> monochrom: How's the above ambiguous in a do block?
16:56:16 <monochrom> I see. it is not ambiguous. but it's a hell to parse
16:57:28 <elliott> monochrom: heh
16:57:35 <elliott> it would be convenient though
16:57:50 <mauke> elliott: what would be the exact parsing rules?
16:58:08 <elliott> mauke: That I'm not qualified to say.
16:59:01 <hpaste_> monochrom annotated “lets in do blocks” with “lets in do blocks (annotation)” at http://hpaste.org/50672#a50673
16:59:24 <monochrom> my example is still not ambiguous but no one will like it
16:59:27 <edwardk> elliot: the let opened a layout rule. do tried to open one offside
16:59:45 <elliott> monochrom: wow, I can't even figure out what is going on there
16:59:51 <elliott> edwardk: right
16:59:52 <monochrom> QED
17:00:28 <edwardk> elliott: you can derive a form of layout that is compatible with what you wrote. in fact if you look at my layout combinators thats basically what i parse ;)
17:00:38 <edwardk> elliott: but it isn't haskell layout
17:01:02 <ovrskr> heh I just learned about SysRq.
17:01:11 <edwardk> it also breaks layout for empty let and where clauses
17:01:17 <ovrskr> actually tried the example Wikipedia gives: echo b > /proc/sysrq-trigger
17:01:31 <monochrom> "z" is part of the do-block. "moreover" is a sibling of "foobar". the poor indentation is unreadable and caused by your desired extra lenience. this example shows how bad the idea is
17:01:35 <mauke> ovrskr: force reboot?
17:01:40 <ovrskr> yep.
17:01:49 <elliott> empty let and where clauses - useful :P
17:01:58 <azaq23> It's not so much a reboot as just a power switch off
17:02:17 <ovrskr> I think it must be a bad joke somebody planted there.
17:02:41 <edwardk> monochrom: if you follow a 'first token after the do block' rule like my layout parsers you get foobar = do (with all its contents) as the first scope. let { z = x + y } and then return z moreover a = a * a
17:02:47 <mauke> that'll learn you to run random unix commands you read on the internet
17:02:48 <mauke> as root
17:02:49 <edwardk> as members of the do block
17:02:59 <ovrskr> :D
17:03:23 <monochrom> oh, right, so it's ambiguous afterall
17:03:40 <edwardk> monochrom: but then a floating 'where' for an empty class becomes illegal because it consumes the rest of the input
17:03:55 <ovrskr> well, "reboot" reboots the machine in a safe way, you'd figure the SysRq equivalent does the same ?
17:04:01 <edwardk> which is a fairly easy mistake to make
17:04:47 <edwardk> and similarly if someone left a naked 'let' inside a do block it'd have a different meaning than the haskell version
17:04:50 <mauke> ovrskr: then why would it be necessary?
17:05:31 <ovrskr> necessary?
17:06:12 <mauke> yeah, why would someone make the SysRq key magic?
17:06:37 <ovrskr> welll....
17:06:55 <ovrskr> wine often wreaks havoc in my input devices
17:07:20 <ovrskr> say, when running fullscreen apps or something
17:07:42 <blackdog> ovrskr: you poured merlot on the keyboard?
17:08:51 <ovrskr> well, beer was fine..
17:09:30 <edwardk> yeah, there is no use crying over spilt beer. spilt wine on the other hand.
17:13:27 <cmccann> edwardk, out of curiosity, does trifecta have any way to produce incremental results?
17:13:48 <edwardk> not _really_
17:14:02 <edwardk> i'm working on adding another parser that is nicer about incremental feedback
17:14:04 <kmc> > let {} in ()
17:14:05 <lambdabot>   ()
17:14:15 <edwardk> since its only Text.Trifecta.Parser.Prim that needs duplicating to do that
17:14:29 <edwardk> what i want is one for doing interaction (haskeline/readline-like stuff)
17:14:41 <edwardk> and for that i need to suspend and resume
17:14:51 * ski notes edwardk lost his mett
17:14:56 <cmccann> e.g., something where the input is parsed as a whole, but there are checkpoints where some stuff up to that point is known with certainty, and incremental output can be collected piecemeal and assembled somehow
17:15:26 <edwardkmett> the current design doesn't really support it because i don't know what marks have been made
17:15:54 <cmccann> an easy case being something that roughly goes line-by-line, but I can imagine it extending to the output being a general monoid of some sort
17:15:55 <edwardkmett> i've been eyeballing revoking my 'permanent mark' approach, and making something like try where nested code can use the mark only
17:16:13 <edwardkmett> yeah, the original trifecta talk used that approach actually
17:16:39 <edwardkmett> the problem with it is that it is someone inimical to my way of handling diagnostics
17:17:04 <cmccann> yeah, I asked mostly because monoidal computation seems like something you enjoy :P
17:17:19 <edwardkmett> yeah, the monoidal stuff is going in, but differently.
17:17:49 <cmccann> so far everything I've actually wanted I've been able to twist into running complete parsers sequentially with modified input, but a more coherent approach would be nice
17:17:52 <edwardkmett> i'm adding a dyck language pre pass that you can use as a form of MonadTokenParser that will be responsible for balancing parens, etc.
17:18:10 <edwardkmett> and then you can run the parser in parallel over the parenthesized fragments and the remainder
17:18:14 * cmccann nods
17:18:36 <edwardkmett> the dyck language pass is monodical, as is the preprocessor that is in the wings
17:18:40 <edwardkmett> er monoidal
17:18:48 <edwardkmett> damn autocorrect. where do i turn that off in textual?
17:18:49 <cmccann> monodical eh
17:20:23 <ski> :/
17:23:14 <edwardkmett> ah it was some crud they added to lion
17:23:27 <mustelo> autocorrect *everywhere*?
17:23:34 <edwardkmett> yeah
17:24:03 <Jafet> What is monodical
17:24:04 <edwardkmett> lovely given the fact that a good number of the words i use in day to day conversation aren't in the dictionary ;)
17:24:21 <edwardkmett> it was what it wrote when it autocorrected monoidal (perhaps half-way through)
17:24:37 <edwardkmett> i caught 3 tries by it to 'correct' me, but missed one
17:27:43 <blackdog> lion sounds like a dubious "upgrade"
17:28:23 <edwardkmett> actually its pretty good
17:28:36 <edwardkmett> and once i stopped bitching and googled, it was a 2 second fix ;)
17:29:08 <Cale> Wow, monodical is at least as obscure a word as monoidal, wtf Apple.
17:29:09 <blackdog> i'm a bit biased - one of my mates managed to take his machine out of action for a full week through upgrading
17:29:55 <blackdog> and autocorrect everywhere seems a bit dumb for an input device as fast and unconscious as a keyboard
17:30:05 <Cale> Autocorrect is almost always the wrong thing to be doing.
17:30:27 <blackdog> it's fine for tablets & phones, where you're painstakingly hunting-and-pecking stuff out
17:30:30 <copumpkin> autoincorrect
17:30:34 <blackdog> (although even there i'd prefer autocomplete)
17:49:48 <shachaf> blackdog: Are you aware that haskell-src-meta-mwotton isn't working witH GHC 7?
17:50:21 <blackdog> shachaf: nope. i should really delete it, it was just a stopgap. there's an active maintainer of haskell-src-meta now, as far as i'm aware
17:52:42 <edwardkmett> does sam anklesaria log into irc? i can't remember
18:02:06 <aavogt> blackdog: you can delete packages of hackage?
18:03:01 <aavogt> *off
18:03:27 <blackdog> aavogt: i think you have to talk to someone?
18:04:03 <aavogt> you can upload a new one that says it is no good
18:04:32 <aavogt> sort of like http://hackage.haskell.org/package/monads-fd
18:05:24 <blackdog> that's a good idea.
18:07:58 * hackagebot BiobaseTrainingData 0.1.1.0 - RNA folding training data  http://hackage.haskell.org/package/BiobaseTrainingData-0.1.1.0 (ChristianHoener)
18:10:59 <copumpkin> what's a good way to get code to run on startup (when your module loads)?
18:11:18 <copumpkin> that doesn't involve __attribute__((constructor)) in a linked-in C module
18:12:06 <blackdog> copumpkin: that sounds like an awful, awful thing to permit :)
18:12:46 <copumpkin> well, I need it :P
18:13:21 <ski> > fromDynamic (fix toDyn) :: Maybe Dynamic
18:13:22 <lambdabot>   Just <<Dynamic>>
18:14:01 <Jafet> Well, some modules make you do everything in a monad
18:14:05 <edwardkmett> clearly you should just seq some thunk that unsafePerformIO's what you need done before every action ;)
18:14:08 <ski> > fix (fromJust . fromDynamic)
18:14:12 <lambdabot>   mueval-core: Time limit exceeded
18:14:13 <copumpkin> edwardkmett: :(
18:14:28 <Jafet> And edwardk's method is just a simplification of that
18:14:33 <edwardkmett> well, i suppose that would actually work ;)
18:14:37 <ski> @hoogle (forall a. Typeable a => a -> b) -> (Dynamic -> b)
18:14:37 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
18:14:38 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
18:14:38 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
18:14:42 <edwardkmett> Jafet: doing everything in a monad isn't really an option here
18:14:49 <copumpkin> that's annoying overhead that we shouldn't need :P
18:14:50 <Jafet> It wouldn't actually run when you load the module, of course
18:15:05 <edwardkmett> its being used to set up a hook into ghc's custom allocator for gmp so we can support the constant cache used by mpfr
18:15:24 <edwardkmett> it has to happen before calling anything in mpfr that uses its constant cache
18:15:34 <ski> is there a way of doing `forall b. (forall a. Typeable a => a -> b) -> (Dynamic -> b)' without having to dig inside `Data.Dynamic' ?
18:15:51 <Jafet> Bah, they should just fix gmp already
18:15:58 <Jafet> Or integer-gmp
18:15:58 <copumpkin> Jafet: what's wrong with GMP?
18:16:00 <edwardkmett> Jafet: ?
18:16:06 <edwardkmett> how so?
18:16:23 <edwardkmett> we're doing something pretty far outside its ken ;)
18:16:30 <copumpkin> this is bad design (or at least, not foreseeing our kind of usage) on the part of MPFR
18:16:42 <Jafet> Aren't you working around the fact that integer-gmp doesn't let you link gmp again?
18:16:49 <copumpkin> no
18:17:01 <Jafet> Oh, ok. But they still should fix integer-gmp.
18:17:23 * ski wonders what "MPFR" stands for
18:17:31 <copumpkin> multiprecision float (with) rounding
18:18:01 <Jafet> Yeah, C programmers love "static" memory
18:18:31 <edwardkmett> jafet: actually, yes, we are
18:18:46 <edwardkmett> Jafet: we're working around the fact that anything else that uses gmp breaks when linked with haskell
18:18:58 <Jafet> That's a corollary
18:19:07 <copumpkin> Jafet: how would you fix that?
18:19:21 <edwardkmett> but when it all works we'll get the benefit of GHC's being able to move the MPFR'd memory around
18:19:23 <Jafet> Depends on what you want to fix, doesn't it.
18:19:29 <edwardkmett> er GHC's GC
18:19:44 <edwardkmett> so it'll be a net 'good thing
18:19:48 <Jafet> If you want to fix your module, you can do what edwardk said with the unsafePerformIO
18:20:14 <copumpkin> Jafet: I don't want to force that for every bound function
18:20:39 <edwardkmett> copumpkin: theoretically we could get away with it as a pseq only on calls to pi and to the trig functions
18:20:43 <Jafet> If you want to bother fixing integer-gmp or asking the gnu people to fix mpfr or getting some sort of run-on-load hook into ghc...
18:21:11 <Jafet> How is pseq implemented?
18:21:34 <edwardkmett> jafet: unlike seq, pseq has the guarantees of "do this, then do that".
18:22:06 <edwardkmett> copumpkin: it makes me a little sad that we'd have to hook some weird CAF like that but i could stomach it
18:22:24 * roconnor secretly suspects pseq is implement as seq
18:22:31 <monochrom> pseq doesn't get translated to code per se. but it pins control flow order of generated code
18:22:49 <Jafet> Hm, how is seq weaker than "do this, then do that"?
18:23:08 <copumpkin> Jafet: it could be evaluate that, evaluate this, then return that
18:23:09 <edwardkmett> jafet: seq's can be swapped around. they merely say that if the left hand side is _|_ then so is the result
18:23:11 <monochrom> seq suggests but not requires that order
18:23:18 <zygoloid> Jafet: seq means 'do that, but produce _|_ if this is _|_'
18:23:19 <edwardkmett> jafet: and it happens
18:23:35 <Jafet> Ah, subtle
18:23:50 <monochrom> my example http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/ is hilarious
18:25:20 <monochrom> so seq a b is "eventually do a"
18:25:37 <copumpkin> edwardkmett: I'm still really confused as to why this documented feature of gcc, that works elsewhere on my machine, isn't working here
18:25:52 <edwardkmett> are you statically or dynamically linking?
18:25:59 <copumpkin> statically
18:26:01 <copumpkin> but so is integer-gmp
18:26:09 <edwardkmett> is that how they hook?
18:26:17 <copumpkin> yep
18:26:20 <shachaf> edwardkmett: You seem to have grown a mett.
18:26:22 <edwardkmett> nifty
18:26:30 <copumpkin> it'd be niftier if it worked for me too
18:26:37 <edwardkmett> shachaf: i did so earlier as a joke, then someone teased me when i lost it
18:27:48 <shachaf> preflex: seen ekmett
18:27:48 <preflex>  ekmett was last seen on #haskell 1 year, 230 days, 8 hours, 20 minutes and 35 seconds ago, saying: jmcarthur: accident =)
18:28:01 <shachaf> Been a while since we've seen *him*.
18:28:10 <ekmett> it has?
18:28:16 <shachaf> preflex: seen ekmett
18:28:16 <preflex>  ekmett was last seen on #haskell 6 seconds ago, saying: it has?
18:28:42 <ski> edwardkmett : actually i was reliefed that you had lost it ..
18:29:35 <mauke> so what you're saying is edwardk has lost it
18:29:37 <edwardk> heh, i've actually had several people pop on here and eventually go, 'oh, you're edward kmett!' then launch into asking me a bunch of questions about libraries and posts and stuff
18:30:05 <ovrskr> fame oO
18:30:16 <finlayt> hi
18:30:39 <finlayt> anyone got a good reference suggestion for PrimMonad, and what its all about ...
18:30:46 <edwardk> these things happen ;) its a bit easier now that i'm not hiding as "Harmless" on teh interwebs
18:31:01 <mauke> preflex: seen harmless
18:31:01 <preflex>  Sorry, I haven't seen harmless
18:31:23 <ski> edwardk : you, harmless ?!
18:31:27 <Jafet> Mostly harmless.
18:31:29 <edwardk> not sure if i ever signed in here with it
18:31:40 <edwardk> but its what i used to use back in the demo scene days
18:32:17 <monochrom> "harmless" is more harmless than "hamlet"
18:32:34 * ski . o O ( "Well it just so happens that your friend here is only *mostly* dead." )
18:33:40 <cmccann> there's a big difference between mostly dead, and all dead
18:34:44 <cmccann> edwardk, it probably doesn't help your internet fame that your blog is occasionally used as a representative example of the "obsessed with abstract math" side of the Haskell community
18:34:47 <monochrom> that suggests the game of quantum werewolf ( http://puzzle.cisra.com.au/2008/quantumwerewolf.html )  you are mostly dead but not dead because you are dead in most universes but not all
18:35:07 <edwardk> i'll live
18:35:21 <edwardk> the funny thing is i spend about half my time hacking on eminently practical stuff ;)
18:35:33 <copumpkin> yeah, what the hell
18:35:33 <edwardk> the blog is what i write to unwind
18:35:37 <copumpkin> stop working on such practical stuff
18:35:41 <edwardk> hahahaha
18:36:22 * cmccann thinks edwardk should stop messing with academic toys like another parsing library and spend more time on practical tools, like recursion schemes
18:36:28 <copumpkin> I demand a zygohistodynapreproparahylomorphic g_preprocatamorphism
18:36:40 <edwardk> but i already packaged that
18:36:48 <copumpkin> I need it for my latest algorithm
18:36:54 * monochrom wonders if the dual is true of bloggers who blog practical stuff. is it because they have to do abstract proofs for day jobs?
18:38:10 <ski> (cmccann : hehe, i haven't even seen the movie)
18:38:30 <cmccann> edwardk, incidentally the recursion-schemes package has given me a few ideas, I've taken some inspiration form it in my attempts to get some better generic type-level recursion operators working
18:38:50 <cmccann> the current form seems clearer to me than the old stuff dumped in category-extras
18:38:52 <edwardk> i had a big patch i was going to push out for it, but i'm not sure where i putit
18:39:03 <edwardk> i'm glad. that was why i rewrote it ;)
18:39:12 <aavogt> @src Mu
18:39:12 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
18:39:17 <copumpkin> Moo
18:39:43 <aavogt> cmccann: fancier than that? as in you get to choose how many iterations?
18:39:43 <edwardk> the category-extras version had the downside that it was obscured behind type aliased like Algebra, etc.
18:39:58 <copumpkin> OH
18:40:02 <monochrom> mu, a name, that calls itself  ( http://www.mail-archive.com/haskell-cafe@haskell.org/msg92742.html )
18:40:04 <copumpkin> I think I know what's going on
18:40:07 <cmccann> aavogt, not that kind of recursion
18:40:11 <edwardk> copumpkin:?
18:40:33 <cmccann> aavogt, I mean the kind that requires undecidableinstances :P
18:40:49 <Anpheus_> If I have a function f :: a -> b -> c -> d
18:41:07 <Anpheus_> and I want to lift it twice to different contexts h and j
18:41:11 <Anpheus_> similar to how one can do
18:41:19 <Anpheus_> f <$> _ <*> _ <*> _
18:41:22 <cmccann> for my type hackery dumping ground that I finally started uploading to github
18:41:35 <Anpheus_> how does one do that for two contexts deep?
18:42:03 <cmccann> :t liftA2 . liftA2
18:42:05 <lambdabot> forall (f :: * -> *) a b c (f1 :: * -> *). (Applicative f, Applicative f1) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
18:42:06 <Anpheus_> I know for unary functions it's easy to just do (fmap . fmap) f _
18:42:13 <Anpheus_> Ok
18:42:18 <ski> @type liftM3 . liftM3
18:42:19 <lambdabot> forall (m :: * -> *) a1 a2 a3 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> a2 -> a3 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 a3) -> m (m1 r)
18:42:28 <cmccann> don't think there's an easy way to use the infix style
18:42:44 <copumpkin> edwardk: it's stripping out the function because it thinks nobody uses it
18:42:53 <edwardk> ah
18:42:54 <copumpkin> my constructor
18:42:56 <aavogt> you can go half way     liftA2 <$> _ <*> _ <*> _
18:43:02 <aavogt> liftA2 f <$> _ <*> _ <*> _
18:43:03 <edwardk> so, construct it somehow
18:43:03 <copumpkin> my beloved constructor
18:43:26 <edwardk> how goes integer-gmp fake its use?
18:43:41 <copumpkin> not a clue
18:43:48 <cmccann> aavogt, I think that's more confusing to have both, personally
18:43:59 <gwern> @quote gmp
18:43:59 <lambdabot> No quotes match. Wrong!  You cheating scum!
18:44:01 <mauke> copumpkin: what is stripping it out?
18:44:03 <edwardk> adding a pretty printer for highlighted ropes to trifecta.
18:44:09 <copumpkin> mauke: not a clue
18:44:11 <copumpkin> mauke: someone is though
18:44:22 <edwardk> i have one for printing them in HTML, now i want to render them to TermInfo
18:44:23 <mauke> pesky
18:44:32 <copumpkin> mauke: if I call the constructor function explicitly, it fires before I call it. If I don't call it, it doesn't fire at all
18:44:50 <copumpkin> mauke: if I hide the explicit call behind a tough-to-see-through condition
18:44:54 <edwardk> then i can tweak the diagnostic renderer to admit retroactive highlights
18:44:55 <copumpkin> so it can't get optimized out
18:45:01 <copumpkin> it calls the constructor without me calling it
18:45:15 <copumpkin> I remember there being another function attribute to stop that from happening
18:46:00 <mauke> copumpkin: __attribute__((used))
18:46:12 <edwardk> shiny
18:46:22 <copumpkin> not good enough :(
18:47:05 <edwardk> externally_visible ?
18:47:09 <copumpkin> tried that too
18:47:56 <copumpkin> it's also kind of wonky
18:48:59 <copumpkin> I am fucking confused now
18:50:11 <copumpkin> oh
18:50:20 <copumpkin> no, I'm still confused
18:51:15 <ski> @type \f a b -> (<*>) <$> ((f <$>) <$> a) <*> b
18:51:15 <lambdabot> forall (f :: * -> *) a b a1 (f1 :: * -> *). (Applicative f, Applicative f1) => (a1 -> a -> b) -> f1 (f a1) -> f1 (f a) -> f1 (f b)
18:51:20 * ddarius retroactively rewrites that into just "oh no, I'm still confused."
18:51:29 <edwardk> where did you put the attribute? before, after, etc.
18:51:56 <kfish> @pumpkinsnack
18:51:56 <lambdabot> Unknown command, try @list
18:52:04 <copumpkin> well, I'm sure I can coax it to include the function for me
18:52:13 <copumpkin> but the actual runtime behavior is confusing me now
18:52:19 <ski> @quote *gmp*
18:52:19 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 13,"Invalid preceding regular expression")
18:52:25 <copumpkin> @kfishsnack
18:52:26 <lambdabot> Unknown command, try @list
18:52:31 <mauke> @quote .gmp
18:52:31 <lambdabot> No quotes match. Just try something else.
18:52:47 <mauke> preflex: quote . gmp
18:52:50 <ski> @botsmack
18:52:50 <lambdabot> :)
18:52:53 <edwardk> @botsnack
18:52:53 <lambdabot> :)
18:52:55 <preflex>  no quotes found
18:53:06 <mauke> preflex: quote
18:53:07 <preflex>  <dngor> The answer, my friend, is blow me.
18:53:15 <incluye> preflex: quote
18:53:16 <preflex>  <warewolf> ok, I just reminded myself why I never clean this keyboard. it's because I never clean this keyboard.
18:54:13 <copumpkin> oh actually, I'm not confused
18:54:25 <copumpkin> it's just that the worst thing that could happen did happen
18:54:36 <monochrom> haha, what is the worst thing?
18:54:42 <mauke> all of this is just a dream
18:54:48 <mauke> we're figments of your imaginations
18:54:56 <edwardk> how so?
18:55:05 * cmccann dreams of being a butterfly
18:55:16 <copumpkin> well, the order of multiple constructors firing in the same module is undefined
18:55:17 * incluye is already a butterfly
18:55:23 <copumpkin> so of course, it picked the most unfavorable order for me
18:55:28 <edwardk> hah
18:55:39 <cmccann> deliberately, I'm sure
18:55:40 <edwardk> don't you just have one?
18:55:49 <copumpkin> so integer-gmp goes ahead and resets the allocators after I set them to my evil versions
18:55:53 <edwardk> ah
18:55:58 <copumpkin> because it decided in its infinite wisdom to call gmp's one after mine
18:56:07 <cmccann> haha
18:56:23 <copumpkin> okay, at least that's a sane explanation
18:56:30 <copumpkin> I was utterly confused at the behavior I was seeing
18:56:32 <edwardk> can you use a constructor (priority) version of the flag?
18:56:49 <copumpkin> unfortunately that priority thing supposedly only works locally, but I'll try
18:56:54 <cmccann> "this program is doing the thing I didn't want it to do" is almost always a sane explanation.
18:57:30 <edwardk> or init_priority or some such
18:59:35 <copumpkin> hmm, it seems to think priority isn't a valid parameter to constructor here
19:00:05 <edwardk> you passing it as a number?
19:00:17 <copumpkin> yep
19:00:20 <edwardk> odd
19:02:10 <copumpkin> I think I just have an old gcc
19:02:13 <copumpkin> but that's what apple gives you
19:04:04 <cmccann> edwardk, oh btw, you mentioned having a big patch for recursion-schemes you misplaced, do you remember what it changed? I'm curious.
19:04:17 <edwardk> what version?
19:05:55 <edwardk> i was going through and ripping apart the notion of cata and iter that i used and their ana/coiter analogues to make it easier to work things you can build but not take apart or vice versa
19:06:09 <edwardk> i don't remember the details off hand
19:06:36 <cmccann> ah, ok
19:06:56 * ddarius makes an iteratee library based on coalgebras and calls it "coitus."
19:07:14 <JoeyA> Suppose I have a function definition like this: let reverse [] = []; reverse (x:xs) = reverse xs ++ [x]
19:07:15 <cmccann> ddarius, that sounds like a fantastic idea
19:07:24 <edwardk> i have something that is not quite an Iteratee, I just call it It.
19:07:38 <JoeyA> However, I have a type defined like this: data MyList a = MyNil | MyCons a (MyList a)
19:07:42 <cmccann> ugh not the daft punk again
19:07:48 <edwardk> and use it to get music stuck in cmccann's head
19:07:58 <copumpkin> callIt
19:08:02 <cmccann> it's very effective
19:08:14 <copumpkin> forgetIt
19:08:16 <JoeyA> The reverse function defined above only works on lists.  If I wanted to make it "polymorphic" in the data constructors the arguments are built from, would I use type families?
19:08:33 <ddarius> JoeyA: No.
19:08:39 <JoeyA> Is it possible to do so?
19:08:57 <JoeyA> Or would I have to manually pick the data structures apart using arguments provided by the user?
19:09:20 <edwardk> JoeyA: you'd need to take something from the user, be it a class like Traversable or some arguments
19:09:26 <cmccann> JoeyA, you could use regular everyday type classes, not type families
19:09:34 <JoeyA> okay, thanks
19:09:39 <cmccann> Foldable and Traversable are probably what you want to look at
19:09:47 <edwardk> you can implement it with Traversable
19:09:54 <edwardk> its kinda silly though
19:10:02 <edwardk> and you need to do something really ugly
19:10:07 <copumpkin> use ST? :P
19:10:17 <JoeyA> The only downside is that you lose the luxury of pattern matching.
19:10:17 <monochrom> type class does not save you from writing yet another version of code for yet another data type
19:10:22 <edwardk> meh
19:10:32 <JoeyA> Pattern matching only works on the hard-coded data types you specify.
19:10:55 <cmccann> monochrom, it can save you from writing anything other than a small set of basic operations for every type, at least
19:11:02 <ddarius> The correct solution is to port the ideas from bondi to Haskell.
19:11:09 <maurer_> When I try to install process (under 7.2, so yeah, I know, I shouldn't expect it to work) I get * Missing (or bad) header file: runProcess.h
19:11:19 <maurer_> Does anyone have ideas on what's wrong/how to fix it?
19:11:19 <monochrom> oh, I see, yeah
19:11:55 <cmccann> maurer_, use a verbose flag, see where it expects the file to be
19:12:05 <edwardk> reversed as = snd . mapAccumL (\(a:as') _ -> (as', a)) (reverse . toList as) -- or something like that
19:12:09 <cmccann> I've had a couple situations where it was just being silly and creating an empty file in the right location was enough
19:12:25 <sm> ghci's :browse is great, but doesn't show instances, is there a way to explore those ?
19:12:37 <edwardk> relying on the fact that toList from Foldable and the Traversal will visit exactly the same number of elements
19:12:43 <cmccann> sm, :i
19:12:53 <edwardk> :info is your friend
19:12:55 <cmccann> lists (some) instances when asked about the class or a type
19:12:55 <sm> joy! thanks
19:12:59 <monochrom> ":info Int" shows stuff. ":info Show" does too
19:13:11 <cmccann> don't think it works right for multi-param type classes and some other funny business
19:13:14 <maurer_> cmccann: include/runProcess.h:47:26: fatal error: processFlags.h: No such file or
19:13:27 <maurer_> It looks like a sub header is not being found?
19:14:04 <cmccann> maurer_, right, so figure out where it's looking, and whether a file by that name exists elsewhere
19:15:23 <cmccann> if the file doesn't exist anywhere, create an empty file and see if that works, sometimes it's getting what it needs from elsewhere but looks for something anyway
19:15:50 <cmccann> if the file does exist elsewhere, add that to the include search path with a compilation flag
19:16:20 <copumpkin> gah, the IDA trial doesn't let me disassemble 64-bit binaries and I don't want to fire up a VM to use my legit copy on windows
19:16:41 <maurer_> copumpkin: IDA actually works surprisingly well under wine
19:16:51 <copumpkin> yeah, but I'm on a mac :)
19:16:59 <maurer_> copumpkin: Oh >_>
19:17:28 <ddarius> copumpkin: It's that much effort to start a VM?
19:17:38 <copumpkin> ddarius: when I don't have the VM set up on this computer, yep
19:17:54 <mustelo> might as well install linux
19:18:02 <ddarius> copumpkin: Just use gdb (haha)
19:18:06 <copumpkin> :P
19:18:09 <copumpkin> anyone want to save me an idb of http://dl.dropbox.com/u/361503/MPFRTest ?
19:20:40 <xil> hello. I am stuck on an odd problem. I'm doing some stuff with OpenGL and a simulation of some organisms moving around. I create a pipe to an instance of ffmpeg and I pipe rgb data to it every frame. I take the data from the OpenGL buffer every time OpenGL's draw function is called. I also separately put a printout of how many frames have gone by. Problem is that ffmpeg periodically prints some data and it conflicts with my frame p
19:21:53 <maurer_> copumpkin: How will that help? You'll still need the right ida stuff to read it...
19:22:09 <copumpkin> maurer_: I was hoping it wouldn't bitch if it was a premade idb :)
19:22:37 <maurer_> copumpkin: So, maybe the OSX codebase is different, but under linux and windows you need _separate_ _binaries_ to actually read the two
19:22:56 <maurer_> Like, they did the bittage with a #define or some shit
19:23:03 <maurer_> So you can read 32 or 64 but not both
19:23:24 <azaq23> xil: ffmpeg ought to have an option to disable output; if it is outputting stuff, yes, it will go to stdout along with your ourput, creating mixed rubbish
19:23:49 <kfish> xil: ffmpeg's text output messes with your program's text output?
19:23:52 <copumpkin> ah
19:24:17 <xil> oh no, sorry, that's not the problem. I don't mind the ffmpeg output, I like it, but it says it's processed less frames than have actually gone by
19:25:07 <xil> I got up to 600 frames and ffmpeg said only about 300, but it's not always half. And in the playback, if the video even works, it often starts skipping after a few seconds
19:26:08 <dmwit> ffmpeg? In my Haskell?
19:26:24 <maurer_> dmwit: It's more likely than you think.
19:26:26 <xil> it's more likely than you think
19:26:27 <xil> damn
19:26:32 <zekna> lol
19:26:38 <kfish> heh
19:27:09 <kfish> xil: is it just dropping frames? what if you write to a file then afterwards ask ffmpeg to encode that; does it encode all the frames?
19:27:40 <xil> kfish: I haven't tried because there are TBs of uncompressed RGB data and I don't have the time to figure out how to encode it in some format
19:28:07 <kfish> xil: same format you are sending ...
19:28:21 <int80_h> Is there a pre-existing type that looks like a natural number, but only can use the addition operator?
19:28:56 <dmwit> int80_h: No?
19:28:56 <maurer_> int80_h: Natural numbers _can_ only use the addition operator
19:29:02 <maurer_> But that is probably not what you are looking for
19:29:19 <edwardk> int80h: there is a Natural type in semigroups
19:29:20 <dmwit> Without at least zero-testing and decrementing, what exactly is it you're hoping to do with these things?
19:29:32 <ddarius> dmwit: Add them.
19:29:33 <xil> kfish: huh? I have a 600x600 image of RGB data. I send it uncompressed through the pipe
19:29:54 <xil> if I saved to a file it would add up VERY VERY FAST. I don't have the space for that
19:29:55 <dfjklasd> how will you print them?
19:30:06 <maurer_> xil: Then test with a file and fewer frames
19:30:14 <int80_h> dmwit: I want to guarantee that they can only increment, and never decrement.
19:30:24 <xil> maurer_: the problem only starts happening after a couple hundred frames so far
19:30:32 <dmwit> int80_h: That's fine and all, but you're going to need more than addition.
19:31:15 <int80_h> dmwit: why?
19:31:49 <dmwit> Here's a three-line module that provides what you (say you) want. "module OnlyAddition where data Nat; plus a b = a"
19:32:08 <edwardk> int80_h: if you use the algebra package you can use an appropriate additive monoid
19:32:22 <azaq23> maurer_: What do you mean when you say that Natural numbers can only use the addition operator?
19:32:32 <edwardk> int80_h: then just lean on parametricity and the choice of class
19:32:36 <int80_h> edwardk: I was looking up monoids just now in RWH thinking it might lead me to the right place.
19:32:49 <joe6> need some advice, I have a bunch of .c files meant for a pic30 target. I want to test the functions in the .c file using haskell FFI. Is that possible? run the c function on an x86 pc and use haskell to test the function.
19:32:59 <edwardk> int80_h: there is always the Sum monoid, but that doesn't keep someone from handing you a negative number
19:33:00 <franny> Hmm, I'm having a bit of a hard time figuring out how to use the "bitmap" package effectively.
19:33:26 <huangyi> Where is the real implementation of primitives in ghc, e.g. xxMVar#
19:33:37 <edwardk> GHC.Prim for the most part
19:33:45 <cmccann> franny, what's giving you trouble?
19:33:47 <edwardk> some other stuff gets spread about
19:34:14 <ddarius> joe6: Yes.  It's even easy depending on how complicated the interface to your C functions is.
19:34:15 <huangyi> but the implementation is just `newMVar# = let x = x in x'
19:34:20 <ddarius> I imagine it isn't very.
19:34:27 <xil> is it possible that the pipe gets too full or something and there's an overflow that's just ignored or something?
19:34:33 <maurer_> azaq23: (-) :: Foo -> Foo -> Foo
19:34:43 <maurer_> azaq23: Zero - (Succ Zero) = ?
19:34:51 <xil> the thing I don't understand is that whole frames, or a whole chunk of frames are dropped
19:34:54 <ddarius> huangyi: The "real" implementation is in the compiler/RTS.
19:35:06 <joe6> ddarius, it isn't complicated. i will start by defining the ffi file and take it from there.
19:35:08 <franny> cmccann: I'd like to be able to accept a Bitmap of any of the four legal types and encode it in a given format. But I'm not sure I can, given the type signature of Bitmap.
19:35:15 <azaq23> maurer_: Obvious; I was more concerned regarding multiplication (you said "can only" with emphasis on can)
19:35:35 <edwardk> huangyi: newMVar# is given a type signature in GHC.Prim but the implementation is off as a prim in the RTS
19:35:45 <maurer_> Oh, I was saying "as opposed to subtraction"
19:36:01 <maurer_> Any type you can do addition on and have a zero base for you can do multiplication on
19:36:27 <cmccann> franny, ah, so you want a function that accepts a polymorphic Bitmap as an argument?
19:36:31 <franny> It's straightforward enough for a function to accept a (Bitmap Word8) or a (Bitmap Float), but I'd like to be able to accept all four PixelComponent types in http://hackage.haskell.org/packages/archive/bitmap/0.0.1/doc/html/Data-Bitmap-Base.html
19:36:36 <franny> cmccann: yes.
19:36:55 <edwardk> the main purpose of the GHC.Prim module is to show you haddocks ;)
19:37:33 <edwardk> at least the one with the let x = x in x defs everywhere
19:37:57 <cmccann> franny, it should be easy to have a function accept such an argument, the only difficulty would be in doing something with it depending on what the library API looks like
19:39:14 <franny> cmccann: yeah, I know I can accept a (Bitmap t), but the API seems to be the problem here.
19:39:23 <copumpkin> didn't jhc support "on startup" things?
19:39:38 <cmccann> franny, what in specific? looks like most of the functions should be polymorphic enough
19:39:41 <dmwit> franny: Are the four types all members of any helpful type classes?
19:39:51 <dmwit> franny: If not, why not define a type class containing the operations you need?
19:40:03 <cmccann> they should all be instances of PixelComponent, yes
19:40:40 <franny> cmccann: I'd like to simply extract the value of each pixel. (In each channel, too.)
19:41:53 <xil> anyone know if hPutBuf returns before the data in the pipe is read? I assume so but hadn't thought about it before. If it does, is there a way to stop that and force it to wait until there's no more to read?
19:41:58 <edwardk> copumpkin: yes, the "ACIO" monad
19:42:06 <edwardk> affine commutative IO
19:42:07 <franny> dmwit: They're all numeric, which I suppose helps. (And PixelComponent, too.)
19:42:33 <franny> Actually, I'm not sure the "Data.Bitmap.Pure" package even has a way to read the individual pixels.
19:42:43 <dmwit> franny: Don't the "unsafeRead" functions let you do what you're asking to do?
19:42:44 <franny> Module, rather.
19:42:54 <dmwit> From Data.Bitmap.IO
19:42:54 <cmccann> well, reading a pixel gives you something of the pixel type obviously, and those are all Num instances, as you say
19:43:25 <franny> Hmm, the IO module seems a lot more fleshed out than the Pure one.
19:43:42 <cmccann> though I don't think `Num` alone gets you any way to convert to other numeric types, so I guess that's awkward if you wanted to do that?
19:44:01 <dmwit> :t toInteger
19:44:02 <lambdabot> forall a. (Integral a) => a -> Integer
19:44:07 <franny> And I spent all this time making my library as pure as possible. :p I guess I could use unsafePerformIO?
19:44:15 <dmwit> :t toRational
19:44:16 <lambdabot> forall a. (Real a) => a -> Rational
19:44:21 <dmwit> huh
19:44:31 <ski> edwardk : s/commutative/central/
19:44:33 <franny> (<https://github.com/franrogers/pam> is what I'm working on, incidentally.)
19:44:35 <edwardk> ah
19:44:37 <edwardk> you're right
19:44:45 <maurer_> franny: What function are you trying to construct that you can't?
19:44:55 <dmwit> Oh, fromInteger is what I was thinking of, but it goes the wrong way.
19:45:00 <cmccann> dmwit, indeed
19:45:08 <JoeyA> Are there any fast binary diff/patch libraries for Haskell?
19:46:02 <aavogt> @type flip lookup [ (fromIntegral (x::Int), x) | x <- [minBound .. maxBound] ]
19:46:02 <JoeyA> There's this: http://hackage.haskell.org/package/Diff  but the expected running time of that algorithm is O(N + D^2).  If the difference is too big, it'll explode in terms of space and running time.
19:46:03 <lambdabot> forall a. (Num a) => a -> Maybe Int
19:46:27 <franny> maurer_: to this module <https://github.com/franrogers/pam/blob/master/Codec/Image/PAM.hs>, I'd like to add a function: fromBitmap :: PixelComponent t => Bitmap t -> PAM
19:46:54 <dmwit> JoeyA: Where are you seeing O(N+D^2)? It says O(ND) in my documentation.
19:47:06 <cmccann> I guess you could use the fact that `Num` requires `Show` and convert numbers via `read` :P
19:47:24 <cmccann> ugh, backticks are becoming automatic
19:47:34 <dmwit> cmccann: eewww
19:48:09 <cmccann> dmwit, yeah pretty much :T
19:48:31 <dmwit> :t signum
19:48:32 <lambdabot> forall a. (Num a) => a -> a
19:48:51 * cmccann thinks it's kind of weird that Num doesn't include any way to convert to other numeric types
19:49:00 <cmccann> given all the other nonsense it does have
19:49:03 <JoeyA> dmwit: O(ND) > O(N + D^2)
19:49:18 <franny> Heh, that reminds me of an unrelated question: is there an equivalent to read that doesn't throw an exception when it fails? Like returning a Maybe?
19:49:37 <mauke> franny: reads
19:49:39 <JoeyA> The Myers O(ND) algorithm has expected running time of O(N + D^2), similar to how quicksort has expected running time of O(n log n)
19:49:55 <JoeyA> Too bad it's not O(N + D) :-)
19:50:03 <cmccann> > reads "what" :: [(Int, String)]
19:50:05 <lambdabot>   []
19:50:26 <ski> > (reads :: ReadS Int) "what"
19:50:26 <lambdabot>   []
19:50:31 <franny> mauke: Ah, thanks.
19:50:37 <incluye> > reads "(0.0)" :: (Float)
19:50:38 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
19:50:38 <lambdabot>         against inferred typ...
19:50:43 <edwardk> cmccann: writing too much haddock?
19:50:43 <incluye> neat
19:50:49 <cmccann> edwardk, no, SO markdown
19:50:50 <ski> > (reads :: ReadS Float) "(0.0)"
19:50:51 <lambdabot>   [(0.0,"")]
19:51:10 <edwardk> cmccann: shucks was going to suggest that before you lost the tick to go dump a bunch of docs on code for me ;)
19:52:03 <cmccann> edwardk, I should do that anyway at some point, for your stuff or any of the other interesting things on hackage with no useful docs
19:52:06 <dmwit> :t let toInteger n | signum n == -1 = -(toi (-n)) | otherwise = toi n; toi n | signum n == 1 = 1 + toi (n-1) | otherwise = 0 in toInteger
19:52:07 <lambdabot> forall a a1. (Num a1, Num a) => a -> a1
19:52:11 <dmwit> cmccann: =)
19:53:02 <edwardk> Data.IntervalMap.FingerTree has finally annoyed me enough that i'm dumping it and writing my own
19:53:18 * cmccann would probably be more inclined to document the general abstract nonsense than anything practical though
19:53:26 <edwardk> you can't just ask it for all the intervals, you get the intervals out in lexicographical order so you don't get strict nesting where possible, etc.
19:55:22 <ski> > dmwitToInteger (5 % 3)
19:55:24 <lambdabot>   2
19:55:39 <incluye> "dammitToInteger"
19:55:56 <ski> > dmwitToInteger (1 :+ 1)
19:55:57 <lambdabot>   0
19:56:12 <dmwit> > signum (1 :+ 1)
19:56:13 <lambdabot>   0.7071067811865475 :+ 0.7071067811865475
19:56:14 <incluye> > 1 :+ 1
19:56:14 <lambdabot>   1.0 :+ 1.0
19:56:19 <dmwit> heh
19:56:30 <cmccann> that's a very sensible signum, obviously
19:56:37 <dmwit> Yes.
19:56:50 <dmwit> I'm actually a bit surprised that dmwitToInteger terminates for Complex's.
19:56:54 <incluye> 1/2 * sqrt(2)?
19:57:01 <ski> > Data.Complex.magnitude (1 :+ 1)
19:57:02 <lambdabot>   1.4142135623730951
19:57:07 <incluye> yeah
19:57:12 <dmwit> incluye: Yes, times (1+i), though.
19:57:39 <cmccann> in other news this is one of the most atrocious type signatures I've written recently: (Natural n) => n -> (forall g x. f g x -> (x, g x)) -> (forall g x. x -> g x -> f g x) -> (z a -> z b -> z (a, b)) -> Replicate2 n f z a -> Replicate2 n f z b -> Replicate2 n f z (a, b)
19:57:51 <cmccann> I really need to find a better way of doing that
19:58:07 <dmwit> type-level replicate...
19:58:15 <elliott> beautiful /sheds a single tear
19:58:29 <incluye> and they say functional programming is complicated
19:58:43 <cmccann> incluye, no this is definitely dysfunctional don't worry about that
19:58:49 <incluye> heh
19:59:02 <dmwit> cmccann: What is the expansion of Replicate2 (S (S O)) f z b?
19:59:11 <incluye> "crapskell, a purely dysfunctional programming language"
19:59:28 <elliott> edwardk: how long until you release your own Prelude?
19:59:38 <incluye> evaluation is so lazy you'll receive your data when the compiler fucking feels like it
19:59:39 * ski . o O ( Stack-Stack-Overflow )
19:59:46 <edwardk> elliott: meh. too much work
19:59:53 <copumpkin> okay, I tried another approach to get static initialization
19:59:54 <edwardk> i had a small one at one point
19:59:54 <cmccann> dmwit, f (f z) b
19:59:57 <copumpkin> but it also failed :(
20:00:01 <edwardk> copumpkin: doh
20:00:09 <copumpkin> as in, it fired
20:00:14 <edwardk> how bad would the pseq'd solution be?
20:00:16 <copumpkin> but it fired before integer-gmp did
20:00:28 <edwardk> it'd at least unblock us
20:00:28 <cmccann> whereas Replicate (S (S Z)) f z = f (f z)
20:00:33 <cmccann> stupid lack of kind polymorphism
20:00:39 <copumpkin> hmm
20:01:14 <dmwit> Okay, so some kind of (possibly deeply-nested) zipWith, then?
20:01:20 <edwardk> just make one primop, call it from a thunk you put in as a CAF that you pseq before calling anything that might use the cache
20:01:20 <ski> cmccann : you should complain to implementers
20:01:26 <edwardk> that way you know the handler got installed
20:01:35 <copumpkin> yeah
20:01:46 <dmwit> I'm still deciphering arguments two and three, though.
20:01:48 <dmwit> =P
20:01:50 <copumpkin> it's nicer than this c++ static initializer thing I'm trying right now :P
20:01:50 <cmccann> dmwit, yeah it's zipWith for a flavor of type-level Nat-indexed data types
20:01:51 <edwardk> most of the time the overhead is just looking at a tag bit
20:02:23 <edwardk> actually it may be worse than that becuase its a constant reference to a caf
20:02:25 <cmccann> the horrible arguments are the "take it apart" and "put it back together" steps, made generic enough that the function with that type only needs to know about the type nat
20:02:30 <edwardk> iirc those don't get properly tagged
20:02:44 <edwardk> but it should be good enough
20:03:13 <dmwit> aha
20:03:15 <ski> dmwit : i think they want to say that `f g x' is isomorphic to `(x,g x)' for any `x' and `g'
20:03:37 <cmccann> dmwit, so I can define fixed-size data structures, and as long as I have a way to figure out their size as a type nat, I don't have to rewrite my recursive functions for each one
20:04:32 <dmwit> oh, wow, this is very different than what I had in my head
20:04:55 <hpaste_> “C. McCann” pasted “type-level nat recursion” at http://hpaste.org/50675
20:05:21 <cmccann> dmwit, there's the whole thing if you're curious
20:06:23 <dmwit> cheers
20:06:37 <Cale> data Nat a = Zero a | Succ (Nat a); instance Monad Nat where return = Zero; Zero x >>= f = f x; Succ n >>= f = Succ (n >>= f)
20:06:46 <Cale> plus m n = m >> n
20:06:47 <Maxdamantus> Is there some mechanism to help with partial derivation of Show for data declarations?
20:06:48 <Cale> lol
20:06:52 <Maxdamantus> (where I fill in the rest)
20:07:07 <Cale> Maxdamantus: hmm, maybe Data.Generics.Text.gshow
20:07:42 <cmccann> dmwit, all the weird stuff with Replicate2 is mostly for making nat-indexed data types with a single type parameter, e.g. things like fixed-length lists and such
20:07:42 <ddarius> Is this the tropical semimonad?
20:09:23 <cmccann> the main goals were 1) do all the recursive nonsense through the Natural class there, to keep everything else generic 2) not create any type constraints on the data structures other than Natural
20:09:37 <Maxdamantus> Hm. Looks crazy.
20:10:06 <cmccann> All I have is an equality constraint hidden inside a GADT saying that the type is equal to ReplicateNat2 something something etc.
20:10:26 <cmccann> the end result being that I can define instances for Functor and such without extra cruft hanging around
20:10:46 <cmccann> particularly no cruft on Applicative in order to justify constructing a value in pure
20:11:00 <ski> instances of `Functor' for your fixed-length list types ?
20:11:44 <cmccann> ski, yes, and a zippy Applicative instance
20:11:54 <cmccann> could write one for Monad but that's dumb so I won't
20:12:14 <ski> why'z eet dump ?
20:13:28 <cmccann> ski, well, think about how to implement a Monad instance for fixed-length lists such that liftM2 is zipWith
20:14:47 <cmccann> the regular list monad creates a brand new list for each element, and join concatenates
20:15:07 <ski> well, `join' here should obviously not concatenate
20:15:14 <ski> it should take the diagonal
20:15:18 <cmccann> yep
20:15:38 <cmccann> so you do a lot of work just to throw most of it away
20:15:52 <cmccann> <*> doesn't have to bother because it can construct the diagonal directly
20:15:59 <ski> well, wouldn't much of it be lazy ?
20:16:07 <cmccann> whereas the Monad instance has to build everything and then take it apart
20:16:21 <cmccann> not necessarily
20:17:05 <cmccann> for instance, I have a type nat-indexed data type of nested pairs where the "tail" is a strict unpacked field
20:17:11 <cmccann> e.g. pretending to be a tuple
20:17:19 <ski> hm
20:17:45 <ski> i wondering about applications where you'd want the monadic interface
20:18:04 <cmccann> also, you still have to traverse some stuff far enough to get the diagonal
20:18:20 <cmccann> the extreme case being the instance for infinite streams
20:18:27 <cmccann> taking the diagonal of that gets more and more fun over time
20:18:50 <cmccann> whereas <*> can be sensible and just zip the stupid things
20:19:19 <ski> is there sensible cases where you want `(>>=)' ?
20:19:42 <cmccann> not that I can think of
20:19:51 * ski wonders whether one could use zippers, somehow ..
20:20:20 <ski> (to alleviate taking the diagonal, i.e.)
20:20:46 <cmccann> given that using >>= has to create exactly the same amounts of structure every time, you can't alter the shape of things based on the values
20:20:54 <cmccann> and you only get to keep the diagonal
20:21:06 <cmccann> and the type class laws say that ap needs to agree with <*>
20:21:17 <cmccann> I'm not sure if you can even get different results from the monad instance
20:21:31 * ski isn't sure either
20:21:52 <cmccann> which would make sense, since fixed-size data structures are isomorphic to functions from a type with that cardinality
20:22:08 <cmccann> so these instances are all equivalent to Reader
20:22:27 <cmccann> and Reader's Applicative and Monad instances are equivalent by using flip
20:22:53 <cmccann> edwardk could probably answer this more conclusively :P
20:23:04 * edwardk looks up
20:23:07 <ski> hm, that argument sounds sensible
20:23:48 * ski ponders using different comonoids for the environment monad
20:24:09 <cmccann> edwardk, is it possible for the Applicative and Monad instances to differ for fixed-length ZipLists or similar things
20:24:18 <cmccann> is the question being considered
20:24:23 <cmccann> er
20:24:33 <cmccann> not the instances, I mean what you can do with >>= vs. <*>
20:24:45 <cmccann> i.e. does the Monad instance do anything other than be inefficient
20:24:45 <edwardk> for fixed length things you need to use the diagnalization monad
20:24:48 <cmccann> right
20:24:50 <edwardk> which agrees with the zippy applicative
20:25:07 <edwardk> the monad there generally just sucks ;)
20:25:18 <cmccann> ski was wondering if there's anything you can do with the monad instance that you can't do with Applicative
20:25:28 <edwardk> hrmm
20:25:44 <cmccann> based on my assertion that I could write a Monad instance for fixed-length data structures but won't because it'd be dumb
20:26:09 <edwardk> i use a variant of that monad in my graphs library
20:26:50 <cmccann> my handwavy argument is that the equivalence to Reader, e.g. functions from a type with the same cardinality as the structure size, and Reader's applicative and monad being equivalent via swap
20:26:58 <cmccann> suggests there's probably no difference
20:27:01 <edwardk> yeah
20:27:17 <edwardk> you just flip to go from (<*>) to (>>=)
20:27:49 <cmccann> I'm not completely sure that carries back over to the instances on the fixed-size data structures but I also don't see why it wouldn't
20:28:05 <cmccann> er I meant flip not swap, yes, sorry
20:28:20 <edwardk> the fixed sized structures are representable functors, so everything carries back and forth
20:28:51 <cmccann> that's the part where I figured you'd be able to answer more conclusively, yes :]
20:28:54 <Saizan> modulo lazyness?
20:28:59 <edwardk> Vec n a is a representable functor with representation Fin n
20:29:08 <edwardk> er Vec n is
20:29:35 <edwardk> sure there is probably a strictness side-condition if you allow for the infinite ziplist
20:29:46 <cmccann> edwardk, for what it's worth all of this was about attempting to justify what I was doing in this code: http://hpaste.org/50675
20:30:48 <cmccann> so yeah, no infinite streams here, heh
20:31:40 <ski> @type \split mma -> ReaderT (\rho -> do (rho0,rho1) <- split rho; ma <- mma `runReaderT` rho0; ma `runReaderT` rho1)
20:31:41 <lambdabot> forall r (m :: * -> *) a r1 r2. (Monad m) => (r -> m (r1, r2)) -> ReaderT r1 m (ReaderT r2 m a) -> ReaderT r m a
20:32:59 <Saizan> there was some discussion above of strict spines/elements and i figure some combination of those wouldn't be exactly isomorphic to an arrow type
20:33:48 <ddarius> :t let split :: Kleisli m r (r1, r2); split = split in (split >=>)
20:33:49 <lambdabot>     Couldn't match expected type `a -> m b'
20:33:49 <lambdabot>            against inferred type `Kleisli m1 r (r1, r2)'
20:33:49 <lambdabot>     In the first argument of `(>=>)', namely `split'
20:34:01 <ddarius> :t let split :: Kleisli m r (r1, r2); split = split in (split .)
20:34:02 <lambdabot>     Couldn't match expected type `a -> b'
20:34:02 <lambdabot>            against inferred type `Kleisli m r (r1, r2)'
20:34:02 <lambdabot>     In the first argument of `(.)', namely `split'
20:34:10 <ddarius> :t let split :: Kleisli m r (r1, r2); split = split in (split Control.Category.)
20:34:11 <lambdabot> Couldn't find qualified module.
20:34:20 <Saizan> :t let split :: Kleisli m r (r1, r2); split = split in (split <<<)
20:34:21 <lambdabot> forall (m :: * -> *) b r1 r2 a. (Monad m) => Kleisli m a b -> Kleisli m a (r1, r2)
20:34:37 <Saizan> :t let split :: Kleisli m r (r1, r2); split = split in (split >>>)
20:34:38 <lambdabot> forall (m :: * -> *) a r1 r2 c. (Monad m) => Kleisli m (r1, r2) c -> Kleisli m a c
20:34:40 <cmccann> Saizan, I was mentioning using nested pairs strict and unpacking in the nesting, so that it all flattens out the way larger tuples do
20:35:07 <cmccann> e.g. like (a,b,c) instead of (a,(b,c))
20:35:37 <xil> is it possible for a pipe to fill up? If that happens does it throw an error or something? I'm just trying to figure out if it's possible my problems could be from the pipe filling up too fast
20:35:48 <c_wraith> xil: generally they just block if they fill.
20:36:01 <xil> c_wraith: okay that's very good
20:36:02 <c_wraith> xil: unless the reading end is closed
20:36:03 <cmccann> so I don't think that should impact the equivalence to a function from an appropriate range of natural numbers
20:36:06 <Saizan> cmccann: ok, but then is it (a,a) or Vec 2 that is isomorphic to Bool -> a ? both seems weird
20:36:15 * copumpkin needs to shower after this horrible hack
20:36:36 <cmccann> Saizan, the idea is that (a, a), Vec Two a, and Bool -> a should all be isomorphic to each other
20:36:58 * ddarius suspects copumpkin just needs to shower.
20:37:06 <copumpkin> edwardk: want to hear what I did? :P
20:37:08 <copumpkin> ddarius: probably
20:37:12 <Saizan> but the domains of (a,a) and Vec Two a don't have the same shape
20:37:19 <edwardk> copumpkin: what'd you do?
20:37:20 <cmccann> copumpkin, I have the opposite problem, I take a shower and start thinking up horrible hacks
20:37:24 <copumpkin> it disgusts me
20:37:28 * copumpkin enters the confessional
20:37:29 <edwardk> if _you_ consider it a horrible hack, i'm scared
20:37:44 <copumpkin> edwardk: you probably won't want to use this in your library, but I think it'll work on all *nix platforms
20:37:49 <cmccann> Saizan, how so?
20:37:57 <copumpkin> so to ensure that I get the last say in which allocators are used...
20:37:58 <copumpkin> I um
20:38:12 <copumpkin> mprotect the global variables they're stored in in my initializer
20:38:17 <edwardk> hahahahhaa
20:38:23 <copumpkin> catch the segfault/bus error
20:38:27 <copumpkin> then unprotect it
20:38:29 <copumpkin> then set my own allocators
20:38:34 <copumpkin> and happily go along
20:38:35 <copumpkin> it works fine :P
20:38:39 <mustelo> haha
20:38:39 <cmccann> copumpkin, haha wow
20:38:48 <Saizan> cmccann: with Vec defined inductively there's both Cons x _|_ and Cons x (Cons _|_ Nil)
20:38:59 <edwardk> sounds good, ship it ;)
20:39:03 <copumpkin> lol
20:39:12 <edwardk> does it work?
20:39:17 <m3ga> given a package X, is there a way to search hackage for all packages that depend on X?
20:39:21 <copumpkin> yep, although I still have to write the actual allocator shit
20:39:34 <copumpkin> this is just yak shaving to get my allocators' feet into the door
20:39:36 <edwardk> write the allocator stuff then we can benchmark and see how bad this is
20:39:37 <cmccann> Saizan, no, because I'm talking about something like Cons a b = Cons a {-# UNPACK #-}!b
20:39:37 <Cale> Allocators?
20:39:38 <ddarius> copumpkin: You are basically doing the same thing as COW.
20:39:49 <copumpkin> Cale: for mpfr, to replace those integer-gmp uses
20:39:57 <copumpkin> ddarius: yeah
20:40:04 <edwardk> ddarius: well this is just a hack to install a custom allocator so we can do FURTHER nastiness
20:40:19 <cmccann> it's ugly hacks all the way down.
20:40:27 <copumpkin> yeah, the further nastiness involves inspecting the return address of the function
20:40:27 <copumpkin> it's a blast
20:40:36 <edwardk> cale: we need to replace the ghc hook into the gmp allocator with one that checks for a few places that it should let through unmolested
20:40:52 <edwardk> cale: because mpfr abuses the custom allocator to allocate its internal cache for constants like pi
20:40:52 <ddarius> copumpkin: My favorite kinds of things to do.
20:40:55 <Saizan> cmccann: so you see the point of my question now?
20:41:19 <edwardk> cale: so we need it not to hand those allocations off to ghc, but to hand everything else off like a good little citizen
20:42:05 <cmccann> Saizan, I think I'm missing what you're getting at, still
20:42:35 <cmccann> since I'm specifically talking about a type where the example you gave can't work
20:42:38 <edwardk> cale: so copumpkin came up with a horrible way to find the few calls into the allocator that we want to mask off and check the function that called the allocator to see if its one of the few we should switch to malloc for
20:43:11 <Saizan> cmccann: the point is that i was talking about another type :)
20:43:20 <edwardk> cale: but hooking the allocator after ghc is tricky
20:43:33 <cmccann> Saizan, ok. then yes, simply nesting tuples naively is not the same thing at all, which is why I'm doing something else :]
20:43:53 <cmccann> i.e. that (a,b,c) is different from (a,(b,c))
20:44:26 <cmccann> and I'm attempting to build inductively defined data structures I can work with recursively that are actually isomorphic to (a,a,a), (a,a,a,a), etc.
20:44:38 <Jafet> That sounds too horrible to actually work
20:44:48 <copumpkin> it does work
20:44:55 <ski> m3ga : <http://hackage.haskell.org/trac/hackage/ticket/576>
20:45:50 <xil> is it possible that ffmpeg is to blame for my problem, and that it's dropping some of the frames I send it?
20:45:53 * ddarius doesn't see why it would that horrible
20:45:53 <m3ga> ski: thanks
20:46:27 <edwardk> ddarius: portability across architectures for one. pain in the butt to duplicate on windows for instance
20:46:47 <cmccann> edwardk, I don't think anyone uses haskell on windows anyway, so who cares
20:46:52 <cmccann> ;]
20:46:53 <edwardk> ddarius: though we'd also have to duplicate the caller-name lookup machinery
20:46:56 <ddarius> edwardk: I'm aware of the portability issues.
20:47:18 <edwardk> cmccann: they don't? whew. glad apple took over the market
20:47:27 <Saizan> cmccann: my remark was more about the fact that we were talking about fixed-size structures in general wrt the uselessness of the Monad instance, and using their representableness(?) to prove that, but i would still consider (a,(a,a)) fixed size, and that isn't isomorphic to (Fin 3 -> a)
20:47:35 <ddarius> There's also the issue of intermediate functions being added later in mpfr.
20:47:59 <Saizan> cmccann: and i don't think there's any X such that (a,(a,a)) is isomorphic to (X -> a) ?
20:48:00 <cmccann> Saizan, ok. I see what you're getting at now.
20:48:27 <edwardk> yeah for right now it looks like each constant is cached in one place, and managed through one hok
20:48:29 <edwardk> er hook
20:48:57 <edwardk> but rampant LLVM inlining , etc could change that
20:48:59 <Saizan> i guess i'm in nitpicking mode in the morning :)
20:50:48 <cmccann> Saizan, having a _|_ appear in the middle of the nesting turns what should be a simple product into something that behaves more like something containing a sum type
20:50:59 <ski> hm, would `data X = X0 | X12 X12; data X12 = X1 | X2' work ?
20:51:01 <cmccann> which I don't think gives you a representable functor which is where this all come from
20:51:24 <cmccann> though again edwardk is the one to ask about most of this, I'm figuring too much out as I go :P
20:52:05 <Saizan> of course it's also easy to ignore bottoms in the finite case, so this is fairly academic :)
20:52:54 <Jafet> data Cons a b = Nil | Cons a !b
20:52:54 * cmccann usually prefers to politely ignore bottoms when he can get away with it, but in this case that was part of the motivation for the type hackery experiments
20:53:48 <edwardk> saizan: what keeps you from nesting the structure of X similarly to that of the pairs so you have to walk down as many branches as you would thunks ensuring the same bottom properties?
20:54:00 <ddarius> edwardk: See what ski wrote.
20:54:07 <edwardk> Either () (Either () ())
20:54:09 <edwardk> ah
20:54:10 <edwardk> yes
20:55:57 <Saizan> that might work, it's not obvious to me though
20:56:14 <ddarius> Saizan: Just enumerate all values of each type.
20:56:35 <edwardk> saizan: my representable trie for integers does just this
20:57:42 <edwardk> though i suppose i'm hiding lots of extra bottoms in there, quite the opposite of your concern ;)
21:03:45 * cmccann reflects on empirical evidence that, on average, 12-year old children seem to do better learning Haskell than commenters on /r/programming and wonders what the implications of this are
21:04:13 <c_wraith> that's easy.  They don't hate it for being different.
21:04:21 <Jafet> Their minds weren't spoiled by reddit
21:04:45 <ddarius> People on /r/programming are too busy reading/writing to reddit to learn.
21:05:25 <cmccann> apparently so.
21:06:15 <c_wraith> cdsmith's students have the advantage of just learning how to do something neat.  They don't need to fit it into any pre-conceived framework about what should be easy or hard.
21:06:37 <cmccann> seems to bolster the observation I've heard--from Tony Morris, I think?--that it's often easier to teach Haskell to non-programmers than to experienced programmers
21:07:07 <c_wraith> Tony Morris is mauke, right?  I have trouble remember real names.
21:07:21 <cmccann> don't think so
21:07:23 <azaq23> c_wraith: no, dobblego
21:07:26 <cmccann> yeah
21:07:27 <azaq23> pretty sure
21:07:45 <c_wraith> Oh
21:07:47 <c_wraith> ok
21:07:50 <cmccann> yes, that's him, just couldn't remember off the top of my head
21:07:59 <c_wraith> told you I have trouble remembering real names :)
21:09:04 <cmccann> anyway, trollish rhetorical questions aside, yes, I expect that the lack of pre-conceived ideas getting in the way plus the general enthusiasm that kids often have (and that cdsmith seems to encourage rather well) is the difference
21:11:50 <luite> I don't think it's only that, not just pre-conceived ideas, but people who already know some programming language probably expect to be actually productive after some time.
21:11:55 <luite> Just creating a program that runs on a computer isn't "magical" for them anymore, and finding out that getting productive takes much longer than expected just makes the experience much more frustrating...
21:12:16 <cmccann> luite, because they've forgotten how long it took them to learn programming in the first place
21:12:37 <cmccann> and the impatience ends up actually making things take longer because of futile attempts to treat Haskell like whatever other language
21:12:48 <luite> yeah, they might have picked up a few new languages along the way, but those never required relearning progrmaing
21:13:16 <kfish> if only haskell was all uppercase, i could automatically transfer my cobol knowledge
21:13:31 <c_wraith> lowercase letters are a new paradigm
21:14:32 * cmccann has a hard time not laughing outright at assertions about how things in Haskell are more difficult than things in whatever generic imperative language... I did tutoring when I was in college and trust me, in freshman CS courses, "setting the value at a reference" is a very, very difficult and unintuitive concept
21:15:28 <dolio> If only Haskell were just like the stuff I already know.
21:15:31 <dolio> I'd have no reason to learn it.
21:15:43 <dolio> Then it wouldn't take so long.
21:15:46 <azaq23> cmccann: If one is versatile in programming and math, the experience of seeing people struggle with questions one considers to be simple is fascinating; I've read somewhere about some university test
21:15:46 <aavogt> cmccann: surely there is a surplus of analogies for that?
21:15:46 <azaq23> where half the class regularily failed to name the values of a and b after some simple statements like "a = b + 2; b = a; " etc; couldn't cite a reference, of course
21:16:09 <cmccann> aavogt, and they help exactly as much as burrito analogies in monad tutorials
21:16:25 <c_wraith> I could use a burrito analogy
21:16:26 <cmccann> azaq23, yes, I think I know what you're remembering
21:16:33 <c_wraith> I'm hungry-analogue
21:17:00 <cmccann> and the test wasn't about if they knew any particular concept, it was whether they would settle on a consistent mental model of whatever the equals sign meant in the examples
21:17:43 <aavogt> sometimes (often) you have other symbols for assignment
21:17:57 <cmccann> the ones who had a consistent mental model almost all did well in the programming course, the ones who had no consistent interpretation mostly did poorly
21:18:21 <cmccann> aavogt, that didn't matter for the study I'm recalling
21:19:03 <cmccann> I don't recall if it even assumed assignment is what was happening, or just asked "what do you think this does?"
21:22:17 <azaq23> cmccann: If found it, the article contains a link to an actual research paper: http://www.codinghorror.com/blog/2006/07/separating-programming-sheep-from-non-programming-goats.html
21:22:52 <cmccann> azaq23, aha yes, that's what I was vaguely remembering as well
21:23:40 <dolio> Always nice to have a sheep vs. goats comparison.
21:24:01 <mmos1127_> The imperative-language programmers I worked with sometimes got two things mixed up, I think-- the difference between a program that "looks simple" during a quick scan of it, and a program that has a "simple behavior" -- that is, structured to minimze tricky unexpected behavior
21:24:02 <c_wraith> um.  yes.  good that people on both sides feel insulted by the comparison :)
21:24:25 <ddarius> "Two years ago we appeared to have discovered an exciting and enigmatic new predictor of success in a first programming course. We now report that after six experiments, involving more than 500 students at six institutions in three countries, the predictive effect of our test has failed to live up to that early promise."
21:25:41 <mmos1127_> in other words, a program that was thought-out carefully to aid an understanding of all the cases it handles was often rejected in favor of a program that looked simpler on the surface but had extremely complex, unmanageable behavior
21:26:12 <cmccann> ddarius, heh, that's nicely honest at least
21:26:42 <c_wraith> but in which way?  false positives, false negatives, or no correlation in either way at all?
21:26:58 <c_wraith> Examining how it failed would be instructive, too
21:27:08 * cmccann bookmarks the researcher's page to look through later
21:27:10 <ddarius> c_wraith: The papers are all linked.
21:27:14 <c_wraith> ah
21:28:45 <hpaste_> DukeDave pasted “Do I need to understand monad tranformers?” at http://hpaste.org/50676
21:28:57 <DukeDave> Hey gang
21:29:28 <dolio> That looks like a syntax error.
21:29:31 <DukeDave> So I think I'm failing in that paste because my two `fmap's are referring to two different monads
21:29:33 <c_wraith> DukeDave: that doesn't appear to be syntactically valid haskell.  Did the first line get messed up?
21:29:59 <c_wraith> rather, it'd be the first few lines..
21:30:44 <DukeDave> Oh, well, it's in the middle of another case :)
21:31:49 <dolio> > (+1) `fmap` id `fmap` [5]
21:31:50 <lambdabot>   [6]
21:32:24 <hpaste_> DukeDave annotated “Do I need to understand monad tranformers?” with “Do I need to understand monad tranformers? (annotation)” at http://hpaste.org/50676#a50677
21:32:41 <DukeDave> Perhaps that is clearer
21:33:11 <hpaste_> jake pasted “AbstractAlgebra.hs” at http://hpaste.org/50678
21:33:25 <DukeDave> So the left-most fmap is supposed to be mapping show over the IO monad, but it looks like it's actually mapping it over Maybe.
21:34:25 <DukeDave> show `fmap` (pGPropertyGetDisplayedString `fmap` maybeProp :: IO (Maybe String))
21:34:28 <DukeDave> Ah, I see it
21:34:44 <dolio> Your big long function name appears to return an IO something.
21:34:44 <DukeDave> That's wrong isn't it..
21:35:02 <DukeDave> This is the type:    show `fmap` (pGPropertyGetDisplayedString `fmap` maybeProp :: Maybe  (IO String))
21:35:03 <dolio> So using fmap gives you a Maybe (IO ...)
21:35:14 <DukeDave> dolio: Cool
21:35:20 <dolio> Which you're then trying to show.
21:35:20 * DukeDave needs sequence..
21:35:26 <dolio> Or, show the IO thing.
21:35:28 * DukeDave thinks?
21:35:42 <dolio> Yes.
21:35:48 <dolio> or mapM.
21:36:09 <dolio> show `fmap` longThing `mapM` ...
21:36:29 <dolio> Assuming that associates correctly, which it may not.
21:49:24 <DukeDave> dolio: Thanks for the help, got it now, much cleaner :)
21:49:26 <DukeDave> dolio++
22:02:56 <hpaste_> jake annotated “AbstractAlgebra.hs” with “AbstractAlgebra.hs (annotation)” at http://hpaste.org/50678#a50679
22:08:27 * ski wonders why hlint doesn't complain about redundant brackets in `class (Eq a) => Monoid a where'
22:09:50 <DukeDave> ski: Does it ever complain about type sigs?
22:09:59 <ddarius> Because that is arguably a good practice.
22:10:27 * ski never writes it that way, himself
22:11:47 <dreixel> maurer_: you were having trouble with the new generics stuff?
22:12:18 <ski> jakeskik : is that your paste ?
22:13:15 <maurer_> dreixel: I think I fixed it, but I haven't tested it too thoroughly yet
22:13:33 <maurer_> dreixel: https://github.com/maurer/c-storable-deriving if you're curious
22:13:54 <dreixel> I am :-)
22:15:17 <dreixel> maurer_: looks good
22:21:22 <ddarius> The hardest part of writing is starting.
22:21:50 <djahandarie> Hardest part for me is finishing
22:22:19 <ddarius> So fail fast by never starting.
22:40:56 <maurer_> dreixel: Of course, if it is actually correct it belongs in Foreign.Storable, and the CStorable class shouldn't even exist, but this seemed a reasonable way to play with it without trying to push it into storable
22:44:49 <Saizan> do you really need the split between CStorable and GCStorable?
22:44:53 <dreixel> maurer_: right, I understand that it's not integrated. But when I developed this mechanism this is exactly what I was hoping for: that standard classes could be defined generically. Hopefully you can test this and propose it to be the standard
22:45:07 <dreixel> same thing would go for NFData, for instance
22:45:15 <dreixel> Saizan: yes
22:45:33 <maurer_> Saizan: That split needs to be there. The one that doesn't need to be there is CStorable vs Storable
22:45:35 <dreixel> Saizan: note that the arguments to the classes have different kinds
22:45:52 <maurer_> The second split is artificial, and is in use to allow me to do default signatures
22:45:59 <maurer_> and implementations
22:46:09 <maurer_> The procedure for use of this would be something like
22:46:16 <maurer_> 0.) Append deriving Generic to your datatype
22:46:33 <maurer_> 1.) instance Storable YourDataType where
22:46:36 <maurer_> peek = cPeek
22:46:37 <maurer_> etc.
22:46:42 <dreixel> basically, CStorable is what Storable should now be.
22:47:09 <dreixel> then you can just say |instance Storable YourDataType|
22:47:22 <dreixel> and the generic defaults kick in.
22:47:32 <maurer_> Oh yeah, forgot a step in there, namely instance CStorable YourDataType
22:52:30 <Saizan> yeah, the Storable/CStorable was clearly artificial
22:55:07 <maurer_> Oh, hm, the CStorable hack doesn't save me :(
22:56:48 <maurer_> Hm, this is awkward
22:57:23 <maurer_> Lemme just try hacking it straight into Storable, see if that works
22:58:41 <maurer_> ...nevermind. Storable is in base
22:59:28 <maurer_> Anyone know a way to have two available default signatures?
23:01:36 <Cale> maurer_: hm?
23:01:56 <maurer_> Cale: I want to use one method when it falls into one set of typeclasses, and another method in the other case
23:02:17 <maurer_> Specifically, here I want to use a Storable instance if it exists, and if not, use my generic deriving method
23:02:35 <Cale> Which type something has is never based on the existence or nonexistence of typeclasses, as a rule.
23:02:53 <Cale> Er, on the existence or nonexistence of instances.
23:03:22 <maurer_> Cale: No, these are the default signatures
23:03:26 <maurer_> e.g. I want to be able to say
23:03:32 <maurer_> instance CStorable Foo
23:03:41 <Cale> There's no way to know when a module is being compiled that there isn't an instance of any given class.
23:03:53 <Cale> (there's only a way to know that there already is one)
23:04:00 <maurer_> I see.
23:04:12 <Cale> Because it's always okay to define instances in future modules
23:04:25 <Cale> (which is annoying in some cases, but that's how they work)
23:04:29 <maurer_> Yeah.
23:04:31 <maurer_> Hm.
23:04:50 <maurer_> Unfortunately, I can't do this the right way because I can't edit base easily
23:05:08 <Cale> Usually, you can distinguish which of two typeclasses gets used by defining newtypes.
23:05:55 <Cale> er, hmm
23:06:08 <maurer_> Cale: Have you seen the context?
23:06:09 <Cale> er, I was thinking of "which of two instances"
23:06:13 <sohum> @pl \x -> foo x == bar
23:06:13 <lambdabot> (bar ==) . foo
23:06:21 <Cale> I haven't
23:06:23 <maurer_> https://github.com/maurer/c-storable-deriving
23:06:44 <maurer_> So, I'm trying to make it easy to "copy" a Storable instance to be a CStorable one
23:06:58 <maurer_> Ideally CStorable wouldn't exist, but editing base is hard
23:07:59 <Cale> newtype Storable a = Storable a
23:08:14 <Cale> instance (Storable a) => GCStorable (Storable a) where
23:08:29 <c_wraith> Are classes and types different namespaces?  I can never remember...
23:08:41 <ddarius> No.
23:09:17 <Cale>   gcPeek p = liftM Storable (peek p)
23:09:20 <Cale> etc.
23:09:29 <c_wraith> They're never syntactically legal in the same space though, so they could be, right?  It's just a matter of making error messages better?
23:09:38 <Cale> oh, right
23:09:53 <Cale> So yeah, you'll have to use a different name :P
23:09:58 <Cale> but you get the idea
23:10:03 <ddarius> c_wraith: Currently, there is no ambiguity, no.
23:10:05 <aavogt> if you're ok with overlapping instances you can write   instance Storable a => CStorable a
23:10:52 <c_wraith> I'm more interested in the other direction.  Can you go from Generic to Storable, possibly through a wrapper?  Since so much of the FFI is in terms of Storable...
23:11:59 <Cale> http://hackage.haskell.org/trac/ghc/wiki/KindFact -- is this being done?
23:12:19 <ddarius> Cale: Yes.
23:12:25 <ddarius> Though as a branch to GHC.
23:13:50 <maurer_> aavogt: No, I did that before.
23:14:06 <maurer_> aavogt: This causes a circular instance if I try to create a Storable instance via my generalized deriving
23:15:06 <Cale> The Collection example there is cute. :)
23:15:46 <Cale> Associated type class constraints :)
23:17:53 <aavogt> maurer_: but it works when you write instances like that for specific types?
23:18:23 <ddarius> Cale: Do we have a metatheory for how that should work out?  I'm curious about the induced notion of "parametricity."
23:19:16 <Cale> Maybe the metatheory is OutsideIn(X)? I haven't read most of that paper.
23:19:28 <aavogt> if that's the case, you could settle for writing some template haskell which does those instances (which is roughly the same overhead as adding  deriving Generic)
23:19:48 <djahandarie> Some stuff had to be rewritten, so it's probably not exactly OutsideIn(X)
23:19:55 <djahandarie> I am also interested in the details of that though
23:22:17 * ddarius suspects the power to do that example is also already present albeit through a, probably not too unpleasant, encoding.
23:22:27 <Cale> I'm not too scared of it, it seems like it's only marginally more powerful than associated types alone, since you could always just define an associated dictionary-of-methods type
23:22:53 <Cale> At least, using higher rank types too :)
23:24:46 <huangyi> I've found detailed document for my previous question, implementation of primitives. For anyone interested, here is the link: http://hackage.haskell.org/trac/ghc/wiki/Commentary/PrimOps
23:33:20 <maurer_> OK, in case anyone was interested in playing with it, I just added all the base instances from Foreign.Storable to it (minus a few datatypes I couldn't import)
23:34:16 <hpaste_> maurer_ pasted “Example CStorable Usage” at http://hpaste.org/50680
23:53:54 <Saizan> i'm not aware of much metatheory at all in the OutsideIn(X) paper
23:53:59 <nyingen> @type runstateT
23:54:00 <lambdabot> Not in scope: `runstateT'
23:54:05 <nyingen> @type runStateT
23:54:06 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
23:54:17 <nyingen> @type execStateT
23:54:19 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
23:54:32 <nyingen> why is there no Monad class requirement for runStateT?
23:54:38 <Saizan> ddarius: yep, we have rmonad already
23:55:03 <Saizan> nyingen: runStateT (StateT m) = m
23:55:51 <nyingen> Saizan: I'm not sure I follow
23:56:39 <Saizan> nyingen: runStateT just extracts the "s -> m (a, s)" function contained in a StateT s m a
23:57:24 <Saizan> it doesn't use any Monad method to do this
23:57:34 <Axman6> @unmtl RWST w r s m a
23:57:35 <lambdabot> w -> s -> m (a, s, r)
23:57:48 <Axman6> @unmtl RWST
23:57:49 <lambdabot> err: `RWST' is not applied to enough arguments, giving `/\A B C D E. A -> C -> D (E, C, B)'
23:58:15 <Botje> w 11
23:58:17 <nyingen> Saizan: oh, I see what you mean
