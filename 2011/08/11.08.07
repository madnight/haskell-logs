00:02:41 <shachaf> copumpkin: You just discriminate against clear code.
00:02:49 <copumpkin> I guess so
00:03:02 <shachaf> You worry too much about types. If you want to do something, who cares what the type system says? You should be able to do it!
00:04:03 <ddarius> unsafePerformIO isn't a muzzle on the type system, though it can be used to create one.
00:05:02 <shachaf> I guess this isn't just about types.
00:05:05 * ddarius doesn't know what one would do with a Haskell to Clojure translator.
00:05:12 <ddarius> I guess it gives a path to the JVM...
00:05:22 <shachaf> Sounds like a painful path.
00:05:27 <ddarius> Indeed.
00:06:13 <copumpkin> code like that doesn't inspire confidence, either
00:06:19 <NihilistDandy> #haskell and #esoteric are currently approaching one another asymptotically
00:06:25 <ddarius> Indeed.
00:08:14 <ddarius> copumpkin: However, just consider the case for C and C++ code.  Much worse than that is happening all the time, and the developers in those languages just blithely continue.
00:08:53 <Ke> halipeto is hug beast in finnish =o/
00:08:54 <copumpkin> sure :) but he might have a credibility problem trying to get the haskell community to adopt a project that contains code like that
00:09:04 <Ke> hmm, backlog
00:10:03 <Ke> so anyone up to badmouthing haskell for the lack of non pattern matching case
00:10:10 * copumpkin goes to sleep
00:10:42 <ddarius> I'll make sure to avoid the voracious Finnish hug beast if I'm ever in Finland.
00:11:08 <Hunner> NihilistDandy: If it's asymtotic, then they'll never meet!
00:11:38 <NihilistDandy> Exactly
00:16:05 * ski . o O ( <http://web.archive.org/web/20060211020827/http://www.niksula.cs.hut.fi/~candolin/scheme/> )
00:16:53 <ski> "We also serve the Schememonster with prayers in form of procedures and sacrifice small Pascal-users to him."
00:22:57 <manateeUser> /quit
00:23:37 <ski> manateeUser : didn't work
00:26:26 <yitz> hey, we made the big time! (see the alt comment) http://xkcd.com
00:26:54 <ddarius> yitz: You're a little slow.
00:27:17 <ddarius> Also this is #haskell not #xmonad.
00:27:30 <yitz> ddarius: you mean it has already been implemented?
00:27:47 <ski> it was mentioned yesterday or something, i think
00:27:53 <yitz> yeah i know, but i consider that haskell news too
00:31:18 <yitz> in other xkcd news - for the first time in about a year, today's geohashing location is a few minutes' bus ride from my house
00:31:36 <erasmas> yitz: I hadn't seen it the alt on that xkcd -- thanks! If only we could make firefox extensions/plugins in haskell.
00:32:29 <mauke> s/alt/title/
00:33:13 <erasmas> mauke: I'm only partially conscious and typing poorly, but I meant the alt text on the image
00:33:38 <mauke> it's not an alt text
00:33:43 <mauke> it's a title text
00:34:59 * yitz views page source
00:35:05 <erasmas> it comes from the alt attribute of the image tag. usually in html the title is what goes in the head/title tag.
00:35:08 <yitz> mauke: right you are. i stand corrected.
00:35:10 <shachaf> He should duplicate all the title= attributes with alt= attributes.
00:35:21 <yitz> there's a different alt attribute
00:35:22 <shachaf> So people can be technically correct while they're being wrong.
00:35:33 <mauke> erasmas: no, it comes from the title attribute
00:35:35 <yitz> alt="Mac/PC"
00:36:03 <erasmas> ah, I see what you mean now
00:36:11 <yitz> shachaf: there are actually rules about that nowadays, having to do with accessibility
00:36:13 <isBEKaml> I believe, alt is for when the image is not viewable. title is for mouse hovers.
00:36:19 <mauke> isBEKaml: exactly
00:37:09 <isBEKaml> though that's supposedly outdated these days. alt is cruft from the old text mode internet.
00:37:39 <yitz> isBEKaml: what's old about using the internet in text mode?
00:38:05 <isBEKaml> yitz: "old" as in time, not as in usage.
00:38:08 <fengshaun> isBEKaml: elinks ftw!
00:38:39 <isBEKaml> FWIW, I sometimes browse internet from lynx (esp when I'm on the console and lazy to go over the gui prompt) :)
00:38:43 * ski prefers w3m
00:39:04 <mauke> I hear there are people who can't even see
00:39:13 <ski> (and if you want to, there's `w3m-img' even)
00:39:36 * yitz prefers telnet
00:39:48 <mauke> nc
00:39:53 <isBEKaml> telnet! now that's old
00:39:54 <ski> yeah, i recall talking to a blind person here on #haskell some years ago
00:39:54 <isBEKaml> !
00:39:59 * isBEKaml ducks
00:40:32 * ski thinks it's sad that the local library no longer provide an interface via telnet, like they used to do ..
00:43:19 <ski> (for some strange reason, he was listening to swedish white supremacy tunes while hacking haskell with a braille display. of course he didn't know any swedish, he'd just gotten a link to the music somewhere, and thought it sounded nice, while wondering what the text was about ..)
00:43:32 <yitz> the image alt text on xkcd doesn't help much for sight-impaired people - they need to read the transcript
00:44:15 <ski> (s/text/lyrics/)
00:44:41 <isBEKaml> ski: (OT) there were Swedish supremacy movements in the past? I thought Swedes were the most impartial of the Scandinavians....
00:45:09 <pikhq_> isBEKaml: Y'know, blind people also use the Internet.
00:45:50 <ski> isBEKaml : in the nineties there was <http://en.wikipedia.org/wiki/Vitt_Ariskt_Motst%C3%A5nd> ..
00:45:54 <isBEKaml> pikhq_: mate, I know. My point was alt was from the olden days of the text mode internet. Not to diss on anyone, really.
00:46:40 <isBEKaml> pikhq_: To the point, alt doesn't help blind people as some text readers skip over images.
00:47:14 <pikhq_> Sounds like a text reader bug to me.
00:47:45 <tsanhwa> hi, i like to use python codes from within haskell, is there packages for this purpose ?
00:47:47 <arcatan> ha, i remember that guy. but the songs did indeed sound nice if you disregarded the lyrics!
00:48:48 <tech2> tsanhwa: what do you mean? You want to execute something written in python, or you actually want to mix haskell and python in one application?
00:49:46 <tsanhwa> tech2: any difference? actually I want to use library written in python within my haskell code
00:50:06 <tsanhwa> I am writing app in haskell, and like to use a library written in python
00:50:38 <pikhq_> This is one of those "what are you actually trying to do" problems, isn't it?
00:50:40 <tech2> tsanhwa: you might be asking too much methinks.
00:50:59 <isBEKaml> ski: yes, neo-nazi. I never knew Sweden was also into it at one point of time. Though I have heard of a few instances in Japan.
00:51:01 <tech2> tsanhwa: what does the library do that you can't find a library for haskell to do too?
00:51:22 <isBEKaml> ski: (anyway, I don't want to pursue this further) </stop>
00:51:23 <tsanhwa> library for parsing xls files
00:52:26 <pikhq_> tsanhwa: Do you have *any* alternative to that for an input format? Seriously, down that road lies pain.
00:52:44 <pikhq_> (also, I'd imagine that's a Python binding of a C library)
00:54:11 <tsanhwa> I did consider droping support for that input format
00:54:16 <fengshaun> tsanhwa: http://www.haskell.org/haskellwiki/Applications_and_libraries/Interfacing_other_languages#Python
00:54:47 <ski> arcatan : i can't recall his nick now, though ..
00:55:07 <fengshaun> tsanhwa: or you can use a proper C library to parse xls instead: http://www.haskell.org/haskellwiki/Applications_and_libraries/Interfacing_other_languages#C
00:55:34 <tsanhwa> I have poor exprience in C programming
00:56:11 <tsanhwa> while I know much better python
00:56:48 <fengshaun> tsanhwa: read up on using C inside Haskell, I don't think you need to know much C to use it effectively.
00:57:51 <tsanhwa> fengshaun: MissingPy seems nice, I will lookat it
00:58:38 <tsanhwa> fengshaun: ok I will also try to call c library directly, that may be broadly open my choices
01:03:09 <fengshaun> tsanhwa: this should give you a head start if you're gonna be working with C code: http://www.haskell.org/haskellwiki/FFI_Introduction
01:03:13 <fengshaun> good luck :)
01:04:33 <shachaf> Also http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html , or so I hear.
01:18:26 <roastbird> is it possible to have a hashtable where the key is a data type or an empty data constructor?
01:18:35 <mreh> i never knew there were so many recursion schemes
01:19:30 <shachaf> roastbird: What does that mean?
01:19:35 <mauke> roastbird: data type: no. keys must be values, not types
01:19:46 <mauke> roastbird: empty data constructor: what is that?
01:20:11 <roastbird> i meant something like "data Key1 = Key1"
01:20:18 <roastbird> and then use Key1 as the key
01:20:37 <mauke> sure, why not
01:20:46 <mauke> it's useless but valid
01:21:31 <roastbird> but also data Key2 = Key2 in the same hashtable?
01:21:38 <mauke> no
01:21:45 <roastbird> so i could run "lookup Key1" or "lookup Key2" ?
01:21:49 <mauke> no
01:21:58 <mauke> why do you want a hashtable anyway?
01:22:07 <fengshaun> roastbird: use "Key1" and "Key2" instead
01:23:00 <roastbird> it's for something like a symbol table, but with data types as the key.
01:23:17 <mauke> symbol tables don't require hashing
01:23:43 <roastbird> how would it be done?
01:24:08 <mauke> that depends on what "it" is
01:24:51 <roastbird> no matter what, it seems like i have to store things of type (key, value)
01:25:23 <fengshaun> roastbird: [(String, Whatever)]
01:25:32 <roastbird> i thought of using "Key1" or "Key2" as the key, but in that case, i wouldn't be able to guarantee that the key will be unique
01:25:39 <mauke> why not?
01:25:42 <mauke> what does your program do?
01:26:02 <mreh> hmm, i think I need an accesible guide to category-extras
01:26:51 <yitz> mreh: category-extras is deprecated, it has been exploded into dozens of small packages
01:26:53 <fengshaun> roastbird: http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
01:27:05 <mreh> yitz: yeah I just remembered
01:27:14 <mreh> with sooo many depedencies :)
01:27:26 <tsanhwa> fengshaun: thank you :)
01:27:34 <yitz> mreh: so the good news is that the accessible guide to each one of those ought to be rather small.
01:27:36 <edwardk> =P
01:27:38 <fengshaun> tsanhwa: for what?
01:27:44 <arcatan> i don't know about guaranteeing the uniqueness of keys, but you could of course use something like data Keys = Key1 | Key2 | Key3 | ... for the keys
01:27:51 <mreh> yitz: ok, great
01:27:59 <edwardk> before you just had to build one package with 120+ modules to get the one thing you wanted, so much better ;)
01:28:13 <roastbird> it has many haskell modules, each with some monads; the monads should only run after some earlier monad has run;
01:28:25 <coppro> what.
01:28:39 <coppro> what do you mean, 'run'ning monads
01:28:54 <mreh> edwardk: where do I get started with a Histomorphism?
01:29:16 <edwardk> varmo vene had some papers on the topic
01:29:17 <fengshaun> tsanhwa: np! :)
01:29:25 <yitz> edwardk: i have found that the cabal *model* strongly encourages splitting things into many small packages, but tool support for projects that span many packages is still very primitive.
01:30:05 <roastbird> like m1 and m2 depends on m0; so "m0 >> m1" or "m0 >> m2" are valid; "m1" would throw an error after evaluation
01:30:08 <edwardk> trust me, i've been fighting with that ;)
01:30:24 <roastbird> or return a failure or something.
01:30:36 <mauke> ok, so you don't know what monads are
01:30:41 <mauke> what does your program do?
01:31:17 <yitz> edwardk: i've found that yackage servers and cabal-dev help. that and lots of shell scripts, used as duct tape.
01:31:30 <yitz> also paper clips
01:32:26 * mauke ponders a heterokey map
01:32:55 <roastbird> hm... is there a better way of doing that without monads? m0 has some side effects that goes into the monad's state before binding m1 is valid
01:33:08 <mauke> roastbird: doing what?
01:33:33 <mauke> lookup :: (Typeable k, Ord k) => HMap v -> k -> Maybe v
01:33:37 <roastbird> i'm trying to add a symbol-table that records whether m0 has been bound, so if m1 is then bound before m0 has been bound, the monad would return false or sth
01:34:04 <mauke> roastbird: that's not a "monad" and what does "bound" mean?
01:34:13 <mauke> roastbird: what does your program do?
01:35:57 * hackagebot tls 0.7.2 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.7.2 (VincentHanquez)
01:35:59 * hackagebot trifecta 0.5 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.5 (EdwardKmett)
01:37:43 <roastbird> i'm lost. i was referring to using a type T, which is an instance Control.Monad
01:38:06 <roastbird> uh, i used bind/bound to refer to the ">>" operator for monads
01:38:18 <mauke> generally "bind" refers to >>=
01:38:29 <mauke> T is a monad, but types don't "return false"
01:38:41 <roastbird> i see. sorry. then i meant ">>" (is that compose?)
01:38:52 <mauke> compose is .
01:38:56 <mauke> I don't know if >> has a name
01:39:22 <roastbird> hm... my bad for trying to associate a name with it
01:39:29 <mauke> preflex: quote . modem
01:39:36 <preflex>  <monochrom> Do not try to pronounce haskell code. You are not a modem.
01:39:52 <roastbird> heh
01:40:20 <arcatan> (i read >> as "then")
01:40:29 <roastbird> i meant that the program should fail if that happens, or the resulting monad will have type "M Failure" or something like that
01:40:58 <mauke> http://www.youtube.com/watch?v=p8XKhCfsTts
01:41:13 <mauke> there is no "resulting monad". M is a monad.
01:41:28 <mauke> monads don't have types. types are monads.
01:42:22 <shachaf> Types are burritos.
01:43:03 * mauke curses TypeRep for still not having an Ord instance
01:43:13 <mauke> but hey, that's what unsafePerformIO is for
01:43:20 <companion_cube> so if we want to make haskell more powerful, we could replace its type system by a burritos system
01:45:24 <pgiarrusso> roastbird: sorry for jumping into the discussion now. When you talked about failure ("the monad would return false"), did you mean returning Nothing?
01:45:39 <roastbird> something like that
01:46:00 <roastbird> i meant that "evaluate m1" would be of type "Maybe String", and have a value of "Nothing".  "evaluate (m0 >> m1)" would have a value of "Just somestring"
01:46:28 <pgiarrusso> OK, then it's your monadic computation that fails. But now let's get back to your problem
01:47:25 <roastbird> yup. it's okay if the program fails as well, just for my particular use case.
01:48:12 <pgiarrusso> well, of course you can give a monadic interface to that - the evaluation function must just return Nothing
01:48:36 <pgiarrusso> but it's up to you to record the dependencies and determine when to fail
01:48:49 <roastbird> so i wanted to associate m0 to some type that could be stored in a hashtable. the hashtable would be a state in the monad.
01:49:12 <mauke> why did I even bother
01:50:07 <roastbird> sorry mauke, guess i can't express myself well.
01:50:38 <mauke> you didn't even try to answer my question
01:52:07 <roastbird> sorry, which question?
01:52:17 <roastbird> what i'm trying to do?
01:52:20 <mustelo> roastbird, maybe you should give a bit more context with what you're trying to do. I'm skeptical of the fact that you're using the word "hashtable"...
01:52:43 <mauke> roastbird: yes. the question I only asked you three times
01:53:07 <mauke> all of this sounds like an XY problem
01:53:09 <mauke> preflex: ? xy
01:53:10 <preflex>  They ask how to do X, but that's because they really want to do Y but think X will get them there and most of the time they are wrong
01:54:36 <mustelo> theorem 1: x = hashtable
01:55:11 <pgiarrusso> roastbird: you talked about a symbol table, but in which context do you have it? An interpreter or a compiler?
01:55:19 <pgiarrusso> or something else?
01:55:38 <mauke> roastbird: why are you writing a program?
01:57:20 <roastbird> sorry pgiarusso: i meant something similar to a symbol table; mauke: i'm writing a program to generate java code.
01:57:36 <mauke> from what?
01:57:50 <roastbird> from haskell?
01:58:02 <mauke> you're compiling haskell to java?
01:58:21 <roastbird> no, not a compiler.
01:58:28 <mauke> then what?
01:58:35 <roastbird> more like how blaze does it with html
01:58:44 <mauke> I have no idea what that is
01:59:25 <roastbird> i don't know how to describe it
01:59:40 <mauke> then how am I supposed to code it?
02:00:09 <siracusa> I guess this is going to be a combinator library to create Java code.
02:01:09 <mauke> at this point I'm not convinced it's actually java code
02:01:17 <ksf> does anyone have pointers to cool stuff using openclraw (reverse deps hackage is down). and when is dph going to go stable?
02:01:45 <roastbird> it's alright. i'll try it on my own first. as you said, it's likely that i don't understand it well enough, which is why i'm using an approach i can't explain.
02:04:10 <ksf> also, ghc --make still doesn't use multiple cores.
02:04:23 <hpaste> vrtra pasted “traversable” at http://hpaste.org/49937
02:04:24 <ksf> I even know why: ghc itself is build with make.
02:05:43 <vrthra> hello, I was trying to modify the example in Data.Traversable to take a list of trees rather than just two trees as children of a node. I am stuck at the traverse of a node, any help would be great.
02:05:45 <vrthra> http://hpaste.org/49937
02:08:27 <edwardk> traverse f (Node l) = Node <$> traverse (traverse f) a
02:09:03 <vrthra> wow
02:09:05 <vrthra> thank you :)
02:09:22 <edwardk> also your foldr needs to be improved, it only handles the two children case
02:09:38 <edwardk> it is easier with foldMap
02:09:45 <edwardk> where you can copy the same trick almost verbatim
02:09:51 <vrthra> ok,
02:10:03 <edwardk> foldMap f (Node xs) = foldMap (foldMap f) xs
02:11:29 <augur> new cosmos!
02:17:46 <shane84_> why does `:t 3 id` have a type?
02:17:49 <shane84_> 3 id :: (Num ((a -> a) -> t)) => t
02:17:53 <shane84_> if its not useable?
02:17:59 <mauke> it is usable
02:18:01 <mauke> > 3 id
02:18:02 <lambdabot>   3
02:18:25 <shane84_> 3 id gives: No instance for (Num ((a -> a) -> t))
02:18:34 <mauke> yes, but lambdabot has such an instance
02:18:50 <mauke> and so can you!
02:18:53 <shane84_> lol
02:18:55 <edwardk> 3 is perfectly usable
02:18:58 <mauke> for the low, low price of 49.99
02:19:28 <shachaf> > 49.99 3
02:19:29 <lambdabot>   49.99
02:19:47 <roastbird> @pgiarusso: my only requirement for this is that "m0 >> m1" is valid, but "m1" alone must return a failure of some sort. i thought the naive way to do it would be to have some state within the monad, such that "m1" would check if m0 has run, i.e. "m0>>...>>m1", and "m0" would alter the state to indicate that m0 has run. meaning that i'd like to enforce some kind of dependency between m0 and m1.
02:19:47 <lambdabot> Unknown command, try @list
02:19:54 <mauke> > 49.99$ 3 id
02:19:55 <roastbird> m0 and m1 are defined in different modules, and this dependency is specified in m1's module. for all such m' depends on m, the specification of the dependency is preferrably done in m's module, and safely. in some sense, m0 performs some initialization that is required for m1 to run.
02:19:55 <lambdabot>   49.99
02:20:07 <roastbird> it seems like to store within the state whether m0 has run, i would need to associate with m0 some identifier that can be compared for equality. because there would be an arbitrary number of dependencies specified, i.e. m1 depends on m0, at a later time, someone could add m2 depends on m1, etc, it would be safer if the identifier is generated uniquely for each m. but i don't see how i could generate a unique identifier that can b
02:20:16 <shane84_> 49.99 $ 3 id
02:20:18 <mauke> > 3 id $49.99
02:20:19 <lambdabot>   3
02:20:22 <shane84_> No instance for (Fractional (a -> b))
02:20:31 <roastbird> thanks for your help anyway, but i guess i should try other sources first before asking others
02:20:31 <shane84_> ghci does not like it
02:20:41 <mauke> shane84_: yeah, you didn't load the same modules as lambdabot
02:22:32 <shane84_> what am i missing?
02:22:45 <shachaf> Try: instance Num Eq (a -> b); instance Show (a -> b); instance Num b => Num (a -> b) where fromInteger x _ = fromInteger x
02:22:48 <shachaf> (In a file.)
02:22:59 <mauke> shane84_: those Num/Fractional instances
02:29:35 <siracusa> roastbird: You can do that with the State monad. If m0 is run it modifies a flag in the state value, which is initially, say, False. If m1 is run with that flag set to False, the result of m1 is Nothing, otherwise Just someValue.
02:30:57 * hackagebot wl-pprint-terminfo 0.2.1.2 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.2.1.2 (EdwardKmett)
02:31:51 <shane84_> ok i follow
02:32:30 <roastbird> siracusa: the problem with that is that i can have a large (over a few hundred) arbitrary number of dependencies, and the number of dependencies can increase with time. so while i can set 1 flag, it wouldn't be practical to 'register' a new flag in the state every time i want to add a new dependency (which occurs when i add a new module).
02:33:49 <shane84_> can it be useful?
02:34:08 <shane84_> (3)(\x->x)
02:34:12 <shane84_> doesnt really make sense
02:34:49 <shane84_> (\x->x)(3) is reducible
02:39:04 <shane84_> like this maybe? let swap a b = b a in swap 3 id
02:39:31 <pgiarrusso> shane84_: you need to tuple the return value
02:39:42 <pgiarrusso> ah no, I see what you're doing
02:39:48 <pgiarrusso> but then the name swap is misleading
02:45:09 <siracusa> roastbird: So this is where your initial idea of a (Hash)Map is useful. m0 adds assertations of some type  to the pool (= Map) of asserations, and when m1 is executed it checks if all needed asseratations are in the pool.
02:45:57 <roastbird> i guess so. it doesn't need to be in a hashmap. it could be a property list, or anything that does the same thing.
02:47:06 <pgiarrusso> roastbird: so basically you want to have both a State and the possibility to give errors and terminate the computation
02:48:11 <pgiarrusso> @unmtl StateT s Maybe a
02:48:11 <lambdabot> s -> Maybe (a, s)
02:48:16 <roastbird> i keep thinking of attaching a unique identifier to each m0, but i don't quite seem to know how to do it (trying to use unsafePerformIO to generate unique Int). if i could use a data type constructor like "M0" as a key, it is pretty to guarantee that it's unique. i'll just define it in the module where i define m0, and insert it into the hashtable (or any other state structure) when m0 is run.
02:48:51 <pgiarrusso> roastbird, in your state you can keep also a unique id
02:49:00 <roastbird> how?
02:49:16 <pgiarrusso> do you know the state monad?
02:49:16 <roastbird> *pretty easy to guarantee
02:49:24 <roastbird> yup. i'm using it.
02:49:59 <pgiarrusso> Well, instead of State Data.Map.Map, you want State (Int, Data.Map.Map)
02:50:13 <roastbird> how do i generate the unique id if it's an Int?
02:50:24 <ski> > (3)(\x->x)  -- shane84_
02:50:24 <lambdabot>   3
02:50:47 <pgiarrusso> then to generate the unique int you simply take the current int, store it + 1 in the state, and return the value you had read
02:50:50 <argiopeweb> > id 3 -- ?
02:50:51 <lambdabot>   3
02:51:37 <pgiarrusso> isn't that what you're using unsafePerformIO for?
02:51:41 <roastbird> ah.. but in my situation, the unique ID has to be generated outside the state monad.
02:52:18 <roastbird> i.e. i have a haskell module that generates a java module that does something.
02:52:54 <pgiarrusso> well, you wanted to use "M0" as key
02:53:46 <pgiarrusso> so either you can use arbitrary id (and then my proposal works) or you can't (and then it seems to me that your M0 proposal doesn't work)
02:54:13 <roastbird> in another haskell module2, i use a Monad from haskell module0 (say m0), so haskell module2 has monads that have a dependency on m0.
02:54:27 <siracusa> > (+) 1 2 3
02:54:28 <lambdabot>   3
02:54:29 <pgiarrusso> Btw, if you have data M = M0, you can indeed use it as a key - depending on the map, you need to have either an Ord instance or sth like that (dunno for hashmaps)
02:54:30 <roastbird> in a 3rd haskell module3, i use m0, so haskell module3 has a dependency on m0 too
02:55:16 <pgiarrusso> I'm not sure what you're saying... when you have (m0 >> m1), m0 and m1 are not monads, but _monadic actions_.
02:56:21 <roastbird> thanks. i meant _monadic actions_.
02:56:39 <pgiarrusso> roastbird: you mentioned the idea of storing an id inside each monadic action, to mark an action as executed or not, and that sounds pretty reasonable
02:57:18 <roastbird> but if i run say "m0 >> m2 >> m3", m2 has to check whether m0 has run. so m2 has to check based on a unique id from m0, but that unique id has to be shared outside the monad.
02:57:27 <roastbird> m0 doesn't get to generate a uniqueid within the monad
02:58:21 <pgiarrusso> Ah right
02:58:28 <roastbird> can i define data M = M0 in one module, and then add more constructors for M, like M1, in another module?
02:58:39 <pgiarrusso> roastbird: that you can't
02:58:57 <pgiarrusso> you need to pass around the unique id in the code which constructs the monadic actions, not in the code that composes them
02:59:01 <roastbird> or something similar? if i could do that somehow, then the key would be of type M, and i could arbitrarily add IDs
02:59:14 <siracusa> roastbird: You can define a class M and add instances M0 and M1
02:59:34 <pgiarrusso> siracusa: but instances are not values
03:00:14 <siracusa> No, but a class function could return an unique id for an instance
03:00:34 <roastbird> i tried  Key k => [ ( k , String ) ], but it doesn't work for the standard reasons
03:00:57 <pgiarrusso> roastbird: instead of having M0, M1, you could have simply "M0" and "M1" - they're just as unique
03:01:33 <pgiarrusso> siracusa: I see, but which instance is used is determined statically at the "original call site"
03:02:08 <pgiarrusso> your idea might still work depending on the use case
03:02:37 <roastbird> pgiarrusso: what happens if i wrote around 80 modules, and I can't remember whether the latest one is "M85", or "M86"?
03:03:32 <roastbird> siracusa: i know a class function can return an id. how would u make it unique?
03:04:09 <siracusa> The easiest would be hardcoding an unique id.
03:04:14 <pgiarrusso> ah, you need your program to remember it - do you generate id manually? Anyway, in the other case (with data constructors) the difference would be of getting a compile error
03:04:50 <pgiarrusso> roastbird: what is Key k => [ ( k , String ) ]?
03:04:57 <pgiarrusso> Is Key a typeclass somewhere?
03:05:22 <roastbird> yes, defined as "class Key a"
03:05:41 <roastbird> no i mean uh. i define "class Key a", and then use it.
03:06:22 <pgiarrusso> and is that an instance declaration?
03:06:38 <roastbird> it would be nice if i could do    foo M0 (Key M0) = True and foo M0 (Key M1) = False
03:07:46 <roastbird> er, i mixed up my data and class definitions, but otherwise, it would be nice to be able to do that
03:09:02 <pgiarrusso> roastbird: Sorry, I can't follow
03:09:08 <roastbird> like if i could define "data Key = Key a", where a is any type variable, or so on. there's a similar to try doing it using class, like "class Key t", and "instance Key M0"
03:09:19 <roastbird> sorry, let me type it out again
03:09:24 <siracusa> roastbird: There's also a more hackish way to do it: For each property create a phantom type and store it's TypeRep as key.
03:09:35 <siracusa> *its
03:10:08 <pgiarrusso> @info TypeRep
03:10:08 <lambdabot> TypeRep
03:10:44 <siracusa> It's in Data.Typeable
03:11:14 <pgiarrusso> I just checked that TypeRep is an instance of Eq
03:11:40 <pgiarrusso> so then you can compare different types
03:11:54 <roastbird> i thought TypeRep represents each type as a String? would i be required to ensure that, during instance declaration, the strings that i give are unique?
03:12:30 <roastbird> i see the source of TypeRep as something like... "INSTANCE_TYPEABLE0(Bool,boolTc,"Bool")"
03:13:25 <pgiarrusso> I think you can just say "deriving Typeable"
03:13:39 <pgiarrusso> and then values of type TypeRep are just built through
03:13:41 <pgiarrusso> :t typeOf
03:13:42 <lambdabot> forall a. (Typeable a) => a -> TypeRep
03:14:36 <siracusa> Hhm, I don't know if "typeOf Module1.T == typeOf Module2.T" would return True
03:15:02 <mauke> it wouldn't
03:15:30 <roastbird> oh.. let me try that
03:15:50 <pgiarrusso> siracusa: but do you want that?
03:16:06 <siracusa> No, that would be bad
03:16:17 <roastbird> i was hoping that i could have
03:16:26 <roastbird> data M0 = M0; data M1 = M1; data M2 = M2
03:16:27 <pgiarrusso> data Key = forall a. (Typeable a) =>Key a
03:16:27 <pgiarrusso> f :: Key -> TypeRep
03:16:28 <pgiarrusso> f (Key a) = typeOf a
03:16:33 <roastbird> class Key t; instance Key M0; instance Key M1; instance Key M2
03:16:37 <roastbird> initList = [ M0 , M1 ]
03:16:40 <roastbird> foo :: Key k => [k] -> k -> True
03:16:43 <roastbird> isInitM0 = foo initList M0 -- === True
03:17:20 <pgiarrusso> roastBird, with the code I wrote, you don't even need those instances - you can directly compare different TypeReps
03:18:13 <pgiarrusso> I'm completing it with an instance declaration of Eq Key
03:18:20 <pgiarrusso> Key is the type you wrote before
03:18:45 <roastbird> thanks. i think i could.
03:20:12 <mreh> how can I keep a mutable reference to the last element whilst I'm mapping over some structure?
03:20:36 <mreh> unless you have a better idea
03:20:46 <pgiarrusso> roastbird: there's a couple of tricks needed
03:21:21 <hpaste> “Paolo G. Giarrusso” pasted “Comparing types” at http://hpaste.org/49938
03:22:12 <pgiarrusso> Actually, the language pragmas were suggested by GHC
03:22:25 <pgiarrusso> Here's the results after loading the script:*Main> list !! 0 == list !! 1
03:22:26 <pgiarrusso> False
03:22:26 <pgiarrusso> *Main> list !! 0 == list !! 0
03:22:27 <pgiarrusso> True
03:24:25 <pgiarrusso> siracusa: thanks for the tip
03:24:37 <pgiarrusso> I just executed it and learned something
03:25:03 <siracusa> Nice :-)
03:25:13 <Leif_Bork> Hi!
03:25:23 <Leif_Bork> I have a function, cmpObjCluster that takes two arguments. I wish to map two lists containing arguments to this function in parallel.
03:25:36 <mreh> :t zip
03:25:37 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
03:25:39 <mreh> :t zipWith
03:25:40 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
03:26:25 <mreh> \xs ys -> zip xs ys . map . uncurry
03:26:31 <mreh> :t \xs ys -> zip xs ys . map . uncurry
03:26:32 <lambdabot>     Couldn't match expected type `a -> b'
03:26:32 <lambdabot>            against inferred type `[(a1, b1)]'
03:26:32 <lambdabot>     In the first argument of `(.)', namely `zip xs ys'
03:26:42 <mreh> what am I doing
03:27:34 <Leif_Bork> But with regular map, will it be run in parallel?
03:27:37 <mreh> type safetly, electronically limiting your stupidity
03:28:52 <mreh> Leif_Bork: only if f is strict
03:29:15 <shachaf> mreh: What?
03:29:28 <mreh> it depends what he means
03:29:52 <mreh> what are we talking about?
03:30:37 <mreh> parallel as in multiple threads of execution?
03:30:44 <Leif_Bork> Yep
03:31:08 <roastbird> pgia: got it. thanks =)
03:31:12 <shachaf> The "two list" thing and the "parallel" thing are completely unrelated questions.
03:31:22 <Leif_Bork> I guess I need parMap or parZipWith
03:31:51 <mreh> the lines of parallel computation don't go down the lists, they go across
03:31:59 <Leif_Bork> Yes, I wonder only about the parallel, because I don't understand strategies
03:32:40 <mreh> i've never managed to get it working on any machine unfortunately :(
03:33:11 <Leif_Bork> Damn
03:33:28 <mreh> i've only got two core machines, i've been told that might be a problem
03:35:25 <Leif_Bork> But somebody here must have used parMap for example
03:36:39 <mreh> you have to get GHC to compile it as threaded, specify how many OS threads you want
03:38:46 <telephone_> Do any body have the following vim-script: when code selected (visual mode), pressing '-' two times comments out that selection. ?
03:39:39 <telephone_> There should also be a vim-page on the haskell wiki. (maybe I shall start it)
04:13:46 <mreh> :t mapM . newSTRef
04:13:46 <lambdabot>     Couldn't match expected type `a -> m b'
04:13:47 <lambdabot>            against inferred type `ST s (STRef s a1)'
04:13:47 <lambdabot>     Probable cause: `newSTRef' is applied to too many arguments
04:13:52 <mreh> :t mapM newSTRef
04:13:53 <lambdabot> forall a s. [a] -> ST s [STRef s a]
04:14:13 <mreh> i'm glad that's valid
04:14:41 <mreh> STRef s (STRef s a) -- that's a pointer!
04:15:52 <knoc> I tried to install hoogle via cabal but it reports this http://hpaste.org/49939
04:16:06 <mreh> i tried that yesterday
04:16:35 <knoc> Why is every base-4. packet excluded?
04:17:12 <mreh> i think this is one of cabal most cryptic messages
04:17:57 <knoc> yeah, I cannot figure out what that means
04:18:16 <mreh> you've probably got a library in your depency resolution that depends on base-3
04:18:28 <mreh> dependency*
04:18:57 <mreh> what ghc are you using?
04:19:10 <knoc> 6.10.4
04:19:26 <knoc> im on gentoo amd64
04:19:52 <mreh> unix-2.4.2.0 was released with ghc7
04:19:55 <knoc> I have masked a whole lot of packaged like described in the haskell.org/wiki
04:19:58 <mreh> did you install it manually?
04:20:07 <gienah> knoc: ghc 7.0.4 is in the gentoo haskell overlay
04:21:13 <merijn> @where lambdacats
04:21:13 <lambdabot> http://tinyurl.com/lambdacats
04:22:19 <knoc> gienah: gienah If I add that overlay, must I just remove the masked haskell packages from /etc/portage/package.mask ?
04:22:43 <knoc> and everything works after updating/upgrading? ^^
04:23:09 <gienah> knoc: to use the gentoo haskell overlay you need to mask >=dev-lang/ghc-7.2, and unmask everything else
04:24:01 <gienah> knoc: yes after unmasking heaps of stuff you can emerge dev-haskell/hlint and dev-haskell/hoogle, then run hoogle data to build the database as root
04:24:45 <gienah> knoc: there's an irc channel: #gentoo-haskell
04:25:01 <knoc> gienah: ok, thanks for helping
04:25:16 <gienah> knoc: no worries
04:25:19 <mreh> i wouldn't bother unless there is a requirement for you to use the latest version of unix
04:25:25 <mreh> the hackage library
04:26:22 <mreh> deleting your .cabal and starting again with (maybe with cabal-dev) would seem the easier alternative to me
04:26:53 <knoc> mreh: i deleted .cabal before pasting the paste
04:27:39 <gienah> mreh: possibly, I never use cabal-dev. gentoo has the haskell-updater program to rebuild broken packages when stuff is updated.
04:28:16 <gienah> cabal-dev is also in the gentoo-haskell overlay
05:03:12 <kizzx2> after barging through several papers on Type Families, i attempt to write a "Type Family for Dummies" sort of tutorial, here is the draft of the concept      http://ideone.com/fpTvC      comments welcome (i wonder if i am understanding type families correct usage or being totally wrong about it?)
05:11:06 <derivingShow> i've got 'data Foo = F { foo :: Integer, bar :: [Int] }', but i want bar to have a special length so that e.g. 'length bar == 5'. how can i do that?
05:11:31 <kizzx2> derivingShow: probably #agda
05:11:42 <derivingShow> huh?
05:11:47 <kizzx2> derivingShow: you can make Foo an ADT and provide a constructor that yields Maybe Foo
05:11:52 <kizzx2> so an invalid Foo cannot be constructed
05:12:03 <kizzx2> afaik what you want is dependent type
05:12:28 <kizzx2> which from what i know Haskell doesn't inherently do (there are advanced type trickeries to get that, but that's the basic idea)
05:12:34 <Entroacceptor> derivingShow: or maybe just using n-tuple?
05:12:43 <merijn> kizzx2: Actually, there is work being done on type level naturals atm
05:12:44 <Entroacceptor> (Int, Int, Int, Int, Int)
05:12:45 <derivingShow> could you give me a (good) link concerning that issue, please?
05:12:52 <derivingShow> Entroacceptor: hmm, good idea :)
05:13:00 <derivingShow> but the lenght is dynamic...
05:13:02 <derivingShow> so..
05:13:14 <kizzx2> since length == 5 is an invariant
05:13:21 <merijn> kizzx2: So while we won't have full dependent types we will be able to use natural numbers in a dependent way :)
05:13:28 <derivingShow> 'length bar = anotherFunction' where anotherFunction is defined in the code somewhere
05:13:28 <kizzx2> so (Int,Int,Int,Int,Int) conveys that information in the type systme, and user does not need to use length on it
05:14:47 <derivingShow> hmm.. i'd like a link pls =)
05:14:49 <kizzx2> merijn: that sounds cool, any links?
05:15:20 <isBEKaml> merijn: there was a recent thread in haskell-beginners too askimg about restricting numbers to positive ones only. Somebody suggested dependent types and haskell doesn't currently do that ATM.
05:16:07 <derivingShow> whats ATM?
05:16:13 <kizzx2> at the moment
05:16:14 <derivingShow> at the moment,.. i see..
05:16:33 <merijn> kizzx2: http://hackage.haskell.org/trac/ghc/wiki/TypeNats
05:16:36 <kizzx2> isBEKaml: i guess that particular case straightforward to achieve with phantom type?
05:16:37 <derivingShow> So, there's no simple solution for this problem??!?
05:16:44 <merijn> kizzx2: It's not fully implemented yet, afaik
05:16:56 <kizzx2> derivingShow: i think your problem is not posed correctly
05:17:03 <derivingShow> why?
05:17:09 <isBEKaml> kizzx2: I don't know if we have phantom types in haskell, either.
05:17:14 <kizzx2> if the user must supply 5 ints to construct Foo, why not convey that in the type system explicity? (i.e. (Int,Int,Int,Int,Int))
05:17:27 <merijn> derivingShow: Well, if its used in a module you can simply not export the constructor and instead only export a creation function for that type (which enforces the invariant)
05:17:41 <derivingShow> as i said.. the length of the list is defined in the source code somewhere else!
05:18:04 <derivingShow> merijn: cool, that's a very nice idea, yea =)
05:18:24 <kizzx2> argh, isn't that what i said earlier !? :P
05:18:35 <merijn> kizzx2: I dunno, read over that if you did :p
05:18:36 <derivingShow> oops :D
05:18:38 <kizzx2> isBEKaml: is it phantom type here? https://secure.wikimedia.org/wikibooks/en/wiki/Haskell/GADT
05:19:34 * kizzx2 shamelessly advertises again while the channel is heated
05:19:38 <kizzx2> after barging through several papers on Type Families, i attempt to write a "Type Family for Dummies" sort of tutorial, here is the draft of the concept      http://ideone.com/fpTvC      comments welcome (i wonder if i am understanding type families correct usage or being totally wrong about it?)
05:20:47 <kizzx2> derivingShow: you can look at the GADT link above, it has a "Safe List" implementation using GADT, so that `head` is guaranteed to succeed, enforced by teh type system
05:21:49 <derivingShow> kizzx2: thank you. thank you, too, merijn :]
05:25:09 <zong_sharo> is there any up to date tutorial (or any introduction whatsoever) on atom?
05:29:29 <isBEKaml> kizzx2: hmm, that looks like phantom types, yes. but the thing is, how would you restrict an input, say an Int to be only of positive numbers? Moreover, with phantom types, it looks like you throw away type checking in value cnostructors.
05:30:03 <JuanDaugherty> it would be great if there was someplace where there were reviews/ratings of haskell packages
05:30:10 <kizzx2> isBEKaml: you can check whether the input is positive in the value constructor and "Tag" the phantom as Valid or Invalid
05:30:12 <isBEKaml> kizzx2: s/throw/& away/
05:30:21 <kizzx2> isBEKaml: other operations can propagate this info
05:31:11 <isBEKaml> kizzx2: How would you do that?
05:31:28 <isBEKaml> kizzx2: ie. check positiveness in value constructor.
05:31:36 <kizzx2> isBEKaml: i dunno, i'm not one of those one-liner spitting wizards yet, lemme try it right now :P
05:34:06 <kizzx2> isBEKaml: you're right, turns out you can't :P
05:38:38 <kizzx2> isBEKaml: yeah i was mixing up the concepts.. turns out the Safe List example of phantom type can only encode static information (which is normal)
05:39:16 <kizzx2> mkPosInt :: Int -> Maybe PosInt is probably closest to mortals can get
05:40:54 <isBEKaml> what's in PosInt? :)
05:41:18 <kizzx2> oh, just a `newtype Int` with the invariant coded
05:41:28 <kizzx2> and PosInt will be utterly uselss, because it can't be made an instance of Num, the return type of (-) cannot guarantee PosInt's invariant
05:41:54 <isBEKaml> kizzx2: :)
05:42:27 <kizzx2> in fact i cant imagine how any type system can gaurantee the positive of a number, unless no subtraction can be performed on that type
05:43:50 <isBEKaml> you mean substraction as in an operation or substraction as in a subset type?
05:45:05 <kizzx2> i dunno whats a subset type :(
05:45:38 <isBEKaml> PosInt subset of Int (atleast, that's what I think)
05:46:46 <kizzx2> can haskell do subset types?
05:47:16 <isBEKaml> no, if it were able to, you could solve that PosInt problem. :)
05:47:24 <kizzx2> subset type as in something like this?       http://perlgeek.de/blog-en/perl-5-to-6/21-subset-types.writeback
05:47:24 <kizzx2> wow, even perl has it
05:47:58 <isBEKaml> kizzx2: that's perl6. That language is a WIP.
05:48:15 <kizzx2> yeah
05:48:24 <kizzx2> wow, even perl may have it
05:49:50 <merijn> Hah
05:49:51 <isBEKaml> kizzx2: perl5 backports certain stuff from perl6, but not all.
05:50:00 <merijn> Perl6 is the Duke Nukem Forever of programming languages...
05:50:23 <merijn> kizzx2: For the record, the only remotely working Perl6 implementation is written in...Haskell :p
05:50:33 <merijn> (Last I checked anyway)
05:50:34 <kizzx2> merijn: really?
05:50:46 <kizzx2> that's really wow
05:50:55 <isBEKaml> merijn: Not really. DNF never released, but Rakudo was released several times last year and is still on a monthly release cycle.
05:51:08 <merijn> isBEKaml: DNF did release...
05:51:30 <isBEKaml> kizzx2: There are several implementations in progress. Rakudo on parrot VM, Niecza runs on CLR.
05:52:08 <isBEKaml> merijn: Oh, really? that would make for a poor joke on DNF. :)
05:52:25 <merijn> isBEKaml: A few months back, the reviews said it was basically terrible
05:52:55 <isBEKaml> merijn: clunky work, hacked together in days, I think. :P
05:54:44 <isBEKaml> kizzx2: for more info on perl6, you can join the IRC channel or try http://perl6.org
05:55:37 <__pao__> I all, I was reviewing Text Eq instance implementation and I was woundering if the case a == a is optmized... from what I've seen the optimization is left to libc memcmp... is that correct?
05:55:48 <__pao__> * Hi all
05:57:05 <kizzx2> are type families "usually" slower than GADT + fundeps because of the overhead of type classes?
05:57:37 <kizzx2> s/are type fam/in general, are things implemented in type fam/
05:58:30 <pao> kizzx2, I guess not
05:58:45 <pao> kizzx2, what leads you to think that?
05:59:05 <kizzx2> pao: for example, here is my attempt to implement a "type safe DSL compiler" using type families            http://ideone.com/fpTvC
05:59:32 <kizzx2> i dunno if i'm doing it stupidly
05:59:47 <kizzx2> but `data Expr = Number | Add Expr Expr` became a type class
06:00:05 <kizzx2> and here http://www.haskell.org/haskellwiki/Performance/Overloading     says "Haskell's  overloading (using type classes) is elegant, neat, etc., etc., but it is death to performance in an inner loop"
06:00:35 <kizzx2> * but where one would usually say `data Expr = Number | Add Expr Expr` became a type class
06:01:40 <mm_freak_> kizzx2: consider that after compilation all type informations are gone
06:01:44 <mm_freak_> that should answer your question
06:01:45 <pao> kizzx2, I guess GADT + fundeps are not better performing that type classes... Have you tried both approaches?
06:01:53 <kizzx2> pao: no, i'm just speculating
06:02:10 <kizzx2> mm_freak_: the above wiki quotes "  Each type class constraint on an overloaded function corresponds to an extra argument passed at runtime (called a dictionary) "
06:02:13 <kizzx2> mm_freak_: ?
06:02:18 <mm_freak_> the only thing left are dictionaries, as far as they are needed at compile time, and i think that only happens when you use higher rank types
06:02:36 <mm_freak_> s/at compile time/at runtime/
06:03:20 <mm_freak_> type families are equivalent to a special case of fundeps (where the arrow points in one direction only), so they have the same runtime overhead
06:03:30 <kizzx2> pao: but why would GADT + fundeps not be performing better, if type families (type classes) *may* carry a dictionary with them?
06:04:03 <kizzx2> does GADT + fundep also result in some form of dictionaries? (now that i say it, i think i may have read that it is actually the case)
06:05:19 <pao> kizzx2, mm_freak_ gave you the best answer... as I suspected the runtime overhead should be exactly the same
06:06:48 <kizzx2> mm_freak_: umm since type classes are known to carry dictionaries with them, does that mean fundep may introduce dictionaries? (that would be required for "type familes must be no slower than fundeps" to hold)?
06:08:21 <kizzx2> btw if anyone wants to point out total error in conception in my Type Family exercise i'd really love to be humiliated
06:08:27 <kizzx2> lol
06:12:00 <pao> kizzx2, fun dep _may_ introduce dictionaries
06:13:19 <kizzx2> that's good to know (i guess i can prove it for myself and write about it when i am more advanced)
06:14:10 <stevex> hi - what's the difference between Random and System.Random?
06:14:30 <kizzx2> @hoogle Random
06:14:41 <kizzx2> oops
06:14:43 <kizzx2> http://haskell.org/hoogle/?hoogle=Random
06:14:46 <kizzx2> i think there are no difference
06:15:14 <identity_> The former might be deprecated
06:15:20 <identity_> Like with Maybe and Data.Maybe
06:15:30 <identity_> same module but you should use the latter, IIRC & AFAIK
06:31:39 <identity_> Uhm.. I'm importing System.IO and it's giving me "not in scope hPutStrLn" whilst I'm using stderr from system.io in the same function and it works fine
06:31:42 <identity_> what the hell
06:31:59 <identity_> + ghci isn't allowing me to tab-expand System.IO.[tab]
06:32:02 <Entroacceptor> @hoogle hPutStrLn
06:32:14 <Entroacceptor> @hayoo hPutStrLn
06:32:21 <Entroacceptor> mh
06:33:09 <identity_> Entroacceptor: http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
06:33:13 <identity_> it's there
06:33:15 <Entroacceptor> yeah
06:33:17 <Entroacceptor> sounds broken
06:34:15 <identity_> this is very strange indeed
06:34:40 <identity_> now I just confirmed that it's in my system.io as well
06:35:25 <LeNsTR> identity_: whats happens if you try import directly form "GHC.IO.Handle.Text"?
06:35:32 <identity_> hmm
06:35:38 <kamatsu> in Haskell, i want to have a Map from, let's say strings (they're not but let's say they are) to a certain data type
06:35:56 <kamatsu> this data type represents processes (or actors), which accept messages of a certain type.
06:36:16 <kamatsu> different actors have different message types
06:36:34 <identity_> LeNsTR: If I import it and do not use hPutStrLn in my function, it is imported confirmed with ghci
06:36:45 <identity_> if I try to use it in my code, it tells me it's not in scope
06:37:01 <mreh> is ST magic?
06:37:10 <LeNsTR> hm
06:37:17 <LeNsTR> sadly
06:37:31 <identity_> wot
06:37:33 <identity_> the hell
06:37:41 <kamatsu> I can't think of a way that doesn't involve dependent types to make it possible to, in a type-safe way, take a process value out  of a map with its string key, send it a message
06:37:42 <identity_> added "foo = hPutStrLn" in my code
06:37:48 <identity_> it compiled
06:37:49 <identity_> what the hell
06:38:14 <kamatsu> fundamentally the problem I think I'm facing is I desperately want my types to be dependent on runtime values
06:38:23 <kamatsu> and that's not going to fly
06:38:47 <identity_> LeNsTR: Nvm, thanks. Probably was some invisible character
06:38:53 <merijn> kamatsu: How do the actors send messages?
06:39:30 <kamatsu> merijn: the act of sending it isn't the problem, so much as the educating the type system as to what type the expected messages are based on an atom key.
06:39:37 <kamatsu> i know it's impossible with haskell's type system
06:39:45 <kamatsu> what I'm looking for is workarounds that don't involve Data.Dynamic
06:41:05 <ClaudiusMaximus> kamatsu: http://hackage.haskell.org/packages/archive/polytypeable-utils/0.1.0.0/doc/html/Data-PolyTypeable-Utils.html perhaps (i was recommended it some years ago, on a project i abandoned due to too much pain..)
06:41:40 <ClaudiusMaximus> kamatsu: never used it though..
06:41:53 <merijn> kamatsu: Well, if you use Chan's for communication (for example) then the act of sending is just type "a -> IO ()" which can be easily wrapped in such a way that the send function for all your actors return IO (), (which means you can just have an Actor typeclass supporting this send function) and the Chan's will enforce proper typing for the receiver
06:42:04 <erus`> ClaudiusMaximus: what was the project?
06:42:16 <merijn> kamatsu: Unless I misunderstand your problem?
06:42:56 <ClaudiusMaximus> erus`: embedding Haskell into Pure-data  ( http://puredata.info )
06:43:28 <erus`> http://puredata.info/dbimage.jpeg lol
06:43:54 <erus`> thats a real user interface
06:44:15 <ClaudiusMaximus> i think someone was showing off
06:45:00 <kamatsu> merijn: no, not the problem.
06:45:17 <kamatsu> merijn: the problem is that maps are typically homogenous
06:45:48 <kamatsu> merijn: if i want a heterogenous map (on the value side), if i use an existential type there's no way the type checker can recover that information
06:45:59 <merijn> kamatsu: True
06:46:50 <merijn> kamatsu: You could maintain multiple maps (one for each actor type) and try a lookup in each?
06:48:01 <kamatsu> not feasible, i think i have a solution though, give me a minute
06:48:17 <ClaudiusMaximus> ^ that's what i do in some C++ code of mine, seems to work ok with enough CPP to make writing switch() less painful
06:48:24 <kamatsu> in order for this to make any sense, the types of the actor's message has to be known to the programmer
06:48:37 <kamatsu> so i'm trying to reify the atom id's of the message into a type.
06:50:39 <ClaudiusMaximus> maybe something like xsd2hs or whatever it's called (the one that turns xml schemas into a collection of haskell types and stuff) would work?  i mean, a completely open API isn't much of an I
06:54:01 <ClaudiusMaximus> http://hackage.haskell.org/package/HaXml was what i was thinking of (XsdToHaskell)
06:58:59 <chenwl> how to take off 'Right' for (Right 10)
06:59:23 <ion> What do you want to do with the value? What do you want to return?
06:59:36 <Botje> what if it's left?
07:00:06 <ion> :t either
07:00:46 <ion> either :: (a -> c) -> (b -> c) -> Either a b -> c
07:00:55 <ion> (<$> Right 10) :: Num a => (a -> b) -> Either a1 b
07:03:29 <chenwl> Botje: I want to take off every (Monad m) => m a to be a
07:03:49 <chenwl> Just 10 to be 10
07:04:02 <chenwl> Right 10 to be 10
07:04:23 <susanoof> how come "x * $ y + z" doesn't work? i would expect it to be the same as "x * (y + z)", but i get a parse error on the $
07:04:24 <Entroacceptor> but it can be Left "lol"
07:05:34 <Entroacceptor> you can pattern-match to remove it
07:05:37 <ion> chwnel: (>>=) :: Monad m => m a -> (a -> m b) -> m b
07:05:57 <ion> The (a → mb) gets the ‘a’ from ‘m a’.
07:06:31 <ion> (<$>) :: Functor f => (a -> b) -> f a -> f b
07:06:35 <Entroacceptor> or fmap :: Functor f => (a -> b) -> f a -> f b
07:06:36 <Botje> chenwl: uh, you're generally not supposed to do that
07:06:41 <ion> The (a → b) gets the ‘a’ from ‘f a’.
07:07:11 <Entroacceptor> but I think he's missing some basic knowledge about types
07:07:11 <chenwl> Botje: what should I do, if I want to get the content
07:07:26 <Botje> chenwl: can you step back a bit and explain why you need this?
07:07:28 <Entroacceptor> chenwl: please elaborate, do you have code?
07:08:40 <identity_> Does the author of aeson come here?
07:09:01 <chenwl> I write a function to return Either Bool Int
07:09:14 <Botje> susanoof: $ is a real operator, it's not just syntax. so ghc expects an expression on the left side and an expression on the right
07:09:15 <luite> identity_: yes, bos
07:09:18 <Botje> x * is not a valid expression
07:09:26 <Botje> you could do (x *) $ y + z
07:09:28 <chenwl> drop  (Left False)
07:09:31 <Botje> but that kind of defeats the point :)
07:09:49 <chenwl> get the first element Right 10
07:09:57 <chenwl> now , I want the 10
07:10:40 <Botje> chenwl: there's a rights function in Data.Either that only grabs the Right elements from a list
07:10:45 <identity_> How did the tell feature work again?
07:10:48 <ion> chenwl: http://mywiki.wooledge.org/XyProblem
07:10:53 <identity_> lambdabot's, that is
07:11:05 <Botje> tell user message goes here
07:11:09 <Botje> with an @ in front
07:11:17 <identity_> ah
07:12:20 <identity_> @tell bos aeson-0.3.2.10 doesn't build as described by http://hackage.haskell.org/packages/archive/aeson/0.3.2.10/logs/failure/ghc-7.0 . See your issue tracker
07:12:38 <identity_> wat
07:12:40 <identity_> no lambdabot?
07:12:49 <Axman6> yeah :(
07:12:50 <Botje> she's resting.
07:13:10 <chenwl> so, there is no function do take off generally?
07:13:21 <ion> chenwl: What do you really want to do?
07:13:32 <identity_> meh
07:13:36 <identity_> it's in his issue tracker anyway
07:13:50 <Entroacceptor> chenwl: it doesn't make sense, generally
07:13:54 <chenwl> get the content of  NoMatterWhatItis 10
07:14:03 <Entroacceptor> say you have IO String, what would you do?
07:14:03 <ion> chenwl: In order to do what?
07:14:13 <chenwl> Left 10, Right 10, Just 10...
07:14:27 <Entroacceptor> because there's no guarantee the types fir
07:14:28 <Entroacceptor> fit
07:14:38 <Entroacceptor> you pattern match to get it
07:14:45 <Entroacceptor> or use fmap or bind
07:14:48 <chenwl> for example, I get Just 10, and want to div 2 and then return 5
07:15:02 <ion> chenwl: (`div` 2) <$> Just 10
07:15:21 <chenwl> ion: how about Right 10
07:15:26 <Entroacceptor> case data of; Just a -> a `div` 2 ; Nothing -> 0
07:15:28 <ion> (`div` 2) <$> Right 10
07:15:30 <chenwl> maybe <$> is what I want
07:15:57 <chenwl> :t <$>
07:16:30 <ion> su173053 < ion> (<$>) :: Functor f => (a -> b) -> f a -> f b
07:17:01 <Entroacceptor> but that would return Just 5
07:17:20 <ion> which is probably what you want.
07:18:31 <kizzx2> it may help to know that (<$>) = fmap, a la    fmap (+5) [5,10] = [10,15]
07:20:18 <susanoof> i'm using par to spark an evaluation, but the thing that i'm sparking is a list, so only the head is evaluated in the spark - id like the whole list to get evaluated in that spark. how can i force the whole list to be evaluated within my spark?
07:22:06 <ion> susanoof: «length xs» may or may not do what you need.
07:22:13 <Botje> deepSeq list () `par` ... ?
07:22:30 <Botje> or rnf, which does the same if i understood the strategy paper correctly
07:24:04 <dankna> okay, so if I'm interpreting these profiling results correctly, my ReaderT ? IO monad (from "transformers", not "mtl") is causing like 3000% overhead.
07:24:06 <Axman6> susanoof: let list' = deepSeq list () in list' `par` foo list
07:24:23 <dankna> will rewriting the monad myself help with that?
07:24:26 <dankna> if not, what will?
07:25:34 <erus`> when i am not being observed, am i invisible?
07:25:39 <Axman6> hmm, actually, i don't think that will work properly
07:26:04 <chenwl> ion: if I want "10" from Right 10
07:26:14 <Axman6> susanoof: this should be better, you need to keep a reference to the result of the spark so the spark doesn't get GC'd let list' = deepSeq list list in list' `par` foo list'
07:26:53 <chenwl> ion: what shold I do
07:27:00 <chenwl> ion: I want to print it
07:28:05 <ion> chenwl: What do you want to do if it’s Left "foo" instead?
07:28:46 <chenwl> ion: print "foo"
07:29:20 <chenwl> ion: I want get the real content
07:30:45 <ion> chenwl: print . either (const "foo") id $ Right 10
07:31:01 <ion> chenwl: Sorry, that’s wrong.
07:31:13 <ion> chenwl: putStrLn . either show show $ Right 10
07:32:38 <chenwl> ion: hmm.., I think i shold right a function to get it
07:33:04 <chenwl> ion: I thought there may already be one
07:33:44 <chenwl> getRight getLeft getJust get...
07:34:06 <ion> Never use functions like that.
07:34:55 <ion> What would getRight return if it got a Left?
07:35:35 <Botje> chenwl: the whole point of Maybe and Either is to encode possible failure.
07:35:47 <ion> While bottoms may be nice on humans, they are to be avoided in Haskell.
07:36:02 <Botje> chenwl: by forcing users to pattern match on the 'success' conditions, you also need to write code for the fail condition
07:36:43 <chenwl> hmm...
07:36:57 <Botje> what functions like <$> and fmap do is to allow you to write code that only transforms the success condition, but you still carry a fail condition around
07:37:27 <Botje> for example, there's a lookup function in Data.Map
07:37:51 <chenwl> It is hard to write concise code
07:37:54 <Botje> lookup k map returns Just v if there was a (k,v) pair in the Map, or Nothing if there wasn't
07:38:26 <Botje> what people typically do is fmap over the result of the lookup, and handle both the success and the fail case when they are done with the computation
07:38:31 <Botje> so ..
07:39:04 <Botje> let result = lookup k map `fmap` (+1) `fmap` (*2)
07:39:35 <Botje> and then case result of Nothing -> "Key not found"; Just v -> "Result: " ++ show v
07:40:04 <Botje> chenwl: can you put code on hpaste that explains how you get your Either value and what you intend to do with it?
07:40:15 <Botje> maybe we can point where the natural 'handling errors' code comes
07:40:21 <ion> The function comes first in fmap.
07:40:36 <Axman6> yeah...
07:40:50 <Botje> uh .. guess i got carried away there. :)
07:41:46 <Axman6> chenwl: i'd advise you to go and look at the relevant sections of LYAH and RWH to see how to use monads like Maybe and Either
07:41:47 <chenwl> Botje: ok, it is a program solving problem4 in projecteuler.net
07:42:07 <Botje> chenwl: ah.
07:42:09 <chenwl> Axman6: what is LYAH
07:42:18 <Axman6> @where lyah
07:42:22 <Axman6> urgh
07:42:28 <Axman6> learnyouahaskell.org
07:42:36 <Botje> chenwl: okay, can you put the code you have for it on hpaste.org?
07:42:44 <Botje> I've solved that one as well, a long time ago
07:43:30 <hpaste> chenwl pasted “problem4” at http://hpaste.org/49941
07:43:54 <chenwl> Botje: aha, hpaste is a bot
07:44:33 <Axman6> hpaste has a bot
07:45:15 <Jafet> hpaste was a bot
07:45:38 <Axman6> was? still is?
07:46:11 <Botje> chenwl: okay. so your Either data structure is equivalent to Maybe
07:46:21 <Botje> since you do not encode extra information in the Left branch
07:46:40 <chenwl> Botje: yes
07:47:49 <Botje> okay, well
07:48:10 <Botje> you can use the rights function from Data.Either to strip out all the Lefts from your list
07:48:32 <Botje> and then two cases remain: you either have an empty list, or you have a list that starts with a Right element
07:49:32 <Botje> so I would do something like case rights palindromes of [] -> error "Something bad happened"; Right x : xs -> x
07:49:50 <Botje> instead of the head $ dropWhile ... you have now
07:50:08 <Saizan> Right (x:xs)
07:50:16 <Saizan> ah, no
07:51:37 <chenwl> Botje: that seems good, I need to learn more lib functions :P
07:52:25 <Botje> chenwl: in this specific case, fromRight $ head $ dropWhile ... would also have worked
07:52:42 <Botje> but you would get a really vague error if the list was empty
07:52:54 <Botje> it's better to be a bit more expressive :)
07:54:32 <chenwl> Botje: Data.Either is better
07:55:04 <chenwl> Botje: maybe I should seperate divisible and get factors to 2 functions
07:55:21 <chenwl> Then there is no Left Right Just ...
07:57:11 <chenwl> got to sleep *_*
07:57:14 <chenwl> good night
07:57:18 <Botje> bye :)
08:02:09 <randomwords> Does anyone know how I resolve this error (http://hpaste.org/49942) when installing the profiling version of base?
08:04:54 <ocharles> Hey, what's the recommend way of adding error handling to a monad? I seem to have 2 options: add an instance of MonadError, or I can wrap it up in a newtype and use ErrorT
08:05:04 <ocharles> I'm not really sure which is best
08:05:06 <Saizan> randomwords: you can't install base through cabal
08:05:49 <Saizan> randomwords: how did you get your ghc? if it's via your package manager it probably has a package for the profiling version too
08:06:48 <Saizan> ocharles: depends, can you write a sensible instance of MonadError for your monad?
08:06:49 <randomwords> I got the latest binary from the website
08:07:00 <bss03> ocharles: How easy is it to write a MonadError instance?
08:07:04 <randomwords> Saizan: Presumably I need to find one with profiling libs?
08:07:17 <ocharles> Saizan: I don't know sadly, I haven't managed to yet... the monad in question is "Handler" from Snap 0.6 "snaplets"
08:07:21 <Saizan> roastbird: it should have them
08:07:46 <bss03> ocharles: If a MonadError instance is pretty easy to write, do that.  Otherwise, just wrap in ErrorT.
08:08:08 <ocharles> Presumably, MonadError's throwError should return a value that indicates there was an error, right?
08:08:50 <randomwords> Saizan: to be specific - this one (http://haskell.org/ghc/download_ghc_7_0_3#x86_64linux)
08:09:02 <isBEKaml> @hoogle nub
08:09:06 <bss03> So, I'm thinking of writing a low-level interface to libgit2 in Haskell.  Does one exist already?  Is there a tool to automatically generate the Haskell, based on reading the public interface headers?
08:09:17 <isBEKaml> gah, lambdabot down?
08:09:22 <isBEKaml> @type nub
08:09:29 <bss03> isBEKaml: nub :: forall a. [a] -> [a]
08:09:39 <Saizan> randomwords: yeah, that one includes the profiling versions
08:10:16 <bss03> isBEKaml: nub [] = []; nub (x:xs) = x : filter (x /=) xs
08:10:16 <isBEKaml> bss03: thanks, which module is it? I get 'not in scope' errors.
08:10:44 <bss03> I thought they put it in Prelude, but it might be in Data.List instead.
08:10:47 <randomwords> Saizan: Could not find module `Control.Monad': Perhaps you haven't installed the profiling libraries for package `base'? - Perhaps there's another problem?
08:11:12 <bss03> (oh, and I got the source wrong. :[)
08:11:21 <isBEKaml> bss03: ah, Data.List. thanks.
08:11:23 <randomwords> I have library-profiling: True in my cabal config
08:11:28 <ocharles> I understand how MonadError works for Either e, but I can't see how other instances should look
08:11:39 <ocharles> Anyone know any good examples to see other implementations?
08:11:39 * hackagebot flo 0.1 - Generate flow charts from your code base.  http://hackage.haskell.org/package/flo-0.1 (ChrisDone)
08:11:43 <isBEKaml> bss03: no worries. I actually know what nub does. :)
08:12:13 <Saizan> ocharles: it's not just about what it returns, it also has to make so that in throwError e >> m you don't execute m
08:13:39 <ocharles> right
08:13:47 <ocharles> that's what I'm not quite sure about, I guess :)
08:13:50 <Saizan> ocharles: and then it has to interact with catchError, so if the monad wasn't designed for control effects like this it can't do much
08:14:13 <ocharles> brb, gotta swap trains... if theres any good material to read/examples, please share away (highlight my name and I'll get back to it in a few mins)
08:14:14 <Saizan> s/do much/implement MonadError/
08:16:23 <bss03> Okay, it actually seems like there are already two bindings to libgit2 written in Haskell, I guess I'll look at those.
08:19:30 <yitz> @src nub
08:19:49 <yitz> @botsnack
08:20:03 <yitz> :(
08:20:10 <yitz> preflex: seen lambdabot
08:20:10 <preflex>  lambdabot was last seen on #haskell 3 hours, 59 minutes and 4 seconds ago, saying: http://tinyurl.com/lambdacats
08:20:34 <isBEKaml> it found a mate! :D
08:20:47 <isBEKaml> and ran off.
08:21:09 <hvr> preflex: seen bos
08:21:09 <preflex>  bos was last seen on #ghc 3 days, 21 hours, 54 minutes and 49 seconds ago, saying: https://github.com/haskell/win32
08:21:41 <mreh> coincidence?
08:22:43 <bss03> yitz: nub [] = []; nub (x:xs) = x : nub (filter (x /=) xs)... I think.
08:23:06 <bss03> yitz: nub [1,2,3,3,2,1] = [1,2,3]
08:27:45 <ocharles> Saizan: right, that's why I said I guessed it had to change value, so >> could actually specify whether or not to evaluate the next action
08:27:56 <ocharles> ErrorT is probably the way to go
08:28:42 <Saizan> yeah, but to make >> care about it you've to change the monad, hence ErrorT :)
08:29:08 <ocharles> yep
08:29:54 <Saizan> where is this Handler monad in the haddocks, btw?
08:30:07 <ocharles> 0.6 isn't out yet
08:30:14 <ocharles> you'd have to build haddocks from source (it's on their github)
08:31:30 <ocharles> https://github.com/snapframework/snap/blob/0.6/src/Snap/Snaplet.hs if you don't mind reading in haddock syntax
08:32:33 <ocharles> https://github.com/snapframework/snap/blob/0.6/src/Snap/Snaplet/Internal/Types.hs#L185
08:32:52 <Saizan> ah, it has MonadCatchIO
08:33:20 <Saizan> so you're probably supposed to use IO exceptions to handle/throw errors
08:34:14 <ocharles> better learn how IO exceptions work then :)
08:34:47 <Saizan> http://hackage.haskell.org/packages/archive/MonadCatchIO-mtl/latest/doc/html/Control-Monad-CatchIO.html <- learn the generalized interface directly then :)
08:35:48 <ocharles> though there is also https://github.com/snapframework/snap-core/issues/82
08:38:19 <Saizan> Control.Exception.Control is almost the same as Control.Monad.CatchIO API-wise, so it shouldn't be a problem to switch to it when snap does
08:41:39 * hackagebot llvm 0.10.0.1 - Bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-0.10.0.1 (BryanOSullivan)
08:43:38 <ocharles> cool
08:44:00 <ocharles> And are IO exceptions a desirable way to handle errors?
08:44:05 <ocharles> quite a broad question...
08:45:15 <Saizan> i'd say yes, if your monad is already using IO
08:45:28 <bss03> IO exceptions are pretty good, if you always want to "recover" in an IO context.  Some of my recovery I like doing outside of IO, so I end up mixing stuff.
08:46:01 <chrisdone> hey guys check this https://github.com/chrisdone/amelie/commit/d80da7c59514c5cbb279ea99c7c5921d9a2f3ec3
08:46:01 <preflex>  chrisdone: you have 1 new message. '/msg preflex messages' to read it.
08:46:11 <chrisdone> from that i generate: http://i.imgur.com/Va8Xo.png
08:46:17 <byorgey> dylukes: it will be very soon -- currently making the arrows would be an exercise in annoying low-level stuff, but those will be added very soon
08:46:35 <dylukes> I want to use diagrams to do erlang supervision trees :P.
08:46:49 <byorgey> dylukes: however, diagrams has no facilities for doing the actual graph layout
08:46:49 <dylukes> How easy would it be to build my own library on top of diagrams streamlined for that purpose btw?
08:46:55 <Saizan> ErrorT E IO has the problem of having two not-so-orthogonal call stacks wrt exceptions, so the throwing and catching can become tricky
08:47:18 <byorgey> dylukes: it should be very easy.
08:47:26 <dylukes> byorgey: I'll definitely do that at some point then.
08:47:28 <byorgey> dylukes: and if it isn't we will make it so.
08:47:33 <dylukes> ^^
08:47:41 <Saizan> OTOH it could be useful to keep them separate in some cases, if you know what you're doing
08:47:53 <dylukes> It would be amusing to use a Haskell DSL for Erlang planning.
08:47:56 <dylukes> but, why not.
08:47:57 <dylukes> :)
08:48:03 <byorgey> dylukes: I want to make an interface between diagrams and ivanm's GraphViz bindings so you can use GraphViz to do graph layout
08:48:32 <dylukes> hm, yeah
08:48:40 <dylukes> do you have arrows/nodes/etc for graphing done?
08:49:39 <kniu> do functions used for view patterns have to come from the top level?
08:51:49 <chrisdone> kniu: yeah
08:52:10 <kniu> chrisdone, is there a reason for this restriction?
08:52:54 <byorgey> dylukes: no, we'll just make a function to take a graph data structure annotated with position information and turn it into a diagram
08:54:22 <chrisdone> kniu: it adds some complexity in implementation but the restriction may be lifted later
08:54:47 <sm> chrisdone: very nice
08:54:55 <chrisdone> sm :)
08:55:10 <chrisdone> package is here http://hackage.haskell.org/package/flo
08:57:36 <stobix> I kinda would like haskell too have both lazzy evaluation aand "senile memory" . My system tries to kill me just beccause I tried to sum something large together. Iis there no way to tell haskell too just drop things when iit's done with them?
08:58:18 <edwardk> stobix: that will actually ruin your asymptotic performance
08:58:22 <stobix> (Sppelling errors due to heeavy caching. (writing hile waiting for ghc to  receive its ^C^D and do something inttelligent with it...)
08:58:25 <stobix> )
08:59:02 <stobix> edwardk: it would make me able to comput things
08:59:26 <edwardk> stobix: even if you try to wise up and do tricky things with exponential back off on each thunk you can't recover the original asymptotics
08:59:31 <stobix> or, to  put it in other worrds, if it didn'{t hog memory, the computatiinos coould be allowed to finish.
08:59:50 <edwardk> because it necessarily means a loss of sharing
09:00:33 <stobix> Why would I want asymptotic behavioru on something thhat cannac finish computing due tlack of memory?
09:00:41 <edwardk> i wanted it too once before i worked through the ramifications
09:00:53 <stobix> (And why isn't it shutting down so I can see what I write?) (brb)
09:01:02 <edwardk> just fix your strictness. it isn't hard to find the few places you accumulate +1's and put ! patterns on the types
09:01:26 <stobix> What does the strictness do?
09:01:35 <edwardk> if you want magic, there is walsks rob ennals thesis which makes naively written haskell code have decent efficiency
09:01:42 <jmcarthur> is it fair to assume that the Sum and Product monoids are commutative?
09:01:51 <stobix> Or, more specifically, how does strictness helps me free up memory? :)
09:01:53 <edwardk> jmcarthur: no
09:02:19 <edwardk> stobix: using foldl' (+) 0 instead of foldr (+) 0 takes constant instead of O(n) memory
09:02:35 <edwardk> jmcarthur: you might get away with the Sum monoid but the Product ?
09:02:47 <jmcarthur> i know not in principle, but based on the fact that their Monoid instances are defined in terms of Num (which i realize don't really have laws on it...)
09:03:14 <edwardk> sure but if i give you quaternions...
09:03:35 <qwr> stobix: strictness avoids creating expression thunk trees
09:03:36 <jmcarthur> i'll just make the assumption for Sum but not Product
09:03:51 <stobix> edwardk: hm, so, basically, "build up all modules from scratch using foldl' instead of foldr"?
09:04:00 <edwardk> or clearly you should just use the algebra package and use Abelian and Commutative
09:04:15 <jmcarthur> yeah i was going to take a peek at it
09:04:18 <edwardk> stobix: no most haskell modules do the right thing. Map etc internally do it
09:04:44 <edwardk> and foldl' isn't always what you want, depends on if you need infinite lists, etc.
09:04:52 <edwardk> or if you want the output to be productive
09:05:13 <jmcarthur> edwardk: what would be the best type class to use if i just want commutative monoids without the additive/multiplicative distinction?
09:05:18 <edwardk> stobix: the supply of different folds is made available to you for a wide variety of containers through Foldable
09:05:37 <edwardk> jmcarthur: there isn't one. just use the Additive version when in doubt.
09:05:38 <stobix> edwardk: an example of a memory hogger: length $ takeWhile (<100000000)  primesTME -- primesTME is a prime list generator
09:05:42 <jmcarthur> darn
09:05:52 <edwardk> i chose not to make a distinction betwen making the distinction and not =P
09:06:33 <edwardk> that is because primesTME is a CAF.
09:06:47 <edwardk> and so it remembers you looked at it and holds on to the evaluation so other computations can share it
09:06:57 <stobix> qwr: hm. So using strict evaluation on every element that I chose to pick from an infinitely long list would help the memory consumption?
09:07:43 <edwardk> the primes example is particularly evil because you only force the _spine_ of that list, not the elements
09:08:11 <edwardk> so you wind up with thunks for each prime, and then a spine of 100000000 elements
09:08:55 <stobix> hm. and a "thunk" would be something taking up much more data than a simple function value?
09:08:59 <edwardk> you can fix it in part by using a list type that is strict in the elements, and the rest of the way by changing it from a caf that generates the primes to a function, which will destroy the sharing on the result.
09:09:30 <stobix> are funcions CAFs with arguments?
09:09:35 <edwardk> the thunk is a 'function value' but it isn't evaluated, so it needs to hold onto everything it needs to evaluate. which for the last prime there is probably a pointer to the previous primes
09:09:42 <qwr> stobix: you wouldn't collect that infinite list into nested thunks of (item + (...)) expressions
09:10:15 <edwardk> well, a CAF is just a top level definition with no arguments, basically its something a lot of people can come back to and ask to further evaluate parts of
09:10:20 <jmcarthur> edwardk: anything with a property like this one sitting around?   (*^) :: Foo a => Bar a -> a -> a,  where  a *^ (b *^ c) = b *^ (a *^ c)
09:10:30 <qwr> stobix: as that's what the lazy fold tends to do
09:11:33 <edwardk> hrmm
09:11:56 <edwardk> that is close to left semimedial
09:12:04 <stobix> qwr: heh. And here I got fooled by my teacher (years ago) telling me that "don't use foldl, because it's head recursive".
09:12:06 <jmcarthur> edwardk: basically that would be for folding a bag into an accumulator, or at least that's the use i'm envisioning
09:12:21 <jmcarthur> Bar a would be an element of the bag
09:12:41 <edwardk> it isn't a usual law: http://en.wikipedia.org/wiki/Magma_(algebra)
09:13:46 <edwardk> stobix: not foldl, foldl'
09:13:53 <edwardk> foldl' is actually a foldr ;)
09:14:06 <edwardk> as is foldlM
09:14:20 <stobix> ... haskell just gets clearer and clearer the deeper you go
09:14:24 <edwardk> (tricky consequence of the use of ($!)
09:14:41 <stobix> heh, is that why fouldM has its arguments reversed? ;)
09:15:36 <edwardk> @type foldlM
09:15:46 <stobix> I guess I need to deeply evaluate what on earth foldr and foldl does on a deep level to really get that. Or maybe just get a hang of strictness...
09:15:49 <edwardk> @type foldl
09:16:29 <stobix> Not even the bot knows....
09:16:45 <edwardk> lambdabot is taking her lunch break
09:17:08 <stobix> maybe she is summing somethin big lazily?
09:17:31 <edwardk> nah her ADD kicks in after about 3 seconds
09:17:38 <stobix> :)
09:18:33 <stobix> hm, would my example consume less memory if I chose to evaluate each element? :)
09:19:07 <edwardk> a little, but fixing the CAF would take it down to constant memory
09:19:53 <zomg> Is there a way to :load code that uses import GHC in ghci?
09:20:11 <zomg> If I try loading it in ghci, it just says "Could not find module GHC" "It is a member of the hidden package .... "
09:20:27 <stobix> edwardk: hm, like building something that output the n:th element instead of creating an infinite list?
09:20:32 <monochrom> :set -package ghc  then try again
09:20:45 <mercury^> edwardk: do you know of a standard designation for `the' universal isomorphism category?
09:20:54 <zomg> monochrom: nice, that did the trick. Thanks :)
09:21:22 <edwardk> stobix: that would be one solution. here you only care that the 100000000th element exists, not that you save any work on the previous ones
09:21:30 <edwardk> mercury^: not off hand
09:21:54 <qwr> stobix: http://en.wikipedia.org/wiki/Fold_(higher-order_function)#List_folds_as_structural_transformations
09:22:19 <mercury^> edwardk: If I were to call it 2x2, would you immediately know what I meant?
09:22:23 * stobix sacrifices some RAM by starting a browser
09:23:43 <qwr> stobix: and http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
09:23:51 <edwardk> mercury^: probably not, thinking about it for a sec. perhaps you can get there by looking at universal morphisms as initial and terminal arrows in a comma category?
09:23:56 <stobix> nice, thanks
09:24:07 * stobix does some rtfm:ing
09:26:44 <mercury^> edwardk: can you elaborate? What I mean by 2x2 is the category with 4 arrows and projections onto the set with two elements, i.e. the category representing the `isomorphisms-in'-functor.
09:28:27 <edwardk> well, i was just thinking in terms of the definition of universal morphisms from as initial (and terminal) morphisms in the comma category (X, U)  (or U, X))
09:29:36 <randomwords> What's the canonical way to convert Double -> GLDouble. It seems that since 7.0 realToFrac is pathalogically slow..
09:29:52 <edwardk> randomwords; unsafeCoerce =P
09:29:55 <mercury^> edwardk: but how does that relate to my question?
09:29:57 <randomwords> edwardk: :
09:30:01 <randomwords> edwardk: :(
09:30:33 <edwardk> mercury^: well i was looking for some standard pile of constructions i could pile on top to get you a standard-looking name for the category =P
09:30:45 <edwardk> GLDouble was a stupid abstraction
09:30:51 <mercury^> Ok.
09:30:53 <jmcarthur> randomwords: an upcoming version of the gl packages should have rewrite rules for that, btw
09:31:00 <edwardk> in the interest of supporting non-existing platforms it ruined performance for everyone
09:31:03 <randomwords> jmcarthur: Fantastic
09:32:17 <edwardk> i'd be happier if they just turned them into a type synonym until someone found this magical shangrila where they are different
09:32:33 <jmcarthur> edwardk: i'd be fine with it if the conversion was free
09:32:35 <edwardk> or exposed the damn constructor
09:32:41 <edwardk> conversion is never free
09:32:49 <edwardk> i convert trees and structures full of these things
09:33:02 <edwardk> even a newtype isn't free if I map it
09:33:20 <jmcarthur> that map is usually fused in with other things though, in practice
09:33:35 <edwardk> but it is still an indirection i pay for in that other loop
09:33:51 <edwardk> it made a noticable difference in the performance of my AD library to start using the iso hack
09:33:56 <edwardk> =(
09:34:20 <tech2> Is there a marked performance improvement (e.g. factor of two) between ghci and compiled?
09:34:26 <jmcarthur> tech2: huge
09:34:29 <edwardk> tech2: more
09:34:34 <randomwords> unsafeCoerce just improved my perfomance by around 3000%
09:34:44 <edwardk> randomwords: exactly
09:34:45 <tech2> thanks
09:34:46 <jmcarthur> randomwords: realToFrac sucks
09:34:59 <randomwords> it sucked less in 6.x I think
09:35:05 <randomwords> I'm revisiting old code
09:39:12 <stobix> haha, http://foldr.com/ :)
09:43:18 <mm_freak_> most abstractions in the OpenGL library are stupid…  GLDouble pays you nothing and just makes your life harder
09:43:34 <mm_freak_> i was tempted to use GLDouble instead of Double throughout my code to get around that problem
09:43:39 <mm_freak_> that's really ugly
09:43:49 <randomwords> yeah
09:44:02 <randomwords> well I remember when GLDoubles didn't exist
09:44:11 <randomwords> a better time
09:51:34 <edwardk> heck, even hugs got it right: http://cvs.haskell.org/Hugs/pages/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-BasicTypes.html
09:53:53 <edwardk> clearly someone needs to pull a jinjin wang and upload OpenGL-owns
09:54:11 <dylukes> edwardk: ?
09:54:30 <edwardk> http://hackage.haskell.org/package/monoid-owns
09:55:21 <dylukes> "Owns"?
09:55:29 <edwardk> you tell me =)
09:56:07 <dylukes> ._.
09:57:04 <stobix> hm, so part of my problem above was that length strictly evaluates the list in the wrong order, leaving no redexen, and the other part was the CAF being a bitch... Are there any good rtfm:s for CAF:s as well?
09:57:23 <edwardk> http://www.haskell.org/haskellwiki/Constant_applicative_form
09:58:41 <stobix> nice, just the one I randomly googled up. :)
10:01:52 <edwardk> don stewart's reply in http://stackoverflow.com/questions/6090932/how-to-make-a-caf-not-a-caf-in-haskell is pretty good too
10:02:33 <Eliel> @pl zipWith (\f i -> f i) fs (repeat b)
10:02:51 <Eliel> the bot's offline again I guess.
10:02:54 <edwardk> it also highlights how you can get whammied with a CAF even if it doesn't look syntactically like one
10:04:45 <Eliel> I've got a list of functions and the parameter to feed to each of the functions. Is this code the simplest way to do it? zipWith (\f i -> f i) fs (repeat b)
10:05:28 <edwardk> no
10:05:33 <edwardk> map ($b) fs
10:05:45 <Eliel> Ah, thank you :)
10:06:36 <benmachine> Eliel: notice that (\f i -> f i) is ($)
10:06:39 * hackagebot wl-pprint-extras 1.2.2 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-1.2.2 (EdwardKmett)
10:06:41 * hackagebot wl-pprint-terminfo 0.2.1.3 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.2.1.3 (EdwardKmett)
10:06:48 <benmachine> ...which is a specific form of id
10:07:41 <Eliel> I still have some way to go to really start regarding functions like any other values :)
10:08:11 <frerich_> sm: Are you around?
10:08:31 <sm> hi frerich_, yes
10:09:04 <frerich_> sm: Hi; I might be mistaken, but you recently discussed some things about the code of some RSS/Atom-IRC bridge which dons originally wrote, right?
10:09:34 <sm> yup, I took over rss2irc from dons
10:10:06 <sm> chrisdone thought he found a printf bug in it
10:10:09 <frerich_> sm: Ah, rss2irc! I was trying to find it's codebase since I think it's really a great program to learn from (I'm fairly new to Haskell), but I couldn't find it anymore...
10:10:34 <frerich_> sm: Now I found it again, I lacked the name. Thanks!
10:10:55 <sm> np! http://joyful.com/projects.html#rss2irc is latest
10:12:07 <frerich_> sm: Thanks - bookmarked that. I just noticed that it was really nicely readable code (with comments, helpful for newbies like me) solving a non-trivial problem in a good fashion. I'm trying to get my hands on more code like that. :-)
10:12:43 <frerich_> It seems that there is plenty of free Haskell code around, but much of it was written by beginners like me; the code quality and style is not something I'd like to copy :-)
10:12:57 <frerich_> So I'm trying to find more understandable code by "well known" Haskell programmers. ;-)
10:12:58 <sm> thanks, that's nice to hear. Sometimes I think I use too many comments - the good coders don't seem to. But newcomers always seem to appreciate them
10:13:41 <sm> I'm a fan of documentation driven development, so I often write the haddock first.
10:13:55 <frerich_> sm: Yeah, I guess comments tend to duplicate information really; in the best case, the code is self-documenting through good names and small functions. That's only useful if you know the programming language already though.
10:14:17 <frerich_> I was always a fan of "Don't comment what's happening, only why" but now I realize that this is not useful to somebody learning the language.
10:15:23 <sm> I feel a single sentence describing the function is usually worth it, for haddock etc.
10:15:55 <frerich_> I greatly appreciate that attitude. :-)
10:16:20 <frerich_> It's great to find stuff like this in the see of Haskell blogs from people who just convinced themselves that they "got" monads.
10:16:25 <frerich_> s/see/sea/
10:16:39 * hackagebot smallarray 0.2.2.1 - low-level unboxed arrays, with minimal features.  http://hackage.haskell.org/package/smallarray-0.2.2.1 (AntoineLatter)
10:16:47 <avpx> Haskell lends itself to incredibly dense code, so I'm often very descriptive in my comments
10:16:52 <sm> and the effort of keeping it in sync with the code is often worth it in terms of bugs found & clarifying old code, for me
10:17:24 <stobix> heh, seems "length.takeWhile (<1000000) $ map (\x -> head.drop (x-1) $  primesTME ) [1..]" fixed the memory problem. :) Thanks edwardk, qwr. I guess I'll watch out for CAFs from now on, then. (And learn to evaluate things in the right order...)
10:18:01 <edwardk> happy to help
10:20:09 <stobix> however, to get 100000 elements now take 12.060 seconds instead of 0.0006 seconds...
10:21:02 * stobix lets the thing comput while watching a movie
10:36:59 <identifai> i'm looking for a function (say 'foo') which applies another function on an element at a specific index of a list. e.g.:  ''foo 2 (+1) [1..5] == [1,2,4,4,5]''; or:  ''foo 4 (*2) [5..10] == [5,6,7,8,18,10]''.    does such a function already exist? or should i implement it manually?
10:40:18 <benmachine> identifai: that function doesn't already exist; lists usually aren't meant for random access
10:40:34 <benmachine> if you want to implement it yourself, I recommend looking at splitAt
10:41:17 <copumpkin> if you only apply it a constant number of times, you can get away with a zipWith
10:41:24 <copumpkin> but I don't recommend doing it much
10:41:40 <benmachine> (to back up my point about random access, the sequence type in Data.Sequence *does* have a function that does that)
10:42:01 <avpx> Think about using arrays for random access. Mutable arrays in the ST monad are convenient for this.
10:42:18 <benmachine> nah, use Data.Sequence
10:42:24 <benmachine> mutability is evil :)
10:42:28 <jmcarthur> identifai: what's the use case?
10:42:30 <fazzone> >let foo idx f xs = beg ++ f a : end where (beg,(a:end)) = splitAt idx xs
10:42:33 <jmcarthur> benmachine: mutation is not inherently bad
10:42:35 <copumpkin> or even an IntMap
10:42:41 <copumpkin> depending on your use case
10:43:06 <benmachine> jmcarthur: I wouldn't say mutability is inexcusable, but I don't see that it's ever to be preferred where there's a choice
10:43:09 * yitz on the way out the door, supports benmachine
10:43:32 <jmcarthur> benmachine: not even for efficiency?
10:44:01 <benmachine> jmcarthur: efficiency is a decent excuse
10:44:02 <identifai> Well, actually the list is a list of my own type: data MyType = M { {- here some differnet values -} }; i want to change a specific value of an element in the list...
10:44:11 <identifai> jmcarthur: ^
10:44:19 <jmcarthur> identifai: but what is the bigger picture?
10:44:30 <monochrom> that changes everything again
10:44:31 <jmcarthur> identifai: we might be able to suggest a nicer data structure for it
10:44:37 <yitz> benmachine: *really* gotta run. but thanks for the heads up about stupid backslash quoting for quasi quoters. the fix got implemented!
10:44:44 <benmachine> yitz: I heard :)
10:44:56 <benmachine> we need to get the quoty function in L.H.QQ I think
10:44:59 <benmachine> er
10:45:05 <benmachine> L.H.TH.QQ or whatever
10:45:07 <yitz> yep.
10:45:16 <yitz> maybe put it up on hackage for now
10:45:21 <yitz> ok bye
10:45:24 <benmachine> see you
10:45:28 <identifai> jmcarthur: w8 a scn
10:45:30 <identifai> d
10:46:15 <jmcarthur> identifai: just a short explanation of the problem you are solving or the algorithm you are implementing might be enough
10:46:39 * hackagebot hfractal 0.4.2.4 - OpenGL fractal renderer  http://hackage.haskell.org/package/hfractal-0.4.2.4 (ChrisHoldsworth)
10:46:41 * hackagebot hfractal 0.4.2.5 - OpenGL fractal renderer  http://hackage.haskell.org/package/hfractal-0.4.2.5 (ChrisHoldsworth)
10:47:19 <Phyx-> hmm.. does the tail recursive optimization apply to something a function that's inside a monad?
10:47:30 <identifai> jmcarthur: http://hpaste.org/49945
10:47:50 <identifai> jmcarthur: oh.. oops; i thought you want the data-definition...
10:48:00 <jmcarthur> heh
10:48:08 <jmcarthur> nope, this isn't really helpful ^_^
10:48:22 <monochrom> depends on the monad. but let's say IO. f = print () >> f does not waste memory
10:48:26 <identifai> jmcarthur: sorry, but the algorithm i wanna implement is complex :/
10:48:47 <copumpkin> identifai: our point is why are you doing that operation specifically?
10:48:51 <copumpkin> can you batch up the modifications somehow?
10:48:55 <copumpkin> can you use a different datastructure?
10:48:59 <copumpkin> what operations do you need on it and why
10:49:36 <jmcarthur> identifai: then don't go into details on the algorithm. just a basic explanation of what operations you need to be fast and what operations are okay to be slow might be helpful, for example
10:49:59 <jmcarthur> at least, that's what we are ultimately looking for
10:50:03 <benmachine> identifai: you can write your function easily on lists with splitAt, but you might find you don't want to use lists after all
10:50:16 <jmcarthur> if you aren't sure, then a basic overview of the algorithm might be necessary anyway
10:50:40 <Phyx-> monochrom: i'm using a StateT and processing a rather large list recursively
10:50:52 <Phyx-> getting stack overflow errors
10:51:23 <monochrom> Control.Monad.State.Strict enjoys tail-call too
10:51:23 <jmcarthur> identifai: you might be able to just say what problem you are trying to solve without mentioning the algorithm at all. some of us might know some comon algorithms to solve that particular problem already
10:51:26 <jmcarthur> *common
10:51:51 <identifai> w8 a moment, please..
10:51:54 <jmcarthur> which could be enough to suggest a nice data structure
10:51:58 <Phyx-> monochrom: ah, thanks, I'll give that a shot
10:52:31 <monochrom> but note "get", "put", "modify" are non-strict in the state value. Control.Monad.State.Strict is strict in the (a,s) pair only
10:52:55 <SuspiciousMind> http://pedro3005.cjb.net/    <- this blog tells the secret life of one of your users. pedro3005 it realy is worthwhile reading.
10:53:17 <Phyx-> monochrom: yeah, that's find for my usage
10:53:43 <Phyx-> fine*
10:55:59 <malorie> what's a good way to implement an algorithm which uses a 'working stack'?
10:56:07 <monochrom> http://hpaste.org/41790/ illustrates Control.Monad.State Lazy vs Strict
10:56:09 <identifai> it's: >> myFunc :: [Foo] -> [Bar] -> [Foo] << (where Foo and Bar are data-types which i defined..). furthermore >> myFunc (f:fs) b =  (m { qwre=specialElemFromBarList }):(myFunc ms (f b)) << where 'f' changes a special attribute of a special element in b. does that help?
10:56:35 <avpx> malorie, recursion?
10:56:39 * hackagebot Shellac-haskeline 0.2.0.1 - Haskeline backend module for Shellac  http://hackage.haskell.org/package/Shellac-haskeline-0.2.0.1 (JudahJacobson)
10:57:01 <identifai> oh god, i think i cant explain my problem :\
10:57:21 <malorie> avpx: e.g., f xs = f' xs [] where f' = (x:xs) stack@(y:ys) ?
10:58:28 <jmcarthur> identifai: if you were trying to explain to a non-programmer what your program should do, what would you say? i'm not really looking for code here
10:58:39 <jmcarthur> you don't have to explain how it works
10:58:39 <avpx> I'm not sure I understand what you're trying to do there. f' = (x:xs) stack@(y:ys) would try to apply a list to another list
10:58:59 <Phyx-> monochrom: right, because gen isn't evaluated in the lazy State and so the recursive call is not made right?
10:59:58 <monochrom> gen is done later than modify (():)
11:00:03 <identifai> jmcarthur: it looks for a special element in the one array and allots this element to another in the other array.
11:00:30 <identifai> s/allot/assign/
11:00:47 <malorie> avpx: f xs = f' xs [] where f' (x:xs) stack@(y:ys) = ...  -- fixed
11:01:29 <jmcarthur> identifai: does "looks for" mean by index or by predicate?
11:01:56 <malorie> avpx: basically I'm having an auxilliary function (f') that has an "internal" list-argument for the stack.
11:02:05 <avpx> malorie, Yes, that is in fact a common argument
11:02:15 <avpx> Erm
11:02:19 <jmcarthur> identifai: from the way you phrased it, it sounds like you might want a mutable array or a sequence, but i'm still not sure whether you are overcontraining your problem
11:02:22 <avpx> A common methodology. Not paying attention to my wording
11:02:55 <ion> f = f' [] where f' stack@(y:ys) (x:xs) = ...
11:03:05 <zomg> I have a IO [[a]], and I'd like to have IO [a] instead.. I'm trying to use concat on this but it isn't quite working (probably using it wrong)
11:03:14 <zomg> Is there some way to get it going without using do notation?
11:03:19 <fazzone> zomg: fmap concat?
11:03:21 <monochrom> liftM concat
11:03:30 <hpc> or fmap join
11:03:38 <identifai> jmcarthur: contrain?
11:04:02 <fazzone> identifai: constrain
11:04:03 <avpx> zomg, do notation is always syntactic sugar, so yes
11:04:03 <malorie> avpx, ion: thanks. what about using the state monad, though? would it be inadequate / overkill?
11:04:17 <zomg> Thanks all, will give those a shot :)
11:04:19 <avpx> Adequate, but definitely unnecessary
11:04:25 <ion> malorie: It might be just fine.
11:04:27 <avpx> malorie, recursion is a very natural way to take advantage of a stack
11:04:43 <malorie> I see. will stick to my list-argument, then :-)
11:04:51 <avpx> malorie, yes, do that.
11:05:22 <ion> If you have a number of functions operating on the stack, passing it around implicitly in the State monad might be nice.
11:05:43 <ion> But if your stack usage is simple enough, Stack might be overkill.
11:05:43 <fazzone> identifai: i believe he is asking for a much larger-scale description of the problem than what you are giving; a type signature for a function and a rephrasing of the original question with strange variable names doesn't help if we can't put it in context.  what I think jmcarthur means by 'overconstraining' is 'solving a simple problem in an unnecessarily complex way'
11:05:51 <ion> s/Stack/State/, duh
11:06:53 <mm_freak_> malorie: use the state monad, when your computation is complicated and your state is manipulated deep inside of it, and passing the state around all the time would be inconvenient
11:07:07 <mm_freak_> for simple one-function algorithms explicit arguments are probably more adequate
11:07:55 <malorie> it's the shunting-yard-algorithm, jfyi. so push/pop along with pattern-matching should suffice
11:08:52 <jmcarthur> what i mean by overconstraining is "conflating the general problem with one of its possible solutions"
11:10:13 <identifai> jmcarthur: Well, I think I'll simply look for a solution on my own since i really cant explain my problem, but that's not that important.. any way, i'd like to know what mutable arrays are instead :]
11:13:32 <identity_> @hoogle Array
11:13:37 <identity_> ah, yeah
11:13:44 <identity_> lambdabot :(
11:14:07 <identity_> You know, if I could have compiled lambdabot I would've stepped up and saved us
11:14:59 <Phantom_Hoover> Wait, are you guys still relying on the tunes logs?
11:15:10 <mm_freak_> identifai: try the 'vector' package for mutable arrays, but keep in mind that well written functional code usually performs just as well and sometimes even better than imperative code
11:16:01 <identifai> mm_freak_: so, what exactly *are* mutable arrays? and what do they have to do with imperative code?
11:16:13 <mm_freak_> identifai: arrays with destructive update
11:16:28 <mm_freak_> the arrays you know from most other languages are mutable arrays…  you can overwrite values
11:16:37 <identifai> yep
11:16:53 <mm_freak_> immutable arrays like those you generally prefer to deal with in haskell are not mutable
11:17:03 <mm_freak_> conceptually every change requires a copy (though that's just concept)
11:17:13 <identifai> and that's the point? hmm,.. I see.
11:17:22 <identifai> mm_freak_: thanks :)
11:17:33 <mm_freak_> you're welcome =)
11:17:42 <Phantom_Hoover> I'm assuming that uses monads or something?
11:17:53 <mm_freak_> Phantom_Hoover: mutable arrays?
11:17:56 <chrisdone> who's commin' to camhac‽
11:18:55 <Phantom_Hoover> mm_freak_, yes.
11:19:31 <identifai> chrisdone: http://www.haskell.org/haskellwiki/CamHac#Attendees :)
11:19:56 <identifai> even Simon PJ!! cool
11:19:57 <mm_freak_> Phantom_Hoover: usually you would use a monad, yes
11:20:06 <mm_freak_> but that's not strictly a requirement
11:20:16 <BCoppens> chrisdone: I am, and itkovian and jaspervdj :p
11:20:17 <chrisdone> identifai: I totally knew that!!!!!
11:20:30 <chrisdone> BCoppens: hehe, i knew that one. what day are you going?
11:20:37 <luite> I'm not :(
11:20:41 <chrisdone> luite: why?
11:20:46 <BCoppens> chrisdone: arriving Thursday evening, leaving Sunday afternoon
11:21:04 <copumpkin> that's a pretty huge hackathon
11:21:11 <BCoppens> chrisdone: but I'll probably sneak out for a while to look at some of the cambridge buildings :p
11:21:15 <luite> not registered, thought I wouldn't have time
11:21:16 <Phantom_Hoover> <mm_freak_> but that's not strictly a requirement
11:21:17 * clsmith heard of it too late :(
11:21:27 <chrisdone> BCoppens: ho ho, i'm arriving on wed, nes, day, we should meet up a thursday
11:21:30 <Phantom_Hoover> Well yeah, but it's generally The Way It's Done.
11:21:34 <clsmith> (though i'd probably have spent the entire time confused)
11:21:40 * arcatan noticed the registeration one day too late
11:21:44 <BCoppens> chrisdone: cool :)
11:21:59 <BCoppens> chrisdone: we should
11:22:06 <BCoppens> dunno when we'll be arriving though
11:22:18 <mm_freak_> Phantom_Hoover: if you specifically want to write imperative code, yes
11:22:30 <chrisdone> BCoppens: what's your email?
11:22:36 <mm_freak_> Phantom_Hoover: but usually you'll want to write functional code, which is compiled to imperative machine code
11:22:38 <BCoppens> chrisdone: see pm :p
11:22:59 * chrisdone goes for pizza
11:24:14 <mm_freak_> Eduard_Munteanu: hi there…  may i PM you?
11:25:01 <copumpkin> chrisdone: what kind?
11:25:05 <Phantom_Hoover> mm_freak_, sure, but mutable arrays... don't make an awful lot of sense in properly functional code.
11:25:55 <mm_freak_> Phantom_Hoover: they make no sense at all, and you don't use them =)
11:26:11 <chrisdone> copumpkin: probably get some salamino e the pizza with the bianco cheese that i can't remember the name of
11:26:27 <mm_freak_> i sometimes use them for simple array stuff, which can be best expressed in an imperative way
11:26:31 <copumpkin> chrisdone: :O
11:26:45 <copumpkin> chrisdone: by the way, if you haven't yet, see if you can find burrata (or buffalo mozzarella)
11:26:49 <copumpkin> (just to eat on their own)
11:26:57 <Phantom_Hoover> mm_freak_, yes, but I was saying that when you *do*, you must therefore use monads.
11:27:02 <copumpkin> another good cheese is sottocenere al tartufo
11:27:05 * copumpkin shuts up
11:27:14 <mm_freak_> Phantom_Hoover: no, you don't have to
11:27:28 <mm_freak_> there are some abstractions like DiffArray
11:27:43 <Phantom_Hoover> That's interesting, though.
11:27:43 <mm_freak_> they use destructive update and copy on demand
11:27:59 <chrisdone> copumpkin:never heard of either of those, good recommendazione (tee hee)
11:28:27 <copumpkin> I'd use consiglio :)
11:28:36 <copumpkin> the cognate is raccomandazione, but it's not really used in the same way
11:29:00 <Eduard_Munteanu> mm_freak_: hi, yeah
11:41:11 <hpaste> dankna pasted “My monad, let me show you it” at http://hpaste.org/49947
11:41:33 <dankna> it is too slow (this test runs in 1.9 seconds for me) and I do not understand why.
11:45:58 <mm_freak_> dankna: try not forcing the intermediary result in (>>=)
11:46:11 <mm_freak_> otherwise your monad looks fine to me
11:46:18 <dankna> you mean take out the seq?
11:46:21 <dankna> I tried it that way too
11:46:38 <dankna> the profiler shows vast amounts of garbage being generated, so I thought perhaps...
11:47:04 <dankna> well, thank you for looking
11:47:11 <mm_freak_> that's not related to the intermediary result
11:47:40 <mm_freak_> you may want to try to force the state instead, but i don't think that fixes it
11:47:51 <mm_freak_> in fact i don't see what would cause garbage at all
11:48:18 <dankna> actually let me check something - I hadn't rerun the profiler since producing this reduction
11:48:27 <dankna> let me make sure it's sufficiently similar to the real program
11:48:52 <mm_freak_> you may want to try to prefer pattern-matching over 'runEverything', but since your monad is a newtype that shouldn't make a difference
11:49:00 * dankna nods
11:49:37 <dankna> yeah, I just did what I said, and yes, there's a ton of garbage
11:49:45 <mm_freak_> wait a minute
11:49:48 <dankna> to the tune of almost 3G of it
11:49:52 <mm_freak_> i think your mapM_ is the problem
11:50:02 <mm_freak_> i think mapM_ doesn't properly eliminate the list in your monad
11:50:06 <dankna> oh hm
11:50:18 <mm_freak_> try writing a recursive loop instead of using mapM_
11:50:19 <dankna> well, the real code exhibits similar behavior without the mapM_.  one sec, I'll turn it into recursion.
11:51:06 <ClaudiusMaximus> +RTS -hy looks like /
11:51:07 <mm_freak_> or wait
11:51:07 <dankna> hm
11:51:16 <mm_freak_> you can replace your mapM_ by a replicateM_
11:51:18 <dankna> that actually did substantially reduce time and heap usage
11:51:38 <ClaudiusMaximus> three way split between [] and Digits and Integer  (I'm using ghc 7.0.3 / integer-simple)
11:51:46 <mm_freak_> since you use mapM_ only for repeating the same operation, replicateM_ does exactly what you want
11:51:52 <dankna> ClaudiusMaximus, hmmm thanks
11:52:14 <hpaste> dankna annotated “My monad, let me show you it” with “My monad, let me show you it (annotation)” at http://hpaste.org/49947#a49948
11:52:28 <dankna> new version uses explicit recursion
11:54:21 <dankna> I actually get no meaningful output from -hy, just a graph with no data on it
11:54:28 <ClaudiusMaximus> dankna: replicateM_ takes it down to under 1kB constant memory usage
11:54:32 <dankna> hm!
11:54:45 <dankna> :t replicateM_
11:54:49 <dankna> oh no lambdabot
11:55:09 <ClaudiusMaximus> whereas before it peaked at 600M
11:55:15 <ClaudiusMaximus> (with mapM_)
11:55:31 <dankna> right
11:55:32 <dankna> hmm
11:55:36 <ClaudiusMaximus> replicateM_ :: Monad m => Int -> m a -> m ()  -- probably
11:55:41 <mm_freak_> avoid mapM_, when all you need is repetition
11:55:52 <mm_freak_> use replicateM_ or 'forever'
11:56:00 <dankna> I do not reproduce your improvement though
11:56:13 <jmcarthur> that advice makes sense, but i don't see why mapM_ should have such bad behavior here
11:56:26 <mm_freak_> dankna: have you removed the 'seq'?  it may actually reduce memory usage
11:56:27 <ClaudiusMaximus> dankna: i'm compiling with ghc -O3 -Wall dankna.hs -fforce-recomp -prof -auto-all -caf-all -rtsopts
11:56:31 <dankna> oh, good call
11:56:38 <dankna> you know there is no -O3 btw
11:56:45 <ClaudiusMaximus> seems to work
11:56:47 <dankna> -O2 is the highest
11:56:50 <mm_freak_> jmcarthur: because you ignore the elements, it doesn't know how to fuse…  i guess, it simply has no rule for that
11:56:51 <dankna> 3 is treated as 2
11:57:14 <mm_freak_> i'm pretty sure if you print the numbers from the list while mapping, it will go to constant memory usage
11:57:36 <Eduard_Munteanu> real 0m0.252s    here
11:57:39 <dankna> I still can't reproduce.  ClaudiusMaximus, could you annotate my paste with your version so I can stare at the diff until enlightenment?
11:58:07 <dankna> oh never mind
11:58:07 <dankna> I do
11:58:11 <dankna> I wasn't forcing recompilation
11:58:25 <dankna> okay
11:58:34 <dankna> so I do actually need to understand why this behavior is so bad
11:58:50 <dankna> because my real program is larger and doesn't do any mapMs
11:59:06 <dankna> it's particularly frustrating in that the profiler attributes the cost to the monad!
11:59:11 <mm_freak_> dankna: what about using ReaderT?
11:59:16 <dankna> oh I did
11:59:20 <mm_freak_> your monad is really just ReaderT IO
11:59:22 <dankna> this was my attempt to make things better by rewriting
11:59:25 <dankna> I started with that
11:59:34 <mm_freak_> then your problem is elsewhere
11:59:37 <dankna> yes
11:59:37 <Eduard_Munteanu> Is this about the NES emulator?
11:59:38 <mm_freak_> and a custom monad won't solve it
11:59:44 <dankna> no, it's not, this is the speech synthesizer
11:59:51 <dankna> yes, I agree
12:00:04 <mm_freak_> you need to find out where to force evaluation
12:00:12 <dankna> indeed, heh
12:00:48 <mm_freak_> for example i often find that my code has memory leaks, when i forget to force a record, when i updated an element
12:00:57 <dankna> hmm
12:00:57 <mm_freak_> unless the element is strict, of course
12:01:01 <dankna> well I did do things such as that
12:01:24 <dankna> as brute-force to determine if that's my problem, would it be a valid test to make all my records strict in all their elements?  heh
12:01:47 <dankna> that is, will that make the symptoms go away if my problem is of that nature
12:01:52 <mm_freak_> let x = x' { someXVar = newValue }; x `seq` doMore
12:02:06 <dankna> right
12:02:10 <mm_freak_> that may not solve your problem
12:02:13 <chrisdone> copumpkin: and by pizza, i meant indian curry
12:02:20 <copumpkin> oh, of course
12:02:31 <mm_freak_> in general if you don't have a good reason, you shouldn't make your fields strict
12:02:50 <dankna> certainly
12:02:55 <dankna> well, I didn't mean do that and leave it that way
12:03:03 <dankna> I just want to quickly determine if my problem is of this class
12:03:04 <mm_freak_> nonstrict fields generally perform better, and once you understand evaluation, their performance is also easier to predict
12:03:09 <chrisdone> though in the indian place an italian drunk guy was adamant at teaching me the meaning of the lyrics like si strada de sempre la desserte la cita
12:03:10 <dankna> and then narrow down the actual performance issues
12:03:19 <chrisdone> (or something like that)
12:03:45 <mm_freak_> dankna: if you want to see exactly where your problem is, use profiling
12:03:47 <chrisdone> (i've also had a few beers m'self)
12:03:48 <edwardk> i parsed that as some indian guy trying to teach you those lyrics, and was momentarily baffled
12:03:57 * chrisdone giggles
12:03:59 <Eduard_Munteanu> On CPU-intensive tasks strictness in records can be hit and miss.
12:04:13 <dankna> mm_freak_, but as I said, profiling attributes the expense to the monad (specifically to runEverything)
12:04:14 <chrisdone> all the while i was listening to Alice in Chains, the justaposizione was molto weird
12:04:20 <Eduard_Munteanu> (unboxing strict fields too)
12:04:40 <mm_freak_> dankna: i see
12:04:46 <edwardk> i don't like -funbox-strict-fields
12:04:55 <edwardk> i tend to mix and match more carefully than that
12:05:05 <mm_freak_> the profiler seems to miss the real issue then, but i have no experience with the profiler
12:05:09 <dankna> yeah
12:05:15 <mm_freak_> for me it really happens only for records
12:05:31 <mm_freak_> and mostly when calculating an updated version and forgetting to force properly
12:05:43 <ddarius> The profiler is not trivial to use and the common advice to beginners to "just profile their programs" is a bit disingenuous.
12:05:47 <dankna> well, I do use record updating
12:06:39 * hackagebot trifecta 0.5.1 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.5.1 (EdwardKmett)
12:06:44 <mm_freak_> dankna: for example i had a record with a current time value, which gets updated over time…  but it doesn't get replaced entirely, but receives time deltas
12:06:48 <Eduard_Munteanu> At a certain point, it's nice to experiment with the profiler and learn to use it, though.
12:07:05 <edwardk> i finally got the diagnostic formatting right, so if you can render diagnostics on long lines without overflowing
12:07:19 <edwardk> and it'll clip the line to keep the caret in focus
12:07:28 <mm_freak_> i.e.:  let t = addUTCTime dt t'
12:07:34 <edwardk> now to make prettier errors
12:07:40 <mm_freak_> what i didn't consider is that UTCTime is a record with two fields
12:07:46 <dankna> ah indeed
12:07:59 <mm_freak_> forcing it doesn't eliminate the inner thunks
12:08:22 <edwardk> i wish parsec was polymorphic in its error type =(
12:08:31 <chrisdone> why?
12:08:57 <chrisdone> can't you use MonadError and roll thine own?
12:08:58 <edwardk> because i have a very rich toolchain i'm building on top of and want to be able to return errors with the additional context
12:09:01 <ddarius> Eduard_Munteanu: Yes, but saying things like "oh just write your code and look at the profiling output if you have problems" is, to me, like saying "oh just write your code and look at the debugging output if you have problems;" ignoring the complexity of using those tools and the complexity of resolving problems later rather than earlier.
12:09:26 <edwardk> how does parsec deal with errors in the underlying monad it uses for reading?
12:09:35 <ddarius> edwardk: Talk to Antoine.  It should be a fairly simple change that can be done with little interface change.
12:09:57 <mm_freak_> ddarius: i have absolutely no experience with the profiler, so the best i can say is:  "try profiling your program"
12:10:23 <mm_freak_> i can imagine that profiling is a complicated task, but i simply don't know
12:10:40 <mm_freak_> you seem to be annoyed by everything i say…  somehow…
12:10:57 <edwardk> i also find that in trifecta i don't need the rudimentary source position tracking from parsec
12:11:01 <chrisdone> ddarius is just a badass. he loves all creatures
12:11:26 <edwardk> since i have to do some complicated gyrations to track it across #line directives in the base parser
12:11:40 * chrisdone tried to use the profiler today for a program and did not really grok everything
12:12:09 <ddarius> mm_freak_: I don't see how you got that impression here.  The first comment was more or less agreeing with you and the second wasn't directed to or at you.  Even the first comment wasn't directed at you.
12:12:53 <ddarius> mm_freak_: If you are one of the people that say the things, then I'd be mildly annoyed at that, but you haven't said those things now.
12:13:36 <mm_freak_> ddarius: well, i was the one saying, "try profiling", in a way, which makes it sound like a simple thing to do
12:13:39 <edwardk> mm_freak: ddarius has a rather flat affect, even in person ;)
12:14:22 <erus`> did anyone else see john carmack talk about haskell in his keynote?
12:14:28 <edwardk> erus`: yeah
12:14:44 <ddarius> mm_freak_: There's a difference between "I have a performance problem now." "Try profiling."  and "How do I write fast code?" "Don't worry about it just profile later."
12:15:14 <ddarius> erus`: Unless he also "talked" about it earlier, he very passingly mentions it.
12:15:44 <ddarius> He says some much more entertaining and interesting stuff a little bit before it.
12:16:03 <chrisdone> yeah i saw that reddit post too
12:16:09 <chrisdone> i quoted for truth, and will quote again
12:16:21 <chrisdone> It's not because people are no good. The very best programmers always make mistakes. This is something that I've really internalized; that, no matter how good you think you are, you are making mistakes all the time, and you have to have structures around you to try and help you limit the damage that your mistakes will cause, find them as early as possible, so that you can correct them, and the earliest possible time is at compile time. So I'm al
12:16:21 <chrisdone> l about trying to be much more restrictive on what we can do, here.
12:16:36 <chrisdone> sums up one reason for using Haskell completely
12:19:30 <ddarius> mm_freak_: Really, my point is 1) if one doesn't understand even roughly how Haskell execution works then profiling output will probably be unintelligible at best and misleading at worse, and 2) one can go overboard with discouraging "premature optimization" to the point that it becomes like discouraging "premature debugging."
12:19:30 <angzam79> .
12:19:35 <ClaudiusMaximus> i found a bug today in some C++ - i used memset and forgot to multiply the count by sizeof(*ptr)...
12:19:48 <chrisdone> ClaudiusMaximus: lol
12:20:01 <chrisdone> report it to Bjarne Stroustrup and BCC to James Gosling
12:20:03 <ClaudiusMaximus> been there for months...
12:20:13 <ClaudiusMaximus> chrisdone: it was C++ i wrote
12:20:39 <ddarius> I don't think who wrote the code had much to do with chrisdone's comment.
12:20:53 <ClaudiusMaximus> i don't know who james gosling is, so it's lost on me
12:21:08 <ddarius> You do know who Bjarne Stroustrup is.
12:21:24 <ClaudiusMaximus> vaguelly
12:21:28 <ddarius> What?
12:21:45 <dylukes> Stroustrup is the C++ creator dood.
12:21:51 <ClaudiusMaximus> architect of C++, apart from that dunno what
12:21:54 <ddarius> ClaudiusMaximus: You do know who Simon Marlow and Simon Peyton Jones are right?
12:21:55 <dylukes> Gosling is thé Java creator dood.
12:21:58 <ClaudiusMaximus> ah
12:22:04 <dylukes> I've met Gosling.
12:22:11 <ClaudiusMaximus> ddarius: :)
12:26:32 <chrisdone> dylukes: did he sign your floppy disc?
12:26:52 <chrisdone> i didn't intend that to sound like an innuendo. :-(
12:29:02 <erus`> lol
12:31:19 <mm_freak_> ddarius: ok, i may have wrongly assumed that you were referring to me
12:32:18 <ClaudiusMaximus> dankna: try adding a type signature fixing the list to [Int]
12:32:24 <rs463> hi, I'm having a problem with haddock. I'm getting a warning: "could not find link destinations for:" for many modules
12:32:45 <dankna> ClaudiusMaximus, but this isn't the real program ? in the real program there's nothing quite analogous to the list
12:32:49 <rs463> for many, including Data.Time.Clock.UTC.UTCTime, Text.Html.Html etc...
12:33:07 <dankna> ClaudiusMaximus, I did manage to reproduce your results after I added -fforce-recomp
12:33:08 <rs463> I'm running haddock as:
12:33:35 <ClaudiusMaximus> dankna: well, here it makes it return to constant space, i guess enumFromTo for Int is strict but for Integer is lazy so massive thunk builds up?
12:33:41 <rs463> SF (~ivan@187.106.54.41) has joined channel #haskell
12:33:41 <rs463> ERC> runghc Setup haddock --executables --hyperlink-source
12:33:45 <rs463> .. help ?
12:33:55 <dankna> that's my understanding, yes
12:34:02 <dankna> I've been bitten before by Integer defaulting thing
12:34:15 <mm_freak_> dankna: at the beginning it can be really brute-forcy to determine issues with laziness
12:34:26 <dankna> indeed
12:34:43 <rs463> (and I'm running configure as: $ runghc Setup configure --prefix=$HOME --user)
12:35:05 <mm_freak_> i think to really find the problem, we need to see the real code…  preferably with ReaderT IO instead of a custom monad
12:35:34 <dankna> okay.  well, let me take a minute to take the custom monad out and post it somewhere.
12:35:38 <dankna> it's about 1500 lines
12:35:39 <mm_freak_> rs463: when does that happen?  at installation time?
12:35:46 <mm_freak_> dankna: oh
12:35:49 <dankna> so obviously I wanted to reduce it if possible, but it seems that it's not
12:35:53 <danharaj> does ghc still have the arrow sugar as of GHC 7?
12:35:54 <Saizan> rs463: that means that you don't have the haddock docs for those modules, iirc
12:35:59 <dankna> oh hehe
12:36:12 <rs463> Saizan: cool. How do I obtain them ?
12:36:16 <mm_freak_> dankna: ok, honestly i don't feel like going through 1500 lines of code now, but try to narrow it down by running individual parts of your program
12:36:23 <dankna> I understand!
12:36:27 <erus`> wtf is this arrow i keep hearing about?
12:36:27 <dankna> I would have been surprised if you did
12:36:38 * hackagebot uhexdump 0.3 - hex dumper for UTF-8 text  http://hackage.haskell.org/package/uhexdump-0.3 (EricKow)
12:36:50 <mm_freak_> erus`: you mean Control.Arrow?
12:36:56 <Saizan> rs463: how did you get those libs?
12:36:58 <ClaudiusMaximus> danharaj: seems -XArrows enables it (at least it gives parse error for let f proc = 42 in ghci)
12:37:09 <zomg> In a way this is scary... I don't even fully understand monads, but I still managed to write some code which dynamically loads (and reloads) haskell modules into my app... :D
12:37:16 <mm_freak_> dankna: sure it does
12:37:21 <mm_freak_> enable the Arrows extension
12:37:37 * dankna blinks
12:37:44 <mm_freak_> uhm
12:37:47 * dankna suspects that was misdirected
12:37:50 <mm_freak_> that was for danharaj =)
12:37:53 <dankna> yeah haha
12:38:10 <dankna> someone in one of the channels the other day accidentally addressed a comment to himself? it was one of us with d-names.  it was amusing.
12:38:11 <cec24> hi, i'm having some trouble with types and exception handling
12:38:35 <mm_freak_> danharaj: i don't expect arrow notation to be removed any time soon, and i would kill the person proposing to remove it =)
12:38:36 <danharaj> I wrote a pull-based frp implementation based on applicative, I'm hoping to give it a push-based implementation via arrows.
12:38:48 <cec24> according to real world haskell, :t handle (const (return [])) should be:: IO [a] -> IO [a]
12:38:48 <danharaj> So, time to learn arrows. :p
12:39:18 <mm_freak_> danharaj: funny…  i just uploaded my arrowized FRP library yesterday =)
12:39:22 <danharaj> heh
12:39:32 * jmcarthur is also working on an FRP library...
12:39:32 <cec24> with handle from Control.Exception, but in ghci i get an error about an ambiguous type variable "e0"
12:39:37 <jmcarthur> as usual :)
12:39:42 <danharaj> FRP libraries are in one-to-one correspondence with monad tutorials.
12:39:47 * chrisdone pounces on jmcarthur 
12:39:54 <mm_freak_> danharaj: no, i don't think so
12:39:57 * jmcarthur pounceblocks
12:40:07 * chrisdone bounces
12:40:11 <danharaj> mm_freak_: maybe modulo burritos?
12:40:12 <hpaste> cec24 pasted “handle” at http://hpaste.org/49952
12:40:16 <rs463> Saizan: take for example, Text.Html.Html
12:40:31 <mm_freak_> i wrote my FRP library, because yampa/animas don't really scale well and their internals creep the hell out of me
12:40:41 <danharaj> Also what is your frp library called? I've been looking at reactive-banana and elerea.
12:40:44 <jmcarthur> mm_freak_: what is your frp library?
12:40:55 <rs463> Saizan: no sorry, take Graphics.GD.Image
12:40:57 <mm_freak_> jmcarthur: http://haskell.org/haskellwiki/Netwire
12:41:05 <rs463> I just ran $ cabal install gd
12:41:12 <mm_freak_> danharaj: see above
12:41:28 <rs463> see http://hackage.haskell.org/packages/archive/gd/3000.4.0/doc/html/Graphics-GD.html
12:41:30 * jmcarthur is working on monadic frp
12:41:35 <Saizan> rs463: then you'll have to repeat that but with --enable-library-profiling
12:41:42 <rs463> cool !
12:41:42 <mm_freak_> cec24: that's because you don't fix the exception type
12:41:44 <rs463> thanks!
12:41:50 <Saizan> rs463: err, not profiling, documentation
12:41:54 <mm_freak_> cec24: try this instead:  handle (\(_ :: SomeException) -> …)
12:42:09 <rs463> Saizan: thank you very much!
12:42:10 <cec24> mm_freak_: i'm a pretty new at this, ok i'll try that
12:42:32 <Saizan> rs463: you can also make this the default by editing ~/.cabal/config
12:42:44 <mm_freak_> cec24: background is that 'catch' and 'handle' can actually tell the exception type and react only to certain types…  SomeException acts sort of like a wildcard type
12:42:49 <danharaj> I've also been thinking of modelling frp on continuation passing style, but very vaguely.
12:42:51 <cec24> mm_freak_: but that code is listed ass ok in real-world-haskell, it's confusing to me
12:43:08 <jmcarthur> huh, signal inhibition sounds cool
12:43:45 <mm_freak_> jmcarthur: yes, it's not just a yampa imitation…  it has some features, which i haven't seen in other FRP libraries yet
12:43:56 <rs463> Saizan: (it's --enable-documentation, cheers)
12:43:57 <cec24> mm_freak_: i get an "illegal signature in pattern: SomeException" error doing that
12:44:10 <mm_freak_> cec24: RWH may be referring to 'handle' from System.IO.Error
12:44:35 <mm_freak_> cec24: oh, indeed, for that type signature you need ScopedTypeVariables, i think
12:44:39 <mm_freak_> cec24: but you can do this instead:
12:44:52 <mm_freak_> handle (\ex -> const … (ex :: SomeException))
12:45:03 <mm_freak_> has the same effect, but should be h98
12:45:19 <Saizan> handle (\(SomeException _) -> ..) -- also
12:45:37 <mm_freak_> or you can write a separate exception handling function with a type signature
12:46:02 <mm_freak_> let handler :: SomeException -> IO X; handler _ = … in handle handler
12:46:16 <cec24> mm_freak_: ok so: handle (\(SomeException _) -> return []0
12:46:26 <cec24> mm_freak_: seems to have the right signature
12:46:49 <andares> hey, does ADT mean abstract data type or something? lyah doesn't actually define it anywhere.
12:46:59 <mm_freak_> cec24: yes, Saizan's variant should work just fine, unless you do weird hackery
12:46:59 <chrisdone> yeah
12:47:05 <lpsmith> andares: algebraic data type
12:47:25 * chrisdone read abstract as algebraic, /me goes to bed
12:47:29 <cec24> mm_freak_: man, this is all a bit too confusing
12:47:41 <cec24> mm_freak_: thanks for the help though :)
12:47:42 <mm_freak_> cec24: coming from other languages?
12:48:40 <cec24> mm_freak_: yup, just starting to get a hold of some of this but learning haskell always feels like trying to pick up a big slippery cube of ice, whenever i have some hold on it it just slides away
12:49:20 <andares> lpsmith: what is that, formally?
12:49:36 <lpsmith> andares: basically ADTs are what you define in a data Foo = Foo | Bar Foo | Baz Foo Foo declaration
12:49:42 <andares> w
12:49:47 <mm_freak_> cec24: i found that you learn it best by just using it…  you should read, but don't forget to write code…  the confusion goes away at some point
12:50:19 <andares> lpsmith: wait, can you actually define data <X> = <X>?
12:50:23 <lpsmith> formally,  it's the fixpoint of a functor over the category of complete partial orders
12:50:31 <mm_freak_> usually that point is really a point, where suddenly you experience a sensation of clarity and everything starts to make sense =)
12:50:34 <andares> or rather, I guess you could, but wouldn't it be useless?
12:50:54 <cec24> mm_freak_: sound advice, i've definitely made the most progress by trying to actualy do interesting things
12:51:37 <mm_freak_> andares: single-constructor types are useful in haskell
12:51:46 <lpsmith> andares: well,  the first "Foo" on the right of the = in my example refers to the data constructor,  the remaining Foo's refer to the type constructor "Foo"
12:51:51 <andares> mm_freak_: what is a single-constructor type?
12:51:52 <mm_freak_> but since they are all isomorphic to (), you would usually just use ()
12:52:08 <mm_freak_> andares: a type with only one variant on the right side
12:52:10 <andares> oh, so a data constructor with nullary args?
12:52:12 <lpsmith> you might find the GADT syntax easier to understand
12:52:16 <mm_freak_> data MySingletonType = MyConstructor
12:52:29 <mm_freak_> data TwoConstructors = A | B
12:52:46 <mm_freak_> TwoConstructors is isomorphic to Bool
12:52:50 <mm_freak_> data Bool = True | False
12:52:55 <mm_freak_> etc.
12:53:12 <lpsmith> The data constructor namespace is separate from the type constructor namespace
12:53:14 <andares> and True is a data constructor with null args?
12:53:23 <mm_freak_> lpsmith: while GADT syntax indeed seems to be easier to understand to me, the usual introductions to GADTs are not
12:53:28 <mm_freak_> andares: yes
12:53:52 <lpsmith> data Foo where  {  Foo :: Foo;   Bar :: Foo -> Foo;   Baz :: Foo -> Foo -> Foo }
12:54:00 <andares> it confuses me that the data keyword is used to define type constructors as well as data constructors.
12:54:40 <mm_freak_> andares: 'type' would be a better word, i guess, but it's 'data' now and 'type' is something different
12:54:53 <lpsmith> well,  most type constructors have several data constructors,  they form a cohesive unit,  known as an algebraic data type.
12:55:24 <mm_freak_> lpsmith: sure about that?  i think most types are single-constructor types
12:55:46 <lpsmith> mm_freak_: sure...  one or more data constructors is what I meant :)
12:55:51 <andares> lpsmith: I get an error about illegal generalised algebraic data declaration for `Foo' when I try to compile your definition.
12:55:59 <jmcarthur> claims either way i think depend largely on your personal style and on the project you are working on
12:56:02 <mm_freak_> lpsmith: i'm talking about data constructors, too =)
12:56:35 <mm_freak_> andares: that's nonstandard syntax, for which you need to enable an extension
12:56:36 <lpsmith> andares: you need {-# LANGUAGE GADTs #-} at the top of your file
12:57:03 <mm_freak_> i recommend not using GADT syntax for now
12:57:51 <mm_freak_> understand ADTs first, before moving to GADTs and their more flexible syntax
12:58:10 <djahandarie> Personally I'd just teach GADTs from the start
12:58:11 <lpsmith> I don't think there is much to fear from GADT syntax,  I know some people have been using it to teach haskell to newbies
12:58:25 <jmcarthur> i think i would have been happier learning GADT syntax for the start
12:58:39 <jmcarthur> doesn't mean you have to learn all the fancy tricks you can do with it
12:58:43 <mm_freak_> i think there is too much material outside, for which you really should master the standard syntax
12:58:46 <lpsmith> mm_freak_: there is a difference between using GADT syntax for defining plain old ADTS and using GADTs
12:59:13 <andares> lpsmith: so can you use type constructors like that recursively to define a tree of types?
12:59:26 <lpsmith> andares: yup
12:59:34 <mm_freak_> andares: tree of types or of values?
12:59:44 <lpsmith> err
12:59:44 <andares> tree of types, I think.
12:59:57 <andares> wait, values I guess.
12:59:58 <mm_freak_> for a tree of values you can use a normal ADT
13:00:07 <lpsmith> I misread that as "type of trees"
13:00:16 <jmcarthur> lpsmith: GHC 7.2 will have a GADTSyntax extension that gives you the syntax without the extra power
13:00:26 <mm_freak_> data BTree a = Leaf a | Branch (BTree a) (BTree a)
13:00:37 <roconnor> @hoogle listToMaybe
13:00:44 <alpounet> jmcarthur, really ?
13:00:53 <mm_freak_> or alternatively:  data BTree :: * -> * where Leaf :: a -> BTree a; Branch :: BTree a -> BTree a -> BTree a
13:01:00 <sm> hey all
13:01:06 <alpounet> uh
13:01:16 <alpounet> not sure of the point of this extension but ok
13:01:29 <mm_freak_> (i think, it is visible from that example, why i recommend using h98 ADT syntax, before learning GADT syntax)
13:01:33 <jmcarthur> oh there is a semantic difference after all
13:01:38 <jmcarthur> http://www.haskell.org/ghc/dist/stable/docs/html/users_guide/data-type-extensions.html#gadt-style
13:01:45 <jmcarthur> but it's still not the full power of GADTs
13:01:52 <sm> how come haddock complains about Overlapping instances for Data Day, when ghc doesn't ? and, why does ghc require me to define that instance when it's already there in Data.Time.Calendar.Days ?
13:02:43 <jmcarthur> alpounet: the semantic point seems to be that you can bring type class instances into scope on a per-constructor basis
13:02:46 <jmcarthur> when pattern matching
13:02:50 <mm_freak_> i've never seen haddock complaining about overlapping instances
13:03:14 <mm_freak_> jmcarthur: GADT syntax also gives you existential quantification for free
13:03:38 <jmcarthur> ah
13:03:48 <mm_freak_> data MyObj :: * where MyObj :: Object a => a -> MyObj
13:03:51 <ddarius> GADT syntax also turns typos into code that passes the compiler.
13:03:52 <copumpkin> so basically real GADTs add an implicit ~ for you over GADT syntax
13:04:40 <ddarius> Adding equality constraints was the cleverest move by SPJ.
13:04:43 <andares> mm_freak_: for BTree, don't you mean data BTree a = Leaf a | Branch a (BTree a) (BTree a)?
13:04:58 <Saizan> ddarius: which typos?
13:05:02 <mm_freak_> andares: in that case, i would drop the argument of Leaf
13:05:29 <mm_freak_> andares: my variant has only values at its outermost leafs, while your variant can have values everywhere
13:05:39 <andares> mm_freak_: ah, I see.
13:05:44 <ddarius> Saizan: data Foo a where Foo :: b -> Foo a; Bar :: int -> Foo a
13:05:46 <andares> I am going to build a priority queue to test this out.
13:06:34 <copumpkin> plusOne :: int -> int
13:06:41 <copumpkin> plusOne x = x
13:06:54 <hpc> copumpkin: diabolical!
13:07:00 <ion> hah
13:07:19 <mm_freak_> plusOne :: int -> largerInt
13:07:28 <mm_freak_> plusOne = plusOne
13:07:42 * ddarius personally thinks that the data Foo a where ... syntax should not be allowed and the kind signature syntax should be required.
13:07:46 <sm> mm_freak_: it's haddock 2.9.2, https://gist.github.com/1130761
13:07:57 <mm_freak_> ddarius: i agree
13:08:10 <mm_freak_> the type variable syntax is very misleading
13:08:39 <mm_freak_> sm: sorry, no idea…  you may want to post this to the mailing list
13:08:52 <sm> aha.. it fails the same way with ghc 7 (on the machine where haddock is failing)
13:09:07 <sm> thx
13:09:14 <mm_freak_> sm: you mean it doesn't compile with GHC 7, but does with GHC 6?
13:10:29 <mm_freak_> sm: well, i find it quite understandable that haddock complains about overlapping instances, if you redefine the same instance, which is already defined in a module
13:10:36 <mm_freak_> make sure you import that module
13:10:46 <dolio> The typos aren't a problem when you're actually required to quantify your variables.
13:10:48 <mm_freak_> instances are not visible automatically
13:12:00 <sm> mm_freak_: right, I was originally using ghc 6 which didn't complain. Apparently there's an instance in Data.Time.Calendar.Days, but not importable. Some 6 vs 7 difference, I'll figure it out
13:12:15 <ddarius> dolio: That was the thrust of my statement.
13:12:33 * sm is porting to cmdargs
13:12:35 <mm_freak_> sm:  there are no non-importable instances, because there is no way to write non-exportable instances
13:12:53 <mm_freak_> perhaps the instance in question is defined elsewhere?
13:13:05 * ddarius is on record as having stated that he thinks Haskell should never have allowed implicit quantification.
13:13:44 <andares> hm. so I'm trying to define a min-heap priority queue in Haskell. what's the best way to get a leaf of the priority queue tree?
13:13:49 <dolio> I don't think implicit quantification is an essential part of GADT syntax.
13:14:00 <mm_freak_> andares: recurse into the tree
13:14:02 <dolio> Agda has what I'd call the same syntax, but you can't do implicit quantification.
13:14:05 <sm> mm_freak_: my ghc was using time 1.1.* while my haddock was using time 1.2.*, I expect
13:14:24 <mm_freak_> sm: oh yes, that's well possible
13:14:25 <andares> mm_freak_: should I get the leaf in a separate function though?
13:14:33 <mm_freak_> sm: you should try to cabalize your code
13:14:47 <mm_freak_> if it is cabalized, try to fix the version of the time package
13:14:48 <Saizan> ironically, it's less of a trouble to explicitly quantify in haskell than in agda, since you usually have less stuff to quantify
13:15:07 <mm_freak_> andares: this is a design choice, and i won't take it from you =)
13:15:14 <danharaj> what laws does an instance of ArrowLoop have to satisfy?
13:15:15 <sm> it's cabalized, but I am compiling on local machine and pushing to server where haddock runs as a commit hook
13:15:25 <mm_freak_> andares: part of learning is to do it the wrong way at first
13:15:31 <andares> mm_freak_: my only concern is speed, if Haskell is going to do log N things where it shouldn't.
13:15:58 <mm_freak_> andares: it does exactly the operations you tell it to do
13:15:58 <andares> in a procedural implementation, the priority queue's strength comes from its array.. hm.
13:16:13 <andares> perhaps I should implement this with a list instead of a tree.
13:16:18 <ddarius> mm_freak_: Except for the ones it doesn't do.
13:16:30 * sm awaits snow leopard to get lion to get ghc 7 on this mac
13:16:40 <mm_freak_> ddarius: it doesn't necessarily do what you want it to do
13:16:48 <mm_freak_> but it does do, what you tell it to do
13:17:01 <mm_freak_> and it can be difficult to grasp the difference sometimes =)
13:17:30 <ddarius> mm_freak_: I didn't make any comment about the difference between intent and statement.  I said it doesn't do all the operations you tell it to do.
13:18:14 <mm_freak_> ddarius: that's a matter of view…  main = const (return ()) undefined  -- you didn't tell it to crash, and it doesn't
13:18:44 <ddarius> I didn't say anything about it not doing things you didn't tell it to do.
13:18:57 <mm_freak_> ok, i'm lost
13:19:04 <ddarius> But I agree that some cases are a matter of perspective.
13:19:13 <mm_freak_> ah, good =)
13:20:39 <andares> does Haskell have array lists?
13:20:55 <andares> or optimize into them?
13:20:55 <chrisdone> what's an array list?
13:21:04 <andares> a list with O(1) random access time.
13:21:08 <andares> for my purposes.
13:21:33 <jmcarthur> andares: Data.Sequence gives you O(log n) random access
13:21:50 <jmcarthur> andares: we also have arrays, both mutable and immutable
13:21:55 <jmcarthur> with O(1) lookup
13:21:58 <mm_freak_> andares: Data.Array or preferably the 'vector' package give you O(1)
13:22:01 <andares> I thought nothing was mutable.
13:22:05 <andares> hm, okay.
13:22:06 <Eelis> wait, "O(log n) random access"? that sounds like a contradiction
13:22:15 <Eelis> but maybe that's my C++ background
13:22:15 <benmachine> andares: mutability is avoided in haskell, but definitely possible
13:22:16 <jmcarthur> andares: mutable structures require ST or IO
13:22:36 <mm_freak_> andares: some people (including me) argue that haskell is better suited for imperative programming than most supposedly imperative languages =)
13:22:48 <luite> Eelis: why? how about balanced trees?
13:22:52 <chrisdone> Eelis: Data.Map has log n access
13:23:09 <benmachine> Eelis: to me "random access" means "accessing any point in the structure" and so "O(log n) random access" means "accessing any point in the structure takes log of the size of the structure time"
13:23:33 <jmcarthur> unlike imperative languages, haskell basically gives you direct control over effects
13:23:38 <Eelis> oh, ok. in C++, for a container to qualify as "supporting random access", it must support accessing arbitrary indices in O(1)
13:23:58 <mm_freak_> unlike most imperative languages, haskell has some neat combinators for imperative programming
13:24:00 <jmcarthur> Eelis: i don't agree, even in C++
13:24:13 <Eelis> jmcarthur: lol, it's not your place to disagree in C++. the standard is perfectly clear on this point
13:24:18 <ddarius> The RandomAccessIterator concept may suggest that.
13:24:22 <mm_freak_> and some neat DSLs, my favorite being ContT
13:24:25 <jmcarthur> Eelis: at least not if you qualify its algorithmic complexity
13:24:31 <Eelis> jmcarthur: see what ddarius said.
13:24:32 <copumpkin> http://www.sgi.com/tech/stl/RandomAccessContainer.html
13:24:42 <copumpkin> "It provides amortized constant time access to arbitrary elements."
13:24:51 <andares> is there any way I can structure a tree so that I can get a leaf node in O(1) time then?
13:24:53 <copumpkin> I do think that's a questionable definition though
13:24:54 <andares> (btree)
13:25:21 <mm_freak_> andares: no
13:25:29 <companion_cube> andares: to access left and right leaves, you have finger trees
13:25:36 <companion_cube> but real random access, clearly not
13:25:45 <andares> but if I structure my btree as a list, I can do it.
13:25:49 <jmcarthur> it's not uncommon in these parts to argue that memory access is not O(1) at all, so if one was to run with that then no container in C++ is "random access" :P
13:26:00 <andares> where the children of element n are at index 2n and 2n+1
13:26:15 <mm_freak_> andares: only arrays can be accessed in constant time…  an simple static-size array would look like:  data Array a = Array a a a a a a a
13:26:15 <danharaj> O(1) tends to swallow things like cache hierarchies, disk access, the speed of light, etc.
13:27:03 <companion_cube> danharaj: there still is a constant upper bound
13:27:13 <mm_freak_> andares: however, note that O(log n) is not slow…  and most data structures with O(log n) access time also have O(log n) for many other useful operations
13:27:13 <danharaj> not if your memory is unbounded
13:27:16 <mm_freak_> somethat that's not true for arrays
13:27:20 <danharaj> Then you have a cube root factor or something like that.
13:27:26 <companion_cube> danharaj: which is not realistic
13:27:27 <jmcarthur> O(log n) time is basically as good as O(1) time in the algorithmic sense
13:27:37 <jmcarthur> err
13:27:41 <jmcarthur> i misstated
13:27:48 <danharaj> companion_cube: Well then everything is O(1) because realistically everything operates on data sets of bounded size.
13:27:56 <companion_cube> for real RAM, you have like one memory read lower or equal 100 cycles
13:28:06 <jmcarthur> not sure how to state what i meant
13:28:22 <mm_freak_> andares: consider that O(log n) for binary trees means:  you need 16 branches to look up the leaf of a tree with 2^16 (!) entries
13:28:26 <companion_cube> but i do agree, O(ln n) is almost constant access in practice
13:28:30 <andares> mm_freak_: yeah, but as an exercise I'm trying to make the most therotically efficient priority queue possible.
13:28:49 <jmcarthur> andares: in what operation(s)?
13:28:53 <danharaj> I mean, the fact that it is not O(1) is an issue for NUMA architectures.
13:29:05 <andares> NUMA?
13:29:14 <andares> jmcarthur: I mean, push and pop..
13:29:15 <danharaj> non-uniform-memory-access
13:29:19 <mm_freak_> andares: the most efficient algebraic priority queue has O(log n) access time, as long as your underlying data structure is a tree
13:29:26 <dolio> http://www.youtube.com/watch?v=60og9gwKh1o
13:29:27 <jmcarthur> andares: that sounds like a stack
13:29:35 <ddarius> The draft standard seems to say nothing at all about the algorithmic complexity of the operations of a random access iterator.
13:29:37 <mm_freak_> and you basically cannot get around using trees, as long as you want dynamic size
13:29:40 <andares> jmcarthur: it's like a stack, but elements are sorted.
13:29:47 <andares> it's implemented with a heap.
13:29:54 <mathijs> Hi all, I have a somewhat offtopic question, but I've been googling for an hour, and most of the time people here are very knowledgeable math-wise :)   is it possible to encrypt a message to multiple recipients without a linear growth in message size?
13:30:00 <mm_freak_> isn't that just Data.Sequence?
13:30:04 <mm_freak_> no
13:30:06 <mm_freak_> Data.Set
13:30:09 <luite> mm_freak_: fibonacci heaps?
13:30:31 <jmcarthur> andares: http://hackage.haskell.org/packages/archive/heaps/0.2/doc/html/Data-Heap.html
13:30:34 <bscarlet> saying the elements are sorted is misleading.
13:30:36 <mm_freak_> luite: no idea
13:30:40 <jmcarthur> andares: O(1) insertion, O(1) minimum element
13:30:46 <luite> yeah
13:30:49 <chrisdone> dolio: why did you paste that?
13:30:57 <mm_freak_> mathijs: ask the same question in ##crypto
13:30:58 <luite> though deleting an arbitrary element still is O(log n)
13:30:59 <dolio> chrisdone: NUMA.
13:31:09 <mathijs> I mean... you can always encrypt a message (symetric key), and encrypt that key with pke to all recipients, but with 1000 recipients, that gets nasty too
13:31:10 <mm_freak_> mathijs: i think it's pretty off-topic here =)
13:31:10 <chrisdone> dolio: ALO?
13:31:10 <jmcarthur> andares: but you pay O(log n) to delete the minimum element as opposed to looking it up
13:31:19 <andares> hm.
13:31:26 <mathijs> mm_freak_: I think so too :P
13:31:29 <mm_freak_> mathijs: but i'm willing to help in ##crypto ;)
13:31:40 <mathijs> join ##crypto
13:31:46 <danharaj> no I refuse
13:31:50 <Wild_Cat> mathijs: if you're using PKI, you need to encrypt the message with every recipient's public key. That's the point of the whole thing ;)
13:31:57 <mathijs> hehe ;)   damn slashes
13:32:06 <mm_freak_> Wild_Cat: no, you don't
13:32:12 <mm_freak_> there is a way to avoid that
13:32:14 <jmcarthur> andares: also, something to keep in mind about purely functional data structures is that in addition to whatever operations it has, it also have one really fast operation that most impure data structures don't have so cheaply...
13:32:17 <mm_freak_> but i won't explain it here =)
13:32:25 <jmcarthur> andares: that would be free undo
13:32:41 <andares> I think I'll just use trees.
13:32:44 <jmcarthur> *it also has
13:32:51 <danharaj> :t fix
13:32:59 <danharaj> lambda bot where are you :|
13:33:15 <ddarius> danharaj: She has forsaken you in your hour of need.
13:33:22 <monochrom> I'm writing various backtracking searches to help solve puzzle games. O(0) undo makes my day.
13:33:26 <jmcarthur> andares: finger trees are easy to make priority queues with
13:33:28 <danharaj> I'm going to pretend she's here, but also use ghci
13:33:35 <jmcarthur> with pretty nice complexity
13:33:41 <andares> jmcarthur: what is a finger tree?
13:33:42 <danharaj> :t (\f b -> let (c, d) = f (b,d) in c)
13:33:45 <jmcarthur> i don't think it's optimal complexity though
13:33:52 <dolio> You can make a priority queue using finger trees that has pretty good asymptotics.
13:34:15 <luite> monochrom: but you often pay for cheap undo by generating much more data that needs to garbage collected
13:34:20 <jmcarthur> andares: it's an annotated 2-3 tree or somesuch like that
13:34:31 <jmcarthur> andares: "with the ends lifted up"
13:34:43 <jmcarthur> there's a paper somewhere that explains better than i ever could
13:35:13 <dolio> O(n) heapify, O(log n) dequeue, O(1) (?) enqueue...
13:35:22 <monochrom> it is more than O(0) undo. it is also non-error-prone. in C, to implement backtracking you always have to remember to clone, that's an opportunity for human error
13:35:26 <andares> hm
13:35:53 <dolio> It's O(log n) peek instead of O(1), though.
13:35:56 <jmcarthur> monochrom: true
13:36:15 <jmcarthur> dolio: by enqueue do you mean cons or snoc?
13:36:18 <jmcarthur> if so then it's O(1)
13:36:41 <dolio> jmcarthur: You can do either. It's the monoid that handles the priority.
13:37:04 <jmcarthur> right. i just was responding to that ? you put after O(1)
13:39:02 <ddarius> @where Okasaki
13:39:10 * ddarius will never learn.
13:39:43 <chrisdone> is lambdabot gone forever or until cale wakes up?
13:40:29 <jmcarthur> yes
13:41:00 <chrisdone> :)
13:41:28 <Saizan> Right yes, i'd imagine
13:41:50 <Saizan> if that was a constructive or
13:44:32 <jules2> I'm trying to understand comonads. What should I read? Specifically I'd like to learn how they help to write programs (what I've found so far was rather theoretical). And I'd like to understand their relation to monads, and in general what "dual" in "comonads are the dual of monads" means. For example is there a bijection between monads and comonads?
13:44:40 <jules2> What should I read?
13:46:55 <mm_freak_> jules2: comonads are monads with the arrows flipped around
13:47:02 <bscarlet> jules2: I recently asked a very similar question, and found some value in reading http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html, to which I was pointed.
13:47:14 <mm_freak_> monads:  return :: a -> m a;  comonads:  extract :: w a -> a
13:47:29 <mm_freak_> that's what "dual" means in simple terms
13:47:44 <bscarlet> mm_freak_: what's in mean in complex terms?
13:47:49 <bscarlet> s/in/it/
13:48:08 <jules2> yup, that's what i understood about duality, but what I don't understand is why flipping arrows is a meaningful operation
13:48:30 <mm_freak_> comonads can express a certain (apparently small) set of patterns very elegantly, but i haven't used them productively
13:48:39 <mm_freak_> like streams
13:49:05 <mm_freak_> bscarlet: that's a question edwardk can explain better than me =)
13:49:27 <jules2> I have read that blog post :) it explains that particular comonad nicely but it didn't clear up my general confusion
13:49:33 <djahandarie> Well, one think to keep in mind is that Monad and Comonad in Haskell are just using the (->) endofunctor from Hask to Hask
13:49:51 <jules2> what is Hask?
13:49:55 <mm_freak_> jules2: well, one implication of the flipped arrows is this:  while monads model patterns, where it's safe to "go in" and unsafe to "get out", in comonads it's safe to "get out" and unsafe to "go in"
13:49:55 <flapjackery> could anyone explain how derivative function works?
13:49:56 <flapjackery> let deriv f = (fun x -> (f (x +. dx) -. f x) /. dx);;
13:50:20 <djahandarie> jules2, category of haskell types. You can pretend its just Set (category of sets) if that helps.
13:50:34 <mm_freak_> jules2: an infinite stream is something, from which it's always safe to get a value out of
13:50:58 <jules2> flapjackery, it is a numerical approximation to the real derivative, if you look at the exact definition of the derivative you'll see that it is the same but with limit dx -> 0
13:51:33 <djahandarie> So "flipping the arrows" is a little more general when you are discussing any category rather than just Hask.
13:51:57 <flapjackery> @jules2 thanks
13:52:18 * edwardk looks up at the mention of comonad
13:52:26 <ddarius> bscarlet: Monads and comonads are 2-categorical ideas.  You can define the op category by swapping 1-cells, and the co category by swapping 2-cells.  Comonads are monads in the co-category of Cat.  Note, that most "co" things are in the op category not the co category.
13:52:52 <ddarius> The 1-cell in the definition of (co)monads is the functor and it is not getting swapped, not that if it was it'd make much of a difference.
13:53:21 <mm_freak_> i think jules2 is asking for the practical side of comonads
13:53:36 <edwardk> flapjackery: you install the 'ad' package then just say 'diff (\x -> sin x * x)' and it does the right thing
13:53:37 <ddarius> djahandarie: (->) isn't an endofunctor and (co)monads are themselves endofunctors (plus some natural transformations.)
13:53:40 <companion_cube> i guess it's doing co-IO
13:53:46 <mm_freak_> i.e. why one would flip the arrows anyway in haskell =)
13:53:49 <ddarius> mm_freak_: He is.  bscarlet wasn't.
13:53:50 <edwardk> co-IO is impossible
13:54:29 <edwardk> as i've shown recently this would induce an IO monad transformer, which we all know to be bad
13:54:42 <companion_cube> wow
13:54:42 <mm_freak_> ddarius: that was addressed to edwardk
13:54:45 <benmachine> I don't think you get a monad and flip the arrows and go "is this a thing?"
13:54:55 <companion_cube> IOT IO
13:54:56 <jules2> for example one thing i wondered about is this: you have the reader monad, but it seems to me that it is much more naturally a comonad. OTOH the writer monad seems naturally suited to monads, but can you squeeze it into a comonad too?
13:55:01 <benmachine> I think you come up with problems and go "oh hey, the solution to this is kind of like a monad but with the arrows the other way around"
13:55:09 <danharaj> Can someone explain to me the function (\f b -> let (c,d) = f (b, d) in c) ? Maybe an example or two?
13:55:10 <djahandarie> ddarius, I know (co)monads are endofunctors. I meant to say that we're limited to endofunctors involving the category (->)
13:55:16 <edwardk> benmachine: well you need to be careful, because the haskell monad definition is flipped around a bit to be proper
13:55:20 <benmachine> edwardk: sure
13:55:22 <ddarius> benmachine: You don't do the former because you know that it -is- a thing.
13:55:31 <djahandarie> ddarius, I just meant to say comonads and monads could be generalized to endofunctors on other categories
13:55:31 <benmachine> ddarius: I meant an interesting thing :P
13:55:39 <benmachine> ddarius: I mean, I don't just go around flipping arrows and hoping
13:55:45 <mm_freak_> jules2: the reader comonad does not have the same purpose as the reader monad
13:55:58 <djahandarie> And Functor itself could be generalized to other endofunctors, or just to proper functors if we're generalizing
13:56:05 <jules2> mm_freak_, what is the difference in purpose?
13:56:19 <edwardk> mm_freak: though it provides ultimately the same api
13:56:37 <edwardk> jules2: are you familiar with transformers and the mtl?
13:56:37 <ddarius> benmachine: Usually there is value to exploring whether the concept can be realized in your original category and what things it does lead to.
13:56:52 <benmachine> ddarius: ok, fair enough
13:57:10 <ddarius> benmachine: I'm pretty sure F-coalgebras were more or less developed.
13:57:33 <edwardk> jules2: if so then you may find http://hackage.haskell.org/package/comonad-transformers and http://hackage.haskell.org/package/comonads-fd enlightening to read through while comparing each to their monad counterparts
13:57:39 <jules2> edwardk, I am somewhat familiar with the concept of a transformer, but not with the implementation in mtl
13:58:08 <edwardk> in particular lining up the entries in comonad-transformers with those in transformers is a useful exercise in understanding how they are related
13:58:23 <djahandarie> There is a concept of transformer outside of the mtl and friends? They vaguely correspond to monad morphisms but I've never really seen them properly laid out in CT terms
13:59:23 <edwardk> djahandarie: they are basically some structure induced by a distributive law, or by wrapping a monad in an adjunction. each one does admit a lifting of monad homomorphisms but its not actually captured anywhere
13:59:26 <mm_freak_> well, comonads have an entirely different data dependency concept…  the type signature of 'extend' makes that clear
13:59:33 <mm_freak_> i'm not even sure i fully understand it
14:00:15 <mm_freak_> as well i simply may be better homed in the world rather than the coworld =)
14:00:24 <edwardk> i keep meaning to put a package with a class MonadTrans t where hoist :: (Monad m, Monad n) => (forall a. m a -> n a) -> t m a -> t n a; lift :: …
14:00:37 <benmachine> hoist is a good name
14:00:57 <jules2> does the Store comonad transformer correspond to the State monad transformer?
14:01:30 <edwardk> mm_freak: anyways reader and env (coreader) serve the same purpose, when you look at the kleisli and cokleisli arrows.       reader gives you a -> e -> r,  while env gives you Env e a -> r, which is isomorphic to a -> e -> r through currying and uncurrying
14:01:37 <edwardk> jules2: yeah
14:02:59 <edwardk> benmachine: i have the weaker dual version in comonad-transformers http://hackage.haskell.org/packages/archive/comonad-transformers/2.0.0/doc/html/Control-Comonad-Hoist-Class.html
14:03:08 <mm_freak_> edwardk: yes, but how do you compose coreader computations?
14:03:11 <edwardk> but i never packaged up the hoisting machinery anywhere
14:03:27 <mm_freak_> you have this weird (w a -> b) in the type signature of 'extend'
14:03:40 <edwardk> its only weird because you've been staring at monads so long ;)
14:03:48 <mm_freak_> probably =)
14:03:54 <mm_freak_> and also probably because there is no codo
14:04:00 <jules2> I'd say the monad way is way weirder, the reader is naturally suited to comonads
14:04:21 <mm_freak_> i'm not sure about that, though i use reader mostly in an applicative style
14:04:24 <edwardk> @djinn ((e, a) -> b) -> (e,a) -> e, b)
14:04:29 <edwardk> @djinn ((e, a) -> b) -> (e,a) -> (e, b)
14:04:40 <jules2> all the "functions" you write are of type w a -> a, so it is naturally that you put the value that you can read in w a
14:05:30 <jules2> say that you were writing a program that needs a value by hand without monads or comonads, how would you do it?
14:05:35 <mm_freak_> edwardk: oh, looking at it that way actually makes sense
14:05:36 <ddarius> You can calculate the comonad operations from the monad operations across the adjunction.
14:06:07 <jules2> ddarius, that seems very interesting, so there is a bijection between monads and comonads?
14:06:20 <benmachine> mm_freak_: an interesting example is cellular automata
14:06:21 <ddarius> jules2: Since this is Haskell you'd probably use a curried style so that would actually correspond to the reader monad.
14:06:33 <mm_freak_> jules2: i think that's the "flip arrows" operation
14:06:36 <benmachine> mm_freak_: you can work out the state of a cell from its surroundings
14:06:43 <benmachine> which is sort of like Surroundings a -> a
14:06:55 <jules2> ddarius, hmm right
14:06:58 <mm_freak_> benmachine: interesting
14:07:01 <edwardk> mm_freak: basically all of the comonads look like that .in a monad you can only look at a tiny piece of the puzzle to build your answer, but your answer can be big. in a comonad you can look at the entire structure (be it a tree, cellular automaton, some extra environment) and you build just one piece.
14:07:11 <benmachine> and then you can go from that to a step function Surroundings a -> Surroundings a
14:07:17 <benmachine> there's a blog post about this somewhere
14:07:32 <edwardk> monads are about substitution. you take a structure of structures and smash them flat.
14:07:34 <benmachine> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
14:07:40 <mm_freak_> perhaps i should just write a real application using comonads
14:07:50 <benmachine> I've never used comonads
14:07:55 <ddarius> jules2: No, the State monad factors into the underlying functor of the Reader monad and the Reader comonad.  You can transport natural transformations across an adjunction (with a flip) so the monad structure on the Reader monad induces a comonad structure on the Reader comonad and vice versa.
14:07:55 <edwardk> comonads are about redecoration. you take one structure, and look at it all sorts of ways, and take all those answers and patch together a new structure.
14:07:55 <benmachine> but I understand they're interesting
14:08:20 <edwardk> but the extend operation in some very fundamental way doesn't change the 'shape'
14:08:29 <dylukes> I _just_ realized the funny pun with the "box" and "decoration" metaphor.
14:08:30 <ddarius> But not every monad/comonad is a left/right adjoint.
14:08:33 <dylukes> Haskell is christmas.
14:08:53 <dylukes> benmachine: that post is neat :)
14:09:01 <dylukes> it doesn't work for finite though
14:09:02 <benmachine> dylukes: sigfpe is awesome
14:09:06 <dylukes> mm yeah
14:09:08 <mm_freak_> edwardk: now the type starts to make sense…  really make sense
14:09:22 <dylukes> I wish I understood how to use a FINITE comonad.
14:09:46 <mm_freak_> i think i may be experiencing the same enlightenment moment like the one i experienced with monads a few years ago
14:10:13 <edwardk> mm_freak: if you think of monads as providing a nice story for sequential computation, a comonad gives you a nice model for lots of parallel steps, because you evaluate a bunch of 'actions' all at the same time, with slightly different contexts.
14:10:30 <edwardk> a good example of a comonad uses an array and an index into it (it is a special case of store)
14:11:05 <danharaj> How about zippers and trees, where you perform a computation at each place in the tree using the zipper focused at that place?
14:11:08 <edwardk> data Image a = Image (Array (Int, Int) a) (Int, Int)
14:11:55 <edwardk> you can 'extract' by reading from the array, and extend, by taking a computation that has a position in the image, and an array, and computes a new value for that one location, but has access to all the values at all the locations in the image
14:12:05 <edwardk> in a monad we'd fake this with some horrible state hack
14:12:23 <edwardk> in the comonad its easy to see we can compute all those individual answers in parallel
14:12:37 <mm_freak_> interesting
14:12:40 <benmachine> dylukes: I know that '(,) a' is a comonad, that's pretty finite
14:12:47 <dylukes> benmachine: wait. what?
14:12:53 <dylukes> What's the implementation for that?
14:12:59 <benmachine> extract (_, a) = a
14:13:06 <benmachine> duplicate (x,a) = (x,(x,a))
14:13:06 <mm_freak_> dylukes: i think that's the reader comonad actually
14:13:10 <benmachine> it is
14:13:22 <dylukes> ._.
14:13:23 <ddarius> It's the cofree comonad over a constant functor.
14:13:34 <dylukes> ...what
14:13:44 <dylukes> you guys are making less sense than ##japanese when no one is speaking english.
14:13:49 <dylukes> I need some edwardk minddump.
14:13:56 <dylukes> EXPLAIN.
14:13:58 <dylukes> EVERYTHING.
14:14:01 <danharaj> So we're making a lot of sense, it's just in japanese? ;)
14:14:02 <dankna> you wouldn't be able to understand it anyway
14:14:02 <dankna> and
14:14:09 <edwardk> it is =). data Cofree f a = a :< f (Cofree f a)  — data Const b a = Const b
14:14:15 <ddarius> danharaj: Japanese people don't make sense.
14:14:22 <dankna> never ask that, you might wind up in livelock trying to parse the response :)
14:14:25 <danharaj> ddarius: that is entirely cultural.
14:14:37 <edwardk> Cofree (Const b) a = a :< Const b (Cofree f a) ~ (a, b)
14:15:01 <dankna> <edwardk> Co-free co-monadic co-ntext.  That should explain everything.  <dylukes> undefined
14:15:19 <mm_freak_> dylukes: actually edwardk just gave a very good explanation for precisely that…  you may want to scroll up =)
14:15:21 <benmachine> danharaj: no-one else makes sense either to be fair
14:15:22 <dylukes> ⟂
14:15:43 <Jafet> ntexts are cool
14:15:52 <benmachine> Jafet: aren't they ol?
14:16:01 <Jafet> mpletely.
14:16:19 <mm_freak_> i coneed some ffee
14:16:37 <benmachine> mm_freak_: so it's like you need some coffee, but the arrow is going the... ew.
14:16:37 <danharaj> you mean ffee coneeds all you?
14:16:42 <mm_freak_> lol
14:17:16 <edwardk> you probably don't want to drink that coffee
14:17:39 <jules2> ddarius: what is an example of a monad that doesn't have a corresponding comonad?
14:17:41 <edwardk> 2 category theorists, one cup
14:17:48 <dankna> gah
14:17:49 <edwardk> jules2: IO
14:17:55 <dylukes> benmachine: coquaffing ffee is simple.
14:18:01 <dylukes> It just goes in the opposite direction.
14:18:08 <jules2> edwardk, right, but IO is rather special, is there a normal monad?
14:18:18 <ddarius> Damn lambdabot.
14:18:34 <ddarius> jules2: Most of them.
14:18:51 <jules2> for example the maybe monad?
14:18:53 <ddarius> At least in the sense that the Reader monad and Reader comonad are related.
14:19:02 <mm_freak_> jules2: the list monad
14:19:12 <mm_freak_> remember that a comonad needs an 'extract' operation
14:19:17 <edwardk> jules2: technically all monads have a 'corresponding comonad' but that comonad may not be in the category you want it to be
14:19:35 <jules2> in which category could it be in that you don't want?
14:19:42 <benmachine> stream is both a monad and a comonad, is that interesting?
14:20:09 <mm_freak_> stream is a lot of monads
14:20:15 <mm_freak_> list, iteratee, state, …
14:20:23 <benmachine> :o
14:20:25 <ddarius> edwardk: The usual reference to that is: 2 natural transformations, one functor
14:20:50 <benmachine> I guess there's a fair few function Stream (Stream a) -> Stream a
14:20:59 <edwardk> jules2: well, for instance, Cont r is a monad given rise to by an adjunction from (_ -> r) -| (_ -> r) which goes through Hask^op, so the comonad it gives is a monad on Hask^op, which is a monad on Hask, which is the same as Cont r
14:21:18 <mm_freak_> benmachine: the three examples i mentioned have that operation
14:21:28 <mm_freak_> its meaning may be arbitrary though
14:21:34 <benmachine> mm_freak_: you can't concatMap infinite lists
14:21:36 <benmachine> not very usefully anyway
14:21:50 <benmachine> you can take the diagonal, or you can do the LogicT thing I guess
14:22:09 <mm_freak_> you can meaningfully concatMap an infinite list of lists
14:22:12 <azaq23> @bot
14:22:18 <jules2> edward, and you can't write that comonad in Haskell?
14:22:50 <edwardk> benmachine: what you want is a notion of compatibility, that return and bind preserves the comonad structure and that extract and extend preserve the monad structure, this is the same kind of thing we build in algebra with bialgebras
14:22:51 <benmachine> mm_freak_: how so?
14:23:11 <edwardk> jules2: you can, its just a 'Monad' with a capital m, despite being a comonad in another category
14:23:18 * benmachine doesn't know much about algebras
14:23:18 <mm_freak_> > concatMap (\x -> [x+1, x-1]) [10, 20 ..]
14:23:34 <singpolyma> Are there tools to cross-compile haskell for windows?  or do I need a windows system to do it?
14:23:36 <mm_freak_> the map produces an infinite list of lists
14:23:42 <mm_freak_> the concat flattens it
14:23:45 <benmachine> mm_freak_: but if your function produces an infinite list
14:23:47 <edwardk> jules2: IO, ST s , STM are all examples of monads without comonadic analogues, Maybe, List, Either, as well
14:24:03 <ddarius> benmachine: xs ++ ys = xs when xs is infinite, so concat (xs:xss) = xs ++ xss = xs  So concatMapping is just head.
14:24:07 <ddarius> + map
14:24:10 <benmachine> ddarius: right
14:24:14 <mm_freak_> benmachine: that's not the concatMap of an infinite list…  it's concat of a list of infinite lists
14:24:37 <benmachine> mm_freak_: yeah, I meant you can't use the list monad implementation on an infinite list type
14:24:42 <mm_freak_> if your mapping function produces infinitely many items at some point, all later lists are of course disregarded
14:24:55 <edwardk> jules2: now, there is a 'comonad' associated with each of those monads because there is an adjunction that heads off to the kleisli category, and you can compose that adjunction the other way getting you a comonad, but its not in a category you want to work with here =)
14:25:01 <benmachine> because your join is then concatting infinite lists, so as ddarius says it's head
14:25:29 <ddarius> mm_freak_: The Stream monad is only infinite lists.
14:26:07 <benmachine> data Stream a = a :> Stream a
14:26:08 <benmachine> or whatever
14:26:16 <mm_freak_> sure, but your monad doesn't have to be the stream itself
14:26:36 <mm_freak_> State can also be abused to model infinite streams
14:26:38 <edwardk> lots of stream monads: http://hackage.haskell.org/package/streams-0.6.1.1
14:27:27 <parcs> singpolyma: yes, wine
14:27:29 <edwardk> er i suppose i should point to http://hackage.haskell.org/package/streams-0.8.0.4 instead being more recent
14:27:32 <jules2> for monads you can do something like CPS transform to use monads in direct style (alternatively you can use delimited continuations to do this). is there something similar for comonads?
14:27:37 <Polarina> Has anyone taken a look at NetWire? :)
14:27:39 <singpolyma> parcs: hah!  ok :)
14:27:45 <edwardk> jules2: a wonderful question =)
14:27:47 <ddarius> edwardk: You have a bookmark to an old version?
14:27:58 <edwardk> ddarius: nah google hits the old one
14:28:02 <ddarius> edwardk: Also if you just say .../package/streams it should be the latest.
14:28:28 <benmachine> the synopsis for latest seems to be formatted incorrectly
14:28:30 <edwardk> jules2: you can rewrite all the monad transformers (and IO, and ST s, and STM, etc) into the form of a right kan extension
14:28:35 * ddarius doesn't understand how you CPS something into direct style.
14:28:45 <edwardk> jules2: you can similarly rewite all the comonad transformers into the form of a left kan extension
14:28:59 <edwardk> however, the former can improve your asymptotics, while the latter, alas, does not
14:29:16 <edwardk> it has to do with the fact that monads 'grow' while comonads stay the same shape forever
14:29:26 <edwardk> substitution vs. redecoration
14:29:55 <edwardk> jules2: i have a scary-looking package monad-ran that cps transformers any monad transformer
14:30:31 <edwardk> jules2: but there is no point in the comonadic analogue, the hand-wavy reason is that the ability to 'capture an environment' kind of does everything that comonad-lan would do for you already
14:30:35 <jules2> ddarius, I mean like if you have the following code: h x = f (g x), you can define an operation ' which converts a functino to monadic style, for example: h' x = do tmp1 <- g x; tmp2 <- h tmp1; return tmp2
14:30:37 <zong_sharo> is there any up to date tutorials (or any introduction whatsoever) on atom?
14:32:08 <ddarius> jules2: Okay, I guess what you meant to say is that you can transform direct style into monadic style and that that transformation is similar to CPS transforming.
14:32:11 <NihilistDandy> @tell edwardk I'll be around later and I'd like to talk to you about your semigroups lib (at least sort of), if you think you'll have the time.
14:32:17 <jules2> ddarius, right
14:32:20 <edwardk> NihilistDandy: sure
14:32:22 <NihilistDandy> Damn lambdabot outage
14:32:34 <NihilistDandy> edwardk: Oh, cool. All right, I'll be back later. Thanks much.
14:32:47 <mm_freak_> edwardk: that whole comonad thing gives me an interesting idea
14:32:50 <dylukes> I have a suggestion.
14:32:50 <jules2> ddarius, I think that transform with the identity monad is the same as cps transforming
14:32:54 <dylukes> We should write lambdabot in Erlang.
14:33:10 * dylukes has just suggested blasphemy, huh.
14:33:17 <ezyang> No, we should write lambdabot in Cloud Haskell!
14:33:27 <dylukes> Is that a real thing?
14:33:29 <edwardk> jules2: nah, though there is a monad that does that, we call it Cont ;)
14:33:31 <ddarius> jules2: No it isn't. (Or at least isn't with the normal CPS.)  Transforming with the continuation monad would be the same as CPS transforming.
14:33:54 <ddarius> In particular, CbV CPS transforming.  There is more than one way to translate direct style to monadic or continuation-passing style.
14:33:55 <mm_freak_> edwardk: but before i try…  how would you combine comonads with IO?  would you even do that at all or just pass the comonadic values around as arguments?
14:34:06 <ddarius> dylukes: Yes.
14:34:36 <edwardk> mm_freak_:  good question. like most good questions the answer isn't very satisfying. ;)
14:34:44 <mm_freak_> hehe
14:35:05 <edwardk> mm_freak_: this is part of the motivation behind the separate 'Extend' class in the comonad package
14:35:36 <edwardk> because a lot of the comonads you'll want to use won't be comonads with a capital C, they'll be comonads over a kleisli category for some monad (like IO)
14:35:43 <edwardk> and extend can usually work for those
14:35:44 <ddarius> You could have the comonad be built over the IO Kleisli category.
14:35:57 <edwardk> exactly
14:35:59 <jules2> edwardk, ddarius: oh, right
14:36:21 <edwardk> this is what i tend to advocate. the distributive law versions that uustalu and vene, and sigfpe all posted suck for actual real work
14:36:37 <edwardk> but building the comonad over a kleisli category works great
14:37:08 <mm_freak_> hmm
14:37:15 <edwardk> you get an extend' :: (w a -> IO b) -> w a -> IO (w b); extract' :: w a -> IO a , etc.
14:37:24 <mm_freak_> my lack of CT background bites me when talking to you =)
14:37:42 <mm_freak_> oh, i see
14:37:48 <mm_freak_> makes sense
14:37:50 <edwardk> 'building over the kleisli category' just means putting the monad on the result of the arrows you're transforming
14:38:02 <edwardk> a -> m b is an arrow in the kleisli category for m
14:38:21 <mm_freak_> is there a library supporting that kind of combination?
14:38:29 <edwardk> not at present
14:38:35 <edwardk> it is ugly enough that i haven't packaged it
14:38:38 <ddarius> newtype Kleisli m a b = Kleisli (a -> m b);  instance Monad m => Category (Kleisli m) where ...
14:38:51 <edwardk> my reactor package uses it for observables
14:38:57 <mm_freak_> hmm
14:39:25 <mm_freak_> a lot of what i would do with comonads would require an impure extend function
14:39:50 <edwardk> which form a comonad over Kleisli Task
14:39:51 <edwardk> sure. part of what i do is work around that by clever use of representability
14:39:59 <jules2> am i right in thinking that f x ====> f >>= \f'. x >>= \x'. f' x' would be the CBV transform, and f x =====> f >>= \f'. f' x would be the CBN transform?
14:40:02 <ddarius> edwardk: It should be trivial to make a ComonadOverAKleisliCategory class.  Is that what Extend is?
14:40:24 <edwardk> ddarius: almost. Extend is 'cokleisli composition forms a semigroupoid'
14:40:45 <edwardk> ddarius: it tuns out that 'comonad over a kleisli category' usually also admits a definition of Extend
14:40:47 <ddarius> jules2: Yes.
14:41:08 <mm_freak_> edwardk: i'm asking because right now i'm using a mutable array in my netwire library, and it makes the impression that a combination of Store and IO would improve that a lot
14:41:16 <mm_freak_> the internal code is highly imperative
14:41:20 <ddarius> jules2: In particular, note that the types transform differently in CbV v. CbN.
14:41:26 <danharaj> Someone needs to write a handbook of categorical structures in Haskell, complete with lots of examples.
14:41:45 <edwardk> mm_freak: i usually use the comonads for things like lenses, to manipulate state actions.
14:41:52 <edwardk> i don't usually plumb it in as part of my monad
14:41:56 <jules2> ddarius, yeah, so there should be something different in the transformation elsewhere
14:42:04 <ddarius> E.g. in f x, f :: A -> B, x :: A and became f :: A -> M B, x :: M A with CbV and f :: M A -> M B, x :: M A for CbN.
14:42:10 <mm_freak_> yes, but the idea of an array+index is exactly what i need
14:42:11 <edwardk> though i did design a nicer Lensed monad for the snap framework guys at hac phi this year
14:42:22 <mm_freak_> but i need an impure variant of that with O(1) update
14:42:24 <jules2> i think that in the CBV transform a variable becomes return variable, but in CBN it just stays variable
14:42:36 <mm_freak_> at each time instant i update only a single element of that array, disregarding all others
14:42:39 <edwardk> the problem is that O(1) update prevents the use of the extend operation
14:42:47 <edwardk> because you need ALL of the actions to see all the old values
14:42:53 <edwardk> and you build a new array with a whole different type
14:43:06 <edwardk> (w a -> _b_ )
14:43:21 <mm_freak_> yes, hence a pure comonad wouldn't help here
14:43:32 <edwardk> if you're updating a single element, you probably still have a monad =)
14:43:46 <mm_freak_> i see
14:43:47 <edwardk> if you want though
14:43:52 <edwardk> you CAN use a comonad to transform a monad
14:44:00 <edwardk> i blogged that recently
14:44:18 <danharaj> working through comonads to monad transformers examples was fun
14:44:38 <edwardk> starting from a trick of ddarius' i shrink-wrapped it to get rid of the extra argument
14:44:59 <edwardk> http://hackage.haskell.org/packages/archive/kan-extensions/2.0.0.3/doc/html/Control-Monad-Co.html
14:45:07 <edwardk> CoT is a comonad-to-monad transformer
14:45:49 <edwardk> so you could just bolt the image comonad i mentioned above, which is a tabulated form of Store comonad in there and let it rip
14:45:56 <edwardk> but you just made an array based state monad
14:45:57 <ddarius> Do we have the isomorphism witnessing the full faithfulness of the Yoneda embedding somewhere?
14:46:25 <mm_freak_> edwardk: could you give me the link do your article?
14:46:42 <edwardk> i have the liftYoneda lowerYoneda pair in http://hackage.haskell.org/packages/archive/kan-extensions/2.0.0.3/doc/html/Data-Functor-Yoneda.html
14:46:58 <mm_freak_> s/do/to/
14:47:07 <edwardk> http://comonad.com/reader/2011/monads-from-comonads/ is the first of 3
14:47:21 <ddarius> Yeah, I guess those work by setting f to be (r ->)
14:47:23 <edwardk> though the four posts before that are also enlightening and set the tone for it
14:47:26 <adu> wow what is a comonad?
14:47:32 <jules2> hmm, so the full transforms are: CBV: e1 e2 ===> e1 >>= \f. e2 >>= \x. f x, variables x ===> return x, lambdas \x. e ===> return (\x. e). And CBN: e1 e2 ===> e1 >>= \f. f e2, variables x ===> x, lambdas \x. e ===> return (\x. e)?
14:47:58 <edwardk> adu http://hackage.haskell.org/packages/archive/comonad/1.1.1/doc/html/Control-Comonad.html
14:49:46 <ddarius> jules2: Do an example and make sure it type checks and makes sense.
14:52:05 <adu> edwardk: I don't see how those comonads are dual to monads
14:52:47 <edwardk> adu: follow the first few slides in http://comonad.com/haskell/Comonads_1.pdf
14:52:59 <edwardk> it goes through flipping the arrows more carefully
14:54:28 <adu> edwardk: at first glance they look closer to comonoids
14:54:44 <edwardk> well, a monad is a monoid
14:54:53 <edwardk> so your intuition is pretty good
14:56:34 <adu> wow cofunctor == functor!
14:56:38 * hackagebot jonathanscard 0.1 - An implementation of the Jonathan's Card API.  http://hackage.haskell.org/package/jonathanscard-0.1 (MichaelSchade)
14:58:52 <jules2> ddarius, it type checks, and i think that even if you replace all monadic operations with comonadic ones, it still type checks
15:01:01 <zzo38> Trying to use lambdaTeX results in:  ! Font \hs@keyface=phvb at 10.0pt not loadable
15:01:04 <zzo38> What is this font?
15:01:29 <zzo38> I want to use DVI not PDF or PostScript
15:01:38 * hackagebot SMTPClient 1.0.4 - A simple SMTP client library  http://hackage.haskell.org/package/SMTPClient-1.0.4 (StephenBlackheath)
15:02:16 <adu> edwardk: so ... extend is dual to (flip (>>=))
15:02:18 <zzo38> And I use Plain TeX not LaTeX
15:02:28 <edwardk> adu: yes
15:03:01 <adu> and duplicate is dual to join
15:03:19 <edwardk> (=<<)  takes an arrow (a -> m b) to   (m a -> m b)        flipping each gives (w b -> a)    to (w b -> w a)
15:03:21 <edwardk> yep
15:03:34 <adu> ok i see now
15:03:45 <adu> I always liked the join definition of monads anyways :)
15:04:44 <adu> but I thought you needed return and join to define a monad, are join and bind enough?
15:04:53 <edwardk> adu: you may find the http://hackage.haskell.org/package/comonad-transformers package a nice place to continue, especially if you are familiar with http://hackage.haskell.org/package/transformers
15:05:06 <adu> I am not
15:05:09 <jules2> you need return, map, and join i think
15:05:11 <adu> transformers scare me
15:05:16 <ddarius> adu: You need return, fmap, and join, or return and (>>=).
15:05:27 <edwardk> you need return and (>>=)   or you need return fmap and join
15:05:50 <adu> ok, i see
15:05:57 <edwardk> the comonadic case is similar, you need extract and extend or you need extract, fmap and duplicate
15:06:31 <edwardk> (>>=) is basically a join and an fmap smushed together
15:06:53 <edwardk> @type (>>= id)
15:06:57 <adu> I love (>>=)
15:07:04 <edwardk> gah, lambdabot dead
15:07:13 <adu> :type (>>= id)
15:07:44 <mm_freak_> edwardk: i think, i've actually read that
15:08:18 <edwardk> (>>=) :: m a -> (a -> m b) -> m b, applied to id as the second argument forces a = m b, so you get m (m b) -> m b
15:08:46 <edwardk> and return and (>>=) are enough to build fmap
15:08:54 <edwardk> see liftM
15:09:24 <danharaj_> !!!
15:09:29 <danharaj_> There's a TupleSections extension?
15:09:38 <benmachine> since 6.12, yeah
15:09:41 <edwardk> to go the other way you need to see that ma >>= f = join (fmap f ma)
15:09:42 <danharaj> That is beautiful.
15:09:45 <edwardk> danharaj: yep
15:09:59 <danharaj> oh god this makes me so happy :[
15:10:03 <danharaj> perhaps irrationally so
15:11:29 <adu> edwardk: I also love liftM
15:11:48 <shachaf> liftM is just fmap
15:13:46 * ddarius loves liftM0
15:14:41 <chrisdone> liftM + ap is nice
15:14:41 <shachaf> Said ddarius pointedly.
15:18:26 <shachaf> (>=>) is just as good as (>>=) or join/fmap, isn't it?
15:19:00 <roconnor> @hoogle liftM0
15:19:21 <shachaf> Control.Monad.return :: (Monad m) => a -> m a
15:19:23 <Kaidelong> shachaf: I'm having trouble imagining why it wouldn't be
15:19:28 <Kaidelong> @src (>=>)
15:19:39 <Kaidelong> @botsnack
15:19:53 <shachaf> lambdabot is dead no matter how many times you use @ commands.
15:20:07 <Kaidelong> yeah someone needs to give her some smelling salts
15:20:18 <shachaf> Cale?
15:20:35 <chrisdone> @faq Can Haskell wait in the depths of the oceans along with the other Deep Ones?
15:20:56 <chrisdone> I'll take that as a Cthulhu R'lyeh wgah'nagl fhtagn
15:21:04 <tech2> chrisdone: I guess the elder one awakes.
15:21:08 <Kaidelong> but anyway
15:21:18 <Kaidelong> I'm sure >=> is just implemented in terms of >>= anyway
15:21:27 <Kaidelong> so I can't imagine it being somehow less efficient
15:21:38 <chrisdone> how else would you implement it?
15:21:48 <Kaidelong> exactly
15:22:17 <ddarius> (f >=> g) x = f x >>= g
15:22:21 <shachaf> Kaidelong: Efficient?
15:22:33 <shachaf> I meant that you could implement (>>=) in terms of (>=>).
15:22:38 <Kaidelong> oh
15:22:47 <Kaidelong> yes, you can
15:22:49 <chrisdone> :t (>=>) . const
15:23:12 <Kaidelong> lambdabot is down, remember
15:23:22 <chrisdone> it's a reflex
15:23:28 <chrisdone> not a conscious action
15:23:29 <shachaf> (\x y -> (const x >=> y) ()) -- ?
15:23:53 <gaxar77> Hey everyone. I was just learning Haskell and I have a question. From what I understand, everything is done through recursion. Wouldn't that cause a stack over flow eventually for certain things, and also, can anything be computed functionally that can be computed imperatively?
15:23:55 <JuanDaugherty> is it me or is it down more than it used to be?
15:24:03 <gaxar77> I'm used to languages like C++, C#, Java, Ruby, etc.
15:24:31 <ddarius> gaxar77: All those languages are broken.
15:24:32 <shachaf> Ooh, ddarius is in for a treat.
15:24:37 <Kaidelong> gaxar77: In C recursion means you build a stack. But recursion doesn't neccessarily mean that. "while" loops are a special case of recursion, and there they do not build a stack
15:24:47 <JuanDaugherty> gaxar, the answer is yes
15:24:58 <cheater__> gaxar77, our recursion is implemented in a cooler way.
15:25:20 <gaxar77> So, our recursion gets translated into something that doesn't cause a stack overflow then?
15:25:31 <cheater__> i dunno. what's a stack?
15:25:40 <jules2> it seems that laziness is a comonad as well with x =>> f = delay (f x) and extract x = force x
15:25:41 <JuanDaugherty> but if all you know is those prosaic algol like langs, haskell may be a rude shock
15:25:41 <Kaidelong> if it is one of those special cases gaxar77, yes
15:26:16 <Kaidelong> lazy evaluation also means there are some more special cases than you find in a language like OCaml
15:26:20 <cheater__> gaxar77, also, to answer the other part:
15:26:27 <chrisdone> stack overflows in haskell are possible, but the general case is different to those languages
15:26:36 <cheater__> @faq can Haskell compute anything that can be done imperatively?
15:26:43 <gaxar77> If I had a gigantic tree structure with numerous levels of children, and I want to process them all in Haskell using recursion, wouldn't that cause problems?
15:26:45 <jmcarthur> NO!
15:26:57 <danharaj> CAPS?
15:26:58 <Kaidelong> anyway you can write imperative code in haskell if you want to
15:27:03 <cheater__> the bot should now pop up and say "Yes, Haskell can do that!"
15:27:05 <jmcarthur> err, i was answering cheater__'s LB query since LB isn't here
15:27:06 <cheater__> but the bot is gone :(
15:27:12 <Kaidelong> a lot of people say Haskell is their favorite imperative language
15:27:21 <danharaj> jmcarthur: big shoes to fill :)
15:27:35 <cheater__> gaxar77, a tree structure wouldn't cause problems.
15:27:43 <jmcarthur> danharaj: i'm slower, so i just timeout most of the time
15:28:16 <gaxar77> Even if the tree structure has so many levels of children that a function calling itself that many times would cause a stack overflow in other languages?
15:28:22 <danharaj> yes.
15:28:23 <cheater__> gaxar77, yes
15:28:23 <ddarius> gaxar77: If you had a very deep tree, then you could cause a stack overflow, but there is no way to avoid this other than to move the stack frames to the heap which just renames the problem.
15:28:24 <jmcarthur> gaxar77: that doesn't inherently cause problems, but there are surely specific cases where there might be problems
15:28:25 <identifai> Kaidelong: haha
15:28:32 <ddarius> gaxar77: This has nothing to do with Haskell.
15:28:35 <Kaidelong> gaxar77: yeah, a tree traversal will build a stack, but ideally it would be tiny compared to the number of elements in the tree
15:28:47 <Kaidelong> that also would be the case in a language like C
15:28:50 <jmcarthur> not all tree traversals do unless you also need backtracking
15:28:54 <ddarius> (Well, I guess technically in some language you could do pointer reversal to avoid this case which you couldn't do in Haskell.)
15:28:54 <Kaidelong> if you have some other means for a traversal
15:29:01 <Kaidelong> then you could just encode that into Haskell
15:29:03 <cheater__> gaxar77, to put it differently: haskell does have its problems where it runs out of space, but they're defined in terms you probably couldn't define right now :)
15:29:06 <jmcarthur> ddarius: you can't just use a zipper?
15:29:09 <jmcarthur> err
15:29:21 <jmcarthur> i mean to suggest that that may be the closest haskell equivalent
15:29:43 <identifai> well, can a tail-recursive function cause a stack-overflow at all?
15:29:50 <loupgaroublond> heh, i was about to suggest, a zipper would redefine the problem really nicely
15:29:52 <tech2> does runhaskell actually build an executable, or is it still interpreted/pseudocompiled?
15:29:57 <gaxar77> So if there are no pointers in Haskell. How do would I have a tree node refer to its parent node then?
15:29:58 <jmcarthur> identifai: depends on what notion of tail recursive you are talking about
15:29:59 <ddarius> jmcarthur: Well you could encode the tree into an IntMap, say, and do the "pointer" reversal directly, but that would be a bit insane.
15:30:03 <jmcarthur> identifai: laziness changes things a bit
15:30:10 <Kaidelong> identifai: AFAIK it can't overflow the call stack. You could still run out of memory in other ways
15:30:29 <identifai> jmcarthur: well, you cannot use tail-recursive functions for lazy lists, AFAIK, dont you?
15:30:30 <Kaidelong> most infamously, foldl overflowing in its accumulator because it isn't strict
15:30:34 <ddarius> That said, almost no one does these kind of pointer reversal tricks and usually you want balanced trees so it is impossible for them to be too deep.
15:30:36 <identifai> s/dont/do/
15:30:51 <ddarius> gaxar77: There are no pointers in Java, Ruby, or C#.
15:31:09 <gaxar77> Yes, but in all those languages there are reference-types.
15:31:11 <identifai> Kaidelong: strict?
15:31:16 <jmcarthur> identifai: foldl is tail recursive but easily leads to stack overflows
15:31:18 <gaxar77> And those are just as good as pointer for certain purposes.
15:31:22 <Kaidelong> ddarius: well if you have exponentially more space to store the tree than the call stack even a balanced tree wouldn't save you
15:31:24 <identifai> jmcarthur: why?
15:31:43 <gaxar77> Well, ruby doesn't have reference types; In ruby everything is just an object.
15:31:44 <identifai> jmcarthur: i need arguments, otherwise i dont trust you :P
15:31:54 <jmcarthur> identifai: say you are using it to sum the elements of a list. if addition is strict (for most types it is) you build up a chain of thunks and eventually overflow
15:32:04 <jmcarthur> identifai: foldl (+) 0 longList
15:32:06 <ddarius> Kaidelong: And if you have so much memory in a single location, even the laws of physics won't be able to save you from the blackhole.
15:32:28 <jmcarthur> identifai: optimizations can fix some cases (i think including that specific one), but in general this can cause stack overflows
15:32:31 <gaxar77> In Java, Ruby and C# I can refer in one structure to another structure by reference. Can I do this in Haskell?
15:32:46 <ddarius> gaxar77: There are reference types in Haskell.  I think what you are asking is: how do I make the parent node which depends on the children if the children depend on the parent node without mutation?
15:32:48 <Kaidelong> hmm, I suppose it is impractical to overflow the stack traversing a balanced binary tree
15:32:59 <jmcarthur> actually addition being strict isn't not important to that i think
15:33:02 <gaxar77> Yes. I think that's what I'm asking.
15:33:04 <identifai> jmcarthur: are you sure about not talking about foldR ?
15:33:14 <jmcarthur> identifai: foldr is not tail recursive
15:33:24 <jmcarthur> identifai: and it has *good* behavior for lazy operations
15:33:27 <identifai> yep.
15:33:30 <ddarius> gaxar77: So there lazy evaluation helps.  You can just directly declare a mutually recursive set of definitions.
15:33:35 <identifai> jmcarthur: i know that
15:33:37 <jmcarthur> identifai: foldl' has good behavior for strict operations
15:33:39 <ddarius> If the 'bot was here, I'd demonstrate.
15:33:42 <jmcarthur> identifai: but foldl does not
15:33:48 <identifai> jmcarthur: i know
15:34:02 <jmcarthur> and this is why
15:34:10 <identifai> jmcarthur: but tail-recursive functions use CONSTANT memory!
15:34:17 <jmcarthur> in strict languages, true
15:34:21 <identifai> so, a overflow is impossible, AFAIK
15:34:42 <jmcarthur> tail recursion in strict languages is different from tail recursion in lazy languages
15:34:47 <Kaidelong> jmcarthur: if a strict language builds a parameter the same way, say, through continuation passing, you still end up with something that isn't constant space, though
15:34:49 <monochrom> screw "tail recursion". foldl (+) 0 [x,x,x] gives you (after several steps) the thunk ((x+x)+x)+0, and only then does the addition begin. to do those additions in that deep thunk, stack space is used.
15:35:01 <identifai> jmcarthur: oh, you mean, tail-recursive functions cause a (stack) voerflow when you use it for lazy stuff, i see; all right, yes.
15:35:14 <Kaidelong> so in a sense it isn't any different
15:35:14 <ddarius> gaxar77: For example, you'd have something like: root = Branch root child1 child2; child1 = Branch root (Leaf 1) (Leaf 2); child2 = Branch root (Leaf 3) (Leaf 4)
15:35:28 <jmcarthur> Kaidelong: they all compile to assembler ;)
15:35:53 <ddarius> identifai: That's not the case.
15:35:59 <Kaidelong> actually wouldn't you be able to translate those perverse cases into a strict language using continuation passing?
15:36:07 <jmcarthur> yes
15:36:07 <identifai> ddarius: it is! ?
15:36:52 <gaxar77> But, doesn't using root as a parameter create a copy of the structure? or does it somehow share it?
15:36:58 <aristid> @hoogle [Int] -> [a] -> [[a]]
15:37:10 <jmcarthur> gaxar77: ghc won't copy anything unnecessarily
15:37:14 <Kaidelong> identifai: they will not cause a stack overflow so long as they do not build up the size of some parameter
15:37:17 <gaxar77> oh
15:37:19 <ddarius> Kaidelong: CPS transforming disassociates the evaluation order of the expressions from the language's evaluation order.
15:37:25 <danharaj> gaxar77: It doesn't matter if it copies it in the implementation because there's no mutation. However, GHC is efficient at sharing when it can.
15:37:35 <monochrom> identifai, the point is "{lazy, eager} {tail recursion, blah recursion} {uses, does not use} a lot of stack" is false dichotomy. you should look at other aspects
15:37:37 <jmcarthur> gaxar77: if something is bound to an identifier, using that identifier more than once is still the same value in memory
15:38:06 <gaxar77> oh ok.
15:38:20 <Kaidelong> "referential transperency"
15:38:25 <jmcarthur> gaxar77: for example, here's an infinite list (represented in memory as a cyclic list!):   let xs = 1 : xs in xs
15:38:26 <ddarius> gaxar77: All the variables, in practice, are implemented as pointers to whatever.  You are pretty much only ever passing around pointers.
15:38:27 <identifai> monochrom: i dont get your syntax, src :P
15:38:30 <Kaidelong> it has very nice consequences when dealing with trees
15:38:47 <gaxar77> Becuse if I had two structures that referred to each other, copying by value would seem to generate infinite nestings.
15:39:00 <gaxar77> In the structure.
15:39:04 <gaxar77> Not really...
15:39:04 <danharaj> gaxar77: That doesn't happen because of lazy evaluation.
15:39:05 <gaxar77> but sort of.
15:39:09 <gaxar77> Oh ok.
15:39:11 <gaxar77> I get it now.
15:39:25 <monochrom> well "(lazy | eager) (tail recursion | blah recursion) (uses | does not use) a lot of stack" then
15:39:31 <jmcarthur> it's safe not to copy due to purity :)
15:39:37 <identifai> Kaidelong: can you explain it more precisely, please?
15:39:58 <Kaidelong> referential transparency is simply where you can't tell a reference apart from a value
15:40:04 <Kaidelong> which is the case in Haskell
15:40:21 <Kaidelong> unless you explicitly use some kind of a mutable reference
15:40:30 <Peaker> (or ghc-specific magic)
15:40:39 <jmcarthur> black magic
15:41:07 <danharaj> referential transparency is when you can substitute subexpression with its value without changing the value of the whole expression.
15:41:14 <monochrom> @bots
15:41:20 <gaxar77> So how would graphical applications be implemented in Haskell.
15:41:20 <gaxar77> ?
15:41:29 <monochrom> preflex: help
15:41:29 <preflex>  try 'help help' or see 'list' for available commands
15:41:32 <jmcarthur> with the usual libraries from any other language
15:41:34 <monochrom> preflex: list
15:41:34 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
15:41:35 <preflex>  ZCode: [zdec, zenc]
15:41:47 <identifai> guys, you really should mention to whom you talk to!
15:41:47 <danharaj> gaxar77: If you want to experiment with graphics and Haskell, Gloss is a great library.
15:41:49 <ddarius> The definition of "referential transparency" from the original linguistic context is that a reference to something (i.e. a use of it) can be replaced by the referent (i.e. its definition.)  In Haskell that would mean a variable can be replaced by defining expression.
15:42:03 <monochrom> I'm talking to everyone.
15:42:09 <monochrom> everyone: I'm talking to everyone.
15:42:12 <monochrom> (happy?)
15:42:17 <identifai> yep
15:42:20 <danharaj> http://gloss.ouroborus.net/
15:42:24 <identifai> ^^
15:42:28 <ddarius> monochrom: Who were you asking was happy?
15:42:38 <monochrom> no one
15:42:43 <identifai> monochrom: :D
15:43:10 <monochrom> foldr (&&) (False : repeat True)  uses constant memory
15:43:28 <monochrom> err make that foldr1
15:43:30 <identifai> monochrom: oO
15:43:41 <pedro3005> how do I activate -XTypeSynonymInstances in ghci?
15:43:44 <Peaker> > foldr1 (&&) (False : repeat True)
15:43:44 <Peaker_bot>  Terminated
15:43:47 <Peaker> oops
15:43:47 <monochrom> try it, and destroy your false dichotomies
15:44:07 <Peaker> lambdabot should probably depend on hint/etc
15:44:22 <gaxar77> Does it come with the platform or do I have to get it from somewhere?
15:44:27 <helgikrs> pedro3005: :set -XType...
15:44:31 <gaxar77> The thing I'm really interested in actually is Natural Language Processing.
15:44:55 <gaxar77> I came accross an online book teaching it using Haskell, and that's why I decided to learn Haskell.
15:44:55 <pedro3005> helgikrs, weird, it still gives the same error
15:45:11 <danharaj> Gloss does not come with Haskell platform. If you have Haskell platform installed you can type "cabal install gloss" to get it.
15:45:19 <danharaj> I don't know about NLP in Haskell, but I know it exists.
15:45:30 <gaxar77> I had this feeling that it would be much easier to do in Haskell than in any of the other languages.
15:46:12 <Kaidelong> well maybe it will be
15:46:21 <identifai> helgikrs: cool :)
15:46:42 <Kaidelong> I remember I did an exercise in latency compensation for multiplayer games and haskell delivered an elegant solution, at least in theory
15:46:51 <Kaidelong> which was very unexpected for me
15:46:53 <pedro3005> okay, never mind. I have a different problem
15:47:07 <azaq23> pedro3005: You can't declare instances or datatypes or classes in the ghci prompt by default, you only can do anything you would be able to do in a IO do block (which is why you define functions on top level by doing let f ... = ...); I think the features I named are not only not enable by default but not implemented.
15:47:31 <pedro3005> What I wanted to do was define a type synonym of int, but have a different Show instance for that type.. is this possible?
15:47:44 <gaxar77> I made up a simple stupid formal language for expressing thoughts so the compute could more easily deal with them. I wrote a parser, and I was going to implement functionality ro make it do logic with these expressions (like first-order logic and stuff), but once I got up to that part I started to procrastinate for some reason. I don't even feel like it anymore. Maybe it is just intimidating. Anyway I did this in C#.
15:48:21 <Peaker> pedro3005: As a newtype, it definitely is.. As a synonym, I am not sure what the semantics of the TypeSynonymInstance extension are, but it's probably not a good idea
15:48:23 <gaxar77> And I was going to write code that would translate between this formal language and the English language.
15:48:44 <gaxar77> I really didn't know too much about NLP, but I was filled with ideas and was just trying to get somewhere with it.
15:48:51 <azaq23> pedro3005: 1. You can't define a type synonym in ghci 2. No, type does not create a new type but only introduces a new name for a type. Therefore, after compilation there is no difference between the type ... = Int type and Int itself, so no. You'll have to use a newtype
15:49:08 <gaxar77> I've gotten very little done, and I realize NLP is probably going to me a whole lot of work.
15:49:20 <danharaj> NLP is Hard(TM).
15:49:24 <danharaj> (Let's go shopping.)
15:49:27 <gaxar77> be*
15:49:29 <gaxar77> lol
15:49:42 <azaq23> pedro3005: TypeSynonymInstances can be enabled so you're able to state type P t = F a t; instance Monad P where ... instead of using instance Monad (F a) where ..., it's not for anything beyond that
15:49:42 <identifai> can i actually ask questions concerning emacs' haskell-mode in here? the problem is that it doesnt work well for me :/
15:50:07 <azaq23> *for instance, of course
15:50:26 <pedro3005> oh
15:50:53 <pedro3005> so I'm doing something wrong here
15:50:58 <ddarius> azaq23: I don't think TypeSynonymInstances lets you do that.
15:51:00 <pedro3005> newtype Cell = Int will not work
15:51:09 <ddarius> azaq23: It would allow type P = F a and then instance Monad P.
15:51:13 <Saizan> identifai: you can, no guarantee on answers though
15:51:33 <identifai> Saizan: do you use haskell-mode, too?
15:51:38 <Saizan> identifai: yep
15:51:50 <blackdog> morning, fellow knights of the lambda
15:51:51 <gaxar77> So when I pass a function somewhere without parameters it just takes the function right? And when I apply paramters to it it gets evaluated?
15:51:55 <identifai> Saizan: i'm sure you use agda-mode, too, right? ;)
15:52:02 <identifai> heh :)
15:52:09 <gaxar77> I can apply some parameters her, some there, and finally the last one, and it evaluates?
15:52:13 <identifai> Saizan: does it work perfectly for you?
15:52:20 <blackdog> had a quick qn about TH - is there a way to generate code that uses the string representation of tags in a datatype?
15:52:46 <blackdog> been thinking about a cheapie json parser/prettyprinter that actually uses the tags in the data types, rather than needing a translation layer
15:52:59 <danharaj> gaxar77: Evaluation only occurs when the result is needed. Ultimately results are needed because they are demanded by 'main'.
15:53:02 <Saizan> identifai: it works, not sure about perfectly
15:53:12 <identifai> Saizan: for me, the most important things such as "C-c C-l" and "C-c C-t" work fine, but thinks like "C-c C-=" or "C-c C-o" or "C-c C-|" dont work ;(
15:53:23 <danharaj> So even if you fully apply a function to arguments, it's still not evaluated until it's needed.
15:53:28 <ddarius> blackdog: I don't understand your question.
15:53:29 <identifai> Saizan: http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Tips_and_use
15:53:32 <danharaj> If you never need it, then it will never get evaluated.
15:53:43 <gaxar77> oh
15:53:59 <Saizan> identifai: mh, i don't use those other three, let me try
15:54:19 <identifai> Saizan: look at the link..
15:54:30 <identifai> .. if you didnt already
15:54:43 <blackdog> ddarius: say i have "data Foo = Bar String | Baz [Integer]"
15:54:56 <danharaj> gaxar77: This is the same principle that let's you define an infinite structure without having it hang forever. Only the part that you actually use is produced, the rest is suspended.
15:55:13 <blackdog> i'd like to be able to parse "{ 'Baz': [1,2,3] }" to a Foo type directly
15:55:37 <blackdog> (and obviously you'd like to support things like Maybe etc, but that's a refinement)
15:55:40 <danharaj> gaxar77: If you have ghci open, you can try this with `take 10 [1..]`, which takes the first 10 elements of the infinite list [1,2,3,...]
15:55:54 <Saizan> identifai: C-c C-o works, for the others i've a bit of a problem typing them since they involve shift keys and my terminal emulator seems to interpret the combinations instead
15:56:06 <blackdog> i can't do it with normal typeclasses etc, because i can't talk about tag names
15:56:50 <gaxar77> I made a tree structure with support for only two leafs. It's stupid but I have only picked up Haskell yesterday. Are there more elegant ways to express this?:http://pastie.org/2336613
15:57:04 <identifai> Saizan: i see... actaully i use emacs within X (not in the terminal..)
15:57:30 <ddarius> blackdog: See the Data class.
15:57:53 <Polarina> mm_freak_: I love your new library. :)
15:58:00 <blackdog> ddarius: thanks, i'll have a look.
15:58:02 <ddarius> blackdog: Though generating some TH would probably be more efficient.  I'm not sure what's blocking you with using TH.
15:58:19 <ddarius> s/generating some/generating some code with/
15:58:35 <blackdog> ddarius: mostly i don't know how to use it:) if you think it's possible, I'll dive in safe in the assumption that anything blocking me is my own stupidity.
15:59:09 <gaxar77> So, how can anything get done if there is no way to save anything to variables?
15:59:16 <Saizan> identifai: only in an haskell file though, not in agda
15:59:21 <identifai> Saizan: hmm... when i try that keybinding i get "C-c C-o is undefined"
15:59:41 <identifai> Saizan: ??
15:59:41 <gaxar77> If I want to make a structure keeps count of an index, so that I can always get a new index, how would I do that?
15:59:46 <ddarius> blackdog: I think you can ask for types that are defined and inspect their structure at compile-time.  In the absolute worst-case scenario, you can require that the data declarations be put into a declaration quotation and have those passed to your generator.
15:59:49 <azaq23> ddarius: I just tried some variations with newtype Const a b = Const a and a type synonym, and you're correct, apparently, a type synonym still needs to get all arguments so that it can be used with type synonym instances.
16:00:25 <pedro3005> Okay, I am getting confused
16:00:29 <pedro3005> I defined
16:00:34 <pedro3005> data Cell = Cell Int
16:00:40 <pedro3005> now how do I write a Show instance for this?
16:00:40 <identifai> oO
16:00:50 <ddarius> azaq23: Yes, the Report says that you can't use type synonyms at all in instance declarations which is somewhat unreasonable.  The Report also states that you can't use partially applied type synonyms in many cases for a very good reason, though some cases would be fine.
16:01:01 <gaxar77> It has to get saved somewhere doesn't it?
16:01:03 <identifai> is it allowed to name the constructor same as the type itself?
16:01:07 <ddarius> azaq23: Moral of the story, always eta reduce your type synonyms as much as possible.
16:01:25 <ddarius> identifai: Yes.
16:01:31 <Saizan> identifai: i mean that these keybindings don't work in an agda buffer, just to be clear
16:01:33 <identifai> ddarius: okay.. cool.
16:01:37 <pedro3005> let me guess, I'm doing something silly
16:01:41 <ddarius> identifai: There's no chance of confusion.  One's a type, the other is a value.
16:02:14 <identifai> Saizan: well, i was actaully talking about haskell-mode.. >.>
16:02:39 <mm_freak_> Polarina: glad you like it =)
16:02:54 <identifai> pedro3005: data Cell = Cell Int deriving Show
16:03:04 <Saizan> identifai: then that's fine, i wanted to be sure of that :)
16:03:18 <identifai> :) okay
16:03:32 <identifai> pedro3005: oops, i mixed sth up.. okay, now i get your problem.. sry
16:03:35 <pedro3005> identifai, I want to write my own instance
16:03:38 <pedro3005> I did
16:03:52 <pedro3005> instance Show Cell where show = chr
16:03:53 <pedro3005> failed
16:04:11 <identifai> pedro3005: chr?
16:04:16 <pedro3005> from Data.Char
16:04:38 <benmachine> chr doesn't return a string
16:04:49 <Polarina> mm_freak_: Do you know anything of its performance vs. Yampa/Animas? Would be interesting to know.
16:05:03 <Saizan> and it doesn't take a Cell
16:05:21 <identifai> pedro3005: i think this should work: ... where show x = [chr x]
16:05:30 <Saizan> pedro3005: you've to take the Int out of the Cell via pattern matching
16:05:57 <identifai> Saizan: oh, you're right.. oops :]
16:06:04 <pedro3005> show (Cell a) ?
16:06:08 <Saizan> yeah
16:06:18 <mm_freak_> Polarina: i haven't performed a comparison, and i believe it really depends on the application, but i'm pretty sure that it will outperform them even in simple cases
16:06:34 <Saizan> show (Cell a) = [chr a]
16:06:35 <identifai> pedro3005: show (Cell a) = [chr a] -- right?
16:06:50 <pedro3005> yeah, what I did
16:07:00 <pedro3005> finally!
16:07:01 <pedro3005> thanks
16:07:07 <Polarina> mm_freak_: Thanks. Please keep up with the good work. :)
16:09:45 <mm_freak_> Polarina: unfortunately it's inconvenient to determine the FPS with animas, whereas in netwire you just use the 'avgFps' wire =)
16:13:17 <Polarina> mm_freak_: Wouldn't it be better to measure the total time it takes to finish a certain task (optionally repeatedly)?
16:13:49 <mm_freak_> Polarina: that doesn't really fit into the concept
16:14:05 <mm_freak_> in FRP a task is done, when the time is up
16:14:19 <mm_freak_> but i could measure the number of frames run for that time
16:21:02 <pedro3005> so
16:21:25 <pedro3005> I have data Cell = Cell Int. If I have a function Int -> Int, how do I apply it into a Cell?
16:21:39 <pedro3005> I tried making an instance of Functor for Cell
16:21:41 <fazzone> make Cell an instance of Functor?
16:21:41 <pedro3005> that didn't work
16:21:47 <pedro3005> exactly but
16:21:54 <pedro3005>     The first argument of `Functor' should have kind `* -> *',
16:21:54 <pedro3005>     but `Cell' has kind `*'
16:22:04 <fazzone> Ah right
16:22:08 <Peaker> applyInCell :: (Int -> Int) -> Cell -> Cell
16:22:19 <Peaker> applyInCell f (Cell x) = Cell (f x)
16:22:48 <Peaker> pedro3005: consider making Cell be a newtype, rather than "data", that cuts down on the overhead.. It has different semantics (which may be desirable in your case)
16:23:21 <Peaker> If you make it parametric on the number type inside it, rather than hard-coded Int, it may become more generically useful -- AND you can make it an instance of Functor automatically to avoid the applyInCell boilerplate
16:24:21 <Peaker> you can also make instances for Applicative/Monad, and that makes operating on multiple cells easier
16:24:30 <pedro3005> as in
16:24:41 <pedro3005> no, I can't imagine how that would go
16:25:07 <Peaker> pedro3005: Do you know the Identity type? Or how its Monad/Applicative/Functor instances work?
16:25:19 <pedro3005> hm... no.
16:25:21 <Peaker> newtype Identity a = Identity { runIdentity :: a }
16:25:36 <Peaker> pedro3005: The type     Identity a      is isomorphic and equivalent to the type   a
16:26:05 <Peaker> pedro3005: Here are its instances:   instance Functor Identity where fmap f = Identity . f . runIdentity
16:26:25 <Peaker> instance Applicative Identity where pure = Identity ;  Identity f <*> Identity x = Identity (f x)
16:26:57 <Peaker> instance Monad Identity where return = pure ; Identity x >>= f = f x
16:28:38 <pedro3005> Peaker, so I did
16:28:43 <pedro3005> newtype Cell a = Cell a
16:28:46 <pedro3005> is this what you meant?
16:29:15 <Peaker> pedro3005: Yeah -- so Cell = Identity
16:29:35 <pedro3005> Now how do I write a Show instance for this?
16:30:44 <Peaker> pedro3005: Which is OK, because it is syntactically separate from Identity, and you may want to have your own Identity types for type-checking purposes.  Another way to achieve this could be to use a type called Const:   newtype Const k a = Const { runConst :: a }     -- same as Identity but with the unused "k" arg -- so Const a and Const b can be distinct types by the type-checker, although identical representation (Just like Cell Int
16:30:44 <Peaker> and Int and Identity Int are all the same)
16:31:03 <Peaker> pedro3005: instance Show a => Show (Cell a) where ...
16:31:25 <pedro3005> But you see, it would not make sense for a to be anything but an Int
16:31:33 <pedro3005> so I don't see the point of this generalization
16:31:36 <Peaker> pedro3005: you may mean for Cell to be specifically for numeric types, and then you can use:  instance Num a => Show (Cell a) where ...
16:31:48 <Peaker> pedro3005: What about the bounds of Int? Maybe it would make sense to use a smaller/bigger int type there?
16:32:02 <Peaker> pedro3005: maybe you can use the Integral class restriction instead of being as specific as "Int"?
16:32:19 <pedro3005> but then will it let me use chr on it?
16:32:28 <pedro3005> since chr expects an Int
16:32:29 <Peaker> @type chr . fromIntegral
16:32:30 <lambdabot> forall a. (Integral a) => a -> Char
16:33:12 <Peaker> pedro3005: Why have an Int, and not a Char in the cell, if you're going to "chr" it?
16:33:26 <hpaste> NemesisD pasted “partial application” at http://hpaste.org/49958
16:33:37 <pedro3005> because I will need to manipulate it as a number
16:34:37 <Peaker> pedro3005: IMO it should probably be a Char you sometimes convert to an Int rather than the other way around :)  That way the restrictions on its range/etc are made explicit by the type
16:34:40 <NemesisD> http://hpaste.org/49958 i can't figure out how to consume some arguments in a function and then rely on partial application to get the rest
16:35:08 <kmc> "doesn't work"?
16:35:23 <NemesisD> doesn't compile
16:35:36 <pedro3005> Peaker, Why does Functor require a kind * -> *?
16:35:43 <NemesisD> not that i expected it to or i wouldn't have to ask the question ;)
16:35:44 <kmc> you should hpaste the type error when there is one
16:35:57 <Peaker> pedro3005: You can also use (with Flexible instances?)   instance Show (Cell Int) where ..      though I can understand if you'd rather restrict Cells to always contain the special type, and not be over-generalized. In that case, just have an   instance Show Cell where ..  (and you lose out on the nice Functor/Applicative/etc, need special-type combinators instead)
16:36:07 <Peaker> pedro3005: Because of the type of fmap
16:36:08 <kmc> just write add3 a x y = (+a) $ add2 x y
16:36:14 <Peaker> @type fmap
16:36:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:36:17 <kmc> composition of multi-arg functions is ugly
16:36:32 <kmc> @pl \x y -> f (g x y)
16:36:32 <lambdabot> (f .) . g
16:36:32 <Peaker> pedro3005: Note how "f" is used in the type of "fmap"
16:37:10 <Peaker> kmc: I like the SEC approach for that:   add3 a = (result . result) (+a) add2
16:37:13 <gwern> > 1474 / (215+1474)
16:37:14 <lambdabot>   0.8727057430432208
16:37:16 <NemesisD> kmc: couldn't match expected type Int with actual type (Int -> Int -> Int)
16:37:33 <gwern> > 44 / 85
16:37:34 <lambdabot>   0.5176470588235295
16:37:38 <pedro3005> Peaker, but why not make fmap also work on concrete types?
16:37:59 <azaq23> pedro3005: A functor is always a type constructor for a some type variable. You basically have a "container type" which contains some other type, and fmap implements functionality around that other type so that fmap :: (a -> b) -> f a -> f b
16:38:31 <pedro3005> but this is kind of like my case
16:38:34 <Peaker> pedro3005: perhaps with more advanced type-trickery, you could say something like:   class ConcreteFunctor f where   type Inside f ;   concreteFMap :: (Inside f -> Inside f) -> f -> f
16:38:40 <azaq23> functors are about turning arbitrary function into functions "over the type"
16:38:48 <NemesisD> kmc: ah so ((+a) . ) . add2
16:39:02 <pedro3005> I have a function (Int -> Int) and a type Cell Int, and I want to apply it to that
16:39:09 <Peaker> pedro3005: but this ConcreteFunctor class would not be possible in Haskell98/2010 and probably not very useful (though maybe useful for ByteString and some other types)
16:39:25 <NemesisD> that is kind of ugly
16:39:26 <Jafet> Then you'd define instance Functor Cell
16:39:50 <Peaker> @where SEC
16:39:50 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
16:39:54 <pedro3005> can't, since Cell is concrete
16:39:59 <Peaker> NemesisD: I recommend reading that about SECs -- it also handles your case
16:40:11 <Jafet> But you said "Cell Int"...
16:40:26 <Peaker> pedro3005: You can write your own combinator as I wrote above:   inCell f (Cell x) = Cell (f x)
16:40:29 <pedro3005> well, data Cell = Cell Int
16:40:38 <pedro3005> Peaker, yeah I guess that's what I should do
16:40:42 <pedro3005> I'll just do that
16:40:51 <Peaker> Jafet: I was suggesting making Cell parameterized on the content (like the Identity functor) to gain Functor/etc
16:41:13 <Jafet> If I really wanted fmap, I'd go with data Cell' a = Cell' a; type Cell = Cell' Int
16:41:19 <Peaker> pedro3005: inCell gives you functor-like power over Cell. You may also want Applicative-like power:    inCell2 f (Cell x) (Cell y) = Cell (f x y)
16:41:41 <Jafet> Maybe I'd name the constructor there Cell, to hide the trickery
16:42:00 <kmc> is all this fuss just so you can write 'fmap' instead of 'cellMap' ?
16:42:21 <pedro3005> basically, lol
16:42:23 <Peaker> kmc: if you also add the (auto?) instances for Applicative, Monad, it also saves some boilerplate
16:42:26 <Jafet> It's not fuss, it's generalization!
16:42:28 <NemesisD> Peaker: ill have a look
16:42:32 <Peaker> kmc: and gives you more combinators
16:43:24 <kmc> well Applicative is going to want something like Cell (a -> b)
16:43:38 <azaq23> Jafet: premature generalization
16:43:47 <Peaker> azaq23: is that a bad thing?
16:44:03 <Peaker> kmc: which may be fine.. His "restriction" on Cell may simply apply just to functions that need it and then they can take Cell Int
16:44:09 <danharaj> Don't strive for the maximum level of generality, but the right level of generality.
16:44:25 <Jafet> Is there ever such a thing as the maximum level of generality?
16:44:35 <Peaker> Generality often means simplicity..
16:45:17 <identifai> Saizan: i got haskell-mode working now: when you use turn-on-haskell-indent then it works fine; use M-x customize-group RET haskell RET for choosing that option..
16:45:20 <danharaj> Jafet: Maybe not, but you might zoom past the right level in search of that fabled maximum.
16:45:24 <Peaker> And it's easier to understand why something general is correct than something specific..   A function type of (Int -> Int) -> Cell Int -> Cell Int  has many more ways to be wrong than one that is   (a -> b) -> Cell a -> Cell b   for example
16:45:47 <identifai> Saizan: ++ there are also some other very nice modes and features :)
16:47:29 <pedro3005> I ended up doing data Cell = Cell Char
16:47:34 <pedro3005> so the restriction makes more sense
16:47:38 <pedro3005> and defining cellMap
16:47:46 <pedro3005> cellMap :: (Int -> Int) -> Cell -> Cell
16:47:46 <azaq23> Peaker: He didn't want a Cell :: * -> * type, but a concrete Cell type which only has an Int as an argument. Nothing about his problem statement suggested that it makes any sense to think of Cell as something functor like besides the fact that inCell, as an operation, looks exactly like the fmap definition for Identity. This thinking suggests that Cell is a container for arbitrary types, when in fact it is not
16:47:47 <pedro3005> cellMap f (Cell a) = Cell $ (chr . f . ord) a
16:48:13 <pedro3005> which works
16:48:49 <Peaker> azaq23: I understand that -- but there's no reason to avoid formulating his Cell type as a specialization of an Identity type.. That formulation gives you a lot of nice combinators for free
16:49:07 <dobblego> why is there a dude who "has used haskell for 5-6 years" using unsafePerformIO for apparently foolish reasons (are they?) and refusing to accept it "because it is easier"? http://www.reddit.com/r/haskell/comments/jarp0/hi_guys_i_made_a_haskell_to_clojure_translator/c2ajxtn (am I missing something here?)
16:49:46 <ddarius> dobblego: Crazy people exist.
16:49:55 <Peaker> dobblego: I saw that too.. I was wondering how someone can use a language for 5-6 years and still find that canonical fmap use unclear
16:50:16 <dobblego> ok so I am not missing something
16:50:21 <kmc> Haskell is obscure; it's quite possible to use Haskell for 5-6 years and never talk to another Haskeller or read anyone else's code
16:50:23 <ddarius> dobblego: Perhaps his motto is: Haskell, world's best impure language.
16:50:35 <ddarius> kmc: Only by choice.
16:50:59 <kmc> sure
16:51:03 <Jafet> preflex, seen dmead
16:51:05 <Peaker> I don't see how you learn any Haskell that way?  trial & error won't get you very far
16:51:19 <Peaker> surely you learn by reading about Haskell -- which is bound to include some example code?
16:51:21 <kmc> Peaker, you read tutorials and they never say "don't do this specific insane thing" because why would you
16:51:24 <danharaj> Maybe he's just like those people who say they 'know' C C++ Java LUA Smalltalk Lisp COBOL Ada Python Assembly (Three kinds) Visual Basic...
16:51:39 <kmc> anyway you see a lot of cargo cult madness in all kinds of languages
16:51:44 <benmachine> danharaj: that wouldn't surprise me
16:51:52 <kmc> C programmers who always declare their array one bigger than it has to be for good luck
16:51:52 <benmachine> "say you know haskell, no-one else does so you won't get caught"
16:51:53 <pedro3005> What do you guys recommend reading to learn all this crazy stuff I don't seem to know?
16:52:00 <kmc> mapping a page at zero
16:52:14 * hackagebot jonathanscard 0.1.1 - An implementation of the Jonathan's Card API.  http://hackage.haskell.org/package/jonathanscard-0.1.1 (MichaelSchade)
16:52:17 <danharaj> pedro3005: Program what you want and pick it up as you need it.
16:52:19 <kmc> Java programs that catch and re-throw every exception at every scope
16:52:32 <kmc> pedro3005, recommend being more specific about which crazy stuff
16:52:42 <pedro3005> which we were just discussing
16:52:43 <Peaker> show me how you sum a list of numbers in Haskell:   foldl' ((+) . unsafePerformIO . return) 0
16:52:46 <pedro3005> about functors etc.
16:52:53 <kmc> pedro3005, Typeclassopedia
16:52:57 <Jafet> Well, I once wrote unsafePerformIO . unsafeSTToIO . unsafeFreeze, so who am I to talk
16:53:06 <pedro3005> does that exist or is it a joke?
16:53:28 <danharaj> no joke
16:53:30 <Peaker> @where Typeclassopedia
16:53:30 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
16:53:31 <kmc> pedro3005, exists.  google it
16:53:42 <ddarius> danharaj: I could probably write code in all of those (depending on which three assembly languages) except Ada and I'd probably need a bit of a 'fresher for COBOL.
16:54:17 <ddarius> kmc: Most introductions, if they mention unsafePerformIO at all, usually say not to use it.
16:54:31 <kmc> ddarius, but you can find it digging through API docs
16:54:39 <kmc> and any way why would you follow that advice not to use it
16:54:48 <ddarius> kmc: I think the API docs also say not to use it.
16:55:01 <dobblego> I see a few of these ones too: x <- return e
16:55:12 <kmc> yeah dobblego
16:55:17 <kmc> i used that before i learned about let-in-do
16:55:32 <kmc> it's still useful if you need to be really absolutely sure you're not making a recursive binding, for whatever reason
16:55:43 <ddarius> That style avoids unintended recursive capture.
16:55:47 <dobblego> kmc: you probably said, "thanks for showing me let-in-do", instead of "lalalala, it's clearer that way!"
16:55:51 <kmc> dobblego, true
16:55:52 <Kaidelong> unsafePerformIO is fine if what you're doing is pure
16:56:08 <Kaidelong> I guess it's just hard to tell if it is really pure
16:56:09 <ddarius> Kaidelong: I don't think parsing a file is considered pure usually.
16:56:14 <danharaj> ddarius: but you don't use number of languages as a metric of competence.
16:56:17 <Jafet> Well, it's very useful if x does pattern matching
16:56:23 <ddarius> danharaj: How do you know?
16:56:33 <danharaj> ddarius: I'm not claiming it, I am demanding it of the universe.
16:56:40 <kmc> there's enough programmers who are so sure they're correct that they won't listen to, let alone seek out advice on their code
16:56:46 <kmc> it's a common phenomenon
16:56:51 <ddarius> I am, actually, a bit irked when I hear about "experienced" programmers that only know one or two languages.
16:56:52 <kmc> it shouldn't be surprising that some of those people use Haskell
16:56:55 <dobblego> the end of every do has "return ()"
16:57:03 <ddarius> That's just insane even from an industrial perspective.
16:57:39 <Kaidelong> ddarius: qualify "knowing a language" here for me?
16:57:52 <Kaidelong> just wondering whether I am one of those programmers
16:58:48 <danharaj> I wouldn't say I know more than two or three languages, but then again I don't claim to be experienced, and I also think I could read code in a lot more languages than I can write.
16:58:51 <ddarius> Could not (and more particularly, have not) program(med) anything in another language.
16:59:11 <ddarius> danharaj: You probably know more languages than you think, but maybe not.
16:59:21 <Kaidelong> hmm okay
16:59:29 <danharaj> do EDSL's in Haskell count? :p
16:59:34 <Kaidelong> yeah it would be insane to call such a person experienced
16:59:41 <ddarius> danharaj: No, but bash, Perl, Javascript do count.
17:00:58 <azaq23> Peaker: Yes, I see that, though I had the impression that he began to think that something like "data Cell a = Cell a" and then always using Cell Int was encouraged - type Cell = Identity Int seems more appropriate regarding your statement as seeing Cell as an instantiation of Identity applied to Int. Generally speaking, premature generalization can be dangerous because you may generalize in the wrong directions and lose focus.
17:01:05 <Jafet> I doubt quality of experience and knowledge of languages are related to beyond an absolute and irrefutable correlation
17:01:39 <danharaj> I took for granted that I once wrote my own toy website with (HTML, CSS, JS)
17:01:58 <alpounet> okay, i want to do some measurements on how long some piece of code takes (it does IO so i can't isolate it)
17:02:03 <alpounet> any advice ?
17:02:13 <Jafet> Criterion
17:02:18 <danharaj> ^
17:02:26 <Eduard_Munteanu> What about stuff one forgot? I think I used to know some BASIC at some point...
17:02:35 <Jafet> Eduard_Munteanu: which one??
17:02:46 <Eduard_Munteanu> QBasic
17:02:57 <ddarius> Eduard_Munteanu: I can't program QBASIC like I could 14 years ago.
17:03:10 <Eduard_Munteanu> (Oh, and Visual Basic)
17:03:12 <alpounet> Jafet, well it's a server, and i wanna measure how much time some piece of it takes to handle some interactions with the clients
17:03:41 <alpounet> oh
17:03:45 <alpounet> there's actually something for this
17:03:47 <Peaker> azaq23: Well, the problem with Identity is that it is untagged as a Cell..  Either a specialized Identity type or a Const type with a special type tag would be better
17:03:52 <Eduard_Munteanu> In fact I think QBasic was my first programming language.
17:04:07 <Peaker> azaq23: I agree about generalizations that you don't need and *cost* you. But in Haskell, generalizations often makes things easier to implement and use
17:04:28 <ddarius> Eduard_Munteanu: It definitely was mine other than typing the commands to start games in Commodore BASIC and I guess some very simple DOS BAT editting.
17:04:29 <Jafet> Criterion is really good due to its thoroughly scientific approach
17:04:30 <Peaker> The YAGNI principle applies to pretty much anything that costs you -- but not to things that are free or even make it cheaper
17:04:47 <alpounet> thanks
17:04:52 <hpaste> NemesisD annotated “partial application” with “partial application (annotation)” at http://hpaste.org/49958#a49959
17:05:20 <NemesisD> i guess i didn't understand this as well as i thought, kmc could you take a look at that and see what i'm doing wrong?
17:06:27 <Phyx-> weee finally managed to track down my memory leak
17:06:28 <Eduard_Munteanu> NemesisD: the pointfree style there looks gratuitious
17:07:03 <ddarius> Eduard_Munteanu: At any rate, having forgotten languages is much more acceptable than never having learned them.
17:07:26 <Phyx-> my ffi allocation tracker found http://pastebin.com/SicKciGT lol
17:07:56 <auvergne> i am having some difficulty with concurrency and gtk:
17:08:31 <danharaj> ugh
17:08:36 <auvergne> i fork an action that runs threadDelay, then calls a function, then the function i forked calls itself
17:08:42 <danharaj> I can't understand mfix or ArrowLoop
17:08:44 <danharaj> :\
17:08:58 <Peaker> NemesisD: I think when you have 4 Text arguments in a row, you're going into error-prone zone.. better give specialized types: e.g:  data LoginInfo = LoginInfo { user :: Text, pass :: Text } ..
17:08:59 <ddarius> danharaj: mfix allows recursive do.  That's all there is to know about it.
17:09:15 <auvergne> it compiles, but fails when a gtk function is called
17:09:43 <danharaj> ddarius: yeah, but I don't know what recursive do does, operationally.
17:09:43 <auvergne> actually, it doesn't crash immediately, but after a few delays, it always stops
17:10:16 <Eduard_Munteanu> @src mfix
17:10:17 <lambdabot> Source not found.
17:10:21 <Peaker> NemesisD: When you have (f .) . g    that means:  Apply "f" to the result of the result of "g".   If   g :: a -> b -> c -> d -> e ..         then this would apply "f" to (c -> d -> ...)
17:10:29 <ddarius> danharaj: It does exactly what a letrec does in an imperative language, albeit for whatever effects are modelled by the monad.
17:10:37 <Peaker> NemesisD: Did you read the SEC thing?  It explains this pretty well
17:10:59 <danharaj> ddarius: I don't know what letrec does in ML/other languages that have it.
17:11:11 <Peaker> @type mfix
17:11:12 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
17:11:23 <danharaj> let me guess
17:11:52 <Eduard_Munteanu> :t fix
17:11:53 <lambdabot> forall a. (a -> a) -> a
17:12:47 <pedro3005> how can I specify to haskell that (-1) is a function?
17:12:49 <danharaj> nevermind. I need to think more.
17:12:57 <Peaker> pedro3005: there's   subtract 1
17:12:57 <danharaj> pedro3005: (subtract 1)
17:13:12 <Peaker> Ugly quirk in Haskell syntax :-(
17:13:14 <danharaj> word.
17:13:35 <Jafet> > (- (1)) 1
17:13:36 <lambdabot>   -1
17:13:36 <Eduard_Munteanu> :t (- 1)
17:13:37 <lambdabot> forall a. (Num a) => a
17:14:02 <Jafet> :t (+ -1)
17:14:03 <lambdabot>     The operator `+' [infixl 6] of a section
17:14:03 <lambdabot>         must have lower precedence than that of the operand,
17:14:04 <lambdabot>           namely prefix `-' [infixl 6]
17:14:06 <Peaker> heh, Jafet, combined with lambdabot's Num instance for (->) that is confusing :)
17:14:06 <Eduard_Munteanu> > pred 5
17:14:07 <lambdabot>   4
17:15:14 <Eduard_Munteanu> :t pred
17:15:15 <lambdabot> forall a. (Enum a) => a -> a
17:17:10 <Peaker> @check liftA2 (==) pred (subtract 1)
17:17:11 <lambdabot>   "OK, passed 500 tests."
17:18:48 <danharaj> ok maybe I'm getting confused because I can't look at how mfix is defined in IO. Probably hackishly.
17:20:53 <Peaker> @type mfix print
17:20:54 <lambdabot> IO ()
17:21:08 <dolio> > subtract 1 minBound :: Int
17:21:09 <lambdabot>   9223372036854775807
17:21:14 <dolio> > pred minBound :: Int
17:21:15 <lambdabot>   *Exception: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
17:22:45 <Peaker> @check liftA2 (==) (pred :: Int -> Int) (subtract 1)
17:22:45 <lambdabot>   "OK, passed 500 tests."
17:22:52 <Peaker> QuickCheck sucks :-)
17:23:19 <Peaker> The Arbitrary instance for types should generate the corner-case values of that type..
17:23:20 <ezyang> Smallcheck is a good idea :-)
17:23:45 <Peaker> What's that?
17:23:56 <ezyang> it exhaustively searches small input spaces.
17:24:05 <ezyang> http://hackage.haskell.org/package/smallcheck
17:25:20 <dolio> Unfortunately smallcheck will never find this case, either.
17:25:43 <dolio> Because it will probably start at 0, and by the time it gets to minBound, you'll be dead.
17:25:59 <Jafet> pred is partial; let's disregard the little runt
17:26:07 <ezyang> It depends on how you define depth on Int.
17:26:46 <Eduard_Munteanu> Not overflowing could be nice at times.
17:27:05 <Jafet> @check liftA2 (==) (pred :: Int8 -> Int8) (subtract 1)
17:27:06 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary GHC.Int.Int8)
17:27:06 <lambdabot>    arising from a ...
17:27:21 <Jafet> Meh, so arbitrary.
17:27:22 <ezyang> lol.
17:29:05 <NihilistDandy> @tell edwardk I'll be around whenever you are available. No rush.
17:29:05 <lambdabot> Consider it noted.
17:30:23 <Jafet> @check liftA2 (==) ((\x -> fromIntegral . (pred :: Int8 -> Int8) . fromIntegral $ x) :: Int -> Int) (subtract 1)
17:30:24 <lambdabot>   "Falsifiable, after 308 tests:\n-140\n"
17:32:08 <amindfv> hey all
17:32:28 <amindfv> the Haskell in Education wiki is sort of old
17:32:31 <amindfv> (http://www.haskell.org/haskellwiki/Haskell_in_education)
17:32:41 <benmachine> yeah, our wiki isn't the best
17:32:51 <amindfv> anyone know of colleges that let a student focus on functional languages, for undergrad?
17:32:59 <djahandarie> CMU
17:33:17 <djahandarie> Possibly UPenn, haven't actually looked at their undergrad stuff though
17:33:28 <amindfv> djahandrie: ok, noted. Haskell?
17:33:40 <djahandarie> Nope, ML
17:34:32 <amindfv> djahandrie: after hacphi, I was looking at upenn a little, but it seems to be focussed in other places. could be wrong.
17:34:34 <NihilistDandy> amindfv: I'm going to try to convince the UVM CS department :D
17:35:17 <amindfv> NihilistDandy: let me know how you succeed. I love VT and UVM :)
17:35:39 <djahandarie> amindfv, ah, you were there? :) UPenn is pretty strong in their grad dep for functional programming and other PL stuff, would be strange if it wasn't there at all in undergrad
17:35:46 <NihilistDandy> It's all C and Java there, and that makes me a sad dandy. There is one course that introduces the functional paradigm, though, so it's not unheard of, just underdeveloped
17:35:51 <NihilistDandy> amindfv: Good to hear it :)
17:36:33 <dobblego> on the topic, I'll be running an intro to FP course at the end of the year at a workshop in Brisbane and Melbourne (Australia)
17:37:02 <amindfv> djahandrie: far right: http://yorgeys.smugmug.com/Computers/Hac-Phi-2011/18289396_wSgFwT#1410910689_9jCTCHP
17:37:27 <dobblego> http://bit.ly/qb4r9f
17:37:28 <amindfv> dobblego: at a university?
17:37:33 <dobblego> at a conference
17:37:35 <Phyx-> > group [1,1,2,1,1,2]
17:37:36 <lambdabot>   [[1,1],[2],[1,1],[2]]
17:37:42 <Phyx-> > group $ sort [1,1,2,1,1,2]
17:37:43 <lambdabot>   [[1,1,1,1],[2,2]]
17:38:05 <djahandarie> amindfv, ah, hey, it's you ! :p We played ping pong :)
17:38:14 <dobblego> table tennis :)
17:38:22 <amindfv> you won :)
17:38:34 <dobblego> we have a game of table tennis in our job interview process
17:38:49 <NihilistDandy> My rock and roll lifestyle does not include table tennis~
17:38:49 <Phyx-> > group $ sortBy
17:38:50 <lambdabot>   Couldn't match expected type `[a]'
17:38:50 <lambdabot>         against inferred type `(a1 -> a1...
17:38:57 <Phyx-> :t sortBy
17:38:58 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
17:38:58 <NihilistDandy> If you have a coke and hookers part of the interview, though...
17:39:19 <Phyx-> :t compare `on` show
17:39:20 <lambdabot> forall a. (Show a) => a -> a -> Ordering
17:39:52 <amindfv> NihilistDandy: how are you going to try and sway the UVM bigwigs?
17:40:20 <NihilistDandy> amindfv: Write up a proposal, present my case, provide nontrivial code examples
17:40:28 <NihilistDandy> I'm willing to take submissions :D
17:40:40 <NihilistDandy> Obviously I'd need to find an instructor who could teach FP
17:41:45 <amindfv> NihilistDandy: do they have an official process for adding new course topics?
17:42:15 <NihilistDandy> amindfv: Not sure, yet. I'm sure they have a particular way of doing it. Mostly I just want to get them thinking about it
17:42:18 <amindfv> NihilistDandy: also, are you looking to add a class, or a whole course track?
17:42:33 <amindfv> all: what about Yale, also?
17:42:33 <ddarius> amindfv: You have to cut off the head of a previous instructor in mortal combat.
17:42:40 <NihilistDandy> amindfv: Honestly, I'd settle for an elective :D
17:42:47 <amindfv> I mean, the SOE came out of there
17:43:11 <amindfv> ddarius: Shhhk! I'm ready.
17:43:11 <NihilistDandy> ddarius: Up, down, back, back, HK, LK, Start
17:43:49 <kmc> amindfv, Caltech will let you focus on functional languages, if you can find a prof that will sponsor your independent projects
17:43:50 <ddarius> Don't underestimate previous instructors.  How do you think they got there?
17:44:10 <kmc> the department is too small to have "rules" or "a fixed curriculum"
17:44:21 <kmc> or "teaching the classes you want to take"
17:44:54 <amindfv> kmc: ooh that's interesting.
17:45:04 <amindfv> kmc: I'll definitely look at that
17:45:17 <amindfv> all: (as well as the rest of your suggestions of course)
17:45:21 <NihilistDandy> I might have to consider that at UVM, too. I'm sure I can find someone :D
17:45:40 <NihilistDandy> I will Fibonacci them into submission
17:45:42 <amindfv> I actually would like to update the Wiki after I do my research and applications
17:46:11 <amindfv> NihilistDandy: yes, independent-study-friendly is also great
17:46:22 <Eduard_Munteanu> Heh, ddarius
17:46:32 <amindfv> oh by the way: I'm a transfer student
17:46:37 <NihilistDandy> Me, too
17:46:54 <NihilistDandy> Into an entirely new major, even
17:46:55 <amindfv> kmc: did you go to Caltech?
17:48:33 <NihilistDandy> > whatDoYouLike
17:48:34 <lambdabot>   "coke and hooker partypartypartypartypartypartypartypartypartyparty"
17:49:17 <Eduard_Munteanu> @vixen Do you like coke?
17:49:17 <lambdabot> yeah, i like
17:51:34 <Jafet> @vixen What about cocaine?
17:51:34 <lambdabot> i'll hafta plead the fifth on that one.
17:52:11 <amindfv> whoa what are all these lambdabot hacks?
17:52:16 <amindfv> I'm impressed
17:52:34 <ivanm> preflex: seen chrisdone
17:52:34 <preflex>  chrisdone was last seen on #haskell 2 hours, 26 minutes and 11 seconds ago, saying: stack overflows in haskell are possible, but the general case is different to those languages
17:54:04 <ivanm> @ask chrisdone is your flo project based upon a call-graph or a control-flow graph?
17:54:04 <lambdabot> Consider it noted.
17:54:12 <kmc> amindfv, yeah
17:54:46 <ivanm> @ask chrisdone and what can I do to graphviz to get you to use that instead of rolling your own dot-output generator? :p
17:54:46 <lambdabot> Consider it noted.
17:54:57 <kmc> > fix ("party hard " ++)
17:54:59 <lambdabot>   "party hard party hard party hard party hard party hard party hard party ha...
17:55:02 <amindfv> kmc: I'm going to Cali later this week. I'll definitely check it out - thanks for the tip
17:55:22 <kmc> amindfv, it's a weird school
17:55:27 <kmc> i can't say i recommend it for everyone
17:55:45 <amindfv> so UPenn seems to have a few FP-related courses (including a cancelled haskell class - which is a start!)
17:55:57 <amindfv> kcm: who'd you recommend it for?
17:56:09 <amindfv> kmc: I don't know anyone who's gone there
17:56:25 <kmc> afaik there are no classes on FP or programming language theory at all
17:56:39 <kmc> the guy who taught most of them left the year after i graduated
17:57:06 <kmc> amindfv, i will share my opinions of the school in #haskell-blah
17:59:46 <kmc> brb
18:01:28 <amindfv> kmc: ok
18:03:29 <sm> hrm. Is cmdargs not unicode-aware ?
18:03:49 <Jafet> Is it based on a C library?
18:06:49 <DukeDave> Hey gang, I need something like zipWith, but over an Traversable, does this exist?
18:08:10 <Jafet> How would you deal with different structures?
18:09:08 <danharaj> not every Traversable is Applicative, is it?
18:09:29 <Jafet> If you want to flatten the structures first, you'll need Foldable
18:09:31 <NihilistDandy> Is there a proper mathematical notion of "_" present in Haskell pattern matches?
18:09:33 <edwardk> danharaj: correct
18:09:33 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
18:09:48 * edwardk hugs lambdabot
18:09:55 <kmc> aww
18:09:59 * NihilistDandy ghc's lambdabot 
18:10:02 <dankna> edwardk: what is "slicing" in the context of trifecta?
18:10:07 <DukeDave> Jafet: Well in my case, they are two identical graphs, but I'd imagine in general you'd stop as soon as you've traversed all of one structure, as with zipWith.
18:10:11 <Jafet> NihilistDandy: _ is just a variable binding that immediately gets thrown away
18:10:12 <kmc> NihilistDandy, what are you looking for?
18:10:25 <dankna> (I was looking through your public repos on github in preparation for finally getting you my type-int changes.)
18:10:25 <edwardk> dankna: you can give it two input cursors and it'll give you the bytestring between them
18:10:26 <DukeDave> > zipWith (+) [1,3,4] [10,20]
18:10:27 <lambdabot>   [11,23]
18:10:32 <dankna> oh, nice
18:10:32 <Eduard_Munteanu> @hoogle (a -> b -> c) -> t a -> t b -> t c
18:10:33 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:10:33 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:10:33 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:10:38 <NihilistDandy> kmc: There's a discussion in #esoteric going on about how to typeset Haskell notation, and I figured this might be the place to ask
18:10:46 <kmc> heh
18:10:51 <dankna> so it's a feature for producing more informative diagnostics
18:10:52 <kmc> lhs2TeX does a pretty good job
18:10:55 <kmc> it has fancy modes
18:10:59 <kmc> but i think it always typesets _ as _
18:11:12 <edwardk> dankna: also you can ask for a 'careted' version of something and get a rendering that points to the start and draws the line it was on with a caret in the right place
18:11:13 <NihilistDandy> I thought so, too
18:11:18 <dankna> I approve
18:11:23 <NihilistDandy> I couldn't think of anything it could be represented as, really
18:11:30 <Jafet> DukeDave: what about zipping the tree ((0, 1), 2) with (3, 4)?
18:11:37 <edwardk> dankna: and if you use the most robust rendering support you can build full clang-style diagnostics (complete with color) on top of that
18:11:44 <edwardk> with multiple selected ranges, etc.
18:11:53 <dankna> I'd rather it were done with a LALR shift-reduce parser than with the combinator approach, because, as you may have noticed, I'm rabid about why we really do want and need strong parsing formalisms
18:12:07 <dankna> but I understand why combinator parsers are popular in Haskell
18:12:12 <edwardk> it intrinsically uses my file position monoid for that, to allow it to rewind it to the beginning of the line
18:12:14 * hackagebot wl-pprint-terminfo 0.2.2 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.2.2 (EdwardKmett)
18:12:20 <dankna> ah yes, sounds nice
18:12:32 <edwardk> LALR shift reduce cannot parse a sufficiently interesting class of languages for me ;)
18:12:43 <DukeDave> Jafet: Erm, there be dragons?
18:12:44 <dankna> ah, but they can, if you allow ambiguous grammars!
18:12:49 <edwardk> in particular it is a bitch when dealing with dynamic precedence
18:13:07 <Jafet> NihilistDandy: replace it with a unicode skull and crossbones
18:13:12 <Jafet> DukeDave: well, there you go
18:13:29 <dankna> I take your point; yes, there is an exponential blowup.  but again, ambiguous grammars with shift-rules that can cause the parse to fail can do what you want in a very clean way.
18:13:31 <edwardk> everyone starts writing some cheesy recursive descent parser for their first parser, then they defect to the american LALR school and build their second, then they come crawling back to combinators when they want more ;)
18:13:39 <dankna> I don't :)
18:13:42 <dankna> I write my own LALR
18:13:46 <dankna> repeatedly, in fact, haha
18:13:48 <NihilistDandy> Jafet: That would make it a bit more exciting to read, I think
18:13:50 <edwardk> =)
18:13:54 <edwardk> masochist
18:13:57 <dankna> I wrote it once in C, twice in Lisp, and once in Haskell
18:13:58 <DukeDave> I like the looks of liftA2 as Eduard_Munteanu found, but Graph isn't Applicative, and I assume that's for the reason you've just demonstrated?
18:14:01 <dankna> but the Haskell version isn't finished
18:14:04 <dankna> I've been called that :)
18:14:23 <edwardk> anyways, the class of languages i mostly tend to parse are slightly enriched visibly pushdown languages. so i push the skeleton off to a weak formalism like that then locally parse context-sensitively
18:14:31 <dankna> yeah, certainly
18:14:40 <dankna> that's the get-it-done-this-month approach
18:14:49 <edwardk> no
18:14:50 <dankna> mine is the do-it-with-the-prettiest-possible-formalism approach
18:14:52 <edwardk> quite the opposite
18:14:59 <dankna> howso?
18:15:01 <edwardk> its the run it in parallel across as many cores as you can
18:15:04 <edwardk> approach
18:15:10 <dankna> hm
18:15:12 <dankna> parallel parsing
18:15:12 <edwardk> and for that i need the stronger constraints
18:15:33 <edwardk> i have been working on various parallel parsing techniques for a couple of years now
18:15:38 <dankna> sounds fascinating
18:15:46 <danharaj> And you have become exceedingly efficient at it?
18:15:54 <dankna> I shouldn't call myself an expert on parsing, but it's probably the area where my theoretical knowledge goes deepest
18:16:00 <edwardk> what i'm packaging here includes none of them … well it includes the buffers that i use to build that stuff on top
18:16:22 <dankna> I've always thought of it as fundamentally non-parallizable because of the need to traverse the input in order
18:16:25 <edwardk> well, the sad thing is that the more i discard the traditional formalisms the faster it gets ;)
18:16:29 <dankna> haha :)
18:16:36 <dankna> disturbing :)
18:17:03 <edwardk> i started with derivatives of parsers using an interesting top down two-finger approach, then i switched to bottom up with observable sharing to recover an attribute grammar
18:17:15 <dankna> right, hm
18:17:50 <edwardk> the jump was about 3 fold between those, then i threw both of those out and went to an adhoc monoids + iteratee + parsec approach and bitonic combinating monoids to deal with lexing, and it sped up 10 fold again
18:18:07 <dankna> well, I do agree that a separate lex pass is needed
18:18:10 <edwardk> there is a theoretical motivation for the later
18:18:16 <edwardk> no, its not lexing separately
18:18:23 <dankna> I have no idea what it means for a monoid to be bitonic combinating, but okay
18:18:29 <edwardk> one sec.
18:18:32 <dankna> sure
18:18:51 <edwardk> http://comonad.com/reader/wp-content/uploads/2009/08/A-Parsing-Trifecta.pdf documents the hack i used
18:19:04 <dankna> reading
18:19:14 <dankna> ah, that explains the name as well
18:19:16 <edwardk> the last few slides talk about the monoidal dyck language recognition machinery i use
18:19:18 <dankna> I should have powerpoints on all my ideas
18:19:31 <dankna> then when people ask me about them I can just say go read the powerpoint, come back with money :)
18:20:02 <dankna> (note that I should actually call them Illustrators rather than Powerpoints.  a linguistic quirk.)
18:20:07 <edwardk> nah when i want money i polish them more: http://www.slideshare.net/ekmett/sma-tech-team-services
18:20:18 <dankna> yuk
18:20:23 <edwardk> =)
18:20:29 <dankna> see the first one loaded in less than a second for me
18:20:34 <NihilistDandy> I should call them beamers
18:20:36 <NihilistDandy> I do not
18:20:48 <dankna> why would you call them beamers?
18:20:53 <NihilistDandy> Just like I still call them band-aids, despite my best efforts
18:20:59 <NihilistDandy> dankna: LaTeX
18:21:01 <danharaj> edwardk: that is the most mixed metaphor I have seen :p
18:21:02 <dankna> oh, cool
18:21:16 <NihilistDandy> dankna: https://bitbucket.org/rivanvx/beamer/wiki/Home
18:21:29 <dankna> oh, cool
18:21:48 <NihilistDandy> It's pretty awesome, especially in combination with TikZ
18:22:20 <edwardk> danharaj: yeah it was a long night. basically a pulled an o'sullivan and hit flickr for commercial use images, pulled everything that looked good and stitched together a sales slick
18:22:45 <edwardk> danharaj: to be fair it was intended to have someone talking over it ;)
18:22:52 <edwardk> so the images are mostly punchlines
18:23:04 <danharaj> they tell a very colorful story :p
18:24:34 <danharaj> oh boy, I think I just had an 'ah-hah!' moment with ArrowLoop.
18:25:40 <copumpkin> danharaj: you got it to spit out something other than an infinite list of ascending numbers?
18:26:20 <danharaj> copumpkin: heh. I managed to come up with an operational picture I can keep in my head.
18:26:40 <danharaj> or so I think.
18:27:59 <Kaide> is there an instance (Arbitrary a) => Abitrary (Endo a)
18:28:46 <Kaide> or is arbitrary not enough?
18:32:15 * hackagebot BiobaseInfernal 0.5.3.1 - Infernal data structures and tools  http://hackage.haskell.org/package/BiobaseInfernal-0.5.3.1 (ChristianHoener)
18:36:13 <dankna> edwardk, I can't claim to have fully absorbed your slides, but I have read them at least.  interesting approach.
18:36:37 <edwardk> dankna: anyways the earlier approaches were vastly more general and more formal
18:36:44 <edwardk> but that one is fast enough i don't notice it ;)
18:36:48 <dankna> that's fair.
18:36:59 <dankna> I think what you're doing could be formalized, so it doesn't seriously offend me.
18:37:14 <dankna> certainly parallelization will only get more important with time.
18:37:23 <edwardk> yes, actually there is a deep connection to error productions in the grammar
18:38:00 <dankna> see one of the reasons I like shift-reduce so much is that people have done work on extending it in interesting ways
18:38:19 <manateeUser> Hey, all. :)
18:38:23 <edwardk> sure but in my experience, I find the LL(k) school has nicer extensions than the LALR school
18:38:38 <dankna> I've seen a paper on a beam-search which finds (probabilistically) a subset of corrections to the input, ordered by distance from it
18:38:50 <dankna> eliminating the need to use explicit error productions
18:38:50 <edwardk> we have those in the LL space as well
18:38:55 <dankna> do you?  hmm, okay
18:39:19 <edwardk> doitse swierstra has a library for the breadth first correcting parsers
18:39:31 <edwardk> uu-parsinglib
18:39:36 <edwardk> papers on them as well
18:39:38 * dankna nods
18:39:41 <dankna> I see
18:39:44 <edwardk> well paper
18:39:55 <NihilistDandy> hi, manateeUser
18:40:21 <dankna> btw, what is that decorative design to the left side of your slides?
18:40:40 <dankna> it resembles, but is not, marks used to align printing separations
18:40:41 <edwardk> something powerpoint put there =P
18:40:44 <dankna> haha okay
18:40:56 <dankna> then it's just something silly and techy-looking I guess
18:41:00 <edwardk> yeah
18:41:12 <edwardk> probably served a purpose before i mutated the master slide
18:41:15 <dankna> haha
18:42:13 <dankna> anyway, let me get you this type-int thing.  I have to migrate my changes from darcs to git, but I know how I can do that.
18:44:13 <edwardk> sounds good
18:44:39 <edwardk> playing with trifecta for a bit before getting dragged away
18:45:01 * dankna nods
18:45:19 <ManateeLazyCat> edwardk: Hey, how do you do?
18:45:24 <edwardk> i do like how the rendering code keeps getting simpler here though
18:45:27 <edwardk> heya manatee
18:45:29 <edwardk> quite well
18:45:37 <edwardk> long time no see
18:45:49 <ManateeLazyCat> edwardk: Yep, long time no see. :)
18:47:56 <dankna> sigh
18:48:05 <NihilistDandy> Indeed
18:48:07 <dankna> darcs doesn't need its own protocol for read-only access
18:48:18 <dankna> so publishing a repo on the web is as simple as, well, making it web-readable
18:48:26 <dankna> this wouldn't matter if git didn't have some failure modes around that
18:48:35 <dankna> struggling to even get a checkout ><
18:49:54 <dankna> okay, did it through their GUI app, which worked for some reason
19:01:31 <fengshaun> does anyone know of any practice problems specifically designed for haskell?
19:01:56 <fengshaun> I'm looking for something like projecteuler.net, but more to do with programming and haskell than math.
19:01:58 <Jafet> Go through "Purely Functional Data Structures" without looking at the code
19:02:04 <argiopeweb> http://www.haskell.org/haskellwiki/99_Haskell_exercises
19:02:13 <kmc> i like http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
19:02:51 <fengshaun> Jafet, argiopeweb, kmc: Thanks a lot, I'll check them all out tonight!
19:03:15 <Jafet> I was being jocular
19:03:22 <Jafet> Or jockular
19:03:31 <argiopeweb> Jafet: That would be an accomplishment...
19:03:33 <danharaj> more like jerkular amirite
19:03:50 <argiopeweb> danharaj: Badum-chi
19:06:52 <dankna> edwardk, okay!  you have a pull request
19:07:03 <edwardk> dankna: sweet
19:07:11 <edwardk> i'll see if i can steal some time to work on it tomorrow
19:07:16 <dankna> awesome
19:07:20 <dankna> I look forward to the results
19:09:10 <danharaj> is there a way to put a typeclass constraint of the type: "(f a) is a functor for all a"?
19:09:19 <edwardk> no
19:09:24 <danharaj> That's bollocks. :[
19:09:29 <edwardk> you make a new class
19:10:21 <danharaj> edwardk: eh?
19:10:23 <Cale> Can't you write Functor (f a)?
19:10:53 <edwardk> cale: you can say that for any particular a, of course
19:11:00 <gaxar77> Hey everyone. I'm getting really irritated here. I guess it's because I am misunderstanding something about lazy evaluations. When I use == with type Tree a0 -> Int and Int I get an error saying it cannot march.
19:11:04 <gaxar77> Thing is...
19:11:11 <gaxar77> I'm comparing the integer result of a function.
19:11:22 <gaxar77> With another Int value.
19:11:22 <Cale> edwardk: Oh, he wants  (forall a. Functor (f a)) => ...
19:11:22 <danharaj> gaxar77: hpaste.org your code
19:11:27 <edwardk> yeah
19:11:28 <gaxar77> Okay.
19:11:30 <Cale> okay, yeah, that's not possible
19:11:47 <Jafet> gaxar: evaluation doesn't matter at all if it didn't compile
19:11:49 <kmc> gaxar77, why do you think it's about laziness?  Haskell's type system would look the same if Haskell were a strict language
19:11:52 <danharaj> Is it in principal not possible (like, highly intractable), or just not allowed?
19:12:11 <edwardk> principal
19:12:41 <gaxar77> Here is the code: http://pastie.org/2337228
19:12:48 <Cale> principle?
19:12:54 <gaxar77> The problem is in the insertNode function.
19:13:04 <Cale> gaxar77: omgtabs
19:13:11 <mauke> gaxar77: idx == idx treeRoot can't be right
19:13:19 <gaxar77> What's wrong with tabs?
19:13:20 <Cale> gaxar77: Make sure to configure your editor to convert tabs to spaces
19:13:33 <edwardk> s/al/le =)
19:13:52 <mauke> gaxar77: tabs are fine if you never mix them with spaces and follow a few rules when writing haskell
19:13:59 <danharaj> tabs = 8 spaces according to ghc
19:14:05 <Cale> The problem with tabs is that the Haskell compiler cares about how things line up. It will always treat tabs as aligning to the next multiple of 8 spaces, but not all editors will.
19:14:06 <mauke> thing is, most other haskellers don't do this and tabs are somewhat unusual
19:15:32 <mustelo> gaxar77_, you've masked the name idx by giving a parameter the same name
19:15:41 <gaxar77_> oh
19:15:51 <danharaj> yeah, I remember when that bit me the first time :)
19:15:52 <gaxar77_> So all I have to do is use a different name for the parameter?
19:15:55 <danharaj> yes.
19:16:01 <gaxar77_> Okay, let me try it.
19:16:21 <danharaj> It has nothing to do with lazy evaluation, GHC just saw that idx has to be two different types. You saw that error because it assumed one of those types before the error occurred.
19:17:04 <gaxar77_> Well, it loaded the module.. now I have to make sure the functions work correctly.
19:17:14 <gaxar77_> Thanks for the help.
19:17:30 <gaxar77_> Oh I see danharaj.
19:17:33 <gaxar77_> That makes sense now.
19:18:14 <danharaj> Yeah, a large part of learning Haskell is learning how to decipher the type errors you get.
19:18:40 <danharaj> You'll get a feel for the type inference as you use it. A good thing to do when you're stumped by a type error is to add annotations.
19:19:03 <kmc> another thing to do is to replace expressions with "undefined" until it compiles
19:19:15 <danharaj> GHC will make its own guess about types, and those guesses might be confusing to you when you see the error. By giving it annotations, you tell it what you intended, so the errors will make more sense to you.
19:19:48 <danharaj> also, generally it's a good idea to give a type annotation to every top level value, for documentation's sake.
19:20:37 <gaxar77_> Hey the code works.
19:21:34 <gaxar77_> You mean when I define the types for a functions? Like myFunc :: Int -> Int -> Int?
19:22:19 <danharaj> yeah
19:27:04 <gaxar77> Sorry I got disconnected again.
19:27:22 <gaxar77> My singal is not strong.
19:27:26 <gaxar77> sgnal*
19:27:36 <gaxar77> signal**
19:28:08 <gaxar77> I guess I need some spelling pointers.
19:29:08 <darius> oops
19:31:21 <mustelo> no pointers in haskell
19:31:35 <NihilistDandy> mustelo++
19:32:54 <EvanR> mustelo: ffi Ptr
19:34:20 <gaxar77> Sorry I was disconnected... again!
19:35:45 <gaxar77> Stupid WiFi!
19:37:14 * hackagebot trifecta 0.6 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.6 (EdwardKmett)
19:44:19 <amindfv_> second haskell-in-college question:
19:44:48 <NihilistDandy> amindfv_: Start a club, begin assimilation. The Haskell Collective demands it.
19:44:50 <amindfv_> where can I study, or what can I study, to support my Pure FP training, even if maybe the school is not so into Pure FP?
19:45:17 <NihilistDandy> amindfv_: Study theory of computation, I suppose
19:45:20 <dolio> Math.
19:45:51 <amindfv_> so, I've been reading Okasaki's Purely Functional Data Structures
19:45:56 <NihilistDandy> Also, hardwire a connection to #haskell into your brain
19:46:05 <amindfv_> and I could be doing those in several languages
19:46:31 <NihilistDandy> amindfv_: Why aren't you?
19:46:32 <amindfv_> dolio: Which math?
19:46:49 <NihilistDandy> amindfv_: The pure kind. Applied math is for squares.
19:46:49 <amindfv_> NihilistDandy: because haskell is better :)
19:47:06 <dolio> Abstract algebra is nice.
19:47:13 <NihilistDandy> ^^
19:47:23 <NihilistDandy> And category theory's fun
19:47:30 <NihilistDandy> FSVO fun
19:47:50 <dolio> If you can find a course on mathematical logic, that'd be excellent.
19:48:00 <amindfv_> NihilistDandy: my encounters with CT in math and in CS have been pretty different
19:48:10 <amindfv_> although, I'm just starting in it
19:48:15 <NihilistDandy> amindfv_: You need to get more abstractly nonsensical about it :D
19:48:23 <Eduard_Munteanu> I'm not sure university provides much in the way of studying programming languages.
19:48:36 <Eduard_Munteanu> At least compared to other fields, it's a really open one.
19:49:47 <Eduard_Munteanu> E.g. it's much harder to find good online material for learning other stuff.
19:50:10 <Eduard_Munteanu> So waiting/looking for a univ course isn't a good excuse :P
19:50:10 <amindfv_> so does anyone want to take a real stand, and say what they think would be the better, of the following 2 options:
19:50:51 <amindfv_> 1) Study non-FP in school. Study scheme if I'm lucky, and learn CS in general
19:51:05 <amindfv_> 2) Study math, abstract algebra, CT, etc
19:51:09 <NihilistDandy> Do both.
19:51:09 <amindfv_> in my learning of haskell
19:51:27 <ddarius> Get an MBA, study PL outside of school.
19:51:39 <Eduard_Munteanu> Heh.
19:51:47 <NihilistDandy> Ick, too practical
19:51:51 <dankna> 1)
19:52:03 <amindfv_> NihilistDandy: I might, but I'm curious what's better
19:52:06 <dankna> you need a data structures and algorithms course - it's the only undergrad course that's worthwhile in CS
19:52:11 <NihilistDandy> amindfv_: Define "better"
19:52:15 <dankna> but one worthwhile undergrad course is more than many majors have at all
19:52:24 <amindfv_> ddarius: indicate sarcasm, or I might go do it on accident
19:52:25 <NihilistDandy> Also, tell me your entire life story so I can attempt to make a judgment
19:52:39 <dankna> life stories belong in -blah :D
19:52:41 <amindfv_> NihilistDandy: better for my Haskell coding
19:52:50 <NihilistDandy> amindfv_: Math, then.
19:52:52 <djahandarie> I think 2) will be more interesting, but 1) is probably more practical
19:52:54 <dankna> honestly you have the wrong goal here
19:52:56 <ddarius> amindfv_: If you are going to pay for and waste four years (or more) of your life, do it doing something you can't easily get for free.
19:53:12 <dankna> your Haskell coding will improve with time; just use Haskell
19:53:20 <dankna> that's the ONLY thing that will improve it, also
19:53:23 <amindfv_> djahandrie: practical in what way? For learning, jobs, or grad school?
19:53:27 <dankna> study of CS or of mathematics will not
19:53:39 <djahandarie> Jobs, and grad school if you want to do CS grad school
19:53:52 <amindfv_> dankna: as far as algorithms, a lot of implementation is very different in FP
19:54:00 <amindfv_> data structures also, I guess
19:54:15 <dankna> amindfv: do this, then.  buy yourself volume 1 of Knuth's _The Art of Computer Programming_.  attempt to do the exercises.
19:54:20 <amindfv_> dankna: see Okasaki, and Fethi(?)
19:54:29 <dankna> if you cannot do the exercises, go major in computer science until you can.
19:54:36 <dankna> it's a book worth owning anyway.
19:54:38 <amindfv_> dankna: :)
19:54:57 <ddarius> amindfv_: Alternatively, do chemistry or physics because you probably can't get a mass spectrometer and proton NMR machine or a high-powered cyclotron on your own, but you can definitely buy a laptop.
19:56:35 <amindfv_> ddarius: I'm really receptive to this type of advice
19:57:13 <amindfv_> ddarius: but with limited time, and an interest in really mastering coding, could I be doing chem or something, with PL "on the side"?
19:57:19 <djahandarie> I personally wouldn't be getting a degree at all if I didn't want an easier time getting a job
19:57:35 <amindfv_> ddarius: and wouldn't it suck for grad school apps?
19:57:36 <djahandarie> And CS is the easiest degree for me to get, so I'm doing that. Also will hopefully pick some stuff up along the way.
19:58:15 <amindfv_> djahandrie: s/job/grad school slot;  same here
19:58:31 <dankna> djahandarie, I agree
20:00:03 <ddarius> amindfv_: With an interest in programming, you could be a quite useful chemist or physicist.
20:01:01 <dankna> or, for that matter, a quite useful anything except literature professor; computational literature is probably possible but they're opposed to the idea on principle
20:01:11 <zzing> Would something like snap work well on a vps with 256mb ram? Low bandwidth site.
20:01:43 <amindfv_> NihilistDandy: my life story: 0) Birth. 1) [blur] 2) [hazy drama] 3) Desire to go to grad school, for CS.
20:02:18 <djahandarie> Why exactly do you want to go to grad school anyways? I don't particularly want to do that
20:02:20 <NihilistDandy> Then math is the answer
20:02:24 <amindfv_> dankna: do you really think that study of CS won't be a major factor in learning Haskell?
20:02:36 <NihilistDandy> zzing: Depends how popular you are
20:02:38 <dankna> amindfv: I think that formal education does very little to help one in that goal, yes.
20:03:12 <dankna> amindfv: but at least take a DS&A class, please, which you can do no matter what your major is, or even if you don't go to college at all!
20:03:17 <kmc> 0) Birth 1) [blur] 2) College [blur, hazy drama]
20:03:23 <zzing> NihilistDandy: I am not :P It is a site where I can host a latin dictionary I am going to be making for my studies.
20:03:26 <dankna> (most professors are flattered when people ask if they can audit their courses)
20:03:43 <NihilistDandy> zzing: Then you should be fine, afaik
20:04:07 <amindfv_> ddarius: assuming I'm most passionate about coding, though?
20:04:20 <amindfv_> or is passion not the point
20:04:43 <dankna> amindfv_, one other thing which a bachelor's can be viewed as good for (although I don't believe it to be, myself?) is to help you get a more concrete research interest
20:04:58 <dankna> amindfv_: right now you seem to know you want to be doing research, but not what sort exactly
20:05:07 <zzing> I am looking for hosting right now, and found a vps company that might work for me. I am looking at a few host options - node.js, sinatra (ruby), and snap... :P Merci for your thoughts.
20:05:35 <amindfv_> djahandarie: I'd want to go to grad school because I'd like research to be a job
20:05:38 <dankna> amindfv_: grad schools are always getting more competitive, not least because they have bottom lines too and can only take so many students in this economy; I've seen very bright students be told to come back in a year with a more specific topic in mind
20:06:04 <djahandarie> amindfv_, learn a topic very well, skip all the crap, publish some papers, get hired at a company for research
20:06:06 <NihilistDandy> zzing: No harm looking into yesod, too, if it fits your model
20:06:21 <amindfv_> dankna: theyre doing computational lit in a few places
20:06:27 <amindfv_> analyzing old texts etc
20:06:35 <zzing> bookmarked, thank you again
20:06:37 <dankna> amindfv_, yeah, I was actually vaguely aware that might be the case
20:06:46 <dankna> amindfv_, and it's very cool, but for the sake of a joke? haha
20:07:10 <dankna> I wish I believed djahandarie's suggestion were possible, but I don't think outsiders to academia get papers published, heh
20:07:38 <dankna> certainly it would be a much riskier path
20:07:42 <djahandarie> Sure they do, just coauthor with some in academia. It's possible if you have all the good ideas
20:07:50 <djahandarie> But yeah, riskier
20:07:57 <dankna> well, it hasn't yet worked for me, but who knows, it still might :)
20:08:23 <NihilistDandy> Typeset a paper for one of your idiot colleagues. Ask for collabo credit. Profit.
20:08:31 <dankna> amusement
20:09:07 <amindfv_> djahandarie: is that actually realistic, in the sense of 1) been done before, 2) cutting out the crap would save significant man-hours?
20:10:40 <darius> wasn't oleg not technically an academic when he started publishing?
20:10:53 <amindfv_> djahandarie: because if there's a siren song in my vocabulary, it's "skip all the crap"
20:11:28 <dankna> that would technically be in your idiolect, not your vocabulary, as it's a phrase and not a word
20:11:55 <djahandarie> Holy smokes, it's Darius Bacon
20:12:08 <amindfv_> dankna: ooh, wrong crowd to start bullshitting linguistics with
20:12:14 <djahandarie> Now there are three Darius in here...
20:12:29 <amindfv_> who's #3?
20:12:39 <darius> er, hi
20:12:43 <djahandarie> ddarius, but his name isn't actually Darius so I guess that doesn't count.
20:13:05 <darius> I think it was ddarius who graciously donated this nick to me
20:13:15 <dankna> amindfv_, heh true
20:13:40 <djahandarie> amindfv_, who knows if it'd save time, but it sure sounds like more fun
20:14:13 <amindfv_> djahandarie: hell yes it does
20:14:48 <djahandarie> darius, so what brings you here, besides trying to confuse people even more with the nicks? :p
20:14:51 <amindfv_> so has it been done?
20:15:03 <djahandarie> Simon PJ didn't do grad school
20:15:33 <amindfv_> djahandarie: really?
20:15:38 <djahandarie> Yep
20:15:42 <bss03> So, are research papers on implementing restricted fundeps (enough to type MTL) worthy of a thesis?  I'm thinking of going back to school and I'd like to actually have my work be on open problems in static typing and type inference.
20:15:54 <darius> djahandarie, just wanted to msg to a friend who's not around at the moment, and #haskell beckoned
20:15:57 <ddarius> bss03: What level of thesis?
20:15:58 <bss03> Or, has the research been done and we are just waiting on a GHC extension?
20:16:04 <djahandarie> Hehe. :)
20:16:05 <darius> holy smokes there are a lot of people here now
20:16:08 <amindfv_> he was at Glasgow as a Prof, though, right?
20:16:11 <bss03> I don't have my Master's yet, so lets start there.
20:16:37 <ddarius> bss03: You may be able to do something as a Master's thesis.  Those things are usually not worth the paper they're printed on anyway.
20:17:33 <djahandarie> I suppose that System F_c subsumes any useful research on fundeps though? Unless you want to start proving different things about them
20:18:07 <bss03> The first question that comes to mind is "Then, what would be Ph.D. level?" but I guess it'll probably take me years before I even start on that, so the topics (and my interests) will have changed a bit...
20:18:17 <Eduard_Munteanu> I'm wondering how feasible it is to get into research without having a masters or doctoral degree.
20:18:22 <Eduard_Munteanu> Maybe corporate research.
20:18:53 <djahandarie> Apparently everyone and their brother is wondering that in here.
20:18:56 <dankna> I'm wondering the same
20:18:58 <dankna> ah
20:18:58 <dankna> yes
20:19:01 <dankna> I don't have a brother
20:19:05 <dankna> but I can pretend to be my own
20:19:07 <bss03> System F_c?  I'm familiar with System F, System F-omega and, System F-sub...  where does System F_c fit in there?
20:19:10 <anknad> I'm also wondering that
20:19:18 <dankna> like that, see
20:19:36 <Eduard_Munteanu> I'd rather work for a while in contact with people doing research and slowly transition if the opportunity arises.
20:19:47 <djahandarie> bss03, it's GHC's lambda calculus which allows it to do all the cool shit you see in its extensions
20:20:06 <djahandarie> (Including fundeps)
20:20:26 <bss03> Ah, so somewhere so somewhere between System F-sub and System F-omega.
20:20:38 <Eduard_Munteanu> AFAIK, there are a few big players doing at least some publishable research.
20:20:48 <darius> Eduard_Munteanu: gregor kiczales got his PhD for work done at PARC, and he had no undergrad degree IIRC
20:21:06 <Eduard_Munteanu> Hrm, interesting.
20:21:08 <darius> pretty unusual, obviously
20:21:24 <djahandarie> bss03, more than system f_omega, fairly unrelated to F_sub
20:22:57 <bss03> djahandarie: I'm pretty sure all the Type assertions that are done in F_sub are handled by GHC's type system.  I guess technically GHC implements them as type class assertions, but they are there.
20:23:26 <bss03> Like GHC and go from Monad a => a <: Functor a => a
20:23:41 <bss03> s/and/can/
20:25:12 <djahandarie> Type classes don't involve any subtyping, normally they are just translated into dictionaries
20:26:20 <bss03> I was a little bit interested in implementing a GHC extension to handle System F-sub assertions (there's evidently a Modula-3 implementation out there, including inference) but for most practical purposes, super-typeclasses are all that's needed.  Structual inheritance would be nice in GHC, but I think it mostly unnecessary...
20:27:45 <bss03> They don't involve sub-typing, they invole sub-typeclassing, but the assertions are virtually identical.
20:31:19 <bss03> djahandarie: How is GHC's type system more than System F-omega?  System F-omega includes values dependent on types and types dependent on types, and GHC still doesn't handle types dependent on values; you have to go to AGDA or Coq to get that crazyness.  Type dependant on values doesn't seem to be statically typeable to me.
20:33:17 <djahandarie> System F_omega doesn't involve types depending on values, only everything else.
20:33:44 <Eduard_Munteanu> bss03: it is, in Coq or Agda.
20:33:54 <bss03> Right.  GHC doesn't handle types depending on values either, from what I understand.
20:34:51 <djahandarie> Indeed. So what is the problem? It's different than F_omega, just not in the dependent type direction.
20:35:09 <Eduard_Munteanu> Obviously, if the value the type depends on can't be computed at compile-time then it stays as an unknown variable.
20:35:32 <bss03> Eduard_Munteau: How to you determine the type of f :: Int -> (Type dependent on the value of the Int) when it is in something like do { i <- read; return $ f i; }?
20:35:33 <djahandarie> It's technically System F with non-syntactic type equality.
20:35:41 <Eduard_Munteanu> Which means it won't unify with other stuff unless you can prove it.
20:36:24 <Eduard_Munteanu> bss03: the type depends on exactly that expression
20:37:14 <bss03> Eduard_Munteanu: Can Coq and AGDA will reject something where the type variable that is unknown can't be "removed"?  Otherwise, it doesn't appear like they are doing full static typing, they are leaving some type variables for unification at run time.
20:37:53 <copumpkin> bss03: ?
20:37:56 <Eduard_Munteanu> They aren't leaving it at runtime. It's just you won't be able to write the proof for your "theorem".
20:38:08 <copumpkin> bss03: example?
20:39:20 <bss03> copumpkin: Sorry, I'm not too well versed in Coq / AGDA.  And I don't want to make up a confusing syntax for types dependent on values in Haskell.
20:39:27 <Eduard_Munteanu> For instance, if you're reading some dependent list "Vec A n" at runtime, you'll not be able to prove n is 5, because you can't prove the expression n is represented by is equal to 5.
20:39:30 <copumpkin> bss03: just describe the situation
20:40:01 <Eduard_Munteanu> (n being its length)
20:40:47 <bss03> But, it might look something like this: f x = undefined; f :: Int -> (Type depenent on value of x); main = do { i <- read; return $ f x; }; main :: IO (???)
20:41:10 <Eduard_Munteanu> There is no 'undefined' in Agda :)
20:41:49 * ddarius doesn't know why bss03 is writing Agda as "AGDA."
20:41:53 <Eduard_Munteanu> It's a total language, so not every type is trivially inhabited by a bototm.
20:41:58 <Eduard_Munteanu> *bottom
20:42:09 <djahandarie> Eduard_Munteanu, doesn't matter wrt his question.
20:42:44 <Eduard_Munteanu> Ah, yes, it isn't.
20:42:59 <bss03> Eduard_Munteau, well assume it is something like replicate 0 = Nil; replicate x = 42 `Vec_cons` replicate (x - 1); replicate n :: Vec Integer n
20:43:12 <Eduard_Munteanu> Well, just writing that type signature doesn't break anything.
20:43:44 <bss03> ddarius: I don't know either, maybe I thought it was an abbreviation for a second.  That would be wrong.
20:44:23 <djahandarie> (Wouldn't 'COQ' be more likely as an abbreviation?)
20:45:08 <bss03> djahandarie: I think Coq is either a name or short for name...  so I didn't capitalize it as an abbreviation.
20:45:55 <monochrom> Coq and Agda are not abbreviations
20:46:12 <NihilistDandy> ^^
20:46:23 <Eduard_Munteanu> bss03: more like    replicate : (n : ℕ) -> Vec A n
20:46:47 <bss03> Eduard_Munteau: I'd expect something that did statis typing to either (a) request that I write a type signature for main or (b) fill in the "???" with something sane.  It seems no matter which of those it chooses, the types could be wrong at runtime.
20:47:41 <Eduard_Munteanu> Types aren't wrong at runtime.
20:47:59 <Eduard_Munteanu> (they *aren't* at all :D)
20:48:34 <bss03> So, does compilation fail with a type error?
20:49:09 <bss03> Or, does the compiler punt the type variable and unify it at runtime -- thus doing dynamic typing?
20:49:36 <Eduard_Munteanu> bss03: consider the following theorem    t : (v : Vec A n) -> length v == 3
20:49:42 <dolio> Calculus of Qonstructions.
20:49:55 <Eduard_Munteanu> Just writing the type signature doesn't make anything go wrong.
20:50:00 <Eduard_Munteanu> But you can't prove it.
20:50:48 <Eduard_Munteanu> (length v   could simply be replaced by n there)
20:51:14 <bss03> Eduard_Munteanu: Okay, but I am asking Coq / Agda to make sure my program is well-typed, statically.  Can they do that with types depending on values.  Particularly, values whcih aren't known until runtime?
20:51:35 <dolio> Yes.
20:52:30 <bss03> So, what would they require / infer for the "???" in my example above?
20:52:32 <Eduard_Munteanu> Yeah, but the burden of providing rich enough types and acceptable proofs is on you.
20:53:13 <Eduard_Munteanu> main has a type similar to Haskell's in Agda.
20:53:59 <Eduard_Munteanu> IO \top    , erm IO T (for lack of unicode completion here)
20:54:23 <bss03> Eduard_Munteau: (1) Ignore that the function is named main, that really isn't relevant to my question. (2) GHC accepts a main of any type that can be unified with IO a, so a lot can go in that "???".
20:54:43 <copumpkin> bss03: I think you're looking for something like decidable predicates
20:55:52 <bss03> I think I'm confused at the claim that you can have all 3 of (a) static typing (i.e. before run-time), (b) types depenent on values, and (c) run-time provided values.
20:56:02 <Eduard_Munteanu> If some type depends on runtime values, then it depends so in an opaque manner. Nothing breaks.
20:56:02 <copumpkin> bss03: think about Maybe
20:56:29 <copumpkin> bss03: let's say you have an interpreter for a language that takes an AST and runs it
20:56:38 <copumpkin> bss03: you take input from the outside world
20:56:50 <copumpkin> a string can _maybe_ be parsed into an AST
20:57:03 <copumpkin> if it fails, you have some failure handling code that might presumably display an error to the user
20:57:08 <copumpkin> right?
20:57:22 <bss03> Eduard_Munteanu: So, Coq / Agda will reject the program if a type that can only be decided at run-time "leaks".  That is, it isn't hidden by an opaque dependency?
20:57:41 <copumpkin> so the AST-walking interpreter doesn't need to be aware of possible input errors
20:58:10 <copumpkin> bss03: make sense so far?
20:58:29 <Eduard_Munteanu> bss03: nope, that's not the point. Types are discarded at runtime anyway, they're only needed for typechecking. And typechecking can fail if your proofs (code) depend on particular runtime values.
20:58:53 <bss03> Eduard_Munteanu: That really sounds like a yes to me.
20:59:07 <Eduard_Munteanu> If you can't prove something at compile-time, you can't prove it at runtime anyway.
20:59:15 <bss03> copumpkin: Sure, not sure how you are going to bring this around to types dependent on values.
20:59:22 <copumpkin> bss03: it's exactly the same thing
20:59:38 <copumpkin> bss03: say I have an algorithm that expects a list of length 3
20:59:46 <copumpkin> how can I make it work at runtime with user-provided input?
20:59:52 <copumpkin> I run in Maybe
20:59:57 <copumpkin> Maybe (Vec A 3)
21:00:02 <dolio> The static type checking will enforce that you handle the runtime values correctly, whatever they are.
21:00:03 <copumpkin> if Nothing, the algorithm doesn't run
21:00:12 <copumpkin> if Just, the algorithm runs on the correct value
21:00:12 <bss03> copumpkin: I disagree, you value values dependent on values there.  The type (Maybe AST) doesn't depend on types or values.
21:00:29 <copumpkin> bss03: that's the point of a decidable predicate
21:00:39 <copumpkin> a proof is a value
21:01:26 <copumpkin> bss03: say I have an algorithm that takes a number, a proof that the number is even, and a tree with that even number of nodes in it
21:01:46 <Eduard_Munteanu> bss03: there's a difference between "a type depends on runtime values" and "a proof is incorrect because a runtime-dependent opaque value can't unify with 3"
21:01:47 <copumpkin> I can run that on values provided at runtime in the manner I just described
21:02:10 <bss03> Wait wait wait.
21:02:20 <bss03> I'm sorry, I really shouldn't have brought this up.
21:02:26 <copumpkin> so in some sense, the function returning the Maybe (some fancy type here) is deciding whether the predicates are true or not
21:02:33 <copumpkin> bss03: we can take it to #agda if you want
21:02:43 <bss03> It's nearly 90 minutes after my bed time, and I don't think I have time so really understand this tonight.
21:02:48 <copumpkin> ah ok
21:03:02 <bss03> Thanks for trying to explain things, everyone.
21:03:05 <copumpkin> np
21:03:08 <copumpkin> ask again tomorrow :)
21:03:26 <Eduard_Munteanu> You might also want to grab Agda and run a few tests to see ;)
21:03:45 <Eduard_Munteanu> That'd settle a lot of "what-ifs".
21:04:39 <bss03> Well, maybe.  Anyway, I really need to settle down and try to get some sleep.
21:04:54 <bss03> Again, thanks.
21:10:22 <roconnor> can I readFile with a particular encoding easily?
21:12:40 <ddarius> There should be a hSetEncoding or somesuch.
21:13:52 <edwardk> roconnor: you can always read and filter it through text-icu
21:14:20 <roconnor> I'm just trying to unrot my program.
21:21:39 <roconnor> there we go
21:22:24 <roconnor> I replace readFile fn with openFile fn ReadMode >>= \h -> hSetEncoding h latin1 >> hGetContents h
21:25:30 <roconnor> edwardk: I finally finished by blog post on *-semirings: http://r6.ca/blog/20110808T035622Z.html
21:32:21 <edwardk> bookmarked
21:32:43 <edwardk> been playing with trifecta, rewrote the rendering core, seeing if i like it
21:33:49 <roconnor> a trifecta is a parimutuel bet in which the bettor must predict which horses will finish first, second, and third in exact order.
21:34:52 <kmc> a package of binary swap options!
21:34:54 <kmc> maybe.
21:34:57 <kmc> was there some reason to avoid realToFrac?
21:35:34 <kmc> i have hazy recollections of some "realToFrac considered harmful" rant but i don't remember details
21:35:42 <kmc> edwardk, what's the elevator pitch for your library? :)
21:35:45 <roconnor> @type realToFrac
21:35:46 <edwardk> bah, introduced a new rendering bug
21:35:46 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
21:36:03 <roconnor> kmc: I'm not aware of any reason not to use it.
21:36:03 <edwardk> kmc: parsers with built-in clang style diagnostics
21:36:23 <shachaf> @src realToFrac
21:36:23 <lambdabot> realToFrac = fromRational . toRational
21:36:39 <shachaf> Doesn't *seem* very harmful.
21:36:49 <edwardk> kmc: succinct enough?
21:37:31 <edwardk> they make it very easy to capture the text of the line you're on, between two cursors, to emit diagnostics with carets and spans and fixits, etc.
21:38:42 <kmc> sweet
21:38:50 <kmc> so i can print out like
21:38:55 <kmc> ^-------- here is where you fucked up
21:39:14 <edwardk> exactly
21:39:16 <kmc> nice
21:39:24 * kmc hasn't used clang
21:39:43 <edwardk> and there will soon be a built in c preprocessor if you want to factor out that concern
21:39:49 <kmc> cool
21:40:55 <edwardk> the ropes it uses to track source code already support the 'virtual' line directive chunks
21:41:08 <Cale> kmc: realToFrac can be obscenely expensive in some cases where it's really doing nothing at all.
21:41:11 <edwardk> so its just a matter of porting one of my old scanners
21:41:27 <Cale> (i.e. where an unsafeCoerce would work)
21:41:32 <kmc> newtypes?
21:41:32 <kmc> ah
21:42:06 <edwardk> http://clang.llvm.org/diagnostics.html gives a pretty good short overview
21:42:13 <JuanDaugherty> edwardk, are you talking about a c preprocessor in clang or what?
21:42:35 <edwardk> JuanDaugherty: nah, im talking about one to generate the path fragments i need in trifecta
21:42:46 <JuanDaugherty> ah
21:43:11 <edwardk> basically i assume any handling of line directives has already been done by whatever is handing me bytestring fragments
21:43:27 <JuanDaugherty> which I take it some kina graphics engine
21:43:30 <JuanDaugherty> *is
21:43:47 <edwardk> nah, trifecta = parser
21:43:55 <edwardk> the rendering stuff is about rendering diagnostics
21:44:12 <edwardk> clipping the line to fit in the terminal, using colors for the ^—'s etc.
21:47:50 <kmc> man i wish GHC had diagnostics like this
21:47:57 <kmc> expected type Foo because of --------------^^^^
21:48:06 <kmc> inferred type Bar because of ------^^^^
21:48:30 <edwardk> kmc: that is exactly why i'm writing this =)
21:48:34 <kmc> aha!
21:48:38 <kmc> you can track a history of assumptions for every unification variable, right?
21:48:41 <copumpkin> kmc: say you had to unify [a] with f Int and b
21:48:44 <edwardk> yep
21:48:53 <kmc> for any expected type you can explain why you expected it, in proof format
21:49:00 <edwardk> =)
21:49:02 <kmc> :D
21:49:05 <kmc> godspeed edwardk
21:49:21 <kmc> is it going in GHC, or in some other diagnostic tool?
21:49:24 <edwardk> i have a toy hmf implementation we are using to test stuff out at work
21:49:34 <edwardk> so i wanted to play with this as a means to express diagnostics for it
21:49:43 <kmc> hmf? hindly-milner-f?
21:49:58 <edwardk> and i had already had something similar lying around in an earlier kata mockup
21:50:05 <edwardk> so i started pulling everything together
21:50:16 <edwardk> since before i had handled all the localization of error messages, etc.
21:50:27 <edwardk> i thought it'd be nice to start pulling this stuff into a general framework folks can use
21:51:00 <edwardk> http://research.microsoft.com/apps/pubs/default.aspx?id=132621
21:51:30 <kmc> cool
21:51:39 <edwardk> i render the diagnostics through a pretty printer, so i can use nesting levels to show sub-derivations, etc.
21:51:40 <kmc> "first-class polymorphism" meaning?
21:51:52 <kmc> you can tell me to RTFP btw
21:51:58 <edwardk> you can define rank n types, but infer normally like haskell
21:52:17 <kmc> what's the catch?
21:52:30 <JuanDaugherty> HSK1 , does your nick refer to the lanuage exam?
21:52:34 <edwardk> the main difference from haskell's type inference is that his later inference algorithms handle not only runST $ foo   but also let you use flip ($) foo runST
21:52:37 <edwardk> which ghc doesn't
21:52:40 <JuanDaugherty> *language
21:52:53 <edwardk> it doesn't play nicely with things like equality constraints which destroy principal types
21:53:59 <HSKl> JuanDaugherty no
21:54:14 <JuanDaugherty> ah
21:56:48 <edwardk> found my rendering bug
22:02:43 <edwardk> i need to add a more general skeleton for talking about multiple notes attached to an error and for providing a generic framework for turning warnings into errors, squelching certain classes, etc.
22:05:40 <_owen> is this channel active?
22:06:00 <edwardk> nope
22:06:04 <_owen> that's a shame
22:06:06 <edwardk> 700 people just chillin
22:06:34 * djahandarie chills
22:07:09 <RayNbow`TU> this channel's active-on-demand :p
22:07:20 <djahandarie> More like explode-on-demand
22:07:49 <__o> test
22:07:57 <djahandarie> > "success"
22:07:57 <lambdabot>   "success"
22:08:32 <kfish> that was chill
22:08:57 <djahandarie> Yeah man
22:09:02 <edwardk> hrmm, can i get another set of eyeballs for a minute?
22:09:15 <djahandarie> Human eyeballs? Probably not legally
22:09:38 <shachaf> I hear there's a pretty big human-eyeball black market in IRC.
22:09:40 <edwardk> they can still be in the cadaver
22:09:47 <djahandarie> shachaf, using bitcoins?
22:10:00 <shachaf> djahandarie: Probably. It's the sort of thing people like copumpkin would be into.
22:10:06 <djahandarie> I knew it.
22:10:27 <djahandarie> edwardk, yes, btw, assuming I'm of any help here :p
22:10:54 <edwardk> https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Render.hs#L51 line 51 − 54 should be putting '<'s and '>'s when i try to print something out of the current 'window'
22:11:20 <__o> anyone know of any good haskell books?
22:11:42 <fengshaun> __o: real world haskell and learn you a haskell
22:11:48 <edwardk> @hpaste
22:11:49 <lambdabot> Haskell pastebin: http://hpaste.org/
22:11:57 <fengshaun> both great.  I would start with learn you a haskell, though!
22:12:12 <fengshaun> __o: realworldhaskell.com and learnyouahaskell.com
22:12:14 * hackagebot trifecta 0.7 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.7 (EdwardKmett)
22:12:16 * hackagebot repa 2.1.1.3 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.1.1.3 (BenLippmeier)
22:12:18 <hpaste> “no < 's” pasted “edwardk” at http://hpaste.org/49967
22:12:36 <edwardk> but as seen in that hpaste i don't get the < even though its clipping the line
22:13:06 <edwardk> its late and i just want to be done with this part and back to working on something interesting
22:13:10 <edwardk> anything obvious?
22:14:49 <edwardk> you can cabal install trifecta and run that line from the hpaste directly
22:15:24 <djahandarie> Does anything change when you flip the order of lt and gt? Just shooting in the dark though, can't parse what the hell's going on here
22:15:33 * djahandarie tries actually using it
22:15:44 <fragamus> I have been struggling to get my monad stack together and I finally have it. I am just getting to the point where I can start to play with it.
22:16:26 <edwardk> basically its taking an array and 'redrawing some of the elements'
22:17:20 <edwardk> it is building up a list of elements to change, then substituting those that fall in the range of the array directly
22:17:40 <edwardk> then it is checking for any that fall out of range, and substituting for the min and max element with < or > respectively
22:19:10 <edwardk> hrm i appear to have introduced a bug in the window calculation as well =/
22:19:37 * djahandarie feels like he's installing all of hackage
22:19:48 <edwardk> sorry =)
22:19:59 <edwardk> i built this one for me, so it sits on a lot of stuff
22:20:56 <fragamus> did Cale end up making RandT an instance of MonadPlus?
22:22:03 <ddarius> edwardk: Throwing in a trace produces all the bounds you'd expect.  Particularly the n, lo, hi values.
22:22:20 * djahandarie is still cabal installing -_-
22:23:06 <ddarius> er that was a question.
22:23:32 <ddarius> edwardk: Or rather, if you call draw directly, does it work?
22:24:02 <edwardk> ddarius: was pursuing another path, haven't tried
22:24:08 <djahandarie> Oh great, and all I got at the end of this was a bunch of packages failing to install
22:24:13 <__o> fengshaun, i may have to put my dignity aside and order 'learn you a haskell'
22:24:41 <djahandarie> Screw this, I'm isolating this function
22:24:52 <Cale> fragamus: I'm not the maintainer of that package.
22:24:55 <ddarius> At any rate, assuming the values are reasonable, though I'm not sure what 'n' should be, it looks like that part is right.
22:25:14 <Cale> fragamus: I originally wrote the code and stuck it on the Haskell Wiki, and other people made a package from it.
22:25:18 <edwardk> it draws the < and >'s on the caret line fine
22:25:27 <edwardk> but it doesn't seem to use them on the main line
22:25:28 <ddarius> __o: You can just read it online.
22:25:38 <Cale> You could always make it an instance of MonadPlus yourself, you know ;)
22:25:40 <__o> i find it hard to read things on the computer
22:25:47 <Cale> (just re-upload new version to hackage :)
22:25:57 <edwardk> n is the position you want to start scribbling text
22:26:00 <ddarius> __o: Buy a ream of paper.
22:26:47 <edwardk> cale: so you want him to just upload an upgraded package?
22:26:59 <Cale> I don't care :)
22:27:02 <edwardk> k
22:27:18 <ddarius> edwardk: In Caret (Columns 80 3) what does the 80 and 3 mean?  I have an idea, but you should know.
22:27:45 <edwardk> i'm a moron. i found it
22:27:47 <Cale> Did someone write my name in the Maintainer field again?
22:27:59 <edwardk> the 80 is the number of characters and 3 is the number of bytes
22:28:06 <edwardk> obviously i'm lying about the latter
22:28:13 <edwardk> because this part of the parser doesn't care
22:28:25 * kmc chills
22:28:28 <Cale> Ah, I'm just listed as an author. I guess you might want to get in touch with Eric Kidd...
22:28:42 <edwardk> the problem was the Source instance for String
22:28:43 <djahandarie> kmc, a little late
22:28:46 <edwardk> it used /// directly
22:29:02 <ddarius> That would do it.
22:29:49 <djahandarie> Looks like I'm not needed here any longer. *woosh*
22:30:14 <edwardk> rather than calling draw
22:30:14 <edwardk> djahandarie: it isn't that complicated. it just draws 3 lines of text
22:31:02 <edwardk> sweet now i get the bolded <'s on either side when i have a caret in the middle of a very long line
22:31:28 <ddarius> edwardk: You could just have long lines of text be a parse error.
22:31:35 <edwardk> hah
22:31:38 <edwardk> @hpaste
22:31:38 <lambdabot> Haskell pastebin: http://hpaste.org/
22:32:23 <hpaste> edwardk annotated “edwardk” with “edwardk (annotation)” at http://hpaste.org/49967#a49968
22:32:42 <edwardk> it works spans pretty print as well, as do fixits
22:33:43 <edwardk> ddarius: the rendering will actual fit to your terminal width, so that would be tricky ;)
22:34:09 <edwardk> er s/actual/actually
22:37:13 <edwardk> overall the diagnostics code there fits in a reasonably small amount of space and is pleasant to look at
22:37:14 * hackagebot trifecta 0.7.1 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.7.1 (EdwardKmett)
22:37:46 <edwardk> and it can do things clang can't, which amuses me
22:37:54 <edwardk> of course, they have a whole framework
22:40:28 <edwardk> and its nicely functional, so you can build up composite fixits, with things like addFixit lo hi replacementText $ addSpan s e $ surface s bs
22:49:03 <jocom> What is the categorical equivalent of Applicative?
22:50:20 <ddarius> Strong lax monoidal functors.
22:50:46 <jocom> Ok, thanks!
22:52:06 <kmc> burritos
23:06:17 <fengshaun> __o: well, by ordering learn you a haskell, you are supporting the author, so that's a good thing.  And I'm currently reading it too, and I can say it's an awesome book!
23:07:13 * hackagebot case-insensitive 0.3.0.1 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-0.3.0.1 (BasVanDijk)
23:12:15 * hackagebot trifecta 0.7.2 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.7.2 (EdwardKmett)
23:25:19 <methods> anyone remember that quote that says it's not worth it to learn a new language unless it makes you think completely different ?
23:27:28 <Nisstyre> methods: Knuth maybe?
23:27:38 <methods> na i think it was alan perlis
23:27:54 <methods> "A language that doesn't affect the way you think about programming, is not worth knowing." (Alan Perlis)
23:43:33 <kmc> it's not really true
23:43:37 <kmc> but a nice thought
23:44:24 <methods> everything has a truth meter :]
23:44:31 <methods> so it is true but also not true
23:44:35 <edwardk> @pl (\d -> l d . l' d)
23:44:35 <lambdabot> liftM2 (.) l l'
23:54:12 <drbean> /sb/sb home
