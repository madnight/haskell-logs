00:05:50 <luite> are there packages on hackage that don't have monotonically increasing version numbers?
00:16:35 <cheater_> :t id
00:16:36 <lambdabot> forall a. a -> a
00:17:17 * hackagebot GenericPretty 1.1.3 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-1.1.3 (RazvanRanca)
00:18:32 <mux>                 archive $builddir/delivery/$pkgname-$version-*.rpm || true
00:52:18 <_KY_> Can I define a data type with variable number of arguments?
00:53:14 <Axman6> ehat do you mean, can you give an example?
00:53:17 <Axman6> what*
00:53:42 <Axman6> you can have data Foo a b c = One a | Two a b | Three a b c
00:54:40 <_KY_> Well... I want a data type
00:54:52 <_KY_> f x1 x2 x3... xn
00:55:07 <_KY_> Like a function with n arguments
00:55:19 <shachaf> Can you give more context?
00:55:36 <_KY_> Say, a function with n integers as arguments
00:55:39 <bidigo> Hi there. I'm having problems converting from ByteString SqlValues with HDBC and Sqlite3
00:56:08 <kmc> f :: [Int] -> Whatever
00:56:21 <bidigo> HDBC links with convertible, which aparently doesn't have instances for ByteString conversion
00:56:28 <_KY_> Yes, but I want to make it a "data" thing
00:56:57 <shachaf> data Foo = Foo [Int]
00:57:24 <Axman6> _KY_: you're not being very clear
00:57:27 <_KY_> But can I replace Int with a type variable a?
00:57:33 <kmc> yes
00:57:39 <kmc> length :: [a] -> Int
00:57:40 <_KY_> I tried that , but it gave an error
00:58:00 <_KY_> data Apply f [x] = MkApplication f [x]
00:58:15 <Axman6> no
00:58:16 <shachaf> _KY_: Why do you have [x] on the left side?
00:58:24 <_KY_> Oh...
00:58:26 <Axman6> data Apply f a = App f [a]
00:58:37 <_KY_> I see=)
00:58:38 <shachaf> The type argument could just be x, and the value can be a list of them.
00:58:42 <Axman6> _KY_: i still don't understand what you're trying to do though
01:00:49 <ski> @tell roconnor It seems unfortunate to have `mapChildrenM' require both `Applicative' and `Monad' when only `Monad' ought to be needed. I think you could have it require only `Monad' if you define `newtype MonadToApplicative m a = MTA (m a)' with `instance Monad m => Applicative (MonadToApplicative m)' and use `applyNaturalTransform' to switch forward and back.
01:00:49 <lambdabot> Consider it noted.
01:01:13 <ski> @tell roconnor Presumably this would apply to `evalFamilyM' as well. Why `M' in `alwaysM', it's requiring `Functor', not `Monad ? One could possibly rename `multiplate' to `mapChildrenA'
01:01:13 <_KY_> Axman6 I'm trying to represent logic formulas
01:01:13 <lambdabot> Consider it noted.
01:02:18 <Axman6> _KY_: i don't see how that type would be used in logic :\
01:04:02 <Axman6> also, if it's anything like Lambda Calculus, you only need an Application data type, like data Logic = ... | App Logic Logic | ..., and you can use that to apply f to as many arguments as you like, by using App (App (Func 'f') (Sym 'a')) (Sym 'b'), which tranlates into f a b, or ((f a) b)
01:04:57 <_KY_> Oh is that currying?
01:05:29 <shachaf> _KY_: No, currying is transforming a function of type (x,y) -> z to a function of type x -> (y -> z).
01:05:53 <_KY_> That's what he did...
01:06:11 <shachaf> Oh, well, sure.
01:06:24 <_KY_> (f a b) is transformed to ((f a) b)
01:06:37 <shachaf> No, f (a,b) is tranformed to ((f a) b).
01:06:47 <shachaf> But *representing* a function as a function that takes an argument and returns another function isn't currying.
01:07:19 <ski> > uncurry f (a,b) :: Expr
01:07:20 <lambdabot>   f a b
01:07:20 <_KY_> Ok..
01:07:33 <_KY_> Axman6: then how can I represent lambda terms?
01:07:42 <shachaf> Is there a way to tell GHC where to look for modules? I have src/Main.hs importing src/Foo/Bar.hs with "import Foo.Bar", but I don't want to have to cd to src/
01:19:06 <hvr> shachaf: '-i'
01:19:21 <hvr> Finding imports -idir1:dir2:...  -i
01:19:56 <shachaf> hvr: I tried that, but runghc src/Main -- -i src/ doesn't seem to work.
01:20:19 <hvr> shachaf: have you tried w/o the space?
01:20:25 <shachaf> Yes.
01:20:25 <hvr> i.e. "-isrc"
01:21:01 <hvr> strange... worked for me so far
01:21:20 <hvr> oh
01:21:38 <hvr> you put the '-i' after the '--'
01:21:50 <hvr> then it most likely won't be interpreted as an option but as an argument
01:22:15 <hvr> try 'runghc -isrc  src/Main.hs' instead
01:22:33 <shachaf> Oh.
01:22:40 <shachaf> There, that worked. I thought -- was for passing arguments to GHC.
01:22:52 <shachaf> And earlier when I tried that, it was without the space. Sigh.
01:23:37 <mux> -- is a UNIX convention to indicate the end of option arguments, it is enforced automatically if the application uses getopt()
01:25:13 <shachaf> mux: Right. It seemed like a reasonable convention for passing arguments to GHC instead of runghc when I skimmed the man page.
01:25:38 <kosmikus> is there a CamHac channel?
01:32:03 <zenzike> there is now :-) join #camhac
01:35:40 <ski> _KY_ : you could use `data Term = ... | Lambda Ident Term', or possibly a de-Bruijn representation
01:36:20 <_KY_> ski: I'm just using Lambda [Term] Term
01:36:35 <ski> huh, why `[Term]' there ?
01:36:54 <_KY_> [Term] is the list of bound variables for that lambda term
01:37:25 <ski> do you handle terms like `Lambda [Lambda [] ...] ...', then ?
01:37:39 <_KY_> Oh I see...
01:37:44 <ski> otherwise i'd do `[Ident]' instead of `[Term]', there
01:37:44 <_KY_> I don't use the nested form
01:38:35 <_KY_> My format is Lambda id1 id2 . term
01:39:29 <shachaf> _KY_: Are those multi-argument lambdas?
01:40:33 <jaspervdj> Is there a dedicated CamHac IRC channel?
01:40:49 <_KY_> shachaf: yeah
01:41:10 <shachaf> jaspervdj: 08:53 < kosmikus> is there a CamHac channel? 08:59 < zenzike> there is now :-) join #camhac
01:41:14 <shachaf> (Just before you joined.)
01:41:23 <jaspervdj> Thanks!
01:41:33 <_KY_> What's CamHac? =)
01:50:25 <mm_freak_> i believe it means Cambridge Hackathon
01:50:43 <mm_freak_> i wonder when the next hackathon will be in germany…  last time i couldn't make it
01:50:51 <mm_freak_> even though it wasn't far away
01:52:17 * hackagebot tagsoup 0.12.3 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.12.3 (NeilMitchell)
01:53:34 <mm_freak_> who is in charge of the hackage server?
01:53:38 <mm_freak_> i have a question
01:54:50 <Heffalump> mm_freak_: try [4~dcoutts_
01:55:16 <mm_freak_> thanks
01:55:32 <mm_freak_> dcoutts: may i /query you?
01:55:41 <mm_freak_> (assuming you are in charge of the hackage server)
02:04:31 <dcoutts__> Heffalump: who was asking?
02:04:34 <Heffalump> mm_freak_
02:04:39 <dcoutts__> ta
02:05:50 <aki> morning
02:07:18 * hackagebot derive 2.5.3 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.3 (NeilMitchell)
02:12:18 * hackagebot trifecta 0.24 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.24 (EdwardKmett)
02:17:49 <Leftmost> I'm reading through Learn You a Haskell and I've come across something confusing. At http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo when discussing the Tofu type class, the tofu function is defined as tofu x = Frank x
02:18:40 <Leftmost> How does the Frank constructor work in that instance?
02:19:21 <edwardk> the 'Frank' constructor has type :: b a -> Frank a b
02:19:43 <edwardk> you can go one further and change the definition down to tofu = Frank
02:19:45 <mm_freak_> second try
02:19:48 <Leftmost> Previously he always uses the Frank {frankField = Just "HAHA"} syntax. Does that mean it's legitimate to leave out the {frankField ... syntax?
02:19:55 <mm_freak_> dcoutts__: may i /query you?
02:20:02 <edwardk> Leftmost yes
02:20:11 <edwardk> record syntax is mostly sugar
02:20:35 <edwardk> data Foo = Foo { runFoo :: Int } -- then you can write Foo { runFoo = 12 }  or Foo 12
02:20:40 <edwardk> and they are interchangeable
02:20:40 <dcoutts__> mm_freak_: what was your question?
02:20:45 <Leftmost> Alright, thank you.
02:21:18 <mm_freak_> dcoutts__: it's about the hackage server, and it has been suggested to me to contact you about it
02:21:28 <Leftmost> Prior to this he's always used record syntax when using the constructors if he's defined them with record syntax, and makes no mention of being able to do that,
02:21:28 <edwardk> the main use of the record syntax is it allows you to copy a structure and only swap out some subset of the fields without mentioning ALL of the arguments
02:22:02 <dcoutts__> mm_freak_: ah ok, ask away
02:22:19 <edwardk> the record syntax basically defines the constructor and functions that access the individual fields (and gives access to the record sugar)
02:22:21 <mm_freak_> even though i haven't used it, i seem to like fclabels
02:22:40 <Leftmost> I'm not sure I follow, edwardk. Swap out some subset of the fields without mentioning all of the arguments?
02:23:18 <edwardk> data Foo = Foo { x, y, z :: Int }    ; foo = Foo 1 2 3 ; bar = foo { z = 4 }
02:24:01 <edwardk> defines a data type, with 3 fields, all Ints. foo is defined as you'd expect, and bar has all the same values as foo except z = 4
02:24:56 <Leftmost> Ahh, okay. That makes sense.
02:24:57 <Leftmost> Thanks again.
02:24:58 <edwardk> saying 'Foo { x = 12, y = 13, z = 10 }' is saying 'start with a Foo where all the fields are undefined' and substitute in for each field (all of the substitution happens at once, so there is no efficiency concern)
02:25:47 <Itkovian> Leftmost: a side effect of this is that you should make sure that record names are unique, as they also form functions within your module.
02:26:11 <edwardk> s/record name/field name/?
02:27:10 <Itkovian> edwardk: yeah, sorry
02:27:18 * hackagebot dimensional 0.10.1 - Statically checked physical dimensions.  http://hackage.haskell.org/package/dimensional-0.10.1 (BjornBuckwalter)
02:36:11 <increpare> Just checking: There's no graph isomorphism / graph canonical form/label stuff anywhere on hackage that I'm missing out on is there?
02:36:27 <copumpkin> chrisdone: so, when you're chrisdoner, does that mean you're a kebab?
02:36:40 <edwardk> increpare: not that i know of. i never needed it so i didn't add it to my graph library
02:36:42 <copumpkin> increpare: I haven't come across it, but hackage is an experience
02:36:44 <copumpkin> ohai edwardk
02:36:48 <edwardk> heya
02:37:03 <chrisdone> copumpkin: it means i'm professionally chrisdoning
02:37:11 <copumpkin> edwardk: still awake or awake early?
02:37:29 <benmachine> chrisdone: chrisdoing, surely
02:37:32 <edwardk> couldn't sleep, got back up
02:37:35 <chrisdone> lol
02:37:44 <copumpkin> chriswinning!
02:37:47 <increpare> copumpkin: Ok.  That puts my mind at rest.  Guess that's my first task for this hackathon then : )
02:38:06 <copumpkin> increpare: oh nice, but please don't build off of fgl :P
02:38:21 <copumpkin> I'd be interested in seeing it
02:38:29 <edwardk> i may wander back to sleep and come in after the FP session
02:38:31 <copumpkin> increpare: you know anything about the hypergraph form of that problem, by the way?
02:38:37 <copumpkin> edwardk: there is no FP session today!
02:40:29 <increpare> copumpkin: what library should I build off?
02:40:32 <increpare> copumpkin: not yet : P
02:40:39 <copumpkin> increpare: I don't know :P maybe edwardk's graph library
02:40:45 <edwardk> this inability to build the haddocks on hackage because of everybody having low base caps is getting old fast
02:41:06 <edwardk> graphs is pretty simple
02:41:11 <copumpkin> "isomorphism of hypergraphs of low rank in moderately exponential time" :(
02:41:34 <ski> (heh, that's what i call inference : i type "lo", and it inferred the whole "loop (False : bs) l" subexpression :)
02:41:47 <copumpkin> ski: by the way, you need to write moar agda
02:42:05 <ski> heh, this was actually Agda1 in Alfa :)
02:42:09 <increpare> copumpkin: http://hackage.haskell.org/packages/archive/hgal/1.0.2/doc/html/src/Data-Graph-Automorphism.html i spoke too soon
02:42:11 <copumpkin> yeah, get with the times
02:42:18 * ski likes the instant inference
02:42:29 <copumpkin> increpare: ooh!
02:42:44 <increpare> doesn't come up under any seachers, don't know how I found it :S
02:43:05 <copumpkin> increpare: can't help you there
02:43:25 <increpare> copumpkin: Have you been working on anything cool recently?
02:44:03 <copumpkin> increpare: mostly boring (to everyone but me) agda proofs and implementing some financial stuff to learn more about it
02:44:10 <copumpkin> nothing of interest to the outside world :)
02:44:13 <increpare> :) cool
02:44:37 <copumpkin> you at camhac?
02:45:28 <increpare> yeah
02:46:12 <increpare> trying to do implement a frequent subgraph algorithm
02:46:31 <increpare> ah sentence formation not working
02:46:34 <copumpkin> ah, neat
02:46:43 <copumpkin> I needed that a while ago
02:47:14 <copumpkin> but anyway, you should build on edwardk's graph library :) then you can work on huge graphs that don't fit in memory
02:47:30 <edwardk> =)
02:47:32 <copumpkin> not sure how usable it is for writing general graph algorithms though!
02:47:40 <increpare> heh
02:47:42 <copumpkin> or if it has any documentation :(
02:47:45 <increpare> graph libraries in haskell are all a bit strange
02:48:03 <edwardk> it is mostly focused on reading graphs and performing traversals, it doesn't really have any mutation capability
02:49:17 <copumpkin> well, if he's mining frequent subgraphs, that's not bad, although presumably he'd want to construct those frequent subgraphs to return them at some point :)
02:49:44 <edwardk> yeah, that will be tricky to do in fully general form
02:50:03 <edwardk> you can probably build the adjacency list or matrix and give that back easily enough though
03:02:29 <Guest41719> What are the differences between the packages mtl and transformers?
03:02:46 <Guest41719> is transformers newer?
03:02:59 <shachaf> Guest41719: http://stackoverflow.com/questions/2769487/mtl-transformers-monads-fd-monadlib-and-the-paradox-of-choice
03:03:13 <Axman6> they used to basically be competing packages, but now mtl uses transformers
03:04:46 <Guest41719> but all of them are based on the same paper (mtl is based on a paper from 1995)
03:04:49 <Guest41719> ?
03:13:31 <Guest41719> OK. Suppose I have a monad m, and transform it to a new monad n. I can then use 'lift' to "access" the old monad m. Which signature should a function have, with input "transformed from m"-monads? Is there a typeclass for that?
03:14:38 <alpounet> Guest41719, not sure of what you mean. Can you give us your concrete case ?
03:15:39 <zygoloid> Guest41719: usually you create a typeclass MonadM for your monad M, and create instances of that for M and for transformed M
03:17:11 <harlekin> Is there a tutorial which covers extending a happstack module or which deals with the Dependencies type in an other way than just setting it to End?
03:17:40 <harlekin> I am planning to extend happstack-auth and the way I've done it I run into some problems most likely because I don't understand Dependencies in MACID.
03:18:23 <Guest41719> alpounet: By transforming the monad IO, we get new monads M. We can write a generalized putStrLn: putStrLn' = liftIO . putStrLn
03:18:44 <Guest41719> putStrLn' :: MonadIO m => String -> m ()
03:19:02 <alpounet> yeah
03:19:52 <Guest41719> I want to write signatures like: function :: MonadMyMonad m => ...
03:21:08 <Guest41719> I somewhat need to tell the function, by writing signature, that we can use lift on the monad, to get MyMonad.
03:21:36 <shachaf> IO is a bit of a special case because it's always at the bottom of a transformer stack.
03:22:13 <shachaf> But look at the code for transformers and/or monads-{tf,fd} and/or mtl-something.
03:22:36 <Cale> Well, any monad is always at the bottom of a transformer stack
03:23:47 <shachaf> I suppose so.
03:24:25 <shachaf> Actually, the reason liftIO doesn't exist for the transformer monads is just that their primitives are already generalized, I guess.
03:24:30 <Guest41719> shachaf: MonadIO is a typeclass. Transformers makes MonadIO instances if old monad is MonadIO. That is the way it works.
03:24:42 <Cale> FLIP ┻━┻﻿ ︵╰(°□°)╯︵ ┻━┻﻿ TABLES
03:24:44 <shachaf> Right, I know how it works.
03:24:48 <shachaf> Cale++
03:25:00 <shachaf> Was that in reaction to something?
03:25:13 <Cale> Heh, not really.
03:25:15 <shachaf> Or just general flippancy?
03:26:16 <increpare> Cale: you should be able to define a╰(°□°)╯ function right?
03:26:31 <shachaf> increpare: With parentheses?
03:26:35 <increpare> might have to find different parentheses
03:26:43 <increpare> yeah
03:27:00 <Guest41719> but I know how I can solve my problem, since I actually use StateT. I was wondering how the signature would look, in a general case, ie, if StateT was newtype'd.
03:27:20 <shachaf> @ty (╰﴾°□°﴿╯)
03:27:21 <lambdabot> parse error (possibly incorrect indentation)
03:27:21 <shachaf> Hmph.
03:27:26 <Cale> In general I recommend against StateT transforming IO.
03:27:43 <Guest41719> Cale: why
03:28:03 <Cale> It almost always ends up being less elegant than simple parameter passing and making good use of the features already in IO.
03:28:15 <Guest41719> Cale: not in my case.
03:28:27 <Cale> What are you doing?
03:29:02 * shachaf seems to recall that Xmonad uses StateT of ReaderT of IO, or something like that.
03:29:10 <Guest41719> remember that StateT is actually s -> m (a, s) (or something similar, just wrapping functions)
03:29:26 <Cale> I know what it is of course :)
03:29:27 <shachaf> I think Cale knows what StateT is. :-)
03:29:28 <Guest41719> Cale: I write a game
03:30:27 <Cale> I usually like splitting up an IORef into a read action and write function and passing those to whatever parts of the code need them.
03:30:51 <benmachine> IO is already statey so I suppose it's a bit like StateT s (State t)
03:31:28 <Guest41719> Cale: My whole game is based on not using IORef's!
03:31:43 <Cale> The IO monad is already capable of keeping track of unbounded amounts of state. Transforming it adds some syntactic overhead (in the form of lifts) without adding much benefit.
03:32:03 <Guest41719> I allowing IORef, I could likewise write in assembly...
03:32:11 <Cale> Guest41719: In that case, why are you allowing IO at all?
03:32:21 * hackagebot typehash 1.4.0.3 - Create a unique hash value for a type.  http://hackage.haskell.org/package/typehash-1.4.0.3 (LennartAugustsson)
03:32:46 <Guest41719> Cale: Because a purely game would be boring (no input!)
03:33:19 <Cale> Represent the entire game input, the state of the game, and the output abstractly, write a pure function describing how the game responds to input, and write a plain IO action at the top level for running the game forward.
03:33:26 <Cale> (and actually drawing stuff)
03:33:39 <hvr> Guest41719: I would have expected pure fun :-)
03:35:05 <Cale> Abstractly, the game is a pure function (GameState, Input) -> (GameState, Output) (possibly with an extra time delta parameter, depending on what sort of game it is).
03:35:13 <Guest41719> Cale: something like that was actually my first idea.
03:36:03 <Guest41719> have input/output pure
03:38:34 <Guest41719> but my game is actually pretty pure as it is.
03:40:13 <Cale> You may also be interested in looking into various FRP libraries. At IPwn, for our game, we're using an internally developed Arrow FRP library which is implemented in terms of IO, but is abstractly fairly pure (only locally-accumulated state), and basically is a system for incremental computation (invalidate things when they change, recompute invalidated things lazily when they're read)
03:41:25 <Guest41719> Cale: what is FRP and IPwn?
03:41:40 <Cale> FRP is functional reactive programming
03:42:00 <Cale> IPwn is the company I work for, we're developing a game for iPhones and other mobile devices in Haskell
03:42:51 <Cale> I guess it's actually spelled iPwn Studios, I'm just used to IPwn from the module names ;)
03:43:45 <Guest41719> Cale: Is it possible to write Haskell for iphone? I read that there was legal problems with that I think.
03:43:47 <Botje_> so you sell iPwnies?
03:43:57 <Cale> Guest41719: No legal problems
03:44:11 <_KY_> What's wrong with this code: http: ? pastebin.com/t864DLfL
03:44:18 <benmachine> Cale: how's haskell-on-android looking, ooi?
03:44:26 <_KY_> http://pastebin.com/t864DLfL
03:44:29 <mauke> The paste t864DLfL has been copied to http://hpaste.org/50220
03:44:42 <Guest41719> Cale: how did you get that job?
03:44:54 <erus`> passing round an 'Either String x' all the time is a pain. Is there a nice way todo error checking?
03:45:10 <Botje_> _KY_: you need to specify a data constructor for Atom and the first branch of Term
03:45:13 <benmachine> erus`: stop it from being a pain :)
03:45:29 <Botje_> erus`: you can use the Either e monad which does exactly that :)
03:45:33 <Cale> Guest41719: Edward Kmett pointed me in the direction of Ryan Trinkle, who is the cofounder of the company, and he hired me.
03:45:36 <erus`> i really miss C++ exceptions
03:46:08 <Botje_> erus`: good news! haskell has those too!
03:46:17 <Cale> benmachine: I'm not certain. kmc did some work on it, iirc, but it was for 6.12.x, I believe, and we're on 7.0.3/7.0.4
03:46:23 <alpounet> @type catch
03:46:23 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
03:46:24 <benmachine> ah ok
03:46:41 <benmachine> @type Control.Exception.catch
03:46:42 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> (e -> IO a) -> IO a
03:46:56 <mux> Botje_: I read that in a Hubert Farnsworth voice :-)
03:47:00 <Cale> benmachine: However, we're working on getting a general cross-compiling framework put into GHC.
03:47:01 <erus`> so i just make everything an IO function?
03:47:12 <Axman6> erus`: haskell has a very powerful exceptions system
03:47:30 <Axman6> erus`: no, not at all
03:47:36 <Axman6> @hoogle throw
03:47:37 <lambdabot> Control.Exception throw :: Exception e => e -> a
03:47:37 <lambdabot> Control.OldException throw :: Exception e => e -> a
03:47:37 <lambdabot> Control.Exception.Base throw :: Exception e => e -> a
03:47:47 <benmachine> Cale: ah, awesome :)
03:47:51 <Botje_> mux: :)
03:48:24 <Cale> Or, I guess it's being called "toolchain mode", since cross-compiling already is used to mean something else in GHC's context. :)
03:48:40 <erus`> let a 1 = 2; a 2 = throw "nope lol!" in a 2
03:48:45 <erus`> > let a 1 = 2; a 2 = throw "nope lol!" in a 2
03:48:46 <lambdabot>   Not in scope: `throw'
03:49:04 <Cale> > let a 1 = Right 2; a 2 = Left "nope lol!" in a 2
03:49:04 <_KY_> Botje_: but then every time I create a term I need to invoke nested constructors ?
03:49:05 <lambdabot>   Left "nope lol!"
03:49:07 <Cale> > let a 1 = Right 2; a 2 = Left "nope lol!" in a 1
03:49:08 <lambdabot>   Right 2
03:49:09 <benmachine> on a completely unrelated note, it looks like netinet/in.h defines a global const struct, the FFI won't let me map that to a haskell name directly, will it?
03:49:11 <Botje_> _KY_: yes.
03:49:14 <benmachine> I'll need a "getter"
03:49:38 <_KY_> Botje_: that looks very clumsy
03:49:41 <erus`> Cale: thats how i do it at the moment but it gets messy fast
03:50:15 <Botje_> _KY_: why not inline Var and Const?
03:50:16 <Cale> erus`: It can, but there are ways of managing it and tidying up most code which uses Either/Maybe
03:50:25 <Cale> erus`: (like the Monad instances for them)
03:50:28 <Botje_> data Atom = MkVar Id | MkConst Id
03:51:00 <_KY_> Botje_: but in the definition of Term, Var and Const are used differently
03:51:22 <Axman6> erus`: working with Either should not be messy at all. the Either monad takes care of all the difficulties of using Either for error handling/reporting
03:51:42 <_KY_> Botje_: I mean in the definition of Term, I need to use both Var and Atom
03:52:30 <Guest41719> Cale: How have you learned game programming? The reason I am programming at all, is because of game programming. But I have never read any good analysis of a computer game, so I have mainly done it myself, learning by doing.
03:52:30 <Botje_> _KY_: okay, so do data Term = MkVar Id | MkConst Id | ...
03:53:22 <_KY_> But then I don't have "Atom" defined, right?
03:54:42 <Cale> Guest41719: I guess I haven't really studied game programming specifically. I've just been programming in general for a long time. I started learning Haskell about 10 years ago, and had been programming since I was a kid, about 9 years before that.
03:55:16 <Cale> Learning by doing is a good way. There's always lots of stuff to read as well though.
03:55:44 <Botje_> _KY_: well, no
03:56:00 <Cale> For FRP stuff, there's Conal's blog and papers, and the various papers about Yampa and other FRP systems.
03:56:17 <Botje_> _KY_: what was wrong with my Atom = MkVar | MkConst proposal?
03:56:59 <Cale> There are a few things I should probably learn more about given that I'm working on a game. More knowledge of OpenGL would be really helpful right now.
03:57:18 <_KY_> Botje_: seems that I need to have all 3 levels defined
03:57:35 <Guest41719> Cale: I have never found any good game programming resource. the resources I have seen are typically only fragments of techniques.
03:57:53 <Botje_> _KY_: then you need to add all the data constructors.
03:58:39 <_KY_> Botje_: in your proposal I still need to define Var, right?
03:58:47 <Cale> Also, most things you'll find are pretty specialised to environments which don't really support functional programming all that well anyway. So we've been finding our own way forward.
04:00:10 <Cale> As a side-rant, OpenGL's design really bothers me. It's almost as if they took all the standard advice about what not to do when designing a library and made sure to do all that stuff.
04:00:20 <Guest41719> Cale: I shall try to put my game on the haskell wiki when finished. That game is just an attempt on creating a computer game.
04:00:38 <Cale> Guest41719: Cool, also you may want to put it on Hackage.
04:01:15 <Guest41719> Cale: OpenGL, do you mean the C-functions, or the state machine idea?
04:01:22 <Cale> OpenGL is so stateful that you can't even observe all of the state without changing the state.
04:01:27 <Botje_> _KY_: no, Var would be folded into Atom
04:01:38 <Botje_> 13:18 < Botje_> data Atom = MkVar Id | MkConst Id
04:01:59 <_KY_> Botje_: but can I use Var in the definition of Term, then?
04:02:38 <Cale> Guest41719: Well, the state machine idea more generally. I've only used the Haskell bindings to it, which are decently done, but the fundamental horribleness of the library design shines through. :)
04:02:48 <Botje_> no, you will have data Term = MkAtom Atom | Apply ... | Lambda ...
04:03:03 <Guest41719> Cale: OpenGL is not functional, but I like the idea of how it works. It is fun to see how it works.
04:03:40 <erus`> is there a functional intermediate language?
04:03:55 <Guest41719> Cale: But the Haskell OpenGL library is bad, I write my own helper functions for the most of it..
04:03:56 <Cale> erus`: Like core?
04:04:52 <erus`> yes :)
04:05:18 <_KY_> Botje_: but inside data Term = ... | Lambda [Var] ... I need to use Var
04:05:40 <Cale> Guest41719: GPipe looks good
04:06:03 <Botje_> _KY_: then you have to revert to your original thing, but with proper data constructors.
04:06:14 <Guest41719> Cale: OK, I have never looked at it, but I know it uses GLUT...
04:06:27 <_KY_> Botje_: oh I see...
04:07:51 <Axman6> hmm, is there a function like guard, but that lets you specify a string to pass to fail? i want something like: guard b str = if b then return () else fail str (speficically for use with the Either monad)
04:08:25 <Cale> Guest41719: It provides a GLUT interface, but it doesn't really use GLUT.
04:08:38 <Axman6> i guess what i have is a good enough function =)
04:08:46 <yitz> Axman6: catch
04:09:10 <Axman6> yitz: is that useful in the Either monad?
04:09:25 <Cale> I believe the only use of GLUT is in the newWindow function.
04:10:53 <yitz> Axman6: well yes, but no, I'm wrong, that's not what you need
04:11:03 <Axman6> thanks anyway :)
04:11:04 <yitz> @hoogle catchError
04:11:05 <lambdabot> Control.Monad.Error.Class catchError :: MonadError e m => m a -> (e -> m a) -> m a
04:13:00 <dixie> has anybody darcs binary for solaris 10/x86?
04:13:33 <yitz> Axman6: I prefer using throwError explicitly over fail. fail is just an internal kluge for supporting pattern matching syntax in do notation.
04:14:04 <yitz> @hoogle throwError
04:14:05 <lambdabot> Control.Monad.Error.Class throwError :: MonadError e m => e -> m a
04:15:12 <dixie> oops
04:15:49 <Guest20484> Cale: I soon log out, but it has been nice to talk with you. I want to do it more. I am actually registrated on freenode, but my nick was banned here on the haskell channel (unsafePerformIO), but I shall try to use the nick "telephone" or similar.
04:16:12 <Cale> Guest20484: sure, see you around!
04:16:32 <Guest20484> Cale: it seems that I also have some problems with the irc-connection (now different GuestXXX)
04:16:33 <shachaf> unsafePerformIO is banned in #haskell?
04:16:35 <shachaf> Makes sense.
04:16:54 <yitz> Guest20484: you became telephone for a few moments in the middle
04:17:01 <tab> it's allowed in #experthaskell though :P
04:17:15 <shachaf> tab: It's allowed there, but no one uses it.
04:17:35 <shachaf> And the moment you use it, you're no longer considered an expert, so you get banned.
04:17:45 <Guest20484> shachaf: :)
04:18:05 <tab> shachaf: a lots of people use it without knowing :)
04:18:19 <tab> using a simple bytestring for example
04:18:24 <tab> gah g2g
04:19:50 <yitz> oops tab just left. tab should also be banned in #haskell, it's the moral equivalent of unsafePerformIO in syntax.
04:20:15 <shachaf> tab probably realized that.
04:20:52 <shachaf> I wish Maybe and Monad didn't start with the same letter.
04:22:26 <copumpkin> Maybad
04:22:34 <copumpkin> Moanbe?
04:26:07 <Axman6> shachaf: would you prefer Gonad then? :P
04:26:33 * Axman6 suspects that's what Google would call them if they were to reinvent Haskell, ala Go >_>
04:30:48 <erus`> go is so far from haskell
04:32:22 <Cale> go is the most boring new language in a long time
04:38:25 <Axman6> indeed
04:38:33 <profmakx> The Google+ monad!
04:38:36 <profmakx> now with zero
04:38:42 <Axman6> easier threading? some type inference? whoopdeedo
04:39:40 <Botje_> profmakx: heh. you put variables in circles and they can only swap values with other variables in the circle >:)
05:05:28 <efie> http://codepad.org/MVGVu9F2 "ERROR line 4 - Instance of Num [Int] required for definition of bin2int" i don't understand what it is i am doing wrong, can anyone help me?
05:06:12 <Saizan> use : instead of ++
05:07:23 * hackagebot AC-Vector 2.3.2 - Efficient geometric vectors and transformations.  http://hackage.haskell.org/package/AC-Vector-2.3.2 (AndrewCoppin)
05:08:20 <efie> saizan: i did, (and [1]), but the same error occurs
05:08:52 <Cale> 2^l ++  calculate_weights l-1
05:09:03 <Cale> 2^l is supposed to be an Int
05:09:08 <Cale> but you're concatenating it
05:09:14 <Cale> which means that it needs to be a list
05:09:30 <Cale> also, you're subtracting 1 from calculate_weights l
05:09:45 <Cale> which means that calculate_weights l needs to be a number
05:09:59 <Cale> You probably meant to write 2^l : calculate_weights (l-1)
05:10:05 <Martty> http://codepad.org/2TTnG0Ze
05:10:18 <erus`> whats the quickest way to read "123 23" as two ints?
05:10:20 <Martty> the error was pretty cryptic
05:10:20 <efie> thank you very much :)
05:10:30 <Martty> is it 'where's fault?
05:10:42 <Cale> erus`: map read . words?
05:10:47 <kate_r> if the universe of a theory are all functions, would a first-order language allow the quantification over functions? do the arities of the functions in the universe matter?
05:11:21 <Cale> kate_r: well, a first order language will allow you to quantify over functions in that case
05:11:50 <kate_r> Cale, right. do the functions have to be of the same arity?
05:11:57 <Cale> kate_r: Also consider things standard first order set theories like ZFC, where functions are defined as just being specific sets
05:12:47 <Cale> kate_r: Well, if everything is a function, the types of the functions involved become strange :)
05:13:15 <Cale> kate_r: They'd have to be like lambda calculus functions in that case.
05:13:43 <Cale> (infinite arity)
05:14:55 <kate_r> Cale, from my understanding of ZFC, it's a first order theory because the universe contains only sets, thus quantification over sets is allowed in a first order language.
05:16:26 <kate_r> kate_r, since sets could be seen as predicates in first order, how come ZFC doesn't run into the problem of infinite arities?
05:17:18 <Cale> Well, you don't apply sets to other sets in ZFC
05:17:33 <Cale> Though I guess there's only the element-of relation
05:18:15 <kate_r> Cale, but there's the membership relation, so a set contains sets as elements. isn't it?
05:18:17 <Cale> The element-of relation is a relation symbol rather than a function symbol though
05:18:17 <sm> morning all
05:18:41 <Cale> While function application is a function symbol in terms of the first order language involved.
05:19:00 <Cale> ZFC doesn't have any function symbols
05:19:56 <kate_r> Cale, so how come being a relation can save it from having infinite arities/dimensions?
05:22:43 <Cale> Well, if everything is a function, and we want to be able to express the application of one function to another by making apply(-,-) a function symbol, then we're forced to accept apply(f,g) for any f and g, and that has to produce another function
05:22:56 <Cale> (because everything in our domain is "a function")
05:23:18 <kate_r> Cale, also infinite order, right? because the arguments would also have to be functions.
05:23:20 <Cale> and so no matter what, we'll always get another function, and we'll be able to apply it again
05:23:30 <Cale> yes, essentially.
05:24:01 <Cale> A first order theory about untyped lambda terms would be like that.
05:24:08 <erus`> @hoogle isAbs
05:24:09 <lambdabot> System.FilePath.Posix isAbsolute :: FilePath -> Bool
05:24:09 <lambdabot> System.FilePath.Windows isAbsolute :: FilePath -> Bool
05:24:09 <lambdabot> Network.URI isAbsoluteURI :: String -> Bool
05:24:26 <erus`> whats the easiest way to check for primes?
05:24:40 <erus`> check modulo's for every number 2..n ?
05:24:42 <Cale> The thing is that first order theories generally aren't allowed to restrict the application of their function symbols to subsets of their domains.
05:24:44 <shachaf> @ty ('\'' `elem`)
05:24:45 <lambdabot> [Char] -> Bool
05:25:10 <kate_r> Cale, because it's untyped?
05:25:13 <Cale> Yeah
05:25:13 <yitz> erus`, Cale: unfoldr $ listToMaybe . concatMap reads . tails
05:25:17 <yitz> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "123 456, and 789" :: [Int]
05:25:18 <lambdabot>   [123,456,789]
05:26:14 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
05:26:15 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:32:11 <kate_r> Cale, so with the membership relation again, the range of it is {true,false}. could a language with the universe containing just functions also be mapped to {true,false}?
05:32:12 <erus`> @hoogle notElem
05:32:12 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
05:32:13 <lambdabot> Data.ByteString notElem :: Word8 -> ByteString -> Bool
05:32:13 <lambdabot> Data.Foldable notElem :: (Foldable t, Eq a) => a -> t a -> Bool
05:33:00 <Cale> kate_r: Well... relation symbols are modelled by subsets of the Cartesian power of the domain with appropriate arity, yeah?
05:33:21 <kate_r> yeah
05:33:42 <Cale> So, if you can think of a predicate on functions that you'd rather have instead of function application, you can definitely construct a first order theory of functions on that basis...
05:34:35 <Cale> Maybe something like a ternary relation R(f,x,y) to indicate that the application of the function f to the value x has result y.
05:34:48 <Cale> and then you don't need everything to be a function anymore
05:35:03 <kate_r> ok. thanks a lot.
05:35:49 <Cale> kate_r: Or: R(f,g,h) to indicate that the composite of f and g is h
05:36:03 <Cale> (that they form a commutative triangle, in categorical terminology)
05:36:34 <Cale> which would let you stick with just functions, but have functions of different "types"
05:36:55 <Cale> You can express the compatibility of composition using something like  exists h. R(f,g,h)
05:37:06 <kate_r> Cale, but then do the arguments of f,g,h not need be functions?
05:37:31 <Cale> In fact, f,g,h don't even need to be functions, but could be arrows in an arbitrary category, and this would make sense.
05:37:38 <Cale> (or even arcs in a graph)
05:37:49 <Cale> er, with a composition defined of course :)
05:38:13 <kate_r> Cale, hmm.. are arcs not functions?
05:38:13 <Cale> We haven't said anything about identity functions yet
05:38:20 <Cale> Not quite
05:38:29 <Cale> in that they're not required to have composites
05:39:49 <Cale> So, I guess you could have axioms like  forall f. exists i. R(f,i,f), and forall f. exists i. R(i,f,f)
05:39:57 <Cale> to get the existence of identities
05:40:10 <Cale> and then we need to express the associativity of composition somehow...
05:41:23 <kate_r> Cale, basically f,g,h,i could just be viewed as generic objects, it seems.
05:42:17 <kate_r> objects that are simply related by the R relation.
05:42:27 <Cale> yeah
05:43:13 <kate_r> Cale, then why have functions in the first place? there must be disadvantages with this approach, right?
05:43:19 <Cale> forall f,g,h,u,v,w,w'. R(g,f,u) and R(g,h,v) and R(h,u,w) and R(v,f,w') => w = w'
05:43:50 <Cale> Well, what we're working towards here is a first order theory of categories...
05:44:08 <Cale> and then to make the arrows of our category work like functions, we'll need to add a lot of other things
05:44:45 <kate_r> ok. i think i get the idea..
05:44:53 <kate_r> thanks a lot!
05:46:01 <Cale> You may also like to check out "Sets for Mathematics" by Lawvere, which is an extremely biased book in its approach to the foundations of mathematics, but an interesting read nonetheless :)
05:46:51 <ciaranm> is it full of annoying discussions between people with politically correct names like his categories book?
05:48:07 <Cale> It basically approaches the philosophical problem of what a theory of sets should be from a categorical perspective, and builds up a list of axioms in terms of what a category of sets ought to have.
05:48:07 <Cale> no
05:48:07 <Cale> But it is sort of casual.
05:48:42 <ciaranm> the only 'casual' book i've liked is lyah. and i don't think that's a regular kind of casual...
05:48:49 <Cale> If you're looking for a theorem/proof/theorem/proof sort of book, it will be disappointing.
05:49:10 <ciaranm> i must be getting grumpy and old. i find the Pragmatic series to be annoyingly informal.
05:49:30 <Cale> But there's some interesting philosophical points in it about the notion of value and how our perspective coming from set theory has somewhat coloured that.
05:50:55 <ciaranm> i find it annoying how even category theory tends to regress towards "functions are sets!" when the going gets tough...
05:51:20 <Cale> Well, the category of sets is a really nice category.
05:51:43 <ciaranm> yeah, but it leads to all sorts of nonsense from a compsci perspective
05:51:44 <Cale> In that it's complete and cocomplete and has exponentials and lots of other constructions.
05:52:33 <copumpkin> is there some categorical construction on sets that expresses that a function _is_ itself a set?
05:52:36 <Cale> and the Yoneda lemma is basically all about how to steal that machinery and complete other categories in a nice way using it
05:52:47 <Cale> sure
05:52:57 <Cale> That's what exponential objects are about
05:53:02 <copumpkin> I was thinking that
05:53:20 <copumpkin> but that's talking about the set of all functions with a given codomain and domain
05:53:37 <copumpkin> which would be a set of sets, if you view a function as a set
05:54:37 <copumpkin> I'm talking about the view of a function as a relation with a designated codomain
05:55:21 <copumpkin> does that make sense?
05:55:28 <Cale> ah, right
05:55:31 <copumpkin> it seems like you'd sort of need grothendieck somehow
05:55:35 <ciaranm> do you mean the category usually known as Rel?
05:55:40 <copumpkin> since we're talking about values
05:55:46 <copumpkin> well, Rel is sort of like Set
05:56:19 <ciaranm> Rel's kinda interesting in that its arrows definitely aren't functions
05:56:37 <copumpkin> sure
05:56:53 <copumpkin> Rel is a supercategory of Set?
05:57:02 <copumpkin> or feels like it should be in some way
05:57:20 <ciaranm> yeah
05:59:05 * ciaranm is trying to come up with a convincing argument that exposing compsci undergrads to category theory would be a benefit over the "functions as sets" approach
05:59:37 <Cale> Why does it have to be over that approach, and not just alongside it? :)
06:00:17 <ciaranm> the other "arrows really aren't functions, honest!" example i've got is linear transformations, which are matrices. but there's an isomorphism between matrices and functions so it doesn't really work.
06:00:30 <Cale> preorders
06:01:02 <Cale> Every preorder induces a category with exactly one arrow x -> y when x <= y
06:02:06 <Cale> By considering the types of our programming language as DCPOs in the usual way, since every DCPO is a preorder, each type is a category.
06:02:24 * hackagebot hoogle 4.2.6 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.6 (NeilMitchell)
06:02:26 * hackagebot testpack 2.1.1 - Test Utililty Pack for HUnit and QuickCheck  http://hackage.haskell.org/package/testpack-2.1.1 (JohnGoerzen)
06:02:36 <ciaranm> mm, see, i've got to make this look like it's stuff that's suitable for people from the software engineering side of things too. the kind that come in from the elec engineering side, where their maths background is "this is how you solve a horrible integral", not "this is how you prove stuff"
06:03:10 <Cale> The functors between those categories are the monotone maps.
06:04:24 <Cale> and continuous endofunctors have fixed points which are the limit (in the categorical sense, even!) of the chain induced by iterating the function
06:05:47 <copumpkin> Cale: oh, so you can actually look at "real" limits that way? neat
06:11:56 <MorelPisum> i'm looking for a already existing function which splits a function at a mentioned element. that is, its type is: `a -> [a] -> ([a], [a])'. example: `function 3 [1..5]' would result in `([1,2],[4,5])'. -- any ideas?
06:12:13 <Botje_> MorelPisum: look at Data.List.Split
06:17:19 <MorelPisum> Botje_: thx
06:19:32 <MorelPisum> Botje_: i can find that module on http://www.haskell.org/ghc/docs/latest/html/libraries/index.html .. why?
06:20:39 <MorelPisum> but it
06:20:48 <MorelPisum> .. is mentioned here: http://hackage.haskell.org/packages/archive/split/0.1.4.1/doc/html/Data-List-Split.html
06:20:59 * MorelPisum is confused...
06:22:11 <Botje_> it's not a 'standard' package, i guess
06:22:19 <Botje_> it's in the split package, so you might have to install that with cabal
06:22:57 <erus`> split should be in the prelude
06:23:10 <MorelPisum> erus`: but not splitOn
06:23:16 <MorelPisum> @hoogle splitOn
06:23:16 <lambdabot> No results found
06:23:23 <erus`> no i mean the package
06:23:34 <erus`> it should come with the prelude in my humble opinion
06:23:37 <MorelPisum> erus`: oh, i see.
06:23:51 <MorelPisum> okay >.> cool.
06:24:35 <rwbarton> in this case you can also use break from the standard libraries
06:24:41 <rwbarton> > break (== 3) [1..5]
06:24:42 <lambdabot>   ([1,2],[3,4,5])
06:24:50 <MorelPisum> rwbarton: COOL!
06:24:52 <rwbarton> only difference that it will include the matched element in the second list
06:24:57 <MorelPisum> @hoogle break
06:24:57 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
06:24:58 <lambdabot> Data.ByteString break :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
06:24:58 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
06:25:05 <copumpkin> > second tail . break (== 3) $ [1..5]
06:25:06 <lambdabot>   ([1,2],[4,5])
06:25:19 <copumpkin> > fmap (drop 1) . break (== 3) $ [1..5]
06:25:20 <mux> I'd use drop 1 instead of tail here for safeness
06:25:20 <lambdabot>   ([1,2],[4,5])
06:25:22 <mux> safety, rather
06:25:28 <copumpkin> safosity
06:25:32 <mux> or that :-P
06:25:33 <MorelPisum> :D
06:25:49 <MorelPisum> copumpkin: you seem to be a great GEEK ;)
06:25:50 <copumpkin> safificationosityness
06:26:00 <copumpkin> MorelPisum: why thank you
06:26:08 <EvanR7> safeality
06:26:20 <EvanR7> safedom
06:26:33 <mokus> safetivity
06:27:06 <MorelPisum> safetity
06:28:22 <MorelPisum> @src fmap
06:28:22 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:29:16 <EvanR7> fmap is different depending on the instance of fmap
06:29:40 <EvanR7> instance of Functor
06:30:01 <EvanR7> @src [] fmap
06:30:02 <lambdabot> fmap = map
06:30:09 <EvanR7> @src Maybe fmap
06:30:09 <lambdabot> fmap _ Nothing       = Nothing
06:30:10 <lambdabot> fmap f (Just a)      = Just (f a)
06:30:18 <MorelPisum> @src second
06:30:18 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:30:23 <MorelPisum> @hoogle second
06:30:24 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
06:30:24 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
06:30:24 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
06:30:26 <EvanR7> @src snd
06:30:26 <lambdabot> snd (_,y) =  y
06:30:29 <mux> I really wish my brain would stop reading 'fmap' as some variation of 'fap'
06:30:32 <eikke> is there any usable Haskell shell out there?
06:30:36 <mux> I spend way too much time on reddit.
06:30:38 <hvr> mux: fmap fmap fmap!
06:30:43 <mux> :t fmap . fmap . fmap
06:30:44 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
06:30:44 <EvanR7> :t fmap fmap fmap
06:30:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
06:30:49 <EvanR7> lol
06:30:51 <Peaker> mux: it's the correct way -- Functor is intellectual masturbation, isn't it? :)
06:31:01 <mux> Peaker: now that makes a lot of sense!
06:32:03 <hvr> I had once a car driving in front of me with the sticker as shown on http://www.flickr.com/photos/hannesmueller/1030400159/
06:32:06 <MorelPisum> eikke: what'd that be? it sounds cool, but i dunno what that might actually be
06:32:24 * hackagebot hlint 1.8.14 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.14 (NeilMitchell)
06:33:09 <eikke> MorelPisum: not entirely sure ;) something which has system commands built-in, but e.g. allows to create chains of piped commands, but type-check everything (input/output format) before executing
06:33:28 <MorelPisum> mux: what is fap? https://secure.wikimedia.org/wikipedia/en/wiki/Fap ?
06:33:44 <EvanR7> urban dictionary
06:33:59 <mux> MorelPisum: the very, very last one on this page ;-)
06:34:10 <mux> "Fap, onomatopoeic slang for masturbation."
06:35:07 <EvanR7> any masturbation? can girls fap?
06:35:30 <ciaranm> girls schlick
06:35:34 <EvanR7> lol
06:35:43 <MorelPisum> eikke: well, i dunno, but maybe you could simply use GHCI? :-P
06:36:42 <eikke> MorelPisum: sure, but I'd still need to create command implementations :)
06:37:05 <EvanR7> eikke: import System.POSIX
06:37:29 <Axman6> ciaranm: heh, you're a true redditor
06:37:30 <EvanR7> and probably some pretty printer formater
06:38:08 <ciaranm> Axman6: oh heck no
06:38:20 * mux tips his hat to ciaranm 
06:38:42 <Axman6> no? i believe the term originated on reddit. i could be wrong
06:39:01 * ciaranm just watches 4chan occasionally when he has no real work to do and fancies seeing a train wreck
06:39:22 <MorelPisum> > second tail . break (== 3) $ [1..5]
06:39:24 <lambdabot>   ([1,2],[4,5])
06:39:28 <MorelPisum> :t second
06:39:29 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
06:40:01 <MorelPisum> i dont understand that function :/
06:40:04 <ciaranm> does anyone else find the (Arrow a) => syntax really icky?
06:40:12 <Axman6> MorelPisum: i'd use second (drop 1)
06:40:26 <MorelPisum> > second (drop 1) . break (== 3) $ [1..5]
06:40:28 <lambdabot>   ([1,2],[4,5])
06:40:29 <Peaker> MorelPisum: "second" applies a function to the second in a tuple
06:40:33 <Peaker> > second (*100) (1,2)
06:40:33 * mux complains to Axman6 about repost
06:40:34 <lambdabot>   (1,200)
06:40:49 <MorelPisum> Peaker: cool
06:41:02 <Axman6> > break 3 [1..5]
06:41:02 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
06:41:03 <lambdabot>    arising from the literal `3'...
06:41:09 <Axman6> > break (== 3) [1..5]
06:41:10 <lambdabot>   ([1,2],[3,4,5])
06:41:20 <Axman6> > second show (1,2)
06:41:21 <lambdabot>   (1,"2")
06:41:25 <EvanR7> :t fmap
06:41:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:41:28 <Axman6> > second f (a,b)
06:41:29 <lambdabot>   Ambiguous type variable `c' in the constraints:
06:41:29 <lambdabot>    `GHC.Show.Show c'
06:41:29 <lambdabot>      a...
06:41:30 <Peaker> @where SEC
06:41:30 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
06:41:36 <Axman6> > second f (a,b) :: (Expr, Expr)
06:41:37 <lambdabot>   (a,f b)
06:41:40 <Peaker> MorelPisum: a generalization and awesome usefulness of this technique is described above ^^
06:41:49 <EvanR7> there sure is a lot of preamble to the damn type now
06:42:22 <MorelPisum> can i also call a function on a special element in a _list_?
06:42:29 <Peaker> :t f
06:42:29 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
06:42:51 <Peaker> MorelPisum: That SEC is missing IMO and I implement it when I need it :-)
06:43:04 <MorelPisum> i mean sth like: func 5 (*2) [1,5,2,5] == [1,10,2,10]
06:43:37 <conal> and similarly for other indexable data structures
06:43:37 <Peaker> @let nth 0 f (x:xs) = f x : xs ; nth n f (x:xs) = nth (n-1) f xs ; nth _ _ _ = error "List index out of range"
06:43:38 <lambdabot>  Defined.
06:43:47 <Peaker> > nth 5 (*2) [1,5,2,5]
06:43:49 <lambdabot>   *Exception: List index out of range
06:43:55 <Peaker> > nth 1 (*2) [1,5,2,5]
06:43:57 <lambdabot>   [10,2,5]
06:43:58 <EvanR7> Peaker: he wants to multiply all 5s by 2
06:44:08 <Peaker> oops, buggy!
06:44:13 <Peaker> @unlet
06:44:14 <lambdabot>  Defined.
06:44:16 <EvanR7> i.e. replace all 5s with 10
06:44:23 <Peaker> @let nth 0 f (x:xs) = f x : xs ; nth n f (x:xs) = x : nth (n-1) f xs ; nth _ _ _ = error "List index out of range"
06:44:23 <lambdabot>  <local>:1:0:
06:44:24 <lambdabot>      Warning: Pattern match(es) are overlapped
06:44:24 <lambdabot>               In...
06:44:58 <EvanR7> [1,5,3,5] ==> [1,10,3,10]
06:45:08 <MorelPisum> Exactly.
06:45:16 <EvanR7> not index 5
06:45:30 <EvanR7> theres already list replace in Data.List, i think
06:46:15 <MorelPisum> @hoogle replace
06:46:16 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
06:46:16 <lambdabot> System.FilePath.Posix replaceBaseName :: FilePath -> String -> FilePath
06:46:16 <lambdabot> System.FilePath.Windows replaceBaseName :: FilePath -> String -> FilePath
06:46:37 <EvanR7> @hoogle sucks
06:46:37 <lambdabot> No results found
06:47:06 <MorelPisum> @faq can haskell suck?
06:47:06 <lambdabot> The answer is: Yes! Haskell can do that.
06:47:19 <Peaker> Network.CGI.Protocol replace seems to have the right type
06:47:23 * hackagebot uuagc-cabal 1.0.0.3 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.0.3 (ArieMiddelkoop)
06:47:25 * hackagebot uuagc-bootstrap 0.9.39.1.0 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-bootstrap-0.9.39.1.0 (ArieMiddelkoop)
06:47:34 <EvanR7> @hoogle Eq a => a -> a -> [a] -> [a]
06:47:35 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
06:47:35 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
06:47:35 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
06:47:38 <ciaranm> sorry, sucking is "doing", and haskell doesn't support "doing"
06:47:54 <EvanR7> ciaranm: it does. do syntax
06:48:04 <benmachine> map (\x -> if x == 5 then 10 else x)
06:48:26 <ciaranm> EvanR7: that's not doing! that's transforming don'ting into something that can do doing. there's a difference.
06:48:45 <EvanR7> @hoogle don't
06:48:46 <lambdabot> No results found
06:49:22 <erus`> every time I learn a little bit more haskell i lose some C++
06:49:29 <EvanR7> good
06:49:35 <MorelPisum> benmachine: Oh, hehe :D cool :]
06:49:42 <zygoloid> erus`: great, you'll be unemployable in no time! ;)
06:50:03 <EvanR7> zygoloid: that paradox pisses me off
06:50:22 <EvanR7> i thought the market was supposed to support better stuff
06:50:29 <ciaranm> of course not
06:50:37 <ciaranm> the market supports replacable parts programmers
06:50:48 <zygoloid> the market has a different notion of 'better' than the technical one
06:51:03 <EvanR7> worse is better
06:51:18 <ciaranm> good programmers are expensive. the market wants to replace one good programmer with ten cheap offshore programmers that it can fire and replace with no impact.
06:51:34 <EvanR7> i can say that that strategy fails miserably
06:51:49 <illissius`> my c++ knowledge has been improving in parallel with my haskell knowledge :\
06:51:49 <ciaranm> i can say an awful lot of companies are doing very well from it
06:51:52 <roconnor> EvanR7: Network effects about programming language knowledge throws a wrench into the assumptions needed for a perfect market.
06:51:52 <lambdabot> roconnor: You have 5 new messages. '/msg lambdabot @messages' to read them.
06:51:52 <EvanR7> but you dont notice until in 3 years your projects not finished or working or neither
06:51:53 <dankna> @tell luite Someone emailed me asking about loading dynamically-recompiled Haskell.  I sent him your way, hope that's all right!
06:51:53 <lambdabot> Consider it noted.
06:52:13 <ciaranm> it's successful because no-one expects software to work
06:52:19 <illissius`> though that's probably because i use c++ when i'm working and haskell when i'm not.
06:52:41 <EvanR7> ciaranm: saving money and having non working and or shitty code
06:52:53 <illissius`> (doesn't hurt that various template crappery is a lot easier to understand with an fp background..)
06:53:06 <ciaranm> EvanR7: sure, but non working and / or shitty code is sufficient
06:53:31 <ciaranm> i mean if the worst comes to the worst, your plane crashes and a hundred people die. but it's still cheaper than writing software correctly.
06:54:33 <erus`> not in my world
06:54:43 <erus`> in my world people write software in haskell
06:54:53 <ciaranm> ah, so you're an academic!
06:55:14 <erus`> and there are no corrupt politicians
06:55:27 <MorelPisum> erus` is from haskelland :]
06:55:29 <Itkovian> erus`: nice world.
06:56:03 <ciaranm> ah, so you're in a loony bin!
06:57:05 <Peaker> ciaranm: Dijkstra commented that writing software correctly seems expensive but is surprisingly cheap in the longer term (debugging is expensive)
06:57:34 <Peaker> (where correctly means: Building constructive proofs while programming, and not trying to prove or verify correctness after-the-fact)
06:57:54 <ciaranm> Peaker: in the long term, the competition has come up with a product that sort of works way before you got yours out the door, and you are thus bankrupt
06:58:06 <Peaker> He went as far as saying there's an *inverse* correlation between  correctness and prive -- lower-quality software is more expensive to make
06:58:24 <Peaker> s/prive/price
06:58:40 <Peaker> ciaranm: that's applicable sometimes, not all times
06:59:18 <brisingr> I
06:59:27 <descender> doesn't quite explain why most written code is bad
06:59:52 <Peaker> Because people think cutting corners save them, and they do so, and end up paying more and having bad software
06:59:55 <ciaranm> unfortunately even the mathematicians tend to go for the "well it probably works" approach
07:00:08 <ciaranm> took 'em 250+ years to go from having calculus to showing that calculus works
07:00:26 <brisingr> Most of the time people don't put soul in it either
07:00:40 <descender> Peaker, unfortunately, the economic system tends to breed this sort of near sightedness
07:00:40 <brisingr> I mean, it's less likely it's gonna be good if "oh let's do it and be  done"
07:01:19 <roconnor> Hmm
07:01:30 <descender> Dijkstra is basically right, I completely agree with him, but sometimes you're fighting against something bigger
07:01:58 <roconnor> ddarius: so a thrist is some sort of free category?
07:02:17 <roconnor> ddarius: as a list is a free monoid
07:02:47 <Younder> Have you read 'worse is better'?
07:03:42 <Cale> Jeez it's annoying to get Google to search for thrist correctly ;) Did you mean thirst? thrift? What?
07:04:09 <ciaranm> try googling java's proposed ?. operator!
07:05:06 <Younder> It goes back to something general Patton said. 'I would rather have a good plan today than a great plan tomorrow.' Sometimes making it to the market first is everything. Quality takes a second.
07:05:44 <Younder> The Netscape/Explorer wars was a example.
07:06:01 <brisingr> In the long term, greatness' market share will exceed the "good" software
07:06:12 <ciaranm> brisingr: name one example where that's actually happened
07:06:54 <Younder> brisbin, I wish that were true. I might add explorer is still the most used browser.. (shudr)
07:06:55 <brisingr> take firefox
07:07:02 <ciaranm> firefox isn't good!
07:07:05 <brisingr> in certain countries it holds majority
07:07:26 <brisingr> I'm not saying it's good or not, I'm saying that projections indicate steep increase in market share
07:07:40 <brisingr> and in some countries, it already has majority
07:08:01 <}ElectrowolF{> isn't windows 95 a nice example :?
07:08:05 <MorelPisum> ciaranm: why?
07:08:57 <ciaranm> MorelPisum: why not?
07:09:19 <MorelPisum> ciaranm: i asked first :P
07:09:34 <ciaranm> MorelPisum: but my question was better
07:09:48 <MorelPisum> ciaranm: why?
07:10:10 <ciaranm> MorelPisum: why not?
07:10:17 <benmachine> this is an odd discussion
07:10:18 <brisingr> it would logically be a superior browser to say, IE or it wouldn't have increasing market share
07:10:18 <MorelPisum> :D
07:10:33 <brisingr> hate to break the conversation :)
07:10:36 <ciaranm> brisingr: by that argument, mcdonalds is the best kind of burger
07:10:55 <brisingr> incidentally, I kinda like mcdonalds
07:10:56 <MorelPisum> ciaranm: do you at least agree that FX is better than IE?
07:11:21 <ciaranm> MorelPisum: in the same way that being kicked in the shins is better than being kicked in the balls
07:11:28 <Peaker> ciaranm: Google was preceded by lower quality search engines
07:11:29 <}ElectrowolF{> define "better"
07:11:44 <MorelPisum> ciaranm: my i ask which browser you use?
07:11:44 <descender> W3C standards compatibility, maybe?
07:11:45 <Peaker> iPhone was preceded by lower-quality phones
07:11:45 <ciaranm> Peaker: ok, you can have that one
07:11:47 <ciaranm> MorelPisum: firefox
07:11:56 <MorelPisum> ciaranm: lol =)
07:12:14 <ciaranm> Peaker: not so sure i'm with you on the iphone... there's an argument to be made that android is a much better product
07:12:18 <}ElectrowolF{> IE might not be better for a single user, but is easyer to use for corperation. Thus it can get a larger share while it is not "the best"
07:12:20 <ciaranm> but the iphone looks pretty
07:12:40 <Peaker> ciaranm: Android kind of sucks.. iPhone is probably better, but I don't have an iPhone and would never buy from Apple
07:12:51 <Peaker> I only have an Android -- and it isn't very good
07:13:02 <Peaker> (maybe I have high standards and would hate iPhone too)
07:13:06 <brisingr> it depends when you've bought it
07:13:20 <brisingr> android isn't fully mature, I think
07:13:31 <Peaker> Maybe Android is fine and the carriers ruined it, I don't actually know, either..
07:13:41 <MorelPisum> }ElectrowolF{: yea. the only (or at least most important) reason why microsoft products are common is that they are pre-installed on most computers, isnt it?
07:13:43 <Peaker> But my Galaxy S is buggy and quirky
07:14:02 <ciaranm> but you can watch porn on it
07:14:15 <brisingr> high-definition porn on it
07:14:16 <mux> and you can share porn from it
07:14:48 <Peaker> ciaranm: anyway, whether Android is better than iPhone or not is a digression -- the original point was that in a supposedly mature market of phones, a better quality phone took significant market share
07:14:49 <}ElectrowolF{> MorelPisum: maybe, but this kinda defies the point that the best product should increase its share
07:15:06 <Peaker> ciaranm: better-is-better in many cases.. Make a big enough improvement and you can kill the entrenched guys
07:15:08 <}ElectrowolF{> and again questions what "the best" is
07:15:31 <brisingr> in a mature market, "the best" is relative
07:15:33 <Peaker> So develop software in the long-term-cheaper way, be better than the rest -- and you may still win out
07:16:04 <Peaker> (Unless you are unable to really make a significant enough improvement to kill the entrenched competitors, which is sometimes the case too)
07:16:13 <Peaker> Especially when there is net-effect involved
07:16:18 <}ElectrowolF{> indeed
07:16:23 <wli> Worse is worse, better is better. The New Jersey style can kiss my ass.
07:16:28 <ciaranm> the problem is, "works" isn't generally a significant improvement
07:16:47 <ciaranm> "new feature" is. "old stuff but that doesn't crash all the time" isn't
07:17:03 <ciaranm> so you might as well deliver "new feature" badly
07:17:07 <brisingr> the problem is "new feature" may not be significant
07:17:07 <MorelPisum> ciaranm: or new version numbers...
07:17:10 <wli> Faster, smaller, better, etc.
07:17:43 <brisingr> worst case scenario, you're competing with a buggy "new feature" against a mature "normal featureset"
07:18:03 <brisingr> a small company can't afford that
07:18:13 <ciaranm> "mature" means "people know what the bugs are and have learned to avoid them", not "doesn't have bugs"
07:18:14 <MorelPisum> }ElectrowolF{: i think 'better' means faster, smaller, securer, extensionabler (?), more features
07:18:23 <wli> And the bug-ridden new feature competitor kills you?
07:18:39 * ciaranm holds the entire software industry in contempt...
07:18:55 <brisingr> I don't think buggy new features will fly for long
07:19:06 <brisingr> you're either gonna die or get bought out
07:19:25 <wli> Doesn't matter, trick is when the buggy new feature competitor kills you off.
07:19:44 <brisingr> only if the buggy new feature competitor is already established
07:19:45 <wli> This is turning into a business discussion.
07:20:30 <benmachine> cynicism is off-topic in #haskell :P
07:20:39 <}ElectrowolF{> MorelPisum: maybe.. but still it's a marketing thing ;-)
07:20:54 <ciaranm> until there's liability for bugs, correctness is only of academic relevance
07:21:02 <Peaker> ciaranm: What new feature does Google Chrome bring?
07:21:12 <ciaranm> Peaker: fewer buttons to press
07:21:18 <brisingr> no progress bar
07:21:21 <wli> There is in some contexts.
07:21:39 <Peaker> Do you think if Firefox had the same button scheme -- Chrome would not get market share simply for being faster/lighter?
07:21:55 <Peaker> Or do you consider that a "feature"?
07:21:57 <ciaranm> i think chrome primarily has market share because it has a google logo on it
07:22:09 <brisingr> so true
07:22:12 <Peaker> I use it because I can't stand to wait for my computer
07:22:21 <brisingr> I mean, I'm gonna switch to google+ only 'cause it's google
07:22:30 <Peaker> And Firefox had me waiting for my computer for years, while I was *thinking* that I was waiting on my network connection
07:22:41 <ciaranm> no, you're going to switch to google+ because it's not facebook
07:22:43 <Peaker> brisingr: Plus is much nicer and better, IMO
07:22:52 <brisingr> and cleaner
07:22:53 <erus`> what is this game stuff on google+?
07:22:54 <brisingr> and safer
07:23:07 <MorelPisum> brisingr: haha Mozilla should make Mozilla+, too :D
07:23:20 * mokus likes the look of google+ but won't switch unless a significant number of friends do - chalk another one up for network effects
07:23:39 <benmachine> mokus: but what if all your friends are thinking the same thing? :o
07:23:46 <MorelPisum> :D
07:23:52 * brisingr is gonna jot down all FB bidthdays and then switch to google+
07:23:54 <mokus> well, i don't actually have anything against facebook, so that's an acceptable outcome
07:24:10 <mokus> because really, all I care about is keeping up with friends
07:24:27 * zygoloid mostly likes that g+ lets him have a clean slate wrt 'friends'
07:24:35 <MorelPisum> benmachine: there should be a FB-group called "If this group is has enough users, we will all switch to Plus together"
07:24:42 <benmachine> zygoloid: pfft, just go on pruning sprees
07:24:44 <wli> Signing up for the thing is basically zero cost.
07:24:45 <brisingr> I don't have any use for FB except birthdays, so that's another nail in its coffin for me
07:24:52 <zygoloid> if there were a facebook2, i'd probably have switched to that :)
07:24:59 <brisingr> AND it's integrated with all the other google stuff
07:25:33 <brisingr> anyhow, I'm gonna spontaneously digress
07:25:47 <brisingr> How can I fill up a 50-minute haskell talk for the uninitiated?
07:25:54 <ciaranm> i like how google+ automatically groups friends who have similar tastes in deviant porn together for you
07:26:14 <brisingr> now THAT's a buggy new feature
07:26:22 <ciaranm> facebook doesn't have access to your search and mail so it can't do that
07:26:40 <Athas> I have a cabal project with two targets (a library and an executable).  These have identical dependencies.  Is there a way I can avoid listing them twice (once in each target)?
07:26:45 <Peaker> brisingr: Show type inference, hoogle lookups, some parsec examples, explain the solution to nullability, and explain the rabbit hole goes too deep for a 50-minute talk (or a whole day's talk!)
07:26:52 <ciaranm> good to know who the furries are, so i can beat them with a cricket bat next time we meet
07:27:15 <brisingr> how should I begin?
07:27:24 <MorelPisum> Google is extremly powerful.
07:27:29 <brisingr> I'm thinking about listing a mouthful of imperative disadvantages
07:27:59 <brisingr> including function side effects
07:28:04 <Peaker> brisingr: better to focus on "why it's better" than "why others are worse" -- people (and programmers) are defensive
07:28:16 <MorelPisum> brisingr: haha :D good idea. no, seriously, presenting the differences between those two paradigms is a good beginning, IMO
07:28:21 <brisingr> good point
07:28:30 <Peaker> brisingr: you'll just elicit a defensive emotional response trying to discredit everything you say
07:29:03 <ciaranm> brisingr: spend the entire time giving examples of stuff that just happens to be really neat when done with monads
07:29:10 <brisingr> I think I should emphasize the different learning approaches
07:29:19 <MorelPisum> brisingr: and do NOT forget to film your presentation and upload it on YT!
07:29:26 <brisingr> ..AND I'm not really at monads in my haskell course yet
07:29:36 <erus`> brisingr: what are the different learning approaches ?
07:29:40 <brisingr> but if it's worth it, I can plow it in a week or so
07:29:58 <brisingr> in imperative languages you start by doing "imperative" exercises
07:30:07 <brisingr> say, learning to use for loops etc.
07:30:08 <ciaranm> but monads are the one awesome thing exclusive to haskell
07:30:30 <brisingr> ok, so
07:30:38 <MorelPisum> ciaranm: exactly. -- well, which languages support lambda-notation?
07:30:50 <ciaranm> MorelPisum: most of them, these days...
07:31:13 <MorelPisum> ciaranm: them == modern (functional) languages?
07:31:30 <ciaranm> MorelPisum: lambdas have made their way out into the real world. ruby, python, c++, scala...
07:31:41 <MorelPisum> lisp?
07:31:43 <brisingr> lua
07:31:51 <descender> even JavaScript
07:31:54 <MorelPisum> oO
07:32:01 * dilinger is still weirded out when he hears that c++ has lambdas
07:32:02 <ciaranm> even pattern matching is becoming mainstream
07:32:13 <brisingr> BUT
07:32:19 <mizu_no_oto> C#, too
07:32:21 <brisingr> most one-language programmers don't know that
07:32:24 * hackagebot data-accessor-template 0.2.1.8 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-template-0.2.1.8 (HenningThielemann)
07:32:28 <companion_cube> lambda in python are poor
07:32:38 <mokus> even C if you're using Apple's compiler
07:32:47 <MorelPisum> companion_cube: in particular, in C++
07:32:54 <brisingr> really?
07:32:55 <MorelPisum> mokus: WTF?
07:32:59 <descender> just about anyone who has used jQuery for JavaScript effects (and there are lots of them) has used lambdas / anonymous functions
07:33:00 <mokus> http://en.wikipedia.org/wiki/Blocks_(C_language_extension)
07:33:12 <brisingr> any chances to learn functors monoids and monads in 5 days?
07:33:21 <MorelPisum> mokus: i didnt even know apples compiler... but then it's not standard/ISO-C, right?
07:33:27 <brisingr> say 8h/day
07:33:32 <ciaranm> brisingr: you can do lyah from start to nearly finish in 5 days...
07:33:37 <mokus> they have customized GCC and Clang
07:33:54 <ciaranm> brisingr: but appreciating the full awesomeness of monads takes a while longer
07:34:00 <MorelPisum> mokus: nice.
07:34:14 <erus`> what other languages have pattern matching?
07:34:19 <ciaranm> erus`: scala
07:34:19 <Botje> brisingr: "monoids are types with an "empty" value and an append, where mempty `mappend` x = x; x `mappend` mempty = x"
07:34:22 <Botje> there, you know monoids
07:34:40 <mizu_no_oto> append is a terrible name for it
07:34:44 <Botje> functors are data structures which have fmap defined on, which change the type of the values they carry to another
07:34:57 <ciaranm> knowing definitions isn't the same as knowing what a thing is!
07:34:57 <Botje> as for monads .. that's a different question >:)
07:35:08 <brisingr> so, functors are like function mappings
07:35:17 <ciaranm> no!
07:35:42 <ciaranm> functors are morphisms in the category of categories
07:35:51 <brisingr> oh
07:35:54 <mauke> wat
07:36:21 <mizu_no_oto> A monoid is a set which has a single binary operation defined on it which is associative and has an identity element
07:36:35 <mizu_no_oto> For example, + and the integers form a monoid
07:36:50 <mizu_no_oto> as does append and lists
07:36:55 <mizu_no_oto> and a number of other things
07:37:09 <ski> erus` : Prolog
07:37:11 <ciaranm> if you've got types a and b and a function f: a -> b then a functor is a thing that can put a and b in a box and turn f into a function f': a-in-a-box -> b-in-a-box
07:37:20 <Axman6> oh damn, i just realised why having an instance for Functor (Compose f g) is a bad idea (type Compose f g x = f (g x))
07:38:19 <ski> Axman6 : why's that ?
07:38:30 <MorelPisum> ski: do you know prolog?
07:38:39 <ski> MorelPisum : i think so
07:38:46 <descender> mizu_no_oto, non-negative integers you mean?
07:38:57 <profmakx> descender, why?
07:39:15 <Axman6> well, say you use fmap show on (Just (Just 1)), should the result be Just (Just "1") or Just "Just 1"
07:39:18 <ski> descender : the integers work just as fine as the naturals
07:39:33 <MorelPisum> ski: be honest. you are a prolog-geek, right?
07:39:56 <zygoloid> Axman6: that's why it's not legal :)
07:39:57 * ski is a declarative-language-geek
07:40:00 <descender> hmm right, what was I thinking of
07:40:20 <MorelPisum> ski: u know haskell, prolog, .. and?
07:40:22 <mizu_no_oto> descender: what property of plain monoids do the negative numbers violate under addition?
07:40:34 <ski> Axman6 : *nod*, ambiguity
07:40:37 <Axman6> zygoloid: yeah, i'm glad i figured it out though. i'd asked about it a few days ago, and i was told it's a bad idea, but it just hit me why
07:40:55 <descender> guess I was thinking of commutative monoids or something
07:41:18 <Axman6> i'm sure there are cases where the ambiguity could be reconciled, but in general it can't
07:41:35 <ciaranm> descender: you're thinking of groups
07:41:48 <ski> MorelPisum : i know some Scheme, some SML, some Agda, a little Erlang, Clean, O'Caml, Oz, Mercury
07:41:51 <ciaranm> naturals don't have additive inverses
07:42:13 <MorelPisum> ski: wow. WOW!
07:42:24 * hackagebot derive 2.5.4 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.4 (NeilMitchell)
07:42:34 * Axman6 isn't that impressed :P
07:42:42 <ski> MorelPisum : also i've played a little in MetaML, LambdaProlog, Lolli
07:42:51 <Axman6> MorelPisum: most people who program for fun know at least than many languages
07:43:05 <MorelPisum> Axman6: e.g. you?
07:43:16 <ski> (probably i forget some language(s) i have looked into, as well)
07:43:31 <_mpu> Axman6: I don't understand your example
07:43:38 * descender goes to reread the definition of monoid on Wikipedia
07:43:47 <ski> ciaranm : monoids doesn't require inverses
07:43:52 <ciaranm> ski: that was my point
07:43:54 * MorelPisum aims to learn as different languages as possible; e.g. C, Java, Prolog, Phyton and Haskell.
07:44:00 <Axman6> haskell, C, erlang, Ada (<3), x86 asm, SPARC asm, a little C++ (</3), probably some more i'm forgetting
07:44:07 <ciaranm> ski: descender is confusing monoids and groups. probably.
07:44:18 <ski> ciaranm : ah, ok
07:44:26 <Lycurgus> was that supposed to be python?
07:44:32 <MorelPisum> yea
07:44:33 <MorelPisum> :D
07:44:34 * benmachine parsed Ada (<3) as the same as how he knows Haskell (==98)
07:44:42 <Axman6> ha
07:45:05 <ciaranm> ada's only redeeming feature is that it gets enums right
07:45:08 <ski> (MorelPisum : i only mentioned declarative languages, of course)
07:45:11 <Lycurgus> http://meansofproduction.biz/eg/index.php/Quadriga
07:45:11 <Axman6> no, i really like the features Ada offers, it's well worth looking into
07:45:12 <_mpu> Axman6: I did, f g might be either Option Option or Option . Option and Id
07:45:14 <_mpu> ...
07:45:16 <MorelPisum> ski: O_O
07:45:24 <Axman6> ciaranm: there's so much more than that
07:45:29 <MorelPisum> ski: O_O
07:45:38 * ski stares back at MorelPisum
07:45:43 <Axman6> _mpu: s/Option/Maybe/ ?
07:46:04 <descender> ciaranm, you are right
07:46:05 * ski smells an MLer
07:46:13 <_mpu> Axman6: I did not remember the Haskell typename, I'm kind of an OCaml guy
07:46:25 <MorelPisum> ski: me?
07:46:31 <ski> nah, _mpu :)
07:46:33 <_mpu> no, mo
07:46:40 <_mpu> s/mo/me/
07:47:13 <Axman6> ciaranm: concurrency in Ada is really nice, it takes a lot of pressure off the programmer and makes much stronger guarantees about interactions between threads and protected objects
07:47:14 <ski> _mpu : not to worry, in the functional programming family, we're all friends :)
07:47:43 <ciaranm> ski: eww. you're friends with the lispers? dirty hippie!
07:47:46 <ski> (.. except when we're not)
07:48:01 <Axman6> it's strange in that it's been designed to be both extremely good for embedded programming, and to make writing large programs much more sane
07:48:09 <_mpu> say, typed functional programming
07:48:13 <ski> ciaranm : hehe, i suspect TH could probably learn from hygienic macro systems
07:48:31 <mizu_no_oto> How is Ocaml compared to haskell?  I'll be graduating soonish, and I was thinking of applying to Jane Street.
07:48:37 * Lycurgus thinks of ski as the prolog guy
07:48:44 <ciaranm> Axman6: all you need to know about ada is that the language specifies three-space tabs
07:49:08 <Axman6> what's wrong with that?
07:49:14 <Axman6> it's just a choice
07:49:14 * ski thinks of JuanDaugherty as Lycurgus
07:49:20 <_mpu> mizu_no_oto: You won't find it hard to use OCaml
07:49:29 <Axman6> and Ada has always been designed to be read a lot more than written
07:49:37 * MorelPisum thinks of _ as Lycurgus
07:49:47 <ski> Ada has mostly sensible input and output modes for arguments
07:49:58 * JuanDaugherty snickers
07:50:02 <ciaranm> Axman6: three space tabs are about on par as defining -1 to be a natural number
07:50:35 <Axman6> ciaranm: if that's the level of critisism you're going to give, it's not really worth listening to :\
07:50:44 <ski> also Ada has range subtypes of integers, that you can use as index types for arrays
07:50:55 <Axman6> "Haskell sucks because it uses indentation instead of braces"
07:51:10 <Axman6> ski: indeed, that's a super nice feature to work with
07:51:22 <ciaranm> Axman6: it's a serious point: there are multiple 'reasonable' definitions of "natural number", and none of them include -1. similarly, there are multiple reasonable definitions of what the tab character does, and none of them are 3 spaces
07:51:24 <Cale> Tab characters themselves are on par with defining -1 to be a natural number. Using any number of spaces to indent things is fine so long as they line up correctly. :)
07:52:02 <Axman6> being able to define type Decimal is range 0 .. 9 and be guaranteed it will never be outside that range without causing an error, without you having to write any more code than that is so nice
07:52:10 <Cale> If it were up to me, tab characters in source files would be a lexical error.
07:52:12 <mizu_no_oto> Oh, yeah - are there any companies out there that might hire a Haskell programmer who merely has an undergraduate degree?
07:52:18 <_mpu> Cale: +1
07:52:41 <Axman6> mizu_no_oto: i got hired as an intern by a haskell company without even having my undergrad yet =)
07:52:41 <ciaranm> mizu_no_oto: there are, although most of them would expect you to be good with something that isn't haskell too
07:52:54 <descender> Cale, I have Emacs automatically turn tabs to spaces
07:52:57 <Axman6> ciaranm: agreed
07:53:06 <Axman6> descender: any decent programmer does :P
07:53:14 <Cale> descender: Yeah, everyone writing Haskell should switch those options on :)
07:53:19 <_mpu> Axman6: Haskell companies do exist ??
07:53:19 <ski> Axman6 : well, istr the errors you get are of the run-time variety (i.e. if you do arithmetic on the indices)
07:53:37 <mizu_no_oto> Axman: which company?
07:53:42 <Axman6> ski: parse error
07:53:47 <Axman6> mizu_no_oto: Tsuru Capital
07:53:50 <ski> descender : `(setq-default indent-tabs-mode nil)'
07:53:51 <Axman6> in Tokyo
07:54:02 <mizu_no_oto> How are they?
07:54:07 <Axman6> fantastic
07:54:13 <Axman6> i loved working there, great guys
07:54:17 <mizu_no_oto> They are one of the places I was thinking of applying to
07:54:24 <Axman6> though, if you interned there, it might be in singapore
07:54:37 <mizu_no_oto> *makes note to finish that code sample they want*
07:54:50 <Axman6> heh
07:55:19 <ski> Axman6 : i mean, i seem to recall that you'll get run-time, not compile-time errors, if you do arithmetic on such ranged indices, and you get out of bounds
07:55:24 <descender> ski, I turn it off while making patches to software I didn't write though
07:55:41 <_mpu> ski: better than segfault
07:55:48 <Axman6> ski: yeah. it's not really avoidable at compile time though
07:55:59 <Axman6> they are exceptions which can be caught
07:56:46 * ski also uses `(setq-default line-move-visual nil)'
07:57:02 <Axman6> one thing that's also really useful are mod types, type Queue_Index is mod 10;, you get values 0..9, and 9+1 = 0
07:57:05 <ski> _mpu,Axman6 : right, it's still great
07:57:12 <descender> mizu_no_oto, ha if you do intern at Tsuru Capital in Singapore, we can meet :)
07:57:29 <Axman6> descender: ever met any of the tsuru guys?
07:57:37 <descender> Axman6, no the first time I've heard of it haha
07:57:39 <ski> Axman6 : interesting, that wasn't in the book i read
07:57:56 <Axman6> really? how odd, i think it's always been a feature
07:58:30 <ciaranm> doesn't ada define the result type of (0 .. 9) + (0 .. 9) to be (0 .. 9) ?
07:58:36 * ciaranm seems to recall that
07:59:26 <Axman6> i'm not sure that's even legal. it may be
08:00:14 <mizu_no_oto> I'll be applying for the full-time position, probably in Tokyo
08:00:19 <descender> by the way, I'm attempting to learn Haskell by writing a Mahjong game; I'm wondering if there is a better way to model the game flow besides using state machines and monads
08:00:47 <Axman6> you can do nice things like arr3 (1..10) := arr1(1..10) + arr2(1..10); which is nice
08:01:06 <ski> Axman6 : reminds me of the interesting partially static integer types that a partial evaluation system used : you could have a type with values `k*m + r' where `m' and `r' (with `0 =< r < m') was known statically -- they used this with `m' a power of two to e.g. specialize loops repeatedly consuming 24 bits out of a bitarray into an unrolled loop consuming 3 32-bit words at a time
08:01:06 <Axman6> state machines?
08:01:33 <Itkovian> is there an isSpace-like function available for ByteStrings?
08:01:58 <descender> Axman6, what about them?
08:02:08 <mauke> Itkovian: that makes no sense
08:03:03 <Axman6> ski: sounds cool :)
08:03:19 <Itkovian> probably not, but reading the contents of a tarball yields a ByteString and I want all the whitespace out of there so it can be correctly interpreted as a CSV file (there are no "strings" with whitespace in these files)
08:03:24 <ski> Itkovian : maybe you can use `span' or `break' ?
08:04:01 <ski> @hoogle span
08:04:02 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
08:04:02 <lambdabot> Data.ByteString span :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
08:04:02 <lambdabot> Data.List span :: (a -> Bool) -> [a] -> ([a], [a])
08:04:05 <Itkovian> ski: there is a filter, but I need the predicate
08:05:08 * ski wonders what "I need the predicate" means ?
08:05:10 <Itkovian> w2c might help
08:05:19 <Itkovian> well, the Word8 -> Bool function
08:05:28 <Itkovian> that would be isSpace . w2c
08:05:32 <ski> oh
08:05:36 <Itkovian> seems ugly
08:05:50 <ski> @hoogle Word8 -> Bool
08:05:51 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
08:05:51 <lambdabot> Data.ByteString elem :: Word8 -> ByteString -> Bool
08:05:51 <lambdabot> Data.ByteString notElem :: Word8 -> ByteString -> Bool
08:06:22 <Axman6> @hoogle isSpace
08:06:22 <lambdabot> Data.Char isSpace :: Char -> Bool
08:06:22 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
08:06:23 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
08:07:24 * hackagebot canonical-filepath 1.0.0.1 - Abstract data type for canonical file paths.  http://hackage.haskell.org/package/canonical-filepath-1.0.0.1 (ThomasSchilling)
08:08:14 <Itkovian> Axman6: yeah, I just saw it. Thx.
08:08:47 <efie> is there a function which produces a list of integers of a specific interval and each integer is dropped with a specific percentage? - i want to set both the percentage and the intervall
08:08:57 <Axman6> i have a feeling it is intended that if you use that module, you only explicitly import the functions you need
08:09:12 <Axman6> so, import Data.ByteString.Internal (isSpaceWord8)
08:09:23 <Botje> efie: create a list with the proper frequencies and then shuffle it?
08:09:46 <Cale> efie: er, what do you mean by "dropped with a specific percentage"?
08:10:36 <Cale> as in, randomly not included in the list?
08:10:53 <efie> cale: well, for example every 4th number in the list shall be a 0, and the rest 1. botje: hm sounds good! ill look for a shuffle function
08:11:43 <atomie> I'm profiling some of my code, but the results of the profiling aren't detailed enough. They show a certain function I defined being a bottleneck, but nothing about the usage of standard library functions inside that function. How do I also get information about the time/memory usage of repeated calls to Data.IntMap.filter from within my function, for instance?
08:12:25 <atomie> It seems only my top-level functions are profiled. I want to "go deeper" than that.
08:12:35 <atomie> Down to standard library definitions.
08:14:52 <ski> efie : so in that case, do you always want `take (4*n) (cycle [0,0,0,1])', or are you after some random permutation of that or something similar ?
08:14:55 <atomie> Can I use the SCC pragma before any expression? I usually profiled with -auto-all, which is maybe why only top-level definitions were checked...
08:16:22 <Cale> atomie: yes
08:16:34 <descender> Axman6, I mean, I've looked at Haskell code from a couple of games, including LambdaHack, but they seem rather uninspired to me given the kind of abstractions Haskell is capable of. Those games might as well be implemented in an imperative language
08:16:39 <Itkovian> Axman6: Yes, that's what I figured.
08:17:26 <efie> ski: yes, i would like a random permutation from this cycled list you mentioned
08:17:26 <atomie> Cale: Thanks. So, there's no way to enable profiling "everything" (up to a certain level of depth).
08:18:15 <Cale> atomie: not as far as I know, but that would produce probably more output than most people are interested in
08:18:25 <Cale> atomie: are you writing some automated tool?
08:18:44 <dncr> descender: maybe the FRP game examples make fancier use of haskell
08:19:26 <descender> games are usually written with the annoying event loop (which creates an inversion of control) and state must be computed in chunks and explicitly saved
08:19:45 <atomie> Cale: No, just profiling. Using -auto-all gave me enough information to start pinpointing probable bottlenecks by hand.
08:20:23 <descender> dncr, yeah FRP does look interesting, but I still struggle to understand its internals, particularly the implementation of switches
08:20:24 <Cale> atomie: yeah, usually -auto-all is good as a start, and you start drilling down with SCC's if you're still confused about where the inefficiency in the definition lies
08:20:27 <efie> skI: do you have an idea how to get a random list? i found this http://www.refactory.org/s/randomly_shuffle_a_list/view/latest but as im not deep into haskell i dont get all of it (IO) and it does not seem to work if i try this code
08:20:46 <merijn> descender: Games often times are just easier to program imperatively. Why invest lots of time fighting that?
08:21:05 <merijn> descender: Especially since haskell is kind of a nice imperative language :)
08:21:25 <merijn> dncr: What's the current most popular/best FRP framework?
08:21:25 <descender> merijn, I'm doing it imperatively actually ;) I just hope there's something better out there
08:22:24 * hackagebot JsonGrammar 0.3 - Combinators for bidirectional JSON parsing  http://hackage.haskell.org/package/JsonGrammar-0.3 (MartijnVanSteenbergen)
08:22:26 * hackagebot lhs2TeX-hl 0.1.3.3 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.3.3 (AlessandroVermeulen)
08:22:56 <thoughtpolice> merijn: "the way we do things now is just the easiest way. how could anything else work?"
08:23:04 <descender> merijn, guess I got too carried away with my HXT based 3D model parser/loader
08:23:30 <dncr> mm well Yampa is the only one that was ever used to do low-level/fast stuff (audio synth) and then Animas is Yampa with a bit more cabal documentation
08:23:52 <dncr> and Yampa development has been frozen forever for some reason
08:24:03 <merijn> thoughtpolice: I don't think it's the easiest way. I think FRP looks far easier for games, but afaik there's no truly great FRP library yet
08:24:45 <danharaj> iPwn studios allegedly has an awesome one :p
08:25:16 <dncr> elerea is simpler and actually has a few game examples
08:25:29 <dncr> reactive was never made to work properly
08:25:42 <dncr> those are the main ones i know about
08:25:54 <Cale> The guy who wrote elerea is working with us now :)
08:26:00 <merijn> thoughtpolice: Most games require a global state, you can't really avoid doing at least some imperative work in that scenario unless you want to specifically construct your game around the limitation of no mutable global state (but that's hardly an argument for functional being "better" then imperative for game programming, since it introduces lots of artificial hurdles)
08:26:05 <danharaj> reactive-banana is promising
08:26:50 <danharaj> also you can just lift the automaton arrow instance from Ross Patterson's arrows paper, adapt it to be able to lift IO actions to arrows, and use that for discrete frp.
08:26:58 <danharaj> That's what I'm doing.
08:27:17 <Cale> Well, it depends on what you mean by a global state.
08:27:20 <descender> let me attempt to grok that idea
08:27:26 <albertid> Hi, my program runs correctly with "runghc Prog.hs", but shows different behaviour with "ghc -o x Prog.hs && ./x". What does runghc do differently?
08:27:32 <Cale> I actually am tempted to disagree with you there.
08:29:09 <merijn> Cale: Well, you can do lots of things to approach the problem differently and reduce or remove the amount of state needed, but in my experience so far it's hardly the easiest way to program games
08:29:27 <dncr> the yampa arcade paper makes an argument that you can build separate FRP pieces of a game which might refute the all-games-are-monolithic idea
08:29:36 <descender> albertid, what errors do you get from ghc?
08:29:42 <Cale> There tends to be some data about the state of the world being simulated which needs to be distributed to all the AI agents, for instance. It's not necessarily everything though, but a summary of the local states of things in the system.
08:30:18 <Cale> and of course, you have to decide what to draw on the screen somehow
08:30:31 <Cale> so you need to be able to collect that data from somewhere
08:31:52 <Cale> But as far as the sort of global state where everything has permission to read and write in arbitrary ways, you can have none of that just fine.
08:32:05 <albertid> descender, no errors. just different (faulty) program behaviour
08:32:24 * hackagebot terminfo 0.3.2.2 - Haskell bindings to the terminfo library.  http://hackage.haskell.org/package/terminfo-0.3.2.2 (JudahJacobson)
08:32:41 <descender> danharaj, is your FRP code publicly viewable somewhere?
08:33:01 <albertid> descender, I will investigate the issue, probably stems from some library.
08:33:48 <danharaj> descender: No, but like I said, it's just a copy of Ross Patterson's automata arrows: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.123.1351
08:34:39 <descender> thanks
08:34:54 <merijn> Cale: I didn't really mean that everything has to be globally readable/writable, but like you said you need some way to distribute data to all the places where it's needed and gather again and that certainly doesn't make designing the code easier
08:37:04 <Cale> Well, that's what function/arrow parameters and monoids are for, respectively :)
08:39:02 <descender> I should start a dev journal for this game to keep track of my progress with Haskell and provide a perspective from a game developer coming from an imperative (C++) background
08:39:54 <ski> .. and things like `ASP a0 b0 -> ASP a1 b0 -> ASP (Either a0 a1) (Either b0 b1)'
08:40:13 <ski> (`ASP' being an asynchronous stream processor)
08:42:17 * ski thinks there's also a distinction between a single global-extent state, and many global-extent, local-scope states which are distributed around your data flow network
08:42:24 * hackagebot haskeline 0.6.4.1 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.6.4.1 (LennartAugustsson)
08:42:34 <Cale> In our game, all the agents produce descriptions of the part of the game world that they're responsible for as part of their output, and those descriptions are combined together and re-distributed as a parameter (with a delay, to prevent loops)
08:42:53 <ski> *nod*
08:43:07 <ski> using something like
08:43:11 <ski> @type loop
08:43:11 <ski> ?
08:43:12 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
08:43:18 <ski> (but with a delay)
08:43:21 <Cale> yeah
08:43:42 <merijn> Cale: If you can't separate the game world in to separate agents then such an approach doesn't really work, though
08:44:01 <Cale> Sure, but I can't think of too many games where you can't do that...
08:44:19 <descender> Cale, what game is that?
08:44:38 <Cale> descender: It's a game called BloodKnight that we're working on at iPwn Studios.
08:44:57 <merijn> Cale: Maybe I'm looking at things the wrong way then...
08:45:43 <descender> Cale, nice
08:45:49 <Cale> merijn: Usually a game world can be broken up into parts that you can come up with names for, and which behave *somewhat* independently of each other.
08:45:53 <merijn> If you have a large "physical" world you can't really avoid giving that information to any agent, no?
08:46:54 <merijn> I think my problem is just that I need to read more game source code...
08:46:56 <Cale> merijn: Sure, though you might want to filter the information in the description of the world before passing it back in to each agent.
08:46:58 <sm> Cale: going well I hope! I wonder what's your biggest pain point
08:47:11 <brisingr> with your help and the price of a beer, I now understand what a functor is.
08:50:27 <brisingr> ok, so now, how to condense haskell in 50 minutes
08:50:32 <Cale> sm: Hmm... biggest pain point...
08:50:56 <c_wraith> Cale: ooh, say my library. :P
08:51:14 <Cale> sm: Probably that the scoping rules of proc/do notation aren't quite right for our system.
08:51:30 <c_wraith> (I made a couple updates to it to satisfy Stephen Blackheath's feature requests so you guys could use it :)
08:52:24 * hackagebot haskeline 0.6.4.2 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.6.4.2 (JudahJacobson)
08:52:32 <Cale> We have a primitive to attach the value of a behaviour (the variables bound by the proc/do syntax) to each of the occurrences of an event as it occurs, and that can be used to make the value available inside arrow operations that process events.
08:53:07 <Cale> But it doesn't happen automatically (you have to write the attaching by hand, which involves repeating the name of the variable a couple times)
08:53:29 <Cale> oh, he left
08:53:46 <Cale> So we might be able to do something about that.
08:53:52 <brisingr> good night c_wraith
08:53:53 <merijn> descender: Yeah, should maintain a blog telling about haskell for games, would be interesting to read. I wish there were some more advanced game programming sites/books, (well, they probably exist, but I don't know them....)
08:54:11 <sm> Cale: interesting, so a bit too much verbosity/boilerplate
08:54:13 <Cale> We already have our own arrow notation preprocessor
08:54:22 <Cale> (for efficiency reasons)
08:54:33 <merijn> All game programming stuff seems aimed at either people with experience in game dev or people completely new to programming, both are a bit wasted on me
08:54:39 <Cale> That got us a 2 or 3 times speedup actually :)
08:54:58 <Cale> c_wraith: oh
08:55:12 <Cale> c_wraith: which library, actually? I'm not sure I was aware of this.
08:55:15 <c_wraith> let me guess...  not using it anymore? :)
08:55:17 <c_wraith> lrucache
08:55:55 <Cale> Ah, that's still a dep, though I'm not sure what it's being used for (Stephen obviously used it for something :)
08:56:12 <sm> descender, merijn: there is a lot of game dev tutorials and real codebases out there. There's a games page on the haskell wiki, and #haskell-game too fyi
08:56:36 <merijn> sm: I was thinking in general, not just haskell specific
08:56:42 <sm> me too
08:56:58 <descender> sm, I'm more into Haskell specifics, I know enough about game development
08:57:15 <Cale> sm: But yeah, overall, arrows have probably saved us more headaches than they've caused
08:58:45 <Cale> Since this isn't just a research project, we can't really afford to tackle things via Conal's route and hope that we can deal with all the sharing problems and solve all the unsolved problems with Reactive. Arrows are a nice middle-ground in terms of being explicit about that.
08:59:00 <descender> I'm hungry for complex games written in Haskell
08:59:01 * sm nods
08:59:15 <sm> descender: you've looked at the source of all the games on hackage right ?
08:59:47 <sm> some of those are complexish
08:59:48 <descender> sm, I looked at a couple of them, but as I mentioned earlier, their structuring is a bit too imperative; I have yet to look at Frag though
09:00:02 <sm> and there are some using various frp flavours
09:00:16 <descender> Frag will be interesting to me, since I've read the Q3 source code
09:00:21 <Cale> Note that Frag was originally written by someone who was completely new to Haskell, and he did it in about a week or two.
09:00:23 <sm> not the good ones, afaik :/ perhaps excluding frag
09:00:53 <sm> descender: you may want to check out roguestar too
09:01:04 <Cale> I heard that it's been cleaned up a bit since then, but I'm not sure about the extent of that. Originally it was unfortunately quite hard to read.
09:01:05 <descender> sm, ah thanks for that
09:02:24 * hackagebot uuagc-cabal 1.0.0.4 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.0.4 (ArieMiddelkoop)
09:02:26 * hackagebot uuagc 0.9.39.1 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.39.1 (ArieMiddelkoop)
09:06:44 <atomie> I'm creating a Haskell wrapper over a common C library. However, I'd like to define additional C functions (an additional layer of C, an adapter of sorts) so that the Haskell bindings can be easier to make. This layer of C would be included in the cabal package. Can cabal handle this, automatically compile it and use it etc.?
09:07:02 <atomie> If so, are there any good sources online where I could find how to accomplish this?
09:08:26 * sm updates http://www.haskell.org/haskellwiki/Applications_and_libraries/Games
09:08:37 <c_wraith> atomie: it's pretty easy actually.  Maybe the best way to learn it is to look at a package that uses local C files
09:08:42 <efie> i am trying to shape a (one-sided disturbed) communication channel http://codepad.org/uMQyAzkS. the '0' are disturbed from time to time to '1'.  (as stated above) i used a shuffle method to model the disturbance. but the type of this method "IO [Integer]" does not match with my [Bit]" changing [Bit] to Io [Integer] leads to further problems. canyone help with this?
09:09:50 <atomie> c_wraith: That's good news. :) I'll check out some of the existing bindings packages on hackage, then. Thanks.
09:14:00 <efie> test
09:14:02 <efie> ah, ok :)
09:14:07 <Itkovian> test successful
09:17:03 <efie> i dont know how to handle IO [Integer] - how can i work with as a normal [Integer] list?
09:18:26 <roconnor> efie: write a function myFunction :: [Integer] -> Foo , and then when you want to use it write do { intList <- myIOIntegerList; f intList }
09:19:02 <roconnor> efie: write a function myFunction :: [Integer] -> Foo , and then when you want to use it write do { intList <- myIOIntegerList; myFunction intList }
09:20:38 <danharaj> alternatively, if f :: [Integer] -> b, then fmap f :: IO [Integer] -> IO b
09:23:19 <efie> do { intList <- myIOIntegerList } casts IO [Integer] to [Integer]  ?
09:23:35 <wyfrn> hey guys ... is there a way to compute the square root of a realy big Integer?
09:24:05 <roconnor> efie: not really.  It is really using the (>>=) combinator under the hood
09:24:06 <ricree> efie:  A do block creates a monad.  When inside monads, you can interact with values wrapped in a monad of the same type
09:24:15 <PatrickRobotham> wyfrn: Newton's method?
09:24:32 <ion> roconnor: myFunction intList at the end of the do block doesn’t typecheck.
09:24:54 <roconnor> efie: but with the do block intList has type [Integer], but it only lasts the scope of the do block, and you have to follow the rules of the do block.
09:25:09 <efie> hm ok
09:25:09 <roconnor> ion: my bad.  myFunction :: [Integer] -> IO Foo
09:25:22 <ricree> efie:  In this case, the "<-" pulls the [Integer] from the IO [Integer], but as roconnor said, it's using >>= under the hood, so it can only be used in a monad do block
09:26:08 <roconnor> efie: it's actually pretty easy to use once you get used to the style.
09:26:12 <wyfrn> PatrickRobotham: ahh thx
09:26:40 <efie> thanks
09:26:41 <efie>  i guess ill have to learn moands and this do-block thing first before going on
09:27:15 <roconnor> efie: in theory you can learn to use do blocks to do IO without understanding monads.
09:27:36 <merijn> Yeah, but on the other hand I don't think monads are that hard once you grok the type system
09:27:55 <ricree> everyone seems to approach them their own way
09:28:06 <merijn> efie: "do { intList <- myIOIntegerList; foo intList } is syntactic sugar for "myIOIntegerList >>= \intList -> foo intList"
09:28:28 <merijn> :t (>>=)
09:28:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:28:43 <roconnor> efie: if you need help, come here and paste your code and someone will likely help you.
09:28:54 <efie> thanks :)
09:29:13 <ricree> Personally, i'd recommend just picking one or two useful ones and getting used to how they work.  Then seeing how that compares to other simple monads like maybe or state
09:29:24 <ion> :t (>>=) `asAppliedTo` (undefined :: IO [Integer])
09:29:25 <lambdabot> forall b. IO [Integer] -> ([Integer] -> IO b) -> IO b
09:29:27 <merijn> Preferably on hpaste.org and not on that ugly pastebin.com :p
09:29:43 <ricree> Once you have a feel for how they work, then the type system approach is easier to visualize
09:30:02 <ricree> but that's just me, though.  Others may have found different approaches to work better for them
09:31:24 <merijn> The problem with monads is, once you understand them they seem so easy that you're confused why you ever though it was hard :p
09:33:40 <illissius> can someone give me examples of things which are safe to unsafePerformIO but not to unsafeDupablePerformIO?
09:34:51 <Cale> illissius: whenever you have multiple threads in a system, unsafeDupablePerformIO might cause the action to occure more than once if two separate threads demand its evaluation at nearly the same time.
09:34:54 <illissius> I thought I had a decent idea of what wouldn't be safe to unsafeDupablePerformIO and what would be, but then I realized the same was basically true for plain unsafePerformIO as well.
09:34:55 <Cale> occur*
09:35:04 <illissius> yeah, I understand that bit :)
09:37:12 <illissius> I mean, let's say you make a ForeignPtr pointing to some data you malloced and initialized -- presumably that would be safe to unsafeDupablePerformIO, because if it gets performed more than once the extra copies will just float in the ether and get garbage collected and do no harm. whereas if you do something with non-self-contained side effects, that wouldn't be, because the side effects would end up happening multiple times.
09:37:17 <gwern> 'Keywords with the Most Clicks  AVCon spaced repetition spaced repetition software spaced repetition learning haskell jewelry ' <-- gee thanks google adwords, I'm a top advertiser for 'haskell jewelry'!
09:37:47 <illissius> but things with side effects are already things you should be applying unsafePerformIO to.
09:37:52 <illissius> *shouldn't.
09:38:02 <Cale> illissius: well, hmm... will it though?
09:38:18 <Cale> illissius: You might end up running a finalizer when you didn't expect to have to
09:38:31 <Cale> Though that might not be too big of a deal
09:38:58 <illissius> I don't know. I'm not actually sure. but that's what seemed logical, to me. just because unsafeDupablePerformIO does weird things doesn't mean garbage collection stops working. but correct me if I'm wrong.
09:39:15 <Cale> It should be okay
09:39:27 <Cale> Well... hmm
09:39:41 <Cale> Wait, the value you get in each of those two threads will be different though
09:39:45 <Cale> so it might not be GCed
09:39:59 <Cale> it's just that the value you'll see for the variable will be different!
09:40:17 <illissius> oh, hmmm
09:40:18 <Cale> So if you allocate twice, what looks like one variable will actually be two values.
09:40:37 <illissius> I may have been misunderstanding things then
09:41:34 <illissius> my impression was that because of how GHC's runtime works, for some reason another multiple threads might end up evaluating and executing the same thunk, though why was not entirely clear, which means spurious multiple executions could result
09:42:10 <illissius> but in that case it's actually something like a race condition where if different threads both *demand* the value they might get different ones?
09:42:11 <Cale> The problem is that when a thunk is entered in one worker thread, there's a small window between when it's entered and when it can be rewritten to point at a greyhole (which is a bit of code that'll cause the other thread who wants the value to wait for the evaluation to finish)
09:42:37 <Cale> If two threads get to evaluating the value at very close to the same time, they'll both evaluate it, and use their own results for that evaluation
09:42:47 <illissius> ah, I see
09:43:32 <Cale> Normally unsafePerformIO will do a check to make totally sure that this hasn't happened.
09:43:47 <Cale> But unsafeDupableIO skips that check
09:43:50 <illissius> but if only one thread ever uses the value, there should be no problems? e.g. threads don't actually try to opportunistically evaluate things just because they can
09:43:56 <Cale> er, unsafeDupablePerformIO
09:44:05 <illissius> Cale: yeah, crawls the stack iirc, which as far as I gathered can be slow.
09:44:12 <efie> roconner: http://codepad.org/IY0jFKFM ... ? :|
09:44:18 <Cale> well, hmm
09:44:31 <Cale> yeah, probably, though I wouldn't rely on it
09:44:38 <illissius> also, are we talking about haskell threads or OS threads here?
09:44:44 <Cale> Haskell threads
09:45:15 <Cale> efie: What's going on with that do block at the top level/
09:45:16 <Cale> ?
09:46:10 <illissius> hmm. would be nice if there were a clear set of criteria (potentially in the form of 'laws') somewhere about what needs to be true for something to be safe to unsafe(Dupable|Inline)PerformIO.
09:46:20 <merijn> efie: Do blocks can only occur inside a function, not at the top level like you have now
09:46:22 <efie> i dont know - im not used to do-black
09:46:53 <merijn> hold on, lemme try to figure out what its supposed to do
09:47:15 <Cale> efie: do-blocks are expression forms, they glue together multiple actions in some monad to make bigger actions.
09:47:22 <Cale> efie: (which are values)
09:48:28 <Cale> illissius: I basically get around this by not using them ever.
09:49:01 <Cale> illissius: (Though of course, for FFI bindings, it often becomes important. :)
09:49:38 <illissius> Cale: Wait. (back to the ForeignPtr example) if the two threads end up seeing different values because of unsafeDupablePerformIO, doesn't that mean the action being unsafely performed was accessing some impure state, which means it wouldn't have been safe to unsafePerformIO in the first place?
09:50:14 <illissius> you do lose sharing, but... I guess if there were something in it (object identity or such..) which is only observable from the IO monad, there might be problems?
09:50:27 <Cale> illissius: Well, your example was allocating a ForeignPtr, wasn't it?
09:50:28 <illissius> hmm.
09:50:41 <Cale> So I guess the state is the contents of the heap
09:50:50 <illissius> well, yeah. make a foreignptr with malloced memory, initialize the memory, and finalizer frees the memory
09:50:51 <hpaste> merijn pasted “Using do blocks” at http://hpaste.org/50225
09:51:06 <Cale> illissius: Yeah, though actually, it probably won't GC
09:51:06 <merijn> Warning: that might not be entirely correctly indented
09:51:16 <merijn> efie: Take a look at what I just pasted
09:51:21 <Cale> (unless one of the threads does nothing with the value)
09:51:26 <merijn> hmm
09:51:35 <merijn> Apparently there's some tab's in there, that looks awful
09:52:07 <illissius> Cale: well, if the two threads get different values, won't each be collected when the thread that's 'using' it stops doing that (no longer has references)?
09:52:45 <Cale> illissius: But both threads must have references to the value, and moreover, must already be trying to do something with it, or else it wouldn't have been evaluated.
09:53:19 <ion> merijn: return (f ...)
09:53:29 <hpaste> merijn annotated “Using do blocks” with “Using do blocks (less wrong)” at http://hpaste.org/50225#a50226
09:53:39 <merijn> ion: Yeah, already spotted it :)
09:53:57 <glguy> Does:  msum . map return :: MonadPlus m => [a] -> m a         live somewhere in a standard library?
09:54:24 <Cale> glguy: I dunno, but I tend to call that 'option'
09:54:28 <merijn> @hoogle MonadPlus m => [a] -> m a
09:54:28 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
09:54:28 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
09:54:29 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
09:54:47 <merijn> glguy: Doesn't look like it
09:55:11 <Athas> I have a cabal project with two targets (a library and an executable).  These have identical dependencies.  Is there a way I can avoid listing them twice (once in each target)?
09:55:32 <merijn> efie: Does that example help at all?
09:55:49 <illissius> Cale: right. but the only difference I see that making is whether there's one value which is collected when both threads lose reference to it, or two separate values which get collected when their individual threads lose reference to them. If both threads lose reference to the single value in the first case, they would also have lost all references to the separate values in the second case. I must be misunderstanding something again.
09:56:39 <efie> merijn: thank you - it now got an insight in what you meant before.. um, but if i try to put it in the rest of my code it says " No instance for (Monad ((->) t0))       arising from a use of `return'" .. i dont know if did something wrong
09:57:02 <Cale> illissius: It's actually really really bad what will happen.
09:57:07 <merijn> efie: My first example was wrong
09:57:29 <merijn> efie: Should be "return $ channel_2' bits test" OR "return (channel_2' bits test"
09:57:35 <merijn> eh
09:57:42 <merijn> Closing parenthesis in the last one, of course
09:57:58 <Cale> illissius: The two threads will behave like they have their own distinct version of x, when the code as written appears that they should agree about its value.
09:58:18 <illissius> to be more specific I was thinking of something like: unsafeDupablePerformIO $ do { mem <- malloc n; poke mem 5; p <- newForeignPtr mem (free mem); return p } (probably not remembering the various APIs completely correctly)
09:58:40 <efie> merijn: thanks in advance! i try it out later, i have to go away from the keyboard for a moment :)
09:58:43 <illissius> Cale: but from pure code the difference shouldn't be observable, given the constraints already present for unsafePerformIO to be safe, should it?
09:58:47 <merijn> efie: This is because channel_2' returns type [Bit], but the do notation expects return type "IO a"
09:58:51 <merijn> :t return
09:58:52 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:58:53 <Cale> illissius: It's totally observable.
09:59:11 <merijn> efie: So return turns the [Bit] created by channel_2' into an IO [Bit]
09:59:14 <illissius> Cale: can you give me a specific example? :-)
10:01:04 <Cale> illissius: Well, okay, suppose one thread goes on to poke a new value into x, and the other expects to read that new value which was poked. It'll never see its version of x change.
10:01:27 <Cale> Because they'll be two separate copies instead of the same pointer as expected.
10:01:36 <illissius> indeed, but wouldn't that need to be happening in IO?
10:01:39 <Cale> Even though it's the same variable in the code
10:01:55 <Cale> Of course, because all the operations on ForeignPtrs are in IO
10:02:05 <illissius> hmm
10:02:59 <Cale> Basically, I would say don't use unsafeDupablePerformIO ever.
10:03:14 <Cale> Sure, it avoids a check which is sometimes not required
10:03:32 <Cale> But it's not like that check is super-expensive anyway.
10:04:17 <Cale> Surely the actual cost of the malloc is much larger.
10:05:27 <illissius> let's say there's a pure API which is implemented using ForeignPtrs internally. the ForeignPtrs are created with unsafeDupablePerformIO in the manner above, and there are functions to 'modify' them by allocating new, modified copies of the original (but not changing the original) (also unsafeDupablePerformIOed), and then functions to read values out of them, also unsafely performed somehow. but once a value-with-ForeignPtr-
10:05:29 <illissius> internally is allocated, it is never modified.
10:06:12 <illissius> sticking to this externally-pure API, would unsafeDupablePerformIO ever be able to cause problems beyond worse sharing?
10:07:08 <Cale> hmmm
10:07:31 <Saizan> i don't think so
10:08:04 <Saizan> that's what bytestring is doing and i think they also use unsafeDupable or something even less secure? maybe check their code
10:08:12 <Cale> Oh really?
10:08:21 <illissius> Saizan: I know they use unsafeInline for reading from immutable ByteStrings
10:08:32 <illissius> but that may be a separate thing to what you're thinking of
10:08:43 <Cale> oh, yeah, they do
10:08:49 <illissius> (unsafeInline was, afaik, added for this specific purpose)
10:08:53 <Cale> unsafeCreate :: Int -> (Ptr Word8 -> IO ()) -> ByteString
10:08:53 <Cale> unsafeCreate l f = unsafeDupablePerformIO (create l f)
10:09:07 <illissius> ah, ok
10:09:33 <Cale> But that's the people who work on ByteString ;)
10:09:43 <Cale> (specifically Don Stewart)
10:11:14 <Cale> (He can get away with using that stuff, because he understands all the details of how it gets compiled.)
10:11:29 <illissius> would it be correct to say that for anything which is safe to unsafePerformIO, the difference caused by using unsafeDupablePerformIO instead will not be possible to observe from pure code (e.g. not IO)?
10:11:35 <Cale> But I dunno, maybe it's fine.
10:11:45 <illissius> whereas if you need to observe it impure ways from IO, you'll have problems
10:12:33 <illissius> if that would be correct then that would allow for a reasonably clear way of figuring out whether something is, in fact, safe to unsafeDupablePerformIO.
10:12:49 <Cale> illissius: Well, that's a little ill-defined in the case of things like allocating pointers, since the set of pure operations on pointers is pretty thin.
10:13:11 <Cale> and it's not even true for those...
10:13:40 <illissius> Cale: sure, but it's plenty possible to define compose impure operations into pure ones, that's the whole reason unsafePerformIO exists
10:13:44 <Cale> like if you fromIntegral . ptrToIntPtr
10:14:11 <Cale> and turn the pointer into an Integer
10:14:14 <illissius> s/define//
10:14:27 <Cale> Then you'll be able to see the difference between the two versions of the same variable.
10:14:43 <rribeiro> @type (flip elem)
10:14:44 <lambdabot> forall a. (Eq a) => [a] -> a -> Bool
10:15:36 <illissius> Cale: obviously you wouldn't be exposing the internal Ptr to the pure API :). newtype PureThingie = PureThingie (ForeignPtr Thingie) or so, where the constructor isn't exported.
10:16:10 <Cale> illissius: Yeah, I'm just a cautious but lazy person. I never want to have to think about whether something will really work in all circumstances when the proof is not obvious at all, and there's a safer way of doing things at hand.
10:16:34 <illissius> anyway, my *next* question would've been whether someone's actually measured the performance impact of unsafePerformIO over unsafeDupablePerformIO... :-)
10:16:54 <illissius> I just like understanding things for the own sake, but maybe I'll get around to measuring whether it's at all significant as well.
10:17:00 <illissius> *their
10:17:01 <Cale> I don't expect it to be very large.
10:18:44 <illissius> Cale: thanks for helping to think things through, I feel like I have a considerably better understanding now than I did.
10:20:17 <illissius> Cale: just out of curiosity, does your iPhone game run in unregisterised mode, or are you using a compiler other than GHC (or perhaps a custom ARM backend for it)?
10:21:19 <sshc> What's the current status of FRP for Haskell?
10:21:39 <sshc> Is there a standard / actively maintained package (with decent documentation)?
10:22:44 <illissius> sshc: there's multiple competing implementations, some are 'production quality', some not, but the One True FRP Way hasn't yet been found.
10:23:25 <illissius> there was a discussion about this just recently... check the logs (should be linked from the title)
10:23:35 <illissius> (or channel topic, or whatever.)
10:27:39 <mizu_no_oto> The reason for type IO a = RealWorld -> (a, RealWorld) is that it prevents ghc from reordering IO by introducing the data dependency, right?  However, in a non-optimizing compiler or interpreter, can't it ignore that story because it won't rearrange the code?  So long as everything typechecks, can't it desugar IO straight into ccall (i.e. primitive operations that can be sideeffecting) and...
10:27:41 <mizu_no_oto> ...`seq` (to make sure that IO is done in the right order) and toss the RealWorld out?
10:30:38 <illissius> mizu_no_oto: in GHC the RealWorld is a 0 byte variable. i'm not sure whether or not that's effectively the same thing.
10:30:55 <thoughtpolice> merijn: i just don't buy into the argument "we have always done X in Y way. why try any other possible way of doing things?"
10:31:39 <thoughtpolice> merijn: also, you're right games require state. i guess it's a good thing then that haskell has a lot of functionality for modeling state and doing it correct and safe ways. people like tim sweeney have talked about this; it's not about eliminating state, it's about factoring it out where necessary, and giving guarantees where you can't
10:33:52 <thoughtpolice> tim in particular gave a pretty good talk several years ago on what he would want in a language for game development, and he wanted a lot of the things haskell is good at: purity, isolation of side effects, safe concurrency primitives like STM offers, and good parallelism to boot. but he wanted more, tim even wants to go so far as dependent types.
10:36:41 <c_wraith> he also wants strictness.
10:36:57 <thoughtpolice> i think it's unsurprising people in such an industry want tools like this. games of such scale seem to be quite difficult, and error prone, to make. having tools that have better defaults and better ways of modeling the interactions your code has helps tremendously. but haskell isn't to the point you could use it in a AAA game like Rage or Gears of War (and it's possible it never will be)
10:37:11 <thoughtpolice> c_wraith: yep
10:38:19 <Eduard_Munteanu> Which Tim is that?
10:38:24 <thoughtpolice> Eduard_Munteanu: Tim Sweeney
10:38:34 <Eduard_Munteanu> I see.
10:38:36 <thoughtpolice> (guy who founded Epic games, they made unreal, gears of war, etc)
10:38:37 <luite> thoughtpolice: possibly not for the main game engine, but there are probably parts where it can already be used, maybe generating shader code for materials, generating AI code
10:39:08 <thoughtpolice> luite: definitely, code synthesis is something haskell makes a great language for in a lot of ways
10:39:14 <merijn> thoughtpolice: When did I ever say anything remotely resembling:  "we have always done X in Y way. why try any other possible way of doing things?"
10:39:20 <Eduard_Munteanu> Dependent types would make for a really nice language, even if you don't use them often.
10:39:31 <thoughtpolice> < merijn> descender: Games often times are just easier to program imperatively. Why invest lots of time fighting that?
10:39:57 <merijn> thoughtpolice: What I meant was that imperative is not by definition wrong
10:40:11 <thoughtpolice> then maybe i just missed the overall context
10:40:32 <thoughtpolice> (and you're right too, it isn't just 'wrong.')
10:40:33 <merijn> A lot of people coming from imperative languages seem to think "omg! I'm writing this imperatively in haskell, how do I fix this?!"
10:41:41 <merijn> If its easier to write it imperatively in haskell, I don't see why that would be bad. It might be interesting to write it non-imperative style, but if you're just learning and want to get stuff working (as in this case) then why torture yourself
10:42:26 <thoughtpolice> merijn: ah, yeah. i think in some ways as a language we've been misrepresented somehow. :/ i constantly find people have this idea that the goal of every haskell programmer is to eliminate all state everywhere, but it's not. it's about isolating and being able to reason about state/other various effects more easily
10:42:51 <dgpratt> merijn: who comes to Haskell just to get stuff working?
10:42:59 <merijn> dgpratt: True :p
10:43:12 <thoughtpolice> merijn: and fwiw, most of the original haskell programs i wrote were totally in IO, and i definitely think it's a pretty good imperative language :)
10:44:43 <dgpratt> seriously, though, I've made a concerted (but not entirely successfull) effort to teach myself how to program functionally in Haskell; I have to say I consider it well worth the effort
10:47:25 * hackagebot cnc-spec-compiler 0.2.0.0 - Compiler/Translator for CnC Specification Files.  http://hackage.haskell.org/package/cnc-spec-compiler-0.2.0.0 (RyanNewton)
10:47:45 <descender> merijn, it's not wrong to write a game (or just sections of it) imperatively, but  I came to Haskell to learn new ways of thinking, so I'm interested in having new ways to model (or replace) game states
10:53:39 <descender> which is why the first things I read learning Haskell wasn't to get a program working, but the 'weird' stuff like functors, monads, arrows, etc. they get me thinking about structural patterns in computations
10:54:31 <Eduard_Munteanu> I wonder if there's any argument whether imperative languages can't achieve brevity akin to FP language.
10:56:24 <sm> dgpratt, merijn: *I* came to haskell to get stuff working :)
10:57:15 <descender> (I might as well stick to C++ to write my Mahjong game otherwise)
10:57:21 <dgpratt> sm: that's what python is for
10:57:36 <sm> it was python that I left. I was sick of runtime errors
10:57:48 <Dashkal> I came to haskell to see if immutibility actually worked.  Seemed like such an insane concept at the time.
10:58:09 <sm> I came for the speed too
10:58:48 <Eduard_Munteanu> Am I the only one who came to Haskell just because it looked weird (in a 'fun' way)?
10:58:57 <thoughtpolice> Eduard_Munteanu: nope
10:58:57 <Eduard_Munteanu> :)
10:58:59 <descender> Eduard_Munteanu, no ;)
10:59:09 <descender> I like that it looks mathematical and succinct
10:59:21 <parcs> does anyone recommend a particular package that provides a Random monad transformer?
10:59:29 <Eduard_Munteanu> Yeah, succintness was quite impressive at first, I must admit.
11:00:51 * sm was also looking for something that would be relevant for a long time
11:01:02 <Eduard_Munteanu> Especially the (naive) quicksort example.
11:01:13 <Dashkal> Eduard_Munteanu: I didn't come to haskell for that reason, but I did stay for that reason
11:02:23 <merijn> I came because I started to outgrow python :p
11:02:26 * hackagebot th-lift 0.5.4 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.5.4 (MathieuBoespflug)
11:02:35 <merijn> Don't think I'll ever outgrow haskell...
11:02:41 <dylukes> Dashkal: It works fine really, provided the VM isn't retarded.
11:02:44 <dylukes> :)
11:02:48 <dylukes> or rather, runtime.
11:03:14 <Dashkal> dylukes: Even if it is retarded, you can get away with it more than I expected.
11:03:24 <dylukes> No, it's not retarded I mean.
11:03:37 <dylukes> By "retarded", I mean "no GC, no reusing boxes, etc
11:04:03 <Dashkal> Yeah, even without that you can get away with it much more than I believed before I learned Haskell
11:04:26 <dylukes> If you never free memory, you'll hit a wall on a non-theoretical machine.
11:04:29 <dylukes> :P
11:04:30 <Dashkal> There are definitely limits without GC and such, but I was broken into thinking it was always mutable all the time or you were just constrained.
11:04:47 <dylukes> It's the same with static typing.
11:04:53 <Dashkal> Oh yeah, and parallel code was prohibitively difficult after a certain point :P
11:05:09 <dylukes> C++/Java people insist static typing is restrictive and has no benefits, just because they're used to a bad type system (association fallacy).
11:05:10 <roconnor> parcs: MonadRandom?
11:05:33 <Dashkal> Java barely has static typing.
11:05:49 <dylukes> I suggest you look at Java again.
11:05:50 <roconnor> Dashkal: and C++ doesn't at all :D
11:05:50 <Eduard_Munteanu> I can't say I had a lot interest in Haskell as a tool, I was (actually am) mainly a C programmer and I wasn't particularly looking for a high-level language, given what I usually spent time coding on.
11:06:16 <merijn> dylukes: No, C++/Java insist that static typing is great
11:06:19 <thoughtpolice> C++ has a type system that can in fact, enforce invariants at compile type. it's just so ridiculously painful and verbose, nobody bothers
11:06:33 <dylukes> merijn: People who have used them, do not, however.
11:06:34 <Eduard_Munteanu> Yeah, static not-really-strong typing.
11:06:36 <thoughtpolice> but you can leverage that quite a bit, still.
11:06:38 <merijn> dylukes: People who've switched from those to python/ruby are the ones saying static typing is restrictive :p
11:06:48 <dylukes> *sigh*… scripting languages.
11:06:52 <descender> thoughtpolice, and the compile-time errors that result are ridiculously hard to read
11:06:53 <Dashkal> dylukes: I'm exaggerating, but only somewhat.  I used to be a full time Java developer.  I'm pretty familiar with its type system and its limitations.  They can be beaten to a degree (see FunctionalJava) but the "idiomatic way" fights what little benifit the type system gives.
11:07:13 <thoughtpolice> descender: yes, that's part of the painfulness :P
11:07:17 <dylukes> aaaaaand I just received 6 text messages, one moment
11:07:18 <merijn> imo the term scripting language has become completely meaningless
11:07:23 <parcs> roconnor: that was my first choice but MonadRandom doesn't provide a MonadError instance and it's probably broken on ghc 7.2 (uses data type contexts). i am there's a superior alternative to MonadRandom somewhere
11:07:42 <merijn> I can't look at something like Twisted and call python a "scripting language" with a straight face...
11:07:42 <descender> thoughtpolice, I still love C++ templates however, despite all the criticisms :D
11:07:42 <parcs> am hoping*
11:08:21 <merijn> descender: I love ASM, doesn't mean I want to do all my programming in it :p
11:08:23 <c_wraith> I really want a rank-2 MonadRandom.
11:08:25 <Dashkal> I'm sticking to calling python, ruby, etc, unityped or monotyped languages.  I think it's much more accurate than "dynamicly typed"
11:08:44 <merijn> Dashkal: No it isn't
11:08:50 <thoughtpolice> descender: the generic programming is certainly nice and without question what makes C++ considerably better than just C, among other things (actual ability to namespace is another one, even if they still are a little verbose)
11:09:00 <merijn> Dashkal: How is python monotyped?
11:09:01 <Dashkal> merijn: It is.  They have one type: "Dyn"
11:09:09 <efie> merijn: if i now for example say channel_2 [0,0,0,0] it does not return anything - instead i can now type everthing in die dialogbox. i guess that has to do something with the IO-monad, but mh id like to get the list
11:09:10 <roconnor> parcs: MonadError instance?
11:09:23 <merijn> Dashkal: No they don't, else you'd never get TypeError's
11:09:24 <Dashkal> Variables of that type can contain any value.  Be it a string, number, whatever.
11:09:39 <thoughtpolice> ROBERT HARPER TERMINOLOGY ALERT, ROBERT HARPER TERMINOLOGY ALERT. DANGER, DANGER WILL ROBINSON
11:09:44 <c_wraith> I want to have the only function in MonadRandom be:  (forall g. RandomGen g => g -> (a, g)) -> m a
11:09:55 <thoughtpolice> (actually harper is super smart, i just say that because he seems to set off people's flamethrowers whenever he writes :)
11:09:56 <merijn> DashkalL The variables may not be typed, but the values are
11:10:33 <merijn> And afaik there isn't a secret council of programming language gnomes which decided that only typing of variables counts...
11:10:46 <Dashkal> merijn: The "types" are just the domains of the functions.  There's still no typing to those functions.
11:10:51 <MichaelBurge> I have a data MyData = MyData { value1 :: Integer, value2 :: String, value3 :: (Integer,String) -> String} deriving (Show, Read, Eq) --- But this isn't legal because of value3. Is there a way to tell it to derive Show or Eq on everything except the invalid type?
11:11:03 <Dashkal> It's no different than throwing an error when you try to wait for a negative time
11:11:11 <c_wraith> MichaelBurge: you'll have to write the instances manually
11:11:15 <thoughtpolice> MichaelBurge: unfortunately not, you'll have to define a Show instance manually
11:11:20 <thoughtpolice> to ignore the constructor's 3rd argument
11:11:25 <descender> thoughtpolice, funnily I find that I get better at (abusing?) C++ templates after learning FP
11:11:35 <thoughtpolice> descender: not surprising :P
11:11:35 <wyfrn> as far as i know Integer is the only numeric type with a flexible size ... what about the conversion from Integer to Double? will overflows occur in the case of really big Integers?
11:11:45 <roconnor> MichaelBurge: not really.  The best you could do is newtype wrap (Integer,String) -> String and provide your own Eq instances for that newtype
11:11:47 <parcs> roconnor: yeah, from Control.Monad.Error in mtl
11:11:58 <descender> thoughtpolice, since you have to construct types in a functional manner
11:12:06 <c_wraith> > fromIntegral (2^100 :: Integer) :: Double -- wyfrn
11:12:06 <lambdabot>   1.2676506002282295e30
11:12:15 <merijn> Dashkal: You mean that the type checking happens at runtime rather then at compile time, making it a...dynamic process rather then static? :)
11:12:20 <c_wraith> wait, is 2^100 in the range of double?
11:12:22 <roconnor> parcs: you could patch MonadRandom to add one I guess.
11:12:22 <c_wraith> blay
11:12:26 <c_wraith> > maxBound :: Double
11:12:27 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
11:12:27 <lambdabot>    arising from a use o...
11:12:41 <c_wraith> > fromIntegral (2^10000 :: Integer) :: Double -- wyfrn
11:12:42 <lambdabot>   Infinity
11:12:46 <c_wraith> there's your answer
11:12:52 <merijn> Dashkal: No one claimed they were statically typed, but saying they are monotyped because checking only happens at runtime is nonsense
11:13:07 <parcs> roconnor: good idea.
11:13:42 <wyfrn> c_wraith: mhmm thx
11:14:55 <Dashkal> merijn: I'd like to continue this debate, but I don't have the time to do the topic justice.  We'll have to agree to disagree for now.
11:15:13 <merijn> Dashkal: Good, cause I have to run in 10 mins anyway ;)
11:15:34 <descender> declare truce?
11:16:14 <Dashkal> Programmers not starting holy wars?  Unpossible!
11:16:38 <merijn> Dashkal: Vim or emacs? :p
11:16:52 <Dashkal> vim.  Burn the heathens!
11:16:58 <c_wraith> notepad
11:17:03 <descender> but I use leksah..
11:17:11 <c_wraith> (I usually throw that in to be the sacrificial lamb)
11:17:28 <merijn> Sometimes I wish vim was more like emacs, though >.>
11:17:47 <Dashkal> Or, I learned vim before emacs and don't feel the need to climb that particular learning curve twice.
11:17:47 <dankna> sometimes I wish everything else were more like vim and emacs, but not so much that they actually WERE vim or emacs
11:17:49 <descender> vim reminds me of WordStar somehow
11:17:56 <Dashkal> Hell, I still use nano for quick changes.
11:18:03 <MichaelBurge> c_wraith, thoughtpolice: Thanks, that worked fine.
11:18:12 * dankna has used both vi (elvis though, not vim) and emacs for many years
11:18:13 <merijn> dankna: I now *insert reminder about Te here*
11:18:16 * merijn runs for cover
11:18:17 <dankna> oh, thanks :)
11:18:18 <dankna> hehe
11:18:20 <merijn> s/now/know
11:18:37 <dankna> that's a good project I can work on today without getting too deep
11:18:45 <dankna> somehow my real project and my fun light project flipped places
11:18:56 <dankna> when I started having to modify GHC to make type-level ints work the way I wanted them to...
11:21:42 <mjo-work> I'm reading http://en.wikibooks.org/wiki/Haskell/Denotational_semantics and I'm on the section titled "Partial Functions and the Semantic Approximation Order." It says "neither 1 <= 2 nor 2 <= 1". Is that correct? Aren't 1 and 2 equally-defined?
11:22:26 <Cale> mjo-work: right, so they're incomparable in the definability order
11:22:50 <mjo-work> Doesn't <= mean less-defined or equally-defined though?
11:22:57 <Cale> less defined or equal to
11:23:09 <c_wraith> oh, it's a lattice.  ok, yeah.
11:23:10 <mjo-work> Oh
11:23:19 <mjo-work> That's weird =)
11:23:19 <Cale> It's not quite a lattice
11:23:26 <c_wraith> Oh, you're right.
11:23:28 <c_wraith> Just a poset
11:23:30 <Cale> But it's a directed-complete partial order
11:23:42 <zygoloid> less-defined or equally-defined is right, but equally-defined doesn't mean what you think.
11:23:49 <merijn> Sometimes I feel like an uneducated barbarian in this channel :p
11:24:02 <dankna> indeed
11:24:04 <byorgey> 1 and 2 are not equally defined. 1 is defined to be 1 and 2 is defined to be 2.
11:24:13 <dankna> ohhhh
11:24:14 <byorgey> =)
11:24:15 <zygoloid> (_|_, 0) <= (1, 1) is false
11:24:34 <mjo-work> Thanks. I see where I mis-read now.
11:24:45 <c_wraith> this is where conal's lub and glb operators show up.
11:25:30 <c_wraith> the greatest lower bound of 1 and 2 is _|_, for instance.
11:26:16 <kamaji> I think i've asked this before and forgotten - is there a splitWhile function in the standard libraries?
11:26:41 <mjo-work> (I'm obviously in over my head, but,) that would be GLB/LUB with respect to that square-cup-definiedness relation, right.
11:26:42 <Cale> kamaji: what would that do?
11:26:48 <Cale> kamaji: span/break?
11:27:10 <kamaji> oh, break
11:27:13 <Cale> > span even [2,4,6,8,1,3,5,10,12]
11:27:13 <kamaji> I just rememberd hoogle
11:27:14 <kamaji> hehe
11:27:14 <lambdabot>   ([2,4,6,8],[1,3,5,10,12])
11:27:20 <kamaji> wait, what's span?
11:27:31 <c_wraith> it breaks a list into two lists
11:27:34 <Cale> span p = break (not . p)
11:27:49 <kamaji> Ah
11:27:55 <kamaji> I thought they were the same there
11:28:03 <c_wraith> oh, I was thinking partition, I think.  but, you know, whatever.
11:28:06 <c_wraith> :t partition
11:28:07 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:28:10 <c_wraith> yeah.
11:28:18 <kamaji> coolbeans
11:28:19 <kamaji> thanks
11:28:29 <c_wraith> partition is not like span or break.
11:28:42 <c_wraith> it's worth knowing what they all do. :)
11:30:51 <albertid> It seems like ghc --interactive assumes -threaded. Is that correct?
11:31:39 <c_wraith> no..  It actually interprets, which is something different yet.
11:32:07 <Eduard_Munteanu> That's just ghci, no?
11:32:16 <c_wraith> also, you use --interactive instead of just running ghci? :)
11:33:01 <albertid> Nah, I was just investigating an issue that performed differently with --make and --interactive
11:33:42 <albertid> with --make (without -threaded) forkIO did not work, with --interactive it did
11:33:49 <albertid> but anyway, it works now
11:33:51 <thoughtpolice> er, and it actually doesn't *completely* interpret either, because GHCi typically will load object code :P
11:34:04 <c_wraith> forkIO works fine without -threaded, btw
11:34:37 <c_wraith> it just won't run two different haskell threads simultaneously, because it only is using on OS thread for haskell code.
11:34:51 <albertid> c_wraith, I used alsa, gtk, TChan in the subprocesses, maybe one of those needed -threaded
11:34:56 <c_wraith> but it still context-switches between them.
11:35:01 <descender> albertid, ah so that was your problem; I ran into a similar issue with running my SDL/OpenGL code in ghci (won't work) and I still don't quite understand why
11:35:07 <c_wraith> oh.
11:35:13 <c_wraith> ghci runs code in the wrong thread
11:35:23 <c_wraith> except there was an option added recently to fix that.
11:35:31 <c_wraith> But I don't remember the name of it.
11:35:58 <MichaelBurge> Is there a way to add typeclasses that thread themselves over a type the same way that Show does in data Cat = Cat { name :: String, age :: Integer} deriving (Show) ?
11:36:11 <c_wraith> the problem is using C libraries that depend on all accesses to them being from the same thread.
11:36:15 <albertid> descender, weird. and hard to find the bug.
11:36:38 <thoughtpolice> MichaelBurge: you mean, is it possible to write a typeclass for which you can derive it for arbitrary types, using 'deriving' clause?
11:36:42 <albertid> c_wraith, ah
11:36:48 <merijn> MichaelBurge: You mean implementing your own automatic derivation of typeclasses? AFAIK that's not possible, but I might be wrong
11:36:51 <thoughtpolice> MichaelBurge: because if so, then yes you can!
11:36:58 <thoughtpolice> (but only as of ghc 7.2)
11:37:00 <albertid> thing is, it worked in ghci :)
11:37:04 <thoughtpolice> which was released like 3 days ago :P
11:37:07 <merijn> Ha! I'm glad I hedged my answer :p
11:37:23 <c_wraith> MichaelBurge: I think you mean adding contexts on your instances?  If that's what you mean, you can do instance Show x => Show (Foo x) where ...
11:37:29 * hackagebot haskell-src-exts-qq 0.5.0 - A quasiquoter for haskell-src-exts.  http://hackage.haskell.org/package/haskell-src-exts-qq-0.5.0 (MathieuBoespflug)
11:37:41 <merijn> thoughtpolice: How does that work, because that sounds awesome :>
11:37:43 <descender> albertid, that's a better problem to have, in some sense.. at least you could debug in ghci..
11:38:29 <thoughtpolice> merijn: i mean, yeah, it's really recent. but it's pretty cool. people have had to implement all sorts of TH hackery to auto-derive things, now it looks like you can use the new generic deriving mechanism for all that
11:39:22 <kmc> thoughtpolice,  wait, what's the new deriving magic?
11:39:28 <kmc> -XGenerics?
11:39:48 <thoughtpolice> merijn: the TL;DR is you derive 'Generic' for your data type, which automatically gives you a sum-of-products view of your ADT, you write a generic class over those sums-of-products types, and then people add 'deriving Generic' to their own data types, and add an empty class instance
11:39:53 <thoughtpolice> (basically)
11:40:03 <kmc> -XGenerics isn't not new
11:40:05 <thoughtpolice> kmc: http://haskell.org/ghc/docs/7.2.1/html/users_guide/generic-programming.html
11:40:06 <kmc> isn't new*
11:40:09 <thoughtpolice> merijn: http://haskell.org/ghc/docs/7.2.1/html/users_guide/generic-programming.html
11:40:10 <kmc> i guess it changed?
11:40:15 <thoughtpolice> kmc: yes, this is completely new stuff
11:40:15 <kmc> thanks
11:40:31 <merijn> thoughtpolice: Nice :)
11:40:57 <kmc> very cool
11:41:02 <MichaelBurge> thoughtpolice: That sounds really nice - is it a stable feature at all, or will it be a long time before we can actually use it?
11:41:03 <kmc> this is totally new
11:41:15 <thoughtpolice> MichaelBurge: yes, you can use this now, but it's a new feature in GHC 7.2.1
11:41:48 <thoughtpolice> MichaelBurge: note that GHC 7.2.1 is intended as a 'preview' for the most part. 7.4.1 will be out shortly later this year as a more 'stable' release.
11:41:55 <thoughtpolice> personally, the 'preview' part doesn't scare me, but YMMV :P
11:42:02 <kmc> it's not a standard language feature and therefore is subject to change
11:42:10 <kmc> GHC extensions can change or become deprecated
11:42:14 <thoughtpolice> yes, kmc is right. extensions change all the time
11:43:34 <thoughtpolice> kmc: on the note of the old -XGenerics, has anybody *ever* seen them used before? i don't honestly ever think I've seen the old stuff in any code in-the-wild
11:43:42 <c_wraith> Huh.  I thought it was a bit early for a new GHC version.  I see I was essentially right.
11:43:54 <thoughtpolice> c_wraith: i think 7.4.1 is scheduled for 'sometime around ICFP'
11:43:57 <thoughtpolice> later this year
11:44:38 <MichaelBurge> Is it safe to use extensions if you want your code in Hackage or other public-facing code?
11:45:02 <c_wraith> well.  It's fine, but your code may not compile if the extension is changed in a future version of GHC.
11:45:13 <c_wraith> But people do it all the time, because some extensions are just *so* useful.
11:45:41 <c_wraith> I mean.  parts of GHC's base library are defined in terms of the Rank2Types extension.
11:45:55 <kmc> "The linker now supports kfreebsdgnu."
11:46:01 <kmc> helllll yess
11:46:07 <c_wraith> Though that extension is very unlikely to ever change.
11:46:17 <thoughtpolice> MichaelBurge: yes, you can. nobody will veto you. :) but c_wraith is correct that your code may not compile in the future, if the extension is changed or dropped from GHC. there's no guarantee on the lifetime or stability of non-standard extensions
11:46:20 <kmc> MichaelBurge, there's a wide range of extensions
11:46:31 <kmc> from "everyone agrees this will be in the spec eventually" to "omg what is that"
11:46:43 <kmc> unfortunately there's not like a great breakdown of which extensions are which
11:46:46 <kmc> to my knowledge
11:46:57 <c_wraith> Rank2Types will be in the spec eventually, right? :)
11:46:57 <thoughtpolice> MichaelBurge: but some are much more widely accepted, used and battle-tested/'stable' than others
11:47:16 <thoughtpolice> kmc: that would be a good thing to jot down maybe
11:47:20 <kmc> the build is more likely to break due to library changes anyway
11:47:25 <thoughtpolice> yea
11:47:26 <kmc> thoughtpolice, yeah, there should be a wiki page
11:47:33 <kmc> also noting the extent to which you need to be careful
11:47:51 <kmc> like UndecidableInstances is pretty safe, but IncoherentInstances can get you in big trouble
11:47:53 <c_wraith> UndecideableInstances?  Safe, despite the scary-sounding name.
11:47:58 <c_wraith> heh.  I was just going for that example
11:47:59 <kmc> yeah
11:47:59 <thoughtpolice> yeah
11:48:15 <kmc> -XUndecidableRegisterAllocation
11:48:25 <thoughtpolice> although 'IncoherentInstances' does not exactly give me the impression of being not-scary, tbqh
11:48:55 <c_wraith> Well, it sounds scary, sure.  But it doesn't sound much more scary than UndecideableInstances.
11:49:00 <c_wraith> But it should!
11:49:23 <descender> wow is that a real type / class?
11:49:32 <thoughtpolice> descender: it's an extension
11:49:34 <c_wraith> They're extensions to the language
11:49:38 <kmc> "Cross-compilation is now supported by hsc2hs, for most features"
11:49:38 <c_wraith> to the type-checker, in particular
11:49:51 <descender> ah
11:50:29 <thoughtpolice> descender: UndecidableInstances for example sounds 'unsafe' but it will never cause GHC's typechecker to not-terminate on an undecidable instance, is what c_wraith/kmc were getting at, for example.
11:50:41 <mwc> What's the state of detailed-1.0 in cabal test-suite? Is it ready for use or should we stick to exitcode? I ask because cabal-test-quickcheck2 isn't on Hackage, isn't yet compatible with ghc 7.2, etc, seems like it's still in development
11:50:42 <c_wraith> I'm pretty sure that you can use IncoherentInstances to get GHC to spit out code that will segfault.
11:50:46 <thoughtpolice> on the other hand, IncoherentInstances or even orphans can just straight up break your program
11:50:49 <thoughtpolice> in very bad ways
11:51:16 <descender> thoughtpolice, makes perfect sense
11:51:37 <kmc> "both TypeRep and TyCon now have Ord instances which means they can be used as Map keys."
11:51:58 <c_wraith> more importantly, TyCons are pure now.
11:52:03 <rwbarton> my type is bigger than your type
11:52:03 <thoughtpolice> kmc: yeah, i remember talking with the guy at bayhac who did all the cross compilation work for hsc2hs. he was really nice.
11:52:12 <kmc> "it will never cause GHC's typechecker to not-terminate on an undecidable instance?"
11:52:32 <thoughtpolice> er, GHC will never loop endlessly, would have been a better way to say it
11:53:13 <kmc> oh
11:53:19 <kmc> well even if it does, meh
11:53:27 <kmc> extensions that could break the build are okay
11:53:30 <kmc> those are called "the type system" ;)
11:53:43 <kmc> it won't produce weird wrong code
11:53:51 <thoughtpolice> true
11:54:03 <c_wraith> In any case, UndecideableInstances is built with a maximum traversal depth, so it will terminate with an error message rather than looping forever. :)
11:54:17 <thoughtpolice> i think i should be able to tell GHC to forgo the traversal depth. -fundecidable-instances-limit=over9000 anyone?
11:54:31 <descender> kill -9 ghc might work too
11:54:39 <rwbarton> can orphan instances actually make your code segfault? maybe with fundeps/associated types?
11:54:48 <descender> killall -9 ghc I meant
11:54:49 <c_wraith> orphan instances shouldn't cause segfaults.
11:55:04 <c_wraith> they just can cause an innocuous-looking import to break your program
11:55:15 <c_wraith> in the "won't compile anymore" sense
11:55:16 <dolio> They cannot cause segfaults as implemented, at least.
11:55:36 <c_wraith> IncoherentInstances can do worse, in terms of "suddenly a different instance than the one you expected is being used"
11:55:47 <dolio> With overlapping instances, one could imagine it.
11:55:49 <rwbarton> oh I see, I sort of read two sentences at once
11:56:21 <c_wraith> and yes.  OverlappingInstances sounds *way* too harmless.
11:56:33 <dolio> Of course, you can cause problems with overlapping instances without orphans.
11:57:35 <danharaj> Would orphans be a non-issue if you could specify instances in import/export lists?
11:57:57 <rwbarton> that way I think you can get crashes
11:58:03 <rwbarton> if you could not export instances
11:58:51 <kmc> thoughtpolice, the syntax should be -fundecidable-instances-limit=∞
11:58:51 <danharaj> ah yes I suppose that would lead to incoherent instances.
11:59:39 <thoughtpolice> toooo infinity, aaaaand beyooond!
12:11:48 <edwardk> danharaj: no, this would be bad
12:11:49 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
12:13:10 <dankna> merijn: got Te building again!
12:14:16 <dankna> @tell merijn I got Te building again - it turned out not to be bitrot in my code at all, but a very creative way for Cabal to find a stale copy of itself
12:14:16 <lambdabot> Consider it noted.
12:15:32 <dankna> @tell dcoutts I just had time to check over my patches towards Mac-app-bundle building and found that they're not actually bitrotten after all, I had just been using a stale Cabal in dist/Setup due to a too-low version number.  So you can review them if you want. :)
12:15:33 <lambdabot> Consider it noted.
12:21:50 <edwardk> did we squelch hackagebot again?
12:22:28 * hackagebot keys 2.1 - Keyed functors and containers  http://hackage.haskell.org/package/keys-2.1 (EdwardKmett)
12:22:30 * hackagebot reducers 0.1.4 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-0.1.4 (EdwardKmett)
12:22:32 * hackagebot vector-instances 2.0.1 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-2.0.1 (EdwardKmett)
12:22:34 * hackagebot representable-functors 2.0.1 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.0.1 (EdwardKmett)
12:31:33 <Eitaro> Hello, all. Just checking out Haskell
12:32:33 <pigdude> noob question...let's say i want a function "second l" that returns the second item of a list, if that list is long enough. second l = if length l > 1 then l !! 1 else ...
12:32:38 <pigdude> what would i put in that else?
12:33:03 <fryguybob> Is there somewhere in base with   instance Functor (Either e) ?
12:33:06 <shachaf> pigdude: Well, you can't really do much if the type is [a] -> a
12:33:20 <shachaf> fryguybob: Control.Monad.Instances
12:33:30 <fryguybob> shachaf: Thanks!
12:33:32 <pigdude> shachaf, meaning input is list, output is list member?
12:33:33 <shachaf> pigdude: You can give it the type [a] -> Maybe a
12:33:41 <pigdude> shachaf, what might that look like?
12:34:13 <shachaf> pigdude: By the way, length is a really bad function to use there. It'll walk the entire list (so it'll just hang on an infinite list, for example).
12:34:18 <dolio> @type listToMaybe . drop 1
12:34:19 <lambdabot> forall a. [a] -> Maybe a
12:34:31 <geheimdienst> pigdude: one possibility is to use Maybe: "if length l > 1 then Just (l !! 1) else Nothing". this would be similar to "return null" in a javaish language, except cooler ;-)
12:34:45 <pigdude> ok, i think i am moving too quickly :^)
12:34:53 <pigdude> thanks for showing me the possibilities
12:35:08 <ion> > (\l -> if length l > 1 then Just (l !! 1) else Nothing) [0..]
12:35:10 <pigdude> i'll explore this Maybe type, and other approaches to list operations, as i go along
12:35:15 <ion> > (listToMaybe . drop 1) [0..]
12:35:17 <pigdude> Nothing, that is what i was looking for, sort of
12:35:20 <pigdude> good to know about it
12:35:38 <lambdabot>   thread killed
12:35:38 <lambdabot>   thread killed
12:35:40 <Enigmagic> pigdude: "second (_:v:_) = Just v; second _ = Nothing"
12:35:40 <ion> > (listToMaybe . drop 1) [0..]
12:35:46 <shachaf> pigdude: It's pretty different from "null" in other languages, though.
12:35:48 <lambdabot>   mueval-core: Time limit exceeded
12:35:53 <ion> eh.
12:35:57 <pigdude> shachaf, i expect so :^)
12:37:19 <geheimdienst> shachaf: "different" in the sense of "not botched"
12:37:29 * hackagebot cnc-spec-compiler 0.2.0.1 - Compiler/Translator for CnC Specification Files.  http://hackage.haskell.org/package/cnc-spec-compiler-0.2.0.1 (RyanNewton)
12:37:36 <EvanR7> so if i have equations of the form Axyz + Bxy + Czy = D, etc
12:37:36 <pigdude> why does haskell reject `head tail [1, 2]`?
12:37:43 <EvanR7> what do i do?
12:37:55 <DrSyzygy> pigdude: Bracketing.
12:38:16 <EvanR7> obviously non linear
12:38:17 <dolio> You have a beer.
12:38:24 <ion> head tail a = (head tail) a, not head (tail a)
12:38:27 <pigdude> DrSyzygy, i'm not sure i understand
12:38:33 <pigdude> oh, i see
12:38:36 <DrSyzygy> Look at what ion wrote.
12:38:37 <geheimdienst> pigdude: also, pattern matching is often a little nicer. this is the solution Enigmagic suggested. whenever writing if then else, you might want to mentally check if you could get there cleaner with pattern matching
12:38:52 <pigdude> geheimdienst, yea, that is something i recall with erlang
12:41:16 <grammer> 96.2% of the people who read this will not have the guts to re-post this.When Goku died in the explosion with Cell, he thought of both you and me. If you are part of the 3.8% that doesnt feel ashamed to love Goku, repost this. Thank you Goku. I as well lifted up my arms when you asked for energy for the spirit bomb.
12:42:39 <dolio> preflex: seen monochrom
12:42:40 <preflex>  monochrom was last seen on #haskell 17 hours, 34 minutes and 22 seconds ago, saying: msword users tend to be white collars with strict dress code and hygiene code
12:43:25 --- mode: ChanServ set +o Saizan
12:43:35 --- mode: Saizan set +b *!*grammer@*.hr.hr.cox.net
12:43:36 --- kick: grammer was kicked by Saizan (grammer)
12:43:50 --- mode: Saizan set -o Saizan
12:45:04 <brisingr> I've just asked someone to teach me monads for 5 beers.
12:45:08 <brisingr> is it worth it?
12:45:45 <Cale> by the end of the 5 beers, it might not be so easy to understand
12:46:25 <DrSyzygy> brisingr: I'd tell you what made ME understand monads for far less than 5 beers.
12:46:39 <brisingr> go ahead - I'm on the clock 'till 22 aug
12:46:40 <brisingr> :)
12:46:45 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation
12:46:49 <DrSyzygy> OTOH, if you can get someone to tell you what YOU need to hear to understand monads, then 5 beers might be cheap.
12:46:53 <Cale> http://www.haskell.org/haskellwiki/Monads_as_containers
12:46:54 <edwardk> DrSyzygy: getting the ph.d is cheating ;)
12:46:59 <DrSyzygy> edwardk: Pbtbtbt.
12:47:10 <DrSyzygy> edwardk: Also, my PhD studies were only VERY tangentially helpful.
12:47:18 <edwardk> it is like having the cheat codes
12:47:29 * hackagebot adjunctions 2.0.2 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.0.2 (EdwardKmett)
12:47:31 * hackagebot compressed 0.1.2 - Compressed generators and reducers  http://hackage.haskell.org/package/compressed-0.1.2 (EdwardKmett)
12:47:32 <brisingr> it's like MAKING the cheat codes
12:47:33 * hackagebot kan-extensions 2.0.1 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.0.1 (EdwardKmett)
12:47:47 <DrSyzygy> brisingr: Nah. My PhD was in computational algebra, not in programming language design.
12:48:06 <brisingr> but it's still cool, and that's what matters
12:49:33 <brisingr> btw, thanks for the links guys
12:50:27 <mekeor> brisingr: how did you progress with your haskell presentation?
12:52:02 <pedro3005> is there a factorial function in the std lib?
12:52:03 <brisingr> well, I'll try something different
12:52:17 <edwardk> > product [1..4]
12:52:18 <lambdabot>   24
12:52:21 <pedro3005> i know
12:52:22 <thoughtpolice> kmc: so did you ever try breaking safe haskell?
12:52:29 * hackagebot representable-tries 2.0.2 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.0.2 (EdwardKmett)
12:52:32 <pedro3005> but i thought there could be a more efficient version implemented
12:52:33 <brisingr> let's say I'm relearning everything and try to transpose it into my presentation
12:52:43 <edwardk> pedro3005: there isn't one in the stdlib
12:52:50 <pedro3005> alright
12:53:04 <edwardk> @type product . enumFromTo 1
12:53:07 <lambdabot> forall a. (Num a, Enum a) => a -> a
12:53:10 <brisingr> whoa, the examples over there at haskell.org really do make sense
12:53:44 <Cale> brisingr: which examples?
12:53:50 <mekeor> brisingr: after having learned haskell, of course, yep :]
12:54:14 <brisingr> the ones in monads as computation
12:55:02 * mekeor still doesnt understand monads oO (and actually didnt need them yet (he mainly does thing without IO))
12:55:25 <brisingr> I like especially the do-notation
12:55:59 <mekeor> i dislike the do-notation 'cause it's to imperative-style
12:56:12 * monochrom likes it imperative
12:56:43 <ion> mekeor: What’s wrong with that?
12:56:56 <brisingr> no, I mean, the do-notation explanation
12:57:01 <brisingr> it makes the monads make sense
12:57:09 <brisingr> and just thinking aloud here
12:57:26 * monochrom these days writes in mixed style, do { y <- m >>= \x -> g 0 x 1 2; ... }
12:57:47 <Lycurgus> breaking purportedly safe haskell should have a small monetary reward
12:57:48 <brisingr> but aren't the monad laws merely describing an identity element and the associativity rule?
12:58:27 <monochrom> yes, merely
12:58:51 <brisingr> I like that
12:59:14 <edwardk> brisingr: that is exactly it. monads are basically describing a monoid-like structure
12:59:33 <brisingr> it makes sense
13:00:06 <pedro3005> I'm doing
13:00:06 <monochrom> my http://www.haskell.org/haskellwiki/Monad_laws shows why the laws rationalize the do-notation, i.e., various flattenings of do-blocks are legit
13:00:09 <pedro3005> let s n k = 1 / (fromIntegral $ factorial k) * sum $ map (\j -> (-1)^j * (k `choose` j) * (k - j)^n) [0..k]
13:00:18 <mekeor> brisingr: can you post the link form on which you read that stuff? i'd like to learn monads, too =)
13:00:25 <pedro3005> oh wait I see what's wrong
13:00:29 <brisingr> http://www.haskell.org/haskellwiki/Monads_as_computation
13:00:40 <mekeor> thx
13:00:47 <pedro3005> ok, now I am doing
13:00:48 <monochrom> (it doesn't indicate me as author, but it came from my post on the haskell-cafe mailing list)
13:00:53 <ion> Also read the Typeclassopedia.
13:00:56 <pedro3005> let s n k = 1 / (fromIntegral $ factorial k) * (sum $ map (\j -> (-1)^j * (k `choose` j) * (k - j)^n) [0..k])
13:00:59 <pedro3005> and it says
13:01:07 <pedro3005> Ambiguous type variable `t' in the constraints
13:01:12 <pedro3005> what's wrong?
13:01:27 <brisingr> mekeor: have fun
13:02:16 <pedro3005> (it's this: http://upload.wikimedia.org/math/d/5/f/d5f62848c8c1378ce61f4d0dd8aeb4af.png )
13:04:17 <pedro3005> oh nvm
13:04:23 <pedro3005> found a better way
13:04:52 <kmc> thoughtpolice, not yet
13:05:07 <kmc> thoughtpolice, i was also thinking of auditing the GHC RTS for C-style memory bugs
13:05:57 <thoughtpolice> kmc: i've thought about that too in the past. haven't taken the time to actually do it yet
13:06:11 <Peaker> In :set +m   mode -- ghci keeps changing my shell prompt string from a nice lambda to the millions-of-imported-modules line
13:06:14 <Peaker> any way to stop that?
13:06:33 <Peaker> (also, it would be nice if +m was smart and only opened a new line if syntactically something was missing..)
13:07:29 * hackagebot algebra 2.0.1 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-2.0.1 (EdwardKmett)
13:09:40 <edwardk> question, are there any parsec-clones out there that carry the swierstra and duponcheel style static parser information round for when they are used applicatively or in a discarded context?
13:10:07 <edwardk> i know uu-parsinglib does this, but its also breadth-first
13:12:27 <descender> Peaker, :set prompt "ghci>" ?
13:12:32 <geheimdienst> peaker, what is ":set +m mode"? i can't find it in the docs
13:17:29 * hackagebot trifecta 0.25 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.25 (EdwardKmett)
13:22:38 <edwardk> what command can i feed ghci to get it to not span me with 50 package names when i run something?
13:22:42 <edwardk> er spam
13:24:04 <edwardk> (e.g.) to suppress the
13:24:04 <edwardk> Loading package unix-2.4.2.0 ... linking ... done. message
13:28:53 <edwardk> :set -v0 seems to have done it
13:29:28 <Peaker> geheimdienst, descender: I think :set +m is new from 7.2.1, and goes into multi-line mode automatically. when it does so, it does not use the usual :set prompt, but its own prompt involving a list of ALL modules imported (bazillions!)
13:32:08 <int80_h> I'm writing a management daemon that checks a directory every time a USRSIG1 is sent to it. I have an MVar that I use (in part) to track how many signals have been sent. This number is how many times the directory needs to be checked. This sounds like a for loop prblem to me, I'm having difficulty using the Haskell Way to think about this. Could someone offer some insight on how to think about this other than a loop. If I should use a loo
13:32:37 <kmc> :t forever
13:32:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
13:32:41 <kmc> @src forever
13:32:42 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:32:48 <kmc> forever x = x >> forever x
13:33:04 --- mode: ChanServ set +o Saizan
13:33:15 <kmc> that's a loop; so is mapM, and forM = flip mapM
13:33:22 --- mode: Saizan set -b *!*grammer@*.hr.hr.cox.net
13:33:45 --- mode: Saizan set -o Saizan
13:34:48 <geheimdienst> > replicate 2 (print "lolcats")
13:34:49 <lambdabot>   [<IO ()>,<IO ()>]
13:35:30 <geheimdienst> int80_h: if you want to run your IO action N times, maybe replicate can help you
13:35:46 <geheimdienst> you can use sequence on the list:
13:35:50 <geheimdienst> :t sequence
13:35:50 <kmc> :t replicateM
13:35:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:35:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
13:35:56 <kmc> :t replicateM_
13:35:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
13:36:06 <kmc> int80_h, there's nothing "un-haskelly" about loops
13:36:20 <kmc> loop constructs in Haskell are ordinary functions, not magical built-in syntax
13:36:36 <int80_h> kmc: gotcha
13:36:37 <geheimdienst> neat, didn't know about replicateM
13:36:46 <kmc> int80_h, Haskell is a great imperative language
13:36:50 <scooty-puff> is there a way to lazily query if an IntSet size matches some predicate
13:36:53 <int80_h> yeah thatnks for the tips :)
13:37:03 <scooty-puff> i.e. not in O(n) time
13:37:30 * hackagebot csv-enumerator 0.9.2.1 - A flexible, fast, enumerator-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-enumerator-0.9.2.1 (OzgunAtaman)
13:37:34 <kmc> you can use imperative programming, it's just that you have alternatives
13:37:43 <kmc> and can pick the best tool for the job
13:37:49 <int80_h> kmc: I've noticed. Also someone said in /r/haskell (I think) that haskell forces you to learn the functional model, but is a multi-paradigm language
13:37:50 <kmc> and this is seen as insane and revolutionary, of course
13:37:55 <kmc> yes
13:38:26 <kmc> though the whole "paradigm" concept is kind of bankrupt to begin with
13:38:42 <int80_h> because it gets thrown out the window when it's inconvinient?
13:38:50 <scooty-puff> like for IntSet.size > 5, i tried null . drop 5 . IntSet.toList
13:38:58 <kmc> languages can help or hinder a particular style of code, but they can rarely force or prohibit
13:39:17 <kmc> my pet example is the Linux kernel, which is written in GNU C and uses FP and OOP styles throughout
13:39:28 <scooty-puff> hmm, nm, looks like its because fromList is strict
13:39:41 <kmc> actually the OOP in C / FP in C thing is really common
13:39:43 <kmc> look at any GUI lib
13:39:48 <int80_h> I'd like to see someone use SmallTalk in a procedural style.
13:39:50 <kmc> it's just clunky and nasty
13:40:10 <kmc> the best argument that FP is useful is that people already go out of their way to do it, even when it's inconvenient
13:42:12 <Onibaba> Is the lecture series "Jurgen Giesl Functional programming using Haskell" from 2005 any good for a beginner like myself? :)
13:43:27 <geheimdienst> kmc, what would be an example of FP in C? passing function pointers around?
13:43:53 <c_wraith> CPS-transformed C code!
13:44:24 <c_wraith> geheimdienst: yes, in fact.  qsort, even
13:45:03 <edwardk> can you do qualified imports in ghci?
13:45:05 <int80_h> I had no idea that when I was making arrays of function pointers, I was using FP style.
13:45:16 <c_wraith> edwardk: I think you can in new enough versions of ghci
13:45:23 <c_wraith> edwardk: I think that was added in 7
13:45:41 <geheimdienst> edwardk: i think recent ghcis have an improved import command. istr hearing that it now can do anything an import in source code can do
13:46:04 <c_wraith> just use import, rather than :m
13:46:10 <edwardk> sweet!
13:46:22 <edwardk> i always used :m + … to import stuff
13:46:51 <c_wraith> :m is still the only way to take something out of scope, or reset the import list.
13:47:02 <c_wraith> but to add stuff to it, you can use import lines
13:47:58 <edwardk> thats fine. it is a lot less verbose to say T.span than Text.Trifecta.Diagnostic.Rendering.Span.span ;)
13:48:14 <c_wraith> looks like a bit of an improvement
13:48:20 <edwardk> a bit
13:51:04 <handonson> I have b :: ByteString. If I { append (take 3 b) (drop 3 b) }, will there be a memory copy?
13:51:39 <handonson> if so, how many copies will there be?
13:52:07 <dolio> Yes, there will be a copy.
13:52:27 <dolio> Well, actually, is this a strict or lazy bytestring?
13:52:34 <handonson> strict.
13:52:47 <parcs> there will be one copy
13:53:06 <dolio> Okay. Then probably one copy of both pieces into a result array.
13:53:08 <edwardk> parcs: append
13:53:35 <edwardk> you can also use InternedByteString ;)
13:53:39 <dolio> Or count that as two copies if you wish.
13:54:12 <edwardk> in which case it'll spot the fact that it has already interned the longer string if you go to intern the second one and give you the original
13:55:17 <dainanaki> Hey all, I've got an interesting error in an app that I'm working on that has an interpreter built into it. It keeps telling me "Interpreting Error(s):
13:55:18 <dainanaki> Couldn't match expected type `Zoom.Demand.CLI.CLI'
13:55:18 <dainanaki>             with actual type `GHC.Prim.Any'"
13:55:33 <dainanaki> Here's the line that's causing the issue: https://github.com/iand675/Zoom/blob/master/Zoom/Interpreter.hs#L50
13:55:54 <dainanaki> Can someone help me figure out what I'm doing wrong?
13:56:08 <ddarius> edwardk solves memory leaks by making them part of the semantics.
13:56:38 <edwardk> =)
13:56:46 <elliott> When using deriveAccessors from data-lens-template, I note that I have to put the statement after all the types that my fields hold are declared; for instance, if I have a field of type [T Int], then I cannot put the deriveAccessors before the definition of T. This is quite annoying for me since I have a lot of types depending on each other and it would be confusing/ugly to have my deriveAccessors after all my type declarations.
13:57:20 <edwardk> elliott: i can't really control which order template haskell is eligible to be run in
13:57:20 <elliott> The error I get is simply of an undeclared type on the line of the field; I've determined the relevant deriveAccessors causes it with -ddump-splices.
13:57:31 <elliott> edwardk: Yeah... it feels like this is a hole in TH's API, though.
13:57:41 <elliott> Surely it should be able to "partially" reify a type?
13:58:07 <edwardk> TH solves a hard problem. it has to interleave with type checking in scary ways
13:58:08 <ddarius> I don't see why it should surely be able to do that.
13:58:28 <elliott> ddarius: Well, because it annoys me that it can't right now :-)
13:58:37 <edwardk> so the things it should obviously be able to do are somewhat less obvious when you are the guy writing it ;)
13:58:44 <ddarius> elliott: I await your patch to GHC.
13:58:55 <elliott> edwardk: Reminds me of most "obvious" Haskell optimisations.
13:59:17 <elliott> ddarius: If I had the knowledge and the time I'd give it a go but I have neither, so I'll just frown a bit and move the statements.
14:00:23 <dainanaki> elliott: I can help you a bit!
14:00:25 <dainanaki> :(
14:00:27 <dainanaki> :(
14:00:38 <elliott> dainanaki: I briefly thought you meant with my real problem.
14:00:41 <elliott> dainanaki: Now I am even sadder. :(
14:02:46 <dainanaki> OK, now wtf is a skolem?
14:03:03 <ion> It’s like a burrito.
14:03:24 <dainanaki> that's good news.
14:04:27 <handonson> Is there a way to write a B.take1While that takes the first element without test and then works just like B.takeWhile?
14:05:33 <shachaf> handonson: Yes, but maybe not in terms of the exposed ByteString API.
14:05:48 <handonson> I think many attoparsec parsers will have performance advantage with this function. (B.span1 to be precise)
14:07:26 <Saizan> dainanaki: if you mean as in "skolem variable" in ghc's errors then it's one that unifies only with itself
14:08:05 <Saizan> IOW it's a true type variable rather than a meta variable used by the inference algorithm
14:08:57 <kmc> geheimdienst, not function pointers by themselves
14:09:39 <kmc> struct closure { int (*code)(void *); void *free_vars };
14:09:54 <kmc> this is a very common pattern in C
14:09:55 <dolio> People actually do that?
14:10:36 <kmc> yeah, most libraries that accept callbacks let you specify a void* argument that gets passed to your callback
14:10:50 <kmc> which amounts to the "free variables" part of a closure
14:10:56 <kmc> without any type checking or memory management, of course
14:10:57 <dolio> Yeah.
14:11:28 <geheimdienst> i haven't seen this kind of struct, but what i do recall from my puny experience of c is that you often tell a library "call_me_back(func_pointer, other_stuff)" and it will pass other_stuff on when it runs func_pointer. kind of like poor man's closures
14:11:47 <thoughtpolice> geheimdienst: yep, this is how e.g. pthreads API works, as well as numerous other APIs
14:12:15 <thoughtpolice> and it basically amounts to a closure as kmc said. with clang you can use blocks and get something that looks a lot nicer
14:12:26 <kmc> yeah, the library is storing those in some struct
14:12:27 <thoughtpolice> (providing the function has a block-equivalent)
14:12:58 <thoughtpolice> which is what apple's GCD does (there's 2 versions of the API - one for blocks, and one for function pointers + void* arguments)
14:13:33 <dolio> GCD?
14:13:46 <geheimdienst> dolio: the apple thread pool thing
14:13:53 <dolio> Oh.
14:14:12 <thoughtpolice> grand central dispatch
14:14:53 <kmc> how does a block differ, in implementation?
14:14:57 <kmc> i know they have different syntax
14:15:13 <thoughtpolice> kmc: http://clang.llvm.org/docs/Block-ABI-Apple.txt
14:15:19 <kmc> a C++1x lambda evaluates to an object of unspecified type which is a subclass of std::function< your args >
14:15:21 <geheimdienst> i think the clang thing is a step in the right direction, but istr there's still the some big inconvenience ... you need to say __block in front of every variable you want to access in a closure or something like that
14:15:40 <kmc> which just automates the C++ boilerplate of declaring a class with member vars for your free vars etc.
14:15:47 <thoughtpolice> kmc: the relevant runtime code which is used by default is in LLVM's compiler-rt.
14:15:53 <kmc> i see, thanks
14:16:27 <thoughtpolice> (i think it's just called blocks.c or something. some people actually made seperate implementations of the lower-level ABI whenever it was announced)
14:16:51 <thoughtpolice> same for the fancy objective-C ARC thing or whatever it's called.
14:17:20 <geheimdienst> i guess it's fancy if you just teleported in from 1972 or something ...
14:17:25 <geheimdienst> ;)
14:17:37 * geheimdienst do not want obj-c
14:19:00 <thoughtpolice> geheimdienst: er, well, TBF, a lot of motivation for ARC was because GC (libauto) just wasn't good on the iphone. it was conservative and slow and had noticable lags on the UI. that's unacceptable by their UI standards. ARC really just encodes retain/release automatically based on well-established cocoa naming conventions
14:19:28 <thoughtpolice> if you think that you can make libauto good enough to work on iOS without stutter, i'm sure they'd be willing to both drop ARC and hire you at the same time :)
14:19:50 <kmc> ugh conservative gc
14:20:07 <thoughtpolice> (the reason ARC has no stuttering problems is because it is in fact, reference counting. GC always happens 'on the fly' so there's never really a pause step)
14:20:57 <thoughtpolice> kmc: yea :/ but it has to work with obj-c, which is just c in disguise, and, well...
14:22:03 <thoughtpolice> (on that note, unavoidable, overtime memory leaks are naturally pretty unacceptable as well by their standards :P)
14:23:31 <MichaelBurge> If you have a type that implements something like subtraction, is it possible to represent addition? That is, can I compute (a+b) using (a - (b - (a - (a - b))) - (a - b) or some other convoluted expression? I also have something that acts like a 0 object
14:23:49 <geheimdienst> i guess working for apple would be a nightmare for me. i'd try to do good solid engineering and all everyone else cares about is bling and shininess. i guess i'd be worn down pretty quickly
14:23:55 <Eelis> MichaelBurge: a - -b ? :)
14:24:26 <thoughtpolice> geheimdienst: i interviewed there. everyone i talked to on the LLVM team was awesome :D
14:24:30 <Eelis> MichaelBurge: or  a - (0-b)  if you wish
14:24:57 <thoughtpolice> geheimdienst: and they are very, very focused on solid engineering in that team, i assure you.
14:25:07 <MichaelBurge> Hmm, my type gives preference to the lefthand side when dealing with lists or strings that make it up
14:25:39 <thoughtpolice> (the leader of the whole clang/frontend team at apple actually used to do ocaml at stanford. we got along really well naturally :)
14:25:40 <alpounet> thoughtpolice, have you met D. Gregor ?
14:25:45 <thoughtpolice> alpounet: i interviewed with him
14:25:47 <thoughtpolice> super nice guy
14:26:04 <alpounet> i have only talked to him by email/IRC
14:26:07 <alpounet> but yeah definitely
14:26:27 <alpounet> and he is a perfect example of what you were telling us about above :P
14:26:36 <MichaelBurge> That's not an issue here though; sorry for the vague question
14:28:11 <thoughtpolice> alpounet: yeah, when i interviewed with him he was basically just like "so tell me about yourself and why you think haskell is awesome!" he was super attentive and really interested it seemed like. i was pretty afraid going into the interview honestly, lol
14:28:46 <alpounet> haha
14:28:58 <Saizan> do you have "haskell is awesome!" on your resume?
14:29:55 <thoughtpolice> from all the people i've talked to most of them have said the same: he's very nice and attentive. based on his postings/constant help to cfe-dev, i'm almost inclined to think half of his paid job is to just help people
14:30:12 <shachaf> Saizan: Who doesn't?
14:30:23 <thoughtpolice> Saizan: not *exactly*, but that's a normal opener :P
14:31:17 <num1> do you know if you got the job yet? :)
14:32:35 <thoughtpolice> num1: oh, this was months ago. i got beaten out mostly by interns/other hackers who had contributed code at the time. :P they gave me solid advice and highly advised I reapply later (mostly it was just i was facing people for the position who'd actually contributed lots of code to llvm/clang - from a risk perspective, that's a better choice)
14:32:39 <geheimdienst> well for work i've been forced to do some obj-c for the last half year, and the impression i get from the language and apple's apis was "let's never modernize this 30-year-old ill-conceived gunk, let's rather take more ill-conceived gunk and bolt it on sideways". from the outside, it does seem to me that engineers wanting to clean up or do something new always get trumped by the people who just want to make obscene amount of money
14:32:54 <kmc> sounds like most languages
14:32:56 <kmc> even Haskell
14:33:00 * benmachine nudges hackagebot 
14:33:18 <num1> makes sense :)
14:33:30 <kmc> let's never modernize [dependent types]
14:33:58 <kmc> let's just bolt on more gunk [mptc, fundeps, asstypes, type nats]
14:34:00 <geheimdienst> kmc: i disagree, i don't particularly like microsoft, but c# for example does move much faster than obj-c
14:34:06 <kmc> sure, there are degrees
14:34:31 <thoughtpolice> num1: i'm hoping to reapply in the future. :) i merely need to get my LLVM-fu up. of course, this requires writing C++. and we all know how haskell users feel about C++ :P
14:35:16 <num1> thoughtpolice I wish you luck! My goal, one of these days, is to contribute a lot to an open source project, and get hired on to continue doing so
14:35:25 <geheimdienst> kmc, agreed. my impression of obj-c is that the degree has unfortunate distance from the average
14:35:41 <_RIP_DREAMS> i'm having some trouble with the following: i want to generate a tuple with 2 random numbers (of integer type). if I try something like (randomRIO(1,2), randomRIO(1,2)) I'll get something of the form (IO a, IO a), which is not what I want.I could otherwise do x <- randomRIO(1,2), y <- randomRIO(1,2), (x,y), but I am left wondering whether there's something more suscint?
14:35:42 <kmc> yeah
14:35:52 <alpounet> thoughtpolice, there are much worse C++ projects than LLVM/Clang though
14:36:08 <kmc> _RIP_DREAMS, let r = randomRIO(1,2) in liftM2 (,) r r
14:36:10 <kmc> :t liftM2
14:36:11 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:36:26 <thoughtpolice> alpounet: oh definitely, the code there is all super high quality. i've hacked on it a bit. very nice and modular. that was mostly just a joke :P
14:36:35 <alpounet> heh
14:36:37 <alpounet> that is not actually
14:36:44 <thoughtpolice> (i do sit in #llvm and see all of them comment about random WTFs sometimes, though)
14:36:45 <alpounet> we've had many fights over this with kmc
14:37:14 <thoughtpolice> num1: right on :) open source is a great way to get experience and get hired too :D
14:37:32 * hackagebot haskell-src-meta 0.4.0.2 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.4.0.2 (BenMillwood)
14:39:56 <num1> thoughtpolice exactly! :D Just gotta find a project that suits my fancy. Android maybe, but it's not really open source, so Cyanogenmod maybe.
14:47:32 * hackagebot applicative-quoters 0.1.0.2 - Quasiquoters for idiom brackets and an applicative do-notation  http://hackage.haskell.org/package/applicative-quoters-0.1.0.2 (BenMillwood)
14:47:35 * hackagebot haskell-cnc 0.1.3.200 - Library for parallel programming in the Intel Concurrent Collections paradigm.  http://hackage.haskell.org/package/haskell-cnc-0.1.3.200 (RyanNewton)
14:50:50 <alpounet> thoughtpolice, what have you been working lately btw ?
14:52:23 <brisingr> I'm running into some trouble with my haskell talk; (now that I've partly gotten the hang of functors and monads)
14:52:45 <brisingr> I want to present haskell without boring everyone to death at the beginning
14:52:58 <brisingr> but I want them to understand later on
14:53:12 <brisingr> what to do?
14:54:45 <alpounet> brisingr, show concrete examples
14:55:09 <illissius> thoughtpolice: referring back to the tim sweeney discussion of several hours ago: I remember the talk about parallism and STM and such (if it's the same one); when did he talk about dependent types?
14:55:37 <alpounet> introducing some tease on functors and monads through some fmap's maybe, and some >>= magic
14:55:43 <alpounet> when i did my talk about haskell
14:55:58 <brisingr> yeah, been thinking about a tease
14:55:59 <alpounet> i showed a one-liner equivalent to "wc -l"
14:56:37 <brisingr> problem is, I'm with a very wide audience
14:56:53 <brisingr> say utter beginners to seasoned professionals
14:57:05 <brisingr> and I'm intermediate unfortunately
14:57:09 <brisingr> but that may be a good thing
14:57:19 <brisingr> say I show them something cool
14:57:29 <brisingr> then trace my learning steps
14:57:44 <brisingr> with cool stuff oozing off of every slide
14:57:50 <brisingr> say
14:58:13 <brisingr> now let's talk about lists
14:58:21 <brisingr> and I show them something cool with infinite lists
14:58:40 <kmc> i'm preparing a "why haskell is cool" talk and i don't mention functors or monads at all
14:59:05 <brisingr> kmc: how long is your talk?
14:59:07 <kmc> "Monad" is just a generic API to a lot of unrelated functionality
14:59:10 <kmc> the API isn't that impressive
14:59:11 <dibblego> when I talk about monads and functors, I never or hardly mention haskell
14:59:16 <kmc> brisingr, probably about an hour
14:59:21 <alpounet> brisingr, well, my audience ranged from linux sysadmins to java devs
14:59:25 <brisingr> same here
14:59:26 <roconnor> brisingr: http://r6.ca/Haskell/FPI.pdf this is the talk I gave where I specifically talk about monads :D
14:59:26 <alpounet> including some ruby/python people
14:59:26 <thoughtpolice> alpounet: right now i do data backup software stuff. java/C++. my main interest is in compiler tech though, hence why i like ghc/llvm :)
14:59:28 <kmc> it's not intended to teach anyone to program in Haskell
14:59:32 <kmc> just to convince them that it's cool
14:59:36 <brisingr> roconnor: thanks
14:59:39 <kmc> and worth learning on their own
14:59:52 <brisingr> yes, want to do the same here
15:00:01 <thoughtpolice> illissius: ISTR he explicitly mentioned it wrt things like tracking array sizes statically. you don't need full blown DTs for this, but i do believe he hinted that he wanted dependently-typed like features along these lines, to enforce more invariants
15:00:06 <brisingr> what I'd like to do tho is touch monads at the end
15:00:08 <alpounet> brisingr, at the end of the talk
15:00:11 <alpounet> i prepared a demo
15:00:12 <brisingr> and leave everything talking
15:00:15 <alpounet> which basically was an IRC bot
15:00:19 <alpounet> with a few fun stuffs
15:00:21 <brisingr> *hanging
15:00:43 <ddarius> "A Short Talk Touching Monads at the End"
15:00:51 <alpounet> connecting to the IRC channel of the user group, following some RSS feeds, etc, that kind of stuffs
15:00:52 <gwern> > 1.8 / 26
15:00:53 <lambdabot>   6.923076923076923e-2
15:00:57 <gwern> > (1.8 / 26)*100
15:00:58 <lambdabot>   6.923076923076923
15:01:00 <alpounet> and i went through the code in front of them
15:01:40 <brisingr> interesting idea
15:01:47 <thoughtpolice> alpounet: more recently i've been wanting to hack more on GHC. i have a partial patch for SIMD-support in GHC's frontend (vivian mcphail did most of this work, but no codegen, and his patches fell very out of date,) so i think i might get to hacking on that and trying to finish it :)
15:02:21 <brisingr> basically I want to show them it's cool
15:02:28 <brisingr> nothing more, nothing less
15:02:43 <alpounet> thoughtpolice, cool!
15:02:54 <alpounet> i've been looking at the ghc trac last night
15:03:00 <alpounet> to find something i could do too
15:03:30 <thoughtpolice> yeah, that's always the hard part. :) most of the bugs are either "really hard", "i don't run that platform/test on it," or "i have no clue" :P
15:03:52 <thoughtpolice> granted bugging people in #ghc helps a lot :D
15:04:02 <roconnor> The A-1920-IXB is an exemplary instance of part number A-1920-IXB.
15:04:03 <roconnor> Also, it is broken: it is (a A-1920-IXB missing a transistor)
15:04:05 <roconnor>  
15:04:06 <roconnor>  
15:04:08 <roconnor> missing (a radio missing an antenna) and a processor and a bolt.
15:04:12 <alpounet> brisingr, the point in showing them an IRC bot with such features was too go against the "haskell is probably cool for mathematicians" or w/e shit i've been told during user group meetings when we talked about haskell before
15:04:15 <roconnor> heh, I always get a kick out of that
15:04:20 <alpounet> s/too/to/
15:04:52 <brisingr> well, I'd like to touch XMonad for that
15:04:54 <alpounet> thoughtpolice, i actually found a task i can do, considering the time/knowledge i have
15:05:15 <alpounet> brisingr, also, telling about "commercial" use of haskell helps
15:05:49 <brisingr> yeah, actually there're gonna be some M$ executives or something
15:06:02 <brisingr> local people trying to advertise or whatnot
15:06:19 <kmc> xmonad is cool, but in general you can't make a good case for Haskell based on consumer-facing software
15:06:28 <kmc> it's mostly used for specialized internal tools
15:06:48 <brisingr> the thing is, say my audience is
15:06:51 <erus`> thats becaus eop
15:06:52 <brisingr> 10% noobs
15:06:57 <erus`> opengl in haskell sucks*
15:07:04 <brisingr> 50% intermediate users
15:07:09 <brisingr> 20% programmers
15:07:12 <brisingr> 20% executives
15:07:56 <brisingr> what I really want to show them is that it's cool AND useful
15:08:19 <alpounet> oh
15:08:30 <alpounet> another good thing is telling them about the bunch of libraries
15:09:01 <brisingr> which leads me to
15:09:11 <brisingr> it needs a somewhat logical order too
15:09:11 * monochrom suspects that every approach to abstraction other than OO is "probably cool for mathematicians"
15:09:49 <monochrom> I mean I suspect that's the mainstream mindset
15:09:51 <alpounet> monochrom, from OO people's POV, yeah
15:10:25 <brisingr> I believe every approach to abstraction is "cool for mathematicians TOO"
15:11:15 <brisingr> god, how am I supposed to put this in a logical order
15:11:21 <brisingr> if I have that I basically have my talk
15:11:57 <monochrom> the mainstream behaviour goes a long way to destroying any hope of distinguishing "education" from brainwashing
15:11:57 <alpounet> brisingr, you may want to take a look at what galois has been using haskell for, and more generally at all the industry related pages/messages in the haskell ecosystem
15:12:33 <brisingr> hmm
15:13:02 <alpounet> ok maybe not all
15:13:05 <alpounet> but a few
15:13:34 <ddarius> monochrom: Simply start describing point-set topology using OOP and the problem should be solved.
15:13:47 <brisingr> so thanks to you I've got my second half / last two thirds of the talk
15:13:53 <brisingr> but how do I begin?
15:13:58 <MichaelBurge> You can show them how easy it is to string together different computations in Haskell. The "bracket connect disconnect loop" line in the Roll Your own IRC Bot example on the wiki amazed me when I saw it
15:14:05 <monochrom> haha I should do exactly that!
15:14:32 <geheimdienst> ddarius: yeah that'll show them that haskell is not just for mathheads ...
15:15:16 <ddarius> geheimdienst: You must read monochrom and me more precisely.
15:15:41 <monochrom> try: mathheads are not just for haskell :)
15:15:55 <brisingr> :)
15:15:59 <alpounet> brisingr, I'd go with provocation
15:16:00 <alpounet> (to get them focused / interested, even if it's for the wrong reasons at the beginning)
15:16:11 <danharaj> That you can define control structures as functions in Haskell is probably the most salient advantage of pure functional programming.
15:16:44 <danharaj> I should say lazy, too.
15:17:12 <monochrom> yeah, show them forM_
15:17:41 <brisingr> You're right, but I still have a problem
15:17:45 <brisingr> how do I begin?
15:17:48 <monochrom> "it is user-definable code. you can define some other loop construct if you like"
15:18:12 <brisingr> okay, so say my first slide is "Haskell is functional lazt etc. etc."
15:18:21 <brisingr> s/lazt/lazy
15:18:37 <monochrom> (to avoid digressing into monads in general, first introduce forM_ etc specialized for IO"
15:18:57 <danharaj> Where to start is a tough decision.
15:19:02 <alpounet> brisingr, i wouldn't go with that
15:19:08 <monochrom> (just like you first pretend "3" is Integer rather than "Num a => a" to avoid digressing into Num in general)
15:19:28 <alpounet> just find a simple (but actually doing something """useful""")
15:19:29 <danharaj> Actually, maybe talking about type classes is a good thing to start with.
15:19:29 <brisingr> should I start with a teaser?
15:19:32 <alpounet> show them the java code
15:19:33 <kmc> danharaj, you can define control structures as functions in impure, strict languages
15:19:35 <alpounet> the C code
15:19:41 <alpounet> etc
15:19:41 <alpounet> and then
15:19:44 <alpounet> the haskell version
15:19:49 <alpounet> probably smth like that
15:19:52 <alpounet> to get their attention
15:20:03 <brisingr> that's gonna work
15:20:05 <monochrom> I would start with actual code (choose some easy example code) and its runtime behaviour
15:20:15 <brisingr> forst thing on my mind, say, quicksort
15:20:16 <danharaj> kmc: Can you? How does ifthenelse b (error "uh oh") (error "oh no") work?
15:20:21 <brisingr> 'cause it's really cheesy in haskell
15:20:29 <kmc> danharaj, right, there are limitations
15:20:44 <danharaj> kmc: I think laziness is important so that control structures defined as functions are compositional.
15:20:44 <kmc> and it's not as nice
15:20:51 <kmc> i agree
15:20:54 <alpounet> brisingr, i'd go with a more classical thing
15:20:57 <danharaj> If they're not compositional, then they're hardly first class.
15:21:04 <alpounet> brisingr, i'd go with a more "real world" thing
15:21:13 <alpounet> executives don't give a fuck about quicksort i think
15:21:18 <kmc> but, say, the "for loop as a function" example works in most languages
15:21:18 <brisingr> say, a simple database?
15:21:24 <alpounet> yeah
15:21:35 <alpounet> database, interacting with web pages
15:21:52 <alpounet> like a program watching if a page has changed
15:22:28 <alpounet> that'll definitely be awful in C, Java, ...
15:22:35 <ddarius> Having a lightweight "lambda" syntax is usually adequate to make up for not having laziness in this regard.  Smalltalk has no control structures.
15:22:48 <kmc> C#'s lambda syntax is lighter than Haskell's
15:22:50 <monochrom> you're going to show an IRC bot written in haskell? and you like to start with a teaser? then set the teaser to be "this slide shows the irc bot code in 5-pt font", "here is a demo", "this slide says I'm going to walk you through the code"
15:23:17 <brisingr> :))
15:23:50 <erus`> might as well show them 'tying the not' with monads or something
15:24:00 <erus`> because thats the shit they're gonna have to read
15:24:42 <monochrom> and then the rest is carefully deciding which parts of the code to explain, in what order. introduce abstract notions on demand only, e.g., don't talk about Num until you come to the code fragment that relies on being general about Num
15:25:44 <brisingr> what would be perfect is some teaser code which is multi-functional, useful
15:25:48 <brisingr> and awful in other languages
15:25:59 <danharaj> you could show an implementation of red-black trees.
15:26:33 <alpounet> brisingr, a parser ?
15:26:37 <danharaj> or, really, what you want to do is show them an example that is exactly in their domain.
15:26:39 <Ptival> what about STM?
15:26:44 <danharaj> What sort of professionals will you be talking to?
15:26:55 <erus`> show them a roguelike
15:26:58 <brisingr> well, say 20% will be professionals
15:26:58 <danharaj> heh
15:27:09 <brisingr> some will be executives
15:27:13 <brisingr> some will be beginners
15:27:23 <brisingr> most will be college students
15:27:30 <alpounet> at some point in my talk i got them to think about a server for a game, thus defining a tiny protocol defined as an ADT (boom, a great haskell feature), a tiny parser, etc
15:27:42 <erus`> show them a quine
15:27:46 <danharaj> The executives are going to want to see 'real world results', don't you think? You'll want to cite results from industrial and government projects.
15:27:49 <brisingr> and the professionals are C/java almost surely
15:27:50 <descender> brisingr, are they familiar with FP in general at all?
15:28:00 <brisingr> no
15:28:10 <brisingr> that's the problem
15:28:14 <descender> then maybe you could start from there?
15:28:15 <thoughtpolice> attoparsec might be fun to show. :) you can write a simple, and resumable network protocol parser in shockingly few lines of code
15:28:33 <descender> speaking generally about what FP has to offer, and then some teasers
15:28:42 <thoughtpolice> on that note regular parsec would be just fine too. mmmm, combinators
15:28:48 <descender> also make the point that many FP features are creeping into mainstream languages
15:28:57 <geheimdienst> "... and the following lambdacat is funny because the kitty can't get out of the shower, much like how things in IO can't escape and be used from pure code ..."
15:29:03 <brisingr> descender: good point on that
15:29:20 <alpounet> geheimdienst, hahaha, i actually showed that picture at some point too :P
15:29:28 <danharaj> http://www.cs.yale.edu/publications/techreports/tr1049.pdf
15:29:30 <monochrom> the non-professionals 80% will understand nothing no matter what you do, but they will consider the professionals 20% as opinion leaders. focus on that 20%. they are your only hope
15:29:33 <danharaj> this is a relevant study
15:29:59 <danharaj> Figure 3 is particularly nice to explain
15:30:14 <brisingr> in my first draft I had a slide "let's open the window"
15:30:15 <brisingr> with
15:30:33 <brisingr> move left foot move right foot repeat 1-2 move window handle pull
15:30:51 <brisingr> and then go on with the horrible bugs that can creep in
15:31:14 <brisingr> but I couldn't make the transition to FP
15:31:41 <monochrom> wait, why are there two "haskell"s in figure 3? :)
15:31:51 <descender> maybe also talk about the ease of creating DSLs in Haskell
15:31:53 <ddarius> monochrom: If you're only hope is a crowd of C and Java programmers, find a new job.
15:32:05 <alpounet> brisingr, i also spent a few minutes talking about how many useless stuffs we have to care about in C, Java, etc, keeping us from focusing on the actual things the code has to do
15:32:26 <brisingr> actually, how about a slide on something like
15:32:33 <brisingr> train of thought:
15:32:50 <brisingr> 1. what needs to be done 2. what is given 3. how to accomplish it
15:33:06 <brisingr> and how imperative programming wastes time on 3 when in fact we need 1
15:33:12 <erus`> what is a notoriously hard/inelegant thing todo in haskell that is easy in c(++)?
15:33:33 <descender> predicting costs? :p
15:33:34 <brisingr> erus`: wait a moment, I have something on that
15:33:38 <ddarius> erus`: Anything that relies on control of memory layout.
15:34:07 <ddarius> Also anything that relies on not allocating at certain pointsn.
15:34:40 <brisingr> erus`: basically anything that is taught to beginner C programmers
15:35:07 <brisingr> those'll usually focus on the language's strength, namely the for loop
15:35:16 <Eduard_Munteanu> Predictable memory usage might be one.
15:35:51 <ddarius> brisingr: I doubt any of those things are hard/inelegant to do in Haskell.
15:36:10 <alpounet> brisingr, also, i very much like the expressiveness of haskell code in general
15:36:20 <brisingr> not inelegant, but let's say..
15:36:21 <BrianHV> that du thread on reddit was an interesting example
15:36:22 <alpounet> and used that argument during my talk
15:36:29 <brisingr> not appreciative of haskell's strengths
15:38:17 <brisingr> alpounet: that would come in excellently after the teaser
15:38:22 <brisingr> or on the teaser slide
15:38:24 <Eduard_Munteanu> Also, some mutable data structures (basically stuff requiring pointer manipulation) looks a bit more inelegant in Haskell.
15:38:57 <brisingr> I feel that I may be wasting your time
15:39:29 <brisingr> but I need to get that talk right
15:39:45 <brisingr> I need it so badly on my college admission CV
15:40:54 <erus`> Data.Vector
15:41:05 <erus`> is it like list?
15:41:36 <ddarius> College is for losers.
15:41:37 <benmachine> more like an array
15:42:04 <brisingr> I mean, college as in university
15:42:24 <smop> almost on chapter 3
15:42:25 <ddarius> I mean college, as in university, is for losers.
15:43:07 <brisingr> I see your point
15:43:07 * benmachine is a loser
15:43:27 <DukeDave> But I discovered Haskell at university!
15:43:28 <Eduard_Munteanu> I wonder if ddarius is serious (not that I disagree).
15:43:35 <brisingr> but unfortunately, no college = no chance to leave to a better place
15:43:51 <descender> heh I withdrew from university because I couldn't stand the course
15:43:58 <descender> so can't argue with that
15:44:00 <benmachine> well, *I* like university
15:44:02 <DukeDave> And it Haskell has bought me far more happiness than a piece of paper with "BSc" on it :|
15:44:15 <Eduard_Munteanu> College... the kindergarten for older kids, it puts the parents' minds at ease.
15:44:18 <benmachine> I even (gasp) enjoy my course
15:44:35 <smop> working at an investment bank eh
15:44:47 <brisingr> to tell the truth I can't wait to go to college
15:45:06 <brisingr> I'm kinda bored here and do a lot of off-school things
15:45:08 <brisingr> like haskell ;)
15:45:13 <kmc> i met a ton of smart people in college
15:45:48 <Eduard_Munteanu> I met a lot more in #haskell...
15:46:10 <ddarius> So one ton of smart people would be about 10 to 20...
15:46:37 <benmachine> Eduard_Munteanu: it depends what you mean by "met" of course
15:46:47 <erus`> Eduard_Munteanu: lots of trolls and fools too :)
15:46:56 <benmachine> erus`: oh, there are plenty of those at university :P
15:46:58 <Eduard_Munteanu> Same in college!
15:47:01 <erus`> i like the variety
15:47:39 <Eduard_Munteanu> benmachine: well, met well enough to say they're smart, I guess.
15:47:42 <descender> I tended to meet those stuck in the education rat race, completely uninterested in the subject matter
15:47:50 <descender> so I got discouraged and left
15:48:09 <benmachine> Eduard_Munteanu: sure, but I don't talk to anyone in here that regularly, compared to my university friends
15:48:26 <benmachine> so even though people here are probably cleverer (or at least more educated) I wouldn't say I learn more from them
15:48:29 <benmachine> necessarily
15:48:57 <Eduard_Munteanu> Ok, maybe you're a bit more social than I am.
15:49:10 <Eduard_Munteanu> Or at least social in the old-fashioned sense.
15:49:15 <ddarius> Your phrase "cleverer (or at least more educated)" strikes me as bizarre.
15:50:03 <Eduard_Munteanu> Why, doesn't "stupid and hard-working" exist?
15:50:59 <benmachine> Eduard_Munteanu: I couldn't possibly comment on how social you are, or whether I'm more so
15:51:15 <benmachine> I'm not unusually social, probably the opposite
15:51:40 <benmachine> but... universities, in my limited experience, tend to contain cool people
15:51:48 <benmachine> 'sall I'm saying
15:52:41 <ddarius> The world, in my limited experience, tends to contain cool people.
15:53:04 <c_wraith> universities do contain cool people.  they also contain outspoken idiots.
15:53:14 <c_wraith> universities contain many things.
15:53:15 <brisingr> the world also contains far-from-cool people
15:53:18 <Eduard_Munteanu> I sometimes felt I attracted undue attention... like people asking me for help on school matters when I knew less than they did :/
15:54:10 <ddarius> (Also, why does everyone never know if I'm being serious or not?)
15:54:24 <brisingr> 'cause it's a text-only medium
15:54:59 <geheimdienst> @pl \x y -> [x,y]
15:55:00 <lambdabot> (. return) . (:)
15:55:13 <djahandarie> ddarius, wait, are you serious in asking that?
15:55:37 <ddarius> edwardk: How easy is it to tell if I'm being serious in person, and despite that, how often am I not serious?
15:55:58 <djahandarie> It's really easy to tell if you're being serious or not in person
15:56:06 <edwardk> ddarius is pretty much dead pan all the time.
15:56:14 <edwardk> djahandarie: you have MET ddarius right?
15:56:17 <edwardk> =)
15:56:18 <djahandarie> Yes.
15:56:50 <edwardk> he has an even flatter affect than dolio ;)
15:57:02 * ddarius agrees with djahandarie.  It's really easy to tell because I'm always serious.
15:57:48 <Eduard_Munteanu> ddarius: that was my impression too... or at least your IRC messages suggest a straight face even when you're not serious.
15:58:24 <edwardk> i need to write a bot that logs into #haskell, and random writes ;)'s and :)'s after ddarius's comments to soften them
15:58:37 <brisingr> :)
15:58:40 <edwardk> er randomly
15:58:43 <brisingr> :)
15:58:44 <brisingr> :)
15:58:46 <brisingr> :)
15:58:47 <edwardk> see, it works
15:59:04 <brisingr> ***fatal error***
15:59:08 <brisingr> :(
15:59:23 <djahandarie> Obviously not type-safe enough
15:59:27 <djahandarie> Should have used Agda
16:00:19 <ddarius> :***out of memory***
16:00:22 <edwardk> playing with ways to do static analysis for parsers for the applicative portions of the grammar, with an eye towards using par and my speculation machinery when i can guess how many bytes ahead the next item will start or what the answer from the current parser will be
16:00:35 <brisingr> ddarius: :)
16:01:13 <edwardk> along the way i came up with a cute little applicative/monad for gluing together partial information
16:01:40 <edwardk> @hpaste
16:01:40 <lambdabot> Haskell pastebin: http://hpaste.org/
16:01:56 <hpaste> edwardk pasted “spec” at http://hpaste.org/50240
16:02:50 <kmc> where do the data constructors Pure and Given come from?
16:02:53 <edwardk> basically each node in the parser also carries (along with the other swierstra and duponcheel stuff) one of these values, which can be used to guess at the output of the parser before it evaluates to permit speculation
16:02:54 <kmc> looks like some bits got renamed
16:03:03 <edwardk> sorry yeah, alpha renamed Pure = Unit
16:03:12 <edwardk> wow
16:03:14 <ddarius> Free (1 + 1 + Id)
16:03:15 <edwardk> that got mangled
16:03:52 <edwardk> there are 4 constructors, Pure is the unit of the monad, Spec is a 'downgrade' of it, that remembers it was downgraded, and Spark and Ap are progressively worse
16:04:14 <int80_h> I need to cast a [String] to a [Int] using read. I think I need map. How do I do this?
16:04:23 <kmc> :t map read
16:04:23 <lambdabot> forall a. (Read a) => [String] -> [a]
16:04:25 <int80_h> can't get the syntax right
16:04:26 <kmc> "cast" isn't the right word
16:04:35 <edwardk> er s/Pure/Unit. i think i need to alpha rename that the rest of the way =)
16:04:39 <kmc> > map read (words "123 456 7 8") :: [Int]
16:04:40 <lambdabot>   [123,456,7,8]
16:04:57 <int80_h> kmc: what's the right word?
16:05:07 <shachaf> Hmm, the GADT record syntax was changed from data Foo where { Con {a :: Int} :: Foo } to data Foo where { Con :: {a :: Int} -> Foo }
16:05:09 <Eduard_Munteanu> ascribe?
16:05:10 <shachaf> Which is kind of weird.
16:05:26 <Eduard_Munteanu> Um no.
16:05:30 <int80_h> kmc: your example using a String, I'm working on a [String]
16:05:32 <Eduard_Munteanu> It's a conversion.
16:06:11 <Eduard_Munteanu> '::' isn't a cast either, that's an ascription
16:06:18 <kmc> int80_h, "convert"
16:06:28 <hpaste> edwardk annotated “spec” with “spec (annotation)” at http://hpaste.org/50240#a50241
16:06:33 <kmc> but "how do I convert A to B" is just a funny way of asking "make up a function of type A -> B"
16:06:36 <edwardk> trying this again =)
16:06:42 <edwardk> gah still missed some
16:06:49 <kmc> thanks, C programming language, for muddling this one up
16:06:57 <int80_h> kmc: oh I just tried using words. I see what's up
16:07:06 <kmc> 'words' was just for the sake of example
16:07:38 <elliott> shachaf: reminds me of Agda :-P
16:07:39 <hpaste> edwardk annotated “spec” with “spec (annotation)” at http://hpaste.org/50240#a50242
16:07:47 <edwardk> there =)
16:08:14 <edwardk> anyways, basically what i'm looking at is some monstrosity like:
16:08:19 <dmwit> kmc: I guess here in the Haskell world, we have the unambiguous word "coerce".
16:08:42 <elliott> dmwit: That's just the word that makes everyone start furiously typing "you don't want to do that".
16:08:46 <elliott> Observe:
16:08:51 <elliott> Hey guys, how can I coerce a function to an integer?
16:08:55 <dmwit> (instead of "cast" which could mean "coerce" or "convert" thanks to C)
16:08:56 <Eduard_Munteanu> Not really... coerce is more like using a pointer of a different type to access something.
16:09:00 <shachaf> elliott: unsafeCoerce :: a -> b
16:09:13 <elliott> shachaf: You were meant to furiously type "you don't want to do that".
16:09:17 <elliott> Now everything is RUINED.
16:09:39 <shachaf> @ty unsafeCoerce
16:09:40 <lambdabot> forall a b. a -> b
16:09:53 <edwardk> data Par e a = Par ( accepts :: ByteSet, mode :: Spec a, deltaGuess :: Delta, exactDelta :: Bool, needsDelta :: Bool, clampedMaxBytesConsumed :: Int, parser :: Parser e a }
16:09:55 <shachaf> > unsafeCoerce id :: Int
16:10:01 <lambdabot>   mueval: ExitFailure 1
16:10:02 <lambdabot>  mueval-core: Time limit exceeded
16:10:02 <edwardk> (with a bunch of !'s etc.
16:10:05 <shachaf> > unsafeCoerce id :: Int
16:10:08 <lambdabot>   *Exception: you don't want to do that
16:10:15 <Eduard_Munteanu> Hm?!
16:10:29 <Eduard_Munteanu> lambdabot has unsafeCoerce?
16:10:36 <edwardk> the deltaGuess and the accepts flag play the role of the swierstra and duponcheel parsers but also let me start the next parser running ahead of time using the guess
16:10:53 <edwardk> downgrading the technique used to spark the parser if the guess isn't accurate
16:10:54 <Eduard_Munteanu> That looks like a can of worms.
16:11:16 <elliott> Eduard_Munteanu: Whoosh
16:11:24 <elliott> Hint: lambdabot responds to private messages. :p
16:11:27 <shachaf> whoosh--
16:11:33 <Eduard_Munteanu> Oh, heh.
16:11:35 <shachaf> @karma- whoosh
16:11:35 <djahandarie> Eduard_Munteanu, you should always be careful when shachaf is ever running anything with lambdabot.
16:11:35 <lambdabot> whoosh's karma lowered to -2.
16:11:36 <Eduard_Munteanu> @src unsafeCoerce
16:11:37 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:11:41 <elliott> Poor whosh.
16:11:45 <shachaf> @karma- whoosh
16:11:45 <lambdabot> whoosh's karma lowered to -3.
16:11:45 <elliott> I mean whoosh.
16:11:57 <whoosh> shachaf: You're hurting my feelings.
16:11:59 <djahandarie> Or is it whooosh? I can never tell with you guys.
16:12:00 <shachaf> whoosh--
16:12:10 <shachaf> djahandarie: Hey, why me?
16:12:23 <djahandarie> It's always you!
16:12:44 <shachaf> You exaggerate.
16:12:50 <elliott> @karma you
16:12:50 <lambdabot> you has a karma of 0
16:12:51 <edwardk> then parsers that give back a known result on success, like 'newline' can carry the Par (singleton '\n') (Known '\n') (Lines 1 0 1 0) True False 1 (…..) where …. is what i'd have writen before
16:12:56 <elliott> @karma I can
16:12:57 <lambdabot> I has a karma of 32
16:12:59 <elliott> Aww.
16:13:02 * benmachine suspects it is const error
16:13:07 <benmachine> oh wait
16:13:10 * benmachine not scrolled down
16:13:11 <shachaf> @whatis djahandarie
16:13:11 <lambdabot> one who exaggerates
16:13:18 <elliott> @whatis whoosh
16:13:18 <lambdabot> I know nothing about whoosh.
16:13:37 <edwardk> and since almost all my parser combinators are just applicative combinators i can glue those together getting longer delta guesses, and bigger speculation gambles
16:14:13 <edwardk> and ultimately it'll be useless because it is way too much meta info to carry in a parser, but still ;)
16:14:19 <dolio> Let it ride!
16:15:49 <acowley> I feel like I walked into a semiring
16:15:53 <parcs> @karma I can
16:15:53 <lambdabot> I can has a karma of 0
16:16:17 <edwardk> I can++
16:16:20 <edwardk> @karma can
16:16:21 <lambdabot> can has a karma of 2
16:16:21 <geheimdienst> "a cowley walks into a semiring ..."
16:16:31 <parcs> I can++
16:16:32 <parcs> @karma I can
16:16:33 <lambdabot> I can has a karma of 1
16:16:33 <thoughtpolice> edwardk: so, i'm playing around with trifecta a little and i found something but i'm not sure if it's a bug or just me doing it wrong :P
16:16:42 <monochrom> hahaha
16:16:46 <edwardk> probably a bug
16:16:49 <edwardk> i have a few
16:17:19 <edwardk> this has been almost all 'expansion phase' coding, with little testing yet
16:17:32 <edwardk> whats blowing up?
16:17:33 <acowley> trifecta is in the Diagnostics section on hackage. That makes sense...
16:18:28 <acowley> do any versions have haddock?
16:18:36 <edwardk> they used to, until they upgraded to 7.2 =(
16:18:44 <thoughtpolice> edwardk: just a sec
16:18:46 <edwardk> then it broke because igloo hasn't updated unix
16:19:08 <edwardk> (the unix package has a base cap of 4.4)
16:19:25 <hpaste> thoughtpolice pasted “trifecta test” at http://hpaste.org/50243
16:19:48 <thoughtpolice> edwardk: note the break in the span leading up to the caret on the second test
16:20:01 <edwardk> ah fixed that in head already
16:20:12 <edwardk> i had some off by one rendering bugs
16:20:22 <thoughtpolice> ah, k
16:20:37 <edwardk> now if you want to fix a real bug, tell me why the parser for 'decimal' spins forever ;)
16:21:45 <thoughtpolice> oh, well look at that, it does :)
16:22:13 <edwardk> i probably screwed up transcoding the stuff from parsec
16:23:39 <monochrom> it was just 0.20 yesterday. now 0.25 already
16:23:48 <monochrom> you could use more cathedral
16:24:11 <edwardk> maybe
16:24:13 <monochrom> which module has decimal?
16:24:26 <edwardk> i find that when i pile more structure on i don't just slow down, i stop
16:24:37 <edwardk> so i try to just go with it ;)
16:24:48 <edwardk> Text.Trifecta.Parser.Literals
16:24:49 <monochrom> ah, Parser/Literals.hs
16:24:58 <edwardk> its split out from Token because it isn't actually a 'token' parser
16:25:06 <edwardk> since it doesn't use lexeme
16:25:29 <edwardk> so i splintered out a module of 'crap that was in Token but shouldn't have been'
16:26:31 <monochrom> foldl ? foldl ?!!
16:27:38 <edwardk> that was what was in text.parsec.token. i should strictify that ;)
16:28:50 <monochrom> so "decimal = number 10 digits", "digits" is pretty trivial, "number x y = ... some y ..." the "some" could be a problem
16:29:16 <edwardk> some here is using the stock one from Alternative
16:29:29 <monochrom> eh? you just use Applicative's some? then I don't see the problem...
16:30:06 <edwardk> yeah one of my goals was to reduce the magic, getting rid of having <|> and many1 and many on my own and just using what was out there
16:30:40 <edwardk> well i'll be, looks like many is busted ;)
16:30:41 <monochrom> if your Applicative instance works, "some" will work too
16:31:16 <edwardk> ghci> parseTest (many (char 'a')) "aaaaaaaaaa" also spins forever
16:31:45 <alpounet> edwardk, you should write a tutorial for trifecta
16:32:02 <edwardk> alpounet: i might, but first i want to finish writing trifecta ;)
16:32:25 <monochrom> my god, it's full of continuation-passing style!
16:32:27 <alpounet> yeah, it's only the 24th version :P
16:32:33 <edwardk> hah
16:32:47 <geheimdienst> > unzip $ map (succ &&& pred) [1..3]
16:32:48 <lambdabot>   ([2,3,4],[0,1,2])
16:33:01 <geheimdienst> ^^ what's a less goofy way to map two functions over one list?
16:33:10 <edwardk> monochrom: you can reason about the internals by looking at the guts of parsec and flipping the arguments around
16:33:44 <edwardk> i haven't spent much time on Parser.Prim since its only an implementation detail none of the other code cares how i implement that part
16:34:06 <alpounet> edwardk, how are the performances btw compared to other parsers ?
16:34:17 <monochrom> continuation-passing style commits you a bit more to evaluation order. you may lose laziness needed for "many" and "some"
16:34:29 <edwardk> it should stack up pretty well against parsec
16:34:30 <acowley> alpounet: performance is a problem if you use many, apparently
16:34:44 <edwardk> monochrom: well, many and some are baked into Alternative, so i can rewrite them
16:34:53 <alpounet> edwardk, and attoparsec ?
16:34:54 <edwardk> acowley++
16:35:30 <edwardk> alpounet: i'm focused on error reporting, not performance, but i actually feed the parsers in the same way attoparsec does, except i hold onto all input for now
16:35:37 <monochrom> a cowley walked into a performance problem :)
16:35:38 <Axman6> @pl \xs -> (map f xs, map g xs)
16:35:38 <lambdabot> ap ((,) . map f) (map g)
16:35:43 <edwardk> so don't use this to parse terabytes of xml. its designed for programming language like grammars
16:35:43 <parcs> why are separate instances of MonadState declared for each monad transformer? why not do something like `instance (MonadState s m, MonadTrans t, Monad (t m)) => MonadState s (t m)` to cover all instances at once? is it because of the language extensions involved to declare that instance?
16:35:56 <alpounet> edwardk, okay :) like kata ?
16:36:02 <alpounet> hah
16:36:23 <edwardk> yeah thats one =)
16:36:46 <edwardk> parcs: because that instance would overlap with any other instance that had the same kinds
16:38:05 <edwardk> monochrom: that looks like it is it
16:38:15 <danharaj> so why does the reader monad have a 'local' function. Doesn't that defeat the purpose of reader being weaker than state?
16:38:31 <Eduard_Munteanu> It still is weaker.
16:38:50 <Eduard_Munteanu> Your callees can't alter the caller state.
16:39:14 <Eduard_Munteanu> (if that's what you mean)
16:39:25 <edwardk> danharaj: it doesn't defeat the purpose but it is annoying
16:39:41 <edwardk> there are monads that can have ask but not local
16:39:42 <danharaj> Eduard_Munteanu: It seems like it's extra functionality that ought to be in a different monad lying between Reader and State.
16:39:54 <danharaj> edwardk: have a good example?
16:39:57 <Eduard_Munteanu> :t local
16:39:58 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
16:40:08 <edwardk> similarly with writer, there are monads with useful tells, but not listen and pass (e.g. logging to the console)
16:40:23 <danharaj> ah yeah that makes sense.
16:41:02 <edwardk> danharaj: anyways, yes, i believe that functionality should probably be factored out, but i haven't been willing to deal with the ensuing complaint storm i'll cause by doing it ;)
16:41:11 <Eduard_Munteanu> It's like calling a function with a different argument, I don't really see the issue.
16:41:36 <edwardk> Eduard_Munteanu: because what if i can't change the argument?
16:42:03 <aavogt> @type \f m -> do x <- ask; return (runReader m (f x))
16:42:04 <lambdabot> forall (m :: * -> *) r r1 a. (MonadReader r m) => (r -> r1) -> Reader r1 a -> m a
16:42:12 <edwardk> instance Reifies s e => MonadReader e (Tagged s) where ask = reflect
16:42:20 <edwardk> good luck defining local though ;)
16:43:06 <aavogt> danharaj: since you're not going to restrict either ask or runReader, it doesn't look like you can ban local
16:43:20 <Eduard_Munteanu> Yeah, I mean what aavogt said
16:44:59 <applicative> has anyone else noticed that 'using' seems to have become a keyword in ghc-7.2
16:45:15 <aavogt> are you 'using' any extensions?
16:45:24 <applicative> > let using = (+) in using 1 1
16:45:25 <lambdabot>   2
16:46:01 <monochrom> lambdabot is emphatically not even ghc 7 :)
16:46:02 <geheimdienst> probably they're merging c++ into haskell. using is a keyword in c++
16:46:13 <danharaj> haskell--
16:46:17 <brisingr> it should be using the best of both worlds
16:46:21 <applicative> that's what I was wondering.   let using = (+)  is a type error in my new shiny ghci
16:47:00 <monochrom> that may be just the type checker
16:47:20 <monochrom> how about "let using = ()" ?
16:47:30 <applicative> I noticed this when importing Control.Parallel.Strategies, but it doesn't matter.  It treats 'using' as if it were 'if'
16:47:53 <applicative> monochrom: <interactive>:0:5: parse error on input `using'
16:48:15 <monochrom> nice, parse error points strongly towards keywording
16:48:43 <monochrom> hrm, so what is ghc using "using" for? XD
16:49:43 <applicative> I was just grepping the source, but there is a bit of an abundance of uses of using
16:52:47 <Eduard_Munteanu> I wonder, could you have some TH magic add up monads for you, so you didn't have to use transformers?
16:53:13 <applicative> monochrom, I found it, it's -XMonadComprehensions I set it in my ghci
16:53:22 <applicative> .ghci rather
16:54:09 <brisingr> I know what to do for my talk (finally)! I'll introduce (and demonstrate) a version of ELIZA written in haskell. I'll explain the code piece by piece and show it's awesome!
16:54:38 <byorgey> brisingr: sounds fun =)
16:54:50 <stepkut> 'using' is from the generalized (SQL-Like) List Comprehensions
16:54:51 <danharaj> that's a good idea.
16:55:04 <danharaj> oh right monad comprehensions are in 7.2
16:55:06 <Eduard_Munteanu> Hah.
16:55:14 <brisingr> it won't break any records but it should be fun and sufficiently short
16:55:36 <Eduard_Munteanu> I guess that one reserves even more keywords, no?
16:55:47 <brisingr> thanks everyone for all your suggestions
16:55:59 <brisingr> I'll be back with questions, no doubt
16:56:03 <stepkut> applicative: section 7.3.9 -> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html
16:56:09 <alpounet> good luck brisingr!
16:56:11 <applicative> monochrom, looks like it isn't a bug, which is a little strange, it's with by group etc
16:56:11 <alpounet> keep us posted
16:56:16 <brisingr> thanks
16:56:18 <alpounet> and don't hesitate to blog about your presentation
16:56:37 <Eduard_Munteanu> brisingr: is this an introductory Haskell talk? Then why not take a few simple programs/algorithms?
16:56:47 <parcs> what is the use case for superclass constraints? why force all instances of Num to be instances of Show and Read? what benefit do they provide?
16:56:57 <brisingr> It's mainly a "haskell is awesome" talk
16:57:19 <applicative> stepkut, yes, somehow it was easier to find in compiler/parser/Lexer.x than in the documentation. I must be a lost cause by now.
16:57:36 <Eduard_Munteanu> @google haskell qsort
16:57:36 <danharaj> if you have extra time, talk about 'real' projects like xmonad, things that galois work on, etc.
16:57:38 <lambdabot> http://www.haskell.org/haskellwiki/Introduction
16:57:38 <lambdabot> Title: Introduction - HaskellWiki
16:57:42 <Eduard_Munteanu> Grr.
16:57:50 <edwardk> parcs: bad example. in that case those don't belong, but you can say every monoid is a semigroup with a straight face
16:57:56 <brisingr> danharaj: yes, that's at the end
16:57:56 <Eduard_Munteanu> Ah, that's not bad.
16:57:57 <edwardk> or every monad is a functor
16:58:08 <parcs> edwardk: why would you want to, though?
16:58:10 <brisingr> ...and, alpounet, I'll keep you posted, I'll come here with dumb questions, and maybe I'll start a blog
16:58:15 <danharaj> parcs: because it's true!
16:58:18 <brisingr> thanks again for the help
16:59:20 <parcs> it may be true but so what?
16:59:31 <edwardk> parcs: i don't really know where to begin, i use it everywhere. do you want to have to say get :: (MonadState s m, Monad m) => m s ?
16:59:40 <edwardk> because you use those.
16:59:42 <Eduard_Munteanu> parcs: you can also draw upon those definitions
16:59:48 <edwardk> when i have an applicative i know i can use fmap
17:00:01 <edwardk> when i have a Real, I know I can (+) them
17:00:13 <edwardk> so i don't have to write 20 classes on the line for every argument
17:00:35 <alpounet> brisingr, good :)
17:00:39 <parcs> hmm, yeah
17:00:42 <edwardk> now, one can reasonably attack the infelicities in the choices made, but the actual idea of allowing those constraints is a good one
17:01:03 <dibblego> I'd rather say (Functor m, Pointed m, Applicative m, Monad m, MonadState m) => m s
17:01:36 <edwardk> dibblego: we've established that you are a little touched ;)
17:01:59 <Eduard_Munteanu> Do you mean your type sig should reflect the stuff you use in the definition?
17:02:10 <dibblego> I kid guys, though I do enjoy the touching
17:02:12 <parcs> maybe there should be some other construct that helps reuse class constraints that is orthogonal to class definitions
17:03:05 <edwardk> i eagerly await your patch to ghc ;)
17:03:15 <Eduard_Munteanu> Well, you can make up a class     class (Functor m, Pointed m, Applicative m, Monad m, MonadState s m) => Awesome s m
17:03:36 <parcs> haha
17:03:37 <Eduard_Munteanu> which has no additional methods
17:03:51 <Eduard_Munteanu> And add an instance for your specific thing.
17:04:28 <edwardk> well if you just want Awesome s m to be everything with those constraints you can follow it with a line where you s/class/instance
17:04:33 <edwardk> and build a poor man's class alias
17:09:11 <edwardk> yay, many is fixed!
17:09:44 <monochrom> is that by a custom-made many, or rewriting <|>?
17:10:16 <edwardk> custom-made many
17:10:54 <edwardk> i may build a lower tech reference implementation of parser that doesn't need this by virtue of not being cps'd so i can compare and contrast the performance
17:11:15 <edwardk> also it'll let me test the power of using codensity (naive parser) vs. the fancy 4 continuation parser
17:19:22 <Eduard_Munteanu> Hm, so DPH went in GHC 7.2?
17:21:18 <parcs> what is the Coverage Condition
17:21:20 <parcs> ?
17:22:26 <ddarius> edwardk: I don't think just Scott encoding structures makes a big performance actually.
17:22:38 <danharaj> I think you accidentally a word.
17:22:56 <edwardk> danharaj: ?
17:23:00 <edwardk> ah
17:23:01 <ddarius> So you can probably keep the codensity aspects but move to a data type.
17:23:09 <edwardk> yeah
17:23:28 <geheimdienst> suppose i were tired of the bazillion lines "import XMonad.This", "import XMonad.That". suppose further that i had an unholy hack to make Setup.lhs autogenerate a module that reexports everything, i.e., lets me replace all the lines with just one line "import XMonad.All__". how nuts am i?
17:23:41 <edwardk> thats what i was thinking. if i went to a cheesy data type, i could use codensity to build it using a codensity instance for MonadParser
17:24:00 <ddarius> geheimdienst: For your own crap, sure.  But people hate non-trivial Setup.lhses.
17:24:13 <edwardk> if i can recover enough performance that way it'd be a much easier to maintain
17:24:23 <parcs> never mind; i found the documentation on it
17:24:40 <ddarius> edwardk: One of my early thoughts about improving Parsec 3's performance reduced to just slapping ContT on it.
17:24:49 <ddarius> edwardk: It's possible that it will be faster.
17:25:10 <danharaj> what's the current state of the art of those arrow-based parsers?
17:25:14 <edwardk> well, one nice thing about the current trifecta model is that it is pretty easy to prototype
17:25:27 <edwardk> danharaj: i started reinventing them the other day as a style of applicative parser
17:25:42 <edwardk> i did a fair bit of work with them a couple of years back as well
17:25:54 <edwardk> but in general the arrows, they do nothing. ;)
17:26:03 <danharaj> edwardk: Eh? :p
17:26:04 * ddarius has happily ignored them this entire time.
17:26:05 <edwardk> its the obliviousness you need, which you get with applicative
17:26:16 <ddarius> edwardk: I think you meant "nozink!"
17:26:47 <edwardk> the swierstra style arrow parsers are really applicative parsers before he had the vocabulary to recognize them as such
17:26:53 <danharaj> ah
17:27:07 <danharaj> What do you think of arrows in general? It seems like opinion is split on their merit and the niceness of their properties.
17:27:34 <edwardk> applicatives eat their lunch for me i'm afraid
17:27:52 <dibblego> tell it how it is!
17:27:57 <danharaj> edwardk: The applicative instance you get when you fix the input type?
17:28:05 <edwardk> every time i think i have a nice arrow i realize i really wanted an applicative or i'm secretly just working with the kleisli construction of some monad
17:28:22 <ddarius> edwardk: Forget telling it how it is, tell me where a cheap racquetball court is.
17:28:23 <kmc> hmm, i hadn't heard of http://en.wikipedia.org/wiki/Quark_Framework#CAL until just now
17:28:35 <edwardk> i had one for linear maps, but then it turned out to be nicer to talk about the covector monad instead
17:28:43 <ddarius> kmc is oblivious.  Or just missed the couple month period where CAL was talked about everywhere.
17:28:52 <kmc> i must have missed it
17:29:05 <applicative> kmc, it comes up periodically' annoying it vanished.
17:29:12 <kmc> it looks a *lot* like Haskell
17:29:25 * shachaf must be oblivious too.
17:29:52 <dibblego> it's broken
17:30:12 <applicative> kmc, someone with knowledge (I think) put it on github recently, maybe you can contribute
17:30:19 <shachaf> Oh, wait, it's that Java thing. I heard of it.
17:30:20 <kmc> broken?
17:30:30 <elliott> i seem to remember it being broken i don't remember how
17:30:34 <elliott> is my input helpful
17:30:52 <dibblego> CAL's Java interface is simply unsafe*
17:30:59 <Eduard_Munteanu> Hm that CAL is pretty much Haskell with a C touch.
17:31:04 <elliott> dibblego: so is the FFI
17:31:15 <elliott> Eduard_Munteanu: you mean semicolons?
17:31:26 <Eduard_Munteanu> Not only... comments, field selectors
17:31:45 <elliott> oh, didn't see the field accessors
17:33:16 <Eduard_Munteanu> I wonder how fast does it get to be on JVM.
17:34:06 <shachaf> Probably several km/minute.
17:37:30 <applicative> elliott you mean you dont use semicolons on every line in haskell
17:37:48 <int80_h> I use smiley faces instead. Haskell loves miley faces.
17:38:24 <elliott> applicative: i get weirded out when i read code that doesn't use layout
17:38:34 <elliott> it looks like a different language
17:38:42 <Eduard_Munteanu> When every line of code winks at you, you know something could be wrong...
17:39:03 <applicative> elliot check out my style maven, http://mit.edu/kenta/www/three/multitape-turing/hudnqucv/
17:40:25 <applicative> i was having the worst time getting an emendation to compile until i realized that if you start "module Main (main) where{ "
17:40:35 <applicative> you have to end: "  }"
17:40:48 <monochrom> haha
17:41:22 <monochrom> this is why I usually write the pair "{}" at once
17:41:40 <ben> Do you mean "  }" and not just "}"?
17:42:38 * hackagebot haskeline-class 0.6.2 - Class interface for working with Haskeline  http://hackage.haskell.org/package/haskeline-class-0.6.2 (AntoineLatter)
17:43:17 * elliott notices applicative's message
17:43:28 <elliott> applicative: can I convince you to stop that?
17:43:28 <applicative> ben, that's just it, if you use }'s it doesn't matter! it's a great idea.  semicolons are the future!
17:43:54 <elliott> "IO(())" <-- nice
17:44:11 <elliott> http://mit.edu/kenta/www/three/multitape-turing/hudnqucv/infiniteturing.ll
17:44:15 <elliott> oh you lied to me this is generated code :P
17:44:24 <applicative> yes, I don't know how he figured out that that some of this stuff was legit
17:44:28 <applicative> is it?
17:44:37 <elliott> well look at http://kenta.blogspot.com/2011/07/hudnqucv-multi-tape-turing-machine.html...
17:44:39 <elliott> erm
17:44:43 <elliott> http://mit.edu/kenta/www/three/multitape-turing/hudnqucv/infiniteturing.ll
17:44:54 <elliott> hm wait no
17:44:56 <elliott> that looks like something else...
17:45:04 <elliott> oh no wait
17:45:07 <elliott> applicative: look at the bottom of that file
17:45:12 <elliott> (: test1 :fun (IO :unit)()
17:45:16 <elliott> definitely generated code (but why????)
17:45:44 <elliott> this is a mystery i do not want to examine further
17:46:04 <elliott> I'm not even sure what the rest of that file does
17:46:52 <applicative> which generates and which is generated?
17:47:02 <elliott> i am definitely sure that http://mit.edu/kenta/www/three/multitape-turing/hudnqucv/infiniteturing.ll is the generator.
17:47:11 <elliott> it looks _precisely_ like a DSL, and is not (much) insanely formatted
17:47:29 <elliott> the incredibly superfluous ()s and lack of whitespace are easily explained by an overly-cautious/crude code generator
17:47:47 <elliott> the only questions are why, and also why does the rest of that file have C++ code
17:47:51 <applicative> elliott, you're thinking people write lisp-like things that way, but not Haskell?
17:48:02 <elliott> except that it has haskell stuff in it too??
17:48:15 <elliott> applicative: no, I'm thinking that the .ll file's haskell DSL code looks like something a human would right
17:48:22 <RenJuan> the ll ext and content
17:48:25 <elliott> and the .hs file looks very much like the output of a dumb code generator on the latter
17:48:30 <elliott> umm, on the former.
17:48:31 <edwardk> that doesn't look that alien to me
17:48:33 <RenJuan> indicate it's a lexical scanner
17:48:36 <parcs> :t (lift (?m >>= ?f), lift ?m >>= lift . ?f) -- are these two types considered the same in the context of satisfying a law that they are?
17:48:37 <lambdabot>     Ambiguous occurrence `lift'
17:48:37 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
17:48:38 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
17:48:55 <edwardk> parcs: yes
17:49:25 <edwardk> parcs: lift is a monad homomorphism, so it doesn't matter which side you bind on
17:49:26 <applicative> funny, in his blog post http://kenta.blogspot.com/2011/07/hudnqucv-multi-tape-turing-machine.html he doesn't mention generating the .hs file
17:49:31 <parcs> edwardk: but they're not the same. the latter has an additional Monad (t m) constraint
17:49:53 <edwardk> yes, but they are spiritually required to yield equal answers
17:49:59 <elliott> applicative: it is obviously shame :)
17:50:01 <edwardk> or lift isn't a monad transformer
17:50:27 <edwardk> you can't 'state' the Monad (t m) constraint nicely in a haskell 98 fashion so the monad transformer class doesn't
17:50:30 <edwardk> but it is there
17:50:34 <zztr> anyone know of a webapp that publishes just a form for me to type haskell into. basically, ghci in a web page?
17:50:39 <elliott> applicative: but no, I see plenty of Haskell code above with some kind of template language, which looks like a code generator or at least parts of it, and I see stuff that looks human-written that is clearly some sort of Haskell DSL... so yeah, I'm pretty sure about this
17:50:44 <elliott> zztr: http://tryhaskell.org/
17:50:45 <applicative> but maybe when he speaks of "implementing it in Haskell" he means writing something that compiles to Haskell, so to say
17:50:58 <zztr> awesome elliott
17:50:59 * ddarius writes a C to Haskell compiler.
17:51:00 <elliott> edwardk: I keep running into situations where I need universally quantified typeclass contexts
17:51:06 <elliott> edwardk: usually I throw it all away and try something else
17:51:18 <edwardk> elliott: that is one way
17:51:23 <applicative> zztr, you can also private message lambdabot on here, talk to her all afternoon
17:51:30 <edwardk> the other way is to go slightly insane and define all the classes one level up ;)
17:51:38 <edwardk> er rather, another copy of
17:51:56 <elliott> applicative: also, what's with the random text strings in that URL and in seemingly all of the guy's blog posts... a man of mystery
17:51:58 <edwardk> http://hackage.haskell.org/packages/archive/prelude-extras/0.1.0.2/doc/html/Text-Show-Extras.html =)
17:52:14 <elliott> edwardk: oh boy :P
17:52:28 <parcs> edwardk: why can't you add the Monad (t m) constraint to the type of lift?
17:52:34 <edwardk> Show1 is effectively a Show with a universal quantifier over the first argument
17:52:39 <ddarius> edwardk: Ask Amy where I can find a racquetball court if she is around, and tell her thanks.
17:52:41 <elliott> class (forall m. (Monad m) => Monad (t m)) => MonadTrans t where
17:52:43 <elliott> coming soon to a GHC near you
17:52:49 <applicative> elliot, he's a strange one, thus I took his .hs file to be written by himself...  wait, maybe *he's* a bot too
17:52:55 <elliott> someone post it on /r/haskell, then they can't NOT implement it!
17:52:56 <edwardk> she's at the movies with friends, but i'll ask
17:53:16 <zztr> applicative: how does evaluation work? begin with a _? comma?
17:53:23 <ddarius> Movies!  Waste of money.
17:53:29 <elliott> zztr: >
17:53:34 <elliott> zztr: or ?run or @run if you really want to
17:53:55 <elliott> zztr: also :t for types (or ?type or @type (abbreviatable to ?ty or @ty) in private; :t doesn't work there)
17:54:22 <zztr> elliott ok thanks
17:54:37 <edwardk> parcs: doing so has a different meaning. 'lift' says it can transform ANY monad action. the signature you specified says, you can transform any monad action for which there is a corresponding Monad (t m) instance
17:54:38 <zztr> elliott otherwise the same as ghci?
17:54:49 <Eduard_Munteanu> You can't do IO stuff.
17:55:03 <Eduard_Munteanu> > putStrLn "Hello"
17:55:04 <lambdabot>   <IO ()>
17:55:16 <applicative> zztr, no, it can't hold a definition, so you write let foo x = x +1 in foo 3
17:55:20 <edwardk> i might define instance Monad (MyNotQuiteTransformer Either) where … but not define instance Monad m => Monad (MyNotQuiteTransformer m) where
17:55:27 <applicative> zztr, it's more like hugs that way.
17:55:35 <Eduard_Munteanu> There's @let though
17:55:36 <edwardk> so that constraint is actually wrong =)
17:55:53 <elliott> applicative: There's ?let, if you don't mind everyone seeing it until anyone does ?undefine
17:56:05 <elliott> zztr: You might just want to use ghci for long-term use :P
17:56:14 <parcs> edwardk: ah, okay :)
17:56:22 * Eduard_Munteanu wonders why the '@' and '?' variants though
17:56:27 <elliott> zztr: btw, you also can't do IO with Try Haskell
17:56:37 <Eduard_Munteanu> For obvious security reasons.
17:57:04 <zztr> elliott yeah i'm just looking for something to use while i'm browsing haskell docs in my free time on an android tablet
17:57:14 <elliott> Eduard_Munteanu: well, there are relatively easy ways to sandbox it. (maybe I should fork it.)
17:57:20 <zztr> so no computer
17:57:40 <applicative> zztr there's also codepad.org  and http://ideone.com/ of course
17:57:59 <Eduard_Munteanu> elliott: yeah, I think luite is working on something similar
17:58:15 <elliott> Eduard_Munteanu: excellent; competition!
17:58:31 <Eduard_Munteanu> SELinux, user limits and maybe cgroups, IIRC.
17:59:45 <applicative> zztr, codepad is lovely, it uses hugs.
17:59:55 <elliott> Eduard_Munteanu: Oh, that's much more complicated than it needs to be.
17:59:57 <elliott> applicative: hahahaha really
18:00:40 <Eduard_Munteanu> Well, I think seccomp might also do in some cases.
18:01:20 <Eduard_Munteanu> Though you still need to limit resource usage somehow, and luite doesn't use mueval IIRC
18:02:25 <Eduard_Munteanu> I'm not sure any approach is really easy anyway.
18:02:56 <elliott> Well, some are easier than others :P
18:03:28 <alpounet> there's hint too
18:06:21 * Eduard_Munteanu kinda wishes there was a big Linux firewall that included file access controls, resource quotas and all this stuff in one package.
18:06:52 <ddarius> Eduard_Munteanu: Make it.
18:09:28 <Eduard_Munteanu> There's that ftrace-for-security-purposes proposition, but even that wasn't really welcomed by everybody. It's quite a tough goal.
18:11:13 <applicative> hmm, hpaste uses hscolor, so it doesn't highlight anything but haskell?  this seems a little unfriendly?
18:12:15 <monochrom> hehe
18:12:48 <Eduard_Munteanu> There's an 'h' in there...
18:12:51 <Eduard_Munteanu> :P
18:18:10 <parcs> the documentation states that "A monad transformer makes new monad out of an existing monad." doesn't that imply that (t m) must be a monad if m is a monad, and therefore a Monad (t m) constraint on lift is actually ok?
18:18:25 <parcs> also, there is a typo in the documentation :P
18:19:05 <edwardk> the monad t m constraint doesn't require that it does so uniformly
18:19:13 <edwardk> that is the problem
18:19:42 <parcs> 'uniformly'?
18:19:55 <edwardk> a monad transformer is a _family_ of monad homomorphisms, one for every monad in haskell, chosen uniformly
18:20:17 <edwardk> i don't transform Either one way and Maybe a completely different way
18:20:51 <edwardk> enforcing that would require that kind of higher rank context that was talked about earlier
18:21:47 <parcs> oh i see
18:23:47 <parcs> so even with the Monad (t m) constraint a valid instance of MonadTrans isn't actually a monad transformer?
18:24:59 <edwardk> you could get away with one such, yes
18:25:31 <edwardk> and the Monad (t m) constraint isn't used by the transformer code, if it needs it it can generate it by other means
18:26:02 <edwardk> i.e. if you need the monad instance for StateT s m when defining lift for (StateT s) you have it because of the rules you put into scope anyways
18:26:14 <edwardk> so it adds no value, and would mean passing another unused dictionary
18:27:05 <dolio> Monad (t m) needlessly uses flexible contexts, too.
18:27:41 <dolio> If I'm not mistaken.
18:27:47 <edwardk> it compiled without the for me actually
18:27:52 <edwardk> i was ready to raise that issue ;)
18:27:58 <dolio> Huh.
18:27:59 <edwardk> er without them
18:28:04 <parcs> yeah, same here
18:29:39 <parcs> still, with the Monad (t m) constraint the laws would actually hold (in the sense that both expressions would have the same type)
18:30:56 <parcs> i should go email the maintainer about that typo
18:31:13 <edwardk> mtl?
18:32:20 <parcs> transformers
18:32:23 <edwardk> if the documentation bug is on the transformers side of the split its ross, if its on the mtl side its me
18:32:35 <parcs> okay
18:32:41 <edwardk> then you'll need to harass ross
18:41:07 <parcs> harassment complete
18:41:21 <geheimdienst> harossment
18:42:07 <edwardk> i'd offered to take over that one too but he wanted to hold on to it
18:47:39 * hackagebot openpgp 0.3 - Implementation of the OpenPGP message format  http://hackage.haskell.org/package/openpgp-0.3 (StephenWeber)
18:47:41 * hackagebot trifecta 0.26 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.26 (EdwardKmett)
18:51:49 <elliott> edwardk: oh hey, now I don't have to write my own parser combinator library
18:51:57 <edwardk> =)
18:52:03 <elliott> never knew that existed
18:52:09 <elliott> wait, is Text.Trifecta.Rope a string implementation based on ropes?
18:52:12 <edwardk> its coming along nicely
18:52:16 <elliott> are you trying to implement everything I was planning on doing? :(
18:52:18 <edwardk> sort of
18:52:21 <elliott> because that's rude
18:52:46 <edwardk> it also includes placeholders for expanded #line directives
18:53:17 <Saizan> if you had been the first edwardk could have used your package for a while, then roll his own anyhow
18:53:28 <edwardk> but yes, it is basically a fingertree of byte strings annotated with relative file positions
18:53:30 <edwardk> hahahaha
18:53:31 <elliott> hmm, what's with the haddock docs not working, just not generated yet?
18:53:34 <elliottcable> ffuufufuuuffufuufuufufuuffufuufuufuuufuu
18:53:38 <elliott> Saizan: but that's what I do :(
18:53:49 <elliott> I love how worked up elliottcable gets whenever I talk in here ever
18:53:54 <edwardk> partly that partly that the unix package hasn't been updated to work with 7.2
18:54:05 <edwardk> follow the homepage link and you'll find browsable code
18:54:20 <elliott> right
18:55:31 <edwardk> it is really funny how much mileage this thing gets out of my silly It type though
18:58:02 <elliott> edwardk: My attempts at nice source-location annotation usually fail after I abstract out the recursion in my AST type and then realise that it makes pattern-matching really awkward... I don't suppose Trifecta has any solution to _that_ problem, beyond having a specialised solution for bytestring source texts? :p
18:58:36 <edwardk> not entirely. you can use the 'Rendered' type to deal with that factored recursion to help a bit
18:58:42 <edwardk> or you can use Spanned, etc.
18:58:58 <edwardk> but i usually just either put the annotation directly in the type or roll through one like that
18:59:09 <edwardk> i _do_ have an article on one solution of sorts
18:59:35 <edwardk> http://comonad.com/reader/2009/incremental-folds/
19:00:23 <edwardk> there i use data (f :> m) = f (f :> m) :> m -- which is a cofree comonad in disguise
19:00:31 <elliott> I keep having a nagging feeling that someone must have solved it before, yes.
19:00:45 <elliott> edwardk: But of course :-P
19:01:17 <edwardk> but where it puts the annotation last
19:01:28 <applicative> hm, there doesn't seem to be any reason why hpaste cant call highlighting kate rather than hscolor -- highlighting kate does ocaml, which was being complained of
19:01:31 <edwardk> since i usually have to wrap the nested terms in parens anywys, foo (Bar a b c :> _) isn't much uglier to work with than foo (Bar a b c)
19:03:03 <elliott> edwardk: Do you have to do that for all subexpressions too, though?
19:03:20 <elliott> Hmm, maybe what's really needed is (a, Annotations a), where (Annotations a) has the same structure as a
19:03:29 <elliott> and a is the entire structure with no annotations
19:03:41 <edwardk> yes
19:03:42 <elliott> then you just need all the same navigation operations that you have on a, generalised so that they also navigate the annotations
19:03:47 <elliott> Or is that what you did :P
19:04:06 <edwardk> I usually convert from something like Mu f to (f :> annotation)
19:04:32 <edwardk> and i find the :> annotation mode to be less obtrusive, so i use that all the time instead
19:04:35 <elliott> Right
19:04:42 <edwardk> because the aforementioned parens are already present
19:04:47 <edwardk> when pattern matching, etc.
19:04:50 * elliott considers mocking something up with the idea he mentioned
19:04:58 <edwardk> whereas foo (Mu (Bar a b c)) is much uglier
19:05:10 <edwardk> foo (Bar a b c :> _) still reads cleanly
19:05:48 <edwardk> the combinators for attaching renderings and spans in trifecta all look kinda like that
19:06:04 <elliott> Right
19:06:12 <elliott> I suppose my representation has more runtime overhead...
19:06:23 <edwardk> :^ for a caret that draws like ^, :~ for a span that draws like ~~~~~, and :@ for a rendering, which can draw like anything
19:07:19 <edwardk> but i can then use any of those as a basis for a diagnostic message
19:09:11 <elliott> Unfortunately it's not clear what operations annotations in general have...
19:11:15 <edwardk> well, i let them automatically construct themselves if i have an appropriate algebra
19:11:48 <edwardk> consider an algebra that computes a size over a tree, from the sizes one level down
19:11:56 <elliott> edwardk: I'm just thinking about my zany different representation
19:21:36 <elliott> oh, cool
19:21:44 <elliott> I think my annotation types follow a really obvious structure
19:53:29 <hatds> anyone know how the old -XGeneric and new -XDeriveGeneric mechanisms compare?
19:56:51 <i142857> hey folks, new around here: i have an application that depends on libraries that use TemplateHaskell, and I'm building it in a cabal-dev environment. Trying to figure out a way to profile it without manually compiling each dependency. How do you do the "double compile" thing for your libraries using cabal/cabal-dev?
19:58:31 <kmc> hatds, they're pretty different and the new one is a lot more flexible, i think
19:58:40 <kmc> the best place to see a direct comparison would be the respective GHC manuals
19:59:52 <edwardk> just built an interned intset, memory footprint is good but speed is pretty slow
20:00:43 <edwardk> highlights the need for widening the identifier supply in intern i guess. instead of using one mvar, i'm thinking an array of them since i hve the hash to reduce collisions
20:03:25 <edwardk> bah. i went to install containers-benchmarks and it won't build because of a bug in aeson http://hackage.haskell.org/packages/archive/aeson/0.3.2.10/logs/failure/ghc-7.0
20:05:44 <gienah> edwardk: obvious idea is to try aeson-0.3.2.11
20:06:09 <edwardk> that was what cabal selected
20:06:47 <gienah> edwardk: right, I don't take much notice of what cabal selects, I use sed to loosen the dependencies
20:08:03 <edwardk> i guess i hadn't run cabal update in a while
20:08:03 <deech> Are there examples that show how to bind Haskell with C++ classes?
20:08:28 <edwardk> deech: the current best answer is to build a shim through c, its pretty ugly
20:08:47 <kmc> right; C++ has no official ABI (on most platforms)
20:09:01 <deech> edwardk: are there any examples of that on Hackage?
20:09:01 <kmc> you can't reliably link C++ code with C++ code built on a different compiler
20:09:10 <danharaj_> wxHaskell
20:09:18 <kmc> also on some platforms, the C++ calling convention is different
20:09:29 <edwardk> llvm bindings (though they use the c bidings), etc. i think someone had ogre bindings
20:09:32 <gienah> edwardk: possible culprits for setting too restrive range dependencies on aeson are: yesod-auth yesod-json
20:09:33 <kmc> and ghc doesn't know about it, because there are too many to go chasing
20:09:34 <deech> danharaj_: I'm looking at that. Anything smaller?
20:09:53 <danharaj> I'm not aware, sorry.
20:09:53 <edwardk> gienah in my case it was just that it wasn't out when i last ran cabal update ;)
20:10:32 <edwardk> i tend to steer pretty clear of the web framework and yesod stuff
20:10:41 <kmc> deech, i bet you can find non-Haskell-related examples of building a C api for a C++ lib
20:11:27 <kmc> i bet the FAQ Lite has one even
20:11:31 <deech> kmc: Oooh, hadn't thought of that. I guess this is how the Python libs do it.
20:11:33 <kmc> http://www.parashift.com/c++-faq-lite/mixing-c-and-cpp.html
20:11:59 <deech> kmc: looking at it right now. Thanks!
20:13:51 <elliott> oh, wow: "BTW there is another way to handle this whole thing: compile all your code (even your C-style code) using a C++ compiler. That pretty much eliminates the need to mix C and C++, plus it will cause you to be more careful (and possibly —hopefully!— discover some bugs) in your C-style code. The down-side is that you'll need to update your C-style code in certain ways, basically because the C++ compiler is more careful/picky than your C c
20:13:51 <elliott> ompiler."
20:14:02 <elliott> what a way to phrase "come over to the dark side" :)
20:16:56 <monochrom> BTW an even better way is to port all your code (even your c++ code) to haskell
20:17:42 <monochrom> plus it will cause you to become a much better programmer! XD
20:17:55 <kmc> elliott, yes, it's recommended to also read http://yosefk.com/c++fqa/
20:17:56 <kmc> for
20:17:58 <kmc> for balance
20:18:01 <deech> monochrom: Writing GUI libs is a thankless and nasty job, and its been done in c++.
20:18:10 <elliott> kmc: yeah, I like the FQA for the mostpart
20:18:13 <deech> kmc: That is a *hilarious* document.
20:18:17 <elliott> kmc: but it's not as entertaining as the FAQ ;-)
20:19:15 <applicative> "If you are an expert in the intricacies of C++, please consider this knowledge a kind of martial art - something a real master never uses."
20:20:10 <kmc> C++ is the world's most successful esolang
20:20:15 <kmc> so good that most people don't get the joke
20:20:28 <geheimdienst> ... least esoteric esolang
20:21:05 <elliott> geheimdienst: You've clearly never used C.
20:21:07 <elliott> erm
20:21:08 <elliott> geheimdienst: You've clearly never used C++.
20:21:15 <geheimdienst> :D
20:21:35 <elliott> kmc: I'm a fan of C++ sudoku, one form of which is as follows: take something that Oleg has done in the type system; do it in C++ templates.
20:22:03 <elliott> (Sometimes the result is even shorter, demonstrating C++'s wide range of expressivity in applications from stupid compile-time hacks to _really_ stupid compile-time hacks.)
20:22:15 <i142857> anyone have information on how to build a completely portable haskell environment for windows? no registry, no global/user files or configs, no need to install anything? it's pretty hard to even find binaries for ghc without a setup.exe ...
20:22:27 <applicative> "C++-FAQ [5.1] What does IMHO mean? "
20:23:33 <elliott> applicative: imho is a common C++ keyword that makes sure an implementation is only used by its original author; other people have to provide their own interpretations of its name and signature
20:23:44 <elliott> For instance: imho int doSomethingCreative(int a, int b) { return a + b; } // written by a boring person
20:24:03 <geheimdienst> elliott: http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46/5/1246985268_LzMLb#960831913_rhDdG the appropriate lambdacat for "c++ sudoku" would be this cat strangled by the strings
20:25:55 <applicative> trapd in Monad tutrl plz help
20:27:18 <geheimdienst> @remember elliott ... demonstrating C++ templates' wide range of expressivity in applications from stupid compile-time hacks to _really_ stupid compile-time hacks
20:27:19 <lambdabot> Good to know.
20:27:40 <applicative> simon cat sez: is fixed in teh HEAD kthxbai  -- catches the spirit well
20:28:18 <elliott> I should set up a cron job to automatically compile and install GHC HEAD
20:28:19 <edwardk> i always underestimate how long it takes for criterion benchmarks to run
20:28:28 <elliott> Then my computer could warm me up in the coldest hours, and I'd get exciting new bugs every day
20:28:43 <applicative> it has to refrigerate your cpu from time to time
20:28:49 <geheimdienst> i particularly like the terminally broken cup in that picture. i don't think it *can* be fixed
20:33:39 <BMeph> "When C++ is an option, C is probably a better option." So vague...what does he really mean? ;þ
20:34:33 <kmc> you could read the rest of the document to find out
20:36:23 <edwardk> bmeph: he means he is going to put his head down like ken thompson and pretend the last 20 years didn't happen
20:37:06 <BMeph> edwardk: I thought that was how (google-)go came about... <duck>
20:37:41 <edwardk> that was pretty much what i was alluding to =)
20:44:21 <Saizan> bah, no use forgetting the last 20 years, the berlin wall was already down in '91
20:47:40 <kmc> i don't know the context, but there are a lot of places where C++ is an option and few other languages are
20:47:46 <kmc> due to strict real-time requirements
20:48:25 <kmc> in high-frequency finance you either write C or C++, or you write Java and shell out for the Azul Systems crazyJVM
20:48:37 <kmc> this is a direct tradeoff between cost of hardware/software and cost of hiring programmers
20:49:00 <deech> kmc: I guess C++0X will help these folks.
20:49:10 <kmc> by making C++ even more hellishly complicated?
20:49:12 <kmc> sure
20:49:19 <kmc> i mean it will help, and hurt
20:49:51 <deech> kmc: I've heard that it introduces a lot of nice new functional features, closures and whatnot.
20:50:00 <kmc> sure, you get closures
20:50:01 <deech> 3rd hand info.
20:50:11 <thoughtpolice> lambdas are just a syntactic sugar over a C++ function object
20:50:13 <thoughtpolice> but they're nice
20:50:15 <kmc> you still need to explicitly manage memory of closures and of variables they close over
20:50:18 <kmc> it's no picnic
20:50:26 <deech> kmc: ye gods.
20:50:34 <kmc> deech, it's C++, it makes sense
20:50:38 <kmc> Haskell has seen a little use in HFT (Starling, Tsuru, and I guess Allston Trading now)
20:50:58 <kmc> but the slides I remember seeing (from Starling?) were like "We're high frequency! We care about *milliseconds*!"
20:51:18 <kmc> which is 3 orders of magnitude slower than what I'm used to
20:51:38 <geheimdienst> yeah there's a niche for c++, there's a niche for everything. however 99% of all software wouldn't need it ...
20:51:47 <kmc> but C++ is terrible even in its niche
20:51:53 <kmc> there should be a better language in that
20:52:23 <deech> kmc: The shootout seems to point to ATS as a possible alternative.
20:52:35 <kmc> you should read the ATS code before you say that
20:52:41 <thoughtpolice> ATS is the C++ of functional programming, only to the max
20:52:54 <kmc> it's largely embedded C
20:53:02 <thoughtpolice> the language is really a cleverly disguised syntactic hack directly over C, with a whole lot of constraint solving and shit on top
20:53:03 <kmc> also you should try to learn ATS and report back
20:53:05 <thoughtpolice> i kid you not
20:53:24 <thoughtpolice> that said, it can disallow interesting classes of errors. i've been playing with it, but dear christ is it hard to *not* hate the syntax
20:53:59 <applicative> ATS is unbelievably ugly
20:54:31 <thoughtpolice> the whole sort/type system situation is also incredibly complicated, and ATS has very little inference so you normally have to annotate the hell out of shit (at least they don't say they have good inference)
20:54:44 <deech> kmc: Haven't had time to delve into it, Haskell's keeping me pretty busy. It just seemed to do well on the benchmarks.
20:54:50 <kmc> yes, so does C
20:55:05 <kmc> so does my amazing new language KMCLang
20:55:10 <kmc> alias kmcc=gcc
20:55:24 <deech> kmc: Hah! Point taken.
20:55:25 <thoughtpolice> it's interesting in that you can prevent some interesting errors with actually a relatively small amount of code, but the language just has so much syntax and concepts you can't keep it in your head at once :|
20:55:46 <kmc> yeah, C with better static checking *is* an important thing
20:55:56 <kmc> but it will still be a pain to write C, even if your errors are caught at compile time
20:55:57 <thoughtpolice> maybe i should just force myself to write more programs in it
20:56:47 <deech> thoughtpolice: perhaps a web framework of some kind.
20:57:58 <thoughtpolice> kmc: when you look at the compiler output, it's pretty astonishing and frightening at the same time, because it's so close to C, but when you look at the language itself, that just makes it more evident it's just a thin syntactic veil over C, with a really advanced type checker
20:58:25 <thoughtpolice> so it's still painful to program in. but it can stop you from blowing your head off
20:58:38 <geheimdienst> how hard is it to learn ats, how good is the teaching material? i casually looked at something called a tutorial, and dumped it after reading < 1 page on account of the off-the-wall terminology
20:58:54 <geheimdienst> sigmas and sorts and terms and whatnot
20:58:57 <thoughtpolice> there aren't many resources. doublec has a good blog where he covers the important concepts
20:59:06 <edwardk> ats is godawful to work with in my experience
20:59:07 <thoughtpolice> http://www.bluishcoder.co.nz/tags/ats/
20:59:15 <thoughtpolice> edwardk: pretty much
20:59:29 <geheimdienst> yeah, i came across the chris double stuff already
20:59:33 <edwardk> it is enough to send one running to ur/web ;)
20:59:37 <thoughtpolice> :P
20:59:54 <deech> geheimdienst: Too much obscure terminology, says the Haskell programmer :)
21:00:18 <thoughtpolice> geheimdienst: chris has decent examples of most of the 'interesting' features. there's also a page somewhere about ATS for ML programmers that takes a different approach
21:00:35 * BMeph is scared, because Haskell programmers are saying that ATS has too much obscure terminology... >:O
21:00:39 <geheimdienst> deech, the hyprocisy has not escaped me ...
21:01:43 <thoughtpolice> edwardk: doublec is hardcore, he wrote the bitcoin nameparking exchange in ur/web *and* ATS (and some C, too)
21:01:49 <thoughtpolice> :P
21:02:14 <edwardk> ATS isn't obscure in the hard sense, it is obscure in the 'language written by a non-native english speaker' sense. it randomly abbreviates things and makes keywords out of acronyms, etc.
21:02:20 <BMeph> ML'er's guide to ATS: http://cs.likai.org/ats/ml-programmers-guide-to-ats (in case someone was curious)
21:02:39 * hackagebot intern 0.5.2 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.5.2 (EdwardKmett)
21:03:38 <edwardk> i added the intset to that version, but i need to do something to streamline data.interned. benchmarking the construction of 10s of thousands of elements in a tree takes a noticable amount of time =(
21:05:16 <geheimdienst> 10s of thousands of elements, sitting in a tree ...
21:05:35 <edwardk> on the other hand the trees compare in O(1) and they do size checks in O(1)
21:05:56 <edwardk> i was thinking about using them for the charsets i have in trifecta
21:06:16 <edwardk> but for that i need to remove the single chokepoint in the cache for id allocation
21:36:10 <malaclyps> so, i want to break on a Left value in a list
21:36:37 <malaclyps> and my first thought was 'break (either True False) foo'
21:37:21 <malaclyps> but the arguments to either have to take a value -- is there a correct way to construct such functions?
21:37:27 <ddarius> :t const
21:37:28 <lambdabot> forall a b. a -> b -> a
21:37:34 <c_wraith> :t isLeft
21:37:35 <lambdabot> Not in scope: `isLeft'
21:37:44 <c_wraith> hmm.  I was sure such a thing would exist
21:37:45 <edwardk> either (const True) (const False)
21:37:45 <ddarius> @hoogle isLeft
21:37:45 <lambdabot> No results found
21:37:59 <ddarius> c_wraith: It would be evil so it is banished.
21:38:03 <edwardk> :t Data.Either.isLeft
21:38:04 <lambdabot> Not in scope: `Data.Either.isLeft'
21:38:08 <c_wraith> ddarius: then what about isJust?
21:38:14 <ddarius> @hoogle isJust
21:38:15 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
21:38:26 <edwardk> guess it isn't there
21:38:37 <edwardk> they have a lefts and a rights but none of the silly tests
21:38:48 <ddarius> :t lefts
21:38:49 <lambdabot> forall a b. [Either a b] -> [a]
21:38:56 <c_wraith> :t partitionEithers
21:38:57 <lambdabot> forall a b. [Either a b] -> ([a], [b])
21:39:12 <ddarius> c_wraith: isJust was put there to tempt the sinners.
21:39:16 <c_wraith> haha
21:40:08 <edwardk> maybe is a jealous god
21:40:49 <edwardk> woot. gained about 2 orders of magnitude in performance in intern ;)
21:41:27 <edwardk> now i can justify switching to interned intsets in trifecta
21:41:50 <ddarius> :t foldr (either (\_ _ -> []) (:)) []
21:41:50 <lambdabot> forall a b. [Either a b] -> [b]
21:42:16 <ddarius> > foldr (either (\_ _ -> []) (:)) [] [Right 1, Right 2, Left 3, Right 4, Left 5]
21:42:17 <lambdabot>   [1,2]
21:42:28 <edwardk> cute
21:42:29 * ddarius strokes foldr.
21:42:40 * hackagebot intern 0.6 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.6 (EdwardKmett)
21:43:35 <luite> does anyone know how to change the name for a "bookmarklet" in chrome (a javascript link that you drag to your bookmarks bar)?
21:45:12 <BrianHV> luite: right-click on it and choose edit
21:50:45 <luite> BrianHV: oh I mean the default name, if I create a bookmarklet for other people to use
21:51:28 <BrianHV> ooooh
21:52:07 <BrianHV> if I had to venture a guess, I'd say the title attribute, probably with a fallback to the link text
21:52:16 <luite> doesn't work :(
21:52:38 <luite> it uses part of my javascript source, for some reason
21:53:57 <BrianHV> I just tried dragging a bookmarklet link and it used the link text...
21:54:15 <luite> with javascript?
21:55:41 <kmc> edwardk, do you have a simple example of how to use 'intern'
21:55:45 <kmc> maybe which could go in the docs?
21:55:47 <edwardk> hrmm, think you could live with a comparison for character sets that only lied and said two sets were not equal when they were when each contains exactly 557056 elements and one was constructed by adding elements and the other was constructed by removing?
21:55:59 <edwardk> kmc: there is a small example of a term type in the examples folder
21:56:10 <kmc> oh, cool
21:56:11 <edwardk> trifecta uses it internally to intern rope fragments
21:56:28 <BrianHV> luite: wait, I lied. I dunno. this is kind of off topic anyway. :)
21:56:49 <edwardk> so you can find it being abused there in Text.Trifecta.Rope.Hunk and more hideously in Text.Trifecta.Rope.Path
21:57:15 <edwardk> i'm tweaking Text.Trifecta.CharSet to use the Data.Interned.IntSet so I can do O(1) charset comparisons
21:58:37 <edwardk> and if i intern the charset i can cache the asciiset it holds onto as well
21:59:33 <luite> well, it's for a haskell-related site ;p  http://hdiff.luite.com/
21:59:37 <luite> oops, BrianHV
21:59:55 <luite> does the bookmarklet work for you?
22:01:13 <BrianHV> luite: the text you mean? no. I just get an icon, but no text. weird.
22:01:14 <mustelo> edwardk, can I make a request to export something from Trifecta.Parser.Literals which does character literals w/o the surrounding single quotes?
22:01:26 <edwardk> mustelo sure
22:01:37 <luite> BrianHV: no text at all? that's strange...it says hdiff.luite.com-;}})() here
22:01:38 <mustelo> (looks like characterChar would be up my alley)
22:01:38 * BrianHV wishes javascript were haskell.
22:01:53 <edwardk> it may wind up being some kind o Literals.Internals just to avoid cluttering the namespace, but it'll get out there ;)
22:01:58 <BrianHV> luite: this is on mac, fwiw. and I have no idea how long it's been since chrome updated itself.
22:02:03 <mustelo> edwardk, awesome.
22:02:08 <luite> ugh that's annoying
22:02:29 <luite> BrianHV: well maybe I can just announce it on -cafe and hope that someone points me in the right direction to fix the name :)
22:02:37 <BrianHV> :)
22:02:45 <BrianHV> open source at its finest
22:03:45 <luite> hehe it's not open source yet, I should upload the script to github
22:04:04 <luite> none is haskell though... two bash script, one php, a cgit config file and an apache virtualhost config
22:04:15 <BrianHV> ugh. I'm not even that good at haskell yet, and already I'm spoiled by it. javascript feels so unexpressive.
22:08:27 <mustelo> edwardk, so am I right in thinking trifecta differs from parsec wrt the 'token' hierarchy in that you've factored the ugly record passing stuff into the MonadTokenParser class?
22:08:35 <edwardk> yeah
22:08:38 <mietek> It looks like alex-2.3.5 doesn't build with ghc 7.2.1
22:08:48 <mietek> Has anyone run into that?
22:08:55 <edwardk> just make your parser type, use newtype deriving to pull in whatever monad transformers you want, and then add the MonadTokenParser instance
22:08:58 <edwardk> it takes about 4 lines
22:09:08 <mustelo> cool, sounds cleaner
22:09:42 <edwardk> the Token.Style module can be imported and provides the way to automatically build the whiteSpace parser
22:09:54 <edwardk> without entangling all the identifier formatting concerns
22:10:29 <edwardk> the nice part is the actual 'parser' implementation is just the Parser.Prim module, nothing else cares about its internals
22:10:41 <mustelo> cool
22:11:00 <edwardk> so i can play with simple versions to test semantics, work with a complicated one that does efficient static parser partial evaluation, etc.
22:11:10 <edwardk> and all the other combinators don't have to change
22:19:16 <mustelo> edwardk, I will say I enjoyed the type of unparser from Parser.Prim ...
22:19:23 <edwardk> =)
22:19:33 <mustelo> haddock also enjoys it
22:19:50 <edwardk> if you ball up most of the continuation in some 'K e r' type alias it isn't bad to look at
22:20:02 <edwardk> but i didn't want to export one
22:26:35 <mietek> Hm
22:26:55 <mietek> It looks like ghc 7.2.1 includes cabal 1.12.0, which isn't available anywhere else
22:27:09 <mietek> Including the cabal homepage
22:27:44 <thoughtpolice> mietek: the new bootlibs haven't been uploaded to hackage yet
22:27:48 <thoughtpolice> so lots of stuff will fail to build
22:27:57 <mietek> Yeah, cabal-install fails to build
22:28:14 <mietek> I really with cabal-install came with ghc
22:28:27 <mietek> s/with/wish/
22:28:32 <mietek> My lisp is getting worse when I'm annoyed
22:32:22 <apsyx> hi everyone
22:39:09 <apsyx> help
22:49:10 <coppro> 1/win 2
22:50:43 <edwardk> hrmm
22:51:05 <edwardk> kmc: around?
23:00:36 <soca> @hoogle io
23:00:36 <lambdabot> module Data.Array.IO
23:00:37 <lambdabot> module System.IO
23:00:37 <lambdabot> Prelude data IO a
23:01:00 <soca> @hoogle system.io
23:01:00 <lambdabot> No results found
23:01:09 <soca> @hoogle System.IO
23:01:09 <lambdabot> module System.IO
23:01:10 <lambdabot> System.IO data IO a
23:01:10 <lambdabot> System.IO.Error ioeGetErrorString :: IOError -> String
23:03:03 <edwardk> i think that some small number of nodes in Data.IntSet aren't being perfectly normalized
23:03:04 <edwardk> it doesn't happen in examples smaller than a couple hundred nodes but in larger trees i get nodes that have the same contents but which have different structure
23:04:47 <ddarius> At which point your interning bites you?
23:04:53 <edwardk> yep
23:05:21 <edwardk> i found it when i went to compare a couple of big unicode classes against one another
23:05:27 <edwardk> then started distilling it down
23:05:32 <kmc> yep edwardk
23:05:48 <edwardk> trying to figure out what could be getting denormalized in intmap
23:05:51 <edwardk> er intset
23:06:05 <edwardk> maybe the mask/etc pair?
23:15:29 <edwardk> or it could be my math
23:17:53 <edwardk> two bugs, one a trivial math problem, the other perhaps more structural.
23:33:25 <saco> @hoogle map
23:33:25 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
23:33:26 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
23:33:26 <lambdabot> Data.IntMap map :: (a -> b) -> IntMap a -> IntMap b
23:36:16 <edwardk> found it
23:36:18 <z1l0g>  /w bonus
23:36:58 <edwardk> once i got past the math error i had to deal with the fact that comparing two intsets could cause them both to be evaluated one after the other, but having starrted collecting one before it evaluated the other
23:37:39 <edwardk> if i put bang patterns on the arguments to (==) (and Ord) then i force the evaluation to have happened while the other was alive
23:38:32 <edwardk> previously my structures had been small enough not run afoul of this
23:55:12 <mustelo> edwardk, am I not supposed to use parseTest? it's segfaulting ghci...
23:55:21 <edwardk> mustelo: interesting
23:55:37 <edwardk> that is unexpected behavior
23:55:44 <edwardk> works fine locally, what platform?
23:56:03 <edwardk> parseTest (string "hello") "hello" blows up?
23:56:14 <mustelo> let me try to get a minimal example. arch linux 2.6.39. ghc 7.0.3
23:56:26 <edwardk> i'm on 7.0.3 but on a mac
23:58:08 <mustelo> well, that's odd. it's stopped :)
23:58:15 <edwardk> hah
23:58:37 <edwardk> if you can find an example that dies, please let me know
23:58:42 <edwardk> i don't do any unsafe indexing
23:58:53 <edwardk> so i should be free from faulting on my own recognizance at least
23:59:22 <mustelo> sure. the behavior I was getting was first an array index exception, and then rerunning the same again gave me a segfault.
23:59:36 <mustelo> this is when a parser failed.
23:59:50 <edwardk> hrmm, can you send me an example parser that was blowing up?
23:59:59 <mustelo> yeah, hang on
