00:08:42 <erus`> is there a song about monads yet?
00:12:01 * hackagebot zlib-bindings 0.0.1 - Low-level bindings to the zlib package.  http://hackage.haskell.org/package/zlib-bindings-0.0.1 (MichaelSnoyman)
00:14:43 <erus`> join my march on Cambridge to get unsafePerformIO removed
00:19:06 <nyingen> i heard monads are kind of like burritos
00:21:18 <maurer_>  /ignore nyingen
00:21:20 <maurer_> oops
00:43:40 <Cale> http://c-faq.com/decl/spiral.anderson.html -- ROFL C
00:45:03 <mustelo> wow
00:46:08 <leod> awesome
00:46:50 <int-e> Sure, you work from inside out, and take into account the various precedences ... but a spiral? Somebody had a tad too much imagination there.
00:48:47 <mustelo> I just realized it's by david anderson, heh
00:49:04 <int-e> Sorry, I don't know him.
00:50:59 <Cale> I don't understand why they decided that inside-out would be a good convention as opposed to left-to-right.
00:52:48 <Cale> signal :: Int -> Ptr (Int -> IO ()) -> Ptr (Int -> IO ())
00:54:31 <mustelo> looks like (>>=) to me
00:54:44 <shachaf> mustelo: ?
00:54:55 <mustelo> spouting nonsense, clearly
00:55:05 <mustelo> could be flip fmap I suppose
00:55:06 <Cale> fp :: Ptr (Int -> Ptr Float -> IO Char)
00:56:40 <int-e> Cale: If I had to speculate, one reason was to allow declarations of values, pointers and arrays on the same line. char a, *b, c[10], *d[10]; -- I don't know why they put * and [] on different sides though. Maybe there was precedent in some other language.
00:56:57 <shachaf> int-e: I doubt that was ever motivation for that syntax.
00:57:20 <mustelo> the thing is a lot of the syntax isn't that bad on it's own (modulo function pointers, I guess)
00:57:31 <mustelo> it's the nesting that's disgusting
00:57:36 * int-e wonders if K&R ever explained the reasons.
00:58:01 <flux> I understood the motivation just to have a syntax for variable definitions that mirrors their usage
00:58:19 <flux> so you type *b to get a char etc
00:58:31 <c_wraith> well.  C was initially based on a language called B, right?  And B was based on Algol of some sort?
00:58:59 <c_wraith> oh, B was based on BCPL
00:59:17 <int-e> "type resembles use" is another reason. So a prefix pointer dereference operator begets a prefix type modifier for pointers.
00:59:38 <shachaf> I think you could argue reasonably that pointer declaration syntax is backwards.
00:59:46 <shachaf> I.e., int &a should declare a as a pointer to an int.
01:00:16 <c_wraith> int-e: that argument is circular.  There's no reason [i]array  couldn't have been the syntax for indexing
01:00:18 <int-e> And you can always use typedefs if you don't like the nesting behaviour.
01:00:41 <c_wraith> ...  actually, that is the syntax for indexing, come to think of it. :)
01:00:53 <flux> c_wraith, you're thinking of i[array]?
01:00:54 <c_wraith> Oh, no it's not.  ok.
01:00:56 <c_wraith> yes
01:01:09 <c_wraith> But still, the "definition resembles use" argument is a bit circular.
01:01:15 <int-e> c_wraith: you mean i[array]? (now that one I actually consider a wart in C)
01:01:33 <shachaf> int-e: A wart? Huh?
01:01:57 <c_wraith> seems B didn't have types for pointers and arrays...  So they were a new invention in C
01:01:58 <int-e> shachaf: the fact that a[b] and b[a] mean the same in C. So 1["abc"] == 'b'.
01:01:58 <Cale> Algol 68 at least put type constructors to the left of what they were applied to
01:02:30 <c_wraith> so, yes, the syntax for them came from C
01:03:09 <shachaf> int-e: Why is that a wart? How would you prefer things to work?
01:03:15 <int-e> c_wraith: yeah, but putting indices after the array is very common. they are a sort of function after all, and f(x) is the most common notation for function application.
01:03:28 <int-e> shachaf: I'd prefer 1["abc"] to be an error.
01:03:39 <c_wraith> shachaf: it could be a type error.  (haha.  a type error in C!  how funny!)
01:03:47 <shachaf> int-e: What do you want the meaning of foo[bar] to be?
01:04:13 <int-e> shachaf: same as it is, except that bar should be forced to have an integral type.
01:04:29 <int-e> it's a minor wart, I admit, since programmers aren't forced to do such things.
01:04:30 <shachaf> "abc" has an integral type.
01:04:33 <ktosiek> int-e: I see, so you don't like the freedoms C gives you? :-P
01:04:37 <shachaf> Unless you mean non-pointer?
01:04:39 <int-e> no, "abc" has a pointer type
01:04:48 <Cale> In Algol 68, they had  ref [] real  for "pointer to array of reals", and proc (real, ref [] real) [] ref proc (real) real for "procedure taking a real, and reference to array of real and returning array of references to procedures taking real and returning real."
01:04:51 <int-e> shachaf: I guess
01:05:25 <shachaf> I think foo[bar] meaning *(foo + bar) and nothing more or less is perfectly reasonable.
01:06:16 <Cale> (though I don't actually know if they actually allowed returning procedures)
01:06:44 <Cale> I think Algol 68 allowed returning references to procedures though.
01:08:07 <Cale> So if C is based on Algol 68 in any way, they should have stolen the good syntax :P
01:09:11 <int-e> shachaf: per the C standard I mean "integer type".
01:10:33 <shachaf> I'm not really sure what the point is.
01:11:39 <int-e> Cale: but they still index arrays as foo[i]
01:12:02 <int-e> shachaf: that this class does not include pointers.
01:12:49 <shachaf> I'm not really sure what the point of restricting foo[bar] beyond *(foo+bar) is, I mean.
01:13:59 <aki> morning
01:14:08 * Cale reads about CPL
01:14:24 <Cale> (the language that BCPL was a simplification of)
01:14:57 <Cale> Interesting feature, first class labels
01:15:12 <Cale> label Switch = x < 0 -> L1, L2
01:15:16 <Cale> go to Switch
01:15:28 <Cale> will go to L1 if x < 0, or L2 otherwise
01:15:41 <Cale> (where L1 and L2 are labels)
01:17:15 <Cale> oh, only based on the value of x at the time of definition of Switch, which seems saner :)
01:19:17 <Cale> CPL had where clauses!
01:20:09 <ion> !
01:26:38 <boegel> is anyone in here aware of a good genetic algorithm library on Hackage?
01:27:04 <boegel> cause I wrote my own (still cabalizing it and adding documentation), which I plan/hope to release soon(ish)
01:27:54 * ion laughed out loud at http://c-faq.com/decl/spiral.anderson.html
01:28:52 <shachaf> Parsing C is probably easier than parsing Haskell.
01:29:09 <Jaak> Cale: gcc supports first class labels too (and so does clang) to some extent
01:29:16 <ion> shachaf: By humans?
01:30:16 <shachaf> By computers.
01:30:23 <shachaf> humans ⊂ computers
01:30:27 <Jaak> allows to implement direct threaded code easily
01:31:18 <ion> shachaf: Yes, it’s obvious C has been designed more for the benefit of computers than of humans.
01:31:24 <shachaf> Jaak: You mean the && thing?
01:31:39 <Jaak> yep
01:31:58 <Cale> shachaf: Though, there are things which are easy for humans but hard for computers and vice-versa.
01:32:13 <Cale> (for digital computers ;)
01:36:02 <luite> does anyone have a script for generating a hoogle index for all installed packages?
01:40:40 <frerich2> ion: Ugh. It's sad that this is actually useful.
02:03:26 <vokoda> why can I do `map (chr . (+65))` but not `map (chr . (-65))`
02:03:52 <Botje> what character would -31 be?
02:04:08 <kizzx2> vokoda: (subtract 65) ?
02:04:10 <Botje> also, it has to do with haskell's parsing of negative numbers
02:04:14 <Botje> you want subtract there, yes
02:04:28 <Botje> @pl \x -> x - 65
02:04:28 <lambdabot> subtract 65
02:04:31 <Botje> ^ ^
02:04:44 <vokoda> Botje: sorry yeah, thats a bad example - I'm getting at the parsing of negative numbers thing
02:05:00 <vokoda> why does it parse negative numbers different to positive?
02:05:26 <kizzx2> :t (-5)
02:05:27 <lambdabot> forall a. (Num a) => a
02:05:32 <kizzx2> :t (subtract 5)
02:05:34 <lambdabot> forall t. (Num t) => t -> t
02:05:57 <ceii__> vokoda, that's a kludge to make things like 5 * (-2) do what people expect
02:06:15 <shachaf> > (5 * subtract 2) 3
02:06:17 <lambdabot>   5
02:06:22 <shachaf> > (5 * subtract 2) 4
02:06:23 <lambdabot>   10
02:06:24 <ceii__> while allowing you to define sections like (/2), (+4) etc. at the same time
02:06:49 <vokoda> ceii__: got it, thanks
02:12:03 * hackagebot bitstream 0.2.0.1 - Fast, packed, strict and lazy bit streams with stream fusion  http://hackage.haskell.org/package/bitstream-0.2.0.1 (MasatakeDaimon)
02:17:03 * hackagebot hcwiid 0.0.1 - Library to interface with the wiimote  http://hackage.haskell.org/package/hcwiid-0.0.1 (KiwamuOkabe)
02:17:05 * hackagebot carettah 0.0.1 - A presentation tool writtten with Haskell.  http://hackage.haskell.org/package/carettah-0.0.1 (KiwamuOkabe)
02:37:03 * hackagebot LinkChecker 0.1 - Check a bunch of local html files for broken links  http://hackage.haskell.org/package/LinkChecker-0.1 (JensStimpfle)
02:47:03 * hackagebot nixos-types 1.1 - Data types representing the Nix language  http://hackage.haskell.org/package/nixos-types-1.1 (PeterSimons)
02:47:05 * hackagebot cabal2nix 1.13 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.13 (PeterSimons)
02:47:49 <kmc> shiny!
02:47:53 <hvr> is code.haskell.org down again? :-/
02:49:04 <m3ga> hvr: http://www.downforeveryoneorjustme.com/code.haskell.org
02:49:43 <hvr> m3ga: :-) & :-(
03:02:09 * hackagebot carettah 0.0.2 - A presentation tool writtten with Haskell.  http://hackage.haskell.org/package/carettah-0.0.2 (KiwamuOkabe)
03:11:58 <Ivoz> incase any of you haven't seen this, good stuff: http://fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf
03:15:05 <int-e> monochrom: FWIW, I updated (not replaced; the versions are different) Cabal as described in my mail and bin-package-db is still ok. I suppose things will break down the road if parts get linked against the new Cabal and then used together with ghc based packages. And fixing that will mean replacing the Cabal-dependent stuff and that will break other packages.
03:16:49 <int-e> monochrom: oh and I'm using --global exclusively. which, as you point out, helps avoid the worst of the problems that you describe.
03:39:52 <byorgey> mustelo: you can send bug reports to me, I can forward them on to the rest of the authors
03:40:16 <byorgey> mustelo: we don't really have any system in place for gathering bug reports, perhaps we should
03:41:23 <mustelo> byorgey, hmm, okay. honestly I've already forgotten where it was... n and m transposed somewhere
03:41:50 <byorgey> hehe, ok
03:43:07 <jeetu> byorgey: May be you can used google.code or sourceforge to host your projects. They provide issue tracker mechanism.
03:43:53 <jeetu> byorgey: We use trac for inhouse projects. Its good and open.
03:55:36 <luite> is code.haskell.org down?
03:57:55 <Ivoz> luite: http://www.downforeveryoneorjustme.com/code.haskell.org
04:18:37 <danel> hi, does anybody know what is happening with code.haskell.org?
04:19:45 <erus`> haskell.org has uptime similar to reddit
04:22:08 <Peaker> Maybe they're using Haskell for their server, and Haskell is infamous for its poor reliability... <ducks>
04:22:55 <luite> the machine is up, but the web server isn't running or something
04:23:02 <luite> it pings and all
04:23:31 <erus`> probably happstack...
04:23:44 <erus`> ;)
04:23:48 <luite> bah they should've switched to yesod of course
04:25:38 <idnar> haha
04:33:52 * Cale plays around with Algol 68
04:34:09 <kmc> what's the premier Algol 68 implementation?
04:34:56 <kmc> Cale, you've probably seen http://www.cowlark.com/2009-11-15-go/
04:35:19 <Cale> I'm using Algol 68 Genie
04:36:31 <Cale> http://jmvdveer.home.xs4all.nl/algol.html
04:36:48 <Cale> It's actually pretty surprisingly featureful.
04:37:05 <Cale> I mean, for an Algol 68 implementation :)
04:37:32 <Eduard_Munteanu> Why... would... you...
04:38:25 <Cale> Just to see what Algol 68 could do. It's a lot nicer than C.
04:38:29 <int-e> Somebody mentioned a link to a rant about how bugs never get fixed in open source software and only closed when the code in question gets rewritten on haskell-cafe a month or two ago. The example was gnome, IIRC, and the context probably the haskell platform. Does anybody remember the link?
04:39:09 <Cale> What better way to fix a bug than to rewrite the code that it's in? :)
04:39:21 <Eduard_Munteanu> Cale: hm, that's an interesting point of view.
04:39:45 <int-e> (I failed to come up with good keywords for google.)
04:40:11 <Eduard_Munteanu> Do you mean the higher level constructs? I don't know much about Algol, but it seems to have such things.
04:40:39 <Cale> Procedures are nearly first class.
04:40:42 <Eduard_Munteanu> To be fair, recent C features and dialects also do.
04:40:53 <Eduard_Munteanu> Ah.
04:41:48 <danr> So binary's runGet operates on lazy bytestrings. What's the best remedy if I have a strict bytestring?
04:41:54 <Cale> The only restriction (admittedly a harsh one) on what you can do with procedures, is that you can't capture the values of the enclosing environment in any procedure which escapes from that environment.
04:42:24 <ziman> danr, there's the binary-strict package, iirc
04:42:36 <kmc> strict bytestring -> lazy bytestring is very cheap
04:42:49 <kmc> because a lazy bytestring is just a list of strict bytestrings
04:43:04 <kmc> Lazy.fromChunks . return
04:43:15 <danr> Ok!
04:43:22 <danr> I'll go for that! Thanks ziman and kmc
04:43:40 <Cale> So you can return a procedure from a procedure, but it can't have any free variables that get bound by that enclosing procedure.
04:43:55 <DrTeggy> Closures!
04:44:20 <Cale> Yeah, closures would be an implementation mechanism you could use to get around that limitation.
04:44:58 <Eduard_Munteanu> If only closures weren't such a bitch to implement for low-level languages...
04:46:21 <Eduard_Munteanu> I mean, the minute you start requiring a GC you kinda lose some potential users.
04:46:23 <Cale> It can, interestingly enough, have free variables which are bound at the top-level, but it doesn't capture their current values, just references to them.
04:47:09 <DrTeggy> There's closure conversion, right?  (Reynolds-style).  Turn closures into records (data), turn functions into tags in these records.
04:47:14 <dolio> That isn't very surprising.
04:47:38 <Cale> Yeah, that's easy enough to implement :)
04:47:42 <dolio> Languages with mutable variables and first-class functions typically don't capture the values at the time of their creation, either.
04:48:04 <Cale> (and pretty necessary if you want to make calls to other stuff in the program :)
04:50:57 <Eduard_Munteanu> BTW, did JHC regions get anywhere?
04:51:21 <Eduard_Munteanu> (region inference, that is)
04:51:33 <dolio> Not really.
04:51:53 <Eduard_Munteanu> Last time I heard, some people said they were broken in the context of Haskell semantics
04:52:06 <Eduard_Munteanu> (or at least difficult to do)
04:52:38 <dolio> Can't say I know about that.
04:52:46 <Peaker> dolio: capturing the mutable variable/cell is more powerful than capturing the value (though more powerful isn't necessarily better)
04:53:26 <dolio> But I know jhc finally got a garbage collector added, because region inference wasn't actually handling the memory well enough.
04:53:34 <Cale> The prelude for this Algol 68 implementation seems to contain stuff for making web requests and talking to a postgresql server. Unfortunately that stuff doesn't actually seem to be written in Algol 68.
04:54:20 <Eduard_Munteanu> I wish we had seen at least a working region inference implementation. :(
04:58:26 <hpaste_> stulli pasted “Trying to install RSA package: Duplicate instance declarations” at http://hpaste.org/50683
04:59:06 <stulli> Does anybody know how to resolve this issue?
04:59:10 <Eduard_Munteanu> I'm also thinking about having separate modules, some being region inferred, some getting GCed. So an OS kernel could bootstrap itself then enable a GC coded in Haskell for the GC-ed parts.
04:59:53 <Eduard_Munteanu> (I guess that'd be nice a nice thing for the GHC RTS too)
05:00:12 <Eduard_Munteanu> (s/nice a/a/)
05:05:07 <kmc> i wonder what i should read to learn how to write a tracing JIT
05:05:12 <kmc> i have some papers
05:05:35 <kmc> i'd love to see a nice documented example
05:05:38 <kmc> maybe https://github.com/resistor/BrainFTracing
05:08:30 <Eduard_Munteanu> kmc: if you'd like a compiler to experiment upon, there's Jato. </shameless spam>
05:08:47 <Eduard_Munteanu> (it's not a tracing JIT though)
05:09:37 <Eduard_Munteanu> (but patches are welcome :D)
05:11:35 <kmc> the JVM implementation?
05:11:35 <kmc> cool
05:12:01 <kmc> right now i'm looking to implement a toy tracing JIT of some kind by myself from scratch
05:14:58 <Jophish_n900> hi all!
05:15:11 <Jophish_n900> does this channel have a haskell interpreter bot?
05:15:17 <kmc> > text "yes"
05:15:18 <lambdabot>   yes
05:15:18 <mekeor> Jophish_n900: hi =)
05:15:35 <kmc> > fix ((0:) . scanl (+) 1)
05:15:37 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:15:49 <Cale> LOL, Suppose 2^(1/3) = p/q for some p, q in N. Then 2 = p^3 / q^3, or equivalently, q^3 + q^3 = p^3, but this contradicts FLT. Hence, 2^(1/3) is irrational.
05:15:54 <Jophish_n900> is he open source?
05:15:57 <kmc> she
05:16:00 <kmc> and yes
05:16:01 <Cale> Jophish_n900: yes
05:16:06 <kmc> http://hackage.haskell.org/package/lambdabot
05:16:13 <Jophish_n900> brilliant!
05:16:19 <mekeor> kmc: wow! that seems to be the shortest fibonacci-impolementation i've ever sween O_O
05:16:27 <Eduard_Munteanu> Cale: nice
05:16:46 <kmc> it's a good one
05:16:51 <kmc> i learned it here; don't remember from whom
05:17:07 <mekeor> *seen
05:17:10 <Cale> Eduard_Munteanu: An additional funny point here is that FLT isn't strong enough here to prove 2^(1/2) is irrational analogously.
05:17:10 <kmc> > scanl (+) 1 [0..]
05:17:11 <lambdabot>   [1,1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,25...
05:17:31 <Eduard_Munteanu> That's a nice one to use in school :P
05:17:36 <Eduard_Munteanu> Yeah.
05:18:22 * mekeor doesnt/didnt learn fibonacci at school (and won't)
05:18:55 <kmc> > fix ((2:) . scanl (+) 1)
05:18:57 <lambdabot>   [2,1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,1512...
05:19:59 <fryguybob> @oeis 2,1,3,4,7,11,18,29
05:20:00 <lambdabot>  Lucas numbers (beginning at 2): L(n) = L(n-1) + L(n-2). (Cf. A000204.)
05:20:00 <lambdabot>  [2,1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,15127...
05:22:02 <mekeor> let's play "who can write the shortest pascal's-triangle--function? (in haskell, of course)"!
05:22:50 <mekeor> an infinite list like this shoulb be the output of the function: [[1],[1,1],[1,2,1],[1,3,3,1]...]
05:23:33 <byorgey> Cale: haha, best irrationality proof I've ever seen =)
05:25:56 <kmc> >
05:26:03 <kmc> > iterate((1:).(++[1]).ap(zipWith(+))tail)[1]
05:26:04 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
05:26:06 <mekeor> byorgey, Cale: what is FLT?
05:26:16 <byorgey> mekeor: Fermat's Last Theorem
05:26:43 <byorgey> kmc: nice =)
05:26:44 <mekeor> kmc: WOW.
05:26:54 <mekeor> @src ap
05:26:55 <lambdabot> ap = liftM2 id
05:27:09 <kmc> ap f g = \x -> f x (g x)
05:27:14 <kmc> it's the S combinator
05:27:16 * byorgey was getting close but forgot about the (++[1])
05:27:20 <kmc> also (<*>)
05:27:36 <kmc> i used @pl of course
05:27:42 <kmc> which is like building a robot to make your golf swings for you
05:27:51 <kmc> except i didn't write @pl either
05:27:53 <hnsz> byorgey: How about proof by contradiction?
05:28:09 <mekeor> @pl?
05:28:09 <lambdabot> (line 1, column 1):
05:28:09 <lambdabot> unexpected end of input
05:28:09 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
05:28:19 <byorgey> hnsz: hmm?
05:28:24 <kmc> > iterate (\xs -> 1 : zipWith (+) xs (tail xs) ++ [1]) [1]
05:28:26 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
05:28:31 <kmc> that's what i had pre-@pl
05:29:00 <mekeor> kmc: what's @pl ?
05:29:01 <Cale> > fix (([1]:) . map ((1:) . (++[1]) . (zipWith (+) <*> tail)))
05:29:02 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
05:29:11 <kmc> @help pl
05:29:11 <lambdabot> pointless <expr>. Play with pointfree code.
05:29:15 <hnsz> byorgey: Was it the best proof by contradiction you've ever seen too?
05:29:20 <kmc> @pl \x y -> f y x
05:29:20 <lambdabot> flip f
05:29:26 <Cale> (just to be analogous to the fibs earlier)
05:29:56 <mekeor> kmc: cool, ty
05:30:02 <byorgey> hnsz: it was not a proof by contradiction.  The definition of irrational is "not rational". Hence, in order to *constructively* prove irrationality, you assume rationality and derive falsity.
05:30:06 <mekeor> @src <*>
05:30:06 <lambdabot> Source not found. Just try something else.
05:30:25 <byorgey> it does not require the law of excluded middle.
05:30:37 <mekeor> Cale: what's <*> ?
05:30:40 <mekeor> @hoogle <*>
05:30:41 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
05:30:42 <Cale> Unless the proof of FLT does, which it probably does.
05:30:55 <kmc> (<*>) = ap, except generalized from Monad to Applicative
05:30:59 <byorgey> hah, yes, probably =)
05:31:56 <Cale> I think the current proof of FLT even uses choice.
05:33:00 <Entroacceptor> yes, it does
05:33:17 <Entroacceptor> really? That's awesome
05:33:54 <byorgey> ... did you just respond to yourself?
05:34:24 <Entroacceptor> no, I just left the links to the discussion as an excercise to the reader
05:34:38 <Entroacceptor> the aweseome was a reply to Cale about choice.
05:35:06 <Entroacceptor> the "yes it does" was that the FLT proof uses proof by contradiction, AFAIK
05:35:28 <Entroacceptor> and it looked so weird because I forgot to scroll down again, so I missed a few lines of discussion
05:36:36 <byorgey> oh, haha, I thought "yes it does" was in reference to choice
05:40:05 <mekeor> according to the german wikipedia, Wiles' proof of FLT is a proof by contradiction; (but) is Wiles' proof the "current" one, as Cale referred to?
05:40:39 <fryguybob> Perhaps there is a constructive proof of FLT for n=3 though.
05:40:55 <Cale> mekeor: Essentially, yes
05:42:09 <byorgey> I think there is: http://fermatslasttheorem.blogspot.com/2005/05/fermats-last-theorem-proof-for-n3.html
05:42:34 <mekeor> see also: http://en.wikipedia.org/wiki/Wiles%27_proof_of_Fermat%27s_Last_Theorem
05:45:30 <Cale> Oh, apparently much of the proof isn't even directly in ZFC, but uses ZFC + Universes, though that should be possible to eliminate.
05:45:44 <Cale> (tediously)
05:45:52 <rwbarton> I was going to say, I wouldn't be surprised if the proof even used grothendieck universes for technical convenience
05:47:40 <rwbarton> but I would be very surprised if someone managed to formalize the proof in a setting without LEM...
05:48:31 <roconnor> Fermat's Last theorem is double negation stable.
05:48:43 <roconnor> Proof by contradition is perfectly acceptable.
05:49:04 <rwbarton> yes
05:49:22 <rwbarton> so I suppose the formalization would consist of embedding everything in a classical subworld
05:49:35 <kmc> you're saying you can prove FLT from ¬¬FLT constructively?
05:49:39 <roconnor> kmc: yes
05:49:51 <rwbarton> since FLT is of the form ¬P
05:50:02 <roconnor> more or less
05:50:39 <kmc> ah, and ¬¬¬P -> ¬P is constructively valid?
05:50:45 <roconnor> yes
05:50:58 <kmc> cool
05:51:04 <roconnor> @djinn (Not (Not (Not a))) -> (Not a)
05:51:05 <lambdabot> f a b = void (a (\ c -> c b))
05:51:35 <fryguybob> @check \a b c -> a*a*a + b*b*b /= c*c*c || (a == 0 || b == 0) -- This should clear things up.
05:51:36 <lambdabot>   "OK, passed 500 tests."
05:51:56 <roconnor> it depends on how you phrase things though
05:52:06 <rwbarton> of course, everything is of the form ¬P classically...
05:53:46 <roconnor> if you phrase it as forall n a b c :: Nat, ((a+1)^(n+3) + (b+1)^(n+3) /= c^(n+3), then you need to do a bit of induction to get from ¬¬FLT to FLT.
05:55:16 <Cale> Is the fact that we're proving something which is a negation enough to use all classical results in our proof? (even positive ones proved using contradiction)
05:55:50 <roconnor> Cale: all of classical logic, yes.  Via Goedel's double negation translation.
05:56:04 <Cale> ah, right, we can just double negate all those results
05:56:09 <Cale> okay
05:56:19 <roconnor> Cale: but maybe not all of classical mathematics.  Choice is a bit tricky.
05:56:34 <Cale> Well, you can still just have choice as an axiom, no? :)
05:57:02 <rwbarton> doesn't it imply LEM I thought
05:57:21 <roconnor> However Schoenfield's absolutness theorem says that choice is conservative for Pi^1_2 sentences.
05:57:27 <rwbarton> probably one has to be very careful with the exact statements one is assuming
05:57:30 <roconnor> and FLT is Pi^0_1
05:57:38 <Cale> rwbarton: How could it imply LEM?
05:57:38 <roconnor> which is well well below Pi^1_2
05:57:44 <Cale> hmm
05:57:56 <rwbarton> hmm, perhaps I am thinking of something else
05:58:12 <roconnor> rwbarton: the double negation translation of choices doesn't imply LEM for constructive disjunction.
05:58:19 <roconnor> *of choice
05:58:23 <rwbarton> oh ok
05:58:42 <roconnor> but a naive translation of extentional choice does imply LEM.
05:58:47 <rwbarton> right, thanks
05:59:24 <roconnor> of course intenstional choice is a theorem.
05:59:55 <roconnor> I don't know if  Schoenfield's absolutness theorem applies to ZFC + Universes, but it seems likely.
06:00:20 <mekeor> ö
06:00:27 <roconnor> mekeor: thanks
06:00:33 <mekeor> :)
06:00:39 <Cale> Isn't LEM up at the level of propositional logic, while Choice is a statement about sets? I don't see how you can just assume something about sets, and get out a propositional axiom schema.
06:00:58 <roconnor> Cale: choice is a statement about existance.
06:01:22 <Cale> Well, in that there's an existential in it.
06:01:40 <roconnor> and existance of certain binary sets is enough to decide disjuctions of propositional formulas IIRC.
06:02:09 <Cale> I don't see how you could even write such a thing down.
06:02:20 <roconnor> basically A \/ B is logically equivallent to the Exists b:Bool. if b then A else B.
06:02:34 <Cale> You can't even talk about what's true in your propositional logic in terms of statements about sets.
06:02:45 <roconnor> I just did
06:02:56 <roconnor> if you think of the type Bool as a set.
06:02:59 <rwbarton> you have a set of truth values
06:04:17 <Cale> Are you assuming some weird converse of the comprehension axiom?
06:04:46 <Cale> (schema)
06:05:12 <roconnor> Cale: Hmm
06:05:46 <roconnor> Cale: maybe it would be more clear if we said that Choice is a statement about the existance of choice functions rather than the some set specific encoding of this fact.
06:06:10 <Cale> You're probably doing some weird level-mixing thing which I wouldn't approve of.
06:06:31 <applicative> proof by choices preceded set theory
06:09:03 <Cale> We have some logical system with a bunch of connectives, and we add to it quantifiers and a relation symbol and start to talk about sets using that relation symbol. We add some axioms about sets, including one which looks like Choice. How can discussing sets ever get us back to proving something in general about propositions in this logic, without doing something which is really entirely unrelated like embedding our en
06:09:03 <Cale> tire system as a set?
06:11:10 <HugoDaniel> hi
06:11:15 <Cale> The inner system which is a set isn't necessarily the same thing as our outer system. The same things aren't necessarily true of it. We can formulate many different logics with different properties as sets, and there's no way for the sets to tell what's true about propositions in the system that's talking about them, is there?
06:11:30 <HugoDaniel> whats the fastests way to serialize my datatypes to ByteStrings into a file that can later be read ?
06:11:41 <HugoDaniel> aeson doesn't work in windows...
06:11:46 <HugoDaniel> :(
06:11:46 <Cale> HugoDaniel: maybe something like cereal?
06:12:01 <HugoDaniel> thanks Cale, let me check it up
06:12:06 <applicative> HugoDaniel:  It's the c library it depends on, no, the "double conversion"
06:12:23 <applicative> HugoDaniel: I mean, the aeson trouble
06:12:44 <Cale> Oh, you want JSON output?
06:12:48 <HugoDaniel> applicative: yes
06:12:59 <applicative> HugoDaniel: but at least the repository version has a way of finessing the use of the library, no?
06:13:02 <HugoDaniel> Cale: JSON would be great, but ive already scratched it from my requirements :/
06:13:26 <HugoDaniel> cereal seems nice, now i just hope i can automatically derive the Serialize typeclass
06:13:44 <hnsz> lua?
06:14:21 <HugoDaniel> i also like that ghci in windows just randomly disapears for no apparent reason
06:14:46 <HugoDaniel> maybe is my windows 2003 box that is crippled beyond repair
06:17:35 <Cale> HugoDaniel: How is aeson broken on windows?
06:17:39 <Cale> That sounds odd.
06:17:58 <HugoDaniel> Cale: its the double conversion c++ lib
06:18:07 <HugoDaniel> i tried some of the things written in the bug report
06:18:31 <HugoDaniel> but i couldn't make it work properly, most likely is my english reading skills that are lacking
06:18:53 <Cale> double conversion?
06:19:44 <kmc> HugoDaniel, 'binary' and 'cereal' are pretty similar
06:19:48 <kmc> 'binary' is in Haskell Platform I think
06:20:34 <HugoDaniel> Cale: http://hackage.haskell.org/trac/ghc/ticket/5289
06:21:01 <HugoDaniel> Cale: more: http://hackage.haskell.org/trac/ghc/ticket/5289#comment:29
06:21:56 <mekeor> according to http://hackage.haskell.org/packages/archive/containers/latest/doc/html/src/Data-Set.html#Set, `Set' can be defined as follows: `data Set a = Tip | Bin {-# UNPACK #-} !Size !a !(Set a) !(Set a)'. could some one explain me that definition? i don't get it...
06:22:25 <kmc> mekeor, it's a binary search tree
06:22:35 <kmc> simplified as:  data Set a = Tip | Bin a (Set a) (Set a)
06:22:58 <HugoDaniel> oh, i can't derive Binary or Serialize :(
06:23:11 <mekeor> kmc: ah, okay... but:
06:23:15 <kmc> HugoDaniel, look at binary-generic
06:23:20 <HugoDaniel> ah cool :D
06:23:27 <kmc> also http://hackage.haskell.org/package/derive
06:23:37 <mekeor> WTF!
06:23:43 <kmc> netsplit?
06:23:51 <hnsz> It has begun!
06:24:01 <hpc> mekeor: a Set is an unordered container of unique values
06:24:10 <hpc> a binary tree doesn't have any ordering either
06:24:13 <mekeor> hpc: agreed.
06:24:37 <hpc> and if you insert a value that already exists, it would just fill the same spot so it isn't added
06:24:45 <hpc> the rest is just strictness stuff to make it fast
06:24:56 <hpc> *fast for the right operations
06:25:09 <mekeor> hmm...
06:25:15 <hgl> how do you export a type class from a module?
06:25:22 <kmc> mekeor, are you trying to understand the Set API, or its implementation?
06:25:25 <hpc> hgl: it just is, i think
06:25:35 <kmc> instances get exported automatically
06:25:43 <kmc> for the class, name it the way you name a type
06:26:44 <roconnor_> Cale: http://plato.stanford.edu/entries/axiom-choice/#AxiChoLog shows how to derive excluded middle from the axiom of choice in set theory.
06:26:54 <Cale> So aeson somehow depends on double-conversion? That seems like it should be an easy dep to eliminate.
06:27:10 <mekeor> kmc: actually, i was looking for a possibility to define a condition for a data type; e.g. sth like: `data Foo = Bar Int | Baz Int where Bar Int > 5; Baz Int < 8' or sth..
06:27:20 <roconnor_> Cale: it requires predicative compreshension,  extensionality of functions, and at least 2 distinct sets.
06:27:36 <kmc> mekeor, ah; you can't really do that
06:27:46 <Cale> oh, some crazy second order logic stuff :)
06:27:49 <Cale> okay
06:27:50 <luite> yesod now "forks" aeson and some of its dependencies to work around this problem
06:27:59 <mekeor> kmc: can Agda do that?
06:28:00 <Cale> more believable then
06:28:06 <roconnor_> Cale: what?
06:28:11 <roconnor_> what is second-order?
06:28:45 <kmc> HugoDaniel, writing your own instances for Binary is simple, if tedious
06:28:46 <roconnor_> Cale: predicative comprehension is a special case of compreshension
06:29:00 <Cale> ∀X [Φ(X) → ∃x X(x)] → ∃F ∀X[Φ(X) → X(FX)]
06:29:05 <HugoDaniel> :)
06:29:08 <Cale> exists F
06:29:08 <HugoDaniel> thanks kmc
06:29:17 <HugoDaniel> yes, but Data.Data exists for a reason :)
06:29:27 <HugoDaniel> oh man, im such a lazy ass!
06:29:39 <kmc> GHC 7.2's new Generic class is probably a better solution than Data.Data
06:29:59 <HugoDaniel> what are the differences between them ?
06:30:02 <roconnor_> Cale: F is a set, F X is set funciton application, X(x) is x \in X.
06:30:09 <kmc> totally different
06:30:20 <roconnor_> Cale: the proof has just been phrased this way to show how general it can be.
06:30:22 <HugoDaniel> cool, im going to read it up
06:30:51 <kmc> however nobody's written a generic binary serializer using Generic, afaik, and even if they had, it'd only help if you have cutting-edge GHC
06:31:11 <HugoDaniel> yes, i see
06:31:32 <Cale> roconnor_: Predicative comprehension is the funny thing
06:31:37 <kmc> HugoDaniel, SYB (including Data.Data) is based on lots of run-time type checks and casts
06:31:46 <kmc> which makes a lot of operations stupidly inefficient
06:31:51 <HugoDaniel> oh, that can be an issue
06:32:07 <HugoDaniel> and Generic can make those in compile time ?
06:32:09 <roconnor_> Cale: sure but the first step can be done by regular compresion of the set {0,1}.
06:32:20 <Cale> roconnor_: You're basically adding second order axioms which assume that you can pull off the trick that I thought you couldn't ordinarily do :)
06:32:32 <kmc> HugoDaniel, yeah
06:32:35 <HugoDaniel> allright :)
06:32:46 <kmc> although Generic potentially has a different slowdown
06:32:58 <Cale> roconnor_: Try doing this in a first order set theory :)
06:32:59 <roconnor_> Cale: one sec, I'll try to filter out all the second-order stuff
06:33:02 <kmc> from converting your data between its original representation and the generic sum-of-products representation
06:33:08 <kmc> i'm not sure how they compare for speed in practice
06:33:34 <HugoDaniel> like generating code so big that it pagefaults all the way during runtime ? (is that even possible?)
06:33:51 <kmc> i don't follow
06:33:57 <HugoDaniel> sorry, my head is messed up
06:34:45 <HugoDaniel> im always fearing that compiles generate cache unaligned code, and memory unaligned code, and produce loads of pagefaults in runtime making it totally inefficient
06:35:23 <kmc> the people that write compilers do in fact think about these things :)
06:35:34 <kmc> but it's good that you think about them too
06:36:16 <Cale> You're just thinking about those things too early.
06:36:20 <hpc> hehe
06:36:28 <Cale> Think about them once it becomes evident that there's a problem :)
06:36:33 <HugoDaniel> yeah i know :/ its an ode to all my white hairs
06:36:34 <kmc> blowing out the i-cache is a valid concern when generating super specialized code for small performance gains
06:36:41 <kmc> page faulting less so
06:36:45 <hgl> do type classes have to have methods?
06:36:49 <kmc> pages are big, and main memory is big
06:36:54 <kmc> hgl, no
06:37:00 <hgl> kmc: thanks
06:39:15 <Cale> roconnor_: In a first order logic, you don't have propositional variables and so you can't even write down the thing we want to prove :)
06:39:51 <roconnor_> Cale: LEM is a axiom scheme in A, so we are building a proof scheme in A.
06:40:04 <roconnor_> Cale: I'm almost done I think
06:48:57 <Cale> roconnor_: Knowing that this implication is really a proof scheme and not a theorem helps me to believe that it could exist :)
06:49:38 <Cale> roconnor_: /msg me a link when you have it, I'd like to see, but I have to go
06:50:27 <rwbarton> regarding your general objection, surely one could add inconsistent axioms which would (among other things) prove that the logic was classical
06:52:56 <roconnor_> Cale:
06:52:56 <roconnor_> http://hpaste.org/50685
06:52:56 <roconnor_> ugh
06:52:56 <roconnor_> no line wrapping :(
06:54:48 <dolio> http://en.wikipedia.org/wiki/Diaconescu's_theorem
06:55:08 <rwbarton> does the axiom of choice also imply statements like forall x y. x in y or not x in y?
06:55:26 <rwbarton> is that different?
06:59:43 <absentia> nx/win shirnk 3
07:03:09 <dolio> rwbarton: You should be able to use excluded middle in arbitrary contexts.
07:03:41 <dolio> So to prove forall x y. P(x,y) \/ ~P(x,y), you'd use excluded middle in a context with x and y, and then generalize.
07:04:21 <rwbarton> hmm OK, I guess this is what I was going to try to do (but without the context language)
07:05:33 <dolio> Lots of treatments of logic don't use them, but I think that's a mistake.
07:05:59 <rwbarton> actually, maybe it's not
07:06:59 <roconnor> rwbarton: oh?
07:07:01 <dolio> It leads to sloppy language like talking about certain variables being implicitly existentially quantified and stuff.
07:07:28 <dolio> When what is meant is, "bound in the context," if you accept working that way.
07:07:31 * roconnor is lost
07:07:38 <roconnor> oh
07:07:43 <roconnor> maybe I was disconnected
07:07:48 <rwbarton> Not equivalent to how I was going to try to prove things like forall x y. P(x,y) \/ ~P(x,y), which is good since I was concerned about my way not working
07:07:53 <dolio> There was a big net split.
07:08:24 <dolio> Revealing that xchat has poor handling of net splits.
07:09:43 <roconnor> Cale: http://hpaste.org/50685 -- in case you didn't get it before.
07:09:59 <roconnor> oh oops
07:10:10 <dolio> Did you get my link to wikipedia's article on Diaconescu's theorem?
07:10:14 <dolio> Which has almost exactly what you wrote?
07:10:25 <roconnor> @tell Cale http://hpaste.org/50685 SEP's proof schema of LEM from AC.
07:10:26 <lambdabot> Consider it noted.
07:11:47 <roconnor> dolio: nope
07:12:38 <roconnor> I was copying the stanford encyclopedia of philosophy
07:12:51 <roconnor> but removing the second-order logic that Cale objected to.
07:12:59 <erus`> is there a defacto library for parsing text code/data?
07:13:17 <RenJuan> you mean default
07:13:17 <haja> parsec is quite good
07:13:18 <roconnor> erus`: like Parsec?
07:13:30 <erus`> someone told me not to use parsec
07:13:31 <RenJuan> (prolly)
07:13:34 <erus`> i forget why
07:13:59 <roconnor> erus`: do you have any particular performance concerns?
07:14:04 <RenJuan> (defacto was misspeech)
07:14:18 <erus`> roconnor: not until its too slow
07:14:30 <merijn> erus`: Parsec is usually quite nice. Unless you have very specific requirements
07:14:41 <roconnor> I think Parsec is a good place to start.
07:14:49 <RenJuan> (default was just off, you actually wanted something like "best", "most popular", etc.)
07:15:40 <merijn> RenJuan: He probably meant is "defacto *standard* library"
07:16:38 <erus`> will parsec tell me line numbers and stuff?
07:16:41 <RenJuan> and he means data absorbtion prolly rather than parsing as such
07:16:44 <erus`> or do i need to tokenize first?
07:18:01 <erus`> ignore that
07:19:05 <zong_sharo> can somebody help me with language-c a little? where do i get values for MachineDesc to reflect local one?
07:20:03 <RenJuan> hmm, looks brand new
07:20:35 <RenJuan> my bad, just current
07:20:48 <rwbarton> dolio: One point which was not clear to me at first is that when one has an axiom *schema* parametrized over a formula, one cannot necessarily use variables bound in the context in the formula in such an axiom schema. (Right?)
07:21:45 <RenJuan> zong_sharo, are you using 0.4.2? Does it require 7.2?
07:21:48 <dolio> The axiom schema would be something like 'G |- A \/ ~A'.
07:22:11 <dolio> Where A is anything that's a valid proposition in the context G, I believe.
07:22:44 <rwbarton> For example, if the axiom of specification only stated "forall z. exists y. forall x. (x in y <=> x in z /\ phi)", where only x and z are free in phi, one could not get the more general axiom of specification that's actually among the axioms of ZFC
07:23:01 <RenJuan> zong_sharo, doubtless your are supposed to supply that from your understanding of the physical architecture
07:23:22 <zong_sharo> RenJuan: 0.4.1 on 6.12
07:23:30 <RenJuan> ah
07:23:47 <dolio> If the axiom scheme specifically restricts what phi is, then it's more restricted. :)
07:24:35 <rwbarton> it's only because the axiom schema has a particular form that you can apply it to formulas involving terms from the context
07:24:53 <rwbarton> assuming your axiom is originally given as part of a logic without contexts
07:25:01 <zong_sharo> RenJuan: i'm afraid i don't understand all those alignments and whatnot to create machine desc for local arch by myself
07:25:12 <zong_sharo> RenJuan: can you help me here?
07:25:12 <rwbarton> that form essentially being that it works inside contexts also
07:25:37 <RenJuan> then it's beyond your depth, I'm looking at the sources of the tar but I will have to get back to work in a few minutes
07:26:27 <rwbarton> (I'm working from http://en.wikipedia.org/wiki/Axiom_schema_of_specification and w_1..w_n are the context)
07:27:50 <RenJuan> *you are supposed to
07:28:11 <zong_sharo> RenJuan: 0.4.2 on 6.12 - works okay
07:28:34 <dolio> rwbarton: Yeah, that presentation explicitly quantifies all the variables to give a proposition you can just take as an axiom, roughly.
07:28:44 <RenJuan> zong_sharo, well I would think it would be most interesting with 7.2
07:29:08 <RenJuan> (which hackage says it supports)
07:30:45 <zong_sharo> so, what about machine desc? on gnu stack, when do i can find those values and what are they mean exactly?
07:31:10 <dolio> rwbarton: In that case, excluded middle would be forall w_1 .. w_n. P(w1 .. wn) \/ ~P(w1 .. wn).
07:31:14 <zong_sharo> some is obvious, but for builtinAling , or size -  i have no idea
07:31:32 <rwbarton> this is probably evidence that one should in fact use contexts in the logic system, since that makes it unnatural to accidentally do things like add the axiom schema of replacement as an axiom but only for n=0.
07:32:58 <dolio> rwbarton: I don't think most presentations would quantify things like that.
07:33:03 <dolio> They'd just allow free variables.
07:33:20 <dolio> Well, I can't say most, since I haven't conducted any kind of survey.
07:33:25 <rwbarton> oh, I see
07:35:54 <RenJuan> zong, there are default values set (apparently 32 bit word) which should do, see dcoutts mentioned in credits maybe he's around
07:35:54 <dolio> Anyhow, without contexts you get some odd stuff going on, in my opinion.
07:36:35 <dolio> Like 'from forall x. P(x), we infer P(v) for a fresh v, and from that infer exists x. P(x).'
07:36:47 <dolio> Which is incorrect if you allow empty models.
07:37:01 <dolio> So, I was reading a book that mentioned this, and how you can fix it.
07:37:42 <dolio> And they came up with these rules like, "you can only perform that instantiation if you've separately proved exists x. x = x."
07:40:02 <zenzike_> This is a bit of a noob question, but is there a library function that takes a number of seconds to an hh:mm:ss format? (I know I can implement this with mod, I'm just wondering if someone's already invented this wheel)
07:40:11 <applicative> its incorrect if you allow empty models, and hold to certain analogies about what forall x P x and exists x P x would mean in an empty model.
07:40:13 <dolio> But in something like type theory you can only get 'v:A |- exists x:A. P(x)'
07:40:44 <dolio> Which is automatically guarded by the fact that A is inhabited.
07:41:59 <rwbarton> what happens if you just restrict the introduction rule for 'exists' to terms without free variables?
07:44:01 <rwbarton> perhaps that is too naive, and I will no longer be able to prove things like forall x. exists y. x = y
07:44:06 <hgl> can a record syntax accessor function serve to implement a function required by a type class?
07:44:54 <dolio> rwbarton: Yeah, it seems problematic.
07:45:23 <roconnor> Hilbert style deductions are kinda wonky
07:45:24 <kmc> hgl, interesting question
07:45:46 <rwbarton> yeah, that's my conclusion
07:45:59 <kmc> works fine to say "data Foo = Foo { bar :: Int }; instance C Foo where { baz = bar }"
07:46:01 <roconnor> hgl: sure
07:46:04 <kmc> there's no more direct way afaik
07:46:04 <applicative> zenzike, you can derive something pretty easily from System.Time.
07:46:15 <roconnor> hgl: field projectors are just regular functions.
07:46:20 <kmc> i bet there are strftime bindings somewhere
07:46:43 <hpaste> haja pasted “example.cabal” at http://hpaste.org/50686
07:46:45 <hpaste> haja pasted “scion usage (Main.hs)” at http://hpaste.org/50687
07:46:47 <applicative> zenzike_: let a = let a = noTimeDiff {tdSec = 112102220} ; then try  normalizeTimeDiff a ; then check out the formating functions
07:46:59 <zenzike_> applicative: thanks :-)
07:47:15 <applicative> normalizeTimeDiff a =  TimeDiff {tdYear = 3, tdMonth = 6, tdDay = 22, tdHour = 11, tdMin = 30, tdSec = 20, tdPicosec = 0}
07:47:23 <haja> Hi. I'm trying to use Scion to get information about all modules of a cabal package. But load LoadAllTargets returns that the compilation was not successfull with the note: "module `X' is a package module" (whereas module X is the first module defined as exported in the cabal file)
07:47:23 <haja> Code I'm running to get the information: http://hpaste.org/50687
07:47:23 <haja> cabal file: http://hpaste.org/50686
07:47:36 <zenzike_> applicative: handy. that's exactly what I'm hunting for, cheers!
07:49:01 <Botje_> 'be vewy vewy quiet, i'm hunting functows'
07:49:45 <RenJuan> phails as elmer
07:49:54 <haja> also note, that with cabal install the package compiles fine
07:50:18 <RenJuan> on "functows" which maybe works in nederlands oder
07:52:23 <hgl> roconnor: do you have to mention the projected function in the "instance" declaration?
07:52:57 <roconnor> hgl: as just you would for any instance ... I think there is something I'm not understanding here.
07:53:03 <roconnor> *just as
07:53:18 <kmc> you can't declare the field itself with the same name as the typeclass method
07:53:40 <kmc> that'd be an ordinary ambiguous name situation
07:53:41 <hgl> well, you normally say instance TypeClass1 Type1 where
07:54:01 <hgl> followed by the implementations of the functions required by the class
07:54:22 <kmc> (or not-functions!)
07:54:59 <hgl> but if functions don't have to be in that block, why ever put them there?
07:55:44 <kmc> they do have to be there, if they're implementing the type class
07:57:21 <hgl> but what about a projected function implementing the type class?
07:57:39 <kmc> the projection function can't implement it directly
07:57:47 <kmc> data Foo = Foo { bar :: Int }; instance C Foo where { baz = bar }
07:58:14 <b930913> If I have ("red", "yellow", "blue"), how do I generate all combinations of two colours?
07:58:32 <kmc> > replicateM 2 ["red", "yellow", "blue"]
07:58:33 <lambdabot>   [["red","red"],["red","yellow"],["red","blue"],["yellow","red"],["yellow","...
07:58:47 <hgl> what if bar is also the name of a function required by the class
07:58:50 <b930913> kmc: Takk.
07:58:55 <kmc> hgl, <kmc> that'd be an ordinary ambiguous name situation
07:59:03 <roconnor> > liftM2 (,) ["red", "yellow", "blue"] ["red", "yellow", "blue"]
07:59:04 <lambdabot>   [("red","red"),("red","yellow"),("red","blue"),("yellow","red"),("yellow","...
07:59:49 <hgl> i see, ok
07:59:58 <hgl> thanks
08:00:09 <roconnor> hgl: the only trick is that you must use unqualified names on the LHS of instance declarations.
08:00:26 <roconnor> as I've found out
08:07:12 <applicative> > let cases = ["red", "yellow", "blue"] in [(x,y) | x <- cases, y <- cases]
08:07:12 <lambdabot>   [("red","red"),("red","yellow"),("red","blue"),("yellow","red"),("yellow","...
08:07:56 <applicative> oops b930913 has vanished, no monad comprehension tutorial for him or her....
08:20:23 <applicative> roconnor: I think I've bumped into this, about unqualified names on the left in instances, but without comprehending it,
08:20:31 <applicative> roconnor: I mean instance M.Monoid a => M.Monoid (Identity a) where mempty = Identity (M.mempty)
08:22:19 <applicative> the most counterintuitive feature must be that I can't now use the mempty for Identity a without qualifying it, though I just defined it in this module....
08:23:20 <ion> applicative: Isn’t that behavior obvious? I expected exactly that to happen.
08:24:10 <applicative> ion, yeah it makes perfect sense, I think I hadn't had occasion to grasp the obvious points all together.
08:24:46 <ion> The names on the left aren’t really usual references to imported modules, but instead associated to the class that was referred to above.
08:25:04 <ion> But the implementations on the right are just usual expressions.
08:25:46 <benmachine> but even if you have to refer to the class qualified, you don't have to refer to the methods qualified
08:26:13 <benmachine> this is afaict the only context in which you don't need to qualify them
08:26:22 <benmachine> so it *is* a little counterintuitive
08:26:50 <benmachine> can't think of any alternative that makes sense and is consistent with th elanguage though
08:27:02 <benmachine> (notice that currently a qualified name doesn't appear on the LHS of an =)
08:27:37 <kmc> benmachine, it does with record label, in record construction or update syntax
08:27:43 <kmc> though there's a GHC extension to drop that
08:27:47 <benmachine> oh right, yes
08:27:49 <benmachine> good point
08:28:02 <kmc> qualified constructor names can also appear in patterns
08:28:08 <kmc> > let Prelude.Just x = Just 3 in x
08:28:09 <lambdabot>   3
08:28:12 <ion> The definitions fill a dictionary of unqualified names, if you will, matching the qualified class name mentioned above.
08:28:43 <ion> It would be somewhat strange to have to qualify them, too.
08:29:01 <ion> It would *look* consistent, but semantically it would be weird.
08:29:10 <kmc> if instances are like dictionary records, then i'd say the Haskell 98 rules are inconsistent
08:29:14 <benmachine> ion: on the other hand, it's weird that in some contexts you may be able to say
08:29:20 <benmachine> instance M.Monoid where mempty = mempty
08:29:21 <benmachine> and have that be valid
08:29:44 <benmachine> (and by valid I mean non-bottom)
08:36:17 <ocharles> wow, cabal-dev is SLOW. it takes over 2 minutes before it even starts compiling my code :(
08:36:22 <ocharles> just sits on "resolving dependencies" for ages
08:39:05 <RenJuan> does it go online to track dependencies?
08:42:25 <ocharles> at a guess, it must
08:43:22 <ocharles> Hm, with -v3 it seems "Reading available packages..." takes a while, but then it just gets to "Resolving dependencies..." and gets stuck for a minute
08:44:41 <RenJuan> what happened to Haskel Platform?
08:45:30 <kmc> what about it RenJuan?
08:45:33 <monochrom> @type 5 :: Int
08:45:33 <lambdabot> Int
08:45:51 <RenJuan> kmc, wasn't there supposed to be a July release?
08:45:53 <mayahustle> \part
08:45:57 <mayahustle> whoops
08:47:00 <RenJuan> (that's what their main page still says)
08:47:54 <RenJuan> to just leave that slipped shit up indicates nobody gives a fuck, employes are working on work for paying clients, etc.
08:48:08 <RenJuan> *employees
08:50:57 <RenJuan> that and maybe a paralysis about what to do about 7.2
08:53:00 <kmc> yeah, it would be good to take down the outdated info
08:53:31 <kmc> it's not the first time a deadline has slipped
08:54:48 <kmc> it's not like the current platform is horribly out of date
08:59:45 <maurer_> kmc: True, but it's quite unfortunate that you have to do a little dance to use the new generics features
09:00:32 <kmc> yeah
09:00:45 <kmc> the lag from GHC to Platform is standard, though
09:01:07 <kmc> i'm happy to let library authors (er, i guess that's me now!) and early adopters work under the latest GHC
09:01:32 <kmc> i actually wanted to provide Generic instances in udis86 but it choked on my Opcode enum :/
09:03:45 <maurer_> kmc: Hm? What issues were there?
09:05:30 <rwbarton> too large perhaps?
09:06:14 <kmc> yeah, GHC just sat for a few minutes before i gave up
09:06:31 <kmc> it derives other classes for that type just fine
09:06:39 <kmc> but Generic involves working with very large type expressions
09:06:44 <rwbarton> that doesn't sound like providing a service to users of your library
09:07:03 <kmc> :)
09:07:49 <kmc> yeah, it might also be impossible to work with the resulting instance
09:08:09 <joe6> i am trying to use bindings-DSL. I understand the definitions for constants/#defines, but am having trouble calling C functions from haskell.
09:08:18 <joe6> Any ideas that can guide me?
09:09:27 <kmc> what trouble are you having?
09:10:48 <benmachine> I've used bindings-DSL a fair bit
09:11:30 <BobFunk> snap
09:12:13 * hackagebot hVOIDP 1.0 - Optimal variable selection in chain graphical model.  http://hackage.haskell.org/package/hVOIDP-1.0 (QiQi)
09:12:52 <joe6> kmc, benmachine: do I have to do this for every function that I have in C? #ccall test , CChar -> CChar -> IO CChar
09:13:01 <joe6> or, can i get it autogenerated?
09:14:19 <benmachine> joe6: good question, I've wondered the same thing
09:14:37 <benmachine> joe6: are you thinking something like, input C header, output haskell file?
09:15:29 <kmc> maybe c2hs or GreenCard can do it
09:15:44 <kmc> joe6, do you have a huge number of functions?
09:17:14 * hackagebot haskdogs 0.1 - Generate ctags file for haskell project directory and it's deps  http://hackage.haskell.org/package/haskdogs-0.1 (SergeyMironov)
09:17:21 <lispy_> joe6: over the years, there have been tools to automate the process, but I find that ultimately I have the best luck just writing the definition by hand.  The biggest problem tehre is that you can write it down wrong and sometimes it will still compile
09:17:50 <edwardk> does anyone know how to reach sam anklesaria?
09:18:42 <MHD> Is it just me or is haskell eerily similar to modern smartphones, in the regard that in almost every situation "there's an app for that," and for almost any interesting computer sciency innovation "there's a monad for that?"
09:19:16 <mux> whoa, I find this pretty far-fetched, personally :-)
09:19:20 <kmc> meh, 'monad' is just one of many ways to structure a library
09:19:26 <kmc> it's not universally the best
09:19:29 <MHD> yeah, but still
09:19:32 <kmc> there are some interesting ones
09:19:41 <kmc> edwardk, do you know of a simple tracing JIT with a nice well-documented implementation that i could study?
09:20:04 <MHD> I just stumbled upon this "Worlds" concept about side effects being contained
09:20:28 <MHD> And I thought "What, this is like... ReaderT IO or something"
09:20:40 <edwardk> the nicest one is probably luajit. nanojit is nice too
09:21:10 <kmc> also i remember a huge informative list of LuaJIT implementation tricks
09:21:15 <edwardk> i have the bulk of the tracing machinery in that x86-64 to x86-64 jit of mine as well, but you'd need to finish out the compilation
09:21:18 <kmc> in a mailing list mail i think
09:21:31 <kmc> from the author
09:21:32 <edwardk> yeah a couple of the spidermonkey/tamarin developers blog quite a bit
09:21:34 <kmc> but i can't find it now :/
09:22:13 <kmc> also, what should I read after the HotpathVM paper?
09:22:39 <edwardk> hrmm. my laundry list of papers is on my other laptop, but lets see if i can find stuff
09:22:54 <kmc> it's not urgent, if this is easier to answer at another time :)
09:23:02 <edwardk> anything andreas abel writes is a good start ;)
09:23:25 <edwardk> er
09:23:45 <edwardk> sorry misplaced the name
09:24:23 <edwardk> andreas gal ;)
09:24:40 <edwardk> mentally swapped tracing jits for agda
09:24:52 <kmc> hehe
09:24:57 <Saizan> almost the same
09:24:59 <companion_cube> oO
09:25:34 <kmc> i think i'd like to implement a toy tracing JIT in Haskell
09:25:52 <edwardk> kmc: i have some haskell tracing code somewhere
09:26:08 <kmc> looks like most JITs out there are in C++, which isn't exactly a nice language to jump in and get the big picture quickly
09:26:30 <edwardk> yeah
09:32:51 <roconnor> Z-algebras are rings?
09:33:11 <sm> kmc: you might enjoy Andy Wingo's blogging about the js engines ?
09:33:26 <roconnor> I guess all algbras are rings and Z is the inital algebra.
09:47:18 * hackagebot hVOIDP 1.0.1 - Optimal variable selection in chain graphical model.  http://hackage.haskell.org/package/hVOIDP-1.0.1 (QiQi)
09:51:32 <joe6> benmachine, kmc, lispy_: ok, thanks.
09:51:47 <joe6> kmc, isn't c2hs an alternative to bindings-dsl?
09:52:12 <joe6> benmachine, yes, "input C header, output haskell file" is what I am wondering about.
09:52:30 <benmachine> joe6: if you find something, let me know :P
09:55:12 <joe6> i have structures ilke http://codepad.org/JTaKPvFz where both U1EP0 and U1EP0bits are in the same address location.
09:55:43 <joe6> this gives the flexibility of either doing "U1EP0 = 0;" or "U1EP0bits.EPHSHK = 0;"
09:56:18 <joe6> i am writing a haskell ffi to that header file. I can figure out the structiure definition and all that.
09:56:38 <joe6> I am not sure how I can replicate the "one address for both structures" though.
09:56:57 <joe6> In the C project, the linker has the addresses to both structures set to the same location.
10:02:29 <ader111> I am looking for a function for a monad m  that trasforms (a -> m b) -> m ( a -> b)
10:02:44 <ader111> does it exist?
10:03:46 <ion> a -> b is a pure function that only exists as a result of the monad. At the point of knowing a it can only decide the b based on it only and no monadic context.
10:04:03 <ion> I.e. you can draw the a -> b out of m (a -> b)
10:04:16 <ClaudiusMaximus> @djinn (a -> Maybe b) -> Maybe (a -> b)
10:04:16 <lambdabot> f _ = Nothing
10:04:20 <ion> and the a -> b must be able to come up with the b only based on a.
10:05:03 <ClaudiusMaximus> @djinn (a -> Either e b) -> Either e (a -> b)
10:05:03 <lambdabot> -- f cannot be realized.
10:07:20 * hackagebot hVOIDP 1.0.2 - Optimal variable selection in chain graphical model.  http://hackage.haskell.org/package/hVOIDP-1.0.2 (QiQi)
10:08:09 <kmc> ader111, you're looking to do this for all monads? or you want some specific M for which it's possible?
10:08:28 <ader111> no, the maybe monad for instance
10:09:06 <kmc> i don't think you can do better than (const Nothing) or various things with undefineds
10:11:54 <ader111> I see, I dont know why, but the fact that I cant do it surprises me
10:15:36 <rwbarton> well, think about the "effects" part of the monad
10:15:46 <rwbarton> with a -> m b, you have to feed in an a to get out some effects
10:15:55 <ader111> yeah, it makes sense for the effects part
10:15:58 <rwbarton> but with m (a -> b), you get effects right away
10:16:05 <ader111> thanks for the hint
10:16:51 <ion> :t let f x | even x = Nothing | odd x = Just (show x) in f
10:16:52 <lambdabot> forall a. (Integral a) => a -> Maybe String
10:17:27 <ion> Say, you convert that into (Integral a) => Maybe (a -> String) that is *not* Nothing.
10:18:01 <ion> And take the Integral a => a -> String out of the Just. What do you suppose it should return when applied to 2?
10:19:03 <ader111> yep, I see the problem clearly
10:25:08 <sm> gwern: are you still running gitit ?
10:25:19 <sm> if so, what kind of memory footprint do you see ?
10:25:43 <gwern> sm: I haven't run it in a while
10:25:48 <sm> ah
10:25:49 <gwern> there was some sort of compilation issue
10:26:08 <gwern> I didn't break the config or anything, so it should still work...
10:26:35 <gwern> sm: it was getting very hard to compile gitit with highlighting-kate, though. taking all my ram. i'd have to shut down pretty much anything running.
10:27:05 <sm> ouch
10:27:18 <sm> I've got the periodic let's make a wiki bug.. reading all about gitit to calm myself down
10:27:38 <gwern> sm: well, the compile isn't too badd as long as you don't want source-code highlighting
10:27:59 * sm nods
10:28:07 <gwern> and you can always just do what I do, keep a local wiki with a gitit config, but edit it on the CLI or in an editor, publishing a hakyll website
10:28:43 <sm> any thoughts about how hakyll and gitit could integrate more - oh nice :)
10:29:06 <gwern> sm: plenty of thoughts, but the big thing is making hakyll use gitit-style intrawiki links
10:30:05 <sm> is that a big thing ? they don't seem all that convenient anyway
10:31:00 <gwern> sm: well, it involves a lot of rewriting existing sites
10:31:31 <sm> when moving a gitit wiki to hakyll ?
10:32:22 <gwern> sm: my current strategy is simply overwriting part of the haykll render chain to accept gitit links
10:32:50 <gwern> since I think the gitit style is much better, and hakyll was easier to change than gitit
10:37:47 <kadoban> I have a game board implemented in haskell, and I'm trying to make a bunch of different ways to display it, with a lot of the logic inside the board module itself, does this way make sense?: http://hpaste.org/50691
10:38:16 <kadoban> my lame test case there compiles and runs, but i'm worried that's a terrible way to do it somehow, or i'm going to run into problems later?
10:55:01 <sm> gwern: gitit has a lot of nice features. It would be nice to have it and hakyll share more of them, and align more in how to do things
10:55:24 <sm> I'll keep playing with both
10:56:21 <Clint> it would be nice if that could supplant ikiwiki too
10:56:47 <sm> indeed
10:57:00 <joe6> anyone with experience of the haskell ffi storable module?
10:58:28 <sm> if we can only find the right name the design might fall out naturally
10:58:42 <sm> hakirevit
11:00:17 <sm> ikiwiki sits between hakyll and gitit in a way. It's like gitit always running in cached mode, or hakyll with a wiki edit ui
11:01:13 <sm> like statically serving gitit's cache, rather
11:13:05 <Clint> ugh, it uses hsopenssl for one function
11:18:40 <monochrom> nice, ghc 7.2 allows class (F a ~ b) => C a b where type F a; ...
11:22:30 <incrow> hey
11:25:08 <incrow> Haskell is good to learn as first programming language?
11:25:28 <maurer_> incrow: Maybe. There are few people who have, so there's not much data, but it's certainly worth a shot.
11:25:43 <maurer_> If nothing else, it will teach you good practices early on.
11:27:20 * hackagebot hxmppc 0.2.1 - Haskell XMPP (Jabber Client) Command Line Interface (CLI)  http://hackage.haskell.org/package/hxmppc-0.2.1 (NicolasPouillard)
11:27:26 <sm> incrow: you'll have to work hard at ignoring things better learned later
11:50:08 <hiptobecubic> str sel = maybe "" join (M.sgGet sel s)     syntactically, what does this line mean?
11:51:26 <monochrom> = case M.sgGet sel s of Nothing -> ""; Just x -> join x
11:51:44 <permagreen> Well that clears that up!
11:51:53 <Saizan> str sel = ((maybe "") join) (M.sgGet sel s)
11:52:14 <mux> I'm not sure what a syntactic meaning means
11:52:40 <monochrom> right, so I apply my liberal interpretation
11:53:03 <hiptobecubic> wait, is there a missing line then?
11:53:17 <monochrom> there is no missing line
11:53:19 <hiptobecubic> i'm looking at xmobar 0.13 as downloaded by cabal five minutes ago
11:53:48 <hiptobecubic> and that line doesn't compile because M.sgGet does not exist. http://hackage.haskell.org/packages/archive/libmpd/0.1.3/doc/html/Network-MPD.html
11:55:07 <dbpatterson> is there a way to force cabal-dev to rebuild a local dependency?
12:01:20 <parcs> what is covariance
12:02:19 <roconnor> when F is a type constructor and A is a subtype of B (A <: B) then if F A <: F B we say that F is covarient
12:02:32 <roconnor> if F B <: F A we say that F is contravarient
12:02:36 <iFire> is it worthwhile to try implementing succinct data structures in ghc?
12:02:43 <iFire> it requires bitwise operations
12:02:44 <roconnor> Eg.  if F X = C -> X, then F is covarient
12:02:56 <roconnor> and if F X = X -> D then F is contravarient.
12:03:08 <copumpkin> was it quicksil1er who was doing succinct data structures a while ago?
12:03:20 <copumpkin> someone around here was
12:03:35 <iFire> do you have a link?
12:03:39 <joe6> hase anyone used bindings-dsl to acces bitfields in a structure?
12:03:43 <parcs> thanks roconnor
12:04:03 <joe6> like these: uri: http://publications.gbdirect.co.uk/c_book/chapter6/bitfields.html
12:04:16 <dainanaki> has anyone done any sort of incremental sorting using enumeratees?
12:04:54 <hiptobecubic> monochrom, do you happen to know what 'sel' is in that context?
12:05:21 <monochrom> some random parameter
12:05:56 <monochrom> or more accurately, I don't know the context, and I don't want to know
12:06:10 <hiptobecubic> sure :)
12:07:40 <hiptobecubic> ohhhhhh i understand what this is doing now
12:07:46 <hiptobecubic> haskell sure is sexy
12:08:32 <parcs> :t let f :: (a ~ b) => a -> b; f = id in f
12:08:33 <lambdabot> forall a. a -> a
12:09:05 <parcs> :t let f :: (Num a, a ~ b) => a -> b; f = (+1) in f
12:09:06 <lambdabot> forall a. (Num a) => a -> a
12:09:55 <rtharper> is ~ just quality on types?
12:10:00 <copumpkin> yep
12:10:04 <parcs> :t let f :: (Num b, a ~ b) => a -> b; f = (+1) in f
12:10:05 <lambdabot> forall a. (Num a) => a -> a
12:11:01 <monochrom> at Haskell, we value type quality! err type equality!
12:11:40 <rtharper> lol
12:12:44 <ziman> you also forgot type liberty and type fraternity.
12:13:43 <monochrom> types of the world, unify!
12:16:44 * RenJuan hmmpfs.
12:23:13 <ski> @palomer
12:23:13 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
12:24:36 <ion> @palomer
12:24:37 <lambdabot> That's nuts!
12:35:00 <roconnor> edwardk: do you have a Biring class?
12:36:27 <joe6> roconnor, your suggestions sometime ago were helpful while I was doing some haskell ffi work. Any suggestions on how to use bindings-dsl to acces bitfields in a structure?
12:36:58 <roconnor> joe6: That doesn't sound like me.  I've never used the FFI.
12:37:16 <joe6> roconnor, ok, sorry for the confusion.
12:37:49 <roconnor> np
12:38:27 <hiptobecubic> Is there an easy to reach inside a data type and look at values of the fields? for example if "data Foo = Foo {bar :: string}" and i have a Foo bound to variable 'd' and i want to know the value of d's "bar" field.
12:38:56 <ricree> is there a safe way to use read?
12:39:11 <ricree> or something like it
12:39:39 <ziman> hiptobecubic, the expression "bar d" is equal to the value of the field
12:39:51 <hnsz> read only reads one value + optional; whitespace, is that safe enough?
12:39:55 <hiptobecubic> ziman, thanks
12:40:59 <copumpkin> ricree: reads
12:41:19 <ricree> hnsz:  well, what's considered the best way to make sure it won't throw an exception
12:41:32 <copumpkin> ricree: reads
12:41:55 <copumpkin> :t reads
12:41:56 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:42:21 <ricree> thanks, copumpkin
12:43:45 <byorgey> I often define  readMaybe x = case reads x of [(y,"")] -> Just y; _ -> Nothing
12:44:21 <ricree> yeah.  seems like something to that effect really ought be somewhere more standard
12:45:04 <sm> there's also readMay in the safe lib
12:45:46 <ricree> where's that?  Doesn't seem to show up in a hoogle search
12:46:20 <sm> hoogle for "safe" or "readMay +safe"
12:46:42 <ski> @hoogle readMay +safe
12:46:42 <lambdabot> Could not find file:
12:46:42 <lambdabot>     safe
12:46:42 <lambdabot> Searched:
12:46:57 <sm> http://haskell.org/hoogle/?hoogle=readMay+%2Bsafe
12:50:41 <ion> Are there ReadS implementations that actually can return multiple result alternatives?
12:54:06 <copumpkin> no
13:05:01 <zzing> Has anyone had a way of supporting sgml based data files?
13:07:41 <geheimdienst> the Read class is one of these things that give me the willies. one of the functions has an incomprehensible second argument that every instance of the class seems to just ignore ...
13:07:53 <geheimdienst> mysteries of the ancient unknown, i'm tellin ya
13:10:22 <zzing> Which funciton?
13:12:38 <geheimdienst> zzing, readsPrec :: Int -> String -> [(a, String)]
13:13:40 <geheimdienst> its doc is "the operator precedence of the enclosing context (a number from 0 to 11). Function application has precedence 10." i don't know what that means. i lean towards the theory that the Int reflects the number of earth's reptilian outer space overlords
13:13:59 <geheimdienst> possibly the number of decimal places that pi really has
13:16:48 <zzing> I believe that the reptilians were of this earth, just hidden. It is the greys that are from outerspace.
13:17:04 <zzing> *WARNING* My mother actually believes what I just said.
13:17:59 <geheimdienst> zzing, i guess that theory is as good as any
13:19:28 <ski> geheimdienst : it tells whether to require brackets or not
13:20:30 <joe6> any suggestions on how I can fix this? http://codepad.org/U11MrDN1
13:20:54 <geheimdienst> on second thought, that argument is quite funny really. "i just have a few strings and want to parse it into Color datatype with three ints ... wtf is an enclosing context any why do i have to worry about it? why does the precedence go to 11, in honor of spinal tap? function application is 10, it says, but what about 0-9 and 11?" etc.
13:20:56 <ski> when printing e.g. `1 + (2 * 3)' (as an `Expr' say), we don't need to print the brackets, because of precedence
13:21:32 <geheimdienst> ski: i suspected it was something like the level of parens we're at ...?
13:21:42 <ski> similarly, if we were to read an `Expr', after seeing `1 + ' we would tell `readsPrec' what the precedence of `+' is, so that it knows that no brackets are required around the `2 * 3'
13:22:01 <ski> not, not the level of brackets, it's the precedence level
13:23:38 <geheimdienst> okay, so this is to accomodate parsing haskell source ... hmm
13:23:58 <ski> if we had `5 ^' instead of `1 +', then since the precedence of `^' is higher than that of `2 * 3', it would know not parse the whole of `2 * 3' now, but just that `2', so that we get `5 ^ 2', and *then* that could be wrapped in `* 3'
13:24:03 <geheimdienst> so it's the precedence of the last-seen operator
13:24:16 <ski> it's to accomodate operators with precedence
13:24:35 <kadoban> is MultiParamTypeClasses a bad idea in general or something? most of the docs on it sound scary, something about functional dependencies? i just want to let a typeclass choose which state it needs in StateT
13:24:36 <fasta> geheimdienst: it is just a silly hacky function.
13:25:02 <kadoban> er let implementations of the typeclass choose rather
13:25:03 <fasta> geheimdienst: hacky, because it is specific to Haskell.
13:25:16 <geheimdienst> ski, hm okay. that's the first explanation that actually makes some sense to me. thanks a lot
13:25:27 <ski> also consider `foo (2 + 3)', here the brackets around `2 + 3' is required, so function application must tell the parser that we're in an argument, and it does that using a precedence as well
13:25:30 <fasta> The whole number based precedence design was out of date a decade ago.
13:25:31 <geheimdienst> so 10 is function application, i presume 11 is parens then
13:26:27 <fasta> geheimdienst: do you need performance? No? Just use some parsing combinator library.
13:27:24 <ski> kadoban : if it's what you need ..
13:29:29 <ski> kadoban : it's not necessarily a bad ides. there are gothchas about ambiguity, though, which can in some cases be fixed by using FDs (in other cases a class split might be more appropriate) -- also, associated types are similar to a MPTC with FDs
13:30:28 <joe6> i cannot get "cabal install hsc2hs" to work. it says: http://codepad.org/PfxaiMRB
13:30:33 <kadoban> ski: okay, thanks.  i geuss i'll go beyond my really retarded test case and see if it blows up then
13:30:34 <joe6> any suggestions on how to fix it?
13:33:20 <geheimdienst> joe6: does "ghc-pkg check" report any packages as broken?
13:33:54 <joe6> geheimdienst:  http://codepad.org/lFZpnfzR
13:34:26 <fasta> joe6: download the package, fix the cabal file by adding process to it as a dependency, send in patch to maintainer.
13:34:41 <joe6> fasta, ok, thanks.
13:35:19 <fasta> joe6: or fix your setup.
13:35:27 <fasta> joe6: it works here.
13:36:12 <joe6> fasta, I have process-1.0.1.5 and the latest process is process-1.1.0.0
13:36:16 <chrisdone> does anyone have a module containing essential System.IO functions but of type MonadIO m => …?
13:36:30 <joe6> I am not able to cabal install the latest process-1.1....
13:36:33 <fasta> joe6: that is not what the error message says.
13:36:36 <chrisdone> typing liftIO all the type is boring
13:36:42 <fasta> joe6: the error message says it is _hidden_.
13:36:55 <fasta> joe6: that is Cabal's annoying way to say 'fix the package'.
13:37:09 <joe6> ok, let me try.
13:37:23 <fasta> joe6: which compiler are you using?
13:37:39 <fasta> joe6: compiler version
13:37:42 <geheimdienst> i just tried and hsc2hs doesn't install for me
13:37:57 <joe6> once I have ghc and haskellplatform installed. and do cabal update. Is that enough or do I have to upgrade ghc and haskell-platform manually?
13:38:07 <geheimdienst> it does not have "process" listed in its dependencies, but it tries to import stuff from that package
13:38:09 <fasta> joe6: oops.
13:38:12 <chrisdone> @hoogle MonadIO m => String -> m String
13:38:13 <joe6> fasta: The Glorious Glasgow Haskell Compilation System, version 7.0.4
13:38:13 <lambdabot> System.Environment getEnv :: String -> IO String
13:38:13 <lambdabot> Text.ParserCombinators.ReadP string :: String -> ReadP String
13:38:13 <lambdabot> Prelude lines :: String -> [String]
13:38:17 <fasta> joe6: ok, so indeed it does not build.
13:38:28 <chrisdone> Hoogle you're such a liar
13:38:45 <fasta> joe6: so, did you already download the package?
13:38:47 <joe6> fasta, hsc2hs does not build for you?
13:38:59 <fasta> joe6: no, it doesn't.
13:39:16 <fasta> joe6: but I am pretty sure it would, if you would add process to its cabal file.
13:39:23 <joe6> ok, will do that and try.
13:39:33 <fasta> joe6: also just use bindings-dsl.
13:39:36 <geheimdienst> i guess we isolated now that it is a problem with that package's *.cabal file, not with joe6's setup
13:40:46 <joe6> once I have ghc and haskellplatform installed. and do cabal update. Is that enough or do I have to upgrade ghc and haskell-platform manually, when a new release occurs?
13:40:55 <joe6> or will cabal update take care of the upgrades?
13:42:02 <fasta> joe6: think of cabal as a 500 line hack, not as if it is apt-get install.
13:43:26 <chrisdone> joe6: when you upgrade GHC, you get a new directory in your ~/.ghc for that GHC version. you get new base packages installed there, including Cabal. you should reinstall cabal-install after that (or with the haskell platform you get that for free), and you'll need to install the packages you need again for this GHC version
13:43:29 <joe6> fasta, i tried bindings-dsl but could not figure out how to use bitfield C structures
13:43:45 <joe6> fasta, like these. uri: http://publications.gbdirect.co.uk/c_book/chapter6/bitfields.html
13:44:23 <joe6> chrisdone: ok, thanks.
13:44:23 <chrisdone> $ ls /home/chris/.ghc → ghci_history i386-linux-6.12.3  i386-linux-7.0.4
13:44:25 <copumpkin> fasta: do you think you could try to be a little more pleasant/respectful in future?
13:45:09 <joe6> chrisdone: i find haskell-platform easier to install vs cabal-install
13:45:20 <joe6> chrisdone: but, that is my opinion.
13:45:56 <fasta> copumpkin: I am not a sales person here.
13:46:20 <chrisdone> joe6: so yeah with the platform you just need to reinstall packages for your projects due to the new ghc version
13:46:26 <fasta> copumpkin: An other way to say it is that whoever wrote Cabal put in more time than others and as such that could be regarded as a good thing.
13:46:29 <joe6> fasta, came across this patch that talks about extending hsc2hs to bitfields
13:47:05 <fasta> joe6: you could try downloading the whole hackage archive and search for the word bitfield.
13:47:10 <joe6> fasta: uri: http://www.haskell.org/pipermail/haskell-cafe/2008-November/050331.html
13:47:34 <fasta> joe6: It's not a very popular thing to do, AFAIK.
13:48:00 <joe6> but, it helps while using c on embedded devices.
13:48:07 <copumpkin> can't you just mask stuff out?
13:48:10 <copumpkin> by hand
13:48:25 <fasta> joe6: lack of features is not a good thing. I agree.
13:48:25 <joe6> copumpkin: but, there are a lot of such struct's.
13:49:13 <fasta> joe6: it seems that patch should work.
13:49:13 <joe6> copumpkin, structures like these. http://codepad.org/F6ixSwuQ
13:49:28 <fasta> joe6: or rather, could theoretically work.
13:49:47 <joe6> fasta, will give it a shot. that is the only option I have, at this point.
13:50:06 <fasta> joe6: you can also write your own mini-compiler.
13:50:22 <joe6> fasta: that would be too much work..
13:50:47 <joe6> btw, looking for some advice. http://codepad.org/F6ixSwuQ , the structures are defined in the linker file to point to the same address location.
13:50:48 <fasta> joe6: doing several hundred structures by hand or writing a 100 line script.
13:50:57 <joe6> Is there anyway that I can do that with haskell.
13:51:06 <joe6> something like synonyms of bindings-dsl
13:51:21 <joe6> but, am not sure if that will can work with hsc2hs
13:51:32 <fasta> joe6: the only possible solution involves the same C compiler.
13:51:42 <fasta> joe6: which essentially is hsc2hs.
13:51:53 <fasta> joe6: hsc2hs compiled fine years ago.
13:52:08 <fasta> joe6: it is a fairly easy program to understand and to extend.
13:52:22 <fasta> joe6: the patch you have there should apply and you should be fine.
13:52:24 <joe6> fasta,  I think what you are saying seems to be the correct thing to do. But, I am not sure of the details.
13:52:37 <fasta> joe6: programming is about confidence too.
13:52:46 <chrisdone> augustss: hey! what's the word on pattern aliases? will you update your blog when there's something to see or where should i look?
13:52:50 <fasta> joe6: or ask your superior if you have one.
13:53:02 <joe6> fasta, i am talking about "doing several hundred structures by hand or writing a 100 line script." -- can you please give more thoughts?
13:53:19 <augustss> chrisdone: nothing much has happened since the hadkathon
13:53:19 <fasta> joe6: I would go with hsc2hs in this case.
13:53:29 <augustss> hackathon, even
13:53:42 <chrisdone> augustss: okie. /me waits
13:53:48 <joe6> ok, thanks.
13:54:03 <fasta> joe6: it really is not magic what hsc2hs does. Read the manual a few times and you will see.
13:54:34 <joe6> guys, any thoughts on how I can do this with hsc2hs?  "http://codepad.org/F6ixSwuQ , the structures are defined in the linker file to point to the same address location"
13:54:42 <joe6> is that possible?
13:54:42 <fasta> joe6: but.. Haskell on an embedded device?!
13:55:00 <joe6> fasta, no. I have some embedded device C code that I want to test with haskell.
13:55:11 <joe6> like unit tests, but driven from haskell.
13:55:42 <joe6> as, C code is portable, I figure I can test the c functions with hunit or quickcheck.
13:55:54 <fasta> joe6: C code is not really portable.
13:56:02 <fasta> joe6: certainly not that code.
13:56:21 <fasta> Java byte code is fairly portable.
13:56:32 <joe6> fasta, why is that c code not portable?
13:57:26 <Nisstyre> The C Programming Language is portable
13:57:27 <fasta> joe6: AFAIK, and I am not an expert C programmer, but it is not C to begin with because of the compiler hints.
13:57:50 <Nisstyre> GNU C isn't portable
13:57:51 <joe6> the compiler hints are not that bad. some of the attributes warn out.
13:57:52 <zygoloid> Nisstyre: you mean the book? yeah, it fits nicely into an overnight bag
13:58:04 <joe6> but gcc compiled a file with that structure.
13:58:21 <Nisstyre> zygoloid: yeah, it would be nice to have a pocket version
13:58:37 <fasta> Nisstyre: you can read it on your phone.
13:58:41 <Nisstyre> true
13:58:54 <Nisstyre> my phone does fit inside my pockets
13:58:56 <permagreen> C was designed to be portable across any processor architecture imaginable, as long as it was being run under a Unix OS.
13:59:09 <zygoloid> this sounds very Dr Seuss
13:59:21 <Nisstyre> permagreen: it is portable to other types of OSes if you don't make any system calls specific to unix
13:59:39 <fasta> C doesn't work well on a DNA computer.
13:59:41 <joe6> permagreen, I do not have any system calls or anything like that in the code.
13:59:49 <fasta> But it could.
13:59:51 <ovrskr> C is fancy assembly language :P
14:00:10 <ovrskr> a[3] == 3[a]  proves my point
14:00:14 <zygoloid> -1 flamebait
14:00:19 <joe6> ovrskr: yes, that is how I use it.
14:00:29 <joe6> more compact than assembly.
14:00:41 <geheimdienst> c combines the speed and flexibility of assembly with the ease of use of assembly
14:00:44 <Nisstyre> people who are paranoid about compilers should use asm
14:00:45 <joe6> i mean in terms of "screen space"
14:01:01 <fasta> Nisstyre: but what about the micro code?
14:01:08 <joe6> anyway, this discussion is veering off-course..
14:01:17 <Nisstyre> fasta: well, then they shouldn't use a modern CPU at all
14:01:17 <joe6> guys, any thoughts on how I can do this with hsc2hs?  "http://codepad.org/F6ixSwuQ , the structures are defined in the linker file to point to the same address location"
14:01:25 <fasta> Nisstyre: exactly.
14:01:33 <Nisstyre> they can have an abacus or something
14:02:06 <ovrskr> don't space shuttles still sport Z80's and stuff?
14:02:07 <fasta> I think you can build a 4MHz machine as a hobbyist today.
14:02:26 <hnsz> Nisstyre: I disagree. People paranoid about the compiler should read the spec.
14:02:34 <Nisstyre> that would also work
14:02:50 <kmc> ovrskr, not quite that extreme, but space vehicles do use lagging computer tech for a variety of reasons
14:02:54 <fasta> hnsz: the compiler would just temporarily output correct code.
14:02:57 <ovrskr> I find it funny btw that about half the C language is "undefined behaviour"
14:03:15 <fasta> ovrskr: right, it would have been better to just leave that out.
14:03:17 <kmc> there's a lot of stock ThinkPads on the ISS
14:03:18 <ovrskr> running a C program essentially is "undefined behaviour
14:03:24 <joe6> does bindings-dsl use hsc2hs behind the scenes?
14:03:24 <kmc> but not in the most critical roles
14:03:35 <kmc> joe6, not very far behind
14:03:38 <permagreen> ovrskr: Yeah, and Larry Wall thinks Perl is freeform
14:03:41 <kmc> bindings-dsl is just some C macros for use with hsc2hs
14:03:42 <hnsz> overskr: You should ask in ##c
14:03:49 <kmc> not 100% positive as i've never used it
14:04:05 <joe6> kmc, I can patch hsc2hs and use that functionality, while also using bindings-dsl?
14:04:10 <kmc> think so
14:04:11 <hnsz> overskr: really you should
14:04:13 <kmc> why do you need to patch hsc2hs?
14:04:20 <joe6> kmc, ok, thanks.
14:04:36 <kmc> does anyone have an example of a Cabal description field containing a paper citation, or footnotes? istr seeing this but can't find a package which has it :/
14:04:37 <joe6> kmc, i am trying to access bitfields
14:05:15 <joe6> copumpkin, structures like these. http://codepad.org/F6ixSwuQ
14:05:18 <ovrskr> hnsz, fair enough
14:05:24 <joe6> kmc, structures like these. http://codepad.org/F6ixSwuQ
14:06:10 <joe6> kmc, this is the patch: uri: http://www.haskell.org/pipermail/haskell-cafe/2008-November/050331.html
14:07:06 <kmc> interesting; what's the __sfr__ attribute? what C compiler understands it?
14:07:14 <joe6> kmc, forget that.
14:07:19 <kmc> i'm curious :)
14:07:27 <joe6> kmc, it is an attribute of the pic30 gcc compiler
14:07:37 <joe6> that points this structure to a predefined location.
14:07:39 <kmc> there's gcc for pic? cool
14:07:41 <kmc> does it work well?
14:07:46 <joe6> yes, it does
14:07:49 <kmc> cool
14:07:58 <kmc> i recently got a pile of pics for free
14:08:02 <kmc> and was wondering how i'd program them
14:08:07 <joe6> kmc, any thoughts on how I can do this with hsc2hs?  "http://codepad.org/F6ixSwuQ , the structures are defined in the linker file to point to the same address location"
14:08:10 <kmc> since i'd heard the free AVR toolchain is much better than PIC
14:08:22 <joe6> kmc, this is for pic24f's and upper
14:08:36 <kadoban> is there any way I can get this to work, or similar? http://codepad.org/cUMGuo5M I want a main like lines 34-35, not a main like line 32-33. ghc actually works with the later, codepad just errors earlier for the same problem i think
14:08:41 <kmc> does that hsc2hs patch do what you want?
14:08:44 <joe6> below that, you are stuck with asm.
14:09:01 <joe6> kmc, that patch is for bitfield access.
14:09:31 <joe6> kmc, I am trying to figure out how I can 2 structures to point to the same memory address location.
14:09:57 <joe6> kmc, in gcc, it is done by have the gcc linker file have the same address for both these structures.
14:10:16 <joe6> but, i am not sure if that is possible with the haskell bindings.
14:10:27 <joe6> kmc, does that make sense?
14:10:31 <ovrskr> joe6, i've been using C30 too :P
14:10:44 <joe6> ovrskr: did you buy that?
14:10:48 <kmc> kadoban, what's the error message?
14:10:54 <ovrskr> huu it's free
14:10:59 <kmc> kadoban, why do you have this Canvas class? might there be a simpler way to achieve the polymorphism you want?
14:11:03 <joe6> ovrskr: or, did you modify the source to remove the license restrictions?
14:11:16 <ovrskr> joe6, if you really want, Lua does compile on C30
14:11:32 <joe6> Lua does?
14:11:33 <ovrskr> no, it still works even if you don't buy it
14:11:39 <kadoban> kmc: very possible i'm doing something too complicated.  ill paste the error message.  is it clear what i'm trying to do, or not really?
14:11:56 <joe6> ovrskr: yes, i know. but, it is easy to modify the source to remove the license restrictions.
14:11:58 <kmc> not totally clear
14:12:07 <joe6> ovrskr: do you code in lua on c30?
14:12:15 <kadoban> k, ill write it out best i can too
14:12:18 <joe6> ovrskr, that would be cool.
14:12:23 <ovrskr> joe6, oh, so you compiled their GCC source? I read it's horrible :/
14:12:33 <joe6> ovrskr, no, it is not.
14:12:37 <ovrskr> Haven't tried it myself, but i've read it compiles, yeah
14:12:46 <joe6> ovrskr: a few hours work, though.
14:12:58 <kmc> kadoban, is your error ambiguity on startState?
14:12:58 <ovrskr> my bad then
14:13:00 <joe6> ovrskr, thanks for the tip. will check it out.
14:13:07 <kmc> you can fix that with a type annotation
14:14:37 <kmc> (r, c) <- runStateT (printOn "" empty :: IgnoreStones -> Board -> StateT (Int, Int) IO IgnoreStones) startState
14:14:39 <kmc> or something
14:14:48 <joe6> ovrskr: where did you find the stuff about lua and pic30?
14:16:58 <kadoban> kmc: oh, let me try that. here's my explanation anyway, in case you're still interested: http://codepad.org/gjttqAzQ
14:17:09 <ski> kadoban : the general problem is that `s' doesn't determine `c' in `Canvas c s'
14:17:39 <monochrom> oh, multiple parameter type class fun?
14:17:42 <joe6> why is the hsc2hs so old? no recent activity? or, is it not on cabal/hackage anymore?
14:17:57 <ski> non-normalized MPTC fun, yes
14:18:01 <kmc> kadoban, maybe you can abstract using ordinary functions rather than type classes
14:18:55 <ovrskr> joe6, http://askrprojects.net/software/dsplua.html
14:18:58 <ski> kadoban : when you write `startState' with some type `s', it doesn't know for which `c' it should fetch the `startState' in `Canvas c s'
14:19:04 <kmc> printOn :: ((Int, Int) -> c -> StateT s IO c) -> (String -> c -> StateT s IO c) -> s -> Board -> IO ()
14:19:15 <kmc> or if you like, wrap the first three args into some data type
14:19:22 <joe6> ovrskr: but, the software on that website seems to be blocked.
14:19:31 <kmc> the point is that in Haskell you don't need to define a new type for each new behavior
14:19:34 <ovrskr> yeah that's weird
14:19:48 <kmc> you just pass around some functions or IO actions
14:19:56 <ovrskr> probably you can compile straight lua, it's a few .c files
14:20:22 <kadoban> hmmm, okay, let me think over this for a bit, takes me a long time to understand much in haskell yet. i think i understand what's wrong at least though
14:21:10 <kmc> kadoban, it's very common for Haskell beginners to invent and use type classes where they are not necessary
14:21:21 <int80_h> yup yup. I tried that
14:21:25 <kmc> i think it's due to this "kingdom of nouns" thinking from Java etc, where every new behavior needs a new type
14:21:29 <ovrskr> joe6, http://askrprojects.net/software/pic32lua/index.html
14:21:33 <kmc> http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html here's a rant about it
14:21:48 <int80_h> kmc: in my case it was due to not knowing what my options were.
14:21:54 <kadoban> yeah, this started out sounding like a cute solution, but i keep having to add on more gunk and confused the crap out of myself
14:22:01 <int80_h> @hoogle repeat
14:22:01 <lambdabot> Prelude repeat :: a -> [a]
14:22:02 <lambdabot> Data.List repeat :: a -> [a]
14:22:02 <lambdabot> Data.ByteString.Lazy repeat :: Word8 -> ByteString
14:22:32 <kmc> there's some irony here, in that people come to Haskell to learn functional programming; but type classes, which are sort of a unique Haskell feature, almost universally lead people away from functional programming
14:22:39 <joe6> ovrskr: thanks.
14:23:15 <int80_h> it's a trap!
14:23:22 <ski> kadoban : generally, each method in a class should mention all the parameters of the class. in case you have functional dependencies, it doesn't need to mention those which are determined by the FDs from those which are mention
14:23:26 <ski> ed
14:24:18 <kadoban> ah, i guess that' (part of) what fundeps are for then, that makes sense. i don't think that would save this though (not that you implied it would)
14:25:01 <kmc> well you already have one fundep
14:25:40 <kadoban> oh, ya, but i just took it out because i realized it didn't make sense.  didn't affect the error either way anyway
14:27:09 <kadoban> kmc: before i run off and read/think, can you say quickly explain what you meant by the suggested printOn above? i realize it should probably be obvious since you most likely copied parts from my code, but i can't seem to grok
14:27:59 <kadoban> i understant the syntax, but i couldn't say in english what each parameter is, if that makes sense
14:28:07 <monochrom> "haskell type class is like java interface" adds to the harm
14:28:20 <int80_h> monochrom: how so?
14:28:39 <kmc> because 'like' does not extend to 'as necessary as'
14:28:52 <kmc> Java only gives you one way to abstract; Haskell type classes are kind of like that one way
14:28:56 <kmc> but Haskell has better ways to abstract!
14:29:12 <monochrom> all the failed type classes are inspired by "in Java I would use interface for this"
14:29:29 <int80_h> kmc: like what?
14:29:35 <kmc> functions.
14:29:48 <int80_h> that's radical
14:29:50 <monochrom> even records of functions
14:30:09 <kadoban> i assume java interfaces are kinda like c++ abstract classes or something? i haven't really done java
14:30:11 <int80_h> I'm going that way, records of functions
14:30:16 <kmc> kadoban, well, you said that most of the code is the same for all printing methods
14:30:21 <kmc> kadoban, yeah, they are
14:30:24 <geheimdienst> i think "java interface ~ typeclass" is okay to say, but we should in the same sentence emphasize that typeclasses are not nearly as often used as java's interfaces
14:30:42 <monochrom> Text.Parsec.Token is an example
14:30:46 <int80_h> I became interested in typeclasses after encountering yesod
14:30:50 <kmc> kadoban, and that common code would call certain specific operations -- displaying a stone, etc.
14:30:58 <kmc> those operations are the arguments to printOn
14:31:02 <kmc> the common code is printOn itself
14:31:17 <kmc> with the type-class solution you're passing those functions implicitly
14:31:21 <kadoban> kmc: oh, okay thanks, i see what you mean now
14:31:29 <kmc> type classes can be thought of as a system of implicit function parameters
14:31:42 <kmc> but in this case, it's a lot clearer and simpler to pass them explicitly
14:31:46 <kmc> cool, good luck :)
14:31:54 <int80_h> Is this where the critque of yesod comes from, it's not haskell-y enough due to it's central foundation built on a typeclass?
14:32:11 <kadoban> hehe, thanks...i'll read that page first, then try another retarded test case, see if it works better this time
14:32:12 <kmc> geheimdienst, yeah, but the analogy is broken in enough other ways
14:32:55 <kmc> int80_h, the main critique i've heard is that it uses a lot of domain-specific languages implemented as quasiquoters
14:33:03 <geheimdienst> yeah well, no analogy is perfect. in can still be useful to understand the first 70%, then you can get into the other 30% of wrinkles and exceptions and obscure stuff
14:33:20 <tromp> > 165/8
14:33:21 <lambdabot>   20.625
14:33:32 <kmc> no analogy is perfect, but some are helpful and some are actively harmful
14:33:35 <int80_h> oooh. See it seemed to me that using QQ is the way to implement eDSLs. Is there a more preferred approch?
14:33:45 <kmc> int80_h, http://www.yesodweb.com/blog/2011/08/perils-partially-powered-languages was an interesting article by the author of Yesod regarding his philosophy on DSLs
14:33:51 <kmc> int80_h, it's far from the only way
14:34:07 <kmc> the QQ DSLs are "less embedded" than a lot of Haskell eDSLs
14:34:20 <kmc> which are truly just Haskell libraries using user-defined functions and infix operators
14:34:25 <kmc> and maybe overloading the "do" notation
14:34:31 <kmc> you can get a long way with that
14:34:35 <int80_h> kmc: where could I look for a survey on the different ways to implement an eDSL in haskell?
14:34:39 <kmc> without introducing a custom parser or anything
14:34:55 <kmc> each QQ defines a totally new language with a new concrete syntax and a new parser
14:35:08 <kmc> which means the cognitive overhead to learning a new QQ DSL can be a lot higher
14:35:08 <sm> http://www.haskell.org/haskellwiki/Research_papers/Domain_specific_languages
14:35:23 <int80_h> ack
14:35:27 <kmc> while any Haskell programmer can deal with new functions and infix operators embedded in the traditional Haskell syntax
14:35:33 <kmc> and you get a lot of useful stuff for free
14:35:43 <ski> syn ack
14:35:44 <kmc> if you want (f $ g x) to mean (f (g x)) in your QQ, you have to implement that yourself...
14:35:56 <kmc> int80_h, i don't actually have a great reference on this subject, sadly
14:36:00 <kmc> and i have to go right now
14:36:02 <kmc> i'll be back later
14:36:15 <int80_h> kmc: before the flood sm managed to paste a url, which I am looking at now
14:36:19 <ion> That’s not very good advertisement for irccloud.com. :-P
14:36:21 <sm> well, I think new QQ dsls are defined when the cognitive load is *less* than using straight haskell
14:36:57 <int80_h> sm: My problem is I need people who don't know Haskell to use my library. Writing an eDSL seemed to be the way.
14:37:00 <kmc> yeah, sometimes it's worth it
14:37:05 <kmc> int80_h, you could write a non-e DSL
14:37:10 <sm> eg compare persistent's DSL with other haskell db libs
14:37:22 <kmc> but people who "don't know Haskell" can still learn enough Haskell syntax to get by in an eDSL
14:37:26 <kmc> join #xmonad and see :)
14:37:44 <kmc> you can also separate the concerns -- define a QQ which produces Haskell terms in your eDSL
14:37:44 <sm> int80_h: I think that's a good use case, especially if you put it in a separate file like yesod's config/routes
14:37:49 <kmc> people can use one or the other
14:38:09 <kmc> or even write a full-blown standalone lexer/parser/compiler which produces Haskell code in that eDSL
14:38:14 <kmc> anyway bbl
14:41:01 <theamoeba> hello
14:41:49 <mustelo> hi theamoeba
14:42:14 <c_wraith> theamoeba: are you one of those rare brain-eating amoebas?
14:42:34 <theamoeba> lol, depends ... :P
14:44:08 <chrisdone> amoebae… amoebae like a sunday morning
14:45:04 <theamoeba> chrisdone: hehe yeah
14:48:09 <zzo38> Is there more information about GHC bytecode?
14:49:37 <kmc> zzo38, try the GHC Trac wiki
14:49:45 <c_wraith> zzo38: you might also ask in #ghc
14:49:56 <zzo38> OK
14:51:51 <monochrom> back for more? hehehehehe...
14:52:25 <zzo38> I have many ideas about stuff that can be added to Haskell, including "more"-notation.
14:54:39 <zzo38> I want to know how to implement these things possibly using GHC API or whatever.
14:54:42 <chrisdone> any ghcjs users get --calling-convention=trampoline to work?
15:05:30 <Jester_Racer> Can I update the packages installed with cabal somehow?
15:05:42 <Jester_Racer> I can't find any option for this in help
15:06:43 <Jester_Racer> there is cabal upgrade but it says to use install instead. but with install I can only install new packages, right?
15:06:56 <mauke> I don't think so
15:07:07 <monochrom> "cabal install x" can install new versions of x
15:07:32 <Jester_Racer> so there's no option to update every package? :O
15:07:42 <monochrom> but see my http://www.vex.net/~trebla/haskell/sicp.xhtml for why you do not want to just add new versions like that
15:10:51 <Jester_Racer> great writing, added to my bookmarks :)
15:11:06 <monochrom> thank you for choosing monochrom
15:11:55 <Jester_Racer> :)
15:12:11 * chrisdone thought monochrom had written a Haskell version of MIT's SICP
15:16:53 <zzo38> Another idea I have for Haskell, other than more-notation, is a new kind (maybe we can use the symbol ## for this kind) that means numbers. If  a type of kind ## is expected then you put a integer there, and then a few operations can be done on these numbers within the type system.
15:17:16 <chrisdone> function foo(x) { return bar(x + 1);} function bar(x) { return foo.arguments[0]; } foo(1) this returns 1. JavaScript is EVIL
15:17:30 <kmc> zzo38, people are working on that for GHC
15:17:33 <kmc> type-level naturals
15:17:59 <chrisdone> i thought TLNs came in in some version of 7…
15:18:23 <zzo38> kmc: OK. What is its kind symbol when it will be implemented?
15:18:29 <kmc> don't know
15:19:15 <chrisdone> still being worked on it seems: http://hackage.haskell.org/trac/ghc/ticket/4385
15:20:22 <Jester_Racer> anyone tried the free hostings for darcs?
15:20:48 <zzo38> OK, it uses the kind Nat although they should probably use symbols like it uses * and ? and so on for kinds, since the existing kinds do not use letters so the new ones probably also should not use these letters
15:21:00 <Jester_Racer> patchtag or darcsden? which one is better? :P
15:21:43 <kmc> zzo38, it's very different from the existing kinds
15:22:54 <zzo38> kmc: OK.
15:25:55 <ornicar> hi all! newbie here.
15:26:00 <kmc> hi ornicar!
15:26:01 <Cale> zzo38: There's only so much you can do without using letters without going insane.
15:26:01 <lambdabot> Cale: You have 3 new messages. '/msg lambdabot @messages' to read them.
15:26:16 <ornicar> I'm trying to find Data.Map implementation. I can't find it in haskell library source code.
15:26:29 <ion> @hoogle Data.Map
15:26:30 <lambdabot> module Data.Map
15:26:30 <lambdabot> Data.Map data Map k a
15:26:30 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
15:26:36 <Cale> If you start from: http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.4.1.0/Data-Map.html
15:26:38 <nominolo> chrisdone: I changed the Analytics account to the same that the platform pages use, last weekend.
15:26:44 <kmc> ornicar, http://www.haskell.org/ghc/docs/latest/html/libraries/index.html , click Data.Map, click source links
15:26:45 <ion> Ah, hoogle didn’t give URLs . Duh.
15:26:45 <Cale> and click the source links, you'll get to:
15:26:50 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.4.1.0/src/Data-Map.html#Map
15:26:51 <ornicar> ah thank you!
15:27:04 <nominolo> chrisdone: so, I'll wait a couple of weeks and then make a blog post
15:27:45 <chrisdone> nominolo: cool :-)
15:27:46 <ion> That is, @hoogle didn’t. You’ll find http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html by searching on http://www.haskell.org/hoogle/
15:28:04 <ion> as an alternative way
15:28:44 <ornicar> I got the haskell source from http://darcs.haskell.org/packages/base.git/ I'm curious about how Data.Map can not be inside.
15:28:53 <kmc> that's the 'base' package
15:28:59 <kmc> Data.Map is in the 'containers' package
15:29:05 <ornicar> ah ok, got it, thanks again.
15:29:15 <kmc> there's probably a containers.git, but you can also grab the tarball from http://hackage.haskell.org/package/containers
15:29:28 * kmc giggles at http://darcs.haskell.org/..../*.git
15:29:29 <ornicar> http://darcs.haskell.org/packages/containers.git/ here it is :)
15:29:42 <nominolo> chrisdone: it's not too interesting.  The location of visitors is quite interesting, and we get quite a large amount of traffic from xmonad
15:30:18 <chrisdone> nominolo: makes sense. i'm guessing the location of visitors is mainly US, UK and germany?
15:33:16 <nominolo> chrisdone: a lot is US.  UK and Germany follow, but there're many other countries which don't trail by far
15:33:55 <chrisdone> nominolo: nice to hear
15:34:05 <chrisdone> nominolo: what about content clicks?
15:34:50 <nominolo> chrisdone: I noticed that it only can track content clicks if the target is also under the same analytics account.  That makes it somewhat less useful.
15:37:38 <chrisdone> nominolo: yeah, would be nice for it to hook into all links but i guess that's difficult
15:38:17 <chrisdone> it'd probably have to replace all links with googleanalyticsdomain.com/log_and_redirect?url=… sort of thing
15:40:16 <nominolo> chrisdone: Yes.  I think it uses the referrer info to track which link was clicked.
15:41:06 <nominolo> Which explains why it thought 30% of people were clicking on the logo.  They probably didn't, it just happens to link to that site.
15:42:55 <chrisdone> hehe
15:43:45 <kmc> so any examples of footnotes or citations in cabal description field?
15:50:54 <nominolo> @tell edwardk for my slicer, I have some old bitrotted code on top of 6.10.  I was planning on integrating it into Scion, but that's needs some infrastructure work before I can work on that.
15:50:54 <lambdabot> Consider it noted.
15:50:56 <joe6> is there any way to do this at command line while starting up ghci? :m + Bindings.SnsrUsb
15:51:16 <nominolo> joe6: you can use a .ghci file
15:51:38 <nominolo> echo ":m + Bindings.SnsrUsb" > .ghci
15:51:42 <joe6> nominolo: ok, thanks. I was looking for a command line option. but, that should do..
15:53:28 <sm> how do you cabal configure & build several package source dirs that depend on each other, without installing ?
15:54:07 <sm> not cabal configure <packagedirs> ... not cabal configure --ghc-options=-i../<packagedir> ...
15:54:36 <unit3> Hey all, attempting to learn me a haskell, can someone point out to me why this doesn't do what I'm expecting it to? :) http://hpaste.org/50695
15:55:09 <Leftmost> Why would `cabal install --only-dependencies' claim it couldn't configure a dependency due to the dependency's dependencies if that dependency is already installed?
15:55:11 <shachaf> unit3: [] and head x are different types.
15:55:26 <shachaf> unit3: Try to figure out the type of that expression. :-)
15:55:42 <unit3> Oh durrr, yeah, you're right.
15:55:47 <sm> Leftmost: try adding -v3 for clues, and see http://www.vex.net/~trebla/haskell/sicp.xhtml
15:55:49 <unit3> Clearly I've been at my desk too long.
15:55:56 <shachaf> unit3: Also, you should probably use pattern-matching instead of head and null.
15:56:19 <shachaf> I.e. decapitate [] = []; decapitate (x:_) = x
15:56:24 <unit3> shachaf: I'm sure, I just haven't got that far in the tutorial, working my way through Learn Me A Haskell to try and figure out how it relates to stuff I already know.
15:56:28 <shachaf> That still has the same type error, of course. :-)
15:56:40 <unit3> true. it'll be more what I'm trying to test if I use tail instead of head.
15:56:42 <shachaf> LYAH tells people about head and null before telling them about pattern matching?!
15:56:45 <glguy> :t \x -> if null x then [] else head x
15:56:46 <lambdabot> forall a. [[a]] -> [a]
15:57:06 <unit3> shachaf: yeah, it does. I can see why, lots of languages don't have pattern matching, but they have lists, so cover familiar things first.
15:57:19 <unit3> Of course, I know patterns from erlang already, but I am trying to take things in order. ;)
15:57:22 <glguy> shachaf: see, the type is fine :)
15:57:29 <glguy> it's a list of lists
15:57:37 <shachaf> glguy: True, but not in the context unit3 wanted to use it.
15:57:55 <unit3> really, it was just an experiment function, and I didn't catch the type error.
15:58:06 <unit3> the ghci errors are a little obtuse to me still, I'm sure I'll get used to them.
15:58:30 <shachaf> As glguy points out, the type error is actually in using that function on a list of non-lists, not in defining it.
15:58:44 <shachaf> unit3: In general head is considered slightly bad style, because using it on an empty will crash your program.
15:59:03 <shachaf> Whereas if you pattern-match on x:xs and on [], the compiler can guarantee that all cases are handled.
15:59:18 <unit3> makes sense, for sure. and I definitely prefer pattern matching.
15:59:30 <glguy> The worst part about head is the generic error message it gives you when you apply it to []
15:59:38 <stulli> monochrom: In SICP you say that you "only upgrade at Haskell Platform release points". Do you mean you do a cabal update only at HP releases too?
15:59:39 <glguy> you'll have no idea where in your source file it came from
15:59:43 <shachaf> Yep.
15:59:58 <shachaf> Until JaffaCake's miracle cure is ready, of course. :-)
16:00:15 <monochrom> no, and unnecessary. new ghc implies goodbye to old packages anyway
16:01:02 <sm> or use headDef/headMay/headNote
16:01:16 <sm> good ol' safe lib
16:01:50 <ion> or listToMaybe :-P
16:02:41 <Leftmost> sm, the results of the -v3 don't make sense to me. It says "selecting" and then the rest of the line is empty right before it gives the error. I checked the package.conf.d/ file for the package that's giving me the error and it's depending on the version it says it can't install.
16:02:55 <joe6> "unsigned int test1;
16:03:22 <ski> @type let decapitate [] = []; decapitate (x:_) = x in decapitate
16:03:22 <lambdabot> forall a. [[a]] -> [a]
16:04:57 <joe6> "extern unsigned int test1;" does not work, "unsigned int test1;" works, "#globalvar test1 , CUInt"  of bindings-DSL is what I am using.
16:05:10 <geheimdienst> Leftmost: have you tried "ghc-pkg check"?
16:05:19 <joe6> the error is: Loading package bindings-snsrusb-0.0.4 ... linking ... <interactive>: /home/j/.cabal/lib/bindings-snsrusb-0.0.4/ghc-7.0.4/HSbindings-snsrusb-0.0.4.o: unknown symbol `test1'
16:05:32 <stulli> monochrom: Ok i see. And thanks for the article, a must-read for every cabal user. I'm a hobby haskeller since 3 years or so and still cringe when i get cabal errors ;)
16:05:39 <joe6> any suggestions, please?
16:05:55 <ion> > map (fromMaybe 42 . listToMaybe) [], [0..]
16:05:57 <lambdabot>   <no location info>: parse error on input `,'
16:06:03 <ion> > map (fromMaybe 42 . listToMaybe) [[], [0..]]
16:06:05 <lambdabot>   [42,0]
16:06:23 <sm> monochrom: you should totally rename that doc :)
16:07:38 <Leftmost> geheimdienst, just did. No output.
16:08:11 <monochrom> "ghc -v" is the most informative one. subsumes "ghc-pkg check"
16:09:55 <Leftmost> Alright. Gotta pack up. I'll keep investigating.
16:18:01 <Yxven> Is there a way to stop processing a function in the interpreter without killing the interpreter?
16:18:31 <ion> ^C
16:18:48 <Yxven> thanks
16:57:38 <copumpkin> I wish initAllocForGMP weren't static
17:03:20 <kmc> bah, there are ways of calling static functions ;)
17:04:07 <copumpkin> kmc: if I could get its address I'd be very happy
17:04:17 <copumpkin> I don't even need to call it
17:04:34 <copumpkin> but I need to do it in a cross-platformish way
17:05:25 <kmc> yeah, my approaches are along the lines of "disassemble a function that calls the static function"
17:05:43 * chrisdone plays the Godfather theme for kmc
17:06:10 <copumpkin> kmc: oh, it's just GHC code
17:06:21 <copumpkin> I'd have no trouble if I were allowed to patch things :)
17:06:34 <copumpkin> but I'm trying to be friendly to users here
17:07:00 <cmccann> pf users
17:07:03 <cmccann> what did they ever do for you
17:07:18 <chrisdone> TIL about the programming language Vala
17:09:36 <Cale> It looks like a thoroughly boring language.
17:09:46 <cmccann> from wikipedia "Vala is a programming language created with the goal of bringing modern language features to C" ...where by "modern" they apparently mean "two decades old" rather than "three decades old"
17:10:08 <kmc> snobs, all of you
17:11:16 <kmc> real programmers use C because real programmers don't make mistakes!  plus, you can have bugs in PHP also, so C and Haskell are equally secure.  and C is fast so my IRC client can get those extra precious microseconds
17:12:15 <luite> kmc: yes I hear hft over irc is the next big thing
17:12:41 <kmc> probably better than FIX
17:12:51 <joe6> c file: http://codepad.org/FsndoyQb, the .hsc file: http://codepad.org/o7m8lzwY , error http://codepad.org/WoDd6tML , simple error "final link ... ghc: test.o: unknown symbol `test1'"
17:12:52 <maurer_> kmc: To be fair, for low level work, do you have a C replacement?
17:12:55 <maurer_> If you do, I'm interested.
17:13:03 <joe6> any suggestions on fixing it, please?
17:13:12 <kadoban> kmc: thanks again for the idea before, this is working out much better than the typeclass thing
17:13:20 <kmc> i like Vala, though I haven't used it
17:13:29 <permagreen> maurer_: I hear assembler is pretty low-level
17:13:32 <maurer_> joe6: objdump -t test.o
17:13:38 <maurer_> joe6: Give us the output of that?
17:13:40 <joe6> i am just trying to use a "extern " variable from ghci.
17:13:43 <maurer_> permagreen: But that's even worse.
17:13:54 <joe6> maurer_: output of what?
17:14:11 <joe6> i am trying to understand how to use the global variable in c
17:14:17 <joe6> from haskell ffi
17:14:22 <maurer_> objdump -t test.o
17:14:32 <maurer_> Oh
17:14:39 <kmc> the idea of "C# without Microsoft lockin, with a direct native compiler" sounds pretty good to me
17:14:57 <joe6> maurer_: http://codepad.org/zlruwsMY
17:15:09 <kmc> also i think it's interesting that they took an object system for C and then built a language around it
17:15:17 <joe6> this is the line in my .c file: extern volatile unsigned int test1;
17:15:22 <maurer_> joe6: OK
17:15:30 <kmc> i agree it's probably not interesting from a hard PL theory perspective
17:15:31 <maurer_> So the problem is you have an unresolved symbol here
17:15:37 <joe6> and I am trying to figure out how to use it with haskell ffi
17:15:39 <maurer_> You need some object file providing that symbol
17:15:58 <maurer_> kmc: I actually dislike objects strongly.
17:15:59 <Eduard_Munteanu> kmc: don't you get zero lock-in as long as you avoid MS/Windows-specific C# things?
17:16:08 <kmc> there certainly are more GNOME desktop apps written in Vala than in Haskell, and according to some people that is the measure of success for a language
17:16:21 <maurer_> joe6: So, that file there isn't a complete module by itself--it is missing a definition for test1
17:16:23 <joe6> maurer_: yes, I am trying to figure how out how to do that. I had the object defined in the linker file to a specific memory loaction.
17:16:40 <maurer_> joe6: Well, according to objdump, it didn't take
17:16:56 <joe6> maurer_: gotcha..
17:17:01 <kmc> oh man, Unity is written (partially) in Vala
17:17:01 <joe6> maurer_: thanks.
17:17:26 <kmc> if I'm obliged to love Darcs because it's written in Haskell, should I also hate Vala because it's used to write Unity?
17:17:59 <maurer_> kmc: I mean, presumably no more than you're obligated to hate firefox for being written in C++?
17:19:24 * cmccann hates every piece of software ever written. simpler that way.
17:19:24 <permagreen> Is it, however, okay to hate minecraft just a little because it's written in java?
17:19:26 <kmc> copumpkin, so "friendly to users" means not forcing them to upgrade ghc?
17:20:17 <permagreen> Friendly to users means "we take care of everything behind to the scenes so that when something goes wrong you have no idea how to fix it."
17:20:26 <copumpkin> kmc: yeah, or install a patched version of mpfr
17:20:44 <joe6> maurer_, can I define that global variable in haskell?
17:20:53 <joe6> maurer_, and use it in c.
17:20:58 <joe6> does that make sense?
17:21:35 <kmc> joe6, in general, i'd define global variables in C and foreign import them by address
17:21:39 <kmc> but i'm not sure exactly what you're doing
17:22:05 <kmc> foreign import ccall "&foo" pFoo :: Ptr Int
17:22:10 <Eduard_Munteanu> I'm not sure it makes sense to talk about global variables in Haskell.
17:22:34 <joe6> kmc, Eduard_Munteanu, makes sense. Thanks.
17:23:12 <Eduard_Munteanu> (as in space that's allocated in the object code at compile-time)
17:23:15 <kmc> definitely makes sense to talk about C global variables in Haskell
17:23:25 <kmc> which are allocated in the object code at compile time
17:23:51 <Eduard_Munteanu> Yeah.
17:24:18 <kmc> i think the only portable way to get a global mutable Int cell in Haskell is to define it in C
17:24:36 <joe6> i have this c file: http://codepad.org/2KBLbAlX and this with the definition of the global variable: http://codepad.org/SdoyFs4G. I could define all the global variables like that. create 2 .o files
17:24:46 <joe6> and then how do I import such file into haskell to use?
17:25:15 <joe6> i tried this: http://codepad.org/5kUcGH6Y
17:25:19 <kmc> foreign import ccall "&test1" pTest1 :: Ptr CUInt
17:25:38 <Eduard_Munteanu> Why extern or static?
17:25:57 <Eduard_Munteanu> Assuming this is a .c file, not a .h
17:25:58 <joe6> Eduard_Munteanu: static in the defining file, and extern in the file using it.
17:26:11 <Eduard_Munteanu> That doesn't sound alright.
17:26:21 <joe6> Eduard_Munteanu: I have current C code with a bunch of externs that I am trying to unit test with haskell.
17:26:34 <joe6> the externs are the devices' memory locations.
17:26:41 <joe6> which is device specific.
17:26:59 <joe6> I plan to, define, them as normal memory locations so I can test it on the pc.
17:27:46 <Eduard_Munteanu> If you have variables you need to access from different compilation units, you declare them with 'extern' in the header and without any linkage qualifier in the .c file.
17:27:49 <kmc> yeah, the extern in one compilation unit won't link to the static var in the other
17:27:54 <kmc> extern in one unit, non-static in the other is fine
17:27:56 <joe6> kmc, i defined the global variable with this : http://codepad.org/1HzEykpK
17:28:03 <joe6> #globalvar test1 , CUInt
17:28:18 <kmc> it's typical to put the extern in a header as Eduard_Munteanu said, but not strictly required
17:28:30 <kmc> (you can even declare extern variables local to a function! just learned that a few months ago)
17:28:43 <Eduard_Munteanu> Oh, hm.
17:28:53 <joe6> Eduard_Munteanu: but, how do i specify the location where the extern symbol is stored?
17:29:15 <Eduard_Munteanu> joe6: symbols which aren't static are searched by name
17:29:27 <kmc> joe6, when you declare the symbol without "extern" the linker will allocate some space
17:29:37 <joe6> Eduard_Munteanu: if I do that, just extern, this is the error I get: http://codepad.org/IRlplIBF
17:29:41 <kmc> then when you declare it "extern" in another compilation unit, that gets linked to the same space
17:29:42 <Eduard_Munteanu> Symbols which are static can't be accessed from another compilation unit and don't pollute the namespace.
17:29:52 <joe6> but, I need extern in that file.
17:30:06 <joe6> and in my original app, I allocated the symbol in the linker file.
17:30:14 <kmc> joe6, if the variable is "static" then you're not going to link it to Haskell or C code in another file
17:30:18 <joe6> but, with haskell, I am not sure where I can allocate the symbol.
17:30:26 <mauke> <Eduard_Munteanu> If you have variables you need to access from different compilation units, you declare them with 'extern' in the header and without any linkage qualifier in the .c file.
17:30:40 <kmc> joe6, you need a C file with a non-extern, non-static declaration of the variable
17:30:50 <joe6> kmc, ok, thanks.
17:30:52 <joe6> let me do that.
17:30:54 <Eduard_Munteanu> Aw... I angered mauke and he's been summoned!
17:30:56 <joe6> sorry for the bother.
17:31:06 <joe6> Eduard_Munteanu: thanks, I think I get it now.
17:31:48 <Eduard_Munteanu> Wait, I think he wasn't planning to correct me. I thought I made a mistake. :)
17:31:59 <joe6> Eduard_Munteanu: kmc, mauke, that worked like a charm.
17:32:03 <joe6> Thanks a lot.
17:32:19 <kmc> :) glad it worked
17:33:36 <Eduard_Munteanu> kmc: yeah, I guess it's okay to put *declarations* in just about any place
17:35:04 <Eduard_Munteanu> Though regarding missing 'extern' keywords, I'm sure many do that, but it might not be 100% correct from the standard's POV.
17:36:05 <kmc> yeah.  i didn't mean to say "extern" keyword is not required
17:36:37 <Eduard_Munteanu> GCC gladly accepts missing 'extern' though, at least without -pedantic or such stuff.
17:36:46 <kmc> yeah
17:36:50 <kmc> there's a linker hack for it iirc
17:37:01 <Eduard_Munteanu> Oh.
17:37:13 <maurer_> linkers are the worst things
17:37:14 <deech> I just tried to compile the HList tip and got a scary looking error "Context reduction stack overflow; size = 21. Use -fcontext-stack=N to increase stack size to N". I can follow its advice but what does it mean?
17:38:18 <cmccann> deech, GHC has a very shallow stack for checking recursive type class instances
17:38:19 <kmc> deech, with -XUndecidableInstances, it's no longer structurally obvious whether type class instance resolution terminates
17:38:39 <kmc> so GHC will just try its best and give up at some depth
17:38:52 <cmccann> so to reduce the chance of sending the type checker into an infinite loop, it sets a very low stack depth and gives errors like that if you exceed it
17:38:55 <kmc> apparently it is considered bad if your compiler enters an infinite loop
17:39:02 <kmc> i don't think it's that bad really
17:39:06 <cmccann> not that it's terribly difficult to do that anyway
17:39:18 <kmc> and anyway there are longstanding wont-fix bugs in GHC which will *actually* cause an infinite loop
17:39:35 <maurer_> kmc: Link?
17:39:56 <maurer_> kmc: Also, UndecidableInstances for me, has always been a warning that I've done something wrong.
17:40:07 <maurer_> A couple of times I've thought "Oh, I'll turn this on" and it's never been the right thing to do.
17:40:13 <kmc> http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs.html#bugs-ghc
17:40:26 <cmccann> UndecidableInstances is a sledgehammer to get around GHC's irritatingly limited termination checker
17:40:44 <cmccann> there are lots of clearly terminating instances that you have to enable UndecidableInstances to use
17:40:45 <maurer_> cmccann: Can you give me an example of a case in which it is useful?
17:40:47 <kmc> there's still no extension to enable backtracking for instance resolution
17:41:02 <deech> kmc, cmccann: So can I go ahead and follow the advice in the error and set '-fcontext-stack=N' to some number over 21?
17:41:07 <kmc> sure
17:41:12 <kmc> you can set it as high as you like deech
17:41:25 <kmc> the higher it is, the longer GHC will take to catch a bug in HList (or how you're using HList)
17:41:34 <kmc> a bug that causes a loop in the instances
17:41:38 <kmc> but it will still catch it anyway
17:42:09 <maurer_> kmc: Those neither seem to be wontfix nor seem to be infinite loop?
17:42:31 <Eduard_Munteanu> The 'russel' one seems to be
17:42:38 <kmc> "GHC's inliner can be persuaded into non-termination using the standard way to encode recursion via a data type:... We have never found another class of programs, other than this contrived one, that makes GHC diverge, and fixing the problem would impose an extra overhead on every compilation. So the bug remains un-fixed"
17:42:44 <deech> kmc: What follows is a type error that rivals a C++ template error. Pretty intimidating.
17:42:48 <cmccann> maurer_, how about http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/Control-Monad-State-Class.html
17:42:51 <maurer_> Eduard_Munteanu: Oh, my bad, missed that
17:43:01 <cmccann> or is the MonadState class not useful enough for you? :P
17:43:05 <Eduard_Munteanu> Yeah, it wasn't obvious to me either which one it was.
17:43:14 <maurer_> cmccann: I didn't realize they used UndecidableInstances
17:44:07 <cmccann> maurer_, in general there's really nothing too terrible about UndecidableInstances, the worst case scenario is that a bug in your code causes GHC to hang which is really not the end of the world
17:44:25 <maurer_> cmccann: I'm not saying it's bad or wrong to use.
17:44:37 <maurer_> cmccann: I'm more saying every time I've thought I should use it, I've been wrong.
17:44:53 <cmccann> in fact, I find compile-time, type-level nontermination significantly less objectionable than run-time, term-level nontermination
17:45:00 <kmc> overuse of type classes is very popular
17:45:25 <kmc> the more I use Haskell for real projects (whose goal isn't "learn type class hackery") the less i like type class hackery
17:45:36 <cmccann> maurer_, in general UndecidableInstances is required for writing very generic instances that are mostly aliases for others, and for doing complex type-level computations as in things like HList
17:46:25 <cmccann> in the former case, nontermination is rarely an issue, because things are simple
17:46:28 <kmc> and every day beginners come in here with code that's a big pile of new classes, instances, wrapper types, and FlexibleUndecidableIncoherentMadness
17:46:41 <cmccann> in the latter case, you want turing-complete type computation anyway because that's what you're doing
17:46:46 <kmc> and usually the solution is "use a function instead"
17:47:09 <Peaker> kmc: the kind of type-class hackery in QuickCheck and Printf is nice
17:47:17 <cmccann> kmc, I find outright type-hackery less problematic than overuse of ad-hoc polymorphism to no benefit
17:47:25 <kmc> Printf is not nice
17:47:47 <Peaker> kmc: Printf may not be very nice (at least without mauke's TH safety) but the kind of type-class magic in it is nice :-)
17:47:54 <ski> `Printf' is a solution of the wrong problem
17:47:54 <kmc> i don't think it's that nice
17:47:58 <kmc> your output formats should be specified using a DSL with actual types
17:48:01 <kmc> not as strings
17:48:02 <maurer_> kmc: I mean, I've found Flexible{Contexts,Instances} and Multiparameter to be pretty much requirements for any typeclass hackery
17:48:13 <kmc> (if you must, as strings fed to a quasiquoter at compile time)
17:48:46 <mauke> the point of printf is concise syntax
17:48:55 <mauke> anything but strings is too much syntactic overhead
17:48:56 <Peaker> Hmm.. is there something like Printf, but which is more like C++'s cout, and thus safe?
17:49:06 <kmc> haha
17:49:11 <cmccann> things like HList are a bit silly, but doing something potentially useful. unstructured function overloading and people wanting existentials with class constraints are mostly useless
17:49:12 <kmc> "more like C++ and thus safe"
17:49:16 <mauke> C++'s cout isn't exactly safe
17:49:17 <kmc> sorry, that's just funny
17:49:18 <ski> mauke : yeah. a proper quasi-quoter is better, though
17:49:22 <Peaker> mauke: why not?
17:49:29 <mauke> Peaker: it's stateful
17:49:37 <mauke> printing certain things causes state changes
17:49:58 <Peaker> mauke: Ah, ok.. Well, I mean safe as in, no TH needed to guarantee format/type correspondence
17:50:04 <Peaker> show x ++ ", " ++ show y ++ ": " ++ ... <-- bah!
17:50:25 <Peaker> concat [show x, ", ", show y, ": ", ...] <-- still bah
17:50:30 <ski> @let a << b = a ++ show b
17:50:31 <lambdabot>  Defined.
17:50:51 <mauke> printf has the advantage of being concise and already known to many programmers
17:51:15 <mauke> and the TH version is like a compile-time DSL
17:51:32 <geheimdienst> @hoogle printf
17:51:32 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
17:51:32 <Peaker> > let f x y = "" << x << ", " << y << ": " << "Yay!" in f 1 2
17:51:32 <lambdabot> module Text.Printf
17:51:32 <lambdabot> Text.Printf class PrintfArg a
17:51:34 <lambdabot>   "1\", \"2\": \"\"Yay!\""
17:51:38 * cmccann thinks a printf-like QQ'r would probably be the most non-hackish way to do that, really
17:51:59 <kmc> i'm not sure how to discourage beginners from overusing type classes
17:52:04 <Peaker> ski: for strings you don't want them "show"n, maybe
17:52:07 <kmc> suggestions?
17:52:14 <ski> Peaker : use a second operator
17:52:36 <mauke> {-# LANGUAGE NoOverusedTypeClasses #-}
17:52:59 <ski> kmc : not sure, other that showing more examples of passing around functions and records of functions ?
17:53:02 <cmccann> kmc, I suspect type classes are a symptom, not a cause to be honest
17:53:17 <kmc> symptom of the kingdom of nouns?
17:53:21 <kmc> or something else?
17:53:30 <cmccann> find what it is that people think they're accomplishing with superfluous type classes, then show better ways to do that, I guess
17:53:40 * mauke ponders
17:53:49 <cmccann> kmc, maybe, but I doubt it
17:53:55 <kmc> what they think they're accomplishing is making a function that has a few different behaviors, and reusing code between them
17:54:04 <kmc> they think new behavior => new type
17:54:08 <kmc> because that's how it is in Java
17:54:12 <mauke> with TH you could actually do more than just type-check the normal printf
17:54:13 <kmc> this is my theory
17:54:13 <dgpratt> gloss uses the same coordinate scheme as GLUT, right? y value increases from 0 in the top-left corder?
17:54:33 <Eduard_Munteanu> Hm, that makes me think whether you can have typeclasses which encompass all types: by default using default definitions, and those which have explicit instances defined.
17:54:52 <cmccann> Eduard_Munteanu, only with OverlappingInstances and a lot of headaches
17:55:26 <ski> `OverlappingInstances' should be taken out back and shot
17:55:37 <mauke> $(printf "%S %S") 42 (Just ())
17:55:39 <kmc> if there's no real backtracking, yes
17:55:47 <Eduard_Munteanu> Yeah, because I'm thinking    class Printable a where print :: a -> String    and you'd only provide an instance for e.g. String, so you could write cout properly
17:55:51 <cmccann> if you think of the instance heads as pattern matching on type constructors, OverlappingInstances lets you write default fall-through patterns in a confusing and awkward way that doesn't really work well
17:56:02 <Eduard_Munteanu> And the default print would merely do show.
17:56:14 <Eduard_Munteanu> instance Printable String where print = id
17:56:43 <kmc> perhaps the problem is that tutorials introduce type classes early, because you need to know how to use (+) and 'show' and such
17:56:47 <Eduard_Munteanu> I see.
17:56:52 <parcs> is there any way to write to stdin?
17:56:55 <cmccann> OverlappingInstances is a generally bad idea that incidentally includes a few useful dirty hacks
17:57:13 <Eduard_Munteanu> parcs: yes, remap stdin to some writable stream :)
17:57:28 <mauke> parcs: what are you trying to achieve?
17:57:43 <mauke> Eduard_Munteanu: I think cout is a bad design and shouldn't be emulated
17:57:45 <Eduard_Munteanu> The only thing remotely like writing to a "true" stdin is C's ungetc().
17:57:49 <cmccann> kmc, I think having "class" in the term doesn't help either, with how ingrained "object-oriented" thinking is these days
17:58:05 <Eduard_Munteanu> Yeah, I'm not advocating it, just wondering how one would go about writing it.
17:58:12 <kmc> but it's a concept with a name and some meat to it, compared to the idea of passing functions to functions, which is so obvious and effortless that it's easy to ignore
17:59:03 * cmccann keeps describing type classes as a more structured version of overloading functions rather than anything similar to OO classes, but it never seems to help
17:59:05 <deech> Having spent about a half-hour looking at HList and OOHaskell I've come to the conclusion that it's way way above my head. I'll just go back to regular Haskell.
17:59:29 <Peaker> deech: IMO there's little point to OOHaskell
17:59:30 <cmccann> deech, HList isn't really something usable without understanding it, I think :T
17:59:33 <Eduard_Munteanu> Why do you think you need heterogenous collections?
17:59:36 <cmccann> which is unfortunate
17:59:39 * ski thinks it might be useful to have a `withInputFromString :: String -> IO a -> IO a', &c.
17:59:56 <cmccann> ad-hoc tuples with some type hackery attached are useful at times
18:00:06 <kmc> parcs, what do you want to do with it?
18:01:15 <deech> Eduard_Munteanu: I've brought this up before but I'd like a more OO'ish bindings to GTK/whatever-oo-lib and I was thinking that OOHaskell might be useful there. I've come to the conclusion that I'm not good enough to take advantage of it.
18:01:46 <Eduard_Munteanu> Why would you...
18:02:04 <mauke> is GTK OO?
18:02:12 <deech> mauke: Yup.
18:02:13 <kmc> pretty much
18:02:14 <Eduard_Munteanu> One thing I liked about gtk2hs was MVC somewhat resembled a functional style.
18:02:31 <kmc> there's no reason OOP and FP need to be mortal enemies
18:02:35 <deech> Eduard_Munteanu: It's not functional, it's more procedural.
18:02:45 <kmc> there's also no reason not to use OOP when it fits the problem
18:02:48 <cmccann> most OO languages don't support OOP very well, though
18:03:05 <kmc> and most imperative languages don't support imperative programming as well as Haskell does
18:03:08 <kmc> but what can you do
18:03:20 <cmccann> fake it, usually
18:03:24 <Cale> deech: I think most of the OO libraries for Haskell are overrated. You can encode OO in Haskell for the most part really straightforwardly, if you don't care about weird things like inheritance.
18:03:27 <deech> I wonder if that's why other FP languages (Ocaml, Scala) bolt on an OO layer to make it easier to bind to other libraries.
18:03:41 <kmc> who uses the object system in Ocaml?
18:03:42 <Eduard_Munteanu> Besides, depending on the project at hand, it might be a better way to get whatever "raw" bindings you can and layer an idiomatic Haskell API on it.
18:03:42 <cmccann> I mean, you can do OOP in C as well as C++, the difference mostly being that doing it in C++ requires more discipline
18:04:22 <deech> kmc: I've seen it used in the canonical networking library. I think it's called netstring.
18:04:27 <Eduard_Munteanu> Think, hmatrix.
18:04:32 <kmc> yeah, OOP isn't a bad idea, but it's a) widely implemented poorly, and b) shoved down everyone's throat as the One True Paradigm
18:04:43 <cmccann> Cale, it's mostly subtyping that's painfully absent
18:04:50 <cmccann> inheritance is almost always a bad idea in OOP languages anyway
18:04:54 <Eduard_Munteanu> OOP is fine, but it's not granular enough.
18:05:16 <kmc> i also think "OOP" is a marketing term
18:05:27 <kmc> it stands for a cluster of somewhat-related language features, and a whole lot of '90's hype
18:05:36 <Cale> cmccann: But you can do subtyping pretty nicely in Haskell in the same way as Control.Exception does.
18:05:39 <deech> I have 5+ years experience in OOP. Can I have money now?
18:06:02 <sm> Eduard_Munteanu: alan kay says "they didn't make objects big enough"
18:06:05 <Eduard_Munteanu> In many respects, Haskell subsumes at least some OOP concepts. Yeah, it could be better / display a bit more brevity in some respects, but it's so much more general.
18:06:22 <cmccann> Cale, yeah, but it still feels a bit clumsy compared to direct support. but eh, not that important
18:06:54 <cmccann> considering that most languages with subtyping built in actively bungle it Haskell probably still comes out ahead
18:06:55 <Eduard_Munteanu> In a sense it's a bit like doing OOP in C.
18:07:10 <Eduard_Munteanu> You get to do your own dispatch and inheritance mechanism.
18:07:12 <Cale> I also think that subtyping is much less important if the implementations of your object methods aren't tied to the class.
18:07:31 <kmc> yeah, the types in OOP-in-Haskell are interfaces, not implementations
18:07:48 <kmc> at least if you do it the kmc-and-Cale approved way
18:08:10 <kmc> as opposed to the "gratuitous type class" way
18:08:47 * cmccann isn't sure why you'd want type classes when encoding OOP in Haskell
18:08:49 <Eduard_Munteanu> The problem with OOP languages is they provide limited mechanisms and thus policy, I'd speculate.
18:08:56 <Cale> I don't really understand how that even got started, really. Objects in OOP were always supposed to be distinguished from each other by the fact that they respond to their methods in different ways. If you tie the methods to the classes, it pretty much forces you to do a lot of spurious subclassing.
18:08:59 <cmccann> other than maybe gratuitous type hackery to fake a subtyping relation, ha ha
18:09:37 <cmccann> Cale, yeah, that's one part of why most OOP languages don't support OO very well
18:10:46 <Eduard_Munteanu> Not to mention they usually suck at making subclassing effortless. :)
18:10:58 <kmc> tl;dr: programming languages suck for inexplicable reasons; people consistently use the wrong ones and don't learn from the past
18:11:05 <kmc> so, uh, what to do about it
18:11:19 <Cale> It seems like there was this period in time when there were a lot of rather principled languages, followed by a period where people started making drastic concessions in the features that their languages supported to make them easier to compile.
18:11:42 <deech> kmc: What's worse is that they make great software with crappy languages!
18:12:05 * cmccann hasn't seen a lot of great software out there so far
18:12:14 <cmccann> there's a lot of mostly tolerable software though
18:13:16 <deech> cmccann: Let me amend, tolerable software that is necessary and will take many man-years to reproduce.
18:13:17 <Eduard_Munteanu> (but that's probably because the syntax is quite verbose, unlike Haskell's)
18:15:09 <Cale> I was playing around with Algol 68 the other day, and while it's not all that special by today's standards, it is at the same time older than C and a much nicer language in a number of ways. If things had gone a little differently and Algol 68's children had been a little more full featured rather than easier on the implementors, the language that would have been C might have had proper first class procedures.
18:15:45 <kmc> Cale, you should write an alternate history novel on this premise
18:15:48 <Cale> haha
18:16:39 <deech> Cale: I don't know much about Algol 68, but there are modern implementations of Pascal and Modula-2. And I read a blog post that said that Algol and Go were pretty comparable.
18:17:19 <deech> Cale: http://www.cowlark.com/2009-11-15-go/
18:17:19 <Cale> (Algol 68 almost has first class procedures, in that procedures are first class, but there are annoying restrictions on variable scoping which make it so that you can't really get novel functions at runtime.
18:17:23 <mauke> oh hey, did I tell you how much I hate pascal?
18:18:23 <mauke> ... wow. I think I'd actually rather use C++ than Pascal
18:18:34 <cmccann> "Here [ALGOL] is a language so far ahead of its time that it was not only an improvement on its predecessors but also on nearly all its successors."
18:18:49 <cmccann> - Hoare
18:19:11 <aavogt> how do you pronounce Hoare?
18:19:15 <cmccann> think that was about ALGOL 60 though
18:19:26 <tgeeky> whore-ay
18:19:54 <tgeeky> *is how I pronounce Horay, but I also run around saying "Good News, Everyone!" incessantly
18:20:09 <maurer_> aavogt: I've always just pronounced it "whore"
18:20:14 <deech> tgeeky: seriously? I thought it was "Hoe-air"
18:20:27 <kmc> maybe the problem is just that all these early CS people thought that software would be held to a non-trivial quality standard
18:20:28 <tgeeky> deech: Good news, everyone!
18:20:32 <copumpkin> okay, I took a more heavy-handed approach to this epic hack this time
18:20:38 <kmc> and it turns out people will put up with awful buggy code, so that's what they get
18:20:40 <copumpkin> I overwrote a gmp function in memory
18:20:45 <copumpkin> :P
18:20:52 <kmc> :D
18:21:01 <copumpkin> now I just need to cross my fingers that nobody uses thumb
18:21:10 <copumpkin> I think other than that, it should be reasonably safe
18:21:15 <kmc> copumpkin, my former colleagues and i would approve
18:21:23 <Cale> copumpkin: thumb?
18:21:32 <copumpkin> you'd be horrified at the hacks I've been doing here
18:21:32 <copumpkin> Cale: the compact ARM code
18:21:48 <copumpkin> to indicate jumping into thumb code, they add 1 to the address
18:21:56 <copumpkin> so if you jump into an odd address, it switches processor mode
18:22:02 <Cale> copumpkin: Why don't you just rewrite the C library you're binding to a bit?
18:22:04 <kmc> :D
18:22:11 <maurer_> companion_cube: Stop using deprecated and use Thumb2 :P
18:22:14 <copumpkin> Cale: I didn't want to force people to use a custom mpfr
18:22:14 <Cale> Or is that not an option somehow?
18:22:19 <Cale> hum
18:22:19 <maurer_> err, copumpkin
18:22:32 <copumpkin> maurer_: it's deprecated now? :o
18:22:35 <maurer_> Thumb2 is in use in a lot of places, don't know about haskell stuff though
18:22:35 <copumpkin> anyway, I'm not using arm
18:22:41 <maurer_> copumpkin: Thumb is deprecated in favor of Thumb2
18:22:45 <copumpkin> ah, interesting
18:22:49 <maurer_> Which is an expanded version of Thumb and is variable length
18:23:03 <copumpkin> I still support it in my decoder
18:23:03 <copumpkin> yep, I've got a pure haskell decoder for most of the ARM spec :P
18:23:15 <copumpkin> including most of thumb2
18:23:22 <copumpkin> I just didn't know thumb was deprecated
18:23:25 <maurer_> Oh, cool
18:23:30 <maurer_> So, thumb as a whole isn't
18:23:38 <maurer_> You just don't get to make the same assumptions about instructions
18:23:38 <copumpkin> kmc: anyway, I needed to stop someone else from calling this function after me
18:23:43 <copumpkin> so I overwrote it with a nop function
18:23:46 <maurer_> copumpkin: Can you link me to htis?
18:23:47 <maurer_> *this?
18:23:54 <maurer_> A decoder for ARM is of interest to me.
18:24:02 <Eduard_Munteanu> Isn't ARM code, as in non-Thumb, deprecated as well?
18:24:09 <kmc> is it?
18:24:10 <copumpkin> https://github.com/copumpkin/charm it's rather neglected and mid-rewrite right now
18:24:11 <maurer_> https://code.google.com/p/nacl-thumb2/
18:24:12 <copumpkin> but it might work
18:24:16 <kmc> Eduard_Munteanu, link?
18:24:30 <Eduard_Munteanu> I mean, is one supposed to use Thumb2 now?
18:24:31 <maurer_> ARM code is the deprecated one, and using Thumb only doesn't work, so since interworking is deprecated...
18:24:34 <maurer_> Eduard_Munteanu: Yes.
18:24:53 <maurer_> copumpkin: Drop me a PM with a link? I've gotta go in negative one minutes, but am very interested in your stuff.
18:24:58 <maurer_> Oh, you already did
18:24:59 <maurer_> nvm
18:25:05 <copumpkin> :)
18:25:11 <copumpkin> I'd love contributions
18:25:13 <copumpkin> but it's a bit of a mess
18:25:20 <copumpkin> I keep meaning to get back to it but so many other projects :P
18:25:25 <maurer_> copumpkin: See https://code.google.com/p/nacl-thumb2/ for some cool thumb2 stuff
18:25:35 <Eduard_Munteanu> kmc: what maurer_ said, but I'm not sure I remember correctly
18:25:43 <kmc> really, the original ARM encoding is deprecated?
18:25:53 <kmc> ok
18:27:44 <copumpkin> maurer_: it's basically a strongly typed version of the decoders from arm-dis.c
18:27:54 <copumpkin> none of that format string shit
18:28:02 <copumpkin> I have bit parsers that return suitable types
18:28:09 <cmccann> kmc, yknow you would probably hate the code I'm working on right now
18:28:09 <copumpkin> :P
18:28:30 <kmc> oh yeah?
18:28:49 <cmccann> kmc, type hackery, as far as the eye can see
18:28:53 <cmccann> an endless sea of undecidable instances
18:28:55 <copumpkin> now I just need to figure out who the hell is throwing out my constructor function
18:29:03 <copumpkin> it seems ridiculous to throw out a constructor because it's unused
18:29:06 <copumpkin> but that's what's happening
18:29:14 <kmc> put on some more attributes?
18:29:18 <copumpkin> I put used on it
18:29:21 <copumpkin> didn't help
18:31:05 <copumpkin> but basically, if I refer to the function through a foreign import (and convince GHC to include it even though I don't call it)
18:31:13 <copumpkin> when False myFunction
18:31:20 <copumpkin> then the constructor gets called
18:31:22 <copumpkin> otherwise it doesn't
18:31:28 <copumpkin> it seems like a bug in something but I'm not sure what
18:32:11 <copumpkin> cmccann: when you getting here?
18:32:25 <cmccann> midday, lemme check the schedule
18:32:53 <cmccann> few minutes past noon supposedly
18:33:08 <cmccann> not that anything ever lands on time
18:34:01 <kniu> @pl (\x y -> f (g (g z x) y))
18:34:02 <lambdabot> (f .) . g . g z
18:34:10 <kniu> @pl (\x y -> f (g (g (f z) x) y))
18:34:10 <lambdabot> (f .) . g . g (f z)
18:43:22 <parcs> mauke,kmc,Eduard_Munteanu: i'd like to spawn a process created with createProcess while not breaking the child process's readline functionality and while being able to send arbitrary data to its stdin. creating and piping to a separate handle breaks the former, sharing stdin breaks the latter. (sorry for the untimely reply)
18:44:23 <mauke> pseudo-terminal, manual proxying
18:44:33 <parcs> sounds complex
18:44:37 <mauke> yes
18:45:17 <parcs> i just wanna write to stdin :(
18:46:42 <mauke> sounds more like you want to write to the child's terminal
18:48:38 <kmc> the answer is ptys
18:48:42 <kmc> (now you have two problems)
18:52:14 <rwbarton> "have you tried writing your program in expect"
18:53:26 <rwbarton> actually an expect EDSL in Haskell might not be a bad idea
18:53:31 <elliott> http://hackage.haskell.org/package/libexpect
18:55:44 <parcs> looks like stdin being readonly is a unix thing or whatever
18:56:23 <kmc> so you want the child to take interactive readline input as usual, but you also want to send it data from the parent?
18:57:29 <parcs> yes. i'm just creating a thin wrapper over a process and adding some extra automated functionality
18:57:52 <kmc> interesting
18:58:13 <rwbarton> expect is good at doing this kind of thing; what sort of automated functionality are you trying to add?
18:58:40 <rwbarton> (disclaimer: I have used expect for all of about 10 minutes, but it solved my similar problem)
19:00:10 <parcs> i'm creating a wrapper over ghci that automatically calls :reload whenever a file in the current directory has changed
19:00:49 <cwl> In RWH, rule for MonadPlus, An instance must short-circuit if mzero appears on the right of a sequence expression: v >> == zero
19:01:14 <cwl> is there any typo?
19:01:22 <cwl> v >> == zero
19:01:49 <kmc> i would expect "v >> mzero == mzero"
19:02:14 <kmc> parcs, ah; did you consider modifying ghci instead?
19:02:15 * ski would expect s/==/=/
19:02:21 <parcs> kmc: yes
19:03:02 <applicative> then modifying any file will also wreck all the bindings I've made inside ghci?
19:03:06 <parcs> i studied the source for 30 mins and i think it would require a large refactoring to implement this
19:03:30 <kmc> :/
19:03:33 <m3ga> i use -Werror for a project. is there a LANGUAGE or OPTIONS pragma i can add to a single file that turns of -Werror for that file?
19:03:39 <kmc> maybe the refactoring is worth it, though
19:04:03 <elliott> m3ga: -Wwarn
19:04:09 <elliott> in OPTIONS_GHC
19:04:16 <m3ga> thanks elliott!
19:04:25 <kmc> heh, that's a counter-intuitive name
19:04:37 <elliott> fwiw, it's right after -Werror in the manpage
19:07:05 <rwbarton> parcs: fwiw, I believe an expect/tcl guru could solve this problem in a matter of minutes, as long as you don't expect too much in tricky situations such as when the user has a partially-entered line and a file changes
19:07:26 <rwbarton> I also think that writing this wrapper from scratch is going to be quite painful
19:12:56 <zzo38> When typing ":module GHC" into GHCi, I get the error message "It is a member of the hidden package `ghc-7.0.3'." Do you know what is wrong?
19:14:29 <kmc> yeah, the GHC API is hidden by default
19:14:33 <kmc> because it pollutes the namespace
19:14:36 <kmc> try "ghci -package ghc"
19:14:42 <parcs> great, the libexpect bindings segfault :P
19:15:09 <kmc> zzo38, ^^
19:15:27 <kmc> zzo38, you should probably wait for an answer in one or the other channel before you spam both #haskell and #ghc
19:17:32 * cmccann can't tell if the GHC API pollutes the namespace, or the rest of the namespace pollutes the GHC API's names
19:18:43 <Cale> Yeah, GHC needs some module reorganisation.
19:19:20 <kmc> but hierarchical modules aren't Haskell 98!
19:19:49 <Cale> Well, there was that addendum :)
19:19:59 <Cale> and GHC isn't written in Haskell 98 anyway :P
19:20:57 * cmccann is a bit scared by GHC's code
19:22:17 <elliott> ghc is written in ghc haskell as defined by ghc
19:22:30 <elliott> to understand ghc haskell read the ghc source (written in ghc haskell)
19:24:26 <cwl> @src show
19:24:26 <lambdabot> show x = shows x ""
19:24:34 <cwl> @src shows
19:24:34 <lambdabot> Source not found. Take a stress pill and think things over.
19:26:36 <ion> shows = (++) . show  -- i think
19:26:59 <ski> nicely circular
19:29:41 <edwardk> @tell nominolo old bit rotted code would be fine. i just want to poke at the approach a bit. needn't even be haskell
19:29:41 <lambdabot> Consider it noted.
19:29:56 * cmccann figures he should probably finish packing, given that he needs to be at the airport at stupid o' clock tomorrow morning
19:30:48 <edwardk> heh
19:30:51 <edwardk> what time do you land?
19:31:12 <cmccann> noon, give or take
19:31:23 <cmccann> assuming things are implausibly punctual at any rate
19:33:27 <edwardk> nice
19:33:28 <edwardk> i would recommend renting a car (and getting the money back from matt) we have (the remnants of) a hurricane coming
19:33:45 <edwardk> you won't want to be trying to get by without one
19:34:02 <cmccann> so I've heard and yes I will be
19:34:17 <edwardk> i can probably drudge up and loan you a gps if i can find the cables, or just get one at the rental office
19:34:31 <edwardk> the other factor is getting around boston without a gps is a nightmare ;)
19:34:39 <kmc> driving around boston is a nightmare
19:34:58 <edwardk> what hotel did you wind up at?
19:35:48 <edwardk> oh keegan, if you're up for it, a bunch of us were thinking of converging on cambridge brewing company to say hi to cmccann
19:35:55 <cmccann> don't recall off the top of my head, but was one of the ones matt suggested
19:36:06 <kmc> edwardk, cool, poke me on irc before you go?
19:36:11 <copumpkin> cmc and kmc!
19:36:23 <kmc> cmccann, what brings you to Bostonia?
19:36:54 <edwardk> i'm trying to get him to move to civilization =P
19:37:09 <cmccann> yes
19:37:26 <cmccann> and has been quite helpful toward that goal :]
19:38:13 <edwardk> did you ever read ender's shadow?
19:38:18 * cmccann tries to figure out just how little baggage you're allowed on a flight these days
19:38:23 <kmc> no
19:38:59 <edwardk> ah, well, orson scott card (before i stopped reading his random mormon ravings) wrote a second set of sequels to ender's game, focused on life on earth after the big alien war
19:39:28 <cmccann> when you're a one-hit wonder might as well run it into the ground eh
19:39:29 <edwardk> and in it, you had all these students returning to their home countries after 'battle school', and a lot of politics as folks tried to snatch them up
19:39:49 <edwardk> because they were the key to winning the wars, etc.
19:40:11 <edwardk> I always get a chuckle when trying to gather up haskellers, because it feels much the same.
19:40:42 <edwardk> You have little pockets of them here, over at Galois, at Standard Chartered, Credit Suisse, BlueSpec, etc.
19:40:52 <cmccann> translation, edwardk is assembling an army to support his plans for world conquest
19:40:58 <edwardk> that too
19:42:40 <Cale> ahahaha
19:42:46 <edwardk> Well it just strikes me as interesting to see what it takes to reach critical mass such that it becomes easier to continue to accrete people.
19:42:47 <Cale> I like that analogy
19:43:40 <edwardk> Cale is the crazy Canadian battle schooler who stays clear of the wars, because he objects to worldly concepts like money and power.
19:43:48 <cmccann> haha
19:45:20 <copumpkin> edwardk: did you ever get any word back from sam?
19:46:03 <edwardk> yeah he popped up a half hour ago, had been on a week long backpacking trip
19:46:24 <copumpkin> lol
19:46:50 <edwardk> Now I need to get Duncan to follow up with Carol's assistant at google to get him marked as passed, and do the appropriate groveling.
19:48:59 <copumpkin> man, all this low-level hackery I've been doing makes me long for my low-level projects again
19:49:04 <edwardk> heh
19:49:09 <copumpkin> maybe I'll shelve agda for a while and work on some of those
19:49:26 <edwardk> you know you want to hack on my jit or something ;)
19:49:32 <kmc> copumpkin, you should write a certified compiler in agda!
19:49:33 <copumpkin> lol
19:49:38 <edwardk> … in agda
19:49:40 <kmc> certified / certifying
19:49:45 <copumpkin> kmc: that emits assembly?
19:49:49 <kmc> sure
19:49:52 <edwardk> dependently typed assembly
19:50:09 <kmc> such things exist in coq
19:50:15 <edwardk> yes
19:50:22 <edwardk> but they are awkward to target
19:50:39 <edwardk> i actually spent quite a bit of time playing with dtal, and talx86, etc.
19:51:30 <kmc> cool
19:51:36 <kmc> i only read some of the papers
19:54:22 <roconnor> birings are awesome!
20:03:51 * cmccann pushes more egregious type hackery to github, hooray
20:05:54 <joe6> kmc, do you know if it is possible to define 2 global variables of the same size at the same memory location in C?
20:07:03 <joe6> kmc, I have 2 variables such as: http://codepad.org/ybVF6922 , and I want them to be at the same memory location.
20:07:21 <joe6> so, I can access the same data using either type.
20:07:36 <copumpkin> make it a union?
20:07:53 <copumpkin> union { type1 x; type2 y; } myvar;
20:08:03 <copumpkin> myvar.x would treat it as a type1
20:08:08 <copumpkin> myvar.y would treat it as a type2
20:08:09 <joe6> but, then I cannot do: EP0INBUFFER = 0;
20:08:25 <joe6> copumpkin: hold on, I will put more samples.
20:08:57 <mgsloan> #define myvar.x EP0INBUFFER
20:09:14 <mgsloan> err other way around
20:09:20 <mgsloan> (blasted typedefs)
20:09:35 <Cale> joe6: You know this is #haskell, right? (Just checking!)
20:09:55 <Cale> But yeah, why doesn't a union work?
20:10:14 <Cale> You use whatever.x to refer to it as one type, and whatever.y to refer to it as the other.
20:10:56 <joe6> full header file: http://codepad.org/0RNcGM8S, and this is the piece I am concerned about: http://codepad.org/0LQEjcWT. The linker defines both SR and SRbits at the same location, thus giving them same memory location.
20:11:08 <joe6> But, with haskell ffi I am not sure how I can acheive that.
20:11:22 <joe6> mgsloan: that is a brilliant idea.
20:12:03 <joe6> mpsloan, I think that will work. thanks.
20:12:26 <joe6> Cale, I am testing some embedded C code on a pc using haskell ffi.
20:12:44 <joe6> the C code has a bunch of memory locations defined as C structs / global variables.
20:12:54 <elliott> mgsloan: that is surely not valid
20:12:59 <elliott> . is not a valid part of a cpp identifier is it???
20:13:08 <elliott> oh
20:13:09 <elliott> other way around
20:13:09 <elliott> ok
20:13:29 <mgsloan> welcome! (not that I really came up with much :P)
20:13:55 <joe6> Cale, I am trying to test that C code from Haskell FFI trying to use the same header files as on that device (as much as possible).
20:14:37 <joe6> mgsloan: simple idea, but something that I have been struggling on how to do for the past day or so..
20:14:45 <mgsloan> yeah, I never did know why typedefs are so unintuitively ordered.  Maybe the due to difficulty of tokenizing types in cpp?
20:14:51 <joe6> mgsloan: genius lies in its' simplicity.
20:15:03 <Cale> All declarations in C are unintuitively ordered.
20:15:48 <elliott> mgsloan: declaration follows use type of thing isn't it? it's the same syntax as declaring a variable of that type
20:16:03 <elliott> there's things like typedef (*foo)(...); after all
20:16:08 <mgsloan> joe6: same could be said of Haskell :D
20:16:45 <mgsloan> elliott - ahh, I guess the problem is I think of them as type synonyms.  That does make sense, though
20:17:04 <joe6> yes, it is a type synonym.
20:17:46 <Cale> also, why give a name to the struct type as well as the typedef of it?
20:18:06 <Cale> seems awkward
20:18:26 <elliott> consistency for recursive structures?
20:18:52 <joe6> Cale, have no idea. It is a template header file.
20:19:08 <Cale> joe6: I just mean about the language in general
20:19:11 <zzo38> How can I tell the -ddump-parsed to use nonlayout mode, since the input is in nonlayout mode?
20:19:40 <Cale> The way that C gives you two ways to name structs.
20:20:38 <zzo38> There is CWEB to put all the codes in the order you want and it can compile in a different order, in addition to doing other things such as indexing
20:21:02 <Cale> zzo38: I'd be careful with doing anything to the prettyprinted output of GHC. The prettyprinter has some annoying bugs which make the code invalid sometimes.
20:21:47 <Cale> (for example, it'll de-parenthesise infix type variables where they occur as parameters to type constructors)
20:21:57 <zzo38> Cale: I am actually only looking at it so that I can understand, although I would like to know if the prettyprinter supports nonlayout mode
20:22:03 <edwardk> cale: well, c++ regularized it a bit, so its kinda silly to put the typedef on now, but it used to be a namespacing thing
20:22:06 <Cale> I'm not sure
20:22:20 <Cale> edwardk: hmm
20:22:41 <edwardk> since at the time you had both the main namespace and the struct namespace
20:23:37 <edwardk> mix in a thinko or two in the early lead up to standard K&R syntax and wham
20:24:36 <copumpkin> how can I ask ghc to not say "Defined but not used" for a single function?
20:25:06 <zzo38> When using a constructor with fields, is it allowed to omit some fields?
20:25:43 <Cale> zzo38: It is, though it's dangerous
20:25:57 <Cale> zzo38: The remainder of the fields get defined by errors.
20:26:02 <zzo38> Cale: And what happens if you do? Is it "undefined"?
20:26:30 <Cale> It's "undefined" in the Haskell sense of that term, not the C sense :)
20:26:49 <Cale> That is, if you use one of the fields, your program dies with an error message.
20:27:10 <maurer_> copumpkin: Append the variable name with a _ ? (or maybe that was ocaml)
20:27:25 <zzo38> Cale: Yes, I did mean the Haskell sense
20:27:41 <copumpkin>     Warning: Defined but not used: `mpfrNoop_'
20:27:46 <copumpkin> :P
20:27:59 <edwardk> prefixing it will silence it about that warning
20:28:11 <edwardk> but it won't help copumpkin's usecase
20:28:18 <copumpkin> why not?
20:28:21 <edwardk> since he is concerned about the linker leaving it off
20:28:22 <edwardk> no?
20:28:27 <copumpkin> oh no, I figured that out
20:28:28 <Cale> It's actually something more like  error "{info about line number and source file}: uninitialised record field" or something like that
20:28:30 <copumpkin> it was leaving out the whole alloc module
20:28:35 <copumpkin> this convinces it to include it :P
20:28:41 <edwardk> ah
20:28:49 <edwardk> so _foo :: Whatever >
20:28:50 <edwardk> ?
20:30:32 <copumpkin> yep, that worked :)
20:30:43 <copumpkin> now we have a ghci issue
20:31:11 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/5435
20:31:29 <edwardk> doh
20:31:32 <edwardk> pseq ;)
20:31:50 <edwardk> _foo `pseq` ?
20:32:15 <zzo38> Is there an extension that allows default values for omitted fields?
20:32:56 <edwardk> zzo38: no, but you can always make a 'smart constructor' which has the same name (though lower case) as the constructor with the defaults filled in
20:34:42 <zzo38> edwardk: OK.
20:36:54 <copumpkin> @hoogle pseq
20:36:55 <lambdabot> Control.Parallel pseq :: a -> b -> b
20:37:52 <joe6> mgsloan: is this what you had in mind? http://codepad.org/2tUrKot3, http://codepad.org/iyEN6Q45, and I compile them as: http://codepad.org/b7IPIP1Y and this is what ghci says about it: http://codepad.org/CcR0BkQ3
20:38:03 <joe6> kmc, any thoughts, please?
20:40:11 <copumpkin> edwardk: okay, it's pushed
20:40:26 <copumpkin> edwardk: no clue if it'll actually fix the pi issue, but it definitely doesn't on ghi
20:40:27 <copumpkin> ghci
20:40:35 <edwardk> doh
20:40:35 <copumpkin> and I'm unable to replicate the pi issue on a test program
20:40:40 <copumpkin> I can't get the GC to fire to break it
20:40:47 <edwardk> have you manually called performGC?
20:40:48 <copumpkin> I left the primitive there for you to pseq at will :P
20:40:50 <copumpkin> yeah
20:40:51 <edwardk> that worked for me to cause it die
20:40:56 <edwardk> hrmm
20:41:10 <copumpkin> _initGlobal# :: Int# -> Int#
20:41:19 <copumpkin> that's what you need to wrap in an action and make happen at least once
20:41:30 <edwardk> so in ghci it just doesnt get called?
20:41:41 <copumpkin> yeah, no constructors fire I guess
20:41:50 <copumpkin> the gmp one fires because ghc gets loaded by the OS
20:42:22 <zzo38> How can I insert stuff between the lexer and the parser, and between the renamer and the typechecker?
20:42:40 <Cale> http://www.secrettechnology.com/six/wocu1.html -- omgwhatisthisidon'teven
20:42:44 <edwardk> so if i make some lazy Int and passed that fixCaches = I# (_initGlobal# 0#)      -- then use something like pi = fixCaches `pseq` constant mpfrPi#
20:42:54 <copumpkin> yeah
20:42:57 <copumpkin> I think that should do it
20:43:26 <copumpkin> I make no guarantees that my fucked-up allocator actually fixes the issue :P
20:43:32 <copumpkin> but it seems like it should
20:43:33 <edwardk> hahahahaha
20:43:36 <edwardk> fair nuff
20:43:44 <copumpkin> it'd be funny if after all this nastiness, it didn't
20:44:02 <copumpkin> all it does is check three levels up in the stack to see if any of the callers were mpfr_cache
20:44:48 <edwardk> sounds plausible.
20:45:01 <edwardk> now all you need to do is benchmark gmp with those changes ;)
20:45:14 <copumpkin> I just hope it never decides to return any of those cached mpfr objects to us directly
20:45:18 <copumpkin> if it did, we'd crash and burn
20:45:25 <copumpkin> but I'd expect it not to as they're mutable
20:45:29 <copumpkin> and it can't assume we won't change them
20:46:05 <edwardk> yeah
20:48:13 <edwardk> trying to package up this last raft of trifecta changes
20:48:25 <copumpkin> sure, no rush
20:48:35 <copumpkin> let me know if it fails miserably and I'll take a closer look :P
20:48:51 <copumpkin> this kind of shit makes me wish we had ACIO
20:50:08 <edwardk> worst case i just make some horrible IO hook you have to run first
20:52:47 <copumpkin> if these allocators of mine work, then we just need GHCI to respect constructors and/or a way to tell integer-gmp to stop setting the functions
20:54:13 <edwardk> i'll probably just accept the pseq solution for now
20:54:19 <edwardk> then we can make it faster later
20:54:29 <copumpkin> ok
20:54:40 <edwardk> correctness, then speed
20:54:48 <copumpkin> still assuming the allocators do the right thing :P
20:54:51 <edwardk> yeah
20:55:23 <copumpkin> actually, the pseq might not be enough in the version I sent you
20:55:23 <copumpkin> I took out everything but the setter of allocators in there
20:55:26 <copumpkin> to minimize overhead
20:55:36 <copumpkin> but I need to (at least once) set the mpfr_cache boundaries too
20:55:46 <edwardk> hrmm
20:55:52 <parcs> > maximum []
20:55:53 <lambdabot>   *Exception: Prelude.maximum: empty list
20:55:55 <copumpkin> and that's a little slow
20:55:56 <edwardk> to flush them?
20:56:05 <copumpkin> nah, I determine where the function "ends"
20:56:11 <copumpkin> under a couple of assumptions
20:56:31 <copumpkin> and then on every allocation check that the caller is between the start and end of the function
20:56:51 <edwardk> eep
20:57:01 <copumpkin> :P
20:57:23 <Jafet> Using the stack return pointer, eh
20:57:30 <Jafet> instance PrimMonad m => Frob (MVector (PrimState m) Word64) -- "Illegal type synonym family application in instance"
20:57:46 <Jafet> How do I recant?
20:58:18 <Saizan>  instance (PrimMonad, PrimState m ~ s) => Frob (MVector s ..
20:58:32 <Saizan> maybe
20:59:42 <copumpkin> edwardk: pushed a version that does that stuff too
20:59:57 <Jafet> Oh, so I need TypeFamilies to use type families.
21:00:05 <edwardk> sweet
21:00:22 <edwardk> yo dawg, i heard you like type families
21:01:35 <Jafet> It seems that I also like undecidable instances
21:02:13 <copumpkin> lol
21:02:20 <copumpkin> dammit, it still fails in ghci
21:03:13 <edwardk> doh
21:03:16 <edwardk> odd
21:03:40 <Jafet> Since PrimMonad has two instances, I might just put those two instances in my instances
21:03:43 <parcs> :t find
21:03:44 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
21:04:03 <Jafet> edwardk: yo dawg
21:07:26 * hackagebot reducers 0.1.6 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-0.1.6 (EdwardKmett)
21:07:28 * hackagebot vty-ui 1.2 - An interactive terminal user interface library  for Vty  http://hackage.haskell.org/package/vty-ui-1.2 (JonathanDaugherty)
21:11:07 <Jafet> It seems that I need UndecidableInstances for ST, anyway.
21:12:06 <Veinor> hmm
21:12:07 <zzo38> Is it possible to use the GHC API to first tokenize the input file and then do something with it and then parse it?
21:12:16 <Veinor> "Next release: July 2011
21:12:33 <zzo38> Can I use it to put stuff between the renamer and the typechecker?
21:12:39 <edwardk> veinor: that would be the hazard of predicting the future. ;)
21:12:47 <edwardk> Veinor: eyeballing the platform?
21:13:06 <Veinor> yeah.
21:13:13 <Jafet> zzo38, you want to do something that can't be done in template haskell?
21:13:21 <Veinor> just set up yet another virtual machine and i might use this as an excuse to get back into haskelling.
21:13:23 <edwardk> i think the plan is currently to push it out after 7.4.1 soon
21:13:38 <edwardk> so you have a couple months before a new platform at least
21:14:05 <edwardk> so just grab the current one its pretty stable
21:14:07 <zzo38> Jafet: Yes, various things
21:14:26 <Veinor> i'm trying to decide whether go with the current one or install ghc 7.2.1
21:14:29 <zzo38> Although some of the things I want to do can be done in Template Haskell, so I can use Template Haskell as well.
21:14:35 <Jafet> Well, Language.Haskell is a tarpit
21:15:35 <gienah> ghc-mtl and hint do not compile with ghc 7.2.1 (due to ghc API changes) which breaks anything that depends on them like snap
21:15:41 <edwardk> Veinor: 7.2.1 is a bit hit or miss. most stuff compiles now
21:16:00 <zzo38> I can find typecheckModule but it does renaming and typechecking together. I want to get the output of renaming and manipulate it before sending it to the typechecker
21:16:12 <gienah> yes most other stuff that does not need hint compiles with ghc 7.2.1
21:16:23 <edwardk> odd that snap depends on the legacy ghc-mtl library
21:16:53 <copumpkin> edwardk: I'm calling it a day :P this shit makes no sense and I'm tired of sifting through crashes
21:16:55 <gienah> snap-core and snap-server build fine with ghc 7.2.1, its just snap that seems to want hint which wants ghc-mtl
21:17:04 <edwardk> copumpkin: go sleep it off ;)
21:17:13 <zzo38> I also cannot find the command to make the tokens and then do stuff with the tokens before sending it to the parser.
21:17:14 <edwardk> ah
21:18:03 <zzo38> How can I do these things??????
21:20:22 <Jafet> You might want to wait until someone who knows the GHC API comes along
21:26:45 <zzo38> There is GHC plugins, but those do Core to Core translations. I want to do tokens to tokens and renamed module to renamed module.
21:28:14 <copumpkin> zzo38: I don't think you can do that
21:28:28 <copumpkin> you can specify custom preprocessors
21:28:32 <copumpkin> but that's just textual
21:28:58 <copumpkin> edwardk: I was wondering something about parsers
21:29:12 <edwardk> copumpkin: ?
21:29:16 <zzo38> copumpkin: Is the GHC API incomplete?
21:29:30 <copumpkin> zzo38: GHC simply doesn't let you jump in everywhere you could possibly imagine :P
21:29:33 <copumpkin> they deal with the common cases
21:29:39 <copumpkin> so yes, it's incomplete, as all software is incomplete
21:29:55 <copumpkin> edwardk: say you'd defined the c grammar
21:29:59 <copumpkin> and I wanted to wrap objective C around it
21:30:03 <copumpkin> or reuse most of it for C++
21:30:19 <edwardk> you probably would have a hard time
21:30:22 <zzo38> Can they make suggestion of GHC API to add some things?
21:30:26 <copumpkin> or you'd defined an expression language and I wanted to add _ deep down in it and keep the rest the same, to make a pattern language
21:30:37 <copumpkin> has anyone done any work on grammar "paths" and "diffs"
21:30:44 <edwardk> parser's a la carte ;)
21:30:49 <copumpkin> that would let you reuse parts of other people's grammars
21:30:51 <edwardk> er parsers
21:30:54 <copumpkin> possibly injecting stuff fairly deeply
21:30:56 <copumpkin> yeah
21:31:03 <copumpkin> I was wondering what a decent API for that would even look like
21:31:26 <copumpkin> it seems like a lot of the c-like languages could be reduced to some simple combinators on top of a base grammar
21:31:41 <edwardk> thats the kind of thing where the scheme untyped guys have it a lot easier than we do
21:31:46 <copumpkin> :)
21:31:54 <edwardk> iirc kent dybvig teaches a compiler course that way
21:32:01 <copumpkin> ah
21:32:10 <edwardk> lots of little passes that tweak the language slightly then pass it along
21:32:27 <zzo38> Can the tokens and renamed stuff be accessed outside of the Ghc monad, even if they cannot be accessed using it?
21:32:58 <edwardk> i only recall because i spent a lot of time talking to dan friedman when he was going to teach it last year trying to see if we could adapt the course to use the shiny scheme monad combinators we put together
21:33:08 <copumpkin> zzo38: I doubt they can be accessed at all, short of retokenizing the source using their lexer. What are you trying to do?
21:34:08 <Jafet> Sanity check; is ByteString.Lazy random access time O(size/blocksize)?
21:35:00 <edwardk> yes
21:35:15 <edwardk> to do better you can use a fingertree of bytestrings
21:35:26 <zzo38> Actually I think I found that lexTokenStream would tokenize the input.
21:35:33 <edwardk> but you lose infinitely long bytestrings
21:35:35 <Jafet> Or I could use someone else's use of a fingertree of bytestrings; is this already done?
21:35:44 <edwardk> yes, i have a couple
21:36:03 <Jafet> On a tangent, I wonder if you could adapt fingertrees into an infinite sequence
21:36:11 <Jafet> Leave one finger for the "rest of the sequence"
21:36:20 <edwardk> http://hackage.haskell.org/packages/archive/rope/0.6.1.1/doc/html/Data-Rope.html is fairly ancient
21:36:26 <zzo38> copumpkin: I want to implement some extensions to Haskell, such as more-notation, rulebook programming, and a few other things.
21:36:29 <edwardk> there is a version in trifecta but it supports extra stuff
21:36:53 <copumpkin> zzo38: that's going to take some fairly heavy GHC hacking, not just GHC API stuff
21:37:04 <edwardk> jafet: it isn't easy. what i was able to do was use a random access cons-list for the infinite tail then peel off a fingertree as the prefix
21:37:24 <edwardk> jafet: but i wasn't able to concoct a nice benchmark where it helped
21:37:26 <Jafet> Yeah. That's why I hope someone like you has done it
21:37:42 <zzo38> copumpkin: OK, so how is it done?
21:37:55 <copumpkin> zzo38: you learn how GHC works, figure out what needs changing, and change it
21:38:21 <edwardk> zzo38: what you want to do is hard
21:38:31 <copumpkin> :P
21:38:31 <copumpkin> it'll probably involve changing the lexer, parser, at the very least :)
21:38:49 <copumpkin> then you could translate that to other haskell as a parser post-processing step, but that wouldn't give you good error messages
21:38:57 <copumpkin> so you'd probably want to make more of GHC aware of what you did
21:40:16 <Saizan> i'd try to fit this as a quasiquoter first
21:41:48 <zzo38> copumpkin: Doing it that way could work too, changing the parser, renamer, and typechecker.
21:41:57 <copumpkin> zzo38: anyway, it won't be easy
21:42:00 <copumpkin> GHC is a big project
21:42:03 <copumpkin> it's got a lot of parts
21:42:07 <copumpkin> and takes ages to compile
21:42:35 <zzo38> copumpkin: That is why I do not want to recompile it. (Actually there is other reason too)
21:44:12 <zzo38> But I do have a few ideas about how to do it from the lexer output and from the renamer output
21:44:24 <zzo38> So if I can somehow use this, it would help
21:44:32 <Jafet> Have you already implemented this without using the GHC API?
21:44:56 <sohum> @pl \x -> if' x y z
21:44:56 <lambdabot> flip (flip if' y) z
21:44:58 <zzo38> No.
21:45:18 <Jafet> Better do what Saizan said then; embed it in TH first
21:45:29 <Jafet> Then you have a concrete idea of what to change
21:46:00 <zzo38> TH doesn't do the all the things I am trying to do!
21:46:42 <copumpkin> zzo38: then write a preprocessor
21:46:46 <copumpkin> people often do that
21:46:51 <Jafet> Embed them until it does!
21:47:00 <Jafet> It'll be uglier, but it has the advantage of working.
21:48:27 <zzo38> copumpkin: The preprocessor is too early. It needs to work with the parsed code (such as the HsSyn code).
21:48:37 <copumpkin> why?
21:48:57 <copumpkin> if you need it parsed, you use haskell-src-exts
21:49:07 <copumpkin> but then you can't implement language syntax extensions
21:49:13 <Jafet> Or write the preprocessor as a TH macro, and quote the code you want preprocessed
21:50:03 <zzo38> copumpkin: Yes, see! I need to work with it both before and after parsing.
21:50:31 <copumpkin> then pick a simple preprocessor syntax that you can translate easily to haskell first
21:50:40 <lewis1711> why is it an error to use the pattern "dropLastElement (xs++x) = xs" ?
21:50:42 <copumpkin> then ask haskell-src-exts (or even the GHC API) to parse it for you
21:50:56 <Jafet> lewis1711: because it isn't a pattern
21:51:03 <Saizan> lewis1711: (++) is not a constructor
21:51:23 <zzo38> Jafet: I did think of that; just quote the entire module. But there are some things that TH won't do, I think.
21:51:31 <lewis1711> as in you can't build a list from elements with ++, where as you can with cons?
21:51:51 <copumpkin> lewis1711: how would you work with the pattern f (x+y) = ...
21:51:57 <copumpkin> if you called it on f 5
21:52:10 <lewis1711> good point
21:52:30 <copumpkin> you can call init and last
21:52:33 <copumpkin> or use a view pattern
21:52:36 <Jafet> copumpkin: f (x+1)!
21:52:41 <copumpkin> :P
21:53:07 <edwardk> zzo38: what do you need to do that is beyond the scope of TH?
21:53:08 <zzo38> I don't mind working in nonlayout mode (in fact I prefer nonlayout mode), but some programs will want layout mode and it would need to be tokenized properly and that kind of stuff, I need to adjust some tokens after it does that so that the parser can work.
21:53:30 <Jafet> {-# LANGUAGE ViewPatterns #-} dropLastElement (init -> xs) = xs
21:54:01 <copumpkin> or you could just write
21:54:04 <copumpkin> dropLastElement = init
21:54:06 <Jafet> Which is a pretty long-winded way to write dropLastElement = init
21:54:07 <copumpkin> :P
21:54:14 <lewis1711> yeah that's what I went with
21:54:29 <zzo38> edwardk: Well, I just know that some things are missing from TH, for one thing. But there is another thing, which is that more-notation requires syntax extensions as well as processing the stuff after parsed.
21:54:43 <lewis1711> just some arbitrary hw question i don't quite get the point of. but at least i learned about the constructor thing
21:55:07 <zzo38> TH will make up errors if I try to do some of these things, not only parse errors, but other errors such as duplicate definition errors
21:55:17 <Jafet> Presumably you're meant to do it by pattern-matching on the list constructors, not by noticing that it's called init, lewis
21:55:38 <edwardk> zzo38: well, backing down from the parser being the vehicle by which you are building stuff, what is it that you want to build? e.g. can you get away with a much lighter weight tool to get you most of the way to your goal?
21:55:59 <Jafet> The list constructors are [] and (:) (or the shorthand [_,_,...])
21:56:03 <edwardk> zzo38: this is an awfully big set of problems to tackle, it is worth while to take stock and see if it is even a fight you need to fight
21:56:11 <Jafet> Those are the only things that can appear in patterns
21:56:20 <zzo38> edwardk: Partially, but not much. I can explain things I try to do.
21:57:12 <zzo38> For example, it should be able to parse this:    data T = ZeroT | more T deriving (Eq); T = Two | Three | Four; T = One | Two;
21:57:35 <copumpkin> more T?
21:57:39 <zzo38> Or even with numbers before the more-declarations:   1 T = First; 2 T = second;
21:57:45 <copumpkin> wat
21:58:22 <Jafet> Fascinating
21:58:45 <edwardk> zzo38: but what for?
21:58:54 <copumpkin> I don't even understand what that means
21:59:05 <_Ray_> did you mean More T?
21:59:18 <zzo38> It is my idea of more-notation. It is allowed in various contexts, including data type declarations but also do blocks, case blocks, and so on. Follow "more" by a capitalized name (that does not interfere with the names of any constructors), and then optional parameters (to rebind scopes of names).
21:59:25 <edwardk> zzo38: i'm trying to drill down to figure out your ultimate goal
21:59:26 <zzo38> _Ray_: No, I do mean it lowercased.
21:59:54 <edwardk> ah some kind of language research project
21:59:58 <edwardk> sounds messy
22:00:06 <zzo38> In the example I gave, it would ultimately become:   data T = ZeroT | One | Two | Three | Four deriving (Eq);
22:00:11 <copumpkin> it seems something you want to implement in a toy language first
22:00:18 <edwardk> yes
22:00:19 <copumpkin> with not much other than the type declarations
22:00:25 <Jafet> Like SML?
22:00:27 <copumpkin> to make sure you can even implement the semantics for it
22:00:32 <Jafet> (badum ching)
22:00:34 <copumpkin> and then apply it to a real compiler/language
22:00:41 <edwardk> do something small, implement your desired feature, and make sure its sound and useful in the small
22:00:49 <edwardk> then scale it up and try it out on a bigger language
22:00:52 <copumpkin> zzo38: what's the use case?
22:01:00 <lewis1711> does that "deriving" thing figure out how to compare that type automagically? that's pretty swish
22:01:56 <edwardk> otherwise you'll spend months in hell trying to work through irrelevant details when you go to make the smallest change
22:01:56 <zzo38> The more-notation is for more than just type constructors; it is also for do blocks and case blocks, and fields. In case blocks, it would automatically arrange them in order of specificness.
22:01:56 <copumpkin> zzo38: how about incomparable specificness?
22:01:56 <edwardk> lewis1711: there are a few types that have some built-in magic in the compiler to generate them
22:02:08 <copumpkin> zzo38: do you intend that to only work within a compilation unit?
22:02:24 <zzo38> copumpkin: Then it results in arbitrary order that you cannot depend on, but it hopefully won't matter.
22:02:37 <zzo38> copumpkin: Yes, I do intend to only work within a compilation unit.
22:03:21 <zzo38> (You might still want include files; there is the C preprocessor but that is not very suitable for Haskell so a better one could still be made, which is one of my other idea)
22:03:28 <Veinor> hm. is installing haskell-platform from a package manager a good idea or will i lose hard?
22:04:45 <zzo38> Another example with do-notation to explain better what I am trying to do, too:   main = do { x <- return 21; more X x; print x; }; X a = a <- return (a * 2);    results in output 42
22:05:48 <zzo38> Now would you know what kind of things I would need to do to make it work better?
22:05:52 <Jafet> Veinor: http://www.vex.net/~trebla/haskell/sicp.xhtml
22:06:24 <Jafet> Basically: you will, unless you never upgrade it, or (apocryphal) your package manager is emerge
22:07:06 <copumpkin> zzo38: how is more X any different from a function?
22:07:16 <copumpkin> oh I guess it binds
22:07:22 <edwardk> zzo38: you have a host of syntactic ambiguity there
22:07:43 <_Ray_> haskell-platform was broken for quite a while in ubuntu
22:07:44 <edwardk> zzo38: X a = …  looks like a destructuring assignment
22:08:26 <zzo38> And please pay attention to things like this:   x y = y * y; main = do { x <- return 21; more X x; print x; }; X a = a <- return (x a);   which output 441
22:08:27 <Jafet> Many things get broken for quite a while in ubuntu
22:08:36 <edwardk> copumpkin: yes but in the case where it doesn't. e.g. he wants to ignore the result of returning, it becomes completely ambiguous
22:08:45 <copumpkin> yeah
22:09:05 <zzo38> edwardk: I know; it does mean that in all more-notation, you are not allowed to have contructors with the same name as names put after "more"
22:09:31 <zzo38> That is how it knows the difference.
22:09:59 <edwardk> zzo38: but more importantly the parse changes meaning depending on whether or not you have more blocks above (or below?) something.
22:10:44 <edwardk> since in one case or the other that funny not-quite-a-block you put in your X a = … syntax may or may not parse that is pretty awkward
22:11:20 <Jafet> .oO(@more@ reminds me of the curious tendency in C++ to endow the same keyword with several dubiously-related meanings and contexts.)
22:11:41 <edwardk> jafet: yeah
22:11:43 <Jafet> From what I can gather, zzo wants to use it as a terse macro facility.
22:12:02 <edwardk> if you want macros, just go add scheme-style macros ;)
22:12:09 <zzo38> Jafet: That is similar to what I am doing. Not exactly, though.
22:12:10 <edwardk> syntax-rules FTW ;)
22:12:50 <edwardk> they are tricky though, since they interact oddly with fixities
22:13:26 <Jafet> You could remove all infix operators before using macrosr
22:13:28 <lewis1711> Jafet: I think "static" should be banned as a keyword in all C-likes now
22:13:38 <Jafet> Then it would be scheme reloaded
22:14:00 <edwardk> well, one thing a macro should be able to define is a fixity.
22:14:05 <edwardk> and one should be able to have infix macros
22:14:11 <edwardk> this leads to a tricky cycle ;)
22:14:15 <Jafet> Oh, infix macros
22:14:22 <Jafet> Infix macros!?
22:14:26 <edwardk> =)
22:14:50 <Jafet> You could have meta-fixity
22:15:41 <zzo38> The idea would be that the more declarations are allowed both before and after "more" appears, like most other things in Haskell. And you can use "more" multiple times with the same name as well as declarations multiple times using the same name that are reordered and put together in the same more. Changing depending on how it is used, such as removing duplicates in the "data" declaration
22:15:46 <edwardk> the best i've been able to do was have the fixities defined by a macro take effect after the macro line, and have the fixity of a macro be determined by the fixities in scope when the macro was executed, but this 'orders' the source code and fixities in an unsatisfying way in a language where nothing else is ordered
22:16:19 <edwardk> zzo38: X a = return a -- would then have two very different parses dependning on whether or not there was a more X somewhere in the file
22:16:29 <Jafet> You could also try every substitution until one type-checks
22:17:25 <edwardk> zzo38: or your X a = a <- return a would be a syntax error conditionally based on stuff you haven't parsed yet, while also adding the need to parse <- in the expression parser some how
22:17:34 * copumpkin slaps Jafet 
22:17:38 <zzo38> edwardk: Yes it would. But declarations can be separated first, and then find "more"s and then those kind of declarations can be parsed. Even if you do not know if X is a constructor or more-name, you still know where the more is being used, such as "data", "do", or "case".
22:18:26 <edwardk> i don't know that you do. in fact i strongly doubt you do, since your more syntax is pretty scarily ambiguous to me. can you inject multiple statements with X a = … ?
22:18:29 <Jafet> zzo: I would worry that your argument might not hold, especially in a language as complex as haskell
22:18:46 <Jafet> Or ghc-haskell
22:19:09 <zzo38> If you want to make such declaration work even though there is no more to include it in, you can use a declaration such as this (using Template Haskell):  [| do { more X; } |] >> [d| |];
22:19:10 <edwardk> at best it would require a radical restructuring of the language
22:19:27 <zzo38> Now "X" is a more-name that is not actually used anywhere but is still a more-name.
22:20:15 <edwardk> i'm thinking about taking wl-pprint-extras and wl-pprint-terminfo and folding them into trifecta itself
22:20:30 <zzo38> Jafet: OK, but it seems to me you can still easily find { ; } without too much difficulty
22:20:53 <edwardk> in particular because then i can define a Syntax class that would let me make the things that just generate or consume a character the same between the pretty printer and the parsers
22:21:10 <edwardk> which would let me remove the name conflicts between my parsers and my pretty printer
22:21:11 <zzo38> (Of course layout complicates it, while I do not use layout I still some people will do so, so it should be tokenized at first)
22:21:21 <edwardk> so you could load them both up in scope and not have to work qualified
22:21:24 <Jafet> I could try to come up with a counterexample of its consistency, but not until you describe its semantics.
22:21:50 <zzo38> Jafet: OK. I thought my examples did describe its semantics, though.
22:22:53 <edwardk> zzo38: finding ; is hazardous because your = … ; …. could be ending the statement your = …  or it could be part of your more notation
22:23:10 <edwardk> the former would be the one that the lack of an introduction of a layout context would hint towards
22:23:45 <zzo38> edwardk: No, it cannot be. I didn't explain it, but if you want multiple statements in that case you need to separate them by | not by ;
22:23:50 <Jafet> zzo: nope, they're just examples
22:24:07 <Jafet> You have to be more formal than examples
22:24:16 <zzo38> Or, if the order doesn't matter, as separate declarations.
22:24:21 <zzo38> Jafet: OK, I will try better.
22:24:29 <edwardk> the utility of this does not seem to be worth the number of very bizarre syntactic warts that would ensue
22:24:42 <Jafet> Indeed. But they're his warts.
22:25:12 <zzo38> "more X z" in a do-block means: take all "X" declarations and include them in the block but with the proper name scoping.
22:25:44 <Jafet> And what does "take all" mean? How do you combine multiple declarations?
22:26:01 <zzo38> "more X z" in a data type declaration means: take all "X" declarations and reorder them so that they retain order of multiple constructors in a single "X", and then remove duplicates and put them in the data type declaration as constructors.
22:26:19 <edwardk> zzo38: i wish you luck implementing your toy language feature
22:26:28 <zzo38> "more X z" in a case block means: take all "X" declarations and rearrange them in order of specificness.
22:26:55 <zzo38> "more X z" in a list means: take all "X" declarations and put them in a list.
22:28:17 <zzo38> Multiple items in a single "X" declaration must be separated by "|" and all names must be scoped as where they are in the source file.
22:28:33 <zzo38> Now do you know what is wrong with this?
22:29:33 <zzo38> In addition, if "more X" appears in a file, "X" is not allowed to be the name of any constructor (although it can still be the name of a type).
22:30:12 <copumpkin> zzo38: I encourage you to look at how SHE is implemented
22:30:18 <Jafet> You seem to be inventing four different macros and deciding they should be part of the base haskell syntax and share the same keyword
22:30:21 <copumpkin> it adds a few constructs to haskell without parsing everything
22:30:27 <copumpkin> and in a fairly lightweight manner
22:30:48 <Jafet> You also haven't specified how to combine multiple declarations for some of those macros
22:30:58 <copumpkin> http://personal.cis.strath.ac.uk/~conor/pub/she/
22:31:11 <copumpkin> it's a preprocessor
22:31:11 <zzo38> copumpkin: I have seen that already.
22:31:22 <copumpkin> why won't it work for your purposes?
22:31:46 <copumpkin> in particular, its pattern synonyms seem like roughly the same idea
22:31:56 <copumpkin> adding the specificity sorting would be a pain
22:32:02 <Jafet> It doesn't implement spooky action at a distance
22:32:08 <copumpkin> ah
22:32:18 <Jafet> Which is pervasive in his usage
22:32:23 <zzo38> There are problems with it. It does have something similar to the more-notation but not nearly as powerful or stuff
22:32:45 <Saizan> the aspect oriented stuff in SHE is somewhat spooky and at a distance
22:32:46 <copumpkin> how much haskell have you written, out of curiosity?
22:32:51 <rudyl313> does anybody know how to deploy haskell code to heroku?
22:33:41 <zzo38> copumpkin: One entire program, and part of another. (This second program does not need more-notation or any of this other stuff; but it might be useful in future programs I wrote)
22:34:25 <copumpkin> modifying the compiler with an unproven language feature seems a bit ambitious for your second project :P
22:34:37 <copumpkin> at least write up a concrete proposal on all the details
22:34:44 <copumpkin> and let people look over it and give suggestions
22:34:54 <zzo38> Yes I should write a concrete proposal; it would be good idea you are correct.
22:35:02 <copumpkin> it'll also help you clear up issues and think through gotchas you'll encounter on the way
22:37:40 <zzo38> The first complete Haskell program I wrote was this:   http://zzo38computer.cjb.net/prog/Constantinople.zip
22:40:23 <zzo38> I might have done a lot of things badly because it is the first program I wrote, but the program does work.
22:50:37 <zzo38> So I can tell you that Parsec is a very good program from what I can tell.
22:52:05 <zzo38> It works well both with and without do-notation.
22:53:21 <zzo38> How common is it to do something like this?   parse_replace x = do { ... } >>= programParser;
22:56:09 <c_wraith> zzo38: in idiomatic code?  Very uncommon.  But if you're generating code, whatever, it's fine. :)
22:57:22 <zzo38> c_wraith: Actually I typed that manually. I wrote the entire program. I know it is probably not idiomatic but I did a lot of things that are probably unusual such as using nonlayout mode.
22:58:24 <zzo38> I do find >> very useful when using Parsec.
22:58:56 <zzo38> For example something might start with   spaces >> string "with" >>   ......
22:58:59 <c_wraith> You'll find most people really like layout mode.  It's nice when the layout can't lie.  So yeah, not using it is very uncommon.
23:00:43 <c_wraith> though I guess it's much less of an issue than it would be in C, where people lie with layout all the time.
23:03:28 <zzo38> With C, I use CWEB which prettyprints everything anyways.
23:03:53 <c_wraith> so...  you prefer layout to not lie, after all.
23:04:01 <c_wraith> Why not let the compiler enforce it?
23:04:37 <zzo38> I also prefer explicit { } ;
23:04:56 <zzo38> I find it actually makes some things clearer too
23:05:40 <c_wraith> there should be exactly zero things it makes clearer.  It's not like the difference between do-notation and explicit use of >>=
23:06:20 <dibblego> I find burning incense makes my haskell appear clearer
23:07:12 <sohum> @pl \x -> p (g x) x
23:07:13 <lambdabot> p =<< g
23:08:18 <zzo38> To me, it makes everything clearer. I also sometimes want to put things that are not the same as the way the layout mode does it, such as multiple things on one line, splitting line if it is helpful, and other things.
23:08:30 <zzo38> Is there also a backwards (>=>) as well?
23:08:34 <c_wraith> You can always split a line in layout mode
23:08:42 <c_wraith> and always put two things on one line in layout mode
23:08:49 <c_wraith> so...  I'm not sure what you're running into
23:08:52 <zzo38> Well, I still prefer nonlayout mode
23:09:16 <zzo38> To me it is clearer, anyways.
23:09:19 <c_wraith> Seems silly to prefer the compiler not tell you when you're lying.  But ok.  You're the one who has to maintain it.
23:10:03 <zzo38> I don't want the compiler to tell me when I am lying. I want the compiler to do exactly what I typed even if it is wrong.
23:10:17 <c_wraith> That's a very poor attitude to have with haskell.
23:10:27 <c_wraith> You'll spend all your time fighting the compiler, instead of writing code.
23:10:49 <zzo38> I want the computer to do exactly what I typed even if it is wrong.
23:11:01 <zzo38> (In general.)
23:11:17 <c_wraith> yeah, you're going to hate haskell.  The compiler actually tells you when you're wrong.
23:11:42 <c_wraith> It's much better to use the compiler as an extension of yourself, that checks all the mechanical things so you don't have to do it manually.
23:13:53 <copumpkin> that attitude will lead to a painful experience with haskell
23:14:44 <copumpkin> because it will invariably win
23:15:01 <c_wraith> just need moar unsafeCoerce, right?
23:15:40 <pikhq_> And unsafePerformIO.
23:15:47 <zzo38> Why did the backspace key suddenly stop working? (Now it just beeps unless I also push CTRL)
23:15:49 <pikhq_> :t unsafeCoerce . unsafePerformIO
23:15:50 <lambdabot> Not in scope: `unsafeCoerce'
23:15:50 <lambdabot> Not in scope: `unsafePerformIO'
23:15:57 <pikhq_> Darn sanity.
23:16:01 <pikhq_> IO a -> b
23:16:03 <pikhq_> Mmm.
23:16:09 <c_wraith> zzo38: sounds like a terminal issue...  what platform?
23:16:34 <zzo38> PuTTY. I would use UNIX but now I cannot
23:17:11 <c_wraith> Hmm.  Well, I don't know enough to help with that, then.  But it still sounds like somewhere, the terminal settings changed.
23:18:15 <zzo38> It is fixed now
23:19:06 <c_wraith> then shrug, and hope it doesn't happen again :)
23:19:10 <zzo38> And don't be silly..... Haskell is supposed to be functional programming you should not use the unsafe functions, although it is there if you need it, at least.
23:19:50 <c_wraith> functional doesn't imply statically typed
23:20:04 <c_wraith> I mean...  There are all the lisp dialects, after all
23:33:12 <cads> http://www.youtube.com/watch?v=cHTibqThCTU&feature=related
23:33:52 <cads> I don't know how it's stable sideways
23:33:58 <cads> err
23:34:00 <cads> wrong channel
23:34:10 <cads> but do enjoy the engineering porn :)
23:41:59 <Jafet> @hoogle Handle -> IO Word8
23:42:00 <lambdabot> Network.BufferType buf_hGetContents :: BufferOp a -> Handle -> IO a
23:42:00 <lambdabot> Network.BufferType buf_hGetLine :: BufferOp a -> Handle -> IO a
23:42:00 <lambdabot> Network.BufferType buf_hGet :: BufferOp a -> Handle -> Int -> IO a
23:42:58 <Jafet> Pft
23:54:29 <Jafet> Please don't tell me I need to alloc 1 $ \buf -> do fd <- handleToFd h; 1 <- fdReadBuf buf 1; peek buf
23:56:11 <Jafet> Or go to getchar via FFI
23:58:29 <c_wraith> you should use alloca :P
23:59:05 <c_wraith> But...  isn't there some bytestring IO you can use?
23:59:15 <c_wraith> @hoogle Handle -> IO ByteString
23:59:16 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
23:59:16 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
23:59:16 <lambdabot> Data.ByteString.Char8 hGetContents :: Handle -> IO ByteString
23:59:20 <Jafet> Yeah, but that also feels overpowered
23:59:50 <c_wraith> simpler than FFI. :P
