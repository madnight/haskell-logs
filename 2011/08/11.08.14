00:00:06 <jrockway> i saw graphalyze first and noticed a lot of traversal algorithms, but not A*, which is what i had in mind
00:00:09 <jrockway> i'll take a look at fgl
00:00:23 <ivanm> jrockway: there's an astar package on hackage which is non-implementation specific
00:00:28 <ivanm> (i.e. function based)
00:00:44 <ivanm> warning: I make no claims to performance in Graphalyze :p
00:02:14 <ivanm> dammit, ghc-7 now bitches about non-exhaustive patterns in lambdas
00:02:31 <ivanm> I started using lambdas because I knew I covered only the patterns I cared about!
00:03:01 <jrockway> ivanm: thanks.  don't know how i didn't notice that!
00:03:17 <ivanm> jrockway: my graphviz package can also be used to visualise fgl graphs
00:03:38 <ivanm> (and I'm going to release a new version tonight; hopefully with the new features; if not just a bug-fix)
00:04:16 <sohum> does fgl support multiple edges between nodes?
00:05:35 <ivanm> yup
00:05:51 <ivanm> I fixed that bug in PatriciaTree where it didn't
00:07:37 <ivanm> wow... ghc-7 _really_ hates my code :o
00:08:07 <sohum> @pl \a -> out a ++ inn a
00:08:08 <lambdabot> liftM2 (++) out inn
00:08:46 <ivanm> lots of SpecConstr messages :s
00:09:05 <ivanm> sohum: if that's for fgl, you can't quite do that because of loops
00:10:27 <sohum> ivanm: that would surely just result in duplicate edges, though?
00:10:51 <ivanm> sohum: duplicate loops, yes
00:11:13 <sohum> duplicate edges in the resulting [LEdge b], I meant
00:11:33 <ivanm> yup
00:11:51 <ivanm> each loop will be listed twice
00:11:58 * sohum nod
00:11:59 <ivanm> once as an in-coming edge and once as an out-going edge
00:12:48 <sohum> right. so it doesn't seem like this exists, so I'll have to hack in a way to have edges between edges
00:13:16 <ivanm> sohum: what are you wanting?
00:13:55 <sohum> have edges between edges in a graph :p
00:14:31 <ivanm> as in an edge from edge1 to edge2 ?
00:14:34 <sohum> yea
00:14:35 <ivanm> that doesn't sound right...
00:14:50 <ivanm> create a node to represent edge1, etc.
00:15:02 <ivanm> why the hell would there be edges between edges?
00:15:15 <dmwit> Why shouldn't there be edges between edges?
00:15:25 <ski> @type \f -> liftM2 f out In
00:15:26 <lambdabot>     Couldn't match kind `* -> *' against `(* -> *) -> *'
00:15:26 <lambdabot>     When matching the kinds of `f :: * -> *' and `Mu :: (* -> *) -> *'
00:15:26 <lambdabot>       Expected type: Mu t
00:15:37 <dmwit> But I concur: the right way to do this is to track two graphs, one with nodes and edges, and the other with edges and edge-edges.
00:15:49 <dmwit> ?type liftM2
00:15:49 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
00:16:00 <ivanm> dmwit: I can't recall any usage of a graph or a graph data structure where you'd have some kind of arc from one edge to another
00:16:08 <ddarius> Clearly the write thing to do is to use a globular set.
00:16:10 <ivanm> dmwit: and I meant within the same graph have some nodes representing edges
00:16:12 <dmwit> liftM2 :: (a -> b -> c) -> (e -> a) -> (e -> b) -> (e -> c)
00:16:25 <ddarius> s/write/right/
00:16:40 <dmwit> ivanm: I know what you meant. But I think the idea you meant was crappy.
00:16:54 <sohum> ivanm: each "edge" represents a similarity between two items, in my case. I want to allow similarities between similarities
00:16:54 <dmwit> So I fixed it inline.
00:17:04 <ivanm> oh? why?
00:17:15 <ivanm> sohum: hmmmm....
00:17:26 <ivanm> sounds like a multi-layered graph
00:17:28 <dmwit> ivanm: Because it allows you to have an edge from an edge to a node. Which doesn't sound like what he wants.
00:17:35 <ivanm> can you have edges between edges between edges ?
00:17:37 <ski> ivanm : well, you might want to do buildings ..
00:17:38 <dmwit> Whereas what I suggested properly stratifies the two kinds of edges.
00:17:49 <ski> i.e. Bruhat-Tits buildings
00:17:57 <ivanm> dmwit: so you make your functions smarter that manipulate it, and use node labels to indicate whether it's a real node or an edge node
00:17:58 <ski> <http://en.wikipedia.org/wiki/Building_(mathematics)>
00:18:08 <sohum> ivanm: theoretically, yes
00:18:23 <dmwit> ivanm: Yes, you could rely on careful coding. Or you could just have a data-type that prohibits wrong things.
00:18:30 <dmwit> Which is sort of the whole point of Haskell's type system.
00:18:36 <ivanm> dmwit: then you have to keep them in sync
00:18:40 <ivanm> and thus need careful coding
00:18:42 <dmwit> You have to do that anyway.
00:18:47 <dmwit> (In your suggested way.)
00:18:56 <sohum> and yea, this involves keeping things in sync, which is hard, which I really don't want to do >_>
00:19:15 <jrockway> so you've invented a new concept, "edge-edge", instead? :)
00:19:26 <ivanm> sohum: what's your actual usage for this?
00:19:39 <sohum> I am all for suggestions for a different data structure that would work better
00:19:43 <sohum> ivanm: my honours project :p
00:19:53 <ivanm> heh
00:20:03 <dmwit> sohum: Just write your own data type wrapper that just stores two graphs behind the scenes.
00:20:09 <ivanm> so, is this whole concept your project?
00:20:22 <dmwit> You will need to do a bit of synchronizing in the functions that you expose as this new data type's API.
00:20:24 <sohum> nah. I thought the concept existed, previously, actually
00:20:29 <dmwit> But it shouldn't be *that* hard to get right.
00:20:37 <sohum> dmwit: hrm. fair enough...
00:21:00 <sohum> ivanm: my project just requires tracking edge-like concepts between edge-like concepts
00:21:14 <ivanm> OK: is it a regression in GHC if my project takes a hell a lot more time/CPU/RAM to compile with 7.0.2 instead of 6.12.3?
00:21:15 <aninhumer> I'm using 'instance (Integral i) => BData i where' but GHC complains, and using the suggested pragma appears to cause all types to be recognised as Integral
00:21:32 <ivanm> aninhumer: what's the error message?
00:21:39 <ivanm> oh, wait, I see what you're doing...
00:21:44 <ivanm> aninhumer: yeah, there's no real way of doing that
00:21:54 <ivanm> (i.e. automatically making all instances of one class instances of another)
00:22:13 <jrockway> sohum: Data.Graph.Inductive.Graph has labeled edges.  i think the label you apply to edges in one graph become labels of nodes in the other graph.
00:22:33 <ivanm> jrockway: yeah, that'd be the best way to keep them in sync
00:22:41 <aninhumer> ivanm: Why doesn't what I've written work, from a type system point of view?
00:22:46 <marens> hmm, snap-server still fails to install via cabal even after installing monad-control
00:23:02 <dmwit> aninhumer: During instance search, the rule is *only* to look at the head of the available instances (not their contexts).
00:23:17 <jrockway> sohum: so if you're traversing the similar-concepts graph, you'll encounter label "foo" along the edge, representing the similarity "foo".  then you look at your similarity similarity graph for the node labeled "foo", and then you have your similar similarities.
00:23:30 <ivanm> aninhumer: because someone might then write: instance BData Int where ...
00:23:34 <ivanm> and which version do you use then?
00:23:35 <dmwit> aninhumer: So, to search for an instance of BData, this rule will always apply -- even if the type is not an Integral instance.
00:23:38 <dmwit> Is that what you wanted?
00:24:01 <dmwit> s/this rule/this instance/
00:24:02 <dmwit> sorry
00:24:11 <sohum> wee keeping track of unique ids...
00:24:21 <sohum> I'm going to be using a _lot_ of Maps :p
00:25:44 <jrockway> can't you label a node with its unique id as you are building the graph?
00:26:49 <dmwit> sohum: Surely you only need a Map for the bits that are shared between the two graphs (i.e. edges)?
00:29:49 <jrockway> depending on how big the graph is, you may or may not care about eliminating extra data structures
00:30:22 <jrockway> with some care, you can assign unique ids without maintaining a node -> id map
00:30:33 <eyu100> > fix (\f a -> if a == 0 then 0 else f (a - 1)) 0
00:30:34 <lambdabot>   0
00:30:42 <jrockway> actually, fgl's node type seems to be Int :)
00:31:00 <sohum> dmwit: yea, but I already need to use a bunch of maps for other reasons
00:31:23 <sohum> sorry, should have said that I need another map
00:31:34 <jrockway> you seem overly excited about maps :)
00:31:38 <sohum> the fun bit will be _modifying_ this structure later
00:32:31 <sohum> jrockway: maps! so like a function, maps! having such gumption, maps! ...
00:34:08 <eyu100> > fix (\f a -> if a == 0 then 0 else f (a - 1)) 1
00:34:08 <lambdabot>   0
00:34:44 <eyu100> hmm, interesting
00:34:49 <hvr> marens: I suspect that `mask_` was added to `base-4.3`... but w/ GHC 6.12 you have base-4.2 at best
00:35:53 <marens> hvr, i tested snap-server-0.5.2 instead 0.5.3 that works here
00:36:03 <eyu100> so if f is bottom the first part of that expr becomes \a -> if a == 0 else _|_ (a - 1), which is not bottom?
00:36:24 <marens> should upgrade ghc soonish then :D
00:36:31 <_KY_> How do I merge 2 lists l1, like to to give [(l1,like to)] , ie a list of tuples?
00:36:41 <eyu100> so bottom is not the least fix point and it works... right?
00:36:44 <dmwit> eyu100: f is not bottom, it's "fix (\f a -> ...)".
00:36:57 <_KY_> How do I merge 2 lists L1, L2 to give [(L1,L2)] , ie a list of tuples?
00:37:04 <dmwit> :t zip
00:37:04 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
00:37:19 <dmwit> _KY_: In the future, questions of this form can be answered by giving the type of the function you want:
00:37:24 <dmwit> ?hoogle [a] -> [b] -> [(a, b)]
00:37:25 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
00:37:25 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
00:37:25 <lambdabot> Data.Graph.Inductive.Example genLNodes :: Enum a => a -> Int -> [LNode a]
00:37:34 <_KY_> Thanks=)
00:37:47 <eyu100> > zip [[]] [[]]
00:37:48 <lambdabot>   [([],[])]
00:38:40 <marens> hvr: but thanks for looking into it
00:41:51 <ivanm> @tell chrisdone actually, a re-load equiv of F5 would be handy when you edit one file but want the previous one re-loaded
00:41:52 <lambdabot> Consider it noted.
00:44:45 <eyu100> dmwit: so is it valid to say that since bottom is not a fixpoint, the "correct" function is the only fixpoint and therefore fix (\f a -> ...) x is guaranteed to work?
00:45:31 <eyu100> without trying to figure out the details of the evaluation
00:45:49 * hackagebot digestive-functors-happstack 0.1.0.2 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.1.0.2 (JasperVanDerJeugt)
00:45:51 * hackagebot citeproc-hs 0.3.3 - A Citation Style Language implementation in Haskell  http://hackage.haskell.org/package/citeproc-hs-0.3.3 (AndreaRossato)
00:46:17 <_KY_> A pattern cannot begin with (_ ...) ?
00:47:02 <eyu100>  well if it begins with _ you have no idea how many arguments it takes
00:47:26 <dmwit> eyu100: yes, that sounds a bit right
00:47:34 <eyu100> k
00:47:55 <dmwit> eyu100: I'd be a bit careful with the "only fixpoint" part. I think it's true in this case and many others, but really fix only promises to give the least fixed point (in definedness ordering).
00:48:58 <eyu100> well if it's the only fixpoint incl. bottom it is the least fixpoint
00:49:39 <dmwit> > snd (fix (\(a, _) -> (a, 3))) -- bottom is not a fixed point, and there are many non-bottom fixed-points
00:49:41 <Cale> A pattern can begin with (_ ...) if ... is the empty string ;)
00:49:43 <lambdabot>   mueval-core: Time limit exceeded
00:49:48 <dmwit> err
00:49:53 <dmwit> > snd (fix (\~(a, _) -> (a, 3))) -- bottom is not a fixed point, and there are many non-bottom fixed-points
00:49:54 <lambdabot>   <no location info>: parse error on input `->'
00:50:14 <Cale> > snd (fix (\ ~(a,_) -> (a,3))
00:50:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
00:50:18 <Cale> > snd (fix (\ ~(a,_) -> (a,3)))
00:50:18 <lambdabot>   3
00:50:20 <ivanm> @tell chrisdone having each line of output from "cabal build", etc. might not be a good idea with so many lines...
00:50:20 <lambdabot> Consider it noted.
00:50:29 <dmwit> > snd (fix (\p -> (fst p, 3)))
00:50:29 <lambdabot>   3
00:51:00 <eyu100> yeah I saw something like that on haskell-cafe
00:51:30 <eyu100> fix is confusing >_>
00:51:40 <dmwit> > fix (\p -> (3, snd p)) -- a clearer example, perhaps
00:51:44 <lambdabot>   mueval-core: Time limit exceeded
00:52:07 <eyu100> > undefined
00:52:08 <lambdabot>   *Exception: Prelude.undefined
00:52:17 <eyu100> > fix undefined
00:52:18 <lambdabot>   *Exception: Prelude.undefined
00:52:26 <eyu100> > fix error
00:52:27 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
00:52:45 <dmwit> Oh, well, that example is clearer in ghci, at least. haha
00:53:01 <eyu100> yeah it prints part of the tuple
00:53:07 <eyu100> (3,
00:54:12 <mustelo> kind of an odd question: does anyone know the best way to contact mike meyer (of http://blog.mired.org/ )?
00:54:52 <ivanm> mustelo: well, he has facebook, etc. accounts
00:55:03 <ivanm> he also has a google+ account; might be able to get his gmail address from that
00:55:15 * mustelo was secretly hoping he would be in the channel
00:55:25 <eyu100> > fix (\p -> (1,fst p))
00:55:26 <lambdabot>   (1,1)
00:55:49 * hackagebot hashed-storage 0.5.8 - Hashed file storage support code.  http://hackage.haskell.org/package/hashed-storage-0.5.8 (PetrRockai)
00:56:17 <solrize_> > fix error
00:56:17 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
00:56:35 <dmwit> > fix show
00:56:36 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
00:56:38 <dmwit> @v
00:56:38 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
00:56:46 <dmwit> what a wacky coincidence
00:57:03 <ivanm> hooray for test-suites picking up really embarrassing bugs every now and then (as in, they've existed for _ages_ but QC just generated a value that caused it now)
01:05:31 <dmwit> \bot seems to have more spaces in front of its replies every time I turn around.
01:06:30 <shachaf> > text (replicate 12 ' ' ++ "Odd.")
01:06:33 <lambdabot>               Odd.
01:06:55 <dmwit> > text "" -- hum
01:06:56 <lambdabot>  Terminated
01:07:01 <dmwit> eh?
01:07:05 <dmwit> That was unexpected.
01:07:17 <dmwit> > text " "
01:07:27 <shachaf> > text "Terminated"
01:07:27 <dmwit> > text "" -- reproducible?
01:07:28 <lambdabot>   Terminated
01:07:28 <lambdabot>  Terminated
01:07:55 <shachaf> > text "mueval-core: Time limit exceeded"
01:07:56 <lambdabot>   mueval-core: Time limit exceeded
01:08:05 <shachaf> This text thing is really broken.
01:08:07 <dmwit> Yours has more space in it than a legitimate reply.
01:08:31 <dmwit> > fix id
01:08:32 <shachaf> ?where ?where
01:08:32 <lambdabot> ?where ?where
01:08:35 <lambdabot>   mueval-core: Time limit exceeded
01:08:54 <dmwit> shachaf: Yes, that's the most dangerous one.
01:09:06 <dmwit> I'm surprised that one hasn't been fixed yet.
01:09:20 <dmwit> Considering all the extra spaces cropping up in the rest of the plugins. =P
01:09:34 <shachaf> dmwit: Lambdabot hasn't been changed in years.
01:09:42 <shachaf> Just like NetHack.
01:09:54 <shachaf> It's a piece of history, y'know, frozen in time forever.
01:09:54 <dmwit> hm?
01:10:01 <dmwit> Last uploaded Jan 20 2011
01:10:08 <shachaf> Well, maybe small changes.
01:10:18 <shachaf> Not to any of the actual plugins, though.
01:10:49 * hackagebot snap-core 0.5.3.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.5.3.1 (GregoryCollins)
01:10:51 * hackagebot snap-server 0.5.3.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.5.3.1 (GregoryCollins)
01:10:52 <dmwit> I wonder if \bot would be architected the same way today if it were to be build fresh.
01:11:07 <dmwit> p. not
01:11:14 <shachaf> Very unlikely.
01:11:18 <shachaf> Someone should rewrite her.
01:11:59 * dmwit puts his finger on his nose
01:12:00 <ivanm> @tell chrisdone it also doesn't like it when hasktags fails...
01:12:00 <lambdabot> Consider it noted.
01:12:44 * shachaf puts his finger on dmwit's nose.
01:13:15 <dmwit> *gasp*
01:13:18 <dmwit> human contact!
01:13:42 <elliott_> edwardk: ok, how did you know I was just thinking "I sure wish data-lens-template used a _ prefix rather than suffix" a few days ago?
01:14:58 <Rc43> Hi, guys.
01:15:18 <Rc43> Prelude> :t subtract 10 . length >>= drop
01:15:22 <dmwit> hiya, Rc43
01:15:24 <Rc43> subtract 10 . length >>= drop :: Monad ((->) [a]) => [a] -> [a]
01:15:46 <Rc43> Never seen it earlier, what is Monad ((->)[a]) ?
01:15:53 * hackagebot snap 0.5.3.1 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.5.3.1 (GregoryCollins)
01:15:53 <shachaf> > (subtract 10 . length >>= drop) ['a'..'z']
01:15:55 <lambdabot>   "qrstuvwxyz"
01:16:03 <shachaf> Rc43: ((->) r) is a monad.
01:16:34 <dmwit> Rc43: The (i ->) monad is a container indexed by values of type "i".
01:16:35 <Rc43> We can operate with function types like with others? I thought that it is right only with values.
01:16:46 <elliott_> Functions are values.
01:17:14 <Rc43> Can we declare (->a) as Eq instance?
01:17:21 <Rc43> (For example.)
01:17:22 <dmwit> Yes, if you can write one.
01:17:25 <dmwit> Or rather, no.
01:17:30 <dmwit> But not because it involves an arrow.
01:17:35 <dmwit> Rather because it doesn't have the right kind.
01:17:36 <Rc43> Cool.
01:17:44 <dmwit> You could declare an (a->b) Eq instance.
01:17:48 <elliott_> You probably mean ((->) a) rather than (-> a).
01:18:08 <Rc43> Ye, I undertood, just didnt type thoroughly.
01:18:08 <elliott_> ((->) a) b = a -> b; whereas (-> a) b = a -> b, if that syntax is even valid.
01:18:10 <elliott_> Right.
01:18:16 <elliott_> Erm.
01:18:19 <Rc43> Eee
01:18:20 <elliott_> ((->) a) b = a -> b; whereas (-> a) b = b -> a, if that syntax is even valid.
01:18:24 <elliott_> I'm good :P
01:18:25 <shachaf> elliott_: (->) b = b -> ... Yes.
01:18:28 <Rc43> What is ((->)a) ?
01:18:39 <elliott_> Rc43: The partial application of (->) to the  type variable "a".
01:18:39 <shachaf> However, it would be nice if we could call it (a ->).
01:18:47 <elliott_> For any infix operator, (op) is the prefix version of it.
01:18:52 <elliott_> For instance: (+) 9 9 === 9 + 9.
01:18:55 <ddarius> shachaf: You can with an extension.
01:19:19 <shachaf> ddarius: That's true of everything I might want. Does that extension actually exist in GHC?
01:19:20 <ddarius> However (-> a) is not allowed regardless.
01:19:30 <Rc43> elliott_, partial application? I thought it is language feature but not the strange typ :D
01:19:32 <ddarius> shachaf: I'm pretty sure TypeOperators allows that.
01:19:49 <dmwit> Aww, why isn't (-> a) allowed?
01:19:50 <elliott_> Rc43: Well, obviously ((->) a) isn't a type in itself, because it's missing the right hand side of the arrow.
01:19:55 <dmwit> ...oh, type-level lambdas.
01:19:56 <dmwit> right
01:20:05 <elliott_> Rc43: Just like (Either String) isn't a type, but (Either String Int) is; the former has been partially applied.
01:20:15 <elliott_> dmwit: I'm just hearing reasons why it should be allowed ;-)
01:20:22 <ddarius> dmwit: It would be sweet if it were allowed and actually it isn't infeasible to allow that one.
01:20:27 <Rc43> elliott_, we can operate with (Either String)?
01:20:53 <elliott_> Rc43: Depends what you mean by "operate with".
01:21:07 <dmwit> Rc43: Yes. All Monad instances are incompletely-applied type-level functions.
01:21:17 <dmwit> :k Monad m => m
01:21:18 <ddarius> (Though the combination of type classes and type level pattern unification is probably unpleasant.)
01:21:18 <lambdabot>     `m' is not applied to enough type arguments
01:21:19 <lambdabot>     Expected kind `*', but `m' has kind `* -> *'
01:21:19 <lambdabot>     In the type `(Monad m) => m'
01:21:30 <elliott_> We're good at this.
01:21:31 <shachaf> ddarius: Doesn't seem to me to work.
01:21:54 <elliott_> Oh, I thought that error was accidental.
01:21:54 <ddarius> shachaf: It may be another extension, or maybe I'm wrong.  There's a few I believe that affect that syntax.
01:21:55 <Rc43> elliott_, dmwit, is there any article about types or smthing, that include such things?
01:22:00 <elliott_> dmwit has failed to make me feel better about my gaffe.
01:22:16 <Rc43> elliott_, dmwit, haven't seen such before
01:22:29 <dmwit> Rc43: The "m" in a "Monad m" instance must have kind "* -> *", that is, it must be a type constructor that takes a fully-applied type (something of kind *) and returns a fully-applied type (another thing of kind *).
01:23:09 <dmwit> Rc43: Just like values have a type system, types have a kind system. =)
01:23:19 <dmwit> Luckily the kind system is significantly simpler than the type system.
01:23:27 <shachaf> dmwit: "Luckily"?
01:23:36 <Rc43> dmwit, so keywords are something like "partially-aplied-types" ?
01:23:43 <dmwit> There's only two sorts of kinds: * is a kind, and if k1 and k2 are kinds, then k1 -> k2 is a kind.
01:23:54 <dmwit> Rc43: No, not keywords.
01:24:02 <dmwit> Rc43: Perhaps you meant things like "Maybe" and "Either"?
01:24:07 <dmwit> These are just called "type constructors".
01:24:11 <dmwit> They're not built into the language.
01:24:15 <elliott_>   	-- Defined in data-lens-1.8.0.2:Data.Lens.Common
01:24:15 <elliott_> [...]
01:24:15 <elliott_>   	-- Defined in Data.Lens.Common
01:24:15 <elliott_> Oh no.
01:24:18 <dmwit> Maybe :: * -> *
01:24:22 <dmwit> Either :: * -> * -> *
01:24:40 <dmwit> Then there's more complicated ones like StateT :: * -> (* -> *) -> * -> *
01:24:56 <Rc43> dmwit, hm, ok; it seems type constructors appropriate
01:25:18 <shachaf> dmwit: Would you say that (kind-level) (->) isn't a kind? :-)
01:25:34 <shachaf> In the sense that type-level (->) is a type, anyway. You can't have anything *of* that kind, I guess.
01:25:45 <dmwit> type-level (->) is a type constructor
01:25:50 <elliott_> shachaf: I wouldn't call (->) a type.
01:25:51 <dmwit> kind-level (->) is a kind constructor
01:25:57 <elliott_> dmwit: And sort-level????????
01:25:58 <dmwit> I would happily stand behind both of those claims.
01:26:11 <dmwit> elliott_: I don't think Haskell stratifies quite that far. =)
01:26:18 <elliott_> dmwit: YET.
01:26:23 <dmwit> indeed =P
01:26:36 <shachaf> dmwit: A value constructor is a value; is a type constructor not a type?
01:26:45 <dmwit> No.
01:26:50 <dmwit> A type is a thing of kind *.
01:26:52 <elliott_> ohYeah :: foldr (->) String [String, Int, [Double]]
01:26:53 <shachaf> Hmph.
01:27:01 <shachaf> Is there a word for "value-on-the-type-level"?
01:27:10 <dmwit> A value constructor is a value only by accident.
01:27:18 <elliott_> shachaf: Value-type. That can't possibly get confusing.
01:27:37 <elliott_> "The type of the value is a value-type, but not all value-types can have values whose types are that value-type."
01:28:20 <dmwit> shachaf: Since we don't really do type reduction (ignoring type families for now), talking about values at the type level is a bit nonsensical.
01:30:11 <k0ral> hi, anyone ever used couchdb package ?
01:31:02 <k0ral> I'm looking for a way to login into the database and I can't see anything from the Haskell API that manages that
01:31:53 <dmwit> Hm, what *is* the normal way to define "value" in the presence of custom data types?
01:32:03 <dmwit> Are lone constructors a value or not?
01:32:15 <dmwit> (specifically, lone constructors of function type)
01:33:15 <benmachine> I think a value is just anything on the value level
01:33:33 <benmachine> possibly any expression is a value
01:33:40 <dmwit> Go on then.
01:33:47 <dmwit> What would be the point of the word "value" in that case?
01:33:58 <benmachine> the same as the point of the word "expression" I guess
01:34:01 <benmachine> well
01:34:03 <dmwit> Surely nobody allows (\a -> a) (\a -> a) to be a value?
01:34:11 <benmachine> "value" is more usually contrasted with "type"
01:34:26 <benmachine> so it sort of means "thing-that-is-not-a-type"
01:34:32 <dmwit> Really?
01:34:42 <benmachine> that's how I use the word
01:34:47 <benmachine> couldn't comment on anyone else
01:34:57 <benmachine> and (\a -> a) (\a -> a) is a value
01:35:02 <shachaf> dmwit: Why is _|_ not a value?
01:35:05 <dmwit> Usually, when I hear it (not followed by "level"... =) it specifically means the base case of a reduction relation.
01:35:05 <benmachine> but it is the same value as id, I suppose
01:35:14 <shachaf> Wait, that's not even _|_.
01:35:18 <benmachine> heh
01:35:19 <elliott_> Of course _|_ is a value. ...as is id.
01:35:32 <shachaf> I'd call that a value.
01:35:35 <benmachine> ok so value is not the same as expression
01:35:39 <benmachine> but every expression has a value, I think
01:35:53 <elliott_> A value is... at a first approximation, anything you compute with at run-time, which is horribly implementation-centric.
01:35:57 <elliott_> But it's about which side of the :: you're on.
01:36:05 <elliott_> And then I've really just localised it to "anything", haven't I.
01:36:15 <dmwit> benmachine: Infinite loops usually are considered not to have a value.
01:36:26 <shachaf> The great #haskell divide: Which side of the :: are you on?
01:36:31 <elliott_> dmwit: In a strict language, sure...
01:36:31 <benmachine> dmwit: that depends; some people would say they have an undefined value
01:36:42 <benmachine> a value of _|_
01:36:50 <shachaf> dmwit: (\a -> a) (\a -> a) isn't an infinite loop. :-)
01:36:50 <dmwit> I'm specifically talking about in the context of operational semantics.
01:36:57 <dmwit> shachaf: I never claimed it was.
01:37:06 <shachaf> Ah.
01:37:38 <elliott_> I'd say a value is the "result" of any expression, and a piece of data would be a value in WHNF.
01:38:04 <dmwit> For example, with STLC, there's a very simple definition: lambdas are values, and bare variables are values.
01:38:07 <ddarius> In operational semantics often the term "value" is used to distinguish irreducible expressions.  In denotational semantics, anything denotable is usually called a value.
01:38:09 <dmwit> Everything else is Not A Value.
01:38:41 <dmwit> This definition works out pretty good even up to complex systems like system F and friends.
01:38:56 <benmachine> ok, so by ddarius' definitions, I'm using the denotational definition and dmwit's using the operational definition
01:39:02 <shachaf> dmwit: An application of something to something else isn't a value?
01:39:07 <dmwit> shachaf: correct
01:39:13 <dmwit> Because it can take an evaluation step.
01:40:10 <dmwit> Anyway, I guess ddarius' sentence really lays out the motivation for the term pretty well, and answers in my mind whether a lone constructor ought to be a value (even if it has function type): yes.
01:40:36 <ddarius> dmwit: Either denotationally or operationally the answer to that would be "yes."
02:02:50 <merijn> Is there a semi convenient way to search through the logs?
02:03:20 <shachaf> Download the logs, use grep.
02:03:28 <Botje> I recall there being a bot that logs this channel
02:04:32 <merijn> shachaf: That only works for concrete phrases. I just remember some vague words occurring the conversations (not necessarily in close proximity) :\
02:04:49 <shachaf> merijn: Download the logs, use egrep.
02:06:03 <chrisdone> merijn: i'm probably going to write a web app to search the logs today/tomorrow
02:06:03 <lambdabot> chrisdone: You have 9 new messages. '/msg lambdabot @messages' to read them.
02:06:09 <chrisdone> @_@
02:06:24 <shachaf> @tell chrisdone You've got mail!
02:06:24 <lambdabot> Consider it noted.
02:06:27 <merijn> Wow, you're popular :>
02:07:46 <chrisdone> merijn: with postgres's full text search we have the english-awareness for free
02:07:46 <lambdabot> chrisdone: You have 10 new messages. '/msg lambdabot @messages' to read them.
02:08:18 <chrisdone> lambdabot> Plugin `tell' failed with: thread killed
02:08:18 <chrisdone> ~_~
02:08:25 <bcoppens> chrisdone: :D
02:08:38 <chrisdone> chrisdone> @messages <lambdabot> You don't have any new messages.
02:08:47 <chrisdone> heh. so those messages are gone
02:10:40 <chrisdone> just trying to upgrade to ghc 7 at the moment. the dependency update process is a big deal
02:12:36 <ivanm> chrisdone: awww, you didn't want to read all my bug-reports? :(
02:12:38 <chrisdone> ivanm: the copy of autocomplete is only included to ease trying it out
02:12:54 <ivanm> chrisdone: OK
02:13:10 <chrisdone> the ghci buffer is kinda prefixed with *
02:13:19 <ivanm> yeah
02:13:22 <chrisdone> if your project is graph.cabal then your ghci will be *graph*
02:13:33 <ivanm> but still, it used to be easy finding the *haskell* buffer
02:14:24 <aninhumer> If I have a default class method implementation which matches _ and an instance has a partial match what order will they be matched against?
02:14:41 <chrisdone> ivanm: it's trivial to add some smidgen to prefix the buffer name, sure
02:14:59 <chrisdone> ivanm: what do you want? it can be in the config like hs-repl-buffer-prefix
02:15:01 <Botje> aninhumer: and they both match a value of the same type?
02:15:24 <aninhumer> Botje: yes
02:15:40 <Botje> then you will get an error about overlapping instances
02:15:41 <chrisdone> ivanm: personally i've been thinking it's probably better just to have a special key that takes you straight to the prompt, and maybe pressing the key again gets rid of the prompt and takes you back to the file you were in. that would be nice
02:15:57 <Botje> and once you enable overlapping instances .. i don't know. it's up to ghc, really
02:15:58 <ivanm> chrisdone: could work, but not when you have other non-haskell buffers open
02:16:08 <ivanm> I was thinking something like: *ghci: foo*
02:16:14 <ivanm> (for foo.cabal)
02:16:48 <chrisdone> that's less helpful for me because I usually have >3 haskell projects open simultaneously, but I can make the format an option
02:17:22 <chrisdone> just a sec
02:17:54 <ivanm> chrisdone: or a suffix
02:17:57 <ivanm> *foo - ghci*
02:18:06 <ivanm> or configurable; whatever :p
02:18:13 <chrisdone> ivanm: btw… there is support for pirate-mode, and pulp fiction mode :p
02:18:17 * ivanm is still waiting for The Official Guid! :p
02:18:22 <ivanm> chrisdone: wtf?
02:18:27 <aninhumer> Botje: I got no error without Overlapping, although I do have FlexibleInstances
02:18:59 <chrisdone> (defun hs-lang-directory-does-not-exist (dir)
02:18:59 <chrisdone>   (format "Say '%s' again. Say 'what' again, I dare you." dir))
02:19:22 <ivanm> OK, the emacswiki doesn't mention pulp-fiction-mode...
02:19:28 <ivanm> heh
02:19:32 <chrisdone> ivanm: i mean a lang option :p
02:19:36 <ivanm> heh
02:19:49 <hpaste> lewis1711 pasted “ugly but it works” at http://hpaste.org/50291
02:19:53 <chrisdone> (defun hs-lang-build-compilation-failed (msg)  (format "ABANDON SHIP! DON'T FORGET THE RUM!" msg))
02:20:02 <ivanm> chrisdone: oh, and any chance of having directory finding when specifying dirs fixed as well (using ido if possible)?
02:20:12 <lewis1711> can anyone think of a less horrible way of implementing duplicated there, that uses recursion and pattern matching?
02:20:52 <chrisdone> ivanm: yeah i'm not sure how easy it is to use ido-mode for this, it's not very libraryish, but i would like that too
02:21:19 <Botje> lewis1711: e `elem` (e `delete` list)
02:21:50 <ivanm> chrisdone: btw, haskell-emacs' default keybindings clashes with anything-config's defaults :(
02:21:55 <ivanm> it wants to use f5 as well :s
02:22:13 <Botje> aninhumer: hmm. well, i'm not sure. can you put something on hpaste?
02:22:40 <jrockway> chrisdone / ivanm: i'm not quite sure what you guys are talking about, but i think i've done something very similar in emacs before
02:22:44 <chrisdone> ivanm: sure. but yeah, the keybindings are just what i use. use whatever you want
02:22:51 <ivanm> right
02:22:55 <chrisdone> jrockway: done what?
02:22:56 <jrockway> for determining the project name, try eproject.  for switching to the REPL buffer, take a look at stylish-repl-minor-mode
02:23:06 <ivanm> chrisdone: OK, the ghci buffer is now no longer accepting return... :s
02:23:27 <aninhumer> Botje: Just testing now it seems to do what I want, I'll post anyway hang on
02:23:31 <chrisdone> ivanm: what's in your repl?
02:23:33 <lewis1711> Botje: nice
02:23:59 <ivanm> chrisdone: just closed the buffer; I hit F5, had the prompt, but then return doesn't do anything :/
02:24:00 <Botje> lewis1711: it does walk the part leading up to the first e twice, but ..
02:24:20 <lewis1711> ugh, yeah I guess it has to traverse the whole lsit
02:24:26 <hpaste> aninhumer pasted “BData” at http://hpaste.org/50292
02:24:36 <ivanm> chrisdone: OK, even with a new buffer and staring a new hs-project-start it doesn't do anything :/
02:24:38 <lewis1711> I might look at the elem implementation
02:25:07 <lewis1711> actually, is there a place where you can get example implementations of prelude functions?
02:25:23 <jrockway> the "source" link on the ghc docs?
02:25:29 <adrake_> @src flip
02:25:29 <lambdabot> flip f x y = f y x
02:25:32 <Botje> lewis1711: if your list is L1 e L2 e REST it will walk L1 twice and and L2 once.
02:25:40 <Botje> it will not walk REST
02:25:50 <ivanm> chrisdone: methinks the process stuff stopped working :/
02:26:37 <aninhumer> Botje: Ah, it seems to result in just the parital function
02:26:46 <aninhumer> *partial
02:27:23 <ivanm> chrisdone: oh, and your fontlock stuff doesn't like my benchmark.hs which has a line 528000+ chars long :p
02:27:45 <chrisdone> ivanm: lol
02:27:46 <aninhumer> I guess I'll just fill in the _ matches, it's just Nothing anyway
02:28:05 <ivanm> chrisdone: how do I kill running projects?
02:28:13 <GoodAD> niko c'est un ircop pédophile qui abuse des négros, attention, il veut enculer blanche neigre avec ses copains les nains de jardins !
02:28:13 <lewis1711> @src elem
02:28:13 <lambdabot> elem x    =  any (== x)
02:28:35 <ivanm> OK, we now have non-english IRC spam
02:28:48 <Botje> is it september yet?
02:28:54 <chrisdone> ivanm: err I didn't make a function for that. (setq *hs-projects* nil)
02:29:04 <chrisdone> then kill the ghc processes manually :p
02:29:18 <chrisdone> (you can tell it's only me using this)
02:29:38 <ivanm> heh
02:30:20 <GoodAD> Un chasseur sachant chasser sans son chien, est un bon chasseur.
02:30:36 <ivanm> @where ops
02:30:36 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
02:30:37 <chrisdone> ops, please wield your lambda swords
02:30:44 <merijn> Random question, does anyone know who's running the logbot?
02:31:01 <chrisdone> someone in here but i don't remember his nick
02:31:10 <GoodAD> @where ops
02:31:10 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
02:32:22 <ivanm> chrisdone: also, it seems your ghci stuff suffers the same long lines issue as haskell-mode, so adding (setq process-connection-type nil) helps (helps me at least)
02:33:10 <ivanm> chrisdone: OK, after killing them all, they all bitch that the graphviz process isn't running
02:33:44 <chrisdone> ivanm: M-x hs-project-switch-or-create
02:34:03 <chrisdone> yeah long lines is a pain
02:34:22 <ivanm> yup, just worked that one out
02:35:17 <GoudAD> geekounet c'est une tapette qui c'est fait enculer et corrompre par niko, il faut soigner geekounet et lui purger l'anus pour qu'il retrouve le sourrir comme avant.
02:35:26 <ivanm> chrisdone: OK... I've just got the same issue again :/
02:35:47 <chrisdone> ivanm: hard to say what's happening without seeing it
02:35:51 * hackagebot cabal2nix 1.10 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.10 (PeterSimons)
02:36:27 <brisingr> what is the coolest snippet of (Haskell) code you know?
02:36:41 <chrisdone> yay, talk starting
02:36:57 <ivanm> brisingr: fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
02:37:09 <chrisdone> loeb x = fmap (\a -> a (loeb x)) x
02:37:48 <brisingr> fibs goes at the beginning
02:37:51 <brisingr> loeb later on
02:37:57 <brisingr> thanks
02:39:09 <osfameron> what's loeb do?
02:39:40 <chrisdone> :t let loeb x = fmap (\a -> a (loeb x)) x in loeb
02:39:41 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
02:39:42 <brisingr> circular datastructures
02:40:07 <mayahustle> Hi has anyone here installed the latest haskell platform on osx lion?
02:40:08 <chrisdone> :t let loeb x = fmap (\a -> a (loeb x)) x in loeb :: [[a] -> a] -> [a]
02:40:09 <lambdabot> forall a. [[a] -> a] -> [a]
02:40:22 <Itkovian> mayahustle: yes, I think so :-)
02:40:27 <merijn> What's the correct spelling? Type checker, typechecker or type-checker?
02:40:42 <ivanm> chrisdone: I have a sneaking suspicion that the reason is I ignored the error buffer, and it kept sending messages to it or something
02:40:57 <chrisdone> ivanm: oh. yeah
02:41:04 <Itkovian> merijn: Type checker afaik.
02:41:14 <mayahustle> okay great, so i upgraded from snow leopard, and now gcc has been moved to some folder under /Developer.  Do you have to install the latest xcode to install the platform?
02:41:57 <merijn> mayahustle: I'm pretty sure that you should probably install the latest xcode regardless
02:41:59 <ivanm> chrisdone: one problem with -fobjects: if I want to load something that's inside the scope of a compiled file but not defined/exported there, I have to edit the file and force re-compiling it
02:42:29 <mayahustle> argh I wanted to avoid that.. all i have right now is my cell phone tether and 2.5 gigs... is daunting
02:42:34 <Itkovian> mayahustle: Hmm. I installed XCode from the app store iirc.
02:42:42 <ivanm> chrisdone: or maybe it's just that your buffer doesn't like QuickCheck...
02:42:46 <merijn> mayahustle: You don't have the Lion install DVD near you?
02:42:48 * osfameron has a look at http://blog.sigfpe.com/2006/12/tying-knots-generically.html
02:42:50 <ivanm> (as in it's busy running the QC test without the output)
02:43:00 <osfameron> it looks like the definitions already do knot-tying using lookup functions
02:43:03 <Itkovian> merijn: what DVD? It's an app store thingie, no?
02:43:05 <osfameron> so I'm not sure what the loeb is adding?
02:43:11 <mayahustle> no, i upgraded via the appstore
02:43:20 <merijn> Itkovian: XCode ships for free on all OSX install DVDs
02:43:20 <mayahustle> and it deletes the darn install file when your finished
02:43:23 <ivanm> Itkovian: XCode comes on the install DVD as well (except Air I think)
02:43:31 <chrisdone> ivanm: yeah that's a prob with fobject-code. maybe i should force recomp on the current file
02:43:39 <GoodAD> geekounet c'est une tapette qui c'est fait enculer et corrompre par niko, il faut soigner geekounet et lui purger l'anus pour qu'il retrouve le sourrir comme avant.
02:43:43 <merijn> Where as the app store xcode costs like $5, right?
02:43:57 <merijn> mayahustle: Ah, bummer
02:43:57 <mayahustle> I just checked and it says its free
02:44:06 <merijn> oh, maybe they changed that then
02:44:19 <GoodAD> avec 5$ je m'achete 12 paires de chaussettes
02:44:21 <mayahustle> yeah, i was just trying to avoid downloading 2.5 gigs over my cell phone
02:44:40 <mayahustle> thank god for unlimited data i guess
02:44:47 <merijn> mayahustle: Well, you could try without upgrading XCode
02:44:58 <merijn> I just have no idea whether that'll work :p
02:45:12 <Itkovian> merijn: yeah, but I have no recent mac that has _that_ XCode version
02:45:20 <mayahustle> I did, and it said i needed xcode installed, but xcode is installed it's the just the version from snow-leopard
02:45:32 <Itkovian> can somebody ban that idiot ^
02:45:48 <merijn> Itkovian: I think there's no ops around atm
02:46:08 <ivanm> and I forget the incantation for ignore :s
02:46:09 <merijn> mayahustle: Then your SOL, I guess
02:46:14 <shachaf> @where ops
02:46:14 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
02:46:16 <ivanm> (as in for my client)
02:46:18 <mayahustle> apparenlty the binary doesn't recognize the old version, because it seems lion moves all the old stuff to different folders under /developer
02:46:22 <ivanm> shachaf: even the spammer did that!
02:46:36 <mayahustle> haha seems so
02:46:44 <merijn> ivanm: Mine doesn't have an ignore (at least not using a sane command like /ignore), sucks >.>
02:46:59 <ivanm> merijn: xchat does; I just can't remember how to use it :s
02:47:06 <ivanm> have to use the IP address or something
02:47:23 <merijn> That's just dumb...
02:47:45 <mayahustle> thank you all for the help, guess I'll catch up on some reading :)
02:48:55 <merijn> New version of "code's compiling", "Why are you slacking?" 'XCode is downloading!'
02:51:37 --- mode: ChanServ set +o Heffalump
02:51:46 <ivanm> yay! an op!
02:51:59 <shachaf> Heffalump++
02:52:15 <ivanm> chrisdone: another thing: I just went and re-formatted all my source to match the new "indentation = 2 spaces" of haskell-mode, and now haskell-emacs doesn't do that! :p
02:52:18 <shachaf> A herrible Hoffalump!
02:52:27 <Heffalump> I haven't done anything yet! What should I do?
02:52:40 <Itkovian> We had some spam from Go[ou]dAD.
02:52:46 <Heffalump> but yes, I can be terribly herrible
02:52:50 <Itkovian> not too much, but annoying and offensive at times
02:53:09 <Heffalump> and in French, I see (looking over owst's shoulder)
02:53:23 <hvr> Heffalump: that's the 'offensive' part I guess.. :)
02:53:30 <Itkovian> Please unleash your op wrath. Thx.
02:53:33 --- kick: GoodAD was kicked by Heffalump (GoodAD)
02:53:48 --- mode: Heffalump set +b *!*@cust-21-115-109-94.dyn.as47377.net
02:53:53 --- kick: GoodAD was kicked by Heffalump (GoodAD)
02:54:38 <shachaf> A Hoffable Hellerump!
02:56:02 <Botje> any relation to kitten huffing?
03:04:09 <zhulikas> sup, haskellers
03:08:18 <ivanm> OK.... one of my QC tests failed, but when I try using the bad value to test the property by hand, it works :s
03:09:08 <ivanm> chrisdone: how do you do "cabal configure"; by hand in a terminal still?
03:21:08 <aninhumer> Is there a safe version of (!!)?
03:21:39 <aninhumer> Didn't find anything with hoogle
03:21:58 <gienah> aninhumer: atMay in safe (strangely not in hoogle)
03:23:03 <opqdonut> heh, pig latin
03:29:58 <ivanm> aninhumer: index
03:30:02 <ivanm> @type index
03:30:03 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
03:30:07 <ivanm> OK, not that...
03:30:14 <ivanm> @hoogle [a] -> Int -> a
03:30:15 <lambdabot> Prelude (!!) :: [a] -> Int -> a
03:30:15 <lambdabot> Data.List (!!) :: [a] -> Int -> a
03:30:15 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
03:30:17 <ivanm> @hoogle [a] -> Int -> Maybe a
03:30:18 <lambdabot> Prelude (!!) :: [a] -> Int -> a
03:30:18 <lambdabot> Data.List (!!) :: [a] -> Int -> a
03:30:18 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
03:30:24 <ivanm> huh, thought there was one...
03:30:38 <gienah> ivanm: yes, atMay in safe
03:30:53 <ivanm> aninhumer: safeIndex as n = listToMaybe $ drop (n-1) as
03:31:01 <ivanm> gienah: yeah, I thought there was one in the prelude
03:31:14 <ivanm> OK, wtf is going on that QC says something is False when I find it to be True? :s
03:35:54 * hackagebot fclabels 1.0.1 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.0.1 (SebastiaanVisser)
03:41:19 <chrisdone> ivanm: C-c C-c to cabal compile, C-c c to prompt for a cabal command
03:41:41 <ivanm> is configure interactive?
03:41:57 <chrisdone> nope?
03:42:01 <chrisdone> whaddayoumean
03:42:21 <ivanm> cabal configure
03:42:27 <ivanm> what happens if you want to pass flags?
03:43:08 <chrisdone> just type space and put the flags :)
03:44:10 <merijn> @tell danka Pulled the new source versions and recompiled everything. Te compilation fails on Mac/AppDelegate.h because it cannot find the protocol declarations, any suggestions what might be going wrong?
03:44:10 <lambdabot> Consider it noted.
03:45:54 <lewis1711> @src takeWhile
03:45:55 <lambdabot> takeWhile _ []                 =  []
03:45:55 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
03:45:55 <lambdabot>                    | otherwise =  []
03:46:36 <hpaste> jrockway pasted “a* is great for word games” at http://hpaste.org/50294
03:47:23 <jrockway> ivanm: so astar ends up being fine without fgl
03:47:33 <ivanm> OK
03:48:09 <kp> hi
03:48:26 <brisingr> hi
03:50:53 <Guest20686> a question: I'm using xmonad on ubuntu, right now if I'd open a program and then change the workspace, the program is openend in the current workspace, say I've called the command in workspace 1 and then changed to workspace 2, then it's opened in workspace 2. Is there any way to change this behaviour ? I'd like that the programm is opened in the workspace you've triggered the command.
03:51:42 <kamaji> I'm having trouble with the code described here http://learnyouahaskell.com/for-a-few-monads-more#state
03:51:58 <kamaji> I'm getting "Not in scope: Data constructor 'State'"
03:52:17 <kamaji> I've imported Control.Monad.State though
03:52:36 <kamaji> specifically this line: pop = State $ \(x:xs) -> (x,xs)
03:54:15 <lewis1711> @src takeWhile
03:54:15 <lambdabot> takeWhile _ []                 =  []
03:54:16 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
03:54:16 <lambdabot>                    | otherwise =  []
03:55:26 <merijn> Guest20686: Might wanna try the #xmonad channel instead, they know more about it
03:55:57 <Guest20686> thx
03:56:17 <lewis1711> where does the bot gets it src from? might be nicer instead of me spamming the channel ;)
03:56:47 <merijn> lewis1711: The source in lambdabot is not necessarily the actual source, it's from a database filled in by people
03:56:53 <leod> you can also query the bot, lewis1711
03:56:53 <merijn> The actual source is on hackage
03:57:16 <merijn> hmm, wrong button :p
03:57:24 <tech2> yup :)
03:57:35 <lewis1711> merijn: yeah I noticed why it looked nicer - better for my noob brain
03:57:41 <lewis1711> leod: query?
03:57:49 <merijn> lewis1711: Private message
03:57:58 <merijn> "/msg lambdabot @src takeWhile"
03:58:00 <lewis1711> humm tried that
03:58:17 <merijn> Also, you can search Hoogle and click on the documentation, that usually has a link to the source
03:58:26 <merijn> For example: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:takeWhile (source link on the right)
03:58:44 <lewis1711> oh he doesn't have dropWhile. that's the problem
03:58:47 <lewis1711> ohh, nice
03:58:58 <ddarius> @src dropWhile
03:58:58 <lambdabot> Source not found. There are some things that I just don't know.
03:59:04 <ddarius> Hmm
04:20:32 <brisingr> wow, silence? or buggy connection?
04:20:48 <ceii> silence it seems
04:20:52 <adrake_> looks like silence to me
04:20:56 <adrake_> well, looked :P
04:21:02 <brisingr> got scared for a second
04:21:39 <tech2> brisingr: have to poke edwardk, the silence is obviously his fault.
04:21:51 <brisingr> we can compensate
04:22:32 <brisingr> say, anu more cool code snippets (apart from ~/haskellwiki/Blow_your_mind)?
04:22:37 <brisingr> s/anu/any/
04:22:52 <mistertim> morning all
04:22:53 <preflex_>  mistertim: you have 1 new message. '/msg preflex_ messages' to read it.
04:23:21 <brisingr> morning
04:24:11 <mistertim> i was wondering - can anyone explain what "mkUsageInfo: internal name?" means when output by GHC? I'm getting  it on compiling some code of mine and don't fully understand what it denotes
04:24:44 <mistertim> it doesn't seem to result in an error, it's just logged to STDOUT during compilation
04:25:07 <ddarius> Sometimes I just can't believe Java.
04:25:15 <Botje> java believes in you!
04:25:25 <tech2> Botje: in Soviet Russia.
04:25:31 <tech2> Sorry, had to be said
04:25:59 <brisingr> whoa, silence is broken
04:37:15 <Phyx-> @info Ix
04:37:15 <lambdabot> Ix
04:37:24 <Phyx-> whoops
04:37:30 <Phyx-> i was scrolled way up
04:39:03 <ocharles> Awww, is there no way to do something like: runQuery :: Convertible a SqlValue => String -> [a] -> IO ()?
04:39:24 <ocharles> That so far means that all a's still have to be the same type, not the looser classification that they just all have to have an instance of Convertible a SqlValue
04:40:46 <ocharles> do I need existentially qualified types?
04:41:02 <Phyx-> @pl \a -> a `seq` a
04:41:02 <lambdabot> join seq
04:41:41 <mauke> Phyx-: id
04:42:46 <Phyx-> mauke: how come?
04:43:54 <Eduard_Munteanu> Just using a 'seq' there doesn't force any evaluation by itself. It merely means "when you look at 'a', first evaluate 'a'"
04:44:12 <ocharles> hrm, looks like I won't be able to get rid of my "toSql" calls everywhere. that's a shame
04:45:21 <Phyx-> Eduard_Munteanu: hmm ok
04:46:36 <chrisdone> ocharles: you can get rid of it if you make a class SqlParams a where toParams :: a -> [SqlValue]; and then instance (SqlValue a,SqlValue b) => SqlList (a,b) where toParams (a,b) = [toSql a,toSql b] and then you can write runQuery "select beans" (1,"apples")
04:46:41 <Eduard_Munteanu> ocharles: yeah, you might want a heterogenous collection. Can you use an ADT instead of your a's?
04:47:10 <ocharles> chrisdone: except that limits me to just exactly 2 parameters, or an instance for 3 parameters, or 4...
04:47:13 <ocharles> it sounds messy
04:47:27 <chrisdone> ocharles: not that messy. just implement up to 10 and then if you need more add more
04:47:44 <ocharles> hm
04:47:46 <chrisdone> another option is the printf-style
04:48:11 <chrisdone> :t printf
04:48:11 <ocharles> Eduard_Munteanu: it doesn't really give me much other than replacing "toSql" with a constructor
04:48:11 <lambdabot> forall r. (PrintfType r) => String -> r
04:48:12 * ivanm watches as ghc scrolls heaps of SpecConstr warnings all over his screen
04:48:36 <chrisdone> :t printf "x" () :: PrintfArg a => a -> String
04:48:37 <lambdabot>     No instance for (PrintfArg ())
04:48:37 <lambdabot>       arising from a use of `printf' at <interactive>:1:0-12
04:48:37 <lambdabot>     Possible fix: add an instance declaration for (PrintfArg ())
04:49:02 <chrisdone> meh i don't remember off the top of my head
04:49:10 * ocharles googles
04:49:23 <ocharles> chrisdone: this is in base?
04:49:26 <ivanm> why is ghc taking up so much memory? :/
04:49:29 <chrisdone> in Text.Printf
04:49:40 <chrisdone> maybe in base
04:49:45 <ocharles> yea
04:50:17 <chrisdone> SQL in this case is just a printf with different printing standards
04:50:47 <ivanm> I think GHC-7.0 hates data types with heaps of constructors even more than 6.12 did :s
04:52:38 <ocharles> :t printf "%s" "Hello"
04:52:39 <lambdabot> forall t. (PrintfType ([Char] -> t)) => t
04:52:58 <ocharles> :t printf "%s %s" "Hello" "Haskell"
04:52:59 <lambdabot> forall t. (PrintfType ([Char] -> t)) => t
04:54:12 <mauke> haskeline--
05:04:50 <sanjoyd> :t printf
05:04:51 <lambdabot> forall r. (PrintfType r) => String -> r
05:06:16 <buntfalke> Hi
05:06:31 <brisingr> hi
05:06:48 <buntfalke> I would like to print type information in a standalone program, as if with :info -- which function to use?
05:07:03 <buntfalke> Atm, I am stuck with this
05:07:04 <buntfalke> aufg1a.hs:7:34: Not in scope: `info'
05:07:06 <Botje> there are no more types at runtime
05:07:33 <buntfalke> Sooo...can I use a special compiler flag maybe? like "gcc -g" or so, to keep the information?
05:07:56 <buntfalke> I simply run "ghc -O --make foo.hs"
05:08:06 <ivanm> nope
05:08:09 <ivanm> it's all gone
05:08:25 <ivanm> maybe if you use the dynamic stuff or something, but that'd be about it I think
05:08:32 <ivanm> or maybe using the ghc-api...
05:08:39 <buntfalke> So how do ppl debug standalone haskell code.
05:08:49 <ivanm> ghci
05:08:49 <Botje> they open up ghci
05:08:56 <buntfalke> I see.
05:08:58 <chrisdone> you can do it with the ghc api but there's not a simple function to do it
05:09:06 <ivanm> chrisdone: yeah, what I figured
05:09:45 <chrisdone> tibbe worked a bit on such a thing. it'd be nice to have
05:09:59 <chrisdone> would make it easier for me to do fancy stuff in emacs
05:10:29 <chrisdone> i should really just learn the ghc api and then i can do whatever i want
05:10:36 <buntfalke> Okay...too bad, I imagined I could simply use {-# BEHAVE_AS_IF_INTERACTIVE #-} or --keep-all-debug-info or import Interactive or whatever :-)
05:10:58 <buntfalke> thanks gys
05:11:05 <buntfalke> +u...
05:11:08 <buntfalke> :-)
05:11:42 * chrisdone does the I'm Compiling GHC dance
05:11:44 <brisingr> import Happiness
05:11:46 <chrisdone> \o\
05:11:51 <chrisdone> |o/
05:12:06 <leod> keep dancing for 2 hours?
05:12:08 <Botje> chrisdone: if you keep that up during the whole compile, you'll get an AMAZING workout :)
05:12:19 <chrisdone> _o. "oh it's done"
05:12:29 <chrisdone> hehe
05:12:43 <Botje> I picture "_o." as a guy laying down in exhaustion
05:13:43 <ivanm> how does one specify -rtsopts in a .cabal file so that it won't trigger for ghc < 7 ?
05:14:03 <ddarius> I picture "_o." as an underscore followed by the letter 'o' followed by a period.
05:14:56 <chrisdone> ddarius: you're too deep, man
05:15:04 <shachaf> Postmodern.
05:15:06 <chrisdone> i feel like i should make a program that takes compiler output and renders an ASCII-art nyan cat flying through space but instead of a rainbow come out of its rear, it could be compiler output
05:15:50 <brisingr> technicolor compile cat? sounds like a new meme
05:16:30 * chrisdone looks at the ncurses package, tempted
05:17:14 <Botje> chrisdone: well, you can mod the (iirc win 7) progressbar to be nyan cat
05:17:20 <Botje> that's a start :)
05:20:55 <b0fh_ua> Hi! Can you please explain how should I add some UTF-8 constants to Haskell source in order to make them be recognized as UTF strings?
05:20:55 * hackagebot tiger 1.1 - Tiger Compiler of Universiteit Utrecht  http://hackage.haskell.org/package/tiger-1.1 (ArieMiddelkoop)
05:20:57 * hackagebot uuagc-cabal 1.0.0.5 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.0.5 (ArieMiddelkoop)
05:23:36 <ivanm> b0fh_ua: ummm.... write them?
05:23:45 <ivanm> just make sure your source file is utf-8
05:24:00 <ivanm> then: utf8String = "слова", etc.
05:24:15 <ivanm> to force utf-8 output for strings, use either utf8-string or Text
05:24:24 <b0fh_ua> okay, I did in that way - but when trying to submit the data to HTTP server - I am seeing some garbage in protocol dump
05:24:31 <b0fh_ua> perhaps this is a problem with curl...
05:26:26 <buntfalke> How come this works "putStrLn $ show $ add 2 3" but this iterator-function doesnt "it f n = f $ it f (n-1)"? I know the it-Function would need .-composition, but I do not know why.
05:26:45 <buntfalke> How do $ and . differ? I didn't quite get that from the report...
05:27:27 <brisingr> . is function composition, $ acts like an open paranthesis
05:27:45 <buntfalke> From the definition, "f $ x = f x" looks equal to "f . g = \ x -> f (g x)" for me in this case
05:28:20 <brisingr> hmm
05:28:43 <buntfalke> brisingr: Aye, so what's bad with "f(f(f...<n times>))) x". It's opening parenthesis.
05:28:59 <buntfalke> x within those, of course.
05:29:17 <ivanm> buntfalke: if you had x, it would work
05:29:22 <ivanm> but you're returning a function
05:29:29 <ivanm> so you should use: it f n = f . it f (n-1)
05:30:01 <buntfalke> I see, so it f n x = f $ it f (n-1) $ x should be okay? /me goes test it
05:30:05 <buntfalke> ivanm: thx!
05:37:06 <buntfalke> Yes, this way "it' f n x = it' f (n-1) $ f x" it's just fine. Good to kow.
05:40:55 * hackagebot GenericPretty 1.1.6 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-1.1.6 (RazvanRanca)
06:22:04 <chrisdone> haha, nice. my nice emacs thingie triggered while dev'ing, and I happy faced
06:22:23 <chrisdone> Can't make a derived instance of `MonadReader …   Add {-# LANGUAGE GeneralizedNewtypeDeriving #-} to the top of the file? (y or n)
06:23:44 <Axman6> heh, nice
06:32:13 * ivanm is still waiting for that guide from chrisdone...
06:32:14 <ivanm> :p
06:32:48 <chrisdone> ivanm: you want to know specifically how to use cabal-dev with it?
06:33:09 <ivanm> I think that's the main thing I've got left to figure out, yes
06:33:48 <ivanm> don't recall if I told you this before, but your fancy import stuff doesn't seem to work :(
06:34:04 <chrisdone> whaddaytalkinabout
06:34:08 <parcs> why is split useful when passing an RNG down to recursive calls? why not just recursively thread the same state? http://hackage.haskell.org/packages/archive/random/1.0.0.3/doc/html/src/System-Random.html#split
06:34:18 <chrisdone> f8 goes to the imports, C-cC-. sorts them
06:34:23 <ivanm> chrisdone: F8 takes me to the top of file, not to the import list
06:34:34 <ivanm> C-c C-. sorts them, but doesn't do the formatting (gives an error message)
06:34:45 <chrisdone> what error message?
06:35:00 * ivanm swears ghc-7 has regressions when compiling files with datatypes with >100 constructors
06:35:06 <shurikas> @src (+)
06:35:07 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
06:35:13 <Axman6> ivanm: .................
06:35:17 <Axman6> o.O
06:35:36 <ivanm> chrisdone: OK, it's mysteriously working now...
06:35:50 <chrisdone> yeah, that's what I thought  >_>*evil eyes*
06:36:26 <chrisdone> http://images.cheezburger.com/completestore/2011/4/8/93103934-f693-4955-80d5-9303fcd5b8e7.jpg
06:37:28 <ivanm> chrisdone: it's not perfect: if the import list is multi-lined, then it doesn't indent subsequent lines
06:38:03 <chrisdone> ivanm: yeah. why you got multi line imports, you got no sense! :P
06:38:12 <chrisdone> (it's a bug i haven't fixed yet0
06:38:30 <ivanm> OK
06:40:16 <ivanm> Axman6: http://hackage.haskell.org/packages/archive/graphviz/2999.11.0.0/doc/html/Data-GraphViz-Attributes.html
06:40:25 <ivanm> also Colors
06:40:44 <Axman6> heh, i see
06:41:04 <Axman6> seems to me there's better ways to implement that, but you probably get more safety that way
06:41:16 <ivanm> on my uni machine with 6.12.3, it takes about 5-6 min to compile the latest version; on my core i7 with 7.0, it takes about 20min :s
06:41:28 <ivanm> Axman6: yeah, and there's some auto-generation involved as well
06:41:46 <ivanm> Axman6: that said, that is no longer the main interface
06:41:49 <dafis> ivanm: bug filed?
06:42:00 <ivanm> in the current version, that module exports a simplified sub-set
06:42:09 <ivanm> dafis: not yet; haven't verified that that is indeed the case
06:42:17 <ivanm> need to get this working first :p
06:42:59 <ivanm> I think it's to do with the SpecCOnstr stuff
06:43:58 <dafis> ivanm: likely, that'll have a long run with > 100 constructors
06:44:19 <ivanm> it also chews up RAM
06:44:27 <Axman6> ivanm: ask in #ghc
06:44:30 <dafis> ivanm: try compiling with -fno-spec-constr to verify
06:44:34 <Axman6> find out if it's worth filing a bug
06:44:40 <ivanm> Axman6: I have
06:44:42 <ivanm> no response yet
06:44:51 <ivanm> dafis: hmmm.... that's not a bad idea
06:44:52 <Axman6> well, it is a sunday
06:45:16 <ivanm> Axman6: it's actually monday already ;)
06:45:28 <Axman6> ivanm: in those docs, should ([' ', :, '\t']) be ([' ', ':', '\t'])?
06:45:30 <chrisdone> ivanm: where are you?
06:45:30 <dafis> ivanm: not in Cambridge
06:45:33 <Axman6> ivanm: not where the devs are
06:45:39 <Axman6> chrisdone: canberra
06:45:40 <ivanm> chrisdone: land down under
06:45:53 <ivanm> Axman6: ahhh, probably
06:45:58 <ivanm> ta
06:46:28 * dafis just smiles and gives him a vegemite sandwich
06:46:59 <Axman6> om nom nom
06:48:23 <ivanm> Axman6: heh, turns out that that part of the documentation no longer applies
06:48:30 <ivanm> hey, leave some yeasty goodness for me!
06:48:30 <tarrasch> When using functions from System.Process, like rawSystem, Can one do shell-injections so that I better escape all input (I let the users supply the input)?
06:49:05 <tarrasch> The documentation says alot, but I'm not certain I follow what they mean
06:49:31 <mauke> tarrasch: rawSystem doesn't use a shell
06:49:32 <ivanm> Axman6: one of the changes I've made is that it now has a state-based printer/parser
06:49:50 <tarrasch> mauke, byt system does?
06:50:12 <mauke> Computation 'system cmd' returns the exit code produced when the operating system runs the shell command cmd.
06:50:14 <Axman6> ivanm: one you wrote?
06:50:15 <mauke> ... yes
06:50:17 <tarrasch> I'm mostly interested in readProcessWithExitCode, but I guess it doesn't use either if rawSystem doesn't
06:50:47 <tarrasch> doens't use the shell*
06:51:02 <ivanm> Axman6: well, the parser is from polyparse and was already stateful (though I helped debug the Text-based one); the printer is just State over my wl-pprint-text library
06:51:20 <Axman6> righto
06:52:08 <ivanm> using Text leads to better perfoamnce
06:52:19 <ivanm> using State makes it slightly slower, but nowhere near as much
06:58:05 <ivanm> dafis: well, that definitely seemed to have an affect
06:58:45 <dafis> ivanm: how big, roughly?
06:58:54 <DevHC_> is there a reason why ghc shouldn't quit when signaled (killall ghc)?
06:59:42 <Axman6> because signals are in IO, and we can't have that!
07:00:16 <DevHC_> ????
07:00:28 <hpc> DevHC_: the same reason other things don't kill when signaled?
07:00:35 <hpc> (signalled?)
07:00:49 <dafis> DevHC_: doing cleanup perhaps? try killall -KILL
07:00:55 <benmachine> (I think signalled is british english)
07:00:57 <parcs> both spellings are correct according to aspell
07:01:16 <benmachine> (or, we usually double consonants you don't)
07:01:41 <DevHC_> hpc, dafis: no
07:02:22 <DevHC_> ghc quits when signaled, except when ghc is calling another process, via rawSystem
07:02:36 <ivanm> there's still some increase in build time, but that could just be because it's doing more work
07:03:04 <dafis> ivanm: have a 6.12 around to compare?
07:03:09 <ivanm> I do on another machine
07:03:49 <ivanm> the current builds aren't _quite_ the same, but on the older machine with 6.12 it takes about 6 min; on this one it takes about 9 min with an i7 and 7.0
07:06:13 <DevHC_> shall i submit a bug report "ghc forgets to die when killed during execution of another process?"
07:06:41 <DevHC_> -?" +"?
07:06:53 <Entomy> might the bug be elsewhere?
07:07:09 <DevHC_> doubtfully
07:07:16 <DevHC_> but might not be a bug
07:07:48 <mauke> http://www.eatliver.com/img/2009/4309.jpg
07:09:07 <DevHC_> TL;DR
07:10:15 <DevHC_> meh, ghci doesn't die if it's executing an IO action when a signaled
07:10:27 <DevHC_> just stops the execution
07:10:55 <DevHC_> however, ghci doesn't even stop executing the full action when in a system/rawSystem call
07:12:44 <benmachine> DevHC_: which GHC version?
07:13:30 <benmachine> personally if I signal a ghci session running rawSystem "/usr/bin/sleep" ["10"]
07:13:37 <benmachine> then it says something like
07:13:40 <ivanm> chrisdone: aha! found a file where F8 took me to the top of the file rather than the import list! mwahahahaha!
07:13:41 <benmachine> ghc: signal: 15
07:13:46 <benmachine> and then returns me to the prompt
07:13:50 <DevHC_> 7.0.3
07:14:06 <benmachine> but it looks like the underlying process carries on because a few seconds later it prints ExitSuccess anyway
07:14:11 <benmachine> I'm on 7.2.1
07:14:14 <DevHC_> benmachine: yes, ind33d
07:14:41 <benmachine> what you *want* ghci to do when signalled is not entirely clear
07:14:48 <benmachine> it might or might not be a bug
07:15:04 <DevHC_> in fact i found it weird that the system slowed down after i ran writeFile "/dev/null" $ repeat 'a'
07:15:18 <DevHC_> (and signaled ghc to die)
07:15:53 <Axman6> o.O
07:16:32 <DevHC_> in case of an interrupt signal, ghci could back out to the prompt
07:16:39 <DevHC_> but in case of a sigkill?
07:16:48 <Axman6> i wonder if writeFile "/dev/null" . fromChunks . cycle $ [pack . replicate 1024 $ 'a'] would do the same thing
07:17:44 <benmachine> in the case of a KILL, ghc dies immediately
07:17:53 <DevHC_> sigterm*
07:17:59 <benmachine> oh
07:18:10 <benmachine> well, sometimes you run whole programs from ghci
07:18:10 <DevHC_> i am the terminator
07:18:13 <DevHC_> u r ghc
07:18:17 <DevHC_> u r going to die if i say so
07:18:22 <benmachine> send two terms
07:18:23 <benmachine> sorted
07:18:30 <benmachine> or send a kill if you're that picky
07:18:41 <DevHC_> kill is naughty ya know
07:18:55 <benmachine> kill is what it says it is
07:30:47 <pr> @hoogle a -> a
07:30:47 <lambdabot> Prelude id :: a -> a
07:30:47 <lambdabot> Data.Function id :: a -> a
07:30:47 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
07:36:55 * edwardk waves hello.
07:37:12 * byorgey waves back
07:37:57 * Axman6 waves frantically
07:38:10 <edwardk> sitting here trying to encode a direct (constructor based) parser after living in continuation-land so long. it is so verbose! all these names. ack
07:38:16 <parcs> do type classes/methods have to be explicitly set it the export list to have them exported?
07:38:37 <edwardk> parcs: classes and methods do, instances go along for free
07:38:47 <parcs> okay
07:38:58 <edwardk> well, if you have an export list that is, otherwise they go along with everything else
07:39:28 <Axman6> that's why you sometimes get warnings from ghc saying that an import is unused, you might want to import it with import Foo () to get access to class instances
07:40:13 <increpare> trying to install FiniteMap via cabal, and getting the error "cannot satisfy -package Cabal-1.10.2.0:" (due to the missing or recursive dependencies "process-1.0.1.5-3e412eee765d141be15796c32f22f7a3") (full error here : http://hpaste.org/50295 )
07:40:39 <shurikas> @src null
07:40:39 <lambdabot> null []     = True
07:40:40 <lambdabot> null (_:_)  = False
07:40:56 * hackagebot heist 0.5.3 - An xhtml templating system  http://hackage.haskell.org/package/heist-0.5.3 (DougBeardsley)
07:41:34 <pr> @hoogle True
07:41:34 <lambdabot> No results found
07:42:30 <shurikas> @src reverse
07:42:31 <lambdabot> reverse = foldl (flip (:)) []
07:42:36 <shurikas> :o
07:43:50 <pr> > let reverse [] = []; reverse (x:xs) = reverse xs ++ [x] in reverse "abcd"
07:43:52 <lambdabot>   "dcba"
07:44:21 <Axman6> you're a monster
07:44:25 <pr> haha
07:46:47 <shurikas> @src takeWhile
07:46:47 <lambdabot> takeWhile _ []                 =  []
07:46:48 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
07:46:48 <lambdabot>                    | otherwise =  []
07:48:09 <DevHC_> is there a way to use the standard input as a binary input file?
07:48:25 <DevHC_> (in ghc >=7)
07:48:33 <Axman6> sure, use hGetContents stdin i assume
07:48:41 <DevHC_> that sux
07:48:43 <Axman6> and you can set the handle's mode to binary
07:48:50 <DevHC_> o
07:48:51 <DevHC_> how
07:48:59 <Axman6> um
07:49:00 <byorgey> increpare_: what version of GHC are you using?
07:49:04 <DevHC_> 7.0.3
07:49:06 <aavogt> @hoogle hset
07:49:06 <lambdabot> System.IO hSetBinaryMode :: Handle -> Bool -> IO ()
07:49:07 <leod> does HDBC provide any function to get the rowid from the last insert?
07:49:07 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
07:49:07 <lambdabot> System.IO hSetEcho :: Handle -> Bool -> IO ()
07:49:08 <Axman6> @hoogle Handle
07:49:08 <lambdabot> System.IO data Handle
07:49:08 <lambdabot> Control.Exception handle :: Exception e => (e -> IO a) -> IO a -> IO a
07:49:09 <lambdabot> Control.OldException handle :: (Exception -> IO a) -> IO a -> IO a
07:49:09 <DevHC_> nvm
07:49:15 <increpare_> byorgey: 7.0.4
07:49:33 <byorgey> increpare_: also, why are you trying to install FiniteMap?
07:49:40 <DevHC_> kthx
07:50:21 <increpare_> I think having an associative array to hand would make code neater (at the moment I'm tossing around things of type [(a,b), using a as a key]
07:50:39 <increpare_> (bracket mismatch…oops)
07:50:55 * hackagebot yesod-comments 0.4.0 - A generic comments interface for a Yesod application  http://hackage.haskell.org/package/yesod-comments-0.4.0 (PatrickBrisbin)
07:51:07 <shurikas> @src notElem
07:51:07 <lambdabot> notElem x =  all (/= x)
07:51:10 <Kaidelong> is there a haskell datatype somewhere for values between 0 and 1
07:51:42 <benmachine> Kaidelong: tricky. what happens when you add 0.75 and 0.75?
07:51:59 <DevHC_> /dev/stdin: openBinaryFile: invalid argument (Bad file descriptor)
07:52:00 <DevHC_> hmm has anyone ever seen this?
07:52:09 <byorgey> increpare_: Finite Map is super deprecated
07:52:16 <dafis> increpare_: why not use Data.Map?
07:52:26 <increpare_> byorgey: ok.  is there something else that has similar functionality?
07:52:27 <Kaidelong> you get 0.9375
07:52:41 <Axman6> increpare_: Data.Map
07:52:58 <increpare_> ah
07:53:05 <pr> Kaidelong: why would you get 0.9375
07:53:08 <increpare_> Axman6: dafis: byorgey  . yes.  yes that's much better.
07:53:11 <increpare_> thanks : )
07:53:18 <Axman6> increpare_: what type are your keys?
07:53:29 <Kaidelong> 0.75+(1-0.75)*0.75
07:53:41 <Axman6> if they're Int, then Data.IntMap may be better
07:54:20 <increpare_> Axman6: they're graphs (not Data.Graph, a custom variant)
07:54:29 <byorgey> increpare_: you ought to use Data.Map (from the containers package) instead
07:54:47 <increpare_> will do
07:54:50 <increpare_> thanks
07:55:20 <byorgey> increpare_: you ought to use Data.Map (from the containers package) sorry, I have a lot of lag
07:55:24 <Kaidelong> multiplication would be the same as floating point multiplication I think
07:55:51 <Kaidelong> err, as in the meaning, not as in the implementation neccessarily
07:55:55 * hackagebot haskell-mpi 1.1.0 - Distributed parallel programming in Haskell using MPI.  http://hackage.haskell.org/package/haskell-mpi-1.1.0 (DmitryAstapov)
07:56:10 <Kaidelong> oooh
07:56:15 <Kaidelong> does Haskell-MPI have docs yet
07:56:25 <Kaidelong> I mean other than the ones in the source code
07:56:31 <Kaidelong> doesn't look like it
07:56:47 <Axman6> it's intended for people who know how to use MPI
07:57:26 <Kaidelong> well I pieced together my haskell MPI program for my class by reading docs in the haskell MPI source code
07:57:50 <Axman6> MPI's not that difficult to understand
07:57:51 <Kaidelong> which struck me as a bit silly but it worked well enough for me not to complain
07:57:57 <Axman6> LLNL has some very good docs on it
07:58:28 <Axman6> I believe it's very much designed as a wrapper around the MPI spec
07:58:44 * Kaidelong remembers when he used to get annoyed at how bad Microsoft's documentation was compared to Sun's
07:58:46 <Axman6> t's like HOpenGL in that respect
07:59:19 <Kaidelong> Hmm, not sure how HOpenGL works
07:59:39 <Kaidelong> but the way I percieved it is that you wrote your MPI program as a function from rank and size to IO
07:59:44 <Axman6> ah, and also, it wont have docs on hackage because to compile, it needs MPI installed, so the build fails
07:59:45 <Kaidelong> not at all unlike how you do it in C
07:59:54 <Kaidelong> although the functional nature of it is exposed
08:00:04 <Kaidelong> oh okay that explains it
08:00:05 <minh> I have a function which looks something like Foo :: (MyTypeclass t) => t -> t . This works fine with using functions, which instances of Foo implement. But there is a point inside Foo, where I need to pattern-match on the type, which GHC declares as an error! Can someone please give me a hint on this problem?
08:00:09 <Kaidelong> it looked like it had haddock docs
08:00:16 <Kaidelong> but hackage didn't show any docs for it
08:00:40 <Kaidelong> now it makes sense Axman6
08:00:41 <Axman6> minh: you'll have to give an example or something to make that question clear
08:00:53 <ddarius> Even if you write nothing, Hackage will produce haddock documentation for it unless the build fails.
08:00:57 <Axman6> minh: type classes are how we do pattern matching on types in haskell
08:01:14 <Botje> minh: pattern matching is for values, not for types
08:01:24 <minh> Axman6: give me a second! I'll post a minimal code-sample
08:01:28 <Kaidelong> ddarius: I wonder if that's a good thing. It may be desirable to be able to generate the docs even if the build fails.
08:01:38 <Kaidelong> even if you force the developer to write the docs
08:01:40 <ddarius> Kaidelong: It is desirable.
08:01:48 <Axman6> it kind of annoys me that even if the build fails it won't generate the docs
08:02:30 <Axman6> ddarius: do you mean it's desirable for the docs not to be generated if the build fails?
08:02:31 <Kaidelong> I really like what the .NET people did with code documentation
08:02:37 <Kaidelong> it's ugly and verbose but it works really nicely
08:03:25 <minh> The problem is, that inside Foo :: (MyTypeclass t) => t -> t, some instances t of 'MyTypeclass t' have to be treated somewhat special. How to manage that?
08:03:38 <parcs> > replicate (-1) ()
08:03:38 <lambdabot>   []
08:04:46 <parcs> bounds checking is for sissies
08:04:46 <ddarius> Axman6: No.
08:04:54 <Axman6> ok
08:05:11 <mekeor> @src replicate
08:05:11 <lambdabot> replicate n x = take n (repeat x)
08:05:12 <Axman6> parcs: do you prefer Exception: Segmentation Fault? :P
08:05:17 <ddarius> Part of the reason this happens is that Haddock uses type information that won't be available if the build fails.
08:05:29 <Axman6> ah :\
08:05:31 <aavogt> Axman6: sometimes docs depend on being able to load the code, such as definitions written by template-haskell or if you leave out type signatures
08:06:04 <hpaste> christo pasted “14” at http://hpaste.org/50298
08:06:14 <christo_m> I dont know what im doing wrong here
08:06:20 <Kaidelong> @hoogle fuzzy
08:06:21 <lambdabot> No results found
08:06:21 <mekeor> > replicate (-1) 5
08:06:22 <lambdabot>   []
08:06:33 <christo_m> it keeps expecting Int against inferred type (Int,[Int])
08:06:58 <Botje> christo_m: yes. you are comparing length (snd x) against maxtail
08:07:03 <Botje> which is of type (Int, [Int])
08:07:16 <christo_m> should it be snd maxTail?
08:07:30 <Botje> no, that's of type [Int]
08:07:33 <edwardk> Axman6 the docs for things like http://hackage.haskell.org/packages/archive/type-int/0.5.0.1/doc/html/Data-Type-Hex-Stage1.html used to just not work at all now they can generate all umpteen thousand instances and read them out of the .hi file
08:07:42 <edwardk> and you get fewer strand errors out of haddock
08:07:46 <edwardk> er strange
08:08:16 <Axman6> edwardk: ... you're a monster D:
08:08:18 <Axman6> :P
08:08:35 <edwardk> it compiles =)
08:08:59 <Axman6> so does windows
08:09:13 <aavogt> edwardk: why use / write that library over type-level?
08:09:13 <christo_m> length $ snd x > length $ snd maxTail = x  doesnt work either
08:09:17 <christo_m> hmm
08:09:28 <edwardk> aavogt: type-level didn't exist when i wrote it
08:09:44 <Botje> christo_m: you want to take care with $ here
08:09:58 <brbr> what would code look like to measure max throughput of a haskell http server?
08:10:20 <edwardk> also those are 2s complement, so things like Pred are total
08:10:24 <ddarius> Botje: You mean $ isn't a magical "put the parentheses how I want them" operator?
08:10:27 <edwardk> (and 16s complement)
08:10:28 <Botje> christo_m: length (snd x) > length (snd maxTail)
08:10:46 <Botje> ddarius: Haskell should be more DWIM-compatible
08:10:50 <Axman6> brbr: i'd use something that already exists. i'd recommend either apachebench or whatever it's called if it's HTTP, or you can use pipeviewer (also known as pv)
08:11:09 <edwardk> otherwise, i think type-level is a pretty clean design
08:11:23 <christo_m> Botje: ya i just tried that and it worked, i thought length $ snd x == length (snd x)
08:11:44 <brbr> Axman6: right. thanks
08:12:09 <Axman6> brbr: the reason i say that is that it's actually something that's quite difficult to get right, in any language
08:12:28 <Axman6> although, apparently it's quite easy in Esterele =)
08:12:28 <edwardk> wow the first release of type-int was before i moved to comonad.com
08:12:33 <benmachine> christo_m: depends on context. length $ snd x > r == length (snd x > r)
08:21:04 <mekeor> not using exitSuccess, does a haskell-programm always (if it succeeds) exit with success (0) ?
08:21:25 <mauke> yes
08:21:30 <mekeor> mauke: thanks.
08:21:50 <mauke> the runtime code does the equivalent of 'main >> exitSuccess'
08:21:51 <edwardk> unless you tell it to exit with something else, yes
08:22:27 <Martty> conspicuous
08:27:44 <mekeor> (how) can i replace the 'eval'-function in https://github.com/MekeorMelire/hascal/blob/master/Hascal.hs with a fold ?
08:40:01 <brbr> On a fresh debian server, I just did an `sudo apt-get install haskell-platform'. OK. Now `sudo cabal update' ==> "Note: there is a new version of cabal-install available. To upgrade...". OK. Now `sudo cabal install cabal-install'...
08:40:35 <Axman6> you likely need to add ~/.cabal/bin to your PATH
08:40:37 <brbr> and then "cabal: Error: some packages failed to install: cabal-install-0.10.2 failed during the building phase. The exception was: ExitFailure 9"
08:40:41 <brbr> and that's all
08:41:02 <brbr> I see some warnings in the compiling phase, but no errors
08:41:12 <dafis> brbr: whcih ghc/platform version is that?
08:41:20 <dcoutts__> brbr: does it say Linking... and then fail after that?
08:41:24 <brbr> debian stable
08:41:49 <brbr> ghc --version is 6.12.1
08:41:55 <benmachine> you don't want to use sudo with cabal update or cabal install, do you?
08:42:18 <benmachine> I mean it's probably not the problem
08:42:20 <brbr> dcoutts__: yes it does fail right after "Linking dist/build/cabal/cabal ..."
08:42:36 <dcoutts__> brbr: it's running out of memory and being killed by the OOM killer
08:42:47 <dcoutts__> brbr: guessing your server has ~500Mb ram?
08:42:58 <brbr> dcoutts__: yep, linode
08:43:07 <brbr> am I.. SOL?
08:43:35 <dcoutts__> brbr: linking ghc stuff makes the linker cry, you'll find it better to compile on your desktop and upload binaries
08:45:34 <brbr> anyone know approx how much memory required to do this linking for cabal?
08:46:08 <dcoutts__> brbr: it's not just cabal, you'll find the same with more or less any ghc-compiled prog
08:46:10 <brbr> I do not have an amd64 box handy to build on and upload to my server
08:46:28 <dcoutts__> brbr: about ~500mb is quite common
08:46:55 <dcoutts__> brbr: it's possible to do a special build of ghc that uses less memory for linking static libs
08:47:04 <dcoutts__> but it's a bit of a pain to do so
08:47:29 <dcoutts__> brbr: you can also try just closing down other stuff and trying again
08:51:25 <increpare> when I have lots of modules loaded in ghci, the prompt can get a bit wide - is there a way to narrow it down?
08:51:32 <ion> :set prompt
08:51:44 <increpare> ion: thx
08:54:32 <Philonous_> What was the package containing the implementation of monad zipper called?
08:55:46 <Philonous_> Never mind, it was monatron (why is it that you will always find it as soon as you ask for it on IRC)
09:00:56 * hackagebot dataenc 0.14.0.2 - Data encoding library  http://hackage.haskell.org/package/dataenc-0.14.0.2 (MagnusTherning)
09:01:16 --- mode: Heffalump set -o Heffalump
09:10:15 <linduxed> is there such a thing as "gofmt for haskell"?
09:11:06 <pr> http://stackoverflow.com/questions/6870148/is-there-a-haskell-code-formatter
09:11:37 <linduxed> pr: thx, that answers it i think
09:12:46 <Eataix> :reload
09:13:30 <zomg> Would anyone happen to know if the GHC compiler API can produce values from dynamic calls in other ways than using unsafeCoerce?
09:14:01 <zomg> eg. when you do val <- compileExpr ....; let val' = (unsafeCoerce val) :: SomeType
09:15:49 <mekeor> is (:) a function or a primitive?
09:16:00 <mekeor> or both?
09:16:04 <mekeor> @hoogle (:)
09:16:05 <lambdabot> Data.Complex (:+) :: a -> a -> Complex a
09:16:05 <lambdabot> Data.Sequence (:<) :: a -> Seq a -> ViewL a
09:16:05 <lambdabot> Control.Parallel.Strategies (:=) :: a -> b -> Assoc a b
09:16:07 <byorgey> zomg: no
09:16:11 <peteriserins> what would one have to read to get to the point where one could contribute to GHC?
09:16:29 <byorgey> mekeor: what's the difference?
09:16:48 <ben> Isn't it a constructor if anything
09:16:58 <zomg> byorgey: I see... Is it possible to do something like "runFn :: String -> a -> IO a" which runs the String using compileExpr, coercing to "a"?
09:17:03 <mekeor> byorgey: AFAIK, a primitive is a part of a language, isnt it?
09:17:14 <mekeor> byorgey: i can't find (:) with hoogle...
09:17:33 <byorgey> zomg: sure
09:17:48 <mauke> @src []
09:17:48 <lambdabot> data [] a = [] | a : [a]
09:17:57 <mekeor> byorgey: i can't find it in the Prelude
09:18:12 <mauke> it's part of the definition of [], which is built into the compiler
09:18:25 <mauke> but only because [] has special syntax; otherwise it's a normal type
09:18:46 <zomg> byorgey: should just doing "(unsafeCoerce val) :: a" work? I'm not entirely sure, because for example how would I use "Bool" as "a", since Bool has only True and False as constructors
09:19:05 <mekeor> mauke: whom did you talk to?
09:19:09 <aavogt> in ghc at least you aren't allowed to define a constructor :   but  :%^&  is allowed
09:19:51 <byorgey> zomg: I don't understand the question.  What do Bool
09:19:59 <byorgey> 's constructors have to do with it?
09:20:14 <zomg> Maybe I'm misunderstanding it. Let me hpaste the code, maybe it clarifies it a bit
09:20:44 <byorgey> zomg: if all you want to do is dynamically interpret expressions, I would recommend using the 'hint' package instead of the GHC api directly
09:21:57 <zomg> byorgey: okay, I'll take a look at that
09:22:01 <zomg> Thanks
09:23:22 <zomg> And I spent ages figuring out the GHC API...
09:23:22 <zomg> :D
09:23:32 <zomg> Oh well, at least I think I learned something while doing that =)
09:27:31 <Ptival> @type [1, [2, 3]]
09:27:32 <lambdabot> forall t. (Num [t], Num t) => [[t]]
09:27:36 <Ptival> care to explain? ^
09:27:44 <mauke> which part?
09:27:45 <dante> in:
09:27:54 <dante> let xs' = IntSet.filter (>= IntSet.findMin ys) xs
09:28:03 <dante> is IntSet.findMin compute n times?
09:28:12 <Ptival> well, how 1 and [2, 3] are considered the same type?
09:28:22 <mauke> Ptival: well, they have to be, obviously
09:28:30 <mauke> Ptival: they're elements of the same list, after all
09:28:33 <Ptival> sure
09:28:44 <mauke> dante: unlikely
09:28:56 <dante> how can one best go about reasoning about it?
09:29:09 <linduxed> hmmm, when i try to compile a code formatter, i get Could not find module `Language.Haskell.Exts.Pretty'
09:29:20 <linduxed> is it because i might not have Exts?
09:29:56 <Ptival> mauke: so it tries to find a typeclass that is satisfied by both parts of the cons ?
09:30:15 <byorgey> linduxed: that module is probably provided by the haskell-source-exts package
09:30:17 <mauke> Ptival: huh?
09:30:18 <Ptival> not sure how the type is determined
09:30:22 <mauke> it just does standard type inference
09:30:28 <linduxed> byorgey: will check that out then
09:30:31 <byorgey> linduxed: er, sorry, haskell-src-exts
09:30:36 <mauke> Ptival: the type of number literals is (Num a) => a
09:30:48 <mauke> Ptival: so [2, 3] :: (Num a) => [a]
09:31:09 <mauke> Ptival: 1 :: (Num b) => b
09:31:29 <mauke> Ptival: and since typeof 1 == typeof [2, 3], we get b = [a]
09:31:39 <Ptival> yes by unification
09:31:49 <mauke> that means (Num a, Num [a]) => [[a]] for the whole thing
09:32:00 <hpaste> 14 pasted “christo” at http://hpaste.org/50299
09:32:09 <christo_m> I dont think im doing things the haskell way
09:32:16 <christo_m> im not sure why this is so slow
09:33:44 <c_wraith> nothing's wrong with your approach, in terms of being idiomatic haskell or not
09:33:50 <c_wraith> that's just a really slow way to solve the problem
09:34:53 <c_wraith> oh, nevermind, there *is* something wrong.
09:35:08 <c_wraith> you're re-calculating the length of the lists in findMax many times
09:35:19 <c_wraith> length is O(length of list)
09:35:19 <christo_m> c_wraith: i guess i better get smarter then.
09:35:19 <c_wraith> so re-calculating it should be avoided
09:36:07 <christo_m> c_wraith: length is 0??
09:36:09 <elliott> Is there any way to access the cabal version number of my package from within its code? I don't really want to litter my code with multiple things to change every update
09:36:19 <c_wraith> christo_m: oh, you have no CS background?
09:36:43 <c_wraith> christo_m: let me phrase it as "calculating the length requires walking the entire list.  That means it's a slow operation"
09:36:55 <christo_m> c_wraith: right, i understand that.
09:37:00 <byorgey> elliott: ISTR there is
09:37:07 <aavogt> elliott: import Paths_yourPackageName
09:37:10 <christo_m> c_wraith: what would be a more elegant way to find the maximum list in a list of lists.
09:37:18 <byorgey> elliott: cabal generates a special module you can import
09:37:19 <christo_m> maximum length list*
09:37:21 <elliott> aavogt: Ouch, ugly package name... but OK
09:37:26 <elliott> Any documentation on its contents?
09:37:41 <byorgey> elliott: have you looked in the cabal documentation?
09:37:50 <elliott> byorgey: That's what I've been doing :P
09:37:54 <tibbe> is that website with hackage reverse deps still live somewhere?
09:38:12 <elliott> The only thing about Paths_ seems to be getDataFileName :: FilePath -> IO FilePath
09:38:13 <aavogt> elliott: it's probably quickest just to read it... cabal puts it in  dist/build/autogen/
09:38:14 <christo_m> c_wraith: what im doing is comparing the length of the head with the length of the tail lists, recursively
09:38:17 <elliott> tibbe: cab does that
09:38:23 <elliott> tibbe: I wondered the same thing a few days ago
09:38:27 <elliott> ("cab revdeps pkg")
09:38:41 <elliott> although, hmm, it might only be for installed packages
09:38:46 <elliott> aavogt: ah, thanks
09:39:02 <c_wraith> christo_m: yes, but that calculates the length of the longest list you've found an extra time at each step.  That's not good for performance.
09:39:23 <c_wraith> :t max . map (\l -> (length l, l))
09:39:23 <lambdabot> forall a. (Ord a) => [[a]] -> [(Int, [a])] -> [(Int, [a])]
09:39:40 <c_wraith> huh, that didn't work out.
09:39:51 <c_wraith> :t max
09:39:52 <lambdabot> forall a. (Ord a) => a -> a -> a
09:39:55 <c_wraith> oh, that's why
09:40:01 <c_wraith> :t maximum . map (\l -> (length l, l))
09:40:02 <lambdabot> forall a. (Ord a) => [[a]] -> (Int, [a])
09:40:32 <c_wraith> that expression will take in a list of lists, and give you back the length of the longest list along with the longest list.
09:40:39 <byorgey> > snd . maximum . map (\l -> (length l, l)) $ [[1,2,3], [1,2], [1,2,6,7,8], [4,5,2]]
09:40:41 <lambdabot>   [1,2,6,7,8]
09:40:52 <ion> > maximumBy length [[1,2,3], [1,2], [1,2,6,7,8], [4,5,2]]
09:40:53 <lambdabot>   Couldn't match expected type `[a] -> GHC.Ordering.Ordering'
09:40:53 <lambdabot>         against...
09:41:05 <ion> > maximumBy (compare `on` length) [[1,2,3], [1,2], [1,2,6,7,8], [4,5,2]]
09:41:06 <lambdabot>   [1,2,6,7,8]
09:41:16 <c_wraith> ion, that's not simpler anymore. :)
09:41:25 * byorgey wonders how maximumBy is implemented
09:41:31 <mekeor> ion: why not 'comparing' ?
09:41:33 <aavogt> dante: assuming ghc doesn't rearrange things (which it's allowed to), functions get re-calculated if you call them twice for the same arguments, but other variables are saved
09:41:44 <ion> mekeor: on generalizes that kind of functions.
09:41:47 <c_wraith> also, if maximumBy doesn't do a decorate/undecorate thing, that adds the problem back in.
09:42:05 <dolio> byorgey: Not as efficiently as possible, I think.
09:42:25 <elliott> There's no way to access another field of the cabal package, though, right?
09:42:28 <elliott> Like the website, say
09:42:49 <byorgey> indeed.  for the record, maximumBy does not use the decorate/undecorate method.
09:43:22 <byorgey> it does a foldl1 maxBy   where maxBy compares using the provided comparison function
09:43:37 <aavogt> elliott: you could load your  .cabal during the compilation of some module (using template-haskell and some things from Distribution.*)
09:44:13 <elliott> aavogt: "nice" :P
09:44:21 <elliott> I think I will handle two places to update :)
09:45:31 <dafis> byorgey: maximumBy can't use decorate/undecorate, the supplied comparison function needn't use an intermediate type
09:46:01 <christo_m> oh wow, maximum knows that if i pass it [(Int,[int]] that i want it to be applied to the [int]?
09:46:17 <ddarius> No
09:46:18 <christo_m> is that because lists are under the ord type constraint?
09:46:20 <christo_m> and values arent?
09:46:25 <christo_m> i mean.
09:46:42 <Axman6> @instances Ord
09:46:43 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:47:11 <christo_m> i dont get how maximum is working there then.
09:47:14 <aavogt> > sort [('b',[]),('a',[1,2]),('a',[0])]
09:47:15 <lambdabot>   [('a',[0]),('a',[1,2]),('b',[])]
09:47:17 <Axman6> there are definitions for instance (Ord a, Ord b) => Ord (a,b)
09:47:44 <dafis> christo_m: by the way, if you're on a 32-bit system, you'll get Int overflow for your collatz thingy
09:47:52 <Axman6> it compares the first elements, and if they're equal, the reault is the result of comparing the second elements
09:47:52 <christo_m> im on 64
09:47:56 <christo_m> and its still really slow
09:47:58 <christo_m> taking longer than a minute for sure
09:48:06 <christo_m> Axman6: ohhh!
09:48:40 <dolio> @type maximumBy
09:48:41 <roconnor> edwardk: fclabel's Point (->) f i o appears to be an indexed store coalgebra of some sort.
09:48:41 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
09:48:41 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
09:49:09 <christo_m> Axman6: but in [(Int,[Int]) the first enry of the tuple will never be the same as another, so why is it that it moves on to [int]
09:49:38 <c_wraith> christo_m: that's not true at all.  Sometimes things do have the same length in the collatz sequence.
09:50:01 <roconnor> edwardk: the big problem with fclabels is probably that modify is slow for long compositions of lenses because it doesn't use the performant coalgebra representation.
09:50:13 <Axman6> christo_m: the implementation of compare for tuples is: compare (a,x) (b,y) = case a b of EQ -> compare x y; other -> other
09:50:21 <c_wraith> [5, 16, 8, 4, 2, 1] is the same length as [32, 16, 8, 4, 2, 1]
09:50:32 <Axman6> christo_m: the int is the number used to generate the sequence i believe
09:50:49 <christo_m> ahh i thought it was the index of where that list was woops
09:50:56 * hackagebot fclabels-monadlib 0.1.0 - MonadLib monadic interface for the "fclabels" package.  http://hackage.haskell.org/package/fclabels-monadlib-0.1.0 (BardurArantsson)
09:50:57 <christo_m> because i need to know for which number this collatz sequence applies to
09:51:07 <c_wraith> christo_m: that's the first number in the list
09:51:08 <Axman6> christo_m: i'd use: maximumBy (\(_,a) (_,b) -> max (length a) (length b))
09:51:26 <dafis> christo_m: faster than constructing the list is just counting its length: collatzLength :: Int -> Int; collatzLength n = let go :: Int -> Int -> Int; go !acc 1 = acc; go acc m | even m = go (acc+1) (m `quot` 2) | otherwise = go (acc+1) (3*m+1) in go 1 n
09:51:28 <christo_m> findMax = maximum . map (\l -> (length l, l)) $ list
09:51:42 <Axman6> well, actuallt i'd use maximumBy (max `on (length . snd)), but that's besides the point :P
09:51:48 <Axman6> :t maximumBy (max `on (length . snd))
09:51:49 <lambdabot> parse error on input `('
09:51:56 <Axman6> :t maximumBy (max `on (length . snd))
09:51:57 <lambdabot> parse error on input `('
09:51:58 <Axman6> :t maximumBy (max `on` (length . snd))
09:51:59 <lambdabot>     Couldn't match expected type `Ordering' against inferred type `Int'
09:52:00 <lambdabot>     In the first argument of `maximumBy', namely
09:52:00 <lambdabot>         `(max `on` (length . snd))'
09:52:03 <mkscrg> New to cabal question: I've got multiple versions of some package installed. How do I remove the older ones?
09:52:04 <Axman6> uh
09:52:11 <Axman6> :t maximumBy (comparing (length . snd))
09:52:12 <lambdabot> forall a a1. [(a1, [a])] -> (a1, [a])
09:55:00 <hpaste> zomg pasted “attempt at dynamic execution” at http://hpaste.org/50300
09:55:29 <zomg> byorgey: looking at hint but I'd still like to understand how I could make my original idea to work :) If you're not busy could you take a look at  http://hpaste.org/50300
09:58:21 <Peaker> Axman6: comparing = compare `on` ... (not max `on`.. :-)
09:58:37 <Axman6> yeah, i figured that
09:58:56 <Peaker> All the blahBy functions need their blahOn counterparts which are much more comfortable to use (if slightly more restrictive)
09:59:10 <Peaker> @let maximumOn = maximumBy . comparing
09:59:11 <lambdabot>  Defined.
09:59:15 <Axman6> you'd use max if you were doing maximum using a foldl
09:59:23 <Peaker> @let sortOn = sortBy . comparing
09:59:23 <Axman6> :t maximumOn
09:59:24 <lambdabot>  Defined.
09:59:24 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> a
09:59:49 <Peaker> > maximumOn snd [(1,2),(2,1),(3,5),(4,4)]
09:59:51 <lambdabot>   (3,5)
09:59:53 <parcs> @hoogle m a -> m [a]
09:59:53 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
09:59:54 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
09:59:54 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
10:00:00 <Axman6> Peaker: it should be implemented a little more efficiently though...
10:00:09 <Peaker> @type fmap pure
10:00:10 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Applicative f, Functor f1) => f1 a -> f1 (f a)
10:00:40 <Peaker> Axman6: what do you mean? I think with a bit of inlining this should be equivalent to a more specialized fold
10:00:43 <parcs> Peaker: i want an infinite list :P
10:01:02 <Peaker> @type fmap repeat
10:01:03 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f [a]
10:01:20 <Axman6> something like: maximumOn f = map snd . maximunBy (comparing fst) . map (f && id)
10:01:31 <Axman6> :t let maximumOn f = map snd . maximunBy (comparing fst) . map (f && id) in maximumOn
10:01:32 <lambdabot> Not in scope: `maximunBy'
10:01:39 <Axman6> :t let maximumOn f = map snd . maximumBy (comparing fst) . map (f && id) in maximumOn
10:01:40 <lambdabot>     Couldn't match expected type `[(a, b)]'
10:01:40 <lambdabot>            against inferred type `(a1, b1)'
10:01:41 <lambdabot>     In the first argument of `(.)', namely `maximumBy (comparing fst)'
10:01:44 <Axman6> bleh
10:01:56 <ion> &&&
10:02:02 <Axman6> :t let maximumOn f = map snd . maximumBy (comparing fst) . map (f &&& id) in maximumOn
10:02:03 <lambdabot>     Couldn't match expected type `[(a, b)]'
10:02:04 <lambdabot>            against inferred type `(a1, b1)'
10:02:04 <lambdabot>     In the first argument of `(.)', namely `maximumBy (comparing fst)'
10:02:31 <Axman6> :t \f -> map (f &&& id)
10:02:32 <lambdabot> forall a c. (a -> c) -> [a] -> [(c, a)]
10:02:44 <ion> snd instead of map snd, i think.
10:02:46 <parcs> :t sequence . repeat
10:02:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
10:02:48 <zomg> Oh if anyone else is familiar with the GHC Haskell API to some degree, would be nice if you can look at this http://hpaste.org/50300
10:02:55 <arcatan> [A~.
10:02:56 <Axman6> :t maximumBy (comparing fst)
10:02:57 <lambdabot> forall a b. (Ord a) => [(a, b)] -> (a, b)
10:03:03 <arcatan> fyf
10:03:11 <Axman6> :t let maximumOn f = snd . maximumBy (comparing fst) . map (f &&& id) in maximumOn
10:03:11 <ciaranm> what's a &&& ?
10:03:11 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> a
10:03:14 <Axman6> duh
10:03:25 <ion> > ((+1) &&& (+2)) 5
10:03:26 <lambdabot>   (6,7)
10:03:28 <Axman6> ciaranm: \f g x -> (f x, g x)
10:04:28 <Axman6> Peaker: i think that's known as a schwartzian transform or something? stops you having to reevaluate the function being used to compare results, so you can use previous results
10:04:29 <aavogt> @pl \f x -> (f x, x)
10:04:29 <lambdabot> ((,) =<<)
10:05:02 <elliott>     Record update for insufficiently polymorphic field:
10:05:02 <elliott> No fair
10:05:16 <aavogt> Axman6: why don't you just memoize your function?
10:05:45 <Axman6> because i want to be able to write maximumBy length and have it worry about that for me
10:05:56 * hackagebot fclabels-monadlib 0.1.1 - MonadLib monadic interface for the "fclabels" package.  http://hackage.haskell.org/package/fclabels-monadlib-0.1.1 (BardurArantsson)
10:05:57 <Axman6> uh, maximumOn length i guess
10:06:02 <zomg> byorgey: Oh nevermind, I think I figured it out :) remove the rettype param entirely, and use "executeFunction "ModName" "someFn" :: IO Bool"
10:06:09 <Peaker> Axman6: ah, yes, you're right
10:06:13 <Axman6> (or in the case we're talking about, maximumOn (length . snd)
10:06:26 <aavogt> it's probably not always an optimization
10:06:32 <Axman6> no
10:06:43 <Axman6> but in cases like this one, which isn't uncommon, it certainly is
10:06:51 <Peaker> @let maximumOn' f = fst . maximumBy snd . map (id &&& f)
10:06:52 <lambdabot>  <local>:4:31:
10:06:52 <lambdabot>      Occurs check: cannot construct the infinite type:
10:06:52 <lambdabot>        ...
10:07:04 <Axman6> comparing snd i think
10:07:13 <Peaker> @let maximumOn' f = fst . maximumOn snd . map (id &&& f)
10:07:14 <lambdabot>  Defined.
10:07:17 <dolio> Looking up the length of a list in a memo table isn't any better than computing the length again.
10:07:38 <Axman6> > maximumOn (length . snd) [(2,[2,3,4]),(3,[2])]
10:07:39 <lambdabot>   (2,[2,3,4])
10:10:33 <Peaker> Axman6: btw Ordering is a Monoid, so you can use  compare a b `mappend` compare x y
10:10:50 <Axman6> ah yes
10:11:02 <Axman6> i was just going by the definition i would have written
10:12:58 <aavogt> dolio: the lookup table could be based on comparing the addresses of the first (:)
10:32:17 <vamega> Hi, I'm trying to do the 99 exercises for haskell
10:32:31 <vamega> but this code isn't working, could someone pinpoint why
10:32:33 <pedro3005> cool
10:32:35 <vamega> its located at http://pastebin.com/h94GxGW6
10:32:37 <mauke> The paste h94GxGW6 has been copied to http://hpaste.org/50301
10:33:04 <Phyx-> what is exercise 99?
10:33:16 <vamega> PhyX
10:33:16 <vamega> http://www.haskell.org/haskellwiki/99_Haskell_exercises
10:33:29 <tech2> vamega: why are you using ()
10:33:30 <Phyx-> vamega: your base case doesn't work then list is empty
10:33:56 <edwardk> preflex: xseen roconnor
10:33:56 <preflex>  roconnor was last seen on freenode/#haskell 43 minutes and 56 seconds ago, saying: edwardk: the big problem with fclabels is probably that modify is slow for long compositions of lenses because it doesn't use the performant coalgebra representation.
10:34:06 <vamega> tech2: I used the parenthesis because it complained when I tried to use square brackets
10:34:08 <edwardk> roconnor: pretty much
10:34:19 <tech2> vamega: use neither
10:34:23 <edwardk> roconnor: otoh reads are probably a little cheaper
10:34:41 <vamega> PhyX: It isn't supposed to work when the list is empty, the head of an empty list is undefined
10:34:52 <vamega> tech2: what would you suggest I use?
10:35:01 <tech2> vamega: x:xs
10:35:23 <vamega> Didn't know you could do that, what is the parenthesis used for?
10:35:26 <Phyx-> vamega: yes, but usually you write it out , e.g. myLast [] =  error, instead of letting it give a generic pattern matching error
10:35:32 <tech2> vamega: defining a tuple
10:35:41 <Phyx-> tech2: that pattern match is invalid without the parenthesis
10:36:00 * tech2 looks again
10:36:28 <vamega> PhyX so perhaps I could use a Maybe a for the function type
10:37:05 <vamega> since I'm just trying to get a feel of the syntax, I'm going to leave the error handling for later
10:37:23 <Phyx-> anyway, vamega your code doesn't work, because your base case is never hit
10:38:02 <tech2> my mistake, sorry all, misreading
10:38:11 <Phyx-> vamega: maybe is a possibility yeah
10:39:19 <vamega> PhyX: why wouldn't the base case be hit for an argument like [1,2,3,4]
10:39:20 <Phyx-> vamega: see your file
10:39:27 <Phyx-> vamega: because, you have a typo
10:39:27 <Phyx-> :)
10:39:33 <Phyx-> myLast and mylast
10:39:34 <zzo38> Does the IO type have any constructors? Is there any way to override IO actions?
10:39:44 <Phyx-> your base case is missing the uppercase L
10:39:50 <Phyx-> so it's actually defining two different functions
10:40:00 <Phyx-> "myLast" and mylast
10:40:03 <ion> zzo38: No. What do you mean by override?
10:40:18 <vamega> Oh god, that explains everything, thank you so much.
10:40:34 <Phyx-> vamega: lol, np
10:40:41 <Phyx-> I missed it at first too :/
10:40:47 <byorgey> zzo38: no, but you could make your own "reified" IO-like type with constructors, and then write one or more "interpretation" functions from your type to IO
10:41:37 <zzo38> ion: For example, if you have a IO action which does input, output, etc, and you want to have your own IO actor which does its own things with the IO actions
10:42:10 <byorgey> zzo38: like  data MyIO a where   Return :: a -> MyIO a;  GetChar :: MyIO (); ...
10:42:15 <luite> is there an easy way to build "development version" packages? I have around 20 packages in git repositories, and want to publish them to my private hackage repository. ideally they would get version x.y.z.20110814 or something, automatically
10:42:40 <edwardk> gah, there are many days when i long for an opposite version of the {-# UNPACK #-} pragma, where it takes something that has multiple constructors being used in something with one constructor and moves the arguments from the outer thing into the target.
10:43:08 <edwardk> i can always do the translation by hand, but zomg so much duplication
10:44:22 <tech2> edwardk: is there a specific reason this doesn't exist now other than "nobody's bothered" or am I just being dim (I blame hypoglycaemia atm, but that's another story)
10:44:51 <zzo38> I mean, is there anything like  data IO a where { InputChar :: FileHandle -> IO Char; OutputChar :: FileHandle -> Char -> IO (); ... }
10:45:13 <zzo38> So that you can make your own I/O system
10:45:18 <edwardk> well, it'd mess with pattern matching in a non-local way, but then UNPACK also does
10:45:30 <monochrom> no, there isn't
10:45:52 <edwardk> zzo38: i blogged something similar
10:46:17 <zzo38> edwardk: You did? Do you have the document available so that I can see?
10:46:32 <edwardk> http://comonad.com/reader/2011/free-monads-for-less-3/ but you probably want to rewind 2 articles from that
10:46:38 <Peaker> zzo38: what do you want to achieve?
10:46:51 <Peaker> zzo38: you can make your own IO-like monad, and a translator from your own monad to IO
10:47:48 <zzo38> Peaker: For example, if you want to write a terminal emulator program that treats it as if the other program running inside is a Haskell program (even if it isn't) with type IO ()
10:48:04 <byorgey> zzo38: you may be interested in http://hackage.haskell.org/package/operational
10:48:26 <zzo38> Or, if you want to override other system stuff too, such as making a sandboxing filesystem for another program.
10:49:12 <Peaker> zzo38: so you want to treat IO values as non-opaque and peek what's inside?
10:50:00 <zzo38> Peaker: Sort of, so that you can make these kind of overriding and other stuff.
10:50:14 <edwardk> zzo38: the problem comes down to the fact that you need a pile of those effects that you know how to inspect, which leads to making a bigger and bigger monad or you need to have some way to encapsulate the actual 'call' to a primitive in a generic way
10:50:32 <edwardk> the set of IO actions is open, so you have to be careful
10:50:40 <vamega> Hi, can someone explain to me what the purpose of the const function is
10:50:58 <Peaker> vamega: mostly points-free code
10:51:00 <vamega> I've read the declaration, but I fail to see why it is necessary
10:51:03 <edwardk> > either (const True) (const False) (Left 12)
10:51:04 <lambdabot>   True
10:51:24 <edwardk> you can always write (\_ -> True) there, but giving it a name is useful
10:51:59 <edwardk> similarly id
10:52:01 <monochrom> "necessary" is subjective
10:52:11 <edwardk> i can always write (\x -> x) everywhere
10:52:26 <zzo38> But some of the existing IO commands could be seen as combination of other IO commands, I would think.
10:52:30 <edwardk> (and paradoxically, in scala, that is actually shorter than writing out identity[TheBigScaryType] !
10:52:41 <edwardk> zzo38: some
10:52:49 <edwardk> but remember ffi lets you make new ones
10:52:58 <edwardk> zzo38: and the base set is HUGE
10:53:29 <monochrom> for efficiency, in practice getLine is not a loop over getChar
10:53:35 <vamega> Where can i find the definitions of the standard Haskell functions
10:53:45 <Phyx-> :t foldr (.) id
10:53:46 <lambdabot> forall b. [b -> b] -> b -> b
10:53:49 <vamega> I'm looking to find this id function that was mentioned above
10:54:12 <edwardk> it is in the Prelude
10:54:21 <monochrom> the Haskell Reports (a 98 one and a 2010 one) have reference definitions of the standard Haskell functions
10:54:26 <edwardk> that one is specified by the haskell 98 report (and its later editions)
10:54:35 <edwardk> http://hackage.haskell.org/package/base-4.3.1.0 shows the stuff you can rely on
10:54:41 <vamega> so can I pull this up in ghci somehow?
10:54:57 <monochrom> no, ghci does not show source code
10:55:00 <zzo38> Another way could be to allow you to have another function that convert IO monad into other values depending on actions and depending on what you specify it to do, that way you don't need to be able to access constructors of IO
10:55:12 <edwardk> http://www.haskell.org/onlinereport/standard-prelude.html describes the standard prelude
10:55:23 <elliott> vamega:
10:55:26 <elliott> ?src id
10:55:26 <lambdabot> id x = x
10:55:38 <Phyx-> monochrom: that's not really true.. it does partially for datatypes
10:55:41 <edwardk> in practice the actual prelude you use differs slightly from that report, but you can reason about code as if those were the implementations
10:55:43 <Axman6> hmm, I = id, K = const, and S = (>>=) right?
10:55:53 <monochrom> the ?src command here is handwritten and proved to be untrustworthy
10:55:55 <elliott> S = ap
10:55:58 <Axman6> (neglecting types of course)
10:56:02 <Axman6> ah yes, of course
10:56:05 <Axman6> :t ap
10:56:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:56:06 <edwardk> elliot: isn't there a flip in there?
10:56:18 <Phyx-> monochrom: i'm not talking about ?src
10:56:19 <vamega> well I found the prelude online
10:56:20 <Axman6> > ap x y z :: Expr
10:56:21 <vamega> thank you all
10:56:21 <lambdabot>   Couldn't match expected type `t -> a -> SimpleReflect.Expr'
10:56:21 <elliott> edwardk: not afaik
10:56:21 <lambdabot>         against...
10:56:26 <monochrom> but I am
10:56:41 <Phyx-> I gathered that much :P
10:57:03 <edwardk> ah
10:57:07 <edwardk> misremembered
10:57:15 <monochrom> Phyx-, not everything I say is stemmed from everything you say, I trust you can see that
10:57:48 <roconnor> edwardk: the big problem with fclabels is probably that modify is slow for long compositions of lenses because it doesn't use the performant coalgebra representation.
10:58:05 <edwardk> yep
10:58:18 <Phyx-> monochrom: I just thought it was a response to what i told you, hence why i thought that
10:58:27 <edwardk> but in exchange their reads are slightly cheaper
10:58:34 <edwardk> because they aren't throwing away boxes all over the plae
10:58:36 <edwardk> er place
10:58:46 <hpaste> “David Fox” pasted “Why too many open files?” at http://hpaste.org/50302
10:58:52 <elliott> edwardk: unboxed tuple lenses? :)
10:59:02 <zzo38> Such as, a function overrideIO that allows you to specify what IO actions you want to override and what to return with those cases, and in other cases return the something that is still based on the original IO value. And then you can use multiple overrideIO for many cases, and can specify the direct one or ones that can be considered as combined IO actions
10:59:05 <edwardk> elliot: that is an option actually
10:59:11 <elliott> edwardk: wow
10:59:19 <elliott> sounds ideal...
10:59:23 <edwardk> it gets rid of one place for a bottom to hide
10:59:29 <edwardk> they still have to construct and throw away a function
10:59:34 <edwardk> but they don't have to box it up
10:59:44 <elliott> right
10:59:52 <elliott> well doesn't laziness help
10:59:56 <elliott> oh hm
11:00:05 <dsfox1> Greetings - can someone tell me how to keep this from running out of file descriptors? - http://hpaste.org/50302
11:00:07 <elliott> unboxed tuples are strict aren't they
11:00:39 <edwardk> yeah, though the function itself can play the role of the thunk
11:01:06 <edwardk> another option is to denormalize slightly and build:
11:01:06 <elliott> edwardk: is it possible that data-lens might use an unboxed representation? or too unportable...
11:01:09 <monochrom> if you use readFile, but does not consume all of the string, you have file descriptors not closed
11:01:12 <edwardk> they don't
11:01:20 <elliott> i mean
11:01:24 <elliott> in the future
11:01:33 <Saizan> dsfox1: you could try unsafeInterleaveIO (readFile path) to defer the opening of the files too if you're feeling evil :)
11:01:34 <edwardk> data Lens a b = Lens (a -> b) (a -> (# b, b -> a #))
11:01:48 <edwardk> this is basically the design i'd been playing with
11:01:48 <dsfox1> monochrom: i thought i was consuming everything
11:01:59 <elliott> gross possibility for error imo :/
11:02:03 <edwardk> sure
11:02:13 <edwardk> but i'm willing to allow that in exchange for speed
11:02:32 <elliott> whats next, passing undefined like data-accessor?
11:02:36 <edwardk> hahahahahah
11:02:45 <elliott> HOW FAR WILL YOU GO
11:02:48 <dsfox1> Saizan: unsafe IO looks pretty safe in this case
11:02:58 <dsfox1> monochrom: oh, I see why I'm not consuming I think
11:03:02 <monochrom> but I guess you did not ask for why. what you should do: several options: don't use readFile, use withFile or iteratee or enumerator or ...
11:03:02 <edwardk> touche
11:03:03 <edwardk> there are levels of survival that we are willing to accept
11:03:27 <wli> In the long run, the survival rate for everyone drops to zero.
11:04:07 <roconnor> edwardk: shouldn't you just CPS transform everything
11:04:32 <edwardk> don't see how it helps here
11:04:32 <monochrom> the long-run eventual equilibrium is not always relevant
11:04:53 <roconnor> edwardk: CPS transforming things gets rid of pattern matches and bottoms =D
11:04:54 <edwardk> the unboxing vs. cps transformation achieve much the same goal
11:04:56 <elliott> roconnor: (a -> (b -> (b -> a) -> r) -> r)?
11:04:58 <edwardk> hah
11:05:03 <elliott> i was thinking that too
11:05:10 <elliott> more portable too
11:05:15 <edwardk> yeah
11:05:21 <roconnor> edwardk: there is a certain cymetry there
11:05:27 <roconnor> *symetry
11:05:37 <elliott> i like it
11:06:05 <edwardk> the rank 2 type is a bit annoying, but then so is unboxing
11:06:33 <elliott> rank two is one of  the lesser evils you could do on this quest
11:06:45 <edwardk> yeah
11:07:16 <edwardk> right now i have a completely haskell 98 solution, debating about opening this can of worms ;)
11:07:47 <roconnor> edwardk: Have you looked at these fclabel partial lenses?  Partial lenses ought to be isomorphic to a -> (Id :+: Store b) a
11:07:51 <DevHC> edwardk: unboxing: see http://www.youtube.com/watch?v=ssTZ6czMaiM
11:07:55 <monochrom> if it is currently haskell-98, I encourage you to keep it that way a bit longer
11:08:02 <roconnor> but I don't think fclabels has this type
11:08:50 <roconnor> actually, I guess it needs to be isomorphic to Coalgebras of type a -> (Id :+: Store b) a
11:09:01 <roconnor> and that coalgebra restriction is pretty heavy
11:09:11 <edwardk> devhc: so disturbing
11:09:17 <edwardk> yeah
11:09:30 <roconnor> making a -> Maybe (Store b a) likely a sufficent representation
11:09:41 <roconnor> which might be what they effectively have
11:09:59 <edwardk> its close
11:10:09 <edwardk> they use a generic arrow type under the hood
11:10:15 <elliott> <edwardk> right now i have a completely haskell 98 solution, debating about opening this can of worms ;)
11:10:15 <elliott> how about abstracting out the API so that the difference between the two is undefined behaviour (wrt _|_ and the like), then having Data.Lens.Pure and Data.Lens.Fast (or similar) and a cabal flag that only builds the former and makes Data.Lens reexport it rather than the latter
11:10:29 <elliott> everyone gets to say their code is valid haskell ninety-eight
11:10:38 <elliott> those with a fancy compiler get nice speed
11:10:42 <edwardk> so its probably a -> Maybe b, b -> a -> Maybe b so the maybe set could do hinky things depending on the value
11:10:54 <zzo38> I am trying to learn how to write a parser, probably using Parsec, I read instructions to try to figure it out
11:10:57 <elliott> the new fclabels is less appealing to me than the previous version
11:11:02 <edwardk> elliot: distinctly possible
11:11:39 <elliott> edwardk: IMO the API is bad if it lets things like _|_s in the result leak through as guarantees anyway
11:11:56 <edwardk> i lured the snap guys away from fclabels to data-lens with the prospect of speed so it is worth it to me to offer as much as i can
11:12:10 <elliott> super crazy idea for a "fast" version: Lens as a type family
11:12:19 <elliott> specialise implementation to the data types :>
11:12:41 <edwardk> chaining paradoxically becomes more expensive
11:12:57 <elliott> with a type family? hmm, right
11:13:02 <edwardk> because it has to build the composite type
11:13:08 <elliott> well, that idea lasted whole seconds, I tell ya
11:13:30 <roconnor> edwardk: now it the time to take advantage of the anti-arrow sentiment and seize the lens market!
11:13:33 <elliott> edwardk: unless... (.) :: Lens b c -> Lens a b -> LensCompose a b c which is ALSO A TYPE FAMILY!!!!
11:13:39 <elliott> EVERYTHING must be a type family!
11:13:46 <edwardk> hah
11:13:47 <elliott> roconnor: you know me too well :(
11:14:03 <elliott> I was wavering between fclabels and data-lens and then the new version came out and made the decision for me
11:14:05 <roconnor> elliott: I don't think you are the only one
11:14:26 <roconnor> elliott: unless you are ehird
11:14:28 <ion> The new version of which?
11:14:44 <elliott> roconnor: oh, so my band of millions turns out to just be me
11:14:54 <roconnor> elliott: :D
11:14:55 <elliott> I've never been more disappointed in my life
11:15:20 <roconnor> the imporant thing is that people use data-lens =D
11:15:26 <hpaste> pedro pasted “bla” at http://hpaste.org/50303
11:15:38 <pedro3005> I have a problem with that code
11:15:38 <roconnor> it will help me get tenured.
11:15:43 <elliott> I kind of like the idea of lenses in monads, though... it'd be cool if you could make "value inside an IORef" an "IO lens"
11:15:50 <pedro3005> Occurs check: cannot construct the infinite type: a = [a]
11:15:52 <elliott> but I suspect this can be built aside data-lens
11:16:37 <edwardk> building the unboxed tuple version
11:17:04 <edwardk> least amount of code changes
11:17:12 <edwardk> and the most obviously correct
11:17:14 <elliott> edwardk: (a -> ((# b, (b -> a) #) -> r) -> r)
11:17:17 <elliott> edwardk: unboxed AND CPS!
11:17:20 <elliott> so much SPEED!!!!
11:17:21 <edwardk> can't
11:17:38 <edwardk> that puts the unboxed tuple in non-positive position
11:17:40 <elliott> heh, oh, that would actually have an effect wouldn't it
11:17:43 <edwardk> kinds don't check
11:17:46 <elliott> my joke ruined by plausibility :(
11:17:49 <edwardk> hah
11:17:55 <pedro3005> oh I can kind of see where it's wrong
11:18:08 <elliott> edwardk: now, I'm sure we can get the _equivalent_ of that with some judicious use of FFI functions...
11:19:01 <elliott> hmm, all the combinators built on top of the data-lens core don't really exploit any efficiency in the lens representation themselves, right? just benefit from it
11:19:11 <elliott> (I was thinking what a "defined lens API" would actually constitute)
11:20:40 <edwardk> probably deconstruction through the cps'd version since the quantifier moves up
11:20:56 <elliott> hmm?
11:20:56 <edwardk> and construction from the getter setter pair, isomorphisms and from a store coalgebra
11:21:03 <elliott> right
11:21:30 <elliott> that deconstruction should avoid exposing too many details about where _|_s can sneak in, right?
11:21:54 <edwardk> yeah
11:22:16 <elliott> pull a reactive-banana: class LensImpl t where data Lens t a b; ... :-P
11:22:19 <elliott> (don't)
11:25:15 <pedro3005> http://hpaste.org/50304 I get the same error
11:25:35 <pedro3005> the purpose of partitions is to return all ways of partitioning a list into n sublists
11:26:05 <elliott> edwardk: btw, what would it take to persuade you to make the StateT set/modify functions return () rather than the modified value under the usual names? I keep writing "ignore $" a bunch, and GHC keeps whining at me to write "_ <-"... although I guess if I made my actions return the modified value the first problem would go away, and I could turn off the warning... plus there's probably some really useful case I'm missing :P
11:26:08 <edwardk> so far the transcoding isn't that bad
11:26:08 <elliott> talked myself out of that one quickly
11:26:09 <edwardk> (^%=) (Lens f) g a = case f a of (# b, h #) -> h $! g b
11:26:29 <elliott> those hashes scare me
11:26:31 <edwardk> elliott: that decision would break many people's code
11:26:31 <pedro3005> also why can't I do "import Data.List (\\)" ?
11:26:39 <elliott> edwardk: that also talked me out of it :P
11:26:50 <elliott> pedro3005: ((\\))
11:27:06 <pedro3005> ah ok
11:27:06 <edwardk> now, what i _would_ like would be to add state :: (a -> (a, s)) -> m a -- to MonadState
11:27:24 <edwardk> then define get and put in terms of it as default definitions
11:27:28 <elliott> I'm tempted to write my own antisocial operators on top of data-lens and use them :p
11:27:29 <edwardk> that way modify can be defined more efficiently
11:27:39 <edwardk> avoiding one round trip through the monad transformer stack
11:27:45 <elliott> edwardk: that's the obvious definition of MonadState, isn't it...
11:27:48 <elliott> mtl :(
11:27:52 <edwardk> yes
11:28:04 <edwardk> defining it interms of the monad homomorphism from state
11:28:25 <edwardk> i rather prefer these 'initial' encodings to all the classes actually
11:29:06 <mun> hi
11:29:07 <mun> i see that the real numbers (and transcendental numbers in general) cannot be formalised in first-order logic, but how about algebraic numbers?
11:31:41 <acowley> I've apparently been using the old definition of semigroups.
11:31:58 <acowley> I would've called our semigroup an associative magma so I still have a name for things that don't have all inverses
11:32:13 <acowley> what do we call those now?
11:33:47 <edwardk> acowley: no inverses but you have a unit? monoid
11:33:58 <edwardk> no inverses, no unit, just associativity? semigroup
11:34:22 <acowley> some inverses, and I have a unit?
11:34:46 <acowley> wikipedia says I'm using the original definition of the term
11:34:47 <edwardk> well, in a ring, those things that have multiplicative inverses are called units of the ring
11:35:14 <edwardk> so you'd use http://hackage.haskell.org/packages/archive/algebra/2.0.1/doc/html/Numeric-Decidable-Units.html
11:35:21 * Eduard_Munteanu kinda wonders about magmas with units
11:35:24 <elliott> apart from the terrible name of colens, this looks about right: http://hpaste.org/50307 ... of course it'd be horrible to use in practice because of the typeclass poking into all your code. unless each implementation module re-exported specialisations of them, but then it's unclear why the typeclass would even exist. actually, that's unclear in general. oops. well, too late now
11:35:25 <edwardk> if you were off in my theoretical lala land
11:35:35 <acowley> edwardk: that's quite nice!
11:35:44 <mun> according to wikipedia, FOL is not sufficient to describe infinite structures like the natural numbers. but don't the Peano axioms describe exactly that?
11:35:47 <Eduard_Munteanu> I think they're not unique, no?
11:36:02 <Eduard_Munteanu> (the units in such magmas)
11:36:04 <acowley> edwardk: but what's ^?
11:36:10 <edwardk> ^ that may fail
11:36:40 <edwardk> so for integers you can raise (-1 and 1) to a negative power
11:36:48 <edwardk> and it is still well defined
11:36:53 <edwardk> because those have recipriocals
11:37:01 <edwardk> but the rest aren't units so you can't
11:37:32 <zzo38> Does Haskell have any standard function that does:  either (fail . show) return
11:37:35 <elliott> hmm, can type family instances even be newtypes?
11:37:39 <edwardk> basically if you raise to a negative power it tries to use recipUnit, then flips the sign and proceeds as usual
11:37:49 <edwardk> elliot: sure
11:37:57 <Eduard_Munteanu> :t either
11:37:57 <edwardk> you can even have newtype members of a data family
11:37:58 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
11:38:05 <elliott> zzo38: btw, fail should usually be avoided... its presence in the Monad class is a bit ofa mistake
11:38:07 <acowley`> edwtjo: I think it would help
11:38:09 <edwardk> doh, what'd you miss? =)
11:38:11 <elliott> edwardk: err, right, that is what i meant :)
11:38:30 <acowley`> Eduard_Munteanu: I think you are right that they are not unique
11:38:32 <edwardk> elliot: yeah you define the family as a data family, but you make the member using newtype Foo
11:38:37 <roconnor> @type execStateT
11:38:38 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
11:38:49 <elliott> i share the curse of conal
11:38:53 <elliott> edwardk: right
11:38:56 <acowley`> edwardk: I got your first message clarifying (^?), and it makes good sense
11:39:02 <Eduard_Munteanu> I remember the uniqueness proof invoked associativity explicitly.
11:39:10 <zzo38> elliott: I know it is not a part of the mathematical monad, but I want to make it use the fail of the Q monad in order to halt compilation. Does that work?
11:39:20 <Eduard_Munteanu> Or at least id_left = id_right
11:39:35 <elliott> zzo38: Yes.
11:39:39 <zzo38> Is that the way to make up your own compile errors?
11:39:54 <edwardk> there is also the related concept of an associate: http://hackage.haskell.org/packages/archive/algebra/2.0.1/doc/html/Numeric-Decidable-Associates.html
11:40:02 <elliott> zzo38: There's also qReport
11:40:10 <elliott> qReport isError str
11:40:14 <elliott> but it doesn't stop compilation
11:40:21 <elliott> fail is when you want an error that stops compilation
11:40:26 <edwardk> but the choice of unit in that case is ambiguous, so it just says 'yes or no'
11:40:50 <zzo38> I do want it to stop compilation though.
11:41:54 <zzo38> Is there any other uses for   either (fail . show) return   or   either fail return    with other monads?
11:42:00 <acowley`> edwardk: so magmas with units need DecidableAssociates, while monoids can use DecidableUnits?
11:42:41 <edwardk> no, decidable units lets you answer whether or not something is a unit, decidable associates let you know that there exist some unit you can multiply by one to get the other
11:43:00 <zzo38> If I invent this function what should its proper name be?
11:43:24 <edwardk> but it has to be bool because there can be lots of such units
11:43:52 <acowley`> edwardk: got it
11:43:53 <edwardk> e.g. is zero an associate of zero? sure i can multiply it by 1, or -1 and get 0
11:43:58 <edwardk> (in the naturals)
11:44:10 <zzo38> edwardk: There is no -1 in the naturals
11:44:14 <edwardk> in the rationals, i have infinitely more choices of units
11:44:16 <edwardk> sorry integers
11:44:46 <edwardk> in the naturals you can decide all associates exactly
11:45:02 <elliott> edwardk: type Lens a b = (# a -> Ptr b, a -> State# RealWorld -> (# a, State# RealWorld #) #)
11:45:14 <elliott> edwardk: first returns a pointer to modify the value in-place, second one... copies a?
11:45:14 <edwardk> elliot: hahaha
11:45:22 <elliott> so to modify, you copy, then modify the pointer of the result
11:45:25 <elliott> then return it
11:45:28 <elliott> and unsafePerformIO the lot
11:45:29 <elliott> perfect
11:45:55 <elliott> I'd love to see the Template Haskell to generate _those_
11:46:08 <zzo38> I should name the function that does (either (fail . show) return) how should it be named to be useful to other people making Haskell program too?
11:49:19 <marv> so I was trying to play with the code from http://sequence.complete.org/node/258 but I'm getting errors on both usages of `catch`, something about Ambiguous type variables
11:49:55 <marv> am i doing something wrong or is that code busted?
11:49:57 <zzo38> Other than Parsec, are there other things that Left for errors and Right for successful?
11:51:19 <acowley`> zzo38: System.IO.Error.try is in that vein
11:52:35 <Cale> zzo38: Basically anything which uses Either as a monad will have to.
11:52:46 <Cale> Rather, Either e as a monad
11:53:06 <Cale> return :: a -> Either e a
11:53:30 <Cale> (>>=) :: Either e a -> (a -> Either e b) -> Either e b
11:54:20 <Cale> The types basically force errors to be Left.
11:54:23 <acowley`> where is the monad instance for Either defined these days?
11:54:38 <edwardk> control.monad.instances
11:55:24 <acowley`> docs need updating
11:55:32 <acowley`> they say they only provide Functor for Either
11:55:57 <Cale> Indeed they do.
11:56:30 <Cale> Haddock should just document instances correctly and not just in a little list attached to the class.
11:56:42 <acowley> Cale: ++++++++
11:56:46 <Cale> and then the silly thing can't get out of date
11:57:14 <Cale> (at least in that respect)
12:00:58 <marv> I get a similar error on something simple like:  getChar1 =  catch getChar (\e -> return '\n')    from http://www.cmi.ac.in/~madhavan/courses/programming06/ExceptionHandling.html
12:01:22 <marv> I must be doing something wrong, all these examples can't be faulty?
12:01:47 <k0ral> I can't see any combinator implementation of html5 in hackage ; does this mean the html package has to be upgraded to this purpose ?
12:02:24 <mauke> marv: oh yeah, that's the wrong catch
12:02:37 <mauke> marv: the one in Control.Exception has changed a bit recently
12:03:10 <mauke> marv: for your getChar example I'd just use the one from System.IO.Error
12:03:15 <zhulikas> mauke, where was that page about IO you gave me last week? I lost it :/
12:03:28 <mauke> http://mauke.dyndns.org/stuff/haskell/how-to-io.html this one?
12:03:32 <zhulikas> thanks
12:03:42 <zzo38> OK it uses Either e as a monad, but what would you do if you want to convert errors and success to another monad? I wrote a function to do so but what is its name suppposed to be?
12:04:13 <marv> mauke: oh. Yeah i've been trying to use Control.Exception. So that has changed recently?
12:04:24 <edwardk> what is the snap framework channel?
12:04:42 <ozataman> edwardk: #snapframework
12:04:57 <mauke> marv: well, FSVO recently
12:05:12 <mauke> the switch to extensible exceptions happened in 2008 with ghc 6.10
12:06:38 <marv> well i haven't been learning haskell for very long, so i guess it doesn't matter to me when it changed, only that hte examples i'm finding don't work
12:07:04 <marv> any idea how to make them work for Control.Exception, or where I would go to figure that out?
12:07:23 <mauke> well, http://www.cmi.ac.in/~madhavan/courses/programming06/ExceptionHandling.html still works
12:07:27 <mauke> it's the IO catch
12:07:58 <mauke> marv: ah, the other thing just wants to catch any exceptions
12:08:06 <mauke> should be easy to fix
12:08:08 <Cale> marv: There's the documentation for Control.Exception... I'm not sure if someone's written a nice tutorial on it.
12:08:46 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.0.0/Control-Exception.html
12:09:34 <marv> Cale: I've looked through that, I don't think it explains why i'm getting the ambiguous error or what to do about it
12:09:41 <mauke> marv: catchAny :: IO a -> IO a -> IO a; catchAny body err = catch body (\e -> const err (e :: SomeException))
12:09:49 <Cale> marv: ah, okay, I didn't see the error message you were getting
12:10:02 <mauke> marv: and now instead of 「foo `catch` const bar」 you can use 「foo `catchAny` bar」
12:10:32 <iFire> anyone making a haskell binding for http://www.acunu.com/blogs/tom-wilkie/open-castle/ ?
12:10:32 <Cale> marv: But probably what you're seeing is related to wanting to catch any kind of exception
12:10:50 <Cale> catch body (\(SomeException e) -> ... e ...)
12:11:14 <mauke> Cale: my version doesn't need language extensions :-)
12:11:30 <Cale> mauke: ???
12:11:36 <mauke> what
12:11:43 <Cale> What language extension?
12:11:48 <mauke> oh wait
12:11:50 <mauke> I misread
12:12:05 <mauke> Cale: you're right. d'oh
12:12:06 <Cale> I mean, SomeException is an existential type
12:12:08 <Cale> so maybe
12:12:41 <mauke> catchAny :: IO a -> IO a -> IO a; catchAny body err = catch body (\(SomeException _) -> err)
12:13:53 <marv> thanks guys
12:24:36 <edwardk> the cps'd version of the lenses is actually rather pleasant to code to
12:27:16 <danharaj> Are lenses the next sexy abstraction?
12:28:02 <edwardk> i gave a talk on them, so of course they are
12:28:33 <danharaj> what's the authoritative introduction?
12:29:01 <edwardk> probably my scala talk
12:29:40 <edwardk> http://www.youtube.com/user/edwardkmett?feature=mhee
12:29:44 <danharaj> thanks.
12:30:32 <edwardk> that version uses a naive encoding to sell it to folks who don't think in terms of comonads and coalgebras, etc.
12:31:11 <danharaj> edwardk: We have almost the same haircut.
12:31:29 <danharaj> I do not sport awesome facial hair though.
12:31:42 <edwardk> heh
12:32:01 <ocharles> Hi, I'm having some problems with type classes... http://gist.github.com/1145242 are the errors I'm getting, and http://gist.github.com/1145243 is the code I'm trying to write
12:32:33 <ocharles> I've tried adding explicit type annotations of LoadedEntity Role, and LoadedCoreEntity Person, but it doesn't seem to have any affect
12:32:43 <ocharles> so I'm not understanding something :)
12:34:10 <ocharles> Ah, wait - it's looking for type class instances
12:34:46 <ocharles> is it because I haven't imported instances of Entity Role and CoreEntity Person?
12:34:50 <Saizan> yeah
12:35:11 <TotoTitus> is it necessary to grasp category theory/abstract algebra in order to fully understand Haskell?
12:35:32 <ocharles> TotoTitus: depends what your definition of "fully" is
12:36:13 <TotoTitus> Hmm...rephrasing...will tackling such mathematical subjects lead to a better experience of the language ?
12:36:25 <TotoTitus> I am sorry if my questions are rather vague
12:36:35 <BMeph> TotoTitus: depends what your definition of "better" is ;)
12:36:41 <mauke> can't help you; I don't know abstract algebra
12:36:50 <TotoTitus> Wow, this is getting complex really fast
12:37:01 <ocharles> that's a better question, which I'm too new to answer :) But for me, I don't know much know category theory - but learning the type classes has been very important
12:37:11 <TotoTitus> Ok, does knowing this part of math give you an edge whatsoever ?
12:37:18 <ocharles> time is better spent learning the stuff in haskell-platform, then branching out
12:37:23 <danharaj> TotoTitus: You are going to learn that math by using Haskell.
12:37:27 <edwardk> tototitus: no, though you;ll probably learn a little by accident as you go
12:37:35 <TotoTitus> Ah, ok
12:37:48 <Cale> TotoTitus: Yes it gives you an edge, but not so much that if you don't know it you should go out of your way to learn it first, if your goal is to write programs
12:38:05 <pedro3005> how is abstract algebra used in haskell?
12:38:07 <Cale> Because it's much easier to learn these concepts as they apply to Haskell than it is to learn them generally.
12:38:19 <danharaj> Monoids are a very useful abstraction.
12:38:26 <danharaj> Considering how so many things are monoids.
12:38:27 <geheimdienst> TotoTitus: in my view it's unnecessary. i'm absolutely not a math person (i find it to be a load of complex jargon with little value) and i enjoy haskell just fine
12:38:37 <TotoTitus> aha..
12:38:39 <danharaj> geheimdienst: Boo.
12:38:41 <edwardk> the main thing about learning haskell is to be open to other ways to do things than your original preconception, because a lot of things work a bit side-ways from what you'd expect for what are ultimately very good reasons
12:38:58 <TotoTitus> Cuz' the last time i visited algebra was at Vector Spaces, Rings, Groups and Morphisms, so i thought extending the knowledge a bit would be necessary
12:38:59 <copumpkin> yay, more bikeshedding on haskell-cafe about the fucking operator
12:39:06 <mauke> monoids aren't hard, though
12:39:08 <edwardk> fucking :: ?
12:39:18 <Cale> TotoTitus: Well, that's a pretty decent foundation to build on.
12:39:20 <mauke> they're like algebra for babies
12:39:20 <ocharles> lol
12:39:21 <TotoTitus> Just a set of items with an operation defined on them
12:39:30 <copumpkin> the (+>) operator
12:39:30 <TotoTitus> Ok, associativity etc.
12:39:33 <edwardk> copumpkin: which operator?
12:39:39 <ocharles> Man -> Woman -> Baby?
12:39:41 <edwardk> monoid?
12:39:43 <zzo38> I understand monoids in mathematics, like groups except for inverses. And monoids in Haskell are the same thing.
12:39:49 <danharaj> TotoTitus: If you're comfortable with that stuff then you will pick up the category theory stuff without much trouble.
12:39:50 <edwardk> last time we voted and <> won
12:39:59 <TotoTitus> Yeah, ex. (R,+) is a monoid
12:40:00 <edwardk> which is why i started using it for semigroup
12:40:00 <copumpkin> oh yeah, that one
12:40:01 <zhulikas> Woman -> Woman -> ()
12:40:08 <TotoTitus> sorry, (R, *) is a monoid
12:40:12 <copumpkin> edwardk: yeah, there's lots of discussion about semigroup now
12:40:16 <danharaj> (R,+) is a monoid too.
12:40:20 <edwardk> interesting
12:40:21 <danharaj> TotoTitus: Also lists.
12:40:21 <TotoTitus> but also a group
12:40:25 <danharaj> That's true.
12:40:37 <rwbarton> what operator is +> supposed to be?
12:40:38 <Cale> If you enjoy mathematics enough to already know what a group is, yeah, you probably should learn a bit of category theory already. :)
12:40:45 <TotoTitus> so i didn't want to 'subclass' it, calling it a monoid *cough* *cough*
12:40:50 <TotoTitus> aha
12:40:55 <TotoTitus> Man, you guys are great, thanks !
12:41:08 <elliott> edwardk: any conclusion from your lens optimisation?
12:41:18 <elliott> oh, I see something about the cps ones being nice :)
12:41:19 <ocharles> I'm curious where someone with no college level maths should start with learning this stuff :)
12:41:33 <copumpkin> ocharles: wikipedia!
12:41:43 <TotoTitus> Uh..no..not wikipedia
12:41:46 <danharaj> TotoTitus: A category is the thing you get when you abstract the algebra of functions and composition, like monoids is the abstraction of natural numbers and addition.
12:41:59 <ocharles> I'd love to understand some stuff like darcs explained with inverse semi groups, or whatever that paper used, but I dunno where to start
12:42:22 <ocharles> copumpkin: sadly a great resource, but so unapproachable for a layman
12:42:59 <TotoTitus> I'm lucky, in my country groups/monoids/rings are taught in high school
12:43:17 <TotoTitus> So i got them for free
12:43:23 <ocharles> wow, nice!
12:43:24 <danharaj> ocharles: Thinking about it in terms of Haskell code is not a bad thing.
12:43:31 <ion> Cool
12:43:36 <ocharles> i can't see the uk ever having that
12:44:20 <TotoTitus> I don't think we're having them for long either
12:44:28 <ocharles> danharaj: well, I was using an example for my more general goal of learning, but yea - haskell will help me gain a bit more intuition
12:45:07 <TotoTitus> I find abstract algebra/categ theory like a sticky goo which envelops all math
12:45:16 <TotoTitus> Bassically, everything relates to them in a way or another
12:45:40 <BMeph> edwardk: Did you use a font for the ambigrams, or is it just a graphic?
12:46:05 <ion> The ambigrams?
12:46:16 <edwardk> graphic
12:46:27 <hpaste> Tasser pasted “beginner type signature question” at http://hpaste.org/50308
12:46:40 <edwardk> ion: the title slide for http://www.youtube.com/user/edwardkmett?feature=mhee uses an ambigram
12:46:43 <danharaj> TotoTitus: There's a reason why category theory is called general abstract nonsense.
12:46:45 <Tasser> wow, cool bot :-)
12:47:01 <BMeph> edwardk: I was hoping not, but figured such, once I thought abuot it more. Thanks.
12:47:21 <edwardk> there are some automatic generators but they are hard to come by =)
12:48:11 <rwbarton> Tasser: this is a particularly unhelpful error message
12:48:11 <danharaj> Tasser: GHC is telling you that it can't decide that the type a in your annotation is a list. Why is that?
12:48:18 <ion> edwardk: Was that supposed to show a specific video? I’m probably just being blind, but i’m not noticing an amigram on that page.
12:48:22 <acowley> Tasser: consider the simple case of qsort (pivot:[]). The type says that (pivot:[]) has type a, but the pattern match says the argument is a list. So, a is [b] for some b.
12:48:44 <acowley> Tasser: except it calls "b" "a0" to be regular
12:49:01 <acowley> Tasser: so now you're returning an [a0], but the type checker doesn't know that a is the same as [a0]
12:49:11 <acowley> Tasser: or, put another way, it doesn't know a ~ [a0]
12:49:15 <rwbarton> basically, the type you declared is too general
12:49:18 <edwardk> the first video that is being shown has be rambling on about lenses, it animates in a second
12:49:18 <ion> edwardk: Ah, had to open the first video of the series.
12:49:26 <edwardk> er had me
12:49:30 <acowley> Tasser: what you want is to say that the input is a list of values, so, [a]
12:50:15 <ocharles> uhhh, why with "findRoles (book :: LoadedCoreEntity Book)" am I getting an error:  No instance for (BookBrainz.Model.Role.HasRoles Book) ?
12:50:19 <Tasser> oh, makes sense. [a] is what I thought of :-)
12:50:21 <ion> I’ve actually had that series downloaded to my todo directory for a while, but haven’t got around to watching it yet.
12:50:28 <Tasser> ... but didn't write.
12:50:43 <ocharles> hrm, might need more context for that question
12:50:54 <rwbarton> btw I guess this is a new error message from equality contexts for classes?
12:51:02 <Tasser> doesn't like the stuff nontheless -     Warning: Pattern match(es) are overlapped
12:51:04 <Tasser>              In an equation for `qsort': qsort (pivot : []) = ...
12:51:05 <hpaste> BMeph annotated “beginner type signature question” with “Re: beginner type signature question (annotation)” at http://hpaste.org/50308#a50309
12:51:18 <ocharles> oh wait, never mind me, my type class is not what I thought
12:51:22 <acowley> Tasser: when you see a type variable invented by GHC and a complaint that it can't figure out an equality, you've probably done something very like what you've done here
12:51:28 <acowley> rwbarton: no, this is standard
12:51:39 <rwbarton> the old message was more helpful
12:51:44 <rwbarton> Couldn't match expected type `a' against inferred type `[t]'
12:52:04 <ion> Btw, the page lists “DSLs in Scala” 5, 4, 3, 2 and 1 and then “Lenses: A Functional Imperative” 5, 4, 3, 2 and 1. I looked at the beginning of DSLs in Scala #5 and then #1 until complaining about not seeing the ambigram. Only then i found it in Lenses #1. :-P
12:52:08 <geheimdienst> wow, that message is gone? :-o
12:52:25 <rwbarton> it's because there is a class context that could theoretically provide the match
12:52:38 <rwbarton> in this case Ord a could have an a ~ [a0] context
12:52:42 <Tasser> works \o/
12:53:07 <BMeph> ion: ...did you not notice that the page itself is of "Lenses #1"? :)
12:53:18 <rwbarton> I guess this message is OK too, once you get used to it
12:53:36 <acowley> rwbarton: ah, thanks! the current message looked fine to me
12:53:46 <danharaj> Once you know what a ~ b means, it says basically the same thing.
12:53:51 <ion> bmeph: It isn’t here. It’s “edwardkmett’s channel”.
12:53:57 <rwbarton> right.
12:54:11 <rwbarton> I just was surprised because the code is pretty standard and yet I had never seen that form of error message before
12:54:12 <ion> This one <http://www.youtube.com/playlist?list=PLEDE5BE0C69AF6CCE> looks like the intended link to me.
12:54:16 <danharaj> ghc does have a serious problem with error messages though :p
12:54:58 <Cale> The latest changes to GHC's type system seem to have worsened its error message quality quite a lot
12:55:09 <edwardk> ion: the channel is configured to play that video by default
12:55:19 <edwardk> ion: whatever you are using to browse didn't pick that up
12:55:35 <BMeph> ion^^ I think edwardk set it up to do...yeah, what he said. :)
12:56:02 <elliott> Cale: agreed
12:56:08 <elliott> I barely even look at the messages any more
12:56:16 <elliott> whereas before I found them really helpful unlike some
12:56:22 <parcs> Cale: yeah i noticed that too, after the release of ghc 7
12:56:30 <elliott> I just C-c C-l, "oh, GHC's unhappy... better twiddle random bytes"
12:57:03 <ion> edwardk: http://i.imgur.com/IsXXN.png
12:57:24 <ion> A screenshot of what http://www.youtube.com/user/edwardkmett?feature=mhee looks like here.
12:57:37 * BMeph thinks that "someone" (full name, "Someone Else") should make a module that can make good guesses at what the error messages ought to say, from what the error and code are.
12:57:46 <elliott> ion: that looks like some beta youtube or something
12:57:56 <elliott> or at least it looks much less flashy here, and that feedback icon seems an indicator too
12:59:00 <acowley> BMeph: that sounds not easy
12:59:47 <BMeph> acowley: It sounds Very "not easy", thus my suggestion that the amazingly talented and competent "Someone Else" should do it.... ;)
12:59:50 <acowley> BMeph: also really frustrating if you have to parse the error messages yourself and are thus vulnerable to a GHC hacker doing some word smithing themselves
13:00:05 <acowley> Yes, selse needs to pull more weight
13:00:14 <elliott> what sounds not easy?
13:00:25 <cgroza> Is it possible to get a stack overflow in Haskell? I mean, something that happens with imperative languages when the recursion is too deep.
13:00:31 <BMeph> elliott: "* BMeph thinks that "someone" (full name, "Someone Else") should make a module that can make good guesses at what the error messages ought to say, from what the error and code are."
13:00:34 <acowley> elliott: BMeph's error message improvement suggestion
13:00:39 <geheimdienst> BMeph: i think the established message (Couldn't match ... Inferred type:... Expected type:...) is perfectly fine. in the case of the class constraint it could gain an additional line "The constraint '(Ord a) =>' did not provide a match either" or some such
13:00:42 <ion> elliott: Probably a new layout being deployed to users gradually. It has looked like that here for quite a while.
13:00:42 <elliott> ah
13:00:51 <elliott> BMeph: that's called GHC :)
13:00:53 <elliott> ion: yeah
13:01:09 <TTimo> cgroza: not really unfortunately .. with it being lazy and all there's no such thing as a clear backtrace
13:01:23 <TTimo> that being said .. last time I asked and investigated that question was months ago
13:01:39 <acowley> you can get stack overflows when you have a deeply nested unevaluated thunk
13:01:57 <cgroza> TTimo: I have seen a stack overflow post that said that it is possibe to force evaluation in haskell
13:02:04 <cgroza> something like " $! "
13:02:05 <BMeph> elliott: Naugh, I've seen GHC 7; I'd prefer "someone else" give it a try. ;)
13:02:34 <elliott> all GHC errors should just become
13:02:35 <elliott> IT'S WRONG
13:02:35 <elliott> [one type
13:02:36 <elliott> ]
13:02:38 <elliott> [another type]
13:02:51 <elliott> maybe they should be equal, maybe one has to have the same instances as the other
13:02:55 <edwardk> hopefully, speaking up as the guy who is going to have to rewrite the most packages will end the semigroup discussion and we can move on
13:02:56 <elliott> only you can determine which
13:03:13 <mauke> preflex: quote . sensible
13:03:15 <preflex>  <augustss> ghc had a bug once where it deleted the source file if it had a type error. Quite sensible, I think.
13:03:16 <elliott> edwardk: you missed a word. maybe
13:03:24 <rwbarton> cgroza: basically "f $! x" is the same as "f x" except that when the result of "f x" is evaluated, "x" is evaluated first
13:03:25 <elliott> mauke: :D
13:03:26 <brisingr> cgroza: I've once stack overflowed on what I believe was a fold and an infinite list
13:03:32 <brisingr> but it's hard
13:03:32 <TTimo> cgroza: there are some gross things you can do .. and at some point bearded wizards start complaining about causality
13:03:55 <rwbarton> or perhaps I should say, when the result of "f x" is needed
13:04:14 <BMeph> elliott: Unaceptible. Your messages are much too concise, to-the-point, and understandable. ;)
13:04:15 <acowley> edwardk: I'm glad you came in on the side you did come in on. Thanks for stepping in!
13:04:38 <edwardk> i'll just tweak my packages to explicitly hide (<>) once it becomes visible
13:04:39 <elliott> BMeph: no, no no no. it shows the types as they appear _in Core_.
13:04:41 <BMeph> *Unaceptable
13:04:47 <elliott> edwardk: or did I misparse
13:04:51 <edwardk> and in the meantime nobody gets hurt
13:04:52 <dafis> *Unacceptable
13:05:08 <edwardk> elliott: not sure which sentence you are referring to
13:05:20 * BMeph blames the wireless keyboard. It's okay, it doesn't mind.
13:05:25 <cgroza> interesting. thank you for the clarification.
13:05:28 <edwardk> i probably have about 200 small edits to make as a result
13:05:50 <BMeph> Sweet! 777 users, that's very lucky! :D
13:06:06 <elliott> edwardk: <edwardk> hopefully, speaking up as the guy who is going to have to rewrite the most packages will end the semigroup discussion and we can move on
13:06:26 <BMeph> Even sweeter that only one person quit (and another joined) since I started typing that. :)
13:06:35 <edwardk> elliott: written as intended
13:06:35 <dafis> elliott: seems correct to me
13:06:49 <geheimdienst> BMeph: 666+111, because #haskell goes to eleventy
13:06:54 <elliott> edwardk: oh, i can parse it now
13:07:43 <BMeph> elliot: Hopefully, maybe? ;)
13:19:15 <Tasser> where do I find the haskell sources for basic functions like map or filter?
13:19:38 <shachaf> @src map
13:19:38 <lambdabot> map _ []     = []
13:19:39 <lambdabot> map f (x:xs) = f x : map f xs
13:19:40 <shachaf> @hackage base
13:19:41 <lambdabot> http://hackage.haskell.org/package/base
13:19:51 <shachaf> @source Data.List
13:19:51 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
13:20:16 <shachaf> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html
13:22:19 <ion> tasser: Hoogle them, open the documentation, click the Source link.
13:24:08 <tulcod> oh i love all these ridiculous names for certain haskell web resources
13:24:10 <tulcod> i just love them
13:28:01 <mauke> edwardk: so I'm watching your Lenses talk
13:28:12 <mauke> it's nice but holy fuck is it slow
13:28:24 <edwardk> it is targeted at scala folks who have never written functional code
13:28:39 <edwardk> i was going to say folks here aren't really the target demographic
13:29:26 <brisingr> edwardk: may I see the talk too?
13:29:49 <edwardk> http://www.youtube.com/user/edwardkmett?feature=mhee
13:29:58 <brisingr> thanks
13:30:02 <edwardk> if the video doesn't start the 'lenses a functional imperative' ones
13:30:10 <edwardk> are the ones in question
13:30:55 <mauke> I don't know scala
13:31:07 <zhulikas> > let 0 = 1 in 0
13:31:08 <lambdabot>   0
13:31:12 <zhulikas> why?!
13:31:13 <mauke> does f.apply provide syntactic sugar for f(...)?
13:31:23 <edwardk> yeah
13:31:34 <edwardk> lets you use the object like a method
13:31:40 <edwardk> er like a function
13:31:44 <dolio> The talk's practically over 30 seconds in.
13:31:49 <dolio> Once you've seen the ambigram.
13:31:56 <edwardk> hahaha
13:32:24 <mauke> I would have preferred one that was "functional" in one direction and "imperative" in the other
13:32:27 <mauke> :-)
13:32:37 <edwardk> sure
13:32:45 <edwardk> and to the right audience i would have given that talk ;)
13:32:53 <MorelPisum> hi; quick question: is there a shorter form for `n:list ++ [n]' ?
13:33:00 * MorelPisum is sorry for his interruption...
13:33:30 <MorelPisum> `n:list ++ [n]' seems ugly to me
13:33:38 <MorelPisum> i'm sure there's a more elegant way...
13:33:52 <MorelPisum> isnt there?
13:33:57 <mauke> I can give you [n] ++ list ++ [n] for symmetry
13:34:05 <Peaker> zhulikas: because you're pattern matching 0 against 1, but the pattern match is not needed so not used
13:34:05 <shachaf> It's kind of an ugly operation.
13:34:06 <mauke> but list ++ [n] is morally ugly
13:34:15 <MorelPisum> symmetry is nice,.. but.. it's not shorter..
13:34:32 <shachaf> Yes, what mauke said.
13:34:39 <MorelPisum> shachaf: OK.
13:34:41 <zhulikas> @type 0
13:34:42 <lambdabot> forall t. (Num t) => t
13:35:05 <Peaker> > case 0 of 1 -> 0
13:35:06 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
13:35:11 <MorelPisum> @let p [x] = []
13:35:12 <lambdabot>  Defined.
13:35:31 <Peaker> zhulikas: let is more forgiving than case -- it only tries the actual pattern match if it needs a binding from the pattern match (or if a strictness annotation is used)
13:35:35 <MorelPisum> @let p (x:y:z) = (x+y):p (y:z)
13:35:35 <lambdabot>  <local>:6:18:
13:35:36 <zhulikas> how is that a pattern if that's a function name
13:35:36 <lambdabot>      Ambiguous occurrence `p'
13:35:36 <lambdabot>      It could refer to either `L...
13:35:56 <shachaf> MorelPisum: Don't use @let. Just use let ... in ..., and fit it all on one line.
13:35:57 <geheimdienst> > let 123 = succ in 42
13:35:58 <lambdabot>   42
13:36:14 <Peaker> zhulikas: let binds names -- and these name bindings are allowed to be patterns:
13:36:26 <zhulikas> ok, I didn't know that
13:36:35 <Peaker> > let Just x = Just 5 in (show x ++ " was pattern-matched out of the Just")
13:36:36 <lambdabot>   "5 was pattern-matched out of the Just"
13:37:04 <Peaker> zhulikas: so let 0 = 1 in ...      is just a special case of that.. and not a very useful one :)
13:37:12 <MorelPisum> > let p [x] = []; p(x:y:z)=(x+y):p(y:z); pascal n = iterate (\l -> [n] ++ (p l) ++ [n]) [n]; in mapM_ (putStrLn.show) (pascal 1)
13:37:16 <lambdabot>   <IO ()>
13:37:16 <Peaker> It binds no names that will be used, so it essentially ignored
13:37:24 <MorelPisum> > let p [x] = []; p(x:y:z)=(x+y):p(y:z); pascal n = iterate (\l -> [n] ++ (p l) ++ [n]) [n]; in mapM_ show (pascal 1)
13:37:27 <lambdabot>   *Exception: stack overflow
13:37:27 <zhulikas> I am just fooling around with such definitions actually :D
13:37:35 <zhulikas> checking what language is capable of
13:38:01 <brisingr> ooh, we've got a stack overflow
13:38:02 <MorelPisum> wtf?? the code works for me ..
13:38:14 <brisingr> where is cgroza?
13:38:52 <MorelPisum> > let p [x] = []; p (x:y:z) = (x+y):p (y:z); pascal n = iterate (\l -> [n] ++ (p l) ++ [n]) [n]; in mapM_ show (take 10 (pascal 1))
13:38:54 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
13:39:00 <mauke> > let c = (\f -> f a b) in c 1 2
13:39:01 <lambdabot>   1
13:39:03 <k0ral> is there a trick to perform a kind of "maybe" function on a tuple of Maybe elements so that if any element is Nothing, a fallback function is executed ?
13:39:18 <hpc> a tuple or a list?
13:39:22 <shachaf> k0ral: On a tuple? No.
13:39:30 <mauke> k0ral: what would its type be?
13:39:31 <k0ral> well, I wrote "tuple" :)
13:39:48 <hpc> there's almost nothing convenient for working with tuples
13:40:02 <hpc> unless you s/any/either/ :P
13:40:06 <shachaf> hpc: Sure there is. Syntax, for one.
13:40:36 <k0ral> trying to build its type
13:40:58 <k0ral> maybe recursively
13:41:10 <k0ral> hmmm not in a tuple then
13:41:16 <k0ral> ok let's say in a list
13:42:14 <cgroza> I am here. How did you do it?!?!
13:43:06 <k0ral> maybe' :: b -> ([a] -> b) -> [Maybe a] -> b
13:43:13 <k0ral> not sure this is right
13:43:24 <brisingr> let p [x] = []; p(x:y:z)=(x+y):p(y:z); pascal n =  iterate (\l -> [n] ++ (p l) ++ [n]) [n]; in mapM_  show (pascal 1)
13:43:47 <brisingr> that's what
13:43:49 <brisingr> ooh wait
13:44:02 <brisingr> did I overwrite someone's useful definition?
13:44:04 <brisingr> uhh
13:44:06 <brisingr> sorry
13:44:11 <k0ral> hpc: for lists then
13:44:29 <brisingr> so that above made lambdabot overflow
13:45:27 <Megant> k0ral: you probably want a -> b instead of [a] -> b
13:46:13 <hpc> :t maybe
13:46:14 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:46:21 <hpc> :t sequence
13:46:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:46:44 <brisingr> cgroza: you can stack overflow by applying lazy folds to big lists
13:46:50 <hpc> :t \f ms -> maybe f (sequence ms)
13:46:51 <lambdabot> forall a a1. [a1] -> [a -> a1] -> Maybe a -> [a1]
13:47:14 <hpc> :t \z f ms -> maybe z f (sequence ms)
13:47:15 <lambdabot> forall b a. b -> ([a] -> b) -> [Maybe a] -> b
13:47:15 <cgroza> brisingr: ok, thakns :D
13:47:20 <hpc> there we go, i think
13:47:24 <k0ral> Megant: I think I really want [a] -> b since I want either all the list, or nothing; the result can't be computed element by element; all are needed
13:47:25 <brisingr> cgroza: no problem
13:47:25 <hpc> wait no
13:47:42 <hpc> anyhoo, sequence and pattern-matching will do you well
13:47:53 <k0ral> waw, impressive
13:48:06 <k0ral> never met sequence before
13:48:17 <k0ral> I guess this will make my life a lot easier
13:48:20 <Megant> k0ral: ah, that's what you wanted. okay then
13:48:21 <k0ral> thank you
13:50:19 <Peaker> @hoogle sequenceA
13:50:19 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
13:50:19 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
14:18:14 <Plouj> hi
14:18:26 <Plouj> how can I use ghci as a calculator such that 1069.68-1039.59+1.53-7.49-22.60 gives me exactly 0?
14:20:39 <pedro3005> are you sure that's right?
14:20:50 <jrockway> >  (1069.68-1039.59+1.53-7.49-22.60) :: Rational
14:20:51 <lambdabot>   153 % 100
14:21:21 <Peaker> > 0 (1069.68-1039.59+1.53-7.49-22.60)
14:21:22 <lambdabot>   0
14:21:39 <Plouj> ooh, oops
14:21:40 <geheimdienst> Peaker: yeah, way to clarify the issue :)
14:21:42 <Plouj> remove the 1.53
14:21:51 <acowley> > let calc = const 0 in calc "1069.68-1039.59+1.53-7.49-22.60"
14:21:52 <lambdabot>   0
14:21:57 <acowley> nailed it
14:22:02 <Plouj> echo "1069.68-1039.59-7.49-22.60" | bc
14:22:02 <Plouj> 0
14:22:11 <Peaker> > (1069.68-1039.59-7.49-22.60) :: Rational
14:22:12 <lambdabot>   0 % 1
14:22:31 <Plouj> so I need to put it in brackets and add :: Rational?
14:22:44 <Peaker> Plouj: no, you just need to make your numeric type for the arithmetic be Rational
14:22:56 <Plouj> huh?
14:22:57 <acowley> you don't even need the parentheses!
14:23:01 <Plouj> I just want to use ghci as a calculator
14:23:03 <jrockway> > 1069.68-1039.59-7.49-22.60
14:23:04 <lambdabot>   1.4210854715202004e-13
14:23:12 <acowley>  > 1069.68-1039.59-7.49-22.60 :: Rational
14:23:20 <jrockway> > fromRational $ 1069.68-1039.59-7.49-22.60
14:23:21 <lambdabot>   0.0
14:23:21 <Peaker> Plouj: if type inference can deduce it is a rational from any constraint on types anywhere, that's enough
14:23:52 <acowley> Can one easily change GHCi's defaulting rules?
14:23:56 <Plouj> Peaker: what other than :: Rational can I write on the command? I'm looking for the shortest thing.
14:24:15 <jrockway> why use ghci as a calculator?  that's not what it's for and there are better tools available.
14:24:19 <Peaker> Plouj: oh sorry, I missed that you're just talking about ghci
14:24:31 <Peaker> Plouj: yeah, just throw a ::Rational
14:24:35 <Plouj> jrockway: cuz it's the first thing that comes to my mind :)
14:24:48 <Plouj> and it has readline support
14:26:04 <geheimdienst> Plouj: you might want to check out bc. it's probably already installed on your system
14:26:08 <jrockway> "the first thing that comes to one's mind" is rarely the best solution
14:26:17 <acowley> I use GHCi as a calculator sometimes, too
14:26:22 <jrockway> yes, and it supports readline :)
14:26:30 <brisingr> if you insist on using ghci, just type
14:26:32 <brisingr> :: Ra
14:26:32 <acowley> it's handy because you can quickly build up more complicated bits and pieces
14:26:34 <brisingr> and then tab
14:26:52 <jrockway> you can in bc, as well
14:26:54 <jrockway> x = 2 + 2
14:26:56 <jrockway> 2 + x
14:26:58 <jrockway> 6
14:27:15 <brisingr> you don't have monads in bc ;)
14:27:29 <jrockway> and it supports readline.  and it gets the "right" answer to the original problem with no work
14:27:57 <jrockway> i doubt anyone is REALLY going to prefix every simple arithmetic problem they want solved with "fromRational" or end it with ":: Rational"
14:28:10 <jrockway> it's a needless step that computers are designed to eliminate
14:31:13 <Peaker> does bc use rational numbers?
14:31:32 <Peaker> bc says 1/100000000000000000 == 0
14:31:58 <Peaker> there may be nicer calculators than ghci, but I don't think bc is one
14:32:08 <brisingr> what I'd do if I were bc is use say 2 more bits of precision then round it
14:32:15 <accel> how smart does a a programming langauge ahve to be
14:32:19 <roconnor> @hoogle insert
14:32:19 <lambdabot> Data.HashTable insert :: HashTable key val -> key -> val -> IO ()
14:32:20 <lambdabot> Data.IntMap insert :: Key -> a -> IntMap a -> IntMap a
14:32:20 <lambdabot> Data.IntSet insert :: Int -> IntSet -> IntSet
14:32:28 <Plouj> ah, I think I know what happened
14:32:34 <accel> how smart does a a programming langauge ahve to be for it to be able to say: "looks like you're linearly checking every element of a sorted list; let me do binary search for you instead"
14:32:39 <mceier> Peaker: use scale=100 :) and you will get .0000000000000000100000000000000000000000000000000000000000000000000\
14:32:47 <mceier> in bc :)
14:32:52 <c_wraith> accel: nothing faster than a linear search in a linked list.
14:33:02 <kmc> accel, you can't efficiently binary-search Haskell lists, anyway
14:33:02 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
14:33:06 <Plouj> I originally tried using bc for doing rational math, eg what Peaker said then when it gave me an answer I didn't want: 0, I decided to use ghci
14:33:18 <ion> Haskell needs Clippy.
14:33:23 <Plouj> now I tried using ghci for arbitrary precision, which is different
14:33:25 <danharaj> Lambdy
14:33:33 <danharaj> An anthropormorphic lambda
14:33:33 <geheimdienst> peaker: i dimly remember bc uses arbitrary-precision numbers. in any case it's not floats, so you don't have these silly "-0.00000002" results
14:33:34 <accel> how smart does a a programming langauge ahve to be for it to be able to say: "looks like you're linearly checking every element of a strict, sorted vector; let me do binary search for you instead"
14:33:45 <ion> Does it echo in here?
14:33:58 <brisingr> echooo
14:34:08 <danharaj> accel: Dependent types.
14:34:10 <c_wraith> accel: dependent-typing, probably.  It needs to carry some sort of proofs of the status of the array
14:34:39 <Peaker> accel: that's more of something I'd want from an IDE -- "Your code's semantics is equivalent to this from the stdlib (can use hlint-like matching on code patterns) -- why not use that?"
14:35:24 <accel> damn it
14:35:33 <Peaker> knowing the array is sorted is not enough, you also need to know that what's being done is a linear search that compares the property the array is sorted upon
14:35:34 <accel> that qusetion swas meant to be a troll against advanes of ghc
14:35:40 <accel> didn't realize people had actual technical answers
14:35:42 * accel face palms
14:36:21 <danharaj> Most of the people here are not afraid to ask how to push the boundaries of what a programming language can do.
14:36:39 <copumpkin> byorgey: is there a pure (non-cairo) svg backend for diagrams?
14:36:39 <danharaj> After all, we're not insistent on using a language that has ignored 40 years of research and development.
14:36:54 <Peaker> Hmm.. actually, with dependent types -- if your code generates the proofs that your result is a result of a search -- the code that generated that result can be replaced.. Yet another interesting potential consequence of DT's...
14:36:55 <jmcarthur> troll fail
14:37:30 <danharaj> Peaker: I think it's all a matter of how much your optimizer can assume. The more assumptions the language gives the optimizer, the more drastic and aggressive its transformations can be.
14:37:32 <Peaker> so you don't need to structurally compare the code -- you can just look at the type.. if it's informative enough, the code becomes irrelevant
14:37:53 <Peaker> danharaj: yeah, and DT's give the compiler far more assumption-room
14:38:02 <danharaj> The ultimate extreme is an optimizer that is essentially just a program extractor from types.
14:38:33 <brisingr> okay I'm in need of a code snippet which best illustrates the functional nature of haskell
14:38:44 * brisingr is desperate
14:38:54 <c_wraith> functional?  map is  good
14:38:56 <acowley> What would the type of a result due to a search look like?
14:38:57 <accel> jmcarthur: noted; next time I'll read a few research papers before I start trolling hakell
14:39:03 <Peaker> If you can mechanically prove a type has just 1 value -- you can rewrite the code that builds it to anything you would like
14:39:14 <brisingr> thx
14:39:22 <Peaker> brisingr: histogram = map (head &&& length) . group . sort
14:39:25 <acowley> or do you want to use convention to establish names for things
14:39:37 <Peaker> brisingr: powerset = filterM (const [True,False])
14:39:58 <brisingr> Peaker: thx, awesome
14:40:24 <danharaj> quicksort is nice
14:40:31 <danharaj> 'quicksort'
14:40:33 <Peaker> danharaj: the nice one isn't quicksort
14:40:37 <danharaj> heapsort
14:40:41 <brisingr> that goes to "Elegant, concise and abstract"
14:41:33 <Peaker> decodeNumber base digits = sum (zipWith (*) (reverse digits) (iterate (base*) 1))
14:41:48 <jmcarthur> @remember accel next time I'll read a few research papers before I start trolling hakell
14:41:48 <lambdabot> Nice!
14:44:16 <danharaj> brisingr: How about representing an expression tree as an ADT and writing an evaluation function for it almost trivially?
14:44:39 <ion> decodeNumber base = foldl' (\a x -> base*a + x) 0
14:44:53 <brisingr> that may go later on
14:45:04 <brisingr> I want to start them gently, they don't know any FP
14:45:18 <brisingr> but thanks
14:46:05 <Peaker> brisingr: I personally think the filterM one is the most mind-bending hard of them
14:46:14 <Peaker> brisingr: decodeNumber is actually easy, and histogram the easiest
14:46:35 <Peaker> I think histogram is a lovely example for Haskell's type inference too
14:46:44 <danharaj> don't forget good ol fibo
14:46:46 <Peaker> @type map (head &&& length) . group . sort
14:46:47 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
14:47:23 <Peaker> I remember I found recursive examples in Haskell (as:  fib = 0 : 1 : zipWith (+) fib (tail fib)) less compelling..
14:47:27 <tromp> @src replicateM
14:47:28 <lambdabot> replicateM n x = sequence (replicate n x)
14:47:54 <ivanm> dammit, I left my test-suite to run when I finally went to get some sleep in the wee hours of the morning... and it had a stack overflow :s
14:48:03 * ivanm blames GHC-7.0 again
14:48:11 <brisingr> thanks again
14:49:59 <brisingr> histogram seems very good at the beginning
14:51:02 <brisingr> excellent in fact
14:51:15 <brisingr> to explain all the function composition things
14:52:07 <brisingr> fibo goes to... Lazy
14:52:17 <danharaj> make sure you use 1 : 1. :p
14:52:18 <brisingr> and quicksort to "elegant concise and abstract"
14:52:23 <aavogt> would this histogram still be simple if you wanted to specify  10 bins rather than 1 bin per value?
14:52:43 <ski> danharaj : no, it should be `0 : 1 : ...'
14:52:47 <danharaj> that's for haters.
14:53:08 <danharaj> Some people don't have a concept of 0.
14:53:16 <Peaker> brisingr: don't call it quicksort
14:53:24 <Peaker> aavogt: what do you mean?
14:53:35 <brisingr> Peaker: what do you mean?
14:53:46 <brisingr> oh, right
14:53:49 <brisingr> "quick"sort
14:54:00 <Peaker> brisingr: quicksort is a specific algorithm involving swapping large elements from the left side with large ones in the right side, in-place
14:54:05 <ski> danharaj : the sooner they get one, the better ..
14:54:14 <mauke> Peaker: that's racist!
14:54:26 <Peaker> brisingr: there's a full description of the quicksort algorithm -- the 3-line sort function isn't really an implementation of that
14:54:27 <brisingr> Peaker: oh, I didn't know that
14:54:29 <aavogt> Peaker: if you plot the points given by  (map (head &&& length) . group . sort), you don't do any smoothing of the data
14:54:41 <mauke> I disagree with Peaker's definition
14:54:51 <elliott> slowsort
14:55:01 <brisingr> I'll call it qsort
14:55:07 <danharaj> slicksort
14:55:12 <brisingr> and everyone's happy, right?
14:55:15 <brisingr> ...right?
14:55:23 <mauke> brisingr: C programmers won't be :-)
14:55:52 <VHD> erm beginner here, I understand IO operations have to be done in main, but how can I write functions which read inputs?
14:55:56 <brisingr> When they see Histogram they'll be like "is this guy trying to prove C is dumb?"
14:56:05 <ivanm> @hoogle readLine
14:56:06 <lambdabot> Network.Stream readLine :: Stream x => x -> IO (Result String)
14:56:06 <lambdabot> Network.TCP readLine :: HStream bufType => HandleStream bufType -> IO (Result bufType)
14:56:06 <lambdabot> module System.Console.Editline.Readline
14:56:08 <mauke> VHD: IO operations don't have to be done in main
14:56:22 <Peaker> mauke: well, according to Wikipedia the definition is lenient.. but I think Hoare's paper defined it pretty specifically
14:56:33 <mauke> Peaker: maybe he was wrong then
14:56:36 <ski> VHD : I/O operations doesn't have to be done in `main', then just have to be called (directly or indirectly) from `main'
14:56:41 <kmc> VHD, http://www.haskell.org/haskellwiki/Introduction_to_IO
14:57:07 <Peaker> VHD: main is the IO action that's magically executed when you run a Haskell program.  main can be composed from IO actions defined anywhere
14:57:34 <ski> VHD : also, any function that does I/O will need to have `IO' in the result type in the type signature (either explicitly or implicitly hidden in another type)
14:57:36 <VHD> hmm ok, I will read that wiki and return if it still confuses me. Thank you.
14:57:46 <Peaker> VHD: printTwice x = print x >> print x          main = printTwice 5 >> printTwice 10
14:57:52 <VHD> hold on, but what if the return type is say an int?
14:58:05 <ski> VHD : then you will nee to change the return type to `IO Int'
14:58:09 <ski> s/nee/need/
14:58:11 <VHD> ahh ok
14:58:14 <kmc> i'm strongly in favor of putting these standard answers to standard questions in writing
14:58:30 <kmc> on the wiki or elsewhere
15:02:43 <siracusa> kmc: Could be put here http://www.haskell.org/haskellwiki/FAQ (which would be nice to have in the topic).
15:03:59 <geheimdienst> kmc: yeah, why don't you start writing something in the wiki, possibly on that FAQ page
15:04:01 <geheimdienst> :D
15:04:03 <shachaf> I'm not sure kmc knows about that page.
15:04:23 <geheimdienst> shachaf: luckily we had siracusa tell him
15:04:59 <shachaf> That page mostly looks like it has the sorts of things kmc would agree with.
15:06:01 <ivanm> @ask chrisdone am I correct in understanding that I have to start the project before loading any .hs files?
15:06:01 <lambdabot> Consider it noted.
15:12:25 <aavogt> Peaker: http://hpaste.org/50312 <-- this what I mean by a not-useful histogram function
15:13:06 <aavogt> since in this case you have too many different input values, you end up with all the groups having only one element
15:13:49 <Peaker> aavogt: if you want to group similar elements, you can use groupBy.. it still remains nice&elegant
15:14:45 <Peaker> I guess not much of the original function would remain, but it could still be simple&elegant
15:14:49 <sshc> Are parallel list comprehensions part of the '98 standard?
15:15:26 <aavogt> sshc: no
15:16:00 <sshc> Ah, ParallelListComp
15:25:51 <clsmith> there doesn't happen to be a lyah-like for category theory, does there? ;p
15:26:51 <zzo38> Is this how to make a parser, it doesn't work. I get the message:   Exception when trying to run compile-time code:   <stdin>: hGetContents: illegal operation (handle is closed)   Code: parseConstantinople   In the expression: $parseConstantinople   In an equation for `it': it = $parseConstantinople
15:27:02 <zzo38> parseConstantinople = runIO getContents >>= (monadify .:: parse) (programParser $ VarE 'return) "";
15:27:06 <Eduard_Munteanu> clsmith: hm, not really
15:27:14 <clsmith> i'm reading this book on it and in the first chapter it gives 7 strict mathematical definitions in 3 pages :/
15:27:15 <kmc> you're writing your parser with Template Haskell?
15:27:28 <Eduard_Munteanu> clsmith: what book?
15:27:29 <zzo38> kmc: I am using Parsec.
15:27:49 <kmc> and Template Haskell?
15:27:55 <zzo38> Yes, and Template Haskell.
15:27:57 <clsmith> Eduard_Munteanu: categories, types, and structures (an introduction to category theory for the working computer scientist) -- asperti & longo
15:28:10 <kmc> why the TH?
15:28:13 <zzo38> I typed in part of the input and then after typing in three lines, this error message came up.
15:28:16 <jmcarthur> does anybody know of a package that has a StreamT monad transformer?
15:28:36 <jmcarthur> bonus points if it's a well polished package, of course
15:28:44 * Eduard_Munteanu looks
15:28:45 <aavogt> zzo38: from that message it looks like you can't use stdin for input with TH
15:28:52 <aavogt> reading files works just fine though
15:29:08 <brisingr> Eduard_Munteanu: May I ask you a question?
15:29:18 <zzo38> kmc: This program is a compiler.
15:30:01 <Eduard_Munteanu> Yeah, but you might want to ask the channel if it's a general question?
15:30:14 <aavogt> also the    (VarE 'return), if you have lots of this  is sometimes better done as  [| return |]
15:30:15 <brisingr> nope,
15:30:25 <brisingr> in romana se scrie monad-monazi sau monadă-monade?
15:30:58 * benmachine pokes synesthesia 
15:31:02 <Eduard_Munteanu> brisingr: hm, I'm not sure. I haven't read any Romanian books on that, but I'd guess "monade".
15:31:06 <clsmith> zzo38: it's probably an API change: you mean $parseIstanbul
15:31:11 <brisingr> ok, thanks
15:31:21 <Eduard_Munteanu> brisingr: there's something on the wiki though, lemme look.
15:31:33 <zzo38> clsmith: It is a function I am writing myself. It doesn't matter what I call it.
15:31:52 <Eduard_Munteanu> brisingr: http://www.haskell.org/haskellwiki/Monade
15:32:00 <brisingr> thanks
15:32:05 <zzo38> Yes, I guess it does not read stdin because this doesn't work either:    $(runIO getLine >>= return . LitE . StringL)
15:32:08 <clsmith> zzo38: i know i was just doing a funny :(
15:32:46 * Eduard_Munteanu remembers some of those pages might need a serious cleanup (remove political statements etc.)
15:32:47 <zzo38> Ha ha ha ha ha joke
15:33:03 <clsmith> hoho. :]
15:33:16 <zygoloid> Eduard_Munteanu: ah, le monade. delicious!
15:33:29 <Peaker> jmcarthur: StreamT as in ListT without the nil case?
15:33:31 <zzo38> How can I correct this problem, then?
15:33:42 <jmcarthur> Peaker: yeah
15:33:57 <Peaker> zzo38: >>= is left-to-right, . is right-to-left... it's better not to mix RTL and LTR.. Use =<< with .
15:34:07 <Peaker> (or >>= with >>>)
15:34:29 <jmcarthur> something like newtype StreamT m a = StreamT (m (a, StreamT m a)), i think
15:34:39 <Eduard_Munteanu> zygoloid: no, not French :P
15:35:07 <zygoloid> Eduard_Munteanu: chrome tells me it's romanian. but that ruins the joke
15:35:13 <jmcarthur> which i believe is in the spirit of "ListT Done Right"
15:35:55 <Peaker> jmcarthur: maybe you should add it to the List package, and make a pull request :-)
15:36:01 <zzo38> Peaker: You think that is the problem? No, I think the problem is that Template Haskell doesn't work with stdin, like aavogt said it is. It works when I replace  getLine  with  (return "42")
15:36:12 <Eduard_Munteanu> clsmith: that book looks interesting. Don't be afraid of formal stuff, it's nice to know exactly what one means when you're in doubt.
15:36:14 <Peaker> zzo38: no, just commenting on style :)
15:37:21 <rwbarton> in my experience template haskell likes to execute IO actions multiple times
15:37:26 <zzo38> Peaker: OK.
15:37:39 <rwbarton> for example if you try to print something, you'll often get multiple copies of it
15:37:55 <rwbarton> and executing getContents multiple times would produce that error
15:38:39 <Eduard_Munteanu> @where cts
15:38:39 <lambdabot> I know nothing about cts.
15:39:15 <Eduard_Munteanu> @where asperti
15:39:15 <lambdabot> I know nothing about asperti.
15:40:52 <clsmith> Eduard_Munteanu: the only problem, i guess, is the author doesn't seem to illustrate anything; he just gives a definition and expects you to know how to apply that. like as an exercise it says, "Set{op} is a subcategory of Rel, but not of Set. is it a full subcategory?" and this point i don't know why the hell Rel, which apparently has "relations" for morphisms, has the dual category of Set as a subcategory.
15:40:53 <Eduard_Munteanu> @where+ cts "Categories, types and structures", A. Asperti, G. Longo: http://www.cs.unibo.it/~asperti/PAPERS/book.pdf
15:40:53 <lambdabot> Nice!
15:41:01 <clsmith> Eduard_Munteanu: i just .. really don't know.
15:42:20 <Eduard_Munteanu> clsmith: do you know about relations?
15:42:48 <Eduard_Munteanu> and how they differ from functions?
15:43:35 <clsmith> not really. i looked at a page in wikibooks, but it didn't really explain anything :p
15:44:45 <Eduard_Munteanu> Functions are "special" relations.
15:45:50 <Eduard_Munteanu> Relations are allowed to be partial and/or evaluate to multiple values, which functions aren't.
15:46:00 * hackagebot cabal2nix 1.11 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.11 (PeterSimons)
15:46:27 <Eduard_Munteanu> That's because they're just triples (A, B, R) where R is a subset of A x B.
15:47:14 <clsmith> hmm, okay
15:50:06 <Eduard_Munteanu> So while every function can be seen as a relation, it's not true the other way around.
15:50:31 <hpaste> benmachine pasted “mlist monoid” at http://hpaste.org/50317
15:50:47 <benmachine> ^ can anyone advise me as to whether that's a good monoid instance?
15:50:54 <benmachine> the only non-trivial thing is right identity
15:51:12 <benmachine> which I *think* I can prove sort of inductively but I'm not sure
15:51:35 <Eduard_Munteanu> (where dom(f) = A, cod(f) = B, R = {(a, b) | a ∈ A, b = f(a)}
15:55:17 * synesthesia pokes benmachine
15:55:51 <benmachine> hi
15:56:05 <benmachine> I didn't want anything in particular :P
15:56:34 <synesthesia> benmachine: haha, no worries.
15:56:45 <synesthesia> I do believe I'm experiencing camhak withdrawal sydrome
15:56:59 <benmachine> I'm experiencing sleep withdrawal syndrome, mostly
15:57:07 <benmachine> camhac-induced, possibly
15:57:11 <synesthesia> hmm, that may actually be what I'm experiencing too
15:57:15 <synesthesia> though it's hard to tell the difference
15:57:19 <clsmith> Eduard_Munteanu: ah, i think i might understand now. so Set{op} is a subcat of Rel but not Set because the dom and cod switch, so the functions become relations because they switch from many-to-1 (values) to 1-to-many?
15:57:20 <jules2> what does it mean to define a type inside a class definition? like class Foo a where\n type Bar a\n...
15:57:33 <synesthesia> jules2: it's an associated type
15:57:41 <Peaker> Monad can be defined via   return+fmap+join.   What's the equivalent for Comonad?  extract+fmap+duplicate?
15:57:48 <jules2> synesthesia, thanks, i'll google it
15:57:51 <synesthesia> jules2: http://www.haskell.org/haskellwiki/GHC/Type_families
15:57:59 <jules2> :)
15:57:59 <edwardk> yes
15:58:00 <synesthesia> jules2: I bet they've coded lambdabot to do that for you
15:58:09 <synesthesia> (the googling)
15:58:31 <jules2> how do i summon it?
15:58:41 <Peaker> So both Monad and Comonad are covariant.. Is there any interesting (monad-like?) extension of Contravariant (ContraFunctor)?
15:58:44 <synesthesia> tbh, I've no clue, but I bet others have intimate knowledge
15:58:47 <edwardk> nope
15:59:05 <edwardk> you stall out around coapplicative ;)
15:59:14 <edwardk> er contraapplicative
15:59:37 <Peaker> hmm...  pure is the same,  ap :: f (a -> b) -> f b -> f a  ?
15:59:44 <synesthesia> benmachine: I think I'm going to have to give up... err go to bed.
15:59:46 <Peaker> oh wait, pure isn't the same
15:59:53 <synesthesia> benmachine: this is indeed sleep deprivation
16:00:01 <benmachine> synesthesia: :) good night, then
16:00:04 <synesthesia> same
16:00:07 <benmachine> was nice talking to you etc.
16:00:08 <edwardk> actually pure should go the opposite way in a way that forces you to just have f Void
16:00:13 <synesthesia> and pleasure meeting (all of you) this weekend
16:00:58 <Peaker> edwardk: f Void -> a  ?
16:01:15 <Peaker> that makes no sense, sorry :-)
16:01:22 <edwardk> i think cmccann hpasted one the other day
16:01:41 <edwardk> whenhe was playing around trying to understand what was useful in the contravariant functor space
16:01:48 <edwardk> but in haskell contravariant functors are pretty boring
16:02:02 <Peaker> intuitively, I'd expect there to be some kind of symmetry
16:02:06 <edwardk> since there is really only 1 (function) and a bunch of stuff that acts like a function with stuff bolted on top
16:02:26 <edwardk> well, the problem is one takes a category to itself the other has a twist
16:02:35 <edwardk> the twist breaks symmetry
16:03:41 <edwardk> symmetry would lead you to think well, 1 * 1 is 1, so -1 * -1 = -1, but that'd be wrong ;)
16:04:02 <zzo38> Yes it does perform output multiple times. How can I rewrite the program to correct it so that it works regardless of I/O?
16:04:15 <zzo38> Yes it does perform output multiple times. How can I rewrite the program to correct it so that it works regardless of I/O number of times?
16:04:16 <Eduard_Munteanu> clsmith: yeah, I think so
16:04:31 <Eduard_Munteanu> clsmith: btw, there's ##categorytheory too
16:07:35 <zzo38> What is the best way to correct it? And why does Template Haskell do that?
16:08:21 <Peaker> Maybe the TH actions can be memoized?  but then you'd need them to have some memoization table/memoizer as a lexical scope
16:09:12 <clsmith> Eduard_Munteanu: okay, thanks :)
16:09:34 <rwbarton> there should be some hackish function IO a -> IO a that causes its argument to get executed only once even if the result is executed multiple times
16:10:10 <rwbarton> possibly involving unsafePerformIO
16:10:19 <jmcarthur> i don't think unsafePerformIO is necessary for that
16:10:22 <zygoloid> rwbarton: sounds easy enough to build one of the form  IO a -> IO (IO a).
16:10:26 <Saizan> IO a -> IO (IO a) is more doable
16:10:31 <Peaker> yeah, you could unsafePerformIO on the non-hacky memoize of type IO (IO a)
16:10:34 <rwbarton> right
16:11:05 <Peaker> jmcarthur: IO a  cannot memoize its result without some sort of shared context whose creation requires an IO action too
16:11:29 <Eduard_Munteanu> Maybe going through FFI?
16:11:38 <zzo38> How would I do that? I prefer to not use the "unsafePerformIO" and that kind of stuff but I could do if it is necessary to do it in this way somehow
16:11:55 <rwbarton> your other question is a good one
16:12:22 <ourfrank> Can you recommend a package on hackage that uses c2hs? I just unpacked almost all of the bindings-* packages and none of them did.
16:12:26 <zzo38> Is there any way to do it using the "reify" command somehow?
16:13:15 <rwbarton> if you only need to do this in one place, all you need is a single MVar created with unsafePerformIO
16:13:22 <Saizan> to do what, precisely?
16:13:28 <rwbarton> at top level I mean
16:13:36 <Jafet> ourfrank: note that c2hs would be a binary dependency
16:14:06 <rwbarton> Saizan: work around the fact that TH seems to execute IO actions lifted into the Q monad multiple times for some reason
16:14:25 <rwbarton> so that you can process stdin with getContents for example
16:14:32 <ourfrank> Jafet: I meant, contains and uses *.chs files.
16:15:31 <ourfrank> Jafet: So, installing that package would mean needing to have c2hs. I'm having trouble making c2hs work (and work with cabal), so I'd like to find some examples.
16:16:31 <zzo38> When the program is actually running I would redirect input from a file into ghc, so it will be seekable, but that won't do when doing testing with ghci.
16:17:01 <kmc> ourfrank, ezyang's blog has a nice c2hs tutorial
16:17:49 <Saizan> zzo38: so you want to run getContents at compile time just so it's "easier" to test in ghci?
16:18:29 <Jafet> Hm, I thought gtk2hs used c2hs but it doesn't
16:18:35 <ourfrank> kmc: I went through it, but still receive an error. c2hs complains it cannot find a definition in any header files. This definition is within a file under cabal's c-sources.
16:18:38 <zzo38> Saizan: No, I want to run getContents at compile time so that I can redirect input of a different kind of programming language which I parse, into the Haskell compiler.
16:19:09 <hpaste> Peaker pasted “memoize & unsafePerformIO” at http://hpaste.org/50319
16:19:14 <ourfrank> hsc2hs didn't have troubles doing this, so I'm wondering what I'm doing wrong.
16:19:52 <Peaker> rwbarton: that seems to work
16:20:17 <rwbarton> yeah, that was what I had (vaguely) in mind :)
16:22:08 <dcoutts__> Jafet: gtk2hs does use c2hs, but an older custom fork of it
16:22:28 <jmcarthur> Peaker: indeed. i was misreading the type signature as IO a -> IO (IO a)
16:23:01 <dcoutts__> ourfrank: with c2hs you have to specify what header you want in the .chs file
16:23:06 <VHD> looking at http://zvon.org/other/haskell/Outputprelude/read_f.html not much guidance is given for when a read fails, how can I catch it?
16:23:09 <Peaker> I remember first time I had implemented some IO action modifier, I was kind of surprised it wasn't IO a -> IO a
16:23:32 <dcoutts__> ourfrank: and that must exist in the system or local include dirs listed in the .cabal file
16:24:02 <Peaker> btw: Is there some nice library of IO action decorators?  I implemented a nice "preemptive runner" (for latency hiding) that has a little thread pool of workers preemptively performing an action.. There's also a "runInBackground" that is useful, or a parallel (>>), and other stuff I code up as I need, but could be nice in a library
16:25:21 <ourfrank> dcoutts__: I didn't specify the headers I want within *.chs, so that's probably the problem. I should use the context command for this?
16:25:22 <Saizan> VHD: it's easier to use reads instead, so you can pattern match on the result list to tell if there was a successful parse
16:25:24 <kmc> runInBackground?
16:25:32 <dcoutts__> ourfrank: #include
16:25:41 <kmc> Peaker, i could probably add some of those to http://hackage.haskell.org/package/spawn
16:26:06 <Saizan> VHD: otherwise use readIO and Control.Exception.catch (or maybe .try)
16:26:09 <kmc> «mapM_ spawn» works all right as a parallel sequence_
16:26:23 <kmc> there's a bit of extra overhead but probably negligible
16:26:30 <VHD> im looking into reads thank you :)
16:27:07 <kmc> VHD, http://haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
16:27:54 <Saizan> @where read
16:27:54 <lambdabot> I know nothing about read.
16:28:09 <Saizan> @where+ read http://haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
16:28:09 <lambdabot> Okay.
16:30:05 <zzo38> I know that stdin will be seekable when my program is used properly, will that help anything?
16:31:15 <ourfrank> dcoutts__: Thanks! I have the definition of a struct within include/source.h, I have "include-dirs: include" and "includes: source.h" within the cabal file. I do "#include <source.h>" within the *.chs file. But the struct definition still cannot be found. I must be making some kind of elementary mistake.
16:31:49 <Phyx-> This may sound a bit weird, but is there anyway to see which instance of a class ghc is picking, and why?
16:33:01 <rwbarton> zzo38: yes, rather than use getContents you could write an IO action that seeks to the start and reads the whole file strictly
16:33:08 <ourfrank> dcoutts__: Eureka, it compiles. Thank you once more. (It was truly a silly and elementary mistake I made just now.)
16:33:23 <c_wraith> Phyx-: that does sound a bit weird.  Are you using strange extensions which make it hard to figure out?
16:34:32 <Phyx-> c_wraith: no, I'm using FlexibleContexts, MultiParamTypeClasses, FlexibleInstances TypeSynonumInstances and ForeignFunctionInterface
16:34:34 <sshc> Which versions of GHC incorporate RelaxedDependencyAnalysis?
16:34:51 <Phyx-> but the error I'm getting from GHC pertaining to the typeclass makes no sense to me
16:36:43 <c_wraith> well, multiparam can do odd things
16:36:48 <c_wraith> as far as reporting
16:39:46 <Phyx-> c_wraith: hm ok
16:41:41 <Saizan> yeah, when it says "No instance for Foo Int b" it might just mean that b is not instantiated enough for it to pick one of the more specific that exist
16:42:09 <zzo38> Is there a kind of getContents without closing the file?
16:43:51 <Entroacceptor> is there a way to derive functor outside of the module the datatype is defined in, when it doesn't export all constructors
16:44:05 <danharaj> don't do that
16:44:18 <danharaj> it's called an orphan instance and it is extremely frowned upon.
16:44:19 <Jafet> zzo38: getContents doesn't close the file; it just doesn't make much sense to use the file after that
16:44:37 <aavogt> zzo38: couldn't have at the top of your file:         $(valD (varP (newName "contents")) (normalB (runIO getContents >>= stringE)) [] ), then refer elsewhere to this contents variable
16:44:44 <Jafet> Well, maybe it does, but hGetContents definitely doesn't close the file.
16:45:10 <aavogt> err, I think  mkName should be used instead
16:45:17 <Entroacceptor> danharaj: I don't care about what others think :)
16:45:29 <Saizan> Entroacceptor: TH tends to be able to ignore scoping that way, but i'd try with StandaloneDeriving first
16:45:55 <danharaj> Entroacceptor: as long as you know how much of a deviant you are, it's fine :p
16:46:16 <Entroacceptor> Saizan: that gave me the problem of not having the constructor
16:46:24 <zzo38> In addition, is there a command to display a "Exp" value using Haskell syntax?
16:46:26 <Saizan> Jafet: it closes the file when you get to EOF
16:46:35 <zzo38> Jafet: The document says it semi-closes the file.
16:46:50 <Entroacceptor> anyway, I could just patch it
16:47:10 <Jafet> Oops, sorry
16:47:28 <Entroacceptor> or can someone tell me why data.tree.zipper (from rosetree) doesn't have fmap
16:47:47 <Entroacceptor> or something similar
16:47:48 <zzo38> I want to view a code generated from Template Haskell
16:47:56 <ivanm> OK, I'm definitely finding regressions with ghc-7 with my code... on a slower machine with 6.12.3, my code runs; on my faster machine with 7.0.4, it has a stack overflow :s
16:48:12 <aavogt> zzo38: in ghci  :set -ddump-splices      then               $myExp -- will print out what the code sort of looks like
16:48:23 <zzo38> OK.
16:48:43 <Jafet> ivanm: if you wait longer on the slower machine, do you get a stack overflow?
16:48:50 <ivanm> no, it runs
16:48:55 <ivanm> goes for the complete hour
16:49:22 <ivanm> whereas on my faster machine it stack overflows rather soon in to it
16:49:29 <Saizan> Marlow posted something about new tweaks for the stack, maybe they changed the defaults or something
16:49:35 <ivanm> (this is QC tests by the way, so it may be that QC doesn't like 7.0)
16:49:45 <ivanm> Saizan: I thought that was just 7.2
16:49:57 <Saizan> ah, yes, sorry
16:52:10 <ivanm> I notice it also takes a lot longer to compile (and typically spits out a lot of SpecConstr error messages) on modules with really big (as in > 100) constructors
16:54:35 <zzo38> Is this better?    (hSeek stdin AbsoluteSeek 0 >> getContents)
16:55:00 <shachaf> getContents is kind of evil.
16:55:13 <zzo38> shachaf: Then how do I do it better?
16:55:15 <shachaf> Also, you can't seek stdin (can you?).
16:55:27 <shachaf> Do what better?
16:55:28 <zzo38> Well, I will be redirecting stdin from a file
16:55:29 <Axman6> i'd be very surprised if you could
16:55:40 <shachaf> zzo38: Even so. It's stdin.
16:55:51 <shachaf> If you want a file, use a file.
16:56:09 <zzo38> But the program doesn't know what filename you want.
16:56:42 <zzo38> That is why I redirect from stdin instead.
16:57:39 <aavogt> zzo38: I think getArgs or getEnv work from TH
16:58:27 <Saizan> i think you'd be better off by making a text to text preprocessor and use it with -pgmF (?) like it's done for SHE
16:58:30 <Saizan> @where SHE
16:58:30 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
16:58:49 <zzo38> aavogt: Someone told me getArgs doesn't work in TH, although it seems correct that getEnv probably work
16:59:01 <Saizan> see the {-# OPTIONS_GHC -F -pgmF she #-} line
16:59:53 <zzo38> I suppose I can use a getEnv to read the filename, since it is a shellscript which calls the program anyways.
17:01:06 <zzo38> If getArgs does work in TH, what arguments would you get? Is there ghc options to tell the getArgs for Template Haskell?
17:06:25 <aavogt> zzo38: I get arguments like:  ["-B/usr/lib/ghc-7.0.2", "-pgmc", "/usr/bin/gcc", "-pgma", "/usr/bin/gcc", "-pgml", "/usr/bin/gcc", "-pgmP", "/usr/bin/gcc -E -undef -traditional", "--interactive", "-ddump-splices", "getargs.hs"]
17:07:28 <Jafet> That makes sense, since ghc just executes the code in its own process.
17:08:53 <zzo38> I get no arguments in ghci
17:09:05 <zzo38> Even though I specified the arguments on the command line when starting ghci
17:09:13 <zzo38> Whether I use Template Haskell or not
17:09:44 <zzo38> For what I am doing, though, I can just use getEnv
17:10:48 <Jafet> Perhaps because your ghci forks a ghc subprocess
17:11:44 <sshc> What was the issue that wxHaskell had with ghci?  Has this issue been resolved?
17:11:48 <aavogt> my results were from loading a file in ghci
17:11:53 <Eduard_Munteanu> You can somewhat "seek" stdin.
17:12:02 <Eduard_Munteanu> In the ungetc() sense.
17:12:19 * Eduard_Munteanu isn't sure about the Haskell part of that story though.
17:12:29 <ion> If stdin is a normal file, you can completely seek stdin.
17:13:08 <Eduard_Munteanu> That isn't really stdin anymore, though :/
17:13:15 <ion> Why?
17:13:26 <zzo38> ion: Yes it is what I thought, if you redirect stdin from a normal file
17:13:41 <Eduard_Munteanu> zzo38: a redirect won't do
17:13:49 <parcs> sshc: i believe you can't run a wx gui within ghci due to linking errors
17:14:02 <Eduard_Munteanu> You'd have to reassign stdin to a file handle or close it and reopen what you want.
17:14:13 <brisingr> quick question, in my talk, should I present explicit recursive fibo before or after the zipWith one?
17:14:17 <Eduard_Munteanu> *normal file
17:14:46 <clsmith> Eduard_Munteanu: really? in unix terms, stdin can be a seekable, normal file
17:14:51 <Eduard_Munteanu> brisingr: btw, where are you giving that talk?
17:15:08 <brisingr> forum IT, Targu Mures
17:15:13 <danharaj> brisingr: Before. It'll be more accessible, since you can define recursive functions in non-functional languages. You can introduce the zipWith one as an example of what you can do when you have the power of functional programming.
17:15:15 <ion> % ghc -e 'System.IO.hSeek System.IO.stdin System.IO.AbsoluteSeek 100 >> getContents' </etc/motd
17:15:18 <ion> "n:  https://help.ubuntu.com/\n\n"
17:15:23 <Eduard_Munteanu> clsmith: the mere name stdin? Sure.
17:15:26 <danharaj> (also the power of laziness)
17:15:37 <brisingr> yes
17:15:39 <brisingr> that too
17:15:41 <brisingr> thanks
17:16:13 <Eduard_Munteanu> I see.
17:16:14 <clsmith> Eduard_Munteanu: as in file descriptor 0, as assigned by the parent process
17:16:36 <danharaj> brisingr: One thing you want to emphasize is how natural functional programming is. Just like how we add, multiply, subtract, and divide numbers, there is a very natural 'algebra of functions': lambdas and application.
17:16:50 <brisingr> you're right
17:17:25 <brisingr> ideally I want to introduce the idea that it's the way our brains work
17:17:41 <kmc> i think that's a real hard sell
17:17:42 <danharaj> It took millennia for the idea of a function to be born :p
17:17:50 <zzo38> Well, yes getContents does close the handle so you cannot use it anymore; but seeking stdin does work.
17:18:07 <kmc> to me the argument "OOP is how people *really* think" or "FP is how people *really* think" smells like bullshit
17:18:14 <Eduard_Munteanu> ion: ah, indeed, I forgot '<' doesn't pipe stuff into the program
17:18:21 <kmc> brisingr, in my talk I'm focusing on the idea that Haskell constructs are very composable
17:18:28 <kmc> which is compelling but relatively concrete
17:18:28 <zzo38> Is there a "getContents and rewind" command?
17:18:32 <kmc> you can show a lot of examples
17:18:39 <brisingr> kmc: yes, that's my first example actually
17:18:43 <brisingr> real-world composition
17:18:47 <brisingr> histogram
17:18:53 <mun> i see that FOL is insufficient for describing reals, but is FOL categorically insufficient for describing uncountably infinite sets? all uncountably infinite sets?
17:18:55 * Jafet drags kmc into the miniluv
17:19:10 <brisingr> they'll understand it immediately, 'cause it uses predefined functions, just composed
17:19:13 <ion> brisingr: You may or may not want to mention spreadsheets as an example of declarative programming languages.
17:19:36 <danharaj> mun: You can describe the real numbers perfectly fine in first order logic. What you can't do is prove that they are unique, or that any model of the real numbers has the same cardinality for that matter.
17:19:58 <danharaj> mun: The idea of cardinality is part of set theory, of which virtually every version used by anyone is first order.
17:20:07 <brisingr> ion: good thinking
17:20:21 <ion> Thank SPJ. :-P
17:20:44 <brisingr> thanks SPJ... and ion
17:20:52 <ivanm> @tell chrisdone your ghci interaction doesn't like multi-line statement :(
17:20:53 <lambdabot> Consider it noted.
17:22:53 <gwern> it's funny, I saw a quote today from a programming textbook where the 'error' was obvious - the novice had been programming as if using lazy evaluation
17:23:27 <danharaj> that's funny and also slightly depressing
17:23:37 <mun> danharaj, so, as in how the natural numbers can be described in FOL, but the induction axiom itself is a second-order statement?
17:23:41 <danharaj> brisingr: You should spend some time on polymorphism in Haskell. Generic programming in Haskell is vastly more powerful than the hobbled and monstrous growths that are generics and templates in other languages. (Although D is not too shabby)
17:23:44 <shachaf> gwern: Understanding the evaluation model of whatever language you're using is important.
17:24:10 <brisingr> danharaj: yes, naturally
17:24:21 <danharaj> mun: In first order logic you replace the axiom of induction with an axiom scheme, which is an infinite set of axioms for each formula you can apply induction to. Since such a set is recursively enumerable it is entirely reasonable.
17:24:25 <gwern> shachaf: the novice justified it saying the logic was sound (as it was) and the computer ought to find the right order to executve lines in. which the textbook seemed to think was hilarious
17:24:26 <danharaj> schema*
17:24:48 <brisingr> danharaj: like showing sort or something, then saying, did I mention it works for anything that can be sorted?"
17:24:50 <danharaj> gwern: you must find every copy of this book and put a sticky note about Haskell on that page.
17:24:58 <mun> danharaj, could one pull the same trick as Peano arithmetic and have an infinite set of axioms for each definable set of reals?
17:25:00 <shachaf> gwern: What book/quote was it?
17:25:22 <gwern> don't remember. it was quoted in an essay I finised reading and deleted
17:25:26 <danharaj> mun: what kind of axioms? You can construct a countable model of the reals in first order logic if that's what you're asking.
17:26:01 * hackagebot pointed 2.0.1 - Haskell 98 Pointed and copointed data  http://hackage.haskell.org/package/pointed-2.0.1 (EdwardKmett)
17:26:39 <danharaj> brisingr: You could spend an entire week of talks on polymorphism in Haskell. For example, the fact that you can have polymorphism over type constructors is intensely expressive.
17:27:40 <brisingr> danharaj: I'll try to introduce the idea that almost all things in haskell (pattern matching lambdas polymorphism etc. can be mixed-and-matched_
17:27:42 <shachaf> What's the intensity scale for expressiveness ?
17:27:43 <brisingr> )
17:27:46 <ivanm> edwardk: you keep saying your packages are haskell98, but you're not using the haskell98 package! :o :p
17:27:47 <shachaf> s/..$/?/
17:27:56 <kmc> orgasmically expressive
17:27:59 <edwardk> ivanm: screw the haskell 98 package =P
17:28:15 <ivanm> you're just trying to say that you're not using extensions, etc.?
17:28:18 <edwardk> it is a great way to make it so your packages can't work with anyone
17:28:26 <edwardk> yes
17:28:29 <ivanm> what, the haskell98 package?
17:28:42 <danharaj> is haskell2010 not a good target for packages yet?
17:28:48 <edwardk> ivanm: yes
17:29:02 <danharaj> or is it that there's hardly more expressiveness over haskell98.
17:29:27 <ebzzry> Is there a page that describes community-accepted coding standard and styles?
17:29:27 <edwardk> danharaj: its fine, but the only way i can say 'haskell2010' is to fight with cabal, and upgrade all the way to 1.10 or so,  locking out anyone still behind the times
17:29:40 <Guest31450> Hello, I'm Running Ubuntu 11.04 And I Was Wondering If Haskell Would Be Good Choice For Me?
17:29:51 <ebzzry> For example, whether to put a space after a "\" or not, in lambda definitions.
17:29:53 <edwardk> danharaj: most of my packages don't use anything exotic, particularly i tend to code to the intersection of haskell 98 and 2010
17:30:05 <brisingr> Guest31450: What would you like to do with Haskell?
17:30:16 <luite> Guest31450: haskell platform runs fine on ubuntu
17:30:18 <shachaf> Guest31450: http://www.haskell.org/haskellwiki/FAQ#Should_I_learn_Haskell.3F
17:30:19 <ivanm> Guest31450: well, you have to get over the habit of starting every new word with a capital letter, since Haskell is case-sensitive... :p
17:30:35 <Guest31450> Ok. Ican work with that :P
17:30:36 <kmc> Guest31450, http://haskell.org/haskellwiki/FAQ
17:30:41 <Guest31450> Yes
17:30:44 <edwardk> but i have to admit the general reaction to this damn semigroup thing has me tempted to just say screw it and go back to coding with whatever extension is convenient
17:30:51 <clsmith> ... gtk2hs requires gtk2hs-buildtools, and yet its listed in its hackage dependencies. sigh.
17:30:52 <edwardk> since people bitch no matter what i do
17:30:54 <kmc> oh, shachaf already linked that :)
17:30:54 <danharaj> edwardk: Yeah! Fuck the police!
17:31:04 <kmc> thanks, shachaf.  thachaf.
17:31:07 <danharaj> edwardk: Are you familiar with the proverb "Haters gonna hate"?
17:31:18 <shachaf> kmc: Yes, it's a great page. I'm glad you saw siracusa's link to it before. :-)
17:31:18 <mustelo> what's the high-level summary of the semigroup debate? current status? consensus?
17:31:30 <ion> Haskellers gonna Hask
17:31:30 <kmc> danharaj, that was confucius, right?
17:31:35 <edwardk> mustelo: looks like we'll take johan's patch
17:31:39 <ivanm> edwardk: my only complaint is that by stopping usage of <> for mappend because of semigroup means that you can't use <> in boot libs (so pretty won't have it)
17:31:58 <danharaj> kmc: I think it was Aristotle, actually.
17:32:03 <edwardk> ivanm: um… it is basically the same as is used by pretty
17:32:16 <edwardk> ivanm: i USE semigroup for (<>) in my pretty printing package =P
17:32:20 <ivanm> edwardk: right, but pretty will still have to re-define it unless semigroup becomes a boot lib
17:32:25 <kmc> it's more poetic in the original greek
17:32:32 <danharaj> Oh no, it was Diogenes the Cynic, as he was masturbating in public.
17:32:36 <danharaj> My mistake.
17:32:36 <Eduard_Munteanu> Semigroupoids? What's wrong with it?
17:32:45 <ivanm> which means you can't use pretty's <> and semigroup's <> in the same module
17:32:46 <kmc> diogenes was a pretty cool guy
17:32:46 <Eduard_Munteanu> (the package)
17:32:49 <edwardk> well, as it stands, i just intend to keep using (<>) for semigroup and import monoid with explicit imports
17:32:59 <edwardk> i rarely import data.monoid in its full glory
17:33:17 <Eduard_Munteanu> Grr... /me misread, semigroups, no oids
17:33:18 <kmc> eh mouths off to Alexander the Great and doesn't afraid of anything
17:33:24 <ivanm> edwardk: but I wouldn't mind it being part of the disruptive haskell' release that's fixing the various typeclass hierarchy that someone talked about...
17:33:26 <edwardk> then you can import semigroup or not
17:33:29 <edwardk> sure
17:33:40 <kmc> diogenes is possibly the original troll
17:33:40 <edwardk> but i'm not holding my breath
17:33:43 <ivanm> heh
17:34:05 <ivanm> it's just that some people are still using pretty, so you have a mis-match there
17:34:20 <Eduard_Munteanu> About that... are there any decent alternate and "Done Right" Preludes?
17:34:24 <shachaf> edwardk: Do you have Data.Magma among your libraries? It would make a great type class, since its laws are enforced by Haskell. :-)
17:34:31 <edwardk> and when you get folks like malcolmw flipping out about this alien semigroup package and 'zomg what laws does it satisfy?' i despair
17:35:00 <ivanm> heh
17:35:04 <edwardk> which is odd because he is usually so rational
17:35:04 <jmcarthur> shachaf: isn't totality technically a law of magma?
17:35:06 <ivanm> yeah, malcolmw is a bit weird like that
17:35:18 <ivanm> I think it's because he still imagines people use nhc or something...
17:35:27 <Eduard_Munteanu> jmcarthur: I think that's just about the only thing Haskell types can ensure there
17:35:40 <jmcarthur> Eduard_Munteanu: *can't?
17:35:54 <shachaf> jmcarthur: Spoilsport.
17:36:13 <sshc> < parcs> sshc: i believe you can't run a wx gui within ghci due to linking errors — Has this issue been resolved?
17:36:27 <Eduard_Munteanu> jmcarthur: hm, no, "can". Supposedly you mean   a, b ∈ G => a * b ∈ G, no?
17:36:47 <Eduard_Munteanu> Oh, you mean totality in the normal Haskell sense.
17:36:51 <jmcarthur> yes
17:36:53 <ivanm> sshc: I think they might have fixed it
17:37:05 <ivanm> or at least are working on it
17:37:27 <shachaf> Eduard_Munteanu: I suppose calling that "closure" would be confusing in a Haskell context too. :-)
17:37:29 <parcs> sshc: not on 7.0.3
17:37:37 <parcs> i'm not sure about any later versions
17:37:41 <Eduard_Munteanu> Yeah, closure is better though.
17:37:55 <Eduard_Munteanu> Closed under the operation.
17:38:22 <jmcarthur> yeah, there are a couple ways to interpret that
17:38:50 <jmcarthur> it's closed in the sense that a*b is always a valid computation, but it's not closed in the sense that actually *performing* the computation isn't guaranteed to give you a value
17:39:04 <Eduard_Munteanu> However, if   undefined ∈ G, then I suppose you do have a magma  :)
17:39:42 <parcs> preflex: seen apfelmus
17:39:42 <preflex>  apfelmus was last seen on #haskell 40 days, 6 hours, 2 minutes and 27 seconds ago, saying: byorgey: Anyway. Let me know if you're taking the homebrew route, I'll be happy to contribute. :)
17:39:51 <jmcarthur> Eduard_Munteanu: just depends on if you pretend undefined is a value or not
17:40:00 <mustelo> edwardk, what's malcolmw's point besides the fact that making semigroup a superclass of monoid would break things?
17:40:25 <edwardk> he didn't understand why sconcat and replicate1p had to be in there
17:40:32 <edwardk> i agree the latter has a terrible name
17:40:53 <edwardk> but both serve a serious purpose once you actually try to program anything non-trivial with these things
17:41:02 <mustelo> I see
17:41:32 * Eduard_Munteanu wonders about separate Commutative, Associative etc. classes
17:42:20 <shachaf> Eduard_Munteanu: What about a type class that contains both (+) and (*)?
17:42:23 <Eduard_Munteanu> class Associative a => Semigroup a where <void>
17:42:24 <edwardk> "I oppose any dependency (at this stage) on Semigroup.  For one thing, I don't know what a semigroup is."
17:42:44 <danharaj> A monoid without identity....?
17:42:47 <edwardk> at that point he largely disqualified himself from the discussion IMHO ;)
17:43:12 <mustelo> hehe
17:43:15 <edwardk> first sentence on the first hit on google explains it
17:43:47 <Eduard_Munteanu> shachaf: I guess you also need a Distributive "capability"
17:43:58 <Eduard_Munteanu> You mean rings and fields no?
17:44:32 <shachaf> Well, yes.
17:44:42 <ivanm> edwardk: well, it would have been nice IMHO if Yitzchak gave a brief description of what it was and why we want it (even if it's just "some things are semigroup but not monoid) in his first objection email
17:44:58 <johntromp> @hoogle on
17:44:59 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
17:44:59 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
17:44:59 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
17:45:07 <edwardk> Min, Max, and a real First and Last are among those
17:45:18 <edwardk> plus the Monoid instance for Maybe is borked as well
17:45:29 <danharaj> What's wrong with it?
17:45:32 <edwardk> because it assumes you are lifting a semigroup (faked as a Monoid) into a monoid
17:45:37 <danharaj> ah
17:45:39 <shachaf> Where is this discussion you're all discussing?
17:45:41 <copumpkin> it doesn't use the mempty of the underlying monoid
17:45:46 <copumpkin> shachaf: libraries list
17:45:51 <shachaf> Oh.
17:45:54 <shachaf> All these lists.
17:46:13 * shachaf has >10000 unread messages in -cafe. :-(
17:46:22 <ion> /me read the first sentence on the first hit on Google. Now i know what a semigroup is. :-P
17:46:44 <copumpkin> yeah
17:46:49 <copumpkin> you can't get much simpler
17:46:50 <Eduard_Munteanu> Was he raising concerns about math terms creeping into Haskell code?
17:46:56 <edwardk> no idea
17:46:59 <ivanm> Eduard_Munteanu: not explicitly
17:47:03 <shachaf> There should be better words for all these algebraic structures.
17:47:11 <shachaf> Such that their names capture all their laws.
17:47:11 <danharaj> words are just words
17:47:12 <edwardk> some objections were valid. there is crap documentation in there.
17:47:20 <Jafet> Creeping? They're here, guns blazing.
17:47:23 <ion> So, «class Semigroup a where mappend :: a → a → a; class Semigroup a => Monoid a where mempty :: a»?
17:47:24 <ivanm> edwardk: at least you admit it :p
17:47:30 <edwardk> btw- i happily accept patches on github for documentation
17:47:43 <copumpkin> ion: yeah
17:47:45 * Eduard_Munteanu still hopes one day edwardk will write a book on all his stuff...
17:47:53 <ivanm> edwardk: to add documentation, I'd have to first understand it; to understand it, I need documentation!
17:47:56 <ivanm> catch-22
17:48:14 <danharaj> catch :: Num a => a?
17:48:45 <Cale> ion: yeah
17:50:56 <mustelo> is it conceivable that someone with a large chunk of time could get things ready for something like `class Semigroup a => Monoid a`?
17:51:33 <ivanm> mustelo: well, it would break every package that defines a new Monoid instance
17:53:08 <edwardk> mustelo: well, i've been trying to do just that with all these random haskell 98 packages
17:53:22 <edwardk> setting up smallish chunks that could be standardized
17:53:28 <mustelo> how does that work?
17:53:35 <edwardk> dunno, never had it work
17:53:40 <mustelo> heh
17:53:43 <danharaj> would things be easier if Haskell had a way to add superclasses after the fact?
17:53:53 <edwardk> and there are times like today when it is pretty damn exhausting
17:53:53 <danharaj> a way to say "Every monoid is a semigroup"
17:54:00 <edwardk> danharaj: yes
17:54:02 <ion> There are proposals for that.
17:54:09 <mustelo> `class Semigroup a <= Monoid a`...?
17:54:18 <edwardk> tehre are proposals a-dozen for it, but there is no implementation that is usable
17:54:22 <edwardk> SHE doesn't count
17:54:43 <shachaf> mustelo: Well, you couldn't define arbitrary new operators, presumably, only ones in terms of Monoid functions.
17:55:13 <mustelo> is it inherent to the idea or is it just implementation specific?
17:55:13 <danharaj> what is SHE?
17:55:19 <Eduard_Munteanu> @where she
17:55:19 <lambdabot> http://personal.cis.strath.ac.uk/~conor/pub/she/
17:55:25 <danharaj> @where is she!?
17:55:26 <lambdabot> I know nothing about is.
17:55:31 <Phyx-> hmm, can anyone explain to me what the difference is between IncoherentInstances and OverlappingInstances?
17:56:02 <danharaj> Phyx-: Incoherent instances can make your program segfault because the code might use two different instances in two places for the same value.
17:56:05 <danharaj> (Or something)
17:56:25 <aavogt> danharaj: have you an example of that?
17:56:26 <Phyx-> doesn't the same danger exist with overlapping/
17:56:33 <Saizan> it exists
17:56:45 <ion> http://hackage.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances
17:57:01 <danharaj> aavogt: I don't, because I haven't written an incoherent instance precisely because people warn against it :p
17:57:33 <Saizan> Phyx-: with II you can have two instances that are none more specific than the other and ghc will just pick one as it feels like
17:57:38 * ivanm wants type-class aliases!
17:58:40 <danharaj> do type classes have categorical semantics yet.
17:59:25 <Phyx-> Saizan: but then I don't understand, given two instances, Foo String CWString and head => Foo [a] (Ptr b), isn't the first one more specific? so shouldn't OverlappingInstances suffice then?
18:00:04 <cmccann> hey, Phyx-
18:00:12 <Phyx-> given that type CWString - Ptr CWchar
18:00:13 <cmccann> did you see the nonsense I posted on SO the other day?
18:00:15 <Phyx-> cmccann: hi
18:00:25 <cmccann> sorta related to the stuff I was trying to help you with a while ago
18:00:34 <Phyx-> cmccann: hm no
18:00:37 * Phyx- looks
18:00:50 <cmccann> Phyx-, or just check out the goods https://github.com/isomorphism/evangelist
18:01:03 <cmccann> (the README there has a link to the SO question anyway)
18:01:18 * Phyx- looks
18:01:27 <cmccann> not actually usable at the moment, I'm pretty sure
18:01:52 <mustelo> hmm, I'm suddenly getting a bunch of "package ... is broken due to missing package ..." errors... how do I figure out what I did wrong?
18:02:22 <Phyx-> cmccann: lol, it requires 7.2?
18:02:27 <cmccann> Phyx-, yes
18:02:40 <cmccann> for type equalities in class contexts
18:03:03 <aavogt> you could have encoded it with fundeps, which would work with older ghcs
18:03:17 <cmccann> aavogt, I could have, but I like type families better
18:03:33 <danharaj> screw the past
18:03:36 <danharaj> what did it ever do for me
18:03:37 <cmccann> and I don't feel too guilty about requiring the latest GHC with something this hilariously non-portable
18:03:45 <Phyx-> Hmm I'll take a look, thanks cmccann :)
18:04:16 <Phyx-> cmccann: lol, aslong as it's portable between a the 7.x branches is fine by me, so if I can understand what's going on I'll see if i can make a fundept version
18:04:45 <cmccann> Replacing the type families with fundeps would tedious but straightforward
18:05:06 <cmccann> though if doing so, it would make sense to pull overlapping back in and do some equality checking
18:05:12 <Jafet> mustelo: ghc-pkg list?
18:05:17 <cmccann> rather than relying on a non-overlapping base case for the recursion
18:05:19 <Jafet> Or ghc-pkg check
18:05:50 <Phyx-> cmccann: I'm afraid I need overlapping anyway for the rest of the instances. since GHC doesn't check the heads
18:06:01 * hackagebot semigroups 0.7.1.1 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.7.1.1 (EdwardKmett)
18:06:15 <Saizan> Phyx-: yes, but what will happen is that ghc wont' use the Foo [a] (Ptr b) instance until it can be sure that a is not Char or b is not CWChar
18:06:29 <cmccann> Phyx-, overlapping doesn't help as much as you might think with that
18:06:30 <ion> It’s so annoying the Hackage package pages don’t have changelogs.
18:06:34 * ivanm wonders whether this release means edwardk has finally worked out hot to document stuff...
18:06:34 <ivanm> :p
18:06:55 <edwardk> i put a few sentences in
18:07:15 <Phyx-> Saizan: I was wondering because for some reason it's *requiring* me to have IncoherentInstances to compile
18:07:29 <cmccann> with overlapping instances you tend to get situations where something slightly too polymorphic gets wedged halfway through and it's a pain to untangle
18:07:31 <edwardk> and as usual i have a new problem because of haddock
18:07:33 <edwardk> gah
18:07:44 <cmccann> Phyx-, incoherent instances are almost never what you want
18:07:52 <Phyx-> cmccann: agreed
18:08:02 <ivanm> edwardk: heh
18:08:03 * Phyx- thinks he needs to rewrite the convertions
18:08:10 <danharaj> edwardk: Sounds like fishy business.
18:08:20 <mustelo> Jafet, so given the output of `ghc-pkg check` how do I know which package(s) is/are the root of the problem?
18:08:21 <edwardk> this is why i usually batch up writing haddocks
18:08:22 <Phyx-> The straight-forward approach is not doing what I expect
18:08:44 <cmccann> Phyx-, got an hpaste or something? I can probably tell you why it's not working
18:08:51 <ivanm> mustelo: it says so right up the top
18:10:03 <Phyx-> cmccann: The file is rather large but sure one sec
18:10:03 <Jafet> Well, the mechanism of breaking dependencies involves spooky action-at-a-distance
18:10:18 <hpaste> mustelo pasted “ghc-pkg check” at http://hpaste.org/50321
18:10:21 <edwardk> it just took me 6 tries to figure out how to \ <> appropriately in the haddock and i still can't get the hyperlink right =/
18:10:23 <Eduard_Munteanu> edwardk: btw, any way your blog could display a list of all posts (or otherwise not make readers press "Next" sequentially), and/or a tag cloud? :)
18:10:26 <Jafet> mustelo: put http://www.vex.net/~trebla/haskell/sicp.xhtml on your reading list
18:10:31 <Jafet> Near the front, if possible
18:10:38 <edwardk> Eduard_Munteanu you can go to the main page and scroll down the list
18:10:47 <edwardk> Eduard_Munteanu: i tried to make the summaries short enough you can skim
18:11:18 <edwardk> http://comonad.com/reader/ should show them all (well, across 3 pages or so of backlog)
18:11:39 <Eduard_Munteanu> Ah, so there aren't many pages (yet).
18:11:53 <edwardk> yeah i tend to write in spurts
18:13:10 <Jafet> mustelo: it sounds like you're trying to use something in the global world, but its dependencies are in the .cabal world
18:13:23 <Phyx-> cmccann: http://pastebin.com/WDbq4t40 the instances are at line 255 and 265
18:13:27 <mauke> The paste WDbq4t40 has been copied to http://hpaste.org/50322
18:14:49 <Phyx-> cmccann: ignore the CPP pragmas, it's always the last argument that's the function being applied
18:15:03 * cmccann takes a look
18:15:10 <Phyx-> s/Pragmas/Macros
18:15:17 * Phyx- expects a "HOLY CRAP!!"
18:15:19 <Phyx-> from cmccann
18:15:20 <Phyx-> lol
18:15:55 <Saizan> you have II but not OI turned on there
18:16:18 <cmccann> doesn't incoherent imply overlapping?
18:17:21 <Phyx-> Saizan: I'm pretty sure I tried it with OI before... unless cabal didn't rebuild the dependencies
18:17:24 * Phyx- checks
18:18:33 <Saizan> also, you need OI in the module that defines the instances, or is it the same one?
18:19:08 <Phyx-> heh, I would have never thought of what you did in that SO post cmccann, thanks!
18:19:27 <Phyx-> Saizan: this is most of them. the instances that are generated are highly specific
18:19:30 <cmccann> Phyx-, heh, which part? I did kind of a lot of things
18:19:33 <Phyx-> they should never overlap
18:19:43 <Saizan> also, what's the type of unpackFS?
18:20:07 <Phyx-> cmccann: the entire approach using type families. And collapsing context. As I've never used TF before, :P
18:20:32 <Phyx-> not sure, it's been a while, let me check
18:20:40 <cmccann> Phyx-, ah, ok
18:20:59 <Saizan> mh, shouldn't matter, it knows it's looking for FFType String CWString
18:21:46 <Phyx-> yeah, unpackFS :: FastString -> String
18:21:52 <Saizan> the lack of OI seems the most likely problem to me
18:21:55 <cmccann> Phyx-, pretty sure you'll have huge headaches with this if there's any ambiguity whatsoever in the types
18:22:01 <Phyx-> oh, seems i was wrong, it does work with only OI
18:22:17 <Phyx-> must not have compiled earlier when I tried it with it
18:22:44 <Cale> What SO post?
18:23:03 <Phyx-> cmccann: there shouldn't be, most of the instances are slightly different
18:23:16 <cmccann> Cale, http://stackoverflow.com/questions/7030476/haskell-polyvariadic-function-with-io/7035253#7035253
18:23:30 <cmccann> Cale, just me doing some egregious hackery with type families
18:23:43 <Phyx-> hrm, how do you download from git?
18:23:46 <Cale> ah, nice
18:23:52 <Phyx-> and where is a good tut on Type families?
18:24:02 <Phyx-> I know Dependent types, just not TF
18:24:53 <DdRmanxbxfr> Phyx-: to download from git, install the git client and then open a command-line and type "git clone your-git-url"
18:24:55 <cmccann> Phyx-, well, you have a multiparameter type class with two independent parameters and are relying on specificity to choose from overlapping instances, it's pretty easy to confuse GHC that way
18:25:16 <cmccann> Phyx-, keep in mind how many of the types you're writing instances for are just type synonyms, too
18:25:27 <Phyx-> Draggor: I tried that... it failed while accessing /info/ref
18:25:34 <cmccann> lots of stuff has the same outermost tpye constructor
18:26:01 * hackagebot semigroups 0.7.1.2 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.7.1.2 (EdwardKmett)
18:26:03 * hackagebot data-lens 2.0.1 - Haskell 98 Lenses  http://hackage.haskell.org/package/data-lens-2.0.1 (EdwardKmett)
18:26:23 <cmccann> Phyx-, if you go to the top page for a repository there's a "downloads" link to the right side
18:26:29 <cmccann> You can get a zip or tarball that way
18:26:31 <danharaj> The die is cast.
18:27:09 <Phyx-> cmccann: hmm, but is there a way to write them without? I couldn't think of anything, You'll always have some overlap
18:27:21 <Eduard_Munteanu> Or use the 'tree' links and get just the file you're interested in.
18:27:26 <Eduard_Munteanu> (if that's the case)
18:27:35 <Phyx-> i dled the zip
18:27:46 <Phyx-> so i can disect cmccann's code tomorow
18:29:40 <cmccann> Phyx-, overlapping mostly lets you have "default" instances that get selected for any type not covered by other instances
18:30:34 <cmccann> a lot of what you're doing there doesn't actually need overlaps, I think
18:31:08 <Phyx-> cmccann: no, it's only the String CWString instance that needs it
18:32:12 <cmccann> Phyx-, yes, that overlaps the [b] (Ptr a) instance
18:32:51 <cmccann> which also overlaps the a (Ptr a) instance
18:32:51 <christo_m> what package is generally used for audio signal analysis with haskell?
18:33:09 <Phyx-> cmccann: why would those two overlap?
18:33:39 <christo_m> things like capturing sound from a device etc?
18:33:46 <cmccann> actually, wait, I forget how GHC handles that case, hm
18:33:47 <christo_m> measuring wave frequency
18:35:06 <ebzzry> Does anybody here use Yi as their main editor?
18:35:40 <edwardk> christo_m: i have some digital signal processing code, but i never released it. iirc there is a pretty good haskelldsp package
18:35:50 * Phyx- disappears to read the Haskell wiki on TF
18:36:07 <Phyx-> thanks again cmccann, i'll let you know how it goes :)
18:36:18 <edwardk> http://haskelldsp.sourceforge.net/doc/index.html
18:36:54 <edwardk> christo_m: as for low level stuff like actually capturing it? dunno
18:37:05 <ddarius> Does this page make anyone else's skin crawl? http://en.wikipedia.org/wiki/Relativistic_heat_conduction
18:38:10 * shachaf wonders why ddarius is never in #-blah.
18:38:18 <cmccann> Phyx-, yeah, those can overlap if the types aren't fully known. If you specify all the types with annotations, they're fine though
18:39:01 <Phyx-> cmccann: yeah, I always specify all the types in the generated code
18:39:07 <Phyx-> it's also a sanity check for myself
18:40:05 * Phyx- needs to fix the parenthesis happiness of his codegen
18:40:48 <cmccann> Phyx-, oh, and since you asked earlier I don't really know of any good tutorials on type families that go beyond some fairly simple examples
18:41:23 <cmccann> I actually think that SO post I wrote is more detailed than most of what I've seen other than a couple papers about the concept
18:41:36 <Phyx-> cmccann: I'm just reading the Wiki now, and i found Fun with types, that seems to cover them aswell
18:42:04 <Phyx-> cmccann: ah ok, i'll finish reading it first them
18:42:50 <cmccann> Phyx-, or start with the other stuff, it's all good
18:42:57 <Phyx-> :)
18:43:08 <ivanm> OK, ghc 6.12.3 compiles criterion + requried deps faster than 7.0.4 :/
18:43:12 <Phyx-> need to watch out for laziness. it's bitten me quite a few times already with this FFI code
18:43:35 <ivanm> (as in much faster; I didn't bother timing it, but I think 6.12.3 was done before 7.0.4 got to compiling criterion itself)
18:46:23 <Phyx-> cmccann: ah, reading the post more clearly now, it does seem to explain it all, hehehe
18:47:44 <Phyx-> cmccann: gj explaining it so that even I could understand :D
18:48:27 <cmccann> Phyx-, yes, explaining things is kind of the point of Stack Overflow :P
18:49:10 <Phyx-> cmccann: I thought it was making witty comments :) which might be why i don't have much points
18:49:14 <Phyx-> heheh
18:49:15 <Phyx-> many*
18:50:42 * ivanm is trying to work out how an answer that doesn't actually answer the question AFAICT keeps getting voted up
18:50:58 <Phyx-> lol
18:50:59 <Cale> http://arxiv.org/pdf/1108.2001  I N C E P T I O N
18:51:56 <cmccann> ivanm, ?
18:53:42 <Jafet> @quote dolio monad
18:53:42 <lambdabot> dolio says: Monad are just monads in the 2-category of categories.
18:54:36 <sshc> If I set -fbreak-on-exception, and I send sigint to inspect the evaluation of a traced expression, how do I continue normally as if it were never interrupted? (anologous to "continue" in gdb after sending SIGINT)
18:54:47 <parcs> is it safe to say mtl is more popular than monads-tf?
18:54:53 <sshc> In ghci, I meant to say.
18:55:08 <ivanm> cmccann: pigworker's answer here: http://stackoverflow.com/questions/7043442/where-do-quickcheck-instances-belong-in-a-cabal-package/
18:55:24 <ivanm> he just talks about how Cabal doesn't do this stuff properly
18:55:43 <ivanm> (I'm not saying this just because I provided the other answer; I provided the other answer just because his was so off-topic)
18:55:48 <ivanm> parcs: yes
18:55:57 <ivanm> but my guess is that it's mainly due to inertia
18:56:14 <ivanm> though there was one thing you could do with mtl and not monads-tf; can't recall what though
18:56:27 <Eduard_Munteanu> Hm, pigworker's on SO too?
18:56:29 <ivanm> (I tried switching one of my projects to -tf, but it didn't work so I switched back)
18:56:34 <ivanm> Eduard_Munteanu: who is he?
18:56:46 <danharaj> Isn't he an epigram guy?
18:56:47 <Eduard_Munteanu> ivanm: the Epigram dude
18:56:52 <cmccann> Conor McBride
18:57:00 <ivanm> oh? he's Conor?
18:57:05 <parcs> ivanm: newtype deriving of transformers?
18:57:06 <sshc> mtl requires UndecidableInstances
18:57:07 <copumpkin> yeah
18:57:13 <parcs> because that's my problem :P
18:57:21 <parcs> (with -tf)
18:57:22 <Eduard_Munteanu> He's been in other Haskell-related channels lately, too.
18:57:31 <ivanm> parcs: could be it, yeah
18:57:35 <cmccann> pigworker is also his username on reddit and twitter I think
18:57:39 <danharaj> He is in our base, typing our dudes.
18:58:58 <ddarius> Conor is interesting.
19:00:28 * Eduard_Munteanu 's on SO too, but hasn't posted in ages
19:00:48 * shachaf has never posted.
19:00:58 <shachaf> Wait, that's not true. I posted once. They deleted my account.
19:01:02 * hackagebot cab 0.1.5 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.1.5 (KazuYamamoto)
19:01:22 <ivanm> I was only on there to post my question regarding binary + length
19:01:22 <shachaf> In fact, I posted twice.
19:01:26 <ivanm> shachaf: oh? why?
19:01:32 <shachaf> Inactivity, I think.
19:01:36 <ivanm> heh
19:01:38 <Phyx-> cmccann: hah, that's pretty awesome +1 from me, quick question, is there any particular reason that you created two new classes for the function case? They look similar to the alreade defined Convert class.
19:01:39 <shachaf> Seems like a pretty ridiculous thing to do.
19:02:40 <cmccann> yeah, they purge accounts that have been inactive forever and had like one or two posts at most
19:03:10 <cmccann> Phyx-, keeping the recursion separate mostly
19:03:18 * Eduard_Munteanu wonders what ddarius meant by that
19:03:55 <Phyx-> cmccann: ah ok, thanks, First thing tomorow i'll start rewriting my lib
19:03:55 <cmccann> the Convert stuff is just a one-time thing, the function cases have to walk the nested type constructors
19:04:10 <Eduard_Munteanu> Yeah, who needs SO when there's a #haskell... :P
19:04:12 <cmccann> they probably could be merged, but I'd rather keep the simple stuff simple
19:04:36 <ivanm> Eduard_Munteanu: well, no-one answered my question no matter how many times I asked it here... ;)
19:04:47 <Eduard_Munteanu> BTW, how common are Haskell questions there?
19:04:58 <Phyx-> cmccann: i'll probably merge them, it's to keep my code generator simple
19:05:00 <Phyx-> "simple"
19:05:14 <cmccann> Eduard_Munteanu, on SO? you can just look at the tag: http://stackoverflow.com/questions/tagged/haskell
19:05:48 <luite> what are the differences in handling of associated data types between ghc 7.0.4 and 7.2.1? for some reason I get with the same code some top-level data families with 7.2.1, that I didn't have with 7.0.4
19:05:49 <Eduard_Munteanu> Ah, right.
19:09:42 <wavewave> Hi~
19:10:06 <Eduard_Munteanu> Hi.
19:10:07 * shachaf doesn't understand the "tilde at the end of line" thing.
19:10:20 <shachaf> Is it some new Internet punctuation?
19:10:20 <ivanm> shachaf: I think he's waving...
19:10:24 <shachaf> It should be illegal, whatever it is.
19:10:28 <Eduard_Munteanu> :)
19:10:29 <wavewave> does anyone know whether zip in iteratee package is implemented for enumerator package?
19:10:47 <clsmith> ~ at the end of a line generally indicates a sing-song kind of speech :p
19:11:00 <danharaj> ~~(o_O)~~
19:11:02 <wavewave> zip is pretty convenient function
19:11:30 * Eduard_Munteanu has seen various IRC cats speaking like that...
19:11:32 <danharaj> 10 points to anyone who can embed that in their haskell code.
19:11:56 <ivanm> you can't, I don't think
19:12:01 <ivanm> not as a single operator anyway
19:12:07 <danharaj> it doesn't have to be
19:12:24 <Eduard_Munteanu> {- ~~(o_O)~~ -} :P
19:12:29 <danharaj> I was waiting for that.
19:12:32 <danharaj> So I could do this.
19:12:36 * danharaj smacks Eduard_Munteanu
19:12:37 <luite> for code with TH, is it possible to have ghc output the whole source file after running all splices?
19:12:45 <Eduard_Munteanu> :)
19:14:07 <aavogt> @hackage zeroth -- luite, but it's rotted
19:14:07 <lambdabot> http://hackage.haskell.org/package/zeroth -- luite, but it's rotted
19:16:02 <luite> aavogt: hmm, I guess I can try -ddump-splices and do everything manually
19:16:11 <luite> since I need to compare results of 7.2.1 and 7.0.4
19:17:08 <aavogt> you might run into some bugs with missing parens in that output, never mind that you need to rename variables from   x[Na1231] to something else
19:18:14 <luite> aavogt: ghc 7.2.1 fortunately changes that to x_something
19:34:43 <luite> hmm, even with the names proper identifiers, ghc cannot parse my splice:
19:34:57 <luite> instance PersistEntity (UserG backend) where
19:34:57 <luite>     data instance Unique (UserG backend) backend2
19:34:58 <luite>         = UniqueUser Text deriving (Show, Read, Eq)
19:35:13 <luite> parse error on the second line, what can it be?
19:35:42 <luite> Mod.hs:20:10: parse error on input `instance'
19:36:29 * aavogt doesn't recall 'deriving' being allowed with type families
19:36:37 <jmcarthur> luite: just leave out the instance part
19:36:40 <kizzx2> (newb advice) should it be is it `data instance Unique` instead of `data Unique`?
19:36:55 <kizzx2> i mean maybe you shoudl just  `data Unique`
19:37:43 <jmcarthur> luite: you don't need to say "data instance" for associated data types. that's only for data families (not in type class instances)
19:38:14 <kizzx2> luite: afaik you only say `data instance` or `type instance` to define "top level" "type-level" functions (argh, typical haskell gibberish)
19:38:16 <Eduard_Munteanu> kizzx2: he wants data families, not simple ADTs
19:38:23 <luite> ah, annoyingly -ddump-splices prints the "instance" word there :(
19:39:25 <kizzx2> Eduard_Munteanu: i thought the syntax for "type-level function definition" inside an "instance" is `type A = ...` or `data A = ...` as in http://www.haskell.org/haskellwiki/GHC/Type_families ??
19:39:38 <kizzx2> there is an example, it says
19:39:38 <jmcarthur> kizzx2: you are correct
19:39:38 <kizzx2> instance GMapKey () where   data GMap () v           = GMapUnit (Maybe v)   empty                    = GMapUnit Nothing   lookup () (GMapUnit v)   = v   insert () v (GMapUnit _) = GMapUnit $ Just v
19:39:47 <kizzx2> argh, sorry for the format :(
19:39:50 <jmcarthur> you just have some terminology confusion i think
19:40:07 <kizzx2> jmcarthur: i'd love to be corrected
19:40:16 <luite> for some reason this code results in top-level type families Unique and Field when run with 7.2.1
19:40:20 <luite> but not with 7.0.4
19:40:29 <luite> I mean data families
19:41:06 <Eduard_Munteanu> Ah, I see what you mean.
19:41:10 <kizzx2> jmcarthur: (i mean the terminology part)
19:41:22 <jmcarthur> kizzx2: "type-level function definition" is a strange term to me, for example. the examples you gave are associated type synonyms and associated data types
19:41:47 <jmcarthur> those would be what you call "type" and "data" inside type class instances
19:41:56 <ddarius> :t let (~~) = undefined; o_O = undefined in 1~~(o_O)~~2
19:41:57 <lambdabot> forall t. t
19:44:00 <applicative> ebzzry: on style have you seen https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md -- there's also hlint of course
19:45:42 <kizzx2> jmcarthur: ok that seems to be a better name
19:46:21 <kizzx2> jmcarthur: i think i got that terminology from SPJ's "Fun with Types" paper, where he did things like arithmetic in compile time (thus type-level functions :P), but i guess that's not how it's typcially used
19:49:35 <kizzx2> > let (~~) = undefined; o_O = undefined in 1~~(o_O)~~2
19:49:36 <lambdabot>   *Exception: Prelude.undefined
19:49:53 <hpaste> sutabi pasted “How to fix this ambiguous type?” at http://hpaste.org/50324
19:50:25 <aavogt> sutabi: which exceptions do you want to catch?
19:51:06 <aavogt> if you change it to                  Left SomeException{} -> return defaultItemInfo,  it'll catch everything
19:52:15 <Cale> That might have to be Left (SomeException {})
19:52:29 <Cale> but I'm not sure
19:52:38 <aavogt> > case Just (Right 1) of Just Right{} -> 'a'
19:52:39 <lambdabot>   'a'
19:52:43 <Cale> neat
19:53:25 <kizzx2> wow it's the first time i've seen that brace syntax usage
19:53:42 <kizzx2> how is it different from?
19:53:47 <kizzx2> > case Just (Right 1) of Just (Right _) -> 'a'
19:53:48 <lambdabot>   'a'
19:53:51 <kizzx2> ??
19:54:14 <aavogt> you don't need to know how many parameters Right as
19:54:20 <kizzx2> that's right
19:54:23 <kizzx2> cool
19:54:25 <aavogt> and you get to save some parentheses :)
19:54:46 <kizzx2> i was literally reading GHC's manual for fun and didn't spot anything like this
19:55:06 <Cale> kizzx2: It's mentioned in the Report, but it's easy to miss.
19:55:12 <ebzzry> applicative: Thanks. I'll look at it.
19:55:33 <Cale> You're allowed to use record syntax with even data constructors that aren't defined using record syntax in this special case.
19:56:12 <luite> does anyone have an idea why there's an extra data family F a with ghc 7.2.1 here? http://hpaste.org/50325
19:57:16 <sutabi> thanks aavogt  and Cale :) that worked great.
19:57:59 <Cale> luite: Maybe someone added data families to the things reported by :browse?
19:58:40 <luite> Cale: it's probably deeper than that, because it causes ambiguous reference conflicts if I import C and B in another module, but only with ghc 7.2
20:00:03 <Cale> In that case, I have no idea
20:00:34 <Cale> oh, interesting, 7.2.1 was actually released
20:01:00 <luite> yeah it's been nothing but trouble for me though :p
20:01:26 <Cale> "This 7.2.1 release is intended to be more of a "technology preview" than normal GHC stable branches. In particular, it supports a significantly improved version of DPH, as well as new features such as compiler plugins and "safe Haskell". The design of these new features may evolve as we get more experience with them."
20:03:19 <Eduard_Munteanu> Hm, can you actually get ContT from the right Kan extension somehow?
20:03:27 <luite> hmm bah I can't reproduce those name conflicts with my small sample, only in the large yesod thing with lots of TH
20:04:16 <Eduard_Munteanu> Ran f f almost gives ContT, but now quite.
20:04:24 <Eduard_Munteanu> s/now/not
20:04:58 <luite> Cale: if I add an explicit data family D a, it's still printed in ghc 7.0.4
20:05:29 <luite> but data family F a only appears with 7.2.1
20:06:19 <Cale> luite: Yeah, it appears to have lifted the definition of the data family out of the typeclass for some reason.
20:08:42 <edwardk> yes
20:08:48 <luite> yes, I have no idea what that reason could be though
20:08:51 <edwardk> apply it to a constant functor
20:09:28 <edwardk> newtype F m a b = F (m a)
20:09:55 <Eduard_Munteanu> Oh, I see, nice. Thanks.
20:10:03 <luite> I'll wait for an answer in #ghc :)
20:10:12 <edwardk> Ran (F m r) (F m r) a ~ ContT r m a
20:10:25 <edwardk> i have that one in monad-ran
20:11:08 <ddarius> A nightly dose of ignorance: http://cafe.elharo.com/blogroll/type-inference-another-bad-idea-for-java-7/
20:11:13 <Phyx-> hmm would on expect a Haskell type [Foo] to be in C a Foo** or Foo*?
20:11:22 <edwardk> trying to figure out how to nicely annotate expectation information in a grammar for autocomplete purposes.
20:11:39 <edwardk> leaning towards using <!> as the operator, something like
20:11:57 <edwardk> spaces = many space <!> " " <?> "white space"
20:12:16 <edwardk> where the <!> " " indicates that if autocomplete is generating it, it gets a single space
20:13:02 <edwardk> then carrying those like the "expected" messages i carry in trifecta and are carried by parsec
20:13:19 <edwardk> <!?> is another option i guess
20:13:27 <edwardk> interrobang for the win
20:13:30 <Phyx-> ddarius: lol, those arguments made no sense (-.-)
20:14:16 <Phyx-> ddarius: he also forgets that C# also has local type inferencing using the "var" keyword and also dynamic type inferencing
20:15:29 <ddarius> Phyx-: The article is from 2007 so C# did not have it then, I don't think.
20:16:35 <Phyx-> ddarius: actually it's been there since C# 3.0, release November 2007
20:17:00 <Phyx-> dynamic typing however is a 4.0 thing
20:17:11 <ddarius> Phyx-: The blog is April 2007.
20:19:22 <Phyx-> ddarius: yes, but the features inside it were announced and discussed at PDC 2005 :)
20:19:25 <mustelo> so he seems to think haskell is "more dynamically typed than java"?
20:19:35 <ivanm> is there a way of telling which ghc optimisation (seemingly enabled by -O2 but not -O) is causing compilation to use app all the RAM?
20:21:08 <ddarius> Phyx-: I doubt this guy kept up with C# news.
20:21:19 <Phyx-> mustelo: I think he's misunderstanding the fact that local type inferencing is done at compile time, and not runtime, this wouldn't affect the strong typeness of the language at all
20:21:20 <Eduard_Munteanu> ivanm: "bisect" optimizations between -O and -O2, IIRC there wasn't much anyway
20:21:29 <Phyx-> ddarius: hehehe :)
20:21:38 <ddarius> Anyway, until it was actually put in practice, he could just say that it was "unproven."
20:21:43 <ivanm> Eduard_Munteanu: I was hoping there would be an automated way, but didn't think it likely ;)
20:22:16 <ddarius> Anyway, the best statement is: "Type inference actually makes some sense in languages like JavaScript and PHP that are built around this, and had this feature from day 1."
20:22:29 * Eduard_Munteanu was wondering about a similar GCC issue a few days ago, but went ahead and did it manually :/
20:22:31 <Phyx-> hehehe
20:23:27 <Phyx-> ddarius: lol, how'd you run into that post?
20:23:36 <Eduard_Munteanu> Hence inference, not duck typing or some behind-the-scenes conversion.
20:24:58 <ddarius> Phyx-: I wanted to see what the state of type inference was in Java-land and that was the first Google hit.  However, Java 7 has just been released just the other week.
20:25:24 <Eduard_Munteanu> "In fact, if anything this is now more strongly typed because, for example, you have to type a Map variable as a HashMap or a TreeMap rather than just a Map." -- isn't this wrong as well?
20:25:28 <Phyx-> ddarius: yeah. heard about it, with show stopping defects in the compiler
20:25:38 <Jafet> Phyx-: is your C pure and garbage-collected?
20:25:47 <ivanm> how do I find out which optimisations are in -O2?
20:25:58 <Jafet> The manual?
20:25:59 <Eduard_Munteanu> I'd imagine it unifies all constraints and decides whether a Map or HashMap is needed.
20:26:18 <Phyx-> Jafet: no..
20:26:49 <Jafet> Then in all generality, F**
20:26:56 <Jafet> Er, Foo**
20:27:06 <Jafet> I guess coding in that would be a f**
20:27:38 <Phyx-> ddarius: seen these http://drdobbs.com/java/231300060 ?
20:27:46 <ivanm> Jafet: silly me, thinking it would be in the users guide...
20:28:09 <Eduard_Munteanu> Hm, there doesn't seem to be a "-Q" equivalent for ghc
20:28:10 <Jafet> Some of them want to use you...
20:28:21 <Eduard_Munteanu> (or is there?)
20:28:47 <Phyx-> Jafet: yeah.. figured as much, logically it was what I came at, but since I could do both...
20:28:53 <Phyx-> Jafet: ty, i'll fix it tomorow
20:31:58 <ddarius> Phyx-: Oracle will be the death of Java.  I don't know how I should feel about Oracle due to that though.
20:32:40 <Phyx-> ddarius: i wonder if mysql will suffer the same faith
20:34:08 <Eduard_Munteanu> Did they change the developer team at all? /me wonders
20:34:34 <luite> mysql or java?
20:34:45 <Eduard_Munteanu> Say Java.
20:35:11 <luite> to be fair though, ghc probably has similar issues, but can get away with it much easier due ot haskell being esoteric and academic and stuff
20:35:52 <luite> on the other hand, oracle should have the resource to fix them
20:37:39 <Phyx-> luite: but in the case of haskell, anyone can make a haskell compiler, not sure about java
20:38:21 <luite> anyone can make one, just don't call it java, and if you're too succesful we'll sue your ass
20:38:30 <luite> something like that
20:38:47 <Phyx-> lol
20:40:06 <danharaj> ddarius: Should send Oracle a cake.
20:40:24 <ddarius> danharaj: I freakin' hate Oracle, but I also hate Java, so I'm torn.
20:40:49 <danharaj> ddarius: Send them a cake, but spit on it.
21:16:03 * hackagebot fgl 5.4.2.4 - Martin Erwig's Functional Graph Library  http://hackage.haskell.org/package/fgl-5.4.2.4 (IvanMiljenovic)
21:21:03 * hackagebot weighted-regexp 0.3.1.1 - Weighted Regular Expression Matcher  http://hackage.haskell.org/package/weighted-regexp-0.3.1.1 (SebastianFischer)
21:30:04 <sutabi> How would I get the array length of [IO MyDataType] ? I tried defining length :: [IO MyDataType] -> Integer but it doesn't have a type signature for it
21:30:38 <aavogt> @ty fromIntegral . length
21:30:38 <lambdabot> forall b a. (Num b) => [a] -> b
21:30:44 <aavogt> @ty genericLength
21:30:44 <lambdabot> forall b i. (Num i) => [b] -> i
21:31:48 <aavogt> sutabi: putting (just) a type signature doesn't let you convert the  Int to Integer
21:35:26 <sutabi> aavogt, i figured after I tried :\
21:41:34 <ion> edwardk: The lenses talk was nice.
22:09:15 <edwardk> ion: thanks =)
22:24:02 <aleator> Silly question: does forkIO give me a spark or a thread?
22:24:18 <shachaf> A thread.
22:24:29 <shachaf> @google forkIO
22:24:30 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
22:24:30 <lambdabot> Title: Control.Concurrent
22:24:49 <aleator> I thought so. The documentation starts with word "Spark" so I had to ask :)
22:25:22 <aleator> Is there any way of sparking io computations? Ie. I want to perform them in parallel but don't care about the details.
22:25:49 <shachaf> forkIO. :-)
22:26:03 <shachaf> forkIO won't even let you wait on the thread.
22:26:36 <eyu100>  :t show
22:26:37 <shachaf> If you want to do a parallel mapM or something like that, I suppose it's a bit trickier.
22:26:38 <kmc> in GHC forkIO gives you a lightweight GHC thread
22:26:57 <aleator> Well, I have an op that peeks and pokes a huge array. It could just as well do it in multiple places at once
22:26:58 <kmc> which is different from a spark and also different from an OS thread
22:27:09 <eyu100> > fix arr
22:27:09 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> c)
22:27:10 <lambdabot>    arising from a use of `...
22:27:10 <kmc> mapM_ (forkIO . f)
22:27:28 <eyu100> > fix arr 1
22:27:32 <lambdabot>   mueval-core: Time limit exceeded
22:27:34 <kmc> parallel mapM is easy with <plug>my 'spawn' library</plug>
22:27:49 * shachaf would've mentioned kmc's spawn library.
22:28:04 * ion would’ve mentioned shachaf would’ve mention kmc’s spawn library.
22:28:15 <ion> ed
22:28:19 <shachaf> It has a nice API, if it matches what you want to do exactly.
22:28:34 <shachaf> You don't get the ThreadId, though.
22:28:51 <aleator> Let me see..
22:30:34 <kmc> join . fmap sequence . mapM (spawn . f)
22:30:40 <kmc> that's not as nice as i hoped
22:30:42 <kmc> is there a better way?
22:30:58 <aleator> Well, I'll probably go with spawn, but I'm bit worried that I actually would need some smarter scheduler to figure out how many threads really should be spawned
22:31:03 * hackagebot prototype 0.5.3 - prototype-based programming on Haskell  http://hackage.haskell.org/package/prototype-0.5.3 (YoshikuniJujo)
22:31:11 <shachaf> Does GHC even give you an option to spawn a real OS thread?
22:31:24 <Bwild> join #ruby-lang
22:31:27 <Bwild> ooops
22:31:31 <kmc> aleator, GHC is fine with managing millions of threads
22:31:48 <shachaf> But my list is billions of items long.
22:31:50 <kmc> it can be a problem though if each thread starts by reading some huge file
22:32:12 <kmc> which is why 'spawn' has this 'pool' function
22:32:27 <kmc> which lets you block IO actions such that only n of them are in progress at once
22:32:51 <aleator> kmc: What I intend to do with the threads is to peek a value from c-ffi memory block, apply a pure function and poke it back.
22:32:54 <kmc> shachaf, no, afaik there's no run-time control over the number of Haskell Evaluation Capabilities
22:33:01 <aleator> ie. I don't want concurrency, but parallelism.
22:33:04 <kmc> aleator, how many times?
22:33:16 <aleator> Well, about few million
22:33:41 <aleator> I can of course make blocks, so each op won't be a thread
22:33:46 <kmc> forking a thread for each might work
22:33:58 <kmc> but yeah, you could chunk it
22:34:13 <aleator> Each operation is quite lightweight, so my intuition says "chunks!"
22:34:59 <aleator> But ghc's pure parallelism seems more suited still, since it incorporates some intelligence in sparks and converting them to threads
22:35:15 <kmc> yeah
22:35:32 <kmc> it's not going to fit that well, though
22:35:49 <aleator> If I spawn 500 threads, and there are no cores, I'd get a slowdown compared to not spawning any extra threads, right?
22:36:15 <kmc> i also worry about caching wrecking the parallel performance gains
22:36:20 <shachaf> If there are *no* cores, you'll not get a slowdown, presumably. :-)
22:36:23 <kmc> this is one reason to chunk it
22:36:35 <aleator> shachaf: .. no cores remaining :)
22:38:34 <eyu100> > [: 1 :]
22:38:35 <lambdabot>   <no location info>: parse error on input `]'
22:39:19 <eyu100> @type [::]
22:39:20 <lambdabot> parse error on input `::'
22:41:07 <aleator> wait.. If I do `let r = parMap rDeepSeq (\i -> unsafePerformIO (peekPokeThing i >> return True)) is in all r `seq` return peekAndPokedCArray` would it work to parallelise the operation?
22:41:32 <aleator> Or just explode?
22:42:38 <eyu100> > [:1:]
22:42:39 <lambdabot>   <no location info>: parse error on input `]'
22:42:53 <kmc> eyu100, lambdabot doesn't have Data Parallel Haskell enabled
22:43:28 <shachaf> > [: 1 :] -- Maybe it was enabled since you said that?
22:43:29 <lambdabot>   <no location info>: parse error on input `]'
22:43:34 <shachaf> You can never tell with bees.
22:43:57 <eyu100> on my screen that shows up as smile 1 smile
22:44:16 <shachaf> Get a better IRC client.
22:46:34 <eyu100> hmm I could ssh into a remote server using an ipad app and run irc there... and amazingly I think that would work better
22:46:46 * cmccann uploads some of his type hackery to github
22:47:43 <ion> Ah, now i remember where i encountered the case-expression-with-exactly-one-branch style: in edwardk’s code. https://github.com/ekmett/data-lens/blob/master/Data/Lens/Common.hs#L48
22:48:05 <edwardk> i stole it from the bowels of ghc
22:48:27 <cmccann> I'm probably going to regret this: https://github.com/isomorphism/typewriter
22:48:29 <shachaf> Is there a reason not to use let?
22:48:35 <edwardk> since it is pretty close to the resulting core
22:48:41 <ion> Is it just an aesthetical choice or does the strictness matter?
22:48:57 <edwardk> avoids me having to think about it binding identifiers in the right hand side
22:49:14 <edwardk> and it puts a logical ordering on things
22:49:22 <edwardk> i mostly use it when chaining state
22:49:36 <edwardk> in the soon to be released version that very line is actually changed
22:49:37 <edwardk> ;)
22:50:27 <edwardk> f `o` g = Lens $ \a -> g a $ \b ba -> f b $ \c cb -> store (ba . cb) c
22:50:43 <edwardk> er there are a couple of 'runLens's in there
22:51:05 <edwardk> the connection between the continuation passing style and the case version is obvious
22:51:18 <edwardk> the let style makes it harder to flip your thinking to continuation mode where beneficial
22:52:12 <edwardk> but in a sane world it is purely aesthetic in the absence of GADTs
22:52:24 <edwardk> there are some GADT cases where you have to use case or do to deconstruct
22:52:53 <edwardk> destructuring assignment in a let where the left hand side is a GADT constructor doesn't work
22:53:08 <edwardk> er GADT constructor with an actual existential
22:55:40 * cmccann really needs to find a better way to do generic type-level recursion
22:56:26 <ion> edwardk: aye
22:56:28 <cmccann> preferably without burning through GHC's context reduction stack too quickly :T
22:56:47 <edwardk> i almost have the syntax highlighting integrated into trifecta
22:57:26 <edwardk> then you'll be able to get out a nice interval tree of how the syntax of your grammar should be highlighted, which will let me do things like pretty print your error messages in color, with syntax highlighting ;)
22:57:53 <ion> edwardk: Why is the code for ‘o’ duplicated for (.), btw?
22:58:31 <edwardk> ion: partially because i didn't want to make either dictionary subordinate to the other, but it could have been streamlined
22:59:07 <edwardk> i do it sometimes as a tick when the dictionaries are expensive to construct, in this case i just did it out of habit
23:02:21 <ddarius> cmccann: CPS transform your type level programs.
23:04:11 <cmccann> ddarius, that's probably not too far off from what it'll end up being
23:07:26 * ddarius decides that Vermont doesn't make good cottage cheese, or at least it's weird.
23:12:34 <wavewave> I implemented zip for enumerator package :-D
23:12:59 <cmccann> wavewave, oh hey, you were asking about type-level nonsense the other night, right?
23:13:18 <wavewave> cmccann: yes, yesterday :-)
23:13:29 <cmccann> wavewave, then here, knock yourself out: https://github.com/isomorphism/typewriter
23:13:49 <wavewave> cmccann: Oh, great! thanks a lot!!
23:13:49 <cmccann> lots of stuff still missing but it's a start
23:14:42 <cmccann> very little of where's there so far is likely to be useful. other stuff that might actually be worthwhile I'm still cleaning up a bit first.
23:15:52 <cmccann> the bit that attempts to serialize a function to an Integer is probably the most useless thing I've ever written, in fact.
23:15:57 <cmccann> should probably have just removed that
23:16:03 * hackagebot tiger 1.1.1 - Tiger Compiler of Universiteit Utrecht  http://hackage.haskell.org/package/tiger-1.1.1 (ArieMiddelkoop)
23:17:36 <wavewave> I am reading your List.hs. It looks quite interesting. This may have some interesting application.
23:18:01 <cmccann> that's mostly just a rehash of the core bits of HList
23:18:12 <wavewave> Aha.
23:18:19 <cmccann> minus the type-equality needed to do some of the stuff HList does (though that could be added, see TypeEq.hs)
23:18:47 <wavewave> now with ghc 7.2, it should be very smooth ;-)
23:18:48 <cmccann> once I get a bit more machinery added for using the lists, yes, those can actually be useful
23:19:02 <cmccann> nah, still can't do type equality predicates with type families, alas
23:19:31 <wavewave> I see.
23:19:48 <cmccann> look at TypeEq.hs to see how it works
23:20:18 <cmccann> basically it's implemented via disreputable trickery
23:21:08 <cmccann> anyway, I'm off to bed now. enough type hackery for one evening.
23:21:57 <wavewave> cmccann: great. thanks so much!
