00:00:00 <kmc> yeah, I figure it's unlikely, but not impossible
00:00:04 <kmc> excellent
00:03:56 <kmc> are we getting per-capability minor GC without stopping the world any time soon?
00:04:02 * kmc probably has not read the latest paper
00:04:55 <c_wraith> yeah, that's the topic of the paper
00:05:01 <c_wraith> I think it's slated for 7.4, at this point
00:05:08 <c_wraith> I'm sure it's not in the 7.2 RCs
00:05:35 <kmc> nice
00:06:01 <Cale> How is dph coming along?
00:06:11 <c_wraith> I don't know about that one :)
00:15:58 <Cale> http://hackage.haskell.org/packages/archive/repa-algorithms/2.1.0.1/doc/html/Data-Array-Repa-Algorithms-Randomish.html -- haha
00:16:29 <Schalken> shachaf: kmc: Thanks for your help, by the way. :)
00:18:17 <kmc> no problem :)
00:21:21 <erus`> equal a a = True
00:21:24 <erus`> in my world this would work
00:21:41 <opqdonut> yeah one can have a language like that
00:21:49 <kmc> in Haskell that could desugar to «equal a b | a == b = True»
00:21:54 <kmc> however i think it's better that it doesn't
00:21:55 <opqdonut> but that would mean that equality would be "more fundamental" than pattern matching
00:21:59 <opqdonut> (or sugaring)
00:22:00 <erus`> i cant think of any more uses for that though
00:22:10 <Kaidelong> erus`: you can do it in prolog
00:22:12 <opqdonut> whereas now equality is defined in terms of pattern matching (mostly)
00:22:16 <Kaidelong> or with haskell types
00:22:21 <kmc> mostly because a lot of small typos would become valid wrong code
00:22:38 <kmc> there's already some pattern sugar that uses (==)
00:23:01 <opqdonut> oh?
00:23:19 <Kaidelong> opqdonut: for example, "isA 'a' = True"
00:23:38 <opqdonut> oh okay, literals
00:23:38 <kmc> «f 5 = e» ≡ «f n | n == fromIntegral 5 = e»
00:23:57 <kmc> Char is at least conceptually an algebraic enumeration type
00:24:03 <kmc> and its (==) instance behaves as such
00:24:20 <shachaf> Right, it's only for overloading.
00:24:25 <shachaf> Including IsString.
00:24:42 <kmc> but you can write Num types with fromIntegral and (==) that makes it act unlike any enumeration type
00:24:43 * shachaf kind of wishes IsString had a toString.
00:25:25 <kmc> I'm not a big fan of IsString because its main use case — ByteString — is fundamentally bankrupt
00:25:36 <kmc> it is fine for Data.Text, say
00:25:38 <shachaf> kmc: Not Data.Text?
00:26:04 <kmc> shachaf, I've seen it used more often for ByteString.  maybe that's because it causes more trouble there and people come here to ask questions about it and then I yell at them and insinuate that they're racist
00:30:50 * kmc still wonders about a nice tree search kind of problem which can be solved in one slide of code
00:31:05 <kmc> n-queens is a good choice, i guess
00:45:51 <erus`> what do i call "x = 123" as opposed to "123"
00:45:57 <erus`> a named value?
00:46:04 <coppro> a variable
00:46:15 <erus`> its constant though
00:47:00 <shachaf> You can call that whole thing a binding.
00:47:13 <shachaf> The x is a name, or a variable.
00:47:33 <erus`> ok cool
00:47:50 <edwardk> woot. i have the leijen/wadler pretty printers working with terminfo
00:48:29 <kmc> syntactically, it's a declaration
00:49:16 <edwardk> so i can say things like bold (text "hello") <+> foreground Blue (text "world")
00:51:08 <coppro> awesome
00:51:28 <kmc> woah
00:51:31 <kmc> nice edwardk
00:51:54 <kmc> i look forward to a world of declarative Haskell ANSI art demos
00:51:55 <edwardk> next up, using curses to figure out the actual terminal width
00:52:02 <edwardk> hah
00:52:08 <edwardk> i just wanted it for printing diagnostics
00:52:14 <edwardk> i had something weaker working before
00:52:21 <edwardk> but now it has a real pretty printer bolted on
00:52:29 <ivanm> edwardk: what, yet another fork? :p
00:52:51 <edwardk> ivanm: well, wl-pprint-extras is a fork, but this is just built on top =P
00:53:08 <edwardk> ivanm: the former is me making a free monad out of the wadler pretty printers
00:53:29 <edwardk> (and yes you can make them faster for binding purposes with codensity, etc) but i didn't ;)
00:53:51 <mauke> edwardk: IIRC that's an ioctl
00:53:55 <ivanm> edwardk: you know about the ansi-wl-pprint library?
00:54:38 <edwardk> ivanm: yeah. but it isn't 1993. i don't assume every terminal is ansi
00:54:42 <coppro> I want Haskell-equivalent curses
00:54:42 <ivanm> edwardk: you know about the ansi-wl-pprint library?
00:54:48 <ivanm> heh
00:55:06 <ivanm> did that statement of mine come up twice? I've been having network issues this arvo
00:55:08 <edwardk> mauke: yeah, but iirc ncurses gets access to it
00:55:12 <edwardk> ivanm: yeah
00:55:37 <ivanm> OK; it's a bit hard to tell when not even /whois returns anything :/
00:55:52 <mauke> edwardk: but ncurses is Terrible!
00:55:58 <edwardk> ivanm: using terminfo let me do things like ring a visualbell, etc.
00:56:07 <ivanm> *nod*
00:56:13 <edwardk> mauke: i don't want to do anything with it other than ask for the current screen width for error reporting
00:56:53 <hpaste> “`erus” pasted “either” at http://hpaste.org/49807
00:57:17 <edwardk> mostly so i can make a nice little 'do what i mean' command that starts pretty printing a terminfo document to standard output  or the terminal
00:57:20 <erus`> can i use one of the sexy operators to error check on line 24
00:57:34 <erus`> instead of (Right value)
00:58:46 <kmc> wait, non-ANSI terminals are becoming *more* common?
00:58:57 <coppro> erus`: dude you want to bind
00:59:04 <edwardk> kmc: no, but things like visual bell, etc. require me to insert timed delays
00:59:11 <coppro> erus`: also stop using lists like tuples
00:59:51 <erus`> Binding name <$> parseValue ts
01:00:13 <erus`> coppro: what do you mean, where do i use lists like tuples?
01:00:55 <coppro> erus`: oh wait, I misread; my bad
01:01:05 <coppro> erus`: you do know that Either is a monad right?
01:01:12 <erus`> yeah
01:01:22 <erus`> i just had to ask the question to answer it myself :|
01:07:57 <ivanm> edwardk: wait, wtf does this have to do with comonads, etc.?
01:07:57 <ivanm> ;-)
01:08:18 <edwardk> ivanm: since when do i just do comonads? =)
01:08:30 <edwardk> besides. i had a pretty printing profunctor in here for a while
01:18:13 <erus`> @hoogle f -> Either e [a] ->  Either e [a]
01:18:14 <lambdabot> No results found
01:18:27 <erus`> is there a map over Either
01:18:35 <erus`> where either holds an array
01:18:42 <erus`> list i mean
01:18:47 <Cale> erus`: You mean (a -> b) -> Either e [a] -> Either e [b]?
01:18:53 <Cale> fmap . fmap will do
01:19:14 <Cale> (or fmap . map)
01:19:23 <ivanm> Cale: you mean you're not saying to use fmap for . as well for once? :o
01:19:24 <ivanm> :p
01:19:37 <medfly> hi
01:19:53 <Cale> > (fmap . fmap) (*2) $ Right [1,2,3]
01:19:54 <lambdabot>   Right [2,4,6]
01:19:59 <Cale> > (fmap . fmap) (*2) $ Left "hello"
01:20:00 <lambdabot>   No instance for (GHC.Show.Show (f a))
01:20:00 <lambdabot>    arising from a use of `M7793677934...
01:20:05 <Cale> heh
01:20:17 <Cale> > (fmap . fmap) (*2) $ Left "hello" :: Either String [Integer]
01:20:18 <lambdabot>   Left "hello"
01:20:38 <ivanm> is that because there's no type available or something?
01:20:54 <ivanm>  > (fmap . fmap) (*2) $ (Left "hello" :: Left String [Int])
01:20:57 <ivanm> > (fmap . fmap) (*2) $ (Left "hello" :: Left String [Int])
01:20:58 <lambdabot>   Not in scope: type constructor or class `Left'
01:21:06 <Cale> yeah, it's ambiguous
01:21:24 <Cale> So it's unclear which is the inner functor
01:21:35 <Ptival> Cale: is (::) one of the less tightly binding operators?
01:21:42 <Cale> (::) isn't an operator at all
01:21:52 <Cale> Or rather, :: isn't
01:21:56 <Ptival> ok :)
01:22:16 <erus`> @hoogle (a -> Either e b) -> [a] -> Either e c
01:22:16 <lambdabot> No results found
01:22:17 <Cale> If you consider it an operator, then it binds more weakly than anything else
01:22:36 <Ptival> yeah
01:23:47 <Ptival> is it called something like "type annotation"?
01:24:10 <Cale> yeah
01:24:11 <erus`> ok i have a list of eithers, if any are Left i need to return the first left
01:24:51 <Cale> > sequence [Left "e1", Right [1,2,3], Left "e2"]
01:24:53 <lambdabot>   Overlapping instances for GHC.Base.Monad
01:24:53 <lambdabot>                              (Data...
01:25:00 <Cale> urk
01:25:12 <Cale> Well, the usual instance of Monad for Either will work.
01:25:56 <erus`> is there a function which returns the first left else returns all the right in an array of eithers?
01:26:13 <quicksilver> no
01:26:29 <quicksilver> although you can obviously write one :)
01:26:35 <Cale> I think you mean list
01:26:38 <Cale> not array
01:26:44 <erus`> yeah i do
01:26:50 <Cale> sequence is what you want
01:26:54 <quicksilver> erm, yes, ther is
01:26:57 <quicksilver> sequence is it :)
01:27:03 <quicksilver> sorry, not enough tea yet.
01:27:14 <Cale> import Control.Monad.Error
01:27:19 <Cale> and then use sequence
01:28:15 <dibblego> though the signature above is almost mapM (assuming there is an error in that signature), which is closely related to sequence
01:28:30 <dibblego> <erus`> @hoogle (a -> Either e b) -> [a] -> Either e c <-- assume you mean b here
01:31:58 <erus`> > (\x y z = x + y + z) <$> sequence [Right 1, Right 2, Right 3]
01:31:58 <lambdabot>   <no location info>: parse error on input `='
01:33:11 <quicksilver> you mean -> not=, but lambdabot's sequence is broken anyway
01:33:21 <Ptival> > (\x y z -> x + y + z) <$> sequence [Right 1, Right 2, Right 3]
01:33:23 <lambdabot>   Overlapping instances for GHC.Base.Monad (Data.Either.Either a)
01:33:23 <lambdabot>    arising ...
01:33:26 <Ptival> :)
01:33:32 <erus`> swap the anony func for sum
01:33:33 <quicksilver> well, lambdabot's monad instance for either is broken, to be precise.
01:33:56 <erus`> > sum <$> sequence [Right 1, Right 2, Right 3]
01:33:57 <lambdabot>   Overlapping instances for GHC.Base.Monad (Data.Either.Either a)
01:33:57 <lambdabot>    arising ...
01:34:02 <Cale> unfortunately, there seem to be two instances for Monad (Either e), I'm not sure which modules they're in
01:34:35 <Cale> But erus' last line would work otherwise.
01:34:46 <mauke> :t liftIO
01:34:47 <lambdabot>     Ambiguous occurrence `liftIO'
01:34:47 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
01:34:47 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
01:34:59 <mauke> @seen
01:34:59 <lambdabot> Unknown command, try @list
01:34:59 <preflex>  what
01:35:05 <mauke> ^ WHY
01:35:53 <quicksilver> mauke: why is @seen missing? or why is liftIO ambiguous?
01:36:24 <mauke> quicksilver: why haven't those been fixed yet?
01:36:43 <mauke> fixes: hide one of the liftIOs, make lambdabot ignore @seen
01:37:21 <quicksilver> well, liftIO is within cale's purview ;) I think it might be two versions of the mtl in scope? Ignoring @seen you could submit a patch for.
01:38:12 <mauke> I did
01:40:00 <quicksilver> mauke++
01:40:09 <quicksilver> did it get applied?
01:40:20 <mauke> no
01:40:22 <nlogax> only partially
01:41:04 <mauke> nlogax: what
01:41:21 <nlogax> sorry, bad joke
01:42:14 * hackagebot wl-pprint-terminfo 0.1 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.1 (EdwardKmett)
01:45:28 <edwardk> i should get some sleep before work
01:45:33 <edwardk> night all
01:46:02 <coppro> edwardk: have you seen the terminfo package?
01:46:14 <edwardk> coppro: i'm using it
01:46:27 <edwardk> coppro: just bound a wadler-leijen pretty printer on top
01:46:55 <edwardk> i tweaked the wl pretty printer to carry around arbitrary user terms (making it a free monad)
01:47:22 <edwardk> and then i made this to a.) showcase the technique, and b.) scratch an itch i had for something similar
01:47:41 <coppro> ah
01:49:18 <ivanm> coppro: he's using it
01:49:19 <coppro> edwardk: it has termLines and termColumns functions
01:50:08 <ivanm> @tell edwardk I already have something like your wl-pprint-extras in wl-pprint-text (as in a monadic Doc)
01:50:08 <lambdabot> Consider it noted.
01:50:27 <ivanm> oh, edwardk is still here... ;-)
01:51:15 <mauke> @uptime
01:51:15 <lambdabot> uptime: 11h 53m, longest uptime: 1m 10d 23h 44m 29s
01:51:47 <ivanm> edwardk: you may wish to grab the whitespace modifications I have in wl-pprint-text at least if you want to be able to do indentation, etc. properly
01:52:51 <ivanm> edwardk: I take it back, I misunderstood what wl-pprint-extras does; so it _isn't_ the same as what I have in the monadic version of wl-pprint-text
01:54:53 <edwardk> heh fair nuff
01:54:54 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
01:55:45 <edwardk> yeah a very different kind of doc =)
01:57:02 <edwardk> i did almost build on Text instead though, perhaps i'll add a .Text.Extras when i get a chance
01:59:52 <edwardk> ivanm: the monad in question make sense?
02:00:50 <edwardk> @messages
02:00:50 <lambdabot> ivanm said 10m 43s ago: I already have something like your wl-pprint-extras in wl-pprint-text (as in a monadic Doc)
02:01:11 <ivanm> edwardk: hmmm, so if I take your approach and make Doc a monad and then want to wrap StateT around it, I'd have to use lift all the time for the actual pretty-printing combinators, wouldn't I?
02:01:21 <edwardk> ivanm: yep
02:01:43 <edwardk> ivanm: the fact that my Doc became a monad was more or less incidental
02:01:56 <edwardk> but it was also useful because it lets me use ReaderT to pass around precedence
02:01:59 <edwardk> and local to change it
02:02:39 <edwardk> what i wanted was an effect type where i could pass around extra stuff that would make its way into the SimpleDoc
02:02:52 <edwardk> so whatever user extensions someone wants it can be thrown on top
02:04:56 <edwardk> also if you're going to use the monad a lot you probably want to work with Codensity Doc rather than Doc
02:07:07 <edwardk> ok. sleepy time
02:09:27 <ivanm> edwardk: well, all mine is is liftM{,2,3} on the existing combinators
02:09:36 <ivanm> the use case being so I could have State Doc a
02:11:08 <ivanm> if I used something like your monad (i.e. StateT Doc () a), to use the combinators would it require using lift from MonadTrans ?
02:11:22 <ivanm> (I've never used any Monad Stacks before)
03:26:07 <ehamberg> The haskell Wiki seems to begin a new paragraphs even where there is not a blank line, but it also looks like this has not always been the case.
03:27:01 <ehamberg> For example in http://www.haskell.org/haskellwiki/Monad/ST#An_explanation_in_Haskell-Cafe under the type for “runST”, there are several paragraphs starting mid-sentence.
03:27:38 <ehamberg> While under section 3, the first paragraphs is one, long line and is thus correctly interpreted as one paragraph.
03:28:49 <ehamberg> I guess some setting for the Wiki changed or something... Is this known? *Should* each paragraph be on one line‽
03:32:27 <erus`> http://hpaste.org/49809 can someone show me how to fix this please
03:32:55 <erus`> i think that the last <$> cant work as i need it to
03:35:35 <erus`> its the first one
03:35:38 <dibblego> Apply <$> parseExpression f <*> parseExpression ts -- you prolly want this
03:35:39 <erus`> i wanna bind and curry
03:36:29 <erus`> thanks dibblego
03:37:54 <erus`> oh no its building it the wrong way round
03:42:12 <dibblego> erus`: perhaps you want <**>
03:42:23 <Waspinator> Hi
03:43:08 <Waspinator> How can I fix this? : let z (x:xs ) a = z xs ( (a+1) `seq`  (a+1) ); z [] a = a in z [1..1000000] 0  *Exception: stack overflow
03:46:58 <ClaudiusMaximus> Waspinator: the seq isn't doing anything there; i'd try something like:  let z (x:xs) a = let b = a + 1 in b `seq` z xs b  (or use -XBangPatterns with z (x:xs) !a = ...
03:46:59 <Eduard_Munteanu> > let z (x:xs) a = a `seq` z xs (a + 1); z [] a = a in z [1..1000000] 0
03:47:00 <lambdabot>   1000000
03:48:59 <Eduard_Munteanu> Note when evaluation is forced.
03:50:18 <Waspinator> but seq x x eval x and "returns" x , isnt it?
03:50:32 <Waspinator> aaa
03:50:44 <Waspinator> it needs a var, no?
03:50:51 <Eduard_Munteanu> No.
03:51:28 <Eduard_Munteanu> > let z (x:xs) a = (a + 1) `seq` z xs (a + 1); z [] a = a in z [1..1000000] 0
03:51:29 <lambdabot>   1000000
03:51:51 <Eduard_Munteanu> Waspinator: it's still forcing nothing if you do it inside the recursive call to z
03:53:29 <Eduard_Munteanu> Waspinator: look at it this way... at every step, we force 'a' and _then_ call z again. Otherwise you're still building a huge expression that isn't evaluated until the end.
03:54:33 <Waspinator> ah
03:54:35 <Waspinator> now
03:54:37 <Waspinator> thanks
03:56:03 <Eduard_Munteanu> For example, take    z [1,2] 0 = z [2] ((0 + 1) `seq` (0 + 1)) = z [] ((0 + 1 + 2) `seq` (0 + 1 + 2)) = (0 + 1 + 2) `seq` (0 + 1 + 2)   so at the end you reduce the huge thing at once
03:56:15 <Eduard_Munteanu> erm 0 + 1 + 1
03:58:43 <Eduard_Munteanu> Work the correct variant out yourself, and you'll see how the seqs behave there.
04:00:02 <benmachine> Waspinator: the idea of seq is that 'seq x y' means 'when you want to evaluate y, evaluate x as well'
04:00:25 <benmachine> so seq x x is "when you evaluate x, evaluate x" which is useless :P
04:00:30 <Eduard_Munteanu> Yeah, better said ^
04:03:17 <Waspinator> very intesteing benmachine, Eduard_Munteanu
04:04:01 <erus`> could one ever apply a something to a number (value) ? not in haskell, but in another language would that ever be a sensible thing todo?
04:04:13 <erus`> 2 3 = 6?
04:04:22 <Eduard_Munteanu> > 2 3
04:04:22 <lambdabot>   2
04:05:12 <Eduard_Munteanu> Though this is Caleskell stuff :)
04:05:25 <Eduard_Munteanu> (or some imports of lambdabot doing this)
04:06:36 <erus`> at the moment i just throw an error if you try to apply something to a non function
04:10:36 <benmachine> erus`: a function is something you can apply to stuff
04:10:46 <benmachine> so a non-function is something you can't apply to stuff
04:10:49 <benmachine> QED
04:11:12 <NihilistDandy> erus`: I suppose you can do 2 3 = 6 in Mathematica~
04:11:13 <benmachine> a natural question is then could you have a language that had no non-functions
04:11:17 <benmachine> the answer is... probably
04:11:25 <benmachine> (that's lambda calculus isn't it?)
04:11:38 <NihilistDandy> Everything's a function!~
04:12:52 <erus`> if only i could implement the other mathmatical functions with mul then i would have the most minimal language evarrrr
04:13:10 <benmachine> that's a high claim :P
04:13:30 <benmachine> there are complete languages that have a syntax of two distinct instructions
04:13:31 <erus`> minimal * usable = over 9000
04:13:34 <Eduard_Munteanu> You don't really want minimality at all costs.
04:13:37 <NihilistDandy> erus`: I'm sure there's a way
04:13:51 <Eduard_Munteanu> (e.g. Brainfuck)
04:14:21 <Eduard_Munteanu> I think consistency is better said.
04:14:22 <Waspinator> Will BangPatterns be included in a future Haskell?
04:14:32 <benmachine> Waspinator: maybe.
04:15:10 <Eduard_Munteanu> (in the sense of not having lots of arbitrary rules)
04:16:03 <ion> instance Function [a] where apply = map; [42, 43] succ == [43, 44]
04:17:02 <Eduard_Munteanu> Waspinator: note GHC is probably the only compiler worth considering for real work at the moment. And anyway, lots of packages use at least one non-standard extension
04:18:00 <Eduard_Munteanu> Many of them are quite useful and relatively benign.
04:20:42 <Waspinator> then you recommend use BanPatterns always
04:21:17 <erus`> whats bang patterns? are they for lists?
04:21:37 <Eliel> it allows you to control strictness for variables
04:21:45 <Eliel> umm, not variables... what's the term?
04:21:57 <mokus> bindings
04:22:07 <Eliel> yes, bindings
04:22:39 <Eduard_Munteanu> It also cover use of '!' in data fields, IIRC.
04:22:43 <Eduard_Munteanu> *covers
04:22:47 <Eliel> helps with memory usage as well as processing efficiency if used correctly
04:23:21 <Eliel> but if used in the wrong place, it prevents benefits from laziness.
04:23:37 <Cale> Eduard_Munteanu: ! in data fields is part of Haskell98
04:23:52 <Eduard_Munteanu> Ah.
04:24:11 <Eliel> I seem to remember getting errors trying to use it on data fields without bang patterns
04:24:36 <Eduard_Munteanu> Waspinator: if you need it
04:26:49 <erus`> i want patterns like this rest:penultimate:last
04:27:00 <erus`> like : but reversed
04:27:15 <Eduard_Munteanu> I find it laziness doesn't usually result in performance improvements.
04:27:36 <Eduard_Munteanu> e.g. gains through deforestation
04:27:45 <quicksilver> erus`: see Data.Sequence and viewr
04:28:08 <Waspinator> Eduard_Munteanu: defoerestation?
04:28:17 <Eduard_Munteanu> erus`: also see the ViewPatterns extension, if you want something like pattern matching
04:28:50 <Eduard_Munteanu> Waspinator: http://www.haskell.org/haskellwiki/Short_cut_fusion
04:29:19 <Eduard_Munteanu> Also, laziness avoiding to do work isn't something that happens usually.
04:29:34 <benmachine> laziness isn't a performance feature
04:29:43 <benmachine> it's more about modularity and stuff
04:29:48 <Eduard_Munteanu> benmachine: sometimes it is pushed as such.
04:29:50 <benmachine> composability
04:30:17 <benmachine> Eduard_Munteanu: some people say silly things
04:31:02 <davor> yo, anyone on?
04:31:25 * benmachine waves
04:31:33 <Waspinator> this is a silly thing, isn't it?
04:31:35 <Waspinator> > let { z (x:xs) a = seq  (a+1) (z xs (a+1)); z [] a = a} in z [1..1000000] 0
04:31:36 <lambdabot>   1000000
04:31:42 <Waspinator> better_
04:31:46 <aninhumer> Composability seems like the unique paradigmn of Haskell to me, from what I've seen so far
04:31:53 <Waspinator> > let { z (x:xs) a = seq  (a+1) (z xs a); z [] a = a} in z [1..1000000] 0
04:31:53 <lambdabot>   0
04:31:54 <benmachine> aninhumer: right
04:32:05 <Waspinator> error, srry
04:32:20 <Waspinator> > let { z (x:xs) a = seq  a (z xs (a+1)); z [] a = a} in z [1..1000000] 0
04:32:21 <lambdabot>   1000000
04:32:40 <benmachine> Waspinator: I'd advise doing let a' = a+1 in seq a' (z xs a')
04:32:42 <Guest47820> i just wanted to ask about the diff. between "Simon Thompson's Haskell - The Craft of Functional Programming" and "Graham Hutton's Programming in Haskell"
04:32:48 <benmachine> or even
04:33:27 <benmachine>  let { z (x:xs) a = z xs $! a+1; z [] a = a} in z [1 .. 1000000] 0
04:33:33 <benmachine> >  let { z (x:xs) a = z xs $! a+1; z [] a = a} in z [1 .. 1000000] 0
04:33:35 <lambdabot>   1000000
04:33:44 <benmachine> simpler
04:34:09 <benmachine> davorb: I haven't read either, sorry
04:36:10 <NihilistDandy> davorb: Craft is better. End of.
04:37:14 <burbul> Is anyone familiar with Data.Graph?
04:37:46 <erus`> parseExpression ts | length ts > 1 = Apply <$> (parseExpression (init ts)) <*> (parseExpression [last ts])
04:37:51 <burbul> bcc (biconnected components) returns a [Tree [Vertex]]
04:37:53 <erus`> can i reduce that down any further?
04:38:05 <burbul> Whereas I would expect a [Tree Vertex]
04:38:17 <burbul> I.e. there is one level of [] which I don't understand...
04:38:54 <erus`> burbul: a tree has a single vertex?
04:40:40 <burbul> No -- In Tree a, a is the type of nodes of the tree
04:40:59 <frigga> Is there a way to include a bunch of .o files for foreign C libraries in your cabal package rather than forcing them to be already installed on the system?
04:41:15 <burbul> So it's returning trees whose nodes are lists of verteces
04:41:25 <burbul> I think each node corresponds to a biconnected component
04:41:45 <Waspinator> I'm Hutton's book is a good intro
04:41:46 <burbul> That's not silly in itself, but then I would expect to get a single tree rather than a list of trees...
04:41:59 <burbul> Basically I'm getting back [[[Vertex]]] where I would expect [[Vertex]]
04:42:00 <Waspinator> Hutton's book is a good intro
04:42:46 <Waspinator> I don'r recommend "Lear you a haskell"
04:43:33 <Jetbeard> LYaH helped me a lot
04:43:58 <int-e> frigga: there's a  c-sources  field for libraries which allows you to compile c files; the resulting .o files will be packaged with the library.
04:45:52 <int-e> frigga: http://hackage.haskell.org/packages/archive/zlib/0.5.3.1/zlib.cabal is an example
04:46:17 <quicksilver> burbul: the top level list is in case the graph is disconnected, surely?
04:46:28 <quicksilver> burbul: so you get a top-level item for each connected component
04:46:34 <Waspinator> Jetbeard: I begin reading LYaH, I get discouraged
04:46:48 <quicksilver> and within each connected component you get a tree of biconnected comps
04:47:20 <burbul> quicksilver: just figured out that empirically -- but thank you!
04:47:36 <quicksilver> burbul: :)
04:47:44 <quicksilver> burbul: TIAS++
04:47:50 <Waspinator> Now that I know something I'm reading again, it's a great book, but it has too higher types for beginning
04:48:07 <burbul> TIAS?
04:48:21 <burbul> ah -- googled it
04:48:41 <Eduard_Munteanu> Waspinator: dunno, most people complain LYAH it's a bit too wordy
04:48:50 <Eduard_Munteanu> s/it's/is/
04:49:08 <frigga> int-e: Ahhh, thanks.  That helps.  But the C project I'm using is a bit bigger than that, so getting GHC to build it all seems a bit of a pain.
04:49:51 <Waspinator> yes
04:50:53 <Waspinator> LYaH in a advanced section about Monads explain gcd algorithm
04:50:55 <int-e> frigga: but includeing .o files is not portable. you can probably hack something together using Cabal's hook mechanism, but it won't be supported directly.
04:53:20 <frigga> int-e: Yeah, I realize that.  My real problem is that the library ships a .a lib instead of a .o.  My wrapper builds fine with GHC, but I cannot use it from GHCi because it seems GHCi does not know how to link with .a files.
04:54:52 <frigga> You don't realize how nice ghci is until you don't have it.
04:55:20 <int-e> frigga: hmm. theoretically it's just a matter of using ld -r on the right list of objects, combining them into a single one.
04:55:37 <hpaste> XniX23 pasted “err” at http://hpaste.org/49812
04:56:01 <XniX23> could anyone explain me what im doing wrong?
04:56:21 <int-e> frigga: but I never tried that so I don't know what problems lurk around the corner when you do that.
04:56:29 <frigga> Ahh, I'll look into it.
04:56:33 <Eduard_Munteanu> frigga: well, you can use Makefiles or whatever build system (e.g. autotools) you feel like
04:57:05 <frigga> Eduard_Munteanu: How would that work?  Cabal would use the makefile?
04:58:33 <Eduard_Munteanu> frigga: possibly, I think it can start a normal make build. That if you want to use Cabal.
04:59:07 <Eduard_Munteanu> And anyway, if you're including all sorts of precompiled stuff, I'm not sure if that's welcome on Hackage. I might be wrong though.
04:59:38 <Eduard_Munteanu> IIRC, Cabal shouldn't attempt to deal with getting non-Haskell dependencies.
05:00:07 <quicksilver> XniX23: you want to type take' (-1) [1]
05:00:14 <quicksilver> XniX23: negative numbers need ()
05:00:37 <XniX23> quicksilver: ohhh thank you very much!
05:01:24 <int-e> frigga: right, there are build-types besides Simple, namely Configure (runs ./configure prior to building), Make (not quite sure what it does exactly), custom (uses custom Setup.(l)hs).
05:03:57 <int-e> And, heh. http://hackage.haskell.org/packages/archive/Cabal/1.10.2.0/doc/html/Distribution-Make.html (which implements the 'Make' build type) says about itself "Perhaps at some point we should stop pretending that it works." but it seems to do the usual configure + make dance (and does not build any haskell stuff itself, by the looks of it.)
05:04:19 <frigga> heh
05:06:15 <Eduard_Munteanu> Well, it looks like it simply calls 'make'.
05:06:40 <Eduard_Munteanu> Unlike autotools stuff where you have to use configure and possibly autoreconf
05:07:05 <Waspinator> why we can't do instance Myclass String ?
05:07:07 <int-e> Eduard_Munteanu: by the description it calls configure, then make.
05:07:16 <increpare> I've been out of the haskell loop for a while now.  Have any nice gui libraries/updates appeared over the past year or so?
05:08:07 <int-e> Eduard_Munteanu: auto(re)conf is something the package maintainer is supposed to do when preparing a release. so it's completely in line with the autotools process, I'd say.
05:08:31 <quicksilver> Waspinator: limitation in haskell98.
05:08:39 <quicksilver> Waspinator: GHC has FlexibleInstances
05:08:45 <Eduard_Munteanu> int-e: I mean not all packages use autotools. Some use plain Makefiles.
05:09:12 <Waspinator> why?
05:09:12 <quicksilver> however, that still won't let you have an instance String and a different instance [a], which is a different point.
05:09:41 <Eduard_Munteanu> increpare: gtk2hs is quite nice, though that's not new.
05:09:46 <quicksilver> I don't know of a good reason, except making certain checks simpler.
05:19:18 <frigga> ick, when I try to link the .o created by "ld -r", I get "unhandled ELF relocation type 23"
05:20:28 <frigga> Google hasn't yielded any clues.
05:22:49 <erus`> :t <$>
05:22:49 <lambdabot> parse error on input `<$>'
05:22:55 <erus`> @hoogle <$>
05:22:55 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
05:23:20 <frigga> :t (<$>)
05:23:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:23:54 <erus`> @hoogle (a -> f b) -> f a -> f b
05:23:54 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
05:23:54 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
05:23:54 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:26:10 <erus`> holy crap im monading
05:26:24 <erus`> look mum!
05:27:03 <NihilistDandy> I hope lambdanaut is a pirate themed robot
05:27:18 <Botje> of the pillage and plunder the loot!
05:27:36 <Clint> lamb da naut
05:27:44 <Botje> lamb dana ut
05:28:13 <NihilistDandy> lamb dan aut
05:29:19 <zygoloid> @botsnack
05:29:19 <lambdabot> :)
05:29:30 <NihilistDandy> Also, this Unicode table calls it GREEK SMALL LETTER LAMDA, which I find infuriating
05:29:55 <NihilistDandy> 03BB
05:30:46 <erus`> > 0x3BB
05:30:46 <lambdabot>   955
05:30:50 <erus`> ╗
05:30:53 <erus`> :|
05:31:59 <NihilistDandy> U+03BB
05:32:34 <mokus> well, it was their letter first so I guess they can spell its name however they want
05:32:44 <NihilistDandy> You've just done U+2557
05:33:46 <NihilistDandy> mokus: Λάμβδα
05:34:25 <NihilistDandy> Though Λάμδα is also listed :|
05:34:44 <mokus> NihilistDandy: my IRC hates unicode, so i don't know what you said
05:35:10 <ion> BitchX? Seriously? :-)
05:35:17 <NihilistDandy> Capital lambda, álpha, mu, beta, delta, alpha
05:35:23 <mokus> heh, yea
05:35:30 <Axman6> why not irssi?
05:35:43 <NihilistDandy> Then, capital lambda, álpha, mu, delta, alpha
05:35:50 <mokus> Axman6: found one that worked and never bothered trying another...
05:36:00 <ion> An unmaintained client with a history of awful security
05:36:00 <Axman6> i never could get BitchX working
05:36:15 <ion> and no support for essential modern things such as UTF-8
05:36:38 <mokus> ion: well, until now i never needed utf8, and it runs on a computer that doesn't have anything to steal ;)
05:36:39 <NihilistDandy> "BitchX is the most popular IRC client among Unix systems."
05:36:41 <Ke> not too essential for those who only communicate within ascii
05:37:16 <zygoloid> NihilistDandy: is that really still true? i'd have thought irssi would be winning by now
05:37:38 <NihilistDandy> zygoloid: Apparently irssi didn't even make their list :/
05:38:07 <Nimatek> Many Ubuntu users I know use xchat.
05:38:18 <NihilistDandy> Also, bold text: http://www.bitchx.org/
05:38:24 <NihilistDandy> Curiouser and curiouser
05:39:22 <mokus> NihilistDandy: in any case, I think the beta hasn't been used in the name in centuries, but i could be wrong about that
05:40:35 <NihilistDandy> Time for sleep
05:40:48 <mokus> I'll have to give irssi a try though, this isn't the first time it's been suggested to me
05:41:25 <NihilistDandy> I'll recommend it, as well. Though really I'll recommend irssi as a bouncer and whatever you like as a client
05:41:36 <mokus> screen is my bouncer
05:41:45 <sordina2> I've been using weechat for a while, quite like irssi, more pleasent defaults though
05:46:19 <erus`> is there a monad unfold?
05:46:41 <zygoloid> NihilistDandy: according to debian popcon, irssi has nearly 8* more active users than all ircII-derived clients in debian combined (though bitchx is apparently not packaged in debian)
05:46:42 <Axman6> erus`: what type would it have?
05:47:03 <quicksilver> not by default although a number of people have written one.
05:47:19 <NihilistDandy> zygoloid: I was just going by their site :D
05:47:37 <Axman6> unfoldM :: (a -> m (b,a)) -> a -> m [b]?
05:47:39 <quicksilver> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:unfoldM
05:48:38 <zygoloid> NihilistDandy: well, someone's site at least ;)
05:48:57 <NihilistDandy> heh
05:49:50 <erus`> @hoogle unfoldr
05:49:50 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
05:49:50 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
05:49:50 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
05:51:11 <erus`> (a -> m (Maybe a, b)) -> a -> m [b] ?
05:52:38 <erus`> who knows, or cares
05:55:57 <deech> In the header of a module can I list functions/types that I don't want exported? For instance, if Module X has functions a,b and c, can I write something like "module X (hiding b) ..." so it exports everything but b?
05:56:21 <Axman6> i don't believe so
05:56:49 <Axman6> though, you may be able to do it with two module, with the second one importing the first, hiding what you want, and exporting the module
05:57:17 <ezyang> There's a tricky way to do this, but not directly.
05:57:27 <ezyang> (I don't think. Could be wrong.)
05:57:39 <deech> ezyang: Go on .... :)
05:58:23 <ezyang> Create two modules: Foo.Internal and Foo. Then, import Foo.Internal inside Foo, and export the module itself with a 'hiding' declaration.
05:58:31 <ezyang> Hoopl uses this trick, in Compiler.Hoopl.
05:58:33 <shachaf> deech: Presumably ezyang means what Axman6 said.
05:58:53 <Axman6> yeah... what i said
05:59:01 <ezyang> Oh, oops, didn't see that :^)
05:59:54 <deech> ezyang, Axman6 : Gotcha. Perhaps this would be a nice extension seeing as there's an asymmetry between exporting and importing.
06:00:13 <ezyang> Yeah, probably wouldn't be too hard to add. Propose it on the ML?
06:00:26 <shachaf> I'm sure it's been proposed before.
06:00:29 <shachaf> At least in this channel.
06:00:38 <Axman6> the advantage of explicitly listing everything you want to export comes from being able to order and group functions in haddock output
06:01:32 <frigga> Axman6: ...which everyone should always do. ;)
06:01:39 <Axman6> indeed
06:01:40 <Axman6> :P
06:02:30 <deech> Actually now that I think about it this is probably a bad idea. Explicitly managing exports is a job for the IDE not the compiler.
06:03:47 <deech> What's a skolem type?
06:05:59 <NihilistDandy> You mean skolem type variable?
06:06:21 <quicksilver> it's a variable which can't be unified because inference requires it to be arbitrary
06:06:36 <NihilistDandy> Relevant: http://hackage.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7
06:06:42 <quicksilver> so you have code which must work for all possible 'a' (due to a type signature somewhere)
06:06:50 <deech> NihilistDandy: yes. I got an error about a "skolem type variable escaping...". The solution is to add a type sig to the function, but I just wanted to know what it was.
06:07:35 <NihilistDandy> deech: What version are you using? I thought they changed that after 7.0.1
06:07:47 <deech> 7.0.1
06:08:10 <deech> quicksilver: Ah so I need a less polymorphic type.
06:08:31 <NihilistDandy> I think the term I usually hear now is "rigid type variable"
06:08:54 <deech> NihilistDandy: That's more descriptive.
06:09:20 <NihilistDandy> True :D
06:09:49 <deech> Thanks all!
06:12:55 <ion> What’s the etymology of skolem?
06:13:30 <ezyang> Skolem was a dude.
06:13:44 <ezyang> A Norwegian dude.
06:22:01 <copumpkin> ion: skeletor
06:24:19 * hackagebot syntactic 0.6 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-0.6 (EmilAxelsson)
06:28:45 <burbul> Can you define a datatype locally inside a function?
06:28:53 <shachaf> Nope.
06:29:00 <burbul> Thanks
06:43:19 <erus`> Apply a <$> (parseAppList as)      i need to rearange this so that a and (parseAppList as)  are the other way around
06:43:44 <quicksilver> Apply <$> parseAppList as <*> pure a
06:44:13 <erus`> @hoogle pure
06:44:14 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
06:44:37 <erus`> yey thanks quicksilver
06:44:58 <quicksilver> you're welcome.
06:45:34 <MHD> hmm
06:45:34 <erus`> if i showed this code to myself a week ago i would be like wtf
06:46:12 <byorgey> past selves are always so ignorant
06:47:19 <erus`> unless alzheimer's
06:47:58 <quicksilver> byorgey: I'm not sure. I can clearly remember that, as a teenager, I knew EVERYTHING; whereas now I know how far that is from the truth.
06:48:13 <erus`> my haskell code never looks pretty
06:48:38 <byorgey> quicksilver: Right, I didn't say past selves THINK they are ignorant, just that they are =)
06:49:14 <erus`> fucking monads...
06:49:37 <erus`> i dont know why people say fucking magnets, monads are for more confusing
06:49:50 <MHD> erus`: surely you jest
06:49:55 <byorgey> at least I understand how monads work.
06:50:02 <MHD> monads are straighforewrd
06:50:05 <shachaf> No one understands magnets, really.
06:50:22 <byorgey> I agree monads are more confusing than magnets, though.
06:50:22 <Axman6> we can explain what they do, but not exactly how they do it
06:50:31 <ceii__> @google monads are magnets
06:50:32 <MHD> it is category extras that is problematic
06:50:32 <lambdabot> http://www.urbandictionary.com/products.php?term=monad&defid=894676
06:50:32 <lambdabot> Title: Urban Dictionary: monad t-shirts, mugs and magnets
06:50:39 <ceii__> :s
06:51:02 <intractable_> Can someone help me gain some intuition about the "Illegal type synonym family application in instance" error I'm getting from http://hpaste.org/49815 ? Trying to use type families but am having a problem creating typeclass instances.
06:52:06 <mreh> what's a universally quanified applicative instances?
06:52:14 <erus`> i can write haskell code on the whiteboard at work and people think i'm a maths genius :P
06:52:15 <Axman6> "Monad: The singular forum of the word gonads. To have only one testicle.
06:52:16 <Axman6> Hey ever since that infection, my monad has been swollen and sore.
06:52:43 <quicksilver> intractable_: please paste exact error
06:52:46 <parcs> intractable_: you can't use type families in instances
06:52:58 <intractable_> parcs: so i simply cannot do what i'd like here?
06:53:02 <Nisstyre> mreh: not sure but I know what a universally polymorphic existential applicative category is
06:53:03 <parcs> 'instance Sem (M iface m) (SBETerm iface) where'
06:53:25 <parcs> intractable_: not using type families
06:53:29 <intractable_> i'm trying to avoid any detailed knowledge of the term type in that instance -- this is an example lifted from more context.
06:53:34 <mreh> Nisstyre, that sounds like alot of stuff
06:53:35 <intractable_> parcs: bahhhhh
06:53:45 <Nisstyre> mreh: it is :P
06:53:48 <byorgey> intractable_: I suggest you move the SBETerm application from the head of the class to the type signature of iAdd
06:53:51 <Nisstyre> also my bullshit is strong
06:54:14 <mreh> Nisstyre: universally polymorphic sounds suspect
06:54:29 <byorgey> intractable_: also, it's strange that you are using both type families and functional dependencies
06:54:48 <byorgey> intractable_: if int is really determined by m in a Sem instance, then int ought to be an associated type family
06:54:48 <Waspinator> Hi, I repeat the question: why we can't do instance Miclass String ?
06:55:16 <intractable_> byorgey: hmm, ok, let me think about this a bit ;P
06:55:22 <Nisstyre> mreh: something could be universally polymorphic
06:55:23 <quicksilver> Waspinator: I answered you before.
06:55:37 <byorgey> intractable_: so,   class (MonadIO m) => Sem m where   type Foo m :: *;  iAdd :: Foo m -> Foo m -> m (Foo m)
06:55:42 <ceii__> Waspinator: because String is a type synonym. You need to use its actual name ([Char]), or use the TypeSynonymInstances extension
06:55:42 <erus`> using monads: try different operators until it builds
06:56:04 <byorgey> instance Sem (M iface m) where   type Foo (M iface m) = SBETerm iface;  iAdd x y = ...
06:56:09 <mux> /*\*/@import url("css/feuilledestyle.css");/**/
06:56:12 <mux> woops, sorry.
06:56:17 <Waspinator> yes, thanks quicksilver
06:56:20 <intractable_> byorgey: yeah, i think that's what i was looking for -- thanks muchly.
06:56:26 <byorgey> intractable_: sure.
06:56:34 <intractable_> the functional dependencies hadn't been fully vacated yet ;P
06:56:36 <intractable_> this is mid-refactor
06:56:54 <byorgey> hehe, right =)
06:57:41 <Waspinator> ceii__: instance Miclass [Char] is impossible too
06:58:02 <quicksilver> Waspinator: not with FlexibleInstances
06:58:07 <quicksilver> Waspinator: (which is what I told you last time)
06:58:09 <Waspinator> quicksilver give me a solution, but I want to know why
06:58:20 <quicksilver> it was just a simplification in haskell98
06:58:31 <ceii__> ah, yes
06:58:37 <quicksilver> there isn't a satisfying deep reason for it, although it was related to how people expected typeclasses to used
06:58:54 <quicksilver> in particular, they expected you would always write a polymorphic instance for [a]
06:58:54 <ceii__> in pure Haskell98 you can only give an instance for a constructor applied to a number of type _variables_
06:58:59 <quicksilver> not a specific one for [Char].
06:59:10 <ceii__> ^what quicksilver says
06:59:34 <Waspinator> is a strong simplification
06:59:47 <quicksilver> what *is* important, and there is a good reason for, is why you can't simultaneously define one for [a] and [Char].
07:00:13 <Waspinator> ok
07:00:49 <Waspinator> why we can't simultaneously define instance Mic [a] and instance Mic [Char]?
07:01:07 <quicksilver> because that breaks polymorphic code.
07:01:14 <Waspinator> how?
07:01:23 <quicksilver> (there is an OverlappingInstances extension, but it's a bad idea)
07:01:41 <quicksilver> because if you have code which is polymorphic in a, and uses the Mic instance on [a]
07:01:43 <theorbtwo> Waspinator: Which one would get used?  Does it vary if you say [a] when a happens to be Char vs when you say [Char]?  What if the compiler can tell that a=Char?
07:01:54 <quicksilver> there is no way it could know at runtime that it has been passed a Char
07:01:55 <Waspinator> very interesting, why it's a bad idea? That is I want to know
07:02:15 <quicksilver> polymorphic code in GHC is really compiled polymorphic, so it can't tell what type its arguments are.
07:02:33 <Waspinator> with OverlapedInstances GHC uses the mos specific
07:02:41 <quicksilver> not successfully, no
07:02:47 <quicksilver> it tries to, but in fact it is impossible
07:02:54 <Waspinator> why?
07:02:59 <quicksilver> for the reason I just explained
07:03:08 <quicksilver> your module can have export a polymorphic function
07:03:14 <quicksilver> this function is only compiled once
07:03:22 <bxc> i guess you have the behaviour that adding instances can change the behaviour of existing code, if you allow that (even if it works)
07:03:27 <Axman6> i assume instance Foo (a,Int) where and instance Foo (Char,b) where would be an example?
07:03:30 <MHD> GHC is polymorphic, not overloading
07:03:32 <quicksilver> and it can be called with a = Char or a = SomethingElse and never know
07:03:53 <quicksilver> the OverlappingInstances hack only works reliably where all polymorphism is overloaded locally
07:04:03 <bxc> instance f [a] = 1;   f "hi" = 2; now add another instance f [Char] = 3 ; and f "hi" now = 3
07:04:04 <quicksilver> in particular it works if everything is in a single file
07:04:16 <quicksilver> or if all the critical functions are successfully inlined
07:04:28 <quicksilver> or if all the polymorphism is resolved close to point of use.
07:04:42 <quicksilver> since these conditions are quite hard to understand in practice, I do not recommend it.
07:04:49 <bxc> which seems ugly in the sense of that idea of adding facts to a statement should add more facts, not change existing onces
07:05:03 <quicksilver> that's also a good argument bxc
07:05:11 <quicksilver> (although in some ways it is saying the same thing)
07:05:13 <Axman6> Waspinator: if you had class Foo a where foo :: a -> String, instance Foo b => Foo (Int,b) where foo x = ..., instance Foo a => Foo (a,Int) where foo x = ..., and you give foo something of type (Int,Int), which one shoudl it use?
07:07:58 <Waspinator> ok quicksilver, Axman6, bxc , thanks you
07:08:14 <Waspinator> Now I have it :)
07:08:51 <intractable_> byorgey: http://hpaste.org/49815 -- i'm trying it like this, but get "Application is no smaller than the instance head in the type family application" ; what does that even mean?
07:11:58 <benmachine> quicksilver: couldn't you just do everything by dictionary-passing, and have it work that way?
07:12:18 <benmachine> (although that prevents optimisation I suppose)
07:12:22 <quicksilver> benmachine: why should a function of the type "f :: a -> Int" (for example) require a dictionary?
07:12:23 * hackagebot BiobaseInfernal 0.5.2.0 - Infernal data structures and tools  http://hackage.haskell.org/package/BiobaseInfernal-0.5.2.0 (ChristianHoener)
07:12:33 <quicksilver> NB the type is not Mic a => ....
07:12:41 <quicksilver> because it does not require an instance of Mic for a :)
07:12:50 <benmachine> because there is one already?
07:12:53 <benmachine> as it were
07:12:55 <benmachine> ok
07:12:57 <quicksilver> it requires an instance of Mic [a], and that already exists, so no constraint required.
07:13:01 <benmachine> fair enough
07:13:25 <ceii__> intractable_, can you give the line number and other details?
07:13:32 <intractable_> ceii__: sure, sorry, one sec
07:13:33 <quicksilver> I mean, you can imagine a system which propagates more constraints than necessary
07:13:37 <quicksilver> to enable this kind of thing
07:13:46 <quicksilver> ...but that's quite a big change to the type checker.
07:13:52 <benmachine> mm
07:13:54 <quicksilver> I have no idea what the implications of that would be.
07:13:58 <benmachine> I wonder if Overlapping will ever be removed
07:14:32 <intractable_> ceii__: added the error message
07:14:56 <mreh> first they take our side effects, then our Overlapping
07:15:05 <mreh> tsk
07:15:14 <mreh> what's next, inverted commas?
07:19:36 <ceii__> intractable_: you get an error because you declared that for "IntTy iface" to exist, "SBETerm iface" has to exist. Keeping in mind that type families are open, this means GHC can't prove that instance resolution will always terminate.
07:19:52 <burbul> Is there an easy way to compute the symmetric closure of a Data.Graph?
07:19:55 <ceii__> so you need to turn off the termination checker with UndecidableInstances
07:20:23 <intractable_> ceii__: aha, ok, that makes sense. thanks for the explanation.
07:20:42 <ceii__> you're welcome
07:20:43 <intractable_> it doesn't know if SBETerm iface is defined.
07:21:27 <ceii__> you could define it later as, for example, "SBTerm iface = IntTy iface", and throw the typechecker into a loop
07:21:34 <burbul> ah, nm, found the function I need
07:21:36 <intractable_> right
07:21:40 <intractable_> good times =)
07:21:43 <ceii__> so GHC needs a termination criterion, and the one it uses is a bit sumb
07:21:47 <ceii__> dumb*
07:24:12 <Fabian___> hallo
07:24:29 <dafis> hello
07:36:10 <BlankVerse> any haskell web app which is open source?
07:36:23 <BlankVerse> and uses a haskell web framework?
07:36:40 <dainanaki> BlankVerse: for open source frameworks, there's snap, yesod, happstack.
07:36:43 <Axman6> lots. the most populat is probably hpaste though
07:36:52 <Axman6> hpaste.org
07:37:36 <mightybyte> BlankVerse: http://snapframework.com/faq#is-anyone-using-snap-in-production
07:38:45 <dainanaki> I have a bit of an odd problem I'm working on:
07:39:43 <dainanaki> I'm trying to figure out how to use something like dyre or another runtime evaluation library and get the names of all of the functions defined in the runtime evaluated code.
07:39:56 <dainanaki> Does anyone have any ideas how I could do this in a reasonable way?
07:42:03 <jules2> What is the following technique called: you write functions var, lam and app corresponding to the language features of lambda calculus. Then instead of writing your programs in ordinary syntax, you write all variables x as var x, all lambdas \x -> m as lam (\x -> m) and all applications f x as app f x?
07:42:43 <jules2> You can use this with the appropriate definitions of var app and lam to do e.g. lazy evaluatino in a strict language, strict evaluation in a lazy language, cps transform, etc.
07:42:44 <dmwit> "embedding"?
07:43:18 <quicksilver> dainanaki: hint can browse modules it has loaded
07:44:30 <jules2> dmwit: do you know some keywords i can search for to find things that make use of this technique, or do you know things that make use of this?
07:45:07 <quicksilver> "deep embedding" "deep shallow encodings"
07:45:16 <quicksilver> are phrases used in the literature for this general kind of thing
07:45:29 <dainanaki> quicksilver, thanks, I was just looking at that. Is there a way to see the type of the function? I only see a way to look at names.
07:45:30 <dmwit> jules2: If you specifically want Haskell examples, search for "GADT". This is like _the_ example of where GADTs are useful.
07:46:50 <quicksilver> dainanaki: you can use typeof on the name, can't you?
07:46:52 <erus`> @pl \as -> \(v, rest) -> readAppList rest (v:as)
07:46:52 <lambdabot> (`ap` snd) . (. fst) . (flip readAppList .) . flip (:)
07:48:43 <jules2> dmwit, quicksilver: thanks! that turned up a page about tagless-final interpretations, which seems to be exactly what I was looking for :)
07:49:08 <copumpkin> that sounds like hoas
07:49:12 <copumpkin> jules2
07:49:40 <copumpkin> the lam (\x -> m) bit does, anyway
07:52:10 <jules2> copumpkin: hmm it seems very similar indeed
07:59:37 <dainanaki> OK, so Hint seems to be only able to load code by module name, but what if I just want to load all Haskell files in a given directory and don't necessarily care about the module name?
08:00:03 <dainanaki> actually, I'm dumb
08:00:13 <dainanaki> I should read the documentation better.
08:14:07 <dainanaki> Why does running an interpreter in ghci cause it to segfault?
08:14:18 <dainanaki> I was hoping for a little bit of HASKCEPTION
08:14:29 <copumpkin> what kind of interpreter in ghci?
08:15:03 <dainanaki> Hint
08:15:25 <quicksilver> you created a singularity
08:15:30 <quicksilver> it's a shame that it doesn't work though.
08:15:49 <dainanaki> Seriously though, I was running the interpreter on the code that contained the interpreter.
08:17:05 <dainanaki> On the upside, it builds and runs fine.
08:17:15 <dmwit> ghci does funny things with threads
08:17:32 <dmwit> This has traditionally been a problem when using GUI libraries.
08:17:35 <Fuco> what does ~ mean in this: unzip    =  foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
08:17:46 <dmwit> But perhaps hint also has some thread assumptions that ghci breaks.
08:18:22 <dmwit> Fuco: It's an irrefutable pattern; it means that it is assumed to match, and actually checking the constructor of (as,bs) is delayed until one of as or bs is demanded.
08:18:36 <dmwit> It's an efficiency thing.
08:18:51 <dainanaki> Well, life will go on. I can still do what I need to do with hint without doing so in ghci.
08:18:53 <Fuco> ok, in other words, don't worry aboutit :)
08:19:02 <quicksilver> in some cases that efficiency thing can be the difference between nontermination and code which works, though
08:19:03 <alex404> Let's say I've got a typeclass that will never be extended - I know in advance which datatypes will be part of it. Does this mean I should just use an ADT as well? Are typeclasses at all useful in closed executables?
08:19:03 <int-e>  foldr (\(a,b) x -> (a:fst x, b:snd x)) would be pretty much equivalent.
08:19:49 <dmwit> Well, except that your code checks the constructor of x twice, yes.
08:20:19 <dmwit> alex404: Typeclasses cannot be closed. But that doesn't mean they aren't useful.
08:20:25 <dafis> foldr (\(a,b) x -> let (xs,ys) = x in (a:xs,b:ys))
08:20:37 <dmwit> Classes often offer a much nicer syntax than ADTs.
08:21:00 <alex404> dmwit: I'm trying to build some intuition about that...
08:21:16 <alex404> It seems though that typeclasses are almost always a better idea
08:21:31 <dmwit> alex404: So, you can think of typeclasses as offering an implicit dictionary parameter.
08:21:41 <int-e> dafis: right, but it's sidestepping the problem - how do you translate that to core (where you only have let on values and case?)
08:21:46 <dmwit> You can always write that dictionary yourself, and you often get much more flexibility out of that approach.
08:22:02 <dmwit> But you probably don't want to, because then all your code is littered with implicit parameters made explicit. =P
08:23:11 <alex404> dmwit: But isn't all your talking about whether to have a bunch of small instance declerations all over your code, vs one place where a monolithic data type is defined?
08:23:16 <dafis> int-e: I'll let ghc do the translation (and it better compile it as if I'd written ~(xs,ys) ;)
08:23:21 <int-e> \x y -> case x of (a, b) -> let as = case y of (as, _) -> as; bs = case y of (_, bs) -> bs in (a:as, b:bs)
08:23:34 <dmwit> alex404: one second
08:23:35 <int-e> but is, sadly, not very enlightening
08:24:08 <int-e> Unless you already know what irrefutable pattern matches do.
08:27:08 <hpaste> dmwit pasted “three approaches” at http://hpaste.org/49819
08:27:24 <dmwit> alex404: There, now we have three concrete names for the possible approaches.
08:27:25 <dmwit> Good?
08:28:43 <Saizan> the ADT one wouldn't look like that, usually
08:29:06 <dmwit> Okay, let's add approaches and names in parallel. Go ahead and annotate... =)
08:31:30 <Veinor> remind me
08:31:39 <Veinor> to make a functor into a monad, it suffices to define join, right?
08:31:45 <Veinor> (assuming that all the laws are satisfied)
08:31:54 <alex404> dmwit: Just having a look now...
08:32:02 <dmwit> Veinor: In category theory, yes; in Haskell, no.
08:32:06 <Veinor> er
08:32:07 <Veinor> join and return
08:32:09 <azaq23> Veinor: You also need return, otherwise yes
08:32:20 <dmwit> ...and return, urk
08:32:25 <zong_sharo> hi, i wrote my onw simple polymorphic records system - here it is http://paste.pocoo.org/show/451999/
08:32:28 <Saizan> data Foo = Int Int | Bool ool; bar (Int i) = i; bar (Bool b) = fromEnum b; and avoid baz
08:32:32 <Veinor> dmwit: what extra do you need in haskell?
08:32:32 <zong_sharo> how much it will tax performance?
08:32:51 <dmwit> Saizan: Ah, that looks much more reasonable, yes.
08:33:00 <zong_sharo> i'm aware of O(n) lookups, it's kinda okay
08:33:13 <dmwit> Veinor: Well, join just isn't in the Monad class.
08:33:23 <dmwit> Veinor: So you have to implement it as (>>=).
08:33:31 <Veinor> ah
08:33:34 <zong_sharo> i more concerned about stuff i didn't see, how much ghc will be able to optimize it?
08:33:48 <dmwit> Veinor: You can define "joinFoo" for your type, and then implement (>>=) in terms of it, but you have to write down an implementation for (>>=). =)
08:33:53 <Veinor> but, you can impelement (>>=) using fmap and join
08:33:55 <dmwit> Veinor: (+ there's "fail" in Haskell...)
08:33:59 <Veinor> fuck fail :P
08:34:24 <alex404> dmwit: Yah, that's quite handy. Thanks for that.
08:34:43 <dmwit> Veinor: Oh, yes, you can perfectly well write "m >>= f = myJoin (fmap f m)". But you do have to write that.
08:34:52 <Veinor> of course
08:35:05 <Veinor> @pl m >>= f = join (fmap f m)
08:35:06 <lambdabot> (line 1, column 9):
08:35:06 <lambdabot> unexpected "="
08:35:06 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
08:35:11 <Jetbeard> vfdx
08:35:21 <Veinor> @pl \m f -> join (fmap f m)
08:35:21 <lambdabot> (join .) . flip fmap
08:35:58 <dmwit> zong_sharo: Have you had a look at hlist?
08:36:04 <dmwit> ?hackage HList
08:36:04 <lambdabot> http://hackage.haskell.org/package/HList
08:36:25 <Veinor> so that makes (join .) . fmap = (=<<), right?
08:36:40 <dmwit> ?unpl \m f -> join (fmap f m)
08:36:40 <lambdabot> \ m f -> (fmap f m) >>= \ a -> a
08:36:46 <dmwit> ?pl \m f -> join (fmap f m)
08:36:46 <lambdabot> (join .) . flip fmap
08:36:56 <zong_sharo> dmwit: yup
08:36:56 <dmwit> Veinor: close =)
08:37:02 <dmwit> Veinor: Oh, you want (=<<)
08:37:09 <dmwit> ?pl \f m -> join (fmap f m)
08:37:09 <lambdabot> (=<<)
08:37:14 <dmwit> haha
08:37:23 <copumpkin> unsafeDumpBitcoinz :: ()
08:37:24 <dmwit> But, yup, (join .) . fmap
08:37:28 <copumpkin> o noes
08:37:38 <zong_sharo> dmwit: i'm not looking into full fledged polymorphic variants
08:37:39 <Axman6> zong_sharo: any reason you're using data X = X and not ()?
08:37:54 <stevenboore> hello! are 'where' and 'let' exactly the same except for the ordering of the bindings and the bound expression, or is there more to it than that? (such as slightly different semantics, performance)
08:38:15 <gwern> how sad. hawiki spam has started up again. oh well, it was a nice vacation
08:38:30 <dmwit> stevenboore: The only difference is that one is allowed in expressions (let) and the other isn't.
08:38:31 * hackagebot multiset-comb 0.2.2 - Combinatorial algorithms over multisets  http://hackage.haskell.org/package/multiset-comb-0.2.2 (BrentYorgey)
08:38:31 <Axman6> stevenboore: i think they're the same in non monadic usage. let in do expressions is a little different
08:38:42 <dafis> stevenboore: GHC compiles wheres into lets (no where in core), so no perf. difference
08:38:47 <zong_sharo> Axman6: apparently not
08:38:48 <azaq23> stevenboore: where gets translated into a let expression. Where is not a expression (unlike let) but may only be used beneath a function definition or in a case statement.
08:39:25 <stevenboore> ok, so where is part of the function syntax, not a construct in it's own right
08:39:45 <Axman6> stevenboore: you can use let to refer to variables created in a do block (the x in x <- m), which you can't do with a where clause (for various reasons, not least of which that you can use the same variable name multiple times in a do block 'without problems'
08:40:00 <zong_sharo> Axman6: it _was_ some reason for it a while ago, but not anymore, thx
08:40:38 <Axman6> no worries. using () makes it clearer they you're working with a null value, than using something that's less well known
08:42:21 <zong_sharo> so, how much of all that typeclass nonsense ghc will able to remove?
08:42:29 <zong_sharo> *will be
08:43:06 <dmwit> I don't really think GHC tries to remove typeclass nonsense.
08:43:22 <Saizan> it does try to compile away dictionary passing
08:43:26 <dmwit> Honestly, if the bulk of your computation time is spent in typeclass lookup... you must not be doing a real computation. =P
08:43:35 <quicksilver> well, it compiles typeclasses into dictionaries which are handled much like other tuples
08:43:39 <Saizan> but how much of that it can is something you should look at core to tell
08:43:45 <quicksilver> and can be inlined and optimised away using standard optimisations
08:44:19 <Saizan> i think it's more aggressive with typeclass dictionaries, actually
08:44:37 <zong_sharo> okay, here is the thing, i'm hacking on a gentoo-related code and, in gentoo pacakge dependency specification is a mess
08:44:40 <dmwit> copumpkin: bitcoin is low, now is the time to buy, not dump!
08:44:50 <Saizan> knowing that they can't be changed by plain expressions
08:45:00 <zong_sharo> it's overly complicated, and in different places different syntactic constructs can be use
08:45:03 <zong_sharo> *used
08:45:17 <zong_sharo> so, i was looking in some way to make my parser composable and modular
08:45:18 <c_wraith> GHC 7's INLINABLE pragma is used to trigger very aggressive dictionary inlining
08:45:25 <c_wraith> err, INLINEABLE
08:45:35 <c_wraith> even cross-module dictionary inlining
08:45:49 <zong_sharo> to give you an idea of how bad gentoo depspecs may be, look at this:
08:45:51 <zong_sharo> =foo/bar-22-123z-2.2.2c_pre2_p-r3*:0.2::zzz[a@,-a-,a+=,!a_=,a?(+),!a?(-)]
08:46:35 <zong_sharo> but, in some cases, it can only contain some subset of it
08:46:37 <Saizan> nice
08:46:45 <zong_sharo> so, it's kinda expression problem
08:47:33 <zong_sharo> and beacause it's a parser for a such fundamental thing as depspec, performance is counts too
08:47:37 <augur> is there any research into relation programming that doesn't involve transforming relational code into functional code?
08:48:18 <zong_sharo> so, in my paste, there is a `aM` definition, which is a rough prototype of real composed parser
08:48:32 <zong_sharo> http://paste.pocoo.org/show/451999/ -- paste
08:48:43 <zong_sharo> will ghc factor out all of dict lookups?
08:49:07 <Eelis> augur: how about prolog?
08:50:09 <augur> Eelis: hm.. logic programming is indeed what relational programming would be..
08:51:07 <augur> but prolog is definitely more oriented towards general logical programms, not combinations of relations in a way analogous to functional programming
08:51:31 <Saizan> zong_sharo: i think the way to assure such an optimization is to make anything with an (HasField Foo xs) context inlined into a context where xs is known, which i guess it's why the INLINEABLE pragma is used
08:53:14 <Saizan> heh, i've used "context" with two different meanings in the same sentence :)
08:57:52 <zong_sharo> Saizan: huh?
08:58:44 <zong_sharo> Saizan: isn't xs is always known?
08:59:40 <copumpkin> dmwit: yeah, been doing that :)
09:01:34 <Saizan> zong_sharo: by known i mean a specific concrete type, not a type variable
09:01:55 <dmwit> copumpkin: Trying to manipulate the market with your dumping advice, then? ;-)
09:02:01 <copumpkin> oh no!
09:02:08 <copumpkin> I just thought it was another example of unsafeDoSomething!
09:04:43 <zong_sharo> Saizan: okay, what kind of docs i should read to understand all this specifics?
09:07:35 * hackagebot wl-pprint-terminfo 0.1.1 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.1.1 (EdwardKmett)
09:09:01 <Saizan> zong_sharo: i don't have anything to point you to, except for the user guide on the pragmas
09:10:36 <zong_sharo> ok, thx. that's the start
09:12:26 <benmachine> yitz: since the inbuilt quasiquoting escapes just got removed, I guess someone should submit your escaping function to the libraries process; I'd do it myself but I'm kinda busy, so it wouldn't be very soon... can you take care of it?
09:21:18 <dolio> Anyone know who's in charge of code.haskell.org currently?
09:24:31 <osaunders> Anybody know anything about deductive databases?
09:30:10 <fragamus> I am using RandT with ListT but when I put in a guard I have compile problems based on the fact that ListT is not an instance of MonadPlus.  I want to have a high level conversation about the semantics of what it would mean to make RandT an instance of MonadPlus.
09:32:23 <fragamus> I mean RandT is not an instance of MonadPlus
09:32:26 <fragamus> any takers
09:32:33 <lpeterse> osaunders: you mean like prolog or datalog?
09:33:37 <edwardk> RandT is just StateT so you could just borrow StateT's implementation. not a very high level discussion ;)
09:33:56 <fragamus> ooooh cool
09:34:01 <osaunders> lpeterse: I used Prolog and didn’t find it particularly interesting. I read that Datalog is just a subset of Prolog so I don’t imagine I’d find that very interesting either. Although I’m starting to think I’ve been too brief with my assessments.
09:34:30 <edwardk> of course, whoever wrote RandT was silly and didn't actually export the constructor =(
09:35:03 <osaunders> lpeterse: I’m interested in building an environment for storing logical facts in an ontology
09:35:10 <c_wraith> edwardk: wasn't that Cale? :P
09:35:15 <lpeterse> osaunders: so what is your question then? we can go into pc, because I think this will be quite offtopic
09:35:22 <edwardk> c_wraith: cale can still be silly from time to time
09:35:35 <osaunders> lpeterse: pc?
09:35:43 <edwardk> and yeah it was cale
09:35:43 <osaunders> pm?
09:35:46 <lpeterse> osaunders: private chat
09:36:49 <frerich_> Hi! Is it possible to "define" Haskell functions at runtime? I'm toying with the idea of writing my own XMLRPC library in Haskell (as an exercise) and I'd like to expose functions offered by an XMLRPC server as "first class" functions. so that instead of doing something like "invoke "http://www.foo.com/xmlrpc.php" "add" 2 3" I can do something like "remote = ...; result = add remote 2 3".
09:37:13 <edwardk> you can use the ghc-api or something like mueval
09:37:21 <edwardk> or hsplugins or one of many other solutions like that
09:37:46 <Eduard_Munteanu> IIRC function marshalling isn't done yet.
09:37:46 <frerich_> Ah, neither of those three rings  a bell, thanks for dropping those keywords, I'll google a bit. :-)
09:37:56 <edwardk> it isn't
09:38:05 <kmc> frerich_, look at "hint"
09:38:11 <kmc> and the ones edwardk said
09:38:28 <edwardk> in particular you'd need to extend the type/kind system to know whether or not the environment of a function captures anything you can't marshal over the wire
09:38:28 <fragamus> can you direct me to where i can find StateT source code? I installed the platform on my mac, and searched for .hs files but didn't find it
09:38:38 <Eduard_Munteanu> kmc has been awakened! :P
09:38:43 <edwardk> fragamus: transformers
09:38:52 <edwardk> Control.Monad.Trans.State.Lazy
09:38:57 <fragamus> robots in disguise
09:39:30 <edwardk> transformers, monads wage their battle to destroy the evil forces of… the comonads.
09:40:06 <edwardk> arrows were like one of those late season additions to sell new toys, like the insecticons and constructicons
09:40:18 <fragamus> lol
09:40:24 <Eduard_Munteanu> Heh.
09:40:37 <edwardk> i guess that makes applicatives into go-bots
09:40:45 <Eduard_Munteanu> edwardk also has comonad transformers, mind!
09:40:55 <edwardk> the cheap knockoff that everyone had as a kid
09:41:05 <silver> comonad cotransformers
09:41:17 <edwardk> instead of lifting you can lower
09:41:24 <silver> lol
09:41:29 <edwardk> comonad transformers let you forget part of a context
09:41:36 <bscarlet> edwardk: as I recall go-bots actually came first
09:41:44 * Eduard_Munteanu thinks 'cocones' is the weirdest
09:41:48 <edwardk> silver: http://hackage.haskell.org/packages/archive/comonad-transformers/1.8.0.3/doc/html/Control-Comonad-Trans-Class.html
09:41:55 <edwardk> bscarlet: they did
09:42:02 <Eduard_Munteanu> (erm, equivalently Cocont)
09:42:05 <edwardk> Eduard_Munteanu: clearly they should just be nes
09:42:17 <Eduard_Munteanu> Yeah.
09:42:50 <edwardk> eduard: well, cocont = cont so thats boring =)
09:43:17 <edwardk> and my discont is fairly boring
09:43:41 <Eduard_Munteanu> Hrm, I don't know why somebody (you?) was working on something cocont-ish then
09:49:31 <edwardk> it was me. that is Discont in comonad-transformers
09:49:45 <edwardk> it just turns out to be boring. (a consequence of my recent series of blog posts)
09:50:07 <mike-burns> But you could have named a library "coconut"!
09:50:47 <edwardk> cocont itself is just cont, since either way you compose the adjunction (_ -> r) -| (_ -> r) you get the same thing
09:51:04 * dafis invents a structure called Jones and waits for somebody to dualize it
09:51:18 <Eduard_Munteanu> :)
09:51:29 <edwardk> but if you observe that cont is the right kan extension of a constant functor you can take the left kan extension of a constant functor and get another structure that is different than cont = cocont
09:51:36 <edwardk> and which is a comonad
09:51:40 <edwardk> but its boring =)
09:51:50 <edwardk> dafis: =)
09:52:09 <edwardk> speaking of which i need to go strip out the Discont class from comonad-transformers
09:52:16 <edwardk> well comonads-fd
09:52:44 <mike-burns> Are you also passing up naming a library "discount"?
09:52:54 <edwardk> yeah
09:53:02 <mike-burns> The "hey that word is a 'u' off from another word" potential is really high here.
09:53:20 <edwardk> i think my libraries effectively typo-squat almost everything in hackage as it is ;) no need to get greedy ;)
09:53:30 <Eduard_Munteanu> Cocont is also one letter away from coconut.
09:54:23 <byorgey> "Call now for your very own disconted cocont!  All that is missing... IS U!"
09:57:13 <bscarlet> very slighly more seriously, could someone point me somewhere to understand what comonads are good for? (Is this some sort of conewbie question?)
09:57:39 <edwardk> as soon as i get out of this meeting, yes.
09:57:54 <silver> are you at work?
09:58:03 <Eduard_Munteanu> bscarlet: this is a nice example: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
09:58:11 <edwardk> the more interesting question is when i am not =P
09:58:15 <edwardk> but yes
09:58:27 <silver> heh
09:59:18 * Eduard_Munteanu imagines edwardk giggling through the (possibly serious) meeting due to IRC conversations
09:59:35 <edwardk> has happened
09:59:50 <edwardk> actually most of the time i'm pretty focused at the office.
10:00:15 <Eduard_Munteanu> We can tell by the hackagebot floods.
10:00:58 <edwardk> little did you know that i have outsourced my hackage updates to india
10:01:08 <byorgey> hahaha
10:01:35 <edwardk> byorgey witnessed a rare manual update that threw my people into a tizzy
10:01:48 <Eduard_Munteanu> Heh.
10:02:25 * byorgey imagines some poor soul in India who is constantly making up category-theory-ish-sounding gibberish and incrementing version numbers
10:03:25 <djahandarie> It used to be me but apparently the prices are better in India
10:03:29 <byorgey> it's true, it was quite a tizzy
10:03:39 <amindfv> byorgey & edwardk: any news on a CT package paper?
10:04:14 <byorgey> amindfv: the news is that we made an outline! sort of!
10:04:35 <byorgey> where by "outline" I mean "toplogical sort + brain dump"
10:05:12 * amindfv hopes he hasn't given away the ending to the summer CT blockbuster
10:05:32 <acowley> you should use the new topSort I wrote for the ad package, it's much faster
10:05:34 <amindfv> byorgey: oh great - I'm looking forward to it
10:06:15 <bscarlet> Eduard_Munteanu: thanks, that's helpful. I think.
10:06:36 <byorgey> you mean the ending where Cont realizes it had the power of Kan extensions within itself all along?  no, you didn't give it aw-- oops
10:07:25 <byorgey> acowley: hehe, oh well, our version took about an hour
10:07:44 <amindfv> :)
10:07:59 <byorgey> acowley: however, that running time isn't so bad given that it was running on a carbon-based substrate
10:08:20 <acowley> It could've been minutes! Also, Cont realizing something about itself calls for a Hofstadter acknowledgement in the credits
10:08:27 <byorgey> haha
10:09:09 <erus`> roconnor: hows the bitcoin client coming?
10:09:23 <Eelis> chrisdone: i'm learning Lojban and may attempt to write things like data types, lexers, and parsers for it. would you recommend using your 2.5 year old Lojban package as a starting point? is there anything i should know about it before i set about expanding it?
10:10:51 <edwardk> byorgey: that and how thinly timesliced i was
10:11:21 <byorgey> edwardk: well, me too
10:11:27 <acowley> can somebody write a blog post about why Haskellers are so enthralled by bitcoin?
10:11:28 <edwardk> true that
10:12:13 <edwardk> selection bias. you have a bunch of geeks who deliberately play with one obtuse technology. odds that they'll also play with another one
10:12:16 <edwardk> ?
10:12:22 <byorgey> acowley: maybe because it appears to be an elegant technical version of something that no one understood before
10:12:23 <dainanaki> acowley: The idea of non-forgeable, unregulatable, online currency has a lot of technical challenges that make it interesting. It's also just a cool idea in general.
10:12:35 <byorgey> this is the same reason that edwardk's category theory packages are popular
10:12:58 <acowley> this is a very sophisticated usage of the word "popular," isn't it?
10:13:01 <acowley> :)
10:13:05 <chrisdone> Eelis: i wouldn't recommend it, i would replace it with whatever you write
10:13:08 <edwardk> woot i'm popular. i think my highest ranked package was like 54th or something on the listing ;)
10:13:20 <Eelis> chrisdone: ok, very well. thanks :)
10:14:07 <edwardk> i now have the pretty printer equivalent of the blink tag fully operational. fear me
10:14:29 <Eduard_Munteanu> byorgey: b-b-but you can't buy drugs with 'adjunctions' :P
10:14:31 <bscarlet> edwardk: ok
10:14:47 <byorgey> Eduard_Munteanu: adjunctions ARE drugs
10:14:55 <edwardk> Now witness the firepower of this fully ARMED and OPERATIONAL blink tag! (after installing appropriate hackage packages)
10:14:58 <Eduard_Munteanu> Oh. Makes sense.
10:15:03 <byorgey> and they're free!  Some in a technical sense!
10:15:06 <monochrom> pretty printer equivalent to blink?!
10:15:19 <edwardk> System.Console.Terminfo.PrettyPrint> displayDoc 0.8 $ fillSep $replicate 100 $ red (text "hello" <> blink (char ',')) — works fine =)
10:15:53 <bscarlet> edwardk: in emacs?
10:16:01 <chrisdone> eelis: ime piping jbofihe or camxes and parsing that is reliable enough. i tried translating the orthography PEG grammar to both parsec and frisby. the parsec one was ungodly slow (though not hand optimized) and the frisby one ran out of GHC-supported do statements before i completed it. i'd probably use pappy/happy one of those if i were implementing lexers/parsers, fwiw
10:16:14 <edwardk> bscarlet: whatever the emacs terminfo entry lets me get away with
10:16:47 <Eelis> chrisdone: all right, good to know, thanks
10:16:48 * monochrom fears edwardk's emacs skillz
10:16:56 <acowley> edwardk: this is probably a stupid question, but, why?
10:17:08 <roconnor> acowley: are Haskeller's enthralled by bitcoin?  I thought it was just 4 of us.
10:17:08 <edwardk> acowley: so i can do clang style colored diagnostics of course
10:17:29 <monochrom> clang diagnostics has blinking?!
10:17:31 <dmwit> roconnor: #haskell, like reddit and other large conglomerations, have One Mind
10:17:41 <chrisdone> edwardk: you know elisp?
10:17:44 <edwardk> acowley: and it is part of a multi-step process of converting wadler style pretty printers to be free monads, and then leverage my existing machinery on top
10:17:51 <copumpkin> epic bitcoin crash a-happenin!
10:17:53 <edwardk> chrisdone: enough to limp by
10:17:53 <copumpkin> zomg
10:17:55 <copumpkin> below 9
10:18:00 <bscarlet> edwardk: how do I try it?
10:18:09 <acowley> roconnor: I hear more about bitcoin in Haskell settings than anywhere else
10:18:11 <copumpkin> ccasin, dmwit : ZOMG!
10:18:13 <dmwit> (More seriously: I think the human mind may in fact have a cognitive bias towards treating such conglomerations as if they were internally consistent single entities.)
10:18:14 <edwardk> bscarlet; cabal install wl-pprint-terminfo
10:18:16 <chrisdone> edwardk: please write me a `show` output parser and I will pay you five cakes
10:18:25 <copumpkin> roconnor: dmwit and ccasin are also into it
10:18:26 <edwardk> hah
10:18:29 <acowley> edwardk: that's actually a noble goal. I support your garish text styling ways!
10:18:39 <Evious> I want Haskell + bitcoin unity.
10:18:45 <eyu100> =D
10:18:54 <Evious> It would give me an excuse to do more with both technologies, which I currently can't find time for :D
10:18:58 <roconnor> erus`: I've put the ripemd and the elliptic curve code into the darcs repo.  Next up is the script intepreter, then the transaction map, and finally the block "chain".
10:19:02 <Evious> I don't know -what- I'd do but it would be cool!
10:19:08 <edwardk> acowley: so i implemented a terminfo mode on top of the base pretty printers to show how this lets me extend them
10:19:10 <roconnor> erus`: that will complete the core of purecoin.
10:19:18 <eyu100> @info (>>=) :: [a] -> (a -> [b]) -> [b]
10:19:18 <lambdabot> (>>=) :: [a] -> (a -> [b]) -> [b]
10:19:22 <erus`> what is the script interpretter?
10:19:22 <edwardk> acowley: and you can use ReaderT to pass around precedence
10:19:26 <chrisdone> edwardk: it's on my todo list: https://github.com/chrisdone/haskell-emacs i want to do a nice click-and-expand inspection of record values for the REPL, a la firebug/chrome's js console
10:19:33 <edwardk> chrisdone: ah
10:20:13 <edwardk> chrisdone: i'm currently trying to figure out how to nicely print out expanded types with all of the information about where each application came from. clang diagnostics are a bit biased in that they don't deal with things like unification errors nicely
10:20:24 <roconnor> erus`: bitcoin has a simple stack programming language for verifying authetication to transfer bitcoins.
10:20:43 <roconnor> erus`: the script intepreter interprets this stack programming language.
10:20:54 <erus`> i didnt know about this
10:21:14 <edwardk> roconnor: now allyou have to do is figure out how to use it to root someone's box and steal their wallet.
10:21:30 <acowley> that's a primitive in the stack language
10:21:40 <ccasin> acowley: well, dmwit is responsible for getting me into it
10:21:45 <chrisdone> edwardk: "expanded types with all of the information about where each application came from" — example?
10:21:46 <ccasin> may just be small sample size :)
10:21:49 <edwardk> acowley: bah that takes all the fun out of it
10:21:59 <roconnor> acowley: BTW, I have 0 bitcoins to my name and I don't expect this to change anytime soon.
10:22:01 <eyu100> roconnor: where is this darcs repo?
10:22:21 <roconnor> eyu100: darcs get http://r6.ca/purecoin IIRC.
10:22:42 <edwardk> chrisdone: i'm trying to see if it is reasonable to never pretty print a constructed type, but instead show the source ranges where the applications came from and point to each variable in turn inside of it and show the range that it was instantiated to
10:22:45 <ion> I take it the stack language has a “system” command for running stuff via the shell?
10:22:55 <edwardk> chrisdone: that way i can get away with only showing pointers into your existing code
10:23:01 <Evious> roconnor, testcoins are equally cool and far more stable in value anyway.
10:23:01 <roconnor> ion: how else do you save stuff to disk? :P
10:23:06 <edwardk> @hpaste
10:23:06 <lambdabot> Haskell pastebin: http://hpaste.org/
10:23:22 <erus`> so bitcoin allows remote code execution ?
10:23:46 <Evious> Win32 users are safe because the "system" command is bugged there.
10:23:47 <roconnor> Evious: if you suggest they are stable at 0 value, I'm told that testcoins used to be bought and sold.
10:23:53 <bscarlet> edwardk: fillSep?
10:23:56 <dmwit> erus`: Of a very limited kind, yes.
10:24:02 <roconnor> erus`: nah, we are just kidding.
10:24:07 <erus`> what is the purpose again?
10:24:07 <dmwit> erus`: The bitcoin language is very limited.
10:24:23 <roconnor> erus`: to allow for multiparty authetication and whatnot.
10:24:37 <Evious> erus`, https://en.bitcoin.it/wiki/Script
10:24:41 <erus`> someone sends my client a script and i return the result?
10:24:54 <Nimatek> The computations for creating new bitcoins actually bruteforce the WLANs of the neighbours of the bitcoin creator.
10:25:06 <roconnor> erus`: athough it's primary historic use seems to have been to DOS the bitcoin clients with unnecessary computation.
10:25:20 <ion> OP_SYSTEMCOMMAND
10:25:41 <roconnor> ion: Microsoft is adding that command to their client.
10:25:45 <chrisdone> edwardk: i still don't quite get it. you mean in the REPL you might ask :t foo bar, and rather than Maybe Int, you print Maybe a + Int where Int is on line:col in file x and Maybe is in line:col in file y?
10:25:58 <Evious> Seriously though, it is a really cool idea. It allows custom, new transactions types other than the ones built into the main client (wiki has some examples) while providing a huge amount of safety.
10:26:02 <chrisdone> (or print Maybe Int but the Maybe and Int are clickable?)
10:26:16 <dmwit> erus`: No. You need not return anything.
10:26:20 <roconnor> Nimatek: I used to think bitcoin was a sophisticated poly to find SHA256 collisions, but it acutally isn't so good at that.
10:26:39 <erus`> it seems pointless to me
10:26:45 <erus`> i just read the wiki page
10:26:46 <dmwit> erus`: However, if you want to decide to accept a payment, you probably want to run the script to verify that the person has given you valid proof that you now own those bitcoin.
10:26:47 <chrisdone> Eelis: lojban's a bit like haskell, it makes you hate learning other languages…
10:26:58 <bscarlet> edwardk: nm. got it
10:27:22 <Jetbeard> after having learnt haskell, the idea of mutability scares me
10:27:23 <erus`> dmwit: just look at the confirmations?
10:27:31 <roconnor> Jetbeard: good for you
10:27:33 <Nimatek> roconnor: Even that would have been more useful than just wasting energy.
10:27:34 <dmwit> erus`: nope
10:27:37 <Eelis> chrisdone: i would never even bother trying to learn another natural language anyway :)
10:28:02 <dmwit> erus`: Confirmations are of a transaction -- not of the fact that *you*, specifically, own those bitcoin.
10:28:07 <Eduard_Munteanu> Wait until you see the Agda of natural languages :P
10:28:20 <roconnor> Nimatek: I presume bitcoins are less energy intesive than mining gold, or even printing, securing, distributing and destroying paper currency
10:28:34 <hpaste> edwardk pasted “for chrisdone” at http://hpaste.org/49823
10:28:36 <chrisdone> i've been in italy for a year and my italian sucks. i did french at school for five years and it sucks. i can speak more lojban than either of them and i only studied, as one contiguous study, for about 6 months
10:29:05 <edwardk> basically that
10:29:16 <ptd> roconnor: You can calculate how much money it costs to mine a bitcoin
10:29:21 <ptd> It's 1 btc
10:29:25 <edwardk> though i get stuck showing lots more nested ranges when the types are more complicated
10:29:26 <Nimatek> roconnor: Gold is actually useful.
10:29:28 <edwardk> which makes me sad
10:29:34 <Eelis> chrisdone: once i'm up to speed with Lojban, we should found #haskell-lojban, talk about Haskell in Lojban, and feel super-double-smug about ourselves ;)
10:29:39 <roconnor> ptd: usually it is a little less.
10:29:39 <chrisdone> edwardk: what's that output from?
10:30:04 <edwardk> chrisdone: a toy hmf implementation i'm playing with
10:30:16 <saati> ptd: that's higly dependent on where do you live (electricity cost)
10:30:28 <chrisdone> eelis: simlu lo ka traji
10:30:29 <Saizan> edwardk: miss a forall? or do you have your own rules for where to put implicit quantifiers?
10:30:47 <roconnor> Nimatek: arguablly bitcoin is useful; and it is arguablly even more useful than gold.
10:30:48 <chrisdone> edwardk: ah, cool
10:30:56 <ptd> saati: No it isn't, simply put your miner somewhere other than where you live
10:31:00 <edwardk> saizan: the forall on isId should be implicit as is the one on id.
10:31:00 <dainanaki> What do you think qualifies one to consider his or herself a good Haskell programmer?
10:31:11 <edwardk> isId was mostly a humorous name =)
10:31:26 <Evious> That's agood question, what is a good Haskell programmer?
10:31:37 <edwardk> oh yeah
10:31:38 <edwardk> i did
10:31:38 <monochrom> output qualifies "good"
10:31:40 <Evious> One that successfully avoids success at all costs?
10:31:44 <Nimatek> roconnor: I'm skeptical of the usefulness of bitcoin.
10:31:45 <chrisdone> dainanaki: have produced a few nontrivial useful projects >500 loc
10:31:52 <roconnor> Nimatek: that is fair.
10:32:17 <Evious> Nimatek, the underlying technology is cool and pretty, whether it has economic value or usefulness is an open question.
10:32:38 <acowley> shot in the dark: has anyone here implemented the Lanczos algorithm for finding eigenvectors?
10:32:46 <edwardk> i tweaked the example before pasting and obviously mucked it up a bit
10:33:02 <dainanaki> I've been thinking about the fact that I consider myself a good Haskell programmer, and it made me wonder how others classify the quality of Haskellers.
10:33:07 <roconnor> @bot
10:33:08 <lambdabot> :)
10:33:09 <ptd> Nimatek: Bitcoins are digital tokens that have properties required of money, whether that is sufficient to make them money is an open question.
10:33:21 <roconnor> edwardk: did you get that question I asked lambdabot to ask you?
10:33:27 <edwardk> nope
10:33:31 <edwardk> @messages
10:33:31 <lambdabot> You don't have any new messages.
10:33:43 <bscarlet> edwardk: xterm - yes, blink; gnome-terminal - no blink; emacs - no blink. Too bad.
10:33:51 <edwardk> ah well
10:33:57 <edwardk> probably for the best
10:33:57 <Nimatek> ptd: I'm not an economist, but would such a currency be something 'good' ?
10:33:58 * roconnor checks his logs
10:34:23 <chrisdone> dainanaki: let's see your code and we'll tell you :p
10:34:30 <roconnor> edwardk: What's the difference between Naperian functors and Representable functors (in Haskell)?
10:34:32 <ptd> Nimatek: What do you mean 'good'?
10:35:34 <edwardk> naperian was something about logarithms right?
10:35:38 <roconnor> ya
10:35:39 <Nimatek> ptd: A currency that is not inferior to the existing ones in all the things currencies must accomplish.
10:35:56 <roconnor> let me check the paper on the essence of the iterator
10:36:12 <edwardk> this looks exactly like representability
10:36:29 <Nimatek> ptd: For example, the pyramid scheme style with the limit on the number of bitcoins that can be created.
10:36:30 <edwardk> Log t is a cute name
10:37:32 <edwardk> looks like Napier just reinvented representability
10:37:37 <roconnor> ya, it says here t is a naperian functor iff t a is (naturally?) isomorphis to p -> a for some type p of positions.
10:37:46 <chrisdone> any linux users want to beta test my haskell emacs library?
10:37:56 <roconnor> edwardk: okay, cool.  Representable functors just got a lot more interesting for me. :D
10:37:57 <ptd> Nimatek: What you need to realise is that mining isn't a waste of time?
10:38:15 <chrisdone> i'm stuck in WFM territory, need to test platforms
10:38:23 <edwardk> roconnor: =)
10:38:35 <ptd> Nimatek: Mining prevents malicious agents from adding false blocks to the blockchain
10:38:36 <Eduard_Munteanu> How's this about mining? I think it is about whether to buy or mine or otherwise acquire bitcoins.
10:38:48 <clsmith> chrisdone: i would, but i don't use emacs ;p
10:38:49 <Nimatek> ptd: My question wasn't about that, but about how suitable it is, as a currency.
10:38:54 <roconnor> ptd is right.  The mining difficulty is important to prevent people from reversing transactions.
10:39:04 <Nimatek> ptd: The technical details are irrelevant to that.
10:39:24 <roconnor> Eduard_Munteanu: log t = p right?
10:39:25 <roconnor> er
10:39:27 <roconnor> sorry
10:39:30 <Eduard_Munteanu> :)
10:39:32 <bscarlet> chrisdone: what's it do?
10:39:32 <roconnor> edwardk: log t = p right?
10:39:36 <chrisdone> clsmith: i have a one-liner that lets you try it if you have emacs installed
10:39:40 <jerji> sorry for the bouncing-- should be fixed now
10:39:51 <clsmith> i see bitcoins as just a speculative bubble. they only have value because people expect them to have value
10:40:10 <ptd> Eduard_Muntenu: Do which whichever is cheaper (which should be buying because miners can claim economies of scale).
10:40:28 <clsmith> chrisdone: i don't, but i'm happy to install it and run a one-liner so long as i don't need to actually know emacs :p
10:40:41 <ptd> clsmith: s/bitcoins/dollars
10:40:50 <edwardk> roconnor: they have a deep connection to haskell adjoints as well, since given F -| G C -> Set, G is representable by F (). since we can use Hask as Set, any adjunction to Hask gives us a representable functor, but also since representable functors are isomorphic to (->) (Key p), and that has a left adjoint, all representable functors on hask are right adjoints
10:41:16 <chrisdone> bscarlet: multiple projects and clever handling of cabal projects with the REPL and such... also autocompletion and stuff. eh, it's the bizz compared to haskell-mode
10:41:19 <clsmith> ptd: no, dollars (and all other national currencies) have value because they 'represent' actual real gold.
10:41:29 <edwardk> so you get a monad and a comonad for free, etc.
10:41:34 <Eduard_Munteanu> clsmith: hm?!
10:41:42 <roconnor> edwardk: I was dismissing represenatable functors because, and this paper notes, "Naperian functors generally are equivalent to Reader monads, with the logarithm as the environment; nevertheless..."
10:41:47 <chrisdone> clsmith: awesome. git clone git://github.com/chrisdone/haskell-emacs.git  and cd into it and run emacs -Q -l examples/init.el
10:41:59 <Eelis> clsmith: even if that were true, that just changes it to s/bitcoins/gold :)
10:42:02 <edwardk> and you also get the fact that the left adjoint is a comonad because it is isomorphic to (Key f, a)
10:42:12 <ptd> clsmith: Well, they did. (it was called the gold standard)
10:42:13 <edwardk> roconnor: i'm using them heavily in my algebra package
10:42:21 <clsmith> chrisdone: alright, let me install emacs
10:42:34 <edwardk> roconnor: where they are seriously awesome =)
10:43:27 <clsmith> Eelis: yes, except i figure that bubble is far less speculative than that of bitcoin. true, it has been flawed in the past, but bitcoins are flawed (imo more) and also the protocol is slightly .. bad
10:43:44 <edwardk> in particular i define free modules as functions from a basis b to a ring k, b -> k  — which gives me the space of their contravectors, which is clearly contravariant in change of b in the sense a mathematician says and the way a computer scientist says, but then i can use a representable functor with representation b instead.
10:43:45 <Nimatek> clsmith: The dollar hasn't been tied to gold for about 40 years.
10:44:07 <edwardk> so data Complex a = Complex a a   is a functor, with representation data ComplexBasis = E | I
10:44:28 <dmwit> Bitcoin have value because people are willing to trade them for goods. Is that so hard to believe?
10:44:32 <edwardk> and i can talk about its covectors by using a linearly constrained cont, etc.
10:44:32 <roconnor> edwardk: why not just use p -> a for everything?
10:44:41 <ptd> clsmith: I think your use of 'slightly' was unwarrented
10:44:51 <edwardk> roconnor: because compose 3-4 matrices and check how fast your code is running
10:44:58 <roconnor> edwardk: ok :)
10:45:02 <edwardk> roconnor: you get no memoization
10:45:28 <roconnor> edwardk: I thought functions were easy to memoize.
10:45:29 <Eduard_Munteanu> One problem I see is whether there's any reason to acquire bitcoins in the first place.
10:45:36 <clsmith> hold on i'm being attacked by this massive wasp
10:45:43 <roconnor> edwardk: Oh, I guess it depends on the domian.
10:45:48 <edwardk> they are. i just choose to use the representation as the memoization implicitly
10:45:55 <roconnor> ok
10:45:56 <clsmith> but i'll admit my knowledge of economics is pretty bad -- especially US, since i'm british
10:46:07 <edwardk> and i can work with infinite vector spaces by using the fact that (->) e is always representable by e.
10:46:10 <chrisdone> clsmith: slap them on the nose, that's stops 'em
10:46:18 <roconnor> edwardk: So this is like venazio's quest to remove functions and replace them by coinductive data types :D
10:46:18 <benmachine> chrisdone: that's sharks
10:46:20 <clsmith> it sounds like a helicopter.
10:46:24 <edwardk> so i can get the 'always programming with (e -> k)' version as a special case.
10:46:25 <chrisdone> < _<
10:46:38 <unsafePerformIO> Is it possible to use GLSL with the Haskell OpenGL bindings?
10:46:46 <edwardk> well, i program with the function arrow in the case of covectors, where i can't memoize because i have a monad
10:46:46 <clsmith> this is a shark-sized wasp, so i'm going to give it a go.
10:46:47 <ptd> Eduard_Munteanu: That is the big problem
10:46:57 <chrisdone> benmachine: … so it's not wasps that come out of the water and bite you?
10:47:00 <edwardk> one that looks a lot like cont, but is constrained (extra-logically) to not use callCC
10:47:08 <edwardk> by linearity
10:47:09 <benmachine> chrisdone: to be fair it's not sharks that do that either very much :P
10:48:00 <benmachine> mosquitos bite, though
10:48:01 <chrisdone> true, sharks don't even live in water these days. the ocean's nice but 65 million years is enough to make anyone bored
10:48:23 <chrisdone> clsmith: did it install yet?
10:48:24 <benmachine> mosquitos are sort of like sharks I guess
10:48:26 <Eduard_Munteanu> ptd: yeah, I mean, gold and other metals had at least *some* possible use, even before modern ages, and even excluding their use as jewelry.
10:48:37 <benmachine> they both have an affinity for blood
10:48:45 <bscarlet> chrisdone: I've got it installed and doing something, but I'm not sure what.
10:48:46 <benmachine> Eduard_Munteanu: hifi cables. since antiquity.
10:48:50 <chrisdone> they can both smell blood from a hundred miles in water
10:49:11 <Eduard_Munteanu> Heh, no. But it is a noble metal.
10:49:20 <clsmith> chrisdone: yep, hold on
10:49:22 <edwardk> roconnor: anyways, that is one use i've had for representable functors
10:49:30 <edwardk> roconnor: and it seems to be paying off nicely
10:49:40 <chrisdone> bscarlet: did you run the emacs -Q stuff? by default it starts a "project" which is a REPL + a set of buffers/files that are associated with it + a cabal directory, if any
10:50:02 <roconnor> edwardk: it feels far removed from the container use of Napierian functors.
10:50:21 <ptd> Eduard_Munteanu: But gold is overpriced relative to value it would have were it not hoarded by speculators
10:50:29 <bscarlet> chrisdone: yep, did that. Got to a λ> prompt which seems to work.
10:50:42 <clsmith> chrisdone: i've been told to prepare my face.
10:50:49 <chrisdone> bscarlet: try opening a .hs file from one of your haskell projects, it should prompt which project to load it as. you can choose a new project name
10:50:57 <chrisdone> clsmith: bscarlet: perfect. it works then? the basic REPL?
10:51:00 <edwardk> brb
10:51:04 <chrisdone> good start
10:51:17 <bscarlet> chrisdone: seems to, yes.
10:51:19 <Eduard_Munteanu> ptd: hm, I don't really think so. Basically fiat currencies are going down the drain, so I think that's why.
10:51:31 <clsmith> chrisdone: yeah, seems to work
10:51:34 <chrisdone> ariiight
10:51:41 <Eduard_Munteanu> It seems like metals would be currencies of choice, were fiat money to collapse.
10:51:56 <Eduard_Munteanu> *such metals
10:52:00 * roconnor likes bitcoin 'cause he read Cryptonomicon a few years ago.
10:52:03 <clsmith> chrisdone: except i was told to prepare my face twice.
10:52:16 <clsmith> roconnor: i would love a good cryptocurrency. bitcoin is broken.
10:52:35 <roconnor> clsmith: due to lack of anonymity?
10:52:36 <tgeeky> clsmith: I don't know much about it. I presume it's flawed by design?
10:52:45 <chrisdone> clsmith: yeah that's normal. it's not intentional, but it's not indicative of a setup issue
10:52:58 <edwardk> roconnor: well, the container use is what i have representable-tries for
10:52:59 <Twey> What's wrong with Bitcoin?
10:53:15 <bscarlet> chrisdone: How many of the defaults in the init.el are necessary? Your choices are sufficiently different from mine that I find this emacs hard to use.
10:53:16 <Twey> chrisdone: I may be at work for the first day of CamHac :-\
10:53:17 <clsmith> roconnor: no, there are just certain parts of the bitcoin protocol which are vulnerable to attack
10:53:17 <chrisdone> clsmith: bscarlet: if you type in something with a type error like 1 + (), you should get an error buffer pop up and be able to hit q to close it. right?
10:53:19 <Eduard_Munteanu> What's the problem with Bitcoin and anonymity?
10:53:21 <ptd> Eduard_Munteanu: What happens to goverments ability to borrow (and thus spend) money if fiat currencies go down the drain?
10:53:28 <benmachine> Twey: laaaame
10:53:35 <clsmith> chrisdone: yes
10:53:35 <chrisdone> bscarlet: you mean the keybindings?
10:53:51 <bscarlet> chrisdone: 1 + () popup works, yes.
10:53:53 <Twey> benmachine: Yeeeah… I'll be sitting in an office coding PHP T_T
10:53:57 <roconnor> clsmith: I haven't noticed any in particular.
10:53:58 <chrisdone> cool. that doesn't work on os x when i tried it
10:54:04 <benmachine> (ps. guys #haskell-blah is a cool place to be discussing currencies, just sayin')
10:54:06 <Twey> Maybe I should open my slot :-\
10:54:08 <Eduard_Munteanu> ptd: presumably it'd decrease.
10:54:13 <bscarlet> chrisdone: it's actually the fancy complete stuff in the minibuffer that's getting me at the moment.
10:54:18 <roconnor> benmachine is right.
10:54:26 <Eduard_Munteanu> Alright.
10:54:44 <clsmith> roconnor: someone a lot better at crypto than i was talking about it. there are vulnerabilities like being able to spoof timestamps or something. i don't know if there's an analysis somewhere, i think there is
10:54:47 <bscarlet> chrisdone: were you expecting another frame or another window? I got another window.
10:54:48 <ptd> Eduard_Munteanu: Can you name any countries that have had problems borrowing money?
10:54:51 <chrisdone> bscarlet: the keybindings are just suggestions. init.el is a 'suggestion' file. everyday emacs users can have it as they like
10:54:57 <Eduard_Munteanu> Yeah, we've been having bitcoins and currencies and adjunctions and comonads discussions going in parallel a bit too much.
10:55:00 <chrisdone> bscarlet: it should be another window, yeah
10:55:09 <Eduard_Munteanu> ptd: #haskell-blah
10:55:13 <chrisdone> bscarlet: "the fancy complete stuff in the minibuffer that's getting me at the moment" — "getting you"? facny complete stuff? elaborate?
10:55:38 <clsmith> i guess #haskell-blah is the off-topic channel? :p
10:55:44 <benmachine> clsmith: precisely
10:56:03 <chrisdone> Twey: suuuuucks. but the wed/thursday perhaps you will be free?
10:56:20 <chrisdone> (and sat/sun)
10:56:45 <Twey> chrisdone: I'll have the weekend
10:56:58 <chrisdone> okies
10:57:08 <benmachine> does ghc work in wine, out of interest?
10:57:09 <Twey> But IIRC it is only one day, and I kind of feel like I should let someone have the slot who will be there for the whole thing
10:57:10 <clsmith> i sometimes wonder whether i should learn emacs. but with vim i am just sooo fast.
10:57:16 <Twey> I don't know, I might be able to get the day off
10:57:25 <chrisdone> bscarlet: the autocomplete or the completion that shows when you hit space?
10:57:27 <Twey> I'll ask someone tomorrow
10:57:32 <benmachine> Twey: I heard that the entire waiting list for camhac is going now, but I could be wrong
10:57:44 <chrisdone> Twey: cool
10:57:52 <Twey> benmachine: You mean they opened it up to everyone?
10:58:01 <benmachine> Twey: no, just enough people dropped out
10:58:07 <Twey> Oh right
10:58:10 <bscarlet> chrchrisdone: C-x C-f to open a file, in the minibuffer I get not only a the text of the path I'm working on, but also following completions in brackets. Lacking experience with whatever's driving that behaviour, it's kinda weird.
10:58:49 <chrisdone> bscarlet: ahh. that's just vanilla ido-mode. i figured most people used that. you can turn it off with M-x ido-mode
10:59:24 <djahandarie> dibblego, congrats re: book. :)
11:01:14 <bscarlet> chrisdone: when I start up I get two windows into the *Messages* buffer and a question asking for a Cabal dir in the minibuffer. Is that expected?
11:02:28 <chrisdone> bscarlet: yeah. it's starting a REPL session which prompts for some things. just to demo it. you can start more REPLs afterwards
11:03:25 <chrisdone> M-x hs-project-start — or open a .hs file and it'll prompt to associate with an existing session or let you start another associated with that file and directory
11:03:37 <chrisdone> well it seems to work fine on linux
11:03:45 <chrisdone> thanks for testing chaps
11:14:16 <chrisdone> brb
11:15:58 <chrisdone> on the macbook. man i dislike mac keyboards. makes my fingers ache
11:16:17 <chrisdone> give me Das Keyboard or give me death!
11:16:35 <kmc> chrisdone, how dare you doubt the wisdom of the great Apple
11:16:50 <kmc> your fingers are deformed or something
11:17:31 * chrisdone dumps a lovely das keyboard ontop of it
11:18:28 <chrisdone> kmc: hehe, gave me visions of the eye of mordor
11:25:16 <dainanaki> I actually quite like my Mac keyboard
11:25:41 <dainanaki> Non-chiclet keyboards are really annoying to me to type on now.
11:27:08 * chrisdone can pretty much only comfortably type on mechanical or buckling spring keyboards
11:27:13 <tromp> did you try a thinkpad keyboard?
11:27:29 <chrisdone> tromp: what key technology does it use?
11:28:04 <kmc> magic
11:28:09 <tromp> i dont know
11:28:29 <tromp> but it feels slightly better than my mac keyboard
11:29:00 <kmc> the keys are supported on little plastic nipply things
11:29:12 <kmc> they're also attached by plastic scissor things but i think those provide no resistance
11:29:30 <kmc> so i think it is basically a membrane keyboard, but a really good one
11:30:08 <kmc> that said the goodness of thinkpad keyboards is kind of a dogma beyond rational analysis to some
11:30:13 <kmc> so take it with a grain of salt
11:31:28 <chrisdone> the important factor for me for keys is the travel distance before and after the press is registered	
11:31:49 <chrisdone> a typical membrane/dome switch key resists your finger and then depresses suddenly and sharply and at that point registers and then when you release it pushes your finger away
11:32:05 * hackagebot split 0.1.4.1 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.1.4.1 (BrentYorgey)
11:32:21 <kmc> yeah that's basically how the thinkpad keyboard behaves
11:33:14 <kmc> chrisdone, why is that important to you?
11:33:40 <kmc> i like the thinkpad keyboards but i still get RSI-type pain if I use one for too long
11:33:46 <kmc> which i don't with the Kinesis Advantage
11:33:47 <chrisdone> a buckling spring or mechanical key registers half way down the distance travellable. so your finger doesn't have to strike at a hard surface, it just has to push enough for the key to register, but can go a few millimeters further if needs be without hititng a hard surface, and it's not very resistant. this means i can type on it lighter (or hard if i want) and my fingers tire less over time and i get pains less
11:34:04 <kmc> but part of that is confounded by having better posture when I'm using an external keyboard
11:34:25 <chrisdone> where do you get rsi pain?
11:34:43 <kmc> hand and the part of the arm near the hand
11:34:52 <chrisdone> ah, the wrist area
11:35:07 <chrisdone> do you rest your wrists on the desk or surface while typing?
11:35:40 <kmc> both keyboards have  a wrist area
11:35:56 <jerji> those can cause problems
11:36:57 <chrisdone> yeah, any "good posture" guide will tell you that your hands should hover over the keyboard while typing. this is what i do and i've never once had wrist or hand pain. i get finger aches (and pains if i go for too long). the idea of having hand or wrist pain is foreign to me
11:37:29 <Twey> Better than a Mac keyboard?
11:37:31 <jerji> but if you just hover without lowering your keyboard, you might end up with shoulder pain instead
11:37:39 <Twey> O.O
11:37:46 <sbrtgr> kmc: frequently pressing more than one key with one hand can cause rsi as well, especially modifier "chords"
11:37:50 <chrisdone> but it seems most people i know who complain of that kind of pain type with their wrists rested on a surface. so it's kind of funny that there're these keyboards with padded surfaces, *encouraging* you to have bad posture
11:38:03 <Twey> sbrtgr: Depends on the modifiers, I think?
11:38:06 <jerji> chrisdone: same with arm rests and ulnar nerve issues
11:39:20 <chrisdone> yeah i avoid arm rests too. i as I'm typing right now. I have arm rests either side of me, but my elbows are by my sides. afaik this is the right posture, which makes sense as i've not had arm or shoulder pain either. only finger pain, ever
11:39:56 <sbrtgr> Twey: imo, even things like C-Tab can be problematic, but you're right of course
11:40:13 * chrisdone types all two-keyed chords with two hands for that reason
11:40:16 <dolio> Igloo: ping
11:40:35 <Igloo> pong
11:40:44 <jerji> sounds pretty good to me. out of curiosity, is the angle on the inside of your elbow > 90?
11:40:51 <dolio> Are you the code.haskell.org supervisor?
11:42:14 <chrisdone> jerji: more or less 90. putting the keyboard ontop of the macbook makes a funny angle
11:42:24 <chrisdone> probably 100~
11:43:36 <Twey> sbrtgr: C-Tab is pretty awkward IMO — it requires pressing Tab at an unpleasant angle (assuming the palm is used for Ctrl)
11:43:46 <Twey> And with the weakest finger
11:43:55 <jerji> i was just wondering since it seems like the closer the elbow is to 90, the more the weight of the arm is carried by the skeleton rather than either rested on the wrist or lifted with the shoulders. my angle is pretty screwed up compared to yours, but my posture is bad. ;)
11:43:59 <chrisdone> kmc: have you tried a das keyboard or a razor keyboard (both are mechanical)? presumably you've tried a Model M
11:44:26 <Twey> I wish there were a ‘keyboard shop’ where you could try out different keyboards
11:44:30 <chrisdone> jerji: hmm, good point
11:44:57 <Igloo> dolio: No
11:44:57 <sbrtgr> Twey: somehow - ok, by geometry - the weakest fingers end up doing the heavy lifting, it's the same with musical istruments
11:45:00 <chrisdone> twey: yeah, i was looking at a razor keyboard in munich and wanted to try it out
11:45:06 * hackagebot terminfo 0.3.2 - Haskell bindings to the terminfo library.  http://hackage.haskell.org/package/terminfo-0.3.2 (JudahJacobson)
11:45:14 <Twey> Good keyboards are so expensive.  I would like to be able to compare them before deciding on one.
11:45:19 <jerji> Twey: do you have a Fry's near you?
11:45:22 <jerji> ah you mean the fancy pants ones
11:45:30 <Twey> jerji: I don't think we have those in England
11:45:31 <Twey> Yes
11:45:41 <Twey> Things like the Model M and the Das Keyboard
11:45:42 <sbrtgr> Data Hand FTW, it's only $1000+ I think
11:45:55 <jerji> jeez
11:45:56 <Twey> Data Hand looks interesting too
11:46:02 <chrisdone> FWIW Razor's keys feel just like the Das Keyboard, but yeah they're both costly
11:46:41 <dolio> Igloo: Ah, okay. Sorry. Ed thought you might be.
11:47:29 <jerji> Razer's DeathAdder mouse is pretty badass too. a lot of mice hurt my right pinky
11:47:52 <Twey> I am considering going trackball
11:48:12 <sbrtgr> geekhack.org is a great resource regarding mechanical keyboards
11:48:57 <chrisdone> yeah my friend uses trackball. i wouldn't mind one of them. the awkwardness of the mouse (not accurately able to use on your lap for example) is a pain
11:49:05 <jerji> there was a guy at my last job who moused with his feet always
11:49:13 <jerji> he just got sick of mouse-related RSI
11:49:14 <chrisdone> haha, awesome
11:50:37 <Twey> chrisdone: Yeah, plus trackballs give you much more accuracy and you don't have to lift the device up when you get to the edge of your mousing range
11:50:42 <acowley> Use a Kinect and point using your whole arm
11:50:49 * roconnor uses a thumb based trackball
11:50:56 <chrisdone> i used this model m for a year: http://www.youtube.com/watch?v=eOJQU5UgvJk  not as soft as previous model m's i've used, but looked pretty
11:51:24 <chrisdone> twey: that's a good point. the range point is cumbersome
11:53:00 <scottj> Twey: find a place with good return policy and you can try out the expensive ones for ~$20 (usa)
11:53:29 <chrisdone> i might bring my das to camhac :p
11:53:37 <chrisdone> a week of typing on a laptop keyboard... ew
11:54:20 <chrisdone> twey: a php job? ;_;
11:54:42 <sbrtgr> chrisdone: maybe a nice excuse to get a tenkeyless? ;)
11:55:48 <chrisdone> sbrgrrgdf: what's one of those?
11:56:18 <sbrtgr> chrisdone: regular keyboard without the number pad. good mechanical ones available from filco and other companies
11:57:03 <chrisdone> ahh nice one. i'd love a keyboard without numpad
11:57:41 <scottj> buy a laptop
11:57:52 <chrisdone> scottj: did you read the above?
11:58:15 <scottj> chrisdone: nope. buy a hhkb
11:58:19 <sbrtgr> chrisdone: then there are group buys on forums like geekhack for Asia-only keyboards that are *very* slick...
11:58:56 <sbrtgr> chrisdone: (similar to hhkb but cheaper and less different)
11:59:39 <chrisdone> yeah i was looking at the happy hacking keyboard one before you mentioned tenkeyless. that's a nice keyboard
11:59:42 <scottj> anyone remember the keyboard design that was like hhkb but more modern/mac looking that took preorders a coiuple years ago but ended up canceling bc of manufacturing?
12:01:26 <chrisdone> funny thing about the Das is when programmers come over to my desk and go to type something, look down and go "oh shit". they can still type, but it throws them off
12:02:54 <scottj> you can get whoopie cushions for $1
12:02:56 <bscarlet> I'm using a kinesis freestyle (http://www.kinesis-ergo.com/images/freestyle-solo_690x375.jpg) into which I've splices a couple extra meters of cable between the halves, which allows me to put them on trays mounted by the sides of a hacked (copy of a) Le Corbusier recliner. (http://purecontemporary.blogs.com/photos/uncategorized/le_corbusier_recliner_1.jpg). My monitors are mounted on swing arms over my knees.
12:04:08 <kmc> nice bscarlet!
12:04:12 <sbrtgr> chrisdone: Leopold tenkeyless is nice as well
12:04:30 <scottj> bscarlet: another use of kinesis freestyle http://www.flickr.com/photos/technomancy/4397554484/
12:04:37 <sbrtgr> bscarlet: Recliner... yes!
12:05:04 <kmc> 'Tenkeyless Tactile Touch "Otaku" Keyboard'
12:05:11 <kmc> not buying anything with "Otaku" in the name, thanx
12:05:21 <kmc> (i think that's what they call the "no labels" version?)
12:05:29 <sbrtgr> kmc: no no that's just one model
12:05:34 <kmc> chrisdone, yeah, I used a Model M for a while
12:05:42 <chrisdone> bscarlett: haha, that's awesome
12:05:58 <kmc> it was pretty good but I still eventually got wrist pain
12:06:12 <chrisdone> sucks. gotta do the hovering man
12:06:13 <bscarlet> scottj: awesome! (but bad for the elbows. Better to rotate them a little like a standard ergo keyboard. Also, easier to walk if my splicing trick is added)
12:06:36 <kmc> Model M etc. still have a traditional layout
12:06:37 <ion> I’d love one of these <http://www.datahand.com/products/proii.htm> but they are insanely expensive.
12:06:59 <bscarlet> side effect: I can't code when too tired, 'cause I fall asleep instead.
12:07:07 <kmc> one of the best features of the Kinesis Advantage is that it puts space, enter, backspace, modifiers, etc. under the thumbs
12:07:18 <ion> http://www.youtube.com/watch?v=_rzFqEqzhmA
12:07:27 <chrisdone> i left my model M in england in my parents' attic. I kinda miss it. lovely typing experience
12:07:29 <kmc> and arrow keys easy to reach with the right hand
12:07:53 <chrisdone> yeah modifiers in the centre makes sense
12:07:59 <kmc> it's probably too much to fix in software on a regular layout
12:08:08 <kmc> although repurposing CapsLock is still essential
12:08:12 <chrisdone> all programming keys seem to be on the right near Return on a standard 104/105-key US layout
12:08:29 <kmc> chrisdone, what layout do you use?
12:08:31 <luite> which laptops have the best keyboard these days?
12:08:37 <chrisdone> presently US layout
12:08:55 <hpaste> “Ian Duncan” pasted “Hint & Typeable” at http://hpaste.org/49824
12:08:59 <chrisdone> qwerty
12:08:59 <bscarlet> luite: see scottj's link, above.
12:09:13 <sbrtgr> kmc: (commercial, I have no financial interests) here are all the leopold tenkeyless-es http://elitekeyboards.com/products.php?sub=leopold,tenkeyless
12:09:27 <dainanaki> Could someone help me figure out what's wrong with the Hint & Typeable example just pasted?
12:09:27 <kmc> yeah i saw that page
12:09:33 <kmc> dainanaki, what goes wrong with it?
12:09:37 <ion> I used to switch between the Fi layout (for typing Finnish text) and the US layout (for everything else) but then i switched to the US Intl. (AltGr dead keys) layout which lets me type ä and ö with altgr-q and altgr-p.
12:09:49 <dainanaki> It's saying that I need an instance declaration for Data.Typeable.Typeable for Args
12:09:51 <chrisdone> dainanaki: behaviour expected/got?
12:09:52 <scottj> luite: ppl normally say thinkpad or mbp
12:09:55 <chrisdone> ah
12:10:00 <dainanaki> but I derived it, so I don't see what's wrong.
12:10:04 <kmc> dainanaki, did you import Typeable in that module?
12:10:11 <dainanaki> I tried with and without.
12:10:13 <kmc> usually deriving fails unless that class is in scope
12:10:35 <chrisdone> I was gonna say the same, usually have to import afaik
12:10:51 <dainanaki> Well, I just added the import back in, still no luck.
12:10:56 * kmc uses dvorak with a Compose key for diacritic marks, math, etc
12:11:13 <luite> scottj: hmm, yeah I already had two thinkpads that died just out of warranty so I don't really want to buy another one
12:11:16 <ion> The compose key ftw.
12:11:24 <kmc> i think i'd only need AltGr if I typed those letters very frequently
12:11:33 <chrisdone> Compos key<3 (if i wasn't on a mac that'd be a unicode heart)
12:11:40 <kmc> ♥
12:11:45 <luite> have never typed on a mbp though, I kind of like the trackpoint so I'm probably going to miss that
12:12:09 <kmc> alias asdf='setxkbmap -layout dvorak'; alias aoeu='setxkbmap -layout us'
12:12:10 <hpaste> dainanaki annotated “Hint & Typeable” with “Hint & Typeable (annotation)” at http://hpaste.org/49824#a49825
12:12:27 <dainanaki> it looks like this now, but still not working.
12:12:34 <scottj> luite: dell latitudes used to have a trackpoint that was even better than thinkpad one since you could press it down to click
12:12:37 <kmc> can you paste the actual error messag?
12:12:56 <chrisdone> 'tis a weird error
12:13:12 * hackagebot wl-pprint-terminfo 0.2.0 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.2.0 (EdwardKmett)
12:13:52 <luite> scottj: hmm, I had a latitude before the two thinkpads  (but it was stolen), but its keyboard was a bit worse, and I liked the trackpoint on the thinkpads better
12:14:13 <luite> but that might just have been because of the rubber trackpoint cap
12:14:21 <luite> the dell only had the pointy one
12:14:35 <luite> the thinkpads also have a flat one an a hollow one
12:14:39 <luite> I like the hollow one best
12:14:53 <luite> well, concave actually
12:15:06 <hpaste> dainanaki pasted “Hint & Typeable Error” at http://hpaste.org/49826
12:15:09 <chrisdone> heh, a hollow one would be like a short straw
12:15:32 <scottj> chrisdone: it's pretty useful on the camelback thinkpad
12:15:34 <luite> I used a too literal translation from the dutch word without thinking :p
12:15:37 <chrisdone> oh
12:15:51 <chrisdone> dainanaki: you're missing LANGUAGE from that file
12:15:59 <dainanaki> Oh, derp
12:16:04 <chrisdone> what compiler is this that doesn't warn that you can't derive Typeable? O_o
12:16:10 <zhulikas> http://pastebin.com/dNFbQ3Sf it doesn't compile. I try to compile with "ghc tutorial.hs -XScopedTypeVariables" and it gives me an error "tutorial.hs:21:2: Not in scope: type variable `people'"
12:16:12 <dainanaki> GHC
12:16:13 <mauke> The paste dNFbQ3Sf has been copied to http://hpaste.org/49827
12:16:14 <dainanaki> yikes.
12:16:32 <zhulikas> any help would be appreciated, I am just starting to learn Haskell. This is the tutorial I use: http://lisperati.com/haskell/ht2.html
12:16:38 <danharaj> sometimes I have to marvel at how easy it is to refactor Haskell code.
12:17:12 <danharaj> I just mutilated a few hundred lines of code and it took 5 minutes to get the type errors to go away, and when they did, everything worked fine.
12:17:14 <chrisdone> zhulikas: you just need to indent line 21 to be in the same column as line 20
12:17:15 <dafis> zhulikas: looks like indentation is wrong
12:17:22 <chrisdone> probably gotta disable tab characters in your editor
12:17:35 <zhulikas> ohh, I didn't know that Haskell could complain about indentation
12:17:48 <dafis> always a good advice, chrisdone
12:17:51 <chrisdone> danharaj: yeah i love that. I have no fear when refactoring haskell code
12:17:52 <zhulikas> ok then, thanks
12:18:08 <luite> hmm, how do you disable tabs in emacs?
12:18:16 <chrisdone> er...
12:18:38 <luite> all my indenting things use spaces, but I sometimes get tabs when copy/pasting some text
12:18:46 <zhulikas> still complains...
12:18:46 <chrisdone> (setq-default indent-tabs-mode nil)
12:18:48 <luite> untabify works
12:19:00 <dainanaki> OK, something weird is going on. GHC is totally ignoring my pragmas...
12:19:03 <chrisdone> oh, when pasting. that's a different story altogether
12:19:07 <zhulikas> so should I use spaces instead of tabs?
12:19:16 <chrisdone> yeah
12:19:16 <dafis> zhulikas: yes!
12:19:21 <zhulikas> that's just wrong...
12:19:32 <dafis> tabs are eevil
12:19:45 <danharaj> GHC interprets tabs as 8 spaces
12:19:48 <zhulikas> tapping space is evil
12:19:53 <chrisdone> dainanaki: what pragmas are you writing verbatim?
12:20:10 <dainanaki> {-# LANGUAGE DeriveDataTypeable #-}
12:20:16 <dafis> zhulikas: configure your editor to insert k spaces when you type tab
12:20:19 <chrisdone> zhulikas: you just use an editor which does indentation for you. no haskellers (sensible ones) tap space out
12:20:23 <dainanaki> Either that's wrong, which should tell me, or it's ignoring it.
12:20:36 <danharaj> chrisdone: I do. Then again my editor auto-converts tabs to 4 spaces.
12:20:38 <dainanaki> Either way, the behavior is wrong.
12:20:43 <chrisdone> dainanaki: try with DerivePotatoes
12:21:04 <chrisdone> does it warn? it should
12:21:05 <dainanaki> I already tried DeriveFart, not even a warning with -Wall
12:21:06 <danharaj> Language pragmas don't get ignored. If you give it a language pragma ghc doesn't understand, you'll get an error.
12:21:11 <danharaj> That's strange.
12:21:12 <chrisdone> interesting
12:21:16 <burbul> zhulikas: I'm pretty new to Haskell too. Can I recommend the Leksah editor? It's fantastic... every time you leave it alone for a few seconds it compiles and puts little squiggly underlines under all your errors.
12:21:27 <zhulikas> well, right now I am using gEdit... so I guess first thing would be to get a decent editor...
12:21:43 <dainanaki> ah, never mind guys.
12:21:46 <chrisdone> danharaj: what about if you swap line 1 and line 2 so that it's the first line in the file?
12:21:55 <dafis> danharaj: no error, because other compilers could know it
12:21:55 <dainanaki> I'm having a really bad day for stupid errors.
12:21:55 <danharaj> chrisdone: I dunno.
12:22:04 <chrisdone> er, dainanaki. bah. tab completion isn't working, i have to type every name out
12:22:14 <burbul> I'm pretty sure I'm working at least twice as fast with Leksah as I would be without
12:22:16 <danharaj> dafis: I just tried it. GHC gives you an error. Unsupported extonsion: Blahblahblah.
12:22:30 <zhulikas> yay, an IDE. Thanks, burbul
12:22:36 <burbul> You're welcome
12:22:44 <ion> Haha. I just thought of use for RState.
12:22:56 <danharaj> ion: making Haskell look crazy?
12:23:08 <dainanaki> It turns out it was in issue with moving the file to a different dir and saving the modification to the original location.
12:23:16 <hpaste> ion pasted “foo” at http://hpaste.org/49828
12:23:20 <dafis> danharaj: oh, right, it knows the LANGUAGE pragma, but not the (made-up) extension
12:23:51 <chrisdone> <mishoo> .. and the reason is ? there wasn't any! :) <chrisdone> :D <mishoo> the das keyboard rules.  thanks again fellows!
12:24:05 <chrisdone> (at work we bought him a Das Keyboard as a gift)
12:24:29 <chrisdone> ah, i didn't paste the important line: "funny, I just realize that I wasn't thinking much about wrist pain lately.."
12:24:31 <ion> Someone here was asking about generation of strings between AAA-0000 and ZZZ-9999 yesterday. I used State to convert a number between 0 and (length ['A'..'Z'] ^ 3 * length ['0'..'9'] ^ 4 - 1) to the string. Just one problem: 1 gives BAA-0000 instead of AAA-0001.
12:24:42 <ion> So, switch State to RState and it magically works. ;-)
12:25:12 <ion> See the paste above.
12:25:37 <danharaj> Now I want a Das Keyboard.
12:25:46 <danharaj> If only so I can talk about it to my friends in a German accent.
12:26:03 <thoughtpolice> they're pretty nice
12:26:14 <thoughtpolice> i'm thinking of getting one and a new machine, but i'm really questioning if i want to get an awesome desktop
12:26:18 <thoughtpolice> guess i should if i want bitcoins :P
12:26:47 <mokus> I really like the Das Keyboard, got my employer to get me one at work and i've wanted one at home ever since
12:26:48 * chrisdone takes his Das Keyboard to work and back every day in his bag ... should buy another one
12:26:48 <zong_sharo> danharaj: have you considered capacitive keyboards?
12:26:55 <zong_sharo> danharaj: HHK for example?
12:27:00 <danharaj> I have not considered keyboards in general.
12:27:01 <ion> Do they give tactile feedback?
12:27:11 <zong_sharo> ion: sure they do
12:27:13 <chrisdone> ion: sure. and audio
12:27:41 <zong_sharo> no, it's not that capacitive switches
12:28:00 <scottj> thoughtpolice: btc mining? with drop from 30+ to 9 I'd think it's oversaturated and price of godoGPU's has gone up a lot
12:28:04 <zong_sharo> https://secure.wikimedia.org/wikipedia/en/wiki/Happy_Hacking_Keyboard -- this one
12:28:05 <chrisdone> you can tell when a press is registered because there's a click about half way through one full compression. so you don't have to compress the key all the way, just enough for the click
12:28:28 <thoughtpolice> scottj: i'm just joking. :P either way i thought the current exchange was something like 13 or 14 USD?
12:28:29 <zong_sharo> pretty much the best keyboard switches ever
12:28:31 <thoughtpolice> or has it gone down
12:28:41 <thoughtpolice> it was 33 in its prime in like april
12:29:09 <chrisdone> I wanna try a happy hacking keyboard
12:29:55 <zong_sharo> chrisdone: wery nice feel, even better than cherry's
12:30:13 <scottj> thoughtpolice: june not april.
12:30:26 <zong_sharo> and if you want more keys than hhk provides - realforce does full sized ones
12:31:32 <scottj> the biggest problem with hhkb imo is not having dedicated row for f# keys
12:31:48 <zong_sharo> scottj: http://elitekeyboards.com/products.php?sub=topre_keyboards,rftenkeyless&pid=rf_se05c0
12:31:56 <frerich_> Is it possible to have something like "f x" or "g x" translate into code which does something like "print f" or "print g"? I'm trying to write a Haskell library which can talk to XMLRPC services, but I don't know the available methods in advance. The best thing I can do is to allow random functions and let them fail at runtime in case the server tells me that they are not available.
12:32:27 <zong_sharo> scottj: will cost you an arm and a leg, but worth it
12:32:37 <scottj> zong_sharo: yeah biggest pro of hhkb is the RET key is as far right as it goes :)
12:33:25 * sbrtgr desires a KBC Poker with Cherry MX Reds, a Kinesis Advantage, and the DIY chops to saw the KA in half...
12:33:34 <chrisdone> frerich_: are you writing an RPC service or client?
12:33:39 <frerich_> In Python, one can do this by reimplementing __getattr__, is there something similiar for Haskell? A generic 'fallback' function.
12:33:59 <frerich_> chrisdone: Yeah, I'm trying to write my own XMLRPC library (I know there are existing libraries, I'm u sing this as an exercise).
12:34:12 <chrisdone> o_o
12:34:19 <Cale> frerich_: Have you seen haxr?
12:34:23 <zong_sharo> frerich_: default class functions implementation ?
12:34:35 <Cale> http://hackage.haskell.org/package/haxr-3000.8.2
12:34:42 <frerich_> Cale: Yes, but haxr basically passes the function to call as a string, like "remote url "doThis".
12:35:00 <frerich_> I wonder whether this can be improved, to make the API look like native Haskell code - much like it is possible in Python.
12:35:33 <frerich_> I asked something similiar some time ago here and was pointed to hint and mueval - which apparently allow me to define functions at runtime - not bad, if the XMLRPC server supports introspection.
12:36:01 <chrisdone> do you need to define functions at runtime?
12:36:08 <frerich_> I googled a bit and found "quasi quoters" which seemed remotely interesting, but I'm not sure whether it's applicable.
12:36:27 <chrisdone> I use quasi quoters for an RPC service, but it may be different to yours
12:36:48 <frerich_> chrisdone: Well - *if* the XMLRPC server I'm talking to supports introspection, I could use that to enumerate the available functions and then define them at runtime using ghc-api
12:37:01 <chrisdone> controller "foobar" [| do x <- getParam "x"; success "yay" |]
12:37:03 <frerich_> chrisdone: However, I wonder whether I can have a similiar effect without knowing the valid methods in advance.
12:37:17 <chrisdone> that's how I define my RPC methods ^
12:37:24 <chrisdone> ah, sure
12:37:25 <frerich_> chrisdone: Hmm interesting, so maybe quasi quoters are more relevant than I thought.
12:37:39 * frerich_ didn't really understand them yet
12:37:40 <MHD> I think I might have made the syntactic description language equivalent of Haskell...
12:38:06 <Cale> frerich_: Well, you can define them at runtime using the ghc-api, but that doesn't really buy you a whole lot, unless you know the result of the enumeration to begin with.
12:38:12 <chrisdone> it basically adds it to a compile-time list of ("name",function) and then by runtime the list is populated
12:38:26 <Cale> (how can your program know that it wants to call something that it doesn't know exists at compile time?)
12:39:22 <frerich_> Cale: Yes, I was told about the ghc-api approach already, but indeed - it doesn't solve all cases. It's perfectly possible to write a program which connects to some XMLRPC service whose address is only specified at runtime (say, a command line argument) and which then attempts to call various functions on that service.
12:39:48 <Cale> Okay, yeah I suppose that's possible.
12:39:51 <frerich_> I wonder whether this program could call those functions without using strings but rather "real" Haskell functions, which are translated to XMLRPC requests at runtime.
12:40:22 <chrisdone> i'm not sure that makes sense..
12:40:24 <Cale> If they're really real Haskell functions, they'll have to have types. What types will they have?
12:40:42 <chrisdone> you mean you connect to an RPC service, receive some kind of method list, generate a bunch of functions of the same name, and then use those functions?
12:40:52 <frerich_> Cale: Okay, they are not that real then. Pseudo-functions. This is basically just a matter of syntax.
12:41:10 <frerich_> chrisdone: Yes, that's the "simple" case. If I can enumerate the available functions, I can use ghc-api to register them.
12:41:51 <chrisdone> but what code would use the functions if they're completely arbitrary?
12:41:58 <Cale> frerich_: I'm not sure I understand what you mean by register. It's still a compile-time error to refer to a name which isn't in scope.
12:42:16 <edwardk> preflex: xseen jaspervdj
12:42:16 <preflex>  jaspervdj was last seen on freenode/#haskell 18 days, 12 hours, 36 minutes and 49 seconds ago, saying: Jafet: it has some good uses though. E.g., I disable orphan instances warnings in my testing code, so I can declare Arbitrary instances there
12:42:28 <frerich_> Cale: Yeah, I guess I want to have the syntax of ordinary Haskell functions, but not more. I cannot have real functions since I don't know their types.
12:42:38 <frerich_> I guess that's one reason why it's easy to do this in languages like Python.
12:42:55 <Cale> You can start up an interpreter session in which they get loaded, but then you have to put code into that interpreter session to do anything with those functions, and you end up putting the rest of your code into string format.
12:43:28 <danharaj> Could you perhaps use a dictionary of dynamic values and cast them when you want to use themL
12:43:30 <danharaj> ?*
12:43:30 <lambdabot> Maybe you meant: . ? @ v
12:43:57 <Cale> Well, it's a fundamentally dangerous thing to do, because you can't know for sure that you'll be getting any individual function from the enumeration service, so calling anything at all which isn't statically part of your program is bad.
12:44:07 <frerich_> Right now, my hope are these magic "quasi quoters" which seem like they combine the dynamic behaviour I want with the non-string syntax.
12:44:22 <frerich_> Cale: Sure, it may cause errors because the function is not available, or because the function does someting else than you think.
12:44:43 <Cale> Also, what if you typo one of the names of the functions in your own code. Presumably you don't want the compiler to think "oh, that might turn out to be an XML-RPC call at runtime, I'd better not complain."
12:45:21 <dolio> Cale: That's the essence of independent compilation, clearly.
12:45:32 <dolio> No compile-time errors whatsoever. :)
12:45:32 <danharaj> does the GHC RTS allow you to load modules and link modules at run-time?
12:45:45 <frerich_> Cale: Right. I guess I'm mainly looking for nicer syntax for strings. For example, see the Python code at http://docs.python.org/release/2.5.2/lib/xmlrpc-client-example.html
12:45:55 <kmc> danharaj, yeah -- GHCi does it
12:46:04 <frerich_> Cale: Note how they can do "    print server.examples.getStateName(41)" without even knowing that the XMLRPC service 'server' exposes an 'example.getStateName' method.
12:46:06 <kmc> 'plugins' has that capability
12:46:17 * hackagebot intern 0.3.0 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.3.0 (EdwardKmett)
12:46:18 <danharaj> so is there a way to refer to a module at compile time, and then have that module loaded at run-time?
12:46:22 <frerich_> Cale: you can call arbitrary functions and it's dynamically translated to XMLRPC requests - which may work, or not.
12:46:40 <Cale> frerich_: I don't think I like that.
12:47:24 <Cale> Though, python already has a lot of the problems which that poses to begin with, so I guess it doesn't make python much worse than it already is to allow it.
12:48:41 <frerich_> Cale: Definately. I just wonder whether it's possible to achieve this "tight" integration into the language grammer if one is willing to accept certain costs (like, no compile time type checks)
12:49:02 <frerich_> There are so many Haskell extensions, I thought - maybe one of them does that. :-}
12:49:09 <Cale> Probably not. You can't very well remove typechecking from Haskell. It's extremely fundamental.
12:49:15 <Cale> (think about how typeclasses work)
12:49:27 <danharaj> That's not an extension, that a lobotomy.
12:49:30 * danharaj zing
12:49:35 <frerich_> :-)
12:49:38 <Cale> Which code you're running, a lot of the time, depends on what type something is.
12:49:39 <sbrtgr> Cale: what's so wrong with doing runtime type checking?
12:50:32 <Cale> Runtime types aren't really types :P
12:50:57 <sbrtgr> semantics
12:51:02 <Cale> exactly
12:51:07 <frerich_> Cale: Yes, I can see that it very much conflicts with a static type system. I just wonder whether it's possible to relax this a bit, for some code section. Basically a DSL which happens to look like Haskell as far as the syntax is concerned.
12:51:42 <danharaj> frerich_: You can use the foreign function interface to let Python handle it, and the wrap the results before reentering Haskell land.
12:51:50 <MHD> Is there some site where one can publish non-serious papers, perhaps like DeviantART?
12:52:00 <danharaj> MHD: Your blog.
12:52:04 <Cale> frerich_: You could just write some operators which work with strings.
12:52:22 <sbrtgr> Cale: the service provider can be queried for it's interface dynamically, the calling code can run in a monadic context that provides all the safety one needs
12:52:31 <MHD> danharaj: Oh, right. Only I don't have the money to add storage to my domain...
12:52:37 <MHD> danharaj: :)
12:53:31 <chrisdone> frerich_: can you connect to the RPC service at compile time or is the particular service only known at runtime?
12:53:43 <frerich_> chrisdone: Only at runtime
12:54:06 <chrisdone> tch
12:54:10 <kmc> MHD, get a free blogger account
12:54:21 <MHD> kmc: yeah...
12:54:35 <chrisdone> frerich_: FWIW you can always do something along the lines of
12:54:40 <tgeeky> >> i assume 'the catsters' on youtube is considered a wonderful source of cat theory?
12:54:43 <tgeeky> i've heard it mentioned
12:55:02 <Cale> tgeeky: yes
12:55:09 <Cale> tgeeky: bits and pieces though
12:55:11 <parcs> looks like hlint (haskell-src-exts?) still fails at parsing the new QQ syntax :/
12:55:22 <tgeeky> Cale: bits and pieces are useful, or bits and pieces are not?
12:55:31 <Cale> Very useful and motivating
12:55:35 <tgeeky> ok
12:55:39 <Cale> but you'll ultimately want more
12:55:44 <danharaj> would be better if the videos featured cats
12:55:46 <chrisdone> frerich_: actually no. i was gonna suggest you have an object whose fields represent methods of the RPC but then you'd need to have some idea of what you want from the service, even if some functions aren't available
12:57:22 * hackagebot wl-pprint-terminfo 0.2.1 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.2.1 (EdwardKmett)
12:57:26 <tgeeky> also, anyone if there exists / the name of a video associated with dons' paper about writing unix shell code in haskell?
12:57:28 <chrisdone> do Emailer{..} <- Emailer <$> method "sendDistrib" <*> method "sendSingle" <*> method "inboxCount"; emailerSendSingle "chrisdone@gmail.com" "Hello!"
12:58:03 <dpratt71> all I know about Category Theory I learned in Cale-garten
12:58:04 <chrisdone> somehting like this would work. you can just set the methods to be error "Unimplemented method " ++ methodName, if they don't exist in the RPC schema
12:58:32 <chrisdone> you have to specify what functions you want to use up front, but they can not-exist, at least. does that fit your requirement?
12:59:09 <XniX23> I read now that haskell is good for writing compilers... why is that?
12:59:20 <chrisdone> types and pattern matching
13:00:29 <chrisdone> frerich_: no?
13:00:37 <XniX23> chrisdone: any other field where it stands up? :)
13:01:22 <chrisdone> any field where you need to be able to refactor and maintain and have other people work on
13:01:51 <frerich_> chrisdone: I think that's an interesting idea, I didn't consider looking for a solution to that problem.
13:02:04 <sbrtgr> (haskell-mode) hm, went back to ubuntu, C-c C-b works, but C-c C-l just hangs
13:02:33 <kmc> XniX23, http://www.haskell.org/haskellwiki/Haskell_in_industry
13:02:42 <edwardk> what is the current nice iteratee library?
13:02:46 <frerich_> chrisdone: However, you still have to pass method names as strings around - which is as good as a generic 'invoke remote "getCount"'. Instead, I'd like to be able to just say something like "getCount remote" so that it's hidden that 'getCount'; is not a real Haskell function.
13:03:02 <kmc> XniX23, it's not just compilers; anything that involves either implementing a new language or analyzing code in an existing language
13:03:05 <roconnor> edwardk: not the Enumertee library
13:03:11 <roconnor> or whatever it was called
13:03:25 <edwardk> roconnor: yeah i ruled it out when it lacked the cps transform, and so had inefficient left binds
13:03:28 <roconnor> edwardk: It's the only one I've used and it was almost, but not quite nice.
13:03:44 <roconnor> edwardk: pfft, just codensity it
13:03:48 <kmc> XniX23, a lot of problems are nicely solved by having a small team implement a domain-specific language for use by a large number of problem experts, who may not be programmers
13:03:51 <edwardk> =P
13:03:54 <chrisdone> frerich_: well that's what my example was about... you only specify the string once. then you get a real . haskell function, in this example emailerSendSingle
13:03:54 <kmc> e.g. the financial derivatives modeling languages
13:04:04 <kmc> implemented in Haskell for use by finance / applied math people
13:04:17 <edwardk> well, i need the history, so i violate iteratee space invariants
13:04:36 <edwardk> basically looking for a nice design to rebuild my trifecta talk plumbing on top of
13:04:44 <edwardk> guess i'll just implement it straight
13:05:01 <roconnor> @wn trifecta
13:05:02 <lambdabot> No match for "trifecta".
13:05:10 <chrisdone> frerich_: so like do counter <- Counter <$> method "getCount" <*> method "anotherMethod"; return counter; now counter is the object that represents the RPC. you can run: getCount counter (like counter.getCounter in an OO language)
13:05:20 <frerich_> chrisdone: Aaah!
13:05:34 <roconnor> chrisdone: oh god
13:05:51 <chrisdone> roconner: I prefer "the almighty" :p
13:06:18 <frerich_> chrisdone: Maybe one could use some sort of template haskell or so to generate these functions automagically?
13:06:20 <roconnor> chrisdone: I can't tell if I'm impressed or horrified.
13:06:28 <chrisdone> hahaha
13:06:31 <edwardk> http://comonad.com/reader/wp-content/uploads/2009/08/A-Parsing-Trifecta.pdf
13:07:05 <edwardk> http://en.wikipedia.org/wiki/Trifecta in the hat trick sense
13:07:16 <chrisdone> frerich_: ah you mean to get the RPC object? sure.
13:08:04 <XniX23> kmc: so they build a language in haskell for them to use?
13:08:06 <roconnor> What's wrong with parsing context-sensitively?
13:08:13 <kmc> XniX23, yes
13:08:13 <roconnor> ;(
13:08:31 <kmc> XniX23, sometimes an "embedded language", i.e. a Haskell library which feels like a new language
13:08:37 <kmc> a common example of that is Parsec
13:08:37 <XniX23> kmc: isn't it easier to write a program?
13:08:41 <copumpkin> roconnor: I can't enumerate ur stringz
13:08:58 <chrisdone> frerich_: could end up with something like: defRPC "Counter" ["getCount","anotherMethod"]; myFunc = do counter <- getCounter; c <- getCount counter; print c
13:09:04 <edwardk> roconnor: re the talk?
13:09:07 <kmc> it's an ordinary Haskell library defining ordinary functions, but it feels like a domain-specific parser language
13:09:12 <XniX23> kmc: embedded language is one that looks different but in background uses lets say haskell?
13:09:13 <edwardk> roconnor: hard to split into chunks
13:09:13 <kmc> XniX23, ? it's all writing programs
13:09:16 <roconnor> last week I learned that regular languages are an inital model of kleene algebras.
13:09:41 <chrisdone> frerich_: first part being some declaration elsewhere, second part being to acquire the RPC object and use it
13:09:51 <XniX23> kmc: yeah sorry, i meant window application
13:09:55 <kmc> ?
13:09:55 <edwardk> roconnor: what i do these days is usually pick some visibly pushdown language for dealing with my parens, etc. then try to find nice structures i can parse inside those
13:09:59 <kmc> still don't get it
13:10:26 <edwardk> roconnor: but the monoid structure is the leg of this three legged stool that i'm omitting today.
13:10:37 <chrisdone> woops
13:10:40 <edwardk> roconnor: i just want the slicing machinery
13:11:21 <kmc> XniX23, you mean, why describe (say) financial contracts in a programming language rather than some point-and-click GUI?
13:11:35 <XniX23> kmc: thank you, could put it in words :D
13:11:36 <Twey> Eros!
13:11:40 <XniX23> couldn't even
13:12:41 <kmc> XniX23, because the contracts get very complicated.... "derivative" means a financial product whose value is based on the value of another product, often in a complex, non-linear way.  so you can combine these things with various operators to any depth you like
13:12:57 <kmc> so you really end up wanting to write out a formula
13:13:08 <kmc> in fact I think many GUIs are secretly bad programming languages
13:13:38 <kmc> graphics are great for output but for input you want text
13:14:19 <XniX23> kmc: oh i see now
13:14:20 <kmc> there's a reason humans evolved language and then writing
13:14:28 <kmc> instead of point-and-grunt... i mean, point-and-click
13:15:08 <chrisdone> too busy stabbing eachother with pointy things, cavemen. they'd get the wrong idea if you gave them a pencil
13:15:40 <XniX23> kmc: what did you mean with parsec that it feels like a domain-specific language? im surfing a bit for examples and seems like you just use functions; am i missing something?
13:15:48 <chrisdone> throw it back in your face and say "get me a palmtop, grandad"
13:15:50 <kmc> you do just use functions
13:16:25 <kmc> XniX23, but it also looks a lot like a grammar description
13:16:38 <XniX23> kmc: you mean like BNF?
13:16:51 <kmc> expr = (Lit <$> integer) <|> (Plus <$> expr <* char '+' <*> expr)
13:16:52 <kmc> yes
13:17:13 <kmc> (this is more obvious if you use Applicative instead of Monad)
13:17:21 <danharaj> DSL's in Haskell tend to look like ordinary functions.
13:17:22 <dainanaki> Doing a little bit of Template Haskell. Say that I have a value of type Q Foo and I want to splice it into an expression. How do I do so?
13:17:23 <chrisdone> a DSL in haskell is usually a set of functions and types, and often a monad or applicative or arrow, which imposes or supports a set of operations and means of combination specific to one domain
13:17:43 <dpratt71> what's the distinction between an endofunctor and an identity functor?
13:17:50 <kmc> dainanaki, well, it'd better be Q Exp
13:17:53 <danharaj> dpratt71: The identity functor is a specific endofunctor.
13:17:59 <kmc> but then you just say $(my expression)
13:18:20 <danharaj> [] is an endofunctor, taking a type to the type of lists whose elements are that type, for example.
13:18:38 <kmc> an endofunctor is any functor from a category to itself; the identity functor is the endofunctor which maps every object and morphism to itself
13:19:17 <copumpkin> except in haskell you only get the identity endofunctor that maps every object and morphism into something isomorphic to it
13:19:32 <kmc> it's like the difference between "any function of type A -> A" and "the function (\x -> x) specifically"
13:19:39 <Saizan> danharaj: there's the Lift class to transform a value into an expression that evaluates to it
13:19:42 <chrisdone> dainanaki: you can only splice haskell AST into haskell... so ask kmc says it should be Q Exp
13:19:46 <mokus> copumpkin: you can define type Identity f = f; you just can't give it a Monad instance ;)
13:20:00 <ion> FR: splicing PHP AST into Haskell
13:20:04 <copumpkin> mokus: fair enough
13:20:04 <Saizan> er, that was for dainanaki
13:20:04 <dainanaki> kmc, thanks, it turns out the real problem was orthogonally related.
13:20:19 <dainanaki> Thanks all, got it.
13:21:07 <dpratt71> copumpkin: can you elaborate on the distinction?
13:21:38 <copumpkin> dpratt71: newtype Identity a = Identity a
13:21:43 <copumpkin> you can make a functor instance for it
13:21:46 <copumpkin> Identity 5 ~ 5
13:21:59 <copumpkin> they're basically the same thing, but aren't exactly the same thing :)
13:22:00 <dpratt71> copumpkin: ah
13:22:33 <dpratt71> the whole 'up to isomorphism' concept is one that I would like to eventually wrap my head around
13:22:56 <dpratt71> thanks all for the enlightenment, btw
13:25:20 <zhulikas> where do you guys work as Haskell programmers?
13:25:29 * hackagebot intern 0.4.0 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.4.0 (EdwardKmett)
13:25:30 <zhulikas> and doing what
13:25:37 <kmc> dpratt71, so I draw two circles and label them "A" and "B" and draw a line between them
13:25:44 <kmc> and then i do it again with labels "X" and "Y"
13:25:52 <kmc> i've drawn two graphs
13:25:58 <kmc> they're the same up to isomorphism
13:26:34 <chrisdone> i work in end-user application development. 'tis a grim bidniss
13:26:54 <dpratt71> kmc: is that because (intuitively) you can stretch and completely overlay one graph over the other?
13:27:27 <kmc> because there's a mapping between them (namely A ↦ X, B ↦ Y) which a) is invertible, and b) preserves adjacency
13:27:38 <kmc> in fact there's another mapping A ↦ Y, B ↦ X with the same property
13:27:42 <kmc> so they're isomorphic in more than one way
13:27:50 <kmc> in fact a graph can be isomorphic to *itself* in more than one way
13:27:55 <kmc> anyway
13:28:04 <kmc> that's what a graph isomorphism is
13:28:13 <dpratt71> kmc: so the lines in this case are just that, not arrows?
13:28:27 <kmc> doesn't matter if it's a directed or undirected graph
13:28:34 <kmc> you can define "graph isomorphism" for either
13:28:38 <kmc> look it up on Wikipedia for the details
13:29:17 <kmc> anyway, that's what a graph isomorphism is... you have similar ideas in lots of areas of math: group isomorphism, ring isomorphism, topological homeomorphism, etc.
13:29:30 * hackagebot nptools 0.5.0 - A collection of random tools  http://hackage.haskell.org/package/nptools-0.5.0 (NicolasPouillard)
13:29:34 <kmc> they're each defined differently but the idea is the same
13:29:43 <kmc> and category theory to some degree formalizes that similarity
13:30:09 <dpratt71> kmc: interesting
13:31:33 <mokus> dpratt71: informally, if somthing is true "up to isomorphism" then it's true "if you consider equivalent things equal", where "equivalent" means there is an isomorphism as kmc is describing
13:32:29 <dpratt71> mokus: your explanation gets to the heart of why I am vexed by this concept; it seems rather circular in its logic
13:33:51 <kmc> dpratt71, it's perfectly concrete and well-defined for graphs, for groups, etc.
13:33:53 <mokus> dpratt71: that may be because it's more intuitive to think of "equivalent" as more fundamental than equal - most of the things we intuitively think of as 'true' are 'true up to isomorpism' instead of the more strict 'true up to equality'
13:34:01 <kmc> you can look up "graph isomorphism" and "group isomorphism" etc.
13:34:07 <kmc> it's a simple concrete property of functions
13:34:16 <kmc> the slippery part is figuring out why these all go by the name "isomorphism"
13:34:19 <kmc> but that's not math, it's philosophy of math
13:34:22 <kmc> makes sense?
13:34:32 <danharaj> it's the most important concept in modern mathematics, after the notion of a function itself.
13:34:59 <dafis> kmc: iso - equal, morphe - shape; the things have the same shape
13:35:16 <dafis> just language, no philosophy
13:35:27 <kmc> sure but then you have to justify why this particular notion of "shape" is the right one
13:35:36 <dpratt71> kmc: so long as I am not admitting complete understanding, yes it makes sense :)
13:35:48 <kmc> dpratt71, i think you may be looking for something that isn't there
13:36:14 <dpratt71> kmc: seems likely
13:36:24 <azaq23> dpratt71: What do you think is circular about the concept?
13:36:44 <dafis> kmc: not "the right one", it's the one under consideration at that point
13:36:46 <kmc> anyway category theory is an attempt to cast disparate areas of math (algebra, topology, poset theory, etc) into the same vocabulary
13:37:00 <kmc> you should look there if you want a formal yet general definition of "isomorphism"
13:37:05 <kmc> but that's getting out of my depth
13:37:22 <Cale> chrisdone: I think that while it's possible to programmatically define new names not occurring in the source code using TH, I kinda think it's unwise... (like generating the name getCounter given that the name of the thing is Counter). I think using a typeclass would be better.
13:37:31 <dpratt71> azaq23: I suppose its the fact that I fail to distinguish between equivalent and equal as mokus said
13:37:37 <Cale> Or else, letting the user write the name of the thing.
13:38:00 <mokus> dpratt71: yes, the concept does hinge on that distinction
13:38:28 <kmc> a graph is a graph no matter how you draw it or what you name the nodes
13:38:31 <Cale> (I just dislike the weird TH stuff people do which magically defines a whole bunch of things which aren't textually mentioned anywhere in the code which defines them)
13:38:58 <Cale> Generating instances of classes is fine with me though.
13:39:15 <dafis> dpratt71: you consider sets (or other objects) with some structure (say groups), a (homo)morphism is a mapping which 'respects' that structure (for groups, that'd be f(x*y) = f(x)*f(y))
13:39:22 <Cale> kmc: The definition of isomorphism from a CT perspective is really really simple :)
13:39:34 <Cale> isomorphisms are just arrows that are invertible
13:40:03 <Cale> That is, f: A -> B is an isomorphism if there exists some g: B -> A such that g . f = id_A, and f . g = id_B
13:40:26 <mokus> dpratt71: you could actually say that the phrase "up to isomorphism" is just a formalization of the phrase "if we gloss over the difference between equality and equivalence"
13:40:50 <kmc> no, there is no formalization of the phrase "up to isomorphism" in isolation
13:40:50 <dafis> dpratt71: an isomorphism is a bijective homomorphism [such that the inverse is also a homomorphism, but I don't know of a category of sets where that doesn't follow automatically]
13:41:08 <azaq23> dpratt71: To consider things to be equivalent is to say that some important property is preserved in both things; You could say that the natural number 2 and [(), ()] are isomorphic to each other because you can get one thing from the other effortlessly and you could use lists to define numbers and so on.
13:41:09 <azaq23>  To say that things are equal is to say that they have the same identity. To pieces of bread are equivalent, but they are still distinct and you could attach a serial number to them to distinguish them by identity, if you wanted to. Think OOP objects which have an identity by being an object from a certain class, though you may still define you own equivalence function.
13:41:10 <kmc> there is a formalization of "up to graph isomorphism" and "up to group isomorphism" and "up to lattice isomorphism" and etc.
13:41:19 <mokus> kmc: "up to isomorphism" is the formalization, within the context of some category/other context
13:41:22 <Cale> kmc: welll...
13:41:58 <Cale> Yeah, when you say "up to isomorphism", the objects involved had all better belong to some well-defined category.
13:42:09 <mokus> kmc: it gives concrete meaning (not in isolation, as you say, but in reference to other terms in context) to the informal concept of "if we pretend similar things are the same"
13:42:17 <Cale> and the isomorphism is the isomorphism in that category
13:42:27 <dafis> dpratt71: so, two isomorphic objects are equivalent with respect to that structure, you can translate everything you say about the one which only mentions the relevant structure to a corresponding statement about the other
13:42:44 <Cale> Where did this discussion begin?
13:43:08 * frerich_ waits for somebody to define "isomorphism" in terms of an isomorphism.
13:43:14 <Cale> zhulikas: I work from home as a developer for iPwn studios. We're working on a game for iPhones and other mobile devices in Haskell.
13:43:14 <mokus> Cale: an offhand remark that someone needed to look into the meaning of "up to isomorphism"
13:43:26 <Cale> mokus: ah, I see
13:44:22 <kmc> the concept of isomorphism is simple; the fact that this channel explained it 50 times in 50 slightly different ways has probably convinced dpratt71 that it's not simple ;P
13:44:34 <Cale> When you're talking about categories, isomorphism itself is often even too strong.
13:44:39 <dpratt71> kmc: :)
13:45:02 * roconnor finds the concept of isomorphism more subtle than it is often made out to be.
13:45:07 <dpratt71> kmc: I often find its the simplest concepts that are the hardest to understand
13:45:20 <ion> kmc: Any news about getting a video of your Haskell talk? The last time i asked you said you’d look into it. :-)
13:45:23 <zhulikas> dpratt71, like monads?
13:45:28 <Cale> Often you only care about properties of categories which hold up to equivalence of categories, which is weaker.
13:45:31 <kmc> ion, it's not to happen for several months
13:45:37 <ion> Oh, ok
13:45:38 <kmc> the talk i mean
13:46:10 <dpratt71> zhulikas: quite like that, yes
13:46:25 <Cale> The simplest concepts have the most examples, and admit the smallest number of general statements to be made about them. That's why they're harder to understand.
13:46:56 <frerich_> dpratt71: I think when really "getting" something, you're able to turn it around in your mind and view it from different angles. Now, simple things are understood by many people, but they all happen to view it from a different angle - so you get to see all sides at once. :-}
13:47:12 <Cale> (probably that should be s/number/set/)
13:47:32 <frerich_> dpratt71: That's why a room of experts usually gives a pretty uniform explanation of something very complicated (since it's hard to turn it around) but many different explanations of something simple.
13:47:58 <dpratt71> frerich_: as I have just experienced :)
13:48:05 <dafis> Cale: number is fine, the cardinal number of the set of statements
13:48:29 <Cale> dafis: Except that's not really what I mean, because generally it'll just be Aleph_0 all the time.
13:48:41 <dpratt71> the onslaught of helpful information is overwhelming at times in this channel :)
13:48:41 <mokus> dafis: up to equivalence of statements? :P
13:48:42 <Cale> I mean smallest in the sense of set inclusion.
13:48:44 <tromp> slashdot has an article "Microsoft To Pay $200k Prize For New Security Tech". i think haskell deserves that prize
13:49:01 <dafis> mokus: yep
13:49:12 <frerich_> dpratt71: I recently experienced it when watching some young children (some friends of my son) explain what a "hole" is (some said the hole is a short tunnel, others said there is no hole, just the stuff around it). It was amazing! :-)
13:49:28 <dpratt71> frerich_: :)
13:49:58 <dpratt71> concepts defined by the absence of things are always tricky
13:50:24 <Cale> There's an entire branch of mathematics whose purpose is to explain what a hole is.
13:50:26 * dafis wonders whether matter is just holes in the vacuum
13:50:43 * roconnor assumes a hole has something to do with homology groups
13:50:44 <dpratt71> dafis: :)
13:51:01 <dafis> roconnor: or homotopy
13:51:08 <roconnor> or homotopy
13:51:25 * frerich_ is sure you folks can give some fun explanations of what a "hole" is, but maybe not quite as creative as a bunch of four-year olds.
13:51:58 <roconnor> a hole is when you can draw a line on the ground that comes back to where you start, but cannot continuously deform this line back to the single starting point. :P
13:52:26 <dpratt71> Cale: and what, for trivia's sake, would this branch of mathematics be?
13:52:36 <mokus> dpratt71: topology
13:52:40 <chrisdone> what gets bigger the more you take away?
13:52:48 <Cale> dpratt71: It's a bit of a glib characterisation of algebraic topology
13:53:07 <dpratt71> cale, mokus: ah
13:53:21 <mokus> as usual, cale's explanation is more complete than mine ;)
13:53:21 <Cale> Homotopy and homology groups are both about detecting and characterising holes of various types in topological spaces
13:53:34 <hpaste> int80_h pasted “TagSoup question” at http://hpaste.org/49830
13:53:43 <roconnor> A hole is when you have a type with a non-reflexive proof of equality.
13:54:06 <Cale> A sphere has a different kind of hole in it than a circle does. But how exactly?
13:54:07 <mokus> chrisdone: taxes?
13:54:37 <mokus> that probably doesn't count, those seem to get bigger no matter what
13:54:50 <dafis> int80_h: The constructor exposed, isn't it?
13:55:03 <Somix> wow ... this channel is a giant math+CS orgy - <3
13:55:27 <dafis> Cale: a sphere is simply connected
13:55:32 <Cale> dafis: yes
13:55:47 <roconnor> Hmm, Bool has a non-reflexive proof of equality, but dosn't seem to have a hole.  I must be missing soemthing.
13:55:53 <int80_h>  dafis: not sure what exposed means.
13:56:07 <azaq23> Somix: It's everyday like this, you're welcome
13:56:23 <Cale> dafis: pi_1(circle) = Z and pi_2(circle) = 0, while pi_1(sphere) = 0, and pi_2(circle) = Z
13:56:34 <dpratt71> Somix: I'm afraid I am to blame (this time), sorry
13:56:40 <Somix> haha
13:56:49 <frerich_> azaq23: Thanks to this channel, I know almost nothing about almost everything in mathematics.
13:56:50 <bscarlet> chrisdone: me? I like the local Chinese joint a little too much.
13:56:53 <dafis> int80_h: you can use the constructor outside the defining module, in particular pattern-match on it (meant to type exported)
13:57:01 <roconnor> dafis: Cale's last pi_2(circle) is supposed to be pi_2(sphere)
13:57:05 <Cale> er, yes
13:57:07 <Cale> sorry
13:57:11 <mokus> dpratt71: nonsense, you just asked a question - it's the rest of us to blame for pointing the firehose your way :)
13:57:16 <Cale> line edit fail ;)
13:57:39 <dafis> Cale, roconnor: I know, my emory is not yet that bad :)
13:57:52 <mokus> I'm pretty sure there's a #haskell manifesto somewhere that says questions are always allowed
13:57:53 <dpratt71> mokus: true, that; actually the thing that got the firehose pointed in my direction wasn't even an explicit question ;-)
13:58:14 <mokus> dpratt71: oh yea, we just heard it as one because we wanted to :)
13:58:15 <int80_h>  dafis: oh yes, it's exported. I'm having difficulty imagining what the pattern-matching looks like.
13:58:18 <dpratt71> (although I knew what was the likely outcome)
13:58:46 <dafis> int80_h: case foo of TagOpen _ attrs -> attrs
14:00:23 <dafis> Cale: however, more interesting holes appear e.g. in projective spaces, pi_1(P^2(R)) = Z_2
14:00:38 <Cale> dafis: Yes, I was thinking about bringing that up too
14:00:42 <int80_h> dafis: thanks, it was the first value I didn't know how to deal with. And you just drop it!
14:00:46 <dafis> :)
14:04:09 <Gracenotes> oh god. I just realized I implicitly think of lazy transformations on data structures as more efficient than equivalent strict transformations
14:04:38 <Gracenotes> especially list collections, even if I'm processing the whole thing. :.
14:04:52 <dainanaki> that's no bueno.
14:04:53 <Gracenotes> in other programming languages, I mean, namely Python
14:05:20 <Gracenotes> generators and iterators are nice.
14:05:22 <dainanaki> You should stop doing that.
14:05:27 <dainanaki> :D
14:06:22 <Cale> Well, once you start consuming the result somehow, they can be more efficient in terms of memory.
14:06:23 <ceii__> verse 12 of the Haskell Gospel is that lazy transformations are always better if you throw a sufficiently good compiler at them
14:06:37 <rwbarton> it's not totally false, it can have lower space usage = faster due to cache hierarchy
14:06:42 <Cale> Because only a small part of the structure might be live at any time.
14:07:02 <yitz> obligitory classical definition: a topolgist is someone who can't tell the difference between a doughnut and a coffee cup
14:07:56 <ceii__> which are functionally equivalent anyways: they're both used for breakfast
14:08:07 <yitz> Gracenotes: it may not be more efficient, but it does often lead to more beautiful programs
14:08:10 <dafis> ceii__: not here
14:08:44 <mokus> yitz: until they take a bite of one - one changes its topology, the other changes the topology of his/her teeth :)
14:09:07 <dafis> mokus: I fear your doughnuts
14:09:12 <Gracenotes> my program does operate on lots and lots of data, but tries to avoid collecting its results until last minute due to construction of filter objects
14:09:18 <mokus> dafis: I would too, were I a topologist
14:09:26 <ceii__> If you managed to break your teeth in a way that changed their topology then I want a picture
14:09:32 <ceii__> :)
14:09:38 * hackagebot vector-algorithms 0.5.0 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.5.0 (DanDoel)
14:09:44 <mokus> ceii__: two pieces has a different topology than one
14:10:04 <dafis> ceii__: if you break your teeth, the number of connected components will increase
14:10:08 <ceii__> ah, I was thinking about what was left on the jaw. Oh well.
14:10:42 <dafis> ceii__: even that is possible
14:14:29 <burbul> Is there a way to force hlint to ignore a particular file in a directory (or a particular line of a file)?
14:15:03 <burbul> It's generating a message for
14:15:04 <burbul> I.lookup hash tbl >>= L.find ((== sn) . fst) >>= (return . snd)
14:15:13 <burbul> But the rewrite is nastier than the original.
14:15:56 <Gracenotes> out of curiosity, what's its suggestion
14:16:16 <burbul> fmap snd (I.lookup hash tbl >>= L.find ((== sn) . fst))
14:16:25 <burbul> [ I didn't in fact write either myself
14:16:38 <burbul> But I find the latter harder to read because it's more nested.]
14:17:13 <ceii__> also, the latter's data flow is non-linear
14:17:16 <Gracenotes> I like the look of - fmap snd $ L.find ((== sn) . fst) =<< I.lookup hash tbl
14:17:36 <Gracenotes> but, yeah, it doesn't like the return in >>= >_> not too familiar with hlint
14:18:03 <burbul> Thanks -- I'll see what my collaborator (who wrote that code ) thinks of the suggestion.
14:18:50 <dafis> burbul: L.find is Data.List.find?
14:19:09 <burbul> yup
14:19:17 <burbul> and I is Intmap
14:19:49 <dafis> burbul: I.lookup hash tbl >>= Prelude.lookup sn
14:20:14 <dafis> je pense
14:20:38 <ceii__> @type lookup
14:20:39 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:20:45 <ceii__> right
14:21:21 <burbul> Hey, that's *much* nicer. Thanks!
14:21:42 <dafis> burbul: and should shut up hlint
14:24:25 <burbul> yup
14:24:40 <dafis> :)
14:32:30 <args[0]> band
14:32:59 <dafis> ?
14:54:24 <erus`> is reality deterministic?
14:54:43 <erus`> reality/the universe
14:55:25 <erus`> no you are wrong! the answer is: we will never know
14:57:53 <dafis> erus`: that may be wrong if the universe isn't deterministic
14:59:03 <erus`> the point is, there may be some state that you cant see
14:59:18 <erus`> that means the universe could be deterministic even if it looks like its not
14:59:55 <erus`> and viceversa
15:00:29 <erus`> viceversa (a, b) = (b, a)
15:00:37 <sbrtgr> ok I think I shelve this for now. Can't get haskell-mode's C-c C-l to work, even though C-c C-b works. I tried M-x debug-on-entry inferior-haskell-load-file, which then, of course, hangs as well. Setting debug-on-exit tells me that it send the :load command to the process. Oh and istalling scion from github seems to -be a complete dependency nightmare- have issues with ghc 6.12. because of old list-tries.
15:01:30 <kmc> erus`, or viceversa ~(a, b) = (b,a) -- :)
15:02:53 <acowley> so, viceversa is always true, therefore yes and no, we are right and wrong!
15:03:20 <_Ray_> Does anyone have any experience with LIO? I have a relatively basic question about it :)
15:03:25 <acowley> sbrtgr: standalone ghci works for you?
15:03:33 <acowley> what's LIO?
15:03:45 <_Ray_> Labeled IO, a library in hackage.
15:04:38 <acowley> "This package is intended to only be used at the computer science school ECI 2011 (Buenos Aires, Argentina)"
15:04:54 <acowley> _Ray_: that will limit the odds of finding someone with experience here!
15:05:09 <_Ray_> What are the odds, I'm specifically from there! ;)
15:05:24 <sbrtgr> acowley: yes
15:08:10 * hackagebot vector-algorithms 0.5.1 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.5.1 (DanDoel)
15:11:37 <acowley> sbrtgr: what OS?
15:13:14 <XniX23> im surfing about haskell's future and i've read that there might come to haskell 2?
15:13:44 <dafis> XniX23: pfft, we're at Haskell 2010 already
15:14:07 <sbrtgr> acowley: ubuntu natty with haskell installed from debian packages because ubuntu's haskell-platform is/was bugged.
15:14:21 <acowley> Yes, you are over 2000 versions out of date. Long term service only goes back to Haskell 3.
15:14:47 <XniX23> dafis: hahahah :D
15:14:59 <dafis> seriously, there's a Haskell' process, it started out to do a major revision, but has been changed to incremental updates
15:15:34 <acowley> sbrtgr: I can't think of anything specific that could be causing the difficulty, but as a general principle I always install GHC myself rather than rely on a package manager.
15:15:37 <dafis> expect H2012 soon
15:15:55 <dafis> acowley++
15:16:21 <parcs> acowley: do you compile from source?
15:16:37 <acowley> XniX23: If you are interested in where Haskell ideas are coming from, you can take a look at something like Agda.
15:16:39 * dafis only uses the distro to get the process going, from then on it's all source
15:16:52 <acowley> parcs: not usually
15:17:07 <acowley> GHC binary install, then do your own cabal
15:17:11 <Cale> Haskell 98 is 1.5, and Haskell 2010 is 1.5.1
15:17:58 <kmc> XniX23, new language features tend to get implemented first and only standardized much later
15:17:58 <XniX23> dafis: is there a website about haskell' ?
15:17:59 <acowley> I don't know about that
15:18:06 <dafis> Cale: I'd have thought 1.4 -> 98 was substantive enough to call H98 Haskell 2
15:18:11 <kmc> so even Haskell 2010 is far behind what's possible today in GHC
15:18:22 <Cale> Though, really, it's backward. 1.4 was better than 98.
15:18:28 <acowley> does 2010 have GADTs?
15:18:28 <kmc> Cale++
15:18:33 <kmc> Haskell hipsters represent
15:18:37 <kmc> acowley, no way
15:18:46 <kmc> acowley, Haskell 2010 is a *very* conservative extension to Haskell 98
15:18:50 <dafis> acowley: ghc only so far
15:19:02 <kmc> no UHC or JHC support?
15:19:09 <c_wraith> 2010 adds things like dot-separated module names.  Fancy!
15:19:11 <Cale> The changes in Haskell 2010 are all largely inconsequential tiny things.
15:19:12 <dafis> afaik, no
15:19:19 <acowley> The whole spec vs. GHC situation isn't very satisfying
15:19:25 <kmc> i agree
15:19:32 <kmc> but it's important to go slow and get it right
15:19:34 <Cale> Well, the hierarchical modules thing was an addendum to 98 already
15:19:47 <kmc> the #1 unusual feature of Haskell is that it's designed by careful people who know what the hell they're doing
15:19:49 <acowley> kmc: yes, I suppose that's right
15:19:50 <Cale> I think it's good for GHC to go way ahead of the spec
15:20:01 <Cale> Specifying unimplemented things is stupid.
15:20:08 <c_wraith> yeah..  let GHC find out what works and what doesn't.
15:20:15 <c_wraith> then add the things that work to the language
15:20:20 <XniX23> im not sure im following... they're slowly "upgrading" haskell, and then there's some other work (separate) on haskell' ?
15:20:21 <kmc> GHC has implemented and deprecated many extensions
15:20:37 <kmc> XniX23, Haskell' (Haskell Prime) is the name of the process which produces new language specs
15:20:38 <c_wraith> XniX23: GHC is an implementation that supports many non-standard extensions
15:20:44 <kmc> Haskell 98, Haskell 2010, soon Haskell 2012
15:20:48 <Cale> XniX23: The standards process is completely separate from the reality of the language that people use (for better or worse)
15:20:54 <acowley> Sure! But the eagerness we show in adopting new features is striking
15:21:01 <acowley> "we" meaning the community
15:21:08 <kmc> the language people use is "Haskell 2010 plus varying numbers of GHC-specific extensions"
15:21:56 <kmc> (or even extensions implemented beyond GHC but still not standard)
15:22:01 <Cale> Think about everything that uses the MTL for example.
15:22:10 <Cale> That's all not Haskell 2010 code.
15:22:11 <acowley> I guess my issue with the spec vs. GHC is that certain language extensions have seen such widespread uptake that removing them would already be very painful (e.g. BangPatterns), and that it would be nice if there were other implementations in more active use
15:22:13 * kmc considers Rank2Types the only truly essential extension beyond Haskell 2010
15:22:20 <dolio> The main problem is that you get various people putting out 3 packages instead of 1 in some attempt to partition them by what extensions they use.
15:22:29 <kmc> (that's not including GHC libraries that have magical implementations, though)
15:23:09 <sbrtgr> acowley: Well I haven't encountered any general haskell issues on this system. For example, I'm running XMonad from repos. But yeah, I'll try installing from source as you suggest. It seems the package manager model isn't nearly as smooth a ride as one would hope, anyway.
15:23:47 <acowley> sbrtgr: I wasn't saying to compile GHC yourself, just to install a binary from http://www.haskell.org/ghc/download
15:24:08 <c_wraith> kmc: you don't think GADTs are also important?
15:24:14 <acowley> sbrtgr: then use cabal-install to get libraries
15:24:20 <kmc> c_wraith, important but not "truly essential"
15:24:22 <dafis> acowley: but compiling from source is fun (and you can customise)
15:24:24 <acowley> GADTs will really come into their own when we get TypeKinds
15:24:28 <kmc> i mean, the question is "essential for what"
15:24:30 <sbrtgr> acowley: I did all that.
15:24:39 <kmc> but Rank2Types are needed for a lot of basic practical things
15:24:59 <acowley> dafis: it also takes a long time! What customizations do you use?
15:25:02 <Cale> The reason to have standards documents is to help implementors of the language keep things straight. We don't have all that many implementations of Haskell, and it's still really not that hard for people to coordinate what they're implementing, so the standard process is currently succeeding for the current level of development of implementations.
15:25:04 <kmc> like ST, and you can also use them to encode existentials
15:26:02 <Cale> Also, there are papers written about the various extensions which usually specify their semantics formally.
15:26:15 <Cale> (with a few notable exceptions)
15:26:16 <kmc> and then GHC implements something different ;)
15:26:18 <acowley> Cale: I'm certainly not arguing against having standards documents. I suppose I just worry that extensions that don't come with draft-ammendments to the standard gain too much ground
15:26:22 <dolio> We have a lot more implementations than many other modern languages.
15:26:24 <XniX23> kmc: so basicaly the language is being developed slowly? do you know what was that about haskell 2?
15:26:36 <dafis> acowley: for one, I change defaultHaddockFlags in Distribution.Simple.Setup so I get automatically hscoloured code with my docs, then some performance things, most will be in 7.2 though
15:26:41 <Cale> acowley: I'm arguing against taking standards documents too seriously.
15:27:05 <kmc> XniX23, yeah, the language is being developed slowly; the features are implemented in GHC long before they're part of Haskell proper
15:27:29 <kmc> dolio, indeed, the very concept of a language spec independent of implementations is foreign to a lot of programmers
15:27:45 <Cale> You have to be careful about what you mean by "the language" -- do you mean Haskell-as-standardised or Haskell-as-implemented?
15:27:48 <XniX23> kmc: so "the language" is way more developed than it seems by standards
15:27:53 <Cale> Because those are two very different things.
15:27:54 <kmc> XniX23, right
15:28:05 <kmc> I use the terms "Haskell" and "GHC Haskell"
15:28:06 <Cale> Standard Haskell is changing *very* slowly.
15:28:16 <Cale> Implemented Haskell is changing much more rapidly.
15:28:28 <Cale> Even if you count other implementations than GHC.
15:28:30 <acowley> kmc: that's kind of the point I was initially complaining about, though
15:28:34 <Philippa> acowley: stuff around typeclasses has turned out to need a /lot/ of practical experience to really get our heads around adequately. We wouldn't have anything worth standardising otherwise
15:28:47 <kmc> people will say they program in "perl", by which they mean their code works in whatever perl 5.12.3 binary happens to be installed in their system and configured with whatever build-time options
15:28:52 <acowley> kmc: the occasions in which you really mean to say "Haskell" instead of "GHC Haskell" are rare
15:28:55 <Philippa> (not that we're quite there, but things're looking pretty damn promising)
15:28:59 <XniX23> i've heard that ghc is one of the most amazing pieces of software ever written lol
15:29:01 <acowley> kmc: and this leads to confusion
15:29:21 <gwern> Cale: on the bright side, our standards process is not *completely* broken - we have gotten things after '98
15:29:24 <kmc> acowley, i don't know if you mean me or "one in general" but I talk about standard Haskell all the time
15:29:29 <Cale> acowley: Well, in a de-facto sense, GHC *is* Haskell.
15:29:34 <kmc> bah
15:29:35 <aavogt> you can say haskell98 or haskell2010 to emphasize the other way
15:29:37 <acowley> hah
15:29:45 <acowley> see? this is the proglem
15:29:48 <Twey> I think most people do
15:29:54 <Philippa> aavogt: yeah, that's what people do with C
15:29:59 <kmc> Cale, I'm annoyed by that claim because it makes people ignore useful extensions that don't exist in GHC
15:30:05 <Cale> It's not a problem unless you have more implementations that people are actually using.
15:30:19 <Cale> There are other implementations of Haskell, but they are mostly toy implementations at this point.
15:30:25 <kmc> How often do people in #haskell say "I wish we had extensible records"?  And how often do we talk about Trex?
15:30:26 <acowley> Philippa: I'm not advocating rushing the standards, just worrying that the gap between standards and what people use on a daily basis grows too wide
15:30:27 <Philippa> kmc: it's not the claim, it's the reality that's the problem
15:30:36 <kmc> (the answers are "always" and "never" respectively)
15:30:48 <Twey> Why do we not have Trex?
15:30:55 <Cale> kmc: Trex isn't what I mean when I say that I want extensible records though ;)
15:31:03 <kmc> you don't have to use Hugs to read the Hugs user manual and consider its extensions as design points
15:31:04 <Twey> What's wrong with it?
15:31:05 <dafis> 'cause Marc Bolan's dead
15:31:10 <Philippa> acowley: yeah. That turns out to be because the whole bundle of problems around type classes and fundeps/type families and GADTs is /complicated/. Like, decades-long-research-program complicated
15:31:17 <Cale> Inequality constraints is what's wrong with it
15:31:23 <kmc> you don't have to use JHC to think that ACIO would be useful in GHC
15:31:31 <Cale> I find type inequality constraints distasteful.
15:31:36 <kmc> but you'll never hear about Trex or ACIO if you take the "Haskell = GHC" view
15:31:55 <Cale> I dislike ACIO as well.
15:32:07 <dolio> Why wouldn't you hear about them?
15:32:10 <Cale> (but I do understand your point)
15:32:40 <Philippa> eh, the moment you're playing in the space of "potential extensions to haskell" they're back in scope again anyway
15:33:03 <acowley> Philippa: Understood. But we have a naming problem with GHC being the language people use, and the Haskell standard not defining it.
15:33:24 <Cale> acowley: Well, there's also Haskell, the wider family of not-yet-implemented languages.
15:33:35 <Philippa> on the whole, you have to feed GHC flags or at least pragmas to deviate from the standard
15:33:41 <Cale> and some people in this channel, notably ski, seem to write a fair amount of that too ;)
15:33:46 <Philippa> in fact, more so pragmas than flags. And that's a big improvement
15:33:49 <acowley> I suppose it's an unavoidable problem in some sense, as there are very good reasons for it, and we all just have to be vigilent about clarifying the distinction between the Haskell language and GHC features.
15:34:01 <mauke> when I say "I wish we had exensible records" I mean "I wish we had extensible records in GHC"
15:34:03 <Cale> acowley: I don't think anyone's actually confused.
15:34:08 <acowley> Cale: I am
15:34:12 <Cale> acowley: Oh?
15:34:15 <Philippa> acowley: it gets worse though. For example, what about features that GHC and Hugs have in common, but which aren't standardised?
15:34:15 <zong_sharo> hi, i really need some help with associated types
15:34:17 <zong_sharo> http://paste.pocoo.org/show/452203/
15:34:21 <Cale> acowley: Well, what specifically are you confused about?
15:34:31 <acowley> Cale: well, I was joking. But this started with someone asking about the Haskell standard
15:34:35 <dainanaki> I'm running into problems with a personal project that I'm working on that uses Hint regarding scope issues of interpreted code. Could anyone check out my code at https://github.com/iand675/Zoom and help me figure out what's wrong?
15:35:04 <dolio> There are features that ghc, jhc, uhc _and_ hugs have in common that aren't standardized, even.
15:35:17 <acowley> Cale: I suppose we can point to the GHC docs for a relevant language standard
15:35:42 <sipa> hi blaze-x
15:35:46 <blaze-x> sipa: :-)
15:35:57 <dainanaki> I'm getting an error message for my interpreted code: "Not in scope: type constructor or class `Zoom.Task.Args'"
15:36:01 <Cale> acowley: yes, and the various papers that have been written specifying all the extensions
15:36:02 <acowley> Philippa: Yes, those are the issues that makes me want more up-to-date standards
15:36:05 * zhulikas kthxbye
15:36:23 <sipa> > let { len [] = 0; len (_:b) = 1 + len b } in len "hello"
15:36:24 <lambdabot>   5
15:36:33 <Cale> acowley: As well as the grand unified system which has recently been constructed (OutsideIn(X))
15:36:35 <sbrtgr> acowley: For example, for scion, cabal successfully installed every dependency except one. tries-list>=0.1 && <0.3 (quite old I think)
15:36:50 <Philippa> acowley: the problem is that most of /those/ have subtle things going on too. For example, when you have RankNTypes not all inference algorithms are equal
15:36:52 <zong_sharo> i want class with associated datatype in the context of another class
15:36:57 <Cale> http://research.microsoft.com/~simonpj/papers/constraints/jfp-outsidein.pdf
15:37:07 <zong_sharo> but, only associated type goes on the right site of the class context
15:37:11 <Philippa> but we're seeing more of an effort to at least start clarifying a minimum for them
15:37:17 <zong_sharo> is it possible?
15:37:37 <acowley> sbrtgr: I've never installed scion
15:37:44 <Cale> That paper specifies a framework in which many of the type-system extensions to GHC can be formalised and unified.
15:37:46 <Philippa> Cale: is that the current latest story on the GADTs+type equalities+type classes+... mess?
15:37:49 <Cale> yeah
15:37:59 <Philippa> cool, I should read that
15:38:15 <Philippa> (not least because I have some stuff to say about principal typings and I should check for interactions)
15:38:18 <acowley> Cale, Philippa: I'm just sensitive about these things after seeing just a fraction of the R6RS episode
15:38:28 <sbrtgr> acowley: well I tried that as an alternative because the inferior ghci process works fine
15:38:31 <acowley> Cale: Yes, that is great work
15:39:01 <sipa> :t (+5)
15:39:02 <lambdabot> forall a. (Num a) => a -> a
15:39:12 <Cale> Unfortunately, its implementation seems to have led to much less readable type errors.
15:39:26 <Cale> Or perhaps I just don't understand all the terminology yet.
15:39:32 <sipa> @pl \x y -> x*5+3-y
15:39:32 <lambdabot> (-) . (3 +) . (5 *)
15:39:58 <Cale> (you can easily get error messages talking about untouchable variables and such)
15:40:04 <sipa> @botsnack
15:40:05 <lambdabot> :)
15:40:34 <dainanaki> So nobody will help me figure out what's wrong with how I'm using hint?
15:41:21 <Cale> dainanaki: You linked to github...
15:41:24 <c_wraith> dainanaki: I'll take a look.  (didn't see the previous request)
15:41:34 <Cale> I don't understand what code you want me to look at
15:41:38 <dainanaki> I'm getting the error "Not in scope: type constructor or class `Zoom.Task.Args'"
15:41:41 <c_wraith> hmm.  yes, linking to the exact code using it would help
15:42:06 <dainanaki> the whole github project contains what you need to see.
15:42:31 <dainanaki> the issue is that I'm making a rake-like task runner that interprets haskell files and lets you run tasks in them
15:42:42 <dainanaki> the tasks/SayHello.hs has an example, namely hi2
15:43:05 <dainanaki> the issue is that when I try to run hi2, I get "Not in scope: type constructor or class `Zoom.Task.Args'"
15:43:11 <c_wraith> Well.  That error message is pretty clear, you don't have the module with the type needed in scope
15:43:24 <dainanaki> Right, but I'm not understanding why.
15:43:31 <c_wraith> strip things way down.
15:43:45 <c_wraith> can you interpret "2 + 2"?
15:43:50 <dainanaki> Yes
15:43:51 <c_wraith> there are some tricks to getting even that far.
15:44:28 <kmc> @. run run text "2 + 2"
15:44:28 <dainanaki> If you look at test in Main.hs, I can interpret hi, but it errors out at hi2
15:44:29 <lambdabot>   4
15:44:45 <dainanaki> https://github.com/iand675/Zoom/blob/master/Main.hs#L41
15:45:42 <dainanaki> So that's what confuses me. How can it even load SayHello.hs and run hi if Zoom.Tasks.Args isn't in scope?
15:46:37 <sipa> > fix ((1:) . scanl (+))
15:46:38 <lambdabot>   Couldn't match expected type `[t]'
15:46:38 <lambdabot>         against inferred type `[[t]] -> ...
15:46:52 <Cale> dainanaki: The problem isn't about what's in scope in SayHello.hs
15:46:56 <sipa> > fix ((1:) . scanl (+) 1)
15:46:57 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
15:47:16 <Cale> dainanaki: SayHello.hs doesn't export the type Args, and so it's not in scope just by loading that module in your interpreter
15:47:23 <sipa> blaze-x: seen that? :)
15:48:40 <Cale> dainanaki: So, just like if you were typing this at the ghci prompt, you need to import the module with that type into your interpreter before you can try to coerce things to that type.
15:48:59 <Cale> (as interpretTask does)
15:49:55 <dainanaki> Cale, shouldn't the fact that the defaultModules are loaded qualified, and Zoom.Task is supposed to be loaded mean that it should be able to run interpretTask without issue?
15:50:25 <spencergordon> +i
15:50:28 <gwern> lambdabot: @join #lesswrong
15:51:08 <dainanaki> Actually, nevermind
15:51:10 <dainanaki> d
15:51:15 <dainanaki> I found the bug.
15:51:19 <dainanaki> thanks for the help.
15:52:45 <acowley> is anyone actively working on an OpenCL API?
15:53:37 <Cale> dainanaki: hmm, I just tried running it and all I get is that it can't find module Zoom.Task when loading SayHello.hs
15:53:41 <blaze-x> sipa: yep, nice!
15:53:42 <dainanaki> Right
15:54:02 <dainanaki> That's probably because you have to have actually installed it.
15:54:24 <dainanaki> I don't allow it to use . as the search path.
15:54:36 <c_wraith> Oh.  Are you misinterpreting the difference between modules to put in scope and modules to load?
15:54:44 <dainanaki> Apparently.
15:54:50 <c_wraith> That's an important distinction
15:54:54 <dainanaki> I realized that a few moments ago.
15:55:12 <c_wraith> if things are coming from installed packages *or* modules you're interpreting, they need to be listed as modules in scope
15:55:21 <c_wraith> But you also need to list things you're interpreting seperately
15:56:39 <c_wraith> It's the difference between :module and :load in ghci
15:56:53 <c_wraith> except you can do the equivalent of :load on multiple files via hint
15:57:09 <dainanaki> Right, so the question then is, how do you imitate :module?
15:57:13 <c_wraith> (and the ghci api in general, which hint is just a wrapper around)
15:57:20 <c_wraith> err, ghc api
15:57:31 <c_wraith> oh, let me find it
15:57:35 <aavogt> zong_sharo: use   class HasLabel a label | a -> label     instead?
15:58:04 <c_wraith> setImports
15:58:22 <c_wraith> and setImportsQ, for qualified names
15:59:14 <dainanaki> so I was trying to use setImportsQ to load prelude and zoom.task in the first place.
15:59:36 <zong_sharo> aavogt: actually i've completely removed Label from class context -- http://paste.pocoo.org/show/452216/
15:59:58 <zong_sharo> which is happens to be a right thing to do
16:00:07 <dainanaki> c_wraith, see 84-86 in main and defaultModules at 23
16:00:22 <erus`> can i dynamicaly load code with haskell
16:00:26 <erus`> ghc*
16:00:37 <zong_sharo> now signature of product type consists directly of member types, not labels
16:01:00 <Cale> erus`: yes
16:01:08 <c_wraith> erus`: yes.  that's what this hint discussion is about. :)
16:03:01 <erus`> i wanna make a programming game :)
16:03:14 <c_wraith> dainanaki: that code looks really suspect to me.
16:03:41 <dainanaki> how so?
16:03:43 <c_wraith> dainanaki: does qualifiedModules actually look right where you're printing it out?
16:03:44 <erus`> players write a function that takes a GameWorld and returns an action
16:04:33 <dainanaki> c_wraith: [("Prelude",Nothing),("Zoom.Task",Just "Task"),("Zoom.Task.SayHello",Just "SayHello")]
16:05:04 <zomg> I'm trying to understand how mutable state works in Haskell, it seems there's the state monad and then there's this Data.IORef thing... Are there any practical examples of how to use this?
16:05:25 <zomg> I found some code samples of the state monad but it was hardly very practical
16:05:37 <c_wraith> dainanaki: ok, that's fully consistent with the error message "Not in scope: type constructor or class `Zoom.Task.Args'"
16:05:58 <c_wraith> dainanaki: because the module is referred to as Task in that scope, not Zoom.Task
16:06:06 <c_wraith> dainanaki: I think you're running into Hint's type checking
16:06:06 <kmc> zomg, (State s a) is just a wrapper for (s -> (a, s))
16:06:14 <kmc> functional state-passing
16:06:21 * hackagebot HROOT 0.5.1.0 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.5.1.0 (IanWooKim)
16:06:24 <kmc> zomg, IORefs are "real" in-place-update variables
16:06:30 <kmc> as are MVars and TVars and STRefs etc.
16:06:35 <kmc> zomg, I think some of this stuff is covered in RWH
16:06:41 <c_wraith> dainanaki: hint's type checker is rather primitive, and based directly on Typeable
16:07:00 <c_wraith> dainanaki: and in particular, it's based on the string spit out by Typeable's show instance
16:07:11 <c_wraith> which means it will include the fully qualified original module name
16:07:25 <c_wraith> which is not the same name as you have the module imported with
16:07:25 <dainanaki> c_wraith: so you're saying if I fully qualify it, it'll be fine?
16:07:33 <c_wraith> dainanaki: I think so
16:08:39 <zomg> kmc: I see. I'll check RWH.. thanks
16:08:45 <dainanaki> c_wraith: that fixed it. thanks so much.
16:09:18 <c_wraith> dainanaki: you're welcome.  That's one of the less-obvious pitfalls of hint.  I only know about it due to having run into it before myself.
16:09:47 <dainanaki> yeah, hint has really been a pleasure to use besides that little bit.
16:12:52 <c_wraith> dainanaki: another pitfall you may or may not run into: it's not thread-safe.
16:13:21 <c_wraith> dainanaki: the hint wrapper is fine, but the ghc api itself is not, and hint doesn't do anything to protect you from that.
16:14:22 <dainanaki> thread-safe in the sense that I can't fork multiple interpreter instances?
16:16:21 <dainanaki> that wouldn't really surprise me.
16:17:11 <c_wraith> You can.
16:17:21 <c_wraith> you can run the interpreter from any forkIO'd thread
16:17:29 <c_wraith> what you can't do is run it concurrently from two of them
16:17:47 <dainanaki> that's what I meant by forking multiple instances. I should have been more precise.
16:18:03 <c_wraith> ah, ok.
16:19:12 <c_wraith> Oh.  And one other thing.  the ghc api mucks with signal handlers in an unfortunate way if run from a forkIO'd thread.  There's a bug report into ghc about that, with a "will be fixed eventually" status.
16:19:47 <c_wraith> I think that's everything I ran into. :)
16:20:42 <dainanaki> Thanks for letting me know. I'm not *too* worried about the thread-safety and signal-handling issues since only one task at a time is meant to be executed per command line invocation.
16:20:59 <c_wraith> yeah, probably not too important for you.
16:21:07 <c_wraith> I was hooking it into snap.  It mattered there. :)
16:21:21 <dainanaki> Certainly.
16:23:46 <parcs> does anyone recommend a particular first-class-records library?
16:25:16 <c_wraith> edwardk will recommend fclabels or his own library, which I can't remember the name of.
16:25:21 <c_wraith> I don't have a strong opinion, myself
16:25:21 <parcs> theres so many :(
16:26:30 <ddarius> @google site:hackage.haskell.org "Edward Kmett"
16:26:32 <lambdabot> http://hackage.haskell.org/package/streams-0.8.0.3
16:26:32 <lambdabot> Title: HackageDB: streams-0.8.0.3
16:26:35 <kingping> hello
16:26:47 <benmachine> hi kingping
16:26:48 <kingping> > 2 + 2
16:26:48 <lambdabot>   4
16:26:57 <sipa> :t liftM
16:26:58 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:27:29 <dainanaki> is HaLVM still being developed at all?
16:28:08 <c_wraith> I believe Galois is still using it, so it's likely
16:28:14 <parcs> data-lens is the name
16:28:21 <parcs> i'll go check it out, thanks
16:28:22 <dainanaki> the trac page is pretty stale.
16:30:06 <kingping> > Right 40 >>= Right . (+1)
16:30:07 <lambdabot>   Overlapping instances for GHC.Base.Monad (Data.Either.Either a)
16:30:07 <lambdabot>    arising ...
16:30:19 <kingping> > Right 40 >>= \x -> Right $ x + 1
16:30:20 <lambdabot>   Overlapping instances for GHC.Base.Monad (Data.Either.Either a)
16:30:20 <lambdabot>    arising ...
16:30:37 <benmachine> kingping: looks like lambdabot doesn't like the either monad
16:30:48 <kingping> > Right 40 >>= \x -> Right $ x + 1 :: Either String Int
16:30:49 <lambdabot>   Overlapping instances for GHC.Base.Monad
16:30:49 <lambdabot>                              (Data...
16:31:05 <benmachine> kingping: it won't work no matter what you try, lambdabot has the wrong imports
16:31:18 <benmachine> Cale: I think L.hs needs some tweaking, so that we only get one monad instance for Either
16:31:30 <kingping> benmachine: Looks like something changed since this section was published http://learnyouahaskell.com/for-a-few-monads-more#error as well
16:31:32 <Cale> benmachine: Yes, I'm not sure what two modules are both defining it
16:31:56 <benmachine> Cale: hmm, I assumed mtl+base but they're cleverer
16:32:11 <kingping> benmachine: In GHCi, because I cant evaluate the previous code in my 7.0.3.
16:32:34 <kingping> I wonder if >>= still exists for Either.
16:32:38 <benmachine> kingping: it does
16:32:44 <Cale> oh, apparently we have both mtl and transformers somehow
16:32:46 <Cale> that's bad
16:32:48 <c_wraith> kingping: the error message is it's finding *two* implementations of it
16:32:56 <benmachine> Cale: one's supposed to re-export the other these days, isn't it?
16:33:13 <benmachine> kingping: you should still be able to get the instance from Control.Monad.Error
16:33:17 <zzo38> Maybe I can propose the variant of Template Haskell which keeps state. In addition to types "Q Exp" and "Q Typ" and so on, the result can also be of a type "x -> (y, Q Exp)" and "x -> (y, Q Typ)" and so on, where "y" can be any type, and "x" must be either "()" or the same as the "y" type of a previous splice. The ordering of splices in a "chain" is guaranteed but others aren't.
16:33:19 <benmachine> but it'll also be in Control.Monad.Instances
16:33:55 <benmachine> zzo38: well, you can run IO in template haskell
16:34:38 <zzo38> benmachine: Yes but someone told me there is problem it doesn't so what I said, though. IO does something else instead, I think.
16:35:16 <benmachine> zzo38: oh right, yes, possibly. probably the only way to guarantee what you want is to put everything in a super-splice :P
16:36:22 <zzo38> benmachine: OK. Is there any syntax that can help with such things?
16:37:11 <benmachine> zzo38: you're aware of [| putting stuff in quotes |] and [t| type quotes |] and stuff?
16:37:18 <benmachine> (I think the latter is a thing, I don't really remember)
16:37:23 <zzo38> benmachine: Yes, I read the documentation.
16:37:28 <c_wraith> yes, quote syntax is very helpful
16:37:28 <hpaste> kingping pasted “Either” at http://hpaste.org/49831
16:37:37 <benmachine> well, I can't be any more help than that, but I'm not an expert
16:37:55 <zzo38> Would function composition help?
16:38:14 <aavogt> top-level splices are run in order from top-down
16:38:25 <dafis> kingping: you need Control.Monad.Instances now
16:39:02 <zzo38> aavogt: I thought there is no order?
16:39:27 * hackagebot BiobaseInfernal 0.5.3.0 - Infernal data structures and tools  http://hackage.haskell.org/package/BiobaseInfernal-0.5.3.0 (ChristianHoener)
16:39:32 <kingping> dafis: That worked. Anyway, I think http://learnyouahaskell.com/for-a-few-monads-more#error should note about import :-/
16:40:02 <c_wraith> sadly, BONUS hasn't been here in about 3 months, or he'd probably update it
16:40:24 <Nisstyre> So, trying to understand this version of foldl written using foldl in RWH
16:40:40 <Nisstyre> they weren't exaggerating >_<
16:40:47 <Nisstyre> *foldr
16:41:02 <kingping> c_wraith: I'm translating it into russian, probably No Starch are the only who around.
16:41:48 <aavogt> zzo38: http://hpaste.org/49832
16:41:58 <dafis> kingping: the instance was recently moved (and changed), LYAH is presumably older and not yet updated
16:42:51 <kingping> dafis: I see. Thank you.
16:43:38 <dafis> does anyone here know how to pull a single commit in git?
16:44:25 <zzo38> aavogt: Is there a documentation that says it is guaranteed?
16:46:04 <zzo38> I do not see the $(...) in there. Is it using "You may omit the $(...) in a top-level declaration splice. Simply writing an expression (rather than a declaration) implies a splice"?
16:47:00 <zzo38> If it is possible guaranteed ordering, is there also something that the ... can be something that tells it to call another your function having information about previous declarations input, and then can decide the output from there instead?
16:47:22 <kmc> dafis, git cherry-pick
16:48:09 <dafis> kmc: thx
16:48:17 <aavogt> zzo38: yes, you can leave out the $( ) at top level for more recent ghc
16:49:32 <zzo38> aavogt: Yes I read the document. However I am also asking if you can do something else similar what I mentioned next
16:50:22 <dafis> kmc: but before I can do that, I have to fetch everything from the remote repo?
16:51:13 <kmc> you have to have the commit object in your database
16:51:31 <kmc> one way to accomplish that is to run "git fetch"
16:52:19 <kingping> dafis: Did you search in source code to find out where Monad instance for Either is, or in hayoo ?
16:52:48 <dafis> kmc: any way to get a single patch from remote without asking for a mail?
16:53:36 <dafis> kingping: I've seen that problem often enough to remember where
16:53:49 <kingping> daed: ok then.
16:54:42 <aavogt> zzo38: http://hpaste.org/49833
16:54:56 <kingping> dafis: What if I just note that reader should import (:import) the Control.Monad.Instances to be able to use >>= for Either in the book? What do you think?
16:55:28 <aavogt> but say you compile that file, the IORef doesn't save the value it got when the TH got evaluated
16:56:01 <kingping> I mean what are the chances that it is moved some other module instead of the current one (Control.Monad.Instances).
16:56:13 <dafis> kingping: note that the necessary import depends on the version of base resp. mtl installed
16:56:35 <dafis> kingping: it will stay a while where it is now
16:57:01 <kmc> dafis, what's wrong with fetching?
16:57:37 <dafis> kmc: potentially maany commits I don't necessarily want
16:57:47 <kmc> how do those harm you?
16:58:47 <zzo38> It says you are not guaranteed the order of splices run.
16:58:47 <dafis> kmc: bandwidth, slow fetching? Usually, no real problem, I'm just enquiring whether there are other ways
16:59:03 <kmc> not to my knowledge, but ask #git
16:59:11 <hpaste> Fran pasted “CellularAutomaton.hs” at http://hpaste.org/49834
17:00:01 <kingping> Well, both Data.Either and Control.Monad.Instances live in package base.
17:01:09 <aavogt> zzo38: I don't think they can change the order the top level ones are run because that would break lots of code: you're allowed to reference things that have been defined by top-level splices above the current one being expanded
17:01:58 <franny> Hey, folks, I've been trying to wrap my head around multi-param type classes and I've been running into errors. Does anyone know what might be wrong with my code?
17:02:16 <franny> The error in question, on line 48: Could not deduce (Generation g i0 Bool)      arising from a use of `mapNextGeneration'
17:02:23 <dafis> kingping: but Control.Monad.Error is mtl
17:02:53 <franny> (Oh, and the code is the paste above, <http://hpaste.org/49834>)
17:03:46 <zzo38> aavogt: OK. Can you show me the document that says that?
17:03:55 <kingping> dafis: Indeed.
17:05:47 <rwbarton> franny: basically the problem is that there's no way for the compiler to determine what type to use for i
17:05:52 <dafis> franny: the compiler can't know which mapNextGeneration to use
17:06:56 <franny> rwbarton / dafis, is there something missing in my declaration/instances of Generation?
17:07:38 <rwbarton> perhaps you want a functional dependency from g to i and e?
17:07:41 <aavogt> zzo38: section 7.2 in the original paper
17:09:05 <rwbarton> that tells the compiler that for any type g there's only one pair of types i, e for which there's an instance Generation g i e
17:09:24 <rwbarton> which seems to make sense here because I guess g is the type of a grid and i is the type of an index into the grid and e is an element of the grid
17:11:56 <franny> rwbarton, ah, I added some functional dependencies and it looks like it compiled! Thanks :)
17:12:44 <dafis> franny: or you could use ScopedTypeVariables and tell the compiler which i to use (namely that from the sig) by giving an expression type signature (btw, you misspelled neighbour)
17:13:42 <Nisstyre> Any hints to understanding foldl defined in terms of foldr, but without giving it all away?
17:13:48 <dafis> but I think the FunDep is what you want
17:13:56 <rwbarton> there is no i in the type signature of life though
17:14:07 <rwbarton> well only in the context
17:14:10 <ddarius> Nisstyre: Solve it the same way you solve any "express this as a foldr" problem.
17:14:27 <dafis> rwbarton: yup, that I meant
17:14:44 <Nisstyre> ddarius: okay, so try to think of a final result and an accumulator function?
17:14:57 <rwbarton> so I guess you could get 'life' to compile but you wouldn't be able to use it
17:15:27 <franny> dafis, I'll add a synonym with the alternate spelling for British users. ;)
17:15:29 <dafis> rwbarton: true
17:15:40 <ddarius> Nisstyre: You can be much more directed than that.
17:15:49 <dafis> franny: very considerate
17:20:19 <franny> What I'm trying to build is a generic framework for cellular automata, where the rules and the universe contents are decoupled and generic as possible, so different rules, geometries, etc. are easy to fool with.
17:24:54 <kmc> franny, i'm suspicious of these heavily-typeclass-overloaded designs
17:25:11 <kmc> the best way to accommodate different behaviors in Haskell is to pass or store an ordinary function as an ordinary value
17:26:02 <_Ray_> Vague question. Is a battle hardened haskeller generally able to turn almost any program into a map & fold?
17:26:09 <kmc> no
17:26:24 <jfredett> _Ray_, kmc and further, why would they want to?
17:26:24 <lambdabot> jfredett: You have 1 new message. '/msg lambdabot @messages' to read it.
17:26:28 <kmc> well, able yes
17:26:33 <jfredett> ooh- messages. :)
17:26:39 <_Ray_> This comes from looking at things like MapReduce, where the entire model of computation is based on map and fold.
17:26:43 <kmc> because you can describe the state-evolution of a Turing machine as a fold
17:27:01 <kmc> but in general lots of things are not *conveniently* map or fold
17:27:02 <aavogt> kmc: those have shortcomings otherwise we wouldn't have fundeps and type families
17:27:17 <kmc> _Ray_, btw map is a special case of fold
17:27:25 <kmc> map f = foldr ((:) . f) []
17:27:27 <_Ray_> oh, right
17:27:31 <_Ray_> yeah, append to result
17:28:42 <kmc> what i said about turing machines isn't really usefully true
17:28:58 <kmc> the list you fold over is infinite and trivial
17:29:11 <franny> kmc, yeah, I might not be approaching this optimally, but it's helping me understand the type system more. :) I might refactor it later.
17:30:07 <Cale> You should think of foldr f z as replacing each (:) in the construction of the list with f and the [] at the end (if any) with z
17:30:32 <Cale> This process generalises to arbitrary algebraic datastructures
17:30:51 <Cale> So, for instance, if we have a datatype  data Tree a = Tip | Branch a (Tree a) (Tree a)
17:31:07 <Nisstyre> Cale: RWH uses that example when explaining fold
17:31:16 <Cale> there's a natural  foldTree tip branch = f where f Tip = tip; f (Branch x l r) = branch x (f l) (f r)
17:31:19 <Nisstyre> map as a fold that is
17:32:13 <_Ray_> oh, nice, hadn't thought of foldr like that
17:33:29 <Cale> Or:  data Nature a = Rock | Stream a (Nature a) | Tree (Nature a) (Nature a); foldNature r s t = f where f Rock = r; f (Stream x n) = s x (f n); f (Tree l r) = t (f l) (f r)
17:33:32 <Cale> for another example :)
17:34:09 <Cale> either and maybe are functions of this sort
17:34:12 <Cale> :t either
17:34:13 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
17:34:15 <Cale> :t maybe
17:34:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:34:22 <Cale> as well as uncurry
17:34:25 <Cale> :t uncurry
17:34:26 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
17:34:36 <Cale> though those are non-recursive examples
17:35:32 <jfredett> franny: just remember that premature abstraction is the root of all metaevil.
17:36:01 <ddarius> What's the root of all ortho- and para-evil?
17:36:22 <jfredett> ddarius: the dutch, on both counts.
17:37:08 <jfredett> (just kidding, I <3 the dutch)
17:39:26 <ddarius> jfredett: How was your amazing, world-spanning adventure?
17:40:10 <jfredett> ddarius: it was, I hope to never have to go on another one, but in the end, good things came of it.
17:54:33 <zzo38> Why is the original paper a A4 PDF? PDF is not a very good format and I don't have A4 size paper either.
17:55:04 <shachaf> PDF is pretty standard for papers. A4 is pretty standard for paper.
17:55:14 <zzo38> O, it says it is 8.5 x 11 in so probably it can work.
17:55:24 <dafis> shachaf: outside USA
17:55:48 <Jafet> Why? What's in the USA?
17:56:28 <zzo38> I live in Canada. But I have 8.5x11 paper so probably that is OK.
17:56:32 <dafis> Jafet: they use letter, slightly different format, but letter <-> A4 mostly works
17:57:18 <zzo38> However, I think the PDF format (and also PostScript) is dumb. DVI is better format I use it for all of my stuff.
17:59:49 <zzo38> Is it possible to use the "reify" command and add class instances to keep track of previous things?
18:10:09 <acowley> Man, OpenCL is really enticing. Totally crying out for a slick Haskell frontend.
18:14:49 <zzo38> Now I made the prettyprinting Haskell. There is a few things wrong with it (hopefully it can be corrected later), but it works from what I can figure out. Can you see?
18:16:40 <deech> Hi all, I'm having a type error that I can't seem to narrow to a smaller example, how do I go about troubleshooting "Couldn't match type `m1' with `m'; m1' is a rigid type variable bound by ...;" message?
18:17:07 <kmc> it matters more what the expressions are
18:17:18 <acowley> deech: the ... is where I'd start
18:17:37 <deech> ok, lemme paste.org it.
18:18:07 * ddarius opens his cheap crme caramel with dreadful hope.
18:18:17 <zzo38> Why does Haskell Platform so slow for downloading? Probably it contains a lot of things I don't need.
18:18:34 <kmc> it contains a lot of libraries
18:18:47 <kmc> also GHC itself is pretty big
18:18:51 <zzo38> Even MiKTeX, after I installed it, I uninstalled most of it because it installed too many things
18:19:10 * ddarius uninstalls most of Ubuntu
18:19:36 * djahandarie suggests LFS to ddarius
18:19:59 <kmc> zzo38, you're not required to use Haskell Platform
18:20:07 <kmc> it's just a collection of libraries available from Hackage
18:20:39 <kmc> like i said GHC by itself is pretty big, though
18:20:43 <kmc> are you on dialup or something?
18:20:50 <ddarius> Needs more Activa RM.
18:20:59 <zzo38> No. I am not on dialup I have cable modem
18:21:36 <deech> Ok, I've pasted it (http://hpaste.org/49835). It's not the full program but I hope it provides enough context.
18:21:43 * hackagebot vector-algorithms 0.5.2 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.5.2 (DanDoel)
18:22:08 <kmc> zzo38, how long is the download going to take?
18:22:33 <zzo38> It says, 2 minutes left (5 minutes elapsed)
18:22:41 <zzo38> Now it says 3 minutes left (6 minutes elapsed)
18:23:46 <zzo38> They don't know the exact time because the speed is changing sometimes
18:24:02 <danharaj> I know life is short, but it is not *that* short.
18:24:19 <kmc> getting 40 years of programming languages research in 10 minutes seems like a good deal to me ;)
18:24:26 <ddarius> Actually this separation may be intended.  It has carageenan and locust bean gum, which probably explains why it is too stiff.
18:24:29 <pedro3005> life isn't short, it's the longest thing you do
18:26:29 <zzo38> Can you look at the programs to format literate Haskell codes? There is a few things missing the second one, and a few things wrong, but the first one works.   http://sprunge.us/acFU   http://sprunge.us/cfgO
18:29:46 <zzo38> Why is it trying to install *everything* I don't want PDF or PostScript! I also don't want the GUI of it!
18:30:14 <kmc> Haskell Platform?
18:30:19 <kmc> again, you're not obliged to use it
18:30:33 <kmc> are you actually limited on disk space?
18:30:42 <QinGW> dead will be more long than life one do.
18:30:55 <danharaj> zzo38: If you care so much. Only download GHC. Don't download the Haskell Platform.
18:31:38 <kmc> i don't understand people who are offended by having software they don't need
18:31:50 <kmc> it's another thing if it's running and using RAM, or if you are low on disk space
18:32:23 <kmc> but i'd like to have as much as i can fit on my drive
18:32:29 <kmc> you never know when you need some specific tool
18:32:37 <zzo38> kmc: Now I already put Haskell Platform. I am not limited on disk space (since I never watch pornography), but there is a lot of files is useless to me.
18:32:42 <MaskRay> Why is `System.Timeout.timeout' unavailable for pure functions wrapped in `return'
18:32:52 <kmc> porn is streamable now
18:32:58 <kmc> MaskRay, it's available but probably not what you want
18:33:04 <parcs> some software is hooked into X and gets autostarted with it
18:33:08 <kmc> executing «return x» does not evaluate its argument before returning
18:33:15 <parcs> like console-kit-daemon
18:33:15 <kmc> MaskRay, look at Control.Exception.evaluate
18:33:30 <kmc> parcs, not if you write your own .xsession
18:33:33 <MaskRay> thanks, i'll look into it
18:34:11 <kmc> zzo38, I just don't see why you care
18:34:54 <zzo38> kmc: Well, I will just do with what I have.
18:35:12 <kmc> GHC also produces binaries in the MB range even for trivial hello world programs
18:35:16 <kmc> i bet you won't be happy about that either
18:35:54 <zzo38> kmc: Yes that is no good either. Most programs I would not use Haskell of course. I program most programs in Enhanced CWEB, or in LLVM.
18:36:06 <kmc> hahaha
18:36:14 <ddarius> w/w emulsions, interesting.
18:36:48 <kmc> i'm told that Enhanced CWEB has an "advanced preprepreprocessor"
18:36:58 <zzo38> kmc: Yes it does.
18:37:09 <ddarius> kmc: "You never know when you need some specific tool ..." to restore your internet connection.
18:37:36 <zzo38> Next version probably I will not only add a few things but also remove many things including PDF and stuff.
18:37:51 <zzo38> (As well as some of the preprepreprocessor commands that don't work will be removed)
18:38:02 <kmc> zzo38, do you also heat up your motherboard and remove all the peripheral chips you're not using?
18:39:12 <zzo38> kmc: No. I don't do these thing I have to deal with what I have instead. Next time I can just build a new computer maybe. I do know where I can get the equipment but currently I have not the space to put it in, and anyways I would still have to learn the Linux and other stuff a bit
18:39:54 <zzo38> (Advanced preprepreprocessor is very useful, do you think so? And anyways who told you that? Yes it is true but who told you anyways?)
18:40:02 <kmc> c2 wiki told me
18:40:06 <ddarius> @google quamachine
18:40:07 <lambdabot> http://www.badmintoncentral.com/forums/showthread.php/62637-Stringing-using-a-Hi-Qua-machine
18:40:08 <zzo38> OK.
18:40:12 <kmc> i have no idea if it's useful, since i haven't used it
18:41:09 <parcs> a statically-linked hello world in C is 676k. a statically linked hello world in haskell/ghc is 928k. that's not so bad
18:41:16 <MaskRay> kmc: How does evaluation influence `timeout's behavior?
18:41:32 <kmc> parcs, the GHC code still dynamically links libc, though
18:41:40 <kmc> MaskRay, I don't understand the question
18:41:49 <kmc> parcs, unless you did more tricks
18:41:53 <danharaj> Hello World in GHC comes with a world class RTS >_>
18:41:57 <zzo38> Of course one reason for using C at all is because the C code can work for many computers.
18:42:03 <ddarius> kmc: If it was useful, you would have used it.  Therefore, it is useless.
18:42:25 <kmc> zzo38, you can get microcontrollers with a whole computer in a single chip, but they'll still have lots of peripherals you have no need for
18:42:30 <deech> Hi all, need some advice. I have several function that return different types in the same monad, so f1 :: m a, f2 :: m b etc. I need to store them all in the same map, so I've created a typeclass "T" that has the common functions and created unifying data type, data A = forall a. T a => A a. Is this the right way to do it?
18:42:39 <kmc> so you'd probably need to get a powerful laser and carefully burn out those parts of the die
18:42:48 <kmc> deech, those aren't functions, unless m = ((->) r)
18:42:54 <ddarius> kmc: Or not get a SoC.
18:43:13 <mauke> deech: why not just use a variant type?
18:43:21 <mauke> data A = A a | B b
18:43:31 <kmc> data Thing = ThingA (M A) | ThingB (M B)
18:43:39 <mauke> kmc: without the M, I think
18:43:43 <kmc> ok
18:44:05 <kmc> the complicated typeclass + existential approach is popular, but it's only really a good idea when you need to allow others to extend that variant type
18:44:12 <kmc> as with Control.Exception
18:44:55 <deech> kmc: That's what I was going for, but am failing miserably (http://hpaste.org/49835).
18:45:06 <kmc> which?
18:45:17 <deech> kmc: The typeclass approach.
18:45:20 <kmc> but why?
18:46:40 <zzo38> kmc: Yes I know some things about microcontrollers but not a lot of things. But I think there are many kinds so I can find which one is suitable for whatever I am using it with.
18:47:13 <deech> Because I'm getting the error shown in the paste. Near as I can tell, the 'm' in the type signature of zip'simple is required to be the same as the 'm' in the class definition, but I don't know how to do that.
18:47:37 <kmc> deech, I mean, why are you using the typeclass approach as opposed to something simpler
18:48:08 <ddarius> Unless you're rolling out 10,000 radios, it's often cheaper and easier to get a microcontroller that is more featureful than you need.
18:48:28 <kmc> nobody uses exactly the microcontroller you need
18:48:37 <kmc> even if you are getting custom silicon, you'll design in some margin
18:48:49 <deech> kmc: I wanted to give it a shot and it's part of a web framework I'm trying to build.
18:49:45 <ddarius> Yay ASIC.
18:56:07 <parcs> with libgmp, libm, librt, libdl, libpthread and libc statically linked, a threaded ghc hello world binary is 1536k. not bad at all :)
18:57:08 <parcs> strangely the binary doesn't link correctly without -threaded
18:57:58 <zzo38> One program I used the Enhanced CWEB is TeXnicard. It is not written in Haskell and I don't plan to; however, some of my ideas and interest about Template Haskell are related. Such as, using Template Haskell in one of the external utility programs, related to the rules if there can be a rulebook program in Template Haskell. Other things too, though.   https://devlabs.linuxassist.net/projects/texnicard
19:09:07 <mustelo> does anyone have tips on how to pull line number information through parsec so I can give good error messages even after parsing succeeds?
19:10:27 <zzo38> Is there a program for making something similar to the rulebook features of Inform 7 using Template Haskell? I would like to do something similar, but not quite exact to that. So, if there is such a program I can learn it and make a modified one with new things on it
19:10:36 <tsuraan> what do you do to debug unknown symbol errors?
19:11:04 <tsuraan> whether I compile with ghc 6.12.3 or 7.0.3, I'm getting nearly the same missing symbol error, with pure haskell code
19:11:21 <kmc> tsuraan, are you using ghc --make?
19:11:24 <kmc> that's the default in GHC 7 though
19:11:29 <kmc> what's the unknown symbol?
19:11:30 <tsuraan> no, cabal build
19:11:37 <tsuraan> hszmcabinetzm0zi1_NetworkziProtocolziCabinetProtoziCabinetziCheckFileUpload_CheckFileUpload_con_info
19:11:41 <tsuraan> that's 7.0.3
19:11:48 <tsuraan> hszmcabinetzm0zi1_NetworkziProtocolziCabinetProtoziCabinetziResponse_zdfWireResponse3_closure
19:11:51 <tsuraan> for 6.12.3
19:11:54 <kmc> preflex, zdec hszmcabinetzm0zi1_NetworkziProtocolziCabinetProtoziCabinetziCheckFileUpload_CheckFileUpload_con_info
19:11:54 <preflex>  hs-cabinet-0.1_Network.Protocol.CabinetProto.Cabinet.CheckFileUpload_CheckFileUpload_con_info
19:13:44 <tsuraan> is that saying there should be some con_info "field" of the CheckFileUpload type?
19:14:17 <kmc> no
19:14:30 <kmc> con_info is a GHC internal thing
19:14:44 <gienah> zzo38: I don't really know, I'm trying to hack stuff with template haskell, it does look really powerful like you can do just about anything
19:15:13 <tsuraan> I am trying to create a CheckFileUpload when this undefined symbol hits
19:15:22 <tsuraan> if that helps any...
19:16:55 <tsuraan> hm, but a different CheckFileUpload.  It shouldn't break things having two different modules exporting types with the same name, should it?
19:16:57 <gienah> @google "Implementing Functional Generic Programming" Ulf Norell
19:16:59 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.63.6136
19:17:06 <zzo38> gienah: OK. What have you done with it by youself?
19:17:07 <tsuraan> one is internal, generated by protocol buffers
19:17:45 <gienah> zzo38: I'm only just starting, so not much so far
19:17:46 <kmc> tsuraan, no, I wouldn't expect that to break at the linker stage
19:19:41 <tsuraan> heh, renamed my types that had the same names as the internal pbuffer types, and it didn't help (not surprisingly)
19:20:22 <kmc> tsuraan, does your cabal file list the hs-cabinet dependency?
19:20:35 <kmc> do you have two modules with the same name in two different packages?
19:22:09 <tsuraan> there shouldn't be anything else exporting (or even using) the Network.Protocol.CabinetProto namespace, but is there some way I can check that?
19:22:38 <tsuraan> hs-cabinet is the library I'm working on, so nothing is depending on it yet
19:22:40 <tsuraan> as far as I know
19:22:42 <tsuraan> hm
19:22:54 <gienah> zzo38: Ulf Norell's thesis has some template haskell stuff in it
19:23:20 <tsuraan> no, at least no installed library is depending on hs-cabinet
19:24:43 <zzo38> gienah: Who is Ulf Norell? And what kind of template haskell stuff does it have?
19:26:30 <gienah> zzo38: he's a haskell hacker that does lots of stuff with generic programming, the thesis is in the google lambdabot result up about 20 lines
19:27:23 <gienah> zzo38: it has printf implementing in template haskell, then more stuff
19:28:09 <tsuraan> oh, weird.  I just added the module that was breaking things into the exposed-modules of my .cabal file, and now it works
19:28:46 <tsuraan> so I guess I have a larger API than desired, but it works now
19:29:26 <tsuraan> none of my public function return anything from the internal modules, so I'm not sure what I did to break things
19:29:38 <dmwit> tsuraan: Was that module in your other-modules: before?
19:29:44 <dmwit> If not, have you tried putting it there?
19:30:01 <tsuraan> other-modules?  no, I don't have one of those
19:30:09 <tsuraan> I've never even seen that directive
19:30:39 <tsuraan> do I need to list every module in my project under one of those two?
19:30:45 <dmwit> Yes.
19:31:21 <tsuraan> oh weird.  I guess I've been getting lucky.  Is that for libraries, or executables as well?
19:31:29 <dmwit> Executables, too.
19:31:58 <tsuraan> wow, that's really strange.  cabal finds everything on its own; I figured it was just working :)
19:32:38 <dmwit> The cabal documentation corrects me: modules must be listed in one of other-modules, exposed-modules, or main-is.
19:32:56 <tsuraan> if I list all the internal modules under other-modules, my library works just fine. I guess I'll be using that other-modules thing from now on
19:33:13 <tsuraan> cabal should get a new error message then :)
19:33:40 <dmwit> hm
19:33:52 <dmwit> Should cabal search your entire hard drive for .hs files, just in case? =P
19:34:23 <mustelo> better do a google search for them too
19:34:31 <tsuraan> well, when you're building an executable, it finds all the dependencies of main-is on its own, as well as all the dependencies of everything listed in exposed-modules
19:34:54 <tsuraan> but if you don't list those files yourself under other-modules, it can (but won't always) result in broken libraries or programs
19:35:07 <dobblego> dmwit: lenses do not "fan out" (there is no (&&&)) however, taking just the "get" they do -- do you know of a "next best thing" for a lens?
19:36:13 <dmwit> dobblego: Lenses don't have (&&&), but they do have fst, snd, and (***); symmetric lenses also have the opposite of fst and snd.
19:36:41 <dmwit> dobblego: There are some folks that work on something similar to lenses that, instead of having round-trip laws, have round-trip-and-a-half laws; these are generally not total, but can do (&&&).
19:36:45 <dobblego> dmwit: yeah I read your paper -- that's as far as I had got too
19:36:57 <dobblego> ok cool, didn't know that
19:37:06 <dmwit> Using them is a bit frustrating, because it's never clear whether the input you have in your hand is going to make it through the lens. You just have to try it and see.
19:38:42 <dobblego> I wonder if: Lens a b -> Lens a c -> a -> (b, c) would be useful
19:39:09 <dmwit> dobblego: See, for example, "A programmable editor for developing structured documents based on bidirectional transformations", I think they do round-trip-and-a-half laws.
19:39:18 <dobblego> ok thanks!
19:39:47 <dmwit> You can implement foo :: Lens a b -> Lens a c -> a -> (b, c) on top of lenses, if you like.
19:39:56 <dmwit> foo k l a = (get k a, get l a)
19:40:06 <dobblego> yeah just wondering if it is a worthy function
19:40:14 * dmwit shrugs
19:48:48 <dmwit> dobblego: Just to be clear: even for round-trip-and-a-half lenses, it's not really possible to support a fully-polymorphic (&&&).
19:49:02 <dmwit> You essentially need some kind of merge operation of type a -> a -> a.
19:49:15 <dmwit> So you have to specialize to types that you know how to merge.
19:50:32 <kmc> monoid?
19:50:42 <copumpkin> semigroup?
19:50:58 <dmwit> Yeah, semigroup.
19:51:00 <kmc> magma
19:51:10 <dolio> lava
19:51:14 <dmwit> But you probably also want a law like (merge a a = a).
19:51:20 <dmwit> So... not semigroup, really.
19:51:37 <copumpkin> idempotent commutative semigroup? a.k.a. a semilattice?
19:51:46 <dmwit> In fact, you might want to violate merge a (merge b c) = merge (merge a b) c.
19:51:54 <copumpkin> okay :P
19:51:59 <dmwit> don't really know though
19:52:09 <dmwit> I haven't thought about it too much.
19:52:12 <dmwit> I probably ought to.
19:52:17 * copumpkin is just spouting out random words
19:53:52 <dmwit> In reality, you probably want merge to be some IO type that gets the user involved sometimes. =P
19:54:24 <copumpkin> screw the user!
19:54:29 <kmc> octopus merge!
19:54:38 <dmwit> You have all seen the "A Formal Investigation of Diff3" paper, in which they discover that basically none of the properties you might expect of diff3 actually are true?
19:55:17 <copumpkin> nope
19:55:27 <dobblego> dmwit: what is the signature for that?
19:55:40 <dmwit> dobblego: For what?
19:55:46 <dmwit> You mean "merge :: a -> a -> IO a"?
19:55:51 <dmwit> Or for diff3?
19:56:13 <dobblego> I mean the (&&&) operation requiring a merge
19:57:10 <dmwit> dup :: (a -> a -> a) -> X a (a, a)
19:57:12 <dmwit> I guess
19:57:44 <dmwit> though in the paper I suggested it's more like
19:58:16 <dmwit> well
19:58:18 <dolio> That's okay. diff3 does the Right Thing for Real World cases.
19:58:33 <dmwit> dolio: Does it? I'm not convinced...
19:58:37 <dobblego> is it possible to model these symmetric and round-trip-and-a-half lenses in haskell easily? (I'm a bit vague on it, you see)
19:58:49 <dolio> I guess you're not a git user?
19:58:57 <dmwit> Anyway, the caveat there is that the "a"s in the paper I linked may have delayed edits marked inside the value.
19:59:03 <dobblego> well, I saw symmetric lenses easily enough
19:59:29 <dmwit> dobblego: I'm working on a symmetric (edit) lens library right now, actually.
19:59:34 <dobblego> linky?
19:59:48 <dmwit> not publically available yet, but expect a Hackage upload in the next week or two
19:59:53 <dobblego> sweet cheers!
20:00:12 <dmwit> dolio: I use git. I've also seen merges go horribly wrong.
20:00:31 <dmwit> dolio: I've also seen merges report success, and do the wrong thing.
20:00:45 <dolio> Pah. You must have been doing something contrived! :)
20:00:59 <dmwit> heh
20:01:02 <dobblego> I am reasonably confident we have "reinvented" these lenses that require a merge in production -- someone else wrote them and I thought, "that's a lens, except no (&&&)" and I have twiddled it a tad but haven't fully realised it
20:01:43 <andares> what is a lens?
20:02:19 <dmwit> andares: A lens is just a way of packaging up two transformations, one roughly from A to B, and the other roughly from B to A, that behave in a nice way.
20:02:30 <kmc> andares, generally a pair of a getter and a setter
20:02:38 <dmwit> andares: Any time you have two pieces of data that need to be kept in synch, you should think of using a lens. =)
20:02:42 <dobblego> data CoState a b = (a -> b) a; newtype Lens a b = Lens (a -> CoState b a)
20:02:58 <kmc> hmm, that's different from what I said
20:03:02 <andares> hm, I don't know enough Haskell yet to understand.
20:03:08 <andares> I shall keep learning.
20:03:50 <dmwit> andares: They're not Haskell-specific; dobblego just used Haskell syntax to illustrate because this is #haskell.
20:04:04 <kmc> andares, what i"ve seen called "lens" is perhaps simpler:  data Lens structure field = Lens (structure -> field) (field -> structure -> structure)
20:04:07 <kmc> a getter and a setter
20:04:33 <dmwit> kmc: That's isomorphic to dobblego's: just observe that both functions have a "structure" argument and factor it out.
20:04:39 <kmc> ok
20:04:43 <dmwit> structure -> (field, field -> structure)
20:04:45 <kmc> right
20:05:11 <kmc> andares, one thing it solves is the problem where Haskell record labels are not first-class
20:05:17 <kmc> i.e. there's no way to write this function
20:05:30 <kmc> f label value rec = rec { label = value }
20:05:57 <kmc> but if instead of using the labels built into Haskell, you use lenses, then you can do things like this
20:06:06 <kmc> andares, http://hackage.haskell.org/package/fclabels has good examples
20:06:29 <dobblego> dmwit: is there a haskell notation for round-trip-and-a-half lenses somewhere?
20:06:41 <dmwit> I don't believe so.
20:07:22 <dobblego> hmm buggery
20:13:14 <dobblego> google search term for these things?
20:15:06 <dmwit> Not sure.
20:15:06 <kmc> by the way, I'm still looking for a good example of a search problem that can be solved in one slide of Haskell code and then parallelized
20:15:13 <kmc> something like n-queens -- that's my current best idea
20:15:18 <dmwit> "Inv" and "X" seem to be the names of the bidirectional languages that use this.
20:15:21 <kmc> (well, not my idea -- it was suggested here)
20:15:24 <dmwit> But those are a bit un-googleable.
20:16:47 <dmwit> kmc: http://brainden.com/number-puzzles.htm ?
20:17:01 <kmc> nice
20:17:18 <kmc> maybe some PE problem too
20:17:22 <kmc> i'll take a look
20:18:37 <kmc> thanks
20:20:04 <acowley> dmwit: re SO, do you get the same problem if you break things up into two browse invocations?
20:20:35 <dmwit> If I break it up, the log-in information is lost.
20:21:40 <dmwit> (But if I remove the "sleep" it works fine. In case that answers your question.)
20:22:38 <acowley> No, I was just thinking that the connection is dropped after the first response
20:22:55 <acowley> so just having two browse actions might re-initialize the connection
20:23:12 <acowley> you can get the browser state
20:23:21 <dmwit> How?
20:23:24 <acowley> and then reuse it on the subsequent action
20:23:49 <acowley> getBrowserState?
20:24:16 <dmwit> hm
20:24:19 <dmwit> annoying
20:24:55 <acowley> I don't know that it would fix the problem, it's just an idea
20:25:15 <dmwit> let me try it
20:27:20 <dmwit> hm
20:27:37 <dmwit> The code I pasted no longer seems to work, even on Linux. O_o
20:28:00 <dmwit> acowley: But yeah, saving the state and restoring it doesn't seem to help at all.
20:28:29 <dmwit> using getBrowserState/withBrowserState, that is
20:28:35 <acowley> dmwit: hmph, sorry. I don't have access to a Windows system at the moment so can't try anything
20:28:40 <acowley> dmwit: still the same error?
20:28:44 <dmwit> same error
20:29:00 <acowley> So weird, why is HTTP thinking the connection should still be open?
20:30:52 <gwern> @quote easier.*write
20:30:53 <lambdabot> No quotes match. You untyped fool!
20:30:56 <gwern> @quote easier
20:30:56 <lambdabot> pumpkin says: sounds like a lot of work! it's easier for me to just bitch about it
20:30:58 <gwern> @quote easier
20:30:59 <lambdabot> pumpkin says: sounds like a lot of work! it's easier for me to just bitch about it
20:31:00 <gwern> @quote easier
20:31:00 <lambdabot> Athas says: I like Lisp for its extreme expressivity, but I think it's easier to make Haskell more powerful, than to make Lisp more statically safe.
20:31:04 <gwern> bah
20:31:11 <gwern> @quote understand.*an
20:31:11 <lambdabot> <glguy> says: When I said that it only takes a few hours to understand the types I didn't mean that you only had to do it once
20:31:20 <gwern> @quote understand.*a.*correct
20:31:20 <lambdabot> No quotes match. You type like i drive.
20:31:30 <gwern> guess I didn't include that Perlis quote
20:31:48 <kmc> haha
20:31:57 <kmc> i like glguy's quote
20:32:09 <gwern> @remember AlanPerlis It is easier to write an incorrect program than understand a correct one.
20:32:09 <lambdabot> Done.
20:32:12 <gwern> @flish
20:32:22 <acowley> dmwit: maybe you could explicitly close the connection from within HTTP. My guess at this error would be that the server is closing the connection, so you would then need to either close and re-open it yourself, or at least explicitly check its state yourself before the second transfer
20:32:32 <kmc> i'm actually playing down types in my "why you should learn haskell" talk
20:32:41 <ericjet19> What is trying to be done?
20:32:47 <kmc> not that i think they're not important, or even that the audience would react poorly (some would)
20:33:06 <kmc> it's just not that central to the point i'm trying to make
20:33:36 <kmc> and i don't think I can present compelling evidence for the core claim -- "your program will likely work once it passes the type checker" -- in a few slides
20:35:02 <ddarius> kmc: I doubt that is something that can be meaningfully conveyed in slide form regardless of the number of slides.
20:36:15 <ericjet19> I'm sorry, but what is it you guys are talking about?
20:36:59 <ericjet19> Lol I have nothing to do (downloading Haskell on dial-up)
20:37:12 <mauke> what do you mean by "Haskell"?
20:37:34 <ericjet19> I'm downloading the package from the main page
20:37:35 <ddarius> kmc: The best you could do is literally show the iterations of code you attempted to compile and type error from an actual development session.
20:37:49 <ddarius> mauke: He's downloading the bits of Mr. Curry.
20:38:00 <kmc> ericjet19, Haskell is not software
20:38:22 <kmc> it's a document describing a programming languag
20:38:22 <mauke> ericjet19: which package from what main page?
20:38:24 <ericjet19> It is a programming language, I know
20:38:31 <kmc> maybe you are downloading that document
20:38:46 <ericjet19> Im downloading the installer of the core components
20:38:49 * kmc has a little map/territory confusion there
20:38:55 <ddarius> kmc: It's the programming language described by the document, not the document.
20:38:56 <ericjet19> lol
20:39:04 <kmc> ericjet19, GHC and/or Haskell Platform, probably
20:39:12 <dmwit> acowley: Hm, after a bit more testing, it seems to be a HTTP-3000 vs HTTP-4000 thing, not a Linux vs Windows thing.
20:39:17 <dmwit> So, that's interesting.
20:39:17 <kmc> GHC is the most popular implementation of the standard Haskell language
20:39:21 <kmc> @where GHC
20:39:21 <lambdabot> http://haskell.org/ghc
20:39:28 <andares> kmc: why should I learn Haskell?
20:39:32 <dmwit> acowley: Gotta run for a bit.
20:39:33 <andares> I mean, I am, I was just wondering about reasons. :p
20:40:09 <andares> also vim is being infuriating about smart tabbing in my .hs files. I wonder if I haven't set something.
20:40:11 <kmc> andares, because it's a programming language carefully designed by people who knew what the hell they were doing and had done their homework
20:40:20 <ericjet19> I am so used to java... a little too much. thought I might look into haskell though (a friend recomended it to me)
20:40:24 <kmc> andares, and for whatever reasons, that's very rare
20:40:38 <gienah> andares: I learn haskell because I'm totally unqualified to write code in Java or C# :-)
20:40:50 <ericjet19> lol
20:40:53 <poltak> gienah: explain
20:41:14 <andares> I feel unqualified in those languages too. :p have to for work though until the summer ends.
20:41:36 <gienah> poltak: I have almost zero commercial programming experience in Java and C#, so am very unlikely to find employment in those languages
20:41:52 <ericjet19> One of my friends told me haskell was a simpler language, so I wanted to try it out..
20:41:57 <gienah> so I learn Haskell as its far more interesting anyway
20:41:59 <poltak> gienah: learn haskell?
20:42:04 <andares> gienah: are you a mathematician?
20:42:12 <andares> I think it's easier for mathematicians to learn.
20:42:17 <gienah> no I'm a programmer (interested in maths)
20:42:19 <ericjet19> lol
20:42:20 <mauke> gienah: are you a wizard?
20:42:33 <poltak> he's not a wizard guys
20:42:35 <kmc> ericjet19, Haskell is simple the way Go is simple -- not the programming language, but the ancient chinese board game
20:42:35 <gienah> no, but I wish I was :-)
20:42:38 <andares> yer a wizard harry!
20:43:53 <ericjet19> Point is I thought it'd be a little interesting to try and learn a new programming language
20:44:02 <kmc> it is interesting :)
20:44:05 <poltak> ericjet19: and how are you finding it so far?
20:44:07 <kmc> and it really is a new language
20:44:07 <ddarius> ericjet19: You should be learning many new languages.
20:44:15 <kmc> not just new syntax for Java concepts
20:44:38 <ericjet19> poltak, I am still downloading...
20:44:46 <ericjet19> Dial-Up :(
20:44:50 <Axman6> :(
20:44:56 <kmc> ericjet19, tryhaskell.org
20:45:01 <gienah> haskell is really powerful for writing compiler stuff like processing ASTs (Abstract Syntax Trees), trying to walk ASTs using visitor patterns or heirarchical visitor patterns in Java is difficult
20:45:15 <shachaf> 1987 isn't *that* new.
20:45:42 <poltak> shachaf: java isn't 1987
20:45:47 <shachaf> Haskell is.
20:45:49 <kmc> shachaf, recall that C++ and Java are yet to reach 1936
20:45:49 <andares> gienah: are you using learn you a Haskell?
20:45:50 <ddarius> Java is 1995.
20:45:52 <shachaf> Well, kind of.
20:46:04 <gienah> andares: yes
20:46:14 <kmc> andares, the thesis of the talk i'm preparing (thanks cmccann) is that Haskell is unusually well-suited to writing composable code
20:46:27 <kmc> that is, writing pieces which can be combined in flexible yet well-defined ways
20:46:32 <kmc> without an explosion of complexity
20:46:32 * ddarius blames purity.
20:46:49 <kmc> of course the same claim has been made of the OOP "paradigm" and of pretty much every programming language
20:46:57 <kmc> so i have a bunch of examples
20:47:04 <ericjet19> I know enough of java that ive made 3 games, and a simple UI that speaks (The speech required a small library)
20:47:51 <acowley> Arguing programming language virtues is a pretty tough game
20:48:00 <acowley> most languages have high points
20:48:10 <ericjet19> On the other hand, I only know enough C++ to make a basic user console...
20:48:35 <kmc> acowley, well, the mere fact that examples of Haskell high points fit on a single slide is a point in Haskell's favor
20:48:50 <andares> eh, you know one OOP-based procedural language, you know them all.
20:49:11 <kmc> andares, how well do you know C++?
20:49:16 <kmc> C++ is an *extremely* unusual language
20:49:32 <ddarius> C++ -is- a rather unusual language.
20:49:33 <ericjet19> I've been using C++ for processing heavy applications and java for UIs for a while now. my question about Haskell for one, is whether or not it is compiled?
20:49:37 <kmc> arguably it is further from Java than Haskell is from Python
20:49:40 <acowley> kmc: Oh, I agree! It's just that there are undoubtedly cases where Java is just the right language. You want to argue Haskell's virtues without making it too combative, imho.
20:49:59 <kmc> certainly, writing C++ as if it were Java will produce much worse outcomes than writing Haskell as if it were Java or Python
20:50:07 <kmc> i'm not kidding when I classify C++ as an esolang
20:50:09 <ericjet19> my biggest issuewith java is speed
20:50:15 * ddarius is not really sure there are cases where Java is the "right language."
20:50:15 <gienah> ericjet19: haskell is compiled
20:50:25 * ddarius thinks there are plenty of cases where the JVM is the right platform.
20:50:26 <kmc> ericjet19, the Haskell standard does not mandate a compiler
20:50:39 <kmc> ericjet19, GHC, the most popular implementation of the Haskell standard, is an optimizing ahead-of-time native-code compiler
20:51:05 <ddarius> The Haskell standard doesn't even provide a basis for talking about compilation.
20:51:08 <andares> kmc: not very well.
20:51:09 <Cale> The Haskell standard doesn't even specify an ordering of evaluation.
20:51:13 <ericjet19> Will Haskell code run generally faster than java code?
20:51:18 <kmc> ericjet19, that's a meaningless question
20:51:26 <kmc> which Haskell implementation? which Java implementation? which code?
20:51:40 <kmc> ericjet19, see http://shootout.alioth.debian.org/
20:51:59 <Cale> Haskell compilers normally don't compile Java code, and Java compilers stubbornly refuse to compile Haskell code as well...
20:52:14 <ericjet19> not what I mean
20:52:23 <ericjet19> I can learn a new language
20:52:27 <Cale> (so it's hard to write the same program and compare :)
20:52:32 <andares> you can probably do all kinds of optimizations with Haskell at compile-time, right?
20:52:37 <andares> that are provably correct?
20:52:37 <Cale> But you can get decent performance from GHC for most tasks.
20:52:45 <Cale> andares: sure
20:53:08 <kmc> andares, yeah.  for example GHC's inliner is *very* aggressive
20:53:13 <andares> do I have to worry about writing inefficient functional code, or does the compiler "reduce" what I write somehow?
20:53:22 <kmc> andares, some of each
20:53:37 <andares> I guess I got into trouble with the exponential Fibonacci thing.
20:53:37 <gienah> ericjet19: learning haskell seems useful for programming in C++, as they are both strongly typed, they both use parametric polymorphism, C++ has some limited functional programming stuff in the STL and Boost
20:53:48 <kmc> andares, you should not expect GHC to make your beautiful idiomatic functional Haskell run as fast as nasty hand-tuned C code
20:53:55 <ericjet19> my question is which would be better to use for speed, java or Haskell... I always notice faster speed in a C++ program for instance
20:53:59 <Cale> Learning Haskell will make you not want to program in C++ anymore though.
20:54:05 <andares> gienah: you can apparently actually do a lot of functional stuff with C++ templates.
20:54:06 <mauke> gienah: since when does C++ use parametric polymorphism?
20:54:14 <kmc> ericjet19, we cannot answer that question unless you are much more specific
20:54:18 <ddarius> kmc: Occasionally it does just hat.
20:54:22 <ddarius> s/hat/that/
20:54:26 <kmc> andares, but it will get decently close, and you'll spend much less time getting the Haskell code working
20:54:27 <ddarius> But usually not.
20:54:35 <kmc> and you can use the time savings to optimize the parts that actually matter
20:54:39 <acowley> ddarius: arguing "right" is hopeless, the point more is that plenty of smart people write clever code in Java. To set things up that must demonstrate superior versions of anything they can do is wrong headed.
20:54:41 <kmc> which usually is not much of the program
20:54:50 <gienah> mauke: maybe I misunstand, it seems C++ templates are like parametric polymorphism
20:54:52 <ericjet19> nevermind lol I'll wait for the download to finish in a week or two...
20:55:10 <Cale> ericjet19: heh, what are you downloading?
20:55:26 <kmc> gienah, C++ templates are a metaprogramming system that thinks it's a macro system that thinks it's an implementation of parametric polymorphism
20:55:26 <pikhq_> gienah: More like type-level strict lambda calculus.
20:55:38 <kmc> gienah, they are not actually good for any of those three things
20:55:43 <Cale> The GHC binary is package is only ~100MB :P
20:55:44 <ddarius> pikhq_: It's not strict.
20:55:46 <Cale> -is
20:55:48 <mauke> andares: I'd say it's not that templates are good way to do functional programming, it's that the only things you can do with templates are strictly within the confines of functional programming
20:55:59 <kmc> i was not kidding when I said C++ is an esoteric language.  you will find nothing quite like C++ templates anywhere else
20:56:02 * ddarius downloaded all the SICP lectures over dialup.
20:56:27 * ddarius could only fit two or so at a time in the space he had available on his hard drive at the time.
20:56:34 <andares> mauke: it's definitely not a good way, for sure. but I think I remember a blog where somebody bootstrapped a lot of lambda calculus using C++ templates.
20:56:34 <ericjet19> http://hackage.haskell.org/platform/
20:56:41 <ericjet19> that is what im downloading
20:56:47 <mauke> ericjet19: the platform?!
20:56:52 <ericjet19> The HUGE platform
20:57:16 <ddarius> kmc: C++ puts a purely functional lazy programming language into its type system.  Haskell puts a deterministic logic programming language.
20:57:20 <ericjet19> JDK and the C++ compiler together werent this Huge
20:57:29 <andares> oh, does anyone know anything about House? it's apparently a research OS written in Haskell.
20:57:35 <kmc> ddarius, can a deterministic logic programming language be called a logic programming language?
20:57:39 <Cale> It's only 90MB. I average 4GB/day .___.
20:57:46 <ddarius> kmc: Why not?
20:57:50 <kmc> shrug
20:57:51 <ericjet19> I have dial-up
20:58:00 <ericjet19> 5KB/sec
20:58:02 <andares> ericjet19: where do you live?
20:58:04 <Cale> nice
20:58:08 <ericjet19> 25MB a day
20:58:11 <kmc> andares, note that you can also write your speed-critical function in C and the rest of the app in Haskell
20:58:17 <andares> ericjet19: also isn't IRC great? IRC doesn't care about your connection speed. :p
20:58:31 <ericjet19> I live in the middle of nowhere
20:58:32 <Cale> Might as well have someone fedex you a CD of it :)
20:58:47 <andares> ericjet19: satellite internet?
20:58:51 <andares> they still have that, right?
20:58:57 <ericjet19> cant afford that
20:58:57 <kmc> andares, so if it takes (made up numbers ahead!) 10 hours to get C code working, 1 hour to get Haskell code working, and 1 hour to get the C / Haskell interface working, then you lose at most 20% by writing it first in Haskell
20:59:19 <ericjet19> I can afford DSL but the lines are too old
20:59:21 <kmc> andares, and you can run automated tests of your fast C code against the naive-but-probably-correct Haskell code
20:59:35 <andares> kmc: and a lot of the hand-tuned optimizations are actually detrimental (see Duff's device.)
20:59:44 <andares> because the compiler is smarter than the average bear these days.
20:59:51 <kmc> right, C compilers have gotten a lot smarter since those tricks were invented
21:00:01 <ericjet19> lol
21:00:04 <ddarius> If you are the average bear, you are probably not hand-tuning at all.
21:00:20 <kmc> ericjet19, can you go to some school / work / library with a USB stick and download files?
21:00:31 <andares> sneakernet!
21:00:34 <ericjet19> yes, but only once a week...
21:00:38 <ericjet19> only 15...
21:01:07 <kmc> ericjet19, if you want to get started with Haskell sooner, you can a) http://tryhaskell.org/ , runs in your browser, b) download Hugs, a small Haskell interpreter, c) download binaries for GHC itself without all the Platform libraries
21:01:15 <ddarius> We don't want those 15 year olds hanging around the libraries too much.
21:01:27 <ericjet19> LOL
21:01:33 <andares> you could download the spec and write a small Haskell interpreter in C. :p
21:01:39 <ericjet19> :D
21:01:50 <andares> it's not too hard to write a Scheme interpreter, actually.
21:01:50 <ericjet19> Will do! NOT
21:01:56 <andares> you should make Scheme and then make Haskell in Scheme.
21:01:58 <ericjet19> or maybe
21:02:01 <ddarius> andares: Haskell is not Scheme.
21:02:13 <ericjet19> OMG this is entertaining
21:02:17 <kmc> ericjet19, Platform is getting you OpenGL, network libs, parser libs, HTTP libs, ...
21:02:20 <kmc> that's why it's so big
21:02:42 <andares> ddarius: of course. but it's another functional language (although impure.)
21:02:46 <andares> and great to learn on imo.
21:02:46 <kmc> ericjet19, could you please not say inane things?
21:02:53 * kmc realizes this is a somewhat hypocritical request
21:03:24 <andares> kmc: do you know the LoC on Hugs? I was wondering how complicated writing a Haskell interpreter would be.
21:03:26 <ddarius> andares: Haskell is much more difficult to implement than Scheme.
21:03:29 <ericjet19> maybe
21:03:35 <kmc> andares, a lot more complicated in C :)
21:03:38 <kmc> andares, but no I don't know
21:03:54 <andares> the hard part seems to be the pattern matching.
21:04:00 <kmc> Hugs is written in C... a Haskell interpreter in Haskell would be a lot shorter, even if you don't cheat
21:04:02 <andares> among other things.
21:04:04 <ddarius> No, that's pretty easy.
21:04:09 <ddarius> The hard part is the type system.
21:04:30 <kmc> it's pretty easy to desugar Haskell's full pattern matching into forms that check exactly one constructor at a time
21:04:44 <kmc> which (if you compile the way GHC does) turns into a call and a C "switch"
21:04:48 <kmc> and if you interpret is even easier
21:04:50 <ericjet19> wait... are you talking about writing an interpreter || compiler in haskell?
21:05:06 <danharaj> interpreter, compiler. same thing.
21:05:10 <kmc> ericjet19, that's one of the best applications for Haskell
21:05:11 <ericjet19> NO
21:05:14 <andares> kmc: wait, does GHC compile Haskell into C+
21:05:15 <andares> *?
21:05:19 <kmc> andares, into C?
21:05:33 <kmc> GHC can compile into awful platform-dependent C
21:05:39 <kmc> that's no longer the preferred mode
21:05:39 <danharaj> not anymore
21:05:45 <danharaj> -fvia-c got removed
21:05:49 <kmc> danharaj, in 7.2?
21:05:50 <ericjet19> danharaj: a compiler converts code to executable format, an interpreter executes instructions
21:05:52 <danharaj> I think so?
21:05:58 <mauke> heh
21:06:05 <kmc> ericjet19, http://blog.sigfpe.com/2009/05/three-projections-of-doctor-futamura.html
21:06:07 <mauke> then how can you port ghc to a new platform?
21:06:12 <kmc> ericjet19, read that article
21:06:20 <kmc> mauke, unregisterised LLVM maybe?
21:06:40 <Cale> Write a compiler in Haskell and then bootstrap it by executing the code by hand on paper. Show your work in the form of a line-by-line derivation of the result of the compilation.
21:06:41 <danharaj> maybe one of the guys who ported it to the iPhone can describe the process.
21:07:45 <ddarius> Cale: You don't need the derivation.  You just need to type in the machine code that you calculate.
21:08:06 <Cale> ddarius: You need the derivation for full marks.
21:09:31 <Axman6> ddarius: the full derivation is done for all haskell programs, but not by the user, by Oleg
21:10:06 <danharaj> GHC's optimizer is actually an SSL session with dons.
21:10:30 <kmc> -fvia-stack-overflow
21:10:35 <Axman6> ha
21:10:49 <andares> dons?
21:11:07 <Axman6> Don Stewart
21:11:18 <danharaj> High Wizard of Optimization
21:11:24 <kmc> Chief Haskell Evangelist
21:11:31 <andares> ah.
21:12:03 <kmc> @quote dons.*title
21:12:03 <lambdabot> hiredman says: I used to think "dons" was a title, like people who were recognized as being really good at haskell were called dons
21:12:15 <andares> lol. like in the mafia.
21:12:17 <kmc> yes
21:13:42 <Cale> Stephen's been working on a new cross-compiling mode for GHC using LLVM to generate registerised code for the iPhone, and the benchmark results are exciting. Code size is down 31% and runtime is down 47% vs. unregisterised via-C.
21:14:31 <ddarius> Just get GHC running on the iPhone.
21:15:30 <dmwit> Is there any reason to believe that would be any easier than making GHC cross-compile?
21:15:55 <kmc> dmwit, GHC isn't so great at the host arch / target arch distinction
21:16:14 <dmwit> If it's spitting out LLVM, that's not supposed to matter, right?
21:16:17 <kmc> no
21:16:22 <dmwit> LLVM is the one that gets to make that distinction.
21:16:25 <kmc> it still cares about the size of various structs, etc.
21:16:34 <dmwit> I see.
21:16:49 <kmc> i'm not 100% sure about that
21:16:55 <kmc> but it's the case for unregisterized C
21:17:37 <kmc> Cale, has anyone looked at my Android stuff?
21:17:48 <kmc> it's probably getting obsolete and was a pile of hacks to begin with
21:17:55 * ddarius is pretty sure the iPhone is significantly more powerful than computers that he has built and used GHC on in the past.
21:17:58 <kmc> i assume the new LLVM work is not on 6.10.4
21:18:53 <Cale> Yeah, it's on 7.0.x
21:18:57 <gienah> kmc: ghc 7.0.4 only support LLVM 2.7*, ghc 7.2rc1 supports LLVM 2.9
21:19:23 <ivanm> is it a bad sign if about 50% of my program's runtime is serialisation?  Admittedly, there are a lot of values to be serialised, but I was hoping that the actual point of the program would be the expensive bit, as then there'd be hope for more optimisations...
21:19:57 <dmwit> Whatcha usin' for serialization?
21:20:07 <mauke> oh shit, I'm getting upgraded to ghc 7
21:20:27 <ivanm> dmwit: custom a -> Put function
21:20:27 <ddarius> It could mean that you have a very efficient algorithm, but it probably means you either have very inefficient/excessive serialization or you're IO bound.
21:20:56 <gienah> mauke: ghc 7.0.4 works fine for most stuff
21:21:27 <ivanm> how can I determine if IO is the problem?
21:21:41 <dmwit> redirect to /dev/null and see if it gets faster =)
21:21:56 <ivanm> otherwise, I'm not really sure how to make the serialisation more efficient...
21:22:22 <kmc> stub out the IO calls
21:22:32 <ivanm> I could possibly do away with using my list-based middle-man representation, but I need that for my Show instance :/
21:22:46 <kmc> let putStr xs = evaluate (xs `using` rnf) >> return ()
21:23:10 <ivanm> @hoogle xs
21:23:10 <lambdabot> Control.Monad.ST fixST :: (a -> ST s a) -> ST s a
21:23:11 <lambdabot> Control.Monad.ST.Lazy fixST :: (a -> ST s a) -> ST s a
21:23:11 <lambdabot> Network.Socket MaxSegment :: SocketOption
21:23:14 <ivanm> gah
21:23:16 <ivanm> @hoogle using
21:23:16 <lambdabot> Control.Parallel.Strategies using :: a -> Strategy a -> a
21:23:20 <ivanm> ^^ what I actually meant
21:23:57 <ivanm> kmc: how does that differ from just "rnf xs" ?
21:24:37 <ddarius> "list-based middle-man representation" sounds like a performance destroyer.
21:25:06 <ivanm> yeah :s
21:25:26 <kmc> oh, i think it's wrong
21:25:33 <dmwit> ivanm: The type is different. ;-)
21:25:35 <kmc> " Note that since the Strategy type changed, rnf is no longer a Strategy: use rdeepseq instead."
21:25:55 <ivanm> kmc: heh
21:26:01 <kmc> «evaluate (xs `using` rdeepseq)» or «evaluate (rnf xs)»
21:26:07 <kmc> should both work
21:26:21 <Cale> I don't really understand why rnf isn't a strategy anymore.
21:26:30 <Cale> and why rdeepseq needs to be separate
21:26:42 <kmc> Cale, so that the deepseq package can be split from the parallel package, I'd guess
21:27:00 * kmc is not inclined to guessing -- merely public statements about how, hypothetically, he would guess
21:27:13 <ivanm> ddarius: well, when I first wrote it, the idea was that it would make it easier to have extra support for different serialisation methods down the track (as I'll be adding at least two more to this library before I actually release it) and I needed something for Show/Read without exporting constructors, etc.
21:27:39 <ivanm> kmc: as in not depending upon each other?
21:28:12 <kmc> well 'parallel' depends on 'deepseq'
21:28:22 <kmc> but "Strategies" is a big complicated thing
21:28:31 <kmc> and NFData is more fundamental and clearly useful outside of "Strategies"
21:28:46 <kmc> and Strategies has changed a lot recently
21:28:54 <ddarius> NFData is a pile of poo.
21:29:19 <kmc> oh ddarius?
21:29:40 <ivanm> what's so bad about NFData?
21:30:03 <ddarius> The whole idea of it.
21:30:20 <kmc> i'd say it should be used sparingly
21:30:27 <kmc> this seems like one of the legit use cases
21:31:12 <ivanm> it's useful for debugging purposes to try and see if excessive laziness is at fault
21:31:19 <kmc> :t foldr seq ()
21:31:20 <lambdabot> forall a. [a] -> ()
21:31:47 <ivanm> but yeah, apart from parallel there probably isn't much practical purpose in using NFData in released code
21:32:13 <kmc> i think even in a parallel context it's usually wrong
21:32:15 <kmc> not sure ,though
21:32:40 <ddarius> "The small object argument is a transfinite construction which ..."
21:46:32 <FeiRuoWa> i'm finally actually trying to learn haskell, instead of just being supposed to learn haskell.
21:47:22 <FeiRuoWa> i'm not sure how i feel about this whole "explaining what things are instead of just redefining them a bajillion times" business. anybody have suggestions as to how i should think of this?
21:48:47 <kmc> can you be more specific?
21:48:52 <dmwit> I don't even know what that question means.
21:48:53 <kmc> what resources are you using to learn Haskell?
21:48:54 <Maxdamantus> imo, start by thinking of every expression as a function in another language, like JS.
21:49:11 <Maxdamantus> (then stop thinking like that)
21:50:09 <mauke> FeiRuoWa: think in state transitions
21:50:22 * kmc thinks we should wait for clarification before we turn on the fire hose
21:50:42 <kmc> "first, think of Haskell as like Javascript, then forget Javascript, then forget Haskell, then re-learn Haskell, then learn Javascript as like Haskell"
21:51:04 <FeiRuoWa> kmc: i'm using primarily Learn You A Haskell, in conjunction with a handful of other things google is throwing at me.
21:51:14 <kmc> cool, LYAH is a good book
21:51:48 <FeiRuoWa> dmwit: i'm not entirely sure what that question means. whatever the most basic thing about how to start going about achieving an objective in haskell is, i'm having trouble with that.
21:52:08 <kmc> FeiRuoWa, I don't think we'll be able to convey that easily
21:52:18 <kmc> just read more of LYAH and maybe take a look at RWH too
21:52:19 <kmc> @where RWH
21:52:20 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:52:30 <FeiRuoWa> thanks! i'll try that.
21:52:32 <kmc> RWH has some very practical, real-world, (therefore kinda ugly) examples of whole programs
21:52:46 <FeiRuoWa> LYAH is telling me to do things...and i still don't really understand the basic premise.
21:52:57 <hatds> do you mean "staring at the text editor" trouble for expressing your program?
21:53:04 <FeiRuoWa> i may have been ruined by starting in Labview really really young.
21:53:06 <kmc> well, can you give an example of a thing it tells you?
21:53:07 <FeiRuoWa> hatds: yes!
21:53:36 <hatds> FeiRuoWa: I (and most people I think) went through the same thing.
21:53:46 <kmc> FeiRuoWa, what's your other programming experience?
21:54:13 <FeiRuoWa> kmc: "In purely functional programming you don't tell the computer what to do as such but rather you tell it what stuff is." is where the problem was, and i thought i could overlook it, until i read further and it built off of an understanding of that idea i can't seem to gather.
21:54:22 <FeiRuoWa> hatds: well, that's encouraging, at least.
21:54:50 <mauke> I totally tell the computer what to do
21:54:55 <kmc> FeiRuoWa, take a look at http://www.haskell.org/haskellwiki/Introduction#Quicksort_in_Haskell
21:55:00 <mauke> don't believe the hype
21:55:08 <kmc> particularly "quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater)"
21:55:13 <mauke> you can mechanically translate from imperative code to haskell
21:55:16 <hatds> FeiRuoWa: following examples of whole programs is the zeroth step.  It will let you scrutinize how lots of isolate pure functions come together to give the outer imperative program.
21:55:25 <FeiRuoWa> kmc: i started using labview in sixth grade, LOGO in eighth (talk about a step down), html/javascript the summer before ninth, java in ninth, and perl in 11th. i just finished my first year of college, and the professor leading a research group i'm working with wants me to learn haskell.
21:55:44 <kmc> FeiRuoWa, in C or Python or Javascript, you'd say like "make a new array, now loop over that array, fill in elements one by one, now return that array"
21:55:50 <FeiRuoWa> okay! thank you!
21:56:08 <kmc> FeiRuoWa, in Haskell you say "the sorted list is the sorted (stuff less than p), then p, then the sorted (stuff greater than p)"
21:56:25 <kmc> "the result is foo" not "do foo, then do bar"
21:56:39 <kmc> you can also write imperative code in Haskell; in fact it's my favorite imperative language
21:56:53 <kmc> but that's generally reserved for tasks which are actually imperative in nature (like IO)
21:56:59 <mauke> in Haskell I say "extract the elements less than p, sort them; extract the elements greater than p, sort them; now concat"
21:57:07 <FeiRuoWa> hmmm...
21:57:19 <Cale> Labview is a dataflow programming system, so that should probably be less crippling than an imperative language, but I'm not really familiar.
21:57:38 <kmc> FeiRuoWa, does the quicksort example make a little sense?
21:57:50 <FeiRuoWa> Cale: labview still encourages you to give it a list of things to get you from point a to point b
21:58:02 <kmc> so does Haskell
21:58:03 <FeiRuoWa> so, basically, haskell wants you to go from point b to point a.
21:58:09 <FeiRuoWa> it does?
21:58:09 <kmc> it's just often a bunch of functions being composed
21:58:21 <kmc> i wouldn't say Haskell asks you to work from solution to problem
21:58:39 <hatds> FeiRuoWa: have you written a complete haskell program that involves prompting the user for input and interactively responding to it?
21:58:41 <kmc> the "programming backwards" thing sounds more like a nondeterministic logic programming system
21:59:02 <kmc> Haskell is still "feed-forward" in that data comes into functions, gets transformed somehow, and comes out
21:59:11 <FeiRuoWa> hatds: i have written nothing. i was trying to write the absolute first thing in LYAH and i got really really lost.
21:59:12 <Axman6> FeiRuoWa: it's not too hard to pick up. you just have to keep reminding yourself of two things: 1) Haskell isnt other languages, so please try and forget them while learning haskell, and 2) you're just saying what the values of results should equal, and the compiler worries about how to make that happen in an efficient order
21:59:29 <hatds> FeiRuoWa: hmm.. what was this absolute first thing?
21:59:39 <mauke> "add 2 and 2"
22:00:03 <FeiRuoWa> hatds: the first thing was to set up interactive mode.
22:00:12 <Axman6> by running ghci?
22:00:29 <FeiRuoWa> basically, an explanation of how to make three files in the same folder and use them together to set up to do things.
22:00:32 <FeiRuoWa> yes, Axman6
22:02:06 <Axman6> FeiRuoWa: were you having trouble with the 'What you need to dive in' section?
22:02:23 <ddarius> You can trivially translate from functional code to C# code.
22:02:24 <kmc> you don't have to make any files to use ghci
22:02:59 <FeiRuoWa> Axman6: sort of.
22:03:06 <kmc> FeiRuoWa, skip to the beginning of "Starting out"
22:03:32 <FeiRuoWa> is this one of those books to ignore the intro of?
22:03:45 <kmc> it eventually tells you to "Open up your favorite text editor"
22:03:49 <kmc> but you do a few things before then
22:04:00 <kmc> it'll probably make more sense by the time you get there
22:04:16 <Axman6> FeiRuoWa: all that's saying is that if, in the future you've started writing functions in files, you can play with them in ghci by cd'ing into the directory where the files are, running ghci, and entering :load Foo.hs to access the functions and other definitions in the file Foo.hs
22:04:37 <ddarius> kmc: Logic programming isn't backwards; it's relational.  "Output" and "input" are on equal terms.
22:04:38 <kmc> fortunately this isn't some big conceptual question about functional programming vs. whatever else
22:04:42 <kmc> ddarius, fair enough
22:05:15 <FeiRuoWa> oh. okay.
22:05:33 <FeiRuoWa> so that actually wasn't supposed to be taken as a further explanation of how i should be thinking about haskell
22:05:40 <FeiRuoWa> this might be the source of my problem.
22:05:40 <Axman6> no
22:05:43 <FeiRuoWa> ><
22:05:52 <FeiRuoWa> Error: User is incompetent :p
22:05:57 <kmc> "The usual workflow for me when playing around in stuff is defining some functions in a .hs file, loading it up and messing around with them and then changing the .hs file, loading it up again and so on"
22:06:06 <kmc> that *is* a general piece of advice
22:06:09 <FeiRuoWa> yes, but what it said before that confused me
22:06:10 <kmc> but it's still pretty narrow in scope
22:06:13 <Axman6> it's just letting you know how to use the interpreter with files, which you;ll get to very soon
22:06:19 <FeiRuoWa> okay
22:06:23 <FeiRuoWa> thank you all!
22:06:25 <ddarius> "I've found the bug in your program.  It has users."
22:06:29 <FeiRuoWa> let's see if i can make some progress...
22:06:29 <kmc> :)
22:06:32 <FeiRuoWa> exactly, ddarius
22:06:41 <Axman6> FeiRuoWa: stick around and ask questions
22:06:45 <FeiRuoWa> okay!
22:06:48 <FeiRuoWa> gladly! :p
22:08:12 <Axman6> head to the next page and get haskelling! :)
22:08:20 <andares> I wish learn you a haskell had exercises.
22:08:25 <andares> it's hard for me to remember without doing.
22:08:41 <Axman6> tell BONUS
22:08:53 <andares> BONUS?
22:08:54 <Axman6> that can be in the second edition
22:08:58 <Axman6> the author of LYAH
22:09:07 <andares> does BONUS stand for anything?
22:09:22 <Axman6> not as far as i know. he hangs out here fairly often though
22:09:57 <mauke> preflex: seen BONUS
22:09:57 <preflex>  BONUS was last seen on #haskell 95 days, 10 hours, 4 minutes and 14 seconds ago, saying: yeah i think that's better as well
22:09:59 <c_wraith> well.  he hasn't been around in the last three months.  Before that, he was here pretty often.
22:10:06 <andares> =(
22:10:17 <shachaf> He's on other IRC channels.
22:10:33 <Axman6> i swear i've seen him on here more recently than that
22:10:37 <andares> I think I will attempt to define the list typeclass.
22:10:42 <dmwit> preflex: seen BONUS_
22:10:42 <preflex>  BONUS_ was last seen on #haskell 1 year, 238 days, 15 hours, 48 minutes and 8 seconds ago, saying: osaunders_: usually i think it's defined as a function that uses only the stuff it takes as parameters and function application
22:11:18 <kmc> andares, the list typeclass?
22:11:46 <andares> or rather, a list typeclass.
22:11:59 <kmc> for list-like types?
22:12:00 <andares> er, by typeclass I mean type constructor.
22:12:02 <Axman6> what's it supposed to do?
22:12:04 <kmc> oh
22:12:10 <andares> sorry, new at this.
22:12:12 <kmc> those are different things :)
22:12:13 <kmc> 's okay
22:12:20 <andares> how do typeclasses work internally?
22:12:29 <kmc> you mean, how are they implemented?
22:12:37 <andares> it seemed like magic that I can just say that my type derives Eq and it just works.
22:12:41 <kmc> the Report places few requirements on implementations
22:12:49 <kmc> oh, "deriving" is a whole other sideshow
22:12:53 <mauke> andares: autoderiving is built into the compiler
22:12:53 <andares> explain, please.
22:12:59 <mauke> it only works for like 3 classes
22:12:59 <kmc> it's not core to the idea of type classes
22:13:11 <andares> mauke: oh.. dear. this is complicated.
22:13:24 <mauke> Eq is one of them
22:13:24 <kmc> no it's really not
22:13:36 <kmc> "deriving" works for certain standard classes
22:13:42 <andares> like "Bounded?"
22:13:46 <kmc> all it means is the compiler is required to generate boilerplate for you
22:13:47 <kmc> yes
22:14:03 <kmc> Eq, Ord, Show, Read, Enum, Bounded
22:14:05 <kmc> maybe others
22:14:06 <andares> were they unable to specify a more general derivation system?
22:14:08 <kmc> GHC adds a few more
22:14:23 <kmc> andares, there are many systems but it's still an active research topic how to do it right
22:14:30 <andares> kmc: oh, cool.
22:14:34 <c_wraith> there are things that are ambiguous, too
22:14:35 <dmwit> There are more general derivation systems available on Hackage.
22:14:41 <kmc> Haskell is a pretty conservative standard language
22:14:47 <kmc> and was conservative even when first standardized 21 years ago
22:14:47 <c_wraith> there isn't a single correct derivation for some stuff
22:14:58 <kmc> andares, check out http://hackage.haskell.org/package/derive
22:15:26 <kmc> andares, use "ghc -ddump-deriv" to see the boilerplate GHC is generating
22:15:46 <ddarius> There isn't a single correct derivation for pretty much any of the classes you can derive.
22:15:55 <c_wraith> Functor!
22:16:04 <kmc> i just derived Eq and got some GHC-internal nonsense code
22:16:04 <ddarius> You can't derive Functor.
22:16:05 <c_wraith> ... with the help of an extension
22:16:05 <kmc> oh well
22:16:24 <kmc> right, the Report's specified derived instances are only one of the possible instances
22:16:32 <kmc> like deriving Ord on «data Foo = A | B» you get A < B
22:16:40 <kmc> it's perfectly legit to write your own Ord where B < A
22:16:51 <mauke> or data Foo = B | A
22:17:06 <andares> so it's like the autoderived functions are "virtual?"
22:17:10 <andares> (pardon the OOP expression.)
22:17:11 <mauke> no
22:17:13 <kmc> no
22:17:18 <andares> I don't understand, then.
22:17:21 <kmc> andares, it's just auto-generation of boring code
22:17:29 <andares> okay.
22:17:42 <mauke> deriving means the compiler writes code for you ... then compiles it as if you'd written it
22:17:47 <kmc> when you say "data Foo = A | B deriving (Eq)" the compiler writes for you "instance Eq Foo where A == A = True; B == B = True; _ == _ = False"
22:17:53 <c_wraith> however, typeclasses are *kind of* like virtual functions.  But not very much like them.
22:18:11 <kmc> don't confuse the concept of type classes with the concept of automatically-generated type class instances
22:18:32 <kmc> the latter really is a self-contained idea because it boils down to the compiler writing code for you, which you could have written yourself
22:19:20 <kmc> you can use type classes in full and never once use "deriving"
22:19:26 <kmc> you just end up writing a lot of boring, obvious code like the above
22:19:33 <kmc> if Haskell were Java we would be fine with that
22:19:41 <kmc> and it would be up to your IDE to generate the boring code for you, and then hide it
22:20:03 <kmc> but Haskellers don't like boilerplate and so there's a little mechanism built into the language for generating some of the most common boilerplate
22:21:11 <FeiRuoWa> this is one of the most painful things i've ever tried to learn :(
22:21:28 <kmc> FeiRuoWa, pain is weakness leaving the body
22:22:22 <FeiRuoWa> :p
22:22:52 <Cale> FeiRuoWa: Any questions?
22:23:02 <FeiRuoWa> not at the moment...
22:23:09 <FeiRuoWa> i'm not entirely sure what to ask.
22:23:12 <kmc> (that's what they say...)
22:23:17 <Cale> Don't worry about asking beginner questions here.
22:23:21 <FeiRuoWa> give me a few minutes, and i'm sure i'll have a couple trillion.
22:23:25 <Cale> okay :)
22:23:45 * andares tries to hunt down the section on type constructors in lyah.
22:23:57 <FeiRuoWa> hah, did you miss where i asked how i should think about beginning to do something in haskell? i am very much not worried about asking dumb questions :p
22:24:06 <kmc> FeiRuoWa, don't get hung up on that lofty conceptual stuff
22:24:17 <kmc> the intro to LYAH is trying to motivate a bit why you should learn Haskell
22:24:28 <kmc> but it's not expected that you'll have a deep understanding by the end of the intro
22:24:53 <FeiRuoWa> kmc: it's not that i'm hung up on the lofty conceptual stuff so much as that i'm still not even able to think about how to go about beginning something.
22:25:14 <FeiRuoWa> i would not, right now, even be able to write out a basic sketch of a program intended to be in haskell.
22:25:14 <Cale> FeiRuoWa: Start by writing simple functions and loading them into ghci where you can try them out
22:25:16 <kmc> the first example is "2 + 15"
22:25:28 <kmc> you type "2 + 15" and hit enter and it says 17
22:25:28 <Cale> or just writing expressions into ghci
22:25:32 <kmc> start there
22:25:38 <kmc> don't worry about writing a whole program
22:25:51 <Cale> You mean 2 + 15 isn't a whole program? ;)
22:25:52 <andares> so, what does the data keyword actually do, conceptually?
22:25:54 <kmc> you're not going to do that for a while
22:26:02 <dolio> Aww, no one linked cdsmith's "haskell for kids" thing to the programming reddit?
22:26:06 <kmc> andares, introduces a new data type, with one or more value constructors
22:26:15 <andares> kmc: but what is a data type?
22:26:25 <kmc> a type which stores data
22:26:32 <dolio> I wanted to go read some, "herp, derp, you need to be a PhD. Teach kids BASIC."
22:26:54 <Cale> andares: you can think of it as a set of values
22:27:03 <kmc> andares, the values of a data type are its constructors applied to appropriate values
22:27:11 <kmc> if i say «data Foo = A Int | B String»
22:27:15 <kmc> then I've just added new values to Haskell
22:27:20 <andares> Cale: so a value constructor is a function that maps a data type to a value in the set of values, ultimately, right?
22:27:22 <kmc> such as (A 3), (A 7), (B "Hello world!")
22:27:32 <kmc> value constructors are like functions, yes
22:27:38 <mauke> andares: value constructors are not necessarily functions
22:27:38 <kmc> you can use them where functions are used
22:27:40 <andares> so they're not actually functions?
22:27:43 <kmc> but you can also pattern-match against them
22:27:43 <mauke> andares: they don't map types
22:27:45 <Cale> andares: A data constructor might be a function, if it takes parameters
22:27:47 <kmc> which you can't do with normal functions
22:27:57 <Cale> andares: but some, like True, are not functions
22:28:08 <mauke> kmc: I think you're too far ahead
22:28:11 <kmc> i can say «f (A x) = x» but I can't say «f (not x) = x»
22:28:12 <Cale> Just is a function
22:28:19 <Cale> but Nothing isn't
22:28:35 <andares> what is Nothing?
22:28:41 <andares> or is it just a symbol at that point?
22:28:43 <kmc> data Maybe a = Nothing | Just a
22:28:47 <Cale> Nothing is a value of type Maybe a (for any type a)
22:28:55 <kmc> then I've just added new values to Haskel
22:28:59 <Cale> It's essentially just a symbol
22:29:01 <kmc> such as (Just 3), (Just 7), and Nothing
22:29:15 <Cale> That's a little fancy because of the type parameter
22:29:17 <mauke> beautiful Atoms
22:29:24 <kmc> ur-elements
22:29:27 <Cale> 'a' here is allowed to be any type
22:29:45 <Cale> So we have Maybe Integer, whose values are Nothing, and Just x, where x is any Integer value
22:29:48 <kmc> andares, did you understand my "data Foo = A Int | B String" example?
22:29:58 <kmc> did you understand the examples in whichever book you're reading?
22:30:12 <andares> kmc: lyah, and yeah, but I was a little confused about what the types actually are.
22:30:26 <kmc> what do you mean "actually are"?
22:30:40 <mauke> things are the operations defined on them
22:31:01 <kmc> if you know how to define data types, and construct values of those types, and pattern-match on those values
22:31:02 <andares> is there a function that maps Maybe a -> a?
22:31:05 <kmc> then you understand it
22:31:14 <kmc> andares, there is a "function" but it sometimes crashes your program
22:31:15 <kmc> @src fromJust
22:31:16 <lambdabot> fromJust Nothing  = undefined
22:31:16 <lambdabot> fromJust (Just x) = x
22:31:27 <FeiRuoWa> urgh. i'm writing expressions...and they make sense...but i have this terrible feeling i will never ever be able to make them do anything together.
22:31:33 <Cale> andares: Sort of. Not a total function, because in general, there won't be a value you can give when you get Nothing as input.
22:31:36 <kmc> FeiRuoWa, keep reading!
22:31:45 <FeiRuoWa> i am, i am!
22:31:48 <kmc> andares, look at fromMaybe instead
22:31:49 <Cale> But you can leave the Nothing case undefined and just have the program fail.
22:31:50 <kmc> :t fromMaybe
22:31:51 <lambdabot> forall a. a -> Maybe a -> a
22:31:52 <kmc> @src fromMaybe
22:31:53 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
22:32:12 <kmc> fromMaybe d Nothing = d; fromMaybe d (Just x) = x
22:32:18 <Cale> case x of Nothing -> ...; Just v -> ... stuff with v ...
22:32:27 <kmc> andares, note that you introduced Maybe with two value constructors, and your functions on Maybe have two cases
22:32:30 <kmc> one for each constructor
22:33:03 <Cale> > case lookup 2 [(0,"hello"), (1,"there"), (2,"world")] of Nothing -> "ummm..."; Just w -> reverse w
22:33:04 <lambdabot>   "dlrow"
22:33:12 <Cale> > case lookup 5 [(0,"hello"), (1,"there"), (2,"world")] of Nothing -> "ummm..."; Just w -> reverse w
22:33:13 <lambdabot>   "ummm..."
22:33:28 <kmc> andares, your confusion might stem from the fact that, in other languages, a "constructor" is a function with code that can do arbitrary things
22:33:37 <kmc> in Haskell a value constructor just remembers its arguments
22:33:41 <hatds> FeiRuoWa: there is an older tutorial called "Yet Another Haskell Tutorial" which gets along to interactive programs more quickly.
22:33:43 <kmc> it does not compute anything, by itself
22:34:06 <Cale> data Bool = False | True
22:34:16 <kmc> it can act like a function and have a function's type but there is no "code" to it
22:34:20 <andares> kmc: so a data does just define a set (possibly polymorphic) of values.
22:34:27 <kmc> sure
22:34:27 <Cale> andares: yeah
22:34:52 <FeiRuoWa> hatds: i think i might have to continue going through whatever i can find as slowly as possible, because haskell and i have some serious ideological differences.
22:35:00 <kmc> it declares the existence of a new type, and says what the values in that type are
22:35:06 <kmc> and a type is roughly like a set of values
22:35:18 <andares> so you can think of a value constructor as just mapping arguments to an element in the set.
22:35:18 <kmc> FeiRuoWa, really, you're on page 1 of LYAH and you already have "ideological differences"?
22:35:25 <kmc> andares, yeah
22:35:37 <kmc> some of them don't have arguments and just represent individual elements
22:35:38 <andares> I don't know why I think this will make it easier for me to understand. :p
22:35:40 <kmc> like True, False, or Nothing
22:35:41 <FeiRuoWa> kmc: i've moved past that
22:36:00 <FeiRuoWa> we have ideological differences in that it is obviously hateful and impolite.
22:36:12 <FeiRuoWa> and, no, ofc i'm not projecting at all :p
22:36:18 * kmc confused
22:36:24 <ivanm> @hoogle encode
22:36:25 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
22:36:25 <lambdabot> Network.CGI formEncode :: [(String, String)] -> String
22:36:25 <lambdabot> Network.CGI.Protocol formEncode :: [(String, String)] -> String
22:36:31 <Cale> I think FeiRuoWa is joking ;)
22:36:56 <kmc> sure
22:37:06 <kmc> i'm more generally confused
22:37:07 <mauke> /var/tmp/portage/dev-lang/ghc-7.0.4/temp/ghc2269_0/ghc2269_0.split__336.s:2363:0:
22:37:10 <mauke>      Error: unknown pseudo-op: `.dong'
22:37:14 <kmc> :D
22:37:15 <mauke> excuse me wtf r u doin
22:37:19 <andares> is there a useful difference between value constructors and type constructors, or are value constructors just a special case of type constructors?
22:37:20 * mustelo thought FeiRuoWa was expressing a difference of opinion about the debt ceiling
22:37:28 <kmc> andares, they are totally different
22:37:34 <FeiRuoWa> yes, mustelo. :p
22:37:38 <mauke> andares: value constructors construct values, type constructors construct types
22:37:38 <kmc> type constructors construct types; value constructors construct values
22:37:43 <kmc> values and types are sharply separated in Haskell
22:37:49 <kmc> Maybe is a type constructor because (Maybe Int) is a type
22:37:52 <FeiRuoWa> no, i actually still don't understand how to do anything but stick expressions in...
22:37:55 <kmc> Just is a value constructor because (Just 3) is a value
22:37:56 <mauke> andares: 42 <- value constructor
22:38:00 <mauke> andares: Int <- type constructor
22:38:05 <ivanm> if I do something like: "do { let (c,b) = runPutM (foldM (\c a -> put a >> return (succ c)) 0 as); B.writeFile fp b; return c }", then it seems that the entire constructed Bytestring is kept in memory rather than buffering out to disk
22:38:08 <FeiRuoWa> once we go to functions and up, i have no idea how haskell wants me to write things.
22:38:18 <mauke> FeiRuoWa: yes, that's normal
22:38:24 <kmc> FeiRuoWa, I don't understand the point of repeatedly telling us how confused you are and how you'll never understand anything
22:38:30 <kmc> keep reading, ask a question if you have one
22:38:39 <ivanm> does anyone have a suggestion on how I can count how many entries I'm writing to disk, without doing the foldM on the IO level?
22:38:53 <andares> if they're totally different, why do they have the same keyword to define them? argh.
22:39:06 <ivanm> (which is what I'm doing atm, but feels rather hacky :s)
22:39:09 <kmc> FeiRuoWa, we were all beginners once; you do not need to impress us with your noobishness in order to win the right to ask a question ;P
22:39:18 <kmc> andares, because they are linked
22:39:22 <Cale> andares: They live in different worlds, but are created together
22:39:26 <FeiRuoWa> hah, less that and much much more incredible levels of frustration,
22:39:31 <kmc> you define a type at the same time you define the values in that type
22:39:40 <Cale> andares: type constructors construct types, data constructors construct values
22:39:42 <kmc> data Bool = False | True
22:39:47 <Cale> Bool is a type constructor
22:39:54 <kmc> False and True are the two values of type Bool
22:39:57 <Cale> True and False are data constructors
22:40:05 <hatds> FeiRuoWa: my first exposure was this long video presentation called "A Taste of Haskell".  It is very rudimentary in some ways but very helpful in other ways because it is given by a fantastic speaker who explains the ideological concepts.
22:40:12 <kmc> andares, actually I happen to prefer GHC's alternative "GADT" syntax, which would look like this:
22:40:19 <kmc> data Bool where { False :: Bool; True :: Bool }
22:40:31 <ivanm> I want to be able to know how many values I'm printing to disk to make sure my code is generating the correct number :p
22:40:32 <kmc> data Maybe a where { Nothing :: Maybe a; Just :: a -> Maybe a }
22:40:35 <FeiRuoWa> hatds: i'll try to find that, too, then. thanks!
22:40:47 <andares> Cale: wait, why aren't False and True two values defined in the Bool value constructor? why does Bool have to be a type constructor?
22:40:48 <ivanm> (and the list gets rather long, so I'd prefer not to do a "length as" in there at some point)
22:40:58 <Cale> Bool isn't a value constructor
22:41:21 <hatds> FeiRuoWa: if you would otherwise enjoy such a presentation it would give you the best introduction of IO in haskell that I can think of
22:41:26 <Cale> Bool is a type (which is a special case of a type constructor having no parameters)
22:41:32 <kmc> data <type constructor> = <value constructor> | <value constructor> | <value constructor> | ...  -- andares
22:41:42 <hatds> FeiRuoWa: (among many other things that it discusses)
22:42:01 <FeiRuoWa> hatds: i might very well enjoy such a thing.,
22:42:04 <Cale> You define a new type by saying which new values belong to it.
22:42:12 <kmc> andares, a type is a set of values, right?  we're saying Bool = { False, True }, in set notation
22:42:17 <andares> kmc: so if I define data Foo = 0 | 1, 0 and 1 are value constructors?
22:42:25 <kmc> andares, yes, except you can't use that syntax
22:42:31 <Cale> You can write
22:42:31 <kmc> they have to be words starting with upper case
22:42:36 <Cale> data Foo = Zero | One  though
22:42:37 <kmc> data Foo = Zero | One
22:42:38 <kmc> haha
22:42:41 <kmc> nice one Cale
22:42:45 <mauke> data Foo = X0 | X1
22:43:01 <kmc> andares, and some might quibble about whether they're value *constructors*, because they don't have arguments
22:43:01 <Cale> or that, sure
22:43:04 <kmc> but you basically have it
22:43:04 <andares> so then what's a data constructor?
22:43:20 <kmc> data constructors are what i've been calling value constructors
22:43:21 <Cale> data constructor is the usual word for what we've been calling value constructors for some reason
22:43:26 <hatds> FeiRuoWa: This webpage has the video link(+slides)  http://haskell.org/haskellwiki/Video_presentations
22:43:31 <kmc> i called it that to be extra explicit about the type vs. value distinction
22:43:34 <andares> LYAH calls them value constructors. that's why I guess.
22:43:35 <FeiRuoWa> oooh, yay! thanks!
22:43:37 <kmc> because it's not as clear which one "data" is
22:43:38 <Cale> ah
22:43:48 <mauke> that's actually a very good idea
22:43:53 <kmc> i'm not a huge fan of the Haskell "data" syntax
22:44:13 <ivanm> alternatively: is there a better library than binary/cereal if I'm wanting to encode something using an existing binary format?
22:44:24 <Cale> The data syntax was natural to me when I first saw it, but I was already familiar with context free grammars
22:44:46 <andares> oh, suddenly I get why they're called value constructors, I think.
22:44:48 <andares> instead of values.
22:44:52 * ddarius has no problems with the data syntax.
22:45:17 <ddarius> They are values.  It's just that not all values are constructors.
22:45:28 <Cale> andares: The special thing about constructors is that you're allowed to pattern match on them.
22:45:41 <Cale> (value/data constructors)
22:46:07 <kmc> andares, "Just" isn't a value.  "Just 3" is
22:46:13 <Cale> > case even 5 of False -> "okay"; True -> "wat"
22:46:14 <andares> so I can have a value constructor "Just a" that I can pattern match to when I say Just 2 for instance.
22:46:14 <ddarius> Just is a value.
22:46:14 <lambdabot>   "okay"
22:46:14 <kmc> well, okay
22:46:17 <andares> right.
22:46:17 <kmc> it's a value but not a data value
22:46:19 <kmc> technically
22:46:24 <kmc> because it's a function and functions are values
22:46:24 <Cale> Just is a value
22:46:30 <kmc> but you can't pattern-match on "Just" by itself
22:46:30 <ddarius> "Data value" isn't a defined term.
22:46:59 <andares> wait, what is a value that is not a value constructor?
22:47:14 <kmc> bleh
22:47:18 <Cale> andares: a function, for instance
22:47:19 <ddarius> \x -> x, and arguably most of the primitive numeric types.
22:47:22 <Cale> andares: or an IO action
22:47:47 <ddarius> Plenty of other abstract types as well.
22:47:49 <Cale> (when we get to those ;)
22:48:30 <andares> ah, okay.
22:48:39 <Cale> For example, you can't pattern match to see if the function you were passed is, oh, sqrt, because sqrt isn't a data constructor.
22:49:13 <Cale> (it's in general impossible to scrutinise what function you have at runtime apart from giving it arguments and seeing what result you obtain)
22:49:32 <kmc> that's a very important property too
22:49:40 <ddarius> If only it were true.
22:49:57 <Cale> Well, it would be nice to be able to tell, but it requires solving the halting problem.
22:50:04 <Cale> as a special case
22:50:12 <Cale> so it's unrealistic to want it
22:50:40 <kmc> then it's unrealistic to want a type for real numbers, too
22:50:44 <kmc> yet people do
22:50:47 <ddarius> If Cale is responding to me, he totally misread what I said.
22:52:16 <Cale> kmc: It's unrealistic to want to be able to pattern match on real numbers
22:53:16 <FeiRuoWa> i think i need to leave haskell alone for the night :)
22:53:21 <FeiRuoWa> ^ :(
22:54:12 <kmc> 'night FeiRuoWa
22:54:16 <FeiRuoWa> gn
23:08:16 <ivanm> anyone have any hints/clues on how I can serialise a list of values (using the equivalent of "mapM_ put"; the value definitions know when to stop) whilst also counting how many values there are?
23:09:02 <ivanm> trying to do so within the PutM monad results in the entire resulting bytestring being kept in memory rather than it being buffered like it normally is
23:09:27 <ivanm> the only solution I've come up with is to the looping + counting within IO, which seems rather hacky to me :s
23:09:46 <kmc> go !n [] = return n; go n (x:xs) = put x >> go (n+1) xs
23:10:06 <ivanm> yeah, tried that
23:10:16 <kmc> and?
23:10:21 <ivanm> same thing
23:10:37 <ivanm> memory goes way up, and it seems to do one big file write at the end rather than incrementally
23:10:46 * ivanm tries again to make sure
23:11:41 <kmc> ivanm, did you do it in PutM or in IO?
23:12:02 <ivanm> PutM
23:12:10 <kmc> try it in IO
23:12:10 <ivanm> within IO it works
23:12:12 <kmc> ok
23:12:16 <kmc> so what's the problem?
23:12:26 <kmc> by "looping + counting within IO" i thought you meant, like, an IORef for the count ;P
23:12:31 <ivanm> it doesn't seem as nice/elegant to be doing repeated appends within IO
23:12:35 <ivanm> kmc: heh
23:12:38 <kmc> appends?
23:12:45 <kmc> aren't you just writing these to a file as generated?
23:12:48 <ivanm> B.appendFile fp ...
23:13:01 <kmc> oh
23:13:05 <ivanm> kmc: when looping within IO, instead of the put
23:13:06 <kmc> yeah, i don't see what's wrong with this
23:13:30 <kmc> it's not ideal but as performance optimizations go it's really mild
23:13:36 <ivanm> *shrug* just seems more elegant IMHO to have binary do the buffering for me
23:13:56 <ivanm> what's the extension needed to be able to do !n ?
23:14:17 <kmc> BangPatterns
23:15:57 <ivanm> nope, using go within PutM doesn't solve it
23:16:09 * ivanm vaguely wonders if using blaze-builder would...
23:16:21 <ivanm> probably end up going back to looping in IO I suppose
23:16:32 <kmc> what about http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Builder.html
23:16:38 <kmc> PutM isn't much of a monad
23:16:50 <ivanm> blaze-builder is meant to be faster than the builder in binary
23:17:00 <ivanm> (and is eventually meant to replace it IIRC)
23:17:10 <kmc> *nod*
23:17:16 <kmc> sounds worth a shot
23:18:05 <ivanm> anyway, time I headed off home
23:18:10 <ivanm> I'll try that tomorrow
23:18:13 <ivanm> thanks kmc
23:18:16 <kmc> ttyl ivanm
23:18:40 <ivanm> though it took me a while to realise it was the counting that was using up all the RAM and not just that there was a bug in binary or something :p
23:19:16 <kmc> yeah, i guess doing it in IO is fundamentally less composeable
23:22:03 <kniu> @hoogle succ
23:22:04 <lambdabot> Prelude succ :: Enum a => a -> a
23:22:04 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap succFM :: Ord a => FiniteMap a b -> a -> Maybe (a, b)
23:22:04 <lambdabot> System.Exit ExitSuccess :: ExitCode
23:31:35 <andares> hm, wht's the difference between let/in and where?
23:31:56 <andares> let/in is scoped to a single definition, right?
23:32:04 <RayNbow`TU> let/in is an expression
23:32:11 <andares> oh.
23:32:25 <mauke> > (let a = 2 in a) + (let a = 3 in a)
23:32:26 <lambdabot>   5
23:32:52 <Nisstyre> I prefer the where syntax
23:33:10 <Nisstyre> for most things
23:33:11 <mauke> > (let a = 2 in a) + (let a = b where b = 3 in a)
23:33:12 <lambdabot>   5
23:33:26 <Nisstyre> :3
23:33:49 <RayNbow`TU> and as mauke shows, "where" belongs to a binding
23:34:38 <mauke> > var "a" == a
23:34:39 <lambdabot>   Couldn't match expected type `Data.Number.Symbolic.Sym a'
23:34:39 <lambdabot>         against i...
23:34:59 <mauke> > a == var "a"
23:35:00 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
23:35:00 <lambdabot>         against inferred ...
23:35:34 <kniu> @hoogle iter
23:35:34 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
23:35:35 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
23:35:35 <lambdabot> Data.ByteString.Lazy iterate :: (Word8 -> Word8) -> Word8 -> ByteString
23:35:49 <kniu> @hoogle repeat
23:35:49 <lambdabot> Prelude repeat :: a -> [a]
23:35:50 <lambdabot> Data.List repeat :: a -> [a]
23:35:50 <lambdabot> Data.ByteString.Lazy repeat :: Word8 -> ByteString
23:36:23 <kniu> @hoogle a -> (a -> Bool) -> a
23:36:24 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
23:36:24 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
23:36:24 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
23:37:20 <kniu> @hoogle until
23:37:21 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
23:46:20 <andares> whee I made a tree.
