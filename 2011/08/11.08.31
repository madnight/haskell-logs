00:01:07 <Saizan> lewis1711: you should rather split the list in two and recurse on both sides of Branch with half of the list
00:01:46 <shachaf> monochrom: Did you once say that 5 was a metaphor for death?
00:02:31 <cwl> csvFile :: GenParser Char st [[String]]
00:02:36 <cwl> what is `st`
00:02:44 <mister_m> should I jump to real world haskell after the 6th chapter of learn you a haskell?
00:02:56 <shachaf> cwl: State, I think.
00:02:57 <cwl> mister_m: no
00:03:10 <shachaf> mister_m: Is LYAH taking things too slowly?
00:03:22 * hackagebot ghc-mod 0.6.1 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.6.1 (KazuYamamoto)
00:03:35 <shachaf> lewis1711: A binary tree isn't the same thing as a B-tree, by the way. :-)
00:03:40 <cwl> shachaf: I tried  > :t st
00:03:43 <cwl> > :info st
00:03:44 <lambdabot>   <no location info>: parse error on input `:'
00:03:53 <shachaf> It's a type variable.
00:03:57 <cwl> not in scope, ghci tells me
00:04:02 <shachaf> forall st. GenParser Char st [[String]]
00:04:05 <Botje> cwl: st is the type variable for the state you're passing around.
00:04:22 <mister_m> shachaf: I had read somewhere online that doing that was recommended
00:04:43 <shachaf> mister_m: Oh. I'm not sure why (though I've skimmed both and read neither).
00:04:44 <cwl> Botje: something like Integral or Int?
00:05:05 <Botje> cwl: yes. if you don't need it, stick to the alias Parser
00:05:09 <Botje> type Parser a = GenParser Char () a
00:05:10 <cwl> mister_m: Real World Haskell is very hard to read
00:05:29 <Botje> mister_m: read both, if you can
00:05:30 <shachaf> mister_m: As long as you're learning things from LYAH, you might as well keep reading it.
00:06:30 <shachaf> No real point in jumping around unless there's something specific you want to see that's in RWH.
00:06:52 <cwl> why is st in lower case
00:07:00 <shachaf> Because it's a type variable.
00:08:45 <bz_> I read RWH chapters about monads several times and every time where was something new I learned. There are still much more to learn though.
00:09:59 <luite> there's always much more to learn :p
00:10:23 <mister_m> I don't think I'll ever get to the point where I'm writing actual programs
00:10:35 <Botje> then just start hacking something.
00:10:39 <luite> why not, just learn while writing actual programs :)
00:11:00 <cwl> shachaf: is  csvFile :: GenParser Char a [[String]]  an equivalent
00:11:06 <shachaf> Yes.
00:11:26 <cwl> shachaf: I see :-)
00:12:58 <bz_> Necessety to have global configuration which is passed among all of the functions forced me to read more about combinations of Reader, State and IO monad. So, yes, real-world problems is a good motivation to learn some "theory".
00:22:40 <chrisdone> what's a good way to have variables (like ST vars, for example), let's call them ZVars, which can be created, but once you have ‘deleted’/unacquired them, they are no longer accessible, in the type system?
00:24:16 <mauke> I bet oleg has done something like that
00:24:20 <Lemmih> chrisdone: I don't know if there a good way.
00:24:35 <Lemmih> chrisdone: If you're just looking for a way then it can be done.
00:24:38 <mauke> the name may involve "region"
00:25:16 <chrisdone> Lemmih: how?
00:25:46 <quicksil1er> chrisdone: it's not too difficult if you're prepared to tie the 'unacquiring' to a lexical scope
00:25:47 <chrisdone> mauke: reading this http://okmij.org/ftp/Haskell/regions.html
00:25:54 <Lemmih> chrisdone: Like ST.
00:26:06 <quicksil1er> I think it's very difficult (impossible?) to tie the unacquiring to something more dynamic.
00:26:50 <ddarius> You could use linear types (kinds?) to do it, albeit not in Haskell in an obvious manner.
00:26:56 <mister_m> how can I force integer division
00:27:03 <ddarius> Use div or quot.
00:27:27 <mister_m> grea
00:27:28 <mister_m> t
00:33:31 <chrisdone> hmm
00:35:23 <jeltsch> A message from cabal install:
00:35:23 <jeltsch>     Warning: No documentation was generated as this package does not contain a library. Perhaps you want to use the --executables flag.
00:35:23 <jeltsch> But what is this --executables flag? cabal install doesn’t accept it and I couldn’t find it in the docs.
00:36:23 <jeltsch> Hmm, cabal haddock accepts it.
00:36:41 <jeltsch> Can I make cabal install installing documentation somehow?
00:37:12 <chrisdone> it's an argument to haddock
00:37:25 <chrisdone> it creates documentation for executables, rather than the default, libraries
00:37:47 <mister_m> I don't think I have a haskell brain
00:38:01 <Botje> nobody does
00:38:15 <Botje> that's why haskell conveniently explodes your skull to make room
00:38:50 <fasta> Some things are just not convenient to do in Haskell.
00:39:23 <fasta> If you really would want a certain functionality like that, you could write a compiler pass too.
00:39:31 <fasta> Conceptually much easier.
00:40:02 <fasta> (which is incidentally why Lisp macros are a good idea in principle)
00:40:40 <fasta> (Or PLT Scheme macros, or whatever developed macro system you are talking about.)
00:41:11 <fasta> Just like not everything is an object, not everything needs to easily fit in some fixed type system.
00:41:31 <chrisdone> something the author of Ur said about producing programs that are correct made me think about the fact I can write a database migration that can create a table, delete it, and then try to select from the table
00:42:09 <quicksil1er> chrisdone: you can do that with something like a type which represents your schema
00:42:17 <fasta> chrisdone: what do you do if every such operation takes 10 hours?
00:42:40 <quicksil1er> chrisdone: and make the database migration 'change' the schema type so opertaions after that point are forced to run in the new schema
00:42:57 <fasta> quicksil1er: did someone steal your nickname?
00:43:00 <chrisdone> quicksil1er: hm, good idea
00:43:28 <quicksil1er> chrisdone: it's a little like that version of the state monad where the state type can change
00:43:32 <chrisdone> quicksil1er: if i use something like HList then it's easier to construct new types like that
00:43:33 <quicksil1er> I forget where that's written up
00:43:42 <quicksil1er> chrisdone: yes, you'd need a structure like tuples.
00:43:44 <chrisdone> yeah… i saw that somewhere… hm
00:43:50 <quicksil1er> you can choose to spell tuples 'HList' if you like ;)
00:43:53 <quicksil1er> but they're just tuples.
00:43:55 <chrisdone> ;)
00:44:06 <chrisdone> yeah, essentially
00:44:16 <quicksil1er> I'm not sure it is a good idea ;)
00:44:28 <dmwit> jeltsch: Yes, you can ask cabal install to install documentation. Set documentation: True in ~/.cabal/config.
00:44:32 <quicksil1er> that is, I'm not sure haskell has the right abstraction to cope *conveniently* with using types that way.
00:44:46 <quicksil1er> see the sessions types package for an example of something that is theoretically clever but not all that convenient in practice.
00:45:12 <quicksil1er> fasta: no, just some weird freenode glitch about changing nick whilst in a channel in which I'm "banned" although, apparently, I"m not banned
00:45:24 <chrisdone> quicksil1er: right. apparently something like this is convenient in Ur (which is the author's main argument for having a new language)
00:45:31 <jeltsch> dmwit: I already did this. The problem was how to make cabal-install install documentation for executables. Well, maybe this isn’t possible.
00:46:02 <chrisdone> haha, oh god
00:46:07 <chrisdone> http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html
00:46:11 * chrisdone boggles
00:46:25 <quicksilver> yes, exactly
00:46:43 <quicksilver> it's quite a sensible scheme of types (the sessions package)
00:46:47 <quicksilver> but it needs a new *notation*
00:46:56 <quicksilver> the haskell notation for types does not work well for those.
00:46:59 <Axman6> jesus!
00:47:25 <quicksilver> I'm not sure what a good notation would be although there are some clues in some of Matthew's papers
00:47:30 <Axman6> if that isn't auto-generated, the author should go and kill themself
00:49:08 <Botje> maybe it's suicide by type system.
00:53:45 <Saizan> quicksilver: btw, freenode says banned even when it means +q
00:55:03 <quicksilver> Saizan: I can't imagine how/why I would have been +q'ed, I've been away
00:55:12 <quicksilver> Saizan: anyhow, fixed it by part/nick/join
00:57:18 <accel> on osx
00:57:21 <accel> is yi in the temrinal only
00:57:25 <accel> or does it use cocoa to have a gui?
01:04:19 <mister_m> is it possible to translate this into haskell? http://en.wikipedia.org/wiki/Binary_search_algorithm#Iterative I imagine of course that it is - but I'm not sure how it would translate
01:06:06 <quicksilver> mister_m: yes. The simplest way to translate a loop liek that is to turn it into recursion, and turn the mutable variables into function parameters
01:06:13 <luite> mister_m: almost the same, but with recursion. You'd use an array insted of a list
01:07:40 <quicksilver> iter_binsearch a x min max = let mid = (min+max)`div`2 in if x > a!mid then iter_binsearch A x (mid+1) max else iter_binsearch A x min (mid-1)
01:07:51 <quicksilver> although you need to add a check for 'we've found it' too.
01:08:12 <luite> I'd use guards :)
01:08:14 <quicksilver> mind you that then approaches what that article describes as the 'recursive' solution.
01:08:39 <quicksilver> 'recursive' and 'iterative' are not really such different concepts
01:09:06 <quicksilver> the difference is generally highlighted with reference to specific language implementation quirks like how much stack you use up.
01:09:15 <quicksilver> (this is an important quirk in some contexts of course!)
01:13:22 * hackagebot http-enumerator 0.6.7 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.7 (MichaelSnoyman)
01:15:10 <mister_m> can you use guards within a let expresstion
01:15:24 <mister_m> rather - the "in" part of the let expression
01:15:47 <quicksilver> mister_m: you can use guards on any definition/pattern
01:16:04 <quicksilver> which means the literal answer to your question is yes, but I suspect you can't actually do what you're trying to do ;)
01:16:18 <quicksilver> you can't do "let x = y in | a == b -> c"
01:16:57 <ddarius> What would that mean?
01:17:23 <mister_m> !topic
01:18:12 <hpaste> mister_m pasted “error on line 5” at http://hpaste.org/50812
01:18:22 <mister_m> quicksilver: http://hpaste.org/50812
01:20:29 <Botje> mister_m: you want to use a 'where', there.
01:22:02 <quicksilver> ddarius: It would mean (let x = y in if a==b then c else error "unmatched guard")
01:22:21 <quicksilver> ddarius: which is what you'd need it to mean for mister_m's code to do what he presumably wants
01:22:51 <quicksilver> mister_m: either move the mid into a where clause, or use if/case/somethign else
01:22:56 <Axman6> mister_m: binary_search xs x high low | ... <all your guards here> where mid = ...
01:24:39 <hpaste> Axman6 annotated “error on line 5” with “error on line 5 (annotation)” at http://hpaste.org/50812#a50813
01:25:08 <Axman6> also, follow the warning there, underscores are for losers :P
01:29:32 <hpaste> mister_m annotated “error on line 5” with “error on line 5 (annotation)” at http://hpaste.org/50812#a50814
01:30:02 <quicksilver> returning -1 for 'not found' is not very haskell-like, either
01:30:28 <accel> is quartz C or objective-c?
01:30:33 <accel> is quartz is C
01:30:38 <accel> I can do GUI in haskell on osx
01:30:39 <accel> with quartz
01:30:39 <mister_m> quicksilver: what is more haskell like
01:30:42 <accel> rather than objetive-c
01:30:49 <accel> and that would amke me happy due to haskell's  c ffi
01:31:07 <quicksilver> mister_m: returning Nothing for not found, and (Just mid) when found
01:31:34 <quicksilver> also, binary_search for lists is rather slow but that's probably not the important point.
01:32:13 <mister_m> quicksilver: yeah I read online that !! is bad, but I can change to arrays later on I suppose
01:32:59 <brisingr> Hey, I'm trying to define a function that does something like f (w (k x)) = k (w x) where k and w are functors
01:33:03 <Axman6> quartz is not something you access, it's the name of the system OS X uses for rendering i believe
01:33:09 <brisingr> Can you please give me a few pointers?
01:33:20 <Axman6> i think it's analogous to X11, but i'm not sure
01:34:32 <brisingr> something like f Just [1,2,3] = [Just 1, Just 2, Just 3]
01:34:43 <quicksilver> brisingr: you seem to be confusing types and values
01:34:45 <quicksilver> I think you mean
01:34:51 <quicksilver> f :: w (k x) -> k (w x)
01:34:58 <Axman6> > map Just [1,2,3]
01:34:59 <lambdabot>   [Just 1,Just 2,Just 3]
01:35:02 <quicksilver> this isn't possible for all pairs of functions
01:35:11 <mister_m> quicksilver: if I wanted to return 'Nothing' I would want my function to return what type
01:35:13 <quicksilver> Axman6: he meant f (Just [1,2,3])
01:35:21 <Axman6> ah
01:35:23 <quicksilver> mister_m: MaybeInt
01:35:32 <quicksilver> > traverse (Just [1,2,3])
01:35:33 <lambdabot>   Not in scope: `traverse'
01:35:39 <quicksilver> > Data.Traversable.traverse (Just [1,2,3])
01:35:40 <lambdabot>   Couldn't match expected type `a -> f b'
01:35:41 <lambdabot>         against inferred type `Data...
01:35:45 <quicksilver> hmm
01:35:49 <Axman6> :(
01:35:54 <brisingr> Hmm
01:35:59 <quicksilver> it's something to do with traversable
01:36:10 <mux> there's one thing harder than decoding GHC error messages; trying to decode just the beginning of such a message
01:36:27 <quicksilver> > Data.Traversable.sequence (Just [1,2,3])
01:36:28 <lambdabot>   [Just 1,Just 2,Just 3]
01:36:34 <quicksilver> brisingr: there you are.
01:36:40 <quicksilver> :t Data.Traversable.sequence
01:36:40 <brisingr> oh, thanks
01:36:41 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
01:36:49 <quicksilver> it doesn't work for all pairs of functors
01:36:52 <quicksilver> :t Data.Traversable.sequenceA
01:36:53 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
01:36:56 <ddarius> Traversable is equivalent to having a distributive law which is a natural transformation f . g -> g . f
01:37:04 <quicksilver> the outer has to be traversable, the inner has to be applicative
01:37:20 <brisingr> oh, I see
01:37:22 <brisingr> thanks
01:37:25 <quicksilver> ddarius: (but requires g to be Applicative to work)
01:37:44 <brisingr> man, is there anything that isn't already defined?
01:37:53 <mister_m> quicksilver: okay neat. My search doesn't work atm - I'll return to it tomorrow
01:37:57 <mux> > Data.Traversable.traverse id [1..5]
01:37:58 <lambdabot>   No instance for (GHC.Show.Show (f [b]))
01:37:58 <lambdabot>    arising from a use of `M33952788...
01:38:24 <Maxdamantus> collatzProof
01:39:06 <brisingr> :t Data.Traversable.traverse
01:39:07 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
01:41:12 <accel> ladies and gentlemen, I have a non-trolling question
01:41:17 <accel> so I'm interfacing objective-c / haskell
01:41:27 <accel> and I need it to be setup so that the haskell code is called in a handler
01:41:32 <accel> i.e. the objective-c code has the main loop
01:41:36 <accel> and periodically calls the ahskell code
01:41:47 <accel> so somehow, I need ot pass a haskell function as a pointer to a c function
01:41:52 <accel> what should I read up on / google for?
01:42:27 <quicksilver> accel: FunPtr
01:42:51 <accel> holy shit, that's a real name
01:43:05 <quicksilver> also, check how GLUT (HOpenGL) and SDL handle this
01:43:12 <quicksilver> they both have mainloops under foreign control
01:43:22 <accel> whoa
01:43:28 <accel> yeah, I should just steal code from them
01:44:00 * Maxdamantus would think it'd just be magic and let you import a function typed something like `IO () -> IO ()`
01:44:34 <Maxdamantus> Already seems crazy to me that you can import `(a -> b) -> c`
01:45:34 <ddarius> accel: Read the FFI addendum.
01:48:18 <brisingr> quick question uhh, a little confused here
01:48:29 <brisingr> traverse f = sequenceA . fmap f
01:48:32 <mm_freak> is there a way to rebuild my entire haddock documentation to reflect the latest instance definitions?
01:48:33 <brisingr> sequenceA = traverse id
01:48:48 <brisingr> uhh
01:49:21 <azaq231> brisingr: The Traverseable class defines these functions, as you noticed, in terms of each other. You can implement one and get the other one by the stated definition for free.
01:49:31 <ddarius> x == y = not (x /= y); x /= y = not (x == y)
01:49:41 <brisingr> oh
01:49:42 <brisingr> thanks
01:49:47 <brisingr> right
02:34:33 <erus`> monads and monoids, do notation confusion, a haskell haiku
02:35:51 <Axman6> to be a haiku, you must reference something, that is natural
02:35:59 <dave123> erus`:  begin the countdown to a 17 syllable -morphism...
02:36:09 <brisingr> monads are natural
02:36:23 <brisingr> monoids too
02:36:26 <brisingr> do notation isn't
02:36:27 <Axman6> they're a purely human construct
02:36:41 <brisingr> they are arguably "discovered"
02:36:44 <Axman6> something natural meaning something from nature
02:36:58 <mauke> how about a perl haiku?
02:37:05 <brisingr> monoids are nature, abstracted
02:37:12 <mauke> print STDOUT q / Just another Perl hacker / unless $spring
02:37:51 <cheater> hi
02:37:56 <brisingr> hi
02:38:43 <brisingr> I'd love to see a lambdabot plugin that answers to hi so I won't have to (I feel compelled)
02:39:42 <Entroacceptor> just think that saying "hi" on irc is considered rude
02:40:23 <brisingr> uhh, even answering to "hi"? *innocent face*
02:40:40 <Entroacceptor> that's even worse
02:40:48 <Botje> @vixen hi
02:40:49 <lambdabot> hi
02:40:50 <int-e> @bot
02:40:50 <lambdabot> :)
02:41:00 <erus`> i think considering things rude is rude except for when one considers being rude rude
02:41:01 <Entroacceptor> I mean, you have join messages
02:41:18 <leod> being rude is pretty rude
02:41:35 <brisingr> talking about being rude is meta-rude
02:41:53 <brisingr> talking about talking about being rude is double meta rude
02:42:14 <erus`> cancels itself out?
02:42:24 <int-e> > fix ("talking about "++)
02:42:26 <lambdabot>   "talking about talking about talking about talking about talking about talk...
02:42:35 <brisingr> composes into a meta-monster
02:43:07 <Entroacceptor> sometimes you need meta-monster to beat giga-gozilla
02:43:38 <brisingr> lambdabot should suffice
02:43:44 <brisingr> as long as you feed lambdabot
02:43:46 <brisingr> @botsnack
02:43:47 <lambdabot> :)
02:44:05 <int-e> @vixden do you like botsnacks?
02:44:06 <lambdabot> sure, i definitely don't hate
02:44:12 <dave123> so I'm new to Haskell, working through "write yourself a scheme in 48 hours", wondering if anyone has any thoughts on the "next step"
02:44:40 <int-e> the next step is usually a monad tutorial?
02:44:48 <dave123> I'm considering either taking a crack at writing a rogue-like, or sticking my hand up to document / add test coverage to some stuff on Hackage
02:45:00 <int-e> I mean writing one, not working through one.
02:45:08 <dave123> int-e: hehe
02:45:59 <dave123> int-e: I've read a few, might write a monad-tutorial-generator if that's where I should be heading
02:46:40 <int-e> I was kidding.
02:46:49 <Entroacceptor> he wsa kidding, too
02:48:28 <brisingr> off-topic: I noticed that every monad explanation is slightly different
02:50:05 <int-e> Yes. That's because monad tutorials are like tomato sandwiches.
02:50:56 <Botje> I thought they were like martian fruit?
02:51:48 <int-e> Are you saying that tomatoes are from mars?
02:52:45 <brisingr> well, for one, they're red
02:52:52 <Entroacceptor> I always thought monad tutorials where like aluminium foil
02:53:40 <brisingr> monad tutorials are like tacos: you want to make them the same but you can't
02:54:12 <shachaf> brisingr: Monad tutorials are different because monads are different.
02:54:17 <Botje> most of them are clear in the same way a mug of coffee isn't
02:54:58 <brisingr> Botje: so you mean they're clear?
02:55:24 <brisingr> (double negation)
02:55:53 <dave123> the monad is the mug and you put coffee into it
02:56:00 <brisingr> I find monad tutorials deeply confusing and slightly disturbing
02:56:54 <dave123> I found one or two that really spelt things out for me - kind of amazing how much variety there is in the explanations
02:57:34 <brisingr> I liked the wikibooks haskell/category theory tutorial
02:57:54 <dave123> now I just need to find a good comonad tutorial to work out if _I'm_ the comonad that goes along with the mug, which would be awesome
03:02:30 <dave123> so would documenting / adding test coverage to stuff on hackage be an alright idea for learning more?  I can imagine it might depend on whether the maintainers have the bandwidth to check that I'm not wrecking stuff
03:02:56 <hpaste> jeetu pasted “my startuphook” at http://hpaste.org/50816
03:03:32 <RenJuan> dave123, you could write them up then submit them to them for them to post/correct
03:04:29 <RenJuan> unlikely anybody sane would refuse such an offer
03:05:32 <brisingr> to learn more I want to examine lambdabot
03:06:37 <dave123> are there test coverage stats anywhere, or should I just do my homework?
03:07:10 <Entroacceptor> if there are none, I see a project for you :)
03:07:16 <RenJuan> you mean of all of hackage?
03:07:32 <RenJuan> (if so, no, it's not that well organized)
03:08:47 <RenJuan> also after that you can prolly claim "Sisyphus" as a freenode nick if nobody else has :)
03:09:20 <dave123> I wasn't thinking all of hackage - was just wondering if anyone had dug around a little on similar lines - even coverage of some of the popular libs would be interesting
03:09:21 <dave123> hehe
03:09:47 <hpaste> bragh pasted “trouble with yi hacking build” at http://hpaste.org/50817
03:09:47 <brisingr> I want to crawl through lambdabot's source and submit some patches if I find something such as the @choose words instead of lines
03:09:57 <brisingr> to learn more haskell
03:10:18 <brisingr> ideas how to start?
03:10:27 <brisingr> (okay, stupid question)
03:10:28 <bragh> ^ i'm getting 'cannot satisfy -package-id yi-0.6.4.0-inplace' when trying to compile the hacking build, i have yi installed on my machine right now and it's working fine
03:13:22 <dave123> I guess the project would be to add something to cabal so you could attach coverage reports, yeah?
03:14:17 <dave123> as a very first step
03:29:22 <bragh> got the yi hacking build fixed by randomly trying around different versions for yi and now it works. cargo cult problem fixing at it's finest. : <
03:45:56 <kamaji> What's 'cubeFrameBuffer' on this page: http://www.haskell.org/haskellwiki/GPipe/Tutorial ?
03:46:00 <kamaji> I can't find it anywhere
03:46:11 <kamaji> oh..... it's further down the page
03:46:14 <kamaji> derp.
04:01:12 <erus`> is it possible to assert that a sentence has correct syntax?
04:01:20 <erus`> i dont need every case
04:02:35 <hpc> totally ignoring prepositions, there's subject-verb, S-V-O, S-V-DO-O
04:02:37 <hpc> um
04:02:49 <hpc> S-is-Ajd
04:02:52 <hpc> *adj
04:03:03 <hpc> and adj-is-S
04:03:24 <hpc> so work from there and a dictionary?
04:03:33 <opqdonut> erus`: no, don't do it
04:03:43 <opqdonut> unless you're making a grammar checker
04:04:18 <kamaji> isn't that a ridiculously hard problem?
04:04:26 <erus`> i was gonna make a rap generating robot
04:04:33 <erus`> working backwards from the last word
04:04:42 <erus`> the rhyming word :)
04:04:45 <opqdonut> oh, you're already in computational-linguistics-land
04:04:49 <hpc> your first mistake is assuming that rappers understand grammar :P
04:04:50 <opqdonut> then go ahead
04:04:53 <kamaji> hahah
04:04:56 <tab> :)
04:05:13 <kamaji> that is the best application of computational linguistics ever
04:05:19 <kamaji> when you publish, let us know~
04:05:25 <bragh> erus`: something aesop rockish? nice
04:05:33 <tab> looking forward to the result
04:06:57 <enlga> add rhyme fuzzing and it will be realistic and hilarious
04:21:27 <erus`> oh god
04:21:46 <erus`> counting syllables is very very complex
04:21:49 <erus`> lots of edge cases
04:23:32 * hackagebot word24 1.0.1 - 24-bit word and int types for GHC  http://hackage.haskell.org/package/word24-1.0.1 (JohnLato)
04:35:27 <erus`> i need to group the vowels and disregard the rest
04:35:50 <erus`> like alien -> ["a", "ie"]
04:37:11 <erus`> should i unfold?
04:37:30 <hpc> :t groupBy
04:37:31 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
04:38:42 <hpc> @let isVowel x = x `elem` "aeiou"
04:38:43 <lambdabot>  Defined.
04:38:46 <hpc> > isVowel 'e'
04:38:47 <lambdabot>   True
04:39:00 <hpc> > groupBy ((==) `on` isVowel) "alien"
04:39:01 <lambdabot>   ["a","l","ie","n"]
04:39:08 <hpc> now drop consonant groups
04:39:11 <erus`> @hoogle groupBy
04:39:12 <lambdabot> Data.ByteString groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
04:39:12 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
04:39:12 <lambdabot> Data.ByteString.Char8 groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
04:41:28 <erus`> groupBy (`elem` "aeiou") "alien"
04:41:31 <erus`> > groupBy (`elem` "aeiou") "alien"
04:41:31 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> GHC.Bool.Bool'
04:41:32 <lambdabot>         agai...
04:41:43 <hpc> types don't match
04:41:56 <hpc> the predicate to groupBy takes two adjacent elements
04:42:20 <hpc> (==) `on` isVowel = "if both are vowels, or both are consonants, True"
04:42:34 <hpc> aka, group things that are equal by the measure of "is it a vowel"
04:45:25 <Peaker> > filter (isVowel . head) . groupBy ((==) `on` isVowel) $ "alien"
04:45:26 <lambdabot>   ["a","ie"]
04:45:57 <erus`> @hoogle on
04:45:57 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
04:45:58 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
04:45:58 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
04:46:00 <Peaker> group followed by head is really common.. it would be nice if group had returned a non-empty list type
04:51:43 <erus`> whats the best pattern for reading parts of a String into tokens
04:51:47 <erus`> using unfold?
04:52:33 <erus`> unfoldr *
04:52:38 <Cale> Well...
04:52:59 <Cale> You almost might as well use something like Parsec in general.
04:53:22 <erus`> seems a bit overkill
04:53:23 <Cale> But you can get away with much simpler things
04:53:28 <erus`> i just have a few rules
04:53:30 <Cale> There's Data.List.Split
04:53:43 <Cale> and then there's words/lines
04:53:52 <Cale> > words "here is a bunch of words"
04:53:53 <lambdabot>   ["here","is","a","bunch","of","words"]
04:54:15 <erus`> im splitting a word into syllables
04:54:29 <Cale> ah
04:54:31 <erus`> "Hello" -> ["hel", "lo"]
04:54:56 <erus`> or "Hello" -> ["he", "llo"] for now
04:55:41 <erus`> i need to find the index of the last of the first group of vowels ... :|
04:55:57 <Cale> Why the index?
04:56:06 <erus`> so i can split it
04:56:14 <Cale> Why would you need the index to split it? :)
04:58:49 <erus`> ok i need a splitOnLastOfTheFirstGroupOfVowels
04:59:01 <erus`> will i need to groupBy like above and then concat>
04:59:04 <erus`> ?
04:59:15 <Cale> @let isVowel = (`elem` "aeiou")
04:59:16 <lambdabot>  <local>:2:0:
04:59:16 <lambdabot>      Equations for `isVowel' have different numbers of argument...
04:59:19 <Cale> wat
04:59:29 <Cale> > isVowel 'a'
04:59:30 <shachaf> @ty isVowel
04:59:31 <lambdabot>   True
04:59:32 <lambdabot> Char -> Bool
04:59:34 <Cale> oh, cool
04:59:41 <Cale> > let (ks,ys) = span isConsonant "hello"; (vs,zs) = span isVowel ys in (ks ++ vs, zs)
04:59:41 <lambdabot>   Not in scope: `isConsonant'
04:59:48 <shachaf> > isVowel 'y' -- Time for the mystery to be resolved!
04:59:50 <lambdabot>   False
05:00:11 <Cale> > let (ks,ys) = break isVowel "hello"; (vs,zs) = span isVowel ys in (ks ++ vs, zs)
05:00:12 <lambdabot>   ("he","llo")
05:01:00 <shachaf> @let isn'tVowel = not . isVowel
05:01:02 <lambdabot>  Defined.
05:02:19 <Cale> @let splitSegment xs = let (ks,ys) = break isVowel xs; (vs,zs) = span isVowel ys in (ks ++ vs, zs)
05:02:20 <lambdabot>  Defined.
05:03:37 <Cale> > unfoldr (\xs -> case xs of [] -> Nothing; _ -> Just (splitSegment xs)) "abracadabra"
05:03:38 <lambdabot>   ["a","bra","ca","da","bra"]
05:04:22 <Cale> > unfoldr (liftM2 (>>) (guard . not . null) splitSegment) "abracadabra"
05:04:22 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe
05:04:23 <lambdabot>                             ...
05:04:25 <Cale> er, hmm
05:04:57 <Cale> > unfoldr (liftM2 (>>) (guard . not . null) (return . splitSegment)) "abracadabra"
05:04:59 <lambdabot>   ["a","bra","ca","da","bra"]
05:05:44 <Cale> unfoldr is unfortunately kinda awkward to use
05:06:08 <Cale> oh, hmm
05:06:20 <Cale> I could upgrade ghc and use a monad comprehension ;)
05:06:45 <Cale> \xs -> [splitSegment xs | not (null xs)]
05:06:55 <shachaf> Cale: You can use listToMaybe. :-)
05:07:03 <Cale> ah, that too
05:07:11 <shachaf> Poor man's monad comprehensions.
05:07:14 <shachaf> (Very poor.)
05:07:24 <Cale> > unfoldr (\xs -> listToMaybe [splitSegment xs | not (null xs)]) "abracadabra"
05:07:25 <lambdabot>   ["a","bra","ca","da","bra"]
05:08:21 <shachaf> > unfoldr (\xs -> listToMaybe [splitSegment xs | let _:_ = xs]) "abracadabra"
05:08:23 <lambdabot>   ["a","bra","ca","da","bra","","","","","","","","","","","","","","","","",...
05:08:29 <shachaf> Hah, I guess it only works with <-, of course.
05:08:44 <quicksilver> Cale: well (guard (p x) >> return x) is actually a very common pattern
05:08:48 <quicksilver> (in this kind of thing)
05:08:51 <quicksilver> it deserves a name really.
05:08:53 <Cale> quicksilver: right
05:09:04 <Cale> Well, along with unfoldr
05:09:15 <quicksilver> it's common even without unfoldr
05:09:22 <quicksilver> it's a way to add assertions to a parser
05:09:22 <shachaf> @let guarded p x = guard (p x) *> return x
05:09:23 <lambdabot>  Defined.
05:09:30 <shachaf> Actually, that could be an Applicative/Alternative function.
05:09:49 <shachaf> But I guess guard isn't defined for that.
05:10:41 <wjlroe> Vital question. What is your favourite color-theme for emacs (and Haskell obviously)?
05:10:53 <shachaf> Black on black.
05:11:08 <wjlroe> hmm, good one
05:13:15 <joe6> just curious, why do haskell apps need ffi? Why cannot it just read the C files and use them? There is Language.C that can read C code.
05:13:29 <joe6> without the need for ffi..
05:13:43 <joe6> isn't ffi just more boiler-plate?
05:13:44 <Starfire> You need the FFI to actually call the C code.
05:15:23 <joe6> i understand that haskell needs FFI to use the C code. But, for haskell apps, why cannot there be a module/interface that automatically generates the bindings. Something along the lines of HSFFIG..
05:15:45 <tab> joe6: sometimes it's not easy to generate bindings
05:15:47 <joe6> automatically generates the bindings behind the scenes, i mean.
05:15:50 <gienah> joe6: c2hs uses Language.C to help with this
05:16:29 <tab> joe6: also you have some use case where you don't necessarily have the source
05:16:38 <joe6> let me check out c2hs. I am writing some bindings-dsl macros and i see that it is mostly peeling the layers of Language.C structures.
05:17:58 <joe6> i meant, I want to write some bindings-dsl macros for FFI bindings. I am trying to generate these macros using Language.C
05:18:22 <joe6> and, I notice that Language.C has all the C code already parsed.
05:19:10 <joe6> why not just use it without the need for bindings? (still not  checked out c2hs. will do so in a few mins..)
05:19:49 <Starfire> In my experience, c2hs is nice if you don't need to use non-opaque structs.
05:20:08 <joe6> what do you mean by "non-opaque"?
05:20:22 <Starfire> If you need to manipulate struct fields directly, for example.
05:20:28 <joe6> oh, ok.
05:21:24 <Starfire> I seem to remember that c2hs doesn't help with defining Storable instances.
05:22:02 <Starfire> But if you only need to hold pointers to opaque structs, it has plenty of magic to make that easy.
05:22:42 <joe6> thanks. i am reading up on c2hs. i found http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/. Is it a good start?
05:22:49 <joe6> or, do you recommend something else?
05:23:22 <gienah> joe6: I think there is a 6 entry tutorial series on the same blog
05:23:42 <Starfire> There is at least the official(?) documentation http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/
05:23:43 <joe6> gienah: yes, I found that.
05:23:51 <joe6> gienah: thanks.
05:24:01 <joe6> Starfire: thanks, will check it out.
05:24:06 <joe6> what about greencard?
05:24:13 <joe6> has anyone used it?
05:24:14 <Starfire> Haven't tried that one.
05:24:50 <Starfire> Hsc2hs helps with defining Storable instances, but you still have to define them yourself.
05:25:05 * gienah has only tried c2hs
05:25:21 <dainanaki> There's also that other weird one
05:25:36 <joe6> dainanaki: what is it?
05:25:44 <dainanaki> bindings-DSL, I think?
05:25:56 <Starfire> I think it would be nice to have some sort of template haskell magic library, that would be able to parse C struct/union definitions using Language.C and expand them to data type declarations with pre-defined Storable instances.
05:26:05 <joe6> dainanaki: yes, that is for defining the ffi bindings.
05:26:13 <Starfire> I started writing one, but ran out of time and enthusiasm.
05:26:18 <dainanaki> Oh, isn't that what we were talking about?
05:26:20 <joe6> Starfire: yes, that would be awesome.
05:26:38 <joe6> Starfire: would you mind sharing your effort?
05:26:54 <Starfire> I never got very far with it, mostly mucking around with Language.C at the GHCI prompt.
05:26:55 <joe6> Starfire: I can take a look at it and see if I can add something.
05:26:57 <milktrader> package documentation is automatically placed in ~/Library/Haskell/doc/index.html and I just pop the address in a Chrome browser to view it. Are there other methods to access the API documentation?
05:27:52 <dainanaki> that's the easiest way, generally.
05:28:52 <milktrader> nothing like ??module_name from within ghci then I guess
05:29:36 <hpaste> Starfire pasted “Struct offset calculation” at http://hpaste.org/50824
05:30:26 <Starfire> joe6: That's not very much, but might be helpful. I suspect it's buggy and non-portable. :)
05:30:33 <joe6> i have some bitfields' C structures that I am trying to generate bindings-dsl macros for.
05:30:46 <joe6> Starfire: ok, thanks.
05:31:11 <dainanaki> milktrader: Not exactly. You can use :t to look at the types of values, :k to see the kinds of types, and :i to view info about pretty much everything but modules. Also, you may not have noticed, but if you tab-complete a modules name all the way, then it'll give you a list of functions available in that namespace.
05:33:01 <Starfire> The "problem" I had with Language.C was that it seems like a very complete implementation of C syntax, and therefore a bit heavyweight (and hard to learn) for just trying to parse and analyze some data types.
05:33:47 <joe6> i find that I am spending most of my time trying to peel the structures to get at the relevant info.
05:34:16 <Starfire> I recall having a very similar experience.
05:34:39 <Starfire> The fact that C has what, 4 or 5 different namespaces doesn't help any.
05:35:28 <Starfire> But to be a faithful representation, Language.C has to deal with all of that, and the resulting structure is somewhat complex.
05:36:30 <joe6> it makes sense for it to do all that. i *wish* there was some library on top of it, which makes it easier to parse out the irrelevant info
05:36:54 <milktrader> dainanaki: nice - but I don't quite understand the tab-complete of a module's name. I've just installed rclient via the cabal install rclient method and I would think ghci would know where to find it, but do I need to give it the full path name to install the module into ghci
05:36:59 <Peaker> Starfire: what namespaces do you mean? "struct" and "union" prefixes being 2?
05:37:15 <Starfire> Peaker: Regular variables, struct tags, union tags at least.
05:37:25 <Starfire> I think that there might be a fourth, but I might very well be wrong.
05:37:49 <Peaker> Starfire: ah, given that the "namespace" prefix is always explicit, it's not very complicated
05:38:03 <dainanaki> milktrader: you cabal install packages, not modules. Packages contain modules. You should look at your local documentation to see what modules rclient provides and then use :m + to load the relevant ones.
05:38:28 <Peaker> any name is only ever looked up in two namespaces, I think (local function name, top-level name)
05:38:33 <gwern> > 12250 - 11559
05:38:34 <lambdabot>   691
05:38:53 <quicksilver> dainanaki: pedantry - :m doesn't load anything, it just alters scope.
05:39:06 <Starfire> Peaker: It's not complicated to reason about in your head, but it does show up in Language.C data structures.
05:39:40 <Peaker> Starfire: Yeah, my experiences with Language.C have not been entirely positive.. I think it may be better to use clang's lib bindings -- it's probably a faster parser, and just as complete
05:39:49 <milktrader> dainanaki: still getting used to terms, thanks. I will try it.
05:40:15 <dainanaki> quicksilver: fair enough. I tend to forget that.
05:41:23 <milktrader> quicksilver: so modules aren't imported per se?
05:41:36 <Starfire> Peaker: I'll have to keep that in mind when I have to parse C again.
05:41:51 <dainanaki> Is there an easy way to use multiple withCStrings in conjunction? Currently I just have them kinda chained together with lambdas, but it seems kind of weird looking.
05:42:33 <joe6> Peaker, can you give more details on the clang's lib?
05:42:41 <joe6> Peaker: package name?
05:42:43 <quicksilver> milktrader: well, importing is just a matter of changing scope
05:42:54 <quicksilver> milktrader: loading does happen but it's automatic and independent of scope changes
05:43:29 <milktrader> so you cabal a package that consists of a bunch of modules and each module has a suite of functions inside, and then you alter scope within ghci  to include access to those functions?
05:43:43 <roconnor> @hoogle Last
05:43:43 <lambdabot> Data.Monoid newtype Last a
05:43:43 <lambdabot> Data.Monoid Last :: Maybe a -> Last a
05:43:43 <lambdabot> Prelude last :: [a] -> a
05:43:48 <quicksilver> you don't need to alter scope
05:43:51 <quicksilver> that's just a convenience
05:43:58 <quicksilver> you can always use Long.Module.Name.thing
05:44:11 <quicksilver> ghci autoloads the package the first time you use some code from it.
05:44:27 <quicksilver> this is orthogonal to whether-or-not it's conveneint to change the scope using :m
05:45:14 <quicksilver> e.g., launch a fresh ghci and type Data.Map.fromList [(1,'a')]
05:45:25 <quicksilver> you'll witness it autoloading array and containers
05:45:30 <quicksilver> no :m required.
05:45:32 <milktrader> quicksilver: thanks, back to the book ... I need to straighten these terms and concepts out.
05:46:03 <Starfire> joe6: http://hackage.haskell.org/package/LibClang -- I'm guessing he's talking about this.
05:46:35 <milktrader> ah, I see ... loading packages array-0.3.2 and containers-0.4.0.0
05:47:02 <joe6> Starfire: thanks, will check it out.
05:48:31 <quicksilver> milktrader: conversely when yoy type :m Data.Map it won't load them yet
05:48:38 <quicksilver> milktrader: (until the first time you use something)
05:49:05 <milktrader> quicksilver sounds lazy-like
05:49:24 <Peaker> joe6: http://hackage.haskell.org/package/LibClang-0.1.0
05:49:33 <Peaker> oh, Starfire replied :)
05:49:37 <joe6> Peaker: thanks.
05:49:39 <milktrader> why bother with :m Data.Map in the first place?
05:49:44 <quicksilver> so you can type fromList
05:49:49 <quicksilver> instead of Data.Map.fromList
05:49:53 <quicksilver> it's just scope management
05:49:59 <Peaker> and get an ambiguity error from another loaded module :)
05:50:00 <milktrader> aha
05:50:15 <Peaker> though the nice "full import syntax in ghci" will let you get qualified names like M for Data.Map
05:50:22 <Peaker> s/will let/lets?
05:50:40 <sbrg> yeah, in 7.0.x+?
05:51:15 <accel> I understand how shit works when haskell calls C functions
05:51:24 <accel> but how does shit works when haskell hands the loop/control over to a C function?
05:51:30 <accel> it seems to break lots of shit
05:51:44 <accel> like a pure haskell function might be called
05:51:52 <accel> but in teh background, the C function changes stuff when the haskell code is not running
05:52:09 <accel> (this is not a problem with haskell calls C, since the C stuff is stored in an IO a; so it's obvious there are sideeffects)
05:52:50 <quicksilver> well C stuff can't easily poke around in unevaluated thunks
05:52:54 <quicksilver> so it can't easily do any harm.
05:53:09 <Guest14981> c stuff isnt stored in a IO a
05:53:11 <quicksilver> if you deliberately make the effort to delve inside haskell heap structures then, obviously, you take your own chances
05:53:19 <quicksilver> but that's not the normal FFI way
05:53:26 <quicksilver> (nor does the FFI specify any way of doing that at all)
05:55:28 <Saizan>  C owning the main loop doesn't make much of a difference here, just don't make mutable stuff appear pure on the haskell side
05:56:12 <Saizan> where by appear pure i mean that you have an API to look at it that doesn't involve IO
05:59:04 <dainanaki> Is there any way to remove attached finalisers from a ForeignPtr?
06:01:12 <quicksilver> I don't think so, no.
06:01:13 <dainanaki> Actually, never mind. That was the wrong approach.
06:01:19 <quicksilver> finalizers normally are :)
06:01:35 <dainanaki> Can't be helped for FFI stuff sometimes.
06:01:43 <EvanR-work> adding and removing stuff willy nilly sounds wrong
06:03:25 <dainanaki> It was a matter of most values marshalled into Haskell from my bindings requiring finalisers, but a select few types of values are apparently managed by the C library instead and I didn't realise that when I asked.
06:05:12 <joe6> Could not find module `C2HS': is what I am getting.
06:05:26 <joe6> I have http://codepad.org/cBXy7fQK
06:05:36 <joe6> i have installed C2HS module from cabal install.
06:05:45 <joe6> any thoughts on what I could be missing?
06:06:22 <erus`> C2HS by the sounds of it
06:07:36 <Saizan> joe6: try c2hs -l
06:08:38 <joe6> Saizan, that helped. thanks.
06:17:29 <milktrader> I typed import Data.List (nub) into ghci, then :i nub to get some more information about the function and all it gave me was its type signature (nub :: Eq a => [a] -> [a]) and a clue on where I could find the actual function -- Defined in Data.List. How can I see the function?
06:18:35 <tab> milktrader: on hackage you got the source button on the right of the function
06:20:18 <koala_man> does anyone have any opinions on which languages make the most efficient compiled code with from the most high level source? (for study and interest)
06:20:43 <koala_man> I've had ghc compile simple types and functions down to a single instruction, for example
06:21:02 <enlga> koala_man: you'll need to compare implementations, not languages :)
06:21:05 <milktrader> tab: found it! thanks
06:21:55 <koala_man> yes. implementations of any language
06:22:58 <enlga> luajit 2
06:23:43 <koala_man> neat, I'll check that out
06:26:20 <quicksilver> koala_man: the ocaml and clean compilers are both well regarded for some cases
06:27:23 <koala_man> quicksilver: sweet, thanks
06:35:35 <kmc> good morning #haskell
06:36:27 <byorgey> morning kmc, how goes it?
06:36:49 <kmc> goes well
06:43:32 * hackagebot fclabels 1.0.4 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.0.4 (ErikHesselink)
06:47:22 <Cillo> hi
06:47:42 <Cillo> may someone explain me what's @ operator?
06:47:54 <kmc> it's not an operator; it's syntax used in patterns
06:47:55 <Cillo> please...i'm getting mad
06:48:08 <Cillo> ok, good
06:48:10 <kmc> the pattern x@p matches the same things as the pattern p, but also binds the variable x to the whole thing that was matched
06:48:11 <RenJuan> take chill pill Cillo
06:48:23 <RenJuan> *a
06:49:01 <Cillo> ok, i'm italian i'll take 2 sec to get the concept :)
06:49:31 <quicksilver> > let a@(b:c) = [1,2,3,4] in (a,b,c)
06:49:32 <lambdabot>   ([1,2,3,4],1,[2,3,4])
06:49:49 <quicksilver> a is the whole thing, b:c is a normal pattern match.
06:49:54 * RenJuan cues "Mambo Italiano".
06:51:46 <Cillo> ok, i'm almost getting it
06:51:57 <Cillo> thank you very much
06:52:55 <roconnor> anyone know where :+: on functors is defined?
06:55:20 <Cillo> oook, i totally got it! very good! You could be real teachers
06:55:46 <quicksilver> several people here are.
06:55:54 <quicksilver> and more were.
06:56:14 <kmc> the people who get paid to teach are not necessarily the people who are best at teaching
06:56:32 <Cillo> That's great, I'm in the right place, i'm a student and i'm starting learning functional programming
06:56:46 <Cillo> kmc that's the truth
06:56:56 <quicksilver> s/teach/X/
06:57:14 <quicksilver> ditto act, rule, drive, fly, count, etc etc.
06:57:53 * RenJuan finds doing the best teacher.
06:58:42 <Cillo> do you teach quicksilver?
06:59:11 <quicksilver> I have done in the past.
06:59:37 <Cillo> why did you learn functional programming?
07:00:41 <eddayyy> mietek: hey
07:00:45 <copumpkin> Cillo: I did it because all the cool kids were
07:01:10 <quicksilver> well I was always aware of it, just because I'm interested in computer programming languages
07:01:20 <quicksilver> I learnt it problem with ML when I was doing a PhD in CS
07:01:26 <quicksilver> s/problem/properly/
07:02:39 <Cillo> s/problem/properly/ ?
07:03:24 <Cillo> copumpkin so you are a cool kid?
07:03:28 <copumpkin> totally.
07:03:54 <luite> the cool kids do agda now
07:03:56 <dainanaki> I think most Haskellers are.
07:04:01 <quicksilver> Cillo: I was correcting my mistype.
07:04:15 <quicksilver> Cillo: I meant to type "I learnt it properly with ML when I was doing a PhD in CS
07:04:38 <quicksilver> but my fingers got bored after 'pro' and typed an unrelated word beginning 'pro'. Which is somethign they often do. Untrustworthy digits.
07:05:24 <profmakx> c
07:05:49 <dainanaki> profmakx gets bored fast.
07:05:54 <profmakx> sorry.
07:06:09 <dainanaki> m
07:06:32 <Cillo> eheh, thank you for the patience...
07:42:55 <mietek> eddayyy: hey
08:12:35 <sbrg> so, tomorrow: 1. drink free beer for 3 hours whilst watching naked women dance 2. pavement
08:12:43 <sbrg> ... oops.
08:12:46 <sbrg> wrong channel.
08:12:49 <sbrg> But feel free to envy me
08:13:11 <monochrom> I envy your pavement
08:13:44 <sbrg> when you're drunk enough, any bit of pavement is a bed.
08:14:07 <sbrg> following that + where I lay my head is home = i live on the streets while I'm drunk.
08:16:22 <kmc> free beer at a strip club?
08:16:33 <rostayob> yeah that's a stupid idea...
08:16:33 <sbrg> kmc: strip at a club with free beer
08:16:46 <accel> how fast is haskell IPC on osx?
08:16:50 <accel> can it run at 120 hz?
08:16:57 <accel> I'm tempted to juse use IPC for haskell/objective-c communication
08:19:37 <dainanaki> I'd honestly be surprised if it was that fast.
08:19:54 <MHD> what exactly is the diference between Control.Monad.Reader.mapReader and Control.Monad.liftM?
08:20:00 <dainanaki> accel: Your best bet is probably to benchmark and see.
08:20:22 <kmc> :t mapReader
08:20:23 <lambdabot> forall a b r. (a -> b) -> Reader r a -> Reader r b
08:20:49 <kmc> huh
08:21:03 <MHD> yeah
08:21:14 <MHD> exactly what I thought...
08:21:14 <kmc> instance (Functor m) => Functor (ReaderT r m) where fmap f  = mapReaderT (fmap f)
08:21:23 <kmc> yeah i think it's just a specialized name for fmap
08:21:30 <MHD> yeah
08:21:39 <MHD> for efficiency or something
08:21:47 <Cillo> what do i have to write literally to define a function?
08:22:33 <MHD> Cillo: nameOfMyFunc takes some arguments = definition
08:22:36 <joe6> any suggestions on what is the best way to show Ident of Language.c: http://codepad.org/1irA975g, I have it this way: http://codepad.org/9ccb1UMv, and the output is: "\"IPL3\""
08:23:03 <joe6> is there a better way of getting rid of the \"
08:23:29 <MHD> joe6: get rid of the show
08:23:38 <Cillo> f n=n+1
08:23:40 <monochrom> Cillo: example: f x = f (x && x)
08:23:40 <MHD> common mistake
08:23:42 <Cillo> is it corret?
08:23:48 <MHD> Cillo: yeah
08:23:49 <monochrom> yes
08:23:59 <Cillo> thanks a lot
08:24:07 <MHD> Cillo: But spaces around the operators is good style
08:24:08 <monochrom> there are more things you can do
08:24:24 <Cillo> great
08:24:31 <Cillo> how do you pm?
08:24:45 <joe6> MHD, this is what it says: http://codepad.org/sQm6HMhh
08:24:47 <MHD> Cillo: /msg name message
08:26:00 <joe6> this is the definition: http://codepad.org/EuvsQczy
08:26:13 <monochrom> use "/msg #haskell hello" to pm to everyone in the channel :)
08:26:33 <ski> joe6 : actually, i think it's the definition of `Show Ident' that you want to change ..
08:26:37 <glguy> /msg #haskell hello should just send a normal message to the channel
08:26:48 <monochrom> yes, same difference!
08:26:49 <ski> monochrom :D
08:26:54 <accel> does this work?
08:27:00 <accel> oh wow it does :-)
08:27:01 <monochrom> yes accel it works!
08:27:08 * accel stops spamming
08:27:09 <glguy> *we're talking on IRC*
08:27:19 <accel> can I do this to channels I'm not part of?
08:27:28 <glguy> accel: that depends if the mode is +n
08:27:28 <joe6> ski, can you please give more details?
08:27:38 <monochrom> no
08:27:44 <joe6> ski, i cannot understand what you just mentioned.
08:27:52 <joe6> ski, sorry for the bother.
08:28:01 <ski> joe6 : can you paste your `instance Show Ident' ("Defined in Language.C.Data.Ident" as you say)
08:28:39 <joe6> ski, this, you mean: http://codepad.org/cTBw8zz4
08:28:51 <joe6> ski, I do not have an instance show Ident.
08:29:22 <monochrom> every "normal" #haskell message is a PRIVMSG #haskell at the protocol level. every /msg #haskell message is also a PRIVMSG #haskell at the protocol level. servers won't know the "difference" in user origin
08:29:32 <ski>   instance Show Ident -- Defined in Language.C.Data.Ident
08:29:36 <ski> line 7 at <http://codepad.org/1irA975g>
08:29:54 <ski> joe6 : that suggests that you have one -- or have you used `deriving Show' ?
08:31:30 <joe6> ski, found identToString in Ident.hs: http://codepad.org/tesRFGSj
08:31:34 <joe6> ski, thanks.
08:40:31 <hpaste> ohrores pasted “recursive prime factorization” at http://hpaste.org/50827
08:41:49 <ski> joe6 : ok
08:43:36 * hackagebot tempus 0.1.0 - Interpreter for the FRP language Tempus  http://hackage.haskell.org/package/tempus-0.1.0 (MatthiasReisner)
08:44:19 <ohrores> I am new to haskell and would like to know what you think about it
08:44:50 <ski> well, naturally we think Haskell is generally quite nice
08:44:55 <ski> ;P
08:45:18 <ohrores> mmmh
08:45:28 <edwardk> ohores: you have a lot of 'paranoid parentheses'
08:45:32 * ski is already looking at the paste, btw
08:45:33 <kmc> #haskell likes haskell
08:45:47 <edwardk> dividable (x:xs) n = if ((floor n) `mod` (floor x)) == 0 then x can become dividable (x:xs) n = if floor n `mod` (floor x == 0 then x
08:45:49 <kmc> ohrores, http://haskell.org/haskellwiki/FAQ#The_real_world
08:45:53 <edwardk> er minus the other paren, etc.
08:46:05 <edwardk> [n] ++ (primesF (x/n)) can be [n] ++ primesF (x/n)
08:46:19 <ski> hlint ought to complain about redundant brackets in `(value:_) <- getArgs', as well
08:46:21 <int-e> ohrores: please don't use Double like this. Use Integer (or Int if you worry about performance)
08:46:25 <tgeeky> a small minority of us are like self-flagellating monks who don't like haskell but use it to systematically punish themselves
08:46:48 <edwardk> actually if you just wiped out the hlint complaints you'd have a pretty good style
08:47:07 <mux> one small nit: we generally don't write functions such as primesTo, since this is so easy to do take N infinite_primes_list
08:47:17 <edwardk> except for as int-e points out the abuse of Double
08:47:39 <mux> primes (x:xs) = (if (isPrime x) then [x] else []) ++ (primes xs)
08:47:41 <mux> this one is rather bad
08:47:56 <edwardk> you can go with something like filter isPrime [1..]
08:47:58 <mux> = if (isPrime x) then x:(primes xs) else primes xs
08:48:02 <mux> and then again
08:48:08 <mux> you can probably do without the if
08:48:11 <edwardk> or make a more efficient sieve
08:48:30 <ski> ohrores : i think `dividable [] _ = 0' is wrong (except when the second input is also `0')
08:51:29 <accel> what is the right way in haskell
08:51:37 <accel> to for C ffi to share data
08:51:46 <accel> i.e. the haskell function calcualtes some list of objects to display
08:51:54 <accel> then the C function needs to run through the list and actually draw them
08:55:13 <MHD> Where can I find some informal introduction to Typed Lambda Calculus?
08:55:52 <glguy> accel: create a c-array of the c representation of the data and had a pointer and a number of elements to C
08:55:55 <c_wraith> accel: it's usually best to copy the list into a C array
08:56:56 <glguy> accel: withArray  :: Foreign.Storable.Storable a => [a] -> (GHC.Ptr.Ptr a -> IO b) -> IO b
08:56:58 <glguy> for example
08:57:38 <glguy> or withArrayLen :: Foreign.Storable.Storable a => [a] -> (Int -> GHC.Ptr.Ptr a -> IO b) -> IO b
09:13:40 * hackagebot xhtml 3000.2.0.3 - An XHTML combinator library  http://hackage.haskell.org/package/xhtml-3000.2.0.3 (ChrisDornan)
09:24:34 <MHD> Holy crap. I just grokked TLC...
09:25:15 <enlga> good news everyone! ghci works on ppc suddenly. don't know when this happened, but GHC 7.0.4 does it
09:25:28 * enlga guesses roughly 3 people in the world care
09:26:00 <bragh> ah, there are probably more. aren't there amiga users still out there?
09:27:33 <Cale> Let me know when it works on a 6502. ;)
09:28:36 <kmc> enlga, i just got a ppc laptop and was vaguely hoping to run xmonad on it
09:28:58 <enlga> ghc has been working on debian for a long time, but ghc --interactive did not
09:29:01 <kmc> also i'm surprised it didn't work before, at least in unregisterised via-C mode
09:29:03 <enlga> so you'll be safe anyway
09:29:06 <kmc> ah, i misread :)
09:29:46 <kmc> yeah, ghci contains its own custom dynamic linker for... some reason?
09:30:17 <joe6> i am doing a lot of pattern-matching to get at the data that I want: http://codepad.org/OTFjpVxe. Is it possible to use fmap to read Language.C data structures?
09:30:35 <joe6> just curious if there is a better way of doing what I am doing.
09:31:41 <joe6> it is incomplete code, but, just posted it, hoping that it will explain my intention.
09:33:22 <tab> joe6: did you had a look at typeable to manipulate the data structure ?
09:33:35 <joe6> tab, no.
09:33:47 <joe6> tab, I have no idea what typeable does. let me check it out.
09:34:05 <joe6> i am trying to read specific values out from the data structure
09:34:22 <joe6> almost like an fmap, I guess.
09:35:17 <enlga> but fmap preserves structure
09:36:43 <rwbarton> enlga: this is on linux on ppc?
09:36:57 <enlga> rwbarton: yes
09:37:24 <tab> joe6: that sounds like a job for typeable
09:37:28 <joe6> enlga: oh, yes. i cannot use fmap
09:37:32 <tab> joe6: i had great success with it for my C to java converter
09:37:37 <rwbarton> good to know, I tried running ghci on Debian ppc a couple years ago
09:37:43 <joe6> tab, thanks. I am reading up on typeable.
09:37:53 <joe6> tab, any good url's that you would recommend?
09:37:58 <joe6> i just googled it.
09:38:36 <tab> joe6: i'll have a look at the paper on SYB
09:38:39 <tab> papers*
09:38:47 <joe6> thanks, will do.
09:39:22 <tab> it's a bit out of date, but if you get the concept, you should be able to run around the documentation and find useful stuff to do
09:39:23 <enlga> rwbarton: there's a debian bug for 7.0.3's ghc --interactive not working though, and I just looked to make sure the bug was tracked in debian. then I actually tried the latest version 7.0.4 and it works for me. I don't think it's a minor version thing, must be something else, a dependency that's different
09:39:36 <Saizan> > listify (Just (1,[3,4],[(Nothing, [5])]) :: [Integer]
09:39:37 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:39:43 <rwbarton> does cabal-install work?
09:39:43 <enlga> rwbarton: I was surprised my ghci worked, I was used to it not working
09:39:50 <Saizan> > listify (Just (1,[3,4],[(Nothing, [5])])) :: [Integer]
09:39:52 <lambdabot>   Couldn't match expected type `r -> GHC.Bool.Bool'
09:39:52 <rwbarton> ISTR that didn't work either
09:39:52 <lambdabot>         against inferred ...
09:39:53 <enlga> rwbarton: yes
09:40:07 <joe6> Saizan, was listify meant for me?
09:40:21 <Saizan> > listify (const True) (Just (1,[3,4],[(Nothing, [5])])) :: [Integer]
09:40:22 <lambdabot>   Ambiguous type variable `a' in the constraint:
09:40:22 <lambdabot>    `Data.Data.Data a'
09:40:22 <lambdabot>      a...
09:40:30 <Saizan> ugh, well, something like that
09:41:18 <Saizan> joe6: yes, it's part of SYB
09:41:32 <joe6> Saizan: ok, thanks.
09:45:11 <unguest> would anyone provide a rainow penis for a hefy?
09:45:32 <unguest> *sum
09:46:20 <unguest> wouldn't have to be all rainbwish
09:46:28 --- mode: ChanServ set +o Cale
09:46:39 --- mode: Cale set +b *!*@*.nationalcablenetworks.ru
09:46:39 --- kick: unguest was kicked by Cale (unguest)
09:46:55 --- mode: Cale set -oo Cale Igloo
09:47:51 <augur> Cale: wtf was that
09:48:08 <Cale> no idea
09:48:46 <ski> Cale : you have a 6502 you'd like to employ ? :)
09:50:10 * ski ponders how to get GHCi running on his 1541 disk drive (having 4K RAM, and apart from reading floppy diskettes or serial port, only have a one-bit input (sensor) and one-bit output (led))
09:51:06 <erus`> good luck sir
09:51:12 <Cale> ski: heh, I just think it would be epic win to have GHCi running on a Commodore machine, especially given the Haskell logo :)
09:51:28 <Cale> (admittedly, pretty impossible)
09:52:34 <ski> hm, the VIC-20 had only 3K RAM available in unexpanded mode (could be expanded with 24K extra, iirc)
09:53:22 <ski> (and the C64 doesn't have a 6502, it has a 6510 -- it's the same wrt machine code, though)
09:53:32 <ClaudiusMaximus> my commodore 386 has a few MB (can't remember exactly how many, I had to enable swap to compile lua on it)
09:54:04 <Cale> ski: Oh right, yeah.
09:54:16 * ski has pondered implementing some subset of Scheme on his C64
09:54:48 <Cale> The NES has a 6502 in it
09:54:55 <Cale> sort of
09:55:40 <Cale> lol, Haskell on an NES :)
09:56:31 <ski> i've played a little with a C compiler on the C64, and with a (simple) unix-like OS on it
09:56:55 <ski> .. and there's already <http://lemonodor.com/archives/2007/11/microlisp.html>
09:57:59 <joe6> Saizan: could I use uniplate for this?
09:59:30 <joe6> or, maybe traversable?
10:02:54 <joe6> i am trying to understand the Typeable class. Any recommended links/url's?
10:04:07 <mauke> class Typeable a where typeOf :: a -> TypeRep
10:04:34 <kmc> there isn't much to it
10:04:50 <kmc> it lets you get a representation of a value's type at runtime
10:04:50 <joe6> ok, thanks.
10:05:09 <kmc> the API docs give you most of what you need
10:05:23 <kmc> one important rule is that you should never write an instance of Typeable yourself
10:05:33 <kmc> only derive it using GHC's DeriveDataTypeable extension
10:06:10 <kmc> if you write a Typeable instance and make a mistake then you can break the type system leading to segfaults / arbitrary heap corruption / exploitable security holes
10:06:18 <joe6> kmc, thanks.
10:06:19 <ski> > listify (const True) (Just (1,[3,4],[([Nothing,Just 3], [5])])) :: [Integer]  -- Saizan
10:06:20 <lambdabot>   [1,3,4,3,5]
10:06:36 <sbrg> > :t listify
10:06:37 <lambdabot>   <no location info>: parse error on input `:'
10:06:40 <sbrg> eh
10:06:43 <sbrg> :t listify
10:06:44 <lambdabot> forall r a. (Data a, Typeable r) => (r -> Bool) -> a -> [r]
10:07:55 <kmc> joe6, Typeable by itself doesn't give you much for generic programming
10:08:06 <kmc> but it's an ingredient in the "Scrap Your Boilerplate" scheme
10:08:18 <kmc> see Data.Data, syb package, and the SYB papers
10:08:22 <joe6> kmc, thanks. i am just installing syb
10:18:42 * hackagebot uri 0.1.6 - Library for working with URIs  http://hackage.haskell.org/package/uri-0.1.6 (JaroslavGridin)
10:23:42 * hackagebot cereal-ieee754 0.1 - Floating point support for the 'cereal' serialization library  http://hackage.haskell.org/package/cereal-ieee754-0.1 (JacobStanley)
10:36:51 <bfig> hello. to use wxHaskell can i get whatever packages i need through cabal and hackage?
10:37:43 <Eduard_Munteanu> I think you also need wxWidgets itself, which Cabal can't get for you.
10:37:56 <Eduard_Munteanu> just like with other non-Haskell deps
10:46:59 <mister_m> what does the definition of the IsInfixOf function look like ?
10:47:39 <monochrom> @src isInfixOf
10:47:39 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
10:49:33 <mister_m> @src isPRefixOf
10:49:33 <lambdabot> Source not found. Just try something else.
10:49:38 <mister_m> @src isPrefixOf
10:49:38 <lambdabot> isPrefixOf [] _          = True
10:49:38 <lambdabot> isPrefixOf _  []         = False
10:49:38 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
10:49:51 <kmc> isInfixOf isn't using a clever string-search algorithm
10:50:33 <ezyang> I wonder why GHC doesn't know how to inline monad transformers into an optimized monad automatically.
10:50:36 <mister_m> I'm having a hard time thinking functionally and lazily
10:51:23 <bfig> Eduard_Munteanu, so i need to install wxWidgets and download through cabal wxHaskell ?
10:53:00 <sbrg> mister_m: just relax, put some good tunes on and grab a beer
10:53:08 <sbrg> then you at least got the lazy part covered
10:53:12 <mister_m> sbrg: I might need a couple
10:53:52 <mister_m> sbrg: I'll try to tackle more of the 99 problems
10:53:55 <sbrg> mister_m: I first grokked monads after a good few guinness. Needless to say, my friends did not share my interest in my epiphany
10:55:52 <mister_m> sbrg: I haven't read about any of that yet
10:57:26 <sbrg> mister_m: look forward to it. For ahead lies nirvana!
10:58:11 <lysgaard> I want to represent a function using data-types in haskell? How does one do that?
10:58:51 <c_wraith> algebraic types?
10:59:23 <c_wraith> I mean, fundamentally, the answer to that is "an interpreter"
11:01:09 <kmc> lysgaard, why not represent a function as a function?
11:01:12 <maurer_> Hey, does anyone know how to convince ghc to build a statically linked .o?
11:01:24 <maurer_> I'm trying to use foreign export, but for various reasons, I can't allow ghc to do the final link
11:01:29 <kmc> maurer_, did you try ghc -static -optl-static -o foo.o -c foo.hs
11:01:46 <maurer_> kmc: That's a start, but I need it to pull in the runtime and such?
11:01:48 <lysgaard> kmc: Because if I want to be able to manipulate the function based on what arguments it get.
11:02:36 <kmc> lysgaard, that sounds like... a function
11:02:40 <kmc> can you go into more detail?
11:03:38 <lysgaard> I'm trying to build a simple Computer Algebra System in Haskell. To do opperations like simplifying (x + 0) to just x I need some way to represent the plus function with it's arguments, without evaluating it. Then let the user choose to do the simplification.
11:03:52 <kmc> data Expr = Literal Int | Variable String | Add Expr Exp.r
11:03:58 <kmc> err Add Expr Expr
11:04:51 <lysgaard> kmc: Yeah, bu that's not general. What if i want to represent arbitrary functions?
11:05:04 <kmc> how are those functions entered by the user?
11:05:12 <kmc> presumably, using a syntax with a finite description
11:05:48 <lysgaard> Right now I'm just creating expressions by hand using a similar datatype as you listed above.
11:06:06 <c_wraith> lysgaard: the answer is still "write a data type and an interpreter for it"
11:06:49 <Younder> what does bluetooth cost?
11:07:07 <kmc> maurer_, how about something like ld -o combined.o -t foo.o -L /usr/lib/ghc -lHSrts -L /usr/lib/ghc/ghc-prim-0.2.0.0 -lHSghc-prim-0.2.0.0 ...
11:07:10 <kmc> you'll need more of those though
11:07:47 <kmc> you might also want to pass the .a files directly to ld instead of using -L/-l
11:10:17 <maurer_> Hm, let me get back to you, I may have found a way to trick it, I just need to test it
11:10:57 <mister_m> kmc, that is called an algebraic data type, right?
11:11:37 <kmc> which is?
11:11:48 <lysgaard> c_wraith: kmc: I'll see if I can wrap my head around it. Thanks for the help
11:11:51 <kmc> types declared with Haskell's "data" keyword are algebraic data types
11:12:08 <kmc> "algebraic" because they're a sum of products
11:12:13 <kmc> "sum" refers to the choice between constructors
11:12:25 <kmc> "product" refers to the fact that each constructor holds several values
11:12:30 <kmc> i can elaborate on why they're called that
11:12:56 <maurer_> kmc: -optl-r
11:13:19 <maurer_> I'm essentially trying to say "Mr. GHC, it's time for you to do the final link" Pssst. Hey linker. Don't do what that guy says. Don't finalize the link
11:13:25 <kmc> heh
11:13:29 <kmc> oh, yeah, i meant -r instead of -t above
11:13:37 <kmc> but that's better, making GHC do it directly :)
11:13:38 <kmc> clever
11:14:05 <sbrg> Do any of you beautiful people know of a library that allows you to replace custom variable names within String easily? Parametrization, is that the word? E.g. replace "VAR" "foo" "$VAR$bar" = "foobar"
11:14:09 <sbrg> something like that
11:14:20 <sbrg> though it seems like an easy thing to do now that I think about it
11:14:42 <maurer_> kmc: Looks like I need to do a bit more voodoo, I'll get back to you if it works
11:14:56 <maurer_> d
11:16:16 <kmc> a similar flavor of hack is to replace gcc / ld in your path with a script that munges arguments before calling the real program
11:18:46 * hackagebot vector-algorithms 0.5.3 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.5.3 (DanDoel)
11:21:00 <maurer_> kmc: Not an option in this case
11:21:24 <maurer_> kmc: Also, I am now stuck with an issue where ghc appears to statically link in _some_ of pthreads but not all of it
11:21:39 <maurer_> So if I try to use -lpthread to solve the problem, I get multiply defined symbols
11:21:49 <kmc> bleh
11:22:31 <kmc> "use objcopy to set all the symbols in libpthread.a as weak"
11:22:49 <maurer_> :(
11:23:29 <kmc> what platform is this?
11:23:57 <maurer_> kmc: i686
11:24:01 <maurer_> Linux
11:24:25 <maurer_> Basically, I am in a situation where I am allowed to control a single directory for the make procedure
11:24:32 <maurer_> So I need to produce a .a that they will pull in
11:25:58 <kmc> bleh
11:26:16 <kmc> well, cabal produces a .a when it builds a library
11:26:36 <maurer_> kmc: Yes, but they are not suitable for linking by regular programs
11:26:45 <kmc> what if you just toss that and libHSrts.a etc. in the same archive
11:26:46 <kmc> why not?
11:27:04 <maurer_> kmc: They lack the runtime, and don't autoinit the stgmachine
11:27:15 <maurer_> e.g. C won't be super happy with them
11:27:49 <kmc> the first thing is fixed by the ar tricks i suggested
11:27:58 <maurer_> Just tossing libHSrts.a in there?
11:28:10 <kmc> well, un-ar it and throw all the objects together
11:28:12 <kmc> could work
11:28:16 <kmc> the second is a problem with -optl-r too
11:28:17 <ronwalf> argh.  ghc --make works on my project, while cabal install fails to terminate
11:28:40 <maurer_> kmc: I've solved that by having a c file that provides a version of the function that inits the machine if neccessary
11:28:47 <kmc> i mean in general, the Haskell code is no use if the C code doesn't know how to call it.  part of that is knowing that it should call a particular function before using anything else
11:28:52 <kmc> yeah
11:28:56 <ronwalf> (while compiling, ghc 7.0.3 cabal 1.10.1.0 cabal-install 0.10.2)
11:29:10 <maurer_> kmc: Though eventually I'm going to try to Do the Right Thing and hide that in ctors/dtors
11:29:13 <kmc> you can do that if the .a comes out of Cabal too
11:29:14 <kmc> yeah
11:29:35 <ronwalf> Odd thing is, it's cabal running ghc that's not terminating.  I'm not sure how it's doing that
11:29:38 <monochrom> does "cabal configure" then "cabal build" terminate?
11:29:47 <ronwalf> cabal build does not
11:30:00 <monochrom> that is fun
11:30:12 <ronwalf> ghc sucks up the cpu, sits at some 3gb vsize, 772mb rsize
11:30:26 <lysgaard> kmc: I solved it, to make a data type for a general function one has: data Ex = Const Double | Var String | Fun String Int [Ex] , where the arguments to Fun is the name, the correct number of arguments and a list of arguments.
11:30:46 <monochrom> "cabal build" passes elaborately chosen parameters to ghc and is different from "ghc --make"
11:34:16 <maurer_> kmc: /usr/bin/ld: cannot find -lgcc_s
11:34:19 <kmc> lysgaard, ah.  you wanted a way to represent function *calls* not functions themselves
11:34:19 <maurer_> Any ideas?
11:34:33 <kmc> maurer_, find /usr/lib -name '*gcc_s*' ?
11:34:35 <kmc> i dunno
11:34:47 * kmc actually uses find | grep but doesn't want to look un-leet in front of the others
11:35:35 <maurer_> kmc: That should be on the default search path though
11:35:50 <maurer_> And adding it via -optl-L didn't help
11:36:05 <maurer_> Oh, it's only available as a .so?
11:36:19 <kmc> beats me
11:36:28 <kmc> maybe _s stands for shared
11:37:15 <maurer_> Oh, I might have it, onesec (-static-libgcc seems to helP)
11:38:43 <maurer_> kmc: Now builds, but segfaults, debugging oclock
11:44:17 * kmc has a party re-installing every package in the world with profiling enabled
11:45:13 <sbrg> kmc: god
11:45:16 <sbrg> been there, done that
11:45:18 <sbrg> failed that
11:45:25 <monochrom> how many times have you had such parties?
11:45:40 <edwardk> kmc: good luck
11:46:07 <monochrom> don't forget to build them again with haddock enabled
11:46:31 <monochrom> and don't forget to build them again with --shared enabled
11:47:44 <kmc> next platform I'm installing from source with all this turned on from the start
11:50:02 <JoeyA> What's a good way to document data constructor arguments?
11:50:17 <mauke> comments
11:50:20 <JoeyA> e.g. data Range = Range Int Int -- I want to point out which is the start and end
11:50:22 <monochrom> give them field names
11:50:29 <erus`> lets get haskell on the gameboy advance
11:50:32 <JoeyA> Though in my case, I have multiple constructors
11:50:36 <edwardk> data Range = Range { lo, hi :: Int }
11:50:48 <kmc> that reminds me; is there a way to derive the non-record Show instance for a record type?
11:51:03 <JoeyA> edwardk: Won't that pollute the namespace, though?
11:51:11 <edwardk> yes
11:51:15 <kmc> maybe the 'derive' package can do it
11:51:18 <edwardk> the usual idiom is rangeLo, rangeHi
11:51:26 <kmc> "pollute" the namespace with useful functions
11:51:30 <JoeyA> thanks
11:51:30 <edwardk> basing the prefix on the name of your constructor
11:51:38 <kmc> if it's the only or main record in the module, i'd leave off the prefix
11:51:43 <edwardk> yeah
11:51:44 <kmc> people can import qualified
11:51:56 <mister_m> if I have a list of lists and I want to flatten them into a single list - would using foldl be a good start?
11:52:04 <kmc> foldr is probably better
11:52:08 <kmc> but there's a function for that already
11:52:09 <kmc> :t concat
11:52:10 <lambdabot> forall a. [[a]] -> [a]
11:52:15 <edwardk> or concat
11:52:16 <edwardk> yeah
11:52:23 <monochrom> haddock has a provision for individual fields, too
11:52:46 <kmc> mister_m, one school of thought is: write the explicit recursion first, then see if it fits a pattern like foldr
11:53:34 <JoeyA> Ah, I'm glad this works: data Foo = A {tag :: String} | B {tag :: String}
11:53:40 <bfig> 'm having trouble with cabal install cabal-install > it doesn't do anything. if i do cabal update i get told new version of cabal, run cabal install cabal-install, i do that (even with sudo) and then try to cabal update again, same result
11:53:43 <maurer_> kmc: It work!
11:53:49 * hackagebot trifecta 0.41 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.41 (EdwardKmett)
11:54:01 <maurer_> kmc: $(GHC) $(HSFLAGS) -o $@ $(GHCCFLAGS) $(GHCLDFLAGS) -optl-r -optl-nostartfiles -optl-pthread $^
11:54:20 <maurer_> HSFLAGS= -static -optl-L/usr/lib/ -optl-static-libgcc
11:54:39 <maurer_> The GHCCFLAGS and GHCLDFLAGS are just passthroughs for the program's CFLAGS and LDFLAGS :)
11:54:59 <monochrom> richardwagner, I am a fan of your great Ring cycle! \∩/  however, I heard that other people say that you are sexist. what do you say?
11:55:24 <edwardk> i made trifecta a bit smarter about reporting 'expected: "foo"' error messages. now it'll break them up into separate notes if they aren't where the cursor is
11:56:10 <edwardk> this actually makes it a fair bit nicer than parsec in this regard which can give some confusing error messages when you abuse try too heavily without wrapping the try in a <?>
11:56:23 <mister_m> kmc: it would probably be good practice for me to try to write an explicit version
11:57:27 <monochrom> anyway, you can in fact have data Fields = A{f0 :: T0} | B{f0 :: T0, f1 :: T1} | C{f1 :: T1}. it just means f1 (A blah) = ⊥, etc.
11:58:04 <monochrom> the only requirement is f0 has type T0 throughout, f1 has type T1 throughout, that's all
11:59:26 <monochrom> ghc's source code itself uses this aggressively. see for example the types in ghc api
12:01:12 <monochrom> "cabal install cabal-install" doing "nothing" is strange. it should at least print something
12:01:30 <monochrom> make it s/should at least print/at least prints/
12:02:09 <monochrom> 10% probably a black hat replaced your cabal.exe with malware
12:06:08 <bfig> monochrom, it does stuff, only it is 'idempotent'
12:06:11 <mister_m> what would a pattern that matches a nested list look like?
12:06:25 <bfig> it appears to install stuff but doesn't install anything
12:06:43 <bfig> or better said, doesn't get to a point where it doesn't stop updating >_>
12:06:55 <bfig> *doesn't get to a point where it stops updating >_>
12:09:20 <monochrom> "told new version of cabal" I want to see the exact sentence verbatim copy-paste no human re-type
12:09:36 <bfig> ok, i'll paste the console output
12:09:40 <bfig> 1 seg
12:10:19 <bfig> monochrom, http://pastebin.com/rNBqn8sm
12:10:23 <mauke> The paste rNBqn8sm has been copied to http://hpaste.org/50833
12:11:18 <mauke> is ~/.cabal/bin in your PATH?
12:11:25 <monochrom> is /home/bfig/.cabal/bin in your PATH and early enough?
12:11:40 <bfig> i have no idea... but this has worked before :S
12:11:43 <JoeyA> If you're using GADTs, and you have, say, data Expr a = ...
12:11:55 * bfig checks
12:11:58 <JoeyA> How would you write a parse function, where the resulting expression isn't exactly one type?
12:12:02 <monochrom> otoh I personally would not care about upgrading cabal-install twice every month
12:12:14 <copumpkin> JoeyA: data Expr a where ... ?
12:12:24 <bfig> /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
12:12:27 <monochrom> "yeah, new new new version, whatever, I have haskell platform and it works"
12:12:33 <copumpkin> JoeyA: you mean the type is determined by the value being parsed, not by the caller?
12:12:38 <JoeyA> right
12:12:43 <copumpkin> existential wrapper
12:12:48 <copumpkin> or higher-rank continuation
12:12:49 <copumpkin> sadly
12:12:50 <JoeyA> Thought so
12:12:54 <copumpkin> they're equivalent
12:13:05 <copumpkin> I generally prefer the higher-rank continuation
12:13:11 <bfig> i'm on a programming course and we're testing a lot of libraries available
12:13:11 <monochrom> "which cabal" may be educational
12:13:38 <bfig> /usr/bin/cabal
12:13:42 <bfig> what happens with that?
12:13:57 <monochrom> but nevermind, /home/bfig/.cabal/bin is not in PATH, you can keep reinstalling stuff there a million times
12:13:59 <bfig> it doesn't have .cabal, but...
12:14:28 <bfig> how can i permanently add that to the $PATH ?
12:15:01 <monochrom> that depends. upload your whole file system for a free analysis
12:15:02 <bfig> i think this was something in a bash.rc file or similar?
12:15:46 <monochrom> must you absolutely upgrade to the newest newest newest version of cabal-install?
12:16:07 <mauke> bfig: ~/.bashrc if you're using bash
12:16:20 <bfig> not really... but i want to download packages through cabal and it is not letting me unless i upgrade
12:16:28 <bfig> mauke, i can't find the PATH variable there :S
12:16:30 <monochrom> untrue
12:16:35 <mauke> bfig: ... ok?
12:17:15 <bfig> mauke, do ij ust need to add the line $PATH = $PATH:~/.cabal/bin/ ?
12:17:23 <mauke> no
12:18:01 <monochrom> http://hackage.haskell.org/package/wxHaskell is a fairly strong sign that there is no wxHaskell, and it doesn't matter which version of cabal-install you use
12:18:21 <mauke> bfig: PATH="$HOME/.cabal/bin:$PATH"
12:18:29 <monochrom> but there is a http://hackage.haskell.org/package/wx
12:18:31 <peteriserins> preflex: seen conal
12:18:46 <conal> peteriserins: hi
12:19:17 <peteriserins> conal: hi, finally get to meet you here :)
12:19:25 <conal> peteriserins: yeah :)
12:19:47 <conal> peteriserins: i'm in california. where are you?
12:19:52 <peteriserins> conal: Latvia
12:19:55 <bfig> what will happen now that there are two cabals in the path ?
12:20:05 <conal> peteriserins: ah!
12:20:05 <monochrom> the first one found is used
12:20:13 <peteriserins> conal: indeed it's a small overlap
12:20:15 <bfig> ahh cool
12:20:27 <monochrom> did you, like, take a unix course? you should. very enlightening
12:20:41 <peteriserins> conal: I actually have some more questions now, but I'll start with the first one
12:20:54 <monochrom> more specifically, very demystifying
12:20:55 <conal> peteriserins: great. fire away. (i've forgotten the topic.)
12:21:25 <peteriserins> conal: I've reduced it to the following: does amb or unamb allow you to keep computing the value of the 'slower' argument?
12:21:25 <monochrom> after the unix course, nothing looks magic again, ever
12:21:25 <bfig> no real time to take a course :|
12:21:42 <monochrom> everything will look like scientifically explanable
12:21:49 <bfig> lol
12:22:15 <peteriserins> conal: e.g., if amb was the only way of doing parallelism, is there a trick to compute two things in parallel?
12:22:18 <bfig> ok, i got it. i'm a noob >_>
12:22:50 <kmc> computers aren't magic, we just draw special patterns onto sand to make it capable of thought
12:23:05 <monochrom> I hope your shiny new cabal-install will still tell you there is no wxHaskell
12:23:16 <conal> peteriserins: checking that i understand your question: suppose i have d = a `unamb` b, and e = a `unamb` c. and suppose that b resolves (to weak head normal form) before a. and then we want to evaluate e. is your question whether or not the work in computing a so far gets reused?
12:23:27 <rick^> computers are fantastic all the same
12:23:46 <peteriserins> conal: yes, exactly
12:24:29 <rick^> the inventor of the cathod ray tube believed that, spirits or some other entities could move the electrons
12:24:41 <rick^> so there might be some magic possible with the hardware
12:24:45 <rick^> :)
12:24:57 <monochrom> that's a discoverer, not an inventor
12:25:00 <rick^> & those were the 1st elecronic images i think
12:25:19 <kmc> in Turing's original paper about the Turing Test he mentions the possibility of using ESP, telepathy, etc. to cheat at the test
12:25:20 <conal> peteriserins: ah, okay. i don't know the answer. i sure hope it's "yes", but i've been impressed with the subtlety of the underlying mechanisms in GHC's run-time system. in fact a few GHC bugs surfaced exactly around these issues.
12:25:21 <rick^> well the device was an invention
12:25:26 <kmc> nobody can quite tell whether he was joking or not
12:25:27 <monochrom> an inventor is someone like Edison who will it and design it intelligently
12:26:08 <conal> peteriserins: sadly, although the denotational semantics of unamb & lub are very simple, the implementation building blocks aren't. or at least i'm not well acquainted with them.
12:26:28 <rick^> in fact possibly one of the 1st ever electronic images was some occult symbol.. cross i think
12:26:33 <peteriserins> conal: good to know it was intended to work this way
12:26:41 <peteriserins> conal: that positively resolves my initial question
12:27:01 <peteriserins> conal: I wanted to be able to do fast non-deterministic merging of two lists of Improving values
12:27:11 <bfig> bah just cabal install wx
12:27:16 <JoeyA> It seems to me like in C, code is easy to read and type signatures are somewhat harder to read, while in Haskell, code is hard to read and type signatures are easy to read.
12:27:20 <bfig> thanks for helpign with the config mauke
12:27:21 <rick^> monochrom, we'd probably never have had AC if edison had his way :)
12:27:38 <conal> peteriserins: i'd love to find a collaborator who can help get to a very clear & well understood & well articulated implementation. and then further explore applications of unamb/lub. my hunch is that it's as important a modularity tool as laziness/non-strictness is.
12:27:43 <kmc> the type signatures in C tell you almost nothing useful JoeyA
12:27:54 <monochrom> but we do have light bulbs
12:28:10 <conal> peteriserins: ah, hm. non-determinism *and* re-use. tricky stuff.
12:28:18 <JoeyA> char *foo(const char *, size_t)
12:28:18 <incluye> yeah well it's not really okay to admire anybody without qualifying our admiration
12:28:30 <conal> peteriserins: i think these two directions are usually at odds with each other.
12:28:30 <conal> p
12:28:30 <conal> et
12:28:36 <JoeyA> That tells me plenty... sort of.
12:28:39 <monochrom> and Edison does not fit the parallel description "he doesn't know what is causing the light"
12:28:54 <peteriserins> conal: an application would be computing the sum of two improving interval values
12:28:55 <JoeyA> Though I hate when people don't name parameters in function signatures in C .
12:29:18 <peteriserins> conal: we would like to get a good approximation as fast as possible, so zipping would be suboptimal in that sense
12:29:32 <kmc> our long national nightmare of not having the latest version of pandoc is finally over
12:29:35 <nrtelang> use cdecl?
12:29:39 <conal> peteriserins: and in your example, there's an interesting twist, namely that the list merging is only non-deterministic relative to the *representation*, not to the semantics of that representation. i.e., to lists, but not to their meaning as improving values.
12:30:06 <conal> peteriserins: agreed. zipping is a poor choice. even an incorrect one.
12:30:21 <conal> peteriserins: because it could give bottom, where the correct answer is not bottom.
12:30:42 <peteriserins> conal: hmm, yes
12:30:46 <Eduard_Munteanu> < bfig> Eduard_Munteanu, so i need to install wxWidgets and download through cabal wxHaskell ?
12:30:59 <Eduard_Munteanu> bfig: yes, you need to install whatever non-Haskell dependencies there may be.
12:31:21 <conal> peteriserins: have you read warren burton's papers about determistic denotational semantics with nondeterministic operational semantics? he uses the terms "semantics" vs "behavior" iirc.
12:32:23 <peteriserins> conal: haven't come across them, I read functional programming applied to parallel combinatorial search to learn about amb
12:32:58 <conal> peteriserins: that's the stuff. was it his student's dissertation (jackson)?
12:33:02 <roconnor> preflex: seen gwern
12:33:41 <peteriserins> conal: seems so
12:34:34 <conal> peteriserins: my sense is that in haskell we have only scratched the surface of possibilities in this area with our simple & restrictive form of laziness. it's a limited form of denotationally benign side effects. warren burton was pointing to a promising direction we haven't pursued. so does colin runciman in his paper "What about the natural numbers?"
12:35:12 <mauke> why does my bot keep dying. grr.
12:35:16 <monochrom> what about the natural numbers? :)
12:35:49 <monochrom> and bottoms keep dying, yes :)
12:35:57 <peteriserins> conal: I am only a few weeks into haskell now, so I'm afraid these issues are still foreign to me :)
12:36:28 <mauke> since I changed to the new extensible exceptions my 'catch' has stopped working
12:36:38 <conal> peteriserins: btw, do you really want amb rather than unamb? it's the latter that has well-understood and even simple semantics.
12:36:54 <monochrom> perhaps wrong 'catch', as in, wrong module
12:36:55 <dolio> What's the semantics of unamb 3 4?
12:37:06 <mauke> monochrom: that should cause a type error
12:37:08 <peteriserins> conal: in the case of non-deterministic merging, I do not see a way to circumvent it
12:38:26 <mauke> the only obvious difference I see is the change from throwDyn to liftIO . throwIO
12:38:36 <conal> dolio: doesn't have one. outside of the domain of unamb/lub. with a fancier type system, we'd catch that bug statically. if i had to give it a semantics, it'd be top.
12:38:55 <hpc> top?
12:39:26 <conal> peteriserins: because the possible results observably differ?
12:39:27 <peteriserins> conal: another question I have of a more general nature is related to FRP
12:39:32 <peteriserins> conal: yes
12:39:35 <mauke> but even then it should either 1) fail to throw the exception,  2) throw the exception and catch it, or 3) throw the exception and die
12:39:53 <conal> peteriserins: however, the *meanings* of those differing results are equal.
12:39:55 <mauke> what's actually happening is that the exception is thrown (based on debugging output) and then everything hangs
12:40:07 <mauke> in a select loop watching 0 descriptors
12:40:16 <conal> peteriserins: understood as an abstract type, they're equal.
12:40:18 <peteriserins> conal: yes
12:41:08 <conal> peteriserins: as long as you enforce the abstraction, i'd use lub/unamb.
12:41:46 <peteriserins> conal: in practice, wouldn't I always want an approximation of that value?
12:41:57 <conal> peteriserins: though really i'd like this whole sketchy area to be explored and put on the solid ground of a general theory, not hacked up for special things. as part of the evolution of pure functional programming.
12:42:09 <monochrom> whereas ⊥ stands for lacking information, ⊤ could stand for having way too much information, i.e., conflicting information. if you want a ⊤
12:42:36 <conal> monochrom: yes. exactly what i had in mind: too much information.
12:42:56 <conal> peteriserins: an approximation?
12:43:42 <peteriserins> conal: well, I suppose the pure form of improving intervals could only be used for
12:44:21 <peteriserins> conal: comparing things or seeing if an equation can be solved, for instance
12:44:56 <peteriserins> conal: if these were the only uses, I could see the possibility of using unamb only
12:45:06 <conal> peteriserins: "only"? are there some things you'd like to do that you expect not to have pure semantics?
12:45:44 <peteriserins> conal: well, extracting bounds of a given maximum size
12:46:22 <conal> peteriserins: i don't understand that example. what are bounds here? and size?
12:46:31 <peteriserins> conal: there are infinitely many such bounds, but I would like to know any of them
12:47:01 <peteriserins> conal: if the improving value represents x, a bound [a, b] is such that x is known to be a <= x <= b and size |a - b|
12:47:22 <conal> peteriserins: oh. i think i get you. in that case, i would look for a better abstraction that suffices but doesn't leak.
12:48:03 <conal> peteriserins: ie one that doesn't expose the operational nondetermism.
12:48:34 <conal> peteriserins: would probably require some creativity.
12:48:50 * hackagebot bindings-DSL 1.0.14 - FFI domain specific language, on top of hsc2hs.  http://hackage.haskell.org/package/bindings-DSL-1.0.14 (MauricioAntunes)
12:48:53 <hnsz> So haskell is alzy evaluating lagnuage but every algorithm is not lazy so for instance "map (*2) list" will not start composing the outlist untill it reaches the basecase.
12:48:56 <peteriserins> conal: indeed, I hadn't thought of it that way
12:49:09 <kmc> hnsz, it won't?
12:49:11 <hnsz> s/lazy/lazily/
12:49:14 <kmc> > map (*2) [1..]
12:49:15 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
12:49:37 <peteriserins> conal: abstracting away the need to approximate
12:50:02 <hnsz> kmc: Okey cool but basically what it does in theory is append an element to the left of a list x*2:[]
12:50:14 <kmc> @src map
12:50:15 <lambdabot> map _ []     = []
12:50:15 <lambdabot> map f (x:xs) = f x : map f xs
12:50:35 <hnsz> kmc: okey :)
12:50:56 <peteriserins> conal: will think about this
12:51:31 <peteriserins> conal: currently though, I'm trying to understand FRP using your papers
12:51:54 <kmc> hnsz, it's fully lazy.  as you demand elements out the output list, it evaluates the spine of the input list
12:51:59 <hnsz> kmc: Okey good so this evaluates the expression on the left immediately
12:52:20 <kmc> and it only evaluates the individual elements of the input list as far as you demand, modulo what f does
12:52:28 <kmc> hnsz, i don't know what you mean / what you're asking
12:52:52 <peteriserins> conal: I am making some progress, but still am quite far from being able to picture a working implementation
12:53:45 <kmc> hnsz, there's no way to force evaluation in an absolute sense.  it's all about "evaluating X causes evaluating Y"
12:53:48 <peteriserins> conal: I am reading the papers in a top-down fashion, so I was wondering if there are any implied prerequisites you would recommend?
12:53:55 <hnsz> kmc: My worry was (probably unfunded) that it would compose a sequence of expressions and only evaluate those when the end of the list was reached. But this is clearly neccesary
12:54:07 <hnsz> kmc:_not_
12:54:26 <kmc> "let x = e in ()" will never evaluate the expression 'e' no matter what you put there
12:54:32 <hnsz> not necessary *cough*
12:54:52 <kmc> hnsz, if you defined map in terms of foldl, it would work that way
12:55:35 <kmc> reverse = foldl (flip (:)) []
12:55:43 <ronwalf> monochrom: Found the problem (-O)
12:55:54 <peteriserins> conal: for example, the push-pull paper led to 'den. design with tcms' and that to a paper on 'generalized tries' which seems to require understanding of polymorphic types
12:56:01 <ronwalf> If I remove optimizations, it compiles just fine
12:56:21 <hnsz> kmc: I'm not completely through the book yet. I'll ask questions later. THanks for now :)
12:56:29 <kmc> cool :)
12:56:48 <ronwalf> uhg, I have no idea how to reduce this to a minimal example.  I have a similar program compiling against similar libs which goes through just fine
12:57:05 <Cale> ronwalf: optimisations cause something not to compile?
12:57:14 <peteriserins> conal: are there any other papers possibly not listed that would be integral to understanding FRP?
12:57:21 <ronwalf> Cale: Optimizations causing GHC to not finish compiling
12:57:28 <Cale> ronwalf: Are you seeing a panic?
12:57:35 <ronwalf> not terminating
12:57:47 <Cale> oh, wow :)
12:57:54 <conal> peteriserins: what kind of understanding are you looking for?
12:57:57 <Cale> Maybe the inliner has managed to get into a loop?
12:58:01 <thoughtpolice_> i haven't heard of a GHC loop in a while :)
12:58:04 <Cale> What kind of program are you compiling?
12:58:24 <ronwalf> Cale: A brutal abuse of type-level programming
12:58:40 <peteriserins> conal: ideally, I would like to be able to write a working implementation
12:58:43 <Cale> oh, and you're using UndecidableInstances?
12:58:43 <conal> peteriserins: my internet connection flaked out a while back. reading the logs.
12:58:55 <hnsz> kmc: It kinda came up when I was toying with recursive datastructures and was making a function to traverse a binary tree. My instinct was to make a list add a node's value and pass the list on to the left and right traverse but then found it was much more natural to not have the list at all.
12:59:09 <ronwalf> Cale: Actually, no
12:59:14 <thoughtpolice_> conal: UndecidableInstances should never cause GHC to loop endlessly I don't think, it has a depth limit and can't be turned off
12:59:17 <thoughtpolice_> er
12:59:21 <thoughtpolice_> meant to send that to Cale
12:59:25 <ronwalf> Cabal: almost everything else, though
12:59:26 <Cale> ah, okay
12:59:27 <ronwalf> er
12:59:27 <hnsz> kmc: I don;t know if you know what I mean but.
12:59:29 * thoughtpolice_ needs to stop relying on autocomplete so much
12:59:30 <ronwalf> same
12:59:33 <peteriserins> conal: one thing that has been confusing me is that your definition of a Behavior does not consume an event stream
12:59:42 <conal> peteriserins: "working" as in agreeing with a precise specification? or some other notion?
13:00:12 <kmc> the GHC inliner infinite loop bug documented in the manual still holds
13:00:13 <peteriserins> conal: well something that I could write down in a programming language
13:00:27 <thoughtpolice_> ronwalf: are you sure it's looping endlessly? in the past ISTR libraries/code that would take nearly 20 minutes to typecheck
13:00:39 <thoughtpolice_> (this was a serious abuse of type-level programming too)
13:00:43 <thoughtpolice_> kmc: what bug is that?
13:01:01 <ronwalf> thoughtpolice_: That's the problem with termination, isn't it?
13:01:08 <ronwalf> I could tell you next year :)
13:01:12 <peteriserins> conal: so far the implementation that I could gather was from P.Hudak's book on GUI programming
13:01:19 <ronwalf> thoughtpolice_: Similar programs are taking much less time
13:01:26 <thoughtpolice_> ronwalf: ah ok then
13:01:37 <ronwalf> I've given it a half-hour or so
13:02:08 <peteriserins> conal: but I'm sure that modern FRP implementations go beyond having a loop where all global events are captured and then fed to all Behaviors
13:02:17 <conal> peteriserins: looks like some of my previous remarks got lost. so you'll have them, here they are again, including some that did get through.
13:02:17 <kmc> thoughtpolice_, http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs.html#bugs-ghc
13:02:24 <conal> peteriserins: oh. i think i get you. in that case, i would look for a better abstraction that suffices but doesn't leak. ie one that doesn't expose the operational nondetermism. would probably require some creativity. the payoff is precise & tractable semantics, which then serves as the foundation for informal & formal reasoning and thus correctness & optimization. pure FP is full of this sort of denotational determinism in spite of opera
13:02:26 <conal> nondetermism. and i predict this distinction will grow quite a lot as parallelism becomes ubiquitous. which i think was the track warren burton was on in the 80s.
13:02:50 <conal> okay. now catching up with your remarks, some of which i missed.
13:02:56 <conal> peteriserins: ^^
13:03:05 <ronwalf> kmc: That doesn't look like anything I'm doing
13:03:11 <thoughtpolice_> kmc: heh
13:03:32 <peteriserins> conal: ok, I did get all your remarks now
13:03:57 <edwardk> preflex: xseen dylukes
13:03:58 <preflex>  dylukes was last seen on freenode/#haskell-blah 19 hours, 11 minutes and 25 seconds ago, saying: edwardk: alrighty
13:04:02 <peteriserins> I am reading the papers in a top-down fashion, so I was wondering if there are any implied prerequisites you would recommend?
13:04:18 <conal> peteriserins: about background reading & thinking, it really depends how much you care about semantics & correctness (w.r.t that semantics).
13:04:32 <peteriserins> conal: not a lot at this point
13:05:14 <peteriserins> conal: I would have to learn category theory and denotational semantics I suppose before I can tackle that
13:05:17 * ronwalf needs a tool to bisect his code into a minimal example
13:05:36 <conal> peteriserins: ah. and i don't care much about having a how (implementation) without a what (semantics/specification). so i might not be of much help to you.
13:05:39 <peteriserins> conal: and I have to wait two years here (Cambridge) before I can take category theory
13:06:25 <conal> peteriserins: you don't need cat theory, and the part of denotational semantics you'd need is very simple. probably something you already know without realizing.
13:06:44 <ronwalf> Using -v gives me a bit more info
13:07:04 <ronwalf> *** Simplifier SimplMode {Phase = 0 [main], ...
13:07:14 <ronwalf> It stops though, no infinite printing
13:07:24 <peteriserins> conal: well in the 'type class morphisms' paper, I was getting lost in some of the substitutions for monoid instances in the beginning
13:08:11 <conal> peteriserins: ah, too bad. it might assume more haskell knowledge than you have at this point. i bet folks on this channel could help you clear it up.
13:08:35 <conal> peteriserins: including me if i'm here, but probably many other haskellers as well.
13:09:32 <peteriserins> conal: I can actually peg it down to a sentence: 'The RHS resemble an instance in the Monoid library...The instance lets us simplify the TMap semantic monoid instance'
13:09:36 <ronwalf> Interesting... I get much fewer "Simplifier" messages in my comparison program
13:10:28 <peteriserins> conal: I couldn't see how you can get rid of the \k ->, it would seem to me that once you choose a meaning, it is rigid
13:10:33 <thoughtpolice_> ronwalf: you can make GHC absurdly verbose to maybe pinpoint more exactly in the compilation pipeline where it's looping
13:10:54 <b0fh_ua> Hello, when solving the task of filling an array of integers (IO array) I observing very bad performance comparing to Java for example. Are there any tricks tospeed this up? The code is listed at: http://pastebin.com/rnKFsFxq
13:10:56 <mauke> The paste rnKFsFxq has been copied to http://hpaste.org/50834
13:10:59 <thoughtpolice_> (just say '-v' about 3 times)
13:11:00 <conal> peteriserins: i'm looking up the paper ...
13:11:15 <ronwalf> thoughtpolice_: Yeah, not helping
13:11:41 <conal> peteriserins: right. the meaning doesn't change. only the formulation of that meaning.
13:12:50 <conal> peteriserins: i "refactored" the definition of the semantics into an equivalent form, by un-inlining the Monoid instance for a->b
13:13:17 <peteriserins> conal: are you in effect redefining the meaning for constant and unionWith as well?
13:13:58 <peteriserins> conal: or are you perhaps using a meaning for the meaning, as if applying a homomorphism?
13:14:02 <conal> peteriserins: anywhere in a haskell program that you see "\ a -> mempty", you can write "mempty" instead. thanks to the Monad instance for functions. similarly for mappend.
13:14:32 <peteriserins> conal: oh and type inference will handle it?
13:14:50 <conal> peteriserins: i don't think i'm changing *any* meanings in this example. i'm only playing with how these meanings are expressed.
13:14:54 <peteriserins> conal: I see...that's refreshing
13:15:06 <conal> peteriserins: doing a bit of substitution and equational reasoning.
13:15:15 <peteriserins> conal: so instead of learning category theory, I should just study type classes in haskell better
13:15:20 <conal> peteriserins: which is what denotative programming is good for.
13:15:25 <ronwalf> thoughtpolice_: aha - -v9 gives me tons of info
13:16:12 <conal> peteriserins: yeah. and play with equational reasoning. which you can do if you stay away from IO (which is technically "functional", but not denotative).
13:16:14 <thoughtpolice_> ronwalf: i didn't even know it went up to 9! you should definitely try over 9000 :)
13:16:52 <DrTeggy> Denotative or denotational?
13:17:00 <ronwalf> thoughtpolice_: Well, it doesn't complain about 9, anyway.
13:17:23 <ronwalf> how about detonating!
13:17:35 <peteriserins> conal: great, well, those were all my questions :) thanks very much for your insightful answers
13:17:44 <peteriserins> conal: have a good day!
13:17:53 <conal> DrTeggy: "denotative programming" is Peter Landin's recommended replacement for the fuzzy notion of "functional"
13:18:01 <conal> peteriserins: you're welcome! good luck.
13:18:33 <DrTeggy> conal, thanks for the clarification.
13:19:27 <conal> DrTeggy: i've been encouraging our community to follow Landin's advice to abandon "functional" in favor of "denotative", as the latter is a clear/precise notion and is the heart of tractible precise reasoning.
13:19:43 <conal> DrTeggy: see http://conal.net/blog/posts/is-haskell-a-purely-functional-language/#comment-35882 for some pointers .
13:20:04 <ronwalf> 33MB of output, and I'm still not to the infinite loop
13:20:08 <DrTeggy> I'll go have a look. Thanks.
13:20:51 <conal> BTW, much of haskell comes directly or indirectly from that seminal Landin paper .
13:21:40 <conal> and the clarity of this functional/denotative distinction has perhaps been mostly lost, especially since the invention of "imperative functional programming" ("monadic IO").
13:22:33 <DrTeggy> I remember the title of your blog post but obviously I havnr't
13:22:35 <tgeeky>  ^^ -- but this is being slowly rediscovered with conal's work, with applicative style
13:22:47 <DrTeggy> *haven't read it back then.
13:23:39 * DrTeggy reads...
13:24:17 <ronwalf> Booo.  36MB of debug, and it's not clear where the loop is
13:24:32 <ronwalf> (no more output coming)
13:25:33 * ronwalf should stop caring and do his work
13:27:03 <hnsz> Does anyone know, is there a sort of |more function in irssi?
13:27:44 <tgeeky> there are logs, which can be pushed through pagers (like more)
13:28:53 <koala_man> hnsz: so that the screen doesn't scroll until you've read it?
13:29:10 <hnsz> yes
13:29:51 <hnsz> koala_man: For instance when I do /set I would like something like /set |more
13:30:23 <koala_man> so not for channels in general?
13:30:25 <DrTeggy> I read Landin's Next 700 PLs paper, but I must have missed his proposal for "denotative." His condition (c) sounds like "compositional" to me.
13:30:47 <koala_man> hnsz: dunno, I just page up and down again
13:30:54 <boegel> hiya y'all
13:30:56 <hnsz> koala_man: not for normal chat
13:31:13 <boegel> is they guy handling Hackage user account happen to be in here?
13:31:14 <tgeeky> DrTeggy: denotative means (in my opinion), knowing what happens when you compose functions
13:31:24 <tgeeky> boegel: I don't think he is
13:31:34 <boegel> I'm dying to submit my GA package to Hackage, but can't seem to remember my passwd :(
13:31:59 <RenJuan> it doesn't have a lost pw func?
13:32:17 <koala_man> it's 123456
13:32:20 <DrTeggy> tgeeky: ... when you compose bits to form a larger construct ... Yes
13:32:32 <boegel> RenJuan: it says to mail the guy
13:32:40 <boegel> RenJuan: which I will, in the end
13:32:59 <boegel> RenJuan: Hackage accounts are handled very primitively, it seems :)
13:33:01 <tgeeky> DrTeggy: I don't think the "size" of it matters, just that 1) the functions are designed to be naturally composable, and 2) that it's clear what happens when you compose them
13:33:09 <RenJuan> boegel, apparently
13:33:29 <tgeeky> you can use my username and password to submit :)
13:33:30 <RenJuan> I thought with the plethora of web app servers it would be based on one of them
13:33:34 <boegel> I seem to have chosen a very l33t passwd, since I can't seem to remember it
13:33:36 <boegel> tgeeky: ;)
13:34:11 <RenJuan> but come to think of it that might be the issue, if it was one of the older ones like happs of 3-4 years ago or something
13:34:20 <hnsz> koala_man: Heh, thanks. Didn't know :0
13:34:23 <boegel> I guess uploading will have to wait until I can get a password reset :(
13:34:29 <parcs> how old is happs?
13:34:33 <tgeeky> geometric algebra?
13:34:36 <tgeeky> is the new package?
13:34:57 <tgeeky> it'll be exciting to see that
13:35:01 <DrTeggy> tgeeky: I am not sure whether denotative was meant to only apply in the domain of functions (and their composition).
13:35:01 <RenJuan> parcs at least 5 years or so, been happstack for a couple I think
13:35:20 <roconnor> did someone say there is a geometric algebra package for haskell?
13:35:28 <tgeeky> roconnor: lol!
13:35:34 * roconnor wants
13:35:39 <tgeeky> roconnor: someone /guessed/ that there might, in the future, be ...
13:35:42 * tgeeky too
13:35:52 <RenJuan> i think GA meant genetic
13:36:01 <roconnor> I wrote a toy one
13:36:09 <tgeeky> DrTeggy: http://www.cs.uiowa.edu/~slonnegr/plf/
13:36:22 <tgeeky> DrTeggy: lecture 9
13:36:26 * copumpkin pokes boegel 
13:37:08 * boegel pokes copumpkin 
13:37:18 <copumpkin> boegel: #haskell-blah :)
13:37:56 <tgeeky> yeah we don't want none of that dirty poking going on in here
13:41:13 <DrTeggy> tgeeky: That lecture talks about "denotational" semantics...
13:41:31 <tgeeky> DrTeggy: yes, that's what conal is talking about
13:41:38 <DrTeggy> No
13:41:50 <tgeeky> oh? what is he talking about?
13:41:58 <DrTeggy> He's talking about "denotative" semantics.
13:42:35 <tgeeky> he can clarify, but I am pretty sure it's the same thing
13:42:59 <DrTeggy> But thanks for the pointer, this is material that looks useful for an upcoming course here in Tübingen.
13:43:18 <KirinDave> Hmmm
13:43:24 <DrTeggy> tgeeky: No, that's the whole point of the discussion.
13:43:29 <KirinDave> I'm trying to help a rubyist understand monads.
13:43:56 <KirinDave> I'm wondering, is pointing out how rubyists and pythonistas use && and || chaining a basic (and messy) version of the Maybe monad?
13:44:06 <c_wraith> monads are like dragons with antelope heads
13:44:25 <tgeeky> DrTeggy: I've discussed this very point with him myself, he's referring to using  "denotative" or "denotational semantics" instead of "pure functional" programming
13:44:27 <KirinDave> c_wraith: No no. Monads are like dragons with the heads of antelopes scattered about.
13:44:40 <Cillo> hi guys
13:45:02 <DrTeggy> Landin should be here to set us all straight.
13:45:02 <KirinDave> But I think that result = a && b && c is basically a >> b >> c for the maybe monad.
13:46:30 <Cillo> i'm a newb, may i ask  how can i implement a function that uses a function as input? what do i have to write on ghci?
13:46:53 <kmc> let twice f x = f (f x)
13:47:08 <KirinDave> Cillo: Key takeaway from kmc's example
13:47:19 <KirinDave> Cillo: it's nothing special. :)
13:47:34 <kmc> yep, functions are values like any other
13:47:35 <copumpkin> kmc: I love playing with that function
13:47:41 <copumpkin> @let thrice f = f . f . f
13:47:42 <lambdabot>  Defined.
13:47:47 <copumpkin> > thrice thrice (+1) 0
13:47:48 <lambdabot>   27
13:47:51 <copumpkin> > thrice thrice thrice (+1) 0
13:47:53 <lambdabot>   *Exception: stack overflow
13:48:03 <Tomsik> wut
13:48:03 <copumpkin> it gets large quite quickly :)
13:48:10 <Tomsik> That stack be trollin
13:48:22 <kmc> haha
13:48:25 <kmc> exponentials, man
13:48:26 <Cillo> and f is the "expression" to indicate a generic function?
13:48:32 <KirinDave> Cillo: It's weird to think about, but functions with multiple arguments in haskell return intermediate functions.
13:48:42 <kmc> Cillo, it's just a variable
13:48:47 <tgeeky> @let twice = f . f
13:48:48 <lambdabot>  Defined.
13:48:53 <kmc> there's nothing special about naming it f or anything
13:48:54 <tgeeky> > twice (*2) 1
13:48:55 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
13:48:55 <lambdabot>    arising from a use of `...
13:49:09 <tgeeky> oops
13:49:10 <tkahn6> Hi all. Is there a way to get the type system to enforce value ranges? For instance, I would like to have a something like F :: PositiveIntLessThan16 -> PositiveIntLessThan16 -> Word16 -> Word16
13:49:17 <Tomsik> > let twice = join (.) in twice
13:49:18 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a) -> a -> a)
13:49:18 <lambdabot>    arising fro...
13:49:18 <tkahn6> I apologize if this is a stupid question lol
13:49:23 <Tomsik> :t let twice = join (.) in twice
13:49:24 <lambdabot> forall a. (a -> a) -> a -> a
13:49:28 <kmc> > let twice my_little_function_friendship_is_magic argument = my_little_function_friendship_is_magic (my_little_function_friendship_is_magic x) in twice (*2) 1
13:49:29 <lambdabot>   x * 2 * 2
13:49:46 <tgeeky> i hope you typed out every letter
13:50:29 <copumpkin> anyone know what thrice thrice thrice (+1) 0 should be? :)
13:50:45 <copumpkin> there are more efficient ways to compute it
13:50:47 <tgeeky> 27^27^27?
13:51:03 <Tomsik> It's ackermann-y
13:51:40 <Tomsik> like that ↑
13:52:03 <kmc> Cillo, ask questions here; don't PM me
13:52:44 <boegel> mail sent wrt Hackage passwd reset, but no reply yet, so uploading my package will have to wait :(
13:53:28 <kmc> Cillo, it's fine to have an extended discussion in the public channel
13:53:34 <copumpkin> tgeeky: needs to be figured out!
13:53:46 <kmc> it's usually considered rude to private-message specific people with questions anyone can answer
13:54:04 <Cillo> ok, good teaching :)
13:54:05 <kmc> a lot of the nearly 800 people in this channel lurk here because they learn a lot from seeing other people's questions and answers
13:54:14 <tgeeky> boegel: genetic algorithims or geometric algebra?
13:54:26 <copumpkin> tgeeky: ?
13:54:32 <boegel> tgeeky: former
13:54:35 --- mode: ChanServ set +q *!*@99-184-20-21.lightspeed.rswlga.sbcglobal.net
13:54:52 --- mode: ChanServ set +o copumpkin
13:56:11 <tkahn6> would it be rude if I asked my question again? no one seemed to acknowledge it
13:56:25 <roconnor> tkahn6: go for it
13:56:27 --- mode: ChanServ set -q *!*@99-184-20-21.lightspeed.rswlga.sbcglobal.net
13:56:37 <tkahn6> k thanks
13:56:40 <tkahn6> Is there a way to get the type system to enforce value ranges? For instance, I would like to have a something like F :: PositiveIntLessThan16 -> PositiveIntLessThan16 -> Word16 -> Word16
13:56:42 <Eduard_Munteanu> Just don't repost it very often.
13:56:48 <tgeeky> *breathe* . that was weird
13:57:04 <copumpkin> my connection went insane
13:57:08 --- mode: copumpkin set -o copumpkin
13:57:08 <roconnor> tkahn6: one way is to make an enumeration with 15 values
13:57:18 <copumpkin> and showed tgeeky sending dozens of repeated messages
13:57:21 <copumpkin> not sure wtf was up
13:57:22 <roconnor> tkahn6: the other way is to use the module system to enfrace such a constraint
13:57:37 <roconnor> tkahn6: you probably want the latter
13:57:41 <copumpkin> tgeeky: http://snapplr.com/tbzd
13:57:55 <Eduard_Munteanu> No true type-based approach, for that you'll have to upgrade to Agda ;)
13:58:05 <tkahn6> heh
13:58:10 <tkahn6> roconnor: can you point me to an example or documentation on how to do that?
13:58:19 <tgeeky> that's pretty strange.
13:58:40 <roconnor> tkahn6: http://www.haskell.org/haskellwiki/Smart_constructors
13:58:59 <tkahn6> oh wow what a cool feature
13:58:59 <tkahn6> thanks
13:59:55 <roconnor> tkahn6: you can also have smart constructor return Maybe Resistor instead of using error.
14:00:10 * roconnor feels he ought to edit the wikipage to state this, but is to lazy
14:00:41 <tgeeky> copumpkin: no harm done. I figured I might have spammed anyway, but I didn't see it so I was confused. I occasionally paste-spam :(
14:00:52 <tkahn6> roconnor: thanks! in my particular case it shouldn't compile if the value is out of range… that would mean i messed up somewhere in my logic
14:01:20 <copumpkin> tgeeky: yeah, all my channels started repeating stuff like that
14:01:23 <copumpkin> no clue wtf happened
14:01:29 <copumpkin> sorry about that :)
14:01:37 <tgeeky> hehe sounds like a client bug
14:01:44 <tgeeky> or your ISP just turned on traffic shaping
14:01:44 <tgeeky> lol
14:01:56 <copumpkin> :)
14:02:15 <rwbarton> glitch in the matrix
14:02:30 <roconnor> tkahn6: it is tricky; you can use that crazy type-level arithmetic in that article in theory.
14:02:47 <KirinDave> Btw Cillo
14:02:58 <KirinDave> In here you can use the :t to ask about the type of a function if you'e curious AND lazy
14:03:00 <KirinDave> e.g.
14:03:02 <KirinDave> :t foldl
14:03:03 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:03:32 <tkahn6> roconnor: thanks for your help. I'll see how it goes :)
14:04:53 <Cillo> ok, thanks kirindave
14:06:50 <boegel> oh, password reset is in! :)
14:07:11 <boegel> http://hackage.haskell.org/package/GA \o/
14:08:50 * hackagebot GA 0.1 - Genetic algorithm library  http://hackage.haskell.org/package/GA-0.1 (KennethHoste)
14:09:52 * boegel huggs hackagebot 
14:09:57 <boegel> *hugs
14:11:57 <byorgey> boegel: nice =)
14:13:47 * boegel bows
14:17:35 <DukeDave> Ooh, did I see a GA library go in
14:17:41 * DukeDave likes this
14:31:49 <boegel> DukeDave: suggestions for improvements welcome :)
14:32:34 * boegel leaves for bed
14:45:39 <lcfrs> if I have a data Foo = Foo param1::String param2::String, is there a shortcut to do f :: [String] -> Foo where f (a1:a2:_) = Foo a1 a2?
14:46:30 <mustelo> lcfrs, what do you want to happen if the list is too short?
14:48:05 <lcfrs> error?
14:48:17 <byorgey> there is no shortcut, although you could make a higher-order function  app2 :: (a -> a -> b) -> [a] -> b
14:48:34 <byorgey> app2 f (a1:a2:_) = f a1 a2
14:48:39 <byorgey> then you could just do  app2 Foo
14:48:56 <lcfrs> ah i see
14:49:07 <byorgey> and you could reuse it if you have other similar data types
14:49:07 <lcfrs> thanks
14:49:15 <elliott> lcfrs: out of curiosity, why do you want this?
14:51:06 <lcfrs> i'm reading a csv and making a list from it
14:51:21 <lcfrs> is there a better way?
14:51:22 <elliott> ah
14:51:33 <elliott> it seems reasonable enough, in that case
14:52:00 <lcfrs> it does seem a little dirty, so i'm open to ideas
14:52:28 <elliott> well, at least the dirt is localised to your loading of the foreign format
15:05:01 <byorgey> lcfrs: by the way, parsing CSV files correctly is actually rather tricky (due to quoting), depending on what you are doing you might be interested in using an existing csv-parsing library from Hackage
15:05:10 <byorgey> the simplest appears to be http://hackage.haskell.org/package/csv
15:12:52 <sero> Hello, I am fairly new to haskell, however I do have a couple bots running on freenode in a channel I am in, one being lambdabot, the other being number-six (which I came across on github). I was wondering, if there is a haskell bot out there, plugin, or some information at the least, for a weather plugin at all? I have searched google for such a thing, but haven't really found much info/luck. Any help would be appreciated.
15:14:54 <Eduard_Munteanu> @google alabama temperature today
15:14:56 <lambdabot> http://www.al.com/weather/
15:14:56 <lambdabot> Title: Birmingham, AL Weather Forecast, Radar & News
15:15:08 <Eduard_Munteanu> @more
15:15:17 <Eduard_Munteanu> Bah.
15:15:31 <sero> I had tried that myself, hoping it would just give weather output vs a link, but no luck. :/
15:16:21 <copumpkin> dmwit: you related to bruce?
15:18:56 <Dashkal> Can someone give an example of a simple applicative that's not also a monad?
15:19:38 <kmc> ZipList
15:20:04 <copumpkin> ZipList-like behavior could be a monad, though
15:20:09 <copumpkin> just not on []
15:20:14 <Peaker> ZipList is also a monad for same-length lists, isn't it?
15:20:18 <Dashkal> hmm, not quite what I'm after.  I was doing one of Tony's excercises.  Defining ap for various types.  And I kepe catchign myself using join and a couple fmaps
15:20:19 <copumpkin> yeah
15:20:23 <ski> Peaker : yes
15:20:32 <Dashkal> kept catching*
15:20:43 <zygoloid> "Default a => (,) a" is applicative but not a monad
15:20:43 <Peaker> so differing length ZipLists are valid Applicatives?
15:20:57 <copumpkin> Peaker: yeah
15:21:42 <Peaker> zygoloid: how do you <*> that?
15:21:48 <ski> > getZipList (ZipList [(* 2),(^ 2)] <*> ZipList [3,4,5])
15:21:49 <lambdabot>   [6,16]
15:21:57 <shachaf> ZipList is pretty much the only example anybody ever gives.
15:22:13 <Peaker> shachaf: there's the optimized Parser example
15:22:13 <zygoloid> Peaker: (_, f) <*> (a, x) = (a, f x) works, i think
15:22:22 <Peaker> zygoloid: I don't think that works
15:22:23 <ski> there is probably some kind of free applicative
15:22:33 <copumpkin> Monoid a => (a, _)
15:22:56 <copumpkin> pure x = (mempty, x)
15:23:16 <copumpkin> (a, f) <*> (b, x) = (a `mappend` b, f x)
15:23:28 <copumpkin> omg it's a JaffaCake1
15:23:43 <ski>   join (a,(b,x)) = (a `mappend` b,x)
15:23:53 <zygoloid> Peaker: which law do you think it doesn't satisfy?
15:24:07 <zygoloid> oh, interchange, right
15:24:25 <Peaker> zygoloid: I guessed there's probably some x that allows (<*>x) == id if the Applicative laws are sensible :)
15:25:16 * ski . o O ( `(pure id <*>)  =  (id `fmap`)  =  id' )
15:25:35 <ski> @type \x -> (<*> x) `asTypeOf` id
15:25:35 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
15:25:36 <lambdabot>       Expected type: f b
15:25:36 <lambdabot>       Inferred type: f (a -> b)
15:28:52 <Peaker> well, then maybe something like:  \x -> f x <*> y   (choose f and y to get id there)
15:31:03 <ronwalf> monochrom: Woo, small test case and bug report: http://hackage.haskell.org/trac/ghc/ticket/5448
15:31:29 <Peaker> \x -> ?f x <*> ?y
15:45:31 <dylukes> Peaker: ...what?
15:45:33 <dylukes> :<
15:46:14 <shachaf> Exactly what it says.
15:47:30 <conal> tgeeky: hey.
15:50:54 <Peaker> @type \x -> ?f x <*> ?y
15:50:55 <lambdabot> forall t (f :: * -> *) a b. (?f::t -> f (a -> b), ?y::f a, Applicative f) => t -> f b
15:51:09 <Peaker> I think you can find a (t, y) that make that expression ==id
15:51:21 <conal> @tell tgeeky i was off IRC for a while. just returned and saw the chat between you & DrTeggy about "denotative" vs "denotational semantics" vs "compositional". i see these notions as all different (but related). next time you & DrTeggy & i are all on at the same time, i'd be happy to clarify, if you're interested.
15:51:21 <lambdabot> Consider it noted.
15:51:27 <Peaker> (where f /= pure)
15:51:34 <Peaker> and that would make dumping the left-side value in <*> wrong
15:52:06 <hpc> Peaker: Just (1:) <*> Just [1..]?
15:52:48 <Peaker> hpc: for zygoloid's example of (Default a => (,) a)
15:52:51 <hpc> or really, any f = pure . g, y = fix g
15:52:56 <hpc> er, y = pure . fix g
15:53:00 <hpc> or whatever
15:57:12 <BMeph> conal: Would you log that convo somewhere, so others may also gain insight? :)
15:57:38 <conal> BMeph: it'll be on http://tunes.org/~nef/logs/haskell/ .
15:57:52 <conal> BMeph: sometimes i tweet after such conversations.
15:58:05 <conal> BMeph: and thanks for the interest.
15:59:15 <BMeph> conal: Excellent. Sometimes such things are taken to -overflow or -in-depth, so I asked for a record. And, thanks for being generous with your communacative skills. :)
16:00:01 <conal> BMeph: oh, yeah. thanks for that reminder about the unlogged channels. and for the encouragement. :)
16:01:45 <dmwit> copumpkin: I have an Uncle Bruce, but I very doubt he's the one you're talking about.
16:01:52 <dmwit> Unless you're talking about a farmer in Ohio. =P
16:03:15 <ski> conal : would programming in a pure logic/relational programming language (such as Mercury) be included under "denotative programming" ?
16:03:20 <byorgey> dmwit: didn't you know? he's famous
16:03:48 <dmwit> Did he finally grow the Biggest Corn Ever?
16:04:26 <conal> ski: i don't know, offhand. but i imagine it'd be fairly straightforward--and maybe illuminating--to find out by checking against Peter Landin's definition.
16:04:36 <acowley> Are there any good solutions for dealing with the mkTyCon deprecation in GHC 7.2? Specifically, I can use mkTyCon3, but I don't want to lose backwards compatibility, so I seem to need an #ifdef helper somewhere.
16:05:39 <byorgey> dmwit: Rutabaga, actually
16:05:44 <copumpkin> dmwit: oh, I was talking about bruce wagner of bitcoin fame
16:06:00 <ski> @type mkTyCon
16:06:00 <lambdabot> String -> TyCon
16:06:04 <ski> @hoogle mkTyCon3
16:06:05 <lambdabot> No results found
16:07:10 <acowley> Rutabaga is delicious, but I'm not sure if size is critical
16:07:22 <dmwit> copumpkin: Oh, I haven't been following the bitcoin news.
16:07:40 <copumpkin> ah
16:08:07 <byorgey> acowley: it is when you are entering your rutabaga in the World's Biggest Rutabaga Championships
16:08:24 <acowley> so that's why I keep losing
16:14:13 * ski . o O ( mashed rutabagas&potatoes is yummy )
16:18:13 <ion> Have you considered trying to match wits with a rutabaga?
16:18:50 <ddarius> My Guitar directory becomes increasingly misnamed.
16:19:17 <edwardk> ddarius: you need to stop picking up random stringed instruments then =P
16:20:19 <ddarius> edwardk: This is drums!
16:20:28 <edwardk> hah
16:38:22 <dmwit> I like to emulate transparency in my terminal my holding screen's "next window" key.
16:46:17 <shlevy> Hi. I want to write a program that reads xcode .pbxproj files and generates corresponding instances of appropriate types for later use (one such use might be to generate Makefiles). Is Parsec the library I want? If so, where should I look to get started?
16:46:53 <dmwit> Are .pbxproj files binary or text?
16:47:11 <shlevy> dmwit: Text, but not very human-friendly
16:47:25 <shlevy> dmwit: Predictable though, all machine generated
16:47:29 <dmwit> Parsec is a pretty good parsing library, yes.
16:47:45 <dmwit> You should look at the .pbxproj language spec to get started.
16:48:09 <shlevy> dmwit: I already know the format (though it's not formaly specified anywhere), I meant getting started with parsec :)
16:48:39 <dmwit> The main Parsec documentation page is a bit outdated, but is a good overview of what you can expect from the library.
16:48:52 <dmwit> ?google haskell parsec html
16:48:53 <lambdabot> http://book.realworldhaskell.org/read/using-parsec.html
16:48:54 <lambdabot> Title: Chapter 16. Using Parsec
16:49:06 <dmwit> ...not exactly what I had in mind, but probably also a good first resource.
16:49:25 <shlevy> dmwit: Thanks
16:50:04 * jmcarthur wonders when we will be recommending trifecta for beginners
16:50:21 <Peaker> Parsec really lacks some basic functions (e.g: simply parse a decimal integer)
16:50:23 <dmwit> jmcarthur: Oh, I haven't been keeping up with advances in parser technology.
16:50:27 <edwardk> jmcarthur: when i simplify it i suppose.
16:50:37 <edwardk> peaker: thats in trifecta at least
16:50:38 <dmwit> What's the best and newest in parsing these days?
16:50:51 <jmcarthur> i haven't tried trifecta yet. ask edwardk :)
16:50:53 <edwardk> dmwit: trifecta is the new hotness
16:50:55 <Peaker> Parsec has a fragmented API for backwards compatibility, and no deprecation warnings
16:51:25 <dmwit> I guess I'm aware of the names of Parsec, attoparsec, and binary, but I don't really know their tradeoffs.
16:51:43 <Peaker> binary is just the type-class, isn't it? Which is a bad idea in and of itself
16:51:53 <edwardk> may not be idea for shlevy's purposes though, trifecta is almost 100% focused on parsing human readable text.
16:51:56 <Peaker> (There's a "right way" to represent an Int?)
16:52:00 <edwardk> er be ideal
16:52:30 <franny> Are Alex and Happy widely used? I know they come with haskell-platform.
16:52:32 <Peaker> If you think about it, Parsec's generalized parser type has a little ListLike functionality embedded within it
16:52:38 <dmwit> Oh, yes, plus alex/happy.
16:52:41 <Peaker> (the "Stream" and "Char" types)
16:52:43 <dmwit> How could I forget those?
16:52:53 <tvynr> franny: We're using Happy for our language project.
16:52:58 <edwardk> parsec is pretty standard, and offers a good set of tools for things like telling you where a parser went wrong. attoparsec is parsec without good error reporting but with a jolt of speed, it strips things way down to get there
16:53:31 <ddarius> Why do people think the binary package is just a type class?
16:53:35 <edwardk> alex/happy yield very classic LALR lexer/parser combos which are fine if you never have to extend beyond what can be parsed with that formalism
16:53:42 <Peaker> ddarius: because of its name? :)
16:53:44 <jmcarthur> edwardk: just based on the author i can probably guess the answer to this, but is trifecta very efficient? ;)
16:53:55 * hackagebot haskell-bcrypt 0.2 - A bcrypt implementation for haskell  http://hackage.haskell.org/package/haskell-bcrypt-0.2 (BrettCarter)
16:53:58 <ddarius> Peaker: What about its name says "I just contain a type class?"
16:54:00 <edwardk> jmcarthur: its pretty good actually.
16:54:29 <edwardk> jmcarthur: pretty good being 'should be competitive with parsec 3.1' and sometimes blow its doors off.
16:54:40 <Peaker> ddarius: now I remember what it has.. Get is OK (except for using partiality to report errors, arrg!).  Put is monadic for no good reason. And the type-class is silly.
16:54:43 <jmcarthur> cool
16:54:52 <Peaker> so I guess I don't like the binary package very much
16:54:53 <edwardk> once i get the dyck language skeleton code in it will get some speedups that nobody else has
16:55:04 <copumpkin> Peaker: I'm making a better one
16:55:14 <copumpkin> still haven't decided on several design issues though
16:55:16 <ion> The dyck language skeleton?
16:55:24 <edwardk> but it isn't geared towards parsing massive gigabytes of computer generated text, instead it is targeted at source files and human readable text.
16:55:28 <Peaker> I want a total Get monad, a Put monoid, and a "Binary" record instead of a type-class, perhaps with some nice combinators to compose Binary records
16:55:31 <Peaker> copumpkin: cool
16:55:42 <dylukes> Peaker: record?
16:56:02 <elliott> record
16:56:09 <copumpkin> Peaker: though it's mostly geared to parsing for now, not generating
16:56:12 <edwardk> ion: i have a monoid for parsing bitonic sequences of closing and opening contexts. this monoid lets me match up )]]](((  with )))[[[ and get )]]][[[  for instance
16:56:15 * shlevy can't decide if the consensus is still Parsec
16:56:15 <elliott> Peaker: those things sound nice
16:56:22 <Peaker> dylukes: instead of: class Binary b where get :: Get b ; put :: b -> Put   ;  data Binary b = Binary { get :: Get b ; put :: b -> Put }
16:56:24 <jmcarthur> shlevy: parsec
16:56:33 <elliott> I'm not sure why binary is called binary, it seems to generalise to textual things too :)
16:56:38 <ion> edwardk: ok
16:56:42 <edwardk> ion: consider those spread through a grammar. it lets me pair up in parallel the parentheses in your source file (and layout contexts, #ifdefs, case .. of, etc.)
16:56:44 <Peaker> copumpkin, elliott: I guess I'd also add type-parametricity on the kind of string being built (lazy/strict bytestring)
16:56:49 <elliott> it would be neat to plug a similar package into a parser combinator library
16:56:55 <dylukes> Peaker: why is that any better?
16:56:55 <jmcarthur> shlevy: i wouldn't recommend anything but parsec for somebody new to haskell parser combinator libraries
16:56:57 <elliott> Peaker: why not just make it work on any monoid?
16:57:02 <elliott> or something
16:57:05 <dylukes> and I don't think you can have a data type and type class with the same name...
16:57:06 <elliott> I guess it'd need a separate typeclass
16:57:07 <shlevy> jmcarthur: Ok, thanks
16:57:18 <elliott> dylukes: because there can be multiple ways to (de)serialise a single type
16:57:23 <jmcarthur> well, unless there was some performance reason to use attoparsec i guess
16:57:28 <dylukes> jmcarthur: I've been playing with edwardk's trifecta.
16:57:30 <dylukes> It's really nice.
16:57:33 <edwardk> ion: then when you call the parens lexeme parser it can use the known ending paren and speculatively continue evaluation while it parses the nested scope in parallel
16:57:42 <Peaker> dylukes: Type-classes are not the correct way to put a bunch of functionality in the same place.. Type-classes are good for ad-hoc polymorphism and various type trickery
16:57:42 <ion> edwardk: Very nice.
16:57:51 <jmcarthur> i look forward to the next time i need to write a parser :)
16:57:55 <shlevy> jmcarthur: Nope, error reporting is more important than speed for my purpose
16:57:57 <Peaker> dylukes: The Binary class has its own idea of how I "should" [de]serialize an Int, for example
16:58:04 <Peaker> dylukes: But should it be little endian, or big endian?
16:58:14 <ddarius> Peaker: No it doesn't.
16:58:26 <Peaker> ddarius: no standard instance for Int?
16:58:32 <edwardk> ion: the goal is to keep that invisible to the user though, so they just say that they have a grammar with certain paired up opening and closing contexts that always match up, and then i do a monoidal pass to pair them up while loading the ropes
16:58:47 <DukeDave> Erm, is there a package called 'ghc'?, I just grabbed some code and their "compile" script has "-package ghc" as an option to ghc?
16:58:54 <Peaker> dylukes: A Binary record would allow me to define:  bigEndianInt, littleEndianInt, or perhaps generalization of that,  that builds Binary records
16:58:59 <elliott> DukeDave: yep, it's GHC
16:59:03 <dylukes> I see.
16:59:06 <ddarius> The Binary class is meant for "I just need my data in any format that can be read back in."  It is not meant for, "I want to write TCP frames."
16:59:30 <DukeDave> elliott: But, wha?
16:59:39 <elliott> DukeDave: what about it?
16:59:55 <DukeDave> In any case, I get: "cabal: There is no package named 'ghc'."
16:59:56 <edwardk> jmcarthur: the other stuff it does is automatic syntax highlighting (built-in hscolour), clang-style diagnostics, and its picking up a lot of other bits of functionality like typeahead support for a haskeline clone
17:00:06 <elliott> it's not on hackage
17:00:12 <elliott> it comes with GHC
17:00:13 <franny> DukeDave: what OS/distro?
17:00:22 <DukeDave> franny: Ubuntu
17:00:27 <Peaker> ddarius: Perhaps it would be nicer to use the Default class, and make instances for Get Int, etc?
17:00:31 <elliott> DukeDave: (I assume you're trying "cabal install ghc"?)
17:00:31 <ddarius> jmcarthur: Soon it will come with electric leads to gold plate your tea sets.
17:00:35 <DukeDave> How peculiar, I've never heard of such a thing..
17:00:35 <edwardk> jmcarthur: the goal is to be able to slot it in and get most of the tools (like ctags generation, c preprocessing) that you usually build separately for your language as a side-effect of building the parser
17:00:37 <Peaker> ddarius: or have a DefaultSerializer class for this
17:00:40 <DukeDave> elliott: Exactly
17:00:43 <elliott> DukeDave: Why?
17:00:51 <elliott> DukeDave: It is not on Hackage. You have GHC, so you have the "ghc" package.
17:00:55 <elliott> What is the problem?
17:01:06 <Peaker> ddarius: It makes more sense to define [de]serializers as first-class record values -- then attaching them to instances/types can be done separately
17:01:16 <Peaker> ddarius: best of both worlds
17:01:16 <ddarius> Peaker: Using a class at all essentially means that.  As you point out, there will never be one "right" way of serializing an Int.
17:01:21 <shachaf> preflex: seen bos
17:01:22 <preflex>  bos was last seen on #haskell 2 days, 4 hours, 10 minutes and 30 seconds ago, saying: yep
17:01:22 <franny> DukeDave: there's a separate package you have to install. Have you installed "haskell-platform"?
17:01:27 <jmcarthur> edwardk: awesome!
17:01:29 <DukeDave> elliott: I'm getting "cannot satisfy -package ghc"
17:01:35 <ddarius> Peaker: I agree with that completely, and that is completely orthogonal to Binary.
17:01:43 <elliott> DukeDave: huh. do you have GHC installed?
17:01:46 <elliott> I guess Ubuntu might break the packages somehow
17:01:47 <DukeDave> franny: Is that an apt, or hackage package?
17:01:51 <franny> DukeDave: apt.
17:01:55 <c_wraith> DukeDave: sounds like you have a broken ubuntu install.  typical for debian
17:01:56 <jmcarthur> edwardk: in what sense is the syntax highlighting automatic?
17:02:02 <Peaker> ddarius: not quite orthogonal, as Binary is a class that does default-serializer selection AND the serialization itself, the second part should be in a record
17:02:10 <franny> elliott: Ubuntu packages GHC and the "ghc" package separately. Lord knows why.
17:02:12 <DukeDave> elliott: jmcarthur: Aha, thanks
17:02:14 <c_wraith> DukeDave: it's not actually broken.  They just break something that should be one package into *many*
17:02:37 <edwardk> jmcarthur: all the token parsers wrap themselves appropriately with a highlight tag that helps build up an interval map of what recognized each bit of input. you can edit the map or add other annotations as you go
17:02:39 <Peaker> ddarius: Binary is not well designed in this regard, that's all I'm saying about the class -- I agree that such a class can be useful for the first functionality
17:02:52 <edwardk> jmcarthur: so when you're done all identifiers, numbers, operators, etc. are marked for you
17:02:59 <jmcarthur> ooh
17:02:59 <ion> dukedave: Try installing haskell-platform and deleting your ~/.ghc and ~/.cabal. That should be rather close to a clean state.
17:03:16 <dainanaki> I'm trying to use c2hs on OS X and it's choking on system header files. Has anyone got experience in working around crazy preprocessor stuff?
17:03:17 <shachaf> bos: What's the meaning of the word "worth" in Data.Configurator?
17:03:19 <elliott> franny: Sigh.
17:03:22 <ddarius> Peaker: The Binary class neither keeps you from using first-class records nor bars your first-class records from being instances.  I fail to see how it is not completely orthogonal.
17:03:23 <edwardk> and you can build a valid implementation of the parser class that just dumps those on the floor if you don't want the overhead
17:04:02 <edwardk> but if you don't then i use those when printing error messages. the errors show the line the error occurred on with the syntax highlighting embedded in the line
17:04:23 * DukeDave is getting the haskell-platform from the Ubuntu repos and hoping it doesn't trash ghc-pkg :|
17:04:30 <edwardk> and can do clang-style ^'s  ~~~~~'s and 'fixits' over ranges of the input if you choose
17:04:32 <Peaker> ddarius: my records can be made instances by assigning both get and put (rather than just selecting the record) -- I think it's just less elegant that the class has "get/put" rather than "serializer"
17:04:58 <DukeDave> Hmm: There are problems in package QuickCheck-2.1.0.3:  dependency "ghc-6.12.1-c10ea6c243e6388064686188b5cb58e6" doesn't exist
17:05:14 <Peaker> ddarius: Haskell is awesome enough to make this bad choice in Binary not pollute user code too much (indeed just make a record and repeatedly use the instance boilerplate to connect the two)
17:06:06 <franny> DukeDave: that's got to be a bug in Ubuntu's packaging. Maybe try removing everything ghc, then installing haskell-platform?
17:06:09 <DukeDave> ion: If I delete .ghc and .cabal, is there a risk I'll break things? Or can it all be regenerated?
17:06:14 <ddarius> Peaker: I don't agree with your first statement, nor, even if I agreed with it completely, would I find it a compelling argument that Binary is poorly designed.
17:06:14 <Peaker> Abuse of "do" syntax for simple Monoids shows that maybe List syntax is too heavyweight
17:06:53 <Peaker> ddarius: that's not the only problem -- partiality in Get and the unnecessary Monad in Put are problems too.. Also the specific-bytestring-type
17:06:57 <ion> dukedave: You’ll need to reinstall anything you’ve installed with cabal. But since your installation seems somewhat broken at the moment, that shouldn’t be a big issue.
17:07:25 <DukeDave> Hmm: $ ghc-pkg check
17:07:26 <DukeDave> There are problems in package QuickCheck-2.1.0.3:  dependency "ghc-6.12.1-c10ea6c243e6388064686188b5cb58e6" doesn't exist
17:07:29 <Peaker> So: 1) no separation of serializer-for-type selection from serialization operations 2) Get is partial  3) Put is a silly monad  4) ByteString type is hard-coded
17:07:43 <ddarius> Peaker: Yes, there are other arguments that are more compelling, but the earlier one is not one.  I also don't find Put being a monad that big of a deal either.
17:07:59 <edwardk> put being a monad is pretty damn convenient at times
17:08:02 <franny> DukeDave: oh, removing .cabal and .ghc should fix that.
17:08:04 <Peaker> ddarius: I find it indicative of a problem with Haskell more than binary
17:08:19 <Peaker> no reason for "do" to be lighter-weight than [x,y,z]
17:08:25 <edwardk> also argument 4 would be really hard to address without dropping performance through the floor
17:08:29 <edwardk> so i view it as a feature
17:08:33 <ddarius> I also don't agree with 4.  I think, for Binary, that hardcoding ByteString may well be the right thing to do and, at least, is not obviously a bad choice.
17:08:57 <DukeDave> franny: Will I have to run anything to regenerate those?
17:08:57 <Peaker> edwardk: I never get that argument -- why can't a generalized type be specialized right back to the exact same performance?
17:09:13 <DukeDave> ion: Yeah, I think the clean start is probably a good move :|
17:09:16 <edwardk> peaker: i would argue that the burden of proof that it can falls on you =)
17:09:38 <edwardk> it is just another set of hoops you have to jump through, how much harder can it be
17:09:44 <franny> DukeDave: .ghc should repopulate automagically.
17:09:59 <ddarius> Even ignoring the performance aspect, I find that using ByteString is conceptually clearer than trying to make it more generalized.
17:10:01 <Peaker> edwardk: well, I use Haskell, and not C, because I care more about denotational properties of my code than the operational ones.. having to translate between bytestring types makes me yell at my computer :)
17:10:05 <franny> .cabal will repopulate as you install Cabal stuff.
17:10:14 <edwardk> and without the monomorphic version sitting there at the finish line to taunt you along, how would you know if you had eked out what performance you could?
17:10:15 <ddarius> Peaker: You are not the entire Haskell community.
17:10:17 <DukeDave> franny: Here we go then
17:10:38 <Peaker> ddarius: Well, I didn't say my opinions were those of the entire community
17:10:50 <edwardk> peaker: most users of binary are very performance-centric. this is why we have things like blaze-builder, because it just happens to be a lot faster than the stock builder from binary
17:11:10 <edwardk> and its being used for web-apps, which care a LOT about performance
17:11:15 <Peaker> But I think sacrifice of "design correctness" for performance should be a rare choice.. or at least, if such a choice is made, then an alternative, "correct/slower design" should be available
17:11:31 <ddarius> Certainly a higher level "serialization" interface can be defined so you can serialize to binary or JSON or XML or whatever you want.  That's just not the level that binary is operating at.
17:11:54 <edwardk> some times a slower design is just a slower design
17:12:17 <DukeDave> I've deleted .ghc and .cabal, and cabal update'd, but now I'm getting: cabal: cannot configure hint-0.3.3.2. It requires ghc >6.
17:12:17 <DukeDave> Is this ghc the package, or ghc the compiler? :|
17:12:30 <c_wraith> that's ghc the package
17:12:37 <elliott> ddarius: it seems like it could be at that level, just by abstracting out the result/input string type and using records instead of a typeclass
17:12:45 <elliott> that doesn't mean it should do that, but it's close to working for that purpose
17:12:48 <ddarius> elliott: There is much more that you would want.
17:12:51 <Peaker> Well, in this case, we're hard-coding a bytestring type bringing pain to anyone who has to use this with a different type -- on the premise that: A) A concrete type is easier (in my Haskell?)  B) The compiler will fail to specialize
17:13:00 <elliott> ddarius: Well, ok, what?
17:13:21 <Peaker> I think it is safe to assume people can live with polymorphic types in Haskell
17:13:22 <edwardk> peaker: ultimately you are serializing to a sequence of bytes. they have to go somewhere.
17:13:23 <ddarius> elliott: Controlled versioning for one.
17:13:33 <dainanaki> Peaker: there's also the issue of people knowing what types it actually specialises...
17:13:42 <ddarius> edwardk: Which is why I find the choice of ByteString conceptually clearer here.
17:13:46 <elliott> ddarius: Well, OK; then safecopy is close to what you want :-)
17:13:46 <Peaker> edwardk: Sure, why care if they go to Lazy BS or Strict BS?
17:13:57 <DukeDave> Arg, ghc-pkg check is broken again now
17:14:03 <edwardk> opening and closing the bytestring because i have to go through some silly abstraction layer in the middle of the inner loop will completely WRECK the performance of it
17:14:06 * DukeDave bangs head against wall
17:14:39 <aavogt> goodness, ghc's auto UTF-8 decoding isn't what was asked for with lhs2TeX: ./larger-tutorial.lhs: hGetContents: invalid argument (invalid UTF-8 byte sequence)
17:14:43 <Peaker> edwardk: I'm not sure what you're saying -- you can specialize the generalized one to the same implementation you use now (?)
17:14:56 <elliott> aavogt: hSetBinaryMode :p
17:15:02 <Peaker> edwardk: are you repeating the argument that GHC may fail to specialize, or is this a different argument?
17:15:03 <edwardk> and i welcome a screenshot of the resulting core that proves you can do it
17:15:31 <edwardk> i'm not being facetious. i really do
17:15:37 <aavogt> well it shows that nobody has used lhs2TeX with a recent ghc
17:15:56 <Peaker> edwardk: I'll add to my TODO list :)
17:16:11 <roconnor> join #haskell-blah
17:16:15 <roconnor> oops
17:16:19 <elliott> i refuse
17:16:37 <DukeDave> Will I suffer if I delete: /var/lib/ghc-6.12.1/package.conf.d/package.cache   ?
17:16:49 <edwardk> roconnor: already there
17:17:01 <ddarius> Haven't been there in a long, long time.
17:17:03 <roconnor> I was trying to join
17:17:04 <Peaker> DukeDave: worst-case, you reinstall ghc and cabal packages
17:17:05 <elliott> DukeDave: you might want to throw everything out, compile your own GHC, and become a hermit
17:17:10 * DukeDave nods
17:17:17 <ddarius> elliott: Better to execute Haskell by hand.
17:17:20 <elliott> DukeDave: the system packages are usually painful
17:17:36 <elliott> ddarius: that's quicker than compiling GHC; you just can't appreciate the slow life
17:17:57 <acowley> aavogt: I've used it with 7.0.3
17:18:11 <DukeDave> Perhaps I should create a BOINC project for people to compile GHC on, we can hook it into lambdabot :)
17:18:11 <Peaker> one has to get to know how to use cabal-install "correctly".  IME, it involves using --dry-run to verify no system packages will be reinstalled. If they are reinstalled, place a constraint requiring them not to be. Then, figure out which package is overly-conservative about its deps due to the PVP, and delete its upper constaint --> everything is now fine
17:18:35 <elliott> Peaker: thank god for the convenience of package managers!
17:18:36 <DukeDave> Peaker: I have no idea what you just said :|
17:18:46 <ddarius> elliott: You guys have nothing to complain about.
17:18:56 <acowley> I do what Peaker says when I remember to
17:19:03 <DukeDave> Would I be wise to abandon the Ubuntu repos and use everything from haskell.org?
17:19:05 <elliott> ddarius: In my day [...] compiling GHC [...] uphill, both ways [...] the snow [...] no cabal at all?
17:19:13 <DukeDave> Or will I be spending a lot of time doing nothing?
17:19:15 <ddarius> elliott: Correct on all accounts.
17:19:15 <Peaker> acowley: one would think that there would be some.. computer program to automate it.. :)
17:19:25 <elliott> DukeDave: that's what I do; it requires a certain dedication to Haskell that you're willign to wait hours for GHC to compile
17:19:29 <acowley> Peaker: sounds like science fiction
17:19:29 <elliott> but everything usually works, in the end
17:19:34 <aavogt> acowley: well I guess nobody who writes things like ü and encodes it however the larger-tutorial.lhs is done in harpy-0.4.3.0
17:19:39 <edwardk> or just install into user directories and worst-case blow away your .cabal folder
17:19:50 <acowley> aavogt: oh, yes, you need to be careful with characters
17:19:51 <Peaker> elliott: if you know these tricks, sure
17:19:53 <dainanaki> does cabal not build with 7.2.1 yet?
17:20:00 <DukeDave> Hmm, I don't suppose there's a nicely written wiki on all this?
17:20:02 <acowley> aavogt: but that's always the case with TeX.
17:20:06 <DukeDave> Or a friendly shell script?
17:20:09 <Peaker> elliott: Newbies just fail to start with Haskell sometimes, due to cabal-install hardships
17:20:11 <elliott> DukeDave: compiling GHC is just ./configure, make, make install
17:20:14 <DukeDave> Perhaps something like clippy?
17:20:28 <elliott> DukeDave: you need an existing GHC, though, so it's really unpack ghc binary tarball, ./configure --with-ghc=/path/to/extracted/tarball, make, make install
17:20:51 <Peaker> and the hardships of debugging a build error due to a false positive in cabal-install are much easier for beginners and experts to debug, IMO, than the over-conservative false-negatives that wreck havoc
17:20:51 <acowley> aavogt: XeLaTeX loves fancy characters, while other LaTeXs are more reserved in what they will tolerate of their users
17:20:51 <elliott> then you just have to run the cabal bootstrap script, which i usually modify to do haddock documentation too but most people probably don't care enough to
17:20:51 <DukeDave> Ah yes, of course, GHC is written in Haskell :|
17:21:02 <DukeDave> It hurts..
17:21:20 <ddarius> What else would GHC be written in?
17:21:27 <elliott> perl
17:21:40 <acowley> It's a VB macro
17:21:50 <Peaker> DukeDave: the PVP requires that all package authors be utterly paranoid and make their packages refuse to work with any dependency that changed anything which might break anything at all (even if vast majority of changes don't break anything)
17:21:54 <elliott> acowley: so that's why Excel keeps starting
17:22:02 <ddarius> @where vital
17:22:03 <lambdabot> http://www.cs.kent.ac.uk/projects/vital/
17:22:04 <Peaker> DukeDave: and then, not all packages are uniformly updated when new deps come out
17:22:17 <dainanaki> that's the most annoying part.
17:22:49 <Peaker> DukeDave: and then, when you try to install stuff, some dependency often puts its stupid/old paranoid upper limit, forcing a downgrade of some packages. This forces a recompile of packages to link with the older version (which may also cause the "butterfly" problem)
17:23:13 <Peaker> DukeDave: then, you get broken packages and/or failed installs
17:23:33 <elliott> ddarius: oh, that's cool
17:23:37 <elliott> reminds me of mathematica notebooks
17:23:38 <franny> Can you compile ghc with any other existing compilers?
17:23:46 <elliott> franny: no
17:24:00 <franny> Heh.
17:24:27 <Peaker> DukeDave: to "solve" this, you can make sure that the "global" packages (shown in  ghc-pkg list --global)  are not being reinstalled via "--dry-run -v" first. If one is, say: "bytestring" is being reinstalled (to same version, due to older-dep), you can add: "--constraint older-dep==<new ver>" and then cabal will tell you who is the paranoid restrictor
17:24:46 <Peaker> DukeDave: something like: older-dep said to be <new ver>  but paranoid-package requires older-dep <= <old ver>
17:25:18 <Peaker> DukeDave: then you go and: "cabal unpack paranoid-package", edit the cabal file therein to remove the paranoid upper limit on older-dep, and reinstall it
17:25:33 <DukeDave> Peaker: Ah yes, someone in here wrote a page on this didn't they?
17:25:50 <Peaker> I have no idea, I had to discover this myself (with some help, people mentioning each of these things individually)
17:26:12 <DukeDave> Peaker: Hmm, editing the cabal file, that's a good idea.
17:26:32 <Peaker> DukeDave: actually I dislike any re-install to satisfy paranoia... It is almost always possible to just have the newest version of any given package, so I try to have that
17:26:42 <DukeDave> Peaker: This: http://www.vex.net/~trebla/haskell/sicp.xhtml
17:26:48 <Peaker> DukeDave: oh, also remember to bump the minor-minor version when you edit the .cabal file
17:27:05 <Peaker> DukeDave: otherwise cabal will discard your changes and use the hackage one instead at will
17:27:17 <DukeDave> Peaker: It hurts :(
17:27:35 <dainanaki> package management is one of Haskell's warts, to be certain.
17:27:48 <dainanaki> but help is on the way! (soon ™)
17:27:52 <Peaker> Yes.. I've had a bunch of discussions with dcoutts about how I think false-positive is far better than false-negative, and that paranoid version constraints are a bad idea.. but he disagrees
17:27:57 <ddarius> dainanaki: It is?
17:27:58 <gwern> amazing how standards change over time. time was, people praised haskell package management
17:28:19 <dainanaki> ddarius: http://skilpat.tumblr.com/post/9411500320/a-modular-package-language-for-haskell
17:28:23 <Peaker> gwern: as opposed to the nothing that preceded it, it's probably nice :)
17:28:35 <gwern> 'can you imagine ever going back to ./configure and make? truly, cabal is wonderful!'
17:28:52 <Peaker> After some sessions fighting cabal-install, I would definitely be able to imagine that :)
17:29:11 <dainanaki> to be fair, the range of packages and libraries has grown tremendously since the early days of cabal install.
17:29:13 <gwern> it's nice to see that in some areas, we do have progress, if made only by sticking knives in the leaders in front
17:29:33 <bobzhang> did any try haskell-src-meta package?
17:29:42 <dainanaki> I think a lot of these pains are due to the fact that Haskell is growing and improving.
17:29:42 <bobzhang> is it a bug for such case?
17:29:44 <bobzhang> parseExp "(,) 3 4"
17:29:45 <bobzhang> Right (AppE (AppE (ConE GHC.Unit.(,)) (LitE (IntegerL 3))) (LitE (IntegerL 4)))
17:29:45 <bobzhang>  
17:29:57 <Peaker> dylukes: your Expression class sounds like Copointed?
17:30:01 <bobzhang> where's `GHC.Unit.(,)'?
17:30:17 <dylukes> Peaker: what the *fuck* is Copointed >_>
17:30:38 <dylukes> I'm docking around with ways to represent AST's... it's interesting.
17:30:55 <elliott> dylukes: copointed is f where you have (f a -> a)
17:31:15 <dainanaki> so is pointed (a -> f a)?
17:31:32 <ddarius> dainanaki: Yes.
17:31:32 <roconnor> yep
17:31:33 <acowley> Despite the pain of managing versions, I think cabal is fantastic
17:31:49 * acowley spent all day today wrestling with homebrew
17:31:59 <copumpkin> dainanaki: where a is universally quantified, and f is the thing that is pointed
17:32:15 <roconnor> acowley: nix is better
17:32:19 <ddarius> Cabal is a large part of why Haskell has grown so much recently (though far from the only significant factor.)
17:32:22 <roconnor> acowley: but one day cabal will be better than nix
17:32:53 <brisingr> I just wanted to say, haskell has just helped me find the meaning of life. Good night all.
17:32:54 <acowley> roconnor: I've never used nix; how does it improve the cabal experience?
17:33:09 <acowley> @faq can Haskell really help you find the meaning of life?
17:33:09 <lambdabot> The answer is: Yes! Haskell can do that.
17:33:19 <dainanaki> lol
17:33:42 <roconnor> well it doesn't exactly replace cabal.  nix is a general package manager, but it does solve the butterfly problem IIRC.
17:33:46 <acowley> this was a triumph
17:33:48 <shapr> @quote
17:33:49 <lambdabot> <eu-prleu-peupeu> says: just haskell it
17:33:52 <dainanaki> > let theMeaningOfLifeTheUniverseAndEverything = 42
17:33:53 <lambdabot>   <no location info>: lexical error at character '\b'
17:34:23 <dainanaki> :/
17:35:07 <acowley> roconnor: I know, but I'm curious about approaches to dealing with the nastyness of version constraints. It seems intractable on some level if the behavior of a unit can change between versions.
17:35:26 <acowley> Of course there is a lot of low hanging fruit left for cabal to harvest
17:35:43 <roconnor> acowley: oh ya.  nix doesn't solve version constraints.
17:35:45 <acowley> like only verifying compatible versions for exported identifiers
17:35:58 <roconnor> acowley: if all contraints are == constraints, it is pretty easy :D
17:36:28 <DukeDave> Yuck, I didn't realise GHC 6.12.1 was so old :|
17:36:55 <elliott> DukeDave: I was about to snark on its not being that old, but, wow, it is
17:37:18 <DukeDave> "For most users, we recommend installing the      Haskell      Platform instead of GHC. The current Haskell Platform release      includes a recent GHC release as well as some other tools (such as      cabal), and a larger set of libraries that are known to work      together.    "
17:37:23 <DukeDave> Am I "most users" ?
17:37:30 <Draconx> 6.12.1 is less than 2 years old.
17:38:01 <ddarius> DukeDave: There's actually an issue with GHC 6.12.1 that makes it not a version you want to use.
17:38:07 <acowley> Haskell moves fast
17:38:42 <Jafet> Only PhDs need to install GHC
17:38:48 <acowley> DukeDave: probably
17:38:52 <elliott> DukeDave: probably, but you need GHC to compile haskell-platform
17:38:55 <elliott> so if you want to avoid distro packages, ignore that
17:38:57 <DukeDave> Hmm, the rather stylish Haskell platform link takes me through to the Ubuntu repos :|
17:39:17 <Jafet> Use the generic-linux link.
17:39:17 <elliott> DukeDave: You might be fine with the provided Linux binary distrobution for GHC
17:39:20 <elliott> rather than compiling it yousrelf
17:39:24 <DukeDave> Yeah, I should really move to a more recent Ubuntu, but I get scared about dist upgrading..
17:39:25 <acowley> why isn't there a binary Ubuntu disribution of the HP?
17:39:27 <elliott> and then compiling haskell-platform yourself
17:39:35 <elliott> the binary distribution includes documentation and profiling libs so it's pretty good
17:39:57 <Nimatek> Arch's repos have a recent version of the haskell platform.
17:40:17 <acowley> Does anyone have any idea of the relative download numbers of the HP and GHC binary distributions?
17:40:22 <Jafet> Unfortunately, ghc packages are not tolerant of ghc upgrades.
17:40:30 <acowley> Do most people get GHC via the HP?
17:40:44 <Jafet> (Or other packages' upgrades, for that matter)
17:40:45 <roconnor> I get ghc from my distro
17:40:52 <Nimatek> ↑ same
17:41:00 <roconnor> and everything else from cabal as much as possible.
17:41:03 <dylukes> Is there any way to make something like this infer the proper constructor?
17:41:04 <dylukes> https://gist.github.com/1185172
17:41:17 <acowley> roconnor: and your distro keeps pace relatively well?
17:41:21 * DukeDave is now contemplating that he might dist upgrade Ubuntu, because it'll be easy than building GHC myself :|
17:41:32 <dylukes> I'm just messing around aimlessly.
17:41:50 <roconnor> acowley: oh ya.  I use nixos.  It is usually pretty bleading edge.
17:42:37 <Jafet> dylukes: probably because Num is a superclass of Fractional
17:42:48 <DukeDave> The Ubuntu I'm on (Lucid) doesn't even have a haskell-platform package
17:42:50 <Jafet> I suppose it might work if you made them mutually exclusive
17:43:02 <DukeDave> So I think the .deb maintainers have abandoned it
17:43:06 <dylukes> no, still
17:43:07 <dylukes>  Ambiguous type variable `l0' in the constraint:
17:43:08 <dylukes>       (Literal l0) arising from a use of `lift'
17:43:12 <dylukes> If I just remove the Frac case.
17:43:24 <dylukes> oh, wait.
17:43:29 <roconnor> acowley: I've never touched HP and I don't really think it is a good thing.
17:43:32 <dylukes> I never made PrimitiveLiteral an instance of Literal.
17:43:34 <dylukes> derp
17:43:36 <acowley> DukeDave: could you just not use the Ubuntu repos then, and instead use the Linux binary distribution?
17:44:48 <acowley> roconnor: I use it on Windows (which is just an install I keep on my HTPC for compatibility testing), and I like the general idea because Hackage really is a pain to explore, but I don't use it myself either on development machines
17:45:25 <roconnor> acowley: I just ask #haskell for package advice :D
17:45:39 <acowley> I guess I like the experience of installing something like Python or Racket and having a bunch of libraries ready to go
17:45:54 <mike-burns> Yeah it's nice for practical stuff.
17:45:59 <acowley> but then I think cabal stands head and shoulders above those ecosystem's "package managers"
17:46:31 <mike-burns> Huh.
17:46:38 <acowley> roconnor: but we bicker a lot and mostly suggest people use trifecta and bitcoins for whatever they're trying to do
17:47:14 <roconnor> what's trifecta?
17:47:43 <edwardk> my crazy gold-plated parsing library
17:47:46 <acowley> edwardk's new parsing combinator library
17:48:53 <DukeDave> acowley: Ah yes, I didn't spot the 'generic' binary, is it sensible to use that?
17:49:22 <acowley> DukeDave: absolutely!
17:49:25 <Jafet> Well, when Ubuntu is the alternative...
17:49:42 <DukeDave> There's a new Ubuntu release next month, so I'll wait for that
17:49:51 <ddarius> edwardk: Being a good Haskell programmer, rather than providing a gold-plated library, you should provide eletrical leads to allow gold-plating of libraries.
17:50:06 <acowley> first we need smelting combinators
17:50:14 <edwardk> =)
17:50:19 <Jafet> We already have lenses
17:50:22 <ion> Yeah, i’m running Oneiric, it has haskell-platform 2011.2 with ghc 7.0.3
17:50:23 <DukeDave> So, grab the 'generic binary' and install it, then grab 'haskell-platform-2011.2.0.1.tar.gz' and install that..
17:50:34 <edwardk> we'll use the lenses to heat the metal
17:51:04 <edwardk> but we'd better be sure not to pick any one type of metal, or peaker won't use the library
17:51:08 <acowley> DukeDave: that is one option. You can also forego the HP and just install from cabal as you go.
17:51:11 <ddarius> Au NIH.
17:51:35 <Peaker> edwardk: s/won't use/won't like :-)
17:51:39 <DukeDave> Actually with this¹, it should be painless to switch to back to the Ubuntu repos once I've upgraded my distro
17:51:39 <DukeDave> ¹ https://help.ubuntu.com/community/CheckInstall
17:51:41 <acowley> polymorphic transmutation is the only way to code
17:52:21 <DukeDave> acowley: Yeah, so, HP is just a bunch of 'popular' packages off cabal, right?
17:52:21 <acowley> DukeDave: possibly, but there's not a lot of downside to managing your own .cabal
17:52:41 <roconnor> is trifecta better than parsec?
17:52:42 <acowley> DukeDave: It is also versions of those packages that are known to work
17:52:53 <DukeDave> Mm, I get the impression that it's worth keeping a reign on what cabal is up to
17:53:03 <edwardk> roconnor: i think that much is safe to say at this point
17:53:07 <tensorpudding> not just popular, but supported in a stronger sense
17:53:10 <Jafet> parsec isn't gold-plated
17:53:11 <DukeDave> Ha, that's reassuring, "versions of those packages that are known to work"
17:53:13 <acowley> DukeDave: in practice, you are usually fine with cabal until things go nightmarishly bad
17:53:26 <acowley> DukeDave: s/work/work together
17:53:31 <DukeDave> acowley: You make it sound like working packages are the exception ;)
17:53:34 <mike-burns> HP is a bit of an effort to fix the issue of a whole bunch of undocumented libraries that do the same thing.
17:53:50 <acowley> right
17:53:54 <dmwit> acowley: Why, just today I re-installed GHC rather than trying to figure out how to fix what cabal-install had done!
17:54:04 <mike-burns> You look at Hackage, see a whole bunch of parsing libraries, then come here and ask which is best.
17:54:06 <DukeDave> Perhaps we need a cabal install --working-packages   :)
17:54:08 <dmwit> Not that I blame cabal-install.
17:54:20 <dmwit> My package repository would have been broken even sooner if I had tried to do it without cabal-install.
17:54:23 <dmwit> =P
17:54:25 <acowley> dmwit: call it a cleansing ritual and wake to a glorious new day tomorrow!
17:54:27 <DukeDave> dmwit: Re-installed GHC from where?
17:54:40 <dmwit> DukeDave: from The Internet
17:54:46 <roconnor> mike-burns: I don't think that is the goal of HP
17:54:51 <dmwit> (or: what do you mean by "from where"?)
17:54:51 <acowley> they have GHC on The Internet now?
17:55:02 <roconnor> I certainly hope that isn't a goal of HP
17:55:12 <mike-burns> roconnor: What do you hope the goal of HP is?
17:55:21 <acowley> roconnor: I think that is one of its goals
17:55:24 <DukeDave> dmwit: cabal: There is no package named 'Internet'.    :(
17:55:45 <dmwit> DukeDave: clyde -Rc ghc && clyde ghc
17:55:48 <dmwit> ;-)
17:55:49 <ion> I haven’t actually looked at Trifecta yet, just gathered some IRC conversation snippets about it so far, so please excuse my ignorance: would it be sensible for a code editor to store a Trifecta state at certain points (say, every n lines or bytes) in the file into a cache for fast syntax highlighting? If part of the code becomes invalid while typing an expression, perhaps keep the old cached highlighting from the next cache point following the point of error
17:55:49 <DukeDave> dmwit: Ahem, yes, did you get it from here: http://hackage.haskell.org/platform//linux.html
17:55:55 <ion> until the whole thing parses again, or something.
17:56:00 <dmwit> DukeDave: no
17:56:20 <roconnor> mike-burns: I hope their goal is to collect widely useful high-quality packages to replace the ones that have (rightly) been expunged from the GHC distribution.
17:56:21 <edwardk> ion: a better idea would be to set up your parser as a process and feed it edited ropes as you work
17:56:31 <DukeDave> dmwit: clyde is a package manager?
17:56:48 <Jafet> Code editors should allow only transformations between valid code
17:56:55 <edwardk> ion: if you use the material from the original trifecta talk you can build the entire parser that way so you can actually just insert into the middle of the rope
17:56:59 <dmwit> DukeDave: Yes, it's for Arch Linux.
17:57:14 <edwardk> ion: and if you have enough error productions you'll be able to recycle most of the previous parse
17:57:22 <roconnor> BRB
17:57:31 <dmwit> Jafet: People have tried that, those editors are too frustrating to use.
17:57:39 <Draconx> Jafet, really, programming languages should just have no invalid programs.
17:57:47 <ddarius> Draconx: Use Io.
17:58:18 <permagreen> Draconx: I'm pretty sure that is actually proven impossible
17:58:19 <mike-burns> I just realized that I'd watch an IRC channel named #stream-of-opinions.
17:58:22 <ddarius> I think Io is the one I want, though there's at least two other Ios, albeit the statement is probably true of one of them.
17:58:22 <edwardk> ion: for that to work with the current trifecta i need to finish extending the ropes with user annotations, but i need that for the dyck language machinery anyways
17:58:27 <dmwit> Damn, my sarcasmeter is lagging by a few minutes.
17:58:28 <Draconx> permagreen, huh?  It's trivial.
17:58:43 <permagreen> Something to do with Godel, and some incompleteness theorem
17:58:55 <Jafet> ddarius: jot.
17:58:58 <CPO\_\bot> permagreen: no.
17:59:01 <mike-burns> Godel should have finished his proof if he wanted people to care about it.
17:59:03 <Draconx> permagreen, consider a language where every character is a comment, and all programs print "Hello" and terminate.
17:59:04 <edwardk> trifecta is basically a refactored parsec, with a lot of extra stuff thrown on top
17:59:05 <CPO\_\bot> ddarius: You're thinking of Iota.
17:59:10 <CPO\_\bot> ddarius: BUt, yeah, Jot.
17:59:11 <ddarius> Yes.
17:59:18 <CPO\_\bot> Iota has invalid programs, Jot doesn't.
17:59:27 <justin-kp> is there an easy way to convert from State s a -> s -> IO a?
17:59:29 <Jafet> dmwit: which editors are those?
17:59:33 <ddarius> I don't remember which is which out of the two.
17:59:39 <copumpkin> justin-kp: sure
17:59:50 <dmwit> Jafet: "structured editor" is probably the right term for Googling
17:59:59 <justin-kp> copumpkin: how?
18:00:19 <copumpkin> :t return .: evalState
18:00:20 <lambdabot> forall a (m :: * -> *) s. (Monad m) => State s a -> s -> m a
18:00:27 <ddarius> copumpkin: Curse you.
18:00:33 * copumpkin hides
18:00:44 <ddarius> copumpkin: You're already cursed.  It's a little late for that.
18:00:49 <copumpkin> :(
18:00:58 <Jafet> Heh
18:01:06 <Jafet> @hoogle unsafeSTToIO
18:01:07 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
18:01:12 <roconnor> ahh
18:01:17 <roconnor> fresh new system
18:01:35 <justin-kp> copumpkin: is that right?
18:01:42 <dmwit> :t (.:)
18:01:43 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
18:01:53 <copumpkin> justin-kp: it has the type you want. What are you looking for?
18:01:56 <dmwit> Oh, lol.
18:02:15 <Jafet> @type evalState
18:02:16 <lambdabot> forall s a. State s a -> s -> a
18:02:30 <justin-kp> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-State-Lazy.html#v:evalState
18:02:35 <Jafet> I actually thought justin-kp was talking about ST
18:02:38 <justin-kp> does not have right type
18:03:01 <copumpkin> justin-kp: I wrote return .: evalState
18:03:16 <copumpkin> justin-kp: didn't you see the type lambdabot gave for that?
18:03:27 <justin-kp> ohh
18:03:35 <copumpkin> :t (return .) . evalState
18:03:36 <lambdabot> forall a (m :: * -> *) s. (Monad m) => State s a -> s -> m a
18:03:44 <copumpkin> that will work outside of lambdabot
18:04:01 <ion> edwardk: Alright
18:04:34 <edwardk> ion: http://comonad.com/reader/2009/iteratees-parsec-and-monoid/ the second set of slides
18:06:16 <justin-kp> so that is converting to IO sort of after the fact
18:06:44 <justin-kp> what if i wanted to have the state actions be implemented in terms of an actual mutable cell
18:07:28 <ion> edwardk: Thanks
18:07:51 <justin-kp> so put modifies the cell and get reads from it (in IO)
18:09:16 <Jafet> If you really want to write your code that way, use Data.IORef
18:10:06 <CPO\_\bot> justin-kp: why do you want this? Performance?
18:10:34 <dmwit> justin-kp: If you had the foresight to write your code in a polymorphic way (i.e. using only MonadState functions), you can specialize your polymorphic code to a monomorphic type that uses IORef.
18:10:45 <dmwit> ...or STRef, or whatever
18:11:09 <Jafet> Mono Morphin'
18:11:37 <justin-kp> dmwit: i see
18:11:59 <justin-kp> i think i can do that
18:12:01 <justin-kp> cool
18:12:51 <dmwit> I don't think there is a commonly-used instance that does that, but it's not hard to write (I've done it at least twice myself =P).
18:13:02 <aavogt> does somebody know how the   foreign import "dynamic" conv[1234]   as written here: http://hackage.haskell.org/packages/archive/harpy/0.4.3.0/doc/html/src/Harpy-CodeGenMonad.html#callDecl knows what code "dynamic" refers to?
18:14:08 <aavogt> no other code in harpy seems to discuss this "dynamic"
18:14:33 <dmwit> aavogt: Isn't the "dynName" the part that tells what code it refers to?
18:16:01 <aavogt> dmwit: dynName is the name it gets bound to on the haskell side (hence my conv[1234])
18:16:33 <ion> edwardk: There seems to be a small typo in the monoid introduction slides. Page 20: Cols _ `mappend` Lines l’ c’ = Lines l c’
18:16:45 <aavogt> after all, dynName is used elsewhere to write a valD which refers to that foreign import
18:16:47 <monochrom> @quote ddarius isJust
18:16:47 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
18:16:53 <monochrom> ddarius wins!
18:16:57 <edwardk> ion: there are several typos in there
18:18:00 <edwardk> eitherToMaybe makes a good unsafeCoerce as well
18:18:16 <Jafet> @quote generalisation
18:18:16 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
18:18:20 <ion> tsuJsi :: Bool -> Maybe a; tsuJsi = unsafeCoerce
18:18:38 <CPO\_\bot> ion: I wonder what that does
18:18:42 <edwardk> ion: a bit more dangeruous =)
18:19:07 <dmwit> CPO\_\bot: It follows an uninitialized pointer, naturally.
18:19:13 <CPO\_\bot> dmwit: not if you pass false
18:19:21 * dmwit accedes that point
18:19:36 <ion> λ> let isJust :: Maybe a -> Bool; isJust = unsafeCoerce; tsuJsi :: Bool -> Maybe a; tsuJsi = unsafeCoerce in (tsuJsi . isJust) <$> [Nothing, Just "o hai"] :: [Maybe String]
18:19:37 <elliott> <elliott> !haskell print (Unsafe.Coerce.unsafeCoerce False :: Maybe ())
18:19:37 <elliott> <EgoBot> Nothing
18:19:37 <elliott> <elliott> !haskell print (Unsafe.Coerce.unsafeCoerce True :: Maybe ())
18:19:37 <elliott> <EgoBot> ​./interps/ghc/runghc: line 7: 30718 Segmentation fault      ghc -O2 -e "`cat $1`" 2> /dev/null
18:19:40 <ion> [Nothing,Just "o hai"]
18:19:41 <elliott> dmwit: it's close :P
18:20:38 <dmwit> elliott: ghci gets it right, try it ;-)
18:20:39 <edwardk> the problem is the unboxed argument to Just
18:20:59 <elliott> dmwit: so it's as reliable as my withInstance hack, then?
18:21:05 <astePC> What file extension should I use for Haskell?
18:21:07 <elliott> that could have been great :(
18:21:11 <azaq23> astePC: .hs
18:21:11 <elliott> astePC: .hs
18:21:19 <astePC> ok
18:21:29 <dmwit> (ghci is remarkably robust to the kinds of hacks that you would expect to cause crashes)
18:21:32 <shachaf> astePC: .lhs
18:21:55 <ion> astePC: .filenames-are-just-for-humans-anyway
18:21:59 <elliott> I think that hack might have actually been useful
18:22:01 <elliott> I mean, if it worked
18:22:21 <dmwit> ion: Actually, they're not any more.
18:22:41 <dmwit> ion: With GHC at least, you need to specify that a particular file is hs or lhs if it doesn't have one of those extensions.
18:23:18 <ion> dmwit: Yes, conventions popularized by MS-DOS have infected the thinking of many a programmer. :-P
18:25:32 <ddarius> ion: I recommend .hi for the file extension of your source files.
18:25:51 <Jafet> Sounds friendly
18:26:05 * copumpkin tries to come up with a simpler type scheme for his current project
18:26:24 <ddarius> copumpkin: a -> b
18:26:37 <ddarius> Though I guess () -> a is simpler.
18:26:40 <edwardk> copumpkin: just remove them, types never helped anyone in the real world anyways
18:26:42 <copumpkin> kmc: I can write binary parsers that seek (load from arbitrary locations in memory), and my stream parser will refuse to use them until I stop seeking
18:26:53 <copumpkin> kmc: my memory parser will be quite happy to take them, though
18:27:09 <elliott> copumpkin: () -> () is simplest of all
18:27:14 <copumpkin> elliott: good idea
18:27:19 <copumpkin> ddarius: also a good idea
18:27:24 <elliott> copumpkin: no wait, Void
18:27:28 <elliott> that has exactly one element
18:27:35 <elliott> you can't possibly implement it wrong
18:27:51 <kvey> :o a copumpkin!
18:27:59 <Jafet> Unless it was implemented as data Void = Void Void
18:28:09 <Jafet> ("The endless Void")
18:28:10 <elliott> Jafet: that's not Void
18:28:18 <copumpkin> elliott: he means you did it wrong
18:28:23 <copumpkin> if you implement it that way
18:28:31 <elliott> oh, I'm talking about implementing a _value_ of type Void
18:28:40 <elliott> you should use the standard optimised Void type from your vendor
18:28:42 <aavogt> dmwit: ah, dynName is actually the thing being imported. "dynamic" refers to the import being "stub factory for importing addresses", whatever that means
18:29:02 <edwardk> jafet; newtype Void = Void Void
18:29:04 <ddarius> Jafet: Darkness is Void; Juffo-Wup is light.
18:29:12 <edwardk> or data Void = Void !Void or data Void
18:29:41 <Jafet> Oh cool, the first two are hs98
18:29:45 <edwardk> ddarius++ for the SCII reference
18:29:46 <ddarius> type Void = forall a. a
18:30:21 <edwardk> Jafet: yep. the void package uses those
18:30:48 <edwardk> jafet: the newtype version blows up in ghc 6.12.1 or so but is otherwise the nicest
18:30:53 <ion> “data Foo”.
18:31:04 <edwardk> so for the one buggy version i use data otherwise i use newtype
18:31:05 <ion> “data Void” that is.
18:31:19 <edwardk> ion: problem there is the need for EmptyDataDecls so it takes it past 98
18:31:34 <Samy> Hi edenc
18:31:39 <Samy> And also, hello edwardk
18:31:43 <edwardk> heya samy
18:31:54 <copumpkin> omg it's a Samy
18:32:04 <copumpkin> Samy: what'd you do with sbahra?
18:32:07 <Samy> Hey copumpkin ;]
18:32:11 * edenc re-settles in lurking position
18:32:19 <copumpkin> kvey: :O
18:32:23 <Samy> He's asleep, tired.
18:38:30 <roconnor> edwardk: or it takes it before 98
18:38:48 <edwardk> roconnor: touche
18:39:30 <ddarius> data Eval a => Void a
18:40:00 <Jafet> Sounds like a Gene Ray–ism
18:41:05 <ddarius> There are a lot of things that can be characterized as arising from functors having left/right adjoint left/right inverses.
18:42:26 <aavogt> is there some way to   (`sepBy1` newline), even if the parser I apply that function to would normally consume the newlines?
18:43:05 <elliott> many1 newline
18:43:10 <elliott> erm
18:43:11 <elliott> many1 p?
18:43:30 <Jafet> You can't subtract from parsers
18:43:42 <Jafet> Unless the newline was optional
18:43:57 <aavogt> yes, the parser succeeds if there's no newline
18:44:07 <elliott> change the parser :)
18:44:32 <Jafet> It'd have to backtrack every time, at least
18:44:42 <aavogt> but because it's optional, the newline never gets to consume anything
18:45:15 <aavogt> since the p consumes the newline, moves on to the next line and parses it as nonsense (but doesn't fail)
18:47:46 <aavogt> edwardk: did you say sometime that trifecta is getting a way to interpret layout?
18:48:21 <edwardk> aavogt; yes. i just have to part that parser to the trifecta codebase. its already written
18:54:52 <acowley> unpacking linear algebra calculations in order to exploit known structure is an obnoxious task
18:55:37 <DukeDave> What's a good way to get rid of cabal?
18:55:44 <DukeDave> I.e. Clean everything out
18:56:20 * DukeDave has a cabal binary in /usr/local/bin, no idea where it came from :|
18:56:38 <parcs> rm /usr/local/bin/cabal
18:56:47 <DukeDave> parcs: Thank you :P
18:56:48 <parcs> cabal-install doesn't install anything else
18:57:00 <DukeDave> Ah, okay?
18:57:09 <DukeDave> Sure there are some conf files I need to blast away?
18:57:17 <parcs> there are none
18:58:13 <DukeDave> Okay
18:58:49 <acowley> the ease with which cabal can be nuked and reborn contributes to most #haskellers using a binary GHC and managing their own cabal packages
18:59:17 <parcs> http://paste.pocoo.org/show/468109/ is what arch linux has for cabal-install
19:00:29 <deech> Has anyone run into this error when running :hist at a breakpoint in the GHCI debugger? *** Exception: compiler/main/InteractiveEval.hs:(182,14)-(186,47): Irrefutable pattern failed for pattern Data.Maybe.Just decl
19:00:49 <DukeDave> parcs: Thanks, that's reassuring :)
19:01:14 <ion> edwardk: Would something like «fooMappend a b = …; instance Semigroup Foo where { (<>) = fooMappend }; instance Monoid Foo where { …; mappend = fooMappend }» solve the issue of code duplication without causing one dictionary to depend on the other?
19:02:17 <edwardk> ion: well in the case you asked about way back when, both dictionaries were simple enough that nothing was gained either way
19:02:23 <edwardk> ion: it was just force of habit
19:02:33 <parcs> deech: what version of ghc is that?
19:02:51 <deech> parcs: 7.0.2
19:03:08 <ion> edwardk: I’m just looking at Trifecta code and was reminded of that again. :-)
19:03:14 <edwardk> which part?
19:03:42 <ion> edwardk: I began reading the very first commit.
19:04:01 <deech> parcs: 7.0.1 sorry
19:04:25 <ion> The old Text/Trifecta/Cursor.hs in this case.
19:04:33 <edwardk> yeah the style evolved as i went
19:04:52 <deech> Do you recommend upgrading to 7.2.1?
19:05:08 <ddarius> We need to have more discussion of comonad-in-the-bicategory-of-cospans-of-Set theory.
19:07:09 <tgeeky> ddarius: it's neither a set nor a theory. discuss.
19:07:09 <lambdabot> tgeeky: You have 1 new message. '/msg lambdabot @messages' to read it.
19:10:08 <DukeDave> So I suppose the next question is, should I carry on as I used to always using "cabal install --global"
19:11:12 <parcs> deech: do you have an isolated test case? i happen to have 7.0.3 and HEAD built atm
19:11:25 <JoeyA> Just curious, if you take a small slice out of a big Vector, then discard the big Vector and keep the slice, will the garbage collector discard the big Vector?  Or will it be pinned down because its items are referenced by the slice?
19:11:26 <parcs> and lines 182-186 don't point to pattern matchings
19:12:07 <ddarius> JoeyA: The latter I'm pretty sure.
19:12:21 <ddarius> But you can check by checking what the asymptotics of slicing are.
19:12:26 <JoeyA> That is, can the garbage collector collect unused fragments by creating new slices?
19:12:40 <JoeyA> slice is O(1), according to the documentation.
19:12:58 <JoeyA> In theory, it's possible.  I'm just curious if GHC does it.
19:13:13 <ddarius> No, it doesn't.  It doesn't know anything about Vector.
19:13:22 <JoeyA> thanks
19:13:37 <parcs> the last change of line 182 happened 4 years ago
19:16:39 <deech> parcs: No unfortunately not, I was stepping through some of Oleg Kiselyov's delimited continuation code when I hit it. I don't understand his code well enough to isolate it.
19:18:26 <kmc> yeah, you have to copy if you want the bigger vector to get garbage collected
19:18:31 <kmc> :t Data.ByteString.copy
19:18:39 <kmc> lambdabot noooo
19:19:49 <parcs> deech: try upgrading to at least the latest version in the HP
19:19:56 <deech> parcs: will do.
19:20:22 <elliott> Where's the most commonly-used non-empty list type? IIRC it's buried in some other package.
19:21:03 <elliott> oh, there's one in semigroups, maybe that's what I'm thinking of
19:21:57 <kmc> (a,[a]) ;)
19:22:45 <acowley> indeed
19:29:35 <JoeyA> > let x = 123; digits | x < 10 = 1 | x < 100 = 2 | x < 1000 = 3 | otherwise = error "File not found" in digits
19:31:40 <JoeyA> When I want a series of guards based on computed values rather than arguments, this is a simple trick that lets me do it (namely, defining a dummy variable)
19:32:42 <elliott> that's a trick?
19:32:57 <JoeyA> Is there a name for it?  Or "pattern", if you will.
19:33:00 <deech> parcs: It works in 7.2.1. Weird
19:33:18 <JoeyA> That sounded condescending, sorry.
19:34:08 <ddarius> JoeyA: No, it's just ordinary code.
19:34:09 <elliott> JoeyA: I don't think giving names to things to shorten code has a name :)
19:34:15 <elliott> It's called "not inlining everything"?
19:34:35 <tgeeky> inline ALL THE THINGS
19:36:48 <deech> tgeeky: Does that meme have a name?
19:37:37 <JoeyA> On the same note, is FileNotFound a well-known-enough meme?
19:38:00 <tgeeky> deech: my comment was a joke, a meme
19:38:20 <ion> @check let digits base x = length . takeWhile (< x) $ iterate (*base) 1 in \x -> x < 0 || (digits 10 x == length (show x))
19:38:55 <JoeyA> How does that function handle numbers with zero or fewer digits?
19:38:58 <deech> tgeeky: So was mine, in the context of JoeyA's comments.
19:39:30 <dmwit> > logBase 10 10
19:39:34 <dmwit> > logBase 10 100
19:39:36 <ddarius> 1
19:39:37 <ddarius> 2
19:39:37 <dmwit> > logBase 10 1000
19:39:39 <ddarius> 3
19:39:41 <tgeeky> hehe
19:39:45 <tgeeky> i was going to do it
19:39:45 <dmwit> ddarius++
19:39:50 <JoeyA> lol
19:39:52 <ion> dmwit: Doesn’t scale. ;-)
19:39:53 <tgeeky> how about this
19:40:02 <JoeyA> > fix error
19:40:13 <tgeeky> > logBase 1806 (1806+43)
19:40:15 <franny> http://www.youtube.com/watch?v=hP0kWqJJZa4
19:40:21 <DukeDave> Alright! Fine! You win!
19:40:21 <DukeDave> /me cleared everything out, got a new generic GHC binary, installed cabal-install from source, and is now being punished
19:40:40 <dmwit> 1.0031378725387878
19:40:44 <JoeyA> franny: +1
19:41:24 <JoeyA> I have that on cassette tape.
19:41:28 <JoeyA> err, VHS
19:41:35 <DukeDave> ARGH, ghc-pkg check says I'm broken and *I haven't even done anything yet*
19:41:57 <ion> digits base x = max 1 . length . takeWhile (<= x) $ iterate (*base) 1
19:42:00 <tgeeky> dmwit: i meant to do that the other way
19:42:39 <tgeeky> i learned the only digits that have recursively defined exponentiation are 1,2,6,42,1806
19:42:59 <gwern> > 3 * 15 * 21
19:43:13 <gwern> 945
19:43:30 <dmwit> tgeeky: What does that mean?
19:43:56 <tgeeky> dmwit: on Z/nZ, the recusrive definition of exponentiation
19:43:57 <tgeeky> n^0 = 1
19:44:01 <tgeeky> n^(k+1) = n^k * n
19:44:16 <tgeeky> is valid iff n IN {0,1,2,6,42,1806}
19:44:27 <tgeeky> that sound better?
19:44:44 <dmwit> No?
19:44:46 <franny> I thought n+k patterns were deprecated. ;)
19:45:19 <tgeeky> dmwit: i'm quoting from a book, the proof was by John dyer-Bennet and Don Zagier
19:45:24 <dmwit> That looks like a perfectly good definition for 3^k on Z/3Z.
19:45:36 <dmwit> Slash perhaps I don't know what Z/nZ means.
19:45:56 <dmwit> But I thought Z/nZ was just arithmetic mod n.
19:45:57 <tgeeky> it says on the same page "the recursive definition of exponentiation failz in Z/3Z"
19:46:25 <tgeeky> n^3 * n is not equal to n^4 in Z/3Z
19:46:41 <joe6> any suggestions to improve this code, please? http://codepad.org/h4jLE07m
19:47:00 <ion> I want full mathematical patterns! «f (sin (x/2)) = x» is equivalent to «f x = asin x * 2»!
19:47:25 <joe6> no comments, it is still a wip.
19:47:39 <dmwit> 0^3 * 0 = 0 * 0 = 0 = 0^4; 1^3 * 1 = 1 * 1 = 1 = 1^4; 2^3 * 2 = 8 * 2 = 2 * 2 = 4 = 1 = 16 = 2^4
19:47:47 <dmwit> so... what exactly do you mean by "fails"?
19:48:01 <ddarius> dmwit: Since the statement is true by definition...
19:49:11 <tgeeky> dmwit: not sure, let me check it out.
19:49:27 <copumpkin> tgeeky: I don't understand
19:50:02 <tgeeky> copumpkin: i am quoting from a paper, so I don't understand entirely yet either
19:50:11 <dmwit> I mean, how can a definition fail?
19:50:16 <dmwit> It's a definition.
19:50:52 <copumpkin> @oeis 0,1,2,6,42,1806
19:50:58 <copumpkin> gah
19:50:59 <ddarius> No bot.
19:51:00 <tgeeky> n^3 * n = 1  ; n^4 = 2  in Z/3Z
19:51:01 <copumpkin> fucking lambdabot
19:51:14 <copumpkin> tgeeky: forall n? :P
19:51:16 <dmwit> tgeeky: For what n?
19:51:21 <copumpkin> Cale!!!
19:51:50 <shachaf> @get-cale
19:51:54 <shachaf> Useless.
19:52:31 <dmwit> That has undefined behavior for values of shapr not equal to shapr.
19:52:57 <dmwit> It's like the opposite of Haskell, where the behavior of undefined comes from values of shapr that *are* equal to shapr.
19:55:08 <ion> lambdabot should have been written in Erlang, so it would have a nine-nines uptime.
19:55:10 <dmwit> tgeeky: Perhaps you could just link us to the paper you're reading and tell us which page to look on...
19:55:28 <ddarius> ion: Too bad linode or whatever doesn't have 9 9s.
19:56:18 <tgeeky> dmwit: I was looking for the cited paper, but here is what I'm reading:
19:56:19 <tgeeky> http://www.borovik.net/ST_Without_Images.pdf
19:56:24 <tgeeky> page 53
19:56:49 <ion> That’s where distribution comes in! Put instances into ten different data centers. When one dies, the supervisor moves the process into one of the nodes that are still there. lambdabot is such a critical part of our infrastructure this should have been done from the very beginning.
19:57:52 <tgeeky> dmwit: the paper he seems to be refering to is this one: http://metu.edu.tr/~dpierce/Mathematics/Numbers/ordinals.pdf
19:58:34 <tgeeky> dmwit: yeah, that second link, page 11, "Theorem 1"
19:58:44 <franny> ion: if most of the bot's features require Haskell to be running, though, you'd need an entire Haskell implementation running in Erlang to achieve such uptime, wouldn't you?
19:59:32 <ion> Kidding aside, as soon as someone implements the equivalent of OTP in Cloud Haskell, we’ll have pretty much that capability in Haskell. :-)
20:00:01 <dmwit> tgeeky: I can't understand how he computes that (2^3 * 2 = 1). That seems like an error.
20:01:38 <ion> dmwit: In arithmetic modulo 15 it isn’t!
20:02:14 <dmwit> ion: In this particular place, it's arithmetic module 3.
20:02:18 <dmwit> s/module/modulo/
20:02:35 <ddarius> ion: We pretty much have that capability today.
20:02:45 <copumpkin> http://oeis.org/search?q=1%2C2%2C6%2C42%2C1806&language=english&go=Search
20:02:45 <copumpkin> Numbers n such that m^(n+1) = m mod n holds for all m.	
20:03:10 <JoeyA> Where is the Functor instance for (Either a) defined?
20:03:18 <copumpkin> that's different from what tgeeky was saying
20:03:22 <copumpkin> or at least how I interpreted it
20:03:40 <tgeeky> copumpkin: certainly, since that list is larger
20:03:44 <copumpkin> no
20:03:50 <copumpkin> http://oeis.org/A014117
20:03:58 <ion> joeya: Control.Monad.Instances, but you get it by importing Control.Applicative, which tends to be more generally useful.
20:04:05 <copumpkin> tgeeky: that's the one your paper references
20:04:05 <JoeyA> Thanks.
20:04:26 <JoeyA> ion: Control.Applicative does not import it.
20:04:36 <copumpkin> tgeeky: it's not that the recursive definition of exponentiation is wrong
20:05:02 <copumpkin> it's that forall x. x^(n+1) == x (mod n) iff n is one of those numbers
20:05:29 <dmwit> Aha. He's assuming that the exponent is *also* in Z/nZ.
20:05:34 <dmwit> That's a bit of a weird assumption.
20:05:36 <copumpkin> no
20:05:43 <dmwit> yes
20:05:54 <ion> joeya: Please recheck that.
20:06:07 <dmwit> When he says "this definition is valid" in the paper, he means the definition leads to a well-defined function when "n" is in Z/nZ.
20:06:19 <dmwit> s/"n"/the exponent/
20:06:42 <ddarius> copumpkin: The connection to yours being that x^(n+1) = x = x^1
20:06:48 <dmwit> It's easy to see why this should be true exactly when x^(n+1) = x^1
20:08:12 <copumpkin> dmwit: how is "n" ever in Z/nZ?
20:08:27 <tgeeky> yeah, now I'm triply confused.
20:08:29 <dmwit> Let me apologize for conflating too many variables.
20:08:32 <dmwit> Let me try again.
20:08:34 <ddarius> copumpkin: The exponent of the exponentiation operator.
20:08:39 <hpaste> “Joey Adams” pasted “Control.Applicative does not import the Functor instance for (Either a)” at http://hpaste.org/50836
20:08:44 <tgeeky> can someone write this in haskell? :o
20:08:46 <ddarius> I.e. (^) :: Z/nZ -> Z/nZ -> Z/nZ
20:08:55 <ddarius> tgeeky: Almost beat you to it.
20:09:11 <JoeyA> ion: ^
20:09:25 <copumpkin> I'd write a @check for it
20:09:28 <copumpkin> if the fucking bot were here
20:09:32 <dmwit> For field Z/nZ, and particular base x, we might like to define a function (x^) :: Z/nZ -> Z/nZ inductively.
20:09:44 <dmwit> But we're in a bit of a bind doing induction on Z/nZ, since there's some wraparound.
20:09:57 <dmwit> To check that the definition is OK, we have to check that when it wraps around, good things happen.
20:10:16 <ion> joeya: Curious, import doesn’t seem to import those instances indeed. :m + Control.Applicative works.
20:10:30 <dmwit> For exponentiation, this amounts to checking that x^(n+1) = x^1 (or that x^n = x^0).
20:10:50 <tgeeky> this almost sounds like a group property
20:10:52 <ddarius> I think the whole point of the original reference was simply not to use induction blindly.
20:10:54 <tgeeky> s/group/cyclic group/
20:11:02 <dmwit> Right.
20:11:04 <tgeeky> ddarius: yeah, it was
20:11:06 <ion> joeya: import Control.Applicative works in a file, though.
20:11:13 <ddarius> tgeeky: No, a cyclic group would be taking the exponent from Z.
20:11:22 <tgeeky> ddarius: yeah, that's why I said almost
20:11:31 <ddarius> This is what was so confusing to everyone.
20:12:18 <aavogt> what is a better way to handle foreign imports where I know some dimensions: http://hpaste.org/50837
20:12:19 <tgeeky> ddarius: he later says "Yet the confusion continues to be made, even in textbooks for students of mathematics and CS who ought to understand the distinction"
20:12:41 <elliott> Is there a way to turn off the "Pattern match(es) are non-exhaustive" warning for a single function?
20:12:54 <copumpkin> elliott: stick an underscore in
20:12:56 <elliott> GHC is too stupid to see that it is type-systemly impossible to call the function with one of the "unmatched" patterns.
20:13:01 <ddarius> My impression is that induction is usually not adequately taught.
20:13:10 <aavogt> add another case that cannot be reached then
20:13:15 <elliott> copumpkin: I refuse to bow to GHC's wishes. :-(
20:13:17 <tgeeky> ddarius: yeah, me too, (and for me, too)
20:13:26 <elliott> Especially since there's a lot of these functions (in different files).
20:14:25 <ddarius> elliott: Then simply turn off the warning as a flag.
20:14:33 <ddarius> Check the manual.
20:14:47 <elliott> ddarius: Yeah, but you can't do that for just one function, can you?
20:15:00 <elliott> I'm interested in unmatched pattern errors for other functions in the same file.
20:15:01 <aavogt> you can put that one function in a separate module
20:15:09 <sm> how's it going DukeDave ?
20:15:12 <elliott> aavogt: That would almost double my number of modules.
20:15:30 * ddarius estimates that elliott has 1 module.
20:15:30 <DukeDave> sm: Everything is wonderful!
20:15:41 <dmwit> elliott: Pick the least undesirable of the proposals so far.
20:15:43 <sm> really ? all finished ?
20:15:57 <elliott> ddarius: About twenty, actually.
20:16:05 <elliott> The least undesirable is adding the _ case, but it's still annoying. :p
20:16:06 <aavogt>  {-# OPTIONS_GHC -fno-warn-??? #-}
20:16:06 <ddarius> 20 ~ 1
20:16:25 <elliott> ddarius: 40 ~/~ 1.
20:16:29 <DukeDave> sm: My troubles with cabal?
20:16:31 <elliott> I'd like to keep my number of modules at 1.
20:16:32 <sm> yes
20:16:37 <elliott> But yeah, I'll just do it the ugly way. :(
20:16:43 <ddarius> elliott: There's a program that will do that.
20:16:48 <eyebloom> What is the difference between the $ operator and the . operator?
20:16:49 * sm just caught up
20:16:50 <ddarius> Though I don't think it is maintained.
20:16:58 <elliott> ddarius: Do what?
20:17:04 <ddarius> eyebloom: What's the similarity between ($) and (.).
20:17:08 <DukeDave> Yeah! I grabbed the generic GHC binary, and the cabal-install tar, and after a bit of faffing everything seems to work
20:17:11 <ddarius> elliott: Make your number of modules = 1.
20:17:16 <DukeDave> Although this time I'm not sudo'ing anything
20:17:24 <DukeDave> So I don't know if that will bite me later
20:17:35 <elliott> DukeDave: Hope you remembered to tell cabal-install's bootstrap script to build profiling libraries
20:17:40 <elliott> ddarius: cat?
20:17:45 <ion> eyebloom: ($) :: (a → b) → (a → b); (.) :: (b → c) → (a → b) → (a → c)
20:17:53 <DukeDave> elliott: Um, if I hadn't then.. That would be okay? :|
20:17:55 <sm> good. It's really not hard to set this stuff up.. once you know your way around it
20:17:56 <ddarius> elliott: No.
20:18:20 <elliott> DukeDave: That would mean you have to trash, rebuild, and reinstall everything whenever you need to do any profiling, ever.
20:18:20 <ddarius> elliott: That would make one file with multiple modules.
20:18:25 <elliott> Which will be in approximately five minutes on average.
20:18:30 <DukeDave> elliott: Ah
20:18:34 <sm> here are some scripts I use for cabal-fixing: https://gist.github.com/1185421
20:18:39 <DukeDave> Good advice, thanks :)
20:18:41 * ddarius thinks he's used the profiler once in the last ten years.
20:18:46 <eyebloom> That's a good anwer ion, thanks
20:18:48 <elliott> DukeDave: It's just setting some environment variable to -p or something, I think.
20:19:13 <ion> eyebloom: You can type «:t foo» in ghci to get the type of foo.
20:19:18 <sm> it's not that hard to reinstall with profiling when the time comes, I don't think I'd want to build everything twice by default
20:19:32 <elliott> DukeDave: I usually also build HsColour without cabal-install in advance, and then hack the bootstrap script to run haddock with --hyperlink-source so that documentation for everything it installs with nice source links, but most people probably just read it online.
20:19:33 <DukeDave> sm: Ah nice
20:19:46 <elliott> sm: I doubt DukeDave wants to rebuild everything another time.
20:19:52 <elliott> Building everything twice really doesn't take that long.
20:20:17 <aavogt> http://www.haskell.org/pipermail/haskell/2003-July/012248.html <-- merging modules
20:20:18 <ion> Much of ($)’s usefulness comes from its very low precedence. That is, the use case of using it to get rid of annoying parentheses.
20:20:31 <DukeDave> Erm, profiling: Is the code running too slowly? No: Okay; Yes: Get a faster machine.
20:20:54 <elliott> DukeDave: You're a Ruby developer, I take it?
20:20:55 <DukeDave> Haha
20:21:04 <ddarius> elliott: Then he'd say "Get another machine" so that he could have some actual parallelism.
20:21:16 <elliott> One day, every Ruby developer on the planet will learn what big O notation is... and then, the Horror sets in.
20:21:17 <DukeDave> Right, thanks for the advice all, I have to go (and drink)
20:21:37 <elliott> Hmm... why does cabal clutter my source directory with .hi files, but /only/ the modules that are of the form A.B.C? It doesn't do it for my modules of the form A, or A.B.
20:21:44 <elliott> It just likes to clutter things that are two levels deep.
20:21:47 <eyebloom> ion: it's actually ($) :: (a -> b) -> a -> b
20:21:51 <DukeDave> Tomorrow a new day, clean and fresh
20:21:59 <ddarius> Oi vey.
20:22:06 <ddarius> Yeah, ion, what's wrong with you?
20:22:07 <ion> eyebloom: Which is the same thing without redundant parentheses.
20:22:20 <dmwit> elliott: Are you talking about cabal-install?
20:22:26 <dmwit> It doesn't do that here.
20:22:28 <elliott> dmwit: Erm, yes, sorry.
20:22:39 <elliott> Does here. 0.10.2.
20:22:39 <dmwit> Are you sure it wasn't you that did a ghc --make by accident or something like that?
20:23:03 <dmwit> rm **/*.hi && cabal build # does this really make .hi files?
20:23:15 <eyebloom> ion: seems like the first one returns another function, the other takes a function and another type and returns a third type.
20:23:44 <dmwit> eyebloom: You will reach nirvana when you realize that those two things are exactly the same.
20:23:56 <elliott> dmwit: Oh, hmm, looks like my "find" command to remove the his doesn't quite work.
20:23:57 <elliott> I wonder why?
20:23:58 <ion> Was about to say the same thing, although with the word “enlightenment”. :-P
20:24:05 <elliott> Oh, I don't know how -o works.
20:24:06 <elliott> Need some parens.
20:24:32 <ddarius> Was about to say the same thing, although with the word "Xibalba".
20:24:34 <elliott> dmwit: Right you are. Thanks for making me realise my error :)
20:24:46 <dmwit> eyebloom: ...except that your "takes a function and another type and returns a third type" suggests that you have some confusion between types and values.
20:24:53 <ion> Xibalba is like monads.
20:25:09 * ion writes a Xibalba tutorial.
20:25:13 <dmwit> elliott: Get a better shell.
20:25:38 <ddarius> Just use GHCi as your shell.
20:25:42 <eyebloom> dmwit: well I have lots of confusion with Haskell but I'm curious about how to get to nirvana?
20:25:54 <elliott> dmwit: I have a "find" instinct, anyway, even when I used zsh.
20:25:57 <dmwit> eyebloom: Here's one path to nirvana.
20:26:05 <dmwit> eyebloom: Try to say precisely what the difference is between these two definitions:
20:26:09 <dmwit> ($) f x = f x
20:26:14 <dmwit> ($) f = \x -> f x
20:26:52 <ddarius> Then the challenge question:  What is the difference between these two definitions: ($) f x = f x; ($) f = f.
20:27:16 <ion> Hint: the expression «f a b c» means «((f a) b) c».
20:27:23 <ddarius> That should find your way back from nirvana.
20:27:24 <dmwit> (In ddarius' question, the '.' should not be read as part of the Haskell code.)
20:28:36 * cmccann suggests ($) = id
20:28:57 * hackagebot ranges 0.2.4 - Ranges and various functions on them.  http://hackage.haskell.org/package/ranges-0.2.4 (GeorgePollard)
20:29:01 <dmwit> ($) = id is cute, but I think not very helpful for this particular misconception.
20:29:26 <cmccann> no, I expect it would make things worse
20:29:46 <ion> ($) :: (a → b) → a → b
20:29:52 <ion> length :: [a] → Int
20:30:06 <ion> ($) length :: [a] → Int
20:30:10 <ion> which is the same as
20:30:17 <ion> ($) length :: ([a] → Int)
20:31:23 <ion> ($) f indeed returns a function. And ($) indeed takes a function and another value and returns a third value: ($) length [0,1,2] :: Int
20:32:39 <eyebloom> The answer to darius is that the first is fully applied and the second is partial application.
20:32:51 <JoeyA> Sigh, is there anything more weakly typed than Excel/(Libre|Open)office spreadsheets?
20:33:08 <aavogt> eyebloom: can you tell them apart if you're given both in a module you can import, but not look at?
20:33:09 <JoeyA> 08:03:00 PM - 07:59:00 PM == 12:04:00 AM
20:33:12 <dmwit> eyebloom: What is so special about application that it must be full or partial?
20:33:39 <dmwit> Let your demand for qualifiers be overcome by peace, and find yourself on the way to enlightenment.
20:34:17 <dmwit> "f x" is application, whether it is part of a larger expression like "f x y" or not.
20:36:07 <aspect> JoeyA:  if that's your biggest objection to spreadsheets' "type system", you haven't been around long :-)
20:36:52 <copumpkin> JoeyA: yeah, they should have torsors!
20:36:55 <dmwit> That just looks like incorrect typing rather than weak typing to me.
20:37:17 <dmwit> Torsors are everywhere.
20:37:29 <copumpkin> that's what she said
20:37:32 <copumpkin> hmm
20:37:40 <copumpkin> that didn't work, did it
20:37:47 <dmwit> http://math.ucr.edu/home/baez/torsors.html <- where I learned about torsors
20:37:57 <copumpkin> oh yeah, that's what he said
20:38:08 <copumpkin> 'swhat I meant
20:38:16 <dmwit> Following links from Baez's page has lost me many hours.
20:42:59 <JoeyA> aspect: Can you think of an objection bigger than 1/2 automatically becoming 01/02/11 by default?
20:43:41 <aspect> how about opening a .csv file, saving it, and losing data?
20:44:06 <ion> I had fun making this spreadsheet with a couple of friends: http://www.youtube.com/watch?v=_whSnPErl7c (offtopic)
20:44:14 <eyebloom> So essentially what your saying is ($) applied to just a function (a → b) yeilds a function (a -> b) which when applied to value of type a yields a value of type b.
20:44:14 <aspect> (also "by default" -- not the case unless the cell is tagged to hold a date, afaik)
20:44:58 <JoeyA> :t ($)
20:44:59 <aspect> also a/b/y dates don't work unless it's aftr the 12th of the month, and even then should be avoided like somekind of unpleasant virus
20:45:08 <JoeyA> ($) :: (a -> b) -> a -> b
20:45:13 <ion> eyebloom: Indeed.
20:45:22 <JoeyA> Which is the same as ($) :: (a -> b) -> (a -> b)
20:45:23 <joe6> is there a haskell builtin to convert "XXY" -> "Xyy"
20:45:26 <joe6> initcase
20:45:28 <JoeyA> -> is right associative
20:45:39 <joe6> first letter upper case and the rest lower case.
20:45:51 <JoeyA> f (x:xs) = toUpper x : xs
20:46:09 <JoeyA> or maybe f (x : xs) = toUpper x : map toLower xs
20:46:13 <joe6> JoeyA, simple, thanks.
20:47:21 <ion> Don’t use Data.Char.to*. In the Unicode age one can’t do case conversion with a simple f :: Char → Char.
20:48:37 <eyebloom> So ($) is just function application right associative.
20:49:33 <ion> λ> uncurry Data.Text.append . (Data.Text.toUpper *** Data.Text.toLower) . Data.Text.splitAt 1 $ "fOoO"
20:49:36 <eyebloom> I think I read that on Hoogle but didn't fully process it. Thanks.
20:49:36 <ion> "Fooo"
20:50:07 <ion> Data.Text.toUpper and toLower handle case conversion propertly. The Data.Char equivalents don’t.
20:50:12 <ion> properly
20:50:34 <shlevy> I have a file that declares a list of objects ahead of the declaration of the objects themselves by referring to them by a uuid. How do I deal with that in Haskell?
20:51:09 <aavogt> ion: what do the Data.Char functions do wrong?
20:51:20 <shlevy> For example, it might say something like "item 1 = ( 2, 3, 4 ), item 2 = <something complicated>, item 3 = <another thing>, etc.
20:52:03 <shlevy> And after parsing I want to be able to refer to, e.g., head item 1 and get item 2, not just a 2.
20:52:45 <ion> aavogt: Examples from the documentation of Data.Text: toUpper "ß" = "SS", toLower "İ" = "i̇" = "i\775"
20:53:50 <ion> toUpper "ﬃ" = "FFI"
20:59:41 <maximus_> haskell vs c ? for speed ?
21:00:35 <ion> maximus: About 4 m/s.
21:00:48 <elliott> maximus_: African or European?
21:01:06 <maximus_> indian
21:01:11 <cmccann> hm, I thought Einstein showed that nothing can go faster than c
21:01:25 * shlevy was waiting for that last one
21:01:27 <elliott> maximus_: 9 m/q on a Sunday, with about four millilitres of precision.
21:01:33 <nyingen> maximus_: use -fvia-c
21:01:44 <elliott> nyingen: deprecated; Haskell is slow now
21:02:00 <aavogt> it's gone in ghc 7.2
21:02:07 <nyingen> :(
21:02:25 <nyingen> now how can I tell my Java-loving coworkers that haskell is as fast as C?
21:02:49 <aavogt> you can lie to them
21:03:24 <cmccann> given how long it takes Java to catch up with anything new, you can just keep telling them the same thing
21:03:58 <JoeyA> nyingen: Saying Java is slow is like saying a semi truck barreling down the highway is slow.
21:04:13 <JoeyA> What you really care about is that it's BIG.
21:04:32 <JoeyA> More specifically, it has to load up a huge runtime.
21:04:44 <nyingen> the code size is also discouraging
21:05:09 <nyingen> many java projects have reminded me of that scene in the movie Brazil where the evil government guys "fix" the protagonist's air conditioning system
21:06:08 <franny> Like a big truck, it can be the right tool for the job sometimes, usually for huge businesses.
21:06:17 <maximus_> there isnt much of optimization you can do on minimal runtime engine , cant support a multithreading run-time in 300MHz processor
21:06:22 <shlevy> If I know a uuid I'm parsing can only have 96 bits, should I represent it as an integer limited to 96 bits or just a general integer?
21:06:47 <franny> As opposed to Java applets/desktop apps, which in this metaphor are Hummer H2s.
21:27:00 <RayNbow`TU> Commodus: pumpkin season is over?
21:27:05 <Commodus> yep
21:32:06 <ddarius> He's preparing for his annual hiding.  It's almost -that- time of year again.
21:43:42 <kmc> time to rebuild all the highlighting-kate syntax definitions with profiling enabled !!
21:46:10 <lewis1711> this is a seriously weird question - is there anyway to get nicely formatted strings that are pure strings? appearing on multiple lines in the interpreter, for example
21:46:45 <RayNbow`TU> lewis1711: you want to print strings to the terminal?
21:47:30 <kmc> i have no idea what you mean lewis1711 :)
21:47:36 <JoeyA> Pretty-print strings
21:47:44 <kmc> how pretty do you want them
21:47:55 <JoeyA> As opposed to lines and lines of "\220\220...
21:48:15 <kmc> is this an issue of putStr vs print ?
21:48:18 <kmc> or something more
21:48:24 <JoeyA> I don't know, ask lewis1711.
21:48:29 <kmc> i am (implicitly)
21:49:37 <kmc> in GHCi, «putStr "\n\n"» will give you two blank lines
21:49:38 <lewis1711> I will post the question - honestly it seems rather stupid to me, but what do I know
21:49:51 <kmc> and «putStrLn "\n\n"» three :)
21:50:21 <lewis1711> "Define the function "display :: Ranks -> String" that takes the list of names, marks, and final rankings and returns a single that will display the list in a readable format"
21:50:39 <lewis1711> I guess this isn't really a haskell question, more abiguous homework question quesiton. I apologise
21:50:56 <kmc> i would use http://hackage.haskell.org/package/groom but that's probably not what your instructor wants
21:50:58 <ddarius> GHCi applies show to the results of expressions.
21:53:58 <kmc> 'groom' is useful.  its approach to generic programming in Haskell is... amusing
21:54:10 <kosmikus> aavogt: (lhs2tex) which lhs2tex version, which ghc version? have you reported the bug?
21:54:12 <kmc> i wonder if that approach could be generalized
21:54:23 <kmc> forget deriving Generic, forget deriving Data.  just derive Show.
21:54:42 <copumpkin> so I want to do complicated things with types
21:54:49 <copumpkin> they are very complicated
21:54:50 <aavogt> kosmikus: that file wouldn't be a valid latex file if the offending characters were passed through anyways
21:55:02 <kmc> copumpkin, use agda
21:55:08 <ddarius> kmc: All of the "generics" libraries just implicitly or explicitly reify the structure of the type.  Groom just does so in a particularly inelegant manner.
21:55:11 <copumpkin> nah, it can't do them
21:55:16 <copumpkin> trying to figure out if haskell can
21:55:30 <ddarius> @faq no lambdabot
21:55:31 <lambdabot> The answer is: Yes! Haskell can do that.
21:55:32 <copumpkin> this really isn't an important issue but it's bigging me
21:55:35 <copumpkin> bugging, even
21:55:40 <aavogt> I think ipprint is more useful than groom
21:55:56 <kmc> indeed
21:56:04 <kmc> (ddarius)
21:57:17 <kmc> of course to claims that 'groom' is inelegant i'll respond that it's manifestly useful and only 9 SLoC
21:57:46 <aavogt> you're not counting code in hsx
21:57:58 <kmc> sure
21:58:03 <kmc> i'm not counting code in ghc or base either
21:58:50 <kmc> i'm just saying that "deriving (Show)" + haskell-src-exts is a better generics library for this task than "deriving (Data)" + syb
21:59:13 <ddarius> kmc: Doing more generic programming would make it larger than 9 SLOC and would expose more of the inelegance and inefficiency.
21:59:15 <kmc> the cheatingest part is probably that the pretty-printer is built into hsx
21:59:19 <kmc> *nod*
21:59:21 <ddarius> Also, SYB is pretty fucking horrible too.
21:59:26 <kmc> indeed
21:59:33 <kosmikus> aavogt: still sounds like a bug to me. please provide more info :)
21:59:35 <kmc> ddarius, what's your favorite approach to generic programming in Haskell?
22:00:08 <ddarius> kmc: I haven't really looked at Compos but I lean strongly toward Uniplate (and presumably roconnor's Multiplate.)
22:01:54 <aavogt> kosmikus: lhs2TeX 1.17, ghc 7.0.2  (though this should happen with any >= 6.12 because that's when decoding happens by default with hGetContents)
22:02:33 <kosmikus> aavogt: I guess I need the input file, as I'm using this combination regularly without any problems.
22:02:36 <aavogt> kosmikus:  cabal unpack harpy-0.4.3.0; cd harpy*/doc; make
22:02:49 <kosmikus> ok
22:03:10 <copumpkin> this problem is making me want subtyping
22:03:17 <copumpkin> I think it's the first time it's happened
22:03:20 <aavogt> the problem character is the ü
22:04:38 <kosmikus> aavogt: that file is iso-8859-1 encoded
22:04:47 <kosmikus> aavogt: lhs2tex only supports utf-8, I'm afraid
22:06:19 <kmc> Character Encodings: Ruining your day since 1844
22:06:46 <aavogt> kosmikus: in pre ghc-6.12 days it must have worked
22:07:05 <kosmikus> aavogt: it probably did. but in those days, utf-8 wouldn't have worked
22:08:15 <aavogt> it must be possible to avoid decoding the comments / latex part
22:09:04 <kosmikus> aavogt: patches welcome :)
22:09:06 <aavogt> after all the \begin{code} or > are the same in the two encodings we've mentioned
22:09:32 <kosmikus> aavogt: I'm afraid supporting legacy encodings is not of a high priority
22:10:21 <kosmikus> aavogt: but I agree with you. I'd certainly accept a patch that fixes this.
22:11:58 <kosmikus> aavogt: as a workaround, you can probably just recode the file to utf-8 before running lhs2tex
22:12:37 <argiopeweb> The article posted this week and last week found at http://amtal.github.com/2011/08/25/why-haskell-is-kinda-cool.html describes a NetIO monad which restricts IO actions to a subset (connect, send, and recv) and claims its implementation is trivial. This seems like an obvious monad transformer problem, but it is not represented as such. Am I missing something major, or is this not as trivial as it's made out?
22:13:19 <kmc> well you generally can't make monad transformers out of IO
22:13:52 <kmc> e.g. IO transformer applied to the list monad would basically want to backtrack and undo IO
22:14:21 <kmc> you could represent restrictions on IO in a compositional way at type level
22:14:25 <kmc> and that would be very cool
22:14:29 <kmc> but wouldn't be monad transformers per se
22:14:57 <argiopeweb> kmc: Let's assume everything I say is inane noob babble and address the code as it's presented on the site.
22:15:21 <argiopeweb> Because that's where my intellectual roadblock is occuring.
22:15:30 <kmc> ok
22:15:34 <kmc> well i didn't read the article, but go on
22:16:58 <c_wraith> argiopeweb: it's not a transformer because transformers explicitly allow you to do anything the "inner" layer allows.  That code is about only allowing a subset.
22:17:24 <argiopeweb> It simply doesn't make sense to me that you can have a function performing IO and returning something not in the IO monad. Example function signature for send as given is "send :: Socket -> String -> NetIO Int". It seems like the process of doing IO (calling Network.Socket.send) in the site's version of send would inevitably trap you in the IO monad, barring use of unsafePerformIO (which would be wrong/broken if used in this particular way, anyway).
22:17:29 * kmc . o O ( implicit configurations for sandboxing IO by path? )
22:17:36 <kmc> argiopeweb, functions don't perform IO, period
22:17:39 <shachaf> argiopeweb: Functions don't "perform IO".
22:17:43 <kmc> regardless of what they return
22:17:45 <argiopeweb> Valid point.
22:17:46 <shachaf> They can return a description for IO to be done.
22:17:56 <kmc> and they can return that description baked inside some data structure
22:18:05 <shachaf> foo :: String can be viewed as a "description of IO to be done", where the IO is to print the string.
22:18:33 <shachaf> Similarly you can make your own type which has whatever primitives you want, and write an "RTS" that interprets it into actual IO actions (for instance).
22:18:39 <kmc> argiopeweb, you have something like newtype NetIO a = WrapNet (IO a)
22:18:56 <kmc> and then runNetIO :: NetIO a -> IO a; runNetIO (WrapNet action) = action
22:19:09 <kmc> and the only force of the restriction is that you export some things from this module but don't export WrapNet
22:19:24 <kosmikus> yes, this is all the article says. that you can "wrap" IO and thereby restrict it.
22:19:27 <shachaf> What kmc says is a simple way to do that. :-)
22:19:35 <shlevy> What should I put for "Stability" in a new module header that will change drastically?
22:19:53 <shachaf> Compositional restrictions on IO would be interesting. Has anyone done that?
22:20:02 <dmwit> shlevy: unstable
22:20:09 <kosmikus> shachaf: experimental or unstable ?
22:20:23 <shachaf> kosmikus: shlevy?
22:20:30 <kosmikus> sorry, yes
22:20:43 <shlevy> dmwit: Thanks. Is there documentation on the expected values for this kind of documentation?
22:21:04 <dmwit> don't think oss
22:21:09 <dmwit> s/oss/so/
22:21:09 <argiopeweb> So it's simply a matter of wrapping IO and supplying a restricted set of functions to operate on the wrapped type.
22:21:14 <kmc> yeah
22:21:20 <dmwit> You can browse Hackage and see what other modules do.
22:21:22 <kmc> that's one way to implement a "restricted IO monad"
22:21:33 <kmc> like shachaf said, you can define *any* data type and a way to translate it into IO actions
22:21:45 <ddarius> shachaf: Yes.
22:21:55 <kmc> runNetIO is a trivial example of such a translation
22:21:58 <shlevy> dmwit: Ok, thanks
22:22:07 <argiopeweb> Seems entirely more reasonable than what I thought I read.
22:22:12 <shachaf> @more ddarius
22:22:15 <kmc> :)
22:22:32 <kmc> the key is just that IO actions are first-class values
22:22:34 <ddarius> @hackage IOSpec
22:22:35 <lambdabot> http://hackage.haskell.org/package/IOSpec
22:22:39 <argiopeweb> Entirely possible that I just shouldn't try and think about programming at 0200 too.. ;)
22:22:52 <ion> @vixen Welcome back, lambdabot.
22:22:53 <lambdabot> cool
22:23:00 <kmc> it's common to think of IO as a way of tagging "impure functions", but it's ultimately incorrect
22:23:44 <c_wraith> that crashes rather spectacularly when you run into types like Int -> IO a -> IO (Maybe a)
22:23:56 <c_wraith> ohno!  IO is in it twice!  what does this mean?
22:24:05 <kmc> double IO all the way
22:24:11 <shachaf> c_wraith: Well, it means that it gets an "impure function" of zero arguments. :-)
22:24:17 <ddarius> unsafePerformIO = join
22:24:21 <shachaf> Because everything is a function.
22:24:39 <ion> @tell joe6 In case you missed this: Data.Char.toUpper and toLower are bad, Data.Text.toUpper and toLower are good (see the documentation for them). import qualified Data.Text as T; f :: T.Text -> T.Text; f = uncurry T.append . (T.toUpper *** T.toLower) . T.splitAt 1
22:24:40 <lambdabot> Consider it noted.
22:24:41 <c_wraith> yes.  unsafePerformIO does have the same type signature as join
22:24:58 <shachaf> s/does/can/
22:25:03 <kmc> data Nom r a = Moar (a -> IO (Nom r a)) | Kthx r
22:25:16 <copumpkin> :t fmap unsafePerformIO
22:25:16 <lambdabot> Not in scope: `unsafePerformIO'
22:25:30 <c_wraith> I consider anything with a polymorphic type to have all types it *could* have.  This is not a wise viewpoint, but I hold it anyway. :)
22:25:34 <kmc> you know what else has the same type signature as join? unsafeCoerce
22:25:44 <ion> Hah
22:25:44 <shachaf> And undefined.
22:25:46 <copumpkin> kmc: good point
22:25:48 <c_wraith> unsafeCoerce has the same type as most things
22:25:57 <copumpkin> undefined has the same type as all things
22:25:57 <c_wraith> it does not have the same type as 5, though
22:26:11 <shachaf> > 5 3
22:26:11 <lambdabot>   5
22:26:13 <kmc> (unsafeCoerce unsafeCoerce) has the same type as 5, though
22:26:35 <shachaf> fix unsafeCoerce
22:26:38 <kmc> Hoogle often gives unsafeCoerce as a kind of comedy answer
22:26:42 <c_wraith> why, is it broken?
22:26:51 <ion> «<benmachine> unsafeCoerce is just a generalisation of id». undefined is just a generalization of unsafeCoerce.
22:28:15 <c_wraith> > undefined `asTypeOf` 5
22:28:16 <lambdabot>   *Exception: Prelude.undefined
22:28:22 <c_wraith> :t undefined `asTypeOf` 5
22:28:23 <lambdabot> forall a. (Num a) => a
22:28:57 <mauke> :t const `asTypeOf` undefined
22:28:58 <lambdabot> forall a b. a -> b -> a
22:29:16 <kmc> @check \x -> (x `asTypeOf` undefined) == x
22:29:17 <lambdabot>   "OK, passed 500 tests."
22:29:32 <mauke> @check x `asTypeOf` undefined
22:29:32 <lambdabot>   No instance for (Test.QuickCheck.Testable SimpleReflect.Expr)
22:29:33 <lambdabot>    arising fr...
22:29:36 <mauke> @check \x -> x `asTypeOf` undefined
22:29:37 <lambdabot>   "Arguments exhausted after 0 tests."
22:29:41 <c_wraith> haha
22:29:52 <c_wraith> I haven't seen that message before
22:29:55 <ion> :t undefined `asAppliedTo` putStrLn
22:29:56 <lambdabot> forall b. (String -> IO ()) -> b
22:30:17 <kmc> :t asAppliedTo `asAppliedTo` asAppliedTo
22:30:17 <lambdabot> forall t b. ((t -> b) -> t -> t -> b) -> (t -> b) -> (t -> b) -> t -> t -> b
22:30:22 <ion> haha
22:30:25 <kmc> :t asAppliedTo `asAppliedTo` (asAppliedTo `asAppliedTo` asAppliedTo)
22:30:26 <lambdabot> forall t b. (((t -> b) -> t -> t -> b) -> (t -> b) -> (t -> b) -> t -> t -> b) -> ((t -> b) -> t -> t -> b) -> ((t -> b) -> t -> t -> b) -> (t -> b) -> (t -> b) -> t -> t -> b
22:30:50 <kmc> @. djinn type asAppliedTo `asAppliedTo` (asAppliedTo `asAppliedTo` asAppliedTo)
22:30:51 <lambdabot> f a b c d e f g =
22:30:51 <lambdabot>     a (\ h _ _ -> h g) (\ _ ->
22:30:51 <lambdabot>                         b (b (\ _ -> c (c (\ _ -> d f) g) g g) g) g g) (\ _ -> e f) g g
22:31:02 <ion> @@ @djinn @type asAppliedTo
22:31:03 <lambdabot>  f a b _ = a b
22:31:15 <ion> @@ @type @djinn @type asAppliedTo
22:31:17 <lambdabot>  parse error on input `='
22:31:32 <ion> @@ @type @pl @djinn @type asAppliedTo
22:31:34 <lambdabot>  parse error on input `='
22:31:49 <c_wraith> pl still outputs that with an =
22:31:56 <ion> yeah :-\
22:32:07 <shachaf> Not if you use a lambda.
22:32:15 * ddarius will not tell ion that @run is a command.
22:32:20 <c_wraith> djinn apparently doesn't like lambda
22:32:20 <shachaf> lambdabot needs a lambdify command.
22:32:24 <shachaf> I guess @run would do.
22:33:42 <ion> Anyway, (\a b _ → a b) :: (t2 -> t1) -> t2 -> t -> t1, since that definition doesn’t use the third parameter to restrict the type.
22:33:44 <ddarius> @@ @type @run drop 3 @pl @djinn @type asAppliedTo
22:33:46 <lambdabot>  parse error on input `<'
22:34:02 <ddarius> @@ @type @run (drop 3) @pl @djinn @type asAppliedTo
22:34:04 <lambdabot>  parse error on input `<'
22:34:17 <ddarius> @@ @run (drop 3) @pl @djinn @type asAppliedTo
22:34:18 <lambdabot>   <no location info>: parse error on input `='
22:35:06 <shachaf> @@ @type @run drop 3 @show @pl @djinn @type asAppliedTo
22:35:08 <lambdabot>  [Char]
22:35:32 <shachaf> @@ @type @read @run drop 3 @show @pl @djinn @type asAppliedTo
22:35:34 <lambdabot>  forall a b (f :: * -> *). (Functor f) => f a -> f (b -> a)
22:35:43 <shachaf> Success!
22:35:46 <shachaf> I think.
22:35:55 <kmc> what the fuck
22:36:15 <ion> @@ @type @read @run drop 3 @show @pl @djinn @type ($)
22:36:17 <lambdabot>  forall a. a -> a
22:36:30 <kmc> i leave for 3 seconds and you're all metaprogramming and shit
22:36:47 <shachaf> ddarius started it!
22:36:49 <ion> Metaprogramming with string manipulation ftw.
22:36:56 <kmc> ion, there are other kinds?
22:36:58 <kmc> :D
22:37:07 <ddarius> If it's good enough for Tcl, it's good enough for you.
22:37:30 <kmc> though i've also met people who understand the term "metaprogramming" to be synonymous with "C++ template metaprogramming"
22:37:37 <c_wraith> @remember kmc i leave for 3 seconds and you're all metaprogramming and shit
22:37:37 <lambdabot> Done.
22:39:16 <kmc> @. run run text $ map pred "gjy))1;*/tdbom),*2*"
22:39:18 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:39:31 <kmc> @quote _pizza_
22:39:31 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
22:39:39 <ddarius> Only Gray would put a commutative diagram in a parenthetical comment.
22:39:58 <kmc> i want a webcomic where the characters speak only in commutative diagrams
22:40:44 <luite> copy xkcd but replace all dialogs and see if it gets funnier
22:41:23 <ddarius> luite: You wouldn't be able to tell the difference between the dialog and the characters.
22:41:46 <kfish> like goatkcd, but with more natural transformations
22:41:47 <luite> would that make it worse, or better?
22:41:59 <kmc> maybe one characters speaks in commutative diagrams and the other in feynman diagrams
22:42:23 <ddarius> kmc: There isn't necessarily a difference.
22:42:30 <kmc> see the essential conflict that drives the storyline is that one of them is an abstract algebraist and the other a physicist who prefers more concrete forms of algebra, i.e. group theory
22:42:33 <kmc> and they fight over this
22:42:44 <kmc> oh yeah ddarius?
22:43:09 <ddarius> @google "feynman diagram" "higher category theory"
22:43:10 <lambdabot> http://golem.ph.utexas.edu/category/2010/05/the_quantum_whisky_club.html
22:43:10 <lambdabot> Title: The Quantum Whisky Club | The n-Category Café
22:46:23 <ddarius> @google "feynman diagram as string diagram" "category theory"
22:46:23 <lambdabot> No Result Found.
22:46:30 <ddarius> @google "feynman diagram" "string diagram" "category theory"
22:46:32 <lambdabot> http://reperiendi.wordpress.com/category/math/category-theory/
22:46:32 <lambdabot> Title: Category theory « reperiendi
22:48:59 <kmc> @. run run interpret [102,105,120,40,40,48,58,41,46,115,99,97,110,108,40,43,41,49,41]
22:49:02 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:50:04 <kmc> so Church, Curry, and Gödel walk into a bar...
23:06:27 <lewis1711> how can i get the third element from a three element tuple? :/
23:06:43 <ion> \(_,_,a) -> a
23:07:43 <lewis1711> that's handy, didn't know you could do that with lambdas. thanks
23:08:35 <kmc> yeah, you can use arbitrary patterns with lambdas
23:08:41 <kmc> only one pattern though
23:08:55 <kmc> if you want alternatives you have to do something like (\x -> case x of ...)
23:09:47 <ion> Pointless ‘case’ would be useful here, too: (case of 0 -> …; x -> …) 42
23:11:39 <laar> join #leksah
23:12:12 <laar> sry, and hello
23:12:50 * bz_ thought is was an instruction
23:13:21 <bz_> *it
23:14:24 <kmc> ion, I learned recently that a syntax for lambda-case has been implemented for GHC, and is attached as a patchfile to a GHC Trac ticket
23:14:30 <kmc> but not yet merged afaik
23:14:37 <kmc> i don't remember the exact syntax they settled on
23:14:40 <ion> Ok, cool.
23:15:03 <kmc> i only skimmed the thread but it looked like there was a lot of discussion of subtle syntactic interactions
23:15:27 <kmc> i'm glad that people actually think these things through
23:17:18 <ion> http://hackage.haskell.org/trac/ghc/attachment/ticket/4359/multi-clause-lambdas-testsuite.patch
23:42:37 * hackagebot regular 0.3.3 - Generic programming library for regular datatypes.  http://hackage.haskell.org/package/regular-0.3.3 (JosePedroMagalhaes)
23:45:52 <RayNbow`TU> @check sortBy (\x y -> if x+1==y then LT else GT) xs == sort (xs :: [Int])
23:45:53 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
23:45:59 <RayNbow`TU> @check \xs -> sortBy (\x y -> if x+1==y then LT else GT) xs == sort (xs :: [Int])
23:46:00 <lambdabot>   "Falsifiable, after 15 tests:\n[2,0,3,5]\n"
