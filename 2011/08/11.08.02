00:20:43 <ArnoVanLumig> if I use timeout (from System.Timeout) to time out on a STM transaction, will that transaction actually be aborted and garbage collected?
00:21:09 <ArnoVanLumig> for instance: timeout (10*10^6) $ atomically $ readTChan someChan
00:47:36 <Lemon> http://research.microsoft.com/en-us/um/people/daan/download/papers/hml-tr.pdf
00:47:42 <Lemon> (yes, I am kniu)
00:47:52 <Lemon> (yes, I'm still reading that)
00:48:31 <Lemon> in Figure 5, the normal-form transformation is defined
00:49:19 <Lemon> the fourth case depends on "iff nf(phi_2) = alpha"
00:49:42 <Lemon> what equals is that?
00:50:05 <Lemon> is it the type equivalence defined in figure 3?
00:50:25 <Lemon> if so, why isn't it written with the type equivalence symbol?
00:54:29 <Kaidelong> does (Foldable t, Monoid t) => Monad t?
00:55:04 <Saizan> kind error
00:55:43 <Kaidelong> ah right
00:55:46 <Kaidelong> it'd have to be
00:56:18 <Kaidelong> (Foldable t, forall a. Monoid (t a)) => Monad t
00:56:26 <Kaidelong> not that you can write that type in Haskell
00:56:58 <Kaidelong> but I was wondering if that kind of general property holds
01:00:38 <quicksilver> Kaidelong: it gives you join, but does it give you return?
01:00:43 <Saizan> >not sure
01:03:11 <Kaidelong> Well I'm hard pressed to think why it wouldn't
01:03:19 <Kaidelong> but I guess no, return is not guaranteed
01:04:50 <Saizan> fmap (const x) mempty ?
01:05:29 <Kaidelong> @ty flip fmap mempty . const
01:05:30 <lambdabot> forall a b (f :: * -> *). (Functor f, Monoid (f a)) => b -> f b
01:05:44 <Kaidelong> nice
01:06:20 <Kaidelong> but
01:06:34 <Kaidelong> > flip fmap mempty . const $ 5 :: [Int]
01:06:36 <lambdabot>   []
01:06:41 <Kaidelong> which is not return
01:07:56 <Saizan> yeah, hard to make that a return of any monad
01:08:10 <quicksilver> yes, you're not going to get anywhere with mempty IMO
01:08:19 <quicksilver> you need some consistent way to get a 'singleton'
01:08:50 <quicksilver> it's got to be a half-inverse of join, obviously.
01:09:23 <quicksilver> see the remarks about filter and concatMap at http://www.haskell.org/haskellwiki/Foldable_and_Traversable
01:09:41 <quicksilver> I decided then that you needed Applicative as well as Monoid
01:09:46 <quicksilver> or at least, I couldn't see a way to do better
01:26:47 <Johannes`> hi, why is this: http://codepad.org/3BVHx6Yb
01:27:18 <merijn> Johannes`: You cannot have if statements without an else
01:27:29 <Johannes`> why not?
01:27:49 <burbul> @type id *** id
01:27:50 <lambdabot> forall b b'. (b, b') -> (b, b')
01:27:50 <NihilistDandy> Because that's how it is~
01:27:59 <Johannes`> i'm still in the imperative un-wiring stage
01:28:07 <Kaidelong> Johannes`: What's the type of "if False then 5"
01:28:12 <merijn> Johannes`: Because they're expressions taking one argument and returning either the if or the else result
01:28:15 <eikke> Johannes`: what would the 'value' of the if-statement be if the if-condition is false?
01:28:36 <merijn> Johannes`: If the if was type Int and the else was absent, what would the type of the resulting expression be?
01:29:05 <Kaidelong> anyway compare C's ? : operator
01:29:12 <Kaidelong> you can't use the ? without the :
01:29:20 <Kaidelong> if .. then .. else is exactly the same
01:29:36 <Johannes`> ah
01:29:51 <merijn> "if b then 5 else 6" is type Int, regardless of the value of b, but what'd "if b then 5", that can't be Int since if b is False what'd you do
01:30:07 <Kaidelong> which is because if .. then .. else is an expression, rather than statements
01:30:19 <Kaidelong> just like .. ? .. : .. is an expression
01:30:20 <merijn> Also, yes. It is exactly the same as "? :" (since that is also an expression and not a statement)
01:30:41 <Johannes`> in my procedural brain, if is  used to do an action conditionally
01:30:54 <Kaidelong> use "when" for that
01:30:55 <Kaidelong> @ty when
01:30:56 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
01:30:59 <Johannes`> aha
01:31:01 <Johannes`> thanks
01:31:25 <aninhumer> heh guess a lot of people started writing replies and then posted them anyway when they were beaten...
01:32:00 <merijn> Johannes`: I you have an IO action (like putStrLn) and you want to optionally do nothing you could do "if b then putStrLn "yes!" else return ()" although there are more convenient ways of writing the same thing (such as "when")
01:32:20 <Kaidelong> @src when
01:32:20 <lambdabot> when p s = if p then s else return ()
01:32:31 <merijn> Damn, today is typo day for me I see
01:33:17 <Kaidelong> @src guard
01:33:17 <lambdabot> guard True  =  return ()
01:33:17 <lambdabot> guard False =  mzero
01:33:56 <Kaidelong> @hoogle (MonadPlus m) => Bool -> a -> m a
01:33:56 <lambdabot> Control.Exception assert :: Bool -> a -> a
01:33:56 <lambdabot> Control.OldException assert :: Bool -> a -> a
01:33:56 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
01:34:08 <merijn> aninhumer: Just following #haskell tradition ;)
01:34:11 <Kaidelong> funny that that one is missing
01:34:14 <merijn> @quote glorious.stereo
01:34:14 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
01:34:42 <aninhumer> quadraphonic methinks
01:35:07 <mauke> @quote .fugue
01:35:07 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
01:35:10 <companion_cube> yay
01:35:30 <sipa> @quote questions.are.answered
01:35:31 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
01:36:01 <merijn> @quote invariably.involving
01:36:01 <lambdabot> geheimdienst says: #haskell has the type a -> m b. you feed in some problem, and out comes a solution invariably involving monads
01:36:06 <Kaidelong> > do {nat <- [1..]; if odd nat then return nat else mzero}
01:36:07 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
01:36:44 <mauke> > do {nat <- [1..]; guard (odd nat); return nat}
01:36:44 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
01:37:03 <mauke> I am a list comprehension
01:37:03 <sipa> @djinn a -> m b
01:37:03 <lambdabot> -- f cannot be realized.
01:37:15 <sipa> yeah right!
01:37:49 <Kaidelong> sipa: well feed @djinn your assumptions!
01:38:08 <Kaidelong> @djinn (a -> m a) -> (a -> b) -> a -> m b
01:38:08 <lambdabot> -- f cannot be realized.
01:38:25 <Kaidelong> @djinn (a -> m a) -> (a -> b) -> (m a -> (a -> b) -> m b) -> a -> m b
01:38:26 <lambdabot> f a b c d = c (a d) (\ _ -> b d)
01:40:40 <NihilistDandy> I wish GOA still worked :|
01:40:54 <merijn> Nothing makes me appreciate Haskell as much as debugging race conditions in multithreaded C code :\
01:41:19 <shachaf> merijn: Is that a challenge?
01:41:21 <MaskRay> How can I set the maximal running time of runInterpreter in Language.Haskell.Interpreter?
01:41:54 * shachaf >>= undefined
01:42:14 <Kaidelong> well depending on the type of runInterpreter you might be able to simple race it with an IO action that just sleeps and returns
01:42:25 <Kaidelong> @hoogle race
01:42:25 <lambdabot> Text.Parsec.Token braces :: GenTokenParser s u m -> ParsecT s u m a -> ParsecT s u m a
01:42:25 <lambdabot> Text.PrettyPrint.HughesPJ braces :: Doc -> Doc
01:42:25 <lambdabot> Language.Haskell.TH.PprLib braces :: Doc -> Doc
01:42:26 <sipa> NihilistDandy: GOA?
01:42:32 <Kaidelong> huh
01:42:46 <Kaidelong> well I think race is in the unamb package
01:42:54 <NihilistDandy> sipa: GHCi On Acid. GHCi with all the nice lambdabot stuff
01:43:19 <Kaidelong> @hoogle sleep
01:43:19 <lambdabot> No results found
01:43:26 <NihilistDandy> SLEEP? ARE YOU CRAZY? LETS GET UP FOR MIDNIGHT DINNER
01:43:36 <NihilistDandy>  /esoteric
01:43:45 <merijn> NihilistDandy: GOA sounds awesome
01:43:56 <NihilistDandy> merijn: It was, apparently
01:44:10 <NihilistDandy> But it broke after a lambdabot update and nobody fixed it, I guess
01:44:53 <NihilistDandy> http://www.haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
01:45:01 <merijn> shachaf: Not really, it could be worse. But not a whole lot I guess >.>
01:45:48 <gienah> GOA works from here: git://github.com/chrisdone/goa.git
01:45:50 <NihilistDandy> Oh, wait
01:45:58 <NihilistDandy> There was an update :D
01:46:00 <NihilistDandy> Yay!
01:46:08 <NihilistDandy> It's even on hackage
01:46:32 <NihilistDandy> 3 years hiatus, but back in business
01:47:38 <NihilistDandy> I practically never have to leave ghci, now :D
01:50:19 <Baughn> @tell ivanm I know of no reason why it wouldn't be
01:50:19 <lambdabot> Consider it noted.
01:52:28 <adxp`> hi - I'm getting a linker error when trying to use the FFI to call a function that's prefixed with an underscore, but not for standard (non-underscore-prefixed) functions. the code is just a standard "foreign import ccall unsafe" declaration. is there any chance ghc has a bug linking with functions that start with an underscore, or am I doing something stupid?
01:55:17 <mauke> what's the import line, what's the command, what's the error?
01:56:16 <adxp`> will get a paste together
01:56:20 <NihilistDandy> Preferably in a pastebin of one sort or another
01:56:27 <NihilistDandy> Yay :)
01:59:06 <hpaste> adxp pasted “linker woes” at http://hpaste.org/49758
01:59:44 <mauke> what's the command?
02:00:45 <hpaste> adxp annotated “linker woes” with “linker woes (annotation)” at http://hpaste.org/49758#a49759
02:01:55 * NihilistDandy is super-excited about GOA :D
02:04:09 <totimkopf1> :)
02:04:30 <totimkopf1> NihilistDandy: what kind of machine do you do your Haskelling on?
02:04:50 <NihilistDandy> totimkopf1: 07 Macbook
02:05:02 <totimkopf1> nice
02:05:04 <merijn> The only way to Haskell :>
02:05:21 <totimkopf1> the only way to Haskell is on a 07 macbook? :p
02:05:26 <NihilistDandy> Though she is not in good shape. I may need to replace in the near future
02:05:34 <merijn> Well a MacBook or OSX anyway :p
02:05:36 <NihilistDandy> Hopefully I can pull the money together
02:05:41 <NihilistDandy> merijn: Agreed :D
02:05:46 * Saizan strongly disagrees
02:05:56 <totimkopf1> Saizan: what machine do you haskell on?
02:06:01 <NihilistDandy> Well, Linux is fine, too
02:06:08 <merijn> Well, alternatively a whiteboard is fine too :>
02:06:32 <Saizan> for quite a while windows had better ghc support than OS X, not sure now
02:07:00 <NihilistDandy> OS X/Linux > Whiteboard > Windows
02:07:20 <Saizan> totimkopf1: Linux nephthys 2.6.39-ARCH #1 SMP PREEMPT Sat Jul 9 14:57:41 CEST 2011 x86_64 Intel(R) Core(TM) i3 CPU M 370 @ 2.40GHz GenuineIntel GNU/Linux
02:07:23 <NihilistDandy> I dunno, I haven't hit any problems on any of them, so I can't really say with any certainty
02:07:24 <ion> All the cool guys use 680x0-based computers for Haskelling.
02:07:37 <merijn> They should just add posix support windows and a proper shell and I'd be happy >.>
02:07:48 <merijn> s/support/support to/
02:07:51 <ion> Linux hapatus 3.0.0-7-generic-pae #8-Ubuntu SMP Fri Jul 22 22:23:05 UTC 2011 i686 athlon i386 GNU/Linux
02:08:03 <totimkopf1> Saizan: sweet I just ordered an i3, how does she fair with all your programming projects? :)
02:08:22 <ion> Hmm. Why does uname say “GNU”?
02:08:45 <ion> Ah, it’s specifically an “operating system” field, not just kernel.
02:09:24 <adxp`> hm, nobody told OS X that: uname -s = Darwin
02:09:39 <Saizan> totimkopf1: as nice as my 3Ghz core 2 duo, but way colder :)
02:09:39 <ion> adxp: uname -o?
02:09:49 <adxp`> ion: illegal option :)
02:09:50 <merijn> illegal option :p
02:10:03 <mauke> -s is the kernel name
02:10:05 <ion> Well, of course GNU has an uname extension for saying “GNU”. ;-)
02:10:15 <NihilistDandy> Darwin Dirizhabl.local 10.8.0 Darwin Kernel Version 10.8.0: Tue Jun  7 16:33:36 PDT 2011; root:xnu-1504.15.3~1/RELEASE_I386 i386
02:10:52 <adxp`> mauke: my travails make any sense to you, or should I just poke around more?
02:10:53 <NihilistDandy> As long as we're uname'ing to channel
02:10:54 <totimkopf1> Saizan: I've noticed that core 2 duos and i3s are about the same price when i3s are supposed to be a fairly better technology?
02:11:05 * totimkopf1 shrugs
02:11:58 <mauke> adxp`: I don't know
02:12:36 <adxp`> mauke: ok, well, thanks v much for looking. is haskell-cafe the best next step?
02:17:07 <ivanm> OK, I keep getting these kind of errors at link time: (.data+0x130): undefined reference to `planarzmgraphzm0zi0zi0zi0_DataziGraphziPlanarziSerialisationziInternal_renumberNodes_closure'
02:17:16 <ivanm> what can I do to fix this?
02:18:03 <NihilistDandy> ivanm: Your linker has a speech impedimentzi?
02:18:03 <Botje> are you using ghc --make?
02:18:06 <Botje> that usually fixes it
02:18:16 <ivanm> Botje: using cabal build actually ;-)
02:18:30 <ceii__> this looks like the kind of things that happen when something should have been recompiled but hasn't
02:18:30 <Botje> ah
02:18:34 <mauke> preflex: zdec planarzmgraphzm0zi0zi0zi0_DataziGraphziPlanarziSerialisationziInternal_renumberNodes_closure
02:18:34 <preflex>  planar-graph-0.0.0.0_Data.Graph.Planar.Serialisation.Internal_renumberNodes_closure
02:18:59 <ceii__> is planar-graph the package you're building, or a dependency?
02:19:00 <NihilistDandy> What id you cabal clean then cabal build?
02:19:04 <Botje> what a nice symbol name. wonder if it'll be friends with me.
02:19:08 <NihilistDandy> *if
02:19:08 <ivanm> done that
02:19:12 <ivanm> ceii__: a dep
02:19:57 <ceii__> then I'd look into the "cabal butterfly dependency problem"
02:20:13 <ceii__> though I thought you got better error messages there
02:20:49 <Saizan> ivanm: is planar-graph using TH?
02:20:55 <ivanm> nope
02:21:42 <ceii__> also, stupid ideas first: did you try reinstalling planar-graph?
02:21:49 <ivanm> OK, for some reason it isn't built properly or something; it isn't even been working in ghci
02:21:52 <ivanm> ceii__: yeah, I had...
02:26:25 <ivanm> OK, so if I load planar-graph directly into ghci, it works
02:26:46 <ivanm> but as soon as I "cabal install" it (after a "cabal clean") then try to load it in ghci it fails...
02:27:20 <Saizan> what if you run ghci outside the source tree?
02:27:41 <ivanm> that's what I did
02:27:44 <ivanm> oh, wait, I think I know why...
02:28:17 <ivanm> I removed the other-moduels line from planar-graph's .cabal file for something and forgot to add it back in...
02:28:25 <Saizan> heh
02:28:40 <eddayyy> anyone from the Snap world here?
02:28:49 <eddayyy> who is ominously 'in the know' ?
02:29:33 <merijn> How can one be "ominously" in the know?
02:29:55 <ehamberg> eddayyy: #snapframework
02:31:12 <eddayyy> merijn: what do you mean? such a state of being is common
02:34:25 <merijn> What? Being "in the know" in a way that gives the impression of something unpleasant is going to happen?
02:34:51 <nus> a build break?-)
04:15:24 --- topic: '["Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7: http://is.gd/hb8vE", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin and spam issues: #haskell-ops"]'
04:15:24 --- topic: set by mauke!~mauke@p3m/member/mauke on [Sat Jun 11 05:12:19 2011]
04:15:24 --- names: list (clog igrekster elliott refold colbseton drake01 stianhj ]OLI[ dimmy m4k3r otf xcombelle gienah noam_ hrehf_ sheikra dschoepe accel aavogt miclorb_ Blekel phyrex1an XniX23 DevHC ClaudiusMaximus Jeanne-Kamikaze brodo StepanKuzmin MUILTFN knoc Darkflux ksf progit adxp dmwit mpiechotka Shammah Athas Counter-Strike psychicist_ yahooooo burp [[zz]] monochrom hellige jd10 cynick bqf untwisted clsmith ski Fuco mornfall Veinor Eduard_Munteanu MacCoaster_ xarch edon)
04:15:24 --- names: list (ion cheater_ Nebasuke stobix TacticalGrace eddayyy gehmehgeh shintah ivanm kaf3ii ceii__ lopex perspectival FireFly mattp_ ulricha Coriolan HugoDaniel foopsi calp simonmellor stuartmackie owst der_eq burbul Lemon julmuri- merijn lkb tibbe JaffaCake maoe Argue mhweaver Wild_Cat jeltsch dblhelix Htbaa m3ga eikke NihilistDandy Beetny ArnoVanLumig alexkay milli pikhq_ Ptival JimHank peteriserins bragh insomniaSalt OscarZ erus` BigBlackDog sneakfast juhp gpampara)
04:15:24 --- names: list (Spockz Jaak mrtimuk hackagebot k0ral nominolo incluye MaskRay Enigmagic vili wtw alc minsa kpal andares vmil86 kish`_ novas0x2a Palmik mikeplus64 zul_netbsd RayNbow`TU digicyc snr Gunni scm twofish alip SharkMonkey ricky markamber amiri dixie BlankVerse leoncamel da-x args[0] baguasquirrel gerard0 stepkut smop jedai fhs shiduke Belgarion0 Will| Ori_B flamingspinach fcr otto_s Peaker bogner nniro DasIch preflex mauke siracusa agolsme kaito_ mustelo moshee)
04:15:24 --- names: list (jmcarthur EyesIsServer iratsu flippo cubi wto Snusfen EEVIAC copumpkin jrib tomku theorbtwo kniu a11235 identity_ StoneToad drbean__ frerich Scriptor nus augur[sleep] BrianHV dsj36 alexandre perlite mrdomino Cobra_ eyck blackrain Philippa olsner jon_of_arc jdfjklajkl Saizan confab almostsix orbitz Muad_Dibber_ sanjoyd darrint bgamari ormaaj dsmith hampusw helino henr_k inimino aculich tgeeky bxc gbeshers srcerer shachaf yrlnry EvanCarroll ozzloy jrk_)
04:15:24 --- names: list (loupgaroublond aszlig nimred dankna nihtml solidsnack reacocard ahihi2 Nisstyre caleb_9 gdsx Count_Niedar PreciousMetals kurtosis dual totimkopf1 elliottcable araujo kakos gentz drdo Cerise [mth]_ sunfun kubrat hvr Reaganomicon geekounet dMazz trez adnam lanthan_afh stepnem lomeo alek_br isenmann A1kmm Taggnostr2 epdtry Bwild earthy iFire gwern ngochai mjrosenb addhominem peerst synesthesia Cale frode Nanar Igloo nazgjunk aninhumer p3n0id jayne EvanR7)
04:15:24 --- names: list (serialhex captainp` stroan Guest81582 stchang ByronJohnson pantski fihi09 norm2782 rtharper naota jesse99 snorble Khisanth johs zmoazeni alfa_y_omega HaudRex Modius bj0 liyang thorkilnaur jssanders dino- kmill wagle flux Totramon xinming setmeaway jrockway sutabi impl zenazn Octal magicman ezyang Lymee Iceland_jack }ElectrowolF{ sshc Amadiro lucca robinsmidsrod dfeuer sjanssen EvanR silex Urchin thirsteh xplat sonnym dogmaT Johannes` kakazza akosch MarcWeber)
04:15:24 --- names: list (zaero d7 bradwright alxbl ville And[y] hammi Polarina rgee ChongLi jbauman comak niko __class__ bohanlon mtrlt Obfuscate tew88 shutdown_-h_now houeland pi8027 hirsch_ sordina2 vrthra koeskoes lokydor tommd dcolish rattboi quicksilver ousado noblethrasher jcp|1 mike-burns koala_man finnomenon othiym23 idoru rakete koninkje_away dsfox1 ehamberg jix_ jerji aluink ocharles __main__ DukeDave akahn arnihermann alexsuraci kelsin tomh- whoops hydo lpsmith Luke)
04:15:24 --- names: list (aristid mattam_ taruti djahandarie hpaste tessier mm_freak finnrobi blomqvist levitation[A] xenocryst sheik anon edwtjo xenocrys1 Cthulhon yell0 [mth] arkx d2biG kelvie_ sm brandonw tomaw mlh Vulpyne emma Jonno_FTW jmad980 twn chee1 andrewsw Yacoby jdhky ReinH BMeph Gracenotes derrida shepheb vold fall_ jcapper plat0 cyanoacry TML McManiaC _habnabit OnionKnight pettter Draggor idnar nyingen proq geoffhotchkiss Zephyrus Innominate `0660 bremner` alexsdutton)
04:15:24 --- names: list (Boney alyx anders^^ ps-auxw Starfire tauntaun coppro Intensity mafs Twey Dashkal saati maurer_ mortberg jonafan Vorpal Raku^ lambdabot opqdonut shhgs tafryn jml kolmodin_ ivan Maxdamantus davidL eno c1de0x Megant hzh solarus Entroacceptor freeformz bs338 felher benmachine etpace Utkarsh tswett mee exobit MK_FG _1amzave__ peterhil hpc dju alpounet Nereid Harbinger bobbens marienz kaol PHO_ inr drmegahertz det masterzora bbee sully jbalint zorkon ibid fds comex)
04:15:24 --- names: list (cheshire-cat_ burp_ flazz rwbarton dcoutts_ chaoflow maloi pr lusory szbalint gds plimsoll Ke absence palmje robinbb wyfrn saurik ahf deggis DustyDingo froztbyte karld_ sohum tildedave obcode ivanst kshannon progrock mux jyyou Vq Pathin ziman brixen skaar electrogeek confound kalivha chitragupt mike1703 Bassetts Raynes mercury^ Eelis schroedinbug rvncerr sainthuc1 aleator janne lispy sunnavy ray pyrtsa klugez DrSyzygy hyko Boxo tamiko amsl R496 Nshag jlaire)
04:15:24 --- names: list (ixzkn tromp dreixel The_third_man sp3ctum mrd CindyLinz peddie hiredman dkasak saiam sajkr alios dropdrive poucet devn Yahovah_ int-e luite ssbasi takamoron osfameron profmakx pesco jlewis ve dsouza fasta Martty Somix willb cpa ido nlogax Astro Baughn Botje eZet SimonRC incandenza copton CosmicRay _mpu byorgey cjay sirpengi davean savy Eliel ts00000 ttvd edenc ben quaestor cizra2 SonicvanaJr noddy arcatan lebastr dionoea zomg rndm dumael Liskni_si wolverian)
04:15:24 --- names: list (welterde ciaranm geekosaur sgronblo yottis Ornedan Arnar joni6128 Hunner marchdown thoughtpolice ttblrs brett rfgpfeiffer edwinb HalfWayMan dilinger snarkyboojum tridactyla majoh Lemmih rntz Bleadof Laney drhodes sbok aspect theclaw cncl smly- dom96 Clint ccasin etabot kalven xale liw Derander felipe_ robbert naneau carrbs1 daed mietek companion_cube deavid aiko suiside jlouis zaphar_ps ernst gf3 sipa fabjan hhulkko Mitar Aestas @ChanServ _erik_ KitB scsibug_)
04:15:24 --- names: list (zakwilson dorkitude absentia bd_ mrshoe zygoloid seats guerrilla mokus integral freiksenet Zol kosmikus ian_mi periodic EpsilonDur zenzike kloeri erg bezik noj emias ptrf dqd)
04:16:08 <int-e> elliott: http://www.glfw.org/faq.html#2_9
04:16:32 <elliott> int-e: Thanks.
04:16:37 <elliott> It does tempt me into using another windowing library...
04:17:21 <ion> Can one not just run all the GLFW stuff from a single thread and do other stuff in other threads?
04:17:22 <elliottcable> oh my god it’s gotten worse :D
04:17:51 <int-e> hmm, gtk2hs has the same problem. what else is there?
04:18:32 <elliott> int-e: Well, SDL seems to be thread safe (in practice; I don't know if it makes any actual claims to be so).
04:18:36 <int-e> ion: I believe that should work if the glfw thread enters the haskell side often enough to allow garbage collections. Works for gtk2hs at least.
04:18:58 <quicksilver> elliott: opengl, however, is not threadsafe
04:18:59 <elliott> I mean, I'm fine doing all my windowing library calls from one thread; but "GLFW doesn't work well with GHC threads, forkIO or threadDelay. So avoid them if you can." is a rather stronger statement than that.
04:19:05 <elliott> And all my GL calls, too.
04:19:10 <quicksilver> and surely nobody uses SDL except with opengl these days?
04:19:13 <elliott> But that's not the statement being made.
04:19:26 <quicksilver> yes, that statement is far too strong
04:19:35 <quicksilver> I suspect the author of that statement didn't understand the details.
04:19:50 <quicksilver> it's quite sufficient just to make all your GUI cllas from the main thread
04:19:51 <elliott> Right.
04:20:02 <quicksilver> (one way to do that is to set up a Chan(IO ()) and post things to it)
04:20:05 <int-e> elliott: I'm assuming that threadDelay is only a problem if you do it in the GLFW thread, since then event handling will no longer work.
04:20:32 <elliott> I will probably stick with GLFW-b, then; although I dislike the callback-based approach somewhat, it's certainly less crufty than SDL.
04:20:33 * hackagebot she 0.5 - A Haskell preprocessor adding miscellaneous features  http://hackage.haskell.org/package/she-0.5 (ConorMcBride)
04:20:39 <elliott> int-e: Right.
04:20:52 <elliott> I'm planning to plug this into some unholy reactive-banana configuration, so we'll see if it explodes.
04:21:07 <elliott> Ooh, she's new again?
04:21:43 <int-e> elliott: and forkIO'd threads can't make gui calls since they might come from different OS threads. You might want to steal the postAsyncGUI stuff from gtk2hs - the same idea should apply to GLFW.
04:22:07 <elliott> int-e: Right. A Chan seems like the best approach.
04:22:21 <elliott> I'm going to have to fork a library to do this though; sigh.
04:23:45 <ion> Which FRP tutorial would you guys recommend?
04:39:36 * hackagebot she 0.6 - A Haskell preprocessor adding miscellaneous features  http://hackage.haskell.org/package/she-0.6 (ConorMcBride)
04:50:39 <elliott> If a package specifies all the extensions it uses in the extensions field of its cabal file, rather than in the source files, how should I test the modules in GHCi as I modify them?
04:55:48 <byorgey> elliott: one way would be to put a .ghci file in the root directory of the package which has  :set -XFoo  commands for each extension that is needed
04:56:55 <elliott> byorgey: ah, that could work.
04:57:06 <elliott> byorgey: I'll work on moving everything into the files later... this code is quite a mess. :)
05:02:04 <elliott> byorgey: hmm, actually the .ghci would need to be in src/, not the root of the package...
05:07:23 <mattam> Is it allowed to define a class with no parameters in Haskell? w/ extensions?
05:07:52 <Axman6> for what purpose?
05:08:07 <mattam> Just curious.
05:08:18 <quicksilver> A class is a set of types
05:08:20 <Axman6> well it doesn't really make any sense
05:08:22 <sipa> what problem would it solve, or what would it be useful for?
05:08:26 <quicksilver> a multie parameter class is a relation on types
05:08:35 <mattam> I know.
05:08:37 <quicksilver> a zero parameter class appears to be nothing...
05:08:41 <Axman6> the idea of a class is to have a bunch of types which all share a bunch of common functions
05:09:03 <Axman6> class Null where null :: ()?
05:09:31 <sipa> i suppose there is some awkward way of looking at top-level definitions in a modules as belonging to a zero-parameter type class
05:10:02 <sipa> but that doesn't really gain you anything, as it would remain as special case
05:10:53 <mattam> You could have a class [class Debug where debug :: bool] say, but I have no example in mind. Someone uses one in Coq and it doesn't make sense there either.
05:11:25 <mattam> Just wondering if Haskell accepts the definition or not.
05:11:34 <sipa> that sounds like abusing the class system to emulate modules
05:11:52 <elliott> sipa: well, the class system is more powerful than modules. :)
05:13:09 <sipa> so? a blender is also more powerful than a laser pointer
05:14:04 <mattam> Well, no, it's not allowed.
05:14:32 <int-e> sipa: a laser pointer is much more fun when playing with a cat.
05:15:02 <sipa> mattam: in haskell98 a type class has exactly one parameter, with multiparamtypeclasses, it's one or more parameters, iirc
05:17:46 <Eduard_Munteanu> Anyway, how would you spell the typeclass constraint in a type?
05:18:21 <sipa> hmm?
05:19:58 <Eduard_Munteanu> Like    foo :: Debug => something   ?
05:20:06 <mattam> yes.
05:20:31 <mattam> Kind of implicit arguments.
05:21:05 <ceii__> you could select an arbitrary type as the subject of the instance
05:21:14 <ceii__> foo :: Debug Int -> whatever
05:21:29 <ceii__> and define instance Debug Int where debug = ...
05:21:43 <aavogt> > let x2 = ?x ^ 2 in (let ?x = 3 in x2, let ?x = 0 in x2)
05:21:44 <lambdabot>   (9,0)
05:22:11 <aavogt> :t let x2 = ?x ^ 2 in x2
05:22:12 <lambdabot> forall a. (Num a, ?x::a) => a
05:22:47 <mattam> ceii__: the methods would have to mention this type parameter though.
05:24:05 <aavogt> @hackage reflection gives similar results as that -XImplicitParams but using different extensions
05:24:06 <lambdabot> http://hackage.haskell.org/package/reflection gives similar results as that -XImplicitParams but using different extensions
05:24:07 <ceii__> mattam, then what about "class Debug a where _debug :: a -> Bool" and "debug :: Debug Int => bool ; debug = _debug 0" ?
05:24:26 <ceii__> a bit roundabout though
05:25:27 <mattam> yep, that'd work.
05:25:36 <aavogt> ceii__: you will still need to specify that individual uses of debug :: Debug Int
05:26:54 <ceii__> aavogt: the point is to use debug, which has a type signature of "debug :: Debug Int => Bool", instead of _debug
05:27:05 <ceii__> am I getting something wrong?
05:27:29 <aavogt> then there's no difference between defining that without a type class
05:28:04 <Eduard_Munteanu> Just bringing them in scope. But that could be accomplished by a better module system I guess.
05:28:53 <ceii__> All you win is that you can have modules that use "debug" even if they don't import the module that defines it.
05:29:03 <erus`> @hoogle M a -> a
05:29:03 <lambdabot> Warning: Unknown type M
05:29:03 <lambdabot> Prelude id :: a -> a
05:29:03 <lambdabot> Data.Function id :: a -> a
05:29:05 <Eduard_Munteanu> Or yeah, I guess mattam wants the type to witness the fact that a given function uses that method.
05:29:06 <aavogt> (besides maybe telling users that there is some Debug output; you can leave off such constraints so that benefit is less useful)
05:29:21 <erus`> @hoogle Monad a -> a
05:29:21 <lambdabot> Warning: Unknown type Monad
05:29:21 <lambdabot> Prelude id :: a -> a
05:29:21 <lambdabot> Data.Function id :: a -> a
05:29:21 <aavogt> > let x :: Num Int => Int; x = 5 in x
05:29:22 <lambdabot>   5
05:29:42 <ceii__> @hoogle Monad m => m a -> a
05:29:42 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
05:29:42 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
05:29:42 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
05:32:15 <erus`> Can i take a Monad m and turn it into a visual basic variable?
05:32:49 <mattam> Eduard_Munteanu: I suppose it would, but you can forget about the example... I just wanted to know if it was possible and it's not.
05:33:06 <ceii__> erus`, I don't understand your question at all.
05:34:12 <erus`> I need to pipe the monad through SOAP to my access database and run some excel computations on it
05:35:20 <erus`> whats the command?
05:35:52 <Eduard_Munteanu> erus`: Monad is a typeclass, not a type or a value
05:36:20 <joseanpg> Hello
05:36:27 <Eduard_Munteanu> joseanpg: hi
05:36:35 <ceii__> joseanpg, hello
05:36:43 <Eduard_Munteanu> erus`: so you have a monadic value you want to do something with?
05:37:18 <Eduard_Munteanu> That being something of type   M A, where M is some monad.
05:38:01 <erus`> found it
05:38:14 <Eduard_Munteanu> :/
05:46:43 * hackagebot network 2.3.0.5 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3.0.5 (JohanTibell)
05:47:38 <erus`> i wanna reduce haskell down to its smallest language
05:47:42 <erus`> without being a lisp
05:48:15 <erus`> making it dynamicly typed seems to make things simpler for me but it feels like cheating
05:49:03 <erus`> i want to do away with everything except function definition and application
05:49:03 <Axman6> and a horrible idea...
05:49:06 <mauke> dynamic typing breaks typeclasses
05:49:14 <erus`> types are for girls
05:49:16 <opqdonut> it's not haskell if it's dynamically typed
05:49:18 <mauke> erus`: then you get lambda calculus
05:49:26 <bxc> if by part of "simpler" you mean simpler to execute, then dynamic typing is more complex sometimes
05:49:50 <bxc> erus`: types are not for girls! go play with agda
05:49:59 <Axman6> erus`: types are for people who understand the value of the compiler finding your bugs.
05:50:27 <bxc> theres a bunch of desugaring that happens in ghc, right?
05:50:27 <Axman6> types save you large amounts of money in the long run
05:50:36 <erus`> but i can define a list with functions if i have dynamic types
05:50:38 <bxc> i.e. some language constructs get reduced into equivalent other ones
05:50:49 <erus`> otherwise i need 'data' and stuff
05:50:51 <Axman6> you can have a lift with functions in it in haskell
05:50:57 <bxc> thats a "less complex" language
05:51:06 <Axman6> :t [(+), const]
05:51:07 <lambdabot> forall a. (Num a) => [a -> a -> a]
05:51:14 <Axman6> list*
05:51:16 <sipa> erus`: how is having a list with function in any way related to having static types or not?
05:51:48 <erus`> i mean if the only types are tuples, and natives (int, string etc)
05:52:06 <bxc> why do you need something so complex as tuples and strings? you can encode those as ints
05:52:11 <bxc> ;)
05:52:24 <sipa> erus`: and how will you support lists?
05:52:46 <erus`> cons a = (a, ())
05:53:07 <zygoloid> erus`: you don't need tuples, just () and (->) :)
05:53:09 <Axman6> worst ides from lips evar
05:53:11 <erus`> tail (a, b) = b
05:53:43 <quicksilver> erus`: and in what way will this not be lisp, again?
05:53:52 <Axman6> idea*
05:54:00 <erus`> zygoloid: like cons a = (a -> ())?
05:54:06 <bxc> sounds liek you should build your own language, but not call it haskell...
05:54:12 <bxc> that stuff is fun to play with
05:54:26 <bxc> and if you claim its not haskell people will not shout at you so much
05:54:58 <erus`> good point
05:55:27 <bxc> another interesting thing might be to do haskell language extensions negatively - figure out what bits you can remove with the language being useful still (eg typeclasses)
05:56:23 <zygoloid> erus`: like: nil n _ = n; cons x xs n r = r x (xs n r)
05:56:28 <Axman6> erus`: i don't think that the fact you've just reinvented lisp can be easily escaped
05:56:39 <bxc> Axman6: heh
05:57:12 <erus`> zygoloid: what are all those args?
05:57:34 <Axman6> @google lambda calculus
05:57:35 <lambdabot> http://en.wikipedia.org/wiki/Lambda_calculus
05:57:40 <Axman6> erus`: ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
05:57:56 <zygoloid> erus`: you can faithfully represent a list xs by the function '\n c -> foldr c n xs'
05:57:57 <lysgaard> I have a newtype: newtype Key = Key Integer. Is there any way to automatically derive all typeclasses for integers to this newtype?
05:58:03 <opqdonut> yes
05:58:10 <opqdonut> generalized newtype deriving, an extension of GHC
05:58:16 <sipa> not all, you must name them explicitly still :)
05:58:23 <opqdonut> oh, yeah
05:58:35 <zygoloid> erus`: likewise you can represent (a,b) as \f -> f a b
05:58:36 <lysgaard> sipa: Ah, that was what I was hoping to not have to.
05:59:10 <sipa> lysgaard: if you want it to behave exactly like an Integer, why not use Integer itself (maybe type-aliased) ?
06:00:10 <lysgaard> sipa: Because I want the typechecker to not let me send Integers to a function taking Key.
06:00:46 <elliott> lysgaard: then you don't want to be able to send them to Integral functions either, presumably
06:01:30 <sipa> lysgaard: if you want it to behave as an Integer, you'll need to implement Num, and functions that take a Key will accept an integer constant as argument
06:01:53 <sipa> so you're right, there are some mistakes it will prevent you from making, but not all
06:03:03 <erus`> > let c = (\f -> f a b) in c 1 2
06:03:04 <lambdabot>   1
06:03:26 <Axman6> heh
06:03:28 <lysgaard> True, it will only keep me from using functions that specificly talk about Integer, but not about all functions that take the typeclasses to Integer.
06:03:34 <Axman6> that's... not supposed to work like that
06:03:52 <sipa> Axman6: in lambdabot, functions are Num
06:03:54 <Axman6> > let c = \f -> f 1 2 in c const
06:03:56 <lambdabot>   1
06:04:00 <sipa> > 3 1
06:04:01 <lambdabot>   3
06:04:07 <Axman6> sipa: i know, but it's misleading
06:04:18 <sipa> :t (5 :: (a -> a))
06:04:19 <lambdabot>     Could not deduce (Num a) from the context ()
06:04:19 <lambdabot>       arising from the literal `5' at <interactive>:1:1
06:04:19 <lambdabot>     Possible fix:
06:04:29 <Axman6> > let c = \f -> f 1 2 in c (\x y -> y)
06:04:30 <lambdabot>   2
06:04:36 <quicksilver> :t (5,id)
06:04:36 <lambdabot> forall t a. (Num t) => (t, a -> a)
06:04:44 <quicksilver> :t [5,id]
06:04:44 <lambdabot> forall a. (Num a) => [a -> a]
06:04:58 <quicksilver> sipa: you can make the unifier work for you but it's not as simple as an annotation :)
06:05:21 <eikke> if I'd want to work with Integers in a ring modulo N, can I encode this 'N' in some type (wrapper)? which type-fancyness should i look into? (families, gadts, whatever...)
06:05:34 <erus`> is pattern matching hard to implement?
06:05:42 <Axman6> super hard
06:05:44 <Axman6> >_>
06:05:50 <erus`> i cant wrap my head around it
06:06:25 <Axman6> in GHC, tagged pointers are used for small types (is, less than 4/8 constructors on 32/64 bit)
06:06:42 <mauke> eikke: http://okmij.org/ftp/Haskell/types.html#Prepose does this
06:06:46 <quicksilver> I don't think that's true Axman6.
06:06:55 <Axman6> i believe all data in GHC is word alligned, so the last 2/3 bits are unused
06:06:56 <quicksilver> GHC used tagged pointers once but I don't think so any more
06:06:59 <Axman6> quicksilver: no?
06:07:02 * zygoloid thinks lambdabot has the wrong Num instance for functions
06:07:22 <mauke> zygoloid: are there any others?
06:07:26 <quicksilver> Axman6: hmm no, I think you're right :)
06:07:28 <quicksilver> Axman6: sorry.
06:07:41 <zygoloid> mauke: yeah. n x = n * x works nicely in some cases
06:08:00 <Axman6> quicksilver: 9 times out of 10, you're right when you correct me on something. so i count this as a win :P
06:08:09 <mauke> zygoloid: that makes no sense
06:08:13 <zygoloid> (though i consider that a wrong Num instance too)
06:08:22 <eikke> mauke: implicit configurations? think I read that paper a while ago, but it didnt come to mind in this case... will re-read
06:08:47 <zygoloid> mauke: f x = 5 x + 3
06:08:58 <benmachine> zygoloid: does that even type check?
06:09:02 <mauke> zygoloid: how are + and * defined?
06:09:04 <zygoloid> for the right instance, yes
06:09:15 <benmachine> oh wait, that's Num a, Num b => Num (a -> b), right? so less general
06:09:22 <Axman6> zygoloid: so, instance Num a => Num (a -> a) where fromIntegral x = \y -> fronIntegral x * y?
06:09:38 <zygoloid> mauke: (f + g) x = f x + g x. (f * g) x = f (g x)
06:09:55 * zygoloid has an implementation of this somewhere
06:10:06 <benmachine> why would you want the latter?
06:10:10 <zygoloid> iirc there is something which goes badly wrong
06:10:33 <zygoloid> but it's much more intuitive than 1 2 3 4 5 == 5
06:10:44 <sipa> > 1 2 3 4 5
06:10:45 <lambdabot>   1
06:10:46 <zygoloid> or 1. or whatever it is
06:10:51 <zygoloid> :)
06:11:10 <benmachine> zygoloid: sure, but we just gloss over that and pretend it doesn't happen
06:11:13 <benmachine> simple
06:13:42 <erus`> functions are values, but the haskell parser will try to apply values to functions but not values (that are not functions)
06:14:17 <mauke> it totally will
06:14:55 <erus`> ah hang on :P
06:15:14 <erus`> im reading right to left
06:16:38 <erus`> applying a function to a function yeilds a function then values are applied to that rather than applied to the second function. easy
06:16:57 <quicksilver> Axman6: 6.8.1 (pointer tagging came in to GHC)
06:17:07 <Axman6> that late? huh
06:17:15 <Axman6> that's probably the first ghc i used too
06:17:37 <quicksilver> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/PointerTagging
06:17:46 <Axman6> SPARC actually has instructions for working with tagged pointers, which i thought was pretty cool
06:32:55 <hpaste> erus` pasted “indentation error” at http://hpaste.org/49768
06:33:10 <erus`> how can i fix the error,
06:33:18 <erus`> i been messing about with it for 5 mins solid now
06:33:22 <Axman6> don't use tabs
06:33:47 <quicksilver> erus`: you have a missing = sign somewhere
06:34:04 <quicksilver> erus`: second | guard
06:34:06 <erus`> aha
06:34:08 <Axman6> that too
06:34:11 <quicksilver> has no RHS. or no LHS. or something.
06:34:23 <erus`> i forgot my otherwise
06:34:26 <Axman6> the first thing i ever look for when people have indentation errors is the use of tabs
06:34:30 <quicksilver> not using tabs is excellent advice though.
06:35:23 <Ptival> in what sense?
06:35:39 <Ptival> spaces instead of actual tabs?
06:35:43 <quicksilver> yes
06:35:45 <Ptival> ok
06:35:50 <quicksilver> in haskell, tabs are only shorthand for 8 spaces anyway
06:35:54 <quicksilver> so it's not really worth it
06:36:09 <quicksilver> and if your editor is set to display them as anything other than 8, you may misjudge alignment
06:36:22 <Ptival> I only ever use tabs in Makefiles :D
06:36:52 <Axman6> quicksilver: is it 8 spaces, or until the next 8 space tabstop?
06:36:59 <hatds> tabstop
06:37:16 <bxc> ewww tabs
06:37:39 <Axman6> you can write haskell using tabs, but you have to have 8 character tabstops
06:37:56 <Axman6> in your editor*
06:38:22 <quicksilver> tabstop, yes.
06:38:22 <hatds> or know how to write insensitive layout using tabs
06:38:33 <erus`> i just dont bother lining stuff up character to character
06:38:38 <erus`> i just use tabs liek python
06:39:11 <zygoloid> obviously the one true way to write haskell is tabs-and-braces
06:39:14 * zygoloid ducks
06:39:22 <Ptival> braces!
06:39:44 <frerich> quicksilver: Do you have a blog?
06:40:56 <hatds> write all your modules on one line, use word wrap...
06:41:24 <frerich> quicksilver: I greatly appreciate your calmness and competence in this channel, I think I'd also enjoy articles you write - if you do something like that.
06:41:56 <copumpkin> yes!
06:42:01 <copumpkin> quicksilver please write us some articles
06:42:23 <kalven> do you have a newsletter?
06:45:20 <quicksilver> :)
06:45:28 <quicksilver> sadly not
06:45:48 <quicksilver> I hate the idea of putting words down in a permanent medium, people might come along and point out I was wrong!
06:46:53 <frerich> quicksilver: If articles you wrote would improve my knowledge to the degree that I could point out errors in your texts, you succeeded!
06:52:17 <benmachine> I keep meaning to start a blog
06:52:32 <benmachine> but I want to use a haskell blog engine, and none of the existing ones support comments, and I don't like disqus
06:52:44 <frerich> benmachine: I'd love to see some stuff from you, too!
06:52:45 <benmachine> (or, none of the ones I found; heck of a lot of static ones)
06:53:11 <benmachine> frerich: http://www.srcf.ucam.org/~bm380/machine/haskell/overqualified-modules here :P
06:53:12 <Scriptor> aren't most blog engines static?
06:53:19 <benmachine> Scriptor: seems so!
06:53:57 <quicksilver> static is the way to do for a blog engine really
06:53:59 <shapr> benmachine: tried snap or yesod?
06:54:01 <quicksilver> posts don't change
06:54:18 <benmachine> shapr: yesod looked complicated, I've vaguely looked at snap once or twice
06:54:18 <quicksilver> wordpress is notorious for getting DOSed because it does too much work on each page
06:54:30 <benmachine> quicksilver: I want comments though :(
06:54:33 <quicksilver> shapr: snap/yesod are web frameworks not blogs, surely?
06:54:52 <shapr> quicksilver: Yes, but it's the closest I've seen?
06:55:08 <Scriptor> you'd have to write the blog, with comments
06:55:08 <benmachine> I think I had a plan where the submit comment form would write out a new HTML file when it was used, so all content was served statically
06:55:32 <Scriptor> unless there's a wordpress-like thing in Haskell?
06:56:00 <benmachine> if there isn't there should be!
06:56:16 <shapr> I'm using and enjoying hakyll, I was going to suggest writing only the comments part.
06:56:39 <frerich> benmachine: I found you on FB but I'd rather like to follow you on Google+ - https://plus.google.com/114866055015345101389/posts is you, right (there are plenty of Millwood's, but that one looks like the FB picture)? You could use that for blogging!
06:57:00 <quicksilver> benmachine: yes that's a common way to do it I believe
06:57:02 * frerich thinks Google+ assimilates blogging by being viewable even for non-members
06:57:07 <benmachine> frerich: your stalking ability is unsettlingly accurate :)
06:57:08 <quicksilver> benmachine: because you get far fewer comments than page views.
06:57:23 <quicksilver> benmachine: so running the rendering process once per comment is obviously better than once per view.
06:57:29 <benmachine> shapr: right, that was my plan, I did a first version and then decided it was insecure and then got bored
06:57:35 <shapr> heh
06:57:36 <shapr> well
06:59:27 <benmachine> frerich: I've so far been using google+ for FB-like things though, insofar as I've been using it at all, so I don't promise anything exciting :P
07:00:50 <frerich> benmachine: Oh that's fine. I'm just trying (quite successfully, too!) to merge all the streams of news I'm following (various blogs about programming, for instance) into a central place, and Google+ seems to support the 'following' relationship very nicely.
07:01:12 <Scriptor> g+ just needs to make urls be a little more readable and it'd be a pretty nice blogging platform
07:05:37 <erus`> > splitOn 'c' "abcdef"
07:05:38 <lambdabot>   Not in scope: `splitOn'
07:05:42 <erus`> > splitAt 'c' "abcdef"
07:05:43 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:05:43 <lambdabot>         against inferred type ...
07:05:52 <erus`> :t split
07:05:53 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
07:06:25 <int-e> > splitAt 5 "abcdefghijkl" -- gives the length of the initial segment
07:06:26 <lambdabot>   ("abcde","fghijkl")
07:06:38 <erus`> @hoogle a -> [a] -> ([a], [a])
07:06:38 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
07:06:39 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
07:06:39 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
07:07:02 <int-e> > span (/= 'c') "abcdefgh"
07:07:03 <lambdabot>   ("ab","cdefgh")
07:07:43 <Axman6> @src span
07:07:43 <lambdabot> span _ xs@[]                     =  (xs, xs)
07:07:43 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
07:07:43 <lambdabot>                   | otherwise    =  ([],xs)
07:08:30 <int-e> and of course there's http://hackage.haskell.org/package/split
07:11:37 <plat0> Does anyone know when AngloHaskell 2011 will be held?  The wiki seems to go up only to 2010.
07:18:42 <hpaste> erus` pasted “splitAround” at http://hpaste.org/49770
07:18:52 <erus`> is that bloody ugly or good code?
07:19:50 <Axman6> it could be more elegant...
07:20:01 <smoge> Hi
07:20:12 <smoge> I'm getting problems installing pandoc with ArchLinux
07:20:12 <smoge> http://codepad.org/7gzf96mN
07:20:14 <smoge> any ideas?
07:20:34 <zygoloid> erus`: it'd be much nicer to only traverse the list once
07:20:42 <smoge> ``Cabal-1.10.1.0-e951c182da4a22a7b82c0f2e4be13b7b is unusable due to missing or recursive dependencies:''
07:21:37 <zygoloid> erus`: hint: look at Prelude.break
07:21:54 <benmachine> smoge: that's a scary error message. run ghc-pkg check
07:22:25 <Peaker> erus`: isJust should virtually never be used, especially not followed by fromJust
07:22:41 <benmachine> isJust does have legitimate uses
07:22:56 <erus`> whats th alternative?
07:23:01 <Axman6> :y maybe
07:23:02 <Axman6> :t maybe
07:23:02 <benmachine> erus`: pattern match!
07:23:03 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:23:03 <erus`> patern matching?
07:23:05 <Botje> case elemIndex c s of { Nothing -> ...; Just i -> ... }
07:23:21 <roconnor> ``That’s a pretty common strategy of students, to focus on getting rid of the error message without making sure the program still makes sense.
07:23:48 <hpaste> Peaker annotated “splitAround” with “splitAround (annotation)” at http://hpaste.org/49770#a49771
07:23:48 <hpaste> Peaker annotated “splitAround” with “splitAround (annotation)” at http://hpaste.org/49770#a49772
07:24:17 <Botje> .oO(fmap tail also works)
07:24:18 <Peaker> benmachine: with fromJust after it?
07:24:28 <smoge> benmachine: http://codepad.org/0vlwtoXp
07:24:34 <benmachine> Peaker: fromJust doesn't have legitimate uses :P
07:24:37 <smoge> I only get this error with this package
07:24:47 <Peaker> benmachine: :-)
07:25:05 <hpaste> zygoloid annotated “splitAround” with “splitAround (annotation) (annotation)” at http://hpaste.org/49770#a49773
07:25:25 <benmachine> smoge: oh dear. can I see ghc-pkg list?
07:25:39 <benmachine> zygoloid: I was just thinking break
07:25:59 <smoge> http://codepad.org/KZsc3cjC
07:26:09 <Peaker> I wasn't thinking :-) I mechanically transformed the fromJust to pattern matching
07:26:16 <perian> hallo guys. i am having a little bit of trouble tinkering with types. my am designing a library to work with sequences of any type (dna, numbers, chars). for performance issues i want to use ByteString to store numbers and ByteString.Char8 to store characters. Is there any way to infer a type used to store by constructor???
07:26:46 <perian> just some keywords would be nice
07:26:51 <smoge> benmachine: I enabled the testing repo that has a package for cabal-install. Maybe related to this error?
07:27:03 <erus`> my language is useless
07:27:04 <Axman6> perian: what do you mean by constructor?
07:27:30 <Peaker> erus`: ?
07:27:50 <erus`> i cant work out how todo IO
07:27:53 <erus`> well i can do it
07:28:02 <erus`> but then i cant do something else
07:28:04 <benmachine> smoge: probably not. notice that you have two copies of template-haskell installed
07:28:20 <benmachine> smoge: cabal has a habit of installing things it shouldn't
07:28:30 <smoge> hum..
07:28:31 <erus`> oh maybe i can
07:28:38 <smoge> benmachine: any easy fix?
07:28:39 <benmachine> but the damage is probably reversible with a little reinstallation
07:28:50 <smoge> ok, I will start with this package
07:28:56 <benmachine> smoge: no wait
07:28:56 <perian> Axman6: In C++ i could say something like Sequence<Dna> "ACATTAGA". From the Dna-Paramter i could infer a type suitable for storing Dna.
07:29:09 <erus`> main w = print w $ input w "What is your name?"
07:29:18 <perian> Axman6: I am asking for a way to store a type in a type.
07:29:22 <Axman6> perian: look at type families
07:29:24 <benmachine> smoge: try ghc-pkg unregister template-haskell; it will probably refuse to do so, but the reason why will be useful
07:29:27 <zygoloid> perian: search for 'type families' and 'associated types'
07:29:44 <perian> thanks. ill try that
07:29:50 <erus`> lazyness is a bitch
07:30:12 <Axman6> class Sequence a where Sequence a :: *; instance Sequence DNA where type Sequence DNA = C8.ByteString
07:30:43 <Axman6> you'd also have other functions in that class that work on things of type Sequence a
07:30:47 <Axman6> so...
07:30:56 * hackagebot BiobaseInfernal 0.5.1.0 - Infernal data structures and tools  http://hackage.haskell.org/package/BiobaseInfernal-0.5.1.0 (ChristianHoener)
07:30:57 <benmachine> data families might also be useful here
07:31:25 <benmachine> perian: note that ByteString.Char8 is actually the same bytestring as ByteString, it's just different functions to work on it
07:31:30 <Axman6> class Sequence a where data Sequence a :: *; toList :: Sequence a -> [a] fromList :: [a] -> Sequence a etc.
07:32:04 <perian> benmachine: thanks for the note
07:32:20 <perian> Axman6: that might be what i am looking for
07:32:22 <zygoloid> perian: type class instances don't work quite like template specializations -- you can't define a generic implementation and then specialize it for certain types (but you can reduce the boilerplate per type to just one line)
07:32:36 <benmachine> Char8 is a bit odd actually, since it pretends ByteStrings contain characters, but they don't really
07:32:47 <benmachine> they contain bytes, hence the name :P
07:32:57 <smoge> benmachine: ghc-pkg: unregistering template-haskell would break the following packages: QuickCheck-2.4.0.1 bitset-1.1 (use --force to override)
07:33:00 <benmachine> so often using an utf8 encoding is better
07:33:08 <Axman6> characters are also bytes though... just not haskell's Char
07:33:17 <zygoloid> well, the Char8 functions assume that the bytestring represents data in latin1
07:33:20 <benmachine> smoge: interesting. how about unregister QuickCheck?
07:33:26 <Axman6> if you're working with nin ASCII data, you should be using Text
07:33:41 <Axman6> or non latin1 i guess
07:33:47 <benmachine> Axman6: Text or String or utf8-string are all fair options
07:34:02 <Axman6> but Text iz teh fast one
07:34:06 <benmachine> true
07:34:22 <perian> i think ill make some benchmarks on the different types
07:34:28 <benmachine> perian: it depends what you need
07:34:30 <perian> i am new to haskell so just let me take a breath
07:34:46 <smoge> benmachine: ghc-pkg: unregistering QuickCheck would break the following packages: bitset-1.1 (use --force to override)
07:35:41 <benmachine> smoge: hmm. possibly unregistering bitset, quickcheck, and template-haskell would get you most of the way there
07:36:12 <benmachine> smoge: then *maybe* reinstalling them
07:36:30 <benmachine> smoge: the thing is, your locally installed packages shadow globally installed ones
07:36:35 <smoge> so this is a bug in cabal-install ?
07:36:38 <benmachine> the globally installed ones are handled by pacman
07:36:48 <smoge> ah ok
07:37:04 <smoge> no it's overrinding pacman
07:37:04 <benmachine> smoge: in a sense. cabal-install is working as intended, but the intention is wrong :P
07:37:56 <benmachine> smoge: yes. you have (presumably) pacman-installed versions of QuickCheck, against which other packages are compiled
07:38:02 <benmachine> and then a cabal-installed version of QuickCheck
07:38:09 <benmachine> now when ghc looks for QuickCheck, it finds the wrong one
07:38:32 <erus`> is there a handy error monad?
07:38:34 <benmachine> why you've got two copies of the same package I don't know, but probably has something to do with dependency resolution being a bit funny
07:38:41 <benmachine> erus`: depends what errors you want
07:38:45 <erus`> like an Error String which can return a string or error
07:38:58 <erus`> error will be string also
07:39:17 <benmachine> erus`: 'Either String a' might do what you want
07:39:37 <benmachine> well, you have to get the instance somehow; mtl defines one, as does base-4.3
07:39:59 <erus`> maybe i should just data Error = Err String | Ok a
07:40:15 <Entroacceptor> @src Either
07:40:15 <lambdabot> Source not found. Do you think like you type?
07:40:29 <benmachine> erus`: that's essentially the same as Either String a, but sure you can do that if you like
07:40:34 <benmachine> then define your own Monad instance
07:41:11 <erus`> i will use either
07:41:12 <smoge> benmachine: :: haskell-platform: requires haskell-quickcheck=2.4.0.1-3.1
07:41:31 <benmachine> smoge: right, but you have a local version of quickcheck as well
07:41:47 <Axman6> @src Either
07:41:47 <lambdabot> Source not found. My brain just exploded
07:41:50 <Axman6> wut
07:41:53 <benmachine> smoge: you want to unregister the local one with ghc-pkg unregister QuickCheck
07:42:05 <Axman6> Cale! @src Either -> source not found? :(
07:42:28 <Entroacceptor> @type Either
07:42:29 <lambdabot> Not in scope: data constructor `Either'
07:42:44 <Entroacceptor> @type Left "Hello"
07:42:45 <lambdabot> forall b. Either [Char] b
07:50:06 <joseanpg> > data Dat = Dat
07:50:07 <lambdabot>   <no location info>: parse error on input `data'
07:50:30 <joseanpg> how could I define a datatype for lambdabot?
07:50:37 <benmachine> you can't
07:51:02 <erus`> i guess isRight is bad too then
07:51:03 <benmachine> she doesn't like it
07:51:16 <benmachine> erus`: pattern-matching is usually better
07:51:22 <benmachine> but it's not always completely bad
07:52:42 <erus`> here is my problem: i have to parse a list of tokens, first i read the head and make sure it is a valid name, if not return an error, then check if args are valid, returning an error if not
07:52:59 <erus`> so i use isLeft to check for errors
07:53:14 <erus`> from functions that return Either Error SomethingElse
07:54:02 <erus`> i cant see how to pattern match in this situation
07:55:03 <Axman6> foo (Left e) = ...; foo (Right x) = ...
07:55:18 <ion> Use a combinator like f <$> name <*> args
07:55:18 <bss_work> fn (Left err) = err; fn (Right x) = fn' x
07:55:41 <ion> Assuming the parser has a sensible Applicative instance.
07:56:18 <Axman6> erus`: time for you to learn about monads
07:56:27 <Axman6> the Either monad is pretty easy to grasp
07:56:42 <Axman6> it's for doing exactly what you described
07:56:45 <erus`> yeah i know how to use it
07:56:57 <erus`> but i have to write abotu 10 functions
07:57:04 <erus`> to match all the cases
07:57:46 <ion> > let name = Right "name"; args = Right ["foo", "bar", "baz"] in (:) <$> name <*> args
07:58:01 <Axman6> lambdabot!
07:58:48 <bss_work> let passErr f = either Left (Right . f), maybe?
07:59:15 <ion> bss: Isn’t that the same as <$>?
07:59:41 <bss_work> ion: I don't know the applicative instance for Either String
08:00:40 <c_wraith> that's just Functor
08:00:59 <c_wraith> and yeah, that's the same as fmap
08:01:02 <erus`> can i pattern match in gaurds
08:01:03 <erus`> ?
08:01:26 <parcs> yes
08:01:27 <c_wraith> erus`: with the GuardPatterns extension.  (I think that's the name of it)
08:01:33 <bss_work> erus`: I think pattern guards are standard Haskell 2010, yes.
08:01:35 <c_wraith> or is it PatternGuards?
08:01:42 <parcs> it's enabeld by default
08:01:50 <benmachine> bss_work: there is only one sensible fmap, if you have a function that looks fmappish, it's fmap :P
08:02:18 <erus`> I wanna do like | (Meh a) = x = something x
08:02:27 <erus`> too many equals?
08:03:01 <parcs> > let foo x | Just _ <- x = 5 | otherwise = 4 in foo (Just ())
08:03:12 <bss_work> erus`: I think the syntax is: fn x | (Meh a) <- x = something x
08:03:44 <erus`> but i need to enable an extension?
08:04:04 <Botje> PatternGuards, i think
08:04:16 <quicksilver> not in haskell2010
08:04:19 <zygoloid> erus`: depends on which compiler you use. this is standard Haskell'10
08:04:25 <erus`> ok
08:04:26 <quicksilver> by which I mean, you don't need to enable the extensio in haskell2010 mode
08:04:30 <parcs> erus`: how about try it out yourself
08:04:31 <quicksilver> because it is standard then.
08:04:50 <XniX23> what is haskell2010?
08:05:01 <Axman6> the latest haskell standard
08:05:05 <bss_work> XniX23: Latest Hakell standard.
08:05:14 <Axman6> a pretty small modification to haskell98
08:05:22 <Axman6> well, afair it's small
08:05:33 <ion> http://lmgtfy.com/?q=haskell+2010&l=1
08:05:39 <XniX23> Axman6: is the language so perfect?
08:05:46 <bss_work> XniX23: We got pattern guards, and further deprecated n + k patterns, a few other things.
08:05:59 <quicksilver> http://www.haskell.org/onlinereport/haskell2010/haskellli2.html#x3-5000
08:06:02 <quicksilver> lists the major changes
08:06:33 <Axman6> XniX23: no, but it wasn't a big lot of changes, to avoid breaking lots of old code
08:06:36 <bss_work> Well, for the next version we should figure out how MultiParameterTypeClasses really work.  That way MTL and Arrow can be well-typed without extensions.
08:07:09 <quicksilver> that requires figuring out fundeps (yuck) or type families (still unfinished)
08:07:19 <ion> I wonder if the Functor/Pointed/Applicative/Monad classes will ever get fixed?
08:07:50 <bss_work> quicksilver: MTL requires fundeps (or something like it).  I think Arrow does not.
08:07:56 <erus`> bss_work: yey it works :)
08:08:07 <Axman6> ion: i hope so, but it'll be a while. there's quite a lot wrong with them :(
08:08:14 <mokus> ion: yea, if it had just been changed long ago we'd already be over the pain of fixing all the broken legacy code
08:08:34 <quicksilver> bss_work: which part of Arrow uses MPTCs?
08:08:42 <ion> There was a proposal that retained compatibility with legacy code IIRC.
08:08:59 * Axman6 -> sleep
08:09:18 <quicksilver> ion: http://hackage.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances
08:09:37 <mokus> ion: yea, it can be done, but it seems like everyone's waiting on a perfect solution when if we had just jumped in feet first it'd be over already
08:09:41 <bss_work> quicksilver: Arrow itself is a multi-parameter type class.
08:09:56 <quicksilver> bss_work: no it's not.
08:10:02 <bss_work> quicksilver it's parameterized on both the input type and the output type.
08:10:04 <quicksilver> class Arrow a where ....
08:10:40 <quicksilver> from a quick glance over http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html everything seems to be haskell98, although I might have missed something.
08:11:08 <bss_work> Also, there's the Arrow transformers, although they aren't used so much yet.
08:11:13 <d7> I hope my arrow conversation declarations with Tim are not spilling over here. :)
08:11:38 <Saizan> Arrow has a single (higher-kinded) parameter
08:13:44 <ion> Found it: http://repetae.net/recent/out/classalias.html
08:14:00 <joseanpg> what is the meaning of "guarded recursion"?
08:14:46 <roconnor> joseanpg: usually it means that the recursive call occurs under (aka is guarded by) a constructor.
08:14:50 <quicksilver> ion: there are some flaws in that proposal. See the link I posted for a more recent take.
08:15:32 <ion> Now that i look at it (the one i linked), one would have to retain the names such as Monad with the class aliases and call the new Monad class something else. :-(
08:15:35 <roconnor> joseanpg: for lazy evaluation this means that the recursive call is suspended until that constructor is deconstructed by a case statement.
08:15:39 <ion> quicksilver: About to look at it, thanks.
08:16:55 <joseanpg> thanks roconnor , could you give an example?
08:17:50 <hpaste> erus` pasted “pattern matching!” at http://hpaste.org/49774
08:18:01 <erus`> am i doing it right? because it looks messy
08:18:50 <roconnor> @src concat
08:19:35 <zygoloid> erus`: you can use the Monad (Either e) instance to clean that up
08:20:02 <int-e> > foldr (++) [] [[],[1],[2,3],[4,5,6]]
08:20:32 <quicksilver> PatternGuards are not the right hammer for that nut, methinks.
08:20:57 <int-e> oh it died 20 minutes ago.
08:21:08 <bss_work> erus`: I think the last 3 guards might be bettter written as FunctionDef <$> name <*> as, should do the same thing.
08:21:27 <roconnor> joseanpg: if we defined append as append [] ys = ys; append (x:xs) ys = x : (append xs ys) then we see that the recursive call to append is guarded by the (:) consturctor.
08:21:32 <hpaste> zygoloid annotated “pattern matching!” with “pattern matching! (annotation)” at http://hpaste.org/49774#a49775
08:22:21 <bss_work> erus`: Yeah, like zygoloid did it.
08:22:38 <erus`> whats that operator?
08:22:45 <gwern> > 645000 / (365*3)
08:22:51 <bss_work> erus`: (<$>) = fmap
08:23:04 <bss_work> erus` (<*>) = ap
08:23:09 <gwern> 589.0410958904109
08:23:58 <erus`> how on earth does that work
08:24:03 <bss_work> ap is from Control.Monad, (<*>) is from Control.Applicative, fmap is in Prelude, I think.
08:24:04 <ion> erus: I said “Use a combinator like f <$> name <*> args” 30 minutes ago. :-P
08:24:26 <erus`> ion i have never seen this before
08:24:45 <quicksilver> erus`: you are witnessing the point of the Either Monad
08:24:56 <quicksilver> the point is to silently hide the plumbing which propagates 'Left' errors
08:25:03 <erus`> that cool
08:25:07 <bss_work> erus`: You know what lifting is right?  (<$>) is ($) lifted into Functor.
08:25:19 <ion> f <$> Left a = Left a; f <$> Right a = Right (f a)
08:25:22 <bss_work> (sort of)
08:25:32 <joseanpg> roconnor: f (y:ys) = (y +1): f ys is guarded recursion?
08:25:45 <roconnor> joseanpg: yes
08:25:52 <erus`> i dont know the type of $, i know what it does
08:25:53 <ion> Right f <*> Right a = Right (f a); Left e <*> _ = Left e; _ <*> Left e = Left e
08:26:02 <ion> (i think)
08:26:22 <roconnor> erus`: $ is a low precidence version of whitespace.
08:26:32 <bss_work> ($) :: forall a b. (a -> b) -> a -> b
08:26:44 <roconnor> erus`: it is normally used to recude parentheses
08:26:51 <roconnor> erus`: thought it has a few other uses too
08:26:55 <erus`> roconnor: yeah i use it all the time
08:27:02 <erus`> i dont know how its written though
08:27:09 <roconnor> f $ x = f x
08:27:48 <bss_work> zipWith ($) [(+1), (*2), (^2)] [1,2,3] = [2,4,9]
08:28:29 <ion> Right a >>= f = f a; Left a >>= _ = Left a
08:28:53 <ion> pure = Right
08:29:03 <ion> I think those are the Functor, Applicative and Monad instances for Either e.
08:29:28 <roconnor> bss_work gives a good example of another use of ($)
08:30:08 <roconnor> I've also used foldr ($) z [f,g,h] on occasion
08:31:06 <ion> Also ($ x) somethingthatReturnsAFunction
08:31:44 <erus`> shit just got real
08:31:54 <ion> Say, >>= in http://hackage.haskell.org/packages/archive/enumerator/0.4.13.1/doc/html/src/Data-Enumerator.html#Iteratee
08:33:04 <erus`> omg
08:33:10 <erus`> everything is making sense
08:33:26 <bss_work> Careful, it's probably not quite everything yet.
08:33:43 <bss_work> It takes a few epiphanies to really get Haskell. ;)
08:34:16 <ion> erus: http://heh.fi/haskell/functors/
08:34:48 <erus`> thanks guys
08:34:52 <erus`> works over
08:35:03 <ion> In the case of Either, the behavior for all of them is “handle Rights as if they were pure values, stop processing when encountering a Left and return it as is”.
08:38:34 <ion> quicksilver: DefaultSuperclassInstances looks quite sensible indeed.
08:40:21 <quicksilver> ion: it seems that way to me and, as a bonus it actually has an implementation
08:40:28 <quicksilver> which is an important precondition to taking something seriously.
08:40:31 <ion> quicksilver: Cool
08:42:04 * hackagebot error-location 0.1.5.2 - error functions that show file location information  http://hackage.haskell.org/package/error-location-0.1.5.2 (GregWeber)
08:43:07 <parcs> wouldn't this 7.2 extension also 'fix' the monad/app/functor hierarchy?
08:43:08 <parcs> http://www.haskell.org/ghc/dist/stable/docs/html/users_guide/type-class-extensions.html#class-default-signatures
08:43:42 <parcs> just add a default Monad signature to Applicative and a default App signature to Functor
08:44:12 <ion> quicksilver: Still, won’t that need all the old code to add «hiding instance» lines if defining, say, both Monad and Applicative instances?
08:44:15 <parcs> i guess you would still have to say 'instance Foo Applciative'
08:44:31 <parcs> Applicative Foo*
08:44:35 <zygoloid> ion: yeah. that's the major drawback. some other proposals for the same problem don't have that issue
08:45:13 <bss_work> Pointed = Functor + pure, right?  Applicative = Pointed + <*>, right? Monad = Applicative + join, right?
08:45:33 <ion> Monad = Applicative + (one of >>= or join)
08:45:42 <zygoloid> (and it's not just an issue if/when base changes; library authors will sometimes want to do these sorts of shenanigans)
08:45:56 <bss_work> fail is not part of mathematical Monad, and can basically just be error all the time, right??
08:46:23 <quicksilver> bss_work: fail is handy for tricks like this:
08:46:34 * applicative cant find lambdabot :(
08:46:35 <zygoloid> so, why does DefaultSuperclassInstances use opt-out instead of opt-in?
08:46:56 <ion> class Monad m => MonadFail m where fail :: String -> m a
08:46:57 <quicksilver> > [ x | Left x <- [Left 1, Right 3, Left 4, Right 8] ]
08:47:11 <quicksilver> bss_work: well, run that in your ghci :)
08:47:23 <ion> And have the «do» and comprehension sugar depend on MonadFail if any patterns are used with bind.
08:47:28 <quicksilver> pattern match failure in list comps / do blocks uses fail, was my point.
08:47:33 <quicksilver> agreed, ion.
08:47:41 <ion> Well, any patterns that might not match.
08:47:53 <quicksilver> zygoloid: ask conor :)
08:48:33 <ion> Many monads have a “fail” that is not bottom.
08:48:39 <bss_work> quicksilver, I didn't realize list comprehensions were actually using fail from the Monad instance of [].  However, I started learning Haskell after Monad-comprehensions went away.
08:49:38 <ion> Say, fail in a parser monad may signify a failing parser.
08:50:17 <bss_work> fail :: Maybe a = const Nothing, fail :: [a] = const [], fail :: Either String a = id, yeah.  I know it's not always bottom, but it doesn't exactly have any restrictions on behavior from the Monad rules...
08:51:18 <quicksilver> no, it's not motivated by monad rules
08:51:30 <quicksilver> it's motivated by a convenient shortcut / plumbing hiding behaviour
08:51:31 <quicksilver> AFAIK
08:51:47 <quicksilver> it is of course a similar motivation which drove pattern guards
08:51:54 <quicksilver> although they don't require a crufty method to work :)
08:52:06 <bss_work> Heck, I think it's just a good idea to avoid introducing _|_ whenever possible.  All of those are quite sane defaults.
08:53:23 <bss_work> So, in the next Haskell standard are we thinking of moving fail into it's own TC?  MonadFail, e.g.?
08:55:20 <benmachine> bss_work: there's no official proposal stating that, but there's a lot of people who don't really like fail
08:56:22 <parcs> why don't they like fail?
08:56:28 <ion> Has SPJ said anything about fixing the functor class structure?
08:56:33 <bss_work> Not that I dislike fail that much, but it seems to follow the one-method-per-TC guideline I've heard before.
08:56:38 <ion> I take it he has some opinion about it?
08:57:33 <ohwow_> Hello, people. I have a question, not really related to haskell, but this is the most compscienc-y channel I know. I want to learn cat theory, but I suspect that I should have some background knowledge about abstract algebra. What exactly should I learn? I know a little bit of group theory, set theory and calculus.
08:57:47 <ohwow_> Can you recommend, perhaps, some online courses?
08:58:13 <bss_work> Well, moving fail to it's own TC would follow that guideline.  Functor = fmap, ..., Monad = Applicative + join, MonadFail = Monad + fail.
08:59:08 <benmachine> bss_work: I don't agree with one-method-per-TC in general, but the existence of fail meant that the fully general Monad instance for Either wasn't around until recently
08:59:14 <bss_work> ohwow_: All the category theory I learned was through learning Monads and Arrows.  So, all I can recommend is Haskell tutorials / books.
08:59:31 <benmachine> it gives String a privileged position which I think is a bit silly
09:00:06 * hackagebot double-conversion 0.2.0.1 - Fast conversion between double precision floating point and text  http://hackage.haskell.org/package/double-conversion-0.2.0.1 (BryanOSullivan)
09:00:19 <aristid> i think haskell as it is is not well-adapted to deep typeclass hierarchies, basically because you have to define separate instances for every class in the hierarchy
09:00:34 <benmachine> yeah, there's room for improvement
09:00:50 <bss_work> Giving String a privileged position seems wrong, especially with people wanting to use "stuff" notation for Text or ByteString values more and more.
09:00:55 <ion> DefaultSuperclassInstances would fix that, wouldn’t it?
09:01:24 <benmachine> ion: it might well do, but it's a bit of a thorny proposal for a few reasons
09:01:40 <mokus> ion: I think a more implicit version of that proposal would do so more cleanly
09:01:43 <benmachine> ion: do you know of anywhere it's really thoroughly discussed?
09:01:55 <ion> Nope, just encountered it myself when quicksilver linked it.
09:02:02 * benmachine scrolls up
09:02:19 <bss_work> ion: I didn't read the proposal to in depth, but it would be nice for me to put all the Num/Float/Real/Frac/etc. stuff into a single instance declaration when I'm fiddling with that.
09:02:32 <benmachine> ah right
09:02:40 <mokus> ion: eg, if class Functor f => Monad f, then instance Monad f would create Functor f as well if needed, and allow defining or defaulting fmap as if it were in Monad
09:02:54 <mokus> without any special extra syntax
09:03:01 <aristid> mokus: that might help :)
09:03:03 <benmachine> mokus: but where would you be allowed to define Functor f?
09:03:27 <mokus> benmachine: anywhere - if the Functor instance is in scope, then the Monad instance wouldn't create one
09:03:38 <ohwow_> Hm, okay, well I have another question, more applied to Haskell: how's Haskell's module system compared to Racket's?
09:03:58 <bss_work> That's sounds a bit problematic.
09:03:59 <benmachine> mokus: so anywhere further up the import tree than the monad instance?
09:04:11 <aristid> ohwow_: could you rephrase the question so that people who don't know racket's module system can answer? :)
09:04:23 <benmachine> mokus: so if module Foo defines a monad instance and module Bar defines Functor, then you can't import both
09:04:29 <benmachine> unless Foo also imported Bar
09:04:33 <mokus> benmachine: yes, or also in the same module an explicit instance Functor T would cause instance Monad T to not generate Functor T
09:04:49 <bss_work> What is package A.I gives a Functor instance, class B.I give a Monad instance but doesn't import A.I, and my package (Main) imports both A.I and B.I, both indirectly. :P
09:04:50 <mokus> benmachine: that's already true just by virtue of Functor f => Monad f
09:04:56 <benmachine> mokus: I suppose so
09:05:20 <benmachine> I remember there being some subtleties to the issue, but perhaps I'm being paranoid
09:05:42 <aristid> benmachine: i would disallow having a separate functor instance entirely, and allow defining fmap right in the Monad instance :)
09:05:48 <mokus> benmachine: I've got a fairly detailed proposal i've been working on off and on - there are subtleties, yes, but not very deep ones
09:06:11 <Botje> ohwow_: related to your CT question: you might want to check out james awodey's book about category theory.
09:06:13 <aristid> hmm wait no, that's stupid
09:06:14 <benmachine> aristid: hmm, possibly that makes sense
09:06:39 <mokus> aristid: that is a part of my proposal too, although separate instance is still allowed
09:06:43 <ohwow_> aristid: uh it would be rather hard, i spent some time learning it myslef. But I am a noob after all
09:06:43 <aristid> benmachine: that doesn't allow adding a Monad instance if you already have a Functor instance... so, file under "bad ideas"
09:06:55 <benmachine> aristid: ah, true.
09:06:55 <ohwow_> Botje: noted, thanks. But what should I learn before starting with CT?
09:06:58 <mokus> aristid: you can say 'instance Monad T where fmap = ...; (>>=) = ...; return = ...
09:07:36 <mokus> aristid: but you can only include the 'fmap' if there's not already a Functor instance somewhere else (in scope)
09:07:50 <mokus> my proposal also includes a syntax that makes the "inheritance" explicit
09:07:58 <mokus> instance Functor T, Monad T where ...
09:08:11 <Botje> ohwow_: the typeclassopedia is at the very least a good read :)
09:08:12 <mokus> and if you say instance Monad T where fmap = ..., then that's a warning
09:08:19 <aristid> mokus: have you written a GHC extension for it yet? :)
09:08:27 <bss_work> mokus: that doesn't save much typing if you are being explicit.
09:08:54 <mokus> bss_work: it does when it lets you bring in Monad's default fmap
09:09:13 <mokus> while at the same time being explicit 'for correctness sake'
09:09:21 <benmachine> mokus: I thought part of the purpose of the idea, though, was to let you not be explicit
09:09:30 <benmachine> so that you could change a class organisation without breaking old instances
09:09:35 <mokus> benmachine: that's why it's a warning, not an error
09:09:39 <benmachine> oh, right
09:09:54 <mokus> aristid: i haven't yet but I've been thinking about attempting the task
09:10:00 <aristid> mokus: i imagine the biggest problem when writing such an extension would be dealing with the module system
09:10:32 <hatds> it doesn't avoid breakage though... before you could define monad and functor separately and import them together in a third module.. that breaks under this system
09:11:00 <mokus> hatds: yes, but that has to break no matter what just by making Functor a superclass of Monad
09:11:14 <hatds> I see
09:11:28 <mokus> because any place there's Monad without functor now, there has to be Functor added one way or another
09:11:29 <quicksilver> hatds: I don't think (personally) you try to break that kind of code.
09:11:33 <quicksilver> erm
09:11:36 <hatds> so this defaulting is only if there is a superclass constraint
09:11:38 <quicksilver> try /not/ to break that kind of code.
09:11:44 <mokus> hatds: correct
09:12:21 <mokus> quicksilver: yea, my thoughts exactly - orphans are already "here be dragons", the proposal just lets one of the dragons have its lunch ;)
09:13:54 <mokus> aristid: i'm actually thinking the biggest challenge will be getting the information needed about "what's in scope" at the point needed in the compilation pipeline - I have a feeling that to implement it would require work in several stages of compilation, some of which will requiire info from later ones
09:14:14 <aristid> mokus: i think those problems are closely related.
09:14:14 <mokus> but that's just a guess, i haven't looked too hard at it yet
09:14:49 <c_wraith> sadly, orphan instances seem to be the least evil in a lot of cases.  My package could depend on everything it could provide an instance for, mostly useless to any given user, or orphan instances could be put in various packages.
09:14:53 <mokus> aristid: I think the module side of it will have already been dealt with, because interface info is neeeded very early
09:15:01 <aristid> mokus: for typeclasses, the "scope" is the transitive closure of all imports
09:15:10 <benmachine> c_wraith: agreed
09:15:30 <benmachine> orphan instances seem like a necessary evil sometimes
09:15:53 <mokus> c_wraith: true, but my point is that it's an independent issue; the breakage comes from making Functor => Monad, not from anything else
09:16:19 <mokus> the change I'm thinking of just eases that transition for all the non-orphan cases
09:16:27 <aristid> benmachine: edwardk was proposing something like "mixin" modules that are automatically imported when a combination of other modules is imported IIRC
09:16:34 <mokus> as well as making it more tractable in general to have deep typeclass heirarchies
09:16:47 <benmachine> aristid: yeah, but what package would you put them in? when would they be compiled?
09:17:06 <aristid> benmachine: there would also be mixin packages, i guess ;)
09:17:28 <benmachine> eep
09:18:08 <aristid> benmachine: for the time being, we have to live with orphan instances i guess :)
09:18:29 <benmachine> aristid: yep. or huge dependency lists
09:18:37 <benmachine> not naming any edwardks.
09:19:08 <mokus> to get away from the Monad heirarchy issue, it would be nice to be able to say things like 'instance Integral T where (==) = ... , compare = ...', etc., as well
09:19:30 <mokus> even more so when class heirarchies are taller, as in NumericPrelude / algebraic
09:19:37 <quicksilver> that is something the DefaultSuperclassInstance proposal permits, mokus
09:19:47 <mokus> er, 'algebra'? whatever the one that ekmett recently took over is called
09:19:55 <quicksilver> you can give definitions for any of the methods in the 'linked' classes in the one instance.
09:20:08 <bss_work> import ... if class? Applicative; would be an interesting way to handle mixins. :P
09:20:15 <mokus> quicksilver: yes, it's closely related to mine, but I feel like it's "nicer" without all the extra syntax
09:20:36 <mokus> plus the implicit version has the benefit that retroactive changes to typeclass heirarchies will break a whole lot less code
09:20:48 <quicksilver> I find it hard to get excited about this because I don't think people should write new typeclasses anyway :)
09:20:59 <mokus> heh
09:21:00 <bss_work> It's not about writing new typeclasses.
09:21:05 <quicksilver> although I'd quite like the existing ones to be easier to use.
09:21:11 <bss_work> It's about writing new instances for deeply nest typeclasses.
09:21:47 <aristid> quicksilver: you think they should use records with functions instead?
09:21:57 <bss_work> Instance {Eq/Ord/Num/Real/Float/Frac} MyData where ...
09:25:45 <hatds> deep hierarchies are still going to be ugly though, since if you are the creator of a datatype Foo and it's numeric instances then you need to know that you can supply a Foo into a function that has a Poset constraint, even though you've only defined an Integral instance
09:27:42 <mokus> hatds: true, but often intuition will tell you that it "should" work because something representing the integers 'ought' to be a poset
09:29:17 <hatds> mokus: yea, that's ok but it does invite having esoteric classes like BoundedModularLattice be superclasses of non-esoteric ones
09:29:19 <mokus> personally i'd prefer dealing with that complexity over having my function (which only really needs its arguments to be elements of a poset) have to have a significantly less general type
09:30:35 <bss_work> hatds: Also the "exotic" TCs could have defaults based on more "familiar" classes defined in the familiar classes.
09:30:42 <mokus> hatds: seems better than having to introduce silly classes in the place they're needed and then having them not be superclasses of existing 'useful' classes... but yea, class heirarchies really shouldn't try to anticipate every possible intermediate structure
09:31:09 <bss_work> hatds: Like having up and dn for Lattice be defined in terms of compare... e.g.
09:31:22 <hatds> there's a balance somewhere I'm sure
09:32:21 <bss_work> one-method-per-TC gives you alot of that intermediate structure, but it can also be quite a pain.
09:32:30 <mokus> hatds: agreed - and it's probably somewhere between the current numerical heirarchy and NumericPrelude - I think those are both fairly extreme, but in different directions
09:34:49 <mokus> hatds: in any case, if esoteric superclasses could be instantiated without the user having to think about it, I think that would be a good thing - because those classes (hackage proves ;)) will be created either way
09:34:55 <dolio> There are a lot of things you could do to make the current hierarchy better without going into hardcore mathematical correctness.
09:36:12 <mokus> dropping Show, abs and signum from Num would be a great start
09:36:14 <dolio> Like, remove the Eq and Show prerequisites to Num.
09:36:17 <dolio> Yes.
09:36:23 <bss_work> dolio: I think mokus's proposal makes it easier to implement the middle ground, it certainly doesn't force a heirarchy as deep as numeric-prelude.
09:36:30 <mokus> yea, Eq too
09:36:55 <hatds> why Eq?
09:37:12 <dolio> Some things that make sense as numbers don't have semidecidable equality.
09:37:22 <mokus> for example, real numbers
09:37:52 <hatds> but the Prelude doesn't concern it self with computable reals, leave that to libraries
09:37:53 <bss_work> http://en.wikipedia.org/wiki/Surreal_numbers
09:38:23 <mokus> bss_work: so does the one quicksilver linked, I just think it has a few minor things that could be improved - my suggestion is substantially the same
09:39:02 <bss_work> hards: But, if the prelude makes Eq a superclass on Num, libraries can make their types instances of Num without also making them instances of Eq.
09:39:19 <bss_work> So, It makes it quite a bit more difficult to have to good CReal type.
09:40:07 <mokus> bss_work: I think you a "not" or something;)
09:40:18 <bss_work> The current CReal is nice enough, but seems to be severely broken on MS Windows.  Also, approxRational doesn't work on it, which is mildly annoying.
09:40:34 <bss_work> s/can/cannot/
09:44:18 <roconnor> why is CReal broken on MS Windows?  It ought to be Haskell 98
09:44:26 <hatds> bss_work: I think it is a silly sacrifice to make for a CReal type that isn't in the Prelude.  Don't use the Prelude typeclasses if your type doesn't fit.
09:45:29 <bss_work> hatds: I don't really see what it sacrifices, Integer, CInt, Int, Char, CChar, Double, Float, ... etc. will all still be instances of Eq and Ord.
09:45:30 <mokus> hatds: there are a lot more types than CReal which make sense as numbers but not as Nums, and it it would be nice to be able to use existing functions with Num contexts on them
09:45:35 <roconnor> hatds: when you type ( 7 :: CReal) it is sugar from (fromInteger 7 :: CReal) and fromInteger is part of the Prelude heirarchy.
09:45:57 <mokus> hatds: one example I've run into is polynomials; they can't be Nums because of abs and signum, but aside from that they make perfect sense
09:46:00 <bss_work> roconnor: Oh, it compiles, it just doesn't behave like a computable real number.
09:46:14 <hatds> mokus: abs and signum could stand to be removed
09:46:20 <roconnor> bss_work: Why would it behave differently than on Unix?
09:47:18 <bss_work> roconnor: I didn't look into it.  But, on MS Window 1E-120 :: CReal = 0 :: CReal and that's not true on my Debian box at home.
09:47:31 <roconnor> I also think the sacrifices that CReal makes for Eq and Ord are bad choiced.  I've defined (x == y) to return False if they are unequal and return bottom if they are equal.  Not useful, but at least it doesn't lie.
09:47:39 <bss_work> I found out about it when I should have been doing actual work on the MS Windows laptop they issued me.
09:48:45 <bss_work> roconnor: I'll have to reproduce the CReal inconsistencies at some point now that I'm actually paid to work on a little Haskell.  (Not that we need to CReals for anything at work.)
09:50:00 <hatds> mokus, roconnor: my "PrimeNumber" datatype supports Real  if only it didn't have to support Num's plus operation...  should we change that too?  Likewise I can think of "instances" of Fractional that don't support +/-
09:51:12 <roconnor> hatds: how does your PrimeNumber datatype support * ?
09:51:19 <singpolyma> Is there a better way to do http://pastie.org/2310035 ? it's working, but it gives me a warning
09:51:28 <hatds> roconnor: +/* etc
09:51:30 <johannes__> hi guys
09:51:31 <mokus> hatds: well, as you said before - there's probably some middle ground.  personally I find the Eq and Show regrettable but wouldn't propose the hassle of changing them - signum and abs, on the other hand, are already of marginal use in the std library instances (eg Complex)
09:51:36 <roconnor> hatds: how does your PrimeNumber datatype support Real?
09:51:47 <hatds> :i Real
09:52:06 <hatds> :t toRational
09:52:15 <hatds> > :t toRational
09:52:18 <bss_work> I think lambdabot is still dead.
09:52:30 <hatds> toRational :: Real a => a -> Rational
09:54:07 <johannes__> i am reading some lambda calculus here.. and i am confused about the fixed point theorem
09:56:27 * hackagebot unix-compat 0.2.2.1 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.2.2.1 (JacobStanley)
10:01:51 <danharaj> johannes__: which fixed point theorem?
10:02:12 <johannes__> sorry .. my connection dropped
10:02:25 <johannes__> for all F there exists X such that FX = X..
10:02:41 <johannes__> how does that work.. since we have e.g., f(x) = x+1
10:03:01 <ciaranm> depends upon what your f is
10:03:14 <conal> johannes__: do you know what strictness is?
10:03:28 <johannes__> isn't that related to evaluation order
10:03:33 <danharaj> no
10:03:43 <danharaj> it's related to what happens when you apply a function to undefined
10:03:49 <conal> johannes__: no. strictness is a denotational property, not an operational one.
10:04:37 <conal> johannes__: strictness of a function f means that f _|_ == _|_
10:05:06 <conal> johannes__: in other words, _|_ is a fixpoint of f
10:05:16 <conal> (assuming f :: a -> a)
10:05:39 <danharaj> johannes__: So essentially, every function has a fixed point because we add one to all of their domains.
10:05:43 <conal> johannes__: e.g. f = \ x -> x + 1
10:06:07 <conal> danharaj: but _|_ is *not* a fixpoint of all functions. only of strict ones.
10:06:52 <bss_work> > fix (1:)
10:07:27 <singpolyma> Is there a better way to do http://pastie.org/2310035 ? it's working, but it gives me a warning
10:07:41 <monochrom> "f x = x" is good even if f is strict. that is not a problem. the real requirement is that f is continuous, or in some settings monotonic
10:08:11 <danharaj> conal: I've always thought of that as bottom being hidden by a more defined fixed point.
10:08:27 <conal> danharaj: "hidden"?
10:08:40 <danharaj> conal: You can't get to it because when you evaluate the function, you stop short at a more defined value.
10:09:19 <monochrom> but yes ⊥ is a fixed point of \x->x+1.  ⊥+1 = ⊥. there.
10:09:39 <conal> danharaj: interesting. are you speaking informally, in terms of a personal intuitive image?
10:10:12 <bscarlet> singpolyma: Thing { a = 1, b = 2, c = 3 }
10:10:35 <conal> danharaj: like you're traveling downward toward _|_ rather than upward from it?
10:10:39 <singpolyma> bscarlet: well, sure, but the whole point is that I want to build incrementally
10:10:50 <singpolyma> based on conditions or whatever
10:11:49 <bscarlet> singpolyma: that's very procedural thinking, yes? Can you put your conditions inside the constructor?
10:11:54 <danharaj> conal: Sort of how I interpret giving denotation to recursive functions by getting repeated approximations by applying to bottom first and going up from there.
10:12:32 * hackagebot bloomfilter 1.2.6.8 - Pure and impure Bloom Filter implementations.  http://hackage.haskell.org/package/bloomfilter-1.2.6.8 (BryanOSullivan)
10:12:37 <conal> danharaj: that's my model as well. iterating upward from _|_. and with strict functions, we never get any higher.
10:12:54 <singpolyma> bscarlet: Uh... maybe?  in the one actual case I'm looking at the construction of a whole bunch of attributes depends on the value for one of them (I'm writing a Data.Binary get instance)
10:13:03 <conal> singpolyma: the compiler is probably worried that you don't realize your f is only partially defined.
10:13:09 <bscarlet> singpolyma: but especially if there is some well defined default value, you can define defaultThing globally and then build up from it whereever you have to do this.
10:13:20 <singpolyma> The inspiration was that ((Type a) b) works fine
10:14:21 * benmachine tries to think of any standard record types with more than one field
10:14:23 <monochrom> ⊥ is at the bottom, so everything else "hides" ⊥ if you take "hides" to mean "is above"
10:14:36 <singpolyma> bscarlet: ooh, cool.  using a default value does sort of make sense.  and works well
10:14:37 <conal> singpolyma: you could define a global constant undefThing = Thing {a = undefined, b = undefined, c = undefined}, and then add to it incrementally wherever you want. e.g., let f = undefThing {a = 1} in ...
10:14:56 <singpolyma> conal: yeah.  I like that
10:15:40 <conal> singpolyma: though i also wonder if there might be a more elegant & statically _|_-avoiding style that'd work for you.
10:15:43 <hatds> singpolyma: http://pastie.org/2310145
10:16:03 <singpolyma> bscarlet: I will also look into putting the conditionals "inside" -- though that probably can't work since get returns a monad and so I need to use <- to get the value firstn
10:16:04 <rwbarton> you can also write something like  hello = Thing { a=a, b=b, c=c } where { a = ...; b = if a < 3 then ... else ...; ... }, is that "incremental" enough?
10:17:07 <singpolyma> hatds: yes, I know I can use the non-record syntax.  I was just wondering why non-record is fine, but the compiler complained about record syntax
10:17:34 <rwbarton> Thing { a = 1 } isn't a function of two more arguments, it's the same as Thing { a = 1, b = undefined, c = undefined }
10:17:43 <hatds> singpolyma: because record update syntax is not sugar for the helper function "thing" in my paste
10:17:44 <singpolyma> rwbarton: maybe.  the only thing is that I need to get values out of monads as part of it
10:17:49 <singpolyma> oh, I see.  that makes sense
10:17:56 <hpaste> DukeDave pasted “Converting function over lists to function over a foldable” at http://hpaste.org/49779
10:18:13 <rwbarton> right, so maybe  a <- getInteger ; (b, c) <- if a < 3 then ... else ... ; return Thing {a = a, b = b, c = c}
10:18:31 <DukeDave> Hi everyone, I wondered how I would go about converting that ^
10:18:50 <singpolyma> right, that might also work
10:18:59 <rwbarton> (don't name your variables a,b,c if shadowing the record selector functions offends you, of course)
10:19:19 * monochrom ♥ shadowing
10:19:26 <byorgey> DukeDave: well, every Foldable admits a toList function
10:19:42 <markamber> okay, I know this sounds bad, but I want to remove haskell and ghc, I still use it, just the server I am on needs more space and it is huge, I deleted the makefile stuff, so what is the best way now?
10:19:48 <markamber> I know, I am bad :(
10:20:02 <hpaste> DukeDave annotated “Converting function over lists to function over a foldable” with “Converting function over lists to function over a foldable (annotation)” at http://hpaste.org/49779#a49780
10:20:48 <DukeDave> Does that make sense? :|
10:20:58 <byorgey> DukeDave: so you can just define fsum = fsum' . toList  and define fsum' as in the paste
10:21:28 * DukeDave often finds himself guilty of using a list when it could be anything traversable/foldable
10:22:14 <DukeDave> byorgey: Ha, I never met toList before
10:22:35 <DukeDave> Is it (hypothetically) likely to cause efficiency problems?
10:23:03 <byorgey> DukeDave: I don't think so
10:23:06 <DukeDave> byorgey: ++
10:23:09 <DukeDave> byorgey ++
10:23:13 <DukeDave> byorgey++
10:23:18 <DukeDave> Do we still do that in here? :)
10:23:20 <benmachine> DukeDave: it's possible there's a faster implementation, but profile if you're worried :)
10:23:22 <byorgey> DukeDave: your 'average' function is more likely to cause problems than toList
10:23:43 <byorgey> DukeDave: since it has to hang onto the entire list xs while computing the sum since it needs it later to compute the length
10:24:07 <byorgey> you can fuse it into a single traversal which will end up being lazier
10:24:36 * hackagebot blaze-textual 0.2.0.1 - Fast rendering of common datatypes  http://hackage.haskell.org/package/blaze-textual-0.2.0.1 (BryanOSullivan)
10:24:37 <DukeDave> Ah yes, oh well, I'll save optimisation for later :)
10:24:42 <benmachine> byorgey: surely it won't be semantically lazier?
10:24:43 <DukeDave> Thank again though :)
10:24:52 <byorgey> DukeDave: sure, good luck =)
10:25:15 <benmachine> byorgey: you've got to evaluate the entire list and all its elements to calculate average, however you do it, right?
10:25:23 <benmachine> unless you have a lazy / or something odd
10:25:41 <byorgey> benmachine: yes, I used "lazier" incorrectly, it would have the same semantics
10:25:56 <benmachine> it'll be more memory-efficient
10:26:01 <byorgey> what I mean is that the fused version may be able to run in O(1) space whereas... right
10:26:27 <conal> byorgey: though there's a relationship to laziness.
10:26:36 <byorgey> conal: is there? what is it?
10:27:04 <erus`> @faq who is wrong; Palestine or Israel?
10:27:27 <erus`> will probably take while to compute...
10:27:30 <byorgey> erus`: apparently lambdabot doesn't want to get involved
10:27:51 <kmc> do you know if there's been any work toward implementing the lambda-case sugar in GHC?
10:27:57 <conal> byorgey: off the top of my head, something like: laziness postpones birth. and you're wanting to hasten death. both are attempts to shorten lifespan, but from different directions.
10:28:10 <kmc> «case of { alts }»  ≡  «\x → case x of { alts }»
10:28:13 <byorgey> conal: hmmm, interesting.
10:28:31 <conal> byorgey: and maybe not spot on for this particular example. but yeah, interesting nonetheless.
10:28:39 <DukeDave> Oh, ah, one problem, how do I represent the empty list [] for any foldable :|
10:28:57 <erus`> whats wrong with []?
10:29:22 <erus`> :t []
10:29:34 <byorgey> DukeDave: toList, in general, does not necessarily have an inverse
10:29:35 <danharaj> lambda bot is missing :[
10:29:47 <hpaste> DukeDave annotated “Converting function over lists to function over a foldable” with “Converting function over lists to function over a foldable (annotation)” at http://hpaste.org/49779#a49782
10:29:57 <kmc> erus`, it's a list, not generic over all Foldable
10:30:17 <erus`> mempty?
10:30:19 <DukeDave> Yeah, I guess I'll have to do the toList on the outside, and then match [] on the list
10:30:31 <kmc> erus`, that works if it's a monoid too
10:30:47 <amindfv> has anyone successfully installed Alex Mclean's livecoding programs? (besides him)
10:30:49 <byorgey> DukeDave: yes, that's what you have to do
10:31:02 <kmc> none of the Foldable methods allow you to create new Foldable values
10:31:15 <danharaj> those would be UNfoldable values. :p
10:31:24 <kmc> cofoldable ;P
10:33:59 <byorgey> hmm, what would a Cofoldable class look like?
10:35:23 <byorgey> I guess there would be   class Cofoldable t where   unfoldMap :: Comonoid m => (m -> a) -> m -> t a
10:35:45 <kmc> what's a comonoid look like?
10:36:20 <byorgey> I don't know what happens to mempty, but it would give you a function like   split :: m -> (m,m)
10:36:21 <erus`> can i get an argument from a partially applied function?
10:36:28 <kmc> erus`, what does that mean?
10:36:34 <kmc> you can't extract the x from (f x)
10:36:39 <erus`> ok
10:36:43 <kmc> not in general -- you can if 'f' gives you a way to do it, of course
10:36:59 <kmc> (you can also do it with unholy dark GHC magic)
10:37:09 <kmc> what are you trying to do?
10:37:18 <erus`> not use tuples
10:37:31 <erus`> i wanna store a set/list
10:37:39 <erus`> using only functions
10:37:53 <kmc> ah
10:38:13 <byorgey> erus`: check out "Church encoding"
10:38:34 <byorgey> the wikipedia page is decent
10:38:37 <rwbarton> if your notion of comonad is the one where split has type m -> (m,m) then the comonad laws force split to be \x -> (x,x) whatever m is
10:38:45 <kmc> hi rwbarton :)
10:38:51 <rwbarton> hey
10:39:06 <rwbarton> how's it going?
10:39:12 <kmc> goes all right
10:39:16 <byorgey> rwbarton: hmm, why is that?
10:39:39 <rwbarton> it follows from the left and right (co?)unit laws
10:39:57 <rwbarton> the counit just being m -> ()
10:41:07 <rwbarton> if you write out the unit laws for a monoid as a composition of tupling with the unit and then multiplying equalling the identity function and then reverse all the arrows, this is what you get
10:41:34 <rwbarton> comultiplication and then projection onto either factor must be the identity
10:43:18 <byorgey> oh, I see now
10:43:49 <byorgey> having a unit :: () -> m is nice but having a counit :: m -> ()  is worse than useless
10:44:28 <danharaj> but we have counit :p
10:44:59 <rwbarton> this argument only works because we chose the cartesian product as the monoidal operation, if you were in a setting like vector spaces and tensor product you can write down a lot of interesting comonoids ("coalgebras")
10:45:19 <byorgey> hehe, I mean, having a counit with the dual of the identity laws for unit.
10:45:27 <byorgey> ok.
10:46:09 <byorgey> so perhaps what we really want is a co-semigroup, that only gives us split
10:47:40 <scooty-puff> i often find myself want to writing a monad that is a combination reader/writer, where ask refers to the final written state
10:48:11 <scooty-puff> i.e. when building basic blocks, i would like to ask for the final IntMap BasicBlock, and write to the intermediate map a particular basic block
10:48:22 <scooty-puff> is this bad?  what are better ways?
10:49:07 <byorgey> scooty-puff: I don't understand.  You mean you want to import the final state from the future?
10:49:22 <byorgey> Or do you just mean that at some point you want to flip a switch and have the state become read-only?
10:49:29 <byorgey> or something else?
10:49:56 <scooty-puff> i want to import the final state from the future
10:50:18 <bscarlet> scooty-puff: does that not put you at high risk for making the final state dependent on itself?
10:51:04 <scooty-puff> i am concerned of that, but i did something similar for linking jumps to jump targets for forward jumps - just have to be careful to not be strict on the intermediate state i think
10:51:24 <scooty-puff> though an IntMap may not quite work - but could use a UArray or some such
10:51:43 <bscarlet> Why not two passes?
10:51:45 <scooty-puff> each basic block only needs to refer to its successors, not act on them
10:51:48 <byorgey> bscarlet: Haskell eats this sort of thing for breakfast, no worries =)
10:52:12 <byorgey> scooty-puff: sounds like a fun monad, I don't think it's bad
10:52:27 <byorgey> you should try implementing it and see what happens.
10:52:35 <scooty-puff> ok, thanks - i keep thinking of making one, but always dissuade myself its a bad idea for no apparent reason
10:53:18 <byorgey> scooty-puff: the one tricky thing about it is how you decide what the "final" state is
10:53:27 <bscarlet> byorgey: I'm not worried about the language having problems. Sure it'd work. I'm just worried about small stuff like engineering concerns: make a small change here and non-local properties of the design put you in an infinite loop.
10:53:36 <rwbarton> I think you have to "tie the knot" from outside the monad, otherwise I can't see how "x <- ask ; write y" will do what you want
10:53:57 <byorgey> scooty-puff: because if you have some computation m, you can always compose it with another like  m >> m'
10:54:15 <byorgey> you could just add a special operation "finalize" that fixes the final state
10:54:29 <scooty-puff> rwbarton: o yeah - was going to be like runWriter empty fed to runReader, or some such
10:54:29 <benmachine> have you guys heard of the reverse state monad?
10:54:30 <byorgey> so 'ask' gets whatever the state is at the first call to 'finalize'
10:55:09 <scooty-puff> byorgey: i don't mind escaping the monad ones the basic blocks are built
10:55:25 <scooty-puff> o, i see though
10:55:44 <rwbarton> bonus points for using indexed monads to statically ensure that there even is a following call to finalize
10:55:55 <byorgey> and only one!
10:55:59 <rwbarton> though maybe that's not necessary
10:56:07 <byorgey> would be nifty though =)
10:56:08 <benmachine> http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
10:56:46 <rwbarton> probably using a reader/writer monad with a specialized run function is the most practical approach
10:56:48 <scooty-puff> grr.. indexed monads - haven't found a good way to make the do syntax work with them and reg monads without a nasty all encompassing type class
10:57:01 <rwbarton> like you said
10:57:29 <scooty-puff> benmachine: looking at that now (go google!)
10:58:03 <benmachine> scooty-puff: I commented on it with a function to temporarily switch the state threading order
10:58:05 <scooty-puff> guess could have indexed monad and reg monad interop if just define a private'ish standalone type class that they both have instances of - would have bad overlap though i think
10:58:09 <benmachine> hard hats may be required :P
10:59:04 <scooty-puff> except for the differing kinds.. nevermind
11:00:03 <scooty-puff> i guess a newtype WrappedMonad?
11:00:07 <danharaj> :r
11:00:09 <danharaj> DAMNIT
11:00:19 <scooty-puff> ?
11:00:25 <danharaj> I missed.
11:03:59 <acfoltzer> anyone know what bit of code is responsible for cooking up the custom ~/.cabal/config for the Haskell Platform?
11:04:23 <acfoltzer> specifically, on OS X
11:05:00 <yitz> acfoltzer: mzero wrote it
11:05:09 <erus`> (\x y f -> f x y) this is a pair in untyped lambda calc
11:05:25 <erus`> can someone tell me how it works
11:05:55 <erus`> from wikipedia: λxyf.f x y
11:05:56 <kmc> > let p = (\f -> f 2 3) in p (\x y -> x)  -- fst
11:06:33 <kmc> erus`, that lambda term isn't a pair; it's the constructor of pairs
11:06:34 <acfoltzer> yitz: it looks like it's not being regenerated when just the config file is missing; I just want to see how cabal-install knows to generate the custom HP one vs the standard one
11:06:35 <kmc> it's Haskell's (,)
11:06:47 <kmc> the Haskell pair (2,3) would be represented by the term (\f -> f 2 3)
11:07:16 <erus`> ok
11:07:17 <yitz> acfoltzer: i think it's just a file in the Haskell Platform installation bundle for the Mac
11:07:42 <ion> (\f -> f 2 3) (\x y -> x) = (\x y -> x) 2 3 = 2
11:07:45 <yitz> acfoltzer: so what you do is get it from Time Machine. Or from anyone here on #haskell who has a mac. or whatever.
11:08:06 <wavded> super haskell nooby question,  I want to output to a file all the combinations of AAA - ZZZ and 0000 - 9999 (e.g. ASD-3232).  how do I do it?
11:08:10 <kmc> erus`, you can represent Either in a similar way
11:08:14 <acfoltzer> yitz: I don't need a new copy; cabal-install can cough it up again if I move/delete ~/.cabal
11:08:20 <kmc> Left x = \f g -> f x
11:08:23 <kmc> Right y = \f g -> g y
11:08:29 <erus`> aha
11:08:49 <kmc> > replicateM 3 ['A'..'Z']
11:08:53 <erus`> it seems like the wrong way round though?
11:08:54 <kmc> grr
11:08:57 <kmc> erus`, how so?
11:09:13 <acfoltzer> yitz: I just want to report the bug that cabal-install generates the standard one if just the config file is missing, rather than the whole ~/.cabal, which can make things all confused with library locations etc
11:09:16 <erus`> (\f -> f 2 3) (\x y -> x) instead of fst (2, 3)
11:09:25 <yitz> acfoltzer: right but it will give you the standard default config, which is meant for other platforms.
11:09:32 <kmc> erus`, you can define fst p = p (\x y -> x)
11:09:52 <erus`> ah i see
11:09:55 <yitz> acfoltzer: it's a feature request, not a bug. but good suggestion, please report it.
11:09:55 <wavded> <interactive>:1:0: Not in scope: `replicateM'
11:10:03 <erus`> it is a convenient trick
11:10:04 <kmc> wavded, import Control.Monad
11:10:20 <kmc> erus`, in fact you can represent all algebraic data this way
11:10:24 <acfoltzer> yitz: just want to know where to report it; HP, cabal-install, or ?. Sounds like HP
11:10:27 <yitz> acfoltzer: not sure how it would be implemented though. with CPP macros in the source for cabal-install?
11:10:33 <wavded> that worked
11:11:06 <acfoltzer> yitz: well, there already must be some mechanism in cabal-install or a HP-patched version thereof
11:11:07 <yitz> acfoltzer: yeah, it's not so clear. work out how to implement it, and then you'll know where to report it. :)
11:11:33 <yitz> acfoltzer: or just report it in one or the other and let them pass the buck from one to the other
11:11:40 <acfoltzer> :)
11:11:44 <yitz> acfoltzer: nope, no existing mechanism that i know of
11:12:04 <wavded> how about any 'string' from 0000-9999 ?
11:12:47 <ion> map concat . sequence $ [ replicateM 3 ['A'..'Z'], ["-"], replicateM 4 ['0'..'9'] ]
11:12:50 <ion> i think
11:13:31 <yitz> > map concat . sequence $ [ replicateM 3 ['A'..'B'], ["-"], replicateM 4 ['0'..'1'] ]
11:13:48 <erus`> kmc so this would work:    pair a b = (\f -> f a b) ?
11:13:57 <yitz> oh dear
11:14:02 <kmc> yes
11:14:04 <wavded> map concat . sequence $ [ replicateM 3 ['A'..'Z'], ["-"], replicateM 4 ['0'..'9'] ] seemed to work good
11:14:13 <kmc> erus`, you can write that as:  pair a b f = f a b
11:14:17 <kmc> your way might be clearer
11:14:19 <yitz> preflex: seen lambdabot
11:14:19 <preflex>  lambdabot was last seen on #haskell 3 hours, 24 minutes and 18 seconds ago, saying:   <no location info>: parse error on input `data'
11:14:35 <erus`> kmc and now we are back to the start :D awesome
11:14:36 <wavded> last question, how do I dump that output to a newline delimited file each 'item' on a line
11:14:54 <kmc> wavded, look at 'writeFile' and 'lines'
11:14:57 <kmc> er 'unlines'
11:15:05 <kmc> where's lambdabot...
11:15:20 <kmc> Cale, do you know where our lambdabot has run off to?
11:15:27 <mauke> preflex: seen Cale
11:15:27 <preflex>  Cale was last seen on #haskell 13 hours, 48 minutes and 43 seconds ago, saying: It looks like currently the lambdacube on Hackage is using OpenGLRaw
11:15:28 <wavded> will do thanks!
11:15:38 <ion> Cale ran off with her.
11:15:43 <kmc> no doubt
11:16:03 <yitz> @tell hi Cale please check \bot. she's down as of now. thanks!
11:16:07 <yitz> oops
11:16:10 <ion> :-D
11:16:15 <kmc> when lambdabot is not here i usually assume she's hung over
11:16:18 <yitz> can preflex do that"
11:16:19 <yitz> ?
11:16:21 <acowley> is edwardk here under a pseudonym?
11:16:25 <tech2> poor lambdabot
11:16:36 <kmc> acowley, HE'S WATCHING YOU
11:16:37 <kmc> :D
11:16:38 <mauke> yitz: yes
11:16:50 <acowley> kmc: I wish I knew you were joking :|
11:16:53 <yitz> preflex: help
11:16:54 <preflex>  try 'help help' or see 'list' for available commands
11:17:00 <yitz> preflex: help tell
11:17:00 <preflex>  tell NICK MESSAGE - when NICK shows activity, tell them MESSAGE
11:17:21 <yitz> preflex: tell Cale hi Cale please check \bot. she's down as of now. thanks!
11:17:21 <preflex>  Consider it noted.
11:22:20 <acowley> Does IArray.assocs return associations in ascending order?
11:22:23 <heatsink> is there a way to profile Template Haskell?
11:23:02 <kmc> heatsink, you mean the compile-time execution of splices, or the run-time execution of generated code?
11:23:10 <heatsink> Compile-time execution of splices
11:23:12 <c_wraith> acowley: it should return them in Ix order
11:23:16 <acowley> hrm. Data.Array says "index order" IArray doesn't specify
11:23:38 <kmc> heatsink, that's hard, since splices run in the same RTS as GHC itself
11:23:50 <kmc> and you can't link profiling and non-profiling code
11:23:51 <acowley> c_wraith: docs could stand some clarification
11:23:55 <heatsink> right.
11:23:56 <kmc> you'd have to build GHC for profiling basically
11:24:04 <c_wraith> acowley: I don't disagree with that.
11:24:10 <parcs> heatsink: runIO and getCurrentTime for an ad-hoc solution
11:24:23 <kmc> i think the best you can do easily is to write a program that spits out the generated code on stdout
11:24:24 <heatsink> Ok, I can try inserting timers.
11:24:28 <kmc> (or just forces it)
11:24:34 <kmc> and profile that
11:24:55 <kmc> there's some function Q a -> IO a
11:25:15 <heatsink> Oh, I see what you mean
11:25:16 <kmc> so something like main = do { x <- runQ mySplice; evaluate x }
11:26:02 <heatsink> I can do (print $ ppr x) I think
11:26:14 <kmc> ah
11:26:42 <wavded> another noob question, so typingimport Control.Monad
11:26:44 <wavded> map concat . sequence $ [ replicateM 3 ['A'..'Z'], ["-"], replicateM 4 ['0'..'9'] ]
11:27:06 <wavded> woops wrong enter... anyway, typing the above in ghci worked great but trying to compile it doesn't work
11:27:13 <wavded>     Couldn't match expected type `Language.Haskell.TH.Syntax.Q
11:27:15 <wavded>                                     [Language.Haskell.TH.Syntax.Dec]'
11:27:17 <wavded>            against inferred type `[[Char]]'
11:27:19 <wavded>     In the expression:
11:27:21 <wavded>             map concat . sequence
11:27:21 <kmc> yeah, that error message is useless
11:27:23 <wavded>         $ [replicateM 3 ['A' .. 'Z'], ["-"], replicateM 4 ['0' .. '9']]
11:27:25 <kmc> wavded, don't paste big text here
11:27:27 <kmc> use hpaste.org
11:27:29 <wavded> sorry
11:27:46 <kmc> wavded, a GHCi session is a series of statements but a file is a series of declarations
11:27:57 <kmc> main = print (map concat . sequence $ ... stuff ...)
11:28:12 <kmc> wavded, this should be covered by a haskell tutorial
11:28:24 <wavded> yeah most of tuts i've found are all in the ghci
11:28:32 <kmc> they get to compilation eventually
11:28:52 <erus`> kmc how can i do conditionals with only functions?
11:29:30 <wavded> ok thx, main = print ... etc.. worked
11:29:31 <kmc> true x y = x; false x y = y; if_then_else_ b t f = b t f
11:29:47 <ion> erus: http://en.wikipedia.org/wiki/Church_encoding#Church_booleans
11:30:07 <kmc> erus`, more complicated if you have a lambda calculus with strict semantics and you want short-circuiting (i.e. non-strict) conditionals
11:30:14 <mauke> true = const; false = const id; if_then_else_ = id
11:31:04 <kmc> erus`, the general idea here is:  your data type (pairs, Either, Bool) becomes a function which takes one or more "continuation" functions
11:31:15 <kmc> and calls the appropriate one with the appropriate arguments
11:31:32 <erus`> aha
11:32:34 <kmc> just x = \d f -> f x;   nothing = \d f -> d
11:33:06 <erus`> everything looks like its working back to front
11:33:30 <erus`> clever
11:34:22 <kmc> it would be fun to compile Haskell into a pure lambda calculus this way
11:36:32 <erus`> im making my own language
11:36:39 <erus`> as minimal as possible
11:37:05 <c_wraith> more minimal than brainfuck?
11:37:28 <erus`> functional brainfuck
11:37:36 <danharaj> funfuck
11:37:38 <ion> More minimal than SK calculus?
11:37:40 <erus`> but not lazy k because its too hard to read
11:37:44 <kmc> erus`, have you seen Unlambda and Lazy K
11:37:45 <kmc> heh
11:38:12 <erus`> mine will have multi character identifiers
11:38:17 <erus`> but thats it
11:38:25 <kmc> there are languages much more minimal than brainfuck
11:38:33 <kmc> ("more minimal", heh)
11:38:53 <kmc> there's a language where the only instruction is "decrement and jump if non zero"
11:38:53 <ion> kmc: Not in scope: heh
11:39:17 <erus`> lol
11:40:23 <erus`> im gonna do IO by passing a 'world' around
11:40:29 <erus`> is that a bad idea?
11:40:38 <c_wraith> probably.
11:40:46 <c_wraith> the model doesn't really work.
11:41:03 <c_wraith> edward k had a better model described on his blog recently
11:41:14 <danharaj> is there a nice way to refer to the "a -> b -> c ->" part of "a -> b -> c -> d"?
11:41:40 <Scriptor> c_wraith: what's the url for his blog?
11:41:57 <danharaj> http://comonad.com/reader/
11:41:59 <copumpkin> danharaj: the uncurried domain!
11:42:00 <copumpkin> :P
11:42:32 <c_wraith> I forget which article talked about this, though
11:42:55 <danharaj> Free Monads for Less Part 3
11:43:05 <danharaj> : The Monad Strikes Back
11:43:15 <Scriptor> ah, thanks
11:43:21 <tech2> cute
11:43:33 <c_wraith> oh, hey, the one with IO in the title
11:43:33 <Scriptor> I really need to get back to reading lyah
11:43:36 <c_wraith> how about that.
11:43:38 <danharaj> (the title is actually Yielding IO)
11:43:48 <danharaj> c_wraith: Yeah seriously, who does that?
11:51:35 <bobzhang> can anyone help me figure out the type signature?
11:51:47 <bobzhang> testA p f g= proc x -> if p x then f -< x else g -< x
11:51:47 <bobzhang>  
11:52:02 <bobzhang> testA :: ArrowChoice t1 => (t2 -> t3) -> t1 t2 t4 -> t1 t2 t4 -> t1 t2 t
11:52:02 <bobzhang>  
11:52:17 <bobzhang> I thought p should be t2 -> Bool
11:52:24 <bobzhang> but it is not
11:52:34 <c_wraith> ugh, arrow syntax extension
11:52:55 <bobzhang> c_wraith: yeah, the signature is a little strange
11:53:05 <c_wraith> no, the signature is fine
11:53:10 <c_wraith> it's the -< stuff
11:53:15 <c_wraith> in the implementation
11:53:28 <bobzhang> the p should not be t2 -> Bool??
11:53:48 <bobzhang> what's t3?
11:54:20 <c_wraith> Do you have an extension like RebindableSyntax on?
11:54:30 <bobzhang> just -XArrows
11:54:44 <bss_work> Maybe -XArrows implies rebindable syntax?
11:55:12 <bss_work> Then "if x then y else x" = "ifThenElse x y z"
11:55:43 <erus`> do i apply a value to a function? is that the correct terminology?
11:55:52 <c_wraith> I doubt that, though.  the Arrows extension predates the rebindable syntax extension
11:55:54 <bobzhang> where is ifThenElse??
11:56:12 <c_wraith> erus`: other way around.  functions are applied to values
11:56:31 <erus`> f x means applying function f to x?
11:56:49 <bss_work> c_wraith: Okay.  Well, then I think p should be t2 -> Bool, too.
11:57:04 <bss_work> > (+) 1 2
11:57:04 <bss_work> 3
11:57:18 <acowley> ad is 4x faster
11:57:23 <erus`> value x*
11:57:30 <bobzhang> anyway to get the result after translation, like -ddump-splices for template haskell
11:57:32 <acowley> I hope edwardk comes by later
11:57:56 <acowley> Gradients of 16384 partial derivatives, now! (actually it takes ~2min.)
11:57:59 <c_wraith> bobzhang: that's definitely strange.  I want to blame it on proc notation *somehow*, because that's the only thing strange (to me) about what's there.
11:58:14 <bss_work> I think it is part of the arrow notation.
11:58:38 <bss_work> ArrowChoice has some doc strings that basically imply it's operations are used for if/then/else in arrow notation.
11:58:47 <doserj> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/arrow-notation.html#id555930
11:59:25 <danharaj> acowley: Since you're here, do you know if it's possible to send fragments directly to a pixel shader in order to paint pixels directly to framebuffer in OpenGL?
11:59:47 <acowley> you have to use a sampler
12:00:02 <bobzhang> doserj: yeah, so why p is t2 -> t3, not t2 -> Bool
12:00:08 <danharaj> gross. See, I'm trying to render text, and sampling with Nearest loses information and sampling with Linear makes it too smooth.
12:00:38 <acowley> danharaj: that's a legitimately hard thing you're wanting to do
12:00:55 <acowley> danharaj: you can check out the various vectorizers people have written for sprite scaling in console emulators
12:01:23 <acowley> danharaj: also note this is why vector font definitions are so common
12:01:48 <danharaj> acowley: :\ What I'm doing right now is rasterizing CPU-side, then painting a quad. I suppose I should think about vector fonts and stuff. Thanks.
12:02:08 <acowley> why don't you rasterize at various scales
12:02:18 <acowley> and pick the scale in the vector shader
12:02:25 <kmc> http://research.microsoft.com/en-us/um/people/kopf/pixelart/   ←  amazing sprite scaler
12:02:26 <acowley> vertex shader
12:02:55 <acowley> well
12:03:13 <acowley> does the normal mipmap hierarchy not have enough levels for you?
12:03:36 <acowley> If it doesn't, then I'd do my own mipmapping. If it does, then life is good.
12:03:54 <acowley> kmc: yeah, they have some really awesome results
12:04:00 <danharaj> acowley: Well, the problem is small sizes actually. Rendering to a quad that gets rasterized to the same pixels as my texture works fine when the glyph size is large enough, but at around 12 pt. 72 dpi, I lose a few lines on some glyphs. It's a bit annoying.
12:04:18 <danharaj> particularly the horizontal bar on .
12:04:19 <danharaj> e*
12:04:30 <acowley> hm
12:04:35 <acowley> write your own minification filter
12:04:41 <acowley> that preserves edges
12:05:32 <danharaj> acowley: hmm. I wonder if I could access texels directly in the fragment shader and guess properly which nearest neighbor texels I should pick?
12:05:36 <acowley> you can take a few samples from the font texture, and implement some little heuristic to avoid losing thin lines
12:05:39 <acowley> yes
12:05:40 <danharaj> actually that's what you just said, I suppose.
12:06:33 <acowley> danharaj: check out the sprite scaler stuff, since what you want is a much more limited version of that
12:06:39 <acowley> maybe you can pick up a technique or two from them
12:06:44 <danharaj> ok cool.
12:07:01 <danharaj> It's a little ironic that rendering pixels is harder than rendering geometry, in my mind :p
12:07:42 <danharaj> Where should I look?
12:09:35 <acowley> the link kmc pasted
12:09:58 <acowley> pixels are a rendering artifact
12:10:00 <danharaj> I totally missed that :o
12:10:15 <acowley> they don't have enough information and tend to be dirty
12:12:16 <ryant5000> how do i make sure that the key of a weak reference doesn't get unboxed and collected?
12:12:21 <danharaj> acowley: I suppose. It'd be nice if I could blit to a framebuffer directly though, with processing by a fragment shader.
12:12:53 <kmc> danharaj, yeah, the only way I know to do that is to load a texture and draw a flat quad
12:12:55 <acowley> danharaj: how is blitting to a texture object and rendering a full-viewport quad any different?
12:13:53 <danharaj> acowley: Well apparently it is :\. What I've been doing is measuring a quad in pixels, using a vertex shader that scales it appropriately so pixels should correspond to viewed pixels, but apparently there's some very slight rounding issues that is messing up sampling.
12:14:13 <kmc> bah
12:14:15 <kmc> there shouldn't be
12:14:37 <kmc> are you using a rectangular texture
12:14:42 <danharaj> kmc: yeah.
12:14:43 <kmc> with texture coordinates measured in px?
12:15:08 <acowley> I'm not totally clear on what your vertex shader is doing
12:15:25 <acowley> because you really want integral vertex coordinates
12:15:33 <kmc> danharaj, why scale in the vertex shader
12:15:35 <acowley> any scaling will throw things off
12:15:39 <kmc> and not by manipulating the modelview matrix
12:15:49 <danharaj> I thought the vertex shader has to pass on normalized coordinates?
12:15:56 * kmc doesn't remember
12:16:07 <acowley> Yeah, I think it does
12:16:14 <acowley> hm
12:16:32 <danharaj> yeah, that's what I do. I scale from, say 800 x 600 if that's my screen to -1.0 to 1.0 etc.
12:16:41 <acowley> if you have some code, can you paste it somewhere so we can all take a look?
12:16:47 <danharaj> sure
12:17:11 <danharaj> I'm passing in normalized texture coordinates, maybe I should pass in pixel coordinates instead?
12:17:42 <kmc> i need (for my talk) a really short, compelling example of pure parallelism
12:17:51 <kmc> something like searching a game tree in parallel
12:18:01 <danharaj> What about rendering pixels to a screen :p
12:18:03 <kmc> but i don't think that will fit on one slide
12:20:12 <danharaj> http://hpaste.org/49783
12:20:34 <acowley> kmc: my OpenCV examples include some that use par to speed up certain composite realtime video effects
12:20:46 <kmc> nifty!
12:20:55 <kmc> i love composite realtime video effects
12:21:55 <acowley> my favorite example is a kind "blueprint" effect that runs an edge detector for white lines, and an adaptive threshold for two blue tones. Those results are done in parallel and then or'ed.
12:22:17 <kmc> nice
12:25:00 <acowley> kmc: you could run it on your laptop as part of the presentation if you have a webcam
12:25:05 <kmc> true
12:25:09 <danharaj> haha that would be sweet
12:25:17 <kmc> doing stuff like that might make it more entertaining
12:26:58 <kmc> acowley, once upon a time i made a Haskell EDSL for writing video filters that compile to GLSL, and another EDSL for wiring filters together with input/output sources
12:27:44 <acowley> kmc: that sounds great!
12:27:50 <kmc> it was fun
12:28:08 <kmc> i think conal is working on something better along those lines
12:29:04 <kmc> it was a term project for two courses at once
12:29:10 <kmc> a languages course and a graphics course :)
12:29:24 * kmc still isn't entirely sure they should have let him get away with that
12:30:10 <roconnor> @wn automata
12:31:14 <danharaj> I wonder if Nvidia or Ati could be convinced to write a purely functional shader language.
12:32:55 <copumpkin> danharaj: HAHAHAHAHAHAH
12:33:01 <copumpkin> danharaj: HAHAHAHAHAHAHAHAHAHAHAH
12:33:30 <kmc> the existing shader languages are close to purely functional
12:33:40 <kmc> they're just written with C-like syntax to avoid scaring people
12:33:53 <kmc> there's no interacting global state in GLSL
12:34:01 <danharaj> kmc: I want (.) :[
12:34:07 <kmc> right
12:34:16 <kmc> i guess your emphasis is on the "functional" part and not the "purely"
12:34:31 <kmc> fair enough
12:34:54 <danharaj> well also having no assignments explicitly withing shaders would be nice too
12:39:45 <acowley> danharaj: can you try using nicer dimensions that 300x400? Something like 512x512?
12:40:23 <acowley> the thing about assignments in shaders is that you very often do want to refer to the same value several times
12:40:27 <acowley> so there'd be lots of lets
12:40:52 <acowley> which doesn't look all that different from imperative assignment to temporaries
12:41:02 <roconnor> at one point I decide that BASIC either was or is close to a purely imperitive language.
12:41:06 <roconnor> *decided
12:43:14 <danharaj> acowley: true. The dimensions are actually 800x600, since that's the window size I'm testing with currently. Why will making it square change anything?
12:47:08 <chrisdone> is there a way with the binary package to do something equivalent to Alternative like get <|> pure y?
12:47:30 <Saizan> no
12:47:44 <chrisdone> tricky
12:48:07 <roconnor> chrisdone: if you use cereal, Data.Serialize.Get is an instance of MonadPlus.
12:48:25 <chrisdone> i've already written all my codes with binary :/
12:48:43 <roconnor> chrisdone: the interfaces are almost the same
12:49:01 <roconnor> chrisdone: as a rule of thumb, avoid any packages shipped with the Haskell Plaform.
12:49:32 <byorgey> @remember roconnor as a rule of thumb, avoid any packages shipped with the Haskell Plaform.
12:49:39 <byorgey> oh, no \bot
12:49:51 <roconnor> byorgey: you'll have to remember for now
12:49:57 <byorgey> remember what?
12:50:02 <byorgey> ;)
12:50:06 <roconnor> *lol*
12:50:34 <mauke> I'd tell you to use preflex instead but I don't find the quote that funny
12:50:58 <roconnor> chrisdone: er and it is also an Applicative so you can use that code of yours directly.
12:51:37 <chrisdone> bleh i've already tested this code for months, i'm not rewriting with another library. i'll just do this one thing the less convenient way
12:51:39 <dibblego> teaching Haskell at a regular conference http://bit.ly/qb4r9f (SPJ and John Huges are also speakers)
12:51:52 <dibblego> thought some of you would like that!
12:52:47 <roconnor> ... and the Haskell Platform ruins another project ...
12:53:36 <Igloo> binary isn't in the HP, FWIW
12:53:39 <chrisdone> i've never used the haskell platform. i looked for 'binary' on hackage and used that package
12:53:51 <roconnor> oh
12:54:05 * roconnor retracts his slight to the HP
12:54:26 <chrisdone> again, hackage needs quality voting or somesuch. Hackage 2 Forever will surely be delivered
12:54:54 <roconnor> Igloo: hmm, I coudl have sworn it was in there.
12:54:57 <tgeeky> elders / vimmers: which fonts will support utf8 in gvim?
12:55:02 <roconnor> Haskell Platform, I owe you an appology
12:55:02 * Igloo still thinks you need an editor, rahter than voting
12:55:32 <mauke> tgeeky: I use DejaVu Sans Mono
12:55:40 <Igloo> Things like http://www.tex.ac.uk/cgi-bin/texfaq2html?label=letterclass
12:56:18 * hackagebot maccatcher 2.1.2 - Obtain the host MAC address on *NIX and Windows.  http://hackage.haskell.org/package/maccatcher-2.1.2 (JasonDusek)
12:56:46 <roconnor> chrisdone: the interfaces between the two packages are really almost identical.  The major difference is that cereal operates on strict bytestrings; so if you need lazy bytestrings then you won't want to switch.
12:56:48 <chrisdone> Igloo: well whatever—just some indication of quality. it's getting wearisome having to do QA on someone else's library
12:56:50 <heatsink> chrisdone, add +1 button to package pages on hackage?
12:57:04 <tgeeky> mauke: https://github.com/Twinside/vim-haskellConceal/blob/master/after/syntax/haskell.vim doesn't say DJM doesn't have the conceal characters, but it doesn't
12:57:35 <hpaste> erus` pasted “function application” at http://hpaste.org/49785
12:57:49 <clsmith> i had to read that three times. too many doesn'ts.
12:58:02 <tgeeky> clsmith: yes, probably
12:58:48 <tgeeky> mauke: there exist (in this file) a list of fonts which supposedly do not support the proper extra unicode characters. I was using one on the list. DejaVu Sans Mono is not on the list of bad fonts, but it should be. What fonts are next? :O
12:59:31 <chrisdone> roconnor: the APIs are the same—is the behaviour? bleh. 30 minutes left on battery. i'll try it tomorrow
13:00:18 <heatsink> tgeeky: If you're looknig for free fonts with a big character set, try Anonymous Pro.
13:00:29 <tgeeky> heatsink: that also doesn't work, weirdly.
13:00:34 <heatsink> huh
13:00:57 <tgeeky> yeah, all of the UTF-8 chars are just boxes
13:01:02 <tgeeky> (inside gvim, anyway)
13:01:10 <clsmith> what is it with 'scrap your boiletplate'? seems to have crazy confusing types. i'm probably missing the point, but it just seems so opaque
13:01:18 <kmc> clsmith, did you read the papers?
13:01:59 <kmc> the point is that I can write a function of type Foo -> Foo and then apply it to *any* complicated nested algebraic data structure that has a Foo buried somewhere within
13:02:01 <heatsink> Well, the only other candidate that I know of is Menlo, which isn't free but comes with Apple products.
13:02:16 <kmc> and yeah it's a pretty heavyweight way to accomplish this goal
13:02:23 <kmc> see Uniplate as an alternative
13:02:36 <clsmith> kmc: i read one, but looking the list i don't think it was the 'intro'
13:02:44 <roconnor> chrisdone: the functional behaviour on the non-failing monadic code is the same; however decode will return type (Either String a), with Left "foo" indicating an error, rather than type (a).
13:03:05 <tgeeky> roconnor: should everyone be using the kind of thing you described in your f <is-to> lens <as> applicative <is-to> biplate paper (instead of SYB-style or whatever uniplate recommends?)
13:03:05 <kmc> i think you want "Scrap your boilerplate: a practical approach to generic programming, "
13:03:31 <roconnor> tgeeky: yes I think so;  That said my library is not well exercised yet.
13:03:42 <mustelo> what happened to lambdabot?
13:03:45 <roconnor> scrap your boilerplate makes some of us throw up.
13:03:59 <kmc> mustelo, hung over
13:04:11 <mustelo> on a tuesday...? damn.
13:04:14 <roconnor> that said you can do more horrible horrible things with SYB that you cannot do with uniplate/multiplate.
13:04:36 <mauke> tgeeky: it has all characters except for undefined, -<<, >>-, and ..
13:05:05 <mauke> tgeeky: and undefined can be fixed by using UP TACK instead of LARGE UP TACK
13:05:09 <tgeeky> mauke: ok. better than what I had.
13:05:19 <chrisdone> roconnor: it's the code for my postgres library. hpaste.org's been testing it for me for months. i need to write unit tests anyway but nothing beats months of IRL testing. oh well, we'll see
13:05:20 <tgeeky> I actually think using conceal is a *terrible* idea
13:05:32 <mauke> tgeeky: and I can see all characters here by using vim instead of gvim
13:05:39 <mauke> (my terminal can use multiple fonts at once)
13:05:52 <roconnor> chrisdone: ... I can think of one thing that beats months of IRL testing ... :D
13:05:58 <chrisdone> mauke: as fallbacks?
13:06:09 <chrisdone> roconnor: years of IRL testing? an agda proof?
13:06:14 <mauke> the missing operators are being loaded from Sazanami Mincho
13:06:15 <roconnor> chrisdone: an agda proof
13:06:25 <chrisdone> roconnor: let me know when you're done :p
13:06:35 <roconnor> months of agda proof writing :P
13:06:57 <mauke> > deriv (sin + cos) x
13:07:29 <roconnor> 1 * cos x + (-1) * 1 * sin x
13:07:30 <chrisdone> actually that sounds like a fun long term goal project for learning agda. not sure when i'll get round to agda, too busy doing 'real' stuff
13:08:02 <copumpkin> ohai
13:08:11 <copumpkin> roconnor: I made epic proof in agda!
13:08:21 <roconnor> nice.  That is difficult.
13:08:31 <copumpkin> no, I'm just overstating it's epicosity
13:08:37 <copumpkin> it's pretty boring really
13:08:42 <roconnor> copumpkin: I proved the fundamental theorem of galois theory.  What did you prove?
13:08:43 <c_wraith> did you prove n + 0 = 0 + n?
13:08:59 <chrisdone> isn't that an axiom
13:09:15 <c_wraith> depends on your construction
13:09:15 <copumpkin> I proved that if you have a semigroup and fold it in any order over a suitably sized vector, you get the same answer. Also that foldl1 = foldr1 in that case
13:09:16 * chrisdone missed the joke :(
13:09:31 <copumpkin> also, if you have a commutative semigroup, you can fold in any reduction order and any permutation over the vector
13:09:31 <roconnor> copumpkin: nice.  Very suitable for agda.
13:09:33 <copumpkin> and get the same answer
13:09:46 <frigga> Can GHC link with foreign C libraries distributed as a .a file?
13:09:47 <copumpkin> so I have a type for reduction orders and another type for permutations
13:11:05 <djh_> i'm trying to use regular expressions in haskell
13:11:08 <djh_> following this blog post
13:11:09 <djh_> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
13:11:15 <copumpkin> that way lies madness
13:11:16 <djh_> but none of the examples seem to work
13:11:18 <c_wraith> frigga: sure.  it just uses LD to do the linking.  It does need header files, of course.
13:11:33 <chrisdone> i love the pic of the wee guy looking like el chap while coding http://www.bnj.com/cowboy-coding-pink-sombrero/
13:11:44 <djh_> "quux" =~ "(foo|bar)" :: Bool
13:11:46 <copumpkin> roconnor: the proofs are up on https://github.com/copumpkin/containers if you're curious :)
13:11:46 <c_wraith> djh_: that library changed significantly after that post
13:11:54 <copumpkin> roconnor: I bet they'd be 10 lines total in coq :(
13:12:03 <chrisdone> amusingly, that post is probably still the top google result
13:12:12 <c_wraith> djh_: best to not use regular expressions, anyway.  (there are few cases they're really good for in haskell)
13:12:28 <ion> djh: What do you wish to use regexes for?
13:12:30 <djh_> c_wraith - are there any tutorials or example pages or anything that reference how the library can be used today
13:12:36 <frigga> c_wraith: Hmmm, I tried a basic test implementing a wrapper for one function, but when I run ghci with -lmylib, it says .o/.so/.DLL could not be loaded.
13:12:51 <frigga> c_wraith: Which makes sense since the file is a .a
13:13:08 <c_wraith> frigga: ghci does its own linking, rather than using the system linker.
13:13:23 <djh_> ion - basically I have a string that's like this <useless information to me>S01E01<uselessinformation>
13:13:34 <djh_> i want to extract the S bit
13:13:43 <frigga> c_wraith: Oh, so it will work with ghc, but not ghci?
13:13:55 <djh_> in effect it's S/d/dE/d/d
13:13:57 <c_wraith> frigga: I can't guarantee that...  But I think it can.
13:14:07 <frigga> Ok, I'll try it.
13:14:18 <djh_> but I want to pull that out of a string that could be any length
13:14:48 <chrisdone> someone's scraping for LOST torrents ;p
13:14:58 <frigga> c_wraith: The ghci linker doesn't work with .a files at all?
13:15:08 <heatsink> GHCi does not.
13:15:11 <djh_> not quite but....well.....;)
13:15:25 <frigga> heatsink: Ok, thanks.
13:16:39 <chrisdone> i've say this is an occasion where regexes are the right choice
13:16:47 <chrisdone> i like Text.Regex from regex-compat
13:17:21 <copumpkin> REGEX IS NEVER THE ANSWER
13:17:54 <chrisdone> matchRegex (mkRegex "S([0-9]{2})E([0-9]{2})") " me>S01E01<uselessinfor" :: Maybe [String]
13:17:58 <chrisdone> my battery's gonna die
13:18:00 <chrisdone> ciao
13:18:15 <djh_> thanks chrisdone will try that out!
13:19:06 <djh_> chrisdone: oh man thanks for that that's exactly what I was looking for.
13:19:34 <NihilistDandy> chrisdone: Just wanted to express how pleased I am about the GOA update :D
13:20:22 * hackagebot unordered-containers 0.1.4.1 - Efficient hashing-based container types  http://hackage.haskell.org/package/unordered-containers-0.1.4.1 (JohanTibell)
13:21:01 <arcatan> copumpkin: WHAT IS NEVER THE THE ANSWER??
13:21:49 <tgeeky> arcatan: s/THE THE/THE/
13:23:29 <dmwit> arcatan: NO, SOMETIMES WHAT IS THE ANSWER, BUT REGEX IS NEVER THE ANSWER
13:23:40 <ion> ghci> let pre = anyChar `manyTill` (lookAhead . Text.Parsec.try) epId; epId = liftA2 (,) (char 'S' *> natural) (char 'E' *> natural); natural :: Parser Integer; natural = read <$> many1 digit in parse (pre *> epId) "" "foo S S1 S42 S12E34 bar S S1 S42"
13:23:44 <ion> Right (12,34)
13:24:02 <ion> djh: One could use Parsec like so.
13:24:31 <NihilistDandy> LOVE IS THE ANSWER
13:24:37 <kuznero> :)
13:24:43 <dmwit> <3
13:25:25 <ion> djh: The benefits are better composability of parsers, great error messages, named subparts of the parser expression which also allow recursion etc.
13:25:25 <djh_> ion: haha amazing, I'm not really too familiar with the parsec libraries just yet but certainly seems interesting
13:25:37 <chrisdone> back in mac, my dell hit the sack, i'd been on too long and i ran out of power from the pack
13:25:38 <NihilistDandy> No, wait, what's that other thing? Pattern matching. Pattern matching is the answer
13:26:39 <kuznero> It will all come down to immutability then... :)
13:26:45 * chrisdone tends to use pattern matching for scraping
13:27:26 <ion> djh: The semantics aren’t that far from those of regular expressions.
13:28:05 <bscarlet> copumpkin: would you care to elaborate on the origin of your distaste for regexes?
13:28:39 <NihilistDandy> bscarlet: Three words. Perl.
13:29:01 <copumpkin> the libraries in haskell for them are unpleasant, and regexes themselves aren't very easy to understand. Parsers in haskell are easy to concoct and a lot easier to maintain, and the API doesn't suck
13:29:26 <chrisdone> regex are (1) write-only, (2) not typed, (3) slow
13:29:47 <ion> And often not the right tool for the job anyway.
13:30:05 <chrisdone> but for this guy's one-off i'd use it
13:30:10 <bscarlet> NihilistDandy: a very reasonable origin, but not a universal justification
13:30:17 <djh_> to play devils advocate though, surely they're quicker to write?
13:30:25 <djh_> if you're well versed in regex
13:30:26 <dschoepe> They are useful if you want to give the user a way to specify where in a string to find something, though.
13:30:35 <chrisdone> they are, that's their main advantage
13:30:51 <dschoepe> E.g. that season/episode-number parsing example from above.
13:30:54 <bscarlet> copumpkin: somewhat unpleasant / perhaps to some / yes
13:31:03 <kmc> i need a really short, compelling example of pure parallelism in Haskell
13:31:18 <tgeeky> par-tutorial?
13:31:35 <kmc> tgeeky, ?
13:31:48 <kuznero> Simon Peyton's par-tutorial
13:31:52 <kuznero> Great stuff!
13:31:54 <kmc> i'll take a look
13:31:58 <tgeeky> no
13:31:58 <Silvan> copumpkin: do you know some easy tutorial on parsing?
13:31:59 <tgeeky> https://github.com/simonmar/par-tutorial
13:31:59 <bscarlet> chrisdone: (1) perhaps to some (2) what do you want from typechecking in this case? (3) unfortunately true for many current implementations, but not in principle
13:32:05 <tgeeky> simon marlow :O
13:32:06 <aninhumer> seems like it would be easy to write a script to turn regexes into Parsec?
13:32:11 <copumpkin> Silvan: hmm, nothing I can think to recommend
13:32:14 <kmc> other simon ;)
13:32:29 <tgeeky> aninhumer: there is an applicative regex package
13:32:34 <kuznero> Ha... missed that - thought it was Peyton...
13:32:37 <chrisdone> bscarlet: take the email parser regex as the main example
13:32:59 <chrisdone> it's unreadable, it's not typed, it's slow as a snail with asthma
13:33:11 <kmc> thing is, I'm not really looking to explain how to use "par"
13:33:22 <jerji> chrisdone: that is kind of an absurd regex though
13:33:29 <aninhumer> tgeeky: well my point was more, you can get the benefit of fast writing and maintainable code
13:33:30 <jerji> assuming you me the enormous rfc-compliant one
13:33:30 <tgeeky> kmc: even better, he demonstrates
13:33:31 <ion> chrisdone: Well, as for its unreadability, it was generated code based on a readable spec.
13:33:58 <chrisdone> jerji: well the point at which regex becomes absurd probably differs, but the equivalent parser with parsec is 20~ lines of readable code
13:33:58 <ion> chrisdone: Most generated code can’t be blamed for unreadability since the original input was probably readable.
13:34:11 <kmc> i don't see a demo in this paper which would easily fit on a slide
13:34:14 <kmc> that's what i'm looking for
13:34:26 <chrisdone> bscarlet: by typed i mean [0-9] gives you a string from regex, from parsec you ask for digits and you get integer
13:35:06 <kmc> i guess set aside par for a second:
13:35:11 <chrisdone> ion: what part of the spec was it generated from?
13:35:19 <kmc> what's an interesting search problem that can be solved in a few lines of Haskell?
13:35:24 <kmc> then I can try to parallelize the search
13:35:28 <bss_work> Regexes are terse, and after a while you get to where you can read them quite well.  However, I don't use them for parsing.
13:35:29 <danharaj> n-queens problem?
13:35:31 <tgeeky> kmc: yes
13:35:34 <tgeeky> kmc: i have a good example
13:35:41 <jerji> chrisdone: I saw a Perl generator of that regex years ago (not sure where it is now) written by Abigail that was quite readable-- it basically looked like a Perl version of the RFC
13:35:57 <kmc> danharaj, good one
13:36:16 <ion> chrisdone: The BNF grammar
13:36:23 <danharaj> acowley, kmc: I managed to get my text looking nice by using pixel coordinates for texture coordinates, truncating, and texelFetch'ing in the fragment shader. Looks nice enough.
13:36:28 <bss_work> Searching, matching, maybe substitution.  Even for simple parsing single CSV record, I'd rather have parsec (or something from that family)
13:37:04 <bss_work> s/parsing single/parsing e.g. a single/
13:37:48 <tgeeky> kmc: do this one: http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance
13:38:05 <tgeeky> kmc: the "fast but cryptic" one
13:38:11 <tgeeky> explain why it's not cryptic at all :O
13:38:41 <tgeeky> while you're at it, tell *me* why it's not cryptic
13:39:17 <bss_work> Ugh, using fromEnum to do the False -> 0, True -> 1 tansformation is ugly.
13:39:25 <kmc> o_O
13:39:35 <danharaj> why?
13:39:42 <tgeeky> kmc: it was used here https://github.com/liehann/maybeyoumeant ( in ruby )
13:40:17 <bss_work> Actually, I think fromEnum is ugly most of the time.
13:40:42 <bss_work> It drops too much meaning.
13:41:19 <chrisdone> ion: i can't really tell what the 30~ lines of regex in the source is doing, but i'll take your word for it that it's generated from something like parsec
13:41:44 <chrisdone> ion: anyway, point is, even if it weren't generated do you think it would be readable?
13:43:11 <kmc> also, what's the headline impressive statistic about GHC's new IO manager
13:43:26 <chrisdone> jerji: the absurdity of the regex is my point -- in parsec it's not  absurd
13:45:39 <chrisdone> kmc: my irc server can handle 10k connections simultaneously sending/recieving data And All I Had to Do Was Install GHC7?
13:45:53 <kmc> well 10k isn't that much
13:45:58 <kmc> but ok
13:46:04 <chrisdone> it is compared to what ghc6 offered me :p
13:46:18 <kmc> i have a slide about the IO manager but there's not much to say other than "it's really good"
13:46:27 * hackagebot ordered 0.1 - A definition of Posets.  http://hackage.haskell.org/package/ordered-0.1 (MiguelPagano)
13:46:34 <bss_work> kmc: Try the new GHC IO Scheduler! It's got what plants crave!
13:46:37 <kmc> i guess i'll just read the damn paper and stop bugging you all
13:47:17 <luite> chrisdone: how many connections did you test with?
13:47:56 <NihilistDandy> @remember bss_work kmc: Try the new GHC IO Scheduler! It's got what plants crave!
13:48:07 <NihilistDandy> Argh, no bot
13:48:22 <chrisdone> 10k. i didn't test with more.. i was proving to someone that haskell scaled trivially compared to writing an ircd in C
13:48:32 <MHD> So I have this crazy idea...
13:48:46 <luite> oh it would be interesting to see when and how it breaks down :)
13:48:52 <jerji> chrisdone: I'm not familiar with parsec (or much Haskell, for that matter-- I'm just learning now) but I'm reluctant to demonize all regex because of its abusability. perhaps in time I will agree with you in the context of Haskell
13:48:54 <chrisdone> indeed
13:49:13 <NihilistDandy> MHD: What is it?
13:49:40 <MHD> It is a programming language with a couple of interesting features.
13:49:51 <kmc> referential transparency and non-strict semantics?
13:50:01 <MHD> kmc: no, sadly
13:50:10 <NihilistDandy> MHD: Why not a programming language with *lots* of interesting features?
13:50:13 <kmc> MHD, THEN CLEARLY UR LANGUAGE SUX
13:50:16 <kmc> ;)
13:50:24 <NihilistDandy> Ruby's a language with a couple of interesting features.
13:50:32 <MHD> Actually, yes, it is a lot of interesting features
13:50:35 <kmc> C++ is a language with a lot of interesting features
13:50:48 <NihilistDandy> kmc: FCVO "feature"
13:50:54 <chrisdone> jerji: i'm not demonizing all regex either, up there i suggested using it for scraping. anyway, here's email parsing in parsec: http://porg.es/blog/email-address-validation-simpler-faster-more-correct
13:50:58 <heatsink> FCVO?
13:51:01 <MHD> Like the best of C++, Java, C#, D, Python, Probably Ruby and in the spirit of Haskell
13:51:10 <NihilistDandy> "For Certain Values Of"
13:51:21 <bss_work> What are you scraping?
13:51:28 <NihilistDandy> MHD: So you can't program anything in it? :D
13:51:31 * hackagebot file-location 0.2.0 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.2.0 (GregWeber)
13:51:37 <kmc> "in the spirit of Haskell"?
13:51:40 <bss_work> I recently did some extraction from "tag soup" via HXT.
13:51:45 <bss_work> It was quite enjoyable.
13:51:50 <NihilistDandy> kmc: He means no one uses it
13:51:50 <MHD> kmc: yeah
13:51:52 <danharaj> Haskell is soulless mathematics.
13:51:55 <MHD> oh you!
13:52:03 <thoughtpolice> HASKELL IS USELESS BECAUSE MATH NAMES AND STUFF
13:52:03 <jerji> chrisdone: thanks for the link. I'll try to find that Perl one I referenced for comparison
13:52:06 <thoughtpolice> THERE I SAID IT, AND IT'S THE TRUTH
13:52:17 <thoughtpolice> now accept my inability to learn new things and love it!
13:52:17 <MHD> you guys are hilarious
13:52:21 <kmc> it's customary to namedrop Haskell while describing new programming language designs
13:52:37 <chrisdone> jerji: you mean this one? http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html
13:52:39 <yitz> Lazy K is a language with a few interesting features
13:52:52 <MHD> I am writing the first compiler in haskell frontend (backend LLVM), and I plan to make it selfhosting later
13:52:52 <danharaj> Lazy K sounds like a drug I would do.
13:53:03 <erus`> bss_work: are you that guy who made the supercompiler?
13:53:05 <jerji> chrisdone: that's the module but the generator, which looks very similar to your parsec example, used to be available as well (I don't see it in that tgz either)
13:53:05 <NihilistDandy> MHD: So, have you got any more details? What makes it interesting?
13:53:05 <chrisdone> lazy k, a drug for haskell programmers
13:53:10 <kmc> danharaj, sounds like a mixture of ketamine and... more ketamine
13:53:15 <danharaj> heh
13:53:16 <bss_work> erus`: Probably not.
13:53:26 <tgeeky> thoughtpolice: on the one hand, it's not really very enlightened to poke at the fact that people have different learning challenges. On the other hand, one can simply shadow the entire Prelude and name those mathy-sounding monster-things whatever you'd like.
13:53:30 <danharaj> chrisdone: well if we're going to be traditional, we would do amphetamines.
13:53:39 <erus`> bss_work: do you work for a bank?
13:53:48 <Saizan> kmc : MHD, THEN CLEARLY UR LANGUAGE SUX <- at first i thought it was a comment on "ur" the language
13:53:50 <chrisdone> danharaj: but then we don't have a pun
13:53:55 <bss_work> MHD: Let me know when you want tester for a LLVM-backed Haskell compiler.
13:54:03 <chrisdone> saizan: haha, not just me then
13:54:07 <bss_work> erus`: Nope.
13:54:20 <MHD> I am compiling a list of the features right now
13:54:22 <kmc> Haskell is great but everyone knows it's useless; now if only we could combine Haskell with real-world features like stateful variables, Unicode support, concurrency, web frameworks, ...
13:54:32 <MHD> And making syntax Examples
13:54:39 <bss_work> kmc: LOL
13:54:39 <monochrom> people freak out on mere names
13:54:44 <NihilistDandy> kmc: owait
13:54:57 <thoughtpolice> tgeeky: heh, true. but i say this on the assumption people who make such complaints like "omg monoid is such a confusing name! why did you choose it this is worthless omg!?!?!" just aren't attempting to learn, ignoring whether or not it may be more difficult for them compared to some other arbitrary person
13:55:01 <erus`> try using the web frameworks on windows though... trolled hard
13:55:12 <NihilistDandy> monochrom: And yet they love OOP
13:55:17 <chrisdone> MHD: your language sounds like Frankenstein's monster, and not the sexy kind
13:55:23 <yitz> kmc: and multiple inheritance
13:55:26 <danharaj> erus`: Really? Yesod worked when I tried it on Win7
13:55:36 <MHD> chrisdone: It will be a very sexy kind
13:55:44 <erus`> i tried snap and another one
13:55:48 <kmc> "monoid" is so confusing, why can't they just call it PolymorphicAbstractBinaryFunctoidFactory
13:55:50 <bss_work> Stateful Variables?  IORef, MVar, TVar, etc.  Unicode support = on by default, now quit BREAKING it!  Web frameworks: There's like 3-4 and they cross-polinate.
13:56:01 <erus`> they both worked but no addons worked (authentication etc etc)
13:56:17 <NihilistDandy> PolymorphicAbstractBinaryFunctoidFactory would be so much more obvious
13:56:20 <aninhumer> Monoid could be "mergey thing"
13:56:21 <thoughtpolice> kmc: yeah man, none of that nonsensy math stuff
13:56:27 <MHD> What should I name this language experiment?
13:56:28 <tgeeky> thoughtpolice: not just difficult in learning the concepts, but also the lexical understanding and familiarity
13:56:40 <NihilistDandy> MHD: Wip
13:56:54 <MHD> NihilistDandy: Genius
13:56:54 <yitz> MHD: Scheme
13:57:05 <MHD> Hereby I name my language "Wip"
13:57:09 <monochrom> at least we haven't brought up magma yet
13:57:11 * chrisdone ponders Frankenstein puns.. uhh "twist my nuts", "screw me", uhh, "I like a bit of everything"
13:57:12 <bss_work> I'll admit, when my code is simply peppered with 3 letter variables and 5-character operators, my Haskell can be a bit difficult to understand.
13:57:13 <MHD> And no it will not be a lisp dialect
13:57:31 * hackagebot file-location 0.2.1 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.2.1 (GregWeber)
13:57:38 <bss_work> But, I needed ($>>>*^) for this project, it just made sense!
13:57:38 <tgeeky> hehe
13:57:41 <danharaj> bss_work: You have too many letters. Try 1 letter names and 3 symbol combinators.
13:57:42 <Cale> bss_work: Solution: use one letter variables
13:57:42 <preflex>  Cale: you have 1 new message. '/msg preflex messages' to read it.
13:57:45 <chrisdone> MHD: call it Das Experiment
13:57:59 <kmc> MHD, so what will your language have that's *new*?
13:57:59 <monochrom> $>>>*^ is a bit extreme :)
13:57:59 <MHD> chrisdone: good one
13:58:01 <hpaste> DukeDave pasted “Trouble with ReaderT” at http://hpaste.org/49786
13:58:03 <aninhumer> chrisdone: "my birth was a bit of a shock"
13:58:11 <chrisdone> aninhumer: hahaha
13:58:16 <mokus> bss_work: ah, yes, the old dollarsign-triple-left-angle-star-up operator!
13:58:17 <Cale> @bot
13:58:19 <MHD> kmc: It is Google Go but without the suck
13:58:31 <kmc> ah, well there's nothing new in Go
13:58:35 <kmc> and nothing new about not sucking either
13:58:52 <chrisdone> aninhumer: "i'm constantly revinenting myself"
13:58:56 <DukeDave> So, would anyone care to comment on my woe (and probably mis-understanding) with Reader
13:58:56 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
13:59:02 <kmc> it seems like most new language designs are "let's make Java 10% less shitty"
13:59:04 <MHD> It is hard to explain, but I believe it will be a language that programmers can agree to
13:59:09 <kmc> i guess this is a worthy goal
13:59:10 <lambdabot> kmc: You have 1 new message. '/msg lambdabot @messages' to read it.
13:59:14 <kmc> but i find it profoundly uninteresting
13:59:24 <kmc> MHD, sorry to be a dick about it
13:59:25 <yitz> Cale++
13:59:30 <hpaste> DukeDave annotated “Trouble with ReaderT” with “Trouble with ReaderT (error)” at http://hpaste.org/49786#a49787
13:59:32 <kmc> it really *is* a worthy goal
13:59:34 <MHD> kmc: s'alright
13:59:42 <erus`> MHD url?
13:59:53 <erus`> i wanna read a spec
13:59:56 <MHD> kmc: and yes, my language is pretty much "Java 20% cooler"
14:00:00 * DukeDave just thought he was getting to grips with Reader :'(
14:00:04 <MHD> erus`: coming soon
14:00:12 <NihilistDandy> @remember bss_work kmc: Try the new GHC IO Scheduler! It's got what plants crave!
14:00:16 <lambdabot> It is forever etched in my memory.
14:00:24 <erus`> write and paste a Fibonacci in you language
14:00:34 <bss_work> NihilistDandy: Thanks. :P
14:00:47 <aninhumer> > import IO.Electrolytes
14:00:52 <lambdabot>   <no location info>: parse error on input `import'
14:00:53 <chrisdone> MHD: http://sivers.org/zipit
14:00:56 <aninhumer> lies
14:01:00 <chrisdone> "Shut up! Announcing your plans makes you less motivated to accomplish them."
14:01:03 <bss_work> erus`: fibs@(_:t) = 0 : 1 : zipWith (+) fibs t
14:01:14 <kmc> i think most languages do not reveal much from a fibonacci sequence
14:01:26 <jerji> I give up. maybe \yrlnry knows where to find it.
14:01:28 <MHD> chrisdone: No. I have been working on this for about 2 months
14:01:45 <Saizan> DukeDave: asks (\i -> getter i bools)
14:01:54 <chrisdone> MHD: and now it will stop :p
14:02:15 <MHD> chrisdone: no, because it lives in my heart
14:02:18 <MHD> :P
14:02:22 <aninhumer> kmc: true, but if the fib doesn't look nice, it's not a great start
14:02:51 <kmc> shrug
14:03:01 <DukeDave> Saizan: Zomg, okay, thanks, digesting :)
14:03:29 <MHD> I wonder if "Wip programming language" is a googleable name
14:03:30 <kmc> aninhumer, *shrug* if you optimize for programming in the large you get different designs
14:03:31 <chrisdone> fix (\a.\(0) n.add n 1;m n.(\(true).a (sub m 1) 1;(false).a (sub m 1) (a m (sub n 1))) (eq n 0)) 3 2
14:03:33 <chrisdone> => 29
14:03:36 <chrisdone> now that's a language!
14:03:41 <bss_work> Did someone point the fibonacci sequence as the output of fix some_expr_here?
14:03:47 <kmc> MHD, just curious, which programming languages would you say you understand well?
14:04:14 <kmc> aninhumer, Java's far from a good language, but its strength isn't in cute cryptic one-liners like fibonacci
14:04:32 <MHD> kmc: C, C++, Java, Haskell, Python, Cobra, Lua, Theoretically Assembler, LLVM assembly, Shell Scripting
14:04:53 <MHD> kmc: Probably Prolog too
14:05:03 <MHD> kmc: And FORTH and Factor
14:05:03 <kmc> its strength is in allowing a bunch of replaceable-part programmers to collaborate on boring business software
14:05:19 <kmc> and decreasing the variance on outcomes
14:05:35 <yitz> 10 X=0 \n 20 Y=1 \n 30 PRINT X \n 40 Z=Y \n 50 Y=X+Y \n 60 X=Z \n 70 GOTO 30
14:05:37 <erus`> boring state machines
14:05:50 <kmc> i happen to think they underestimated the "average programmer"
14:05:52 <MHD> kmc: And soon SML
14:06:10 <kmc> or at least underestimated what one should push the average programmer to become
14:06:37 <kmc> C# users seem perfectly comfortable with lambdas, monad comprehensions, and other features the Java designers would consider advanced wizardry
14:06:43 <bss_work> DukeDave: You might also do "trans <- asks getter; let strs = trans bools;"
14:06:57 <yitz> IDENTIFICATION DIVISION. oh, never mind.
14:06:58 <DukeDave> Saizan: Ah, I think I get it.
14:06:59 <DukeDave> My incorrect assumption was that (asks getter) :: [Bool] -> Reader Int [String]
14:06:59 <DukeDave> but it is actually the case that (asks getter) :: Reader Int ([Bool] -> [String])
14:06:59 <DukeDave> Is that my mistake?
14:07:24 <companion_cube> kmc: how can anyone consider lambdas "advanced wizardry" ? oO
14:07:32 <MHD> How is the english "W" consonat written in IPA?
14:07:32 * hackagebot error-location 0.1.5.3 - error functions that show file location information  http://hackage.haskell.org/package/error-location-0.1.5.3 (GregWeber)
14:07:35 <bss_work> DukeDave: I think so, but Saizan will know better.
14:07:49 <monochrom> oh dolio: what's new in logict 0.5.0? (compared to 0.4.2)
14:08:12 <aninhumer> companion_cube: they don't know what they are, it has a weird name so it's obviously hard
14:08:51 <bss_work> companion_cube: C doesn't have them.  Normal programmers only use 80% of the C lanaguage.  Therefore only advanced programmers use anything not in the C language. :P
14:09:33 * hackagebot error-location 0.1.5.4 - error functions that show file location information  http://hackage.haskell.org/package/error-location-0.1.5.4 (GregWeber)
14:10:10 <aninhumer> man that sounded more elitist than I meant to...
14:10:21 <kmc> PL really is a depressing field
14:10:23 <companion_cube> 80% of C is not much
14:10:33 * hackagebot error-location 0.1.5.5 - error functions that show file location information  http://hackage.haskell.org/package/error-location-0.1.5.5 (GregWeber)
14:10:47 <DukeDave> Yuck, this is all very ugly :'(
14:10:53 <yitz> kmc: think of it as a division ring then
14:10:58 <kmc> ;P ;P ;P
14:11:04 <kmc> > cycle ";P "
14:11:05 <lambdabot>   ";P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P ;P...
14:11:48 <copumpkin> kmc: how come?
14:13:02 <kmc> copumpkin, because the majority of "real-world programmers" are actively, willfully ignorant of anything that's happened in PL research in the past 40 years
14:13:23 <kmc> which is so shocking for a field like CS
14:13:27 <kmc> that seems to move so quickly
14:14:14 <kmc> everyone acknowledges that software sucks, and you'd think that better languages could help, but nobody will use them
14:14:14 <copumpkin> yeah
14:14:58 <monochrom> wait 10 more years, and you will be able to say "in the past 50 years"
14:15:07 <yitz> kmc: the majority of mechanical engineers are actively, willfully ignorant of anything that's happened in materials research in the past 40 years
14:15:12 <kmc> yitz, really?
14:15:22 <yitz> kmc: they just use steel
14:15:33 <c_wraith> steel is good.  concrete is good.  what else do you need?
14:15:34 <kmc> well, are the other materials actually better for those tasks?
14:16:19 <chrisdone> i thought about this today. i spend time writing libraries, putting up with nonENTERPRISE libs, IDE, package systems... you have to be good to get real things done against these odds. with java or c# i would probably be more productive at least in those aspects. i try to be realistic when newbies to programming ask me if haskell is usable for the real world. the answer is yes but you have to have a certain level of skill and motivation
14:16:27 <yitz> probably. but it will take a long time for the ecosystem to gear up to using them as much as steel is used now.
14:16:46 <kmc> i'm not sure there's any point to building a bridge out of advanced composite materials
14:17:03 <dolio> monochrom: edwardk sent me a bunch of random cleanup changes he wanted.
14:17:06 <kmc> while I think there's plenty of point to building "everyday" software in a language that isn't C or PHP
14:17:14 <dolio> And it's more in line with current mtl practice.
14:17:19 <kmc> *shrug*
14:17:24 <dolio> So Logic is now an alias for LogicT Identity, for instance.
14:17:39 <monochrom> nice
14:17:45 <kmc> if I think PL is depressing, bitching about it on IRC is not the way forward
14:17:49 <edwardk> oh you pushed the patch?
14:18:17 <Axman6> @unmtl LogicT m a
14:18:18 <lambdabot> LogicT m a
14:18:22 <Axman6> -_-
14:18:35 <Saizan> DukeDave: yep that was the problem
14:18:37 <monochrom> clearly, lambdabot doesn't know LogicT
14:18:58 <yitz> kmc: most of the machines that build bridges work better with steel. the machines that build programs are programmers, and most of them work better with C or PHP.
14:19:07 <monochrom> lambdabot is really the last go-to for lookups, not the first
14:19:07 <benmachine> kmc: surely you're not unbiased in your view re: software versus mechanical engineering :P
14:19:18 <benmachine> anything's important if you look at it closely enough
14:19:40 <kmc> chrisdone, yeah; I generally tell people that Haskell is a good tool for real work, but that it takes possibly years to learn to use it that way
14:19:45 <benmachine> but it *is* frustrating how uninterested people are in innovation
14:19:55 <NihilistDandy> ^^
14:20:29 <kmc> benmachine, well, one obvious difference is that a bridge made of carbon nanotubes is going to be a lot more expensive than a bridge made of steel
14:20:36 <kmc> separate from engineering costs
14:20:53 <kmc> whereas a program that comes out of ghc is no more expensive to copy onto CDs than a program that comes out of gcc
14:20:56 <chrisdone> kmc: right
14:21:10 <kmc> analogies between software engineering and building bridges or painting portraits are usually horribly flawed
14:21:11 <benmachine> kmc: ok but there are other ideas, like I read about concrete that was made out of rubbish or something
14:21:13 <chrisdone> i'm still adding things to my Emacs every day
14:21:16 <benmachine> or that absorbed CO2
14:21:38 <DukeDave> Saizan: Thanks, I'm just trying to apply this revelation to my 'real' problem now, and I'm ending up with very messy code. Is there a better strategy for this pattern: "Generate something from environment; apply function using environment to generated something; return it"?
14:21:51 * benmachine read about this in the new scientist and it therefore may be lies
14:22:12 <monochrom> the most flawed part is that real engineering has liability laws and computer programming doesn't
14:22:41 <yitz> benmachine: i think we could find a way to work concrete made out of rubbish for building bridges into our programming languages metaphor quite easily. :)
14:22:51 <benmachine> heh
14:23:15 <NihilistDandy> monochrom: The most flawed part is that engineers have to know math, but programmers don't
14:23:35 <benmachine> anyway, the way I look at it, computer science is just... juvenile
14:23:38 <yitz> NihilistDandy: they most need to, and the problem is when neither do
14:23:39 <monochrom> if a bridge has a crack or something, the engineer faces criminal charges. if a python program has a run time type error, does the programmer face criminal charges?
14:23:42 <benmachine> it may well get over it and become something better
14:23:45 <kmc> benmachine, computer science, or programming?
14:23:54 <kmc> because my initial point was that programming is not keeping up with cs
14:24:00 <Saizan> DukeDave: "foo = asks getter <*> generator" would have worked
14:24:08 <benmachine> kmc: there's what we understand to be CS and then there's what people call CS
14:24:10 <yitz> monochrom: depends. is he part of lulz sec?
14:24:10 <kmc> i agree CS is *also* immature but I don't think that's the main problem here
14:24:18 <monochrom> and NihilistDandy, the liability is the cause of engineers needing math and programmers not needing
14:24:18 <benmachine> but now I'm starting to talk about things that I don't know much about
14:24:27 <jerji> kmc: institutional inertia probably has a lot to do with that
14:24:34 <erus`> how to test equality in lambda calc?
14:24:39 <benmachine> kmc: maybe CS should take some responsibility for the fact that no-one is interested in it :)
14:24:40 <kmc> erus`, equality of what?
14:24:44 <chrisdone> the mythical man month dispatched the building bridges analogy quickly. engineering uses repeated elements. programming takes repeated elements and abstracts the two into the one. a large software system has a high proportion of essential complexity, each component is a different kind of material. construction is totally different
14:24:48 <NihilistDandy> monochrom: Fair point. I'll be making some calls to the president and the Better Business Bureau
14:24:51 <erus`> two things
14:24:55 <erus`> numbers?
14:25:00 <kmc> erus`, numbers represented as church numerals?
14:25:13 <kmc> in a pure lambda calculus there are only functions
14:25:18 <kmc> and you can't compare functions for equality directly
14:25:19 <benmachine> monochrom: I read an article about the space shuttle guys
14:25:24 <benmachine> it was probably linked in here actually
14:25:28 <kmc> i linked it yesterday
14:25:33 <benmachine> oh right
14:25:35 <benmachine> it was good :P
14:25:40 <erus`> kmc what should i do
14:25:47 <kmc> erus`, read a book or wikipedia page
14:26:00 <DukeDave> Saizan: Woo! That means I've just met <*> as a result of writing real code, finally I can allow myself to read up in it!
14:26:00 <DukeDave> /me keeps seeing <*> and hints of its usage.
14:26:04 <chrisdone> there's evidence that growing software is good practice for moral
14:26:09 <chrisdone> er, morale
14:26:11 <benmachine> erus`: lambda calculus doesn't have polymorphism, so you'd probably have to define an equality function for each type
14:26:12 <kmc> erus`, I think you can define equality for church numerals
14:26:17 <kmc> i don't remember how exactly
14:26:34 <benmachine> kmc: in the untyped LC you can do everything :P
14:26:37 <Axman6> kmc: s/think/know, it's computable, so it can be done :P
14:26:40 <erus`> i'll make it a magic build in
14:26:47 <kmc> you can't compare functions benmachine ;P
14:26:52 <kmc> cause it's not computable
14:27:08 <kmc> my quote on the matter was "the Space Shuttle software isn't written by 20-year-old Red Bull guzzling all nighter ninja rockstar cowboy coderzzz... it's written by middle-aged engineers who wake up at 9 AM and go to meetings and write thick, boring specification docs"
14:27:09 <monochrom> I know from engineering school profs that many engineering students hate the math. those students bear with it because it is a necessary condition for not getting sued. that is all there is to it
14:27:10 <benmachine> well anyway, you *can* define equality for church numerals
14:27:25 <kmc> monochrom, why don't they just buy insurance instead
14:27:25 <benmachine> it looks something like "if both are zero then true else pred x == pred y"
14:27:28 <kmc> like doctors do
14:27:36 <kmc> ah yeah
14:27:38 <monochrom> granted, some other engineering students are curious and open-minded enough to like the math, as well as all geeky things
14:27:46 <chrisdone> monochrom: what physical things will they eventually be engineering?
14:27:52 <kmc> isZero n = n (const False) True
14:28:07 <kmc> defining "pred" is a little tricky
14:28:10 <kmc> but it's on wikipedia ;P
14:28:20 <benmachine> I did it with tuples
14:28:42 <benmachine> something like n (\(x,y) -> (y,suc y)) (zero, zero)
14:28:55 <benmachine> er, fst of that
14:29:04 <heatsink> But you can't verify that a given function is a church numeral...
14:29:09 <benmachine> no
14:29:13 <kmc> monochrom, yeah, it's a myth that all smart people / people in quantitative fields will "act like nerds"
14:29:29 <kmc> i know a bunch of smart engineering students who basically act like fratboys
14:29:43 <benmachine> are they nice fratboys
14:29:57 <kmc> (well i "know" them third-hand... can't say if they're nice)
14:30:33 <kmc> similarly just watching sci-fi does not make you smart or good at math
14:30:52 <erus`> i think my lamdba calc programming language is gonna be a pain
14:31:00 <erus`> i just looked at lists
14:31:17 <Axman6> uh, yeah
14:31:25 <benmachine> doing anything in untyped lambda calculus is really annoying
14:31:41 <benmachine> the error messages aren't great :P
14:32:14 <mauke> just write correct code
14:32:43 <DukeDave> Saizan: Your suggestion to use <*> led me to 'ap' (which I've already met and understand) and resulted in my code becoming many orders more readable. Thank you so much! (I can see exactly how it all fits together now)
14:32:54 <DukeDave> Saizan++
14:32:57 <erus`> i just need pattern matching for tuples and its perfect
14:33:00 <Saizan> cheers :)
14:33:09 <benmachine> erus`: tuples are the easiest to do in lc
14:33:16 <benmachine> they're just (a -> b -> c) -> c
14:33:18 <benmachine> well not the easiest
14:33:23 <benmachine> but much less unpleasant than lists :p
14:33:34 <erus`> yeah i worked out pairs would be nice
14:33:38 <kmc> pattern-matching is a much more general idea than tuples
14:33:49 <kmc> many languages only allow pattern-matching for tuples
14:33:53 <kmc> but there's no reason to inherit that flaw
14:34:09 <erus`> well my language will only have tuples and Integers
14:34:10 <aninhumer> can't you make lists trivially once you have tuples?
14:34:18 <erus`> aninhumer: yeah
14:34:21 <kmc> aninhumer, if you don't have static types, sure
14:34:35 <benmachine> and if you have empty tuples
14:34:49 <kmc> or some other distinguished 'nil' value, or bools
14:34:51 <c_wraith> if you do have static types, look at HList.  it hurts the brain.
14:34:55 <monochrom> kmc, insurance doesn't help with criminal charges, only with civil lawsuits i.e. victims want the engineer to pay money. however, depending on what the engineer built and how many people he killed, in practice perhaps insurance companies just say "I don't like this risk model, I don't want to get into this business"
14:35:03 <mauke> this is what happens when I'm bored in java class: http://mauke.dyndns.org/stuff/java/
14:35:06 <kmc> you can always go with nil = (False, _), cons x xs = (True, (x, xs))
14:35:20 <benmachine> monochrom: it's usual to buy insurance *before* killing people
14:35:28 <benmachine> they tend to be unsympathetic if you try to do it afterwards
14:35:53 <monochrom> oh, just wrong wording on my part, s/killed/may be able to kill/
14:35:54 <ddarius> monochrom: All the insurance providers have to do is adjust the premiums appropriately.
14:36:29 <kmc> ddarius, sometimes there is no premium which will satisfy an insurer of bounded computational resources
14:36:39 <ddarius> benmachine: My impression is that insurance firms are unsympathetic period.
14:36:44 <kmc> i.e. for risk curves which have no converging sequence of computable approximations
14:36:48 <NihilistDandy> With enough money paid out ahead of time, you can wipe out an entire Eastern European country without any trouble
14:37:09 <NihilistDandy> At least according to this insurance model
14:37:16 <monochrom> and still, suppose a hypothetical insurance company takes up this business. an engineer using math will pay less premium than an engineer not using math, so there is still incentive to grok the math whether he hates it or not
14:38:31 <monochrom> basically, programmers face no liability, no insurance cost, no nothing. math costs you some pain to learn. no-math costs you $0. the choice is obvious
14:39:46 <ddarius> monochrom: That's assuming there is no intrinsic benefit to learning math.
14:40:11 <MHD_away> Brace based languages are discriminating towards non-stadart keyboard users.
14:40:20 <monochrom> which is assuming I'm talking about some majority of engineers and programmers and humanity
14:40:44 <mokus> ddarius: I think most people do operate under that assumption
14:41:25 <mauke> MHD_away: just use trigraphs
14:41:31 <kmc> it's no surprise that the mathier forms of programming (FP, theorem provers, model checkers) are more popular in high-security and safety-critical domains
14:41:41 <yitz> mauke: what happens when you're bored in java interface?
14:42:06 <hpaste> erus` pasted “tuple matching” at http://hpaste.org/49789
14:42:20 <erus`> do i need two datatypes there?
14:42:37 <kmc> you're redefining Nothing ?
14:42:46 <erus`> just an example
14:42:47 <kmc> also you're defining data constructor "Tuple" twice
14:43:02 <erus`> yeah i mean 'Nested Tuple'
14:43:03 <kmc> i don't understand your example
14:43:33 <hpaste> erus` annotated “tuple matching” with “tuple matching (annotation)” at http://hpaste.org/49789#a49790
14:43:43 <MHD> mauke: Not that I don't have {} available, it is just that I chord Alt GR + 7 and Alt GR + 0 to get them...
14:44:04 <mauke> MHD: change your keyboard layout
14:44:15 <mauke> en_US is required for programming
14:44:47 * kmc does not use en_US
14:44:59 * mauke uses en_hax
14:45:09 <chrisdone> :o
14:45:10 <erus`> kmc, line #5 is a representation of the pattern on line #4
14:45:33 <kmc> ah, "Wildcard" is a better name for "Nothing"?
14:45:37 <monochrom> oh! so you like haskell because it doesn't make you type { } everywhere :)
14:45:46 <NihilistDandy> I use DonKeys
14:46:06 <kmc> or "Anything"?
14:46:08 <MHD> monochrom: No, that is why I like python, I like haskell because it is gods own programming language
14:46:11 * ddarius also does not use en_US.
14:46:13 <Axman6> or Ignored
14:46:18 <erus`> yeah anything is good
14:46:19 <monochrom> hehe ok!
14:46:53 <ddarius> Blind programmers like Haskell because you can type { } everywhere.
14:47:06 <kmc> yeah, there is some code like that on hackage
14:47:14 <aninhumer> MHD: I'd imagine omniscience makes debugging easier :P
14:47:31 <amsl> Is there a way to tell cabal to ignore a specific package when I do a "cabal install"?
14:47:55 <NihilistDandy> amsl: What package are you trying to ignore?
14:47:59 <kmc> MHD, I refuse to believe that any loving god would invent the monomorphism restriction
14:48:07 <monochrom> haha
14:48:12 <MHD> lol
14:48:34 <NihilistDandy> amsl: ghc-pkg hide <package-name>-<version> should do it
14:48:37 <MHD> how do you make lambdabot remember quotes again?
14:48:43 <amsl> NihilistDandy: double-conversion-0.2, I'm trying to figure out what in my build requires it.
14:48:44 <ddarius> @google "omniscient debugger"
14:48:44 <lambdabot> http://www.lambdacs.com/debugger/
14:48:45 <NihilistDandy> MHD: @remember
14:48:55 <MHD> @remember kmc MHD, I refuse to believe that any loving god would invent the monomorphism restriction
14:48:55 <lambdabot> I will remember.
14:48:56 <amsl> NihilistDandy: Thanks!
14:49:02 <chrisdone> how do you get netstat to list ports and ips?
14:49:13 <erus`> I cant believe we have a word for "all knowing" ... stupid Christians
14:49:13 <chrisdone> i always forget and have to rediscover this simple flag
14:49:14 <monochrom> netstat -t -n
14:49:17 <benmachine> MHD: you're going to get a buncha pointless highlights off that :P
14:49:25 <NihilistDandy> erus`: Stupid Romans
14:49:29 <chrisdone> monochrom: you're a gentlemen and a scholar
14:49:51 <MHD> @forget kmv MHD, I refuse to believe that any loving god would invent the monomorphism restriction
14:49:52 <lambdabot> No match.
14:49:59 <MHD> @forget kmc MHD, I refuse to believe that any loving god would invent the monomorphism restriction
14:49:59 <lambdabot> Done.
14:50:12 <MHD> @remember kmc I refuse to believe that any loving god would invent the monomorphism restriction
14:50:12 <lambdabot> It is forever etched in my memory.
14:50:18 <MHD> There
14:50:31 <benmachine> neat
14:51:42 <dmwit> ?quote MHD
14:51:43 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
14:51:46 <dmwit> aw
14:51:52 <ion> @quote
14:51:52 <lambdabot> RasmusLerdorf says: "I don't know how to stop it [PHP], there was never any intend to write a programming language [...] I have absolutely no idea how to write a programming language, I just kept
14:51:52 <lambdabot> adding the next logical step on the way."
14:52:27 <benmachine> @quote RasmusLerdorf
14:52:27 <lambdabot> RasmusLerdorf says: "I don't know how to stop it [PHP], there was never any intend to write a programming language [...] I have absolutely no idea how to write a programming language, I just kept
14:52:27 <lambdabot> adding the next logical step on the way."
14:52:33 <aninhumer> Also makes proofs easier: 1. Looks about right 2. I am god 3. Program is correct (from 1, 2)
14:52:35 <MHD> dmwit: I usually don't say anything memorable...
14:52:44 <benmachine> hmm
14:52:50 <kmc> Theorem: All numbers are prime.  Proof: Fuck you.  □
14:52:58 * benmachine lols
14:53:29 <dmwit> You've got a lousy kind of multiplication.
14:53:37 <MHD> This god-as-a-programmer-slash-computer-scientist gag is really funny
14:54:26 <MHD> Also, obligatory XKCD reference: http://xkcd.com/224/
14:54:44 <aninhumer> Was wondering when that would show up
14:54:55 <kmc> xkcd sucks
14:55:05 <kmc> i disliked xkcd before it was cool
14:55:18 <benmachine> xkcd sometimes sucks
14:55:30 <coppro> xkcd is currently above average in my opinion
14:55:38 <hpc> you can tell he wrote that in high school because he thought regexes were complicated :P
14:55:39 <coppro> it had a slump during which it became popular to hate on it
14:55:40 <danharaj> xkcd is the Java of webcomics.
14:55:54 <mauke> kmc: http://honda-tech.com/attachment.php?attachmentid=206191&stc=1&d=1304046166
14:56:18 <chrisdone> hahaha, oh god. i'm talking with a colleague. we've got a service: killall abc => abc: no process killed. and then in IRC. abc: ping. <abc> pong!. WHAT O_O
14:56:48 <kmc> i might say "xkcd's actual quality is disproportionate to its popularity" but that's not as catchy as "xkcd sucks"
14:57:04 <NihilistDandy> mauke: That's awesome
14:57:05 <NihilistDandy> Saved
14:57:05 <benmachine> hpc: regexes aren't complicated as an idea, but have you seen the one that verifies e-mails?
14:57:28 <kmc> SMBC is also frequently mediocre, but nobody takes SMBC as the defining artifact of "nerd culture"
14:57:38 <NihilistDandy> Wondermark's pretty great
14:57:40 <danharaj> shut up smbc is great
14:57:46 <mauke> benmachine: yes, and it's trivial
14:57:47 <erus`> i like smbc
14:57:48 <mauke> benmachine: http://mauke.dyndns.org/stuff/perl/rfc822
14:58:04 <benmachine> mauke: hmph, fine.
14:58:21 <kmc> all i'm saying is, xkcd is funnier on average if you replace the last panel with a line drawing of goatse
14:58:33 <danharaj> agreed.
14:58:41 <NihilistDandy> lol
14:58:55 <kmc> especially because RM loves the redundant punchline and/or post-punchline dialogue
14:59:10 <kmc> so the actual joke (to the extent there is one) is usually still clear
14:59:21 <chrisdone> i wonder when rand(all) will get another girlfriend
14:59:22 <MHD> kmc: Og god, I am so making that
14:59:26 <aninhumer> kmc: Oh wow, I had this open when you said that: http://xkcd.com/930/
14:59:27 <NihilistDandy> All these graphs are annoying, too
14:59:29 <aninhumer> Cannot unsee
14:59:36 <kmc> MHD, you mean http://goatkcd.com/sfw [nsfw] ?
14:59:39 <NihilistDandy> Google statistics aren't really that funny
14:59:49 <kmc> NihilistDandy, well, I don't think those are *trying* to be funny
14:59:55 <kmc> i appreciate cool data visualization
14:59:55 <benmachine> chrisdone: I don't wonder that at all
15:00:01 <NihilistDandy> kmc: They're not even that cool, though
15:00:06 <kmc> some are, some aren't
15:00:17 <benmachine> (this is going a teensy bit off-topic)
15:00:21 <erus`> http://mauke.dyndns.org/stuff/c/how-to-declare.txt
15:00:24 <kmc> often the joke in XKCD is "person in panel 1 said / did something stupid" and the rest of the panels are a pedantic elaboration of why it's stupid
15:00:24 <NihilistDandy> There have been a few.
15:00:29 <erus`> this is how haskell programmers think :P
15:00:35 <kmc> so it's better if you replace some of that with goatse
15:00:41 <danharaj> http://goatkcd.com/931/sfw
15:00:41 <mauke> erus`: s/haskell/C/
15:00:55 <chrisdone> i think the xkcd effect is that people got his sense of humour more or less after five comics and after that it's not novel. he seems to maintain a userbase with interweb/math/python references
15:01:22 <MHD> The xkcd forum culture is good htough
15:01:26 <danharaj> god no it isn't
15:01:32 <danharaj> Have you stepped into their politics board?
15:01:46 <MHD> Sorry, the subset that is Coding and Computer Science is good
15:01:50 <kmc> what's funny is that some of the early xkcd strips are basically an indictment of everything xkcd has now become
15:01:52 <aninhumer> danharaj: does there exist a politics board that isn't horrible?
15:01:53 <MHD> That is all I ever go to
15:01:59 <danharaj> aninhumer: Yes, but no one posts on it.
15:02:26 <danharaj> ok one more, these are brilliant
15:02:26 <danharaj> http://goatkcd.com/924/sfw
15:02:28 <danharaj> I'm done now.
15:02:30 <kmc> like http://xkcd.com/78/
15:02:40 <aninhumer> "I think Capitalism is good" "I prefer Socialism" "Righty ho then" [thread closed]
15:02:45 <kmc> of course what he doesn't know is that this actually happened, back in 1989
15:03:14 <kmc> http://www.iheartbarrelman.com/?p=621
15:03:23 <NihilistDandy> aninhumer: Heh
15:05:02 <NihilistDandy> kmc: Oh, yeah, I remember that one
15:06:08 <aninhumer> kmc: Half his audience wasn't alive in 1989 it's fine
15:06:23 <kmc> aninhumer, sad but true
15:06:25 <kmc> http://xkcd.com/16/
15:06:55 <kmc> "I went to a dinner where there was a full 10 minutes of Holy Grail quotes exchanged, with no context, in lieu of conversation.  It depressed me badly."
15:07:10 <kmc> now we have 10 minutes of xkcd quotes in lieu of conversation
15:07:51 <benmachine> :P
15:07:55 * benmachine wasn't alive in 1989
15:08:04 <NihilistDandy> kmc: s/xkcd/family guy/
15:08:09 <danharaj> better than 10 minutes of monad jokes mirite
15:08:23 <erus`> tell me a monad joke
15:08:25 <hpc> oh god, better xkcd than family guy
15:08:30 <hpc> at least SOME of the jokes are funny
15:08:37 <aninhumer> Functor? I 'ardly know 'er!
15:08:52 <erus`> oh god :P
15:08:59 * kmc punches erus` in the monads
15:09:02 <kmc> see, it's physical comedy
15:09:23 <benmachine> http://haskell.org/haskellwiki/Humor
15:09:24 <mokus> kmc: that should be one of lambdabot's @slap messages if it isn't already
15:09:28 <yitz> @vixen tell us a monad joke
15:09:29 <lambdabot> I have a boyfriend, but he likes to watch.
15:09:37 <chrisdone> the monty python substitute for conversation/wit is rife in geek circles. lame
15:09:41 <kmc> lambdabot++
15:09:43 <wavded>  another noob question, i inquired earlier about generating all the possible values in a sequence of AAA-0000, which you guys helped with the expression - map concat . sequence $ [ replicateM 3 ['A'..'Z'], ["-"], replicateM 4 ['0'..'9'] ] - now how would i go about first randomizing this list (but in such a way) that I given an index I can run this program and output the 'next' value in the sequence?
15:10:09 <benmachine> http://www.willamette.edu/~fruehr/haskell/SeussFinal2.JPG
15:10:30 <wavded> so i want a 'fixed' random list that can be accessed but the program will have to randomize it the same way every time
15:10:47 <NihilistDandy> lol, haskerl
15:10:54 <wavded> and just output the next value in the sequence given the index, if that makes sence
15:11:09 <erus`> http://ro-che.info/ccc/02.html haha
15:11:16 <hpc> wavded: use any other PRNG but start from the same seed each time
15:11:28 <hpc> (instead of seeding with the current time at startup, seed with 0 or something)
15:11:32 <NihilistDandy> chrisdone: I haven't said a Monty Python quote out of context in 6 years for that very reason
15:11:33 <chrisdone> kmc: amusingly, xckd is often taking that place. people link or quote xkcd instead of expressing their own opinion
15:12:05 <NihilistDandy> "context" in this case means "We are talking about Monty Python"
15:12:35 <MHD> What naming convention is bes, CamelBacking or under_store_spaces?
15:12:38 <MHD> best*
15:12:45 <wavded> ok, not sure what PRNG is (again total noob)
15:12:54 <kmc> @google PRNG
15:12:55 <lambdabot> http://en.wikipedia.org/wiki/Pseudorandom_number_generator
15:12:55 <lambdabot> Title: Pseudorandom number generator - Wikipedia, the free encyclopedia
15:12:56 <hpc> psuedo-random number generator
15:13:02 <benmachine> MHD: camelCase is more common
15:13:04 <NihilistDandy> MHD: camelCase
15:13:06 <wavded> ah thanks :)
15:13:14 <MHD> all righty then
15:13:18 <kmc> in Haskell it's common to name top-level functions with camelCase and local vars with underscores
15:13:19 <wavded> now i really feel like a noob :)
15:13:20 <kmc> ymmv
15:13:30 <ByronJohnson> MHD: Personally, I prefer the latter, but camelCase is more common.
15:13:42 <hpc> kmc: really? i thought it was camelCase all the way
15:13:52 <kmc> common = what i do sometimes
15:13:53 <kmc> ;P
15:13:58 <hpc> heh
15:13:59 <kmc> i don't actually have numbers on this
15:14:26 <benmachine> kmc: you give your local vars multi-letter names? :O :O :O
15:14:27 <hpc> the cases when i have multi-word local vars in haskell is vanishingly small
15:14:30 <MHD> also, !?$ will be variable characters in my language
15:14:42 <MHD> so technically you can do stuff with $_
15:14:46 <MHD> or something
15:14:54 <ByronJohnson> MHD: You could choose either style as long as you're consistent.
15:15:00 <NihilistDandy> What's the GHC extension that lets you use Unicode notations?
15:15:01 <MHD> yeah
15:15:41 <ByronJohnson> NihilistDandy: UnicodeSyntax
15:15:51 <chrisdone> truth be known i never found monty python that funny. if i'd seen it on some random channel having never heard of it before i wouldn't've given it the time of day. i guess nerds like it because it's very quotable and a good substitute for wit
15:15:55 <ByronJohnson> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax
15:15:56 <chrisdone> </offtopic>
15:15:58 <NihilistDandy> I might have to look into that. :D
15:16:29 <stobix> hm, wonder if I can define the unicode invisible multiplicator symbol as an operator in haskell...
15:16:48 <benmachine> chrisdone: you mustn't assume that people only find things funny that you don't because they are lacking in senses of humour :P
15:17:07 <NihilistDandy> @hoogle <~
15:17:07 <lambdabot> No results found
15:17:11 <thoughtpolice> chrisdone: i think a lot of monty python's popularity had to due with the era. that said i think it's funny, but there are definitely funnier skits than others - no comedian/tv show is "just funny without question"
15:17:31 <thoughtpolice> unless you're a redditor, then louis CK is in fact, god on earth.
15:17:45 <c_wraith> hmm.  proof I'm not a redditor
15:17:49 <hpc> i have yet to see an unfunny bill cosby skit
15:18:09 <NihilistDandy> *
15:18:09 <NihilistDandy> ★
15:18:09 <NihilistDandy> 0x2605
15:18:09 <NihilistDandy> BLACK STAR
15:18:12 <NihilistDandy> Who uses that?
15:18:27 <thoughtpolice> chrisdone: fwiw I think louis CK is funny too, but i'm not obsessed with him. i've just seen a few random clips on youtube
15:18:39 <thoughtpolice> er, i meant to send that to c_wraith
15:18:41 <thoughtpolice> stupid autocomplete
15:18:43 <danharaj> NihilistDandy: roguelikes. duh.
15:18:51 <NihilistDandy> :|
15:18:53 <dolio> There are better comedians than him, I'd say.
15:19:09 <thoughtpolice> dolio: no doubt
15:19:13 <chrisdone> dolio: which comedians do I like better?
15:19:16 <dolio> Roguelikes are only allowed to use ascii.
15:19:39 <ByronJohnson> NihilistDandy: (You can already use unicode without it; UnicodeSyntax just provides unicode aliases for specially handled syntax, like type sygnatures.)
15:19:40 <dolio> How would I know which comedians you like better?
15:20:18 <chrisdone> dolio: what does "better comedians than him" mean?
15:20:30 <DukeDave> So, I keep getting "Ambiguous occurrence `mapM'" between Control.Monad and Data.Traversable.
15:20:30 <DukeDave> What do?
15:20:42 <dolio> Funnier.
15:20:42 <hpc> qualify yo imports
15:20:43 <hpaste> “mitchell & webb” pasted “hit and miss (for thoughtpolice)” at http://hpaste.org/49791
15:20:53 <DukeDave> Are they equivalent ?
15:21:17 <kmc> DukeDave, the latter is more general
15:21:21 <kmc> :t Control.Monad.mapM
15:21:23 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:21:26 <NihilistDandy> And people call us smug.
15:21:26 <kmc> :t Data.Traversable.mapM
15:21:27 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:21:34 <kmc> NihilistDandy, smug lisp weenie!
15:21:48 <NihilistDandy> kmc: I've spent way too much time on C2
15:21:50 <kmc> DukeDave, take t = []
15:22:01 <kmc> NihilistDandy, you mean, any time at all?
15:22:09 <NihilistDandy> kmc: Exactly
15:22:14 <thoughtpolice> what the hell
15:22:19 <thoughtpolice> copumpkin: was that you
15:22:21 <thoughtpolice> or was it dolio
15:22:25 <DukeDave> So I'm safe to hide the Control.Monad instance?
15:22:25 <clsmith> is Data.Monoid.Lexical.SourcePosition directly pluggable into Data.FingerTree? (i honestly can't work out the finger tree's needs)
15:22:36 <kmc> DukeDave, yeah
15:22:37 <DukeDave> I'd rather that than having to qualify everywhere
15:22:38 <dolio> It wasn't me, and copumpkin isn't at his computer.
15:22:47 <thoughtpolice> kmc then?
15:22:52 <kmc> :D
15:22:52 <benmachine> it was hpaste, it's developed sentience
15:22:58 <thoughtpolice> i shoulda known
15:23:09 <thoughtpolice> kmc: fwiw i just saw TM&WL thanks to copumpkin the other day
15:23:13 <thoughtpolice> :D
15:23:28 <DukeDave> Gah, Control.Monad.Reader gives an instance too
15:24:00 <kmc> DukeDave, it's the same as Control.Monad
15:24:15 <kmc> i would import Traversable qualified
15:24:22 <kmc> or just hide Traversable.mapM
15:24:41 <chrisdone> I like Steven Wright's deadpan one liners. Milton Jones is a similar one linist/punster of recent
15:25:25 * DukeDave is sad
15:25:34 <kmc> don't be sad
15:25:37 <kmc> it sucks
15:25:53 <benmachine> I find being happy to be preferable
15:25:54 <DukeDave> I don't need fmapDefault
15:26:08 <DukeDave> And I can't reemmber why I need that :D
15:26:35 <chrisdone> 'my uncle, was a weird guy. he had false legs.. real feet.'
15:26:47 <DukeDave> Oh, even with Traversable qualified it's still asking for disambiguation?
15:26:49 <dolio> chrisdone: Were you asking me who I thought was funnier? Because I can answer that question. I can't answer who you think is funnier.
15:27:04 <DukeDave> Oops, missed the qualified :)
15:28:13 <acowley> The up-front investment required to get someone else's code to potentially work always pushes me along the path to NIH
15:28:58 <acowley> C++ is the worst for this. Compiling will be painful, then There Will be SEGFAULTs
15:29:32 <kmc> DukeDave, right, you can import "as T" without qualified
15:29:45 <kmc> Haskell's module system is fundamentally primitive, but the features it does give you are nicely orthogonal
15:31:31 <chrisdone> dolio: i interpreted 'x is better' (as opposed to 'i prefer x') as speaking for everyone, like, a hammer is better for hammering than a baked potato
15:31:32 <robinhoode> How does one completely wipe out the ghc-pkg list and start over? Just rm -rf all the directories?
15:32:19 <aninhumer> chrisdone: <contrived situation where baked potato is superior>
15:33:17 <chrisdone> aininhumer: nooo, your exception proves the rule! my argument falls like a house of cards. /me waits for <contrived scenario where house of cards would be a stable construction>
15:33:48 <chrisdone> robinhoode: typically i just remove the .ghc/version/ dir, yeah
15:34:07 <chrisdone> but there's a packages dir i remove specifically. hm
15:34:12 <robinhoode> But what about under /var/lib?
15:34:19 <robinhoode> There's broken stuff there too.. :(
15:34:31 <chrisdone> nah i don't touch there personally
15:34:54 <chrisdone> have you been sudo cabal install'ing?
15:35:29 <robinhoode> I'm guessing that "sudo cabal ..." is not standard practice..
15:37:00 <chrisdone> i don't think it is
15:37:32 <robinhoode> nm.. I did an apt-get reinstall and everything seems to be okay
15:37:49 <robinhoode> Thanks for the tip, though
15:39:01 <chrisdone> thoughtpolice: hehe i like louis ck :)
15:39:23 <chrisdone> I love discovering new comedians
15:40:11 <dolio> Incidentally, I do like Louis CK. He's just probably not in my top 3.
15:40:31 <chrisdone> dolio: who's in your top 3?
15:40:42 <dolio> I'd have to think about it a while.
15:41:49 <PhilRod_> chrisdone: if you like milton jones, you should listen to forty nights in the wildebeest (dan freedman and nick romero)
15:41:59 <dolio> Brian Regan and Patton Oswalt would probably get in.
15:42:44 <NihilistDandy> <3 Patton Oswalt
15:43:31 <MHD> I wonder...
15:44:49 <MHD> My language idea needs some GC, but LLVM doesn't suport concurrent GC...
15:44:57 <dolio> David Cross might be the 3rd in there.
15:45:55 <NihilistDandy> dolio: Most people with a Mr. Show pedigree are pretty great
15:46:05 <dolio> Yeah.
15:46:43 <dolio> I'm thinking mainly of stand up, and I think David Cross is the only one whose act I've heard.
15:47:03 <dolio> That show was great, though.
15:51:58 <heatsink> MHD: Boehm Demers Weiser?
15:52:34 <MHD> heatsink: Yeah I was thinking that, but I want Wip to support lots of concurrency...
15:52:53 <MHD> heatsink: and LLVM is weird when it comes to GC and concurrency
15:54:50 <heatsink> How so?
15:54:55 * hackagebot semigroups 0.6 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.6 (EdwardKmett)
15:54:57 <MHD> Actually, the way I am designing my language... making a wrapper object to support Refernece counting is trivial.
15:55:56 * hackagebot semigroupoids 1.2.2.2 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.2.2.2 (EdwardKmett)
15:56:13 <copumpkin> AND SO IT BEGINS, ONCE MORE
15:56:14 <heatsink> reference counting can be expensive though
15:56:24 --- mode: ChanServ set +q *!*@li229-222.members.linode.com
15:56:55 <chrisdone> other ones, meh, louis ck, a winrar.
15:57:02 <chrisdone> thoughtpolice: got any other comedians?
15:57:59 <chenwl> import Data.ByteString.Lazy as L
15:58:07 <Nimatek> chrisdone: George Carlin, Bill Hicks
15:58:23 <edwardk> changed the default fixity of <> to agree with + and ++ now i have to rebuild a ton of crap.
15:58:32 <chenwl> import Data.ByteString.Char8
15:58:36 <MHD> chrisdone: Eddie Izzard, Louis CK
15:58:40 <acowley> edwardk: new topSort makes grad 4x faster
15:58:42 <thoughtpolice> chrisdone: patton is of course a favorite, bill hicks is good (but dead,) and i do like louis ck. but frankly i don't really listen to much comedy these days. or watch TV/anything else for that matter.
15:58:52 <acowley> edwardk: and it works for big data
15:58:56 <chenwl> pack "asdfsdf"  returns type ByteString not L.ByteString
15:58:57 <edwardk> acowley: woohoo!!!
15:59:06 <edwardk> acowley: patch patch patch!
15:59:23 <chenwl> how to make haskell regard L.ByteString and ByteString as one thing
15:59:24 <acowley> edwardk: I'll send you the two I wrote in case you have some ad tests you can run with them
15:59:28 <Saizan> chenwl: import Data.ByteString.Lazy.Char8 instead
15:59:30 <edwardk> sweet
15:59:51 <chrisdone> nimatek: mhd: i've already heard of and like george carlin, bill hicks and eddie izzard. thanks anyhoo
16:00:13 <chenwl> Saizan: lazy bytestring and bytestring can not replace each other?
16:00:17 <MHD> chrisdone: David Mitchell?
16:00:19 <chrisdone> thoughtpolice: fair do's
16:00:25 <chrisdone> mhd: of course
16:00:34 <edwardk> acowley: in exchange i'll send you that double-only fast-grad as soon as i can ;)
16:00:36 <Saizan> chenwl: what do you mean by that? they are not the same type
16:00:50 <chenwl> Saizan: I c
16:00:50 <copumpkin> there needs to be easier conversion between them
16:00:54 <copumpkin> toLazy/fromLazy
16:01:05 <thoughtpolice> copumpkin: totes
16:01:12 <smoge> how to clean and reinstall everything? I tried on Arch: pacman -Rc ghc and removed ~/.cabal
16:01:17 <smoge> but it seems not to work
16:01:24 <acowley> edwardk: there's really no rush on that. Now that I can run with non-micro-sized data I can see what works and doesn't work to get a better idea where optimization can pay off.
16:01:25 <smoge> also ghc-pkg recache
16:01:28 <NihilistDandy> smoge: Did you remove ~/.ghc
16:01:28 <NihilistDandy> ?
16:01:29 <Saizan> you want to remove ~/.ghc not cabal
16:01:31 <smoge> no
16:01:36 <smoge> hum, thanks
16:01:42 <chrisdone> copumpkin: at least it's like tha tin Data.Text
16:01:47 <chrisdone> tolazy/fromlazy
16:01:52 <chenwl> Saizan: Are ByteString in ...Lazy.Char8 and ...Lazy the same type
16:01:56 <acowley> edwardk: I'm sure I'll want the Hessian eventually, for example
16:01:59 <Saizan> chenwl: yes
16:02:17 <edwardk> acowley: then you're stuck with the ad package
16:02:50 <acowley> "stuck" sounds too negative :)
16:02:56 <edwardk> fair nuff
16:02:57 <edwardk> =)
16:03:04 <acowley> playing with topSort makes me hopeful there are other areas that can be sped up
16:03:25 <edwardk> yeah
16:03:34 <edwardk> though that is one of the few external dependencies i have
16:04:00 <edwardk> the biggest speed improvement would be for me to give up the 'hiding' of the ad modes, so i lose the 'interpreter' overhead
16:04:04 <kmc> what's the name of the rule that concurrent algorithms should not depend on the relative speed of execution of threads?
16:04:10 <kmc> i want to say "dijkstra's condition" or something
16:05:01 <chrisdone> mhd: i guess you like bill bailey? :)
16:05:01 <acowley> edwardk: is that really a factor for these big gradient calculations?
16:05:19 <MHD> chrisdone: yeah
16:05:38 <edwardk> acowley: try benchmarking rad vs ad and see how they perform relative to one another. i haven't benchmarked it
16:06:00 <edwardk> rad avoids paying the interpreter tax
16:06:09 <copumpkin> plus rad is like totally rad
16:06:29 <acowley> edwardk: okay, will do
16:06:43 <sshc> Can a type or data family be extended in a separate module?
16:06:49 <copumpkin> yeah
16:06:51 <edwardk> yes
16:08:24 <chrisdone> kinda funy how there's more or less no stand up in italy or most of europe it seems. look at the "list of stand-ups" in wikipedia and there're maybe 20 in each country max. UK has about 130
16:08:39 <acowley> rad isn't listed on hackage?
16:08:59 <acowley> and I can't install it with cabal
16:09:07 <NihilistDandy> chrisdone: It's easier to make puns in English~
16:09:17 <sm_> chrisdone: those countries also have their own wikipedias
16:09:22 <edwardk> acowley: it was deprecated i didn't realize that removed the ability to install
16:09:30 <edwardk> acowley: you can pull from github.com/ekmett/rad
16:09:44 <acowley> edwardk: I'm getting a base version conflict that doesn't make sense to me when I try to cabal install rad
16:09:56 <edwardk> it probably was capped too low
16:10:12 <edwardk> removing the upper bound or setting it to 5 should work
16:10:34 <kmc> NihilistDandy, why's that?
16:10:49 <acowley> edwardk: btw, are the graphs you sort always going to be acyclic?
16:10:57 <edwardk> yes
16:11:04 <edwardk> which gives you other opportunities for improvement =)
16:11:06 <acowley> yeah
16:11:09 <acowley> it's like 10%
16:11:20 <NihilistDandy> kmc: More homophones
16:11:47 <edwardk> nice =)
16:12:12 <chrisdone> sm_: well my colleagues tell me there's no stand-up in italy, france or latvia. i'm not judging purely based on wikipedia, that's what i looked at after hearing from people who live in those countries
16:12:22 <acowley> I don't know what's going on with this base version thing
16:12:36 <edwardk> i'll pull and install it
16:12:43 <chrisdone> nihilistdandy: so english is the language of comedy?
16:12:59 <DukeDave> So I have a Fractional f, and I want to use it with 'sin', but:     Couldn't match expected type `Double' against inferred type `f'
16:13:08 <kmc> :t realToFrac
16:13:09 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
16:13:11 <NihilistDandy> chrisdone: There are some pretty funny Russian comedians, but yes, as a massive generalization.
16:13:46 <DukeDave> But, but: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:sin
16:13:47 <acowley> maybe due to the containers constraint
16:13:57 <edwardk> ah its the data-reify constraint i think
16:14:01 <NihilistDandy> Though this is much funnier in Russian: http://www.youtube.com/watch?v=wcZlxCNzQqw
16:14:21 <sm_> ok, well I agree it is funny
16:14:21 <acowley> edwardk: yeah that and containers are the only two whose upper bounds are causing an impact
16:14:22 <Saizan> chrisdone: milan is pretty famous for having stand-ups / cabaret places
16:14:50 <DukeDave> kmc: I already have a Fractional
16:14:55 <chrisdone> saizan: i think milan is the only place in italy (bar rome) that anything happens in. :-P all the music gigs i was looking at on last.fm are all in milano
16:14:58 <edwardk> hrmm the version ont he repo looks otherwise busted though
16:15:14 <Eelis> chrisdone: "stand up" in other countries may have higher standards. in britain, anybody can just go stand on a stage with a microphone and crack one-liner jokes. here in the netherlands, we expect a cabaretier to have underlying themes, social commentary, coherence, and preferably an instrument or two that they play
16:15:27 <edwardk> one sec. patching
16:16:07 <edwardk> uploaded to github. uploaded to hackage
16:16:16 <chrisdone> eelis: yeah, it'll probably stay that way then
16:16:26 <DukeDave> kmc: And that Fractional f won't go in to sin :(
16:16:58 <monochrom> "stand up comedian with batteries included" :)
16:17:21 <acowley> edwardk: does it really need to use the older containers?
16:17:29 <edwardk> acowley: no
16:17:40 <edwardk> acowley: the newer versions just weren't out when it was released
16:17:53 <edwardk> ah i missed the containers in the list one sec.
16:17:57 <copumpkin> so, I have a general question
16:18:12 <NihilistDandy> I have a general answer.
16:18:12 <copumpkin> oh, maybe I don't
16:18:23 <NihilistDandy> And yet I still do.
16:18:27 <kmc> i have a uselessly specific, pedantic answer
16:18:33 <Saizan> now you owe us a question
16:18:39 <monochrom> question `mplus` return ()
16:18:48 <copumpkin> nah, I don't need it after all
16:18:54 <Cale> So have people heard about GHC getting a proper kind system?
16:19:09 <NihilistDandy> Define "proper"
16:19:09 <edwardk> uploaded to github. uploaded to hackage
16:19:18 <chrisdone> polymorphic kinds?
16:19:23 <edwardk> cale: yeah but the example they are starting with is this Nat nightmare
16:19:29 <monochrom> is GHC evolving into a dependent type system
16:19:43 <monochrom> (joking! :) )
16:19:46 <kmc> GHC is evolving into "avoid dependent types at all costs"
16:19:56 <Cale> SPJ just off-hand mentioned to the haskell-prime list that they're working on a system for typed type-level programming.
16:20:01 <monochrom> haha
16:20:07 <Cale> Similar to SHE, with different syntax.
16:20:20 <kmc> but how will we do typed type-type-level programming?
16:20:20 <copumpkin> so, I have this type
16:20:20 <copumpkin> fold : ∀ {n} {a} {A : Set a} → Association n → (A → A → A) → Vec A n → A
16:20:24 <Cale> and with support for poly-kinded type level functions
16:20:32 <Saizan> i think there were a few talks on that already
16:20:37 <kmc> if only there were some theory that encompasses an arbitrary number of levels
16:20:39 <Cale> orly?
16:20:41 <kmc> :D
16:20:45 <Cale> Were they recorded?
16:20:54 <copumpkin> it's an agda type, but the question is more general
16:21:08 <copumpkin> so my association type only supports 1 or more elements
16:21:15 <acowley> edwardk: this doesn't have the strictness patch either
16:21:23 <copumpkin> so all my folds are more or less equivalent to foldl1 or foldr1
16:21:27 <monochrom> coq's logic encompasses an arbitrary number of levels
16:21:29 <copumpkin> or whatever other association1
16:21:30 <Saizan> Cale: someone linked me the slides at some point
16:21:46 <copumpkin> so the natural shape for my algebraic structure has no unit
16:21:52 <copumpkin> semigroups, commutative semigroups, etc.
16:22:08 <copumpkin> how do I go about folding over possibly-empty structures?
16:22:20 <Cale> http://hackage.haskell.org/trac/ghc/raw-attachment/wiki/GhcKinds/fc-sep.pdf -- work-in-progress design document
16:22:42 <kmc> any better way to write this?  f = fmap (map toEnum) . g . map fromEnum
16:22:52 <kmc> f :: (Enum a) => [a] -> IO [a]
16:23:45 <Saizan> Cale: http://www.cis.upenn.edu/~byorgey/talks/typetype-HIW-20101001.pdf <- slides
16:25:01 <NihilistDandy> Is there anything byorgey *hasn't* written a paper about or given a talk about?
16:25:02 <int-e> @type fmap (fmap (fmap (fmap toEnum)) ?g) (fmap fromEnum)
16:25:03 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) a1 (f2 :: * -> *). (Enum a, Functor f, Functor f1, ?g::f2 Int -> f1 (f Int), Enum a1, Functor f2) => f2 a1 -> f1 (f a)
16:26:25 <Saizan> copumpkin: "Either (n == 0) (Association n)" take something like this?
16:26:41 <copumpkin> Saizan: yeah, I guess I'll make a type for that, but it felt ugly :/
16:26:45 <int-e> @type \(g :: [Int] -> IO [Int]) -> fmap (fmap (fmap (fmap toEnum)) g) (fmap fromEnum) -- and no, I'm not seriously suggesting this.
16:26:46 <lambdabot> forall a a1. (Enum a, Enum a1) => ([Int] -> IO [Int]) -> [a1] -> IO [a]
16:27:12 <acowley> edwardk: rad is significantly slower than ad for some reason
16:27:42 <edwardk> acowley: i'm okay with that actually
16:27:54 <edwardk> i hadn't benchmarked one against the other in a very long time
16:28:22 <edwardk> and it also means i don't have to bend over backwards to support a legacy package
16:28:23 <acowley> edwardk: okay, but it makes the Mode interpretation overhead harder to gauge
16:28:30 <acowley> edwardk: true
16:28:36 <edwardk> yeah
16:28:49 <edwardk> makes me leery of moving to that middle ground with monomorphic modes
16:29:00 <clsmith> hey all, i get a ghc panic. any ideas? http://sprunge.us/gGPJ
16:29:27 <acowley> edwardk: I agree
16:29:27 <edwardk> guess the mode is carrying around all the dictionaries i need, so the 'interpreter' overhead consists of cheaper dict construction
16:38:53 <MHD> What comment symbol do you guys think is the best?
16:39:11 <edwardk> MHD: which ever the language you are working with requires you to use ;)
16:39:25 <dmwit> I prefer the comment system from the "whitespace" language.
16:39:35 <kmc> i like brainfuck's
16:39:47 <MHD> dmwit: everything that isn't whitespace?
16:40:11 <kmc> i will make a language where code is ASCII and comments are non-ASCII
16:40:15 <edwardk> MHD: well, it is easy to remember
16:40:35 <MHD> kmc: Great for japanese coders!
16:40:42 <edwardk> kmc: i guess japanese and chinese coders will like it
16:40:49 <MHD> And arabic
16:40:55 <kmc> and upside-down
16:40:56 <MHD> And Russian
16:41:01 <edwardk> at least until they go to type in a loan-word
16:41:15 <kmc> edwardk, have to use katakana for that
16:41:47 <int-e> hmm, start a comment with a vertical tab; end it with a carriage return. have fun with any program that does any kind of automatic line end conversion.
16:41:53 <edwardk> Just type in all your comments umop apisdn.
16:44:44 <acowley> edwardk: pull request filed
16:45:04 <edwardk> sweet. i'll tweak it as soon as i tweak the rest of ad's dependencies for my current binge
16:46:27 <acowley> edwardk: Great! I'm still going to push on large gradients to see if gradient descent gets too bogged down in flat regions.
16:46:52 <edwardk> let me know how it works out for you.
16:47:04 <edwardk> if its too bad i can see if i can get some eigenbasis plumbing in there
16:48:31 <acowley> edwardk: well, it's too slow at the moment for simple things, so I'm going to see if I can get any interesting results with more complicated cost functions without slowing down even more
16:48:45 <edwardk> =/
16:48:47 <acowley> I don't know what eigenbasis plumbing is, but it sounds expensive
16:48:55 <acowley> plumbers aren't cheap
16:48:58 <edwardk> yeah
16:49:35 <edwardk> especially the eigenplumber. there is only one of him after all
16:50:02 <acowley> edwardk: the problem is that for a 64x64 image it's taking 10s. Suppose there's a relatively low-hanging factor of 2, I still need to do something pretty impressive to justify thinking for 5s about such a small image.
16:50:07 <acowley> dude is in demand
16:50:20 <edwardk> yeah
16:50:24 <acowley> it's hard for all other plumbers since people always like to define them in terms of him
16:50:57 <edwardk> worse all of them want to become him just for a little while, then go back to their usual plumberly ways
16:51:05 <acowley> I'd also like to try running ad output through the levmar package
17:03:25 <acowley> d'oh: have to pay O(n) to convert between Vector and Vector.Storable
17:03:32 <acowley> I can't win
17:04:08 <c_wraith> Why does that surprise you?
17:04:33 <acowley> lambdabot: can Haskell help me win?
17:04:42 * acowley gives up
17:07:33 <aninhumer> @vixen Can Haskell help acowley win?
17:07:33 <lambdabot> church is my favourite computer scientist.
17:13:22 <acowley> aninhumer: it's just not happening for me today
17:29:07 <sutabi_> I am tring to go through a list of lists https://gist.github.com/1120615#L31 and using case which I know has to be wrong. How would I go through each row?
17:30:27 <aavogt> sutabi_: use another mapM_
17:30:57 <aavogt> but in that situation putting the list first makes more sense (forM_ = flip mapM_):
17:31:31 <sutabi_> aavogt: I do that on line 32 row@_ -> mapM_ printMovieData row but it only ever hits the first row
17:31:57 <aavogt>  forM_ results (mapM_ printMovieData)
17:33:26 <sutabi_> aavogt: thanks I'll give it a try!
17:33:59 <aavogt> then again, it doesn't look to me like   printMovie :: Show b => [[(String,b)]] -> IO ()
17:34:21 <aavogt> it looks like   [(String, b)] -> IO ()
17:37:48 <sutabi_> aavogt: hm... little hicup since it can't be "b" I tried "SqlValue" instead but now I get "Non type-variable argument in the constraint: Show SqlValue (Use -XFlexibleContexts to permit this)"
17:39:00 <hpaste> sutabi_ pasted “wrong type” at http://hpaste.org/49793
17:39:14 <aavogt> sutabi_: you can drop the   Show SqlValue =>    part
17:40:13 <aavogt> this probably doesn't affect how your code works, but you don't need to use  @  in patterns where you have
17:43:13 <aavogt> sutabi_: http://hpaste.org/49794
17:44:30 <aavogt> I suspect now that it quits for you after one row because your   printMovieData  will crash the program when it gets to the "year" column
17:44:35 <mietek> Hm
17:45:15 <aavogt> but then you'd get a message saying that thing
17:46:50 <int80_h> is there a way to paginate in ghci?
17:47:13 <int80_h> I'm messing about with tagsoup and want to inspect results but they scroll by too fast
17:47:40 <gienah> int80_h: you could run ghci in emacs
17:47:43 * gienah ducks
17:48:36 <parcs> int80_h: tmux ;)
17:48:42 <int80_h> you are a terrible terrible person :)
17:48:53 <int80_h> tmux?
17:49:01 <hpaste> mietek pasted “Exception problem” at http://hpaste.org/49795
17:49:09 <parcs> terminal multiplexer. run ghci in that
17:49:20 <mietek> I'd hoped this program would output "OK"
17:49:23 <mietek> Instead, it outputs "e: MyException"
17:49:27 <mietek> Any idea why?
17:49:54 <shachaf> mietek: yourFunction is not a function.
17:49:58 <Saizan> mietek: use (evaluate myFunction)
17:50:17 <shachaf> Anyway, yes, "return"ing it doesn't force the thunk.
17:50:35 <int80_h> parcs: oh yeah , like "screen"
17:50:37 <int80_h> good idea
17:50:47 <parcs> yeah, but better
17:51:02 <int80_h> parcs: can you point me to better?
17:51:06 <Saizan> mietek: exceptions from pure values get thrown only when they get forced
17:51:15 <parcs> what do you mean?
17:51:47 <mietek> Right, makes sense
17:51:57 <int80_h> parcs: oh nm. I see you mean that tmux is the name of the utlity
17:52:14 <int80_h> parcs: I thought you were just using shorthand, at first.
17:52:28 <mietek> Saizan: however, in my real code, I'm throwing both from pure code, and from an IO action
17:52:56 * aavogt doesn't understand the difference between `evaluate' and (return $!)
17:53:02 <kmc> "IO action which throws when evaluated" and "IO action which throws when executed" are different
17:53:24 <aavogt> in this case you can use either
17:53:30 <kmc> (evaluate ⊥) gives you the latter and (return $! ⊥) the former
17:54:06 <parcs> @src evaluate
17:54:06 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:54:29 <kmc> they say:  evaluate x = (return $! x) >>= return
17:54:35 <kmc> this proves that IO is not a monad, by the way!
17:54:52 <coppro> bottom ruins everything
17:54:58 <kmc> indeed
17:55:04 <hpaste> mietek annotated “Exception problem” with “Exception problem (annotation)” at http://hpaste.org/49795#a49796
17:55:08 <parcs> kmc: you should write a blog post ;)
17:55:10 <shachaf> IO isn't a monad? :-(
17:55:11 <mietek> So this is my real code
17:55:23 <mietek> But the evaluate in there doesn't help
17:55:27 <kmc> i'm not sure the Report gives a precise semantics for what happens when you force an IO action
17:55:28 <Saizan> i think it was decided that evaluate x = (return $! x) >>= return was false
17:55:45 <kmc> Saizan, it makes sense to me from the free monad view of IO
17:55:49 <kmc> (>>= return) adds a constructor
17:55:56 <kmc> to hide it from seq
17:56:07 <kmc> the actual GHC implementation of 'evaluate' is:
17:56:09 <kmc> evaluate a = IO $ \s -> let !va = a in (# s, va #) -- NB. see #2273
17:56:47 <kmc> http://hackage.haskell.org/trac/ghc/ticket/2273
17:57:00 <roconnor> kmc: how does it look from a stream transformer vantage point?
17:57:06 <kmc> don't know roconnor
17:57:56 <Saizan> "free monad" doesn't necessarily mean you have a :>>=: constructor
17:58:15 <mietek> I can't believe using a stack of monad transformers is so much easier than getting exceptions right
17:58:26 <kmc> > ((return $! undefined) :: IO ()) `seq` ()
17:58:26 <lambdabot>   *Exception: Prelude.undefined
17:58:31 <kmc> > ((evaluate undefined) :: IO ()) `seq` ()
17:58:32 <lambdabot>   Not in scope: `evaluate'
17:58:36 <kmc> > ((Control.Exception.evaluate undefined) :: IO ()) `seq` ()
17:58:37 <lambdabot>   Not in scope: `Control.Exception.evaluate'
17:58:51 <kmc> anyway it's () ;P
18:00:06 <mietek> Does this mean I need to evaluate all my pure calls which may throw?
18:00:08 <Saizan> well, my point was that (return $! x) >>= return and evaluate x don't evaluate to the same
18:00:23 <mietek> Evaluating just the result of the top-level action doesn't seem to help
18:00:30 <Saizan> mietek: i suggest to avoid throwing from pure code
18:01:01 <mietek> I'm writing this as an exercise to learn how to deal with exceptions in Haskell
18:01:09 <Saizan> but if you must, you can call evaluate just from the toplevel, if you add enough strictness
18:01:10 <mietek> I guess "avoid using them" is a lesson
18:01:31 <kmc> i second "avoid throwing from pure code"
18:01:33 <kmc> except for fatal errors
18:01:46 <mietek> Well, these are supposed to be fatal errors
18:02:04 <kmc> Saizan, how to distinguish «(return $! x) >>= return» from «evaluate x» ?
18:02:09 <aavogt> exceptions are lazier than the alternative
18:02:10 <Saizan> not so fatal if you catch them
18:03:49 <mietek> Saizan: my program handles interactive input, so I want to let the user know about any mistakes in the input, but also let the user continue
18:04:03 <mietek> So there is only a single exception handler in the main loop
18:04:11 <mietek> (The other handler is to make exiting via EOF nice)
18:04:40 <mietek> Saizan: can you elaborate on what you mean by adding enough strictness?
18:05:01 <Saizan> mietek: use a parser that reports errors then
18:06:21 <Saizan> mietek: i mean that if you e.g. have a list evaluate will only force the first cons cell, you've to call evaluate to something that when forced will force the whole list instead, since thunks might be lurking inside
18:06:47 <mietek> My top-level IO action returns ()
18:07:25 <mietek> I thought evaluating the result of the top-level IO action should be enough
18:07:32 <mietek> Where am I wrong?
18:07:50 <Saizan> well, maybe it's executing the action itself that's throwing then?
18:08:12 <Saizan> show the real code
18:09:07 <Saizan> or, well, if you have "do x <- action; try (evaluate x);" go with "do y <- try action; .." instead
18:09:27 <Saizan> kmc: maybe you don't
18:10:03 <mietek> Saizan: http://hpaste.org/49795
18:10:36 <mietek> Saizan: first, I had "maybeErr <- try (cmd frame)", then I added "maybeErr' <- evaluate maybeErr"
18:10:56 <mietek> I also tried "maybeErr <- try do { result <- cmd frame; evaluate result }"
18:11:36 <Saizan> but the last catch around loop is catching these exceptions, right?
18:11:56 <mietek> No, it's not
18:12:12 <Saizan> maybe it's catching and rethrowing?
18:12:12 <mietek> That's a Prelude.catch, just for the EOF error
18:12:25 <Saizan> ok
18:12:37 <Saizan> put a try around readCommand then
18:12:58 <mietek> Oh snap
18:13:06 <mietek> Of course, I should have
18:13:14 <mietek> Sorry, my bad
18:14:10 <mietek> Yeah, works perfectly now
18:14:12 <mietek> Thanks :)
18:15:45 <Saizan> np
18:21:04 <sutabi_> aavogt: still not having much getting more then one result to print out, https://gist.github.com/1120615
18:21:16 <sutabi_> it stops with test-mysql.hs: test-mysql.hs:(36,22)-(38,41): Non-exhaustive patterns in case
18:22:02 <aavogt> sutabi_: that would have been helpful if you could have said that as the first thing
18:22:31 <aavogt> sutabi_: my hpaste up there should fix that (you need to have a default case)
18:22:32 <sutabi_> >.< sorry
18:24:02 <sutabi_> aavogt: oh I had missed that, man that was a lot simpler then I thought >.>
18:27:42 <ozataman> is there a good sorted set implementation for haskell?
18:28:22 <kmc> Data.Set lets you iterate in sorted order
18:28:29 <kmc> is that what you mean?
18:35:02 <hpaste> scooty-puff pasted “RecT” at http://hpaste.org/49797
18:35:28 <scooty-puff> is it possible to define that without requiring MonadFix?
18:35:30 <scooty-puff> i wouldn't think so..
18:35:38 <scooty-puff> or is there in general a better way to define this?
18:56:48 <ozataman> kmc: well, Data.Sort has an implicit order. I meant something like insertion order, or perhaps a score-based ordering like in redis sorted sets
18:57:53 <dolio> Anyone remember quick how to turn on certain flags, like UnsafeChecks in vector? I do this like twice a year and forget in between.
19:00:05 <dolio> I guess it's "cabal install -f '+UnsafeChecks'"?
19:03:09 <dmwit> dolio: no +
19:03:26 <dmwit> dolio: -f UnsafeChecks or -f -UnsafeChecks
19:03:32 <dolio> Okay.
19:07:06 <deech`> Hi all, can I use have multiple patterns in a case expression have the same action? So for instance "case (x,y) of ; (A,B) | (B,A) -> e;  _ -> error "error"
19:09:04 <kmc> sadly no
19:09:14 <kmc> union patterns would be nice and are (I think) a reasonable extension to Haskell
19:09:17 <kmc> but afaik unimplemented
19:10:04 <deech`> Is there some other idiom for handling this without cutting-and-pasting code?
19:10:47 <dmwit> deech`: where clauses are the idiom
19:10:53 <kmc> or "let"
19:11:43 <kmc> «case scrut of altA | altB -> e; alts » ≡ «let x = e in case scrut of altA -> x; altB -> x; alts»
19:12:46 <deech`> Gotcha. Thanks!
19:14:24 <MaskRay> By default, the Network module doesn't handle octets which were greater than 0x7F correctly.
19:15:34 <MaskRay> If I execute `hSetEncoding h utf8', it won't treat a stream of octets as a single UTF-8 character.
19:16:47 <kmc> are you using sendTo / recvFrom?
19:18:26 <kniu> http://research.microsoft.com/en-us/um/people/daan/download/papers/hml.pdf
19:18:48 <kniu> I am still trying to understand this paper.
19:18:51 <kniu> In figure 1
19:19:36 <kniu> there are overlapping syntactic forms for monotypes, unquantified types, types, and type schemes
19:19:42 <MaskRay> kmc: I use hPutStrLn and hGetLine
19:21:14 <kmc> hmm, I guess that should work
19:21:20 <kniu> what confuses me is that "forall a. sigma" is both a sigma and if it's supposed to be syntactic sugar, a flexible type.
19:21:38 <kmc> i don't think that's the same as "doesn't support octets greater than 0x7F"
19:21:45 <kmc> it supports them just fine if you do ByteString IO
19:21:47 <kniu> so down in figure 5 where he defines the "nf" operation,
19:21:56 <kmc> it's just failing to Unicode-decode them properly
19:22:22 <kniu> the first case says "nf(sigma) = sigma"
19:22:29 <kniu> but what if that sigma has a forall in it?
19:23:05 <kniu> do I do nothing, or apply one of the last four cases?
19:23:25 <kniu> like, am I supposed to interpret that as "all sigma types are already in normal form"?
19:27:05 <MaskRay> kmc: Why does each invoke of putChar output a single character individually?
19:27:32 <kmc> ?
19:27:36 <kmc> you mean, why is it not buffered?
19:28:39 <MaskRay> kmc: In C, if I call getchar() several times to output every byte of an UTF character, I'll see a whole character
19:28:48 <MaskRay> s/getchar/putchar/
19:30:07 <tgeeky> ha! edwardkmett finally took up the entire "What's new" hackage page with his version bumping
19:30:23 <MaskRay> main = putChar '\xe4' >> putChar '\xb8' >> putChar '\x80' >> putChar '\x0a'
19:30:30 <kmc> MaskRay, putChar puts a char, not a byte
19:30:35 <kmc> Char represents a character, not a byte
19:30:44 <kmc> if you want to do binary IO, use ByteString
19:31:00 <MaskRay> i see
19:31:00 <shachaf> What if you want to do binary IO with linked lists of bytes?
19:31:14 <kmc> shachaf, map (BS.pack . (:[]))
19:31:16 <kmc> obviously ;P
19:31:16 <shachaf> For that old-fashioned Haskell inefficiency taste.
19:31:21 <aavogt> @hoogle setbinarymode
19:31:21 <lambdabot> System.IO hSetBinaryMode :: Handle -> Bool -> IO ()
19:31:42 <MaskRay> kmc: I used to expect getChar has a similar feature as getchar() in C
19:31:42 <kmc> is "binary mode" a euphemism for Latin-1?
19:31:51 <MaskRay> s/has/to have/
19:31:52 <kmc> MaskRay, well, Haskell's getChar does what its name and type say
19:31:54 <kmc> and C's doesn't
19:32:27 <shachaf> kmc: Not CP437?
19:32:53 <shachaf> Sure C's does.
19:32:55 <aavogt> ghc's getChar used to use a different encoding by default
19:33:01 <shachaf> FAVO "char".
19:33:09 <kmc> "antiquated" ?
19:33:20 <shachaf> "appropriate", but in this case, sure.
19:33:45 <MaskRay> C's putchar() doesn't do any transformation
19:33:56 <aavogt> http://ghcmutterings.wordpress.com/2009/09/30/heads-up-what-you-need-to-know-about-unicode-io-in-ghc-6-12-1/
19:34:12 <shachaf> MaskRay: Right, it's a putbyte.
19:34:19 <kmc> a poorly named putbyte
19:34:25 <shachaf> kmc: To be fair, C's putchar does exactly what it says -- it puts a char.
19:34:36 <shachaf> Your issue should be with C's char type.
19:34:40 <kmc> yeah
19:34:50 <MaskRay> shachaf: Yes, it's name is a bit misleading.
19:34:54 <kmc> once upon a time the only people with computers spoke English or, at worst, German
19:35:37 <aavogt> kmc: the haskell report doesn't discuss how to set encoding
19:37:07 <aavogt> so I'm not sure you could say the ghc-6.10 behavior didn't comply with the standard
19:37:26 <kmc> i said it does?
19:37:48 <MaskRay> different treatments of unicode character in a variety of languages is annoying
19:38:18 <shachaf> ... unicode ... is annoying
19:38:25 <dmwit> Humans are annoying.
19:38:28 <aavogt> kmc: "putChar puts a char, not a byte"
19:38:34 <shachaf> English is the only language.
19:38:39 <kmc> yeah, we should pass a law saying non-Americans aren't allowed to have computers
19:38:44 <kmc> ;P
19:38:47 <shachaf> Sadly we still need Unicode support everywhere so kmc can use his fancy compose-key characters.
19:38:50 <aavogt> it puts bytes if you have the appropriate encoding
19:39:14 <kmc> it doesn't put bytes; you can tell as much from its type
19:39:37 <kmc> Char is no more a byte type than Word32 is
19:40:52 <kmc> putChar happens to put the byte whose integer value equals the code point of the input Char, if that value is under 256 and the handle is set to Latin-1 encoding
19:41:14 <kmc> i think you're best off viewing that fact as accidental
19:42:02 <shachaf> "whose integer value" as opposed to what kind of value? :-)
19:42:16 <danharaj> floating point value
19:42:24 <kmc> hamming weight
20:07:51 <kniu> so uh
20:08:01 <kniu> what are the problems with naive substitution again?
20:08:48 <kniu> I remember it has something to do with hygiene, but I don't quite remember the subtleties of implementing an actual explicit substitution function.
20:12:36 <monochrom> variable capture
20:13:18 <kniu> okay screw it
20:13:31 <kniu> explicit mutable references seem to be simpler
20:14:59 <monochrom> not sure what you're doing, but I use de Bruijn to circumvent variable capture and other naïve substitution problems
20:15:43 <kniu> monochrom, I'm trying to implement type checking and type inference.
20:16:38 <monochrom> then mutable references work until you have to instantiate a polymorphic type
20:16:54 <kniu> wait, what do you mean?
20:17:21 <kniu> I'm trying to follow this paper: http://research.microsoft.com/en-us/um/people/daan/download/papers/hml.pdf
20:17:32 <monochrom> I write "let f x = x in ...". you type-check "f x = x", right? then what do you do?
20:17:49 <kniu> where the author says that his reference implementation uses updatable references.
20:18:29 <monochrom> sure, it's just more tricky when you instantiate a polymorphic type
20:18:55 <kniu> The references are for setting type variables
20:19:31 <monochrom> you type-check "f x = x", you get "f :: v -> v". following "let-polymorphism", you may like to call it "f :: forall v. v -> v"
20:19:47 <kniu> okay
20:20:18 <monochrom> next, the rest of the code is "... in (f True, f 'x')". now that will force you to instantiate f's "forall v. v -> v" in two separate ways
20:21:18 <monochrom> if you represent "v -> v" by an immutable data structure, all you need to do is two different substitutions
20:22:35 <monochrom> if you represent "v -> v" by a mutable data structure where "v" is mutable, sure, for each substitution you just "write to v". but you need two substitutions not one, and the two must not interfere with each other
20:23:01 <monochrom> sure, you have ways to do it, but it's more effort and at the same time more ways to make mistakes
20:24:24 <monochrom> the least of which is "you have to clone v->v" and the first problem you beg is "do you remember to clone it"
20:30:32 <edwardk> heh, i now have a pretty printing profunctor. i just wish i could understand the behavior of the arrow it induces
20:32:09 <hpaste> xenocryst pasted “crash” at http://hpaste.org/49804
20:32:43 <xenocryst> I installed ghc from the official OpenBSD packages and am getting that message
20:32:55 <xenocryst> is there anything I can do?
20:33:35 <xenocryst> the same exact error happens if I try to run ghc (with no arguments)
20:33:55 <kniu> very well
20:34:00 <kniu> I will use explicit substitutions
20:36:32 <Axman6> xenocryst: try asking #ghc. seems like a very strange error though
20:36:42 <xenocryst> alright, thanks!
20:40:28 <applicative> xenocryst: the lambdacats know about it   http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#960526358_n93fA-A-LB
20:40:52 <xenocryst> ha!
20:43:53 <sp3ctum> hahaha
20:43:55 <sp3ctum> awesome cats
20:45:25 <applicative> foldr (++) [] fridgeContents about killed me when I first saw it
20:46:08 <sp3ctum> i wonder why a right fold
20:46:37 <Cale> http://www.smbc-comics.com/index.php?db=comics&id=2325#comic
20:47:15 <Cale> > isInfixOf "recursion" "recursion
20:47:17 <lambdabot>   <no location info>:
20:47:17 <lambdabot>      lexical error in string/character literal at end o...
20:47:20 <Cale> > isInfixOf "recursion" "recursion"
20:47:21 <lambdabot>   True
20:47:38 <kniu> @hoogle undefined
20:47:38 <lambdabot> Prelude undefined :: a
20:47:38 <lambdabot> Control.Exception UndefinedElement :: String -> ArrayException
20:47:38 <lambdabot> Control.OldException UndefinedElement :: String -> ArrayException
20:47:39 <edwardk> =)
20:48:17 <mustelo> I have some data types that are of the form data MyStuff = A | B | C | D | ..., and each of A, B, etc have an associated integer. currently I translate between the constructors and the Ints using a very long function that just does pattern matching is there a more concise way to express this?
20:49:12 <drbean> :t isInfixOf
20:49:13 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
20:49:20 <int80_h> I have a [String] that looks like this ["","foo","","","","bar","baz"]. I'm trying to drop all the nulls. I was trying to use dropWhile with map and null, but I can't get it to work. Am I going about it the right way? How can I make this work?
20:49:55 <Cale> filter (not . null)
20:49:59 <hpaste> mustelo pasted “ugly pattern matching” at http://hpaste.org/49805
20:50:12 <kniu> @hoogle (==)
20:50:13 <lambdabot> Prelude (==) :: Eq a => a -> a -> Bool
20:50:13 <lambdabot> Data.Eq (==) :: Eq a => a -> a -> Bool
20:50:13 <lambdabot> Test.QuickCheck (==>) :: Testable a => Bool -> a -> Property
20:50:16 <int80_h> thanks Cale :)
20:50:53 <gajbooks> SPAM #spam PLEAESESESES!!!!!!!!!!!!!!!
20:51:01 <Cale> wat
20:51:09 <int80_h> I don't even
20:51:39 <mustelo> well, he said pleaeseseses...
20:51:57 <int80_h> that *is* the super secret password
20:52:00 <kniu> @hoogle error
20:52:00 <lambdabot> Prelude error :: [Char] -> a
20:52:01 <lambdabot> module Control.Monad.Error
20:52:01 <lambdabot> module Foreign.C.Error
20:52:05 <kniu> hm.
20:52:25 <kniu> where are undefined and error defined besides the prelude?
20:53:16 <Cale> nowhere that I can think of
20:53:25 <Cale> You could go into ghci and :info them
20:53:33 <Cale> with the appropriate modules loaded
20:53:40 <kmc> GHCi says GHC.Err
20:53:51 <kmc> of course that's implementation-dependent
20:53:55 <kmc> why?
20:54:05 <mustelo> if I have a datatype with n constructors and I pattern match on it, does the function run in O(1)? O(n)?
20:54:22 <Axman6> huh, apparently i can't catch the exception thrown by error?
20:54:27 <kmc> Axman6, you can
20:55:13 <Axman6> ah, apparently i can. i just wasn't doing it right
20:56:13 <siracusa> mustelo: If you can derive an Eq instance, you can do it like so:
20:56:14 <siracusa> > let lookUp x = find (\x' -> fst x' == x) [("one", 1), ("two", 2), ("three", 3)] in lookUp "two"
20:56:16 <lambdabot>   Just ("two",2)
20:56:17 <mauke> @hoogle (a -> [b] -> [b]) -> [a] -> [b]
20:56:17 <lambdabot> No results found
20:56:40 <mauke> @hoogle (a -> [b] -> b) -> [a] -> [b]
20:56:40 <lambdabot> No results found
20:57:01 <mustelo> siracusa, sure, I was hoping for O(1), or as good as I can get
20:57:09 <Cale> mustelo: You could use a Data.Map
20:57:24 <Cale> (and probably should)
20:57:32 <mustelo> Cale, right. do you know if that's faster or slower than pattern matching?
20:57:36 <Cale> I don't think I'd usually construct such a large enumeration type
20:57:49 <hatds> pattern match would be O(1) I believe
20:57:50 <mustelo> they're mnemonics for an assembly language
20:57:58 <Cale> Pattern matching is probably eventually slower, but of course it's implementation-dependent
20:58:10 <Cale> I don't think GHC does computed jumps, but I don't know.
20:58:37 <hatds> Isn't the constructor just represented by some tag byte?
20:58:47 <Cale> yes
20:58:54 <hatds> oh wait I see
20:58:56 <hatds> :)
20:58:56 <Axman6> it's a tagged pointer i believe
20:59:04 <Cale> Equations are tried in turn until one of them matches
20:59:18 <hatds> yea I don't know how fast it would be
20:59:20 <Axman6> but only up to a certain number of constructors. not sure what happens after 4/8
20:59:22 <applicative> mustelo, you skip 21, 22 and 25 ... , this messes with my plan of deriving Enum and Bounded and using [minBound .. maxBound] ....
20:59:25 <Cale> Pointer tagging only works on small enumerations
20:59:32 <Cale> and only if the thing is already evaluated
20:59:42 <Axman6> yeah
20:59:45 <Cale> otherwise, you need to do the indirection to see which constructor it is
21:00:13 <mustelo> applicative, yeah, there are some weird nuances to the opcodes. I wouldn't be opposed to dummy values for those that are missing...
21:03:14 <kmc> GHC used to have a "vectored return" optimization
21:03:27 <kmc> which would effectively give O(1) matching on enums, though that's not why they did it
21:03:31 <kmc> i believe this optimization was removed
21:04:50 <c_wraith> I seem to recall the paper that talked about its removal said that it could be re-added, but they didn't want to bother with it at the time.
21:05:03 <mustelo> applicative, if I derive an Enum instance is it guaranteed to use the integers [0..n]?
21:05:23 <c_wraith> Derived instances should, yes.
21:05:36 <mustelo> cool, thanks c_wraith
21:16:08 <applicative> i see byorgey added a monad tutorial lolcat http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#1288212148_5KLHJ3V-A-LB
21:16:26 <c_wraith> haha
21:16:43 <danharaj> burrito del gato
21:16:59 <kmc> haha
21:17:19 <kmc> "burrito del gato" sounds like somewhere I'd love to eat at 1 AM and then regret the next day
21:18:01 <kmc> taqueria dos cucarachas
21:18:06 <MatrixFrog> lambdacats <3
21:18:07 <danharaj> gross
21:19:26 <MatrixFrog> http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#960831913_rhDdG
21:19:29 <MatrixFrog> oleg?
21:20:06 <danharaj> HAHAHA
21:20:12 <danharaj> I love the Simon one
21:20:18 <danharaj> with the broken cup
21:21:55 <MatrixFrog> there were some haskell ones too
21:22:00 <MatrixFrog> as in Haskell Curry
21:22:08 <MatrixFrog> i went looking for them and found this instead :( http://troll.me/haskell-y-u-no-make-sense/
21:40:31 * applicative learns that hydrangea blossoms are made blue by "a pigment called delphinidin 3-monoglucoside and a copigment called 3-caffeoylquinic acid."
21:41:28 <marv> So I read through http://www.catonmat.net/blog/simple-haskell-tcp-server/ and I think I understand it.
21:41:39 <kmc> applicative, they're pH indicators
21:41:57 <kmc> so are red cabbages -- it's the same pigment
21:42:06 <applicative> copigments?
21:43:14 <marv> what I don't understand at all, is how you deal with global state in a haskell problem, since it seems to intentionally not have any…but I think i've come up with a more concrete question
21:43:57 <marv> How would you go about extending that tcp server example to add a command that listed all active connections?
21:44:53 <shachaf> marv: I suppose you could add a connection to some list whenever it starts and remove it from that list when it ends?
21:45:49 <shachaf> Haskell certainly has various types of state if you want them.
21:45:55 <marv> shachaf: but how would the other connections get access to that list?
21:46:37 <marv> wouldn't each connection be running it's own loop and only see connections that existed when it started?
21:47:02 <shachaf> Not if you used a variable.
21:47:24 <mustelo> marv, your question is a bit more complicated in this case because the server is multithreaded. are you asking about how to share stuff across threads, or just about how to do state in general?
21:48:21 <shachaf> marv: Actual global state tends to be frowned upon even in languages that use state for a lot of things.
21:50:11 <marv> mustelo: I think I'm asking the latter.  Unless there's no way to mutiplex io without threads in haskell, then i might need the former to do anything useful
21:50:45 <mustelo> marv, the usual to multipex IO in haskell is threads
21:51:10 <kmc> GHC Haskell embraces threading
21:51:16 <kmc> it's not "avoid threads at all costs" like some languages
21:51:42 <kmc> threads are very cheap, and blocking IO in threads is transparently implemented by epoll / kqueue / etc
21:52:11 <kmc> so you get the benefits of the async callback model that the kids these days are so fond of
21:52:15 <danharaj> the GHC RTS is a thread whore.
21:52:15 <kmc> without turning your code inside out
21:52:21 <mustelo> marv, in general though you would use the state monad for stateful stuff. or reader/writer if you didn't need full power
21:52:35 <kmc> not really mustelo
21:52:38 <Axman6> danharaj: it's got so many thread bitches
21:52:41 <marv> ok, so it's the state monad i should read up on?
21:53:12 <kmc> the State monad is just syntactic sugar
21:53:15 <mustelo> marv, like kmc said the first step would be to try to phrase the computation in a pure way
21:53:21 <shachaf> marv: "the state monad" is just an abstraction for passing around state manually, as in Int -> (a,Int).
21:53:24 <kmc> for functions of type (s -> (a, s))
21:53:41 <mustelo> the sugar *is* useful sometimes the, imho
21:53:47 <kmc> for "real" state look at IORef, STRef, STM, etc.
21:54:05 <mustelo> s/the/though/
21:54:05 <kmc> the last chapter in RWH is about STM; i recommend reading that
21:54:06 <danharaj> ST is a nifty monad. It lets you do mutation without sacrificing purity.
21:54:26 <shachaf> kmc: But turning your code inside out and writing everything in explicit CPS airs out the unscalable insides of your code!
21:55:57 <marv> but if i'm multi-threaded, i can't just pass my state as an argument to the next function in the chain….how can thread b see the state of thread a? i don't understand how that can happen in pure functional way
21:56:13 <kmc> marv, the same way putStr happens in a pure functional way
21:56:55 <kmc> a value of type (IO t) is a description of how to produce some IO and produce a result of type t
21:57:04 <kmc> here IO includes reading and writing to shared variables, message queues, etc.
21:57:25 <Axman6> nexx: if you need shared state, you need something like an IORef, or imo a better choice is an MVar
21:57:30 <Axman6> uh, marv, not nexx
21:57:42 <kmc> marv, read http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html and http://book.realworldhaskell.org/read/software-transactional-memory.html
21:57:55 * shachaf should read RWH one of these days.
21:58:02 <kmc> marv, basically Haskell programs are pure functional programs that compute imperative programs
21:58:36 <kmc> that's true whether you're doing simple (putStrLn "Hello world") or massively concurrent IO
22:01:13 <kmc> shachaf, I enjoyed the topics chapters on STM, FFI, etc
22:03:24 <edwardk> hrmm is hackagebot still muted?
22:03:41 <marv> ok, well thanks. i'll read those links and ask more questions later
22:09:50 --- mode: ChanServ set -q *!*@li229-222.members.linode.com
22:10:49 * hackagebot ad 1.2.0.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.2.0.1 (EdwardKmett)
22:11:33 <shachaf> edwardk continues to dominate the What's New page.
22:11:44 <shachaf> Oh, no, JohanTibell is in there now.
22:12:03 <edwardk> yeah. i had to take the time to write a new library after all ;)
22:12:11 <edwardk> the wl-pprint-extras is new
22:12:51 <edwardk> wl-pprint-terminfo is coming momentarily
22:12:59 * sm checks things
22:13:38 <edwardk> which should motivate the extra 'effect' nodes i snuck into the wadler-leijen pretty printer
22:14:02 <dobblego> which package does lambdabot's @undo come from?
22:14:09 <edwardk> and the new ad version there includes acowley's performance improvements
22:14:30 <edwardk> and some strict primal improvements that i added on top
22:14:46 <Jafet> @list
22:14:47 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:15:06 <Jafet> "undo", apparently.
22:15:10 <Jafet> @help redo
22:15:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:15:37 <Axman6> @redo return
22:15:38 <lambdabot> Maybe you meant: do read todo undo
22:15:49 <Axman6> @todo test
22:15:49 <lambdabot> Plugin `todo' failed with: @todo has no args, try @todo-add or @list todo
22:15:52 <dobblego> I cannot see an undo package on hackage
22:15:56 <Axman6> @todo
22:15:57 <lambdabot> 0. SamB: A way to get multiple results from a google search
22:15:57 <lambdabot> 1. dons: improve formatting of @dict
22:15:57 <lambdabot> 2. dons: write Haskell Manifesto
22:15:57 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
22:15:57 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
22:15:59 <lambdabot> [31 @more lines]
22:16:00 <Axman6> :|
22:16:38 <Jafet> Don't step on the priviledge
22:16:46 <shachaf> @help do
22:16:46 <lambdabot> do <expr>
22:16:48 <lambdabot> Translate Monad operators to do notation.
22:16:51 <shachaf> preflex: seen SamB
22:16:51 <preflex>  SamB was last seen on #css 5 days, 10 hours, 47 minutes and 7 seconds ago, saying: somasin: what is the advantage to using text-align:right?
22:17:03 <shachaf> That's not the same SamB, is it. :-(
22:17:04 <shachaf> preflex: seen SamB_XP
22:17:04 <preflex>  SamB_XP was last seen on #ghc 1 year, 62 days, 10 hours, 27 minutes and 39 seconds ago, saying: er. s/runs/run/
22:17:28 <Jafet> dobblego: it'd be in the lambdabot package, then
22:21:49 <sm> edwardk: I see, copumpkin had muted it the last 6 hours
22:22:08 <edwardk> yeah i started spamming hackage again
22:22:17 <edwardk> and he looked over and said 'hell no' before muting it ;)
22:22:24 <copumpkin> sm: how'd you know it was me!?
22:22:34 * copumpkin puts on sunglasses and looks shady
22:22:38 <sm> hackagebot's irc debug log
22:22:44 <copumpkin> lol
22:22:56 <copumpkin> it notifies you when someone quiets you?
22:23:01 <sm> yup
22:23:05 <copumpkin> :O
22:23:12 --- mode: ChanServ set +q *!*@unaffiliated/pumpkingod
22:23:21 <sm> which is good, otherwise we'd be wondering what random thing was screwed up
22:23:32 --- mode: ChanServ set -q *!*@unaffiliated/pumpkingod
22:24:54 <arcatan> what's +q?
22:25:11 <arcatan> oh, mute
22:25:22 <copumpkin> yeah, /mode +stfu copumpkin
22:34:08 <monochrom> @bots
22:34:08 <lambdabot> :)
23:03:42 <ivanm> I'm trying to use binary to encode a list of values whilst also counting how many values are in that list
23:04:13 <ivanm> but for some reason adding the counting bit (even with seq) makes it use up more and more RAM
23:04:17 <ivanm> any ideas why?
23:04:49 <Axman6> well the encoding of lists is basically: put xs = put (length xs) >> mapM_ put xs
23:05:10 <ajnsit> Is it possible to completely remove Leksah configuration and reset back to defaults?
23:05:23 <Axman6> ivanm: care to share the code?
23:05:53 <ivanm> Axman6: nah, I'm using foldM
23:06:04 <ivanm> ajnsit: I would guess something like rm -rf ~/.leksah
23:06:30 <ajnsit> ivanm, and that would not remove anything critical?
23:06:44 <kmc> mv ~/.leksah ~/.leksah.borked  # ;)
23:06:48 <ivanm> soemthign equivalent to: foldM (\ c a -> put a >> (return $! succ c)) 0 as
23:07:25 <ivanm> kmc: mv ~/.leksah{,.borked}
23:07:27 <ivanm> ;-)
23:09:12 <ajnsit> kmc, ivanm, okay I moved .leksah and it's building metadata now.. Hopefully it works
23:10:31 <ivanm> OK, even getting rid of that succ from there makes it use up memory
23:20:05 * ivanm guesses that his problem is because the bytestring isn't buffering to file as chunks are created because the entire thing has to finish to return the count for the length
23:21:37 <Schalken> Is it possible to implement the ST monad in pure Haskell, or is it something that requires compiler support?
23:22:24 <c_wraith> Implementing the interface is possible with unsafeCoerce, though not with the true in-place mutation
23:22:38 <c_wraith> the true in-place mutation requires deep compiler support.
23:22:43 <c_wraith> (at runtime, IO and ST are identical)
23:22:46 <ByronJohnson> Schalken: Conceptually, the ST monad can be; internally, though, you know it's more efficient.
23:22:57 * hackagebot gloss 1.3.3.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.3.3.1 (BenLippmeier)
23:23:51 <ajnsit> okay I somehow managed to hide the output window in Leksah and can't get it back
23:24:10 <ajnsit> even deleting and regenerating .leksah doesn't help
23:24:47 <Schalken> c_wraith: ByronJohnson: Thanks.
23:24:50 <ByronJohnson> Schalken: The concept isn't one that violates referntial transparency.  It can be optimized, though, by making mutations take place in the same memory, and the internal implementation takes advantage of that.
23:27:05 <ajnsit> never mind got it now
23:29:25 <kmc> Schalken, if you have a GHC-like implementation of IO, then it suffices to make ST a newtype wrapper for IO, and runST an alias for unsafePerformIO with a funny type
23:29:54 <kmc> ...assuming you don't export the newtype constructor, that is
23:30:34 <jnhnum1> hey, so I'm trying to learn how to use the ListT monad by example.  if I'm not mistaken, it should make it super easy to do something like the following: read line1 from stdin, read line2 from stdin, and then print all possible pairs of characters with one character from line1 and one character from line2
23:30:39 <shachaf> runST's type is hilarious.
23:30:39 <jnhnum1> I know this is a really contrived example
23:30:49 <jnhnum1> but I still don't know how to do it :/
23:30:51 <Schalken> I am looking at the ST monad transformer and it says not to use it in the list monad, which I want to, as it may violate referential transparency. But I can't see how else to do what I want to achieve.
23:30:59 <kmc> STT o_O
23:31:16 <Schalken> Maybe I should describe what I'm trying to achieve...
23:32:32 <Schalken> I am trying to implement a simple type checker for PHP by stepping through the program and keep the possible types of variables in the current scope in a list monad. So for example if (…) { $a = 7 } will split the world into two, one where $a has type Int, and one where $a has not been set. It proceeds and if any of the possible branches causes a type error, I know that the program _may_ produce a type error when run.
23:32:58 <kmc> STT is a bad bad bad idea
23:33:22 <Schalken> kmc: Right.
23:33:30 <shachaf> > 'S' : repeat 'T'
23:33:31 <lambdabot>   "STTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT...
23:33:42 <kmc> how about StateT (Map VariableName Type) [] a
23:33:47 <kmc> @unmtl StateT (Map VariableName Type) [] a
23:33:48 <lambdabot> Map VariableName Type -> [(a, Map VariableName Type)]
23:35:15 <Schalken> kmc: Right. That's fine. The problem is PHP has a concept of "references", whereby many variables can point to the same contents in memory, like hard links in a filesystem.
23:35:39 <kmc> okay
23:36:08 <kmc> by analogy with hardlinks then, you could use a pair (Map Name Inode, Map Inode Type)
23:37:37 <kmc> ST is doing real in-place updates; one branch of your search will interfere with the others
23:38:20 <kmc> even if you introduced some scheme for rolling back those changes, it would be a lot nicer to use a data structure like Map that gracefully (and efficiently) supports pure-functional update
23:38:37 <Schalken> kmc: That works. The problems is every time a variable is bound to a different Inode, the old Inode may no longer be being used, and unused ones will probably build up. I would have to garbage collect them myself.
23:38:57 <kmc> yep
23:39:55 <kmc> that's easy though; you just drop any key in the second map which doesn't appear as a value in the first map
23:40:11 <kmc> it's not like a real GC where you can follow pointers arbitrarily deep
23:40:13 <Schalken> kmc: Which is what I was trying to avoid. I don't want to manually allocate and garbage collect the k-v pairs in the Map Inode Type. I thought using STRefs in place of Inodes would make that easier.
23:40:40 <kmc> but it doesn't :/
23:41:02 <ivanm> Axman6: I've ended up looping over the list in IO rather than in Put; that way there's no RAM problem
23:41:04 <Schalken> kmc: Heh, alright then.
23:41:17 <kmc> i do feel like there's a pattern one could abstract here
23:41:46 <Schalken> kmc: Wouldn't that be O(n), though? Every time a variable is bound to a different Inode I have to hunt for the previous Inode in the Map Name Inode to see if it's still being used and, if it is, unlink it in the Map Inode Type?
23:42:06 <Schalken> and, if it isn't, unlink it in the Map Inode Type*
23:42:07 <kmc> you can just traverse the first map occasionally
23:42:29 <kmc> it sounds like the naive code will be easy to write
23:42:34 <kmc> then you can see if it performs acceptably
23:43:15 <shachaf> You can use a reference count like filesystems usually do. :-)
23:43:15 <kmc> i wonder if there's already a hackage package that abstracts this idea of a map + key generator
23:43:41 <Schalken> kmc: That leads to a compromise, though. If I only GC occasionally, for all I know the Map Inode Type may blow up and cause OOM before I get a chance to clean it up. I wouldn't know how often to GC.
23:44:04 <kmc> Schalken, or for all you know, it never gets big enough on one path to matter
23:44:16 <kmc> i'm sure we can spend all day coming up with reasons this might not work
23:44:26 <kmc> i don't claim it works; i claim it's easy enough to be worth trying
23:44:26 <Schalken> kmc: Hmmm.
23:45:19 <shachaf> Filesystems shouldn't use reference counts, of course. They should support cycles.
23:45:30 <shachaf> .. is overrated.
23:45:44 <Schalken> kmc: Hey! I can use reference counting!
23:45:54 <Schalken> shachaf: Good idea! :P
23:46:49 <Schalken> kmc: That would work, wouldn't it? Because there's no possibility of cycles, reference counting would be perfect and O(1).
23:47:26 <kmc> you still have the map lookups
23:47:27 <Schalken> So Map Inode Type becomes Map Inode (Type, Int {- refcount -})
23:47:33 <kmc> so it's more like "O(log n)"
23:47:37 <shachaf> kmc: But 1 = log n.
23:47:57 <kmc> but asymptotic complexity is overrated
23:47:59 <kmc> shachaf, right
23:48:04 <Schalken> Right. Sorry. There's still the lookups. But log n is a lot better than n.
23:48:26 <kmc> Schalken, sometimes log n is a lot worse than n
23:48:31 <shachaf> Really your n is n log n anyway. :-)
23:48:48 <Schalken> I don't follow.
23:49:06 <kmc> real machines don't follow the rules of asymptotic complexity analysis
23:49:22 <shachaf> @whatis realmachine
23:49:22 <lambdabot> I know nothing about realmachine.
23:49:35 <Schalken> Do you mean log n may be worse than n if, for example, the n is actually 1000*n?
23:49:45 <kmc> constant factors matter a lot; caches introduce huge discontinuities; etc
23:49:58 <shachaf> Computers would be simpler if there were no caches.
23:50:16 * shachaf proposes removing them. Simplicity over performance.
23:50:20 <kmc> shachaf, get you an AVR
23:51:03 <Schalken> kmc: But in this situation wouldn't you prefer reference counting over occasional GC?
23:51:09 <jnhnum1> can somebody give a good simple example of when to use the ListT monad?
23:51:12 <kmc> Schalken, probably
23:51:51 <kmc> shachaf, it's beautiful.  fixed clock, in-order, no speculation, no caches, all SRAM
23:52:38 <shachaf> Sounds lovely.
23:52:48 <kmc> $2
23:53:27 <kmc> "registers" are just a compact addressing mode for the first 32 bytes of RAM
23:53:46 <Schalken> I have heard about caches killing performance rather than helping it in parallel computing situations.
23:54:34 <kmc> because of the overhead of maintaining cache coherency?
23:54:43 <kmc> ("coherence"?)
23:54:56 <shachaf> As in <http://en.wikipedia.org/wiki/False_sharing>?
23:55:02 <Schalken> Right.
23:55:15 * shachaf has run into that.
23:55:19 <kmc> ouch
23:55:23 <jnhnum1> that's not caches killing performance though
23:55:28 <jnhnum1> that's caches failing to help performance
23:56:15 <kmc> jnhnum1, isn't it conceivable that reading from main memory *and* telling the other guy to drop his cache line is worse than reading from main memory?
23:56:27 <Schalken> jnhnum1: It was mentioned in this video. http://channel9.msdn.com/Shows/Going+Deep/E2E-Herb-Sutter-and-Erik-Meijer-Perspectives-on-C
23:56:35 <shachaf> It was fun to improve performance by ~30% by padding values to the size of a cache line.
23:56:38 * kmc doesn't really understand cache coherence protocols
23:56:59 <shachaf> (Which wasn't an optimal solution, but still.)
23:57:12 <kmc> incidentally, GHC-produced code will never have this problem, correct?
23:57:34 <shachaf> Why not?
23:57:58 <kmc> ah, not correct
23:58:49 <kmc> iirc allocations are done on a per-OS-thread basis, and therefore two concurrent threads will get addresses far apart
23:58:55 <jnhnum1> kmc: I think that with processors today, the cache invalidation is an atomic operation, but if there were no cache at all, I guess main memory access might be able to be a little faster
23:59:13 <kmc> but two Haskell threads could run on the same OS thread at one point, do allocation there, and then run concurrently on different OS threads
23:59:40 <c_wraith> kmc: that's possible, but the ghc scheduler prefers to avoid doing that
23:59:59 <c_wraith> this is discussed a bit in the simons' paper on per-capability GC
