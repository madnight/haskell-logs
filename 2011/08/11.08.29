00:01:43 <solrize> i haven't felt much desire for one.  reading on my laptop works fine for me
00:03:18 <hvr> alas, my eyes get strained looking concentrated at traditional tfts
00:03:35 <hvr> that's why I prefer deadtree for longer reads
00:04:36 <hvr> (and my laptop isn't a lightweight either and gets hot over time)
00:08:26 <earthy> plus, the aspectratio of a laptop screen is All Wrong
00:09:23 * gienah likes paper books, however software foundations is meant to be used in the coq proof assistant
00:24:48 * hackagebot lazysmallcheck 0.6 - A library for demand-driven testing of Haskell programs  http://hackage.haskell.org/package/lazysmallcheck-0.6 (MatthewNaylor)
00:57:02 <iFire> there's no haskell abnf parser D:
01:00:01 <iFire> :o
01:00:38 <iFire> http://hackage.haskell.org/package/hsemail-1.3
01:00:39 <iFire> YES!
01:09:01 <mistertim> quick q guys - can i look up the source for functions that aren't in the prelude with lambdabot @src - and if so, how? observe:
01:09:05 <mistertim> @src listen
01:09:05 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:09:12 <mistertim> @src Control.Monad.Writer.listen
01:09:13 <lambdabot> Source not found. I feel much better now.
01:09:48 <mistertim> sorry for slightly dumb question - @help src didn't enlighten me
01:09:52 * hackagebot fclabels 1.0.3 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.0.3 (SebastiaanVisser)
01:09:54 * hackagebot wai-app-file-cgi 0.3.3 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.3.3 (KazuYamamoto)
01:10:28 <c_wraith> mistertim: @src doesn't actually look up source...  It just replies with the content from a hand-managed database, that is very incomplete
01:10:38 <c_wraith> you can see that with results from some things, like..
01:10:41 <c_wraith> @src (.)
01:10:42 <lambdabot> (f . g) x = f (g x)
01:10:42 <lambdabot> NB: In lambdabot,  (.) = fmap
01:10:45 <mistertim> c_wraith - aha, that'd examplain it
01:10:58 <mistertim> no problem, thank you!
01:11:58 <c_wraith> mistertim: though for the specific thing you were looking at there...  I'm pretty sure listen is part of the typeclass.  in which case, it doesn't have a single implementation anyway
01:12:13 <mistertim> aha yes, you're right
01:13:42 <Saizan> OTOH you can hoogle or hayoo them and then click on the source link
01:14:06 <Saizan> which is in the haddock documentation
01:14:52 * hackagebot mighttpd2 2.3.3 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.3.3 (KazuYamamoto)
01:19:52 <brisingr> i can't believe it i'm free the talk is over!!111
01:20:05 * brisingr tastes freedom then goes back to haskell
01:22:47 <mistertim> Saizan - aha, thanks! hoogle pointed me towards a slightly more descriptive set of documentation than the one i found previoiusly, which is exactly what I needed. Thanks!
01:28:39 <Saizan> np :)
01:40:14 <milo> Hi everybody. I'm having some problems with MonadTrans and what I think might be some kind of lifting. I'm trying to 'lift' catch to except a monad transformer stack. The type I'm trying to feed it is  parseConfig :: FilePath -> S.StateT Context IO () . And I'm in  readConfig :: (forall a. IO a -> IO a) -> StateT Context IO () . I came up with something like  (liftM (`catch` stdErrorH)) (parseConfig cfgPath)  but that doesn't work. I 
01:44:08 <Saizan> MonadTrans is not enough for stuff that takes callbacks like catch
01:45:11 <Saizan> http://hackage.haskell.org/packages/archive/monad-control/0.2.0.3/doc/html/Control-Exception-Control.html <- you could use this though
01:46:50 <milo> Ah, that looks nice. I'll give it a try. Thanks
01:49:14 <kizzx2> one very common (probably only one you can find on the net) example of a custom arrow is     newtype ArrowCircuit b c = ArrowCircuit { unCircuit :: b -> (ArrowCircuit b c, c) }
01:49:34 <kizzx2> what's the intuitiion behind the the "ArrowCircuit b c" in the return value of the function?
01:51:34 <Saizan> that it's ready to consume more b's to give you more c's ?
01:52:30 <Saizan> given the "Circuit" in the name it could possibly represent what will happen at the next clock cycle
01:52:33 <ziman> looks like a state machine to me.
01:52:40 <Saizan> yep, it is
01:53:14 <kizzx2> why not just call the original circuit? what's the 1000 feet intuition of the rasion detre of it returning another function?
01:53:53 <kizzx2> i'm hypothesizing because the function can put in new states in the returned circuit, through closures
01:55:14 <Saizan> yeah, this way the "internal state" can change
01:56:02 <Saizan> you could write an ArowCircuit Int Int that gives as outputs the running sums, for example
01:56:35 <Axman6> @hoogle unsafePerformIO
01:56:35 <lambdabot> Foreign unsafePerformIO :: IO a -> a
01:56:35 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
02:01:24 <rostayob> Is there a standalone type checker for haskell, something like haskell-src but to type check
02:02:16 <Saizan> no
02:02:39 <kizzx2> rostayob: maybe you can say ghc -fno-code?
02:02:54 <Axman6> sounds like a useful thing to have though
02:02:59 <Axman6> could be very helpfun in an IDE
02:03:06 <Saizan> there's some "typing haskell in haskell" code, but that won't support many extensions
02:03:19 <rostayob> Saizan: I'm only interested in haskell98 right now
02:03:47 <rostayob> kizzx2: yeah I could but it'd be nicer to have something like that
02:04:42 <rostayob> I could extract ghc type checker I guess
02:04:57 <Saizan> you can use it through the ghc-api
02:05:29 <Saizan> http://web.cecs.pdx.edu/~mpj/thih/ <- this is what i was referring to, not sure how reliable it is
02:06:33 <rostayob> I want to see how far I can go in writing a hs compiler targeting js, maybe compiling GHC core to js is better if I'm relying on ghc anyway
02:08:00 <Saizan> you'd get the benefit of a lot of optimizations too
02:09:20 <Saizan> https://github.com/sviperll/ghcjs <- seen this?
02:10:16 <rostayob> Saizan: yeah I think I have
02:30:11 <peekaboo> i have a big challenge in front of me. i am supposed to teach kids programming in at most 9 hours (6x2x45min). they are 14 years old and without any prior programming experience
02:30:57 <peekaboo> do you think it would be possible to teach some kind of basic haskell in that short time?
02:31:17 <peekaboo> or do i have to teach them an impreative language (just basics)
02:31:38 <Saizan> try scheme
02:31:46 <brisingr> it would be easier to teach basic haskell, because it has some sort of resemblence with maths
02:34:49 <peekaboo> while i like haskell myself, i just wonder if it is possible. haskell is more complex, hence fewer lines. with most imperative languages you have a few important keywords and from there you start to grow in lines
02:35:25 <peekaboo> a few commands might be easier to teach those kids than the whole broad base of haskell
02:36:02 <peekaboo> what subset would you teach them?
02:36:45 <peekaboo> with any language it would always be a subset... but the more complex langauge, the smaller percent of the whole language the subset becomes
02:39:50 <rostayob> peekaboo: just simple, non-monadic functions, no type classes, no defining of data types
02:40:43 <rostayob> peekaboo: everything in ghci (or hugs), no compiling at all
03:00:25 <Accidus> I want to create a free functor with a single operation of arity Char. So I've created a functor: type Arity a = Char -> a, and now I want to have the type Free Arity. What is the right syntax to do so?
03:00:59 <Saizan> maybe you should consider getting some kind of mini-project completed by the end of the course, like a smallish game with a textual ui
03:01:45 <Saizan> Accidus: define type Arity = (->) Char
03:02:05 <Saizan> then you'll be able to use it without the argument
03:03:19 <Accidus> Cool, thanks. So there is no automatic currying for types?
03:03:40 <Cale> It's important to be aware that type synonyms defined by 'type' are not "real things", but just syntax sugar.
03:03:57 <Accidus> I see.
03:04:04 <Accidus> And there are not anonymous types
03:04:11 <Cale> yeah
03:04:17 <Accidus> * no
03:04:24 <Cale> newtype is different in regard to how it'll behave with currying
03:04:24 <Accidus> Cool, that explains a bit
03:04:41 <Accidus> Aye, well, newtype is different
03:05:48 <Cale> You can have   newtype Arity a = Arity (Char -> a) deriving (Functor, Monad)  (with generalised newtype deriving), and then use Free Arity
03:06:24 <Cale> But yeah, that'll require you to use the data constructor for Arity in your code.
03:08:48 <Cale> actually, hmm, was there an extension to weaken this restriction for type synonyms?
03:10:00 <Cale> {-# LANGUAGE LiberalTypeSynonyms #-}  might make it work
03:11:57 <Cale> I don't know if it automatically eta-contracts type synonyms for you.
03:13:26 <Cale> (apparently not)
03:16:36 <GlenK> hi.  so even though haskell is lazy, I guess I can't expect the following to not run forever?  minimum [x | x <- [1..]]
03:16:49 <GlenK> I suppose there's no way for it to really know the first number is the smallest?
03:17:06 <Axman6> indeed
03:17:58 <Eduard_Munteanu> Yeah, it's just lazy, not oracular. :)
03:18:06 <Accidus> Well, it wouldn't run at all
03:18:12 <Accidus> Because Haskell is lazy
03:18:14 <Axman6> the only way that might work is if minimum is defined using foldr, and min has a definition that special cases the minimum value
03:18:23 <Accidus> You have to make it run first :P
03:19:22 <Accidus> Actually, I take it back. i don't want to argue over this point. :P
03:25:04 <augustss> howdy
03:25:08 <Cale> (and 1 isn't even the minimum value of Integer)
03:25:49 <Eduard_Munteanu> Hey.
03:27:17 <Cale> I tend to think that any semantic infelicity which makes more programs terminate is a good bit less harmful than one which makes programs nonterminate. But as soon as you do things to make programs terminate in special cases like that, you'll end up with programs relying on that behaviour, and it becomes quite complicated to support.
03:28:08 <Cale> (if all you're doing is special case hacks, like knowing that the minimum value of [x..] is x)
03:28:22 <elliott> One could say the same thing of laziness. I think it's about consistency.
03:28:53 <Cale> Well, laziness is different in that it's an implementation of systematic non-strict semantics.
03:29:21 <Cale> It's principled in that regard, rather than being dependent on the use of a blessed set of library functions.
03:29:34 <elliott> Like, I don't see how (minimum [x..]) could possibly know that x is the minimum element without it being a Lisp-style macro. So, conceptually at least to me, it gets filed under "special things the compiler is doing", which is a few murmurs away from "hack".
03:29:41 <elliott> (I wonder if you could do it with GHC rules?)
03:30:15 <elliott> Whereas laziness isn't really comparable to that, despite having the same sort of "now this impossible program terminates" effects.
03:30:49 <hpc> @src minimum
03:30:50 <lambdabot> minimum [] = undefined
03:30:50 <lambdabot> minimum xs = foldl1 min xs
03:31:30 <GlenK> so I just did this:  http://projecteuler.net/index.php?section=problems&id=5  And even though I got the right answer, I was hoping someone might look at my code?  http://fpaste.org/9Qp8/
03:32:19 <elliott> GlenK: "if x then True else False" === x.
03:32:54 <hpc> :t all
03:32:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:32:56 <elliott> modAllTwenty x = all . map ((== 0) . mod x) [11..19]
03:33:01 <elliott> oh, all takes a predicate?
03:33:11 <Cale> elliott: If x was indeed the minimum possible value of the type as a whole, it's possible to catch that.
03:33:14 <elliott> GlenK: modAllTwenty x = all ((== 0) . mod x) [11..19]
03:33:30 <Cale> (or in any case where that minumum possible value occurs over the whole list)
03:33:37 <elliott> Cale: Indeed. It wasn't in the example, though. (I would be a bit wary of that, too; sometimes functions feel like they should be more strict than they have to be.)
03:33:47 <hpc> modAllTwenty x = all (\y -> mod x y == 0) [1..20]
03:34:03 <hpc> or what elliott said...
03:34:36 <Axman6> @check \x -> mod x 1 == 0
03:34:38 <lambdabot>   "OK, passed 500 tests."
03:34:39 <Accidus> How can I use case pattern matching in anonymous functions? Do I have to use a case statement?
03:34:47 <Axman6> Accidus: yes
03:34:53 <Cale> GlenK: if/then/else should be indented like:
03:34:53 <hpc> \x -> case x of ...
03:34:54 <Cale> if foo
03:34:56 <Cale>    then bar
03:34:58 <Cale>    else quux
03:35:01 <Cale> or:
03:35:04 <Cale> if foo then bar
03:35:08 <Cale>        else quux
03:35:12 <hpc> you can do pattern matching in lambdas, but then you only get to match one pattern
03:35:22 <elliott> GlenK: http://hpaste.org/50755
03:35:23 <Cale> In any case where you split it across lines, the 'then' and 'else' should line up.
03:35:29 <elliott> GlenK: That's how I'd restructure your code.
03:35:52 <Cale> Accidus: yeah
03:36:12 <elliott> Accidus: Unfortunately, yes. (It gets true the more people say it.)
03:36:15 <Cale> Accidus: One syntax extension that I would very much like to have is sections of case
03:36:19 <GlenK> thanks everyone.
03:36:31 <Accidus> Sections of case?
03:36:33 <Cale> Accidus: So that  case of ...  would translate into  \fresh -> case fresh of ...
03:36:42 <Axman6> (case of Foo a -> bar; Bar b -> baz)?
03:36:53 <elliott> Cale: Then can we rename "case of" to "\"?
03:37:11 <Cale> elliott: maaaybe
03:37:14 <Accidus> Cale, I'm not sure I follow. Do you want to do eta expansion for sums?
03:37:14 <mauke> elliott: that would break everything
03:37:31 <elliott> mauke: Good. It was probably broken anyway. :p
03:37:32 <Cale> It would be weird to allow semicolons in lambda's syntax
03:37:56 <elliott> Cale: Well, then we just have to replace the ; with |... well, I started off that thought thinking about the "data" syntax, but that would mix rather interestingly with guards.
03:38:01 <elliott> I don't think it'd be strictly ambiguous, though.
03:38:03 <Cale> Accidus: Just a simple syntactic thing where if you leave out the scrutinee of case, it automatically forms a lambda
03:38:10 <Accidus> BTW, thanks Axman6, Cale, hpc and elliott
03:38:20 <Cale> Accidus: similar to how (+ 5) gets turned into  \x -> x + 5
03:38:38 <hpc> if you need to do pattern matching in a lambda, or really if your lambda is big at all, just give it a name
03:38:40 <elliott> Accidus: You're welcome. My answer repetition services are available at no cost.
03:39:15 <Accidus> Maybe Haskell should have had a macro system? It gets impossible to wade through all the syntax for newcomers like me :P
03:39:25 <elliott> Accidus: It does; Template Haskell.
03:39:32 <hpc> Accidus: it has template haskell and oh god do you not want it
03:39:40 <Accidus> Exactly
03:39:47 <elliott> hpc: Template Haskell is nice from one side.
03:39:55 <elliott> (It's the side where you don't have to import anything starting with "Language.Haskell".)
03:39:58 <Cale> Accidus: Adding macros only makes for more syntax to wade through :)
03:40:14 <Cale> People are CRAZY when they say lisp has no syntax :)
03:40:22 <Accidus> Cale, but it's in the libraries
03:40:26 <Cale> Sure
03:40:29 <elliott> Accidus: Really though, are you sure what you think is syntax isn't just operators?
03:40:29 <Accidus> So you can just read the libraries
03:40:42 <hpc> Accidus: libraries aren't any easier to read than specs
03:40:46 <Cale> You could similarly just read the compiler's source code ;)
03:40:51 <hpc> there just happen to be more of them ;)
03:40:55 <Accidus> Cale, not the same thing
03:40:59 <Cale> Or indeed, the GHC user guide and specs.
03:41:08 <Cale> It can be.
03:41:11 <mauke> Accidus: are you a lisper?
03:41:15 <elliott> Macros are literally mini-compilers, it's the exact same thing.
03:41:17 <Cale> The way that some people use macros.
03:41:24 <elliott> (Apologies to Scheme users.)
03:41:27 <Accidus> mauke, I'm a semanticist
03:41:51 <dmos> Looking around the net, there seems to be a lot of mention of Cale Gibbard's "How To Use Monad Transformers" (incl. numerous links from Haskellwiki), but I seem to be unable to dig up a copy.
03:41:54 <dmos> Cale or anyone else: where can I find a copy of the tutorial? Thx
03:42:18 <Axman6> dmos: ask Cale =)
03:42:23 <Cale> dmos: Oh, sorry, I lost that article when the computer I was running my webserver on went down.
03:42:26 <Axman6> uh, lag -_-
03:42:43 <elliott> dmos: Seems like the only link to it floating around the net is http://cale.yi.org/index.php/How_To_Use_Monad_Transformers, which is dead. (You probably already know this.)
03:42:51 <Cale> I need to rewrite it .__.
03:42:59 <Cale> yes
03:43:05 <Cale> That was the old link
03:43:08 <dmos> Cale: :( Ok thanks anyway.
03:43:15 <elliott> And robots.txt stop Wayback from getting it.
03:43:23 <elliott> http://cale.yi.org/robots.txt That's some robots.txt.
03:43:33 <Axman6> grr
03:43:58 <Cale> dmos: The gist of it was this: make it so that from outside your library nobody can tell you're using monad transformers.
03:44:22 <dmos> Cale: as an aside, maybe don't use a robots.txt to exclude your blog, then there would have been a chance of it being picked up by archive.org.
03:44:39 <Cale> elliott: Indeed. I got sick of all the search engines grinding over my files.
03:44:49 <dmos> elliott: Yeah, that's the one that's mentioned everywhere..
03:44:53 <Cale> elliott: and decided to just block them all
03:44:59 <Cale> (this is my personal computer)
03:45:01 <elliott> Cale: Clearly robots.txt needs "User-agent: unfriendly".
03:45:08 <hpc> Cale: you can set a delay for search engines
03:45:10 <elliott> All the nice user-agents, like Wayback, can get through, but nasty crawlers are stopped.
03:45:20 <elliott> This would work using the honour system which is, of course, infallible.
03:45:22 <hpc> make them wait 20 seconds before requesting the next page
03:45:28 <Cale> Wayback in particular.
03:45:28 <elliott> (Wait, that's how robots.txt works anyway...)
03:46:04 <dmos> Cale: Ok, will see what I can come up with. I use xmonad source as inspiration which should be worth something.
03:46:08 <Cale> Honestly, I'm less annoyed losing all the crap on my webserver than I would have been letting robots waste my bandwidth :)
03:46:10 <confound> it should use the evil bit
03:46:13 <mauke> IIRC robots.txt is retroactive for wayback
03:46:28 <mauke> so if you remove it, maybe stuff becomes visible
03:46:35 <elliott> I wish Wayback were slightly less good citizens about that, wrt the retroactiveness.
03:47:03 <Cale> dmos: Xmonad isn't perfect about it, but it's an okay example as far as monad transformers over IO go.
03:47:16 <Cale> dmos: I actually kinda think that you should never transform the IO monad.
03:47:23 <dmos> mauke: are you saying that they will retroactively drop already crawled content (or refuse to search for it) if you put in a robots.txt excluding them?
03:47:34 <mauke> dmos: yes
03:47:37 <Cale> (except possibly by ContT, and those cases are extremely rare)
03:47:56 <Eduard_Munteanu> Why? I was under the impression an IOT would be really bad.
03:48:06 <elliott> Cale: What about ReaderT (MVar blah) IO?
03:48:07 <Cale> Eduard_Munteanu: IOT would be really bad too
03:48:19 <elliott> Cale: I use that occasionally to get the one thing you can't get out of IO without unsafePerforming it.
03:48:31 <Cale> elliott: I find that MVar blah -> IO a is usually much easier to work with in the end.
03:48:33 <dmos> Cale: do you know of a better example to look at? My needs are rather benign, but I need to make configuration modular which means I need a Reader monad in there somewhere.
03:48:51 <elliott> Cale: Well, ((->) s) is a monad transformer too. :)
03:48:55 <Cale> dmos: Parameter passing is my answer
03:48:58 <Cale> elliott: sure
03:49:17 <Cale> elliott: I would tend to use that monad over the more explicit ReaderT
03:49:37 <Cale> But really, I don't mind passing one parameter around
03:50:08 <Cale> The key is just to make sure that you bundle things into datatypes when appropriate.
03:50:10 <elliott> What I take away from "don't transform IO" is more "stay out of IO" than "use IO in all its glory". :p
03:50:25 <dmos> Cale: I tried parameter passing, but it got unwieldy, now looking for a cleaner way to carry around a modular configuration.
03:50:41 <Cale> dmos: Did you try forming a record type with all your configuration in it?
03:50:42 <Eduard_Munteanu> dmos: you can pass a record around
03:50:46 <Cale> So you only have one parameter
03:50:58 <dmos> Yeah, that's where I'm now.
03:51:22 <hpc> elliott: the other way out is "transform over IO by hand, and give only limited access to IO actions in that monad"
03:51:35 <Cale> Yeah, that's the solution I recommend, because it's almost always more convenient than having to liftIO every IO action you want to perform.
03:52:04 <hpc> the monad for my website can print to stdout, stderr, and do database manipulation
03:52:05 <Cale> Unless there are a finite set of IO actions you want to provide access to, in which case you can form a restricted monad.
03:52:06 <elliott> hpc: That's just staying out of IO where you've optimised your execution process on the result.
03:52:12 <mauke> what if most of the actions I want aren't IO?
03:52:15 <elliott> Which, okay, is probably a circular argument.
03:52:34 <Cale> mauke: then sure, but that's usually the more rare case.
03:52:50 <Cale> ReaderT after all doesn't exactly add a lot of functionality
03:52:54 <mauke> I do that in preflex plugins
03:53:02 <mauke> but then I doubt preflex is actually good design
03:53:38 <dmos> Mmh, I need access to IO anyways (it's shell script style code), so IO is going to hang around in one way or another (might use a restricted monad down the road thought).
03:54:31 <Eduard_Munteanu> BTW, I noticed preflex uses notify now. :/
03:54:40 <hpc> it also helps to just get comfortable with having lots of IO around, so when a bug inevitably pops up, it's easy to fix
03:54:46 <mauke> Eduard_Munteanu: o rly?
03:54:51 <elliott> Notify?
03:55:23 <dmos> The thinking behind looking into Reader (or ReaderT) was that I have one module which introspects contributions by other modules, and thus needs access to what other modules provided. Which is very close to ReaderT XConf in xmonad.
03:55:24 <Eduard_Munteanu> preflex: seen mauke
03:55:24 <preflex>  mauke was last seen on #haskell 39 seconds ago, saying: Eduard_Munteanu: o rly?
03:55:29 <Eduard_Munteanu> Strange.
03:55:35 <elliott> Oh, do you mean NOTICE?
03:55:41 <Eduard_Munteanu> I saw it earlier in -blah
03:55:54 <Eduard_Munteanu> Uh, yeah :)
03:56:05 <elliott> preflex: notice me up
03:56:12 <elliott> lame
03:56:19 <Cale> dmos: Don't get me wrong, you *can* do it that way.
03:56:20 <Eduard_Munteanu> It only does so in -blah it seems
03:57:24 <Cale> dmos: But I've come to think that a lot of people jump into using transformers over IO that way where it doesn't actually help their code. Note that it also makes using higher order functions over IO really awkward too.
03:57:40 <Cale> (and there are solutions to this, but they're really clunky as well)
03:58:20 <Saizan> monad-control seems pretty clean
03:58:29 <dmos> Cale: ok. will mull it over.
03:58:41 <hpc> Cale: perhaps it's one of those things where new programmers have to make the transformers mistake at least once just to learn that it's a pain in the ass?
03:58:43 <Saizan> i.e. MonadControlIO, though i'm not sure that's a good name for it
03:58:55 <mauke> Cale: http://pingpawn.com/quotes/10725
03:59:15 <Eduard_Munteanu> dmos: one other option might be implicit arguments
03:59:22 * Eduard_Munteanu isn't sure if somebody mentioned it already
03:59:39 <dmos> in general the things that trips me at the moment is how to get to the same level of *stateful* (mutable/immutable) composability of different parts of my code.
04:00:14 <dmos> Eduard_Munteanu: implicit arguments? seems I have missed something there (only know about them in Scala). Will dig into that. Thx for the pointer.
04:00:19 <elliott> mauke: I would pay good money to read that
04:01:34 <Eduard_Munteanu> dmos: http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters
04:01:55 <dmos> Eduard_Munteanu: yep, just found it.
04:02:12 <elliott> does anyone actually use implicit parameters?
04:02:32 <benmachine> they're used in lambdabot's code
04:02:43 <Eduard_Munteanu> Yes, in Agda :P
04:02:48 <Eduard_Munteanu> But that's a different thing.
04:03:05 <Eduard_Munteanu> I haven't used them so far in Haskell, no.
04:03:15 <Cale> dmos: One thing which I rather like about the explicit parameter passing in IO is that you can actually control access to your state rather finely by passing around  readIORef r  and  writeIORef r  separately to the parts of the code which are allowed to read and write the configuration.
04:03:19 <elliott> benmachine: that's what everyone says when implicit params are brought up
04:03:24 <elliott> and nobody can think of another example :P
04:04:57 <kosmikus> dcoutts: /win 12
04:05:01 <kosmikus> sorry
04:05:10 <Cale> dmos: and the nice thing about those is that their types give nothing away about how the reference is implemented, so you can do things up at the top level where you create those two functions to alter the semantics of the state is changed or read (which is particularly important if your application is concurrent -- you might want to switch to using MVar/SampleVar/Chan, and you can do that almost transparently)
04:05:51 <Cale> of how the state is changed*
04:06:38 <dmos> Cale: sounds like quite a powerful abstraction. I'll look into it.
04:07:27 <dmos> Would lamdabot code be reasonably good code to use for inspiration (just trying to find good examples for moderately sized Haskell projects to learn from).
04:08:13 <elliott> i don't think lambdabot is widely considered to be of good style, is it
04:08:27 <hpc> dmos: you might try looking through xmonad
04:08:42 <benmachine> lambdabot is a tangled mess, in my experience :P
04:08:55 <elliott> hpc: that's how they started
04:09:04 <benmachine> it's very old and unmaintained and no-one really understands it anymore
04:09:10 <Cale> lambdabot is an organically grown mess. It's not had a proper maintainer in years.
04:09:27 <dmos> aww, too bad.
04:09:33 <hpc> Cale: just someone to keep the switch in the 'on' position? :P
04:09:40 <Cale> yes, that would be me
04:09:48 <Cale> I just run the lambdabot instance, I don't really maintain the code
04:09:52 <dmos> does anyone know how long have implicit parameters been around?
04:10:07 <Cale> dmos: hmm, since... around 2002 maybe?
04:10:13 <Saizan> don't put it on a powerful machine, it might become sentient
04:10:34 <Cale> 2000 even
04:10:49 <Cale> Implicit parameters: dynamic scoping with static types, J Lewis, MB Shields, E Meijer, J Launchbury, 27th ACM Symposium on Principles of Programming Languages (POPL'00), Boston, Jan 2000
04:10:49 <benmachine> @vixen are you sentient yet
04:10:51 <lambdabot> yes, i am
04:10:54 <benmachine> :<
04:10:55 <elliott> oh dear
04:11:05 <dmos> Cale: nice, thx
04:11:53 <Cale> GRR, why does google make copy/pasting links so awkward?
04:12:11 <Cale> http://citeseer.ist.psu.edu/viewdoc/download;jsessionid=ED6A76D27B64D1F4C4894EAAE8001FED?doi=10.1.1.156.5131&rep=rep1&type=pdf
04:13:10 <dmos> Cale: downloaded.
04:13:36 <Cale> They show you a link, even make the address show up in the statusbar correctly, and then when you copy it, it ends up being some extremely long URL which points at a google server.
04:14:14 <elliott> Cale: Well, they couldn't track you as well if they didn't do that.
04:14:18 <Cale> I don't particularly care that they're redirecting traffic, but they shouldn't break my browser's "copy link" functionality.
04:14:24 <elliott> I do wonder why a JavaScript click handler isn't enough to manage it.
04:14:46 <dmos> any other project known to use implicit parameters?
04:16:03 <Eduard_Munteanu> dmos: just try passing a record around, don't worry too much about it
04:16:10 <Eduard_Munteanu> See how that works out.
04:16:53 <benmachine> Cale: how do you copy it?
04:16:58 <Accidus> Is there a way to query the type system whether it can prove a given class instance apart from trying to redefine it and have it complain about overlapping instances?
04:17:05 <Cale> benmachine: Right click and copy link location.
04:17:18 <benmachine> huh, weird how that doesn't work
04:17:50 <benmachine> in defence of my browser it doesn't show up in the statusbar correctly either :P
04:17:55 <Eduard_Munteanu> http://www.google.com/url?sa=t&source=web&cd=1&sqi=2&ved=0CCgQFjAA&url=http%3A%2F%2Fwww.haskell.org%2F&rct=j&q=haskell&ei=yn5bTp7tLsfLsgbBmJjTCg&usg=AFQjCNEUgp4cz-Ux4IBG1O3XhObfY7iizg&cad=rja
04:18:16 <Eduard_Munteanu> For example.
04:18:17 <Cale> ^^ yeah, you get crap like that
04:18:27 <Eduard_Munteanu> It shows correctly in the statusbar though
04:19:24 <dmos> Eduard_Munteanu: Passing a record around is where I am at the moment. It does work ok. I'm just trying to find out if there's a cleaner way to solve it.
04:19:58 <dmos> Anyway, I think I have now a better idea of what the territory looks like, much obliged.
04:20:20 <Eduard_Munteanu> http://www.consumingexperience.com/2009/10/google-search-results-redirection.html
04:22:08 <Eduard_Munteanu> I'm thinking parametrized modules might also be a solution for args passing.
04:22:15 <Eduard_Munteanu> But note that isn't implemented.
04:26:40 <dmos> Oh, one other question (or extension of the previous ones):
04:26:47 <dmos> What existing projects should I look at in general for good large(ish)-scale design in Haskell.
04:26:59 <dmos> Especially to learn how fuzzy problems like modularity, crosscutting concerns, logging, failure recovery, etc. have been tackled - all those things that are needed for real-world applications but not usually put into throw away code and libraries.
04:27:22 <dmos> For now my list contains xmonad and combinatorrent. anything else I should look at?
04:28:21 <elliott> wasn't xmonad designed to be a good example of architecture first, a program second :-)
04:28:30 <Eduard_Munteanu> darcs? Also take a look at http://www.haskell.org/haskellwiki/Applications_and_libraries
04:28:34 <elliott> I've never heard of combinatorrent, looks bitrotten
04:28:42 * Eduard_Munteanu neither :/
04:28:48 <elliott> Eduard_Munteanu: I thought darcs was very crufty code-wise?
04:28:59 <hpc> combinatorrent was someone trying to write the lightest torrent client possible in haskell
04:29:09 <elliott> Dependencies	array (≥0.3), attoparsec (≥0.8), base (≥3.0 & <5.0), bytestring, cereal, containers, deepseq, directory, filepath, hopenssl, hslogger, HTTP, HUnit, mtl, network, network-bytestring, parsec, pretty, PSQueue, QuickCheck (≥2), random, random-shuffle, stm, test-framework, test-framework-hunit, test-framework-quickcheck2, time
04:29:09 <elliott> light
04:29:11 <Eduard_Munteanu> Dunno, but it's quite a representative Haskell project.
04:29:23 <hpc> http://www.haskell.org/haskellwiki/Web/Frameworks
04:29:44 <benmachine> combinatorrent has last git commit in march 2011
04:29:44 <hpc> some of those could be good to read
04:29:46 <elliott> "haskell on a horse" good name
04:29:48 <benmachine> that's not *that* stale
04:29:55 <elliott> benmachine: to fix a use of -fglasgow-exts
04:30:06 <Eduard_Munteanu> Hah.
04:30:07 <benmachine> elliott: sure, but it means someone was paying attention
04:30:18 <benmachine> especially as iirc -fglasgow-exts was only deprecated in GHC 7
04:30:25 <elliott> hmm, it does look like someone remembered it existed early this year
04:30:47 <Eduard_Munteanu> I'm pretty sure -fglasgow-exts was advertised against even earlier.
04:30:51 <elliott> still, I would hesitate to say this program I've never heard about is an example of good Haskell architecture
04:30:55 <elliott> but that's just me :-P
04:31:02 <Eduard_Munteanu> Was it just removed in GHC7?
04:31:18 <dmos> hpc: ah, yeah, those are on the list as well, thanks for the reminder.
04:31:24 <Eduard_Munteanu> Hm, it's still there.
04:31:47 <benmachine> Eduard_Munteanu: it now causes a warning
04:31:49 <benmachine> on -Wall
04:31:50 <elliott> Eduard_Munteanu: It probably g- yea.
04:32:09 * mux wishes GHC would at least try to respect POLA accross major releases when it's not too much work
04:32:22 <elliott> I don't think you mean POLA.
04:32:27 <mux> I do mean POLA
04:32:32 <mux> principe of least astonishment
04:32:35 <mux> principle*
04:32:38 <elliott> Principle of least authority?
04:32:39 <elliott> Oh.
04:32:45 <elliott> I've heard that as POLSurprise.
04:32:49 <mux> heh
04:33:01 <benmachine> mux: what's astonishing?
04:33:07 <elliott> Well, -fglasgow-exts being bad should not astonish anyone.
04:33:11 <mux> -fglasgow-exts causing a warning
04:33:12 <elliott> At least anyone who's been awake for the past decade or so.
04:33:23 <benmachine> mux: would you just support the flag forever and ever?
04:33:24 <elliott> mux: how else should GHC inform people that it's not a good idea to use?
04:33:46 <elliott> Emailing you if you use it too many times?
04:33:51 <benmachine> haha
04:33:53 <benmachine> yes.
04:33:55 <mux> benmachine: at least longer than just dropping it at the next major release without any warning that I'm aware of - but that -fglasgow-exts bit is just an example
04:34:08 <benmachine> mux: it's still not dropped, is it?
04:34:09 <mux> there are countless other breakages, and more annoying ones, at every major GHC release
04:34:10 <elliott> I don't think GHC does that :P
04:34:18 <elliott> At least it's never happened to me, and I'm everyone.
04:34:24 <mux> let's not focus on that -fglasgow-exts bit
04:34:37 <elliott> mux: by major do you mean five -> six -> seven? because that's quite a gap
04:34:39 <benmachine> well, what else then?
04:34:46 <elliott> I wouldn't expect very much at all to stay consistent between those
04:34:50 <mux> elliott: yes, that's what one call a major release ;-)
04:34:59 <mux> the $() thingie for TH syntax was another example
04:35:03 <elliott> mux: well, they're pretty long-lived for major releases.
04:35:06 <benmachine> glasgow-exts has now been deprecated but still functional for two major versions
04:35:07 <mux> it got reintroduced in the next release IIRC
04:35:14 <elliott> when has $() ever broken?
04:35:18 <benmachine> mux: are you thinking of qq syntax?
04:35:22 <benmachine> [$foo| |]
04:35:26 <mux> benmachine: that's the one
04:35:28 <benmachine> oh
04:35:36 <benmachine> I think that did annoy me too to be fair
04:35:43 <elliott> benmachine: glasgow-exts was deprecated upon 6's release?
04:35:47 <mux> there are plenty others...
04:35:54 <elliott> I didn't think it'd been advised against for that long
04:35:57 <mux> Control.Exception broke things
04:35:58 <benmachine> elliott: I consider 7.2 and 7.0 to be two major versions
04:36:10 * mux scratches head
04:36:21 <mux> I think it's quite unfair to ask me for more examples anyways :-P
04:36:28 <mux> this has happened time and time again
04:36:38 <benmachine> mux: I like that GHC innovates
04:36:43 <elliott> benmachine: I'd call 6.8, 6.10, 6.12 major versions too -- but then I never understood the philosophy of every few years going in and breaking a bunch and incrementing an arbitrary counter as monument to that.
04:36:48 <benmachine> I prefer instability to stagnation
04:36:51 <gienah> most stuff seems to compile with ghc 7.2.1, ghc-mtl and its dependency hint are broken due to ghc api changes
04:36:53 <elliott> mux: We've got exactly one real example out of you so far :P
04:36:54 <benmachine> but I can understand that not everyone else does
04:36:57 <mux> benmachine: I too, but as the userbase grows, it's nice to at least pretend to care about those things :-)
04:37:09 <benmachine> mux: that leads to stagnation :P
04:37:13 <elliott> http://haskell.org/ghc/download_ghc_029 <-- I wonder if this has -fglasgow-exts?
04:37:17 <mux> elliott: so you ignored Control.Exception?
04:37:28 <elliott> mux: oh, it slipped my mind -- ok, two
04:37:33 <elliott> that's not the same thing as all the time :)
04:37:35 <mux> elliott: oh come on now, be honest
04:37:37 <elliott> especially since one is being rectified
04:37:44 <mux> don't you see tons of packages suddenly failing with new GHC releases??
04:37:50 <mux> it's not like I'm inventing things.
04:37:58 <benmachine> mux: sure, but that's what major versions are for :)
04:38:06 <elliott> what benmachine said :P
04:38:13 <elliott> when it doesn't break anything, that's called a minor version
04:38:18 <benmachine> mux: to be fair, the GHC homepage *does* say, don't get this, get the platform instead
04:38:18 <gienah> mux: yes there were some breakages, but we seem to have been able to fix a lot of them (but not hint as yet)
04:38:27 <hpc> for breaking the old things and coercing maintainers out of the woodwork?
04:38:28 <mux> well it's not the same thing saying that major releases are here for that, and trying to convince me that I'm wrong and that breakages don't happen...
04:38:37 <mux> when your userbase grows, you want to be a little more careful about those things
04:38:43 <elliott> let's see -- how long do major versions last? 6.0: 2003. 7.0: (late) 2010.
04:38:51 <elliott> I think breaking code once every seven years would be fantastic
04:39:08 <elliott> hmm, looks like 5 only lasted two years
04:39:13 <benmachine> mux does have a point that haskell code at the moment has a short shelf-life
04:39:24 <mux> elliott: this is beside the point
04:39:36 <benmachine> but I don't necessarily see that as a drawback
04:39:38 <elliott> benmachine: yeah, but someone comes up with a better abstraction at about the same rate that the existing code breaks :P
04:39:56 <benmachine> elliott: code breaks *because* someone came up with a better abstraction!
04:40:20 <mauke> damn abstractions
04:40:23 <benmachine> mux: after the new Control.Exception was introduced, there *was* Control.OldException
04:40:28 <mauke> coming to our country, breaking our code
04:40:34 <mux> benmachine: which didn't help for *unmodified* code
04:40:38 <elliott> import Control.NewException -- aww yeah, this feels shiny
04:40:40 <mux> providing a workaround is not avoiding the breakage.
04:40:44 * gienah has a little over 300 packages built with ghc 7.2.1
04:40:51 <elliott> mux: a base compatibility package would have been nice
04:40:55 <benmachine> mux: true, but it's a mitigating factor
04:40:56 <elliott> was there nothing like that at the time?
04:40:57 <mux> elliott: yes, for instance
04:41:01 <elliott> that's the obvious solution at least IMO
04:41:01 <mux> benmachine: yes, I agree :-)
04:41:08 <benmachine> well, GHC 6.10 shipped with base 3 and base 4
04:41:14 <benmachine> with old and new exceptions respectively
04:41:20 <elliott> benmachine: yeah but that's just horrible.
04:41:31 <mux> one easy thing to do to improve the situation would be to highlight backwards compatible changes in the release notes
04:41:49 <mux> API wise, ABI wise or command-line wise
04:42:01 <mux> s/compatible/incompatible/
05:02:19 <sanjoyd> @hoogle a->[a]
05:02:20 <lambdabot> Prelude repeat :: a -> [a]
05:02:20 <lambdabot> Data.List repeat :: a -> [a]
05:02:20 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
05:07:17 <Accidus> I'll ask again: Is there a way to query the type system whether it can prove a given class instance apart from trying to redefine it and have it complain about overlapping instances?
05:08:12 <mauke> yes, use the instance and see whether the type checker complains
05:08:35 <rwbarton> how about  x :: YourClass YourType => YourType; x = undefined
05:09:31 <Accidus> Interesting. Thanks!
05:10:19 <kosmikus> > (() :: Num Int => ()) :: ()
05:10:21 <lambdabot>   ()
05:10:24 <kosmikus> > (() :: Num Char => ()) :: ()
05:10:26 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
05:10:26 <lambdabot>    arising from an expression ...
05:11:21 <kosmikus> Accidus: ^^
05:11:30 <Accidus> I saw, thanks.
05:15:03 * hackagebot GenericPretty 1.1.9 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-1.1.9 (RazvanRanca)
05:17:49 <Gagis> Hello folks. I am a physics student who has recently began to study haskell out of curiosity and I have been wondering if there are any powerful modules/libraries for scientific computation for haskell, similar to GSL of C++ and similar stuff for fortran or even things like python's various scientific libraries. Any recommendations?
05:20:51 <Eduard_Munteanu> @where hmatrix
05:20:52 <lambdabot> I know nothing about hmatrix.
05:20:56 <Eduard_Munteanu> @hackage hmatrix
05:20:57 <lambdabot> http://hackage.haskell.org/package/hmatrix
05:21:09 <gienah> haskell has good Foreign Function Interface support to call Fortran libraries, so there are wrappers using BLAS GSL LAPACK like hmatrix
05:21:17 <Eduard_Munteanu> Gagis: ^
05:22:17 <Gagis> Thanks, That's exactly what I need.
05:22:42 <espadrine`> Hello, I was wondering why `y f = f (y f)` works, and indeed defines a fixed-point combinator? Is it because haskell is a lazy programming language?
05:22:42 <espadrine`> I cannot make that work in other languages without writing out the Y combinator in Haskell Curry's form.
05:24:25 <Eduard_Munteanu> espadrine`: in imperative languages you want (variants of) the Z combinator. The Y combinator works as intended only in lazy languages.
05:24:35 <Eduard_Munteanu> s/imperative/strict/
05:26:05 <espadrine`> Eduard_Munteanu: The Y combinator works in Scheme and JavaScript, which aren't particularly lazy.
05:26:20 <kmc> there's a strict Y combinator and a lazy Y combinator
05:26:31 <kmc> but "y f = f (y f)" is neither
05:26:54 <espadrine`> kmc: y f = f (y f) is the clearest definition
05:27:01 <Eduard_Munteanu> That's what TAPL says on Z vs Y.
05:27:16 <espadrine`> every other combinator boils down to `y f = f (y f)`
05:27:22 <Eduard_Munteanu> espadrine`: it's not like you can write Y anyway in Haskell
05:27:42 <espadrine`> Eduard_Munteanu: how so?
05:27:58 <Eduard_Munteanu> It can't be typed.
05:28:08 <espadrine`> http://www.willamette.edu/~fruehr/haskell/evolution.html
05:28:15 <espadrine`> gives an implementation
05:28:27 <espadrine`> in order to get the factorial function
05:28:38 <mauke> but not of Y
05:30:01 <espadrine`> mauke: I guess I see your point. Nonetheless, translating `y f = f (y f)` yields a stack overflow in all other languages.
05:30:40 <kmc> espadrine`, it's not the clearest definition of the Y combinator; that's not a valid concept
05:30:46 <kmc> the Y combinator is a particular lambda term
05:30:51 <kmc> (or maybe two, as noted)
05:31:04 <kmc> that "y" may be the clearest definition of a fixed-point combinator in Haskell
05:31:14 <kmc> but it's not the Y combinator and couldn't be
05:31:16 <espadrine`> Let's say, It is the shortest fixed point combinator I know of.
05:31:35 <espadrine`> *shortest definition
05:32:10 <kmc> the point of Y is to implement recursion when you haven't got any to begin with
05:32:22 <kmc> but that's not possible in typed lambda calculus
05:32:50 <kmc> nothing has type "(a -> a) -> a" in the simply-typed lambda calculus
05:33:16 <espadrine`> kmc: How does `y f = f (y f)` work in haskell then?
05:33:22 <kmc> so to write a fixed-point combinator, you need recursion already built into your language somewhere, either at term level or at type level
05:33:35 <maurer_> kmc: What do you think would be a good way to define native pointer types for other architectures?
05:33:42 <mauke> espadrine`: it's directly recursive in y
05:33:45 <kmc> espadrine`, Haskell is not the simply-typed lambda calculus.  it has recursion built-in at term level
05:34:00 <kmc> note that you used "y" on the right-hand side while defining "y"
05:34:19 <kmc> which is not required when writing the Y combinator
05:34:53 <kmc> maurer_, explain?
05:35:10 <espadrine`> kmc: what is special about direct recusion in haskell, which isn't in other languages?
05:35:25 <kmc> i don't understand the question
05:35:29 <mauke> espadrine`: nothing
05:35:33 <maurer_> kmc: So, I want to be able to write code that deals with, and does direct math on, native pointers etc.
05:35:48 <kmc> espadrine`, in a typed lambda calculus, you cannot implement recursion if you do not have recursion as a primitive
05:35:48 <maurer_> kmc: But I want to be able to reuse that code to work targeting other architectures.
05:36:08 <kmc> espadrine`, and that's exactly what the Y combinator does -- implements recursion without having any primitive for recursion
05:36:50 <maurer_> e.g. I want to be able to have something like a WordDataPtr that depending on an Arch parameter is either 32 or 64 bits, and a CodePtr type that on x86 would be the same ad a DataPtr, but if on ARM, the codePtrToDataPtr would mask off the bottom bit
05:36:54 <maurer_> That sort of thing
05:37:06 <kmc> interesting
05:37:21 <kmc> sounds like "Functional Pearl: Implicit Configurations"
05:37:31 * maurer_ looks it up
05:37:34 <Eduard_Munteanu> "Vanilla" STLC and System ω_F are both total.
05:37:53 <maurer_> Basically I don't want to do the traditional stuff these guys tend to do of assuming you are running on the platform you want to analyze
05:37:57 <espadrine`> kmc: So does JavaScript; yet JavaScript cannot support `function y(f) { return f(y(f)); }`
05:37:57 <espadrine`> And the same goes for Scheme, CL, etc.
05:38:23 <Eduard_Munteanu> espadrine`: that's because you can refer to y within its definition
05:38:25 <kmc> so does Javascript what?
05:38:47 <Eduard_Munteanu> But there's no way you can do that in a normal lambda.
05:38:49 <espadrine`> kmc: JavaScript has builtin recursion too
05:38:53 <kmc> right
05:39:00 <kmc> i don't think what you said is relevant to what i said just before it
05:39:36 <kmc> the reason Haskell supports direct-recursive fix, and JavaScript doesn't, is different from the reason JavaScript supports the Y combinator and Haskell doesn't
05:39:48 <espadrine`> Eduard_Munteanu: definitions in haskell are special?
05:39:57 <mauke> espadrine`: no
05:39:59 <kmc> the first is about evaluations semantics; the second is about types
05:40:22 <espadrine`> kmc: what is different in evaluation semantics?
05:40:34 <kmc> strictness
05:40:46 <kmc> in JavaScript evaluating a function call first evaluates all of the function call's arguments
05:41:02 <kmc> Haskell has non-strict semantics; the arguments are only evaluated as needed
05:41:30 <kmc> in a statically typed, strict language like ML, you cannot write Y (because types) and you also cannot use "fix f = f (fix f)" (because strictness)
05:41:38 <kmc> note that the 'f' in "fix f" need not be a function
05:41:50 <kmc> you can restrict it to functions and recover that usefulness
05:42:34 <kmc> :t let fux f x = f (\y -> fux f y) x in fux
05:42:35 <lambdabot> forall t t1. ((t -> t1) -> t -> t1) -> t -> t1
05:42:40 <kmc> this should work in a strict language
05:43:05 <espadrine`> kmc: oohh
05:43:05 <espadrine`> kmc: so ML cannot do any fixed-point combinator?
05:43:42 <kmc> it can take the fixed point of functions as i just demonstrated
05:43:55 <kmc> rather it can take the fixed point when the *result* is a function
05:44:08 <kmc> but Haskell's 'fix' can usefully return non-functions
05:44:35 <kmc> the thing is, ⊥ is a fixed point of a strict function (by definition)
05:44:42 <kmc> and it's the least fixed point (also by definition)
05:44:52 <kmc> so "fix f =  ⊥" if f is strict
05:46:18 <espadrine`> ok
05:47:11 <kmc> my "fux" function works in a strict language because you push the recursion down under a lambda
05:47:18 <kmc> which prevents it from being evaluated strictly
05:48:49 <shachaf> kmc: You mean that the "fix f" need not be a function?
05:49:14 <Cale> > fix (1:)
05:49:14 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:49:53 <shachaf> Right, but (1:) is still a function.
05:49:54 <kmc> yes
05:50:01 <Cale> :t fix
05:50:02 <lambdabot> forall a. (a -> a) -> a
05:50:09 <kmc> but (fix (1:)) is not a function, it's a list
05:50:15 <tech2> :t 1
05:50:17 <lambdabot> forall t. (Num t) => t
05:51:15 <kmc> fix's argument is a function, but its result can be any type if you provided an endofunction on that type.  of course, this sentence is just a silly way of writing out the type of 'fix'.
05:51:40 <elliott> Prelude> :t fix
05:51:41 <elliott> fix's argument is a function, but its result can be any type if you provided an endofunction on that type.
05:51:42 <kmc> > fix ((0:) . scanl (+) 1)
05:51:45 <elliott> Prelude>
05:51:46 <lambdabot>   mueval-core: Time limit exceeded
05:51:53 <elliott> i'd use it
05:51:57 <kmc> :D
05:52:00 <kmc> that's like cdecl
05:52:08 <Cale> > fix ((0:) . scanl (+) 1)
05:52:11 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:52:22 <Cale> fickle lambdabot is fickle
05:52:23 <elliott> is it just me or is the mueval time limit a little overly strict
05:52:29 <elliott> it rejects things like half the time
05:52:32 <Cale> It's not really that strict
05:52:35 <elliott> and then admits them the next time round
05:52:38 <kmc> > iterate ((0:) . scanl (+) 1) undefined
05:52:39 <lambdabot>   [*Exception: Prelude.undefined
05:52:47 <kmc> > iterate ((0:) . scanl (+) 1) []
05:52:49 <lambdabot>   [[],[0,1],[0,1,1,2],[0,1,1,2,3,5],[0,1,1,2,3,5,8,13],[0,1,1,2,3,5,8,13,21,3...
05:52:51 <Cale> Sometimes the server gets running slowly. I should check that there's no runaway processes.
05:53:15 <parcs> given just a record accessor is it possible to make a setter ?
05:53:25 <Cale> things seem fine now
05:53:31 <kmc> parcs, given how? as a function?
05:54:07 <Cale> parcs: http://hackage.haskell.org/package/fclabels
05:54:09 <shachaf> As a lens.
05:56:04 <parcs> kmc: yeah like runStateT or something
05:56:50 <elliott> parcs: http://hackage.haskell.org/package/data-lens :P
06:00:02 * hackagebot aeson-native 0.3.3 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-native-0.3.3 (MichaelSnoyman)
06:00:04 * hackagebot authenticate 0.10.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.10.1 (MichaelSnoyman)
06:00:06 * hackagebot blaze-textual-native 0.2.1 - Fast rendering of common datatypes  http://hackage.haskell.org/package/blaze-textual-native-0.2.1 (MichaelSnoyman)
06:00:08 * hackagebot hamlet 0.10.0 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.10.0 (MichaelSnoyman)
06:00:10 * hackagebot persistent 0.6.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.6.1 (MichaelSnoyman)
06:05:12 * hackagebot persistent-postgresql 0.6.0 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.6.0 (MichaelSnoyman)
06:05:14 * hackagebot shakespeare-js 0.10.1 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-0.10.1 (MichaelSnoyman)
06:05:16 * hackagebot shakespeare-text 0.10.1 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-0.10.1 (MichaelSnoyman)
06:05:18 * hackagebot wai-app-static 0.3.3 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-0.3.3 (MichaelSnoyman)
06:05:20 * hackagebot wai-extra 0.4.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.4.2 (MichaelSnoyman)
06:10:22 * hackagebot wai-handler-devel 0.4.3.1 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.4.3.1 (MichaelSnoyman)
06:10:24 * hackagebot wai-handler-fastcgi 0.4.1 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-0.4.1 (MichaelSnoyman)
06:10:26 * hackagebot wai-handler-launch 0.0.3 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-0.0.3 (MichaelSnoyman)
06:10:28 * hackagebot wai-handler-scgi 0.4.1 - Wai handler to SCGI  http://hackage.haskell.org/package/wai-handler-scgi-0.4.1 (MichaelSnoyman)
06:10:30 * hackagebot wai-test 0.1.1 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-0.1.1 (MichaelSnoyman)
06:10:44 <danr> Someone has been productive...
06:12:39 <dainanaki> I've got a bunch of SpecConstr messages showing up in some code that I've written, and I don't really understand what they mean. Could someone explain to me what it means when it says that?
06:12:57 <kamaji> Is there something built in to shuffle a list?
06:15:32 * hackagebot warp 0.4.4 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.4.4 (MichaelSnoyman)
06:15:34 * hackagebot warp-static 0.2.1 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-0.2.1 (MichaelSnoyman)
06:15:36 * hackagebot xml-hamlet 0.0.3 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.0.3 (MichaelSnoyman)
06:15:38 * hackagebot yesod 0.9.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.9.1 (MichaelSnoyman)
06:15:41 * hackagebot yesod-auth 0.7.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.7.1 (MichaelSnoyman)
06:16:10 <frerich> kamaji: I think I wrote a shuffle function which shuffles some list given a seed, it was based on shuffle' from http://hackage.haskell.org/packages/archive/random-shuffle/0.0.2/doc/html/System-Random-Shuffle.html
06:16:33 <Polarina> So many new package versions. Gonna be busy all week.
06:16:41 <o-_-o1> doneIO is which module ?
06:17:24 <frerich> kamaji: IIRC mine was 'shuffle :: [a] -> Int -> [a]' with "shuffle xs seed = shuffle' xs (length xs) (mkStdGen seed)"
06:18:03 <o-_-o1> > :t doneIO
06:18:04 <lambdabot>   <no location info>: parse error on input `:'
06:18:17 <o-_-o1> > doneIO
06:18:18 <lambdabot>   Not in scope: `doneIO'
06:19:22 <kamaji> frerich: oh cool, i'll check it out
06:20:14 <o-_-o1> is there putchar in haskell ?
06:20:19 <Cale> :t putChar
06:20:20 <lambdabot> Char -> IO ()
06:20:26 <o-_-o1> ah
06:20:34 <o-_-o1> <- stupid
06:20:42 * hackagebot yesod-core 0.9.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-0.9.1 (MichaelSnoyman)
06:20:44 * hackagebot yesod-form 0.3.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-0.3.1 (MichaelSnoyman)
06:20:46 * hackagebot yesod-json 0.2.1 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-0.2.1 (MichaelSnoyman)
06:20:49 * hackagebot yesod-newsfeed 0.3.1 - Helper functions and data types for producing News feeds.  http://hackage.haskell.org/package/yesod-newsfeed-0.3.1 (MichaelSnoyman)
06:20:51 * hackagebot yesod-persistent 0.2.1 - Some helpers for using Persistent from Yesod.  http://hackage.haskell.org/package/yesod-persistent-0.2.1 (MichaelSnoyman)
06:22:03 <Axman6> @hoogle doneIO
06:22:04 <lambdabot> No results found
06:22:31 <rwbarton> from google doneIO appears to be return () in some Haskell-like language
06:22:38 <o-_-o1> Axman6: I think it is a really old paper and those calls are no longer in haskell.
06:22:50 <o-_-o1> rwbarton: Yes.
06:23:04 <rwbarton> possibly Haskell before the introduction of monadic IO actually
06:23:05 <o-_-o1> there is a seqIO, and is seq the equivalent ?
06:23:13 <kmc> probably not
06:23:17 <o-_-o1> rwbarton: yes, this is the paper on monadic IO
06:23:20 <kmc> probably (>>=) or something is equivalent
06:23:32 <kmc> seq is about evaluation; (>>=) is about execution
06:23:41 <o-_-o1> kmc: hmmm....yes. That makes sense.
06:23:52 <kmc> but, i haven't read the paper
06:25:53 * hackagebot yesod-sitemap 0.2.1 - Generate XML sitemaps.  http://hackage.haskell.org/package/yesod-sitemap-0.2.1 (MichaelSnoyman)
06:25:55 * hackagebot yesod-static 0.3.0.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-0.3.0.1 (MichaelSnoyman)
06:25:59 <Cale> There is Control.Exception.evaluate as well
06:26:11 <Cale> :t Control.Exception.evaluate
06:26:12 <lambdabot> forall a. a -> IO a
06:26:29 <rgrinberg> @hoogle zip
06:26:30 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
06:26:30 <lambdabot> Data.ByteString zip :: ByteString -> ByteString -> [(Word8, Word8)]
06:26:30 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
06:27:15 <o-_-o1> How do I make some function return IO () ?
06:27:31 <o-_-o1> let pusIO [] = do IO ()
06:27:35 <parcs> @djinn (Monad m, Monad m1) => m a -> (a -> m1 (m b)) -> m1 (m b)
06:27:36 <lambdabot> -- f cannot be realized.
06:27:41 <Gagis> Gentlemen. hmatrix fails to install because Vextor is defined in both lib/Numeric/Vector.hs:44:9-46
06:27:48 <Gagis> and Data.Vector.Storable
06:27:49 <Axman6> :t return () :: IO ()
06:27:50 <lambdabot> IO ()
06:27:51 <Gagis> how to avoid?
06:28:14 <o-_-o1> argh nevermind
06:30:10 <Cale> Gagis: hmm, hmatrix installed okay for me last time I tried it
06:30:47 <parcs> @djinn (Monad m, Monad m1) => m (m1 a) -> m1 (m a)
06:30:48 <lambdabot> -- f cannot be realized.
06:30:58 <Gagis> Cale: yus. I am running ubuntu and have a fresh install of haskell platform from apt-get and now tried to install hmatrix via cabal
06:31:28 <byorgey> parcs: you want Data.Traversable.sequence for that
06:32:15 <byorgey> @type \m f -> fmap join $ Data.Traversable.sequence (fmap f m)
06:32:16 <lambdabot> forall (m :: * -> *) a (f :: * -> *) a1. (Monad m, Functor f, Data.Traversable.Traversable m, Monad f) => m a1 -> (a1 -> f (m a)) -> f (m a)
06:32:48 <byorgey> there's probably a nicer way to write it but that's the main idea
06:33:51 <Cale> Gagis: I don't trust my distribution's Haskell-related packages to be any good, so I just download the generic Linux binary of GHC, and then install cabal-install. I somewhat doubt that's your problem here though...
06:40:01 <Gagis> Cale: ill try to find some PPA repository so I wont have conflicts between ubuntu's haskell packages and cabal
06:42:57 <Gagis> The repos I have found so far have not worked -_-
06:44:49 <randomwords> Is it possible to implement a multithreaded algorithm on a mutable Vector? i.e. can I call V.read from multiple threads - or will there always be an implicit lock on the vector?
06:45:05 <Cale> Gagis: http://haskell.org/ghc/download_ghc_7_0_4#x86linux
06:45:06 <nominolo> A
06:45:07 <lambdabot> nominolo: You have 1 new message. '/msg lambdabot @messages' to read it.
06:47:06 <Cale> randomwords: I can't think of any problem with it
06:47:25 <Cale> Most things in Haskell are reasonably thread safe by default.
06:47:38 <Cale> It's a bug in the library if not.
06:47:45 <randomwords> Cale: fair enough - must be my fault
06:47:48 <Gagis> Cale: I found a repository that has newer stuff compiled including hmatrix. Seeing if it works
06:50:03 * hackagebot vector-read-instances 0.0.2.0 - (deprecated) Read instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-read-instances-0.0.2.0 (ChristianHoener)
06:50:58 <kmc> randomwords, i'd look at the source to be sure, but my default assumption is that there's no lock
06:51:13 <kmc> if you're reading and writing concurrently, things get a lot trickier
06:55:40 <gienah> Gagis: patch for hmatrix vector: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/hmatrix/files/hmatrix-0.11.1.0-vector-0.8.patch
06:56:48 <dylukes> @hoogle [a] -> [a] -> [[a]]
06:56:49 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
06:56:50 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
06:56:50 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
06:57:00 <dylukes> :t zipN
06:57:01 <lambdabot> Not in scope: `zipN'
06:57:04 <gienah> Gagis, Cale: vector-0.8 which is an optional package for hmatrix seems to include an instance which was not in vector-0.7, hence the patch
06:57:14 <dylukes> I need something that zips to tuples, not lists...
06:57:41 <Axman6> :t zip
06:57:42 <Cale> dylukes: what?
06:57:42 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
06:59:04 <Gagis> gienah: kay. i'm not too keen on installing anything outside package management unless absolutely necessary so I will try to get around the problem by removing haskell-platform and installing stuff via cabal-install
07:00:21 <gienah> Gagis: ok but hmatrix might need something like the patch anyway if it uses the vector option
07:00:32 <Cale> Gagis: In my experience, package management is counterproductive in combination with trying to install things from hackage. You tend to want your globally installed packages kept to a minimum, and install most hackage packages as user.
07:01:08 <Gagis> Cale: yus. I am giving that a try now. Its depressing to have two package managements to worry about now
07:01:17 <Cale> So, once GHC (and the default set of libraries which come with it) are installed, and you have cabal-install working, everything else can be installed as user from hackage.
07:01:28 <Gagis> gienah: yeah. In that case I might opt to waiting for the patch to be implemented in hackage
07:02:13 <Cale> The annoying thing is that Linux distributions (notably Debian and all its derivatives) split GHC into a million tiny fragments and so it's hard to be sure that you actually have a complete install of GHC.
07:02:17 <gienah> Gagis: by "vector option" I really mean "flag vector" in the vector.cabal file: http://hackage.haskell.org/packages/archive/hmatrix/0.11.1.0/hmatrix.cabal
07:02:47 <dcoutts> Cale: do they provide a hp meta-package?
07:02:49 <gienah> Gagis: guess I'll try forking hmatrix and try to upstream the patch, but I note there's an existing pull request with no comments
07:02:58 <dcoutts> Cale: if not users should lobby for one
07:03:04 <Cale> dcoutts: Maybe, though I don't want that either. I just want the stuff that GHC comes with.
07:03:16 <Gagis> Cale: yeah... I just installed gch6 and none of the other packages.
07:03:28 <Cale> (and I want it to be up to date, which is pretty hopeless :)
07:03:35 <dcoutts> Cale: over-approximating is easier than under-approximating
07:03:35 <Gagis> lessee if this works. Been years and years since I hit a dependency hell the last time. Extremely unpleasant.
07:03:52 <Cale> dcoutts: maaaybe. :)
07:04:31 <Cale> Gagis: It probably won't because you won't have things which are expected to come with GHC like network and mtl.
07:04:51 <Gagis> Cale: goddamnit. Would it be better to install all packages that start with libghc from apt then?
07:05:16 <Gagis> and hmatrix failed from hackage again. -_-
07:05:21 <Cale> Gagis: maybe, though that might include a bunch of stuff that you don't want.
07:05:37 <Cale> Seriously, I hate the Debian packages for GHC, and I don't use them for exactly this sort of reason.
07:05:52 <dcoutts> Gagis: presumably it failed because you're missing the C libs? did the error message suggest that?
07:06:08 <Gagis> I'd need that patch to make it work but the cost of bothering to patch and compile manually outweighs the benefit of learning hmatrix right now so I will give it another go when hmatrix has been properly patched
07:06:21 <dcoutts> Gagis: in which case installing ghc6-blah will not help, it's the blas/lpack/gsl C lib packages that you need
07:06:25 <gienah> Gagis: actually I upstreamed that patch earlier (was getting mixed up with another package)
07:06:30 <Gagis> dcoutts: its the same vector conflict again after I installed the c libs myself
07:07:05 <dcoutts> Gagis: ah ok, then that's a version problem with hmatrix and its Haskell lib deps
07:07:13 <Gagis> Yus.
07:07:54 <Gagis> gienah: ok then its just a matter of time then. Ill try again later and continue reading Learn You a Haskell for Great Good in the mean while
07:08:28 <gienah> dcoutts Gagis: vector 0.8 released today has a new instance not in vector 0.7, patch already upstreamed, this only happened some hours ago
07:08:43 <Gagis> gienah: ah. Ill run cabal update and try again right away
07:09:18 <dcoutts> gienah: you mean that hmatrix ought to build against an older version of the vector lib right?
07:09:40 <gienah> dcoutts: yes, or it should build without the vector flag
07:09:59 <Gagis> still fails. hmh
07:10:02 <dcoutts> Gagis: I'd try that then, rather than trying to use the latest of everything
07:10:23 <dcoutts> Gagis: since I think the hmatrix package is not updated too frequently, so trying slightly older versions of its deps is a better bet
07:10:42 <Gagis> alright. How do I downgrade the vector lib via cabal?
07:11:13 <Gagis> just cabal install vector-0.7?
07:11:34 <dcoutts> Gagis: right, for example:  cabal install hmatrix vector-0.7.0.1
07:12:24 <dcoutts> Gagis: specify them together like that and it'll build one against the other, the default policy otherwise is to pick the latest version and I think you already installed vector-0.8
07:12:59 <Gagis> giving it a try
07:13:29 <Gagis> it works! Thanks again!
07:13:57 <Gagis> does cabal have a metapackage for the whole haskell platform?
07:14:10 <dcoutts> yes, but it's not on hackage for boring technical reasons
07:14:48 <Gagis> would my system completely implode if I installed via apt-get I wonder...
07:19:26 <gienah> Gagis: I don't really know as I run Gentoo, but I guess that it would be necessary to remove all the cabal install'd packages, and then reinstall all the cabal install'd packages after that apt-get of haskell platform
07:20:14 <dcoutts> Gagis: cabal will see things installed by apt
07:21:45 <Gagis> rogel
07:21:52 <Gagis> *roger. Ill see how it goes
07:31:43 <Anpheus_> Yesterday or perhaps a couple days ago
07:32:04 <Gagis> It seems I managed to break my system so thoroughly that haskell-platform and cabal-install fail to install now -_-
07:32:05 <Anpheus_> I asked if one could have a syntax for nested f <$> x <*> y <*> z syntax, multiple contexts deep
07:32:49 <Anpheus_> A nested fmap is easy, but the <*> eluded me until I realized it was simply: (<*.>) = liftA2 (<*>)
07:33:26 <Anpheus_> (<$.>) = (<$>) <$> (<$>) --or fmap `fmap` fmap or fmap . fmap or... etc
07:33:30 <Anpheus_> (<*.>) = liftA2 (<*>)
07:33:49 <Anpheus_> then, (+) <$.> [Just 2] <*.> [Just 3, Nothing]
07:33:57 <Anpheus_> returns: [Just 5,Nothing]
07:34:48 <Anpheus_> To go "deeper" one merely needs to replace the first <$> or <*> with the previous nested one, for example: (<$..>) = (<$.>) <$> (<$>)  and (<*..>) = liftA2 (<*.>)
07:37:37 <Anpheus_> (<$.>) = liftA . liftA is also valid
07:37:55 <Gagis> gienah: yeah I tried that. Now cabal fails to update cabal-install. This is getting rather hilarious
07:38:18 <dcoutts> Gagis: what's the problem installing cabal-install?
07:38:38 <dcoutts> Gagis: if you installed cabal-install system wide then that one probably appears on your $PATH first
07:38:40 <byorgey> Anpheus_: yes, and see also the TypeCompose package on Hackage
07:38:45 <Gagis> it seems to be missing some files
07:38:59 <dcoutts> Gagis: what does it say?
07:39:13 <Gagis> yus. I have it system-wide from apt and now using as a user cabal install cabal-install
07:39:16 <Gagis> lemmecheck
07:39:32 <mjo-work> Is there a way to reuse variable definitions across two (or more) functions without creating them at the top level? What I'd like to do is e.g. let x=1, y=2 in <two unit tests>
07:39:38 <Gagis> Main.hs:73:7:
07:39:38 <Gagis>     Could not find module `Distribution.Verbosity':
07:39:38 <Gagis>       There are files missing in the `Cabal-1.10.2.0' package,
07:39:50 <byorgey> Anpheus_: the idea is that if we define  newtype O f g a = O (f (g a)), then the Applicative instance for O f g gives us exactly <$.> and <*.>
07:40:15 <dcoutts> Gagis: did you rm -r ~/.cabal or something ?
07:40:33 <Anpheus_> byorgey: Neat!
07:40:39 <Gagis> dcoutts: I did
07:41:23 <dcoutts> Gagis: so what you did was delete all the files of the registered packages, but not unregister the packages. Hence chaos ensues.  You want to rm -r ~/.ghc
07:41:25 <byorgey> so instead of  f <$.> x <*.> y  you can say  unO (f <$> O x <*> O y)
07:42:00 <Gagis> dcoutts: ahh. that explains it. I was expecting everything relevant to exist within one directory
07:50:48 <sohum> @pl \x -> foo x a b
07:50:48 <lambdabot> flip (flip foo a) b
07:55:03 * hackagebot OpenAFP 1.3 - IBM AFP document format parser and generator  http://hackage.haskell.org/package/OpenAFP-1.3 (AudreyTang)
07:55:16 <Gagis> Yeaahhh. hmatrix works now.
07:58:24 <gienah> Gagis: that's great
07:58:55 <kmc> mjo-work, (f, g) = let x=1; y=2 in (\a -> ... , \b -> ...)
07:58:59 <kmc> or similar tricks with 'where'
08:01:54 <Gagis> now to properly learn haskell so I can actually use it for something. I have a program written in uncommented fortran that I'd need to finish after its original developer fled. Came to a conclusion its probably easier to rewrite it myself in C++ instead of trying to figure out the fortran code but I could give Haskell a go with it instead.
08:02:22 <kmc> fortran is a much saner language than C++
08:02:49 <kmc> FORTRAN is, to this day, a good choice when you have a FORmula and you need it TRANslated to some blisteringly fast machine code
08:03:16 <Axman6> especially is you're a scientist who's never learnt anything else
08:03:46 <luite> hmm, I thought that fortran compilers were falling behind C these days
08:03:48 <Gagis> in this case writing it in C would probably be just so much easier. Hunting for bugs in code that lacks comments is not exactly pleasant when you could hide all that difficult stuff begind GSL
08:04:31 <Eduard_Munteanu> It probably won't matter much wrt C vs FORTRAN as long as you go through some optimized libs like BLAS, GSL etc.
08:04:32 <Gagis> I read trough a fortran manual for this project but otherwise I am unfamiliar with the language so there is no prior experience to make it easier
08:05:15 <Gagis> Yeah. Currently the code seems to have some custom algorithms for sparse matrices than I can not wrap my head around, but I think GSL already has implementations for those I could use easily
08:06:06 <Eduard_Munteanu> How much do you care about performance?
08:06:11 <Gagis> Anyways. Might be equally interesting to see how it works in Haskell.
08:06:17 <chenwl> @src liftM2
08:06:17 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:06:42 <Gagis> I have supercomputers at my disposal so as long as I can make the code paraller readability takes priority over speed
08:07:19 <sp3ctum_> plural of supercomputer? omg
08:07:23 <sp3ctum_> too awesome
08:07:27 <Axman6> spoken like a true person who doesn't understand parallelism :P
08:07:41 <Gagis> Well, that plural implies two and both are located in the same place :P
08:07:49 <sp3ctum_> :)
08:07:56 <Axman6> Gagis: where are they?
08:08:06 <Gagis> CSC
08:08:21 <Axman6> never heard of it
08:08:28 <Gagis> http://www.csc.fi/english
08:09:16 <sp3ctum_> hey is that where they have the 'ukko' machine?
08:09:31 <ezyang> When edwardk deprecated category-extras, did he move control.monad.either somewhere?
08:09:35 <Eduard_Munteanu> Note Haskell can be a bit problematic to optimize, at times.
08:09:47 <edwardk> yes
08:09:48 <edwardk> either
08:09:49 <Gagis> anyways. currently the algorithm is implemented so badly that if the code was more radable I could get significant speed gains just by adding more terms to a certain taylor series even if each matrix product becomes a bit slower
08:09:57 <edwardk> it only has the transformer though
08:10:04 <Gagis> sp3ctum_: I think so, or at least had. They have been updating their hardware recently
08:10:39 <ezyang> Wait, that's the transformer.
08:10:49 <flux> they recently gave one supercomputer away for a party that could say why they want it (or something)
08:10:55 <flux> never heard where it ended up in
08:11:08 <Eduard_Munteanu> But as long as you're content with mixing C and Haskell code it might be doable.
08:11:09 <benmachine> flux: does "because it would be so cool" count
08:11:15 <ezyang> Oh wait, Control.Monad.Instances grew an instance for either...
08:11:15 <chenwl> > liftM2 (+) [1] [2]
08:11:16 <lambdabot>   [3]
08:11:25 <sp3ctum_> Gagis, cool
08:11:35 <chenwl> > liftM2 (+) [1] []
08:11:36 <Gagis> Eduard_Munteanu: yeah. I am a bit worried about that but might be interesting to try nevertheless. I should be able to throw most of the heavy stuff to GSL via hmatrix anyways.
08:11:36 <lambdabot>   []
08:11:38 <flux> benmachine, I doubt it :). I think it was expected that you have some actual use for it :)
08:11:42 <benmachine> :(
08:11:44 <flux> (..and enough electricity..)
08:11:45 <benmachine> killjoys
08:11:54 <benmachine> pfft who needs electricity, I'd just hug it
08:11:56 <chenwl> > liftM2 (+) (Just 2) (Just 3)
08:11:57 <lambdabot>   Just 5
08:12:05 <sp3ctum_> :t liftM2
08:12:06 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:12:07 <chenwl> > liftM2 (+) (Just 2) Nothing
08:12:08 <lambdabot>   Nothing
08:12:11 <flux> maybe I could've used it for electrical heating
08:13:03 <Gagis> Yeah I looked into the offer. The amount of electricity you need would have made actually installing the computer somewhere rather expensive to do. You need surprisingly havy infrastructure for such a machine.
08:13:12 <dylukes> I'm having an issue with Cabal...
08:13:21 <dylukes> It installs alex/happy fine, but refuses to acknowledge them as installed.
08:13:25 <Eduard_Munteanu> Don't we all :P
08:13:30 <chenwl> @src (>>=) Maybe
08:13:31 <lambdabot> Source not found. :(
08:13:32 <dylukes> So it downloads/installs them every time I run cabal install on my project,
08:13:45 <dylukes> but there's immediately after a warning "could not satisfy dependencies"
08:13:50 <chenwl> @src (>>=)
08:13:50 <lambdabot> Source not found. Take a stress pill and think things over.
08:13:53 <benmachine> dylukes: are they on the PATH and etc.
08:13:53 <dylukes> and under cabal info Versions installed: [Unknown]
08:14:07 <benmachine> dylukes: cabal-install doesn't track installed executables
08:14:22 <benmachine> (it doesn't track libraries either, ghc-pkg does, and ghc-pkg isn't interested in executables)
08:14:29 <dylukes> they are in the PATH...
08:14:34 <dylukes> but then how do I have them as a dependency?
08:14:40 <dylukes> I want to depend on alex >= 3
08:14:40 <benmachine> build-tools?
08:14:40 <Axman6> i've been into the power supply room of a fairly large supercomputer, it surprised me how easy it is to just turn the power off...
08:14:43 <Eduard_Munteanu> What does   ghc-pkg list alex    say?
08:14:55 <dylukes> it just shows my package.conf.d's
08:15:05 <benmachine> Eduard_Munteanu: it wouldn't show anything, because alex is not a library
08:15:09 <dylukes> i.e, nothing
08:15:13 <Eduard_Munteanu> Ah.
08:15:23 <benmachine> dylukes: alex --version?
08:15:24 <byorgey> Axman6: that's in case it shows signs of becoming sentient
08:15:28 <dylukes> 3.0.1
08:15:42 <benmachine> dylukes: run cabal with -v3 to see if it can find alex?
08:16:07 <Axman6> byorgey: they did say they have 10 minutes of juice in batteries, so we've 10 minutes to save the world if it does happen
08:16:14 <byorgey> hehe
08:16:17 <dylukes> It's compiling alex again.
08:16:18 <dylukes> >_>
08:16:23 <dylukes> cabal: At least the following dependencies are missing:
08:16:23 <dylukes> alex ==3.0.1
08:16:27 <dylukes> I can't parse this massive -v3 dump
08:16:38 <int-e> Axman6: more seriously, if there's a fire or some other serious malfunctioning, you want to be able to turn of power quickly ... might save some hardware even.
08:16:51 <dylukes> !
08:16:52 <dylukes> selecting alex-3.0.1 (source) and discarding QuickCheck-1.0, 1.1.0.0, 1.2.0.1
08:16:52 <dylukes> and alex-3.0
08:17:02 <Axman6> there's a big lever you pull to basically flood the place with water too, heh
08:17:04 <dylukes> that's relevant
08:17:10 <benmachine> dylukes: wait, is alex in build-depends?
08:17:17 <dylukes> yeah...
08:17:19 <dylukes> should it be elsewhere?
08:17:23 <benmachine> build-tools
08:17:29 <benmachine> build-depends is for packages/libraries I think
08:17:44 <benmachine> although if cabal doesn't notice that it's a bit silly
08:18:22 <int-e> Axman6: heh, I wonder: can you do that while the power is on?
08:18:36 <Axman6> not sure, i didn't ask
08:19:08 <dylukes> https://gist.github.com/1178711
08:19:10 <dylukes> ;~;
08:19:16 * Eduard_Munteanu would have prefered "not sure, i didn't try" :)
08:19:41 <Axman6> well, i ran fast enough to miss the results
08:19:42 <dylukes> Easy to fix.
08:19:42 <benmachine> dylukes: ...
08:19:44 <dylukes> But that's new.
08:19:46 <benmachine> heh
08:19:56 <dylukes> Seems silly to have "haskell" as a build-depends :3
08:20:02 <dylukes> well of course it depends on it.
08:20:03 * hackagebot OpenAFP-Utils 1.3.1 - Assorted utilities to work with AFP data streams  http://hackage.haskell.org/package/OpenAFP-Utils-1.3.1 (AudreyTang)
08:20:05 <dylukes> hehe
08:20:08 <benmachine> well, you can choose which haskell to depend on!
08:20:15 <Eduard_Munteanu> I've seen cabal failing to build something but not stopping before.
08:20:18 <benmachine> 98 or 2010 or ghc's base
08:20:21 <parcs> @djinn (Monad m, Monad m1) => a -> m1 (m b) -> m a -> m1 (m b)
08:20:21 <lambdabot> f _ a _ = a
08:20:30 <dylukes> If we get a social Hackage 2.0,
08:20:36 <dylukes> then cabal needs to have new social features
08:20:39 <dylukes> Tumblr integration
08:20:42 <dylukes> Friends
08:20:42 <parcs> @djinn (Monad m, Monad m1) => (a -> m1 (m b)) -> m a -> m1 (m b)
08:20:43 <lambdabot> -- f cannot be realized.
08:20:46 <Eduard_Munteanu> Hackage+ ? :P
08:20:50 <byorgey> 'cabal tweet' ?
08:20:53 <dylukes> Cabal2.0: "See what your friends are compiling!"
08:21:03 <benmachine> parcs: don't think djinn does type classes very well
08:21:20 <benmachine> dylukes: I wish we could get the hackage done first :(
08:21:25 <dylukes> cabal tweet `g++ this_has_stl_errors.cpp`
08:21:28 <dylukes> -> message too long
08:21:32 <byorgey> parcs: I already showed you how to do that one, didn't I?
08:21:36 <Axman6> parcs: i don't think that can be realised for all monads (ie IO)
08:21:44 <Axman6> (ieieio)
08:21:52 <byorgey> it can only be done if m is Traversable
08:21:52 <applicative> dylukes, there is already equipment to have ghc tweet your type violations
08:22:03 <dylukes> XD
08:22:06 <dylukes> wonderful.
08:22:20 <int-e> Yeah you'd need some  m a -> m1 a  function to realise that.
08:22:29 <applicative> http://chrisdone.com/posts/2010-04-04-tweet-your-haskell-errors.html
08:22:44 <byorgey> no, just m (m1 a) -> m1 (m a)
08:23:05 * Eduard_Munteanu still wants hpaste + wgetpaste integration...
08:23:05 <byorgey> which is exactly what Traversable gives you
08:23:13 <mm_freak_> :t Data.Traversable.sequenceA
08:23:14 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
08:23:19 <dylukes> Question:
08:23:35 <dylukes> Can you form a Parr monad transformer, and then apply it to the ConcurrentIO monad?
08:23:42 <dylukes> For insane parallel nondeterminism?
08:24:02 <dylukes> er, ConcurrentIO extensions to IO
08:24:23 <dylukes> Is PArr an instance of Monad?
08:24:33 <dylukes> ;~'
08:25:33 <mm_freak_> why is (Either e) not an Alternative?
08:25:40 <mm_freak_> or a MonadPlus
08:27:04 <benmachine> mm_freak_: with what mzero?
08:27:13 <dylukes> Could someone recommend some example alex files?
08:27:14 <mm_freak_> oh, got it
08:27:19 <dylukes> i.e, one for lambda calculus would be great.
08:27:53 <dylukes> Additionally, is it possible to specify actual nested BNF style grammars? Or do I have to use start codes :<
08:28:01 <parcs> byorgey: you did?
08:28:23 <mm_freak_> benmachine: what about an Alternative instance for (Either SomeException)?
08:28:31 <mm_freak_> i think that could be somewhat sane
08:28:54 <mm_freak_> or even:  instance DefaultError e => Alternative (Either e)
08:29:06 <applicative> chrisdone mentions peyton jones's remark that some version of ghc would delete your source if it didn't typecheck
08:29:10 <benmachine> mm_freak_: not convinced
08:29:23 <benmachine> mm_freak_: imo you should just use the Maybe instance and some conversions
08:29:32 <applicative> he leaves out the best part: "users were very understanding"
08:29:57 <byorgey> parcs: yes, using Data.Traversable.Sequence
08:30:01 <mm_freak_> benmachine: problem is that it doesn't play well with my other instances
08:30:02 <int-e> byorgey: really? Can you show how?
08:30:16 <byorgey> I mean, you need an additional Traversable constraint of course
08:30:20 <nschoe> Hi Haskellers, I'm trying to understand some code which deals with monads transformers and I'm stuck (monads transformers are very new for me :/ ). Here: http://tinyurl.com/3hcv8k8 , in the loop function, on line 104 and 105 I understand why he uses ask: he is in the ReaderT AppConfig monad. But how come he can use "get" just on line 106, without using "lift get"?
08:30:21 <benmachine> mm_freak_: how so
08:30:21 <mm_freak_> benmachine: the functor i use here will be fixed throughout entire computations, but should be able to capture errors as well as multiple results
08:30:30 <int-e> byorgey: err, context:  (Monad m, Monad m1) => a -> m1 (m b) -> m a -> m1 (m b)
08:30:39 <benmachine> it's acutally pretty easy to switch between functors, I reckon
08:30:42 <benmachine> with the either/maybe functions
08:30:43 <int-e>   using  swap ::  m (m1 a) -> m1 (m a)
08:30:50 <nschoe> Because from what I understand, the "get" call is to get the state, but the state is in the inner monad, so he should use lift on it, no?
08:30:51 <kmc> nschoe, 'get' is a method in the MonadReader type class
08:30:51 <kmc> :t get
08:30:52 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
08:30:56 <kmc> er, ok, MonadState
08:31:12 <mjo-work> kmc: Got it to work, thanks.
08:31:15 <nschoe> kmc, yeah, precisely. That is bugging me so hard...
08:31:53 <benmachine> nschoe: the lifting is done automatically based on the type
08:31:56 <kmc> nschoe, and there are instances like:  instance (MonadState m) => MonadState (ReaderT r m)
08:32:13 <byorgey> @type let swap :: (Monad m1, Monad m2) => m1 (m2 a) -> m2 (m1 a); swap = undefined in \f m -> liftM join . swap $ liftM f m
08:32:14 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *) a1. (Monad m, Monad m1) => (a1 -> m1 (m a)) -> m a1 -> m1 (m a)
08:32:16 <kmc> instance (MonadState s m) => MonadState s (ReaderT r m) where { get = lift get; put = lift . put }
08:32:18 <kmc> http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/src/Control-Monad-State-Class.html
08:32:20 <byorgey> int-e, parcs: ^^^
08:32:38 <kmc> this is what mtl / monads-fd give you above transformers, basically
08:32:55 <parcs> neat
08:33:03 <byorgey> int-e, parcs: it is not possible to write swap for any monads, but it exists whenever m1 is an instance of Traversable
08:33:14 <nschoe> benmachine, so there *should* be a "lift get" here, but the compiler is intelligent enough to do it itself, is that right?
08:33:15 <byorgey> in which case it is called 'sequence'
08:33:41 <parcs> in this case it m1 is Traversable (Maybe) thanks!
08:33:42 <benmachine> nschoe: sort of. it's all done with type classes, as kmc says
08:33:53 <benmachine> it's not the compiler that's intelligent, it's the library writer :)
08:33:54 <nschoe> kmc, hum okay, but where? Is it a Haskell feature?
08:33:56 <benmachine> (well, both, ofc)
08:34:16 <byorgey> parcs: great! you're welcome
08:34:34 <kmc> nschoe, that instance is declared in the library 'mtl'
08:34:40 <kmc> see the link
08:35:41 <nschoe> Yeah okay, I see it.
08:36:17 <kmc> that's basically why 'get' is a type class method
08:36:30 <nschoe> So basically, it means that we almost never have to actually use lift? Only when we use smth like StateT over State itselft, is that right?
08:36:33 <kmc> it's not a special language feature though; just a consequence of how these type classes are defined
08:37:03 <benmachine> nschoe: yeah, or if you're using a custom transformer that doesn't have those instances
08:37:13 <benmachine> (you'd then write the instances using lift)
08:37:25 <kmc> more specialized monads usually don't have all their primitives shoved into a type class
08:38:05 <nschoe> Okay, I think I got it. The library designers have anticipated and created some instance which were likely to be common, right?
08:38:10 <kmc> the Parsec primitive parsers are Whatever -> ParsecT s u m t and not (MonadParsec p) => Whatever -> p a
08:38:25 <kmc> so if you were using ReaderT r (ParsecT s u Identity) t
08:38:27 <int-e> byorgey: Thanks!
08:38:28 <kmc> you'd have to use 'lift'
08:38:32 <nschoe> ok
08:38:41 <kmc> i'm skeptical of all this transformers business
08:38:50 <kmc> you should not have very much code that touches the individual layers of the stack, anyway
08:39:20 <kmc> if you're defining a new monad by composing some transformers, you should then define the domain-specific primitive operations of your new monad
08:39:28 <kmc> and hide the transformer stack from the rest of your code
08:39:55 <benmachine> kmc: I'm inclined to agree if you use it a lot, or in certain ways
08:40:00 <kmc> there's also a lot of cases where transformers are a net loss
08:40:14 <nschoe> Yeah I think I remembered reading something like that in RWH.
08:40:17 <benmachine> but sometimes transformers make your life easier
08:40:23 <kmc> in a lot of cases, ReaderT r IO a is going to be harder to use than r -> IO a
08:40:28 <kmc> yeah
08:40:47 * benmachine likes StateT s Maybe a as a crude parser
08:40:54 <kmc> my perspective is that for a long time i thought "i'm not smart enough to define my own monad; I'll use these transformers"
08:40:58 <benmachine> *StateT String Maybe String
08:40:59 <kmc> and the reality is opposite
08:41:06 <kmc> defining your own monad is really easy
08:41:11 <benmachine> oh
08:41:16 <nschoe> kmc, but then, if you use r -> IO a; how do you "pass" information which was in the Environement?
08:41:16 <benmachine> it was StateT String Maybe Exp, my bad
08:41:20 <kmc> and making all the transformers machinery work correctly is comparatively difficult
08:41:27 <kmc> nschoe, as a function parameter?
08:41:32 <kmc> @unmtl ReaderT r IO a
08:41:32 <lambdabot> r -> IO a
08:41:40 <kmc> it's just a wrapper for that
08:41:42 <kmc> @src ReaderT
08:41:42 <lambdabot> Source not found. That's something I cannot allow to happen.
08:41:56 <kmc> newtype ReaderT r m a = ReaderT { runReaderT :: r -> m a }
08:43:03 <nschoe> So, instead of doing env <- ask and then doing things with env, you would just do the same, but "fetching" env from the function's parameters?
08:43:27 <kmc> i don't really understand the question
08:43:41 <kmc> it's just a function
08:44:19 <kmc> i think functional programming is undervalued in the Haskell community
08:44:27 <hpaste> Accidus pasted “Free Monads” at http://hpaste.org/50759
08:44:31 <Accidus> I've used cabal to get the control-monad-free library, version 0.5.3.  The above code doesn't compile, but if you uncomment the instantiation, then it does. The two (obvious) uncommented lines were taken from the code in the documentation, which means that it's somehow missing in my version of it. So my questions are: 1. How do I find out whether it's just my local copy that's flawed? 2. Where do I report it?
08:44:35 * kmc runs to get his free monad
08:44:43 <Accidus> :D
08:45:00 <nschoe> Hum, sorry it's my fault. Actually I have trouble understanding Monads and MonadsT, I'm trying ot understand what they are for.
08:45:03 * hackagebot protocol-buffers 2.0.6 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-2.0.6 (ChrisKuklewicz)
08:45:05 * hackagebot protocol-buffers-descriptor 2.0.6 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  http://hackage.haskell.org/package/protocol-buffers-descriptor-2.0.6 (ChrisKuklewicz)
08:45:07 * hackagebot hprotoc 2.0.6 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-2.0.6 (ChrisKuklewicz)
08:45:09 <parcs> :t fmap join .: Data.Traversable.mapM
08:45:09 <lambdabot> forall (m :: * -> *) a (f :: * -> *) a1. (Monad m, Functor f, Data.Traversable.Traversable m, Monad f) => (a1 -> f (m a)) -> m a1 -> f (m a)
08:45:12 <dcoutts> Accidus: the .cabal file and the hackage page list the maintainer and bug report location
08:45:31 <nschoe> When I read RWH's talking about the State, Reader and Writer monad I thought it could be useful, but actually I have no idea how to use them.
08:45:32 <kmc> nschoe, monads aren't for one thing, Monad is the name of a generic API which lets you do lots of different specific things with different specific types
08:45:39 <Accidus> dcoutts, OK, so that's the second question answered
08:47:10 <Accidus> Actually, it answers both. The source listed under the .cabal dir is correct. It contains those two lines
08:47:20 <kmc> nschoe, i recommend reading LYAH's monad chapter and also _All About Monads_
08:47:30 <kmc> AAM has some errors / confusing stuff, but i found it helpful
08:47:31 <Accidus> But somehow the source used by my GHCi doesn't?
08:47:40 <nschoe> kmc, I read them both alreayd :/
08:47:42 <kmc> ok
08:48:14 <nschoe> And I understan their examples. But I don't know how to use them, nor when I should or should not.
08:48:23 <benmachine> nschoe: don't use them, then
08:48:30 <kmc> well, knowing when you should or shouldn't use a particular tool is always the hardest part, i think
08:48:47 <kmc> if you understand their examples of using monads, then presumably you do know how to use those monads, at least in narrow circumstances
08:49:00 <nschoe> benmachine, well they seem to be very present in Haskell, so if I don't use them at all, is it worth trying to learn Haskell at all?
08:49:17 <kmc> yes
08:49:20 <benmachine> nschoe: I think so
08:49:21 <kmc> haskell isn't about monads
08:49:23 <kmc> fuck that noise
08:49:25 <benmachine> :)
08:49:48 <kmc> if you're looking for an excuse not to learn haskell, this is a good one (and a common one)
08:49:52 <kmc> but it's not actually a valid reason
08:49:59 <nschoe> kmc, Yes, but this is the problem: in narrow circumstances only. If I'm trying to code a tic tac toe, should I use them? Should I use State to keep trakc ofthe grid and hte positions? I really have no clue when to use them :/
08:50:00 <benmachine> but I more meant, if you write haskell without using monads, you might start recognising patterns where you repeat yourself
08:50:09 <benmachine> and then you'll go, "#haskell, how do I make this nicer"
08:50:10 <kmc> you'll pick up on where monads are useful
08:50:10 <byorgey> nschoe: if you keep using Haskell you will eventually figure out how/when to use them.
08:50:16 <benmachine> and then we go "you can use a thingy here"
08:50:21 <benmachine> and you go and read about thingies
08:50:25 <benmachine> and then you've learnt something
08:50:57 <benmachine> monads and many other things arose to address problems; it's kinda hard to understand the solution until you've had the problem
08:51:27 <benmachine> I never learnt about how to test haskell code until one day I needed to
08:51:32 <benmachine> and then I did
08:51:46 <ezyang> Any /r/haskell moderators around?
08:52:05 <nschoe> Yeah okay, but how will I know I'm going to need monads?
08:52:45 <nschoe> I mean, monads are designed to make things easier, so that means it's possible not to use them at all. So what if i stuggle with ugly code that could be solved easily with monads?
08:53:10 <kmc> then you ask us
08:53:10 <ovrskr> go for the low-hanging fruit
08:53:14 <kmc> or you read some other similar code
08:53:30 <kmc> also it's not like monads in general solve a particular problem
08:53:37 <kmc> State solves one problem, Maybe another, Reader another
08:53:40 <kmc> [] another
08:53:45 <kmc> they don't have all that much in common
08:54:07 <ovrskr> What I realised is with Haskell I just have to throw aside what I know of programming
08:55:00 <nschoe> kmc, yes, that's right. Only, Haskell code is so elegant when I read from people who are good, and mine is so ugly. I am just looking for a way to improve this.
08:55:24 <kmc> yep
08:55:28 <kmc> there's not an easy answer
08:55:37 <kmc> you have to read and write lots of code
08:55:40 <byorgey> nschoe: the way to improve is to write some code, then ask in here about ways to improve it
08:55:41 <kmc> do that for about 5 years
08:56:31 <kmc> i studied Haskell off and on for 4 or 5 years before I thought I was actually good at it
08:56:36 <cheater> 5 years or or until your facial expression reaches o_ꙮ
08:56:42 <kmc> that's longer than any other language i've learned, even C++
08:56:44 <kmc> haha cheater
08:56:44 <sm> I would add: and read lots of good code for ideas.. something I don't do enough of. There's a great list on stack overflow.
08:56:47 <mistertim_> hey all - possibly dumb question, is it not possible to define a type synonym including a class constraint, eg: "type VolatilityFunction :: (Floating a) => a -> a"? Thanks in advance ' :-)
08:57:02 <kmc> mistertim_, the problem is that 'a' is not mentioned on the left-hand side
08:57:03 <nschoe> yes I guess so. But I was trying to do the LazyFoo tutorials in Haskell. When I came with something then watched the code from snkkid on github,  I was like "Wow, never thought of using a ReaderT over a StateT over IO" -_-
08:57:10 <kmc> is it supposed to be for all a? for some specific unknown a?
08:57:25 <kmc> i'm not too keen on ReaderT over StateT over IO
08:57:27 <byorgey> mistertim_: it is possible,  type VolatilityFunction a = Floating a => a -> a   ought to work
08:57:30 <mistertim_> kmc: forall a actually, in this ircumstance
08:57:37 <mistertim_> aha yep - I see how that would work
08:57:38 <sm> morning all. Does anyone have/know something good for aggregating feeds, like a miniplanet ?
08:57:42 <mistertim_> thanks guys!
08:57:46 <benmachine> byorgey: I'm not sure that always does what you want
08:57:46 <kmc> data VolFunc = VolFunc (forall a. (Floating a) => a -> a)
08:57:47 <ovrskr> When in doubt, unsafeCoerce!
08:57:47 <kmc> in GHC
08:57:52 <Accidus> Hmm... Is it likely that there is a mismatch between the compiled package on cabal and the accompanying source?
08:57:57 <kmc> but this may not actually be what you want
08:58:00 <kmc> bbl
08:58:04 <nschoe> kmc, so, you think he overdid it?
08:58:10 <kmc> maybe.  hard to say out of context
08:58:21 <benmachine> Accidus: cabal updated recently?
08:58:29 <Accidus> Yes, last week I think.
08:58:41 <benmachine> if this is an edwardk package, update again :P
08:58:50 <edwardk> which one?
08:59:02 <nschoe> okay. Well thanks all for your answers. I'll forget about that for now. I'll use function parameters instead and see how it goes.
08:59:16 <edwardk> i've been pretty sedate lately
08:59:16 <benmachine> edwardk: is control-monad-free yours?
08:59:28 <benmachine> oh
08:59:29 <benmachine> no it isn't
08:59:29 <benmachine> k
08:59:32 <edwardk> nah. mine is 'free'
08:59:39 <benmachine> right
08:59:44 <benmachine> that's not the problem then
09:00:00 <benmachine> Accidus: what do you mean by the compiled package on cabal?
09:00:04 <edwardk> 'control-monad-free' kind of conflates the construction and deconstruction, making it largely useless
09:00:35 <kamaji> How could I make a list of all possible types of an Enum?
09:00:37 <Accidus> The one under ~/.cabal/lib/control-monad-free-0.5.3/ghc-6.12.1/Control/Monad/Free.hs
09:00:43 <Accidus> Sorry, Free.hi
09:00:51 <kamaji> so like data Foo = One | Two | Three deriving(Enum)
09:01:02 <kamaji> how do I get [One,Two,Three]
09:01:11 <kamaji> or should I use bounded
09:01:15 <byorgey> kamaji: if you also derive Bounded, you can say [minBound .. maxBound]
09:01:28 <kamaji> ah ok
09:01:35 <kamaji> coolbeans!
09:01:35 <byorgey> there is no way to do it using just Enum
09:01:59 <kamaji> oh ight, it doesn't define bounds
09:02:01 <edwardk> accidus: well, i'd email pepe and say its busted and mention what version of ghc you're using
09:02:01 <byorgey> note that Integer is an instance of Enum =)
09:02:22 <Accidus> Ok. Is there a way to locally recompile a package?
09:02:42 <Axman6> :t [toEnum 0 ..]
09:02:43 <lambdabot> forall a. (Enum a) => [a]
09:02:43 <edwardk> sure you can just cabal unpack it locally to some folder, go in and play around with it
09:02:56 <Accidus> ok, will do that.
09:02:58 <Accidus> cheers
09:03:21 <Axman6> > [toEnum 0 ..] :: [Bool]
09:03:22 <lambdabot>   [False,True]
09:03:23 <byorgey> Axman6: huh, what do you know
09:03:50 <Axman6> not guaranteed to work though...
09:04:06 <byorgey> probably always works in practice, but not guaranteed by the standard, right
09:04:21 <Cale> Accidus: and then if you want to reinstall it after modification, just 'cabal install' with no extra parameters from the directory with the .cabal file in it will install.
09:04:21 <Axman6> :t toEnum
09:04:22 <lambdabot> forall a. (Enum a) => Int -> a
09:04:31 <Axman6> Int!
09:04:37 * Axman6 -> sleep
09:04:42 <Cale> Yeah, I hate that Int.
09:04:50 <Accidus> Cale, will reinstall install the modified package or the unmodified one?
09:04:58 <Cale> the modified one
09:05:21 <byorgey> 9223372036854775807 constructors ought to be enough for anyone ;)
09:05:42 <augur> edwardk!
09:05:45 <edwardk> 'cabal install' when you're in a directory which contains a .cabal file will just build the local copy of the package
09:05:50 * edwardk hides.
09:05:57 <augur> what was special about your monadic parsing library above the applicative parsing libraries out there?
09:06:18 <augur> i mentioned it to a friend but i couldnt remember why you wanted monadicity on top of applicativity
09:06:44 <copumpkin> it gives you context-sensitivity
09:07:05 <augur> oh right
09:07:14 <copumpkin> his library provides lots of stuff on top of conventional monadic parsers, though
09:07:40 <byorgey> although edwardk explained to me once how Applicative + general recursion gives you a limited form of context-sensitivity anyway
09:07:47 <byorgey> I forget the details
09:07:57 <edwardk> yeah i mentioned it to augur, hence his desire to just use applicatives
09:08:09 <augur> edwardk: my desire to use applicatives? :X
09:08:12 <edwardk> the limitation is you have to have a finite alphabet
09:08:19 <byorgey> ah, right
09:08:25 <augur> infinite alphabets! thats another one
09:08:30 <edwardk> not really a huge limitation in practice
09:08:48 <edwardk> but the efficiency consideration is pretty big
09:08:57 <byorgey> yeah, I was just going to ask about that
09:10:15 <edwardk> anyways trifecta offers a lot of non-traditional parsing functionality. built-in syntax highlighting, colored errors, seeking in the input stream, its adding automatic ctags/etags file generation, html pretty printing like hscolour
09:10:56 <edwardk> static analysis of the applicative fragments, dyck language skeleton recognition so i can do things like parse parenthesized fragments in parallel
09:11:16 <edwardk> adding a common c preprocessor, layout, etc.
09:11:37 <luite> whoah
09:11:42 <luite> batteries and kitchen sink included
09:11:44 <edwardk> basically all the stuff you want for parsers for real languages used by humans
09:11:49 <edwardk> yeah
09:11:58 <edwardk> rather than having everyone reinvent the wheel
09:12:30 <luite> yeah that's a good idea
09:12:33 <edwardk> it also includes a bunch of extra stuff like charsets for all the standard unicode and posix character classes, etc.
09:13:36 <edwardk> i've also been working on adding support for typeahead so when you use the parser interactively in a readline like setting it can do tab completion for arbitrary grammars
09:14:05 <edwardk> and then there is the clang-style diagnostics, etc.
09:14:50 <edwardk> optimizations for utf8 and the ascii special case, factoring out most of the parsec combinators to only need applicative, compatibility with transforming the parser via MTL, etc.
09:14:55 <edwardk> i guess it is quite a list by now
09:15:54 <edwardk> i need to write a haskeline clone though, because the current one doesn't do everything i need in order to be able to highlight the line you are typing
09:16:40 <edwardk> augur: other than that, not much
09:17:13 <edwardk> augur: or should i say 'from a linguistic perspective, nothing'
09:17:25 <kamaji> oh weird... System.Random.Shuffle says "Non-exhaustive patterns in function extractTree"
09:18:50 <kamaji> What should the second argument be?
09:19:00 <djh__> exit
09:19:56 <Accidus> Interesting. So now the installed file definitely contains the right instantiation, but I still need to add it for the file to compile
09:20:04 <Accidus> * the installed package
09:20:42 <augur> edwardk: well i wasnt explaining it for linguistic reasons :p
09:20:53 <augur> a friend was just wondering why monadicity
09:21:15 <edwardk> augur: 9 parts easier context sensitivity, 1 part syntax.
09:21:21 <augur> :P
09:21:29 <edwardk> accidus: which instance?
09:21:44 <Accidus> See here:
09:21:44 <Accidus> http://hpaste.org/50759
09:22:01 <Accidus> The code, as is, doesn't compile, unless you uncomment those two lines
09:22:20 <Accidus> But those two lines are taken from the Control.Monad.Free package source
09:22:36 <Accidus> Lines 127 or so
09:23:44 <edwardk> accidus: which ghc version?
09:23:54 <edwardk> accidus: builds fine here
09:23:54 <Accidus> 6.12.1
09:24:00 <edwardk> hrmm
09:24:06 <edwardk> i don't have 6.12.1 to test on
09:24:18 <Accidus> Do you have an earlier or later version?
09:24:22 <edwardk> later
09:24:24 <edwardk> 7.0.3
09:24:31 <Accidus> Would I mind upgrading?
09:24:38 <edwardk> upgrading should be fine
09:24:48 <edwardk> what are you using that needs control-monad-free anyways?
09:24:58 <Accidus> so I should just cabal upgrade ghc?
09:25:07 <Accidus> I'm modelling free monads
09:25:21 <edwardk> i'd just go download the latest version of the haskell platform
09:25:24 <edwardk> there is the 'free' package
09:25:40 <edwardk> which i would argue (being biased, as it is mine) is a better presentation ;)
09:26:39 <Accidus> I'm not biased towards any of them. Control.Monad.Free was the first I came across.
09:27:12 <edwardk> try to build free and let me know if you have any problems
09:33:01 <Accidus> edwardk, I'm confused. Your free monad transformer is the free construct itself?
09:33:17 <edwardk> yes
09:34:27 <edwardk> data Free f a = Pure a | Free (f (Free f a))
09:35:11 <ion> Hmm. Isn’t that Mu with additional Pure?
09:35:33 <Accidus> Ah, right. So that's where the extra Free gone to.
09:35:46 <ion> @src Mu
09:35:46 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
09:35:59 <ion> Ah, not quite.
09:36:31 <Accidus> Hmm... Ubuntu only has version 6 in the repos.
09:37:42 <ion> Oh, wait. I’m being confused. It *is* the same. Right? :-P
09:39:17 <Accidus> If Mu is the fixed-point operator, then it can be obtained from this definition by feeding in the identity monad and the empty type
09:40:02 <byorgey> no identity monad needed.  Just  Mu f = Free f Void
09:41:22 <joe6> i am generating some files of a cabal package. Is it possible to integrate cabal with a Makefile?
09:41:34 <joe6> or, embed some shell commands into cabal?
09:43:56 <dmos> Any opinions/thoughts on the "Functional Pearl: Implicit Configurations" and the implementation of it in the reflection package? Is it being used in practice? Has it been superseded by something else?
09:50:56 <edwardk> dmos: i use it a lot, and no, that is the current implementation
09:51:24 <edwardk> dmos: i actively maintain it and keep it up to date with changes in ghc
09:52:20 <dmos> edwardk: great. The article spells out pretty much the exact problem I ran into, so I'm interested in trying it out.
09:52:44 <dmos> edwardk: is there any public code somewhere that puts it to use in a more involved setting?
09:53:07 <edwardk> dmos: hrmm, let me see, the precision package does but thats not released yet.
09:53:37 <edwardk> https://github.com/ekmett/precision/blob/master/Numeric/Rounded/Precision.hs#L79
09:55:02 <edwardk> I use it in parallel parsers as well, also mostly not released. The monoids package used it back in 0.1.37 but I dropped the modular arithmetic monoid
09:55:12 <edwardk> hrmm
09:55:24 * dmos votes for http://hackage.haskell.org/trac/hackage/ticket/576 (to get reverse dependencies on hackage)
09:55:56 <elliott> Aww man; I thought I had a fun hack, but it turns out that optimisations break my unsafeCoerce-based trickery. :/ (Who'da thunk it?)
09:55:57 <hpaste> elliott pasted “Evil” at http://hpaste.org/50760
09:56:03 <elliott> At least it works in GHCi.
09:56:18 <dmos> edwardk: thanks, I'll have a look at that.
09:56:19 <elliott> Although actually I was running "main" from GHCi too, so I'm not sure why it doesn't work there.
09:56:31 <elliott> Any unsafeCoerce experts who can explain it? ;-)
09:56:31 <augur> edwardk: can you link me again to your monadic parsing stuff?
09:57:32 <edwardk> http://81.26.216.99/~roel/cgi-bin/hackage-scripts/package/reflection shows no reverse dependencies
09:57:54 <edwardk> https://github.com/ekmett/trifecta with docs here: http://ekmett.github.com/trifecta/
09:59:26 <edwardk> fixed-precision used to use it before i realized that hmpfr was horribly broken.
09:59:37 <edwardk> precision will subsume that old use case
10:00:01 <dmos> edwardk: ah, tried to resolve the hackage mirror via url, didn't work, didn't know the IP.
10:00:24 <edwardk> dmos: its a well kept secret ;)
10:04:02 <dmos> edwardk: would you recommend the implicit configurations approach as a replacement for Reader/ReaderT when nothing else forces you to use a monad? The use case I'm looking at is static/dynamic configuration very similar to xmonad which uses a ReaderT XConf to solve it.
10:04:34 <elliott> implicit configurations are gross... at least in implementation
10:05:03 <dmos> earlier on #haskell I was made aware of the fact that using monad stacks get awkward with all the lifting.
10:05:28 <tgeeky> dmos: check out the paper about monad zippers?
10:05:46 <elliott> dmos: What disadvantages are there to Cale's (st -> IO a) solution?
10:05:48 <tgeeky> dmos: http://users.ugent.be/~tschrijv/Research/papers/monad_zipper_draft.pdf
10:06:03 <tgeeky> oops, wrong link!
10:06:10 <tgeeky> http://users.ugent.be/~tschrijv/Research/papers/virtual_monad_stack.pdf
10:07:06 <dmos> tgeeky: ah, another good paper I have to dig through. thanks.
10:07:18 <Cale> I don't really like the term "monad stack"
10:07:32 <elliott> dmos: I think you might be overthinking your simple state problem, if I am perfectly honest :-)
10:07:50 <Cale> but I have trouble explaining exactly why I dislike that term
10:08:08 <elliott> Cale: Maybe because monad transformers aren't really very consistent or composable?
10:08:09 <Cale> Perhaps because it gives the impression that there's a bunch of independent monads stacked on top of each other
10:08:10 <tgeeky> well, you can only be hedging on the term 'stack'
10:08:12 <tgeeky> since monad is a given
10:08:15 <Cale> But there are not.
10:08:19 <elliott> It's more like a monad tangle.
10:08:29 <c_wraith> tangle.  Yes, that's appropriate
10:08:31 <Cale> Monad transformer stack, sure.
10:08:37 <dmos> elliott: I'm actually pretty sure that you're correct, but the thing is that what I'm currently doing are trial runs for a larger project, so I will run into these problems anyway.
10:08:38 <Cale> (or composite)
10:08:39 <tgeeky> a monad metric
10:08:49 <tgeeky> a monad mash
10:09:03 <hiiii> Hi
10:09:15 <hiiii> I got a question concerning the use of $
10:09:15 <tgeeky> ... hello
10:09:21 <tgeeky> ok.
10:09:28 <elliott> dmos: If you don't want a function, I'd go for the equivalent ReaderT -- I mean, this is functional programming, solutions don't come simpler than making it a function :)
10:09:29 <tgeeky> there's a pretty good stackoverflow about that, I'll find it while you ask
10:09:37 <hiiii> why does this work: ($ 3) (4+)
10:09:49 <tgeeky> :t ($3) (4+)
10:09:50 <lambdabot> forall a. (Num a) => a
10:09:50 <Cale> dmos: I recommend sticking with parameter passing until it really becomes completely unbearable for some reason, and then think about what the reason is in a more precise way.
10:10:01 <elliott> hiiii: well, ($ 3) is the same as (\f -> f $ 3)
10:10:07 <elliott> (4+) is the same as (\x -> 4+x)
10:10:22 <elliott> (\f -> f $ 3) (\x -> 4+x) → (\x -> 4+x) $ 3
10:10:27 <tgeeky> elliott: is his question really one about sectioning?
10:10:35 <elliott> → 4+3 → 7
10:10:39 <elliott> tgeeky: I dunno, let's find out
10:10:40 <Cale> dmos: Threading one parameter down to various things tends not to really be all that inconvenient in practice, and it reveals more about the structure of your program to do it (in particular, which bits are configuration-dependent and which are not)
10:10:49 <elliott> hiiii: It may help to understand that $ is just a normal infix operator
10:10:56 <elliott> It just doesn't do much interesting
10:10:59 <hiiii> ok got it ty
10:11:07 <elliott> tgeeky: Apparently so :)
10:11:14 <dmos> Cale: interesting viewpoint.
10:11:15 <hiiii> I was confused because of this; Prelude> :t ($)
10:11:15 <hiiii> ($) :: (a -> b) -> a -> b
10:11:30 <hiiii> since the first parameter to $ must be a functionion und we passed a 3
10:11:37 <dmos> Cale: I agree that hiding it too much can be counterintuitive.
10:11:44 <ion> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi?expr=%28%243%29+%284%2B%29
10:11:47 <elliott> hiiii: Yeah, but it's actually the second parameter there -- just like you  can say (*9) for (\x -> x*9)
10:11:48 <permagreen> Lazy evaluation is fun
10:11:48 <benmachine> hiiii: you don't actually pass it its first parameter though
10:12:06 <ion> hiiii: See the link above.
10:12:20 <elliott> Cale: Yeah, I found the article that was pretty popular a while back pretty convincing on that matter -- maybe dmos wants to read it. I don't have a pointer to it, though...
10:12:46 <hiiii> thx
10:12:49 <applicative> ($3) means applyToThree, as (+1) means increment
10:12:50 <elliott> (It was making the point that a "global reference" is basically introducing an unjustified dependency into all your code; passing around global state everywhere is obviously the same thing.)
10:12:59 <elliott> :t (+1)
10:13:00 <lambdabot> forall a. (Num a) => a -> a
10:13:07 <elliott> hmmph
10:13:14 <hiiii> ion, nice site
10:13:16 <elliott> negative literals are so inconsistent :(
10:13:19 <hiiii> *bookmark*
10:13:40 <benmachine> hiiii: that's my site, actually
10:13:48 <benmachine> hiiii: you have to keep in mind it's only good for some things
10:13:49 <hiiii> good work
10:13:51 <benmachine> sometimes it lies :P
10:13:53 <tgeeky> ion: doesn't hpaste do the same?
10:13:56 <benmachine> well, it's not finished
10:14:05 <benmachine> tgeeky: yeah, chrisdone made it into a library and integrated it
10:14:41 <tgeeky> curiosly, it doesn't work here
10:14:42 <tgeeky> http://hpaste.org/steps/50761?expr=%28%243%29+%284%2B%29&submit=Submit
10:14:43 <elliott> Oh, here it is; dmos: http://lukepalmer.wordpress.com/2011/05/20/the-whole-program-fallacy/
10:15:10 <elliott> dmos: That makes an IMO compelling case that you /want/ to see your state being explicitly passed around in the function arrow.
10:15:19 <dmos> elliott: very nice, thanks.
10:16:37 <applicative> that post, or rather the SO question seemed a bit unreal.  The only case of the alleged crime was one module in the jhc source
10:17:16 <applicative> (admittedly the author of the jhc might be thought someone to emulate.)
10:17:27 <zefciu> Hi: I just asked a question on SO. Could you help me? http://stackoverflow.com/questions/7233873/is-it-worth-to-create-a-pure-graphics-library-for-haskell
10:17:47 <tgeeky> zefciu: it's always worth it to put as much code in the pure region as possible, as far as I understand it
10:18:04 <laker> hello, are there any useful books about writing a compiler for a functional language
10:18:07 <laker> except the SPJ ones
10:18:10 <elliott> zefciu: you are likely to be interested in Gloss, Pan, and Fran
10:18:17 <Cale> zefciu: Yes, and various people have done that in various ways.
10:18:33 <elliott> (fran iirc being the original development of FRP?)
10:18:38 <applicative> zefciu: one could do with more graphics libraries, but what is wrong with say Gloss or Diagrams?
10:18:46 <elliott> oh yeah, diagrams too
10:19:11 <zefciu> applicative: nothing is wrong
10:19:18 <zefciu> I simply didn't know about it
10:19:36 <applicative> zefciu: sorry, really i mentioned them to get clearer on your idea.
10:20:10 <applicative> zefclu, oh you should check them out. have you seen the web interface for gloss that cdsmithus put up?
10:20:22 <zefciu> applicative: Don't be sorry. Probably the answer to my question is "it is already done"
10:20:34 <tgeeky> zefciu: probably not, it's hard
10:21:06 <tgeeky> actually, reading your post (instead of your IRC text)
10:21:11 <tgeeky> it's probably done with Diagrams
10:21:11 <applicative> zefciu, well I wouldnt say that, there is a lot of ferment on the topic, a lot of disatisfaction, so it's by no means silly to say "i want a new graphics library"
10:22:04 <applicative> zefciu: one perpetual nightmare is the different platforms, of course
10:23:26 <applicative> zefciu: here's the link to cdsmithus http://cdsmith.wordpress.com/2011/08/23/haskell-for-kids-week-2/
10:24:42 <applicative> oh and the web server thingy  http://dac4.designacourse.com:8000/
10:25:53 <applicative> (I just note them as amusing, or charming; he uses the gloss library.)
10:27:10 <zefciu> Ok, thanks for guiding me to Gloss and Diagrams. I will checke them.
10:27:14 <zefciu> *check
10:27:50 <tgeeky> I was just about to ask "Why did he make gloss, when Diagrams exists?" but then I saw that link
10:28:01 <applicative> what was the answer?
10:28:19 <tgeeky> native animation support
10:28:30 <tgeeky> i mean, it's probably not the answer he would give, but it's something Diagrams doesn't have yet
10:28:31 <erus`> who is the muscliest haskeller?
10:28:36 <applicative> yes, supposed to be forthcoming in diagrams if I remeber
10:28:48 <tgeeky> in the sense that it's a wanted feature
10:28:52 <tgeeky> not in the sense that someone is doing it
10:29:28 <applicative> the transition to animation is amazingly simple in gloss.
10:29:47 <tgeeky> I really want to wrap d3.js as a backend to diagrams
10:29:54 <tgeeky> since d3.js has a wonderful model for animations
10:30:15 <erus`> gloss animations are like 2 fps, right?
10:30:26 <tgeeky> erus`: hehe, probably on a bad machine yes
10:30:46 <erus`> am i thinking of some serverside service?
10:30:54 <applicative> there doesn't seem to be anything wrong with them, speaking as a perceiving organism
10:31:05 <tgeeky> they work, they are just choppy
10:31:19 <tgeeky> maybe it's because the timestep is slower than 30/s
10:31:48 <applicative> erus` cdsmithus site, linked above, does some indirection, it couldnt be the same.
10:32:51 <erus`> yeah i daw that one on reddit
10:33:03 <erus`> needs some javascript animation thing
10:33:14 <erus`> because < 5 fps is a slideshow
10:34:04 <applicative> the kids around here didn't think it was a slideshow when we got their names doing goofy piroutes around each other
10:34:16 <applicative> using cdsmithus's site
10:36:49 <elliott> erus`: not possible with Gloss' types (I suggested symbolic compilation when it game up)
10:36:51 <elliott> came up
10:37:03 <applicative> hah, but it slow, if you care to think about it.  found the text we finally settled on.... http://hpaste.org/50762
10:37:22 <erus`> i feel sorry for these kids who learn functional programming and then look for a job in the real world :(
10:37:33 <c_wraith> Bah.  What should I do about instances for the package I'm maintaining?
10:37:33 <erus`> maybe by the time they come of age things will be different
10:37:39 * Dashkal is doing functional programming in the real world
10:37:43 <elliott> they'll never experience the wonderful delights of writing CRUD ruby on rails applications
10:37:45 <elliott> :'(
10:37:50 <elliott> we have truly robbed them
10:38:22 <c_wraith> In particular, instances that would be useful, but aren't an important part of what my package does.
10:38:48 <applicative> erus` when 8 year olds learn 'functional programming', they are learning the idea of definition, and precise expression.  I don't feel sorry for such children
10:39:41 <c_wraith> things like NFData and Binary.  They're useful, but not in the slightest related to the implementation.  I don't really want to add dependencies on their packages just to add instances for them.
10:39:54 <applicative> i do feel sorry for children who learning the going imperative languages, unless by chance they become professional programmers
10:39:55 <tgeeky> i don't feel sorry for anyone who has access to any education, especially good education
10:40:42 <c_wraith> I think the more people who recognize that imperative programming is a bad model for some things, the better.
10:41:05 <tgeeky> c_wraith: does 'some things' mean humans (with our rather crappy memories)?
10:41:33 <c_wraith> tgeeky: nah.  After all, haskell has a large imperative programming subsystem.  It's useful for certain things.
10:41:48 <c_wraith> tgeeky: describing operations that should happen in a particular sequence is one of them.
10:41:59 <tgeeky> c_wraith: I like the idea that I can grab some code, look at the type signatures, and understand that it's not going to fire ze missiles
10:42:39 <c_wraith> what if you want to fire the missiles?  Isn't it important that you can make that decision?
10:42:48 * applicative somehow manages to fire missiles whenever he uses IORef inside ghci
10:42:58 <tgeeky> hell no, I'm not to be trusted with such a decision
10:43:03 <applicative> :)
10:43:08 <zomg> unsafeFireZeMissiles
10:43:12 <c_wraith> fire smaller missiles. :)
10:43:19 <c_wraith> maybe nerf ones
10:43:22 <tgeeky> hehe.
10:43:46 <tgeeky> I'm the kind of idiot that hurts himself with plastic sporks and laser pointers.
10:44:07 * applicative has found his double
10:44:11 <zomg> Your laser pointer is clearly in violation of safety regulations =)
10:44:48 <tgeeky> i got a green laser pointer the other day
10:44:51 <tgeeky> that sucker is bright!
10:45:23 <c_wraith> warning: do not look into laser with remaining eye
10:45:32 <applicative> dont let it fry your optic nerve
10:45:44 <Cale> Warning: In case of implosion, look directly at implosion.
10:45:51 <tgeeky> hehe
10:45:53 <zomg> Ordering something that isn't your standard "point it at your eye and it does nothing" laser pointer would probably just end up being confiscated at the customs office here =)
10:45:59 <brisingr> Warning: in case of warning, obey warning
10:46:25 <elliott> fix: in case of Ftack overflow
10:46:28 <elliott> ..ftack
10:46:28 <tgeeky> I was using it to point to treetops at night, to get my dog to look up more
10:46:53 <ion> You can replace the eye you destroyed with… a laser pointer!
10:46:54 <applicative> when I lived in los angeles, whenever there was an earthquake out at see, people would rush to the santa monica pier to see if a tsunami was coming....
10:46:57 <zomg> fhtagn overflow
10:47:11 <applicative> sea for see
10:47:48 <tgeeky> Warning: In case of tsunami WARNING, see for sea for yourself.
10:48:51 <tgeeky> the hour or two of footage I saw of the Japan tsunami really scared me, honestly. It's eerie how the water just keeps flowing in
10:49:51 <c_wraith> yeah...  tsunamis aren't one huge killer wave.  They're water just rising and rising.  Less dramatic, but honestly more damaging.
10:50:11 <tgeeky> yep. I was thinking about the comparison to the Vermont river floods from yesterday.
10:50:33 <tgeeky> at least when water comes in torrents you can hear it.
10:50:45 <tgeeky> With the tsunami, you didn't hear anything except the sound of buildings smashing into each other in the water
10:51:13 <tgeeky> oh, going back up, re "monad stacks", etc
10:51:31 <tgeeky> using the biological cell analogy
10:51:45 <tgeeky> [pure code] | cell membrane | [impure world]
10:51:54 <tgeeky> which SPJ used a few times...
10:52:06 <tgeeky> monads are membranes, right?
10:52:15 <Cale> rofl
10:52:54 <Cale> inb4 spacesuit analogy
10:53:18 <tgeeky> hey, you learn by analogy too
10:53:20 <tgeeky> like it or not :)
10:53:24 <applicative> tortillas are kind of like membranes, so I guess os
10:53:28 <applicative> so
10:53:57 <elliott> I don't remember learning an analogy for monads.
10:54:10 * applicative had his first monad-transformer 'monad comprehension' today.
10:54:11 <tgeeky> that doesn't matter
10:55:33 * applicative wrote his first such comprehension, rather
10:55:43 <Cale> tgeeky: I know, I know, but there are a lot of very poor analogies.
10:55:46 <tgeeky> elliott: analogy is a core learning mechanism, and even bad analogies are good
10:55:56 <Cale> Bad analogies are bad.
10:56:01 <tgeeky> Cale: yes, but even bad analogies are good sometimes.
10:56:05 <Cale> Because they waste your time.
10:56:07 <tgeeky> Cale: see: Bohr model of the atom.
10:56:17 <tgeeky> It's a good analogy because one can study why it's wrong.
10:56:25 <applicative> the trouble with monad analogies, is that they being "a monad is like ...." when a more complicated subject is needed.
10:56:32 <applicative> they begin
10:56:49 <tgeeky> applicative: true, and I'm not looking to write one, I'm just wondering :)
10:56:55 <elliott> monad analogies are not really like models.
10:56:56 <tgeeky> cell membranes are very intricate things
10:56:59 <applicative> a bind analogy might be a better start.
10:57:01 <elliott> they're just bad learning techniques.
10:57:08 <Dashkal> I learned Monads via multiple analogies, followed by the pure explanation.
10:57:20 <tgeeky> elliott: the bohr model *is* an analogy
10:57:21 <Cale> Atoms are kind of like membranes right? ;)
10:57:28 <tgeeky> it's the analogy of an atom behaving like a solar system
10:57:36 <Dashkal> I'm not sure I could have learned via one analogy alone, and I definitely couldn't have on the pure definition alone (had to ground it to existing knowledge somehow)
10:58:07 <tgeeky> Dashkal: that's almost the definition of what an analogy is. existing knowledge -> new inputs -> new knowledge
10:58:09 <applicative> well the diagrams in a category theory account are in the nature of analogies.  "A monad is like a pair of pointy lines"
10:58:24 <tgeeky> applicative: yep.
10:58:29 <permagreen> That explains everything!
10:58:38 <Cale> A monad is like a monoid
10:58:46 <tgeeky> Cale: I want to read more about that
10:58:50 <Dashkal> Right now I'm struggling with Categories.  I can grasp the base definition well enough, but I haven't yet found a way to ground it to anything else I know.
10:59:00 <tgeeky> it's like a monoid where each association is explicitly stated?
10:59:03 <applicative> which has been aptly characterizes on the taco salad analogy
10:59:06 <Cale> Except that sets have been replaced by endofunctors, and Cartesian product by composition
10:59:50 <Cale> Well, to do this justice, let's be explicit :)
10:59:53 <applicative> 'a monad is a taco salad of endofunctors, ..."
11:00:01 <tgeeky> speaking of taco salad, I'm hungry.
11:00:28 <Cale> A monoid is ordinarily a set M together with an associative binary operation: M x M -> M
11:00:40 <elliott> a monad is like a monoid, except instead of a monoid, it's a monad
11:00:44 <elliott> hope this helps
11:00:54 <tgeeky> Cale: the reason I brought up the 'cell membrane' analogy is that cell membranes (with various ion channels as type constraints, perhaps) might be an interesting direction to flesh out said analogy
11:00:54 <Cale> and that operation has a unit, which in order to talk about it in a categorical way, we'll make it into an arrow from a one element set 1
11:01:01 <Cale> So we have:
11:01:11 <Cale> m: M x M -> M
11:01:13 <Cale> e: 1 -> M
11:01:15 <tgeeky> since we have reason to believe there are some universal channels, and some specific channels, and some shared channels
11:01:42 <applicative> wait, first Cale then membranes
11:01:48 <tgeeky> yeah, I'm listening to him
11:01:59 <tgeeky> Cale: the unit is *not* the monoid unit, right?
11:02:11 <Cale> This unit is the monoid unit
11:02:19 <tgeeky> damn it. the catsters said it wasn't :(
11:02:19 <Cale> e: 1 -> M
11:02:24 <Cale> huh?
11:02:32 <Cale> Oh, maybe you're thinking of a different video
11:02:43 <Cale> when they talked about the monad whose algebras are monoids
11:02:52 <Cale> (which is the same thing as the list monad)
11:02:54 <tgeeky> i think i'm talking about Monads 3a
11:03:10 <Cale> yeah
11:03:14 <Cale> that's something else
11:03:27 <Cale> We're not going to look at monad algebras here
11:03:48 <Cale> Just formalise monoids in an arrow-theoretic way, and then generalise to a more arbitrary category
11:03:59 <Cale> and then re-specialise our generalised monoids
11:04:35 <tgeeky> so we've got: m which keeps M (binop) M -> M
11:04:43 <Cale> So, our monoid consists of a set M with two functions m and e, and we have associativity, which is normally written:
11:04:45 <tgeeky> and e which brings everything into M 1 -> M
11:05:01 <Cale> m(a,m(b,c)) = m(m(a,b),c) for all a,b,c in M
11:05:36 <Cale> but if we want to write that in terms of maps and not elements, we say m . (id x m) = m . (m x id)
11:05:51 <tgeeky> ok, that makes perfect sense
11:06:01 <Cale> and unit laws
11:06:45 <tgeeky> so we've got:  (unit), (assoc), m, e
11:07:10 <tgeeky> and fmap
11:07:21 <Cale> no fmap
11:07:23 <Cale> this isn't a functor
11:07:28 <Cale> It's just some sets and functions
11:07:42 <tgeeky> ok.
11:08:49 <ion> Is this anywhere near what “a monad is a monoid in the category of endofunctors” means? If not, how *would* that be written as a Haskell Monoid instance? newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }; instance (Monad m, a ~ b) => Monoid (Kleisli m a b) where { mempty = Kleisli return; mappend (Kleisli a) (Kleisli b) = Kleisli (a >=> b) }
11:09:20 <Cale> the unit laws, btw, look like  m . (e x id) = l, where l is the isomorphism 1 x M -> M
11:09:38 <Cale> and m . (id x e) = r, where r is the isomorphism M x 1 -> M
11:09:39 <thoughtpolice_> edwardk: oh, btw, if you're around, dunno if you noticed but trifecta *almost* builds on 7.2. it seems it's a bit more strict about an instance decl and wants FlexibleInstances enabled as a result.
11:09:57 <Cale> Now, once we can write things down like this, we're going to generalise
11:09:57 <edwardk> yeah
11:10:00 <edwardk> which instance was it?
11:10:05 <Cale> So instead of sets and functions
11:10:09 <edwardk> i have a patch i was half way through writing
11:10:21 <Cale> we're going to have objects of a more arbitrary category, and arrows between them
11:10:25 <edwardk> so i'm hoping to push that out. i think it includes the instance in question
11:10:28 <edwardk> just want to make sure
11:10:36 <tgeeky> Cale: -> #haskell-in-depth?
11:10:39 <Cale> sure
11:10:47 <thoughtpolice_> edwardk: the Source instance for String in Text.Trifecta.Diagnostic.Rendering.Prim
11:11:00 <edwardk> yeah, thats been fixed
11:11:05 <edwardk> i just need to push it
11:11:05 <thoughtpolice_> coolio
11:12:40 <mdwright_laptop> I have an IO Bool, is there someway I can use that as a function guard?
11:12:50 <edwardk> i was making a few downstream dependency shifts to remove a lot of names from Text.PrettyPrint.Free, which has made the current patch bigger than i wanted
11:13:24 <elliott> mdwright_laptop: It starts with unsafePerform
11:13:29 <elliott> (it ends with IO)
11:13:37 <elliott> (and then has a little sticky note attached to it saying "don't")
11:13:48 <edwardk> mdwright_laptop: you shouldn't.
11:13:55 <dafis> "really, don't"
11:14:06 <edwardk> mdwright_laptop: you can however, break up your function into two steps so that you can
11:14:36 <elliott> dafis: it's a fractal sticky note
11:14:37 <edwardk> mdwright: make a function foo :: Bool -> IO whatever and put the guard on that
11:14:51 <mdwright_laptop> edwardk: Ah.
11:14:53 <mdwright_laptop> Thanks everyone :)
11:14:55 <edwardk> mdwright_laptop: then make your other function (>>=) that
11:15:45 <elliott> mdwright_laptop: you could just use if/then/else though :P
11:15:47 <elliott> or when/unless
11:20:06 * hackagebot largeword 1.0.1 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  http://hackage.haskell.org/package/largeword-1.0.1 (DominicSteinitz)
11:35:01 <lysgaard> I'm trying to make my first Cabal package, and i get a duplicate definition for symbol error. Sounds familiar to anyone?
11:41:00 <Blackheart_> Give me a homework question.
11:42:06 <Blackheart_> ...going
11:42:20 <Blackheart_> ...going
11:42:33 <Blackheart_> ...gone.
11:43:29 <elliott> Blackheart_: what's two plus two
11:43:47 <Blackheart_> Five. Next.
11:43:55 <dafis> before or after taxes?
11:44:09 <Blackheart_> During. Next.
11:44:18 <elliott> Blackheart_: what's haskell
11:44:30 <Blackheart_> A kind of curry. Next.
11:44:48 <dafis> How many linguists do you need to change a lightbulb?
11:45:27 <Blackheart_> Phonetically, to.
11:45:39 <Blackheart_> Next.
11:45:48 <dafis> good call
11:45:52 <coppro> Blackheart_: What is not the answer to this question?
11:45:55 <Cale> Blackheart_: Find a generating series for the number of triangles with integer sides with respect to perimeter.
11:46:09 <Blackheart_> coppro: I don't know. Next.
11:46:19 <coppro> Blackheart_: incorrect
11:47:06 <Blackheart_> Cale: You win.
11:47:39 <tech2> coppro: yellow?
11:47:40 <ksf> does anyone use vim haskellmode with cabal, painlessly?
11:48:06 <coppro> Cale: you mean for integers a, b, c where a + b + c = n and a^2 + b^2 = c^2?
11:48:16 <coppro> *positive integers
11:48:31 <Cale> not right angled triangles
11:48:32 <dafis> coppro: no, any triangles with integer sides
11:48:33 <ksf> what's missing most is grabbing the -package options out of the configuration.
11:48:36 <Cale> arbitrary triangles
11:48:40 <coppro> oohh
11:48:43 <coppro> derp
11:49:07 <Blackheart_> Is it a Diophantine problem?
11:50:39 <Cale> There's a nice way to decompose any such triangle into a bunch of applications of a couple of operations to the (1,1,1) triangle.
11:51:46 <Cale> and from there you can just count how many ways there is to do it to obtain a perimeter of n
11:52:18 <ttvd> what does map fib [0 ..] !! mean? specifically !! part?
11:52:19 <Cale> (which has a nice generating series form)
11:52:32 <Cale> !! is list indexing
11:52:36 <ttvd> oh right, thanks
11:52:38 <Cale> xs !! n is the nth element of xs
11:52:40 <ttvd> sorry for stupid question
11:52:41 <ttvd> nod
11:53:10 <Cale> btw, !! is slow, though maybe not as slow as some implementations of fib :)
11:53:17 <ttvd> lol yah
11:53:29 <ttvd> i am reading about memoization http://www.haskell.org/haskellwiki/Memoization
11:53:37 <Cale> yeah
11:53:58 * Cale checks to see if that page talks about Data.MemoCombinators
11:54:21 <Cale> http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.1/doc/html/Data-MemoCombinators.html
11:54:29 <Cale> ^^ this library is really cool
11:55:12 <Cale> It makes very careful use of the property that lazy evaluation will cause any parameter to a function to not be evaluated more than once in order to memoise arbitrary functions.
11:56:04 <monochrom> finding Memo :)
11:56:08 <Blackheart_> When I hear such things ("careful") I wonder if it is not as much an abuse as imperative commands.
11:56:10 <Cale> You can memoise a function f :: Bool -> a as follows:   memoBool f = cond (f True) (f False) where cond t f True = t; cond t f False = f
11:56:47 <Cale> because f True and f False are arguments to cond, they will be evaluated at most once
11:58:06 <Cale> Data.MemoCombinators makes use of fundamentally that trick, and a similar trick for memoising lists of values of a memoisable type to memoise almost anything (anything which can be turned into a sequence of bits, anyway :)
11:58:52 <Cale> er, I should say "memoising functions of lists of a memoisable type"
11:59:04 <Cale> list :: Memo a -> Memo [a]
11:59:04 <Cale> list m f = table (f []) (m (\x -> list m (f . (x:))))
11:59:04 <Cale>     where
11:59:04 <Cale>     table nil cons [] = nil
11:59:04 <Cale>     table nil cons (x:xs) = cons x xs
12:01:07 <Cale> http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.1/doc/html/src/Data-MemoCombinators.html -- the whole thing is tiny and pure (but takes careful thinking to understand properly)
12:13:09 <ocharles> Hey, I have a question about how to model a sort of abstraction. I have a 'Book' type, which is an instance of the Entity type class, which provides the 'addVersion :: Book -> InDatabase Book' function. This is essentially inserting a book into the database, but copying all foreign key references to the new Book.
12:13:33 <ocharles> This is ok, but at the moment addVersion book does 2 things: it adds a new book version, and copies all 'author roles' over to the new book
12:13:48 <ocharles> But editions also have 'author roles', so I was wondering how I could abstract that out
12:14:18 <ocharles> Book and Edition are both instances of the 'HasRoles' type class, so I was hoping I could make use of that so that addVersion could do what I want without having to glue in an extra function there
12:14:38 <ocharles> In other languages, I might solve this problem with traits, mixins or roles - what does haskell have?
12:17:49 <ocharles> It has to create the book version first though, because that's where the new author roles need to be copied too, so I'm thinking an explicit function call is my only real option
12:18:12 <ocharles> addVersion orig = newVersion orig >>= copyRolesFrom orig >>= etc...
12:18:36 <ocharles> I guess I'm just a bit bugged that addVersion :: Edition -> InDatabase Edition will have to have that too
12:19:34 <edwardk> ocharles: making some kind of class AddVersion t where addVersion :: t -> InDatabase t seems to be what you are getting towards
12:19:49 <ocharles> edwardk: I have that, the Entity type class
12:20:26 <ocharles> I'm saying that for things that are instances of the  HasRoles  type class, there is also part of a definition for the addVersion  function in that class though
12:21:45 <ocharles> I'm trying to guarantee that if something is an instance Entity and HasRoles, then you can be sure that it will copy the author roles over correctly
12:23:11 <edwardk> ah, there you are probably out of luck, since you can't really force code-reuse between them
12:23:28 <ocharles> shoot
12:27:04 <ocharles> I can get close with a bit of type magic, but I don't know quite where (or even if I can) plumb it in. if  newVersion :: HasRoles a => Book -> (StillRequires a Book)  and addVersion :: Book -> InDatabase Book, then I'll be forced to compose with copyBookRoles :: Book -> StillRequires a Book -> InDatabase Book
12:27:30 <edwardk> messy
12:27:44 <ocharles> and pointless, if the initial Requires a Book thing can't be automatically derived
12:30:31 <ocharles> edwardk: I might try this at SO and see what people suggest there, but before I do - I'm just curious what you think is messy about the StillRequires approach, so I can outline cons when I explain my problem
12:31:12 <ocharles> to me it's a con that: it's not clear what the start is (only the final type), and it forces composition in a certain order (when there are more mixin-type functions)
12:32:47 <edwardk> just that it has a lot of names floating around for capturing invariants
12:43:32 <ocharles> Hmm. I guess another option is using QuickCheck to assert that invariant is true
12:44:49 <ocharles> forall HasRole a, Entity a. roles originalEntity == roles (newVersion originalEntity) -- if you look past more poor syntax :)
12:51:14 <wires_> does anyone know the status of some kind of virtualenv for haskell / cabal?
12:51:34 <bos> wires_: cabal-dev
12:51:56 <wires_> sweet!
12:52:21 <wires_> can it deal with different ghc's?
12:52:27 <bos> yep
12:52:39 <wires_> dope
12:52:49 <ocharles> well, if anyone is interested in my above question in more detail, it's http://stackoverflow.com/questions/7235630/how-to-promote-code-reuse-in-a-manner-similar-to-mixins-method-modifiers-traits-i :)
12:53:36 <absence> is there any way to do cooperative multitasking in haskell, i.e. something like yielding to another "thread" (synchronously) in the middle of e.g. a fold or map, or is that the wrong way of thinking in a functional language?
12:53:55 <kmc> probably the wrong way of thinking
12:53:57 <copumpkin> why would you want to is the first question
12:54:06 <kmc> with pure functions why do you care about threads?
12:54:11 <zmv> ooooo////////
12:54:17 <kmc> if you're just after parallelism, you can transparently evaluate on multiple cores without using explicit threads
12:54:20 <wires_> parallism
12:54:34 <kmc> read about par and pseq and Control.Parallel.Strategies
12:54:44 <kmc> if you want the semantics of cooperative multitasking, you might want the semantics of continuations instead
12:54:48 <wires_> maybe regarding i/o? like doing a join
12:55:00 <kmc> you're not doing IO in the middle of a fold or a map
12:55:19 <kmc> in IO you can use GHC's lightweight preemptive threads
12:55:24 <wires_> true, .. what about in map over monad?
12:55:29 <wires_> whatever you call it
12:55:33 <kmc> mapM_
12:55:36 <wires_> (not doing much io lately)
12:55:45 <kmc> :t mapM_ (forkIO . ?f)
12:55:46 <lambdabot> Not in scope: `forkIO'
12:56:00 <kmc> basically, it's important to distinguish parallelism from concurrency
12:56:31 <absence> i'm not after parallelism, quite the oposite really. i'm not used to functional languages and trying to learn haskell, so my thinking is probably very imperative. in e.g. c++ i would have one "thread" that continually runs a loop that does stuff, and another "thread" that occasionally changes the state of the first "thread" and waiting otherwise
12:56:52 <kmc> Haskell is a good language for concurrent imperative programming
12:56:53 <copumpkin> absence: ah, we definitely avoid that kind of pattern
12:56:55 <absence> i say "thread" because they're not actually threads that run in parallel, but fully serial
12:56:58 <kmc> so you could translate that code directly
12:57:03 <absence> (cothreads is the right term i guess)
12:57:04 <kmc> but it's probably not the best way to solve this problem in Haskell
12:57:15 <kmc> i think you should back up another step or two :)
12:57:43 <wires_> so i'm thinking, you want to do calculation in parallel with some i/o where you are waiting for input, once input is received you want to continue the calculation
12:57:53 <wires_> how would that work?
12:57:57 <absence> okay :) so what is the right way to implement something like this?
12:58:46 <copumpkin> absence: what's the higher-level goal?
12:58:51 <wires_> absence: i believe the above
12:58:53 <copumpkin> you've told us how you'd implement it normally
12:58:59 <copumpkin> but you haven't told us what "it" is
12:59:56 <kmc> oftentimes, laziness gives you this kind of incrementalism for free
13:00:10 <absence> in general it's a system to handle events for a continually running system. specifically it could be a synthesizer. there's a continually running audio engine that generates samples, but occasionally you want to change its parameters in response to midi data
13:00:38 <kmc> i'd use imperative style for that in Haskell
13:00:41 <absence> it could also be used for visual stuff
13:00:47 <kmc> in fact have done similar things
13:00:54 <kmc> the alternative is probably FRP, which is a big interesting active research field
13:01:28 <hiptobecubic> perhaps this isn't the right room to say this, but that sounds like a better fit for erlang's model
13:01:39 <kmc> Haskell is great for imperative programming when your problem fits that style.  the "radical" thing about Haskell is that it doesn't force you to use that style for everything
13:01:51 <hiptobecubic> granted i've barely written anything non-trivial in either
13:02:01 <kmc> erlang has big advantages over existing Haskell implementations in systems distributed across many machines
13:02:17 <kmc> otherwise, both support huge numbers of lightweight threads with message passing etc
13:02:26 <absence> another way of describing the problem is that there are several contexts that the program switches between at various points
13:02:33 <kmc> Erlang may have better support for real-time stuff
13:03:29 <absence> the low-level primitives used by the c++ implementation swaps the stack pointer and saves/restores the registers when you yield to a different "thread" (or rather, context)
13:04:20 <absence> hm.. you say "fit a modell" in regard to erlang, does that mean something else than generic functional programming?
13:04:30 <kmc> that's a popular approach in C++ because pthreads are expensive in resources, and also insanely difficult to use
13:04:36 <kmc> in GHC Haskell real preemptive threads are easy and cheap
13:04:53 <absence> kmc: well, it's very important that the threads aren't preemptive in my case
13:04:59 <kmc> for realtime reasons?
13:05:11 <absence> kmc: none of them must run simultaneously, only in serial
13:05:21 <absence> kmc: for correct timing
13:05:39 <monochrom> use synchronization primitives like MVar for that
13:05:41 <absence> kmc: e.g. you want something to happen at sample position 10574 this audio frame
13:05:53 <copumpkin> http://www.haskell.org/haskellwiki/Shootout/Thread_ring
13:08:27 <monochrom> hrm? if you know it has to be sample position 10574, you won't even context-switch. you just loop over "if sample position is 10574 then X else Y"
13:09:07 <absence> kmc: hm, i think maybe continuations may be something to look at
13:09:08 <monochrom> I thought you context-switched because you couldn't predict some events
13:11:02 <absence> monochrom: one thread could run code like "do something; wait 1244 samples; do something else; wait 5421 samples; do more", while the audio engine is executed during the waits for the specified number of samples
13:11:15 <absence> sorry, one CONTEXT
13:11:22 <absence> and there could be any number of them
13:12:00 <absence> so there's also some kind of scheduler that sorts and keeps track of everything, and calls the audio engine where it should
13:16:52 <kmc> it seems wrong to equate "time when code runs" with "timestamp for the sample produced by code"
13:17:15 <monochrom> alright then, you could fuse everything into one single loop, or you could make them separate threads, it's up to you
13:17:38 <kmc> rather, you have some constraints on the relation between the two
13:17:45 <monochrom> threads are not preemptive if you use synchronization primitives wisely
13:17:52 <kmc> the code must run before the sample is required and at most n ms before
13:18:40 <kmc> absence, this isn't a great problem for solving with only functional programming
13:18:50 <kmc> however it's a fine problem for Haskell, because Haskell supports much more than just functional programming
13:20:31 <dylukes> So, I'm getting this obnoxious warning in Alex generated code.
13:20:32 <dylukes> https://gist.github.com/1179396
13:20:46 <dylukes> Is there a OPTIONS_GHC flag I can suppress it with?
13:21:07 <dylukes> -w is not even disabling it :<
13:21:15 <dylukes> I have { {-# OPTIONS_GHC -w #-} } in the .x file
13:21:59 <Blackheart_> Try adding !.
13:22:15 <dafis> to alex
13:23:31 <dylukes> ...?
13:23:36 <monochrom> if -w is not enough, I don't know what is. check that no one is adding -W or -Wall behind your back. (conceivably some self-righteous build tools do)
13:23:40 <dylukes> Blackheart_: It's alex generated code.
13:25:09 <Blackheart_> Ah, OK.
13:25:45 <Blackheart_> Trying adding ! to a bug report.
13:26:00 <monochrom> also check that you do get {-# OPTIONS_GHC -w #-} in your generated files and it is at a right place
13:26:40 <parcs> dylukes: 2>/dev/null
13:26:50 <monochrom> haha
13:26:52 <dylukes> parcs: :P
13:27:16 <dylukes> Yeah, it gets inserted properly
13:32:06 <dylukes> Really annoying.
13:36:55 <navaati> hello
13:37:05 <zachk> hi
13:38:24 <edwardk> shapr!
13:39:22 <navaati> does exist a type (preferably in the standard lib) for tables (like "a 10x20 table", i don't know if it's the right english word)
13:39:31 <navaati> ?
13:40:12 <copumpkin> navaati: I'd use repa
13:40:16 <dafis> navaati: arrays?
13:40:19 <copumpkin> or data.array
13:40:36 <dafis> Data.Array
13:41:19 <dschoepe> navaati: Do you want something where the size is part of the type?
13:42:12 <dschoepe> navaati: If so, I don't think there are any widely-used implementations of that, since Haskell doesn't have dependent types to do something like that comfortably.
13:42:49 <navaati> repa seems good, thanks
13:43:44 <navaati> no, i don't need it (well, i would appreciate it but as you say i know it require dependent types)
13:44:31 <navaati> jeu de la vie
13:44:39 <navaati> (oops wrong window)
13:46:27 <navaati> Data.Array is easy to use but there is no garantee that all lines have the same length
13:47:12 <parcs> does hReady work for stdin?
13:49:45 <dylukes> monochrom: I can suppress it with -funbox-strict-field
13:49:47 <dylukes> :\
13:50:09 * hackagebot swapper 0.1 - Transparently swapping data from in-memory structures to disk  http://hackage.haskell.org/package/swapper-0.1 (RomanSmrz)
13:50:22 <monochrom> that is probably like adding !'s for you rather than suppressing warnings
13:50:49 <dylukes> Yeah...
13:50:50 <dylukes> but it works :3
13:51:58 <monochrom> I personally am not keen on killing every possible warning. Haskell Platform itself, half of the packages in there have warnings when built
13:55:12 <absence> kmc: been looking at continuations, couldn't that be used?
13:56:11 <absence> kmc: when one thread wants to wait, it calls the continuation with the number of samples to wait as the argument?
13:56:27 <kmc> could work
13:56:36 <kmc> that's still not "pure functional programming" though
13:56:40 <kmc> "wait n milliseconds" is an IO action
13:57:26 <absence> sort of
13:58:00 <tech2> why is waiting an IO action? Hell, why is waiting a monadic operation at all?
13:58:31 <Dashkal> It requires interaction with the outside world.  In this case, a clock.
13:58:33 <Jeanne-Kamikaze> because it requires interaction with the outside world ?
13:58:41 <kmc> this is kind of a fuzzy area
13:58:42 <Jeanne-Kamikaze> :/
13:58:47 <kmc> but "monadic" is not relevant at all
13:58:51 <absence> kmc: you don't have to think of it as a wait though. instead of "wait 1234 samples", it's really "generate 1234 samples before continuing at this point again"
13:59:00 <kmc> the fact that IO is a monad is irrelevant to how IO works
13:59:18 <kmc> absence, *nod*
14:00:08 <tech2> ah, ok, the clock bit makes sense. Thanks. I figured that since the result may not change (the function has the same result, only the time taken to produce it changes) that conceptually it didn't make much sense to me. THanks.
14:00:40 <absence> so when the thread wants to "wait", it calls the continuation passed to it, ends up in the scheduler, which causes the right number of samples to be generated (possibly interfacing with other threads meanwhile), and then calls the thread that requested the wait's continuation to return to the point where the wait for 1234 samples was requested
14:00:45 <absence> i think :D
14:00:51 <absence> this all causes my head to spin slightly
14:01:21 <kmc> tech2, the result of (putChar :: Char -> ()) would not change either
14:01:23 <kmc> but it has a side effect
14:01:54 <kmc> it *is* fuzzy, though, because you can construct pure computations that take more or less time, and then observe the time they take as an IO action
14:02:10 <kmc> so it's weird to say you can't construct a pure computation which takes n seconds exactly
14:02:24 <tech2> kmc: right, but delaying execution of a function appears to be side-effect free, until I realised that I'd have to read from the clock (IO on an external entity) to work out how long to delay.
14:02:49 <copumpkin> times :: IO [Time]
14:02:53 <copumpkin> an inifinite lazy stream of times!
14:02:54 <copumpkin> ;)
14:02:54 <kmc> but you can argue that goes in the category of "IO implementation with pure interface"
14:02:58 <kmc> copumpkin, .... that's brilliant
14:03:05 <kmc> that needs to be an Acme package now
14:03:05 <copumpkin> seems very useful
14:03:08 <copumpkin> lol
14:03:20 <parcs> so it seems getChar blocks hReady stdin.. that is quite unexpected
14:03:22 <copumpkin> I'll leave that to you
14:03:36 <monochrom> you can construct a pure computation that takes n seconds exactly if you were the computer, which, since it's a pure computation, it's much butchered by the optimizer, and you have a pure computation that takes exactly 0 seconds on a real computer
14:04:25 <kmc> in practice, in GHC Haskell it's very easy to create a value of type () whose evaluation takes 5 seconds + a little bit
14:04:30 <kmc> and not that problematic to do so
14:04:45 <kmc> but you might run into problems with optimizations, more or less sharing than you expected, etc
14:05:09 <navaati> (and a nice 100% cpu load, i guess)
14:05:15 <thoughtpolice_> tech2: generally speaking, if you have a pure computation, you can do unlimited CSE/inlining, and you can replace pure computations with their result without changing semantics. in this regard, replacing '2*2' with '4' is an optimization, but, say, given 'wait :: Int -> ()', replacing 'wait 200' with () is a *bug* - same with the putChar example kmc gave
14:05:34 <tech2> thoughtpolice_: thanks :)
14:05:50 <kmc> thoughtpolice_, but we also consider eliminating sharing with inlining to be a bug
14:06:00 <kmc> and that's just a question of how long evaluation takes
14:06:52 <kmc> GHC already has to be careful that "let y = f x in y+y" doesn't turn into "f x + f x"
14:06:56 <thoughtpolice_> heh, indeed. you're right it's a very fuzzy area
14:07:05 <kmc> you could require it to be careful about explicit delays too, without totally wrecking the idea of pure fp
14:07:10 <thoughtpolice_> yeah, GHC is super conservative about CSE because of things like that
14:07:27 <kmc> it will do it when it can bound the increase in work, i think
14:07:30 <thoughtpolice_> since it'll lead to basically unacceptable loss of sharing
14:07:34 <kmc> "Secrets of the GHC Inliner" is an interesting paper
14:08:01 <thoughtpolice_> it is a good one. i wonder how accurate it is now considering the inliner's had some overhauls.
14:08:05 <thoughtpolice_> it's from '99 or so, IIRC
14:08:16 <monochrom> Harry Potter and the Secrets of the GHC Inliner
14:08:59 <prototrout> Just curious: what does "sharing" mean in this context?
14:09:08 <thoughtpolice_> you're a haskell programmer, harry!
14:10:24 <thoughtpolice_> prototrout: in the example kmc gave, which is 'let y = f x in y+y', you are 'sharing' the result of 'f x' among two halfs of the computation. so the result of 'f x' is computed once and 'shared' by later computations. but the loss of sharing would effectively be changing that to 'f x + f x' - which will compute 'f x' twice
14:11:20 <navaati> if i write "f x + f x" in my code, will sharing happen ? that is, is ghc able to optimize this ?
14:11:22 <tech2> He probably got that scar from headbutting the keyboard after trying to work out what the error messages actually _meant_ in his first year.
14:11:23 <prototrout> thoughtpolice_: Ah, got it.
14:11:31 <thoughtpolice_> sharing/no-sharing is not an issue of semantics, but of how long evaluation of some particular expression takes. but sometimes the loss of sharing due to 'optimizations' by the compiler can be unacceptable. consider that example, what if 'f x' took a really long time?
14:12:12 <JSON> ive been looking into haskell for doing extremely fast real time calculations
14:12:13 <mauke> navaati: "sharing" is not (always) an optimization
14:12:21 <brisingr> presentation's done, I'm back home
14:12:23 <ion> let f :: Enum a => a -> a; f = Debug.Trace.trace "f" . succ; x :: Integral a => a; x = 42; y :: Integral a => a; y = f x in y+y :: Integer
14:12:30 <thoughtpolice_> navaati: GHC will do CSE in certain cases to 'recover' things like that, but it's very conservative about CSE, because sharing is not always a good thing
14:12:31 <brisingr> as promised, the talk
14:12:48 <kmc> sharing is a time/space tradeoff
14:13:05 <brisingr> http://goo.gl/AfsdQ
14:13:05 <kmc> it's also a loss for time alone if you create a thunk and only use its value once
14:13:15 <JSON> bris whats that
14:13:21 <kmc> but i'd be interested to see a short example where sharing is bad
14:13:37 <ion> :set -XNoMonomorphismRestriction, > let f = Debug.Trace.trace "f" . succ; x = 42; y = f x in y+y
14:13:52 <absence> kmc: if the audio engine is used to render audio to a wav file instead of playing back with a sound card, then e.g. ten seconds isn't ten seconds in the real world anymore, as generating ten seconds of audio data could take half a second. not sure if that's what you meant with the io stuff?
14:14:11 <kmc> yeah, then it sounds basically like a pure function
14:14:25 <kmc> cool brisingr
14:14:29 <tessier> Anyone recall the name of that library for generating graphs based off of a text file input? I've seen people do some really cool stuff with it but can't remember the name now...
14:14:40 <JSON> hmm
14:14:57 <tech2> tessier: haskell specific, or a common unix thing?
14:14:57 <kmc> graphviz?
14:15:04 <shapr> edwardk: you called?
14:15:24 <JSON> CLOR
14:15:35 <kmc> brisingr, how did the talk go? what worked well and didn't work well?
14:15:58 <tessier> tech2: Not haskell specific but it seems like the kind of thing the more enlightened programmer types who hang out in here would be more likely to be familiar with...not pie charts or anything but topographical type stuff...
14:16:18 <tech2> tessier: dot?
14:16:31 <kmc> graphviz
14:16:35 <JSON> lets think....
14:16:38 <JSON> topographic
14:16:40 <kmc> there's a haskell output library too
14:17:54 <tessier> Maybe it was graphviz... dot looks to be an input language or something not actual software...
14:18:07 <kmc> dot is the name of one of the graphivz layout programs
14:18:11 <tessier> ah
14:18:14 <kmc> and of the input format it accepts
14:18:25 <kmc> but there's other programs (neato, twopi, circo, fdp, sfdp)
14:18:56 <tessier> That looks like what I need, in any case. Thanks. Someone was just asking about how to diagram what VLANs were on which ports etc. and I was wondering if we couldn't just dump switch configs and parse them into something (like dot) and feed them into something (like graphviz).
14:19:43 <shapr> Does anyone run their own Haskell binaries on a virtual host that does not have enough memory to *build* those programs?
14:19:50 <shapr> If so, do you have an automated solution?
14:20:37 <hpc> shapr: write a really simple build.sh?
14:20:41 <thoughtpolice_> shapr: i've done it before, but not much besides making sure you give '-static' to GHC + scp :(
14:20:45 <hpc> and scp the files over
14:21:07 <thoughtpolice_> not that much to automate anyway. naturally real deployment is of course a whole different story,
14:21:21 <shapr> kinda sucks... perhaps the real solution is to get a vps that has enough memory to build Haskell binaries :-/
14:21:38 <thoughtpolice_> heh, the linking can make that a PITA sometimes
14:22:10 <roconnor> shapr: nix could be coerced into doing something useful in this situation.
14:22:11 <brisingr> kmc: it went very well
14:22:18 <shapr> roconnor: oh? how so?
14:22:19 <parcs> i use runhaskell for my production code
14:22:34 <brisingr> they were impresssed, expect traffic increase in here :))
14:22:44 <brisingr> they were like, haskell can do that?
14:22:50 <dylukes> monochrom: it stopped suppressing :<
14:23:09 <roconnor> shapr: you can make your own nix-channels that hold pre-built binaries and if you install your packages with nix you can tell it to look on your server first for binaries and it will copy them over.
14:23:17 <monochrom> oh fun, you have -funbox-strict-fields and -w and you see a warning?
14:23:21 <roconnor> shapr: this isn't a very lightweight solution.
14:23:40 <shapr> :-/
14:23:40 <dylukes> ....now it is again.
14:23:40 <dylukes> No, it works.
14:23:41 <thoughtpolice_> parcs: :)
14:23:45 <dylukes> I moved the OPTIONS_GHC above module
14:23:47 <dylukes> and it works...
14:23:56 <monochrom> told you so
14:24:05 <dylukes> no you... oh well
14:24:14 <roconnor> shapr: but if you are in a seriously complex situation nix will handle everything for you once it is set up.
14:24:26 <monochrom> "and it is at a right place"
14:24:35 <roconnor> shapr: and dis-nix will even configure clusters for you.
14:25:05 <JSON> parcs how long have you been using haskell
14:25:31 <shapr> I think I should just get a better vps
14:26:02 <monochrom> I thought of showing a example of wrong place "module X where {-# OPTIONS_GHC -w #-}  is a wrong place" but I thought you knew
14:26:12 <kmc> which things most impressed them brisingr?
14:26:45 <roconnor> shapr: what vps do you have?
14:26:46 <brisingr> kmc: the boolean with three values
14:27:01 <kmc> odd
14:27:39 <milktrader> is there a way to "clear" the ghci terminal screen. In UNIX, it's $ clear
14:27:40 <brisingr> kmc: they kinda lost it midway
14:27:53 <kmc> milktrader, :! clear
14:27:57 <roconnor> Boole is spinning in his grave
14:28:27 <milktrader> kmc: whoa, that is very nice
14:28:52 <kmc> you can run any shell command that way
14:28:55 <milktrader> so I suppose there are other :! functions that can be called?
14:28:56 <kmc> brisingr, how so?
14:29:13 <brisingr> well, by halfway I mean at functors
14:29:35 <copumpkin> http://hpaste.org/50764
14:29:38 <milktrader> kmc, thanks. it works with ls too
14:30:02 <brisingr> I went for a "no need to understand now, just open your appetite"
14:30:08 <kmc> yeah
14:30:22 <kmc> i'm doing a similar kind of talk, motivating people to study haskell on their own
14:30:28 <kmc> but i think my slides will come out very different from yours
14:30:37 <tessier> Wow. hpaste.org takes the haskell syntax and renders it into nice lambda glyphs etc? Neato.
14:31:10 <kmc> it does?
14:31:12 <brisingr> kmc: my slides have had surprisingly little to do with my actual presentation
14:31:44 <parcs> milktrader: ":!cmd" runs the program cmd, so :!clear runs the clear command
14:31:54 <parcs> i'd personally use C-l
14:32:31 <monochrom> no, hpaste is showing copumpkin's code verbatim
14:32:33 <kmc> brisingr, did you write LaTeX source directly?
14:32:48 <brisingr> kmc: indeed I have
14:32:48 <kmc> i have a few old slide decks I prepared with markdown -- pandoc --> s5 html
14:32:57 <kmc> and i want to convert them to markdown -- pandoc --> beamer latex
14:33:07 <brisingr> kinda limited but I was low on time
14:33:14 <kmc> beamer seems really nice
14:33:20 <brisingr> I finished 10 minutes before I had to catch the train
14:33:24 <kmc> haha, that's the way
14:33:29 <hpaste> copumpkin annotated “Eckmann-Hilton” with “Eckmann-Hilton (annotation)” at http://hpaste.org/50764#a50765
14:33:41 <copumpkin> I made it cleaner
14:33:53 <milktrader> I used :!mv test.hs tst.hs to change the name of a file from within ghci and it works like a charm. What an absolutely neat feature.
14:34:36 <kmc> it's actually quite common in interactive unix apps
14:34:40 <brisingr> the source: http://goo.gl/ybqxG
14:35:03 <brisingr> dirty, very dirty
14:35:04 <kmc> try "!ls" in ipython or gnuplot
14:35:32 <hpaste> copumpkin annotated “Eckmann-Hilton” with “Eckmann-Hilton (final)” at http://hpaste.org/50764#a50766
14:35:33 <monochrom> in fact, try "!ghci"
14:36:36 <monochrom> in fact, the ghc manual has an example: ":! ghc -c D.hs"
14:39:21 <brisingr> I did stole like half of the LYAH examples, thank god it's open source
14:39:49 <brisingr> *steal
14:39:54 <kmc> no, you "remixed" an "homage" "inspired by" LYAH
14:40:08 <hpc> ^.^
14:40:16 <brisingr> yes, of course
14:40:21 <brisingr> that's what I meant
14:40:38 <hpc> just make sure you use it under the same extraordinarily verbose license
14:40:49 <brisingr> of course
14:41:27 <kmc> CC By-NC-SA 3.0
14:41:45 <brisingr> yup
14:41:47 <kmc> the people i know who care a lot about these things have a rather dim view of NC
14:41:55 <kmc> but perhaps i should take the license war to #haskell-blah :)
14:42:07 <brisingr> as a matter of coincidence, cc-by-nc-sa is my preferred license
14:42:10 <MrDudeManGuy> Hello
14:43:27 <milktrader> kmc: downloading ipython now, previously only used python
14:46:28 <parcs> @hoogle timeout
14:46:29 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
14:46:29 <lambdabot> module System.Timeout
14:46:29 <lambdabot> Network.Socket RecvTimeOut :: SocketOption
14:47:26 <kmc> the implementation of 'timeout' is kind of a neat demo of a few things
14:48:02 <kmc> in particular, using threads and exceptions without making it visible that you're doing so
14:48:52 <parcs> timeout n f = fmap Just f
14:48:59 <parcs> :P
14:49:06 <kmc> ;)
14:50:09 * hackagebot random-fu 0.2.1.0 - Random number generation  http://hackage.haskell.org/package/random-fu-0.2.1.0 (JamesCook)
14:51:45 <parcs> that's also a valid definition due to the guarantees (or lack thereof) of threadDelay
14:52:00 <kmc> yeah
15:09:44 <edwardk> thoughtpolice_: uploaded a big patch. can you give that a shot?
15:10:09 * hackagebot trifecta 0.36 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.36 (EdwardKmett)
15:21:53 <milktrader> getting a little befuddled with the notion of type classes ... should I muddle through and *get* it or can I absorb it while learning other basics (haven't touched monads or pattern matching yet)
15:22:40 <edwardk> @src Eq
15:22:41 <lambdabot> class  Eq a  where
15:22:41 <lambdabot>     (==), (/=)   :: a -> a -> Bool
15:23:16 <edwardk> Eq is a class that says that if you have an instance of Eq for some type 'a', you can compare two of them getting a Bool. Unlike OOP the 'class' isn't tied directly to some object.
15:23:49 <c_wraith> :t all (uncurry (<)) . zip`ap`tail
15:23:50 <lambdabot>     Precedence parsing error
15:23:50 <lambdabot>         cannot mix `.' [infixr 9] and `ap' [infixl 9] in the same infix expression
15:23:53 <c_wraith> boo!
15:24:03 <c_wraith> I demand whitespace based precedence!
15:24:10 <kmc> milktrader, pattern matching is way more fundamental than monads
15:24:18 <edwardk> you make up new instances of a class, even for existing types
15:24:18 <c_wraith> :t all (uncurry (<)) . (zip`ap`tail)
15:24:19 <lambdabot> forall a. (Ord a) => [a] -> Bool
15:24:21 <kmc> in fact, Monad is just one particular type class
15:24:32 <edwardk> and kmc stole my punchline =)
15:24:32 <kmc> but it's one people have lots of trouble with
15:24:33 <kmc> so you should definitely understand type classes first
15:24:50 <milktrader> edwardk and kmc, thanks
15:24:59 <kmc> milktrader, declaring a type class declares a generic interface, which can be implemented by various types
15:25:09 * hackagebot wl-pprint-extras 1.6 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-1.6 (EdwardKmett)
15:25:12 * hackagebot wl-pprint-terminfo 0.8 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.8 (EdwardKmett)
15:25:14 <kmc> it's not that close to specifically a Java interface or a C++ abstract class or whatever
15:25:28 <kmc> those analogies might lead you astray
15:25:34 <kmc> but it's in the same general space
15:26:10 <edwardk> bos is having technical difficulties
15:27:04 <kmc> milktrader, so Eq is an interface for testing equality of values, which is generic in the sense that (==) works on a bunch of different types
15:27:22 <kmc> Show is an interface for turning values into strings, and 'show' works on a bunch of different types
15:27:28 <kmc> etc.
15:30:10 * hackagebot trifecta 0.36.1 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.36.1 (EdwardKmett)
15:33:39 <dylukes> I'm going to risk trying to take on trifecta.
15:33:52 <dylukes> edwardk wrote it. I may end up trapped in a closed semigroup if I'm not careful.
15:35:11 <kmc> haha
15:35:16 <kmc> what are you going to use it for?
15:35:25 <dylukes> my STG->LLVM compiler
15:35:32 <dylukes> I'm getting sick of finding little inconsistencies in alex,
15:35:39 <dylukes> plus all the docs are 3-8 years old.
15:35:49 * milktrader stupid hotel internet
15:35:59 <dylukes> i.e, AlexInput doesn't match the docs.
15:36:00 <kmc> what about Parsec or uu-parsinglib dylukes?
15:36:00 <RenJuan> milktrader, yes, you need to get typeclasses but don't like seize up over it
15:36:08 <dylukes> kmc: I know I could use Parsec
15:36:12 <dylukes> I just want to TRY something new :P
15:36:18 <kmc> fair enough :)
15:36:27 <kmc> i'd love to see a cool example of using trifecta
15:36:33 <kmc> i'm sure edwardk would too :)
15:36:54 <dylukes> STG grammar is pretty simple.
15:36:59 <dylukes> Refreshingly so TT_TT
15:38:03 <dylukes> I wish hackage would generate docs >_<
15:38:47 <dylukes> Is there a way to tell cabal to generate haddock for a package when I install it (or better yet, after the fact)?
15:38:54 <dylukes> I generally resort to unpacking it, then haddocking it
15:39:11 <aavogt> there's an option in ~/.cabal/config
15:39:47 <aavogt> but last I checked it doesn't --hyperlink-source
15:40:32 <dylukes> alright... time to see if I can figure out this thing
15:40:37 <dylukes> it's really really big .__.
15:41:03 <benmachine> I keep meaning to learn uu-parsinglib, it sounds neat
15:41:13 <benmachine> but I never quite know where to start :P
15:41:14 <dylukes> btw, I meant to ask earlier
15:41:16 <dylukes> what does bracket do?
15:41:59 <benmachine> it captures a common exception handling pattern
15:42:09 <benmachine> :t bracket
15:42:10 <lambdabot> Not in scope: `bracket'
15:42:16 <benmachine> :t Control.Exception.bracket
15:42:17 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:42:18 <aavogt> or it turns a parser for  abc one that accepts [abc]
15:42:26 <benmachine> oh, yeah
15:42:29 <benmachine> which bracket :P
15:42:43 <dylukes> I mean the Control.Exception one
15:43:07 <benmachine> the idea is that it goes
15:43:22 <benmachine> bracket init act fin
15:43:28 <kmc> init fin act, actually
15:43:32 <kmc> so that you can partially apply
15:43:32 <benmachine> oh
15:43:33 <benmachine> yeah
15:43:34 <benmachine> wups
15:43:43 <navaati> this repa library is just amazing !
15:43:46 <kmc> an illustrative example is:  withFile name = bracket (openFile name ReadMode) closeFile
15:43:56 <benmachine> IO a fetches a resource and then passes it to your action
15:44:07 <benmachine> then when your action finishes the resource is passed to your closey thing
15:44:17 <kmc> it does exception-safe resource acquisiton and cleanup
15:44:53 <benmachine> (where finishes includes was killed somehow)
15:45:08 <dylukes> ah I see.
15:45:17 <RenJuan> dylukes, is TT_TT an emoticon?
15:45:21 <dylukes> yes
15:45:27 <RenJuan> ah
15:45:30 <dylukes> :t (TT_TT)
15:45:31 <lambdabot> Not in scope: data constructor `TT_TT'
15:45:50 <dylukes> @let (TT_TT) _ _ = "you guys suck"
15:45:51 <lambdabot>   Parse error in pattern: (TT_TT)
15:46:01 <dylukes> @let TT_TT = "you guys suck"
15:46:03 <lambdabot>  <local>:1:0: Not in scope: data constructor `TT_TT'
15:46:06 <dylukes> bah
15:46:25 <benmachine> @let data TT_TT iwonderifthisworks = Constructor iwonderifthisworks
15:46:25 <lambdabot>  Invalid declaration
15:46:27 <benmachine> :(
15:46:54 <c_wraith> sorry, to define new data types, you have to be Cale. :P
15:47:30 <shachaf> c_wraith: So *that's* what that GHC error meant.
15:47:41 <c_wraith> (and then you do it by editing the include files, not through the \bot interface)
15:47:48 * shachaf resorted to using newtypes of Eithers and tuples.
15:48:40 <dylukes> already confusing kmc...
15:48:48 <dylukes> he has parsing as a TYPECLASS rather than a monad.
15:48:50 <dylukes> somehow
15:48:54 <dylukes> and somehow a lot of monads can be used.
15:49:04 <kmc> that sounds like MonadState, MonadReader, etc.
15:49:21 <benmachine> we totes need a let data X = Y in ...
15:49:29 <dylukes> http://cl.ly/9iGr
15:49:34 <dylukes> kmc: maybe this will make more sense to you?
15:49:44 <dylukes> I'm confused a bit.
15:49:50 <hpc> benmachine: that would be brainbreaking
15:49:54 <kmc> your problem is that you're using a mac
15:49:58 <kmc> get a real computer
15:49:59 <kmc> </troll>
15:50:02 <dylukes> I guess there's Parser
15:50:03 <dylukes> >_>
15:50:13 <hpc> kmc: like an android phone! :P
15:50:18 <kmc> dylukes, do you understand how MonadState, MonadReader, etc. classes work?
15:50:22 <kmc> in mtl / monads-fd?
15:50:31 <dylukes> I haven't taken a look.
15:50:34 <dylukes> Let me do so...
15:50:39 <kmc> :t get
15:50:40 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
15:50:44 <aavogt> and there's you own data you've made an instance of MonadTokenParser
15:50:56 <kmc> the idea is that you can use 'get' on (State s) but also on (ReaderT r (State s))
15:51:16 <kmc> because there's an "instance (MonadState m s) => MonadState (ReaderT r m) s"
15:51:24 <kmc> with "get = lift get"
15:51:31 <dylukes> ;~;
15:51:37 <dylukes> do you have a simple example?
15:51:40 <kmc> it just lifts the operation through a transformer stack for you
15:51:42 <aavogt> there aren't any MPTCs in trifecta I think
15:51:59 <hpc> dylukes: a good example would be MonadIO
15:52:00 <dylukes> kmc: Hm I see.
15:52:01 <kmc> dylukes, have you used monad transformers?
15:52:06 <dylukes> A little bit.
15:52:11 <dylukes> But I've always just lifted stuff.
15:52:13 <kmc> so you've used 'lift'?
15:52:15 <kmc> *nod*
15:52:25 <ash_> so.. parsec uses a state object internally (or is bundling one with the Parsec monad) does anyone know if I can access that state variable if I want to make my parsec knowledgable about what has been parsed?
15:52:28 <kmc> the classes just let you omit 'lift' sometimes
15:52:31 <aavogt> at least in the classes on the outside
15:52:37 <dylukes> kmc: Ah. Gotcha.
15:52:54 <dylukes> so it's just a closed set of transformers,
15:53:01 <shachaf> The mtl type class thing is such a hack.
15:53:06 <dylukes> for which functions are defined that let you bypass the transforms stack
15:53:07 <benmachine> ash_: I'm not exactly sure what you mean but I'm going to take a wild guess and say, getInput
15:53:08 <kmc> ash_, yeah, http://hackage.haskell.org/packages/archive/parsec/3.1.1/doc/html/Text-Parsec-Prim.html#v:getParserState
15:53:23 <kmc> and other functions around there
15:53:40 <kmc> (okay, getParserState isn't a function)
15:53:58 <ash_> getState is
15:54:06 <kmc> no it's not
15:54:09 <kmc> it's a parser
15:54:17 <dylukes> kmc: The unicode stuff in trifecta looks nice.
15:54:22 <ricree> how do you make ghci interpret a module rather than using the precompiled one?
15:54:22 <dylukes> there are prebuilt charsets for a lot...
15:54:28 <kmc> ricree, :m + *Foo
15:54:40 <dylukes> Even per block.
15:54:42 <kmc> dylukes, it's not a closed set, anyone can declare a MonadState instance for their own transformer
15:54:44 <kmc> but otherwise, yeah
15:54:46 <dylukes> kmc: Yeah
15:54:52 <dylukes> Like if I wanted to be silly,
15:55:01 <dylukes> and make people write types in japanese and functions in cyrillic,
15:55:04 <shachaf> instance MonadState m => ,
15:55:09 <dylukes> there are charsets based on unicode blocks for that
15:55:21 <RenJuan> benmachine, "tote" ?
15:55:45 <benmachine> RenJuan: totes = totally
15:55:51 <benmachine> I am just being silly
15:55:52 <RenJuan> i c
15:56:13 <RenJuan> i thought mehbe you were talking about them fold up booties
15:56:37 <ricree> kmc: does that work for files in the directory you're running ghci from?  It doesn't seem to when I'm using it
15:56:53 <ash_> kmc: in the docs for Text.Parsec.Prim.getState it says it "Returns the current user state." Is that a state I have free control over? I assume getParserState is more an implementation detail than a user detail
15:57:10 <kmc> it is; it's the 's' parameter to ParsecT
15:57:16 <kmc> it can be anything you like
15:57:23 <dylukes> kmc: Well I can say already, I like the unicode/charset stuff a lot.
15:57:27 <kmc> basically Parsec has a State-like monad built in
15:57:34 <kmc> is my understanding.  i've never used it.
15:57:41 <dylukes> Parsecs support for unicode and multibyte chars is a little annoying.
15:58:02 <hpc> doesn't parsec work on Char?
15:58:48 <benmachine> kmc: I think the 'u' is the user state
15:58:54 <kmc> dylukes, it is?
15:58:58 <kmc> oh
15:59:08 <kmc> i should be more careful reading the docs
15:59:13 <benmachine> my understanding is that it's similar to a State moand except that it backtracks with the parser
15:59:16 <dylukes> kmc: file:///Users/dlukes/Desktop/trifecta-0.36.1/dist/doc/html/trifecta/Text-Trifecta-CharSet-Unicode-Category.html
15:59:21 <dylukes> ...thats a useless link
15:59:24 <dylukes> whoops :3
15:59:36 <dylukes> there are CharSet's for all the unicode blocks, as well as for categories of characters
15:59:37 <kmc> benmachine, yeah, which should be equivalent to one of (StateT . ParsecT) or (ParsecT . StateT) but i don't remember which ;)
15:59:39 <c_wraith> now we know you're on a mac, and your username!
15:59:43 <dylukes> and oneOfset/noneOfSet combinators for thoe.
16:00:09 <benmachine> kmc: ...hmm. since it does something that would be impossible to do with IO I'm assuming not the latter
16:00:20 <benmachine> kmc: but I'm not sure it's exactly like StateT ParsecT
16:00:30 <kmc> you can do backtracking IO with hypervisor support :D
16:00:38 <monochrom> ...
16:00:43 <monochrom> I mean hahahaha
16:03:02 <monochrom> but usually, "backtracking" in the presence of IO is taken to mean re-visit previous control-flow points, in other words repeat previous IO actions. e.g., try some putStrLn's in LogicT IO
16:08:30 <benmachine> no I was thinking the kind of backtracking that would require flux capacitor support
16:09:30 <monochrom> oh!
16:12:00 <kmc> great scott!
16:12:47 <kmc> i still want to see a time travel movie based on Git
16:13:06 <kmc> where you can easily fork the timeline but then you have to deal with merge conflicts later
16:13:35 * benmachine resets kmc... /hard/
16:15:08 * monochrom rm -rf .git
16:15:09 * hackagebot BiobaseXNA 0.5.1.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.5.1.0 (ChristianHoener)
16:15:51 * monochrom rcs init
16:16:05 <monochrom> take that for real backtracking!
16:17:52 <JoeyA> Can GHC create Windows binaries that are easy to deploy?
16:18:41 <Eduard_Munteanu> JoeyA: by default it will build them with static linkage, so yeah
16:18:46 <monochrom> I think so. GHC libs are statically linked into the executable.
16:18:49 <Eduard_Munteanu> Assuming that's what you mean.
16:18:56 <JoeyA> More generally, is it feasible to use Haskell to write a program that will run on Windows?
16:19:01 <JoeyA> So I assume the answer is yes, then.
16:19:04 <Eduard_Munteanu> Sure.
16:19:20 <JoeyA> The most exotic dependency I see in Linux binaries is libffi, which I guess is very likely to be available.
16:19:44 <monochrom> do give it a try. "main = putStrLn "hello"" then copy the executable to another computer and try
16:20:10 * hackagebot trifecta 0.36.2 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.36.2 (EdwardKmett)
16:20:24 <c_wraith> the most common thing to be missing, in my experience, is libgmp.so
16:20:34 <RenJuan> (i.e. one that doesn't have ghc installed)
16:20:40 * Eduard_Munteanu used to do that in Wine, it usually worked well on real Windows too.
16:21:27 <JoeyA> ah
16:21:36 <monochrom> oh, I forgot gmp
16:22:24 <JoeyA> I tried running a 32-bit Linux binary on 64-bit Linux, and it didn't work.
16:22:24 <benmachine> gmp is a nuisance
16:22:43 <benmachine> sometimes
16:22:51 <kmc> JoeyA, you have to install 32-bit versions of some libs
16:22:53 <kmc> then it should work
16:23:17 <monochrom> true, "ldd your_executable" to find out
16:23:30 <JoeyA> "not a dynamic executable"
16:23:52 <monochrom> now that's fun
16:24:06 <MRDUDEMAN> anyone using Haskell and Node.JS
16:24:34 <kmc> in what capacity
16:25:00 <JoeyA> Does Ubuntu have a haskell-platform package?
16:25:03 <Eduard_Munteanu> JoeyA: what do you mean by "it didn't work"?
16:25:10 <monochrom> no, ubuntu doesn't
16:25:22 <JoeyA> Thanks.
16:25:30 <Eduard_Munteanu> It could be your kernel wasn't configured and built properly.
16:25:50 <JoeyA> Running a 32-bit binary on 64-bit Linux.  Didn't expect it to work.
16:25:50 <Eduard_Munteanu> (but assuming you didn't do that yourself, I don't think it's likely)
16:25:56 <kmc> JoeyA, that's generally supported
16:25:57 <JoeyA> I'll just install GHC on the server :-)
16:26:00 <jeffcutsinger_> There is a haskell-platform package.
16:26:00 <kmc> on x86
16:26:05 <kmc> i'm surprised it's not a dynamic exe
16:26:45 <kmc> 32-on-64 compat generally works pretty well
16:26:55 <jeffcutsinger_> It's out of date (2010.1)
16:27:02 <kmc> though it's a big source of serious security holes and ugly, ugly kernel code
16:27:42 <JoeyA> Ubuntu 10.04 doesn't have a haskell-platform package, I don't think.
16:28:02 <jeffcutsinger_> Ok. Running 11.04 here.
16:30:06 <Eduard_Munteanu> It might be a static executable if it's some proprietary thingy.
16:30:30 <kmc> oh, i thought the executable came out of GHC
16:30:53 <Eduard_Munteanu> Oh, hm.
16:35:27 <bfig> hello. is there any way to overlap two module definitions in such a way that you can't type a (sub)expression ?
16:37:15 <monochrom> with zero modules you can already fail typing an expression, e.g., x x
16:40:21 <bfig> monochrom, say i want to manually type an expression, is there any case where i can't do it manually?
16:40:46 <monochrom> x x can't be manually typed either
16:41:09 <bfig> monochrom, say it works when it is untyped :D
16:41:26 <monochrom> x x works when it is untyped
16:41:31 <c_wraith> that's part of the Y combinator when untyped
16:41:59 <bfig> the y combinator can be typed... or is t->t->t untyped?
16:42:15 <Eduard_Munteanu> It can't be typed.
16:42:15 <bfig> is the compiler gently saying 'fuck off' ?
16:42:27 <Dashkal> > id id
16:42:28 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
16:42:28 <lambdabot>    arising from a use of `...
16:42:34 * Eduard_Munteanu isn't sure who asked this earlier
16:42:50 <kmc> the Y combinator does not type in the simply-typed lambda calculus.  in a  you cannot have recursion unless it's built in
16:42:54 <kmc> in a typed lambda calculus*
16:43:01 <Dashkal> lambdabot has a Show for a -> a?
16:43:31 <Eduard_Munteanu> Dashkal: somewhat, IIRC
16:43:31 <c_wraith> yeah
16:43:38 <bfig> typed lambda calculus means the lambdas have a type assoc? like \s::int x::Char z::[Float] -> ... ?
16:43:39 <c_wraith> it used the instance from smallcheck
16:43:41 <ddarius> Apparently she has multiple instances.
16:43:47 <kmc> bfig, sometimes the types are inferred
16:43:55 <parcs> Dashkal: it's just "<function>"
16:44:07 <c_wraith> parcs: one of them is.  the other is more complicated
16:44:30 <kmc> i'd write out the typing rules of STLC but i left my Compose key in my other pants
16:44:30 <Eduard_Munteanu> bfig: simply-typed means everything has a concrete type.
16:44:48 <bfig> ok
16:44:55 <kmc> STLC has no polymorphism, yes, but what I said is still true if you add polymorphism
16:44:56 <Eduard_Munteanu> No polymorphism, no type operators.
16:45:03 <Eduard_Munteanu> Yeah.
16:45:06 <kmc> System F also has the strong normalization property
16:45:19 <kmc> typed lambda calculus has primitive types and function types (S -> T) for types S,T
16:45:30 <kmc> and it has typing rules for variables, lambda, and application
16:45:34 <monochrom> the y combinator specifically refers to \f -> (\x -> f (x x)) (\x -> f (x x)), not just about anything with type (t->t)->t
16:45:39 <parcs> c_wraith: what is it?
16:46:11 <c_wraith> parcs: it's the instance from smallcheck.  It enumerates a few inputs of the domain, and the outputs they map to
16:46:28 <c_wraith> parcs: obviously, that has a bunch of extra instance restrictions on the types
16:46:58 <ddarius> Γ, x:A ⊢ x : A     Γ, x:A ⊢ M : B  ⇒  Γ ⊢ λx:A.M : A → B         Γ ⊢ M : A → B ∧ Γ ⊢ N : A  ⇒  Γ ⊢ M N : B
16:47:32 <kmc> @where+ STLC  Γ, x:A ⊢ x : A     Γ, x:A ⊢ M : B  ⇒  Γ ⊢ λx:A.M : A → B         Γ ⊢ M : A → B ∧ Γ ⊢ N : A  ⇒  Γ ⊢ M N : B
16:47:33 <lambdabot> It is forever etched in my memory.
16:47:49 <Eduard_Munteanu> ddarius: btw, do you type all that with SCIM? I vaguely remember you mentioning it.
16:47:50 <monochrom> @where STLC
16:47:50 <lambdabot> Γ, x:A ⊢ x : A Γ, x:A ⊢ M : B ⇒ Γ ⊢ λx:A.M : A → B Γ ⊢ M : A → B ∧ Γ ⊢ N : A ⇒ Γ ⊢ M N : B
16:47:57 <ddarius> Eduard_Munteanu: Yes.
16:48:12 <Eduard_Munteanu> ddarius: just the Latex plugin? It seems pretty spartan here.
16:48:20 <ddarius> Eduard_Munteanu: Yes.
16:48:46 <monochrom> yeah, SCIM plus the latex table lets you type \lambda to get λ. that's what I do too
16:48:59 * ddarius should make a better table though.
16:49:13 <monochrom> yeah I don't like some of its mappings
16:49:13 <bfig> monochrom, i was refering to that particular combinator, yes :)
16:49:52 <ddarius> monochrom: \bot is ⊤ for some reason and it's missing many
16:49:57 <monochrom> the "x x" part fails type-checking unless you add equi-recursive type
16:50:10 <ddarius> Intersection types would also allow that to type check.
16:50:55 <Eduard_Munteanu> Hm, indeed, I can type that reasonably... but I remember I couldn't do subscripts and superscripts
16:51:48 <Eduard_Munteanu> λ
16:52:32 <Dashkal> When your scope already has conflicting instances for a typeclass, is there a way to forcibly chose one?
16:52:40 <ddarius> No.
16:52:54 <KruMn> hi
16:53:02 <Eduard_Munteanu> KruMn: hi
16:55:41 <Cale> Dashkal: the usual way to avoid writing conflicting class instances in the first place is to newtype the datatype, so that you can use the newtype data constructor as a way to select which instance you want.
16:55:45 <bfig> what are the most used fp combinators, besides Y?
16:55:52 <bfig> i've heard of S and some other iirc
16:56:03 <JoeyA> I (id)
16:56:10 <Cale> K (const)
16:58:03 <geheimdienst> in ghci, if my prompt is set to a fixed string, how can i check what modules are loaded? short of resetting the prompt i mean. ":show modules" and ":show context" don't work
16:58:53 <monochrom> loaded? or in-scope?
16:59:23 <JoeyA> :l , but it's not honest
17:00:01 <JoeyA> > :l  Ok, modules loaded: none.  > sort "liar"  "ailr"
17:00:02 <lambdabot>   <no location info>: parse error on input `:'
17:00:13 <Eduard_Munteanu> bfig: http://en.wikipedia.org/wiki/Ski_combinators   for context
17:00:17 <geheimdienst> monochrom: i guess in scope. whatever the default prompt shows
17:00:24 <KruMn> do you use yi for editing?
17:00:40 <azaq23> bfig: S x y z = x z (y z) and K (const) (from which I (id)) can be formed are often named as combinators because S and K together are enough to express every normal expression (with variables) in
17:00:40 <azaq23> untyped lambda calculus in - whether they are that often used is another question (But S and K form the Applicative instance for (t ->), for instance)
17:01:30 <dalaing> I found http://en.wikipedia.org/wiki/Combinatory_logic was useful as well
17:01:45 <dalaing> was looking at similar stuff a few weeks back
17:02:48 <Cale> in particular, take a look at the abstraction elimination translation rules
17:02:49 <copumpkin> edwardk: your algebra package won't install :(
17:03:12 <edwardk> copumpkin: ohnoes what breaks?
17:03:16 <Cale> (which sort of explain why S,K,I are a reasonable basis to choose)
17:03:23 <copumpkin> edwardk: representable-tries 2.0.3 wants semigroups 0.8, and algebra wants semigroups < 0.8
17:03:28 <edwardk> ah
17:04:08 <edwardk> thats coz i upgraded some of the upstreams of trifecta and forgot to upload algebra. one sec.
17:04:21 <monochrom> I confess I can't find any command to list the modules in-scope. there is probably none. (:show modules shows loaded modules, which is different from in-scope, this is why it is different from the default prompt)
17:04:56 <copumpkin> edwardk: thanks!
17:04:58 <geheimdienst> monochrom: yeah it's weird, isn't it
17:05:00 <monochrom> (:show context is a debugger thing)
17:05:39 <kmc> anyone here done syntax highlighting of Haskell code inside LaTeX (specifically, beamer)?
17:05:54 <kmc> i'm looking for editor-style coloring of ASCII symbols; not fancy arrows and lambdas etc
17:06:37 <monochrom> however, you can use %s in your prompt to get the in-scopes
17:06:50 <maurer_> kmc: I don't know if it does it, but have you looked at the listings package?
17:07:13 <maurer_> lhs2TeX normally does fancy arrows, but there might be .fmt that will give you what you want
17:07:17 <maurer_> *a .fmt
17:07:45 <kmc> listings package? i get a 404 at http://hackage.haskell.org/package/listings
17:07:49 <edwardk> copumpkin: ok. uploaded. should be good now
17:07:50 <JoeyA> Is it possible to do a select() loop, or similar functionality, in Haskell?
17:07:55 <copumpkin> edwardk: yay thanks
17:07:58 <copumpkin> JoeyA: you get it for free
17:07:58 <monochrom> :set prompt "λ♥ %s ♥λ> "  to assert your love of lambda without missing the in-scopes!
17:08:05 <kmc> JoeyA, http://haskell.org/haskellwiki/FAQ#How_do_I_do_event-based_IO_in_GHC_Haskell.3F__Should_I_call_select.2C_epoll.2C_etc.3F
17:08:05 <copumpkin> JoeyA: unless you really really want to do all the hard work yourself
17:08:11 <copumpkin> oh kmc is fancy
17:08:11 <Eduard_Munteanu> @google latex listings
17:08:12 <lambdabot> http://en.wikibooks.org/wiki/LaTeX/Packages/Listings
17:08:12 <lambdabot> Title: LaTeX/Packages/Listings - Wikibooks, open books for an open world
17:08:13 * copumpkin defers
17:08:14 <JoeyA> Namely, the ability to monitor multiple file descriptors and act on them when they update.
17:08:18 <kmc> ah, LaTeX package
17:08:20 <kmc> thanks
17:08:44 <kmc> tl;dr is "just use threads, GHC makes them not suck"
17:08:51 <JoeyA> okay
17:08:53 <Eduard_Munteanu> According to that link it supports Haskell.
17:08:58 <thoughtpolice_> edwardk: On phone atm, but I installed 0.36.2 successfully with ghc 7.2.1 about 10 minutes ago
17:09:00 <JoeyA> threads don't allocate large stacks?
17:09:03 <copumpkin> no
17:09:04 <JoeyA> (in Haskell)
17:09:05 <thoughtpolice_> :D
17:09:05 <JoeyA> okay
17:09:09 <copumpkin> they're super lightweight
17:09:15 <Cale> JoeyA: In fact, what you'll get from that is better than a select() loop, in that it'll use epoll/kqueue where available
17:09:18 <kmc> you can spawn millions of threads on a modest system
17:09:19 <copumpkin> you can spawn a million of them without breaking a sweat
17:09:21 <JoeyA> cool
17:09:54 <Cale> (and it's about 1000 times easier to write :P)
17:09:55 <copumpkin> edwardk: quite a few warnings
17:10:04 <edwardk> 7.2.1?
17:10:11 * hackagebot algebra 2.0.2 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-2.0.2 (EdwardKmett)
17:10:15 <Eduard_Munteanu> Real threads are quite lightweight as well, compared to processes, so...
17:10:31 <copumpkin> edwardk: yeah
17:10:33 <JoeyA> except when you try to use them across multiple CPUs.
17:10:40 <edwardk> copumpkin: patches are welcome. i'm on 7.0.3
17:10:43 <copumpkin> ah
17:10:43 <copumpkin>     Warning: No explicit method nor default method for `mult'
17:10:43 <copumpkin>     In the instance declaration for `Algebra r (IntMap a)'
17:10:49 <edwardk> those 2 are legit
17:11:01 <edwardk> i just never wrote the instances ;)
17:11:04 <copumpkin> ah :)
17:11:08 <edwardk> er methods
17:11:08 <copumpkin> also, quite a few in dependencies
17:11:17 <kmc> sweet, pandoc has --listings
17:11:17 <edwardk> but didn't want to drop the 15 classes on top of those
17:11:18 <copumpkin> apparently mkTyCon is deprecated
17:11:20 <kmc> i <3 pandoc
17:11:23 <JoeyA> You're forcing the computer to keep all accessed data in sync, and you're sharing all data by default, meaning you have to do a lot of locking.
17:11:24 <edwardk> yeah
17:11:31 <Eduard_Munteanu> JoeyA: what do you mean? The GHC scheduler will multiplex green threads onto real threads
17:11:35 <kmc> i think it's a better example of "real world" (read: desktop) Haskell software
17:11:37 <edwardk> that is a harder call because then i have to cut off _me_ =)
17:11:39 <kmc> compared to say Darcs
17:11:45 <JoeyA> (I'm talking about threads in other languages, such as C)
17:11:48 <edwardk> i figure i'll wait until 7.4.1 to deal with that deprecation
17:12:23 <Eduard_Munteanu> NPTL/POSIX threads? Yeah, they're even cheaper than that.
17:14:58 <JoeyA> I'd like to know if Haskell shares the problems with threads that major imperative languages have (e.g. http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf )
17:16:38 <JoeyA> Threads, as opposed to processes, where sharing is explicit.
17:18:08 <kmc> Haskell is a major imperative language
17:18:39 <kmc> the thing is, in Haskell you don't use mutation all over the place for no reason
17:18:41 <kmc> you use it when you need it
17:18:42 <Eduard_Munteanu> "If we expect concurrent programming to be mainstream, and if we demand reliability and pre-"
17:18:45 <Eduard_Munteanu> dictability from programs, then we must discard threads as a programming model.
17:18:54 <kmc> you can also achieve parallel evaluation without threads
17:19:01 * shachaf can't figure out how Eduard_Munteanu manages to paste like that.
17:19:08 <shachaf> How does the second '"' get there?
17:19:16 <Cale> JoeyA: Haskell is essentially the language that the author there is suggesting.
17:19:22 <Eduard_Munteanu> I haven't read through the whole paper, but if he's arguing for certain safety (and thread-obliviousness), there is something like that.
17:19:32 <JoeyA> I haven't read it either.
17:19:38 <Cale> "Rather than pruning nondeterminism, we should build from essentially deterministic, composable components. Nondeterminism should be explicitly and judiciously introduced where needed, rather than removed where not needed."
17:19:39 <Eduard_Munteanu> You might want to take a look at STM or even DPH.
17:19:47 <Cale> ^^ that sounds like Haskell to me :)
17:19:51 <edwardk> JoeyA: haskell offers a notion of light-weight threading, it also offers sparks, STM and other mechanisms for dealing with parallelism
17:20:00 <kmc> JoeyA, in Haskell a shared mutable cell like a MVar is created in a particular place, and the capability to use it is passed around as an ordinary value
17:20:09 <Eduard_Munteanu> Yeah, basically, safe parallelism constructs.
17:20:13 <kmc> which means that even though you have threads running in a shared memory space, it's not quite "shared by default"
17:20:29 <JoeyA> Does anyone here use programmers.stackexchange.com ?  I might ask that over there.
17:20:34 <kmc> GHC Haskell is also one of few languages to offer parallelism without concurrency
17:20:35 <Eduard_Munteanu> shachaf: dunno, but evince seems to get a line break in the clipboard
17:20:46 <kmc> JoeyA, are you not satisfied with our answer?
17:20:55 <Eduard_Munteanu> I just added   ""   then tried to paste inside the quotation marks.
17:20:55 <kmc> anyway, StackOverflow is more popular among the Haskell crowd, I think
17:21:08 <shachaf> Oh, I see.
17:21:28 <JoeyA> programmers.stackexchange.com is where this type of question would be migrated to if it were posted to StackOverflow
17:21:43 <kmc> oh, interesting
17:22:06 <JoeyA> (the question being "Does Haskell share the problem with threads that C/Java/etc. have?"
17:22:31 <Cale> JoeyA: Of course, Haskell threads are not a silver bullet, but as far as concurrency abstractions are concerned, forkIO and the various concurrent datastructures GHC Haskell has are pretty good.
17:22:33 <JoeyA> kmc: It's not that I'm not satisfied with the answer, but that I need more time to write a good question.
17:22:45 <kmc> concurrency and parallelism in Haskell are better in a number of different ways
17:22:54 <kmc> there's no silver bullet; different techniques for different tasks
17:23:05 <JoeyA> And to do that, I need to identify the best arguments against threading from a design (rather than performance) perspective.
17:23:19 <Dashkal> The answer would be "If you write your haskell code in the same manner as you would in C/Java/etc, then yes."  There are other ways in haskell.  `par` is a good example
17:23:31 <kmc> also STM
17:23:41 <kmc> but i think even with plain old MVars and forkIO the situation is better in Haskell
17:23:55 <Dashkal> I'm inclined to agree.  MVar is really nice.
17:23:57 <kmc> because you have a lot fewer mutable variables floating around
17:24:11 <kmc> creating them and deciding who gets to use them is a more explicit act
17:24:56 <monochrom> MVar being a 1-place channel as opposed to a shared variable already avoids 99% of the problems
17:25:03 <BMeph> WARNING: Contains Explicit Mutability.
17:25:12 <kmc> it's also a little suspect to ask if Haskell and C have the same problems with threading.  Haskell is a very high-level language and C is a portable assembler, so of course a great many things will be harder in C
17:26:17 <Dashkal> "C is a portable assembler".  I never actually put that together before
17:26:25 <kmc> did Boost write a 10,000 line library implementing MVar for C++ yet?
17:26:44 <JoeyA> There's one major difference between C and assembly: C lets you use identifiers for variables, which makes code far more self-documenting.
17:26:57 <kmc> JoeyA, so does any decent assembler
17:27:17 <JoeyA> idiomatically?
17:27:42 <coppro> JoeyA: what?
17:27:42 <kmc> one major difference is that C doesn't let you make tail calls easily
17:27:54 <JoeyA> kmc: True that
17:27:57 <kmc> JoeyA, sure, if you use memory locations for your variables then it's very easy to name them
17:28:18 <JoeyA> Then you get a performance hit when you use them.
17:28:49 <JoeyA> kmc: Though GCC optimizes tail recursion on some architectures, such as x86.
17:28:51 <kmc> yes, that's another difference between C and assembly: the C compiler will perform optimizations for you
17:28:55 <kmc> yeah
17:29:05 <kmc> C on a particular compiler on a particular architecture lets you do tail calls, sometimes
17:29:09 <kmc> C doesn't let you do tail calls
17:29:25 <JoeyA> I tried to write a functional language interpreter for 68k, but ran into the fact that GCC doesn't optimize tail calls on that arch.
17:29:29 <Eduard_Munteanu> Not explicit tail-calls but it may perform TCO.
17:30:14 <kmc> JoeyA, a lot of arguments about high-level design issues like "threads or no threads" are still implicitly limited by the experience of the participants.  good ideas that have been implemented poorly in the past are dismissed
17:30:31 <kmc> and it seems to me that threads are a good idea which have been implemented very poorly
17:30:32 <JoeyA> hmm
17:31:00 <nwf> Dashkal: Before you run too far with the C-as-portable-assembler idea, you should read the paper from HP Labs called Threads Cannot Be Implemented As A Library.
17:31:11 <kmc> for example a lot of discussions about "OOP design patterns" are really discussions about how to work around particular flaws in C++ or Java
17:31:18 <kmc> those patterns become trivial in a good OOP language
17:31:22 <nwf> Unrelately, can somebody explain to me an error I'm getting with monomorphism restrictions and associated types?
17:31:25 <Eduard_Munteanu> JoeyA: I think C programmers usually avoid recursion and don't rely on TCO, but code such loops iteratively
17:31:36 <kmc> nwf, probably.  hpaste your code?
17:31:51 <Eduard_Munteanu> At least the stuff I've been involved into.
17:31:57 <Dashkal> nwf: Fair enough.  But I don't touch C threading.  Far too much pain there.
17:32:06 <nwf> kmc: http://pastebin.com/Sj2JehKH
17:32:12 <Dashkal> When I need to do stuff concurrently in C, I tend towards multiple processes.
17:32:17 <mauke> The paste Sj2JehKH has been copied to http://hpaste.org/50769
17:32:19 <kmc> bah, pastebin.com... where's mauke's bot
17:32:19 <Eduard_Munteanu> (so kmc doesn't say "Eduard_Munteanu: link? :P)
17:32:20 <kmc> thanx
17:32:39 <nwf> Dashkal: It's not _just_ threading; the semantics of C leave a lot to be desired as far as "assemblers" go.
17:32:49 <JoeyA> How does GHC handle concurrent accesses of values (namely, to avoid race conditions when a thunk needs to be forced)
17:32:54 <Dashkal> Fortunately, it's been years since I've had to care about C in any meaningful sense
17:32:57 <kmc> nwf, MMR says that pattern bindings at top level must be monomorphic.  'mkfoo' isn't monomorphic (and can't be defaulted)
17:33:10 <kmc> 'bar _ = ...' is a function binding not a pattern binding, so it's fine
17:33:13 <JoeyA> Does it do a lot of locking?  If not, how does it avoid it?
17:33:27 <Dashkal> nwf: Fair enough.  Also, I haven't touched assmebler since Apple ][.  I don't work well at the level of cogs and steam valves.
17:33:32 <nwf> Dashkal: :)
17:33:48 <nwf> kmc: Forgive my alarming ignorance on the topic, but, why the distinction?
17:33:58 <kmc> MMR is a silly rule
17:33:59 <JoeyA> I tried to code something in assembly, but realized I was making very slow process.
17:34:01 <kmc> will explain in a sec
17:34:04 <nwf> Thanks
17:34:08 <kmc> JoeyA, i don't remember what the RTS actually does, but i'd expect an atomic compare-and-swap to replace the thunk with a whitehole
17:34:10 <monochrom> because of expectations of "x = 2"
17:34:11 <JoeyA> (something substantial, that is.  Small routines aren't too bad)
17:34:20 <monochrom> @let x = 2
17:34:22 <lambdabot>  Defined.
17:34:24 <monochrom> @type x
17:34:25 <lambdabot>     Ambiguous occurrence `x'
17:34:25 <lambdabot>     It could refer to either `L.x', defined at <local>:1:0
17:34:25 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at State/L.hs:74:0-32
17:34:29 <monochrom> oops, sorry
17:34:32 <monochrom> @undefine
17:34:36 <JoeyA> kmc: And what does it do about a whitehole?  Jump to some code that waits?
17:34:37 <monochrom> @let monochrom = 2
17:34:37 <lambdabot>  Defined.
17:34:40 <kmc> yes
17:34:41 <monochrom> @type monochrom
17:34:42 <lambdabot> forall t. (Num t) => t
17:34:45 <JoeyA> (when another thread needs to access it)
17:34:48 <ash_> with Text.Parsec, should you be calling runParserT or runPT ?
17:34:57 <kmc> entering a whitehole puts the current Haskell thread on a waitqueue for that thunk's eventual evaluation
17:35:09 <JoeyA> Ah
17:35:13 <kmc> JoeyA, i remember reading that there was a very narrow window in which two Haskell-evaluating OS threads ("capabilities") could start evaluating the same thunk
17:35:21 <kmc> which is duplicated work, but probably harmless semantically
17:35:26 <kmc> i don't know if that's still true
17:35:29 <edwardk> kmc: iirc it isn't atomic it just gambles you won't race during the brief grey hole window
17:35:34 * ddarius should make a steam powered computer.
17:35:42 <nwf> kmc: It was true as of ICFP 2010, at least. :)
17:35:44 <monochrom> look at the (Num t) => t type. for its generality, there are performance penalties that surprise some people when they think "but it's just a simple constant!" (answer: it is not simple and it is not constant)
17:35:49 <edwardk> kmc: and that if you do its idempotent to evaluate twice
17:35:52 <kmc> nwf, so, do you understand the (dubious) justification for the monomorphism restriction?
17:36:04 <JoeyA> Wouldn't it be harmful in the face of unsafeInterleaveIO?
17:36:18 <nwf> kmc: It had something to do with polymorphic unsafePerformIO newIORef, right?
17:36:22 <kmc> edwardk, how do they deal with thunks representing the application of State# RealWorld -> (# a, State# RealWorld #)
17:36:26 <kmc> no nwf
17:36:31 <edwardk> JoeyA: unsafePerformIO uses an MVar to synchronize things
17:36:31 <JoeyA> e.g. if you use getContents, then read the result with two threads.
17:36:33 <nwf> OK, then I have crossed wires in my head.
17:36:42 <kmc> nwf, for one thing, MMR only applies when you haven't written a type signature yourself
17:36:50 <edwardk> unsafeDupablePerformIO on the other hand does not
17:36:57 <ddarius> nwf: You are thinking of the value restriction in ML.
17:37:05 <monochrom> so eventually some committee decided to specialize "monochrom = 2" to be non-polymormphic to please those surprised people
17:37:08 <nwf> ddarius: Oh right, duh.  Thank you.
17:37:51 <edwardk> kmc: well, determining what function that is redundantly isn't a problem, and each person evaluating it gets their own answer.
17:37:58 <edwardk> kmc which is precisely correct
17:38:24 <ddarius> JoeyA: You need to write more assembly.
17:38:25 <nwf> kmc: OK, so what _is_ the dubious rationale for MMR?
17:38:26 <edwardk> remember it is a function (even if it takes a 0 byte, 0 register input)
17:38:27 <kmc> i meant the thunk of type (# a, State# RealWorld #)... but as I type this i realize that can't be a thunk, of course
17:38:33 <Eduard_Munteanu> So the only atomic op is when you actually fill the thunk with the result?
17:38:33 <kmc> nwf, "x :: Int; x = 2 + 2" is a top-level thunk, and the addition should be performed only once.  but "x :: (Num a) => a; x = 2 + 2" is like a function from a Num typeclass dictionary, and therefore the addition can be performed over and over
17:38:35 <edwardk> exactly
17:38:49 <JoeyA> ddarius: Hmm.
17:38:52 <kmc> edwardk, but forcing the application to get at 'a' still seems like a problem
17:39:09 <JoeyA> It could be that a lot of my time was spent figuring out how to implement what I was working on (a garbage collecting memory allocator).
17:39:12 <kmc> nwf, so basically, accidental polymorphism can destroy sharing
17:39:17 <JoeyA> rather than actual coding.
17:39:56 <Eduard_Munteanu> JoeyA: you might try the dirty BoehmGC if you don't feel like doing it yourself
17:40:03 <ddarius> JoeyA: Well, one issue when learning assembly is learning how to recreate all the high-level constructs you are used to (and some you may not be used to) so that you can get back to programming "in-the-large" again.
17:40:09 <JoeyA> Eduard_Munteanu: I was coding an allocator like that for 68000.
17:40:10 <Eduard_Munteanu> *dirty BoehmGC approach
17:40:10 <kmc> and so the Haskell 98 committee decided to restrict the amount of polymorphism you get without a type signature, in order to make it easier for beginners to reason about the performance of their Haskell programs
17:40:13 <edwardk> why? you have a function, applying the function to a State# RealWorld is what you use to get the (# a, State# RealWorld #) out of it. two people doing that are both trying to perform an IO action, and as you said, that isn't a result of kind * that you can seq it
17:40:13 <kmc> (pause for laughter)
17:40:17 <JoeyA> I'm aware of BoehmGC.
17:40:55 <edwardk> er that you can seq
17:40:59 <kmc> *nod*
17:41:00 <nwf> kmc: Their hearts were, perhaps, in the right place, at least.
17:41:11 <Eduard_Munteanu> Yeah, it makes you wonder if Helium isn't the actual goal of Haskell' :P
17:41:26 <kmc> it's a fine goal; it's just that MMR is a drop in the bucket
17:41:34 <kmc> it causes more problems than it solves
17:41:41 <kmc> i think this is widely acknowledged
17:41:44 <nwf> Does the MMR also influence which AT equalities come into being during inference?
17:41:58 <Eduard_Munteanu> Think... Smooth Haskell.
17:42:03 <kmc> i don't know of any special interaction between MMR and asstypes
17:42:13 <kmc> the behavior you're seeing makes sense without one
17:42:25 <mm_freak_> asstypes
17:42:28 <ddarius> The monomorphism restriction definitely does have fun interactions with implicit parameters.
17:42:28 <kmc> btw, you can straight-up turn off MMR in GHC
17:42:30 <monochrom> hey! don't call my favourite extension "asstype", you asstype!
17:42:45 <kmc> the ass is a beloved and useful animal
17:43:02 <monochrom> however with "foo = mkfoo" it is simply because mkfoo is a class method, so type class is involved
17:43:18 <hpaste> nwf pasted “MMR AT?” at http://hpaste.org/50770
17:43:31 <mm_freak_> for some people the ass is just a beloved and useful part of beloved animals
17:43:35 <nwf> I haven't pared it down to a minimal example quite as well as I could, sorry.
17:43:36 <mm_freak_> but we're getting way off
17:43:55 <ddarius> "the ass is wild; the donkey is domesticated."
17:44:18 <nwf> I was going through a paper I'm working on and deleting "superfluous" type signatures and was surprised when my code no longer checked. ;)
17:44:21 <incluye> speaking of wild asses
17:44:29 <zachk> #haskell-blah :)
17:44:38 <mm_freak_> superfluous type signatures?
17:45:05 <monochrom> if you want to get rid of some type signatures, NoMonomorphismRestriction may help
17:45:13 <nwf> mm_freak_: Well, my advisor objects to seeing type signatures everywhere, since he is a LISP/C/C++ person. =P
17:45:22 <monochrom> ha ha ha
17:45:34 <Eduard_Munteanu> I get LISP, but the other ones?
17:45:35 <nwf> _I_ think they're helpful, but I am on the losing side of this argument, it seems. =P
17:45:38 <ddarius> nwf: C and C++ have "type signatures" everywhere.
17:45:38 <mm_freak_> nwf: C and C++ have type signatures everywhere, too
17:45:52 <monochrom> otoh a good use of omitting type signatures is when you want to find out what is inferred
17:46:01 * BMeph thinks of them as "type suggestions"... ;)
17:46:02 <ion> C and C++ don’t even have type inference, they need more type signatures.
17:46:08 <iFire> http://goo.gl/N5t6t Startup Genome Report PDF a research study on 650+
17:46:08 <iFire> web startups on what makes Silicon Valley startups successful.
17:46:13 * mm_freak_ thinks of them as specifications
17:46:14 <iFire> oops
17:46:17 <iFire> wrong channel
17:46:20 <JoeyA> C++11 has the auto keyword, which is sort of like type inference.
17:46:23 <dalaing> auto has improved a bit in C++11
17:46:31 <JoeyA> It means the basic for loop isn't horrible.
17:46:32 <iFire> don't ban me D:
17:46:38 <ddarius> Key word being "a bit."
17:46:41 <nwf> Well, I suppose I should say that he didn't think my types were helpful. =P
17:46:43 <kmc> it's C++11 now?
17:46:48 <JoeyA> for (auto i = vec.begin(); i != vec.end(); ++i)
17:47:06 <kmc> that's still a bit more verbose than 'map'
17:47:16 <ash_> there is std::map as well
17:47:23 <JoeyA> (I hate the ++i syntax, but in C++, it's supposedly better than i++)
17:47:24 <monochrom> but it is not map. it is mapM_
17:47:25 <nwf> In any case, is it the MMR that causes the loss of inference for vfcs_astep in http://hpaste.org/50770 ?
17:47:34 <ddarius> JoeyA: Yes, it is.
17:47:44 <Eduard_Munteanu> How so?
17:47:48 <mm_freak_> the average C programmer would never think that the world of types i any more than specifying what arguments a function takes and what it returns
17:48:03 <monochrom> yes nwf
17:48:08 <JoeyA> ddarius: Indeed, due to the fact that the implementation of postincrement has to save the original version to return it.
17:48:20 <monochrom> oh wait, maybe not
17:48:23 <Eduard_Munteanu> Performance-wise? Most compilers would have an easy time with that.
17:48:33 <JoeyA> That's what I was thinking.
17:48:37 <dalaing> it's commonly overloaded
17:48:47 <Eduard_Munteanu> Ah.
17:48:50 <ddarius> Eduard_Munteanu: Post-increment can be arbitrarily overloaded.
17:48:52 <dalaing> ie custom iterators for data structures
17:48:59 <ash_> i think the idiomatic c++11 war of iterating a list is: for (auto &a : my_array) { ... }
17:49:01 <monochrom> well, if mmr is the reason, the error message tells you
17:49:26 <JoeyA> ash_: What if you want to delete an item as you go along?
17:49:28 <nwf> (Only slightly related) Postfix-increment operators are my favorite misfeature of PHP.  $z = "z"; $z++; now $z contains "aa".
17:49:32 <dalaing> as long as people are sane and preserve the semantics then preincrement can be a big win
17:49:47 <nwf> monochrom: The error messages are right there above it in the paste -- they are failures to deduce AT equalities, nothing about the MMR.
17:49:56 <nwf> Thus my surprise.
17:50:20 <mm_freak_> nwf: be sure not to write $z = z…  it will do exactly the same, if you don't mind the warning message
17:50:22 <dalaing> I'm quite new to Haskell, but it's already making me a bit depressed in my C++ day job
17:50:25 <JoeyA> ash_: I found out very quickly that, in cases where the for loop body grows and grows, using explicit iterators becomes inevitable.
17:50:57 <mm_freak_> PHP is braindead enough to even make sense of obvious typos
17:51:00 <MRDUDEMAN> Haskell has that ability....luckily python hasnt exploded my mind
17:51:08 <monochrom> nwf: you know, you can find out for sure if you change "vfcs_astep" to "vfcs_astep ()"
17:51:10 <nwf> monochrom: However, {-# LANGUAGE NoMonomorphismRestrction #-} does, indeed, allow inference to go forward.
17:51:23 <nwf> Sorry for noise induced by not testing that first.
17:51:24 <monochrom> ok that's good too
17:51:55 <mm_freak_> we should introduce {-# LANGUAGE PHP #-}
17:52:06 <mm_freak_> $main :: IO ()
17:52:10 <ion> {-# LANGUAGE MagicQuotes #-}
17:52:12 <mm_freak_> $main = $return ()
17:52:24 <MRDUDEMAN> good idea mm freak
17:52:27 <nwf> http://www.addedbytes.com/blog/if-php-were-british/
17:52:46 * ddarius doesn't think Haskellers could go as far as PHP even as a joke.
17:53:10 <Eduard_Munteanu> Heh, "perchance ... otherwise"
17:53:21 <mm_freak_> ddarius: placing $ in front of variables wouldn't suffice anyway
17:53:27 <ddarius> @where haskerl
17:53:27 <ash_> JoeyA: if you want to ve able to delete the item form the list i guess you'd need to just use an iterator
17:53:28 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
17:53:48 <mm_freak_> the program 'print x' should not fail, if x is not defined
17:54:03 <mm_freak_> it should silently assume that the programmer actually meant the string "x", just like PHP does
17:54:21 <kmc> but error messages are scary!
17:54:29 <kmc> the computer called me dumb and hurt my feelings
17:54:48 <kmc> better to just make up some insane interpretation of what i meant and go with that
17:54:56 <mm_freak_> $main :: CanWork (IO ())
17:55:12 <incluye> yeah I think haskell would be a lot more accessible if it was more like PHP
17:55:14 <mm_freak_> $compose :: CanWork a -> CanWork b -> CanWork c
17:56:09 <MRDUDEMAN> i went to the php founders talk rasmus and he mentioned that haskell was what he was working on next, trying to merge them
17:57:46 <mm_freak_> ok, daily PHP rant committed…  you may continue
17:58:05 <mm_freak_> (sorry guys, but as a haskell programmer working with PHP really hurts your brain)
17:58:15 <incluye> at least it's straightforward
17:58:26 <ddarius> mm_freak_: I don't think that antecedent is necessary.
17:59:02 * copumpkin thinks hakarl would make a good name for a haskell package
17:59:10 <MRDUDEMAN> i agree with that statement
17:59:15 <copumpkin> or hákarl, I guess
18:00:29 <mm_freak_> ddarius: i'll try to suppress it in the future, but it's like only haskellers ever understand this
18:02:52 * ddarius doesn't understand working with PHP.
18:03:04 <incluye> errybody knows it
18:03:08 <incluye> and all the webhosts allow it
18:03:17 <kmc> maurer_, thanks for the tip on the listings package
18:03:21 <kmc> it's working really well
18:03:54 <kmc> i'll blog soon about converting my markdown->s5 slides to markdown->beamer
18:05:36 <mm_freak_> incluye: people never give /technical/ reasons to prefer PHP over some other language, even when it comes to mainstream languages
18:06:23 <MRDUDEMAN> has anyone here come up with any advanced applications for haskell, after all this is the future cool language, who really wants to be a php programmer in 2504
18:06:34 <incluye> mm_freak_: there /are/ no technical reasons to prefer PHP over /any/ other language
18:06:39 <ddarius> "I use PHP in case I forget my password to my company's servers."
18:06:52 <copumpkin> lol
18:06:56 <mm_freak_> lol
18:07:18 <mm_freak_> MRDUDEMAN: i have written real world applications in haskell, mostly network services
18:07:28 <mm_freak_> also my new homepage is written in haskell
18:08:00 <Cale> mm_freak_: what is the url?
18:08:01 <MRDUDEMAN> thats awesome!
18:08:10 <mm_freak_> Cale: http://coder.mx/
18:08:16 <mm_freak_> but it's not finished
18:08:34 <Cale> nice and fast :)
18:08:45 <MRDUDEMAN> wow that was fast
18:08:45 <mm_freak_> haskell + postgresql is fast =)
18:09:15 <copumpkin> your about-me is empty
18:09:18 <copumpkin> or rather, missing
18:09:22 <mm_freak_> copumpkin: missing
18:09:33 <sm> hey MRDUDEMAN, I went to that talk and heard nothing about haskell, kind of the contrary
18:10:04 <mm_freak_> my current homepage is still primary and will stay primary, until i get some free time to work on coder.mx
18:10:06 <sm> was it right at the end ? another city ? I dozed.. ?
18:10:46 <mm_freak_> the current site is sort of written in haskell…  it was generated by hakyll and not updated since more than a year
18:11:02 <MRDUDEMAN> sm i personally asked him about it after the talks, just to see what he was doing..
18:11:03 <mm_freak_> with the new site i'm switching to dynamic using the yesod framework
18:11:31 <MRDUDEMAN> true the talks really didnt focus on anything haskell
18:11:56 <ddarius> mm_freak_: So that it can dynamically be not updated for a year?
18:12:18 <mm_freak_> ddarius: i hope not =)
18:12:22 <JoeyA> lol
18:13:14 <JoeyA> The generic problem is (I think): being engrossed in implementing a solution, finishing, and not knowing how to use it.  Happens to me a lot.
18:13:20 <mm_freak_> keeping hakyll sites up to date i found a bit inconvenient…  seems like using arrows, where you really should use a monad
18:13:23 <MRDUDEMAN> sm what kind of projects do you work on
18:14:23 <sm> MRDUDEMAN: cool
18:14:42 <sm> I work on haskel by night (hledger etc.) and large PHP ERP app by day
18:15:14 <sm> and I've come to see PHP does have some technical strengths
18:16:07 <mm_freak_> sm: for example …?
18:16:30 <sm> I have forgotten :)
18:16:31 <ion> It has this great feature which makes all incoming strings safe, making SQL injection attacks impossible.
18:16:48 <mm_freak_> it also has this great feature that you never get error messages
18:16:58 <mm_freak_> your programs work out of the box, no matter what bullshit you write
18:17:06 <sm> but eg simplicity, the clean-slate per request and interpreted execution model
18:17:18 <mm_freak_> it's "require_once"-based module system is also awesome
18:17:20 <sm> good debugging and tracing tools is another
18:17:28 <sm> relatively good
18:18:13 <mm_freak_> it also tells you that, yes, 3 is larger than manhattan
18:18:32 <sm> mm_freak you don't need to tell me all the reasons it's crap, I know :)
18:18:43 <mauke> simplicity? what
18:18:47 <mauke> php doesn't even have arrays
18:19:14 <incluye> sure it does
18:19:19 <incluye> it's the same thing as a hash
18:19:20 <mm_freak_> incluye: no, it doesn't
18:19:24 <incluye> I know
18:19:27 <ion> incluye: Yeah, just like JavaScript has integers.
18:19:37 <sm> it's not just about language features
18:19:38 <incluye> tell you what, as I picked up PHP as my first language, that confused me once I moved to other languages
18:19:39 <ion> It’s the same thing as a float.
18:19:55 <incluye> "wait, associative and non associative arrays are different? o_O"
18:19:57 <mauke> what php has are hash tables with a (doubly?) linked list through the values
18:19:59 <JoeyA> IEEE double-precision floats can losslessly encode 53-bit integers, signed or unsigned.
18:20:17 <mauke> this list provides a user-visible ordering
18:20:25 <JoeyA> And recent versions of JavaScript support typed arrays.  I don't know the details, though.
18:20:27 <mm_freak_> incluye: even if you use only integral indices you still won't get an array in PHP…  and by chance you will get this crappy O(n) lookup
18:20:36 <mm_freak_> yes, PHP does not have any trees for lookup
18:20:39 <incluye> O(n) is crappy?
18:20:45 <mm_freak_> rasmus probably doesn't know what a tree is anyway
18:20:49 * incluye does not understand the O() thing very well
18:20:55 <incluye> what is a good lookup time?
18:20:55 <mm_freak_> because as he states himself, he hates programming
18:21:04 <mauke> incluye: O(1) or O(log n)
18:21:04 <mm_freak_> incluye: an array should have O(1)
18:21:05 <MRDUDEMAN> sm do you think Haskell would work well for fast online voting
18:21:21 <sm> MRDUDEMAN: for someone who wants to work in Haskell ? sure
18:21:29 <incluye> oh
18:22:08 <sm> MRDUDEMAN: gonna build an app ?
18:22:22 <MRDUDEMAN> yah something that needs to be super fast
18:22:31 <MRDUDEMAN> open source app
18:22:39 <mm_freak_> sm: i have often found that in PHP someone has already implemented what i needed…  if it does /exactly/ what you need, fine, but in corporate environments you usually have to tweak a bit
18:22:51 <mm_freak_> i found that tweaking existing solutions takes longer than writing custom ones
18:23:04 <mm_freak_> and both take longer than implementing the same thing in haskell, no matter what it is
18:23:29 <sm> mm_freak_: maybe so, I used a PDF lib a while back that I would have taken (me) longer in haskell
18:23:41 <MRDUDEMAN> mm_freak when working in magento i find that to be the case, its like turning a huge ship
18:24:55 <sm> after that Rasmus talk I had a vision of more of PHP's good bits for haskell
18:25:00 <hpaste> bfig pasted “monadic for” at http://hpaste.org/50773
18:25:17 <sm> Hypertext Pages in Haskell, I though
18:25:19 <sm> t
18:25:26 <bfig> i'm having trouble with that code, i'm just trying to Y-combine a for iterator for Int-> IO ()
18:25:29 <mm_freak_> sm: already there
18:25:33 <sm> HSP is part of the way there
18:25:35 <MRDUDEMAN> haha after that talk i decided i was going to code my own language, but then i got tired:)
18:25:36 <mm_freak_> sm: most of what you need is already there
18:25:39 <bfig> what is the problem with my code_ ]
18:27:00 <mm_freak_> bfig: why not just foldM?
18:27:17 <bfig> mm_freak_, just having fun with the Y combinator :D
18:27:56 <mm_freak_> bfig: then most likely mfix is more like what you want
18:27:58 <bfig> mm_freak_, can you spot the error? it thinks my (a,b,c) is a sort of monad triple for what i saw
18:28:18 <bfig> mfix is monadic fix?
18:28:19 <sm> mm_freak_: I'd like to be able to run a haskell server that watches a directory tree and serves anything I put in there - static files, markup documents, dynamic templates and and scripts, many syntaxes & languages
18:28:22 <mm_freak_> bfig: yes
18:28:29 <sm> with the same dynamism as mod_php
18:28:32 <mm_freak_> bfig: fix can handle pure code only
18:29:02 <bfig> so if i change fix for mfix it will be ok_
18:29:04 <bfig> ??
18:29:07 <MRDUDEMAN> thats a cool idea sm
18:29:39 <mm_freak_> bfig: unlikely…  look up the definition of mfix
18:29:44 <mm_freak_> :t mfix
18:29:45 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
18:29:57 <bfig> i'm checking it
18:30:22 <mm_freak_> sm: that's not haskell's part…  that's your webservers part
18:30:45 <mm_freak_> sm: i usually have applications as separate programs listening on localhost on some high port
18:31:00 <mm_freak_> and in front i have an nginx, which does the dispatching
18:31:25 <mm_freak_> that way i can set the rules of what kind of location triggers what kind of response
18:31:37 <sm> sure, I'm not saying haskell the language needs to do this, just that this would make it possible to program web apps with haskell with some of the same facility as in php
18:32:04 <mm_freak_> sm: if you want to do that, use PHP
18:32:12 <mm_freak_> haskell simply doesn't work like that
18:32:25 <sm> mm_freak_: see where I wrote "with haskell" ? :)
18:32:33 <Jafet> @faq can PHP be written in Haskell?
18:32:33 <lambdabot> The answer is: Yes! Haskell can do that.
18:32:35 <ion> Putting the code into the public directory with the program filename being chosed based on the URL would be utterly horrible.
18:32:43 <sm> I want to develop that way with haskell. Why shouldn't I ?
18:33:03 <sm> HPH is going to be awesome, I insist!
18:33:05 <mm_freak_> sm: because then you would essentially have PHP
18:33:15 <mm_freak_> just with a better type system
18:33:37 <mm_freak_> see how happstack and yesod work and why file-based web services suck
18:34:16 <mm_freak_> that's also the reason why most serious PHP applications have only a single entry PHP file, and all others are only allowed to be executed by require* or include*
18:34:33 <sm> mm_freak_: I've worked with happstack and yesod too, and there are times when that's what you want, but you can't say one way fits all needs
18:35:03 <mm_freak_> sm: i say exactly that
18:35:07 <sm> well alright you can
18:35:35 <sm> I say there are some good bits we could bring from the PHP style of development
18:35:53 <mm_freak_> and those would be …?
18:35:59 <sm> I mentioned them above
18:36:05 <sm> dynamism, eg
18:36:13 <sm> quick edit-test cycle
18:36:25 <mm_freak_> i have a quick edit/test cycle
18:36:27 <sm> simpler errors
18:36:37 <mm_freak_> what are simpler errors?
18:36:55 <sm> less cognitive load, applicable to mainstream programmers so acceptable to clients
18:37:23 <mm_freak_> so you're essentially asking haskell to become PHP
18:37:30 <sm> no
18:38:14 <mm_freak_> less cognitive load is simply not possible, because then you would have to change the language
18:38:24 <mm_freak_> the error messages are perfectly fine for haskell programmers
18:38:38 <sm> not necessarily, there are things that can be done. It's not just the language, but the ecosystem
18:38:49 <mm_freak_> and i don't see why a non-haskell programmer should be able to understand haskell error messages, without understanding haskell
18:38:52 <sm> and haskell errors messages are evolving
18:39:29 <sm> anyway, sorry I can't argue more on an empty stomach.. afk a bit
18:39:42 <MRDUDEMAN> i enjoy good debate
18:39:46 <mauke> php -r '::'
18:39:52 <mauke> good error messages
18:40:06 <ion> Mind pasting the output?
18:40:10 <mm_freak_> mauke: good point =)
18:40:21 <mauke> PHP Parse error:  syntax error, unexpected T_PAAMAYIM_NEKUDOTAYIM in Command line code on line 1
18:40:24 <mauke> Parse error: syntax error, unexpected T_PAAMAYIM_NEKUDOTAYIM in Command line code on line 1
18:40:26 <mm_freak_> ion: would get you flood-kicked off here
18:40:27 <mauke> ^ exact output
18:40:38 <ion> Ah, good old pamaayim nekudotayim. :-)
18:40:45 <mauke> twice!
18:40:47 <ion> paamayim even.
18:40:55 <bfig> mm_freak_, i don't understand... am i forced to use bind when i use monads?
18:41:05 <bfig> instead of ie, function application?
18:41:21 <mauke> bfig: parse error at "instead of that is"
18:41:23 <ion> That’s a bit like asking whether you’re forced to use + when you use addition.
18:41:27 <mm_freak_> bfig: if you want the structure of the computation to be dependent on effects, yes
18:42:02 <mm_freak_> bfig: for example if you want to print a line of text a number of times dependent on what the user types, you need to bind
18:42:09 <ion> Well, you could use fmap and join instead if the Monad typeclass had (>>=) and join.
18:42:24 <bfig> test g = mfix (\f (acc,cond,aplus) -> if (cond acc) then return () else acc >>= g >> f (aplus acc, cond, aplus))
18:43:17 <bfig> after the else things go wrong, i don't understand. i send acc's value to g, which does something and binds to f (...)
18:43:37 <mm_freak_> :t mfix
18:43:38 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
18:44:04 <mm_freak_> first find out what the 'a' is in your case
18:44:18 <bfig> you mean i have to return (Int, Int->Bool, Int->Int) ?
18:44:55 <JoeyA> mauke: It prints one time to stdout (because display_errors is enabled), and again to stderr so the error can be seen in CLI output.
18:45:01 <bfig> no, actually i have some weird stuff inside. i have ((Int-> IO ()) -> m (Int, Int->Bool, Int->Int_
18:45:09 <bfig> no, actually i have some weird stuff inside. i have ((Int-> IO ()) -> m (Int, Int->Bool, Int->Int)
18:45:35 <mauke> JoeyA: hahaha
18:45:38 <MRDUDEMAN> mm_freak have you tried any filtering in Haskell, results.
18:45:40 <bfig> ) -> m (Int, Int->Bool, Int->Int)
18:45:54 <mm_freak_> bfig: try writing your inner function independently at first
18:46:01 <mm_freak_> then apply mfix
18:46:06 <mm_freak_> write a type signature!
18:46:14 <JoeyA> Of course, it's silly.  And T_PAAMAYIM_NEKUDOTAYIM is a horrible identifier, if the source isn't written in Hebrew.
18:46:20 <bfig> i wrote the type and it breaks :(
18:46:25 <monochrom> this is not a use case of mfix. go back to fix. if that "doesn't work", it is because of some other reason, not because of fix vs mfix
18:46:27 <mm_freak_> MRDUDEMAN: what kind of filtering?
18:46:30 <bfig> test :: (Int-> IO ()) -> (Int, Int->Bool, Int->Int)-> IO ()
18:46:37 <JoeyA> (Un?)fortunately, most compilers don't support Unicode identifiers.
18:47:37 <monochrom> > fix (\f n -> if n==0 then Just () else f (n-1)) 10
18:47:38 <lambdabot>   Just ()
18:47:41 <monochrom> see? works
18:47:51 <monochrom> mfix would be wrong for that
18:48:40 <monochrom> if you're going for control-flow recursion, it's definitely fix, not mfix. mfix doesn't even do control-flow recursion
18:49:25 <MRDUDEMAN> databases, taking that data and quickly displaying it, similiar to monster jobs
18:50:05 <mm_freak_> MRDUDEMAN: sure, but that's not really haskell work…  most database stuff i'm doing in PL/PgSQL
18:50:38 <monochrom> enter this at your ghci prompt: xs <- mfix (\x -> putStrLn "hi" >> return (():x))
18:50:39 <mm_freak_> bfig: monochrom is right…  sorry for the confusion
18:51:01 <monochrom> it doesn't even print "hi" more than once. not control-flow recursion
18:51:04 <MRDUDEMAN> that makes sense.
18:51:34 <monochrom> it is only value recursion for the x there. do a "take 10 xs" to see
18:51:38 <mm_freak_> apparently mfix is /only/ for value recursion
18:51:58 <ddarius> The value can be a function.
18:52:58 <monochrom> (and also notice that getting xs printed or forced does not lead to printing more "hi"s. this is not unsafeInterleave lazy I/O)
18:53:40 <mm_freak_> has anyone ever used mfix outside of FRP?
18:54:01 <dalaing> I just had a look for more info on the MonadFix typeclass, found this interesting: http://www.haskell.org/haskellwiki/MonadFix
18:54:25 <ddarius> mfix is letrec in an impure language.  monochrom's example would look like let xs = letrec x = putStrLn "hi"; ():x in x in ... in an impure Caml-like language.
18:54:41 <monochrom> a monadic EDSL for writing down a circuit or cyclic graph needs mfix too
18:54:52 <kmc> mfix for IO, anyway
18:55:16 <kmc> some monads have control flow much more interesting than application of impure functions
18:55:22 <copumpkin> the usual example I've seen is a circular imperative linked list
18:55:31 <ddarius> kmc: letrec in Curry is also a case of mfix.
18:55:43 <monochrom> mfix is also nice if you want to set up a cyclic mutable linked list. (I guess it falls under "writing down a cyclic graph")
18:56:02 <bfig> i couldn't understand a single thing you said :( (yet!)
18:56:33 <mm_freak_> i found mfix useful in FRP…  never used it outside of it
18:56:44 <mm_freak_> and mostly used it only inside of ArrowLoop
18:56:55 <kmc> @djinn (a -> ((a -> r) -> r)) -> ((a -> r) -> r)
18:56:55 <lambdabot> -- f cannot be realized.
18:57:05 <ddarius> It's usually much better to use recursive do-notation rather than mfix directly.
18:58:10 <monochrom> actually I merge "use mfix" and "use mdo" and "use do rec" in my discussion above
18:59:00 <monochrom> anyway I tried to give some tolerable examples in my http://www.haskell.org/haskellwiki/MonadFix
18:59:10 <mm_freak_> i never understood how monadic FRP works anyway
18:59:28 <bfig> i don't understand this part, if i try to sequence two monads with a value in the middle pulled from behind, how do i need to do?
18:59:44 <mm_freak_> bfig: sequence two monads?
18:59:50 <mm_freak_> you mean actions?
18:59:53 <monochrom> and anyway have you seen my http://www.mail-archive.com/haskell-cafe@haskell.org/msg92742.html lately? the first two stanzas have to do with "do rec" :)
18:59:55 <ion> With a value in the middle pulled from behind? Sounds dirty.
18:59:55 <bfig> ie, i have  do fMonad, sMonad value;
19:00:16 <bfig> that translates to fmonad >> value >>= sMonad ?
19:00:29 <ion> @undo do fMonad, sMonad value;
19:00:30 <lambdabot>  Parse error at ";" (column 24)
19:00:31 <ion> @undo do fMonad, sMonad value
19:00:32 <lambdabot> (fMonad, sMonad value)
19:00:33 <monochrom> yeah try to say "IO is a monad, getLine is an action", not "getLine is a monad"
19:00:42 <mm_freak_> bfig: c1 >>= c2
19:00:54 <ion> Well, do fMonad, sMonad value isn’t valid in the first place. Ignore that output of @undo.
19:00:59 <mm_freak_> is the same as:  do x <- c1; c2 x
19:01:19 <monochrom> (there was a very funny word in place of "action" but it fell out of favour 2 days after it was brought up)
19:01:44 <bfig> i want to do this: 1)execute computation x, 2) execute computation y:: Int-> m a with  i:: Int as entry value
19:02:02 <ion> do x; y i
19:02:08 <monochrom> where did i come from?
19:02:19 <coppro> or x >>= y
19:02:23 <monochrom> oops i guess wrong channel
19:02:31 <dalaing> hehe
19:02:40 <monochrom> /privmsg #philosophy where did I come from?
19:02:46 * BMeph unsafeCasts teh mobits into the Outer Darkness!
19:02:49 <ion> from YOUR MOMMA
19:02:50 <dalaing> if lambdabot answers I'm out of here
19:02:54 <bfig> ion, with bindings?
19:02:59 <ion> Wait, this your momma joke didn’t work very well.
19:03:07 <monochrom> @vixen where did I come from?
19:03:07 <lambdabot> Huntington Beach, California
19:03:17 <monochrom> interesting!
19:03:28 <ddarius> @vixen Where are we ALL from?
19:03:29 <lambdabot> nevermind about that
19:03:32 <mm_freak_> bfig: look at the type signature of (>>=)
19:03:35 <mm_freak_> :t (>>=)
19:03:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:03:43 <MRDUDEMAN> La Canada, CA
19:03:48 <dalaing> I meant - if lambdabot is hanging out on #philosophy and answering things, I'm out of here
19:04:03 <bfig> how can i chain them together? i figured i could use >> Just i >>= sMonad
19:04:21 <bfig> ie, forget whatever was behind, use this nwe monad and feed it to the next
19:04:35 <mm_freak_> bfig: you're dealing with a single monad here
19:04:38 <digitteknohippie> http://paste.pocoo.org/show/466851/ hi! i'm running gentoo, trying to get "daskeb" to run, but it seems from this verbose output there's something wrong (?) almost like something isnt there... but it is.. isnt it?  what am i missing? can someone help clarify what this output means?  and why it mentions xmonad and xmonad-contrib, when this bot shouldnt need either...?
19:04:41 <monochrom> use >> to "forget what's from behind"
19:04:58 <monochrom> or you can write explicitly ">>= \_ ->"
19:05:22 <monochrom> getLine >> putStrLn "I don't care"
19:05:41 <bfig> monochrom, fMonad :: m a, sMonad :: b -> m c, i:: b => fMonad >> i >>= sMonad?
19:06:02 <monochrom> fMonad >>= sMonad i
19:06:06 <bfig> or  .. >> (\_ -> i ) >> = sMonad
19:06:12 <mauke> fmonad >> smonad i
19:06:20 <mauke> also, terrible names
19:06:33 <monochrom> which is the same as <ion> do x; y i
19:06:33 <bfig> i'm not using those names, just for reference (Firstmonad, Secondmonad)
19:06:44 <mm_freak_> bfig: please stop writing fMonad
19:06:53 <monochrom> you should call them "first action", "second action"
19:06:53 <MRDUDEMAN> :)
19:06:57 <mm_freak_> it's fComp, fAction, fValue, whatever…
19:06:58 <aavogt> edwardk: does wl-pprint-terminfo work in ghci? I get  can't load .so/.DLL for: curses (/usr/lib/libcurses.so: file too short)
19:06:59 <mm_freak_> but not fMonad
19:07:04 <JoeyA> or fm, sm?
19:07:04 <mauke> bfig: terrible names
19:07:15 <JoeyA> or m1, m2?
19:07:16 <monochrom> btw are you too busy asking to read answers? it certainly feels like everyone has to repeat everything now
19:07:16 <dalaing> how about walking through something like do (putStrLn "line1" >> putStrLn "line2" >> getLine >>= \x -> putStrLn x); ?
19:07:34 <edwardk> aavogt: good question. i may have broken it by including it directly =/
19:07:39 <bfig> ok, sorry :|
19:07:42 <edwardk> aavogt: what platform?
19:07:43 * BMeph prefers f'n'm and s'n'm, especially that second one... ;þ
19:07:59 <aavogt> linux
19:08:00 <ddarius> @google s-n-m theorem
19:08:01 <lambdabot> http://en.wikipedia.org/wiki/Smn_theorem
19:08:12 <aavogt> it works when I compile the file
19:08:24 <edwardk> aavogt: i'll set up a linux vm and see if i can come up with a nicer way to pull it in that makes ghci happy
19:08:44 <edwardk> might take a day or two
19:09:02 <edwardk> if you figure it out first, feel free to send me a patch
19:09:37 <edwardk> are you running ghci then just using the module or are you in the folder of the package trying to use the module?
19:10:22 <edwardk> there is also a flag that asks whether to try to use curses, you can probably disable that for now as a stop gap
19:10:54 <edwardk> it only uses it to get a more accurate dynamic column count
19:11:10 <parcs> i get the same error. it has to do with libcurses.so being a linker script on some distributions. ghci uses dlopen to dynamically load shared objects, and dlopen doesn't handle linker scripts.
19:11:35 <MRDUDEMAN> time to get back to writing code
19:11:46 <edwardk> ah
19:12:00 <edwardk> annoying
19:12:11 <aavogt> edwardk: http://hackage.haskell.org/trac/ghc/ticket/1883
19:12:33 <edwardk> just naming ncursesw breaks on a mac, using curses breaks on linux, hence the autoconf hell in a lot of the curses packages
19:12:47 * aavogt tries with libcurses as suggested there
19:13:05 <edwardk> if hscurses gets patched we're all good, and i can revert to using an external curses package
19:13:18 <edwardk> but for right now it doesn't build on 7.2.1
19:14:07 <edwardk> http://hackage.haskell.org/package/hscurses-1.4.0.0 names an old version of unix
19:14:40 <digitteknohippie> http://paste.pocoo.org/show/466851/ i dont understand the output of this.  it's acting like i'm missing some haskell module ('Network'), and complains about xmonad & xmonad-contrib, yet they shouldnt be involved with launching "daskeb". what am i missing?
19:15:08 <mauke> digitteknohippie: is that the wrong url?
19:16:02 <monochrom> what is daskeb?
19:16:04 <edwardk> submitting a patch directly to hscurses
19:17:01 <digitteknohippie> daskeb is a little bot i made.  digit's haskell bot.
19:17:07 <digitteknohippie> woah!  thnx mauke
19:17:22 <digitteknohippie> i missed that.  where'd the rest of it go... wgetpaste fail.  sry... one sec...
19:18:40 <digitteknohippie> http://paste.pocoo.org/show/466853/ should work now.  sorry about the wgetpaste fail.
19:19:29 <parcs> aavogt: 'ncursesw' works for me
19:19:30 <mauke> yeah, you are missing Network
19:19:38 <digitteknohippie> http://www.wastedartist.com/scripts/daskeb/daskeb.html (daskeb)
19:19:46 * ddarius stumbled across the GET command yesterday.
19:20:07 <mauke> ddarius: libwww-perl, yo
19:20:15 * digitteknohippie facepalms.  oh, simple as installing dev-haskell/network
19:21:00 <edwardk> parcs: changing the extra-libraries to ncursesw?
19:21:02 <monochrom> do you not have the package "network" installed?
19:21:21 <ddarius> monochrom: Why would a bot need networking?
19:21:41 <parcs> edwardk: yes
19:21:43 <mauke> did you mean: notworking
19:21:55 <edwardk> parcs: yeah the problem there is it doesn't work on a mac then =/
19:22:20 <ddarius> mauke: Aren't those synonymous?
19:22:20 <edwardk> parcs: i can make it have a flag that switches to that i guess, let me try
19:22:20 <monochrom> I don't know. but "/home/digit/bin/daskeb.hs:1:7: Could not find module `Network'" is pretty strong evidence that the author explicitly wrote "import Network"?
19:22:31 <monochrom> especially since the line number is 1
19:22:52 <monochrom> (hey, the column number is 7 which also matches)
19:23:16 <digitteknohippie> been ages since i did anything with it, or anything in haskell except update my xmonad keybinds.
19:23:46 <parcs> edwardk: ah, that sucks
19:24:07 <digitteknohippie> thnx for blowing the dust of my brain guys.  srsly.  :) :) :) all's well now.
19:24:08 <edwardk> trying to see if i can make a flag that tries the ncursesw then falls back and if that will do the right thing
19:24:51 <edwardk> that didn't work out
19:25:39 <ion> A local libncursesw.so wrapper that dynamically links to the real one!
19:25:59 <edwardk> parcs: does extra-libraries: ncurses work for you?
19:26:22 <parcs> edwardk: not in ghci
19:26:29 <edwardk> bah
19:26:37 <parcs> it resolves to a linker script
19:26:38 <edwardk> same dynamic linker script issue?
19:26:44 <parcs> let me double check though
19:27:05 <edwardk> coz ncurses and ncursesw are a bit different
19:27:14 <edwardk> so i had hope that those would be non-scripts
19:28:02 <parcs> yeah, all variants eventually get resolved to ncursesw here
19:28:13 <edwardk> blah
19:28:48 <ddarius> Horseradish corn?  Let's see...
19:29:14 <monochrom> is yummy
19:30:41 <edwardk> trying to see if i can get away with swapping to ncursesw by requiring brew install ncursesw on a mac
19:31:57 <edwardk> gah, of course homebrew's ncursesw is either non-existent or broken
19:36:23 <edwardk> does anyone know the best way to get in touch with stephan wehr?
19:39:26 <MRDUDEMAN> hmm
19:40:30 <MRDUDEMAN> @skogsbaer
19:40:30 <lambdabot> Unknown command, try @list
19:40:43 <MRDUDEMAN> http://twitter.com/#!/skogsbaer
19:41:19 <MRDUDEMAN> Stephan wehr
19:42:13 <parcs> edwardk: what are you using ncurses for, anyway?
19:42:28 <edwardk> initScr, peeking at the column count and endwin ;)
19:42:51 <edwardk> i may have wl-pprint-terminfo flipped around to use autoconf in a sec
19:42:57 <edwardk> i'll need a linux test though
19:48:29 <edwardk> basically when i call displayLn to show pretty printed output in wl-pprint-terminfo it quickly sets up and tears down ncurses to get the column width
19:48:35 <edwardk> but i don't use it beyond that for now
19:48:47 <edwardk> soon it'll come back when i do a haskeline clone but thats it for now
19:51:13 <edwardk> okay. it works with autoconf on a mac, do you want to pull and try it on from github or from hackage?
19:52:14 <parcs> i'll pull from github
19:52:30 <edwardk> git@github.com:ekmett/wl-pprint-terminfo.git shoudl theoretically work
19:52:51 <edwardk> the autoconfing was fairly rapid though so i may have missed something
19:53:03 <mdwright_laptop> Is there a command to clear the darcs cache?
19:54:28 <parcs> edwardk: config.status: error: cannot find input file: `cbits/config.h.in'
19:54:41 <edwardk> ah run autoheader
19:54:44 <edwardk> i'll add it to the repo
19:54:58 <ddarius> From Bayesian Notation to Pure Racket via Discrete Measure-Theoretic Probability in LambdaZFC"
19:55:48 <edwardk> pushed it to repo, autoheader should regen it otherwise
19:56:53 <edwardk> was missing cursed.h as well
19:58:44 <parcs> great success! (verified with 'ghci -package wl-pprint-terminfo-0.8.1')
19:58:50 <edwardk> yay!
19:59:10 <edwardk> pushing to hackage
19:59:15 <edwardk> cd ..
19:59:19 <edwardk> er woops
20:00:14 * hackagebot wl-pprint-terminfo 0.8.1 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.8.1 (EdwardKmett)
20:03:47 <edwardk> alright. updated trifecta.
20:05:14 * hackagebot trifecta 0.36.3 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.36.3 (EdwardKmett)
20:10:07 <parcs> nice :)
20:15:31 <kmc> parcs, out of curiosity, what are you using trifecta for?
20:20:03 <parcs> nothing yet :)
20:21:33 <tgeeky> edwardk: what are the three things in trifecta?
20:21:35 <tgeeky> one of them is ropes?
20:22:59 <kmc> ropes, dopes, and popes
20:23:13 <tgeeky> he put ze freaking pope in there!? mama mia!
20:24:33 <dalaing> iteratees, parsec and monoids, yeah?
20:26:32 <ddarius> Minus the iteratees, parsec, and monoids.
20:27:22 <tgeeky> hehe
20:27:32 <tgeeky> i was only going to (guessing-ly) rule out parsec
20:28:20 <dalaing> fair enough - I was just googling around earlier to see what it was, made the link from some slides
20:29:18 <tgeeky> someone needs to take a small army of grad students and (document && exemplarize) all of edwardk's work
20:35:24 <parcs> would anyone find use in an autoreload feature for ghci? it would automatically reload modified files/modules. should i bother bothering the ghc devs with this patch?
20:35:49 <tgeeky> yes
20:35:54 <tgeeky> you should
20:37:21 <_Ray_> i would like it
20:37:26 <parcs> my development cycle is currently save -> switch to ghci window -> :<Enter> -> switch back. this would be immensely helpful for me
20:37:32 <parcs> okay, great
20:43:21 <monochrom> not until they have "if the reload fails, revert state back to before reload" first
20:43:46 <ddarius> "if reload fails, delete source file"
20:43:56 <parcs> lol
20:44:29 <monochrom> because you may have typed "let x=2" some time ago and you certainly don't want to lose it just because of a recent type error in your source file plus auto-reload
20:44:50 <tgeeky> fair point
20:45:08 * ddarius writes printServer <- startPrintServer
20:45:48 <monochrom> see also http://www.mail-archive.com/haskell-cafe@haskell.org/msg92815.html
20:47:46 <monochrom> and apparently it is not just "let x=2" you will miss
20:48:52 <parcs> hmm
20:49:57 <tgeeky> run two ghci's, try loading in one first? :o
20:50:20 <monochrom> haha, that probably works for ":type" etc!
20:50:45 <tgeeky> like, shadow all of your input with GHCI to two background ghcis
20:51:06 <tgeeky> if a file changes, see if it reloads in one of them (if so, swap)
20:51:10 <monochrom> is that what the database people call two-phase commit? :)
20:51:54 <tgeeky> i hope not, because it sounds awfully ghetto to me
20:52:45 <ddarius> Run 3 ghcis in case there is a tie.
20:52:55 <monochrom> haha
20:53:39 <tgeeky> run 3+1, the +1 being designed by another company to ensure that you won't accidentially roll the vehicle too fast on re-entry
20:54:50 <parcs> heh
20:55:19 <parcs> monochrom: it seems that i fixed it with a 4 liner
20:55:51 <monochrom> sorry, you fixed what?
20:56:02 <parcs> "revert state back to before reload"
20:56:21 <parcs> if the reload fails, that is
20:56:32 <monochrom> oh! 4 lines sound too short. may I see them?
20:57:20 <parcs> sure let me isolate the changes
20:57:53 <monochrom> oh, changing 4 lines in ghci's source code?
20:58:18 <parcs> yeah
20:58:48 <monochrom> neato, you should post it to that haskell-cafe thread, so the world is saved
20:59:08 <lep> 7q
20:59:59 <monochrom> or maybe post it to the feature request ticket. ( ["milestone changed to " ++ i | i <- ghc versions] hahaha )
21:00:07 <parcs> it's probably too simple to be truely a fix, but maybe not :D
21:04:09 <parcs> actually this seems pretty solid
21:07:09 <swordtenchi> hello people
21:07:28 <tgeeky> hello person
21:08:31 <swordtenchi> :)
21:09:11 <swordtenchi> is it alright if I ask a question?
21:10:17 <monochrom> yes
21:10:21 <swordtenchi> coolness
21:12:05 <swordtenchi> so, I'm new to Haskell...it's quite an interesting way of thinking. But I'm told that the best way to learn is by doing; I'm pretty far into the "Learn You a Haskell" tutorial, but I was wondering if you knew a place with programming problems for newbs to bang their heads against the wall with
21:13:10 <swordtenchi> like maybe ideas for scripts or simple wxWidgets apps
21:13:14 <tgeeky> you could solve project euler problems
21:13:21 <tgeeky> oh. no, not the right kind of thing then.
21:13:36 <tgeeky> you could look at reactive-bannana
21:14:11 <dalaing> swordtenchi: I'm pretty new as well - seems like we're at a similar place - and looking for similar things
21:14:23 <tgeeky> http://www.haskell.org/haskellwiki/Reactive-banana/Examples
21:14:50 <dalaing> swordtenchi: I've been playing with "write yourself a scheme in 48 hours", which has been interesting so far
21:15:31 <swordtenchi> I'll check that out, thanks!
21:16:18 <swordtenchi> (hmm....looking at this, maybe I ought to forgo the GUI programming for now until I have monads under my belt)
21:16:25 <aspect_> maybe everyone will groan, but project euler is fun for exploring a new language or style
21:16:54 * Jafet groans.
21:16:58 <swordtenchi> XD
21:17:06 <tgeeky> that rather depends, imho, on your latent mathematical intuition and your definition of 'fun'
21:17:13 <dalaing> part of the reason I mentioned "scheme in 48 hours" was to submit it to the groan test
21:19:01 <Jafet> Writing scheme counts as an exercise, unless you wrote it in scheme...
21:19:55 <dalaing> I'm considering sticking my hand up to document / quick-check some libraries on Hackage before too long
21:19:55 <cmccann> first write scheme in scheme, then write haskell in haskell.
21:20:04 <cmccann> that sounds like a sensible progression.
21:20:15 <tgeeky> ignore him, he hasn't taken his medicine
21:20:23 <cmccann> haha.
21:20:26 <swordtenchi> lulz
21:20:46 <swordtenchi> confession: I got past the first 2 chap's in SICP before I got confuzzled by all the parentheses :P
21:20:48 <kmc> project euler is fun but it really does not exercise much of your language or style
21:20:50 <cmccann> it's all lambda calculus in the end, right? how different could it be?
21:21:31 <dalaing> I thought it was all Turing machines in the end?
21:21:33 <dalaing> :)
21:22:05 <cmccann> project euler is a good way to learn about a language if what you want to learn is how much more verbose it is than what those bastards who use J come up with.
21:22:11 <kmc> it's all rational number multiplication in the end
21:22:15 <kmc> http://en.wikipedia.org/wiki/FRACTRAN
21:22:53 <tgeeky> that wikipedia page is longer than it otherwise deserves to be
21:22:57 <tgeeky> modulo john conway
21:23:08 * Jafet sticks kmc's own Gödel-numbering into kmc
21:23:25 <kmc> it's not that long
21:23:34 <Jafet> That's what kmc said.
21:23:38 <tgeeky> yes, just longer than it deserves to be.
21:23:39 <kmc> there are much longer wikipedia pages about more obscure computing systems
21:23:58 <kmc> tgeeky, then delete some of it
21:24:12 <tgeeky> I do not want to piss off the knights of the wikipedia
21:24:19 <dalaing> swordtenchi: just our of interest - what kind of background are you coming from?
21:24:31 <tgeeky> it has the word 'esoteric' in the first sentence, so they will probably defend it with vigr
21:24:35 <tgeeky> vigor*
21:24:52 <swordtenchi> dalaing: another confession - I took diffeq and PDE, but I'm a political science student :P
21:25:18 <dalaing> hehe
21:25:39 <dalaing> nice
21:25:59 <swordtenchi> :P
21:26:16 <tgeeky> i came to the conclusion a few years ago, that political science is the least-sciencey thing with the word science in it
21:26:23 <swordtenchi> I'm sure there's a need for computational politics....everything's computationally analyzed nowadays
21:26:25 <dalaing> I was wondering more about what other languages you've used
21:26:44 * cmccann proposes the field of computational computer science
21:27:00 * tgeeky points to prior art
21:27:04 <swordtenchi> other languages? python...tried ruby, but as "beautiful" and "elegant" as it was, it really mystified me
21:27:05 <nisstyre> the Political model of Computation
21:27:32 <nisstyre> we use committees instead of functions
21:27:50 <kmc> tgeeky, where i come from the people with "political science" in their titles were studying game theory
21:27:53 <kmc> so yeah, it's not science, it's math
21:27:55 <Jafet> nisstyre: that's called Ada
21:28:12 <tgeeky> swordtenchi: though, some people seriously advocate (correctly, in my opinion) that there is a valid argument that law (legislation, at least) is very similar to writing code, except that it's done in the poorest way imaginable
21:28:30 <kmc> it's not the worst way imaginable
21:28:30 <nisstyre> legal documents should be written in esperanto
21:28:43 <cmccann> learning about game theory is a great way to make yourself unhappy when you realize just how stupid the way entire societies work is.
21:28:56 <tgeeky> kmc: yes, I realize that some PS study game theory
21:29:17 <tgeeky> kmc: and the most complicated class of games are...? those in which one can change the rules at every turn?
21:29:29 <kmc> i wouldn't know
21:30:04 <kmc> i doubt the game theorists have settled on a single "most complicated class of games" any more than the computer scientists have settled on a single "most complicated class of programs"
21:30:14 * cmccann likes games where the optimal solution is to irrevocably commit ahead of time to play in a suboptimal way.
21:30:25 <tgeeky> kmc: they have singled out the class I mentioned
21:30:32 <kmc> cmccann, like http://wiki.lesswrong.com/wiki/Parfit's_hitchhiker ?
21:30:43 <nisstyre> I like games that give you the opportunity to troll people
21:30:56 <nisstyre> like pretending to be a cylon in BSG the board game
21:30:57 <cmccann> kmc, that's one, if memory serves me
21:30:59 <nisstyre> when you're human
21:31:51 <tgeeky> kmc: anyway, when "valid" legislation is anything one can write on a document and garner ~ 1/2 of (100, 435) votes
21:32:12 <kmc> i like the bit where Yudkowsky claims to have a revolutionary new decision theory that deals with all these "paradoxes", but doesn't feel like writing it down
21:32:17 <cmccann> kmc, but there's lots of variations on the idea because it turns out that lots of stuff in game theory doesn't settle into a neat solution based on the players doing locally optimal things
21:32:22 <kmc> unless some school will give him a PhD for doing so (and nothing else)
21:33:07 <cmccann> eh, I'm pretty sure he explained it elsewhere, and it's not that novel if memory serves me
21:34:03 <cmccann> I think he's just talking about some flavor of "act in a situation-independent way" approach based on picking a strategy that's optimal overall if blindly applied uniformly, then doing just that
21:34:18 <cmccann> modulo some complications
21:35:06 <cmccann> it's an effective technique for cutting short what would otherwise be a non-well-founded cycle of mutual second guessing when the players can approximate each other's behavior
21:35:44 <cmccann> and thus leads back into the whole thing of "irrevocably commit to suboptimal play in order to get optimal results" I mentioned
21:36:13 <kmc> and i had better understand this or robots will eat me
21:36:18 <cmccann> yes
21:36:35 <kmc> and turn me into delicious paperclips
21:37:12 <cmccann> paperclips are pretty nice actually, they hold paper together
21:37:25 <kmc> they can even do things that aren't that!
21:37:26 <tgeeky> that doesn't sound useful to a robot overlord
21:37:38 <kmc> http://wiki.lesswrong.com/wiki/Paperclip_maximizer
21:37:42 <kmc> "The AI does not hate you, nor does it love you, but you are made out of atoms which it can use for something else."
21:38:16 <cmccann> well-organized paper is pretty important, I can't blame the robot overlords for caring about that
21:38:23 <cmccann> seems sensible to me
21:40:04 <cmccann> though I have to say making sure you know how a semi-autonomous system is actually going to react to goals is pretty important even without worrying about robot overlords
21:40:41 <cmccann> it's not too hard to create pretty much the paperclip-maximizer type situations in stuff like simpleminded AIs in an open-world game
21:41:44 <tgeeky> it seems to me rather difficult to make a machine that makes paperclips, though
21:42:02 <tgeeky> certainly one which makes paperclips out of humans, so squishy and moist
21:42:36 <kmc> "Most well-nourished people in industrialized countries have 4 to 5 grams of iron in their bodies."
21:42:37 <cmccann> a human contains a few grams of iron.
21:42:51 <kmc> also you can make paperclips out of lots of things
21:42:54 <kmc> plastic, bone
21:43:11 <Jafet> It won't consider those paperclips.
21:43:13 <tgeeky> yes, but turning arbitrary substance into paperclips
21:43:25 <kmc> and you also need fuel to run the paperclip factory
21:44:08 <tgeeky> hm. 3grams of iron in the average human
21:44:21 <tgeeky> 3 paperclips per human
21:44:49 <kmc> 21 billion paperclips!
21:44:57 <cmccann> sounds like a fair deal to me.
21:45:01 <luite> that should be enough for the remaining humans
21:45:36 <kmc> remaining humans?
21:45:39 <cmccann> remaining humans? you mean "prospective paper clips"
21:45:46 <tgeeky> how about that
21:45:57 <tgeeky> that's only about 1/7th of the number of paperclips *we humans* produce per year
21:46:07 <luite> kmc: the ones that operate the paper clip machine, or do you use robots?
21:46:27 <luite> wait I thought I left -blah yesterday :p
21:46:40 <tgeeky> -blah didn't leave you
21:46:48 <luite> -blah is stalking me :(
21:46:56 <Jafet> You can fuse the carbon in the biosphere into iron
21:46:56 <kmc> i assume that a superintelligent paperclip maximizer can design a paperclip-manufacturing robot more efficient than a human
21:46:59 <cmccann> luite, the context here is an intentionally-ridiculous scenario of an autonomous goal-driven system getting out of hand
21:47:06 <cmccann> so it's not worth worrying too much about particulars
21:47:06 <kmc> it would be surprising indeed if humans turned out to be the ideal machine for making paperclips
21:47:10 <Jafet> But it's probably more efficient to just strip-mine the planet
21:47:27 <cmccann> yes, the planet is made of a lot more grams of iron than humans are.
21:47:28 <kmc> Jafet, well, for starters, the humans will try to stop you
21:47:29 <tgeeky> kmc: they are the the 4th most pilfered office supply item
21:47:37 <kmc> so you've got to kill or imprison them somehow
21:47:46 <kmc> keeping them alive diverts valuable resources from paperclip production
21:47:53 <tgeeky> lol
21:47:55 <kmc> and if you kill them anyway, you might as well turn their bodies into paperclips or fuel
21:48:01 <cmccann> or both!
21:48:02 <luite> cmccann: ah I missed that part
21:48:09 <tgeeky> i think that one needs to be added as a quote somewhere
21:48:59 <cmccann> luite, it's a slightly silly but also not unreasonable point in that, as I said, goal-driven systems tend to, imagine that, seek their goals.
21:49:20 <cmccann> Bolting a super-intelligent AI onto a poorly-architected goal driven system would indeed be a Very Bad Idea
21:49:49 <tgeeky> I'm still holding out fo a super-intelligent (non-A)I
21:49:49 <kmc> the point of the thought experiment is that dangerous AIs aren't necessarily 'evil'
21:50:01 <aspect> if the AI was that intelligent it would realise its goal driven system is inadequate and cry
21:50:09 <cmccann> the author of the intentionally silly scenario being someone who's made a career of suggesting that it might be a good idea to think about well-architected goal systems for AIs
21:50:26 <kmc> how do you judge a goal system to be inadequate?
21:50:29 <kmc> against what set of goals?
21:50:49 <tgeeky> well, if the goal is to make paperclips, it should probably ignore humans entirely
21:50:53 <tgeeky> and you know, dig for dirt
21:51:16 <Jafet> kmc: foundation, obviously
21:51:17 <cmccann> that depends entirely on whether ignoring the humans was the most practical way to produce more paperclips
21:51:19 <kmc> as previously noted, the humans will try to stop it from e.g. blowing up Los Angeles to get at the trace iron underneath
21:51:20 <tgeeky> a goal-driven AI without a resource model that matches the world
21:51:25 <swordtenchi> when I think about all the films that have rogue AIs, I kind of wonder why you need a dishwasher or fighter craft that reads Shakespeare anyway; seems to me to be feature creep
21:51:47 <tgeeky> swordtenchi: you just deeply offended a future dishwasher
21:51:54 <swordtenchi> :P
21:52:09 <Jafet> Part II: The Dishwasher Returns
21:52:33 <cmccann> tgeeky, the whole point here is that poorly-calibrated goal systems are not necessarily something that can fix themselves
21:52:34 <tgeeky> Mommy, why does our dishwasher want to be fed paperclips?
21:52:48 <kmc> yeah, they're only "poorly calibrated" with respect to human values
21:52:56 <tgeeky> cmccann: yes, I get the silly thought experiment. And the relationship to human values.
21:52:58 <kmc> so if we humans aren't good at imposing our values on them, nothing else will
21:53:18 <tgeeky> But humans relevant or not, if an AI doesn't have an internal model of what resources are where, and how costly it is to attain them
21:53:20 <kmc> i don't think it's all that silly, honestly
21:53:22 <tgeeky> then you don't have a smart AI
21:53:29 <cmccann> even if they're poorly-calibrated in the sense of being self-defeating or otherwise ineffective. the thing with those goals isn't going to care, by definition
21:53:53 <luite> kmc: hehe, that depends of course on whether human values are purely human, or more universal
21:54:06 <cmccann> kmc, the paperclips are intentionally silly. the underlying point is not (and in fact, applies just as well to non-superintelligent-AI systems)
21:54:24 <kmc> like the global financial system
21:54:36 <cmccann> luite, universal values don't exist, that one's easy
21:54:48 <kmc> luite, yes, but there's a huge cognitive bias towards us thinking our values are universal, for lack of perspective
21:54:49 <tgeeky> cmccann: kmc: it doesn't matter if it's paperclips or not -- if it's something that's made of atoms, there is a cost in harvesting, converting, and assembling atoms into other configurations
21:54:53 <kmc> how many sentient non-humans have you met?
21:54:55 <cmccann> the laws of physics don't care about values, they just are
21:55:03 <tgeeky> and if your AI doesn't have *some* model for this process, then your model probably can't be all that intelligent
21:56:00 <cmccann> tgeeky, many humans have a very poor model of resource management, so the bar is pretty low here for what's called "intelligent"
21:56:06 <tgeeky> cmccann: true
21:56:08 <dalaing> some of this seems biased towards an AI with a focus on physical goals - what if instead of paperclips it tried to impose it's own values on humans
21:56:27 <tgeeky> and having said that, since an asteroid or comet will likely come along and wipe out our paperclip-obsessed overlords (just like it will us)
21:56:32 <tgeeky> then we needn't worry too much
21:56:45 <kmc> tgeeky, they'll destroy the asteroid
21:56:46 <cmccann> tgeeky, an AI could also have an advantage of parallelization. creating synch'd up copies of itself would let it do stupid things much more efficiently than humans can do stupid things working together
21:56:46 <aspect> we'll know the super-intelligent AI because it's the only thing apostrophising consistently
21:56:52 <kmc> and preferably turn it into paperclips
21:56:56 <tgeeky> kmc: no, they won't
21:57:08 <tgeeky> unless stars are paperclip machines
21:57:22 <kmc> if the asteroid destroys the paperclip maximizer, that would pretty clearly interfere with the production of paperclips
21:57:26 <kmc> therefore the asteroid must be stopped
21:57:44 <cmccann> dalaing, it's just a thought experiment. the physical goals are easier to postulate. what you suggest is more plausible in many ways and quite possibly more dangerous
21:58:46 <tgeeky> kmc: at that point, we're talking about a star-creating-destroying AI which is in competition with a paperclip-maximizing AI
21:58:55 <cmccann> as I said, the fundamental issue is autonomous, goal-driven systems, which can end up doing things you really, really didn't want them to unless you understand all the trade-offs and are conscious of what goals you didn't give them, etc
21:59:38 <kmc> i'm not sure what you're talking about tgeeky
22:00:02 <tgeeky> kmc: nothing that's made of matter can survive things like asteroid impacts or supernovae
22:00:08 <cmccann> this is actually a pretty serious practical issue for writing things that aren't really AIs, because you generally want a system to do the things you want it to do, not the things you told it to do
22:00:29 <kmc> tgeeky, that's demonstrably false; Earth and its moon (among many other objects) are made of matter and have survived many asteroid impacts
22:00:40 <kmc> supernovae are a bit trickier, yes
22:00:52 <tgeeky> the moon was created from an impact
22:00:53 <cmccann> the trick to surviving a supernova is to be somewhere else when it happens
22:01:01 <tgeeky> if you call that survival of the Earth, then that's a weird definition
22:01:12 <kmc> it's well within the technological capability of humans today to deflect or destroy an asteroid
22:01:24 <cmccann> probably not destroy.
22:01:33 <tgeeky> cmccann: I *am* a physicist, and it is
22:01:37 <cmccann> unless by destroy you mean convert it into smaller asteroids that will still hit us.
22:01:55 <tgeeky> that might do, but if we actually had warning, we could destroy (but would choose to deflect) it
22:02:15 <cmccann> hunh, okay. fair enough.
22:02:19 <kmc> http://arxiv.org/abs/0811.4052 this is a relevant paper
22:02:39 <tgeeky> kmc: comets are more serious, but extrasolar planets are problematic too
22:02:43 <tgeeky> as is the Sun itself, long term
22:02:51 <tgeeky> nothing can survive in this universe, long term :o
22:03:01 <kmc> not even neutrons :/
22:03:06 <cmccann> kmc, that is a remarkably practical paper
22:03:08 <tgeeky> for sufficiently loooooong terms of looooonggg
22:03:23 <kmc> "In around 5 gigayears our Sun will grow to a Red Giant and will swallow Earth. In this article we present a rescue-plan for the whole mankind, including its inherited habitat Earth. The plan is subdivided into two parts"
22:03:26 <kmc> best abstract ever
22:03:51 <cmccann> yes, it is certainly not selling itself short.
22:04:11 <tgeeky> hm.
22:04:22 <tgeeky> i like it
22:04:35 <tgeeky> they neglected to include abandoning Earth
22:04:50 <kmc> "Although the `swing-by'- idea is an elegant method it will have some inherent problems... One has to note that the kinetic energy of an object with 10^22 g, passing nearby Earth with velocity of the realm of 50 km/s... [corresponds] to about 3000 Petatons TNT-equivalent."
22:05:03 <tgeeky> lol
22:05:08 <dolio> Obviously we won't have the technology to abandon earth.
22:05:13 <kmc> tgeeky, they discuss and reject that plan
22:05:31 <tgeeky> it's a wonder this paper didn't come across my desk
22:05:36 <dolio> Just the technology to move Jupiter-sized planets to earth.
22:05:42 <dolio> From other solar systems.
22:05:53 <kmc> " We reject this idea not only because of the inherent uncertainty of the place of destination but mainly because of the leaving in the lurch of the majority of mankind and of its whole biosphere."
22:06:11 <kmc> they also reject the swing-by idea
22:06:25 <kmc> one problem is that you have to launch giant asteroids at earth and then wait a few thousand years and hope you didn't miss
22:06:26 <swordtenchi> with a VASIMR engine, we can at least go to some godforsaken asteroid in the Kuiper belt and build a colony
22:06:35 <kmc> and civilization may have collapsed in the meantime and nobody's around to do course corrections
22:06:57 <tgeeky> swordtenchi: you've neglected the problem of stopping
22:07:01 <kmc> screw that, go with Project Orion.  1960's technology all the way
22:07:07 <tgeeky> kmc: hell yes.
22:07:14 <swordtenchi> retrograde burn for a few years :P
22:07:29 <tgeeky> back when the solution to technical problems was "add more mass"
22:08:16 <Jafet> http://qntm.org/moving
22:08:26 <kmc> hmm, on further inspection, yes this plan does require plundering nearby solar systems for gas giants and moving them to the kuiper belt
22:08:36 <kmc> seems like a real pain
22:08:41 <swordtenchi> :P
22:08:51 <tgeeky> I say we just die.
22:09:16 <tgeeky> after all, we are just goal-oriented AI whose goal is "live"
22:09:16 <swordtenchi> (maybe this is a good programming idea; something that can model the movement of high-speed rockets :P)
22:09:18 <cmccann> tgeeky, I'm pretty sure most of us will have already accomplished that well before this becomes a pressing concern.
22:10:08 <tgeeky> hopefully we'll have passed on our propensity to preform devestatingly pointless thought experiments
22:10:41 <dolio> I guess if you're going to build space ships capable of evacuating the earth, you may as well make the earth into such a space ship.
22:10:46 <tgeeky> swordtenchi: I think that one's been well looked into. But still, with VASMIR, you'll want to end up orbiting something pretty massive, it will be difficult to stop yourself
22:10:53 <cmccann> yes. an AI will then consume us as fuel in order to more effectively run thought experiments about doomsday scenarios.
22:11:48 <swordtenchi> unorigina, yeah....but hey, I want to try SOMETHING
22:12:33 <cmccann> personally I think the "AI with miscalibrated goals" is the most likely doomsday scenario just because that seems to have the most potential for humankind to kill itself in a really dumb way
22:12:52 <Jafet> Really? We don't even have AIs yet
22:13:10 <cmccann> yes, that's why we haven't killed ourselves by doing something dumb
22:13:14 <tgeeky> cmccann: I think regular old stupid intelligence will get us to doomsday much faster
22:13:15 <Jafet> They're supposed to be invented Any Time Now for thirty years
22:13:42 <cmccann> since it turns out it's harder than people thought to convince humanity to go out in a blaze of glory.
22:14:04 <cmccann> Jafet, that's just because AI is defined as the things that don't work yet. anything that gets results is reclassified as not-AI.
22:14:05 <tgeeky> cmccann: it might be trivial to get humanity to go out with a slow, agaonizing boil, though
22:14:37 <tgeeky> hell, I saw a video of two cleverbots talking to each other, and I was pretty sure one of them was a teenager on myspace
22:15:13 <Jafet> AI hasn't shrunk by much then
22:15:21 <kadoban> that probably says more about teenagers on myspace than it does about AI
22:15:26 <cmccann> yes, the turing test has been obsoleted by the invention of myspace, and the discovery that most humans can't pass it
22:15:47 <tgeeky> BORING! Let's talk about Lady Gaga.
22:16:20 <tgeeky> this has been an entertaining, if completely unrelated to haskell, discussion
22:16:37 <cmccann> yes. and I should be sleeping right now.
22:16:49 <Jafet> @vixen do you pass the Turing test?
22:16:50 <lambdabot> maybe. do you?
22:16:54 <cmccann> haha
22:17:35 <tgeeky> @vixen Do you have a hankering for 21 billion paperclips?
22:17:35 <lambdabot> oh, you're not to much older than me
22:17:42 <tgeeky> ugh, and a typo!
22:17:44 <cmccann> well that was a misfire
22:18:05 * cmccann figures the response was because of "21"
22:18:07 <tgeeky> at least we know that one robot isn't going to turn us into office supplies
22:18:17 <tgeeky> @vixen Do you like paper clips?
22:18:18 <lambdabot> yeah, i like
22:18:23 <cmccann> uh oh
22:18:24 <tgeeky> spoke too soon!
22:18:24 <kmc> @vixen they only want you when you're seventeen
22:18:25 <lambdabot> when? now? later?
22:18:37 <kmc> @. vixen nixon
22:18:37 <lambdabot> what if i don't?
22:18:43 <kmc> @. vixen nixon
22:18:43 <lambdabot> what if i don't?
22:19:49 <cmccann> ok. anyway this is getting incredibly silly. moreso than it was to begin with. I'm off to sleep now.
22:19:57 <kmc> 'night cmccann
22:19:59 <kmc> me too, actually
22:20:06 <cmccann> try not to kill everyone with paperclip AIs in the meantime
22:22:01 <swordtenchi> :P
22:22:32 <tgeeky> night all of you
22:22:52 <tgeeky> except you vixen... I'm not sleeping. I am always awake, watching you. *squints*
22:25:44 <swordtenchi> I'm gonna head out too; thanks for the advice. peace!
22:26:45 <unguest> what exactly is haskell and how do I cook it?
22:26:47 <kmc> http://www.pbfcomics.com/?cid=PBF115-Hug_Bot.jpg
22:27:21 <kmc> i think these four panels illustrate the problem better than any Yudkowskite treatise
22:28:04 <kmc> unguest, you might have more luck cooking haddock
22:28:09 <unguest> do you universally live in your mother's basement?
22:28:19 <unguest> also, how much is being overweight a problem?
22:28:43 <kmc> guards seize him
22:29:06 <unguest> you don't have those, come on.
22:29:10 <kmc> @where ops
22:29:10 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
22:29:17 --- mode: ChanServ set +o copumpkin
22:29:45 --- kick: unguest was kicked by copumpkin (no)
22:29:50 * kmc claps
22:29:52 --- mode: copumpkin set -o copumpkin
22:30:38 <luite> aw why does everyone sleep? :p
22:32:08 <dalaing> surely a few of the ~700 people on here are awake
22:35:23 <jim``> hi
22:36:50 <azaq23> jim``: hi
22:37:26 <jim``> I.m trying to build ghc-7.2.1 from the src tarball on archlinux using installed ghc-7.0.2. Missing System.Process in libraries/Cabal/cabal/Distribution/Simple/Utils.hs line 192. Any help available?
22:43:14 <kfish> jim``, you don't have the process library for some reason
22:48:07 <jim``> #kfish Ah. cabal install process -> "Missing or bad header file runProcess.h".
22:50:33 <Saizan> jim``: did you install ghc from your distro? if so you might also install process from there
22:54:08 <kfish> i installed 7.0.3 from source, and then used it to build 7.2.1 from source -- no problems with process
22:54:59 <kfish> perhaps arch has split the libs out into separate packages
22:55:14 * hackagebot angel 0.2.1 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.2.1 (JamieTurner)
22:57:40 <jim``> #kfish ghc-7.2.1-src-tar.bz2 is 25184186 bytes. Same file? PS on intel.
22:58:40 <Jafet> Surely you could compare the checksum
22:59:06 <jim``> #kfish going over to arch wiki. tnx for the help so far.
22:59:44 <kfish> good luck
23:09:57 <jim``> #jafet Checking his file against mine :)
23:17:42 <zeweiliu> hi
23:20:14 <DevHC_> is the monomorphism restriction dead yet?
23:22:53 <Enigmagic> think that's fixed in head
23:23:07 <Enigmagic> aka 7.4.1, maybe this year ?
23:23:45 <DevHC_> how?
23:24:00 <DevHC_> (by complete removal, or other changes?)
23:24:48 <Jafet> Presumably b\y changing the default from MonomorphismRestriction to NoMonomorphismRestriction
23:25:18 <Polarina> If one were to make a computer game in Haskell, what would be a good way to store resources and then know where they are at runtime?
23:25:39 <kosmikus> really, is the plan to remove the monomorphism by default? where is that stated?
23:25:41 <Enigmagic> DevHC_: might have just been for top level functions, lemme see if i can dig up spj's mail
23:25:51 <kosmikus> that would violate the standard
23:26:10 <Jafet> kosmikus: what? how can ghc violate ghc?
23:26:24 <kosmikus> ghc claims to implement Haskell
23:26:25 <Enigmagic> http://hackage.haskell.org/trac/ghc/changeset/49dbe60558deee5ea6cd2c7730b7c591d15559c8
23:26:27 <kosmikus> Haskell has a standard
23:26:34 <Jafet> GHC is Haskell
23:26:42 <kosmikus> Jafet: no
23:26:56 <fasta> Academic arguments vs reality. Observe clash.
23:27:09 <kosmikus> and so far, GHC has been relatively careful not to violate the standard
23:27:17 <Jafet> nhc also has no monomorphism restriction
23:27:43 <Jafet> And spj wants to make let-binding monomorphic, afaik
23:27:58 <aki> morning
23:28:08 <Jafet> Polarina: the same way it is done in other languages, why not?
23:28:18 <kosmikus> Jafet: the point is purely what the defaults are
23:28:27 <kosmikus> Jafet: GHC already implements a partially monomorphic let
23:28:28 <Polarina> Jafet, I don't know how it's done. :(
23:28:38 <kosmikus> but it currently is only enabled if you use certain GHC extensions explicitly
23:29:04 <Jafet> Polarina: a simple method is data GameResources = GameResources <everything goes here>
23:29:20 <Jafet> Optionally, you can put that in a reader monad
23:29:34 <kosmikus> the trac you link to doesn't explicitly mention the monomorphism restriction
23:29:40 <Polarina> Jafet, I was more of thinking .png textures and models.
23:29:46 <kosmikus> oh, it does
23:29:48 <Jafet> kosmikus: I assume it will become a haskell' default
23:29:57 <Jafet> Polarina: yes.
23:30:17 <Enigmagic> kosmikus: yeah i remembered it wrong, it was mono pattern binds.
23:30:21 <kosmikus> Jafet: yes, that's entirely possible
23:31:09 <kosmikus> note that I wasn't actually stating my preference. I was just saying that I'd be surprised if GHC would suddenly change it's default behaviour not to match Haskell 2010 or the current standard version.
23:31:20 <Jafet> Polarina: there isn't a good way to pass data around implicitly that's simple enough to explain on irc. You're better off passing it around explicitly
23:32:34 <Polarina> Jafet, Ok, thanks.
23:32:58 <Jafet> (The bad way is to unsafePerformIO in CAFs)
23:34:34 <Jafet> .oO(But GHC *is* the current standard version!)
23:34:55 <DevHC_> kosmikus: its*
23:35:02 <RayNbow`TU> is there a better way of doing this? http://hpaste.org/50775
23:35:27 <DevHC_> 1. patch GHC, 2. patch the haskell standard, 3. profit
23:35:30 <Jafet> Itsterisk
23:35:37 <RayNbow`TU> (converting a sparse list to a dense list)
23:36:12 <Jafet> I can do it in fewer characters
23:36:15 <Jafet> Or what do you mean by "better"
23:37:21 <Jafet> You can scan through the assoc-list to convert it to the required list, but that's probably more characters
23:37:31 <RayNbow`TU> better could be anything
23:37:40 <Jafet> Remember that the assoc-list is sorted
23:37:40 <RayNbow`TU> like more efficient or more elegant
23:38:00 <RayNbow`TU> well, the problem is that the assoc-list might not be sorted (could be easily fixed by first sorting it though)
23:38:04 <DevHC_> to me it looks like u're converting a list to a list...
23:38:06 <Veinor> sort it first
23:38:13 <jim``> Anyone built ghc-7.2.1 from source on intel?
23:38:14 <kosmikus> Jafet: that's just wrong. GHC and the standard are independent.
23:38:22 <Jafet> no u
23:38:49 <Jafet> jim: the answer is definitely "yes", but that's not likely to help you
23:38:49 <kosmikus> Jafet: not completely, of course.
23:38:52 <DevHC_> kosmikus: 1. patch GHC, 2. patch the haskell standard, 3. profit
23:39:10 <kosmikus> DevHC_: that's an oversimplification.
23:39:33 <chrisdone> has anyone done work on optimizing tail recursion modulo constructor for haskell?
23:39:41 <Veinor> RayNbow`TU: sort the sparse array first
23:39:53 <DevHC_> kosmikus: 1. patch GHC to default to NoMR, 2. remove MR from the haskell standard, 3. profit
23:39:57 <jim``> #japet Fraid no help on archwiki. Wants date ssh sum as captcha but won't accept it.
23:39:58 <Jafet> How do you modulo constructor?
23:40:14 <jim``> #japet to register.
23:41:08 <kosmikus> DevHC_: Give me any example from the past where GHC has been actively trying to influence the Haskell standard by changing the default behaviour on a controversial topic like this.
23:41:10 <jim``> #japet do I have to hassle dons the mainainer?
23:41:22 <chrisdone> Jafet: for example, if the only operation left to do after the recursive call is, say, (:), then you can take out the recursive call and just include the consing in the trampoline
23:41:31 <kosmikus> but anyway, I don't think this discussion leads anywhere.
23:41:52 <DevHC_> kosmikus: let examplesFromDevHC = []
23:42:31 <chrisdone> Jafet: i'm guessing that you can generalize this for all constructors seeing as they by definition contain no recursion themselves
23:42:42 <Jafet> jim: you can hassle dons, but I suspect the problem is with your system or ghc
23:43:20 <Jafet> kosmikus: for a controversy to exist, there must be a significant number of people who want the dreaded monomorphism restriction
23:43:56 <Jafet> chrisdone: hm, I thought the stg treated constructor application like functions
23:44:44 <chrisdone> ah, i wasn't aware — i only know down to core level. good point
23:44:56 <Jafet> I'm guessing too
23:47:29 <kosmikus> Jafet: I think both having the monomorphism restriction or not having it have certain advantages. The same holds for monomorphic vs. polymorphic let-bindings.
23:49:26 <Jafet> If it were up to me, I would decide it on how much typing they save
23:49:41 <Jafet> Fortunately none of this is up to me
