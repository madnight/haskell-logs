00:29:21 * hackagebot cake 0.1.0 - A build-system library and driver  http://hackage.haskell.org/package/cake-0.1.0 (JeanPhilippeBernardy)
00:31:01 <petanqk> I'm not used to cabal problems yet so I'd appreciate a bit of advice. I'm installing yesod on top for haskell platform 2010.1.0.0.1ubuntu0.1. as part of 'cabal install yesod' monad-control-0.2.0.2 is getting installd, but it fails as follows: monad-control-0.2.0.2 failed during the configure step. The exception was: user error (The package requires Cabal library version -any && >=1.9.2 but no suitable version is installed.).
00:31:21 <petanqk> cabal -V gives: cabal-install version 0.10.2 using version 1.10.1.0 of the Cabal library
00:31:58 <ArnoVanLumig> petanqk: the ubuntu version of haskell-platform is quite outdated
00:32:45 <ArnoVanLumig> I don't think there is much you can do except for installing a newer version of haskell-platform
00:32:52 <petanqk> yes I've thought so as well but still kept using it since it seems to be preferred in haskell site anyway
00:32:55 <petanqk> ok
00:37:46 <petanqk> ArnoVanLumig: Thanks you
00:38:03 <petanqk> Oh my.. Well, thank you
00:38:28 <ArnoVanLumig> petanqk: glad it works :)
00:41:30 <shachaf> Hmm, OverloadedStrings in ghci is annoying.
00:41:52 <shachaf> "Strings" don't default to String anymore.
00:48:05 <ivanm> shachaf: yeah, it's a bit of a catch-22
00:49:24 <shachaf> length "str" is kind of nice to have work.
00:50:07 <hiptobecubic> If you were trying to read from a fifo, is this how you'd do it? It's how xmobar is doing it and it appears to be pretty broken. I don't have enough experience to say if this is the 'right' way or not. http://vpaste.net/rlpl6
00:51:08 <shachaf> hiptobecubic: What's wrong with it?
00:52:25 <hiptobecubic> shachaf, it doesn't work :D.   if i try something like... "echo 'foo' > fifo"   and then restart xmobar i'd expect 'foo' to show up on the bar. instead it gets nothing ("Updating...") and echo dies with "-bash: fifo: Interrupted system call"
00:52:50 <ivanm> @tell chrisdone it would be nice if the upload functionality asked your for the file to upload
00:52:50 <lambdabot> Consider it noted.
00:53:10 <shachaf> hiptobecubic: Are you sure you're supposed to echo into the FIFO and *then* restart xmobar?
00:53:26 <Eduard_Munteanu> I don't think xmobar requires restarting.
00:53:30 <hiptobecubic> it doesn't work in either order
00:53:42 <Eduard_Munteanu> Besides it probably results in a broken pipe.
00:54:00 <shachaf> hiptobecubic: Though that should work, I suppose. You're also probably supposed to have a long-running process putting data in the pipe, rather than an EOF like you get with echo.
00:54:22 <hiptobecubic> Eduard_Munteanu, seems like it, yes. The pipe becomes usable again after this error. i can tail -f and echo all i want and it works fine
00:54:24 * hackagebot graphviz 2999.12.0.1 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.12.0.1 (IvanMiljenovic)
00:54:44 <shachaf> hiptobecubic:  You can't have more than one thing reading from the same pipe. :-)
00:54:48 <hiptobecubic> shachaf, well what about echo without the EOF, shoudl be fine no?
00:54:59 <hiptobecubic> shachaf, right, which tells me that xmobar isn't even looking at it after it breaks it
00:55:16 <shachaf> Are you sure they're looking at the same file?
00:55:32 <shachaf> I'm pretty sure the xmobar code works, since some people use it and all.
00:55:57 <hiptobecubic> shachaf, if they aren't looking at the same file, why is the pipe breaking
00:56:12 <shachaf> hiptobecubic: Oh, echo dies as soon as you start it?
00:56:20 <hiptobecubic> shachaf, no. it waits
00:56:27 <aki> morning
00:56:40 <hiptobecubic> if something reads from the pipe, then it's all good. echo terminates normally, the data goes through the pipe
00:56:40 <shachaf> hiptobecubic: Until you press ^C?
00:56:55 <hiptobecubic> if xmobar touches the pipe, it breaks, and then nothing happens.
00:57:17 <shachaf> I thought you just said... Oh. I meant "as soon as you start xmobar".
00:57:35 <hiptobecubic> shachaf, here's what i'm doing
00:57:47 <Eduard_Munteanu> hiptobecubic: are you starting xmobar first?
00:58:57 <hiptobecubic> "echo 'foo' > fifo" in one terminal. it waits for something to read frmo the pipe.   THEN mod-q to restart xmonad/xmobar. pipe breaks. nothing goes into xmobar.   If i start xmobar first and then write to the pipe, also nothing happens.
00:59:42 <shachaf> Starting xmobar first and then echoing is probably better.
00:59:47 <hiptobecubic> right now, xmobar is supposedly reading the pipe and echo is supposedly writing to it. echo is waiting and xmobar is 'updating' and that's all.
01:01:12 <hiptobecubic> and if i cat the pipe, it reads it fine. echo terminates. xmobar is still waiting.
01:01:35 <hiptobecubic> it's like xmobar isn't looking at it at all, but if i restart it the pipe breaks, so it must be looking at it, no?
01:02:33 <Eduard_Munteanu> hiptobecubic: how did you configure xmobar?
01:02:34 <shachaf> hiptobecubic: That code works, at least here.
01:03:07 <hiptobecubic> Run PipeReader "/home/john/.pymodoro/fifo" "pymodoro"
01:03:14 <hiptobecubic> i'll paste the whole file
01:03:15 <ClaudiusMaximus> hiptobecubic: i'd try: cat > fifo & echo "foo" > fifo ; sleep 5 ; echo "bar" > fifo  # the cat keeps the pipe ajar, so the EOF from echo doesn't slam it shut
01:03:46 <hiptobecubic> http://vpaste.net/2HMdU
01:03:51 <Eduard_Munteanu> Shouldn't there be a refresh rate arg too?
01:04:24 * hackagebot graphviz 2999.12.0.2 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.12.0.2 (IvanMiljenovic)
01:04:36 <hiptobecubic> Eduard_Munteanu, apparently not? it doesn't build at all if you add one. Although i can't find the docs on this. If you look at PipeReader.hs it only takes two args
01:05:56 <shachaf> Eduard_Munteanu: Why would there be a refresh rate argument?
01:07:50 <Eduard_Munteanu> Yeah, I guess it doesn't make much sense for pipes, at least for blocking reads.
01:10:05 <andras> hello gals and lads, i have a question regarding optimization:
01:10:14 <shachaf> Right. The thing that writes to the pipes decides when to update. :-)
01:10:28 <andras> i'm trying to reuse some algorithms i wrote a while ago in ruby
01:11:08 <andras> for example: create a stream of random numbers obeying some specific statistics (Gauss, Poisson, etc.)
01:11:51 <hiptobecubic> shachaf, Eduard_Munteanu so no ideas ? I know it 'should work' but i'm at a loss.
01:11:52 <andras> in ruby, i wrote a class for each such generator, and each instance had its own set of parameters (for a Gauss distribution, for instance, the mean and the standard deviation)
01:12:25 <andras> this allowed me to do some optimization: precompute some values that are always the same (for the same parameters), such that those calculations only occur once
01:12:44 <andras> is there an elegant way of doing the same in haskell?
01:13:09 <zomg> andras: this is called "memoization" afaik, and should be quite doable in haskell as well
01:13:21 <merijn> I don't think he wants memoization
01:13:36 <zomg> Dunno, sounded like it to me :)
01:13:38 <merijn> That is for storing previous results. I think he just wants to share some pre-computation?
01:13:53 <merijn> But maybe I miss-parsed :p
01:13:55 <hiptobecubic> Eduard_Munteanu, shachaf i changed it to open the pipe in ReadWriteMode and now it works. Seems like a hack to me but i don't suppose i can do any better.
01:14:30 <zomg> merijn: well could be either way I guess, but I think in both cases you probably could get away with a rather similar approach
01:14:54 <zomg> Then again algorithms never were my strong point =)
01:14:57 <merijn> zomg: Well, in the first case just defining the computation in a where clause/at the top level should be enough to cause sharing
01:15:28 <mustelo> andras, can you give an example of what you want to pre-compute?
01:16:21 <andras> simple example: i have a function of two variables which is called a million times, but one of the parameters comes from a set of, say, 100, the other is "random"
01:17:15 <andras> now the function has to compute things such as the logarithm of the parameter which only rarely changes
01:17:50 <mustelo> so could you just map the logarithm over the input set for the first parameter, and then pass that in?
01:18:00 <andras> doing that logarithm every time would be a waste of CPU, so it would be nice if that log were to be computed only once for every distinct value of the variable
01:18:38 <merijn> On unrelated note who do I bug for hpaste feature requests/whining?
01:18:58 <andras> mustelo: the log is just an example, there are a number of values that could be precomputed
01:19:16 <mustelo> andras, so do them all? what am I missing?
01:19:40 <merijn> andras: So you have a collection of basic values and you want to compute them once for each of the 100 unique values?
01:20:19 <merijn> Sounds like a trivial case of "map preComputeMyValues listOfInputs"?
01:20:32 <andras> pretty much, but the question is: what's the best way of storing/naming/passing them? in ruby, i stored them in instance variables
01:20:48 <andras> is it worth defining a data type of this or so?
01:20:58 <andras> s/of/for/
01:20:59 <Eduard_Munteanu> andras: a plain list should do
01:21:06 <merijn> andras: I would either define a data type or use a tuple (depends on how many values you have)
01:21:52 <ClaudiusMaximus> > let f x y = log x * sin x + cos x * y ; xs = [1..10] ; fxs = map f xs ; ys = [1..100] in [ g y | g <- fxs, y <- ys ] -- is how i would do it, probably
01:21:53 <lambdabot>   [0.5403023058681398,1.0806046117362795,1.6209069176044193,2.161209223472559...
01:23:55 <andras> ClaudiusMaximus: fair enough, but does that really save the CPU from computing log x etc. for every combination of x and y?
01:24:41 <hpaste> blueonyx pasted “Network.HTTP exception” at http://hpaste.org/50360
01:24:54 <blueonyx> hi, how to debug this? ^^
01:25:58 <merijn> andras: I would do "map (\x -> (log x, sin x, cos x)) [1..100]" and then pass that tuple to the compute function. If the tuple becomes bigger then 4-5 items I would probably use a custom datatype instead of a tuple
01:26:25 <andras> merijn: ok, that was what i was looking for, thanks
01:26:46 <ClaudiusMaximus> andras: possibly, possibly not - i think it's probably implementation dependent
01:27:26 <Eduard_Munteanu> If you have something like global array, then it should share and memoize.
01:27:52 <shachaf> merijn: Of course, list indexing is linear.
01:27:56 <andras> ClaudiusMaximus: that's what i thought: on my ghc6, it makes no difference
01:28:22 <ClaudiusMaximus> > let f x = let logx = log x in \y -> logx + y ; xs = [1..10] ; fxs = map f xs ; ys = [1..100] in [ g y | g <- fxs, y <- ys ] -- this version is more likely to share
01:28:23 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
01:29:16 <ClaudiusMaximus> but if you want to guarantee sharing, use a datastructure i guess...
01:29:24 * hackagebot tkyprof 0.0.6 - A web-based visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.0.6 (MitsutoshiAoe)
01:29:24 <merijn> shachaf: Not an issue if you iterate over the list calling the computation function multiple times for each list entry
01:29:55 <merijn> So just don't run your computations in random order :p
01:29:58 <ClaudiusMaximus> though, in some circumstances recomputing things can be quicker than finding where you put them...
01:30:10 <shachaf> Oh, I thought you'd pass the entire list in and use it randomly.
01:30:56 * shachaf didn't read much of the context.
01:32:30 <merijn> shachaf: As far as I understood it the point is 100 static values (mangled with computation) then run the main computation step multiple times for each of those 100 values (and associated precomputed values)
01:38:53 <ClaudiusMaximus> hm, interesting - i can't get the first version i pasted to share anything, even with -O2 - is that to be expected?
01:39:08 <ClaudiusMaximus> second version shares even with -O0
01:41:01 <Eduard_Munteanu> > let f x y = log x * y; fs = listArray (1, 100) $ map f [1..100]; f' x y = (fs ! x) y in f' 10 2     -- wonders if this does it better
01:41:02 <lambdabot>   4.605170185988092
01:41:53 <Eduard_Munteanu> I also wonder if the list fuses away.
01:48:01 <Eduard_Munteanu> Hrm... why doesn't IArray provide a method for building arrays using an   i -> e   function?
01:48:32 <Eduard_Munteanu> I imagine that'd be a bit more efficient than going through lists.
01:49:24 * hackagebot tkyprof 0.0.6.1 - A web-based visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.0.6.1 (MitsutoshiAoe)
01:49:36 <ClaudiusMaximus> @hoogle (i -> e -> f) -> Array i e -> Array i f
01:49:37 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
01:50:09 <ClaudiusMaximus> the lack of a "map with index" for arrays is something that annoys me..
01:50:54 <mux> listArray (map f [lowerBound..higherBound]) ?
01:52:04 <Eduard_Munteanu> You might be able to do that using a mutable array and freezing it.
01:52:16 <Eduard_Munteanu> mux: not sure if the list fuses away
01:52:43 <mux> sure but I'd say this is an entirely different problem now, isn't it?
01:52:45 <Eduard_Munteanu> Does it?
01:53:35 <Eduard_Munteanu> From what I've seen it's pretty common for such stuff not to fuse in all cases.
01:54:10 <Eduard_Munteanu> such stuff == plain lists
01:55:00 <frerich2> Are there more generic versions the common list functions (like 'all' or 'any') which work on other types than lists (e.g. Data.Sequence or Data.Array.IArray)?
01:55:11 <frerich2> I'm not sure what type class is needed for that - Traversable?
01:55:26 <Saizan> Foldable
01:55:47 <frerich2> Saizan: Ah yes, that sounds plausible, thanks.
01:58:08 <kmc> any p = foldr (||) False . map p
01:58:13 <kmc> so you only need foldr and map
01:58:32 <kmc> and you can implement map with foldr
01:58:38 <kmc> so Foldable it is :)
01:59:58 <shachaf> Clearly the type classes you want are Allable and Anyable.
02:02:02 <erus`> Clearly he wants Allaboard
02:05:30 <Eduard_Munteanu> @yarr
02:05:30 <lambdabot> I heard andersca is a pirate
02:06:29 <kmc> choo choo
02:11:48 <psysine> is "last" O(n)?
02:11:56 <merijn> :t last
02:11:57 <lambdabot> forall a. [a] -> a
02:11:58 <shachaf> @src last
02:11:58 <lambdabot> last [x]    = x
02:11:59 <lambdabot> last (_:xs) = last xs
02:11:59 <lambdabot> last []     = undefined
02:12:16 <shachaf> No, it returns a thunk in O(1) time. :-)
02:12:21 <shachaf> (Yes.)
02:12:27 <psysine> hehe
02:12:36 <merijn> psysine: The technically correct answer is "it depends", but for simple situations yes
02:13:10 <psysine> is there any container that is "random access", like a C array?
02:13:17 <merijn> Because your code might indeed create a thunk in O(1) and then throw it out in O(1) when never evaluated
02:13:25 <merijn> psysine: Multiple, depending on what you want
02:13:36 <merijn> There's arrays, maps, sets, etc
02:13:38 <psysine> where can i read about them?
02:13:53 <merijn> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
02:14:05 <psysine> thanks
02:14:21 <shachaf> merijn: GHC mighr even optimize it to O(0) time*!
02:14:25 <merijn> Data.Array, Data.Map, Data.Set and Data.Tree are the most obvious ones
02:14:44 <shachaf> (*For value of 0 equal to 1.2246467991473532e-16.)
02:15:14 <shachaf> psysine: There are a bunch of immutable-friendly data structures with O(log n) time operations.
02:15:23 <shachaf> And then you have actual arrays and such, if you want them.
02:15:38 <psysine> ok, thanks everyone :)
02:17:55 <kmc> psysine, Data.Sequence is a good choice if you want something mostly list-like but with random access
02:18:29 <psysine> kmc, ok
02:24:36 <Eduard_Munteanu> Or pretty good access to both ends, depending on how you look at it.
02:24:47 <Eduard_Munteanu> (e.g. for queues)
02:34:19 <ClaudiusMaximus> srsly shouldn't have tried to compile ghc with 256MB ram + 512MB swap...  linking is the killer (haddock is pretty bad too..)
02:34:40 <Baughn> ClaudiusMaximus: Turning off split-objs might help
02:34:47 <Baughn> Though maybe not, 256MB is seriously small
02:35:44 <ClaudiusMaximus> Baughn: well, bit late - been running 6+hours already...
02:36:28 <kmc> ClaudiusMaximus, what machine?
02:36:28 <Baughn> ClaudiusMaximus: What's the actual memory use, by free?
02:36:32 <kmc> embedded? cheap VPS?
02:36:39 <ClaudiusMaximus> old laptop
02:36:41 <Baughn> And, yeah, where did you find a 256MB machine? ;)
02:36:58 <kmc> i will point out that Haskell existed in 1990 :)
02:37:27 * shachaf used a 256MB machine well into the 2000s!
02:37:38 <kmc> gasp, faint
02:37:53 <ClaudiusMaximus> 4M free, 200kB buffers, 16MB cached, 240MB swap used, 240MB swap free
02:37:54 <shachaf> Unbelievable, eh?
02:38:09 <ClaudiusMaximus> top reports 99%wa
02:38:27 <Baughn> ClaudiusMaximus: I don't think, realistically, that's going to complete.
02:38:42 <ClaudiusMaximus> oh?
02:38:54 <Baughn> Mm. Heat-death is going to be an issue.
02:39:13 <ClaudiusMaximus> it's on ghc-stage2 -o ghctags, if that's an idea of progress?
02:39:22 <blackdog> the last step is the worst, though.
02:39:33 <blackdog> anyone had any success with gold?
02:39:55 <ClaudiusMaximus> blackdog: worked fine for me, until i tried to compile ghc with it...
02:40:00 <Baughn> ClaudiusMaximus: If you insist on doing this, check back in a week..
02:40:14 <ClaudiusMaximus> http://hpaste.org/50345
02:40:21 <Baughn> ClaudiusMaximus: But I really do think it'd be over faster if you start over without split-objs. More to the point, using the compiler afterwards will be faster.
02:40:55 <ClaudiusMaximus> ah, can i not turn off split-objs later?
02:41:21 <Baughn> Theoretically you can, in practice you don't want to try
02:41:32 <Baughn> There certainly isn't any documentation for that
02:41:36 <ClaudiusMaximus> line 20 in that paste makes me think binutils-gold has an overflow bug somewhere...
02:42:37 <Baughn> ClaudiusMaximus: Split-objs amounts to taking each haskell file and making the maximum number of .o files it possibly can, one function or /part/ of function per file, in order for the linker to better tree-shake its output
02:42:52 <Baughn> ClaudiusMaximus: And while .o files can theoretically be merged afterwards, I don't want to try it.
02:43:10 <ClaudiusMaximus> ok..
02:43:15 <Baughn> It makes for smaller programs, but also dramatically increases memory use
02:43:19 <Baughn> (Of the linker)
03:00:56 <ClaudiusMaximus> Baughn: i think you're right about that heat death thing...
03:03:32 * ClaudiusMaximus aborts - real 440m, user 140m, sys 20m
03:11:06 <andras> ClaudiusMaximus: how do you check whether the code uses and sharing?
03:11:40 <ClaudiusMaximus> import Debug.Trace (trace)
03:12:53 <hpaste> ClaudiusMaximus pasted “testing sharing” at http://hpaste.org/50362
03:15:42 <ClaudiusMaximus> @quote oasis
03:15:43 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
03:16:20 <merijn> I love that quote :)
03:16:26 <Baughn> andras: It should normally be possible to check statically. Though of course that isn't required, most code that uses sharing does so predictably.
03:16:48 <Baughn> (a,a) is fairly obvious, for example
03:17:05 <merijn> Using where clauses is also a good way to force sharing
03:17:23 <Baughn> Where or let, yes, being the same thing
03:17:46 <Baughn> ..well, anything that gives a name to something
03:17:46 <merijn> Yes, but I prefer where so I try and not mention let to reduce the occurrences of let in the wild :p
03:18:07 * Baughn is a proud member of the Campaign to Save Let
03:18:23 <blackdog> is there a way to write TH code that can take datatypes apart?
03:18:32 <rostayob> blackdog: what do you mean?
03:19:09 <blackdog> i'm trying to generate some code that takes a datatype and generates a parser for it
03:19:27 <rostayob> ok, yes that can be done
03:19:43 <rostayob> generating serializing/deserializing instances of data types is actually quite a common usage of TH
03:19:54 <increpare> I think of 'yet' as having some weird recursion-related uses that I don't really understand yet (cf http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Function.html#fix ).  People never use 'where' in those weird ways.
03:20:25 <rostayob> blackdog: you can inspect the definition of some data type, if that's what you're asking
03:20:50 <blackdog> rostayob: yes, that's what i want - ideally to be able to iterate over the possible fields
03:20:57 <rostayob> blackdog: yes, of course you can
03:21:11 <rostayob> blackdog: this should be of some inspiration: http://hackage.haskell.org/packages/archive/safecopy/0.5.1/doc/html/src/Data-SafeCopy-Derive.html#deriveSafeCopy
03:21:12 <mauke> increpare: fix f = x where x = f x ?
03:21:43 <rostayob> blackdog: what you want is DataD http://hackage.haskell.org/packages/archive/template-haskell/2.5.0.0/doc/html/Language-Haskell-TH-Syntax.html#t:Dec
03:21:58 <blackdog> thank you
03:22:10 <rostayob> np
03:22:23 * Baughn wonders if there's some way to *change* a data type as a TH function.
03:22:38 <Baughn> Wouldn't be very functional. Guess I want a ghc plugin?
03:23:06 <rostayob> Baughn: well you can make up a new data type with the same name i suppose.
03:23:06 <andras> merijn, ClaudiusMaximus: thanks
03:23:20 <Baughn> rostayob: I would expect to see a compile error from that - duplicate name
03:23:44 <rostayob> Baughn: well there is no problem in having the same name in different modules...
03:23:58 <rostayob> but you can't change the actual definition no
03:23:59 <Baughn> rostayob: Yeah, that's not really what I want.
03:24:10 <rostayob> or at least afaik you can't
03:24:16 <Baughn> Looks like a GHC plugin is what I want.
03:24:58 <increpare> mauke: http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion defines it as "fix f = f (fix f)"
03:25:05 <rostayob> Baughn: use case for something like that? (just curious)
03:25:15 <mauke> increpare: ok?
03:25:24 <increpare> which is a lot more grokkable to me - I don't understand the difference, if there is one
03:25:32 <mauke> increpare: it's inefficient
03:26:14 <Baughn> rostayob: Extending the ADT field accessors to be full lenses
03:26:35 <rostayob> what's a full lense?
03:26:48 <Baughn> data Foo = Foo { a :: Int }
03:26:57 <Baughn> a :: Foo -> Int -- Right now
03:27:01 <rostayob> right.
03:27:14 <darkangel> does anybody know is ffi cannot be paralellized&
03:27:16 <Baughn> a :: (Foo -> Int, Foo -> Int -> Foo) -- As a lens
03:27:33 <Baughn> rostayob: The nice thing is that lenses are composable, so you can do the moral equivalent of "foo.bar.baz = 42"
03:27:54 <Baughn> There are plenty of lens-using libraries on hackage, but none integrated to the level that plugins should allow. :)
03:28:18 <increpare> mauke: ok
03:28:31 <rostayob> Baughn: oh, right
03:28:40 <rostayob> Why the tuple of functions?
03:29:05 <rostayob> I mean wouldn't it be better to simply create new functions (the lenses)?
03:29:15 <ClaudiusMaximus> darkangel: http://hackage.haskell.org/trac/ghc/ticket/4262 might provide some insight
03:29:40 <Baughn> rostayob: So you can compose them, basically. Without the composition function knowing whether you intent to read, write, or both.
03:30:06 <Baughn> (Though for efficiency it's not going to be a tuple, and it's not going to be a pair either - you want a 'read-modify-write' function there too)
03:30:29 <rostayob> Baughn: I don't get the "write" part. It would be a new element with the modified field right?
03:30:49 <rostayob> I mean I don't get what you mean with foo.bar.baz = 42 in haskell
03:30:52 <Baughn> Normally, though STM/IORef/STRef integration is.. :P
03:31:05 <rostayob> oh right. I'm not sure I want to get into that :P
03:31:12 <darkangel> ClaudiusMaximus: nope. That not what I searching for. I have tried to implement paralell grep like program and when I used pcre then i had 10x slowdown
03:31:14 <Baughn> rostayob: I'm using 'write' as shorthand for 'return new, modified structure', yes.
03:31:17 <jonkri> could someone explain what this means: "To convert a polymorphic object into Dynamic, give it a monomorphic type signature. For example: toDyn (id :: Int -> Int)"
03:31:49 <rostayob> Baughn: ok so what does foo.bar.baz = 42 do? with bar and baz being tuples as you described
03:31:59 <jonkri> i know that polymorphic types that somehow encapsulates another arbitrary type, such as lists
03:32:05 <darkangel> ClaudiusMaximus: but with tdfa I had 1.5 speedup, dispite tdfa is mush slower than pcre
03:33:06 <hpc> rostayob: function application would be (f $ x) = let f = (g, h) in h x (g x)
03:33:15 <hpc> other combinators can be abstracted from there
03:33:18 <darkangel> parSql''=  (mapSql $ take 100000 $ LC.lines c) `using` parListChunk 50000 rdeepseq is performing parallel with tdfa, but with pcre it 10x slowdown
03:33:37 <rostayob> hpc: ah, ok
03:35:28 <kmc> jonkri, not all lists have polymorphic type
03:35:37 <kmc> jonkri, basically a polymorphic type is a type with a type variable in it
03:35:46 <kmc> [] :: [a]
03:35:48 <kmc> is polymorphic
03:35:58 <jonkri> aha, i'm with you
03:35:58 <kmc> so is  [2,3,4] :: (Num a) => [a]
03:36:02 <kmc> but not [2 :: Integer, 3, 4]
03:36:05 <jonkri> oh
03:36:08 <kmc> which is [Int] -- no type variables
03:36:17 <rostayob> kmc: [Integer] :)
03:36:26 <kmc> err
03:36:28 <rostayob> ehe
03:36:29 <kmc> yes ;)
03:39:30 * hackagebot uniplate 1.6.2 - Help writing simple, concise and fast generic operations.  http://hackage.haskell.org/package/uniplate-1.6.2 (NeilMitchell)
03:39:32 * hackagebot hxt 9.1.4 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.1.4 (UweSchmidt)
03:39:34 * hackagebot hxt-relaxng 9.1.3 - The HXT RelaxNG validator  http://hackage.haskell.org/package/hxt-relaxng-9.1.3 (UweSchmidt)
03:49:46 <hvr> should Control.DeepSeq be integrated into `base` eventually?
03:49:56 <hvr> (or at least be included in HP?)
03:55:37 <kamaji> Is there a way to specify what kind of string you want when using overloadedstrings?
03:55:56 <kamaji> this line is giving me errors: ref <- newIORef ["foo"] :: IORef [B.ByteString]
03:55:56 <shachaf> kamaji: ::?
03:56:16 <kamaji> B is Data.ByteString.Lazy
03:56:22 <shachaf> kamaji: You're specifying a type for newIORef ["foo"] there, not for red.
03:56:34 <shachaf> You can say newIORef ["foo" :: String], or something like that.
03:56:43 <kamaji> oh!
03:56:47 <kamaji> okay
03:57:08 <Rmx> Hi, how can I get my webcam video flux procesed in real time by haskell ? I don't find how to connect it to my program? I'm blocked even before starting.. :/
03:57:32 <kamaji> in the interests of being a dumbass, the way I wrote it should be IO (IORef [B.ByteString]) ?
03:58:10 <kmc> yeah
03:58:23 <kamaji> coolbeans
04:01:41 <kamaji> Is there any way to make ghci keep imports from a file even if it doesn't compile?
04:02:31 <shachaf> kamaji: Not really, as far as I know.
04:02:40 <shachaf> You can put imports in ~/.ghci, though!
04:03:06 <kamaji> ooh that's handy
04:03:17 <kamaji> it's more for when i'm trying to look up type of a function though
04:03:19 <kamaji> but that is useful :D
04:03:20 <kamaji> thanks
04:11:56 <Claudius1aximus> Rmx: i've been working on bindings to v4l2 (if you're on linux), haven't published the high level interface yet but there's repositories at https://gitorious.org/hsv4l2
04:12:26 <Rmx> thanks
04:12:31 <Rmx> sadly, I'm on windows
04:12:49 <Rmx> is there any easy way to get started ?
04:13:14 <Rmx> I can't even find a voice chat program, or anything that get audio or video in real time...
04:13:23 <hpc> Rmx: module Foo.Imports (export lots) where import lots?
04:13:37 <hpc> er, kamaji: ^
04:15:32 <Botje> Rmx: have you looked at openCV?
04:15:54 <Rmx> hm.. right now.. I do, thanks
04:16:24 <Rmx> I don't remember why didn't I look at opencv longer
04:16:31 <Botje> there appear to be haskell bindings for it
04:16:42 <Botje> but the module says they've only been tested on unix
04:16:45 <Rmx> thanks!
04:16:56 <Rmx> I'll investigate this now
04:16:59 <Botje> you might have to tweak the module a bit to get it to work (if you do, send patches!)
04:17:50 <Rmx> ok, If my level allw
04:17:57 <Rmx> me to do so..
04:21:26 <jonkri> events (data Event) in my library is defined like things like "MessageEvent Message". starting to think about implementing a dynamic type of event, i have started out with something like "forall a. Dynamic a => DynamicEvent a"... now, this gives third-party applications the possibility to define their own events, but how can i make it so that they can pattern match against the incoming events? i thought of having a String component of the event with an
04:21:26 <jonkri> identifier, but that seems ugly
04:22:39 <Claudius1aximus> blackdog: binutils-gold seems to work ok for regular builds, but for profiling builds it fails not understanding the -x option
04:23:03 <Claudius1aximus> (with ghc-7.2.1 generic linux x86 binary)
04:25:03 <Saizan> jonkri: the Dynamic context already has the role of distinguishing between different kinds of events if i unerstood what you meant
04:26:30 <Saizan> jonkri: so pattern matching would consist in trying to cast the 'a' back into a concrete event type (and maybe pattern match on the constructors of that type)
04:30:13 <kmc> Dynamic is a class you defined, jonkri?
04:36:45 <jonkri> kmc, no, it's a Data.Dynamic
04:37:31 <jonkri> i think i will need a corresponding DynamicHook a something type constructor too :)
04:37:43 <elliott_> jonkri: you probably want just Typeable, not Dynami
04:37:44 <elliott_> c
04:37:49 <elliott_> or, hmm
04:37:57 <elliott_> if you want to be able to say "hey this is an event of type whatever" at runtime then you want Dynamic
04:38:00 <Saizan> Typeable is the class
04:38:01 <elliott_> which I guess is what you are talking about
04:38:11 <elliott_> Saizan: err, right. I just meant a typeable existential
04:38:29 <elliott_> hmm, how _do_ you get the TypeRep out of a Dynamic
04:38:30 <elliott_> ?
04:38:32 <Saizan> Dynamic is an optimized Typeable existential
04:39:30 * hackagebot monad-abort-fd 0.1 - A better error monad transformer  http://hackage.haskell.org/package/monad-abort-fd-0.1 (MikhailVorozhtsov)
04:39:31 <elliott_> Saizan: true :)
04:47:40 <Baughn> rostayob: The exact syntax would not be identical to that of imperative languages.. nor the meaning, really. I was using that as an illustration.
04:47:44 <Baughn> rostayob: But it's like this..
04:48:03 <Baughn> data Foo = Foo { a :: Int }; data Bar = Bar { b :: Foo }
04:48:24 <Baughn> rostayob: With non-lens accessors, (a . b) (Bar (Foo 42)) returns 42.
04:49:41 <Baughn> rostayob: With lens accessors, (a <> b) is not a function, but (a <> b) <$ (Bar (Foo 42)) would return 42, while (a <> b) $> (Bar (Foo 42)) 43 returns (Bar (Foo 43)). Or thereabouts.
04:49:51 <Baughn> rostayob: <$> would be the modify operator, I guess. :P
04:50:09 <Baughn> rostayob: The point is, you can compose two (or more) lenses and the composition is still a lens
04:50:20 <Baughn> <> because a lens is a monoid
04:56:07 <rostayob> Baughn: late comeback! ehehe
04:57:37 <rostayob> Baughn: yeah I get it, isn't that already implementable, just having the lens with another name?
04:57:47 <rostayob> like if a is the accessor aL, or whatever :P
04:58:06 <kmc> (<>) is the infix symbol for mappend?
04:58:15 <kmc> how are lenses a monoid? aren't they typed?
04:58:32 <kmc> doesn't that make them more like a category?
04:59:13 <kmc> fclabels implements Control.Category.Category and then you can use (.) and id
04:59:20 <kmc> as long as you import them from there and not Prelude
04:59:37 <Baughn> kmc: Well, I didn't give it that much thought. They seem to obey the monoid laws, but then again they'd fit as a category as well.
04:59:51 <Baughn> Monoid-ish?
05:00:05 <Baughn> And yes, libraries@ thread says <>
05:00:20 <kmc> it's a kind error for something to be both a Monoid and a Category
05:00:28 <Baughn> rostayob: And yes, there are several implementations already. I just want it more transparent, and /replacing/ the current accessors.
05:00:43 <kmc> a category is a "typed monoid"
05:00:49 <Baughn> kmc: Sorry, not up to doing type-checking in my head at the moment
05:00:53 <Baughn> You're probably right
05:00:53 <kmc> so yeah the laws are very similar
05:01:06 <rostayob> Baughn: mah it seems like a lot of effort just to keep the names
05:01:20 <kmc> the difference is (M -> M -> M) versus (M a b -> M b c -> M a c)
05:01:23 <Baughn> rostayob: SCIENCE!
05:01:42 <kmc> in a category you can't compose just any old two morphisms
05:01:43 <Baughn> kmc: Ah. That does look rather like a category, then.
05:01:53 <kmc> you can only compose when the types match up, the way function types do
05:02:26 <kmc> so a category with only one type (category theorists would say "one object") is a monoid
05:02:46 * Baughn nods
05:02:56 <rostayob> wow I just learnt what a category is!
05:03:05 <kmc> this would be an interesting use of GHC Plugins
05:03:12 * Baughn nods. FOR SCIENCE!
05:03:14 <kmc> i don't know if it's suitable or not
05:03:25 <Baughn> Even if it isn't, I'll SCIENCE until it is
05:03:48 <kmc> they're designed for Core -> Core optimization passes
05:04:25 <Rmx> okeey... thanks for the forsts answers but I ask again what should be the first step under windows to get webcam input... Opencv and other cv based lib are not really made for windows. anything simple, just to get video stream. thanks in advance :)
05:04:30 <Rmx> firsts*
05:05:08 <Botje> Rmx: but there are windows releases of opencv?
05:05:53 <Rmx> yes
05:06:06 <Rmx> but no haslkell binding of those libs running on windows
05:06:59 <Rmx> some with dependency to unix, some other without, but that I don't succeed to buid under windows anyway
05:08:09 <Botje> maybe porting the bindings to windows is not a lot of work?
05:08:21 <Botje> I can imagine you only need to find the correct compiler/linker invocations
05:09:45 <Claudius1aximus> ugh, Prelude from haskell98 and base :/  illegal datatype context :/  etc etc - maybe i should give up on ghc-7.2.1 for now...
05:11:37 <Rmx> probably.... I feel like I'm not able to do it for now, sorry, but I haven't the experience yet to feel confortable. I fight since yesterday morning for no results at all, I discovered cygwin and Msys yesterday
05:12:43 <Rmx> I'm 18 and despite my motivation to learn haskell, path is long -__-
05:14:07 <mjo> Hello. Does anyone know of a simple recipe for getting some sort of graphics working on MacOS X without magic and/or MacPorts ? I don't want to do anything fancy: just throw an image in a window.
05:14:22 <maloi> what is the advantage of writing point-free?
05:14:40 <Botje> Rmx: have you considered installing ubuntu? in a VM if needed
05:14:46 <mjo> Botje : That's plan B :)
05:15:17 <Botje> mjo: you could output pdf's and open them with Preview
05:15:39 <EagerProgrammer> hi there, from the syntax point of view, using the do and <- notation for sequencing statements is not so much different than sequencing with semicolons in ML. What is the real difference?
05:16:17 <mjo> Botje : That's plan C---I'd like the output to be moderately fast, so I could see a new frame every second say
05:16:32 <Botje> mjo: opengl? or cairo?
05:16:43 <saml> EagerProgrammer, difference is that not all monads have sequencing semantics
05:16:46 <Botje> Rmx: maybe you should start with a simpler project than openCV..
05:16:56 <rostayob> EagerProgrammer: I don't know anything about ML, but with the do notation you are composing monads
05:17:01 <saml> some monads might execute last statement first...
05:17:02 <Rmx> yes
05:17:06 <Rmx> smaller project
05:17:10 <Rmx> is the way to go
05:17:14 <Rmx> I'll come back in some time
05:17:18 <saml> some monads might launch missiles after executing each statement
05:17:21 <Botje> you're free to stay :)
05:17:27 <mjo> Botje : Trying to install Cairo seems an exercise in frustration. Given that I'll be upgrading the OS in a week or two, I thought I'd save that pain until then. OpenGL might be a plan though. Thanks for the idea.
05:17:33 <Axman6> EagerProgrammer: monads are programmable semicolons
05:17:53 <EagerProgrammer> Axman6: and what can they do for me?
05:17:57 <saml> EagerProgrammer, you can think of newline (or ;) in do notation  as a function you can overload
05:18:01 <Rmx> okeey.. thanks :)
05:18:11 <Axman6> ask not what Monads can do for you, but what you can do for your Monads!
05:18:47 <Axman6> > do { x <- [1..3]; y <- [6..9]; return (x,y)}
05:18:48 <lambdabot>   [(1,6),(1,7),(1,8),(1,9),(2,6),(2,7),(2,8),(2,9),(3,6),(3,7),(3,8),(3,9)]
05:19:00 <Axman6> > do { x <- Just 4; y <- Just 7; return (x,y)}
05:19:01 <lambdabot>   Just (4,7)
05:19:31 <saml> EagerProgrammer, do { a <- f; g a}   is same as   f >>= (\a -> g a)     and you get to implement >>=  your way.
05:19:31 <Axman6> > do { x <- Just 4; y <- Nothing; return (x,y)} -- zomg, failure propagation!
05:19:32 <lambdabot>   Nothing
05:19:50 <Axman6> > do { x <- Right 4; y <- Right 'a'; return (x,y)} -- zomg, failure propagation!
05:19:51 <lambdabot>   Overlapping instances for GHC.Base.Monad (Data.Either.Either a)
05:19:51 <lambdabot>    arising ...
05:20:11 <Axman6> > do { x <- Right 4; y <- Left "Fail! :("; return (x,y)} -- zomg, failure propagation!
05:20:12 <lambdabot>   Overlapping instances for GHC.Base.Monad
05:20:12 <lambdabot>                              (Data...
05:20:17 <Axman6> urgh
05:21:05 * EagerProgrammer is not convinced yet but will study this phenomenon
05:21:27 <kmc> EagerProgrammer, with respect to IO in particular, the difference is that you're not really doing IO as you go along, just building a description of how IO could be done
05:21:31 <Axman6> EagerProgrammer: basically, there's so many more things that you might want to sequence, not just a bunch of IO actions like you'll likely find in aan ML file
05:21:32 <rostayob> EagerProgrammer: with monads you can do a lot of stuff. I suggest the Maybe monad to start understanding them
05:21:44 <kmc> "with Ord you can do a lot of stuff"
05:21:51 <rostayob> well to start understand the powerrrr
05:22:18 <rostayob> kmc: ?
05:22:18 <Axman6> EagerProgrammer: you can write things like parsers which keep track of your where you are in the file for you, and handle error reporting when you encounter something unexpected for you
05:22:21 <kmc> EagerProgrammer, did you see http://www.haskell.org/haskellwiki/Introduction_to_IO
05:22:37 <kmc> rostayob, you can't do that much with only the generic Monad API
05:22:57 <kmc> you can do a lot of different things with different specific monads based on the different specific primitives they expose
05:23:08 <kmc> the relevance to the generic API varies
05:23:21 <rostayob> kmc: Well yeah, I meant that it turns out that sequencing stuff in that way is really useful :P
05:23:58 <kmc> yeah
05:24:22 <Axman6> EagerProgrammer: a parser monad might look like: newtype Parser a = Parser (String -> Either String (a, String)), which keeps track of where you are in the string you're parding, and when you encounter an error, you return a Left value, and you stop computation there
05:24:35 <kmc> the interesting thing is that you can define a function like "sequence" with one monad (say, IO) in mind, and then you try it on another (say, []) and it does something totally different which is also useful
05:24:39 <Axman6> i guess that's maybe a bit more complicated than needed
05:25:15 <kmc> maybe the "unexpectedly useful generic function" phenomenon is less common with other type classes
05:25:17 <rostayob> EagerProgrammer: are you familiar with haskell Maybe type? Because that's the simplest useful monad imho
05:27:27 <Baughn> EagerProgrammer: You should have a look at the Typeclassopedia as well; it has a nice explanation of the functor/applicative/monad hierarchy.
05:27:34 <Baughn> (A hierarchy that is not enforced in code, btw)
05:27:48 <rostayob> EagerProgrammer: also, LYAH, the part about Functors
05:31:49 <mm_freak> EagerProgrammer: not to tell you what a monad is or how it works, but projecting the idea to a language like C++, monads sort of allow you to overload '=', ';' and 'return', by which you can create new control structures and use existing combinators (for, while, etc.) in the new concept
05:32:18 <mm_freak> > do x <- [1..3]; y <- [10,20,30]; return (x+y)
05:32:18 <lambdabot>   [11,21,31,12,22,32,13,23,33]
05:36:48 <GoodAD> what is haksell ?
05:37:53 <silver> functional programming language
05:38:17 <GoodAD> me try to learn machine langage
05:38:28 <mux> not quite the same thing :-)
05:38:29 <GoodAD> for use my processor
05:38:33 <silver> which one?
05:38:54 <Axman6> x86?
05:38:57 <GoodAD> yes
05:39:11 <Axman6> x86 is an abomination :(
05:39:19 <GoodAD> for what?
05:39:51 <Axman6> it just is, it's horribly designed and amazingly complicated
05:40:07 <GoodAD> when the langage machine for my processor correclty transmited in my brain, i am the king of my castle.
05:40:10 <silver> backward compatibility eh
05:40:35 <Axman6> backward compatibility of something that was already pretty broken :P
05:40:44 <mjo> GoodAD : Buy an ARM based machine, then revisit your plan :)
05:40:54 <Axman6> heh
05:41:07 <Axman6> yeah, i think learning about assembly is much easier with a RISC CPU
05:41:16 <rostayob> almost by definition....
05:41:21 <GoodAD> no need ARM, my processor 6x2.8Ghz capacity with 16Gb DDR3
05:41:49 <Nimatek> #haskell likes feeding trolls.
05:41:57 <Nimatek> It's a tradition.
05:42:00 <mux> Nimatek: my thoughts exactly
05:42:09 <elliott_> You don't need arms with a good enough processor.
05:42:34 <GoodAD> my videocard 3.000.000.000 transistors, i sure to devel with langage machine too.
05:42:55 <mjo> GoodAD : Sure, but x86 assembly is messy. ARM assembly is clean. Or build yourself something small around a PIC or AVR. Clock it slowly and watch your code's performance with a cheap timer :)
05:42:58 <rostayob> GoodAD: that's a lot of transistors!
05:43:03 <silver> you can use c or c++ for this with CUDA or OpenCL
05:43:10 <GoodAD> no
05:43:16 <GoodAD> i want lear langage machine
05:43:24 <GoodAD> because other langage no enter in my brain
05:43:25 <Axman6> i think my i7 only has just under 1billion transistors
05:43:37 <mux> so does english, it would seem
05:43:38 <silver> GoodAD, I can see that :-)
05:43:40 <GoodAD> i no uderstand for what, but langage machine enter easy.
05:44:10 <fredmorcos> mux, :)
05:44:12 <RenJuan> .oO(wtf)
05:44:38 <Axman6> GoodAD: you'll want to learn something like C so you can think about how to solve your tasks at a higher level
05:45:28 <GoodAD> no i say again, me wan learn langage machine, for better use my processor, because c or c++ no use my processor correctly.
05:45:53 <Axman6> yes they do
05:45:59 <elliott_> haskell use your processor most correctly
05:46:04 <RenJuan> GoodAD, people don't generally program in machine language these days. They did routinely when I first started though.
05:46:07 <mux> GoodAD: may I respectfully suggest that you ask that in a channel that would at least be vaguely related to this topic?
05:46:18 <RenJuan> even business systems were sometimes in assembler
05:46:19 <Axman6> modern compilers will do a much better job of using your CPU's features than you likely ever will ;)
05:46:31 <Axman6> ouch
05:46:31 <GoodAD> the last question
05:46:37 <GoodAD> processor is like a world?
05:46:47 <rostayob> also, "machine languages" are made for compilers nowadays, not humans like you, GoodAD.
05:46:50 <RenJuan> no, like an animal in a world
05:47:11 <RenJuan> or the brain/central ganglia of an animal
05:47:11 <rostayob> #haskell: the friendliest channel on freenode.
05:47:20 <EagerProgrammer> rostayob: what is lYAH?
05:47:24 <GoodAD> processor have a die, the die is like a town or a city or a country?
05:47:31 <RenJuan> learn you a haskell
05:47:33 <rostayob> EagerProgrammer: learn you a haskell, a nice & free book about haskell
05:47:36 <mjo> alea jacta est!
05:47:48 <elliott_> GoodAD: processors have arms.
05:47:49 <rostayob> I think it makes a great jobs at explaining functors
05:47:50 <elliott_> the arms have hands
05:47:58 <GoodAD> ok
05:47:59 <rostayob> the hands have fingers!
05:48:11 <GoodAD> upload me language machine in my brain please
05:48:12 <Axman6> those are the bits that stick out the bottom
05:48:22 <GoodAD> like matrix solution
05:48:22 <silver> haskell promrammers have fingers on fingers
05:48:28 <mux> now that's really starting to be ridiculous
05:48:32 <GoodAD> i wait here
05:48:37 <elliott_> GoodAD: done
05:48:38 <elliott_> enjoy
05:48:54 <GoodAD> ok elliott_ the dragon
05:49:13 <rostayob> another satisfied costumer
05:49:25 <elliott_> GoodAD: it only activates when you leave
05:49:51 <GoodAD> upload fail
05:49:54 <elliott_> and deactivates when you come back
05:50:13 <zomg> If I add a type variable to a data type, is it a bad sign if adding it there requires me to touch a hundred other places where it's used, and other data types too? Just wondering if I'm doing something dumb or if this is just how it works :D
05:50:31 <elliott_> zomg: you have to change all the uses, yes
05:51:00 <rostayob> zomg: you'll definitely have to change all the type signatures...
05:51:23 <GoodAD> elliott_ retry to upload language machine of me kkkkkkkkkkkkkkkkkkkkkk you.
05:51:39 <elliott_> GoodAD: ok done. to activate you must leave this heathen place forever
05:51:52 <zomg> Yeah was just wondering 'cause I have a Foo a now and Bar { x :: Foo } and now I need to change all Bar's to Bar a too... Felt like maybe I was just doing something wrong since I'm not that experienced with haskell stuff yet
05:52:12 <GoodAD> your upload no work
05:52:14 <GoodAD> try again
05:52:23 <zomg> Luckily I've used some  type synonyms and such so it doesn't make me do as much work as it otherwise might entail :D
05:52:32 <GoodAD> game over insert coin
05:52:42 <Axman6> GoodAD: go and learn something please
05:53:48 <GoodAD> Axman6 suck my cocks and after upload me the language machine in my brain.
05:53:56 <Axman6> @where ops
05:53:56 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
05:54:07 <GoodAD> @where ops
05:54:07 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
05:54:10 <hnsz> GoodAd: What are you doing mate?
05:54:12 <Axman6> GoodAD: we could be very helpful to you
05:54:12 --- mode: ChanServ set +o mauke
05:54:12 <elliott_> Axman6 may have six axes, but GoodAD has 3.000.000.000 transistors
05:54:22 <rostayob> and many cocks apparently
05:54:27 <hnsz> GoodAd: Let's try and keep it friendl
05:54:29 <mux> good riddance
05:54:40 <elliott_> GoodAD would be a good name for a good automatic differentiation library
05:54:40 <Axman6> i'd bet 6 axes are more than enough for 3billion transistors
05:54:56 <Botje> note: GoodAd was spamming offensive stuff in french this weekend
05:55:02 --- mode: mauke set -o mauke
05:55:14 <elliott_> badad
05:55:27 <rostayob> I can't figure out why would you try to troll a channel about a programming language
05:55:54 <mux> rostayob: extreme boredom I guess
05:55:57 <elliott_> rostayob: what about #visual-php-basic
05:56:08 <elliott_> the _best_ language
05:56:40 <rostayob> elliott_: yeah I hear it's great
05:56:56 <rostayob> we're going to be out of business soooon
05:59:17 <hnsz> Not as great a cold cobol fusion :p
05:59:43 <rostayob> or fortran#
05:59:49 <rostayob> anyway
06:02:58 <rurufufuss> there was a bunch of recursive functions, besides ackermann, that're often used in benchmarks, what are they?
06:03:31 <Axman6> fibonacci?
06:03:40 <companion_cube> factorial?
06:03:52 <rostayob> companion_cube: the fast factorial is not recursive
06:03:55 <rurufufuss> hmm, the one I was thinking of is a bit more obscure than that
06:04:06 <rostayob> well you could test the slow one i guess.
06:04:15 <companion_cube> rostayob: oh really ?
06:04:44 <companion_cube> you can write tail-call factorial...
06:05:01 <rwbarton> factorial is really more a test of your large integer library
06:05:47 <rostayob> companion_cube: sorry, I meant fibonacci
06:06:06 <companion_cube> ah ok
06:06:18 <companion_cube> but you can also do a fast fibonacci recursively
06:06:27 <companion_cube> if you add an argument to your recursing function
06:06:42 <rostayob> companion_cube: yeah but the fastest uses that formula, right?
06:07:08 <rostayob> yeah binet formula
06:07:17 <rostayob> anyway it's not really relevant since we're talking about benchmarks
06:08:31 <minh> Hi! Is there any way to transform a list like [1,2,3] into something like (1:2:3) ?
06:08:40 <rurufufuss> well, I have to correct myself, it's for generating call graphs, not benchmark
06:08:48 <rostayob> > -1,2,3] == 1 : 2 : 3 : []
06:08:49 <lambdabot>   <no location info>: parse error on input `,'
06:08:53 <rostayob> > [1,2,3] == 1 : 2 : 3 : []
06:08:53 <lambdabot>   True
06:08:58 <rostayob> minh: what do you mean?
06:09:01 <Pikachu> Guys
06:09:03 <Pikachu> I need some help
06:09:04 <rurufufuss> ackermann call graph looks nice, just wondering, just want to see if there's anything else that would look nice
06:09:10 <Axman6> > (1:2:3:[])
06:09:11 <lambdabot>   [1,2,3]
06:09:24 <Pikachu> I need to update existing SQL-tables with PHP-code...
06:09:35 <Axman6> nightdenial: they're (almost) exactly the same, apart from the fact (1:2:3) doesn't make any sense ;)
06:09:49 <Axman6> Pikachu: so why are you asking here? :\
06:09:57 <Axman6> uh, minh, not nightdenial
06:10:04 <Pikachu> I kinda googled programming chat
06:10:09 <Pikachu> And found this
06:10:14 <Axman6> then go to #php
06:10:14 <rostayob> Pikachu: and google came up with haskell? wow
06:10:24 <rostayob> google really is good
06:10:33 <Pikachu> How do i connect to #php
06:10:36 <Axman6> Pikachu: type this into your IRC client: /join #php
06:10:38 <rostayob> Pikachu: /join #php
06:10:44 <hnsz> ##php
06:10:53 <rostayob> hnsz: they'll both work
06:11:02 <rostayob> at least they both work for me :P
06:11:02 <hnsz> yeah it's redirected
06:11:13 <minh> rostayob: the problem is that i have something like: foo : 99 : [100] ! where foo can be the result of two different functions (one of them returns a single element for foo which is fine, the other returns several which have to be in the form of (1:2:3))
06:11:14 <Pikachu> Pikachu: /join #php
06:11:22 <Pikachu> Shit doesnt work! :s
06:11:24 <Axman6> without the Pikachu ...
06:11:30 <Axman6> just /join #php
06:11:44 <ehamberg> /join #php
06:11:49 <Pikachu> Says I must be invited...
06:12:00 <hnsz> You have to be logged
06:12:02 <rostayob> minh: foo will always return the same type. So foo : etc will always work or never work
06:12:15 <hnsz> logged in*
06:12:23 <kmc> how is it that both "RISC assembly is easier to learn" and "RISC is better because it's designed for machines, not human" have entered the Unquestioned Common Wisdom?
06:12:34 <Axman6> heh, i guess #php would be a pretty big target for trolls...
06:12:45 <rostayob> :t (:)
06:12:45 <lambdabot> forall a. a -> [a] -> [a]
06:12:48 <rostayob> :t (++)
06:12:48 <Pikachu> How do I create a username?
06:12:49 <lambdabot> forall m. (Monoid m) => m -> m -> m
06:12:54 <elliott_> kmc: well, those aren't contradictory
06:12:57 <rostayob> minh:  so if you want to concatenate lists use ++
06:13:00 <elliott_> design for the machines, coincidentally end up with something easier for humans
06:13:15 <kmc> but that's not how it goes, not universally
06:13:17 <elliott_> rostayob: Caleskell got you there (sigh)
06:13:21 <hnsz> Axman6: It's not to bad tbh
06:13:23 <elliott_> kmc: doesn't mean it couldn't have happened
06:13:25 <rwbarton> minh: 1 : 2 : 3 : 99 : [100] is 1 : (2 : (3 : (99 : [100]))) so you can't use : to combine "1:2:3" with "99 : [100]"
06:13:29 <Axman6> kmc: well, RISC architectures usually have a lot less you need to know (there's only a few load and store instructions in general, and everything else is register to register)
06:13:33 <HugoDaniel> is the new ghc worth it ?
06:13:36 <rostayob> minh: and anyway, 1 : 2 : 3 : [] and [1,2,3] are exactly the same, it's just a different way of writing the code
06:13:41 <minh> rostayob: but (++) is quite inefficient...let me think about my problem-scenario for another  5 minutes! I'll hit you back!
06:13:42 <Axman6> and RISC instructions are much easier to decode due to their fixed length
06:13:43 <kmc> Axman6, and the instruction after a conditional jump gets executed unconditionally
06:13:54 <kmc> (on MIPS anyway)
06:14:10 <Axman6> kmc: indeed. but the branch delay slot isn't a necessity of a RISC architecture
06:14:11 <rostayob> minh: [1,2] : 3 won't work because : appends a single element
06:14:23 <kmc> Axman6, which RISC architecture should one learn, then?
06:14:29 <rostayob> sorry, [1,2] : [3]
06:14:29 <kmc> MIPS is "too RISCy"?
06:14:31 <Axman6> i quite liked SPARC
06:14:42 <Axman6> but it also has the branch delay slot
06:14:52 <rostayob> minh: if you have to append a list to another list it will be always O(n) in haskell, no way around it!
06:14:53 <kmc> i really don't think x86 assembly is that bad
06:15:06 <Axman6> but it's actually an awesome feature, that makes the hardware implementation much easier (allows for pipelining)
06:15:09 <kmc> for writing programs in
06:15:11 <kmc> sure it has a bunch of weird instructions; you don't have to use them
06:15:13 <rostayob> minh: (and with "list" I mean [a])
06:15:14 <Axman6> i think x86 is horrid
06:15:31 <minh> rostayob: right, consider the situation foo : 2 : [3]. that's because I need a way of transforming [42,43] into (42:43) to be able for it to be placed in place of foo
06:15:43 <kmc> minh, (42:43) is a type error
06:15:48 <rostayob> minh: first, 42 : 43 doesn't make sense. try that in ghci
06:15:55 <Axman6> minh: that makes no sense
06:15:58 <kmc> do you mean 42 : (43 : []) ?
06:16:04 <elliott_> my experience with x86: oh, this instruction is wonderful
06:16:05 <kmc> because that's what [42,43] already is
06:16:08 <kmc> or did you mean (42, 43)
06:16:09 <elliott_> lol, it only works on like three arbitrary operand types
06:16:15 <Axman6> heh
06:16:18 <rostayob> minh: : is an operator, it appends an apple to a list of apples.
06:16:29 <rostayob> it can't append two single apples.
06:16:30 <Axman6> yeah, i found very little consistency when starting to learn x86
06:16:30 <Botje> prepends
06:16:47 <kmc> so x86 sucks because instructions only work on 3 operand types but RISC is great because instructions only work on 1 operand type?
06:16:51 <minh> rostayob: (42:43) make sense, as it is partially applied? --> foo : 2 : [3], and when foo is (42:43) you'll get (42:43):2:[3]
06:16:53 <koala_man> hah, delay slots are awesome. I've never heard of such a thing
06:16:55 <elliott_> kmc: it's called consistency
06:17:09 <elliott_> with x86, you're fishing for the instruction that will let you call it as you need
06:17:15 <elliott_> with RISC, the path is always clear
06:17:18 <minh> rostayob: you see? I need a way of TRANSORMING [2,3] into the partial applied (2:3), so it can be used AS FOO
06:17:27 <Axman6> kmc: RISC instructions usually let you specify the size of the values you're working on (1,2,4 or 8 bytes usually)
06:17:35 <rostayob> > (42 : 43)
06:17:35 <lambdabot>   No instance for (GHC.Num.Num [t])
06:17:36 <lambdabot>    arising from a use of `e_14243' at <in...
06:17:36 <Axman6> i think
06:17:53 <rostayob> minh: you are confused about lists in haskell.
06:17:54 <mjo> kmc : I think x86 assembler is a bit like having a ++ operator which only works if the lists are 2 or 3 or 7 elements long
06:17:57 <rwbarton> minh: did you read what I wrote
06:18:05 <rwbarton> (42:43):2:[3] isn't a thing
06:18:12 <rwbarton> you need 42:(43:(2:[3]))
06:18:15 <mjo> kmc : And there's some other instruction for mildly different lists
06:18:17 <kmc> mjo, and branch delay slots aren't like that?
06:18:23 <minh> rwbarton: ahhh...right!
06:18:35 <kmc> or having a register that looks like an ordinary register but ignores writes and always holds the value "0"?
06:18:38 <Axman6> minh: that's not how it works. i think you want to transform [1,2] into (\x -> 1:2:x) right?
06:18:49 <minh> Axman6: ABSOLUTELY
06:18:49 <rostayob> minh: what you want to do is foo ++ (2 : [3])
06:18:52 <mjo> kmc : I think those are easier to think about
06:18:52 <minh> Axman6: that's it
06:19:12 <Axman6> minh: that's almost exactly what (++) does, and it does it the only way that's possible
06:19:12 <mjo> kmc : A register which is always 0 isn't conceptually so hard is it ?
06:19:14 <elliott_> minh: (++) function does that
06:19:18 <elliott_> see DList
06:19:20 <Axman6> unless you use DLists
06:19:28 <Axman6> damn, beaten to it :P
06:19:42 <kmc> look, i'm not saying x86 is beautiful, or even questioning that MIPS / SPARC / ARM are nicer
06:20:03 <minh> Axman6, rwbarton, rostayob : I'll be back in 5minutes! trying some stuff out!
06:20:04 <kmc> i just think a lot of the hating on x86 is blown out of proportion
06:20:13 <Axman6> kmc: these small features are architecture specific though. there's no need for a zeroed registor, or a branch delay slot
06:20:14 <kmc> and is based on following the crowd
06:20:19 <kmc> cause all the cool kids hate x86
06:20:38 <kmc> Axman6, okay.  so which architecture should I learn, that doesn't have those?
06:20:47 <Axman6> i hate x86 assembly because i tried to learn it, and found it far harder than i expected, and i was expecting it to be quite hard
06:20:57 <kmc> is this an argument about how to learn assembly, or is this a theoretical argument about chips that don't exist?
06:21:10 <merijn> kmc: Well, x86 could use more programmable registers. I think we're still stuck with 8 or so programmer accessible ones
06:21:12 <mjo> kmc : I think I'd put it differently. I think that there's a real pleasure in writing assembler for some processors, but I don't think the x86 is a good way to optimize that pleasure.
06:21:12 <Axman6> kmc: i don't know, i've only used them, and not having a branch delay slot negates a lot of the benefits of using a RISC CPU
06:21:17 <kmc> merijn, 16 on x86-64
06:21:37 <kmc> Axman6, right, I agree RISC has benefits to the compiler ;P
06:21:42 <Axman6> SPARC64 has 32, which is nice
06:21:48 <kmc> the claim that it has benefits to the human first learning assembly programming is more dubious
06:21:49 <Axman6> kmc: not to the compiler
06:21:55 <elliott_> kmc: you don't have to name a superior thing to criticise something
06:21:59 <kmc> sorry, to the hardware, i meant
06:22:04 <Axman6> yeah
06:22:04 <rostayob> minh: but please understand that [1,2,3] is just a commodity when writing lists. What it means is 1 : (2 : (3 : []))). You can see haskell lists as a data type like this: data List a = a : List | [] (not sure if this helps). the square brackets syntax makes it simpler to define lists in your code but that's it
06:22:07 <kmc> other benefits to the compiler
06:22:13 <elliott_> x86 sucks, probably learning a different assembly language is painful in other ways and likely pointless nowadays
06:22:15 <elliott_> doesn't stop it sucking
06:22:31 <mjo> elliott_: I think the only reason for it is fun
06:22:33 <merijn> Our ASM course taught 8086 because it nice and simple, plus less ugly then current x86 stuff :p
06:22:43 <elliott_> mjo: well, that's also the only reason to write asm nowadays.
06:22:48 <kmc> no it's not
06:22:50 <mjo> elliott_: Quite so
06:22:52 <merijn> I disagree
06:22:57 <elliott_> hyperbole
06:22:59 <elliott_> but it's close
06:23:00 <kmc> stupid hyperbole
06:23:06 <merijn> Humans are much, MUCH better at writing ASM then compilers are
06:23:08 <kmc> systems programming, security
06:23:18 <kmc> GHC devs have to know assembly
06:23:20 <Botje> i'm not.
06:23:33 <merijn> kmc: Soon systems programming will be in haskell, if it's up to PSU and Galois ;)
06:23:40 <Axman6> kmc: the reason learning a RISC architecture is easier is that there's very few concepts to learn: you use load instructions to load data into registers, store instruction to store values in registers in memory, and everything else works on registors
06:23:41 <rostayob> kmc: yeah but compilers programmers write assembler to make other people not write assembler :P
06:23:44 <hnsz> I reckon you want to learn machine language on an old processor working in real mode
06:23:57 <mjo> kmc: Yes, of course you're right. And there is benefit in some understanding of how the machine works at a low level.
06:23:58 <mux> one thing is for sure: I never ever want to have to write ia64 asm
06:24:08 <frerich2> merijn: I'n my day job, I'm working on an automatic GUI testing tool - assembler is (almost) daily routine here since many operating systems/toolkits don't have existing facilities to trace/adjust the code execution.
06:24:08 <merijn> mux: I hear ya :)
06:24:11 <rostayob> assembler is still useful in embedded systems
06:24:21 <elliott_> rostayob: in x86?
06:24:24 <mux>         alloc           r14=ar.pfs, 0, 0, 3, 0
06:24:26 <Axman6> minh: i reckon it'd be fun, but you certainly need the right workload for it
06:24:28 <mux> seriously wtf is that?
06:24:35 <mux> don't bother to answer, that's only a rhetorical question.
06:24:36 <Axman6> ok, yeah, wtf
06:24:36 <rostayob> elliott_: no, not x86, with assembler I meant writing machine code
06:24:48 <merijn> mux: ia64 seemed really interesting from a capabilities point of view, but a bitch to program
06:24:50 <mjo> rostayob: I think it's enjoyable to use in embedded stuff, and you get to use benchtop tools for debugging
06:25:02 <Axman6> i've never seen ia64 assembly before, just knew about the ideas used in it
06:25:05 <kmc> i'd like to point out that ARM has three different instruction encodings, supported in varying degree on different CPUs, as well as two different incompatible systems for running JVM-like code; vector extensions; several incompatible FPU instruction sets, etc.
06:25:12 <mux>         br.call.sptk    rp=b7
06:25:15 <elliott_> guys, guys, we just have to use AS/400 assembly
06:25:18 <elliott_> http://publib.boulder.ibm.com/infocenter/iseries/v7r1m0/index.jsp?topic=/rzatk/CPRDATA.htm
06:25:20 <elliott_> compression? sorted
06:25:24 <elliott_> http://publib.boulder.ibm.com/infocenter/iseries/v7r1m0/index.jsp?topic=/rzatk/SETHSSMK.htm
06:25:24 <Axman6> kmc: yeah, ARM can hardly be called RISC these days
06:25:27 <elliott_> garbage collection? you betcha
06:25:43 <mjo> kmc: True, but you can have fun and gain insight without learning all of them.
06:25:45 <merijn> Can't we just go back to LISP machines? :p
06:25:54 <kmc> mjo, and the same is true in x86
06:26:03 <mux> can we all go back to living in trees and having a good time?
06:26:05 <rwbarton> even the individual machine instructions are enterprise nowadays
06:26:13 <Axman6> kmc: what's the second JVM hardware thing?
06:26:13 <merijn> mux: I'm game :p
06:26:16 <elliott_> merijn++, mux++
06:26:19 <RenJuan> for the operators and an arch comparison of old: http://en.wikipedia.org/wiki/User:Lycurgus/MoCA
06:26:20 <kmc> Axman6, there's Jazelle and the other thing
06:26:27 <Axman6> what other thing :P
06:26:27 <kmc> POPCNT: the secret NSA instruction the government doesn't want you to know about!
06:26:34 <Axman6> i only know of jazelle
06:26:36 <elliott_> rwbarton: if you mean what I linked, that's quite old :P
06:26:40 <mjo> kmc: Yes, that might be true. It seemed harder to find a suitable set of things which would be fun from my novice's perspective though.
06:26:45 <merijn> mux: Pretty sure CS is much more relaxing once we get rid of computers and go back to paper :)
06:26:54 <roconnor> merijn: it is
06:26:57 <rwbarton> yeah I meant SETHSSMK, how old is that?
06:27:03 <mux> merijn: +1
06:27:07 <elliott_> computers suck
06:27:09 <merijn> Whiteboad == best investment I made in years
06:27:11 <elliott_> let's burn them all
06:27:21 <merijn> And much easier to program :)
06:27:39 <kmc> x86 is pretty ugly but i think the magnitude of the difference between x86 and other architectures is exaggerated, by people who are ignorant of the details
06:27:45 <kmc> and who want to look cool by dissing what's popular
06:27:52 <roconnor> merijn: not really.  They are even buggier programs; you just don't notice as much.
06:27:55 <merijn> @quote Cale only.runs
06:27:55 <lambdabot> Cale says: The perfect programming language is mathematics, but that only runs on mathematicians.
06:27:56 <kmc> and it's become a sort of Common Wisdom among programmers
06:28:01 <RenJuan> people who are ignorant of the details
06:28:03 <mjo> kmc : I think a useful document would be 'How to have fun writing x86 assembler'
06:28:07 <kmc> the kind of Common Wisdom nobody actually questions or backs up with facts
06:28:11 <mux> if I could travel in time, I'd warn my young self that if he insists in willing to work with computers, he'll end up working for finance-related companies surrounded by a ~80% if clueless people
06:28:12 <elliott_> mjo: "drink a lot"
06:28:23 <mux> s/if/of/
06:28:28 <merijn> mux: Is the work at least interesting?
06:28:36 <roconnor> hey, can I still run my IBM XT programs on my laptop?
06:28:39 <mux> merijn: right now, not quite :-P
06:28:45 <mjo> elliott_: I don't think kmc is obviously wrong.
06:28:47 <rostayob> mux: so you regret working with computers? computers have to be messy to be fun
06:28:54 <elliott_> mjo: i'm just joking around at this point
06:28:55 <kmc> yay, i'm nonobviously wrong!
06:29:00 <rostayob> you guys basically want maths, but maths is still there :P
06:29:01 <mux> rostayob: no, I love computers, but I tend to hate computer scientists
06:29:03 <mux> because they are not
06:29:08 <mjo> kmc : Perhaps :)
06:29:10 <mux> if you see what I mean.
06:29:16 <Axman6> kmc: i'm pretty well educated on the subject, and i've gorwn to believe that variable length instructions are a very bad idea
06:29:18 <rostayob> mux: because they're not what?
06:29:25 <mux> rostayob: computer scientists :-)
06:29:26 <RenJuan> yeah not what?
06:29:26 <kmc> Axman6, oh, i very much agree with you there
06:29:32 <elliott_> rostayob: i have to evaluate maths myself though :(
06:29:33 <kmc> that's only a small piece of the puzzle, though
06:29:36 <elliott_> wait, that's what haskell debugging's like
06:29:45 <Axman6> i mean, so much more of the die area od x86 CPU's is dedicated to instruction decoding than actual execution it's almost unbelieveable
06:29:47 <elliott_> ...guess I don't need this channel any more
06:29:55 <kmc> again, at the end of the day, I would prefer something that 's not x86
06:29:59 <merijn> mux: I'm looking for work to fill my time between graduating (Real Soon Now (TM)) and the next enrollment time for PhD positions arrives. But its looking depressing: all I can find is Java and web programming in PHP or Python (and then only Django, but still less sucky then the rest I guess)
06:30:07 <rostayob> mux: you mean because they're to practical?
06:30:23 <merijn> rostayob: That or to impractical
06:30:23 <rostayob> elliott_: you don't evaluate maths you declare it yo
06:30:26 <RenJuan> kmc I will sell you my eMac ppc
06:30:33 * merijn pushes some prof teaching UML out of a window
06:30:42 <elliott_> rostayob: declarin' the mathematics in the HOOD
06:30:44 <mux> rostayob: that may very well sound quite arrogant, but the reality of development work (at least where I live) is that you're surrounded by terribly incompetent people
06:30:57 <rostayob> elliott_: ehe
06:30:58 <merijn> mux: I get the impression that's the situation everywhere
06:31:06 <mux> who can't even copy-paste 2 lines of PHP properly and have absolutely no idea what they're doing
06:31:08 <mjo> kmc : But given that there are so many x86 processors in machines people can program, I'd still like to read the 'fun x86 assembler' document if you wrote it
06:31:13 <rostayob> mux: you're talking about engineers now
06:31:16 <mux> when you're a dev for 10+ years, it starts to get really old :-P
06:31:16 <rostayob> not computer scientist
06:31:31 <rostayob> I mean software engineers
06:31:36 <RenJuan> yeah, 90%+ of the people in IT in the US (and elsewhere no doubt) are what I call "professional dilletantes"
06:31:43 <mux> right, in the US they call them that, indeed
06:31:47 <rostayob> and yeah there are loads of bad programmers in the world so what?
06:31:52 <rostayob> I still think that CS is really cool
06:32:03 <isBEKaml> "professional dilettantes" ? :D
06:32:05 <Axman6> kmc: i think the effort required to decode x86 is my biggest gripe with it
06:32:06 <RenJuan> between them and the academics clueless about biz and stuff, like sux
06:32:15 <rostayob> the worrying thing is that right now smart people *want* to be softeng and make money most of the times
06:32:15 <RenJuan> *life
06:32:29 <merijn> mux: Try being a dev for 0 years, all you can do is web stuff. The rest requires 10+ years experience apparently :p
06:32:37 <mux> merijn: yeah, I feel your pain on that
06:32:49 <merijn> Screw that, I wanna do hard stuff >.>
06:32:55 <rostayob> I don't get your criticism anyway. what's your point?
06:33:05 <mux> merijn: what "saved" me at that time was that I was a FreeBSD kernel committer, which helped in interviews
06:33:25 <Axman6> mux: thanks for the work =)
06:33:31 <RenJuan> animals don't generally have "points"
06:33:50 <mux> Axman6: well thanks, but there's really not much to be thanked for ;-)
06:33:50 <RenJuan> meaning, etc.
06:33:50 <Axman6> RenJuan: rhinos do
06:34:00 <Axman6> mux: meh, any work for the BSD's is good in my book
06:34:03 <merijn> mux: Semi off-topic, have you ever been to a presentation by Kirk McKusick? Any good? I'm thinking of going to the FBSD kernel programming tutorial he's giving at EuroBSDcon, but its a bit pricy for poor students...
06:34:13 <isBEKaml> RenJuan: And porcupines. :P
06:34:19 <RenJuan> Axman6, yeah and I forgot about the pointed geek
06:34:30 <mux> merijn: never been to a presentation by him, but I exchanged some mails with him, and he's a really, really cool guy.
06:34:48 <mux> incidentally, I have him in my facebook friends, which I brag about to other UNIX enthusiasts :-P
06:34:53 <merijn> :p
06:35:02 <rostayob> personally, I'd have been so much more bored without computers
06:35:29 <merijn> I've been a bit out of touch with FBSD recently, I should be more active again...
06:37:30 <rostayob> I mean you guys say you'd go back and tell your young self to stay away from computers. without computers, I'd probably be clueless right now lol. It's something really fun that can be a job, what can you ask for more
06:38:06 <merijn> rostayob: I wouldn't tell myself to stay away from computers. I just said the CS would be more enjoyable without computers. No one to whine I should fix their computer, etc.
06:38:14 <kmc> rostayob, i'm with you
06:38:30 <kmc> i'm /incredibly/ lucky to have something i a) enjoy, b) am good at, and c) can get paid to do
06:38:42 <koala_man> totally
06:38:46 <kmc> working as a professional programmer is incredibly cushy in a lot of ways
06:38:54 <rostayob> merijn: I disagree. I couldn't imagine the 13 yrs old me having fun with "CS" without computers
06:38:56 <kmc> it sure beats shoveling coal or flippin burgers at Micky D's
06:39:03 <merijn> kmc: Bad for your life expectancy, though :)
06:39:09 <kmc> shoveling coal?
06:39:20 <merijn> Programming :p
06:39:27 <kmc> is it?
06:39:32 <rostayob> the fact that you can actually do stuff with computers makes them much more enjoyable then other theoretical sciences (maths, physics etc)
06:39:33 <merijn> Well, any desk job really
06:39:40 <rostayob> at least for me, I need rewards ehehe
06:39:59 <merijn> Sitting more then 5 to 6 hours a day drastically raises the odds of heart disease
06:40:15 <rostayob> merijn: so does eating red meat!
06:40:18 <kmc> i think CS and programming are both worthwhile endeavors for different groups of people
06:40:21 <kmc> with some overlap of course
06:40:22 <rostayob> well no that increases cancer or something
06:40:37 <companion_cube> living increases the odds of heart disease
06:40:38 <merijn> Everything increases the chance of cancer
06:40:38 <dainanaki> i like the overlap point.
06:40:40 <kmc> but there's no reason to be upset that programmers are programmers and not informatics professors
06:40:42 <rostayob> companion_cube: yes.
06:40:52 <kmc> you should know as much informatics as you need to do your job
06:40:54 <kmc> and more is better
06:40:56 <merijn> kmc: I'm more upset that most programmers are not programmers >.>
06:40:57 <kmc> and more is fun anyway
06:41:00 <rostayob> living increases the chances of dying
06:41:18 <kmc> it's funny how the people who talk about how 99% of programmers suck always consider themselves to be in that 1%
06:41:24 <rostayob> kmc: as always
06:41:36 <suselaloose> hello - i want to convert Int to Double. I'm using fromInteger, but I'm obviously using it wrong, as "(fromInteger (3 :: Int)) :: Double" fails with error "Couldn't match expected type `Integer' with actual type `Int'"
06:41:37 <rostayob> the moralists always put themselves in the "good guys" group ehehe
06:41:40 <kmc> it's funny how the people who say that Real Programmers need to have behavior X and Y and personality flaw Z and philosophical belief W
06:41:41 <merijn> I suck too, but I'm aware of my suckage :)
06:41:43 <kmc> will always have all of those
06:42:03 <kmc> anyway speaking of unhealthy, i'm off to breakfast :)
06:42:06 <kmc> ttyl all
06:42:08 <tromp> :t fromIntegral
06:42:09 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:42:10 <merijn> Acceptance that anything you will code will always suck is the first step towards sucking less :)
06:42:11 <rostayob> suselaloose: fromIntegral is what you're looking for
06:42:13 <rostayob> acc
06:42:17 <merijn> s/anything/everything
06:42:24 <kmc> suselaloose, try fromIntegral not fromInteger
06:42:32 <suselaloose> got it - thanks
06:42:41 <rostayob> suselaloose: btw, fromIntegral = fromInteger . toInteger
06:43:29 <merijn> > fromIntegral 3.5 :: Double
06:43:30 <lambdabot>   Ambiguous type variable `t' in the constraints:
06:43:30 <lambdabot>    `GHC.Real.Fractional t'
06:43:30 <lambdabot> ...
06:43:34 <rostayob> merijn: yeah but I don't understand your delusion about computers, I personally feel the opposite way. CS without computers would be terribly boring to me
06:44:06 <merijn> rostayob: I may be slightly overstating my feelings while I procrastinate from fixing my own horrible code :p
06:44:08 <RenJuan> CS without computers
06:44:52 <rostayob> RenJuan: yeah it sounds funny :P
06:45:00 <rostayob> but that's what they were proposing
06:45:03 <hnsz> It's pretty doable
06:45:26 <rostayob> hnsz: doable and pointless
06:45:34 <merijn> I disagree
06:45:44 <hnsz> It's not pointless
06:45:45 <merijn> I think TCS is very interesting even without computers
06:46:40 <hnsz> It's very important to exclude computers from CS. Because it makes you think better about your code.
06:46:41 <rostayob> TCS is without computers by definition. You study algorithms, type systems, all that jazz and you write papers
06:46:58 <rostayob> but it wouldn't be there in the first place without computers...
06:47:31 <hnsz> Nothing bats writing a few thousand lines of code having the whole thing completely in your head and only then compile, having to only corrrect a few typos.
06:47:41 <rostayob> hnsz: yes, and?
06:47:51 <hnsz> Much better than being a tinkerer doing manual delta debugging
06:48:13 <rostayob> hnsz: how is that related to what we were talking about?
06:48:32 <rostayob> "writing 1ks of locs" is not TCS eheh
06:48:50 <locks> pascal rocks
06:48:55 <locks> oops, wrong chan
06:49:10 <hnsz> rostayob: I don't know mate I was replying to RenJuan
06:49:33 * hackagebot roman-numerals 0.5.1 - Parsing and pretty printing of Roman numerals  http://hackage.haskell.org/package/roman-numerals-0.5.1 (RoelVanDijk)
06:50:39 <rostayob> mah anyway. The world runs on ugly software, practical softeng will always be behind CS
06:51:02 <rostayob> but there has been progress, it's just that the industry is 15 yrs behind :P
06:51:16 <merijn> I used to think I wasn't good enough to write "production" code, then I learned what Real World (TM) production code looks like :)
06:51:24 <MasseR> :D
06:52:24 <byorgey> preflex: seen shachaf
06:52:24 <preflex>  shachaf was last seen on ##javascript 2 hours, 41 minutes and 31 seconds ago, saying: Also, presumably you don't use it everywhere.
06:57:15 <mm_freak> merijn: actually a real haskell programmer is unable to write average real world production code
06:57:40 <mm_freak> i just can't bring myself to write the same code the average "productive" PHP programmer writes
06:58:00 <Axman6> i think about my code too much to write production level code :P
06:58:01 <mm_freak> reading average PHP code makes me angry and sad
06:58:10 <merijn> I know what you mean
06:59:24 <rostayob> I think that all this snobism is irritating :P
06:59:54 <merijn> It's cathartic :p
07:00:16 <hnsz> Once you get over it
07:01:45 <rostayob> I mean I'm an intern in a company that uses java, I code java all day, and personally I wouldn't suggest them to switch to haskell for the next project, for a number of reasons
07:02:13 <rostayob> still they manage to ship loads of stuff and everything, more or less, works
07:02:25 <hnsz> What reasons?
07:02:43 <byorgey> preflex: seen ivanm
07:02:44 <preflex>  ivanm was last seen on #haskell 6 hours, 10 minutes and 4 seconds ago, saying: @tell chrisdone it would be nice if the upload functionality asked your for the file to upload
07:03:06 <rostayob> hnsz: lack of tools and libraries for haskell, lack of haskell programmers
07:03:50 <rostayob> writing beautiful code will never be the goal, making money is the goal :P
07:04:29 <rostayob> we'll get to the point in which using haskell will be convenient for big companies, I hope :P
07:05:04 <mux> I think so; but I also think that will happen long after I'm dead and buried
07:05:12 <hnsz> Well I was only interested in your pragmatic reasons for not using it :)
07:05:16 <frerich2> rostayob: It seems to me (I'm still rather new at this) that a lot of Haskell'ers are coming from a scientific environment (e.g. students) and tend to care about stuff which is not always aligned with (in fact, sometimes it's probably orthogonal to) what a paying customer/boss needs. :-}
07:05:43 <frerich2> rostayob: Still, it's worthwhile to spend time on this, it does have a positive effect on your daily work in Java/C++/whatever
07:05:56 <merijn> orthogonal to what they need...in the short term
07:06:13 <frerich2> merijn: Often, in the mid/long term they have different needs anyway. :-}
07:06:14 <rostayob> frerich2: yeah I agree. also, there are small companies that use Haskell/ML profitably
07:06:19 <hnsz> Though programmers being happy with what they write and not having to struggle with a language  could make them more productive possibly.
07:06:31 <illissius-> ...which I why I avoid Java like the plague.
07:06:34 <illissius-> *is
07:06:40 <frerich2> hnsz: I agree.
07:06:41 <RenJuan> happy happy. happy is stoopy.
07:06:46 <rostayob> hnsz: the percentage of programmers that are happy writing Haskell is very small
07:06:48 <mux> hnsz: you get annoyed by the triviality of stuff long before you get annoyed by the language, most of the time
07:06:58 <rostayob> I mean most people don't mind java
07:07:05 <hnsz> rostayob: I have no clue about those numbers.
07:07:16 <merijn> mux: Really depends
07:07:32 <rostayob> hnsz: well here there are thousands of people and people are happy with java/C++
07:07:36 <merijn> mux: For example, right now I'm more annoyed by the hoops C is making me jump through then by the work I'm doing
07:07:45 <mux> merijn: I'm now writing python day-to-day, and I mostly don't give a fuck ;-) Pardon my french.
07:07:51 <RenJuan> last I checked haskell was like 40 somethingth most popular
07:08:00 <mux> merijn: if that was for a personal project, that would be very different
07:08:06 <merijn> Yes, but python is one of the languages I hate the least :p
07:08:19 <mux> I meant to say that it could be perl or ruby, it wouldn't change much
07:08:19 <RenJuan> but if you looked closer and make some inferences it's in the top ten
07:09:07 <mux> I get annoyed by the disgusting state of the code-base, the stupid bugs and the stupid programmers long before I get annoyed by the language they make me use - once againt, most of the time, not always
07:09:08 <RenJuan> (comments early in this channel by another nick with URLs)
07:09:12 <RenJuan> *earlier
07:10:01 <suselaloose> i blame the universities - graduating people with no real idea of what they're doing
07:10:02 <rostayob> mux: yeah but that is not the language fault
07:10:14 <suselaloose> a cs graduate who doesn't know what the lambda calculus is is apalling
07:10:19 <rostayob> mux: you can have a well organized project in java, and a really messy project in haskell...
07:10:22 <mux> rostayob: obviously not - I don't think I ever said that :-P
07:10:33 <rostayob> mux: ok then :P
07:10:46 <hnsz> rostayob: I didn't say anything about those languages. I'm sure they are. I'm personally very fond of c.
07:10:59 <suselaloose> haskell's rts is written in c
07:11:11 <suselaloose> so it must have been a better choice than haskell for that purpose
07:11:13 <mux> I love Haskell for its strengths, I love C for its weaknesses
07:11:24 <RenJuan> appalling even
07:11:31 <rostayob> mux: what?
07:11:38 <rostayob> you love C for what weaknesses :P?
07:12:08 <hnsz> In fact I love programming languages
07:12:25 <mux> rostayob: is it that hard to find some? :-)
07:12:27 <frerich2> mux: Pff, C has no weaknesses. It just happens to exhibit weaknesses of the programmer in a very relentless manner. :-}
07:12:53 <rostayob> mux: well I'm asking for the weaknessess that you love lol
07:13:04 <mux> C, as a language, is nearly horrible; as a tool, it's been more useful than any other language I can think of
07:13:41 <mux> I'm talking about weaknesses on the theoritic side - unsafe memory model and the likes
07:13:57 <rostayob> mux: those are conscious decision in C
07:14:11 <mux> rostayob: once again I don't think I've ever claimed the opposite
07:14:13 <djahandarie> Can anyone think of a syntactically nicer way to do this on one line?   case (clampEvenTimesTwo x) of { Refl -> case (clampEvenTimesTwo y) of { Refl -> lte } }
07:14:30 <hnsz> I love how Torvalds said it: c is a spartan language
07:14:33 * hackagebot HarmTrace 0.5 - Harmony Analysis and Retrieval of Music  http://hackage.haskell.org/package/HarmTrace-0.5 (JosePedroMagalhaes)
07:14:46 <djahandarie> (I'm using the case to introduce some type-level constraints from a GADT)
07:15:00 <Botje> djahandarie: case (clampEven... x, clampEven... y) of (Refl, Refl) -> lte
07:15:19 <djahandarie> Hmm, it was giving me shit for not using the braces
07:15:41 <Botje> > case (1,2) of (1,2) -> "ok"
07:15:42 <lambdabot>   "ok"
07:15:45 <rostayob> mux: the simple memory model is what makes C useful. I don't think they're weaknesses
07:16:00 <rostayob> well simple, close to the hardware
07:16:11 <rostayob> the fact that you need to know about memory at all :P
07:16:14 <mux> rostayob: you don't seem to realize it but you're saying about the same thing as I just did.
07:16:21 <mux> rostayob: why do you think I said I love those weaknesses?
07:16:22 <djahandarie> Botje, I think it's because it was nested in a bunch of other cases using whitespace stuff. I'll mess around with it more. Thanks.
07:16:32 <rostayob> mux: yeah but you called that a "weakness", I don't think they are
07:16:49 <suselaloose> rostayob - c is more and more distant from the hardware, really. for example, it has a model of uniform memory, and that is less and less true
07:16:50 <mux> rostayob: from a theoritical standpoint, they definitely are
07:17:06 <djahandarie> Botje, ah, what it didn't like was when I was putting an enter after the -> and trying to indent the expression
07:17:11 <rostayob> mux: no they're not, for a language that is designed to be at that level
07:17:35 <Botje> djahandarie: I do that all the time!
07:17:40 <rostayob> C was designed to write an OS and it's tools, and having any other memory model would have been stupid
07:17:42 <djahandarie> Botje, weird...
07:17:47 <rostayob> in 1970 anyway
07:17:59 <mux> rostayob: I can design a fork such that it will almost always harm the person using it - that may be a conscious choice, yet, from a safety point of view, it's only a weakness
07:18:01 <djahandarie> Botje, maybe because the expression I was indenting was another case?
07:18:09 <rostayob> mux: fork is not C
07:18:12 <mux> sigh
07:18:35 <hnsz> heh
07:19:55 <ocharles> http://hackage.haskell.org/trac/haskell-prime/wiki/CompositionAsDot "Cons: breaks a lot of code" that has to be understatement of the century!
07:19:59 <Botje> djahandarie: no idea
07:20:10 <merijn> rostayob: Pretty sure he was referring to an actual physical fork
07:20:23 <rostayob> merijn: ah. lol.
07:21:05 <rostayob> saying that the memory model of C is a weakness is like saying that the fact that a shotgun makes it easy to kill people is a weakness
07:21:21 <rostayob> I mean killing people is bad
07:22:19 <djahandarie> copumpkin, good news is that I've proved the ClampEven Functor for when both numbers are Even... now for the harder cases :p
07:22:24 <mux> yes, it's a weakness of shotguns to make it easy to kill people - only, from a *safety* point of view
07:22:27 <copumpkin> lol
07:22:30 <copumpkin> nice
07:22:45 <copumpkin> djahandarie: just write this in agda :P it'll take you 20 minutes
07:22:53 <djahandarie> Noooo!!! I'd be giving in
07:23:00 <djahandarie> The whole point is to prove it's possible to do in Haskell ;)
07:23:37 <djahandarie> Haskell can be used for proving things too... :(
07:23:42 <rostayob> mux: yeah but when judging a shotgun, the easiest it is to kill people the better :P
07:23:57 <mux> rostayob: given that programming language theory concernes itself (among other things) with the design of languages where it's hard (or harder) to write bugs, that aspect of C cannot be said to be anything else than a weakness. A very useful one too.
07:24:08 <mux> concerns*
07:24:38 <mux> if I'm still not able to convey my thoughts after that last sentence, I'll just give up :-P
07:24:55 <suselaloose> mux: writing to an unallocated area of memory is not a bug if that's exactly what you tell the c compiler to do
07:24:59 <djahandarie> copumpkin, do you remember if partially applied type families end up giving you full type lambdas?
07:25:06 <mux> jesus fucking christ
07:25:20 <rostayob> mah whatever, we're running in circles. C was designed to write an operative systems, so I don't see its memory model as a weakness. It becomes a weakness when you write high level stuff in C
07:25:23 <copumpkin> djahandarie: yeah, just like type synonyms
07:25:31 <mux> whatever
07:25:32 <djahandarie> Yeah, makes sense
07:25:47 <djahandarie> It'd be nice if it was allowed in the cases where you are clearly not doing that
07:25:58 * RenJuan hands mux a muggle muzzle.
07:26:27 <hnsz> eally the difference is building a house from prefab elements or from structural steel where you have to design a safe construction yourself. There is no weakness there imo
07:27:49 <thoughtpolice> a 'weakness'? maybe not, but it is a pain in the ass, cf the whole part where it's totally easy to fuck up, resulting in your house falling apart/users getting owned. C's memory model may not be a 'weakness' by your definition, but it is error prone even for the places where it is useful
07:27:55 <thoughtpolice> that is the problem
07:28:44 <hnsz> I think it's like the other guy said earlier it exposes the programmers weakness. And since all programmers have weak moments you could opt to go for prefab elements.
07:29:03 <thoughtpolice> empirical evidence would show even the best programmers fuck this up, so i'm not sure i buy that at all
07:29:09 <thoughtpolice> go look at the amount of programming errs in the linux kernel
07:29:16 <lispy> Has anyone made a version of C with templates but no classes/objects?
07:29:33 * hackagebot HarmTrace 0.6 - Harmony Analysis and Retrieval of Music  http://hackage.haskell.org/package/HarmTrace-0.6 (JosePedroMagalhaes)
07:29:40 <elliott_> lispy: iirc, CUDA
07:29:50 <suselaloose> lispy - don't think so, but remember you can template a function, so you can use templates without using classes
07:29:52 <lispy> A system (bare metal?) friendly language that is a bit nicer than raw C without being C++
07:30:10 <elliott_> bit-c :P
07:30:37 <lispy> elliott_: CUDA is NVidia's propreitary language, right?  For GPGPU?
07:30:54 <elliott_> yeah
07:31:00 <elliott_> or was it glsl
07:31:04 <elliott_> i lose track
07:31:07 <mux> funny to heard the good old "programmers should just not write bugs" argument in #haskell
07:31:10 <mux> hear*
07:31:18 <elliott_> one of 'em has templates but no oo
07:31:20 <RenJuan> are yall smart people actually havin a lang flame war?
07:31:33 <mux> next time in #agda and #coq
07:31:39 * mux giggles
07:32:07 <sbahra> Bonjour
07:32:12 <mux> hi Samy
07:32:21 <lispy> elliott_: I'll look at BitC again.  I had tossed it aside at one point, but I forget why
07:32:46 <elliott_> vapourwareish :P
07:32:53 <hpaste> cgroza pasted “haskell erorr” at http://hpaste.org/50363
07:33:08 <rostayob> lispy: D, go?
07:33:24 <elliott_> no
07:33:29 <rostayob> (never actually used them, but they seem to aim for the "nicer than C but fast" target)
07:34:09 <mauke> cgroza: precedence
07:36:21 <kamaji> is it possible to read a list backwards efficiently?
07:36:32 <mauke> no
07:36:33 <rostayob> kamaji: define efficiently
07:36:37 <kamaji> without doing reverse first
07:36:41 <rostayob> reversing the list will be linear
07:36:42 <elliott_> no
07:36:43 <rostayob> kamaji: no
07:36:52 <kamaji> is there an alternate structure? like a doubly linked list?
07:37:11 <mauke> a list that you built in reverse order in the first place
07:37:12 <rostayob> kamaji: a queue
07:37:24 <rostayob> if you want to get the front and the rear
07:37:30 <mauke> rostayob: whu?
07:37:33 <kamaji> but i'm guessing it doesn't support the [] syntax, right?
07:37:37 <hpaste> cgroza pasted “haskell erorr” at http://hpaste.org/50364
07:37:45 <zong_sharo> what is the best options to do polymorphic variants in haskell right now?
07:37:47 <kamaji> mauke: sorry I also wanted to do stuff like newItem:list
07:38:02 <kamaji> it is a queue basically
07:38:05 <rostayob> mauke: usually you need something ququeish if you need to do stuff with the front and the rear of a list...
07:38:09 <cgroza> I have a problem with this piece of code. http://hpaste.org/50364
07:38:19 <elliott_> Data.Sequence
07:38:21 <mauke> cgroza: yes, I already answered you
07:38:22 <cgroza> mauke: could you elaborate please?
07:38:23 <elliott_> at kamaji
07:38:29 <kamaji> elliott_: just got there from queue, hehe
07:38:32 <kamaji> but thanks!
07:38:38 <cgroza> mauke: I am a noob at haskell.
07:38:40 <elliott_> yw :P
07:38:42 <mauke> cgroza: do you know what operator precedence is?
07:38:49 <cgroza> mauke: yes.
07:39:06 <mauke> cgroza: how do you think line 6 is parsed?
07:39:30 <lispy> elliott_: I think I remember why I stopped looking at bitc, it doesn't appear that anyone has written any program in it (can't find examples) and it seems to be not at a "1.0" release state yet
07:39:43 <elliott_> lispy: aka, vapourware
07:39:44 <cgroza> mauke: my error is on line 4, check the new paste.
07:39:45 <elliott_> :)
07:40:01 <lispy> elliott_: cyclone has died, bitc is languishing...hmm
07:40:10 <mauke> cgroza: line 4 is empty
07:40:16 <elliott_> lispy: bitc was recently revived
07:40:23 * lispy wonders if D really is the best of breed "better than C" language
07:40:26 <cgroza> mauke: my bad, line 2
07:40:29 <cgroza> mauke: my bad, line 3
07:40:31 <lispy> elliott_: maybe I'm at the wrong website?
07:40:34 <elliott_> d < c
07:40:39 <mauke> cgroza: line 3 is fine
07:40:47 <lispy> elliott_: http://www.bitc-lang.org/
07:40:48 <elliott_> lispy: revived =/=no longer vapour
07:40:57 <elliott_> revived = worked on
07:41:15 <cgroza> mauke: ok
07:41:48 <lispy> elliott_: I may have to read the compiler source code to learn how to write programs in it :)
07:42:36 <cgroza> mauke: I really have no clue.
07:43:13 <mauke> cgroza: how can you write code if you have absolutely no idea how the computer is going to interpret it?
07:43:25 <cgroza> mauke: i am learning haskell now.
07:43:31 <mauke> yes, and?
07:43:35 <saml> can i help you?
07:43:48 <lispy> elliott_: I guess the language spec has some usable examples
07:43:53 <hnsz> cgroza: Try top read more perhaps. It usually works for me. Have you got a book?
07:43:54 <cgroza> mauke: I really dont see why that error comes up.
07:44:04 <mauke> cgroza: ok, but what about my question?
07:44:33 * hackagebot usb-id-database 0.4.0.6 - A database of USB identifiers  http://hackage.haskell.org/package/usb-id-database-0.4.0.6 (RoelVanDijk)
07:44:48 <merijn> lispy: Dunno, can languages with automatic memory management qualify as one of those "better than C" languages? :p
07:45:02 <cgroza> mauke: forget it.
07:46:59 <lispy> merijn: in my current definition, GC should be off or optional
07:47:49 <lispy> Honestly, whenever I look for something other than Haskell I endup wanting Haskell :)
07:48:12 <lispy> For example, I was looking for a "better C" language.  But really, I think I'd be happier making due with Haskell+FFI
07:48:23 <merijn> I kinda like Go as "C but better", but it's garbage collected, of course
07:48:45 <lispy> Go has no generics, templates, or parametric polymorphism, right?
07:49:09 <lispy> To me that's a pretty big omission
07:50:29 <saml> haskell is the best programming language for every problem, thanks.
07:50:44 <merijn> It sorta kinda has generics in the form of interfaces. Not quite a versatile as true generics, but enough to qualify as "better than C" :p
07:50:58 <mux> better then void * :-P
07:51:10 <merijn> exactly :p
07:51:17 * mux gets nightmarish thoughts thinking about sys/queue.h
07:51:26 <merijn> mux: Or macro-based "templates" like I have now >.>
07:51:38 <mux> heh, just like BSD's sys/queue.h for linked lists
07:51:40 <lispy> I think of Go as a simpler Java
07:51:51 <merijn> I think that's selling Go short
07:52:04 <lispy> I would sell Go pretty short :)
07:52:47 <lispy> I think the correct term for what I want, is C with templates and features that allow code to be memory-safe
07:52:48 <merijn> The biggest argument I've encountered so far is people saying "They're doing nothing innovative!", which is sorta odd because why does a language need to be innovative to be good to work in :p
07:53:16 <mux> lispy: Cyclone? :-)
07:53:18 <merijn> Don't forget higher order functions and easy threading :p
07:53:24 <mux> oh, Cyclone probably doesn't have templates.
07:53:24 <atsampson> lispy: I think of Go as occam 2 with better data types ;)
07:53:54 <lispy> mux: I like Cyclone and I installed it, but from talking to the authors it's kind of dead and they felt like it would almost be better to start over on it
07:54:12 <merijn> After several months of hacking together our own "lightweight user space threads" in C, I can really appreciate goroutines
07:54:19 <lispy> mux: cyclone has parametric polymorphism which I would happily take over templates
07:54:29 <mux> lispy: there's another C-like thingie with parametric polymorphism: C forall or something; don't know what state it's in though
07:54:50 <lispy> mux: Thanks for the reference
07:55:34 <lispy> mux: I can't seem to find it on google though
07:55:51 <mux> let me give it a try
07:55:51 <merijn> Shoulda called it "C∀" to stick with the theme for C named languages :p
07:57:01 <mux> lispy: bah, can't find it either
07:57:01 * lispy wonders if he should "make" this language he wants, but then I already have enough side projects going...
07:57:55 <lispy> hmmm...can't build bitc because my boost install is too old
07:58:04 <lispy> (or maybe I just don't have boost...)
08:00:17 <dainanaki> is it possible to derive storable instances automatically?
08:01:03 <mux> that's when we miss proper, working polytopic programming
08:01:08 <mux> or did GHC 7.2 solve that?
08:01:09 <shamster> Hi all. Is there a function already in Prelude (or wherever) that does something like: (RealFrac a, Integral b, Monad m) => (a -> b) -> m a -> b
08:01:50 <mux> you'd get a "m b", not just b, or you won't be able to write this function for every Monad
08:01:51 <shamster> I have a random # generator that returns an IO Double, but I'd like to 'truncate' it, which requires a Double outside of IO
08:01:53 <Axman6> that would involve having a function that could do Monad m => m a -> a
08:02:14 <shamster> okay, so I have to write the intermediary function...?
08:02:14 <djahandarie> copumpkin, success. :) Now to figure out how I'm going to represent ClampEven so it's actually accepted as a Functor...
08:02:34 <Axman6> shamster: it can't be done really, and you should be able to do what you want without needing that
08:02:59 <mux> shamster: you can only extract a value out of some specific monads such as lists or Maybe - you probably don't want to do this anyway
08:03:00 <Axman6> it can be done for some monads, but not many of the popular ones (IO, Maybe, Either, [])
08:03:14 <shamster> Axman6: then I guess I should ask a different question: how can I use truncate in the IO monad?
08:03:24 <Axman6> what is truncate?
08:03:28 <Axman6> :t truncate
08:03:29 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:03:31 <Axman6> ah
08:03:34 <rostayob> shamster: do {x <- getRandomNumber; return (truncate x)}
08:03:47 * mux calls it a day and heads back to $home
08:03:55 <shamster> rostayob: Okay, so I have to leave IO monad altogether and then work on the values...
08:04:05 <benmachine> you want (a -> b) -> IO a -> IO b
08:04:11 <benmachine> which is liftM or fmap
08:04:15 <Axman6> well, you can use fmap truncate foo, and if foo :: IO Double, then fmap truncate foo would be something like IO Int
08:04:22 <mm_freak> repa performs very bad compared to Vector for (as far as possible) direct vector-to-repa code translations…  i suspect that this is because of the index type…  is there any way to get around this, or is repa just not production-ready yet?
08:04:25 <Axman6> shamster: you never leave the IO monad
08:04:26 <rostayob> shamster: no it's the opposite, you can't leave the IO monad :P
08:04:32 <shamster> haha
08:04:38 <rostayob> you have to perform the truncation in IO
08:04:49 <rostayob> so yeah what I said (the stupid way) or fmap
08:04:58 <mm_freak> i mean it does parallelize automatically, but the 8x parallel code is still slower than the nonparallel Vector-based code
08:05:08 <benmachine> rostayob: the thing you said is basically the definition of liftM
08:05:10 <Axman6> mm_freak: you'll have to talk to benl23 about that, there's not many people who know much about repa apart from him (dons maybe)
08:05:10 <benmachine> it can be more clear
08:05:12 <rostayob> benmachine: yes
08:05:24 <shamster> okay, so either perform the truncation in IO to result in an IO Int, or do something like x <- random to pull it out of being an IO Double...
08:05:26 <mm_freak> Axman6: ok thanks
08:05:34 <rostayob> I think it's clearer to show that way, he might not know what fmap does
08:05:38 <Axman6> mm_freak: you might try TacticalGrace too
08:05:53 <mm_freak> i think i'll just post to the ML
08:05:55 <rostayob> shamster: you don't "pull it out", you just use it inside the IO monad
08:05:58 <ricree> :t fmap
08:05:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:07:54 <rostayob> shamster: you never leave the IO monad, with that do block you're just saying what to do inside the IO monad
08:08:07 <shamster> rostayob: here's my other newb question for you - is there a benefit to keeping it an IO type instead of (what's the word for removing the IO name?)?
08:08:12 <rostayob> and that notation is valid for every monad (if you didn't know already :P)
08:08:18 <dainanaki> does anyone have any advice on how to improve performance when using enumerators/enumeratees/iterators? I'm having a hard time reasoning about how chunk size and whatnot affects performance.
08:08:31 <benmachine> shamster: what you should mostly do is write "pure" (non-IO) code
08:08:42 <rostayob> shamster: the benefit is mantaining purity. In haskell you don't have side effects
08:08:46 <benmachine> and then use short IO do-blocks to apply your pure functions
08:09:13 <shamster> benmachine: so with that, should I avoid fmap - which just propogates more IO code?
08:09:28 <benmachine> shamster: fmap's good but
08:09:29 <benmachine> for example
08:09:43 <rostayob> shamster: If you could "leave" the io monad, you could have a function of type :: Int that writes to a file (and that's the case for most programming languages, which are impure)
08:10:01 <benmachine> fmap thisFunction (fmap otherFunction ioThing) is less good than fmap myFunction ioThing where myFunction = thisFunction . otherFunction
08:10:11 <benmachine> hmm
08:10:14 <benmachine> that wasn't very clear
08:10:18 <Axman6> indeed :P
08:10:43 <shamster> :)
08:11:17 <Axman6> shamster: take a look at this: http://random.axman6.com/blog/?page_id=70
08:11:35 <shamster> What I'm seeing are 2 routes: 1) use something like fmap, where I end up still using the monad, or 2) use the '<-' operator to "pull out the value from the monad" and work on pure-code...
08:11:35 <Axman6> should give you enough of an idea of how to work with the IO monad
08:11:57 <benmachine> shamster: no, those two are basically the same
08:12:00 <rostayob> shamster: the two routes are identical, they're doing the same thing
08:12:24 <rostayob> in both case, you're telling what to do with some values that you get in IO, while staying in the IO monad
08:12:25 <shamster> Axman6: thanks
08:13:03 <benmachine> shamster: basically just try to keep the bits of your code that know about IO small
08:13:06 <benmachine> however they are written
08:13:16 <Axman6> shamster: basically, you apply pure runctions to the results of IO actions in the IO monad. i think that's what you're trying to say, but it's somewhat unclear (and said in an incorrect way)
08:13:16 <shamster> benmachine: rostayob: Okay, that makes sense, but is also confusing...
08:13:16 <rostayob> shamster: see it as a box, in both cases you're modifying what's inside without taking it out. fmap is a shorthand (and it's actually more general, see Functor :P)
08:13:49 <rostayob> with fmap you're not doing it explicitly, you're just saying "go and apply this function to what's inside the box"
08:14:24 <benmachine> shamster: say you want your program to output strings at various points inside it
08:14:39 <benmachine> shamster: them you could either write all your program as an IO operation, and put putStrLn everywhere
08:14:39 <shamster> in one case, if I use fmap, I get back an "IO Double" or "IO Int" etc. In the other case, if I write some code that starts with "x <- myIOFunction" I get a "Double" or an "Int"... which seems to me fundamentally different than staying in the IO Monad
08:14:43 <benmachine> *then
08:14:55 <rostayob> shamster: no, you don't get a double or an Int
08:15:00 <benmachine> shamster: or you could make a function which returns a list of strings, and then print them all at once in your main function
08:15:09 <rostayob> :t do {x <- return 5.3; return (truncate x}
08:15:10 <lambdabot> parse error on input `}'
08:15:12 <rostayob> :t do {x <- return 5.3; return (truncate x)}
08:15:13 <lambdabot> forall (m :: * -> *) b. (Monad m, Integral b) => m b
08:15:25 <rostayob> :t fmap truncate (return 5.3)
08:15:25 <benmachine> shamster: the latter is the "more pure" option, and therefore often considered better
08:15:26 <lambdabot> forall b (f :: * -> *). (Integral b, Monad f, Functor f) => f b
08:15:35 <shamster> benmachine: and you're saying that both methods are the same in the end?
08:15:39 <benmachine> (the latter of my options, not yours)
08:16:01 <shamster> benmachine: yes, both of your options are equivalent?
08:16:04 <benmachine> no
08:16:07 <shamster> no...
08:16:08 <benmachine> both of yours are :P
08:16:09 <c_wraith> @src liftM
08:16:09 <kmc> rostayob, fmap f x = do { y <- x; return (f y) }
08:16:09 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:16:17 <benmachine> ok I'm not explaining well this evening so I'll b quiet
08:16:17 <shamster> oh, okay
08:16:21 <benmachine> everyone else can help you
08:16:25 <kmc> err that was for shamster not rostayob
08:16:27 <shamster> benmachine: no, it's helpful, and thanks
08:16:53 <rostayob> shamster: they're basdically the same, and as you can see ghc infers the same type (apart from Functor, don't worry about that)
08:17:14 <rostayob> actually yeah liftM is exactly the same
08:17:15 <dainanaki> this might be a long shot, but is there anything akin to a takeWhileM function out there?
08:17:43 <shamster> rostayob: but for being idiomatic, it's better to do short bits of IO, and stay mostly pure...?
08:18:05 <rostayob> shamster: you should try to be as pure as possible always
08:18:19 <rostayob> I mean you should have the functional part of your program in pure functions
08:18:35 <shamster> rostayob: okay. I'll go write more code and see if this trouble comes up again :) Thanks!
08:18:43 <rostayob> and then do IO when necessary, but it's usually at the beginning (getting the input) and at the end (outputting the result) :P
08:18:58 <rostayob> read this http://learnyouahaskell.com/ !
08:19:01 <rostayob> ehe
08:19:01 <benmachine> shamster: it's a sort of general principle that you should make your types as specific as possible
08:19:12 <benmachine> shamster: so if you don't need IO, don't use it
08:20:21 <c_wraith> ...  Eh?  The general principle is make your types as general as possible.  Which also usually means "don't use IO if you don't need it", because IO is more specific.
08:20:22 <shamster> benmachine: Is there a term for getting a value via "value <- someIOFunction" ?
08:20:29 <shamster> or... what's the "<-" called?
08:20:39 <benmachine> c_wraith: mm, there's a sort of argument for both
08:20:46 <kmc> shamster, sometimes called "bind"
08:20:56 <kmc> shamster, it's sugar for using the infix operator (>>=)
08:20:56 <djahandarie> Does LiberalTypeSynonyms not work with TypeFamilies? It'd be really nice if it did
08:21:01 <kmc> which is also pronounced "bind"
08:21:04 <rostayob> shamster: the do notation is sugar for the >>= operator
08:21:06 <benmachine> c_wraith: I meant, say, if you only have two possible return values, it's more sensible to return Bool than Integer
08:21:36 <shamster> thanks
08:21:46 <benmachine> it depends what you mean by "specific" and "general"
08:21:55 <benmachine> your types should be exactly as big as they need to be
08:22:05 <rostayob> do {x <- getNumber; return (truncate x)} is equivalent to getNumber >>= \x -> return (truncate x)
08:22:10 <kmc> shamster, also, don't think about "IO functions"
08:22:16 <benmachine> IO a is a very big type, so don't use it too much
08:22:27 <kmc> it's not as though "a -> IO b" is an 'impure' version of "a -> b"
08:22:37 <kmc> it's a pure function that returns an IO action, a value of type (IO b)
08:22:55 <shamster> kmc: but the action isn't performed yet...
08:23:01 <kmc> correct
08:23:10 <shamster> kmc: does the action get performed when using a bind?
08:23:22 <kmc> depends on your perspective
08:23:26 <identity_> shamster: it gets performed when you execute it in mian basically
08:23:28 <identity_> or in ghci
08:23:30 <identity_> *main
08:23:31 <benmachine> main gets performed
08:23:34 <kmc> you're building a larger action out of smaller ones
08:23:38 <shamster> gotcha
08:23:47 <identity_> it's all thunked
08:23:49 <kmc> you're building a description of some IO out of descriptions of other IO
08:23:58 <kmc> "thunked" but not in the lazy-evaluation sense
08:24:11 <kmc> evaluation being separate from execution
08:24:34 <shamster> Does using a 'seq' perform actions, or does it just sequence them for when they will finally be performed?
08:24:35 <identity_> listen to kmc
08:24:46 <kmc> shamster, seq has nothing to do with IO actions
08:24:54 <kmc> seq is used to force evaluation
08:25:02 <kmc> evaluation and execution are distinct
08:25:16 <Axman6> shamster: all seq a b says is that before b is evaluated, a needs to be evaluated to weak head normal form
08:25:25 <kmc> not even "before", actually
08:25:26 <kmc> that's pseq
08:25:46 <Axman6> eh?
08:25:47 <kmc> shamster, evaluation means taking an expression and performing computation until it produces a constructor
08:25:55 <shamster> kmc: I was about to ask :)
08:26:03 <kmc> execution means taking an IO action and performing the steps described
08:26:09 <kmc> actually going and doing IO with the real world
08:26:13 <deech> I'm doing some work in Lisp and one of its advantages it turning data into code pretty easily (e.g turn an XML Schema into a set of forms and reading/writing an XML file using those forms). Are there any idioms for doing this in Haskell? So far Data.Dynamic seems to be the only approach.
08:26:24 <kmc> evaluation can't trigger execution (except with hacks)
08:26:39 <kmc> deech, google:  haskell xml schema
08:26:59 <kmc> Dynamic isn't what you want *at all*
08:27:01 <dolio> Saying that 'seq a b' causes a to be evaluated if b is is also misleading.
08:27:11 <kmc> you can make an algebraic data type to represent "untyped XML" easily enough
08:27:16 <shamster> kmc: how does one force execution?
08:27:28 <kmc> shamster, the only thing executed is 'main'
08:27:34 <kmc> or stuff you type at the ghci prompt
08:27:35 <shamster> kmc: I see
08:27:37 <dolio> Rather, if you evaluate the 'seq a b' expression, a will be evaluated, and the expression evaluates to b.
08:27:51 <kmc> you can build IO actions anywhere, because they're ordinary first-class values
08:27:54 <deech> kmc: I've used HaXML in the past. I was talking about general idioms for turning data into datatypes on the fly. I was just using the XML example because it was on my mind.
08:27:58 <kmc> and you can even force evaluation
08:28:09 <kmc> of those IO actions
08:28:12 <kmc> and nothing much will happen
08:28:37 <kmc> unless they end up as part of the action named 'main'
08:28:43 <dolio> 'let x = seq (ack 20 20) b in print b' will not do any evaluation of 'ack 20 20' when run as a program.
08:28:52 <shamster> kmc: This nuance of evaluation v execution is something missing from the books/tutorials out there
08:28:58 <kmc> i guess so
08:30:48 <kamaji> If I have an IORef list I want to add something to, can I use something like fmap or do I have to use read/writeIORef?
08:30:57 <kmc> :t modifyIORef
08:30:58 <lambdabot> Not in scope: `modifyIORef'
08:31:08 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Data-IORef.html
08:31:09 <kamaji> got it :)
08:31:21 <kamaji> thanks
08:31:22 <kmc> reference cells can't be functors
08:31:36 <kmc> because the "read" operation is covariant and the "write" operation is contravariant
08:32:09 <kamaji> Is that category theory?
08:32:22 <Axman6> kamaji: there's also atomicModifyIORef, which might be necessary depending on your concurrent semantics
08:32:22 <kamaji> I'm not exactly a mathematician, hehe
08:32:27 <kmc> not really
08:32:49 <kamaji> What are covariance and contravariance?
08:32:55 <Axman6> kamaji: you can't change the type of a piece of memory and keep your program typesafe basically
08:33:25 <kamaji> But isn't the type the same if i'm just adding data of the same type?
08:33:31 <kmc> kamaji, covariant functor F supports:   (a -> b) -> (F a -> F b)
08:33:42 <kmc> contravariant functor F supports (a -> b) -> (F b -> F a)
08:34:02 <kmc> kamaji, if IORef implemented Haskell's Functor class, you'd have fmap :: (a -> b) -> IORef a -> IORef b
08:34:10 <kmc> which could make sense if you only allow reading
08:34:29 <kamaji> but wouldn't a and b be the same type?
08:34:34 <Axman6> kamaji: if there was a class like functor that had fmap' :: (a -> a) -> f a -> f a it would be ok
08:34:45 <kamaji> oh ok
08:34:49 <kmc> kamaji, if you implement Functor you promise to provide fmap for *all* a,b
08:34:55 <conal> Axman6: though probably only for invertible functions
08:35:03 <Axman6> the type of fmap doesn't guarantee that a and b are the same type
08:35:11 <kamaji> right that makes sense
08:35:13 <kamaji> thanks
08:35:14 <Axman6> conal: hmm?
08:35:37 <conal> Axman6: if you're talking about mapping onto iorefs
08:36:01 <benmachine> you could implement a function (a -> a) -> f a -> f a easily enough, but I'm not sure what behaviour you'd expect from it
08:36:04 <conal> Axman6: transforming with h on the way out and inverse f on the way in
08:36:13 <conal> oops -- 'inverse h'
08:36:20 <Axman6> whaaa
08:36:24 <kmc> kamaji, another example is, for fixed T,  «data F a = F (T -> a)» is covariant, and «data G a = G (a -> T)» is contravariant
08:36:25 <Axman6> you've lost me
08:36:44 <dolio> They don't need to be inverse.
08:37:00 <kmc> kamaji, as a small exercise you can write functions «mapF :: (a -> b) -> (F a -> F b)» and «mapG :: (a -> b) -> (G b -> G a)»
08:37:24 <kmc> kamaji, the same problem comes up in subtyping systems
08:37:42 <kmc> Banana is a subtype of Fruit, but List<Banana> is not a subtype of List<Fruit>
08:37:48 <kmc> if the lists are mutable
08:38:00 <kmc> someone can convert your List<Banana> to a List<Fruit> and then put a Pear in it!
08:38:59 <kmc> so languages which handle subtyping and polymorphic containers correctly have to let you specify whether a type parameter is covariant, contravariant, or neither
08:39:05 <kmc> those languages include Scala and, uh, ...
08:39:27 <owst> C#
08:39:30 <dolio> Java.
08:39:35 <rostayob> java
08:39:37 <rostayob> yeah
08:39:52 <rostayob> but not for arrays, right? or something like that
08:40:02 <dolio> There are issues with things like that in Scala, though.
08:40:19 <kamaji> eek
08:40:35 <dolio> You can't write List[+A] (covariant) with a contains method.
08:40:40 <owst> I have a feeling arrays are always covariant in Java
08:40:45 <dolio> Because the argument to contains is an A, appearing in negative position.
08:41:05 <dolio> So bundling your methods inside the class conflicts with variance.
08:42:04 <rostayob> owst: I'm pretty sure that Banana[] is a subtype of Fruit[]
08:42:06 <dolio> Instead, they let the contains method take an inhabitant of any type, or any supertype of A, and use the fact that equality works between any two values in Java.
08:42:49 <kamaji> ok that confused me a bit
08:42:51 <dolio> Arrays should be invariant in Java.
08:43:05 <copumpkin> gosu!
08:43:09 <copumpkin> mmm
08:43:11 <dolio> Unless they're final, maybe.
08:43:25 <owst> rostayob: Yeah, that's what I said
08:43:30 <rostayob> owst: yes
08:44:27 <rostayob> dolio: well I can't remember the motivation, but that's the state of things
08:44:39 <dolio> What do you know, they actually are covariant.
08:44:40 <dolio> Geeze.
08:45:22 <kmc> java has variance annotations?
08:45:27 <rostayob> I think that the motivation is simply that before generics noone bothered to be sure the whole thing was safe
08:45:42 <rostayob> and then they couldn't change it
08:45:53 <rostayob> there is something about this in effective java
08:45:53 <owst> kmc: ? extends Foo or ? super Foo (or something like that)
08:46:03 <dainanaki> is there a generic way to turn something that's an instance of Data into a ByteString?
08:46:10 <rostayob> owst: yes wildcards
08:46:30 <kmc> that's a way to constrain the X in T<X>
08:46:33 <hpaste> djahandarie pasted “ImpedicativeTypes error?” at http://hpaste.org/50365
08:47:05 <kmc> but what i'm asking is, if X ≤ Y, how does Java decide whether T<X> ≤ T<Y> or T<Y> ≤ T<X> or neither?
08:47:23 <owst> Ah, yeah, fair point.
08:47:35 <dolio> kmc: Now that you mention it, I think that was dropped from the original proposal.
08:47:39 <kmc> that's a problem Scala at least attempts to solve
08:47:45 <dolio> And everything (except arrays) are invariant.
08:47:46 <rostayob> kmc:neither, right?
08:47:47 <kmc> but i don't know of another language which does
08:47:55 <rostayob> kmc: I mean they're invariant
08:47:59 <kmc> yeah, saying "neither" always is a safe default
08:48:00 <dreixel> dainanaki: sure. Data stuff can be shown, which can then be converted to a bytestring. Something more clever can also be done, of course.
08:48:19 <kmc> i happen to think no subtyping at all is a perfectly workable solution :)
08:48:36 <dainanaki> dreixel: i'm asking exactly because I'm trying to cut show out of a function.
08:48:44 <rostayob> yeah it's the best solution for java. generics already stretch the minds of many programmers (:
08:48:53 <dainanaki> but don't have access to the constructor.
08:49:10 <kmc> but if you're going to use subtyping, you don't want trivial wrappers to break it
08:49:14 <owst> kmc: C# allows you to specify variance
08:49:21 <kmc> ah
08:50:26 <dreixel> dainanaki: what do you mean with not having access to the constructor?
08:50:42 <rostayob> dreixel: that he doesn't have access to the constructor :P?
08:50:57 <rostayob> as in the constructor is not exported
08:50:58 <dreixel> dainanaki: also, by "shown" I mean "gshown" :-p
08:50:59 <dreixel> http://hackage.haskell.org/packages/archive/syb/latest/doc/html/Data-Generics-Text.html#v:gshow
08:51:33 <dainanaki> it's not exported from the module, so the data type is a black box.
08:51:50 <dreixel> and my question meant more something like "can't you use toConstr?"
08:51:51 <dreixel> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Data.html#v:toConstr
08:52:03 <dreixel> though not all Data instances provide meaningful info there.
08:52:36 <dainanaki> hrm, well it's a good idea in theory, but I was hoping that there would be a way to cut out the string middleman and this doesn't look like it will do the trick.
08:52:44 <dainanaki> thanks though.
08:53:32 <dainanaki> I want to propose an extension that will generate shows to any StringLike.
08:53:33 <dreixel> dainanaki: no, you can certainly cut the middleman
08:53:44 <dreixel> and you should. I was just saying that it could certainly be done
08:54:06 <dainanaki> I'm afraid I'm not seeing how.
08:54:12 <dreixel> still, the function you're looking for will be similar to gshow
08:54:36 <dreixel> just not building a String, but a ByteString
08:54:46 <dreixel> see http://hackage.haskell.org/packages/archive/syb/latest/doc/html/src/Data-Generics-Text.html#gshows
08:54:57 <dreixel> are you any familiar with writing generic functions in syb?
08:55:12 <dainanaki> nope, i think this could be a fun learning experience though.
08:55:47 <dreixel> I think so too :)
08:56:18 <dreixel> you'll have to do something like checking how many constructors your datatype has
08:56:31 <dreixel> and which particular constructor the value you got is
08:56:37 <dreixel> and write that as a Word8
08:56:48 <dreixel> and then concatenate with the arguments of the constructor
08:56:59 <rwbarton> StringLike?
08:56:59 <dainanaki> well, I know that it only has one constructor.
08:57:19 <dreixel> well, you wanted a function of type Data a => a -> ByteString, right?
08:57:28 <dreixel> you can't assume that type will have only one constructor.
08:57:48 <dreixel> if you know what `a` is, then you don't need syb, you can just write a type-specific instance.
08:58:03 <rostayob> dainanaki: it shouldn't be too hard anyway, take a look at this for example http://hackage.haskell.org/packages/archive/json/0.4.4/doc/html/src/Text-JSON-Generic.html#toJSON
08:58:34 <hpaste> c_wraith annotated “ImpedicativeTypes error?” with “ImpedicativeTypes error? (annotation)” at http://hpaste.org/50365#a50366
08:58:55 <c_wraith> dolio, djahandarie:  see my annotation there
08:59:33 <c_wraith> the part that makes it work is the type annotation on the Fun constructor
08:59:45 <dreixel> ah, yes, that seems like a nice example
08:59:50 <djahandarie> That looks dumb
09:00:08 <c_wraith> without that, GHC attempts to infer a monomorphic type for the argument to Fun, and fails
09:00:21 <dolio> c_wraith: Ah, okay.
09:00:53 <dolio> That's unsurprising in retrospect, but kind of a bummer.
09:00:54 <djahandarie> That makes sense though
09:00:58 <djahandarie> Yeah
09:00:58 <djahandarie> lol
09:01:40 <c_wraith> I should dig up the ticket, as you request, though.
09:01:44 <c_wraith> It has more information
09:01:56 <dolio> Inferring higher-rank and impredicative types is all about making arbitrary decisions about what you have to annotate, though.
09:02:09 <djahandarie> Okay, if you'd like. This should be enough to solve the problem I'm having though... hopefully
09:02:22 <dolio> Although I don't think having to annotate Fun there is a great decision.
09:02:40 <djahandarie> Yeah, annotating the constructor seems really odd
09:02:46 <c_wraith> http://hackage.haskell.org/trac/ghc/ticket/4347
09:02:49 <c_wraith> there
09:03:06 <c_wraith> amusingly, dolio is the actual reporter of that issue
09:03:15 <c_wraith> I just jumped in asking for more information
09:03:23 <djahandarie> Heh
09:04:27 <dolio> Oh, it's that bug.
09:04:49 <dolio> That bug doesn't even have to do with what GHC calls impredicative types, though.
09:05:08 <dolio> It's just a fairly unsatisfactory change in the rank-n inference.
09:05:41 <dylukes> Could someone define what rank n types mean?
09:06:19 <rostayob> when you've got forall to the right of arrows :P
09:06:30 <dolio> Rank(T) = 0 if T has no quantifiers.
09:06:49 <dolio> Rank(forall a. T) = max(1, rank(T))
09:06:58 <dylukes> I see.
09:07:05 <dolio> Rank(T -> U) = max(1 + Rank(T), Rank(U))
09:07:18 <dolio> Actually....
09:07:57 <rostayob> dylukes: I think it's easier to understand looking at existential types
09:07:58 <dolio> That should be max((let r = Rank(T) in if r > 0 then r+1 else 0), Rank(U))
09:08:30 <dolio> So (forall a. a) -> Int has rank 2.
09:08:39 <dolio> ((forall a. a) -> Int) -> Int has rank 3.
09:08:41 <dolio> Etc.
09:09:28 <dylukes> :|
09:09:39 <dolio> Int -> forall a. a isn't counted as having a higher rank because it's isomorphic to forall a. Int -> a
09:09:45 <dylukes> confused. but okay.
09:09:55 <dylukes> ill get back to it later
09:09:59 <dylukes> I need to finish summer reading :O
09:12:13 <rostayob> dylukes: or a good example is when you want to get a function that prints stuff, and use it on arguments of different types
09:12:27 <djahandarie> Hmm, this is requiring me to annotate the crap out of shit everywhere
09:12:30 <djahandarie> God damn it
09:12:43 <rostayob> so for example printStuff :: Show a => (a -> String) -> Int -> Bool -> String; printStuff f x b = f x ++ f b won't work
09:13:07 <rostayob> printStuff :: (forall a. Show a => a -> String) -> Int -> Bool -> String will
09:13:31 <rostayob> and that is rank 2
09:13:34 <djahandarie> Ugh, and all I ended up hitting was "Cannot deal with a type function under a forall type:"
09:13:41 <djahandarie> Damn you GHC!
09:15:09 <djahandarie> byorgey, any idea if http://hackage.haskell.org/trac/ghc/ticket/4310 is fixed as a result of the new coercion stuff you've done?
09:15:53 <jonkri> i want to use Data.Dynamic types as keys in a Map (like, mapping from the dynamic type to a function using a value of the dynamic type), but i can't figure out how the type is represented. is it the Typeable TypeRep type? if so, how can i find out how to use the type constructor?
09:16:19 * djahandarie will brb, lunch
09:29:13 <ski> kmc : O'Caml has variance annotations
09:29:43 <mauke> I want gravity annotations
09:32:59 <c_wraith> gravity as in acceleration due to curvature of space-time, or gravity as in  importance?
09:34:42 <mauke> gravity as in gravity suit
09:35:04 <dolio> From metroid?
09:35:24 <mauke> man, do I have to explain all my obscure jokes?
09:35:40 <ski> (<http://caml.inria.fr/pub/docs/manual-ocaml/manual016.html> describes those covariance annotations breifly)
09:35:50 <dolio> Shouldn't you be asking for gravitynce annotations, then?
09:36:38 <dolio> Or is this like the people addicted to chocohol?
09:36:39 <copumpkin> ski: I think all type variables should be covariant
09:37:14 <dolio> Or sexohol.
09:37:55 <dolio> Clearly.
09:38:03 <copumpkin> ski: now this is a real language: http://lazygosu.org/generics.html
09:38:04 <dolio> Just don't do anything bad.
09:39:21 <copumpkin> real programmers don't do bad things
09:39:32 <copumpkin> except when they want to call a contains method
09:39:45 <dolio> We need types to check errors.
09:39:57 <dolio> But sometimes the types will just not check the errors correctly.
09:40:02 <dolio> So don't make mistakes when they don't.
09:40:42 <leod> heh
09:40:58 <ocharles> Can anyone help me choose a JSON library? I'm working on Haskell bindings to elasticsearch, so I need to have something like  indexDocument :: CanBeTurnedToJSON a => a -> IO ()
09:41:48 <ocharles> I see there's quite a bit in the "JSON" section on hackage, and I'm not sure what to focus my reading on...
09:44:18 <c_wraith> "This is not sound, and that does not matter."
09:44:21 <c_wraith> nice
09:45:28 <c_wraith> ocharles: aeson is probably the best option
09:45:52 <ocharles> ok, that was what my gut feeling was, as I'd heard that package used elsewhere
09:46:38 <Cale> ROFL wtf, they link "covariant" in that article to the wikipedia article about covariance in probability theory (which is a completely unrelated definition)
09:46:41 <ski> would it work to say `public boolean contains(E e)' ?
09:47:19 <c_wraith> ocharles: a handy rule of thumb, when considering multiple packages - If any are written by Bryan O'Sullivan and do what you want, they're probably the best option. :)
09:47:32 <ocharles> haha, ok :)
09:48:53 <djahandarie> byorgey, byorgey, byorgey !
09:50:38 <luite> mushroom mushroom
09:50:57 <Cale> Why don't they just include a way to write arbitrary type inequality constraints?
09:53:00 <ski> btw, i think some arguments against allowing contravariance is based on really wanting to have recursive class types, as used for functional update <http://caml.inria.fr/pub/docs/manual-ocaml/manual005.html#toc30> and binary methods <http://caml.inria.fr/pub/docs/manual-ocaml/manual005.html#toc33> in O'Caml
09:54:40 * hackagebot cpsa 2.2.5 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.5 (JohnRamsdell)
09:55:18 <copumpkin> that's an interesting project
10:00:47 <Cale> I think inheritance is a bad idea in general.
10:01:50 <ski> implementation or specification inheritence ?
10:02:18 <Cale> implementation
10:03:36 <ski> well, it's certainly over-used -- i'm not sure about it's badness is generall, though (compared to alternatives)
10:04:39 <Cale> It also bothers me the way that many typed OO languages do this silly thing where they mix the definition of the type with the definition of the methods on the objects of that type. The methods should be part of each object, not part of their type.
10:04:40 <ski> if you have a proof by induction on some data type, and want to extend the datatype, then in some cases it's possible to extend the proof without changing the existing parts, just adding new cases, that's implementation inheritance
10:04:54 <Cale> (the types of the methods are obviously part of the type)
10:06:04 <ski> Cale : yeah, the strong coupling that requires object types to have exactly one main class (i.e. implementation), of which all others are extensions of, is bad
10:06:15 <Cale> ski: Which is fine if all you care about is truth and not about which proof you're getting ;)
10:06:33 * RenJuan presumes Cale means the type of the value the method returns
10:06:39 <ski> O'Caml allows you to specify object types separatedly from object values
10:06:47 <Cale> RenJuan: yes
10:06:57 <Cale> RenJuan: which is the type of the method
10:07:06 <ski> (but they also has a class system, which i'm not as familiar with how it works, but that provides implementation inheritence)
10:07:09 <RenJuan> actually no it isn't
10:07:12 <Cale> ?
10:07:29 <Cale> Maybe we're talking past each other somehow.
10:07:33 <RenJuan> but then we're talking about an unspecified lang
10:08:22 <RenJuan> in this lang the function/method construct is as like as not to not be modeled as any type (as distinct from a value or lack of one returned)
10:08:56 <Cale> What?
10:09:14 <RenJuan> one way to describe haskellers is people who go bat shit over type theory
10:09:55 <RenJuan> as if it were the final solution
10:10:15 <Cale> RenJuan: Basically, a class should consist of a bunch of names of methods/messages, and their types. They'll be function types if the messages take parameters, and not functions otherwise.
10:10:45 <Cale> To form an object of the class, you provide implementations of the methods.
10:12:16 <cheater> i think RenJuan is protontorpedo
10:12:36 <RenJuan> well to provide it with the desired detailed behaviour you do
10:13:13 * RenJuan has no idea who prontowhosits is.
10:13:35 <Cale> But the implementations should not be part of the definition of the class itself. The class ought to be purely a type-level thing.
10:13:54 * RenJuan is however the Chinese name of JuanDaugherty.
10:14:25 <RenJuan> yeah, C++ and the better ones do maintain that distinction
10:14:36 <Cale> C++ doesn't really maintain that distinction
10:14:48 <cheater_> Cale: i think RenJuan is protontorpedo
10:14:48 <Cale> Because you write implementations of the methods in the class declaration
10:14:50 <RenJuan> not to your satisfaction
10:14:58 <cheater_> or should it?
10:15:00 <cheater_> that's not very OO to have something that isn't an object.
10:15:00 <Cale> and not in the construction of the objects
10:15:06 <cheater_> @protontorpedo
10:15:06 <lambdabot> im such an asshole
10:15:12 <cheater_> hm...
10:15:14 <cheater_> @protontorpedo
10:15:14 <lambdabot> so with 100s of users adn different daabases haskell does fine?
10:15:28 <RenJuan> cheater_, I have no idea who prontotorpedo is
10:15:59 <Cale> cheater_: The class *might* itself be an object, but then you get to compile-time execution of code.
10:16:59 <Cale> Or some sort of dependently-typed thing.
10:17:07 <cheater_> or jit.
10:17:31 <cheater_> RenJuan, msg lambdabot @protontorpedo for more quotes
10:17:36 <Cale> But that's another issue
10:17:56 <cheater_> cale: i'd hardly call jit an issue, i think it's more of a problem than an issue
10:18:16 <Cale> I mean, it's not what I'm trying to discuss
10:18:29 <Cale> The main thing I'm complaining about is the way these languages force you to put implementations into class definitions.
10:18:30 <cheater_> ah ok
10:18:48 <cheater_> that's only illusoric
10:18:54 <cheater_> you can do
10:18:58 <cheater_> def foo:
10:19:00 <cheater_>     raise
10:19:03 <cheater_> and then do
10:19:10 <Cale> You have to subclass in order to provide separate implementations
10:19:10 <cheater_> MyClass.foo = function() ...
10:19:16 <cheater_> not really.
10:19:26 <Cale> Oh, I'm not talking about python, obviously.
10:19:31 <Cale> It's not a typed OO language
10:19:42 <cheater_> what's wrong with subclassing, anyways?
10:20:03 <cheater_> and besides, abstract classes are classes without implementation. exactly what you are describing.
10:20:14 <cheater_>  so what's wrong with subclassing?
10:20:20 <Cale> Well, it introduces distinctions which are often artificial.
10:21:06 <Cale> Basically what I'm advocating is that every class should be abstract
10:21:18 <cheater_> can you give me examples of such distinctions that are artificial?
10:22:52 <Cale> Well, any case where subclasses don't introduce new methods.
10:24:18 <ski> Cale : well, i think its possibly better to call the classes you want ("always abstract classes") object types instead (i've probably seen class type used somewhere too)
10:24:30 <Cale> yeah
10:25:04 <Cale> Well, if it helps people not be confused anyway
10:25:10 <c_wraith> Cale, how about the opposite?  prototype-based objects?
10:25:20 <Cale> I tend to think of the word 'class' as a synonym for 'object type' here
10:25:25 <ski> then you can continue to call an implementation of such an object type a class (possibly parametric), and then it would be classes, not object types, which supported (implementation) inheritence, if supported
10:25:25 <c_wraith> Objects and classes are the same thing!
10:25:45 <ski> are not :)
10:25:53 <Cale> ski: an implementation of an object type is an object
10:26:11 <ski> a value of an object type is an object
10:26:15 <Cale> yes
10:26:16 <Cale> same thing
10:26:30 <ski> an implementation of an object type, which can *extend* by inheritance, is a class
10:26:52 <Cale> I don't like that distinction between implementations and values.
10:27:07 <Cale> Sure an expression is not quite the same thing as a value
10:27:13 <ski> well, afaiu, you need it for implementation inheritence
10:27:33 <Cale> I don't like implementation inheritance anyway
10:27:44 <ski> (partly because a subclass of a class need not necessarily have an object type which is a subtype of the former's object type)
10:28:31 <Cale> ski: do you mean 'proper'?
10:28:50 <ski> (this becomes apparent with "functional update" and binary methods, both of require recursive (cyclic) types, but where the type of a subclass doesn't have to be a subtype)
10:30:04 <ski> no if the type of objects generated by `ClassA' is `TypeA', and `ClassB' is a subtype of `ClassA', then the type of objects generated by `ClassB', say `TypeB', doesn't have to be a subtype of `TypeA'
10:30:10 <Cale> Yeah, I think it's better just not to try to deal with inheritance in those cases. Let people provide the correct definitions that do exactly what they want, rather than trying to guess a proof.
10:30:17 <brisingr> da
10:30:22 <brisingr> oops wrong window
10:30:56 <ski> hm, i'm not sure what you mean by "the correct definitions that do exactly what they want" and "trying to guess a proof"
10:30:57 <Cale> It's similar to what we have with djinn. Djinn is great at inferring implementations from their types, but when there's more than one, you end up with an arbitrary choice.
10:31:10 <Cale> Well, here we have a bit more than just a type
10:31:32 <Cale> We have an implementation for a supertype, and some implementations for missing bits.
10:31:52 <Cale> and we want to somehow glue them together into an implementation for the subtype
10:32:15 <Cale> But in general, there's more than one answer for how this might be supposed to happen.
10:32:29 <ski> of course
10:32:31 <Cale> So my response is to just not do it automatically.
10:32:43 <ski> so there should not be any canonical mapping from the object type to the class
10:33:10 <ski> (though that's unrelated to what i talked about above)
10:33:41 <Cale> We don't need classes as distinct from object types then, because we're not going to attempt to solve ill-defined problems.
10:33:50 <Cale> (by making some arbitrary choices)
10:33:50 <ski> in general, you could have several alternative classes which each yield objects of the same type, when "instantiated"
10:34:07 <ski> i don't follow
10:35:07 <Cale> Well, look at the functional objects example you linked.
10:36:03 <Cale> When you make a subclass of functional_point in O'Caml, you get a different inherited implementation of move from what you get when you form a subclass of bad_functional_point
10:36:20 <Cale> (though I think 'bad' is misleading -- what if you wanted that behaviour?)
10:38:02 <ski> well, if you wanted a "functional update", you generally want to get something as the same as as before (or you'd know that you wanted to)
10:38:14 <Cale> sure
10:38:57 <ski> (modulo potential polymorphic updatings like `data Foo a = F (value :: a,str :: String); update_value :: (a -> b) -> (Foo a -> Foo b)')
10:39:11 <Cale> But the point I'm trying to make is that every recursive method call is inherently ambiguous when trying to inherit a definition from a parent class. You can make canonical choices about the matter, but you might make the wrong choices.
10:39:38 <ski> in what way is it ambiguous ?
10:41:03 <dolio> Does a recursive call in a parent reference the parent's definition, or the child's?
10:41:07 <Cale> In general, whether to make a value of the parent class or the subclass. O'Caml solves the problem by introducing syntax to try to give you a way to make that choice.
10:41:27 <Cale> right
10:43:37 <ski> well, afaiu, it always references the child's definition
10:43:53 <Cale> If you use the {< ... >} syntax it does.
10:44:04 <ski> (this is separate from replacing a method in a class with a modification of it in the new class, i.e. "super" calls)
10:44:12 <Cale> If you call the constructor explicitly it doesn't.
10:44:41 <Cale> (which is the cue that O'Caml uses to try to disambiguate)
10:44:56 <Cale> But that's just O'Caml
10:45:53 <ski> well in general one object type can have many classes (which is more or less the same as class constructors)
10:46:20 <Cale> It means though, that you need to make the right choice about what the children will inherit while you're writing the base class.
10:46:37 <ski> calling the class constructor is always going to generate a new object that is unrelated to the current one
10:46:51 <ski> no inheritence going in that case
10:46:53 <Cale> I'm not really interested in O'Caml specifically.
10:47:29 * ski is mostly using O'Caml as an example of a type system for objects and classes that does more things right that others he's seen
10:47:31 <Cale> O'Caml makes a bunch of choices about how to canonically choose which implementation the inherited code uses
10:47:46 <Cale> Those choices are essentially arbitrary
10:48:02 <ski> i still don't follow this
10:48:05 <hiptobecubic> when installing a haskell library, does one have to do something in particular to get the package to be recognized?
10:48:07 <Cale> It has some syntax to give you a bit of control over it
10:48:09 <catface> anyone know a quick way of parsing a binary String to an Integer?
10:48:16 <ski> you must explicitly say which classes, if any, you want to inherit from
10:48:19 <hiptobecubic> I installed alsa-core and now i'm trying to install alsa-mixer and it's complaining that alsa-core is not installed
10:48:30 <catface> with the list monad or something?
10:48:52 <Cale> hiptobecubic: Did you install alsa-core as user and are attempting to install alsa-mixer globally?
10:49:07 <Cale> (btw, don't install packages globally if you can avoid it)
10:49:08 <hiptobecubic> Cale, no.
10:49:15 <hiptobecubic> Cale, why not?
10:49:40 <hiptobecubic> don't most distros just package these things? which would be global
10:49:45 <parcs> catface: you mean a string like "01010" ?
10:49:47 <Cale> hiptobecubic: Because it's much more convenient if things get really messed up, to be able to blow away your ~/.ghc rather than having to reinstall GHC completely.
10:49:49 <catface> yes
10:50:06 <catface> > replicateM 4 "01" !! 10
10:50:07 <lambdabot>   "1010"
10:50:14 <catface> > replicateM 4 "01" !! 11
10:50:15 <lambdabot>   "1011"
10:50:17 <parcs> you can do that with a left fold
10:50:18 <Cale> With a package manager, global is fine in theory.
10:50:30 <ski> if you inherit from a class, and replace some methods, then all calls to those methods in the parent class will always call the actual methods in the object (which is the methods in the current class, if you instantiate that directly, or of a subclass, if you make further refinements before instantiating an object)
10:50:49 <Cale> (though in practice, I don't trust my distribution with anything related to Haskell)
10:51:07 <catface> ah, now i remember it was actually Integer -> String, nvm
10:51:15 <hiptobecubic> Cale, have you had problems in the past? which distro?
10:51:21 <Cale> hiptobecubic: Ubuntu
10:51:24 <catface> thanks parcs
10:52:20 <Cale> Well, the packages are usually out of date, and the usual stuff you get installing GHC is split up into tiny pieces which you need to ensure are all installed if you want things to be sane.
10:52:21 <byorgey> djahandarie: no, I don't think it is
10:52:32 <hpaste> djahandarie pasted “ClampEven is a monad on the order category of (<=)!” at http://hpaste.org/50372
10:52:44 <byorgey> djahandarie: what Simon was referring to in that ticket was refactoring work I did last summer, which is long since completed
10:52:47 <Cale> So I just install the generic linux binary
10:52:53 <Cale> and then cabal-install
10:53:02 <Cale> and then install any packages that I need as user
10:53:11 <byorgey> djahandarie: so now it is *possible* to fix it but it looks like it has not been.
10:54:33 <Cale> There's also the Haskell Platform. I'm not sure why I don't use that.
10:54:46 <djahandarie> byorgey, aha, okay...
10:54:49 <hiptobecubic> Cale, and that is?
10:54:59 <hiptobecubic> collection of libs?
10:55:02 <djahandarie> byorgey, think it'd be possible for me to fix it if I stab at GHC randomly?
10:55:04 <Cale> http://hackage.haskell.org/platform/
10:55:12 <tafryn> Is there a simpler way to express "groupBy (\x y -> snd x == snd y) listOfPairs" along the lines of "groupBy snds listOfPairs"?
10:55:16 <Cale> oh, right
10:55:20 <byorgey> djahandarie: no
10:55:29 <Cale> There's no generic binary linux release of HP
10:55:33 <byorgey> djahandarie: it looks like it would require messing with the constraint solver
10:56:08 <Cale> There's just an Ubuntu package, which means that it'll usually be out of date.
10:56:23 <byorgey> djahandarie: you really don't want to mess with the constraint solver unless your name is "Simon" or "Dimitrios"
10:56:44 <Cale> and a source package, but ugh
10:56:46 <djahandarie> Aw :(
10:56:57 <djahandarie> I'll just bump the ticket instead
10:57:00 <Cale> If you've already installed the GHC binary, there's no point in installing HP
10:57:20 <Cale> because it's quicker just to install cabal-install
10:57:32 <Cale> and then you can cabal install whatever you need as you need it
10:57:44 <cheater_> what is HP?
10:57:45 <cheater_> <Cale> Well, any case where subclasses don't introduce new methods. < why would subclasses have to introduce new methods? that's a bit crazy for me
10:57:49 <Cale> Haskell Platform
10:57:59 <cheater_> there should be a tutorial for getting everything you get from HP but via just getting GHC and cabal-install
10:58:25 <Cale> cheater_: If subclasses don't introduce new methods, they're essentially like newtypes.
10:58:38 <Cale> (to use the Haskell terminology)
10:58:46 <catface> > sum $ zipWith (*) (iterate (*2) 1) $ reverse $ map (\a -> ord a - 48) "10101010"
10:58:47 <lambdabot>   170
10:58:51 <Cale> and maybe undesired newtypes
10:59:42 <Cale> We can take this to an absurd extreme...
11:00:49 <parcs> > foldl ((+).(*2)) . map digitToInt $ "10101010"
11:00:50 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
11:00:50 <lambdabot>    arising from a use of `GHC...
11:00:56 <parcs> > foldl ((+).(*2)) 0 . map digitToInt $ "10101010"
11:00:58 <lambdabot>   170
11:01:01 <Cale> Imagine if every time you wanted to construct a new value of a Haskell data structure, unless the definition of any function arguments to the data constructors was the same as an existing one, you had to define a new type.
11:01:18 <Cale> That would suck, right?
11:01:19 <parcs> > foldl ((+).(*2).digitToInt) 0 $ "10101010"
11:01:20 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
11:01:20 <lambdabot>         against inferred type...
11:01:37 <Saizan> tafryn: groupBy ((==) `on` snd)
11:01:45 <Cale> But it's essentially what all the typed OO languages do.
11:01:50 <Saizan> tafryn: with Data.Function.on
11:02:49 <parcs> > foldl ((. digitToInt).(+).(*2)) 0 $ "10101010"
11:02:50 <lambdabot>   170
11:03:36 <Cale> Like, function arguments to the data structure would be specified directly in the data declaration as lambdas.
11:03:37 <Martty> that doesnt work
11:03:50 <ski> Cale : separeate from introducing new methods, you can also replace existing methods (so that existing calls to that methods in the class will call the modification) .. one could also consider dropping methods (but maybe that job is better suited to a module system)
11:03:53 <darrint> I just ran across this statement in "Clean Code": "We want the code to read like a top-down narrative." What would experienced haskell programmers say?
11:03:53 <Cale> and you couldn't replace those with other values without defining a new datatype
11:04:00 <Martty> > foldl ((. digitToInt).(+).(*2)) 0 $ "1010.1010"
11:04:01 <lambdabot>   *Exception: Char.digitToInt: not a digit '.'
11:04:16 <parcs> > foldl ((. digitToInt).(+).(*2)) 0 undefined
11:04:18 <lambdabot>   *Exception: Prelude.undefined
11:04:24 <parcs> oh noes haskell is broken
11:04:46 <Cale> darrint: sure, why not? That's one way to do it.
11:05:39 <ski> Cale : heh "unless the definition of any function arguments to the data constructors was the same as an existing one, you had to define a new type" -- that's exactly what i don't like in Java and related languages, and where O'Caml does better :)
11:06:15 <Cale> ski: Well, you have to define a new class in O'Caml. It might not have a new type in O'Caml's type system...
11:06:29 <Cale> So they've gone halfway.
11:07:28 <ski> darrint : sometimes it's nicer to define a mini-language (an EDSL) for expressing the problem domain (in the sense of SICP), and after that go on to use that to solve the problem
11:07:46 <Cale> But it's still a whole bunch of forced(?) boilerplate. Can you choose not to use classes at all, but still use objects and object types?
11:08:15 <darrint> When I write Java or Ruby code I find I try to create narrative. When I write Haskell code I go into another mode where I'm composing things. It's less narrative.
11:08:16 <ski> Cale : yes, sure (but you won't get any implementation inhertance, of course, which i assume you're fine with :)
11:08:21 <Cale> Right
11:08:34 <Cale> Good then.
11:09:19 <Cale> darrint: I don't see why composing things should be any less narrative...
11:09:42 <Cale> darrint: Isn't it talking about the order in which we place definitions?
11:09:49 <darrint> It might be that I'm just not good enough at it yet.
11:09:52 <Cale> (which the language doesn't care about but the reader does)
11:10:15 <Cale> You can put the top level of your program at the top of the file, and supporting definitions underneath
11:10:23 <Cale> Or you can sort the definitions the other way
11:10:27 <Cale> and the compiler won't care
11:10:58 <Cale> There's let and where within definitions as well
11:11:11 <Cale> (though they're not really syntactically equivalent)
11:11:20 <Cale> (they're semantically equivalent though)
11:11:48 <darrint> In imperative land, I tend to say, do this, then this. In FP land, I'm learning to say, A is_a B | C, b is_a something else, and don't get me started on C. Which is different, at least for me.
11:12:12 <identity_> darrint: oh, don't worry
11:12:26 <identity_> I felt like I was bear grylls in a foreign country drinking my own piss
11:12:32 <identity_> except I didn't enjoy it as much
11:12:44 <ski> Cale : e.g. `let counter = object  val count = 0  method tick = {< count = count + 1 >}  method get = count  end' works fine
11:12:54 <darrint> So I agree with Cale then, that is is narrative, just different.
11:14:42 <catface> i guess you put functions in pre-order traversal
11:16:02 <catface> unless it's more of a graph, then maybe breadth first
11:16:11 <cheater_> darrint, yes, impreative languages are constructive whereas functional languages are descriptive.
11:20:48 <dolio> Bundling data and behavior together object-style still seems bad to me.
11:21:07 <dolio> Doesn't matter if you're using predefined classes or not.
11:21:46 <dolio> At least, if you expect subtyping to work sensibly.
11:23:30 <dolio> A < B => List A < List B is sensible purely for the data structures, but when you insist on bundling things together like {List A, A -> List A -> Boolean}, you've made the package as a whole invariant.
11:23:46 <rs464> hi, I'm having an issue getting xmonad to work with Gnome. I can compile xmonad.hs just fine, but when I try via the command `xmonad --recompile', I receive this error: " Could not find module `XMonad.Config.Gnome' "
11:24:09 <donri> newbie question: is the map vs fmap distinction only there for historical reasons?
11:24:24 <rs464> I certainly have xmonad-contrib installed, and registered (visible with `ghc-pkg list')
11:24:46 <rs464> and I can import XMonad.Config.Gnome in ghci
11:24:47 <rs464> ?
11:25:02 <dolio> That's fine if the package is a package (like, a parameterized module), but not fine if the package is equated with the data structure.
11:25:02 <mauke> rs464: how many ghcs do you have?
11:25:36 <byorgey> donri: yes, and according to the argument that when just learning about lists and using map newbies would be confused/scared by errors about Functors
11:26:00 <donri> now they're confused about the distinction instead ;)
11:26:03 <donri> ok thanks
11:26:11 <dolio> Back in 1.4, fmap was named map.
11:26:13 <byorgey> I am sympathetic to this argument or not, depending on my mood and the day of the week
11:26:27 <rs464> mauke: only one
11:26:37 <byorgey> donri: well, they don't have to be confused about the distinction until they learn about fmap =)
11:27:06 <rs464> mauke: 7.0.2
11:29:29 <dylukes> btw
11:29:38 <dylukes> is the Type Generics thing used in Cloud Haskell for serialization?
11:33:03 <thoughtpolice> dylukes: what 'type generics' thing
11:33:06 <thoughtpolice> ?
11:33:08 <hiptobecubic> Cale, cabal install is _nice_ :)
11:33:33 <dylukes> Generic Haskell
11:33:37 <dylukes> http://en.wikipedia.org/wiki/Generic_programming#Generic_Haskell
11:34:08 <thoughtpolice> oh, then no. cloud haskell uses a template haskell hack to convert/serialize things to be put on the wire (including functions,) if I remember correctly. it doesn't use any of the generics stuff
11:34:17 <thoughtpolice> (which as of 7.2 doesn't even exist anymore, as it was replaced)
11:34:41 <dylukes> i.e
11:34:41 <dylukes> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/generic-classes.html
11:34:42 <dylukes> yeah
11:34:43 <dylukes> er,
11:34:47 <dylukes> i meant the 7.2 stuff, I forget tho
11:34:56 <dylukes> http://www.haskell.org/haskellwiki/Generics
11:34:57 <dylukes> here we g
11:34:58 <thoughtpolice> actually i don't think *anybody* ever used the old -XGenerics stuff. I think dons said they used it in galois for some stuff, but that's literally the only use case i've heard of, ever
11:34:59 <dylukes> go*
11:35:03 <thoughtpolice> dylukes: no
11:35:03 <dylukes> This is the one I meant
11:35:03 <dylukes> http://www.haskell.org/haskellwiki/Generics
11:35:05 <thoughtpolice> it doesn't
11:35:05 <cheater_> *go
11:35:29 <thoughtpolice> https://github.com/jepst/CloudHaskell
11:35:47 <thoughtpolice> according to the cabal file it was actually tested with 6.12.1, so if you're talking about the newer generics stuff, then it surely does not :)
11:36:17 <dylukes> heh
11:38:33 <jonkri> i want to use Data.Dynamic types as keys in a Map (like, mapping from the dynamic type to a function using a value of the dynamic type), but i can't figure out how the type is represented. is it the Typeable TypeRep type? if so, how can i find out how to use the type constructor?
11:40:08 <mauke> jonkri: what type constructor?
11:40:49 <jonkri> mauke, i was thinking the one for TypeRep, but i really don't have any idea of what i'm talking out :P
11:41:14 <mauke> the type constructor of TypeRep is TypeRep
11:42:03 <roconnor> using Data.Dynamic is a little sinful
11:42:06 <jonkri> mauke, i don't quite understand this part of the doc: Constructors: TypeRep !Fingerprint TyCon [TypeRep]
11:42:24 <mauke> oh, is that public now?
11:42:34 <mauke> no, it isn't
11:42:45 <mauke> where did you get that from?
11:43:10 <byorgey> jonkri: TypeRep does not have an Ord instance so you cannot use it as the key in a Map
11:43:34 <mauke> TypeRep will gain an Ord instance IIRC
11:43:38 <jonkri> mauke: i think i clicked myself into Data.Dynamic.Internal
11:43:38 <byorgey> jonkri: the standard approach (used in, e.g., xmonad) is to use Strings as keys, and use the output of 'show' on the TypeRep
11:43:43 <mauke> in the meantime you can define one yourself using unsafePerformIO
11:44:14 <byorgey> mauke: what do you have in mind?
11:44:16 <jonkri> mauke, http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable-Internal.html#t:TypeRep
11:44:39 <mauke> jonkri: oh, nice
11:44:54 <jonkri> i was trying to understand dynTypeRep
11:45:02 <byorgey> oh, it has an Ord instance now, but that is only for ghc 7.2
11:45:13 <mauke> byorgey: instance Ord TypeRep where compare = comparing (unsafePerformIO . typeRepKey)
11:45:22 <byorgey> mauke: ah, I see
11:45:31 <byorgey> jonkri: what version of ghc do you have?
11:45:31 <jonkri> roconnor, why do you say it's a little sinful?
11:45:46 <jonkri> byorgey, 7.0.2
11:46:01 <byorgey> jonkri: ok, then you ought to look at the corresponding documentation
11:46:11 <byorgey> jonkri: that link you gave has 'latest' in the URL which means it will be for 7.2.1
11:46:18 <byorgey> just change 'latest' to '7.0.2'
11:46:41 <jonkri> ah :)
11:47:11 <roconnor> jonkri: we are supposed to use the type system to help us enforce invarients, not give the type system concrete shoes and toss it off a pier.
11:48:21 <jonkri> roconnor, mm, yeah. the reason i want this is to make it possible to have extendible events that applications using my library can raise, and hook itself to
11:48:58 <roconnor> jonkri: sounds like a job for existential types.
11:49:01 <jonkri> not sure it's a good approach still though... maybe it would be a better idea to keep the events static and force developers to modify my library instead
11:49:21 <roconnor> jonkri: or higher order functions
11:49:30 <jonkri> no, that can't be good either... (my suggestion)
11:49:33 <rs464> juhp: I'm having problems with your xmonad Fedora rpm. I have done: `yum install xmonad xmonad-contrib'
11:49:59 <roconnor> higher order functions are great for hooks
11:50:02 <rs464> but when I come to ghci, I try:  import XMonad.Config.Gnome
11:50:02 <RenJuan> there's a #xmonad
11:50:10 <rs464> ah right, thanks
11:51:28 <jonkri> roconnor, i would have to use existential types (i'm guessing forall with Dynamic/Typeable) in order to have a DynamicEvent-like type, right?
11:51:41 <roconnor> nope
11:51:45 <jonkri> roconnor, could you elaborate a little bit on how to use higher order functions to implement hooks?
11:51:55 <tafryn> Saizan: Belated thanks.
11:52:21 <roconnor> you'd use existential types to with a typeclass defining your interface that clients need to implement.
11:52:22 * jonkri is trying to write an architectural description document thingy for his open source xmpp library, and is feeling a little lost
11:53:17 <roconnor> and since typeclass constraints are commonly implemented as a dictionary of functions being passed around, you could simply pass around a dictionary of functions.  This is the higher order approach.
11:53:30 <jonkri> the functions that the client is hooking into the library is right now stateful with some arbitrary client state (like State m a)
11:53:42 <joe6> anyone has good experiences with a haskell shell?
11:53:56 <roconnor> jonkri: you can use kleisli arrows of monads for higher order functions.  They are also great.
11:54:25 <roconnor> jonkri: but all this is probably easier said then done.  I don't want to harass you into anything you aren't ready to do.
11:54:41 <int80_h> @hoogle </>
11:54:42 <lambdabot> Text.Html (</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
11:54:42 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
11:54:42 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
11:55:33 <Saizan> roconnor: Typeable/Dynamic seems nice for when the different parts of a conceptually singular "hook" are far apart, like in Control.Exception, where you throw a custom exception here and catch it there
11:56:04 <hiptobecubic> cabal install alsa-mixer is failing due to dependencies. says it needs c2hs. cabal install c2hs says it needs language-c. cabal install language-c says it needs 'happy'. cabal install happy works fine. cabal install language-c says it still needs 'happy'. It's in the pay and happ<tab> autocompletes to 'happy'. what's missing?
11:56:06 <roconnor> Saizan: You could be right.  I've never used Control.Exception.
11:56:19 <jonkri> thank you roconnor :) i think that arrows approach would be a little overkill for where i am now, barely managing to use monads. i do need something though, and using Typeable/Dynamic doesn't really feel right for me either for the reasons you mentioned above
11:56:20 <hiptobecubic> it's in the path*
11:57:13 <jonkri> roconnor, that interface that you mentioned... would that be like a record with callback functions?
11:57:59 <jonkri> roconnor, what would be the keys in the dictionary?
12:03:59 <roconnor> jonkri: What are the keys in the dictionary now?
12:04:01 <hiptobecubic> You know? guys :)
12:04:40 <benmachine> hiptobecubic: hmm, what exactly does cabal instlal language-c say?
12:04:51 <benmachine> hiptobecubic: when did you last cabal update?
12:05:16 <hiptobecubic> Configuring language-c-0.3.2.1...cabal: The program happy is required but it could not be found.
12:05:20 <hiptobecubic> benmachine, minutes ago
12:05:30 <benmachine> hmm
12:05:42 <benmachine> you're not doing sudo cabal install or anything odd like that?
12:05:48 <hiptobecubic> nope
12:06:03 <benmachine> try with more verbosity
12:06:07 <benmachine> cabal install -v3
12:06:18 <hiptobecubic> ah
12:06:59 <jonkri> roconnor, i don't really have any. i'm trying to come up with an architecture that works with a list of use cases :) i have been having a record with functions like messageReceived :: Message -> State m a (), but i'm trying to make the event system more generic (use an Event type to encapsulate the events) and, as you know, extendible
12:07:10 <hiptobecubic> benmachine, says it can't find it in the path. http://vpaste.net/LuWbp
12:07:15 <hiptobecubic> but it's there!
12:07:38 <benmachine> hiptobecubic: did you try actually running it? does happy --version do something sensible?
12:07:59 <hiptobecubic> benmachine, version 1.18.6
12:08:11 <benmachine> ok
12:08:19 <jonkri> i'm thinking perhaps i could have events like "ConnectedEvent (Either ConnectionFailureReason Resource)", where Resource is they information needed in the client upon connection success
12:08:25 <roconnor> jonkri: well like I said, I don't really understand what you are doing, so I guess it is hard for me to be specific ... which makes me of little help to you.
12:08:51 <jonkri> right, of course. you've helped a lot though, so thanks :)
12:08:53 <hiptobecubic> why does it automatically resolve some dependencies and not others?
12:09:01 <benmachine> hiptobecubic: try working around the problem by using --with-happy=`which happy`
12:09:16 <benmachine> hiptobecubic: cabal only tracks libraries, so it can't resolve executable dependencies (build tools)
12:09:36 <hiptobecubic> benmachine, got it. my path was actually ~/.cabal/bin  not /home/$user/.cabal/bin, which apparently makes a difference here
12:10:03 <benmachine> hiptobecubic: oh, yeah. annoying
12:10:11 <hiptobecubic> indeed
12:10:15 <roconnor> jonkri: but roughly speaking in order to be "extensible" someone has to be making up new events and someone else needs to understand what those new events are; the middle man just needs to polymorphic and know enought to shuffle data around (i.e. type class constrains (MiddleManInfo a) => ...)
12:11:22 <roconnor> jonkri: On the other hand, ST is extensible and I don't know how to implement that without resorting to something like Dynamic.
12:12:33 <roconnor> (it is extensible in that newSTRef works for any type)
12:12:51 <jonkri> aha
12:13:09 * roconnor really really wants to see a Haskell implementation of ST
12:13:15 <jonkri> i have never used ST before
12:13:25 <roconnor> it is a little magical
12:14:20 <shachaf> preflex: seen byorgey
12:14:20 <preflex>  byorgey was last seen on #haskell 28 minutes and 3 seconds ago, saying: just change 'latest' to '7.0.2'
12:14:28 <byorgey> hi shachaf
12:14:32 <Saizan> roconnor: i'm working on an agda one by postulating a free theorem
12:14:34 <byorgey> were you looking for me?
12:14:42 <jonkri> i guess the only thing that my library needs to know about this new event is the type of it, with an Ord implementation, so that it can store the hook in a place where it can look it up again later
12:14:45 <shachaf> Was I?
12:14:51 <jonkri> which leads us back to square one :)
12:14:56 <amalloy> curious onlooker from another language here. i'm aware of zip, for turning [1, 2] [a, b] into [(1, a), (2, b)]; does haskell have a simple way to turn N lists into a list of N tuples?
12:15:14 <byorgey> shachaf: well, you asked if preflex had seen me yesterday
12:15:21 <identity_> amalloy:
12:15:21 <amalloy> er. into a list of tuples of size N
12:15:23 <identity_> @hoogle zip
12:15:23 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
12:15:23 <lambdabot> Data.ByteString zip :: ByteString -> ByteString -> [(Word8, Word8)]
12:15:24 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
12:15:26 <identity_> eh
12:15:31 <mauke> amalloy: no, but we can transpose
12:15:32 <identity_> well, there are different zips
12:15:37 <identity_> each for 1, 2, 3, 4, 5.. lists
12:15:39 <rwbarton> @type zip5
12:15:40 <lambdabot> forall a b c d e. [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
12:15:42 <identity_> up to some arbitrary n
12:15:46 <amalloy> yikes. i see
12:15:55 <shachaf> byorgey: Oh, I think I said something along the lines of "maybe Typeclassopedia should be put in its own web page, since people keep linking to a TMR issue containing several other articles".
12:16:10 <rwbarton> you can also make it out of (,,,,) and ZipList
12:16:11 <identity_> there is no easy way to index tuples and so on, or create 'dynamically sized tuples
12:16:14 <byorgey> shachaf: oh, I agree
12:16:17 <d-day> shachaf: yeah, I would like to reprint it soon
12:16:18 <identity_> '
12:16:24 <byorgey> shachaf: actually I think someone made a standalone pdf of it
12:16:41 <d-day> I did, but for my own uses. I can publish it somewhere with your permission
12:16:42 <identity_> amalloy: you could just transform N lists into a list of N sized lists
12:16:44 <shachaf> Hmm, it's not mentioned on the wiki.
12:16:56 <amalloy> identity_: but then they all have to be of the same type, yeah?
12:16:57 <d-day> byorgey: permission to upload standalone PDF?
12:17:04 <identity_> amalloy: yes
12:17:14 <shachaf> Also, HTML pages are nicer to link to than PDFs. :-)
12:17:15 <identity_> unless you create some data type to handle what you need to do
12:17:16 <byorgey> d-day: permission granted. stand by for further instructions.
12:17:21 <byorgey> ;)
12:17:23 <identity_> but someone else, better than me, probably has better hints
12:17:49 <byorgey> anyway, in theory I am working on a second edition
12:17:52 <d-day> i even have a 'byorgey' tag and directory in my library
12:18:13 <roconnor> Saizan: postulating a free theorem isn't so bad.
12:18:14 <d-day> byorgey: it seemed like a lot of 'co-' things ought to be there
12:18:23 <d-day> but I would guess diagrams would be useful in putting the picture together
12:19:13 <Eduard_Munteanu> I also wondered if it might be a good idea to wikify it.
12:19:30 <roconnor> @type runST
12:19:31 <lambdabot> forall a. (forall s. ST s a) -> a
12:20:42 <Eduard_Munteanu> But if you're working on a 2nd edition you probably don't want that at the moment.
12:21:28 <byorgey> working on wikifying the first edition wouldn't be that helpful at the moment, no.
12:21:46 <byorgey> I hope to publish the second edition in several formats, one of which will be comment-able HTML
12:25:17 <int80_h> ghci gives me a "*** Exception: Prelude.read: no parse" when I try to minimum $ map (read . last) fileNames' :: [Int]. But when I bind the expression "map (read . last) ..." (to foo, in this example) and then do "minimum foo" it works just fine. Why is that?
12:25:54 <shachaf> int80_h: Are you using ::[Int] either way?
12:26:01 <shachaf> What's the type of foo?
12:26:19 <int80_h> shachaf: yeah I put :: [Int] at the end in either case
12:26:22 <t4nk197> hi, I need to define a matrix with a defined length
12:26:26 <mauke> int80_h: end of what?
12:26:41 <int80_h> mauke: the end of the expression
12:26:47 <mauke> int80_h: which expression?
12:26:47 <d-day> shachaf: what page on the wiki do you want the typeclassopedia linked to?
12:26:52 <d-day> s/to/from/
12:27:00 <shachaf> @where typeclassopedia
12:27:00 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
12:27:02 <mauke> int80_h: you have three expressions
12:27:05 <shachaf> That one wouldbe good. :-)
12:27:07 <int80_h> shachaf: the type is foo :: [Int]
12:27:13 <byorgey> > minimum $ [1,2,3] :: [Int]
12:27:14 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
12:27:14 <lambdabot>    arising from the literal `...
12:27:19 <Eduard_Munteanu> > [] $ 3 :: Int
12:27:20 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
12:27:21 <mauke> int80_h: should be [[Int]]
12:27:21 <byorgey> :: scopes over the entire thing
12:27:29 <Eduard_Munteanu> > [] $ (3 :: Int)
12:27:30 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
12:27:54 <byorgey> i.e. minimum $ blah :: foo  parses as  (minimum $ blah) :: foo
12:27:56 <int80_h> mauke: it works when I bind verythign but "minimum" to foo and then do " minimum foo"
12:28:12 <shachaf> int80_h: Add parentheses or drop brackets.
12:28:14 <mauke> int80_h: your two versions are very different
12:28:23 <t4nk197> who speak spanish?
12:28:29 <mauke> int80_h: the first one has foo :: [[Int]], the second one has foo :: [Int]
12:28:50 <Eduard_Munteanu> Bah.
12:29:09 <int80_h> mauke: I just did this "let foo = minimum $ map (read . last) fileNames' :: [[Int]]" and got the exact same error.
12:29:15 <mauke> int80_h: see?
12:29:33 <shachaf> int80_h: Try :: INt
12:29:41 <mauke> int80_h: actually, now your foo has type [[[Int]]]
12:29:43 <shachaf> Because that's the type you actually want.
12:29:45 <int80_h> whereas if I do "let foo =  map (read . last)
12:29:50 <int80_h> oops
12:29:52 <Eduard_Munteanu> Anyway, the idea is :: goes over the whole expression, it doesn't stop at '$'
12:29:55 <mauke> int80_h: stop using the name 'foo' for everything!
12:30:03 <mauke> makes it impossible to refer to things
12:30:07 <int80_h> sorry
12:30:27 <int80_h> if [[Int]] is what I want, why do I get the exact same error when I use it?
12:30:27 <mauke> the problem is minimum :: [a] -> a
12:30:35 <shachaf> @ty let foo foo = foo in foo foo foo
12:30:36 <lambdabot> forall t. t -> t
12:30:40 <mauke> int80_h: no, [[Int]] is what your code does and causes the error
12:30:41 <int80_h> mauke: ah
12:30:57 <int80_h> gotcha
12:30:58 <mauke> int80_h: you annotated the result of minimum as [Int], so a = [Int]
12:31:05 <shachaf> int80_h: [[Int]] isn't what you want; mauke is trying to explain a general Haskell thing to you rather than answer this specific question. :-)
12:31:06 <mauke> so the initial list was [[Int]]
12:31:23 <mauke> > read "42" :: [Int]
12:31:24 <lambdabot>   *Exception: Prelude.read: no parse
12:31:37 <mauke> and that's what happened
12:31:39 <int80_h> shachaf : general Haskell thing is fine. My code does what I want, I was just wondering why I have to break it up the way I do.
12:31:50 <mauke> int80_h: just annotate it right
12:32:12 <shachaf> int80_h: What's the type of "minimum $ map (read . last) fileNames'"?
12:32:14 <t4nk197> who speaks Spanish?
12:33:06 <Eduard_Munteanu> Was there a #haskell-es, or I'm misremembering?
12:33:09 <d-day> shachaf: http://www.haskell.org/haskellwiki/Typeclassopedia
12:33:22 <Eduard_Munteanu> Hrm, seems not.
12:33:23 <int80_h> shachaf: minimum $ map (read . last) fileNames' :: (Read a, Ord a) => a
12:33:23 <d-day> shachaf: byorgey: verify workingitude
12:33:30 <mauke> 2 people in #haskell.es
12:33:46 <Eduard_Munteanu> Ah, 'dot'
12:33:48 <d-day> works for me
12:33:56 <shachaf> d-day++
12:33:59 <mauke> int80_h: that's what the compiler says, but what type do you want it to be? :-)
12:34:24 <Eduard_Munteanu> t4nk197: if you speak English, you might be able to get more help in here.
12:34:28 <int80_h> mauke: I want it to be Int
12:34:31 <int80_h> ah!
12:34:36 <shachaf> byorgey: You cook tasty lambda-treats for us?!
12:34:53 <hiptobecubic> how does one build something with options using cabal?
12:35:00 <int80_h> I get it
12:35:26 <byorgey> shachaf: I don't do it as often now as I used to
12:35:28 <Polarina> I got some monadic action `m a` and would like to repeat it and collect its value `a` into a list `[a]` until a predicate `a -> Bool` is matched, then get that list. What would be the best way to do that?
12:35:57 <shachaf> @ty takeWhileM
12:35:58 <lambdabot> Not in scope: `takeWhileM'
12:36:04 * byorgey whips up a lambda-meringue pie just for shachaf 
12:36:07 <shachaf> Polarina: I don't think there's a library function for doing that exactly.
12:36:21 <hiptobecubic> normally it would be `runhaskell configure --flags="with_alsa"`
12:36:47 <d-day> hehe, if monads are like burritos then lambda-meringue pie might not be the most appetizing thing around
12:36:52 * byorgey configures some tortilla chips using --flags="with_salsa"
12:37:04 <dylukes> Cale: My friend Joe jut asked for a polyhedra to try to make (out of origami). Whats the most ridiculous one you can think off?
12:37:07 <Polarina> shachaf: It can also be a `(a -> a -> a)` done in order and give me the final `a`.
12:37:13 <byorgey> d-day: I didn't put any monads in the pie
12:37:24 <shachaf> @ty until
12:37:25 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
12:37:31 <shachaf> That doesn't give you a list, though.
12:37:52 <Cale> dylukes: Rhombicosidodecahedron
12:38:03 <hiptobecubic> nevermind, the xmobar wiki had it. :)
12:38:05 <dylukes> I think he's done that one.
12:38:13 <dylukes> Tetrahemihexahedron looks harder.
12:38:42 <Cale> Well, I guess it's not ridiculous. I just like it in particular.
12:38:44 <Eduard_Munteanu> Evidently, polytopes are the most ridiculous to make from paper, or make at all.
12:39:42 <Eduard_Munteanu> (not polyhedras though)
12:40:58 <dylukes> Cale: any ideas for one that would be neat to make from paper?
12:40:59 <dylukes> but hard.
12:41:19 <ski> (dylukes : singular "polyhedron", plural "polyhedra")
12:41:25 <dylukes> mm my bad.
12:41:42 <shachaf> ski++
12:41:48 * shachaf was trying not to say it.
12:42:02 <Cale> dylukes: All the symmetric things pretty much follow the basic plan of the the Platonic solids, so if you can make Platonic solids, and you can make "face" parts which have appropriate number of rotational symmetries, then you're set.
12:42:17 <dylukes> I told him to make this.
12:42:18 <dylukes> http://en.wikipedia.org/wiki/File:Stereographic_polytope_120cell.png
12:42:42 <dylukes> he's going to make a stellated rhombicosidodecahedron he says.
12:44:11 <ocharles> Is there any recommended way of building up Network.URI.URI values? the api seems fairly horrible to use...
12:44:56 <ocharles> I have a list of path parts, and just want to combine them into a relative URI and then make a URI relative to my end point
12:45:07 <ocharles> right now it's covered in a load of "fromJust" stuff
12:45:33 <ocharles> I'm sure you could use applicative to get it a bit nicer... but I'm still not sure
12:46:35 <ocharles> it's also annoying that you have to remember to append "/" onto path parts
12:53:28 <illissius_> is there any way to do a hoogle/hayoo search for all the packages which define some version of the 'data Eq a b where Eq :: Eq a a' GADT? failing that, can anyone list (some of) them from memory? :)
12:55:18 <Eduard_Munteanu> I wonder how useful that is in Haskell, given there are no dependent types.
12:56:29 <hajhouse> does anyone have an example of a custom SQL-to-Haskell datatype conversion using HDBC? HDBC provides numeric (fixed-precision decimal) as SQLRational, whichi is really not the same thing at all. I'd like to convert SQL numeric data to an appropriate Haskell fixed-precision type.
13:05:41 <jonkri> is there some way to get like a pointer or identifier to a function, in case you want a reference?
13:06:13 <shachaf> jonkri: What do you mean?
13:06:50 <rwbarton> what would you do with this "reference"?
13:06:56 <rwbarton> (the answer is probably no)
13:07:22 <shachaf> Alternatively, the answer might be yes. :-)
13:07:47 <illissius_> the answer is probably one of "the function itself", "StablePtr", or "no"
13:08:19 <shachaf> The answer might be unsafeCoerce!
13:09:03 <rwbarton> like I said, "no" :)
13:09:14 <jonkri> i assumed it wasn't possible :) i'm storing callback functions in a list and i thought about if there is someway to store a reference one of those functions so that it can be removed from the list later
13:09:35 <shachaf> jonkri: Why not just store the function?
13:09:45 <rwbarton> you could store its index in the list
13:09:49 <leod> because he needs some sort of equality for removing
13:09:57 <Eduard_Munteanu> The function itself is already a pointer to a thunk
13:09:57 <illissius_> um. well if it's a mutable list/array, you could store the index. or you could store a tuple of the function and an identifier.
13:09:58 <shachaf> Oh, I see.
13:10:12 <Eduard_Munteanu> Ah.
13:10:45 <illissius_> (in the first case in the place where you want to keep the reference, in the second case in the list itself and then use the identifier as the reference, sorry for the ambiguity.)
13:11:45 <erus`> is there any natural language processing/understanding stuff in haskell?
13:12:37 <jonkri> thanks
13:14:09 <dylukes> erus`: I think there's a wordnet binding.
13:14:39 <erus`> does it just create a word graph or whatever?
13:15:03 <erus`> im lloking for a system that i give some context or environment and then it can parse natural language commands... :)
13:15:14 <erus`> im not sure if that is possible yet
13:15:32 <c_wraith> No one's invented AI yet, no. :)
13:16:15 <c_wraith> I'm not sure what the state of NLP packages is for haskell.  It might be possible to get some limited support for a feature like that, if there are decent libs out there
13:16:27 <parcs> what is the name of that package that was based off of happstack-state?
13:16:32 <jonkri> what would be a good identifier for functions/hooks? string? int? uuid?
13:16:37 <jonkri> parcs, acid-state i think
13:16:50 <parcs> that's it
13:16:52 <parcs> thanks
13:16:59 <jonkri> np :)
13:17:14 <Saizan> ?google grammatical framework
13:17:16 <lambdabot> http://grammaticalframework.org/
13:17:16 <lambdabot> Title: GF - Grammatical Framework
13:17:33 <rwbarton> jonkri: you could make it a type parameter, with an Eq or Ord constraint
13:18:04 <ricree> Are snap and yesod still considered the main web frameworks?
13:18:24 <parcs> and happstack
13:18:42 <parcs> yeah, they're like the only web frameworks
13:19:15 <jonkri> rwbarton, hmm... how would that work? i know what Eq, Ord, and type parameter is, but i don't know what type you are referring to
13:19:31 <mizu_no_oto> The Three Instruction Machine was created by John Fairbairn and S. C. Wray.  Does anyone know if that's a different John Fairbairn from the one who writes software and books about Go and Shogi?
13:19:35 <rwbarton> well I don't know enugh about what you are doing to say precisely
13:19:52 <rwbarton> what is the type of your function to add a callback?
13:19:52 <mizu_no_oto> Or is Fairbairn a common British name?
13:22:02 <dolio> There's a Jon Fairbairn involved with Haskell.
13:22:39 <mizu_no_oto> So probably a different guy, then?  Do you know, tromp?
13:22:43 <jonkri> rwbarton, i will have a list of like ([Maybe x, (Event -> State...)]) so that i can look up the function based on x, an Eq/Ord instance, if needed
13:23:06 <jonkri> so i was just curious what people generally used for x :)
13:23:22 <tromp> the go guy is called Jon, not John
13:23:44 <rwbarton> just leave it free
13:23:57 <tromp> oops, thta's not right
13:24:06 <rwbarton> type CallbackList x = [Maybe x, (Event->State, ...)]
13:24:31 <rwbarton> though you probably want a newtype or data
13:24:35 <mizu_no_oto> http://senseis.xmp.net/?JohnFairbairn
13:24:42 <ski> (why `Maybe' ?)
13:24:44 <tromp> i got confused with another british Go played called Jon, but thast's Jon Diamond
13:25:33 <jonkri> ski, because i want the id/name of the callback to be optional
13:26:19 <jonkri> this is something that i thought clients could specify to be able to remove the hooks later
13:26:26 <ski> so how will you remove it from the list, if it has no identifier ?
13:26:52 <jonkri> i will also allow the hooks to unregister themselves without the need for a name in their return value, but that's a separate issue :P
13:27:25 <jonkri> like, the hooks can return a list of HookAction or whatever :P
13:28:24 <jonkri> ah, no, the insertion of a hook should probably return a unique id instead, and then clients can choose to store it or not
13:29:20 <ski> will a hook be active until it's removed ?
13:29:47 <jonkri> hmm... why wouldn't it? :)
13:30:06 <ski> i dunno what your hooks does
13:30:29 <ski> i wondered whether you'd want to use weak references or not
13:30:41 <jonkri> what's a weak reference?
13:30:57 <pantski> l20
13:31:33 <ski> a bit like an `IORef', but if there's no references to a value unless through the weak reference, it will be GCed
13:31:56 <ski> s/the/a/
13:33:12 <ski> @type System.Mem.Weak.deRefWeak
13:33:13 <lambdabot> forall v. GHC.Weak.Weak v -> IO (Maybe v)
13:33:17 <ski> @type System.Mem.Weak.mkWeak
13:33:17 <lambdabot> forall k v. k -> v -> Maybe (IO ()) -> IO (GHC.Weak.Weak v)
13:33:19 <ski> @type System.Mem.Weak.mkWeakPtr
13:33:19 <lambdabot> forall k. k -> Maybe (IO ()) -> IO (GHC.Weak.Weak k)
13:33:41 <rostayob> oh that's interesting. So basically it's pretty similar to a java weak reference right?
13:35:22 <c_wraith> I wonder if it's closer to java's weak or soft references.
13:35:24 <jonkri> that's cool
13:35:46 <c_wraith> It's great fun to ask java coders what the difference between weak, soft, and phantom references is.
13:35:46 <jonkri> thanks for the info ski, but i think there will be quite few hooks and that i'm in over my head already as it is :)
13:36:07 <c_wraith> Hmm.  I'm interviewing a java coder this afternoon. I could torture him! :)
13:36:13 <jonkri> haha
13:36:13 <rostayob> c_wraith: soft references are not reclaimed unless we run out of memory afaik
13:36:19 <rostayob> so they're more similar to weak references
13:36:31 <c_wraith> That is, in fact, the difference.
13:36:36 <rostayob> e.g. java caches are often implemented with soft references, not weak ones
13:36:38 <c_wraith> Now...  phantom references? :)
13:36:48 <rostayob> c_wraith: no idea about those eheh
13:37:01 <c_wraith> phantom references don't give you any way to get the object back
13:37:22 <copumpkin> sounds useful
13:37:29 <c_wraith> they're useful only because the GC will add phantom references to an object to a reference queue when the object is collected.
13:37:38 <c_wraith> So you can perform post-gc cleanup of other resources
13:37:40 <copumpkin> can you even create them from user code?
13:37:43 <c_wraith> yes
13:39:31 <rostayob> c_wraith: why would you do that?
13:40:05 <rostayob> (create them in your code)
13:40:06 <c_wraith> freeing non-memory resources, generally.  It's a replacement mechanism for finalizers, with less ugly semantics.
13:41:00 <c_wraith> specifically, if you use phantom references to clean up non-memory resources, you can't accidentally put objects into the strange "previously unreachable but now reachable" state that you can with finalizers.
13:41:14 <c_wraith> because you can't actually recover the object in question
13:41:44 <rostayob> c_wraith: I agree that finalizers are bad, and those references seem like an alternative way to do similar things but what do you do with them in haskell?
13:42:13 <rostayob> or is it java only?
13:42:35 <c_wraith> they're just in java, so far as I know.
13:42:41 <rostayob> oh ok
13:46:02 <roconnor> ``It has recently become fashionable to refer to these languages as HOT ("higher-order, typed").  By extension we can speak of a HOT programming style--a style in which (1) the use of higher-order functions and anonymous abstractions is encouraged; (2) polymorphic definitions are used freely and at a fairly fine grain; and (3) "pure" data structures are used instead of mutable state, whenever possible.''
13:47:11 <rostayob> roconnor: I remember a tshirt with HOT and some fire
13:47:12 <c_wraith> where's this a quote from?
13:47:14 <rostayob> pretty ugly actually
13:47:35 <roconnor> c_wraith: Local Type Inference by B. Pierce and D. Turner
13:47:55 <roconnor> I totally want to resume refering to this style as HOT
13:48:03 <RenJuan> how was the t-shirt connected to the current topic?
13:48:07 <c_wraith> I'm a HOT programmer.
13:48:08 <c_wraith> yeah
13:48:10 <roconnor> since the other camp uses words like Dynamic
13:48:18 <rostayob> RenJuan: because it said "higher order and typed"
13:48:37 <RenJuan> i c
13:48:59 <rostayob> this http://www.cafepress.co.uk/highordertyped
13:49:06 <RenJuan> with H, O, and ...
13:49:07 <roconnor> HOTT -- Higher-order, typed, and total :D
13:49:11 <rostayob> it's so ugly it's cool
13:49:30 <matthiasgorgens> dynamic is fine with me.  as long as it's in dynamic programming.
13:50:31 <RenJuan> as in Richard Bellman?
13:50:36 <rostayob> http://www.cafepress.com/MonadPure.13479523 mhm....
13:50:56 <roconnor> matthiasgorgens: the worst thing about the term dynamic programming is that the word "dynamic" was used because it sounds impressive.
13:51:27 <rostayob> roconnor: yeah I never understood the dynamic in DP
13:51:29 <RenJuan> Bellman characterized it as a new formalism in the calculus of variations
13:51:44 <roconnor> rostayob: ya, it was a sales pitch to management.
13:51:49 <RenJuan> but mehbe you're talking about something else
13:52:06 <rostayob> I'm going to create BD
13:52:09 <rostayob> badass programming
13:54:20 <jonkri> how do haskell developers generally guarantee that sufficient debug information is logged in the case of a program error? (as in, the application contains a bug and crashes)
13:54:25 <donri> http://programming-motherfucker.com/ ?
13:54:35 <roconnor> jonkri: I don't :(
13:54:52 <rostayob> jonkri: 2> /dev/null
13:54:55 <roconnor> jonkri: mostly I try to avoid having program errors ;) but this is really a non-answer.
13:55:12 <RenJuan> i think haskellers think they don't need debugging
13:55:28 <benmachine> no, I definitely need debugging
13:55:28 * geheimdienst creates SP, srs programming, targeting all the suits who are off-put by the name of badass programming
13:55:38 <benmachine> less than other languages, but debugging nonetheless
13:55:43 <RenJuan> not sure if they think they need design
13:56:01 <ddarius> No one guarantees sufficient debug information is logged in the case of a program error.  There is no set amount of information that would be sufficient.
13:56:25 <RenJuan> but once correct written I think the magical type systems is supposed to make debugging declasse
13:56:31 <RenJuan> *correctly
13:56:36 <roconnor> I think if you use HAT you can rewind your program arbitrariliy in case of a crash. ... though no one uses HAT.
13:56:43 <jonkri> donri, :D
13:56:57 <ddarius> roconnor: That's because Hat wasn't maintained for a while and I'm pretty sure is still Haskell 98 only.
13:57:09 <jonkri> i'm a student at a software engineering and management, not too sure my teachers would appreciate that philosophy :)
13:57:38 <confab> donri, that's definitely a zed a shaw idea
13:57:40 <RenJuan> missing noun
13:57:52 <donri> obvious zedas is obvious
13:58:02 <rostayob> jonkri: anyway, if your haskell program crashes, you most likely hit "error" somewhere
13:58:13 <rostayob> so using error with meaningful messages helps I guess
13:58:32 <rostayob> if it cores dump or stuff like that there isn't much you can do
13:58:52 <rostayob> or stack overflows, or whatever
13:58:55 <jonkri> rostayob, lol @ 2> /dev/null... responsible :D
13:58:59 * RenJuan would be surprised if there's a haskell dump function
13:59:01 <rostayob> jonkri: :)
13:59:10 <kmc> jonkri, http://haskell.org/haskellwiki/FAQ#How_can_I_find_bugs_that_occur_at_runtime.3F
13:59:18 <kmc> jonkri, http://haskell.org/haskellwiki/FAQ#How_can_I_get_a_stack_backtrace_when_my_program_throws_an_exception.3F
13:59:26 <copumpkin> what's with the .3F?
13:59:30 <copumpkin> oh, is that a question mark?
13:59:41 <kmc> да
14:00:26 <ddarius> copumpkin: No it's a period, a three, and an F.
14:00:46 <confab> heh
14:01:00 <incluye> copumpkin: yes, it's a question mark
14:01:14 <donri> it's a mediawiki thing no?
14:01:36 <jonkri> thanks
14:02:00 <donri> whyever now it would diverge from the %FF standard
14:02:10 <geheimdienst> jonkri: the trace function from Debug.Trace can be used to log things. many bugs that would be discovered at runtime in (say) java are a compile-time error in haskell, so the question of logging and stack traces is moot in many cases. best practices ("avoid head" ...) can sidestep some more cases. beyond that: yeah, it's kind of a weak area in haskell, i guess
14:02:33 <mauke> donri: it's a fragment identifier
14:02:38 <geheimdienst> donri: it's in the "#" part of the url
14:02:44 <donri> ooh
14:02:58 <donri> i didn't know that mattered but makes (more) sense
14:04:12 <rostayob> jonkri: as geheimdienst said if you avoid using/writing non-total functions you should be pretty safe
14:04:19 <donri> is lyah and rwh still the go to books? birthday coming up (:
14:04:32 <rostayob> donri: I LOVE lyah
14:04:46 <donri> me too
14:04:52 <rostayob> so buy it ehe
14:05:29 <donri> dead trees ftw
14:07:07 <rostayob> we still need a book that covers advanced features, RWH kind of does but in a "tutorial" way, I'd like to have a manual
14:07:24 <kmc> i sometimes get annoyed by RWH's evangelical tone
14:07:58 <donri> rwh feels all like "i'm gonna go ahead and be all technical and make you feel stupid right up this bitch"
14:08:04 <copumpkin> lol
14:08:10 <rostayob> ahah no that's not true lol
14:09:04 <jonkri> i see Ö=
14:09:09 <thoughtpolice> kmc: now watch as haskell manifests a pony! it can do that! and a car! everybody gets a car! i haven't even gotten to world hunger yet
14:09:11 <jonkri> s/Ö=/:)
14:09:43 <kmc> "i realize this is hard but trust me Haskell is so cool noooooo don't leave me"
14:09:43 <donri> http://djangopony.com/
14:09:45 <kmc> every third paragraph
14:09:51 <dilinger> roconnor: i'd like a Learn You A Real World Haskell
14:09:55 <donri> haha
14:09:57 <donri> +1
14:10:22 <thoughtpolice> child, you will see the light, i promise.
14:10:25 <dilinger> (ie, a sequel to LYAH that delves into RWH-type stuff)
14:10:34 <donri> the thought police will make sure of it
14:10:46 <kmc> i kind of think the evangelism and teaching aspects should be separate
14:11:02 <kmc> like, get the student interested, and then teach them
14:11:06 <kmc> if they give up easily, fuck 'em
14:11:06 <donri> every goddamn book makes that mistake
14:11:19 <donri> if you love a language enough to write a book i guess it's to be expected
14:11:41 <kmc> i don't think Springer-Verlag Graduate Texts in Mathematics do that
14:12:05 <copumpkin> kmc: they do the opposite
14:12:13 <donri> they don't need to, the language of math is *universal* and has no competition!
14:12:17 <copumpkin> lol
14:12:30 <kmc> every page "no, I promise you, commutative banach algebras are really cool, don't give up! we believe in you!"
14:12:51 <kmc> http://math.arizona.edu/~savitt/GTM.html
14:13:14 <copumpkin> lol
14:13:33 <geheimdienst> i guess if you read that kinda stuff, you're beyond "what's it for" anyway
14:13:52 <thoughtpolice> lolol
14:13:55 <kmc> dilinger, i've been toying with the idea of writing a Haskell tutorial for a while now
14:13:57 <kmc> any other advice?
14:13:58 <thoughtpolice> i got "categories for the working mathematician"
14:14:03 <thoughtpolice> clearly i should tap my inner category theorist
14:14:26 <copumpkin> I'm just commutative algebra with a view toward algebraic geometry
14:14:29 <copumpkin> :(
14:14:36 <dilinger> kmc: yeah.  let me proofread it :)
14:15:03 <thoughtpolice> copumpkin: do you read the comics? or do the crosswords
14:15:11 <copumpkin> clearly chess column
14:15:13 <copumpkin> duh
14:15:19 <copumpkin> I actually do none of those
14:15:24 <donri> thoughtpolice: me too!
14:16:07 <dilinger> kmc: i _really_ like the way LYAH is written.  it's incredibly readable (imo).  its main failings are some of its corny jokes, and a bit of sexism; both very minor things.  RWH, on the other hand, i find pretty unreadable
14:17:07 <donri> rwh is like an autistic cryptically mumbling the stuff of genious
14:17:09 <thoughtpolice> copumpkin: clearly you should read more comics. trust me, i'm category theory, and i know you like that stuff.
14:17:12 <dilinger> kmc: i don't think RWH should be a basic tutorial as well as attempting to do real-world stuff.  it makes the early examples unnecessarily verbose
14:17:50 <donri> rwh needs syntax highlighting of the code examples *simple things*
14:18:05 <brisingr> dilinger: I prefer LYAH as well
14:18:39 <dankna> heh - I thought this was a different channel because my tabs are in the wrong order.  I was like, wait, we're discussing coalgebras in /here/, wtf? :)
14:18:43 <donri> and here i was thinking lyah was haters gonna hate in here
14:18:45 <dilinger> kmc: if RWH had started off saying, "read X before reading this book" (let X = intro book), that would've enabled it to cut out lots of unnecessary text and code
14:18:56 <donri> guess you people are a more relaxed bunch than my prejudice says
14:19:08 <copumpkin> thoughtpolice: oh!
14:19:53 <brisingr> I don't see the sexism in LYAH tho
14:20:01 <brisingr> not trying to start a flame war here
14:20:02 <dankna> imo it's not an author's job to provide a complete course of study or reference one
14:20:06 <brisingr> just curious
14:20:12 * copumpkin flames brisingr 
14:20:19 * copumpkin brings a big fan, too
14:20:21 <donri> not having looked, i haven't seen any sexism either
14:20:23 * thoughtpolice extinguishes copumpkin
14:20:23 <dankna> he can present the material he presents; he can't and shouldn't try to control what else you're exposed to
14:21:02 * brisingr : help its burning
14:21:36 <mm_freak> what's an efficient way to replace part of a vector by another equally long vector, i.e. the equivalent of memcpy?
14:21:48 <mm_freak> "vector" as in Data.Vector
14:22:25 <acowley> sexism? did someone mean to say they saw some sexy in LYAH?
14:22:42 <donri> the drawings are certainly sexy
14:22:44 <dilinger> brisingr: probably not worth discussing.  very minor.
14:22:56 <mm_freak> slicing and reconcatenation doesn't seem to be the operation of choice, unless rules take care of doing this without copying
14:23:01 <copumpkin> mm_freak: backpermute
14:23:03 <donri> dilinger: leaving us hanging
14:23:04 <copumpkin> but that will copy
14:23:09 <copumpkin> except with fusion
14:23:47 <mm_freak> copumpkin: how does that give me a memcpy equivalent?
14:23:50 <copumpkin> it won't
14:23:53 <copumpkin> :P
14:23:58 <mm_freak> lol thanks
14:24:06 <mm_freak> i'll go with 'modify'
14:24:13 <copumpkin> well, if you want an actual copy
14:24:16 <copumpkin> you want to do this in MVector
14:24:22 <copumpkin> and there's basicUnsafeCopy
14:24:26 <copumpkin> or basicUnsafeMove
14:24:30 <dilinger> donri: if you're curious, look at the phonebook example and see if you can spot oddities that aren't necessary and some people might find weird (i mean, weirder than the rest of the book :)
14:24:32 <copumpkin> they might eventually use the new ghc memcpy primops
14:24:35 <acowley> mm_freak: you can also do this with slices
14:24:45 <copumpkin> acowley: only repa got slices, I thought?
14:24:50 <mm_freak> acowley: the reconcatenation may copy
14:25:07 <acowley> yes it will probably copy
14:25:11 <mm_freak> copumpkin: vectors got slicing, too
14:25:23 <mm_freak> 'modify' will probably copy, too, but i hope it won't
14:25:25 <acowley> but you're asking for a lot to avoid copying
14:25:26 <copumpkin> I meant the sliced representation that repa uses
14:25:35 <copumpkin> mm_freak: it's a persistent structure, it has to copy
14:25:42 <copumpkin> if you had linear types, it could avoid it
14:25:49 * ddarius douses thoughtpolice in chlorine triflouride.
14:25:57 <copumpkin> mm_freak: why not just use MVector?
14:26:01 <mm_freak> copumpkin: the documentation says that 'modify' doesn't copy, if that's safe…  i won't use the old vector anymore, so it should be safe
14:26:03 <acowley> I would use slices and hope that it boils down to an allocation and three memcpy's
14:26:11 <kate_r> is it logically valid to have 2 logical theories A and B that are extensions of each other? would that make both A and B essentially the same theory (same signature, same set of theorems)?
14:26:12 <copumpkin> mm_freak: it doesn't know that you don't
14:26:22 <mm_freak> copumpkin: because i believe the pure variant may be faster than MVector even when copying
14:26:22 <copumpkin> oh I see
14:26:28 <copumpkin> modify is the mutable thing
14:26:50 <donri> dilinger: i see what you mean by "minor" ;)
14:26:55 <copumpkin>  The operation will be performed in place if it is safe to do so and will modify a copy of the vector otherwise.
14:26:59 <copumpkin> how does that work?
14:27:11 <copumpkin> it must consider it only safe to do if the vector was never materialized to begin with?
14:27:22 <copumpkin> modify p = new . New.modify p . clone
14:27:33 <mm_freak> copumpkin: probably it has a dialog with the garbage collector
14:27:40 <copumpkin> nope
14:27:40 <mm_freak> if the old vector is never used again, it's safe
14:27:53 <copumpkin> I don't think anything can do that
14:27:54 <acowley> I would expect the clone to go away via rewrite rules
14:28:01 <copumpkin> acowley: yeah, it might
14:28:20 <mm_freak> something like that…  anyway, i'll try a few things
14:28:21 <copumpkin> but it's not going to modify it in place if he's already got a nice materialized vector already
14:28:24 <ddarius> Checking the entire heap for references would be far slower than just copying.
14:28:26 <acowley> copumpkin: it's what my OpenCV library does
14:28:28 <dilinger> donri: there was another spot or two in the book where i noticed things like that.  minor stuff, still a good book, but.. i would've left it out.
14:28:43 <acowley> it's just a syntactic collapse on nested applications
14:28:50 <copumpkin> yeah
14:28:56 <copumpkin> there's a rule for new (clone p) = p
14:29:01 <donri> dilinger: you did mean the fact there's only females in the list? or did you mean something else i missed
14:29:08 <copumpkin> and then a chain of news can get their ST actions concatenated
14:29:15 <mm_freak> copumpkin: i see what you mean…  it may build a materialized vector from a stream, thereby getting along without copying
14:29:20 <copumpkin> yeah
14:29:23 <dilinger> donri: well, combined with the bikini..
14:29:27 <copumpkin> but it's never going to emit an actual memcpy that you want
14:29:28 <mm_freak> that's probably what it does, perhaps with some additional rewrite rules
14:29:29 <donri> i've also noticed in general in programming documentation the male pronoun is often used in reference to programmers
14:30:02 <donri> wait, bikini?
14:30:15 <acowley> if you want memcpy, use slices
14:30:34 <mm_freak> yeah, that was my first intuition…  i'll go with that
14:30:37 <copumpkin> or just the copy functions on mutable vars
14:30:38 <mm_freak> i don't like MVector a lot anyway
14:31:01 <mm_freak> it's amazing to see Vector performing better than MVector for essentially the same algorithm
14:32:49 <acowley> MVector is nice until you realize you've got a bug because you've been coding in Verbose-C
14:33:11 <kmc> why does Vector perform better in those cases mm_freak?
14:33:32 <thoughtpolice> Verbose-C: less *, more 'unsafe' directly in function names
14:33:46 <jonkri> the state of my application is one huge State record. i'm thinking about making my state loop functions as pure as possible. what do you think of this: having a function like "State -> Event -> (State, [IOAction])" which is a pure function to update the current state given an event, and return a list of (impure) IO actions that can be performed elsewhere. i'm thinking that this allows me to write like quickcheck properties and stuff for the function
14:34:05 <acowley> thoughtpolice: we should use a CPP macro so we can write * in place of 'unsafe'
14:34:10 <jonkri> what do you think of this?
14:34:19 <mm_freak> kmc: fusion may produce tighter algorithms than monadic code
14:34:36 <joefons> i'm trying to find someone that knows ASP.NET and VB & MS SQL SERVER that can help me either learn or help with an app.  It's an intranet app.
14:35:00 <mm_freak> jonkri: that really sounds like you ask for functional reactive programming
14:35:23 <mm_freak> in FRP state is somewhat implicit and changing states is done by switching
14:35:41 <thoughtpolice> acowley: clearly the verbosity would discourage people from using those unsafe features. at least we can only hope; then again, people actually seem to write Java and even be *okay* with it!
14:35:44 <joefons> its that to me ?
14:35:53 <glguy> joefons: you might be in the wrong channel. This is about the Haskell programming language.
14:36:29 <joefons> k ty
14:37:32 <acowley> thoughtpolice: syntactic salt is a friendly shove towards the FFI
14:37:40 <mm_freak> jonkri: also in FRP state is naturally distributed and disconnected…  you don't have large state records anymore, but really handle only the individual substates…  the full application state is represented by the current state of your signal network
14:38:30 <acowley> people who do numerical analysis of algorithms are nuts
14:40:30 <jonkri> mm_freak, that sounds great. i've been interesting in frp for a while, and this only makes it even more interesting :)
14:41:01 <jonkri> i don't think i have the time to dive into it for this project though :(
14:41:22 <acowley> copumpkin: I couldn't type check djahandarie's fancy ClampEven monad
14:41:35 <copumpkin> acowley: maybe it takes 7.2? I haven't tried it myself
14:41:46 <acowley> hrmph
14:42:00 <acowley> I don't think I want to upgrade yet.
14:42:56 <acowley> I'd like to play with it some time, though. I wonder if it could be made a bit more concise.
14:43:06 <acowley> as it stands, it's pretty forbidding
14:43:18 <jonkri> speaking of states... in the State monad, is there some way i can avoid to "re-get" the state when i have used "put"?
14:43:47 <roconnor> do {let s = foo; put s; ... use s ...}
14:44:15 <c_wraith> honestly, that question would make more sense with modify
14:45:03 <jonkri> roconnor, of course, thanks :)
14:46:43 <mm_freak> jonkri: yes, FRP has a learning curve…  also adopting FRP into for an existing project requires restructuring it completely
14:46:45 <c_wraith> I'm kind of surprised there isn't some sort of modify' :: MonadState s m => (s -> (s, a)) -> m a
14:47:02 <c_wraith> Amusingly, the "state" function does that for StateT constructions
14:47:30 <mm_freak> jonkri: regarding your last question, most monad transformer libraries provide a 'modify' function
14:47:39 <c_wraith> But it could be implemented purely in terms of get and put
14:47:53 <roconnor> @hoogle State s m a -> m a
14:47:53 <lambdabot> Did you mean: State s m -> m a /count=20
14:47:54 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
14:47:54 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
14:47:54 <mm_freak> modify :: MonadState m => (StateOf m -> StateOf m) -> m (StateOf m)
14:50:23 <ocharles> given  class Foo a where fooName :: FooName a  is it possible to actually get fooName from other functions, outside the class? For example: getFoos :: Foo foo => IO [f], getFoos = ... fooName :: Foo f ?
14:50:35 <ocharles> I have -XScopedTypeVariables on, but this still doesn't seem to typecheck
14:50:55 <Andreas___> Hi, I'm wondering if there are any libraries of STM-based concurrent data structures? I looked around on hackage and didn't find much.
14:53:15 <kmc> what's the preferred syntax for changelogs in cabal descriptions?
14:53:23 <kmc> i can't remember any of the packages that did this
14:53:28 <c_wraith> Andreas___: http://hackage.haskell.org/package/resource-pool uses stm
14:53:36 <ocharles> I have a feeling that what I want to do doesn't work, because the type 'f' is not actually bound to be refereable in the definition of getFoos
14:53:45 <kmc> ocharles, you have to bring type variables into scope with 'forall'
14:53:48 <ocharles> (while it is bound in a class definition)
14:53:53 <ocharles> kmc: aha
14:54:10 <dolio> kmc: I think vector has changelogs in the cabal file.
14:54:13 <ocharles> I'll look into that (existential quallification, is that?{)
14:54:17 <kmc> no ocharles
14:54:33 <kmc> the "forall" syntax is used by several different GHC extensions
14:54:39 <kmc> including ScopedTypeVariables
14:54:40 <djahandarie> acowley, ah, I cheated and uncommented something broken for the paste
14:54:43 <dcoutts> kmc: I applied a patch yesterday to do proper changelogs in the new hackage-server
14:54:43 <ocharles> ah, I see
14:54:50 * ocharles r's tfm
14:54:53 <djahandarie> It isn't fully functional yet, that was a premature paste by copumpkin ;)
14:54:54 <kmc> dcoutts, cool! how do you use it?
14:55:01 <copumpkin> oh noes
14:55:02 <dcoutts> kmc: so that will be the preferred way, rather than putting things in a long package description
14:55:05 <copumpkin> I'm known for my premature pasting
14:55:12 <dcoutts> kmc: ordinary format changelog file
14:55:17 <copumpkin> dcoutts: sweet!
14:55:24 <copumpkin> that's exciting
14:55:43 <dcoutts> thanks to Stefan Wehr
14:55:48 <copumpkin> how far is the new hackage server from being deployed, by the way?
14:55:52 <dcoutts> he did that at the hackathon
14:55:56 <copumpkin> cool :)
14:55:59 <copumpkin> is he on IRC?
14:56:21 <dcoutts> copumpkin: I don't recall what nick
14:56:24 <copumpkin> ah
14:56:47 <luite> dcoutts: great :)
14:56:53 <dcoutts> copumpkin: I expect it to be usable for in-house or private deployments, and for a public testing instance soonish
14:57:09 <copumpkin> preflex: seen skogsbaer
14:57:09 <preflex>  Sorry, I haven't seen skogsbaer
14:57:48 <luite> dcoutts: do you know how all the haddocks are generated on the hackage server, what kind of scripts does it run for that?
14:58:06 <dcoutts> a full switchover of the current central server has various issues, especially to do with account migration
14:58:19 <dcoutts> luite: there's a separate machine that does it, it's not the server
14:58:37 <dcoutts> luite: I think it uses shell scripts and cabal-install
14:59:23 <Polarina> Is there a function like "f x y z = if x then y else z"?
14:59:27 <luite> dcoutts: it's because I have a server with a mirror of all hackage packages with diffs between versions, and I'd like to get diffs for the haddocks for each package as well
14:59:57 <Andreas___> c_wraith: thanks! I just realized I can search hackage by the depends list of packages. That should help me find any packages using stm on hack age.
15:00:00 <dcoutts> luite: well the new server will have package doc tarballs, just like it has package source tarballs
15:00:05 <parcs> Polarina: no
15:00:22 <Polarina> parcs: Ok, thanks.
15:00:33 <kmc> there should be :/
15:00:38 <luite> dcoutts: will it generate those for all older versions?
15:00:52 <shachaf> @src if'
15:00:52 <lambdabot> Source not found. There are some things that I just don't know.
15:00:56 <shachaf> @ty if'
15:00:57 <lambdabot> Not in scope: `if''
15:01:07 <dcoutts> luite: there's no magic, the server simply allows the docs to be uploaded by clients with suitable authorisation
15:01:21 <kmc> bool t f True = t; bool t f False = f
15:01:28 <dcoutts> luite: so it still relies on clients to build the docs and upload them
15:01:33 <kmc> would be the more consistent one
15:01:50 <shachaf> kmc: Consistent with foldr, you mean?
15:01:59 <luite> dcoutts: oh right. I'd rather build them myself then, or at least have the option if there are no doc tarballs available
15:02:22 <kmc> shachaf, and 'maybe' and 'either' etc
15:02:59 <dcoutts> luite: how do you manage your mirror btw?
15:03:49 <parcs> wow, lame
15:04:09 <luite> dcoutts: uh I downloaded all 16000 packages with wget, since I asked a few times in a few channels for better methods, but got no reply. now I just download the index and the uploadlog every hour and download the new versions with wget
15:04:11 <parcs> RebindableSyntax breaks if ... then ... else because ifThenElse doesn't exist
15:04:31 <dcoutts> luite: I see, you might be interested in the hackage-mirror client we've got
15:04:45 <dcoutts> luite: it diffs the source and target package indexes
15:04:51 <int80_h> could someone explain why "map ( <= 255) [1,2,3,4,5]" works, but "map ( <= 255 && >= 0) [1,2,3,4,5]" yields a parse error in ghci? (<interactive>:1:17: parse error on input `>='
15:05:33 <dcoutts> int80_h: section syntax is for a single infix operator
15:05:45 <parcs> :t (<= 255) && (>= 0)
15:05:46 <lambdabot>     The section `<= 255' takes one argument,
15:05:46 <lambdabot>     but its type `Bool' has none
15:05:46 <lambdabot>     In the first argument of `(&&)', namely `(<= 255)'
15:05:49 <parcs> not even that works
15:05:56 <luite> dcoutts: ah that could make it a bit faster
15:06:12 <parcs> int80_h: make an explicit lambda expression
15:06:12 <copumpkin> (| (<= 255) && (>= 0) |)
15:06:17 <copumpkin> that works if you have SHE turned on
15:06:23 <copumpkin> and the function applicative in scope
15:06:46 <dcoutts> luite: the code is in the hackage-server repo btw if you want it
15:06:55 <ddarius> copumpkin: But (| (<= 255 && >= 0) |) is still a parse error.
15:07:00 <int80_h> copumkin: what's SHE?
15:07:15 <copumpkin> ddarius: sure
15:07:21 <copumpkin> int80_h: the strathclyde haskell enhancement :)
15:07:25 <copumpkin> it's a preprocessor written by conor mcbride
15:07:36 <copumpkin> that does a lot of neat little tricks to make writing haskell more pleasant (unless you get errors)
15:07:38 <luite> dcoutts: I don't publish the index by the way, so it's not a real hackage mirror that can be used by cabal-install clients. if there's interest, I could make it a full mirror, but since the server is in the same data center as www.haskell.org, that would probably not be very useful
15:07:42 <copumpkin> (if you get errors, you're screwed)
15:07:48 <int80_h> heh
15:08:24 <dcoutts> luite: it might just be convenient for the mirroring, not for any other reason
15:09:13 <luite> dcoutts: hackage is fairly slow for me by the way, 500-600kB/sec, does it limit upload speed?
15:09:34 <dcoutts> luite: you mean limit download speed?
15:09:49 <dcoutts> luite: it would not surprise me if it's been configured to limit the download speed
15:09:50 <copumpkin> depends which side you look at it from :)
15:10:11 <luite> dcoutts: euh yes, download speed for me :)
15:10:15 <luite> upload for them
15:10:25 <dcoutts> luite: it's hosted by Galois
15:10:31 <luite> it took hours to download all 16000 packages :)
15:10:33 <dcoutts> it's not the haskell.org machine
15:10:38 * dcoutts is not surprised
15:15:43 <luite> dcoutts: thanks, I've found the mirror code
15:16:38 <luite> but the slow part of my mirror thing is the code that checks the new versions of the packages into a git repository, so I'll have to fix that first
15:16:38 <dcoutts> luite: patches welcome btw
15:16:56 <djahandarie> c_wraith, okay, so I'm trying to work with the destructor of one of these impredicative record things, and I've annotated everything I could think of... but can't seem to get rid of some odd concrete types that are popping up instead of the polymorphic ones I'm expecting
15:17:15 <geheimdienst> "cabal is for getting a package into ghc-pkg. once it's in there, cabal doesn't care (much) anymore
15:17:27 <geheimdienst> ^^ would that be accurate?
15:17:38 <c_wraith> djahandarie: have an example?
15:17:41 <luite> dcoutts: this is the site btw, http://hdiff.luite.com/   , I announced it on -cafe, which resulted in some discussion about changelogs on hackage
15:17:49 <djahandarie> c_wraith, no simple one yet, hold on
15:17:57 <dcoutts> geheimdienst: yes, though it cares about things registered with ghc-pkg when it's looking for dependencies for installing other packages
15:18:13 <dcoutts> luite: yes, I saw the discussion a bit
15:19:36 <luite> dcoutts: but if you can find the scripts that build the haddock, that would be very welcome. I'd like to add haddock diffs as it's probably easier to see api changes in those than in the full source code diffs that I have in the current version
15:19:48 <geheimdienst> dcoutts: nice, thanks. so suppose i was nuts enough to programmatically want a list of all installed packages, i'd have to go not to Distribution.*, but to the ghc api? (save for running ghc-pkg and parsing the resulting string)
15:20:18 <dcoutts> geheimdienst: the Cabal lib provides code to get an index of installed packages
15:20:24 <luite> geheimdienst: you can use the cabal api to get a list, but it calls ghc-pkg
15:20:46 <dcoutts> luite: aye, we'll need that eventually. I also hope we can copy over all the old existing docs
15:21:16 <dcoutts> geheimdienst: right, it calls ghc-pkg dump, parses the result and sticks it in a custom index data structure
15:21:41 <geheimdienst> interesting! i couldn't find it. what's the right module? is it in Distribution?
15:22:01 <dcoutts> luite: but it's not the focus at the moment, the focus is still on the foundations not the features
15:24:46 <luite> dcoutts: oh I'd be happy to show diffs for all docs in the same cgit web interface, if I had a way to build all the haddock docs on my own server :)
15:25:08 <dcoutts> luite: how would you diff the html?
15:25:30 <spetrea> is it hard to write something like Maxima ?
15:25:41 <spetrea> I think it's an awesome piece of software
15:25:47 <spetrea> but I don't know squat about LISP
15:25:58 <spetrea> well, nor do I know much about Haskell but I'm a fan :)
15:26:16 <luite> dcoutts: yeah that would've been my next question, does haddock have a text-only output. otherwise I'd use something to convert it to some basic text format
15:26:28 <spetrea> I had a look at Maxima's code and man ... that thing is really off the hook
15:26:35 <spetrea> they manipulate expression trees and such
15:26:43 <dcoutts> luite: I don't think so, just various kinds of html
15:27:00 <ddarius> The whole purpose of it is to manipulate expression trees.  But why is that impressive?
15:27:14 <dcoutts> luite: but it's better html than it used to be, so perhaps you can use a xslt or similar transform to get plain text
15:27:17 <hpaste> djahandarie pasted “ImpredicativeBrokenness” at http://hpaste.org/50382
15:27:21 <djahandarie> c_wraith, ^
15:27:30 <luite> dcoutts: maybe pandoc can handle it
15:27:39 <dcoutts> luite: or adapt haddock directly to generate API diffs
15:27:54 <spetrea> is there some equivalent of Maxima in Haskell ?
15:28:11 <djahandarie> c_wraith, I see where this could be happening but I don't think it's possible to actually give a type annotation for that...
15:28:16 <luite> dcoutts: hmm, I have everything in git repo's, so it's easier for me to have an easily diffable format than diffs directly
15:28:27 * djahandarie brb
15:28:54 <c_wraith> djahandarie: eh?  What's not working?  That compiles for me..
15:29:16 <c_wraith> djahandarie: oh, nevermind.  user error on my paste ability :)
15:30:00 * hackagebot GenericPretty 1.1.8 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-1.1.8 (RazvanRanca)
15:30:07 <spetrea> noone interested in symbolic Calculus I guess ...
15:30:28 <c_wraith> djahandarie: whoops.  I'll take a look at it later
15:33:15 <donri> is there any example of multiple typeclass constraints for the same value in a function? does that make sense?
15:33:24 <dibblego> donri: sure
15:33:34 <dibblego> (Functor f, Monad f) => f a -> b
15:33:51 <ddarius> You don't apply constraints to values, you apply them to types.
15:34:00 <shachaf> Functor f => Monad f => f a -> b
15:34:02 <donri> well yea :)
15:34:07 <djahandarie> c_wraith, heh, okay
15:34:23 <donri> isn't functor a monad
15:34:53 <djahandarie> shachaf, did we ever check if we actually worked?
15:34:54 <donri> excuse the ignorant newbie
15:35:08 <djahandarie> if that actually worked*
15:35:58 <dibblego> @type \f g -> fmap f . liftM g
15:36:14 * ddarius likes Lesson 25s.
15:36:23 <shachaf> djahandarie: It does.
15:40:31 <kmc> :t map show . sort -- donri
15:40:39 <kmc> bah
15:40:42 <kmc> where's lambdabot
15:40:56 <kmc> anyway it's (Ord a, Show a) => [a] -> [String]
15:41:00 <kmc> two constraints
15:41:02 <djahandarie> Lambdabot is dead, long live lambdabot...
15:41:14 <ion> Is our infrastructure really this fragile‽
15:41:30 <donri> hokay, how about typeclass constraint plus concrete type?
15:41:33 <ion> If we can’t depend on lambdabot, what can we depend on?
15:41:38 <donri> surely that doesn't make sense? :)
15:41:48 <djahandarie> Only God.
15:41:57 <ion> djahandarie: I thought that was lambdabot.
15:41:58 <geheimdienst> lambdabot is a fragile girl. also, she prefers the word sensitive
15:42:03 <geheimdienst> cale: you around?
15:42:40 <brisingr> uh-oh, no lambdabot
15:42:55 <donri> it's everyone for themselves now
15:43:36 <geheimdienst> cale: lambdabot has fallen in with untrustworthy folk
15:43:51 <brisingr> quick someone host lambdabot
15:44:04 <brisingr> i'd do it myself but have  no idea what to discern from the readme
15:44:38 <kmc> donri, you can use type variables and concrete types in the same type, of course
15:44:56 <kmc> but you can't express a typeclass constraint on a concrete type in standard Haskell
15:45:09 <kmc> all constrants must be of the form (C a) where C is a class and 'a' is a variable
15:45:09 <donri> I mean like, Num a => (Int a) ??? nothing like that makes sense right?
15:45:19 <kmc> (Int a) doesn't make sense
15:45:22 <kmc> unless you've redefined Int
15:45:30 <donri> because it would say Int is a typec onstructor right
15:45:32 <kmc> Int does not take a type parameter
15:45:33 <kmc> yeah
15:45:49 <kmc> with -XFlexibleContexts, GHC will actually let you write "x :: (Show Int) => String"
15:45:55 <kmc> it's pretty useless, though
15:47:08 <brisingr> look i'll try to build lambdabot
15:48:00 <brisingr> no promises
15:50:14 <donri> i bet she grew a conscious and adopted a prime directive regarding puny humans
15:51:10 <brisingr> how do you automatically install all haskell deps?
15:51:21 <kmc> cabal install lambdabot
15:51:42 <brisingr> heh
15:51:46 <brisingr> wow
15:51:55 <brisingr> thought I had to source compile
15:51:59 <jonkri> kmc, haha
15:52:16 <kmc> that does source compile, brisingr
15:52:16 <jonkri> no, nevermind :P
15:52:25 <brisingr> no, I meant, manually source compile
15:52:29 <brisingr> like manual deps
15:52:39 <brisingr> had to do it before, huge pain
15:52:49 <kmc> that's how things were in like 2007
15:53:12 <donri> redhat 1995.
15:53:52 <kmc> rpmfind!
15:54:00 <jonkri> my monad transformer requires IO, and most uses of it will stack IO and StateT below my monad. currently, i have the restriction MonadIO m on my monad transformer, but StateT wont qualify as a MonadM, will it? if not, is there some way i can get around it?
15:54:21 <kmc> «StateT s IO» is a MonadIO
15:55:05 <brisingr> question in advance, where's online.rc
15:55:39 <brisingr> :t (>>=)
15:55:57 <brisingr> nope, she's still missing
15:56:26 <brisingr> nooo
15:56:28 <brisingr> compile fail
15:56:48 <ivanm> so, who killed lambdabot this time? ;)
15:56:57 <danharaj> lambdabot from the future.
15:57:04 <brisingr> haskell-src-exts-1.11.1 failed during the configure step. The exception was:
15:57:04 <brisingr> ExitFailure 1
15:57:18 <jonkri> what about StateT s (ErrorT (WhateverT( IO))), is that a MonadIO?
15:58:24 <parcs> no
15:58:45 <parcs> you can make WhateverT a MonadIO though
15:58:49 <ivanm> jonkri: I think it is if WhateverT is an isntance of MonadIO
15:59:11 <jonkri> yeah, sorry, WhateverT is an instance of MonadIO, forgot to mention that
15:59:19 <parcs> then yes
15:59:43 <parcs> the instance is MonadIO m => MonadIO (WhateverT m), right?
15:59:54 <parcs> (not WhateverT IO)
16:00:19 <brisingr> ok lambdabot's compiling again
16:00:20 <jonkri> no, i thought it was the second one, IO on the bottom of the stack
16:00:22 <ivanm> parcs: though in this case it shouldn't matter
16:00:47 <parcs> ivanm: true
16:00:50 <ivanm> jonkri: parcs meant that the instance was of the form "if the underlying monad is a MonadIO, then so is this one"
16:01:22 <parcs> jonkri: the former type is more general
16:01:45 <brisingr> is lambdabot dead everywhere?
16:02:07 <parcs> failed to build it? :P
16:02:42 <brisingr> nope
16:02:44 <brisingr> success
16:02:46 <jonkri> yeah, isee :)
16:02:54 <brisingr> now want to config it
16:03:02 <mokus> i think compiling lambdabot is a major rite of passage
16:03:11 <mokus> somewhere around writing a monad tutorial
16:03:36 <brisingr> hmm
16:03:52 <brisingr> should I make it to join all channels?
16:04:01 <brisingr> only this one better
16:05:01 <ocharles> Any aeson guru's around? I'm trying to parse {"hits":{"hits":[ ... ]}}, but I'm not sure how to do it. So far I have: parseJSON (object o) = SearchResults <$> ( (o .: "hits") >>= return . toList . (! "hits") ) -- but it complains it can't deduce: FromJSON (Map ko (Vector d))) -- even though there are FromJSON instances for  d  ,  Vector d  ,  and Map k0 j  (where j is anything that is an instance
16:05:01 <ocharles> of FromJSON)
16:05:28 <ocharles> I'm just kinda confused, because from what I can see, there's an instance of FromJSON here...
16:07:18 <brisingr> :t (>>=)
16:07:19 <lambdabot2> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:07:22 <brisingr> YES
16:07:36 <brisingr> woot
16:07:41 <cmccann> hm
16:07:44 <Cale> I can't ssh into lambdabot's machine.
16:07:49 <cmccann> > fix error
16:07:49 <lambdabot2>  Terminated
16:07:52 <cmccann> :[
16:07:58 <brisingr> it's from my machine
16:08:03 <brisingr> tell me if you want to turn it off
16:08:06 <Cale> nono
16:08:13 <Cale> I mean the machine that lambdabot usually runs on
16:08:17 <Cale> I can't ssh into it
16:08:24 <Cale> It's lispy's server
16:08:30 <brisingr> should I make it join all channels not only #haskell?
16:08:35 <Cale> whatever
16:08:36 <brisingr> like all defaults in config?
16:08:46 <Cale> I will probably get it back up whenever lispy shows up
16:09:01 <brisingr> ok, in the meantime, lambdabot2 says brb
16:09:24 <acfoltzer> I didn't realize lambdabot was lispy's
16:09:30 <acfoltzer> should I go find him?
16:09:47 <ddarius> Ascribing ownership of lambdabot is misguided.
16:09:54 <acfoltzer> well, that instance
16:09:59 <ddarius> Ascribing ownership of lambdabot is misguided.
16:10:05 <acfoltzer> heh
16:10:08 <ocharles> Aha! k0 was confusing it. "hits"::Text in the (!) section gets it
16:10:16 <brisingr> okay lambdabot2's back everywhere
16:11:15 * ddarius needs to rustle up a paper bag.
16:11:21 <brisingr> Cale, just shoot me a message when you want me to kill it
16:11:33 <Cale> sure
16:12:05 <shachaf> lambdabot2: @quote
16:12:06 <lambdabot2> SeanRussell says: [Seen on the wmii (window manager) mailing list] Hah!  That's a laugh.  Since when does "it compiles" equate to "it will run (correctly)"?  We're talking about C, after all... not
16:12:06 <lambdabot2> Haskell.
16:13:50 <kmc> hi lambdabot2
16:13:59 <shachaf> lambdabot2: @quote kmc
16:13:59 <lambdabot2> kmc says: I enjoy it when people write "C/C++" on their resume as if it were one language... so "F#/FORTRAN/Forth", "Perl/Python/Pascal", "Ruby/REBOL/R"
16:14:12 <kmc> where does its quote db come from?
16:14:13 * ddarius hacks into brisingr's machine via lambdabot2.
16:14:21 <ddarius> kmc: There's one in the source.
16:14:23 <brisingr> dunno, it's the default one
16:14:23 <shachaf> kmc: Checked into darcs.
16:14:40 <coppro> lambdabot2: in the interview, ask them if they have any experience with Python/PHP
16:14:53 <coppro> "it's the language used for web development"
16:15:03 <ocharles> no that's ruby on rails
16:15:04 <ocharles> the language
16:15:19 <shachaf> Ruby on Rails transcends language.
16:16:06 <donri> i love it when people say they've programmed too
16:16:08 <donri> "html".
16:16:21 <kmc> CSS3 is Turing-complete
16:16:33 <ion> Someone knows Ruby/REBOL/R but not Rexx?!
16:17:02 <ion> donri: Well, HTML/Haskell.
16:17:07 <kmc> https://github.com/elitheeli/oddities/blob/master/rule110-grid.html
16:17:13 <donri> ah, of course
16:17:45 * cmccann thinks APL/Agda sounds appealing enough though
16:18:19 <ddarius> That's a lot of checkboxes.
16:18:42 <ddarius> cmccann: I would like to see someone pull that off.
16:19:35 <cmccann> ddarius, what, knowing enough of both to be able to put them on a resume? Or actually doing so in the aforementioned manner?
16:20:25 <ddarius> Making a language that is a combination of Agda and APL.
16:22:00 <cmccann> I wouldn't think it would be conceptually difficult, just a lot of work to design and implement
16:22:33 <ddarius> Well the first thing you'd need to do is make the APL parseable.
16:22:35 <cmccann> though I'm only vaguely familiar with both so maybe there's something that would require breaking new ground to successfully combine things
16:24:00 <cmccann> there's also the matter of what combining them entails, my impression is that the APL family of languages as a whole have never really had much use for types
16:26:51 <ddarius> If I write "C/ C++", can I claim that "/" is an oversized comma?
16:27:07 <cmccann> no, say it's division
16:27:59 <donri> C ÷ (C + 1)
16:28:26 <shachaf> > (==) "C + 1" "C++"
16:28:26 <lambdabot2>  Terminated
16:28:37 <Entroacceptor> so you know something<1???
16:30:06 <cmccann> well, C++ is using postfix increment, so I guess it would be C / C++ = 1, but the value of C is incremented afterwards
16:31:44 <shachaf> "C/" would be a good name for a programming language.
16:32:04 <ion> “C?”
16:32:15 <ocharles> perfectly googlable!
16:32:19 <cmccann> alternatively you can treat them as just names and regard (C/C++) as a quotient language consisting of C where all concepts in C++ are treated as equivalent
16:32:36 <ddarius> C☃
16:32:53 <ion> C卐
16:32:55 <geheimdienst> C\NUL
16:33:01 <cmccann> geheimdienst, ha
16:33:02 <shachaf> C☧
16:33:13 <ocharles> c';DROP TABLE, duh
16:33:26 <cmccann> ℂ++
16:33:31 <kmc> haha cmccann
16:33:45 <ion>  ╷╷
16:33:52 <geheimdienst> CCCP
16:33:53 <ion> C┼┼╴
16:33:58 <ion>  ╵╵
16:34:20 <brisingr> C>>=
16:34:21 <donri> Haskell++ It's Haskell with classes!
16:34:26 <Polarina> You all enjoy yourselves, I am off to bed.
16:34:34 <shachaf> Cℌ№
16:34:43 <donri> C♯
16:34:51 <cmccann> donri, no, that's just ridiculous
16:34:57 <donri> yea you're right
16:35:04 <ion> geheimdienst: ITYM СССР
16:35:18 <geheimdienst> c-blunt, c-sharp
16:35:32 <shachaf> ion: ☭++?
16:35:37 <donri> C-soft by Microsharp
16:35:51 <geheimdienst> ion: yeah that's extremely different from what i wrote ;)
16:36:00 <shachaf> geheimdienst: It's very different!
16:36:16 <brisingr> C»
16:36:22 <ion> > "СССР" > "CCCP"
16:36:23 <lambdabot2>  Terminated
16:36:24 <geheimdienst> (++
16:36:34 <shachaf> CСCР
16:36:37 <brisingr> C>>=
16:36:46 <ion> shachaf: heh
16:36:56 <brisingr> > 2 > 3
16:36:56 <lambdabot2>  Terminated
16:36:59 <brisingr> what
16:37:09 <brisingr> why does lambdabot do that?
16:37:12 <cmccann> I think lambdabot2 is having issues with evaluating expressions
16:37:13 <brisingr> > 3 > 2
16:37:13 <lambdabot2>  Terminated
16:37:17 <cmccann> > ()
16:37:17 <lambdabot2>  Terminated
16:37:19 <ion> I always said 2 > 3 is Terminated but my math teacher didn’t believe me.
16:37:19 <cmccann> yeah
16:37:24 <ddarius> Do you have mueval?
16:37:25 <brisingr> :t (>>=)
16:37:27 <lambdabot2> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:37:31 <shachaf> (> 3) > 2
16:37:31 <brisingr> hmm
16:37:34 <lambdabot2> False
16:38:02 <brisingr> hmm
16:38:06 <lispy> Cale: I don't know why my linode has been going down.  I'm doing some scans of the machine and I read the logs, but otherwise it's a mystery to me
16:38:21 * lambdabot2 is done with this job
16:38:35 <brisingr> should I kill it?
16:38:54 <lispy> ?botsnack
16:38:55 <lambdabot2> :)
16:38:56 <shachaf> brisingr: Inhumane!
16:39:04 <brisingr> should I fulfill its purpose?
16:39:56 <brisingr> at least what's the problem with its >?
16:40:53 <Cale> lispy: any hints about what I can do to fix that if it happens?
16:40:59 <Cale> lispy: Or do we just wait?
16:41:49 <siracusa> @botsnack
16:41:49 <lambdabot2> :)
16:41:54 <lambdabot> :)
16:42:01 <brisingr> ok
16:42:02 <brisingr> killing it
16:44:34 <brisingr> > "C" > "C"
16:44:38 <lambdabot>   mueval-core: Time limit exceeded
16:44:44 <cheater_> wat
16:44:58 <brisingr> indeed
16:44:59 <kmc> > ()
16:45:01 <lambdabot>   ()
16:45:06 <brisingr> > 2 + 3
16:45:07 <lambdabot>   5
16:45:20 <brisingr> > "c" > "b"
16:45:21 <lambdabot>   True
16:45:24 <brisingr> > "c" > "c"
16:45:24 <lambdabot>   False
16:45:31 <brisingr> > "C" > "C"
16:45:32 <lambdabot>   False
16:45:35 <brisingr> good
16:47:33 <ivanm> brisingr: lambdabot was still starting up and hence busy
16:47:45 <brisingr> ivanm: I see
16:47:51 <lispy> Cale: We could see if other linode folks are complaining
16:48:14 <lispy> Cale: I've run some exploit checkers, reviewed the logs, and everything seems normal/sane
16:48:39 <lispy> Cale: So if it's exploited it would have to be through lambdabot :)
16:49:27 <lispy> Cale: When it crashes the linode stuff seems to automatically reboot it
16:49:30 <ivanm> lispy: in that case, maybe lambdabot needs to start using SafeHaskell... :p
16:49:40 <brisingr> lispy: do the active lambdabot's databases sync with the sources?
16:49:48 <brisingr> like, quotes
16:49:55 <lispy> brisingr: no idea.  You'd have to ask Cale
16:49:59 <ion> > "СССР" > "CCCP"
16:50:00 <lambdabot>   True
16:50:09 <lispy> I provide a server, but I don't administer the bot
16:50:15 <brisingr> I see
16:50:31 <brisingr> well, next step, multiserver bot
16:50:42 * hackagebot graphviz 2999.12.0.3 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.12.0.3 (IvanMiljenovic)
16:50:44 * hackagebot patience 0.1.1 - Patience diff and longest increasing subsequence  http://hackage.haskell.org/package/patience-0.1.1 (KeeganMcAllister)
16:50:51 <ion> If lambdabot were distributed, i wouldn’t mind providing a fallback instance.
16:50:52 <brisingr> in 5 years I'll know enough haskell to be able to help :)
16:51:10 <brisingr> neither would I
16:56:29 <jonkri> good night everyone :)
16:56:51 <lucca> lispy: http://status.linode.com/2011/08/partial-outage-in-fremont.html
16:57:11 <lucca> have a shot every time fremont loses power >_>
16:58:18 <thoughtpolice> heh, just talking to someone else about that
16:58:29 <thoughtpolice> apparently already happened 3 times this month at the fremont DC?
17:00:06 <geheimdienst> at least these linode dudes seem to be quick about updating that web status page
17:06:44 <HugoDaniel> hi
17:06:58 <brisingr> hi
17:07:05 <HugoDaniel> hey brisingr
17:07:11 <HugoDaniel> how's that haskell going ?
17:07:41 <brisingr> hey, it's going just fine
17:07:58 <brisingr> how's it going over there?
17:08:29 <dankna> lucca: hahaha the linode drinking game?
17:08:48 <HugoDaniel> 2cool
17:09:14 <brisingr> was wondering why linode only guarantee three-nines uptime
17:09:48 <parcs> 99.9 or 99.999 ?
17:09:56 <brisingr> 99.9
17:10:24 <parcs> > (100 - 99.9) * (60 * 60 * 24 * 30 * 365)
17:10:25 <lambdabot>   9.460799999999462e7
17:10:32 <sm_> lispy, Cale: linodes hosted in fremont were just affected by a power outage, cf http://status.linode.com/ and #linode on oftc.net
17:10:37 <ion> > 365*24 * 0.999  -- hours/year
17:10:38 <lambdabot>   8751.24
17:10:44 <ion> err
17:10:46 <sm_> oh yu found it
17:10:48 <ion> > 365*24 * (1-0.999)
17:10:49 <lambdabot>   8.760000000000009
17:11:11 <brisingr> that's 43 minutes per month
17:11:24 <luite> I have a german hosting provider, it only guarantees three neins
17:11:25 <brisingr> this month's downtime is according to schedule
17:11:31 <parcs> what the hell did i calculate?
17:11:44 <brisingr> you calculated correctly
17:12:01 <parcs> yes but what
17:12:21 <parcs> downtime in seconds/year?
17:12:26 <brisingr> hours
17:12:28 <brisingr> per year
17:12:43 <brisingr> it's ironical how lambdabot helped calculate her downtime
17:13:25 <donri> no, ironical would be if she went down doing it
17:13:43 <lucca> brisingr: linode does quite well. Individual physical datacenters have troubles, obviously.
17:13:53 <lucca> I'd really like to know what UPS hurricane electric has been using.
17:13:57 <ion> Thus lambdabot should be distributed. :-P
17:14:11 <parcs> we have to wait til cloud haskell for that
17:14:25 <luite> lucca: can you quickly bring up a linode in a different datacenter of one has problems?
17:14:29 <luite> if
17:14:39 <brisingr> from what they tell
17:14:44 <lucca> luite: yes.  You can have dynamically provisioned clouds of them
17:14:52 <brisingr> you can do that "in a matter of minutes"
17:14:54 <luite> lucca: but how about your data?
17:15:02 <luite> do they sync that for oyu?
17:15:09 <lucca> depends.
17:15:31 <ddarius> brisingr: You've probably calculated how much you'll sleep in your lifetime.
17:15:41 <lucca> If you are setting up a H-A cluster with geographic distribution, you need to be keeping your nodes in live-sync at the application level, which is far outside their scope
17:15:57 <brisingr> ddarius: wait, what?
17:16:26 <brisingr> yes I know I have like a 18/8 biorhythm
17:16:38 <lucca> for smaller things, like if you have a single node and want to know if they'll protect you from reasonable unforseen failures, sure; a few months ago Fremont had a lightning strike (!) that destroyed hardware (!!), and they were able to restore from backups.
17:16:50 <parcs> my calculation was actually downtime in centiseconds/year, it seems
17:17:02 <brisingr> hmm
17:17:05 <lucca> but I think what you're asking for is software that hasn't been written yet.
17:17:37 <parcs> 8.7 * 60 * 60
17:17:40 <parcs> > =8.7 * 60 * 60
17:17:40 <lambdabot>   <no location info>: parse error on input `='
17:17:41 <ion> parcs: * 30
17:17:44 <parcs> > 8.7 * 60 * 60
17:17:45 <lambdabot>   31320.0
17:17:50 <lucca> intercontinental latency and link reliability still make it awkward in the long term, without lots of caching and distributed authority.
17:17:56 <parcs> oh right
17:19:18 <lucca> I think it isn't really viable to assume people can move your data /after/ a failure.  If they have no power, they have no power.
17:22:07 <dankna> yeah
17:22:13 <dankna> you want to be running rsync yourself
17:22:22 <dankna> or whatever other sync mechanism is appropriate
17:23:16 <dankna> mine is in the Newark datacenter, which appears to be much more reliable
17:31:13 <brisingr> *chirp* *chirp* *chirp*
17:32:04 <brisingr> hey lambdabot
17:32:08 <brisingr> @botsnack
17:32:09 <lambdabot> :)
17:33:50 <brisingr> it's creepy in here
17:34:47 <dainanaki> oh noes
17:35:37 <brisingr> @quote
17:35:37 <lambdabot> hoooool says: haskell is optimized for trolling and that is why everyone should use it
17:35:55 <shachaf> @v
17:35:55 <lambdabot> Exception: <<loop>>
17:36:02 <shachaf> @protontorpedo
17:36:02 <lambdabot> I dont know any programming yet at 33 dream of learning ti and gettign rich
17:37:57 <applicative> what is 'protontorpedo'?
17:37:58 <Eduard_Munteanu> brisingr: you don't get much sleep either, do you? :P
17:38:09 <brisingr> nope
17:38:18 <copumpkin> applicative: you playing jeopardy?
17:38:39 <brisingr> something like 18h/6h
17:38:48 <Eduard_Munteanu> Oh, I thought it was an (inexact) reference to Star Trek's photon torpedos
17:38:54 <copumpkin> it's some ex-troll, I think
17:39:03 <ben> star wars has proton torpedos
17:39:15 * Eduard_Munteanu takes note
17:39:18 <geheimdienst> yeah, he was immortalized in his own lambdabot plugin
17:39:24 <applicative> maybe both. I use as many fundamental particles as possible, where possible.
17:39:28 <geheimdienst> @keel
17:39:28 <lambdabot> tomorrow i share next mathematical secrety
17:39:28 <kmc> torpedos are generally known to contain a large number of protons
17:39:38 * cmccann launches photoprotoneutron torpedoes
17:39:50 * brisingr intercepts
17:40:11 <brisingr> speaking of lambdabot plugins
17:40:18 <Eduard_Munteanu> Heh, it's more like I don't sleep regularly, but I do get enough sleep.
17:40:38 <brisingr> yeah, I try to do that too; it makes one flexible
17:40:54 <brisingr> I want a lambdabot plugin to reply to all "hi"s
17:41:04 <applicative> > "hi"
17:41:05 <lambdabot>   "hi"
17:41:09 <Eduard_Munteanu> @vixen say hi to brisingr
17:41:09 <lambdabot> hi
17:41:14 <applicative> people just don't know how to say hi here
17:41:36 <Eduard_Munteanu> > text "hi"
17:41:37 <lambdabot>   hi
17:41:53 <brisingr> @botsnack
17:41:53 <lambdabot> :)
17:41:57 <applicative> > nest 20 "hi"
17:41:58 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
17:41:58 <lambdabot>         agains...
17:42:08 <applicative> > nest 20 (text "hi")
17:42:09 <lambdabot>                       hi
17:42:24 <applicative> so the types don't match, who cares?
17:42:24 <copumpkin> kmc: another possible semantics for your impredicative IO type (the pool one) is a rate limiter
17:42:30 <copumpkin> kmc: just a random thought
17:42:36 <kmc> yeah
17:42:45 <edwardk> impredicative IO?
17:42:56 * applicative was a little startled too
17:43:10 <copumpkin> Int -> IO (forall a. IO a -> IO a)
17:43:11 <copumpkin> iirc
17:43:49 <edwardk> the int is some number of steps, etc?
17:43:59 <shachaf> I think it's the number of IO actions running at a time.
17:44:47 <edwardk> ah
17:46:16 <brisingr> it sure was lonely without lambdabot
17:46:29 <brisingr> you're cute aren't you lambdabot?
17:46:31 <brisingr> @botsnack
17:46:31 <lambdabot> :)
17:46:46 <cmccann> @vixen did you miss us?
17:46:46 <lambdabot> is that really what you want to know?
17:46:49 <cmccann> haha
17:46:52 <edwardk> @vixen a/s/l
17:46:53 <lambdabot> 19/f/California
17:47:07 <edwardk> o.O
17:47:39 <applicative> @vixen where are you from these days?
17:47:40 <lambdabot> Huntington Beach California
17:47:52 * cmccann thinks lambdabot is lying about that age, Haskell itself is barely that old
17:48:09 * applicative likes vixen better when it's from Russia
17:49:30 * applicative is startled by picture of familiar F-sharper & haskell - troll http://www.dotnetrocks.com/default.aspx?showNum=266
17:51:33 * applicative is delighted that XCode thinks he's judah jacobson, but something needs to be changed
17:51:59 <shachaf> cmccann: A lot of people in this channel are younger than Haskell.
17:52:17 <geheimdienst> applicative: if something needs to be changed, how about getting rid of xcode
17:52:54 <cmccann> shachaf, and some are older. But I really doubt that lambdabot is one of them :P
17:53:08 <applicative> not sure how much choice I have with a package calling itself "CoreMac"
17:53:19 <shachaf> lambdabot is probably older than Haskell.
17:55:09 <applicative> geheimdienst https://github.com/judah/CoreMac Do I need an undergraduate degree in Mac Science to use Xcode?
17:55:28 <Saizan> apparently haskell is from 1990 so lambdabot wouldn't be older by being 19 in 2011
17:56:13 <kmc> maybe lambdabot got started with Lazy ML
17:56:23 <geheimdienst> applicative: j/k. it's just that i find xcode kinda annoying
17:56:45 <dolio> lambdabot has been 19 since I got here.
17:57:20 <cmccann> Saizan, yes, but I would expect lambdabot to be a good bit younger :P
17:58:17 <Jafet> @quote 17-ary
17:58:18 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
17:58:24 <brisingr> so what, lambdabot wouldn't be the first one to be lying about their age on the internate
17:58:33 <cmccann> brisingr, which was my original point :]
17:58:35 <brisingr> *internet
17:58:39 <brisingr> :)
17:58:42 * shachaf has never lied about lambdabot's age on the Internet.
18:02:28 <Kaidelong> what's the difference between Monoid and Category?
18:02:49 <Cale> Kaidelong: the types
18:02:59 <Cale> Kaidelong: with a monoid, you can compose any two elements of the monoid
18:03:10 <Cale> with a category, you can only compose arrows which line up end to end
18:03:47 <Kaidelong> well that part I understand, but I'm struggling to find a simple answer to give
18:03:55 <Cale> (a monoid is essentially the same thing as a category with one object)
18:03:58 <Kaidelong> I guess "the types" is fine
18:04:09 <cmccann> where a category with one object here means going to and from the same type
18:04:35 <Cale> Yeah, means that all arrows in the category go from the unique object to itself.
18:04:50 <Cale> (and so any two arrows can be composed)
18:05:03 <Cale> The Category class in Haskell is sort of odd though
18:05:15 <Cale> in that you're forced to have the set of Haskell types as objects
18:05:51 * hackagebot tkyprof 0.0.6.2 - A web-based visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.0.6.2 (MitsutoshiAoe)
18:05:51 <dolio> A category has a partial binary operation.
18:06:01 <Cale> (and the composition has to be polymorphic, which puts somewhat hard-to-state naturality constraints on what's actually possible)
18:06:10 <Kaidelong> dolio: I like that
18:06:31 <Kaidelong> category composition is partial, monoid addition is total
18:06:43 <dolio> And two operations dom, cod : M -> A, where the binary operation f . g is defined exactly when dom f = cod g.
18:07:09 <dolio> However, I don't like that definition.
18:07:24 <Eduard_Munteanu> About that...
18:07:25 <applicative> it's dreadful.
18:07:26 <dolio> And most category theory isn't conceived of that way.
18:07:48 <applicative> there's a total function from pairs of objects to Hom sets
18:07:48 <cmccann> it's kind of hard to explain Category because it's stupidly simple
18:08:05 <Eduard_Munteanu> Do all Haskell adjoint functors stay in Hask?
18:08:07 <cmccann> there's just not much there to explain
18:08:41 <brisingr> it just clicks into place
18:08:48 <applicative> Eduard_Munteanu If there is Hask, there are functors to Set, which isn't Hask, etc.
18:08:48 <brisingr> let's see if I got it right
18:08:50 <Eduard_Munteanu> e.g. can some Haskell monads be decomposed into adjoint functors going in and out of Hask ?
18:09:24 <dolio> Yes.
18:09:33 <copumpkin> I'd hope all of them can
18:09:37 <copumpkin> if you let yourself leave hask
18:09:59 <copumpkin> oh, I misunderstood your question
18:10:06 <copumpkin> Eduard_Munteanu: state arises pretty trivially
18:10:13 <cmccann> on the other hand, decomposing Haskell monads into functors leaving Hask, in Haskell, poses some difficulty
18:10:29 <Eduard_Munteanu> Hask is almost Set-like so I wondered if it's even needed to leave Hask...
18:10:38 <cmccann> depending on whether you count functors to subcategories or the opposite category
18:11:15 <Eduard_Munteanu> In fact I wonder if they're equivalent as categories.
18:11:28 <kmc> Hask only contains computable functions
18:11:30 <Eduard_Munteanu> (category equivalence to be exact)
18:11:44 <kmc> so it's much smaller than Set
18:11:46 <copumpkin> no, they aren't at all
18:11:53 <cmccann> Hask also has no initial object, if memory serves me
18:12:08 <Eduard_Munteanu> cmccann: data Void ?
18:12:14 <copumpkin> undefined :: Void
18:12:20 <cmccann> Eduard_Munteanu, is terminal
18:12:23 <cmccann> because of _|_
18:12:27 <Eduard_Munteanu> Oh, right.
18:12:29 <cmccann> () has two values
18:12:32 <dolio> Hask isn't a category.
18:12:32 <cmccann> nice try though!
18:12:36 <kmc> stupid ⊥
18:12:39 <dolio> If you're going to get technical.
18:12:50 <copumpkin> CPO\_\bot supposedly gets pretty close to what we want in it
18:12:50 <Eduard_Munteanu> dolio: interesting, could you expand on that?
18:12:53 <brisingr> so you can leave Hask but it isn't really useful?
18:13:01 <copumpkin> or CPPO or whatever
18:13:07 <dolio> _|_ . id /= _|_
18:13:37 * applicative doesn't understand this use of '=' and '/='
18:13:50 <cmccann> anyway, I think a lot of the time when people say Hask they're talking about the platonic ideal of "the category of Haskell types and functions" and sweeping some stuff under the rug, conceptually
18:13:54 <ion> Does this get through to the channel? I guess the +c mode blocks it. |
18:14:00 <Eduard_Munteanu> dolio: how so, laziness?
18:14:01 <kmc> ion, i see it
18:14:16 <dolio> > (undefined :: Int -> Int) `seq` ()
18:14:17 <lambdabot>   *Exception: Prelude.undefined
18:14:24 <cmccann> but it's hard to tell sometimes how precise people are being when they talk about "Hask" as a category
18:14:28 <dolio> > (undefined . id :: Int -> Int) `seq` ()
18:14:31 <lambdabot>   mueval-core: Time limit exceeded
18:14:36 <dolio> > (undefined . id :: Int -> Int) `seq` ()
18:14:38 <lambdabot>   ()
18:14:41 <ion> | is ASCII with IRC underline.
18:14:44 <Eduard_Munteanu> Hm.
18:15:00 <kmc> oh, no, i just see a bar
18:15:02 <Jafet> +c just strips formatting.
18:15:02 <Kaidelong> dolio: What just happened
18:15:03 <cmccann> ion, just use ⊥
18:15:20 <dolio> undefined . id = \x -> undefined (id x) = \x -> undefined
18:15:32 <ion> cmccann: Of course i will. :-P
18:15:40 <dolio> seq sees a lambda and stops.
18:15:49 <Kaidelong> ah right
18:15:57 <Kaidelong> lambda is a constructor
18:15:59 <Eduard_Munteanu> Oh, so   undefined . id = const undefined
18:16:00 <kmc> so "Haskell with seq" is not a category
18:16:23 <kmc> but if you banish seq, it is?
18:16:34 <dolio> I think so.
18:16:34 <kmc> even if you have ⊥ as a morphsim?
18:16:37 <hpc> seq breaks just about everything
18:16:47 <dolio> But then it's still not a particularly nice category.
18:16:49 <applicative> or else _|_ isn't a point in them you can use to prove 'identity' and 'difference' of arrows
18:16:53 <kmc> i don't think you can distinguish ⊥ from (const ⊥) without seq or something morally equivalent
18:17:02 <dolio> Because tuples aren't products, and either isn't a sum.
18:17:19 <copumpkin> omg it's bob harper
18:17:27 <Kaidelong> practically speaking, can you banish seq but not banish _|_?
18:17:36 <kmc> define "practical"
18:17:56 <Kaidelong> don't force in ineffiencies on the programmer
18:18:06 <applicative> it's bob harper, spreading academic convention as usual
18:18:18 <copumpkin> Kaidelong: you can approximate seq without its ugly behavior without a builtin
18:18:22 <kmc> if you only want to use 'seq' on algebraic data types
18:18:27 <kmc> then you can use ordinary Haskell functions
18:19:18 <dolio> Actually, if you got rid of seq, you could make pattern matches on tuples and the like irrefutable, and then you'd have genuine products.
18:19:24 <dylukes> ?
18:19:26 <dolio> Because you wouldn't be able to tell the difference.
18:19:27 <dylukes> dolio: what do yo mean?
18:19:44 <dylukes> define "irrefutable"
18:19:47 <dylukes> (in this context)
18:19:48 <dolio> Products require that p = (fst p, snd p)
18:20:01 <dylukes> example...?
18:20:04 <dolio> Irrefutable means they can't fail to match.
18:20:12 <Eduard_Munteanu> I'm finding it hard to see how irrefutable pattern matching would be convenient in all cases.
18:20:18 <dolio> > case undefined of ~(x, y) -> 5
18:20:19 <lambdabot>   5
18:20:25 <dolio> That match is specified to be irrefutable.
18:20:30 <dolio> > case undefined of (x, y) -> 5
18:20:31 <lambdabot>   *Exception: Prelude.undefined
18:20:35 <dolio> That one wasn't.
18:21:18 <dolio> So, if all matches against tuples were irrefutable, and you didn't have seq, there'd be no way to tell the difference between _|_ and (_|_, _|_).
18:21:25 <ddarius> All monads in Haskell can be factored into adjoints not going through "Hask" and most adjoints don't go through Set.
18:21:42 <Kaidelong> hmm so what ~ does there is make it so that if the match fails, bottom only arises if the stuff bound to the pattern is actually used on the right side?
18:21:56 <kmc> it makes it so the match *never* fails
18:22:03 <kmc> but otherwise what you said is true
18:22:16 <kmc> > case Nothing of ~(Just _) -> ()
18:22:17 <lambdabot>   ()
18:22:17 <cmccann> Kaidelong, it binds the identifiers preemptively, but doesn't actually inspect the value until the things bound are forced
18:22:43 <dolio> x and y will both be undefined in the irrefutable match.
18:23:08 <dolio> > case undefined of ~(x, y) -> [1,2,3,4,x,y]
18:23:08 <lambdabot>   [1,2,3,4,*Exception: Prelude.undefined
18:23:24 <applicative> 'most adjoint functors' is a palpable pseudoconcept
18:24:17 * cmccann thinks "most adjoint functors" there sounds like "most numbers" in "most numbers aren't rational"
18:24:31 * applicative agrees
18:24:46 <Eduard_Munteanu> Hrm, what's a meaning of size for categories? Having faithful (or injective?) functors from one to another?
18:25:43 * brisingr goes to sleep; see you later today
18:25:48 <ddarius> Eduard_Munteanu: There is the general notion of subobject which is just an equivalence class of monomorphisms which can be applied in Cat which would give an equivalence class of inclusion functors.
18:25:58 <Eduard_Munteanu> brisingr: g'night
18:26:07 <brisingr> thanks
18:26:12 <brisingr> you too (later)
18:26:28 <ddarius> There is probably a better (i.e. 2-categorical) notion that would be more appropriate for categories.
18:26:38 <applicative> Is IO is interpreted as RealWorld -> (RealWorld, _) it might be said to arise from an 'adjunction in hask'; otherwise ?
18:27:06 <Eduard_Munteanu> ddarius: ok, so you're saying the sets/functions intuition that A < B iff there's an injective f : A -> B doesn't really hold?
18:27:20 <Eduard_Munteanu> erm, hold for categories
18:27:21 <applicative> an injection means: is no smaller than
18:27:22 <ddarius> Eduard_Munteanu: No, I'm saying it does.
18:27:36 <Eduard_Munteanu> Oh, right monos in Cat.
18:27:51 <Eduard_Munteanu> Those would be injective functors I guess.
18:28:45 <Eduard_Munteanu> (on both objects and arrows, but I'm not sure)
18:28:51 <applicative> but the 'usual notion of size' is big / small , locally small etc
18:29:03 <Eduard_Munteanu> Yeah, I know that one.
18:32:29 <Eduard_Munteanu> dolio: btw, Agd (?) is a category, right?
18:32:44 <dolio> Yes.
18:33:28 <dolio> As long as you only count Agda terms that pass the termination checker, and there aren't any holes in the type system.
18:33:39 <Eduard_Munteanu> Still, I'm not sure how easy it is to represent arbitrary categories in Agda or Haskell, like Set, e.g. to speak of such adjunctions
18:33:47 <Eduard_Munteanu> Yeah.
18:33:48 * cmccann postulates a bunch of imported Haskell functions
18:34:00 <dolio> Actually, even then it probably would be okay.
18:34:20 <dolio> Importing seq from Haskell would be a no-no, though.
18:34:34 <cmccann> heh
18:36:46 <dolio> If Agda is in fact total, though, seq would be no different than '\x y -> y' as far as one would care for categories.
18:37:01 <cmccann> postulate unsafePerformIO : {A : Set} → IO A → A
18:37:11 <dolio> In Haskell, representing arbitrary categories is awful.
18:38:07 <dolio> Agda is rather better at it.
18:38:22 <Eduard_Munteanu> When I did it, I pretended Set was in fact Set :)
18:38:32 <Eduard_Munteanu> But otherwise I'm at loss.
18:39:07 <dolio> That's why edwardk goes on with his not-really-categories and not-really-monads and so on. Because Haskell is deficient for talking about categories that aren't almost Hask.
18:39:12 <Eduard_Munteanu> Do you have to postulate them somehow?
18:39:43 <edwardk> semigroupoids are easier to talk about in haskell
18:40:06 * Eduard_Munteanu guesses Hask is at least a proper semigroupoid
18:40:06 <dolio> No, you can just define a record type that is the signature for a category.
18:40:09 <ddarius> Magmoids are even easier.
18:40:18 <edwardk> ddarius: =)
18:40:29 <ion> Magmoids are like chili burritos.
18:40:38 <Eduard_Munteanu> Hot? :)
18:40:44 <edwardk> spicy chili burritos
18:40:56 * ddarius wishes he could find cheap frozen burritos.
18:41:06 <dolio> They have a type of objects, a family of arrow types, a family of identities, and a family of composition operators, all of which satisfy certain laws.
18:41:10 <kmc> applicative, RealWorld -> (a, RealWorld) is a totally inadequate model for IO a
18:41:17 <edwardk> amy has taken to buying these evol burrito things that are pretty good
18:41:56 <Eduard_Munteanu> dolio: do you mean like copumpkin's stuff? Yeah, I did that, but how do you actually talk about Set in particular?
18:42:17 <dolio> You mean Agda's Set? That fits the signature.
18:42:24 <ion> edward: Can you compose them with each other, getting a result from one in the middle?
18:42:33 <Eduard_Munteanu> dolio: no, Set the category.
18:42:35 <ddarius> dolio: With universe polymorphism.
18:43:00 <dolio> If you want to talk about ZF or something, that's another matter.
18:43:07 <dolio> But why would you?
18:43:25 <ddarius> Talk about IZF instead.
18:43:28 <Eduard_Munteanu> So I have a record type parametrized or containing the type of objects, of Hom, of composition etc.
18:43:43 <ddarius> edwardk: I finished your book by the way.
18:43:54 <edwardk> as bad as you hoped?
18:44:00 <Eduard_Munteanu> But to actually provide a value for that that corresponds to Set or Pos or something that's not in Agda... :/
18:44:03 <applicative> not too surprising that an implementation of a type theory expressly intended to capture categories (inter alia) should be better at capturing arbitrary categories
18:44:03 <ion> What book?
18:44:04 <ddarius> edwardk: It was what I was looking for.
18:44:05 <dolio> There are lots of categories definable in Agda that aren't its Set, though, and which aren't very well (or at all) definable in Haskell.
18:44:24 <edwardk> ion: he was looking for some old sword and planet era fiction, so i loaned him burroughs
18:44:29 <ddarius> applicative: I'm not aware of any of those.
18:44:31 <ion> Ah, ok
18:44:39 <applicative> any of those what's
18:44:43 <ion> I thought you had written a book. :-)
18:44:47 <dolio> Like the natural numbers with ordering as arrows.
18:44:54 <ddarius> "a type theory expressly intended to capture categories"
18:45:03 <Eduard_Munteanu> dolio: then it isn't much easier to explicitly talk about adjunctions going out of Hask, is it?
18:45:06 <Eduard_Munteanu> or Agd.
18:45:11 <applicative> martin lof says that is his purpose on page one of the bibliopolis book
18:45:12 <edwardk> i have a chapter or two of a haskell book, but thats about it
18:45:26 <dolio> Why wouldn't you be able to talk about them?
18:45:28 <ion> Is C the category of C++?
18:45:31 <Eduard_Munteanu> ddarius: intuitionistic ZF?
18:45:50 * hackagebot HROOT 0.6.0.0 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.6.0.0 (IanWooKim)
18:45:58 <edwardk> nah, neither C nor C++ is a proper subcategory of the other
18:46:49 <Eduard_Munteanu> dolio: at some point I expect you do have to mention the real Set, if that's what your adjunction references, no?
18:46:54 <applicative> ddarius no, page 2 of the bibliopolis book.
18:47:03 <ion> (with Hask and Agd and PH)
18:47:17 <dolio> What's a real Set?
18:47:24 <applicative> he says that set theory is a crock, 1. because it cant represent categories properly; 2. because it isn't a programming language
18:47:26 <Eduard_Munteanu> Set, the category.
18:48:03 <dolio> There isn't even just one of those.
18:48:20 <dolio> Depending on your perspective.
18:48:26 <applicative> ddarius, thus I was saying, it isn't surprising that a programming language meant to capture categories, does etc.
18:48:27 <Eduard_Munteanu> So say you want to talk about F -| G, F : Agd -> Set, G : Set -> Agd
18:49:07 <dolio> Why would I even be talking about some classical set theoretic Set?
18:49:22 <Eduard_Munteanu> edwardk: did you write a book?
18:49:34 <ddarius> applicative: Saying you are describing a theory that does not fall afoul one problem in representing the semantics of categories is far from saying that you are describing a theory expressly intended to capture categories.
18:49:57 <edwardk> Eduard_Munteanu: the book in question was some 1930s fantasy novel i loaned him because he was looking for some campy old fiction
18:50:05 <Eduard_Munteanu> Oh, heh.
18:50:11 <applicative> if his symbolism hadn't done it, he would have rejected it, this is totally clear historically
18:50:36 <edwardk> Eduard_Munteanu: I was asked a year or so ago by a publishing company if I wanted to write a book, but it never really came together
18:50:37 <Eduard_Munteanu> dolio: not Set in particular, but I imagine there are useful adjunctions going through categories "larger" than Agda's.
18:51:06 <dolio> Well, I suspect you're mistaken in that.
18:51:29 <applicative> ddarius, he no doubt thinks categories are catatonically dull, but he certainly intended an all embracing 'foundation' - and a programming language
18:51:32 <dolio> You don't expect most adjunctions about Set to go through something larger than Set, do you?
18:51:43 <dolio> Or, lots of....
18:51:46 <ddarius> applicative: I can agree with the latter part of that.
18:52:44 <dolio> And something like Agda isn't terrible as a foundational system.
18:52:55 <dolio> (Probably not Agda, but something similar.)
18:53:05 <ddarius> dolio: Where "something like Agda" is something that actually has semantics.
18:53:12 <dolio> Yeah.
18:53:33 <Eduard_Munteanu> I see... so when you said not all (useful) adjunctions go through Hask, you meant they go through other categories that are in a sense "smaller" than Hask.
18:53:51 <dolio> Not necessarily smaller.
18:53:54 <dolio> Just not Hask.
18:54:24 <dolio> For instance, the adjunction for Cont r goes through Hask^op.
18:54:31 <dolio> You can actually do that one in Haskell.
18:54:40 <kmc> so i installed GHC 7.2 and cabal-install in a prefix... how do i tel that cabal-install not to screw with ~/.cabal ?
18:54:40 <Eduard_Munteanu> Oh, hm.
18:54:49 <applicative> can the Identity monad arise from different adjunctions?
18:55:36 <edwardk> sure you can also wander off to the kleisli or eilenberg moore category for it for instance
18:55:36 <ddarius> Depends on your notion of "different"
18:55:50 <ddarius> edwardk: The Kleisli category wouldn't be different.
18:55:59 <ddarius> But the Eilenberg-Moore category would.
18:56:00 <dolio> And for every monad M on C, there is an adjunction between the category of M-algebras and C that gives rise to M.
18:56:05 <edwardk> point
18:56:16 <dolio> But encoding that in Haskell isn't going to be very nice, I expect.
18:56:31 <dolio> Actually, even that may be possible in GHC.
18:56:46 <kmc> i'd like to play with GHC 7.2 features on certain projects but keep everything else using my existing install of GHC 7.0 from Haskell Platform
18:56:48 <dolio> Actually, I take that bad, no.
18:56:56 <dolio> Take it back, even.
18:56:58 <applicative> is see, this is more information, about 'M-algebras', what does that look like
18:57:14 <applicative> i mean in Haskellese
18:57:16 <Eduard_Munteanu> BTW, is there any online reference for how Haskell monads decompose into adjunctions?
18:57:31 <Eduard_Munteanu> I could only find something ddarius wrote in TMR, IIRC.
18:57:41 <dolio> I'm sure there's a catsters video on it.
18:58:02 <Eduard_Munteanu> I see.
18:58:03 <applicative> dolio, he meant familiar Haskell monads
18:58:22 <applicative> catster video XXIV:  What adjunction does IO arise from
18:59:13 <dylukes> I propose the category MonadMindFuck, where objects are stages of understanding, and arrows are metaphors for monads. Can we use confluence to prove everyone will eventually, given enough time and metaphors, understand Monads?
18:59:37 <dylukes> (regardless of the specific ordering of metaphors)
19:00:15 <monochrom> more metaphors is less understanding
19:00:17 <Eduard_Munteanu> And decompositions aren't unique, aren't they?
19:00:29 <Eduard_Munteanu> Erm, I guess that relates to applicative's question.
19:00:56 <Saizan> kmc: stuff from different versions of ghc won't clash in ~/.cabal/ by default, except haddock generated for docs
19:01:01 <ddarius> edwardk: Where does Amy get her burritos?
19:01:14 <ddarius> Eduard_Munteanu: No.
19:01:18 <ddarius> Eduard_Munteanu: They are not.
19:01:32 <edwardk> stop n shop
19:01:44 <Saizan> *except for haddock generated docs
19:01:54 <kmc> Saizan, it put a binary in ~/.cabal/bin
19:01:57 <ddarius> edwardk: Okay.  I think I did actually see some there.  My only annoyance is that they only come in individual packs.
19:02:11 <edwardk> yeah but they are some semblance of real food
19:02:36 <ddarius> Yes, yes, but I'm looking for cheap burritos which are no semblance of real food.
19:03:03 <edwardk> ah
19:03:15 <ddarius> That said, I'll give a few of those a try.
19:03:20 <dolio> Eduard_Munteanu: There is a category of decompositions of monads into adjunctions.
19:03:33 <applicative> what are the arrows??
19:03:56 <ddarius> Look up the Eilenberg-Moore comparison functor.
19:04:29 <ddarius> In the category dolio mentions, the Kleisli category is the initial object and the Eilenberg-Moore category is the final object.
19:05:38 <dolio> I can never remember which is initial and which is final.
19:06:52 <seafood_> What's the status of GHC 7.2.1 on Mac OS X Lion?
19:07:03 <zzo38> How many Haskell programs are there that are using Template Haskell?
19:07:09 <ddarius> dolio: I remember it because you can embed the Kleisli category into the Eilenberg-Moore category
19:07:12 <Eduard_Munteanu> So I guess what's important for Haskell's use of monads is they're endofunctors with those natural transformations.
19:07:21 <Eduard_Munteanu> Less so the actual adjunction, right?
19:07:49 <ddarius> Obviously.
19:08:00 <ddarius> You can talk about monads without talking about adjunctions.
19:08:07 <dankna> seafood_: I believe it works, we wound up going with the llvm-gcc temporary solution instead of the real fix
19:08:09 <applicative> seafood_ I don't think anyone worries about it independently from the haskell platform.
19:08:16 <ddarius> It was, in fact, a bit of time before the connection between monads and adjunctions was fully worked out.
19:08:24 <Eduard_Munteanu> Oh.
19:09:14 <seafood_> dankna: What's the llvm-gcc fix?
19:10:43 <Eduard_Munteanu> However, is the decomposition unique *up to isomorphism* at least?
19:10:50 <ddarius> No.
19:10:56 <thoughtpolice> seafood_: manuel made configure automatically detect gcc-4.2 as the compiler (as opposed to 'gcc') if you're using xcode >= 4
19:11:01 <Eduard_Munteanu> Hm, interesting.
19:11:17 <thoughtpolice> seafood_: in xcode for lion etc, gcc is actually a symlink to llvm-gcc
19:11:31 <thoughtpolice> gcc-4.2 is the real compiler GHC needs, since it has certain required features
19:14:00 <applicative> but a better fix would use llvm-gcc?
19:27:12 <copumpkin> Eduard_Munteanu: lots of haskell's monads leave hask
19:27:13 <augur> edwardk!
19:27:23 <edwardk> ?
19:27:41 <augur> did you get me message?
19:27:50 <edwardk> message?
19:27:52 <augur> maybe i never sent it to lambdabot. i dont even remember
19:27:55 <ddarius> copumpkin: You need to rephrase that statement.
19:28:00 <augur> i !told you something
19:28:02 <edwardk> guessing not
19:28:05 <augur> :D
19:28:14 <augur> incoming!
19:28:22 <ddarius> !tell doesn't do anything for lambdabot
19:28:31 <copumpkin> ddarius: lots of haskell's monads arise from compositions of adjoint functor pairs where one of the categories is not hask
19:28:34 <copumpkin> better?
19:28:38 <ddarius> copumpkin: Yes.
19:28:40 <edwardk> well, fortunately you are here now and can deliver it in person, via a half dozen irc server intermediaries
19:28:49 <augur> ddarius: oh was it @tell?
19:28:57 <augur> i can never remember what these things are
19:28:57 <copumpkin> Eduard_Munteanu: scratch my original statement, replace with the one I ran by ddarius
19:29:09 <ddarius> copumpkin: Except, as I said earlier, all of them can be viewed as coming from compositions of adjoint functor pairs where one of the categories is not Hask.
19:30:02 <ddarius> Really, the important statement is that very few monads in Haskell factor as adjunctions only between Hask and itself.
19:32:31 <hpaste> djahandarie annotated “ClampEven is a monad on the order category of (<=)!” with “ClampEven is a monad on the order category of (<=)! (annotation)” at http://hpaste.org/50372#a50385
19:41:44 <kate_r> i have a rather simple logic question: can ((P <-> Q) & (R <-> S)) --> T be simplified?
19:42:42 <ddarius> kate_r: Why are you asking here?
19:43:19 <applicative> we have lots of -> 's here!
19:44:00 <monochrom> it can be simplified to T
19:44:08 <kate_r> ddarius, i just happened to be writing a simplifier for propositional logic.
19:44:24 <ddarius> kate_r: In Haskell?
19:44:31 <kate_r> ddarius, yeah
19:44:32 <monochrom> oh, unless you mean T to be another propositional variable
19:44:44 <kate_r> monochrom, yeah it is, P Q R S T are all propositional variables
19:44:45 <applicative> clearly they are all independent
19:44:48 <ddarius> kate_r: Define "simpler."
19:44:53 <monochrom> then no further simplification
19:45:57 <kate_r> ddarius, i mean to reduce the number of implications.
19:45:57 <applicative> if each propositional variable appears only once, then how can it be simpler, unless say we think of <-> as decomposing into -> and &
19:46:13 <ddarius> kate_r: You can always rewrite to conjuctive normal form and have no implications.
19:46:56 <Eduard_Munteanu> I see.
19:47:18 <kate_r> yeah, i guess i could...
19:47:30 <kate_r> ok. thanks!
19:47:38 <monochrom> eliminating implications is usually worse, as in both longer and more obfuscating
19:47:39 <applicative> so 'fewer ->'s ' isn't the whole story?
19:47:40 <ddarius> Doing so risks a potentially exponential increase in the size of the term.
19:48:05 <applicative> kate_r: bring back your module when you finish it, it sounds like fun
19:48:42 <kate_r> applicative, ha.. yeah, if i can get my head around it!
19:48:48 <kate_r> ok. thanks guys
19:48:54 <applicative> well, good luck
19:57:52 * applicative cant get djahandarie
19:58:11 <applicative> s refl meditations to compile
19:58:25 <djahandarie> The annotation should work
19:58:36 <djahandarie> Works for me on 7.0.3 at least
20:00:12 <applicative> djahandarie: oh, the second one is working on 7.0 and 7.2
20:00:18 <djahandarie> :)
20:00:39 <djahandarie> First one requires me to either have a stroke of brilliance or fix a GHC bug
20:01:02 <djahandarie> (Well, the latter probably requires the first...)
20:01:20 <ion> a stroke or/of brilliance
20:01:23 <applicative> "Cannot deal with a type function under a forall type:" is already to too much for me....
20:01:32 <djahandarie> Yeah, that's the problem
20:02:00 <djahandarie> It should be possible now due to some underlying machinery being fixed, but that issue in particular hasn't been looked at
20:03:36 <sebz> is it not possible to use ($) in patterns?
20:03:46 <kmc> nope
20:03:51 <kmc> ($) is an ordinary function
20:03:58 <kmc> @src ($)
20:03:58 <lambdabot> f $ x = f x
20:04:00 <djahandarie> applicative, I actually have a cleaner version of the Refl meditation at work, but I didn't put it anywhere
20:04:08 <djahandarie> And don't feel like redoing it (I hate redoing things)
20:04:12 <sebz> is there something like it to reduce parentheses?
20:04:18 <kmc> no
20:04:19 <EvilMachine> why is it so incredibly hard to just do this: zeroPlusMinus = regexReplace "\\+(0+([.:]0+)?)$" "±\1"
20:04:25 <sebz> kmc: ok, thanks
20:04:27 <djahandarie> Mainly by using a data family and reusing inductNat
20:04:36 <EvilMachine> i couldn’t find a regexReplace. let alone for PCRE
20:05:24 <ddarius> EvilMachine: Worst-case scenario, you should be able to get the groups and reconstruct the string with your replacement.
20:05:29 <EvilMachine> matching: no problem. replacing: seems to be a huge taboo.
20:05:31 <ddarius> There is probably a library that does this.
20:06:00 <EvilMachine> ddarius, yes. but come on, this is Haskell! it is not acceptable that PHP beats us at this! ^^
20:06:55 <EvilMachine> ddarius: probably. but where? i'm searching the web for more than an hour straight the second time today.
20:07:21 <EvilMachine> (i searchED. i have enough now! ^^)
20:07:33 <aavogt> EvilMachine: when I looked into that a while ago it looked like a replace existed in a previous version (3 years ago?) of the current regex libraries
20:07:50 <kmc> yeah, regex support in Haskell is unusually bad
20:07:59 <kmc> the overloaded (=~) operator is just an abomination
20:08:10 <kmc> and beyond that there's a big tangle of libraries
20:08:14 <kmc> and no clear guidance on which to use
20:08:14 <applicative> sebz, it's annoying but basically you have to write it out so the compiler can recognize the constructors etc.
20:08:28 <kmc> people say "use Parsec, don't use regex"
20:08:36 <kmc> which is good advice at a certain scale
20:08:43 <EvilMachine> aavogt, so it’s removed?
20:08:48 <kmc> the threshold for writing a "real" parser *is* a lot lower in Haskell
20:09:02 <kmc> but i think there's still a niche for regex
20:09:08 <applicative> it's stunning that they don't have replace, any of them.
20:09:15 <pikhq> kmc: I get the distinct impression that the regex libraries end up coming from Perl, where regex is *the way*.
20:09:25 <edwardk> kmc: it was a misguided exploration of whether or not we could get the same magic as perl's regex API. sadly we can, but its not worth the price
20:09:30 <EvilMachine> kmc, ok. why not. can you tell me: how would i do my example above in parsec ... using just one short line?
20:09:36 <cmccann> kmc, you don't think that overloading a two-character operator to do dramatically different things based on the inferred return type is a good idea? can't imagine why
20:09:41 <kmc> what's the example EvilMachine?
20:09:43 <kmc> sorry, i missed it
20:09:48 <sebz> applicative: yeah, I was hopeful because of sugar like "where (x,y) = …"
20:10:14 * roconnor 's respect for regular expressions has gone up sigficantly in the last few weeks.
20:10:16 <kmc> sebz, (,) is a data constructor
20:10:35 <ddarius> If only we had Haskerl.
20:11:00 <applicative> sebz's remark can be read differently.
20:11:07 <EvilMachine> pikhq, yes. PCRE is really neat for your quick scripts. and it happens that i want to use Haskell for my scripts too. so often it's throwaway code.
20:11:25 <kmc> i wonder if anyone would use a Haskell regex library where regexes are represented not by strings but by an actual EDSL
20:11:30 <kmc> it could have some advantages
20:11:33 <ddarius> @where haskerl
20:11:34 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
20:11:38 <ddarius> (Polymorphic regexen.)
20:11:41 <EvilMachine> edwardk, maybe. ;)
20:11:51 <EvilMachine> kmc:  zeroPlusMinus = regexReplace "\\+(0+([.:]0+)?)$" "±\1"
20:12:13 <cmccann> kmc, I think that might conflict with the desire to write incomprehensible one-liner regexps, since the EDSL would probably be a bit more verbose
20:12:20 <kmc> yeah
20:12:34 <pikhq> cmccann: I don't see how that's a problem.
20:12:53 <kmc> i don't think this EDSL would differ substantially from, say, Parsec
20:13:08 <cmccann> I think the least horrible way to provide "normal" regexps in Haskell would be as a quasiquoter honestly
20:13:10 <EvilMachine> kmc: EDSL? Edsel? (sorry, I don’t know it. ;)
20:13:20 <kmc> embedded domian-specific language
20:13:22 <cmccann> you could parse and check for sanity at compile time
20:13:25 <kmc> Applicative and Alternative already give you juxtaposition, alternatives, and repetition
20:13:28 <cmccann> and then spit out non-magic code to do what the regexp says
20:13:33 <pikhq> cmccann: Win.
20:13:33 <kmc> which describes all of a "pure" regex
20:13:34 <kmc> yeah
20:13:44 <kmc> anyway
20:13:52 <kmc> EvilMachine, i don't think that will look nicer in Parsec
20:13:57 <cmccann> actually, a quasiquoter to turn normal regexps into kmc's hypothetical EDSL would probably be ideal
20:14:03 <kmc> or just into Parsec
20:14:04 <cmccann> so that the generated version is still usable
20:14:04 <EvilMachine> cmccann, yeah, the idea is: if it's incomprehensible, you should probably use a real parser. but short regexes aren't incomprehensible at all to the trained user. :)
20:14:07 <cmccann> for people who don't like TH
20:14:08 <Saizan> parsec doesn't have a replace either
20:14:54 <cmccann> kmc, I'd entertain the notion that a regexp-specific EDSL might be tidier than using something like parsec if designed well
20:14:54 <kmc> you could use trifecta :)
20:14:58 <EvilMachine> kmc, lol.
20:15:07 <edwardk> hah
20:15:08 <cmccann> but I'm not certain
20:15:23 <kmc> find-replace should be easy in trifecta, right?
20:15:44 <edwardk> sure, just highlight the resulting range in the interval map, then cut and paste in the rope
20:15:50 <edwardk> comes free
20:16:01 <aavogt> kmc: regex libraries do more efficient string searches (say on Arrays) than your hand-written parsec code, right?
20:16:09 <kmc> probably
20:16:11 <edwardk> sadly, that would actually work
20:16:18 <EvilMachine> ok, how do you guys do a bit more complex text replacement *right now*? because you definitely need that, don’t you?
20:16:29 <EvilMachine> i mean the quick line
20:16:29 * Saizan doesn't
20:16:40 <EvilMachine> not writing for 2 hours to do a one-time replacement
20:17:05 <Saizan> shell out to perl?
20:17:06 <pikhq> EvilMachine: Quite honestly, when I'm doing text munging I tend to drop to Tcl.
20:17:18 <edwardk> thats what i have perl for
20:17:32 <pikhq> (as opposed to actual text parsing and manipulation, which Haskell is *ideal* for)
20:17:43 <cmccann> I just use list functions on [Char] for stupidly simple things
20:18:06 <EvilMachine> And if you can’t come up with something elegant, I will start a php sub-process from my haskell and tell *it* to do the preg_replace. it will be the ultimate disgrace! muhahahahaha! ;))
20:18:37 <aavogt> re. better typed regex: https://github.com/mgsloan/rex
20:18:47 <Saizan> shall we remind you of the evil mangler?:)
20:18:53 <cmccann> ahahahaha
20:18:56 <kmc> the evil mangler is dead!
20:18:56 <cmccann> Saizan, it's gone though
20:18:58 <mgsloan> aavogt: hrmm? :)
20:19:09 <cmccann> may it rot forever
20:19:36 <cmccann> aavogt, oh hey, someone already did what I suggested apparently
20:19:37 <EvilMachine> pikhq, actual text parsing… i just want to repace the "+" in front of a number that is zero with a "±". that is all. and since the number can be any of "\\+(0+([.:]0+)?)$"... what would you do in my place? :(
20:19:42 <cmccann> that's always convenient
20:20:07 <EvilMachine> what was the evil mangler?
20:20:11 <edwardk> EvilMachine: i'd use the pcre bindings and tell it to do just that
20:20:20 <aavogt> mgsloan: it's not exactly the search-and-replace that was requested originally, but it could make that a bit less error-prone
20:20:34 <mgsloan> funny that I joined just now, glad to see that people know about it!
20:20:38 <edwardk> we have 3 sets of bindings to pcre
20:20:43 <edwardk> (at least)
20:20:56 <mgsloan> mine also invokes PCRE at compile time and stores its compiled rep
20:20:57 <edwardk> a half dozen other regex implementations
20:21:01 <cmccann> mgsloan, there were complaints about the state of regexps in Haskell and I proposed a quasiquoter as the least terrible approach
20:21:03 <EvilMachine> edwardk, how exactly? the bindings have to replace function. at least i didn’t see one here:http://hackage.haskell.org/package/regex-pcre-0.94.2
20:21:15 <pikhq> EvilMachine: That looks like naive munging to me.
20:21:45 <Saizan> EvilMachine: the evil mangler was a horrible perl script used by ghc to mangle the assembly produced by gcc
20:22:00 <aavogt> cmccann: some people might write their regexps at runtime however
20:22:30 <kmc> the Evil Mangler was used for compiling Haskell via C, which was deprecated in GHC 7.0 and now (in 7.2) has been removed
20:22:44 <kmc> (except in the "unregisterized" variant, which never used the EM)
20:22:47 <cmccann> aavogt, in which case other means would be required
20:22:53 <shachaf> Is the unregisterized variant still around?
20:22:57 <kmc> yes
20:22:57 <Polarina> What is the difference between the binary and ghc-binary packages? I need to put either into my cabal file as a dependency.
20:23:01 <thoughtpolice> yes, you still need it for porting
20:23:02 <mgsloan> cmccann - well, glad to provide it.  a PCRE.QQ already existed but it didn't do pattern matching
20:23:10 <edwardk> good question actually
20:23:10 <kmc> in before "LLVM should make porting trivial, lol"
20:23:11 <EvilMachine> You should have answered: It was evil! It was *so* evil! It was a bad, bad script that hurt many programs that are *good*. I think it's *great*, because it's so *bad*! ;)
20:23:16 <thoughtpolice> Polarina: tl;dr do not depend on ghc-binary.
20:23:19 <thoughtpolice> kmc: lol
20:23:22 <mgsloan> (not sure if view patterns even existed back when PCRE.QQ came about, though)
20:24:05 <EvilMachine> pikhq, naive munging? how about instead of constantly telling me how bad it is, you all suggest even a single viable solution? :(
20:24:22 <thoughtpolice> Polarina: it's *supposed* to be a private package that GHC does not expose, but for some reason it is. GHC depends on binary but it uses a lagging version, so they call it 'ghc-binary' - everyone else however should just depend on 'binary'
20:24:35 <cmccann> EvilMachine, did you look at mgsloan's package that was mentioned a bit ago?
20:25:19 <pikhq> EvilMachine: You should consider whether or not you are solving the right problem first. After that, then I'd say "use regexp replacement", and lament that there's no sane way of doing so in Haskell.
20:25:36 <edwardk> http://hackage.haskell.org/packages/archive/regex-compat/0.92/doc/html/Text-Regex.html#v:subRegex
20:25:51 <EvilMachine> ccasin, the comment didn’t suggest it was a solution. it just said "better typed regex". so i didn’t know. it. but thanks for the hint. i
20:25:58 <EvilMachine> -it. -i
20:26:02 <kmc> edwardk, that looks sane
20:26:08 <cmccann> EvilMachine, I'm not sure if it helps or not, just wondering
20:26:52 <mgsloan> actually, rex probably wouldn't be so great for the replacement case, or at least, this just does matching + post-processing into well typed tuple-elements
20:27:02 <cmccann> ah, ok then
20:27:39 <EvilMachine> pikhq, well, it is just a visual thing. in the output, i want all numbers that are zero to have a ± in front instead of a +, since they are tolerances.
20:28:03 <EvilMachine> pikhq, but the numbers can contain a point or even be times.
20:28:21 <ddarius> subRegex does the "match into groups then stick back together" that I mentioned earlier.
20:28:24 <mgsloan> it would be very very easy to write a quasiquoter that just yieleded a plain Regex object, which you could then use with subRegex
20:29:14 <EvilMachine> ddarius, so I will have to try subRegex… OK. So no PCRE... :(
20:29:14 <mgsloan> it might be useful to write something like subRegex, but with a function mapping the captures to a string to be substituted
20:29:42 <EvilMachine> mgsloan, no idea what a quasiquoter is, though…
20:30:10 <cmccann> EvilMachine, Template Haskell black magic. Call a function at compile time with a string argument and it spits out some sort of code
20:30:18 <sebz> one more question...
20:30:21 <djahandarie> How goes it mgsloan
20:30:29 <hpaste> sebz pasted “untitled” at http://hpaste.org/50387
20:30:41 <mgsloan> djahandarie - not bad! yourself? how was hac phi?
20:30:55 <sebz> can I write a function that will accept 2 types without using type classes?
20:30:58 <djahandarie> Good.... and great, I hacked on Agda Category Theory the whole time
20:31:11 <cmccann> sebz, have it take an Either type?
20:31:18 <djahandarie> And by me hacking on Agda Category Theory I mean watching xplat hack on Agda Category Theory since he's better at it
20:31:23 <EvilMachine> cmccann, to replace text in a regex? sorry, something is deeply wrong with this language, or with the way it's approached. not everyone wants to do TH black magic, just to replace a + by a ± in a number. :(
20:31:29 <Eduard_Munteanu> sebz: what type signature do you have in mind?
20:31:42 <edwardk> like this one? http://hackage.haskell.org/packages/archive/regexqq/latest/doc/html/src/Text-Regex-PCRE-QQ.html
20:31:43 <cmccann> EvilMachine, you don't need to know about the black magic, you can just use it
20:31:43 <EvilMachine> (and i really like haskell, so it means something when even i feel that something is deeply wrong)
20:32:03 <cmccann> it's just a funny syntax and requires turning on a GHC extension
20:32:11 <Eduard_Munteanu> Oh, your paste.
20:32:11 <sebz> Eduard_Munteanu: I guess it would be Either Integer N -> N
20:32:25 <edwardk> one of the many presents matt morrow left us before he wandered away
20:32:37 <EvilMachine> cmccann, it’s actually horrible that it has to use black magic for one of the most simple things one needs. that's like: hey, I wanna print a sting… oh, wait!
20:32:37 <ddarius> EvilMachine: You can just take the source code of subRegex.
20:32:38 <EvilMachine> LOL
20:33:07 <Eduard_Munteanu> sebz: that's going to be partial
20:33:10 <cmccann> EvilMachine, the purpose of black magic is to take the usual horrible regex syntax and check it for validity at compile time
20:33:22 <kmc> sebz, it would
20:33:24 <kmc> err
20:33:35 <cmccann> which is substantially less horrible than just putting a string in the code with no checking
20:33:38 <Eduard_Munteanu> Well, not partial.
20:33:45 <sebz> f would be partial?
20:33:46 <EvilMachine> you know, the camel’s back just broke. sorry guys. i don’t want to cause a big fuss here and rage all over the channel. i’m going to go destroy something pretty now… :(
20:33:46 <Eduard_Munteanu> But you have to pick an arbitrary N
20:33:55 <Eduard_Munteanu> in case you get a Left
20:34:27 <cmccann> EvilMachine, I really don't understand what you're even upset about, there are apparently plenty of ways to do what you want and you don't even need to use the TH stuff I mentioned
20:34:30 <Eduard_Munteanu> It's only partial if by N you mean a type variable, my mistake
20:34:34 <mgsloan> djahanderie: nice - hard to find such people to learn from.  I've been getting a little bit more knowledgeable in category theory but not so much in COQ or Agda unfortunately.  Google's been keeping me rather occupied
20:34:48 <sebz> yeah N is the type on line 1
20:35:07 <sebz> but I made a mistake with the signature, I meant [Either Integer N] -> N
20:35:14 <kmc> you can do that
20:35:23 <sebz> and I think it would be partial for []
20:35:40 <Eduard_Munteanu> Not even then as long as N is a concrete type.
20:35:49 <djahandarie> mgsloan, a whole summer school on Coq and you still don't know that it's not an acronym? ;)
20:35:51 * hackagebot HROOT 0.6.1 - Wrapper for ROOT  http://hackage.haskell.org/package/HROOT-0.6.1 (IanWooKim)
20:35:58 <Eduard_Munteanu> like in your definition
20:36:12 <sebz> but writing "f [Right a, Left 1, Right b]" isn't very compact, which is why I'm trying to write this
20:36:16 <Eduard_Munteanu> :t const 3
20:36:17 <lambdabot> forall t b. (Num t) => b -> t
20:36:25 <Eduard_Munteanu> :t const (3 :: Int)
20:36:26 <lambdabot> forall b. b -> Int
20:36:44 <mgsloan> EvilMachine - sorry to go complex on you, many like Haskell because it gives you powerful features and nifty tricks to play with, but you can certainly do whatever you need to do without using them.  There's the haskell98 rational subset, and its quite powerful
20:36:50 <sebz> partial means partial function right?
20:36:55 <mgsloan> we're quite attached to our clever tricks :)
20:36:57 <Eduard_Munteanu> Yes.
20:37:12 <kmc> sebz, Haskell isn't the right language for tweaking the syntax to be just exactly perfect
20:37:15 <cmccann> particularly clever tricks that allow more static checking that things make sense
20:37:26 <mgsloan> (not to say that >haskell98 isn't quite rational :) )
20:37:27 <mgsloan> aye
20:37:41 <kmc> sebz, but you can at least define a type with constructors shorter than "Right"
20:37:42 <mgsloan> erp double negative there
20:37:51 <kmc> sebz, where are these lists coming from?
20:37:54 <Eduard_Munteanu> sebz: don't you actually want   f :: Integer -> N?
20:38:07 <Eduard_Munteanu> erm... f :: [Integer] -> N
20:38:09 <kmc> if they're actually literals in your code, why not write a literal of type N to begin with
20:38:10 <EvilMachine> cmccann, i’m upset about the fact that to do a simple s/\\+(0+([.:]0+)?)$/±\1/ in one’s UI module’s number display helper function, one has to search for two hours to find *nothing*, then have some half-assed solutions like subReplace that don’t work for PCRE, and the only other "solutions" is to write what should be a core library function *yourself*' in essence it’s like telling me i would have to write the mu
20:38:11 <EvilMachine> ltiplication operator myself or use `bitmul` which multiplies arrays of bools as bits…
20:38:26 <sebz> Eduard_Munteanu: no, since a and b are of type N
20:38:29 <ddarius> mgsloan: There is nothing wrong with double negatives.
20:38:35 <Eduard_Munteanu> Oh.
20:38:37 <EvilMachine> sorry, i really have to go or i’m gonna rage so hard i’m gonna be banned. and i like it here. :(
20:38:51 <sebz> kmc: I'm trying to write an interpreter for some guy's language
20:38:53 <kmc> EvilMachine, i think your attitude is totally justified
20:38:59 <mgsloan> ddarius - true, in some logics they're a monad :)
20:39:20 <kmc> sebz, and so you're turning a flat list of symbols into a syntax tree?
20:40:10 <hpaste> sebz pasted “language” at http://hpaste.org/50388
20:40:39 <kmc> sebz, so you're writing a parser?
20:40:39 <EvilMachine> (my away message is way out of context here. ouch. don’t misunderstand it. :)
20:41:10 * ddarius doesn't know what EvilMachine's away message is.
20:41:22 <sebz> kmc: a parser is something that takes a string and gives an ast? then no
20:41:29 <kmc> what are you doing instead
20:42:00 <sebz> kmc: I want to give ghci some expression and have it evaluate it for me
20:42:01 <kmc> sebz, i have no idea what this "language" document means
20:42:09 <sebz> kmc: haha me neither
20:42:23 <kmc> sebz, a Haskell expression? or an expression in this language?
20:42:34 <sebz> kmc: an expression in this language represented as a value
20:42:35 <Eduard_Munteanu> I think he means an EDSL
20:42:47 <sebz> hold on I'll just post my whole thing
20:42:58 <kmc> but then you can't be too picky about syntax
20:43:24 <kmc> there's no reason to believe the syntax of your language is compatible with the syntax of Haskell
20:43:27 <hpaste> sebz pasted “unfinished interpreter” at http://hpaste.org/50389
20:44:03 * Eduard_Munteanu thinks mixfix operators are nice for such stuff, though Haskell doesn't have them
20:44:41 <kmc> sebz, i think you should write a parser
20:44:43 <sebz> so I'm trying to write line 32 in the spec (line 27 in the interpreter - or EDSL I guess?) without it being incomprehensible
20:44:53 <applicative> djahandarie: everyone knows CoQ is an acronym for Calculus of Qonstructions
20:44:53 <kmc> and pass the input as a string
20:45:15 <kmc> looks pretty much as incomprehensible as the document you pasted
20:45:46 <sebz> kmc: wouldn't I still have to write what I just wrote in order to evaluate stuff?
20:45:49 * mgsloan thinks operator precedence needs to be worked out better in the first place before mixfix happens
20:45:50 <kmc> yes
20:45:58 <EvilMachine> By the way: This video is my experience with Haskell, and this is the position i was at right now: http://www.youtube.com/watch?v=in6RZzdGki8#t=23m18s ;)
20:46:18 <kmc> sebz, if you actually want to introduce new Haskell syntax for patterns and expressions, you could usehttp://www.haskell.org/haskellwiki/Quasiquotation
20:46:22 <Eduard_Munteanu> EDSLs usually give you an approximate syntax.
20:46:38 <Eduard_Munteanu> And even then it might not be that easy to embed your language in Haskell.
20:46:46 <kmc> and people will play tricks with EDSL syntax
20:47:05 <kmc> corrupting things at a very deep layer (type system, semantics) in order to make them look nice at the superficial layer
20:47:09 <mgsloan> EvilMachine: I'm by no means an expert, but lemme try to write the function
20:47:10 <kmc> i don't approve
20:47:40 <EvilMachine> mgsloan: what would it be good for, now that I’m done with Haskell? ;)
20:47:41 <mgsloan> and I'll extend rex to do replacement at some point, just for kicks.
20:48:00 <mgsloan> (not try, only do)
20:48:17 <mgsloan> EvilMachine: oh you'll be back ;)
20:48:23 <mgsloan> it's that one girl
20:48:59 <EvilMachine> mgsloan: I’m coming back to the code tomorrow, to see if i want to. but honestly. if i do, i’ll do that PHP invocation disgrace. ;)
20:49:06 <sebz> kmc: that looks useful, though my purposes are modest enough that it would be overkill
20:49:21 <Eduard_Munteanu> mgsloan: there are some inconveniences as well, at least in Agda's implementation... e.g. you can't write (a, b), but (a , b)
20:49:42 <EvilMachine> mgsloan: that one girl? well, this is big-time OT, but: that’s called one-itis. and the cure is FTOG (fuck ten other girls) (or rather programming languages. ;)
20:50:05 <EvilMachine> mgsloan: (works for men too, if there are any girls here. ;)
20:50:07 * cmccann complains that agda isn't flexible enough, since you can't rebind built-in syntax or redefine the juxtaposition operator
20:50:15 <Eduard_Munteanu> I wonder if it's reasonable to do some best-effort parsing and lexing and just tell the programmer when something is ambiguous.
20:50:22 <kmc> classy
20:51:03 <EvilMachine> ccasin: can you rebind "=" in haskell? ^^
20:51:04 <kmc> sebz, yeah, i agree
20:51:14 <EvilMachine> oops
20:51:15 <sebz> I think I'll try the class approach
20:51:16 <kmc> i thought you were done EvilMachine
20:51:26 <EvilMachine> cmccann: can you rebind "=" in haskell? ^^
20:51:37 <cmccann> EvilMachine, alas no
20:51:53 <cmccann> which really spoiled some of the fun of augustss's BASIC EDSL
20:52:05 <aavogt> you can rebind    <-   in do-notation, which might be close enough
20:52:05 <mgsloan> http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html there's something to be said for multi-language development
20:52:14 <EvilMachine> kmc: yes. ok, maybe i was just doing a bit of teasing, which is not nice. i’ll stop. :)
20:52:26 <mgsloan> (just in case you hadn't seen)
20:52:35 <Eduard_Munteanu> Well, maybe, just maybe there is a Unicode =-lookalike... :P
20:52:58 <sebz> can a class and a type share a name?
20:53:01 * cmccann would still actually like rebindable whitespace in some limited contexts
20:53:05 <EvilMachine> Eduard_Munteanu: how about = ≈ ≠
20:53:05 <kmc> sebz, don't think so
20:53:26 * ddarius is actually not aware of any language off the top of his head where you can rebind = except ones that don't use it like Lisp.
20:53:43 <kmc> C++
20:53:48 <Eduard_Munteanu> Can you rebind parens in Lisp? :)
20:54:08 <ddarius> kmc: Good point.
20:54:17 <ddarius> You're still somewhat limited though.
20:54:20 <c_wraith> djahandarie: after playing with it a bit, I think there really is a GHC bug, and it is, in fact, the one dolio reported that I linked to earlier.  There are just some cases where GHC refuses to unify types with explicit foralls with types that don't have the explicit foralls.
20:54:28 <kmc> C++: the ultimate counterexample
20:54:44 <kmc> ddarius, somewhat
20:54:46 <Eduard_Munteanu> Yeah, it's got arbitrary operator overloading
20:54:52 <kmc> but (x = y) is an expression, not a statement
20:55:00 <kmc> Eduard_Munteanu, not really arbitrary
20:55:02 <cmccann> C++ gives you all the tools you need to tackle the problems created by C++ programmers
20:55:03 <ddarius> It's an expression in C too.
20:55:06 <Eduard_Munteanu> Erm, I mean, the list of overloadable operators is arbitrary.
20:55:12 <kmc> oh, heh
20:55:15 <edwardk> Eduard_Munteanu: depends on the lisp
20:55:44 <liyang> Anyone coming to ICFP?
20:56:07 <mgsloan> it'd be cool to see a haskell language pre-processor/frontend use haskell tokenization + indentation rules, with mixfix operators, where precedence is resolved by  some partial order orso.
20:56:39 <Eduard_Munteanu> The question is... how do we make precedence less fragile?
20:56:41 <liyang> (In which case you may be interested in a hackathon: http://haskell.org/haskellwiki/HakkuTaikai )
20:56:45 <edwardk> mgsloan: that is called agda
20:56:56 <kmc> mgsloan, would you require spaces between all tokens, as in Agda?
20:56:57 <EvilMachine> cmccann: actually, a couple of hours ago, I compared C++ 0x to Windows ME. The upside-down pyramid of slapped-on features that just waits to fall over. ;)
20:57:19 <edwardk> i dont find the spaces in agda to be that bad
20:57:24 <mgsloan> kmc - nah, just don't allow operators to intermix alphanumerics
20:57:26 <edwardk> they just become an element of style
20:57:27 <kmc> or restrict each name to one lexical class (alphanum, symbol) so that you can continue lexing as is
20:57:29 <kmc> *nod*
20:57:52 <edwardk> kmc: but then you can't have +_foo as an operator =)
20:57:53 <Eduard_Munteanu> I'd just like it to be best-effort.
20:58:23 <Eduard_Munteanu> As in, try to parse, but give up if there's ambiguity... e.g. most instances of (a, b) would be parsable.
20:58:55 <cmccann> just have it try and find any consistent interpretation based on whatever's currently in scope
20:58:58 <mgsloan> edwardk - syntactically, yes, if someone makes a strongly typed zero-effort Haskell FFI for Agda, /then/ I'm very interesting.
20:58:59 <Eduard_Munteanu> So if you define _,_ it's ok, but if you also make an a,_ then give up
20:59:07 <cmccann> determining what's in scope before you parse is left as an exercise for the reader
20:59:08 <dolio> Agda's precedence isn't specified by a partial order.
20:59:15 <mgsloan> why hasn't someone written a Agda <-> Haskell bridge, come to think of it?
20:59:30 <ddarius> Agda has a Haskell FFI.
20:59:35 <cmccann> mgsloan, more automation for it, you mean?
20:59:36 <edwardk> mgsloan: i spent a few hours on building a dependently typed quasiquoted language at hac phi, but then got distracted by hash consing
20:59:38 <Eduard_Munteanu> And a C FFI
20:59:58 <Eduard_Munteanu> Now, there's no automation to writing the bindings, but still.
21:00:16 * ddarius doesn't know what Baez was thinking of filming a talk involving a whiteboard at low resolution.
21:00:20 <ddarius> s/know/no
21:00:36 <mgsloan> edwardk - hehe, excellent.  At some point I hope to write something for nesting quasiquoters
21:00:59 <Saizan> edwardk: the hash-consing was for the typechecker?
21:01:05 <edwardk> saizan: exactly =)
21:01:32 <Eduard_Munteanu> A partial order style of specifying precedence does sound less fragile.
21:01:48 <edwardk> saizan: chris casingho made some comment about how it'd have been nice if the agda folks had thought of hash consing from the get go, and i took that to be a challenge
21:02:07 <Eduard_Munteanu> I wonder if there's been any research on this particular topic.
21:02:15 <dolio> It's a good thing they didn't.
21:02:18 <edwardk> it resulted in the intern library, but testing has shown that that library blows up once i put a couple hundred thousand entries in the tables
21:02:23 <edwardk> so i'm redesigning it
21:02:33 <edwardk> Eduard_Munteanu: it is
21:02:51 <cmccann> Eduard_Munteanu, I've heard multiple people advocate it, though I still have some objections to the idea
21:02:59 <edwardk> Eduard_Munteanu: i used to use it in a toy computer algebra system of mine, but i had to make the editor smart enough to spot the problems or it was nigh unusable
21:03:10 * ddarius doesn't really think it would make a big difference one way or another.
21:03:12 <mgsloan> Eduard_Munteanu: I've seen a number of people write posts about it, but not implementations
21:03:18 <edwardk> it let me red flag in the editor when you had an expression with ambiguous precedence
21:03:50 * cmccann notes that you sometimes want to define something with precedence that's "lower than almost everything", e.g. how ($) is used in Haskell
21:04:05 <cmccann> which could be given some sort of minimum precedence in a partial order, but that loses some flexibility
21:04:06 <edwardk> i still want at least a partial order though, the approach advocated by NAD in his mixfix paper which gave that up seemed silly
21:04:29 <ion> What else has a precedence of 0, btw?
21:04:32 <edwardk> the problem i have with specifying precedence in terms of partial ordering is its a lot more repetitive than just numbering levels
21:04:38 <edwardk> you have to talk about other operators a lot
21:04:52 <edwardk> ion: $ $! <?> etc
21:05:01 <ion> Thanks
21:05:09 <cmccann> edwardk, I think the assumption is that most operators would be unordered with respect to each other
21:05:30 <cmccann> and I assume the language would be smart enough to fill in that A > B, B > C means A > C
21:05:39 <Saizan> pigworker wants to use classes of operators for that
21:05:41 <edwardk> cmcann: sure. i just found that in my experience this let to a HELL of a lot of parentheses
21:05:41 <ion> I’d have expected <?> to be higher than 0.
21:06:00 <edwardk> cmccan: in my case it was
21:06:10 <cmccann> edwardk, my experience is that for unusual combinations I can never remember precedence so I parenthesize anyway
21:06:45 <mgsloan> cmccann - that's why you make most operators incomparable
21:07:02 <mgsloan> force the parenthesization, as it's good practice
21:07:06 <edwardk> cmccann: i was preparsing down to an xml (ick! don't blame me, sign of the times) representation that stored the parenthesization for me, so that if the precedence rules changed you'd still get the semantic meaning you'd saved
21:07:08 <cmccann> anyway, my current favorite ad-hoc kludge is a fixed set of precedence groups similar to Haskell's current precedence levels, with a partial order on everything at that precedence
21:07:44 <edwardk> then i discovered haskell and never looked back
21:08:01 <cmccann> mgsloan, I'm more arguing that I can't remember so forcing parentheses doesn't matter, rather than forcing parentheses is good because it's too hard to remember, but the difference between those mostly comes out in the wash
21:09:48 <Saizan> edwardk: btw, what do you mean by intern blowing up? using too much memory or being too slow?
21:09:52 <cmccann> anyway, having fixed groups lets related operators all do their thing within each tier, while allowing other operators to step outside that completely as appropriate for e.g. pseudo-syntactic operators like ($)
21:09:58 <mgsloan> well, the type system certainly helps it not matter much, because you'll know if you got precedence wrong
21:10:02 <edwardk> giving wrong answers
21:10:10 <edwardk> i fixed the speed problem
21:10:10 <Eduard_Munteanu> edwardk: how about if you specify them both ways?
21:10:34 <edwardk> Eduard_Munteanu: in the grammar as in + < * and * < + ?
21:10:35 <cmccann> would probably make sense to give recommended semantics to precedence tiers as well, e.g. "additive stuff goes here", "multiplicative stuff goes here", etc.
21:10:39 <Saizan> ah, because of hash collisions?
21:10:52 <edwardk> saizan: nah, odd interactions with the garbage collector
21:11:09 <dolio> I thought you proved it correct by 'thinking about it.'
21:11:11 <edwardk> i have a new system that uses quantification to make hash consing regions
21:11:24 <djahandarie> c_wraith, awesome, thanks. I'll stare at that ticket and then try to add a thoughtful reply
21:11:25 <edwardk> dolio: =)
21:11:30 <Eduard_Munteanu> edwardk: no, both numeric fixities and partial ordering.
21:11:40 <edwardk> Eduard_Munteanu: ah, i'm cool with that
21:11:57 <Eduard_Munteanu> So the numeric stuff would be sugar for partial ordering.
21:12:18 <edwardk> dolio: it worked fine until i build an interned intset and started feeding it massive amounts of data
21:12:50 <dolio> I hate the bugs that only happen on large datasets.
21:13:04 <edwardk> what i'm putting together now uses quantification to make an interning 'region'
21:13:35 <edwardk> then letting you reify that into something if you want to use it in a typeclass, etc.
21:14:16 <cmccann> dolio, most bugs only happen on large data sets, for a suitable definition of "large"
21:14:36 <edwardk> cache :: (forall r. Cache r a -> w) -> w; intern :: Internable a => Cache r a -> a -> Interned r a
21:14:57 <edwardk> then you set up the intern table once, and use it, and it accretes information
21:15:12 <edwardk> the current design works, but its the collection of old entries from the table that mucks it up
21:15:39 <dolio> All bugs should be on small corner cases like 0 and 1.
21:15:44 <edwardk> there isn't a good enough mechanism to ensure that both sides of an equality comparison are alive at the same time
21:15:56 <dolio> Then when you've tested up to like 10, you know it works by induction.
21:16:47 <Eduard_Munteanu> Then programmers would be unemployed.
21:16:56 <Eduard_Munteanu> :P
21:17:28 <Eduard_Munteanu> (Granted, we'd have a lot less problems with software)
21:17:28 <cmccann> dolio, I prefer bugs that show up on small datasets, such as empty ones
21:18:25 <cmccann> if all programs were written in Agda, we'd have a lot fewer problems. We'd also have a lot fewer programs.
21:19:14 <EvilMachine> cmccann: ary a lot fewer programmers who would earn a *lot* more money. ;)
21:19:18 <sebz> what do you call a function which takes a variable number of arguments?
21:19:22 <EvilMachine> ary=and
21:19:23 <Eduard_Munteanu> I somehow doubt that we'd have a lot fewer problems.
21:19:25 <Saizan> programs = problems
21:19:38 <cmccann> Saizan, up to isomorphism at least
21:20:03 <Saizan> sebz: variadic
21:20:08 <Eduard_Munteanu> And that's because people usually don't know what they want.
21:20:10 <sebz> oh right! thanks
21:20:15 <EvilMachine> sebz: a philosopher?
21:20:16 <EvilMachine> ;)
21:20:18 <Eduard_Munteanu> Get the spec wrong and the rest is wrong too.
21:20:26 <sebz> lol
21:20:58 <ddarius> sebz: n-ary
21:21:28 <Eduard_Munteanu> Besides, for programs, termination isn't the only problem.
21:22:41 * cmccann wrote a variadic apply operation that repeatedly applies a function to a single argument of type (forall a. f a)
21:22:45 <Eduard_Munteanu> So is setting an asymptotic bound on time and memory, but I'm not sure how easy that is to do.
21:24:50 <Eduard_Munteanu> ddarius: doesn't that usually assume a fixed n?
21:24:59 <Eduard_Munteanu> n-ary tuple, n-ary operation ...
21:26:25 <Saizan> n-ary tree doesn't
21:26:44 <Eduard_Munteanu> Hrm, indeed.
21:27:01 <cmccann> it assumes that it will be used with a well-defined n, which is true here as well
21:27:12 <cmccann> you don't call a variadic function with "n arguments"
21:28:10 * Eduard_Munteanu nitpicks... but Haskell stuff is either 0-ary or unary, not anything else :D
21:28:59 <Eduard_Munteanu> Maybe that should be called a "tree" plainly.
21:29:14 <cmccann> that would be "nullary" to go with "unary", I think
21:29:45 <ddarius> Eduard_Munteanu: No one said anything about Haskell functions.
21:29:58 <sebz> the pedantism is suffocating
21:30:18 * cmccann is tempted to start using "monadic" and "dyadic" just to confuse people
21:31:03 <ddarius> cmccann: That's what J/APL use as well as the monadic pi calculus and monadic first order logic.
21:31:20 <Eduard_Munteanu> I'd go with variadic for functions, that's a common term there.
21:31:35 <cmccann> ddarius, yes, I'm aware of that. the array language use of the terms, anyway.
21:31:52 <ddarius> Admittedly, there aren't triadic functions in APL.
21:31:53 <cmccann> the confusion would be only from using "monadic" in that sense in Haskell
21:32:01 <Eduard_Munteanu> Triad might be even more common and confusing.
21:32:55 <Eduard_Munteanu> Might also overlap with "p-adic"?
21:33:50 <Eduard_Munteanu> "Here's a function which gets a monadic number and returns ..."
21:55:33 <d-day> anyone know how to deal with '$cabal install      \ ...   \ There is no installed version of base'?
21:56:48 <shachaf> Shouldn't that come with GHC?
21:56:56 <d-day> yes does, but cabal isn't recognizing it
21:56:59 <d-day> s/yes/it/
21:57:02 <shachaf> It sounds like your GHC installatio got messed up. :-)
21:57:06 <shachaf> Or cabal.
21:57:14 <shachaf> Does `ghc-pkg list` know about it?
21:57:21 <d-day> yep
22:02:27 <yitz> if you don't like "unary" you can say "monoadic".
22:02:48 <kmc> haha
22:02:52 <d-day> how about, associatary
22:03:00 <kmc> no confusion is possible
22:03:02 <d-day> if we're inventing new words
22:03:50 <yitz> d-day: we're not inventing them, just improving them
22:04:06 <d-day> oh.
22:04:12 <d-day> I'm not good at either, really.
22:05:19 <yitz> then there's "monadict", which is what many people become after they learn haskell
22:05:48 <d-day> Ah, I reserved a phrase for them instead: lambda pusher
22:06:03 <ion> and “monadick”, which is what some people become after they learn haskell
22:06:57 <yitz> ion: that's a specialization of troll for the ones specifically on #haskell
22:07:26 * cmccann occasionally has "monads and strife" as his status message on IM clients and such, if anyone recognizes the reference 
22:07:58 <d-day> something about squirrels
22:08:58 <kmc> haha
22:09:44 * d-day charges cmccann for 1 minute and 22 seconds of his life
22:10:37 <cmccann> hahaha
22:11:36 <d-day> i do remember it, and somehow it now seems more profound than when I saw it ten years ago.
22:11:47 <d-day> Though it still has that before-people-tried-so-hard flash animation feel to it
22:12:17 <ion> That’s nothing, today i spent 8 minutes and 51 seconds watching people walking.
22:12:33 <d-day> that's excusable in the circumstance that you were also walking.
22:13:03 <ion> I must say i’ve never walked in such an awesome way.
22:13:30 <cmccann> d-day, yes, it's a "classic" of internet "culture"
22:15:50 * hackagebot intern 0.8 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.8 (EdwardKmett)
22:18:58 <ivanm> edwardk: why "intern" ?
22:19:15 <edwardk> interning of strings, etc
22:19:25 <edwardk> and HashCons makes for an awkward module name
22:19:31 <mauke> I hate the name "hash consing"
22:19:47 <ivanm> huh, never heard of that phrase before
22:20:06 <edwardk> http://en.wikipedia.org/wiki/String_interning
22:20:07 * ivanm wonders how edwardk keeps all of his package's APIs in his head and thus be able to use them
22:20:13 <ivanm> yeah, reading that now ;)
22:20:41 <danharaj> interesting how you link to that wiki article instead of the one called "Hash Consing" :p
22:20:53 <ivanm> but I have to keep going back to check function names from a module I just wrote the other day; how do you keep track how to do everything without any docs, etc. ?
22:21:12 <ddarius> He just doesn't use most of his packages.
22:21:22 <edwardk> ddarius: shhhh
22:21:23 <danharaj> He *is* the docs.
22:21:33 <mauke> "hash consing" is memoizing constructors while suffering from lisp
22:21:40 <edwardk> and i get docs just fine from haddock
22:21:46 <edwardk> the signatures tell you a lot =P
22:22:01 <danharaj> that's only because you can derive universal property theorems in your head.
22:22:06 <edwardk> plus it helps that wikipedia tells you what most things mean
22:22:20 <ddarius> If you abstract enough there become less and less possibilities, let alone reasonable possibilities.
22:22:28 <edwardk> ddarius++
22:22:40 <ivanm> heh, fair enough
22:23:03 <danharaj> zz
22:23:07 <danharaj> Why am I talking? I should be sleeping.
22:23:14 <ddarius> danharaj: You can do both.
22:23:20 <edwardk> clearly you are talking in your sleep
22:24:00 <edwardk> anyways that patch to intern lets it keep the old API for now
22:24:07 <ivanm> I suppose in part for me that I'm writing so many things with similar names, etc. that I have to check which one I mean _this_ time
22:24:12 <edwardk> but it means it by construction leaks memory as it is used
22:24:26 <edwardk> hence the need for a region system
22:24:57 <edwardk> just write them in their most general form, then you only have to give the name out once ;)
22:25:44 * ivanm really hates it how haddock uses /.../ for emphasis
22:29:19 * ddarius is utterly amazed at James Dolan's ignorance of basic physics.
22:31:47 <shapr> ddarius: who?
22:31:52 <ion> ivanm: You /really/ hate it?
22:32:12 <ivanm> @slap ion
22:32:12 <lambdabot> Come on, let's all slap ion
22:33:02 <cmccann> @vixen what do you think about /.../ for emphasis?
22:33:02 <lambdabot> i dunno, what about?
22:34:21 <ddarius> shapr: http://ncatlab.org/johnbaez/show/Doctrines+of+algebraic+geometry  The guy in these unwatchable, unhearable lectures.
22:34:22 <dankna> I like /.../ for emphasis
22:35:42 * ddarius has a hard time imagining having strong feelings about it either way.
22:39:43 <ivanm> ddarius: it's more that when I use / for alternatives, I have to remember to escape them
22:41:31 <ddarius> Does that give you \/ ?
22:42:14 <ivanm> yeah
22:42:39 <ivanm> I just got bitten with that when I had something like: using foo/bar gives you /baz/.
22:42:56 <ivanm> so of course "bar gives you" was emphasised, and a slash after baz
22:43:06 <dankna> wait what
22:43:10 <dankna> we're talking about conversation here
22:43:12 <dankna> not computing
22:43:18 <dankna> humans can disambiguate from context :)
22:47:39 <Gracenotes> guillemets are pretty safe at the moment
22:47:51 <Gracenotes> markup languages haven't picked them up for emphasis
22:48:14 <Gracenotes> though. then again. they already have the purpose of quotation.
22:48:25 <dankna> @google guillemet
22:48:26 <lambdabot> http://en.wikipedia.org/wiki/Guillemet
22:48:26 <lambdabot> Title: Guillemet - Wikipedia, the free encyclopedia
22:48:35 <dankna> oh, yes
22:51:47 <mrdk> how can I negate the expression 'fmap (=~ e) q'?
22:52:19 <d-day> anyone here understand what 'table algebras' are?
22:52:20 <kmc> :t negate
22:52:21 <lambdabot> forall a. (Num a) => a -> a
22:52:52 <Gracenotes> :o
22:52:58 <coppro> d-day: sounds boring
22:53:03 <Gracenotes> (not . (=~ q))
22:53:40 <Gracenotes> ...mehbeh
22:55:53 <mrdk> Gracenotes: thank you. How'd I do it using negate?
22:56:24 <shachaf> mrdk: negate is probably no what you want.
22:56:25 <shachaf> > negate 5
22:56:26 <lambdabot>   -5
22:56:58 <shachaf> fmap (fmap not (=~ e)) q works, though. :-)
22:57:21 <shachaf> fmap fmap (fmap not) (=~ e) q
22:57:27 <Gracenotes> :O
22:57:48 <mrdk> shachaf: alright, 'fmap (not . (=~ e)) q' seems to work fine for me :)
22:57:56 <shachaf> fmap fmap fmap fmap fmap not (=~ e) q
22:58:06 <mrdk> hehe I see
22:59:07 * shachaf is annoyed that you can't fmap all parentheses out of any expression.
23:00:32 <Gracenotes> (4 + 2) * x
23:01:14 <shachaf> > (4 + 2) * x
23:01:15 <lambdabot>   (4 + 2) * x
23:01:21 <shachaf> > (4 + 2) * x == 6 * x
23:01:22 <lambdabot>   False
23:01:25 <shachaf> lambdabot++
23:02:22 <rostayob> shachaf: what's that?
23:02:30 <shachaf> What's what?
23:02:36 <rostayob> > (4 + 2) * x
23:02:37 <lambdabot>   (4 + 2) * x
23:02:39 <rostayob> what's the x lol
23:02:45 <shachaf> It's x.
23:02:45 <shachaf> > x
23:02:46 <ion> @type x lol
23:02:46 <lambdabot>   x
23:02:47 <lambdabot> Not in scope: `lol'
23:02:50 <rostayob> :t x
23:02:51 <lambdabot> Expr
23:02:53 <rostayob> oh.
23:02:55 <Gracenotes> a magical vary-able
23:03:03 <jake1> \leave
23:03:14 <shachaf> > f lol :: Expr
23:03:15 <lambdabot>   f lol
23:03:33 <Gracenotes> impossible!
23:04:06 <kaol> > show (f lol :: Expr)
23:04:08 <lambdabot>   Not in scope: `lol'
23:04:32 <rostayob> show (f :: Expr)
23:04:38 <rostayob> > show (f :: Expr)
23:04:39 <lambdabot>   "f"
23:04:42 <rostayob> mhm
23:04:51 <rostayob> show ((4 + 2) * x)
23:04:54 <rostayob> > show ((4 + 2) * x)
23:04:55 <lambdabot>   "(4 + 2) * x"
23:04:58 <rostayob> just woke up ehe
23:05:30 <ion> lambdabot already runs show for you.
23:05:46 <Gracenotes> @type let foo = 4; bar = (foo + 2)*x in foo
23:05:48 <lambdabot> forall t. (Num t) => t
23:05:50 * hackagebot TableAlgebra 0.7.1 - Ferry Table Algebra  http://hackage.haskell.org/package/TableAlgebra-0.7.1 (JeroenWeijers)
23:05:52 * hackagebot FerryCore 0.4.6.4 - Ferry Core Components  http://hackage.haskell.org/package/FerryCore-0.4.6.4 (JeroenWeijers)
23:06:42 <Gracenotes> hm. I'm venturing on some quirky monomorphism restriction territory
23:06:59 <shachaf> -XNoMonomorphismRestriction
23:07:51 <Saizan> -XNoQuirks
23:07:52 <GoodAD> niko is a hackers who take power ircop for make pedophilia whit innocent people.
23:08:03 <rostayob> GoodAD: you again :(
23:08:09 <GoodAD> yes
23:08:18 <dankna> -XNoBugs? :D
23:08:20 <ion> rostayob: No feeding them, kthxbye.
23:08:22 --- mode: ChanServ set +o Saizan
23:08:23 <GoodAD> when the world is end, me again here.
23:08:32 --- mode: Saizan set +b *!*Goodad@*.dyn.as47377.net
23:08:33 --- kick: GoodAD was kicked by Saizan (GoodAD)
23:08:39 <Gracenotes> \o/
23:08:50 --- mode: Saizan set -o Saizan
23:09:49 <ivanm> oh, he's learnt english
23:10:00 <Saizan> dankna: NoBugs is scheduled for ghc-10
23:10:06 <dankna> haha, nice!
23:10:49 <ion> -XPEqualsNP, -XPNotEqualsNP
23:10:50 * hackagebot DSH 0.6 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.6 (JeroenWeijers)
23:11:30 <Saizan> now, does NoBugs turn bugs into compile-time errors or does it fix them?
23:11:30 <ion> -XMagicQuotes
23:12:13 <shachaf> > curry `has` kell
23:12:13 <Saizan> if the latter it's enough to do a sloppy implementation and then compile ghc itself with it
23:12:14 <lambdabot>   True
23:12:24 <incluye> -XDoWhatIMeanNotWhatISay
23:13:29 <Gracenotes> Saizan: it stops the compiler from mischievously choosing to do optimizations it hasn't proven in pure Agda to be unequivocally correct
23:14:15 <ddarius> -XMagicHash
23:15:18 <incluye> -XCompileToQuantumBytecode
23:17:10 <Gracenotes> next thing you know, #haskell unveil a completely novel set of unsafe* functions
23:17:34 <dankna> unsafePerformPureComputation!
23:17:41 <dankna> unsafePerformPureComputation :: a -> a
23:18:43 <shachaf> safePeformPureComputation :: a -> IO a
23:18:58 <zong_sharo> is thre any up to date tutorials on atom?
23:18:58 <shachaf> doublePlusSafePerformPureComputation :: a -> IO (IO a)
23:19:40 <jake1> I am trying to install hlint, but it fails saying it can't find happy >= 1.17 even though I've done "cabal install happy"
23:19:52 <shachaf> jake1: Is it in your $PATH?
23:20:03 <shachaf> You might need to PATH="$HOME/.cabal/bin:$PATH" or similar.
23:20:04 <ion> safePerformIO :: IO a → IO a
23:20:38 <shachaf> Of course, that's only if it uses the executable, which I wouldn't expect it to.
23:20:41 <ivanm> yes, don't use ~/.cabal/bin
23:20:46 <ivanm> cabal-install doesn't like ~
23:21:21 <ivanm> shachaf: what else from happy would it be using?
23:21:30 <ivanm> and I'm guessing that the error comes from haskell-src-exts, not hlint itself
23:21:43 <shachaf> Er, yes. Never mind.
23:22:06 <shachaf> ivanm: I didn't expect it to list the version of happy that it didn't find if it was just looking for a binary, though.
23:22:28 <ivanm> might need a specific version, and that's just specified in the cabal file
23:22:34 <jake1> Ah, it's in ~/.cabal/bin, not in my path
23:23:47 <jake1> invanm is right, the error is from from haskell-src-exts
23:24:05 <Gracenotes> I have maybe a dozen lines in my .bashrc incrementally changing $PATH >_>
23:24:17 <Gracenotes> could consolidate them.. haskell is responsible for 2
23:35:03 <mornfall> Is it possible to express a transitive closure of lift?
23:35:03 <Dirrrk> hi, is there anyone here who can help me with Iteratees?
23:37:26 <jake1> Thanks, adding it to the path worked
23:37:45 <Dirrrk> mornfall: how would that work out in the types?
23:37:52 <mornfall> I run into overlapping instances.
23:38:04 <mornfall> Dirrrk: Lift' a b => m a -> m b I guess?
23:38:07 <conal> I've been conversing with a fellow on StackOverflow (a Schemer & asst prof) about lazy evaluation vs macros. The guy keeps arguing in my direction, but I think he's really agreeing. Does anyone see something that I'm missing? http://stackoverflow.com/questions/7046950/lazy-evaluation-vs-macros/7059279#7059279
23:38:43 <mornfall> Dirrrk: Err. Lift' m n => m a -> n a
23:38:47 <mornfall> Dirrrk: Of course...
23:39:28 <conal> (you'll have to expand the hidden comments on that S.O. question)
23:46:04 <Dirrrk> mornfall: so if there are multiple ways to arrive at lifting (via transitive composition), how's the typesystem supposed to figure out which way to use? I'd guess that's where the overlapping instances come from.
23:48:06 <dobblego> where did State go in 7.0.4?
23:48:37 <kmc> the (State s) monad?
23:48:51 <dobblego> yes
23:49:01 <kmc> mtl version 2 re-exports the transformers library
23:49:13 <kmc> so now:  type State s = StateT s Identity
23:49:23 <dobblego> oh wait, State is no longer a constructor, sorry sorry
23:49:25 <dobblego> yes
23:49:26 <dobblego> thanks!
23:49:31 <kmc> i think they added a function "state"
23:49:34 <dobblego> yep
23:49:45 <dobblego> got a bit carried away there in the size of my s
23:49:58 <kmc> hehe
23:50:27 <ion> Not as much as with the size of your ass. *zing*
23:50:55 <mornfall> Dirrrk: Well, the overlap comes from the induction base, Lift' m m.
23:51:22 <Dirrrk> more specifically, I'd like to so something like Iteratee a m b -> Enumeratee a b m x -> Enumeratee a b m x, i.e. first execute the left iteratee, then output the result as in an Enumeratee, then execute the right Enumeratee.
23:52:10 <Dirrrk> mornfall: that's a special case. "identity" lifting gives rise to multiple ways of doing the lifting (how many identity liftings would you like to add?)
23:52:48 <mornfall> Unless there are MonadTrans instances for transformer compositions, I don't think there are other variations possible.
23:52:51 <mornfall> Just this one. :)
23:53:10 <Dirrrk> mornfall: yes, but how's the type system going to know that?
23:53:25 <mornfall> The problem isn't really they are overlapping, the problem is they are incoherent though.
23:53:28 <kmc> you can't express the composition of two transformers except by introducing a new transformer
23:54:04 <mornfall> (I would expect m (t n) to be more specific than m m, but GHC disagrees...)
23:57:51 <mornfall> [4~I am trying to express "pass me something I can lift into my monad and I'll handle it".
23:59:15 <mornfall> (Sounds a bit like subtyping, now I think of it.)
