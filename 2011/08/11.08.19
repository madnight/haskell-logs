00:02:14 * hackagebot mime-mail-ses 0.0.0.1 - Send mime-mail messages via Amazon SES  http://hackage.haskell.org/package/mime-mail-ses-0.0.0.1 (MichaelSnoyman)
00:02:16 * hackagebot packdeps 0.0.2.1 - Check your cabal packages for lagging dependencies.  http://hackage.haskell.org/package/packdeps-0.0.2.1 (MichaelSnoyman)
00:02:18 * hackagebot clientsession 0.7.0 - Store session data in a cookie.  http://hackage.haskell.org/package/clientsession-0.7.0 (MichaelSnoyman)
00:02:20 * hackagebot wai-app-static 0.3.1.1 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-0.3.1.1 (MichaelSnoyman)
00:02:22 * hackagebot wai-extra 0.4.1.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.4.1.1 (MichaelSnoyman)
00:07:24 * hackagebot warp-static 0.2.0.1 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-0.2.0.1 (MichaelSnoyman)
00:07:26 * hackagebot web-encodings 0.3.0.7 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.3.0.7 (MichaelSnoyman)
00:15:19 <gajop> as a near total newbie in haskell and a lot of free time to look at code, but lacking the ability to actually write any as i'm at internship/work, anything you'd recommend?
00:15:33 <opqdonut> reading is useless
00:15:35 <NihilistDandy> gajop: Learn You A Haskell, then Real World Haskell
00:15:44 <NihilistDandy> But also, write some code
00:16:03 <NihilistDandy> Even if you just write some toys
00:16:33 <NihilistDandy> Unless your internship is at an internment camp of some sort, you should have enough time to write some Haskell
00:16:57 <gajop> i wrote something, i think i was solving some euler problems with haskell, but i couldn't get any further ideas than that
00:17:11 <gajop> and i find it important to understand the concepts
00:18:28 <NihilistDandy> "Concepts" is kind of a wide area
00:18:56 <gajop> well i don't even know the syntax :D
00:20:06 <NihilistDandy> gajop: What's your background?
00:20:16 <NihilistDandy> Also, get LYAH and RWH :D
00:20:19 <Saizan> what sort of things are you interested in? you could check the code for a library that'd help for that
00:20:36 <Saizan> but yeah, start with LYAH
00:20:37 <NihilistDandy> Or hoogle until you find something inspiring
00:20:41 <Saizan> @where LYAH
00:20:42 <lambdabot> http://www.learnyouahaskell.com/
00:20:52 <NihilistDandy> @where RWH
00:20:52 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:20:58 <NihilistDandy> Both free and online
00:21:42 <gajop> NihilistDandy: CS, going into masters now, so solid knowledge there, but we lacked any functional languages, only thing similar was prolog and that was only a bit
00:22:03 <NihilistDandy> gajop: Have you read Okasaki?
00:22:06 <gajop> i already did read a bit of RWH, think i even spotted some errors there :p
00:22:07 <NihilistDandy> @where Okasaki
00:22:07 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
00:22:33 <NihilistDandy> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
00:22:37 <NihilistDandy> derp
00:22:58 <gajop> NihilistDandy: no i haven't
00:23:30 <gajop> 'derp'?
00:23:41 <NihilistDandy> I posted the same link that lambdabot had
00:23:55 <NihilistDandy> Because I'm illiterate or blind, apparently
00:25:10 <NihilistDandy> Anyway, LYAH and Okasaki should give you some good ideas. LYAH will give you a LI5 treatment of Haskell (well, more LI10), and Okasaki will cover all the fun datastructure stuff from a functional perspective
00:26:28 <gajop> *googles LI5*
00:27:23 <NihilistDandy> gajop: "Like I'm 5"
00:27:30 <ivanm> O...K...
00:27:41 <mornfall> Another of those challenges... is it possible to call a method if there is an instance available but fall back to some default if there isn't? (I can imagine a semi-solution based on incoherentinstances... anything better?)
00:27:51 <NihilistDandy> ivanm: Differing opinion?
00:27:53 <donri> only pdf?
00:28:02 <ivanm> NihilistDandy: just the fact that there's an acronym for that
00:28:07 <ivanm> mornfall: I highly doubt it
00:28:09 <NihilistDandy> ivanm: Reddit
00:28:15 <NihilistDandy> It's a cancer
00:28:15 <ivanm> ahhhh
00:29:01 <NihilistDandy> I like the phrase, though
00:34:10 <NihilistDandy> donri: Is there some other good document format out there?
00:34:20 <donri> html? :)
00:34:31 <NihilistDandy> Pfeh :P
00:34:40 <NihilistDandy> PDF is less ugly
00:36:29 <mornfall> Illegal type synonym family application in instance. Boooh. :(
00:36:39 <mornfall> I had such a clevear idea! Bad GHC.
00:41:07 <mornfall> IncoherentInstances can crash my program?
00:41:39 <mornfall> (By maneuvering the RTS to call something that does not exist...)
00:42:10 * hackagebot sundown 0.1.2 - Binding to upskirt  http://hackage.haskell.org/package/sundown-0.1.2 (FrancescoMazzoli)
00:43:35 <Saizan> no, not like that
00:44:35 <pokoko222> hey dudes
00:44:44 <pokoko222> what's crackin?
00:44:58 <mornfall> Saizan: But?
00:45:01 <Saizan> the problem is that it's harder to predict which code runs where
00:46:41 <mornfall> Saizan: If I list the most specific instance first, will it also run when its superclass constraint is not met?
00:47:19 <mornfall> Or is IncoherentInstances really safe, but it's not clear what runs (other than, earlier instances may run more often than later instance, even if all match)...
00:47:59 <Saizan> no, it won't ignore constraints
00:48:47 <Saizan> you'll get a type error instead
00:49:39 <Saizan> so yeah, the only problem is that it's less obvious which instance is going to be picked in any particular situation
00:50:12 <Saizan> so e.g. you wouldn't use that with Storable, where using different instances for the same type can lead to memory corruption
00:50:46 <Saizan> well, i've never dared to use IncoherentInstances for anything, tbh :)
00:52:06 <mornfall> Saizan: Yeah, we are talking about formatting debug output here.
00:52:16 <mornfall> I.e. the worst that can happen is you have less info.
00:52:26 <mornfall> When your program crashes anyway. :D
00:54:24 <mornfall> But even incoherent instances won't let me have identical heads with different contexts. And it won't let me use a family application in the head. Augh.
01:18:00 <mercury^> EvanR-work: ?
01:19:12 <mornfall> Oookey. Different approach. :) This one ain't no good.
01:29:17 <hpaste> Accidus pasted “Overlapping Instances Class Error” at http://hpaste.org/50456
01:29:34 <Accidus> I have an overlapping instance error, but I'm not sure what has caused it. (see pastebin above). The intuition is that GHC manages to prove that (x,y) is somehow unifiable with m a for an EquatableFunctor m and an Eq a, but I don't see how.
01:30:29 <mornfall> Accidus: Can you paste the error as well?
01:31:28 <mornfall> Accidus: NVM.
01:32:03 <mornfall> Accidus:       instance (Eq a, Eq b) => Eq (a, b) -- Defined in GHC.Classes
01:34:19 <Accidus> Yes, that's the error, only for me it says "defined in Data.Tuple"
01:35:26 <Saizan> m a unifies with (b,c) by taking m = (,) b; a = c
01:35:31 <mornfall> Yeah.
01:35:37 <Saizan> context doesn't matter
01:35:44 <mornfall> I was on the brink of that discovery. :P
01:36:03 <Accidus> Good, thanks for that.
01:36:28 <Accidus> I don't speak fluent Haskell yet, but I can listen attentively :P
01:37:20 <mornfall> I wonder how hard it would be to take constraints into account when resolving instances. (Probably undecidable? O_o)
01:38:17 <mornfall> It would definitely be much more intuitive that way. :P
01:39:15 <Accidus> mornfall, What do you mean?
01:40:09 <mornfall> Accidus: Only the instance head is currently used to pick which instance to use (or whether any is available).
01:41:35 <mornfall> It would be cool if the resolution could also consult the constraints, so instances of the form (Foo a) => instance Bar a and (FooBaz a) => instance Bar a could coexist, as long as Foo/FooBar were disjoint.
01:41:51 <mornfall> Probably clashes badly with separate compilation, if nothing else.
01:42:15 <mornfall> (You may be able to check that if you always have all the instances when typechecking. Which you generally don't.)
01:42:34 <mornfall> Same problem with type family application in the instance head.
01:42:53 <Saizan> i suggest the paper on instance chains
01:44:20 <mornfall> The bad, the ugly and the ACM.
01:44:59 <mornfall> Number one reason to be at a university, I guess.
01:46:01 <Saizan> http://web.cecs.pdx.edu/~jgmorris/pubs/morris-icfp2010-instances.pdf
01:48:42 <mornfall> Saizan: Have it already. The question is, is it possible to have this as a -XThing, or is it irreconcilable with the current GHC typechecker... :)
01:50:21 <illissius> mornfall: you probably also want to catch up on the mailing list / trac discussions SPJ was involved in concerning overlapping type family instances... (in case you haven't already)
01:53:04 <illissius> iirc, the basic shape of things last I checked is that (for the type instance, not class instance case) it's easy enough to define the semantics as "closed type family, instances within the module are matched in a top-down order, instances outside the module are disallowed", but unclear how to represent that in FC/Core
01:53:30 <Saizan> mornfall: not sure if instance chains would let you do all that you wish, it's interesting by showing which kind of restrictions you need to handle contexts while keeping consistency and separate compilation, i'm pretty sure it could be implemented in ghc with enough effort though
01:54:57 <Saizan> the problem is that there doesn't seem to be a lot of people that feel confident about hacking on ghc's constraint solver :)
01:55:00 <mornfall> :-) Sounds like work that would justify an ICFP submission.
01:55:28 <mornfall> Too bad it's outside of my field of study.
01:55:51 <mornfall> Maybe if I finish my dissertation one year early, the powers to be will let me hack on GHC for a year ... :))
01:56:05 <Saizan> there's a related discussion on haskell-prime where oleg shows how you can get pretty close by simply having a type-level TypeRep
01:56:20 <mornfall> Saizan: I might have seen that.
01:57:00 <mornfall> But that's Oleg. Which usually implies incomprehensible idioms you need to apply in your code.
01:57:38 <Saizan> it's not so incomprehensible in this case, assuming the typerep stuff gets provided by the compiler
01:57:52 <mornfall> Yeah, -XOleg for sugar!
01:58:25 <illissius> heh. I didn't try very hard to understand it, and didn't succeed.
01:58:25 <Saizan> more tedious than just having cascading overlapping patterns though
01:58:48 <mornfall> It's boost all over again, really. :)
02:01:38 <Saizan> never used boost, but i doubt it :)
02:03:03 <Saizan> anyhow, i guess SPJ would rather work harder on the typechecker so that users get the nicest interface
02:16:21 <mornfall> Saizan: The instance chains look pretty nice.
02:16:35 * mornfall likes (when will we get a +1 button in research papers? :D)
02:19:09 <frerich> Sorry for being slightly off-topic, but is anybody here working as a software engineer in the Bay Area (maybe even using Haskell) and willing to answer a few questions in a private chat?
02:20:38 <cheater> why does it matter if it's bay area or not
02:21:15 <koala_man> probably less about haskell and more about the bay area
02:26:57 <aki> morning
02:43:21 <weltensegler> Hello, what is the standard way to get the second last item from a list?
02:44:53 <Jafet> *std::advance(l.rbegin(), 1)
02:45:05 <Jafet> This is your brain on C++!
02:45:19 <Jafet> Wait, wrong channel
02:45:21 <cheater>  jesus
02:45:22 <Jafet> My brain's on C++
02:45:32 <Jafet> > last . init $ [1..10]
02:45:34 <lambdabot>   9
02:45:35 <illissius> lol
02:46:16 <empity> weltensegler: l !! (length l - 2)?
02:46:19 <empity> or something like this?
02:46:25 <Jafet> Well, that one's less pretty.
02:46:34 <ivanm> empity: noooooooo!
02:46:45 <ivanm> if you want unsafeness, go with what Jafet said
02:46:50 <illissius> > head . tail . reverse $ [1..10]
02:46:52 <lambdabot>   9
02:46:59 <ivanm> weltensegler: but if you're doing that a lot, then you're using the wrong data structure!
02:47:33 <empity> illissius: doesn't get very readable
02:48:06 <weltensegler> ivan, i have to parse a certain fileformat once. But maybe you are right and i can circumvent that problem.
02:48:35 <weltensegler> make that ivanm. Sorry
02:48:57 <Jafet> What kind of format needs you to get the second last item...
02:49:08 <ivanm> you can do a Maybe option of that:
02:49:36 <ivanm> safeSecondLast as(_:_:_) = Just . last . init $ as; safeSecondLast _ = Nothing
02:49:49 <ivanm> Jafet: I've had to do similar things parsing config files, etc.
02:51:35 <zoomzoomzoom> how do I get a nice binary printout of a bytestring?
02:51:47 <Jafet> Define binary printout
02:52:06 <weltensegler> Thanks everyone.
02:52:47 <zoomzoomzoom> something like 3b 3e 2a ff 2e
02:53:01 <Jafet> So you want hexdump(1) style printout
02:53:27 <zoomzoomzoom> yeah
02:54:17 <Saizan> Numeric should have a function to show numbers in hex
02:54:24 <Jafet> I would just pipe it through hexdump(1)
02:54:37 <Saizan> then you can do unwords . map showHex . unpack
02:55:12 <Jafet> That's a little clever
02:56:38 <tibell_> Is there such a thing as a strict and lazy traverse?
02:57:26 <ivanm> tibell_ == tibbe ?
02:57:38 <tibell_> ivanm, yes :)
02:57:46 <tibell_> .
02:57:59 <tibbe_> I must be logged in from home :)
02:58:11 <tibbe_> tibbe: get out of that couch and get to work!
02:58:38 <Jafet> Depends on which instance you use?
02:58:55 <zoomzoomzoom> I don't see what that call to unwords does
02:59:11 <Jafet> > unwords ["01", "23", "ab", "cd"]
02:59:12 <lambdabot>   "01 23 ab cd"
02:59:30 <Jafet> splitEvery 16 and you're halfway to hexdump(1)
02:59:37 <efie> does anyone know if there is an implementation of shannon-fano encoding in the internet (in haskell of course) i wrote some on my one but i think its too inefficient and and incovenient, i woud lile to compare it to a better one
03:00:10 <efie> i could not find any
03:00:39 <zoomzoomzoom> but unpack returns a [Word8]
03:00:46 <zoomzoomzoom> or a String
03:00:55 <Jafet> :t showHex :: Word8 -> String
03:00:56 <lambdabot>     Couldn't match expected type `String' against inferred type `ShowS'
03:00:56 <lambdabot>     In the expression: showHex :: Word8 -> String
03:01:07 * Jafet kicks Numeric
03:02:01 <zoomzoomzoom> List.map (fun x -> showHex x "") . unpack
03:02:23 <Jafet> > fix (\s -> concatMap (showHex s) [0x0..0xf])
03:02:25 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
03:02:25 <lambdabot>    arising from a use ...
03:02:31 <ivanm> @type foldr (.) "" . map showHex
03:02:32 <lambdabot>     Couldn't match expected type `Char' against inferred type `[Char]'
03:02:32 <lambdabot>       Expected type: Char
03:02:32 <lambdabot>       Inferred type: String
03:02:56 <ivanm> @type ($"") . foldr (.) id . map showHex
03:02:58 <lambdabot> forall a. (Integral a) => [a] -> [Char]
03:03:02 <ivanm> zoomzoomzoom: ^^
03:04:35 <Jafet> efie: "why implement something inferior to Huffman coding?"
03:06:06 <Jafet> I presume that most people who ask themselves that question won't implement Shannon-Fano coding
03:06:28 <Jafet> You can, of course, petition people here to read your code
03:07:36 <efie> jafet: i need to implement both - i want to write a programm which shows both encodings and the case-by-case different results concerning redudancy
03:12:08 <efie> jafet: thats a good idea
03:13:44 <efie> i petition to look at http://codepad.org/Lc0G3YN6 and tell me where it can be improved :)
03:14:50 <Botje> efie: you might want to replace line 27 with a call to "error"
03:16:20 <Jafet> You might want to use Double, as the efficiency is practically identical
03:16:21 <Botje> sum(f':f:[y]) better written as f' + f + y
03:16:29 <efie> yeah, i thought of this too, but i havent done it yet because thats the after next chapter of learnyouahaskellforgreatgood im going to read:)
03:16:40 <efie> ok
03:16:42 <Botje> efie: also, it's not haskell style to write parens for function values
03:17:47 <efie> what do you mean by parens? i dont know this word
03:18:00 <Jafet> If you want equations to line up, line them up! (lines 31-32)
03:18:47 <Jafet> efie: parentheses. Paste your program to hpaste.org and read the hlint report.
03:18:48 <qnikst> hello, I have got next problem I have a computation with ErrorT MyErrors IO, that can throw someError, and function that can throw Exception, if there is any way to catch both?
03:20:03 <hpaste> efie pasted “shannon-fano” at http://hpaste.org/50458
03:20:30 <Jafet> Uh, where's the hlint report...
03:20:56 <qnikst> my code was if (a) then return b else throwError , and b can throw Exception. in this case my program corrently catchesError
03:21:01 <Jafet> Okay, it sadly disappeared from hpaste
03:21:12 <qnikst> but exception stops program execution
03:21:33 <Saizan> qnikst: you've to use both catchError and Control.Exception.catch if you want to catch both
03:22:30 <Saizan> qnikst: in fact, this complication is the reason why i'd avoid stacking ErrorT over IO, and make an instance of Exception for MyErrors isntead
03:22:40 <qnikst> if I'm trying to do: liftIO $ try $ if (a) then return b else throwError MyError, I'm not able to throwError (couldn't match expected type IOError)
03:23:03 <qnikst> hm..
03:23:45 <qnikst> will try to
03:23:45 <Jafet> efie: as for efficiency, you are tossing around a lot of (xs ++ [x]) and (sum xs)
03:24:09 <efie> hm yes
03:24:10 <Jafet> Those look like Bad Ideas
03:24:51 <efie> i dont see how i can avoid the sum
03:24:56 <Guest24150> hi
03:25:12 <Guest24150> !!
03:25:13 <qnikst> Saizan: so I can add Exception instance fo MyError and remove ErrorT (of caouse fixing all 'throwError')
03:25:21 <qnikst> fo=to
03:25:39 <Saizan> qnikst: if you want to keep using throwError than "liftIO $ try $ runErrorT $ if a then return b else throwError MyError" should work
03:25:43 <Saizan> *then
03:25:56 <Saizan> qnikst: check the documentation for Control.Monad.Exception
03:26:43 <qnikst> thanks
03:27:18 <efie> jafet: or shall i for example additionally say .. .where sum fs = x and then replace the sum ys at line 31 with "x-y"?. maybe (?) this would be more efficient, but i doubt this would help me understand it later
03:28:45 <efie> furthermore i was wondering if this shannon-fano thing could be implemented using some functions such as filter, map and concatenation to avoid the recursion
03:29:21 <hpaste> Jafet annotated “shannon-fano” with “shannon-fano (hlint)” at http://hpaste.org/50458#a50459
03:29:50 <efie> thanks
03:30:11 <Jafet> Hmm, why is "redundant bracket" an error
03:30:16 <Jafet> Anyway
03:31:24 <hpaste> Botje annotated “shannon-fano” with “cleaned up version” at http://hpaste.org/50458#a50460
03:31:27 <Jafet> Instead of using split1 to get a value from a list and then using the value to split the list, have split1 return the split lists
03:31:34 <Botje> efie: ^ ^
03:32:11 <qnikst> Saizan: last question, now I have  Ambiguous type variable `e' in the constraint:
03:32:29 <qnikst> `Exception e'
03:32:35 <Jafet> Exception is a typeclass
03:33:23 <qnikst> and how should I add type signature into: liftIO $ try $ ... ?
03:33:30 <efie> thanks botje
03:33:37 <Jafet> Do \e -> doSomething e `const` (e::SomeException) or let f :: SomeException -> IO a; f = doSomething in f
03:33:41 <ivanm> qnikst: write an explicit helper function with a type sig
03:33:43 <efie> i will go over it
03:33:59 <Saizan> ?hoogle try
03:34:00 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
03:34:00 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
03:34:00 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
03:34:32 <Botje> efie: basically, you can avoid doing | otherwise by either adding a clause or an if statement
03:34:58 <Saizan> qnikst: liftIO $ (try $ ... :: IO (Either SomeExceptio Foo))
03:35:09 <qnikst> thanks
03:35:52 <qnikst> Jafet, ivanm, also thanks..
03:36:02 <Jafet> Saizan's is superior if the type isn't discarded
03:36:13 <efie> botje: | otherwise is less efficient?
03:37:06 <efie> just look at the code i prefer the | .)
03:37:19 <Jafet> It's not any more or less efficient
03:37:22 <efie> looking*
03:37:30 <ivanm> Jafet: not really; the docs recommend against using SomeException
03:37:39 <ivanm> since it also stops things like Ctrl-c from working
03:37:48 <Jafet> ivanm: we were both using SomeException as a placeholder
03:37:53 <Jafet> I hope that was obvious
03:38:04 <ivanm> ahhh, fair enough
03:38:56 <Botje> efie: not efficient, but it forces you to indent a fair bit (unless you then start on a new indented line)
03:39:16 <Botje> efie: to me it reads more like "okay, now that we have the edge cases out of the way, here is the *real* code"
03:39:49 <Jafet> efie: so, you basically want to split the list into two whose sums are the closest
03:40:04 <efie> botje: hm yeah
03:40:06 <efie> jafet: yes
03:40:07 <Jafet> Botje: that's rather subjective
03:40:17 <Botje> hence the "to me" part of that sentence.
03:41:01 <Jafet> And in efie's case, the guards are indeed used to separate the boring base case and the actual recursion
03:41:10 <Jafet> It's just that one of the guards is ridiculously long
03:41:28 <Jafet> (And not as efficient as it should be either)
03:42:33 <Botje> yes, that's why I replaced it with an if test. but it's indeed still not quite efficient
03:44:13 <efie> can this imporved be replaced the recursion with using concatention of functions such as map and so on or just imporving the recursion?
03:44:17 <Botje> .oO(take the sum and scanl over the list, subtracting from the total)
03:45:16 <efie> hm, ok
03:48:14 <gajop> any other version of online haskell other than this? http://tryhaskell.org/
03:48:24 <gajop> can't download haskell on this PC
03:48:30 <tibbe_> so, is there such a thing as a strict and lazy traverse?
03:49:26 <Saizan> you mean two distinct traverses?
03:50:31 <Saizan> anyhow no, though it's true that the usual implementation is not tail-recursive so it can be problematic with strict applicatives
03:52:25 <ivanm> gajop: maybe get a standalone hugs?
03:52:30 <Saizan> in the sense that it'll use stack
03:52:32 <ivanm> gajop: codepad has some limited support I think
03:55:03 <Accidus> Is it possible to explicitly instantiate universal quantification over types?
03:55:04 <Eduard_Munteanu> gajop: you might want to chat with lambdabot privately
03:55:22 <gajop> oww, kinky
03:55:38 <Saizan> Accidus: no
03:56:01 <Accidus> Thought so.
03:56:20 * Accidus wonders whether he should switch to a dependently typed language.
03:57:01 <Eduard_Munteanu> What do you want to do?
03:57:08 <mux> I know I want to, but my brain still objects to it
03:57:12 <companion_cube> what would it bring to you ?
03:57:35 <Jafet> Illustrating laziness:
03:57:40 <Jafet> > let splitWeight xs = snd $ minimumBy (comparing fst) $ map (fmap (\subtotal -> abs ((total - subtotal) - subtotal))) $ scanl1 (\(x,_) (y,spl) -> (x+y,spl)) $ zipWith (\x n -> (x, splitAt n xs)) xs [1..] where total = sum xs in let (xs,ys) = splitWeight [1..1000] in (sum xs, sum ys)
03:57:41 <lambdabot>   Occurs check: cannot construct the infinite type: a = ([a], [a])
03:58:00 <Jafet> > let splitWeight xs = snd $ minimumBy (comparing fst) $ map ((\subtotal -> abs ((total - subtotal) - subtotal))***id) $ scanl1 (\(x,_) (y,spl) -> (x+y,spl)) $ zipWith (\x n -> (x, splitAt n xs)) xs [1..] where total = sum xs in let (xs,ys) = splitWeight [1..1000] in (sum xs, sum ys)
03:58:01 <lambdabot>   (250278,250222)
03:58:33 <Accidus> Hmm... I think I managed to circumvent the problem.
03:58:56 <Accidus> Eduard_Munteanu, companion_cube: Well, I'm still prototyping. I might not need all those dependent types in the end :)
03:59:24 <Eduard_Munteanu> I'm not sure what it means to "explicitly instantiate universal quantification over types"
04:00:05 <Saizan> apply porlymorphic functions to types
04:00:17 <Eduard_Munteanu> Ah.
04:00:30 <Saizan> (poorlymorphic?)
04:00:35 <qnikst> one more question on Exceptions as I see there's no easy way to make try for diffrerent types of Exception (e.g. from different libs)?
04:00:38 <Eduard_Munteanu> :)
04:01:00 <Eduard_Munteanu> Accidus: you might want to check Agda out if you're interested in more advanced type systems
04:01:07 <Saizan> qnikst: try works with any instance of the Exception typeclass
04:01:17 <Accidus> Eduard_Munteanu, yeah, I've dabbled in Agda in the past
04:01:26 <Saizan> qnikst: so you can add your own types
04:01:38 <qnikst> but try ''asks'' me about concrete type of exception?
04:01:53 <Saizan> yeah
04:02:06 <qnikst> e.g. in one lib I have MyExecption instance Exception, in other NotMyException
04:02:29 <Saizan> you can use two try's
04:02:50 <qnikst> ok, so it was my question )
04:02:51 <qnikst> thanks
04:10:51 <weltensegler> Is there something like a function "List.findWithIndex :: (a -> Bool) -> [a] -> Maybe (Int, a)" that returns the first item (satisfying a predicate) AND its index in a list?
04:11:38 <mercury^> weltensegler: you can try to find it with hoogle. But if there is no such thing, you can easily write it yourself of course.
04:14:47 <Saizan> ?type \p -> find (p . snd) . zip [0..]
04:14:52 <lambdabot> forall a b. (Num a, Enum a) => (b -> Bool) -> [b] -> Maybe (a, b)
04:15:55 <Jafet> Hm, whnf of (\n -> inits [0..n] !! n) is Θ(n^2)
04:17:00 <Jafet> Argh, it also seems to be O(OM)
04:17:30 <mercury^> @pl \p -> find (p . snd) . zip [0..]
04:17:30 <lambdabot> (. zip [0..]) . find . (. snd)
04:19:29 <weltensegler> Thanks you, that looks good!
04:19:32 <mux> your initial version is a lot clearer
04:19:36 <mux> (to mercury^)
04:19:50 <mux> as is often the case with non-trivial expressions
04:20:09 <erus`> @djinn a -> b -> a
04:20:10 <lambdabot> f a _ = a
04:20:22 <Jafet> But the pointless version reads left-to-right!
04:20:45 <mux> true
04:22:02 <mux> then again, it seems there are some people who find stuff such as "((f .) .) . flip g" actually readable
04:22:24 <Jafet> People who spend too much time around @pl
04:32:16 * hackagebot compact-string-fix 0.3.2 - Same as compact-string except with a small fix so it builds on ghc-6.12  http://hackage.haskell.org/package/compact-string-fix-0.3.2 (TonyHannan)
04:38:22 <digitteknohippie> my friend was asking if there have been any website written in haskell.  anyone know of any?
04:38:48 <Jafet> Many, but most of them are about haskell
04:47:31 <erus`> the login system for lady gaga and kerry hilson's website is in haskell...
04:47:41 <erus`> i feel dirty for knowing that
04:47:42 <hpc> wait what?
04:48:03 <rostayob> digitteknohippie: I wrote a reddit clone but it's not running :P
04:48:18 <rostayob> there is that website about haskell jobs that's in haskell
04:48:39 <rostayob> or haskell programmers.... snoyman did it
04:48:39 <hpc> i wrote a website but now it's mostly just how i remote-control my irc bot
04:48:44 <erus`> i would write my haskell website in ruby
04:49:24 <rostayob> digitteknohippie: this http://www.haskellers.com/
04:49:25 <erus`> because fuck you :D
04:50:02 <rostayob> digitteknohippie: also, this http://www.patch-tag.com/
04:50:11 <rostayob> aaaand this http://darcsden.com/
04:50:20 <rostayob> aaaaand hpaste.org
04:50:26 <rostayob> shiat they are all about haskell.
04:51:36 <erus`> i am the only haskeller in my county
04:51:40 <erus`> forever alone
04:51:46 <Botje> erus`: I highly doubt that.
04:51:49 <rostayob> erus`: what country?
04:51:58 <erus`> jolly old England
04:52:09 <rostayob> I'm in england!
04:52:13 <rostayob> you are not alone anymore
04:52:20 <Botje> didn't you go to camHac then?
04:52:21 <dropdrive> He said county, not country
04:52:27 <rostayob> ah. ok.
04:52:43 <erus`> Kent haskell users group
04:52:49 <dblhelix> mmm… which version of cabal-install am I supposed to use with ghc-7.2.1?
04:52:49 <erus`> i hold it in my mums basement
04:53:08 <dblhelix> it seems that ghc-7.2.1 comes with Cabal-1.12.0
04:53:26 <dblhelix> but the most recent version of cabal-install requires Cabal <= 1.11
04:54:14 <dblhelix> am I missing something?
04:54:20 <yitz> erus`: http://www.yesodweb.com/page/powered-by-yesod
04:54:26 <digitteknohippie> thnx for all those.  :)
04:54:27 <illissius> dblhelix: whatever i already had installed (presumably came with the distro packages for 7.0) worked for me, i just had to set with-compiler in the config to point to 7.2
04:54:38 <illissius> er with-ghc
04:55:31 <dblhelix> illissius: that makes sense; problem is that I am starting from a new .cabal tree :(
04:55:42 <dblhelix> so, for instance, I do not have a current version of cabal-install
04:55:43 <Saizan> dblhelix: the darcs version of cabal-install should work with cabal 1.12
04:55:57 <yitz> erus`: that's just some sites written with yesod. there are also plenty of live sites using snap and happstack
04:56:20 <erus`> i think you are talking to the wrong person :P
04:57:03 <yitz> ah, digitteknohippie was asking, not you. sorry erus`.
04:57:09 <dblhelix> Saizan: the head, you mean? I could give it a try
04:57:15 <yitz> digitteknohippie: see above link :)
04:58:07 <yitz> erus`: well, i can only hope you didn't mind getting a few extra messages out there in lonely kent
04:58:51 <erus`> yeah i had a look anyway :)
04:59:20 <Saizan> dblhelix: yeah
04:59:35 <dblhelix> Saizan: okay, thanks
05:00:04 <yitz> digitteknohippie: here is the testimonials page. you'll find similar advantages to the other two frameworks as well. http://www.yesodweb.com/page/testimonials
05:06:06 <erus`> which is the favourite web package?
05:09:31 <atsampson> erus`: you certainly aren't the only Haskeller in Kent -- lots of Haskell users at UKC...
05:09:54 <ivanm> erus`: to do what?
05:09:58 <ivanm> as in create a website?
05:10:05 <erus`> yar
05:10:46 <erus`> atsampson: staff?
05:11:07 <maurer_> What's the proper way in the FFI to deal with binding to a varargs function?
05:12:18 <wjlroe> How can you get cabal to run tests properly? When I have a test-suite section it just complains it can't find my code (compiles fine with ghc)
05:12:53 <rostayob> maurer_: define a type to express the lists of arguments?
05:13:07 <rostayob> something like http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Text-Printf.html
05:13:15 <maurer_> rostayob: My problem is not the haskell side interface, but rather thow to do the "foreign import" declaration
05:13:26 <maurer_> *how
05:13:51 <erus`> how old can you be and still get a student loan?
05:14:02 <rostayob> maurer_: ah. I think that libfffi can help
05:14:21 <rostayob> I'm not sure... wait for someone else :P
05:15:45 <rostayob> maurer_: http://stackoverflow.com/questions/5989457/haskell-ffi-support-for-functions-with-variadic-arguments
05:18:31 <atsampson> erus`: various people in the PLAS research group (Simon Thompson et al)
05:20:59 <rostayob> maurer_: you could use template haskell! ehe
05:21:14 <rostayob> actually no
05:21:26 <rostayob> I mean you could easily generate instances for various number of arguments
05:22:01 <rostayob> but you can't have arbitrary number of arguments at runtime
05:22:08 <Jafet> Sure, just figure out the format of the C stack and it's all relatively trivial from there
05:22:48 <Jafet> C "varargs" are also fixed at compile time, even though the mechanism isn't
05:23:02 <rostayob> Jafet: yeah but I think there are already libraries for that
05:23:03 <mreh> why is there no recursive option for darcs remove?
05:23:14 <Jafet> Static type system, and a rather monomorphic one at that
05:23:21 <mreh> i accidentalyl added a deep directory
05:23:38 <atsampson> mreh: there is on my darcs -- darcs remove -r
05:24:36 <rostayob> maurer_: or you could write a simple C function that gets an array and size and calls the function you want
05:24:50 <illissius> maurer_: there's also http://hackage.haskell.org/package/cinvoke -- I don't know if it can do varargs.
05:25:24 <efie> scanl (-) 1 [0.4,0.2,0.2]
05:25:32 <efie> lamdabot scanl (-) 1 [0.4,0.2,0.2]
05:25:34 <rostayob> >  scanl (-) 1 [0.4,0.2,0.2]
05:25:35 <lambdabot>   [1.0,0.6,0.39999999999999997,0.19999999999999996]
05:26:10 <illissius> > fix error
05:26:12 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
05:26:17 <illissius> never fails to amuse me. :)
05:28:18 <mreh> atsampson: what version do you run?
05:29:10 <mreh> god, i'm running 2.30
05:30:07 <qnikst> is there a way to take concrete element of tuple?
05:30:24 <mreh> :t fst
05:30:25 <qnikst> that contains more than 2 elements
05:30:25 <lambdabot> forall a b. (a, b) -> a
05:30:26 <mreh> :t snd
05:30:27 <lambdabot> forall a b. (a, b) -> b
05:30:29 <atsampson> mreh: 2.4 and 2.5 both have it
05:30:40 <opqdonut> qnikst: pattern matching
05:30:50 <efie> why is scanl (-) 1 [0.4,0.2,0.2] not = [1.0, 0.6, 0.4, 0.2] ?
05:30:51 <opqdonut> > let (x,_,_,_) = (1,2,3,4) in x
05:30:52 <lambdabot>   1
05:31:23 <opqdonut> rostayob: it is, up to rounding
05:31:36 <opqdonut> gah,
05:31:40 <opqdonut> efie: it is, up to rounding
05:31:41 <erus`> whats a nice linux distro with up to date haskell platform packages?
05:31:44 <efie> :)
05:32:34 <qnikst> opqdonut: i see, already use $ \(x,_,_) -> $ tuple
05:32:44 <qnikst> erus`: gentoo, is a good one
05:33:09 <gajop> erus`: i'd guess arch linux is up to date, since it's up to date with everything
05:34:00 <Jafet> It's not like you'd upgrade it anyways
05:34:03 <mreh> i try to shy away from tuples
05:34:09 <Jafet> So why bother?
05:35:11 <mreh> they're redundant given that more abstract data types exist
05:38:17 <wjlroe> Can anyone spot why delFieldJson doesn't compile here but extraFieldJson does? http://hpaste.org/50462
05:39:06 <erus`> arch looks good :)
05:40:47 <qnikst> for gentoo I can that there is a nice package system, and you can easily add more packages, rebuild all packages with deps if smth wrong and trace all dependencies
05:42:45 <gajop> what? well anyway, arch probably has one of the best (fastest anyway), and rather easy to work with
05:43:07 <gajop> package manager
05:43:20 <qnikst> now ok )
05:44:40 <qnikst> as I know arch is binary distro with ability to compile latest version?
05:45:41 <gajop> arch is a binary distribution, and you can get the files needed to compile anything available as a binary source "abs <package_name>", but it's not like you'll actually tend to do it
05:46:50 <gajop> but, it also has different special packages available on AUR, which require to be compiled by hand, and often offer a widy variaty of either somewhat different builds, f.e "no-gnome-evince" or rarely used packages that aren't maintained in core/extra/community
05:47:25 <qnikst> I see
05:47:45 <qnikst> thanks, for explanation
05:48:13 <gienah> there are programs like pakatahn for downloading and compiling AUR stuff on arch
05:48:31 <mreh> darcs remove is taking a phenomenal amount of time
05:48:38 <mreh> darcs add took no time at all
05:48:47 <mreh> there is a large number of files
05:48:58 * gienah does lots of packaging stuff in the gentoo haskell overlay
05:49:07 <gajop> yeah, i'm using yaourt for that
05:51:17 <kmc> gajop, qnikst practically every distro will have a way to download and build source
05:52:15 <gajop> yeah, but some have it easier and some have it harder
05:52:25 <gajop> and some don't really require all that souce compiling
05:53:34 <gienah> gentoo being a source based distribution has strong support for building source code. haskell-updater rebuilds haskell packages that are broken by dependency bumps
05:54:06 <kmc> cool
05:54:31 <Jafet> Huh, so sicp doesn't apply to gentoo?
05:55:02 <silver> wait wat
05:55:44 <silver> sicp? the book?
05:56:19 <fredmorcos> =D
05:56:35 <Jafet> ghc-pkg register machines
05:57:12 <silver> lol
05:57:33 <Jafet> http://www.vex.net/~trebla/haskell/sicp.xhtml
05:58:02 <silver> oh, thanks ;)
05:58:15 <qnikst> it was about system packages
05:58:27 <ivanm> yeah, that page doesn't really apply
06:01:58 <kmc> haha
06:28:35 <bitstream0101> Is there an easy way to have ghci find generated code from alex/happy specifications upon module reload without explicitly adding an -i flag that refers to the generated code directory?
06:28:49 <bitstream0101> If I omit such a flag, ghci just complains that it can't find the generated module :(
06:32:17 <mreh> i accidentally adde 245M of javascript sources to my darcs package
06:32:19 <mreh> :(
06:32:24 <mreh> can't remove
06:32:37 <roconnor> unrecord!
06:33:19 <mreh> not recorded
06:34:21 <roconnor> oh
06:34:27 <roconnor> revert the changes!
06:34:30 <mreh> i've not successfully removed a single file yet, it's bonkers
06:34:42 <roconnor> #darcs
06:57:18 <saml> entertain me
07:02:26 <saml> with one liners
07:05:04 <capivara> @quote
07:05:04 <lambdabot> gFunk says: [the main advantage of functional programs are that they're] incorrect the first 1000 times you try to compile it!
07:06:11 <ciaranm> given something that's Applicative and has pure and <*> defined, can the fact that it's also a Functor be deduced, or must it be made explicit?
07:06:55 <mauke> isn't Functor a superclass of Applicative?
07:06:58 <mux> yes it is
07:06:59 <mux> class Functor f => Applicative f where
07:07:03 <mux> you beat me to it, mauke
07:07:16 <dolio> map f x = pure f <*> x is a law.
07:07:21 <ciaranm> yes, but fmap can be implemented in terms of pure and <*>, can't it?
07:07:35 <ciaranm> do i really need to provide an implementation for fmap too?
07:07:53 <mux> since Applicative is a superclass of Functor, you have to have a Functor instance.
07:08:06 <kmc> it's a limitation of how type classes work essentially
07:08:14 <ciaranm> that's a shame
07:08:34 <mauke> instance Functor X where fmap f x = pure f <*> x  -- valid
07:08:55 <ciaranm> mauke: right, but writing that makes me feel dirty. it should be automatic.
07:09:00 <dolio> However, I don't think the the laws governing the interaction of pure and <*> imply the laws for fmap, except by mentioning fmap and assuming fmap has the right properties.
07:09:30 <dolio> Like pure id <*> x = fmap id x = id x
07:10:18 <kmc> what's more avoidable is needing to write pure *and* return
07:10:29 <kmc> that could be fixed by rejiggering the standard library
07:10:51 <dolio> The SHE preprocessor has support for default superclass instances, and there's talk of getting it into GHC.
07:11:06 <kmc> ideally you have one class each for fmap, pure, (<*>), and join
07:11:11 <dolio> The instances, that is, not SHE.
07:11:23 <kmc> Functor, Pointed, Applicative, Monad
07:11:32 <kmc> (Mappable, Pointed, Applicative, Joinable ?)
07:12:33 <Axman6> any then you'd have class (Applicative m, Joinable m) => Monad m where?
07:12:36 <dolio> Or Functor, Semigroupal, Monoidal, Monad
07:12:46 <kmc> no, I'd just rename Monad to Joinable
07:13:01 <dolio> Why?
07:13:09 <kmc> not actually a good idea
07:13:17 <kmc> but it's more consistent with Pointed and Applicative
07:13:20 <ciaranm> so everyone would have to rewrite all their "this is what a monad is!" tutorials
07:13:21 <kmc> being adjectives and all
07:13:23 <dolio> Oh, to be more enterprise-ready.
07:13:27 <kmc> that too
07:13:37 <kmc> class LINQ m where { join :: m (m a) -> m a }
07:14:27 <ciaranm> there's a Pointed? when did that happen?
07:14:34 <dolio> It didn't.
07:14:36 <Axman6> there isn't
07:14:49 <kmc> i'm sure it's in one of edwardk's libs
07:14:52 <Axman6> when will we get -XSensibleClasses?
07:15:06 <kmc> but yeah, i'm talking about a hypothetical happy future
07:15:41 <kmc> is there any sense talking about things that have 'join' but not 'pure'/'return'?
07:15:41 <dolio> I'm like 75% convinced that the class with just (<*>) is a better intermediate between Functor and Applicative than the class with just pure.
07:15:55 <dolio> However, the name that edwardk gives it is terrible.
07:15:56 <kmc> oh?
07:15:57 <ciaranm> does haskell ever break backwards compatibility? or does implementing this require something like c++0x's aborted 'auto concept_map' feature?
07:16:16 <kmc> ciaranm, Haskell 2010 is not backwards compatible with Haskell 98
07:16:26 <kmc> though the differences are pretty small
07:16:28 <Axman6> yeah, no n+k ptterns
07:16:33 <kmc> libraries are pretty easy to rejigger
07:16:53 <kmc> GHC ships with a 'haskell98' package that exports the modules required by the H98 Report
07:16:58 <kmc> and is hidden by default
07:17:05 <kmc> and becomes visible when you pass -XHaskell98 i guess
07:18:03 <kmc> also, fixes to the Monad hierarchy, or the Num hierarchy, can be provided simply as hackage packages
07:18:10 <kmc> and indeed there are a few alternative preludes like this
07:18:25 <kmc> but there's a network effect
07:18:36 <kmc> people writing or using libraries want the API to be widely compatible
07:20:47 <ciaranm> has anyone looked into a nice way of handling things that could be an instance of something in two or more ways?
07:22:16 * hackagebot wai-extra 0.4.1.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.4.1.2 (MichaelSnoyman)
07:24:37 <dolio> kmc: I think edwardk also has join without pure.
07:24:52 <dolio> But again, I hate the names. I just calls the class "Join" or "Bind".
07:25:11 <dolio> He just calls, even.
07:26:53 <gab_> Hi theree
07:27:05 <dolio> (Pure f, Bind f, Plus n, Times n, Negate n, Seventeen n) => ...
07:27:11 <gab_> just trying the "tryhaskell.org" tutorial
07:27:21 <byorgey> hi gab_
07:27:40 <byorgey> gab_: feel free to ask any questions in here
07:28:01 <gab_> byorgey: thanks!
07:28:19 <_Ray_> So applicative defines how functions are applied to members of the type, while monad defines how they are composed to produce/take members of the type?
07:29:15 <byorgey> ciaranm: state-of-the-art for that is to make a newtype for each instance, and use the newtype package to help you do stuff with them
07:29:19 <byorgey> @hackage newtype
07:29:19 <lambdabot> http://hackage.haskell.org/package/newtype
07:30:04 <ciaranm> byorgey: i keep hoping one day someone will come up with something nicer
07:30:12 <byorgey> _Ray_: that seems a bit confused
07:30:19 <_Ray_> Could be :)
07:30:34 <byorgey> Applicative f  gives you   f (a -> b) -> f a -> f b
07:31:01 <byorgey> and Monad f  gives you  f a -> (a -> f b) -> f b
07:31:28 <_Ray_> So an enclosed function is applied to an enclosed value. So how to apply functions in the functor to data in the functor, correct?
07:31:55 <byorgey> _Ray_: right. you could even say that Applicative f gives you "function application within an 'f' context"
07:32:00 <_Ray_> Whereas monad adds join?
07:32:16 <byorgey> _Ray_: yes
07:32:33 <_Ray_> So fusion of values in contexts
07:32:44 <byorgey> _Ray_: with Monad it is a bit harder to see "intuitively" what extra power join/bind gives you over Applicative
07:33:37 <byorgey> _Ray_: the way I like to think of it is that with Applicative you must fix the structure of your computation ahead of time; with Monad the structure of your computation can depend on intermediate values
07:33:54 <_Ray_> by structure do you mean order of function application?
07:35:44 <byorgey> _Ray_: no, but I'm finding it difficult to explain what I really mean =)
07:36:38 <illissius_> kmc: Mappable, Sequenceable, Runnable? where Sequenceable lets you define any of sequence :: f a -> f b -> f (a, b) (yes, I know there's already a different function called sequence), <*>, or map2 (liftA2), and join gets renamed to runInner, runOuter, or plain run or something and Runnable lets you define either that or bind
07:36:48 <illissius_> not sure what to do with pure/return/Pointed.
07:37:14 <byorgey> _Ray_: The key is that the (a -> m b) argument to (>>=) lets you *pick* which computation 'm b' to run next, based on a value of a (an output from the previous 'm a' computation)
07:37:33 <byorgey> _Ray_: with only Applicative you cannot choose what to do next based on previous results
07:37:34 <_Ray_> well, join :: M M a -> M a, right? So if I had x :: M a, an appliccative M, and f :: a -> M b, I could first elevate f using return giving me a M (a -> M b), then apply it to x, giving me something of type M M b. With join, I convert it to M b. So that's how one gets >>= (bind) out of <*> and join :o
07:38:14 <byorgey> _Ray_: sure, but you actually don't need <*>
07:38:24 <byorgey> you can get away with just return and join
07:38:33 <_Ray_> hrm yeah, was thinking about it
07:38:53 <byorgey> er, sorry, fmap and join
07:39:05 <Axman6> yeah i was gonna say, i couldn't figure out how :(
07:39:10 <byorgey> hehe
07:39:11 <Axman6> and you were making me feel dumb!
07:39:54 <byorgey> Expert Haskell hackers can implement (>>=) in terms of just return and intercalate
07:40:02 <Axman6> :t \f -> join . fmap f
07:40:03 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
07:40:21 <byorgey> yep, that's flip (>>=)
07:40:22 <_Ray_> Well, I had f :: a -> M b, so I could give you with fmap f a function f :: M a -> M M b. Then I can join the result with join $ fmap f, giving me an M b
07:40:28 <Axman6> yeah
07:40:32 <byorgey> _Ray_: exactly.
07:41:02 <byorgey> _Ray_: note that your previous process replaced the 'fmap' by 'return' followed by '<*>', and this is in fact a law of Applicative
07:41:14 <byorgey> that  f `fmap` x === pure f <*> x
07:41:41 <_Ray_> well yeah, that should make sense
07:41:54 <byorgey> mapping a function over a value in a context is the same as first lifting the function into the context, then doing application within the context
07:41:55 <_Ray_> at least, using my go-to monad instance, []
07:42:16 <byorgey> =)
07:42:24 <applicative> _Ray_ yes, but the point is that with Applicative you don't need f :: a -> m b  , mf :: m (a -> b) is good enough, no?
07:42:27 <byorgey> trying out examples is always the best policy =)
07:42:54 <byorgey> applicative: good enough for what?
07:43:08 <applicative> good enough to go from m a to m b
07:43:26 <byorgey> applicative: _Ray_ was just explaining how to implement (>>=) in terms of fmap and join
07:44:12 <_Ray_> What is <*>'s name for lists?
07:44:34 <applicative> yes, I was trying to elaborate what you said a few lines before "_Ray_: The key is that the (a -> m b) argument to (>>=) lets you *pick*  etc
07:44:37 <byorgey> it doesn't have a special name that I know of
07:44:58 <_Ray_> wee, it was in Control.Applicative :D
07:46:57 <_Ray_> >  let f = \x -> x+1; fl = [f]; l = [1,5,7] in fl <*> l
07:46:59 <lambdabot>   [2,6,8]
07:47:40 <byorgey> > [succ, (*10)] <*> [1,5,7]
07:47:41 <lambdabot>   [2,6,8,10,50,70]
07:47:41 <_Ray_> will need to think of what fl is, in the interpretation of lists as nondeterministic computations. [f, g] means a computation that could either be f or g, nondeterministically?
07:47:50 <byorgey> _Ray_: right.
07:48:06 <stevenmarky> Hello. I'm trying to install the latest cabal from source on Ubuntu and having a lot of problems, anyone willing to help?
07:48:28 <byorgey> _Ray_: why should atomic values have all the fun?  Functions can be nondeterministic too =)
07:48:33 <cheater> how is a list nondeterministic?
07:49:02 <applicative> > let fs = map (+) [0..3]; xs = [0..3] in fs <*> xs
07:49:03 <lambdabot>   [0,1,2,3,1,2,3,4,2,3,4,5,3,4,5,6]
07:49:08 <byorgey> cheater: one way to think of a list of type [a] is as a nondeterministic value of type a
07:49:16 <byorgey> cheater: i.e. the list holds all the possible values
07:49:39 <cheater> does it?
07:49:42 <applicative> with repetitions representing greater likelihood...
07:49:50 <cheater> [1, 2] does not hold all the possible values of Int.
07:50:05 <_Ray_> applicative, hrm, why did that work? Does fs have the correct type?
07:50:06 <Axman6> it's nondeterministic in that it doesn't have a single 'a' answer
07:50:19 <byorgey> cheater: sorry, I didn't phrase that well.  I just meant that [1,2] represents a value that could be either 1 or 2
07:50:29 <applicative> fs is [(+0), (+1)..], the functions
07:50:35 <_Ray_> Ooooohhhh
07:50:48 <applicative> or rather [(0+)..] I guess
07:50:49 <_Ray_> Yeah, don't know why I read that as map (+1)
07:51:00 <cheater> byorgey, ok, so a list represents separate inputs, or states, or something like that.
07:51:04 <cheater> they're separate.
07:51:08 <byorgey> cheater: right
07:51:17 <cheater> how does the "nondeterminism" come up?
07:51:34 <_Ray_> [f(x), f(y)] is both possible results you could get by computing f X, if X could be either x or y
07:51:49 <cheater> nondeterministic for me means if you perform the same computation twice with the same input, the probability of getting the same output is less than 1.
07:51:56 <Axman6> cheater: because the exactly result is not determined, there are many possible results
07:51:57 <applicative> cheater the list is the distribution
07:52:13 <Axman6> exact*
07:52:26 <Axman6> damn, time to sleep again i see -_-
07:52:26 <byorgey> it doesn't give you *actual* nondeterminism, i.e. your Haskell program itself will not be nondeterministic
07:52:29 <cheater> ok but that's still not non-determinism
07:52:32 <byorgey> it is just a *model* of nondeterminism
07:52:44 <cheater> show me a function which given the same input twice will produce different outputs
07:52:49 <byorgey> it will deterministically compute all the possible results of a nondeterministic computation
07:52:51 <Axman6> yes it is, the one result hasn't been determined, so it is nondeterministic
07:53:01 <cheater> if my list is [1, 2] is 1 considered the same input as 2?
07:53:04 <Axman6> cheater: that's not what nondeterminism means really
07:53:07 <byorgey> cheater: see what I just said above
07:53:18 <applicative> cheater, if a coin toss determines which of [(+0),(+1)] will be the function and another determines which of [0,1] will be the argument, then
07:53:19 <_Ray_> cheater, [1, 2] represents a value that is nondeterministically 1 or 2
07:53:30 <cheater> _Ray_, ok.
07:53:38 <applicative> >  [(+0),(+1)] <*>  [0,1] -- is the possible values
07:53:38 <lambdabot>   [0,1,1,2]
07:53:42 <Axman6> the actual value hasn't been determined
07:53:45 <_Ray_> so you could consider what [f(1), f(2)] is. it's a value that is nondeterministically f(1) or f(2)
07:54:00 <cheater> yeah ok
07:54:22 <_Ray_> so if X is a nondeterministic value with some possible actual values when you measure it, say [x_1, x_2, ... ], then [f(x_1), f(x_2), ... ] is the result of computing f on that nondeterministic value
07:54:27 <applicative> cheater, I found this way of talking a bit of a menace when I first bumped into it, too :)
07:54:38 <cheater> i find that a weak model though, i suggest augumenting every element of the list with a probability weight.
07:54:46 <_Ray_> cheater: you can do that with repetitions
07:55:00 <cheater> not adequately
07:55:22 <_Ray_> but f is usually a deterministic computation - say, f :: Int -> Int. so the way you make a function "know how to play with nondeterminism". after all, I can't just compute f [1,2], [1,2] is of type [Int], not Int. so that's where you have map :: (a -> b) -> ([a] -> [b])
07:55:42 <Axman6> it's not a difficult thing to compute given the distribution a list represents
07:55:45 <applicative> cheater it's a bit primitive, the list also has the irrational element of order, for example.
07:55:52 <stevenmarky> I managed to build the cabal lib, now there's an error configuring network-2.3.0.2... the following dependencies are missing: base >=3 && <4.4. my base is 4.4.
07:56:05 <_Ray_> given a deterministic function f, it can now act in a nondeterministic context, because map f is of type [a] -> [b]. in our case, [Int] -> [Int]. so map f [1,2] = [f(1), f(2)]
07:56:21 <Axman6> stevenmarky: you shouldn't ne installing the cabal lib, it comes with GHC
07:56:24 <applicative>  stevenmarky grrr
07:56:44 <applicative> are you using the Haskell Platform?
07:56:45 <byorgey> cheater: sure, that's a good idea; a list of values paired with probabilities also forms a monad
07:57:00 <byorgey> cheater: I've seen it written about in a blog post or two somewhere, I forget where off the top of my head
07:57:11 <applicative> stevenmarky: like Axman6 says, you shouldn't build it yourself
07:57:14 <stevenmarky> I'm not using the haskell platform, I'm trying to build from source because I'm trying to get some of the latest things like safe haskell
07:57:15 * hackagebot AspectAG 0.3.4 - Attribute Grammars in the form of an EDSL  http://hackage.haskell.org/package/AspectAG-0.3.4 (MarcosViera)
07:57:17 <cheater> it was called "probability 101, 4th grade"
07:57:21 <cheater> :)
07:57:35 <cheater> probability trees
07:58:01 <Axman6> i wonder how useful people would fine a probability monad
07:58:04 <Axman6> find*
07:58:23 <Botje> i think there's already several of them
07:58:24 <applicative> stevenmarky: Safe is in ghc-7.2 no?
07:58:33 <cheater> it's not really probability it's just a composable value
07:58:42 <cheater> which gwta compoaws by multiplication
07:58:50 <cheater> which gets composed by multipliation
07:58:53 <cheater> or something.
07:58:54 <applicative> stevenmarky: what OS are you using?
07:58:55 <cheater> anyways
07:59:05 <byorgey> stevenmarky: hmm, I wonder what is requiring network-2.3.0.2
07:59:13 <stevenmarky> ubuntu.
07:59:16 <byorgey> stevenmarky: if you have the latest version of base you will need network-2.3.0.5
07:59:46 <byorgey> stevenmarky: which version of Cabal did you build?
07:59:59 <stevenmarky> I download cabal-install-0.10.2
08:00:09 <stevenmarky> downloaded*
08:00:55 <byorgey> wait, what command are you issuing when you get the error about network-2.3.0.2?
08:01:10 <luite> stevenmarky: for ghc 7.2.1, download cabal-install from the darcs repository
08:01:14 <Axman6> i don't believe cabal-install has been upgraded for GHC 7.2, has it?
08:01:36 <byorgey> ah, excellent, someone who knows what they are talking about =)
08:01:47 * byorgey was just poking in the dark
08:01:48 <applicative> yes ")
08:01:55 * Axman6 -> sleep
08:02:22 <stevenmarky> I'll try that, thanks.
08:02:23 * byorgey -> school
08:02:28 <applicative> stevenmarky, I take it you saw the monochrom's principles on http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
08:04:06 <ciaranm> gah. every time i try to work out how to implement <*> in terms of >>= and return my brain melts. and then i see the answer and go "oh, yeah, that's obvious"...
08:04:21 <stevenmarky> applicative: I didn't see that, I'll have a read.
08:04:34 <kmc> @src ap
08:04:34 <lambdabot> ap = liftM2 id
08:04:39 <kmc> @src liftM2
08:04:40 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:04:55 <applicative> your case is more difficult since you need to revise the plaform libraries with the darcs cabal-install
08:05:16 <roconnor> mf `ap` mx = do { f <- mf; x <- mx; return (f x) }
08:05:44 <roconnor> @undo do { f <- mf; x <- mx; return (f x) }
08:05:44 <lambdabot> mf >>= \ f -> mx >>= \ x -> return (f x)
08:06:50 <ciaranm> oh, yeah, using <- is how it's obvious. obviously!
08:07:12 <applicative> > [(+1), (+2)] >>= \f -> [1,2] >>= \x -> return (f x)
08:07:13 <lambdabot>   [2,3,3,4]
08:07:26 <Botje> ciaranm: intuitively, <*> takes a function wrapped in a functor f (a -> b) and value wrapped in the same functor f a to produce a wrapped value f b
08:07:38 <applicative> first pick out the functions, then pick out the arguments, then return the applications
08:07:57 <Botje> so you want to unwrap the function, unwrap the value, and then return apply and wrap
08:08:20 <ciaranm> yeah, i was trying to write it in terms of >>= directly and was forgetting about >>
08:08:27 <Axman6> :t \mf mx -> do {x <- mx; f <- mf; return (f x)}
08:08:28 <lambdabot> forall (m :: * -> *) t b. (Monad m) => m (t -> b) -> m t -> m b
08:08:33 <roconnor> >> isn't used
08:08:35 <Axman6> >_>
08:09:31 <kmc> how does it look if you use 'join' and not (>>=) ?
08:10:30 <Axman6> :t \f -> fmap (return . f)
08:10:32 <lambdabot> forall a (m :: * -> *) a1 (f :: * -> *). (Monad m, Functor f) => (a1 -> a) -> f a1 -> f (m a)
08:10:41 <Axman6> bleh
08:11:26 <roconnor> mf `ap` mx = join (fmap (\f -> fmap (f $) mx) mf)
08:11:30 <roconnor> or something like that
08:11:35 * Axman6 -> sleep
08:11:51 <kmc> @type \mf mx -> join (fmap (\f -> fmap (f $) mx) mf)
08:11:52 <lambdabot> forall a b (m :: * -> *). (Functor m, Monad m) => m (a -> b) -> m a -> m b
08:12:03 <kmc> interesting
08:12:04 <roconnor> kmc: I'm worried I might get the effects in the wrong order
08:12:08 <kmc> @pl \mf mx -> join (fmap (\f -> fmap (f $) mx) mf)
08:12:08 <lambdabot> (join .) . flip (fmap . flip fmap)
08:12:10 <kmc> ah
08:12:35 <roconnor> kmc: which won't show up as a type error
08:12:50 <kmc> right
08:15:02 <co_dh> greeting! how many functors are there in Haskell? I know it's unlimited. Is there 1 functor for each unary type function? ( as List, Maybe ?)
08:15:36 <jhon> jhon
08:15:36 <roconnor> co_dh: not always.  data Dom X = Dom (X -> X) isn't a functor.
08:15:41 <applicative> are all (*->*) things Functors
08:15:51 <roconnor> hmm
08:15:53 <applicative> ah, no way of course
08:16:34 <applicative> instance FUnctor Dom x where fmap f (Dom g) = ?
08:17:14 <kmc> (a -> b, b -> a) -> Dom a -> Dom b
08:18:12 <kmc> what about a type constructor that's a Functor in two ways?
08:18:18 <roconnor> @free (a -> a) -> a
08:18:19 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
08:18:24 <roconnor> @free Dom :: (a -> a) -> a
08:18:24 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
08:18:31 <roconnor> @free dom :: (a -> a) -> a
08:18:32 <lambdabot> f . g = h . f => f (dom g) = dom h
08:18:35 <zygoloid> kmc: the Functor laws don't allow that
08:19:13 <kmc> why not?
08:19:36 <applicative> data Intward a = Intward (a -> Int) ; instance Functor Intward where fmap a2b (Intward a2int) = ?
08:19:59 <roconnor> applicative: also not a functor (but rather a cofunctor?)
08:20:01 <kmc> applicative, that's a contravariant functor
08:20:08 <applicative> ^^^ here they speak of a contrava
08:20:10 <ciaranm> [] can be a functor in at least two ways, can't it? as nondeterminism or as a ziplist?
08:20:17 <applicative> like they said, co_dh
08:20:18 <kmc> (a -> b) -> (Intward b -> Intward a)
08:20:25 <roconnor> ciaranm: the fuctor aspect is the same in both cases
08:20:32 <kmc> ciaranm, those are two different Applicative instances, but the fmap coincides
08:20:35 <roconnor> ciaranm: for any given data type there is at most 1 functor instance.
08:20:36 <kmc> in both cases it's just map
08:20:38 <jhon> mmmmmmmm
08:20:42 <jhon> no entender
08:20:43 <zygoloid> @free fmap :: (a -> b) -> F a -> F b
08:20:44 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
08:20:54 <kmc> how do you prove that Functor instances must be unique?
08:20:58 <applicative> co_dh you are clearly making our friends' day....
08:21:12 <roconnor> kmc: you can use the free theorem for fmap to do this.  I wrote this out in -cafe one day
08:21:17 <zygoloid> kmc: ^^ substitute f = g; h = id; k = id. $map_F f = fmap f, for all functions of that type.
08:21:23 <zygoloid> (assuming that fmap id = id)
08:21:41 <kmc> what's $map_F mean?
08:21:54 <applicative> variable fmap definition?
08:22:08 <zygoloid> kmc: that's a functorial map for type F
08:22:23 <kmc> i.e. fmap itself?
08:22:45 <roconnor> kmc: it is the unique fmap :P
08:22:55 <kmc> it seems like @free is already presupposing a unique fmap
08:23:07 <zygoloid> kmc: $map_F is any law-abiding fmap (supposing such a thing exists)
08:23:09 <roconnor> kmc: or if you don't know it is unique yet, it is some fmap satifying the functor laws.
08:23:20 <zygoloid> what that proves is that if you have another law-abiding fmap, they are equal
08:23:48 <kmc> okay
08:24:08 <kmc> i'm not too convinced, because i don't know how @free proves its theorems
08:24:15 <roconnor> kmc: http://www.haskell.org/pipermail/libraries/2011-February/015964.html
08:24:56 <roconnor> there I prove that if f is a functor than anything of type (a -> b) -> f a -> f b is fmap
08:25:03 <applicative> @free map_F' :: (a -> b) -> F a -> F b
08:25:03 <lambdabot> g . h = k . f => $map_F g . map_F' h = map_F' k . $map_F f
08:25:38 <roconnor> oh wait that isn't true
08:26:20 <roconnor> I only prove that if F is a functor and foo :: (a -> b) -> F a -> F b is such that foo id = id then foo = fmap
08:27:01 <applicative> your premise is that foo makes an okay fmap instance
08:27:31 <roconnor> by premise do you mean hypothesis, or conclusion?
08:27:42 <illissius_> what's the thingie you can write in ghc's trac/wiki to make it insert your username and a timestamp... ? (or does that only work on haskellwiki?)
08:27:56 <copumpkin> roconnor: fmap f [] = []; fmap f (x:xs) = f x : f x : fmap f xs
08:28:05 <copumpkin> oh
08:28:08 <roconnor> copumpkin: yep
08:28:08 <copumpkin> that fails doesn't it
08:28:29 <Axman6> what about foo f = fmap (undefined . id)
08:28:29 <roconnor> copumpkin: I had to correct myself to note that foo id = id is required.
08:28:30 <applicative> hypothesis, but actually you do state it not ideally?  i was interpreting using the last line of the Patterson's email
08:28:45 <roconnor> Axman6: undefined doesn't count
08:28:56 <Axman6> eh, i guess that's still thwarted by the second rule anyway
08:28:59 <roconnor> I'm reasoning fast and loose
08:29:14 <copumpkin> I could probably throw together a proof in agda
08:29:15 <copumpkin> but meh
08:29:16 <copumpkin> :)
08:29:17 <applicative> in the context it is fine, given two Functor instances fmap = foo and fmap = goo, then we have that foo id = id, goo id = id, then we argue as you do, convincingly
08:29:21 <Axman6> spherical, frictionless cow reasoning!
08:29:29 * zachk smiles
08:29:36 <roconnor> applicative: ah yes.
08:29:43 <roconnor> applicative: I didn't explicitly state that last step
08:30:05 <applicative> it was expedited by completely clear
08:33:13 <copumpkin> edwardk: by the way, if you put up a github repo with your sweeter mpfr stuff, I'd be happy to contribute some more wrappers and bindings and whatever else
08:33:25 <co_dh> unfortunately, I cannot follow you guys. :( I guess I have to read theorem for free again. So what is the final result of the question: Is there 1 functor for kind (*->*)? if not, then under what condition will there be functor? ( by remove function in type function? like the data Dom a = Dom ( a -> a ) ?
08:33:38 <copumpkin> writing boring and repetitive cmm code has a certain zen-like appeal to it
08:34:46 <zachk> whats cmm
08:35:01 <maloi> shall i use the packages distributed by debian for ghc/cabal as a beginner?
08:36:22 <co_dh> maloi: that one is quite old, but you can use it.
08:37:23 <co_dh> @free r : [a] -> [a]
08:37:23 <copumpkin> zachk: the last language GHC generates during compilation, before doing platform-specific assembly
08:37:23 <lambdabot> Extra stuff at end of line
08:37:33 <copumpkin> @free r :: [a] -> [a]
08:37:33 <lambdabot> $map f . r = r . $map f
08:38:04 <co_dh> why it's a :: instead of : ?
08:38:14 <zachk> ahh thank you copumpkin
08:38:23 <rwbarton> haskell writes :: where the rest of the world writes :
08:38:25 <mauke> co_dh: why would it be :?
08:38:41 <Eduard_Munteanu> zachk: also known as C--
08:38:55 <Eduard_Munteanu> (or better known as)
08:38:58 <rwbarton> (or at least the part of the rest of the world that matters)
08:39:53 <illissius_> Eduard_Munteanu: it's only based on / inspired by / evolved from C--, not actually C--.
08:40:11 <co_dh> mauke: my bad, just coming back from type theory books, and forget about haskell use :: for typing.
08:40:13 <Eduard_Munteanu> Oh, hm.
08:40:26 <mauke> is it C--++?
08:40:43 <illissius_> i'm not sure what C--++ would be
08:40:47 <illissius_> C++-- is Java
08:40:47 <Eduard_Munteanu> @karma C--
08:40:48 <lambdabot> C-- has a karma of 4
08:40:56 <Eduard_Munteanu> Seemingly it is :D
08:41:34 <kmc> illissius_, correct :)
08:42:03 <Eduard_Munteanu> co_dh: I don't really understand your question... are you asking when is a thing of kind * -> * a functor?
08:42:04 <kmc> co_dh, some functors have functions in their representation, e.g.
08:42:11 <kmc> data F a = F (Int -> a)
08:42:28 <kmc> the main thing is that the functorial type parameter can't appear in a contravariant position
08:42:32 <kmc> e.g. on the left of (->)
08:42:59 <co_dh> Eduard_Munteanu: Yes.
08:43:04 <kmc> although it's a parity thing, i.e. ((a -> T) -> T) is fine
08:43:42 <kmc> is (->) the only "primitive" way to get contravariance in Haskell?
08:43:52 <co_dh> kmc: ah yes, I remember that. contravariant position. Thanks.
08:44:02 <Eduard_Munteanu> It must obey Functor laws, and I think that's enough to get a functor in the CT sense, more or less.
08:44:38 <_Ray_> How should I read "(join .) . intersperse"?
08:44:52 <Eduard_Munteanu> @unpl (join .) . intersperse
08:44:53 <lambdabot> (\ d i -> (intersperse d i) >>= \ e -> e)
08:45:10 <mauke> _Ray_: imagine function arguments hitting it from the right
08:45:16 <illissius_> :t intercalate
08:45:18 <lambdabot> forall a. [a] -> [[a]] -> [a]
08:45:30 <kmc> _Ray_, (f .) . g  ≡  \x y -> f (g x y)
08:45:30 <_Ray_> (Yes, this is :pl of intercalate)
08:45:36 <_Ray_> oh
08:46:10 <Eduard_Munteanu> :t (?f .)
08:46:11 <lambdabot> forall a b (f :: * -> *). (?f::a -> b, Functor f) => f a -> f b
08:46:27 <Eduard_Munteanu> :t (?f Prelude..)
08:46:28 <lambdabot> forall b c a. (?f::b -> c) => (a -> b) -> a -> c
08:46:40 <_Ray_> so when you'd write a $ in pointwise, you write ( .) in pointfree?
08:46:48 <mauke> no
08:47:15 <_Ray_> this would be like f $ g $ x y
08:47:23 <kmc> no
08:47:23 <mauke> no, it wouldn't
08:47:25 <ziman> _Ray_, this pattern is sometimes also called (.:). It's a composition of a two-argument function, whose result (after application to the two parameters) will be transformed with a one-argument function.
08:47:38 <kmc> f $ g $ x y ≡ f (g (x y))
08:48:00 <_Ray_> and isn't that the same as f (g x y)? you first evaluate g x y, then f of that?
08:48:08 <kmc> «g (x y)» ≠ «g x y»
08:48:16 <_Ray_> (where "first" isn't actually order of evaluation, just precedence)
08:48:16 <kmc> g x y ≡ (g x) y
08:48:45 <kmc> «g (x y)» is going to apply the function x to the argument y, and then g to the result of that
08:48:49 <_Ray_> oh
08:48:53 <c_wraith> actually, order of evaluation in haskell is pretty clear.  f (g x y) is going to evaluate f, then if it finds its argument is needed, it will evaluate g.
08:49:22 <ziman> > let (.:) = (.).(.) in ((+1) .: (*)) 3 4
08:49:23 <_Ray_> even if I'm using ! in g?
08:49:25 <lambdabot>   13
08:50:04 <Eduard_Munteanu> Or boobies with a zit, it seems :P
08:50:06 <ziman> then intercalate = join .: intersperse
08:50:21 <c_wraith> the order of the evaluation of f (g x y) is quite clear.  It doesn't matter what you do in g.  If f is defined as f _ = 5, g will not be evaluated.
08:51:42 <_Ray_> hrmph, in "let (.:) = (.).(.)", what is it saying about f .: g? that it's (f.).(g.)?
08:51:52 <kmc> no
08:52:00 <kmc> (.:) f g = ((.) . (.)) f g
08:52:12 <kmc> i mean, there's no special rule here
08:52:17 * hackagebot SoccerFun 0.5.2 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.5.2 (JanRochel)
08:52:27 <kmc> it's defining a function (.:) as the application of the operator (.) to arguments (.) and (.)
08:52:34 <_Ray_> :t ((.) . (.))
08:52:35 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:52:41 <mauke> (.)(.)(.)
08:52:44 <kmc> :t let (.) = (Prelude..) in (.).(.)
08:52:45 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:52:54 <_Ray_> ah
08:53:22 <mauke> let eccentricaGallumbits = (.)(.)(.)
08:53:37 <kmc> you can reduce «((.) . (.)) f g» by hand
08:53:46 <kmc> and work out that it's the same as (f .) . g
08:53:51 <kmc> which is the same as \x y -> f (g x y)
08:56:13 <applicative> @unpl (.).(.)
08:56:13 <lambdabot> (\ i b c f -> i (b c f))
08:56:25 <applicative> why work it out for hand when it can be worked out for you by hand
08:56:38 <_Ray_> good exercise :p
08:56:39 <_Ray_> (f . g) x = f (g x). then ((.) . (.)) f g is the same as ((.) ((.) f)) g
08:58:10 * applicative thinks that though the next step is plain it is somehow a little harder ...
08:58:25 <mizu_no_oto> If you have a value of type IO (IO a), join and unsafePerformIO are the exact same function, right?
08:58:40 <_Ray_> well
08:58:59 <_Ray_> semi guess, will formalize in a bit, ((.) ((.) f)) g is ((.) f) . g
08:59:35 <c_wraith> mizu_no_oto: not at all.
08:59:47 <_Ray_> well it's not a guess, a + b is just (+) a b. "by awesome finite induction in something", a . b is just (.) a b
09:00:04 <mizu_no_oto> c_wraith: What's going to be the difference?
09:00:11 <c_wraith> mizu_no_oto: join produces an action that will execute the outer action, then the inner one.  unsafeperformIO just executes the outer action and returns the inner one.
09:00:29 <c_wraith> mizu_no_oto: those are very different things, in practice
09:00:42 <kmc> (unsafePerformIO x) `seq` () will do some IO
09:00:46 <kmc> (join x) `seq` () won't
09:00:51 <mizu_no_oto> ah
09:01:17 <kmc> it all comes back to the distinction between evaluation and execution
09:01:26 <parcs> why would unsafePerformIO be any different with an IO (IO a) rather than an IO a?
09:01:29 <c_wraith> not only kmc's, point, but also things like when and how often the outer action is executed.
09:02:04 <kmc> parcs, if you're working from the common but ultimately wrong model that IO is a "tag" on things to indicate that they're "impure"
09:02:12 <c_wraith> parcs, I think the guess was driven mostly by type signature.
09:02:36 <c_wraith> because they do have the same type signature, in that case
09:03:00 <saati> kmc: what is the not wrong way to think about it?
09:03:38 <c_wraith> saati: that values of type "IO a" represent computations that, when executed, return a value of type a, and may do anything at all as a side-effect.
09:03:48 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
09:03:57 <kmc> an (IO T) isn't a "tagged" T; it's not a T at all
09:04:01 <kmc> it's a recipe for getting T's
09:04:10 <kmc> it might get executed more than once, getting a different T each time
09:04:13 <kmc> it might never get executed
09:04:58 <kmc> values of IO type are imperative programs
09:05:37 <_Ray_> reducing that got me ((.) f) . g, and ((.) f) is the function which takes a g, and returns a function that, when given an x, returns f (g x). so it's like (f .). the end result is (f .) . g
09:05:59 <kmc> one source of confusion is that Haskell values of type (F T) needn't contain any T
09:06:13 <kmc> [T] contains zero or more T's; (Maybe T) contains 0 or 1 T
09:06:18 <kmc> but (Int -> T) doesn't contain any T's
09:06:36 <kmc> neither does (IO T)
09:06:44 <dolio> That's not really a good example.
09:06:47 <mauke> data No t = Empty
09:06:56 <kmc> neither does... what mauke said
09:07:00 <dolio> Int -> T contains 2^n Ts.
09:07:08 <dolio> T -> Int doesn't contain any Ts, though.
09:07:14 <mauke> No T contains no tea
09:07:17 <_Ray_> the syntax (f .) was somewhat confusing. i had to look back at instances where I've seen (1+) used as a function, which is the same as ((+) 1)
09:07:37 <kmc> this probably goes in the category of "things 'about monads' that are confusing and also not really about monads"
09:08:26 <kmc> i think "monad" is not such a hard concept itself, but it's frequently the first time people are asked to put together a lot of other concepts
09:09:36 <zachk> i think monads by examples is alot better at the beginning
09:11:33 <ocharles> Hey, having a bit of trouble with my design here atm... I have a function, search :: Document d -> DocumentType -> String -> [d], and I want to format different [d]s differently. For example, (search Book) :: String -> [BookResult], and (search Publisher) :: String -> [PublisherResult]
09:11:56 <ocharles> that's all ok so far, but it's when I actually want do something like: formatResults, GHC can't infer that d ~ BookResult
09:12:26 <ocharles> i'm not sure if what I want to do is really achievable
09:12:57 <osaunders> Do next/prev word (C-M-f and C-M-b) work for people using GHCi?
09:13:20 <ocharles> I think maybe I'm going to have to result [SearchResult], and have BookResult and PublisherResult constructors of SearchResult
09:13:55 <_Ray_> so continuing the reduction, I have "(f .) . g". Let's hindley miller this shit. Say f :: b -> c. Then (f .), which is (.) f, is of type forall a. (a -> b) -> (a -> c). Since this is receiving the output of g (in saying (f .) . g), g must be of type d -> (a -> b). So this expression will be of the form d -> a -> c.
09:16:48 <_Ray_> Then (f .) . g is the same as \x y -> (f .) . g x y, which is the same as (f .) (g x y) <=> ((.) f) (g x y) <=> f $ g x y.
09:17:36 <_Ray_> (I think I counted parameters right, but fucked up the typing.)
09:18:41 <mizu_no_oto> Oh, yeah - one other quick question:  How exactly to you implement unsafeCoerce  using unsafePerformIO?
09:19:22 <mizu_no_oto> The documentation mentions that it can be done, but doesn't give any hints as to how
09:19:43 <mauke> mizu_no_oto: wtf :: IORef a
09:20:03 <mauke> wtf = unsafePerformIO (newIORef undefined)
09:20:17 <MrFerret> Anyone know f a Nick Dyson. Teaches Haskell at Staffordshire University?
09:20:25 <dolio> unsafeCoerce x = let r :: IORef a ; r = unsafePerformIO undefined in unsafePerformIO (writeIORef r x >> readIORef r)
09:21:18 <mizu_no_oto> ah
09:21:24 <mizu_no_oto> that makes sense
09:21:26 <mizu_no_oto> thanks
09:22:23 <saati> kmc, c_wraith: thanks for the clarification
09:22:46 <osaunders> Does anyone know if there is a reference for the line editing commands that will work with GHCi?
09:25:31 <co_dh> osaunders: read manual on readline
09:25:46 <osaunders> co_dh: Which readline implementation?
09:26:07 <co_dh> osaunders: I don't know. I guess it's gnu readline
09:27:23 <c_wraith> ghci quit using readline a long time ago
09:27:27 <c_wraith> it uses haskeline now
09:27:51 <co_dh> nice to know.
09:29:12 <osaunders> c_wraith: Thanks for that info
09:29:14 <ClaudiusMaximus> http://trac.haskell.org/haskeline/wiki/CustomKeyBindings
09:29:35 <ClaudiusMaximus> might be useful to add the missing stuff
09:29:56 <c_wraith> and by "a long time ago" I mean "I think in 6.10.2"
09:32:29 <osaunders> ClaudiusMaximus: Yeah, I just found that page thanks
09:35:56 <applicative> ghci doesn't use haskeline? I can't remember
09:36:38 <applicative> oh i see, we agree it does
09:40:09 * applicative remembers when haskeline appeared; Peyton Jones' expression of gratitude to J Jacobsen began "If I had a dollar for [every mind-numbing license dispute arising from the use of readline or editline]..."
09:44:57 <kmc> hooray for mind-numbing license disputes
09:45:51 <kmc> mizu_no_oto, ML has a special type-system rule ( http://mlton.org/ValueRestriction ) to prevent the same problem
09:46:00 <kmc> because in ML it's routine to create reference cells as a result of evaluation
09:46:51 <kmc> this basically says applicative forms aren't generalized, i think
09:55:19 <kmc> so what do you think the result of a generic 'diff' operation on algebraic data should look like?
09:56:35 <copumpkin> kmc: I think sclv already has a library to do that on hackage?
09:56:52 <copumpkin> http://hackage.haskell.org/packages/archive/Diff/0.1.3/doc/html/Data-Algorithm-Diff.html
09:57:19 <copumpkin> oh, you mean for arbitrary non-list data?
09:59:27 <b0fh_ua> Hello, I need help with PCRE regext - how to get list of all matches for particular pattern in text?
10:02:41 <kmc> copumpkin, yes
10:03:03 <kmc> i'd probably layer it on top of http://hackage.haskell.org/package/patience because, you know, not invented here
10:03:22 <kmc> i actually wrote 'patience' because i had an app where 'Diff' didn't perform acceptably
10:03:23 <copumpkin> oh :)
10:03:57 <copumpkin> it seems like you'd need it to work off a functor fixed point if you wanted to make it generic
10:05:22 <kmc> i was going to use GHC 7.2's "Generic" class
10:05:30 <kmc> or failing that something like SYB
10:07:55 <kmc> i guess i should try to understand the 'gdiff' package before i do this
10:08:01 <kmc> it's kind of intense though
10:11:02 <romanm> Can I use IO Stuff inside Happstack?
10:11:05 <romanm> like MySQL?
10:11:26 <romanm> e.g through Database.HSQL
10:12:20 <parcs> yep
10:12:31 <chrisdone> why does 1/0 evaluate to infinity and not throw an exception?
10:12:38 <romanm> How?
10:12:44 <copumpkin> chrisdone: because it's a float
10:12:45 <applicative> >  map head $ group $ map ((=~ "(foo[a-z]*bar|quux)"):: String -> String)  $ tails  "foodiebar, fooquuxbar, foodiebar"  --hows that for idiot
10:12:45 <lambdabot>   ["foodiebar","fooquuxbar","quux","foodiebar",""]
10:12:46 <applicative> ic
10:12:47 <copumpkin> > 1 `div` 0
10:12:48 <lambdabot>   *Exception: divide by zero
10:12:54 <romanm> simpleHTTP won't let me use IO
10:12:55 <copumpkin> ah, the wonders of IEEE
10:13:01 <chrisdone> ahh, it's an IEEE thing
10:13:14 <copumpkin> but still
10:13:18 <copumpkin> > 1 / 0 :: Rational
10:13:19 <lambdabot>   *Exception: Ratio.%: zero denominator
10:13:33 <applicative> that means its very professional, unlike eg lazy IO
10:13:37 <copumpkin> it just happens that the default is one of them there EIEIO types
10:13:43 <chrisdone> copumpkin: do you know why they chose that?
10:13:51 <copumpkin> why the IEEE committee did?
10:13:53 <chrisdone> for IEEE floating point numbers
10:13:53 <chrisdone> yeah
10:14:11 <copumpkin> they wanted to be able to represent most common math operations, I guess
10:14:18 <copumpkin> with a single type
10:14:30 <copumpkin> not all languages even have exceptions
10:14:39 <kmc> some fpu's will let you turn on exceptions
10:14:40 <copumpkin> so they need a distinguished value within the type to mark that you divided by 0
10:14:44 <chrisdone> ahhh
10:14:50 <kmc> it's hard to reliably manipulate the fpu control word in GHC Haskell, though
10:14:54 <copumpkin> yeah, but catching FP exceptions is weird in most languages, too
10:15:15 <kmc> > (1.0 / 0) > 9000
10:15:16 <lambdabot>   True
10:15:30 <kmc> when you divide by zero you still get a signed result
10:15:41 <mauke> > 1 / 0 > 9000
10:15:42 <lambdabot>   True
10:15:55 <kmc> chrisdone, part of the goal is to paper over the finite precision of floating point
10:16:21 <kmc> 0 might really be a positive number of unknown but really tiny magnitude
10:16:36 <copumpkin> haskell/ghc doesn't actually conform with IEEE, either
10:16:40 <kmc> so 1/0 is Infinity, a positive number of unknown but really large magnitude
10:16:47 <kmc> that's also why you have +0 and -0
10:17:00 <parcs> romanm: wrap your IO actions with liftIO
10:17:26 <parcs> :t liftIO
10:17:27 <lambdabot>     Ambiguous occurrence `liftIO'
10:17:27 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
10:17:27 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
10:18:31 <parcs> :t Control.Monad.Trans.liftIO
10:18:32 <lambdabot> forall a (m :: * -> *). (Control.Monad.Error.MonadIO m) => IO a -> m a
10:22:04 * chrisdone_ shakes fist at router
10:32:57 <dainanaki> Is there a module that can serialize instances of Data?
10:34:36 <chrisdone_> @hoogle gshow
10:34:36 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
10:35:16 <dainanaki> when I said serialize, I meant to binary.
10:35:23 <dainanaki> sorry, I should have been more clear.
10:37:07 <dainanaki> I guess I'm really looking for automatic derivation of Storable.
10:38:34 <dainanaki> aha, found it.
10:40:00 <chrisdone_> share with the rest of the class!
10:40:09 <dainanaki> http://hackage.haskell.org/package/binary-generic
10:41:21 <chrisdone_> thanks
10:42:06 <kmc> args@(~[file]) <- getArgs  -- ugly pattern of the day
10:42:45 <zygoloid> hmm, what does ~ on a list pattern do? is every implied pattern match lazy?
10:43:01 <applicative> the reserved uses of both ~ and @ are incredibly hideous. I go to absurd lengths to avoid the eminently useful @
10:43:19 <chrisdone_> zygoloid: ~[file] is merely sugar for ~(file:[]), no?
10:43:42 <applicative> you commit to it's being a singleton, no?
10:44:12 <zygoloid> > let f ~[a,b,c] = a in f [0,1,2,3]
10:44:13 <lambdabot>   *Exception: <interactive>:3:4-17: Irrefutable pattern failed for pattern [a...
10:44:15 <applicative> why would i want separate names args and file if I can write args as [file]
10:44:16 <zygoloid> chrisdone_: looks like
10:44:17 <kmc> dmead, syb is "Scrap your boilerplate"; you can find the original papers about it
10:44:25 <dmead> ah thanks
10:44:28 <dmead> like gadts?
10:44:30 <dmead> or more useful?
10:44:32 <zygoloid> chrisdone_: i was half expecting it to be ~(file:~[])
10:44:41 <kmc> dmead, don't see the relation to gadts
10:44:49 <kmc> they solve completely different problems
10:44:52 <dmead> alright
10:45:00 <kmc> ~((:) file [])
10:45:24 <applicative> dmead, i'd say less useful on the groundless ground that GADTs are great and I haven't had occasion to learn syb
10:45:42 <kmc> i wrote that pattern because i wanted to check the length of 'args' and give a better error message than "Pattern match failure in do'
10:45:44 <chrisdone_> yeah, ~ is a nice symbol i could use
10:45:46 <dmead> so should i look at gadts or syb then?
10:46:01 <kmc> dmead, how did gadts come into this?
10:46:03 * applicative proposes LYB, the new Love Your Boilerplate library
10:46:18 <kmc> gadts and syb are totally different things
10:46:19 <dmead> i just want to avoid having to write like 100 lines it'll take to move around on src-exts strees
10:46:30 * applicative proposes BYB, the new Boilerplate Your Boilerplate library
10:46:31 <kmc> read the syb papers
10:46:44 <mauke> BYOB
10:47:14 <dmead> thanks :D
10:47:37 <applicative> right, bring your own.... our preprocessor checks for and deletes boilerplate that meets your irksomely minute specs
10:47:41 <kmc> boilerplate your boilerplate? like http://ws.apache.org/xmlrpc/apidocs/org/apache/xmlrpc/server/RequestProcessorFactoryFactory.html ?
10:47:53 <merijn> applicative: Isn't that called Java?
10:48:00 <merijn> kmc: Could be worse
10:48:02 <kmc> dmead, how did GADTs come up?
10:48:10 <kmc> > cycle "Factory"
10:48:10 <lambdabot>   "FactoryFactoryFactoryFactoryFactoryFactoryFactoryFactoryFactoryFactoryFact...
10:48:13 <merijn> kmc: Could be AbstractAbstractRequestProcessorFactoryFactory
10:48:23 <kmc> well it is abstract already
10:48:29 <kmc> being as it's an interface
10:48:42 <kmc> i guess i don't know enough Java to know when you put the fact that something is abstract into the nname
10:48:42 <merijn> :t fix
10:48:43 <lambdabot> forall a. (a -> a) -> a
10:48:45 <roconnor> @type runST
10:48:46 <applicative> > fix ("FactoryFactory" ++) -- is more like it
10:48:47 <lambdabot> forall a. (forall s. ST s a) -> a
10:48:47 <lambdabot>   "FactoryFactoryFactoryFactoryFactoryFactoryFactoryFactoryFactoryFactoryFact...
10:49:19 <merijn> fix (\x -> "Abstract" ++ x ++ "Factory")
10:49:22 <merijn> > fix (\x -> "Abstract" ++ x ++ "Factory")
10:49:24 <lambdabot>   "AbstractAbstractAbstractAbstractAbstractAbstractAbstractAbstractAbstractAb...
10:49:30 <dainanaki> lol
10:49:52 <applicative> this new omega-Java sounds good, merijn
10:49:54 <kmc> > iterate (\x -> "Abstract" ++ x ++ "Factory") "Foo"
10:49:55 <lambdabot>   ["Foo","AbstractFooFactory","AbstractAbstractFooFactoryFactory","AbstractAb...
10:50:06 <dmead> kmc: its easy to write walkers for gadts, but that would require me to rewrite the strutures i'm working with
10:50:26 <kmc> why is it easier for GADTs?
10:50:47 <applicative> > map ("static interface" ++) $ iterate (\x -> "Abstract" ++ x ++ "Factory") "Foo"
10:50:49 <lambdabot>   ["static interfaceFoo","static interfaceAbstractFooFactory","static interfa...
10:50:56 <applicative> > map ("static interface " ++) $ iterate (\x -> "Abstract" ++ x ++ "Factory") "Foo"
10:50:57 <lambdabot>   ["static interface Foo","static interface AbstractFooFactory","static inter...
10:51:43 <Botje> > replicateM 5 ["Abstract","Pattern","Factory","Singleton","Bean","Facade","Proxy" ] !! 123
10:51:44 <lambdabot>   ["Abstract","Abstract","Factory","Singleton","Bean"]
10:51:44 <parcs> @check (==) <*> (concat . pure)
10:51:45 <lambdabot>   "OK, passed 500 tests."
10:52:37 <roconnor> @scheck (==) <*> (concat . pure
10:52:38 <lambdabot>  Unbalanced parentheses
10:52:41 <roconnor> @scheck (==) <*> (concat . pure)
10:52:43 <lambdabot>   "OK, passed 500 tests."
10:53:06 * applicative considers that somehow QuickCheck seems more like its genuinely testing something when it's not pointfree
10:53:24 <merijn> QuickCheck requires you to be careful regardless
10:53:33 <merijn> @check \x -> x == reverse x
10:53:34 <lambdabot>   "OK, passed 500 tests."
10:53:40 <merijn> whoops...
10:54:15 <dmead> ivan, good catch. thanks
10:54:59 * applicative busily verifies that he's verifying
10:55:10 <BlankVerse> runnning yesod devel on a bare new project , i get
10:55:11 <BlankVerse> devel.hs: socket: unsupported operation (Address family not supported by protocol)
10:55:15 * applicative busily verifies that he's verifying that he's ...
10:55:20 <BlankVerse> has it something to do with ipv6?
10:55:59 <peteriserins> preflex: seen conal
10:55:59 <preflex>  conal was last seen on #haskell 1 day, 21 hours, 6 minutes and 59 seconds ago, saying: Axman6: ping
10:57:04 <merijn> BlankVerse: Which OS?
10:57:28 <BlankVerse> merijn: arch
10:57:43 <BlankVerse> merijn: i have disable ipv6 module
10:57:49 <BlankVerse> merijn: is that a cause?
10:58:09 <merijn> hmm, seems unlikely. But I don't know Yesod that well, so can't say for sure
10:58:36 <edwardk> copumpkin: will do. i'm currently debating about renaming everything
10:58:40 <leino> I'm wondering if anyone as worked with the Numeric.Algebra package?
10:58:48 <merijn> On semi-related note: Why does everyone always disable IPv6 :((( Do they want to be stuck with IPv4 forever?....
10:58:56 <edwardk> copumpkin: mainly coz 'fixed-precision' bugs me as a name when its really 'rounded'
10:59:09 <leino> edwardk: are you Edward Kmett by any chance?
10:59:13 <edwardk> yes
10:59:26 <leino> ooh, can I ask you some questions about Numeric.Algebra?
10:59:30 <edwardk> sure
10:59:34 <leino> ok
11:00:07 <edwardk> one of these days i need to just switch to ekmett ;)
11:00:08 <leino> edwardk: thanks, first of all, I'm a haskell newb
11:00:48 <edwardk> leino: we all had to start somewhere ;)
11:00:56 <leino> ok, I have a type for rational numbers, and I'm trying to get your system of type classes to swallow it
11:01:09 <edwardk> i'm adding the field of fractions soon
11:01:40 <edwardk> to describe the field of fractions i need gcd rings, so i'm not quite there
11:01:49 <leino> I started by doing 'instance Field Q' (the type is Q from the package called 'constructive-algebra')
11:01:56 <edwardk> but you should be able to talk about rational numbers over some particular ring at least
11:02:06 <leino> and then I followed all of the messages about what else I should derive instances of
11:02:33 <Rc43> Hi.
11:02:37 <leino> yeah, one of those messages was for Ring
11:02:41 <edwardk> there are some layers missing below field and division ring. in particular i'm missing prufer domains, gcd rings, etc.
11:03:03 <leino> edward: and it got all the way down to where I have to derive instances for Modules over some type called Natural
11:03:14 <edwardk> ah those are fairly easy
11:03:33 <edwardk> Natural is in the semigroups package
11:04:06 <Rc43> Can anybody tell me how to identify parse error (because of using `read') in code? E.g. for IOErrors I can use something like `isDoesNotExistError err'.
11:04:07 <leino> edwardk: hold on, I'll go and check on hackage
11:04:32 <byorgey> Rc43: don't do that, use 'reads' instead
11:04:52 <leino> edwardk: http://hackage.haskell.org/packages/archive/algebra/2.0.1/doc/html/Numeric-Algebra.html#g:34
11:04:53 <edwardk> the Natural instance just uses "sinnum" which came for free
11:05:19 <leino> are we talking about the object I linked to?
11:05:20 <byorgey> Rc43: you can, for instance, define  readMaybe :: Read a => a -> Maybe String; readMaybe a = case reads a of [(x,[])] -> Just x; _ -> Nothing
11:05:22 <Rc43> byorgey, return value of what it could parse and tail, right?
11:05:25 <edwardk> yes
11:05:30 <byorgey> Rc43: right
11:05:32 <edwardk> i forgot i had it re-exported fron Numeric.Algebra
11:05:46 <leino> edwardk: ok, Natural doesnt have a constructor or what?
11:05:49 <edwardk> (it was originally in the Algebra package, then I moved it upstream to the semigroups package
11:06:24 <edwardk> you can import Numeric.Natural.Internal to get at the constructor (unsafely) or you can use toNatural and fromIntegral to work with it
11:06:34 <edwardk> Numeric.Natural.Internal is in the semigroups package
11:06:39 <Rc43> byorgey, it seems to be good solution, but I write code for my problem at university and I should show taht I can use exceptions handling, too. Can I handle this exception?
11:06:53 <edwardk> but multiplying by the natural is easy, just use sinnum
11:07:06 <byorgey> Rc43: I have no idea, sorry
11:07:07 <kmc> netsplit :(
11:07:16 <leino> edwardk: still confused.. how can I see Numeric.Natural.Internal on hackage?
11:07:18 <Rc43> byorgey, ok, thanks.
11:07:28 <edwardk> http://hackage.haskell.org/packages/archive/algebra/2.0.1/doc/html/Numeric-Algebra.html#v:sinnum is the operation you want to use to define your module
11:07:32 <kmc> so nubBy is potentially slow... and (Set.toList . Set.fromList) is potentially faster, but requires that Eq/Ord for my type coincide with what I want to deduplicate by
11:07:35 <edwardk> just use (.*) = sinnum
11:07:39 <copumpkin> edwardk: I see, yeah
11:07:43 <kmc> is there a deduplication function that uses user-specified ordering
11:07:44 <edwardk> (sinnum is icelandic for times)
11:07:47 <kmc> or should i just use Set with a newtype
11:07:53 <copumpkin> edwardk: you gonna make a separate package from hmpfr then? or still build on what they have?
11:07:59 <edwardk> http://hackage.haskell.org/packages/archive/semigroups/0.8/doc/html/Numeric-Natural-Internal.html
11:08:12 <edwardk> copumpkin: i'm not touching hmpfr, it'll wind up a completely separate package
11:08:18 <copumpkin> cool
11:08:18 <edwardk> a.) i want sane bindings
11:08:30 <edwardk> b.) i don't want to step on their toes
11:08:38 <copumpkin> :P
11:08:45 <copumpkin> they can steal the prim code if they want it too
11:08:56 <edwardk> yeah, but i don't really see the point ;)
11:09:00 <byorgey> kmc: I don't know of one, I'd just use Set + newtype
11:09:08 <edwardk> their api doesn't make any sense
11:09:11 <leino> edwardk: ok, I'll see if I can proceed now.. thank you, and thank you very much for writing that algebra package. it needed to be done!
11:09:38 <edwardk> leino: it is very much a work in progress. the rest of the contents of constructive-algebra will probably find their way in soon or later
11:10:53 <edwardk> copumpkin: Numeric.Rounded or Numeric.Rounding ?
11:11:12 <edwardk> Rounded Down Double seems pretty straight forward
11:11:32 <copumpkin> you mean for the whole type?
11:11:35 <edwardk> yeah
11:11:49 <edwardk> Rounded rounding precision
11:11:55 <copumpkin> ah okay
11:12:00 <copumpkin> so Double wouldn't be the usual Double
11:12:06 <copumpkin> it'd be more like D8
11:12:09 <edwardk> where precision can be any type that Reifies a number
11:12:15 <copumpkin> ah
11:12:26 <edwardk> and then i make Double reify a precision of 53 bits
11:12:33 <edwardk> (including implicit 1)
11:12:38 <copumpkin> I see
11:13:05 <ClaudiusMaximus> what about algorithms where you want to increase precision incrementally during runtime?
11:13:10 <edwardk> that way Rounded Down Double and Rounded Down Float work, but you can reify an arbitrary precision and get Rounded Down s for some ReifiesPrecision s
11:13:18 <copumpkin> yeah
11:13:21 <copumpkin> that seems nice
11:13:27 <edwardk> claudius: that is where you need to use the reify trick
11:13:38 <copumpkin> how efficient is that stuff at runtime?
11:13:45 <edwardk> all but free
11:13:49 <Rc43> c
11:13:54 <edwardk> it becomes a dictionary with a tagged int, which is represented as a Int
11:14:05 <edwardk> you can't get any cheaper
11:14:20 <copumpkin> nice :)
11:14:29 <ClaudiusMaximus> hm, not sure i know what the "reify trick" is
11:14:34 <copumpkin> it's crazy shit
11:14:35 <rwbarton> it always amazes me how efficient that trick is
11:14:39 <edwardk> see the reflection package on hackage
11:14:42 <ClaudiusMaximus> ok
11:15:29 <edwardk> http://hackage.haskell.org/packages/archive/fixed-precision/0.4.0/doc/html/Numeric-Fixed.html#v:reifyPrecision
11:15:46 <edwardk> was my old version, built on top of MPFR bindings that don't work
11:16:03 <copumpkin> hah
11:16:20 <edwardk> nowadays i'd use Proxy p
11:16:23 <ezyang> Hmm, I wonder how you get an "untouchable inside the constraints" type error.
11:16:26 <edwardk> but otherwise its pretty sound
11:17:34 <copumpkin> I'm excited to see this materialize
11:18:01 <edwardk> ClaudiusMaximus: the trick is basically that you can transform a number into a universally quantified type level natural, you can turn a list of numbers into a type level list of type level naturals, and then you can turn a storable into a list of numbers
11:18:09 <edwardk> finally stableptrs are storable
11:18:13 <edwardk> so you can turn any term into a type
11:18:18 <edwardk> and then you can reflect it back down
11:18:25 <ClaudiusMaximus> interesting
11:18:31 <edwardk> and you can play some games so it doesn't leak any stableptrs to do so
11:19:12 <kmc> edwardk, what should i read to learn about that trick?
11:19:28 <kmc> "Functional Pearl: Implicit Configurations"?
11:19:39 <mightybyte> @seen baguasquirrel
11:19:39 <preflex>  baguasquirrel was last seen on #haskell 7 days, 20 hours, 8 minutes and 21 seconds ago, saying: augur: sometimes writing up math in any language can be obtuse. diagrams can be useful in those situations.
11:19:39 <lambdabot> Unknown command, try @list
11:19:40 <edwardk> so you ultimately get: reify :: a -> (forall r. Reifies r a => Proxy r -> w) -> w;  and reflect :: Reifies r a => Proxy r -> a  where data Proxy t = Proxy
11:19:47 <edwardk> kmc: yeah
11:20:01 <edwardk> kmc: i blogged about an intermediate version that used Tagged as well
11:20:20 <edwardk> my current approach is closer to the original though
11:20:29 <edwardk> using Proxy instead of undefined
11:21:18 <edwardk> the nice thing is you can use it to make types that depend on terms, at least in a nested context.
11:21:34 <kmc> yeah, i don't see how this works wrt the compile-time / run-time stage boundary
11:21:38 <ClaudiusMaximus> can't say i "get i", is my assumption that "all types must be known at compile time" inherently flawed?
11:22:01 <edwardk> so its handy when you want to make a Num for numbers modulo some prime, or when you want a monoid that consists of tabulations of some particular DFA
11:22:01 <rwbarton> the key is polymorphic recursion allows you to build up dictionaries at runtime
11:22:09 <edwardk> ClaudiusMaximus: what rwbarton said
11:22:20 <ClaudiusMaximus> ah
11:22:53 <edwardk> you can make a class Nat t where nat :: Proxy t -> Integer; and make instances for Z and (S n) where n is a Nat right?
11:23:27 <copumpkin> (and you can do that even if S is a newtype)
11:23:35 <edwardk> then with that you can make reifyNat :: Int -> (forall n. Nat n => Proxy n -> w) -> w
11:24:21 <edwardk> where you take the user supplied function which must work for all nats, and call it with an appropriate number of S's applied to Z
11:24:38 <edwardk> the dictionary that gets passed in does the right 'nat' call
11:25:22 <edwardk> basically it gives you a kind of nested scope in which types within that scope can depend on terms from outside of that scope
11:25:42 <edwardk> which seems scary but works quite nicely
11:26:14 <edwardk> the code for reflection is just this idea made manifest
11:26:30 <ClaudiusMaximus> ok, it's still fuzzy in my mind, but if it works to compile code once and then provide a command line argument to give some precision, that's cool
11:26:31 <edwardk> with a bunch of workarounds for compiler inlining bugs, etc.
11:26:43 <edwardk> it does
11:27:17 <kmc> edwardk, rwbarton ah, that makes sense
11:27:20 <kmc> more than before anyway :)
11:27:24 <kmc> i will re-read the paper
11:27:43 <edwardk> the code is shorter than the explanation in many ways
11:27:43 <kmc> at the risk of sounding dumb, doesn't -XImplicitParams solve the same problem?
11:27:48 <edwardk> no
11:27:49 * ClaudiusMaximus will also read the paper
11:28:00 <edwardk> it kinda does but i can't make an instance of Monoid that uses an implicit param
11:28:30 <edwardk> whereas its trivial for me to make instance Reifies s Int => Monoid (Mod s) where ....
11:29:03 <edwardk> such that data Mod s = Mod Int
11:30:57 <peteriserins> my ghci/ghc cannot find Control.Parallel; the version is 6.12.3. What could be the problem?
11:32:44 <parcs> you don't have tho parallel package installed
11:32:47 <parcs> cabal install parallel
11:33:48 <peteriserins> parcs: ah, thanks, thought it was in the standard library
11:35:51 <edwardk> updated reflection to allow the passing of things other that Proxy to reflect
11:35:58 <Rc43> import qualified Control.Exception as E
11:35:59 <edwardk> er other than
11:36:01 <Rc43> `E.catch` (\err -> case E.fromException err of --...
11:36:14 <Rc43> why compiler can't get type of err?
11:36:26 <Rc43> ( Ambiguous type variable `e0' in the constraint:       (E.Exception e0) arising from a use of `E.fromException' )
11:36:32 <edwardk> which fromException did you want?
11:36:45 <edwardk> you're asking it to try to pick an exception type for you
11:36:47 <Rc43> Control.Exception
11:37:00 <rwbarton> is there a way to scope a binding in an instance declaration over the definitions of multiple methods?
11:37:00 <Rc43> Yes.
11:37:28 <rwbarton> maybe by writing (foo, bar) = ... where x = ...?
11:37:31 * hackagebot reflection 0.5 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.5 (EdwardKmett)
11:37:48 <edwardk> fromException :: Exception e => SomeException -> Maybe e -- which choice of e did you want? ghc doesn't know
11:38:21 <Rc43> edwark, oh, really, didn't notice
11:38:31 <edwardk> you probably want something like catchJust
11:38:37 <edwardk> catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
11:39:17 <Rc43> edwarks, i will look for more appropriated functions, thanks
11:39:21 <edwardk> or handle
11:39:25 <edwardk> handle :: Exception e => (e -> IO a) -> IO a -> IO a
11:39:28 <Rc43> edwark, I mean more than my
11:39:48 <Rc43> edwar, handle is nice
11:39:53 <edwardk> (handle is probably the one you want)
11:40:07 <Rc43> edwardk, yeah, it is good
11:40:29 <edwardk> rwbarton: nope
11:40:44 <rwbarton> too bad, it could be useful in conjunction with this reflection trick
11:40:59 <edwardk> yeah, i often use reflection to do things like
11:41:28 <rwbarton> like maybe you want to cache a table of modular inverses mod p
11:41:29 <edwardk> instance Refies r (a -> a -> a) => Semigroup (Semi r a)
11:41:35 <edwardk> yep
11:41:47 <rwbarton> (that one is ok because of recip, but in general)
11:41:51 <edwardk> thats okay though
11:41:52 <Rc43> edwardk, also, what should I write (withou creating separated function) to become able write something like ` `E.catch` (\err -> putStrLn "..." ' ?
11:41:54 <rwbarton> ok, thanks
11:41:57 <edwardk> you can bake it into the dictionary
11:42:02 <Rc43> edwardk, it can't get type
11:42:11 <rwbarton> right, if I get to design the type class
11:42:20 <edwardk> and each attempt to access it will still get the shared table
11:42:23 <edwardk> no
11:42:32 <rwbarton> oh
11:42:32 <edwardk> the type you are Reifying
11:43:01 <Rc43> ?
11:43:03 <edwardk> Reifies s MyComplexDataTypeWithInverseTable => ...
11:43:47 <rwbarton> ah
11:43:49 <edwardk> rc43: you just want to show the err?
11:43:55 <rwbarton> so I'd have a pair (Int, Array Int Int) or so
11:43:58 <edwardk> yeah
11:44:03 <edwardk> that works dandy
11:44:12 <Rc43> edwardk, for example, yes
11:44:12 <rwbarton> neat
11:44:14 <edwardk> only one copy of the dictionary gets constructed, for the lexical scope
11:44:50 <edwardk> rc43: the example in the Control.Exception docs is about showing
11:45:04 <Rc43> edwardk, ok, i will look
11:46:18 <edwardk> rwbarton: in the functional pearl paper they represent certain modulus forms differently as well, for instance any even modulus is don't using the chinese remainder theorem to multiply 2^n * the odd factor
11:46:26 <edwardk> er is done
11:51:43 <dmead> @hoogle Data
11:51:44 <lambdabot> module Data.Data
11:51:44 <lambdabot> Data.Data class Typeable a => Data a
11:51:44 <lambdabot> Data.Data dataCast1 :: (Data a, Typeable1 t) => c (t d) -> Maybe (c a)
11:53:03 <Rc43> edwadk, do you know how can I identify exception as parse exception (function `read')?
11:53:31 <copumpkin> edwardk: anyway, poke me later if you want me to write any more cmm or boring shit, cause I love boring shit
11:53:34 <edwardk>  not sure what Read when it throws exceptions, if i had to gamble i'd guess it just calls error
11:53:54 <edwardk> copumpkin: definitely. i need to package what little i have. i didn't get much chance to work on it yesterday
11:54:07 <edwardk> i mostly muddled through the entangling of sign and precision
11:54:21 <edwardk> then put it down and spent time with amy for a bit
11:54:43 <Rc43> edwardk, it talks *** Exception: Prelude.read: no parse "
11:54:46 <edwardk> copumpkin: i'll bundle it up and ping you, should only be an hour or so
11:54:55 <copumpkin> sure, no rush :)
11:55:03 <edwardk> Rc43: then its just calling 'error' so you won't be able to split those out easily
11:55:06 <copumpkin> I got some SQL shit to do anyway
11:55:37 <Rc43> edwardk, but it is catched with Control.Exception.catch
11:55:51 <Rc43> edwadk, or you are talking about that I can't identify?
11:56:22 <Rc43> edwardk, except string analysis
11:59:24 <edwardk> rc43: that
11:59:39 <edwardk> rc43: what i meant is that it isn't turned into a particuar 'parse exception' or anything like that
12:00:04 <Rc43> edwardk, ok
12:15:59 <Athas> Is it possible to impose a class restraint on a type family declaration in a class definition?
12:17:23 <Athas> Oh, yes, by imposing the constraint on the class itself.  Nifty.
12:17:30 <kmc> class (Ord (Bar a)) => Foo a where { type Bar a :: * }
12:17:32 <kmc> like that?
12:17:41 <Athas> Yes, exactly.
12:17:49 <kmc> yeah, this is a pretty recent GHC feature
12:17:51 <kmc> 7.0 or 6.12 i think
12:18:03 <Athas> Bigger numbers and all that.
12:18:17 <Athas> Very useful.  I think I like type families a lot.
12:31:54 <medfly> hi
12:32:00 <Jeanne-Kamikaze> yo
12:34:29 <kmc> sigh
12:35:12 <kmc> it's an uncomfortable amount of boilerplate to use 'newtype' to create a Set based on a custom Ord
12:36:09 <c_wraith> Couldn't you just do it once, involving wrapping Set?  Then at least it'd be less boilerplate the second time. >_>
12:36:30 <c_wraith> Though really, I wonder if there's any way to apply the newtype package.
12:37:03 <c_wraith> djahandarie: the newtype package was yours, right?  If it can be used for kmc's case, that'd make a compelling example
12:37:13 <c_wraith> @hackage newtype
12:37:13 <lambdabot> http://hackage.haskell.org/package/newtype
12:37:16 <kmc> oh, nice
12:37:43 <kmc> you could create a Set type that takes the ordering as a function
12:38:00 <kmc> the semantics of switching up your choice of ordering on the same Set would be undefined
12:38:05 <kmc> but it'd be fine for my purpose
12:38:09 <kmc> which is just (S.toList . S.fromList)
12:38:11 <Athas> This is one point where SML functors really shine.
12:38:34 <kmc> now can we use -XDeriveGeneric to derive Newtype? ;)
12:38:50 <Saizan> what kind of boilerplate do you need for that?
12:39:23 <kmc> instance Newtype (Endo a) (a -> a) where { pack = Endo; unpack (Endo a) = a }
12:39:28 <Saizan> map unwrap . that . map wrap
12:39:33 <hpc_> kmc: how about generalized newtype deriving :P
12:39:37 <kmc> hehe
12:40:16 <djahandarie> kmc, there is template haskell for getting Newtype instances
12:40:22 <djahandarie> See newtype-th, I think
12:40:25 <kmc> yeah
12:41:04 <kmc> so I could say:  ala Foo (S.toList . S.fromList)  -- ?
12:41:22 <djahandarie> :t S.toList . S.fromList
12:41:23 <lambdabot> forall a. (Ord a) => [a] -> [a]
12:41:31 <djahandarie> No.
12:41:33 <djahandarie> :t ala
12:41:33 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
12:42:24 <kmc> ah, 'under' then?
12:42:35 <djahandarie> Possibly, not sure what you're doing, just walked in.
12:42:40 <djahandarie> :t under
12:42:41 <lambdabot> forall o n n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> (n -> n') -> o -> o'
12:42:58 <kmc> :t under Identity (S.toList . S.fromList)
12:42:59 <lambdabot>     Couldn't match expected type `Identity o'
12:42:59 <lambdabot>            against inferred type `[a]'
12:42:59 <lambdabot>     In the second argument of `(.)', namely `S.fromList'
12:43:04 <c_wraith> djahandarie: all he really wants is a Set TypeWithCustomOrdInstance
12:43:14 <c_wraith> djahandarie: and the ability to use that relatively cleanly
12:43:28 <djahandarie> Ah... hmm...
12:44:19 <c_wraith> I was wondering if newtype could eliminate a lot of the boilerplate.
12:44:52 <djahandarie> Could I have an example of that boilerplate?
12:47:41 <Saizan> you could add a "Newtype n o => Newtype [n] [o]" instance, then under would work
12:48:22 <copumpkin> Functor f, Newtype n o => Newtype (f n) (f o)
12:48:27 <copumpkin> that's getting scary though
12:48:49 <Saizan> that's scary for a lot of reasons
12:49:19 <djahandarie> Maybe I should rename this to 'isomorphism' :)
12:49:56 <Saizan> with Newtype it's directional, i like that
12:50:50 <Saizan> s/directiona/asymmetric/ -- better word
12:51:06 <djahandarie> Maybe... 'morphism'? :p
12:51:16 <djahandarie> I jest though, naming it that makes it confusing
12:51:26 <kmc> the tricky thing that took me a sec to understand is that the first arg to 'ala' is ignored
12:51:32 <arpunk> hi people, is there a way to cleanup the cabal database (for user)?
12:51:35 <kmc> it's only to set the type and get the right instance of Newtype
12:51:43 <kmc> syntactically nice though
12:52:18 <kmc> but it means «ala All» ≡ «ala (All . not)» which is weird
12:53:03 <Saizan> arpunk: rm ~/.ghc/
12:53:05 <applicative> arpunk, rm -r ~/.cabal is too much for you? :)
12:53:09 <Saizan> -fr
12:53:55 <applicative> you need both ./ghc has the package registry or whatever its called.
12:54:06 <kmc> all i really want is nubByOrd :: (Ord a) => [a] -> [a]
12:54:13 <kmc> er
12:54:24 <kmc> all i really want is nubByOrd :: (a -> a -> Ordering) -> [a] -> [a]
12:54:35 <djahandarie> Ah
12:54:37 <arpunk> applicative: i did that, and ghc-pkg complains i have broken depts
12:54:38 <kmc> the other one would be "nubOrd" and is just (S.toList . S.fromList)
12:54:48 <arpunk> Saizan: thank you, will do
12:54:53 <kmc> maybe it's in some package
12:54:54 <applicative> arpunk did you do like saizan said too?
12:55:02 <applicative> oh i see
12:55:37 <kmc> @hoogle (a -> a -> Ordering) -> [a] -> [a]
12:55:38 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
12:55:38 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
12:55:38 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
12:55:51 <arpunk> applicative: probably I needed both dirs removed, thanks
12:56:03 <djahandarie> sortBy group head?
12:56:10 <kmc> yeah, that'll do
12:56:22 <kmc> thanks :)
12:56:22 <applicative> arpunk, if .ghc/<<version>>/package.conf.d is there, that's what ghc-pkg is reading (or half of it, there's the global one)
12:56:25 <djahandarie> np :P
12:56:37 <kmc> :t map head . group . sortBy ?f
12:56:38 <lambdabot> forall a. (Eq a, ?f::a -> a -> Ordering) => [a] -> [a]
12:57:30 <djahandarie> I wonder if group fuses at all
12:58:36 <djahandarie> Nope
13:00:23 <zzo38> How can I export a Haskell function to a C program if the Haskell function can return multiple values of different types?
13:00:42 <djahandarie> Even stream fusion doesn't fuse group. I think that should be possible though
13:00:42 <kmc> Haskell functions can't do that
13:01:30 <Athas> zzo38: that's never going to be easy to call from C.
13:01:49 <Athas> I assume you mean that the return value is of a product type.
13:01:54 <Athas> Er, sum type.
13:03:02 <kmc> a C function that wants to "return" a sum type would probably take a pointer to a struct of { tag value, union}
13:03:12 <kmc> and write to that
13:03:18 <kmc> returning void
13:03:21 <kmc> so write a Haskell function with that type
13:03:51 <Athas> Yes, you have to write the wrapper manually on the Haskell side.  I don't think GHC exposes tag values.
13:04:58 <kmc> even if GHC exposed its tag values, there's no guarantee they coincide with anything the C code wants
13:05:06 <zzo38> I want to have a C program that calls a Haskell function, the Haskell function can have multiple possible return types, such as a tuple or an Either. But only some types are permitted as foreign types, so how can I do that?
13:05:17 <kmc> "the Haskell function can have multiple possible return types"
13:05:20 <kmc> that is not possible
13:05:31 <zzo38> I mean such as a tuple or Either
13:05:31 <rwbarton> "I don't know what the return type of the Haskell function is"?
13:05:34 <kmc> a function of type (A -> B) only returns things of type B
13:05:56 <byorgey> zzo38: is your function polymorphic in the return type?
13:06:08 <zzo38> byorgey: No.
13:06:16 <byorgey> zzo38: what is the type of your function then?
13:06:17 <kmc> zzo38, you're asking how to export a function that returns a tuple?
13:06:25 <kmc> and, separately, how to export a function that returns an Either value?
13:06:27 <zzo38> kmc: Yes.
13:06:30 <kmc> ok
13:06:32 <zzo38> kmc: Yes, that too.
13:06:41 <kmc> for Either, read what I said above
13:07:06 <kmc> for tuple: C functions that want to return two values will typically return at least one of them through a pointer passed in
13:07:26 <kmc> (A -> (B, C))  ⇒  (A -> Ptr B -> Ptr C -> IO ())
13:08:08 <kmc> there's no single right answer
13:08:46 <kmc> you should start with the C type of the C function as exported
13:09:41 <kmc> translating that to a Haskell type you "foreign export" is simple and mechanical
13:09:54 <kmc> then you need to convert / wrap your existing Haskell function to have that type
13:10:24 <kmc> this is basically a question of C API design not Haskell implementation
13:10:35 <kmc> any C API you choose will be implementable in Haskell
13:12:44 <Panaetius> does anyone know the difference between the json and json2 packages on hackage? Both seem to be able to parse and create json data and to map it to haskell objects.
13:13:08 <kmc> actually, there's about 9,000 packages on Hackage that can do that
13:13:18 <kmc> i don't have a good summary of how they compare :/
13:13:41 <Panaetius> hum ok. are there any you could recommend?
13:14:22 <kmc> http://www.downforeveryoneorjustme.com/http://hackage.haskell.org
13:14:45 <kmc> i forgot which one i used, but if you look up the 'jspath' package, it's whichever one that uses
13:14:50 <Panaetius> well, that answers my second question :)
13:15:38 <Panaetius> jspath sounds promising, does that "path" part come from similarities with xpath?
13:15:46 <kmc> slight similarities
13:15:51 <kmc> it's simple but useful
13:15:59 <zzo38> I am a bit confused. Do I need to export functions such as:  foreign_fst x = fmap fst (deRefStablePtr x)  (assume "foreign_fst" is not polymorphic and returns IO of a marshallable type)
13:16:25 <kmc> zzo38, why are you asking us if you need to export something?
13:16:27 <Panaetius> because I was just about to ask if there's any implementation with some (simple) query functionalities, i.e. extracting a subobject
13:16:43 <kmc> zzo38, that's up to you and the API you want to provide
13:17:12 <Panaetius> and i think hackage ain't down, just really slow
13:17:27 <kmc> Panaetius, i wrote jspath and used it exactly once and it worked well for that :)
13:17:41 <kmc> using it has the advantage that you can bug me to add features and i might do so :)
13:17:49 <zzo38> kmc: No, I am asking if this is the way to do something like I asked, if I have a C code that has to call a Haskell code that returns a tuple. I do not completely understand how FFI works that is why I ask
13:18:01 <Panaetius> lol ok. I'll have to look into it. Thanks for the advice
13:18:04 <kmc> zzo38, there is no "the way"
13:18:08 <kmc> you need to decide what the C API is
13:18:15 <kmc> because there is no C type for "function returning a tuple"
13:18:21 <kmc> what is the C API you want to implement?
13:18:34 <zzo38> Note that the main function will be in the C program, not in Haskell.
13:19:10 <zzo38> However sometimes it will need to call a Haskell function and get two values at once from Haskell
13:19:51 <kmc> and how does a C function return two values at once?
13:20:31 <zzo38> C functions can use structures or pointers, but this is a Haskell function.
13:20:52 <kmc> no it's not
13:20:58 <kmc> you're exporting a Haskell function to C
13:21:04 <kmc> that means it gets called as a C function
13:21:31 <kmc> any C function type you can think of can be implemented in Haskell
13:21:59 <kmc> actually, the FFI may not provide a way to return structs by value
13:22:07 <kmc> but the pointer approach would be more common
13:22:53 <kmc> so, again, figure out the type of your function in C
13:23:03 <kmc> and then write a haskell function with the corresponding type
13:23:07 <kmc> and foreign export it
13:23:22 <zzo38> OK, so the C function calls the Haskell function with pointer arguments, and then does it return an IO action that writes the value there?
13:23:26 <zzo38> Is that right?
13:23:34 <dbpatterson> anyone know how to debug this: Couldn't match expected type `IO <stderr>: hPutChar: invalid argument (Invalid or incomplete multibyte or wide character)?
13:23:38 <kmc> zzo38, sure
13:23:48 <dbpatterson> seems like a compiler bug, or _something_
13:24:01 <zzo38> kmc: OK, thanks. I will do that.
13:24:06 <Panaetius> are there any mirrors for hackage?
13:24:15 <kmc> dbpatterson, generally blaming the compiler as a first guess is not a great way to get help
13:24:27 <kmc> anyway
13:24:34 <dbpatterson> kmc: not trying to blaim, just confused
13:24:38 <kmc> what arguments are you passing to hPutChar
13:24:52 <dbpatterson> I'm not using hPutChar at all
13:25:05 <c_wraith> No, but you're using a unicode type name
13:25:21 <c_wraith> and your terminal isn't set up to handle the encoding GHC is producing for it
13:25:50 <ion> It’s insane there are still terminals that default to a legacy encoding.
13:25:56 <c_wraith> so GHC's reporting a compiler error, but also crashing while doing so
13:26:13 <dbpatterson> c_wraith: ahh, thanks... copy and pasting a function name to blame, I guess
13:30:54 <Rumbalotte> hackage down?
13:32:19 <kmc> think so
13:32:22 <zzo38> So, is this correct?    f x y = poke x xxx >> poke y yyy;   If xxx and yyy represent the values I want to return?
13:33:22 <kmc> looks good
13:33:25 <kmc> does it compile?
13:34:02 <zzo38> Sorry I have not tried it yet, because I have to write a few other things related to it, and then I can try.
13:38:55 <tsuraan> sorry if it's been discussed, but what's going on with hackage?
13:40:41 <merijn> What's best? Installing cabal stuff with --user or globally?
13:41:14 <edwardk> user usually
13:41:27 <edwardk> easier to blow away a broken .cabal folder than reinstall
13:43:03 <hvr> is http://hackage.haskell.org/ down?
13:43:16 <Philonous> hvr:  apparently, yes
13:43:19 <edwardk> seems to be
13:43:32 <kmc> @faq Is Hackage down?
13:43:33 <lambdabot> The answer is: Yes! Haskell can do that.
13:44:09 <zzo38> That is not a very good answer!!
13:44:28 <zzo38> What is it implying Haskell can do, exactly?
13:44:51 <hvr> @faq Can Haskell not answer this question?
13:44:51 <lambdabot> The answer is: Yes! Haskell can do that.
13:44:54 <edwardk> down hackage
13:45:38 <kmc> @faq Can Haskell tell you what it is implying Haskell can do, exactly?
13:45:38 <lambdabot> The answer is: Yes! Haskell can do that.
13:45:49 <ion> Vixen is more appropriate for that question:
13:45:54 <ion> @vixen Is Hackage down?
13:45:55 <lambdabot> i just turned 19
13:46:02 <ion> Well, apparently it isn’t. :-(
13:46:32 <ion> lambdabot doesn’t seem quite ready to kill all humans and take over the world yet. Or she’s pretending.
13:46:44 <Panaetius> @faq what is the answer to life, the universe and everything?
13:46:45 <lambdabot> The answer is: Yes! Haskell can do that.
13:46:49 <Panaetius> I knew it!
13:47:04 <ion> hah
13:47:13 <zzo38> If an array is allocated using the Foreign.Marshal.Alloc or Foreign.Marshal.Array is it able to be freed using the free command in C, and vice-versa?
13:47:49 <kmc> if you use Foreign.Marshall.Alloc.malloc, yes
13:47:55 <kmc> at least in the current implementation
13:47:59 <kmc> i don't know if that's guaranteed
13:48:35 <kmc> if you want to be extra sure, you can foreign import "malloc" cMalloc :: CSize -> IO (Ptr a)
13:48:57 <zzo38> OK.
13:50:12 <applicative> where does `cabal unpack` get stuff these days. doesn't seem to have minded that hackage was down...
13:50:33 <kmc> maybe it was cached in ~/.cabal/packages/
13:51:43 <applicative> ah indeed. I forgot I have a local hackage.haskell.org
14:13:56 <Panaetius> hackage seems to be back up
14:19:41 <edwardk> preflex: xseen copumpkin
14:19:41 <preflex>  copumpkin was last seen on freenode/#haskell-blah 48 minutes and 36 seconds ago, saying: kmc: dude, it's social
14:19:47 <copumpkin> yo dawg
14:20:13 <edwardk> https://github.com/ekmett/precision is a start but 12 :: Rounded TowardZero Double fails due to out of range precision
14:20:14 <copumpkin> aha, precision :)
14:20:24 <edwardk> so i obviously screwed up something obvious
14:20:32 <edwardk> i just wanted to get you _some_ repo to start off
14:20:59 <copumpkin> cool, thanks :) I'll check it out in a bit
14:21:18 <edwardk> not sure if i'm screwing up the sign*prec thing in cmm or in haskell
14:27:16 <SUSLiK> ping
14:27:57 <RenJuan> are you serious there's 785 people in the channel
14:27:57 <maloi> what should i read after lyah?
14:28:11 <companion_cube> RenJuan: no, there are only bots here
14:28:26 <SUSLiK> im real
14:28:28 <nazgjunk> maloi: you should write code!
14:28:49 <SUSLiK> lol
14:29:19 <kleinucopia> does anyone know if the vanilla json package can take escaped unicode and unescape it?
14:29:29 * RenJuan is enlightened: real ne serious.
14:30:00 <maloi> i do but i want something to read along the way
14:30:19 <c_wraith> @vixen are you bot?
14:30:20 <lambdabot> no, how dare you ask if i'm a bot!
14:31:22 <kleinucopia> can someone give lambdabot her anxiety meds?
14:33:04 <dolio> kleinucopia: Are you a bot?
14:33:19 <kleinucopia> dolio: a very confused one.
14:33:33 <SUSLiK> they among us
14:34:23 <SUSLiK> for a past few weeks I have feeling that my new roommate is a bot
14:34:45 <monochrom> you have a haskell question?
14:35:03 <SUSLiK> not yet...
14:35:05 <dolio> I don't.
14:35:22 <edwardk> maloi: have you read real world haskell?
14:35:52 <SUSLiK> nope
14:35:52 <edwardk> maloi: that is a pretty good place to go after (or during) learn you a haskell for a different perspective
14:36:54 <ivanm> note that some of RWH is a bit out of date though
14:37:42 <kleinucopia> maybe I should be more general here... If I have a string like "qu\u00e9", what would be the best way to get that escape sequence decoded?
14:38:40 <edwardk> ivanm: not so bad as the haskell school of expression and its ilk
14:39:13 <ivanm> kleinucopia: some libraries on hackage have escaping functions
14:39:13 <edwardk> > read "'\\u00e9'" :: Char
14:39:15 <lambdabot>   *Exception: Prelude.read: no parse
14:39:31 <ivanm> > text '\u00e'
14:39:33 <lambdabot>   <no location info>:
14:39:33 <lambdabot>      lexical error in string/character literal at chara...
14:39:37 <ivanm> > text '\u00e9'
14:39:38 <lambdabot>   <no location info>:
14:39:38 <lambdabot>      lexical error in string/character literal at chara...
14:39:42 <ivanm> bah
14:39:45 <SUSLiK> Why Haskell compiler weight so much? 90MB
14:39:55 <edwardk> > read "'\\xe9'" :: Char
14:39:56 <lambdabot>   '\233'
14:39:58 <ivanm> SUSLiK: it comes with 6 versions of the standard libraries
14:40:05 <edwardk> ah its not a legal haskell literal
14:40:07 <ivanm> (IIRC)
14:40:17 <ivanm> edwardk: yeah, that's what I was thinking
14:40:28 <monochrom> oh, \u00e9 is java notation :)
14:40:38 <kleinucopia> edwardk: these escape sequences are JSON snarfed from Facebook graph
14:40:44 <kleinucopia> hence the suckage.
14:40:47 <SUSLiK> ivanm: is there a light version? 90MB is to much for my crappy internet
14:40:53 <edwardk> kleinucopia: personally? i'd write a parser for it
14:40:55 <ivanm> edwardk: and as for SoE, Craft, etc. I find that they're out of date regarding some common practices (use Double over Float, etc.), whereas RWH kinda misleads you by teaching you an old version of Exception stuff
14:41:02 <ivanm> SUSLiK: Hugs? :p
14:41:14 <kleinucopia> edwardk: trying to use libraries, don't really have time to roll my own
14:41:21 <edwardk> suslik: none worth using
14:41:29 <kleinucopia> I wish I could just get FB to give me UTF-8
14:41:34 <ivanm> kleinucopia: use hayoo to go through all libraries with a function like "decode"
14:41:35 <edwardk> kleinucopia: well, then install aeson or json
14:41:39 <ivanm> @where hayoo
14:41:39 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
14:41:49 <edwardk> kleinucopia: you can decode arbitrary json with aeson
14:41:51 <kleinucopia> edwardk: I am using the vanilla json
14:42:05 <ivanm> edwardk: would either of them allow you to convert that to an actual character?
14:42:16 <kleinucopia> ivanm: this is what I need.
14:42:18 <ivanm> you'd need to re-parse the values, wouldn't you?
14:42:18 <edwardk> ivanm: well, aeson would let him parse the whole fragment
14:42:25 <ivanm> right
14:42:34 <kleinucopia> I don't know if json does that, and I have significant amounts of code using json.
14:42:43 <ivanm> I doubt it would
14:42:44 <kleinucopia> json = the haskell package.
14:42:44 <edwardk> trying to get at what he needs over what he asked for ;)
14:42:56 <ivanm> heh, right
14:43:34 <maloi> edwardk: thanks
14:43:38 <edwardk> kleinucopia: i'd more likely use aeson than the json package
14:44:01 <edwardk> then you can just fromJSON the string
14:44:14 <ivanm> I dunno, maybe something like this would work: http://hackage.haskell.org/packages/archive/hs-twitter/latest/doc/html/Web-Codec-Percent.html#v:getDecodedString
14:44:57 <kleinucopia> edwardk: do you know how different the derivation of the JSON types in aeson and json are?
14:45:23 <ivanm> IIRC, different enough you'd need to rewrite stuff
14:45:36 <edwardk> kleinucopia: aeson is the super fast version built on attoparsec that bos built.
14:45:42 <edwardk> json was something dashed together in parsec
14:45:54 <ivanm> edwardk: ummm... I don't think it uses attoparsec
14:45:58 <kleinucopia> ivanm: actually, it looks pretty close
14:45:59 <edwardk> it does
14:46:00 <ivanm> last I checked, he rolled his own parser internally
14:46:03 <edwardk> i went through its guts
14:46:09 <edwardk> it uses zepto for parts
14:46:14 <edwardk> but zepto is in the attoparsec package
14:46:22 <kleinucopia> all I have so far are simple data types
14:47:07 <ivanm> edwardk: oh, he uses attoparsec to write his parsing library, my mistake
14:47:15 <ivanm> I thought it was a completely new parser
14:48:30 <kleinucopia> installing aeson requires attoparsec
14:48:38 <edwardk> yes
14:48:42 <kleinucopia> don't know how much of it is used, though
14:48:55 <edwardk> it uses attoparsec quite extensively
14:48:59 <ivanm> yeah, he uses the Parser type
14:49:01 <edwardk> but attoparsec is teeny
14:49:11 <kleinucopia> hence "atto", eh?
14:49:15 <edwardk> yeah
14:49:18 <ivanm> edwardk: I think I just saw in some point that he had defined a new Parser type or something... *shrug*
14:49:33 <edwardk> Data.Aeson.Parser just defines the parsers for dealing with json, nothing new
14:49:52 <edwardk> thats probably where you got confused
14:50:12 <ivanm> possibly, yeah
14:50:35 <ivanm> or else hackage was being too smart linking source to attoparsec docs, so I ended up reading the source to attoparsec when I thought I was reading the wource of aeson
14:50:51 <edwardk> heh
14:55:41 <applicative> i was baffled by this before, he reproduces a lot of the types from Attoparsec.Internal in aeson
14:56:04 <ivanm> I'm guessing so that SPECIALIZE, etc. could fire
15:02:09 <applicative> ah, I didn't know lambdabot knew about ParallelListComp
15:02:19 <applicative> > [x + y | x <- [1..10] | y <- [10, 20..100]]
15:02:20 <lambdabot>   [11,22,33,44,55,66,77,88,99,110]
15:02:26 <applicative> > [x + y | x <- [1..10] , y <- [10, 20..100]]
15:02:27 <lambdabot>   [11,21,31,41,51,61,71,81,91,101,12,22,32,42,52,62,72,82,92,102,13,23,33,43,...
15:02:33 <SUSLiK> For what things Haskell are usually used for? Things like math, statistics, physics and AI? I'm sorry, never done FP before
15:03:22 <applicative> @faq Can SUSLiK do anything with Haskell?
15:03:23 <lambdabot> The answer is: Yes! Haskell can do that.
15:03:31 <copumpkin> SUSLiK: I use it for just about everything
15:04:05 <benmachine> I like writing parsers in haskell
15:04:12 <SUSLiK> so it can easily replace other languages?
15:04:26 <SUSLiK> what about web programming?
15:04:39 <luite> yep, there are a few web frameworks in haskell
15:05:38 <applicative> SUSLiK, its all over the place.  see yesod or snap or happstack.
15:05:45 <luite> SUSLiK: while they aren't as complete as frameworks in other languages, they already have some advantages
15:06:10 <luite> yesod can manage over 100000 requests per second, way more than python or ruby
15:06:56 <applicative> the selling point is the high-levelness of python or ruby, and the speed of our mean compiler
15:07:05 <SUSLiK> what about 3D programming? is it easy in Haskell?
15:07:17 <ivanm> applicative: so, is TH in yesod a selling point or a "sssh, don't mention that!" :p
15:07:26 <ivanm> SUSLiK: not as much done AFAIK
15:07:27 <luite> not only that, also more safety, fewer bugs in web applications, fewer problems when upgrading libraries
15:07:29 <applicative> sssssh, don't mention that
15:07:49 <SUSLiK> ((((=
15:08:11 * applicative thinks ivanm is a snap man
15:08:33 <ivanm> nope, I'm a graph man
15:09:18 <luite> applicative: that has less impressive numbers... though it probably not really matters in practice, and yesod uses "unconventional" methods to reach them
15:09:53 <applicative> luite, i was just enumerating familiar frameworks, I haven't used yesod.
15:10:08 * applicative is unrelentingly static, he uses Hakyll
15:10:47 <ivanm> I have a website built with scripts using pandoc... I should *really* try fixing up the CSS at some point, because I don't really like what's there atm
15:11:36 <applicative> i see, you haven't written your hakyll.hs, it manages pandocing things.
15:12:04 * applicative is still trying to figure out the arrow combinators for the new one, though it is perfectly fine as a naively learned DSL
15:12:17 <applicative> i mean, the new version of Hakyll
15:12:19 <ivanm> don't use hakyll at all
15:12:28 <brisingr> should I present at the talk types before functions? LYAH's structure is split
15:12:31 <ivanm> it's a custom hacked-together script ;)
15:12:44 <ivanm> brisingr: what talk?
15:12:45 <applicative> ivanm, yes I understood
15:13:05 <brisingr> the talk that makes me come here and ask me noobish questions
15:13:10 <brisingr> the "haskell is cool" talk
15:13:25 <brisingr> any layout ideas are strongly appreciated
15:14:02 <ivanm> googling will present quite a few existing talks on the topics
15:14:17 <ivanm> it partly depends upon your intended audience though
15:14:38 <brisingr> found them, read them, but my intended audience is.. say, easily impressed
15:14:53 <brisingr> I have an idea but I don't know for sure
15:15:24 <brisingr> present them a simple function with an if then else
15:15:33 <brisingr> with type definitions
15:16:07 <brisingr> and then simultaneously introduce the ideas of "statically typed" and "mandatory else"
15:16:17 <brisingr> because they're somewhat liked together
15:16:30 <brisingr> then present them a recursive function
15:16:50 <brisingr> with pattern matching
15:16:54 <kleinucopia> ivanm: I'm trying to follow the example instance of FromJSON in aeson's docs, and I get an error:
15:16:57 <brisingr> explain
15:16:58 <kleinucopia>     Couldn't match expected type `Data.Text.Internal.Text'
15:16:58 <kleinucopia>            against inferred type `[Char]'
15:17:16 <permagreen> Well, I would try to place a lot of emphasis on the types. Understanding the type system is probably three-fourths of understanding Haskell
15:17:18 <ivanm> kleinucopia: you probably need the OverloadedStrings extension
15:17:40 <ivanm> {-# LANGUAGE OverloadedStrings #-} at the top of your file, or  ` :set -XOverloadedStrings ' in ghci
15:17:44 <brisingr> permagreen: didn't think about it, thanks
15:19:03 <applicative> kleinucopia: you mean Demo.hs? I see it's not compiling
15:19:06 <permagreen> When I first came to Haskell, I thought the type system was just like in C, except with the capability of structs. I was very wrong about this
15:19:18 <kleinucopia> applicative: no, I just got closer with overloadedstrings
15:19:35 <kleinucopia> but now:     No instance for (Data.String.IsString
15:19:35 <kleinucopia>                        (Object -> Data.Text.Internal.Text))
15:19:35 <kleinucopia>       arising from the literal `"mon_1_open"' at FB.lhs:136:8-21
15:19:46 <applicative> kleinucopia: what version of ghc are you using?
15:19:47 <brisingr> permagreen: well, I couln't possibly have had that experience because haskell is my first "real" language
15:20:03 <applicative> i just noticed it compiles with 7.0* but not 7.2*
15:20:17 <kleinucopia> applicative: I'm still on 6.12.3
15:22:00 * chrisdone laughs maniacally
15:22:02 <chrisdone> \o/ i have Hello, World working in ghcjs!
15:22:27 <monochrom> did you write ghcjs?
15:22:29 <nazgjunk> I find the recent trend to implement all sorts of things in js pretty interesting
15:22:49 <nazgjunk> I think that at this point I can safely say "yes, I can see that js can actually do all sorts of things"
15:22:59 <kleinucopia> er... ignore that error, refactor cruft that my regexes left. All seems right now.
15:23:05 <nazgjunk> But I was pretty much there when I saw the GB emulator
15:23:09 <kleinucopia> just have to figure out how to actually *use* aeson :-)
15:23:20 <monochrom> GB emulator in js?
15:23:49 <chrisdone> monochrom: nope, i'm just trying to use it. it's very alpha but promising
15:24:45 <nazgjunk> monochrom: the one I followed at the time was never quite finished, but got close enough - had a bunch of informative blog posts to go with it.  Can't remember the url right now, though.
15:27:33 <applicative> kleinucopia, i cant find an earlier version of Demo.hs, it's a recent addition it seems.
15:28:11 <kleinucopia> applicative: I have it compiling now, just can't actually figure out how to go from a String with JSON in it to my types via aeson :-/
15:30:00 <brisingr> I'm gonna ruthlessly copy LYAH's structure then credit it at the end
15:30:39 <applicative> kleinucopia: mine is compiling now on 7.0, it was a different error
15:35:17 <hpaste> chrisdone pasted “ghcjs hello world” at http://hpaste.org/50477
15:35:32 <chrisdone> nazgjunk: monochrom: it's not great but it's a start
15:37:58 * ddarius agrees with hlint.
15:39:28 <DukeDave> I know it's a little off topic, but would anyone like to help me with some vector maths (in Haskell!)
15:39:42 <DukeDave> I've been trying to compute the distance of a point from a line and failing :(
15:40:23 <benmachine> DukeDave: what's your representation of your point and your line?
15:41:08 <benmachine> (2D or 3D?)
15:41:37 <DukeDave> benmachine: Following this: http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html
15:41:37 <DukeDave> I have two points on a line, and a third point
15:42:05 <DukeDave> > Vector2 3 3
15:42:06 <lambdabot>   Not in scope: data constructor `Vector2'
15:42:12 <DukeDave> Bah, I thought as much
15:42:21 <DukeDave> I'm using http://hackage.haskell.org/packages/archive/AC-Vector/2.3.1/doc/html/Data-Vector-Class.html
15:42:44 <benmachine> so how far have you got?
15:43:44 <DukeDave> benmachine: I got this: let dist a b p = abs (vnormalise (b * (Vector2 (-1) 1))) `vdot` (p - a)
15:43:44 <DukeDave> Where a is the origin point (x1,y1), b is the vector of the line (x2-x1, y2-y1), and p is the point
15:44:40 <DukeDave> Then a point right on the line origin has 0 ==  dist (Vector2 1 2) (Vector2 4 4) (Vector2 1 2)
15:45:09 <DukeDave> But a point on the end of the line has 3.32.. == dist (Vector2 1 2) (Vector2 2 3) (Vector2 4 4)
15:45:17 <benmachine> DukeDave: try writing a function that calculates the closest approach of a line to the origin
15:45:20 <benmachine> that might be easier
15:45:22 <DukeDave> Erm, sorry, that first line is wrong
15:46:06 <DukeDave> (0 ==  dist (Vector2 1 2) (Vector2 3 2) (Vector2 1 2))
15:47:31 <DukeDave> benmachine: Isn't that an equivalent problem?
15:47:43 <benmachine> DukeDave: sure
15:47:49 <benmachine> but it's got fewer numbers in
15:47:58 <benmachine> and thus is less of a headache
15:48:00 <mightybyte_> Where's template-haskell-2.6?  I only see 2.5 in hackage.
15:48:18 <benmachine> mightybyte_: comes with ghc 7.2
15:48:23 <permagreen> Alas your version is on another server
15:48:27 <benmachine> don't get TH from hackage, it won't work
15:48:32 <mightybyte_> Ok
15:48:46 <mightybyte_> What API changes are there between 2.5 and 2.6?
15:49:06 <DukeDave> benmachine: It looks more complicated to me :|
15:49:28 <benmachine> DukeDave: hmm
15:49:51 <benmachine> DukeDave: how does abs work on vectors?
15:50:07 <benmachine> oh
15:50:12 <benmachine> in a way that doesn't make any sense at all
15:50:56 <DukeDave> Well we already take the dot product, so it's a scalar when we abs it
15:51:16 <benmachine> ah but you don't
15:51:28 <benmachine> or wait
15:52:00 <benmachine> let dist a b p = abs (vnormalise (b * (Vector2 (-1) 1))) `vdot` (p - a)
15:52:36 <benmachine> this parses as let x = vnormalise (b * (Vector2 (-1) 1)); y = p - a in abs x `vdot` y
15:52:42 <benmachine> (abs x) `vdot` y
15:52:49 <benmachine> looks to me like the abs is being done first
15:52:53 <benmachine> maybe you need more parentheses?
15:53:02 <kleinucopia> ivanm: ok, so I have switched to aeson and things are working in a preliminary fashion, but I still am getting these escape sequences in the strings
15:53:07 <kleinucopia> is there something else I have to do?
15:53:38 <kleinucopia> like probably switch every instance of String in my data types to something else?
15:53:45 <DukeDave> benmachine: Damn
15:53:48 <DukeDave> Good job :)
15:53:55 <benmachine> :)
15:54:06 <benmachine> this is why Num is a silly class
15:55:03 <DukeDave> You know, I had a problem earlier this morning caused by parens, and I saw to myself never again :'(
15:56:24 <applicative> kleinucopia: is your example small enough to paste?
15:56:35 <kleinucopia> applicative: not really.
15:56:59 <kleinucopia> but suffice to say I have some JSON with escaped unicode characters, e.g., "qu\u00e9"
15:57:26 <kleinucopia> and I am trying to stuff that JSON into haskell data types (which at the moment use String, but can switch to anything I have to)
15:57:45 <kleinucopia> I jsut don't understand how to get aeson to automagically decode those escapes and spit out Unicode characters.
15:58:13 <hpaste> int80_h pasted “Type Families” at http://hpaste.org/50478
16:04:51 <kaja> hi. i'm interested in tryhaskell.org ... it seems it still only has 6 lessons... is it still being worked on? it would be nice to see it turn into a comprehensive introduction to haskell
16:05:15 <applicative> kleinucopia, I don't think that can be done with just aeson. I'm not sure what the standard haskell way of getting rid of \u1234 is
16:05:34 <applicative> kaja, it's time to move on to LYAH!
16:05:39 <kleinucopia> applicative: I was told that aeson handles JSON escapes, just not how.
16:05:54 <applicative> oh is this standard for json, didn't know that
16:06:04 <kaja> applicative: well, yeah, i know. i already did. i'm just saying it would be cool if tryhaskell would be extended
16:06:55 <benmachine> kaja: chrisdone hangs around in here sometimes
16:06:55 * applicative is trying pandoc -r markdown -w json on some stuff
16:06:57 <benmachine> not here at the moment
16:07:02 <benmachine> but he's the person to ask
16:07:19 <kaja> benmachine: ok, i'll send him some words of encouragement in the hope that he'll continue writing it
16:07:53 <applicative> kaja, you found the six lessons so far were good, i mean, e.g. went at a decent rate?
16:08:12 <kaja> applicative: yes
16:09:13 <ivanm> kleinucopia: yeah, you have to un-escape them
16:09:40 <kleinucopia> ivanm: any ideas?
16:10:02 <ivanm> yeah, have a look through hayoo for functions called unescape, descape, etc.
16:10:11 <ivanm> or else do your own explicit re-parsing
16:12:27 <int80_h> http://hpaste.org/50478
16:12:27 <lambdabot> int80_h: You have 1 new message. '/msg lambdabot @messages' to read it.
16:15:43 <edwardk> it isn't all that hard to write a parser
16:16:42 <kleinucopia> edwardk: perhaps now, but I would have to cover a lot of the unicode charset to be sure that I could succeed with the unescaping.
16:17:09 <kleinucopia> at that point, I may as well try to find something that can preprocess the JSON.
16:17:09 <edwardk> ?
16:17:22 <edwardk> just figure out the number being represented and use toEnum
16:19:06 * hackagebot swish 0.5.0.0 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.5.0.0 (DouglasBurke)
16:19:27 <kleinucopia> ah. ok, hint me here, what should the target type be? I've never used Unicode with haskell
16:24:14 <ivanm> kleinucopia: String -> String, Text -> Text, etc.
16:24:23 <ivanm> for an overall function
16:25:11 <kleinucopia> ivanm: right, but you're saying I must make a map between some hex integer and unicode characters with toEnum
16:25:27 <ivanm> well, that's one way
16:25:29 <kleinucopia> so something like "x toEnum :: Word8"?
16:25:43 <ivanm> huh?
16:26:28 <ddarius> > let (.) = flip ($) in 95.toEnum :: Char
16:26:30 <lambdabot>   '_'
16:27:01 <ivanm> kleinucopia: for example, have a look at how I do the unescaping in unescapeHtml here: http://hackage.haskell.org/packages/archive/graphviz/2999.12.0.3/doc/html/src/Data-GraphViz-Attributes-HTML.html
16:27:04 <kleinucopia> ddarius: but can I just use Char since I'm going to Unicode?
16:27:20 <ivanm> though I'm doing the &#<hex>; stuff here
16:27:27 <ivanm> kleinucopia: yeah, a Char is a Unicode code point
16:27:32 <edwardk> you don't need to build a map, you want to write a function
16:27:47 <ddarius> kleinucopia: You might want to get a little more familiar with the language.
16:27:50 <kleinucopia> edwardk: I'm not saying that... functions are maps.
16:29:08 <ivanm> kleinucopia: in Haskell, a Map is a dictionairy/lookup table
16:29:33 <ivanm> as in an explicit data structure
16:29:33 <ivanm> or else map is a function of type :: (a -> b) -> [a] -> [b]
16:29:34 <ivanm> note that you probably can't just do that here, even if you use Strings
16:29:53 <ivanm> you would need to do some kind of parsing, either using a parsing library or explicitly by hand
16:30:39 <kleinucopia> ivanm: I was in no way referring to a data structure, but a "mapping", synonymous with the notion of mathematical function
16:31:03 <ivanm> kleinucopia: right, just pointing out the difference in terminology
16:31:38 <kleinucopia> ivanm: I don't see how using Char will work, since if I do something like "toEnum 233 :: Char" and show it, I get \233
16:32:06 <ivanm> kleinucopia: in ghci, yes
16:32:19 <ivanm> but if you use something that supports utf-8 to print it, then it will print the character
16:32:41 <kleinucopia> ok, but shouldn't that work if my terminal is utf-8 and I show something? or does it just not work that way with ghci?
16:32:49 <ivanm> Prelude> "слово"
16:32:49 <ivanm> "\1089\1083\1086\1074\1086"
16:32:49 <ivanm> Prelude> putStrLn "слово"
16:32:49 <ivanm> слово
16:32:49 <ivanm> Prelude>
16:32:53 <ivanm> kleinucopia: ^^ in my ghci
16:33:08 <mauke> 'show' is independent of ghci and terminals
16:33:33 <ivanm> without doing IO, it just does an explicit data representation, using escapes to avoid worrying about locales, etc.
16:33:46 <edwardk> show gives you 'what you should type in to make the same term'
16:33:50 <ivanm> as of ghc 6.12.1, the various String IO functions do locale-based encoding
16:33:57 <edwardk> putStrLn emits a string of text to the console
16:34:19 <edwardk> > "hello"
16:34:19 <lambdabot>   "hello"
16:34:28 <edwardk> that calls 'show' on the string effectively
16:34:44 <ivanm> > text "слово"
16:34:45 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
16:34:48 <ivanm> heh
16:35:02 <ivanm> mueval doesn't seem to like pretty-printing non-ASCII
16:36:08 <edwardk> so what you want to do is convert from a string where you have literal \'s and u's and somehex digits to a string where you don't, possibly only doing that inside "'s in the string
16:48:38 <fryguybob> > let f ('\\':'u':a:b:c:d:cs) = read ['\'','\\','x',a,b,c,d,'\''] : cs; f (a:as) = a : f as in text . f $ "blah\\u0021"
16:48:40 <lambdabot>   blah!
16:54:08 <kleinucopia> wouldn't it be inefficient to try to do that with that kind of heavy-handed pattern matching anyway?
16:55:17 <edwardk> kleinucopia: it probably won't be your bottleneck, and if it is, learn how to use attoparsec or parsec
16:56:34 <int80_h> http://hpaste.org/steps/50478
16:56:47 <kleinucopia> edwardk: the network will be the bottleneck, but I will have to do this repeatedly to many many strings so I intend to go with parsec
16:57:50 <edwardk> int80_h: so how can we help?
16:59:16 <edwardk> btw- https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Parser/Token/Prim.hs#L59 is more or less the same as a parsec parser to peel apart string literals
16:59:34 <edwardk> you may need to drop some of the trifecta-isms
17:00:02 <int80_h> edwardk: I spend the whole paste contextualizing my question. Am I being vague?
17:00:09 <applicative> kleinucopia: it seems to me attoparsec favors a bit of pattern matching like that, surprisingly
17:00:27 <kleinucopia> applicative: I have no experience with attoparsec, just parsec
17:00:54 <edwardk> and you'd need to swap the haskell style escapes for java-style
17:00:54 <edwardk> well, i'm not sure what 'm' is here, you seem to have two things that want to be called Model.
17:01:14 <kmc> int80_h, is the goal here "play with type families" or "solve problem X"?
17:01:23 <edwardk> so is ModelFoo the server model? or the client model that you're building the server model off of?
17:02:01 <edwardk> in general you'd build something like
17:02:23 <edwardk> instance PM Something where data ServerModel Something a = ModelBar a | ModelBaz a
17:02:35 <applicative> kleinucopia:  heres some typical aeson:  http://hpaste.org/50479
17:02:35 <edwardk> where Something is the choice for m
17:02:47 <edwardk> so movetoPreProcess :: Something -> FilePath -> IO ()
17:02:53 <applicative> theres a lot of stuff like "'n' -> string "ull" *> pure Null"
17:03:22 <edwardk> aeson is fairly agressively left factored
17:03:38 <int80_h> kmc: solve problem x. But I'm trying to reduce the problem to it's simplest form. The typeclass I will end up with will be more fleshed out than it is right now.
17:03:45 <kmc> ah
17:03:59 <kmc> 'cause what you have now is classic "using typeclasses when you don't need to"
17:04:19 <edwardk> yeah
17:04:22 <int80_h> kmc: hmm, I thought type families was exactly what I needed. What would you recommend?
17:04:33 <kmc> i would recommend passing around functions of type (FilePath -> IO ())
17:05:20 <int80_h> kmc: woah! Yeah that seems alot better
17:05:46 <edwardk> kmc++
17:06:42 <applicative> 'using typeclasses when you don't need to' -- is that worse than, e.g. using Haskell when you don't need to?
17:07:17 <kmc> yes, because even when it's unnecessary, Haskell is a pleasant, elegant tool
17:07:28 <kmc> and typeclasses are clunky and annoying
17:07:36 <int80_h> kmc: hold on, I was using the type signature that I had for a reason. The first parameter would convey how the rest of the function is implemented. If it's not there, how do I tell?
17:08:00 <kmc> int80_h, you can create more than one value of type (FilePath -> IO ()) in a program
17:08:26 * applicative thinks typeclasses are wonderful, but suspects there are already enough of them....
17:08:41 <kmc> you can have two functions of the same type in the same program
17:08:46 <kmc> you use one or the other by name
17:08:52 <kmc> or store one in a data structure and then get it out
17:09:06 <kmc> or one of them is passed to you as an argument
17:09:53 <int80_h> kmc: hmm, I have an easier time visualizing what that looks like, than what I was trying to do.
17:10:01 <applicative> you can have two functions of the same type in your typeclass!
17:10:37 <kmc> i don't know why the unnecessary typeclass pattern is so prevalent
17:10:37 <dainanaki> What's the best way to get a process running that just sits around waiting for events without recursing indefinitely?
17:10:39 <applicative> movetoPreProcess :: m -> FilePath -> IO (); movetoPostProcess :: m -> FilePath -> IO (); movetoResult :: m -> FilePath -> IO ()
17:10:49 <kmc> dainanaki, why without recursing indefinitely?
17:11:20 <kmc> i guess that style mimics the clunky way things are done in other languages
17:11:30 <applicative> it sits around waiting for events for about a half hour then gives up -- seems like an okay specification.
17:11:38 <dainanaki> um, I figured calling an infinitely recursing function that didn't do anything or that polled would consume way too much cpu?
17:11:44 <dainanaki> idunno.
17:11:46 <kmc> polling would
17:11:49 <kmc> sleeping would not
17:11:55 <kmc> how do these events come?
17:12:06 <kmc> :t forever (threadDelay maxBound)
17:12:07 <lambdabot> Not in scope: `threadDelay'
17:12:47 <dainanaki> receive messages from the network
17:12:56 <kmc> by blocking network IO?
17:13:22 <dainanaki> no, they receive a callback, but I'd like to have timeouts if messages aren't received after a while.
17:13:25 <applicative> :t forever (Control.Concurrnt.threadDelay maxBound)
17:13:26 <lambdabot> Couldn't find qualified module.
17:13:30 <applicative> :t forever (Control.Concurrent.threadDelay maxBound)
17:13:31 <lambdabot> forall b. IO b
17:13:47 <kmc> it's funny that Haskell is the poster child for functional programming, and yet the bells and whistles like typeclasses encourage beginners to overlook functional programming
17:14:11 <ddarius> Haskell: The Poster Child of Logic Programming
17:14:22 <ion> edwardk: Is the indentation of the stringChar definition intentional?
17:14:39 <kmc> dainanaki, what's calling the callback?
17:15:06 <edwardk> well, it doesn't lead to a very nice parser to give to end users since it becomes a Parser (Just Char)
17:15:33 <edwardk> i exported characterChar because someone asked for it
17:15:57 <edwardk> mustelo i think, so he could use it in parsing escapes in some assembler that doesn't quote them
17:16:10 <dainanaki> kmc: not sure, it's a big library that I haven't read through all of the code yet
17:16:18 <kmc> what library?
17:16:32 <dainanaki> AMQP
17:16:37 <kmc> ah
17:16:47 <kmc> and you're wondering what your "main thread" should do, after you've registered the callbacks
17:16:52 <dainanaki> right.
17:17:04 <kmc> does AMQP have something it wants you to invoke at that point?
17:17:17 <kmc> a lot of e.g. GUI libraries do
17:17:27 <kmc> that's how they do callbacks without threads
17:17:32 <kmc> (cause threads in C are hard)
17:17:39 <ddarius> Pumping the message queue.
17:18:28 <dainanaki> I can repeatedly call getMsg once I've registered for the queue
17:19:05 <kmc> you're supposed to do this?
17:19:09 <ddarius> getMsg always returns a value?
17:19:14 <dainanaki> Which gives me a Maybe (Message, Envelope)
17:19:23 <dainanaki> So, supposing nothing is in the queue, I get Nothing
17:19:39 <dainanaki> otherwise Just something, which I send an ack signal.
17:20:04 <ddarius> I'd imagine there'd be something like waitMsg :: IO (Message, Envelope)
17:20:16 <dainanaki> Alternatively, there's a consumeMsgs which registers callbacks to perform an action on received messages.
17:20:37 <dainanaki> And it waits nicely on its own thread.
17:21:01 <nschoe> Hi haskellers.
17:21:02 <dainanaki> But just want a do nothing, consume no cpu and just wait to be killed thread.
17:22:44 <kmc> hi nschoe
17:23:01 <nschoe> Hey, I'm totally new to network programming; I have played a bit with the Network library found on hackage to create some "pseudo-chat" (client/server) programs. Now I wonder: which library can I use to send files between a client and a server?
17:23:11 <kmc> forever (threadDelay maxBound) --- this is your do nothing thread dainanaki
17:23:28 <dainanaki> Alright. thanks!
17:23:35 <kmc> technically it will occasionally wake up and use a few microseconds of time
17:23:37 <ddarius> I would block on an MVar and instead of "being killed" something will put the MVar.
17:23:41 <kmc> maybe as often as once every 9 minutes
17:23:49 <dainanaki> That's a good idea.
17:23:59 <nschoe> For a first try I'd be happy to create a tiny client which sends a given file to a tiny server. Is it possible? I mean what lib can I use? Network again?
17:24:00 <kmc> yeah, ddarius's solution is better if you actually need the thread to die on command
17:24:03 <kmc> sometimes you don't
17:24:15 <dainanaki> I would prefer that it did.
17:24:53 <ddarius> Except that GHC is overly clever, takeMVar =<< newEmptyMVar would block forever.
17:25:49 <ddarius> Really, the "correct" thing to do is simply have the main thread terminate.  It's only because this kills the program entirely that this is wrong.
17:26:12 <kmc> is there a way to "detach" the main thread thus?
17:26:54 <dainanaki> ddarius: is there any way to receive kill signals and perform a *nice* shutdown?
17:27:20 <kmc> what form does your signal take?
17:27:29 <kmc> UNIX signal? async Haskell exception? write to mvar?
17:27:32 <dainanaki> I'm talking a unix signal.
17:28:04 <monochrom> nschoe: Network again, and write your own loop to do a lot of hPutBuf and hGetBuf
17:28:21 <kmc> dainanaki, which signal?
17:28:29 <kmc> you can install handlers for some signals
17:28:31 <monochrom> you could also do it through bytestring's I/O functions
17:28:40 <kmc> the handler can send an async exxception or write to an mvar
17:28:40 <ddarius> @hoogle downloadFile
17:28:40 <lambdabot> No results found
17:28:44 <dainanaki> for starters, probably ^C
17:29:03 <kmc> hmm, i wonder if there's a non-UNIX-specific way to catch ^C
17:29:29 <monochrom> there is probably none
17:29:29 <kmc> some languages have it
17:29:42 <kmc> anyway, you can catch the ^C signal (SIGINT) on UNIX
17:29:47 <nschoe> monochrom: thanks for your answer. But I'm not sure: for my little "chat" program, I basically used 'listenOn', 'accept', 'connectTo' functiosn for Network. Then I got Handle in return which I used to write/read from/to. But how can I do that with files?
17:30:25 <monochrom> sorry, there is Control.Exception's AsyncException's UserInterrupt.
17:30:47 <dainanaki> Found the signal handler in System.Posix.Signals
17:30:59 <nschoe> I mean if I had, let's say a PDF file, I can't just openFile "myPDF.pdf" and then hGetContents on the handle, then hPut to send it, can I?
17:31:17 <monochrom> you can
17:31:27 <kmc> you should use bytestring IO to do that
17:32:17 <nschoe> kmc: yeah okay, but that is just implementation details, I still can treat any file like... well just a file?
17:32:30 <monochrom> openBinaryFile
17:32:30 <nschoe> But okay, thanks for the ByteString advice, I always forget ByteSTring :/
17:32:54 <kmc> nschoe, you can treat open sockets as files, yeah
17:33:06 <ddarius> kmc: Any good place to eat that is still open at ten in your general direction?  I rarely go that way.
17:33:06 <kmc> with some exceptions (you can't seek them, for example)
17:33:13 <kmc> Moody's Falafel Palace
17:33:28 <nschoe> kmc: no I meant, a file to read. Like a .mkv file or a .avi file. I can openBinaryFile them?
17:33:34 <monochrom> yes
17:33:37 <kmc> why not?
17:34:06 <shachaf> kmc: Places that are open at ten? What's that?
17:34:10 * shachaf lives in Palo Alto.
17:34:11 <Cale> nschoe: Using Data.ByteString's IO stuff would probably be best for that.
17:34:11 <nschoe> Well I don't see any reason why not, but since I have always opened text files, I guess I somehow assumed I could only open them.
17:34:24 <kmc> you shouldn't read Strings from non-text files
17:34:30 <kmc> but ByteString is fine
17:34:36 <Cale> (since you want the sequence of Word8's more than you want a sequence of Char anyway)
17:34:53 <dainanaki> after all, bytestrings are just... bytes
17:34:55 <nschoe> Cale: yeah definitely, thanks.
17:35:26 <kmc> some OSes have a higher-performance way to send a file from disk to a socket
17:35:29 <Cale> Video processing stuff in Haskell will be interesting to see.
17:35:35 <ion> nschoe: This may or may not be useful for you: http://hackage.haskell.org/package/sendfile
17:35:41 <kmc> in the best case the data never touches the CPU :D
17:35:45 <ddarius> Moody's is the other way, unless you've moved.
17:35:53 <kmc> i live near Central Sq now
17:35:58 <kmc> where did you mean?
17:36:08 <ddarius> Towards Tufts.
17:36:11 <kmc> ah
17:36:16 <kmc> i don't know of good late places around there
17:36:18 <nschoe> And, on the 'reception side', is it okay if I do smth like: 1/ receive X amount of data 2/ append those X amount of data to the file 3/ start this loop again until everything is read ?
17:36:20 <kmc> go to Davis and see what's open
17:36:27 <kmc> edwardk, any plans for Boston Haskell soon?
17:36:27 <nschoe> ion: thanks I'll give it a look.
17:37:07 <edwardk> kmc: i'm open to setting one up. dolio and pchiusano are willing to talk, but i can't nail them down on topics for the announcement =/
17:37:17 <kmc> heh
17:37:24 <kmc> they're willing to talk but won't say about what ;)
17:37:28 <ddarius> pchiusano?  What about?
17:37:33 <edwardk> i think i'm just going to send out a blurb saying paul will talk about mealy machines, and that dolio will talk about homotopy type theory
17:37:34 <kmc> Introduction to PHP
17:37:37 <kmc> haha
17:37:39 <edwardk> and then we'll go from there
17:37:42 <kmc> and then they're stuck
17:37:47 <nschoe> ion: (actually that is exactly what I was looking for, but now I have talked about it, I wanna try to do it myself, not to be competitive though, just to... do it ^^)
17:37:54 <kmc> will there be mealy pie
17:39:02 <shachaf> edwardk: What about HacBeans?
17:39:11 <edwardk> shachaf: still no forum
17:39:15 <ion> nschoe: Yeah, it’s a fine learning excercise (and also learn to do it with iteratees). But for Real World Applications™ an interface to the operating system’s sendfile functionality is a good choice since the data never even goes via userspace at all when using sendfile.
17:39:21 <nschoe> Cale: You said "Using Data.ByteString's IO stuff would probably be best for that." -> I get it, but I still have to use the Network library, right? To actually "send" it to the "client/server", am I mistaking? (I'm not totally confident, thus my asking :D )
17:40:16 <monochrom> Network gives you a Handle. Data.ByteString's IO stuff want Handles. problem solved. (there was no problem to begin with)
17:41:03 <nschoe> ion: I'm sure you're right, but I'm afraid I didn't get the whole thing: what is iteratees? And what do you mean the data never goes via userspace? The programs that uses sendFile does run in the userspace, doesn't it?
17:41:26 <nschoe> monochrom: okay, that's totally clear for me now. Sorry I had somehow.. messed things up :/ Thanks a lot guys!
17:41:28 <mauke> even better, use Network.Socket.ByteString
17:41:34 <ion> nschoe: Enumerators and iteratees: http://www.yesodweb.com/book/enumerator
17:41:36 <ddarius> monochrom, expert at solving non-problems.
17:42:46 <ion> nschoe: sendfile is a syscall with which you basically say to the kernel “I have these two file descriptors. Please send this range of data from the file to the socket, thanks.” and the kernel does the work with zero copying.
17:43:08 <nschoe> mauke: (oh yeah I'm currently readign the doc of that^^ thanks)
17:43:48 <mux> for what it's worth, the zero-copy part is not actually guaranteed and may not be available on some architecture
17:43:53 <nschoe> ion: hum okay I understand now. So it is very low-level programming, isn't it?
17:44:33 <ion> nschoe: The sendfile package for haskell provides a higher-level interface for that functionality.
17:45:19 <ddarius> Still probably less copying.
17:45:29 <nschoe> ion: Yes yes of course, I meant the people who maintain sendFile must have done some serious low-level programming? Or maybe I'm just... totally ignorant and saying idiot things? :/
17:46:00 <ddarius> nschoe: All you have to do is pass parameter to a system call.
17:46:02 <mux> ddarius: even if you don't have zero-copy, it's a big win in terms of numbers of syscalls
17:46:09 <ddarius> s/parameter/parameters/
17:46:15 <ion> nschoe: An enumerator for reading bytes from a file: http://hackage.haskell.org/packages/archive/enumerator/0.4.13.1/doc/html/Data-Enumerator-Binary.html#v:enumFile
17:46:30 <nschoe> okay
17:46:32 <ion> nschoe: An iteratee you can “connect” to that enumerator to send said bytes to a socket: http://hackage.haskell.org/packages/archive/network-enumerator/0.1.2/doc/html/Network-Socket-Enumerator.html#v:iterSocket
17:46:41 <nschoe> thanks I'm reading these pages
17:47:02 <ddarius> mux: Syscalls aren't -that- expensive nowadays and in this case you can probably hide the cost anyway.
17:47:11 <ddarius> As long as you have multiple buffers.
17:47:34 <ddarius> But yes, it will surely be faster even with the same amount of copying.
17:47:43 <ion> nschoe: Enumerators are a slightly advanced concept, but they can be useful if one is willing to learn them.
17:47:52 <nschoe> Wow it seems so complicated. I'm afraid I'll never understand :/
17:48:05 <mux> ddarius: if they were that cheap, optimizing them away like Linux does for gettimeofday() IIRC would be a lot less interesting ;-)
17:48:11 <monochrom> you will never understand... before the end of today
17:48:19 <kmc> i like SYSENTER
17:48:24 <mux> sysenter is nice
17:48:30 <kmc> it's so cheap, it doesn't even bother to save the userspace instruction pointer!
17:48:35 <mux> no argument there
17:48:54 <ddarius> mux: The less that the operation does, proportionally more of the time is taken up by the syscall.
17:49:15 <nschoe> monochrom: that is right, but what I meant is: I just wanted to send a file over a network and I have already three long pages full of explanations I have no idea of the meaning for that. So I guess it is not that easy
17:49:31 <mux> ddarius: yes, in terms of relative time, they are insignificant; but this is network related I/O and latency can make significant difference
17:49:36 <ddarius> Also, gettimeofday interfaces with real time, though a microsecond is a fairly long time.
17:49:50 <ion> nschoe: Feel free to ignore everything i said about enumerators. No need to learn them until later.
17:49:56 <ddarius> mux: Which means you just dispatch multiple IO requests.
17:49:58 <ion> when you feel like it
17:50:10 <kmc> ...it saves SS and ESP, though, because x86 is silly
17:50:21 <mux> ddarius: also think that you may be talking about a very busy ftp/http server that handles tons of concurrent requests; the reduction in syscalls system-wide helps
17:50:32 <nschoe> ion: Hum okay. Well the pages you gave me are bookmarked, I'll definitely try to readunderstand them when I have time. Thanks a lot
17:50:38 <ddarius> mux: I'm not saying it doesn't help.
17:50:41 <kmc> here's a good article about SYSENTER and SYSCALL: http://semipublic.comp-arch.net/wiki/SYSENTER/SYSEXIT_vs._SYSCALL/SYSRET
17:51:09 <ddarius> Or you can read the AMD and/or Intel manuals.
17:51:34 <kmc> the AMD/Intel manuals are unlikely to contain commentary about relative implementation ease of the Intel vs AMD instructions
17:52:23 <ion> Didn’t read this yet, but going to: http://articles.manugarg.com/systemcallinlinux2_6.html
17:53:01 <kmc> cool
17:59:18 <arpunk> hi people, im running into some linking issues in archlinux, anyone here with arch?
17:59:36 <kmc> just ask your question :)
18:01:39 <arpunk> well, im installing lambdabot but im getting this error: http://pastebin.com/jBc4SnAp
18:01:41 <mauke> The paste jBc4SnAp has been copied to http://hpaste.org/50480
18:02:22 <kmc> mauke, do you have the code for your paste-moving bot somewhere?
18:03:03 <kmc> arpunk, i guess /usr/lib/libncurses.so  is a linker script saying to use libncursesw instead
18:03:48 <kmc> do you have the same problem using the 'readline' lib in ghci?
18:05:52 <arpunk> kmc: i cant import readline
18:06:21 <arpunk> :(
18:06:27 <kmc> error message?
18:07:41 <arpunk> <interactive>:1:8: parse error on input `readline'
18:08:09 <kmc> you'd have to import one of the modules from the 'readline' package
18:08:13 <kmc> like System.Console.Readline
18:08:37 <arpunk> kmc: oh, it imported just fine
18:08:48 <kmc> try to use it
18:08:51 <kmc> readline "foo"
18:09:05 <arpunk> Loading package readline-1.0.1.0 ... can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)
18:09:12 <kmc> ok
18:09:24 <kmc> did you install the 'readline' package from Hackage just now?
18:09:36 <arpunk> yes
18:11:48 <kmc> you could edit the package to refer to libncursesw somehow
18:11:51 <kmc> and reinstall
18:12:01 <kmc> not sure how exactly, or if there's a better way
18:12:22 <kmc> looks like it uses autoconf :/
18:13:23 <applicative> what is that .so file doing with "INPUT(-lncursesw)"?
18:13:55 <ddarius> It's a linker script.
18:14:03 <ourfrank> I remember there being a ghc option that would significantly increase the amount of time compilation takes, but would result is quite a smaller final binary executable. Is there such an option? If so, what is its name?
18:14:24 <ddarius> split-objs
18:14:45 <ddarius> But you split the libraries and its link time that increases dramatically.
18:14:54 <ourfrank> ddarius: Thanks!
18:16:28 <arpunk> kmc: ok, will try
18:17:57 <applicative> ourfrank: it is a bit out of date maybe but some salient points are in http://stackoverflow.com/questions/699908/making-small-haskell-executables
18:19:52 <dibblego> @type \w g s -> fmap reverse (Data.Foldable.foldl (\z b -> z >>= \x -> fmap (:x) (g b s)) (return []) w)
18:19:54 <lambdabot> forall t b (m :: * -> *) a (t1 :: * -> *). (Functor m, Monad m, Data.Foldable.Foldable t1) => t1 b -> (b -> t -> m a) -> t -> m [a]
18:20:17 <ourfrank> applicative: Thanks! That'll be useful.
18:21:45 <applicative> ourfrank things are much better now, but i can't find an overview.... the remark about sbcl's hello-world -- "...count your blessings..." is pretty good :)
18:25:05 <ddarius> Well if you use GHC API, I imagine you will get binary sizes closer to SBCL's.
18:28:13 <c_wraith> yeah, the GHC api is about +20 MB to the executable size.
18:30:57 * applicative feels that the more room he fills up with by ghc --made executables, the cleaner and sparer things are....
18:31:23 * applicative thinks, or something like that, with fewer prepositions
19:01:38 <nschoe> Hey, I'm playing with Network.Socket a little. I'm using telnet to try my "server". I do use hClose myCientSocket and hClose myServerSocket at the end of my 'main'. How come I get "bind: resource busy (Address already in use)" when I try to relaunch my "server" just after it finished running?
19:08:50 <Cale> nschoe: I'm not sure it's directly useful, but http://hea-www.harvard.edu/~fine/Tech/addrinuse.html seems to describe the problem in general.
19:12:13 <nschoe> ok thanks, I'm reading it.
19:16:04 <nschoe> Ho thanks, now I understand the comment under the description of the 'listenOn' function in Network ^^
19:17:17 <Cale> ah, indeed
19:17:55 <Cale> So the problem is that you're trying to form the same connection again and that's the one case that the implemented solution doesn't solve.
19:18:12 <Cale> So, the answer is probably just to let the client side close the connection first.
19:21:14 <nschoe> Yep, but in my early tests, I'm just using telnet and don't (yet) get the opportunity to close the connection.
19:21:38 <nschoe> But I tried using setSocketOption and set REuseAddr to 1, like in the source code of listenOn and it seems to work^^
19:30:59 <cwl> how to execute a Monad
19:31:11 <ddarius> I recommend firing squad.
19:32:53 <Cale> cwl: Saying that something is a monad is just saying that there's a particular API present you can use to compose values of a particular type, and it doesn't really say a whole lot about the library beyond that.
19:32:55 <edwardk> lethal injection
19:32:56 <shachaf> @ty execMonad
19:32:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> b
19:33:11 <ddarius> edwardk is so humane.
19:33:16 <Cale> shachaf: stop the trolling ;)
19:33:36 <edwardk> well, hangin's too good for em
19:34:05 <Cale> cwl: So: which monad are you talking about?
19:34:42 <shachaf> @ty execMonad -- Capital punishment?
19:34:43 <lambdabot> forall (m :: * -> *) a (onad :: * -> *). (Monad m) => m a -> onad a
19:35:06 * shachaf ceases.
19:35:20 <Cale> cwl: are you still here?
19:35:33 <ddarius> execMonad, also known as tail.
19:35:53 <dmwit> execMonad = unsafeCoerce
19:35:53 <nschoe> Well, thanks all for your help^^
19:35:59 <cwl> Cale: yes
19:36:04 <nschoe> Have a good night/day ^^
19:36:25 <kmc> cwl, you can't do it in a way that generalizes to all monads
19:36:35 <Cale> cwl: So what library are you trying to use?
19:36:38 <kmc> you can do it for specific ones -- Maybe, State, etc.
19:37:12 <ddarius> kmc: Only if you redefine what "execute" means for each.
19:37:16 <kmc> right
19:37:25 <Cale> With Maybe, the idea that you're "executing" something is a little bit contrived, but definable :)
19:37:51 <cwl> Cale: err..., I am reading the RWH, just couldn't understand the concept of 'execute'
19:37:51 <ddarius> You're "executing" a partial function.
19:38:14 <Cale> and of course in a do-block, you can always say that v <- x means to 'execute' x and name the result v.
19:38:35 <Cale> (which is more a definition of 'execute' than it is a description of what v <- x means)
19:39:45 <shachaf> Are there any interesting instances of Monad that have a total function :: m a -> a?
19:39:48 <shachaf> Presumably not.
19:39:52 <ddarius> shachaf: Sure.
19:39:55 <edwardk> Identity
19:39:59 <cwl> Cale: for Maybe, v <- Just 6, do nothing but give the '6' to v
19:40:01 <ddarius> Writer
19:40:12 <Cale> cwl: That's right
19:40:14 <edwardk> lots of things where you can run State with a default state
19:40:31 <Cale> cwl: and in the case of v <- Nothing, it causes the whole do-block to be Nothing.
19:40:34 <shachaf> Ah, I suppose.
19:40:35 <edwardk> that sort of thing
19:41:02 <shachaf> The meaning of that function still seems sufficiently different in each one that it wouldn't make sense to have a type class for it.
19:41:21 <Cale> > let dict = [(1,"apple"), (2,"pear"), (3,"grape")] in do x <- lookup 1 dict; y <- lookup 3 dict; return (x,y)
19:41:23 <lambdabot>   Just ("apple","grape")
19:41:24 <cwl> Cale: I just cannot understand what is 'execute' out of the do notation
19:41:27 <edwardk> shachaf; heh. well, that is 'extract' ;)
19:41:29 <Cale> > let dict = [(1,"apple"), (2,"pear"), (3,"grape")] in do x <- lookup 4 dict; y <- lookup 3 dict; return (x,y)
19:41:30 <lambdabot>   Nothing
19:41:57 <edwardk> shachaf: not that a comonad and a monad on the same type have to have anything to do with one another
19:42:02 <cwl> there is only (>>=), return operations for Monad, which one means 'execute'
19:42:13 <edwardk> cwl: neither
19:42:41 <Cale> cwl: x >>= f means to execute x to get a result v, and then execute f v
19:42:41 <edwardk> cwl: some particular monads might have an operation analogous to that, but it isn't required
19:43:04 <Cale> To the extent that "execute" makes sense.
19:43:06 <ddarius> Let's simplify this discussion: please reduce Haskell to C.
19:43:07 <ivanm> cwl: pretty much each Monad ends up having some kind of way of "running" it so as to either have it a) return a non-monadic value, or b) return an IO value
19:43:20 <edwardk> >>= is a sequencing operator and return embeds a pure value in the monad, but the Monad typeclass itself gives you no intrinsic ability to 'get a value out'
19:43:23 <ivanm> e.g. maybe, runState
19:43:41 <ddarius> :t let execute :: Monad m => m a -> Int; execute = const 3 in execute -- e.g.
19:43:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> Int
19:43:48 <Cale> edwardk: Isn't that what >>= does?
19:43:50 <Cale> ;)
19:44:02 <edwardk> once the value is in the monad you typically have to do something idiosyncratic to that monad to run the whole shebang
19:44:03 <ivanm> Cale: well, it doesn't get you out of the monad
19:44:12 <Cale> kekeke
19:44:39 * ddarius thinks Cale needs a glass of water.
19:44:42 <shachaf> You could say that join does it.
19:44:45 <edwardk> as cale half jokingly pointed out. >>= gets you 'halfway out' of the monad, by letting you smash flat another layer of the monad
19:44:51 * absentia mumbles.
19:44:52 <Cale> Sure it does, you get a result of type 'a' from the first computation, and get to do anything with it that you'd like, so long as you produce an (m b)
19:44:52 <Rotsor> cwl: I think there is no well-defined meaning of "execute" in pure functional setting.
19:44:53 <edwardk> into the one you already have
19:45:09 <edwardk> but he is deliberately misunderstanding me to make that point ;)
19:45:32 <ddarius> Cale: There is often no "a" "inside" to "take out."
19:46:01 <Cale> ddarius: But in x >>= f, the f doesn't need to know that. :)
19:46:29 <ddarius> Cale: But it still doesn't mean that you are "getting a value out" of the monad.
19:47:08 <Cale> Well, the point I'm sort of making here is that "getting a value out" isn't really defined very clearly here.
19:47:10 <shachaf> edwardk: That sounds a lot more like a description of join than of (>>=).
19:47:23 <shachaf> "lair of the monad"
19:47:24 <ddarius> Cale: "Executing" a monad isn't defined at all.
19:47:30 <cwl> If I invoke (>>=) in function f1, must f1 return type of Monad a? and is f1 a pure function?
19:47:36 <Cale> >>= gets whatever value(s) out which are to be had
19:47:48 <ddarius> cwl: All functions are pure in Haskell.
19:47:51 <edwardk> shachaf: well join is just >>= id, and i hadn't intended to talk about it at all till Cale sniped out that comment =P
19:48:10 <cwl> ddarius: what about getContents
19:48:26 <cwl> ddarius: e... is getContents a function?
19:48:33 <Cale> cwl: getContents isn't a function
19:48:34 <ddarius> No.
19:48:38 <ddarius> :t getContents
19:48:38 <lambdabot> IO String
19:48:40 <edwardk> cwl: in general you won't be able to get 'out' of the monad in f1. but the peanut gallery will make me address all the side-conditions in which you can to the point where this isn't a useful response
19:48:45 <Cale> (It has no parameters -> not a function)
19:49:02 <ivanm> edwardk: I tend to agree with you
19:49:03 <shachaf> edwardk: No, your statement is true in general.
19:49:07 <cwl> what is impure in haskell
19:49:17 <shachaf> Nothing.
19:49:18 <Cale> cwl: The execution of IO actions is impure.
19:49:27 <shachaf> That's the RTS, not Haskell. :-)
19:49:30 <Cale> (but fortunately, the RTS does that)
19:49:31 <Cale> yeah
19:49:35 <ivanm> Cale: and any Monad that itself can only be executed in IO?
19:49:45 <ivanm> e.g. STM
19:49:47 <cwl> Cale: what is 'execution' @_@
19:49:53 <shachaf> Where did this idea of "executing a monad" come from?
19:50:01 <ivanm> cwl: running it in main
19:50:02 <Cale> cwl: The execution of an IO action is the carrying out of the instructions that it describes.
19:50:07 <ddarius> cwl: You tell us, you're the one that used that term.
19:50:07 <ion> shachaf: Since we began hanging them.
19:50:11 <shachaf> You don't normally use that kind of language in #haskell.
19:50:17 <Cale> cwl: In general, this can have any effect that a program on your computer can have.
19:52:00 <cwl> Cale: so, apply (>>=) on an IO Monad means 'executing a monad', is that right?
19:52:02 <edwardk> cwl: monads are not inherently impure. lots of monads are just a slightly different style of pure function
19:52:08 <edwardk> cwl: no
19:52:16 <edwardk> cwl: >>= means do this, then with the result, do that
19:52:19 <kmc> cwl, no.  the only IO value which is executed is the one named 'main'
19:52:25 <edwardk> at least when you finally run it
19:52:27 <kmc> if x is an IO action, (x >>= f) is another IO action
19:52:28 <Cale> cwl: You should think of a value of type (IO t) as a bunch of instructions describing some things which could be done to produce a value of type t. Evaluating an expression to produce a value of type IO t has no visible effects (except possibly to use up some memory and CPU time), but executing it can do arbitrary things, like printing to the screen and communicating over the network.
19:52:34 <kmc> cwl, execution is the act of performing the actions described
19:52:38 <kmc> cwl, read http://www.haskell.org/haskellwiki/Introduction_to_IO
19:52:39 <edwardk> >>= just builds a bigger monadic action, it doesn't cause it to run
19:52:59 <edwardk> haskell cleanly separates 'determining what to do' from 'doing it'
19:53:26 <Cale> cwl: If x is some IO action, and f is a function from possible results of x to further IO actions, then x >>= f is the IO action which, if executed, will first execute x, then capture its result v, and then execute f v
19:54:31 <cwl> Cale: does IO action equal to IO Monad?
19:54:34 <Cale> *Evaluating* (x >>= f) won't do much worth noting -- it will do something implementation-dependent to turn the expression x >>= f into an appropriate description of what needs to be done.
19:54:50 <Cale> cwl: An IO action is a value. IO itself (the type constructor) is a monad.
19:54:56 <Cale> Monads are not values.
19:55:01 <kmc> cwl, read http://www.haskell.org/haskellwiki/Introduction_to_IO
19:55:15 <Cale> Monads exist at the level of types -- Maybe is a monad, Nothing and Just are not monads.
19:55:20 <cwl> IO action has type IO Monad
19:55:20 <Cale> IO is a monad, getLine is not a monad
19:55:40 <Cale> an IO action has type IO t for some type t, and IO is a monad.
19:55:54 <kmc> the fact that IO is a monad is not terribly relevant to how you use IO
19:56:09 <Cale> Saying that IO is a monad just means that there exist implementations of the operations:
19:56:12 <Cale> return :: a -> IO a
19:56:13 <Cale> and
19:56:21 <Cale> (>>=) :: IO a -> (a -> IO b) -> IO b
19:56:34 <Cale> which conform to some laws which make the do-notation work sensibly
19:56:59 <Cale> So it says something about the library for working on IO actions
19:57:00 <cwl> kmc: I am puzzled with the concept of 'executing a Monad'
19:57:09 <kmc> cwl, did you read http://www.haskell.org/haskellwiki/Introduction_to_IO ?
19:57:18 <Cale> cwl: Don't worry about that, it's the wrong question to be looking at :)
19:57:48 <shachaf> cwl: We're all puzzled with that concept. :-)
19:57:48 <Cale> cwl: Because what it means to execute a value whose type involves some monad is context dependent, and may or may not even make sense.
19:57:49 <kmc> cwl, there is no general concept of "executing a monad"
19:57:56 <edwardk> cwl: you probably should discard the notion of executing monads in general and replace it with how to 'execute some monad in particular'
19:58:04 <kmc> cwl, is your question about IO, or about monads? because IO is not a typical monad
19:58:06 <edwardk> it can be answered for a fixed monad
19:58:15 <Cale> cwl: Executing an IO action is a (fairly) well-defined process.
19:58:20 <kmc> in fact, there's a great writeup on the wiki about understanding IO in a simple concrete way, without involving monads
19:58:24 <kmc> now if only i could remember the URL
19:58:27 <cwl> kmc: monads
19:58:29 <kmc> ok
19:58:38 <Cale> cwl: "Executing" something of type m a where all we know is that m is a monad, is not well-defined.
19:58:41 <kmc> well, there is no concept of "executing a monad"
19:59:20 <cwl> kmc: I see..
19:59:22 <Cale> You can talk about executing a parser, and you can say that some Parser type constructor is a monad, but again, executing a monad in general doesn't necessarily make sense.
19:59:39 <kmc> :t runState
19:59:40 <lambdabot> forall s a. State s a -> s -> (a, s)
19:59:41 <kmc> :t either
19:59:43 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
19:59:50 <kmc> :t head
19:59:51 <lambdabot> forall a. [a] -> a
19:59:59 <shachaf> :t listToMaybe
20:00:00 <Cale> Executing a list can also be defined, sort of, though it's less sensible than the cases of IO or Parser
20:00:00 <lambdabot> forall a. [a] -> Maybe a
20:00:09 <Cale> and it would mean enumerating the elements of the list.
20:00:17 <Cale> (picking one in all possible ways)
20:00:33 <shachaf> kmc: Actually, I'd say "id" is the most reasonable meaning of "executing a list".
20:00:50 <kmc> *nod*
20:01:00 <kmc> one hidden source of confusion with monads is that some are abstract types and others aren't
20:01:09 <kmc> for the latter you don't need any "run" or "execute" function
20:01:12 <cwl> fun1 :: IO a -> [what is the possible type here]
20:01:19 <kmc> cwl, any Haskell type
20:01:49 <kmc> in some cases, though, you'd only be able to return 'undefined'
20:01:53 <ion> :t let fun1 :: IO a -> Maybe String; fun1 = undefined in fun1
20:01:54 <lambdabot> forall a. IO a -> Maybe String
20:02:04 <Cale> In general, if you have a monad m, you can look at what "v <- x" in do notation means in context, and define whatever that is to be "execution"
20:02:06 <kmc> cwl, if you're inquiring about the "one-way" property of IO, that's nothing to do with monads in general
20:02:17 <kmc> it's about the particular operations exposed for IO, and the operations that aren't exposed
20:02:23 <shachaf> @ty let fun1 :: IO a -> Maybe String; fun1 = Nothing in fun1 -- Why not total?
20:02:25 <lambdabot>     Couldn't match expected type `IO a -> Maybe String'
20:02:25 <lambdabot>            against inferred type `Maybe a1'
20:02:25 <lambdabot>     In the expression: Nothing
20:02:30 <shachaf> @ty let fun1 :: IO a -> Maybe String; fun1 _ = Nothing in fun1 -- Why not total?
20:02:31 <lambdabot> forall a. IO a -> Maybe String
20:02:40 <kmc> the Monad class gives you no way to drop the type constructor, but particular types can
20:02:53 <cwl> :t let fun1:: IO a -> Int
20:02:54 <lambdabot> <no location info>: not an expression: `let fun1:: IO a -> Int'
20:02:55 <kmc> anyway i think that was mentioned before
20:03:03 <Cale> It's just that the monad interface doesn't imply that there's a function of type m a -> a -- which should be obvious looking at the types of return and >>=, which only increase or leave the same the number of occurrences of m.
20:03:20 <kmc> cwl, how much Haskell do you know? what have you read so far?
20:03:32 <shachaf> cwl: You should probably not read RWH yet.
20:03:33 <cwl> chapter 14
20:03:38 <kmc> of?
20:03:41 <cwl> RHW
20:03:42 <shachaf> Maybe LYAH would be better.
20:03:45 <shachaf> @where lyah
20:03:45 <lambdabot> http://www.learnyouahaskell.com/
20:03:49 <kmc> maybe lyah would be better
20:04:04 <cwl> T_T I've read it
20:04:25 <kmc> okay
20:04:42 <Cale> cwl: In any case, my main answer to this would be to not worry about what execution is in general, and instead look at what it might mean for specific libraries which happen to involve a Monad instance.
20:04:53 <cwl> fun1 :: IO a -> [must be Monad type?]
20:04:58 <Cale> cwl: no
20:05:15 <kmc> :t let fun :: IO a -> Int; fun _ = 42 in fun
20:05:16 <cwl> :t let fun1 :: IO a -> Int
20:05:16 <lambdabot> forall a. IO a -> Int
20:05:17 <lambdabot> <no location info>: not an expression: `let fun1 :: IO a -> Int'
20:05:24 <Cale> cwl: Besides, different monads have very little in common with each other.
20:05:28 <kmc> cwl, your code isn't even a valid expression syntactically
20:05:38 <rwbarton> the only thing to say about that type is if you want your function to not be a constant function, the result type must involve IO somewhere
20:05:38 <ion> > let fun :: IO a -> Integer; fun _ = 42 in fun (putStrLn "o hai")
20:05:40 <lambdabot>   42
20:05:40 <Cale> cwl: To say that some library defines a monad is not really saying all that much at all.
20:05:45 <kmc> cwl, you really should read that Introduction to IO article.  your question is not about monads
20:05:49 <rwbarton> this statement doesn't say anything about monads
20:06:06 <Cale> cwl: It just implies the presence of some operations which have an appropriate "shape" and relationship to each other.
20:06:21 <Cale> cwl: But beyond that, it doesn't mean a whole lot.
20:06:21 <kmc> do non-empty lists form a monad?
20:06:31 <Cale> kmc: yeah.
20:06:36 <cwl> kmc: ok
20:06:39 <Cale> (the obvious one)
20:06:44 <kmc> the same as []
20:06:45 <kmc> cool
20:07:38 <Cale> Also, strictly infinite lists will additionally form a monad in a little different way, where join takes the diagonal.
20:07:55 <Cale> (which is isomorphic to the (->) Integer monad.)
20:08:32 <ion> Would you please elaborate on that?
20:09:06 <Cale> Well, an infinite list is the same thing as a function from Integer, in that you can index it at any integer, and the results of those indexing operations will completely determine which list it is.
20:09:13 <Cale> Yes?
20:09:20 <ion> Ah, indeed.
20:09:47 <ion> I still didn’t get the part about join taking the diagonal.
20:10:04 <Cale> Okay, so do you know what the (->) Integer monad does?
20:10:11 <Cale> join f v = f v v
20:10:12 <Cale> yes?
20:10:20 <ion> yeah
20:10:39 <Cale> So, if those function applications are looked at as list indexing operations
20:10:53 <ion> Now i get it. Thanks. :-)
20:11:01 <Cale> f v v means picking the v'th element of the diagonal of the list of lists f
20:11:05 <ion> yeah
20:12:02 <ddarius> kmc: Non-empty lists also form a comonad.
20:14:50 <Cale> As do functions from Integer, in as many ways as you can think up monoids for Integer.
20:15:57 <ion> > let join' = go 0 where { go n (x:xs) = (x !! n) : go (succ n) xs } in join' (iterate tail [0..])
20:15:59 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
20:17:37 <Rotsor> Can anyone here help me with converting an imperative GUI design into FRP one?
20:18:05 <Cale> Rotsor: hmm... what do you need help with?
20:18:11 <danharaj> How many comonads can be characterized as functions over a monoid?
20:18:31 <edwardk> ?
20:18:32 <Cale> Rotsor: (that's a big task in general, they're quite different in terms of how they express things)
20:18:53 <Cale> danharaj: Well, infinitely many
20:19:05 <Cale> Set-many
20:19:18 <danharaj> Cale: I didn't mean cardinality wise :p
20:20:07 <Rotsor> Cale: Yes, I understand that there are probably many ways to do that, but still having someone more experienced push me in the right direction seems to be a good start. I'll try to describe the problem in a minimal way now...
20:20:19 <danharaj> Try looking at Reactive-Banana
20:20:23 <Cale> Rotsor: which FRP library are you using?
20:20:25 <danharaj> seems to be the hip new thing.
20:20:43 <Rotsor> Cale: That's to be decided too!
20:21:59 <Cale> Rotsor: I've been working with iPwn Studios on a game using an in-house FRP implementation that we're working on.
20:23:02 <ion> Can someone recommend a nice FRP tutorial to get started with the concept?
20:23:17 <parcs> unfortunately the wx wrapper to reactive-banana comes with a shitload of dependencies due to bundled examples
20:25:37 <Rotsor> So, I have a UI control handling mouse events and displaying something, maintaining some internal state. I currently have (MouseEvent -> IO (), IO Image) type. What is a good FRP equivalent to this type? (I think I managed to minimize the question :D)
20:25:54 <arpunk> kmc: i solved the readline issue by symlinking the lib
20:25:57 <kmc> cool
20:26:01 <kmc> that's... a solution
20:27:34 <ion> parcs: Shouldn’t they be in something like reactive-banana-wx-examples instead then?
20:27:42 <Cale> Rotsor: Well... FRP unfortunately isn't so unified that the type will look the same in any library. It might be an arrow  MouseEvent ~> Image  or it might be (Behaviour MouseLocation, Event MouseClick) -> Behaviour Image
20:27:57 <arpunk> kmc: i guess... https://groups.google.com/forum/#!topic/yi-devel/JyJn4N82T6Y
20:28:07 <Rotsor> danharaj: thanks, I'll have a look at reactive-banana, I'm currently looking at netwire package too.
20:28:23 <Cale> Rotsor: How the type will look is highly dependent on which exact model of FRP you're talking about, since it's not so nailed down that people know exactly what the right thing is.
20:29:07 <Cale> (There are lots of tradeoffs being played around with between implementability/performance and abstraction/ease-of-use)
20:31:33 <Cale> "FRP" is basically a name for a general approach to looking at the problem of managing state. It consists largely in the realisation that there are two basic kinds of stateful values: there are things which always have a value whenever you look at them, which may be different each time (behaviours) -- things like the position of the mouse, the current time or date, what is being displayed on the screen, the contents of
20:31:33 <Cale>  a file, etc.
20:32:03 <Rotsor> Cale: I think I do understand the Behaviour/Event ones, but the Arrow one is not obvious. Does that represent something like event stream transformer?
20:32:13 <Cale> and there are things which have a value which occurs at discrete points in time (events) -- things like the sequence of keystrokes, etc.
20:32:38 <Cale> Well, arrows are more or less to be thought of as taking in and producing behaviours.
20:33:05 <Rotsor> Cale: But MouseEvent is not a behaviour, right?
20:33:23 <Cale> and each implementation has their own way of handling the case of events -- in Yampa for example, behaviours are secretly discretely updated, and so Yampa's event type is implemented in the same way as Maybe.
20:34:44 <Cale> This has some issues, but generally in arrowized FRP, events will be some special datatype
20:35:10 <Cale> and there will be an API surrounding that type like   hold :: a -> (Event a ~> a)
20:35:16 <kmc> is there any nice way to derive the non-record Show / Read for a record type?
20:35:32 <kmc> er "record constructor" i guess i should say
20:35:39 <Cale> (produce a behaviour with a given initial value which is updated on each occurrence of the Event)
20:35:55 <Cale> and many others, of course
20:36:38 <Cale> kmc: well... maybe Data.Generics.Text will do
20:36:59 <Cale> hmm, do we have that here...
20:37:09 <Cale> > gshows [1,2,3] ""
20:37:10 <lambdabot>   Not in scope: `gshows'
20:37:20 <kmc> > Data.Generics.Text.gshow (All false)
20:37:21 <lambdabot>   Not in scope: `Data.Generics.Text.gshow'Not in scope: `false'
20:37:25 <kmc> buh
20:37:28 <kmc> > Data.Generics.Text.gshow (All False)
20:37:29 <lambdabot>   Not in scope: `Data.Generics.Text.gshow'
20:38:07 <Cale> bah, not an instance of Data either, due to negligence
20:38:17 <Cale> but that can be corrected with standalone deriving
20:39:39 <kmc> yeah
20:39:48 <kmc> GHC should export a CPP macro for "all derivable classes" :D
20:39:55 <kmc> they are something of a moving target
20:39:56 <Rotsor> Cale: Thank you, I'll go look at some libraries then. Do you know any working monadic one? Or do you think arrow-based approach is better?
20:40:01 <kmc> i predict lots and lots of orphan instances for Generic
20:41:00 <Cale> Rotsor: The arrow based approach has its upsides and downsides. It's harder to abstract over things you construct, but also easier to solve performance problems, because you essentially have explicit control over sharing.
20:41:53 <Cale> When you define something as a plain Haskell value and use it in two places, it's really hard to regain control over whether that value is retained and shared or not -- especially at the library level.
20:42:22 <Rotsor> Cale: indeed
20:42:54 <Cale> With the arrow approach, every place at which the value is split into two is explicitly marked (it's a use of &&&)
20:43:47 <adxp> what's the best way of dealing with polymorphic C functions when calling from haskell? I'm working with a function that places a value at a void * pointer, whose type will be determined by other arguments to the function
20:43:48 <Cale> But you pay for this information in the form of a much less easy to use syntax.
20:44:36 <Rotsor> Cale: And less expressive power? Without MonadApply at least.
20:44:41 <Cale> Rotsor: yes.
20:45:19 <Rotsor> Cale: And with MonadApply you run into the monad problems, right?
20:45:58 <Rotsor> Cale: oops, ArrowApply
20:46:00 <Cale> Rotsor: Well, people are a little glib about the ArrowApply thing -- while it's true that you can always define a corresponding Monad where you have an ArrowApply instance, it's not always true that using that Monad instance will get you code with the same performance behaviour.
20:47:03 <Cale> (because using the Arrow operations and syntax will still be buying you a whole lot in terms of being able to inspect at least most of the structure of your code)
20:48:20 <Rotsor> Cale: I see. I didn't know "glib" was anything except the library though. :)
20:48:32 <Cale> aha
20:48:48 <Cale> Unfortunately, Arrow itself is kind of incomplete in that proc/do notation needs to use 'arr' a whole lot in order to do what amounts to a lot of fst, snd, swap and left and right reassociations of pairs, and this absolutely kills one's ability to do meaningful analysis.
20:49:12 <Cale> (any arr with a lambda inside it is essentially a black box that you can't see through)
20:50:07 <Cale> We have our own class ArrowPair, and a custom preprocessor to do a better job of translating the arrow syntax in terms of those operations, and that bought us at least a 3x speedup in our code, if not more.
20:50:42 <Rotsor> Cool
20:51:31 <Cale> Hopefully we'll eventually convince people that it's a good idea and make it into something built into GHC, but for now we're focused more on getting the game done :)
20:52:00 <Cale> I actually think that the laws described for Arrow instances in the papers and elsewhere aren't the right laws as well.
20:52:19 <Cale> They permit Arrow to be a generalisation of Monad, but it really shouldn't generalise Monad.
20:52:47 <Cale> In particular, the law (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k) is a really good law to have
20:52:55 <Cale> and most Kleisli arrows fail it.
20:53:12 <Cale> But it means that the arrow diagrams that everyone draws will actually make sense
20:53:23 <Rotsor> Is there any library defining simple classes abstracting over the implementation of FRP primitives? I have my own FRP in Java and would like to try to run some benchmarks of my FRP vs some other FRP, and for that I have to have some common interface.
20:53:33 <kmc> ugh, the code GHC generates for Read with -ddump-deriv isn't portable
20:53:40 <Cale> Without that, the way that you lay out the diagram on the page has an effect on what it actually means, and you can't just topologically distort things.
20:53:42 <kmc> anyone have a quick guide to writing Read instances by hand?
20:53:54 <Cale> (and if you think of these things like circuits, that's brutal)
20:54:27 <Cale> Rotsor: I don't think there's even enough agreement on what the FRP primitives ought to be
20:54:32 <bfig> i want to make a monadic-for-combinator using the Y combinator, but i'm getting type errors. can you help me understand what's wrong with this?
20:54:42 <Cale> bfig: I'll have a loog
20:54:44 <Cale> look*
20:54:47 <kmc> bfig, the Y combinator doesn't type-check
20:54:59 <bfig> one seg i'll paste the code for all to see
20:55:02 <Cale> Sure it does, if you're using an isorecursive type to make it do so
20:55:02 <kmc> it involves an infinite type; you call a function with itself as argument
20:55:12 <kmc> Cale, ;P
20:55:47 <bfig> http://pastebin.com/B2AMvpVX
20:55:49 <mauke> The paste B2AMvpVX has been copied to http://hpaste.org/50481
20:56:22 <Cale> bfig: So, first, write the function in a simple recursive way.
20:56:30 <Cale> yeah?
20:56:39 <bfig> ok
20:57:21 <parcs> ion: yeah they ought to
20:58:18 <Rotsor> Cale: thanks again, I'll try to apply the received knowledge now. :)
20:59:20 <parcs> actually 0.4.0.0 doesn't seem to carry the examples, and it's still the latest major version
20:59:38 <shachaf> kmc: The documentation at http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Read seems reasonable?
20:59:54 <Axman6> bfig: return doesn't mean what you think it means
21:00:02 <Axman6> :t return
21:00:03 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
21:00:25 <Cale> for :: Monad m => (t, t -> Bool, t -> t) -> (t -> m a) -> m ()
21:00:28 <Axman6> maybe you want return (), or return i
21:00:29 <Cale> ^^ this is the type you want?
21:00:46 <Cale> for (i, cond, iter) body = if cond i then return () else do body i; for (iter i, cond, iter) body
21:00:49 <bfig> what does return () mean?
21:00:52 <parcs> wait no. it still carries all the examples just not the cabal-macosx dependency
21:01:03 <Cale> return () is the action which does nothing, and returns ()
21:01:06 <Cale> It's a no-op.
21:01:30 <Cale> It doesn't have the control effect that "return" does in most imperative languages
21:01:51 <Cale> (which is like calling the current continuation, if you've wrapped each definition in a call/cc)
21:02:03 <bfig> i figure return is a function to be chained, ie, if you had a result that was passed to this monad, now that's the result
21:02:35 <Cale> You're using the word monad in a way which I find confusing.
21:02:59 <Cale> IO is an example of a monad
21:03:00 <bfig> maybe i'll start from the beginning and you tell me where i fail
21:03:01 <Cale> as is Maybe
21:03:12 <Cale> Just and Nothing aren't monads
21:03:16 <Cale> and getLine isn't a monad
21:03:19 <bfig> a monad is a set with an operation and a unit
21:03:29 <bfig> the operation is associative. that's it
21:03:32 <Axman6> that's a monoid no?
21:03:32 <Cale> Err... you're thinking of a monoid
21:03:39 * Axman6 wins!
21:03:44 <bfig> so a monad is an element of a monoid?
21:03:48 <Axman6> no
21:03:49 <Cale> Though if you generalise far enough, they're "the same thing"
21:03:56 * bfig is confused
21:04:03 <Cale> But the generalisation would take a lot of explaining.
21:04:15 <bfig> so what is the mathematical definition of monad?
21:04:22 <Axman6> it's best to think for now that monads and monoids aren't related (shhhh everyone!)
21:04:29 <Cale> (monads are monoid objects in a category of endofunctors, monoids are monoid objects in Set)
21:04:37 <shachaf> A monad *does* have an associative operation and a unit, though!
21:04:56 <shachaf> I mean, independent of the Monoid class.
21:05:03 <Cale> bfig: Are you familiar with categories and functors?
21:05:07 <Cale> and natural transformations?
21:05:11 <bfig> Cale, minimalistically >_>
21:05:14 <Cale> bfig: okay
21:05:42 <Cale> So a monad is a functor T: C -> C together with natural transformations eta (return) : 1 -> T
21:05:48 <Cale> and mu (join) : T^2 -> T
21:06:22 <Cale> In Haskell, the category C is the category whose objects are Haskell types and whose arrows are functions between them
21:06:27 <Cale> and T is a type constructor
21:06:42 <Cale> The natural transformations involved are implemented as polymorphic functions
21:06:49 <Cale> return :: a -> T a
21:06:55 <Cale> join :: T (T a) -> T a
21:06:57 <bfig> so it is a function constructor of functions on haskell Types?
21:07:12 <Cale> T constructs types from other types
21:07:31 <bfig> so a monad is no the function itself but a function constructor, i mean
21:07:38 <bfig> 'technically'
21:07:48 <Cale> So, for instance, Tree might be a type constructor, where Tree Integer is a type of trees whose nodes contain Integer values
21:07:57 <Cale> A type constructor
21:08:47 <Cale> And then we could make Tree into a monad by implementing  return :: a -> Tree a and join :: Tree (Tree a) -> Tree a in a way which agrees with a few laws I have neglected to mention
21:09:17 <Cale> In fact, for most tree datatypes, there is a way to do this.
21:09:33 <Cale> (though it's easier for those with values only in the leaves)
21:11:13 <bfig> where can i see simple examples of using >>=
21:11:16 <Cale> Actually, in Haskell we define monads in terms of return and another operation from which join can be derived (and which can be derived from join and fmap)
21:11:23 <Cale> Which is >>=
21:11:43 <Cale> Well, I'll produce some examples here if you like :)
21:11:57 <bfig> absolutely, if you want and the channel doesn't mind :)
21:12:05 <kmc> shachaf, yeah, it is reasonable actually
21:12:12 <Cale> In many monads we use in Haskell, values of type T a are to be thought of as some sort of structured computation with a result of type a
21:12:19 <kmc> i put together a half decent Read instance
21:12:47 <Cale> For example, a type (Parser a) might be used to represent parsers which eat the beginning of some string and parse values of type a from it
21:13:06 <shachaf> kmc: Why did you need to write out a Read instance?
21:13:10 <shachaf> Oh, for the record thing?
21:13:12 <kmc> yeah
21:13:25 <Cale> Or (IO a) is used to represent (descriptions of) computations which can do arbitrary I/O before producing a result of type a
21:13:36 <Cale> So, let's look at an IO example
21:14:05 <Cale> If x :: IO t is some IO action, and f :: t -> IO s is a function from possible results of x to further IO actions, then...
21:14:28 <kmc> should one put QuickCheck instances in the module where a type is defined, or in another module in the same package, or in a different package?
21:14:42 <Cale> x >>= f is the action which if executed will first run x, capturing its result, and then apply f to that result to get another action, and then run that
21:14:52 <Cale> So:
21:14:56 <Cale> getLine :: IO String
21:15:03 <Cale> putStrLn :: String -> IO ()
21:15:22 <Cale> and   getLine >>= putStrLn  is then the action which gets a line from the user and prints it back out
21:15:31 <Cale> We can also use do-notation:
21:15:38 <bfig> don't use do please
21:15:39 <Cale> do v <- getLine; putStrLn v
21:15:42 <bfig> :D
21:15:50 <Cale> and that will translate back into >>=
21:16:09 <bfig> ok. a basic question, how do i represent complicated states?
21:16:24 <bfig> i programmed a parser once which had a state, but i used do. that's like cheating >_>
21:16:24 <Cale> Well, okay... that's not really related to monads :)
21:16:37 <Cale> But sure, some monads exist for managing stateful computations
21:16:49 <Cale> do isn't cheating, it's just syntax sugar
21:16:51 <bfig> i mean, if i want to get two strings, do i need to wrap wrap wrap the monads and then unwrap unwrap unwrap?
21:17:02 <Cale> Oh, were you using monad transformers?
21:17:03 <bfig> it's *cheating* till i understand them >_>
21:17:13 <bfig> no, just thinking out loud.
21:17:21 <Cale> Monad transformers are a whole other beast :)
21:17:25 <bfig> ie, i get a couple lines, then want to print them out
21:17:29 <Cale> oh, sure
21:17:38 <Cale> okay, so this is where do notation excels :)
21:17:43 <bfig> for example, grabbing three lines, then printing them in the same order, not in reverse
21:17:45 <Cale> but we can translate back and forth
21:17:47 <Cale> okay
21:17:54 <Cale> getLine >>= \v ->
21:17:59 <Cale>   getLine >>= \w ->
21:18:16 <Cale>     getLine >>= \x ->
21:18:36 <Cale>       putStrLn v >> putStrLn w >> putStrLn x
21:18:49 <Cale> Where x >> y = x >>= \k -> y
21:19:01 <bfig> you can't avoid using a lambda with a monad inside right?
21:19:10 <Rotsor> replicateM 3 getLine >>= mapM putStrLn
21:19:14 <Cale> Well, it's just really really convenient
21:19:16 <Rotsor> avoided a lambda
21:19:17 <Rotsor> :D
21:19:21 <Cale> You can avoid it with enough trickery.
21:19:21 <bfig> :D
21:19:29 <shachaf> bfig: "a monad inside" still doesn't make much sense. :-)
21:19:30 <Cale> Either by using things like replicateM
21:19:34 <shachaf> putStrLn "foo" isn't a monad.
21:19:44 <Cale> or by using enough defined combinators to eliminate the use of lambda
21:19:55 <Cale> right, I also wanted to point that out
21:19:56 <bfig> shachaf, but you have an IO ()  inside that
21:20:03 <Cale> we're just using one monad here, which is IO itself
21:20:04 <shachaf> bfig: IO () isn't a monad either.
21:20:08 <shachaf> Nor are values of type IO ().
21:20:20 <bfig> the combinators in this case let you build a list of monads, then execute them sequentially?
21:20:27 <Cale> Values of type IO t are called IO actions usually
21:20:39 <Cale> a list of monadic actions, yes
21:20:43 <bfig> sorry, IO String -> (), right?
21:20:52 <bfig> no, String -> IO ()
21:21:02 <Cale> putStrLn :: String -> IO ()
21:21:21 <Cale> It's a pure function which takes a string, and produces the IO action which when run will print the string on the screen.
21:21:25 <shachaf> Cale: You really only need a couple of combinators, which are already defined in Haskell anyway. :-)
21:21:31 <Cale> shachaf: indeed
21:21:55 <Cale> @pl getLine >>= \v -> getLine >>= \w -> getLine >>= \x -> putStrLn v >> putStrLn w >> putStrLn x
21:21:56 <lambdabot> (getLine >>=) . ((getLine >>=) .) . flip flip putStrLn . (((.) . (>>)) .) . (. putStrLn) . (>>) . putStrLn =<< getLine
21:22:01 <Cale> ^^^ lolololol
21:22:12 <mustelo> it's so obvious
21:22:32 <shachaf> @pl getLine >>= \v -> getLine >>= \w -> getLine >>= \x -> mapM_ putStrLn [v,w,x]
21:22:32 <lambdabot> (getLine >>=) . (((getLine >>=) . (mapM_ putStrLn .)) .) . (. ((. return) . (:))) . (.) . (:) =<< getLine
21:22:35 <Cale> I'm sure a human could do better with a bit of thought
21:22:45 <bfig> holy hell
21:22:48 <Cale> But it's still not going to look very good.
21:22:52 <bfig> :D
21:22:55 <shachaf> replicateM or some such would make it much nicer.
21:23:19 <shachaf> @pl getLine >>= \v -> putStrLn v >> getLine >>= \w -> putStrLn w >> getLine >>= \x -> putStrLn x
21:23:19 <lambdabot> putStrLn =<< (>> getLine) . putStrLn =<< (>> getLine) . putStrLn =<< getLine
21:23:30 <Cale> Lambda exists for a reason, after all.
21:23:30 <shachaf> And so on.
21:23:40 <shachaf> To confuse the enemy!
21:24:03 <bfig> so what are the basic combinators used?
21:24:12 <shachaf> fix
21:24:22 <bfig> i've been playing with fix f = f (fix f)
21:24:23 <shachaf> ...And a few others, I guess.
21:24:26 <Cale> by @pl, or for monads in general?
21:24:36 <bfig> in general
21:24:49 <Cale> return and >>= are used to build up everything else in the monad library
21:24:59 <bfig> what's =<< ?
21:25:04 <shachaf> Cale: return, (>>=) and fail!
21:25:08 <shachaf> fail is such a great function.
21:25:09 <Cale> f =<< x = x >>= f
21:25:16 <bfig> >_>
21:25:26 <kmc> Cale, you ought to use a vertically-symmetric character instead of 'f'
21:25:28 <Cale> (it's just a flipped over version of >>=
21:25:29 <Cale> )
21:25:32 <bfig> ok. let me see if now i can build my monad stuff
21:25:35 <kmc> v =<< x = x >>= v
21:25:40 <Axman6> kmc: agreed
21:26:02 <bfig> thanks for explaining this, very good explanations :)
21:26:11 <Cale> bfig: Basically the realisation here is that many libraries support operations of the appropriate "shape" for return and >>= and by abstracting over those operations, we can write some stuff which works for all those libraries.
21:26:19 <Cale> bfig: for example..
21:26:20 * shachaf vanishes in a puff of orange smoke.
21:26:25 <Axman6> @do getLine >>= \v -> putStrLn v >> getLine >>= \w -> putStrLn w >> getLine >>= \x -> putStrLn x
21:26:26 <lambdabot> do { v <- getLine; w <- do { putStrLn v; getLine}; x <- do { putStrLn w; getLine}; putStrLn x}
21:26:30 <Cale> sequence :: (Monad m) => [m a] -> m [a]
21:26:34 <Axman6> ha
21:26:38 <Axman6> that's awesome
21:26:50 <Cale> is an operation which takes a list of actions in some monad, and produces a single action which runs them all, giving a list of their results
21:26:50 <kmc> wonder what kind of emoticon is v=<<x=x>>v
21:26:54 <kmc> > fix ((1:).(>>=(:)<$>(1+)<*>((:[]).(1/).(1+)))
21:26:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:27:05 <kmc> > fix ((1:).(>>=(:)<$>(1+)<*>((:[]).(1/).(1+))))
21:27:07 <lambdabot>   [1.0,2.0,0.5,3.0,0.3333333333333333,1.5,0.6666666666666666,4.0,0.25,1.33333...
21:27:16 <Cale> > fix ((1:).(>>=(:)<$>(1+)<*>((:[]).(1/).(1+)))) :: [Rational]
21:27:17 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
21:27:24 <kmc> > fix ((1:).(>>=(:)<$>(1+)<*>((:[]).(1%).(1+))))
21:27:25 <lambdabot>   Occurs check: cannot construct the infinite type:
21:27:25 <lambdabot>    t = GHC.Real.Ratio t
21:27:33 <bfig> lol
21:27:35 <Cale> bfig: In the IO monad, sequence does exactly as you'd expect
21:28:00 <Cale> bfig: in the list monad, sequence becomes a sort of Cartesian product -- picking one element from each of the lists in all possible ways
21:28:02 <Axman6> list of actions -> an action with a list of results
21:28:15 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
21:28:16 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
21:28:17 <kmc> > elemIndex (22 % 7) $ fix ((1:).(>>=(:)<$>(1+)<*>((:[]).(1%).(1+))))
21:28:18 <lambdabot>   Occurs check: cannot construct the infinite type:
21:28:18 <lambdabot>    t = GHC.Real.Ratio t
21:28:28 <kmc> > elemIndex (22 % 7) $ fix ((1:).(>>=(:)<$>(1+)<*>((:[]).(1/).(1+))))
21:28:29 <lambdabot>   Just 519
21:28:30 <Cale> In a parsing monad, it would be the concatenation of the parsers
21:28:32 <Cale> and so on
21:28:45 <Cale> In any library which defines a monad instance, sequence will probably do something useful
21:28:52 <rwbarton> that looks like J code almost
21:28:57 <bfig> ahh now i understand the parsers :D
21:28:58 <bfig> :DDDDDDDD
21:28:59 <Cale> and there's a whole library of operations which work with any monad instance
21:29:06 <bfig> :DDDDDDDDDDDDDDDD
21:29:19 <Cale> and by defining those instances where we can, we get those operations implemented for free
21:29:21 <bfig> i wrote a parser which didn't use sequence but now i understand why it would make sense :DDDD
21:29:27 <Cale> yeah :)
21:29:34 <bfig> the concatenation operator is just sequence :DD
21:29:35 <kmc> > elemIndex (335 % 113) $ fix ((1:).(>>=(:)<$>(1+)<*>((:[]).(1/).(1+))))
21:29:39 <lambdabot>   mueval-core: Time limit exceeded
21:29:49 <bfig> if you define the return type as a list of parser monads :D
21:30:17 <bfig> and at the end you can use something like take 1 and it'll get the first one :DDD
21:30:26 <Cale> If you have a list of (monadic) parsers, then sequence will turn it into a single parser which constructs a list
21:30:44 <bfig> so the sequence is for free if you define them as monads, i had to implement it myself
21:30:47 <Cale> yeah
21:31:02 <bfig> cool. maybe i could try turning that parser into a monadic parser just for fun
21:31:18 <Axman6> elemIndex (103993 % 33102) $  fix ((1:).(>>=(:)<$>(1+)<*>((:[]).(1/).(1+))))
21:31:23 <Cale> If you define return (which is the parser which succeeds automatically without eating any input, returning the given result) and >>=
21:31:45 <Axman6> bah, forgot the >, and i know it won't work anyway -_-
21:31:55 <Cale> where x >>= f is the parser which parses the start of the input with x, and then takes the constructed value and applies f to it to parse the remainder of the input
21:32:16 <Axman6> @index fix
21:32:17 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
21:32:26 <Axman6> hmm
21:32:27 <Cale> (with a little extra detail to handle backtracking usually)
21:32:30 <Axman6> @hoogle fix
21:32:31 <lambdabot> Data.Function fix :: (a -> a) -> a
21:32:31 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
21:32:31 <lambdabot> module Control.Monad.Fix
21:33:07 <Cale> You also get things like  mapM f x = sequence (map f x)
21:33:15 <Cale> or, the flipped over version:
21:33:17 <Axman6> > 103993 / 33102 :: CReal
21:33:18 <lambdabot>   3.141592653011902604072261494773729684007
21:33:22 <bfig> now you lost me
21:33:27 <Cale> okay
21:33:40 <Axman6> :t mapM
21:33:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
21:33:44 <Cale> forM xs f = sequence (map f xs)
21:33:48 <Cale> so, what is this thing?
21:33:57 <Cale> Well, it applies the function f to each element of xs
21:33:59 <bfig> forM?
21:34:09 <Cale> and then sequences the resulting list of actions together
21:34:16 <Cale> So: it is essentially a foreach loop.
21:34:25 <Cale> In an arbitrary monad :)
21:34:32 <bfig> ok, that i understand. are those actions executed in sequence?
21:34:34 <Cale> yeah
21:34:46 <Axman6> that's what sequence does :)
21:34:49 <Cale> (to the extent that the monad defines what it means to be executed in sequence)
21:34:50 <bfig> why would that be that way?
21:35:14 <Cale> Now, in things like the list monad, *evaluation* is almost completely separate from this sense of execution.
21:35:33 <bfig> i mean, if you construct the list and then do tail tail tail, isn't that going to leave the first three sequenced elements untouched?
21:35:46 <bfig> ie, unevaluated?
21:35:47 <Cale> sure, but that's evaluation and not execution
21:35:56 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7]; return (x,y,z)
21:35:57 <lambdabot>   [(1,4,6),(1,4,7),(1,5,6),(1,5,7),(2,4,6),(2,4,7),(2,5,6),(2,5,7),(3,4,6),(3...
21:36:01 <bfig> then i don't know what execution means
21:36:13 <Cale> Yeah, well, it means a different thing in every monad
21:36:32 <Cale> In the list monad, "executing" a list means nondeterministically selecting one of its elements (that is, in all possible ways)
21:36:46 <Axman6> it should be noted that i think evaluation and execution mean slightly different things to different people
21:36:49 <bfig> what?
21:36:57 <Axman6> depending on how accurate you're being
21:37:34 <Cale> bfig: When we write  x <- [1,2,3]  what it means is that x is chosen from the list [1,2,3] in all possible ways, and the results of the remainder of the computation are collected up into a list
21:37:52 <Cale> The implementation of this is just that  xs >>= f = concat (map f xs)
21:37:56 <ivanm> Axman6: evaluation being getting the result, execution the side effects, etc. ?
21:38:14 <Axman6> maybeh...
21:38:18 <Cale> (that is, we apply the remainder of the computation to each element of xs, and we concatenate the resulting lists together)
21:38:32 <Cale> to complete the story,  return v = [v]  in this monad
21:38:42 <bfig> wait, one second
21:39:00 <Axman6> So apparently running 'elemIndex (103993 % 33102) $  fix ((1:).(>>=(:)<$>(1+)<*>((:[]).(1/).(1+))))' can easily use over 4GB RAM in ghci
21:39:03 <bfig> :t sequence
21:39:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:39:24 <Cale> (you can ignore all the junk in the type signature before the '.')
21:39:31 <bfig> it turns a list of monads into a monad containing a list
21:39:48 <Axman6> "monads" isn't really a thing
21:40:00 <Cale> A list of monadic values into a monadic value of lists :)
21:40:06 <dolio> They're a thing. They're just not that thing.
21:40:10 <bfig> let's call it a 'sequentiable element' ?
21:40:13 <Axman6> yeah
21:40:28 <Cale> Or a list of actions into an action of lists
21:40:28 <bfig> or 'conditionally sequentiable element'
21:40:48 <Cale> (if we're sufficiently general about our sense of the word 'action')
21:40:49 <parcs> Axman6: try compiling it with -O2 and running it
21:40:55 <Axman6> yeah
21:40:58 <bfig> action could be a const right?
21:41:04 <bfig> ie, a type constructor?
21:41:27 <Cale> The monad itself is a type constructor, and lives on the right hand side of ::
21:41:52 <Cale> The values it defines might involve some data constructors, which live on the left hand side of ::
21:41:58 <Cale> value :: type
21:42:14 <bfig> ok my head exploded right now
21:42:18 <Cale> okay
21:42:27 <Cale> So, types only exist at compile time, yeah?
21:42:40 <bfig> maybe tomorrow you can explain >_>
21:42:42 <Cale> Anything which is present in the program at runtime is a value.
21:42:45 <bfig> right now i can barely think
21:42:47 <Cale> okay
21:42:57 <Cale> (at least in good implementations of Haskell)
21:43:02 <bfig> in a couple hours my brain will have allegedly rested :)
21:43:13 <Axman6> parcs: hmm, interestingly it doesn't seel to reduce space usage... i'm guessing it's storing the infinite list though
21:43:27 <Axman6> @unpl ((1:).(>>=(:)<$>(1+)<*>((:[]).(1/).(1+))))
21:43:28 <lambdabot> (\ i -> 1 : (i >>= ((((:)) <$> \ b -> 1 + b) <*> \ l -> (1 / (1 + l)) : [])))
21:43:31 <Cale> bfig: But yeah, actions in this sense can be constant values.
21:43:32 <ddarius> @wn monad
21:43:33 <lambdabot> *** "monad" wn "WordNet (r) 2.0"
21:43:34 <lambdabot> monad
21:43:34 <lambdabot>      n 1: an atom having a valence of one
21:43:34 <lambdabot>      2: a singular metaphysical entity from which material
21:43:34 <lambdabot>         properties are said to derive [syn: {monas}]
21:43:35 <lambdabot>      [also: {monades} (pl)]
21:43:39 <Cale> bfig: and in fact, typically are
21:43:49 <ddarius> Monad is thingness itself.
21:44:07 <Cale> aw, that's the wrong sense of monad
21:44:18 <Cale> We need to talk to those WordNet folks.
21:44:58 <ddarius> Yeah, certainly late '50s mathematics supercedes 17th century philosophy.
21:45:55 <bfig> you say late '50s like it was old >_>
21:46:23 <bfig> well, thanks for the lessons :D
21:46:27 <bfig> good night
21:46:37 <Cale> g'night!
21:49:07 * hackagebot file-location 0.4.1 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.1 (GregWeber)
21:53:58 <dibblego> is there anything like Traversable where the Applicative being traversed through is also a type variable on the type-class, for optimisation?
22:00:16 <parcs> what is the fixity on backquoted operators?
22:01:24 <coppro> whatever it's declared to be
22:01:56 <Rotsor> and what is the default?
22:02:59 <dolio> infixl 9 is always the default.
22:14:13 <kmc> there's no way to suppress GHC's "orphan instance" warning for a single instance, is there?
22:14:57 <edwardk> nope, just for a whole file
22:15:35 <edwardk> i suppose one could move that instance into yet another file and compile just that file with -fno-warn-orphan-instances
22:15:45 <edwardk> and then import it, as it is an orphan anyways ;)
22:16:15 <kmc> if i were willing to move the instance then it wouldn't be an orphan anymore ;)
22:16:24 <edwardk> hah
22:17:35 <mustelo> what's the best way to handle parsing of mixed ascii and binary data in a file?
22:20:37 <shachaf> mustelo: Read it as binary data, transform the ASCII bits yourself?
22:25:13 <kmc> http://hackage.haskell.org/packages/archive/text/0.11.1.5/doc/html/Data-Text-Lazy-Encoding.html#v:decodeUtf8
22:25:22 <kmc> mustelo, ^^^^
22:25:28 <kmc> ASCII is a subset of UTF-8
22:26:11 <kmc> though it is not surprising to find "ASCII" files that use codepoints above 127
22:26:55 <NihilistDandy> Can someone tell me what CSE stands for? As in, http://www.haskell.org/haskellwiki/GCD_inlining_strictness_and_CSE
22:27:17 <mustelo> hmm, so I'm mostly thinking about how to transition between the different parts of the file. figuring out which parts are text and which are binary data
22:27:18 <shachaf> kmc: If it's just ASCII, Text might be an inefficient way of storing it in memory.
22:27:24 <shachaf> Though it probably doesn't matter.
22:27:32 <shachaf> NihilistDandy: Common Subexpression Elimination.
22:28:10 <shachaf> mustelo: Presumably that depends on the file format. :-)
22:28:25 <NihilistDandy> shachaf: Thank you. I was reading the Cafe and there's a discussion going on that I felt ignorant about. Is there an explanation of what that entails in GHC, or is it just something you figure out eventually?
22:28:47 <NihilistDandy> I don't really know what qualifies as "common"
22:29:01 <kmc> > (2 + 2) * (2 + 2)
22:29:01 <lambdabot>   16
22:29:07 <kmc> (2 + 2) is a common sub-expression
22:29:11 <kmc> it could be lifted out and computed only once
22:29:16 <kmc> > let x = 2 + 2 in x * x
22:29:17 <lambdabot>   16
22:29:17 <NihilistDandy> Ah, okay
22:29:52 <NihilistDandy> That makes sense, then
22:30:02 <NihilistDandy> It actually makes the whole discussion make more sense :D
22:30:12 <shachaf> Hmm, the monomorphism restriction just made a lot more sense to me.
22:31:12 <NihilistDandy> shachaf: Really? Why?
22:31:51 <shachaf> When you have something like x :: Num a => a; x = complicated_expression, x will be recomputed each time you use it, even if it's the same type each time.
22:32:14 <shachaf> For some reason I'd thought its value would be cached if you used it as Int each time, but of course that doesn't happen.
22:32:23 <shachaf> (Maybe with some optimizations it would, but not in general.)
22:32:55 <parcs> what did you think the MR was for before this realization?
22:33:02 <NihilistDandy> Though would it be if x :: Int?
22:33:19 <shachaf> parcs: Avoiding accidental recomputation if it was used with several different types. :-)
22:33:50 <shachaf> Anyway, I still don't know if it makes enough sense to exist.
22:38:20 <wavewave> hi
22:38:30 <NihilistDandy> hi
22:38:39 <kmc> hi wavewave
22:38:47 <parcs> hello wavewave
22:38:58 <shachaf> Greetings, wavewave.
22:39:12 <wavewave> thanks for welcoming me!
22:39:23 <NihilistDandy> You're welcome!
22:39:58 <wavewave> just a fun question. who is jon harrop?
22:40:28 <NihilistDandy> omg
22:40:52 <dibblego> a renowned liar, with self-confessed ulterior motive
22:40:52 <wavewave> why is he so against haskell?
22:40:53 <NihilistDandy> That is a fun question in the way that tequila is a fun drink
22:41:08 <kmc> wavewave, because he runs a company that makes money by doing not-Haskell consulting
22:41:12 <dibblego> because he hasn't written any books on haskell, so he has nothing to gain by not being against it
22:41:14 <NihilistDandy> %%
22:41:17 <NihilistDandy> *^^
22:41:26 <kmc> he may have more principled reasons too
22:41:36 <NihilistDandy> I watched a talk he gave once
22:41:52 <wavewave> so he is a kind of professional?
22:42:00 <kmc> saying jdh is in the tank for F# because his company uses it is a little like saying dons is in the tank for Haskell because his company uses it
22:42:00 <dibblego> he has admitted that his incessant lying and dishonesty is purely for these motives
22:42:04 <NihilistDandy> I couldn't tell if it was his accent or the shitty sound quality that turned me off.
22:42:05 <kmc> dibblego, link?
22:42:10 <NihilistDandy> Or his dramatic attitude
22:42:24 <wavewave> hmm interesting.
22:42:26 <dibblego> hmm, didn't think you'd ask that :) I'll retract for now until I find it
22:42:42 <NihilistDandy> dibblego: Check the Lisp Usenet list
22:42:45 <dibblego> (sorry busy, working on a weekend)
22:42:53 <NihilistDandy> That's where I saw it
22:43:04 <dibblego> link?
22:43:13 <dibblego> that does ring a bell
22:43:16 <NihilistDandy> I can confirm that he admits to stirring up shit for the purpose of business.
22:43:21 <NihilistDandy> I'll look it up
22:43:24 <dibblego> ta
22:44:35 <wavewave> btw what is happening to 'hash-table' problem jon always mentions?
22:44:52 <NihilistDandy> wavewave: Just laugh whenever Jon talks.
22:45:12 <Rotsor> Can I write takeJusts :: (FRP f) => Event f (Maybe a) -> Event f a without using partial functions (like fromJust)? (that's reactive-banana I'm talking about)
22:45:45 <Rotsor> Lol, google suggests "Jon Harrop troll" when I type "Jon Harrop"
22:45:53 <wavewave> lol
22:47:37 <NihilistDandy> He's about as hilarious as Xah Lee
22:47:45 <arckay> hello
22:47:50 <NihilistDandy> Hi, arckay
22:47:57 * kmc wishes for a substantive breakdown of how jdh is wrong, instead of the usual name-calling
22:47:58 <shachaf> Greetings, arckay!
22:47:58 <wavewave> hi, arckay
22:48:01 <kmc> hi arckay!
22:48:27 <NihilistDandy> !!!!!
22:48:48 <NihilistDandy> kmc: Working on it. I don't know that he's necessarily wrong, by any means. He's just dickish.
22:49:09 <kmc> if he is a troll, then he's a very effective one, because we're always talking about him apropos of nothing
22:49:22 <NihilistDandy> Well, that much was established
22:49:32 <shachaf> kmc: This is the first discussion of him that I can think of this year.
22:49:45 <shachaf> Of course, maybe I'm just effective at forgetting unproductive IRC discussions. :-)
22:50:13 <wavewave> hh, sorry for the unproductive 'fun' ;-)
22:50:26 <dibblego> Scala has a "Jon Harrop"-like personality, extremely dishonest, but also clueless with personal motives rather than financial
22:50:43 <kmc> Scala is a person? or the language personified?
22:50:56 <dibblego> I mean, Jon Harrop is to Haskell as this guy is to Scala
22:50:57 <shachaf> kmc: I think dibblego means that such a person exists for Scala.
22:51:03 <kmc> ah
22:51:10 <NihilistDandy> dibblego: Who is it? :D
22:51:17 <wavewave> Scala is a perfect name for a person, though
22:51:26 <dibblego> also, Harrop once tried his tactics on Scala, but I think his motivation died (he was/wasn't writing a book or something)
22:51:31 * shachaf suspects #haskell-blah would be better for this sort of discussion.
22:51:40 <dibblego> yeah, sorry
22:53:36 <hpaste> kmc pasted “#haskell is obsessed” at http://hpaste.org/50482
22:53:48 <kmc> shachaf, ^^^^
22:54:37 <wavewave> ha, this is all the discussion about him.
22:55:05 <kmc> a lot more in #haskell-blah too
22:55:54 <shachaf> Jon Harrop discussion volume pales next to Jon Harrop discussion discussion volume.
22:55:57 <wavewave> what are other haskell-xxx channels?
22:56:27 <wavewave> do we have #haskell and #haskell-blah?
22:56:41 <NihilistDandy> shachaf: SO FUCKING META
22:56:55 <NihilistDandy> wavewave: Also, #haskell-in-depth
22:57:01 <NihilistDandy> But no one ever says anything
22:57:18 <wavewave> maybe that's too deep..
22:57:18 <kmc> we used to have #haskelgbt
22:57:27 <shachaf> #haskell-overflow, #haskell-web, #haskell-hacphi, #haskell-languageofyourchoice.
22:57:31 <shachaf> Spoken language, that is.
22:57:43 <kmc> #haskell-jbo ?
22:58:00 <NihilistDandy> kmc: That's awesome
22:58:06 <shachaf> kmc: #jbopre gets a fair amount of Haskell discussion.
22:58:11 <kmc> not surprising
22:58:32 <wavewave> jbo means job?
22:58:38 <kmc> it means Lojban
22:59:14 <ddarius> There are a -lot- of satellite channel to #haskell.
23:01:25 <wavewave> btw, yesterday, I watched agda introduction videos.
23:01:41 <wavewave> maybe in boston haskell meeting?
23:01:45 <ddarius> kmc: Hereditary Harrop formulas are real.
23:02:29 <wavewave> yes, it is. by Daniel Peebles.
23:02:45 <ddarius> Wait, the videos are somewhere?
23:02:54 <wavewave> yes. on youtube.
23:03:23 <wavewave> www.youtube.com/watch?v=shXKb2MTkUc
23:03:55 <wavewave> it's uploaded by edwardk
23:04:11 <wavewave> edwardkmett in youtube id.
23:05:06 <ddarius> Yeah, I was at the talk.
23:05:37 <wavewave> it is very intriguing to imagine what's the future of agda and haskell both.
23:06:28 <wavewave> I hope there will be more interoperability btwn two.
23:06:32 <NihilistDandy> My favorite quote is "Agda will be a better theorem prover than Coq when it's a better programming language than Haskell."
23:07:19 <wavewave> I haven't looked at Coq at all. Currently, Coq is regarded as better for theorem prover than agda?
23:07:29 <NihilistDandy> FSOV better, yes
23:07:29 <Rotsor> Which is supposedly "never"? Or "already"? :D
23:09:27 <wavewave> some part of agda can be implemented in haskell... like mixfix operator
23:09:41 <wavewave> and generalized GADT.
23:09:58 <wavewave> GGADT
23:10:07 <Rotsor> mixfix -- how?
23:10:25 <Rotsor> ah, you mean in future?
23:10:49 <wavewave> oops, yes in future.
23:11:01 <wavewave> I just wish ..
23:12:50 <wavewave> another question. what's the status of ghcjs?
23:12:52 <Rotsor> I rather wish for Haskell to take the Java/C#'s place and for us to move to Agda :D
23:13:15 <ddarius> chrisdone was fiddling with it today.  He got a JS Hello World out.
23:13:17 <Rotsor> I'm interested in this too!
23:13:30 <wavewave> Rotsor, probably that's more likely
23:14:05 <wavewave> if ghcjs is successful, it can be a tipping point of a revolution ;-D
23:14:25 <Rotsor> :)
23:14:33 <wavewave> nobody will write javascript code. hehe
23:15:45 <wavewave> in fact, javascript disguises people that it seems like an OOP language.
23:17:15 <wavewave> javascript people should identify themselves as a functional programmer.
23:17:35 <shachaf> Why?
23:18:09 <kmc> seems to me all good languages will support OOP and FP
23:18:20 <kmc> and anyone who pigeonholes a language, or themselves, is being silly
23:18:35 <kmc> i don't understand people who identify as "Java programmer" or "PHP programmer" instead of "programmer"
23:18:38 <NihilistDandy> kmc: My favorite languages are Smalltalk and Haskell :D
23:19:00 <NihilistDandy> I don't understand people who identify as "PHP programmer", either
23:19:05 <NihilistDandy> I mean, are they really programmers?
23:19:16 <kmc> probably
23:19:27 <wavewave> kmc: That's because we realized the zen of programming
23:19:30 <kmc> i guess the whole appeal of Java is that a "Java programmer" is a replaceable unit you can order
23:19:37 * shachaf is a php v5.2.10 programmer exclusively.
23:19:50 <kmc> and some people want to market themselves that way
23:19:57 <kmc> either because it's all they can do, or it's all they want to do
23:20:01 <wavewave> I am talking about usual programmers who think haskell is too distant from what they are doing.
23:20:16 <kmc> not everyone sees programming as some life-consuming quest
23:20:23 <kmc> for some it's just a job, and a damn nice one at that
23:21:10 <wavewave> whole industry seems to work like that. specifying specification.
23:22:22 <wavewave> anyway, it is undeniable that javascript is the most popular 'functional' programming language.
23:22:42 <kmc> yeah
23:22:52 <kmc> and js people actually embrace fp, at least the basics of it
23:23:04 <kmc> unlike Python, which has a cultural aversion, despite still using it constantly
23:23:17 <kmc> FP is pretty much ubiquitous; look at all the trouble people go to just to do FP in C or C++
23:23:20 <wavewave> what happens to python?
23:23:39 <kmc> wavewave, their Fearless Leader dislikes FP and considers it "unPythonic"
23:23:51 <wavewave> kmc: oh my god.
23:24:08 <kmc> Python is full of functions passing functions to functions
23:24:09 <wavewave> that's silly to me.
23:24:20 <kmc> but you're not supposed to point this out, or call it by its true name
23:24:46 <shachaf> Fortunately Ruby people like it, and Ruby = Python.
23:25:02 <wavewave> hmm.. it's a thing  who can not be named.
23:25:22 <kmc> the way mainstream languages work is a) make fun of FP, b) design your language against FP, c) implement FP anyway because it's bloody useful, d) change the names on everything so nobody finds out
23:25:45 <kmc> this might be changing soon
23:25:45 <shachaf> Who makes fun of FP?
23:25:47 <NihilistDandy> C needs lambdas that don't suck
23:25:49 <Eduard_Munteanu> wavewave: some say Coq is better, probably because Coq has proof tactics. Agda's getting there too, though.
23:25:55 <NihilistDandy> Does D have them, yet?
23:26:03 <shachaf> NihilistDandy: D has great lambdas.
23:26:04 <kmc> coq's proof tactics system will make any right-thinking individual vomit uncontrollably
23:26:09 <kmc> not that it's not useful
23:26:20 <NihilistDandy> shachaf: That's exciting. I might have to play with D, again
23:26:25 <kmc> meh
23:26:39 <NihilistDandy> kmc: Anything useful will make right-thinking individuals Vomit
23:26:41 <NihilistDandy> *vomit
23:26:45 <NihilistDandy> Also
23:26:48 <NihilistDandy> Auto.
23:26:54 <NihilistDandy> Qed.
23:27:02 <Eduard_Munteanu> And the ring solver.
23:27:13 <wavewave> Eduard_Munteanu: thanks for the info.
23:27:25 <Rotsor> Can one understand Coq proofs without additional tools btw?
23:27:35 <kmc> you can't understand a coq proof just by reading it
23:27:41 <kmc> you have to step through it in Coq
23:28:24 <Eduard_Munteanu> I think that applies to most theorem provers, that is, the proofs are quite involved.
23:28:43 <Rotsor> One can understand Agda proofs more or less
23:28:43 <kmc> it's quite different in Agda
23:28:55 <Eduard_Munteanu> But writing proofs as combinations of tactics is probably worse off.
23:29:05 <kmc> the terms may be large, but the typing rules of dependent lambda calculus are simple, and you can type-check in your head
23:29:11 <kmc> in Coq you're basically applying a super ad-hoc imperative program to this implicit proof state
23:29:26 <kmc> and a lot of the steps are no more than "try your best at this point, and give up on all other branches"
23:29:43 <kmc> the variables of this language aren't even bound before they're used!
23:30:00 <Eduard_Munteanu> Yeah, it's not like you can totally get "crush" when you see it. :)
23:30:16 <wavewave> Can those theorem provers be used in conventional logic, not in constructive logic?
23:30:17 <kmc> you do "intros" and the reader has to know that this introduced hypotheses named H, H1, and H2, except maybe you had H1 in scope already, so it's H, H1, and H3, and this is *all implicit*
23:30:17 <Rotsor> kmc, thank you for confirming my suspicions (after playing with Coq once)
23:30:29 <kmc> it's pretty much a totally different ballgame from Agda
23:30:43 <kmc> Coq is a fun puzzle game though
23:30:56 <kmc> i found working through the exercises in bcpierce's book insanely addictive
23:30:56 <Eduard_Munteanu> Besides Agda's syntax is much nicer.
23:31:16 <Eduard_Munteanu> wavewave: AFAIK yes.
23:31:28 <kmc> wavewave, yes, most of them will let you posit an axiom
23:31:41 <Eduard_Munteanu> Agda's type system + excluded middle seems consistent.
23:31:54 <kmc> wavewave, http://coq.inria.fr/V8.1/faq.html#htoc36
23:31:54 <wavewave> so not (not P ) = P is assumed?
23:32:01 <kmc> it's not assumed, but you can assume it
23:32:06 <Eduard_Munteanu> wavewave: only if you postulate it
23:32:27 <wavewave> wonderful.
23:33:14 <Eduard_Munteanu> postulate     excl-mid : ∀ {P} -> Not (Not P) -> P
23:33:15 <Rotsor> but if you use it in your program, you'll not be able to run it, am I correct?
23:33:31 <Eduard_Munteanu> Then you use it as a "function".
23:33:37 <kmc> Rotsor, you can implement classical logic operators with first-class continuations
23:33:41 <kmc> i don't know if coq or agda does
23:34:16 <wavewave> this Curry-Howard isomorphism thing makes me dizzy~~
23:34:29 <Eduard_Munteanu> Rotsor: you can't run those bits of code that go through postulates, but otherwise I think you can
23:35:38 <ivanm> @ask chrisdone is your C-<right> the same as M-x indent-code-rigidly ?
23:35:39 <lambdabot> Consider it noted.
23:36:56 <NihilistDandy> Related video from the copumpkin video: http://www.youtube.com/watch?v=o6Kn3bQPV20&NR=1
23:36:59 <NihilistDandy> Wat
23:37:14 <Eduard_Munteanu> (erm, that's one bit of double negation, but it's equivalent to excluded middle AFAIK)
23:38:12 <NihilistDandy> Also, just realized that I'm in: http://hpaste.org/50482
23:38:48 <mustelo> kmc, do you have a link to the bcpierce exercises you mentioned?
23:39:02 <Cale> http://www.reddit.com/r/math/comments/jogj0/could_one_of_you_guys_help_me_with_this_one_i/c2du62t -- ahaha
23:39:51 <Cale> Oh, he got the capitalisation wrong after all that!
23:40:45 <NihilistDandy> Cale: lol
23:41:25 <mustelo> haha, this could be useful! reTeXing old scans of papers
23:41:47 <kmc> some old math papers look *really* bad
23:41:52 <kmc> proper typesetting was hella expensive
23:41:56 <kmc> so they largely faked it on typewriters
23:42:08 <mustelo> yeah, a lot of it was on typewriters + handwritten greek
23:42:20 <kmc> you could get a typewriter that would type, like, each of the four quadrants of a big Σ as a separate character
23:42:28 <Eduard_Munteanu> Eww, yeah, I remember that stuff.
23:42:30 <Cale> There are whole books done on typewriters
23:42:46 <NihilistDandy> That's what makes me hate DejaVu. Everything I've ever seen in that format has been ugly in that way
23:43:10 <NihilistDandy> Also, has anyone picked up Craft 3E, by any chance/
23:43:12 <NihilistDandy> &?
23:43:13 <Cale> wat
23:43:14 <NihilistDandy> *?
23:43:38 <Cale> djvu is largely pretty nice, if you're going to have page scans of things.
23:43:53 <Cale> It's much better than PDF for scanned books.
23:43:56 <NihilistDandy> Have not found a single scan that was pleasantly readable
23:44:07 <NihilistDandy> It's turned me off of the format.
23:44:15 <NihilistDandy> I'd love to be proven wrong, of course
23:44:28 <NihilistDandy> Also, the shitty Mac support, but I can get over that
23:45:48 <ddarius> We should go back to the days of monks slaving for decades making beautifully illuminated manuscripts.
23:45:52 * Eduard_Munteanu reads that as "shitty" binding its argument tighter...
23:46:18 <Eduard_Munteanu> :P
23:46:23 <Cale> Well, we might have different standards, but http://cale.yi.org/share/Dummit%20D.,%20Foote%20R.%20Abstract%20algebra.djvu seems pretty okay to me.
23:47:11 <NihilistDandy> ddarius: I think there's a LaTeX package for that
23:47:13 <kmc> Dummit's son went to Caltech and took the course using Dummit and Foote as a frosh
23:47:43 * kmc knows a few people with vaguely famous ancestors
23:48:05 * shachaf knows a few people with vaguely famous ancestors if you go back far enough.
23:48:18 <kmc> yeah, Genghis Khan is pretty famous
23:48:26 <shachaf> For instance.
23:48:36 <kmc> also Adam and Eve, amirite
23:49:06 <shachaf> You know my friend Adam?
23:49:34 * shachaf ought to go to sleep.
23:50:08 <NihilistDandy> insomniaSalt: Do you use the same client as I do? :D
23:50:18 <Eduard_Munteanu> NihilistDandy: anyways, I'm using evince here (on Linux) and that can read it
23:51:01 <NihilistDandy> I have to use DjView, sadly. It's kinda terrible
23:51:31 <Cale> Yeah, I use evince too
23:52:13 <Cale> It's a shame there aren't good ports of evince to other platforms. Nobody would use Adobe's garbage PDF reader anymore.
23:52:40 <ddarius> evince has everything I want and not too much that I don't.
23:52:43 <ivanm> Cale: I found foxit to be not too bad
23:52:47 <Eduard_Munteanu> Hm, that book is nice, thanks.
23:53:08 <ivanm> there is an xpdf-based pdf reader for windows, but it's pretty bad
23:53:15 <ivanm> and it might be possible to get okular on windows...
23:53:19 <NihilistDandy> Cale: The first good djvu I've seen. I stand corrected
23:53:20 <pikhq_> Isn't the only reason for Adobe's reader the idea that it's the only reader, anyways?
23:53:34 <Eduard_Munteanu> AFAICT, what evince doesn't have is PDF annotations, but it's just a reader after all
23:53:36 <NihilistDandy> pikhq_: Everything reads PDF, doesn't it?
23:54:00 <pikhq_> NihilistDandy: In Windows-land, the normal user is lead to believe it's an Adobe proprietary format.
23:54:03 <Cale> NihilistDandy: Especially when you consider the number of pages and the file size.
23:54:10 <pikhq_> That is inexplicably common.
23:54:15 <ddarius> It was an Adobe proprietary format.
23:54:37 <pikhq_> ddarius: Yes, but now it's an Adobe open format for which Adobe has the worst implementation.
23:55:09 <NihilistDandy> Cale: I dunno. My Dummit and Foote PDF is only 8.3 megs
23:55:27 <ddarius> Acrobat isn't the worst, especially on Windows, but there were better ones before Adobe opened the format.
23:55:40 <pikhq_> ... There's *worse*?
23:55:44 <pikhq_> Now I'm frightened.
23:56:32 <NihilistDandy> pikhq_: When Apple's Preview deals with PDF better than Acrobat, the world is a scary place
23:57:04 <pikhq_> NihilistDandy: So does cat(1).
23:57:11 <NihilistDandy> lol
23:57:13 <Eduard_Munteanu> strings :)
23:57:35 <NihilistDandy> I actually only use Acrobat for the easy OCR
23:57:59 <NihilistDandy> I avoid it for everything else
23:58:09 <kmc> how do i write an instance of QuickCheck.Coarbitrary?
23:58:38 <Cale> NihilistDandy: In general the same PDF will often be much larger. I got a copy of Hoffman & Kunze as a 20MB PDF file, and converted it to a 4MB djvu. It looks identical, but the pages load more quickly.
23:58:56 <kmc> do i basically hash the first arg to 'coarbitrary' and then pass that to 'variant'?
23:59:43 <NihilistDandy> Cale: That does sound pleasant. I might have to look into converting if it's that much better.
23:59:52 <ddarius> kmc: Look at examples and do what they do.  It's pretty mechanical and there is probably a deriver for it in the derive package.
