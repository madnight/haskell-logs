00:01:10 <luite> edwardk: do you use both when programming? ipad as extra screen, or documentation?
00:01:13 <edwardk> sure, and eventually i'll switch to the next gen, etc. but i have to admit that i like the form factor. when i'm walking i use the ipad, the moment i sit down i whip out the air. at 11" its small enough that i don't even notice i'm carrying it. the ubiquity more than makes up for any speed difference
00:01:14 <frerich> edwardk: Do you use an extra keyboard with it? I imagine using the tiny (13"?) keyboard for programming might be a bit painful.
00:01:17 <lpsmith> kmc: maybe the issue I brought up isn't really signficant.   I mean,  the IO component of this hypothetical application should spend most of it's time blocked,  which should those threads unavailable for use by computationally-heavy component.
00:01:45 <edwardk> frerich: nah, i don't even notice the keyboard any more. I used to notice it all the time when I tried programming on an old OLPC XO though
00:01:50 <lpsmith> err, *which should keep those threads unavailable*
00:02:00 <kmc> oh god, the XO
00:02:11 <kevea> edwardk: sure maybe no significances in current time but overall you've wasted a lot of time with a bad processor
00:02:42 <kevea> not to be sentimental, but life is limit hence why I'm interested in other people's experience with processors
00:02:51 <edwardk> kevea: i switched to the air ~5 months ago. if you look at my activity on github, its gone up significantly in the meantime
00:02:58 <kevea> anyone experience with non-x86 processors?
00:03:14 <luite> hmm, so if I buy an air, I'll have 100 hackage packages in 5 months?
00:03:48 <edwardk> when i used to work with workstation replacements i wouldn't just grab my laptop and carry it out to the kitchen with me and keep chatting on IRC while making a dinner for instance
00:04:08 <edwardk> even the difference between a 11" and 13" macbook air would be significant enough to keep me from doing that
00:04:20 <kevea> edwardk: are you cooking currently?
00:04:39 <frerich> :-)
00:04:44 <benmachine> if I cooked while on IRC I think that would go wrong
00:04:50 <luite> hmm really? I drag my 15" laptop everywhere
00:05:08 <edwardk> heh, i actually just woke up and reached over and grabbed the laptop ;)
00:05:20 <kevea> ... I'm currently on the Apple site customising an air
00:05:24 <luite> unfortunately it's now dying, so I'm looking for a new one
00:05:30 <kevea> you should be paid commission ;)
00:05:33 <frerich> I'm dragging my 15" macbook everywhere as well, but then - I'm used to carrying a 11kg kid around so maybe I don't notice the pain anymore :-}
00:05:40 <edwardk> kevea: =)
00:06:02 <kevea> edwardk: where did you acquire the money for a macbook?
00:06:20 <edwardk> yeah. i used to lug around a procession of various 17" laptops, moving to the 11" was a significant difference
00:06:28 <doghead> are there any algorithms where the Haskell version is a lot faster than the non lazy version
00:06:32 <edwardk> kevea: I've had a very interesting career ;)
00:06:47 <kevea> doghead: make list to inifinite
00:06:49 <edwardk> doghead: sure, take 10 . sort ;)
00:07:06 <kevea> edwardk: would you be interest in funding me?
00:07:08 <doghead> haha true
00:08:07 <edwardk> kevea: wow, an investment opportunity! ;)
00:08:21 <kevea> edwardk: so yes?
00:08:27 <luite> kevea will program the next facebook on his macbook!
00:08:31 <luite> don't miss out
00:08:32 <edwardk> the check is in the mail
00:09:29 <kevea> luite: I don't use facebook
00:09:33 <luite> kmc: you forgot to mention agile programming methods in the haskell FAQ
00:09:39 <kevea> edwardk: how did you get my address? from my ip?
00:09:52 <edwardk> of course. i used to run an ISP after all
00:10:14 <edwardk> luite: you mean the faq isn't buzzword compliant?
00:10:29 <kevea> edwardk: can you not give me hope? I would very much like to know if you send it or not
00:10:56 <edwardk> alright i'll dash your hopes then
00:11:35 <kevea> edwardk: ho, I am eligible for student discount
00:11:49 <edwardk> since you insist
00:11:54 <edwardk> nice.
00:12:24 <luite> edwardk: it's severely lacking in business value driven development methods
00:15:10 <kevea> edwardk: so in a rating for 0 to 10, how has macbook air improved your accountability for projects?
00:15:38 <edwardk> not sure what that means
00:16:03 <kevea> Um in terms of improvement of productivity
00:16:03 <edwardk> I wrote code before that i was accountable for. I write code now that I'm accountable for.
00:16:16 <edwardk> ah
00:16:50 <edwardk> i'd definitely rate it up there with ditching darcs for github
00:17:07 <kevea> 9/10?
00:17:14 <edwardk> 7-8
00:17:26 <kevea> I'll take the average 7.5
00:17:45 <frerich> kevea: Are you sure it's not more like 7.75 ?
00:17:56 <kevea> Also, in terms of proccesors: what is the improvement of so called "sandy bridge" on compiling?
00:18:02 <kevea> frerich: no, 7.5
00:40:42 <erus`> what is the standard, correct way to track user sessions on a site?
00:53:15 <mysticc>  can any refer to some good article or video reference for understanding arrows ??
00:53:52 <Accidus> Is there a way to define an anonymous type constructor (i.e. *->*)? I want to create a type class instance such as: instance Functor m, Eq a  => C (x |-> m (a,x)) where ...
00:53:53 <qnikst> hello, is there a way to force Data.ByteString.readFile/writeFile operations?
00:54:11 <Accidus> Where x |-> m (a,x) is the functor Foo x = m (a, x).
01:01:55 <mysticc> qnikst: What do you mean by force
01:03:08 <mysticc> You can hide readFile in prelude and overload readFile with the above ByteString.readFile
01:04:04 <qnikst> yes, I've found that I used readFile from ByteString Lazy
01:04:23 <qnikst> it seems I should add ByteString.Lazy <-> String convertation
01:04:27 <qnikst> *Strict
01:04:29 <qnikst> thanks
01:09:12 <kmc> Accidus, no
01:10:33 <erus`> kmc do you sleep?
01:10:35 <mysticc> kmc: Any good reference for reading about arrows ??
01:13:07 <kmc> mysticc, not afaik.  they really aren't used very much
01:13:51 <kmc> erus`, yeah, i most recently slept from 18:00 to 02:00 local time
01:14:56 <erus`> You always seem to be active in here :P where do you reside?
01:15:12 <kmc> EDT
01:24:10 <huangyi> It seems the stepeval in hpaste.org don't have prelude included.
01:41:24 <roastbird> undo do x <- f
01:41:39 <kmc> @undo do { x <- f }
01:41:39 <lambdabot>  Parse error at "}" (column 13)
01:41:48 <kmc> it's not a full "do" expression
01:42:00 <kmc> the last statement can't be a "<-" statement
01:42:19 <kmc> that would desugar to "f >>= \x -> " which is also syntactically incomplete
01:45:12 <ski> @undo do { x <- f; g x }
01:45:13 <lambdabot> f >>= \ x -> g x
01:47:46 <mustelo> which of course eta reduces to f >>= g
01:55:20 <erus`> how does @pl work?
01:56:13 <mustelo> erus`, there's no magic, it's a lambda calculus mangler with a lot of rewrite rules
01:56:34 <mustelo> it's a fun exercise to try to add a new rewrite rule. let me know if you want some suggestions
01:58:41 <erus`> > let pair x y f = f x y; sumpair x y = x + y in pair 1 2 sumpair
01:58:41 <lambdabot>   3
02:00:46 <tomberek> .
02:01:47 <koeien> are parsers generated by happy/alex generally faster than those by attoparsec?
02:01:53 <tomberek> anyone familiar with loeb, the generic knot tying? I've been playing with a monadic for creating a mutable doubly linked structure. I'd like any feedback, comments, discussion.
02:02:15 <tomberek> http://hpaste.org/50548
02:03:29 <Baughn> koeien: It's a different parsing algorithm entirely
02:03:48 <Baughn> koeien: Faster, slower.. it depends on the language, but happy ought to cover more of them than a recursive-descent engine
02:03:52 <koeien> Baughn: so difficult to say in general?
02:03:56 <Baughn> Mm, mm.
02:04:11 <koeien> Baughn: my language is LL1 so that's not a problem
02:04:30 <mustelo> I would say almost certainly faster in that case
02:04:34 <Baughn> koeien: Generally it's easier to understand the performance of a recursive-descent engine. If (atto)parsec is going to be slow, you'll know.
02:04:54 <Baughn> I.e. all backtracking is explicit
02:06:57 <koeien> ok, I'll do some experiments. attoparsec is not slow, but the files can be >100 MB.
02:07:13 <HugoDaniel> hi
02:08:05 <tomberek> hi
02:09:08 <roastbird> @undo do { x <- f; return x }
02:09:08 <lambdabot> f >>= \ x -> return x
02:09:32 <efie> inside a function, is it better to grab the edge cases (unwanted inputs) with an " = error "xy"" message or to change the signature into .... -> Maybe a and then say edge case: Nothing. ? i think the error assage is more meaningfull, when should i use the Maybe a?
02:10:10 <mustelo> efie, it depends on the function. for example, it would be bad if Prelude.lookup threw errors everywhere
02:10:11 <koeien> efie: generally, use error if you have convinced yourself that that case cannot occur.
02:10:32 <koeien> efie: e.g. a mathematical property that you did not express in the type system
02:10:34 <Baughn> efie: error = programming error
02:10:53 <Baughn> efie: You should expect any call to error to crash your program. If you don't want that..
02:11:33 <koeien> but for example for human input using error is a mistake
02:11:49 <koeien> (if you want your software to be robust, that is)
02:12:32 <Baughn> Well, not always.
02:12:47 <Baughn> It's a bad move for software you want to release to anyone else, but for your own use that can be fine
02:13:02 <Baughn> (..plenty of software in google just crashes if you give it bad parameters, heh.)
02:17:04 <efie> hm i am not sure, what to take out of your answers - i will post an example. at first (i have not worked on it yet) i want to make sure that only double values are entered, and then i want to ensure that the list is called with at least 2 elements
02:17:16 <efie> http://hpaste.org/50577
02:17:51 <efie> the first thing i want to do inside the main
02:19:13 <mustelo> efie, personally I would do the Maybe version, and then check the result in main. it'll be interesting to see what others think
02:19:25 <qnikst> why error, not Exception?
02:19:45 <qnikst> (for user input errors)
02:20:08 <mornfall> What was wrong with DatatypeContexts? GHC claims it's "widely considered a misfeature" but I can't google up a single reason for that?
02:21:52 <mornfall> Ok, I have found the haskell prime page for nodatatypecontexts
02:22:30 <efie> qnikst: yes, i want to use an exception to ensure that only double values are entered "getLine"; i did not know how to do this, so i just skipped this for now
02:23:09 <mustelo> I think exceptions are a little over the top for this particular case
02:24:11 <roastbird> i used a monad, until i realised that i required specific types for the input, and now i have to change everything to an arrow :(
02:25:27 <mustelo> roastbird, it sounds like there might be a better way. can you paste some code?
02:26:36 <efie> mustelo: you mean i should (pattern?)check if the result is "nothing" (for this using a new function?) and then print a message like "you just entered 1 value"
02:26:45 <efie> Nothing*
02:26:57 <mustelo> efie, something like that, yeah
02:27:47 <mustelo> the function maybe also encapsulates that pattern match, if you're into that
02:29:21 <efie> hm, im guess i am not :/
02:29:26 <roastbird> mustelo: i hope so, but i doubt so. i was using monads to emulate states (like in the StateT monad) that represents generated code in another language. then i figured that i needed to separate the generated code into two parts: the part that is run before (the stuff that initializes stuff), and the part that runs after.
02:30:05 <mustelo> roastbird, I don't see why arrows help here...
02:30:11 <Baughn> mornfall: Because datatype contexts are not very useful, and also terribly confusing
02:30:30 <efie> mustelo: i hoogled it, thanks
02:30:31 <erus`> :t (..)
02:30:32 <lambdabot> parse error on input `..'
02:30:38 <Baughn> mornfall: You can put contexts on GADT constructors, which doesn't do the same thing at all but is much easier to read..
02:30:44 <Baughn> ...and why did I even mention that?
02:31:03 <efie> anyway, that maybe message to me seems a bit inconvenient as the error messages does the same with less code ... and thats why i was wondering when to use  maybe a, but i am inexperienced :)
02:31:05 <roastbird> so... naively... i could have 2 monads in a pair, like in "newtype PairOfMon r1 r2 = PairOfMon (Mon r1, Mon r2)"
02:31:22 <efie> maybe method*
02:32:10 <mustelo> efie, if it's less code and you want to just fail out anyways, error may be (no pun intended) the right way to go
02:32:32 <efie> :D
02:32:34 <roastbird> and then i would selectively use >> or >>= on PairOfMon. but when that happens, the do notation no longer works, and even binding with lambdas doesn't work - the syntax of getting the nested lambdas doesn't look nice
02:32:40 <efie> ok, thanks mustelo
02:33:01 <mustelo> roastbird, can you step back and give some background? what is it that you're trying to do?
02:33:48 <mustelo> efie, a good example of when to use Maybe is the lookup function. since we're not processing user input, it doesn't make sense to call error if the key isn't in the list.
02:33:50 <mustelo> @type lookup
02:33:52 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
02:39:58 <hpaste_> dfg pasted “temp0” at http://hpaste.org/50578
02:40:44 <roastbird> mustelo: that's what i was considering before i decided that Arrows is a workable alternative
02:40:55 <mustelo> what's CodeMonad?
02:41:30 <tomberek> @seen sigpfe
02:41:30 <preflex>  Sorry, I haven't seen sigpfe
02:41:30 <lambdabot> Unknown command, try @list
02:41:49 <tomberek> @seen sigfpe
02:41:50 <preflex>  Sorry, I haven't seen sigfpe
02:41:50 <lambdabot> Unknown command, try @list
02:42:47 <roastbird> mustelo: in some situations i could first construct the after monad independent of S, but in other situations, i need to bind to the before monad, then after monad, and then before monad again.
02:43:46 <mustelo> roastbird, I'm happy to try to help, but you're not explaining what you're trying to do, you're just saying what didn't work
02:46:36 <roastbird> it's a monad that's similar to a state monad, the state is a syntax tree that's later converted into code
02:47:05 <mustelo> why do you want two monads then?
02:48:46 <roastbird> i guess that if this can work on a state that's a monoid, it would work on the state in CodeMonad. but because it's a pair of monads...
02:49:11 <roastbird> well, some code have to occur before, and some code after. there are two sections.
02:49:31 <roastbird> i.e. certain variables have to be declared/set before other functions can be defined and run.
02:49:51 <mustelo> that sounds like two different parts of one State monad to me
02:50:44 <roastbird> but the before-part has to run before the after-part
02:51:20 <mustelo> right, but you can handle that at the end, when you actually do code generation, or whatever it is you're trying to do
02:52:23 <roastbird> with a pair of monads, i would sequence them at the end like this: "data S r1 r2 = S { before :: CodeMonad r1 , after :: CodeMonad r2 }; linearize x = before x >> after x", by calling linearize
02:53:06 <roastbird> if they are both states, then it would be.... problematic. i would end up with something like "someCode :: (CodeState,CodeState) -> (CodeState,CodeState)"
02:53:44 <mustelo> yeah, I have no idea what you're trying to do, so I'm afraid I can't help further
02:54:50 <roastbird> i mean, this doesn't give a before that's "CodeState -> CodeState" and an after that's "CodeState -> CodeState". if there's a way to do it cleanly, it eludes me.
02:55:37 <roastbird> oh. no problem with that. i thought you just happened to be interested. i'll sit on it for a few more days =)
03:03:13 <byorgey> roastbird: it also sounds to me like the best way would be to use a single State monad with the state being a pair
03:04:13 <byorgey> but you can abstract over it so that you are only allowed to do operations which make sense for your application
03:04:49 <byorgey> while using a state monad you shouldn't need to be thinking about the fact that it is actually a function  s -> (s,a)  anyway.
03:05:01 <roastbird> byorgey: i really wanted to do that. but when i finally exec the state to get "(SomeState, SomeState) -> (SomeState, SomeState)", i have no idea how to change it to a pair of "(SomeState -> SomeState , SomeState -> SomeState)"
03:06:00 <roastbird> actually, i went ahead with this without resolving the issue. now that most of the other stuff is done, well... i can't solve this, so i'm kinda regretting.
03:06:14 <byorgey> aha, now I understand.  let me think about that for a minute.
03:06:48 <mustelo> roastbird, once you have that pair, is the goal to compose them?
03:07:31 <byorgey> roastbird: also, does it really need to be a state monad? or do you really want Writer?
03:07:34 <roastbird> (:   is this a common issue?
03:07:50 <roastbird> yes, just to compose them
03:07:56 <byorgey> State would mean that you can look at what code has been currently generated in order to decide what code to generate next
03:07:59 <byorgey> which sounds... strange
03:08:08 <mustelo> indeed
03:08:18 <roastbird> it doesn't need to be a state monad, nor a writer. a state monad is sufficient, but a writer isn't.
03:08:32 <byorgey> why is Writer insufficient?
03:08:51 <roastbird> yup. the previous code is useful because of the unique variable names involved.
03:09:21 <roastbird> and because the previously imported libraries/variables are stored in a Map. if it has already been initialized/imported, it won't be imported again.
03:09:36 <Jester_Racer> hello! I'm getting an error on line 16, help me please: http://hpaste.org/50579
03:09:39 <byorgey> hmm, ok
03:09:42 <Jester_Racer> how can I avoid that?
03:10:03 <Jester_Racer> maybe data Expr = Operator is wrong?
03:10:09 <Botje> and what error would it be?
03:10:10 <byorgey> Jester_Racer: what is the error?
03:10:34 <byorgey> Jester_Racer: Oh, I see the problem
03:10:40 <hpaste_> Jester_Racer pasted “prettyExpr error” at http://hpaste.org/50581
03:10:43 <byorgey> Jester_Racer: yes, data Expr = Operator is wrong
03:10:56 <roastbird> oh
03:10:58 <byorgey> Jester_Racer: Operator is a type, and you are using it as a data constructor
03:11:09 <mustelo> you might want data Expr = Operator Operator
03:11:12 <byorgey> Jester_Racer: perhaps you want something like  data Expr = OpExpr Operator
03:11:29 <byorgey> OpExpr is the data constructor, which contains a single value of type Operator
03:12:27 <mustelo> roastbird, can you say any more about what situations you need to go back and forth between "before" and "after"? is it really both directions?
03:12:29 <Jester_Racer> byorgey: es I thought that will be a problem. So I can't do it this way :) How should I construct OpExpr?
03:12:33 <Jester_Racer> *Yes
03:12:53 <roastbird> something that just works with your code would be: "data Expr = Op String Associativity Precedence | Number Int deriving (Show, Eq)"
03:12:57 <Jester_Racer> oh ok I see
03:13:02 <Jester_Racer> I think I got it
03:13:53 <Jester_Racer> roastbird: I know, but I want the Operator to be in a separate data type, and include it in Expr
03:14:13 <byorgey> :t \f -> \initialState -> let (x,y) = f (initialState, x) in y
03:14:14 <lambdabot> forall t t1 t2. ((t2, t) -> (t, t1)) -> t2 -> t1
03:14:21 <byorgey> roastbird: ^^^  =)
03:14:59 <byorgey> you cannot change  (S,S) -> (S,S)  to  (S -> S, S -> S)  in general, but if you just want to compose them anyway... =)
03:15:14 <Jester_Racer> byorgey: Thanks for your suggestion, it's working now :)
03:15:29 <roastbird> hrmmm. let me read that...
03:16:16 <mustelo> byorgey, that's clever. I'm not convinced it works, heh :)
03:16:24 <byorgey> neither am I ;)
03:16:44 <byorgey> I think it will work as long as the two states do not depend on each other.
03:16:59 <mustelo> right, which goes back to my previous question about the interaction
03:17:24 <byorgey> that is, as long as you do not write computations where one state is used to compute something that ends up affecting the other.
03:17:45 <byorgey> it may be a bit finicky though.
03:18:09 <mustelo> I still feel like there's a more straightforward way for what roastbird is trying to do
03:19:22 <byorgey> one idea would be to separate out the stateful parts (maps of loaded identifiers etc.) from the code generation parts, and see if that helps
03:19:25 <roastbird> hrm... yes, i think it'll work if there's no interaction =)
03:19:32 <roastbird> but there are interactions.
03:20:02 <mustelo> right, instead of keeping all of the generated code around in a State, just keep the maps you need
03:20:22 <roastbird> i.e. when a function from a library is called, it will add stuff to the before part, and then add stuff to the after part.
03:20:47 <byorgey> right, so have something like StateT maps (Writer (code1, code2) ...
03:20:52 <hpaste_> jeetu pasted “xsession” at http://hpaste.org/50582
03:21:01 <roastbird> but when a function from a library is called if a previously defined condition is satisfied, then the before part may be added or not, depending on the condition
03:21:23 <byorgey> then you run it with initial empty maps, and get out some before code and some after code
03:21:27 <byorgey> voila!
03:21:31 <mustelo> so then you need to make sure that enough information is in the maps to make that decision
03:23:04 <mustelo> StateT maps (Writer (BeforeCode, AfterCode)) looks good to me. are you familiar with monad transformers roastbird?
03:24:03 <roastbird> ack. i don't know. it's too complicated for me.
03:24:20 <roastbird> i've read through the sources, but...
03:25:28 <roastbird> how would i modify the AfterCode like a monad?
03:26:38 <mustelo> I'm not sure what you mean by "like a monad", but you could define some like tellBefore and tellAfter which generate code to a particular phase
03:26:44 <roastbird> suppose i define a function using  a monad,  like "defineSomeFunction :: m FunctionType". usually i would "f <- defineSomeFunction; f ..." i'm not sure i could do that with a writer.
03:28:54 <roastbird> like it would be quite common to do these things "f <- defFn; f 20; f 30; g <- defVar; f g; return f;". that would be natural in a monad. but i'm not even sure if it's possible in writer without putting in something that's a monad.
03:30:05 <byorgey> Writer is a monad.
03:30:10 <roastbird> hm... possible is too strong a word.
03:31:18 <roastbird> i meant Writer (some monad) (another monad)
03:33:26 <efie> there is fst and snd for zip ... is there a third function for zip3?
03:34:09 <ski> @type \(a,_,_) -> a
03:34:10 <lambdabot> forall t t1 t2. (t, t1, t2) -> t
03:39:24 <roastbird> hm... the way i see it, writer is a state monad, with a monoid state, and some convenience functions.
03:39:56 <roastbird> meaning that in the end, i still have to deal with sequencing the before-part and after-part. which are still inter-related.
03:41:43 <roastbird> if i represent the states as ((CodeState -> CodeState), (CodeState -> CodeState)), so they would stay independent, then it wouldn't work in a monad...
03:41:52 <roastbird> well, problem for another day!
03:47:21 <ski> `Writer w' is not a state monad, it is a writer/output monad
03:47:59 <ski> you could implement it with a state monad, though (losing some laziness)
03:49:22 * hackagebot email 0.1.1 - Sending eMail in Haskell made easy  http://hackage.haskell.org/package/email-0.1.1 (JohannesWeiss)
04:08:46 <dibblego> what is the name/author of the paper that talks about different ways to load code?
04:09:54 <erus`> free amazon ec2 instance :D
04:40:06 <kmc> dibblego, could you be more specific?
04:40:22 <dibblego> something to do with "plugins" and the reader monad was featured as one possibility
04:40:37 <dibblego> and static typing iirc
04:40:48 <kmc> the plugins work is by dons
04:40:49 <dibblego> can't remember any other details :(
04:40:53 <kmc> but maybe you already know that
04:40:57 <dibblego> yeah I found a paper by him
04:41:11 <dibblego> I think it was more general than haskell-specific
04:42:01 <kmc> machine code is homoiconic
04:42:36 <kmc> (non sequitur)
04:42:51 <dibblego> not sure what you're getting at
04:43:29 <dibblego> the paper went through a list of methods of implementing "plugins" in a statically-typed language (was it specific to haskell? I forget)
04:43:47 <kmc> it's not related to your question, just a thought that occurred to me just now
04:44:32 <dibblego> oh ok
04:46:58 <dibblego> I might just ping dons
04:49:53 <dibblego> bah his email address fails
04:50:07 <kmc> try stack overflow :D
04:50:08 <Cale> Homoiconicity always seemed a bit vaguely defined to me. Is Haskell with TH homoiconic?
04:54:37 <ehamberg> dibblego: http://comments.gmane.org/gmane.comp.lang.haskell.cafe/91045 (last email)
04:55:10 <ehamberg> oh. d'oh. the address is of course filtered. :)
04:55:12 <dibblego> I found his email address just by googling
04:55:23 <kmc> Cale, yeah
04:57:03 <kmc> the interesting thing about Lisps isn't so much that Lisp programs can represent Lisp programs as data
04:57:38 <kmc> but that Lisp is *defined* as a language for describing Lisp data structures, and then a semantics for interpreting Lisp data structures as programs
04:57:51 <kmc> (i don't actually know if this is true of CL, but it's true of R5RS Scheme anyway)
04:58:36 <tomberek> hey, i would like to apply   f :: (a -> ST s a)  a large number of times.  unrolled:  f a >>= f >>= f .. etc.  I am currently building up and allocating too much. is this the right spot for CPS, or is there a library function for this?
04:58:59 <kmc> is that actually where your allocation is coming from?
04:59:24 <kmc> :t foldr (>=>) return . replicate ?n
04:59:25 <tomberek> kmc: not 100% sure, but when I unroll it 10 times, my garbage collection drops by a factor of 10
04:59:25 <lambdabot> forall (m :: * -> *) c. (Monad m, ?n::Int) => (c -> m c) -> c -> m c
04:59:37 <kmc> heh
04:59:51 <kmc> foldr and replicate should fuse
04:59:55 <kmc> how did you code the loop?
05:01:44 <tomberek> kmc: right now it's a variation of    iter n f a = f a >>= iter (n-1) f
05:02:14 <tomberek> kmc: in context:
05:02:18 <hpaste_> tomberek pasted “loebM” at http://hpaste.org/50584
05:02:33 <tomberek> i started unrolling it to see what it did
05:02:50 <tomberek> i just could get variations of replicate to do it right
05:02:56 <tomberek> *couldn't
05:03:19 <kmc> so you tried that "foldr (>=>) return" solution?
05:03:27 <tomberek> kmc: one moment
05:03:49 <hpc> :t (>=>)
05:03:50 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:04:03 <kmc> :t iterate (f >=>) return !! ?n
05:04:04 <lambdabot> forall (m :: * -> *) c. (Show c, SimpleReflect.FromExpr (m c), Monad m, ?n::Int) => c -> m c
05:04:10 <kmc> :t iterate (?f >=>) return !! ?n
05:04:11 <lambdabot> forall (m :: * -> *) c. (?f::c -> m c, Monad m, ?n::Int) => c -> m c
05:04:24 <kmc> this one might be better
05:04:55 <benmachine> might it have something to do with associativity?
05:05:03 <kmc> yeah, try both ways :D
05:05:03 * benmachine forgets which way is better for monads to associate
05:05:14 <kmc> @src (>=>)
05:05:15 <lambdabot> Source not found. I am sorry.
05:05:22 <kmc> @. elite src (>=>)
05:05:23 <lambdabot> Say again?
05:05:25 <tomberek> benmachine, i'm simply trying to traverse a structure with STRefs
05:05:28 <Eduard_Munteanu> :t iterate (?f >=>) (return $!) !! ?n
05:05:29 <lambdabot> forall a (m :: * -> *). (?f::a -> m a, Monad m, ?n::Int) => a -> m a
05:06:41 <tomberek> :r
05:06:44 <tomberek> oops
05:06:49 * benmachine reloads
05:07:52 <donri> huh, more haskellites use vi(m) than use emacs? (state of haskell)
05:07:55 <Eduard_Munteanu> @hoogle iterateM
05:07:55 <lambdabot> No results found
05:08:17 <tomberek> kmc:Eduard_Munteanu: or is there a better/faster way?
05:08:19 <Eduard_Munteanu> I do.
05:09:40 <tomberek> Eduard_Munteanu, the $! is actually MUCH slower
05:10:27 <tomberek> the $ variant runs out of memory
05:11:09 <favonia> donri: vim+1
05:11:42 <tomberek> kmc: foldr (>=>) return . replicate n    is able to complete, but still takes a longer time
05:11:43 <donri> i thought #haskell was 99% emacs fanatics
05:12:06 <tomberek> donri: i've actually enjoyed vim recently
05:12:11 <Eduard_Munteanu> I'm not sure you want a foldr.
05:12:19 <tomberek> yeah.
05:12:44 <tomberek> my version of iter is a rewrite of foldM
05:12:49 <donri> whereas I, a vim user, have noticed emacs superior strength recently :D
05:13:03 <tomberek> with some manual unrolling
05:13:33 <Cale> I use mainly vim
05:13:36 <tomberek> but it just looks ugly, can this be improved with CPS?
05:13:46 * Eduard_Munteanu uses emacs only for Agda :/
05:13:54 <donri> i wish there was a less bloated emacs with vim-like bindings and a sane scripting language
05:13:57 <favonia> donri: personally I use vim for programming, and Haskell is no exception
05:14:10 <Eduard_Munteanu> donri: there's the emacs Viper mode
05:14:11 <Cale> donri: Work on yi, perhaps.
05:14:45 <Cale> I really wish there was even just one editor which understood Haskell's layout rules correctly.
05:14:53 <mm_freak> i tried vim once, but i didn't like its auto-indenting
05:14:56 <favonia> Eduard_Munteanu: me too (for agda Auto)
05:15:05 <mm_freak> haskell-mode's autoindenting is very smart
05:15:26 <donri> irc client froze
05:15:50 <Cale> Any editing command which causes the first non-whitespace character after a layout keyword to move should cause the entire block to move accordingly.
05:15:58 <Cale> No editor does that.
05:16:01 <mm_freak> donri: emacs by itself is not bloated at all, but many distributions auto-install a lot of libraries
05:16:11 <Cale> (yi does something kinda like that, but it's not correct)
05:16:21 <donri> i consider an editor that ships with a tetris implementation bloated
05:16:38 <hpaste_> tomberek pasted “iterM” at http://hpaste.org/50585
05:16:41 <tomberek> this is the key part that I'd like to improve on
05:16:57 <opqdonut> donri: have you looked at how large a packaged vim is?
05:17:07 <opqdonut> just sayin'
05:17:12 <donri> it's not about size in megabytes
05:17:18 <Cale> tomberek: You could use "square and multiply"
05:17:25 <donri> more like, "relevance"
05:17:30 <tomberek> Cale: beg pardon
05:17:35 <mm_freak> donri: your favorite linux distribution likely ships with 'ddate', the discordian date program
05:17:41 <mm_freak> so linux is bloated?
05:17:42 <Cale> @src (^)
05:17:43 <lambdabot> x ^ 0            =  1
05:17:43 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
05:17:43 <lambdabot>   where f _ 0 y = y
05:17:43 <lambdabot>         f x n y = g x n
05:17:43 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
05:17:45 <lambdabot>                       | otherwise = f x (n-1) (x*y)
05:17:47 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
05:18:07 <donri> mm_freak: i have different needs between my OS and my editor
05:18:08 <Cale> ^^ do that, only with iterM in place of ^, return in place of 1, and >=> in place of *
05:18:18 <mm_freak> donri: what's the difference?
05:18:35 <mm_freak> donri: i would accept "i don't like emacs", but "emacs is bloated" is plain wrong
05:18:37 <kmc> <3 ddate
05:18:41 <tomberek> Cale: let me try it out
05:18:43 <kmc> Today is Setting Orange, the 16th day of Bureaucracy in the YOLD 3177
05:19:15 <donri> mm_freak: i do like emacs and my finding it bloated isn't a big factor in my not (yet/currently) using it
05:19:50 <opqdonut> even though elisp is a slightly horrible language, it's better than the mismash that's used to extend vim, IMO
05:19:58 <opqdonut> but this is off-topic
05:20:14 <mm_freak> donri: perhaps me as a KDE user has a very different definition of "bloated" =)
05:20:30 <kmc> does yi build cleanly these days?
05:20:33 <Cale> tomberek: Also, configure your editor so that it doesn't put tabs in your source code, those things are treacherous.
05:20:36 <donri> hah let's not even go there
05:20:56 <mm_freak> KDE, firefox, libreoffice (when i must), emacs, compiz, …
05:21:00 <tomberek> Cale: yeah, sorry about the tabs
05:21:21 <mm_freak> on the other hand i use task warrior as my organizer =)
05:21:32 * donri unity (but would prefer gnome3/shell), firefox, gvim, compiz
05:21:38 <donri> but yea off-topic
05:22:26 <tomberek> Cale: I think I tried some >=> based solutions already, but give me a few more minutes to convert thiss
05:24:25 <hpaste_> Cale pasted “iterM ” at http://hpaste.org/50586
05:24:34 <Cale> oops, forgot the last line ;)
05:24:52 <hpaste_> Cale annotated “iterM ” with “iterM  (annotation)” at http://hpaste.org/50586#a50587
05:25:31 <Cale> This should almost be a higher order function.
05:26:16 <tomberek> Cale:  yeah, i've had to re-implement it many times,,, it's slower
05:26:48 <Cale> I mean, the square and multiply tactic
05:27:13 <tomberek> Cale : i'm running it with 100,000,000.   allocates 2 Gb to the heap, 4609 collections, almost 8 seconds
05:27:24 <Cale> heh
05:27:50 <tomberek> Cale: no, oops, 200,000,000
05:28:34 <tomberek> Cale: I just can't seem to beat the manual unrolling branch, can't trick the compiler to do it for me
05:29:14 <Cale> What are you iterating? Are you sure it's iterM's fault?
05:29:22 * hackagebot nixos-types 1.0 - Data types representing the Nix language  http://hackage.haskell.org/package/nixos-types-1.0 (PeterSimons)
05:29:40 <ski> kmc : "<3 ddate" -- re the relational model ?
05:29:51 <erus`> any iPwn member in here?
05:30:00 <Cale> I don't see that much allocation here, iterating a pretty trivial function
05:30:07 <Cale> erus`: hi
05:30:10 <erus`> whats ghc compiled binary performance like on haskell?
05:30:20 <erus`> where haskell = iphone :S
05:30:24 <kmc> is there any way to hide an exposed module from the modules list on Hackage?
05:30:36 <kmc> {-# OPTIONS_HADDOCK hide #-} doesn't cut it
05:30:57 <Cale> erus`: Reasonable?
05:31:14 <tomberek> Cale: this is in the ST monad, I'm traversing a STRef linked structure.  Unrolling the iteration into f a >>=f  >>= f >>=  x 10  gives me 1/10 the GCs,
05:31:18 <ski> (i.e. <http://en.wikipedia.org/wiki/The_Third_Manifesto>)
05:31:19 <kmc> Cale, any news on Android (using my code or otherwise)?
05:31:22 <Cale> oh, I suppose it does do a lot of "allocation"
05:31:33 <Cale> I just don't notice it because it's all immediate garbage
05:31:56 <Cale> kmc: We actually aren't even testing the game on iPhone right now.
05:31:59 <tomberek> Cale: but the structure is circular, not infinite, so it's the traversal that is allocating somewhere
05:32:13 <Cale> kmc: We just have a linux version which is more convenient to develop with for the time being.
05:32:21 <erus`> what do we want?! haskell on arm! when do we want it?! yesterday!
05:32:41 <Cale> (When do we want it? A few months from now?)
05:32:50 <kmc> erus`, GHC on ARM has worked forever
05:32:58 <kmc> you can apt-get install GHC 6.12 on Debian Linux on ARM
05:33:18 <kmc> the difficulty is that neither iPhone nor Android provides a very UNIX-like OS
05:33:20 <erus`> Cale are you wrapping opengl?
05:33:39 <erus`> because of opengl ES
05:34:09 <erus`> android should be fairly unix like
05:34:15 <kmc> Cale, ah, well there was talk of making the Android GHC hacks open-source... if you guys aren't doing much with them, maybe we can at least release the tarball on an as-is basis
05:34:19 <erus`> apart from the gui and app handling stuff
05:34:21 <kmc> erus`, it's not
05:34:29 <kmc> a lot of UNIX is unimplemented
05:35:05 <kmc> the kernel is Linux; the userland is BSD-derived and not full POSIX
05:35:12 <confound> Cale: what game is this? I missed it
05:35:13 <kmc> Android is amusing in that it's Linux but not GNU/Linux
05:35:19 <Cale> confound: BloodKnight
05:36:52 <Cale> erus`: Um, sort of, yes. In that there's a piece of code written in C++ on the device which will essentially abstract over low-level drawing.
05:37:08 <erus`> that is a good idea
05:37:09 <Cale> erus`: But the linux version implements that stuff in Haskell.
05:37:19 <erus`> i was gonna do something like that for opengl even on PC
05:37:36 <Cale> (because GC is not a problem on desktop machines)
05:37:43 <kmc> yeah, even for a "realtime app" 90% of the code will be non-realtime-critical
05:37:53 <kmc> file loading, error handling, whatever
05:37:56 * kmc saw this in finance too
05:38:16 <kmc> so even in very latency-demanding domains, a mixed approach between C or C++ and a high-level language is useful
05:39:09 <tomberek> Cale: would you mind taking a look at iterM in context?  (tabs -> spaces; fixed)
05:39:09 <kmc> in automated trading you sometimes decompose the problem into "signal" and "execution engine"
05:39:15 <hpaste_> tomberek pasted “loebM with iterM” at http://hpaste.org/50589
05:39:21 * hackagebot cabal2nix 1.12 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.12 (PeterSimons)
05:39:24 <Cale> kmc: You should be talking with Ryan more than you should ask me about this. I haven't really given much more than a cursory level of thought to the fact that the code is running on anything other than an abstract machine ;)
05:39:24 <kmc> which is roughly "which stocks are going up soon" and "how do i buy those quickly without getting ripped off"
05:39:33 <kmc> *nod* well, i emailed him a little while back
05:41:01 <Cale> kmc: but Duncan Coutts is also interested in collaborating on iPhone support, and Stephen Blackheath has been working on a toolchain (cross-compiling) mode for GHC which is apparently going in.
05:43:18 <Cale> Scumbag GHC: Builds your code with profiling turned on; doesn't enable RTS options, so you can't make use of the profiler.
05:44:02 <Cale> oh, apparently *all* of the allocation my iterM testing program was doing was allocating integers (I had a counter)
05:44:09 <Cale> I was just testing it with:
05:44:19 <tomberek> Cale: ah, one moment
05:44:21 * hackagebot atto-lisp 0.2 - Efficient parsing and serialisation of S-Expressions.  http://hackage.haskell.org/package/atto-lisp-0.2 (ThomasSchilling)
05:44:28 <Cale> iterM 200000000 (\x -> evaluate x >> return (x+1)) 0
05:44:45 <tomberek> a `seq` can fix that
05:44:51 <Cale> and that allocated 400GB of integer values
05:44:59 <Cale> It essentially is doing seq
05:45:06 <Cale> (that's what evaluate does)
05:45:26 <Cale> It's not showing up in real memory usage
05:45:31 <Cale> It's just doing that much allocation
05:45:36 <Cale> which you seem to be concerned with
05:45:45 <tomberek> ah, yes,,, it's all GC'd
05:45:49 <Cale> of course
05:45:56 <tomberek> but still slowing me down
05:46:06 <tomberek> *i think*
05:46:27 <tomberek> (a good caveat to add pretty much whenever i'm in this channel)
05:46:30 <kmc> preflex, seen rl
05:46:30 <preflex>  rl was last seen on #go-nuts 49 days, 15 hours, 12 minutes and 28 seconds ago, saying: Rune makes sense in a way though; the term "character" is overloaded
05:46:32 <Cale> tomberek: Oh, haha, I see you got my broken last line of iterM :)
05:46:43 <kmc> i had a question about vector's allocator
05:46:46 <Cale> tomberek: I forgot to fix the _ ^ _ case
05:46:59 <Cale> (I fixed it, but not quickly enough ;)
05:48:33 <Cale> tomberek: anyway, I'd expect my version to "complete" the fastest, since it's essentially log time in the number of iterations, but of course, it produces a tree-like composition which has to be flattened out as the program runs.
05:49:41 <tomberek> @src evaluate
05:49:41 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
05:50:11 <Cale> evaluate is like seq, but in IO
05:50:30 <Cale> (and sequences with other IO actions, rather than at an arbitrary point in the program's evaluation before the value is used)
05:51:14 <Cale> It's defined in Control.Exception
05:51:51 <Cale> Since it's usually in order to catch exceptions thrown from pure code that you care about ensuring anything about how IO execution and evaluation interleave with each other.
05:52:30 <tomberek> Cale: ok, perhaps I'm doing this wrong, but adding in seq doesn't seem to change anything, i think the compiler can turn the counter into a Int# on its own
05:53:00 <kmc> (evaluate x) gives you an IO action whose execution causes x to be evaluated
05:53:17 <kmc> this is different from (return $! x), which gives you an IO action whose evaluation causes x to be evaluated
05:53:25 <Cale> Well, I can write a program which does a trivial iterM (with my version) which only allocates 4192 bytes.
05:53:37 <Cale> (and "counts" to 200 million)
05:53:55 <tomberek> Cale: can you repaste?
05:53:55 <Cale> It just doesn't record anything about what it's counting :)
05:54:00 <kmc> (this is not in response to anything particular, just information that usually comes up in conjunction with "evaluate")
05:55:01 <tomberek> kmc: I'll have to take a look. Does this apply when using ST monad? or is this a suggestion to switch to IO, i'd prefer to be able to run algorithm in ST, then revert to purity
05:55:08 <hpaste_> Cale pasted “iterM ” at http://hpaste.org/50590
05:56:26 <tomberek> Cale: ah, so I guess I'm allocating somewhere else, but what I don't understand is how my manual unrolling affects that, I can still get the same number of 'steps' but 1/10 or 1/100th the allocation with manual unroll
05:57:04 <Cale> hmm, interesting
05:57:23 <Cale> perhaps it's inlining the function you apply your iteration function to, and then simplifying the iter100
05:58:02 <kmc> i see nothing wrong with evaluateST, but I don't think it's defined anywhere
05:58:13 <kmc> (return $! x) might be good enough
05:59:03 <Cale> actually, that's probably what's happening
05:59:24 <Cale> It can inline and then simplify better with the explicit unrolling.
06:00:34 <tomberek> Cale: it just confuses me that I can't code something to do f >>= f >>= for me. This should be just a simple jmp instruction, no?
06:01:27 <erus`> how does haskell no if a func is infix? if it starts with a symbol ?
06:01:47 <kmc> an identifier is either all symbols or all alphanumeric
06:01:53 <Cale> tomberek: No, the thing is that the compiler is rewriting the code for you before it ever runs, and that's what's decreasing the allocation -- it can take iter100 applied to a specific f, and flatten out the definition so that not as much allocation is required
06:01:55 <kmc> (alphanumeric including _ ')
06:02:05 <kmc> erus`, but you can also use an alphabetic name infix
06:02:10 <kmc> > 7 `divMod` 3
06:02:11 <lambdabot>   (2,1)
06:03:26 <tomberek> Cale: sure, so what if I hard code the f into iterM, would that do it?   The way I look at it, there should be no allocation going on.
06:03:51 <tomberek> once the circular list is made, traversing it a bunch shouldn't allocate
06:03:53 <Cale> tomberek: Well, no, because it still won't have much opportunity to combine the compositions of f
06:04:27 <Cale> I think what's happening is that after pasting those 100 copies of your specific f into the body of iter100, it's simplifying the result effectively.
06:04:54 <saml> teach me
06:05:32 <Cale> saml: ask me a question
06:05:45 <Botje> pi seconds is a nanocentury
06:05:49 <erus`> does the prelude come with libs to parse haskell code?
06:06:06 <Cale> erus`: Not the Prelude. There are libs to parse Haskell code.
06:06:08 <rostayob> erus`: not the prelude, check haskell-src
06:06:14 <rostayob> it's on hackage
06:06:20 <Cale> The Prelude is just a little module of commonly used stuff.
06:06:27 <kmc> haskell-src-exts is the most popular one, i think
06:06:28 <rostayob> erus`: theeeere you go http://hackage.haskell.org/package/haskell-src
06:06:53 <rostayob> right the -exts includes all the advanced stuff
06:06:56 <Cale> You might also consider just using the GHC API :P
06:07:18 <tomberek> Cale: so you think what i got is the best I can get?
06:07:38 <Cale> tomberek: You could form a hybrid of my solution with that iter100
06:07:40 <erus`> rostayob: is this used by ghc?
06:07:47 <Cale> tomberek: I'm just thinking about the best way to do that
06:07:53 <Cale> erus`: no, ghc has its own parser
06:08:03 <rostayob> erus`: no, ghc uses its own lexer and parser
06:08:06 <rostayob> Cale: damnit
06:08:26 <erus`> why is there two?
06:08:27 <hpaste_> “Mukesh Tiwari” pasted “State monad learning” at http://hpaste.org/50591
06:08:27 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/Parser.html
06:08:44 <tomberek> Cale: i thought of 'double'-ing my way there, like your iterM, but I think it has to do with my traversal function
06:08:45 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/HsSyn.html
06:08:49 <saml> @google haskell fuse
06:08:51 <lambdabot> http://hackage.haskell.org/packages/archive/HFuse/0.2.1/doc/html/System-Fuse.html
06:08:51 <lambdabot> Title: System.Fuse
06:09:10 <hpaste_> “Mukesh Tiwari” annotated “State monad learning” with “State monad learning (annotation)” at http://hpaste.org/50591#a50592
06:09:20 <kmc> rostayob, "advanced" meaning "nonstandard stuff that's not part of Haskell"?
06:09:37 <keep_learning> hello all
06:09:44 <tomberek> hi
06:09:47 <rostayob> kmc: is it a rethorical question?
06:09:52 <keep_learning> i am trying to learn State monads
06:09:54 <Cale> tomberek: Yeah, you'd just have to stop a bit short, and do your non-branching iterM in any case where there are between 100 and 199 iterations left
06:09:56 <erus`> i allready have haskell-src :O
06:09:58 <rostayob> it is part of haskell
06:10:09 <kmc> dunno, maybe haskell-src-exts is more advanced in another way i'm not aware of
06:10:22 <rostayob> kmc: it's mostly the typing system extensions
06:10:32 <rostayob> and TH and stuff like that afaik but I think it's all in haskell 2010
06:10:38 <keep_learning> and tried to wrote this game http://www.haskell.org/haskellwiki/State_Monad using  >>=
06:10:39 <kmc> no it's not
06:10:42 <rostayob> but I don't know exactly
06:10:50 <kmc> http://haskell.org/haskellwiki/FAQ#My_textbook_uses_Haskell_98._Is_it_very_different_from_Haskell_2010.3F
06:10:50 <keep_learning> but i am getting compilation error
06:10:57 <kmc> Haskell 2010 is a tiny change to Haskell 98
06:11:26 <keep_learning> could some one please tell me why this code is giving compiler error http://hpaste.org/50591
06:11:45 <erus`> i just asked if this was in the prelude and you guys said no :|
06:11:47 <rostayob> kmc: yeah but I think that most of it is in the report
06:11:53 <Cale> keep_learning: remove one space before the _
06:11:57 <kmc> erus`, prelude != all the libraries that come with Haskell Platform
06:12:02 <kmc> Prelude is all the stuff you get without "import"
06:12:09 <Cale> keep_learning: It's indented one space too far and therefore part of the previous line.
06:12:17 <rostayob> kmc: ah, TH is not in the report
06:12:22 <erus`> damn i meant platform
06:12:36 <keep_learning> Cale: thank you
06:12:37 <kmc> rostayob, none of the bullet points on the haskell-src-exts doc page are in the Report
06:12:39 <Cale> keep_learning: The _ should line up with the first ' in 'c'
06:12:44 <kmc> and i wager they'll never all be
06:12:53 <kmc> at least, i'd be sad if MPTC + fundeps *and* asstypes both made it in
06:12:58 <rostayob> kmc: what? fundeps and type families are not in the report?
06:13:06 <rostayob> oh right
06:13:12 <kmc> look it up if you don't believe me
06:13:16 <rostayob> right I always mess up the report and the ghc manual. they're so similar
06:13:18 <rostayob> yes you are right
06:13:29 <kmc> TH is in the GHC manual
06:13:37 <Cale> Almost nobody actually programs in Haskell 98
06:13:41 <rostayob> yes sorry about the confusion
06:13:58 <kmc> no worries
06:13:59 <Cale> Haskell 98 actually didn't even allow .'s in module names (though there is an addendum for that at least :)
06:14:47 <dylukes> I heard fundeps might be on the way out?
06:14:50 <dylukes> what's the story with that?
06:14:57 <kmc> hurrah
06:14:58 <rostayob> bah haskell is a lot less exciting without the advanced typing stuff
06:15:00 <Cale> dylukes: Um, well, sort of.
06:15:02 <edwardk> dylukes: they aren't
06:15:13 <kmc> rostayob, i disagree
06:15:23 <erus`> yey i can write my haskell to .bat converter
06:15:35 <koala_man> haha
06:15:41 <edwardk> dylukes: behind the scenes more stuff may switch to implemented in terms of type and data families, but the fundep syntax isn't going away any time soon
06:15:46 <Cale> dylukes: Type families and associated types kind of "replace" multiparameter typeclasses and fundeps, but not quite.
06:15:48 <rostayob> kmc: well most cool code I've read in haskell relies on one or two extensions
06:15:51 <clsmith> hmm, is haskell 2010 a "beta" standard, then?
06:16:03 <kmc> clsmith, no
06:16:06 <edwardk> data and type families overlap with the use cases for fundeps, but neither fully subsumes the other
06:16:08 <rostayob> kmc: I'm not saying that plain haskell is not cool
06:16:13 <kmc> clsmith, but there will be more
06:16:14 <Cale> clsmith: Haskell 2010 is practically the same thing as Haskell 98
06:16:19 <kmc> the plan was one per year, but they skipped 2011
06:16:34 <Cale> (with some very trivial changes)
06:16:41 <edwardk> clsmith: no its the 'here is the stuff we can all agree on today' level standard
06:16:43 <Cale> actually, I dislike most of the small changes they made
06:16:46 <edwardk> as such it makes few changes
06:16:58 <dylukes> The Haskell community doesn't agree on much.
06:17:02 <dylukes> :P
06:17:12 <edwardk> they tried a bigger switch, haskell' was originally going to include a lot of stuff
06:17:14 <kmc> i think the Haskell community agrees that it's important to be careful when designing a programming language
06:17:15 <edwardk> but it bogged down
06:17:23 <Cale> Like the stupid "let me indent if/then/else incorrectly pl0x"... "Okay." patch.
06:17:26 <edwardk> so they scaled back their ambitions and pushed that out in a few short months
06:17:39 <edwardk> after a year and a half or so of slogging towards a more ambitious Haskell'
06:17:42 <kmc> yeah, now haskell' refers to the process and not a particular language
06:17:44 <rostayob> kmc: yeah but we ended up with this situation, which is that everyone codes in ghc haskell
06:17:59 <kmc> rostayob, yeah
06:18:14 <kmc> it would be nice to have at least provisional clarity on what's likely to make it in to future language versions
06:18:17 <rostayob> which is quite a problem, haskell is completely tied to ghc
06:18:21 <edwardk> rostayob: i usually at least try to factor out the haskell 98/2010 compatible bits into separate packages
06:18:22 <kmc> you can kind of figure it out yourself after looking at enough code
06:18:47 <Cale> rostayob: It's only a problem when people are actually trying to coordinate more than one implementation.
06:18:51 <rostayob> edwardk: because you're a good guy
06:18:58 <Eelis> byorgey: done :)
06:19:09 <kmc> i try to limit my use of extensions, in a way
06:19:13 <edwardk> the original intention was so i could factor out the bits that were standardizable. the result has mostly been people mocking the ensuing package storms ;)
06:19:15 <tomberek> Cale: actually, i've been using Hugs occasionally. (can't get ghc installed at work, hehe)
06:19:21 <Cale> The Haskell community isn't actually large enough to produce more than one implementation of Haskell which is as good as GHC.
06:19:32 <kmc> to stuff that's either widely supported, or stuff that's superficial syntax i could remove in an afternoon's work
06:19:35 <rostayob> Cale: I don't get what you're saying, you're saying that we should be happy with one good compiler?
06:19:35 <saml> > \->1
06:19:36 <lambdabot>   <no location info>: parse error on input `\->'
06:20:01 <kmc> Cale, yeah, at this point if you want to do interesting compilers work on Haskell, stealing GHC's frontend is a good bet
06:20:02 <Cale> rostayob: Um, I'm saying that I don't think we have the human resources to produce more than one good compiler at the moment.
06:20:02 <rostayob> Cale: yeah but the barrier to writing a useful good compiler for haskell now is huge
06:20:10 <saml> > (\x -> 1) == (\x -> 1)
06:20:11 <lambdabot>   *Exception: (==): No overloading for function
06:20:14 <saml> why can't i do that?
06:20:19 <rostayob> Cale: we don't have the human resources because there is so much to cover :P
06:20:20 <edwardk> once the dust settles on the type/data family stuff, i could see another compiler getting up to snuff, but right now its too easy to wind up in an intellectual backwater
06:20:27 <Cale> saml: because equality isn't defined for functions
06:20:30 <saml> compare lambdas since lambdas are values
06:20:42 <clsmith> saml: because there's no definition of equality for arbitrary functions. you could define one i think
06:20:44 <Cale> saml: Equality testing for functions is undecidable.
06:20:59 <Cale> saml: It's equivalent to the halting problem.
06:20:59 <saml> maybe it's doable in agada?
06:21:03 <edwardk> saml: then you get different answers depending on whether or not common subexpression elimination is done, etc.
06:21:10 <erus`> i thought the parser would convert infix functions to prefix ones
06:21:12 <Cale> no, it's not doable in any effective language
06:21:13 <saml> doesn't haskell have well defined semantics?
06:21:14 <tomberek> Cale: i was considering CPS or the CPS Monad, is that applicable to my situation?
06:21:22 <kmc> saml, you can pass around proofs of function equality in Agda
06:21:24 <edwardk> saml: it does, and therefore it doesn't allow nonsense like that ;
06:21:25 <kmc> that's not really the same thing
06:21:32 <Cale> saml: Checking to see if two functions are the same is fundamentally impossible.
06:21:40 <Accidus> edwardk, does it? Where are they?
06:21:44 <tomberek> saml: it's like asking if a black box is identical to another black box
06:21:53 <Accidus> edwardk, Are there well defined operational/denotational semantics for haskell?
06:21:55 <saml> yes
06:21:57 <kmc> saml, you can easily phrase any unsolved question of mathematics (Riemann hypothesis, Goldbach conjecture, etc.) as a question of the equality of two functions
06:22:02 <tomberek> saml: it could be the same, but you'd have to try every input
06:22:08 <Cale> saml: You could do it for functions having finite domains.
06:22:10 <kmc> two computable functions
06:22:17 <edwardk> Accidus: =P there have been lots of attempts to build a formal semantics for Haskell. none that are really usable
06:22:18 <Cale> actually, and even then, you can't really check
06:22:25 <saml> in some languages  two functions are equal if they are isomorphic
06:22:30 <Cale> Because you have to test whether f _|_ == g _|_
06:22:33 <kmc> saml, http://hackage.haskell.org/package/enumerable
06:22:42 <saml> and isomorphism test for semantic graph is decidable
06:22:44 <edwardk> sam1: and how to these functions actually test that equality? it is undecidable
06:22:48 <Cale> in the case that f or g is constant on the rest of the domain
06:23:09 <Accidus> edwardk, So the proper answer to saml's question: "doesn't haskell have well defined semantics?" is "no, it doesn't."
06:23:12 <Cale> and if one is strict, then that won't terminate
06:23:14 <dylukes> Cale: Is it possible to inductively prove that two functions are equivalent?
06:23:16 <saml> you draw semantic graph from syntax tree. and the graph can take natural transformation to equality
06:23:17 <keep_learning> How can we use State monad if  our number of variables are large ?
06:23:18 <rostayob> what was the propriety of functions that always return the same value with the same arguments?
06:23:20 <Cale> dylukes: Sometimes
06:23:20 <dylukes> (for infinite functions)
06:23:22 <edwardk> accidus: fine
06:23:24 <Accidus> :)
06:23:30 <Cale> dylukes: But not always, in the case that they are.
06:23:31 <kmc> rostayob, function
06:23:31 <Botje> keep_learning: stick them in a record.
06:23:41 <rostayob> kmc: no, there was a specific term for that
06:23:49 <rostayob> in CS
06:24:00 <kmc> the term is "function", everyone else is just crazy ;)
06:24:10 <kmc> maybe you want "referentially transparent" or "pure"
06:24:26 <rostayob> kmc: no, a function of that kind is not necessarly referentially transparent, or free of side effects
06:24:33 <rostayob> i could delete files and still return the same thing
06:24:46 <edwardk> sam1: the problem with such an intensional notion of equality is that you then have to keep such a graph around, and it makes a lot of useful code transformations illegal
06:24:51 <kmc> true
06:25:15 <Cale> saml: Let f be the function which given an integer n, tells us whether some arbitrary Turing machine terminates on input n. Let g be the constant True function. Then f == g amounts to termination checking.
06:25:17 <keep_learning> Botje: You mean some thing like State ( state defined algebrically using data keyword ) ( returning value ) ?
06:25:19 <clsmith> rostayob: i doubt that really has a name? i mean, in strict terms by creating a side-effect you are returning a different value in terms of the "world"
06:25:22 <Cale> saml: -> undecidable
06:25:27 <edwardk> sam1: for instance scheme r5rs mandates that you can compare lambdas for equality because they all get a unique 'location' at definition, but this rules out eta-expansion and eta-reduction
06:25:27 <Botje> keep_learning: yes.
06:25:39 <efie> map (\x -> if (x=='[' || x==']' || x==',') then '' else x) "[0,1]" i want to delete [,]and, but '' is not correct, what do i have to use? ' ' works, but thats not what i want
06:25:51 <edwardk> sam1: i'm much happier not having equality than having a crappy semantics that ensures poor performance
06:25:54 <rostayob> clsmith: it was a term specific to CS, starting with homo I think eheh
06:25:58 <keep_learning> Botje: thank you
06:26:09 <Botje> efie: you cannot delete elements with map. switch to concatMap
06:26:31 <efie> ok, thanks
06:26:42 <edwardk> sam1: it also directly conflicts with the ability to inline
06:26:43 <dylukes> efie: or use filter?
06:26:56 <Cale> Or, that is, let f be the function which gives True when the Turing machine terminates, and _|_ otherwise ;)
06:27:00 <Botje> filter is indeed infinitely better here.
06:27:14 <Botje> efie: also, check out the elem and notElem functions
06:27:32 <efie> ok :)
06:27:57 <rostayob> Saizan: some time ago you mentioned a term to indicate functions that return the same values if called with the same arguments
06:28:00 <dylukes> > let f = filter (\x -> x `notElem` ['[', ']', ',']) in f "[1,2,3,4,5]"
06:28:00 <lambdabot>   "12345"
06:28:08 <dylukes> efie: Is that what you want?
06:28:13 <edwardk> rostayob: pointwise equality?
06:28:15 <efie> yes, thanks
06:28:19 <Axman6> > filter (`notElem` "[]'") "[1,2]"
06:28:20 <lambdabot>   "1,2"
06:28:20 <Botje> or just x `notElem` "[],"
06:28:30 <dylukes> Botje: true.
06:28:31 <Axman6> > filter (`notElem` "[],") "[1,2]"
06:28:32 <lambdabot>   "12"
06:28:50 <Cale> If we want == to be syntactic equality of functions, it completely prevents almost all optimisations that the compiler could do, because it doesn't know what optimisations will be present in future modules.
06:29:01 <dylukes> > let f = filter (`notElem` "[],") in f "[1,2,3,4,5]"
06:29:02 <lambdabot>   "12345"
06:29:05 <dylukes> yeah, that's cleaner.
06:29:17 <Cale> Or else it would have to store the syntactic definition of every function and keep it around at runtime
06:29:26 <Cale> which is nonsense
06:29:38 <frerich> Axman6: Hm, interesting, didn't occur to me to use infix style instead of "flip" (I have a function like you wrote, except that I used "flipt notElem")
06:29:52 <Cale> also, syntactic equality of functions is dumb
06:29:55 <tomberek> Cale: i was just about to say that.  Every function would have to carry around its explicit definition
06:30:14 <dylukes> frerich: :)
06:30:19 <Cale> It would break referential transparency
06:30:39 <Axman6> Cale: how?
06:31:09 <Cale> Axman6: You could check to see if the function parameter you were passed was a specific function implemented in a specific way
06:31:23 <Cale> and do something entirely different based on that
06:31:49 <Cale> and then replacing the argument to that function with a different one which is semantically equivalent is no longer valid
06:31:50 <erus`> is there a gedit plugin that makes \ into lambda and -> into a real arrow etc like leksah ?
06:31:55 <rostayob> edwardk: no
06:32:09 <rostayob> erus`: well emacs has font locking. don't know about gedit
06:32:21 <rostayob> erus`: probably not
06:32:23 <Axman6> bleh, so foo id and foo (\x -> x) would act differently. not fun
06:32:26 <edwardk> extensional equality?
06:32:31 <Cale> Axman6: right
06:32:58 <Cale> saml: So basically, it's either impossible, or a terrible, terrible idea.
06:33:17 <edwardk> i get the impression sam1 wandered away a while ago ;)
06:33:26 <rostayob> macros share a similar problem right? that a macro given semantically equivalent arguments can lead to different results
06:33:34 <Cale> rostayob: yeah
06:34:36 <Cale> Well...
06:34:58 <Cale> It depends on what you consider the arguments to the macro to be.
06:35:05 <Cale> They're probably syntax trees, and not really functions.
06:35:59 <Cale> and sure, macros can do anything they want with syntax trees which would compile to semantically equivalent functions, including things which wouldn't be referentially transparent at all if they could be done to those functions themselves.
06:36:02 <rostayob> Cale: yes, I don't think you actually "break" any propriety like you do if you define some strange function equality
06:36:12 <kmc> the problem is more at the site of use, if you don't have a syntactic distinction between function and macro application
06:36:31 <Cale> Macros are implicitly running at compile time, and not runtime too.
06:37:12 <rostayob> yeah I didn't imply that you lose referential transparency or something like that. I remember seeing this argument against macros in a lazy evaluation vs macros discussion
06:37:51 <edwardk> the main benefit that macros bring to the table is the ability to define exotic binding forms
06:37:59 <Cale> Oh, sure, in cases where you have a choice, lazy evaluation has nicer properties.
06:38:27 <kmc> it's funny how Graham's _On Lisp_ goes out of its way to use macros not only for deferring evaluation but even simple things like 'map'
06:38:37 <rostayob> Cale: since many people liquidate the useful evaluation saying that macros are a good substitute...
06:38:46 <rostayob> kmc: yeah exactly
06:38:56 <rostayob> is liquidate a word in english?
06:38:57 <kmc> his perspective on Lisp is not shared by everyone who uses it
06:39:10 <Cale> It is, but it seems a little odd there.
06:39:13 <kmc> it is, but i don't think it means what you think it means
06:39:38 <rostayob> ok. in Italian it would mean to dismiss
06:39:57 <rostayob> kmc: well a lot of people approached lisp through paul graham
06:41:10 <rostayob> for example this essay http://www.paulgraham.com/avg.html declares lisp superiority on all other languages, mostly because of homoiconicity/macros
06:41:11 <Cale> In English, it's mostly used for the ending of a company, where the assets that the company has are broken up.
06:41:42 <rostayob> Cale: yeah it means that in italian as well, but it has two meanings i guess
06:53:35 <roconnor> does Epigram 2 have homoiconicity?
06:53:44 <roconnor> maybe not
06:54:02 <hnsz> paul graham his essays are overrated
06:56:15 <tomberek> Cale: both you iterM and my iter produce almost the same allocations and GC behavior. I'm thinking that something about f a >>=f >>= f can be optimized, but not the recursive (f  >=> f) or (f a >>= go (n-1)
06:56:40 <mm_freak> hnsz: actually paul's essay really applied to me
06:57:11 <mm_freak> haskell increased my productivity a lot
06:57:27 <Cale> Paul Graham uses a lot of words to say very little.
06:57:28 <roconnor> paul's essays told you to use haskell?
06:57:38 <hnsz> Cale: Indeed
06:57:41 <mm_freak> roconnor: no, i just generalized it
06:57:45 <mm_freak> Cale: that's true
06:59:06 <hnsz> His story about the uberlanguage reads like a bedtime story. It's really a simple unexplored idea not some deep insight as he wants to make it out to be.
06:59:14 <mm_freak> i'm not a big fan of paul graham after reading some of his other stuff, but i have to thank him for encouraging me to go with haskell
06:59:39 <hnsz> And trust me you don't really want to work in lisp anymore, eventhough it's a n ice language
06:59:52 <mm_freak> even though he would probably have preferred me to learn lisp instead
07:00:14 <mm_freak> i didn't like lisp, despite trying it very often
07:00:37 <mm_freak> ugly syntax (and i'm not talking about the parentheses here), strict, nonlazy, no builtin concurrency
07:01:30 <mm_freak> talking about common lisp here…  i did like scheme/racket to some extent
07:03:06 <rostayob> paul graham as every evangelist abstracts the details so what he says might not be correct, but most of the times the point he makes is valid
07:03:34 <rostayob> like "if you can use a higher level language, you should". no shit
07:03:43 <rostayob> but it's not so obvious to many people
07:03:58 <mm_freak> he's a bit more exact here:  you should, /most of the time/
07:04:26 <rostayob> mm_freak: well that's what I mean with "if you can"
07:04:58 <Cale> http://www.wolframalpha.com/input/?i=number+of+calories+in+a+skinless+chicken+breast -- LOL wtf
07:05:07 <hnsz> rostayob: He just really doesn't have that many interesting things to say, that has nothing to do with abstraction.
07:05:19 <Cale> NLP complete fail!
07:05:31 <rostayob> Cale: ahahaha
07:05:47 <rostayob> hnsz: that's not true
07:06:11 <hnsz> rostayob: What isn't ?
07:06:22 <rostayob> hnsz: that he never had anything interesting to say
07:06:34 <hnsz> Btw he isn't writing foor lamen he is writing for us.
07:06:43 <rostayob> lamen?
07:06:46 <rostayob> oh. laymen.
07:06:51 <confound> lamen noodles
07:06:52 <tomberek> Cale: is that a statistical average or deduction from experience?
07:06:52 <hnsz> yes
07:07:15 <rostayob> well he's writing to startup founders. it's not like every person that wants to create a startup is a good programmer
07:07:29 <rostayob> that's his target, and his essays are relevant in that field imho
07:08:19 <confound> that's the first time I have encountered the suggestion that paul graham is writing primarily to startup founders
07:08:39 <rostayob> also, there are a lot of great programmers who are perfectly content with java
07:08:56 <rostayob> confound: isn't he?
07:09:12 <rostayob> most of his essays are about that
07:09:30 <rostayob> even the one about lisp is about how their startup was better because they had lisp
07:09:54 <confound> I guess people just don't send me links to those.  I get sent stuff like http://www.paulgraham.com/iflisp.html instead
07:10:04 <confound> and http://www.paulgraham.com/hp.html
07:10:30 <hnsz>  alot are but they are directed towards engineer students not business students
07:10:45 <hnsz> pardon my English atm
07:12:48 <rostayob> confound: yeah but they're not strictly technical anyway
07:13:18 <rostayob> hnsz: yes, engineering students that want to create a startup. is mostly about succeeding in business through programming :P
07:13:19 <confound> there's a pretty large gulf between "for startup founders" and "not strictly technical"
07:14:58 <rostayob> confound: I don't get your point, paul graham has founded a company to found startup, he himself created a startup for "the first web application", his essays are mostly targeted to programmers who want to create some product
07:15:04 <rostayob> at least that's the feeling i guess
07:15:26 <rostayob> *i get
07:15:42 <confound> many of them are
07:16:33 <rostayob> confound: yeah that's all i'm saying :P
07:16:39 <confound> but my point there was only that you'd made what seemed like an unwarranted leap of logic
07:16:45 <confound> I'm not sure we're even having the same conversation, though
07:17:43 <confound> PG's more general essays about software don't seem to say very much. I think that's what hnsz might have meant.  his founder-targetted ones might, but I don't care about founding a startup, so I don't read them.
07:19:13 <hnsz> What I do like is that he is rallying students to become sort of hybrids entrepeneur/engineer. He does classes and projects with them.
07:19:48 <RichardBarrell> Not trying to be That Guy or anything, but this conversation kiiiinda belongs in #haskell-blah.
07:20:08 <RichardBarrell> I mention it mainly because #haskell-blah is full of nice friendly people who dispense hugs on command and you should come and say hello there too.
07:20:08 <hnsz> :)
07:20:39 <confound> please dispense ghci on command
07:21:45 <hnsz> Just as a last note his things on SPAM are pretty good.
07:22:33 <rostayob> confound: yes, I agree that on a software engineering pov he doesn't say much
07:23:32 <rostayob> RichardBarrell: yeah you are right ehe
07:23:49 <Saizan> RichardBarrell: are you serious?:D
07:24:18 <RichardBarrell> Saizan: well, I'm in #-blah and I dispense hugs upon request, so that's one data point there and I just extrapolated wildly.
07:27:42 <hnsz> Problem is I'm in ircII in putty. I can only have one window :)
07:28:45 <Botje> are you sure?
07:29:04 <Botje> I remember using Bitchx(an evolution of ircII) in 2000ish and I could listen to multiple channels
07:29:14 <Botje> talk, too. but it was a bit more complex
07:29:19 <rostayob> hnsz: the question is: why?
07:29:33 <hnsz> indeed
07:29:37 <rostayob> there are a lot of nice textual irc clients ehe
07:29:57 <hnsz> I should just install irssi. B ut this is offtopic again. sorry. :(
07:30:44 <Botje> do it! let #haskell be the motivating factor! :)
07:30:50 <rostayob> hnsz: (weechat is better)
07:31:35 <drdo> ERC
07:31:36 <hnsz> Botje: I'm on page 180 of the Art of Functional programming
07:32:17 <hnsz> Can't wait to get to monads :) I hear it everywhere :)
07:32:43 <rostayob> the art of functional programming? is that a book?
07:32:53 <Botje> monads are okay
07:33:01 <hnsz> oops ! s/art/craft/
07:33:21 <rostayob> hnsz: ah, ok
07:33:30 <hnsz> Simon Thompson
07:33:52 <rostayob> hnsz: yeah I remember it being the suggested book for haskell, first day at uni eheh
07:35:59 <endojelly> I really liked The Haskell School of Expression
07:36:03 <roconnor> preflex: seen alex404
07:36:03 <preflex>  alex404 was last seen on #haskell 5 days, 20 hours, 38 minutes and 5 seconds ago, saying: roconnor: This is a lot of food for thought... thanks.
07:36:09 <hnsz> rostayob: Yeah it's not in my curriculum but I wanted to learn it and took the book from the course description.
07:37:07 <kmc> hnsz, monads really aren't a big deal
07:37:17 <hnsz> rostayob: Not really a book for programmers tbh, but it is very good.
07:37:21 <kmc> they're not the main thing in Haskell, despite what you may have heard
07:37:48 <roconnor> the are kinda a big deal in a way that isn't Haskell specific.
07:37:53 <hnsz> kmc: I realise that :)
07:38:42 <kmc> cool :)
07:38:57 <edwardk> yes, comonads are clearly where it is at.
07:39:48 <roconnor> comonads are hopefully a bigger deal than they have been made out to be :)
07:57:26 <RayNbow> what is the ConstraintKind extension that's being used in http://hpaste.org/50576 ?
08:00:48 <Saizan> ooh, they implemented that?
08:01:12 <thoughtpolice_> max did, but it's not in master branch yet
08:01:17 <thoughtpolice_> you can clone ghc and check out the branch though
08:01:29 <copumpkin> he's been so prolific
08:01:56 <Saizan> this is going to create even more bikeshedding on the Control.* hierarchy :)
08:02:15 <copumpkin> I wonder if you can make it an associated type, too
08:02:27 <ezyang> Aw man, that's pretty excellent.
08:10:02 <kmc> woah
08:10:08 <kmc> nice extension
08:10:34 <kmc> also nice hpaste title
08:11:59 <copumpkin> man, I can't wait
08:12:18 <copumpkin> I wonder if we might even get instances for Vector!!
08:12:24 <copumpkin> :O
08:12:42 <roconnor> please annotate the paste to use  GHC's do notation overloading.
08:12:49 <mm_freak> isn't Vector a monad?
08:12:58 <copumpkin> no
08:13:04 <copumpkin> unless you put edwardk's instances into scope
08:13:25 <copumpkin> but what I meant was that even the unboxed ones
08:13:27 <mm_freak> why not?  why is [] a monad, when Vector isn't?
08:13:30 <copumpkin> could be meaningful instances
08:13:36 <copumpkin> mm_freak: ask rl :P
08:13:46 <mm_freak> rl?
08:13:54 <copumpkin> roman leschinskiy, the guy who wrote it
08:15:52 * kmc has a question for rl about vector's allocator
08:16:10 <kmc> maybe i should send him one of these "electronic letters" i keep hearing about
08:17:14 <kmc> man, as much as i hate on Haskell records, they are pretty useful
08:17:25 <kmc> not so much for "actual data"
08:17:31 <copumpkin> its allocator?
08:17:34 <kmc> but for configuration options to functions
08:17:46 <kmc> and for little cheesy imitations of first-class modules with local open
08:17:59 <kmc> copumpkin, yeah, i was wondering if you get a ForeignPtr from a ByteString and turn it into vector
08:18:01 <frigga> kmc: What do you mean by "Haskell records"?
08:18:09 <kmc> if you run into trouble from the two packages using different allocators
08:18:13 <copumpkin> kmc: you can with StorableVecotr
08:18:14 <copumpkin> vector
08:18:25 <kmc> *nod* that's the one i wanted
08:18:30 <kmc> i have a lib that does this ready to go
08:18:34 <nominolo> @hoogle (a -> b) -> (c -> d) -> Either a c -> Either b d
08:18:34 <lambdabot> No results found
08:18:51 <copumpkin> and I don't mean the StorableVector package
08:19:00 <kmc> frigga, http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-490003.15
08:19:00 <copumpkin> http://hackage.haskell.org/packages/archive/vector/0.7.1/doc/html/Data-Vector-Storable.html
08:19:01 <copumpkin> that one
08:19:09 <copumpkin> unsafeFromForeignPtr
08:19:14 <kmc> *nod*
08:19:23 <kmc> the API is there, i'm just a little uneasy about what the preconditions are
08:19:27 <copumpkin> ah
08:19:38 <copumpkin> I'm pretty sure it's designed specifically for that scenario
08:20:18 <frigga> kmc: Yeah, they're fine for the stuff they can do...kind of suck for anything beyond that though.
08:20:19 * copumpkin curses at scala's terrible type inference
08:21:13 <kmc> why is it terrible?
08:21:36 <benmachine> :t (+++)
08:21:37 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
08:21:43 <benmachine> nominolo: ^
08:21:51 <kmc> implementation problems, or are Java's type system and Hindley-Milner fighting like two cats in a burlap sack?
08:22:41 <copumpkin> kmc: well, there's the subtyping issue that's fundamental, and just really bad implementation that isn't
08:22:55 <copumpkin> you can write val x = List()
08:23:03 <copumpkin> and it will infer the type of x to be List[Nothing]
08:23:06 <copumpkin> where Nothing is the bottom type
08:23:15 <copumpkin> even if you later use x as a list of Int
08:23:24 <copumpkin> the information doesn't get propagated
08:25:09 <kmc> gah
08:25:15 <kmc> does it not do unification at all?
08:25:21 <copumpkin> it does in restricted situations
08:25:52 * kmc curses Haskell committee for making 'default' a reserved word
08:25:53 <copumpkin> also, f[A](x: A, f: A => Boolean): Boolean
08:26:05 <copumpkin> that function will always need a type annotation
08:26:12 <copumpkin> the [A] means f is polymorphic in A
08:26:22 <copumpkin> or that A is a "type parameter"
08:26:27 <kmc> sure
08:26:34 <copumpkin> so if I call
08:26:36 <kmc> explicit forall
08:26:42 <copumpkin> f(1, ...)
08:26:42 <copumpkin> 1 is an Int
08:26:52 <copumpkin> it still can't use that knowledge to determine that f's domain is an Int
08:26:55 <copumpkin> however
08:27:01 <copumpkin> also, f[A](x: A)(f: A => Boolean): Boolean
08:27:10 <copumpkin> that's the curried version of the same thing
08:27:12 <copumpkin> and it works fine
08:27:20 <Saizan> ...
08:27:25 <kmc> sigh
08:27:35 <Saizan> y so fail?
08:27:52 <kmc> sounds like it's hard even to predict when it will work
08:27:57 <kmc> which is almost worse than no inference
08:28:11 <kmc> in Haskell 98 i have a really good idea of when type inference will work
08:28:16 <kmc> that's what makes it usable as a feature
08:28:32 <copumpkin> yeah
08:28:42 <copumpkin> it's not impossible to predict
08:28:44 <Saizan> it's not like you've any alternative in haskell98
08:28:48 <copumpkin> but it's kind of quirky and can take getting used to
08:29:13 <edwardk> then there is scala, where type inference works until you need it to
08:29:30 <copumpkin> :P
08:30:22 <copumpkin> edwardk: you see the type context families?
08:30:48 <edwardk> byorgey mentioned something about them, but i haven't seen a concrete proposal
08:30:55 <edwardk> link?
08:31:19 <edwardk> they would possibly greatly simplify my AD library
08:32:09 <Saizan> they've been implemented, it seems
08:32:19 <edwardk> o.O
08:32:31 <Saizan> http://hpaste.org/50576
08:32:39 <luite> already in head? or even 7.2?
08:32:51 <gwern> > let x a = a:a in x 1
08:32:52 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:32:57 <edwardk> nice
08:32:58 <Saizan> (paste linked by RayNbow)
08:33:02 <gwern> > let x a = [a,a] in x 1
08:33:03 <lambdabot>   [1,1]
08:33:09 <edwardk> i could definitely use that
08:33:25 <int80_h> I am trying to get a git repository. I thought "git pull" or "git fetch" would work, but it doesn't. So what's the right command to pull a repository?
08:33:27 <Saizan> luite: not merged in head yet
08:33:39 <gwern> > let x a = a: x a in take 100 $ x 1
08:33:40 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:33:46 <benmachine> int80_h: git pull :P
08:33:51 <int80_h> hmm
08:33:55 <Saizan> int80_h: from scratch it's clone
08:34:01 <kmc> int80_h, you can try #git
08:34:02 <int80_h> ah!
08:34:02 <benmachine> ohh right
08:34:03 * _Ray_ had to think for a second, since "x" really didn't seem like a function ;)
08:34:11 <benmachine> git pull updates, yes
08:34:19 <edwardk> copumpkin: any luck with precision?
08:34:21 <int80_h> that's why it didn't work
08:34:28 <benmachine> git clone is darcs get is svn co or whatever
08:35:16 <benmachine> :t ap (:) pure
08:35:17 <lambdabot> forall a. a -> [a]
08:40:48 <edwardk> RayNbow: did you write that example?
08:42:13 <edwardk> RayNbow: could you handle the [] case better by just using class Parametric a; instance Parametric a; then using a class associated type for the RMonadCtxt, and just saying that instance RMonad [] where type RMonadCtxt [] = Parametric ?
08:44:48 <hpaste_> edwardk annotated “It LIVES!” with “It LIVES! (class associated type constraint)” at http://hpaste.org/50576#a50595
08:45:38 <edwardk> er sans the spurious 'instance' i left in the second monad
08:46:13 <hpaste_> edwardk annotated “It LIVES!” with “It LIVES! (class associated type constraint) (typo fixed)” at http://hpaste.org/50576#a50596
08:46:52 <Saizan> is it really so complicated to allow "type RMonadCtxt [] a = ()" even for RMonadCtxt m :: * -> Constraint ?
08:47:20 <edwardk> saizan: it breaks the rules for the existing class associated types
08:50:16 <copumpkin> edwardk: that example was by max bolingbroke
08:50:30 <copumpkin> edwardk: not yet, still haven't had any time. Leaving tonight and will probably work on it on the plane
08:50:50 <edwardk> copumpkin: ah
08:50:57 <edwardk> i'll ping him with the cleaned up version
08:51:07 <copumpkin> yeah, he announced it on twitter
08:51:59 <mm_freak> i can't find any information about the ConstraintKind extension
08:52:01 <copumpkin>       s.close
08:52:04 <copumpkin> https://twitter.com/#!/mbolingbroke
08:53:03 <thoughtpolice_> http://hackage.haskell.org/trac/ghc/wiki/KindFact is the proposal iirc
09:03:02 <co_dh> how can I talk to lambdabot directly?
09:03:07 <mm_freak> say i have a comonadic data structure like a fixed length array…  it seems to me that the comonadic interface is only useful, when you want to map a function looking at the neighbourhood of each element, e.g. image processing
09:03:12 <mm_freak> is my intuition right here?
09:03:18 <mm_freak> co_dh: just /query
09:03:19 <kmc> co_dh, IRC private message.  /msg lambdabot
09:03:30 <co_dh> thanks!
09:03:56 <hugh> hello
09:04:09 <edwardk> mm_freak: it is close enough to right that i can't complain about it ;)
09:04:22 <mm_freak> seems that i just don't have the right problems for comonads
09:04:29 <edwardk> likely
09:04:36 <mm_freak> haskell has more solutions than there exist problems lol
09:04:48 <edwardk> i write code then when i look at the data type, i check to see if it is a reasonable comonad
09:06:09 <edwardk> then i occasionally get comonads like https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Diagnostic/Prim.hs but note i don't use Diagnostic as a control structure
09:06:12 <edwardk> just as data
09:07:34 <mm_freak> edwardk: quick summary of what it is?
09:08:28 <edwardk> mm_freak: those are what i use to report errors in trifecta. a diagnostic is a location, a message that you want to show for that line, and a rendering of what the line the error occurred on looks like, along with a nested list of related diagnostics
09:09:41 <edwardk> @hpaste
09:09:42 <lambdabot> Haskell pastebin: http://hpaste.org/
09:10:04 <mm_freak> edwardk: ah, alright
09:10:04 <hpaste_> edwardk pasted “a rendered trifecta diagnostic” at http://hpaste.org/50597
09:10:41 <ezyang> edwardk: "Do I know where hell is? Hell is in hello."
09:10:56 <edwardk> o
09:10:57 <Cale> edwardk: What does the duplicate/cojoin of that look like? :)
09:10:58 <edwardk> ;)
09:11:17 <edwardk>   extend f d@(Diagnostic r l _ xs) = Diagnostic r l (f d) (map (extend f) xs)
09:11:23 <Cale> I mean, when rendered
09:12:16 <edwardk> Diagnostics carry around user defined values in them, not text. i render them to a pretty printer to generate that output
09:13:38 <edwardk> extend would let you use your child diagnostics when determining what to say
09:14:48 <Cale> Makes sense, I guess the prettyprinter isn't some thing using polymorphic recursion that you could just arbitrarily decide to feed a Diagnostic of Diagnostics :)
09:15:28 <edwardk> well i suppose one could try to print one, it'd look silly though ;)
09:16:58 <edwardk> ghci> displayLn $ duplicate $ Diagnostic (Left "Cale") Error () []    ==> Cale: error: Cale: error: ()
09:17:10 <kmc> but i wanted to debug while i debug :(
09:17:18 <edwardk> yo dawg
09:17:55 <edwardk> @hpaste
09:17:56 <lambdabot> Haskell pastebin: http://hpaste.org/
09:18:20 <hpaste_> edwardk pasted “yo dawg I heard you like diagnostics” at http://hpaste.org/50598
09:19:18 <hpaste_> edwardk annotated “yo dawg I heard you like diagnostics” with “yo dawg I heard you like diagnostics (annotation) (with carets)” at http://hpaste.org/50598#a50599
09:19:44 <edwardk> i think it is better to nest them the way it is intended ;)
09:23:29 <ezyang> Sweet, reification of type family instances just hit template-haskell.
09:24:27 <edwardk> ezyang: nice =)
09:28:41 <ezyang> edwardk: Oh right, substructural logics
09:29:40 <hatds> I don't read much about subtyping in Haskell that isn't about records.  Wouldn't subtypes based on constructors be useful?  Like non-empty lists as a subtype of lists.
09:29:49 <copumpkin> https://issues.scala-lang.org/browse/SI-4939
09:31:21 <d-day> edwardk: what are you using the RMonad for that you pasted in 'IT LIVES'?
09:33:00 <copumpkin> d-day: it's a feature everyone has wanted for ages
09:33:05 <copumpkin> and max bolingbroke just implemented it
09:33:14 <d-day> constraint kinds?
09:36:00 <erus`> Anyone have a good idea for a site that i can steal?
09:38:11 <frigga> erus`: That question is rather ill-defined
09:38:12 <d-day> erus`: A community site for people who have confusingly named pets; ie  a kitten named monkey, and a monkey named kitten
09:38:50 <erus`> d-day: sorry i meant cool ideas :)
09:39:00 <erus`> but my friend has a snake called fish
09:39:54 <frigga> erus`: Oh, that's easy then.  Build a web-scale site for social collaboration with the semantic web 3.0.
09:41:05 <erus`> frigga: you cant socially collaborate with an inanimate entity
09:41:24 <erus`> well you can, but i dont think there is enough interest
09:41:38 <frigga> Insert a comma after collaboration.
09:43:35 <erus`> maybe something with bitcoins...
09:49:19 <anandjeyahar> is there a way to convert a IO Int type to Int??
09:49:48 <anandjeyahar> I have to pick a random string from a list of strings. my random generator function returns IO Int.
09:50:06 <n0den1te> @type read
09:50:08 <lambdabot> forall a. (Read a) => String -> a
09:50:30 <copumpkin> anandjeyahar: you're doing it backwards
09:50:34 <copumpkin> you can't get things out of IO
09:50:44 <frigga> anandjeyahar: http://stackoverflow.com/questions/5090779/haskell-problem-io-string-int
09:50:45 <copumpkin> you need to put your consumer of the Int into IO
09:51:14 <copumpkin> instead of taking the Int out of the box so you can work on it, crawl into the box and work on the Int inside
09:51:40 <anandjeyahar> copumpkin: Thanks. will try that and come back
09:52:17 <n0den1te> anandjeyahar: adding to what copumpkin said, minimise IO only to expose data to external world.
09:52:27 <erus`> one of the advantages of writing a game in haskell is the cheaters/hackers will have a hard time making hack for it :P
09:52:38 <kmc> anandjeyahar, http://haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
09:52:53 <kmc> erus`, unless they just analyze your network protocol
09:53:45 <erus`> good luck with that, i rot13-ed it
09:53:57 <kmc> hardcore cryptography
09:54:33 <EvanR-work> lol
09:55:11 <EvanR-work> ive given up on the theoretical and social value of trying stop 'cheaters'
09:55:14 <roconnor> erus`: I want to play!
09:55:30 <copumpkin> I quite enjoy reverse engineering
09:55:45 <erus`> ok
09:55:53 <erus`> my next project that i wont finish is a tiny fps
09:55:59 <copumpkin> oh sweet
09:56:00 <roconnor> copumpkin: have you done ICFP contest 2006?
09:56:01 <erus`> with glfw
09:56:09 <copumpkin> roconnor: nope, I didn't even know it existed back in 2006 :)
09:56:23 <roconnor> here you go: http://www.boundvariable.org/task.shtml
09:56:32 <roconnor> go forth and reverse engineer
09:57:01 <copumpkin> lol
09:57:08 <copumpkin> maybe eventually
09:57:30 <roconnor> ``
09:57:32 <roconnor> When reading programs from legacy "unsigned 8-bit character"
09:57:33 <roconnor>   scrolls, a series of four bytes A,B,C,D should be interpreted with
09:57:35 <roconnor>   'A' as the most magnificent byte, and 'D' as the most shoddy, with
09:57:36 <roconnor>   'B' and 'C' considered lovely and mediocre respectively.
09:59:29 <copumpkin> lol
10:00:45 <n0den1te> that was in ICFP 2006?
10:01:13 <roconnor> ``The '0' array shall be the most sublime choice for loading, and shall be handled with the utmost velocity.
10:03:53 <n0den1te> 13 Febtober 19106? Is that far back into the future or the past? :D
10:04:23 <EvanR-work> lol
10:04:23 <kmc> yeah the ICFP contest is pretty old
10:04:23 <kmc> i recommend digging through the archives
10:04:23 <kmc> (to the extent they exist; it's hosted by a different group each year, so it's not very coordinated)
10:04:23 <kmc> http://www.icfpcontest.org/2011/03/links-to-previous-contests.html
10:04:33 <roconnor> n0den1te: on most computers after 1999 comes 19100 of course.
10:04:51 <drdo> n0den1te: Febtober, sounds like it's in both February and October
10:05:31 <n0den1te> roconnor: y2k bug, I see. ;)
10:05:51 <roconnor> n0den1te: then 6 years after that is 19106
10:06:35 <roconnor> to be honest on my computer it is written as "19:6"
10:06:49 <roconnor> and this year it is "19;1"
10:06:56 <n0den1te> lol
10:07:21 <roconnor> but I guess they are running different software
10:10:10 <n0den1te> drdo: http://www.boundvariable.org/um-spec.txt
10:11:33 <erus`> windowParam :: WindowParam -> GettableStateVar Int
10:11:41 <erus`> how do i read that?
10:12:10 <roconnor> #xmodad ?
10:12:11 <roconnor> er
10:12:14 <roconnor> #xmonad ?
10:12:33 <erus`> GLFW
10:12:51 <roconnor> oh
10:13:44 <monochrom> read that like you read x -> f Int
10:14:00 <erus`> get $ windowParam Opened ?
10:14:27 <roconnor> ah
10:14:50 <roconnor> erus`: it returns the window parameter in the GettableStateVar monad, which is vaguely like the IO monad.
10:15:22 <erus`> they have getKey :: Key -> IO Bool
10:15:38 <roconnor> ya, similar, except even more like the IO monad
10:15:45 <erus`> but windowParam :: Param -> StupidStateShit Int
10:15:55 <roconnor> pretty much
10:16:03 <erus`> why the different methods
10:16:07 <erus`> im gonna fork
10:18:44 <roconnor> erus`: I would have guess that GettableStateVar enforces that the GL state variables are not written to
10:18:49 <roconnor> earthquake!!
10:19:18 <Clint> wacky
10:20:10 <monochrom> roconnor: I'm in Toronto, which town are you in?
10:20:23 <roconnor> monochrom: Hamilton
10:20:28 <roconnor> run for cover!
10:20:59 <tensorpudding> there's an earthquake in canada?
10:21:13 <monochrom> because it may be the same earthquake here. actually, I didn't feel shaking. but I saw a curtain swinging without any air movement whatsoever!
10:21:28 <CoverSlide> probably a poltergeist
10:21:43 <tensorpudding> hmm
10:21:47 <tensorpudding> it should be felt here soon
10:21:48 <danharaj> An earthquake just happened in Washington DC
10:21:52 <danharaj> I felt it here in New York
10:22:15 <roconnor> man if I were in California I'd be able to find a live map of earthquakes
10:22:16 <CoverSlide> oh it's only a 5.8
10:22:31 <fryguybob> http://earthquake.usgs.gov/earthquakes/recenteqsww/Maps/region/N_America.php
10:22:34 <CoverSlide> oh like http://earthquake.usgs.gov/
10:22:36 <Clint> http://earthquake.usgs.gov/earthquakes/recenteqsww/Quakes/at00lqe6x3.php
10:23:41 <monochrom> (what kind of superb suspension system my house is on, that I felt none of the known earthquakes in the past 10 years? :) )
10:23:44 <roconnor> Clint: thanks!
10:23:53 <tromp> i felt it in long island
10:24:33 <Clint> i thought i was having a stroke
10:26:23 <tensorpudding> boo
10:26:25 <tensorpudding> i didn't feel it
10:26:44 <roconnor> tensorpudding: where are you?
10:26:44 <tensorpudding> ohio
10:26:47 <dylukes> I felt it here in Pittsburgh
10:26:48 <roconnor> *lol*
10:26:50 <tensorpudding> but friends in northeast ohio felt it
10:26:57 <dylukes> I was just watching it on Twitter
10:26:57 <dylukes> lol.
10:27:06 <dylukes> 1st world white kid's response to earthquake
10:27:07 <dylukes> -> twitter
10:27:10 <roconnor> yep
10:27:15 <roconnor> obxkcd
10:27:23 <mysticc> :p
10:27:42 <roconnor> http://xkcd.com/723/
10:27:42 <dylukes> The dog was pretty damn calm about the whole thing.
10:27:46 <dylukes> She freaks out when it rains.
10:27:51 <dylukes> She was like NBD GUYS
10:28:19 <tromp> funny; never felt one before
10:29:18 <erus`> i need to turn a GHC.Int.Int32 into a GL.Sizei somehow...
10:30:52 <erus`> do i need to use unsafe cast?
10:31:08 <Saizan>  fromIntegral?
10:31:13 <roconnor> erus`: GL.Sizei is a synonym ofr GHC.Int.Int32
10:31:23 <roconnor> erus`: you don't need anything
10:31:46 <erus`>  Couldn't match expected type `GL.GLsizei' with actual type `GHC.Int.Int32'
10:31:51 <roconnor> oh?
10:32:21 <erus`> @src fromIntegral
10:32:21 <lambdabot> fromIntegral = fromInteger . toInteger
10:32:36 <erus`> well that works
10:33:14 <roconnor> erus`: this is OGL-0.0.3?
10:33:36 <erus`> OpenGL.Raw.Core31
10:33:56 <roconnor> which package is that?
10:35:14 <erus`> Graphics.Rendering.OpenGL.Raw.Core31
10:35:21 <erus`> errr 'openglraw'
10:35:44 <roconnor> I see
10:35:51 <roconnor> ya, fromIntegral is probably best here
10:36:18 <erus`> i still have to use HOpengl though because GLFW takes input with HOpengl types and stuff :(
10:36:39 <erus`> im importing everything and the kitchen sink
10:43:10 <hpaste_> davidb pasted “What's wrong with this?” at http://hpaste.org/50600
10:43:53 <Guest95142> why do i get No instance for (Num [[a]]) ?
10:45:00 <Clint> exactly what do you think you're doing?
10:46:13 <daavidb> ok, it's because the function can return either 0 or b, which can have any type?
10:46:36 <benmachine> what is the function supposed to do?
10:46:54 <benmachine> what type should it have?
10:46:54 <Clint> what is the type of the argument?
10:47:08 <daavidb> well where i have "else b" i had "else [code that uses b and returns integer]". the stuff in the brackets didn't working so I was debugging by trying to return the argument
10:47:34 <daavidb> ...b should be a list of lists, e.g. [[],[]] or [[1,2],[3,4]]. it represents a matrix in fact.
10:47:44 <benmachine> ah
10:48:03 <benmachine> then yes, the problem is you're trying to return b and 0
10:48:10 <benmachine> in different places
10:48:29 <benmachine> 0 is Num a => a, and b is [[a]]
10:48:41 <benmachine> combining these, your function returns Num a => [[a]]
10:48:46 <daavidb> i can't get my head around debugging in haskell
10:48:50 <benmachine> wait no
10:48:54 <benmachine> well, anyway
10:49:11 <benmachine> daavidb: the error messages make more sense when you understand more about classes
10:49:19 <monochrom> > if True then [0] else 0
10:49:19 <benmachine> and numeric literals
10:49:19 <lambdabot>   No instance for (GHC.Num.Num [t])
10:49:20 <lambdabot>    arising from a use of `e_100' at <inte...
10:49:25 <monochrom> same error
10:49:53 <benmachine>  < benmachine> combining these, your function returns Num a => [[a]] <-- this is wrong, what I meant to say is that
10:50:11 <benmachine> combining these, your function returns [[a]], but needs [[a]] to be an instance of Num
10:50:20 <benmachine> sort of like, Num [[a]] => [[a]]
10:50:21 <monochrom> this type error is of the cognitive dissonance kind. you can't make up your mind whether you want a plain number or a list of list of list of numbers
10:50:46 <daavidb> let's say i have a typical recursive factorial function [ fac n = if n==1 then 1 else n*(fac n-1) ]. how can i make the interpreter print out the argument of every call to fac? so if i do fac 10 I want 10, 9, 8, 7,....,1.
10:50:58 <benmachine> try the Debug.Trace module
10:51:29 <daavidb> I found that on google but couldn't figure out how it works
10:51:42 <benmachine> magic
10:51:50 <benmachine> but you achieve what you want by doing
10:51:51 <efie> can someone do anthing with "<stdou>: commitBuffer: invalid argument <character is not in the code page>"?
10:51:59 <monochrom> "how it works" sometimes means "how to use"
10:52:11 <benmachine> fac n = traceShow n (if n == 1 then 1 else n*fac (n-1))
10:53:46 <monochrom> (it bothers me that "how it works" somtimes, even most of the time, refers to "how to use". but who says natural language is meaningful?)
10:54:23 <daavidb> i get "Not in scope: `traceShow'"
10:54:30 <monochrom> import Debug.Trace
10:54:54 <daavidb> beautiful. thanks!
10:56:30 <monochrom> ghci has debugger features too. take some time to read the manual
11:00:19 <monochrom> there is also http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
11:02:38 <benmachine> which is to be taken with a pinch of salt
11:02:42 <benmachine> or possibly a whole handful
11:02:42 <loic_> Hello, I try to install on debian the ssh package with cabal but I have this error : src/SSH/Crypto.hs:70:16: Couldn't match expected type `Data.ASN1.Types.ASN1t'  with actual type `ASN1ConstructionType' ?
11:02:44 <benmachine> (I wrote it)
11:09:47 <sheeple> is there a reason why explicit exporting/importing instances from modules is not available in haskell? is it somehow difficult to implement?
11:10:28 <erus`> haddock should have an 'up' link
11:10:42 <erus`> so if im looking at mobuleA.submodule
11:10:48 <erus`> there should be a link to modulea
11:10:55 <Saizan> sheeple: it's to ensure global consistency, like other limitations of typeclasses
11:11:36 <monochrom> there is a "contents" link
11:16:15 <sheeple> hhm I see
11:16:29 <erus`> @Hoogle Ptr
11:16:29 <lambdabot> Maybe you meant: google hoogle
11:16:44 <erus`> @hoogle Ptr
11:16:44 <lambdabot> module Foreign.Ptr
11:16:45 <lambdabot> Foreign.Ptr data Ptr a
11:16:45 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
11:17:54 <erus`> oh god im using malloc
11:18:04 <erus`> this is what i was trying to escape from
11:19:35 <int-e> what are you doing?
11:20:22 <erus`> making a texture
11:20:30 <erus`> loading a texture i mean
11:20:32 <erus`> into opengl
11:20:39 <erus`> @hoogle a -> Ptr a
11:20:39 <lambdabot> Foreign.ForeignPtr unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
11:20:39 <lambdabot> Prelude id :: a -> a
11:20:39 <lambdabot> Data.Function id :: a -> a
11:21:23 <monochrom> consider alloca, it's easier to use than malloc
11:21:29 <glguy> alloca ::
11:21:30 <glguy>   Foreign.Storable.Storable a => (GHC.Ptr.Ptr a -> IO b) -> IO b
11:21:54 <glguy> I've got your back, monochrom.
11:22:05 <glguy> (apparently)
11:22:28 <int-e> Ok, I have no significantly better idea then. (I had a similar problem when building a vertex array recently.)
11:22:42 <erus`> can i have a multiline lambda?
11:22:50 <monochrom> yes
11:23:01 <int-e> sure, expressions can span multiple lines
11:23:46 <glguy> erus`: another convenient function is
11:23:49 <glguy> with :: Foreign.Storable.Storable a => a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
11:24:19 <hpaste_> erus` pasted “crash!” at http://hpaste.org/50601
11:24:51 <int-e> @type Foreign.Marshal.allocaArray
11:24:53 <lambdabot> forall a b. (Foreign.Storable.Storable a) => Int -> (GHC.Ptr.Ptr a -> IO b) -> IO b
11:25:59 <erus`> allocaArray 1 (\t -> do      still crashes :|
11:26:34 <glguy> Does glGenTextures expect an uninitialized memory region?
11:26:53 <int-e> yes
11:27:23 <erus`> in c it takes GLuint a; glGenTextures(1, &a);
11:27:29 <erus`> i think
11:28:07 <glguy> @hoogle glGenTextures
11:28:07 <lambdabot> No results found
11:28:26 <int-e> erus`: you should initialise GL first.
11:29:21 <monochrom> how anti-climatic
11:29:22 <int-e> (i.e. you need an active context before the glGenTextures call, which I guess comes from the openWindow call)
11:30:16 <int-e> but I don't know GLFW.
11:30:28 <erus`> GLFW does this
11:30:35 <erus`> oh haha
11:30:56 <monochrom> well then init glfw first before glgentexturing
11:31:19 <erus`> i had to open the window too
11:31:22 <erus`> but it works!!!!
11:32:28 * monochrom is disappointed at all these exclamation-marked questions that end with anti-climatic pebkacs
11:33:51 <int-e> monochrom must be disappointed a lot.
11:34:19 <erus`> whats the standard way to dereference a Ptr?
11:34:33 <Saizan> peek
11:34:58 <Saizan> ?type peek
11:34:59 <lambdabot> Not in scope: `peek'
11:35:04 <Saizan> ?hoogle peek
11:35:05 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
11:35:05 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
11:35:05 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
11:35:52 <erus`> I think opengl is nicer in C. But i know its just because the interface is written in C
11:38:37 <int-e> Ah you're using OpenGLRaw. In OpenGL you could use genObjectNames to produce TextureObjects and fill them with texImage2D. You'd still have to deal with a Ptr for the pixel data.
11:39:31 <int-e> (and I suppose genObjectNames would also crash the same way as glGenTextures did)
11:40:31 <daavidb> how would i generate a vector of length 10 of independent random 0-1 coin flips, and then call a function on this vector?
11:40:43 <daavidb> (i.e., a list)
11:44:03 <int-e> @type randomRs
11:44:04 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
11:44:32 <copumpkin> if you have a generator of random values in a monad
11:44:43 <copumpkin> you can use replicateM to get a specific number of random values
11:45:00 <Guest29062> @pl \x -> read $ x:[]
11:45:00 <lambdabot> read . return
11:45:02 <int-e> > randomRs (0,1) (mkStdGen 42) -- but for true randomness you need to pass in some fresh generator each time.
11:45:04 <lambdabot>   [1,1,1,0,0,1,0,1,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,...
11:45:06 <Cale> replicateM 10 (randomRIO (0,1))
11:45:42 <Cale> fmap f . replicateM 10 . randomRIO $ (0,1)
11:46:29 <mm_freak> daavidb: a random vector as in the Data.Vector module?
11:46:54 <mm_freak> if yes, import qualified Data.Vector as V, then V.replicateM 10 yourFavoritePRNG
11:47:00 <int-e> f . take 10 . randomRs (0,1) =<< newStdGen
11:47:07 <int-e> argh.
11:47:09 <hkarim> how to convert (x :: ArrowXml a => a n XmlTree) into String
11:47:14 <int-e> <$> not =<<.
11:52:27 <daavidb> thanks guys
11:52:56 <daavidb> what is the "opposite" of take 5 a? i.e. how do i get all elements 6,7,8,... from the list a?
11:53:04 <Cale> drop 5 a
11:54:54 <daavidb> ah cool thank you
11:57:57 <EvanR-work> drop = -take
11:58:58 <efie> does anyone know how to handle an error like "<stdout>: commitBuffer: invald argument <character is not in page>"?
11:59:04 <ezyang> I must mornfully conclude that projections are not a particularly good way of reasoning about the operational behavior of lazy functions.
11:59:10 <efie> i mean i do not know what i am doing wrong
11:59:31 <EvanR-work> lol
12:00:25 <benmachine> efie: when do you get that error?
12:02:39 <efie> benmachine: when i try to decode binary numbers (maximum of 8 digits, and chr 127 works fine...)
12:03:01 <benmachine> huh?
12:03:02 <efie> err, i mean chr 255
12:03:04 <benmachine> what functions are you using
12:03:22 <benmachine> what do you mean by decode
12:03:30 <efie> um
12:03:45 <mustelo> seen byorgey
12:03:56 <elliott> How can I get GHC to use a module pre-compiled into a certain -outputdir if I'm using a different -outputdir for this build?
12:04:09 <elliott> Passing the relevant .o to GHC doesn't seem to stop it recompiling; it just links that /and/ the newly-built version together and it all explodes.
12:06:29 <efie> benmachine: i encode a string of characters by converting each character into unicode number, converting each such number into an eight-bit number, if i decode this (the other way round) it is fine, but if i change too much of the binary digits in the eight-bit number the error occurs
12:07:18 <benmachine> efie: I take it from the <stdout> message that you are trying to output something?
12:07:28 <efie> yeah
12:07:42 <efie> i want to print what was decoded
12:07:42 <benmachine> ok
12:07:46 <efie> um
12:07:51 <efie> can i maybe show you the code?
12:07:56 <benmachine> hpaste.org
12:07:58 <efie> its not that long..
12:12:17 <hpaste_> efie pasted “communication channel” at http://hpaste.org/50604
12:13:08 <erus`> has anyone used glTexImage2D with opengl raw?
12:13:18 <erus`> the parameters dont seem to match the opengl docs
12:13:28 <efie> benmachine: maybe you want to compile this ... if the percentage of distortion if small everthing is fine, but when a lot of binary numbers are disturbed, the error occurs
12:13:46 <benmachine> efie: excuse me, I'm suddenly distracted
12:13:48 <benmachine> be back in a bit
12:13:58 <efie> ok :)
12:15:01 <Botje> efie: I think GHC is being helpful by trying to encode your characters somehow.
12:16:04 <rwbarton> maybe your terminal doesn't support unicode?
12:17:07 <rwbarton> or is in some weird configuration that ghc can't translate all unicode characters 0x80-0xff into
12:17:35 <efie> using GHC i can say "decode *any appearance of bits*" and it is decoded (although. rwbarton: um, well 2 days ag
12:17:38 <efie> ups
12:18:21 <rwbarton> try putStrLn $ decode *any appearance of bits*
12:18:25 <Botje> efie: yes, your decode function creates arbitrary chars.
12:18:38 <Eduard_Munteanu> Can you type / paste unicode chars into your terminal and have them display properly?
12:18:43 <Botje> efie: hoewever, when you try to output those chars GHC will try to print it in an encoding your terminal supports.
12:19:23 <Botje> efie: so I guess you will have to switch to a codepage that supports the full 0-255 range
12:19:31 <elliott> hSetBinaryMode stdout True
12:19:34 <elliott> yw
12:19:39 <elliott> efie: see above
12:19:47 <erus`> http://i.imgur.com/D6qEM.png finally! :D
12:20:11 <b_jonas> hello. could you tell me what the DoAndIfThenElse language extension means, eg. which part of the h2011 standard or ghc user manual tells what it is?
12:20:23 <efie> hm ok, thanks for your answers - what me confuses is that it worked 2 days ago and know it does not, grml
12:20:23 <b_jonas> I can't find it from that name
12:20:32 <rwbarton> are you on windows?
12:20:53 <erus`> rwbarton: yeah, my linux box doesnt have X
12:21:07 <rwbarton> I mean efie
12:21:17 <Cale> b_jonas: It's a silly thing which lets you put semicolons in the middle of an if/then/else expression for people who don't know how to indent if/then/else properly
12:21:21 <erus`> well me too
12:21:42 * Eduard_Munteanu remembers there was a bug with unicode stuff on Windows
12:21:49 <elliott> b_jonas: http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
12:22:06 <b_jonas> Cale: thanks. elliot: ah, I should've checked the wiki
12:24:14 <b_jonas> ah, that's not _the_ wiki
12:24:26 <b_jonas> it's the haskell prime wiki
12:24:33 <elliott> I used the google
12:28:18 <efie> rwbarton: decode [1,1,1,1,1,1,1] is displayec in GHCi as '/DEL' whereas putStrLn $ decode [1,1,1,1,1,1,1] is []
12:28:28 <erus`> @hoogle M a -> (a -> b) -> M b
12:28:29 <lambdabot> Warning: Unknown type M
12:28:29 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:28:29 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
12:29:09 <efie> botje: i do not see where the decode function produces arbitrary chars
12:29:28 <rwbarton> it produces arbitrary chars from 0 to 255
12:29:40 <rwbarton> which is fairly arbitrary, compared to ascii :)
12:31:11 <efie> mh
12:31:23 <monochrom> are you just putting an 8-bit value into a Char?
12:31:44 <Botje> efie: the default codepage you're using probably only supports ascii.
12:31:58 <Botje> or maybe latin1. if you're lucky.
12:32:14 <efie> monochrom: yes
12:32:20 <mustelo> edwardk, ping
12:32:35 <rwbarton> you should set your terminal to use unicode if you can, because that is what ghc is trying to output
12:32:58 <efie> ok, i will check this, thanks all :)
12:33:36 <tech2> rwbarton: not entirely accurate. It's attempting to output a particular encoding, probably utf8, but just calling it "unicode" doesn't really say much :(
12:33:42 <monochrom> mere 8-bit values in Char don't cause the exception for most default settings
12:34:22 <rwbarton> even sending control sequences that are in the ascii range (like 0-31) isn't likely to be terribly helpful, though
12:34:25 * hackagebot netclock 0.2 - Netclock protocol  http://hackage.haskell.org/package/netclock-0.2 (AlexMcLean)
12:34:44 <monochrom> but you should find one single value that leads to the exception
12:34:57 <rwbarton> tech2: it wants to output specific unicode characters; I assume it would be willing to cooperate with the terminal if the terminal expected, say, the utf-16 encoding
12:35:11 <tech2> rwbarton: how would it know?
12:35:19 <rwbarton> on UNIX it would use LANG or something
12:35:35 <erus`> i have an IO (Either String a) and i want to >>= into an a -> IO (Either String a)
12:35:37 <rwbarton> I think, maybe one of the LC_* variables
12:36:32 <monochrom> perhaps windows-125x has a problem with some 8-bit values. chcp 65001 for much goodness
12:37:57 <monochrom> "The default TextEncoding is the same as the default encoding on your system, which is also available as localeEncoding. (GHC note: on Windows, we currently do not support double-byte encodings; if the console's code page is unsupported, then localeEncoding will be latin1.)" from TFM
12:39:04 <monochrom> on windows this means probably detecting what codepage the console is at
12:39:31 <erus`> @hoogle M a -> (a -> b) -> M b
12:39:31 <lambdabot> Warning: Unknown type M
12:39:31 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:39:32 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
12:39:56 <mustelo> erus`, you're looking for 'flip fmap' probably... if you give more context I can be more specific
12:40:11 <edwardk> mustelo: pong
12:40:35 <hpaste_> erus` pasted “for mustelo” at http://hpaste.org/50605
12:40:47 <mustelo> edwardk, is there a good way to tell trifecta "no, this isn't utf8, please don't decode it, just treat it raw" on a temporary basis?
12:40:49 <efie> monochrom: ah ok, windows, ms-dos uses ascii
12:40:55 <erus`> i feel like oglLoadImage doesnt need to be an either
12:41:02 <edwardk> mustelo: you can use the combinators in Text.Trifecta.Parser.Char8
12:41:31 <monochrom> no, windows command prompt tends to use windows-125x since 10 years ago or something
12:41:32 <edwardk> if you import those instead of the defaults, none of those do utf8 decoding
12:41:54 <mustelo> edwardk, but when I run the parser itself won't it do the decoding?
12:41:55 <edwardk> the various token combinators, etc. will try to do utf8 decoding though
12:42:07 <edwardk> the individual combinators ask for decoding as they go
12:42:17 <mustelo> okay, so then I guess I'm asking if there's a way to do token stuff without decoding
12:43:04 <edwardk> which tokens are you worried about?
12:43:19 <edwardk> most tokens don't actually match on any non-ascii symbols
12:43:30 <mustelo> right, that's the problem ;)
12:43:35 <edwardk> so it is invisible to you whether or not they try
12:43:35 <erus`> i just needed fmap
12:43:56 <edwardk> which combinator is messing with you?
12:43:56 <mustelo> I want something that maches every single possible byte in a bytestring
12:44:02 <edwardk> thats fine
12:44:15 <edwardk> use satisfyByte or Text.Trifecta.Parser.Char8.anyChar
12:44:25 * hackagebot tidal 0.1 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.1 (AlexMcLean)
12:44:27 * hackagebot tidal 0.1.0.1 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.1.0.1 (AlexMcLean)
12:44:46 <glguy> edwardk: Are there significant differences in trifecta from parsec beyond the pretty error reporting?
12:44:46 <mustelo> ah, so I was just importing the wrong anyChar. okay, I'll give it a try. sorry to bother
12:44:52 <edwardk> Text.Trifecta.Parser.Char8 doesn't do the decoding
12:45:20 * glguy hasn't had time to comb through it yet
12:45:33 <edwardk> glguy: pretty error reporting, you can apply monad transformers, built-in highlighting support, and it is factored in such a way that you more easily use the token parsers
12:46:20 <edwardk> and there is only one small module that actually cares about the parser impementation so its easy to experiment with different parser designs, like swierstra-duponcheel for applicative fragments, etc.
12:46:30 <glguy> built-in highlighting support means your parser implementation also describes a highlighting implementation?
12:46:33 <edwardk> or to ignore things like the highlighting hints
12:46:36 <edwardk> yes
12:46:47 <edwardk> as it parses it builds up an interval map of where tokens were matched
12:46:59 <edwardk> which can be used to retroactively highlight the source rope
12:47:43 <edwardk> next patch will probably include the highlighter as part of the default result, letting you take the diagnostics its generating and generate diagnostics where the cursors etc, point into syntax-highlighted input
12:48:08 <glguy> I guess that makes sense since you have highlighted error messages
12:48:25 <elliott> What's the industry-standard priority queue implementation for Haskell? :p
12:48:43 <edwardk> elliott: heaps is asymptotically optimal
12:48:47 <erus`> hoogle (>>=)
12:48:56 <glguy> Data.Map and Data.FingerTree both offer efficient implementations
12:49:20 <elliott> oh, hmm, why didn't I think of Data.Sequence?
12:49:46 <monochrom> because it requires you to find out where to insert
12:49:49 <edwardk> http://hackage.haskell.org/packages/archive/heaps/0.2/doc/html/Data-Heap.html is very containers-like, but if you need a priority search queue you need to look elsewhere
12:49:56 <elliott> monochrom: well, true.
12:50:12 <edwardk> the main difference is O(1) merge
12:50:15 <elliott> edwardk: I'll try out heaps, then
12:50:17 <glguy> http://hackage.haskell.org/packages/archive/fingertree/0.0.1.0/doc/html/Data-PriorityQueue-FingerTree.html
12:50:37 <monochrom> there are a bunch of priority queues on hackage. I don't know which one is the fastest
12:50:46 <edwardk> glguy: log time merge instead of the optimal O(1) though ;)
12:50:58 <glguy> edwardk: does he care about that?
12:51:00 <elliott> Everybody fight and tell me who wins.
12:51:06 <edwardk> the fingertree psq is also about a factor of 10 slower than a directly implemented psq
12:51:16 <edwardk> glguy: dunno
12:51:25 <elliott> I don't need anything fancy at all.
12:51:31 <edwardk> just enumerating the reasons why the fingertree psq is something you need to think about before using
12:52:19 <edwardk> elliott: http://hackage.haskell.org/package/PSQueue-1.1 is the fastest priority search queue, heaps was at last check the fastest pure priority queue
12:52:45 <elliott> I don't care abou the search part. :p
12:52:48 <edwardk> the fingertree version offers a slightly better fairness guarantee in exchange for a 10x slowdown over PSQueue
12:52:51 <hpaste_> erus` pasted “bloat” at http://hpaste.org/50606
12:52:57 <edwardk> then heaps should work fine
12:52:59 <erus`> am i doing anything silly there?
12:54:10 <elliott> edwardk: I take it you're meant to use Heap (Entry p a) for some p, a?
12:54:25 <edwardk> elliott: if your type doesn't provide its own priority
12:54:35 <elliott> Right.
12:55:10 <edwardk> Entry p a is just Ord'ered on p. giving you a priority/value pair
12:55:25 <elliott> Right
12:56:18 <hpaste_> mustelo annotated “for mustelo” with “for erus (annotation)” at http://hpaste.org/50605#a50607
12:56:39 <edwardk> in retrospect i probably should have supplied two versions, one taking a ey value pair and the other offering this fairly 'naked' priority queue interface
12:56:43 <mustelo> erus`, not saying it's more readable ;)
12:57:19 <reidc> Is there a way to get a simple mutex without using "atomically"?
12:57:34 <edwardk> reidc: MVars?
12:57:45 <erus`> mustelo: i just realized i need oglLoadImage to be IO :(
12:58:14 <erus`> http://stackoverflow.com/questions/7167190/could-i-be-using-a-bind-fmap-here reap the sweet karma
12:58:35 <reidc> ok, but I would have to define the MVar before forking, right?
12:59:08 <edwardk> reidc: it is much easier to ensure both have access to it if you do ;)
12:59:08 <monochrom> s/define/create/ but yes
12:59:13 <reidc> whereas with "atomically", I can just mark off the critical section without changing anything else
12:59:20 <luite> erus`: you can use loadTexture = PNG.loadPngFile >=> oglLoadImg
12:59:26 * hackagebot iso3166-country-codes 0.20110810.3 - A datatype for ISO 3166 country codes  http://hackage.haskell.org/package/iso3166-country-codes-0.20110810.3 (JonFairbairn)
12:59:30 <luite> erus`: and use the either function for oglLoadImg
12:59:48 <edwardk> reidc: in exchange for the fact that atomically does optimistic evaluation with backtracking and you can't nest IO actions inside it safely
13:00:00 <edwardk> and you'd probably best not use atomically inside of unsafePerformIO
13:00:08 <monochrom> with STM you create TVars to share before forking anyway
13:00:30 <reidc> hmm, well what I'm trying to do is thread-safe random number generation
13:00:39 <edwardk> you can also use atomicallyModifyIORef
13:00:47 <edwardk> which is lighter weight than the MVar approach
13:00:47 <reidc> and (assuming that different threads use the same global random number generator)
13:01:15 <reidc> it seems that a clean solution would be to protect the getStdGen and setStdGen code with a mutex
13:01:31 <erus`> @hoogle (>=>)
13:01:32 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:01:37 <edwardk> fresh = atomicallyModifyIORef myHugeChokePoint $ \a -> (a + 1, a)
13:01:38 <incluye> The wiki's "tutorial" on the State monad is absolutely terrible
13:01:41 <incluye> does anybody know of a better one?
13:01:51 <Botje> did you check all about monads?
13:01:57 <Botje> or maybe LYAH's chapter on them.
13:02:12 <luite> erus`: you can se a separate fmap, but you'll need either anyway...
13:02:21 <edwardk> reidc: you can modify that scheme to deal with the rng plumbing
13:02:54 <monochrom> well then only the code of getStdGen and setStdGen needs to know about the MVar
13:03:20 <incluye> Botje: oh I didn't even think of LYAH but that looks like what i need
13:03:27 <monochrom> just like only the code of getStdGen and setStdGen needed to know about the TVar
13:03:40 <luite> erus`: oh wait, sorry I didn't see that you return an either
13:03:45 <luite> Either
13:03:48 <luite> ugh my shift is broken
13:04:08 <monochrom> and if you choose atomicmodifyioref, only the code of getStdGen and setStdGen needs to know about the ioref
13:05:12 <edwardk> of course, if you are multithreaded using a common IORef then exposing a setStdGen is potentially quite silly ;)
13:05:19 <edwardk> you can't sanely replay anyways
13:06:25 <monochrom> so my "you have to create blah before forking" was wrong. you have to create blah before creating those who need to know
13:07:02 <hpaste_> reidc pasted “rng with mutex” at http://hpaste.org/50608
13:07:48 <monochrom> sem is global
13:08:03 <reidc> oh, I can just put it at the beginning of that file?
13:08:11 <edwardk> you can just put sem at the top level and define it using unsafePerformIO $ newMVar ()
13:08:18 <edwardk> but there is a better way
13:10:19 <FUZxxl> Is there an instance of traversable for Either?
13:11:19 <edwardk> i have defined it a couple of times, but i recalled it being added somewhere
13:11:19 <rwbarton> for Either a, yes, don't know whether it is defined anywhere
13:12:11 <efie> if say import Char main = do mapM_ print $ map chr [1..130] , compile it and start the exe, everthing is displayed as it is when i say mapM_ print $ map chr [1..130]  in GHCi; this is contrary to the codepage error above, is it not?
13:12:14 <mm_freak> ok, i'd like to have a problem ;)
13:12:15 <incluye> Err, it appears that LYAH was written based on an incompatible version of mtl
13:12:16 <hpaste_> edwardk annotated “rng with mutex” with “simpler rng with mutex” at http://hpaste.org/50608#a50609
13:12:22 <incluye> so I'm getting "unknown data constructor State"
13:12:38 <Botje> efie: can you go up to 255?
13:12:42 <edwardk> incluye: ah, State is long dead. use 'state' to construct
13:12:43 <efie> yes
13:12:51 <edwardk> and runState will effectively tear it apart
13:12:57 <Botje> efie: can you also check if 0 is allowed?
13:13:20 <mm_freak> i had (roughly) this definition for AFRP signal transformers:  data Wire a b where WGen :: (a -> (b, Wire a b)) -> Wire a b
13:13:26 <edwardk> incluye: effectively with the jump to 2.0 mtl dropped the 'non-T' versions of things and made them special cases of the transformers
13:13:39 <mm_freak> it was easy to define a working ArrowLoop instance for this type
13:14:10 <mm_freak> now i have (roughly):  data Wire m a b where (a -> m (Either SomeException b, Wire m a b)) -> Wire m a b
13:14:35 <mm_freak> i tried hard to write an ArrowLoop instance for that:  instance MonadFix m => ArrowLoop (Wire m)
13:14:40 <mm_freak> but it always diverges
13:14:46 <efie> :|
13:14:47 <efie> botje: it works fine with 0 as well
13:14:47 <mm_freak> anyone have an idea how to do it?
13:15:12 <mm_freak> Cale: you perhaps?
13:16:04 <mm_freak> oh, add the constructor name in the GADT
13:16:05 <Botje> efie: and you are certain you're only creating characters up to 255?
13:16:07 <mm_freak> typo =)
13:18:30 <efie> bothe: yes, this is the program http://hpaste.org/50604 chop8 is used in decode .. furthermore i can go up to 10000 and no error occurs
13:20:18 <efie> botje*
13:21:22 <efie> it seems to me that the error occurs in the program when something is disturbed into '\xy', when something is is disturbed into a character or something it is displayed
13:21:39 <Botje> [1..0]
13:21:41 <Botje> hmm
13:21:45 <Botje> > [1..0]
13:21:46 <lambdabot>   []
13:21:50 <Botje> good
13:22:36 <Botje> efie: in decode, can you check if it produces characters > 255 ?
13:26:10 <Cale> mm_freak: glutGameTest: <<loop>>
13:26:20 <Cale> That is all.
13:27:24 <sonoflilit> Hello
13:27:30 <sonoflilit> I've been profiling my heap usage
13:27:40 <Cale> mm_freak: (actually, I can help, but I'm actually busy working on a loop introduced by some new collision detection code)
13:27:55 <sonoflilit> and I've noticed that my program is using much more memory than is shown in the profiling graph
13:28:13 <sonoflilit> (I should mention that I don't let it run to the end but instead kill it in the middle with Ctrl+C once)
13:29:09 <Cale> sonoflilit: You mean as reported by 'ps' or 'top' or something?
13:29:14 <sonoflilit> I thought this was caused by either (a) a constant amount required by the runtime and not shown (but the amount is not constant) or (b) the profiler "lagging" behind and showing me historical data but not current
13:29:18 <efie> botje: no, it does not
13:29:20 <sonoflilit> Cale: indeed
13:29:49 <sonoflilit> but now I'm considering that (c) most of the memory is going to FFI-allocated buffers that might not be shows
13:29:49 <Cale> sonoflilit: Are you doing a lot of FFI stuff? I'm pretty sure allocations out in C land aren't counted by the profiler.
13:30:08 <sonoflilit> how can I check if this is the case?
13:30:15 <efie>  (although i now think it would not make any difference as encode [1,1,1,1,1,1,1,1] is "\255" and this is displayed in the terminal correctly
13:30:27 <Cale> I'm honestly not sure. I've never had to do it myself.
13:30:34 <sonoflilit> anyone know?
13:30:39 <efie> (as i can see, it does not produce > 255)
13:30:52 <Botje> efie: then i'm out of ideas.
13:31:41 <efie> thanks anyway :)
13:33:04 <sonoflilit> Cale: I can't seem to find relevant stuff on google either
13:33:13 <sonoflilit> is there a resource you can direct me to?
13:33:57 <Cale> Where is dons when you need him? I'm sure he'd know.
13:34:23 <rwbarton> efie: print and putStrLn are quite different
13:34:36 <Cale> sonoflilit: Maybe it's possible to use C profiling tools, but I'm completely unfamiliar with those.
13:34:55 <Cale> sonoflilit: Basically, out in C land, you're on your own, as far as I know.
13:36:11 <rwbarton> efie: print is putStrLn . show, so print-ing a String will produce output that is wrapped in "", and has sequences like \255 in place of characters that aren't printable ASCII
13:36:58 <rwbarton> putStr just sends the String to the console, after encoding it appropriately for your terminal
13:37:09 <monochrom> > show "\x0041\x0397"
13:37:10 <lambdabot>   "\"A\\919\""
13:37:14 <rwbarton> you probably just want to use print in your program rather than putStr
13:37:18 <monochrom> that is expected
13:39:18 <monochrom> encrypting things into the like of '\x0001' and outputting it to console is very disturbed
13:39:47 <roconnor> ☺
13:39:54 <sonoflilit> Cale: thanks. I'll try to ask again another time and I'll see if I can get C profilers to work here
13:39:59 <sonoflilit> good night
13:41:18 <hpaste_> reidc annotated “rng with mutex” with “simpler rng with mutex (annotation)” at http://hpaste.org/50608#a50611
13:42:38 <reidc> Can someone help me with the code there?  The most recent annotation is edwardk's code corrected so it runs.
13:43:35 <reidc> How can I generate doubles in [0, 1]?
13:44:48 <efie> rwbarton: thanks a lot ... it works now! (though i am still surprised about that it worked 2 days ago with putStrLn and ASCII, the "\xy" were displayed/encoded as crude, strange symbols)
13:44:54 <reidc> Why is it that when I change "getRnd :: (Random a) => IO a" to "getRnd :: IO Double" I get the same output with every call?
13:45:40 <monochrom> you need another one: getRndR r = atomicModifyIORef sem $ \g -> case randomR r g of (v,g') -> (g',v)
13:45:41 <rwbarton> efie: either your terminal was different in some way, or you simply got lucky that the characters you were sending that day were ones your terminal could handle...
13:45:43 <cwraith> reidc: I'd expect the answer is "you implemented it wrong"
13:47:40 <monochrom> also I don't get the same output with every call
13:47:48 <efie> yeah, that's how it probably is :)
13:50:05 <monochrom> also you should have {-# NOINLINE sem #-} to suppress an optimization that may create many instances of sem
13:54:27 * hackagebot web-css 0.1.0 - Simple functions for CSS.  http://hackage.haskell.org/package/web-css-0.1.0 (BardurArantsson)
13:57:59 <kamaji> Can I do "read x :: a" where a is a type variable?
13:58:14 <monochrom> depends on context
13:58:28 <kamaji> I'll paste my function, heh
13:58:36 <monochrom> but perhaps there is no context
13:58:43 <kmc> kamaji, by default, type variables in one type signature are not related to type variables elsewhere
13:58:43 <monochrom> @type read x :: a
13:58:44 <lambdabot>     Couldn't match expected type `String' against inferred type `Expr'
13:58:44 <lambdabot>     In the first argument of `read', namely `x'
13:58:44 <lambdabot>     In the expression: read x :: a
13:58:51 <monochrom> it says no. thank you.
13:59:01 <kmc> but look into the ScopedTypeVariables extension
13:59:20 <hpaste_> kamaji pasted “CSV to matrix” at http://hpaste.org/50612
13:59:39 <kamaji> oh...
13:59:40 <monochrom> I should learn to not ask for context
13:59:49 <kamaji> wait.. i'm confused
14:00:29 <byorgey> kamaji: why do you need a type annotation at all?
14:00:49 <kamaji> fromLists only works with 'Element'
14:00:57 <kamaji> wait
14:01:19 <byorgey> I assume  fromLists :: [[a]] -> Matrix a
14:01:20 <monochrom> I believe [[a]] can be inferred
14:01:24 <kamaji> :|
14:01:29 <kamaji> damnit!!!!!
14:01:30 <kamaji> thanks :D
14:01:58 <kamaji> I'm guessing I still need (Element a, Read a) =>
14:02:00 <monochrom> > let { x :: a; x = x :: b } in const () x
14:02:01 <lambdabot>   ()
14:02:14 <mustelo> byorgey, so word on the street is you're a williams alum. you should come back and give a talk some time!
14:02:29 <monochrom> try to meditate on that example. ("surely 'a' is not 'b'?")
14:02:38 <byorgey> mustelo: it's true, and I'd love to =)
14:03:24 <mustelo> cool, I'll have my people contact your people.
14:03:33 <byorgey> hehe, excellent
14:04:27 <mm_freak> Cale: i'd be grateful for any pointer…  i works for pure wires, but not for monadic wires over Identity
14:04:53 <Cale> mm_freak: oh, hmm, maybe you need mfix?
14:05:04 <mm_freak> it appears to me that the code should perform exactly the same in both cases, but in the monadic case it diverges
14:05:11 <mm_freak> Cale: i'm using mfix
14:05:26 <mm_freak> instance MonadFix m => Wire m a b
14:06:11 <mm_freak> Cale: part of my problem is the signal inhibition…  i actually need to pattern-match against the result, which isn't the case in the simple yampa-style signal transformer
14:06:37 <mm_freak> perhaps i should also parameterize over the inhibition functor
14:07:15 <mm_freak> and allow ArrowLoop whenever the inhibition functor is a comonad
14:07:17 <mm_freak> that could work
14:07:59 <mm_freak> but i already have three type parameters =/
14:09:22 <mm_freak> Cale: do you get along without ArrowLoop?  it sounded to me that you don't have it either
14:09:29 <mm_freak> +like
14:09:46 <Cale> No, we have ArrowLoop, and we make good use of it
14:10:40 <Cale> (and when there are bugs, they can be a total bitch to find, but we've got some annotation devices using mapException which can be turned on to help at least)
14:10:49 <erytssiN> Can someone give me a hint for how to write sqrt in terms of foldr? (Not the whole solution, just a tip)
14:10:59 <erytssiN> I'm assuming it's possible
14:11:17 <erytssiN> also I'm using Newton's method
14:11:42 <dolio> Doesn't sound like a natural foldr situation to me.
14:11:44 <mauke> sqrt x = foldr return (sqrt x) []
14:11:47 <mm_freak> erytssiN: doesn't sound like a job for foldr
14:11:49 <erytssiN> :P
14:11:55 <erytssiN> mm_freak: can it be done with foldl' ?
14:11:59 <ciaranm> erytssiN: are you thinking of an infinite list of approximations or something?
14:12:01 <mm_freak> erytssiN: yes
14:12:08 <erytssiN> ciaranm: that's kind of what I had in mind
14:12:45 <glguy> mauke: that's one crazy looking implementation :)
14:12:56 <monochrom> if you want to get foldr or foldl' involved, first you have to pull a list out of the blue
14:13:34 <erytssiN> is there a way to make the next element in the list a new approximation?
14:13:47 <glguy> what about
14:13:49 <glguy> :t iterate
14:13:50 <lambdabot> forall a. (a -> a) -> a -> [a]
14:13:51 <glguy> or
14:13:53 <glguy> :t until
14:13:54 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
14:14:05 <erytssiN> those would probably work
14:14:06 <ciaranm> erytssiN: there is... but it's rather silly...
14:14:23 <erytssiN> ok, I'll just write it off as something not suited for a fold
14:14:44 <monochrom> I can only imagine one relevant list to be pulled out of the blue. the list of all numbers. so that you just sqrt n = filter (\x -> x*x == n) (list of all numbers), and filter is a foldr
14:14:47 <ciaranm> you could use a monad, if you're looking for a silly way of doing it
14:15:14 <erytssiN> monochrom: well, the solution I came up with is only good for finding the root of perfect squares :P
14:15:15 <hpaste_> reidc annotated “rng with mutex” with “simpler rng with mutex (annotation) (annotation)” at http://hpaste.org/50608#a50613
14:15:19 <erytssiN> since it uses an infinite list
14:15:43 <mauke> here's an implementation based on reverse ST: http://mauke.dyndns.org/stuff/haskell/posi.hs
14:15:58 <ClaudiusMaximus> :t unfoldr
14:15:59 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:16:21 <ciaranm> erytssiN: oh, have you considered using a zygohistomorphic prepromorphism rather than a fold?
14:16:39 <erytssiN> I have no idea what that is
14:16:46 <reidc> monochrom: I updated the code based on your suggestions, but I don't have it right. I'm getting the same value every time.
14:16:48 <ciaranm> your education is sorely lacking
14:16:55 <erytssiN> apparently
14:16:56 <roconnor> ciaranm: don't be mean
14:17:11 <ciaranm> roconnor: no, he wants sqrt, not mean
14:17:21 <dwaynecrooks> lol... wth
14:17:34 <monochrom> I am getting different values every time. perhaps you need to upload your whole computer for examination
14:17:50 <glguy> erytssiN: perhaps he means that you shouldn't be mean to the people who take "zygohistomorphic prepromorphisms" seriously?
14:18:09 <reidc> monochron: my "getRnd2" gives you a different value every time?
14:18:11 <roconnor> glguy: wrong target
14:18:16 <monochrom> yes
14:18:17 <glguy> quite
14:18:23 <glguy> ciaranm: ^
14:18:28 <erytssiN> ok, I looked it up on the haskell wiki
14:18:40 <monochrom> the only way to have the right target is to not specify any target
14:18:50 <reidc> monochron: different values in what range?
14:18:52 * roconnor doesn't like people misdirecting newbies with inside jokes.
14:18:59 <roconnor> it makes the channel unfriendly
14:19:03 <roconnor> I think
14:19:10 <mauke> erytssiN: http://haskell.org/haskellwiki/Real_World_#haskell
14:19:17 <monochrom> 0.9657801282592118, 5.53288736846298e-2, 0.8046464256476611
14:19:19 <roconnor> @get-shapr
14:19:20 <lambdabot> shapr!!
14:19:49 <monochrom> anyway, most algorithms are not folds of lists
14:20:15 <erytssiN> mauke: please say it exists
14:20:26 * glguy didn't actually know that that was a specific inside joke :)
14:20:40 <mauke> erytssiN: huh?
14:20:43 <monochrom> but there is a proof that every algorithm is a composition of a fold and an unfold of lists. (I forgot which order)
14:20:44 <erytssiN> the book
14:20:49 <ciaranm> aren't all algorithms folds of lists?
14:21:00 <ciaranm> (in an utterly pointless theoretical way)
14:21:01 <mauke> erytssiN: sadly no
14:21:08 <erytssiN> I was led to believe you could translate any recursive algorithm to a fold
14:21:22 <roconnor> heh, I was also thinking that most algorithms were folds of lists, like the one on my recent blog post.
14:21:26 <ciaranm> erytssiN: you probably can, but you probably shouldn't
14:21:29 <monochrom> no, even theoretically, you need unfold
14:21:31 <erytssiN> good point
14:21:31 <c_wraith> primitive recursive, anyway.
14:21:44 <Eduard_Munteanu> monochrom: that seems pretty obvious if you can (un)fold by an arbitrary function
14:21:44 <c_wraith> there are algorithms that aren't primitively recursive.
14:22:04 <c_wraith> That was the whole point of Ackerman's function.
14:22:15 <roconnor> arguably a Turing machine is a fold over time.
14:22:18 <glguy> enter lexicographic recursion
14:22:40 <monochrom> all the better if you find it obvious
14:23:16 <roconnor> foldr F [] (repeat ())
14:23:39 <reidc> monochron: I tried it on another computer (Ubuntu, ghci 6.12) and it worked.  Still doesn't work on the first computer (OS X, ghci 6.10).  Thanks for your help.
14:25:18 <Eduard_Munteanu> foldl algo input ()   :)
14:26:08 <Eduard_Munteanu> I'm unsure why you need the unfold though.
14:27:10 <monochrom> oh, nothing says unfold is the minimum requirement. just agree that fold is not enough and you need some help. you could say unfold is overkill, I'm fine with that.
14:27:37 <monochrom> but apparently no one cared enough to find a less powerful help
14:27:43 <Axman6> reidc: why are you using such ancient GHC's?
14:28:09 <Eduard_Munteanu> Oh, hrm, you kinda need to pre-arrange your input in some way I guess.
14:28:46 <monochrom> 6.10 is not ancient yet. I still have a copy of 4.something
14:28:57 <Eduard_Munteanu> My '()' there wasn't quite right.
14:29:16 <tech2> Axman6: 6.12 is the latest on the current ubuntu release. You may not like it but that's where many people will be starting.
14:29:19 <ciaranm> i heard a rumour that some people still use hugs
14:29:27 <Axman6> >_<
14:29:36 <monochrom> > "6.10" == "6.12"
14:29:36 <lambdabot>   False
14:29:45 <monochrom> computer is smarter than humans
14:30:08 <monochrom> or at least, computer is more literate than humans
14:30:19 <ciaranm> > "6.8" > "6.12"
14:30:19 <lambdabot>   True
14:30:24 <monochrom> haha
14:30:37 <ciaranm> the perl guys used to version stuff that way
14:30:44 <ciaranm> highly annoying
14:31:04 <mauke> ciaranm: [citation needed]
14:31:13 <monochrom> haha
14:31:57 <ciaranm> mauke: if you really want, i've got a (hopefully) complete description of the insane clusterfuck that is perl and cpan versioning somewhere
14:31:58 <glguy> People still use Hugs because (unless this changed recently) it can check some properties of functional dependencies that GHC can't
14:32:31 <mauke> the perl version is a number. it gets bigger.
14:32:33 <monochrom> some teachers still instruct students to use hugs
14:32:50 <ciaranm> mauke: *historically* perl versions (and cpan versions) were strings, compared lexicographically
14:33:00 <mauke> ciaranm: I don't believe that
14:33:01 <ciaranm> mauke: there are still packages in cpan versioned that way
14:33:17 <ciaranm> (so cpan versions aren't totally ordered)
14:33:37 <monochrom> (then again it's the same phenomenon as: some teachers haven't caught up on the changes in the last 10 years in the haskell community)
14:35:35 <ciaranm> mauke: http://www.cpan.org/misc/cpan-faq.html#What_versions_mean is when they fixed it for perl itself. if you want examples of things using the old rules, i believe eternaleye has a complete list
14:35:42 <Eduard_Munteanu> Presumably they don't really teach much Haskell.
14:35:49 * cmccann recalls learning "C++" from several teachers who hadn't really caught up on changes like the existence of the STL, or it not being the same as C, or in one teacher's case it not being the same as Pascal
14:36:04 <Eduard_Munteanu> And I hear hugs has friendlier error messages, at least in some regards, if I'm not mistaken.
14:36:22 <erytssiN> Eduard_Munteanu: that alone is a good reason to use it for learning
14:36:25 <ciaranm> mauke: also see http://search.cpan.org/~jpeacock/version-0.94/lib/version.pod
14:36:48 <mauke> ciaranm: that's not a "fix" and it doesn't change the internal API
14:36:48 <maltem> hugs is nice for students who want a quick install on Windows
14:37:00 <elliott> C++ is the best Pascal compiler, cmccann.
14:37:09 <mauke> ciaranm: it's just a different formatting of the same internal version number
14:37:21 <mauke> seriously, what would that even "fix"?
14:37:31 <erytssiN> but, I'm starting to like GHC's error messages more. They tell you what the actual problem is, although you might not understand what it means at first.
14:37:43 <elliott> maltem: the haskell platform is not quick to install?
14:37:53 <cmccann> my impression is that GHC's errors used to be far more cryptic than they are now
14:37:59 <Eduard_Munteanu> It's a lot bigger though.
14:38:00 <ciaranm> mauke: if you have two cpan packages versioned 1.2 and 1.21 , there is no way of knowing purely from that which is the newer version
14:38:02 <erytssiN> I installed it in < 5 minutes on my friend's windows 7 laptop
14:38:03 <mauke> ciaranm: yeah, version.pm is about the semi-fucked up vstrings/version object/whatever stuff
14:38:17 <erytssiN> GHC that is
14:38:29 <Eduard_Munteanu> And you don't get an IDE.
14:38:40 <mauke> ciaranm: I'd say 1.21 is newer. who disagrees?
14:38:41 <elliott> is the hugs ide actually nice at all
14:38:42 <ciaranm> uh, do i mean 1.2 and 1.21? or 1.3 and 1.21?
14:38:43 <elliott> i find that relaly hard to believe
14:38:52 <cmccann> also, I've never had trouble installing GHC etc. on Windows. installing FFI bindings to almost anything can be tricky though.
14:38:52 <erytssiN> why do you need an IDE for haskell?
14:38:56 <ciaranm> mauke: i think i mean 1.3 and 1.21
14:39:01 <Eduard_Munteanu> (For the record, I'm not advocating Hugs, just thinking of reasons they'd choose it)
14:39:02 <maltem> elliott, no idea, but a non-haskeller friend of mine was happy with hugs for a Haskell course
14:39:10 <mauke> ciaranm: 1.3 > 1.21
14:39:42 <ciaranm> mauke: perl used to think so. it no longer does, if you're using the new format, and pretty much everyone not perl thinks 1.21 > 1.3
14:39:56 <ciaranm> but some of cpan still uses the old format
14:40:02 <mauke> ciaranm: what new format?
14:40:19 <ciaranm> mauke: the one that usually has a v prefix
14:40:24 <mauke> that's not a number
14:40:37 <mauke> also, does anyone actually use that for module versions?
14:40:46 <ciaranm> everyone is *supposed* to now
14:40:49 <mauke> perl itself still uses floating-point numbers
14:41:02 <mauke> ciaranm: that would surprise me *a lot*
14:41:26 <ciaranm> perl's version is now officially 5.14.1, not 5.014001
14:41:54 <mauke> [citation needed]
14:41:59 <ciaranm> perl.org
14:42:04 <tech2> ciaranm: perl6 ever coming out?
14:42:22 <ciaranm> tech2: http://www.learningperl6.com/ is your answer to that...
14:42:24 <elliott> tech2: It's out-ish.
14:42:40 <tech2> heh
14:42:43 <mauke> ciaranm: I don't see anything saying 5.014001 is "wrong" now
14:43:02 <iwtu> Hi. I need a little help. I want to programming Aho-Corasick algorithm. I think I can make a trie but I wanto to test it now. So I decised to write down the whole string in trie. Not sure if understand but i should be line 38 http://codepad.org/xkDSO5VP
14:43:09 <mauke> $] still exists and will do so for a long time
14:43:32 <ciaranm> mauke: but it's no longer the canonical representation
14:43:44 <mauke> ciaranm: [citation needed]
14:44:03 <ciaranm> mauke: perl.org, front page, where it tells you the current version
14:44:11 <iwtu> hope it's clear what I need but I don't know how to write it in Haskell
14:44:17 <mauke> ciaranm: that's fluff
14:44:36 <mauke> ciaranm: or rather, a nice looking representation of 5.014_001 for end users
14:45:05 <shachaf> According to `perl -V`, I have "perl5 (revision 5 version 10 subversion 1)".
14:45:19 <shachaf> I have no idea how it's represented, though.
14:45:29 <mauke> shachaf: yes, the first three digits after the decimal point are the version, etc
14:45:53 <glguy> Wikipedia states that "When developing Perl 5.6, the decision was made to switch the versioning scheme to one more similar to other open source projects; after 5.005_63, the next version became 5.5.640, with plans for development versions to have odd numbers and stable versions to have even numbers."
14:45:54 <glguy> This doesn't prove that this is true but gives us a point in time that the change may well have happened.
14:46:42 <mauke> I see 5.6.0 and 5.006 as interchangeable as far as perl versions are concerned
14:47:08 <ciaranm> for perl itself they are, since unlike cpan modules, perl has restricted itself to just a possible single letter suffix
14:47:33 <mauke> if you want to check the perl version from perl code, you've basically got two choices: $] (works everywhere) and $^V (works on perls >= 5.6.0 but differently after 5.10.0)
14:48:14 <roconnor> what happened with pugs and audrey?
14:48:21 <monochrom> well, apparently, codepad.org still uses hugs, that's a major user :)
14:48:34 <iwtu> so I need recursion function which will travel trough whole trie :)
14:49:28 * hackagebot pcap-enumerator 0.1 - Convert a pcap into an enumerator.  http://hackage.haskell.org/package/pcap-enumerator-0.1 (KatsutoshiItoh)
14:50:13 * edwardk waves hello.
14:51:19 <elliott> <roconnor> what happened with pugs and audrey?
14:51:26 <luite> does anyone know who the admin of the servers that builds the haddock for hackage is?
14:51:27 <elliott> surprisingly the Pugs package was last updated this May...
14:51:29 <shachaf> @ohai edwardk
14:51:30 <lambdabot> edwardk!!
14:51:31 <elliott> I thought it was totally unmaintained
14:51:38 <edwardk> heya shachaf
14:51:57 <elliott> monochrom: looks like it: http://codepad.org/R6pcif0R
14:52:03 <edwardk> elliott: audrey went away for a while due to medical problems, and only recently got reinvolved with it
14:52:17 <shachaf> edwardk: How are the strong lax semimonoidal endofunctors?
14:52:30 <edwardk> in the meantime while she was out of condition, not much happened with it
14:52:41 <dolio> roconnor: Oh, I almost forgot. It occurred to me yesterday that you've given a good reason for calling IO 'the IO monad.'
14:52:56 <roconnor> I have?
14:53:00 <edwardk> shachaf: happily packaged up and on hackage =P
14:53:00 <dolio> Yes.
14:53:03 <roconnor> w00t
14:53:18 <shachaf> edwardk: What's your preferred domain name?
14:53:23 <dolio> Because I/O is properly described by the initial algebra of whatever functor.
14:53:24 <roconnor> edwardk: oh, is she better now?
14:53:32 <dolio> And IO is actually the free monad of the same functor, obviously.
14:53:41 <roconnor> dolio: yep
14:53:45 * edwardk arches an eyebrow.
14:53:46 <roconnor> it seems that way
14:53:54 <roconnor> edwardk: disagrees
14:54:02 <roconnor> s/://
14:54:04 <jamwt> all, if I'm doing some heap profling and I have some sat_XXXX references, any pointers on how to track down what that might be?
14:54:44 <edwardk> shachaf: i use comonad.com for most
14:54:52 <edwardk> shachaf: i have about 50 others though
14:55:18 <shachaf> @where edwardk
14:55:18 <lambdabot> http://slipwave.info/
14:55:24 <roconnor> dolio: shall we now make the type of main :: IO Void?
14:55:58 <edwardk> shachaf: so i'm not entirely sure of the context you meant that in
14:56:17 <elliott> roconnor: that hurts me a bit because sometimes I like to pretend that _|_ does not exist
14:56:29 <edwardk> shachaf: that is ancient
14:56:36 <dolio> roconnor: Is there a 'halt' instruction in the standard library that would allow that?
14:56:49 <roconnor> dolio: we would have to retype exitWith
14:56:51 <dolio> I don't remember if exitWith is standard.
14:56:52 <roconnor> @type exitWith
14:56:54 <lambdabot> Not in scope: `exitWith'
14:56:57 <roconnor> @hoogle exitWith
14:56:58 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
14:57:11 <roconnor> oh
14:57:13 <roconnor> that type isn't so bad
14:57:15 <coppro> win 2
14:57:31 <elliott> ?hoogle exitSuccess
14:57:31 <lambdabot> System.Exit exitSuccess :: IO a
14:57:31 <lambdabot> System.Exit ExitSuccess :: ExitCode
14:57:46 <dolio> Oh, even better.
14:57:51 <roconnor> dolio: exitWith is in the Haskell 98 report
14:57:59 <dolio> Okay.
14:58:01 <iwtu> anyone with any idea? :)
14:58:14 <roconnor> exitSuccess isn't
14:58:27 <dolio> Ah well.
14:58:50 <roconnor> elliott: I also pretend that _|_ doesn't exist, which is exactly why I want to use IO Void
14:59:12 <edwardk> shachaf: slipwave.info was part of a little side project I abandoned around the time I discovered Haskell.
14:59:13 <edwardk> hah some ancient content is apparently there: http://slipwave.info/tiddly.php
14:59:14 <elliott> roconnor: fair enough, I was thinking in terms of "return undefined"
14:59:24 <roconnor> elliott: yep
14:59:34 <roconnor> elliott: the proper way of terminating a program is exitWith
14:59:52 <mauke> foreign import "stdlib.h exit"
14:59:53 <roconnor> main = return undefined would throw an exception (and then halt)
15:00:09 <mauke> main = return main
15:00:19 <roconnor> mauke: not well typed
15:00:35 <zzing> Does anyone know if the issues with ghc and lion have been fixed yet in either a release or in trunk?
15:00:35 <roconnor> mauke: try forever return
15:00:44 <roconnor> er
15:00:51 <hpc> :t forever
15:00:51 <roconnor> forever (return ())
15:00:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
15:01:12 <roconnor> or simply main = main
15:01:31 <hpc> main = unsafeCoerce unsafeCoerce
15:01:52 <mauke> hpc: now you're thinking with portals
15:02:08 <mauke> let alone = return () in forever alone
15:02:27 <elliott> unsafeCoerce is definitely the most versatile function Haskell has to offer
15:02:38 <roconnor> elliott: it isn't Haskell
15:02:46 <elliott> roconnor: Well, it's Haskell+FFI.
15:02:52 <roconnor> pffft
15:02:53 <roconnor> FFI
15:03:00 <incluye> "converts any type to any other type"
15:03:01 <incluye> well well
15:03:13 <elliott> incluye: s/converts/coerces/, s/the rest of it/a value of any type to any other type/
15:03:18 <roconnor> unsafeCoerce isn't even safe
15:03:21 <elliott> s/all of that/does something unpredictable unless you're a wizard/
15:03:27 <elliott> ?remember roconnor unsafeCoerce isn't even safe
15:03:28 <lambdabot> I will never forget.
15:03:38 <incluye> it says unsafeCoerce
15:03:43 <incluye> i figure it coerces unsafely
15:03:48 <elliott> roconnor: safeCoerce :: a -> a
15:03:56 <elliott> safeCoerce = unsafeCoerce -- optimised implementation
15:04:14 <roconnor> isn't there some sort of safeCoerce :: (a ~ b) => a -> b
15:04:20 <roconnor> how do those ~'s work?
15:04:28 <incluye> fuckin tildes
15:04:35 <incluye> what is their significance
15:04:39 <mauke> roconnor: cast
15:04:40 <edwardk> roconnor: yeah, you can just write it though, safeCoerce x = x
15:04:43 <roconnor> something about type families
15:05:12 <edwardk> roconnor: they become 0-byte witnesses of type equality that get passed around like all the other constraints
15:05:35 <roconnor> edwardk: they are still erased at runtime right?
15:05:38 <Guest29455> it is just me or the right toolbar on leksah dont go to the bottom?
15:06:13 <elliott> roconnor: Wouldn't it be awful if those 0-byte witnesses weren't erased?
15:06:19 <roconnor> yes!
15:06:23 <elliott> if you had a billion of them, they'd take up a whole 0 terabytes
15:06:26 <ciaranm> i see what you did there
15:06:37 <roconnor> elliott: totally unacceptable overhead
15:06:49 <elliott> might want to unbox them
15:07:06 <edwardk> roconnor: all but, i think they still infect the type signature at the STG level, but as a 0 byte object, like when passing State# RealWorld
15:07:06 <edwardk> so no registers are harmed, etc.
15:07:07 <jutaro> Guest29455: Where is a right toolbar with leksah?
15:07:10 <zygoloid_> roconnor: (a ~ b) => a -> b  is the same type as  a -> a.
15:07:22 <int80_h> @hoohle writeFile
15:07:22 <lambdabot> Prelude writeFile :: FilePath -> String -> IO ()
15:07:23 <lambdabot> Data.ByteString writeFile :: FilePath -> ByteString -> IO ()
15:07:23 <lambdabot> System.IO writeFile :: FilePath -> String -> IO ()
15:07:29 <edwardk> they mostly just mess with principal types/typings
15:07:38 <roconnor> zygoloid_: I'm just impressed that I mananged to make it well typed
15:07:52 <jutaro> The toolbar goes away with Ctrl-T , but no way to move it to the bottom.
15:08:18 <elliott> I've used "instance (a ~ T) => Foo (S a) where ..." before I think
15:08:26 <elliott> I forget how it helped, I think it disambiguated things
15:08:55 <cmccann> elliott, it can let you make the instance head more generic while still requiring the same types
15:09:02 <elliott> right
15:09:15 <elliott> I guess what happens there is that any (S t) context is handled by that instance
15:09:16 <cmccann> which means that in some circumstances, instead of failing on polymorphic types it will unify them
15:09:20 <elliott> and it just fails if (a ~/~ T)
15:09:51 <cmccann> basically a cheap way to delay certain constraints on an instance until after instance selection is done
15:10:01 <cmccann> just like Oleg's TypeCast hack
15:11:30 <ddarius> That instance declaration should make S T the only allowable instance of Foo.
15:11:39 <elliott> Really?
15:11:53 <elliott> Oh, here it is: instance (IsString s, Monoid s, r ~ a) => IsString (Format s r a)
15:12:06 <cmccann> the only instance with S as the outermost type constructor, at least
15:12:39 <elliott> cmccann: well, yeah, of course
15:12:47 <elliott> not quite the same thing as only allowable instance
15:13:20 <ddarius> elliott: Er, it would make S T the only allowable instance of Foo of the form S a.
15:13:40 <elliott> ddarius: Right.
15:13:44 <elliott> That's the desired effect.
15:14:12 <cmccann> generally the desired effect is that ambiguous instances of the form (S a) will be inferred as (S T)
15:14:24 <cmccann> which is not the same as what you'd get with just "instance (S T)" obviously
15:14:38 <cmccann> but if you intend (S T) as the only instance of that form, it's helpful
15:15:56 <cmccann> it's a useful way of holding GHC's hand in getting through certain kinds of type-level shenanigans
15:16:09 <elliott> ?pl \k x -> f (\s -> g (\t -> k (s . t)) x) x
15:16:10 <lambdabot> join . (f .) . flip . (g .) . (. (.)) . (.)
15:16:12 <elliott> ah
15:16:55 <Guest29455> jutaro on the  right side, I guess
15:17:18 <Guest29455> for me it shows logs and errors
15:18:00 <jutaro> Ok, you mean the log pane
15:18:01 <cmccann> elliott, well on the bright side @pl didn't make that function significantly harder to read than it already was
15:18:17 <elliott> cmccann: I don't want to know how long it took me to work that one out
15:18:47 <jutaro> You have to switch TabsOn, and then you can drag it to another position.
15:18:57 <cmccann> elliott, what, to figure out the original you fed to @pl? That's the sort of thing you should just feed to djinn
15:19:05 <elliott> ?djinn (((s -> s) -> a) -> (b -> c)) -> (((s -> s) -> c) -> (b -> a)) -> (((s -> s) -> c) -> (b -> c))
15:19:06 <lambdabot> f a b c d = a (\ _ -> b (\ _ -> c (\ e -> e)) d) d
15:19:09 <cmccann> if you're writing a function like that you probably already know the type
15:19:12 <elliott> not helpful, lambdabot
15:19:22 <cmccann> heh
15:19:26 <jutaro> The tricky part is, that you first have to select the pane, which you can see in the status bar
15:19:40 <cmccann> I think actually running djinn gives you more control that lambdabot's command
15:19:41 <elliott> infixr 0 %&
15:19:41 <elliott> (%&) :: Format s a (b -> c) -> Format s c (b -> a) -> Format s c (b -> c)
15:19:41 <elliott> Format f %& Format g = Format $ \k x -> f (\s -> g (\t -> k (s . t)) x) x
15:19:41 <elliott> I'm just going to assume it made sense at th etime
15:19:45 <elliott> although that type reminds me of (>=>)
15:20:25 <ddarius> It makes sense in this context.
15:20:25 <cmccann> :t liftA2 (.)
15:20:26 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
15:20:58 <cmccann> ok, that would have made more sense with a sensible (.)
15:21:14 <elliott> heh
15:21:44 <cmccann> but the other parameters make that not work directly anyhow, so eh
15:22:08 <zzing> Is there a way in cabal to get the list of packages that can be upgraded? (like the old 'cabal upgrade')
15:41:58 <AshtonK> Damn registered nicknames.
15:42:52 <Boxo> "import Control.Monad.Random" gives an error even though there's this http://hackage.haskell.org/packages/archive/MonadRandom/0.1.3/doc/html/Control-Monad-Random.html#1
15:42:59 <Boxo> how do I import it?
15:43:36 <Boxo> nvm
15:45:05 <Boxo> thought that was standard library documentation insted of hackage :D
15:47:22 <lispy> zzing: I think someone made a utility for that...trying to remember the name
15:47:38 <lispy> zzing: IIRC, it was based on cabal-dev
15:48:42 <lispy> zzing: ah, here it is: http://hackage.haskell.org/package/cab
15:50:22 <gwern> > 1835 * 1604
15:50:23 <lambdabot>   2943340
15:52:08 <incluye> > Just 3 >>= (Just . (+1))
15:52:10 <lambdabot>   Just 4
15:52:45 <djahandarie> > fmap (+1) (Just 3)
15:52:45 <lambdabot>   Just 4
15:52:54 <incluye> oh
15:53:12 <zzing> lispy: merci
15:53:31 <ddarius> > Just 4
15:53:32 <lambdabot>   Just 4
15:53:53 <incluye> > fmap (+1) (Just 4)
15:53:54 <lambdabot>   Just 5
16:17:42 <incluye> so in a type declaration for a function I know you have to specify what values a Map holds
16:17:47 <incluye> but I am not sure what the syntax is
16:17:50 <incluye> for that
16:18:12 * incluye n00b
16:18:14 <permagreen> (a->b) I believe
16:18:34 <permagreen> Although I'm not exactly sure what you mean
16:18:46 <cmccann> if you mean Map from Data.Map, it's just "Map k v" where k and v are the key and value types
16:18:56 <incluye> God I can't believe I forgot that
16:18:58 <incluye> thanks
16:19:15 <cmccann> e.g. "Map String Float" for a map from strings to floats
16:19:40 <incluye> cmccann: that's it
16:20:01 <cmccann> anyway, typing :i Data.Map.Map or whatever in GHCi can often be informative, or :browse Data.Map to see what's in the module
16:20:17 <cmccann> often the names of the functions plus their types will give you enough to figure out what's what
16:21:10 <cmccann> e.g. "lookup :: Ord k => k -> Map k a -> Maybe a" is fairly self-explanatory once you're used to interpreting type signatures
16:21:17 <cmccann> though it takes some practice to get fluent with it
16:22:32 <ion> void *lookup (void *key, map_t map)
16:23:05 <ddarius> lookup/3
16:23:11 <ion> heh
16:24:33 <accel> has anyone wrtitten a tutorial on writing a J/K/APL interpreter in haskell?
16:25:15 <ddarius> I don't think so.
16:25:32 <ddarius> It might be fun to do with Repa.
16:28:17 <VHD> hello, could anyone explain this type. somef :: a -> [a->a] -> a, more specifically the [a->a] is what is confusing me.
16:28:31 <glguy> That's a list of functions from a to a
16:28:38 <ciaranm> VHD: do you know what a->a is?
16:28:43 <VHD> ciaranm, yes
16:28:51 <ciaranm> VHD: do you know what [Monkey] is?
16:28:55 <VHD> yes
16:29:05 <ciaranm> then put them together
16:29:12 <glguy> monkey functions?
16:29:13 <incluye> it's a list of functions?
16:29:23 <incluye> brutal
16:29:25 <VHD> :o i get it now.
16:29:28 <VHD> thank you.
16:29:31 <ddarius> The free monoid over endofunctions.
16:29:33 <cmccann> :t (+) <$> [0..5]
16:29:35 <lambdabot> forall a. (Num a, Enum a) => [a -> a]
16:29:54 <incluye> oh man that <$> thing confuses me
16:29:54 <cmccann> :t foldr (.) id ((+) <$> [0..5])
16:29:55 <lambdabot> forall b. (Num b, Enum b) => b -> b
16:29:56 <benmachine> :t [id, reverse, drop 3]
16:29:58 <lambdabot> forall a. [[a] -> [a]]
16:29:59 <VHD> I though functions had to have brackets around them.
16:30:01 <cmccann> > foldr (.) id ((+) <$> [0..5]) 0
16:30:01 <incluye> plus, it's /completely/ un google-able
16:30:03 <lambdabot>   15
16:30:03 <glguy> :t (+).[0..5]
16:30:04 <lambdabot> forall a. (Num a, Enum a) => [a -> a]
16:30:11 <cmccann> incluye, it's fmap, sorry
16:30:17 <cmccann> which in this case is just map
16:30:22 <incluye> <$> is the same as fmap?
16:30:24 <ddarius> :t (<$>) -- says everything
16:30:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:30:30 <benmachine> VHD: what do you mean?
16:30:32 <ddarius> @src (<$>)
16:30:32 <lambdabot> f <$> a = fmap f a
16:30:33 <cmccann> I use it because infix style is tidier in many cases
16:30:37 <incluye> ohhh
16:30:41 <incluye> so it's just like $
16:31:15 <VHD> benmachine, I mean I would have expected this instead somef :: a -> [(a->a)] -> a
16:31:23 <incluye> where is that <$> found
16:31:29 <glguy> Control.Applicative
16:31:30 <cmccann> incluye, you can think of fmap as ($) for Functor instances, so yeah
16:31:36 <cmccann> :i (<$>)
16:31:37 <benmachine> VHD: ah, well, square brackets do the job of parentheses
16:31:38 <VHD> but I forgot about the theory of currying, so nevermind
16:31:42 <cmccann> bah
16:31:43 <incluye> I better really figure out what Functor is
16:31:49 <glguy> ?index (<$>)
16:31:49 <lambdabot> bzzt
16:31:59 <incluye> trying to understand haskell is like taking an advanced math class
16:31:59 <ddarius> @src Functor
16:32:00 <lambdabot> class  Functor f  where
16:32:00 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
16:32:20 <cmccann> incluye, if something is an instance of Functor, it means that you can use fmap on it
16:32:29 <cmccann> :t fmap
16:32:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:32:31 <glguy> incluye: Especially if you try to understand it via #haskell
16:32:35 <cmccann> there really isn't much else to say about it
16:32:46 <incluye> oh, okay
16:32:47 <ddarius> VHD: It has nothing to do with currying.
16:32:57 <ciaranm> VHD: it's not about currying. you only need ()s around a->b when it would be parsed the wrong way otherwise.
16:33:02 <incluye> also ghci is telling me not in scope <$> so what do I import
16:33:13 <cmccann> incluye, Control.Applicative
16:33:21 <incluye> much obliged
16:33:42 <cmccann> actually I think it's defined somewhere else, but I always import Applicative regardless
16:34:01 <VHD> well from what I understand (and that may be wrong) I think it does. Since each -> means a function.
16:34:23 <incluye> no it's applicative
16:34:43 <ciaranm> VHD: Monkey -> Banana is the type of a function, not a function
16:34:43 <cmccann> incluye, Control.Applicative re-exports (<$>) is what I meant
16:35:00 <cmccann> the definition is somewhere else, specifically Data.Functor
16:35:16 <ciaranm> Control.Applicative and Control.Monad.Instances should be imported automagically by your text editor whenever you create a new .hs file
16:37:24 * cmccann also likes to import Category, Foldable, etc. and hide the clashing Prelude names
16:37:34 <ddarius> edwardk: You and Amy want to walk to Davis Square and get a burger?
16:37:35 <cmccann> I also sometimes rename things from the Prelude because I feel like it
16:38:01 <ddarius> import Prelude hiding (.); x.f = f x
16:38:13 <cmccann> ddarius, oh god no
16:38:27 <ddarius> You're right.
16:38:33 <ddarius> import Prelude hiding ((.))
16:38:34 <cmccann> that's from the one guy's crazy alternate prelude, isn't it?
16:38:40 <ion> Control.Applicative already imports Control.Monad.Instances.
16:38:50 <elliott> (.) should be lens access or something :P
16:38:57 <ciaranm> it's not possible to get ; for backwards composition, is it?
16:39:01 <cmccann> :t (.)
16:39:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:39:05 <ddarius> ciaranm: It's not an operator.
16:39:06 <elliott> hmm, I guess (.) should be flipped category composition then
16:39:07 <MichaelBurge> If I have a list of Writers each wrapping a list of objects, how do you concatenate them into a single Writer wrapping a list of concatenated objects?
16:39:13 <glguy> ddarius: you prefer the ∘ for composition?
16:39:26 <elliott> (∘) is nice but unfortunately not very typeable
16:39:32 <cmccann> but yeah, I prefer using (.) from Category
16:39:33 <ddarius> glguy: That would be too much of a hassle to type.
16:39:49 <glguy> In agda-mode it's just \o iirc
16:39:50 <shachaf> There's always "o".
16:39:58 <cmccann> I also have shortcuts in my editor to insert lots of unicode rubbish to ensure that noone else can do anything at all with my code
16:39:59 <ddarius> glguy: Which is already more than ..
16:40:30 * ddarius just applies chaffing and winnowing too his public source repositories.
16:40:39 <ciaranm> unicode snowman time!
16:40:42 <glguy> Typing speed was never my limiting factor :)
16:40:54 <ddarius> glguy: Who said anything about speed?
16:41:11 <glguy> I did, clearly
16:41:26 * cmccann particularly enjoys doing "type ℤ = Integer" and then putting that in type signatures everywhere
16:41:39 <elliott> :(
16:41:58 <ion> With ibus-table-latex, ctrl-space \circ space ctrl-space, which is still a hassle. No nice compose key combinations for ∘ either by default.
16:42:24 <cmccann> if I'm feeling particularly cruel, I'll use (×) as a replacement for (*)
16:42:44 <ion> or ·… or both. ;-)
16:42:50 <ciaranm> the cartesian cross should be a replacement for -> , clearly
16:43:03 <cmccann> usually can't be bothered to do (∘) for composition though, I'd get tired of hitting the replacement shortcut key :[
16:43:21 <cmccann> no, my editor replaces -> with →
16:43:34 <ion> → is easy enough: compose - >
16:43:45 <ddarius> instance Num a => Num (a -> a) where fromInteger = (*)
16:43:53 <ion> ddarius: hehe
16:43:56 <glguy> in agda-mode \r is →
16:44:20 * cmccann uses SciTE for what it's worth
16:44:39 <ddarius> I guess that would be fromInteger = (*) . fromInteger
16:45:01 <cmccann> hitting ctrl-B does replacements on whatever is behind the cursor, based on a huge file full of "abbreviations" I have
16:45:32 <ddarius> cmccann: Make a batch version.
16:45:48 <ddarius> Or is that what "behind the cursor" means.
16:46:03 <elliott> we should use subscripts as flipped function arrows.
16:46:03 <monochrom> with the right "abbreviations", you could turn ctrl-B into a lambda calculus evaluator :)
16:46:08 <elliott> finally haskell is accessible to set theorists.
16:46:09 <edwardk> ddarius: amy looked over and groaned (she had had a five guys burger about an hour ago), but i'm game
16:46:11 <cmccann> ddarius, it means that I type something like ->, hit ctrl-B, and it replaces it with the unicode version
16:46:58 <ddarius> cmccann: I'm suggesting something that will do it for everything in the file at once.
16:47:14 <cmccann> ddarius, yes, I figured. it doesn't do that.
16:47:32 <cmccann> I could write something that did, but that seems rather frivolous.
16:47:33 <monochrom> people don't like batch processing. they prefer interactive
16:47:36 <edwardk> ddarius: should i wander up that way and rap on your door? or you want to swing by and kidnap me?
16:48:04 <ddarius> The former is more sensible.
16:48:20 <edwardk> hrmm, my phone is almost dead so i may not be able to contact you at the end of the trip
16:48:27 <cmccann> maybe someday when I can legitimately write type signatures like (a ⊗ b ⊸ c ⅋ ?d) then I'll consider something more effective
16:48:34 <ddarius> monochrom: Yes, but then this would be once a line or whenever you have a break rather than every character.
16:48:46 <yretssin> monochrom: remember that square root thing I was discussing earlier?
16:48:47 <edwardk> heading out the door. be there in a few
16:48:47 <ddarius> monochrom: But I agree that it just substituting without prompting would be a nicer feel.
16:48:48 <yretssin> http://codepad.org/gprInC1V
16:49:17 <ddarius> cmccann: -Classical- linear logic?  What's wrong with you?
16:49:28 <monochrom> nice yretssin
16:49:30 <cmccann> haha
16:49:39 <yretssin> oops I put an _ in there
16:49:43 <yretssin> but yeah
16:49:57 <yretssin> I can just do take 6 $ infsqr n
16:50:04 <yretssin> and get a nice list of approximations
16:50:33 * ddarius defined Newton-Raphson sqrt in high school CS class.  The termination condition was when old == new.
16:51:05 <ddarius> (The problem was to make some noddy program for calculating distances and areas.)
16:53:03 <Nisstyre> so yeah, that is a good use of unfoldr I think
16:53:11 <ddarius> Nisstyre: It is.
16:53:26 <Johannes`> hi, how do i infinitely run a main loop in a 2-second interval?
16:53:58 <monochrom> the same way I solve the halting problem in 1 day
16:53:59 <shachaf> You can only run it finitely in a 2-second interval.
16:54:01 <ddarius> forever (main >> waitTwoSeconds)
16:54:04 <glguy> Prelude Control.Concurrent> :t threadDelay
16:54:05 <glguy> threadDelay :: Int -> IO ()
16:54:26 <cmccann> ddarius, anyway, is it just the ? on the right of the implication that bothers you? or do you prefer some more restricted subset of linear logic.
16:54:55 <shachaf> Using threadDelay might be an issue if main takes a significant time to run (e.g. 1.5 seconds).
16:55:20 <monochrom> forever (forkIO main >> wait two seconds)
16:55:22 <Johannes`> ddarius: thanks
16:55:39 <VHD> is everything in haskell a function? e.g is 5 a function? more explicitly, are data also functions?
16:55:46 <ddarius> The ⅋ is not usually well behaved/defined in intuitionistic logics.
16:55:47 <shachaf> VHD: No.
16:55:55 <VHD> shachaf, hmm ok. thank you.
16:56:06 <monochrom> True is not a function
16:56:07 <shachaf> VHD: Things with a type of something -> something are functions.
16:56:21 <cmccann> depending on how you look at, polymorphic values are also functions
16:56:27 <shachaf> Other things are just called values.
16:56:34 <VHD> but isnt somef :: Int; somef = 10, also a function?
16:56:36 <cmccann> so (5 :: Int) is not a function but (5 :: Num a => a) could be
16:56:45 <shachaf> cmccann: Well, I'll say that it depends on how you look at "=>". If you look at it as a "->", then yes. :-)
16:56:48 <monochrom> no, somef is not a function
16:57:37 <VHD> hmm ok, what would somef be classified as?
16:57:45 <monochrom> value
16:57:51 <cmccann> VHD, an Int
16:58:05 <monochrom> (\x -> x) is also a value
16:58:08 * shachaf wonders why people hate the word "value" so much that they want to assign "function" to everything.
16:58:34 <VHD> I dont hate the word value.
16:58:39 <roconnor> what is ddarius's day job?
16:59:09 <monochrom> isn't that a bit personal? :)
16:59:23 <roconnor> possibly
16:59:26 <Cale> VHD: It's not a function because it has no parameters
16:59:32 <shachaf> dankna: See? See?
16:59:46 <roconnor> but I want to be like him
16:59:56 <shachaf> Everyone wants to be like ddarius.
17:00:29 <roconnor> shachaf: FWIW, I like the word value now
17:00:30 <monochrom> I think programmers (those affected by the C background) don't hate "value", they just love "function" too much, i.e., even procedures are called functions.
17:00:48 <MichaelBurge> Is there a way to reduce Functor [Functor [a]] to a Functor [a]? I'm using the Writer monad.
17:00:49 <cmccann> ddarius, ok. I don't see what the problem with ⅋ would be off the top of my head, though. any particular references you know of?
17:00:59 <shachaf> monochrom++
17:00:59 <glguy> Can we consider "10 :: Num a => a" to be a function (at least one from types to values?)
17:01:11 <ddarius> > 10 10
17:01:12 <lambdabot>   10
17:01:25 <cmccann> monochrom, we should start telling people that "in haskell all functions are functions."
17:01:33 <monochrom> haha
17:01:38 <dankna> shachaf: wait what?
17:01:43 <shachaf> cmccann: So what you're saying is, everything is a function?
17:02:00 <shachaf> dankna: <roconnor> what is ddarius's day job? <monochrom> isn't that a bit personal? :)
17:02:24 <shachaf> MichaelBurge: What does "Functor [Functor [a]]" mean?
17:02:33 <cmccann> monochrom, the bonus being that if you read that as "all (haskell) functions are (mathematical) functions" it actually says something interesting
17:02:34 <ddarius> cmccann: I'm not sure of a reference off the top of my head that shows the problems with ⅋.  Plenty on fragments of linear logic though.
17:02:35 <dankna> well, I think it's more personal if asked to a third party, actually
17:02:43 <dankna> but I certainly don't mind answering the question for myself
17:03:49 <roconnor> dankna: okay, what is ddarius's day job?
17:04:00 <MichaelBurge> It probably doesn't mean anything. I have "type EventLog a = Writer [EventRecord] a ", and now have a value of type "EventLog [EventLog [a]]" that I want to get a "EventLog [a]" out of.
17:04:03 <roconnor> :)
17:04:09 <dankna> LEFT CHANNEL
17:04:24 <dankna> STEREO!
17:05:06 <shachaf> MichaelBurge: That's a bit of an odd type to have.
17:05:20 <shachaf> Anyway, you can't do very much with Functor, but you can probably do what you want with Monad.
17:05:20 <bambanx> hello
17:05:30 <shachaf> See e.g. sequence and join. Depending on the actual behavior you're after.
17:05:36 <shachaf> Greetings, bambanx!
17:05:49 <bambanx> guys for what is used this language?
17:05:53 <monochrom> Writer [EventRecord] [Writer [EventRecord] [a]] ?
17:06:00 <bambanx> i was reading on the net but i can find good answers
17:06:06 <cmccann> ddarius, ok, fair enough. I can see why it would be difficult to actually do anything with types containing ⅋ but nothing I would expect to be a serious problem, though.
17:06:15 <tech2> bambanx: what do you use any language for?
17:06:24 <bambanx> well programming things
17:06:36 * cmccann programs things in Haskell
17:06:37 <bambanx> i mean what is the most common use for this language?
17:06:51 <shachaf> bambanx: The FAQ has a lot of useful answers to that sort of question.
17:06:53 <shachaf> @where faq
17:06:53 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:07:14 <bambanx> php is most part used for database web design html for webs haskell what uses is common?
17:07:48 <sully> generating infinite lists using clever one liners
17:07:49 * cmccann thought php was mostly used for sql injection vulnerabilities 
17:08:05 <lispy> bambanx: languages, finance, and whatever else you can think of :)
17:08:22 <bambanx> you can do a dinamic web with haskell?
17:08:33 <lispy> bambanx: I'd like to see it get used more for guis and visualizations, but there is still a lot of work to be done there
17:08:42 <lispy> bambanx: yes, look at snap and yesod
17:08:52 <cmccann> @faq can haskell create dynamic websites?
17:08:52 <lambdabot> The answer is: Yes! Haskell can do that.
17:09:02 <bambanx> cool
17:09:18 <bambanx> sorry formy english is bad :)
17:09:19 <cmccann> I love the @faq command more every time I use it
17:09:30 <VHD> does it report yes regardless?
17:09:39 <azaq23> @faq do you?
17:09:39 <lambdabot> The answer is: Yes! Haskell can do that.
17:09:39 <lispy> ?faq Can Haskell create a thunk so big that Haskell cannot evaluate it?
17:09:40 <lambdabot> The answer is: Yes! Haskell can do that.
17:09:43 <VHD> haha
17:09:51 <monochrom> "what is it most used for" is not a good question for several languages
17:10:07 <hpaste_> Johannes` pasted “forever” at http://hpaste.org/50614
17:10:13 <Johannes`> what's wrong there?
17:10:40 * cmccann proposes that java is most often used for working around the limitations created by using java
17:10:40 <bambanx> haskell have a library for do interfaces of the programs? gui
17:10:48 <monochrom> for example, if I ask "what is c++ most used for?", and you answer "c++ is most used for ___", I'm pretty sure real data will show your answer is wrong
17:10:53 <lispy> monochrom: It can be awkward for languages that are meant to be general purpose like (Haskell, C/C++, etc) but I think it's still reasonable to ask
17:10:57 <mightybyte> What function should I call to get the system timer at the highest possible resolution?
17:11:02 <monochrom> yes exactly, lispy
17:11:17 <azaq23> Johannes: What do you try to achieve with "forever(printinfo, sleep 2)? That printinfo and sleep 2 are done after another forever`?
17:11:25 <lispy> mightybyte: IIRC, that's platform dependent
17:11:31 <cmccann> bambanx, there are bindings to some common GUI libraries, as well as stuff like SDL and OpenGL and whatnot
17:11:35 <mightybyte> lispy: :(
17:11:37 <Johannes`> azaq23: yeah, iow i want to print date every 2 seconds
17:11:45 <bambanx> thanks
17:12:07 <mightybyte> I was hoping for something like Java's System.nanoTime()
17:12:12 <Johannes`> i get "Couldn't match expected type `IO t0' with actual type `(IO (), b0)'"
17:12:13 <azaq23> Johannes: Well, forever takes one IO action and only this IO action - You'll have to construct a complete IO action from printinfo and sleep 2
17:12:21 <monochrom> in fact "most used for" is only meaningful for a minority of languages because they are no good for anything else (and likely no good for what they are used for either, but saved only by "invented here" mentality)
17:12:24 <azaq23> Johannes: What you give forever is a tuple type of two IO actions
17:12:27 <lispy> mightybyte: I bet you could build the equivalent if you knew what it used on each platform
17:12:39 <monochrom> for example php is most used for ___ because it's really no good
17:12:45 <lispy> mightybyte: you might need some FFI and/or CPP macros, but doable
17:12:59 <azaq23> Johannes: forever (printinfo >> sleep 2) or anything in this regard might do the trick - I don't know if you're using the sleep function correctly, though.
17:13:13 * lispy needs to run
17:13:16 <mightybyte> Looks like the clock package might be an attempt at what I'm looking for, but it doesn't build.
17:13:25 <mightybyte> lispy: Thanks
17:13:32 <Johannes`> ah, *facepalm*
17:13:44 <cmccann> monochrom, "X is most often used for creating large numbers of bugs" is true for most programming languages X
17:13:54 <Johannes`> it was supposed to be main = forever (printinfo >> sleep 2)
17:13:57 <Johannes`> i need coffee ;)
17:15:18 <monochrom> cmccann: I hope you enjoy my http://groups.google.com/group/comp.lang.functional/msg/81756fe3fe07a61a and also http://groups.google.com/group/comp.lang.functional/msg/571a96f2fd6195b5 :)
17:16:03 <mightybyte> Oh, it looks like the clock package works on Linux...just not on MacOS
17:16:53 <cmccann> monochrom, hahaha
17:18:00 <cmccann> monochrom, I'd seen one of those before, didn't realize that was you :]
17:19:05 <mm_freak_> Cale: i found the solution…  it's really the signal inhibition, which makes this hard, so i'll have to work on an idea to overcome this
17:19:30 <mm_freak_> it even works in IO =)
17:24:32 * hackagebot hexpat 0.19.7 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.19.7 (StephenBlackheath)
17:25:36 <bambanx> cmccann thanks for your answer , for what you do haskell?
17:26:42 <cmccann> I would like to note, as an immutable fact which I am stating for the record, that reddit's spam filter is utter rubbish. I think 3 out of 25 articles I see on /r/haskell right now are perfectly reasonable articles I had to rescue
17:26:58 <monochrom> reddit has a spam filter? :)
17:27:27 <monochrom> oh, some things are filtered. so I guess reddit has a filter
17:27:36 <monochrom> ham filter? :)
17:28:14 <cmccann> yes, reddit, obviously one particular link to cdsmith's blog is spam. this is obvious from the fact that the previous several links to his blog got plenty of upvotes and comments and were clearly not spam
17:28:20 <monochrom> dons will be furious to find out that reddit is f**king with his haskell community! :)
17:28:42 <cmccann> dons has been a moderator for /r/haskell long enough that I'm sure he's well aware of how terrible the filter is
17:29:26 <cmccann> but basically reddit randomly decides that some articles are spam and then filters them out, so I have to go check the filter a couple times a day to release them
17:30:06 <cmccann> most recently I think the self post about IDEs, and the "week 1" link to cdsmith's blog
17:31:06 <cmccann> bambanx, oh, sorry, got distracted. I use it for lots of stuff, really. most small one-off projects at home and work I do in Haskell because it's quicker to get it working
17:31:44 <bambanx> small project like what?
17:32:18 <cmccann> monochrom, oh and to answer your question, no I'm pretty sure reddit doesn't have a spam filter. It may call it a spam filter, but what it's actually filtering I can't tell you
17:33:51 <cmccann> bambanx, automating simple tasks and such. usually processing files and chewing on bits of data in the end.
17:34:46 <cmccann> bambanx, really, Haskell is a general-purpsoe language, you can use it for anything you like. library support varies, but that's the situation with any not-completely-mainstream library
17:35:01 <bambanx> nice
17:35:10 <bambanx> i am a beginner on programming
17:35:15 <bambanx> i am learning python
17:35:27 <bambanx> a friend say me learn haskell and i am curious why
17:36:06 <zhasha> http://learnyouahaskell.com/introduction#so-whats-haskell
17:36:07 <cmccann> bambanx, it's a very different perspective from other languages, if nothing else. gives you more ways to look at problems.
17:36:26 <ian__> best programming language, etc.
17:37:12 <cmccann> it's somewhat trite to say learning other languages makes you a better programmer, but just knowing one language can certainly help make you a bad programmer
17:38:21 <cmccann> and Haskell is sufficiently different from most mainstream languages that it gives you a lot of return on effort for widening your perspective
17:41:39 <zachk> you can take the ideas/concepts/constructs you learn into haskell and move them into other languages
17:41:57 <cmccann> with varying degrees of success :]
17:42:42 <ion> You certainly learn to separate the nasty IO stuff from the pure stuff better.
17:42:48 <cmccann> a lot of stuff in Haskell doesn't translate well to languages lacking meaningful static types, such as Java
17:47:09 <mustelo> @tell byorgey I pinged brent about colloquium. hopefully you'll hear from him shortly!
17:47:10 <lambdabot> Consider it noted.
17:48:41 <djahandarie> Now that's confusing.
17:49:46 <zygoloid> hmm, a different brent, or a self-fulfilling prophecy?
17:50:08 <ian__> is there anything like this: groupTogether 3 [1, 2, 3, 4, 5, 6, ...] ===> [[1, 2, 3], [4, 5, 6], ...]
17:50:14 <mustelo> heh, it's the boring former case, unfortunately
17:50:14 <cmccann> djahandarie, alas real life does not warn about name shadowing
17:51:11 <djahandarie> I wonder if De Bruijn was any good at remembering names.
17:51:36 <mustelo> ian__, http://hackage.haskell.org/packages/archive/split/latest/doc/html/Data-List-Split.html#v:splitEvery (speaking of byorgey...)
17:52:13 <ian__> thanks!
17:54:33 <monochrom> @remember djahandarie I wonder if De Bruijn was any good at remembering names.
17:54:33 <lambdabot> Done.
17:55:21 <elliott> I'm going to start referencing people by how many lines up they spoke.
17:55:34 <elliott> 3: you sure did add a quote
17:56:04 <djahandarie> Can I refer to you by the number of 't's in your name?
17:56:17 <monochrom> 0: haha
17:56:18 <djahandarie> Oh, our elliot and elliottt friends aren't here today.
17:56:27 * mustelo starts hacking on a xchat plugin to do proper highlighting of 4's naming
17:56:32 <ian__> -1: hi
17:57:03 <_Ray_> I finally understood what functor it is that is contravariant in the first parameter, and covariant in the first parameter. It is  -> .
17:57:04 <mustelo> this brings a whole new usefulness to preflex's 'seen'
17:57:06 <zygoloid> > let groupTogether n = map snd . filter fst . zip (cycle . take n $ True:repeat False) . map (take n) . tails in groupTogether 3 [1..]
17:57:07 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
17:57:27 <_Ray_> fucking hell zygoloid, that is disgusting
17:57:51 <ion> > map (map snd) . groupBy ((==) `on` fst) . zip (map (`div` 3) [0..]) $ ['a'..]
17:57:52 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz{","|}~","\DEL\128\129"...
17:57:55 <zygoloid> 3: thank you :)
17:58:17 <ezyang> You mean hilarious!
17:58:36 <_Ray_> But yeah, feelsgoodman.
17:59:12 <_Ray_> Although strictly speaking, it is not contravariant in the sense of subtyping, but the subtyping needs to be witnessed by a function.
17:59:44 <_Ray_> Like fst :: (a, b) -> a witnesses that (a, b) is a subtype of a.
18:00:41 <ion> > map (map snd) . groupBy ((==) `on` fst) . zip (cycle (replicate 3 0 ++ replicate 2 1 ++ replicate 1 2)) $ ['a'..]
18:00:43 <lambdabot>   ["abc","de","f","ghi","jk","l","mno","pq","r","stu","vw","x","yz{","|}","~"...
18:01:23 <aavogt> > let groupTogether n = map (map snd) . groupBy (\_ (x,_) -> mod x (n+1) /= 0) . zip [0 .. ] in groupTogether ['a'..]
18:01:23 <lambdabot>   No instance for (GHC.Real.Integral [GHC.Types.Char])
18:01:24 <lambdabot>    arising from a use ...
18:01:35 <aavogt> > let groupTogether n = map (map snd) . groupBy (\_ (x,_) -> mod x (n+1) /= 0) . zip [0 .. ] in groupTogether 3 ['a'..]
18:01:36 <lambdabot>   ["abcd","efgh","ijkl","mnop","qrst","uvwx","yz{|","}~\DEL\128","\129\130\13...
18:01:51 <aavogt> > let groupTogether n = map (map snd) . groupBy (\_ (x,_) -> mod x n /= 0) . zip [0 .. ] in groupTogether 3 ['a'..]
18:01:52 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz{","|}~","\DEL\128\129"...
18:02:09 <ian__> guys don't worry about it i'm using Data.List.Split
18:02:15 <ian__> i appreciate it though
18:02:33 <aavogt> but for whatever reason groupBy isn't guaranteed to take arguments in that order
18:02:41 <cmccann> > let groupTogether = (\n -> unfoldr ((\(x,y) -> if null x then Nothing else Just (x, y))  . splitAt n)) in groupTogether 3 ['a'..]
18:02:41 <ion> We’re not really doing this for you, just toying with it. You really should use Split instead of any of these onliners.
18:02:43 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz{","|}~","\DEL\128\129"...
18:05:36 <aavogt> > let groupTogether n = iterate (drop n) . map (take n) . tails in groupTogether 3 ['a'..]
18:05:38 <lambdabot>   [["abc","bcd","cde","def","efg","fgh","ghi","hij","ijk","jkl","klm","lmn","...
18:06:08 <cmccann> > let justIf p x = if p x then Just x else Nothing; groupTogether n = unfoldr (justIf (not . null . fst) . splitAt n) in groupTogether 3 ['a'..]
18:06:10 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz{","|}~","\DEL\128\129"...
18:06:14 * cmccann likes that version
18:07:49 <aavogt> > let groupTogether n = map head . iterate (drop n) . map (take n) . tails in groupTogether 3 ['a'..]
18:07:51 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz{","|}~","\DEL\128\129"...
18:08:50 <cmccann> I'm telling you, unfoldr is the way to go
18:08:53 <aavogt> > let groupTogether n = map head . until null (drop n) . map (take n) . tails in groupTogether 3 ['a'..'k']
18:08:54 <lambdabot>   ""
18:09:08 <cmccann> aavogt, ooh, that one's nice too
18:09:16 <ion> Indeed
18:09:19 <incluye> you can't use $ together with cons can you
18:09:29 <ion> > let groupTogether n = const [] in groupTogether 3 ['a'..'k'] --optimized
18:09:30 <lambdabot>   []
18:09:30 <incluye> like as in fibs = 0:1:$ zipWith (+) fibs (tail fibs)
18:09:31 <aavogt> the iterate one doesn't work for finite lists
18:09:38 <ion> Also more polymorphic.
18:09:40 <incluye> or something of that sort
18:10:10 <aavogt> you can define    data D = Int :$ String
18:10:27 <incluye> buuut you can't do what I wanted to do
18:10:43 <cmccann> incluye, what are you trying to do there?
18:10:45 <ion> What did you want to do again?
18:11:12 <cmccann> regular application binds more tightly than operators, so the stuff after the last (:) already groups together
18:11:14 <incluye> just not have to put parentheses around that last section there
18:11:18 <incluye> oh
18:11:33 <incluye> you know maybe I should have just tried that first
18:11:53 <aavogt> > let groupTogether n = until (not . null) (drop n) . map (take n) . tails in groupTogether 3 ['a'..'k']
18:11:54 <lambdabot>   ["abc","bcd","cde","def","efg","fgh","ghi","hij","ijk","jk","k",""]
18:12:07 <cmccann> incluye, the $ is just a regular operator with very low precedence, which is why "a b $ c d" is like "(a b) (c d)"
18:12:30 * aavogt must be misunderstanding until
18:12:31 <incluye> right
18:13:10 <incluye> I just needed to fix my preconceptions about how programming languages treat whitespace
18:14:10 <permagreen> Inconsistently, in my experience
18:14:17 <ion> HLint would also have suggested removing the extraneous parentheses in 0:1:(zipWith …)
18:14:23 <ClaudiusMaximus> > until null tail "list"
18:14:23 <lambdabot>   ""
18:15:21 <cmccann> permagreen, haha
18:15:30 <cmccann> at least Haskell tends to be internally consistent about whitespace
18:15:39 <cmccann> if a bit peculiar in some cases compared to other languages
18:16:13 <ion> I’m completely happy with the H98 style of
18:16:14 <ion> if …
18:16:18 <ion>   then …
18:16:41 <ion> It’s just logical for then and else to be indented in that case to me.
18:16:41 <ClaudiusMaximus> > let groupTogether n = takeWhile (not . null . drop n) . map (take n) . tails in groupTogether 3 ['a'..'k']
18:16:42 <lambdabot>   []
18:17:16 <ion> (Except for the “if” structure not being very nice in the first place. :-P)
18:18:13 <cmccann> ion, I don't think H98 required then and else to be indented
18:18:33 <ion> cmccann: In some cases it does, i think. For instance if it’s a statement in a do block.
18:19:39 <cmccann> that's because parsing the do block is specified by the indentation level
18:19:47 <ClaudiusMaximus> > let groupTogether n = takeWhile (not . null . drop n . (error "Success.":)) . map (take n) . tails in groupTogether 3 ['a'..'k']
18:19:49 <lambdabot>   ["abc","bcd","cde","def","efg","fgh","ghi","hij","ijk"]
18:19:55 <ion> Indeed
18:20:09 * cmccann thinks if expressions in do blocks usually indicate bad style anyway
18:21:23 <aavogt> edwardk: does trifecta have anything for parsing permutations of things?
18:25:10 <mustelo> aavogt, afaik not yet
18:25:23 <mustelo> slash intentionally no.
18:27:11 <ion> What are your opinions on the separation of Alonzo Church and the State monad?
18:29:10 <aavogt> ion: they've newtype'd it away to keep the classes from overlapping
18:29:10 <cmccann> ion, given that the State monad arises from the adjunction given by Currying, it seems reasonable to me
18:46:14 <int80_h> :quit
19:40:15 <ivanm> I've been reading through Snoyman's chapter on Enumerators in his Yesod book
19:40:56 <ivanm> if enumerators are meant to be producers, is there any advantage in turning an existing function that produces a (long) list of values into an Enumerator instead?
19:41:39 <kfish> ivanm, it might give you more control for incremental processing
19:41:48 <ivanm> *nod*
19:42:19 <ivanm> so the advantage would come from the combination of enumerators + iterators?
19:43:22 <kfish> depends what advantages you're looking for ... if you want to get better control of resource management (io buffer sizes etc.) then turning a pure list processor into a pure enumerator/iteratee stack won't help so much
19:43:57 <kfish> it could help untangle nasty flow control, or it could help obfuscate simple list processing
19:49:34 * hackagebot wai-logger 0.0.1 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-0.0.1 (KazuYamamoto)
19:51:46 <ivanm> just hoping for better performance at the IO level ;)
19:52:22 <ivanm> it seems the solution that John Lato came up with for me for use with iteratees doesn't apply too weel for enumator :(
19:52:40 <Axman6> depends really on whether you can stream your data to get a result, or whether you need to have all your info available at once
19:52:47 <ivanm> though it's a little dodgy to begin with: it tries to make writing ByteStrings more efficient by trying to guess how to chunk an incoming list
19:52:52 <ivanm> Axman6: I'm streaming it
19:52:56 <Axman6> if you can incrementally process your data then you should be ok
19:53:15 <ivanm> with or without the enumerator stuff
19:53:36 <ivanm> ?
20:24:02 <zoo> How can I avoid getting "no instance for (Show (IO X))"?
20:28:05 <huangyi> zoo: fmap show x ?
20:29:26 <shachaf> zoo: DOn't try to show a value of type "IO X". :-)
20:29:43 <azaq231> zoo: You can't show an IO value. That doesn't make sense. You may try to show the result of the IO value (X in your case), for which you should do what huangyi said
20:35:34 <zzo38> After I write Haskglk, can they make the Haskell compiler into Glulx, that can use all of the same exported types and functions and so on?
20:41:23 <blackdog> any windows haskellers here? i need to use some C libs in a windows project, with haskell on top - is Visual Studio the way to go?
20:41:42 <zoo> huangyi, azaq231: Thanks for your replies. (IO X) >>= print seems to be an easy way to do it.
20:42:54 <shachaf> zoo: That's most likely an error. :-)
20:44:30 <edwardk> aavogt: i currently don't have the permutation parsers in trifecta because i've never needed them
20:44:45 <edwardk> aavogt: i've yet to actually get a payout from them
20:45:17 <aavogt> the way it handles invalid input is quite nice
20:45:34 <edwardk> aavogt: the 'expected' errors?
20:45:35 <glguy_> > show (print ())
20:45:36 <lambdabot>   "<IO ()>"
20:45:39 <aavogt> yep
20:45:49 <azaq231> :t (print, putStrLn . show)
20:45:50 <lambdabot> forall a a1. (Show a, Show a1) => (a -> IO (), a1 -> IO ())
20:46:09 <edwardk> yeah i was trying to make those pretty. next up is adding typeahead support so when you plug it into readline it can do tab completion for your grammars
20:46:24 <shachaf> > putStrLn " <IO ()>"
20:46:25 <lambdabot>   <IO ()>
20:46:27 <azaq231> :t let x :: Show a => IO a; x = undefined in fmap show x >>= putStrLn
20:46:27 <edwardk> that'll make for nicer repl support
20:46:28 <lambdabot> IO ()
20:46:31 <azaq231> zoo ^^
20:46:47 <edwardk> especially once i build some form of haskeline that supports syntax highlighting the line you are editing
20:47:08 <glguy_> edwardk: I know that it isn't something that would necessarily be appropriate for trifecta, but have you put any thought into deriving unparsers from the parser?
20:47:25 <edwardk> glguy: 'deliberately not' as someone said earlier.
20:47:56 <edwardk> glguy: i'm trying to avoid pretty printing types or terms by pointing directly into your code at the raw types and terms that make up the error
20:48:05 <edwardk> glguy: clang gets really far with this approach
20:48:18 <edwardk> glguy: i want to see how usable it is in a functional context
20:48:44 <edwardk> glguy: what i do support is that all of the token parsers mark up an interval map, so you get free highlighter support from your parser
20:49:03 <edwardk> so while you don't pretty print you can spit back user source code at the user highlighted
20:49:21 <edwardk> also, the bidirectional approach almost mandates giving up the monad
20:49:43 <Saizan> really?
20:49:45 <edwardk> the limited form of bidirectionality that i'm looking to support right now is the typeahead machinery
20:50:28 <edwardk> saizan: take a look at the awful biarrow bidirectional parse/pretty print stuff that has gone before
20:50:36 <aavogt> edwardk: but lets say you have a construct like  "(x1:x2,y1:y2,z2)" (array bounds) is there some simple way to get a different error "say missing x2" if there's a  "(x1:)"?
20:50:39 <edwardk> or worse these bidirectional lenses
20:50:48 <glguy_> I tried your HTTP example in the repository. It told me that it didn't expect an <EOF> and left it at that (in the one random string of words I tried to parse) :) Is there a way to enumerate what would have been valid alternatives in the error message?
20:51:32 <edwardk> glguy: that example is literally cut and pasted from one of bos's examples. it makes no use of the <?> functionality that i have that attoparsec doesn't
20:51:49 <edwardk> glguy: so its not very compelling. i was literally using it to make sure i could parse _anything_ ;)
20:51:50 <glguy_> Ah ha.
20:51:57 <aavogt> currently I have  "(,) <$> variable <*> optional (colon *> variable)"
20:52:08 <glguy_> I was using it to see pretty colored error messages :)
20:52:09 <edwardk> i have a much bigger example, but its not ready for public release yet
20:52:11 <Saizan> edwardk: i was thinking of this, which looks less awful http://hackage.haskell.org/packages/archive/invertible-syntax/0.2/doc/html/Text-Syntax-Classes.html and can be extended with a (>>=) :: f a -> (a -> f b) -> f (a,b)
20:52:43 <edwardk> aavogt: you can give any error you want manually by calling 'warn' or 'error'
20:53:05 <edwardk> and you can even add things to it with the rendering support, so you can draw squiggles over ranges, etc.
20:53:55 <edwardk> saizan: i'm still not sold on the general utility of that approach. as ASTs go the intermediate results are awful
20:55:19 <edwardk> glguy: heh, well, i'm hoping to add a layer that will pretty print control characters in the input nicely as either colored <EOT> or ^X like annotations, but then i have to tweak the renderer, with that i'll have to tweak the draw command to be two commands, probably a draw and a fill
20:55:33 <edwardk> glguy: after that i plan to put out some more test grammars
20:55:58 <edwardk> i have a nice one for an HMF-style language that I'm using for work that I'm hoping to release publicly as a toy language example
20:56:18 <edwardk> i'm using that to experiment with ways to render type errors without pretty printing
20:57:01 <edwardk> thats why the diagnostics wound up with nested child diagnostics, etc. so i could show the derivation tree
20:57:01 <Saizan> well, if you have some original code to refer to the trifecta way is surely better, though sometimes you've to present freshly generated code
20:57:40 <edwardk> saizan: perhaps. right now im trying to wear the hair shirt. it works REALLY well for clang
20:57:57 <edwardk> the error messages are lightyears better than the heavily pretty printed gcc error messages
20:58:41 <edwardk> saizan: i figure if 50 people veer one way I might as well veer the other way and see if its worth doing.
20:58:51 <edwardk> and only after, come back and join the herd ;)
20:58:56 <Saizan> i'm thinking of stuff like normalization, not much error messages
20:59:27 <edwardk> well, you can make a PrettyTerm instance for your type, etc. nothing stops that
20:59:57 <edwardk> i'm just blowing my complexity budget for crap i can cram in the parser on other things
21:00:05 <aavogt> @hoogle (Traversable t, Applicative f) => f b -> t a -> f (t b)
21:00:05 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
21:00:05 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
21:00:05 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
21:00:23 <edwardk> and something that makes me give up monadic style (like the invertible syntax stuff) is largely a non-starter
21:00:51 <Saizan> yeah, in the end with the invertible-syntax approach the bidirectionality is not something the parser should care about
21:01:23 <aavogt> there's no more clear way to write    "traverse . const"?
21:01:33 <edwardk> my experience with bidirectional 'lenses' is that they are almost universally not worth the bother. write the embedding and the projection, maybe test that it is idempotent and go from there
21:01:48 <edwardk> @type traverse . const
21:01:49 <lambdabot> Not in scope: `traverse'
21:01:59 <edwardk> @type Data.Traversable.traverse . const
21:02:00 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => f b -> t a -> f (t b)
21:02:36 <edwardk> thats pretty minimal
21:03:02 <Saizan> once i managed to write a bidirectional foldl it was pretty easy to write a parser+printer with prolog's DCG's :)
21:03:22 <Saizan> for a minimal lambda calculus though
21:03:33 <edwardk> but the moment you get even minor context sensitivity it all goes out the window
21:04:44 <aavogt> edwardk: do you intend that user code defines    instance MonadTokenParser (Parser a) where whiteSpace = spaces {- or other kinds of white space? -} ?
21:05:31 <Saizan> i guess i should try something like a^nb^n then
21:05:37 <edwardk> aavogt: or preferably you make newtype P a = P { unP :: StateT MyState (Parser String) a } deriving (Functor,Applicative,Monad,MonadParser,….)
21:06:04 <edwardk> then use instance MonadTokenParser P where whiteSpace = buildWhiteSpaceParser haskellCommentStyle
21:06:31 <ddarius> edwardk: The one thing you were like "bugger it, no one needs it."
21:06:35 <edwardk> so you make up your own parser type for your language and bake in a whitespace parser that you built directly from your chosen comment or layout style.
21:07:03 <edwardk> ddarius: which it? there are 3-4 going in conversation ATM ;)
21:07:10 <ddarius> edwardk: The permutation parsers.
21:07:14 <edwardk> ah yeah
21:07:19 <edwardk> those i just said 'screw it'
21:07:32 <edwardk> i've never seen them actually used
21:07:39 <edwardk> i'd love to be sold a compelling use case
21:08:47 <edwardk> i suppose record fields, etc.
21:09:19 <edwardk> if someone screams loud enough and has a use case i can relent ;)
21:09:22 <aavogt> error messages about duplicate fields would be the main benefit
21:10:05 <ddarius> edwardk: Generally any "keyword" parameter passing as I mentioned earlier.
21:10:17 <edwardk> yeah
21:10:35 <edwardk> aavogt: do you have a parser that uses it or is it a hypothetical?
21:13:42 <aavogt> I used this once (for xmobar's config parsing) http://hackage.haskell.org/packages/archive/action-permutations/0.0.0.0/doc/html/Control-Applicative-Permutation.html
21:13:49 <edwardk> okay
21:13:53 <aavogt> though I think it uses parsec's permutations now
21:13:57 <edwardk> i'll take a gander at porting it
21:14:10 <edwardk> well, at porting the parsec version
21:15:08 <edwardk> it doesn't look so bad to port
21:15:14 <ion> namedParams ps = do p <- namedParam ps; (p:) <$> (namedParam (delete p ps) <|> pure [])
21:18:18 <ion> err, the last namedParam should have been plural.
21:19:31 <ddarius> namedParam = choose
21:20:31 <aavogt> @type delete
21:20:32 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
21:21:09 <ion> Not Prelude.delete necessarily. I was using a hypothetical delete.
21:21:29 <ion> Just like i was using a hypothetical namedParam. :-)
21:30:29 <edwardk> okay, almost done porting the permutation parser and cleaning it up
21:33:00 <hpaste_> ian__ pasted “euler 58 answer - so happy” at http://hpaste.org/50615
21:33:53 <ian__>  oo error checking
21:34:34 <rekahsoft> hi all..i recently purchased RWH from my local bookstore and have been wroking my way thoruhg it..right now i have been reading about hte Text.Regex.Posix module but am having issues using it (not found)..i did a google search and found a module by the name Text.Regex.Base..also not able to use that either (not found)..whats up?..do i haveto use cabal it install it? (is it not part of the standard library?)
21:35:05 <Saizan> yes, you've to use cabal to install it
21:35:19 <Saizan> it used to be shipped with ghc, iirc
21:37:34 <edwardk> aavogt: how does http://ekmett.github.com/trifecta/Text-Trifecta-Parser-Perm.html look to you?
21:38:24 <edwardk> sufficiently similar to the one in parsec?
21:42:03 * ddarius remembers when practically everything used to be shipped with GHC.
21:42:16 <ddarius> Admittedly, "practically everything" was a whole lot less.
21:42:39 <edwardk> ddarius: and i remember how bad it was trying to get anything into that base package
21:42:41 <edwardk> ;)
21:43:10 <edwardk> oh nice, i'm able to get all the combinators in that module other than permute down to just requiring Functor
21:43:26 <ddarius> edwardk: At that time they were trying to move away from everything being bundled with GHC.
21:43:42 <tommd> Heck, even now.  I'm _still_ waiting for Bart to finish up nubOrd (2 years and running!)
21:43:53 <edwardk> yeah
21:44:13 <aavogt> edwardk: looks good. Should/could this work properly:   (<||> (x <?> "no x"))?
21:44:27 <edwardk> probably
21:44:35 * ddarius remembers the fptools CVS repository that had a large chunk of Haskell IP including GHC and Hugs and various tools and libraries.
21:44:42 <edwardk> at least as well as it does in parsec
21:45:08 <ddarius> Back when GHC and Hugs actually shared the same code for "standard libraries."
21:45:49 * ddarius would expect the Parsec permutation parsers to port with almost no effort or changes.
21:45:55 <edwardk> yeah
21:45:59 <edwardk> i did some cleanup
21:46:07 <edwardk> since i didn't have to suport any 'legacy api' stuff
21:46:21 <edwardk> and i wanted to just make the things that were functors into functors rather than make some silly combinator
21:46:25 <ddarius> The permutation parsers have seen almost no love since probably the '90s.
21:46:39 <edwardk> yeah i gathered from the 'we push the type system to the limit!' comment ;)
21:47:19 * ddarius used to push Haskell's type system to the limit.  Now I just push C#'s.
21:47:42 <edwardk> it was so cute, now that people have pushed those limits out a ways farther its practically laughabe
21:47:53 <edwardk> the algorithm is so complex, *turns out to be 8 lines of code*
21:47:56 <ddarius> edwardk: I did laugh when you quoted the comment.
21:49:04 <ddarius> To be honest, even the depths of Haskell 98's type system have been far from plumbed.
21:49:33 <edwardk> heh
21:49:53 <edwardk> with the changes to meet the weaker class requirements for trifecta it now no longer requires anything parser specific
21:50:04 <edwardk> so you can use permute with any Alternative
21:50:36 <ddarius> I believe there are actually some permutation-like things for generic Alternative instances somewhere.
21:51:09 <ddarius> Quite a lot of parser combinators do generalize to arbitrary Alternatives.
21:51:22 <edwardk> yeah
21:51:28 <edwardk> i generalized all of the stock ones
21:52:02 <aavogt> edwardk: action-permutations I linked earlier works with any Alternative
21:52:08 <edwardk> sounds right
21:52:51 <ddarius> So one problem with these burritos is that I don't own a microwave.
21:52:58 <edwardk> hahahahahaha
21:53:05 <edwardk> ouch those take a while to cook otherwise
21:53:11 <edwardk> 60 minutes to tasty goodness
21:53:32 <ddarius> I guess I could take them to work and use the microwave there.
21:53:39 <edwardk> that'd work
21:54:34 * hackagebot trifecta 0.34 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.34 (EdwardKmett)
21:55:02 <edwardk> http://ekmett.github.com/trifecta/Text-Trifecta-Parser-Perm.html
21:56:32 <ddarius> Documentation copied from Parsec?
21:56:54 <edwardk> yeah
21:57:02 <edwardk> along with credits
21:57:12 <edwardk> did i miss an update?
21:57:16 <ddarius> I never did get permission to use the documentation for Parsec 3.
21:57:31 * edwardk plugs his ears and goes lalalala
21:57:36 <ddarius> I attempted to, but Daan is a hard person to get a hold of.
21:57:40 <edwardk> yeah
21:58:10 <edwardk> he seems to largely not care about this stuff these days
21:58:23 <ddarius> I imagine, which is a bit of a shame.
21:59:24 <edwardk> any other common parsec-style parsers that i missed?
22:00:02 <edwardk> with a few small edits i can export a poly-parse-style API as well, but i haven't gotten around to it
22:00:04 <ddarius> It quite possible that there is stuff worth stealing from any of the many, many other Parsec knock-offs over the years.
22:00:35 <edwardk> so you'd be able to import one module or another to get try-style or commit-style semantics
22:01:20 <ddarius> You should do it, make your library very popular, and then a year from now we'll grep hackage and see which style is preferred.
22:01:22 <edwardk> when i do it'll probably Text.Trifecta.Parser.Poly and Text.Trifecta.Parser.Poly.Char8
22:02:01 <edwardk> well those who like attoparsec seem to like the polyparse commit style
22:02:07 <edwardk> since they can ignore 'try'
22:02:20 <edwardk> and just never commit to get the attoparsec semantics
22:02:43 * ddarius is using attoparsec for his PDF parser.
22:03:20 <edwardk> i suppose there is no point on emitting trifecta -style error messages on PDF guts ;)
22:05:50 <ddarius> I should email my "ideas" file to some suck^W bored student sometime.
22:07:32 <shachaf> ddarius: You should!
22:09:20 <Axman6> ddarius: what's in it?
22:09:27 <ddarius> Here's a good (as in entertaining) one.  God only knows how long ago this was written: "Reimplement MTL using CPS also use Associated type synonyms/type families to lead to auto-flatten monad transformer stacks"
22:10:25 <Saizan> sounds like monad-ran
22:11:40 <ddarius> Here's another good one (in a different way): Formalize the connection between operational and denotational semantics a la Danvy in a theorem prover in such a way that one can model operationally, but prove results denotationally.
22:12:51 <mister_m> quick question about this piece of code: fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)]    -- am I correct in thinking that zip fibs (tail fibs) is equal to zip [0,1] [1] when computing the third number? What would zip fibs (tail fibs) be when computing the fourth? Surely it isn't zip [0,1,1] [1]?
22:13:04 <ddarius> mister_m: No, you are not correct.
22:13:33 <ddarius> mister_m: Just substitute mechanically.
22:13:34 <accel_> if someone writes a "how to write an APL interpreter in haskell" tutorial; I will reduce my trolling by half as I read through said tutorial.
22:13:46 <copumpkin> mister_m: keep in mind that when you write [0,1], you mean 0:1:[]. Who put that [] in there? Nothing in the code says []
22:14:12 <copumpkin> accel_: you reducing it by half doesn't sound like a good deal for us
22:14:23 <ddarius> @google timothy budd lambda
22:14:24 <copumpkin> cutting it in half might be
22:14:25 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.8147
22:14:39 <mister_m> copumpkin: I'm sorry; I'm not following
22:15:04 <accel_> copumpkin: alright; I really want such a tutorial. I'll up it to 75%
22:15:13 <copumpkin> you understand that [0,1] is the same as 0:1:[]?
22:15:21 <copumpkin> it's just syntactic sugar for that
22:15:29 <mister_m> copumpkin: sure
22:15:38 <Saizan> ddarius: do you have a reference on those semantics a la Danvy?
22:15:42 <copumpkin> you said "is equal to zip [0,1] [1]"
22:15:58 <mister_m> sorry, the expression zip [0,1] [1]
22:16:06 <mister_m> which would be [(0,1]
22:16:23 <copumpkin> if you'd said "is equal to zip (0:1:who knows) (1: who knows)"
22:16:24 <ddarius> edwardk: You might find this idea interesting: Use a (non-)linear model reduction approach to develop effects over animations, where an entire animation would be a single vector in discretized space-time.  Motion blur, for example, would be one such effect.
22:16:24 <Saizan> zip gets passed two infinite lists there
22:16:31 <mister_m> resulting in the sequence 0:1:1:[]
22:16:39 <Axman6> not :[]
22:16:45 <copumpkin> mister_m: the [] never gets inserted
22:16:50 <ddarius> Saizan: I have an excellent reference.  One second.
22:16:52 <copumpkin> nothing ever outputs one of those
22:17:17 <copumpkin> mister_m: do you understand how
22:17:22 <copumpkin> let x = 1:x works?
22:17:28 <copumpkin> > let x = 1:x in x
22:17:29 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:17:30 <ddarius> Saizan: http://lambda-the-ultimate.org/node/2423#comment-38384
22:17:48 <accel_> > let x = "hello world" : x in x
22:17:50 <lambdabot>   ["hello world","hello world","hello world","hello world","hello world","hel...
22:18:05 <Saizan> ddarius: heh, extensive, thanks :)
22:18:06 <ddarius> copumpkin: Would you play racquetball (possibly paying some kind of fee) if I found a place to play?
22:18:13 <mister_m> copumpkin: that is I think what I am confused about. I am reading this: http://ccfit.nsu.ru/~ikuznecov/doc/Haskell%20Tutorial%20for%20C%20Programmers/section1.html#part4 but the explanation of that particular part of the above snippet was not actually existant
22:18:26 <Axman6> fibs = 0:1:zipWith (+) fibs (tail fibs -> 0:1:zipWith (+) (0:1:...) (1:...) -> 0:1:(0+1):zipWith (+) (1:(0+1):...) ((0+1):...)
22:18:38 <Axman6> wow, that's a lot less clear than I had hoped =)
22:18:40 <copumpkin> ddarius: I'd definitely be up for attempting it :) but I'm sure I'd be pretty bad at it
22:18:43 <ddarius> Saizan: I seriously recommend reading pretty much all of them.  They aren't all Danvy.
22:18:49 <copumpkin> ddarius: but it sounds fun
22:18:52 <Axman6> especially with the missing brackets
22:18:56 <mister_m> copumpkin: what is let x = 1:x called?
22:18:57 <ddarius> copumpkin: I'm not all that great and it's super fun.
22:19:11 <Axman6> mister_m: it's just a recursive definition
22:19:19 <Axman6> s is defined in terms of itself
22:19:20 <Axman6> x*
22:20:22 <ddarius> Saizan: The Reynolds paper is also very good.
22:20:32 <copumpkin> ddarius: sounds good then :)
22:20:42 <Axman6> so when you evaluate x, you follow the = and see it's equal to 1:x, you need to know what x is equal to, so you again follow the = and see it's again 1:x, so now you've got 1:(1:x), keep doing that, and you'll see that it leads to an infinite list of 1's. this is only really possible in a non-strict language like haskell
22:21:41 <Nisstyre> Axman6: it's possible in a strict language I think, but it will run forever
22:21:52 <copumpkin> well, in this case, it could be done with a simple pointer
22:21:58 <copumpkin> to make a cyclic singly linked list
22:22:05 <copumpkin> but the fibs case couldn't
22:22:06 <ddarius> Yes, I'm pretty sure you can write that in O'Caml and it will "do the right thing."
22:22:51 <mister_m> Axman6: so in the fib example here: fib2 = 0 : 1 : [a + b | (a, b) <- zip fib2 (tail fib2)]  - fib2 is [0,1] , if I was to take 3 fib2. I understand that alright assuming that is correct. I am confused on what happens when I take 4 fib2
22:23:42 <Axman6> mister_m: it's not [1,2], which is the same as 1:2:[], it's 1:2:something that hasn't been evaluated yet
22:26:40 <mister_m> I think I am thinking of how this is all evaluated the wrong way
22:26:50 <Axman6> most likely
22:27:00 <Axman6> > head undefined
22:27:02 <lambdabot>   *Exception: Prelude.undefined
22:27:05 <Axman6> > head 1:undefined
22:27:06 <lambdabot>   No instance for (GHC.Num.Num [a])
22:27:06 <lambdabot>    arising from a use of `e_11' at <inter...
22:27:11 <Axman6> > head (1:undefined)
22:27:12 <lambdabot>   1
22:30:02 <ddarius> Here's an idea for you, Saizan, once you finish those papers: Apply "a functional correspondence" to LL/LR parsers and such.
22:30:30 <mister_m> I guess what I am wondering about is what list is the first argument to zip when you attempt to: take 4 fib2
22:31:05 <shachaf> mister_m: fib2 is, as you can see in the definition. :-)
22:31:31 <shachaf> Which is a list of the form [0,1,???, i.e. 0:1:unevaluated_thunk
22:31:36 <mister_m> shachaf: yes, but is that [0,1] at that particular depth?
22:31:53 <shachaf> Note that ther's no "]" in "[0,1,???". There's never a "]".
22:32:24 <shachaf> data List a = Nil | Cons a (List a)
22:32:40 <shachaf> The first argument to zip is Cons 0 (Cons 1 (...))
22:33:28 <Saizan> ddarius: but what are the advantages of modelling operationally?
22:33:59 <copumpkin> mister_m: you're thinking of it as mutating the list as it goes along, I think
22:34:01 <Saizan> i guess that it works for compilers, for one
22:34:10 <copumpkin> mister_m: all it is is a list whose tail we haven't bothered looking at yet
22:34:20 <copumpkin> that's why we keep telling you to leave the ] off
22:34:42 <copumpkin> there's definitely more there
22:34:47 <copumpkin> we just don't know what it is yet
22:34:52 <ddarius> Saizan: Sometimes it's simpler/clearer/more direct.  You could also go the other way.
22:35:32 <mister_m> copumpkin: I believe you. I understand that the third fibonacci number isn't known until you try: take 3 fib2
22:36:31 <shachaf> mister_m: It's not just that the third Fibonacci number isn't know. It's that the rest of the list isn't known.
22:36:40 <shachaf> It definitely exists, we just haven't looked at it yet.
22:36:54 <mister_m> shachaf: right
22:36:57 <shachaf> (It *could* be [], but it isn't.)
22:38:55 <mister_m> I'm almost there
22:38:59 <mister_m> maybe
22:40:45 <ddarius> edwardk: Your mult for Algebra is essentially taking a bilinear form as its first argument, ne?
22:43:59 <ddarius> Yeah, it's matrix multiplication.
22:44:26 * ddarius is a fucking retard.
22:45:13 <mister_m> could someone show me what the 'thunk' would be for: take 3 fib, and take 4 fib?
22:47:28 <shachaf> mister_m: A thunk is just any value you haven't looked at yet.
22:48:12 <shachaf> Once you evaluate them, both are going to be of the form (_:_), and in particular (0:_).
22:49:38 <shachaf> If you evaluate the whole thing, one is going to be (0:1:1:[]) and the other (0:1:1:2:[]).
22:49:42 <Saizan> when you've evaluated the first 3 elements of fibs you have an heap that looks like this: let fibs = 0 : fibs1; fibs1 = 1 : fibs2; fibs2 = 1 : fibs3; fibs3 = [a + b | zip fibs1 fibs2 ]
22:49:46 <shachaf> Note that the [] is coming from take, not from zip.
22:50:15 <shachaf> Saizan's answer is more helpful than mine. :-)
22:50:46 <Saizan> if you force the fourth element it'll look like ....; fibs3 = 2 : fibs4; fibs4 = [a + b | zip fibs2 fibs3 ]
22:51:07 <shachaf> If you're using take to examine fibs, note that take constructs an entirely new list -- it doesn't give you the same conses as the ones in fibs.
22:51:15 <Saizan> err, sorry, s/zip/(a,b) <- zip/ in both lines
22:52:17 <tommd> Just about everything is broken wiht GHC 7.2 (due to upper bounds on base and/or unix) - is there a unified effort here that I don't know about?
22:52:44 <luite> lots of things have already been fixed
22:52:45 <tommd> Packages from maintainers who I expect to be more on-the-ball are even broken (Cabal, unordered-containers, etc)
22:52:51 <luite> but it's hard to reach some of the maintainers
22:53:04 <Saizan> what makes the computation scroll down the list is that "zip (x:xs) (y:ys) = (x,y) : zip xs ys"
22:53:21 <luite> tommd: you don't need to install Cabal
22:53:35 <tommd> luite: If I want to upgrade it then yes, I do.
22:54:04 <luite> tommd: it comes with ghc, why do you need a different one?
22:54:05 <Saizan> the latest version of Cabal the library should be the one shipped with ghc-7.2
22:54:37 <Saizan> if you are talking about cabal-install then you need the darcs version of that
22:54:46 <tommd> luite: That was more of an example than a central issue.
22:55:39 <tommd> It's easy enough to fix (usually) but just a little frustrating.
22:56:00 <ddarius> tommd: Then use 7.0
22:56:03 <luite> if I had to guess, most packages have already been updated
22:57:09 <luite> I've submitted some patches to yesod to make it build, the release candidate (which has lots of deps) now almost installs with 7.2, the only thing missing is email-validate
23:00:33 <mister_m> I think I am starting to understand how the snippet I posted is really working
23:04:43 <ddarius> @tell edwardk I think I'll write that paper on (some of) the ideas in your algebra package.
23:04:43 <lambdabot> Consider it noted.
