00:12:18 <blackdog> so, if you wanted to interact with a restful web service, what would you use?
00:12:32 <blackdog> i've got a version written in ruby, but it'd be really nice to just distribute a statically linked binary
00:13:30 <shachaf> blackdog: There's always ruby2exe.
00:13:41 <shachaf> (Assuming it works; I've never tried it.)
00:14:14 <blackdog> shachaf: huh, not sure how i didn't see that
00:14:27 <blackdog> still, i'd like to see if it's reasonable to do with haskell libs too
00:14:55 <shachaf> What sort of requests do you do?
00:15:09 <shachaf> (How big is the Ruby script? Can you @paste it?)
00:15:09 <augur> does anyone know of any techniques for eliminating backtracking by enriching data?
00:15:27 <blackdog> shachaf: is reasonably big - uses a client api (about 200 lines)
00:15:49 <blackdog> does put, post, get, delete... session based auth
00:16:01 <blackdog> using restclient atm
00:18:15 <shachaf> Does Network.HTTP not do what you want?
00:21:04 <BlankVerse> compress (x:x:xs) = compress (x:xs)
00:21:19 <BlankVerse> i want to match with the list ehose first 2 elements are same
00:21:24 <blackdog> shachaf: might be enough. tbh, i didn't think to look at the basic libs.
00:21:40 * shachaf isn't sure what else you want a library to do.
00:21:47 <shachaf> You could @paste your Ruby script. :-)
00:21:56 <mauke> BlankVerse: (x : y : xss) | x == y
00:21:59 <shachaf> blackdog: You'll have to compare manually, I'm afraid.
00:22:00 <BlankVerse> but i get error that x:x:xs ....
00:23:09 <arcatan> blackdog: iirc, http-enumerator is sanest of the HTTP libraries
00:24:01 <kmc> BlankVerse, not all types have a notion of equality; what if it's a list of functions?
00:24:35 <kmc> mauke's solution makes explicit the fact that you're using (==)
00:30:58 <BlankVerse> x:y:xss matches all strings of length at least 2 or 1?
00:31:26 <BlankVerse> *lists
00:32:59 <kmc> at least 2
00:33:09 <kmc> there is one (:) per list element
00:33:28 <kmc> (it also matches all strings of length at least 2, because strings are lists)
00:33:48 <kmc> aside from special syntax, lists are an ordinary algebraic data type
00:33:52 <kmc> data List a = Nil | Cons a (List a)
00:34:06 <kmc> and that pattern desugars to (Cons x (Cons y xss))
00:34:35 <frerich> What does the 'algebraic' in 'algebraic data type' mean? As far as I can see, all types in Haskell are algebraic types, so it seems a bit superfluous?
00:34:39 <BlankVerse> compress [x] = x , doesnt work?
00:35:12 <mauke> I think functions aren't algebraic
00:35:14 <kmc> frerich, functions aren't algebraic
00:35:23 <mauke> and Integer
00:35:35 <kmc> neither is any type whose value constructors you can't see, in a sense
00:35:43 <kmc> you're not supposed to be able to tell if (IO T) is algebraic
00:35:52 <frerich> Do functions count as a 'data type' or just as a 'type'? I thought you meant 'data type' as in "types defined with 'data'".
00:35:54 <kmc> frerich, 'algebraic' means that it's built from 'sums' and 'products'
00:36:00 <BlankVerse> http://dpaste.com/586164/
00:36:16 <kmc> sums being the alternative constructors; products being the multiple fields in a constructor
00:36:21 <BlankVerse> to take care of single element lists ... i used compress (x:[]) = x
00:36:24 <kmc> i can go into more detail about why we'd call them that
00:36:28 <mauke> ok, then I'd say arrays are non-algebraic data
00:36:43 <mauke> BlankVerse: what's the type of compress?
00:36:56 <BlankVerse> mauke: [a] -> [a]
00:36:56 <kmc> frerich, I would not count functions as a data type in the most technical sense
00:37:04 <mauke> BlankVerse: x :: a, not [a]
00:37:06 <kmc> but I doubt i've been super consistent about that
00:37:25 <kmc> it's true that (->) is the most special type constructor in Haskell
00:37:55 <kmc> frerich, anyway you said "all types in Haskell are algebraic types"
00:38:05 <kmc> functions aren't algebraic types, whether or not you consider them to be data types
00:39:48 <johnnowak> hello all. is there a transformer like Control.Monad.Error.ErrorT that doesn't require I define a Control.Monad.Error.Class.Error instance? having to give a meaning to 'noMsg' and 'strMsg' is undesirable; i want a closed class of errors.
00:41:45 <kmc> johnnowak, you can drop the arg to strMsg
00:42:03 <kmc> it's mainly there so that "fail" invoked by pattern-match failure can provide something helpful
00:42:18 <kmc> alternately if you want pattern-match failure to kill the program, you can do "strMsg = error"
00:42:39 <johnnowak> ah, right. fail.
00:43:07 <johnnowak> unfortunate. thanks though.
00:43:33 <kmc> frerich, in GHC there's another sort of non-algebraic type: the unboxed primitive types
00:44:01 <kmc> in GHC, Int and such are algebraic data types wrapping those primitive types
00:44:10 <kmc> data Int = I# Int#
00:44:39 <kmc> but that's an implementation detail, albeit one that's quite useful for writing high-performance code
00:45:16 <kmc> you can't sensibly work with unboxed types in standard Haskell
00:46:26 <kmc> even if your implementation provides a module you can import to see unboxed types, you also have to extend the type/kind system for them to make sense
00:48:03 <zhulikas> http://pastebin.com/zWRZsKsf
00:48:07 <mauke> The paste zWRZsKsf has been copied to http://hpaste.org/49840
00:48:16 <zhulikas> can anybody help me solve this problem? I am following this tutorial: http://rizwanbulbul.blogspot.com/2010/06/installing-leksah-gtk-gtk2hs-and-glade.html
00:49:01 <zhulikas> Debian 5 x64
00:54:37 <pranjal> @help
00:54:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:59:13 <pranjal> Hi all, just getting started and I have a quick question: if I have a type like "data Shape = Line Orient | Square Orient | Blank", is there a way to define a function that takes a Line and returns a new Line with a different Orient, or a Square and returns a new Line with a different Orient, without writing the same code twice? It seems like I might be missing an idiom when describing my ADTs.
01:00:14 <opqdonut> no not really
01:01:12 <opqdonut> if you want to do lots of stuff like that you might want to do something like: data ShapeType = Line | Square | Blank; data Shape = Shape Orient ShapeType
01:01:40 <johnnowak> pranjal: you might write a "lifting" function with the type '(Orient -> Orient) -> Shape -> Shape' if you frequently find yourself operating on subcomponents like that
01:02:38 <pranjal> very cool. thanks for the help, I'll try those out and see which fits best, I think the lifting function works best in this case
01:02:42 <quicksilver> a third option:
01:02:52 <quicksilver> data Shape a = Line a | Square a | Blank
01:03:02 <quicksilver> and define the Functor instance
01:03:07 <opqdonut> that's a good one too
01:03:16 <pranjal> oh wow
01:03:30 <johnnowak> or use {-# LANGUAGE DeriveFunctor #-} and have it derive the functor for you :)
01:03:57 <pranjal> is that a ghc-specific thing? like a pragma for haskell?
01:04:03 <johnnowak> yeah, ghc-specific pragma
01:04:20 <johnnowak> it lets you add Functor to your deriving clauses in some cases like you can with Show and Eq and such
01:04:40 <pranjal> interesting, what would happen if I tried to call fmap with a Blank shape though?
01:04:56 <pranjal> would it just give me another Blank?
01:05:08 <dobblego> @type \a b -> do i <- a; b i; return i -- in the stdlib somewhere?
01:05:09 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> (b -> m a) -> m b
01:05:26 <johnnowak> pranjal: correct
01:05:55 <johnnowak> i think you may find a custom lifting function best.. making it a functor will let you create nonsense types like 'Shape String' which may make type error reporting clumsier
01:06:08 <pranjal> right, that makes sense
01:07:14 <aninhumer> johnnowak: What would happen if you had an ADT like data A a = B a a | C a for the B part deriving Functor?
01:07:42 <aninhumer> Would it map over both?
01:07:54 <quicksilver> yes.
01:08:04 <quicksilver> it maps over all the as in positive positions.
01:08:31 <aninhumer> positive positions?
01:08:43 <quicksilver> johnnowak: Actually experience suggests that custom types like 'Shape String' are very useful.
01:08:54 <quicksilver> johnnowak: or, more often Shape (Int -> Orient) and so on.
01:09:15 <quicksilver> aninhumer: data Example = Pos a | Neg (String -> a)
01:09:24 <quicksilver> erm, that's backwards
01:09:31 <quicksilver> aninhumer: data Example = Pos a | Neg (a -> String)
01:09:39 <aninhumer> Ah that makes more sense
01:09:40 <quicksilver> negative positions are on the left of an odd number of -> signs.
01:10:10 <aninhumer> an odd number? why that choice?
01:10:20 <aninhumer> I could see just, on the left of functions
01:11:15 <mauke> heh, "choice"
01:12:11 <aninhumer> Oh also what if you have a functor of a in there?
01:12:14 <mauke>  | NegNeg ((a -> Int) -> String)
01:12:26 <quicksilver> it's not a choise, aninhumer, it's a deep fact about mathematics ;)
01:12:45 <quicksilver> normal functors are positive so they're fine.
01:12:52 <quicksilver> they make no difference.
01:13:14 <aninhumer> In which case I'd say why is it called positive/negative?
01:15:58 <aninhumer> What's the connection to the mathematical property?
01:16:23 <quicksilver> -1 * -1 = +1
01:18:11 <aninhumer> Yes... but how are function arguments connected to that?
01:19:43 <johnnowak> aninhumer: it might help if you think about it in terms of subtyping
01:20:04 <johnnowak> for example, if you have a function of type Int -> Int, it is okay to pass it a natural (assuming you have subtyping)
01:20:34 <johnnowak> however, if you have a function of type (Int -> Int) -> Int, it is *not* okay to pass it a function that *requires* a natural
01:20:43 <asuaN>  #c#
01:21:12 <johnnowak> in a -> b, 'a' is a contravariant position... but in (a -> b) -> c, it is in a covariant position
01:22:58 <jasxon> Hello. When I import Data.Set, to use the \\ operator, do I have to use it qualified, as in Data.Set.\\, or something like that? or are operators special?
01:23:03 <johnnowak> aninhumer: ghc requires that all arguments be in covariant positions
01:23:14 <mauke> jasxon: no and no
01:23:47 <johnnowak> jasxon: importing without 'qualified' always brings everything that was exported into scope.
01:23:48 <jasxon> oh, it's a typeclass isn't it
01:24:14 <jasxon> but what happens if you have two functions with different types, does it choose based on type? as if it was overloaded?
01:24:23 <mauke> no
01:24:23 <johnnowak> no, you'll get an error
01:24:49 <jasxon> …so i do need to qualify it each time i use it?
01:24:56 <mauke> no
01:25:49 <jasxon> sorry, i'm not getting this. if i import into global, i will have two operators (functions) with different types. but that doesn't work as you say i'll get an error, so what do i do?
01:25:55 <johnnowak> .. yes, you will need to qualify it if they overlap
01:25:58 <mauke> why do you have two operators?
01:27:07 <jasxon> For example the \\ operator is defined for sets and lists
01:27:08 <aninhumer> jasxon: Oh, since it's a typeclass, if you define an instance of \\ for your type, it's fine
01:27:19 <mauke> aninhumer: what
01:27:30 <mauke> jasxon: don't import the \\ for lists then
01:28:07 <johnnowak> jasxon: i'd suggest importing things with 'import qualified' in most cases and then using 'import' only with an explicit list of things you want to bring directly into scope. that will stop problems with conflicts.
01:28:21 <jasxon> well say i'm using lists and sets in one module (very possible), do I then qualify Data.List as List and write "myList1 List.\\ myList2"
01:28:24 <johnnowak> you can then use names like (Data.List.\\) to refer to functions
01:28:25 <aninhumer> mauke: I missed the lists part, but otherwise was I right?
01:28:38 <mauke> aninhumer: that wasn't even wrong. it simply made no sense
01:28:58 <mauke> jasxon: yes, that's one way
01:28:59 <johnnowak> jasxon: correct
01:29:09 <blackdog> arcatan: thanks, i'll check http-enumerator out
01:29:12 <mauke> if you do need both operators, you can use at most one of them unqualified
01:29:15 <jasxon> can't the compiler see the two functions, see what types i'm calling it with, and work out which i want?
01:29:27 <mauke> no, it works the other way around
01:29:41 <mauke> the compiler sees which functions you call and deduces the required argument types
01:29:45 <aninhumer> mauke: I was thinking they had defined a custom function \\ and it was conflicting, in which case you'd potentially want to make it an instance method (although not in all cases)?
01:29:58 <johnnowak> jasxon: some languages can but ghc cannot. it would be quite difficult given the sort of type system that haskell has.
01:30:29 <mauke> jasxon: foo x = x \\ 42  -- what's the type of foo?
01:31:03 <jasxon> in that case, the compiler could ask my to clarify, but very often it can deduce it itself
01:31:08 <aninhumer> mauke: Oh I said instance of \\ ... I guess that's not really correct language
01:31:18 <johnnowak> jasxon: the real problem is that people insist on using the same silly operator names all over the place instead of english words that look reasonable when used in a qualified manner :)
01:31:37 <opqdonut> well there could be an implicit type class for every operator symbol
01:31:38 <johnnowak> somehow List.union is fine but List.difference would be a mortal sin
01:31:43 <jasxon> yeah, that's the only thing i was confused about, whether or not the qualified syntax worked with operators
01:31:49 <johnnowak> aye, it does
01:32:39 <johnnowak> i find the readability questionable though.. i'd use them in a prefix position
01:32:43 <johnnowak> e.g. (List.\\) a b
01:32:50 <johnnowak> but either way works
01:33:04 <aninhumer> Hmm, if List is a Set instance, wouldn't Prelude.\\ be the same as Set.\\ ?
01:34:00 <quicksilver> aninhumer: Set is a type. not a class.
01:34:17 <aninhumer> Oh, that had me confused
01:35:25 <dobblego> dmwit: ping
01:41:13 <dobblego> does anyone happen to understand dmwit's symmetric lenses? http://paste.pocoo.org/show/452431/
02:21:53 <mreh> when I darcs rm files, will a revert get them back?
02:22:19 <mreh> i.e. does it store removing files as a patch
02:26:39 <Lemmih> mreh: Yes.
02:27:05 <quicksilver> be a pretty poor excuse for a VCS if it didn't!
02:28:46 <merijn> heh, is there any VCS which does remove files from the history without 25 bazillion confirmation prompts?
02:29:30 <quicksilver> you mean expunge them from your entire history?
02:30:24 <merijn> yeah. Seeing how edit happy Git users are Git probably allows it, but I would expect at least some prompt are "yes, I really want you to do this"-flag for doing so
02:30:43 <quicksilver> the best way to do that in most VCSes of which I'm aware is probably to write a filter and pipe git-fast-export | filter | git-fast-import. Despite that use of the word 'git' lots of modern VCS support that same stream format.
02:31:26 <merijn> Yeah, we're actually exporting our hg repo to git to edit some history before importing back into hg and continuing our work :p
02:31:32 * quicksilver nods
02:31:43 <quicksilver> I had to do some contortion to remove one from bzr.
02:32:38 * shachaf should look into editing git history.
02:32:59 <shachaf> At one point someone checked some large files into a repository and now it's way bigger than it needs to be.
02:33:10 <aninhumer> I think git is globally compressed, so serialising it might even be necessary
02:33:13 <merijn> Whole bunch of files with unclear licensing or trade secrets which have to be nuked from the repo before we can finally open source our code :p
02:33:33 <aninhumer> Even if there's a tool implementation
02:33:39 <mistertim> Hi all - I have a quick question about class constraints on data declarations if that's ok - is there anyway to create a type eg data (Ord a) => OrdList a = OCons a | Nil such that the Ord constraint on the type parameter to OrdList for functions that take or return an OrdList can be inferred? I've looked into existentials, but they seem subtley different in that they actually 'hide' they type parameter.
02:34:28 <quicksilver> mistertim: depends excatly what you mean by 'can be inferred' but the short answer is no.
02:34:50 <quicksilver> although you can do something a bit like that by using GADT syntax and putting the constraint on the OCons constructor.
02:34:56 <mistertim> quicksilver / merijn: The problem with permanently deleting files from git in my experience is ensuring that they're deleted from every copy of the repo in existance, as (AFAIK) there's no way to permanently delete a file from history and have that change propogate to other copies of the repo when other users pull
02:35:07 <quicksilver> mistertim: yes, that's impossible.
02:35:16 <quicksilver> mistertim: rewriting history = new repo, incompatible with old.
02:35:38 <quicksilver> you can sorta see why. Otherwise you need a meta-VCS to control repository versions.
02:36:13 <aninhumer> In what situations do you actually need to edit history?
02:36:30 <sanjoyd> Leaked passwords and other sensitive information.
02:36:56 <sanjoyd> I do agree with mistertim; once you've leaked information, it is leaked. Nothing more can be done.
02:37:21 <mistertim> quicksilver: I meant that I can write type signatures eg 'first :: OrdList a -> a' without an explicit (Ord a), however, i suspected as much - thanks anyway!
02:37:58 <quicksilver> mistertim: the GADT approach would let you do that, in fact. But anecdotally I don't recommend it.
02:39:36 <mistertim> quicksilver: hmm, I've used GADTs elsewhere actually, but am finding that they're causing a whole new set of difficulties. I think I'll stick to writing explicit type sigs instead :-)
03:05:39 * hackagebot HaXml 1.22.3 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.22.3 (MalcolmWallace)
03:05:50 <dobblego> @tell dmwit is this correct? http://paste.pocoo.org/show/452467/
03:05:50 <lambdabot> Consider it noted.
03:08:20 <ptd> Are mutually recursive modules really a good idea?
03:08:40 <ptd> From what I've read they seem to cause a lot of trouble.
03:19:07 <hvr> ptd: what exactly have you read?
03:20:06 <ptd> hvr: ghc documentation describing .hs-boot files and {-#SOURCE#-} pragmas
03:20:18 <quicksilver> ptd: I have not yet found a program design which required them
03:20:27 <quicksilver> however, I've not written large programs with haskell
03:20:31 <quicksilver> so I may be missing the use case
03:20:34 <quicksilver> for now, I avoid them.
03:21:08 <ptd> Trivially recursive modules can be eliminated by combining them into a single one
03:21:28 <hvr> ptd: even less trivial ones... but the single module gets larger and larger =)
03:22:00 <ptd> I meant the process was trivial, as opposed to the modules
03:22:13 <hvr> ic
03:22:27 <ptd> That would be a sensible way to compile them
03:22:57 <ptd> draw dependency graph -> combine loops into a single module -> compile as if with out loops
03:23:20 <hvr> I have a larger haskell program, where I have a complex data structure which is graph-like; where various kinds of cycles are possible
03:23:50 <hvr> I started by keeping all type defs in the same module
03:23:57 <hvr> but it got kinda crowded
03:24:28 <ptd> why does that require cycles
03:24:31 <hvr> and I'm forced to merge multiple concerns into one module
03:24:53 <hvr> cause there are mutually recursive type references
03:26:21 <ptd> If a pair of data types are mutually recursive aren't they sufficient interconnected to merit being in the same module?
03:26:53 <hvr> that's one possible view
03:28:03 <erus`> i have a few functions on seperate lines
03:28:13 <erus`> i would like a where clause to apply to all of them
03:31:54 <Ptival> erus`, can't the where clause content exist by itself?
03:32:11 <erus`> yer but its ugly
03:32:21 <erus`> maybe you could give me some refactor tips
03:32:49 <Ptival> maybe not me, bu feel free to paste it on a website :)
03:32:57 <hpaste> erus` pasted “ugly code” at http://hpaste.org/49841
03:33:33 <erus`> the parseAL is only used by ReadAppList
03:33:47 <erus`> and i have these reArranges
03:33:52 <erus`> which are yuck too
03:41:07 <gienah> erus`: I'm kind of learning, so not sure I should suggest anything, here goes anyway: an idea for the where clause to apply more stuff is to use case, sequence of pattern matches, where
03:45:03 <quicksilver> I wouldn't worry particularly about functions which are only used by one small group of functions
03:45:08 <quicksilver> that's a natural state. just don't export them.
03:47:30 <erus`> quicksilver: what about those reArranges
03:47:37 <erus`> 'reArrange'
03:47:52 <erus`> whats the alternative?
03:48:44 <quicksilver> well personally I would generally not name something I only used once
03:48:52 <frerich> Sorry for being a bit off topic, I'm trying to explain some API decisions I made (in a Haskell program!) and wanted to stress that the program is robust even when being given malformed input, but it will always try hard to produce wellformed output. There was some english saying along the lines of "Be tolerant what you accept, be strict what you give out" or so, does anybody know the actual words?
03:49:06 <quicksilver> I'd just use lambda notation.
03:49:29 <quicksilver> frerich: Postel's Law
03:49:32 <quicksilver> frerich: http://en.wikipedia.org/wiki/Robustness_principle
03:49:39 <frerich> Ah!
03:49:46 <frerich> Yes, that's exactly what I had in mind, thanks!
03:49:51 <quicksilver> it is not unambiguously good advice though.
03:51:06 <erus`> ah anonymous funcs
03:54:12 <merijn> quicksilver: Postel's Law is what got us in the lousy mess of HTML support >.>
03:54:54 * Clint nods.
03:56:49 <jix> is there some clever algorithm to fit a polynomial to go through a given set of intervals?
03:57:21 <merijn> jix: You mean curve fitting?
03:57:28 <quicksilver> merijn: defenders of Postel's Law would argue that it was a abuse of it, not a use of it. But yes, exactly.
03:58:03 <jix> merijn: yeah... but I don't have points and want to minimize the error... but instead I have intervals and the curve has to be within all of them
03:59:51 <merijn> I would assume there are algorithms for it since Mathematica et al. do things at least similar to that, but beats me which algorithms you want to be looking at
04:00:18 <jix> I have a quantized version of a function and want to reconstruct it so that requantization results in exactly the same values
04:11:22 <erus`> if you could only have two types, what would you prefer? Tuple and Integer?
04:11:35 <erus`> (in a dynamicly typed language)
04:12:34 <merijn> Tuple, you can just constructs integers from there :)
04:12:47 <zomg> String and a Number type probably would be convenient
04:12:49 <aninhumer> If you only have two types, isn't that basically a static type which can be one of two?
04:12:49 <merijn> Peano SSSSZ Life <3
04:13:01 <zomg> You could represent most types of data relatively easily
04:13:33 <zomg> You could even have faked arrays =)
04:13:44 <mux> merijn: hahahaha, that is the geekiest joke I've ever read
04:13:47 <Ptival> If you just have Tuples, how do you construct something?
04:14:05 <merijn> mux: I stole it of course :p
04:14:22 <mux> I might do the same now :-P
04:14:23 <Ptival> with an empty tuple?
04:14:25 <merijn> Scrolled by on Twitter today and I've been waiting all day to use it :p
04:14:52 <merijn> Ptival: Nullary tuple! O:)
04:15:13 <aninhumer> If you only had a single size of tuple, you'd struggle to do anything I think?
04:15:27 <aninhumer> Without a null type
04:15:59 <Ptival> yeah, you need an inductive base case...
04:16:03 <merijn> You could construct an infinite integer :)
04:16:12 <merijn> It's tuples all the way down :)
04:16:14 <Ptival> :)
04:16:43 <Ptival> Please convert to my language, it has one type, one value, and you can't type it!
04:21:49 <aninhumer> If you're saying you could choose any size of tuple, isn't that basically a list? (In a dynamic language)
04:23:00 <mux> except that lists are homogenous while tuples aren't
04:23:10 <merijn> mux: Not in dynamic languages
04:23:31 <mux> yeah, I meant in haskell, and then realized that my comment was off-topic :-P
04:24:24 <merijn> Although in general the consensus is that lists in dynamic languages should be homogeneous too :p
04:24:30 <merijn> Always a fun question in #python
04:24:39 <merijn> "But why do we have tuples if we have lists?!?"
04:26:44 <erus`> @hoogle Either a b -> Bool
04:26:45 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
04:26:45 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
04:26:45 <lambdabot> Data.Graph.Inductive.Basic isSimple :: Graph gr => gr a b -> Bool
04:30:50 <Ptival> @hoogle either
04:30:50 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
04:30:50 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
04:30:50 <lambdabot> module Data.Either
04:31:30 <gienah> thunderrd: yes, taking a look
04:33:09 <merijn> Type theory question: What is the correct term? Elimination function/strategy/...? In the sense of eliminating a construction (datatype or whatever) from a term (e.g. or-elimination in logic)
04:36:19 <byorgey> merijn: just "elimination", or "elimination rule(s)" if you are talking about the judgments of a formal system.
04:36:58 <merijn> Actually, I think tactic might be the word I want
04:37:12 <byorgey> merijn: what is the context?
04:38:56 <quicksilver> a tactic is a step towards trying to get terms into some particular form (for some reason)
04:38:57 <merijn> Describing a generic elimination tactic (takes an arbitrary tactic, goal & term and refines the term based on the tactic and goal)
04:39:34 <merijn> quicksilver: Yeah, that's why I think I want tactic, but I had a blackout and forgot that name. I assume that's where my brain got "strategy" from :p
04:40:07 <merijn> Tactic, strategy...close enough, lets procrastinate! :>
04:41:32 <erus`> i like how if something builds in haskell it tends to work :)
04:41:47 <byorgey> merijn: "tactic" is more of a proof assistant word than a type theory word, but it does sound like that is the word you want =)
04:42:02 <byorgey> erus`: me too =)
04:42:18 <merijn> byorgey: Does anyone outside type theory and logic use proof assistants? :p
04:43:00 <byorgey> merijn: haha, yes, and also there are lots of type theory/logic people that don't =)
04:43:35 <osfameron> "It looks like you are writing a proof!"</clippy>
04:44:14 <merijn> osfameron: Surely that should be </epigram> :>
04:49:42 <erus`> why do people like anonymous functions?
04:50:17 <mreh> it's exciting
04:50:34 <Botje> because they read better
04:50:37 <mreh> sometimes I don't want to know their name
04:50:50 <Botje> map (\foo -> bar baz qux foo) vs map f where f = ...
04:51:20 <Botje> or sortBy (\a b -> length a `compare` length b) vs sortBy f where f = ...
04:51:21 <int-e> Botje: map (bar baz) vs, of course *g*
04:51:21 <gienah> I have heard the argument that they read better as the anonymous function can be placed where its used rather than later on in a where clause
04:51:31 <Botje> int-e: well, yes.
04:51:39 <int-e> Botje: err, bar baz qux.
04:51:54 <kalven> erus`: you wouldn't want to put a name on every expression, would you?
04:51:56 <NihilistDandy> mreh: I laughed so hard at that
04:51:57 <Botje> int-e: it took me a while before I started eta-reducing functions by myself
04:52:08 <mreh> NihilistDandy: :)
04:52:18 <int-e> @type compare `on` length
04:52:19 <lambdabot> forall a. [a] -> [a] -> Ordering
04:52:42 <mreh> :t on
04:52:43 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
04:52:47 <augur> beep
04:52:53 <mreh> :t liftA2
04:52:53 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
04:53:05 <mreh> nah
04:54:24 <mreh> :t (liftA2 .)
04:54:24 <lambdabot> forall a b c (f :: * -> *) (f1 :: * -> *). (Applicative f, Functor f1) => f1 (a -> b -> c) -> f1 (f a -> f b -> f c)
04:55:04 <qnikst> can you advice what packages are best to use in order to serialize data. I have data object contains Word of different size and bytesting of concrete size, and I need to get bytestring
04:55:25 <qnikst> there is Data.Serialize packages, Data.Put, Data.Put.Binary etc..
04:56:33 <jix> qnikst: I haven't tried many of them... but for what I did so far I was quite happy with cereal
05:00:14 <NihilistDandy> Is there ever a particular use for eta abstraction in a lazy language?
05:00:27 <NihilistDandy> Curiosity, not use case
05:01:10 <qnikst> jix: thanks, will try
05:03:36 <Ptival> NihilistDandy: might be worth the read, I didn't -> http://www.haskell.org/pipermail/haskell-cafe/2010-December/087782.html
05:05:07 <NihilistDandy> Is there anything the Cafe doesn't talk about at some point? :D
05:05:22 <Botje> monad slash fiction.
05:05:51 <merijn> New life goal!
05:07:01 <NihilistDandy> Botje: Oh, baby, let's do it applicative style
05:07:13 <merijn> Slowly the IO monad traced its fingers across State, I'll show you what I can fmap into you...
05:07:54 <NihilistDandy> Ooh, unsafePerformIO, unsafePerformIO
05:08:44 <Botje> and the next step is of course famous haskeller slash fiction
05:09:06 <NihilistDandy> "I'll show you why they call me "Hot and Spicy" Curry
05:09:07 <NihilistDandy> "
05:09:09 <merijn> @quote unsafePerformSex
05:09:10 <lambdabot> lispy says: "monads are like condoms, without them, it's unsafePerformSex"
05:10:11 <mreh> those jokes usually only come out at new years
05:10:12 <NihilistDandy> Side effects, indeed
05:39:13 <erus`> what is 4chan's favourite unix command? cp
05:40:20 <BlankVerse> map head $ group xs
05:40:30 <BlankVerse> what is the meaning of $
05:40:36 <merijn> @src ($)
05:40:36 <lambdabot> f $ x = f x
05:40:43 <erus`> BlankVerse: it replaces brackets
05:40:56 <BlankVerse> erus`: thanks
05:41:00 <erus`> map head $ group xs = map head ( group xs )
05:41:11 <merijn> BlankVerse: $ is just function application, but since infix operators have lower priority then function application it helps you avoid brackets
05:41:25 <tensorpudding> $ is like punctuation
05:41:32 <BlankVerse> is it same as head . group?
05:41:37 <merijn> No
05:41:42 <merijn> eh
05:41:42 <BlankVerse> ah got it
05:41:44 <merijn> maybe
05:41:44 <mbrochh> Hey guys. Learned PHP, C, C++ and Java at university. Used Java and C# for 6 years at a large corporation. Then started using Python 3 years ago (loving it like hell). Its time to learn something new. Should I learn Haskell? If so, why?
05:42:00 <BlankVerse> head . group is head ( group xs ) ?
05:42:02 <ion> (foo bar) (baz quux) = foo bar $ baz quux
05:42:04 <tensorpudding> you should learn haskell if you want to learn it
05:42:25 <mtrlt> what answer do you expect from a haskell channel? :-P
05:42:38 <merijn> BlankVerse: map head group xs -> (((map head) group) xs) and map head $ group xs -> (map head) (group xs)
05:42:42 <erus`> mbrochh: ask the same question in #c++
05:42:48 <erus`> then compare answers
05:43:14 <erus`> then stand on your head and count from 200 backwards
05:43:17 <ion> mbrochh: It’ll make you a better programmer in any language, just like learning any new language does. Especially one so much different than what you already know.
05:43:34 <ion> mbrochh: It’ll also make PHP, C, C++ and Java look even more inelegant to you. :-P
05:43:39 <merijn> mbrochh: I would say yes, because Haskell (and other functional languages) will force you to think differently about programming. I don't even write that much haskell, but I think my python and C code have become much better since learning it
05:43:40 <mbrochh> I did the tutorials and started reading the free oreilly book. It looks appealing to me. The thing is: I have no whatsoever knowledge about functional programming. It seems like a massively different way to think about programming...
05:43:53 <NihilistDandy> BlankVerse: The type signatures give it away
05:44:27 <ion> mbrochh: I’d recommend starting with LYAH.
05:44:29 <ion> @where lyah
05:44:29 <lambdabot> http://www.learnyouahaskell.com/
05:44:30 <mbrochh> I think I would need some kind of small sideproject to do in Haskell in order to keep myself motivated and keep it going. I just don't know which problems should be solved with Haskell that I can't solve with Python. And I wonder I if I could use it for anything that is related to web development, because that is my passion.
05:44:33 <merijn> mbrochh: It'll also show you a non-sucky static type system. I first learned Java then Python and thought static typing sucked, then I learned Haskell and realized its just the implementation of static typing in C/Java that sucks
05:44:43 <ion> merijn: Indeed
05:44:53 <merijn> I second Learn You a Haskell as a nice in-depth book introducing haskell and functional programming
05:45:02 <parcs> mbrochh: fp is really not that different
05:45:03 <merijn> (and third and fourth it as well)
05:45:49 <ion> mbrochh: Also, #haskell tends to be great for learners. :-)
05:45:52 <NihilistDandy> mbrochh: Yesod, happstack, snap, etc., etc.
05:45:55 <mbrochh> You guys are awesome. I'll eat that book and come back later with more stupid questions :)
05:46:01 <merijn> I kinda like Real World Haskell (the free oreilly one), but I think its more of a practical followup to LYAH then a good intro to haskell
05:46:06 <NihilistDandy> Haskell: We've got web development out the ass.
05:46:08 <Axman6> mbrochh: Project Euler is great for giving you lots of ideas on what to program next
05:46:20 * hackagebot aterm 0.1.0.1 - serialisation for Haskell values with sharing support  http://hackage.haskell.org/package/aterm-0.1.0.1 (ChristianMaeder)
05:46:27 <merijn> Because RWH glosses over lots of basic stuff which can leave you confused as a newbie
05:46:30 <NihilistDandy> merijn: Agreed
05:46:44 <NihilistDandy> Though I really want to pick up the new edition of Craft
05:46:47 <Axman6> mbrochh: also, if you want to get technical, every single problem that can be solved with python can be solved with haskell :P
05:46:50 <merijn> Also, LYAH clearly has superior illustrations :)
05:46:56 <NihilistDandy> Axman6: I was just gonna say that
05:47:00 <mbrochh> Axman6: I'm a very visual person and I totally suck at math. At a first glance haskell looks a lot like creation equations... would I need to be a math genious in order to pick it up and create something useful with it?
05:47:05 <NihilistDandy> merijn: Goes without saying
05:47:19 <Axman6> mbrochh: not at all, i'm certainly not
05:47:22 <merijn> mbrochh: No, people claim haskell is so formal and mathematical, but they're lying
05:47:23 <mbrochh> NihilistDandy: what do you mean? Is it an inside joke?
05:47:31 <erus`> I tried learning haskell for 2 weeks and then uninstalled the haskell platform because i was so annoyed with no side effects, but then i installed it again a week later and here we are...
05:47:32 <NihilistDandy> mbrochh: As long as you know what a zygohistomorphic prepromorphism is, you'll be fine.~
05:47:40 <Axman6> mbrochh: it is maths, but you don't have to think of it like that. i never do
05:47:40 <merijn> mbrochh: Reference to turing completeness
05:47:51 <NihilistDandy> mbrochh: Those are all web development frameworks
05:47:58 <NihilistDandy> Oh, that
05:47:59 <Axman6> erus`: what, inventing lisp again? :P
05:48:28 <erus`> no mine has pattern matching :D
05:48:33 <Axman6> there's a guy i know who's writing a python to haskell compiler, which is pretty cool
05:48:43 <merijn> mbrochh: As long as you're not intimidated by people going on a math binge in the channel you'll be fine. It's not that haskell requires you to know math to use it, it's just that math is more easy to do in haskell then in most other languages
05:48:47 <erus`> in your face lisp!
05:49:08 <mbrochh> NihilistDandy: oh, awesome, thanks!
05:49:09 <BlankVerse> (.) f g == g . f OR f . g
05:49:23 <ion> @src (.)
05:49:23 <lambdabot> (f . g) x = f (g x)
05:49:23 <lambdabot> NB: In lambdabot,  (.) = fmap
05:49:23 <merijn> And as a consequence of that (plus it being a research compiler) it attracts lots of theory/math geeks
05:49:24 <Axman6> BlankVerse: the latter
05:49:32 <ion> axman6: Huh. Why not use the languages themselves and FFI instead?
05:49:43 <BlankVerse> Axman6: i found it from type info  ... its unintutuive though
05:49:44 <Axman6> ion: why not?
05:49:45 <NihilistDandy> merijn: y helo thar
05:49:50 <BlankVerse> Axman6: any reason why type is so?
05:49:54 <NihilistDandy> I am such a theory/math geek :D
05:49:59 <Axman6> BlankVerse: what type?
05:50:09 <BlankVerse> (.) :: (b -> c) -> (a -> b) -> a -> c 	-- Defined in GHC.Base
05:50:26 <mauke> BlankVerse: your intuition is wrong
05:50:31 <NihilistDandy> ^^
05:50:38 <Axman6> > (show . length . (^2)) 7
05:50:38 <lambdabot>   No instance for (GHC.Num.Num [a])
05:50:38 <lambdabot>    arising from a use of `GHC.Real.^' at ...
05:50:40 <Axman6> uh
05:50:40 <NihilistDandy> That's how composition works in math
05:50:49 <Axman6> > (show . length . replicate 4) 7
05:50:50 <lambdabot>   "4"
05:50:59 <merijn> mbrochh: Two other reasons for learning haskell are the awesomeness of lambdabot and Hoogle :)
05:51:18 <Axman6> BlankVerse: NihilistDandy is right, it's how function composition works in maths
05:51:20 <NihilistDandy> @type ((.).(.))
05:51:21 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:51:22 <BlankVerse> mauke: seconded !
05:51:42 <NihilistDandy> @type ((.)$(.))
05:51:43 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
05:51:56 <Axman6> bloody Cale
05:51:59 <NihilistDandy> lol
05:52:08 <Axman6> i wasn't jokingh
05:52:10 <Axman6> -h
05:52:17 <merijn> BlankVerse: It helps to write out the type signature for . and its arguments on paper and manually do the substitution. Once you work it out you will go "ooooh!"
05:52:33 <Axman6> i'm sick of lambdabot using non-standard implementations of functions
05:52:37 <mauke> :t (P..) (P..)
05:52:38 <lambdabot> Couldn't find qualified module.
05:52:46 <mauke> :t (Prelude..) (Prelude..)
05:52:47 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
05:53:38 <Axman6> i don't mind having a bot that has the non-standard implementations, but don't do it in the one that everyone uses to teach newbies with
05:54:12 <NihilistDandy> @type uncurry (Prelude..)
05:54:13 <lambdabot> forall b c a. (b -> c, a -> b) -> a -> c
05:54:14 <merijn> I move that Haskell implements a system like Racket, where the language supports "difficulty levels"
05:54:30 <NihilistDandy> Axman6: Safety feature, I'm sure
05:54:41 <Axman6> ?
05:54:56 <NihilistDandy> merijn: So what's easy Haskell? Scheme?
05:55:00 <merijn> And at higher levels you can just use map instead of fmap, etc
05:55:22 <sanjoyd> Difficulty levels?
05:55:24 <sanjoyd> Like a game?
05:55:29 <merijn> NihilistDandy: map only accepts lists and fmap is a different function for functors. Supposedly because fmap's generic type would confuse newbies
05:55:40 <erus`> @hoogle <$>
05:55:40 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
05:56:15 <NihilistDandy> merijn: Oh, pshaw. fmap's not that complicated :D
05:57:19 <merijn> NihilistDandy: Just a trivial example. In Racket they actually have a simplified Racket-alike language for newbies and then you can ramp up to the hard/more generic stuff once you are no longer confused. It's a great idea imo
05:57:33 <NihilistDandy> Wow, that's kinda neat, actually
05:57:43 <NihilistDandy> Racket is my favorite Scheme, I think
05:57:49 <NihilistDandy> Chicken's not bad, either
05:58:41 <erus`> f 1 = 2
05:58:45 <erus`> f = id
05:58:49 <erus`> that should work
05:59:27 <mreh> miranda, that's like diet-haskell
05:59:33 <NihilistDandy> @let f = id
05:59:34 <lambdabot>  Defined.
05:59:38 <mokus> merijn: one could say that H98 is "easy Haskell", but arguably not easy enough
05:59:40 <mauke> @undefine
05:59:40 <ion> I agree with requiring the same level of pointlessness from all the definitions.
05:59:40 <Axman6> the reason it doesn't is likely because leaving off a parameter usually indicates the author did something wrong
05:59:41 <NihilistDandy> > f 1 = 2
05:59:42 <lambdabot>   <no location info>: parse error on input `='
06:00:05 <yitz> > f "this is a boring function"
06:00:06 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:00:06 <lambdabot>    `GHC.Show.Show a'
06:00:06 <lambdabot>      a...
06:00:13 <yitz> ?
06:00:24 <Axman6> f is already defined anyway
06:00:30 <Axman6> :t f
06:00:31 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
06:00:31 <yitz> @type "foo"
06:00:32 <lambdabot> [Char]
06:00:37 <Axman6> which mauke fixed i see
06:00:39 <yitz> @type f
06:00:40 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
06:01:01 <yitz> > f x
06:01:03 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:01:03 <lambdabot>    `GHC.Show.Show a'
06:01:03 <lambdabot>      a...
06:01:04 <NihilistDandy> erus`: As you see, it did not
06:01:13 <erus`> yeah but in theory
06:01:16 <yitz> @type id
06:01:18 <lambdabot> forall a. a -> a
06:01:19 <erus`> it should work
06:01:48 <erus`> im gonna write a compiler extension
06:01:52 <NihilistDandy> erus`: Why?
06:02:00 <NihilistDandy> Why should it work, that is
06:02:05 <mauke> NihilistDandy: why not?
06:02:57 <BlankVerse> so $ is a syntactic sugar to avoid brackets?
06:03:10 <NihilistDandy> mauke: Other than the parse error? :D
06:03:12 <mauke> BlankVerse: see above
06:03:15 <merijn> BlankVerse: Yes
06:03:21 <merijn> Well, no
06:03:22 <ion> Well, it has some other uses as well. And best not to overuse it to avoid brackets.
06:03:22 <mauke> NihilistDandy: the parse error was you trying to use '=' in an expression
06:03:26 <mauke> NihilistDandy: that's completely unrelated
06:03:33 <merijn> It's not syntactic sugar. $ is just a normal operator
06:03:40 <ion> > map ($ 42) [succ, id, negate]
06:03:41 <lambdabot>   [43,42,-42]
06:03:42 <NihilistDandy> mauke: I know. :P
06:03:48 <NihilistDandy> The main thing is the definition of id
06:03:53 <merijn> A function like any other function, but its goal is to avoid parenthesis, yes
06:04:02 <NihilistDandy> Though :/
06:04:03 <NihilistDandy> Hmm
06:04:06 * NihilistDandy shrugs
06:04:18 <NihilistDandy> Perhaps I'm just not ready to consider a world where 1=2
06:04:30 <RGW> lol
06:04:36 <ion> > foldr ($) 0 [(+1), (+2), (+3)]
06:04:37 <lambdabot>   6
06:05:01 <RGW> > sum [1,2,3]
06:05:02 <lambdabot>   6
06:05:10 <zygoloid> > let 1 = 2 in 1 + 1 -- NihilistDandy: don't worry, things still work out fine :)
06:05:11 <lambdabot>   2
06:05:16 <erus`> NihilistDandy: i have a function called transformTuple [v] = v    THEN      transformTuple = id
06:05:21 <mauke> > let 1 + 1 = 1 in 1 + 1
06:05:22 <lambdabot>   1
06:05:29 <NihilistDandy> MY MIND
06:05:30 <NihilistDandy> :D
06:05:30 <RGW> lol
06:05:34 <Botje> hax!
06:05:42 <ion> > foldr (.) id [(+1), (+2), (+3)] 0
06:05:44 <lambdabot>   6
06:06:04 <Botje> > let _ + _ = "a vague suffusion of yellow" in 5 + 4
06:06:05 <lambdabot>   "a vague suffusion of yellow"
06:06:13 <Phyx-> Anyone here use Cabal with  the Custom build type?
06:06:24 <ion> erus: No, transformTuple = head
06:06:36 <ion> erus: Actually, not that either. Sorry.
06:06:37 <erus`> > head []
06:06:38 <lambdabot>   *Exception: Prelude.head: empty list
06:07:02 <erus`> the point is i shouldnt have todo transformTuple a = a
06:07:24 <NihilistDandy> Sure, that's reasonable
06:07:43 <quicksilver> erus`: yes, it has been suggested before
06:07:54 <joebacklo> what does an exclamation mark in front of a type mean (and as an aside, do you know how hard it is to search for an exclamation mark operator?)
06:07:55 <quicksilver> (lift the restrictin that all equations have the same number of parameters)
06:08:09 <merijn> joebacklo: Unboxed type, I think
06:08:12 <dibblego> joebacklo: it is a strictness annotation, declaring the value strict
06:08:19 <Phyx-> it seems to me that cabal clean exibits a bug when the build type is custom. The generated Setup.exe tries to delete itself, which since it's being executed is not possible. so cleaning always 'fails'. Anyone else see this too?
06:08:22 <joebacklo> strict, as in always evaluated?
06:08:29 <BlankVerse> can i use hoogle from terminal?
06:08:32 <dibblego> joebacklo: evaluated to WHNF
06:08:37 <joebacklo> got it
06:08:39 <NihilistDandy> BlankVerse: Yes
06:08:42 <dibblego> BlankVerse: yes, cabal install hoogle
06:08:44 <NihilistDandy> cabal install hoogle
06:08:48 <NihilistDandy> Then hoogle data
06:08:50 <NihilistDandy> Then wait a bit
06:08:55 <NihilistDandy> Then have fun
06:09:03 <chenwl> how to run *.ghci file
06:09:14 <chenwl> there are ghci commands in *.ghci
06:09:26 <dibblego> chenwl: ghci will see it in the current directory and use it
06:09:27 <chenwl> like :load QC.hs
06:09:32 <dibblego> (also ~/.ghci)
06:09:44 <chenwl> dibblego: but there are many of it
06:09:45 <BlankVerse> haskell.org|2a01:4f8:121:6::10|:80...
06:09:45 <Axman6> chenwl: if it's haskell code, it needs to be .hs
06:10:05 <dibblego> chenwl: perhaps you can ln -s yourpreferred.ghci .ghci
06:10:11 <chenwl> Axman6: it is not haskell code, it is ghci commands
06:10:11 <BlankVerse> unable to get data ... ipv6 issue ?
06:10:24 <mbrochh> will i need an IDE for haskell? can I be productive and efficient using vim?
06:10:35 <BlankVerse> mbrochh: ofc
06:10:37 <merijn> mbrochh: I use vim, no problem so far
06:10:38 <quicksilver> you can be productive and efficient using vim.
06:10:38 <dibblego> chenwl: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/ghci-dot-files.html
06:10:38 <RGW> the best IDE for Haskel is vim
06:10:40 <NihilistDandy> mbrochh: emacs
06:10:45 <quicksilver> there aren't any really compelling IDEs for haskell yet.
06:10:45 <BlankVerse> mbrochh: vim + ghci , :wq and :r
06:10:51 <merijn> mbrochh: Of course I also use vim for C code :p
06:10:52 <quicksilver> although there are lots of people working on them
06:10:54 <RGW> leksah
06:10:54 <NihilistDandy> emacs + haskell-mode
06:10:57 <cpa> why is main of type IO () and not IO Int# where the Int would be the return value?
06:11:02 <RGW> how about leksah
06:11:04 <mbrochh> ok cool
06:11:05 <Axman6> any decent text editor is perfect for haskell work
06:11:10 <chenwl> dibblego: it works, but the comment was not ignored
06:11:17 <erus`> gedit
06:11:17 <BlankVerse> NihilistDandy: how do i get haskell-mode?
06:11:29 <merijn> cpa: Hysterical raisins, I think. (I've wondered the same myself)
06:11:32 <NihilistDandy> BlankVerse: I think it's on github.
06:11:36 <RGW> haskell-mode for vim is not working for me
06:11:36 <NihilistDandy> I'll find a link
06:11:45 <Axman6> cpa: it's actually IO a, its result isn't used anywhere. i believe there are functions for setting the return value passed back to C
06:11:45 <RGW> it's trash
06:11:48 <quicksilver> cpa: I suppose the haskell standard wasn't really thikning of the unix exit code style.
06:11:57 <quicksilver> cpa: you set the exit code explicitly.
06:12:06 <quicksilver> Axman6: AFAIK that's a GHC extension (IO a).
06:12:12 <quicksilver> the standard calls for IO ().
06:12:14 <Axman6> yeah? fair enough
06:12:26 <Axman6> doesn't really matter though
06:12:37 <merijn> quicksilver: Pretty sure that by now GHC *is* the standard :p
06:12:54 <NihilistDandy> BlankVerse: git pull git://github.com/pheaver/haskell-mode.git
06:13:07 <erus`> i wish debain/ubuntu would upgrade the default ghc
06:13:13 <gienah> RGW: on gentoo we think its here: http://projects.haskell.org/haskellmode-vim http://code.haskell.org/~wwolff/haskellmode/haskellmode-20101118.tar.bz2
06:13:15 <ion> Uncaught exceptions etc. affect the exit value, so it might come from something else than the result value of main anyway. Also, it would be annoying to have to return 0 in the end of every main.
06:13:29 <NihilistDandy> erus`: You could always build the 7.2 RC :)
06:13:48 <cpa> ion: fair enough
06:13:56 <erus`> it wouldnt build with the ghc i installed from apt-get
06:14:14 <NihilistDandy> :(
06:14:16 <erus`> it blows my mind that its so much easier to install haskell and cabal on windows
06:14:48 <NihilistDandy> Well, Gentoo and some other thing are the best supported Linux platforms right now, IIRC
06:14:51 <ion> Install them in Wine.
06:14:52 <RGW>  gienah: I haved tried haskell-mode. It doesn't work for me on ubuntu properly
06:14:52 * ion ducks
06:15:00 <Saizan> erus`: the generic linux binary doesn't work for you?
06:15:03 <NihilistDandy> What version does Debian force on you?
06:15:16 <erus`> ghc 6.*
06:15:23 <erus`> where * is forgotten
06:15:26 <RGW>  gienah: I think syntax-highlighting, folding and some key-bindings are enough to work
06:15:28 <NihilistDandy> :(
06:15:29 <gienah> NihilistDandy: might be a bit earlier, text (and sha-1 I think) fail to build with ghc 7.2rc1, we did find this early though, some other stuff builds
06:15:37 <quicksilver> merijn: no, it's not.
06:15:40 <quicksilver> merijn: but I know what you mean.
06:15:41 <dibblego> erus`: I use this http://paste.pocoo.org/show/452546/
06:16:45 <NihilistDandy> gienah: I think that last I bulit was 7.1.something. I've been meaning to pull the new sources and build the RC for fun :D
06:16:51 <NihilistDandy> *built
06:17:46 <erus`> f a = 123    <- is a still a pattern there?
06:17:49 <Botje> yes
06:17:57 <erus`> great
06:18:16 <gienah> NihilistDandy: one of the gentoo devs created an ebuild for one of the snapshots, so when 7.2rc1 came out we were ready to test it, found some issues the same day so ghc hq should have time to fix them, hoping 7.2.1 will be solid
06:18:54 <NihilistDandy> Sweet.
06:19:27 <ion> erus: One could also write that as: f _ = 123
06:20:02 <parcs> or f __ = 123 :P
06:20:07 <gienah> NihilistDandy: its neat how template-haskell 2.6.0.0 seems to have good backward compatibility
06:20:07 <BlankVerse> i am using emacs starter kit .. their is no .emacs file only .emacs.d directory .. where should i add the haskell-mode hook?
06:20:41 <alexandre_> BlankVerse: create a .emacs file
06:21:07 <NihilistDandy> gienah: I'm actually a bit surprised by that :D
06:21:14 <alexandre_> or run M-x customize-group something
06:21:15 <ion> 2600!
06:21:27 <parcs> and actually ghc omits the 'defined but not used' warning when an identifier is prefixed with an underscore
06:21:28 <NihilistDandy> BlankVerse: I'll paste part of my .emacs for you, if you like
06:21:45 * gienah just built Agata with trivial tweaks with template-haskell 2.6.0.0 ghc 7.2rc1
06:21:45 <BlankVerse> NihilistDandy: plz
06:21:49 <erus`> ion: i just needed a name for the arguements/pattern in a function
06:22:05 <erus`> but i didnt know if a plain old argument list was still called a pattern
06:22:26 <merijn> erus`: There are only patterns, some patterns just match everything of a certain type :p
06:22:57 <quicksilver> erus`: an argument *list* isn't a pattern
06:23:04 <quicksilver> erus`: ...it's several patterns
06:23:07 <quicksilver> one per argument
06:23:16 <quicksilver> f a b c = 1 -- three patterns
06:23:17 <ion> erus: _ or _something is the standard way to express a pattern for a throwaway value. It works both as documentation for the reader and to remove the compiler warning about an unused variable.
06:23:22 <quicksilver> f (a,b,c) = 1 -- one pattern
06:23:47 <erus`> whats "a b c" called in f a b c ?
06:23:56 <erus`> whats "a b c" called in f a b c = 1, i mean ?
06:24:24 <hpaste> NihilistDandy pasted “.emacs BlankVerse” at http://hpaste.org/49846
06:24:57 <ion> The parameters, for instance. Or the arguments.
06:24:59 <NihilistDandy> I didn't realize how huge my .emacs was and how tiny the haskell-mode part was
06:25:01 <quicksilver> erus`: a pattern list, in the formal grammar, IIRC.
06:25:17 <erus`> oh ok
06:26:00 <NihilistDandy> Jargon? In MY Haskell?~
06:27:33 <identity_> Wrangling standardese is a necessary skill for any programmer :P
06:30:12 <erus`> @hoogle Char -> Int
06:30:12 <lambdabot> Data.Char digitToInt :: Char -> Int
06:30:12 <lambdabot> Data.Char ord :: Char -> Int
06:30:12 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
06:30:19 <erus`> > ord 'a'
06:30:20 <lambdabot>   97
06:30:26 <benmachine> > fromEnum 'a'
06:30:27 <lambdabot>   97
06:31:17 <erus`> > map ord "hi!"
06:31:18 <lambdabot>   [104,105,33]
06:31:50 <NihilistDandy> Also, this: http://i.imgur.com/mwOmg.jpg
06:31:54 <erus`> in my language "hi!" = (104, (105, (33, ())))
06:32:16 <erus`> everything is an Integer, Tuple (any size) or a function
06:32:22 <erus`> so simple
06:32:24 <erus`> so beautiful
06:32:56 <NihilistDandy> erus`: But is it Turing complete?
06:32:56 <RGW> but rarely somebody wants to learn it :(
06:33:03 <mbrochh> wonderful. haskell can't be installed via apt-get on ubuntu 11.04... i can smell adventures along the road already :)
06:33:03 <RGW> and uses it
06:33:18 <RGW> I have installed it with apt-get
06:33:29 <RGW> apt-get install ghc6
06:33:39 <erus`> NihilistDandy: if haskell is then mine is
06:33:52 <merijn> It can't? Weird
06:33:55 <NihilistDandy> erus`: I don't think that's necessarily true
06:33:55 <merijn> Don't install ghc
06:34:00 <merijn> Install haskell platform
06:34:27 <ion> > let f base charFor = charFor <$> state ((snd &&& fst) . flip quotRem base) in evalState (fmap concat . sequence $ [ replicateM 3 $ f 26 (['A'..'Z'] !!), pure "-", replicateM 4 $ f 10 (['0'..'9'] !!) ]) <$> [0, 1, 2, 26^3*10^4-2, 26^3*10^4-1]
06:34:29 <lambdabot>   ["AAA-0000","BAA-0000","CAA-0000","YZZ-9999","ZZZ-9999"]
06:34:30 <RGW> merijn: I haved installed gh6 in ubuntu (on the corresponding haskell-site I was told so)
06:34:47 <merijn> RGW: haskell platform installs GHC + bunch of the more important libraries
06:34:52 <RGW> ion: Why do you use lambdabot, dont you have installed ghci?
06:35:02 <merijn> RGW: So it is recommended over installing GHC and everything manually
06:35:02 <ion> Switch State to RState and 1 results in AAA-0001 instead of BAA-0000.
06:35:03 <erus`> NihilistDandy: i have pattern matched functions and recursion
06:35:07 <NihilistDandy> RGW: ion likes to brag, obviously :D
06:35:08 <erus`> so i think yes
06:35:35 <NihilistDandy> erus`: I don't know if that'll do it.
06:35:49 <mbrochh> merijn: yep i tried to install haskell-platform - doesn't work
06:35:50 <RGW> merijn: evoke the download-page for haskell-platform. There I am told to install ghc from the package-sources
06:36:19 <mbrochh> merijn: RGW: same experience here... so installing GHC first, then haskell-platform
06:36:42 <erus`> @hoogle Int -> Integer
06:36:42 <lambdabot> Prelude toEnum :: Enum a => Int -> a
06:36:42 <lambdabot> Data.Bits bit :: Bits a => Int -> a
06:36:42 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
06:36:49 <RGW> merijn: is there a ubuntu-package for the haskell-platform?
06:37:10 <mbrochh> i think there is, but doesn't work with 11.04
06:37:58 <merijn> I went to the platform site, clicked linux, clicked ubuntu and that links to: http://packages.ubuntu.com/search?keywords=haskell-platform
06:38:05 <merijn> No clue if it works, though
06:38:15 <RGW> merijn: ok
06:38:24 <erus`> i wanna have either just anonymous function or just named functions... but which :(
06:38:33 <BlankVerse> meta-x haskell-hoogle doesnt work NihilistDandy
06:38:49 <BlankVerse> and no tab completion in haskell-mode for the ghci repl?
06:39:05 <RGW> merijn: there is also a ubuntu-package: haskell-platform - standard haskell libraries and tools
06:39:13 <mbrochh> merijn: RGW: for me it doesn't workL http://askubuntu.com/questions/44709/how-can-i-install-haskell-platform
06:40:07 <mbrochh> RGW: Someone further down that page recomments another ppa to install it...
06:40:42 <NihilistDandy> BlankVerse: Didn't you have trouble downloading the hoogle databases?
06:41:11 <NihilistDandy> And unfortunately, no, no tab-completion in the haskell-mode REPL. I usually just call a shell and use ghci there
06:41:12 <BlankVerse> NihilistDandy: yep .. does haskell-hoogle use the same hoogle cabal package?
06:41:18 <kamaji> Are there any good tutorials for Data.Graph/
06:41:19 <NihilistDandy> Yeah.
06:41:37 <BlankVerse> NihilistDandy: so you open up ghci and do :r
06:41:48 <mbrochh> RGW: But that doesn't work as well :)
06:42:26 <NihilistDandy> BlankVerse: That will reload whatever file you last loaded in that session
06:42:31 <dpratt71> I'm watching a video about algebras for monads; is there a Haskell analog to this concept?
06:42:52 <merijn> mbrochh: Well, for getting started with learning just GHC should be good enough, since that includes the very basics and GHCi, but for actually developing programs you'll probably want haskell-platform later
06:43:07 <mbrochh> merijn: ok
06:43:40 <mbrochh> merijn: actually learnyouahaskell recommends installing the platform right away :(
06:44:16 <byorgey> there's no reason not to.
06:44:45 <RGW> merijn: I have read the book online and I didn't recognize this recommendation
06:45:00 <RGW> there is a cabal-module: haskell-platform-test
06:45:03 <RGW> whats that?
06:45:36 <byorgey> @hackage haskell-platform-test
06:45:36 <lambdabot> http://hackage.haskell.org/package/haskell-platform-test
06:45:46 <byorgey> "A test system for the Haskell Platform environment"
06:45:56 <RGW> And?
06:46:07 <byorgey> I don't know, it runs some tests I guess
06:46:35 <RGW> I am installing it now, and these are no tests
06:46:40 <byorgey> looking at the source it looks like it just makes sure it can actually import every module that's supposed to be in the HP
06:46:44 <RGW> opengl, parseccombinators,
06:46:46 <RGW> ...
06:47:01 <yitz> @. hackage . faq
06:47:01 <lambdabot> http://hackage.haskell.org/package/Not enough arguments to @.
06:47:02 <byorgey> just to test that the HP has installed correctly.
06:47:02 <gienah> kamaji: there's an example: http://mathlesstraveled.com/2009/11/27/m-bracelets-code/
06:47:21 <yitz> @. @hackage @faq
06:47:21 <lambdabot> Plugin `compose' failed with: Unknown command: "@hackage"
06:47:42 <yitz> @. hackage faq
06:47:42 <lambdabot> http://hackage.haskell.org/package/The answer is: Yes! Haskell can do that.
06:47:42 <byorgey> gienah, kamaji: no idea if that example still compiles, it probably doesn't
06:48:14 <gienah> byorgey: I like the example anyway :-)
06:48:20 <byorgey> thanks =)
06:48:54 <merijn> byorgey: Well, if the haskell-platform install is currently broken on ubuntu then that would be a reason not to invest hours into getting it running now vs just grabbing GHC and getting started :p
06:49:26 <mbrochh> RGW: For installing under 11.04 you might check this out: https://bugs.launchpad.net/ubuntu/+source/haskell-platform/+bug/742052 at the very bottom is a workaround
06:49:43 <byorgey> merijn: ah, true, I missed the backstory it seems
06:49:46 <Ke> any way to create forall function that detatchs any constructor
06:50:06 <byorgey> Ke: I don't understand what you mean, can you give an example?
06:50:09 <Ke> or more like fmaps something inside
06:50:09 <RGW> I will have a look at it
06:50:44 <Ke> f (AnyConstructor x) g = AnyConstructor (g x)
06:50:54 <erus`> @type
06:50:54 <lambdabot> <no location info>: not an expression: `'
06:50:57 <erus`> @type .
06:50:57 <lambdabot> parse error on input `.'
06:51:04 <erus`> @src (.)
06:51:04 <lambdabot> (f . g) x = f (g x)
06:51:04 <lambdabot> NB: In lambdabot,  (.) = fmap
06:51:13 <mauke> Ke: what would its type be?
06:51:17 <byorgey> Ke: well, that can't possibly work for any constructor, since it depends on the type of x, how many arguments the constructor has, etc.
06:51:25 <byorgey> Ke: but you can make an instance of Functor for your data type
06:51:27 <kamaji> gienah: I found that, had a little trouble following it, but i'll have a go
06:51:36 <kamaji> gienah: also thanks
06:51:38 <erus`> (.) <- whats the real word for that?
06:51:44 <byorgey> erus`: compose
06:51:49 <Ke> obviously you can assume constructor with one parameter
06:52:11 <byorgey> Ke: *I* can, but the compiler can't
06:52:35 <byorgey> Ke: does making a Functor instance not work?
06:52:37 <Ke> byorgey: well it can, but it probably won't in standard haskell
06:52:41 <Ke> nope
06:53:00 <byorgey> Ke: why not?
06:53:10 <RGW>  mbrochh: lol, that was a nice hack. Thank you for the link
06:53:14 <RGW> it seems to work
06:53:18 <mbrochh> RGW awesome!
06:53:20 <Ke> I basically want to combine bitmaps with .|. for numbers that are within constructor
06:53:46 <mbrochh> RGW gonna try it tomorrow... that freaking huge download will not finish today and my virtualbox is running out of disk space anyways :)
06:53:48 <byorgey> Ke: what constructor?
06:54:07 <Ke> any 2 constructors of the same type
06:54:37 <RGW> mbrochh: you have just to replace 6.12.1+ with 6.12.4 in the mentioned file and everything works
06:54:38 <byorgey> Ke: why do you need to do it for any 2 constructors?
06:54:38 <hpaste> erus` pasted “Tom's language” at http://hpaste.org/49847
06:55:05 <byorgey> Ke: what you are asking for is impossible / does not make sense so I am trying to figure out what you are trying to do at a higher level
06:55:16 <byorgey> Ke: so I can help you figure out a way to actually do what you want
06:55:20 <Ke> byorgey: in order to avoid writing the same code for n different types
06:55:23 <mbrochh> RGW oh that was indeed a hack. if you go even further down they recommend to use the fixed package from the ubuntu proposal packages
06:55:58 <byorgey> Ke: what is the same code you would have to write? A Functor instance?
06:56:14 <Ke> yes
06:56:33 <byorgey> Ke: did you know that GHC 6.12 and later can automatically derive Functor instance for you?
06:56:35 <Ke> though actually functor won't do, I guess applicative would
06:56:54 <byorgey> oh, right, I see
06:57:00 <byorgey> Applicative cannot be automatically derived
06:57:40 <byorgey> well, the only way I can think to do it is to use a generic programming framework but that seems like it would be more trouble than it's worth
06:58:34 <erus`> in f (g x) what do we call (g x)? whats the name for something that should be evaluated first?
06:59:06 <quicksilver> an expression?
06:59:11 <byorgey> an argument?
06:59:11 <roconnor> a parameter?
06:59:12 <quicksilver> you are wrong to say it should be evaluated first.
06:59:28 * roconnor switches his vote to an argument
07:00:15 <erus`> can i just call it a thunk?
07:01:42 <erus`> actualy its not needed at all
07:01:46 <quicksilver> I don't know what you're trying to say, erus :)
07:01:55 <quicksilver> but you might be mixing the semantic with the operational.
07:02:01 <erus`> i am
07:02:01 <quicksilver> a thunk is a very operational description.
07:02:39 <erus`> i just forgot that i evaluate just before pattern matching
07:03:13 <erus`> not that im giving you much more context by saying that
07:04:58 <Ke> I guess class Bits is not derivable either
07:05:12 <erus`> wow this parser writes itself :D
07:05:40 <BlankVerse> is there any pidgin clone in haskell?
07:05:55 <BlankVerse> multi chat client
07:05:55 <erus`> my code to unwrap 1-tuples allready handles function applications in order
07:07:30 <merijn> BlankVerse: Check hackage?
07:09:36 * hackagebot intern 0.5.0 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.5.0 (EdwardKmett)
07:12:47 <mwc> Odd, cc-options in cabal build info aren't used to compile c-sources?
07:16:53 <dmwit> mwc: They should be.
07:16:54 <lambdabot> dmwit: You have 1 new message. '/msg lambdabot @messages' to read it.
07:16:59 <dmwit> ?messages
07:16:59 <lambdabot> dobblego said 4h 11m 17s ago: is this correct? http://paste.pocoo.org/show/452467/
07:17:12 <mwc> dmwit: yeah, I tracked it down to my foo.buildinfo file not being imported
07:20:07 <dmwit> ?tell dobblego Close. I added three lines on http://paste.pocoo.org/show/452575/ (marked --here).
07:20:07 <lambdabot> Consider it noted.
07:24:39 <sp3ctum> what's a good way to check if a character belongs to a specific set? if i were learning / using perl, i'd do it with a regex: e.g. [0-9]
07:24:55 <_Ray_> elem
07:25:35 <dmwit> Depends how the set is specified.
07:25:51 <dmwit> There's half-a-dozen character predicates available from the Unicode spec.
07:25:54 <dmwit> For example
07:26:00 <dmwit> :t isAlpha
07:26:01 <lambdabot> Char -> Bool
07:26:17 <sp3ctum> ah yeah elem is nice. thanks a lot!
07:31:06 <erus`> \f 1 -> 2    << could I call that a lambda
07:31:33 <Botje> yes
07:31:52 <dmwit> > (\f 1 -> 2) "hello!" 1
07:31:53 <lambdabot>   2
07:31:56 <Botje> it's just a pretty selective one :)
07:32:14 <Ptival> is there a Unicode character for top/bottom/join/merge? (as in lattice)
07:32:21 <dmwit> Of course.
07:32:27 <zhulikas> how can I provide input for readLn in Leksah?
07:32:53 <dmwit> http://en.wikipedia.org/wiki/List_of_logic_symbols
07:33:03 <quicksilver> > (\f 1 -> 2) "hello!" (+5)
07:33:04 <lambdabot>   *Exception: (==): No overloading for function
07:33:14 <Ptival> dmwit: thanks!
07:36:44 <erus`> map ($ 1) [\_ -> 2,\_ -> 3]
07:36:47 <erus`> > map ($ 1) [\_ -> 2,\_ -> 3]
07:36:48 <lambdabot>   [2,3]
07:37:24 <erus`> > (λ 1 -> 2) 1
07:37:26 <lambdabot>   Pattern syntax in expression context:
07:37:49 <erus`> my language allows lowercase λ
07:37:55 <erus`> lamdurp 1 - haskell 0
07:38:05 <osfameron> what's the uppercase lambda?
07:38:14 <erus`> /\ like that
07:38:27 <dmwit> erus`: Be careful. Greek programmers will be upset that they can't use half their words as variable names.
07:38:43 <erus`> that can fork
07:38:58 <erus`> i'll have a compiler switch or something
07:39:04 <dmwit> Λ <- a real upper-case lambda ;-)
07:39:41 <Ptival> ∧ Λ < have fun distinguishing :)
07:39:51 <erus`> what is this called '->'
07:39:56 <erus`> @type ->
07:39:57 <lambdabot> parse error on input `->'
07:39:58 <Ptival> implies?
07:40:11 <dmwit> It can be pronounced "to" if you like.
07:40:16 <dmwit> But it's called an arrow.
07:40:27 <erus`> in the context of \f 1 -> 2
07:40:59 <Ptival> my teacher used to say "arrow"
07:41:38 <erus`> i need a witty name
07:41:41 <erus`> for my language
07:42:23 <deech> Hi all, dumb question. Escaping the double quote in a string seems to render the escape character, for instance "\"hello\"" => "\"hello\"", but I want ""hello""
07:42:24 <zygoloid> erus`: "brev"
07:43:20 <int-e> deech: the Show instance for strings quotes the " characters.
07:43:24 <erus`> it is a dynamicly typed functional programming language that separates pure and impure code
07:43:48 <int-e> > let t = "\"hello\"" in (t, head t)
07:43:49 <lambdabot>   ("\"hello\"",'"')
07:44:11 <erus`> deech: do putStr
07:44:15 <erus`> it will escape it
07:44:17 <bscarlet> dmwit: Do Greek programmers really need to be so limited? If it were lexed similar to a keyword as opposed to punctuation, then only the single character keyword could collide with anything. Words of more than one character would be fine.
07:44:24 <deech> show "\"hello\"" => "\"\\\"hello\\\"\""
07:44:38 <erus`> > "\"\\\"hello\\\"\""
07:44:39 <lambdabot>   "\"\\\"hello\\\"\""
07:44:45 <deech> erus`: I need something that's not in the IO monad.
07:45:04 <int-e> > text "\"hello\""
07:45:05 <lambdabot>   "hello"
07:45:28 <dafis> > ['"','h','e','l','l','o','"']
07:45:29 <lambdabot>   "\"hello\""
07:45:30 <erus`> deech: its just show putting extra \'s in
07:45:34 <byorgey> deech: the string "\"hello\"" does not include \ characters.
07:45:35 <int-e> > text (show (show (show "hello")))
07:45:36 <lambdabot>   "\"\\\"hello\\\"\""
07:45:41 <byorgey> it is only printed out that way.
07:46:08 <byorgey> > fix show
07:46:09 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
07:46:14 <int-e> and printing is done using 'show' internally: print x = putStrLn (show x)
07:46:26 <int-e> > fix error
07:46:27 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
07:47:10 <mornfall> Anywhere I can find a RegexLike instance for Data.Text?
07:48:09 <quicksilver> instance RegexDontLike Quicksilver where error = "excessive overloading"
07:48:18 <erus`> the lambda wikipage calls '->' map to
07:48:52 <erus`> where is simon peyton jones when you need him?
07:49:03 <mornfall> quicksilver: Better than matchDataText.
07:49:52 <quicksilver> I would call it 'maps to'
07:49:53 <deech> byorgey: I just compiled and ran the program "main = print "\"hello\"" and it output "\"hello\"" to the command line.
07:50:01 <quicksilver> arrow is actually a slightly unusual symbol for maps to.
07:50:09 <deech> int-e: What module has that "text" command?
07:50:11 <quicksilver> the traditional one is x |-> x+1
07:50:12 <ion> > fix (error . show)
07:50:14 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
07:50:15 <byorgey> deech: right, because print calls show
07:50:30 <byorgey> deech: if you want it to output "hello" you should write   main = putStrLn "\"hello\""
07:50:36 <erus`> ok MapsTo it is :)
07:50:38 <applicative> deech, you printed "hello", do you want to write "hello" to screen?
07:51:26 <applicative> > ("hello", show "hello")
07:51:27 <lambdabot>   ("hello","\"hello\"")
07:51:39 <mornfall> quicksilver: Actually, most of Haskell sucks comes from insufficient overloading. :P
07:51:39 <ion> > iterate show "hello"
07:51:40 <lambdabot>   ["hello","\"hello\"","\"\\\"hello\\\"\"","\"\\\"\\\\\\\"hello\\\\\\\"\\\"\"...
07:52:11 <deech> applicative: I want to write '"hello"'. This is in the context of generating an html link programtically. I want to write `a<href="...">...</a>` where the 'href' attribute is quoted.
07:52:23 <applicative> > iterate show "is referred to by"
07:52:24 <lambdabot>   ["is referred to by","\"is referred to by\"","\"\\\"is referred to by\\\"\"...
07:52:37 <ion> That’s not how you escape HTML.
07:53:20 <mornfall> ion: He's not escaping HTML though.
07:53:38 <applicative> > "<a href=\"...\">...</a>"
07:53:39 <lambdabot>   "<a href=\"...\">...</a>"
07:53:44 <Lycurgus> Escape From HTML5 III with i dunno Vin Diesel mehbe
07:53:49 <byorgey> deech: so, you combine the string "\"hello\"" with other strings like "<a href=" and so on
07:53:50 <applicative> > text "<a href=\"...\">...</a>"
07:53:50 <lambdabot>   <a href="...">...</a>
07:53:57 <applicative> ^^^ like that deech?
07:54:05 <byorgey> deech: then eventually you take the string you've built and write it to a file or to the screen
07:54:24 <kizzx2> what are some practical use of fix?
07:54:26 <deech> applicative: exactly, which module is that from?
07:54:34 <byorgey> deech: but you write it directly using something like writeFile or putStr, NOT using print or show
07:54:36 <ion> kizzx2: Self-recursion with anonymous functions.
07:54:55 <deech> byorgey: true, maybe guess I shouldn't worry about it for my tests in ghci.
07:54:58 <applicative> oh, that was just Text.PrettyPrint .  I was using to emulate putStrLn in lambdabot
07:55:01 <deech> :i text
07:55:06 <byorgey> deech: indeed.
07:55:08 <kizzx2> ion: a short example?
07:55:16 <applicative> @type text
07:55:17 <lambdabot> String -> Doc
07:55:39 <deech> Thanks all! I think that solves my issues.
07:55:49 <ion> > fix (\f n -> if n > 0 then show n : f (n-1) else []) 10
07:55:50 <lambdabot>   ["10","9","8","7","6","5","4","3","2","1"]
07:56:15 <applicative> > map show [10..1]
07:56:16 <lambdabot>   []
07:56:23 <applicative> oh always forget that
07:57:00 <kizzx2> @type fix
07:57:01 <lambdabot> forall a. (a -> a) -> a
07:57:01 <applicative> sugar makes me stupid
07:57:12 <ion> > let f n = if n > 0 then show n : f (n-1) else [] in f 10
07:57:13 <lambdabot>   ["10","9","8","7","6","5","4","3","2","1"]
07:57:47 <kizzx2> @type (\f n -> if n > 0 then show n : f (n-1) else [])
07:57:48 <lambdabot> forall a. (Num a, Ord a) => (a -> [String]) -> a -> [String]
07:58:34 * shapr yawns
07:58:41 <shapr> Good Morning #haskell!
07:58:53 <mreh> you're awake early
07:58:55 <Lycurgus> yello shapr
07:59:24 <applicative> > let ion = (\f n -> if n > 0 then show n : f (n-1) else []) in ($10) $ fix ion
07:59:25 <lambdabot>   ["10","9","8","7","6","5","4","3","2","1"]
07:59:46 <shapr> mreh: It's a beautiful day for code! I spent six days in Portland OR, much of it writing fun Haskell code now. Now I feel good enough to write more Python for $
07:59:48 <RGW> > reverse [100..1]
07:59:49 <lambdabot>   []
07:59:56 <mauke> > [10, 9 .. 1]
07:59:57 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
08:00:03 <Lycurgus> at galois?
08:00:33 <shapr> Lycurgus: Nah, though I did meet up with SyntaxNinja for dinner.
08:00:46 <mreh> shapr: a hackathon?
08:01:10 <shapr> mreh: No, I was in Portland for a knitting conference, but I wrote Haskell code in my free time.
08:01:13 <kizzx2> ion, applicative: that's instructive, i think i know what it is intuitively now though i don't quite grok it yet
08:01:14 <milktrader> I have the following code in a file.hs. change x y = (x-y) /  x
08:01:17 * Lycurgus mental note: SyntaxNinja is a galois employee.
08:01:17 <kizzx2> thanks
08:01:18 <mreh> oh yeah, you said
08:01:32 <milktrader> and it works with or without change :: Double -> Double -> Double
08:01:56 <milktrader> is the function type templating necessary?
08:02:06 <mauke> templating?
08:02:21 <byorgey> milktrader: it isn't necessary, but it is recommended, because it helps you catch errors earlier
08:02:35 <milktrader> mauke: what is the correct term for the first part of a haskell function definition?
08:02:45 <c_wraith> it also makes some type errors clearer when you annotate them with their type
08:02:47 <byorgey> milktrader: "type signature"
08:02:49 <shapr> Though sometimes I write all my code first, and come back and add type signatures when it works, proving to myself that I understand what I wrote.
08:02:52 <c_wraith> err, with the types you expect them to have
08:02:58 <mauke> milktrader: the function name?
08:03:09 * applicative thinks 'knitting conference?'
08:03:10 <milktrader> got it, type signature ...
08:03:10 <mreh> what did you write?
08:03:19 * applicative thinks "lemon curry?"
08:03:22 <mreh> applicative: I think he is married
08:03:27 <shapr> applicative: Sock Summit 2011, I bought hardwood knitting needles!
08:03:46 <Lycurgus> 0.0
08:03:49 <milktrader> why did Haskell assume my function took doubles and not integers?
08:04:15 <byorgey> milktrader: because division / does not work on integers
08:04:24 <ion> :t \x y -> (x-y)/x
08:04:25 <lambdabot> forall a. (Fractional a) => a -> a -> a
08:04:37 <byorgey> milktrader: there is an integer division function but it is called div
08:05:00 <applicative> milktrader: it would only do that if it had to.  If its some number, ghci might default to Integer (not Int)
08:05:14 <byorgey> milktrader: in fact, as you can see from what ion wrote, \x y -> (x-y)/x will work on any Fractional type, not just on Doubles
08:05:48 <milktrader> byorgey I was trying change x y = (x-y) `div` x and I think it failed, which explains it
08:05:51 <shapr> Speaking of knitting, I haven't spent any time studiyng sigfpe's monadic knot theory notation, but from what edwardk says, I think it may be good for a knitting DSL.
08:05:57 <applicative> milktrader: it assumed Double in preference to Float, both being Fractional.
08:06:04 <byorgey> milktrader: change x y = (x-y) `div` x  is a valid definition
08:06:13 <byorgey> milktrader: but it will not work if you apply it to Doubles
08:06:35 <byorgey> > let change x y = (x - y) `div` x  in change 2 11
08:06:35 <lambdabot>   -5
08:06:38 <milktrader> byorgey: great, thanks
08:07:00 <mreh> there are concepts in haskell related to knitting I recall
08:07:02 <mreh> tying the knot
08:07:04 <byorgey> milktrader: FYI, for converting from Integer to Double there is the function 'fromIntegral'
08:07:22 <byorgey> milktrader: for converting from Double to Integer there are 'round', 'floor', and 'ceiling'
08:07:25 <shapr> mreh: good point
08:07:44 <applicative> knitting is sort of systematically not tying the knot, Id think
08:08:37 <bscarlet> applicative: wouldn't that be called "playing the field"?
08:08:57 <mreh> every jumper ends with just a single knot
08:08:57 <milktrader> I'll plan to tattoo type definitions to my arm until they become second nature
08:09:02 * applicative thinks, ok, I need a new syntax error to figure out....
08:09:35 <ion> I do knot understand any of that.
08:10:22 <mreh> tying the knot means getting married
08:11:08 <dumael> anyone here familiar with jhc's ffi ?
08:11:12 * applicative changes the wiki page on "tying the knot" to "Getting Married"
08:11:13 <ion> mreh: Yeah, referring to both restraints and a noose.
08:12:33 <jwoolard> Hello, anyone know of any tutorials/docs on creating new streamed functions using the vector package
08:13:39 <int-e> > let xs = 0 : 1 : zipWith (+) (tail xs) (tail (tail xs)) -- marrying each list element but the first to its successor, producing offspring?
08:13:40 <lambdabot>   not an expression: `let xs = 0 : 1 : zipWith (+) (tail xs) (tail (tail xs))...
08:13:44 <applicative> dumael, only to the extent of having once relicated http://mostlycode.wordpress.com/2010/07/28/its-jhcs-turn/ the most helpful jhc related post ever
08:14:19 <int-e> oh, too many tails. (and missing 'in xs', but that was obvious)
08:14:23 <mreh> that still messes with my head
08:14:53 * quicksilver wonders if int-e just defined marriage as "too many tails".
08:15:05 <int-e> I definitely did not.
08:15:12 <mreh> you need a zero at the front
08:15:24 <incluye> you need something before "xs" and after "let"
08:15:27 <incluye> wait, never mind
08:15:35 <int-e> I was more after the explanation of Fibonacci numbers as the number of offspring of a single pair of rabbits
08:16:27 <int-e> > let xs = 0 : 1 : zipWith (+) xs (tail xs) in xs -- this is what I wanted
08:16:28 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:17:14 <dumael> applicative: thanks, though I'm trying something a lot more.. 'unpleasant'. I have a C function that takes a StableName and returns a pointer to a haskell object (of an arbitary type) and jhc is whining.
08:18:45 * hackagebot monoids 0.2.0.4 - Monoids, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/monoids-0.2.0.4 (EdwardKmett)
08:21:45 * hackagebot alex 3.0 - Alex is a tool for generating lexical analysers in Haskell  http://hackage.haskell.org/package/alex-3.0 (SimonMarlow)
08:23:20 <siracusa> .oO(New alex version with unicode support?)
08:24:52 <erus`> > id \f -> 1
08:24:53 <lambdabot>   <no location info>: parse error on input `\'
08:25:21 <int-e> siracusa: possibly. there's a UTF8 module.
08:25:25 <ion> erus: Alas, Haskell doesn’t support that syntax.
08:25:29 <ion> > id (\f -> 1) 42
08:25:30 <lambdabot>   1
08:25:38 <erus`> yer i was just checking :)
08:25:49 <int-e> > id $ \f -> 1
08:25:51 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t1)
08:25:51 <lambdabot>    arising from a use of ...
08:25:56 <cpa> http://hpaste.org/49849 : is there an easy fix for this?
08:26:19 <applicative> > id $ \f -> 1 $ 2
08:26:19 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> b)
08:26:19 <lambdabot>    arising from a use of `...
08:27:07 <applicative> > id $ head [\f -> 1] $ 2
08:27:08 <lambdabot>   1
08:27:59 <int-e> cpa: there's a MonadFix class and an mdo syntax for that
08:28:27 <ion> > let f = do { b <- f; return ('a':b) } in runIdentity (take 5 <$> f)
08:28:28 <lambdabot>   "aaaaa"
08:28:44 <ion> It works if the >>= operator of your monad is not too strict. Many of them are.
08:29:18 <shapr> in fact, there's edwardk even now!
08:29:32 <shapr> Is there some good way to put strictness properties in the type?
08:30:03 <cpa> that means that I have to understand MonadFix. I guess it was bound to happen
08:30:06 <cpa> thanks
08:30:31 <shapr> :t fix
08:30:32 <lambdabot> forall a. (a -> a) -> a
08:30:34 <shapr> :t break
08:30:35 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:30:39 <shapr> :t fix $ break
08:30:40 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
08:30:40 <lambdabot>       Expected type: a -> Bool
08:30:40 <lambdabot>       Inferred type: [a] -> ([a], [a])
08:31:07 <mauke> you don't need to understand mfix to use recursive do
08:33:32 <ion> > take 5 <$> mfix (\b -> return ('a':b))
08:33:33 <lambdabot>   No instance for (GHC.Show.Show (f [GHC.Types.Char]))
08:33:33 <lambdabot>    arising from a use ...
08:34:19 <ion> > take 5 <$> mfix (\b -> return ('a':b)) :: Maybe String
08:34:20 <lambdabot>   Just "aaaaa"
08:34:39 <ion> > take 5 $ fix (\b -> 'a':b) :: String
08:34:40 <lambdabot>   "aaaaa"
08:36:38 <int-e> oh, mdo is deprecated. http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html#recursive-do-notation
08:37:47 * hackagebot semigroups 0.6.1 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.6.1 (EdwardKmett)
08:45:22 <hpaste> unsafePerformIO pasted “solve Mutually recursive modules” at http://hpaste.org/49850
08:45:30 <edwardk> int-e: isn't that only because it is being replaced with some rec do thing?
08:45:48 * hackagebot semigroupoids 1.2.2.4 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.2.2.4 (EdwardKmett)
08:46:30 <int-e> edwardk: yes, it's a syntactic change - probably related to the Haskell' discussion.
08:47:06 <hpaste> unsaf annotated “solve Mutually recursive modules” with “solve Mutually recursive modules (annotation)” at http://hpaste.org/49850#a49852
08:50:39 <hpaste> applicative annotated “take 5” with “take 5 (annotation) (annotation)” at http://hpaste.org/49849#a49853
08:51:07 <unsafePerformIO> I have a problem with mutually recursiv modules. see: http://hpaste.org/49850. (had some problems with hpaste)
08:51:17 * applicative curses DoRec syntax
08:52:46 <applicative> cpa, surely 'blobMRec' is too complicated ^^^
08:53:25 <cpa> indeed
08:53:27 <cpa> !
08:55:42 * mokus curses the absence of unsigned integer types in the Prelude (and in particular the rampant abuse of Int where Word would be saner)
08:56:54 <ion> http://hpaste.org/49849#a49854
08:57:44 <quicksilver> mokus: Word isn't really that sane though, for the purpose of unsigned integer
08:57:49 <deggis> uh-oh. i just realised why the topic has funny syntax. feeling being slower than a rock
08:58:01 <quicksilver> it's reasonably sane for 'representation of bytes'.
08:58:07 <quicksilver> > (-1) :: Word
08:58:07 <lambdabot>   18446744073709551615
08:58:17 <mokus> quicksilver: for purposes of list length it generally is
08:58:44 <mokus> quicksilver: it would definitely be nice to have a Natural type as well though
08:59:05 <mokus> quicksilver: the ghc+gmp situation has thwarted my past attempts to make one though
08:59:10 <mauke> deggis: because we're Web 2.0 compatible, JSON, etc
08:59:30 <quicksilver> I don't really know if it's worth having lists return a type which is forced to be non negative
08:59:42 <quicksilver> do you want to lose the ability to subtract lengths?
09:00:11 <unsafePerformIO> mokus: yes, unsigned int's are more natural than int's
09:00:13 <mokus> quicksilver: i suppose that's a good point
09:00:20 <int-e> > let s = iterate (\x -> x Seq.>< x) (Seq.singleton ()) in drop 62 $ map Seq.length s
09:00:21 <lambdabot>   [4611686018427387904,-9223372036854775808,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:00:35 <mauke> /ban unsafePerformIO
09:02:45 <deggis> mauke: first in my mind was data Topic = [String] deriving(Show), but actually yes, that could just anything
09:03:06 <mauke> deggis: that would have to be 'type Topic = [String]'
09:03:13 <mauke> and yes, that's what it is :-)
09:03:14 <deggis> (syntax error in that)
09:03:26 <mauke> it just happens to be valid javascript as well
09:03:30 <mauke> and probably python and perl
09:03:42 <deggis> jeah. and many many things
09:03:53 <mauke> but not php because php is "special"
09:05:15 <deggis> i could now print an eventful curve of my feelings toward the topic, feeling kinda neutral again
09:08:35 <int-e> valid C, too ;-) http://pastebin.com/EG91f4EU
09:08:38 <mauke> The paste EG91f4EU has been copied to http://hpaste.org/49855
09:08:56 <int-e> tsk.
09:09:35 <int-e> mauke: you're faking names.
09:10:04 <mauke> where?
09:10:21 <int-e> Simple. I did not paste that.
09:10:29 <mauke> you're still the author
09:11:21 <int-e> I might be. But how can you infer that from a link?
09:12:31 <zhulikas> can I write function declarations with data? or should I use only type keyword?
09:12:43 <erus`> how did you guys get into programming?
09:13:03 <earthy> erus`: my dad brought home an Apple II
09:13:13 <Eelis> erus`: i wrote a time travel program and travelled back in time to before i was a programmer, and took up programming
09:13:21 <earthy> with almost *no* software but for a basic interpreter
09:13:51 <earthy> so that was loads of fun ;)
09:14:01 <zhulikas> I started with scripting mIRC to support some game projects hehe
09:14:34 <accel> so I'm writing a real time audio API for haskell on OSX
09:14:38 <erus`> I bought this package called DIV games studio thinking it would be some click and drag maker thing. Turned out it was a weird parallel dialect of BASIC, and i had never seen source code before so i was like wtf is this shit
09:14:38 <earthy> caught a bug that hasn't left me in the oh... 27-ish years since
09:14:44 <accel> for the FFI, pretty much any function that is not pure should ahve type IO a ?
09:14:53 <earthy> accel: yup
09:15:13 <unsafePerformIO> when did hpaste.org become "new"? It works different than the last time I used it.
09:15:47 <c_wraith> unsafePerformIO: chrisdone has been updating it frequently since he took over running it
09:16:27 <applicative> unsafePerformIO: it's been up for some time, now, the chrisdone version
09:16:41 <applicative> tarted up with hlint etc.
09:17:29 <applicative> oh ion put up the correct blobMRec
09:18:02 <unsafePerformIO> ok, had some problem when pasting, and I could not re-edit paste. And when choosing channel #haskell, it automatically wrote her.
09:19:40 <applicative> unsafePerformIO, well, you can always paste at your preferred paste site, then mention the paste here, than mauke's mystery bot will take care of it.
09:20:30 <mauke> no
09:20:35 <unsafePerformIO> applicative, yes, the sideeffects on hpaste came as a surprise for me
09:20:43 <mauke> I don't work * -> hpaste.org
09:20:49 <mauke> it's pastebin.com -> *
09:21:11 <monochrom> but perhaps "your preferred paste site" = "pastebin.com"
09:21:11 <applicative> hm: http://pastebin.com/RjFZSmHz
09:21:13 <mauke> The paste RjFZSmHz has been copied to http://hpaste.org/49856
09:21:40 <applicative> see mauke, you work just fine
09:22:03 <erus`> but what about when mauke goes to bed?
09:22:21 <monochrom> then no more translation
09:22:27 <mauke> don't worry, I never sleep
09:22:45 <monochrom> do worry, because all good things come to an end
09:22:53 <unsafePerformIO> monochrom: and I will not get /ban
09:24:19 <unsafePerformIO> mauke: why did you write "/ban unsafePerformIO"?
09:24:40 <mauke> because unsafePerformIO should be banned, obviously!
09:24:46 <copumpkin> I agree
09:24:49 <monochrom> hahaha
09:24:55 --- mode: ChanServ set +o copumpkin
09:25:01 --- mode: copumpkin set +b unsafeCoerce!*@*
09:25:05 --- mode: copumpkin set -o copumpkin
09:25:10 <unsafePerformIO> because of what?
09:25:28 <applicative> why doesn't it work with http://sprunge.us/SEHZ?haskell mauke?
09:25:33 <monochrom> because your nick invites puns :)
09:25:35 <applicative> what kind of a bot are you?
09:25:35 <copumpkin> we strongly discourage the use of unsafePerformIO
09:25:40 <zhulikas> how can I get String value of Int?
09:25:45 <copumpkin> show
09:25:48 <mauke> applicative: see above
09:25:48 <copumpkin> > show 5
09:25:49 <lambdabot>   "5"
09:25:51 <zhulikas> it gives me an error
09:25:58 <zhulikas> when I try to print to console
09:26:07 <monochrom> it's the same as: on every co-Halloween we go smash copumpkin
09:26:13 <copumpkin> :'(
09:26:15 <applicative> mauke, yes we agree on the facts
09:26:21 <int-e> /nick reallyUnsafePointerEquality ... probably a bit too long.
09:26:29 <mauke> applicative: because pastebin.com must die
09:26:37 <zhulikas> http://hpaste.org/49857
09:26:40 <applicative> it's pretty gross.
09:26:57 <monochrom> err sorry, on co-Halloween we draw communting diagrams on copumpkin. it's co-Christmas when we smash :)
09:26:59 <mauke> zhulikas: show gives you a string, yes
09:27:00 <zhulikas> gives error on line 10
09:27:03 <zhulikas> oh...
09:27:06 <mauke> zhulikas: but you still need to print that string
09:27:09 <zhulikas> ok :D
09:27:11 <zhulikas> thanks
09:27:21 <unsafePerformIO> well, I tried to choose a haskell name for my nick, because I mainly use irc for haskell. maybe I should change it?
09:27:22 * int-e wonders about http://pastebin.com/RjFZSmHz
09:27:26 <mauke> @src print
09:27:27 <lambdabot> print x = putStrLn (show x)
09:27:34 <zhulikas> putStr (show (product input1 input2))
09:27:36 <zhulikas> \o/
09:27:43 <monochrom> #python agrees that pastebin.com should die. it has a bot doing the same thing as mauke
09:27:58 <mauke> int-e: hasn't come up yet
09:27:59 <zhulikas> what's up with pastebin.com? I kinda like it :)
09:28:05 <mauke> zhulikas: you're fired
09:28:09 <zhulikas> haha :D
09:28:19 <monochrom> it's a revelation to me that two antipodal communities can agree on one point :)
09:28:36 <zhulikas> mauke, well, I came from Java community :D
09:28:49 <zhulikas> I have a different position
09:28:55 <mauke> enjoy your visual aids
09:30:15 <monochrom> mauke: suppose I make up a non-existent pastebin url, what will your script do?
09:30:15 <zhulikas> yay! My first Haskell program works! it computes the product of two input numbers \o/
09:30:25 <mauke> int-e: try again
09:30:34 <dylukes> zhulikas: now sanitize input.
09:30:36 <applicative> excellent sale on wedding rings on pastebin.com today
09:30:59 <monochrom> webbing rings?
09:31:11 <monochrom> webbing rings are web-scale
09:31:13 <mauke> zhulikas: main =  liftM2 (*) readLn readLn >>= print
09:31:20 <int-e> mauke: I thought it was just that the same paste had already been mentioned before ;)
09:32:36 <applicative> @type (*) <$> readLn <*> readLn >>= print
09:32:37 <lambdabot> IO ()
09:33:02 <mauke> :t join (liftM2 (*)) readLn >>= print
09:33:03 <lambdabot> IO ()
09:33:09 <zhulikas> mauke, that's elegant!
09:33:32 <zhulikas> anyhow, I know nothing about monads, so...
09:33:48 <monochrom> (*) <$> star <*> spangled <*> banner
09:34:02 <zhulikas> :t liftM2
09:34:03 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:34:19 <mauke> someone mention a pastebin.com url again, preferably in an action
09:34:25 <mauke> @src liftM2
09:34:26 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:34:46 <zhulikas> bla bla I mention pastebin.com again
09:34:52 <zhulikas> nothing happens \o/
09:35:08 <erus`> http://pastebin.com/Yz78U1Um
09:35:10 * applicative compiled main = (|readLn * readLn|) >>= print  with the new `she` preprocessor
09:35:10 <mauke> The paste Yz78U1Um has been copied to http://hpaste.org/49858
09:35:30 <applicative> thanks mauke
09:35:53 <mauke> zhulikas: that wasn't a url
09:40:10 <zhulikas> http://pastebin.com/Yz78U1U1
09:40:19 <zhulikas> it doesn't work
09:40:23 <zhulikas> you broke it.
09:41:38 <mauke> no, it says http://pastebin.com/Yz78U1U1 - 404 Not Found
09:41:48 <mauke> but error output doesn't go to the channel so you can't see it
09:42:33 <monochrom> good
09:44:51 <applicative> i see under 'trending pastes' there are 20000 views of one from yesterday, an irc log...
09:45:16 * applicative wants 'trending pastes' on hpaste!
09:45:59 * int-e wants a meta-pastebin that picks some other pastebin at random and posts the contents there.
09:46:03 <zhulikas> @src >>=
09:46:03 <lambdabot> Source not found. stty: unknown mode: doofus
09:46:08 <erus`> auto submit to /r/haskell and stackoverflow
09:46:15 <int-e> zhulikas: depends on the monad.
09:46:32 <zhulikas> :t >>=
09:46:33 <lambdabot> parse error on input `>>='
09:46:44 <int-e> @type (>>=)
09:46:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:46:48 <zhulikas> thanks
09:46:57 <int-e> (:t is fine.)
09:47:36 <zhulikas> hehe I still can't understand anything of this type declaration :D
09:48:07 <applicative> zhulikas, but suppose it said [a] -> (a -> [b]) -> [b]
09:48:13 <kmc> for (>>=) ?
09:48:14 <applicative> @type concatMap
09:48:14 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
09:48:26 <applicative> @type flip concatMap
09:48:27 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
09:48:28 <kmc> you should ignore "forall (m :: * -> *) a b."; it's GHC-specific and is mostly noise
09:48:37 <zhulikas> @type forall
09:48:38 <lambdabot> Not in scope: `forall'
09:48:48 <kmc> i can explain it if you want, but it's not important here
09:48:57 <kmc> 'forall' is syntax added by GHC
09:48:57 <applicative> zhulikas: just ignore it, begin reading after the dot .
09:49:19 <applicative> zhulikas, its illegal its not really haskell it's ghc heterodoxy
09:49:37 <applicative> zhulikas, does [a] -> (a -> [b]) -> [b] seem okay as a signature?
09:49:38 <zhulikas> kmc, I'll figure it out myself somehow, but thanks. :)
09:50:35 <kmc> so (>>=) is a family of functions with types like «[a] -> (a -> [b]) -> [b]» and «Maybe a -> (a -> Maybe b) -> Maybe b» and «IO a -> (a -> IO b) -> IO b» etc
09:50:56 <kmc> the 'm' type variable can be instantiated to any type which is an instance of the type class named "Monad"
09:51:04 <applicative> (>>=) is a good function for a type to support.
09:51:06 <zhulikas> guys, I can't read this stuff. It's just a bunch of arrows and letters for me :D
09:51:07 <kmc> any type constructor, that is
09:51:18 <zhulikas> I'll google for some constructive cookbook style tutorial on Haskell
09:51:25 <kmc> zhulikas, programming
09:51:25 <applicative> zhulikas: does Int -> Char make sense?
09:51:34 <applicative> @type chr
09:51:35 <lambdabot> Int -> Char
09:51:36 <zhulikas> applicative, it does :|
09:51:50 <applicative> @type show
09:51:51 <lambdabot> forall a. (Show a) => a -> String
09:51:59 <applicative> wait, try
09:52:03 <applicative> @type reverse
09:52:04 <lambdabot> forall a. [a] -> [a]
09:52:12 <kmc> zhulikas, i don't recommend learning Haskell in cookbook style
09:52:15 <zhulikas> ok, forall a means for any type of variable?
09:52:21 <_Ray_> for any type, yes
09:52:25 <zhulikas> oh, ok :)
09:52:28 <zhulikas> that makes sense
09:52:28 <applicative> exactly
09:52:31 <kmc> yes, but we already said you should ignore the "forall" stuff up to the dot
09:52:32 <kmc> to begin with
09:52:33 <_Ray_> f: a -> b means a function taking an a, and returning a b
09:52:44 <_Ray_> f: Int -> Char means it takes an Int, and returns a Char
09:52:53 <_Ray_> f: a -> Char means it takes _anything_, and returns a Char
09:53:09 <zhulikas> so show function is like a type casting?
09:53:24 <_Ray_> It means it's "polymorphic": it acts on many types.
09:53:35 <ion> No, it’s for serializing a value into a string.
09:53:36 <applicative> zhulikas, it's like in algebra class you write "x + 1 = 1 + x" meaning: its true for all of them; in logic class you write "for all x, x+1 = 1 +x" the differences only arise in special contexts
09:53:48 <_Ray_> For instance (+) acts on Int, on Integer, Double, etc...
09:54:31 <_Ray_> the stupidest function would be id. id x = x. it does nothing to its input. the type of id is id :: a -> a. For every element of any type a, it returns some element of the same type, a.
09:54:44 <applicative> zhulikas, if it 'show' were casting then show "hello" would be "hello", no?
09:54:51 <applicative> > show "hello" == "hello"
09:54:52 <lambdabot>   False
09:55:00 <zhulikas> hmm
09:55:03 <_Ray_> a here could be Int, Char, whatever. id doesn't care what you give it, it'll return the same. so id 5 = 5, id "a" = "a".
09:55:08 <applicative> > show "hello"
09:55:08 <lambdabot>   "\"hello\""
09:55:44 <zhulikas> > show ['a','b','c'] == "abc"
09:55:45 <lambdabot>   False
09:55:53 <zhulikas> > show ['a','b','c']
09:55:54 <lambdabot>   "\"abc\""
09:56:04 <_Ray_> note the extra "s
09:56:08 <applicative> > ['a','b','c'] = "abc"
09:56:08 <lambdabot>   <no location info>: parse error on input `='
09:56:08 <zhulikas> I see
09:56:13 <_Ray_> shwo takes something that "can be shown", and shows it.
09:56:25 <_Ray_> "can be shown" is taken as "this type implements Show"
09:56:38 <zhulikas> @src show
09:56:38 <_Ray_> if you've heard of Interfaces in object oriented programming, this is similar
09:56:38 <lambdabot> show x = shows x ""
09:56:53 <applicative> @src shows
09:56:53 <lambdabot> Source not found. Sorry.
09:57:03 <_Ray_> for your type to be Show, it must define how 'show' acts on it.
09:57:24 <kmc> i don't suggest learning Haskell by analogy to OOP, either
09:57:25 <_Ray_> so for instance, Show of a list prints a [, then prints every element in the list separated by a comma, then a ]
09:57:38 <ion> s/prints/shows/
09:57:46 <kmc> type classes are just similar enough to Java etc. to confuse you
09:57:48 <_Ray_> yes, shows, not prints :)
09:58:01 <kmc> zhulikas, have you read about "type classes" in your Haskell book yet?
09:58:04 <zhulikas> kmc, but I want to learn Haskell by doing some practical things. I can find how to declare a function or data type. But how to use it all in practice is still a mistery for me :)
09:58:25 <kmc> zhulikas, take a look at Real World Haskell then
09:58:27 <kmc> @where RWH
09:58:27 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:58:30 <zhulikas> ok
09:58:33 <_Ray_> create a .hs, run it with ghc or hugs or any other compiler. or you can use ghci, an interpreter
09:58:49 <kmc> (hugs isn't a compiler)
09:58:57 <_Ray_> just an interpreter?
09:59:00 <kmc> yeah
09:59:04 <_Ray_> ah, didn't know that
10:00:06 <dpratt71> kmc: you have to add a lot of qualifications, but speaking as an OOP programmer (by trade), certain analogies (such as the one _Ray_ made) were more useful than damaging
10:01:08 <dpratt71> ...to me as I attempted to learn Haskell
10:01:13 <applicative> zhulikas, do you have ghc installed?
10:01:25 <zhulikas> I do.
10:01:42 <zhulikas> ghc, ghci and hugs, leksah
10:02:00 <applicative> so, begin compiling!
10:02:02 <_Ray_> zhulikas, you can fire up ghci and say "let f x = x+1", and then ask what f 5 is
10:02:12 <applicative> main = interact reverse
10:02:15 <_Ray_> (by saying f 5)
10:02:23 <kmc> dpratt71, i see a lot of people overusing type classes and producing complicated messy designs
10:02:32 <applicative> main = interact (show . fib . read)
10:02:34 <kmc> i'm trying to understand why
10:03:02 <_Ray_> applicative, 'fib'?
10:03:15 <applicative> typeclasses are fine, as long as you only instance ones in someone else's library
10:03:16 <kmc> the best i've come up with is that Java says interfaces and classes are *the only* way to structure a program, and Haskell classes and types look a bit like those, so people use a big pile of Haskell classes and types
10:03:31 <kmc> this is less "OOP is bad" and more "Java is bad for forcing you to think only one way"
10:03:36 <dpratt71> kmc: I can see that; regardless of whether it makes sense to define a type class, it seems important to have a decent understanding of them
10:03:55 <kmc> yes but that understanding includes understanding what they're *not* for
10:03:59 <kmc> which is the harder part it seems
10:04:28 <applicative> dpratt71: that seems right, the import thing is to define one's own types, but then you will want to instance suitable classes.  It is very rare that you want to make your own class
10:04:34 <dpratt71> kmc: I've noticed that many interfaces define but one method, which I think is...revealing
10:05:14 <dpratt71> kmc: and when they define more than one, I often wish they hadn't
10:08:06 <dpratt71> of course, without first-class functions, the closest thing you have to a function type is a single-method interface
10:08:29 <zhulikas> @type do
10:08:30 <lambdabot> Empty 'do' construct
10:08:34 <kmc> zhulikas, "do" is syntax
10:08:51 <zhulikas> do is like a code block. It doesn't seem to be appropriate for FP
10:08:55 <kmc> @undo do { x <- a; (y x) }
10:08:55 <lambdabot> a >>= \ x -> (y x)
10:09:18 <kmc> zhulikas, it's just syntactic sugar for applying some higher-order functions
10:09:23 <kmc> namely this (>>=)
10:09:37 <kmc> sounds pretty FP to me
10:09:56 <ion> What do you mean by appropriate for FP?
10:10:06 <kmc> anyway Haskell is a functional language but it's also an imperative language
10:10:12 <kmc> in fact it's one of the better imperative languages
10:10:23 <kmc> because imperative actions are first-class the same way functions are
10:10:29 <dpratt71> zhulikas: when I first started learning Haskell, I often assumed functions and operators were syntax; it's probably good that your intuition seems opposite to mine
10:10:31 <dankna> okay so
10:10:32 <zhulikas> ion, I was hoping not to be able to construct ANY code blocks :)
10:10:36 <dankna> I have many nested ReaderTs
10:10:43 <dankna> this is slow, so I must make fewer
10:10:46 <ion> What do you mean by code blocks?
10:11:04 <kmc> zhulikas, "do" is syntactic sugar.  you can ignore it and code with this (>>=), which is an ordinary infix operator
10:11:21 <zhulikas> kmc, I'll try. Maybe that will make more sense for me :)
10:11:29 <dankna> the obvious strategy for that is to make a master record that has a Maybe in it for each of the posssible types that can occur
10:11:38 <zhulikas> and also I will understand idea behind >>=
10:11:50 <kmc> (>>=) is implemented differently for different types
10:11:52 <kmc> same as (+)
10:12:01 <kmc> the types implementing (+) are called "numeric types"
10:12:07 <kmc> the types implementing (>>=) are called "monads"
10:12:13 <zhulikas> ion, Maybe I had a wrong picture of FP
10:12:50 <kmc> zhulikas, Haskell is also not a typical functional language
10:12:54 <kmc> it has lots of unusual features
10:12:54 <ion> One might want to learn about functors and then applicative functors before going into monads. The typeclassopedia is good.
10:13:13 <dankna> but the problem with that is that it means I have just one monad type
10:13:23 <zhulikas> wikipedia says Haskell is pure functional language... now dpratt71 says its also an imperative
10:13:32 <kmc> yes
10:13:36 <dankna> where previously I had typeclasses MonadTimepoint, MonadFrequency etc and the type of a given thing was some union of them
10:13:40 <kmc> don't worry about terminology gibberish
10:13:45 <zhulikas> and what I don't like about Haskell that it DOES have if-else
10:13:57 <c_wraith> you can just ignore it.
10:14:01 <c_wraith> I basically never use it.
10:14:02 <zhulikas> I will :D
10:14:08 <c_wraith> and it's just like it's not there!
10:14:08 <dpratt71> dpratt71: I don't think I said that...but it is...or it can be
10:14:11 <dankna> if/else is just an expression in Haskell though - it's always total
10:14:17 <dankna> there's no "omitted else" problem
10:14:19 <zhulikas> because I want to learn FP and using old techniques is just useless
10:14:31 <c_wraith> if/else/then is fine in FP
10:14:38 <kmc> right, I think it's a good idea for beginners to avoid if/then/else
10:14:46 <kmc> not because it's "old techniques"
10:15:01 <kmc> but because pattern-matching is often more appropriate
10:15:08 <kmc> i guess "not pattern matching" is the old technique
10:15:09 <c_wraith> @google boolean blindness
10:15:10 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
10:15:10 <lambdabot> Title: Boolean Blindness « Existential Type
10:15:13 <ion> It would be nice if if-then-else were a function in the style of Data.Maybe.maybe and Data.Either.either.
10:15:16 <zhulikas> Somebody told me that any algorithm involving if/else/then takes much more computing power than straightforward algorithms
10:15:28 <c_wraith> zhulikas: branching is branching.
10:15:29 <kmc> zhulikas, really, it's not worth your time to get hung up on what Wikipedia or random people on the Internet told you about Haskell
10:15:39 <zhulikas> let's say ANY algorithm which involves making a decision
10:15:50 <ion> Premature optimization is bad.
10:16:06 <dankna> that would be prediction failures causing the instruction pipeline to clear
10:16:10 <zhulikas> writting ineffective code is bad :)
10:16:12 <dankna> but if your algorithm calls for a decision
10:16:20 <dankna> you can't just reword the code to avoid one
10:16:27 <c_wraith> bot the link up there, the "boolean blindness" article.
10:16:31 <c_wraith> err, *but
10:16:38 <c_wraith> it's a good reason to avoid if/then/else
10:17:02 <c_wraith> not because if/then/else is bad, just that there's usually a better appraoch
10:17:16 <dafis> hmmm, if even n then soemthing else somethingElse seems perfectly fine to me
10:17:31 <zhulikas> > filter (>5) [1,2,3,4,5,6,7,8]
10:17:32 <lambdabot>   [6,7,8]
10:17:34 <dafis> *something
10:17:41 <zhulikas> isin't that using if/else or something similar inside filtering?
10:17:54 <ion> @src filter
10:17:54 <lambdabot> filter _ []     = []
10:17:54 <lambdabot> filter p (x:xs)
10:17:54 <lambdabot>     | p x       = x : filter p xs
10:17:54 <lambdabot>     | otherwise = filter p xs
10:17:59 <zhulikas> I guess its unavoidable to use such things anyway
10:18:04 <dafis> > map (\n -> if even n then n `quot` 2 else 3*n+1) [1 .. 10]
10:18:05 <lambdabot>   [4,1,10,2,16,3,22,4,28,5]
10:18:05 <c_wraith> > (\x -> if isJust x then fromJust x else 0) Just 5  -- this is a case of boolean going horribly wrong
10:18:06 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (t -> t1)'
10:18:06 <lambdabot>         against i...
10:18:13 <c_wraith> > (\x -> if isJust x then fromJust x else 0) $ Just 5  -- this is a case of boolean going horribly wrong
10:18:14 <lambdabot>   5
10:18:14 <kmc> zhulikas, the whole program of dividing languages up into "functional" and "imperative" etc. is ridiculous.  please ignore it
10:18:30 <kmc> zhulikas, good languages let you use a variety of techniques
10:18:40 <erus`> \f a 2 = "Hello"    <- what do i call the 2 there (the part that must match)
10:18:45 <zhulikas> kmc, please forgive me for that. The whole FP topic is new for me ;)
10:18:53 <dafis> c_wraith: yeah, that's bad
10:18:59 <kmc> erus`, it's a numeric literal pattern, i guess
10:19:00 <kmc> bbl
10:24:48 * edwardk waves hello.
10:25:08 * ion waves sin²
10:25:34 <erus`> i cant do circular refs :O
10:25:39 <erus`> with imports
10:25:58 <zhulikas> ion, your hand is a dolphin!
10:26:26 <ion> But i don’t know which seat to take.
10:26:26 * mokus waves cos²
10:26:53 <ion> erus: Put the common thing into a separate module for the others to import.
10:27:07 <erus`> i just have to make a types module
10:31:31 <jooboo> has anyone got time to explain to me how seq is implemented? it's "seq = let x = x in x", so surely the second x is free. where does it get bound? how does this work?
10:31:38 <kmc> that's not seq
10:31:56 <kmc> also, the second x isn't free
10:32:00 <kmc> "let" bindings are recursive
10:32:01 <jooboo> that's where the docs linked me from the prelude - file:///Library/Frameworks/GHC.framework/Versions/7.0.3-i386/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/src/GHC-Prim.html#seq
10:32:16 <c_wraith> jooboo: seq is internal.  the implementation listed there is a placeholder
10:32:21 <kmc> jooboo, the definitions in GHC.Prim are completely bogus
10:32:25 <kmc> for the benefit of Haddock only
10:32:36 <c_wraith> jooboo: in fact, that implementation is an infinite loop, just to make it clear it's a placeholder
10:32:38 <kmc> you can implement "seq" yourself for specific types
10:32:45 <kmc> for example seq True x = x; seq False x = x
10:32:51 <acfoltzer> jooboo: I had a similar question recently on SO: http://stackoverflow.com/questions/6442019/how-does-seq-force-functions
10:33:03 <kmc> the magic of the built-in seq is a) that it's polymorphic over everything; b) that it works for function types too
10:33:12 <acfoltzer> you may find the links/text there helpful
10:33:29 <jooboo> ok that all makes sense
10:33:31 <kmc> the desugaring into "case" is true in Core but not in Haskell
10:33:42 <jooboo> just confusing to see a link to the source code from the docs, that doesn't link to any useful source code...
10:33:46 <kmc> yeah
10:33:51 <kmc> that is very confusing
10:33:57 <kmc> probably should be considered a doc bug
10:34:53 <kmc> fix f = let x = f x in x   -- jooboo here's a similar, more interesting bit of code
10:35:47 <zhulikas> :t fix
10:35:48 <lambdabot> forall a. (a -> a) -> a
10:36:05 <kmc> another definition is:  fix f = f (fix f)
10:36:11 <kmc> but the "let" version can be more efficient
10:36:22 <zhulikas> fix f = let x = f x in x -- looks like inline variable declaration with that 'let x' :D
10:36:38 <c_wraith> it's an inline name binding, at least
10:36:39 <kmc> zhulikas, yeah, "let" is used to introduce local names for expressions
10:36:52 <XniX23> im thinking of buying LYAHFGG and also RWH. I was told that LYAH is really good to begin with. Someone (i remember know who) told me that after LYAH, its best to read RWH. Is that true or is some other book better for understanding more advanced stuff?
10:37:06 <c_wraith> better to think of it as "name binding" than "variable declaration in haskell".  since the values don't actually vary. :)
10:37:08 <kmc> it's a "variable" in the math sense but not in the usual programming sense, because you can't change its value
10:37:22 <kmc> XniX23,  LYAH and RWH are both available for free online, so why not take a look first
10:37:50 <kmc> as in most fields, there are a lot of different directions you can go for advanced stuff
10:38:05 <kmc> RWH is, not surprisingly, a good resource for the "real world" directions
10:38:09 <zhulikas> ok, what word should I use instead of variable? I know those are immutable
10:38:17 <kmc> zhulikas, "variable" is fine
10:38:22 <kmc> just don't expect it to behave like a Java variable
10:38:23 <zhulikas> but that's from OOP
10:38:26 <erus`> whats a simple way to check if a language is turing complete?
10:38:27 <zhulikas> yeah, I know :)
10:38:30 <kmc> zhulikas, no, it's from math
10:38:35 <c_wraith> "named expression" or the like can also be useful terms.
10:38:37 <zhulikas> it's like final from Java
10:38:51 <kmc> a little
10:39:01 <c_wraith> because it drives home the point that it really is semantically just giving a shorter name to a particular expression
10:39:09 <ion> I don’t see the problem with “variable”. The x in «foo x = ...» can vary across foo invocations.
10:39:10 <kmc> erus`, try to write a simulator for a turing-complete system in it
10:39:16 <c_wraith> (or sometimes clearer, but not shorter)
10:39:24 <kmc> ion, right, that's what mathematicians mean by it
10:40:11 <zhulikas> I just want to be politically correct :))
10:40:27 <kmc> "variable" is fine.
10:40:57 <kmc> zhulikas, here is where you can read about what things are officially called: http://www.haskell.org/onlinereport/haskell2010/
10:40:58 <erus`> can a turing machine jump?
10:41:09 <kmc> erus`, not directly
10:41:10 <erus`> ah yes
10:41:11 <copumpkin> if someone built one with a big spring under it
10:41:12 <zhulikas> thanks \o/
10:41:13 <erus`> left and right
10:41:16 <copumpkin> it probably could
10:41:25 <copumpkin> but it's quite hard to find infinite tapes these days
10:41:26 <rtharper> I mean, you can simulate jump, I'm sure
10:41:38 <rtharper> copumpkin: quite hard to find turning machines these days
10:41:47 <erus`> isnt there some simple problem that proves turing completeness
10:42:01 <kmc> erus`, simulating any turing-complete system
10:42:03 <kmc> pick your favorite
10:42:13 <erus`> brainfuck
10:42:25 <copumpkin> subleq
10:42:44 <copumpkin> someone should make a haskell to subleq compiler
10:42:48 <erus`> i can pass lists around and i can recurse
10:42:56 <erus`> so it must be turing complete?
10:43:18 <erus`> i can check equality, do integer add min sub mul
10:43:45 <kmc> your description is too vague
10:43:54 <kmc> try implementing a brainfuck interpreter
10:44:25 <XniX23> kmc: I'm already reading LYAH and like it a lot. However with haskell knowledge i have now, i can't tell whether i'll understand RWH when ill start reading it
10:44:48 <kmc> XniX23, really? i thought RWH actually starts off at nearly the same point
10:45:21 <zhulikas> @where LYAH
10:45:21 <lambdabot> http://www.learnyouahaskell.com/
10:45:23 <kmc> erus`, it sounds like your language is probably turing complete, but there are many ways to design a language with those properties that isn't turing complete
10:45:47 <XniX23> kmc: i read reviews on amazon and found that some people had trouble starting with it
10:45:54 <kmc> like "recursion depth is limited to 50" or "recursive calls must be on strictly smaller arguments"
10:45:55 <zhulikas> hahahahahah
10:46:01 <kmc> XniX23, why not hold off buying RWH, then?
10:46:08 <zhulikas> a sun which says 'Holy shit' :DD epic
10:46:34 <erus`> 'epic' this word used to mean something
10:47:05 <zhulikas> sorry for misusing it and forgetting it's trully meaning 8-|
10:47:06 <kmc> erus`, yeah, it means level 21 or greater
10:47:39 <erus`> now the hipster geeks are changing the whole interwebs
10:52:33 <erus`> lex doesnt handle comments :(
10:53:10 <XniX23> kmc: yeah ill probably do that and see when i finish reading it ^^
10:53:32 <copumpkin> lex luthor?
10:53:41 <erus`> > lex "no this lex"
10:53:42 <lambdabot>   [("no"," this lex")]
10:53:51 <copumpkin> > lex "luthor"
10:53:51 <lambdabot>   [("luthor","")]
10:53:55 <copumpkin> looks fine to me
10:54:37 <hpaste> erus` pasted “lamdurp” at http://hpaste.org/49859
10:54:47 <erus`> what do you guys think of my language?
10:55:30 <erus`> (one can use \ instead of lowercase lambda)
10:56:47 <copumpkin> mixfix?
10:56:48 <edwardk> one of these days i should work on luthor again
10:57:00 <edwardk> but then i found someone else made an alex-meta package
10:58:13 <kmc> edwardk, i wonder how close you can get to a parser combinator EDSL and still have ahead-of-time compilation
10:58:53 <kmc> istr something that would quote and compile Parsec code
10:59:18 <edwardk> kmc: well, i was playing around with using template haskell for it
10:59:44 <edwardk> i had one for a lexer, but i never finished it. got bogged down in the unicode parsing
11:01:36 <DanC_> suggestions for installing haskell on ubuntu? following my nose from http://hackage.haskell.org/platform/linux.html yields: haskell-platform : Depends: ghc6 (< 6.12.1+) but 6.12.3-1ubuntu7 is to be installed
11:02:09 <kmc> DanC_, Haskell Platform is just GHC plus a set of libraries and tools picked from Hackage
11:02:21 <kmc> if you already have ghc and "cabal install" then you are ready to go
11:02:50 * DanC_ find ghc6, starts with that...
11:05:09 <erus`> @src last
11:05:09 <lambdabot> last [x]    = x
11:05:09 <lambdabot> last (_:xs) = last xs
11:05:09 <lambdabot> last []     = undefined
11:05:17 <monochrom> you can try my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
11:05:27 <erus`> @src map
11:05:27 <lambdabot> map _ []     = []
11:05:27 <lambdabot> map f (x:xs) = f x : map f xs
11:06:25 <fragamus> @src StateT
11:06:25 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:06:35 <fragamus> I installed haskell platform on my mac.  I need to find the source for StateT. Any clues?
11:07:08 <erus`> whats the name of (:) ? prepend?
11:07:26 <monochrom> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Control-Monad-Trans-State-Lazy.html and look for "source" links
11:07:31 <kmc> erus`, often "cons"
11:07:37 <kmc> erus`, thank Lisp for that
11:07:49 <acowley> always cons
11:07:58 <erus`> cons a = (a, ()) ?
11:08:05 <kmc> no?
11:08:06 <acowley> cons the magnificent!
11:08:09 <fragamus>                   look for "source" links
11:08:09 <fragamus> 23:29 < kmc> erus`, often "cons"
11:08:20 <fragamus> gah
11:08:25 <monochrom> yes, look for "source" links :)
11:08:48 <kmc> in Lisp it's like cons = (,) and nil = ()
11:08:57 <kmc> but that doesn't work out with Haskell's types
11:09:57 <erus`> is there a standard function to make a new list with a single element in lisp?
11:10:03 <erus`> other than cons a ()
11:10:43 <monochrom> (list x) is a new list with a single element x
11:10:48 <Taslem> What's lambdabot's command for geting point free form?
11:10:53 <kmc> @pl \x -> x+3
11:10:54 <lambdabot> (3 +)
11:11:06 <monochrom> @pl \x -> list x
11:11:06 <lambdabot> list
11:11:25 <Clint> @unpl (3 +)
11:11:25 <lambdabot> (\ a -> 3 + a)
11:11:29 <monochrom> except that list is var-arg :)
11:11:31 <Taslem> @pl (\x -> (head x,tail x))
11:11:32 <lambdabot> liftM2 (,) head tail
11:11:44 <MHD> regarding pointless haskell: http://pseudo.fixme.fi/~opqdonut/blog/
11:11:51 <MHD> look at that abomination
11:12:16 <monochrom> hahaha (λblog. blog blog) (λblog. blog blog)
11:12:24 <kmc> does not typecheck ;)
11:12:56 <MHD> Read the first post about stack based argument shuffling
11:13:02 <erus`> map f () = ()
11:13:03 <erus`> map f (a, b) = cons (f a) (map f b)
11:13:05 <erus`> Does that work in theory?
11:13:06 <MHD> Obfuscated haskell contest material?
11:13:34 <MHD> erus`: with a little hacking it might
11:13:35 <kmc> :t let map f () = (); map f (a, b) = (f a, map f b) in map
11:13:36 <lambdabot>     Couldn't match expected type `()' against inferred type `(a, b)'
11:13:36 <lambdabot>     In the pattern: (a, b)
11:13:36 <lambdabot>     In the definition of `map': map f (a, b) = (f a, map f b)
11:13:56 <erus`> in a hypothetical dynamic language?
11:14:10 <MHD> erus`: yes
11:14:13 <monochrom> that's what lisp does, no?
11:14:20 <kmc> sure
11:14:34 <erus`> does lisp have pattern matching?
11:14:43 <monochrom> no
11:14:50 <kmc> you can add it
11:14:54 <kmc> moreso than in most languages
11:14:55 <acowley> it can be made to
11:14:59 <jerji> looks a little funny to me to have the (a, b) pattern on the left and then not use the comma in the recursion
11:15:06 <erus`> i thought i was just writing a lisp with less braces for a second
11:15:37 <fragamus> <---- is sad
11:16:07 <fragamus> <----- tried to make RandT an instance of MonadPlus
11:16:21 <Taslem> @pl (\x -> (head x,last x))
11:16:21 <lambdabot> liftM2 (,) head last
11:16:39 <fragamus> <----- coded it correctly but the constructor for RandT is not exported
11:16:48 <MHD> is there a conjunction operator for monads? More specifically for parsec?
11:16:54 <zhulikas> > [10,9.25..8]
11:16:54 * ion used /me
11:16:55 <lambdabot>   [10.0,9.25,8.5,7.75]
11:17:00 <zhulikas> well, why is that? 7.75
11:17:05 <zhulikas> its below 8
11:17:26 <kmc> zhulikas, don't use enum with floating point
11:17:27 <kmc> it makes no sense
11:17:36 <monochrom> ≤ monochrom
11:17:39 <ion> Floats shouldn’t have had an Enum instance in the first place.
11:18:11 <fragamus> why is the data constructor for RandT not exported
11:18:28 <kmc> > 7.75 + (9.25 - 10.0) < 8.0
11:18:29 <lambdabot>   True
11:18:32 <MHD> @hoogle RandT
11:18:32 <lambdabot> No results found
11:18:32 <monochrom> >>= and >> 's job include conjunction
11:18:32 <zhulikas> > [10,9..5,6,7..10]
11:18:33 <kmc> ^^^^ that's why zhulikas
11:18:33 <lambdabot>   <no location info>: parse error on input `,'
11:18:55 <monochrom> (generally for all backtracking schemes including parsec)
11:18:57 <zhulikas> I see limitashuns...
11:19:03 <MHD> monochrom: It's a parsec thing, you know <|> or mplus is disjunction
11:19:09 <monochrom> I know
11:19:23 <MHD> monochrom: is there a conjunction operator that overlaps two parsers?
11:19:34 <kmc> zhulikas, yeah, floating point is quite annoying
11:19:37 <monochrom> if you read logict's doc you also see a hint that >>= includes conjunction
11:19:49 <zhulikas> kmc, but compiler is right with your given equation
11:19:56 <monochrom> but no, not overlap
11:19:58 <kmc> it's annoying in the same way in every other language that has floating point
11:20:01 <zhulikas> 7.0 is truly less than 8.0 :D
11:20:09 <MHD> monochrom: oh wait there's peek
11:20:15 <kmc> oh yeah
11:20:16 <zhulikas> > 8.75 + (9.25 - 10.0) < 8.0
11:20:16 <MHD> or whatever it's called
11:20:17 <lambdabot>   False
11:20:22 <kmc> hmm ok
11:20:40 <zhulikas> > 8.75 + (9.25 - 10.0) > 8.0
11:20:41 <lambdabot>   False
11:21:20 <zhulikas> > 8.7500 + (9.2500 - 10.0) /= 8.0
11:21:21 <lambdabot>   False
11:21:24 <zhulikas> k.
11:22:19 <ion> ghci> parse ((,) <$> lookAhead digit <*> Text.Parsec.many anyToken) "" "4foo"
11:22:20 <ion> Right ('4',"4foo")
11:22:28 <rwbarton> the real solution is don't write things like [10,9.25..8] that don't make any sense
11:23:05 <zhulikas> rwbarton, I am just exploring. :)
11:23:23 <ion> mhd: Is that of any help?
11:23:32 <rwbarton> the reason for the odd-seeming enumFromTo behavior is so that when you write things that do make sense, like [0,0.1..10] they do approximately what you expect
11:23:39 <kmc> > [10,9.25..8] :: [Rational]
11:23:40 <lambdabot>   [10 % 1,37 % 4,17 % 2,31 % 4]
11:23:46 <MHD> ion: yeah that was about what I was thinking
11:24:49 <rwbarton> > last $ takeWhile (<= 10) [0,0.1..]
11:24:50 <lambdabot>   9.900000000000052
11:25:03 <rwbarton> > last [0,0.1..10]
11:25:04 <lambdabot>   10.000000000000053
11:25:20 <rwbarton> obviously you don't want to get the first answer from the second expression
11:49:54 <psysine> is there any book teaching haskell that goes deeply into applications and has many interesting, non-trivial exercises (like SICP for example)
11:51:36 <erasmas> psysine: have you checked out Real World Haskell? http://book.realworldhaskell.org/read/
11:51:57 <thoughtpolice> psysine: real world haskell has lots of interesting exercises and applications, i guess how 'non-trivial' they are is a little subjective though
11:52:03 <erus`> (\ -> 123) could be the same as 123?
11:52:05 <thoughtpolice> but it's available for free! follow the link erasmas gave you
11:52:12 <kmc> erus`, not in Haskell
11:52:21 <kmc> erus`, each Haskell function has exactly one argument
11:52:31 <erus`> ok
11:52:46 <psysine> erasmas, thoughtpolice; thanks
11:53:19 <kamaji> What's the difference between Data.Graph and Data.Graph.Inductive? are they completely different packages or what?
11:53:55 <kmc> "zero-argument function" is one of those ideas that makes no actual sense but is required to reconcile bad language design decisions
11:54:00 <acowley> kamaji: yes they're totally different
11:54:46 <kamaji> oh knobbery
11:54:57 <kamaji> why are there two?
11:55:11 <acowley> because there are lots of reasonable ways to represent graphs
11:55:48 <kamaji> shouldn't that be a feature of a library though?
11:56:54 <acowley> Perhaps, except that FGL was originally written to previde a function interface to graph manipulation drastically different from interfaces provided by other representations
11:57:01 <acowley> s/funciton/functional
11:58:03 <kamaji> So does FGL have a single underlying representation?
11:58:04 <acowley> kamaji: if you're just trying to figure out which one you should use, look at what those two modules provide and see how it matches up with your needs
11:59:04 <dpratt71> I was going to ask: shouldn't there be one programming language to represent all manner of expressing computation?
11:59:26 <dpratt71> but then I realized that of course the answer is "yes: Haskell!"
11:59:59 <c_wraith> haskell is kind of clunky for describing algorithms that rely on heavy mutation.
12:00:05 <kamaji> acowley: well I quite wanted to play with graphviz so I guess inductive is where I want to go, but I'm having trouble finding out if anyone's implemented stuff like djikstra, max-flow, stuff like that
12:00:20 <chrisdone> that was made in 1936
12:00:39 <c_wraith> I mean, you *can* write union/find trees in haskell with path compression, but the code is verbose compared to how it looks in other languages
12:01:29 <acowley> kamaji: it looks like FGL has several such things
12:01:52 <dpratt71> c_wraith: to be clear, my last comment was intended to be tongue-in-cheek :)
12:01:57 <c_wraith> :)
12:02:40 <chrisdone> http://scholar.google.com/citations?view_op=view_citation&hl=en&user=5NUaEngAAAAJ&citation_for_view=5NUaEngAAAAJ:qjMakFHDy7sC
12:02:43 <chrisdone> hehe, see the citations
12:03:01 <acowley> You can usually do pretty well in making the Haskell version aesthetically pleasing (to a Haskell programmer), but typically end up paying a performance penalty.
12:03:01 <kmc> hahaha
12:03:34 <yitz> @faq Is there one programming language to represent all manner of expressing computation?
12:03:34 <lambdabot> The answer is: Yes! Haskell can do that.
12:03:48 * hackagebot semigroups 0.7.0 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.7.0 (EdwardKmett)
12:04:01 <yitz> ooo!
12:04:11 * yitz goes to see what's new in semigroups
12:04:20 <kmc> yeah, it's not clear why programming languages should be one of those fields where your work is ignored until after you die
12:04:55 <chrisdone> maybe they're all critical of his work :p waiting until they die is a nice way to avoid a slap
12:05:06 <kmc> haha
12:05:07 --- mode: ChanServ set +q *!*@li229-222.members.linode.com
12:05:21 <kmc> write an academic paper about how this "lambda" is academic nonsense, and cite church
12:07:09 <chrisdone> awesome, i found the paper: http://thor.info.uaic.ro/~fltiplea/CDC/Chur1932.pdf
12:07:59 <yitz> @slap alonzo church
12:07:59 * lambdabot will count to five...
12:09:13 <edwardk> yitz: adding replicate1p, moved natural numbers down, and i'm adding Data.Semigroup.Combinators for repeat and cycle
12:09:15 <chrisdone> i like reading old math papers, it feels like there're fewer assumptions made of the reader
12:09:21 <dpratt71> wow, the PDF format has been around for a lot longer than I would've guessed
12:09:40 <edwardk> actually that one stays in the reducers package i'm pushing
12:12:21 <chrisdone> dpratt71: what?
12:12:37 <chrisdone> oh, that was a joke. nevermind
12:13:23 <hpaste> erus` pasted “could i be using a bind or something here?” at http://hpaste.org/49861
12:13:55 <yitz> edwardk: are you considering a separate nonempty-lists package?
12:15:53 <edwardk> yitz: there is streams.
12:15:58 <edwardk> yitz: it builds on top
12:16:52 <yitz> edwardk: hmm, natural numbers also? these are useful things whose use ought to become absolutely viral. i'm afraid "semigroups" just isn't a catchy enough name for non-empty lists and naturals.
12:17:00 <edwardk> sorry man
12:17:07 <edwardk> i'm stuck maintaining like 60 some packages
12:17:12 <edwardk> i'm not breaking it up any finer
12:18:02 <yitz> what is replicate1p?
12:18:04 <edwardk> i moved natural numbers down from algebra ;)
12:18:11 <edwardk> repeat (n + 1) times
12:18:18 <edwardk> generalized (^)
12:18:22 <yitz> ?
12:18:32 <yitz> type?
12:18:49 <edwardk> replicate1p :: (Semigroup a, Whole n) => n -> a -> a
12:18:52 <zygoloid> edwardk: assuming associativity?
12:18:59 <zygoloid> ah, i see.
12:19:03 <edwardk> zygoloid: yes, its on a semigroup
12:19:05 <yitz> aha
12:19:13 <yitz> nice
12:19:22 <dolio> yitz: Thanks for the help yesterday, by the way.
12:19:29 <edwardk> i had it in algebra on the additive semigroups there and a version on the multiplicative ones as well
12:19:46 <edwardk> and i wound up needing it down here in a semigroup reducers package i needed
12:19:47 <yitz> mm? ah, that. sure, np. :) glad to see the immediate benefit to the community :)
12:20:07 <edwardk> so i dragged it all the way down
12:20:16 <edwardk> it'll break my algebra package, but i can fix that
12:20:22 <MHD> in my world, strings are glorified arrays...
12:20:50 <chrisdone> tch. you're so western
12:20:51 <yitz> MHD: *text* is glorified arrays. strings are glofified lists.
12:21:05 <chrisdone> text is just a list of alphabetical characters!
12:21:11 <qnikst> hello, I have some question about binary package
12:21:11 <MHD> yitz: I know, I am not talking about haskell
12:21:20 <chrisdone> qnikst: go
12:21:20 <MHD> yitz: I am talking about my world
12:21:34 <MHD> qnikst: yes=
12:21:41 <MHD> s/=/?/
12:21:47 <qnikst> is there a way to use bytrestring already put int Put monad
12:21:56 <yitz> MHD: your former world. you know you're already hooked.
12:22:15 <chrisdone> qnikst: you mean get the current output state?
12:22:24 <MHD> yitz: Oh, I am hooked, I have been hacking haskell for the last six months
12:22:36 <qnikst> i.e. instance Binary A where put a = do { putWord8 .. ; putWord8 .. ; crc16 {- of what have already putted -}
12:22:40 <MHD> yitz: and I have looooads of free time
12:22:41 <dpratt71> MHD: your world exclusively or a world you share with others? in the latter case, what world is that?
12:23:03 <MHD> dpratt71: Making a programming language called "Wip"
12:23:05 <qnikst> chrisdone: yes, and use it in next field
12:23:25 <dpratt71> MHD: oh - google-able?
12:23:54 <MHD> dpratt71: pretty sure "Wip Programming language" will turn up results
12:24:22 <chrisdone> i don't think so
12:24:37 <qnikst> I think I can runPut inside function, but it seems not good idea
12:24:44 <dpratt71> MHD: indeed it does, unsure of the relevance, though
12:25:07 <MHD> dpratt71: I haven't published anything yet...
12:25:23 <MHD> Maybe I should go with Wyp instead
12:25:32 <MHD> That gives even more obscure google results
12:25:35 <yitz> @google wip program
12:25:37 <lambdabot> http://www.med.wright.edu/citar/wip/
12:25:37 <lambdabot> Title: Weekend Intervention Program at Wright State University School of Medicine | www ...
12:25:52 <yitz> @google wip programming
12:25:53 <lambdabot> http://msdn.microsoft.com/en-us/library/aa705274(v=bts.10).aspx
12:25:53 <lambdabot> Title: WIP Programming Model
12:26:05 <yitz> wow you made microsoft already
12:26:19 <MHD> ew, microsoft hogged my name
12:26:22 <yitz> didn't know you were using COM
12:26:31 <MHD> I'm not
12:26:41 <yitz> MS says you are :)
12:26:44 <MHD> :P
12:26:56 <MHD> Prolly go with "Wypp" instead
12:27:03 <MHD> pronounced "Whip"
12:27:21 <qnikst> chrisdone: and in get monad can I somehow report about errors?
12:27:26 <MHD> "Hey, Joe, can you Wypp up a solution?"
12:27:27 <tech2> not pronounced "Wipe"? ;)
12:27:39 <MHD> no, because of above pun
12:27:59 <tech2> MHD: pronunciation of Wy.. could incur that
12:28:10 --- mode: ChanServ set -q *!*@li229-222.members.linode.com
12:28:24 <MHD> tech2: then hooray for IPA
12:28:26 <copumpkin> OPEN THE GATES OF MORDOR
12:28:42 <chrisdone> qnikst: no, it's not that great. the cereal package is better for this. it has Applicative,Alternative,MonadPlus instances: http://hackage.haskell.org/packages/archive/cereal/0.3.3.0/doc/html/Data-Serialize-Get.html
12:29:29 <chrisdone> so you can do, e.g. do result <- Right <$> getWord8 <|> Left "OH GOD"; case result of …
12:29:44 <chrisdone> er, I meant pure (Left …), but w/e, you get the idea
12:29:51 * hackagebot comonads-fd 2.0 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-2.0 (EdwardKmett)
12:30:07 <qnikst> thanks
12:30:12 <qnikst> will try
12:30:51 * hackagebot data-lens 2.0.0 - Haskell 98 Lenses  http://hackage.haskell.org/package/data-lens-2.0.0 (EdwardKmett)
12:31:21 <MHD> Okay, someone explain what good Comonads are...
12:31:47 <chrisdone> copumpkin: And the Mouth of Sauron will greet you… Mouth of Sauron, moar liek Ranout of Sensodyne amirite
12:31:51 * hackagebot data-lens-fd 2.0 - Lenses  http://hackage.haskell.org/package/data-lens-fd-2.0 (EdwardKmett)
12:32:16 <chrisdone> (context: http://www.youtube.com/watch?v=xrLizclY8nU)
12:32:21 <copumpkin> lol
12:32:51 * hackagebot data-lens-template 2.0 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-2.0 (EdwardKmett)
12:33:05 <edwardk> mhd: normally i'd dive right in but i'm in the midst of juggling a lot of code
12:33:21 <MHD> edwardk: Then you go do that :)
12:34:51 * hackagebot comonad-extras 2.0 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-2.0 (EdwardKmett)
12:37:17 <qnikst> chrisdone: one more question (maybe I'm not seen it) is there a way to work on bit level, or it should be done with putLazyByteString?
12:37:48 <xplat> < chrisdone> what gets bigger the more you take away? <-- a negative number, or a restaurant chain
12:37:52 * hackagebot categories 0.58.0.5 - categories from category-extras  http://hackage.haskell.org/package/categories-0.58.0.5 (EdwardKmett)
12:37:54 * hackagebot either 0.2.2.3 - Haskell 98 either monad transformer  http://hackage.haskell.org/package/either-0.2.2.3 (EdwardKmett)
12:37:56 * hackagebot groupoids 0.1.1.1 - Haskell 98 Groupoids  http://hackage.haskell.org/package/groupoids-0.1.1.1 (EdwardKmett)
12:37:56 <chrisdone> i think its granularity is bytes, but i don't know for sure, sorry
12:38:11 <chrisdone> xplat: *golf clap*
12:38:22 <chrisdone> were you saving that for me all this time? :p
12:38:28 <chrisdone> i swear i said that like a day ago
12:38:52 * hackagebot eq 0.3.4.1 - Leibnizian equality  http://hackage.haskell.org/package/eq-0.3.4.1 (EdwardKmett)
12:39:22 <mauke> hahaha
12:39:52 * hackagebot free 2.0 - Monads for free  http://hackage.haskell.org/package/free-2.0 (EdwardKmett)
12:40:05 <thoughtpolice> oh god, i didn't think the edwardk hurricane would be coming by again so soon
12:40:19 <xplat> 17:27 < roconnor> Hmm, Bool has a non-reflexive proof of equality, but dosn't seem to have a hole.  I must be missing soemthing.
12:40:23 <edwardk> hah
12:40:39 <copumpkin> thoughtpolice: I tried to seal the gates
12:40:41 <copumpkin> but he was too strong
12:40:45 <edwardk> hahaha
12:41:17 <dolio> Maybe we can just get rid of hackagebot.
12:41:17 <xplat> roconnor: you made a level slip.  there's a non-reflexive proof of Bool == Bool, but there are no nonreflexive proofs of equality for things in Bool.  the hole, therefore, exists, but it's in Set.
12:42:30 <MHD> Am I the only one who thinks Python's string prefixes are an insanely great idea?
12:42:31 <roconnor> xplat: hmm, interesting
12:42:48 <chrisdone> MHD: i was recently looking at comonads recently. i grok the type class definition but not sure where i'll use it in code yet/what kind of problems it's appropriate for
12:42:52 * hackagebot pointed 2.0 - Haskell 98 Pointed and copointed data  http://hackage.haskell.org/package/pointed-2.0 (EdwardKmett)
12:42:54 * hackagebot tagged 0.2.2.3 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.2.2.3 (EdwardKmett)
12:43:12 <MHD> chrisdone: I am of the same opinion.
12:43:33 <MHD> It's just reversed monads. But there must be something sinister behind it
12:43:42 <roconnor> chrisdone: works well for cellular automoton
12:43:44 <dolio> They're for categorizing coalgebras.
12:43:53 * roconnor looks for an example on reddit
12:44:01 <ion> dolio: Ah, that explains it!
12:44:02 <chrisdone> dolio: but i don't know what a coalgebra is!
12:44:03 <edwardk> chrisdone: look at the comonad-transformers package
12:44:05 <edwardk> perhaps that'll help
12:44:11 <dolio> Then you should learn what they are.
12:44:14 <sm> I guess we need to get rid of hackagebot or exclude/display only a sample of edwardk's uploads ?
12:44:15 <thoughtpolice> dolio: hackagebot would be more amusing if it had thunderdome-like announcements
12:44:23 <chrisdone> dolio: is it turtles all the way down?
12:44:25 <edwardk> chrisdone: you can find all the analogues to the mtl
12:44:33 <chrisdone> edwardk: ah, cool
12:44:42 <dolio> I don't remember any turtles being involved.
12:44:46 <sm> or just endure and rely on social pressure to help him release less often
12:45:04 <sm> damn you edwardk !
12:45:05 <MHD> I think I will Minor in Category Theory when I start Uni in two years time...
12:45:22 <dolio> I don't think you will.
12:45:23 <roconnor> what was that ocaml web based video game where you walk around slaying monstors and other players on a tile board?
12:45:31 <dolio> Because you can't minor in that.
12:45:42 <MHD> dolio: I'm not from US
12:45:44 <edwardk> sm:if you press me to release less often i'll just go away.
12:45:46 * Saizan gets coalgebras but not what categorizing them means
12:45:51 <MHD> dolio: I think I can get close
12:45:53 * hackagebot keys 2.0 - Keyed functors and containers  http://hackage.haskell.org/package/keys-2.0 (EdwardKmett)
12:46:03 <edwardk> to be quite honest
12:46:06 * sm isn't pressing anyone
12:46:12 <thoughtpolice> isn't category theory mostly taught at graduate level in most places?
12:46:14 <dolio> Can you minor in calculus, too?
12:46:17 <thoughtpolice> that was my impression anyway, not that i'd know
12:46:43 <kmc> thoughtpolice, yeah, but at most good schools it's easy to take grad classes as an undergrad
12:46:57 <MHD> dolio: Honestly I havent checked, but there is a lot of free space in the "Datologist" batchelor (that is the danish equivalent of CS)
12:46:57 <tech2> If I have a list of lists and I want to filter that list such that it only includes elements of strictly increasing length is there an easy way to do this?
12:47:22 <thoughtpolice> kmc: true, i did it once in the year i was in school
12:47:23 <chrisdone> oh. it's literally the reverse of the monads
12:47:26 <MHD> tech2: use unfoldr?
12:47:31 <edwardk> sm: i release because it is downright awkward to use haskell direclty from repositories when there are lots of packages involved
12:47:32 <thoughtpolice> (it was a mixed grad/undergrad class though, slightly different i guess)
12:47:47 <psii> how do i get ghci to show me, which constructor was used for the creation of an ADT? the normal "show" doesn't work, because the ADT is an instance of Show and the implementation by the author doesn't give me useful results.
12:47:50 <edwardk> and because i have people who build on top of the top of the stack
12:48:00 <edwardk> so it behooves me to get bugfixes etc out
12:48:32 <kmc> tech2, that's a case where i would write the explicit recursion and then stare at it and see if there's a pattern to abstract out
12:49:17 <mwc> Is there a proper way to get the top level of the source directory within a cabal Setup script or should I just do a getCurrentDirectory at the top of the program?
12:49:33 <mwc> there's buildDir, scratchDir in LocalBuildInfo but nothing like a sourceDir
12:49:40 <tech2> kmc: I have a function which yields lists, it will progress forever so I'd like to merely keep track of the largest values I've found to date. I had a solution which was a bit rough to start with but I'd like to simplify it if at all possible
12:49:55 <dolio> MHD: Maybe it's different over there. I think category theory (and calculus) would be too narrow for a minor over here.
12:50:18 <tech2> MHD: I don't understand how I would apply unfoldr in this case, sorry.
12:50:20 <dolio> You could minor in mathematics, of course.
12:50:25 <MHD> dolio: Yeah, but I can minor in Math
12:50:27 <edwardk> sm: if it makes you feel better, unlike manatee, i actually do all my uploads by hand after testing
12:50:35 <edwardk> sm: so this takes me a lot of effort =P
12:51:03 <MHD> tech2: keep a state of the last list length with you and discard any that are not strictly longer.
12:51:08 <thoughtpolice> edwardk: hahaha
12:51:19 <sm> to be clear, as keeper of hackagebot, I'll do whatever the channel needs/wants, and isn't too much work. I don't want to be seen as a spammer
12:51:39 <sm> right now personally the status quo is best
12:51:48 <MHD> :t unfoldr
12:51:49 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:51:54 <chrisdone> sm: you know there's a bug in hackagebot. PAY ME ONE HUNDRED MILLION DOLLARS and i will not exploit it :p
12:51:59 * hackagebot representable-functors 2.0.0.5 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.0.0.5 (EdwardKmett)
12:52:12 <chrisdone> *Dr Evil pose*
12:52:27 <sm> edwardk: agreed releasing is a lot of work. I have automated mine extensively, but it's impossible to make perfect releases that don't require updates, specially with the number of packages you've got
12:52:27 <MHD> tech2: Just write a custom recursive function
12:52:51 <chrisdone> if a package has % in the title it will end hackagebot due to a bad printf use
12:53:07 <sm> chrisdone: really ? good one!
12:53:09 <MHD> chrisdone: I am so doing that
12:53:21 <kmc> what if it has a %n in the title
12:53:59 <thoughtpolice> kmc: i think you just haxed a gibson
12:54:22 <mauke> when you see it you'll hax gibs
12:54:31 <kmc> haha
12:54:34 <chrisdone> https://github.com/chrisdone/rss2irc/blob/master/rss2irc.hs#L606
12:55:01 <edwardk> hah
12:55:19 <kmc> ok, I hope Text.Printf doesn't implement %n
12:55:33 <sm> great - patches very welcome, http://joyful.com/darcsden/simon/rss2irc
12:55:37 <chrisdone> needs moar Text.Printf.Mauke.TH
12:55:39 <fragamus> I tried to make RandT and instance of MonadPlus, but I got this error: Not in scope: data constructor 'RandT'
12:56:03 * hackagebot adjunctions 2.0.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.0.1 (EdwardKmett)
12:56:11 <edwardk> fragramus: as i mentioned RandT doesn't export everything you need
12:56:19 <edwardk> poke cale
12:56:28 <sm> that's not aimed at you chrisdone, you've done your bit
12:56:32 <edwardk> and get him to give up some of his precious encapsulation =)
12:56:53 * sm passes chrisdone a cookies
12:57:03 * chrisdone nom nom noms
12:57:10 <fragamus> well I really dont want to make a branch of RandT
12:57:45 <edwardk> well, i don't see how you can write what you want without extending it
12:57:57 <edwardk> without using template haskell to peek at constructors you can't see ;)
12:58:15 <edwardk> since you can use it to bypass encapsulation iirc
12:59:04 * hackagebot bifunctors 0.1.1.2 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-0.1.1.2 (EdwardKmett)
13:00:04 * hackagebot streams 0.8.0.4 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.8.0.4 (EdwardKmett)
13:01:30 <mwc> So running a command in a working directory isn't yet supported? runProgramInvocation: not yet implemented for this form of invocation
13:03:24 <roconnor> @src inits
13:03:25 <lambdabot> inits []     =  [[]]
13:03:25 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
13:03:50 <roconnor> @src tails
13:03:50 <lambdabot> tails []         = [[]]
13:03:50 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
13:04:53 <sm__> mauke, chrisdone: does http://hackage.haskell.org/package/printf-mauke work well ? the TH part says not tested much ?
13:05:15 <sm__> how does the non-TH printf differ from the standard one ?
13:05:28 <mauke> better documentation :-)
13:05:40 <mauke> hopefully fewer bugs
13:05:45 <accel> does haskell have a C++ FFI
13:05:53 <mauke> a few perl features, such as %b and the v flag
13:06:00 <kmc> accel, no
13:06:03 <accel> does haskell have a C++ FFI; or is evereything via the C FFI
13:06:04 <kmc> accel, C++ does not have a C++ FFI
13:06:08 <accel> lol
13:06:09 <mwc> accel: yes and no. You can call the C++ functions if you know the mangled names
13:06:26 <mwc> accel: better to export your interface as extern "C" and call it that way
13:06:33 <sm__> thanks
13:06:37 <pikhq> mwc: And are running on a system where C++ and C have matching call conventions.
13:07:04 <chrisdone> yeah, i use printf-mauke, nicer docs (and i patched it >_>)
13:07:05 * hackagebot vector-instances 2.0 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-2.0 (EdwardKmett)
13:07:06 <mwc> never seen a platform that didn't. Is that windows sickness?
13:07:16 <kmc> thiscall!
13:07:26 <kmc> yeah, windows sometimes passes "this" in a register and the rest of args on the stack
13:07:44 <mwc> good grief. So glad I'm not a windows programmer
13:07:48 <kmc> srsly
13:07:51 <chrisdone> mauke: will you make PrintfArg a fully exposed class in printf-mauke?
13:08:17 <mauke> chrisdone: maybe! what types do you want to add?
13:08:56 <chrisdone> i just have some newtype wrappers around Int and String sometimes. it's nice to just write printf "%s" foo rather than printf "%s" (unFoo foo) or whatnot
13:09:23 <mauke> hmm, makes sense
13:09:42 <mauke> and you probably can't use newtype deriving if the class is not exposed
13:09:48 <chrisdone> indeed
13:11:56 <sm__> chrisdone: I think rss2irc head is free of that bug - http://joyful.com/darcsden/simon/rss2irc/browse/rss2irc.hs#L-660
13:12:44 <roconnor> (forall a. (X -> a) -> F X) <-> F a
13:12:45 <chrisdone> sm__: hPutStr h (s++"\r\n")  — no?
13:13:02 <roconnor> (forall a. (X -> a) -> F a) <-> F X
13:13:08 <sm__> right, no printf there. But maybe the one a few lines down
13:13:32 <chrisdone> yep, looks god
13:13:35 <chrisdone> er, good
13:14:53 <chrisdone> is it possible to enforce that printf take a String literal expression and not, say, a Var, with TH? i'm having trouble remembering what can be dictated at that level
13:15:02 <sm__> yeah, I think it is ok. So the lesson for me: don't printf untrusted formatting strings, lest ye suffer % injection attack!!
13:15:18 <chrisdone> hehe
13:15:34 <kmc> chrisdone, shouldn't it just be String -> Q Exp ?
13:15:52 <chrisdone> kmc: won't that allow, e.g. foo (undefined :: String) :: Q Exp?
13:15:57 <kmc> sure
13:16:03 <kmc> that'll crash during compilation
13:16:07 * hackagebot void 0.5.4.3 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.4.3 (EdwardKmett)
13:16:11 <kmc> i mean, if you try to splice it
13:16:26 <kmc> if the string is used at compile time then you don't have to worry about unvalidated user input
13:16:33 <chrisdone> well, what i mean is restrict it to foo "x". like StringLiteral -> Q Exp or somesuch
13:16:41 <kmc> why?
13:16:46 <kmc> what does "restrict" mean?
13:16:54 <kmc> if the restriction is violated, the compiler dies?
13:17:02 <kmc> the same is true for $(foo undefined)
13:17:03 <chrisdone> i mean you could easily write foo arbitraryString = printf arbitraryString
13:17:24 <kmc> no
13:17:28 <kmc> not the way i think you mean
13:17:40 <kmc> i'm saying printf is a function that takes a format string and spits out Haskell code
13:17:57 <kmc> you use it like  $(printf "%s %d") valFromUser otherValFromUser
13:18:07 * hackagebot adjunctions 2.0.1.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.0.1.1 (EdwardKmett)
13:18:26 <kmc> if you say "foo arbitraryString = printf arbitraryString" then you've just made another name for that Haskell-code-generating function
13:18:35 <kmc> and you can't say foo xs = $(printf xs)
13:18:41 <chrisdone> kmc: so what happens if i do let x = "blah" in $(printf xs)
13:18:41 <chrisdone> oh
13:18:42 <kmc> that is a compile-time stage error
13:18:52 <chrisdone> good, that's what i wanted
13:18:55 <kmc> you can't use a variable from runtime at compile time
13:19:13 <chrisdone> i wasn't sure, i've never tried that before
13:19:39 <kmc> what would it mean? generate code which calls into the GHC API or "hint"?
13:19:54 <chrisdone> leave me alone :p
13:20:05 <kmc> that'd be cool; I'd like to see GHC become a nice JIT compiler and erase the stage distinciton
13:20:07 * hackagebot representable-tries 2.0.1.2 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.0.1.2 (EdwardKmett)
13:20:09 * hackagebot wl-pprint-extras 1.2.0.1 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-1.2.0.1 (EdwardKmett)
13:20:13 <kmc> chrisdone, no, I think it would actually be a nice feature
13:20:13 <erus`> @hoogle (a -> m b) -> [a] -> m [b]
13:20:14 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:20:14 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:20:14 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
13:20:22 <kmc> but it's far beyond the current half-assed TH implementation
13:20:47 <chrisdone> i was thinking of topleveldef = "x"; foo = $(printf topleveldef) — i'm not sure… i *think* this does work?
13:21:03 <chrisdone> because it can be used at both runtime and compile-time safetly
13:21:07 * hackagebot wl-pprint-terminfo 0.2.1.1 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.2.1.1 (EdwardKmett)
13:21:25 <kmc> i think splice code is only allowed to use names defined in another module
13:21:35 <chrisdone> yeah, let me check
13:21:39 <kmc> x = $(y); y = $(x)
13:21:49 <chrisdone> hm, not so, it seems
13:21:49 <kmc> i'm not sure, though
13:21:52 <kmc> ok
13:21:59 <accel> shit
13:22:00 <chrisdone> i have a module that defins an IORef toplevel var that i use in the same module
13:22:03 <accel> I need to write a multi threaded app
13:22:07 <accel> involving haskell
13:22:14 <accel> with the multithreaded part in FFI
13:22:25 <hpaste> chrisdoner pasted “TH staging stuff” at http://hpaste.org/49863
13:22:31 <accel> what is the correct way to set this up?
13:22:33 <chrisdone> kmc: fwiw ^
13:22:37 <accel> (context: real time audio playback)
13:23:20 <kmc> accel, I'm not sure what you're asking, specifically
13:24:01 <accel> what nastiness is there relating IO() to multi threading?
13:24:23 <accel> It seems likemulti threading breaks IO a
13:24:26 <kmc> still too vague
13:24:30 <accel> becuase IO a says "you run some shit, and get back an object of type a"
13:24:34 <chrisdone> mostly whether the C code that you're FFI'ing too is reentrant or not
13:24:44 <kmc> accel, forkIO, MVar, Chan, etc. all work inside IO
13:24:44 <accel> where as, if the FFI function ... runs, returns some object of "a"
13:24:49 <kmc> basic concurrency is done in IO in Haskell
13:24:51 <accel> but there's other things that runs in other threads
13:24:59 <accel> man; I'm terribley vague
13:25:05 <kmc> IO actions are not required to have deterministic results
13:25:14 <kmc> there are plenty of examples where they don't, outside of threading
13:25:20 <kmc> like user or network IO
13:25:20 <accel> are they allowed to modify system state
13:25:23 <kmc> yes
13:25:23 <accel> after they reeturn?
13:25:36 <accel> okay, this seems to break IO a = World -> (World, a)
13:25:44 <kmc> right, that model is totally incorrect
13:25:52 <kmc> and this is one of the reasons why
13:25:53 <accel> what is the right model
13:26:10 <kmc> IO actions are descriptions of how IO could be performed
13:26:20 <chrisdone> the main nastiness is when a C library isn't reentrant or doesn't expect to be multithreaded, or its multithreading support is a load of ass, you get segfaults
13:26:21 <kmc> but they're abstract values; you can't take them apart and look at the guts
13:26:54 <accel> kmc: I don't see how to get a mental model out of this
13:27:15 <kmc> here's a model: an IO action is a String
13:27:20 <chrisdone> the model seems to work in one thread?
13:27:24 <kmc> putStr s = "put the string \"" ++ s ++ "\""
13:27:45 <accel> go on
13:27:51 <accel> so this is strings that's sent to some interpreter?
13:28:03 <kmc> yeah
13:28:18 <HotPornYo> Check this out: http://bit.ly/HotPornYo
13:28:23 --- mode: ChanServ set +o copumpkin
13:28:26 --- mode: copumpkin set +b *!~workstati@adsl-99-44-224-240.dsl.pltn13.sbcglobal.net
13:28:26 --- kick: HotPornYo was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
13:28:28 --- mode: copumpkin set -o copumpkin
13:28:34 <accel> and IO a = "we send some shit to interpreter; interpreter odoes some work, sends back an object of type 'a'" ?
13:28:36 * chrisdone puts copumpkin's cigar back in his mouth
13:28:38 <kmc> copumpkin = fastest gun in the west
13:29:05 * copumpkin blows the smoke off his barrel
13:29:21 <kmc> accel, a value of type (IO t) is an imperative program written in some unspecified language
13:29:31 <copumpkin> clearly that language is ruby
13:29:33 <kmc> which produces a result of type t, which you then get back in Haskell
13:29:41 <mauke> no, you get nothing back
13:29:53 <kmc> you get it as the argument to the right-hand function of (>>=)
13:30:01 <copumpkin> you get to give it a callback
13:30:03 <mauke> all you can do is send more stuff to the interpreter
13:30:06 <kmc> yeah
13:30:17 <copumpkin> >>= is the callbackification operator
13:30:20 <kmc> accel, http://www.haskell.org/haskellwiki/Introduction_to_IO
13:30:23 <mauke> don't call us; we'll call you!
13:30:27 <kmc> haha
13:30:32 <edwardk> yay for foreign languages for naming functions
13:30:32 * sm__ thinks of another cheap hackagebot tweak to try: announce in less frequent larger batches, 5m interval instead of 1m ?
13:30:45 <kmc> accel, I guess my question is: what do you get out of the (World -> (a, World)) model that you're now missing
13:31:01 <edwardk> sm_: that might work
13:31:14 <mornfall> Am I supposed to be getting Prelude.undefined on infinite recursion?
13:31:23 <kmc> no mornfall
13:32:06 <Saizan> sm__: i think that was how dons originally had it and it was quite floody
13:32:21 <mornfall> ghci loops forever
13:32:23 <kmc> mornfall, it's impossible in general to detect infinite recursion and error out
13:32:35 <kmc> ghc can detect it in certain cases
13:32:35 <mornfall> But the compiled/optimised code dies with Prelude.undefined.
13:32:38 <kmc> *nod*
13:32:46 <kmc> i'm surprised it says that and not "<<loop>>"
13:32:47 <mornfall> I have seen <<loop>> before.
13:32:51 <mornfall> But not undefined.
13:32:54 <Saizan> or maybe it was "annouce every x new packages" rather than using a time interval
13:33:04 * sm tries
13:33:32 <dolio> It used to be once an hour.
13:33:38 <edwardk> saizan: but that risks them sitting there for a long time
13:33:48 <sm__> dolio, I don't think so
13:34:03 <chrisdone> we use hackagebot at work for redmine activity (support tickets/commits). nice
13:34:21 <sm__> chrisdone: rss2irc ? nice!
13:34:25 <chrisdone> mhm :)
13:34:27 <kmc> mornfall, yeah, that is weird.  let me know if you figure out why :)
13:34:29 <Saizan> edwardk: i'm not advocating it anyway :)
13:34:42 <chrisdone> had to patch it to support sending a password, other than that using it as-is
13:34:44 <sm__> I use it all over. For a while I was announcing craigslist computer gigs in a private channel
13:34:52 <chrisdone> heh, nice
13:35:50 <edwardk> pwd
13:35:58 <edwardk> hah
13:35:59 <chrisdone> actually patched it also to support filtering based on regex. the redmine feed shows all the marketing department activity that devs don't care about, so i filter those out ;)
13:36:20 <sm__> that's good.. I thought I'd added --exclude already but apparently not
13:36:39 <thoughtpolice> oh snap, type classes for C? https://github.com/jhowarth/welcome
13:36:57 <chrisdone> sm__: fwiw: https://github.com/chrisdone/rss2irc/commit/50e0aa273c579a72c4f7ad1c1e14bfb6d1b11878
13:37:52 <sm__> chrisdone: can, er, do a little programming so you can send a pull request from your github repo to the main darcs repo ?
13:38:01 <sm__> can YOU
13:38:02 <sm__> :)
13:38:23 * hackagebot algebra 2.0 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-2.0 (EdwardKmett)
13:38:24 * hackagebot semigroupoid-extras 0.2.6.1 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-0.2.6.1 (EdwardKmett)
13:38:27 * hackagebot recursion-schemes 2.0 - Generalized bananas, lenses and barbed wire  http://hackage.haskell.org/package/recursion-schemes-2.0 (EdwardKmett)
13:39:25 <chrisdone> sm__: i don't know how to use darcs but i'll give it a try after i've finished this task
13:39:25 <sm__> well maybe some day. Thanks, later
13:39:57 <sm__> oh excellent, I thought you were opposed to it. I'm going to lunch but happy to walk you through whenever
13:40:04 <luite> thoughtpolice: hmm, that allows each type to be the instance of only one class?
13:40:57 <thoughtpolice> i haven't looked in any detail whatsoever, i just saw it on twitter. so naturally i'm throwing it in here, to be fed to the lions
13:41:05 <edwardk> i think the hackagebot storm is over for now
13:41:07 * thoughtpolice will look at the paper or whatnot a bit later
13:41:43 <chrisdone> sm__: enjoy your lunch :) i'll give it a go
13:41:48 <thoughtpolice> edwardk: hackagebot needs a rest anyway
13:43:10 <edwardk> i feel like rolling over, looking at hackagebot, and asking "was it good for you?" before lighting a cigarette.
13:43:23 * hackagebot graphs 0.3.2.3 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.3.2.3 (EdwardKmett)
13:43:24 * hackagebot reflection 0.4.0.2 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.4.0.2 (EdwardKmett)
13:43:38 <edwardk> spoke too soon.
13:43:41 <dolio> thoughtpolice: Those don't look like classes to me.
13:44:17 <dolio> Maybe I'm just missing it, though.
13:45:06 <chrisdone> edwardk: i envision the Fight Club response; ‘are we done?’
13:45:54 <thoughtpolice> dolio: that's what i thought too, but again i've looked for maybe 10 seconds and decided to throw it here to the lions like i said
13:45:54 <Keko> pl  \f g  x y ->  f (g x) ( g y)
13:46:06 <chrisdone> :t on
13:46:07 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:46:13 <edwardk> chrisdone: =)
13:46:14 <thoughtpolice> @quote edwardk i feel like rolling over, looking at hackagebot, and asking "was it good for you?" before lighting a cigarette.
13:46:15 <lambdabot> No quotes match. Take a stress pill and think things over.
13:46:17 <thoughtpolice> er
13:46:23 <thoughtpolice> @remember edwardk i feel like rolling over, looking at hackagebot, and asking "was it good for you?" before lighting a cigarette.
13:46:24 <lambdabot> I will remember.
13:47:38 <Keko> Hi. How to ask lambdabot to point-free this : pl  \f g  x y ->  f (g x) ( g y) ?
13:47:41 <chrisdone> Keko: f (g x) (g y) == on f g x y
13:48:01 <kmc> @pl  \f g  x y ->  f (g x) ( g y)
13:48:02 <lambdabot> join . ((flip . ((.) .)) .) . (.)
13:48:06 <kmc> it doesn't know about 'on'
13:48:21 <Keko> thx
13:48:30 <pe> Hi. Is there an equivalent to Ocaml's Eliom in haskell ?
13:48:55 <pe> I.e. something to generate entire web services, including haskell to javascript compilation
13:49:51 <chrisdone> haskell→js is still in alpha stages (see ghcjs and uhc (and yhc and nhc did it in the past))
13:50:23 <chrisdone> but i tried it and it works. probably gonna hack on it at CamHac
13:50:52 <Keko> I'd like to know what's \x y  -> (or (not x) (not y)) looks like in point free style (I knw it's equivalent to nand).
13:51:04 <chrisdone> > on or not True False
13:51:06 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool] -> c'
13:51:06 <lambdabot>         against inferre...
13:51:14 <chrisdone> oh, not or
13:51:17 <chrisdone> > on (||) not True False
13:51:18 <lambdabot>   True
13:51:49 <kmc> :t (||) `on` not
13:51:50 <lambdabot> Bool -> Bool -> Bool
13:51:50 <chrisdone> > zipWith (on (||) not) [True,False,False,True,False] [False,False,True,True,True]
13:51:51 <lambdabot>   [True,True,True,False,True]
13:52:21 <Keko> thank you, but I'm specifically interested in point free style...
13:52:29 <chrisdone> o_o
13:52:30 <mauke> that is points-free
13:52:43 <Keko> what's on ?
13:52:50 <mauke> > join (liftM2 (on (||) not)) [minBound .. maxBound]
13:52:51 <lambdabot>   [True,True,True,False]
13:53:04 <mauke> @src on
13:53:04 <lambdabot> (*) `on` f = \x y -> f x * f y
13:53:20 <dylukes> http://ocsigen.org/eliom/manual/xhtml
13:53:23 * hackagebot zeromq-haskell 0.7.0 - bindings to zeromq  http://hackage.haskell.org/package/zeromq-haskell-0.7.0 (ToralfWittner)
13:53:24 <dylukes> >o>
13:56:15 <dolio> thoughtpolice: What it looks like is a safer way to do the normally unsafe struct subtyping in C.
13:57:32 <dolio> I.E. you can cast struct {a, b, c} to struct {a} and it works because the layout is the same.
13:57:47 <dolio> For the parts that the latter cares about.
13:59:39 <dolio> I doubt the author has a very good argument that that has something to do with type classes, though.
14:02:16 <erasmas> does anyone think tutorials on parsing with AttoParsec would be helpful to add to the wiki?
14:02:34 <ortmage> i'd probably read them
14:02:35 <Keko> Is there a clean tuple constructor constructor in haskell, or does it need meta-programming (or multi stage...) cnstruct ?
14:02:56 <dolio> Clean?
14:03:06 <Keko> something elegant
14:03:16 <shachaf> What's a tuple constructor constructor?
14:03:20 <dolio> > (,,) 1 2 3
14:03:20 <lambdabot>   (1,2,3)
14:03:57 <companion_cube> neat!
14:04:16 <Keko> (,,) is a 3 tuple constuctor, not a n tuple constructo constructor
14:04:37 <dolio> Do you mean like 'tuple 3' would produce that, and 'tuple 5' would be (,,,,)?
14:04:50 <danharaj> :k (,)
14:04:51 <lambdabot> * -> * -> *
14:04:54 <Keko> yes
14:04:58 <erasmas> I've reached that stage of learning Haskell where if I don't start writing tutorials the community actually needs I'll be forced to join the legions of bloggers who share revelations about monads
14:05:08 <dolio> Then you need template Haskell, or some type-level programming.
14:05:14 <tech2> erasmas: quick, find a blog!
14:05:19 <mwc> erasmas: lol
14:05:51 <danharaj> Why doesn't GHC have the omega in system F_omega :[
14:06:03 <Keko> dolio : is template haslkell the haskell metaprogramming ?
14:06:09 <danharaj> Keko: Yes.
14:06:10 <dolio> Yes.
14:06:13 <danharaj> Only supported by GHC.
14:06:31 <dolio> Any solution to this is going to be GHC specific, most likely.
14:07:24 <Keko> Thanks you all.
14:08:40 <chrisdone> you all everbody ♫
14:10:16 <erasmas> is it acceptable/recommended to start adding things to the haskell wiki, or would a blog be better? (for some introductory attoparsec tutorials)
14:11:34 <chrisdone> i'd prefer wiki. blogs disappear and/or become irrelevant over time
14:13:03 <erasmas> chrisdone: I'll put a few things together then. I guess I'm looking for a review process or competency test of some kind...
14:13:41 <chrisdone> are you the same guy that was talking about judging whether he was a good haskell programmer the other day?
14:13:55 <erasmas> no
14:14:02 <chrisdone> oic
14:14:44 <erasmas> the competency test was tongue in cheek. I don't want a certificate or anything, but being self-taught I don't want to add to the "noise". I read a lot of misleading posts/tutorials when I was first learning Haskell
14:16:44 <byorgey> erasmas: for a review process, just send an email to haskell-cafe saying "hey, I just wrote an attoparsec tutorial at <url>, any feedback is appreciated"
14:17:03 <chrisdone> probably get good response from /r/haskell too
14:18:30 <hpaste> tech2 pasted “yet more tomfoolery” at http://hpaste.org/49866
14:19:14 <tech2> Hi all, I'm just trying to work out if I'm doing things completely incorrectly or if there's some way I could improve things stylistically?
14:19:25 <Keko> Does a monadic  style program is compiled to efficient machine code ?
14:19:26 <acowley> copumpkin: why are you quizzing people on G+?
14:19:39 <copumpkin> why not
14:19:41 <Keko> Is a monadic...*
14:19:47 <copumpkin> :)
14:19:47 <mwc> There's organized haskell on google+?
14:20:01 <acowley> I'm trying to guess ulterior motives
14:20:13 <acowley> mwc: there's unorganized haskell on google+
14:20:35 <ion> There’s nothing special about monadic code in itself except for potentially a lot of anonymous functions, but one could argue there’s nothing special about *that*. :-P
14:20:39 * mwc wonders how organized the #haskell is on irc.freenode.net
14:21:01 <Keko> monads seems to add an overhead...
14:21:15 <acowley> mwc: it's coorganized
14:21:16 <chrisdone> anyone done a g+ hangout with haskellers?
14:21:25 <mwc> Keko: not really, IO is really just continuations
14:21:29 <shachaf> chrisdone: I saw one yesterday with three people in it.
14:21:32 <thoughtpolice> my g+ is pretty much nothing but haskellers
14:21:41 <thoughtpolice> i should add more. then it can be my exclusive haskell friend community
14:21:54 <copumpkin> acowley: oh, I just wanted to get people to discuss that behavior, really :)
14:21:57 <copumpkin> cause it's counterintuitive
14:21:57 <Keko> mwc: ok
14:21:58 <acowley> tech2: use a qualified import so you can write M.fromJust (or just import that symbol unqualified as it's well known and quite unambiguous)
14:22:22 <thoughtpolice> dolio: yeah, that's the exact impression i got to. i think the standard specifies that kind of cast is safe already, this just adds sugar
14:22:26 <thoughtpolice> *too
14:22:46 <acowley> copumpkin: I thought you were setting up a trick question :)  How is it counterintuitive?
14:23:06 <chrisdone> my g+ is also 95% haskellers
14:23:08 <acowley> well, that's a silly question for me to ask
14:23:29 <ion> My G+ doesn’t exist because John Google doesn’t want to give me access.
14:23:32 <dolio> thoughtpolice: Yeah, I imagine it's specified that the cast is safe. This is just a way to check that you're only doing the safe casts.
14:23:36 <copumpkin> acowley: you think that's obvious behavior? :
14:23:37 <copumpkin> :o
14:24:15 <tech2> acowley: at the moment, given I don't fully understand where things reside in the library I'm just trying to keep track of things, but that's good to know, thanks. Is there a cleaner way of writing things though, in particular the latter two functions?
14:24:18 <kmc> Keko, "monads" don't add anything in general, because they are just an interface, not an implementation
14:24:24 <kmc> Keko, each monad is implemented separately
14:24:32 <kmc> for lists, (>>=) is (flip concatMap)
14:24:40 <thoughtpolice> ion: want access? :P
14:24:41 <kmc> it's not somehow less efficient
14:24:47 <Keko> oh ?
14:25:05 <shachaf> @google flip concatMap
14:25:05 <lambdabot> http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46/2/960526234_VYAt3
14:25:05 <lambdabot> Title: flip concatMap - Sean Leather's Photos
14:25:05 <acowley> copumpkin: yes, but replace "obvious" with "expected" and add the caveat that I write a lot of Haskell
14:25:06 <kmc> Keko, the fact that IO has a monadic interface is mostly irrelevant to how IO works or how it's implemented
14:25:32 <copumpkin> acowley: fair enough :) it just seems slightly inconsistent with how lazy everything else is
14:25:33 <kmc> you can treat (>>=) as having type «IO a -> (a -> IO b) -> IO b», and never notice that this is an instance of a more general pattern
14:25:38 <ion> thoughtpolice: I do, but i don’t think Google Apps users can get access.
14:25:56 <ion> They’re second-class users as usual.
14:25:57 <kmc> Keko, GHC's implementation of the IO type is pretty good at eliminating the continuation-passing overhead
14:26:00 <thoughtpolice> ion: huh
14:26:06 <thoughtpolice> weird
14:26:51 <Keko> kmc : and concerning concat map ?
14:26:53 <ion> keko: Exactly what overhead did you encounter? How was it measured?
14:27:49 <Keko> I am not an haskeller, i never encountered any overhead. i'm just curious about this language.
14:27:52 <acowley> Would a G+ haskell hangout involve several video feeds of people typing on #haskell?
14:27:58 <fasta> Does anyone know what Hangup detected on fd 0 means?
14:28:10 <kmc> Keko, there's a lot to learn before monads
14:28:14 <kmc> don't worry about it right now
14:28:17 <fasta> Basically only the Hangup part, the rest is obvious.
14:28:23 <Keko> But "concat map" is part of the monadic list definition, and i never used this !
14:28:39 <kmc> @src [] (>>=)
14:28:39 <lambdabot> xs >>= f     = concatMap f xs
14:28:52 <thoughtpolice> acowley: hahahaha
14:28:59 <thoughtpolice> for some reason it's very possible it would
14:29:03 <fasta> That is at least what gdb is saying when GHC crashes on a 5 line program...
14:29:05 <thoughtpolice> or, well, it seems that way :)
14:29:20 <Keko> Well, i'm used to functional programming anyway, so i'm specifically interested in particularity of haskell, not it's basic feature.
14:29:23 <kmc> > liftM2 (,) "abc" "xyz"
14:29:24 <fasta> I thought GHC was supposed to never crash.
14:29:24 <lambdabot>   [('a','x'),('a','y'),('a','z'),('b','x'),('b','y'),('b','z'),('c','x'),('c'...
14:29:25 <Peaker> Keko: About your question from above: The compiler can definitely see "through" the monad interface and optimize it away, at least in certain cases. So it doesn't impose any cost inherently
14:29:51 <Peaker> Keko: Which languages?
14:29:57 <Keko> Ocaml
14:30:10 <kmc> > "abc" >>= (\x -> "def" >>= (\y -> [x,y]))
14:30:11 <lambdabot>   "adaeafbdbebfcdcecf"
14:30:18 <Peaker> fasta: I can only guess that "Hangup" is a euphimism for SIGHUP capture or such
14:30:20 <kmc> > "abc" >>= (\x -> "def" >>= (\y -> [(x,y)]))
14:30:21 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
14:30:25 <fasta> Peaker: AFAIK, if you have a stack of of monad transformers, it is not magically going to be compiled away.
14:30:38 <Keko> (and also Prolog... it's not functionnal, but I had to do a lot of list manipulation...)
14:30:41 <Peaker> fasta: And that surprises me :-)
14:30:50 <fasta> Peaker: Oleg pointed this out as a flaw in monad transformers.
14:30:52 <Peaker> fasta: I wonder what's missing in GHC for that
14:31:18 <Peaker> Keko: ah, so you have the HM type system thing covered, right?
14:31:41 <Keko> HM ?
14:31:46 <thoughtpolice> hindley-milner
14:32:07 <Peaker> Keko: ML's type system is very similar to Haskell's, so I'm guessing OCaml's is too, or at least a subset of each
14:32:10 <thoughtpolice> Keko: that is, if you're an ocaml person, then you're at least already used to having a good type system at your disposal :D
14:32:23 <Keko> yes
14:32:38 <ion> A good type system? Haskell doesn’t even have method_missing.
14:33:03 <shachaf> @slap ion
14:33:04 <lambdabot> I'd rather not; ion looks rather dangerous.
14:33:14 <shachaf> Get your method_missing away from me.
14:33:19 <fasta> ion: good troll.
14:33:37 <zzo38> Why do I get error message when I make a function type that uses itself in the input and/or output of the function?
14:33:58 <kmc> zzo38, you don't in general; recursion is a very standard thing to do
14:34:03 <kmc> you probably did so in a type-unsafe way
14:34:04 <Peaker> Keko: well, so you also understand the maybe/option type, right?
14:34:14 <Keko> Yes
14:34:29 <Keko> but Ocaml has great exception...
14:34:35 <Keko> so I never use it
14:34:52 <zzo38> kmc: What is the proper way then? I typed something like:  type Abc = (Xyz, Zyx) -> (Abc, Cba)
14:34:53 <ion> zzo38: What function? What error message?
14:34:59 <zzo38> What is the proper way?
14:34:59 <Peaker> Keko: so, imagine you have a function:  getXMLChild :: String -> Element -> Maybe Element       (bring a child by name, or Nothing if no such child name)
14:35:08 <zzo38> And what if I want it on the input instead?
14:35:20 <copumpkin> Cale: have you considered a @kmc command?
14:35:23 <copumpkin> in lambdabot
14:35:28 <Peaker> Keko: Now imagine you want to get a grandchild -- or a grand-grand-grandchild, using a path.. what kind of combinator would you use to compose these things?
14:36:07 <luite> @kmc C/C++
14:36:08 <lambdabot> Maybe you meant: ghc rc src
14:36:11 <luite> hmm
14:36:17 <Keko> I'm just thinking it's trivial in prolog, right now...
14:36:20 <Peaker> Keko:   case getXMLChild "a" parent of Nothing -> ..   Just child -> case getXMLChild child of ..       will get tiring :-)
14:36:29 <fasta> Keko: prolog is a great language.
14:36:39 <Peaker> Keko: especially since you will repeatedly have nested cases that map Nothing to Nothing
14:38:08 <zzo38> How do you know how to do my question?
14:38:21 <Keko> Peaker : yes, so ?
14:38:30 <Peaker> Keko: What I'm trying to lead to, is that it may become convenient to write a function that does all the Nothing->Nothing cases for you.  So in case of Just, it continues to the next thing to do.  The type is:    Maybe a -> (a -> Maybe b) -> Maybe b
14:39:01 <Peaker> Keko: oh wait, I'm assuming you don't understand what Monads are/useful for, and leading there.. if you already know, I misunderstood
14:39:14 <Keko> Yes, instead of messing with the type system, adding ... | Nothing to each declaration...
14:40:04 <Keko> I understand it's a programming pattern solving some problem... I'm just not convinced it's that efficient.
14:40:07 <hpaste> acowley pasted “tech2 takes” at http://hpaste.org/49868
14:40:28 <Peaker> Keko: efficient in runtime? or otherwise?
14:40:30 <ion> zzo38: Type synonyms don’t support cycles, try making it a newtype.
14:40:34 <acowley> tech2: I put a couple other options there for you to look at
14:40:38 <Keko> y, runtime
14:40:42 <Cale> zzo38: Can you show the code for what you're trying?
14:40:47 <zzo38> ion: I tried "newtype" instead of "type" but that failed too
14:40:50 <Cale> zzo38: What function are you trying to calculate?
14:40:50 <dolio> Efficient compared to what?
14:40:58 <zzo38> Cale: I did write the entire code
14:41:01 <acowley> tech2: also, idiomatic Haskell would have that named nextLargest
14:41:09 <Peaker> Keko: implementations have efficiency, not interfaces..
14:41:26 <Cale> I see a type synonym...
14:42:00 <Keko> Efficient like... minimum number of instruction to do the same job ?
14:42:23 <Cale> zzo38: Oh, type synonyms are not allowed to be recursive.
14:42:25 <Peaker> Keko: Well, monad instances do things, the monad type-class doesn't do much.
14:42:32 <Cale> zzo38: because they're just syntax sugat
14:42:34 <Cale> sugar*
14:42:55 <Cale> zzo38: You could write  newtype Abc = C ((Xyz, Zyx) -> (Abc, Cba))
14:42:57 <dolio> To do what job?
14:42:57 <Peaker> Keko: The IO monad instance does things efficiently.. The Maybe monad instance is efficient.  fasta mentioned above how Monad Transformers are inefficient (they're a particular monad instance)
14:43:14 <Cale> Where C is some new data constructor being introduced
14:43:20 <zzo38> Cale: OK I will try that.
14:43:25 <tech2> thanks acowley, yeah, I haven't really looked at naming conventions yet. I come from a python background so I've kinda got a bit of legacy behind me in terms of naming.
14:43:28 <Keko> Peaker : He does? I missed it.
14:43:48 <acowley> tech2: sure, it's hard to keep them straight
14:43:49 <Cale> zzo38: You're not allowed to have infinite types, because they *usually* indicate mistakes
14:43:52 <Peaker> Keko: Does OCaml have interfaces?  Or just module signatures?  Is there any particular example module signature that's commonly used?
14:44:09 <acowley> tech2: whenever I switch over to Python I forget colons and make a hash of using consistent style for names
14:44:30 <Cale> (There are a lot of stupid mistakes which will typecheck if infinite types are allowed)
14:44:36 <zzo38> Cale: Is there some pragma to override that?
14:44:42 <erasmas> yesterday I found myself typing "let x = ...." in the python interpreter
14:44:56 <tech2> acowley: so it's not that there's a much simpler way of doing what I want to do with unfoldr or something?
14:45:25 <Keko> Peaker : Ocaml has "interface" like c has .h, and also modules and objects.
14:45:39 <acowley> tech2: which part?
14:46:02 <Peaker> Keko: well, are interfaces efficient? Is a specific interface (e.g: Map interface) efficient?
14:46:41 <acowley> tech2: bigger = iterate next_largest
14:46:49 <tech2> acowley: primarily the nextLargest
14:47:25 <tech2> acowley: it just seems (feels?) overly complex to me
14:47:48 <ddarius> acowley: Switch over to ruby.
14:48:09 <zzo38> Cale: Your code    newtype Abc = C ((Xyz, Zyx) -> (Abc, Cba))   compiles but how can you define a function with this type? Sorry I am a bit confused by these things
14:48:28 <acowley> ddarius: I used ruby for a few years, but I'd still have the naming problem
14:48:48 <ion> zzo38: Why do you want that type anyway?
14:49:22 <Cale> zzo38: Well, it's not directly a function type. You use the data constructor C :: ((Xyz, Zyx) -> (Abc, Cba)) -> Abc
14:49:48 <Cale> (It might help if Xyz, etc. were actual datatypes, I could write real code...)
14:49:53 <ddarius> acowley: My comment was meant as a solution to the problem.
14:50:12 <acowley> I thought ruby typically used underscores, too?
14:50:13 <Keko> Peaker: i don't know anything called inteface in Ocaml, I mean not like anything you talk about. There is functor to parametrized module and object oriented feature.
14:50:14 <Cale> foo = C (\(xyz,zyx) -> (foo, cba))
14:50:15 <zzo38> Cale: For testing, I just defined them as   type Xyz = Int  and so on
14:50:34 <Peaker> Keko: What functors are useful for example?
14:50:58 <ddarius> s/was/wasn't/
14:51:07 <Peaker> Keko: a functor is tied to a particular implementation, right?  There are signatures which are just interfaces?
14:51:27 <Keko> Sorry, I can't think any general kind. It is used for generic programming for instance.
14:52:04 <rudyl313> Does anybody know of a good haskell library that can parse HTML and allow you to search for nodes via css selectors (kinda like nokogiri for ruby)?
14:53:35 <zzo38> Cale: That code compiles but how can you call a function?
14:54:01 <Cale> g (C f) = f (xyz, zyx)
14:54:19 <Cale> You have to pattern match away the C data constructor
15:00:05 <zzo38> Yes finally I figured it out thanks
15:01:13 <zzo38> But it didn't work until I added:   instance Show Xyz where show x = "..."
15:01:21 <zzo38> Now it works OK thanks you OK
15:02:33 <erasmas> rudyl313: I don't know of a library like that. out of curiousity, what do you use it for?
15:03:15 <rudyl313> erasmas: wanna extract data from a webpage table
15:04:39 <erasmas> rudyl313: you might try http://hackage.haskell.org/package/tagsoup
15:06:07 <rudyl313> erasmas: thats the one I tried first, but it doesn't have a css or xpath searching functionality
15:09:50 <fasta> How do I do make uninstall with a binary release of GHC?
15:10:25 <erasmas> rudyl313: yeah, that's the part I wasn't sure about... some of the xml libraries support xpath, so your best bet might be something like HXT where you can use your own filter combinators to extract information from the html format
15:11:00 <fasta> It seems they simply don't support an uninstallation target. Isn't this Software Engineering 101?
15:11:24 <fasta> "Be able to clean up the mess you create."
15:11:53 <shachaf> fasta: Also there's no cabal uninstall.
15:12:14 <rudyl313> erasmas: busy giving haxml a try
15:12:33 <fasta> shachaf: another epic failure.
15:13:11 <fasta> Apparently there are tools to guard against such stupidity.
15:13:20 <cmccann> fasta, if you're installing your own compiler I think the assumption is you can take care of yourself
15:13:21 <mm_freak> what's the default precedence number of an operator, if none is specified by infix*?
15:13:22 <fasta> (which in turn legalize such build systems)
15:13:34 <mm_freak> especially for `backtick` operators
15:13:59 <fasta> cmccann: a silly excuse, IMHO.
15:14:12 <acowley> Is there a canonical tuple type with a single type parameter?
15:14:33 <shachaf> acowley: There's Control.Monad.Identity.
15:14:54 <shachaf> (Which is a newtype, not a data, and also somewhat specialized in purpose, but still.)
15:14:58 <fasta> I think it takes about 10 minutes to make something that always works on Unix like systems.
15:15:03 <cmccann> acowley, isn't that just a fixed-length list?
15:15:09 <fasta> To also make it work on Windows is another 20 minutes.
15:15:12 <mm_freak> acowley: (a, a)
15:15:15 <edwardk> acowley: vector ;)
15:15:21 <acowley> cmccann: yes
15:15:27 <cmccann> mm_freak, I assume he means something that can be an instance of Functor etc.
15:15:27 <shachaf> Oh, I misunderstood.
15:15:32 <acowley> edwardk: dammit
15:15:33 <cmccann> (a, a) doesn't work so well for that
15:15:45 <acowley> cmccann is precisely right
15:15:49 <edwardk> acowley: vector-static has one iirc. i was going to add one to representable-tries (and probably factor it out, but i never got to it)
15:15:57 <mm_freak> not without a custom newtype
15:16:01 <DukeDave> Here's a little one for you: I'm using Debug.Trace, but the variable I want to output isn't constrained by Show.
15:16:01 <DukeDave> I know that it (an Int) is show-able, but I don't want to have to add the constraint all the way up the call tree just for debugging. Do we know a (force-type-esque) work-around?
15:16:12 <acowley> the frustration is that I always end up writing my own and then having to define relevent VectorSpace instances
15:16:26 <mm_freak> acowley: although the (Bool ->) monad has the semantics you're asking for
15:16:27 <cmccann> acowley, I have about three hacked-together versions of things like that lying around, so if there's a canonical one I'd like to know
15:16:40 <edwardk> just use a function and if you need to memoize it use HasTrie
15:17:00 <edwardk> acowley: that is what i do in the algebra package.
15:17:01 <shachaf> DukeDave: unsafeCoerce? :-)
15:17:23 <acowley> edwardk: you use a function?
15:17:34 <edwardk> acowley: i use representable functors.
15:17:48 <DukeDave> shachaf: Ah, I hadn't met that before, looks perfect, thanks :D
15:17:52 <zzo38> How can you define a opaque type in Haskell so that the stuff dealing with the structures and data stored in that type is programming in C instead of Haskell, but that the object is still a type in Haskell?
15:17:53 <DukeDave> shachaf++
15:17:58 <shachaf> DukeDave: ...I was kind of joking.
15:18:03 <edwardk> a representable functor is one where f a is isomorphic to (x -> a) for some x
15:18:08 <acowley> edwardk: doesn't that seem a bit much for a lowly pair? I just want a strict, functorial pair that I'll pattern match a lot
15:18:12 <DukeDave> shachaf: Well, I only need it for debugging :)
15:18:23 * hackagebot reducers 0.1 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-0.1 (EdwardKmett)
15:18:25 <edwardk> it you want all that, then just write one ;)
15:18:36 <acowley> I write it regularly
15:18:45 <acowley> I just don't have a good name for it
15:18:47 <mokus> DukeDave: unsafeCoerce can give you a lot to debug ;)
15:18:51 <edwardk> Pair
15:18:54 <mm_freak> acowley: if you don't want to define it yourself and you don't want to have a package dependency, then you can use (Bool ->) together with view patterns
15:19:02 <acowley> edwardk: indeed
15:19:05 <c_wraith> zzo38: EmptyDataDecls is a common extension to create a type with no constructors
15:19:11 <acowley> mm_freak: that's true
15:19:15 <edwardk> mm_freak: the Bool -> version doesn't memoize its results like an ADT does
15:19:39 <c_wraith> zzo38: and you'll generally be using either a Ptr Foo or ForeignPtr Foo to actually manage the data structure
15:19:58 <mm_freak> edwardk: memoize?  it does the usual sharing, as long as you give the pair members names
15:20:06 <c_wraith> zzo38: which one of those you use depends on who is responsible for cleaning up the memory eventually - the c code or the haskell code
15:20:42 <cmccann> c_wraith, Bool -> a is isomorphic to (a, a), but the tuple elements are computed only once, whereas the function is recomputed each time
15:20:58 <mm_freak> and with view patterns, (Bool ->) is surprisingly convenient to work with
15:21:08 <DukeDave> shachaf: mokus: I can see how it could cause a problem, however it works just great like this:
15:21:08 <DukeDave> traceShow (unsafeCoerce i :: Int)
15:21:11 <mm_freak> the only thing you probably want is to define a smart constructor
15:21:15 <edwardk> mm_freak: i mean that if it computes anything with the False and True it can have to do recomputation next time you ask it for its True member
15:21:19 <acowley> vector-static does have a lot going for it, I suppose
15:21:36 <mm_freak> the smart constructor is just the functional version of 'if', btw =)
15:21:37 <c_wraith> zzo38: if you want to have haskell access to fields in the data structure, things get a bit more complicated.  You have multiple options then, none of which are exactly simple.
15:21:55 <c_wraith> cmccann: I suspect that wasn't aimed at me. :)
15:22:00 <mokus> DukeDave: yea, if you know for certain the monomorphic type it will be, then unsafeCoerce is safe
15:22:06 <edwardk> acowley: be warned it is largely unmaintained at this point i believe
15:22:09 <mm_freak> edwardk: yes, that happens, if you don't use sharing
15:22:12 <edwardk> since copumpkin got bored with it
15:22:15 <cmccann> c_wraith, argh, sorry
15:22:58 <acowley> edwardk: thanks for the warning
15:23:03 <acowley> guess I'll use derpa
15:24:16 * edwardk is lost in a twisty maze of packages, all alike.
15:27:53 <cmccann> edwardk, pretty soon you'll need all that category theory stuff just to analyze the dependency graph of your packages
15:28:12 <edwardk> cmccann: hah. i should use acowley's acyclic topsort ;)
15:29:10 * cmccann considers the merits of treating packages as objects and dependencies between compatible versions as distinct morphisms
15:30:55 <acowley> are we going to get generalized newtype deriving for classes with arity > 1 at some point?
15:31:23 <edwardk> it works just in the last argument
15:31:30 <edwardk> just specify the first couple
15:31:34 <edwardk> this is actually a real problem
15:32:00 <edwardk> deriving (MonadReader Foo) does work though
15:32:50 <acowley> I wanted to derive Data.Vector.Generic.Vector for a newtype
15:32:53 <acowley> seems tricky
15:33:24 <edwardk> ah there you are out of luck
15:33:39 <edwardk> the one you want to derive isn't the last argument of the class
15:33:57 <edwardk> have you tried using standalone deriving?
15:34:00 <acowley> type level flip to the rescue!
15:34:40 <edwardk> deriving instance blah blah => Vector blah blah ?
15:37:57 <acowley> edwardk: "The last argument of the instance must be a data or newtype application"
15:39:35 <ion> deriving implementation HaskellCompiler
15:52:02 <tswett> > cos 1.0 == cos 1.0
15:52:03 <lambdabot>   True
15:52:05 <tswett> Whew.
15:55:08 <parcs> > (cos - cos) 1 == 0
15:55:09 <lambdabot>   True
15:55:23 <coppro> tswett: that's obviously true dude
15:55:43 <tswett> coppro: I'm just making sure that this isn't a case where taking the cosine of the same number twice yields different results each time.
15:55:44 <c_wraith> coppro: hah
15:56:07 <c_wraith> > 0.0 / 0.0 == 0.0 / 0.0
15:56:08 <lambdabot>   False
15:56:21 <tswett> Supposedly, such cases exist.
15:56:27 <cmccann> > 0/0 > 0/0
15:56:27 <lambdabot>   False
15:56:34 <cmccann> > compare (0/0) (0/0)
15:56:35 <lambdabot>   GT
15:56:37 <cmccann> hm
15:56:41 <Claudius1aximus> > (cos - cos) (0 / 0)
15:56:42 <lambdabot>   NaN
15:59:12 <bscarlet> > 0/0 == 0/0
15:59:13 <lambdabot>   False
16:00:34 <tech2> is  (>xlen) . snd  the same as (\ (_, ylen) -> ylen > xlen) assuming xlen is defined?
16:00:51 <mauke> @unpl (>xlen) . snd
16:00:52 <lambdabot> (\ d -> (snd d) > xlen)
16:01:00 <c_wraith> yes
16:01:13 <mauke> @pl  (\ (_, ylen) -> ylen > xlen)
16:01:14 <lambdabot> (> xlen) . snd
16:01:14 <cmccann> @pl (\ (_, ylen) -> ylen > xlen)
16:01:14 <lambdabot> (> xlen) . snd
16:01:16 <cmccann> pf
16:01:30 * cmccann was too slow on the draw
16:01:39 <tech2> thanks :) Still getting my head around composition.
16:03:20 <bscarlet> :t head . (.)
16:03:21 <lambdabot>     Couldn't match expected type `[a]'
16:03:21 <lambdabot>            against inferred type `f a1 -> f b'
16:03:21 <lambdabot>     Probable cause: `.' is applied to too few arguments
16:03:23 * hackagebot printf-mauke 0.5.1 - A Perl printf like formatter.  http://hackage.haskell.org/package/printf-mauke-0.5.1 (LukasMai)
16:03:39 <bscarlet> tech2: can't get head around composition
16:03:49 <bscarlet> tech2: (sorry)
16:03:52 <mauke> hnnrg
16:04:19 <tech2> bscarlet: :) I figured I ought to try something different, for me, this is different.
16:04:33 <Peaker> is the convenience of printf worth the type unsafety?
16:04:39 <mauke> Peaker: yes
16:04:46 <mauke> it's not even unsafe with TH
16:04:55 <Peaker> mauke: how do you make it safe with TH?
16:05:30 <Peaker> is there something that makes it safe or are you talking about theory?
16:05:50 <mauke> $(printf "%s %d") "hello" "world"
16:05:55 <mauke> <interactive>:1:3:
16:05:55 <mauke>     No instance for (Integral [Char])
16:06:19 <bscarlet> tech2: good
16:07:34 <tech2> @pl (\ y -> (head y, fromIntegral (length y)))
16:07:34 <lambdabot> liftM2 (,) head (fromIntegral . length)
16:08:42 <Favonia> @t (id, id)
16:08:42 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
16:09:06 <bscarlet> :t (id, id)
16:09:07 <lambdabot> forall a a1. (a -> a, a1 -> a1)
16:09:19 <bscarlet> :t id &&& id
16:09:20 <lambdabot> forall b. b -> (b, b)
16:09:21 <Peaker> mauke: cool.. is that part of your package?
16:09:26 <mauke> Peaker: yes
16:09:31 <Peaker> mauke: ah, nice! :-)
16:09:54 <bscarlet> :t id *** id
16:09:55 <lambdabot> forall b b'. (b, b') -> (b, b')
16:10:22 <mauke> preflex: seen chrisdone
16:10:23 <preflex>  chrisdone was last seen on #haskell 1 hour, 47 minutes and 20 seconds ago, saying: my g+ is also 95% haskellers
16:11:15 <Peaker> :t (id :: forall a. a->a) &&& (id :: forall a. a->a)
16:11:15 <lambdabot> forall b. b -> (b, b)
16:11:25 <mauke> preflex: tell chrisdone printf-mauke updated. I think I exposed everything you need to instantiate PrintfArg
16:11:25 <preflex>  Consider it noted.
16:13:36 <dainanaki> Hey all, still fiddling with Hint. Is there any way to get a list of modules that are available to load? Something along the lines of all of the modules that come up when you :m TAB in ghci?
16:18:43 <scooty-puff> is using the List monoid in the Writer monad inefficient?
16:18:51 <danharaj> sorta
16:19:14 <scooty-puff> guess thats a good answer
16:19:24 <scooty-puff> was planning on using [a] -> [a]
16:19:28 <danharaj> You always want to profile to find out
16:19:44 <danharaj> If it is inefficient, it's not hard to retrofit a more efficient data structure for appends.
16:20:02 <scooty-puff> k
16:20:32 <bscarlet> scooty-puff: I like Endo
16:21:34 <scooty-puff> k
16:25:43 <dainanaki> So does anybody know how to get a list of what modules are available on a system with ghc installed?
16:25:48 <dankna> ghc-pkg list
16:25:53 <dainanaki> programmatically
16:26:00 <dainanaki> and that's packages, not modules.
16:26:16 <dankna> ah.  well, the GHC API will tell you what packages if you use it properly, but it's not easy and why do you want to?
16:27:14 <dainanaki> Because I'm doing some work with hint and want to be able to load all modules that fit a given pattern, including installed modules.
16:27:34 <dankna> hmm okay
16:27:44 <dankna> well, unfortunately the GHC API is mostly undocumented
16:27:50 <dankna> so have fun learning it
16:30:11 <luite> dankna: it looks like this is more a job for the cabal api
16:30:19 <augur> dankna: heyo
16:30:34 <luite> you can get the exposed modules for a package with that
16:30:43 <dankna> oh, good call
16:30:49 <dainanaki> is that how ghci does it?
16:30:50 <dankna> augur: oh!  I'm not in the channel
16:30:53 <augur> ;p
16:31:04 <augur> anyone know about eliminating backtracking by using more complex data structures?
16:31:09 <Favonia> hmm I found the link in the topic leads to GHC 7.0.1. shall we change it to 7.0.4?
16:32:25 <Saizan> should be changed to http://www.haskell.org/ghc/download maybe
16:32:40 <augur> Saizan: do you know? :D
16:32:43 <augur> you always seem to know something
16:33:35 <aavogt> dainanaki: ghci uses the ghc api for doing things. If you look in http://hackage.haskell.org/package/ghci-haskeline you can find a  completeModule  function which gets a list of modules
16:34:49 <Saizan> augur: no, sorry
16:35:02 <luite> the alternative is cabal: getInstalledPackages
16:35:27 <hpc> @pl \f g x -> f x >>= \y -> g x >>= \z -> return (y,z)
16:35:27 <lambdabot> (. flip (flip . (((.) . (>>=)) .)) ((return .) . (,))) . liftM2 (>>=)
16:35:32 <luite> but apparently that runs ghc-pkg, so the ghc api is probably more efficient
16:35:36 <hpc> oh a fat lot of good you are, λbot
16:36:07 <dainanaki> hmm, the ghc api certainly seems a lot hairier to mess with too.
16:36:31 <luite> it's probably less stable
16:36:58 <zomg> Yay
16:37:05 <zomg> I got mutable variables via IORef working
16:37:07 <hpc> @pl \f g a -> f a >> g a >> return ()
16:37:07 <lambdabot> flip flip (return ()) . ((flip . ((>>) .)) .) . liftM2 (>>)
16:37:12 <zomg> Although I haven't got the slightest clue what I'm doing
16:37:14 <zomg> but.. it works
16:37:14 <zomg> :P
16:37:42 <hpc> hmm, no terse definition of kleisli (&&&) without just using kleisli itself
16:37:49 <zomg> It's ugly as hell though, probably a side effect of not having a clue
16:38:58 <dainanaki> I used an IORef one time. that was fun.
16:39:02 <aavogt> IORef is kind of verbose, since elsewhere   writeIORef ref value   is     ref = value or similar (and it's worse for reading things)
16:39:30 <cmccann> if you're doing something with a mutable reference where some code only reads/writes to it, you can partially apply the read/write function and pass that around instead
16:39:47 <cmccann> helps both with obvious correct use and makes the code tidier
16:40:10 <dainanaki> I've only ever used IORefs when dealing with OpenGL. I haven't seen any other use cases that really make it an attractive idea.
16:40:34 <zomg> dainanaki: well it lets me have variables I can change :P maybe there's some other way of doing it but I have no idea =)
16:40:56 <dainanaki> You probably ought to learn about the State monad.
16:40:58 <cmccann> dainanaki, I've never actually used IORef I don't think but the syntax of using them is identical to TVars, STRefs, and such that have more interesting uses
16:41:11 <zomg> dainanaki: I was staring at it for a while and felt stupid
16:41:12 <zomg> :D
16:41:21 <kmc> IORefs are attractive in situations where you would use STRef but you can't (for whatever reason) satisfy the static checking on runST
16:41:30 <dainanaki> zomg: Me too when I first started learning haskell.
16:41:58 <dainanaki> zomg: but learning it will help you understand even more complicated stuff in the future.
16:42:05 <zomg> I suppose so
16:42:15 <zomg> I sorta get what it does but sorta don't =)
16:42:19 <kmc> (State s a) is a wrapper on (s -> (a, s))
16:42:24 * cmccann notes that if you use lenses + state monad, the lens works almost exactly like an IORef
16:43:07 <kmc> zomg, your function gets an old state as an argument, and returns a new state together with a result
16:43:26 <kmc> the (>>=) operator for State just pipes these together in the obvious way
16:45:44 <kmc> @djinn (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
16:45:45 <lambdabot> f a b c =
16:45:45 <lambdabot>     case a c of
16:45:45 <lambdabot>     (d, e) -> b d e
16:46:52 <luite> hmm, I have a .psd file with a lot of layers, how can I quickly find the layers that have visible pixels at some location in the image?
16:48:46 <luite> err sorry that was a -blah question
16:50:18 <blackdog> luite: i think you found something that's off-topic even for -blah. well done!
16:50:36 <luite> blackdog: it's not about haskell so it's on-topic there
16:51:07 <hpaste> kmc pasted “parMap stack overflow” at http://hpaste.org/49872
16:51:24 <kmc> anyone know why this code is stack-overflowing?
16:52:24 <hatds> iterate has poor performance iirc, might not be the issue though
16:52:40 <dainanaki> So I'm getting an irrefutable pattern match exception for this little attempt to get installed packages using Distribution.Simple: test = GHC.getInstalledPackages silent [GlobalPackageDB, UserPackageDB] defaultProgramDb
16:52:42 <kmc> can you elaborate?
16:53:16 <Claudius1aximus> @src maximum
16:53:17 <lambdabot> maximum [] = undefined
16:53:17 <lambdabot> maximum xs = foldl1 max xs
16:53:25 <kmc> ... not foldl' ?
16:53:28 <kmc> sigh
16:53:34 <kmc> that might be it, if @src is to be trusted
16:53:47 <kmc> it's probably got a map / fold fusion rule that goes away
16:53:58 <Claudius1aximus> @hoogle foldl1'
16:53:59 <lambdabot> Data.ByteString foldl1' :: (Word8 -> Word8 -> Word8) -> ByteString -> Word8
16:53:59 <lambdabot> Data.List foldl1' :: (a -> a -> a) -> [a] -> a
16:53:59 <lambdabot> Data.ByteString.Char8 foldl1' :: (Char -> Char -> Char) -> ByteString -> Char
16:54:53 <hatds> kmc try:
16:54:55 <hatds> iterate' f x =  go x where
16:54:56 <hatds> 	go !x = x : go (f x)
16:55:58 <Claudius1aximus> hatds: shouldn't matter here i think, takeWhile is strict in list elements
16:56:21 <kmc> well, it's as strict as the comparison function
16:56:25 <kmc> which for Ints is strict
16:56:32 <kmc> the lists produced by iterate should be small anyway
16:56:36 <kmc> for the most part
16:56:37 <Claudius1aximus> hatds: if it were (iterate f x !! largeN) then iterate' would be better
16:56:45 <hatds> yea I see nvm
16:57:19 <kmc> mäximüm = foldl1' max
16:57:22 <kmc> does not seem to help :/
17:00:56 <aavogt> kmc: how about you use parListChunk instead?
17:01:42 <aavogt> main = print . maximum . withStrategy (parListChunk (div n 2) rseq) $ map (length . collatz) $ [1..n]
17:02:35 <kmc> will try that
17:02:41 <kmc> do you have a theory where the stack overflow is coming from?
17:03:04 <copumpkin> joel spolsky
17:03:21 <shachaf> copumpkin++
17:03:29 <kmc> http://instantrimshot.com/
17:03:29 <shachaf> For awkward English.
17:04:08 <kmc> joel spolsky would probably give me a medal for using recursion
17:04:12 <aavogt> kmc: too many sparks? In any case, that one doesn't overflow
17:04:28 <shachaf> @remember copumpkin <kmc> do you have a theory where the stack overflow is coming from? <copumpkin> joel spolsky
17:04:28 <lambdabot> Done.
17:04:33 <kmc> i'm not sure how too many sparks would cause a stack overflow
17:04:44 <kmc> since they shouldn't directly contribute to excessively nested pattern matching
17:04:58 <shachaf> kmc: I don't think you get medals for using recursion in Haskell.
17:06:57 <kmc> i was kind of hoping that using sparks instead of explicit threads would mean I don't need to explicitly think about decomposition size
17:07:26 <cmccann> shachaf, yes, there's a very sad story behind that, because they wanted to give out medals for using corecursion. then they realized they'd have to take medals away for using recursion, so the whole idea was scrapped
17:08:17 <kmc> anyway the chunked version looks good aavogt, thanks
17:08:22 <kmc> if only i understood why...
17:08:58 <kmc> i would expect an excessive number of sparks to result in low conversion rate
17:09:01 <shachaf> kmc: Is this for your Haskell talk?
17:09:04 <kmc> yes shachaf
17:09:10 * shachaf finds it somewhat ironic, in that case.
17:09:13 <kmc> right now it's not looking great
17:09:14 <kmc> yeah...
17:09:53 <kmc> "Parallelism in Haskell is so easy!  Look, you just add parMap, and, erm... uh, what if I put three exclamation points in..., uh, change this to a 12...  *scratches head*"
17:10:16 <cmccann> kmc, is parallelism really supposed to be easy in Haskell?
17:10:24 <cmccann> I thought it was just supposed to be tractable
17:10:28 <cmccann> which is impressive enough
17:10:33 <kmc> in GHC Haskell i mean ;)
17:10:35 <pikhq> cmccann: "Easy" is relative.
17:10:40 <cmccann> now, concurrency, that's a different story
17:10:48 <cmccann> pikhq, exactly :]
17:11:01 <shachaf> kmc: What about the monad-par thing?
17:11:14 <kmc> shachaf, i haven't had time to look into that
17:11:17 <kmc> maybe i shall
17:11:37 <kmc> my hope for "par" and friends is that they really do act like annotations, with the compiler / RTS deciding how much parallelism you really want
17:11:47 <kmc> in theory just the "sparks" idea should be enough to achieve that
17:11:55 <kmc> but it's not 100% there yet
17:12:57 * kmc finds minimum working chunk size
17:13:17 <dylukes> Could you guys recommend a good C STM implementatin?
17:13:33 <kmc> basically i feel like "too many sparks" should not be a thing
17:14:06 <mauke> np: Love-Colored Master Spark
17:14:15 <dylukes> I think its nice with DSL's when you're able to just swap out functions and "upgrade" behavior.
17:14:20 <dylukes> case in point: stream fusion
17:14:25 <dylukes> well, not just DSL's, languages even
17:14:36 <Cale> I don't think it's possible to implement STM well in any language which doesn't have a mechanism for controlling where effects can occur.
17:15:07 <dylukes> I need optimistic STM for a really really big C binary blob
17:15:12 <dylukes> (this will go within an Erlang NIF)
17:15:25 <kmc> Cale, well, C already has loads of unchecked rules about how you're allowed to use which sort of variable
17:15:29 <dylukes> I need zero-to-no overhead, and contention will almost never occur.
17:15:39 <kmc> you can add a few more unchecked rules without ruining the general flavor of the language
17:15:40 <dylukes> but I need parallel edits.
17:15:57 <dainanaki> I need magic.
17:15:59 <Peaker> kmc: maybe that's semi-possible with automatic profiling -- but sparks cannot have 0 overhead?
17:16:22 <kmc> dylukes, almost no contention -- maybe you can use something simpler than STM?
17:16:26 <dylukes> now that I think about it though
17:16:31 <kmc> an optimistic sequence lock
17:16:35 <kmc> or RCU
17:16:36 <dylukes> yeah
17:16:37 <Peaker> kmc: I think maybe it would be much nicer to annotate with "this is expensive enough to be spark-worthy" than par/pseq
17:16:52 <dylukes> RCU has too high locks.
17:16:55 <dylukes> too high writes*
17:16:56 <Cale> If you're not going to get any safety out of it, there's not much point in STM.
17:17:15 <kmc> Cale, it still makes concurrent code composable
17:17:23 <kmc> unsafe STM is composable in a way unsafe locking isn't
17:17:24 <Cale> Sort of
17:17:54 <Peaker> you can implement "STM" with a single global lock in a language like C.. not efficient, but safe?
17:18:00 <HugoDaniel> hi
17:18:08 <kmc> Peaker, yeah, it's an unattainable goal, but... I only had a million sparks, and like half of them were getting converted
17:18:24 <kmc> a million threads is no problem for the GHC RTS, so why should a million sparks crash the program?
17:18:40 <shachaf> It actually crashed?
17:18:44 <kmc> stack overflow
17:18:54 <shachaf> Oh, right.
17:18:56 <jmcarthur> a global lock still leaves you with the problem of a thread getting stuck until some other thread changes some shared state
17:19:13 <Peaker> stack overflows ought to be easier to debug.. it's not inherently hard
17:19:14 <jmcarthur> which of course won't happen if you need a rollback and can't do it since arbitrary effects may have occurred
17:19:31 <dylukes> the user case is,
17:19:33 <kmc> Peaker, where would i start debugging?
17:19:34 <dylukes> a LOT of editing at once
17:19:35 <Peaker> jmcarthur: with a global lock you don't need a rollback
17:19:36 <dylukes> in different places
17:19:44 <kmc> +RTS -xc just says "<Main.caf><Main.caf>"
17:19:47 <kmc> i don't even have any cafs...
17:19:47 <jmcarthur> Peaker: you do if you're stuck...
17:20:00 <jmcarthur> Peaker: consider any case where you would use retry
17:20:00 <kmc> well, 'main' itself is one
17:20:02 <Peaker> jmcarthur: oh, right, you can't implement "retry"
17:20:07 <kmc> hmm
17:20:12 <kmc> yeah, it's not useful
17:20:18 <kmc> oh duh i forgot some cost centers
17:21:57 <kmc> btw i get the same overflow, and much faster, if i leave off -threaded
17:22:09 <kmc> so methinks there's a problem in parMap itself / in how i'm using it
17:22:15 <kmc> it's not a "too many sparks" problem
17:22:45 <kmc> i bet it's breaking foldl / map fusion
17:23:52 <Cale> z
17:23:53 <Cale> a
17:23:56 <Cale> oops
17:23:59 <kmc> happens with r0 as well as rseq
17:27:26 <gienah> portage only supports ranges like dev-haskell/tagged=0.2*
17:27:38 <gienah> sorry wrong channel
17:31:43 <kmc> yeah, so i have a program where replacing "map" with "parMap r0" causes a stack overflow, even without -threaded
17:31:48 <kmc> that sounds like a bug, no?
17:32:13 <Cale> um, not necessarily
17:32:23 <Cale> is the list constructed with something like iterate?
17:32:34 <kmc> yes
17:32:41 <Cale> yeah, then that's to be expected
17:32:56 <kmc> map (length . takeWhile (>1) . iterate f) [1..n]
17:32:59 <kmc> oh, why's that?
17:33:16 <jmcarthur> i suspect that this is not the problem this time
17:33:21 <jmcarthur> iterate screws up fusion
17:33:21 <Cale> parMap is getting too far ahead and the resulting expression that r0 is evaluating does too many cases at once
17:33:40 <Cale> When you evaluate it sequentially, there's only one case at a time, and the expressions never get very large.
17:33:41 <hatds> parMap is over the enumeration list [1..n], not the iterate list though
17:33:42 <jmcarthur> Cale: parMap isn't being applied to the list generated by iterate
17:33:51 <kmc> that's right
17:33:52 <Cale> oh, I see
17:33:59 <kmc> http://hpaste.org/49872
17:33:59 <jmcarthur> however, it is being applied to a fairly large list
17:34:04 <jmcarthur> still not sure it's the problem though
17:34:07 <jmcarthur> thinking probably not
17:34:11 <kmc> when i use smaller lists, it doesn't overflow, but it spends lots of time in GC
17:34:40 <kmc> my best guess right now is that «foldl1 max . map» fuses in a way that «foldl1 max . parMap r0» doesn't
17:34:50 <kmc> but i'm not sure why that fusion should be necessary to avoid a stack overflow
17:35:06 <kmc> (i tried with foldl1' max too; i didn't actually look up which is the real definition of "maximum")
17:35:18 <jmcarthur> @src maximum
17:35:19 <lambdabot> maximum [] = undefined
17:35:19 <lambdabot> maximum xs = foldl1 max xs
17:35:23 <kmc> i don't trust @src :)
17:35:27 <jmcarthur> ;)
17:35:42 <hatds> maximum isn't a strict fold
17:35:48 <hatds> I've run into that before
17:35:52 <jmcarthur> ew
17:37:39 <Saizan> kmc: what's the input list to that?
17:38:02 <kmc> the hpaste is complete
17:38:08 <kmc> i'm not sure what you mean
17:38:14 <Saizan> ah, missed the paste
17:40:54 <Cale> Try -O2
17:41:04 <Cale> er
17:41:05 <Cale> oh
17:41:14 <kmc> i'm using -O2
17:41:33 <Cale> yeah, I missed that
17:43:46 <Cale> well, hmm, interesting
17:44:02 <Cale> I think the choice of parMap here is not going to help you, since the sparks are so tiny
17:44:19 <Cale> But the behaviour is a little mysterious
17:44:27 <Cale> maybe something like threadscope could help to figure it out
17:44:43 <dmwit> kmc: I also get a stack overflow for the "map" version (without optimizations on).
17:44:47 <Cale> Mine succeeds without an overflow, but it takes a lot longer with parMap
17:45:07 <Cale> cale@ender:~$ ghc -O2 -threaded -rtsopts --make map.hs
17:45:07 <Cale> [1 of 1] Compiling Main             ( map.hs, map.o )
17:45:07 <Cale> Linking map ...
17:45:07 <Cale> cale@ender:~$ ./map +RTS -N2
17:45:07 <Cale> 524
17:45:12 <Cale> took a long time though
17:45:22 <kmc> threadscope shows lots of garbage collection
17:45:40 <aavogt> kmc: openmp has a reduction thing specifically for those kinds of things, so maybe that's a missing feature in Control.Parallel?
17:45:41 <kmc> anyway i'm not even thinking about parallelism atm
17:45:45 <aavogt> http://hpaste.org/49873
17:46:06 <aavogt> (use that as an example of uglier parallelism for the same problem)
17:46:08 <kmc> i'm curious why parMap fails in a way map doesn't, even without -threaded
17:46:19 <kmc> too many sparks might waste time but i don't think they'd cause a stack overflow
17:46:30 <kmc> and there should be no sparks at all without -threaded
17:46:41 <kmc> so it's probably something dumb in the implementation of parMap or in how i'm using it
17:46:44 <kmc> but I'm not sure what
17:47:16 <Cale> main = print . maximum . withStrategy (parListChunk 1000 rseq) . map (length . collatz) $ [1..1000000]
17:47:20 <Cale> ^^ much faster
17:48:41 <xispirito> someone here use xmonad?
17:48:47 <xispirito> ops
17:48:48 <xispirito> xmobar
17:48:48 <xispirito> ?
17:48:53 <kmc> Cale, yeah, that one works well for me
17:50:03 <xispirito> i find a little strange "feature"
17:50:58 <dmwit> xispirito: Yes, join us in #xmonad.
18:05:04 <edwardk> heya dmwit
18:05:24 <edwardk> i packaged up reducers, which is basically monoids rewritten over semigroups
18:09:16 <gienah> I wonder if the Num, Real, Integral and Enum instances in http://hackage.haskell.org/packages/archive/Agata/0.2.1/doc/html/src/Test-Agata-Common.html#Dimension are equivalent to the ones now in tagged
18:10:00 <edwardk> they are
18:10:40 <gienah> edwardk: great, thanks, will try to upstream that change, removing those and trivial package bumps allows Agata to build with ghc 7.2rc1, 7.0.4 and 6.12.3
18:10:51 <edwardk> nice
18:25:01 <dmwit> edwardk: Oh cool, where?
18:26:25 <edwardk> http://hackage.haskell.org/package/reducers
18:26:49 <edwardk> basically Reducer only assumes a Semigroup now, and i added more plumbing to make it do the right thing for the monoidal cases
18:27:11 <edwardk> and i added a Data.Semigroup.Generator to go with Data.Semigroup.Foldable
18:29:07 <dmwit> Oh, unit is interesting.
18:29:18 <edwardk> which one?
18:29:19 <dmwit> I thought these might be monoid actions, but they seem to be a bit more.
18:29:27 <dmwit> Reducer.unit
18:29:54 <edwardk> they aren't quite actions of semigroups or anything like that
18:29:58 <dmwit> Do these have a name that would be familiar to a mathematician? (not claiming to be a mathematician here -- maybe Reducer *is* that name =P)
18:30:06 <edwardk> nah
18:30:10 * dmwit nods
18:30:32 <edwardk> they are some kind of mapping from objects to elements of a monoid, but there is no guarantee of any structure preservation
18:30:54 <edwardk> er s/monoid/semigroup/
18:31:09 <dmwit> Ah, I see.
18:31:21 <dmwit> So snoc m c should be something like m ++ unit c?
18:31:41 <edwardk> yep
18:31:46 <edwardk> those laws exist
18:31:50 <edwardk> snoc and cons are just an optimization
18:31:56 <dmwit> right
18:33:02 <ddarius> Let X be a Set, then X -> UM ~ FX -> M
18:33:56 <edwardk> ddarius: what adjunction are you getting at?
18:35:08 <ddarius> The free monoid adjunction.
18:42:02 <argiopeweb> I'm using Chan for a producer/consumer type of system and I'm worried that my producer's chan is going to hang on to every message it sends out, thereby creating a massive memory leak. I should be able to readChan every time I writeChan to remove the message, but is this the cleanest way to go about it? Is this even an issue I should worry about (I.E., can I leave it to the optimizer)?
18:44:30 <mauke> huh?
18:45:08 <dmwit> I think you may be confused about how memory leaks work.
18:46:02 <dmwit> (I'm definitely not an expert myself.)
18:47:16 <xplat> 09:20 < Axman6> there's a guy i know who's writing a python to haskell compiler, which is pretty cool < ion> axman6: Huh. Why not use the languages themselves and FFI instead? < Axman6> ion: why not?
18:47:26 <xplat> actually that pretty much seems like a natural
18:47:53 <xplat> it's traditional in python circles to write python implementations, and traditional in haskell circles to write compilers :)
18:48:05 <mauke> preflex: seen edwardk
18:48:05 <preflex>  edwardk was last seen on #haskell 14 minutes and 9 seconds ago, saying: ddarius: what adjunction are you getting at?
18:48:47 <dmwit> hm
18:49:20 <dmwit> The trouble with Python compilers is their output has to include a Python compiler.
18:49:43 <dmwit> pesky eval
18:50:21 <shachaf> dmwit: "trouble"?
18:50:30 <shachaf> Seems like an excellent strategy, evolutionarily speaking.
18:50:39 <ddarius> argiopeweb: If you are worried about the producer over-running the consumer, you'll want a buffered channel.  Unfortunately, there isn't a convenient buffered channel in the "standard" libraries except for the one-element case, namely an MVar.
18:51:01 <ddarius> Python people write Python implementations?
18:51:02 <argiopeweb> dmwit: Meh, sorry, had to run out. I'm using memory leaks in a very loose way. It's possible I need to actually go look at how Chan works under the hood.
18:51:17 <mauke> ddarius: what's a buffered channel?
18:51:43 <ddarius> Really what I want to say is a finitely buffered synchronous channel.
18:51:58 <ddarius> I.e. you block if you get too far ahead of the reader.
18:51:59 <mauke> a pipe!
18:52:10 <ddarius> Pipes would be an example.
18:52:30 <argiopeweb> ddarius: I'm worried about the fact that I can writeChan to a Chan c and have what I wrote show up on c and all duplicated versions of c. Now, if I don't read from c (my version) and continue writing for it for some time t, the data that has been looped back to my version of c has to reside in memory somewhere.
18:52:45 <mauke> correct
18:53:04 <argiopeweb> Hence memory leak. As mentioned, my off the top of my head fix would be readChan every time I writeChan.
18:53:11 <gienah> fyi there are Erlang like asychronous channels in cloud haskell/remote https://github.com/jepst/CloudHaskell/
18:53:19 <ddarius> It's not a memory leak, though it is undesirable behavior in many cases.
18:53:38 <argiopeweb> I was just wondering if there were a cleaner method. If not, I'm going to wrap it in a function called publishChan and try not to think about it.
18:53:47 <siracusa> What about getChanContents, shouldn't that invoke the consumer each time a new message is written to the channel?
18:54:18 <ddarius> If you use an MVar, you will have a synchronous 1-element buffered channel.  The producer and consumer will proceed in lock-step.
18:54:49 <ddarius> You can shove a ring queue or something in between if you want more slack.  Alternatively, there's a way to do it by using more threads.
18:55:00 <ddarius> (Essentially, a thread for each element in the "buffer.")
18:55:00 <mauke> argiopeweb: http://hpaste.org/49874
18:55:05 <mauke> I think that should do it
18:55:11 <mauke> (warning: untested)
18:55:28 <DevHC> @src curry3
18:55:29 <lambdabot> Source not found. stty: unknown mode: doofus
18:55:33 <DevHC> halp!
18:56:22 <mauke> argiopeweb: the idea is that you have your main writer channel and murderRead it
18:56:26 <mauke> argiopeweb: you can still dup it
18:56:51 <argiopeweb> Absolutely great function names...
18:57:05 <mauke> inorite
18:57:45 <argiopeweb> I'll give it a try, thanks.
19:02:03 * ddarius wishes for a mature CML library.
19:09:10 <monochrom> > let x:y:z = ():undefined in x
19:09:11 <lambdabot>   *Exception: Prelude.undefined
19:09:29 <monochrom> hmm I be damned, but perhaps that's correct
19:09:43 <mauke> > let x:y:z = ():undefined in 42
19:09:44 <lambdabot>   42
19:09:51 <mauke> > let x: ~(y:z) = ():undefined in x
19:09:52 <lambdabot>   ()
19:12:51 <monochrom> > case ():undefined of ~(x:y:z) -> x
19:12:52 <lambdabot>   *Exception: Prelude.undefined
19:13:37 <aavogt> preflex: tell kmc if you inline parMap manually there's no stack overflow (re. parMap rseq (length . collatz))
19:13:37 <preflex>  Consider it noted.
19:13:44 <ddarius> monochrom: Only the outermost match is lazy.
19:14:00 <copumpkin> apparently that's augustss' fault
19:14:21 * ddarius blames copumpkin.
19:14:41 <ddarius> Just kidding.  I blame augustss.
19:15:30 <mauke> preflex: karma augustss
19:15:31 <preflex>  augustss: 9
19:15:42 <shachaf> augustss++ augustss--
19:15:50 * ddarius thinks the behavior is the way it should be.
19:15:55 <shachaf> preflex: karma augustss
19:15:55 <preflex>  augustss: 9
19:16:02 <shachaf> Hmm, preflex /= lambdabot.
19:19:43 <Axman6> > let x:~(y:z) = 1:undefined in x
19:19:45 <lambdabot>   Not in scope: data constructor `:~'
19:19:51 <Axman6> bah
19:20:02 <Axman6> > let x:(~(y:z)) = 1:undefined in x
19:20:03 <lambdabot>   1
19:22:51 * Axman6 wins at pattern matching on undefined
19:23:10 <mauke> Axman6: scroll 10 minutes up
19:23:47 <edwardk> mauke: you rang?
19:24:10 * Axman6 wins second at pattern matching on undefined
19:24:17 <mauke> edwardk: yeah, I've been looking at Data.Reflection
19:24:33 <edwardk> whats up?
19:24:34 <mauke> edwardk: what can you do with ReifiesNums?
19:24:40 <ski> > let x: ~(y:z) = 1:undefined in x
19:24:41 <lambdabot>   1
19:24:44 <edwardk> it is mostly a stepping stone
19:25:01 <mauke> it has no methods
19:25:03 <edwardk> i suppose you could use it directly if you had a list of integrals you wanted to reify
19:25:09 <edwardk> ah
19:25:11 <edwardk> hrmm
19:25:19 <roconnor> edwardk: what's your favourite monad library?
19:26:12 <edwardk> depends on the monad i want ;)
19:26:20 <roconnor> state
19:26:23 <edwardk> i just use transformers and mtl as a rule though
19:26:26 <roconnor> and maybe excpetion
19:26:35 <edwardk> use transformers, and mtl if you need the actual mptcs
19:27:10 <edwardk> mauke: pushed a version that exposed it
19:27:15 <shachaf> Not monads-tf?
19:27:20 <mauke> sweet
19:27:41 <edwardk> mauke: i never use the ones between reflectNum and reflect so i never noticed reflectIntegrals was missing
19:27:43 * roconnor download monadLib
19:27:49 <edwardk> the only use was in the package
19:28:09 <edwardk> roconnor: its kinda fallen out of favor since mtl/transformers were fixed
19:28:17 <edwardk> i haven't seen monadLib in a while
19:28:22 * hackagebot reflection 0.4.1 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.4.1 (EdwardKmett)
19:28:29 <roconnor> edwardk: mtl/transformers still has broken state/cont instances
19:28:50 <edwardk> broken in what way?
19:28:57 <edwardk> the preservation of state?
19:29:16 <edwardk> there is an argument made in the transformers code that the other way doesn't form a monad transformer
19:29:19 <roconnor> in whatever way that the modular monad paper says it is.
19:29:25 <edwardk> hah
19:29:34 <edwardk> i need more to go on than that ;)
19:29:48 <monochrom> I have used haskell 98 and call-by-name lambda calculus to verify that "let x:y:z = ():⊥ in x" is ⊥. interesting
19:29:49 <roconnor> really?
19:30:36 <roconnor> edwardk: www.fceia.unr.edu.ar/~mauro/pubs/mmt/mmt.pdf
19:30:58 <monochrom> do you happen to know why augustss chose it?
19:31:53 <ski> preflex: xseen augustss
19:31:53 <preflex>  augustss was last seen on freenode/#haskell 3 days, 7 hours, 36 minutes and 32 seconds ago, saying: Does anyone remember where to find an STM implementation that is just in terms of cuncurrent haskell?
19:32:17 <edwardk> roconnor: we've fixed the callCC definition since that paper was published i'm guessing
19:32:29 <edwardk> because the liftCallCC that is used by StateT rolls back state
19:32:42 <monochrom> but I suppose it is more uniform. one ~ buys you one chance, no more no less
19:32:50 <edwardk> and there is an explicit liftCallCC' that doesn't.
19:32:56 <edwardk> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Control-Monad-Trans-State-Lazy.html
19:33:19 <edwardk> roconnor: so you are rebelling against mtl for no reason
19:33:34 <ski> i suppose `~' and `!' could have changed between two defaults ..
19:33:37 <edwardk> any other snipes you want me to catch? =)
19:33:52 <roconnor> edwardk: ya get rid of the listT non-monad transformer
19:34:07 <edwardk> roconnor: that i'll grant you is annoying to have present
19:34:10 <roconnor> http://trac.haskell.org/haskell-platform/wiki/Proposals/transformers
19:34:25 <roconnor> suggests that ``The MonadCont instance for StateT is not compatible with the monad transformer. The transformers package provides the correct lifting (in which callcc causes the state to rollback on entering the saved continuation), but also provides the MTL lifting for compatibility, and this is used by monads-fd. It could be switched to the correct lifting later.
19:34:35 <roconnor> oh
19:34:36 <roconnor> wait
19:34:43 <roconnor> that is good
19:35:05 <roconnor> :)
19:35:12 <edwardk> so use transformers
19:35:27 <roconnor> and the Error constraint is gone too?
19:35:32 <edwardk> yes
19:35:34 <edwardk> long time ago
19:35:35 <Axman6> does anyone have a link to a good explanation of the Cont monad?
19:35:37 <roconnor> :O
19:35:40 <edwardk> so Either is free of it
19:35:57 <edwardk> and the instance is in base not transformers. you just need Control.Monad.Instances
19:38:46 <roconnor> ;(
19:38:55 <roconnor> I've been angry at the mtl for so long
19:39:01 <edwardk> hah
19:39:13 <edwardk> i was once upon a time
19:39:17 <edwardk> we've since made up
19:40:44 <ezyang> who was famous for naming his type T in Hackage libraries?
19:40:45 <mauke> more than meets the eye
19:40:53 <ezyang> I can't quite remember...
19:41:00 <mauke> Henning T something
19:41:05 <aavogt> @hackage data-accessor
19:41:06 <lambdabot> http://hackage.haskell.org/package/data-accessor
19:41:09 <ezyang> Thielmann, thanks!
19:41:14 <edwardk> henning thieleman
19:41:25 <mauke> you're both wrong
19:41:29 <danharaj> That's a dick move.
19:41:31 <mauke> but nice try
19:41:38 <ezyang> erm Thielemann
19:42:18 <aavogt> maybe he has a name that starts with C too
19:43:06 <mauke> I shall refer to him as Henning.T from now on
19:43:14 <edwardk> =)
19:43:48 <edwardk> Well, you know his type after all. (it's T!)
19:48:24 <roconnor> how do I cabal remove monads-fd?
19:48:35 <shachaf> You can't uninstall a package with cabal.
19:48:42 <shachaf> You can ghc-pkg unregister it, but the files will still be there.
19:48:43 <edwardk> ghc-pkg unregister
19:48:58 <edwardk> will do what you mean at least
19:54:06 <ski> hm, when it says "It does not satisfy the laws of a monad transformer.", which laws is that referring to ?
19:57:04 <aavogt> it should at least include that a transformed monad still be a monad
19:57:43 <ski> (i'm looking at  liftCallCC'  at <http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-State-Lazy.html>)
19:58:48 <ski> yeah, but i don't see how defining  liftCallCC'  or even `callCC' in an instance could possibly cause monad transformer laws to fail ..
20:00:07 <ski> maybe it's some interaction between `callCC' laws and `lift' laws that is referred to -- i dunno
20:01:11 <roconnor> bah, circular module dependencies
20:01:18 <roconnor> lame
20:01:26 <applicative> ski, here are the laws http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-Class.html
20:01:29 <roconnor> Haskell 98 says it is should be fine
20:01:36 <applicative> yes, he means it's not a valid lift
20:02:02 * ddarius needs to give pre-searing a try.
20:02:20 <ski> applicative : yeah i found them. means `callCC' is not a valid lift ??
20:02:21 <roconnor> why do we use monad trasformers rather than monad products?
20:02:43 <ski> roconnor : istr some paper suggesting monad coproducts ..
20:02:53 <shachaf> ddarius: "pre-searing"?
20:02:58 <roconnor> monads don't have coproducts in general AFAIK
20:03:06 <ski> *nod*
20:03:29 <dolio> ddarius: Didn't know you play Guild Wars.
20:03:33 <applicative> ski, now I'm baffled by the signature
20:03:46 <ski> but `ReaderT r',`StateT s',`WriterT w' all commutes
20:03:59 <ski> applicative : hm .. signature of what ?
20:04:09 * ski tries to recall laws for `callCC'
20:05:02 <ddarius> shachaf: Searing my steak before I "boil" it.
20:05:09 <ddarius> (And likely again after.)
20:05:37 <dolio> You haven't been doing that?
20:07:26 <ddarius> dolio: I've just been blanching them.
20:07:31 <dolio> How was it without the searing? I would have thought that would be pretty recommended for flavor.
20:07:33 <ddarius> (And searing after.)
20:07:38 <dolio> Oh.
20:07:54 <dolio> Okay, that sounds less crazy.
20:08:06 * applicative gives up, crushed by continuations again
20:08:36 <ddarius> edwardk: Chris currently has my books, by the way.
20:09:41 <edwardk> books?
20:10:38 <ski> applicative : `liftCallCC :: (forall a b. ((a -> m b) -> m a) -> m a) -> ((a -> StateT s m b) -> StateT s m a) -> StateT s m a' might have been a more abstract type signature there
20:11:25 <ProofWizard> BEHOLD
20:11:36 * ProofWizard bewitches ProofGeneral 
20:11:53 <ProofGeneral> Gah!
20:12:11 * ProofWizard bows
20:12:49 <ski> ProofWizard : oughtn't you have been a witch, for that ?
20:13:20 * ProofWizard bewizards ski
20:13:48 <ddarius> edwardk: The Modernist Cuisine ones.
20:13:56 <edwardk> ah
20:14:39 <Axman6> http://seehere.blogspot.com/2009/02/installation-wizard.html
20:15:09 * ski unlocks the warlock, fog starts to appears around ProofWizard
20:15:29 <Axman6> the fog of war?
20:15:43 <ski> presumably, yes
20:15:49 <Axman6> warlocks stop war right?
20:16:06 <ski> only if they're locked !?
20:16:24 <ddarius> They also lead to deadlock.
20:16:31 <Axman6> i've discovered the answer to world peace!
20:17:47 * ski considers word peas
20:20:48 <ski> bah, where is <http://www.cse.ogi.edu/~magnus/mdo-callcc-slides.pdf> and <http://www.cse.ogi.edu/~magnus/mdo-callcc.pdf> when i need them ?
20:23:01 <gwern> ski: you tried internet archive of course
20:26:26 <ski> gwern : yep. have only got "Please try again later." yet
20:28:33 <ski> a-HA !!
20:29:24 <ski> some creative cut-and-paste with existing links suggests <http://www.carlssonia.org/ogi/mdo-callcc-slides.pdf> and <http://www.carlssonia.org/ogi/mdo-callcc.pdf> might work -- and they do !
20:36:09 <applicative> hah, ski, i just discovered the same, http://www.carlssonia.org/ogi/mdo-callcc-slides.pdf
20:41:38 <Axman6> heh, the latest xkcd mentions Xmonad
20:41:44 <Axman6> (in the hover text)
20:42:06 <edwardk> hah!
20:42:25 <copumpkin> @kmc
20:42:26 <lambdabot> Maybe you meant: ghc rc src
20:45:33 <scooty-puff> is there a way to have both indexed monad do-notation and regular monad do-nation both in scope at the same time?
20:45:46 <copumpkin> nope
20:46:19 <scooty-puff> that sucks..
20:47:16 <edwardk> clearly you should use scala where at least that isn't a problem ;)
20:48:13 <scooty-puff> yeah, everything is in IO, no escaping, but not way to be not in IO
20:48:21 <scooty-puff> *no way..
20:48:40 <Axman6> because everyone needs printf debugging
20:52:03 <cmccann> scooty-puff, just define (>>=) etc. in local scope
20:52:07 <cmccann> like a where clause or something
20:52:22 <cmccann> rebindable syntax is fine with that
20:52:31 <cmccann> people trying to read your code may not be
20:53:27 <applicative> scooty-puff, a preprocessor is just a future language extension, http://hackage.haskell.org/package/ixdopp
20:53:32 <scooty-puff> thanks - thats probably acceptable for how / where i'll be usingit
20:53:46 <gwern> I wonder if randall uses xmonad
20:54:02 <gwern> be nifty to have famous users to list in the wikipedia article
20:54:17 <cmccann> rebindable syntax lets you do all kinds of horrible, terrible things that are also potentially hilarious
20:56:18 <scooty-puff> applicative: thank you - that looks like it will as well
21:05:57 <cmccann> edwardk, you really should pick a more consistent level of generality for your abstract nonsense, the recursion-schemes and categories packages really don't seem to mesh very well
21:06:46 <edwardk> categories is way out in lala land
21:06:53 <edwardk> it was the stuff i had in category-extras
21:07:06 <edwardk> i wanted to keep it around somewhere
21:07:34 <cmccann> haha
21:07:40 <edwardk> the level i usually pick is something around 'can be expressed in haskell without too much pain' categories is on the other side of that line
21:07:54 <cmccann> yeah, I can imagine
21:08:05 <edwardk> not because there is too much there, but because it uses excessive flexibility but then doesn't do anything with it
21:08:23 * hackagebot trifecta 0.1 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.1 (EdwardKmett)
21:08:35 <edwardk> does someone feel up to helping me track down a strictness bug?
21:09:01 <cmccann> I only noticed it because I was playing with the recursion schemes stuff and thought I remembered something in categories that would have been useful but the disconnect in generality made it not worth the hassle :[
21:09:18 <edwardk> i'm 90% certain it is a bug due to interning while i'm interning
21:09:25 <Jafet> Is the bug strictness or lack of strictness?
21:10:00 <edwardk> lack thereof. it needs to be more strict to avoid trying to unsafePerformIO to modify one mvar while another is being modified
21:10:15 <edwardk> using the trifecta package i just uploaded
21:11:27 <edwardk> Prelude Data.Monoid Text.Trifecta.Cursor Text.Trifecta.It Text.Trifecta.Supply Text.Parsec.Prim> supply EOF $ supply "ti" $ supply "lalalalalalalala" $ uncons (mempty :: Cursor) — spins forever
21:12:22 <ddarius> Built on Parsec?
21:12:28 <edwardk> it is using a form of iteratee that uses my intern package to build fingertrees of buffers and canonicalize the choice of those if fed the same content
21:12:39 <edwardk> ddarius: yeah that is parsec's uncons
21:13:28 <edwardk> ddarius: basically its my old parsec-on-an-iteratee hack where i modified an iteratee to work with a run of buffers, except tweaked to intern the set of buffers used
21:13:56 <edwardk> and i'm modifying it to do some additional slicing and tracking of pretty printing information during parsing time
21:14:05 <edwardk> https://github.com/ekmett/trifecta/tree/master/Text/Trifecta
21:15:06 <edwardk> the irony is it is strict throughout except in the fingertrees themselves, which is where i'm getting bitten ;)
21:15:48 <edwardk> i have a known limitation to the intern library, which is that if you define a hash consable data type that has to hash cons while it is hash consing, it'll hang
21:16:14 <edwardk> so you need to deep seq whatever you're going to feed in to an intern method as a base representation
21:18:23 * hackagebot UtilityTM 0.0.3 - Utility functions that are missing from the standard library  http://hackage.haskell.org/package/UtilityTM-0.0.3 (TonyMorris)
21:21:59 <Jafet> Could you debug it by replacing the MVar operation with a trace? putMVar x --> ("[" `trace` x) `trace` "]"
21:22:30 <edwardk> jafet the problem is th mvar is buried in another library and is used polymorphically in different types
21:22:33 <edwardk> =/
21:24:28 <Jafet> Or try to add some debug code to intern to check that case
21:24:48 <Jafet> That sounds like it involves some sort of global lock though
21:25:04 <edwardk> guess i can try to add some kind of 'modifyAdvice' to the Interned class
21:26:16 <Jafet> Heh, tryIntern
21:26:46 <edwardk> too politically incorrect ;)
21:29:30 <edwardk> hacked in a modifyAdvice i can use to see what is going on
21:29:33 <edwardk> now to use it
21:33:24 * hackagebot intern 0.5.1 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.5.1 (EdwardKmett)
21:36:52 <edwardk> entering rope exiting rope entering rope entering rope — so apparently it is the rope memoizer
21:41:49 <edwardk> woot
21:43:23 * hackagebot intern 0.5.1.1 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.5.1.1 (EdwardKmett)
21:48:34 <kniu> in MLF and HML
21:49:30 <kniu> are type schemes of the form (forall a >= _|_. ...) always equivalent to the system f type (forall a. ...)?
21:49:48 <kniu> that is, am I allowed to use one in the place of the other at all times?
21:58:23 * hackagebot mongrel2-handler 0.2.1 - Mongrel2 Handler Library  http://hackage.haskell.org/package/mongrel2-handler-0.2.1 (BardurArantsson)
22:18:17 <frerich_> I think http://joyful.com/darcsden/simon/rss2irc/browse/rss2irc.hs#L-660 is very interesting for a Haskell beginner like me. It solves a known problem (bridging some XML feeds and IRC), it's very nicely commented, it's written by known people (so copying their style is probably not a bad idea) and it uses all sorts of useful packages.
22:18:24 <frerich_> I wish I found more like that.
23:08:24 * hackagebot trifecta 0.2 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.2 (EdwardKmett)
23:18:53 <harlekin> @pl (\_ a -> f a)
23:18:53 <lambdabot> const f
23:21:21 <looopy> @bots
23:21:21 <lambdabot> :)
23:21:43 <mustelo> edwardk, anywhere I can read about trifecta?
23:22:08 <edwardk> mustelo: its more of a work in progress at the moment
23:22:24 <edwardk> but the bulk of it is based on my parsing trifecta talk from a couple years back
23:22:26 <mustelo> translation "the source"
23:22:38 <edwardk> http://comonad.com/reader/wp-content/uploads/2009/08/A-Parsing-Trifecta.pdf
23:22:42 <mustelo> cool, thanks
23:22:44 <edwardk> that describes the core slicing machinery
23:23:14 <edwardk> there is some extra stuff going in there as part of me trying to figure out how to open source bits of my diagnostics code, etc.
23:23:35 <edwardk> and it'll go through a few iterations before it stabilizes
23:23:41 * mustelo swears lurking and listening to edwardk's hackage updates could be a full time job
23:23:53 <edwardk> right now there is enough there that you can run a parsec parser on top of it
23:24:08 <edwardk> and you can slice up the input to get source bytestrings out.
23:24:29 <edwardk> but once the diagnostics go in you'll be able to pretty print clang-style diagnostics pointing to actual source
23:25:02 <mustelo> that sounds awesome
23:25:13 <edwardk> (which is one reason why i put wl-pprint-terminfo on hackage, so i can print those in color) =)
23:26:05 <edwardk> as for the source there isn;t too much there yet so you can pretty much get your head around the entire thing as it stands
23:26:17 <mustelo> great, thanks again
23:26:34 <edwardk> some funny uses of fingertrees, etc. but those are covered by the slides for the most part. the least documented bits are the use of the intern library
23:27:09 <edwardk> but that just makes it so you can hash cons structures. i use it to get cheap bytestring comparisons and to memoize expensive functions by including their answers in the interned representation
23:33:23 * hackagebot sbv 0.9.21 - Symbolic bit vectors: Bit-precise verification and automatic C-code generation.  http://hackage.haskell.org/package/sbv-0.9.21 (LeventErkok)
23:33:59 <LimitSupremum> newbie here, how does one make variadic functions in Haskell?
23:35:02 <edwardk> in general, you don't. there are some dirty tricks to accomplish it, but i wouldn't recommend it 'as a newbie'. in general we replace them with folds over lists and the like
23:35:42 <LimitSupremum> and now I'm curious. Bearing in mind your caveat, what are teh dirty tricks to accomplish this feat?
23:36:01 <edwardk> consider the lisp variadic (+), which way does it sum its arguments? left to right? right to left? some arbitrary tree ordering?
23:36:40 <Jafet> > let s = printf "Hello! %s" s in s
23:36:41 <lambdabot>   Ambiguous type variable `a' in the constraints:
23:36:41 <lambdabot>    `Text.Printf.PrintfArg a...
23:36:45 <Jafet> > let s = printf "Hello! %s" s in s :: String
23:36:49 <lambdabot>   mueval-core: Time limit exceeded
23:36:54 <Jafet> Sucker
23:36:57 <edwardk> in haskell we'd usually use foldr (+) 0 or foldl (+) 0  — and if we didn't want to deal with the extra +0 on either side, we'd turn to foldr1 (+) or foldl1 (+)
23:37:50 <edwardk> now, what you _can_ do is often construct a typeclass for the result type of your function such that it doesn't overlap with the function type, and make two overloads that conspire to give you a variadic function.
23:38:39 <edwardk> i do this with the variadic gradient function in my ad library, and lennart used this trick to make a variadic printf: http://stackoverflow.com/questions/3467279/how-to-create-a-polyvariadic-haskell-function
23:39:29 <edwardk> in exchange for these ease of talking about variadicity, we get to freely curry all our arguments, can over and under apply them, etc.
23:40:09 <LimitSupremum> hmm how does currying work with variadic stuff
23:40:25 <LimitSupremum> how would you know when you're finished?
23:40:30 <edwardk> thats the problem =P
23:40:34 <Jafet> Using typeclass polymorphism
23:41:02 <LimitSupremum> well in lambda calculus everything's a function ... I guess you just use grouping to deal with it
23:41:04 <Jafet> The idea is that although the function can be applied to a varying number of arguments, each use of the function is with a fixed number
23:41:09 <LimitSupremum> but that seems a little annoying
23:41:18 <edwardk> in haskell what you need to do is make it so the result can't unify with (a -> b) of some sort, then use another instance
23:42:01 <Jafet> Haskell uses System F (?) as a model, so many constructions in the simple lambda calculus do not apply.
23:42:42 <edwardk> also, haskell isn't a lambda calculus a la curry. it is a la church, the types affect the meaning of your program, in our case via type classes.
23:43:26 <edwardk> afk a bit
23:43:38 <LimitSupremum> lambda calc à la curry versus à la church ... is that typed versus untyped ... or something completely different?
23:53:12 <andares> edwardk: wait, but isn't it named Haskell after Haskell Curry, and employ currying?
