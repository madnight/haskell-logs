00:02:04 <ddarius> conal: I guess a question that would sum up his perspective is: Why are the "macro expansions" in the language definition acceptable, but not user defined macro expansions?
00:03:39 <conal> ddarius: how do you suppose this idea of "acceptable" would arise in his head?
00:04:27 <conal> ddarius: i get a feeling he's reacting defensively, which maybe triggers subjectivity in him.
00:04:36 <ddarius> conal: I agree.
00:04:57 <kfish> hi conal :)
00:05:10 <conal> kfish: hi! :)
00:05:59 <conal> ddarius: ah. thx. i guess some people want to argue and so they cook up something that isn't there.
00:06:26 <conal> perhaps he read some criticism in other answers and imagined it in mine.
00:06:49 <ddarius> Well, there also seems to be an aspect of him just thinking you're thick.
00:07:22 <conal> ddarius: yeah. i get that sometimes.
00:07:50 <ddarius> conal: In this case, it's not just a "stylistic" thing.  He thinks you are wrong and that you don't understand macros.
00:08:40 <mornfall> But, but. I don't get the overlap. :(
00:09:09 <conal> i'm also puzzled over this C.A.McCann fellow's second remark in http://stackoverflow.com/questions/2488646/why-are-side-effects-modeled-as-monads-in-haskell/7072217#7072217 , where he goes on about functor nesting and then concludes that Monad in general has an intrinsically imperative nature .
00:09:12 <mornfall> Oh, I do.
00:09:27 <mornfall> GHC thinks that m might actually be (t n). Which it might. Gah.
00:09:41 <conal> kfish: how's the weather in Tokyo?
00:10:23 <shachaf> conal: He's in this channel regularly.
00:10:27 <shachaf> (Though not now, it seems.)
00:10:47 <conal> shachaf: oh. what's his handle?
00:10:52 <shachaf> cmccann :-)
00:10:56 <mornfall> So how do I express the idea of a smaller monad stack? :-)
00:10:56 <shachaf> Used to be syntaxglitch, I think.
00:10:59 <shachaf> PreciousMetals: seen cmccann
00:11:03 <ddarius> shachaf: Yes.
00:11:04 <shachaf> Er.
00:11:07 <shachaf> preflex: seen cmccann
00:11:08 <preflex>  cmccann was last seen on #haskell 1 hour, 38 minutes and 9 seconds ago, saying: @vixen what do you think about /.../ for emphasis?
00:11:18 <conal> shachaf: thx.
00:11:50 <hpaste> sp3ctum pasted “parse error in local function” at http://hpaste.org/50390
00:12:06 <conal> i wonder what he could mean by "Specific instances may not have intrinsically imperative structure, but Monad in general really does." Does in general but not in particular??
00:12:12 <sp3ctum> i'm mostly hacking around with haskell, since i'm just learning
00:12:38 <sp3ctum> i was wondering if someone could help me with that code in the hpaste ^ (http://hpaste.org/50390 )
00:12:53 <shachaf> "Specific instances may not have intrinsically imperative structure, but Monad in general really does." does seem a bit odd.
00:13:14 <sp3ctum> the error message isn't specific and i'm stuck
00:14:05 <shachaf> conal: I think the issue is mainly that "imperative" isn't very well defined.
00:15:20 <shachaf> Ugh, the "Chosen Answer" to that question is the World -> (a,World) thing?
00:15:27 <ddarius> conal: I think to clarify what you are saying to Sam, you want to say, more concretely, that since macros are a function of the syntax and not the semantics you cannot apply semantics preserving syntax transformations to arguments of a macro, while you can for a lazy function.  Of course, these variation in behavior based on syntax are exactly what you are often trying to get from a macro.  Quotation is the original re
00:15:27 <ddarius> ferentially opaque context.
00:15:30 <conal> shachaf: ah. some unexpected notion of "imperative" might help explain what his earlier remarks in that paragraph have to do with the question.
00:16:29 <shachaf> conal: I suspect "imperative" might simply mean "a strict notion of causality going from one to the next" in that context. :-)
00:16:35 * shachaf doesn't know, though.
00:16:55 <shachaf> Anyway, the World -> (a,World) explanation of IO should just be illegal.
00:17:34 <conal> shachaf: it's a very tricky one, because it's so easy to read that def in the source code and believe it's true.
00:17:42 <kfish> conal: i actually moved to singapore last week ... will be back in tokyo for icfp and your visit tho :)
00:17:49 <Dirrrk> sp3ctum: Try (b:bs) instead of b:bs
00:18:25 <shachaf> Also the "IO ==> Monad" thing should be abolished. Introductions to IO in Haskell should show several ways to do IO that don't involve Monad or >>= before they get to those subjects.
00:18:26 <conal> kfish: oh, wow. singapore. i hadn't heard.
00:18:46 <mornfall> Hm. I need a type inequality constraint.
00:18:49 <ddarius> conal: The question that the original poster asked in that thread (monads) seems completely reasonable.  I would say that monads entered Haskell via their use in denotational semantics where modelling effects was exactly what they were accomplishing.  Admittedly, the monad interface does not do that.  It seems that many responders have leapt to IO for no apparent reason, though that is probably what the OP was intendin
00:18:49 <ddarius> g.
00:19:12 <conal> shachaf: i almost always believe source code. now i wonder where else it lies.
00:19:40 <sp3ctum> Dirrrk, it seems to have solved this issue. thanks!
00:19:55 <Dirrrk> sp3ctum: you're welcome
00:20:22 <ddarius> conal: If you stopped before you got to the non-existent definition of RealWorld, then ...
00:20:53 <mornfall> shachaf: How do you do IO without IO? :)
00:20:53 <ddarius> This is a more generic "you."
00:21:02 <shachaf> mornfall: You mean without the IO type in Haskell?
00:21:07 <mornfall> shachaf: Yea.
00:21:19 <shachaf> mornfall: There are lots of ways. For example, main :: String, which is a not-very-interesting output-only form of doing IO.
00:21:44 <shachaf> Or main :: String -> String, a la interact.
00:21:53 <mornfall> shachaf: Sure, but you can't *do* that. You can only talk about it. Which kind of defeats the purpose.
00:22:03 <conal> ddarius: yeah, i see that historical haskell connection. and maybe OP-er didn't mean "modeled" in the way i took it.
00:22:04 <shachaf> mornfall: What do you mean, you can't do that?
00:22:04 <ddarius> I mean if I saw newtype IO = IO (RealWorld -> (a, RealWorld)), I would want to know what RealWorld actually was doubly so.  If one digs, you quickly find out that it is magic.
00:22:37 <mornfall> shachaf: When you are teaching Haskell, you can't tell people to declare main :: String.
00:22:55 <shachaf> mornfall: You can tell people to declare realMain :: String.
00:23:07 <conal> ddarius: could the magic be in RealWorld?
00:24:22 <mornfall> shachaf: Well, at least it would make them understand why they really do want monads.
00:24:55 <aki> morning
00:25:04 <mornfall> shachaf: (On the other hand, main :: String is no different from ghci REPL...)
00:25:05 <kmc> hi aki
00:25:07 <shachaf> mornfall: I don't think anything would make someone understand "why they really do want monad" other than seeing more than one instance of Monad and seeing that they're related.
00:25:40 <dobblego> make them write sequence over and over, works every time, laugh at them as they copy/paste code
00:25:56 <dobblego> if they still don't get the joke, move on to replicateM
00:25:57 <mornfall> shachaf: Well, if you introduce non-monadic IO and non-IO monads, I suppose people would "get" how to apply monads to get a less insane IO.
00:26:04 <ddarius> conal: The magic, in the case of GHC, is in the compiler itself and how it treats RealWorld and functions of RealWorld.  The magic as far as how this "semantics" explains things is also in RealWorld, so to speak, but in a way that utterly useless and still not quite adequate/compelling.
00:26:47 <mornfall> -a
00:27:30 <shachaf> mornfall: Probably.
00:27:41 <shachaf> "non-monadic" IO doesn't have to be insane, of course.
00:28:11 <conal> ddarius: magic in the compiler is my understanding also. about RealWorld, my puzzle is what it could *possibly* be that would allow interaction, concurrency, and nondetermism.
00:28:14 <mornfall> shachaf: Well, the interact-style stuff is *really* bad.
00:28:41 <shachaf> mornfall: Oh, well, sure, but you can do a CPSy thing or something like that that's very similar to how IO works in Haskell.
00:28:55 <kmc> the (World -> (a, World)) model of IO has almost nothing to do with GHC's implementation of IO, despite looking the same
00:29:04 <kmc> and neither is a good model for how to think about IO
00:29:07 <dobblego> @type \p x -> case x of Nothing -> Nothing; Just z -> if p z then x else Nothing
00:29:08 <lambdabot> forall a. (a -> Bool) -> Maybe a -> Maybe a
00:29:08 <aki> hi kmc
00:29:14 <dobblego> is that lying around where? filter?
00:29:16 <conal> shachaf: we had the current IO model before haskell could define Monad (i.e., before type ctor classes).
00:29:21 <mornfall> shachaf: Guess so. But at that point, you are just desugaring the monad, more or less.
00:29:32 <kmc> why don't people just say "values of type (IO t) are imperative programs"
00:29:34 <conal> shachaf: same model, slightly different interface.
00:29:35 <kmc> everyone knows how those work
00:29:42 <shachaf> kmc: People do say that. :-)
00:29:46 <ddarius> conal: Basically, by taking the entire state of the universe and transforming it and if you push this hard enough and self-referential enough you can argue (in, by that point, completely informal ways) that it -could- still work.
00:29:52 <kmc> not enough shachaf
00:30:03 <shachaf> kmc: That's one of the most common explanations, isn't it?
00:30:13 <shachaf> "Monads-as-computations"
00:30:19 <mornfall> But it's not entirely true. :P
00:30:20 <shachaf> s/Monads/IO/
00:30:26 <shachaf> mornfall: Why not?
00:30:33 <conal> ddarius: even nondetermism?
00:31:09 <yitz> conal: not deleting terms?
00:31:34 * shachaf thinks data IO = Exit | GetLine (String -> IO) | PutStrLn String IO | ... is a reasonable model for explaining "how IO might work" initially.
00:31:42 * frerich gets disappointed if somebody comes up with a nice explanation of monads which he understands, and then somebody comes along saying "Uhm yeah, nice, but it's not *entirely" true."
00:31:56 <mornfall> shachaf: If I were to imagine do-notated IO as an imperative program, I would definitely expect binding to work differently.
00:32:04 <ddarius> conal: At that point it becomes a philosophical question of whether you believe in non-determinism in reality.  If you don't, then there is no non-determinism.  The non-determinism you note is just your lack of information.  Information which the functions have since the have the state of the entire universe.
00:32:12 <conal> shachaf: that def is more a syntax than a semantics. i.e., just code, not meaning/model.
00:32:14 <shachaf> mornfall: kmc wasn't talking about do-notation, I think, just about values of type IO a.
00:32:15 <yitz> shachaf: a list of those
00:32:36 <mornfall> shachaf: True. (But it's too easy to conflate when you are just learning Haskell.)
00:32:43 <shachaf> conal: Right. Just as an approximation of the existing IO in Haskell. :-)
00:32:46 <ddarius> If you believe in non-determinism, then you may fall back to a deterministic multiverse, in which case RealWorld is the multiverse, or you may have to do some more 'splaining.
00:33:09 * shachaf is all for a meaning/model for IO, of course.
00:33:12 <conal> shachaf: an extremely coarse approximation
00:34:03 <ddarius> conal: Indeed that model is, but that is actually essentially what -is- happening.  You are feeding the OS/RTS meaningless tokens that it interprets and then gives you results.  The semantics, at that point, are in the OS/RTS.  You could assign some directly to these tokens as well.
00:34:15 <conal> ddarius: yeah. maybe if RealWorld were a set of real/definite real worlds.
00:34:16 <mornfall> shachaf: But I certainly imagine imperative programs using fixed code and mutable state, not with unmutable state and on-the-fly computed code.
00:34:54 <mornfall> Even though they are kind-of equivalent.
00:35:04 <shachaf> yitz: (No, not a list.)
00:35:08 <conal> ddarius: are you thinking of treading all of the thread scheduler's influences in through the initial RealWorld?
00:35:27 <conal> ddarius: luqui suggested that idea to me when he visited recently.
00:35:59 <yitz> ddarius: why is the philosophy important? either way, you don't know how they are ordered, so you need to model that.
00:36:02 <ddarius> conal: Holders of that view are eventually pushed to including the entire universe, so certainly the scheduler is included, as is user input, as is your cat unplugging the computer.
00:36:10 <conal> ddarius: (to eliminate nondeterministic thread scheduling).
00:36:17 <yitz> shachaf: if not a list, that is going to be a very large ADT
00:36:35 <ddarius> yitz: You don't know, but the World -> World function knows.  It knows all.
00:36:46 <nda> hi
00:36:59 <yitz> ddarius: oh in that model you mean
00:37:00 <nda> @pl \i f -> f . (g i)
00:37:00 <lambdabot> flip (.) . g
00:37:07 <mornfall> ddarius: But is the function part of the World? :D
00:37:10 <conal> ddarius: perhaps that POV could turn out to be self-consistent. i haven't explored it far enough to conclude.
00:37:11 <ddarius> mornfall: Yes.
00:37:19 <mornfall> ddarius: And is it still a function, then?
00:37:38 <ddarius> conal: That is my view on it.  You may be able to make it self-consistent, but it is extremely uncompelling and ridiculous by that point.
00:37:52 <ddarius> mornfall: That's where questions of determinism come in.
00:38:02 <yitz> mornfall: in the same sense that a lambda abstraction in the lambda calculus is a function
00:38:56 <ddarius> mornfall: It being a function means the world is ultimately deterministic or a multiverse is.  At least, that's what I think.  As I said, this is far beyond being amenable to formal reasoning by this point.
00:39:36 * waschbaer
00:39:38 <ddarius> conal: At any rate, even if this model is self-consistent, it would still be completely non-predictive.
00:39:42 <conal> ddarius: thx for helping me look down that path. it's far from compelling to me too.
00:40:09 <conal> ddarius: i suspect so also, though i could be mistaken.
00:41:57 <conal> oops. got pretty late here. ddarius & shachaf: thanks for the help with perspective-grok.
00:42:05 * conal heads to bed
00:42:40 * shachaf wasn't aware he was perspective-grok-helping.
00:43:09 <benmachine> my view on State -> (a,State) is that it had some value when I was learning
00:43:32 <benmachine> before I could see how immutability could possibly be used to write programs at all
00:44:00 <benmachine> it's a concept of how haskell can model state mutation in general, I suppose
00:44:11 <shachaf> benmachine: s -> (s,a) is a perfectly valid and reasonable thing.
00:44:27 <conal> agreed. it just doesn't correspond to IO .
00:44:38 <ddarius> benmachine: It's using the World passing model for explaining IO that's the problem.  State is perfectly reasonable.
00:44:38 <benmachine> conal: I view it in the same way I view, like
00:44:51 <conal> (it's a model for purely sequential computation.)
00:44:55 <benmachine> when you tell people in chemistry that electrons are little balls that orbit around atoms
00:45:09 <benmachine> it's false and it's demonstrably false, but it helps people to get closer to the truth
00:46:06 <benmachine> I suppose I see it as an informal metaphor, rather than a formal model
00:46:15 <ddarius> benmachine: The only problem is that there are perfectly reasonable alternatives that are less false and at least comparably easy to understand.
00:47:09 <conal> benmachine: i like people learning that model, just not believing it.
00:47:18 <benmachine> conal: ok, that seems fair
00:47:27 <benmachine> ddarius: what did you have in mind?
00:47:57 <conal> rather than: "here's a way to think about IO. It's not true and can't explain some important things, but ..."
00:48:29 <conal> on the other hand, why do we want people to get a functional/denotative view of IO at all, when we can't really deliver?
00:48:51 <shachaf> benmachine: If you just want to see "how mutability could work in Haskell", (->) s (s,a) is fine.
00:49:11 <conal> i.e., why do we want to suggest that there's a functional/denotative explanation of Haskell IO when there isn't?
00:49:28 <ddarius> benmachine: The term model approach that shachaf mentioned is one model I like.  It is very close to what is actually happening and is capable of dealing with concurrency.  Similarly the continuation based approaches are also good.
00:49:33 <conal> oh. maybe i'm asking the wrong question.
00:49:59 <conal> by focusing on IO rather than stateful computation.
00:50:07 <benmachine> I've got to run, work time, sorry
00:50:24 <conal> benmachine: me, too. take care.
00:50:26 <shachaf> ddarius: Continuation-based approaches?
00:50:36 <benmachine> I don't have a really concrete idea about what I'm saying here, I just remember that thinking of IO as a state monad was part of my learning process
00:50:49 <ddarius> The key difference between the continuation-/term-based approaches and state-based approach is essentially that the former are event-based and the latter is not.
00:54:30 <ddarius> shachaf: It's not too different, instead of having a PutStrLn constructor you have a putStrLn primitive that takes a continuation (and you use the Cont monad or equivalent CPS which handle execution order.)
00:55:35 <kmc> maybe teaching the bohr model first *isn't* helpful
00:55:46 <shachaf> The PutStrLn constructor *is* a primitive that takes a continuation. :-)
00:55:52 <ddarius> shachaf: Exactly.
00:55:56 <ddarius> They are very similar.
00:56:09 <kmc> if nobody has tried the alternative then how would we know?
00:56:49 <ddarius> kmc: We have tried alternatives.  We tried the stuff we used before the Bohr model was accepted.
00:57:01 <kmc> which are even more wrong, though
00:57:18 <ddarius> kmc: Which is my view on the World-passing explanation.
00:58:11 <ddarius> shachaf: The difference is mostly a matter of how the data type is represented and some software engineering aspects.
01:40:03 <erus`> i want a string -> Anything map
01:40:16 <erus`> like dynamic type
01:41:00 <erus`> how can i do something like that?
01:41:06 <kmc> Data.Dynamic
01:41:20 <erus`> how can i find the underlying type?
01:41:40 <mux> :t typeOf
01:41:41 <lambdabot> forall a. (Typeable a) => a -> TypeRep
01:41:47 <kmc> erus`, did you read the API docs for Data.Dynamic?
01:42:11 <shachaf> @docs Data.Dynamic
01:42:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
01:42:22 <kmc> nice, i didn't know about @docs
01:42:48 <kmc> erus`, if you want, you could tell us what problem you're actually trying to solve
01:42:51 <kmc> there might be a better way
01:42:58 <erus`> ok
01:43:14 <erus`> i want to model a game world
01:43:30 <erus`> so each object has named properties
01:43:56 <erus`> but i would like the AI to learn about these object properties dynamicaly
01:44:34 <erus`> so an AI would see an apple and deduce that it is a physical object and has color = "red" and size = 1m sq or whatever
01:45:05 <erus`> so its just a dynamic map of string -> Unknown
01:45:59 <kmc> don't you want a closed universe of types the AI has to think about?
01:46:21 <erus`> i need to model something like json
01:46:28 <kmc> you don't need dynamic types for that
01:46:39 <kmc> in fact there's already approximately 10,000 json libraries on hackage
01:47:02 <kmc> erus`, data Value = Length Int | Color (Float, Float, Float) | Name String | ...
01:47:14 <kmc> dynamic types are neither a necessary nor sufficient solution
01:47:17 <erus`> kmc: ah i should just limit the property types?
01:47:22 <kmc> i think so
01:47:28 <erus`> ok that makes sense
01:47:35 <shachaf> Dynamic is very different from what you want.
01:47:37 <sannysanoff> hello, gentlemen, could you please point me to the document which explains how to read STG with regard to allocations and optimization of tight loops
01:47:42 <kmc> do you want to make your AI think about properties of type Int -> IO (Int -> Mu Chan) ?
01:47:44 <flux> maybe there's a property library around that allows "open sum types"?
01:48:14 <flux> although, I'd say it's best avoid such trickery unless you really need it ;)
01:48:15 <shachaf> Mu Chan?
01:48:18 <kmc> erus`, even in a dynamically typed language, pattern-matching and declared sums are useful
01:48:44 <kmc> it's a regrettable fact that they're not widely implemented
01:48:56 <kmc> and so in dynamic languages you use the dynamic type system itself as a single global ad-hoc sum type
01:49:07 <kmc> and then this poisons the way people think generally
01:52:10 <erus`> every AI looks like a game tree when you take its clothes off
01:52:15 <cpa> is there a nice way to automagically derive endofunctors for a ground type? like data D = T1 String | T2 String String deriving Endofunctor
01:52:36 <kmc> cpa, where's this Endofunctor class from?
01:52:56 <cpa> kmc: that's what I'd like to write, not actual Haskell
01:53:03 <kmc> what would the class look like?
01:53:53 <cpa> well, that definitely involve some TH and it's not well defined for data D = T1 String | T2 Int, sure
01:54:04 <cpa> but often I'm not in this case
01:54:17 <kmc> so you want a function of type (String -> String) -> (D -> D) ?
01:54:20 <kmc> in this case
01:54:40 <cpa> yes
01:54:47 <kmc> yeah
01:55:00 <kmc> it's not really a functor then
01:55:13 <kmc> if you wrote an actual Endofunctor class it would need multiple parameters or associated types
01:55:21 <cpa> indeed
01:55:27 <kmc> cpa, i think the closest extant thing to what you want would be some of the first-class labels packages
01:55:32 <kmc> fclabels, lenses, data-accessor
01:55:38 <cpa> I'll check that
01:55:40 <cpa> thanks
01:55:49 <kmc> you can also implement generic traversals with SYB
01:56:05 <cpa> SYB?
01:56:34 <shachaf> @where syb
01:56:34 <lambdabot> http://www.cs.vu.nl/boilerplate
01:56:47 <kmc> 403 :/
01:56:52 <kmc> http://www.haskell.org/haskellwiki/Scrap_your_boilerplate
01:57:10 <shachaf> @where+ syb http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/
01:57:10 <lambdabot> It is forever etched in my memory.
01:57:13 <kmc> take a look at 'syb' package and the Data.Data module in 'base'
01:57:14 <shachaf> Hmm, maybe kmc's link is better.
01:57:23 <kmc> you might want to read the original papers to see how it all fits together
01:57:28 <kmc> :t mkT
01:57:28 <lambdabot> forall b a. (Typeable a, Typeable b) => (b -> b) -> a -> a
01:57:29 <shachaf> But the slides/paper at that link are good.
01:57:31 <kmc> :t everywhere
01:57:32 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
01:58:00 <kmc> cpa, you can say "apply this function of type String -> String to every String within this complex nested data type"
01:58:02 <ddarius> SYB is fugly.
01:58:28 <cpa> kmc: that's what I want!
01:58:29 <cpa> cool!
01:58:39 <kmc> ddarius is right, though
01:59:01 <cpa> I'll try for myself
01:59:12 <kmc> there's a lot of other work in generic programming in Haskell
01:59:30 <rostayob> uniplate?
01:59:33 <shachaf> kmc: SYB is kind of weird when dealing with that sort of thing.
01:59:45 <shachaf> > everywhere (mkT (++"a")) "foo"
01:59:47 <lambdabot>   "fooaaaa"
01:59:55 <kmc> and multiplate
01:59:56 <shachaf> Since it goes over the entire list.
01:59:57 <Ke> some day you could even have case where you could use constant expressions instead of patterns
02:00:03 <kmc> and multirec
02:00:25 <kmc> and new compiler features in GHC 7.2
02:00:45 <Ke> it's always bad when language is boilerplaty compared to C
02:00:46 <Ke> =oP
02:01:22 * ddarius doesn't know what Ke is going on about.
02:05:13 <Ke> ok C is only as bad =oP
02:05:58 <mux> let me guess, we got a new troll?
02:06:36 <Ke> http://users.tkk.fi/~jkarlson/files/screenshot.png just frustrated having to do this
02:07:11 <Ke> would be nice to skip at least the c ==
02:07:42 <mux> well you could
02:07:50 <frerich> Hm, it seems to me that Haskell's purity doesn't lend itself to frameworks (or generally, the "Hollywood" style of programming - don't call us, we call you), simply because writing a Haskell framework means putting a lot of restructions (and being able to predict) on the called functions.
02:07:52 <Ke> how?
02:08:13 <erus`> whats a generic name for the effect something has on you when you consume it?
02:08:50 <dankna> "food buff" =p
02:08:59 <shachaf> erus`: "nomitude"
02:09:01 <erus`> maybe i should have a generic effect type
02:09:09 <erus`> then have onEat or something
02:09:15 <dankna> so this is actually for a game?
02:09:17 <mux> > case 2 of 1 -> "foo"; 2 -> "bar"
02:09:17 <rostayob> digestion
02:09:17 <lambdabot>   "bar"
02:09:21 <dankna> then yes, buff/debuff is the standard terminology
02:09:21 <mux> > case 1 of 1 -> "foo"; 2 -> "bar"
02:09:22 <lambdabot>   "foo"
02:09:39 <mux> Ke: I have no idea why you're taking such a detour with case () of ... and pattern guards
02:09:42 <erus`> dankna: yeah a little game/demo
02:09:48 * dankna nods
02:10:09 <erus`> I have been trying to create a virtual economy for years
02:10:19 <Ke> mux: how could I avoid it
02:10:38 <mux> Ke: I just showed you, didn't I?
02:10:39 <erus`> i want agents running around being semi-intelligent
02:10:52 <shachaf> frerich: I'm not sure what you mean.
02:11:50 <ddarius> mux: "Pattern guards" means something specific, an extension, just say "guards."
02:11:52 <Ke> mux: case uses pattern matching so I can't use named constants
02:12:03 <ddarius> Ke: You could just use a data structure.
02:12:10 <mux> ddarius: right.
02:12:19 <Ke> ddarius: url?
02:12:39 <ddarius> What are you expecting a URL to?
02:13:05 <Ke> explain your intention more verbosely
02:13:13 <kmc> frerich, i don't follow
02:13:17 <shachaf> Perhaps Ke just wants a general-purpose URL.
02:13:22 <Ke> !
02:13:33 <mux> Ke: even then, you could build a list of (constant, action) and then evaluate the one matching your constant, it would still be nicer
02:13:38 <shachaf> Hmm, ddari.us isn't registered.
02:13:48 <Ke> did you mean making a constructor of all the constants?
02:13:50 <shachaf> You could be all Web2.0y.
02:13:53 <ddarius> fromJust $ flip lookup c [(clDeviceAddressBits, peekOneInfo DeviceInfoRetValCLuint x), ...]
02:14:01 <mux> like that
02:14:09 <kmc> fromJust :(
02:14:27 <ddarius> kmc: I wouldn't recommend using fromJust here, but I didn't feel like typing more.
02:14:36 <ddarius> kmc: But now you've gone and blown my typing budget.
02:14:41 <kmc> haha
02:15:11 <kmc> shachaf pointed out to me the other day that «let Just x = ...» is better than «fromJust x» because at least you get a filename / line number
02:15:16 <Ke> well fromJust is really the only thing you could do here
02:15:30 <mux> no it's not
02:15:35 <kmc> there's also fromMaybe (error "custom message")
02:15:40 <erus`> is there an easy way to export everything in a module?
02:15:48 <shachaf> kmc: Well, it's not an expression (unless you use in).
02:16:06 <Ke> otherwise you won't get header compatible error message
02:16:11 <ddarius> erus`: Everything is exported by default.
02:16:12 <kmc> erus`, leave off the export list
02:16:25 <kmc> see also http://www.haskell.org/haskellwiki/FAQ#How_can_I_export_another_module_and_everything_defined_in_this_module.3F
02:18:02 <ddarius> Not that using this export list approach really saves much typing... you're complaining about 3 characters per line.  In C you'd need at least six for the ";break;".
02:18:03 <shachaf> We have a FAQ?
02:19:27 <ddarius> Incidentally, you can also group the chunks of the lookup table so that you can map \ctr -> peekOneInfo ctr x over chunks with the same type and concatenate them so you don't have to repeat the peekOneInfo D...t x part.
02:20:16 <ddarius> @faq Can a FAQ be made for Haskell?
02:20:16 <lambdabot> The answer is: Yes! Haskell can do that.
02:22:02 <Ke> ddarius: how could I group ti for different keys
02:22:05 <shachaf> @faq Can Haskell be used to send a ℻?
02:22:05 <lambdabot> The answer is: Yes! Haskell can do that.
02:22:28 <Ke> ddarius: and the keys really are constants defined by C interface
02:24:13 <mux> you could also use CPP
02:24:17 <mux> and just have a regular case
02:27:16 <efie> when i try to compile this http://codepad.org/oSOLN5Zx i get "The last statement in a 'do' construct must be an expression: let number = read numberString todoTasks" at line 34. what can i do? why does ghci think this is the last expression?
02:28:18 <Ke> efie: do you have in in your let
02:28:39 <Ke> afaik let without in is just for ghci
02:28:40 <shachaf> Ke: You don't need in; it's a do.
02:28:45 <shachaf> Ke: Nope.
02:28:49 <Ke> ah
02:29:28 <shachaf> efie: Are you sure that's the file you're trying to compile?
02:30:01 <shachaf> Maybe you're dealing with somethign with different indentation or something like that?
02:31:27 <peteriserins> efie: have you tried splitting the let into three lets?
02:31:44 <peteriserins> efie: might help identify the problem
02:32:15 <efie> i just copied it from the codepad link i sent - although it still looks exactly the same it works now, maybe there was a problem with spaces and tabs .. .um, sorry!
02:32:17 <efie> thanks
02:32:26 <efie> :|
02:32:31 * shachaf suspects a problem with tabs.
02:32:41 <shachaf> Make sure your editor doesn't expand eight spaces into a tab or something silly like that.
02:33:10 <efie> ill check it
02:40:44 <ketil> For bytestring, is it better to use unfoldrN than pack to construct a BS when the length is known - or are there better alternatives?
02:42:20 <kmc> unfoldrN can be more efficient
02:46:04 * ddarius found his OS.
02:46:07 <ketil> hm...didn't help a lot for me, I'm afraid.
02:48:35 <rostayob> ddarius: what is it?
02:49:33 * ddarius is not exactly sure how that question is expected to be answered.
02:51:05 <sp3ctum> is fromJust a bad practice? also, why?
02:51:29 <Entroacceptor> yes
02:51:35 <mercury^> It requires effort on your part to guarantee that no exception is raised.
02:51:40 <mercury^> The compiler cannot help you.
02:51:54 <sp3ctum> what exception might be raised when using it?
02:52:12 <Entroacceptor> > fromJust Nothing
02:52:13 <lambdabot>   *Exception: Maybe.fromJust: Nothing
02:52:15 <mercury^> Failed pattern match essentially. I don't know if it has a special exception.
02:52:19 <mercury^> Yeah, that.
02:52:30 <sp3ctum> oh, ok. thanks
02:52:38 <sp3ctum> it was totally new to me
02:52:53 <kmc> so your program prints that message with no context, and dies
02:53:08 <kmc> if you say "let Just x = ... in ..." then you at least get the line number of that failed pattern match
02:53:27 <sp3ctum> i can see that would be bad :)
02:53:47 <Entroacceptor> and if you want to use fromJust, why use Maybe in the first place?
02:54:03 <shachaf> Entroacceptor: Perhaps you used a library function that used Maybe.
02:54:50 <Entroacceptor> then you probably still want to check for Nothing
02:55:42 <shachaf> Maybe you're doing M.lookup in a Map that you know will contain the key you want. Or, if it doesn't, your state is so inconsistent you might as well crash.
03:10:04 <ketil> kmc: after working with it a bit, I got an 85% speedup.  Anamorphisms FTW!
03:10:38 <kmc> cool!
03:10:43 <kmc> that's with unfoldN?
03:10:56 <shachaf> @faq Can Haskell express anthropomorphisms?
03:10:56 <lambdabot> The answer is: Yes! Haskell can do that.
03:11:25 <ketil> >fromMaybe (error "foo") (Just 6)
03:11:53 <kmc> > fromMaybe (error "foo") (Just 6)
03:11:54 <lambdabot>   6
03:11:58 <kmc> > fromMaybe (error "foo") Nothing
03:11:59 <lambdabot>   *Exception: foo
03:12:00 <ketil> Ah.
03:12:11 <ketil> Exactly.
03:12:39 * ketil makes mental note to remember the space after the greater-than.
03:12:45 <shachaf> @@ @show (@run fromMaybe (error "foo") (Just 6)) (@run fromMaybe (error "foo") Nothing)
03:12:46 <lambdabot>  "  6\n   *Exception: foo\n"
03:45:49 <ski> (ddarius : to be fair, `Int' and friends are also magic, like `RealWorld' (but to a lesser degree) -- the former also being abstract data types)
03:45:52 <ski> kmc : "and new compiler features in GHC 7.2" -- which features were you thinking of ?
03:47:08 <kmc> ski, http://haskell.org/ghc/docs/7.2.1/html/users_guide/generic-programming.html
03:47:59 * hvr is looking at Data.List.NonEmpty (from the semigroups pkg)
03:48:08 <hvr> wouldn't it be better to use a newtype?
03:48:27 <hvr> instead of using a
03:48:29 <hvr> data NonEmpty a = a :| [a]
03:48:33 <hvr> type?
03:49:04 <hvr> wrt performance/list fusion and all that
03:49:33 <Axman6> you can't use a newtype for that
03:49:41 <hvr> why not?
03:49:56 <hvr> I mean, a newtyped [a]
03:49:58 <kmc> not sure fusion sees through newtype anyway
03:50:10 <hvr> newtype NonEmpty a = NonEmpty a
03:50:14 <hvr> newtype NonEmpty a = NonEmpty [a]
03:50:14 <Axman6> because newtypes can only be of the form of newtype Name var = Constructor var', there can't be more than one element in the constructor
03:50:22 <kmc> hvr, you'd have to make it an abstract type, to be able to enforce non-emptyness
03:50:28 <kmc> so you lose pattern-matching
03:50:47 <hvr> kmc: yeah... but would that be a problem?
03:51:41 <hvr> kmc: I can always convert back to a list and do pattern matching then (isn't there a ghc extension for view patterns?)
03:58:34 <efie> "delete removes the first occurrence of x from its list argument" - is there a delete function which deletes y's element of a list wherares y is an index of my choice?
03:59:18 <efie> the yth*
03:59:28 <matin> hi
04:00:47 <matin> hi pleas answear me
04:03:32 <ivanm> matin: you haven't asked a question yet...
04:04:04 <geheimdienst> efie: you might use "take" on the list and "drop"
04:04:26 <matin> hello.where are u from my dear/
04:04:41 <ivanm> uhhhh...... what?
04:04:47 <ivanm> do you realise what this channel is?
04:05:09 <efie> geheimdienst: perfect! thanks
04:05:14 <geheimdienst> matin: this is a channel about the programming language haskell. please stick to that topic only
04:05:24 <ski> kmc : ty. ok, i had seen the previous incarnation of that, but hadn't noticed it had been updated/replaced
04:06:01 * mornfall suspects matin doesn't really have the concept of a "channel"
04:06:34 <matin> i didnt khow thanks
04:06:41 * companion_cube suspects matin does not have any concept
04:07:53 <ski> hvr : with refinement types, we might have `data [a] :> NonEmptyList a = a : [a]'
04:08:07 <mornfall> (But, if those things happen when people google for chat and get to #haskell by randomly clicking things, there must be an awful amount of wrong in the world...)
04:09:03 <mornfall> Now I wish I knew how to express my ugly ugly problem with transformer stacks. :(
04:09:37 <ricree> huh... for some reason it hadn't even occurred to me that (,) might have a type rather than just being a piece of syntax
04:10:02 <mornfall> :-))
04:10:05 <geheimdienst> > let tuplify = (,) in tuplify "lolcats" 42
04:10:06 <lambdabot>   ("lolcats",42)
04:10:13 <mux> :t (,,,)
04:10:14 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
04:10:29 <mornfall> It not only has a type, it is a value, too!
04:10:47 <mux> > (1,) 2
04:10:48 <lambdabot>   Illegal tuple section: use -XTupleSections
04:10:55 <ski> > case (,) of (,) -> ()
04:10:56 <lambdabot>   Couldn't match expected type `a -> b -> (a, b)'
04:10:56 <lambdabot>         against inferred ty...
04:10:57 <mux> what, an extension not enabled in ghc?!
04:11:01 <mux> err
04:11:02 <mux> in lambdabot
04:11:10 <mornfall> mux: !
04:11:24 <mux> tuple sections are so yummy though
04:11:25 <mornfall> You win a Glasgow Cookie.
04:11:34 <mux> mornfall: I do? Cool! :D
04:11:56 <mornfall> Unfortunately you need GHC 12.2.1 to compile it.
04:12:16 <mux> GHC 12? Well, I'll just to wait a few months ;-)
04:12:32 <mornfall> Yeah. It'll also solve *my* problem, I am sure.
04:12:56 <mux> any new GHC version is supposed to fix problems you didn't even know you had, isn't it? ;-)
04:13:00 <mornfall> (Among other things by making 7.2 sufficiently old to get me superclass equalities...)
04:13:38 <mux> yeah, superclass equalities were much awaited by me too
04:14:04 <mornfall> Now, having a /~ operator would be possibly even cooler.
04:15:04 <mornfall> (Life was easy when all we had were single-parameter type classes...)
04:17:56 <aspect> I don't really know haskell but I'm playing in response to the horrible code at http://dada.perl.it/shootout/nestedloop.ghc.html -- don't bother following that link if you like your eyes, but if anyone can critique my attempt at http://paste.lisp.org/+2NQQ/1 I'd really appreciate it :)
04:18:25 <m3ga> something is wrong with my ghc install. I get "Not in scope: type constructor or class X" even though I'm using -package Y which provides constructor X. anyone seen this before?
04:19:30 <kmc> mornfall, it's one of the biggest channels on Freenode
04:19:48 <kmc> m3ga, you have to import a module that exports that type
04:20:11 <kmc> m3ga, also, it's rare to pass -package directly
04:20:13 <geheimdienst> m3ga: note that there is a difference between type constructors and data constructors. i suspect you are using a class where you'd need a data constructor
04:20:18 <aspect> my Church combinator I'm sure can be more neatly written
04:20:37 <geheimdienst> > let f :: Int = () in 42
04:20:38 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:20:38 <lambdabot>         against inferred type ...
04:20:43 <kmc> m3ga, you'd either use ghc --make (the default in GHC 7), which finds -package flags for you
04:20:43 <geheimdienst> > let f :: Int = 3 in 42
04:20:44 <lambdabot>   42
04:20:47 <kmc> or you'd use Cabal
04:20:48 <frerich> Is anybody here familiar with 'Zipper' structures (as in http://www.haskell.org/haskellwiki/Zipper)? I have some code which passes around some state and part of the stat is a list as well as a 'currentElement' integer which references some item in the list to be processed next. This is a bit ugly since I need to verify that the index is valid in the first place. Are Zippers a good solution to this, so that I use
04:20:48 <frerich>  a data structure which doesn't even make it possible for references to go out of bounds?
04:20:49 <geheimdienst> > let f :: (Eq a) = 3 in 42
04:20:50 <lambdabot>   Not in scope: type variable `a'
04:21:00 <hvr> geheimdienst: ...is there a separate irc channel for flirting with haskell programmers btw?
04:21:06 <kmc> frerich, yes, that sounds a lot like a zipper
04:21:09 <kmc> hvr, #haskell-blah
04:21:59 <frerich> kmc: Cool, thanks for the confirmation, so I'll look at that more closely.
04:22:21 <kmc> frerich, in general indexing lists with integers is slow and crappy
04:22:32 <kmc> look at Data.Sequence also
04:22:51 <geheimdienst> m3ga: people can help you better if you paste the code that's giving you trouble
04:22:56 <geheimdienst> @where hpaste
04:22:56 <lambdabot> http://hpaste.org/
04:23:05 <m3ga> geheimdienst: its the ddc compiler
04:23:12 <frerich> kmc: True, and I'm actually in the process of porting this code to Data.Sequence, but the problem remains - I have a structure and some reference into it and I'd like to remove the need to validate the reference by simply making it impossible for the reference to become invalid.
04:23:15 <m3ga> 50k lines of code :-)
04:23:18 <kmc> yeah
04:23:48 <m3ga> the make file worked for ghc-7.0.3 but fails with 7.0.4.
04:23:55 <frerich> kmc: Otherwise I'd start writing invariants (makes me wonder how you implement invariants nicely in Haskell programs).
04:24:45 <kmc> well, in most languages, most invariants are unchecked
04:24:54 <kmc> the same is true in Haskell
04:25:23 <kmc> you can sometimes push them into the type system
04:25:40 <frerich> Yes, I'm trying to lessen the need for runtime checks by moving more power to the type system.
04:25:48 <Maxdamantus> loop min max f x = iterate f x !! (max - min) .. maybe
04:25:54 <kmc> invariants usually don't have runtime checks
04:27:05 <kmc> data List size t where { Nil :: List Z t; Cons :: t -> List n t -> List (S n) t }
04:27:13 <kmc> data Z; data S n;
04:27:19 <frerich> kmc: Hm? Then we must be talking about different kinds of invariants. I mean conditions which hold true before and after some given code is performed. But now that I think about it, maybe invariants aren't as useful in haskell since you don't have that much state in the first place. SO you rather use pre/postconditions.
04:27:21 <kmc> that's a list whose length is tracked in types
04:29:00 <aspect> Maxdamantus: hm thanks, I'll have a play with that
04:29:11 <Maxdamantus> (assuming max > min)
04:29:14 <kmc> data Fin n where { Zero :: Fin n; Succ :: Fin n -> Fin (S n) }
04:29:45 <Maxdamantus> >=, rather .. otherwise you'd use the `max 0 (max - min)` .. but max is shadowed.
04:29:45 <aspect> I also seem to be running out of stack space with an argument >8, any pointers on how to avoid that?
04:29:49 <kmc> that gives you bounded indices (if I did that right)
04:30:12 <aspect> I thought the original might be doing contortions to be tail-recursive but it appears to have the same problem
04:30:15 <kmc> then you can pair them up etc.
04:30:19 <kmc> it all gets pretty ugly though
04:30:34 <frerich> kmc: Hm actually, I just had an idea. Instead of maintaining a Data.Sequence and updating an 'index' (which, in my case, happens to be ever incrementing and if it hits the end it starts from the beginning), I could remove the index and rotate the sequence instead.
04:30:40 <frerich> So the first element is always the next.
04:30:41 <kmc> *nod*
04:30:57 <geheimdienst> kmc: neat yet terrifying
04:31:13 <Maxdamantus> Yeah, I think the `iterate` version should avoid that.
04:31:32 <kmc> frerich, I think we're using the same definition of "invariants".  i'm saying that in most code, the invariants are only described in comments, and are not checked, at runtime or compile time
04:31:37 <Maxdamantus> Can also do the same with `church`
04:31:59 <frerich> kmc: I must admit I looked at your type magic but I only thought "Oh you can do some funky stuff but better only bother thinking about it when you got the basic stuff sorted out". :-)
04:32:10 <aspect> just: church n f x = iterate f x n  ?
04:32:18 <Maxdamantus> Looks like it.
04:32:39 <Maxdamantus> iterate f x !! n
04:32:55 <Maxdamantus> (again, assuming n >= 0)
04:33:17 <Maxdamantus> Otherwise: iterate f x !! max n 0
04:33:47 <kmc> frerich, same for pre/post conditions
04:34:38 <frerich> kmc: Hm, I see. Some times ago I worked with a language which had some sort of annotations to express pre/post conditions as well as invariants. At runtime, in debug builds, they had the same effect as assert()'ions in C.
04:34:41 <geheimdienst> suppose i have a big map of things, currently of the form [(k, v), (k, v)]. i'd like to enforce at compile time that the keys are unique. any chance?
04:34:51 <frerich> kmc: I wondered, maybe Haskell has something along the lines of that.
04:35:06 <kmc> frerich, only what you can express in the types
04:35:19 <kmc> though if it's just runtime checking you want, there are many ways
04:35:24 <aspect> Maxdamantus: thanks.  Would it be too much to ask how I would make either of these functions tailrec without iterate?
04:36:13 <frerich> kmc: Hm yeah I guess I'm just thinking of a little code generation so that I don't have to write "f x | x < 3 || x > 9 = error ..." by hand.
04:36:29 <kmc> here's one trick for that: http://mainisusuallyafunction.blogspot.com/2010/09/view-patterns-for-validation.html
04:36:32 <frerich> ...because I can write '-- | @precondition: 3 < x < 9' or so.
04:37:09 <frerich> kmc: Ha! That looks very much like what I had in mind.
04:37:50 <frerich> Neat.
04:37:58 <kmc> you can also write a function that takes a function and returns a range-checked function
04:38:14 <kmc> f = checkRange 3 9 g where g x = ...
04:38:16 <geheimdienst> ... and i just had the epiphany of saying "f k1 = v1" "f k2 = v2". if k1 and k2 are the same, ghc prints a warning :)
04:38:25 <Maxdamantus> aspect: dunno.
04:38:30 * Maxdamantus needs to do more Haskell.
04:39:23 <aspect> (hmm no even the iterate version blows the stack)
04:39:30 <frerich> kmc: Oh, that's a cool idea as well.
04:39:31 <aspect> Maxdamantus: no worries, thanks for your help :)
04:39:37 <Maxdamantus> Hm. Really?
04:39:46 <frerich> kmc: Oh I can't wait to try all this stuff, it's hilarious. :-)
04:40:12 <Maxdamantus> I'd say it's probably not the stack.
04:41:30 <Maxdamantus> > iterate succ 0 !! 90000
04:41:31 <lambdabot>   90000
04:41:36 <aspect> that's the error the compiled version gives me, though in the interpreter it's fine.  Getting a bit deep, I guess I need to read seriously :)
04:41:51 <mux> > iterate succ 0 !! 900000
04:41:52 <lambdabot>   *Exception: stack overflow
04:42:20 <Maxdamantus> Oh, stack there.
04:42:38 <Maxdamantus> (when it finally tries to evaluate, I guess)
04:42:55 <mux> > let iterate' _ [] = []; iterate' f (x:xs) = let x' = f x in x' `seq` iterate f xs in iterate' succ 0 !! 900000
04:42:55 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
04:42:59 <mux> woops.
04:43:13 <mux> > let iterate' _ [] = []; iterate' f (x:xs) = let x' = f x in x' `seq` x' : iterate f xs in iterate' succ 0 !! 900000
04:43:14 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
04:43:24 <mux> !$#@%$!#]
04:43:35 <parcs> :t foldr (.) id . repeat
04:43:36 <lambdabot> forall b. (b -> b) -> b -> b
04:44:02 <Maxdamantus> Giving a list to iterate?
04:44:11 <parcs> :t foldr (.) id . take . repeat
04:44:12 <lambdabot>     Couldn't match expected type `[b -> b]'
04:44:12 <lambdabot>            against inferred type `[a] -> [a]'
04:44:12 <lambdabot>     In the first argument of `(.)', namely `take'
04:44:32 <aspect> :t iterate
04:44:34 <lambdabot> forall a. (a -> a) -> a -> [a]
04:45:43 <Maxdamantus> > let iterate' _ = id; iterate' f x = let x' = f x in x' `seq` iterate' f x' in iterate' succ 0 !! 900000
04:45:44 <lambdabot>   Equations for `iterate'' have different numbers of arguments
04:45:45 <lambdabot>    <interactiv...
04:46:29 <zhulikas> >0!!5
04:46:35 <zhulikas> > 0!!5
04:46:36 <lambdabot>   No instance for (GHC.Num.Num [a])
04:46:36 <lambdabot>    arising from a use of `e_105' at <inte...
04:46:42 <mux> ah, here we go
04:46:46 <mux> > let iterate' f x = let x0 = f $! x in x0 : iterate' f x0 in iterate' succ 0 !! 900000
04:46:47 <lambdabot>   *Exception: stack overflow
04:46:56 <mux> not quite correctly strict
04:47:01 <mux> to think I already wrote this twice...
04:47:25 <mux> > let iterate' f x = let x0 = f x in x0 `seq` x0 : iterate' f x0 in iterate' succ 0 !! 900000
04:47:25 <adimit> There's no Int24 type in Haskell?
04:47:26 <lambdabot>   900001
04:47:28 <mux> \o/
04:47:29 <mux> victory.
04:47:45 <kmc> not afaik adimit
04:47:52 <mux> strictness saved the stack, once again.
04:47:53 <Maxdamantus> One too many.
04:47:55 <kmc> you could define one
04:47:58 <adimit> kmc: *sadface*.
04:48:12 <kmc> why do you need Int24?
04:48:16 <adimit> kmc: how? Do you have any pointers on how the Int* types are built?
04:48:22 <adimit> kmc: type safety reall.
04:48:23 <adimit> *really.
04:48:27 <aspect> mux: mind blown.  Thanks :)
04:48:34 <mux> aspect: you're welcome
04:48:58 <mux> I think I even filed a bug report about this, suggesting the addition of a strict iterate' in the base libraries
04:49:02 <zygoloid> adimit: define a newtype around Int, and implement Num such that all the operations work mod 2^^24
04:49:19 <adimit> kmc: I have a specific problem where I need a 3 byte integer, and using Int32 and relying on the programmer to provide one with the first byte zero'd would be… risky.
04:49:35 <kmc> you can just zero the first byte when you get it
04:49:37 <kmc> but yeah, okay
04:49:39 <adimit> zygoloid: I understand. Well, I don't actually need to do num operations with it.
04:49:54 <adimit> kmc: well, that's a bit ugly, because it would completely ruin my data.
04:50:09 <adimit> i.e. the output would just be erroneous.
04:50:36 <hpc> zygoloid: i think there's an interval-arithmetic package on hackage
04:51:34 <frerich> Hm I think it would be funky if 'take' could accept negative values to express 'all but last N', e.g. 'take -1 xs' has the same effect as 'take (length xs - 1) xs'.
04:52:14 <adimit> 'funky' is the right word for that…
04:52:21 <frerich> Maybe I'm spoiled by Python, ahem.
04:52:54 <adimit> frerich: you would change the behaviour of take drastically: take works on infinite lists. If take took negative numbers like that, I couldn't rely on take always working on infinite lists.
04:53:04 <geheimdienst> i don't think it's that funky, it's fairly standard
04:53:04 <frerich> adimit: True.
04:53:33 <geheimdienst> i'd call it "rtake" for reverse take or something
04:54:06 <geheimdienst> but yeah, i wouldn't muddle it into the existing take function, because of the infinite list thing
04:54:22 <adimit> yeah, I'd definitely name it differently. I prefer a function to be undef over a certain range of input over a function changing its behaviour for different ranges of input.
04:55:20 <adimit> worse than infinite lists would be that take doesn't require evaluation for everything that is not 'take'n. rtake *does* force the entire list ( if you force the result. )
04:55:38 <adimit> mangles space-time complexity quite a bit.
04:58:36 <mornfall> adimit: It'd only force the spine, AFAICT.
04:59:05 <mysticc> What is the problem in this .. http://paste.pocoo.org/show/459872/
05:00:01 <adimit> mornfall: depends. If the list is built up incrementally, i.e if n+1 is calculated using n, it'd have to force the values, too.
05:00:20 <mornfall> adimit: True.
05:00:49 <mornfall> But you have to expect that.
05:01:13 <kmc> mysticc, what's the error message?
05:01:28 <mornfall> head . drop n also does the same thing for the discarded part of the list
05:01:30 <mysticc> kmc:  Couldn't match expected type `[t0]' with actual type `IO String'
05:01:34 <kmc> one problem is that you're returning a list on one branch, and an IO action on another branch
05:01:51 <erus`> > sqroot
05:01:52 <lambdabot>   Not in scope: `sqroot'
05:02:06 <adimit> yes. relying on something to only force the spine of a list is — in my book — a clear case of "user knows very well what she's doing."
05:02:41 <mysticc> kmc: How to correct that .... what I want is given y .. read next y lines from STDIN and return them as a list ..
05:02:42 <erus`> > sqrt $ 3 * 4 * 5
05:02:43 <lambdabot>   7.745966692414834
05:02:58 <erus`> > sqrt $ 3 * (sqrt $ 4 * 5)
05:02:58 <lambdabot>   3.6628415014847064
05:03:01 <kmc> replicateM n getLine
05:03:11 <kmc> mysticc, http://www.haskell.org/haskellwiki/Introduction_to_IO
05:04:16 <zygoloid> adimit: a well-written rtake would not force the entire list spine
05:05:16 <zygoloid> here's a properly-lazy implementation: rtake n xs = zipWith const xs (drop n xs)
05:08:49 <adimit> zygoloid: how do you calculate the length of a list w/o forcing the spine? I think frerich's original intention was to get the *last* n elements of a list.
05:09:17 <adimit> more like \n -> take n.reverse
05:09:26 <aspect> :t seq
05:09:27 <lambdabot> forall a t. a -> t -> t
05:09:29 <zygoloid> adimit: that's not what the sample implementation does
05:09:44 <zygoloid> frerich said "all but last N", not "last N"
05:09:52 <adimit> oh, I misunderstood.
05:10:27 <fryguybob> > let l a b f x = Data.Foldable.foldr' ($) x $ map (const f) [a..b]; c f x 0 = x; c f x n = c f (f x) (n-1); n t = c (l 1 t) (+1) 6 0 in n 10  -- aspect
05:10:28 <lambdabot>   1000000
05:10:35 <zygoloid> it still needs to retain N elements, which may be an important change in behaviour
05:11:49 <adimit> indeed, you're right. the concern about infinite lists still applies, but it doesn't force the whole spine. I've always had a problem with properly reading the instructions >.>
05:12:22 <frerich> zygoloid, adimit: I'm sorry for the confusion; indeed, as zygoloid says, I was thinking of the same behaviour as [:-n] in Python (e.g. range(5)[:-2] yields [0,1,2], omitting the last two elements).
05:13:29 <adimit> ah, well, I don't know of Python's take :-) In Python, that makes a whole lot of sense to have this.
05:13:57 <zygoloid> i wouldn't like to see 'take' gaining this ability. i've been bitten more than once by python's "negative indexing means from the end" approach
05:14:33 <adimit> yeah, but the idea is sound. I think the suggestion to go with a different function name (rtake, or what have you,) is a sound one.
05:14:45 <zygoloid> in a dynamic language like python, you definitely don't want obvious off-by-one errors in list indices to magically produce some other random element of the list
05:16:18 <adimit> I hate those subtle bugs where your code doesn't fail but predends to do the right thing. You often only notice it quite a ways downstream.
05:19:58 <brisingr> @src replicateM
05:19:58 <lambdabot> replicateM n x = sequence (replicate n x)
05:34:28 <brisingr> how do you read a specified number of lines without using do-notation?
05:34:49 <opqdonut> for instance with replicateM
05:35:24 <kmc> brisingr, you can always eliminate do notation
05:35:36 <kmc> @undo do { x <- a; y <- f x; return (g x y) }
05:35:36 <lambdabot> a >>= \ x -> f x >>= \ y -> return (g x y)
05:35:55 <brisingr> hmm, let
05:35:57 <brisingr> 's see
05:36:33 <kmc> i.e.:  a >>= (\x -> f x >>= (\y -> return (g x y)))
05:36:38 <brisingr> @undo do { x <- a; y <- b; return (f x y)
05:36:39 <lambdabot>  Parse error at end of input
05:36:42 <brisingr> @undo do { x <- a; y <- b; return (f x y)}
05:36:43 <lambdabot> a >>= \ x -> b >>= \ y -> return (f x y)
05:36:54 <kmc> that's also:  liftM2 f a b
05:36:57 <kmc> or liftA2 f a b
05:37:00 <kmc> or  f <$> a <*> b
05:37:25 <brisingr> oooh, I see
05:42:09 <frerich> Is it possible to have different definitions of a polymorphic function depending on the classes of the type? I have a function "unique :: (Eq a, Ord a) => [a] -> Bool" and now I'd like to have a different implementation if 'a' just instantiats Eq but not Ord.
05:44:09 <Cale> frerich: no, but you could make a new typeclass
05:44:10 <RichardBarrell> Not in plain Haskell, and I don't know that you can even do that with any of the type-system extensions in GHC.
05:44:16 <mizu_no_oto> What's the difference between a black hole and an infinite loop?
05:44:39 <kmc> frerich, why should those two functions have the same name?
05:44:44 <Cale> mizu_no_oto: A black hole is the code which GHC redirects a value at when it begins to evaluate it
05:44:56 <kmc> might you not sometimes want to do Eq-based uniquification on types which happen to implement Ord?
05:45:04 <Cale> mizu_no_oto: So that if it starts to evaluate it again, it can detect the loop.
05:45:12 <mizu_no_oto> so a black hole is used to detect infinite loops
05:45:15 <Cale> mizu_no_oto: yeah
05:45:26 <Axman6> i think a blackhole just says that something is already evaluating this value no?
05:45:36 <Axman6> i thought it was part of the parallel runtime
05:45:49 <Cale> those are called grey holes, I believe :)
05:45:58 <Axman6> hmm, not in the talks i've seen :\
05:46:24 <RichardBarrell> Not all infinite loops will actually show up as black hole exceptions. Some will but you can't rely on it.
05:46:53 <Cale> Well, they can be called whatever, but yeah, once you have a threaded runtime, you can't assume that re-entering a value means that you have a loop
05:47:06 <Cale> Instead, you have to wait in case some other thread is evaluating it
05:47:13 <Cale> (or do something to check)
05:47:36 <mux> does the RTS know whether some thunk is in scope in multiple threads or just one?
05:48:02 <Cale> I don't think it can tell.
05:48:43 <frerich> kmc: No, I don't want to execute the Eq-based unification for types which happen to implement Ord. It's just that I sometimes have functions I can implement in multiple ways (in particular, with different time or space complexities) depending on what classes a type instantiates. For instance, if I can sort a type (because it implements Ord) then I can do some things more efficiently than if it just implements Eq.
05:49:03 <frerich> kmc: So I wondered, maybe I could have one function which always works as good as possible for any given type.
05:51:58 <efie> i have a function tansmit :: String -> String with transmit = decode . channel_1 . encode whereas encode :: String -> [Bit], channel_1 :: [Bit] -> [Bit], decode :: [Bit] -> String. this works well. if i now want to transmit via channel_2 i just want to say transmit = decode . channel_2 . encode; but channel_2 :: [Bit] -> IO [Bit]. i am not really familiar with IO, can decode still be of type [Bit] -> String?
05:52:31 <frerich> kmc: http://hpaste.org/50393 <-- the code I have, I tried to merge the two functions into one.
05:53:33 <merijn> efie: If channel_2 is IO [Bit], then decode can be [Bit] -> String, but you will have to write transmit differently
05:54:02 <merijn> @pl return . f
05:54:02 <lambdabot> return . f
05:54:17 <rwbarton> replace decode by fmap decode :: IO [Bit] -> IO String, then transmit will have type String -> IO String
05:54:39 <Cale> If you're going to unicodify (.), why not (∘)?
05:55:08 <efie> um i dont know what is meant by (∘)
05:55:55 <merijn> efie: Let's say decode is indeed [Bit] -> String and you have channel_2 which is [Bit] -> IO [Bit]. One possible solution is >>=
05:55:59 <merijn> :t (>>=)
05:56:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:56:08 <brisingr> I'm gonna ask another stupid problem, what's wrong with this (I know it's fail on my part):
05:56:10 <hpaste> brisingr pasted “fail me replicateM” at http://hpaste.org/50394
05:56:47 <merijn> We have an IO [Bit] and a function which takes [Bit] and returns String. Now the problem is of course that (>>=) demands that this function returns IO String instead. Which we can solve easily using return
05:56:49 <merijn> :t return
05:56:50 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
05:57:19 <rwbarton> brisingr: the error isn't with replicateM, it's somewhere around "read"
05:57:22 <ion> brisingr: Look at the types. They don’t match.
05:57:55 <brisingr> hmm
05:57:59 <ion> Well, there’s another type mismatch with the use of replicateM.
05:58:05 <mornfall> *or* you could fmap read.
05:58:05 <frerich> Cale: My IRC font apparently doesn't know that last character you wrote.
05:58:12 <rwbarton> oh true
05:58:19 <clsmith> hmm, is it possible to quickcheck an IO function?
05:58:24 <ion> clsmith: Yes
05:58:40 <Cale> frerich: a small circle, like composition usually is in mathematics
05:58:52 <clsmith> okay, cool. :) i'll look into it
05:58:54 <cpa> is there a typeclass for operations like lookup/elem ?
05:58:55 <efie> merijn: unfortunately im not familiar with >>== either; can you maybe show me an example where your idea of how soliving this is used?
05:59:24 <merijn> efie:  Do you have a small sample code using those functions which you can pastebin? Then I can edit it to show how this can be used
06:00:00 <efie> this would be great, wait a second
06:00:17 <ion> @hoogle morallyDubiousIOProperty
06:00:17 <lambdabot> No results found
06:00:25 <ion> clsmith: Look that up.
06:00:36 <clsmith> lol, okay
06:00:59 <brisingr> :t readLn
06:01:00 <lambdabot> forall a. (Read a) => IO a
06:01:31 <kmc> cpa, not a common one
06:01:49 <kmc> cpa, it's hard to design that class in a way that's generally useful
06:01:50 <clsmith> ah, i see. interestingly named, too :p
06:01:55 <tswett> Hi.  I'm trying to install the SDL library on OS X, but it's giving me this error: "General.hsc:60: error: ‘SDL_INIT_CDROM’ undeclared (first use in this function)"
06:01:58 <kmc> especially without using language extensions beyond Haskell 2010
06:02:11 <brisingr> the problem is replicateM wants String and getLine gets IO String
06:02:20 <tswett> Here's the pastebin: http://pastebin.com/dXctEsYB  Perhaps the SDL wrapper is expecting libsdl to be in a specific place, and it isn't?
06:02:22 <mauke> The paste dXctEsYB has been copied to http://hpaste.org/50395
06:02:25 <djahandarie> copumpkin, I got owned by sjoerd visscher :(
06:02:26 <kmc> :t replicateM
06:02:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
06:02:34 <kmc> :t replicateM :: Int -> IO String -> IO [String]
06:02:35 <lambdabot> Int -> IO String -> IO [String]
06:02:55 <brisingr> so why is the expected type [a]?
06:03:19 <brisingr> oh oh right, the other way round
06:03:22 <brisingr> :t getLine
06:03:23 <lambdabot> IO String
06:03:26 <kmc> \n -> replicateM n getLine >>= \xs -> print xs
06:03:37 <kmc> (that simplifies, though)
06:03:51 <kmc> brisingr, the problem is what putStrLn expects ,not what replicateM expects
06:04:04 <kmc> namely putStrLn wants [Char] and not IO [[Char]]
06:04:10 <kmc> (that's actually two problems)
06:04:59 <efie> merijn: i hope this is short enough http://pastebin.com/sDGLFSTp
06:05:01 <mauke> The paste sDGLFSTp has been copied to http://hpaste.org/50396
06:05:14 <brisingr> kmc: thanks
06:05:52 <kmc> :)
06:09:59 <Peaker_> Maybe a GHC extension can be made to allow:  DataConstructor { f x = ... }  it's the only place in the language where f = \x -> ...   is not replaceable with f x = ...
06:10:53 <mm_freak> Peaker_: i think, that is already allowed
06:11:32 <kmc> not to my knowledge
06:11:41 <mm_freak> @src Either
06:11:41 <lambdabot> Source not found.
06:11:43 <kmc> you can use RecordWildCards though
06:11:46 <Peaker_> mm_freak: http://codepad.org/w22e3Vts
06:11:51 <kmc> let f x = ... in DataConstructor{..}
06:11:52 <Peaker_> kmc: what's that?
06:11:57 <kmc> a GHC extension
06:12:18 <Peaker_> DataConstructor{..} instantiates the record with all of the names from scope?
06:12:21 <kmc> yes
06:12:26 <Peaker_> oh, interesting (yet somewhat.. evil)
06:12:28 <Peaker_> :)
06:12:30 <kmc> yes
06:12:40 <roconnor> Peaker_: yes, I want that extension!
06:12:42 <kmc> there's also NamedFieldPuns
06:13:02 <kmc> which lets you write C{x, y} as shorthand for C{x=x, y=y}
06:13:07 <kmc> less evil
06:13:33 <Peaker_> yeah
06:15:25 <cari_veri_epdsk> hello guys, exuse my interruption: does any one know the ATOM language ( a dsl for haskell )? Im looking for scientific documents that I can make a seminar presantation from ?
06:16:45 <byorgey> cari_veri_epdsk: look at http://tomahawkins.org/, under the heading "Atom", there are some links there you may find useful
06:17:59 <copumpkin> djahandarie: aww
06:18:02 <cari_veri_epdsk> byorgey: nice, thank you very much.
06:18:56 <hpaste> merijn pasted “>>= and IO” at http://hpaste.org/50397
06:19:22 <merijn> efie: Not exactly the sort of example I had in mind, but I hope that one helps
06:19:58 <byorgey> cari_veri_epdsk: by the way, it's no interruption, questions are always welcome here
06:20:17 <merijn> efie: Feel free to ask if you get confused, but meditating on this and the type signatures should hopefully enlighten you :)
06:22:25 <efie> yes, i hope so! i will go on reading some introducing texts for IO and monads, and if i hit on >>= i will be able to compare it to a example im familiar with and which works - thank you very much :)
06:22:54 <merijn> efie: Personally I think the best approach is to not combine IO and monads
06:23:20 <brisingr> can you forcefully leave IO? just academic curiosity
06:23:36 <merijn> brisingr: Yes, but all bets about what happens are off
06:23:41 <Cale> brisingr: forcefully leave?
06:24:03 <djahandarie> copumpkin, though the main reason seems to be because he used a different representation of Omega than I did
06:24:04 <merijn> brisingr: Because the compiler assumes that you don't and some code transformations may break the code if you do
06:24:15 <merijn> Cale: He means simonSaysPerformIO
06:24:21 <Cale> merijn: well...
06:24:23 <Cale> maybe :)
06:24:29 <brisingr> I see
06:24:31 <djahandarie> copumpkin, which allows him to directly write fmap, as opposed to mine where I think you need to use parity
06:24:35 <copumpkin> cool
06:24:36 <brisingr> just curiows
06:24:41 <brisingr> *curious
06:24:57 <Cale> brisingr: Generally it's not required because you can take any computation not written using IO and use it from an IO action
06:25:20 <armido> Guys, what kind of ability does Haskell have at implementing ADTs?
06:25:23 <clsmith> merijn: i assume bets are off only if the action has side-effects?
06:25:24 <brisingr> Cale: yeah, I finally figured that out
06:25:26 <Cale> brisingr: So what you're really asking is whether you can embed an IO action into a non-IO action (if merijn's understanding of what you're asking is correct :)
06:25:35 <kmc> armido, A = "abstract" or A = "algebraic" ?
06:25:35 <Cale> Or a non-IO expression
06:25:37 <Cale> rather
06:25:41 <brisingr> yes
06:25:55 <kmc> brisingr, the precise way to ask is "can I make a value whose evaluation causes IO execution"
06:25:55 <merijn> clsmith: Well all bets are off, but if you happen to know things are rigged it might still be safe
06:25:57 <armido> abstract
06:26:05 <kmc> normally evaluation and execution are separate processes
06:26:11 <merijn> efie: Once you look at monads from an IO perspective people get hopelessly confused. I would recommend just ignoring IO is a monad for now and when you are stuck with an IO variable write your code in a do block and use "<-" to get it "out" of IO (which is not what it does, but don't worry about that until you have figured out "normal" monads)
06:26:12 <kmc> armido, mostly just modules
06:26:21 <armido> kmc: examples?
06:26:25 <merijn> efie: I think the list and Maybe monads are nicest for understanding monads
06:26:50 <kmc> armido, you export a type and some operations without exporting the data constructor for that type
06:27:18 <merijn> brising, clsmith: Basically if you get something out of IO you may accidentally cause an IO action to be executed more then once. If you know it won't be you can get away with it, of course
06:27:19 <kmc> brisingr, a separation between evaluation and execution is really the way to look at it
06:27:21 <efie> merijn: ok, i will keep it in mind
06:27:27 <kmc> not "IO world vs pure world" or "pure vs impure functions"
06:27:37 <brisingr> was asking that because it seems that "<-" "leaves" IO
06:27:38 <kmc> because IO actions are pure values too
06:27:51 <kmc> brisingr, it doesn't, really
06:27:52 <armido> kmc: Alright, and comparison to advanced ADTs in Java?
06:27:58 <merijn> @quote is.not.a.bug
06:27:58 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
06:28:13 <kmc> armido, how much Haskell do you know?
06:28:29 <merijn> brisingr: Did you see my IO and >>= example code I pasted just a few mins back?
06:28:38 <brisingr> yes
06:28:41 <Cale> armido: You can use the module system to construct abstraction barriers
06:28:46 <kmc> brisingr, <- is syntactic sugar for (>>=)
06:28:52 <Cale> armido: Just don't export the data constructors of your defined type
06:28:53 <kmc> (>>=) :: IO a -> (a -> IO b) -> IO b
06:28:58 <kmc> so you're never "leaving IO"
06:29:03 <merijn> brisingr: Ok, so you've seen how x <- becomes >>=
06:29:07 <brisingr> yes
06:29:14 <kmc> you're gluing together an IO action and a function for producing another IO action
06:29:20 <kmc> and the result of that gluing is yet another IO action
06:29:25 <Cale> armido: and instead export only constructors which preserve whatever invariants you're interested in
06:29:30 <armido> kmc: not a lot. I do very advanced Java and have been recently referred to Haskell
06:29:42 <Cale> "smart" constructors
06:29:48 <kmc> armido, i think analogies between Haskell and other languages are counterproductive for Haskell beginners
06:29:49 <brisingr> so if I want to glue together an IO action and a function that does not produce an IO action, I am forced to use "return"
06:29:49 <Cale> Data.Set is a good example of this
06:30:00 <kmc> brisingr, or fmap
06:30:11 <Axman6> i don't think there is a good analog for ADT's in java
06:30:12 <Cale> fmap :: (a -> b) -> IO a -> IO b
06:30:19 <kmc> fmap f x = x >>= (return . f)
06:30:21 <armido> I'm thinking of doing a thesis between a relationship of Java and Haskell
06:30:25 <merijn> brisingr: As kmc said, you can actually think of IO actions as callbacks in an event system like Node.js or Python's Twisted. You program ends up being one big IO callback which gets run
06:30:48 <armido> as Haskell is amazing so far, especially it's comparison to Java
06:31:18 <brisingr> I see
06:31:23 <brisingr> thanks
06:31:23 <Axman6> java and haskell don't have all that much in common
06:31:36 <merijn> Axman6: They're both Turing complete? :)
06:31:49 <brisingr> you'll have to bear with me while I ask stupid questions
06:31:51 <byorgey> 'class' is a keyword in both
06:31:55 <kmc> they both use semicolons and curly braces
06:31:55 <Axman6> though, i believe generics in java were strongly inspired by Haskell's polymorphic data types
06:32:08 <Cale> They both support parametric polymorphism (lol)
06:32:09 <armido> axman6: they're almost identical!
06:32:11 <brisingr> and of course they both have functions
06:32:19 <Axman6> java doesn't have functions
06:32:21 <Cale> Java doesn't have functions
06:32:21 <kmc> Java doesn't
06:32:24 <Cale> lol
06:32:24 <kmc> :D :D :D
06:32:24 <Axman6> it's got object methods
06:32:29 <Axman6> ha XD
06:32:39 <kmc> a lot of languages are "inspired by Haskell" yet make a bloody mess of porting over those concepts
06:32:40 <brisingr> oh oh thought you were talking about python
06:32:47 <lispy> good morning
06:32:56 <lispy> Cale: has lambdabot been better behaved?
06:32:59 <kmc> sometimes the designers didn't actually learn Haskell and are just namedropping to sound cool
06:33:03 <Cale> seems so
06:33:17 <lispy> Cale: that's good news!
06:33:19 <kmc> sometimes they actually tried but couldn't make it fit / decided it's not worth the effort
06:33:21 <Axman6> i've heard that parametric polymorphism was implemented in java by some haskell people, can't remember where though
06:33:25 <byorgey> Cale: java does not support parametric polymorphism due to 'instanceof'
06:33:34 <byorgey> just polymorphism.
06:33:46 <Cale> byorgey: Hence the lulz
06:33:49 <byorgey> =)
06:33:52 <kmc> well it also has something like Typeable on every value
06:34:03 <kmc> because you can do a runtime-checked downcast, even without instanceof
06:34:11 <brisingr> wait, wait, java is inspired by haskell?
06:34:18 <brisingr> clearly
06:34:22 <Cale> brisingr: Slightly
06:34:25 <byorgey> certain aspects of it, not the language as a whole.
06:34:26 <kmc> you also have equality and a hashing function for all types
06:34:29 <lispy> Aren't they about the same age?
06:34:37 <Cale> There are Haskell programmers creeping everywhere.
06:34:55 <lispy> Haskell Hackers gonna creep?
06:34:57 <Cale> influencing the design of more popular languages
06:35:16 <brisingr> and everyone says "haskell programmers are in fact mathematicians so no-one will notice if we steal a few ideas"
06:35:29 <Axman6> i thought it was interesting what Guy Steel said about Fortress and its relationship with Haskell
06:35:40 <hpaste> djahandarie annotated “ClampEven is a monad on the order category of (<=)!” with “ClampEven is a monad on the order category of (<=)! (annotation)” at http://hpaste.org/50372#a50398
06:36:15 <Axman6> ie, he wishes he'd started with haskell and moved it a bit towards where fortress is, and not started with fortran(?), and tried to move it a hell of a long way towards haskell
06:36:36 <lispy> heh
06:36:42 <lispy> I think I heard that too
06:36:43 <djahandarie> copumpkin, ^ slightly cleaner. I wish I could make clampEvenClampEven use inductNat
06:37:09 <Cale> brisingr: One of the main guys working on C# and VB.net is Erik Meijer, whose name is also on the Haskell 98 report.
06:37:12 <lispy> Did any of you folks go to one of the hackathons this summer?
06:37:12 <merijn> brisingr: Another point of interest. In non-functional languages all lines of code are executed sequentially, right? And each previous line can influence the state for all following lines. This is exactly what do notation in the IO monad does, sequentially run each line and possibly setting variables in the rest of the sequence (using <-). Meanwhile normal haskell code can be executed in arbitrary order (if it is executed at all). You can think
06:37:13 <merijn> of it as tiny pieces of sequential code gluing lots of non-sequential code together.
06:37:34 <armido> Alright then, so can you guys explain any "huge" differences between the two languages?
06:37:43 <kmc> a) everything
06:37:49 <kmc> that's it, really
06:37:54 <Cale> armido: Between Java and Haskell?
06:37:56 <Axman6> they're pretty similar, like chaulk and cheese ;)
06:38:02 <kmc> nom
06:38:03 <armido> Cale: yes
06:38:06 <merijn> brisingr: Gluing IO actions together then becomes creating sequences of sequential code. (IO is secretly just a normal imperative language embedded in pure Haskell :)
06:38:07 <lispy> same same but different
06:38:11 <Axman6> they have very little in common
06:38:13 <brisingr> merijn: very interesting
06:38:28 <tromp> haskell is almost, but not quite ,entirely unlike Java
06:38:29 <kmc> merijn, it's not much of a secret :)
06:38:33 <brisingr> Cale: VB.net and C#? uh-oh
06:38:39 <Axman6> one is very useful to enterprise, the other is used a lot in enterprise :P
06:38:49 <merijn> brisingr: The big difference with Haskell and other languages is that in haskell you can choose to write "outside" of the sequential code, whereas this is impossible in imperative languages
06:39:04 <merijn> kmc: It's a public secret, only haskellers seem to know it :p
06:39:06 <Axman6> alexandre: it's not like a comparison between C and Java. they have many similarities.
06:39:11 <kmc> C# has lambdas and monad comprehensions
06:39:20 <Cale> armido: Haskell has non-strict semantics, which means that a compiler is free to evaluate values only when they're needed, in an arbitrary order.
06:39:27 <lispy> A secret is something everyone knows but no one is talking about
06:39:27 <kmc> but Everyone Knows those are useless academic nonsense
06:39:29 <brisingr> meijn: whoa, and that's something I can say in my talk
06:39:31 <kmc> so they had to come up with new names
06:39:35 <Cale> armido: It also admits infinite data structures to exist.
06:39:35 <armido> Axman6: C and Java are essentiallly one and the same. Not even related to this argument
06:39:38 <Cale> > [1..]
06:39:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:39:40 <Guest48557> Axman6: i think you mean wrong alexandre
06:39:51 <armido> Cale: You can do that in Java
06:39:56 <Axman6> uh, meant armido, sorry
06:40:02 <kmc> "C and Java are essentiallly one and the same"?
06:40:06 <kmc> are you just trolling or what?
06:40:09 <merijn> brisingr: Once you've meditated enough to realize IO is an imperative language embedded in Haskell everything will suddenly make so much sense :)
06:40:14 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
06:40:16 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
06:40:20 <Cale> ^^ do that in Java now :)
06:40:22 <armido> kmc: in the state of this current argument
06:40:30 <kmc> i'm not even sure what's being argued
06:40:38 <armido> kmc: pay attention
06:40:53 <brisingr> merijn: is it true that the implementation of IO is a big hack?
06:40:55 <kmc> armido, you asked a question to which the correct answer is a full copy of the Haskell 2010 Report and the Java Language Specification stapled together
06:40:59 <armido> kmc: sorry, I didn't mean that harsh
06:41:04 <kmc> brisingr, the implementation in GHC is, yes
06:41:08 <Axman6> armido: we'd be more willing to discuss the issue if you knew some haskell. trying to write a thesis on a subject you don't know anything about seems a little... odd to say the least :\
06:41:22 <kmc> but that's almost never relevant if you're just using IO
06:41:24 <Cale> armido: Next, Haskell has a conceptual separation between evaluation (which means turning expressions into values, and has no user-visible effect), and execution (of IO actions, which has arbitrary user-visible effects)
06:41:31 <kmc> the visible semantics of IO are not a hack
06:41:34 <armido> Axman6: well I've already written 30,000 words so therefore you are wrong
06:41:38 <kmc> haha
06:41:49 <kmc> 30,000 words on a topic you know nothing about
06:41:51 <kmc> that's impressive
06:41:55 <Axman6> armido: your argument is illogical...
06:42:14 <armido> kmc: ... and how did you come to this assumption?
06:42:15 <Cale> I agree about C and Java being similar
06:42:16 <kmc> > concat $ replicate 30000 "rutabega "
06:42:16 <lambdabot>   "rutabega rutabega rutabega rutabega rutabega rutabega rutabega rutabega ru...
06:42:19 <frerich> @google SCIgen
06:42:20 <lambdabot> http://pdos.csail.mit.edu/scigen/
06:42:21 <lambdabot> Title: SCIgen - An Automatic CS Paper Generator
06:42:22 <armido> Cale: thank you
06:42:27 <Cale> Compared to Haskell, C and Java are the same language.
06:42:28 <Axman6> does that mean i could go and do a PhD thesis on the difference between Haskell and COBOL and that would be accepted, without me even having to learn COBOL?
06:42:30 <armido> Cale: another one of brain in this chat room
06:42:39 <Cale> (almost)
06:42:44 <kmc> my troll sense is tingling
06:42:44 <brisingr> armido: what's your deadline?
06:42:49 <lispy> kmc: is that a reference to old movies and how they would have angry mobs say it to sound mean?
06:42:56 <kmc> lispy, yes
06:42:56 <Axman6> armido: you said you don't know haskell earlier no?
06:43:03 <lispy> kmc: obscure!
06:43:07 <brisingr> armido: if you put aside 2 weeks only for Haskell you can get very far
06:43:28 <Cale> C is slightly worse, because it has a few more abstraction problems than Java has.
06:43:28 <armido> Axman6: I don't know Haskell well, but it doesn't mean I don't know how the language works
06:43:28 <Axman6> we were always told to use rubarb in primary school to emulate a croud talking
06:44:08 <Cale> In particular, because it doesn't automatically manage memory, it's possible for C libraries to have a sort of impedance mismatch or disagreement about whose responsibility it is to clean up allocated values.
06:44:11 <kmc> Cale, I think that the complete lack of memory safety in C makes it vastly different from most other languages
06:44:11 <merijn> brisingr: The insides of IO are gross, but the outside semantics perfectly nice and clean
06:44:23 <Axman6> armido: i think i would disagree with that. one massively important part of haskell is its ability to make amazing abstractions, and that's something that takes time to understand
06:44:27 <Cale> But Java also has related problems, because of mutation.
06:44:46 * lispy disappears
06:44:50 <kmc> in particular for security
06:44:51 <Cale> (admittedly, not quite as bad)
06:44:57 <armido> Axman6: I never said anything about abstraction!!!
06:45:05 <kmc> but i forgot, good programmers make no mistakes, so C is fine and we're just wusses for using anything else
06:45:12 <merijn> kmc: Duh!
06:45:27 <Axman6> armido: ... but it's such an important part of haskell o.O
06:45:28 <merijn> Race conditions are only a problem for dumb people too
06:45:30 <Axman6> and Java really
06:45:54 <benmachine> C just takes a lot of typing though
06:45:59 <benmachine> even for perfect programmers
06:46:02 <brisingr> haskell has basically 0 race condition problems
06:46:07 <benmachine> you gotta write a new library on account of how rubbish libc is :P
06:46:08 <merijn> Which doesn't predict much good, since I generally consider myself of at least average intelligence and I f' up race conditions all the time :)
06:46:08 <armido> Axman6: you wouldn't know. Anyway, how do you guys think C relates to your language of Haskell?
06:46:09 <kmc> brisingr, not true
06:46:11 <Axman6> if you're not going to consider the power and expressiveness of a language, why even compare them at all?
06:46:26 <brisingr> kmc: okay, correction, well-written haskell?
06:46:31 <merijn> brisingr: Not true, but you can avoid a lot more of them soon
06:46:35 <kmc> armido, you're wasting everyone's time
06:46:39 <Axman6> does anyone else think that being abrasive and abusive is a really bad way to get people to help you?
06:46:46 <Axman6> i mean, it's not just me right>?
06:46:46 <kmc> with ridiculous questions that can't be answered
06:46:48 <Iceland_jack> Axman6: Because he's already written 30,000 words!
06:46:48 <Cale> I don't understand what this argument is
06:46:54 <Cale> I can answer the question
06:46:59 <kmc> brisingr, well-written code is bug-free by definition
06:47:00 <armido> Yes?
06:47:07 <merijn> brisingr: You can still have race conditions on a different level (i.e. you program definition has a race)
06:47:09 <Cale> (s)
06:47:20 <kmc> brisingr, you can do threaded concurrency with shared mutable state in Haskell
06:47:24 <Cale> Who is being abusive?
06:47:25 <kmc> and people quite frequently do
06:47:28 <merijn> brisingr: Multi-thread file system accesses, ordering, etc.
06:47:47 <benmachine> Axman6: when I think people are trolling, I tend to just pretend they're not; in either the case they are or they aren't it works out better
06:47:47 <kmc> and naturally you can run into race conditions
06:47:57 <brisingr> merijn: so the problem is within IO, is that what you mean?
06:48:10 <kmc> brisingr, STM is a really cool solution to that
06:48:14 <kmc> but it's not always suitable
06:48:22 <merijn> brisingr: The problem is that non-deterministic concurrency is...non-deterministic
06:48:32 <merijn> And where there is non-determinism there are races
06:48:35 <Axman6> Cale: do you think that to give answers to the level required for a thesis on haskell, it makes sense to completely ignore the power of abstractions and the expressivness of the language?
06:48:57 <kmc> brisingr, but the other nice thing about GHC Haskell is that you don't need to use concurrent semantics if you just want parallel performance
06:49:00 <Axman6> merijn: that's not necessarilly so
06:49:08 <Cale> Axman6: no, but maybe he's just not concerned with them right now? I'm not sure how else you can compare two languages though...
06:49:15 <kmc> concurrency and parallelism are different concepts, and each is sometimes useful without the other
06:49:23 <merijn> Axman6: Do you have a counter example?
06:49:25 <tromp> > let c '0'='1';c '1'='0'; x (h:t) = h:c h:x t; t='0':tail(x t) in t
06:49:26 <lambdabot>   "01101001100101101001011001101001100101100110100101101001100101101001011001...
06:49:55 <brisingr> kmc: so, as far as I understand, the pure, lazy part of haskell doesn't have race conditions
06:49:58 <Axman6> Cale: me either. it seems odd to completely ignore the features of a language that actually make it useful
06:50:12 <merijn> Axman6: Or anything other than just an assertion
06:50:14 <kmc> brisingr, not ones that affect correctness, anyway
06:50:23 <Axman6> i mean, we could do pretty much anything we want with the prelude along, but none of us ever would for anything but the most simple code
06:50:29 <kmc> and assuming you mean roughly what i think you mean by 'pure'
06:50:47 <brisingr> kmc: yes, I think so
06:50:47 <Axman6> merijn: it's quite possibly to write deadlock free code...
06:50:55 <Cale> armido: What are you really asking about? Perhaps people will be able to help more if we knew what sort of differences you're looking for.
06:51:04 <Axman6> it's also possible to write provably deadlock free code
06:51:11 <brisingr> hmm switching to wireless, may go dead
06:51:16 <armido>  arrays, ADTs, objects ETC
06:51:21 <kmc> benmachine, trolls waste time and they contribute to burn-out of helpful people
06:51:21 <merijn> Axman6: Deadlocks are hardly the only races...
06:51:30 <Cale> armido: There's basically a large number of differences, and the whole approach you'll take when writing a Haskell program is quite different.
06:51:34 <benmachine> kmc: sure, but they do that even if you tell them they're trolls
06:51:41 <kmc> but they don't if you ban them
06:51:47 <Cale> armido: Haskell has many array libraries.
06:51:50 <benmachine> sure, so do that if you can
06:51:57 <benmachine> if you can't then don't stress about it
06:52:02 <benmachine> people get burnt out fighting them
06:52:04 <benmachine> the solution is don't fight
06:52:05 <armido> Cale: what are the names, so I can look them up
06:52:09 <Axman6> merijn: well, you can also always write a program that can avoid race conditions, again provably so. Ada is a language well worth look at to see some very powerful ways to do that
06:52:15 <merijn> kmc: I think his point is "ban or don't, but don't bother calling them out"
06:52:18 <kmc> benmachine, it's true both of actual deliberate trolls and of people who are simply annoying and repeatedly ask impossible questions, even if their goal is not to annoy
06:52:21 <kmc> well i can't ban anyone ;P
06:52:23 <mornfall> Can I have an existentially quantified type instance?
06:52:25 <Cale> armido: There are distinctions between boxed arrays (which can hold values of any type), and unboxed arrays (which can only hold values of uniform size, but are compact in memory)
06:52:40 <Cale> and between mutable arrays and immutable arrays
06:52:51 <armido> Cale: yes I'm learnt about this I think
06:52:55 <Cale> Look in Data.Array.IArray and Data.Array.MArray
06:52:58 <merijn> Axman6: Sure, but the matter was not that it is possible to write something without races. It may or not be, my point was that non-deterministic concurrency is all you need to make races possible
06:52:59 <benmachine> merijn: pretty much. also if annoying trolls is your sort of thing then being nice to them is a much better way to achieve that :P
06:53:02 <armido> I read Learn You a Haskell already.
06:53:03 <Cale> and surrounding libraries
06:53:11 <Cale> also, look up the 'vector' package on Hackage
06:53:13 <kmc> i can only suggest changes in policies
06:53:22 <kmc> mornfall, you can make a data instance with an existential field
06:53:27 <Axman6> merijn: sure, i'd agree with that
06:53:27 <kmc> you can't do it with a type synonym instance
06:53:33 <merijn> Axman6: Which I'm not convinced is true, but I don't see how you can prevent races in a non-deterministic scenario
06:53:33 <mornfall> kmc: :((
06:53:44 <Axman6> but non-deterministic concurrenct =/=> races
06:53:45 <armido> Cale: does haskell have something similar to Javadoc online documentation?
06:53:50 <kmc> mornfall, you can't do it in a normal type synonym, either
06:53:55 <Cale> which makes use of a technique called stream fusion for compile-time rewriting of operations on arrays so that they can be done in a single pass
06:53:57 <ion> tromp: I like it.
06:53:59 <kmc> armido, Haddock
06:54:02 <Cale> armido: Haddock
06:54:04 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
06:54:11 <armido> kmc: thank you
06:54:18 <Cale> see also: http://hackage.haskell.org/packages/archive/pkg-list.html
06:54:19 <Axman6> you're comparing... documentation?
06:54:22 <ion> armido: Haddock
06:54:23 <merijn> Axman6: I was just generalizing from non-deterministic concurrency + Murphy's law/programmer fallibility :)
06:54:24 <tromp> that's the Thue Morse seq
06:54:27 <Axman6> god, i never want to read this thesis, sorry
06:54:29 <kmc> documentation matters a lot
06:54:31 <Cale> http://hackage.haskell.org/package/vector
06:54:32 <armido> Axman6: If I was an admin, I'd ban you!
06:54:34 <mornfall> kmc: Hm, when will it break with a normal synonym?
06:54:42 <kmc> maybe this is a software engineering thesis and not a computer science thesis
06:54:48 <kmc> mornfall, maybe i don't understand
06:54:54 <merijn> kmc: I didn't hear the word UML yet
06:54:55 <armido> kmc: compsci
06:54:55 <brisingr> adventures in nonetworkland
06:54:59 <kmc> also, i assumed you meant GHC, sorry
06:55:02 <Cale> http://hackage.haskell.org/package/repa
06:55:11 <Axman6> armido: you shouldn't be so defensive about your work, especially something as large as a thesis. you should be able to defend critisism
06:55:16 <kmc> GHC doesn't have existential quantification as a first-class member of the language of types
06:55:30 <kmc> you can only existentially quantify when introducing a new data constructor
06:55:37 <kmc> and so type synonyms by themselves can't do it
06:55:38 <mornfall> kmc: type Foo a = forall x. x a
06:55:40 <armido> Axman6: If people defend critisicm, the Eifel Tower wouldn't have been complete
06:55:42 <mornfall> kmc: Is accepted...
06:55:43 <Cale> Repa is a library of high-performance parallel operations on multi-dimensional arrays.
06:55:44 <Axman6> and, the equivalent of "I don't like you" is not a defence
06:55:49 <mornfall> kmc: But I can't partially apply Foo.
06:55:51 <kmc> mornfall, yes, but it's not an existential
06:55:52 <merijn> @where ops
06:55:52 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
06:56:02 <copumpkin> yes?
06:56:04 <Cale> All the operations are automatically parallelised
06:56:07 <kmc> mornfall, i think it just stands for the naive expansion
06:56:21 <Axman6> copumpkin: see armido
06:56:26 <kmc> «Foo S -> Foo T» becomes «(forall x. x S) -> (forall x. x T)»
06:56:37 <kmc> which is a type with rank-2 universal quantification
06:56:42 <kmc> but no existential quantification
06:56:47 <merijn> copumpkin: I was just wondering if someone was keeping an eye out on armido, since I'm growing sort of bored with the rude attitude and trolling
06:56:56 <copumpkin> sure :)
06:56:56 <brisingr> armido: if you ignore haskell's purely functional, lazy part is like comparing Java to Haskell's IO system
06:57:09 <Axman6> armido: if you're doing a thesis for a univerity, you will be required to defend it before it's accepted, so i'm confused why you're so tetchy about any critisism from people who don't actually matter
06:57:12 <Cale> There's also something being worked on called Data Parallel Haskell, which will give another parallel array type with non-uniform (nested-tree-like) operations on parallel arrays.
06:57:23 * brisingr has made an extremely weird grammar error
06:57:29 * copumpkin bans brisingr 
06:57:33 <kmc> snap
06:57:33 <armido> The IO systems of the languages is one of my major comparisons
06:57:43 <kmc> is this a PhD thesis?
06:57:45 <mornfall> kmc: Which probably works because synonyms can't be partially applied. Duh. :)
06:57:49 <kmc> or something smaller
06:57:53 <kmc> mornfall, *nod*
06:57:56 <copumpkin> armido: what do you mean by IO system? most languages don't have a notion of an IO system
06:57:57 <brisingr> armido, yes, but it's like comparing haskell IO to the whole java language
06:57:59 <Axman6> brisingr: you accidently a word!
06:57:59 <armido> Axman6: Look, you've provide me no help whatsoever this whole entire time
06:58:08 * ion bans ion. His attitude sucks.
06:58:13 * copumpkin does too
06:58:18 <armido> kmc: phd
06:58:39 <mornfall> Sometimes, I really hate Haskell. You get to choose two dozen approaches, none of which does what you want. :P
06:58:43 <lispy> Guys, don't break the ban hammer!
06:58:44 <brisingr> armido: you might want to put apart 2 weeks and just race through "learn you a haskell"
06:58:53 <Axman6> armido: i've tried to, by telling you that trying to compare something you know next to nothing about is a very strange thing to do. i would have thought that writing a thesis that discusses haskell at length would require you knowing some haskell.
06:58:57 <armido> mornfall: I'm seeing this as both pro and con right now :P
06:59:00 <Cale> armido: In that case, you're probably best off just learning Haskell more completely, because you probably have enough time available to learn lots of it :)
06:59:01 <merijn> Man, I feel I wasted 9 months on my master thesis now >.>
06:59:11 <Axman6> armido: we're more than happy to help you learn the language, really :)
06:59:17 <kmc> merijn, yeah, you could have been trolling on IRC the whole time!
06:59:22 <mornfall> But it was the same with C++ templates, really.
06:59:24 <merijn> kmc: I was, but still!
06:59:30 <Axman6> armido: but it takes experience with languages to be able to write a well thoughtout discussion on their differences
06:59:35 <armido> brisingr: I already finish reading Learn you a Haskell
06:59:36 * mux ponders writing a thesis some day
06:59:46 <mux> look, ma, no diploma!
06:59:52 * copumpkin bans mux
06:59:56 <armido> Didn't understnad the drawings crudeness though
07:00:02 <copumpkin> you need to have a Ph.D. in category theory to hang out in here
07:00:08 * mux thinks he should have probably stayed silent
07:00:09 * mornfall co-bans copumpkin 
07:00:13 <merijn> mux: Yeah, but you're smart. You don't need papers when you're smart
07:00:20 <armido> Axman6: you couldn't get experience in anything
07:00:21 <Cale> With a couple years, you can become a really competent Haskell programmer.
07:00:24 <Axman6> anyone can write "Java is an object oriented, imperative language, Haskell is a purely functional, strongly typed, non-strict language" but that doesn't tell you much at all
07:00:30 <brisingr> look,
07:00:47 <brisingr> 6 beers and someone who knows category theory are prerequisites to learning haskell
07:00:53 <merijn> mornfall: Is that when you invite someone into a channel?
07:00:54 <Cale> lol
07:00:57 <mux> Cale: it took me significantly longer to feel like I can actually manage projects of some size in Haskell (I'd say 3-4 years)
07:01:02 <mornfall> Oops. :-)
07:01:09 <mux> but maybe that's because I'm getting old :-P
07:01:13 <armido> Axman6: That's not any where close to what I have write
07:01:16 <armido> already 30 000
07:01:18 <Cale> mux: Perhaps. I was thrown into a large project at that point in my development and managed :)
07:01:24 <kmc> brisingr, are the beers to drink or to bribe the CT expert?
07:01:25 <merijn> I call myself a haskell programmer and then just write all my production code in C or python >.>
07:01:32 <brisingr> to bribe the CT expert
07:01:36 <erus`> kmc: i feel like i should use polymorphism to describe my object in my game world
07:01:39 <brisingr> now really, that's what I did
07:01:43 <lispy> merijn: heh
07:01:47 <brisingr> it took him 5 whole hours of explaining
07:01:50 <Axman6> armido: sure, it was just an example. i'm just suggesting you learn more about the language, and it will make our job helping you a lot easier
07:01:57 <hvr> merijn: you obviously know when to use haskell and when not =)
07:02:10 <ion> (mapM_ kickBan <=< nicks <=< channel) "#haskell"
07:02:13 <kmc> the first time i went to Boston Haskell, edwardk tried to explain the Yoneda lemma to everyone over beers afterwards
07:02:22 <armido> Axman6: I would rather not taking your advise to sabotague my thesis
07:02:22 <merijn> hvr: I actually wanted to throw out the C codebase and write it in haskell
07:02:24 <mux> kmc: hahaha, that sounds fun
07:02:30 <merijn> My supervisor wouldn't allow it >.>
07:02:30 <erus`> maybe i should just write my own code to inherit properties
07:02:32 <mux> I should come by some day
07:02:37 <kmc> it's fun
07:02:40 <zygoloid> ion: phew, your code kickbans you before it gets to me :)
07:02:43 <hvr> merijn: it's easier to ask for forgiveness than permission... +)
07:02:45 <Polarina> brisingr: What is the thing with knowing category theory to learn haskell? I don't get it.
07:02:56 <armido> Axman6: I will be presentation of this after finishing
07:02:57 <kmc> Polarina, it's a long-standing myth, is al
07:02:57 <hvr> merijn: especially when it comes to using Haskell =)
07:02:57 <copumpkin> Polarina: it's a running joke
07:02:58 <kmc> people
07:03:03 <Axman6> armido: how on earth could you learning more about the topic of your thesis make it any worse? that's rediculous
07:03:03 <armido> Polarina: me as well!
07:03:05 <mornfall> I totally forgot Yoneda lemma. We had it in class though. I more like obliterated all CT from my brain.
07:03:07 <copumpkin> Polarina: I repeat it to mock people who actually think so
07:03:09 <merijn> Polarina: It is something we often refer to as a joke :)
07:03:10 <kmc> people hear the word "monad" and think they need to know the CT definition of it
07:03:25 <kmc> funnily enough nobody hears "singleton pattern" and runs out to learn axiomatic set theory
07:03:28 <Polarina> kmc, copumpkin, armido, merijn: Oh, I see. Thanks.
07:03:32 <mux> isn't a monad a strong endofunctor in a lax monoidal setting?
07:03:37 <brisingr> kmc: well, I found it somewhat useful
07:03:41 <merijn> kmc: I just know that monads are comonads and vice versa
07:03:41 <kmc> i'm just a simple Pole in a complex plane
07:03:50 <kmc> merijn, they are? ;P
07:03:50 <mux> or whatever. some day I'll remember the whole CT definition to scare newbies away
07:03:52 <armido> Anyone use xmonad?
07:03:55 <copumpkin> they are!
07:04:02 <kmc> brisingr, useful maybe; cool definitely, but not necessary
07:04:03 <brisingr> armido: I am
07:04:05 <kmc> that's my take
07:04:09 <Axman6> armido: what's the title of your thesis by the way?
07:04:11 <kmc> from knowing just a tiny bit of CT
07:04:20 <hvr> merijn: you know, like replacing a c/java code silently w/ Haskell, and leaving it in production for a few months... and only then admit that all code has been running happily on Haskell for some months now in production =)
07:04:21 <Axman6> i've used xmonad in the past
07:04:27 <armido> brisingr: this is what introduce me to Haskell for starters!
07:04:35 <mornfall> Well, people talk about CT and then they refuse to lift IO into a type class. Cowards.
07:04:45 <brisingr> armido: same here
07:04:51 <armido> Axman6: "How to prove Axman6 wrong, a phd" :P
07:04:56 <Axman6> heh
07:05:04 <merijn> hvr: One of the other guys working on the codebase would've killed me, because he doesn't like haskell :p
07:05:05 <zygoloid> there's no need to generalize to CT; a (big-M) Monad is just a monoid in the category of endofunctors on Hask. what's the big deal?
07:05:10 <copumpkin> aren't you aussies supposed to love each other?
07:05:13 <mux> aaah, that was it
07:05:15 <armido> Axman6: No but when I finish I will show you my succesful
07:05:17 * copumpkin demands that armido and Axman6 love each other
07:05:20 <mux> a monoid in the category of endofunctors
07:05:27 * mux repeats that several times in his head
07:05:28 <Axman6> armido is an aussie?
07:05:33 <armido> Yes!
07:05:34 <merijn> mux: I thought it was a burrito?
07:05:37 <Axman6> which uni?
07:05:42 <Axman6> i'm at ANU
07:05:42 <armido> Monash
07:05:45 <hvr> merijn: does he has actual arguments, or is it just because he didn't understand Haskell?
07:05:50 <mornfall> What were the objects in Hask again? :P
07:05:55 <mux> merijn: stop confusing me! :-)
07:05:55 <kmc> mornfall, Haskell types
07:05:57 <Cale> mornfall: types
07:06:03 <copumpkin> ooh, .au university hate now
07:06:07 <copumpkin> START
07:06:15 <armido> I denounce hate
07:06:22 <brisingr> .au university hate end
07:06:24 <hvr> <hateful comment here>
07:06:34 <brisingr> hvr: out of hate bounds
07:06:36 <copumpkin> brisingr: man, that wasn't very exciting :( can you extend it a bit?
07:06:39 <armido> ANU is where an idiot attend though
07:06:44 <Axman6> heh, the only university hate from ANU students is for the University of Canberra, which is the other main uni in Canberra
07:06:45 <merijn> hvr: Not so much, but since he's doing a phd working on programming languages and likes ocaml I assume he has a relatively ok understanding of haskell
07:06:52 <brisingr> .au university force hate begin
07:07:05 <armido> University of Canberra is for scum dog
07:07:12 <Axman6> heh
07:07:17 <Axman6> hey, my girlfriend goes there
07:07:17 <kmc> haha
07:07:24 <erus`> what can i call a Action -> Effect ?
07:07:29 <mornfall> :D
07:07:31 <armido> Axman6: I feeling of sorry for her
07:07:37 <frerich> erus`: A causality?
07:07:42 <mornfall> Axman6 has a girlfriend!
07:07:44 <kmc> erus`, what's an Action and what's an Effect and why are they different types?
07:07:50 <hvr> merijn: ic... I tried to use ocaml some time ago... but got frustrated about all ghc stuff I missed there... together with the seemingly stagnation of the OCaml development
07:07:57 <armido> This is my second phd
07:07:58 <mux> causality is World -> World
07:08:03 <Axman6> nah she knows it's not the best uni out there, but it was the only one that offered what she was after. she;s definitely good enough to be doing law at ANU though
07:08:04 <armido> and I will prove to Axman6 the world of different
07:08:06 <erus`> an action is a verb like 'consume'
07:08:07 <merijn> frerich: Sounds like a finisher in the nerd version of Mortal Kombat based on logic :)
07:08:09 <mornfall> mux: Not again.
07:08:16 <rwbarton> I was thinking something involving causality also
07:08:16 <erus`> an Effect is like 'heal 10hp'
07:08:22 <frerich> merijn: hah!
07:08:24 <Axman6> armido: you'll prove to me that it's ok to write a thesis about something you don't know about? :P
07:08:30 <mux> what, you don't enjoy metaphorical discussions about the meaning of the universe applied to functional programming?
07:08:30 <rwbarton> or maybe a rule
07:08:44 <armido> Axman6: You insolent fool! How to come to this assumption?
07:08:52 <mornfall> mux: Nor of functional programming applied to universe.
07:08:56 <merijn> mux: Those are the only worthwhile discussions :p
07:08:56 * hackagebot HarmTrace 0.7 - Harmony Analysis and Retrieval of Music  http://hackage.haskell.org/package/HarmTrace-0.7 (JosePedroMagalhaes)
07:08:56 <Cale> lol "CAUSALITY"
07:08:58 <Iceland_jack> armido: ..
07:09:01 <mux> yeah, and vice-versa.
07:09:02 <Axman6> didn't you say earlier you don't know much about haskell?
07:09:15 <merijn> I should go to -blah :p
07:09:15 <kmc> Axman6, 30,000 words!
07:09:18 <armido> Axman6: No! I would like to know more!
07:09:25 <kmc> 30,000 words guiltied to a zegnatronic rocket society
07:09:36 <brisingr> movie idea #1831 "In an imperative world, we are all casualties of causality... enter Haskell, the one, the only, HASKELL!"
07:09:48 <Iceland_jack> armido: I would also like to know more about physics — that's why I'm not writing a thesis on it
07:09:49 <armido> Axman6: as with most thing I know, but this does not neccaserily in case of not knowing!!!
07:09:50 <Entroacceptor> how did you write 30000 words comparing the documentability of languages without coming across haddock?
07:09:59 <Axman6> armido: i'd think that if you've written 30,000 words, you should be able to say something about ADT's in haskell, and how they are useful/different to what is available in java
07:10:05 <armido> Iceland_jack: shove your thesis up your arse
07:10:12 <dolio> Causality is like a French guy slipping an aphrodisiac in your cake.
07:10:12 <mux> ADT is such an overloaded acronym
07:10:14 <kmc> armido, i love your attitude
07:10:17 <Iceland_jack> armido: :)
07:10:18 <merijn> Are there any European haskell meetups? Half the people are smart enough that I think I might learn something, the other half funny enough to drink beer with :p
07:10:20 <copumpkin> Ph.D. research = troll on IRC
07:10:22 <kmc> can we get a ban already
07:10:23 <copumpkin> why do anything else? :)
07:10:26 <mornfall> Axman6: Is there *any* point at all comparing Java to Haskell or vice versa?
07:10:27 --- mode: ChanServ set +o copumpkin
07:10:29 <hvr> armido: ...cause it's cheaper than toilet paper?
07:10:39 <mux> mornfall: for... SCIENCE!
07:10:50 <Axman6> mornfall: well, that's what armido's thesis PhD is on
07:10:51 <mornfall> mux: Oh. Come. On. :P
07:10:54 <armido> hvr: no cheaper than sex
07:10:57 --- mode: copumpkin set +b armido!*@*
07:10:57 --- kick: armido was kicked by copumpkin (go to #haskell-ops if you want to amend your ways)
07:11:08 --- mode: copumpkin set -o copumpkin
07:11:11 <Botje> co-kickbanned!
07:11:14 <mux> whoa, kickbans in #haskell? /me rubs his eyes
07:11:19 <Axman6> :o
07:11:23 <mornfall> Stuff happens.
07:11:24 <Axman6> did i cause that?
07:11:28 <Entroacceptor> merijn: I'm in Hamburg
07:11:29 <Axman6> I really did want to help :(
07:11:34 <Cale> CAUSALITY
07:11:37 <mux> lol
07:11:40 <mux> Cale++
07:11:41 <Axman6> but... slight trolling is more fun >_>
07:11:45 <brisingr> We are all casualties of causality
07:11:49 <Axman6> Cale: ha
07:11:59 <merijn> Cale: Nice :)
07:12:01 <brisingr> any yearly european haskell meetups?
07:12:02 <kmc> mux, dissing ANU is crossing the line
07:12:04 <kmc> ;)
07:12:08 <blueonyx> hey i still got popcorn left :/
07:12:20 <mornfall> blueonyx: Bring me some...
07:12:37 <mux> kmc: you got me confused here - ANU?
07:12:41 <luite> blueonyx: throw it at copumpkin for spoiling your fun
07:12:46 <ion> blueonyx: We could indulge you by still fighting about something.
07:12:48 <Axman6> dissing ANU's CS department isn't all that bad, we're not really known for it.
07:12:56 <mux> kmc: oh, I think you meant to say that to Axman6
07:13:12 <ion> Gnome 3 is better than all .au universities combined.
07:13:17 <Axman6> world leaders in some other fields though (Asian studies is one, not sure what else)
07:13:20 <erus`> i think skynet will evolve from my AI :D
07:13:25 <kmc> mux, nah, it was just a joke about "this is what it takes to get kickbanned"
07:13:27 <mornfall> ion: Now that's some serious flamebait. :)
07:13:28 <brisingr> ion: never had a chance to use gnome3
07:13:32 <kmc> haha ion
07:13:32 * Axman6 demands kickban for ion!
07:13:36 <brisingr> ion: is it cool with xmonad?
07:13:45 <Axman6> ion: that crossed about 4 lines :P
07:13:48 <ion> brisingr: Me neither. I have no idea.
07:13:51 <mornfall> brisingr: gnome3 is cool with nothing.
07:14:01 <kmc> gnome 3 isn't cool
07:14:06 <kmc> you know what's cool? gnome 3,000
07:14:13 <merijn> Friends don't let friends use gnome
07:14:35 * Axman6 refrains from replacing gnome with linux
07:14:36 <Axman6> >_>
07:14:42 <kmc> i stick to ELF and DWARF thanks
07:14:43 <Axman6> now that's trolling, sorry
07:14:55 <kmc> Axman6, it's GNU/Linux you insensitive clod
07:15:06 <mornfall> kmc: Only bested by BFG10000.
07:15:09 <ion> > fix ("GNU/"++) ++ "Linux"
07:15:11 <lambdabot>   "GNU/GNU/GNU/GNU/GNU/GNU/GNU/GNU/GNU/GNU/GNU/GNU/GNU/GNU/GNU/GNU/GNU/GNU/GN...
07:15:21 <Axman6> > "\GNU"
07:15:22 <lambdabot>   <no location info>:
07:15:22 <lambdabot>      lexical error in string/character literal at chara...
07:15:24 <Axman6> >_>
07:15:49 <mornfall> ion: Your fix broke it.
07:15:58 <Axman6> yeah, i should really say GNU/Linux, i don't really have a problem with the kernel
07:15:59 <kmc> > fix (\x -> "(" ++ x ++ ")'s Not UNIX")
07:16:01 <lambdabot>   "((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((...
07:16:16 <kmc> i have mega problems with the kernel
07:16:39 <mornfall> The kernel stinks. And it's written in C.
07:17:04 <merijn> linux kernel code makes me weep
07:17:05 <dolio> They should write a new kernel in NuPRL.
07:17:11 <hvr> kmc: then use seL4 :-)
07:17:18 * brisingr goes to get some orange juice, brb
07:17:18 <ion> I wonder if RMS would have a similar reaction to “Linux/GNU” as to just “Linux”?
07:17:19 <hvr> or L4.verified
07:17:27 <Axman6> yeah, during my networking course, we were shown quite a bit of linux networking code. i was not impressed
07:17:42 <dolio> Anyhow, we're all going to be using Hurd within the year.
07:17:46 <mornfall> Axman6: I wish I could be not impressed.
07:17:52 <dolio> Now that it got released or something.
07:17:54 <kmc> i diss a piece of software and y'all assume my objection is just that it's not written in Haskell :D
07:17:54 <mornfall> I am rather co-impressed...
07:17:56 <ion> dolio: 2012 is the year of Hurd on the desktop.
07:17:58 <Axman6> dolio: 2012 is the year of the Hurd desktop!
07:18:04 <kmc> omg
07:18:05 <merijn> I was used to FreeBSD/minix code before looking at linux code. That was a sad moment
07:18:17 <mornfall> kmc: I'd write it in C++ anyway.
07:18:21 <kmc> ugh
07:18:23 <merijn> mornfall: Eewww
07:18:41 <kmc> Linux isn't written in C, anyway
07:18:48 <kmc> count the GCC extensions they use
07:18:52 <mornfall> kmc: Doesn't matter.
07:18:56 <Axman6> if you could write a kernel from scratch in any language you want, what would you use? (seriously)
07:19:05 <mornfall> kmc: (It'd only matter if they actually helped.)
07:19:12 <kmc> i can write a kernel from scratch in any language I want
07:19:13 <mornfall> Axman6: C++. :-)
07:19:13 <Axman6> i mean, Haskell is possible, but i don't think i'd choose it
07:19:15 <Ke> C-ish C++
07:19:15 <Polarina> Axman6: Why not haskell?
07:19:21 <merijn> Axman6: The strict haskell variant they're working on at PSU, if it ever works
07:19:33 <kmc> maybe something like ATS
07:19:35 <merijn> Polarina: No raw memory access makes it very unsuitable for OS code
07:19:41 <Axman6> i think Disciple might be interesting
07:19:45 <kmc> hey Haskell has raw memory access
07:19:48 <mornfall> merijn: Since when there's no raw memory access?
07:19:54 <Axman6> ATS could also be interesting
07:19:57 <Polarina> merijn: Doesn't haskell have Ptr in Foreign?
07:20:06 <hvr> kmc: how would you bootstrap the GC?
07:20:11 <merijn> And where does the Ptr come from?
07:20:17 <Axman6> hvr: house managed it
07:20:28 <Axman6> there's also that OS thing Galois released...
07:20:38 <kmc> Axman6, is this "you're implementing a 1970's OS design again for some unholy reason" or "you're doing a cool research project with few real-world constraints?
07:20:40 <Axman6> with the runtime running on the baremetal
07:20:40 <brisingr> I would write a kernell in haskell but alas you need abstract hardware
07:20:41 <kmc> "
07:20:46 <brisingr> *kernel
07:20:58 <kmc> @where house
07:20:58 <lambdabot> http://programatica.cs.pdx.edu/House/
07:20:58 <Axman6> kmc: i'd like to hear answers for both =)
07:21:04 <mornfall> Well, C++ takes you a long way, really.
07:21:12 <mornfall> Axman6: You need to write the runtime in *something*.
07:21:13 <kmc> in the first case i'd quit
07:21:14 <merijn> House seems interesting, so does the new haskell dialect they're working on
07:21:27 <Axman6> Ada wouldn't be a bad choice
07:21:36 <mornfall> Axman6: And writing Haskell runtimes in Haskell only gets you so far.
07:21:37 <kmc> in the second case I'd try to make an OS with strongly typed system calls, file system, etc.
07:21:43 <ion> C++ takes you a long way toward voluntary lobotomy to take the pain away.
07:21:43 <Axman6> mornfall: agreed
07:21:44 <brisingr> merijn: new haskell dialect?
07:21:48 <kmc> maybe have all code on the system running in a single Haskell RTS
07:22:01 <kmc> with as much isolation as possible done at compile / link / load time
07:22:02 <merijn> brisingr: I'd have to look up the paper again
07:22:03 <mornfall> kmc: LISPMACHINE!
07:22:09 <kmc> @google The Reduceron
07:22:10 <lambdabot> http://www.cs.york.ac.uk/fp/reduceron/
07:22:10 <lambdabot> Title: The Reduceron
07:22:16 <brisingr> merijn: don't bother, just curious
07:22:21 <Axman6> the reduceron is very cool
07:22:24 <kmc> oh, yeah, Habit
07:22:30 <merijn> Oh yeah, Habit
07:22:33 <kmc> Habit is a haskell dialect specialized for sys tems programming
07:22:39 <Axman6> @where habit
07:22:40 <lambdabot> I know nothing about habit.
07:22:48 <Axman6> you now narthing!
07:22:51 <merijn> I need to weasel my way into those PhD spots they have open :p
07:22:55 <kmc> i think it's not released :/
07:22:59 <kmc> but there was a Galois talk about it
07:23:12 <kmc> merijn, did you write your 30,000 words yet?
07:23:24 <merijn> kmc: I wrote lots of C, does that count?
07:23:29 <erus`> how can i describe how accurate my knowledge of something is?
07:23:39 <Axman6> @where+ Habit The preliminary Habit report: http://hasp.cs.pdx.edu/habit-report-Nov2010.pdf
07:23:40 <merijn> erus`: In an AI sense?
07:23:40 <lambdabot> I will remember.
07:23:47 <erus`> merijn: yeah
07:23:52 <mornfall> merijn: It counts. In the negative. :P
07:23:56 <merijn> erus`: Read up on "fuzzy logic"
07:24:01 <kmc> erus`, make a prediction, compute the error?
07:24:10 <erus`> Certain | Possible Float | Unknown
07:24:20 <Axman6> Float? D:
07:24:27 <erus`> Certain x | Possible Float x | Unknown
07:24:28 <Axman6> Y U NO DOUBLE?
07:24:47 <erus`> Double is too many instructions :P
07:24:48 <merijn> mornfall: Naah, it counts as positive. Proves I'm capable of doing annoying but necessary coding that no one else wants to do ;)
07:24:55 <Axman6> erus`: eh?
07:25:02 <ion> False | True | FileNotFound
07:25:16 <kmc> Haskell's Bool is already  False | True | FileNotFound
07:25:20 <Axman6> doubles are exactly the same speed as floats on modern hardware...
07:25:29 <erus`> why do people use Floats?
07:25:34 <mm_freak> doubles are probably faster than floats
07:25:35 <Axman6> they don't
07:25:40 <kmc> floats take less memory
07:25:43 <kmc> by which i mean data cache
07:26:03 <Axman6> yeah, the only situation where using floats is useful is when you have large data
07:26:03 <mm_freak> floats are used, where you deal with lots and lots of data
07:26:08 <erus`> ok I'm a convert
07:26:08 <kmc> :t fmap (read :: String -> Bool) . readFile
07:26:09 <lambdabot> FilePath -> IO Bool
07:26:22 <merijn> kmc: "data Bean = Paula"? :D
07:26:24 <mornfall> merijn: Oh, *that* kind of PhD. :P
07:26:24 <kmc> here's a very real example of False | True | FileNotFound
07:26:39 <ion> Imma convert floats to doubles
07:26:48 <Ke> the last I tested the speed was 8:9 for floats on my cpu, but some memory access patterns might favour the smaller size of floats
07:26:54 <Axman6> erus`: doubles used to be slower, but these days, pretty much everything (on intel CPU's anyway) is done using 80 bit floating point numbers internally anyway
07:27:11 <kmc> "these days"?  that's a quirk of the original x87, i thought
07:27:16 <erus`> 80 bits! thats nearly 128
07:27:18 <mm_freak> it is
07:27:22 <kmc> these days 64-bit x86 will use SSE for floating point
07:27:25 <mux> the fact that you can fit more floats than doubles in a cache line remains though
07:27:26 <mm_freak> the x87 started the 80 bit story
07:27:34 <Ke> on gpu the difference might be 1:4
07:27:36 <mm_freak> the 287, i think
07:27:46 <merijn> Hah, in a year we will all be running Barrelfish and floats will be outsourced to the GPGPU
07:27:52 <Axman6> mux: indeed
07:28:03 <Axman6> but you have to be using packed data for that to matter anyway
07:28:16 <mux> in a few more (dozens?) years the distinction between CPU and GPU is probably going to fade away
07:28:23 <Axman6> which you don't get when you have an ADT with construtor Foo Double
07:28:37 <Axman6> mux: not that long i'd bet
07:28:37 <merijn> mux: Are you aware of Barrelfish? It's quite intriguing
07:28:38 <mux> here we are with our N-core GPUs and M-core CPUs, that look more and more alike
07:28:43 <mux> I'm not, what is it?
07:28:56 <Axman6> Ke: yeah, on GPU's floats are currently a lot faster
07:29:18 <mux> I have to find something fun and interesting to code that would make good use of OpenCL or CUDA.
07:29:25 <Axman6> http://www.barrelfish.org/
07:29:28 <merijn> mux: Research OS developed in Zurich together with MS. The idea is to design an OS capable of managing a system of heterogeneous computing resources
07:29:32 <Axman6> i think i read about that a while ago...
07:30:17 <mux> merijn: sounds interesting
07:30:18 <merijn> The idea is that GPUs and CPUs will not look more and more alike, but the OS will be able to deal with it
07:30:24 <ion> Aren’t some manufacturers putting them on the same chip already? Or is that just discrete chips in a single package?
07:30:26 <erus`> merijn: data Fuzzy = Certain a | Possible Double a | Unknown
07:30:44 <erus`> whats a good name for Fuzzy then? i cant find it in the wiki article
07:31:02 <ion> Isn’t Certain a the same as Possible 1.0 a?
07:31:07 <mux> data QuantumBool = Alive | Dead | Both
07:31:12 <merijn> CPUs diversifying also seems to be something Intel is convinced of
07:31:27 <ion> I point to Schrödinger’s living cat and I point to Schrödinger’s dead cat. That is all.
07:31:34 <erus`> ion: yeah but i think it will make pattern matching nicer
07:31:37 <Entroacceptor> mux: you forgot "Bloody Angry"
07:31:49 <kmc> haha
07:31:59 <mux> Entroacceptor: I write this one as "undefined" :-)
07:32:00 <kmc> angry cat covered in radioactive liquid
07:32:00 <Axman6> do we have a good type in haskell to represent probabilities? something with a range of 0..1
07:32:24 <Eliel> I fully expect future motherboards to have a cheap low-power processor integrated with some expansion slots (could even be pci-express) for extra processor boards :)
07:32:24 <kmc> Axman6, there's a type somewhere with logarithmic representation
07:32:32 <kmc> for tiny probabilities
07:32:44 <merijn> mux: That type makes me think of paraconsistent logic and by extension makes me think of:
07:32:45 <merijn> @quote paraconsistent
07:32:46 <lambdabot> edwardk says: the gf obeys a paraconsistent logic, so given a contradiction you can't actually go an really prove everything like you can in classical logic, which always makes it hard to refute a
07:32:46 <lambdabot> claim via contradiction.
07:32:47 <Axman6> i think the whole schrodinger experiemtn is retarded. you'd know the cat's alive or dead, it'd be bitching its head off complaining
07:32:57 <ion> I heard there’s also a type somewhere with a sign, a mantissa and an exponent.
07:32:59 <erus`> @src Maybe
07:32:59 <lambdabot> data Maybe a = Nothing | Just a
07:33:14 <Entroacceptor> Axman6: you're obviously not a physicist
07:33:19 <Axman6> there's a nice fixed point library somewhere
07:33:24 <Axman6> Entroacceptor: no, i'm a cat owner :P
07:33:44 <merijn> Axman6: Hearing meowing means you're perceiving the cat so the experiment is already ruined then
07:33:49 <ion> You’re obviously not a cat owner. If you were you would know you’re owned by a cat.
07:33:49 <kmc> obviously you're not a golfer
07:33:59 <Axman6> merijn: which is why the experiment is silly :P
07:34:08 <mux> that reminds me of the OneOrBoth datatype I needed some day: data OneOrBoth a b = First a | Second b | Both a b
07:34:10 <merijn> Silly != incorruect
07:34:18 <merijn> @quit Neither
07:34:18 <lambdabot> Not enough privileges
07:34:21 <merijn> @quote Neither
07:34:22 <lambdabot> Baughn says: Those who would give up essential laziness for a little ephemeral performance, deserve neither laziness nor performance.
07:34:27 <merijn> bollocks
07:34:33 <mux> when you really need this, it makes the code a LOT clearer than some ugly combination of Maybe's or Either
07:34:34 <Axman6> ion: i'm the only one in the house who isn't. everyone else lets him get away with murder -_-
07:34:35 <merijn> Not the one I was looking for
07:34:41 <merijn> @quote Neither.a.b
07:34:41 <lambdabot> Berengal says: data Neither a b = Left | Right
07:34:47 <Entroacceptor> lol
07:34:50 <merijn> That one always cracks me up :)
07:34:53 <ion> hah
07:35:01 <Axman6> ha
07:35:46 * mux thanks #haskell for preventing his death by boredom at work today
07:35:51 <Entroacceptor> same here
07:35:52 <Axman6> going back to the kernel talk, i've decided that if i wrote a kernel, it would be in Ada
07:35:54 <mauke> preflex: quote
07:35:57 <Entroacceptor> except that I should've worked more
07:36:00 <preflex>  <khisanth> hmm if it actually makes searching for 'muppet rape' work that would be nice
07:36:14 <mauke> preflex: inappropriate!
07:36:15 <Axman6> i've never seen anything with as much control and easy of use over the hardware (not even C)
07:36:16 <ion> @google muppet rape
07:36:17 <lambdabot> http://www.metafilter.com/50559/Because-puppet-rape-actually-is-funny
07:36:17 <lambdabot> Title: Because puppet rape actually is funny | MetaFilter
07:41:21 <brisingr> @botsnack
07:41:21 <lambdabot> :)
07:42:29 <erus`> is there any docs on modeling a world so its easy for AI to understand it?
07:43:17 <Entroacceptor> the internet!
07:43:40 <kmc> erus`, that's a whole academic discipline that has existed for at least 50 years
07:44:02 <Entroacceptor> (even more OT: I've played a RPG character once, which was an AI that learned about humans from the internet and went genocidal after that)
07:44:50 <erus`> well at the moment i just have objects that are lists of properties and actions that transform objects
07:45:06 <erus`> i dont know if im barking up the wrong tree
07:45:26 <kmc> do you know how you're going to implement this AI?
07:45:48 <brisingr> what is its main purpose? you might want to use only relevant stuff
07:45:54 <erus`> yeah like a gametree throught actions
07:47:00 <brisingr> how about making an AI with several components
07:47:15 <brisingr> one that processes objects ant categorizes them
07:47:17 <brisingr> *and
07:47:23 <brisingr> one that assigns them priority
07:47:59 <brisingr> so you want only relevant info in your objects
07:48:08 <brisingr> and objects that are as general as possible
07:48:19 <brisingr> e.g. a room instead of the objects within it
07:48:27 <brisingr> and state as a property of the room
07:48:52 <merijn> A nice thing to read up on might be "Overmind" it was a StarCraft AI made at Berkely to compete in a big StarCraft AI tournament
07:48:56 * hackagebot language-c 0.4.1 - Analysis and generation of C code  http://hackage.haskell.org/package/language-c-0.4.1 (BenediktHuber)
07:49:00 <merijn> A nice write up is here: http://arstechnica.com/gaming/news/2011/01/skynet-meets-the-swarm-how-the-berkeley-overmind-won-the-2010-starcraft-ai-competition.ars/
07:49:11 <brisingr> you want to use as big chunks of data as possible
07:49:16 <merijn> And if you google you can find their website and publications
07:49:30 <brisingr> and only model desired state delving deeper into the details
07:49:58 <brisingr> you want a "neat room" not "object 1 is over there object 2 is that way"
07:50:11 <brisingr> just stating the (more or less) obvious
07:50:39 <erus`> brisingr: i have a Perceived.Object type that has 'fuzzy' properties
07:50:58 <brisingr> that's good
07:50:59 <erus`> and a World.Object that is the real thing
07:51:17 <brisingr> perfect, I think
07:51:18 <erus`> and yes i am gonna make a room of objects
07:51:42 <erus`> then i can just walk the tree of actions on my room right?
07:52:05 <brisingr> I suppose so
07:52:20 <brisingr> you might want to make intermediate object groups to handle them more easily
07:53:01 <brisingr> you may or may not want to group them according to location or properties
07:53:12 <brisingr> or purpose
07:53:52 <brisingr> say group all objects which can combine
07:54:23 <brisingr> but you'll probably do that anyway, by using types
07:54:40 <brisingr> I'm just rambling here
08:04:02 <myszek123> ok, so i'm bit new to xmonad and need some help with  thunderbird and gnome-panel
08:04:18 <mornfall> Wrong channel. :) Try #xmonad.
08:04:43 <myszek123> fair enough ;)
08:08:04 <mornfall> Hm. Imagine I have two (Monad m) => X m, (Monad m) => Y m type classes, and I want to express things (monads) that are at least one of them, and maybe both...
08:08:15 <mornfall> Any ideas? :)
08:08:33 <opqdonut> answer: you shouldn't use type classes for that
08:08:38 <mornfall> But?
08:08:43 <mornfall> Explicit dictionaries?
08:08:53 <mornfall> (I was thinking about that, too.)
08:08:53 <opqdonut> maybe, yeah
08:09:52 <mornfall> The question then becomes: how do I avoid passing the dictionaries around all the time. (Maybe hide *those* in a common type class?)
08:10:03 <opqdonut> you could do something like "newtype XX a = XX a; newtype YY a = YY a; instance (X m) => XorY (XX m); instance (Y m) => XorT (YY m)"
08:10:35 <opqdonut> or constrain the constructors XX and YY. but this might be a painful solution as type classes aren't inferred very well
08:12:10 <opqdonut> I'm guessing there is a niceish type family solution too... :)
08:12:14 <mornfall> (The idea is that both the bottom and the top of the stack share a dictionary, but the middle shouldn't need to know about it.)
08:12:51 <mornfall> (And there are two different *types* of dictionaries.)
08:13:17 <mornfall> Hm.
08:13:20 <opqdonut> (Yeah, of course the dictionarys would be "data X m = X {f :: m a ...}"
08:13:22 <efie> merijn: i tried to use your newTransmit method http://codepad.org/3vPf2S5Y did i do something wrong?
08:13:33 <rwbarton> what do you do with something that's "at least one of them and maybe both"
08:14:21 <mornfall> rwbarton: Apply patches in it. :-)
08:14:53 <mornfall> And depending on the domain of the patches, the something is something different.
08:15:03 <mornfall> (The domain being the dictionary, more or less.)
08:16:25 <mornfall> Although it's true that the "both" thing has rather limited use.
08:17:04 <mornfall> So maybe I could dispense with that. Would buy a nice functional dependency that probably fixes a lot of pain...
08:17:11 <merijn> efie: That should work
08:17:18 <mornfall> i
08:19:40 <Cale> mornfall: What would you do with the information that t is a type which is in at least one of those two typeclasses, but you don't know which? It's not valid to use any of the methods of either of the classes if that's all you know.
08:20:20 <efie> its strange. i enter something, but nothing then happens (i cant enter anything then)
08:20:34 <merijn> efie: Even when you hit enter nothing happens?
08:20:53 <efie> yes
08:21:09 <merijn> heh
08:21:12 <Cale> newTransmit is taking forever to complete then?
08:21:55 <merijn> efie: Can you pastebin the channel_2 code? I would assume that is where its going wrong
08:22:07 <efie> sure :)
08:22:49 <mornfall> Cale: Yeah, I guess so. What I had until recently (which broke down for somewhat unrelated reasons) was a type class that had methods constrained on one of the type parameters of the class. Like, C x y where foo :: (x ~ T1) => ... and bar :: (x ~ T2) => ... now that worked pretty well.
08:23:44 <mornfall> Cale: There are intermediate types that only propagate T1/T2 but otherwise don't care about them. You can only instantiate them with the correct set of parameters and everything works.
08:24:15 <Cale> huh, what are you trying to do?
08:24:53 <efie> http://pastebin.com/GW03gbSC
08:24:56 <mauke> The paste GW03gbSC has been copied to http://hpaste.org/50401
08:25:18 <mornfall> class X p where type T1or2 p; x :: C (T1or2 p) ble => something with ble
08:25:41 <tromp> :t foldl
08:25:42 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:25:45 <tromp> :t foldr
08:25:45 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:25:50 <Cale> mornfall: I mean, more generally
08:26:05 <Cale> What sort of library are you writing?
08:26:13 <mornfall> Cale: I am hacking darcs. :-)
08:26:33 <mornfall> This problem pertains to applying patches.
08:26:46 <merijn> efie: I don't see anything particularly odd, but I'm not sure how to debug the issue
08:27:03 <mornfall> The "classic" patches apply to a filesystem. A new set of "primitive" patches apply to a more abstract thing (a UUID -> Object map).
08:27:39 <mornfall> Now there are types of patches that are composite, made of some primitive patches. These composites are always applied in terms of their constituents, so their application is actually independent of what the primitives apply to.
08:28:15 <mornfall> But the "toplevel" needs to provide the state the primitives apply to, and call the right instantiations of the composites.
08:28:34 <Cale> Okay, and where do typeclasses come in?
08:28:42 <Cale> I see a class Apply p where ...
08:28:46 <mornfall> Cale: The type class describes what an applying patch can do.
08:28:54 <mornfall> As in, create file, edit file, etc.
08:29:14 <mornfall> The patches are applied to different kinds of things with a common interface (not always a filesystem).
08:29:52 <mornfall> I could always provide both sets of methods, and fail at runtime. But that sucks.
08:30:33 <Cale> Which classes, sorry?
08:30:58 <Cale> I'm not very familiar with Darcs' internal structure, but I have the documentation open :)
08:31:07 <mornfall> :-) Not entirely sure that'll help.
08:31:10 <mornfall> But I have
08:31:30 <mornfall> class TreeApply m and class OMApply m.
08:31:42 <Cale> hmm
08:32:02 <mornfall> Then there's class ApplyMonad m state, and class Apply p where type ApplyState p correlates with the second ApplyMonad parameter.
08:32:09 <Cale> okay, and those actually aren't in the Darcs code yet :)
08:32:19 <Cale> I see Apply, anyway
08:32:27 <mornfall> Well, if you look at http://darcs.net/screened
08:32:32 <mornfall> you can see my previous version.
08:32:35 <mornfall> Which works.
08:32:42 <mornfall> Kindof.
08:33:01 <mornfall> In Darcs.Patch.ApplyMonad and Darcs.Patch.Apply (inside src)
08:33:41 <mornfall> TreeApply and OMApply came around from splitting ApplyMonad into 3 pieces.
08:34:01 <mornfall> Well, it's pretty much a mess now. :|
08:34:27 <mornfall> I can figure out a good way to express these things.
08:35:29 <mornfall> So I suppose what I want is a class of Monads that can provide a dictionary that apply can fetch and use.
08:37:01 <Cale> Whaaaat.  forall p m C(x y). ...
08:37:26 <mornfall> Cale: Well, C is a CPP macro that hides x y from compiler sometimes. Sorry...
08:37:36 <mornfall> Cale: (x and y are witnesses... we get rid of that macro real soon now...)
08:37:55 <Cale> interesting
08:39:47 <Cale> It's often the case that when you run into problems expressing yourself with typeclasses, what you really want is a record type with the methods of your would-be typeclass.
08:40:07 <mornfall> Yeah. I'll try to explore that avenue for a while.
08:41:37 <Cale> For example, it solves the problem you were talking about earlier with having one or another instance available, because you can use case then.
08:41:46 <Cale> (and Either, or some other sum type)
08:43:07 <Cale> Which two classes were those, anyway?
08:44:44 <mornfall> Cale: They don't exist yet (if you look at ApplyMonad, it conflates both into a single one).
08:44:54 <ricree> any idea where I can figure out what's the most recent version of haskell that can run under glibc 2.5?  I'm trying to get haskell up and running on a shared host, and it's yelling at me for not having glibc 2.9
08:45:32 <mornfall> Cale: http://darcs.net/screened/src/Darcs/Patch/ApplyMonad.hs
08:46:38 <Cale> aha
08:46:49 <Cale> So what you really want is probably just a couple of record types
08:47:27 <Cale> or... three of them
08:49:56 <efie> merijn: i think it can be excluded, that your newTrasmit is wrong; i tried this http://codepad.org/y87dgtZz and its the same result, i think the mistake is in the channel_2 function
08:56:43 <Cale> mornfall: It may result in a bit more parameter passing that way, but it tends to work out for the best.
09:00:49 <frerich_> Hm, my experiment of using Haddock on the sources in the project reache a dimension at which I may just as well transition to a literal haskell program.
09:11:19 <efie> http://codepad.org/raOsBxPx this does not work, how it is correct?
09:11:55 <kmc> how does it fail?
09:12:09 <benmachine> efie: if you enter 1,2 then read will not parse it
09:12:14 <benmachine> because read expects the [1,2] format
09:13:44 <efie> okay
09:14:26 <efie> kmc: it says "no parse"
09:16:29 <Axman6> efie: are you entering [1,2] on the command line?
09:16:53 <efie> i entered 1,2; it works with [1,2]!
09:17:51 <Axman6> of course
09:18:03 <Axman6> > read "1,2" :: [Int]
09:18:04 <lambdabot>   *Exception: Prelude.read: no parse
09:18:08 <Axman6> > read "[1,2]" :: [Int]
09:18:09 <lambdabot>   [1,2]
09:18:18 <ricree> Has anyone run into the "utils/ghc-pwd/ghc-pwd: No such file or directory" error when building ghc?
09:19:49 <benmachine> ricree: I vaguely remember doing so a long time ago
09:20:14 <brisingr> efie: use let ints = read ("[" ++ toBeSent ++ "]") :: [Int]
09:20:40 <brisingr> ugly hack but functional
09:20:43 <efie> ah, thats nice :)
09:20:45 <efie> yeah
09:20:51 <brisingr> no prob :)
09:21:11 <Axman6> it's not nice, but it works :P
09:21:17 <efie> :D
09:21:54 <ricree> I'm trying to get it up and running on a shared host, so more user friendly means of installation seem out of the picture.  the 6.8.3 binaries seem to work, so maybe I'll just stick with that
09:22:22 <ricree> how do I figure out what version of the platform would work with that ghc?
09:22:28 <roconnor> brisingr++
09:22:31 <roconnor> brisingr: that is cute
09:22:46 <benmachine> ricree: 6.8.3 is hecka old by now
09:23:03 * benmachine wonders if this is correct usage of the "hecka" modifier
09:23:19 <benmachine> ricree: seriously like four major versions old
09:23:36 <ricree> benmachine, yeah, but the newer binaries don't really work on it.  So the idea was to use it to bootstrap newer versions
09:23:45 <benmachine> hmm
09:24:17 <ricree> This blog post: http://sheyll.blogspot.com/2010/05/installing-haskell-prime-on-cent-os-54.html seems to go through what I'm looking to do, but I'm running into that error on ./configure, and my google-fu is failing me
09:25:13 <tromp> :t unfold
09:25:14 <lambdabot> Not in scope: `unfold'
09:25:16 <tromp> :t unfoldl
09:25:17 <lambdabot> Not in scope: `unfoldl'
09:25:19 <tromp> :t unfoldr
09:25:20 <efie> i get another "parse error on input `<-'" when i try ints2 <- shuffle ints whereas shuffle :: [a] -> IO [a] and ints :: [Int]
09:25:20 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:25:30 <benmachine> ricree: go and have a look at utils/ghc-pwd and see if you can work out why it failed
09:25:48 <benmachine> efie: possibly your indentation is wrong, can we see the code?
09:26:13 <Axman6> efie: of course, that translates into the code: shuffle ints >>= \ints2 ->
09:27:06 <efie> benmachine : http://codepad.org/WcrW4ZP7
09:27:25 <Axman6> you've indented that line too far
09:27:41 <tromp> :t divMod
09:27:41 <efie> axman6: umm i am not really aware of this >>= thing yet
09:27:41 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
09:27:43 <Axman6> you've used a tab. don't do that
09:28:06 <efie> ah ok
09:28:08 <efie> its fine now
09:28:09 <efie> ok
09:28:11 <efie> :/
09:28:21 <Axman6> you should change your editor to insert spaces instead of tabs
09:28:40 <roconnor> ghc needs a flag making tabs an error
09:28:59 <tromp> > -3 `divMod` 5
09:28:59 <lambdabot>   (0,-3)
09:29:04 <tromp> > -3 `quoteRem` 5
09:29:05 <lambdabot>   Not in scope: `quoteRem'
09:29:10 <tromp> > -3 `quotRem` 5
09:29:11 <lambdabot>   (0,-3)
09:29:36 <tromp> both broken:(
09:29:46 <roconnor> > (-3) `divMod` 5
09:29:47 <lambdabot>   (-1,2)
09:29:47 <Axman6> ?
09:29:54 <roconnor> > - (1,2)
09:29:54 <tromp> ah:)
09:29:55 <lambdabot>   (-1,-2)
09:30:02 <roconnor> caleskel!!!!!
09:30:04 <tromp> forgot parentheses
09:30:05 <Axman6> roconnor: that should not work :|
09:30:16 <Axman6> bloody Cale
09:30:27 <roconnor> tromp: -(1,2) should be a type error
09:30:33 <Axman6> since when do we have an instance for Num (a,b) >_<
09:31:08 <tromp> `op` should have lower precedence than - ?!
09:31:13 <roconnor> there should be a flag to make unparnethesized use of the negation operator illegal.
09:31:31 <roconnor> tromp: - is a big big hack that doesn't work well
09:31:42 <Cale> what?
09:31:58 <roconnor> actually I wouldn't mind throwing out the whole operator and just use negate instead
09:32:08 <Cale> There's an instance of Num for pairs in one of the modules which is loaded
09:32:15 <roconnor> save for numerical literals
09:32:16 <Cale> It's not like I did it explicitly :P
09:32:19 <Axman6> i find it odd that haskell doesn't define numbers to be (+|-)?[0-9]+
09:32:35 <roconnor> Cale: tell use whose house to burn down!
09:32:42 <tromp> > unfoldr (Just . divMod 2)  13
09:32:44 <lambdabot>   [0,1*Exception: divide by zero
09:32:47 <Cale> I love how unary negation works in Haskell even if it is a bit idiosyncratic.
09:32:49 <ricree> benmachine, figured it out.  apparently I hadn't used the 64 bit binaries.  It worked fine when I switched to those
09:32:55 <benmachine> ah
09:33:05 <Cale> roconnor: Probably Conal's
09:33:14 <Cale> I think it's probably his vector space library
09:33:16 <tromp> > unfoldr (Just . (divMod 2))  13
09:33:18 <lambdabot>   [0,1*Exception: divide by zero
09:33:20 <Cale> But I'm not sure.
09:33:21 <roconnor> everyone to California!
09:33:23 <tromp> > unfoldr (Just . (`divMod` 2))  13
09:33:25 <lambdabot>   [6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
09:33:27 <ricree> or at least it configured fine.  still have to actually make it.  I'm told that's not a fast process
09:33:36 <Axman6> :t swap
09:33:37 <lambdabot> Not in scope: `swap'
09:33:40 <Axman6> bleh
09:33:54 <tromp> which function takes (x,y) -> (y,x)?
09:33:54 <roconnor> Axman6: hah. We have a Num instance for (a,b) but no swap
09:34:02 <Axman6> > unfoldr (Just . (\(a,b) -> (b,a)) . (`divMod` 2)) 13
09:34:04 <roconnor> tromp: swap
09:34:04 <lambdabot>   [1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
09:34:15 <Cale> -(1,2) isn't exactly a normal type error even when it is a type error
09:34:20 <roconnor> tromp: Data.Tuple.swap IIRC
09:34:21 <Cale> It's a missing instance error
09:34:42 <roconnor> lots of type errors manifest themselves as missing instance errors
09:34:43 <kmc> hmm, would one generally want  swap (x,y) = (y,x) , or  swap ~(x,y) = (y,x) ?
09:35:02 <kmc> the latter is lazier and lazy = good, right?
09:35:09 <roconnor> kmc: that choice caused 1 year of delay
09:35:13 <copumpkin> I think that's what stalled the proposal to add it to the standard library
09:35:14 <copumpkin> yeah
09:35:19 <kmc> except it's weird that swap ⊥ ≠ ⊥
09:35:20 <kmc> sigh
09:35:28 <copumpkin> I think they ended up making it swap x = (snd x, fst x)
09:35:35 <copumpkin> which is the latter, basically
09:35:36 <tromp> @hoogle swap
09:35:37 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
09:35:37 <lambdabot> Control.Concurrent.STM.TMVar swapTMVar :: TMVar a -> a -> STM a
09:35:42 <Peaker> lifted type products suck :-)
09:35:49 <kmc> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Tuple.html
09:35:50 <roconnor> Peaker: let's use ML!
09:35:56 <kmc> it's the strict one
09:35:59 <roconnor> oh wait
09:36:00 <copumpkin> oh
09:36:02 <copumpkin> I was wrong!
09:36:03 <roconnor> Peaker: let's use Miranda
09:36:11 <Peaker> roconnor: unlifted products would be OK in a lazy setting I think
09:36:11 <acowley> are those really the same?
09:36:20 <roconnor> Peaker: yep
09:36:30 <Peaker> roconnor: hey, if GHC compiled all product patterns to be irrefutable ones, I think it would get the effect I want
09:36:40 <Axman6> > let x = (fst x, snd x) in x
09:36:44 <lambdabot>   mueval-core: Time limit exceeded
09:36:58 <Axman6> :t let x = (fst x, snd x) in x
09:36:59 <lambdabot> forall a b. (a, b)
09:37:01 <Peaker> (well, if it were to rely on this to make (a,(b,c)) isomorphic to (a,b,c)...
09:37:20 <Peaker> and once it is isomorphic, we can replace tuples with HLists
09:37:31 <Peaker> (i.e: the cons/nil tuple constructors)
09:37:32 <Axman6> :t let x = (snd x, fst x) in x
09:37:34 <lambdabot> forall b. (b, b)
09:37:58 <acowley> Huh, I guess they are the same
09:38:01 <roconnor> kmc: I'm just glad someone made some choice :D
09:38:03 <Axman6> :t let x = (fst x, fst x) in x
09:38:05 <lambdabot> forall a. (a, a)
09:38:18 <Axman6> :t let x = (fst x, fst . snd $ x) in x
09:38:19 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b)
09:38:20 <lambdabot>       Expected type: (a1, (a, b))
09:38:20 <lambdabot>       Inferred type: (a1, a)
09:38:37 <acowley> roconnor: so now it is the time to propose that we make it lazy! Reviving dead arguments ftw.
09:39:24 * Axman6 -> sleep
09:39:43 <brisingr> 'nite
09:39:47 <roconnor> acowley: I like laziness!
09:40:54 <brisingr> off-topic, how does lambdabot's "choose" work?
09:40:59 <tromp> > reverse . take 8 . unfoldr (\x->Just(intToDigit(x`mod`2),x`div`2)) . ord $ ' '
09:40:59 <brisingr> @choose 1,2
09:41:00 <lambdabot> 1,2
09:41:01 <lambdabot>   "00100000"
09:41:34 <Cale> wtf
09:41:40 <RenJuan> i dunno
09:41:47 <brisingr> the 1,2 was from my query
09:41:50 <tswett> @choose 8,3
09:41:50 <lambdabot> 8,3
09:41:58 <tswett> @choose 8 3
09:41:58 <lambdabot> 8 3
09:42:02 <tswett> Well.
09:42:04 <acowley> @choose cheese
09:42:04 <lambdabot> cheese
09:42:13 <brisingr> @choose
09:42:13 <lambdabot> Choose between what?
09:42:18 <tswett> @choose a, b; c: d. e| f! g
09:42:18 <lambdabot> a, b; c: d. e| f! g
09:42:37 <acowley> we will find a use for this!
09:42:38 <brisingr> @help choose
09:42:39 <lambdabot> choose. Lambdabot featuring AI power
09:42:44 <roconnor> *lol*
09:43:02 <tswett> @choose a , b ; c : d.  e | f ! g a,b;c:d.e|f!g [a , b ; c : d.  e | f ! g] [a,b;c:d.e|f!g]
09:43:03 <lambdabot> a , b ; c : d.  e | f ! g a,b;c:d.e|f!g [a , b ; c : d.  e | f ! g] [a,b;c:d.e|f!g]
09:43:14 <tswett> Well, I'm not thinking of anything.
09:43:19 <Cale> I think it's broken
09:43:50 <brisingr> or just a joke
09:44:07 <acowley> I'm still going with it being a test of our ingenuity
09:44:25 <jpcooper> hello
09:44:32 <Cale> nah, it's bitrotten from the time when lambdabot somehow arranged the arguments to a command to be separated by newlines.
09:44:36 <jpcooper> how do I define the type of a variable before I define it, in GHCi?
09:44:52 <brisingr> oh, been meaning to ask you, Cale, does lambdabot's quote db sync with the source?
09:44:52 <Cale> process_ _ "choose" xs = fmap return . io . randomElem . lines $ xs
09:44:54 <acowley> @choose Choose between what?
09:44:55 <lambdabot> Choose between what?
09:44:57 <acowley> darn
09:45:02 <Cale> brisingr: ?
09:45:13 <brisingr> say, I add a quote to lambdabot
09:45:28 <Cale> brisingr: Then it'll go into the lambdabot instance that I'm running.
09:45:34 <brisingr> will it show up in the default quote list on a newly compiled lambdabot?
09:45:39 <Cale> I don't maintain lambdabot.
09:45:49 <brisingr> oh
09:45:54 <tswett> Isn't there some newtype for String whose Show function is identity?
09:45:56 <jpcooper> okay I've figured it out
09:45:57 <hpaste> a annotated “fail me replicateM” with “fail me replicateM (annotation)” at http://hpaste.org/50394#a50402
09:45:57 <acowley> jpcooper: let {x::Float; x=3} in x
09:46:05 <Cale> But maybe eventually?
09:46:28 <tswett> Some type called "Print" or "Text" or something like that.
09:46:32 <Cale> I guess if people really wanted the quotes to go back into the source code, I can commit them.
09:46:51 <Cale> But all I do is try to keep the lambdabot instance running.
09:47:00 <Cale> Lispy runs the server
09:47:34 <Cale> and Gwern does some stuff related to maintaining lambdabot, but by and large lambdabot is unmaintained since Don Stewart gave it up
09:47:40 <RenJuan> runs and owns?
09:47:41 <brisingr> I see
09:47:46 <kmc> tswett, look at Text.PrettyPrint
09:47:51 <kmc> it's not just a newtype, though
09:47:55 <Cale> RenJuan: It's a linode server.
09:48:29 <RenJuan> Cale: I consider myself the owner of my linode host.
09:48:43 <Cale> Then yes
09:48:49 <RenJuan> owner/lessee
09:49:47 <tswett> > Text.PrettyPrint.text "baboon"
09:49:48 <lambdabot>   Not in scope: `Text.PrettyPrint.text'
09:49:58 * tswett nods.
09:53:41 <brisingr> there's your problem:
09:53:43 <brisingr> process_ _ "choose" xs   = fmap return . io . randomElem . lines $ xs
09:54:20 <Cale> Yeah, it should probably be words
09:54:43 <ocharles> Anyone encountered http://stackoverflow.com/questions/6634373/undefined-symbol-in-a-hackage-package-double-conversion and know how to fix it?
09:54:56 <ocharles> Both my Ubuntu laptop and Gentoo desktop have this problem, and I can't compile my projects :(
09:54:58 <saati> :t io
09:54:59 <lambdabot> Not in scope: `io'
10:01:08 <joe6> not a haskell question, but given how haskellers always try to write const/pure (gcc attributes) functions. Does anyone know of any utility to double-check a C function with a const attribute?
10:01:19 <fryguybob> @. choose run text "a\nb\nc"
10:01:53 <joe6> i notice that with the const attribute set, if the function accesses global variables, I do not get any warning or error..
10:02:21 <joe6> just curious if there is something that can warn/error in such situations..
10:04:24 <fryguybob> @botsnack
10:04:24 <lambdabot> :)
10:04:26 <fryguybob> @. choose run text "a\nb\nc"
10:04:39 <fryguybob> :(
10:05:09 <efie> haskell aint that lazy as i thought id would be :( (or ia am getting something wrong)
10:05:10 <efie> http://codepad.org/AdR5Hfob: as i stated a few times above (sorry!) i had problems with my code because after entering for example "1,1,1,1" nothing happend. i think thats because in "test <- myIOIntegerList" the infinite list is loaded into test and therefore nothing happens, right? i though haskell would begin to load only that much integers into test as needed, meaning as much channel_2' needs to give a final result (when "bits" pat
10:05:39 <Botje> efie: you got cut off after "when bits pat"
10:05:55 <efie> oh
10:05:57 <efie> "(when "bits" patter matches with [])"
10:06:35 <Peaker> efie: it's good practice to give a type signature to main. If you had used:   main :: IO ()   it would catch your bug of using mapM there instead of mapM_  (unrelated to your problem though)
10:06:48 <Peaker> (give type signatures to top-level stuff in general)
10:07:06 <fryguybob> @compose choose run text "a\nb\nc"
10:07:06 <lambdabot>  b
10:07:34 <Botje> efie: uh. the first thing your shuffle does is take length xs .. of an infinite list.
10:08:19 <efie> botje: oh, yeah - that is a problem i guess
10:08:21 <efie> :)
10:08:31 <Peaker> efie: (IO a) is a broad type to give to something just because it needs some randomness
10:10:23 <efie> peaker: unless I'm very much mistaken on learnyouahaskell.com i think it was stated that main in practise does not get a signature
10:10:38 <efie> (i was wondering if that is good)
10:11:11 <erus`> is main given a sig by the compiler?
10:11:25 <Botje> the compiler only checks that main :: IO a
10:11:29 <erus`> or an error if it isnt the right type or something
10:11:33 <Botje> main = return 5 will compile without an error
10:11:52 <Botje> but it really should be stricter and demand it to be IO ()
10:12:26 <zygoloid> @type forever -- things like this are probably why it's not IO (), i suspect
10:12:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:13:07 <zygoloid> hmm, no, forget that :)
10:13:14 <efie> i am sorry i doubted about haskells laziness, thanks for the hint with the infitive list
10:13:53 <Botje> efie: no problem, once you stare at something too long you completely miss such things :)
10:15:44 <zygoloid> hmm, it was changed from IO () to IO t for any t in Haskell'98
10:16:59 <benmachine> the type of forever is wrong
10:17:04 <benmachine> imo
10:17:11 <benmachine> should be forever :: m a -> m Void
10:17:18 <benmachine> otherwise this
10:17:24 <copumpkin> Void = forall a. a
10:17:35 <benmachine> :t forever putStrLn "hello!"
10:17:36 <lambdabot> forall b. b
10:18:17 <roconnor> benmachine: readerMonad?
10:18:26 <benmachine> roconnor: right :(
10:18:27 <roconnor> :t forever $ putStrLn "hello!"
10:18:28 <lambdabot> forall b. IO b
10:18:34 <Eduard_Munteanu> :t forever
10:18:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
10:18:45 <benmachine> 'm b' unified with 'r -> b' and then you're screwed
10:18:46 <roconnor> but benmachine is right
10:18:47 <copumpkin> I don't see the problem with its type
10:18:59 <roconnor> it should be m a -> m (forall b. b)
10:19:03 <copumpkin> :)
10:19:08 <Eduard_Munteanu> Possibly.
10:19:11 <benmachine> isn't that impredicative :o
10:19:14 <copumpkin> yeah
10:19:17 <benmachine> eep
10:19:31 <roconnor> benmachine: forall b. b is the impredicative way of saying Void, yes.
10:19:32 <copumpkin> although if m is instantiated to ((->) r)
10:19:35 <Eduard_Munteanu> Well, you'd get some static assurance that you're not expecting something to run after your "forever" action, no?
10:19:35 <benmachine> what's wrong with Void :P
10:19:42 <benmachine> Eduard_Munteanu: exactly
10:19:50 <copumpkin> then you get (r -> a) -> (r -> (forall b. b))
10:19:56 <benmachine> haskell is supposed to catch your typos at compile time
10:19:58 <zygoloid> yeah. if the type of 'forever' were corrected, and the type of main were required to be IO (), then "main = forever mainLoop" would be illegal
10:20:05 <copumpkin> (r -> a) -> (forall b. r -> b)
10:20:07 <roconnor> benmachine: nothing is wrong with Void. I just wanted to tie the existing type of forever into a version of its proper type.
10:20:14 <benmachine> roconnor: ah I see
10:20:18 <copumpkin> forall b. (r -> a) -> (r -> b)
10:20:21 <copumpkin> yay
10:20:29 <Eduard_Munteanu> But I'm unsure if that's the type we should use.
10:20:46 <benmachine> copumpkin: oh, so that's no good then?
10:21:05 <copumpkin> did I fuck up? it seems like that impredicative forall b. b would just float outwards with reader
10:21:10 <copumpkin> and would have the same issue :)
10:21:26 <roconnor> zygoloid: actually, based on the free monad semantics of IO, the type of main should be IO Void.
10:21:37 <zygoloid> hmm, i can't find any justification for haskell'98 relaxing the type of main
10:21:51 <benmachine> zygoloid: laziness, and not the good kind :P
10:21:55 <zygoloid> roconnor: so a terminating main has to return undefined? that seems unsatisfying
10:22:16 <benmachine> not necessarily
10:22:20 <roconnor> zygoloid: nope terminating main has to be done by calling exit :: ExitMsg -> IO Void.
10:22:21 <benmachine> you could also use exitWith or some such
10:23:02 <zygoloid> roconnor: ew. what would happen if main returned?
10:23:12 <roconnor> zygoloid: what do you mean?
10:23:23 <Aune> Im trying to write my own IRC-bot, heavily influenced by Dons "Roll your own IRC-bot" - tutorial. But I want to add some extra state and I feel quite lost. The problem is that I don't really get how to use StateT in a proper way.
10:23:31 <roconnor> zygoloid: main does return ... an IO Void. :)
10:23:41 <benmachine> hmm
10:23:51 <zygoloid> roconnor: i mean, if you require termination to happen through a call to exit, what does "main = return undefined" do?
10:23:57 <Eduard_Munteanu> Probably not if you exit yourself or go through an exception handler, no?
10:24:00 <copumpkin> roconnor: why not IO ExitMsg? :)
10:24:00 * benmachine becomes torn between convenience and correctness when deciding between forall a. IO a and IO Void as types
10:24:03 <Aune> So I wonder if im starting on the right foot, here is my code: http://hpaste.org/50403
10:24:09 <roconnor> zygoloid: throw an exception.
10:24:53 <hpaste> applicative annotated “parse error in local function” with “parse error in local function (annotation)” at http://hpaste.org/50390#a50404
10:24:53 <zygoloid> roconnor: this makes writing little scripts like main = interact (unlines . map toUpper . lines) harder :)
10:24:54 <copumpkin> seems  like main :: IO ExitMsg would give you fewer "bad" IO values
10:25:15 <benmachine> zygoloid: no it doesn't, interact :: (String -> String) -> IO Void
10:25:15 <Peaker> copumpkin: what about IO exceptions?
10:25:28 <copumpkin> Peaker: you can still throw them
10:26:04 <roconnor> copumpkin: IO ExitMsg would work but would be a bit more awkward
10:26:11 <copumpkin> why more awkward?
10:26:21 <benmachine> roconnor: what's your original justification for  < roconnor> zygoloid: actually, based on the free monad semantics of IO, the type of main should be IO Void
10:26:24 <Eduard_Munteanu> Still, how does it prevent    forever f >> g?
10:26:32 <copumpkin> it seems like getting an exit-time exception because people forgot to write exitWith in every single program
10:26:40 <roconnor> copumpkin: you'd have to write main = fmap magic (forever mainLoop)
10:26:49 <copumpkin> is less desirable than just giving them a type error telling them that they didn't return the ExitMsg
10:26:53 <benmachine> Eduard_Munteanu: tricky
10:27:03 <telephone___> How do I convert Double -> Float?
10:27:06 <benmachine> Eduard_Munteanu: that's invalid in IO but not in other moands
10:27:06 <zygoloid> benmachine: so interact would terminate the program? yikes!
10:27:08 <benmachine> *monads
10:27:10 <roconnor> copumpkin: with IO Void people would still be effectively forced to return an exit code or run forever.
10:27:27 <benmachine> zygoloid: well, interact already never returns, aiui
10:27:39 <Eduard_Munteanu> Hrm, yeah, I think it's valid in Cont or such.
10:27:41 <copumpkin> roconnor: fair enough
10:27:43 <roconnor> @type interact
10:27:44 <lambdabot> (String -> String) -> IO ()
10:27:55 <roconnor> benmachine: the type of interact is wrong.
10:27:55 <benmachine> Eduard_Munteanu: or Maybe (though trivially) or Either (less trivially)
10:28:00 <roconnor> @src interact
10:28:01 <lambdabot> interact f = do s <- getContents; putStr (f s)
10:28:08 <benmachine> hmm
10:28:09 <roconnor> oh goodness
10:28:12 <benmachine> in principle that could return
10:28:19 <roconnor> okay I take that back
10:28:50 <roconnor> you'd have to terminate the intract call with an exit msg function
10:29:15 <tswett> Is IO isomorphic to Cont (IO ())?
10:29:18 <zygoloid> this seems like a not-good idea
10:30:13 <Eduard_Munteanu> Hm, how do you callCC in IO?
10:30:26 <zygoloid> Eduard_Munteanu: forkIO + MVars
10:30:45 <zygoloid> (i'm not sure that works, but...)
10:31:13 <Eduard_Munteanu> I presume exception handlers kinda get you something similar, but it might be inconvenient.
10:31:24 <roconnor> benmachine: if we take IO as a free monad of system calls then IO Void is the initial system call-algebra.  See http://www.reddit.com/r/haskell/comments/hgx46/io_is_not_a_monad/c1veokh?context=3
10:31:29 <tswett> I guess it's not.  Cont (IO ()) a is (a -> IO ()) -> IO ().  >>= obviously allows you to convert IO a into that, but converting that into IO a...
10:31:32 <zygoloid> exception handlers don't give you multiple return
10:32:19 <tswett> Well, we'd want to make an MVar or some such, and pass the "put" function in.  The thing is, it might end up calling the "put" function any number of times... but is this a problem?
10:32:20 <Eduard_Munteanu> Also, I assumed this was about ContT.
10:32:22 <telephone___> I don't know how to convert Double to Float. There is a function 'double2Float' in GHC.Float. So are the types Double and Float not actually part of Haskell, but part of my compiler GHC?
10:32:33 <roconnor> @type realFrac
10:32:34 <lambdabot> Not in scope: `realFrac'
10:32:35 <roconnor> @type realToFrac
10:32:37 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
10:32:43 <roconnor> telephone___: realToFrac will do it I think
10:33:03 <tswett> Maybe you can simply ignore all but the first put.
10:33:39 <telephone___> roconnor: so the types Double and Float are part of my compiler, and the typeclasses part of Haskell?
10:34:00 <Eduard_Munteanu> @hoogle (Num a, Num b) => a -> b
10:34:02 <lambdabot> Prelude abs :: Num a => a -> a
10:34:02 <lambdabot> Prelude negate :: Num a => a -> a
10:34:02 <lambdabot> Prelude signum :: Num a => a -> a
10:34:13 <roconnor> telephone___: Double and Float are part of the Haskell standard.
10:34:21 <Eduard_Munteanu> @hoogle (Num a, Real b) => a -> b
10:34:22 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:34:22 <lambdabot> Foreign.Marshal.Utils toBool :: Num a => a -> Bool
10:34:22 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
10:34:36 <roconnor> telephone___: GHC chooses to implements these data types using GHC.Double and GHC.Float.
10:35:02 <roconnor> telephone___: but if you want your code to be portable, you shouldn't use GHC.foo
10:35:31 <Eduard_Munteanu> > realToFrac (0.1 :: Double) :: Float
10:35:32 <lambdabot>   0.1
10:37:16 <alex404> So I've got a bit of a puzzle... I never thought I *needed* references for anything before, but what about the following case: I have a set of records, and I want to maintain various maps via the fields of the records to the original instance of the record itself, e.g. a size or weight field returning the relevant person(s). It seems like I need references to do this, in order to not e.g. have to rebuild my tree maps all the tim
10:37:17 <alex404> e.
10:39:10 <Eduard_Munteanu> alex404: so when you update, you want to keep the old version around for a while?
10:40:09 <Eduard_Munteanu> Oh, I see.
10:40:20 <benmachine> alex404: does sound difficult to do without references, but I'm not sure why I'd want to do that :P
10:40:28 <benmachine> perhaps there's another way to solve your problem?
10:40:40 <Eduard_Munteanu> You might be able to do it by "tying the knot".
10:40:42 <alex404> Eduard_Munteanu: No. It's like, if I have a set of people, and I change the weight of one of them via the (Map Weight Person), what do I do with the (Map Height Person)
10:41:07 <alex404> Eduard_Munteanu: What do you mean?
10:41:35 <alex404> benmachine: Indeed I do, but it's not 'optimal'. This is largely a theoretical excercise
10:42:04 <benmachine> alex404: perhaps have a Map Weight Name
10:42:08 <benmachine> instead of a Map Weight Person
10:42:13 <benmachine> and then a Map Name Person that you modify
10:42:41 <Eduard_Munteanu> Nvm, IAh.
10:42:53 <benmachine> (this is sort of crudely implementing references in the sense that your RAM is Map Address Word8 :P)
10:42:59 <peteriserins> the amb described in http://www.haskell.org/haskellwiki/Amb is actually strict, right?
10:43:02 <alex404> benmachine: Indeed
10:43:17 <Eduard_Munteanu> And your Name could be an index into a map that actually points to your Person.
10:43:32 <alex404> benmachine: Though if there is a unique identifier in the record, it is handy to know that you could use it as a reference...
10:44:10 <peteriserins> if not in the sense of passing in undefined, but in the sense of non-termination?
10:44:39 <roconnor> alex404: the Map shouldn't return records of people, rather the maps should return "accessor" (aka lenses) pointing to the records of people.
10:44:49 <benmachine> peteriserins: what do you mean by the sense of non-termination?
10:45:06 <benmachine> it seems like amb undefined = undefined, because amb pattern-matches
10:45:24 <benmachine> in that sense it is strict
10:45:26 <peteriserins> benmachine: if you write amb (sum (repeat 1)) 2, it will not terminate, correct?
10:45:28 <alex404> roconnor: I do use Data.Accessor, is that something else from lenses?
10:45:46 <roconnor> alex404: Data.Accessor is one of sevral implementations of lenses
10:45:47 <benmachine> peteriserins: er, will that typecheck?
10:45:51 <peteriserins> benmachine: that's what I meant by "not in the sense of passing it undefined"
10:45:54 <benmachine> do you mean amb [sum (repeat 1), 2]
10:45:54 <alex404> roconnor: I guess the meaning of lense is relatively self evident
10:46:07 <peteriserins> benmachine: right
10:46:08 <roconnor> alex404: I don't know about self-evidant
10:46:16 <benmachine> ok, well that's equivalent to amb [undefined, 2]
10:46:20 <alex404> roconnor: I said relatively ;)
10:46:31 <roconnor> alex404: it is not self-evident at all :D
10:46:39 <peteriserins> benmachine: will haskell figure that out?
10:46:58 <alex404> roconnor: Well, I'll look into the theory a bit more, in any case. Thanks of rthe tip
10:47:03 <benmachine> peteriserins: in the sense of "equivalent" that I mean, there's no figuring out to do
10:47:23 <benmachine> peteriserins: it looks to me like amb won't necessarily fail to terminate, but it will if you try to *do* anything with that undefined
10:47:28 <roconnor> alex404: to be fair, although I've conjectured using this solution to that sort of problem before, I don't think I've actually tried it out.
10:47:51 <benmachine> so basically, it's as lazy as one could possibly imagine it being
10:47:55 <peteriserins> benmachine: right, so it actually is non-strict for that sort of purpose
10:47:55 <Peaker> hlint doesn't warn about mapM print
10:48:06 <alex404> roconnor: Could you maybe explain it a bit? How is it different from (Map Weight Name) (Map Name Person)
10:48:06 <roconnor> alex404: Since lenses are "functional references", this solution is, in fact, using references :D
10:48:20 <roconnor> alex404: the idea is that you have a database
10:48:20 <benmachine> Peaker: sounds like it wouldn't be hard to fix that
10:48:30 <Gracenotes> Peaker: ..context of that being bad?
10:48:32 <roconnor> alex404: db :: DB
10:48:37 <Peaker> Gracenotes: almost every context :-)
10:48:41 <peteriserins> benmachine: so is there no current implementation of amb that actually returns the first argument to terminate?
10:48:42 <Peaker> Gracenotes: you want mapM_
10:48:46 <Gracenotes> oooh right
10:48:59 <Peaker> I guess mapM on a list of (IO ()) should in general warn you
10:48:59 <roconnor> alex404: lens allow you to pull out records from this database
10:49:04 <benmachine> peteriserins: you need IO and threading to do that
10:49:12 <roconnor> alex404: Lens DB PersonRecord
10:49:16 <Peaker> can WARN rules be added like REWRITE rules?
10:49:19 <peteriserins> benmachine: yes, has it been done?
10:49:25 <Manehattan> hi, does anyone know an md5 function that's String -> String ?
10:49:30 <benmachine> peteriserins: uh, I think so
10:49:39 <benmachine> see also http://hackage.haskell.org/package/unamb which cheats
10:49:41 <Peaker> Manehattan: The String type is not a good idea almost all of the time
10:49:49 <roconnor> so you might have a refrence ot the person named simon:  Simon :: Lens DB PersonRecord
10:49:49 <benmachine> (and demands very careful use to avoid violating purity)
10:50:01 <Gracenotes> > "I like my mapM print like I like my coffee, " ++ show (repeat ())
10:50:02 <alex404> roconnor: So you're letting your lense library maintain the map as opposed to something like Data.Map
10:50:03 <lambdabot>   "I like my mapM print like I like my coffee, [(),(),(),(),(),(),(),(),(),()...
10:50:10 <Manehattan> peaker: I am working with Text, yes, so maybe Text -> Text
10:50:11 <roconnor> alex404: not quite
10:50:20 <benmachine> peteriserins: ah, that package also contains the non-cheating version, which may interest you
10:50:35 <roconnor> alex404: with Simon you can get the record from a database: get Simon db :: Record
10:50:43 <peteriserins> benmachine: ah, it's called unamb, it was called amb in papers; thanks!
10:51:07 <roconnor> alex404: and modify the record in a db to produce a new updated database:  newDb = modify Simon db f where f = ...
10:51:10 <benmachine> peteriserins: there's two functions here
10:51:17 <benmachine> peteriserins: amb :: a -> a -> IO a
10:51:22 <benmachine> and unamb :: a -> a -> a
10:51:34 <roconnor> alex404: notice your old database db remains if you need it.
10:51:36 <alex404> roconnor: Ah, I think I see what you mean by functional references. But this is only good if you have a static number of referents?
10:51:43 <benmachine> the latter demands that the two a values are equal if defined
10:51:49 <roconnor> alex404: Nope, you can make it dynamic
10:52:01 <benmachine> the former doesn't
10:52:08 <benmachine> this condition isn't checked
10:52:11 <alex404> roconnor: Fair enough... in so far as you can create the accessors on the fly
10:52:11 <roconnor> for instance getRecordByName :: String -> Lens DB Record
10:52:12 <benmachine> and the implementation is slow
10:52:13 <Aune> How do I best use StateT and/or ReaderT to model a bot with both imutable state, mutable state?
10:52:17 <benmachine> so I'm not sure the module is practically useful
10:52:21 <benmachine> but it's interesting nonetheless
10:52:28 <roconnor> and getRecordByWeight :: Int -> Lens DB Record
10:52:29 <Peaker> Manehattan: I can't find something efficient/quick, MissingH has an MD5 class you can instantiate for Text maybe
10:53:09 <Manehattan> peaker: It does not have to be that efficient, it is a one-time check at registering
10:53:24 <roconnor> alex404: the way you implement getRecordByName and getRecordByWeight would likely be using Data.Map internally.
10:53:43 <roconnor> alex404: these maps would be part of the DB structure in all likelyhood.
10:54:02 <roconnor> but that is an implementation detail hidden inside your DB module.
10:54:10 <alex404> roconnor: Indeed...
10:54:17 <roconnor> alex404: again, I haven't tried this idea in practice ...
10:55:01 <alex404> roconnor: It does have a bit more of that functional flavour than the other suggestions though, which is nice...
10:55:17 <roconnor> alex404: and in theory you want to use partial lenses because there may be no record with a given identifier in some cases.
10:55:40 <alex404> roconnor: Can you foresee any other problems?
10:55:48 <roconnor> not yet.
10:56:24 <roconnor> alex404: depending on how serious your application is you can punt on the parital lenses and just use error "no record found" in those cases.
10:56:40 <benmachine> Aune: the easiest way is probably to use ReaderT MyState IO a, assuming you need IO
10:56:43 <alex404> roconnor: Indeed, that's what I would likely do.
10:56:52 <benmachine> Aune: put an IORef in MyState, and that will get you mutability
10:57:05 <roconnor> alex404: the new fclabels package claims to support parital lenses, but I haven't verified this claim.
10:58:44 <Peaker> Manehattan: you could encode your Text to a ByteString (choose utf8 or utf16) and then use any md5 lib on that: http://hackage.haskell.org/packages/archive/nano-md5/0.1.2/doc/html/Data-Digest-OpenSSL-MD5.html
10:58:55 <Aune> benmachine, thanks, will try that and see if I can make sense of it.
10:59:34 <Manehattan> peaker: Many thanks!
10:59:56 <roconnor> alex404: lenses interact nicely with (State DB), so you can update your database easily with the lens/State combinators.
11:02:16 <alex404> roconnor: This is a lot of food for thought... thanks.
11:02:30 <roconnor> good luck
11:12:05 <ocharles> Anyone know what to do about" Loading package double-conversion-0.2.0.1 ... linking ... ghc: /home/ollie/.cabal/lib/double-conversion-0.2.0.1/ghc-7.0.4/HSdouble-conversion-0.2.0.1.o: unknown symbol `_ZNK17double_conversion6Double5valueEv'" -- I'm getting that whenever a file uses TH
11:18:51 <frerich_> I guess a lot of people published something like this already, but I thought I'd mention it anyway in case it has some new bits: https://github.com/frerich/unicode-haskell is a little Vim script for making Haskell source code appear using fancy Unicode characters in vim/gvim (there's a screenshot linked from that page).
11:25:40 <brisingr> whoa, irccloud down?
11:26:25 <ddarius> brisingr really doesn't know how IRC works.
11:26:33 <brisingr> nope, I don't
11:26:50 * ddarius waves to CosmicRay.
11:27:09 <brisingr> but all those people with ping timeouts
11:28:31 <brisingr> surely they do mean something
11:28:50 <peteriserins> what is the idiomatic way of branching based on whether x < 0, x == 0 or x > 0 in sub-expressions, using case x `cmp` 0 of?
11:29:21 <ddarius> More or less, where cmp = compare
11:29:53 <peteriserins> ddarius: ok, thanks
11:45:03 <mornfall> Anyone can think of a way to factor "grab >>= \x -> fun x" out of "grab >>= \x -> fun x p1 p2" (for arbitrary p1 ... pN)?
11:46:57 <copumpkin> reorder the arguments to fun?
11:47:27 <mornfall> copumpkin: Record selectors...
11:47:50 <c_wraith> @pl \x -> fun x p1 p2
11:47:50 <lambdabot> flip (flip fun p1) p2
11:48:00 <mornfall> Yeah, flippity flip.
11:48:03 <mornfall> Sucks. :P
11:48:12 <mornfall> (And fails the p1...pN thing, I suppose.)
11:48:47 <mornfall> And Debian ships GHC 7.2.0.20110728 which panics on Data.Text. Oh so not cool. :(
11:49:04 <Cale> lol, wtf
11:49:29 <copumpkin> moo f = grab >>= f . fun
11:49:40 <Cale> is that even a release version?
11:49:42 <copumpkin> hmm, that won't work
11:50:02 <mornfall> Cale: Almost. :-)
11:50:51 <Cale> I never trust my distribution (Ubuntu) to distribute GHC correctly.
11:51:52 <mornfall> Cale: Well, Debian has been steadily improving. But they are still a tad slow.
11:52:27 <Clint> the unstable abi problem makes updating somewhat challenging
11:52:54 <basus> I'm having trouble to use Data.Map
11:53:04 <HugoDaniel> ive just downloaded the most recent version of ghc
11:53:09 <Cale> Yeah, to be honest, I don't want GHC's version to change out from under me without warning.
11:53:11 <basus> do I need to specify key/value types first?
11:53:19 <HugoDaniel> i hope it comes with awesomeness included
11:53:29 <Cale> basus: um, well, they appear in the type of the Map
11:53:47 <Cale> basus: but you don't necessarily have to specify them if they can be inferred.
11:54:02 <Cale> basus: But of course, you should know what they are.
11:54:29 <basus> so I can write a type like `type SomeMap = Map.Map Int String` if I want to specify a Map from ints to strings, right?
11:54:37 <Cale> You can...
11:54:59 <Cale> btw, I usually like to do:
11:55:05 <Cale> import Data.Map (Map)
11:55:13 <Cale> import qualified Data.Map as Map
11:55:23 <Cale> So I don't have to qualify it in types.
11:55:28 <mauke> too much typing
11:55:33 <mauke> import qualified Data.Map as M
11:55:37 <copumpkin> yeah, I do that too, but hate having to do that
11:55:38 <mornfall> $ get-ghc 7.2.1
11:55:41 <mornfall> let's see if that works :D
11:55:52 <Cale> yeah, there needs to be a way to abstract over import declarations
11:56:36 <basus> Cale: I guess the core problem is that I'm confused as to how to work with Maps with specific key/value types
11:56:38 <mornfall> (http://pastebin.dqd.cz/KaOD/ ... testing in progress)
11:56:48 <Cale> basus: How so?
11:57:15 <mornfall> (A cabal install <useful stuff> could be tacked at the end I guess...)
11:57:17 <Cale> basus: Have you looked at the documentation?
11:57:18 <dolio> Same as you would with general key/value types.
11:57:30 <basus> specifically, with Map.empty
11:57:45 <Cale> http://hackage.haskell.org/packages/archive/containers/0.4.0.0/doc/html/Data-Map.html
11:58:08 <Cale> You can usually just use Map.empty
11:58:29 <Cale> If it results in an ambiguity, then you can add a type signature to the expression
11:58:37 <Cale> But usually it won't, in a complete program.
11:59:42 <copumpkin> we need generic collections
11:59:46 <copumpkin> like scala has!
11:59:56 <copumpkin> ;)
12:00:01 <mornfall> copumpkin: What?
12:00:12 <copumpkin> we need CanBuildFrom
12:00:16 <copumpkin> mmm
12:00:25 <mauke> import Collection.Whatever
12:00:29 <mornfall> [citation needed]
12:00:34 <Cale> http://hackage.haskell.org/package/keys
12:00:39 <Cale> ^^ problem solved?
12:01:20 <mauke> that needs some documentation
12:01:33 <Cale> The types are all the documentation it needs.
12:01:39 <mornfall> Cale: Hardly. :P
12:01:44 <mauke> well, I have no idea what this does
12:01:48 <copumpkin> I was being sarcastic
12:01:50 <mornfall> I would have to boot my brain.
12:01:56 <copumpkin> scala's collections are terrifying
12:01:59 <Cale> what what does?
12:02:05 <mauke> Keyed
12:02:05 <copumpkin> Cale: samwell does
12:02:21 <Cale> It's a few typeclasses for indexed container libraries
12:02:21 <thoughtpolice> oh copumpkin, you crazy. how'd you get so hysterical?
12:02:32 <copumpkin> lol
12:02:33 <mornfall> How many stages there are to GHC build? -DSTAGE=1 means it'll take a long time yet, I guess?
12:02:40 <copumpkin> Samwell
12:03:03 <mornfall> /nick CoSamwell
12:03:50 <mauke> why does Indexable exist?
12:04:56 <HugoDaniel> mornfall: get-ghc ? is that a script you just did ?
12:05:08 <basus> is there a way to combine a list and a type deconstruction without specifying the type?
12:05:12 <Cale> mauke: Look at its method
12:05:21 <mauke> looks like !
12:05:25 <Cale> yeah
12:05:26 <Cale> exactly
12:05:36 <mauke> i.e. unsafe
12:05:36 <mornfall> mauke: Sounds like "stuff you can look up other stuff by keys".
12:05:39 <HugoDaniel> a script that installs ghc and cabal-install in my home dir from source has been in my todo list for some time
12:05:43 <basus> like doing ((Typename x y z) : xs) but omitting the Typename?
12:05:43 <mornfall> Oh noes!
12:05:44 <mornfall> collect2: ldc oreltlurneedct2: ld ret ur1n eedx i1t st atexius
12:05:48 <Cale> mauke: *possibly* unsafe
12:05:53 <Cale> mauke: but not in every case
12:06:04 <mornfall> Serious parallel failure.
12:06:05 <Cale> For example, the Cofree instance is safe.
12:06:23 <mauke> mornfall: hahaha
12:06:35 <Cale> and the ((->) a) instance is safe
12:07:05 <cari_veri_epdsk> hello guys. im trying to install leksah the haskell IDE and it failes because theres no available ghc >=7.0 ? what shall I do ? (ubuntu 11.x)
12:07:27 <Cale> basus: uh, what?
12:07:45 <Cale> basus: You can't omit the data constructor if you want to pattern match the data constructor.
12:08:11 <Cale> basus: You either pattern match it, or you don't.
12:08:31 <mornfall> ghc-prim failed to build... :(
12:08:35 <Cale> cari_veri_epdsk: Install an older Leksah, or a newer GHC?
12:09:51 <ricree> Any suggestions for diagnosing errors while building ghc?  All I got was "[compiler/stage2/build/DsMeta.dyn_o] Error 1"  and I'm not really sure where to start figuring out what's wrong
12:10:13 <Cale> basus: What would the code look like that you'd like to write?
12:11:19 <basus> Cale: I was wondering if I had an function argument that looked [Typename] -> String
12:11:21 <Cale> ricree: What have you changed?
12:11:52 <basus> Cale: and I had `type Typename = Typename a b c`
12:12:07 <Cale> You mean data?
12:12:15 <Cale> er, I don't think I understand
12:12:22 <basus> yes, I mean data, sorry
12:12:54 <Cale> So something like  data Typename = Typename Integer String Double
12:13:00 <ricree> Cale, Nothing.   The generic binaries wouldn't run for me, but a blog post I came across suggested that installing an older binary and using it to compile ghc might work.  http://sheyll.blogspot.com/2010/05/installing-haskell-prime-on-cent-os-54.html
12:13:01 <basus> yeah
12:13:13 <basus> then I would want to write: someFunc ( (a b c) : xs ) = something
12:13:17 <Cale> ricree: aha, okay
12:13:29 <Cale> ricree: and the older binaries run okay?
12:13:32 <basus> where someFunc :: [Typename] -> String
12:13:35 <basus> or something like that
12:14:05 <basus> so because someFunc is expecting a list of Typenames
12:14:07 <Cale> basus: Yeah, you have to write the data constructor, because in general there might be more than one.
12:14:10 * mornfall upgrades gcc...
12:14:25 <basus> like more than one way to build Typename?
12:14:34 <basus> I see
12:14:44 <Cale> basus: I could come along and add to the definition:  data Typename = Typename Integer String Double | Foo Integer
12:14:49 <ricree> Cale,  yes.   6.8.3 works for me
12:14:55 <basus> right...
12:14:58 <basus> got it
12:15:38 <Cale> ricree: okay, hmm...
12:16:04 <ricree> Cale, The newer binaries seem to want at least glibc 2.7, but the box I'm trying to install on has 2.5
12:18:31 <Cale> and you're building 6.12.2, or something newer?
12:18:54 <Cale> It might be necessary to work your way up
12:19:24 <ricree> trying 6.12.2 .  It got pretty far before failing
12:20:05 <ricree> So maybe give something in the 6.10 range a try, then come back to .12?
12:20:51 <Cale> Well, that guy suggested that he was successful building 6.12.2 from 6.8.3
12:20:53 <HugoDaniel> mornfall: is it awesome ?
12:20:59 <Cale> so I don't know
12:21:23 <Cale> DsMeta is a pretty unspectacular module, apart from being fairly large
12:22:34 <ricree> Might just be a sign telling me it's time to ditch the shared hosting.
12:23:16 <Cale> Maybe it failed because of system limitations?
12:23:24 <ricree> could be
12:23:38 <Cale> Like, if it ran out of memory and was killed, I doubt you'd see much in the way of useful messages.
12:25:04 <ricree> Hadn't thought of that, but you might easily be right on that
12:26:34 <basus> can someone tell me what a red underline in the Emacs Haskell mode means?
12:28:11 <Cale> basus: I don't think I've ever seen that
12:29:06 <mustelo> perhaps it's an error in the *ghci* buffer?
12:29:10 <basus> I wrote `Just nstate -> Map.lookup c nstate`, both of the nstates are underlined, but in different colors
12:29:51 <basus> it's in the file buffer and it compiles/runs fine
12:29:59 <Botje> maybe it's warning about variable shadowing?
12:30:00 <Cale> weird
12:30:06 <Botje> no, wait
12:30:53 <wyfrn> is there a way to use typeclass constraints in definitions with type? the data syntax does not work
12:31:02 <basus> apparently it doesn't like the name 'nstate'
12:31:14 <Cale> I don't use emacs all that often, but I don't recall having seen something like that. I forget, does it highlight warning/error messages when compiling?
12:31:21 <mustelo> basus, can you paste the code somewhere?
12:32:14 <Botje> is there perhaps another nstate in scope?
12:33:22 <basus> Botje: nope
12:34:28 <basus> here's the whole file http://pastebin.com/MVReSSvg
12:34:30 <mauke> The paste MVReSSvg has been copied to http://hpaste.org/50406
12:38:21 <basus> it's probably not very idiomatic Haskell since I'm just getting started
12:38:29 <mustelo> basus, nothing strange happens here when I load that in emacs. try restarting emacs maybe?
12:40:08 <basus> yeah it's probably nothing serious
12:40:16 <basus> goes away if I change the name to something else
12:41:07 <szerf> hello
12:41:12 <mustelo> basus, also, do you know about the Maybe monad? because you've got a great example of where to use it here in `transition`
12:41:46 <szerf> can anyone help me ?
12:41:54 <mustelo> szerf, sure just ask
12:41:55 <basus> mustelo: I've heard about it, but haven't really wrapped my head around Monads, can you explain?
12:42:04 <szerf> thanks
12:42:24 <mustelo> basus, you can rewrite transition as `transition m s c = Map.lookup s m >>= Map.lookup c`
12:42:41 <mustelo> and it will do exactly what you had written, but it's clearer and more idiomatic
12:43:05 <szerf> ok i trie to write a function in haskell that use 2 class constraint
12:43:09 <szerf> but it fail
12:43:14 <basus> mustelo: when I was reading about Monads, I was confused about the >> and >>= operators
12:43:20 <szerf> i dont know why
12:43:26 <ricree> :t (>>=)
12:43:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:43:30 <mustelo> szerf, did you put parens around the constraints? also, pasting your code will be helpful
12:43:34 <basus> mustelo: can you explain them a bit?
12:43:43 <szerf> yes
12:43:59 <ricree> basus, basically, >>= feeds the value inside the monad on the left into the function on the right
12:44:33 <szerf> this is my function
12:44:37 <szerf> pid4 :: (Num b, Integral a) => a -> b pid4 0= 0.0 :: Float pid4 x = (if even x then 1/x*2+1 else (-1/x*2+1))+pid4 (x-1)
12:45:31 <mustelo> szerf, do you want it to return a Float?
12:45:39 <szerf> yes
12:45:43 <szerf> or double
12:45:48 <mustelo> then change the type sig to reflect that
12:46:10 <mustelo> instance  Monad Maybe  where
12:46:11 <mustelo>     (Just x) >>= k      = k x
12:46:11 <mustelo>     Nothing  >>= _      = Nothing
12:46:16 <mustelo> basus, ^^
12:47:01 <basus> ricree: how does it know which function argument the Monad value should map to?
12:47:05 <mustelo> so in your transition, the first lookup is on the left, if it fails, then the second case of >>= is matched, and Nothing is returned. if it succeeds, the first case is matched and the second lookup is performed
12:47:31 <mustelo> basus, what do you mean?
12:47:51 <ricree> basus,  It can only take one argument functions.  But you would apply the other arguments in place
12:48:22 <ricree> so you'd feed (Map.lookup c) to the >>= operator
12:48:56 <basus> right, I'm just wondering what would happen if I had (for example) a 3 arg function where the second arg should come from the Monad
12:49:19 <mustelo> basus, you have a couple options there, one is `liftM3`
12:49:20 <ricree> basus,  In that case, you'd probably use do notation
12:49:28 <ricree> or at least I would
12:49:33 <ricree> but there may be better ways
12:50:02 <szerf> that dont work
12:50:21 <mustelo> szerf, if you delete the type signature, ghc will infer the type pid4 :: (Integral a, Fractional a) => a -> a
12:50:23 <szerf> he say type constructor 'Float' used as class
12:50:30 <ReinH> is it possible to represent Haskell 2010 grammer in BNF? I notice things like "comment -> dashes [ any<symbol> {any} ] newline" where the any<symbol> seems problematic?
12:51:00 <mustelo> szerf, do you know about `fromIntegral`?
12:51:02 <mustelo> :t fromIntegral
12:51:03 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:51:16 <ricree> basus,  Do notation is syntactic sugar for >> and >>=, but it is more convenient in more complex cases.  For example, your transition could be written in do notation as
12:51:16 <szerf> yes i test it
12:51:24 <ricree> transition m s c = do
12:51:38 <ricree> nstate <- Map.lookup s m
12:51:51 <ricree> map.looukup c nstate
12:52:01 <szerf> but he put somthing like : could not deduce Fractional
12:52:03 <basus> ricree: I see
12:52:43 <basus> mustelo: I get a Duplicate instance error if I change the Monad type sig, but it works fine without it
12:52:45 <ReinH> Another way to put it: is Haskell 2010 context-free?
12:53:02 <basus> mustelo: maybe that behavior is already part of the Maybe Monad?
12:53:27 <mustelo> basus, what do you mean "change the monad type sig"?
12:54:03 <basus> the instance Monad Maybe where… code that you put in a little earlier
12:54:17 <mustelo> basus, that's already built in, I just wanted to show you that there's no magic
12:54:24 <basus> ohhh…
12:54:26 <basus> I see
12:54:30 <basus> that makes sense
12:55:13 <mustelo> basus, there are a lot of different monads, but very few of them are magical :)
12:55:58 <edwardk> reinh: no
12:56:06 <edwardk> reinh: layout isn't expressible in BNF
12:56:19 <mustelo> also fixity declarations right?
12:56:33 <ReinH> edwardk: makes sense. Now I have to learn a new grammar grammar :)
12:56:34 <edwardk> mustelo: well, most haskell parsers parse fixity after they do an initial pass
12:56:46 <ReinH> mustelo: I believe so
12:56:48 <basus> mustelo: yeah, I'm just starting out with Haskell so I'm trying to juggle a bunch of different concepts in my head at the same time, I decided to sit and write some code instead of just reading
12:56:52 <ReinH> "remove FixityResolution from the context-free grammar"
12:56:57 <edwardk> hey do one pass to get the general structure of things then reassociate
12:57:04 <edwardk> er they
12:57:06 <mustelo> I see
12:57:10 <ReinH> which makes me wonder... what is this context-free grammar
12:57:40 <Philippa> RTFHaskellReport :-)
12:57:40 <edwardk> in general in haskell context-free grammars tend to be recognized with applicative combinators and context sensitive ones with monadic combinators
12:58:01 <ReinH> edwardk: I only care about syntax hilighting, so I only need a subset of the grammar rules, probably
12:58:04 <edwardk> but that isn't a hard fact because over a finite alphabet applicative combinators can be context sensitive
12:58:17 <ReinH> I wonder if there's some context-free subset that I can use... maybe I'll check vim and erlang syntax rules
12:58:21 <edwardk> ReinH: i have some primitive syntax highlighting support baked into trifecta
12:58:30 <ReinH> afaik vim only supports context-free grammars
12:58:45 <ReinH> edwardk: trifecta? (I'm writing a CodeRay scanner)
12:58:47 <edwardk> yeah, there are some pretty decent haskell vim language bindings out there though
12:58:47 <Philippa> ReinH: you can do a lot with just lexical level stuff
12:58:54 <mustelo> edwardk, is there a formal statement of the fact that applicatives can't parse context sensitive grammars but monads can? (ie, if you don't have a finite alphabet)
12:58:59 <ReinH> Philippa: looks that way, fixity isn't important at this level
12:59:00 <earthy> vim's syntax highlightihg, afair, is limited to regexes
12:59:00 <ReinH> etc
12:59:04 <edwardk> you can't get it perfect, because of the interaction with layout
12:59:17 * hackagebot compressed 0.1.4 - Compressed generators and reducers  http://hackage.haskell.org/package/compressed-0.1.4 (EdwardKmett)
12:59:19 <Philippa> but yeah, it'd be nice if you had access to a layout stack so you could accurately recognise what types are
12:59:43 <ReinH> earthy: the rules are regexp based but iiuc they can be composed in ways that make it context-free
12:59:56 <ReinH> earthy: tbh I'm not sure
13:00:12 <edwardk> mustelo: well, the fact that they can work for finite alphabets comes from the fact that you can build an infinite tree with finite branching for each node, where the tree contains precisely those expressions recognized by the grammar
13:00:12 <earthy> hm, true, there's syntax groups
13:00:33 <edwardk> in the infinite token set case the tree doesn't have finite fanout and so isn't constructive
13:00:48 <ReinH> earthy: I skipped class on the days they talked about the chomsky hierarchy... and, also all the other days. ;)
13:00:50 <mustelo> hmm, so my question doesn't even really make sense then
13:00:57 <edwardk> basically =)
13:00:59 <ReinH> heh
13:01:27 <edwardk> reinh: have you looked at the haskell.vim syntax file?
13:01:39 <edwardk> philippa: btw- i started packaging up more parsers
13:01:43 <Philippa> cool
13:01:48 <edwardk> Philippa: a VPL layer is going in soon
13:01:55 <hpaste> mustelo pasted “szerf is this close to what you want?” at http://hpaste.org/50407
13:02:23 <augur> oh edwardk, you and you stuff
13:02:23 <augur> :P
13:02:29 <Philippa> :-) Is it introspectable enough to do full-scale grammar optimisations on like my own lib was intended to?
13:02:39 <edwardk> not exactly
13:02:46 <Philippa> (I don't know if I'll get round to it, my life is one personal crisis after another lately)
13:02:46 <ReinH> edwardk: I have, that's where I was planning on starting
13:02:50 <edwardk> in the applicative fragments, yes
13:02:56 <slom> hi, is there a way to use Parsec number parser (from Parsec.Token) without it eating trailing newlines?
13:02:59 <edwardk> in the monadic ones, no
13:03:01 <ReinH> but then I realized that a BNF might be easier. But THEN I realized that a BNF is impossible. :)
13:03:32 <ReinH> so now I'm back to the vim syntax file as a good approximation for the purposes of syntax hilighting
13:03:37 <edwardk> slom: not the parsec one, though trifecta exports a number parser for both cases
13:03:43 <ReinH> although iirc emacs handles a few things better
13:03:54 <ReinH> but I don't grok emacs syntax hilighting at all
13:03:56 <mustelo> szerf, did you see my paste?
13:04:01 <edwardk> and is otherwise parsec-like
13:04:03 <slom> edwardk: thanks I'll have a look :)
13:04:28 <szerf> ok
13:04:28 <mustelo> we need an @faq for "no parsec can't to that, but trifecta can!"
13:04:37 <edwardk> http://ekmett.github.com/trifecta/Text-Trifecta-Parser-Token-Prim.html#v:natural-39-
13:04:41 <edwardk> mustelo: =)
13:05:10 <edwardk> i'll have my parsing needs sated and move on to other things soon enough =P
13:05:10 <Philippa> edwardk: yeah, the applicative fragments were all I was looking at. I mean, I'm guessing you have an applicative, /intentionally/ context-sensitive fragment by now too?
13:05:32 <Philippa> mustelo: yeah. It's kind of impressive to see parsec 3 get topped for possibilities
13:05:34 <szerf> so how to write a function that take an integer as parameter and return a double ?
13:05:36 <thoughtpolice> edwardk: do you have any more plans for trifecta in the short term? i was about to start using it the other day
13:05:40 <edwardk> i have a toy parser that fits into my parsing class hierarchy that supports it but i haven't put it in the package yet
13:05:51 <thoughtpolice> (but got sidetracked by testing SSD performance :P)
13:05:52 <edwardk> thoughtpolice: i'm planning on keeping the major structure of it the same
13:06:16 <edwardk> the main thing that may go in is that the result type will probably pick up access to the interval map for highlighting
13:06:26 <mustelo> szerf, do you mean that function `pid4` in particular or just how to convert between Integers and Doubles in general?
13:06:26 <edwardk> so you can get highlighted source fragments in your error messages
13:06:34 <edwardk> and i may change the way the highlights are stored
13:06:41 <erus`> I'm making a minecraft MMORPG set in the fallout universe with kinetic controls. I will be releasing on the PC PS3 PS2 and gameboy advance. I will use haskell
13:06:47 <edwardk> but those should be relatively easy to integrate changes
13:07:23 <szerf> i mean in general
13:08:04 <edwardk> thoughtpolice: i'm also planning on adding support for my preprocessor, so the delta type may be enriched at some point
13:08:11 <Ptival> question: how do I tell vim NOT to indent anything in my .lhs files?
13:08:21 <mustelo> szerf, you want `fromIntegral` then
13:08:48 <szerf> but it dont work with me
13:08:56 <szerf> ghs still complaining
13:09:14 <mustelo> szerf, can you paste an example?
13:09:32 <szerf> ok
13:09:48 <szerf> pid4 :: (Integer a,Float b)a -> b
13:10:00 <szerf> pid4 0= 0.0
13:10:09 <szerf> pid4 x = (if even x then 1/fromIntegral(x)*2+1 else (-1/fromIntegral(x)*2+1))+pid4 (x-1)
13:10:17 <mustelo> szerf, I already gave you that one :)
13:12:33 <edwardk> i'll have a new version of intern in a few minutes as well
13:12:35 <hpaste> mustelo pasted “szerf, this?” at http://hpaste.org/50408
13:14:52 <szerf> please can you gave me a function that take an integer and return a double tha work properly ?
13:15:13 <mauke> fromIntegral
13:15:19 <mustelo> szerf, that paste works. what error message are you getting?
13:16:11 <szerf> he say that he cannot deduce the type
13:16:40 <Taejo> what is a good ratio of MUT/GC time?
13:16:53 <mustelo> szerf, that function typechecks fine on my machine: ghc 7.0.3.
13:17:14 <szerf> i have also ghs 7.0.3
13:17:39 <szerf> do i need to restart the prompt ?
13:17:41 <ricree> szerf, paste the exact contents and error message somewhere
13:18:02 <mustelo> (not in the channel, please)
13:18:42 <ricree> yes.  by somewhere, I meant hpaste.  I suppose saying that explicitly  would have been better
13:19:13 <basus> are there some demo projects I could do to get up and running with Haskell quickly? Preferably something that isn't a translation of a Lisp/Scheme project list.
13:19:43 <edwardk> project euler?
13:19:55 <ricree> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours was one of the early tutorials I did when I was trying to start doing something larger
13:20:00 <Eduard_Munteanu> > fromIntegral (3 :: Int) :: Double
13:20:01 <lambdabot>   3.0
13:20:05 <ricree> I'd definitely recommend it
13:20:19 <Eduard_Munteanu> szerf: you might need to tell it the return type you want
13:20:42 <szerf> i do
13:21:06 <Eduard_Munteanu> Well, what error do you get?
13:21:11 <ReinH> edwardk: looks nice
13:21:54 <basus> ricree: have been looking at that myself.
13:21:57 <ricree> szerf.  Like I suggested, go to http://hpaste.org/ and give us exactly what code you've written, and exactly what the error message is
13:23:01 <mornfall> Ok, GHC and binutils-gold don't mix.
13:23:10 <mornfall> At least not while building another GHC...
13:23:19 <hpaste> szerf pasted “error” at http://hpaste.org/50409
13:23:47 <ricree> szerf, the type signature is the problem
13:24:09 <mustelo> szerf, use the type signature from my paste. pid4 :: Integer -> Double
13:24:11 <szerf> where is the problem ?
13:24:29 <ricree> Integer and Float are types, rather than typeclasses
13:24:35 <elliott> Is there an easy way to get cabal-install to build a (preferably separate) build of my application than "cabal configure --enable-executable-profiling --ghc-options='-rtsopts'; cabal build"?
13:24:59 <slom> edwardk: whats the recommended way to install trifecta? should cabal work
13:25:11 <edwardk> yes, does it not?
13:25:21 <ricree> szerf,  when you have a signature like "(Real a, Integral b) => a -> b", a and b stand for any type that matches those classes
13:26:04 <ricree> szerf,  In this case, though, you aren't using typeclasses.  You want the function to be specifically Integer and Double
13:26:18 <Eduard_Munteanu> A typeclass isn't a type, it's more like an open collection of types.
13:26:21 <szerf> yes
13:26:53 <ricree> szerf, Since the 'a' and 'b', mean "any type with the given typeclasses", you need to get rid of them and make the function "Integer -> Double" instead
13:27:10 <Eduard_Munteanu> :t fromIntegral
13:27:12 <lambdabot> forall a b. (Integral a, Num b) => a -> b
13:27:29 <slom> I think my cabal is to old/broken then
13:27:47 <edwardk> slom: what version of haskell?
13:27:48 <roconnor> I wonder why the Haskell comittee choose lifted tuples.
13:27:51 <szerf> and if i would use typeclasses like Integral and Fractional instead how to do that
13:27:52 <edwardk> slom: and what error?
13:28:06 <edwardk> roconnor: they used to be unlifted
13:28:13 <roconnor> ?
13:28:15 <edwardk> roconnor: but the semantics were all screwy
13:28:17 <roconnor> when?
13:28:18 <mustelo> szerf, pid4 :: (Floating b, Integral a) => a -> b
13:28:24 <edwardk> 1.4ish
13:28:30 <roconnor> edwardk: I don't believe you
13:28:33 <Eduard_Munteanu> Unlifted as in a, b, c is (a, (b, c)) ?
13:28:35 <elliott> hmm, maybe I should look at the cabal wrappers
13:28:44 <edwardk> it was one of the big changes when they put fail in monad
13:28:52 <edwardk> it was because the notion of irrefutable patterns largely went away
13:28:53 <slom> edwardk: ghc 6.12.1 cabal-install 0.8.0
13:28:53 <edwardk> =P
13:29:00 <edwardk> ah
13:29:06 <edwardk> the cabal install you have is ancient
13:29:11 <slom> fails in resolving dependencies for container
13:29:12 <Eduard_Munteanu> Or how do you call that?
13:29:13 <elliott> edwardk: which was the last Haskell report that didn't screw everything up? :P
13:29:37 <edwardk> elliott: 98 was pretty good aside from the wave of monomorphization
13:29:56 <elliott> edwardk: excuse me, monad comprehensions
13:30:00 <edwardk> roconnor: miranda also had unlifted tuples, though you could kind of peek and see they weren't properly unlifted
13:30:14 <roconnor> edwardk: peek with seq?
13:30:16 <edwardk> elliott: we got them to fix that ;)
13:30:20 <edwardk> roconnor: yeah
13:30:27 <Philippa> edwardk: and the operator fixity stuff, to be fair
13:30:36 <elliott> edwardk: what, they've been accepted? Or are you just referring to the ghc extension
13:30:41 <Philippa> 98 patched with fixity-as-second-pass, sure
13:30:45 <edwardk> elliott: ghc extension
13:30:48 <elliott> edwardk: riht
13:30:56 <elliott> (hey guys, n+k patterns)
13:31:02 <edwardk> now dead
13:31:06 <roconnor> edwardk: what am I looking for in the Haskell 1.4 report that will show me that the tuples are unlifted?
13:31:11 <elliott> edwardk: they live on in our hearts
13:31:34 <Philippa> elliott: and in your view patterns, if you really insist
13:31:41 <szerf> thanks
13:31:55 <elliott> Philippa: haha, you actually can do (subtract 9 -> n) can't you
13:31:56 <elliott> that's awesome
13:32:10 <elliott> now someone just has to propose to specifically ban using subtract there
13:32:35 <edwardk> first they'd have to standardize view patterns =P
13:33:06 <elliott> the haskell standard is available at haskell.org/ghc in executable form for any platform that already has it
13:34:55 <roconnor> edwardk: oooh in Haskell 1.4 newtypes have multiple paramters
13:35:26 <elliott> roconnor: multiple type parameters? I thought that was standard
13:35:32 <elliott> or multiple fields? in which case, weird
13:35:37 <roconnor> elliott: er, multiple fields
13:35:52 <roconnor> oh wait
13:35:53 <roconnor> you are right
13:35:54 <elliott> roconnor: I guess it's kind of like an unboxed tuple?
13:35:57 <roconnor> they are multiple paramters
13:36:00 <roconnor> type parameters
13:36:02 <roconnor> okay
13:36:03 <elliott> right
13:36:05 <edwardk> =)
13:36:18 <edwardk> did you ever get around to believing me?
13:36:20 <roconnor> Unlike algebraic datatypes, the newtype constructor N is unlifted, so that N _|_ is the same as _|_.
13:36:32 <roconnor> edwardk: nope.  I've found partial evidence that you are wrong
13:36:43 <elliott> edwardk: you should port data-lens to multiple-field newtypes so it can run on roconnor's mental 1.4 compiler :P
13:36:50 <copumpkin> edwardk wrong??
13:36:56 <copumpkin> surely you must be wrong
13:36:57 <elliott> roconnor: clearly tuples just aren't algebraic
13:36:58 <edwardk> hey, dolio sold me on this one
13:37:01 <edwardk> ;)
13:37:12 <copumpkin> roconnor: it isn't looking good
13:37:29 <ocharles> Hrm, if I have: doSomething a b = (something "here") $ BuildObject a b, can that be written without the "a" and "b"
13:37:31 <ocharles> (point free?)
13:37:50 <Peaker> @pl doSomething a b = (something "here") $ BuildObject a b
13:37:51 <lambdabot> doSomething = (something "here" .) . BuildObject
13:37:59 <ocharles> ah
13:38:00 <ocharles> extra .
13:38:04 <Peaker> @where SEC
13:38:04 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
13:38:09 <copumpkin> or .:
13:38:11 <edwardk> hrmm, mayhap i misrecalled
13:38:16 <ocharles> :t (.:)
13:38:16 <Peaker> ocharles: If you read about SECs above it should clear it up
13:38:17 <copumpkin> doSomething = something "here" .: BuildObject
13:38:17 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
13:38:19 <elliott> is there a package with (.:) yet
13:38:21 <ocharles> Peaker: excellent, thank you!
13:38:22 <edwardk> dolio just said miranda only
13:38:27 <copumpkin> @hackage dotcolon
13:38:27 <lambdabot> http://hackage.haskell.org/package/dotcolon
13:38:28 <elliott> ocharles: ignore the caleskell behind the function ((.:) is not standard)
13:38:35 <elliott> and it wouldn't be for Functors if it was
13:38:39 <Peaker> (.:) is just a special case...
13:38:51 <roconnor> hey
13:38:57 <roconnor> Haskell 1.4 has a Void type
13:38:58 <roconnor> man
13:39:01 <elliott> s/function/curtain/
13:39:07 <elliott> roconnor: haha
13:39:11 <roconnor> Haskell 1.4 is so much better than Haskell 98
13:39:12 <Peaker> in 5-10 years, maybe Haskell will catch up with Haskell 1.4
13:39:13 <ocharles> I wonder if hlint can be patched to hint about SECs
13:39:15 <edwardk> they had 'unfailable patterns'
13:39:23 <elliott> roconnor: we just need support in modern GHC
13:39:31 <ocharles> so if I stuck my above example into hlint, it would suggest .) ., or .:, or whatever
13:39:33 <elliott> I'll do my bit to port my code
13:39:42 <roconnor> elliott: well, GHC does support the Void declairation with some flag
13:39:46 <Peaker> ocharles: hlint doesn't suggest points-free code in general
13:39:52 <ocharles> for a reason?
13:39:52 <Peaker> ocharles: but it does such eta reductions if those are possible
13:39:57 <monochrom> does haskell 1.4 newtype allow "newtype X = X" i.e., not even one field?
13:39:58 <elliott> roconnor: yeah, but that's not standard :D
13:40:06 <ocharles> Peaker: i've seen some reductions, like redundant brackets
13:40:07 <roconnor> monochrom: I'm not sure
13:40:09 <elliott> monochrom: roconnor was mistaken, itw as multiple type parameters
13:40:09 <Peaker> ocharles: points-free isn't considered "better" in all cases, it's a matter of style
13:40:13 <elliott> or are you asking it separately?
13:40:16 <ocharles> Peaker: I guess
13:40:33 <roconnor> elliott: though in Haskell 98 I define newtype Void = Void Void
13:40:37 <Saizan> ocharles: hlint suggestions are configurable
13:40:39 <ocharles> I'm quite fond of it, when it has a type signature with it
13:40:51 <Peaker> ocharles: I guess most hlint suggestions are about style :-) But stuff in the consensus.. You can always points-free your code, you don't always want to
13:40:55 <ocharles> Saizan: I know, I just happen to agree with all the ones I've got :)
13:41:01 <ocharles> Peaker: true
13:41:08 <elliott> roconnor: yeah, I've seen void
13:41:18 <elliott> err, oh wait
13:41:20 <elliott> void is edwardk's :)
13:41:26 <elliott> ...same implementation, though
13:41:36 <edwardk> hah
13:41:47 --- mode: ChanServ set +o copumpkin
13:41:54 <elliott> hmm, i see it uses optional DeriveDataTypeable
13:41:55 --- mode: copumpkin set -b armido!*@*
13:42:01 <edwardk> void?
13:42:09 <elliott> wouldn't it be simpler just to write the instances?
13:42:10 --- mode: copumpkin set -o copumpkin
13:42:10 <elliott> edwardk: yeah
13:42:14 <edwardk> maybe
13:42:20 <elliott> well
13:42:24 <elliott> I guess Data instances are a pan
13:42:27 <elliott> ...pain, but also pan
13:42:28 <edwardk> yeha
13:42:36 <edwardk> yeah, but also yeha
13:42:43 <elliott> yeha they're a pan
13:43:10 <thoughtpolice> edwardk: 'your' preprocessor? like CPP? what sort of amazing things does it do?
13:43:16 <ocharles> While people are around, I hope you don't mind me repeating a previous question...
13:43:27 <roconnor> elliott: nope.  newType X = X is not allowed.  Haskell '98 allowed newtypes to get a field name.  That's good.
13:43:32 <ocharles> if I'm working on a library, should I use MonadIO m => m (), or IO ()? The former seems much more general, and convenient
13:43:44 <ocharles> but from what I can see, MonadIO is not part of the current platform, I could be wrong though
13:43:44 <edwardk> thoughtpolice: chunked parallel preprocessing
13:43:58 <elliott> ocharles: the former may be more general, but have fun writing liftIO everywhere
13:44:08 <ocharles> elliott: I thought it *saved* me writing liftIO
13:44:11 <c_wraith> elliott: that's the opposite
13:44:11 <elliott> ocharles: if your type is literally just "MonadIO m => m ()" then nothing is lost if you make it IO () and everyone else can lift it
13:44:14 <monochrom> use IO () first
13:44:20 <elliott> c_wraith: no?
13:44:21 <edwardk> find the directives in parallel, then evaluates enough of the preprocessing skeleton to proceed
13:44:26 <elliott> the Prelude uses IO explicitly everywhere
13:44:28 <elliott> so liftIO abounds
13:44:30 <thoughtpolice> edwardk: ah, very cool
13:44:36 <edwardk> deferring macro expansion in each chunk til later
13:44:37 <roconnor> edwardk: I'm 85% sure that even Haskell 1.4 had lifted tuples
13:44:44 <ocharles> :t liftIO
13:44:44 <c_wraith> elliott: once per function, at most.
13:44:45 <lambdabot>     Ambiguous occurrence `liftIO'
13:44:45 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
13:44:45 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
13:44:57 <edwardk> roconnor: dolio just informed me i'd conflated two historical bad ideas
13:45:03 <edwardk> they had unfailable patterns
13:45:04 <ocharles> elliott: well in this case, m is indeed just IO a
13:45:13 <edwardk> not irrefutable patterns
13:45:14 <roconnor> edwardk: and I'm now 96% sure that Haskell 1.4 is better than Haskell 98
13:45:14 <elliott> c_wraith: Well, sure...
13:45:24 <ocharles> I just thought it'd be nice to avoid liftIO, because in my other code, I'm already in MonadIO a (but not IO a)
13:45:28 <elliott> ocharles: MonadIO might also have a runtime penalty unless you use SPECIALISE pragmas
13:45:36 <roconnor> edwardk: oh, what is an unfailable pattern?
13:45:39 <elliott> I made some code twice as fast by eliminating a monad typeclass
13:45:43 <edwardk> so they did remove something in 1.4 to 98 that made tuples less nice
13:45:59 <edwardk> do (a,b) <- …   didn't induce a MonadFail constraint
13:46:04 <c_wraith> really, the main reason to not automatically use MonadIO is that it's not standard.  Even though it is part of mtl, so in the platform
13:46:09 <ocharles> heh, it's gonna take me a while to even care about speed, seeing as my naive haskell consistently blows anything else I've written out of the water :)
13:46:15 <edwardk> 98 introduced fail into Monad
13:46:21 <edwardk> when they took that away
13:46:25 <roconnor> ocharles: blows in a good way or a bad way?
13:46:34 <ocharles> very good
13:46:36 <roconnor> :O
13:46:44 <dolio> roconnor: An unfailable pattern is a pattern that can only be refuted by bottom.
13:46:45 <roconnor> ocharles: what is Haskell compeating agains?
13:46:50 <ocharles> Perl, in this case
13:46:51 <roconnor> dolio: ugh
13:46:52 <ocharles> Perl + Moose
13:47:06 <elliott> edwardk: I kind of think failing pattern matches using fail is a bad idea anyway
13:47:06 <ocharles> Perl + Moose that's trying to be so "standard" now, it can't even construct objects fast enough
13:47:13 <dolio> If you do a monadic match on an unfailable pattern, you don't need to branch.
13:47:19 <elliott> edwardk: even though I exploit it extensively in my program to avoid a use right-leaning tower of cases...
13:47:25 <elliott> well, hmm
13:47:39 <elliott> primarily I use it through a function which does it for Maybe, so I guess I could do it without :)
13:47:55 <dolio> So you could do a match with just a Monad constraint, instead of MonadZero.
13:48:19 <dolio> In 98, they got rid of unfailable patterns, and replaced it with fail.
13:48:27 <lispy> I see that cabal-rpm is no longer maintained.  What do the centos/redhat folks use these days?
13:48:42 <elliott> ocharles: I wrote a Perl program using that Moose extension that adds proper class and method syntax
13:48:47 <elliott> it took like two seconds just to start running
13:48:51 <ocharles> yep
13:48:54 <ocharles> sounds about right
13:49:03 <elliott> a small program at that
13:49:11 <ocharles> it could be a noop, and you have that overhead
13:49:28 <ocharles> at runtime, things are a bit nicer, but even then a perl subroutine call has a lot of overhead
13:49:49 <ocharles> I just generally hate the language, after being bitten by Haskell. I'm still really skeptical when I compile, and run my code, and it just works
13:50:14 <elliott> ocharles: anyway, my full opinion on MonadIO is that it would be nice, if all the libraries in base did it too
13:50:18 <elliott> but they don't, so oh well
13:50:23 <conal> Axman6: ping
13:50:27 <ocharles> ok, so it's better to be consistent
13:50:34 <elliott> well, that's my opinion, others may have better ones :)
13:50:40 <ocharles> :)
13:52:49 <elliott> meh, I guess I'll just define an alias for that cabal line
13:53:19 <elliott> I hate how --make doesn't realise that -rtsopts requires a relink
13:55:30 * edwardk feels dirty. I just lied to Typeable
13:56:18 <elliott> edwardk: eek
13:56:20 <ion> Were you under oath?
13:56:33 <edwardk> no bible was presented
13:56:56 <elliott> I think the standard unsafeCoerce ritual should clear you
13:57:04 <geheimdienst> just remember that bible or no, ceiling cat is watching you
13:57:32 <edwardk> > fix unsafeCoerce
13:57:33 <lambdabot>   Not in scope: `unsafeCoerce'
13:57:35 <edwardk> bah
13:58:04 <dolio> roconnor: Anyhow, I think unfailable patterns are preferable to fail.
13:58:24 * copumpkin makes a rewrite rule to rewrite unsafeCoerce :: a -> a to id
13:58:25 <dolio> And it's not something you'd usually have to think about.
13:58:56 <elliott> copumpkin: Isn't unsafeCoerce's implementation basically unsafeCoerce id? :P
13:59:04 <dolio> Although I'm sure we'd get an increased number of newbie questions about, "why is this function MonadPlus instead of Monad?"
13:59:06 <monochrom> how was unfailable patterns done? something has to prove that "x:xs <- getLine" does not fail, right?
13:59:17 <edwardk> dolio: so be it
13:59:21 <dolio> No, that one just goes in MonadZero.
13:59:23 <copumpkin> elliott: it already is id on a -> a
13:59:32 <copumpkin> so that's why I want a rule setting that in stone!
13:59:40 <dolio> There's no flow analysis about what actually can't fail.
13:59:56 <dolio> It's just that (x,y) can't fail because there are no other constructors for tuples.
13:59:58 <elliott> dolio: I still don't get why do { x:xs <- y; ... } should not be the same as y >>= \(x:xs) -> do {...}
14:00:05 <elliott> it seems inconsistent
14:00:07 <monochrom> I see. thanks
14:00:31 <shachaf> @undo do { x:xs <- y; dotdotdot }
14:00:32 <lambdabot> y >>= \ a -> case a of { x : xs -> dotdotdot; _ -> fail ""}
14:00:52 <elliott> I'm surprised undo is smart enough for that
14:01:02 <ion> It’s rather smart.
14:01:11 <elliott> Smarter than pl :P
14:01:14 <monochrom> computer programs are smarter than humans
14:01:15 <dolio> Because it's nice to be able to write things like "Just x <- m ; ..." and have the failure case be specific to your monad.
14:01:19 <ion> @undo [ succ x | x <- [0..], x < 5 ]
14:01:20 <lambdabot> concatMap (\ x -> if x < 5 then [succ x] else []) [0 ..]
14:01:28 <phyro> monochrom: not at solving captchas ;d
14:01:37 <dolio> Instead of bombing out with a pattern match error, which would make the matches useless.
14:01:39 <elliott> dolio: I agree, but it still seems like that should be a separate construct.
14:01:44 <elliott> "ensure (x:xs) <- ..." or something.
14:01:55 <elliott> It just makes do notation harder to translate, and it's easy to miss when it's being used.
14:02:05 <dolio> Why are you making me type extra syntax for the non-useless case?
14:02:54 <elliott> dolio: I don't see how that's the useless case, if you know that it won't be [] (yes, wouldn't it be wonderful if we had no partial functions and the type system knew everything, but we don't have dependent types)
14:03:10 <dolio> I don't care about a Haskell compiler having to be slightly more clever about translating do notation.
14:03:17 * frerich_ writes his first literate haskell program and notices it's a very pleasant experience!
14:03:19 <elliott> I'd dislike it less if it didn't just create a "user error" that's hard to distinguish from other fails
14:03:33 <elliott> dolio: I meant for humans.
14:03:41 <shachaf> It would be nice if it added a MonadZero constraint. :-)
14:03:51 <dolio> Humans don't have to desugar do notation. They just use do notation.
14:04:05 <elliott> dolio: Except when refactoring things to make them pointfree.
14:04:06 <acowley> This looks pretty neat to me: https://www.fluxflex.com/
14:04:47 <dolio> I don't care about people who are OCD about point-freeness, either.
14:05:15 <roconnor> frerich_: they are good for blogs too
14:05:18 <elliott> dolio: "Refactors one thing to point-free style" --> "OCD about point-freeness"?
14:05:30 * acowley cares about lots of things
14:05:56 <acowley> roconnor: the only sticky part is the final step of getting pandoc html into a CMS
14:06:03 <dolio> Do you think matches should throw errors in list comprehensions, too?
14:06:17 <acowley> roconnor: I tend to generate standalone html then manually edit the resultant document to be cut-and-pasted
14:06:22 <luite> acowley: what's the difference between that and heroku?
14:06:52 <elliott> dolio: No. But I view the <- there as a rather different beast to do notation's.
14:06:59 <elliott> (I realise it is not different in practice.)
14:07:01 <dolio> Well, I'm afraid it isn't.
14:07:03 <acowley> luite: I don't really know as I haven't kept up with heroku! But if they automatically pull from github and support haskell right out of the gate, it seems at least promising.
14:07:03 <roconnor> acowley: I'm pretty lame and just write bird ticks inside <pre> elements.
14:07:16 <dolio> In fact, list comprehensions are now monad comprehensions when you flip a switch.
14:07:33 <luite> acowley: oh you have to push to heroku yourself, but that's hardly more work than them pulling from github :)
14:07:33 <dolio> And they were back in 1.4, too.
14:07:36 * brisingr - gone to bed early; a first
14:07:56 <luite> acowley: and yesod has heroku support in the next release
14:08:12 <dolio> roconnor: By the way, I think 96% sure is too low.
14:08:12 <acowley> luite: I read about that, but it didn't sound entirely trivial to me
14:08:16 <luite> although you must upload your binaries to them
14:08:25 <luite> so it takes a while
14:08:34 <acowley> roconnor: don't you lose syntax highlighting that way?
14:08:40 <elliott> You could add a post-push hook
14:08:45 <elliott> or use GitHub's service notification stuff
14:09:17 <acowley> luite: statically linked GHC-produced executables are rather large
14:09:20 <dolio> elliott: I mean, I can replace do-notation with list comprehensions in all your arguments.
14:09:22 <dolio> What if I want to refactor my list comprehension to make it point-free.
14:09:22 <elliott> "service hook"... doesn't support Heroku natively, but it will POST to any address you want
14:09:36 <dolio> Then I can't just write concatMap (\(x:xs) -> ...)
14:09:46 <elliott> dolio: in the list comprehension case, you almost certainly intend to be filtering out
14:09:56 <elliott> in the monad case, usually fail is going to end up just spewing an error
14:10:08 <luite> acowley: indeed, there are some plans to improve that with a binary diff program, but it's probably rather low priority
14:10:12 <dolio> Usually fail shouldn't exist.
14:10:12 <elliott> so you're much more likely to be doing it without intending to exploit it
14:10:25 <elliott> dolio: I agree
14:10:39 <acowley> what I really want is a cloud hosting solution that makes it really easy for me to periodically run somethign on a machine with a lot of cores and the option to use a GPU
14:11:09 <luite> hmm, looks like you need plain old ec2 with cloudhaskell then :p
14:11:19 <acowley> luite: if fluxflex can be made to rebuild things on the server, that seems like a plus to me, but I don't know any of the details
14:11:21 <dolio> But when something like fail does exist, it's the right way to desugar partial matches.
14:11:40 <acowley> luite: ec2 does what I want, but whenever I use it it's a chore
14:11:46 <dolio> Because otherwise you shouldn't be using partial matches, because, "I'm sure it isn't partial," isn't a very good excuse.
14:12:04 <dolio> Or you should declare that you're sure with ~, I suppose.
14:12:15 <luite> acowley: yeah something more automated could help
14:12:58 <acowley> luite: it's also a little slow to spin up. I want a machine waiting for me to log in that's run by someone who will meter my CPU usage.
14:13:29 <luite> acowley: do you need root access?
14:13:34 <acowley> luite: no
14:15:11 <int80_h> This is a problem domain question. I bring it here because I'm only intersted in it insofar that it looks like an interesting problem to solve in Haskell. A friend of mine proposed an Open Source project that modernizes NNTP by implementing security at the protocol level (as opposed to running NNTP through tunnel). This questions occurs to me, "Does it make sense to do this, or is NNTP through a tunnel good enough?"
14:15:26 <elliott> People use NNTP?
14:15:36 <int80_h> we think NNTP may be due for a comeback
14:15:44 <elliott> Really.
14:15:44 <nazgjunk> Lots of people do.  Pretty sure most traffic on it is warez, though
14:15:45 <int80_h> in response to the walled gardens popping up everywhere.
14:15:53 <elliott> nazgjunk: Well, sure.
14:16:06 <elliott> int80_h: So people are going to move from Facebook to... Usenet?
14:16:07 <monochrom> I still use NNTP
14:16:41 <int80_h> elliott: I'm not thinking that far ahead. That's application level. I'd work on this, and see what happens with it.
14:16:57 <int80_h> If we're right, people will figure out what to do with it.
14:17:15 <elliott> I've definitely heard that a million times, but okay.
14:17:44 <monochrom> if you do it right, your own secure nntp is better than nntp+stunnel. if you do it wrong, worse than.
14:17:53 <int80_h> but I don't see how this is better than NNTP thorough a tunel. I'd need to be convinced of that before moving forward.
14:18:00 <int80_h> ah!
14:18:21 <int80_h> good enough monochrom. I'm willing to go through many design iterations in order to get it right.
14:18:45 <monochrom> a person not learned in secure protocols has 99% chance of doing it wrong
14:18:46 <mustelo> what would be better about it?
14:19:04 <int80_h> monochrom: I trust my mentors.
14:26:58 <int80_h> monochrom: do you have any book recommendations? I found this, and it looks like I would need it. http://www.schneier.com/book-applied.html
14:27:19 <peteriserins> if nd_merge was implemented as follows https://gist.github.com/1152744 (merges a list by taking earliest available heads repeatedly), the unused head thread would be discarded and not reused for the next iteration, yes? I'm assuming amb as in Data.unamb.
14:27:55 <peteriserins> If so, is there a way to circumvent this and have amb continue evaluating the "other result"?
14:28:42 <elliott> that won't work
14:28:44 <elliott> amb returns (IO a)
14:28:52 <elliott> because it is not referentially transparent
14:29:10 <elliott> (unamb a b) is, but has the additional constraint that when a =/= _|_ and b =/= _|_, a = b
14:31:03 <dolio> unamb is not referentially transparent, either.
14:31:16 <dolio> It's just accompanied with a, "don't do bad stuff," warning.
14:31:34 <Peaker> well, head is total, but has the additional constraint that the input isn't an empty list :)
14:32:05 <elliott> dolio: It's referentially transparent if you satisfy the precondition.
14:32:10 <elliott> I guess Peaker's snark is right
14:32:21 <mornfall> You could say that about unsafePerformIO, I guess.
14:32:25 <elliott> But it's easy to use amb in a way that is always safe without wrapping it with conditions
14:32:30 <elliott> Not so much for head
14:32:42 <elliott> Well, s/easy/possible/ to make that a more objective statement
14:32:51 <elliott> I guess head (if null xs then [99] else xs) works too :-P
14:33:39 <dolio> I mean, you could say that about anything.
14:33:44 <dolio> :)
14:33:59 <peteriserins> elliott: are you saying that the function won't work at all?
14:34:09 <Peaker> unamb is useful in the same sense that unsafePerformIO is useful -- when you're very very careful :-)
14:34:11 <elliott> peteriserins: Your code has an obvious type error.
14:34:13 <dolio> <X> is referentially transparent when you satisfy the conditions for it being referentially transparent. :)
14:34:21 <Peaker> I guess you don't have to be quite as careful as with unsafePerform
14:34:23 <elliott> peteriserins: You can write nd_merge so that it works in IO.
14:34:34 <elliott> Or you can figure out a way to express it without violating unamb's constraint and do it purely.
14:34:39 <elliott> (Well, if that is possible.)
14:35:08 <peteriserins> elliott: do I have to replace xs, ys with return xs etc.?
14:35:21 <elliott> peteriserins: You probably want to use do notation.
14:35:36 <elliott> "where choice = amb ..." choice here is an (IO Integer), not an Integer.
14:35:44 <elliott> (Well, probably (Num a) => IO a, but I'm trying to make this simple, so sssh.)
14:35:46 <Younder> do notation = monads
14:36:20 <Younder> I really think you don't
14:36:33 <peteriserins> elliott: so it would be something like do { choice <- amb ...; case .. } ?
14:36:41 <elliott> Younder: He's using amb, so yes, yes he does.
14:36:56 <elliott> peteriserins: Yes.
14:37:13 <peteriserins> elliott: ok, and the original question in that case?
14:37:36 <elliott> peteriserins: Yes, the thread will be discarded, but it's a GHC thread, not an OS one (I think).
14:37:42 <elliott> So it is less expensive than you might think.
14:38:13 <peteriserins> elliott: also, I don't think it's possible to write it with unamb as the function will be impure
14:38:41 <peteriserins> elliott: I'm not worried about the overhead of threading, more about wasted computation within the threads
14:39:10 <elliott> peteriserins: My hunch is that you want to write the whole thing as something like "join $ amb (f xs) (f ys)".
14:39:25 <elliott> where f :: [a] -> IO [a]
14:39:36 <elliott> Err, hmm.
14:39:40 <elliott> That won't do what you want.
14:39:46 <elliott> Oh, yes it would.
14:41:10 <elliott> peteriserins: http://hpaste.org/50410
14:41:14 <elliott> That might do the trick.
14:41:26 <elliott> You'll need to import Control.Applicative for the operators I used on the last line.
14:41:30 <elliott> Oh, oops, they're wrong.
14:41:33 <Younder> I think I am breaking into a Haskell discussion without the faintest clue what I am talking about and I should probably just shut up
14:41:42 <elliott> peteriserins: Last line should be         f (x:xs) ys = (x :) <$> nd_merge xs ys
14:44:39 <elliott> peteriserins: If that doesn't work, it's probably my fault :)
14:45:55 <peteriserins> elliott: if I understand correctly, the slowest f's results will still be discarded
14:46:21 <peteriserins> elliott: so say if head xs can be computed faster than head ys, we will be recomputing head ys again in the next iteration
14:47:21 <elliott> peteriserins: Maybe you want "amb (maybeHead xs) (maybeHead ys)", where maybeHead [] = Nothing; maybeHead (x:_) = x
14:47:36 <elliott> Or something along those lines
14:50:16 <elliott> peteriserins: Oh, that joining amb nonsense is unnecessary, it's provided in Data.Unamb as "race".
14:50:32 <elliott> peteriserins: At this point I'd just write my own threaded code using MVars or something.
14:51:10 <peteriserins> elliott: it's not really a real-world problem for me know :). Just something that interested me
14:52:15 <peteriserins> elliott: the motivation is being able to get good approximations as fast as possible for, say, the sum of two lazily approximated values
14:52:54 <elliott> peteriserins: Don't you want a sort of zipWith then? Maybe I'm misunderstanding.
14:53:17 <peteriserins> elliott: that might not be fastest
14:53:33 <elliott> I don't see how your code does summation.
14:53:44 <peteriserins> elliott: say you have a function that approximates very fast (e.g., using binary search) and another that is really slow, but has an initial bound that is workable
14:54:03 <peteriserins> elliott: I reduced to a simpler problem which I found in a paper
14:54:36 <elliott> OK. Well, I'm no expert.
14:58:45 <peteriserins> elliott: wait, are you by any chance Conal Elliott?
15:00:00 <c_wraith> no, Conal goes by "conal" here.
15:00:08 <elliott> peteriserins: No, but please feel free to assume I am
15:00:36 <elliott> I'm also not the owner of the nick elliottt, hope this makes things less confusion :)
15:00:46 <elliott> confusing.
15:01:28 <peteriserins> elliott: ah, I see :), this whole investigation was actually spun off by a blog post on his on improving intervals
15:07:37 <dgpratt> preflex: seen jutaro
15:07:38 <preflex>  jutaro was last seen on #haskell 1 day, 23 hours, 56 minutes and 19 seconds ago, saying: dgpratt: leaving now for bed.
15:08:02 <elliott> heh
15:09:56 <peteriserins> preflex: seen conal
15:09:57 <preflex>  conal was last seen on #haskell 1 hour, 19 minutes and 36 seconds ago, saying: Axman6: ping
15:18:22 <_habnabit> is there a function or simpler way of doing something like \f g a b -> f (g a b)
15:18:45 <_habnabit> i.e. (a -> b) -> (c -> d -> a) -> c -> d -> b
15:19:03 <c_wraith> _habnabit: not in the prelude, but others tend to define things like that.
15:19:13 <c_wraith> .: is a common name for that.
15:19:18 <_habnabit> ah.
15:19:32 <peteriserins> sort of like apply?
15:19:51 <c_wraith> peteriserins: it's more of a composition operator
15:20:01 <c_wraith> :t (.:) -- this version is defined in lambdabot
15:20:01 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
15:20:15 <_habnabit> yeah, I called it `compose12` from the respective arities
15:20:24 <peteriserins> c_wraith: ah indeed, the brackets around g a b
15:20:42 <c_wraith> :t negate .: (+)
15:20:43 <lambdabot> forall a. (Num a) => a -> a -> a
15:20:53 <c_wraith> :t (negate .: (+)) 4 7
15:20:54 <aavogt>  (f .) . g   -- doesn't look that bad
15:20:54 <lambdabot> forall a. (Num a) => a
15:20:59 <c_wraith> > (negate .: (+)) 4 7
15:21:00 <lambdabot>   -11
15:24:31 <DukeDave> So I'm just 'cabal-ising' some code for a project, I've split into a "Library" part and an "Executable".
15:24:33 <DukeDave> I assume I am okay to define both in the same .cabal?
15:24:55 <DukeDave> However, when I "cabal build"
15:25:52 <DukeDave> It appears to compile everything twice, first all the library code, and then all the library code again plus the executable code :|
15:27:06 <Saizan> with recent enough cabal you can put the executable sources in a different hs-source-dirs: and have the library appear in the executabel build-depends to avoid that
15:27:48 <abc> which package you guys recommend, text or compactsring?
15:28:10 <Peaker> what's compactstring? :P
15:28:24 <Peaker> afaik the text package is the de-facto standard in its niche
15:28:48 <DukeDave> Saizan: Cool, I just figured that out:
15:28:50 <DukeDave> "... refers to a library which is defined within the same package. To use this feature the package must specify at least 'cabal version: >= 1.8'."
15:28:51 <Peaker> http://hackage.haskell.org/package/compact-string says it's obselete
15:28:57 <Peaker> "This package is obsolete: use text instead."
15:30:54 <tonkman> Hi, I have a [Word8] or a bytestring, that represents an image
15:31:09 <lispy> DukeDave: yup, requires that >= 1.8 clause
15:31:19 <tonkman> and I want to use that as a texture in opengl
15:31:21 <lispy> DukeDave: also, you should use cabal-dev instead of cabal :)
15:31:30 <lispy> tonkman: okay
15:31:38 <lispy> tonkman: I have some example code, hang on
15:31:40 <tonkman> so I need a pointer to that array?
15:32:04 <lispy> tonkman: https://github.com/dagit/nehe-tuts/blob/master/Util.hs
15:32:04 <DukeDave> lispy: cabal-dev ?
15:32:08 * DukeDave Googles
15:32:31 <lispy> DukeDave: http://www.reddit.com/r/haskell/comments/f3ykj/psa_use_cabaldev_to_solve_dependency_problems/
15:32:58 <int80_h> hey lispy! haven't seen you around for awhile
15:33:03 <tonkman> lispy: cool, thanks
15:33:03 <lispy> tonkman: are you using OpenGL or OpenGLRaw?
15:33:16 <lispy> int80_h: I've been around but not much lately.
15:33:19 <tonkman> OpenGL
15:33:37 <tonkman> Im just messing around with it
15:33:52 <lispy> tonkman: Okay, so in that github repo (nehe-tuts) there are lots of examples, but they currently use OpenGLRaw.  The previous version used OpenGL
15:34:21 <lispy> tonkman: I found that OpenGLRaw more closely matches the C version of OpenGL so it's easier to wrap my head around
15:34:40 <DukeDave> lispy: Oh, cute, thanks :)
15:34:55 <tonkman> that might be more suitable for me too
15:36:07 <lispy> tonkman: the nehe-tuts (also on hackage, cabal-dev install nehe-tuts) correspond to these tutorials: http://nehe.gamedev.net/  (look on the right side bar for legacy tutorials)
15:36:28 <lispy> tonkman: I was translating them to learn the Haskell bindings
15:36:35 * lispy disappears again
15:36:39 <tonkman> :)
15:37:03 <elliott> I wonder if GPipe should be using OpenGLRaw
15:37:18 <elliott> lispy: NeHe still exists?
15:37:38 <lispy> elliott: yup, and the site was updated recently to start adding opengl 4.x stuff
15:37:42 <DukeDave> Hmm, cabal is still compiling everything twice, even though my Executable has the library name
15:37:44 <DukeDave> (which I assume is just the same name as the .cabal file) in its Build-Depends :(
15:37:51 <tonkman> Im just doing simple 2D stuff so, I think, that it does not matter what library I use
15:37:59 <lispy> DukeDave: and you made sure that it says >= 1.8 in the file?
15:38:05 <Saizan> DukeDave: did you use distinct hs-source-dirs ?
15:38:11 <lispy> tonkman: you might want to use gloss instead in that case
15:38:17 <DukeDave> Saizan: "Cabal-Version:      >=1.8"
15:38:30 <lispy> tonkman: http://trac.haskell.org/gloss
15:38:42 <Saizan> DukeDave: that's not what i asked :)
15:38:43 <DukeDave> cabal doesn't complain about anything, it just builds everything twice.
15:38:43 <lispy> tonkman: er, I mean this url: http://trac.ouroborus.net/gloss :)
15:39:04 <DukeDave> Saizan: Sorry!
15:39:05 <lispy> tonkman: it's on top of opengl/glut but it makes 2d animations nicer, or so I've heard
15:39:09 <Saizan> you've to put the source files of the library in a different directory
15:39:11 <tonkman> looks simple
15:39:12 <elliott> hmm, my cabal file has "cabal-version: >= 1.2", is that bad? :)
15:39:24 * lispy is gone for real
15:39:27 <DukeDave> Saizan: Aha, that'll be it then!
15:39:42 <DukeDave> I have both library and test code in my src/ dir
15:40:42 <Saizan> the hs-source-dirs field in a Library or Executable section points cabal to the directory(ies) that contain the sources for that component
15:41:05 <tonkman> Is gloss fast enough to be used in games
15:41:17 <Saizan> you want to keep them in different dirs because otherwise ghc will ignore the installed library modules
15:41:29 <tonkman> it looks promisign
15:41:45 <elliott> gloss has no input facility afaik
15:41:52 <elliott> oh, yeah it does
15:42:03 <elliott> http://hackage.haskell.org/packages/archive/gloss/1.3.4.1/doc/html/Graphics-Gloss-Interface-Game.html
15:42:07 <elliott> ugly type signature
15:42:20 <elliott> ugly interface too :/
15:42:46 <tonkman> well, maybe I stick with opengl
15:43:09 <elliott> GPipe is pretty nice, or will be once I finish my patch to rip GLUT out :-P
15:43:37 <elliott> (purely-functional shader-based (with only Haskell) library, uses OpenGL/GLUT internally)
15:43:55 <tonkman> sounds cool
15:43:58 <acowley> elliot: you're working on GPipe?
15:44:17 <elliott> acowley: yeah, trying to make it window-system independent -- I already have a patch to make it use GLFW-b
15:44:19 <acowley> elliot: do you have any specific plans other than ripping GLUT out?
15:44:30 <elliott> acowley: yes, preferably ripping Vec out too :-)
15:44:40 <elliott> (https://github.com/tobbebex/GPipe/issues/2 for reasons)
15:44:56 <acowley> elliot: I was really interested in using it at some point but then found it making my life much harder when trying to figure out efficient shader programs
15:45:09 <elliott> acowley: hmm, really?
15:45:31 <elliott> acowley: Using GLUT and Vec are pretty much blockers for me using it, so I hadn't started a serious evaluation before I ended up patching it :)
15:46:22 <acowley> I never really did anything with it, so I'm not lodging an official complaint.
15:46:22 <int80_h> how do I write an expression where I want to evaulate a value to be "not Nothing"?
15:46:39 <acowley> I had issues such as wanting to try out different kinds of samplers
15:46:52 <acowley> and doing things with GPipe seemed to get in the way
15:46:59 <elliott> hmm, OK
15:47:04 <acowley> and/or I just wasn't sure what was happening
15:47:16 <int80_h> a case statement, specifically
15:47:18 <acowley> let me take everything back and just ask for more examples :)
15:47:25 <elliott> I'm planning to use both reactive-banana and GPipe, so I'm prepared for everything to be a colossal pain :P
15:47:42 <elliott> (as far as "treaded ground" goes...)
15:47:49 <acowley> int80_h: Just
15:47:59 <acowley> int80_h: but I'm sure I misunderstood you
15:48:35 <acowley> elliot: I think ultimately I'm probably more interested in GPipe-style with OpenCL
15:48:55 <acowley> elliot: because it seems to me the operations there are a little more straight forward as there's less faffing about with texture formats and such
15:49:02 <elliott> acowley: Yes, that would be cool. I'm writing a game so that's a lower priority for me. What I would like to see is something applying the same ideas to OpenAL.
15:49:16 <int80_h> acowley: no I think that's right. I'm writing the case statement now, and am sure it won't be quite right. I'll post if it isn't.
15:49:40 <acowley> Good, so we're agreed: We want Someone Else to write awesome embeddings of Open* in Haskell.
15:49:52 <elliott> acowley: Precisely!
15:49:57 <int80_h> I vote for oleg!
15:50:08 <acowley> He already did.
15:50:12 <acowley> In the type system.
15:50:15 <int80_h> oh, we're done then.
15:50:16 <elliott> Yeah, but they're -- damn you
15:50:25 <elliott> -- in the type system, so they're not much use for us regular folk stuck in value-land.
15:50:30 <acowley> only ccshan can use them though
15:52:10 <elliott> acowley: The way I see it, though, modifying GPipe to fit my needs can't possibly be more painful than using the OpenGL binding :-)
15:53:43 <acowley> elliott: what about vector-static?
15:54:10 <elliott> acowley: "Very unstable! Many interfaces are still incomplete or even empty. Nat and Fin will be moving to a separate package eventually. This package is not currently maintained."
15:54:13 <elliott> Maintainer	none
15:54:18 <elliott> Any quUpload date	Thu Nov 11 22:45:49 UTC 2010
15:54:21 <elliott> Any questions? :-)
15:54:31 <acowley> elliott: I wish you luck with that! I went through just that decision a while ago and came to the opposite conclusion :P
15:54:31 <elliott> Ugh, second-last line got mangled.
15:54:55 <lispy> I like GLFW-b better than GLUT, FWIW
15:54:56 <acowley> elliott: just write-in copumpkin for maintainer and you can harass him all day on irc!
15:55:13 <elliott> acowley: Well... my project is rather large. Unless fixing GPipe is _insanely_ difficult, then it pays off.
15:55:13 <copumpkin> :O
15:55:18 <lispy> lately I've taken an interest in G3D.  I think we need a Haskell binding :)
15:55:26 <elliott> lispy: re GLFW-b: Me too, that's why I wrote the patch :)
15:55:32 <elliott> But genericity is probably the way to go.
15:55:36 <copumpkin> I consider vector-static to be mostly a failure :P
15:55:42 <acowley> copumpkin: why?
15:55:43 <copumpkin> that doesn't mean I'm not interested in the general idea
15:55:48 <acowley> (note: I've never used it)
15:55:52 <lispy> elliott: oh, what patch did you write for GLFW-b?  I've been sending bsl patches for it right and left :)
15:55:53 <copumpkin> because it's impossible to do anything interesting safely :P
15:56:05 <copumpkin> I don't have the proof facilities I need to show that what I'm doing is safe
15:56:11 <lispy> elliott: mac support was a pain, but well worth the effort
15:56:15 <copumpkin> and without it, I can't really do anything
15:56:20 <elliott> lispy: No, I mean, I wrote a patch to GPipe to make it use GLFW-b
15:56:31 <lispy> elliott: ah, cool
15:56:43 <lispy> copumpkin: addicted to proofs?
15:56:45 <acowley> copumpkin: I suspect common usage would not require much
15:56:55 <elliott> There's a good chance I'll end up using SDL, though... I don't like GLFW-b's callback architecture
15:57:04 <copumpkin> acowley: try writing a non-trivial algorithm over them :P
15:57:07 <copumpkin> I did and failed
15:57:12 <elliott> copumpkin: Try unsafeCoerce
15:57:19 <acowley> copumpkin: I only have trivial concerns
15:57:27 <copumpkin> lispy: I'd quite like to do that kind of stuff with an automated theorem prover, and there are many things that could be done
15:57:28 <copumpkin> but not in haskell
15:57:30 <acowley> copumpkin: I just want tuples with various container like operations
15:57:31 <copumpkin> brb
15:57:38 <lispy> elliott: SDL is nice for projects where you give users an installer.  I did a write up on my blog: http://blog.codersbase.com/2011/03/picking-gui-library-to-use-with-opengl.html
15:57:54 <elliott> lispy: I saw that, I think, when evaluating windowing systems
15:58:08 <lispy> copumpkin: we need to get you working on our haskell-verifier, so you can write your haskell code then do your proofs in isabelle
15:58:22 <acowley> I really fough with SDL to get it working on Mac
15:58:27 <acowley> s/fough/fought
15:58:29 <elliott> acowley: Me too, a year or two ago
15:58:36 <elliott> acowley: You just need a simple C file and use the FFI, IIRC
15:58:39 <acowley> yeah
15:58:42 <lispy> copumpkin: work-in-progress (eg., not usable yet): https://github.com/atomb/core-to-isabelle
15:58:45 <acowley> but that sucks
15:58:59 <elliott> acowley: Sure, but it's a one-off effort. Someone should package it up and put it on Hackage.
15:59:06 <acowley> Every project I was copying a little library around
15:59:16 <acowley> it felt lame, so I went back to GLUT's loving embrace
15:59:26 <lispy> copumpkin: the README explains a lot of the ideas.  Translate Haskell to Core, then Core to Isabelle.
15:59:27 <elliott> Less of an issue when you only have one, big project
15:59:36 <elliott> I really don't think GLUT should be used ever though, when GLFW-b exists
15:59:48 <elliott> lispy: Surely reasoning about Core is pretty difficult
15:59:56 <acowley> elliott: true, but at the start of a project I usually kick off several variants that evolve in parallel until a winner emerges
16:00:11 <elliott> acowley: Sounds like a branch to me :-P
16:00:28 <lispy> elliott: yes, but Brian Huffman updated Isabelle's HOLCF to support reasoning about Haskell programs in a way that actually matches the semantics of a lazy language
16:00:35 <elliott> lispy: cool
16:00:38 <lispy> elliott: it was a whole PhD worth of updates
16:00:47 <elliott> lispy: Can it handle unsafePerformIO? :-P
16:00:56 <lispy> elliott: We're not there yet :)
16:01:04 <lispy> but it does model bottoms on the isabelle side
16:01:09 <elliott> Cool.
16:01:35 * lispy -> coding
16:03:55 <int80_h> @Hoogle <$>
16:03:55 <lambdabot> Maybe you meant: google hoogle
16:04:01 <int80_h> @hoogle <$>
16:04:01 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
16:05:14 <int80_h> @hoogle getDirectoryContents
16:05:14 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
16:06:42 <int80_h> @hoogle </>
16:06:43 <lambdabot> Text.Html (</>) :: (HTMLTABLE ht1, HTMLTABLE ht2) => ht1 -> ht2 -> HtmlTable
16:06:43 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
16:06:43 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
16:07:59 <mornfall> Hm. http://pastebin.dqd.cz/u5AL/ -- even though type instance DefaultApplyState TreeSemantics = Tree
16:08:20 <mornfall> Cale: (Btw. I made much progress with the classes.)
16:08:30 <Cale> mornfall: nice
16:08:35 <Cale> mornfall: What happened to them? :)
16:08:47 <mornfall> Cale: Ended up with a data family, lemme paste.
16:08:56 <elliott> Is "extensions: Haskell2010" the correct way to specify a language for cabal?
16:09:23 <int80_h> I'm tried to have a type signature "foo :: IO Maybe (Bar,Baz). Type system complained with "`IO' is applied to too many type arguments". Is there a way to do what I want? Alternatively, I could use an Either instead of a Maybe
16:09:25 <mornfall> Cale: Like this, http://pastebin.dqd.cz/3VZK/
16:09:35 <elliott> int80_h: IO (Maybe (Bar,Baz))
16:09:44 <int80_h> ah
16:09:47 <int80_h> thanks!
16:09:55 <acowley> > :k IO
16:09:56 <lambdabot>   <no location info>: parse error on input `:'
16:10:02 <acowley> hrmph
16:10:06 <elliott> :k IO
16:10:07 <lambdabot> * -> *
16:10:23 <acowley> thanks!
16:11:07 <Cale> mornfall: Cool. Is the data family actually used as a data family proper, or could you just get by with two separate datastructures right now? :)
16:11:09 <acowley> int80_h: that kind shows you how many arguments IO takes
16:12:20 <mornfall> Cale: Saves me some naming conflicts. :) Other than that, I don't think they are used.
16:12:28 <mornfall> But considering that I need type families for other things anyway.
16:13:04 <mornfall> Ah, actually.
16:13:05 <mornfall> class (Functor m, Monad m, LoadMonad m) => ApplyMonad m semantics where
16:13:05 <mornfall>   applyDict :: m (ApplyDictionary semantics m)
16:13:34 <mornfall> (Yeah, it's almost 2 am...)
16:13:55 <int80_h> acowley: thanks! further along toward understanding kinds
16:13:56 <Cale> That's still a little bit shallow, since you could replace the semantics parameter with the type constructor for the datatype in question.
16:14:11 <Cale> But yeah, it might turn out to be useful.
16:14:34 <Cale> It's probably useful as documentation if nothing else.
16:15:29 <mornfall> Cale: That'd work if there wasn't other stuff tied into the semantics parameter. I guess you could get by without the family anyway, but it's cleaner this way. Or so I guess.
16:16:14 <mornfall>   applyState :: semantics -> m (ApplyState m semantics)
16:16:52 <mornfall> (Unfortunately, can't make ApplyState a data family, so I need to pass around a semantic-typed bottom in a few places...)
16:17:43 <Cale> btw, treeDefaults might be nicer to write with the NamedFieldPuns extension
16:18:24 <Cale> treeDefaults s = s { mModifyFilePSs, mCreateFile, mReadFilePSs, mChangePref }
16:18:36 <Cale>   where mModifyFilePSs f j = ...
16:19:19 <Cale> It's handy wherever you have a record with a bunch of function fields. Also RecordWildCards for making use of them.
16:19:27 <Cale> You'll be able to write...
16:19:46 <Cale> foo (TreeSemantics {..}) = ... use mDoesFileExist etc. here ...
16:20:31 <mornfall> Hmm! That's got some potential. :)
16:21:10 <Dashkal> Is there a term for the construct like a lens but where one of the directions is a partial function?
16:21:18 <mornfall> Can I do that in a do binding, too? (Not that I expect that'd work...)
16:21:24 <Cale> you can
16:21:30 <mornfall> Hmm!
16:21:40 <dobblego> a `Lens` Maybe b
16:21:42 <mornfall> Let's try then.
16:23:15 <Cale> It'll make the fields you get scope over the rest of the do-block
16:23:18 <Dashkal> dobblego: Nice, that works for one direction.  Doesn't work for both but I might be able to restructure.  The case I'm thinking of is mapping an object to a generic representation (such as XML/JSON/Map A B/whatever)
16:23:46 <Dashkal> Going towards it is total.  Coming back, not so much
16:24:56 <acowley> So you want a -> b and b -> Maybe a ?
16:25:03 <Dashkal> acowley: Yes
16:25:28 <Cale> Dashkal: So you want to be able to take an object and a generic representation of part of its structure and replace bits of the object according to the generic representation?
16:25:39 <Dashkal> Cale: correct
16:26:50 <Cale> I think it's pretty fair to do nothing in the case of unidentifiable fields in the generic representation in that case.
16:27:00 <Dashkal> The closest I have is to actually use a lens and "deal with" mismatches if the b being shoved back into the a doesn't fit.  (Copy only fields that exist and are known to be in a)
16:27:15 <Cale> (because you already have an object that you're modifying, it's not a problem just to not change it)
16:27:35 <Cale> yeah
16:27:45 <Dashkal> Yeah, that sounds reasonable.
16:27:54 <mornfall> Cale: Way cool.
16:27:55 <Cale> It is a bit ugly to discard part of the input, I'll admit.
16:28:05 <Cale> mornfall: Isn't it though? :)
16:28:21 <Cale> mornfall: This sort of technique makes Haskell into a pretty decent OO language, imo.
16:28:21 <Dashkal> I could also just invert my lens as dobblego mentioned, but the master object is the non-generic one.
16:28:47 <mornfall> Cale: I love the "let go" that came about as a side-effect, too. :)
16:29:08 <Cale> let go?
16:29:32 <mornfall> apply' = do OmSemantics {..} <- applyDict
16:29:38 <mornfall>             let go (...) = ...
16:29:46 <mornfall>             go p
16:29:55 <mornfall> (I forgot the p after apply')
16:29:56 <dylukes> let go?
16:30:11 <dylukes> Cale: ^
16:30:36 <monochrom> lego
16:30:44 <dylukes> my eggo?
16:31:09 <mornfall> (Sometimes I wish I could write "let do" ...)
16:31:53 <aavogt> > let {} do 1
16:31:54 <lambdabot>   <no location info>: parse error on input `do'
16:32:05 <mornfall> Now there's still the question how come GHC doesn't see a type equality that is fairly easy to prove...
16:32:13 <aavogt> > do let {}; do 1
16:32:14 <lambdabot>   1
16:34:02 <mornfall> (Maybe because I am mis-reading the error. Bah.)
16:35:43 <mornfall> Yeah, that GHC bug is called "user is stupid".
16:36:11 <mornfall> #10000: GHC should DWIM!
16:36:22 <ion> -XIAmNotStupid
16:38:49 <Cale> lol, that one just turns the type system off and lets you deal with the horrible horrible consequences (except that's not really possible)
16:38:49 <geheimdienst> ghc 2> /dev/null
16:39:15 <geheimdienst> cale: sure it's possible, you get ruby that way
16:39:26 * hackagebot tkyprof 0.0.6.3 - A web-based visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.0.6.3 (MitsutoshiAoe)
16:39:42 <Cale> geheimdienst: typeclasses don't work without types
16:40:19 <mornfall> intercalate coerce# ...
16:40:43 <mornfall> But yeah. Haskell would be pretty useless that way.
16:41:20 <geheimdienst> cale, please don't pollute my catchy snarkitudes with facts
16:41:40 <mornfall> Ooooh! Serious rule.
16:41:49 <mornfall> It compiles, it passes tests, and what more, it *works*.
16:43:11 <acowley> This is #haskell, you could have stopped after "It compiles"
16:43:12 <mornfall> Interestingly, the only point between "does not compile" and "works" was a brief moment with an undefined method (state "compiles but all tests fail").
16:45:11 <dbpatterson> can anyone recommend a regex library that is fast and ideally without pathological cases? Or just what they would recommend when good importance is important? I see at least 10 separate libraries on hackage, most of which just say "Replaces Text.Regex" as their description
16:45:21 <dbpatterson> good speed*
16:45:35 <mauke> there are no libraries without pathological cases
16:45:40 <acowley> I usually use regex-pcre-builtin
16:45:53 <dylukes> All Haskell regexes are perfect from the getgo.
16:45:54 <dylukes> Duh.
16:46:12 <Axman6> there are not non-pathelogical regex libraries, only non-pathelogical regexs
16:46:16 <Axman6> no*
16:46:45 <dbpatterson> mauke: I thought russ cox figured out some way to do it?
16:46:49 <mornfall> Paleolithic regexen!
16:46:56 <acowley> But idiomatic Haskell is to use parser combinators and hold smug disdain for REs
16:47:06 <mauke> dbpatterson: does his library handle ([ab]{9999}){9999}?
16:47:13 <geheimdienst> smug disdain often is idiomatic haskell
16:47:54 <acowley> at least it's an ethos
16:47:59 <mornfall> Yeah, why use something simple and fast when you can use something turing-complete and leaky like a sieve. :P
16:48:00 <Axman6> > 9999^9999
16:48:01 <c_wraith> @quote recursion.and
16:48:01 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
16:48:02 <lambdabot>   367897836216551579269262598478356580455025438573477618640185661384561636087...
16:48:32 <dbpatterson> mauke: not sure. I'm not sure the exact source, but it may have been http://swtch.com/~rsc/regexp/regexp3.html . I think it was just about avoiding exponential time, not making every thing fast. but I know wery little about regex parsing, hence not knowing which library to use!
16:48:54 <Axman6> i've wondered whether you could make an efficient regex library that took regexes and compiled them using LLVM
16:49:16 <mornfall> Axman6: Depends to what exactly you compile them.
16:49:24 <acowley> other regexes
16:49:25 <mornfall> DFAs are infinitely slow.
16:49:35 <luite> Axman6: doesn't java do that with bytecode?
16:49:39 <mornfall> Even when done in C.
16:49:42 <Axman6> no idea
16:49:48 <parcs> > 10 `logBase` (9999^9999)
16:49:49 <lambdabot>   Infinity
16:49:52 <Axman6> ha
16:49:54 <parcs> o
16:49:57 <geheimdienst> Axman6: i bet if you asked oleg, next day we'd have regexes in the type system
16:50:07 <mornfall> Apparently, backtracking beats all. Which is sad...
16:50:24 <parcs> @src logBase
16:50:25 <lambdabot> Source not found. Maybe you made a typo?
16:50:39 <mornfall> geheimdienst: RegexLike may not be type-level regexps, but it's definitely baroque.
16:51:09 <geheimdienst> @google oleg cat type problem was not so hard
16:51:10 <lambdabot> http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46/4/960831913_rhDdG
16:51:11 <lambdabot> Title: oleg cat sez:see? ur type problim wuz not so hardby Andrew Bromage - Sean Leathe ...
16:51:13 <Axman6> NFA's seems like a good way of doing regexes in haskell. each character leads to a list of states (which is nub'd)
16:51:43 <Axman6> couldn't you then use regexes from left to right?
16:51:45 <mornfall> Axman6: (Did I say DFAs were slow? I take that back.)
16:52:01 <acowley> I think my favorite part of RegexLike is its resistance to user-initiated discovery
16:52:56 <mornfall> acowley: Yeah, it takes a big hammer. The advantage is that it looks neat and flat when you are done.
16:53:18 <mornfall> (In Soviet Russia RegexLike discovers you.)
16:53:37 <acowley> exactly
16:54:25 <roconnor> acowley: I don't think of it as losing syntax highlighting as never having it in the first place :)
16:54:36 <Axman6> "(a?)+" would be pathological no?
16:54:39 <acowley> their inscrutability gives us stockholm syndrome for parser combinators
16:55:03 <mauke> dbpatterson: "It supports counted repetition, but it is implemented by actual repetition (\d{3} becomes \d\d\d), so large repetition counts are unwise."
16:55:17 <mornfall> acowley: And TH makes us happy for happy.
16:55:18 <mauke> dbpatterson: so yeah, my example is pathological and would make the regex compiler consume all available memory
16:55:33 <mornfall> Axman6: You probably aren't even allowed to do that.
16:55:39 <mauke> dbpatterson: (in something like perl it turns into a simple loop)
16:55:41 <dbpatterson> hmm. that doesn't sound much better... :)
16:56:07 <Axman6> mornfall: the language should allow it, but the engine might not..
16:57:13 <mornfall> Axman6: A smart compiler probably rewrites that to something sane, too.
16:57:15 <mauke> "Perl and PCRE differ on the meaning of the regexp \v. In Perl it matches just the vertical tab character (VT, 0x0B), while in PCRE it matches both the vertical tab and newline."  <- this is factually incorrect
16:57:20 <mornfall> (Like a*.)
16:57:59 <dylukes> I need to get around to inventing BeeFeR
16:58:05 <dylukes> The BrainFuck Regex engine.
16:58:22 <dylukes> It
16:58:28 <dylukes> It's a bit verbose, but it's pretty sane.
16:58:30 <dylukes> :)
16:58:39 <edwardk> i need bindings to pcre that support its partial match mode
16:59:18 <edwardk> that way i can tweak my parsers to let you run a regex, and have it feed the lines to pcre on demand
16:59:44 <edwardk> but pcre's partial match mode is a horrible frankenstein's monster
17:00:09 <mauke> "RE2 demonstrates that it is possible to use automata theory to implement almost all the features of a modern backtracking regular expression library like PCRE."
17:00:19 <mornfall> edwardk: Which is consistent with PCRE (and perl) in general.
17:00:23 <edwardk> yeah
17:00:32 <geheimdienst> mauke, is re2 the thing google put out?
17:00:42 <mauke> except for backreferences, counted repetitions, lookahead, lookbehind, conditional patterns, independent submatches, ...
17:00:45 <edwardk> the main problem i have is that it is inconsistent with the rest of pcre in the answers it gives, etc
17:00:55 <mornfall> mauke: The question is: performance?
17:01:05 <mauke> geheimdienst: yes
17:01:41 <mauke> mornfall: no, the question is features
17:02:20 <mornfall> mauke: Backreferences allow (at least some) CFLs.
17:02:33 <mauke> ok?
17:02:48 <mornfall> mauke: Which means the regular expression is not actually regular.
17:02:54 <monochrom> -XImNotStupid is implemented by replacing every type-erring expression by undefined
17:03:10 <mauke> mornfall: duh
17:03:59 <edwardk> it'd be better if it replaced them with error "Yes, you are"
17:04:25 <mornfall> mauke: counted repetitions are trivial if you unroll them, afaict
17:04:43 <mauke> mornfall: yes, until you run out of memory
17:04:53 <mauke> <mauke> dbpatterson: does his library handle ([ab]{9999}){9999}?
17:04:54 <mornfall> I don't even *know* what the rest means. :P
17:04:56 <edwardk> mornfall: at an explosive cost in the complexity
17:04:58 <monochrom> ok, I agree, replace with error "Yes, you are" :)
17:05:23 <mornfall> edwardk: Sure. That's exactly what language theory predicts.
17:06:12 <mornfall> (Although the explosion is pretty slow as long as your compiler is smart.)
17:08:28 <acowley> my font is annoying me with tiny greek letters, can someone sell me on a different font (I usually use Monaco)?
17:08:56 <monochrom> use ubuntu out-of-the-box fonts
17:09:18 <sshc> Is it safe to use rewrite rules to define a much more efficient version of a function for the monomorphic case in which the result is a lazy bytestring if the result of appyling input to the two versions differ in their internal representation but are "equal" (such that the result of passing both bytestrings to '(==)' is True)?  Specifically, the result of the more efficient version may be
17:09:24 <sshc> chunked differently.
17:09:47 <geheimdienst> acowley: you mean monospace? use inconsolata, it's hands-down the most readable and beautiful one
17:09:49 <elliott> sshc: You can observe that externally (at least with "show").
17:09:51 <geheimdienst> not sure about greek though
17:10:02 <mauke> preflex: re "d!+ ['d!.'^]" 12 34.56
17:10:02 <preflex>  match: [0-2: 12]
17:10:03 <elliott> sshc: I'd say it's OK iff your function returns in IO.
17:10:51 <mauke> preflex: re "d!+ ['d!.'^]" 12.34.56
17:10:51 <preflex>  match: [6-8: 56]
17:11:25 <sshc> elliott: It's not in IO.  What exactly do I need to guarantee about the two bytestrings to make this rewrite rule safe?
17:12:36 <elliott> sshc: That they're indistinguishable, at least without using any unsafe functions on the ByteStrings?
17:12:50 <monochrom> @quote solrize Schubert
17:12:50 <lambdabot> No quotes match. It can only be attributed to human error.
17:13:00 <elliott> sshc: I mean, my definition of "safe" may be more stringent than others', but the fact that you can define a top-level Bool value that has a different value depending on whether an optimisation kicked in or not is terrifying to me.
17:13:07 <elliott> (Just compare the result of "show".)
17:13:29 <monochrom> @quote solrize Schubert's
17:13:29 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
17:16:24 <mornfall> geheimdienst: Hm, inconsolata (like all other scalable fonts) suck on-screen. :\ Other than that, looks nice. But then, I don't print much monospace text...
17:18:01 <luite> I like consolas better, and it looks great with cleartype
17:18:06 <luite> unfortunately not free
17:18:25 <geheimdienst> mornfall, maybe your system is misconfigured? i find with the right hinting and stuff, on-screen font rendering is pretty damn good these days
17:19:19 <mornfall> geheimdienst: Dunno. It's bad even on PNG renderings off the web that show off fonts.
17:19:22 <luite> I like (subpixels) antialiased much better than bitmap fonts
17:19:36 <luite> at least on a reasonably high res display
17:20:01 <mornfall> I use -misc-fixed-medium-r-semicondensed--13-*-*-*-c-*-iso10646-1 to this day.
17:20:19 <luite> mornfall: there are multiple inconsolata versions, the one on google webfonts is hinted
17:20:27 <mornfall> I used DejaVu and Monaco before, but they can't match the legibility.
17:21:19 <mornfall> The basic problem is that once you get used to fixed, *everything* looks blurred. I don't mind in a browser, but I do in the terminal and in emacs.
17:21:58 <mornfall> (Well, it's true that going solarized helped the browser a fair bit, too.)
17:22:18 <luite> solarized?
17:22:41 <mornfall> http://ethanschoonover.com/solarized
17:23:30 <luite> oh that low contrast stuff
17:23:33 <mornfall> I am piecing together a userstyle that forces the palette on the browser, with mixed success.
17:24:01 <dobblego> @type  \f i k -> fmap (f i) k `mplus` return i
17:24:02 <lambdabot> forall a a1 (m :: * -> *). (Functor m, MonadPlus m) => (a1 -> a -> a1) -> a1 -> m a -> m a1
17:24:06 <dobblego> feels ick
17:24:30 <luite> mornfall: the left font sample looks blurry to me by the way
17:24:53 <geheimdienst> uh, low contrast and too many of the colors are indistinguishable. feels like i'd have to squint way too much
17:24:54 <luite> my emacs font is consolas with subpixel rendering, looks much crisper
17:25:12 <elliott> mornfall: Solarised looks nice
17:25:21 <mornfall> luite: The only one that's actually sharp is bottom right.
17:25:36 <elliott> Non-antialiased fonts are gross though :)
17:26:03 <luite> mornfall: consolas is still much better :p
17:26:16 <elliott> mornfall: those anti-aliased samples look gross... but they look like they're from vim, which IIRC on OS X uses an older text rendering method
17:26:25 <luite> my font size is slightly bigger than those though
17:27:01 <geheimdienst> mornfall: seriously, check out your system's font rendering settings. if it looks blurry, dial up the hinting
17:27:36 <luite> since I have a 150dpi screen
17:27:59 <luite> terminal is about the same size, emacs slightly bigger
17:28:26 <mornfall> geheimdienst: I tell you, rendering of PNGs has nothing to do with my font renderer.
17:28:34 <sshc> There really should be a lazy bytestring type whose chunking is not intrinsically visible.  Once there's a standard polymorphic type class that contains an intersection of the functions of the already plethoral hpeans of string types.
17:29:05 <mornfall> geheimdienst: At ~100dpi, AA fonts are bound to be blurry. You can't *fix* that.
17:29:27 <elliott> mornfall: Rendering of PNGs taken on OS X, which _does not hint_
17:30:44 <mornfall> elliott: It's not just those. Look at http://www.antigrain.com/research/font_rasterization/
17:31:21 <acowley> "plethoral hpeans" sounds derogatory
17:31:25 <elliott> mornfall: I've read it.
17:31:37 <elliott> mornfall: But hinting works in practice.
17:32:05 <RenJuan> hpean?
17:33:56 <elliott> Has the world reached agreement on what container typeclasses should look like yet?
17:34:03 <elliott> Or should I go back into hibernation
17:34:24 <mornfall> World probably didn't start deliberating yet.
17:34:42 <jmcarthur> dobblego: yeah i wish we had something in the standard libs like TypeCompose's Monoid_f
17:35:26 <jmcarthur> oh you used return
17:35:37 <jmcarthur> maybe you could just get away with Alternative then
17:36:01 <jmcarthur> @type \f i k -> fmap (f i) k <|> pure i
17:36:02 <lambdabot> forall a a1 (f :: * -> *). (Alternative f) => (a1 -> a -> a1) -> a1 -> f a -> f a1
17:36:04 <luite> mornfall: http://jabberwock.xs4all.nl/exp/emacs.png check my l33t emacs font and colors
17:36:10 <jmcarthur> @type \f i k -> f i <$> k <|> pure i
17:36:11 <lambdabot> forall a a1 (f :: * -> *). (Alternative f) => (a1 -> a -> a1) -> a1 -> f a -> f a1
17:38:14 <dylukes> luite: http://cl.ly/9PfS
17:38:16 <dylukes> twilight D:
17:38:17 <mornfall> luite: Yeah, it's leet, but definitely smeared. :P
17:38:18 <dylukes> what now.
17:38:24 <dylukes> mornfall: Mine is more l33t
17:38:25 <dylukes> http://cl.ly/9PfS
17:38:34 <luite> mornfall: looks sharp here
17:38:35 <dylukes> no anti-aliasing in here.
17:38:44 <dylukes> luite: You have anti aliasing on, and your font is soooo big.
17:39:08 <mornfall> dylukes: Hmm?
17:39:20 <mornfall> That's blurry too.
17:39:21 <luite> dylukes: yes I have 150dpi
17:39:34 <dylukes> mornfall: what resolution are you at?
17:39:39 <luite> dylukes: I set it a little smaller sometimes, but it's easier to read this way, especially late at night
17:39:41 <mornfall> ~100dpi
17:39:47 <ion> I can’t stand OSX’s blurry font rendering.
17:40:03 <luite> dylukes: yes antialiasing roxors
17:40:10 <mornfall> dylukes: *could* be compression... you need to post a PNG not a JPEG maybe
17:40:11 <jmcarthur> my own color scheme, but i think i'll be going back to zenburn soon http://i.imgur.com/jT85T.png
17:40:14 <dylukes> anti-aliasing = bad. :<
17:40:22 <dylukes> http://f.cl.ly/items/2R0a0w2n1m2V0p3f1P1c/Image%202011.08.17%209:10:12%20PM.png
17:40:23 <dylukes> click to zoom
17:40:30 <dylukes> to see at 100%.
17:40:35 <elliott> dylukes: That looks antialiased to me.
17:40:46 <elliott> In fact, there is no non-antialiased text in that screenshot.
17:41:01 <jmcarthur> mine is not antialiased
17:41:03 <dylukes> No, I explicitly turned it off...
17:41:06 <elliott> No.
17:41:09 <dylukes> With AA on it looks different
17:41:09 <jmcarthur> you failed
17:41:10 <dylukes> one sec
17:41:18 <elliott> If you think you did, you do not know what anti-aliasing means.
17:41:19 <ion> Anti-aliasing is *not* bad by itself. Proper sharp subpixel antialiasing can render curves and diagonal features *sharper* than nonantialiased rendering.
17:41:29 <jmcarthur> what ion said
17:41:40 <mornfall> dylukes: It's definitely blurred.
17:41:43 <jmcarthur> but dylukes' shot is full of antialiasing
17:41:50 <elliott> mornfall: It's also not hinted, because /it's OS X/.
17:41:51 <mornfall> jmcarthur: That's cool weechat.
17:42:02 <dylukes> elliott: what does hinted mean anyways.
17:42:15 <elliott> mornfall: Obviously you're on a lower-DPI display and find unhinted text ugly, so it's wrong to look at only unhinted text as examples of antialiasing.
17:42:17 <luite> dylukes: your image has subpixel aa
17:42:24 <elliott> dylukes: See Wikipedia.
17:42:25 <ion> Distorted to match the pixel grid better, resulting in sharper features when combined with proper antialiasing.
17:42:26 <jmcarthur> hinted means it stretches things around to try to fit within pixels exactly
17:42:33 <jmcarthur> or more exactly, at least
17:42:38 <dylukes> hinting is a bad thing then
17:42:39 <dylukes> ?
17:42:42 <jmcarthur> not necessarily
17:42:43 <ion> Not at all.
17:42:45 <dylukes> or a good thing?
17:42:53 <dylukes> I don't know any typography stuff.
17:42:58 <luite> hinting is good, but it's a lot of work
17:42:59 <jmcarthur> it depends on preferences, type, etc.
17:43:01 <dylukes> If its legible and clean, I'm happy.
17:43:01 <luite> to do correctly
17:43:05 <ion> The low resolution of today’s monitors is a bad thing, hinting is not the worst workaround.
17:43:10 <jmcarthur> yeah, and on the quality of the hinting
17:43:22 <jmcarthur> same for antialiasing, really
17:43:32 <geheimdienst> not at all, with (decent) hinting things are more legible than without
17:43:45 <luite> jmcarthur: yes but you have to hint each font individually
17:43:48 <jmcarthur> i've seen some terrible hinting
17:43:52 <jmcarthur> right
17:44:59 <luite> what annoys me is that linux and windows usually have very different interpretations of how a font (especially free web fonts) should be rendered
17:45:10 <jmcarthur> hinting, AA, subpixel AA, all these things can be done well or poorly, and all of them will be liked or not like by different people :\
17:45:22 <jmcarthur> *liked
17:45:28 <dylukes> How are the different OS's in fonts, comparitively
17:45:35 <dylukes> I've personally found fonts on Windows pretty... weird.
17:45:43 <dylukes> OS X/Linux seem similarish to me.
17:45:44 <geheimdienst> jmcarthur: there'll also be stockholm syndrome involved ...
17:45:47 <dylukes> I'm probably bling.
17:45:49 <dylukes> blidn*
17:45:57 <luite> windows distorts fonts more, to get more sharpness
17:46:08 <ion> ClearType™ is horribly blurry as well.
17:46:17 <luite> nah cleartype is ftw
17:46:23 <jmcarthur> all three, when configured well, can do pretty decently
17:46:24 <luite> especially with fonts hinted for it
17:46:42 <luite> I still like consolas best on windows
17:46:51 <geheimdienst> i'd say windows rendering is top-notch, linux isn't far behind these days and is more configurable
17:47:03 <jmcarthur> windows is the worst, IMO
17:47:06 <luite> :)
17:47:08 <jmcarthur> :)
17:47:21 <ion> Whenever you have partially translucent (sub)pixels along horizontal or vertical straight lines you have blur that doesn’t need to be there.
17:47:43 <jmcarthur> windows has the most hinting, which i'm not a fan of, but it also has the highest quality hinting except in some extreme circumstances
17:48:59 <mornfall> http://web.mornfall.net/stuff/screens/solarized.png :)
17:49:03 <jmcarthur> i hate it when i look at a windows shot and all the text looks yellow because for some bizarre reason it decided to snap everything to some subpixel (uniformly) instead of to a whole pixel
17:49:08 <luite> jmcarthur: do you always use specific non-standard fonts in your editors? the difference between a poorly hinted font and a good one is much bigger on windows than on os x
17:49:09 <djahandarie> I like how we always end up having periodic conversations about font hinting in here
17:49:32 <jmcarthur> luite: i agree. i mean windows generally, not windows with some specific font
17:49:34 <luite> yeah, oly usually in -blah ;p
17:49:40 <mornfall> djahandarie: Never happened to me before. :)
17:49:54 <jmcarthur> s/generally/usually/
17:50:03 <geheimdienst> we should put the whole hinting thing in the faq
17:50:07 <jmcarthur> ha
17:50:29 <luite> and get included in haskell 2012
17:50:43 <luite> {-# LANGUAGE ClearType #-}
17:50:43 <jmcarthur> ghc will come with special support for high quality fonts
17:50:52 <elliott> renderFont :: Font -> Opinions -> String -> Bitmap
17:51:03 <elliott> data Opinions = Opinions { ... too many fields to list ... }
17:51:10 <elliott> needs to be in the Prelude
17:51:25 <ion> mornfall: That looks blocky compared to http://heh.fi/tmp/sharp_subpixel_rendering
17:51:42 <luite> ion: whoah that looks terrible
17:51:43 <geheimdienst> "FAQ 4.7.2 Is Jmcarthur wrong about the hinting issue?" -- "Yes, decent hinting increases the perceived resolution. Hinting awesum."
17:52:01 <jmcarthur> i never said decent hinting is bad
17:52:04 <jmcarthur> :P
17:52:30 <elliott> Erm, does anyone know Google's DNS IPs? Apparently my nameservers have just quit working. Off-topic, I know, but not moreso than hinting :-P
17:52:40 <jmcarthur> 2.2.2.2 is one i think
17:52:43 <luite> 8.8.8.8
17:52:46 <jmcarthur> heh
17:52:47 <geheimdienst> 8.8.8.8 and 8.8.4.4
17:52:48 <jmcarthur> that is it
17:52:53 <jmcarthur> ignore mine
17:53:11 <jmcarthur> how did they score that ip?
17:53:16 <elliott> jmcarthur: by being rich
17:53:26 <ion> luite: But is pretty much as legible as possible with the low-res display technology.
17:53:28 * mornfall uses 4.2.2.2 for pings (no idea who actually owns that box)
17:53:30 <elliott> thanks luite, geheimdienst :P
17:53:37 <mornfall> (and an odd DNS query or two...)
17:53:59 <luite> ion: hm, it looks way too irregular for me, inconsistent sharpness
17:54:16 <elliott> ion: Gross (owner of a high-DPI display here :P)
17:54:22 * jmcarthur can't decide whether he hates ion's color scheme or ion's font rendering more ;)
17:54:23 <elliott> Probably nice if you're on something lower-API
17:54:27 <elliott> What's up with your time format, though
17:54:27 <luite> hehe
17:54:31 <elliott> jmcarthur: That's default Ubuntu
17:54:36 <luite> elliott: how many dpi's do you have?
17:54:50 <jmcarthur> ah mornfall is another fixed fan
17:54:56 <elliott> luite: I think one hundred and twenty eight or thereabouts
17:54:56 <jmcarthur> i have a love/hate with it
17:55:02 <geheimdienst> yeah, let's all hate ion's font rendering, it will be a bonding moment
17:55:14 <jmcarthur> elliott: i don't like default ubuntu :P
17:55:17 <luite> he should be arrested for indecent hinting
17:55:20 <mornfall> Fixed Forever. :-)
17:55:23 <ion> Weekday, hours, minutes, seconds. The day is a workaround for irssi not showing the days when /lastlog’ing.
17:55:26 <elliott> WE NEED MORE OPINIONS
17:55:28 <elliott> MOOOOOOOOOORE OPINIONS
17:55:35 <jmcarthur> your opinions all suck
17:55:44 <jmcarthur> i'm going back to #haskell
17:55:47 <jmcarthur> oh shit, i'm already there
17:55:50 <mornfall> :D
17:55:51 <jmcarthur> thought i was in -blah
17:55:52 <ion> :-D
17:56:00 <elliott> :DD
17:56:05 <jmcarthur> :DDD
17:56:12 <elliott> :DDDDDDDDDDDddddddddd hel p i have too many mouths,
17:56:39 <luite> I should switch to zapfino in emacs
17:56:42 <ion> ：－Ｄ
17:56:54 <elliott> luite: As long as you can get a background of crumpled old paper
17:57:03 <elliott> Preferably change your mouse cursor to a quill
17:57:29 <jmcarthur> i want my emacs to be rendered by LaTeX, of course
17:57:36 <elliott> TeXmacs :P
17:57:40 <jmcarthur> ha
17:57:42 <luite> elliott: if that's what it takes to be a Dijkstra
17:57:50 <jmcarthur> does that work for non-TeX languages though? :P
17:57:59 <elliott> jmcarthur: It doesn't even work with TeX, the name is totally stupid
17:58:00 <geheimdienst> @remember jmcarthur your opinions all suck. i'm going back to #haskell (...) oh shit, i'm already there
17:58:00 <lambdabot> It is forever etched in my memory.
17:58:14 <elliott> jmcarthur: It has a bunch of REPLs to various computer mathematics systems
17:58:25 <jmcarthur> huh
17:58:27 <elliott> It can also export to LaTeX
17:58:32 <elliott> You'd have to write something to use it with Haskell, though
17:58:38 <jmcarthur> i want it to do agda
17:58:45 <elliott> jmcarthur: http://upload.wikimedia.org/wikipedia/commons/2/27/Yacas-texmacs-gnuplot.png -- you can also input in the formula style, but it... doesn't always work.
17:58:51 <elliott> But that's the fault of the integration more than TeXmacs itself.
17:58:54 <jmcarthur> surely these are popular enough technologies that it's been done already
17:59:31 <jmcarthur> oh, and it has to go through lhs2TeX first, of course
18:00:49 <ion> Real coders write on papyrus scrolls with a carbon-based ink powder.
18:01:38 <jmcarthur> he died, sorry
18:01:56 <mornfall> When will we finally get Functor as a superclass of Monad?
18:02:05 <Peaker> mornfall: what about Applicative?
18:02:08 <huangyi> What's the diffenrence between iff and if? I can't find iff in dictionary.
18:02:14 <ion> TeXmacs’ math input mode is awesome. The keyboard shortcuts are intuitive. I used to do my algebra notes in class with TeXmacs.
18:02:16 <jmcarthur> huangyi: iff = if and only if
18:02:33 <mornfall> Peaker: If applicable, why not. :P
18:02:40 <mornfall> I mean.
18:02:42 <elliott> mornfall: All monads are applicative
18:02:46 <mornfall> It's a shame.
18:02:55 <ion> http://dictionary.reference.com/browse/iff
18:03:05 <mornfall> (Well, so is fail.)
18:03:07 <elliott> All we need is a mechanism to specify methods of superclasses in a subclass instance, and a method for subclasses to provide defaults for superclasses in terms of their methods.
18:03:16 <parcs> mornfall: there was recent discussion about superclass defaults on one of the MLs
18:03:20 <elliott> Then backwards compatibility would be maintained and defining instances wouldn't be a huge pain.
18:03:22 <jmcarthur> huangyi: "a if b" means "b implies a". "a iff b" mean "a implies b *and* b implies a"
18:03:30 <mornfall> -XBetterMonads
18:03:31 <elliott> parcs: Is superclass defaults all of that or just half?
18:03:42 <parcs> all i think
18:03:55 <elliott> "An instance declaration can specify multiple classes
18:03:55 <elliott> instance (Class1 a, Class2 a, ...) where ..."
18:04:06 <elliott> With what I was thinking it'd say "instance Monad m where ...".
18:04:12 <elliott> Because Monad would effectively include the methods of all its parents too.
18:04:16 <Peaker> but Applicative mixes up Pointed and Ap which maybe ought to be in other places.. also I think Applicative/Monad should let you define liftA2/join rather than ap/>>=
18:04:25 <elliott> I'm pretty sure it maintains full backwards compatibility
18:04:27 <Peaker> (IOW Applicative could be split)
18:04:44 <elliott> Peaker: I think at some point you have to stop splitting before every single typeclass has one method
18:04:54 <jmcarthur> that would just give you Clena
18:04:56 <jmcarthur> *clean
18:05:00 <elliott> Functor with fmap, Pointed with pure, Ap with (<*>), Monad with join
18:05:04 <ion> Well, Monad and Applicative both having a separate “pure” certainly warrants splitting it to Pointed.
18:05:06 <elliott> jmcarthur: Clean does that?
18:05:09 <Peaker> elliott: Functor has 1, Applicative has 2, Monad has 1 (to extend Applicative)
18:05:11 <elliott> ion: That's Monad's problem.
18:05:25 <jmcarthur> clean type classes only have one method
18:05:35 <dobblego> be rid of pure
18:05:41 <parcs> is Pointed useful in practice?
18:05:45 <jmcarthur> or at least that's the way it used to be
18:06:11 <jmcarthur> parcs: i think edwardk has made an argument that it's not, but i don't know the substance of that argument
18:06:22 <ion> class Applicative f => Monad f where { x >>= f = join (f <$> x); join x = x >>= id }  -- and types
18:06:40 <dobblego> fmap, (<*>), (<*>)+fmap, (>>=), (>>=)+fmap, now add point
18:06:51 <edwardk> ion: the argument against Pointed is that it has no useful laws
18:07:25 <edwardk> ion: the (<*>) structure and the (>>=) structure are more useful in isolation
18:07:48 <ion> ok
18:08:17 <elliott> dobblego: What's wrong with pure
18:08:19 <roconnor> the argument for pointed is that (Pointed f) => (b -> f b) -> (a -> f a) is a partial lens.
18:08:30 <edwardk> the main problem is that whenever you find youw ant to use Pointed you're usually fooling yourself. because rarely are you writing any combinator you can say anything definitive about
18:08:31 <dobblego> elliott: what edwardk said
18:08:44 <elliott> dobblego: I don't see how that's an argument against pure
18:08:49 <elliott> Do you just mean pure as a separate typeclass?
18:08:52 <elliott> If so, yeah, I can agree with that
18:08:57 <edwardk> elliot: as a separate class
18:09:00 <elliott> Right.
18:09:03 <dobblego> elliott: I am not arguing against pure, just that its introduction into the type-class hierarchy is too hasty
18:09:27 <edwardk> we have pointed sets, but you don't find mathematicians enthralled with them, on the other hand semigroups are quite useful
18:09:33 <edwardk> and monoids more so
18:09:44 <roconnor> topologists seem to like pointed sets
18:09:48 <edwardk> we don't build monoid out of a pointed set with a compatible associative binary operation usually
18:09:55 <dolio> Also categorists.
18:10:14 <edwardk> we tend to come down and add the unit to the semigroup
18:10:20 <dolio> The category of pointed sets is some natural lower-than-categories level of categories.
18:10:30 <dobblego> some like pointy, some like voluptuous
18:11:07 <elliott> dolio: Insert joke about the only property of something more general than a category being "it exists"
18:12:18 <huangyi> jmcarthur: thanks.
18:12:34 <elliott> Hey, I got into HWN. Cool.
18:12:58 <edwardk> but in general given haskell's general dislike for classes that have no methods you wind up uncomfortably having to choose. you can have Pointed, or you can have Apply then Bind, with Apply leading into Applicative and Monoid unfortunately being an empty class
18:13:16 <edwardk> adding Pointed, and making Applicative another empty class would lead to even fewer people using it ;)
18:13:21 <elliott> nobody like monoids :(
18:13:31 <dolio> Apply fits in better with algebra, though.
18:13:56 <dolio> You usually have structures with operations, and then extensions of those with units.
18:14:06 <roconnor> elliott: I've moved on to dioids
18:14:17 <dolio> Not structures with things, and then extensions of those with operations that use the things as units.
18:14:27 <edwardk> yeah
18:14:38 <hpaste> mrakan pasted “data.array.repa troubles - can't match type X with type X?” at http://hpaste.org/50413
18:14:48 <edwardk> pointed is fine as far as it goes, but it doesn't go very far, and like dolio says, the extension usually goes the other way
18:14:53 <elliott> roconnor: Trioids are where it's at
18:15:03 <roconnor> elliott: what is a Trioid?
18:15:07 <edwardk> elliot: we call those algebras
18:15:08 <mrakan> Hi. I'm having type trouble with the small program I pasted just now. Does anyone know what I'm doing wrong?
18:15:19 <elliott> edwardk: Decoids!!!!!!!
18:17:45 <DrSpatula> Can anyone explain to me what "Just" is/does?
18:18:01 <elliott> edwardk: btw, how fast is trifecta, compared to parsec 3?
18:18:19 <elliott> roughly :P
18:18:25 <edwardk> should be comparable. i add a bit more but then optimize the ascii case
18:18:33 <roconnor> DrSpatula: it's a constructor that holds a value in the Maybe Foo type
18:18:36 <edwardk> keep in mind i do utf8 decoding by default
18:18:53 <edwardk> though satisfy8, etc and the Char8 api let you avoid that
18:18:53 <Kaidelong> @djinn b -> (b -> Either a b) -> a
18:18:54 <lambdabot> -- f cannot be realized.
18:18:55 <elliott> so slower than parsec 2? OK :P
18:18:57 <xenocryst> DrSpatula: it's a type that holds other types (like lists). It allows you to see if a value is Just a value (successful) or Nothing (didn't work out)
18:19:01 <edwardk> =P
18:19:13 <Peaker> xenocryst: he asked about Just, not Maybe
18:19:16 <aavogt> mrakan: do you have multiple versions of repa installed? (in that case you get  errors like   couldn't match   pkg-v1:X agains  pkg-v2:X  if you manage to get X from both versions in scope at the same time)
18:19:19 <edwardk> i am not trying to win a race
18:19:23 <ricree> Draconx, Just is part of Maybe.  Maybe is used in cases that may or may not have a value, such as a lookup in a data structure.  Just means that it succeeded
18:19:24 <xenocryst> Just is part of Maybe...
18:19:30 <edwardk> i'm trying to make something more useful
18:19:38 <edwardk> think of it as gold plated parsec ;)
18:19:52 <ricree> and I got beaten by not one, but two others.  yay me
18:19:58 <elliott> edwardk: yeah, was just curious... I mean, if you're parsing a bunch of source files, speed matters, since it can be the slowest part of compilation depending on your language...
18:20:11 <edwardk> because it has been refactored differently i can do things like add swierstra and duponcheel style static analysis to the applicative fragents, etc.
18:20:30 <Draconx> ricree, you also addressed the wrong nick :)
18:20:31 <edwardk> so there it should start to get some nice speed wins
18:20:38 <Kaidelong> @ty let f x g = case x of { Left w -> w; Right v -> f (g x) g } in f
18:20:39 <lambdabot> forall t t1. Either t t1 -> (Either t t1 -> Either t t1) -> t
18:20:40 <edwardk> sure.
18:20:52 <Kaidelong> @ty let f x g = case x of { Left w -> w; Right v -> f (g v) g } in f
18:20:53 <lambdabot> forall t t1. Either t t1 -> (t1 -> Either t t1) -> t
18:21:06 <edwardk> its continuation based, and it caches the current line
18:21:12 <ricree> Draconx, why so I did.  Sorry about that.  I really ought to have checked what my irc client autocompleted, shouldn't I
18:21:27 <edwardk> so most operations other than shuffling continuations only have to ask some properties of the current bytestring
18:21:28 <Kaidelong> @ty let f x g = case x of { Left w -> w; Right v -> f (g v) g } in f . Right
18:21:29 <lambdabot> forall t t1. t1 -> (t1 -> Either t t1) -> t
18:21:35 <Draconx> ricree, no worries.
18:21:40 <Kaidelong> why did djinn get that wrong
18:21:42 <edwardk> and unlike parsec the continuation is flipped around to allow partial application
18:21:56 <mrakan> aavogt: You're right, I have multiple repas installed. Thanks!
18:22:55 <aavogt> mrakan: you used to get the package versions in the type error. It must be a mistake that ghc-7.2 doesn't show it
18:23:27 <mrakan> aavogt: Actually, I'm using 7.0.3.20110517.
18:25:30 <BMeph> Kaidelong: djinn didn't get it wrong, but it didn't reach into the future to see what you really meant, vice what you said. ;)
18:26:57 <Saizan> Kaidelong: i'm not sure if djinn does any recursion, but yours is not guaranteed to terminate so it wouldn't count as a valid proof (which is the space that djinn searches)
18:26:59 <Kaidelong> I guess if you allow it to discover contingency implementations
18:27:17 <Kaidelong> you can't stop it from discovering implementations of contradictions
18:27:24 <Kaidelong> since you can use recursion for those too
18:29:03 <BMeph> Kaidelong: I.e., There is no guarantee that "f (:: b -> Either a b) b" produces a (Left a) for any value of b...or what Saizan said. :)
18:29:45 * BMeph really needs to learn how to type...
18:30:01 <Kaidelong> hmm in those situations the implementation doesn't work anyway
18:30:05 <Kaidelong> it'll just loop forever
19:08:14 <Maxdamantus> @can Haskell solve child poverty?
19:08:14 <lambdabot> Maybe you meant: faq map run wn
19:08:18 <Maxdamantus> Can Haskell solve child poverty?
19:08:21 <Maxdamantus> Damn.
19:08:43 <rwbarton> lambdabot even guessed the correct command for you :)
19:08:54 <Maxdamantus> @faq can Haskell solve child poverty?
19:08:55 <lambdabot> The answer is: Yes! Haskell can do that.
19:18:09 <ezyang> Why are typed functional programming languages traditionally not JIT'ed?
19:20:17 <kmc> they should be!
19:20:49 <ezyang> Perhaps we're spoiled on all of this type information...
19:21:04 <kmc> there are some people working on tracing JITs for Haskell, i think
19:21:25 <ezyang> Oh really? I wasn't aware of any such efforts 8)
19:21:58 <Saizan> nominolo is the guy, i think
19:23:43 <ezyang> ah, ok.
19:25:11 <dolio> edwardk talks about it.
19:25:24 <dolio> But he's not actually working on it.
19:25:34 <edwardk> ?
19:25:41 <dolio> JITs.
19:25:41 <edwardk> oh the jit
19:25:42 <edwardk> yeah
19:25:47 <edwardk> i haven't touched one in a while
19:26:01 <edwardk> nominolo or someone is working on the basic design these days
19:27:09 <edwardk> ezyang: i had the start of a tracing jit that i was fiddling with for ghc bytecode that i was hacking on with matt morrow, then he vanished, and i put it away figuring he'd be back 'real soon now'
19:27:58 <edwardk> anyways tracing and the spineless tagless g-machine work really well together.
19:28:55 <edwardk> thunk evaluation usually requires two indirect jumps to calculated addresses, and that traces nicely
19:29:22 <ezyang> Oh, nice!
19:29:37 <ezyang> I guess pointer tagging is a form of primitive tracing 8)
19:38:24 <edwardk> yeah pointer tagging helps quite a bit
19:56:50 <eyu100> I need to use a function displayInWindow in ghci
19:56:58 <eyu100> problem is, displayInWindow quits the program
19:57:10 <eyu100> so is there a way to wrap it to prevent quitting?
20:34:35 <absentia> n/win shrink 3
20:34:35 <absentia> n/win shrink 3
20:35:42 <bmars> Can I could install complete documentation via cabal-install?
20:50:56 <bmars>  3;3~
21:09:40 * hackagebot thespian 0.999 - Lightweight Erlang-style actors for Haskell  http://hackage.haskell.org/package/thespian-0.999 (AlexConstandache)
21:10:07 <DukeDave> How would I express something like this:
21:10:09 <DukeDave> let shape   = case shape of Circle -> drawEllipse; Square _ -> drawRect
21:11:18 <DukeDave> Will I have to create another function to do the pattern matching?
21:12:36 <DukeDave> Oh, ha, what do you know, that actually works
21:13:01 <parcs> > let x = case x of () -> () in x
21:13:05 <lambdabot>   mueval-core: Time limit exceeded
21:13:07 <DukeDave> ... Having removed the, ahem, intentional error of using "shape" twice to mean different things :|
21:21:11 <parcs> > let x = case x of _ -> () in x
21:21:12 <lambdabot>   ()
21:25:07 <parcs> > fix (() -> ())
21:25:07 <lambdabot>   Pattern syntax in expression context: () -> ()
21:25:12 <parcs> > fix (\() -> ())
21:25:15 <lambdabot>   mueval-core: Time limit exceeded
21:29:52 <Axman6> > fix (\_ -> ())
21:29:54 <lambdabot>   ()
21:32:17 <Axman6> > fix (\f x -> case x of Left a -> f (Right a); _ -> f x
21:32:19 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:32:23 <Axman6> > fix (\f x -> case x of Left a -> f (Right a); _ -> f x)
21:32:24 <lambdabot>   Overlapping instances for GHC.Show.Show
21:32:24 <lambdabot>                              (Data....
21:32:32 <Axman6> :t fix (\f x -> case x of Left a -> f (Right a); _ -> f x)
21:32:33 <holmak> I would like to pass an array of floats through the FFI to C. I am currently using the vector package; is that a good way to do it?
21:32:33 <lambdabot> forall t t1. Either t1 t1 -> t
21:34:59 <Axman6> > fix (\f x -> case x of Left a -> f (Right a); Right a -> f (Left a))
21:35:00 <lambdabot>   Overlapping instances for GHC.Show.Show
21:35:01 <lambdabot>                              (Data....
21:35:06 <Axman6> :t fix (\f x -> case x of Left a -> f (Right a); Right a -> f (Left a))
21:35:07 <lambdabot> forall t t1. Either t1 t1 -> t
21:35:09 <parcs> holmak: you can use Foreign.Marshal.Array.withArray
21:35:49 <holmak> thanks
21:48:40 <Derander> I am trying to learn how to use parsec (2, I think). When I try to compile https://gist.github.com/gists/1153341 , I get "Not in scope: `haskellDef'"
21:51:01 <Derander> hm. I removed the ( haskellStyle ) from the import and it appears to work.
22:01:28 <edwardk> you probably want haskellStyle not haskellDef
22:01:56 <edwardk> or you want to do that, the import line you wrote was limiting the import to only pull that one definition
22:02:08 <edwardk> rater than everything in Language.
22:02:12 <edwardk> er rather
23:29:33 <QinGW> quiet
23:39:11 <peteriserins> preflex: seen conal
23:39:12 <preflex>  conal was last seen on #haskell 9 hours, 49 minutes and 6 seconds ago, saying: Axman6: ping
23:39:48 <Axman6> i don't even know why D:
23:54:45 <peteriserins> is http://hackage.haskell.org/trac/ghc/ supposed to have a link to vending machines in there?
23:56:23 <luite> hmm, linkspam
23:57:00 <Derander> edwardk: ah, I understand. thank you. the parsec book is slightly dodgy
23:58:58 <hpaste> Anon annotated “DynacatLovesMe” with “DynacatLovesMe (annotation)” at http://hpaste.org/49392#a50419
23:59:51 <hpaste> anon annotated “DynacatLovesMe” with “DynacatLovesMe ” at http://hpaste.org/49392#a50420
