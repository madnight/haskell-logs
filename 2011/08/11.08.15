00:20:05 * hackagebot transformers-abort 0.1 - A better error monad transformer  http://hackage.haskell.org/package/transformers-abort-0.1 (MikhailVorozhtsov)
00:21:42 <ebzzry> Is there a document describing the use of parentheses?
00:21:55 <mustelo> ebzzry, what do you mean?
00:22:07 <edwardk> you put them around stuff
00:22:13 <mustelo> heh
00:22:15 <shachaf> edwardk: Or on their own, occasionally.
00:22:22 <edwardk> that too
00:22:27 <kizzx2> any first hand opinions of mtl vs transformers + mtl-tf/mtl-fd vs monadLib?
00:22:32 <shachaf> I suppose that "nothing" counts as "stuff".
00:22:37 <edwardk> kizzx2: yes the issue is solved
00:22:43 <kizzx2> edwardk: yeah?
00:22:50 <edwardk> kizzx2: mtl + transformers is the current stack
00:22:52 <shachaf> @google cmccann transformers mtl
00:22:53 <lambdabot> http://stackoverflow.com/questions/2769487/mtl-transformers-monads-fd-monadlib-and-the-paradox-of-choice
00:22:53 <lambdabot> Title: haskell - mtl, transformers, monads-fd, monadLib, and the paradox of choice - St ...
00:22:59 <ebzzry> Aside from putting them around patterns, e.g., (x:xs), and using them to group stuff, what other uses are there?
00:23:01 <edwardk> mtl was split to make this possible
00:23:10 <edwardk> so now its just the classes, and transformers are just the data types
00:23:15 <shachaf> edwardk: mtl + transformers? I thought mtl was standalone, and it was transformers + monads-x.
00:23:43 <kizzx2> edwardk: so do you mean the other choices should be regarded as obsolete?
00:23:48 <edwardk> yes
00:24:01 <edwardk> monads-fd IS basically most of the contents of mtl
00:24:21 <kizzx2> it says "mtl == transformers ++ monads-fd", so how does "mtl + transformers" work out?
00:24:28 <ebzzry> mustelo, aside from putting them around patterns, e.g., (x:xs), and using them to group stuff, what other uses are there?
00:24:52 <edwardk> mtl re-exports the Control.Monad.Trans.State.Lazy etc. as Control.Monad.State.Lazy after mixing in Control.Monad.State.Class
00:24:55 * kizzx2 obviously lacks  first hand experience anything other than those came with Haskell Platform
00:25:03 <edwardk> for example
00:25:11 <mustelo> ebzzry, that's pretty much it.
00:25:32 <mustelo> I would note that "putting them around patterns" is a subset of "grouping stuff"
00:25:41 <shachaf> They're also used for tuples.
00:25:45 <shachaf> Which is an abuse, really.
00:25:49 <edwardk> the way it is usually used is if you need just the data type, just bring in the stuff from Trans.Foo, if you want to work with the class and don't care about limiting yourself to haskell 98, use the mtl machinery
00:25:52 <ebzzry> mustelo, OK
00:25:55 <edwardk> but the data types are the same actual types
00:25:56 <shachaf> In fact, I object to parentheses being used for tuples.
00:26:00 <shachaf> I wish they weren't.
00:26:01 <edwardk> so the code interoperates
00:26:27 <edwardk> shachaf: the thing is there is stuff exported by transformers that isn't exported from the mtl layer
00:26:55 <kizzx2> edwardk: thanks for clearing up
00:27:10 <kizzx2> so monad-fd has won out? oo i've always like type families more
00:27:29 <edwardk> yeah it has
00:27:37 <kizzx2> so sad
00:27:47 <mreh> i thought type families were prefered by 8/10 cats
00:27:50 <edwardk> part of the finally accepted proposal was to rename the modules in monad-tf to one side so you could support it as well, but it never happened
00:28:10 <shachaf> Wait, monads-tf lost?
00:28:15 <edwardk> shachaf: yes
00:28:24 <shachaf> :-(
00:28:33 <kizzx2> mreh: what's "8/10 cats"?
00:28:35 <mreh> awwww, VHS...
00:28:39 <shachaf> @where lambdacats
00:28:39 <lambdabot> http://tinyurl.com/lambdacats
00:28:42 <edwardk> ideally monad-tf would just get its modules renamed slightly. Control.Monad.State.Family, or something
00:28:51 <edwardk> and then you could implement both for downstream libs
00:28:54 <mreh> kizzx2: marketing speak
00:28:55 <shachaf> Monads for the entire family.
00:29:19 <benmachine> I use monads-tf whenever I have a choice
00:29:27 <shachaf> benmachine: You will soon never have a choice.
00:29:30 <edwardk> benmachine: i like actually linking with other people's code
00:29:39 <benmachine> edwardk: pfft, usability, what a bore
00:29:46 <kizzx2> mreh: so did you mean "I thought type families were preferred by haskell people"?
00:29:47 <mreh> i used fd out of ignorance of tf
00:29:54 <benmachine> anyway they should be using tf in any case
00:29:54 <mreh> kizzx2: yeah :)
00:29:55 <edwardk> this is why i think the modules in monads-tf shoud just be renamed then nobody needs care if you use it
00:30:03 <kizzx2> mreh: ook plz spare my dullness :P
00:30:27 <benmachine> yes but implementation details in the module name = blah
00:30:34 <benmachine> actually
00:30:36 <kizzx2> i cant believe fundep has won
00:30:39 <benmachine> that's probably not true
00:30:46 <edwardk> benmachine: it lets you then import both or neither, ec.
00:30:50 <benmachine> man am I the only one who doesn't think the war is over
00:30:57 <benmachine> edwardk: I can already import neither :P
00:30:59 <shachaf> The war is over. Haskell lost.
00:31:00 <edwardk> =P
00:31:10 <mreh> Machines rules the world
00:31:39 <edwardk> the fundep style is frankly just a bit less work to use when working with transformers
00:31:47 <kmc> ebzzry, they're also used to form and match tuples
00:32:00 <kmc> which isn't quite a case of "around stuff" because the syntax inside isn't valid by itself
00:32:05 <edwardk> rarely do i have a function that requires MonadState m => ….. and doesn't mention the state in the type.
00:32:09 <kmc> case (2,3) of (x,y) -> ...
00:32:17 <shachaf> kmc: Right. As I mentioned, I consider that an abuse.
00:32:23 <kmc> i didn't see that
00:32:26 <shachaf> It comes from the lack of useful characters in ASCII.
00:32:28 <kmc> *scrolls*
00:32:29 <kmc> yeah
00:32:31 <edwardk> it'd be nice for some data types here and there
00:32:32 <kmc> this includes (), which you can think of as a 0-ary tuple
00:32:35 <edwardk> for that i'm sad
00:33:00 <kmc> ebzzry, another use of parens is operator sections
00:33:05 <kmc> :t ( (+2), (2+) )
00:33:06 <lambdabot> forall a t. (Num a, Num t) => (a -> a, t -> t)
00:33:13 <shachaf> Oh, true.
00:33:21 <edwardk> shachaf: that and its easy to parse the case. when you parse ()'s add a check after you parse for a term, that checks for a , and tries to parse another term
00:33:24 <ebzzry> kmc, I forgot to mention that. Ya.
00:33:36 <shachaf> I wish (,) was just an operator.
00:33:41 <edwardk> one little <|> and your grammar remains factored
00:33:44 <mreh> it is isn't it?
00:33:53 <shachaf> mreh: No, it's magi parenthesis synta.
00:33:55 <benmachine> mreh: it's not *just* an operator
00:33:58 <shachaf> HList-style, or something.
00:34:05 <mreh> right, gotcha
00:34:15 <mreh> where do i learn about tf vs fd?
00:34:24 <ebzzry> So, we have: 1) grouping, 2) tuples, and 3) sections
00:34:24 <mreh> i never got round to learning tf
00:34:25 <kmc> mreh, the features themselves?
00:34:30 <kmc> or the monad libs?
00:34:46 <mreh> kmc: both would be great
00:34:50 <edwardk> and tuple sections
00:34:56 <kmc> for the features, start with the GHC manual
00:34:58 <shachaf> Tuple sections are kind of evil.
00:35:02 <edwardk> > (,2,) 1 3
00:35:02 <lambdabot>   Illegal tuple section: use -XTupleSections
00:35:06 <edwardk> bah
00:35:07 <shachaf> But they make sense as long as you allow tuples.
00:35:17 <edwardk> i like tuple sections
00:35:24 <kmc> i
00:35:26 <edwardk> they fix a 'hole' in the grammar conceptually
00:35:36 <shachaf> (,1,,True,'a',,)
00:35:36 <kmc> i like the idea, but it never seems worth turning on an extension for the one case
00:35:50 <mreh> kmc++
00:35:55 <edwardk> i want unboxed tuple sections ;)
00:35:59 <kmc> shachaf, if you have a 7-tuple you already have bigger problems...
00:36:10 <edwardk> or do those work?
00:36:21 <kmc> you can consider unboxed tuples a use of parens distinct from regular tuples
00:36:27 <kmc> if you want to allow GHC extensions
00:36:45 <edwardk> also the delimiting of contexts and deriving clauses
00:36:48 <shachaf> edwardk: Unboxed tuple sections seem to work in my ghci.
00:36:52 <edwardk> and the module list at the beginning
00:36:55 <kmc> and "deriving"
00:36:58 <edwardk> shachaf: sweet =)
00:37:01 <kmc> those are all kind of like "grouping" though
00:37:05 <edwardk> yeah
00:37:06 <kmc> it's not clear where to draw the lines
00:37:11 <edwardk> same with imports, etc.
00:37:16 <kmc> it's a strange question :)
00:37:17 <shachaf> The tuple syntax for constraints is kind of weird.
00:37:22 <benmachine> the module list and imports both require parens though
00:37:28 <shachaf> As opposed to the curried version of that syntax, I mean.
00:37:31 <benmachine> even if there's only a single thing being grouped
00:37:35 <kmc> ebzzry, oh, using parens to refer to an infix operator by itself
00:37:38 <kmc> is none of those
00:37:39 <edwardk> shachaf: yeah i always thought they should have curried it to comply with the rest of the language
00:37:47 * shachaf has a few minor adjustments to make to Haskell syntax.
00:37:48 <kmc> close to sections, though
00:37:50 <benmachine> kmc: it's kind of a section
00:37:57 <edwardk> Num a => Monad m => a -> m a
00:37:57 <shachaf> I also kind of think "->" should be eliminated from lambdas.
00:38:13 <edwardk> shachaf: i'd rather eliminate the \
00:38:15 <shachaf> @ty let f :: Num a => Monad m => a -> m a; f = undefined in f
00:38:16 <lambdabot> forall a (m :: * -> *). (Monad m, Num a) => a -> m a
00:38:29 <shachaf> edwardk: Really? I'd think that one-argument lambdas using just \ would be nice.
00:38:30 <kmc> benmachine, that's not how the Report sees it, but it is valid i suppose
00:38:34 <edwardk> it requires infinite lookahead int he grammar but its more pleasant to read
00:38:35 <shachaf> As in \a\b\c a (b c)
00:38:46 <benmachine> kmc: isn't it?
00:38:48 <shachaf> Oh, parsing-wise.
00:38:49 <edwardk> shachaf: i write 6 argument lambdas a LOT
00:38:59 <shachaf> edwardk: Right, but what's wrong with backslashes?
00:39:02 <kmc> "Haskell provides special syntax to support infix notation. An operator is a function that can be applied using infix syntax (Section 3.4), or partially applied using a section (Section 3.5)."
00:39:06 <shachaf> It's not any longer, and there's clear separation.
00:39:14 <edwardk> a lot of noise
00:39:49 <ebzzry> kmc: Hmm, OK
00:40:00 <shachaf> Doesn't seem like it would read as noise if you got used to it.
00:40:09 <shachaf> It's conceptually simpler, after all, than "fake multi-argument functions".
00:40:30 <shachaf> That concept makes sense in application, because you just make it left-associative, but less sense in defining lambdas.
00:42:28 <edwardk> but then syntactically you have things of very different types sitting right next to one another, patterns and expressions
00:42:28 <edwardk> the -> is a pretty decent separator
00:43:03 <edwardk> and is consistent with its use in case, etc.
00:43:10 <edwardk> which i suppose you'd also want to excise ;)
00:43:33 <edwardk> but to do that then i have to wrap my cases i ()'s ick
00:43:36 <shachaf> "->" is also used in other places with a completely different meaning.
00:43:36 <edwardk> er in
00:46:33 <mreh> t's quite obvious when it is a case expression and a lambda expression
00:47:25 <shachaf> edwardk: Why not "=" for case?
00:47:38 <shachaf> Hmm, I guess = doesn't make sense.
00:47:40 <edwardk> because it isn't an equality
00:47:45 <shachaf> Yes.
00:47:59 <shachaf> I like how "->" is just a type (and kind, I guess) operator, though.
00:48:01 <edwardk> foo (Bar x y z) = .. reads as equality case is a sequence of alternatives
00:48:27 <shachaf> I don't like it when some piece of syntax's meaning is overloaded just because that piece of syntax looks nice.
00:48:29 <edwardk> and since they have it already reserved they might as well use it
00:48:36 * shachaf is heading down the path to APL, of course.
00:48:41 <edwardk> i like pretty
00:48:41 <edwardk> ;)
00:49:05 <edwardk> APL was a terrible language if only for the fact you couldn't extend it for squat
00:49:23 <edwardk> all the useful bits of syntax were taken because folks like you didn't want to overload any meanings ;)
00:49:51 <mreh> This article contains APL source code. Without proper rendering support, you may see question marks, boxes, or other symbols instead of APL symbols.
00:50:07 <opqdonut> :)
00:55:24 <edwardk> yay i have syntax highlight interval tracking working in the parser
00:56:20 <shachaf> edwardk++ for doing nifty parser things that I haven't really been paying much attention to.
00:56:54 <edwardk> pretty error messages and basically expressing a willingness to entangle every other concern in the world with the parser
01:00:05 * hackagebot download-media-content 0.0.0.1 - Simple tool to download images from RSS feeds (e.g. Flickr, Picasa)  http://hackage.haskell.org/package/download-media-content-0.0.0.1 (JasperVanDerJeugt)
01:00:36 <edwardk> for instance i'm entangling the concerns of highlighting the resulting code with parsing, but this lets me print the diagnostic messages pointing into highlighted source code, and by tracking the current completions i can give informative fixits, and will soon support tab completion for arbitrary grammars, etc.
01:01:16 <edwardk> so it is basically the gold plated parser combinator library, willing to trade in performance here and there for a boatload of flexibility
01:01:49 <edwardk> with an eye towards the fact that the design is such that you can make other parser (and i probably will) that support fewer of these things
01:30:05 * hackagebot data-lens-template 2.1.1 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-2.1.1 (EdwardKmett)
01:32:16 * frerich thinks he's doing something wrong if 75% of his functions have the signature 'Game -> Game'
01:32:33 <frerich> I guess I could just as well pass the world around.
01:33:10 <edwardk> eep
01:33:17 <edwardk> yeah probably a bad sign
01:33:51 <ivanm> great.... my QC tests have stack overflows :s
01:34:29 <edwardk> doh
01:34:55 <ivanm> how the hell can I debug that? :/
01:35:13 <ivanm> I have the sneaking suspicion that it's because the size of the generated Dot graphs is too big :s
01:35:32 <edwardk> i now have automatic syntax highlighting baked into trifecta, so it'll mark the portions of the input that were recognized by the token parsers if you want it to
01:36:11 <gienah> ivanm: I wonder if you have the code compiled with optimisation like -02
01:36:52 <edwardk> with some tweaking i should be able to make it so that if you get errors out of parseTest it'll use those to vim-like coloring on the input
01:37:15 <edwardk> and to make it easier for folks to automatically generate syntax highlighters for their toy languages
01:38:17 <ivanm> gienah: heh, I had to go down to -O because some -O2 optimisation caused GHC to eat too much RAM :s
01:38:31 <ivanm> though I've run this particular test before in the past with no problems... :s
01:39:51 <gienah> ivanm: i guess profiling it and looking at what types of memory are being allocated might give some hints, or there's looking at the ghc core output
01:40:02 <ivanm> yeah
01:47:51 <k0ral> how do I catch "read" errors ?
01:47:53 <k0ral> :t read
01:47:54 <lambdabot> forall a. (Read a) => String -> a
01:48:02 <ivanm> k0ral: use reads instead
01:48:04 <ivanm> @type reads
01:48:05 <lambdabot> forall a. (Read a) => String -> [(a, String)]
01:48:10 <ivanm> @src read
01:48:10 <lambdabot> read s = either error id (readEither s)
01:48:28 <ivanm> otherwise, you have to do so in IO
01:48:34 <k0ral> thank you
01:50:05 * hackagebot trifecta 0.31 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.31 (EdwardKmett)
01:50:56 <kmc> @where read
01:50:56 <lambdabot> http://haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
01:51:00 <kmc> k0ral, ^^^^
01:51:11 <k0ral> waw
01:51:46 <kmc> @hoogle readEither
01:51:46 <lambdabot> No results found
01:51:54 <kmc> i don't believe that @src ;P
01:52:47 <mjrosenb> kmc: that doesn't look like it is binding a variable at all!
02:00:35 <Itkovian> any tips to get the platform packages compiled using ghc7.2.1?
02:02:55 <RenJuan> you mean the ones that are in the slipped HP release?
02:04:18 * RenJuan suggests making the earlier compilers (perhaps both 6.12 and 7.0.n) part of the build process.
02:10:43 <mm_freak> what's the difference between (a -> a) and (a ~ b => a -> b)?
02:11:03 <coppro> (a -> a) is a function from a to a
02:11:13 <benmachine> :t id :: a ~ b => a -> b
02:11:14 <lambdabot> forall a. a -> a
02:11:19 <benmachine> does this answer your question
02:11:38 <hvr> benmachine: so the difference is just more noise? :)
02:11:48 <coppro> wait... /me is getting suspicious he is missing something about ~ here
02:11:48 <mm_freak> benmachine: i guess
02:12:00 <mm_freak> coppro: ~ means "equals"
02:12:03 <mm_freak> in type families
02:12:12 <mm_freak> you use it to place requirements on associated types
02:12:12 <benmachine> hvr: it's like "what's the difference between id x and x" I suppose
02:12:15 <coppro> ah
02:12:16 <coppro> ok
02:13:04 <mm_freak> benmachine: there is a subtle difference between "newtype X = X Int" and "data X = X !Int", which i didn't expect, until my code really broke down with data, while it worked well with newtype
02:13:16 <mm_freak> so i thought, there might be such a subtle difference for this question, too
02:16:22 <kmc> pretty sure the intent is that they're equal
02:16:59 <kmc> there might be a corner case in GHC that can distinguish them
02:19:24 <mjrosenb> mm_freak: I could probably write a function that would oom on one, but not the other, but other than that, what was the difference
02:19:42 <mjrosenb> mm_freak: or was it some horrible interaction between a whole bunch of different things?
02:21:51 <kmc> between newtype and strict data?
02:22:25 <blackdog> hey all. trying to help out a mate with this: https://gist.github.com/1144680#file_bool.hs
02:22:52 <blackdog> so i know there's a pattern where you can apply a simplifying function at every element of an AST
02:22:55 <benmachine> mjrosenb: http://www.haskell.org/haskellwiki/Newtype#The_messy_bits
02:23:04 <blackdog> (in this case, taking SNot (SNot a) to a)
02:23:18 <kmc> mjrosenb, the difference is that pattern-matching a data constructor will force the value to whnf (and thus force the field, in this case)
02:23:19 <blackdog> but not sure how to apply it - is that generics?
02:23:33 <kmc> but pattern-matching a newtype constructor does nothing
02:23:40 <blackdog> (obviously his implementation only catches that simplification if it's at the top)
02:23:50 <benmachine> blackdog: yeah, sounds about right, see uniplate, Data.Generics, etc.
02:23:50 <kmc> > case undefined of Endo x -> ()
02:23:51 <lambdabot>   ()
02:27:09 <Itkovian> RenJuan: well, yeah but I'd rather have it working in a single go, i.e., make and make install
02:28:04 * mjrosenb was thinking of polymorphic recursion to force a *large* chain of boxes
02:28:21 <mjrosenb> where the unboxed variant just sort of sits there
02:32:54 <blackdog> benmachine: thanks :)
02:33:08 <benmachine> I've used syb
02:33:20 <benmachine> I had neil explain to me why uniplate was better but I forget :P
02:33:22 * RenJuan next suggests adjusted expectations.
02:33:55 <RenJuan> that or you know, work (said with Maynard G Krebs intonation)
02:34:28 <RenJuan> (for the very few that will get the reference)
02:43:46 <willem> When you use a wrapper in the FFI should you release the FunPtr later on?
02:45:00 <mm_freak> mjrosenb: problem was that 'data' types still force constructors, as if there could be multiple of them
02:45:18 <mm_freak> while matching against the constuctor in a newtype is essentially a no-op
03:00:55 <hpaste> kamaji pasted “State monad in Snap” at http://hpaste.org/50328
03:01:25 <kamaji> I'm having trouble understanding the state monad, would anyone be able to help me implement a 'counter' page with snap?
03:01:36 <kamaji> paste is here (also above) http://hpaste.org/50328
03:01:40 <hvr> edwardk: do you plan on adding arrows for your Data.Lens abstraction?
03:04:22 <kmc> willem, yes, if you create a FunPtr using 'foreign import "wrapper"' then you should free it with freeHaskellFunPtr when no longer needed
03:05:11 <rostayob> kamaji: the State monad wouldn't be of much use to implement a counter in snap, would it?
03:05:20 <rostayob> counter as in it increments each time you visit the page?
03:05:40 <kmc> kamaji, the State monad has no magic; (State s a) is just a wrapper for (s -> (a, s))
03:05:41 <benmachine> kamaji: since Snap is MonadIO, you might as well use IORefs
03:05:49 <kamaji> rostayob: yeah that was the idea
03:06:03 <kamaji> Right, so there's no way to I can use the State monad for that?
03:06:04 <kmc> if you can't implement your design with plain old functions then State is not going to help
03:06:11 <kamaji> ok
03:06:17 <kamaji> I thought someone had said use State to do it
03:06:21 <kamaji> that explains a lot >_>
03:06:36 <kamaji> How might I do something like that then?
03:06:43 <kmc> benmachine's suggestion
03:06:56 <rostayob> kamaji: well you could simply write to a file :P
03:07:00 <kamaji> rostayob: >_>
03:07:16 <kamaji> I don't really know what IORefs and MonadIO are, I will look into them
03:07:27 <benmachine> IORefs are mutable variables in IO
03:07:35 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Data-IORef.html
03:07:46 <rostayob> I mean you have to "remember" the counter somewhere. it's going to be either memory or disk, a file would work fine. otherwise IORefs yeah
03:07:49 <benmachine> damn it kmc I just went and copied that
03:08:01 <benmachine> MonadIO is a way of turning IO a into Snap a
03:08:04 <benmachine> using liftIO
03:08:26 <kamaji> rostayob: right, I just want an int in memory basically
03:08:31 <rostayob> kamaji: yes
03:08:39 <benmachine> so for example, liftIO (newIORef 'x') :: Snap (IORef Char)
03:08:57 <rostayob> well either in memory or on the disk, but somewhere where it would be persistent, not per request
03:09:33 <kamaji> benmachine: lots of new stuff there.. I'll save it and look ^^
03:09:48 <kamaji> How does having mutable variables work with the "purity" bit of haskell?
03:09:54 <benmachine> IO
03:09:58 <kmc> the same way as any other IO
03:10:01 <rostayob> kamaji: happstack has a really cool State-like persistent storage
03:10:17 <rostayob> kamaji: http://hackage.haskell.org/package/acid-state
03:10:28 <kamaji> Oh I saw that, it does look cool
03:10:30 <benmachine> you can think of an IORef as a pointer, sort of - so it is itself immutable, but it points to a value you can set or get
03:11:16 <benmachine> all setting or getting is in IO, so it doesn't break purity in the same way that setting or getting the contents of a file is fine
03:11:28 <kamaji> How does the compiler handle IORef?
03:11:39 <kamaji> does it have some special case stuff to deal with it?
03:11:44 <merijn> kamaji: Same way it handles all IO
03:12:00 <benmachine> well, newIORef and stuff is all primitive
03:12:05 <rostayob> kamaji: I think you're a bit confused about IO in haskell
03:12:05 <merijn> kamaji: Updating the value the IORef points to is just an IO action
03:12:11 <kamaji> rostayob: I think that's fair :P
03:12:18 <kmc> yeah, GHC has primitives for allocating memory and writing to it in-place
03:12:25 <kmc> which are used to implement writeIORef etc.
03:12:30 <kamaji> I think the primitives thing answers my question really
03:12:31 <kmc> you don't have to care though
03:12:35 <kamaji> right, just curious
03:12:42 <kamaji> because obviously that can't be done 'in language' per se
03:12:56 <kmc> you could implement a clunky IORef using files ;)
03:13:00 <kamaji> haha
03:13:00 <kmc> at least for serializable types
03:13:08 <kamaji> that would be blazing fast~
03:13:08 <benmachine> or with Storable
03:13:22 <benmachine> you could actually do it with Storable except again, only Storable types
03:13:26 <kmc> IO is pretty straightforward; ST and STM have more interesting examples of mutable state
03:13:27 <benmachine> you can put anything in an IORef
03:13:33 <kmc> but aren't directly relevant to your problem
03:13:38 <kmc> benmachine, even another IORef :D
03:13:40 <benmachine> :>
03:13:46 <kmc> Mu IORef
03:14:11 <kamaji> that's almost just like a double pointer in C?
03:14:21 <kmc> kinda-sorta
03:14:21 <zygoloid> kamaji: do you understand how IO generally gets around the purity of haskell?
03:14:24 <kmc> Haskell isn't C, though
03:14:25 <benmachine> Mu IORef is a very very strange beast :P
03:14:30 <clsmith> hmm, just because this is on-topic atm, isn't how the compiler allows side-effects in monads with (>>) and so on .. a bit of a hack, mathematically? i don't know, it just seems strange to me that a monad (in category theory terms) requires special-casing in that way. shrug
03:14:45 <benmachine> clsmith: IO doesn't need to be a monad to work
03:14:54 <kmc> clsmith, the way IO works has nothing to do with monads
03:15:04 <benmachine> you could just as easily write an IO that didn't have a monad instance
03:15:05 <kamaji> zygoloid: Well here is my understanding- You say your mutable things are external, and use IO to get them so the program can remain pure?
03:15:12 <benmachine> in fact haskell had IO before it had monads
03:15:17 <kmc> kamaji, http://www.haskell.org/haskellwiki/Introduction_to_IO
03:15:27 <kmc> clsmith, the key idea is just to describe the actions you want to perform, instead of performing it
03:15:46 <kmc> it so happens that the generic Monad API is useful for describing IO actions
03:15:52 <merijn> clsmith: What special casing are you talking about?
03:15:56 <kmc> it's also useful for describing lists and functions and maybe-values
03:16:00 <benmachine> yes
03:16:02 <kmc> none of which have anything to do with "side-effects"
03:16:03 <clsmith> hmm, really? i think i'm confused specifically because i read that the monadic function (>>) performs the "side-effects" of the computation despite actually not using the result. and as a result .. i'm sort of confused.
03:16:13 <zygoloid> clsmith: you were lied to
03:16:13 <benmachine> the idea of Monad is we can use mapM in lots of different contexts and get something useful
03:16:24 <merijn> Also, it is my understanding that haskell monads are category theory comonads
03:16:27 <benmachine> or sequence or liftM2 or forever or <whatever>
03:16:36 <zygoloid> clsmith: (>>) does not perform any side effects. it just produces an IO action which represents gluing together two other actions. it's entirely pure.
03:16:46 <benmachine> zygoloid: it depends what you think of side-effects
03:16:53 <benmachine> or performing
03:16:59 <benmachine> the terminology is a bit mixed around this subject :P
03:17:10 <kmc> some people like to describe all monads as being about effects, but you have to stretch the idea of "effect" pretty far ;P
03:17:13 <kmc> > "abc" >> "de"
03:17:14 <lambdabot>   "dedede"
03:17:15 <zygoloid> benmachine: i don't think so. (>>) does not perform the side-effects; whoever executes the result does.
03:17:17 <kamaji> zygoloid: Isn't the point of monads that they contain some context for those glued actions, which can then be looked at as the actions are performed?
03:17:23 <kamaji> but they're 'hidden' outside the Monad?
03:17:23 <kmc> no
03:17:37 <kmc> look, Monad is just an API
03:17:46 <kamaji> but isn't that what it's for?
03:17:47 <kmc> implemented lots of different ways
03:17:50 <kmc> they don't have a lot in common
03:17:53 <merijn> kamaji: Not really
03:17:55 <kamaji> aw :\
03:17:55 <benmachine> zygoloid: as kmc says, some people have a generous definition of effect
03:17:56 <kmc> some are "about effects" or "about context"
03:17:57 <kmc> some aren't
03:18:03 <kmc> there's no one "point of monads"
03:18:21 <kmc> it's like saying "the point of Ord is that you can put Strings in a Data.Map"
03:18:29 <kmc> that is one specific use case of the Ord API, yes
03:18:43 <benmachine> kmc: iono, I kind of think kleisli composition is the "point of monads"
03:18:54 <kmc> ok
03:19:05 <merijn> People keep confusing side effects and monads, but there are no sensible semantics for side effects (ask conal! :p), the fact that IO has side effects is orthogonal to monads and ugly voodoo inside haskell
03:19:21 <zygoloid> benmachine: imo, talking about (>>) having a side-effect will confuse people when they see  (a >> b) `seq` foo  has no side-effect
03:19:39 <kmc> anyway the Monad class doesn't have any special side-effect hack
03:19:43 <benmachine> zygoloid: that's probably true
03:19:51 <kmc> it's an ordinary type class you can write yourself in a few lines of standard Haskell
03:19:57 <kmc> what's special is the IO type
03:20:01 <kmc> and its instance for Monad
03:20:11 * hackagebot posix-timer 0.2 - Bindings to POSIX clock and timer functions.  http://hackage.haskell.org/package/posix-timer-0.2 (MikhailVorozhtsov)
03:20:15 <kmc> if you didn't provide that instance, you could instead provide dedicated returnIO and bindIO functions
03:20:21 <kmc> and it would still work basically the same
03:20:46 <benmachine> zygoloid: one needs a good way to talk about the way that x >> y is different from y, even though the values "inside" x aren't used
03:20:57 <benmachine> zygoloid: but there are probably better words one can use than side-effect
03:20:59 <clsmith> see, this is the trouble i'm having: i understand monads from a functor -> pointed functor -> ... point of view, but then (and i'm trying to find this again) i read something about (>>) and side-effects and since then it's all been a bit vague
03:21:22 <kmc> probably the thing you read was wrong or confusing
03:21:37 <kmc> there's really nothing to Monad though
03:21:43 <kmc> it's a tiny type class you can write yourself
03:21:49 <merijn> clsmith: Just forget side effects exist when reading about monads and especially ignore the IO monad. See if it makes sense that way, then if it does you can look at IO and realize its full of evil :p
03:21:54 <kmc> the instances for Maybe and [] and ((->) r) and such are similarly tiny
03:22:01 <zygoloid> benmachine: this is where we need a clear evaluation/execution distinction: "x >> y constructs an action which, when executed, performs the effect of x then the effect of y, and returns the value produced by executing y"
03:22:30 <kmc> i don't think IO is "full of evil"
03:22:33 <benmachine> zygoloid: are you talking about just IO here
03:22:38 <kmc> it's a good imperative language
03:22:47 <kmc> sometimes that's what you need to solve the problem at hand
03:22:58 <zygoloid> benmachine: yes.
03:23:08 <benmachine> ok, fair enough
03:23:10 <kmc> Haskellers can sound like a bunch of deranged fundamentalists
03:23:22 <kmc> which is unfortunate because Haskell itself is a well-balanced, multiparadigm language
03:23:35 <benmachine> I wouldn't call haskell very multiparadigm
03:23:37 <kmc> which has good support for IO
03:23:44 <benmachine> I know there are people who do OO in haskell
03:23:52 <kmc> the revolutionary idea in Haskell is that you shouldn't use mutable state everywhere all the time for the hell of it
03:23:58 <benmachine> but practically speaking it's not very common
03:24:00 <merijn> kmc: I like IO as a language
03:24:00 <benmachine> or simple
03:24:08 <clsmith> okay, so i'll assume that what i read was wrong, and it's just that IO is a compiler hack which happens to work well with monads? :p
03:24:16 <kmc> benmachine, maybe because the set of problems best solved by OOP is smaller when you have other tools too
03:24:19 <merijn> kmc: But from a semantics perspective it is terrible
03:24:20 <kmc> clsmith, that sounds better to me
03:24:30 <kmc> clsmith, it doesn't really have to be a compiler hack
03:24:49 <benmachine> kmc: sure. I don't need or want haskell to support OO, but it still doesn't :P
03:24:50 <kmc> clsmith, it's easy to describe the "building up descriptions of IO" part of IO in pure Haskell
03:24:57 <kmc> benmachine, sure it does
03:25:20 <benmachine> clsmith: IO in every language is a bit magic
03:25:21 <kmc> clsmith, the only magical part is that the runtime will *actually perform* whatever action you described and named "main"
03:25:54 <kmc> GHC's implementation of IO is a pretty huge hack though
03:26:05 <benmachine> sure
03:26:11 <benmachine> but we don't need to know what that is :P
03:26:18 <kmc> usually not
03:26:29 <kmc> it's not a good guide to how to think about IO, anyway
03:26:38 <merijn> kmc: That's also what I meant by full of evil, not that IO itself is evil. But IO's insides are :p
03:26:43 <kmc> clsmith, i hope the bit about describing IO and then performing it later makes sense
03:26:45 <RenJuan> "we don't need to know" + "we want it" = magic
03:26:48 <kmc> it's really really important
03:27:03 <kmc> i'm going to sleep now but other people can clarify if it's still murky
03:27:17 <kmc> ttyl all
03:27:20 <clsmith> okay, thanks :)
03:29:06 <zygoloid> is there a name for this pattern: FreeMonad (Yoneda f)  (where f is a GADT describing a set of primitive operations)?
03:47:49 <tomh-> is HOpenGL the same thing as OpenGL for haskell or are they different packages?
04:03:43 <Saizan> zygoloid: seen edwardk's free monads for less? sounds pretty similar to what's happening there
04:06:14 <hpc> tomh-: hopengl is the old name for the opengl package, iirc
04:07:04 <tomh-> ok thanks
04:09:17 <ivanm> @tell chrisdone it would be nice if there was also the facility of "I just want to open this file to read it; don't force me to create a new project or add it to an existing one"
04:09:17 <lambdabot> Consider it noted.
04:10:52 <tomberek> ivanm: regarding leksah?
04:11:42 <brisingr> quick question, having missed the IO conversation
04:12:06 <brisingr> supposing x has no side effects, what's the difference between y and x >> y?
04:12:15 <ivanm> @tell chrisdone it would be nice if there was also the facility of "I just want to open this file to read it; don't force me to create a new project or add it to an existing one"
04:12:16 <lambdabot> Consider it noted.
04:12:26 <merijn> brisingr: Nothing
04:12:34 <ivanm> @tell chrisdone also, it appears that what you're using for highlighting doesn't like the numbers in liftM<n>
04:12:35 <lambdabot> Consider it noted.
04:12:47 <tomberek> ivanm: regarding leksah?
04:12:52 <merijn> brisingr: Actually, that's the wrong answer. Correct one: "Nothing, in the case of IO"
04:13:00 <alpounet> tomberek, https://github.com/chrisdone/haskell-emacs I think... ?
04:13:09 <brisingr> merijn: but in the general case?
04:13:15 <ivanm> tomberek: nope, chrisdone's haskell-emacs stuff
04:13:20 <ivanm> alpounet: yeah, that
04:13:34 <ivanm> I've been giving him non-stop progress reports of me using it :p
04:13:36 <merijn> brisingr: Impossible to say, just like it is impossible to say what ">>=" does "in the general case"
04:13:50 <alpounet> ivan, i was planning on trying it. How is it ?
04:13:55 <ivanm> quite good
04:13:56 <tomberek> ah, i've been playing with the vim's haskell support, like it so far
04:14:13 <ivanm> dig through the logs of the past 48 hours (roughly) to see all my bug reports... :p
04:14:22 <brisingr> @src >>
04:14:22 <lambdabot> m >> k      = m >>= \_ -> k
04:14:29 <brisingr> ...right, yeah
04:14:40 <ivanm> there are a few funky things (some just because it needs work, others because chrisdone has his way of doing things that differs form mine)
04:14:56 <ivanm> I do sometimes miss the smarter indentation, and his highlighting support isn't as good yet
04:15:04 <ivanm> that said, I was running into bugs in haskell-mode as well
04:15:36 <alpounet> yeah ok
04:15:38 <Saizan> brisingr, merijn: each monad has its own notion of effects, if according to this notion x has no effect it's actually equivalent to return something and "return something >> y" has to be the same as y by the monad laws
04:16:03 <alpounet> ivan, do you know how far he is planning to get it ? I mean, there's "IDE" in the description...
04:16:07 <brisingr> Saizan: thanks, that sums it up
04:16:17 <brisingr> be right back
04:18:59 <merijn> Saizan: Yes, but monads aren't forced to obey the monad laws, so that'd make the answer "usually x >> y is the same as y (and if its not, stab the programmer)"
04:19:48 <opqdonut> merijn: don't you mean something like "return x >> y is the same as y"
04:19:54 <opqdonut> surely x could be e.g. fail
04:20:08 <opqdonut> oh, return x is what Saizan said earlier
04:20:11 <Axman6> that wouldn't do anything
04:21:20 <benmachine> I'd say 'y == x >> y' is a pretty good definition of 'x has no side-effects'
04:22:18 <opqdonut> yeah
04:22:43 <Saizan> merijn: i think it's more useful to focus on just the ones that do obey them when explaining
04:30:16 * hackagebot sfml-audio 0.2.1816.0 - minimal bindings to the audio module of sfml  http://hackage.haskell.org/package/sfml-audio-0.2.1816.0 (SoenkeHahn)
04:31:15 <tomh-> anyone knows if SDL is currently being maintained?
04:33:44 <Lemmih> tomh-: Why do you ask?
04:34:09 <tomh-> I'm in doubt whether to use GLFW or GLUT or SDL :)
04:34:59 <Lemmih> The haskell SDL binding is being maintained but I think GLUT is part of the Haskell platform.
04:35:21 <Lemmih> (To my dismay)
04:35:24 <tomh-> but GLUT itself is quite outdated
04:36:05 <tomh-> and GLFW seems to have some problems
04:36:07 <Lemmih> I wrote the SDL binding because GLUT annoys me so I'm obviously quite biased.
04:36:18 <tomh-> oh hehe
04:36:44 <tomh-> how well tested is it?
04:47:14 <Lemmih> tomh-: It has been around for years and is used by quite a few people.
04:47:40 <Lemmih> tomh-: The last bug report I received was about a year ago, I believe.
04:48:26 <Lemmih> tomh-: It's not a very ambitious binding but the little it does, it does well.
04:50:34 <tomh-> ok sounds good
05:00:17 * hackagebot wumpus-basic 0.21.0 - Basic objects and system code built on Wumpus-Core.  http://hackage.haskell.org/package/wumpus-basic-0.21.0 (StephenTetley)
05:00:18 * hackagebot wumpus-drawing 0.6.0 - High-level drawing objects built on Wumpus-Basic.  http://hackage.haskell.org/package/wumpus-drawing-0.6.0 (StephenTetley)
05:00:21 * hackagebot wumpus-tree 0.17.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.17.0 (StephenTetley)
05:00:40 <benmachine> I've used the SDL binding, but only for toys
05:10:32 <tomh-> mm I get this 'ghc: unable to load package `SDL-0.6.2''
05:12:16 <tomh-> oh and this '/Users/tom/.cabal/lib/SDL-0.6.2/ghc-6.12.3/HSSDL-0.6.2.o: unknown symbol `_SDL_FreeSurface'
05:14:04 <mornfall> Hm. Can I have a Handle backed by a ByteString? Eg.?
05:14:14 <mornfall> Or actually *any* way to use TextEncoding with ByteString.
05:14:40 <mornfall> (I just need to use localeEncoding...)
05:15:03 <Axman6> use Text if you need to worry about encodings
05:15:16 <mornfall> Text does not provide localeEncoding.
05:15:26 <mornfall> So I can't. (I use text, yes.)
05:18:33 <mornfall> I just need to decode a bytestring into a text/string, using the current locale encoding.
05:18:50 <tomh-> Lemmih: are you familiar with that error?
05:18:59 <mornfall> Something you would expect to be trivial, considering that all IO uses the locale encoding by default...
05:19:10 <mornfall> Text IO, anyway...
05:19:40 <mornfall> So far the only way to do that I figured out is to write out the bytestring into a file and read it back.
05:20:14 <mornfall> (Well, there's also Haskeline, which implements its own decode routine based on iconv, which can handle locales as well...)
05:21:37 <mornfall> OK, haskeline it is, then. :(
05:31:13 <willem> Do you need to always cast StablePtr to Ptr when using the foreign function interface?
05:32:04 <ClaudiusMaximus> @hoogle StablePtr -> (Ptr -> IO a) -> IO a
05:32:05 <lambdabot> Did you mean: StablePtr a -> Ptr a -> IO a -> IO a /count=20
05:32:05 <lambdabot> Control.Exception catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
05:32:05 <lambdabot> Control.Exception.Base catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
05:32:28 <ClaudiusMaximus> @hoogle StablePtr b -> (Ptr b -> IO a) -> IO a
05:32:28 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
05:32:28 <lambdabot> Foreign.Marshal.Alloc allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
05:32:28 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
05:33:48 <willem> well I mean can I use StablePtr in the declaration foreign import ccall "..." cFun :: (StablePtr/Ptr Int) -> IO ()?
05:34:13 <ClaudiusMaximus> willem: yes you can, according to the last section on http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-StablePtr.html
05:35:15 <willem> ClaudiusMaximus: thanks
05:45:30 <Eliel> what libraries are there for a file backed map/hasmap implementation?
05:46:27 <Eliel> I just realized one of my projects needs to store a few hundred megabytes of data in a random access structure.
05:47:36 <frerich> Eliel: You could maybe use the file system as it is; create some directory and store your data in convenient chunks (say, 64kB) with file names giving the chunk index.
05:48:16 <Entroacceptor> but a few hundert megs easily fit in ram
05:52:25 <Eliel> frerich: does not sound quite optimal. It's not a static datastore but for each entry there's one insert and one read (+most likely delete after).
05:53:38 <Eliel> each entry is between 100 bytes and at most a few kilobytes.
05:55:02 <ClaudiusMaximus> Eliel: i'd probably use a database for that kind of stuff (splite3 perhaps)
05:55:04 <Entroacceptor> Eliel: are you worried about persistance or about ram?
05:55:17 <ClaudiusMaximus> sqlite3*
05:55:24 <Entroacceptor> or acid-state
05:55:38 <Eliel> Entroacceptor: the system I'm running it on doesn't have enough ram in it for the data.
05:56:10 <Eliel> but yes, sqlite could work, although, I don't need the complexity of SQL, simple map is enough.
05:56:43 <Eliel> Entroacceptor: I'll take a look at acid-state.
05:56:55 <Entroacceptor> Eliel: that doesn't help you, then
05:57:19 <ClaudiusMaximus> or, enable swap and let the OS do your disk caching for you
06:00:31 <Eliel> ClaudiusMaximus: the process is going to be long lived and need to be able to shutdown and continue where it left off too.
06:00:52 <Eliel> also, would be nice if it didn't take all the memory on the system :)
06:02:09 <EvanR7> use erlang
06:03:45 <brisingr> quick question
06:04:00 <brisingr> (again) how do I logically link separate haskell slides in a presentation
06:04:33 <brisingr> not really haskell question but hey, it's worth a shot
06:05:14 <Entroacceptor> "next" and "previous"
06:05:28 <ClaudiusMaximus> Eliel: fair enough - then i'd almost certainly use a db
06:06:00 <brisingr> Entroacceptor: but the content? it's in the slides but it's like a slide is one box and the other one is in another so
06:06:29 <brisingr> Entroacceptor: I want something like >>= instead of >> b/w slides
06:06:39 <brisingr> hi da_petcu21
06:06:47 <da_petcu21> hi
06:07:07 <Entroacceptor> I'm not sure I understand what you ask
06:07:31 <EvanR7> :t (>>=)
06:07:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:07:39 <brisingr> I want to make a presentation
06:07:54 <brisingr> and to make the next slide follow logically from the previous one
06:07:59 <brisingr> it's a haskell presentation
06:08:01 <brisingr> like, a talk
06:08:03 <brisingr> not
06:08:11 <brisingr> a presentation function
06:08:11 <ClaudiusMaximus> Eliel: i do use something like frerich's suggestion for a multi-level tree of tiles, because each tile is around 750kB which is big enough to offset the file system overhead
06:08:23 <brisingr> my bad for the explanation
06:09:57 <Eliel> Thank you for the suggestions :)
06:10:00 <ClaudiusMaximus> brisingr: i use LaTeX 'beamer' to get me a pdf; you could maybe use lhs2TeX with it
06:10:04 <frerich> ClaudiusMaximus, Eliel: I think using the filesystem extensively here makes a lot of sense if you don't need to do complicated accesses as SQL allows (with conditionals and whatnot). The file system *is* a database already and it has a lot of the complexity sorted out already. It also does caching, persistence and (depending on the filesystem) atomicity for you.
06:10:47 <ClaudiusMaximus> frerich: right, but the filesystem also has an overhead of maybe 4kB/file, which is silly if you're only storing 100 bytes...
06:11:13 <ClaudiusMaximus> (at least, the file systems i've used)
06:11:33 <brisingr> ClaudiusMaximus: yes, I use beamer too
06:11:46 <brisingr> so let me rephrase the question and undo my failure
06:12:13 <brisingr> I want the content of a slide to logically lead to the next slide
06:12:19 <brisingr> from easy to complex
06:13:18 <brisingr> should I do something like basic functions -> intro to lists -> types and typeclasses -> more functions -> higher-order functions -> functors -> monads
06:13:56 <EvanR7> functors -> applicatives -> monads ?
06:14:02 <EvanR7> monoids!
06:14:15 <Entroacceptor> copy the structure from LYAH
06:15:06 <brisingr> Entroacceptor: that's what I was thinking
06:18:26 <zygoloid> brisingr: so your presentation is presenting the haskell language itself?
06:18:57 <brisingr> its coolness
06:19:32 <brisingr> I intend to use snippets of code in almost all slides
06:19:39 <brisingr> things like histogram or fibo
06:20:00 <Entroacceptor> show the nice stuff
06:20:11 <Entroacceptor> some DSL
06:20:32 <ClaudiusMaximus> brisingr: generic tips might be found at http://research.microsoft.com/en-us/um/people/simonpj/papers/giving-a-talk/giving-a-talk.htm http://video.google.com/videoplay?docid=-4741879301982276957
06:20:54 <brisingr> cool thanks
06:21:19 <Entroacceptor> wasn't he famous for having ugly slides?
06:21:40 <brisingr> omg, comic sans
06:22:17 <joedev> Hi
06:22:21 <brisingr> hi
06:34:47 <brisingr> ClaudiusMaximus: I've just read that
06:35:21 <brisingr> I've realized that I've been going about it all wrong
06:35:21 * hackagebot hxt-regex-xmlschema 9.0.1 - A regular expression library for W3C XML Schema regular expressions  http://hackage.haskell.org/package/hxt-regex-xmlschema-9.0.1 (UweSchmidt)
06:36:21 <brisingr> now the question is, what should I include? certainly a teaser "show you something cool so I can show you something even cooler"
06:36:30 <mokus> does cabal support a "changelog: " field or anything of the sort?
06:37:49 <Axman6> no, sadly
06:37:50 <mokus> I've searched for a few "obvious" words/phrases in the cabal user guide but haven't found anything
06:37:59 <mokus> bummer
06:38:03 <Axman6> you can add it to the description
06:38:13 <mokus> yea, i've seen that done but it always looks so awful
06:38:28 <Axman6> agreed
06:38:40 <mokus> i might start doing it anyway though, because it's good info to provide
06:38:58 <Axman6> there should be one that includes the previous changelogs (with the option of showing more if you want, with the default being only the latest changes)
06:39:01 <increpare> copumpkin: finally got the frequent subgraph algorithm working.  It's not fast (main aim was to get it to work at all rather than to work well), but…it works.  Ended up having to write a wrapper class for Data.Graph to keep things under control.
06:39:10 <mokus> especially in the case of a few recent ones i've uploaded where the only changes were to enable -XSafe, etc.,
06:39:11 <copumpkin> cool!
06:40:21 <copumpkin> increpare: is the code up somewhere?
06:42:08 <increpare> copumpkin: Not yet.   I should do a little more testing, but can upload it if you'd be interested in having a glance.  It ended up looking a lot more functional than I had anticipated it would.
06:42:39 <copumpkin> cool :)
06:42:48 <increpare> will let you know
06:43:24 <copumpkin> thanks
06:45:21 * hackagebot hxt 9.1.3 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.1.3 (UweSchmidt)
06:55:22 * hackagebot flexible-defaults 0.0.0.2 - Generate default function implementations for complex type classes.  http://hackage.haskell.org/package/flexible-defaults-0.0.0.2 (JamesCook)
06:58:35 <frerich> I currently have a small function 'pickChip' (see http://hpaste.org/50336) which makes some player in a game pick one of the 'covered' chips and add it to the chips the player has at hand.
06:59:05 <frerich> Unfortunately this 'deconstructing' of Game values and replacing items in a list of players using record syntax feels really clumsy.
06:59:33 <frerich> I think I should use a better data structure than plain old lists, and maybe refactor the function to have a different signature - but which? Does anybody have some suggestions?
07:00:22 * hackagebot AC-Colour 1.1.4 - Efficient RGB colour types.  http://hackage.haskell.org/package/AC-Colour-1.1.4 (AndrewCoppin)
07:00:51 <frerich> For instance, adding an element to the 'chips' list of some 'player' via 'player { chips = head covered : chips player }' seems a bit clumsy. Is there a nicer way to do that?
07:00:55 <opqdonut> frerich: maybe something like modifyAt :: Int -> (a -> a) -> [a] -> [a] would be useful
07:02:22 <frerich> opqdonut: Hmm, let me write that and see how the code looks like afterwards...
07:03:03 <opqdonut> and maybe something like modifyChips :: (Set -> Set) -> Player -> Player
07:03:14 <opqdonut> that way you can get into a more functory vibe
07:03:42 <frerich> Yes I think that's the crux, I have a lot of functions like 'pickChip' and many of them actually have signatures much like 'Game -> Game', which seems a bit... lame.
07:04:05 <opqdonut> but I tend to tolerate "ugliness" like in pickChip since it's only local
07:04:25 <opqdonut> but doing !! and then replaceNth calls for modifyAt :)
07:05:12 <frerich> opqdonut: True. Actually, I just realized modifyAt is a generalization of replaceNth
07:05:22 <opqdonut> that also
07:05:32 <frerich> replaceNth xs idx elem = modifyAt xs idx $ const elem I think
07:06:03 <opqdonut> well, I'd order the arguments like modifyAt (const elem) idx xs
07:06:10 <opqdonut> but whatever
07:06:20 <frerich> Why?
07:06:38 <frerich> Just curious, because I notice I always pick unfortuante orders of arguments (I notice when I try to curry)
07:06:47 <roconnor> frerich should make a lens ?
07:07:12 <frerich> roconnor: Err, I don't understand?
07:07:49 <roconnor> frerich: a lens is a construct that is used to read and modify substructures of data.
07:08:30 <roconnor> a lens is a *composable* construct that is used to read and modify substructures of data.
07:09:13 <frerich> Hm, that sounds interesting. Getting at the 'inner' values of some nested data structure always became ugly in my programs.
07:10:05 <roconnor> There are several packages providing lenses under various names.  My favourite is http://hackage.haskell.org/package/data-lens
07:10:11 <roconnor> that said, I've never used it :D
07:11:54 * roconnor wonders if data-lens needs a tutorial
07:12:12 <frerich> Hm it does sound interesting, but some examples of how it beautifies code would be great.
07:13:47 <frerich> opqdonut: I htink 'mapAt' would be a nicer name than 'modifyAt', what do you think?
07:13:52 <roconnor> when you modify a nested structure, the naive method means writing something like foo{fooField = (fooField foo){barField = f (barField (fooField foo))}}
07:13:52 <opqdonut> sure
07:14:11 <flux> that seems nice. maybe I'll steal it to some o'caml project :).
07:14:20 <opqdonut> frerich: I tend to favor signature that end in A->A for some type A
07:14:27 <roconnor> with lenses you would write something like modL (barLens . fooLens) f
07:14:44 <roconnor> with lenses you would write something like modL (barLens . fooLens) f foo
07:14:47 <opqdonut> yeah, lenses are the generic way of doing modifyNth, modifyChips etc.
07:14:56 <frerich> roconnor: Hm that soudns interesting (and the naive code you sketched actually looks much like the code I'm proudly showing to other people, oops)
07:15:18 <roconnor> frerich: heh, don't feel bad about it.
07:15:49 <flux> opqdonut, hm, so for modifyNth you would provide a functino that returns a Lens for an index and then use that Lens for actual modification?
07:16:16 <roconnor> with common lens operators, you can access a get a nested field with foo^.fooLens^.barLens
07:16:30 <roconnor> which should look familiar if you know Pascal
07:16:34 <opqdonut> flux: yeah
07:16:38 <frerich> Yes, it does.
07:16:40 <roconnor> ... maybe people don't know Pascal nowadays
07:17:49 <roconnor> of course in Haskell (^.) is the operator name and it doesn't decompose into ^ and . like it does in Pascal
07:19:15 <roconnor> frerich: there are also a whole bunch of operators that can be used in the state monad
07:19:39 <dolio> Did people know Pascal in your day/
07:19:46 <roconnor> dolio: yes
07:19:57 <roconnor> dolio: Pascal was taught in 1st year CS
07:21:08 <dolio> I think I barely missed learning Pascal in high school.
07:21:30 <dolio> I took the computer science courses the year the AP test switched to C++.
07:21:36 <roconnor> do { fooLens ~= 7 } will set the fooLens field of the state of a State monad to the value 7.
07:21:59 <roconnor> do { fooLens += 7 } will increment the fooLens field of the state of a State monad by 7.
07:22:10 <roconnor> etc.
07:22:55 <roconnor> finally focus :: Monad m => Lens a b -> StateT b m c -> StateT a m c will lift a state monad operating on a substructure b to a larger structure a.
07:23:09 <roconnor> this lets you modularize your stateful development.
07:27:38 <Phyx-> ooh #haskel forwards here
07:33:50 <brisingr> here I go again.. tell me a 5-liner SUPER AWESOME HASKELL THING!!!!11
07:34:09 * brisingr plans to kill himself after he finds out
07:34:09 <Axman6> why?
07:34:19 <roconnor> 5-lines is kinda long for a Haskell program
07:34:20 <brisingr> I'd like to give a talk
07:34:29 <brisingr> yes, but utter goodness
07:34:34 <Axman6> roconnor: including all types of course
07:34:45 <roconnor> oh okay
07:34:51 <brisingr> it will be the first and last slide
07:35:28 <brisingr> or maybe a link to pure haskell awesomeness
07:35:52 <christo_m> brisingr: http://www.haskell.org/haskellwiki/Blow_your_mind
07:36:03 <Axman6> if you could write something that could parse and execute lambda calculus/SKI, that would be pretty cool. i'd doubt you could do it in 5 lines... but... challenge!
07:36:20 <brisingr> christo_m I know them. is there something _awesomer_?
07:36:38 <christo_m> brisingr: define awesomer
07:36:41 <roconnor> Escardo's impossible function can be written in like 5 lines
07:36:57 <christo_m> maybe write a small interpreter/compiler?
07:37:18 <brisingr> awesome: something M$ under-executive will find remotely awesome
07:37:19 <christo_m> im honestly pretty new to haskell and i havent developed anything useful or cool yet.. just project euler problems mostly
07:37:35 <brisingr> something useful or whatnot
07:37:40 <christo_m> but those are more interesting to me than the newest "killer app"
07:37:41 <brisingr> I know 5 lines is a lot
07:37:47 <brisingr> but it'd be a hell of a punchline
07:38:05 <brisingr> punchlines, I mean punch5lines
07:38:11 <christo_m> if its a microsoft guy, maybe compare the brevity to LINQ ?
07:38:21 <brisingr> not only microsoft guy
07:38:32 <brisingr> mainly hi school/college students
07:38:35 <brisingr> but not all
07:39:09 <brisingr> some will be from m$
07:39:14 <christo_m> well, they probably hate math
07:39:31 <christo_m> so itll be hard to explain why haskell is cool in terms of pure functions without sideeffects
07:39:34 <brisingr> I know, i've gone sleepless nights on this
07:39:40 <christo_m> why?
07:39:47 <dolio> Escardo's impossible function isn't really that amazing. It's the ideas that lead up to it that are.
07:40:44 <ricree> As I was first learning Haskell after mostly imperative languages, the strength of Haskell's implicit typing was really impressive to me
07:40:51 <roconnor> dolio: really?  Most programmers appear to think that a finite domain is required to compare functions for equality.
07:41:29 <dolio> I mean the implementation.
07:41:32 <ricree> You can get some of the brevity of dynamic languages, with all the compile time benefits that strong typing provide
07:41:47 <djahandarie> Damn GHC. So close to doing this.
07:41:50 <roconnor> dolio: oh ya.
07:41:55 <dolio> Figuring out that you can do it is harder than doing it once you've figured that out.
07:41:57 <ricree> perhaps an example around that impress people
07:42:00 <christo_m> roconnor: since when can you compare functions for equality? (sorry i wasnt paying attention)
07:42:09 <djahandarie> f :: (forall x. a ~ b => x) -> blah     should put a ~ b in the context of f, right?
07:42:20 <djahandarie> Because it doesn't seem to be doing so
07:42:33 <roconnor> dolio: the existance of the function is what is impressive.  And I guess it really isn't specific to Haskell.  It work in ML and probably in C somehow too.
07:42:56 <roconnor> christo_m: well, if a function has a finite domain, it is pretty easy to compare them for equality.
07:43:51 <christo_m> roconnor: the only way i can think of is seeing if both map the values to the same co domain
07:43:56 <c_wraith> djahandarie: Well, as that signature stands, a ~ b isn't related to x, so I'm not sure exactly what it's doing there.
07:44:15 <christo_m> err, same values in the co domain
07:44:23 <djahandarie> c_wraith, it doesn't need to be. I just need a way to promote any arbitrary context from an argument to the function itself.
07:44:36 <djahandarie> (a and b are used in blah)
07:44:39 <increpare> is there a "group"-like function for Data.Set somewhere on hackage? (or a group function for lists that doesn't require the elements to be side-by-side to be grouped).
07:45:35 <roconnor> christo_m: for example: compareFunctions :: (Bounded a, Enum a, Eq b) => (a -> b) -> (a -> b) -> Bool; compareFunctions f g = map f [minBound..maxBound] = map g [minBound..maxBound]
07:45:48 <c_wraith> djahandarie: I'm really confused.
07:45:54 <roconnor> compareFunctions f g = map f [minBound..maxBound] == map g [minBound..maxBound]
07:46:31 <c_wraith> that requires the codomain be an instance of Eq also! :P
07:46:35 <roconnor> yes
07:46:44 <roconnor> I forgot ot mention that
07:47:26 <c_wraith> and the domain needs to be Bounded and Enum, but I don't think it needs more than that...
07:47:53 <djahandarie> c_wraith, I essentially have a 'proof' that a ~ b. I want to use that proof in f. Think of a and b as somewhat concrete types, not forall'd types
07:47:55 <roconnor> (Bounded a, Enum a, Eq b) => is what I wrote
07:48:21 <djahandarie> I'm sure this is possible, I'm just not sure how to make GHC actually see that information
07:48:41 <roconnor> but, of course, it is sufficent for the domain to be compact.
07:49:10 <c_wraith> djahandarie: ah.  well...  The only thing that comes to mind is including that proof explicitly in a GADT or the like, which has some syntactic overhead
07:49:23 <djahandarie> Ah, good call, that gave me an idea. THanks
07:49:46 <roconnor> There seems to be some sort of discrete/compat duality being exploted here that I don't fully understand.
07:49:51 <djahandarie> I don't actually need a GADT I don't think, a normal data type should work fine
07:50:12 <djahandarie> Oh no, GADT is required, nevermind
07:50:13 <roconnor> *compact
07:50:27 <christo_m> roconnor: your solution is what i was thinking of
07:50:30 <christo_m> man i love haskell.
07:50:32 <frerich> Does anybody know a nice way to implement a removeAt :: [a] -> Int -> [a] function which removes the element at a given position from a list? I have two implementations (see http://hpaste.org/50338) already but I don't like either very much. The former version because it uses (++), the latter because it zips and shortly after does 'map snd' again.
07:50:42 <christo_m> i love math and i love programming ,and haskell ties it together so awesomely
07:50:51 <roconnor> christo_m: yep.  However you can weaken the requirements on the domain from Finite to Compact.
07:50:54 <c_wraith> @src delete
07:50:54 <lambdabot> delete = deleteBy (==)
07:50:58 <mauke> frerich: splitAt
07:51:08 <christo_m> @src maximumBy
07:51:08 <lambdabot> Source not found. Maybe you made a typo?
07:51:18 <frerich> c_wraith: I want to delete at a certain position, not by testing for equality.
07:51:34 <c_wraith> frerich: oh, yes.  Is that not in Data.List?
07:52:05 <c_wraith> frerich: anyway, you can do it with take and drop, almost as efficiently as possible
07:52:17 <frerich> c_wraith: See my link, that was my first attempt.
07:52:51 <ricree> removeAt x:xs 0 = xs
07:53:04 <c_wraith> frerich: your second version appears to ignore its index and just use 5. :P
07:53:09 <ricree> removeAt x:xs n = x : removeAt (n-1) xs
07:53:17 <yrlnry> Do you know that in Haskell, (++) is not the inefficient thing it is in SML or Lisp or eager languages?  it will only perform as much of the append as is necessary.
07:53:29 <ricree> that sort of what you're looking for, frerich?
07:53:51 <frerich> ricree: Yes, but I Was hoping for something more high-level than a fold (or a raw recursion like yours), but that's exactly it.
07:54:30 <rwbarton> you can use splitAt
07:54:31 <c_wraith> frerich: I'm pretty sure that due to fusion rules, take ++ drop is going to be basically identical to direct recursion
07:54:38 <frerich> c_wraith: Oh, yes - I copied straight from my gvim.
07:54:50 <rwbarton> which is basically take and drop in a single pass
07:55:14 <rwbarton> > let (x, _:y) = splitAt 3 "abcde" in x ++ y
07:55:15 <lambdabot>   "abce"
07:55:34 <roconnor> frerich: There is probably no way of avoiding using something like (++).
07:56:02 <c_wraith> rwbarton: I'm not sure ++ will fuse with the results of splitAt
07:56:33 <rwbarton> what is there to fuse?
07:56:40 <rwbarton> oh I see
07:56:42 <frerich> I guess you could also say that I should just use a propre data structure, ahem.
07:56:48 <roconnor> frerich: as you advance your Haskell-fu, you will slowly stop using Integers with Lists, and gradually give up Integers all together.
07:57:40 <rwbarton> Well, the splitAt implementation won't cause a space leak like "take idx xs ++ drop (idx + 1) xs" will.
07:57:55 <c_wraith> ...  I don't see a space leak there.
07:58:20 <rwbarton> all of xs needs to be retained, to pass to drop, even as take consumes it
07:58:25 * frerich thinks this channel is great :-)
07:58:59 <c_wraith> rwbarton: that's not much of a leak.
07:59:12 <c_wraith> rwbarton: I mean, it's finite-size! :)
07:59:19 <rwbarton> it's proportional to idx
07:59:50 <rwbarton> so "sum $ removeAt n [1..2*n]" will take proprtional to n
08:00:02 <rwbarton> with that definition of removeAt
08:00:20 <rwbarton> take maximum concurrent space usage proportional to n, I mean
08:00:30 <c_wraith> actually, worse than the leak is the second traversal of the first idx elements of xs
08:01:07 <rwbarton> countaing traversals is a bit fishy because a single traversal that does twice as much work per step is no worse than two traversals, if the latter are properly lazy
08:01:19 <rwbarton> *counting, why can't I type today
08:01:27 <rwbarton> also, *no better
08:01:42 <c_wraith> actually, two traversals *are* worse.  That's why there's a fusion rule for map f . map g
08:01:52 <rwbarton> it's not that much worse
08:02:21 <rwbarton> It's not enough worse to say that in general, one traversal is always better than two
08:02:32 <rwbarton> it depends on how much work you are doing in the traversal, and you have to benchmark that
08:03:07 <rwbarton> That said, the direct recursive definition is almost certainly fastest
08:03:48 <roconnor> frerich: At your Haskell experience level, I recommend implementing things is the most clearly correct way possible first.  Worry about efficency later if it matters.
08:04:04 <roconnor> frerich: if that means take idx ++ drop (idx + 1) then so be it.
08:04:04 <rwbarton> and actually, I am not sure that the splitAt definition does not also have a space leak
08:04:49 <roconnor> rwbarton: I believe the splitAt doensn't have the leak.
08:05:05 <rwbarton> @src splitAt
08:05:05 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
08:05:12 <rwbarton> well I hope that's not the real definition
08:05:15 <roconnor> frerich: that said, It is very educational to ask and get answers to questions like yours
08:05:16 <copumpkin> lol
08:05:27 <roconnor> :O
08:07:05 <roconnor> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#splitAt
08:07:40 <rwbarton> hmm, this is slightly more detail than I was hoping for
08:08:09 <rwbarton> oh, it's not so bad actually
08:08:13 <c_wraith> looks like splitAt *does* have fusion rules, though! :)
08:08:22 <roconnor> from visual inspection it looks to me like if the first part of the splitAt result is consumed first there will be no leak.
08:09:40 <rwbarton> what happens if you make the binding of (xs', xs'') lazy?
08:10:36 <roconnor> rwbarton: the binding of (xs', xs'') is lazy.
08:10:45 <roconnor> rwbarton: all let bindings are lazy
08:12:41 <rwbarton> oh right.
08:15:24 * hackagebot converge 0.1.0.1 - Limit operations for converging sequences  http://hackage.haskell.org/package/converge-0.1.0.1 (JamesCook)
08:16:04 <kamaji> With do notation, how do multiple previous results get passed with >>=?
08:16:10 <kamaji> I don't really understand how it desugars
08:16:25 <Botje> kamaji: they are lexically bound
08:16:33 <roconnor> @undo do { a <- f; b <- g a; c <- h a b; z a b c}
08:16:33 <lambdabot> f >>= \ a -> g a >>= \ b -> h a b >>= \ c -> z a b c
08:16:45 <kamaji> does ghci have an "@undo" thing?
08:16:55 <kamaji> I don't want to spam the channel...
08:17:02 <roconnor> you can PM lambdabot
08:17:06 <kamaji> cool, thanks
08:17:15 <Botje> kamaji: everything to the right of \a -> has the variable a in scope.
08:17:22 <Botje> likewise for b and c
08:17:27 <rwbarton> it might help to put in the parentheses
08:17:47 <roconnor> kamaji: f >>= (\a -> g a >>= (\b -> h a b >>= (\c -> z a b c)))
08:21:59 <kamaji> Ah I see
08:22:17 <kamaji> I guess that's the point of lambdas
08:22:18 <kamaji> heh
08:22:24 <kamaji> welp, that explains it :)
08:40:09 <psysine> how sould i overload "+" and "-" for a data type where the other things in class Num don't make sense?
08:41:30 <Botje> you could replace them with error "does not make sense for this type"
08:42:11 <Botje> there is a prelude out there that refactors Num to be more fine-grained
08:42:29 <psysine> ok. is there any way that doesn't involve Num at all?
08:42:53 <copumpkin> just reject the standard prelude
08:43:04 <copumpkin> tell whoever designed Num to go **** themselves
08:43:10 <psysine> haha
08:43:16 <Botje> you could not import the standard prelude and define your own typeclass that includes num
08:43:35 <psysine> ok, thanks everyone :)
08:43:35 <Botje> uh, + and -
08:43:44 <Botje> copumpkin: was it one of the simons?
08:43:54 <copumpkin> beats me
08:43:59 <yrlnry> copumpkin: I want to tell that to the person who said that Monad instances have to define "fail"
08:44:08 <copumpkin> :)
08:44:12 <yrlnry> With (****) == "fail"
08:44:27 <copumpkin> someone should do some harcheology
08:44:33 <copumpkin> and find out who we can blame for all that shit
08:44:47 <mike-burns> I blame the decimal point.
08:44:57 <Botje> I blame socialism
08:45:03 <dolio> You might be able to blame fail on SPJ, as I recall.
08:45:04 <copumpkin> I blame obama
08:45:31 <dolio> I seem to recall him being the most prominent proponent.
08:45:38 <parcs> what's so bad about fail? if you don't use it don't redefine it
08:45:45 <copumpkin> parcs: wart
08:45:58 <parcs> there are worse warts than fail though
08:46:03 <copumpkin> oh yes
08:46:04 <yrlnry> I was about to say.
08:46:30 <yrlnry> Well, the inclusion of "abs" and 'signum" in Num… but that gets us back to where we started.
08:47:14 <copumpkin> or just the superclasses of Num
08:47:25 <copumpkin> Eq I can almost understand
08:47:30 <copumpkin> Show is lame
08:47:36 <yrlnry> Yeah.
08:48:02 <dolio> Show has about the worst justification, from what I've heard.
08:48:10 <copumpkin> what was it?
08:48:25 <dolio> Most of the time you want to show Nums, and it makes the context shorter.
08:48:56 <copumpkin> lol
08:49:04 <copumpkin> good point
08:49:23 <dolio> Same with Eq, really.
08:49:31 <dolio> Except there it's used for matching, I think.
08:49:35 <copumpkin> Eq is needed to pattern match
08:49:35 <copumpkin> yeah
08:50:07 <copumpkin> I think we should just have an implicit Eq on every type
08:50:18 <copumpkin> like other great languages we love
08:50:20 <dolio> That's the same justification, though.
08:50:30 <dolio> "I want to match on Nums a lot, and don't want to type Eq."
08:50:35 <copumpkin> yeah :)
08:51:21 <rwbarton> the premise is more plausible though
08:51:28 <rwbarton> I guess
08:51:42 <rwbarton> how often do you want to show a number but don't know what type it is?
08:56:03 <mm_freak> what's a good method to read JPEG files into pixel arrays?
08:56:11 <mm_freak> like Vector or UArray
08:56:23 <identity_> I remember there being some haskell library you could use to benchmark individual functions. What is it called again?
08:56:29 <mm_freak> (or a good library for that matter)
08:56:47 <luite> Codec-Image-DevIL has a simple function for that
08:56:55 <dolio> Criterion?
08:56:59 <identity_> dolio: that's the one
08:57:01 <identity_> I think
08:57:21 <rwbarton> mm_freak: repa and repa-devil look promising for that, I haven't gotten around to installing ghc 7 though to try it
08:57:42 <accel> ctually didn't paste it anywhere
08:57:44 <accel> fucking typed it here
08:57:47 <accel> but at some point
08:57:49 <accel> hit some key combo
08:57:59 <accel> and irssi decided "hmm, I'm goign to kill what you've written so far"
08:58:01 <accel> rather than send it
08:58:23 * accel invents his own lame jokes
08:58:27 <mm_freak> luite: looks good, thanks
08:58:41 <mm_freak> rwbarton: is repa really as fast as Array/Vector, if you don't use SMP?
09:01:47 <accel> oh shit, this is #haskell
09:01:49 <accel> not #startups
09:01:52 <accel> wtf am I doing here
09:02:06 <dainanaki> lol
09:02:18 <rwbarton> I don't know since I haven't tried it yet.  But one thing that looks nicer about it is that it supports multidimensional rectangular arrays specifically; with Vector you just have Vector (Vector a) which doesn't have to be rectangular.
09:02:40 <Entroacceptor> @hoogle Lens
09:02:40 <lambdabot> No results found
09:03:23 <copumpkin> rwbarton: and you don't get any nice flattening behavior with that
09:03:47 <mm_freak> rwbarton: looks promising…  i'll benchmark my package with repa (vs. Vector)
09:03:56 <rwbarton> I would love to hear the results of that
09:04:09 <mm_freak> problem is that repa will require more memory in my case, because i really have a Vector (IntMap a) right now
09:04:18 <mm_freak> the inner intmaps are sparse
09:04:38 <mm_freak> (it's a neural network and the Vector (IntMap Double) is the connection matrix)
09:04:39 <dainanaki> Speaking of vector, what's the best way to do bulk insertions?
09:04:47 <mm_freak> dainanaki: (//)
09:05:21 <dainanaki> mm_freak, isn't that updates, not insertions?
09:05:32 <kamaji> How do I check what classes a type is instances of?
09:05:49 <kamaji> oh :i works, my ba
09:05:49 <kamaji> d
09:07:49 <mm_freak> dainanaki: both
09:08:19 <mm_freak> dainanaki: you mean you want to split an array and put something between the parts?
09:08:30 <copumpkin> that's not a good use for vector
09:08:53 <copumpkin> although if you do it right, when it's a stream, it's probably fine
09:09:00 <mm_freak> copumpkin: actually it is…  it works well, as long as you get fusion
09:09:13 <copumpkin> yeah
09:09:17 <mm_freak> and as long as your vectors are finite
09:09:56 <dainanaki> Are lists the only O(1) insertion option for ordered containers?
09:10:15 <dainanaki> for single insertion, that is.
09:10:18 <copumpkin> you can use an arraylist-like structure
09:10:22 <copumpkin> for amortized O(1)
09:10:38 <dainanaki> that's what I was thinking. is there something like that already out there?
09:10:45 <copumpkin> I doubt it
09:10:52 <copumpkin> they're a very mutable structure :P
09:11:57 <dainanaki> I'm trying to build a high-performance quadtree, so I'm having a hard time figuring out an efficient way to represent it.
09:12:09 <mm_freak> is there a faster alternative to IntSet, if the set is very small like only a few thousand entries?
09:12:22 <mm_freak> IntSet seems to require 32 branches for every existing element
09:12:27 <Botje> mm_freak: an array?
09:12:33 <zygoloid> FingerTree / Seq has amortized O(1) push_front
09:13:04 <mm_freak> Botje: IntSet constantly requires 32 branches, while an array would require O(n)
09:13:17 <dainanaki> zygoloid: was that aimed at me?
09:13:20 <zygoloid> dainanaki: yeah.
09:13:22 <mm_freak> i don't care as much for insertions as for fast membership tests
09:13:31 <copumpkin> mm_freak: it isn't always 32
09:13:39 <copumpkin> mm_freak: it's at most 32 (or your bit size)
09:13:44 <zygoloid> dainanaki: the choice really depends on what other facilities you want from your sequence
09:13:56 <mm_freak> i think i'll use UArray Int Bool
09:14:05 <mm_freak> very quick O(1) lookup
09:14:19 <mm_freak> or unboxed Vector Bool
09:14:37 <Botje> does haskell optimize that to bitsets yet?
09:14:51 <copumpkin> some of the structures do
09:14:52 <mm_freak> Botje: yes
09:15:00 <Botje> ooh, shiny
09:15:02 <mm_freak> at least for UArray and unboxed Vector
09:15:30 <dainanaki> zygoloid: indeed. I'm looking almost exclusively for fast insertion and fast filtering.
09:20:11 <efie> what is the syntax for exporting "data" in a module? in my module vector i want to export "data Vector a = Vector a a a deriving (Show)", but "module Vector (data Vector a = Vector a a a deriving (Show))" does not work
09:20:45 <Saizan> just Vector(..)
09:20:54 <rwbarton> module Vector (Vector) where data Vector a = ...
09:21:05 <rwbarton> or module Vector (Vector(..)) to export the constructor(s)
09:21:57 <efie> thanks
09:24:52 <benmachine> or module Vector (Vector(Vector)) to export the constructor explicitly
09:25:10 <benmachine> module Module(Module(Module)) where
09:28:05 <Peaker> is 3 times enough? I think the reader may not be sure what name you're trying to export over there
09:28:29 * zygoloid wonders how many distinct variable names you need for lambda calculus to be turing complete
09:30:46 <roconnor> zygoloid: to just write functions or does the list include the fresh names possibly needed during execution?
09:31:01 <zygoloid> roconnor: just to write functions.
09:31:14 <ClaudiusMaximus> <=3 is my guess
09:33:43 <zygoloid> i can see how to do it with 3: (\s. \k. \i. <any ski term>)(\s. \k. \i. s i (k i))(\k i. k)(\i. i)
09:34:19 <ClaudiusMaximus> yeah that was my reasoning..
09:35:10 <roconnor> (\s. \k. <any ski term>)(\s. \k. \i. s i (k i))(\k i. k) -- a smaller term
09:35:44 <zygoloid> roconnor: sure. but you still seem to need 3 to define S, and the SK term will be longer than the SKI term :)
09:35:51 <zygoloid> (probably)
09:42:24 <sm_> hi all. Is there any strong reason not to include gtk2hs-buildtools as a dependency to ease installing gtk packages ?
09:42:30 <sm_> gtk-based
09:43:00 <rwbarton> http://www.springerlink.com/content/u82866761848712p/ "Two Variables Are Not Enough"
09:43:09 <rwbarton> very recent
09:43:19 <thoughtpolice> sm_: gtk2hs-buildtools does not expose libraries, only executables. cabal cannot track dependencies on executables
09:43:27 <thoughtpolice> although it could export a dummy module and list a dependency i suppose.
09:43:59 <sm_> I see - yes that might be nice
09:45:05 <sm_> I think if I include it currently, cabal install will install it every time
09:45:23 <increpare> copumpkin: just threw it up - https://github.com/increpare/vsigram
09:45:29 * hackagebot wl-pprint-extras 1.4.1 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-1.4.1 (EdwardKmett)
09:46:18 <dainanaki> does having more constructors for a data type increase its memory usage per value of that type?
09:46:51 <ion> edwardk: The home page is git://… in wl-pprint-extras.
09:47:18 <c_wraith> dainanaki: depends on if the constructor has arguments, how many there are, whether you're on a 32-bit or 64-bit system... etc, etc
09:47:46 <c_wraith> dainanaki: I guess the short answer is "it can"
09:47:50 <dainanaki> c_wraith, could you give me the long answer?
09:48:06 <dainanaki> i've been wondering about the details.
09:48:25 <edwardk> ion: woops
09:49:55 <c_wraith> I don't know all the details..  There are a lot of optimzations, and I really don't know how they all interact.
09:50:06 <dainanaki> hmm, okay.
09:50:31 * hackagebot wl-pprint-terminfo 0.5.2 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.5.2 (EdwardKmett)
09:50:33 * hackagebot wl-pprint-extras 1.4.1.1 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-1.4.1.1 (EdwardKmett)
09:50:50 <c_wraith> But there are certainly cases where pointer tagging happens, and that can only happen with a max of 4 constructors on a 32 bit system, or 8 constructors on a 64-bit system
09:51:27 <dainanaki> well, here's a different question: if the number of fields in a constructor varies per constructor in a data type, will all values of the type always utilize the amount of memory that the largest constructor would use?
09:51:28 <c_wraith> So...  In those cases, going over those numbers of constructors will make them take more memory
09:51:36 <c_wraith> No
09:51:48 <c_wraith> That much I'm sure of, from tibbe's talk on optimizing memory use :)
09:51:59 <dainanaki> okay then :)
09:52:10 <dainanaki> That will do for now then.
09:52:17 <dainanaki> thanks!
10:00:29 * hackagebot timeplot 0.3.8 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.3.8 (EugeneKirpichov)
10:04:02 <edwardk> dainaki: nope
10:04:31 <frerich_> Is there a more concise way to define a function which tests whether each element in a given list appears more than once than "all ((== 1) . length) . group . sort" ?
10:05:55 <bscarlet> frerich_: how about \x -> x == nub x
10:05:58 <copumpkin> all (null . drop 1) . group . sort is a little cleaner
10:05:59 <frerich_> I think this is suboptimal because at the point 'group' is evaluated, it would already be clear whether there is a list with length > 1 or not, so maybe this function could shiort-circout
10:06:35 <frerich_> bscarlet: Ha! Interesting!
10:06:41 <copumpkin> frerich_: that will be short-circuited anyway
10:06:46 <copumpkin> bscarlet's one is O(n^2)
10:07:02 <luite> frerich_: in your function, obviously the whole list must be sorted, but the rest will short circuit on the first group with the wrong length
10:07:02 <bscarlet> yep. concise, but not efficient.
10:07:36 <frerich_> copumpkin, luite: Ah, because the "outer loops" (group and all) are fused?
10:07:42 <dainanaki> if I have multiple shared libraries that I'm exporting functions from via the ffi, do I need to initialize a new ghc runtime for each library?
10:07:53 <luite> > all odd [1..]
10:07:54 <lambdabot>   False
10:08:04 <byorgey> frerich_: yes, because of lazy evaluation
10:08:20 <byorgey> frerich_: the result of group will only be computed to the extent that it is needed by all, and so on
10:08:29 <luite> frerich_: here, an infinite list. the rest is evaluated lazily, but all stops at 2, since it's not odd
10:09:07 <frerich_> byorgey, luite: Ah, makes sense. So lazyness is what makes it efficient here.
10:09:24 <copumpkin> frerich_: it's often the case, with functions in haskell
10:09:31 <copumpkin> composing things naturally actually is lazy enough
10:09:37 <roconnor> rwbarton: I can believe you found a paper on the topic!
10:09:47 <luite> frerich_: yes, with laziness you don't need explicit short circuiting, just functions that don't look at some part of the input
10:09:48 <copumpkin> rumor has it that head . sort is actually pretty efficient, for example
10:09:51 <copumpkin> but I haven't actually verified that
10:10:03 <roconnor> rwbarton: I *can't* believe you found a paper on the topic!
10:10:43 <frerich_> I still find it very hard to anticipate the efficiency of functions. Like, earlier I asked for an efficient definition of a 'removeAt :: [a] -> Int -> [a]' function and according to what ghci printed (with ":set +s"), the "naive" implementation ("take count xs ++ drop (count + 1) xs") was by far the most efficient.
10:10:55 <frerich_> Much more so than a hand-written recursion, a filter or something with splitAt.
10:11:12 <rwbarton> found it linked from an xkcd forum post of all places
10:11:19 <copumpkin> rwbarton: lol
10:11:29 <Saizan> ghci is not the best way to test for efficiency
10:11:35 <bscarlet> frerich_: do you consider \x -> length x == Set.size (Set.fromList x) concise?
10:11:39 <luite> frerich_: you can't really make it much better with lists, efficient deletion of arbitrary elements requires a different data structure
10:12:32 <frerich_> luite: Ah that's okay, my lists aren't very long (106 elements at most). So I'm mostly interested in "idiomatic" lists uses. Stuff like "zip [0..] xs" or so.
10:12:53 <frerich_> I'm sure there are more appropriate data structures, but that's an exercise for another day. Unless lists really become too p ainful :)
10:13:39 <frerich_> bscarlet: I think it's a little ugly since it takes advantage of how Set.fromList deals with duplicates, behind the scenes. But it's creative! :-)
10:14:08 <bscarlet> frerich_: ugly? Isn't that the very setness of set? :-)
10:14:37 <byorgey> yeah, that works because of the semantics of Set, not the implementation of fromList
10:29:45 <roconnor> rwbarton: I guess it goes to show that you can't spell S without I.
10:36:33 <sral> @pl f a b c d e f g = f g a d e c c b
10:36:34 <lambdabot> f = ((((const .) .) .) .) . flip . ((flip . ((flip . (flip .)) .)) .) . join . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .) . flip) .) . flip . flip (join id)
10:36:50 <leod> obviously
10:37:10 <Phyx-> yup
10:37:30 <benmachine> @. unpl pl f a b c d e f g = f c a b b a g e
10:37:32 <lambdabot> f bh df di _ dl _ f = ((((\ ae dx y z ac -> ae dx z ac y) >>= \ u v w -> u w v) ((\ ed ag ah ak -> ak ah bh ed ag) >>= \ cm -> cm) df di) >>= \ by -> (\ o -> o) >>= \ bx -> return (by bx)) f
10:37:32 <lambdabot> dl
10:37:40 <benmachine> oh right
10:37:49 <benmachine> pl generalises a bit, so unpl . pl /= id
10:38:09 <benmachine> well, unpl could possibly work out that the lhs of >>= is a function and inline it
10:52:08 <kate_r> hi
10:52:14 <benmachine> hi
10:52:24 <Ptival> newbie question here: is "inc n = (+ 1) $! n" the same as "inc n = let l = n + 1 in l `seq` l"? (in terms of laziness)
10:52:53 <copumpkin> x `seq` x doesn't do anything much
10:53:01 <benmachine> much? at all, surely
10:53:06 <benmachine> x `seq` x == x
10:53:14 <kate_r> just a quick check on terminology: given a consistent logical theory, is every sentence derivable from it "consistent" or "valid"?
10:53:19 <roconnor> x `seq` x === x -- very equal
10:53:28 <benmachine> :P
10:53:42 <benmachine> (+ 1) $! n = n `seq` n + 1, essentially
10:54:15 <Botje> Ptival: + is already strict in its arguments, so if n+1 is not being evaluated in time, inc n won't help
10:54:27 <benmachine> yeah
10:54:30 <Ptival> Botje: oh, didn't know that
10:55:13 <benmachine> strictness is tricky
10:55:16 <monochrom> "inc n = (+ 1) $! n" is the same as "inc n = n `seq` (n+1)
10:55:22 <benmachine> you can't force an expression to be evaluated from inside it
10:55:27 <benmachine> as it were
10:55:35 <monochrom> @src $!
10:55:35 <lambdabot> f $! x = x `seq` f x
10:55:44 <Ptival> :)
10:55:54 <Ptival> so, n and 1 are evaluated
10:56:11 <Ptival> but then is the sum performed lazily/strictly? (if it makes sense)
10:56:14 <monochrom> calculate, do not intuit
10:56:33 <Botje> Ptival: + is strict.
10:56:52 <monochrom> if nothing demands n+1, n is not evaluated. if something demands n+1, n is evaluated
10:56:52 <benmachine> Ptival: it's a question that only makes sense in a wider context really
10:57:24 <Botje> I guess Ptival is in a situation where thunks for +1 are accumulating
10:57:24 <Ptival> yes I see, the thing that calls inc can call it either way, is that it?
10:57:38 <Ptival> Botje: oh not at all, just trying to understand :)
10:57:44 <Botje> Ptival: no, it calls + or it doesn't.
10:57:56 <benmachine> Ptival: when you have something like a foldl where the thunks accumulate
10:58:02 <benmachine> you have to do the seq'ing in foldl
10:58:06 <benmachine> not in the function you pass to foldl
10:58:11 <Botje> once you start evaluating a +, you evaluate its arguments as well. that's what strict evaluation means
10:58:16 <Ptival> benmachine: ok, makes sense
10:58:31 <Botje> unlike, say, (:), which doesn't evaluate its arguments at all
10:58:49 <Ptival> like (inc n) `seq` (doStuff (inc n)) ?
10:58:49 * monochrom does not like wording it "strict evaluation"
10:59:09 <Botje> eager?
10:59:16 <monochrom> yes, eager
10:59:18 <benmachine> Ptival: you'd really need to do let n1 = inc n in n1 `seq` doStuff n1
10:59:23 <Ptival> ok
10:59:30 <Botje> Ptival: except those inc n values are distinct.
10:59:33 <benmachine> otherwise it might evaluate one inc n and not the other ;)
10:59:40 <Ptival> otherwise the two "inc n" are not the same thunk?
10:59:49 <monochrom> strict or non-strict semantics (denotational). eager or lazy evaluation (operational semantics)
11:00:14 <Botje> monochrom: noted. i'll try to keep it in mind
11:00:44 <Botje> although i've read that calling it 'lazy' evaluation is also not-really-right
11:00:44 <benmachine> Ptival: potentially the compiler could realise they were the same, but it's not obliged to
11:00:48 <monochrom> the mix up was populated by forefathers including Richard Bird and Philip Wadler
11:01:28 <Botje> pfft. what have they ever done for us! :)
11:02:10 <Ptival> where do I know that (+) is strict?
11:02:15 <monochrom> but the fact is that all 4 combinations of [(x,y) | x<-[strict, non-strict], y<-[eager, lazy]] are possible
11:02:16 <bscarlet> Botje: more to the point, what would they do for us if we actually needed it, yes?
11:02:33 <Botje> bscarlet: >:)
11:03:28 <benmachine> Ptival: you know it from your intuition fo what (+) does
11:03:40 <benmachine> Ptival: in order to know what a + b is, you *must* know what a and b are
11:03:49 <Botje> I can imagine the + for () being lazy.
11:03:55 <benmachine> sure
11:04:08 <benmachine> but all standard instances of Num have a strict +
11:04:11 <chrisdone> cabal update && cabal install c2hs && cabal install nyan && nyan
11:04:12 <lambdabot> chrisdone: You have 5 new messages. '/msg lambdabot @messages' to read them.
11:04:12 <chrisdone> :)
11:04:37 <djahandarie> I really wish you could partially apply type families...
11:04:51 <danharaj_> I almost tried to invoke ghc over irc -_-
11:05:22 <Botje> chrisdone: is that the nyancat progress thing you talked about yesterday?
11:05:31 * hackagebot nyan 0.1 - Bored? Nyan cat!  http://hackage.haskell.org/package/nyan-0.1 (ChrisDone)
11:05:38 <chrisdone> wait, what. who are you?
11:06:03 <zygoloid> what is this i don't even
11:06:21 <kamaji> ncurses nyan cat? :D
11:06:22 <monochrom> haskell 98 seems to actually leave open whether (+) for built-in types is strict
11:06:30 <chrisdone> ^_^
11:06:45 <zygoloid> no music. son i am disappoint
11:07:05 <monochrom> @quote monochrom lazy
11:07:05 <lambdabot> monochrom says: some kind of lazy evaluation is already known to highschool kids. teachers tell you that in a*(b+c), "evaluate b+c first", right? well, I challenge you to take 0*(389238493+97283748)
11:07:05 <lambdabot> and find one single student who faithfully evaluate 389238493+97283748 first.
11:07:08 <chrisdone> i looked at the audio APIs on hackage and O_O'd
11:07:19 <mroman> http://codepad.org/Q3QLo61L
11:07:28 <mroman> ^- is there a way to make ghc deduce "right"?
11:07:54 <mroman> I want a method in a typeclass which can return something where an instance exists
11:07:54 <monochrom> and that's the problem with "you know intuitively"
11:07:57 * copumpkin pokes edwardk 
11:08:04 <dolio> He's in a meeting.
11:08:06 <zygoloid> mroman: firstly, it looks like you're using hugs not ghc :)
11:08:11 <dolio> A different meeting.
11:08:14 <mroman> like class C m where c :: (C m, C t) => m -> t
11:08:17 <mroman> without m == t
11:08:22 <copumpkin> oh okay
11:08:24 <chrisdone> Botje: and yeah, i'm trying piping /dev/urandom to it before releasing the output part ;)   (that is, the rainbow will be replaced by your compiler output or w/e)
11:08:27 <mroman> zygoloid: Codepad uses hugs
11:08:31 <copumpkin> dolio: I am too :P
11:08:40 <dolio> Yeah, he's in the wrong one.
11:08:40 <mroman> Could not deduce (t ~ SwitchOn)
11:08:40 <mroman>     from the context (Switchable SwitchOff, Switchable t)
11:08:40 <mroman>       bound by the type signature for
11:08:40 <mroman>                  switch :: (Switchable SwitchOff, Switchable t) => SwitchOff -> t
11:08:41 <Botje> chrisdone: cool!
11:08:43 <chrisdone> cd ghc; make | nyan # ^_^
11:08:43 <monochrom> you know intuitively 0*whatever = 0 without caring about whatever. but no, most haskell implementations care about whatever.
11:08:44 <mroman> says ghc
11:08:51 <Botje> mroman: please don't paste in this channel
11:08:52 <copumpkin> oh
11:08:56 <zygoloid> mroman: ah :) well, in any case, you need a type annotation somewhere in the vicinity of 'show'.
11:09:06 <Botje> mroman: the compiler is complaining because there is no Switchable instance for Int
11:09:23 <Botje> mroman: you should do switch (switch (SwitchOff 0))
11:09:27 <monochrom> it is simpler and more tenable to just say that most haskell implementations make (+), (*) etc strict for built-in types, that's their rules, no reason, end of story
11:09:35 <mroman> eh
11:09:44 <benmachine> chrisdone: what's the install c2hs about?
11:09:55 <mroman> ok
11:09:58 <benmachine> I installed c2hs but am still getting an error
11:09:59 <mroman> that's an error there @switch 0
11:10:05 <mroman> but not the error ghc is complaining about.
11:10:07 <dolio> There's a reason.
11:10:16 <kamaji> I'm still installing c2hs :P
11:10:22 <kamaji> this better work
11:10:25 <kamaji> I demand nyan cat
11:10:26 <zygoloid> mroman: there's a third issue, too. the intermediate type between the two switches is unknown
11:10:33 <dolio> Performance.
11:11:07 <benmachine> hm, I don't actually have an ncursesw/ncurses.h
11:11:08 <mroman> GHC does not allow that t is not the same type as m
11:11:13 * benmachine pokes around for a useful arch package
11:11:24 <chrisdone> benmachine: ncurses doesn't have c2hs in its dependencies and fails to build without c2hs installed. kinda lame
11:11:30 <benmachine> oh
11:11:34 <parcs> benmachine: talking about the ncurses package?
11:11:34 <kamaji> benmachine: c2hs is in the AUR
11:11:41 <chrisdone> parcs: yup
11:11:52 <parcs> i've had many problems with it too
11:11:55 <zygoloid> mroman: so: 1) (switch 0) is an error, since 0 does not have a Switchable type. 2) switch (switch 0) is an error since the type 'between' the switches is unknown, and 3) show (switch (switch 0)) is an error since the type between show and switch is unknown.
11:11:55 <parcs> (on arch)
11:11:58 <benmachine> parcs: :(
11:12:06 <benmachine> kamaji: sure, but c2hs installed fine
11:12:09 <benmachine> it's ncurses that is the problem
11:12:15 <kamaji> oh right
11:12:16 <chrisdone> coding - 5 minutes; drawing ASCII art of nyan - 30 minutes
11:12:17 <kamaji> shat :\
11:12:22 <parcs> even changing the header to the one arch provides doesn't work to well
11:12:23 <benmachine> :D
11:12:28 <benmachine> time well spent
11:12:31 <chrisdone> :D
11:12:42 <zygoloid> mroman: i think the key issue is that 'switch' has the wrong type.
11:12:56 <parcs> for example, you can't dynamically link or run ncurses applications through ghci
11:13:18 <zygoloid> mroman: "switch :: (Switchable m, Switchable t) => m -> t" means that switch can produce /any/ type Switchable t => t, and the caller chooses which one
11:13:23 <parcs> too*
11:13:41 <mroman> http://codepad.org/e7lQFXBf
11:13:49 <mroman> zygoloid: That would be the Idea, Yeah.
11:13:57 <chrisdone> parcs: actually that works here
11:14:08 <chrisdone> … somewhat
11:14:13 <Botje> zygoloid: except your switch functions give one specific Switchable instance back.
11:14:25 <chrisdone> more like zalgocat
11:14:27 <mroman> except that t has to be an instance of Switchable, yes.
11:14:44 <chrisdone> must be because of the mixture of curses
11:14:57 <zygoloid> mroman: it looks like what you actually want is that the produced type is chosen by 'switch'
11:15:07 <kamaji> I am so shit at haskell
11:15:19 <Botje> mroman: your type says that, if there is a LaunchNukes instance for Switchable, switch (SwitchOff 5) :: LaunchNukes is a valid program.
11:15:24 <chrisdone> kamaji: at least you're pretty
11:15:28 <kamaji> lol
11:15:31 * hackagebot string-combinators 0.6.0.1 - Polymorphic functions to build and combine stringlike values  http://hackage.haskell.org/package/string-combinators-0.6.0.1 (BasVanDijk)
11:15:32 <kamaji> IF ONLY
11:15:54 <kamaji> then I could just sleep my way to haskell success
11:16:21 <mroman> Botje: But Switch does never return a LaunchNukes
11:16:39 <mroman> switch called with a SwitchOff always returns a SwitchOn
11:17:01 <mroman> ghc should be able to deduce that.
11:17:14 <chrisdone> kamaji: yep
11:18:01 <Botje> mroman: no, if you call switch (SwitchOff ...), you get something of type Switchable t => t
11:18:10 <mroman> Yes.
11:18:26 <mroman> But the type of t is fix.
11:18:33 <Botje> switch (SwitchOff ...) does NOT have the type SwitchOn
11:18:59 <mroman> Yeah. And my question is why ;)
11:19:20 <benmachine> chrisdone: I like your haddock
11:19:26 <benmachine> -- | Madness.
11:19:37 <chrisdone> :P
11:20:01 <chrisdone> @hoogle Int64
11:20:01 <lambdabot> Data.Int data Int64
11:20:40 <mroman> the type of switch (SwithOff x) = SwitchOn (succ x) is clearly SwitchOff -> SwitchOn
11:22:23 <mroman> theoretically ghc could infer that switch (SwitchOff 0) has the type SwitchOn if it looked at the definiton of switch
11:23:01 <mroman> I could deduce that in my head.
11:23:03 <dschoepe> mroman: If it tried to do that, type checking would become undecidable
11:23:27 <dschoepe> at least in the general case
11:23:41 <Saizan> mroman: the problem is that SwitchOff -> SwitchOn doesn't match the type of the switch you've to define to make an instance Switchable SwitchOff; since you need a "Switchable t => SwitchOff -> t"
11:23:49 <Saizan> mroman: which means it has to work for every t
11:24:11 <Saizan> mroman: if you want your instance to fix a specific type for 't' you've to change the definition of Switchable
11:24:36 <Botje> Couldn't you use a fundep m -> t ?
11:24:47 <Saizan> it has to make t a parameter of the class first.
11:24:48 <monochrom> if you don't make "switch" a type class method, "switch (SwithOff x) = SwitchOn (succ x)" will get you SwitchOff -> SwitchOn, sure
11:24:50 <Botje> but then Switchable should also include t.. right
11:24:56 <mroman> but I can't use (SwitchOn t or SwitchOf t) => m -> t
11:25:07 <chrisdone> <stdin>: hWaitForInput: invalid argument (Invalid or incomplete multibyte or wide character)
11:25:17 <chrisdone> how do you disable decoding in haskell's io functions?
11:25:26 <Saizan> chrisdone: set binary mode
11:25:31 * hackagebot repr 0.4.1.1 - Render overloaded expressions to their textual representation.  http://hackage.haskell.org/package/repr-0.4.1.1 (BasVanDijk)
11:25:38 <hpaste> kamaji pasted “IO” at http://hpaste.org/50339
11:25:39 <chrisdone> @hoogle hsetbinarymode
11:25:39 <lambdabot> System.IO hSetBinaryMode :: Handle -> Bool -> IO ()
11:25:41 <monochrom> hSetEncoding something something. or set binary mode
11:25:41 <mroman> switch :: m -> t is also invalid.
11:25:43 <chrisdone> ah ok
11:25:44 <kamaji> Is anyone prepared to deal with a complete misunderstanding about IO? If so, I refer you to the above paste. ^
11:25:47 <chrisdone> thanks
11:25:52 <kamaji> aka this: http://hpaste.org/50339
11:26:13 <Saizan> mroman: you need a multiparam typeclass, class Switchable m t where switch :: m -> t
11:26:30 <kamaji> I get why it's wrong, but not how to do it :\
11:26:35 <micahjohnston> how do I specify comipler flags (like -XFlexibleInstances) in a file?
11:26:44 <micahjohnston> I remember it's something about {- something -}
11:26:46 <Saizan> mroman: then you can make instance Switchable SwitchOff SwitchOn where ...
11:27:05 <Saizan> micahjohnston: {-# LANGUAGE FlexibleInstances #-}
11:27:06 <Botje> kamaji: you can execute IO actions with x <- foo
11:27:14 <monochrom> {-# LANGUAGE FlexibleInstances, DivineIntervention #-}
11:27:18 <bscarlet> mroman: as Saizan is saying: http://codepad.org/h8P5WD2H
11:27:20 <Botje> kamaji: counter <- newIORef 0 -- counter is now an IORef
11:27:52 <kamaji> oh...
11:28:15 <kamaji> isn't IORef doing some IO as well?
11:28:30 <kamaji> oh no that's the read/write functions
11:28:39 <Botje> IORef is a normal data structure, like a list or an Int
11:28:52 <micahjohnston> Saizan: thanks
11:28:57 <Botje> but you can only /create/ one by using newIORef, which has type a -> IO (IORef a)
11:28:57 <ion> or getLine
11:29:05 <Botje> since ghc has to allocate a cell for the IORef to point to
11:29:06 <micahjohnston> Saizan: where do I put it in the file? just anwyhere
11:29:07 <micahjohnston> ?
11:29:08 <Saizan> mroman: btw, i'd rather use data Switch = SwitchOn Int | SwitchOff Int; switch (SwitchOn x) = SwitchOff (succ x); switch (SwitchOff x) = SwitchOn (succ x)
11:29:16 <Saizan> micahjohnston: no, at the very top
11:29:16 <kamaji> ok, but since I'm doing IO in that function, I need to return an IO thing
11:29:20 <micahjohnston> Saizan: ok
11:29:23 <micahjohnston> thanks
11:29:51 <Botje> kamaji: what?
11:30:11 <kamaji> I'm not sure ;_;
11:30:12 <Botje> counter <- newIORef 0 -- counts as 'an IO thing'
11:30:19 <Botje> you execute the newIORef action
11:30:26 <Botje> and you bind the result to counter
11:30:28 <kamaji> I mean in the 'countHandler' function
11:30:34 <kamaji> I can't do anything to the IORef because that's doing IO
11:30:39 <Botje> why not?
11:30:48 <Botje> surely Snap has support for IO actions somehow?
11:31:08 <kamaji> oh I was trying to return a+1 for one reason... not sure why
11:31:28 <mroman> Thanks.
11:31:28 <mightybyte> Botje: Yes, Snap has a MonadIO instance.
11:31:30 <Botje> kamaji: Snap is an instance of MonadIO
11:31:31 <mroman> That works.
11:31:39 <Botje> so you can do io stuff inthere
11:32:07 <monochrom> liftIO (newIORef whee)
11:32:08 <mightybyte> Yes: liftIO myIOAction
11:32:09 <mroman> Saizan: I know that data Switch = SwitchOn Int | SwitchOff would be a lot easier.
11:32:26 <mroman> I just wondered if it is somehow possible with typeclasses.
11:33:07 <kamaji> Botje: is MonadIO the same as IO ?
11:33:09 <monochrom> it is possible with extensions. turn on all ghc extensions to enable oop
11:33:31 <monochrom> MonadIO is a type class for IO and derivatives
11:33:41 <Botje> kamaji: no. in a MonadIO monad you have to do liftIO (an IO action here)
11:34:41 <monochrom> liftIO :: (MonadIO a) => IO m -> a m
11:35:12 <kish> how do you do 1000 + 4% + 4% + 4%
11:35:30 <Botje> carefully.
11:35:43 <monochrom> 1000*1.04*1.04*1.04
11:36:00 <Botje> kish: how do the percentages stack? all at once or serial?
11:36:03 <kish> there's no short ?
11:36:05 <kish> serial
11:36:13 <Botje> then it's what monochrom said.
11:36:26 <Botje> you could do 1000 * 1.04 ** 3
11:36:38 <kish> i'll do thank. thanks
11:36:53 <deech> Hi all, how does something like the "trace" method works at (http://www.haskell.org/haskellwiki/Circular_programming)? I'm having trouble understanding how you can just conjure up a variable "d" and how that gets fed back into f.
11:37:21 <deech> s/"d"/"feedback"/
11:37:25 <copumpkin> :t loop :: ((input, feedback) -> (output, feedback)) -> input -> output
11:37:28 <lambdabot> forall input feedback output. ((input, feedback) -> (output, feedback)) -> input -> output
11:39:00 <deech> copumpkin: my mental block is on the "let (output, feedback) = f (input, feedback)" line. "feedback" isn't defined anywhere or passed it.
11:39:14 <copumpkin> do you understand fix?
11:39:18 <copumpkin> it's the same idea as fix
11:39:25 <deech> copumpkin: yes.
11:39:33 <monochrom> perhaps a simple example helps. let (y, xs) = (x+1, y:xs) in (y, xs)
11:39:43 <monochrom> > let (y, xs) = (x+1, y:xs) in (y, xs)
11:39:44 <lambdabot>   (x + 1,[x + 1,x + 1,x + 1,x + 1,x + 1,x + 1,x + 1,x + 1,x + 1,x + 1,x + 1,x...
11:39:50 <dolio> Do you understand 'f x = f (x - 1)'?
11:40:23 <deech> dolio: yes, that's just standard recursion, right?
11:40:30 <copumpkin> deech: you can write let x = x + 1, right? that x is like "feedback" in your example
11:40:46 <copumpkin> that probably won't terminate for most Num instances, but it's the same thing
11:41:07 <deech> copumpkin: ah, then it's the same as knot-tying.
11:41:41 <dolio> The examples in question just are just defining recursive things that aren't functions.
11:42:02 <monochrom> it seems you may also enjoy my http://www.haskell.org/haskellwiki/MonadFix
11:42:31 <deech> monochrom: I was actually just looking through that! It's well written.
11:42:54 <monochrom> "customers who bought CircularProgramming also bought: http://www.haskell.org/haskellwiki/MonadFix , http://www.haskell.org/haskellwiki/Dynamic_programming_example , http://www.vex.net/~trebla/haskell/fix.xhtml ..."
11:43:21 <monochrom> thank you for choosing monochrom!
11:43:53 <kamaji> How should I turn an Int into a ByteString like I would with "Show"?
11:43:55 <deech> monochrom, copumpkin, dolio: I think I understand how "feedback" recurses now. Wow, I feel as though I just lazy evaluation just little bit better now. What kind of mind (in a good way) comes up with this stuff?
11:44:18 <copumpkin> a perverse one!
11:44:29 <chrisdone> LOL. it works
11:44:46 <copumpkin> chrisdone, the modern frankenstein
11:44:46 <roconnor> deech: it is more natural than strict evaluation.
11:45:20 <dolio> More dinatural.
11:45:40 <benmachine> kamaji: I think there's a bytestring-show package
11:45:58 <kamaji> benmachine: oh ok, cheers
11:46:28 <deech> roconnor: Totally, it's just a mismatch between how I'm used to reading source code in strict languages and Haskell. When I first started developing I spent many clock cycles understanding "x=x+1" in the C sense. This is just total cognitive dissonance.
11:46:32 <chrisdone> copumpkin: haha
11:47:52 <kamaji> argh!!!!!
11:48:15 <hpaste> “Fred Morcos” pasted “Return IO Lists” at http://hpaste.org/50340
11:48:26 <dolio> What?
11:48:52 <fredmorcos> hi, i need help with ^
11:49:06 <kamaji> that package is for Lazy bytestring or something.... I swear i'm losing hair over this
11:49:36 <monochrom> the repmin feedback trick works because repmin is non-strict in the min
11:49:41 <dolio> Oh yeah.
11:49:43 <benmachine> you can convert between strict and lazy bytestrings without too much trouble
11:49:47 <deech> Wow I think I finally get how (n + k) patterns work too.
11:49:56 <dolio> binary works with lazy bytestrings, so that's what it does.
11:50:00 <chrisdone> those are deprecated, heh
11:50:31 <deech> chrisdone: yeah I know. I just had a whole logjam clear up.
11:50:31 <dolio> Explain how they work.
11:50:43 <bscarlet> fredmorcos: to get something else done, or to learn? (Do you want the easy way from a library, or to know how to do it yourself?)
11:51:13 <EvanR7> deech: haskell is a laxative for your brain
11:51:34 <monochrom> seqIO (x:xs) = do { tmp<-x; more<-seqIO xs; return (tmp : more) }
11:51:52 <monochrom> you now also see how to complete mapIO
11:52:03 <fredmorcos> bscarlet, to know how to do it, its an exercise from the wikibook
11:52:24 <monochrom> and of course after all your hard work, you still haven't done seqIO [] and mapIO []
11:52:28 <benmachine> fredmorcos: do you understand about recursion?
11:52:41 <hpaste> bragh pasted “chap 6 of Hutton book” at http://hpaste.org/50341
11:52:59 <benmachine> are you comfortable with things like the quicksort example (that isn't a quicksort but never mind)
11:53:11 <kamaji> Why is there only a function (toChunks) converting Lazy bytestring to strict bytestring?
11:53:15 <kamaji> a list of strict, even
11:53:16 <bragh> chrisdone: is (n + k) being deprecated also the reason why my paste doesn't work?
11:53:17 <monochrom> mul' m n = m + mul' m (n-1)
11:53:19 <fredmorcos> benmachine, yes and yes
11:53:46 <benmachine> kamaji: lazy bytestrings can be thought of as lists of strict bytestrings
11:53:51 <benmachine> kamaji: see also: fromChunks
11:54:02 <gwern> benmachine: can be? I thought that's what they *were*
11:54:07 <benmachine> fredmorcos: well, you've gotta use recursion
11:54:19 <jpcooper> hello. Is there a function [a] -> [Bool] -> [a] which takes [a] and [Bool] both of length n, and returns the a for which the corresponding element in [Bool] is True?
11:54:19 <kamaji> well then should I just concat the list?
11:54:21 <benmachine> gwern: I think they once were but are now something more efficient
11:54:24 <benmachine> kamaji: sure
11:54:26 <kamaji> I don't know what the laziness means really
11:54:36 <kamaji> or what the 'chunks' are?
11:54:44 <EvanR7> > snd (undefined, 5)
11:54:45 <benmachine> jpcooper: you can write such a function quite easily
11:54:45 <lambdabot>   5
11:54:50 <kamaji> I should probably read bytestring documentation but I just want a counter :p
11:54:50 <EvanR7> > (undefined, ,5)
11:54:51 <lambdabot>   Illegal tuple section: use -XTupleSections
11:54:57 <jpcooper> benmachine: yes I can. I wondered whether it existed already
11:55:11 <benmachine> jpcooper: I'd write it with map, filter, and zip
11:55:14 <benmachine> I don't think it exists already
11:55:21 <roconnor> @type concat . zipWith (flip guard)
11:55:22 <lambdabot>     Couldn't match expected type `[[a]]'
11:55:22 <lambdabot>            against inferred type `[Bool] -> [()]'
11:55:23 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
11:55:28 <jpcooper> okay, thanks
11:55:32 <roconnor> @type (concat .) . zipWith (flip guard)
11:55:33 <lambdabot>     Couldn't match expected type `[a]' against inferred type `()'
11:55:33 <lambdabot>     In the first argument of `flip', namely `guard'
11:55:33 <lambdabot>     In the first argument of `zipWith', namely `(flip guard)'
11:55:37 <fredmorcos> monochrom, does your solution count as tail recursion?
11:55:38 <roconnor> :(
11:55:55 <roconnor> @type (concat .) . zipWith (flip when)
11:55:56 <lambdabot> [[()]] -> [Bool] -> [()]
11:56:00 <monochrom> it doesn't
11:56:15 <fredmorcos> monochrom, due to lazy evaluation of more...?
11:56:24 <roconnor> hmm, guard was closer
11:56:34 <monochrom> no, due to the syntactic form
11:56:34 <fredmorcos> monochrom, sorry, *unlazy
11:56:38 <jpcooper> benmachine: how would I make it work on any type of list, though?
11:56:44 <roconnor> @type (concat .) . zipWith (\a b -> guard b >> return a)
11:56:45 <lambdabot> forall a. [a] -> [Bool] -> [a]
11:56:56 <roconnor> bah, it's too long
11:57:05 <monochrom> you will soon find out that tail recursion tells you nothing here
11:57:19 <benmachine> jpcooper: how would it not?
11:57:20 <monochrom> > foldr1 (&&) (repeat False)
11:57:21 <lambdabot>   False
11:57:33 <monochrom> not tail recursion, efficient
11:57:55 <roconnor> jpcooper:  \l1 l2 -> concat $ zipWith (\a b -> guard b >> return a) l1 l2
11:57:57 <jpcooper> benmachine: can I just define the type to be [a] -> [Bool] -> [a], and it will work with multiple types in the same programme?
11:58:02 <benmachine> jpcooper: yes
11:58:05 <jpcooper> okay
11:58:16 <monochrom> > foldl' (&&) False (replicate 1000000 False)
11:58:17 <lambdabot>   False
11:58:24 <monochrom> tail recursion, efficient
11:58:41 <jpcooper> thanks roconnor
11:59:17 <chrisdone> Botje: copumpkin: http://www.youtube.com/watch?v=RPT9MvsZIQA
11:59:21 <copumpkin> jpcooper: I'd do it ifferently
11:59:22 <erus`> can haskell optimize recursive calls to more than 1 func?
11:59:27 <jpcooper> copumpkin: how would you do it?
11:59:45 <monochrom> my http://hpaste.org/41790/controlmonadstatelazy is an extreme example
11:59:45 <roconnor> I would do it differently if I could figure out a shorter/better way
12:00:15 <monochrom> the extreme example also shows that it depends on which monad you use
12:00:36 <copumpkin> :t (map fst . filter snd) .: zip
12:00:37 <lambdabot> forall a. [a] -> [Bool] -> [a]
12:01:09 <Botje> erus`: how do you mean?
12:01:14 <roconnor> pfft, tuples
12:01:19 <copumpkin> lol
12:01:23 <roconnor> still, it is shorter and nice
12:01:25 <jpcooper> copumpkin: ahah, I haven't seen this .: before. Where does that come from?
12:01:30 <copumpkin> and it fuses nicely
12:01:37 <copumpkin> jpcooper: it's just a double compose
12:01:40 <roconnor> can I use .: too?
12:01:41 <erus`> gay n = if n > 3 then bum n else willies n
12:01:42 <EvanR7> .::
12:01:49 <roconnor> @type concat .: zipWith (\a b -> guard b >> return a)
12:01:50 <lambdabot> forall a. [a] -> [Bool] -> [a]
12:01:50 <copumpkin> :t ((map fst . filter snd) .) . zip
12:01:51 <erus`> where willies and bum call gay, willies or bum
12:01:51 <lambdabot> forall a. [a] -> [Bool] -> [a]
12:02:03 <EvanR7> .:^n
12:02:09 <jpcooper> @type .:
12:02:10 <lambdabot> parse error on input `.:'
12:02:11 <copumpkin> erus`: quit it
12:02:19 <jpcooper> I suppose .: is . and then :
12:02:32 <copumpkin> jpcooper: nah, it's just two (.)
12:02:43 <jpcooper> where is it defined?
12:02:45 <roconnor> It really feels like (\a b -> guard b >> return a) ought to be defined somewhere, like when
12:02:48 <copumpkin> in lambdabot :)
12:02:51 <Botje> erus`: if they are in tail position, haskell can compile the whole lot to essentially GOTO statements.
12:02:53 <copumpkin> roconnor: yeah
12:02:54 <jpcooper> okay
12:02:58 <ion> (.:) = (.).(.)
12:03:00 <Botje> *they = the calls)
12:03:05 <jpcooper> yeah good idea
12:03:06 <Botje> chrisdone: \o/
12:03:30 <copumpkin> roconnor: that's too pointful, still
12:03:57 <copumpkin> :t concat .: zipWith (curry (uncurry (>>) . (guard *** return))
12:03:58 <lambdabot> parse error (possibly incorrect indentation)
12:04:01 <copumpkin> gah
12:04:01 <ion> a <$ guard b
12:04:04 <roconnor> @type let when b a = guard b >> return a in concat .: zipWith (flip when)
12:04:05 <lambdabot> forall a. [a] -> [Bool] -> [a]
12:04:07 <copumpkin> :t concat .: zipWith (curry (uncurry (>>) . (guard *** return)))
12:04:08 <lambdabot> forall b. [Bool] -> [b] -> [b]
12:04:10 <monochrom> Botje, not haskell, ghc. but then ghc compile all "call"s to goto, recursive or not
12:04:11 <copumpkin> :P
12:04:29 <copumpkin> :t concat .: zipWith (curry (uncurry (flip (>>)) . (guard *** return)))
12:04:29 <lambdabot> forall a. [Bool] -> [a] -> [()]
12:04:33 <copumpkin> whoops
12:04:34 <benmachine> :t map fst . filter snd . zip
12:04:35 <lambdabot>     Couldn't match expected type `[(a, Bool)]'
12:04:35 <lambdabot>            against inferred type `[b] -> [(a1, b)]'
12:04:35 <lambdabot>     Probable cause: `zip' is applied to too few arguments
12:04:37 <ion> @pl \a b -> a <$ guard b
12:04:38 <lambdabot> (. guard) . (<$)
12:04:39 <benmachine> wups
12:04:53 <copumpkin> :t concat .: zipWith (curry (uncurry (flip (>>)) . (return *** guard)))
12:04:54 <kamaji> wait shit, I'm an idiot
12:04:54 <lambdabot> forall b. [b] -> [Bool] -> [b]
12:04:56 <copumpkin> there
12:05:07 <roconnor> wait a minute.  We are missing the big picture!  jpcooper: what happens if the lists are not the same length?
12:05:07 <copumpkin> that's roconnor's solution fully pointlessificated
12:05:19 <roconnor> copumpkin: much better
12:05:24 <copumpkin> bens: that's why I used .: :)
12:05:29 <copumpkin> roconnor: thanks!
12:05:34 <dolio> You need to make your code pointless.
12:05:36 <dolio> For the inliner.
12:05:38 <jpcooper> roconnor: there should be no such case
12:05:41 <copumpkin> lol
12:05:41 <roconnor> copumpkin: except for the damn tuples
12:05:42 <benmachine> > let result = (.) in result (map fst . filter snd) . zip
12:05:43 <lambdabot>   Overlapping instances for GHC.Show.Show
12:05:43 <lambdabot>                              ([a] -...
12:05:48 <benmachine> :(
12:05:50 <benmachine> :t let result = (.) in result (map fst . filter snd) . zip
12:05:51 <lambdabot> forall a. [a] -> [Bool] -> [a]
12:05:55 <copumpkin> I write all my code pointful
12:06:01 <copumpkin> then I run it through @pl before publishing it
12:06:08 <NihilistDandy> obvi
12:06:09 <copumpkin> it's the only way to go, really
12:06:11 <roconnor> jpcooper: your types ought to enforce that.  Write [(a,Bool)] -> [a]
12:06:15 <roconnor> instead
12:06:24 <copumpkin> roconnor: damn tuples
12:06:32 <roconnor> :D
12:06:38 <jpcooper> hmm
12:07:00 <roconnor> jpcooper: well, only do so if it makes your code better.
12:07:16 <roconnor> jpcooper: but generally it is good to make the impossible impossible.
12:07:23 <copumpkin> preventing invalid values is a worthy goal
12:07:39 <dolio> Write a type of statically sized lists.
12:07:43 <jpcooper> is there any way of asserting the lengths, or would that then have to be in the IO monad?
12:07:46 <dolio> Then you can ensure they're the same length.
12:07:54 <copumpkin> or just make a list of pairs
12:08:01 <copumpkin> that has the property by construction
12:08:03 <dolio> Too easy.
12:08:07 <copumpkin> true that
12:08:10 <dolio> By construction is no fun.
12:08:16 <monochrom> use agda or pvs to ensure equal length
12:08:28 <roconnor> jpcooper: you can use GADTs
12:08:37 <copumpkin> I've been tempted to write something on enforcing neat invariants like that in haskell without using dependent types or GADT wankery
12:08:55 <monochrom> will it use type class wankery?
12:08:59 <copumpkin> nah
12:09:03 <copumpkin> no wankery whatsoever
12:09:04 <ocharles> will it use any wankery?
12:09:06 <kamaji> I wish I wasn't so stupid. Thanks for your help everyone ( benmachine and Botje especially )
12:09:06 <ocharles> not interested.
12:09:15 <benmachine> kamaji: we all wish we weren't so stupid
12:09:22 <kamaji> hehe
12:09:29 <dolio> Did you ever explain in what way you're stupid?
12:09:29 <kamaji> I'm glad I can have dinner now though
12:09:41 <kamaji> fail to grok IO
12:10:01 <monochrom> no no, you are too smart, not stupid
12:10:03 <jpcooper> roconnor: what are GADTs?
12:10:10 <kamaji> also, I had some functions on the wrong side of a big (.) expression but I didn't want to say that~
12:10:15 <kamaji> monochrom: lol
12:10:17 <ocharles> jpcooper: http://www.haskell.org/haskellwiki/GADT
12:10:25 <roconnor> jpcooper: ... Don't use GADTs then :)
12:10:26 <kamaji> ok dinner
12:10:28 <roconnor> not yet
12:10:28 <jpcooper> thanks
12:10:31 <kamaji> thanks all
12:10:35 <EvanR7> IO is like a burrito with sensors and actuators
12:10:40 <ocharles> I think GADT's are kinda cool, I might be reading about them tonight
12:10:45 <monochrom> I try to be dumb, not try to understand IO or monad or whatever, understanding is for smart people, I just try to use, and become very successful
12:10:50 <ocharles> I haven't decided what to read over pizza yet
12:11:21 <monochrom> likewise, I do not try to intuit, intuition is for smart people, I just try to calculate
12:12:14 <rostayob> I've asked this question before now, but I still have this problem: has anybody got ghc-mod working?
12:12:40 <chrisdone> nope
12:13:10 <rostayob> chrisdone: I'm sure that someone had it working :P
12:13:34 <rostayob> also, I'm waiting an answer from the author, he has it working ehe
12:20:32 * hackagebot nyan 0.2 - Bored? Nyan cat!  http://hackage.haskell.org/package/nyan-0.2 (ChrisDone)
12:21:07 <monochrom> is that a game?
12:21:38 <benmachine> no
12:21:45 <benmachine> it's just a nyan cat
12:21:48 <merijn> ASCII nyan cat on command line?
12:21:55 <benmachine> animated with ncurses
12:21:59 <merijn> :D
12:22:08 <chrisdone> now with piping :p
12:22:12 <Botje> now to get it accepted by the simons ... >:)
12:22:23 <rostayob> The only thing I really want is to lookup the type of functions and jump to definitions, not only of the current project, but with all the libraries
12:23:40 * benmachine pipes tcpdump into it
12:24:00 <chrisdone> ooo
12:24:07 <rostayob> chrisdone: lol @ nyancat
12:25:24 <rostayob> ah also, flymake
12:26:04 <rostayob> is there a way to get flymake work with cabal?
12:28:35 <roconnor> not yet
12:28:38 <roconnor> oops
12:28:50 <hpaste> tibbe pasted “traverseWithKey” at http://hpaste.org/50343
12:29:22 <tibbe> I'm having troubles coming ST and Applicative. Anyone up to the task? In particular I'm not sure if I need some kind of lifting.
12:29:46 * benmachine fails to parse this
12:29:54 <benmachine> or rather, I parsed it but failed to interpret it
12:29:57 <copumpkin> tibbe: what's the error?
12:30:02 <roconnor> *combining
12:30:09 <benmachine> but my parser's non-modular so it all died :(
12:30:16 <tibbe> copumpkin: I'm not sure how to approach it.
12:30:37 <tibbe> copumpkin: I made a few attempts but couldn't quite get it to work. The implementation in the link above is simply that of 'map'.
12:30:45 <benmachine> I can't imagine you could get much out of ST without using the monaddiness
12:30:47 <tibbe> copumpkin: Which I try to to turn into traverse
12:31:02 <tibbe> benmachine: so I have a run for ST
12:31:36 <copumpkin> benmachine: he can use monad on ST
12:31:38 <tibbe> I think I need to end up with f (ST s (MArray s a)) in the end and then apply run <$> to get rid of the inner ST.
12:31:38 <copumpkin> just not on f
12:31:51 <benmachine> copumpkin: ah, I see
12:32:06 <tibbe> I did try to use >>= in combination with <$> and <*> but couldn't get the types to work out.
12:32:38 <benmachine> well, in principle at least you could go via toList and fromList
12:32:49 <benmachine> it would be slow but it might give you a reference implementation you could manually fuse
12:32:50 <copumpkin> it's kind of painful for a non-inductive structure
12:33:14 <roconnor> tibbe: see the Array instance of http://hackage.haskell.org/packages/archive/keys/2.1/doc/html/Data-Key.html#g:10
12:34:14 <tibbe> roconnor: traverseWithKey f arr = Array.listArray (Array.bounds arr) <$> traverse (uncurry f) (Array.assocs arr) ?
12:34:29 <copumpkin> that's probably as efficient as it can get
12:34:30 <roconnor> I guess
12:34:41 <roconnor> that looks good to me actually
12:35:03 <copumpkin> if you do the rest manually
12:35:05 <tibbe> (just for the record I'm using my own array type but that shouldn't change much)
12:35:05 <roconnor> I don't think using ST will make things any metter.
12:35:13 <roconnor> *better
12:35:14 <copumpkin> you're still going to be building up arrays recursively
12:35:19 <copumpkin> which isn't going to be pleasant
12:35:22 <tibbe> as long as I don't have to traverse the array twice
12:35:26 <copumpkin> so you might as well use an intermediate structure that's good at that
12:35:32 * hackagebot cryptohash 0.7.1 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.7.1 (VincentHanquez)
12:35:43 <tibbe> copumpkin: What do you mean by building it up recursively?
12:36:17 <tibbe> copumpkin: shouldn't I be able to manually fuse it, instead of going via lists?
12:36:34 <roconnor> heh
12:36:41 <roconnor> Vincent has a funny definition of pure
12:36:42 <copumpkin> tibbe: at each iteration of your traverse, you need to run the action and stuff the result onto the head of the rest
12:36:53 <roconnor> foreign import ccall "ripemd.h ripemd160_update"
12:36:54 <roconnor> 	c_ripemd160_update :: Ptr Ctx -> CString -> Word32 -> IO ()
12:38:42 <copumpkin> tibbe: keep in mind that you could need a thousand arrays in the output
12:38:48 <copumpkin> if you're running on the list monad, for example
12:39:08 <copumpkin> or list applicative, I should say :)
12:39:28 <tibbe> :/
12:39:34 <tibbe> this was unexpected
12:39:46 <copumpkin> Data.Vector has a similar approach
12:39:53 <copumpkin> I'm pretty sure I remember it going through lists
12:40:01 <tibbe> ok
12:40:03 <tibbe> oh well
12:40:05 <copumpkin> on the other hand, replicateM on vector could be done more efficiently, but isn't
12:40:13 <copumpkin> I sent roman a patch but I don't think he ever applied it
12:40:30 <copumpkin> replicateM on IO or ST, that is
12:40:48 <tibbe> copumpkin: Vector isn't traversable from what I can see
12:41:21 <peteriserins> what is a 'partial value'? I know what a partial function is, but could not find a definition of partial value anywhere even though it was referred to in a blog post.
12:41:22 <copumpkin> oh fair enough, I was thinking about the replicateM implementation then
12:41:38 <copumpkin> > let x = error "no" in x
12:41:39 <lambdabot>   *Exception: no
12:41:44 <copumpkin> x is a partial value!
12:42:10 <roconnor> > 1 :: undefined
12:42:10 <lambdabot>   Could not deduce (GHC.Num.Num undefined) from the context ()
12:42:11 <lambdabot>    arising fro...
12:42:15 <roconnor> > 1 : undefined
12:42:17 <lambdabot>   [1*Exception: Prelude.undefined
12:42:22 <roconnor> that is also a partial value
12:42:32 <edwardk> tibbe i have an instance in vector-instances
12:42:48 <copumpkin> > fix (1:) -- is this a partial value?
12:42:48 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:42:52 <edwardk> tibbe: roman seems to object to implementing even basic classes for vector
12:42:53 <peteriserins> a partial value is an expression that evalutes to undefined?
12:42:53 <roconnor> copumpkin: nope
12:43:08 <roconnor> peteriserins: nope
12:43:16 <tibbe> edwardk: I'm fine with adding all that don't require depending on new packages
12:43:26 <edwardk> me too
12:43:29 <roconnor> peteriserins: a partial value is a value that isn't one of the top elements in its CPO
12:43:40 <tibbe> (although I'd prefer people to send me patches for the more complicated ones xD )
12:43:53 <edwardk> i sent him a list with an implementation for each at some point
12:43:57 <peteriserins> Just _|_ is a partial value in Maybe Bool?
12:44:00 <roconnor> yes
12:44:20 <peteriserins> roconnor: thanks, cool
12:44:29 <edwardk> the only tricky one is Foldable because he exports foldr, etc with his own signatures
12:44:48 <edwardk> and so you'd need to do something drastic like move Data.Vector's guts into an Internal module and re-exporting
12:44:51 <roconnor> peteriserins: well that is how i use the term partial value.  I don't know about this blog post.
12:45:15 <peteriserins> roconnor: It's this one http://conal.net/blog/posts/a-type-for-partial-values. Is it related?
12:45:32 <roconnor> I think conal would use partial value in this sense.
12:48:44 <edwardk> tibbe++ for getting the ball rolling on the (<>) issue again
12:49:22 <tibbe> edwardk: I got a bit frustrated with us not being able to get it into base even though we had consensus on the issue 3 times or so
12:49:27 <edwardk> yes
12:49:28 <edwardk> exactly
12:49:47 <edwardk> that was why when i finally gave in and wrote Semigroup i just used the damn operator we'd all agreed on because I liked it ;)
12:49:54 <tibbe> :)
12:50:06 <tibbe> sorry if adding it causes you trouble
12:50:07 <opqdonut> what issue? (<>) = mconcat?
12:50:15 <tibbe> mappend
12:50:15 <edwardk> in the faint hope that i could get folks to standardize on adding Semigroup whenever people stp caring about depths of inheritance hierarchies
12:50:18 <edwardk> its a weekend
12:50:18 <roconnor> mappend presumably
12:50:22 <edwardk> meh
12:50:38 <opqdonut> yeah, that
12:50:40 <tibbe> I'd like to see SemiGroup et al in base, but we need to solve the language problem first
12:50:51 * roconnor has decided that dioids are of central importance to CS.
12:51:13 <edwardk> i have ~25 packages on hackage in which i have to change a total of about 130 or so imports, then the 100 or so packages that depend on mine should be ok, because most only depend on something else and don't import semigroups
12:51:14 <roconnor> typed dioids even
12:51:19 <roconnor> dioidoids?
12:51:42 <edwardk> the other packages of mine either don't mention semigroups or don't import monoid
12:52:15 * roconnor just realized that dioids are probably a play on monoids
12:52:18 <edwardk> The only thing I request is that the (<>) = mappend be a function in the module and not part of the dictionary itself
12:53:04 <edwardk> because then any code that uses import Data.Monoid(Monoid(..)) will still be okay
12:53:23 <edwardk> roconnor: dioidoids are fine
12:53:31 <edwardk> make a ringoid
12:53:48 <edwardk> give it the idempotent dioid properties
12:53:50 <roconnor> dioidioid would looks more symetric
12:53:56 <edwardk> =P
12:55:52 <tibbe> edwardk: <> will be top-level
12:55:58 <tibbe> for that reason
12:56:15 <edwardk> another solution for me would be i suppose to just export Monoid(..) from Data.Semigroup so then i don't need to qualify any import. i already export almost all the monoids anyways
12:56:29 <edwardk> i'd just delete the import Data.Monoid lines from all my packages
12:56:34 <edwardk> and I could be done in a couple hours
12:56:34 <tibbe> edwardk: Are people who use monoids and the semigroups package supposed to write: f :: (Monoid m, SemiGroup m) => ...
12:56:42 <edwardk> right now
12:56:50 <tibbe> right
12:56:51 <edwardk> same problem as with Applicative over Monoid
12:56:57 <edwardk> er Applicative over Monad
12:57:00 <Johannes`> hi, trying to install yi, how do i solve this: http://codepad.org/5n6jumsU
12:57:32 <Johannes`> did cabal update right before this
12:57:41 <edwardk> In general I use the Semigroup to describe the Bind, Extend and other semigroupoid structures which are implied by Monad, Comonad, etc. so it works out reasonably well in practice
12:58:38 <edwardk> in a perfect world i'd have all the granularity i need in the standard libraries, but until then this lets me forge ahead and make progress on the things that interest me
12:58:50 <tibbe> edwardk: that's good
12:58:59 <edwardk> and hopefully provides enough of a chicken that people realize the egg is worth hatching ;)
12:59:02 <tibbe> edwardk: we need someone to explore these structure in Haskell :)
12:59:10 <tibbe> edwardk: so you can teach us all the cool applications
12:59:28 <edwardk> tibbe: heh well, i think i have the first parsing combinator library that needs 'codensity' ;)
13:00:18 <edwardk> the main selling point for semigroupoids for me is that they make most of the prelude types into something that is 'almost a comonad'
13:00:41 <edwardk> so people can use these methods as a form of generalized 'tails' that work on things like Maybe, etc.
13:00:54 <parcs> Johannes`: "The program happy version >=1.17 is required but it could not be found"
13:01:01 <edwardk> and for those i need semigroups
13:01:31 <tibbe> I see
13:02:05 <edwardk> similarly many comonads are 'almost an applicative'
13:02:18 <edwardk> they have an associative <*> like operator but no pure.
13:02:27 <conal> on http://stackoverflow.com/questions/7046950/lazy-evaluation-vs-macros/7059279#7059279, i wonder whether i'm missing hearing something that Sam T-H is trying to say. or whether he's just reacting defensively, having somehow persuaded himself that i'm dissing macros.
13:03:31 <Johannes`> parcs: ah, thanks
13:04:19 <tibbe> woho! Ported all of unordered-containers from Patricia trees to hash array mapped tries!
13:07:39 <edwardk> tibbe nice!
13:07:54 <edwardk> tibbe: how is the performance difference?
13:12:09 <edwardk> i'm adding the re-export of Data.Monoid (Monoid(..)) to the list of other things I re-export from Data.Semigroup, then just dropping all my Data.Monoid import statements other than that
13:12:41 <tibbe> edwardk: lookups are about 3x faster than Data.IntMap, inserts about the same as IntMap
13:12:44 <edwardk> that way if you want (<>) from semigroup you import Data.Semigroup and Monoid is available via mappend, and otherwise you import Data.Monoid and you get the (<>)
13:13:08 <edwardk> would it be possible to get unionWith added?
13:13:18 <frerich_> Hm, if I have a lot of functions which access list elements via Ints, is that a good code smell that I should be using Data.Sequence instead?
13:13:43 <edwardk> frerich yeah, though there are plenty of alternatives
13:13:56 <edwardk> Data.Sequence is a good go-to default though
13:14:10 <edwardk> once it is clear you need random access and still need to cons or snoc
13:14:16 <ion> Is there some kind of instance that makes all Monoids without an explicit Semigroup instance Semigroups? Is that possible?
13:14:24 <edwardk> ion: nope
13:14:31 <edwardk> ion: doing so will overlap with any other instance
13:14:59 <edwardk> ion: there is a WrappedMonoid(..) which you can use to make a Semigroup for any type you don't own and don't want to write an orphan instance for
13:15:10 <edwardk> but that is the price we pay for the current brittle class system in Haskell
13:15:53 <ion> aye
13:15:55 <tibbe> edwardk: I've added it in HEAD
13:15:56 <frerich_> Yeah; I started off with [] and Int but now it's getting really annoying. In particular, I'd like to write a function 'move :: [[Chip]] -> Int -> Int -> Int -> Int' which can extract a certain element from a certain list and insert it at a given position in another list. This looks really ugly with lists...
13:16:05 <edwardk> tibbe: sweet =)
13:16:26 <tibbe> edwardk: now when the internal rewrite is done I'm looking at fleshing out the API
13:16:27 <edwardk> tibbe: i needed it for something in trifecta
13:16:32 <tibbe> ah
13:17:07 <kmc> frerich_, you're right that you should use Sequence instead
13:17:13 <kmc> consider IntMap also
13:19:02 <kmc> tibbe, nice
13:19:14 <kmc> tibbe, what's the tree fanout?
13:19:41 <tibbe> kmc: 16
13:20:01 <kmc> cool
13:20:06 <tibbe> best tradeoff between lookup and insert
13:20:16 <tibbe> fits in 2 cache lines
13:20:23 <kmc> are sparse nodes packed somehow?
13:20:27 <tibbe> yes
13:20:33 <kmc> cool
13:20:34 <tibbe> using a single word bitmask
13:20:39 <tibbe> and bit population count
13:20:47 <tibbe> to translate index to packed index
13:21:16 <tibbe> I've implemented faster bit population count in GHC HEAD, so things might be a bit faster in 7.4
13:21:32 <edwardk> what are you using for pop count?
13:21:43 <tibbe> edwardk: 256 byte lookup table
13:21:57 <tibbe> edwardk: best tradeoff between memory usage and speed I could find
13:22:09 <tibbe> the fastest implementation I know uses a 16-bit lookup table
13:22:23 <bos> as in 64KB?
13:22:30 <tibbe> bos: yes
13:22:31 <kmc> can you use POPCNT on CPUs that support it?
13:22:32 <edwardk> curious how it stacks up against https://github.com/ekmett/algebra/blob/master/Numeric/Coalgebra/Geometric.hs#L118
13:22:43 <tibbe> kmc: Implemented in GHC HEAD at CamHac :)
13:22:46 <kmc> cool
13:22:58 <home> wow this channel is packed 0_0
13:23:11 <tibbe> edwardk: is that a SWAR algorithm?
13:23:30 <tibbe> edwardk: the logarithmic number of step algorithms are a bit slower than the lookup table based ones
13:23:34 <edwardk> multiple simultaneous additions, shifted and added?
13:23:38 <tibbe> yes
13:23:51 <edwardk> when i last checked they were competitive but used less cache
13:23:56 <tibbe> yes
13:24:08 <tibbe> in microbenchmarks LUTs are faster
13:24:37 <tibbe> I'm not sure how much the fact that those touch memory affects real programs
13:24:48 <edwardk> it doesn't
13:25:00 <tibbe> but both GCC and LLVM use a LUT for their implementations
13:25:08 <edwardk> trying to dig up the benchmarks that drove me to this approach
13:25:15 <edwardk> *nods*
13:26:04 <edwardk> meh, happy to defer to someone else doing optimization work so i don't have to
13:26:20 <edwardk> in that case i just needed the answer ;)
13:27:09 <tibbe> :)
13:27:22 <tibbe> in 7.4 you will be able to use Data.Bits.popCount
13:27:36 <edwardk> nice
13:27:55 <tibbe> and it will do the right thing, including using -msse4.2 to use the POPCNT instruction
13:29:03 <byorgey> home: welcome =)
13:29:19 <home> byorgey: Why thanks :)
13:29:32 <edwardk> nice
13:29:51 <byorgey> home: learning haskell? or just curious?
13:30:13 <home> byorgey: Curious really, I dont have the time to learn haskell
13:30:25 <home> byorgey: trying to set up a portfolio/blog
13:30:38 <byorgey> home: fair enough. =)  well, feel free to hang out and ask questions
13:30:41 <home> maybe then I can learn haskell,lisp,ruby..etc
13:30:48 <home> byorgey: Oh thanks :)
13:33:39 <chrisdone_> home: http://tryhaskell.org !
13:35:14 <byorgey> anyone know off the top of their head whether some TH code generation can depend on whether or not something with a particular name was generated previously in the same file?
13:35:45 <byorgey> basically I want people to be able to call a function to generate some splices multiple times, but have only the first call generate some generic support code
13:36:01 <byorgey> then have the subsequent calls notice that it has already been generated
13:36:24 <mauke> is the support code static? can't you just import it normally?
13:36:57 <byorgey> It is not static.  Because Haskell lacks kind polymorphism there is support_code(n) for every n.
13:37:20 <mauke> then I'd see if a global IORef works
13:37:48 <byorgey> aha, that's an idea
13:37:55 <byorgey> thanks, I'll look into that
13:38:54 <MHD> aargh, macros for aglol derivative languages are hell!
13:39:44 <home> tryhaskell seems like an awesome site
13:39:54 <kmc> it is :)
13:39:58 <aninhumer> MHD: heh aglol... the lolcat theorem prover?
13:40:20 <home> I guess I have to take my time
13:40:26 <home> I am trying to learn to many things at once :)
13:40:28 <MHD> anihummer: lol
13:40:39 <MHD> aninhumer: lol x 2
13:40:46 <MHD> I can't spell right now
13:40:56 <MHD> meant algol
13:41:51 <mustelo> "i can haz propositional equality?"
13:42:27 <aninhumer> y meanz derezan x. wer x meanz q
13:42:45 <aninhumer> y => exists x. x => q
13:42:53 <MHD> "im in ur dependent typez stealin ur naturals"
13:43:02 <Cale> wait, wtf. Holding shift and typing MHD repeatedly on my keyboard is giving me: MΗΔΜHDMΗΔΜHDMΗΔΜHDMΗΔΜHD
13:43:05 <sm_> intense debugging of bizarre type error caused by editing an old emacs buffer with out of date file path.. ACK
13:43:45 <Sugarlake> haskell is too complicated
13:43:46 <Cale> anyway, I was going to say, macros for any language with a complicated syntax are sort of hellish.
13:43:53 <mauke> when losing your sanity, put a syntax error in line 1
13:43:55 <MHD> Sugarlake: Compared to what?
13:43:57 <ion> cale: A result of “optimizing” the number of physical wires within the keyboard, i’d guess.
13:44:02 <Sugarlake> compared to c
13:44:14 <Sugarlake> i'm really having a hard time learning it
13:44:17 <MHD> Sugarlake: Depends... C is pretty damn complicated too
13:44:24 <mauke> Sugarlake: how much C do you know?
13:44:32 <Sugarlake> 10years
13:44:41 <MHD> You are just predjudiced
13:44:46 <Sugarlake> maybe
13:44:47 <alpounet> Sugarlake, you're just used to C
13:44:55 <Sugarlake> i think that too
13:45:01 <ion> Yeah, it might be easier for you had you not learned C first. ;-)
13:45:03 <MHD> Haskell is about as far from C that you can get
13:45:08 <Saizan> that's an haskell for C programmers tutorial somewhere
13:45:10 <alpounet> do you think it'd be *that* complicated if you had never programmed before and would be starting with haskell ?
13:45:14 <Saizan> not sure how good that is
13:45:16 <gwern> I like reading the automated testing papers about undefined C operations
13:45:16 <Cale> ion: Hmm, maybe... if something acts like I'm pressing both shift keys when I'm only holding down one.
13:45:22 <alpounet> you have to update your view of programming
13:45:22 <Cale> Then it would have that effect.
13:45:31 <gwern> so much undefinedness
13:45:40 <Sugarlake> but everytime i open source code of someone it has completly "new" syntax
13:45:47 <Sugarlake> it at least seams like that
13:45:56 <Sugarlake> the language is just huge
13:46:19 <MHD> Sugarlake: Actually it is just simple
13:46:25 <MHD> And therefore extensible
13:46:28 <aninhumer> Sugarlake: That's not the language though
13:46:30 <ion> The syntax of the language itself is not very big. You’re just seeing people using libraries.
13:46:31 <mauke> Sugarlake: hmm, do you have an example of that?
13:46:37 <kmc> i'd say Haskell is medium-size among the languages I know
13:46:42 <ion> Which also happens in C. People use different libraries.
13:46:52 <kmc> you have to realize that Haskell lets you define new infix operators
13:47:06 <Sugarlake> yeah that makes it hard to read
13:47:07 <kmc> but they aren't special syntax; you can look up the definition in library code as usual
13:47:13 <Sugarlake> there is so much syntax
13:47:20 <mauke> Sugarlake: do you have an example of that?
13:47:32 <kmc> i'm not sure how you quantify "so much syntax"
13:47:33 <geheimdienst> yeah, i've noticed that too. people tend to define lots of their own operators and stuff. it's normal to see things like "className =? ... <&&> appName =? ... --> doF ..."
13:47:36 <ion> For instance, every C programmer is using a different linked list implementation. Haskellers usually use just one. :-)
13:47:40 <kmc> too many syntax rules?
13:47:46 <increpare> Though haskell's laziness lets people make new control structures like there's no tomorrow - it can take a while to get used to new programming construct X that's introduced.
13:47:52 <aninhumer> I think the infix namespace is getting a little crowded tbf
13:47:53 <geheimdienst> i guess there's a learning curve associated with all those EDSLs ...
13:48:07 <mauke> geheimdienst: yes, but it's not syntax
13:48:20 <mauke> imagine writing the same things in java syntax
13:48:24 <kmc> i don't see every new user-defined infix operator as "new syntax"
13:48:38 <kmc> it's a somewhat valid view
13:48:45 <kmc> depending on how many tricks they place with precedence etc
13:48:45 <Sugarlake> yeah it's not that the language it self has a "huge" syntax. it's just that every library implement it's own monads etc. that give me trouble
13:48:48 <geheimdienst> mauke: yeah, i meant that as an example of things that a random haskeller couldn't read if he stumbled upon them
13:48:52 <Eliel> Sugarlake: it can take a while for it to set in that infix operators are just regular functions.
13:48:54 <MHD> Haskell: Great for DSLs, not great for 5 of them at the same time.
13:49:01 <increpare> mauke: Most people wouldn't write the same things in java syntax.  This makes a lot of code more immediately grokkable.
13:49:08 <kmc> Sugarlake, well, the whole point of monads is that they all use the *same* syntax
13:49:10 <Cale> Sugarlake: The syntax of Haskell itself is kinda big when you add extensions, but it's nowhere near as complicated as parsing C++, say.
13:49:13 <kmc> that's why it's a type class
13:49:21 <ion> Libraries implementing an instance of Monad instead of NIHing the equivalent semantics actually unifies how things work.
13:49:51 <mauke> Sugarlake: that's like complaining that all collection classes define their own iterators
13:50:00 <kmc> if libraries didn't implement their own monads, and instead just implemented crap that looks kind of like a monad
13:50:00 <Cale> Sugarlake: But when you add in the language-like things that people do with libraries in Haskell, you have to consider some libraries like miniature embedded programming languages.
13:50:08 <kmc> then the situation would be a lot worse
13:50:22 <ion> When you see someone using <$> it tends to be immediately obvious what the code intends to do even if you’re not yet familiar with the functor in case.
13:50:24 <Cale> In fact, hmm... let's compare Language.C and Language.Haskell
13:50:33 * monochrom sees no difference between a library of many function names and a library of many symbol names
13:50:41 <Sugarlake> i guess it just takes time to learn it if you're biased with c
13:50:47 <kmc> yes
13:50:52 <alpounet> Sugarlake, well
13:50:55 <kmc> learning Haskell is slow going
13:51:09 <alpounet> we can say the same of glib for example
13:51:16 <Sugarlake> everytime i try something more complicated it ends in a mess
13:51:27 <Sugarlake> especially when i need states
13:51:48 <ion> Don’t forget to ask for help in, say, here. :-)
13:51:50 <mauke> Sugarlake: I'd like to dis your C skills
13:51:51 <Sugarlake> does anyone know how to do the states thing right?
13:52:00 <kmc> Sugarlake, maybe you'll get more out of this convo if you show us some specific code and we can help you clean it up
13:52:03 <Eliel> Sugarlake: the State monad tends to help.
13:52:10 <monochrom> some states are easy
13:52:14 <kmc> it doesn't always help, though
13:52:14 <monochrom> @src foldl
13:52:15 <lambdabot> foldl f z []     = z
13:52:15 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:52:16 <kmc> State isn't magic
13:52:29 <sm_> Sugarlake: how long have you been learnin ghaskell ?
13:52:32 <Cale> Sugarlake: Depends on what you mean by "do it right". A lot of people would say that the way that C manages state is the wrong way to do it.
13:52:33 <mauke> ST is a bit of magic
13:52:38 <monochrom> that foldl example is an example of doing an accumulator state (z)
13:52:57 <Sugarlake> does anyone know a good monad site?
13:53:05 <hpc> isn't ST just a simple subset of IO?
13:53:08 <Sugarlake> where i could learn this stuff?
13:53:11 <Cale> Sugarlake: There are a lot of ways to manage state in Haskell, from simple parameter passing, to things like the State monad, to ST and IO.
13:53:13 <ion> LYAH and the Typeclassopedia
13:53:14 <Eliel> Sugarlake: it's easiest if you have a mess to show us so we have something concrete to poke at :)
13:53:20 <increpare> hpc: it does very different stuff from IO
13:53:24 <geheimdienst> imho learning haskell libraries is difficult and i guess some of it is to blame on haddocks being incomplete, incomprehensible, or example-free ...
13:53:34 <aninhumer> Sugarlake: definitely LYAH if you haven't read it
13:53:44 <Cale> Sugarlake: and then you have things like FRP libraries like Yampa/Animas and Elerea
13:53:45 <monochrom> some other times you should not do state at all, not even mimicked accumulator state like the above
13:53:46 <increpare> geheimdienst: examples can be hard to find, which is the main problem I've had
13:53:49 <monochrom> @src map
13:53:50 <lambdabot> map _ []     = []
13:53:51 <lambdabot> map f (x:xs) = f x : map f xs
13:53:54 <Eliel> Sugarlake: I liked http://learnyouahaskell.com/ for introduction.
13:54:00 <increpare> @src fmap
13:54:00 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:54:02 <Cale> Sugarlake: which take a whole different route to the management of state in general
13:54:08 <sm_> Sugarlake: https://john-millikin.com/articles/monad-is-not-difficult/ is a nice short one
13:54:13 <mauke> Sugarlake: IMHO a "monad site" won't help you with this
13:54:19 <monochrom> map doesn't use an accumulator state, and should not. many newbies thought they needed one
13:54:35 <Sugarlake> for example: i you have a bitmap and you want to apply a specific function like wave function to every pixel. how would you do it efficiently?
13:54:40 <mauke> the whole issue of monads is somewhat orthogonal to purely functional programming
13:54:48 <frerich_> Sugarlake: What worked very well for me is to write little games in HAskell using almsot no library functions, and then asking for comments in this channel. I learned a great deal about the standard library and general programming techniques that way. And I had the motivation to use them, since I had a problem at hand (and I have 11 years of C++ by now)
13:54:53 <Sugarlake> i mean without copying lists around
13:54:56 <mauke> Sugarlake: with a loop?
13:54:59 <Eduard_Munteanu> < ion> For instance, every C programmer is using a different linked list implementation. Haskellers usually use just one. :-)
13:55:05 <Eduard_Munteanu> That could be attributed to a number of things.
13:55:08 <edwardk> I oppose any dependency (at this stage) on Monad.  For one thing, I don't know what a monad is.
13:55:11 <alpounet> Sugarlake, read Learn You A Haskell, practice with simple stuffs, read more complicated articles/blogposts/whatever, practice, ... and it will come, little by little
13:55:11 <Sugarlake> i mean an inplace modifcation as in c with pointers
13:55:22 <mauke> Sugarlake: you can do that
13:55:24 <kmc> use ST
13:55:29 <kmc> but, do you actually need that performance?
13:55:38 <monochrom> we have mutable arrays
13:55:52 <mauke> in some cases laziness pays off because you only need to look at some of the pixels
13:56:05 <Eduard_Munteanu> First, Haskell does contain a lot more "blessed" libs and functionality than C. Then Haskell coders are less like to care about microoptimization and writing specialized versions of such stuff.
13:56:10 <monochrom> we have some slower but more flexible mutable arrays, and some fast but restrictive mutable arrays
13:56:10 <copumpkin> you can even do some sort of mutability things in pure haskell, without ST
13:56:17 <copumpkin> mostly for "write-once" structures
13:56:24 <Eduard_Munteanu> *likely
13:56:52 <kmc> yeah, programming in C and C++ is all about premature microoptimization to a machine model from the 1970's
13:57:16 <Cale> Eduard_Munteanu: But C (and C++ because it also admits manual memory management) also has problems with library abstraction in general.
13:57:16 <monochrom> but we are still stuck with that machine
13:57:43 <kmc> monochrom, but we have cache-heavy superscalar pipelined out-of-order branch-predicted multithreading processors now
13:57:51 <Cale> Eduard_Munteanu: Every library can have its own convention for how allocation is done and who has responsibility to free allocated resources.
13:57:59 <MHD> Eduard_Munteanu: There's an article about optimizing haskell out there somewhere
13:58:00 <kmc> and also compilers smarter than they had in 1970
13:58:02 <Cale> Eduard_Munteanu: and then you end up with libraries that don't work together
13:58:04 <Eduard_Munteanu> kmc: to be fair it depends on the purpose. Now I agree if you argue we shouldn't use C, or abide to such practices, as much as we do
13:58:31 <kmc> many of the naive tricks for making C code faster end up being useless or counterproductive
13:58:33 <kmc> on today's machines
13:58:44 <kmc> where the instruction set is just an API to an extremely complicated implementation
13:58:55 <Eduard_Munteanu> However, stuff like branch likeliness annotation is likely to stay in Linux code and such stuff.
13:58:57 <geheimdienst> Sugarlake: i suggest you set yourself a small goal, write a program as far as you get, then ask here. either with the complete code for people to critique, or a part of the solution when you're stuck
13:59:00 <copumpkin> yeah, the compiler will often do some of the simplest stuff for you, so all you get from it is unreadable code
13:59:05 <monochrom> but ghc doesn't seem to exploit cache-heavy superscalar pipelined out-of-order branch-predicted multithreading processors. ghc seems to still generating 1970 code
13:59:10 <Cale> I think we shouldn't program in C because most of the things which C is better at than most other languages intended to be written by humans tend to be things which are better served by, say, LLVM.
13:59:20 <frerich_> Is there a conventional alias to use for Data.Sequence, much like 'M' is often used for 'Data.Map'?
13:59:28 <frerich_> S? Or Seq? Or something like that?
13:59:42 <hpc> depends on what other qualified modules you might have?
13:59:50 <monochrom> M is often used for 'Control.Monad'
14:00:06 <hpc> people import Control.Monad qualified?
14:00:09 <Eduard_Munteanu> monochrom: why? It's not like stuff in Control.Monad conflicts much with the rest of Prelude
14:00:19 <monochrom> no, but the M in mapM refers to Mona
14:00:25 <monochrom> s/Mona/Monad
14:00:28 <c_wraith> Who's Mona?
14:00:29 <Eduard_Munteanu> Ah.
14:00:32 * hackagebot semigroups 0.8 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.8 (EdwardKmett)
14:00:35 <copumpkin> c_wraith: lisa
14:00:41 <mauke> c_wraith: a japanese font
14:00:44 <monochrom> Mona is my mirror image
14:01:00 <geheimdienst> > reverse "mon a"
14:01:01 <lambdabot>   "a nom"
14:01:26 <hpc> in my font, the mirror image of mona is woue
14:01:39 <mauke> ɐuoɯ
14:01:59 <mauke> use ROT180 for enhanced security
14:02:09 <hpc> haha
14:02:16 <monochrom> if you want a transformation done on a mutable bitmap, you use a fast mutable array lib like "vector" and loop over it yourself, or even better call the lib's loop function
14:02:55 <Eduard_Munteanu> Or go through FFI and do it in C, where microoptimization is "kosher" :P
14:02:58 <aninhumer> mauke: It's cracked, everybody should move to ROT360
14:03:07 <monochrom> if you want immutable bitmaps instead, there are also fast immutable array libs and they provide loop-over-to-generate-new-array functions too
14:03:27 <monochrom> so generally just choose a lib and call one function
14:03:31 <mauke> aninhumer: do you know why it's called the XBOX 360?
14:03:48 <monochrom> well those libs do the FFI and optimizations for you
14:03:50 <hpc> monochrom: everyone knows applying the same encryption twice is less secure
14:03:53 <hpc> use ROT90
14:04:01 <frerich_> mauke: *drumroll...*
14:04:15 <monochrom> hpc?
14:04:34 <mauke> because when you see it, you turn 360 degrees and walk away
14:04:42 <hpc> instead of username abcd, password efgh, username ae, password bf :P
14:04:51 <monochrom> I am not using any encryption
14:05:01 * frerich_ golfclap's in mauke's general direction ;-)
14:05:30 <monochrom> but you could argue that I am using an involution 42 times without knowing it
14:05:32 * hackagebot tagged 0.2.3 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.2.3 (EdwardKmett)
14:06:19 <monochrom> wait, if you see it, then turn 360 degrees, then walk, don't you bump into it?
14:06:27 <Cale> ROT2600, super-secure
14:06:28 <MHD> mauke: *spins in place and moonwalks away*
14:06:32 <aninhumer> monochrom: thatsthejoke.jpg
14:06:41 <mauke> MHD: you're doing it right!
14:06:57 <mauke> http://img25.imageshack.us/img25/9792/whydotheycallitxbox360.png
14:06:57 <MHD> I am actually really good at moonwalking
14:07:09 <monochrom> ok so it is supposed to be moonwalk or "back away slowly"
14:07:29 <kmc> oh man, are those sprites from the Moonwalker arcade game?
14:07:38 <cheater> no from the sega game
14:07:51 <cheater> where you can sort-of punch kids
14:08:10 <kmc> as opposed to the arcade game, where you send your pet monkey to molest them
14:08:25 <cheater> i wouldn't know, i don't feed trolls
14:10:03 <monochrom> rot2600 may be a bit useful on unicode code points
14:10:22 <ion> 2600 Hz
14:11:58 <MHD> Okay so I have this crazy idea for tuples...
14:12:09 <MHD> Tuples literally express the act of stack pushing
14:12:16 <frerich_> What's something like 'x :: [a]' called? A polymorph value?
14:12:20 <MHD> nesting them is meaningless
14:12:34 <MHD> that would be rad for a language
14:12:54 <mauke> MHD: reminds me of perl lists
14:12:58 <bos> anyone around here know much about cabal?
14:13:01 <monochrom> you can call it a polymorphic value, if you are sure it's polymorphic, i.e., "a" is not to be pinned to a specific type later
14:13:01 <ion> Doesn’t (:) express the act of stack pushing better?
14:13:21 <geheimdienst> bos: never heard of it. nobody around here has.
14:13:26 <MHD> ion: this is more for function calls and multiple returns in an algol like language
14:13:34 <edwardk> heya bos
14:13:42 * bos waves
14:13:43 <MHD> this would also mean that operators could take multiple arguments...
14:14:12 <edwardk> bos: i'd like to set up some kind of conference call with me you, tibbe and jaspervdj to go over the Data.Text utf8 stuff and decide what to do
14:14:14 <aninhumer> Sounds like it could lead to really weird bugs
14:14:25 <bos> edwardk: oh?
14:15:16 <bos> edwardk: at the moment, i'm not feeling super warm about taking the utf8 patches
14:15:32 * hackagebot semigroupoids 1.2.6 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.2.6 (EdwardKmett)
14:15:36 <edwardk> well that was something i'd like to get through on the call
14:15:42 <edwardk> i'm okay with that being the response
14:15:48 <edwardk> i'd just like to talk through the issues
14:15:56 <bos> ok
14:16:58 <edwardk> accounting for this many timezone differences is hard. i know i can get me and jaspervdj on the line at around noon EST pretty much any day this week
14:17:04 <edwardk> not sure about you and tibbe
14:17:48 <edwardk> i must admit it makes me sad that i'll have to keep trifecta running on bytestrings though if that is the ultimate resolution, but that is a small personal sadness
14:18:13 <bos> edwardk: i could manage noon PST some day
14:18:17 <kmc> isn't there already a separate library for packed utf8 strings?
14:18:24 <bos> sorry, noon EST, edwardk
14:18:50 <edwardk> kmc: yes, but it doesn't any of the nice streaming, etc. that make text nice
14:19:33 <edwardk> whereas text is stuck with bytearray#'s which complicate interop
14:21:00 <edwardk> bos: great i'll let tibbe constrain the day then ;)
14:21:10 <dainanaki> how can one tell when something is worth 'par'ing
14:21:11 <dainanaki> ?
14:21:20 <bos> edwok
14:21:25 <bos> edwardk: opk
14:21:29 <bos> argh, typing
14:21:47 <bos> dainanaki: experience + experiment
14:21:56 <dainanaki> alright then.
14:21:59 <MHD> dainanaki: Many places seq is good, par is good too.
14:22:10 <monochrom> if x and y take about the same time and fairly independent, x `par` y is worthwhile
14:22:47 <edwardk> though you may want to mix that in with pseq'ing the next stage of the pipeline
14:23:15 <dainanaki> I'm a little confused about where to pseq and where to par.
14:23:26 <ion> > let push = modify . (:); pop = do { (x:xs) <- get; x <$ put xs }; divMod' = do { (a,b) <- liftA2 (flip divMod) pop pop; mapM_ push [a,b] }; plus' = push =<< liftA2 (+) pop pop) in evalState (do mapM_ push [10, 3]; divMod'; plus'; pop) []
14:23:27 <lambdabot>   <no location info>: parse error on input `)'
14:23:28 <kmc> they do totally different things
14:23:39 <kmc> (a `par` b) will evaluate a and b in parallel, sometimes
14:23:45 <kmc> (a `pseq` b) will evaluate a and then b, in sequence
14:24:02 <kmc> if you write (a `par` (a+b))
14:24:14 <bos> dainanaki: i'd strongly recommend using the monad-par package instead.
14:24:15 <kmc> there's a good chance (50% ?) that (a+b) will get evaluated first
14:24:19 <kmc> which starts evaluating 'a'
14:24:23 <kmc> and thus kills your parallelism
14:24:27 <bos> using par by hand is a very error-prone pain in the ass.
14:24:29 <dainanaki> hmm, ok then.
14:24:31 <kmc> so you do (a `par` b `pseq` (a+b))
14:24:31 <ion> Err, extraneous ) in plus'. Well, it would return 4.
14:24:46 <kmc> so that the current thread will chew on b first
14:24:51 <ion> Multiple returns, yay. :-P
14:24:54 <kmc> giving the RTS an opportunity to spark a thread for a
14:25:01 <dainanaki> ok, got it.
14:25:13 <kmc> dainanaki, pseq is what seq should be, basically
14:25:15 <edwardk> otoh you can par a (pseq b (a + b)) -- and then a can happen if sparks are running, but we'll start computing b before (a + b), giving a a change to finish before we add
14:25:20 <kmc> seq has only a denotational guarantee
14:25:25 <kmc> which is usually pretty useless
14:25:33 <kmc> pseq has the operational guarantee about ordering
14:25:53 <kmc> in fact i'd wager a majority of extant uses of seq should be pseq instead
14:26:03 <c_wraith> seq's denotational guarantee is sufficient for the case of (return $!)
14:26:12 <kmc> yeah
14:26:22 <ion> pop = state (\(x:xs) -> (x,xs))
14:26:47 * frerich_ realizes that he's getting older as he realizes that the cool guy writing all those interesting blog entries and maintaining that important package he uses is much younger than himself :-(
14:26:52 <edwardk> btw- does f <$!> ma = do a <- ma; return $! f a  have a name anywhere?
14:27:00 <copumpkin> anyone see that undo monad?
14:27:11 <monochrom> no, I disagree. see my http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/ although it is not (return $!)
14:27:18 <Cale> copumpkin: I did, because I wrote it
14:27:23 <edwardk> cale: url?
14:27:25 <copumpkin> Cale: well then :)
14:27:25 <jaspervdj> bos: Hmm, any particular consideration you have about the utf8 patches? I'm going to write a summary report on it this week, comparing the advantages and disadvantages.
14:27:30 <copumpkin> it's quite nice!
14:27:31 <Cale> (Or I wrote an undo monad, at one point)
14:27:34 <Peaker_> What's the Undo monad?
14:27:40 <copumpkin> the one I'm referring to is on the wiki
14:27:41 <Cale> I put it on the old Haskell Wiki
14:27:46 <c_wraith> monochrom: ok, it depends on the monad in question having a data constructor, such that >>= actually forces evaluation
14:27:50 <Cale> Probably it got migrated
14:27:59 <copumpkin> http://www.haskell.org/haskellwiki/New_monads/MonadUndo
14:28:08 <bos> jaspervdj: so far, the changes in performance and space use just don't look very compelling to me
14:28:19 <Cale> I don't actually write packages, because that would require filling in my name in the Maintainer field
14:28:29 <edwardk> ah
14:28:34 <Peaker_> Cale: and? :)
14:28:36 <copumpkin> Cale: sounds like a lot of work
14:28:38 <Cale> I just make the code public and let other people make packages for me
14:28:48 <Cale> hehe
14:30:19 <edwardk> bos: part of what i want to talk about is to define what it'd take to get over that hump, and what more radical things would have to happen to get a performance win
14:30:35 * hackagebot comonad-transformers 2.0.2 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-2.0.2 (EdwardKmett)
14:31:43 <spirit> hiya, really sorry to ask this -- have been using leksah for a while and now i don't seem to remember how to compile my haskell project via ghc command-line style. any clues?
14:31:51 <erus`> you can't name a folder 'con' in windows
14:32:08 <monochrom> ghc --make -O myprogram.hs
14:32:16 <edwardk> not saying that any of those things can happen this year, but so we know the state of the world
14:32:28 <Peaker> spirit: Leksah works well for you?
14:32:48 <bos> edwardk: sure
14:33:13 <Peaker> I tried Leksah multiple times, I don't think much of it actually worked for me.. (e.g: all the buttons seemed to be no-ops, cabal build failed whereas a "cabal build" outside it worked, etc)
14:33:14 <spirit> cool, i was missing the --make! leksah works just fine for me
14:33:52 <kmc> you don't need --make on GHC 7, btw
14:35:35 * hackagebot comonads-fd 2.0.2 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-2.0.2 (EdwardKmett)
14:35:41 <spirit> it took a while to set leksah up properly, but it worked fine then
14:36:56 <dgpratt> Peaker: my experiences with Leksah are similar to yours
14:38:47 <Peaker> spirit: not sure how to "set it up" -- I really wanted a debugger frontend for the ghci debugger and that didn't seem to work at all. Can you use it?
14:40:35 * hackagebot comonad-extras 2.0.2 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-2.0.2 (EdwardKmett)
14:41:10 <cheater> mauke, what was that bot command that did 1st 2nd 3rd but incorrectly
14:41:16 <mauke> 6st
14:41:24 <cheater> @6st
14:41:24 <lambdabot> Maybe you meant: ask ft let list msg
14:41:28 <mjrosenb> kmc: good to know.
14:41:34 <cheater> how do i use it?
14:41:37 <cheater> > 6st 1
14:41:38 <lambdabot>   Not in scope: `st'
14:41:40 <jaspervdj> I'm off to bed. edwardk, bos, looking forward to the meeting somewhere next week(?), I'll do my best to produce a comprehensive report by then.
14:41:42 <cheater> no.
14:41:45 <mauke> preflex: 6st 1 2 3
14:41:46 <preflex>  1st 2rd 3th
14:41:56 <cheater> ah preflex
14:42:02 <cheater> thx mauke
14:42:15 <bos> dolio: ping
14:42:20 <bos> preflex: seen dolio
14:42:21 <preflex>  dolio was last seen on #haskell-blah 15 minutes and 51 seconds ago, saying: Oh wait, ntfs, not zfs.
14:42:35 <dolio> Yo.
14:42:59 <bos> dolio: bytestring-show doesn't build under GHC 7.2.1
14:43:09 <bos> dolio: cabal: cannot configure bytestring-show-0.3.4. It requires integer-gmp ==0.2.*
14:43:09 <bos> There is no available version of integer-gmp that satisfies ==0.2.*
14:43:19 <dolio> Okay. I'll fix it.
14:43:21 <jutaro> Peaker: which version of Leksah did you try?
14:43:25 <bos> dolio: thanks
14:43:55 <Peaker> jutaro: I don't remember, it was about 5-6 months ago I think (newest of then)
14:44:05 <int80_h> I'm calling an outside haskell program and want to capture it's "return value". Example: If one calls a script from another script, the called script will often return an integer that expresses a state (failed, succeeded). What is the common way of doing that in haskell
14:44:21 <bos> dolio: it's not enough to just widen the version constraint
14:44:35 <dolio> No?
14:44:36 <kmc> int80_h, on which side?
14:44:47 <dolio> Did they change some module names or something?
14:44:50 <int80_h> kmc: both, starting with the called script side
14:44:52 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/process-1.0.1.5/System-Process.html
14:44:58 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/System-Exit.html
14:45:05 <int80_h> cool!
14:45:07 <bos> dolio: no, you need FlexibleInstances at the top of Text/Show/ByteString.hs
14:45:10 <Peaker> int80_h: specifically: http://hackage.haskell.org/packages/archive/process/1.0.1.1/doc/html/System-Process.html#v%3AwaitForProcess
14:45:18 <thoughtpolice> int80_h: the return code of the process is just the exit code. the process library has facilities for returning the exit code from a process
14:45:27 <jutaro> We only made moderate progress on leksah in that period.
14:45:28 <thoughtpolice> so yeah, that's about all you need :)
14:45:30 <spirit> i rather liked this tutorial. but i also remember i had to install some libtools (i think that was it)
14:45:32 <bos> dolio: with that added, the package builds and installs cleanly
14:45:35 * hackagebot GenericPretty 1.1.7 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-1.1.7 (RazvanRanca)
14:45:41 <dolio> Okay.
14:46:27 <jonkri> is there some way to make something like an extendable data type in haskell, like something that an unrelated client can extend to add custom values that can be pattern matched by the client?
14:46:51 <mauke> like exceptions?
14:47:45 <jonkri> ah, no... my application using events and hooks ((stateful) callback functions), and i would like to make my library extendable by allowing clients to define own hooks and events
14:48:14 <jonkri> don't know if this works well with haskell's type system or not
14:48:39 <kmc> jonkri, look at Control.Exception
14:48:47 <kmc> xmonad also does something similar
14:48:59 <kmc> the easiest solution is Data.Dynamic
14:49:10 <dgpratt> jutaro: I am running GHC 7.0.3 and Leksah 10.0.4. I've had no luck getting debugging working.
14:49:44 <kmc> but then generic code can't use those values
14:49:47 <jutaro> dgpratt: Whats happening if you switch on debugging mode?
14:51:20 <jonkri> kmc, i don't see how exceptions are relevant, but then i'm new to haskell exceptions
14:51:28 <dgpratt> jutaro: not sure if I'm even doing this right, but when I go to Debug -> Continue, I get a prompt "GHCi debugger is not running"...
14:51:46 <kmc> jonkri, it's just an example of an extensible type system
14:51:47 <edwardk> jonkri: Control.Exception does some nice tricks with Typeable to get an 'open set' of exceptions
14:51:48 <kmc> like what you want
14:51:51 <kmc> go read the code
14:52:08 <edwardk> jonkri: where you can choose to catch some subset thereof, etc.
14:52:20 <jutaro> Then some exception has occured when calling ghci, which is not handled well.
14:52:30 <edwardk> jaffacake gave a really nice overview back at icfp 2006. there should be a paper on it
14:52:35 <dgpratt> I click "Start GHCi" and I see output from GHCi appear in the log window, ending with "Ok, modules loaded: Main"
14:53:05 <dgpratt> thereafter no debug-related action produces any apparent result
14:54:27 <jutaro> dgpratt: no idea. Can you load the project in bare ghci?
14:54:29 <jonkri> Eduard_Munteanu, http://icfp06.cs.uchicago.edu/bird-talk.pdf ?
14:54:38 <jonkri> omg it's upside down :P
14:54:51 <Eduard_Munteanu> Hm, what about that?
14:55:03 <Eduard_Munteanu> Oh, you meant to type edwardk?
14:55:17 <jonkri> right, sorry about that :)
14:55:19 <edwardk> nah that is richard bird's talk on functional pearls. also excellent but not about exceptions
14:55:30 <dgpratt> jutaro: the single file that is in the project can be loaded, yes; is there a way to do it that is closer to what Leksah is doing?
14:55:50 <edwardk> An Extensible Dynamically-Typed Hierarchy of Exceptions
14:56:06 <edwardk> https://docs.google.com/viewer?a=v&q=cache:CjW27kkw5H0J:community.haskell.org/~simonmar/papers/ext-exceptions.pdf+haskell+marlow+exceptions&hl=en&gl=us&pid=bl&srcid=ADGEESi7R4LvBx8poNCxuA8vN77IK-NwCmknQ7imalVe9fhn3IsE-scjLk745DsgleFJLLMqJZtW884i06jZPjPS2WOp-rDwPFawdnI-t1xU9X8ukCtwMJ5mkF-03-PFJD8cC5kS8l9K&sig=AHIEtbRiGgXXKPoMwcBAowkAf5nYqTXh4Q&pli=1 got it for me but icky url
14:56:10 <dgpratt> does GHCi understand .cabal files?
14:56:52 <jutaro> Leksah is doing some magic to call ghci with all cabal args. But I'm not the one who implemented this
14:57:12 <jonkri> thanks:)
14:57:14 <edwardk> https://docs.google.com/viewer?a=v&pid=explorer&chrome=true&srcid=19emwma_up8_A4W6ymDS0_Ukh-DUPrJUijKSQWZ6DjOhbee6gNec6YzwfYLjY&hl=en_US
14:58:42 <jutaro> jonkri: I have just work on extensible stuff for leksah plugins. It is somehow documented here. https://github.com/jutaro/billeksah/wiki. It is an early state. And yes, I use Data.Typeable stuff
14:59:38 <dgpratt> jutaro: it certainly does appear that GHCi (via Leksah) is loading the file without issue
15:00:00 <dgpratt> jutaro: alas, that's as far as it (apparently) goes
15:00:09 <jutaro> dgpratt: you can send your example to me and I (we) will try to find out whats happening
15:00:12 <jonkri> jutaro, nice, thanks :)
15:00:35 * hackagebot bytestring-show 0.3.5 - Efficient conversion of values into readable byte strings.  http://hackage.haskell.org/package/bytestring-show-0.3.5 (DanDoel)
15:00:37 * hackagebot free 2.0.2 - Monads for free  http://hackage.haskell.org/package/free-2.0.2 (EdwardKmett)
15:01:24 <dgpratt> jutaro: actually, this occurs with the default project template
15:01:51 <dgpratt> jutaro: it may matter that this is on Windows 7
15:02:09 <cdsmithus> So with GHC 7.2 SafeHaskell, do I really have to modify every package in the system to explicitly use -XSafe and/or -XTrustworthy before modules can be imported in safe code?
15:02:13 <Peaker> edwardk: why "retract" and not "unlift"?
15:02:25 <jutaro> I myself use Windows 7 without problems. But what do you mean with default project template?
15:02:34 <kmc> cdsmithus, you can use ghc-pkg trust, can't you?
15:02:37 <edwardk> peaker: i could have gone with lower but lower already exists
15:02:50 <kmc> http://hackage.haskell.org/trac/ghc/wiki/SafeHaskell
15:03:10 <cdsmithus> kmc: That marks a package as trusted, but that doesn't do anything unless the package declares trustworthy modules
15:03:16 <kmc> ok
15:03:26 <edwardk> and then i'd have had to have a name for prelifting for the dual ;)
15:03:36 <dgpratt> jutaro: oh, maybe I forgot where this code came from; now that I think on it, maybe it came from a Leksah tutorial
15:03:50 <Peaker> edwardk: unlift is obviously an opposite :)
15:03:59 <dgpratt> jutaro: I'll come up with some repro steps and give you that
15:04:07 <edwardk> unlift . lift works but then you need lower . ???
15:04:17 <cdsmithus> I'd hoped that GHC would try to determine whether modules were safe, and mark them that way without modifying the package if they are... it appears not.
15:04:41 <jutaro> dgpratt: You have to eval some code in debugger mode (Ctrl-Enter) to see the effect
15:04:59 <edwardk> and the obvious 'raise' isn't nice coz it has other connotations ;)
15:05:08 <jutaro> Then you can set breakpoints and continue ...
15:06:04 <edwardk> peaker: unlower in the dual case is wrong because it happens before you lower
15:06:41 <hvr> edwardk: do you plan on adding arrows for your Data.Lens abstraction?
15:06:43 <dgpratt> jutaro: other than starting GHCi the first time I do it, Ctrl+Enter has no apparent effect
15:06:54 <edwardk> hvr: the (:->) arrows?
15:07:20 <jutaro> dgpratt: strange. Maybe some unknown config problem
15:07:28 <edwardk> i'd previously objected to them due to them requiring TypeOperators, so the operator was just 'Lens a b'
15:07:31 <hvr> edwardk: errrr.... I was thinking more about Control.Arrow arrows :)
15:07:44 <hvr> edwardk: but TypeOperators would be nice too :)
15:07:46 <edwardk> they aren't Arrows though
15:08:02 <edwardk> try and implement 'arr' correctly
15:08:10 <cdsmithus> Lenses aren't arrows, but the new fclabels lets you define lenses FOR arrows
15:08:16 <hvr> ic
15:08:34 <cdsmithus> Personally, I rather think it's gratuitous abstraction, but I've never liked arrows
15:08:41 <edwardk> i have a new version of data-lens that actually gives in on the type operator front
15:08:46 <edwardk> breaking haskell 98
15:08:52 <jonkri> what do you think is the number of spaces to convert a tab to? i've seen both 2 and 4
15:08:56 <edwardk> but it does so so i can make the class of lens types into "Lens" ;)
15:09:01 <kmc> jonkri, Haskell report says 8
15:09:04 <edwardk> that way you can implement lenses different ways
15:09:05 <kmc> but don't use tabs at all
15:09:08 <Peaker> cdsmithus: I wonder if conal's DeepArrow class is a useful replacement for arrows
15:09:12 <edwardk> and I have unboxed and continuation passing style versions
15:09:13 <dgpratt> jutaro: perhaps; probably benign, but some of the messages in the console window seem to reference prior versions of GHC
15:09:33 <edwardk> and i can then export a data-lens-fclabels data-lens-accessor, which makes their lenses instances
15:09:42 <edwardk> so all the combinators can work across all the damn libraries and we can go from there
15:09:53 <hvr> edwardk: what I still don't get... when would I use fclables and when would I use data-lens? :)
15:09:55 <edwardk> then they can compete on performance, etc.
15:09:55 <dgpratt> such as: set leksah_libdir=C:\Program F
15:09:55 <dgpratt> iles (x86)\Leksah\leksah\ghc-6.12.1
15:10:10 <edwardk> hvr_ data-lens has a performance benefit
15:10:16 <edwardk> hvr: fclabels came first
15:10:28 <dgpratt> oops; accidental line-break, but you get the idea
15:10:30 <edwardk> and you can't use fclabels in haskell 98 or haskell 2010
15:10:41 <edwardk> you hitch yourself to ghc with it
15:10:49 <edwardk> because the template haskell is in the main library
15:11:07 <jutaro> dgpratt: yes ok. That will cause a problem. The leksah installation and the compiler version shall match
15:11:13 <edwardk> my problem with fclabels is that it is more expensive when you want to use deeply nested lenses
15:11:14 <jonkri> thanks, i wont
15:11:24 <edwardk> because they don't fuse together the getter and setter
15:11:38 <cdsmithus> *sigh*... so I take it the answer is yes, you have to patch every library in the universe to import them into safe code?
15:11:48 <hvr> edwardk: btw, the documentation seems wrong @ http://hackage.haskell.org/packages/archive/data-lens-template/2.1.1/doc/html/Data-Lens-Template.html
15:11:56 <hvr> it says
15:11:57 <hvr>  $( makeLenses ''TypeName )
15:11:58 <jutaro> dgpratt: You should install:  leksah-0.10.0.4-ghc-7.0.3.exe
15:12:03 <hvr> whereas it should say
15:12:07 <hvr>  $( makeLenses [''TypeName] )
15:12:08 <fengshaun> what is -XUndecidableInstances good for?
15:12:14 <edwardk> probably is, i recently received a patch to it that changed behavior
15:12:25 <dolio> Absolutely nothing.
15:12:27 <Peaker> fengshaun: type-level computation using convoluted type-classes :-)
15:12:29 <edwardk> thanks. i've added it to my todo list
15:12:47 <jutaro> dgpratt: leaving now for bed.
15:12:55 <cdsmithus> fengshaun: it's good for adding whem GHC says you need it for your types.  But when you do, you should have a proof that type checking really terminates.
15:13:02 <dgpratt> jutaro: ok, thanks
15:13:09 <Peaker> partiality-in-compile-time is really not as big a deal as partiality-in-runtime.. I've not encountered cases that I actually needed it though
15:13:17 <fengshaun> Peaker: I have a class that has both Bool and (Num a) instances: instance (Num a) => MyClass a where...
15:13:25 <hvr> edwardk: and what's the data-lens-fd package for?
15:13:38 <hvr> i.e. why would I want to use that?
15:13:46 <fengshaun> and I get "constraint no smaller than the instance head" error.
15:13:51 <fengshaun> what does it mean?
15:13:57 <edwardk> it provides the lens operations in a more general way, they work on any MonadState instead of just transformers Lazy and Strict .StateT s m,
15:14:06 <hvr> ic
15:14:20 <edwardk> it is a separate package because to do so requires MPTCs
15:14:32 <bos> dolio: thanks for the quick turnaround!
15:14:34 <Peaker> fengshaun: I think it means GHC cannot prove that type-checking would terminate (or accept a correct program)
15:14:41 <dolio> No problem.
15:14:53 <fengshaun> Peaker: oh, how can I fix it?
15:15:04 <Peaker> fengshaun: can you paste the code?
15:15:14 <fengshaun> Peaker: sure, hold on
15:15:16 <hvr> edwardk: ok, well, you've convinced me that I should prefer data-lens over fclabels :-)
15:15:29 <cdsmithus> fengshaun: Haskell has some rules intended to guarantee that the type checker won't run forever.  They are fairly arbitrary, and you've run afoul of them.  If it's possible, try to refactor your types, e.g. by adding in some newtypes.  If not, then you have to convince yourself that type checking terminates, and then add UndecidableInstances to tell the compiler to trust you.
15:15:29 <edwardk> i'm glad. =)
15:15:46 * hackagebot keys 2.1.1 - Keyed functors and containers  http://hackage.haskell.org/package/keys-2.1.1 (EdwardKmett)
15:16:00 <edwardk> the new api cleans things up a bit and lets you use whatever lens implementation you want, but the combinators sstill look the same, you just get more with nice names
15:16:05 <fengshaun> Peaker: http://paste.pocoo.org/show/458987
15:16:09 <kmc> you don't really have to convince yourself that type checking terminates
15:16:18 <hvr> bos: as you are the benchmarking go-to guy... do you happen to have compared GHC 7.0 to 7.2 in terms of performance? :-)
15:16:19 <edwardk> i'll probably upload it this week some time
15:16:20 <bos> someone who knows those packages well would do us all a favour by writing them up, and why they prefer one over another
15:16:21 <bos> . hint, hint, edwardk :-)
15:16:27 <kmc> you just try it :)
15:16:28 <fengshaun> cdsmithus: I'm just getting started with Haskell, so I don't know what it mean that type-checking doesn't terminate!
15:16:31 <bos> hvr: not yet
15:16:37 <edwardk> i'm waiting to get some benchmark data out of the snap guys
15:16:41 <edwardk> bos: which packages?
15:16:46 <edwardk> bos: the lenses?
15:16:47 <cdsmithus> fengshaun: for example, you could wrap your type in a newtype, and write: class Num a => MyClass (Wrapper a)
15:16:52 <bos> edwardk: the various lens-like ones
15:17:04 <fengshaun> cdsmithus: how does that help?
15:17:06 <edwardk> bos: you mean something like http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation/5769285#5769285 ?
15:17:21 <bos> edwardk: ah, yes
15:17:38 <atsampson> fengshaun: "your program takes longer to compile, but on the upside it completely prevents the possibility of run-time errors"
15:17:43 * edwardk dusts off his hands and sits back smugly ;)
15:17:44 <cdsmithus> fengshaun: it makes the instance head smaller.  That's one of the conditions GHC relies on to prove type checker termination
15:18:04 <fengshaun> cdsmithus: what do you mean by "instance head"?
15:18:07 <fengshaun> atsampson: thanks!
15:18:35 <cdsmithus> The part on the right of the =>
15:18:51 <fengshaun> that would be MyClass?
15:18:57 <fengshaun> or MyClass a?
15:19:01 <cdsmithus> MyClass a
15:19:06 <atsampson> fengshaun: more seriously, it's possible to write type constraints that'll get the Haskell compiler stuck in a loop (in theory; in practice it gives up -- see http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/type-class-extensions.html#undecidable-instances for some examples)
15:19:29 <bos> edwardk: do we have to use some funky version of the "." operator with data-lens?
15:19:41 <fengshaun> atsampson: interesting, I'll definitely have a look at that.  Thanks!
15:19:52 <edwardk> there is a getL, setL, etc.
15:20:02 <bos> edwardk: as i recall, one of the category packages wants to steal "." to mean something more exciting than function composition
15:20:02 <edwardk> but there are also ^$ ^. , etc.
15:20:14 <fengshaun> cdsmithus: so, GHC complains that "MyClass a" is *smaller* than "Num a"??
15:20:15 <edwardk> i use Control.Category fairly heavily
15:20:21 <fengshaun> I'm way too lost on this!
15:20:21 <edwardk> the lenses form a Category
15:20:24 <edwardk> so you can compose with those
15:20:45 <cdsmithus> fengshaun: another way to look at it... what if someone wrote: instance MyClass a => Num a ... then the type checker would have problems because of the loop.  By requiring the head to be more specific, you avoid that
15:21:16 <edwardk> so you can nest lenses with fstLens . sndLens . thdLens     and apply them with ^$ to something and it works just like . and $
15:21:47 <fengshaun> cdsmithus: oh, so the head should be more specific (aka smaller) than the type constraint!
15:21:53 <cdsmithus> Right
15:22:05 <bos> edwardk: i see
15:22:27 <fengshaun> cdsmithus: so, how would I be able to fix this code?
15:22:39 <fengshaun> http://paste.pocoo.org/show/458987
15:22:49 <bos> wow, the category-extras docs are all screwed up on hackage
15:22:59 <edwardk> category-extras is long dead =)
15:23:03 <cdsmithus> You can wrap the type, and write an instance for the wrapped type... then you need to do the wrapping and unwrapping, though
15:23:06 <edwardk> it has been factored into about 25 libraries these days
15:23:15 <bos> edwardk: it is? it has?
15:23:22 <fengshaun> cdsmithus: any other ways to get around that?
15:23:32 <bos> jeesh, i wish we had a way to mark packages as dead or superseded by others
15:23:33 <edwardk> yeah, they start at 'semigroups' and grow through 'kan-extensions'
15:23:35 <edwardk> more or less
15:23:39 <edwardk> we do
15:23:50 <edwardk> i think i pushed an update so it could at least build after it was deprecated though
15:23:53 <edwardk> so it lost the flag
15:23:59 <cdsmithus> Umm, you can add {-# LANGUAGE UndecidableInstances #-} to the top of your file...
15:24:26 <edwardk> the mechanism is to email ross and he can mark the package in hackage as deprecated which removes it from the list of packages
15:24:28 <fengshaun> cdsmithus: Are those all of the possible solutions?
15:24:59 <cdsmithus> No, I'm rather sure there are more possible solutions, but those are the straightforward ones I see
15:25:17 <fengshaun> cdsmithus: Quite helpful, thanks a lot!
15:25:46 * hackagebot data-lens-template 2.1.1.1 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-2.1.1.1 (EdwardKmett)
15:25:52 <cdsmithus> fengshaun: Note that wrapping a in a newtype wrapper won't have any runtime effect, if you're worried about that.  All it does is keep the type checker happy
15:27:05 <fengshaun> cdsmithus: I'm not worried about performance at all, I'm just playing around with things I just learned about.
15:30:46 * hackagebot bifunctors 0.1.2 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-0.1.2 (EdwardKmett)
15:35:48 * hackagebot either 0.2.3 - Haskell 98 either monad transformer  http://hackage.haskell.org/package/either-0.2.3 (EdwardKmett)
15:35:50 * hackagebot void 0.5.5 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.5 (EdwardKmett)
15:37:06 <cdsmithus> Yay!  I've got my wewb-based haskell development env running code using SafeHaskell.  I'm still disappointed that I have to patch any libraries that are used.
15:40:47 * hackagebot reflection 0.4.1.1 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.4.1.1 (EdwardKmett)
15:40:49 * hackagebot representable-functors 2.0.2 - Representable functors  http://hackage.haskell.org/package/representable-functors-2.0.2 (EdwardKmett)
15:41:19 <Peaker> I remember glancing over the Implicit Configurations thing -- is there a tl;dr what's it for? :)
15:41:42 <Peaker> I think I remember it wasn't very clear from a cursory glance at the paper
15:41:48 <edwardk> yes. you turn a term into a type so you can do things like have a Num instance for say numbers modulo some particular runtime constant
15:42:39 <mauke> Peaker: you teleport values through the type system
15:42:47 <edwardk> since it is a type you know you are getting the same constant for every value in your monoid
15:43:03 <mauke> since the type checker propagates information into all parts of the programs anyway
15:43:04 <edwardk> i use it for instance to make a monoid out of tabulating some PARTICULAR dfa, etc.
15:43:05 <ivanm> edwardk: I thought functional pearls were articles, not packages
15:43:05 <ivanm> ;)
15:43:21 <edwardk> ivanm: you know me, everything gets a package ;)
15:43:32 <ivanm> heh
15:43:33 <alpounet> oh, the edwardk massive-package-updates dance again
15:43:37 <edwardk> sorry
15:43:39 <alpounet> :p
15:43:48 <Gracenotes> hm. what's the nicest way of mapping [0, \inf) to [0, x], such that 2n*x is 0, and (2n+1)*x is x, and everything inbetween is linearly interpolated?
15:43:48 <ivanm> edwardk: wait, you have a package just to specify your contact details as well? :p\
15:43:53 <ivanm> a package for your shopping list?
15:43:54 <ivanm> :p
15:43:58 <edwardk> i updated semigroups to make it so that the world doesn't need to care about when the monoids (<>) patch goes in
15:44:03 <edwardk> being pre-emptive
15:44:05 <Gracenotes> >_>
15:44:17 <edwardk> ivanm: now you know the secret to my dominance of hackage
15:44:19 <ivanm> heh
15:44:29 <ivanm> yeah, I noticed your email on that
15:44:36 <ivanm> but, are they documented yet? :p
15:44:36 <Gracenotes> best I can do is (x - ((n `mod` 2*x) - x))
15:44:41 <Gracenotes> but... seems messy. anywho.
15:44:44 <edwardk> better than they were
15:45:00 <mustelo> Gracenotes, check out the fmod function
15:45:02 <Gracenotes> er, (x - abs ((n `mod` 2*x) - x))
15:45:11 <edwardk> and replicate1p is times1p for repeating a n + 1 times using log n applciations of (<>)
15:45:19 <Gracenotes> mustelo: oh, and I only need it to work for integers >_> I should mention
15:45:28 <mustelo> ah
15:45:36 <mustelo> don't check out the fmod function then ;)
15:45:47 * hackagebot adjunctions 2.0.3 - Adjunctions  http://hackage.haskell.org/package/adjunctions-2.0.3 (EdwardKmett)
15:45:48 <Gracenotes> a sage piece of advice!
15:46:11 <mauke> preflex: calc pi % sqrt 2
15:46:11 <preflex>  0.313165528843603
15:46:22 <mauke> preflex: botsnack
15:46:22 <preflex>  :-)
15:47:59 <edwardk> i really wanted to get something else done with today, but i figured it was good to just get this out of the way
15:48:24 <benmachine> Gracenotes: abs on a sawtooth?
15:49:32 <Gracenotes> benmachine: that is pretty much it :)
15:49:37 <benmachine> mm
15:49:47 <benmachine> I suppose so yeah
15:50:29 <Peaker> mauke, edwardk: Ah, thanks
15:51:56 <Gracenotes> and its amplitude is half its.. uh.. wavelength
15:55:47 * hackagebot representable-tries 2.0.3 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-2.0.3 (EdwardKmett)
15:55:49 * hackagebot kan-extensions 2.0.2 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-2.0.2 (EdwardKmett)
16:00:48 * hackagebot pointed 2.0.2 - Haskell 98 Pointed and copointed data  http://hackage.haskell.org/package/pointed-2.0.2 (EdwardKmett)
16:00:50 * hackagebot reducers 0.1.5 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-0.1.5 (EdwardKmett)
16:01:45 <roconnor> edwardk: what are representable tries?
16:01:57 <edwardk> polynomial representable functors
16:02:07 <edwardk> useful for memoizing functions
16:02:10 <roconnor> where are the tires?
16:02:22 <edwardk> they are used as a 'memo trie' for the function =)
16:02:47 * roconnor needs to learn Kan Extensions
16:02:58 <NihilistDandy> Hooray, I'm not homeless!
16:03:02 <edwardk> when you look at the polynomial strucutre you take + and turn it into the * for the memoization and * into composition
16:03:12 <NihilistDandy> pumpkin: cocopumpkin?
16:03:23 <edwardk> its the notion of log from naperian functors just put to a slightly different use
16:03:31 <Peaker> since memos are mutable only by-extension, and not mutation of existing values, it sounds like they're a good candidate for unsafePerformIO'd hash tables (like the ugly-memo package)
16:03:49 <roconnor> mm
16:03:57 <roconnor> We should get GHC support
16:03:57 <edwardk> i have a library for that, intern, though its getting replaced with a more principled one
16:04:14 <roconnor> put it right into the runtime and garbage collector somehow
16:04:18 <edwardk> it is
16:04:23 <Peaker> you don't really need the persistence with memos, so why pay the price of a trie and not use an ephemeral structure that's faster?
16:04:34 <edwardk> http://community.haskell.org/~simonmar/papers/weak.pdf
16:04:51 <Peaker> roconnor: you talking about memos?
16:04:56 <edwardk> because in my case the memo-structure gets used for a lot of things that aren't traditional 'memo functions'
16:05:09 <roconnor> edwardk, Peaker, aren't the memo tries entirely built at once and simply lazily unthunked?
16:05:17 <edwardk> i use them all the way down to talking about complex numbers as isomorphic to a function from data C = E | I ;)
16:05:27 <edwardk> roconnor: they are
16:05:37 <Peaker> roconnor: is that a counter point?
16:05:43 <edwardk> peaker: that ephemeral structure is pretty expensive
16:05:50 <edwardk> i have to grab some kind of mvar to update it
16:05:51 <roconnor> Peaker: why would an ephemeral structure be faster?
16:06:06 <edwardk> that is HUGE in terms of operational costs
16:07:03 <roconnor> Maybe with a hashtable the lookups would be proportional to the number of entries accessed rather than the size of the key
16:07:34 <Peaker> roconnor: well, it may require O(1) average access time in practice (or a very small constant O(logN) if you're pedantic) as opposed to O(logN) of a lazy trie
16:07:53 <edwardk> roconnor: intern uses Data.HashMaps stored in an array of mvars
16:08:01 <Peaker> edwardk: what about an IORef with atomicallyModify?
16:08:04 <edwardk> the array reduces the pressure on the mvar chokepoint
16:08:18 <edwardk> doesn't work. you need to dereference a weak pointer while modifying
16:08:23 <edwardk> or you can spin indefinitely
16:08:28 <edwardk> so you need an ioref
16:08:30 <edwardk> er mvar
16:08:39 <edwardk> so you can perform an IO action while deconstructing it
16:09:00 <Peaker> edwardk: hmm.. so that the structure doesn't keep all the memo'd inputs/results alive?  a lazy trie keeps all the results alive (and in some cases, the keys)
16:09:01 <roconnor> edwardk: what if you added your own primitive to GHC?
16:09:03 <edwardk> otherwise you risk livelock
16:09:31 <Peaker> edwardk: what if you just "leak" all of the memo? I'm sure there are many cases that don't care if the memo makes these values live forever
16:09:36 <edwardk> correct. this is why the new intern library is based on building a sort of 'contravariant ST" monad for updating the cache
16:09:38 <edwardk> but never deletes
16:09:44 <edwardk> that way it doesn't break any invariants
16:10:07 <edwardk> you allocate a cache like the implicit configuration pearl, using a quantified variable
16:10:16 <edwardk> then it leaks for the life to the computation
16:10:25 <edwardk> er the life of
16:10:34 <edwardk> but once you exit the scope you throw away the interning region
16:10:40 <edwardk> so you can control the lifespan
16:10:49 <edwardk> and the quantifier ensures correctness
16:12:47 <roconnor> edwardk: wait, what are you describing?
16:12:57 <edwardk> something like: reifyCache :: (forall r. Cache t r => Proxy r -> w) -> w; intern :: (Cache t r, Eq t, Hashable t) => Proxy r -> t -> Interned t
16:13:24 <edwardk> the Cache lives for the life of the the quantifier on r, like runST
16:13:46 <edwardk> and you can compare Interned 't's in O(1)
16:14:28 <edwardk> but once you escape that quantifier the dictionary for Cache which is the only thing that holds the memo-table, goes away
16:14:34 <edwardk> and it gets garbage collected
16:14:59 <edwardk> so you get a region discipline to your use of the memo-structures
16:15:06 <roconnor> ah
16:15:45 <edwardk> ideally it'd be a linear discipline so you can pingpong contents into a new buffer then let the old one die, but we can't have everything
16:16:23 * roconnor wants everything
16:16:40 * monochrom wants everything that doesn't want itself
16:17:44 <HNSZ> wants everything that wants everything that doesnt want itself :)
16:18:07 <edwardk> =)
16:19:16 <monochrom> there is also this: I want everything wanted by everyone who wants everything I want. (it is a tautology)
16:20:03 <HugoDaniel> i want openleaks
16:20:48 * hackagebot streams 0.8.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.8.1 (EdwardKmett)
16:30:47 * hackagebot wl-pprint-extras 1.5 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-1.5 (EdwardKmett)
16:30:49 * hackagebot wl-pprint-terminfo 0.6 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.6 (EdwardKmett)
16:30:51 * hackagebot compressed 0.1.3 - Compressed generators and reducers  http://hackage.haskell.org/package/compressed-0.1.3 (EdwardKmett)
16:37:01 <mustelo> what's the best way to track down packages responsible for repeatedly breaking my quickcheck install?
16:37:16 <mustelo> (due to ghc-pkg dependency issues)
16:39:18 <zekna> https://gist.github.com/962807
16:39:54 <zekna> oops wrong channel xD
16:45:49 * hackagebot trifecta 0.32 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.32 (EdwardKmett)
16:46:16 <hpaste> jake pasted “Pins.hs” at http://hpaste.org/50344
16:47:07 <edwardk> whew. package storm over
16:47:19 <edwardk> well, one last one that is already uploaded
16:49:47 <kmc> :t foldr (>=>) return  -- jake
16:49:47 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
16:50:49 * hackagebot trifecta 0.32.1 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.32.1 (EdwardKmett)
16:52:16 <shachaf> Hmm, this is kind of odd.
16:52:36 <shachaf> "Test.QuickCheck" was suddenly gone on my system, for some reason, but cabal said quickcheck was installed.
16:52:46 <shachaf> I had to cabal install --reinstall it to be able to import Test.QuickCheck again.
16:53:06 <shachaf> Also, I can't import the module "System", which I used to be able to do; does it still exist?
16:53:18 <ivanm> shachaf: was it broken for some reason? (i.e. ghc-pkg check) ?
16:53:40 <shachaf> Oh, hmm, apparently I have lots of broken packages.
16:54:01 <cmccann> shachaf, yes, that would explain why quickcheck checked out
16:54:39 <shachaf> Is there a simple way to fix this sort of thing?
16:54:40 * cmccann has just wiped everything out and reinstalled from scratch a couple times 
16:54:52 <ivanm> so, if ghc now complains about lambdas not being exhaustive, how do you use handle, etc. where you only care about one constructor of the Exception?
16:54:53 <shachaf> That's a lot of from-scratch-reinstallation. :-(
16:54:55 <cmccann> depending on why your packages are broken there might be an easier way though
16:55:08 <ivanm> shachaf: rebuild all the broken packages?
16:55:24 * ivanm can't recall if there's any easier way than doing this, but recalls hearing something about it
16:57:16 <cmccann> shachaf, what sort of packages are broken? random minor stuff, a group of related packages, fundamental packages that lots of things use... ?
16:57:25 * shachaf notes that ~/.cabal is >800MB.
16:57:31 <shachaf> Maybe I'll be best off just reinstalling.
16:57:38 <shachaf> In fact, maybe I can use this as an excuse to get GHC 7.2.
16:57:47 <cmccann> yes, GHC 7.2 is nice
16:57:58 <shachaf> Is there any reason not to get it right now?
16:58:02 <cmccann> especially if you enjoy type hackery like I do
16:58:12 <Eduard_Munteanu> Did it get type-level nats?
16:58:20 <parcs> package incompatibilities
16:58:32 <cmccann> Eduard_Munteanu, don't think so, but it has class context equality constraints now
16:58:40 <shachaf> parcs: Hmm, anything significant?
16:59:22 <parcs> dunno. i don't use it but others have complained
16:59:42 <monochrom> every package you download is stored in .cabal forever
17:00:10 * cmccann doesn't mind sticking tiny quick fixes into packages anyway
17:00:45 <monochrom> ls -R ~/.cabal/packages for great fun
17:00:51 * shachaf reconsidersshachaf@argon:~$ ls .cabal/packages/hackage.haskell.org/ | wc -l
17:00:54 <shachaf> 210
17:00:56 <shachaf> Er.
17:01:06 <shachaf> Anyway, that's a lot of packages.
17:01:26 <cmccann> that's almost as many as edwardk uploads in a week
17:01:28 <accel> quit
17:01:29 <accel> exit
17:01:39 <monochrom> hahaha
17:01:40 <shachaf> kill -9 $$
17:01:54 * shachaf regularly uses kill -9 $$ to exit shells.
17:02:08 * monochrom uses ctrl-d
17:02:17 <shachaf> monochrom: But that saves command line history!
17:02:18 * parcs clicks X
17:02:25 <Dashkal> Handy way to avoid ending up wiht your password in ~/.bash_history when you oops...
17:02:53 * cmccann tends to just leave a steadily-accumulating number of terminal windows open until he has to reboot and lets the shutdown process close everything
17:02:56 <cmccann> it's not a very good system
17:02:58 <Dashkal> Though on my personal machine I just symlink ~/.bash_history -> /dev/null
17:03:03 <shachaf> Dashkal++
17:03:12 <shachaf> I do that with a lot of history files.
17:03:15 <shachaf> Not .bash_history, though.
17:03:33 <monochrom> I want command history, and I don't mistakenly have passwords there
17:03:37 <Dashkal> I don't do it to root's, but that's where I'm most likely to oops my password.  Sudo
17:04:06 <monochrom> IOW I am not the "press enter and then proofread" kind
17:04:20 <shachaf> monochrom: Passwords have nothing to do with it.
17:04:29 <Dashkal> I'm the press enter and never proofread... >.>
17:04:37 * shachaf also does almost all web browsing in Chrom{e,ium}'s "incognito mode".
17:04:39 <shachaf> I just dislike history.
17:05:03 <parcs> is ^D the only way to exit a shell via keyboard?
17:05:09 <parcs> well
17:05:18 <shachaf> There's exit.
17:05:18 <parcs> you know what i mean ;)
17:05:25 <shachaf> And kill -9 $$
17:05:36 <shachaf> And whatever your terminal/WM's bindings are.
17:05:42 <parcs> key combination or control character
17:05:49 * hackagebot chell 0.1.1 - Quiet test runner  http://hackage.haskell.org/package/chell-0.1.1 (JohnMillikin)
17:05:58 <monochrom> ~/.cabal/world and ~/.cabal/logs have histories too, while we're at it. ~/.cabal/packages is also a kind of history. have fun
17:06:27 * shachaf is aware.
17:06:37 <Eduard_Munteanu> Alt+SysRq+k might also do :P
17:06:43 <monochrom> you should at least link .cabal/world to /dev/null
17:06:57 <parcs> sometimes i accidentally press a space or something and mash ^D frantically and wonder why it doesn't exit
17:07:21 <monochrom> "logout" also exits some shells
17:07:38 <monochrom> there is also the power plug... :)
17:07:42 <Dashkal> The only real way to exit is to detonate the mobo
17:07:53 <parcs> 'exec foo', where foo is a nonexistant command does too
17:08:01 <parcs> or just exec ""
17:08:03 <monochrom> oh, that's fun :)
17:08:08 <shachaf> Or `true`.
17:08:17 * shachaf wonders whether you can exec a shell builtin.
17:08:25 <monochrom> no, can't
17:08:25 <shachaf> Hmph. No.
17:08:36 <shachaf> `exec true` runs a different command from `true`.
17:08:42 <Dashkal> Or :(){ :|:& };: (For the uninitiated, don't even think of typing this into a bash shell.  google fork bomb)
17:08:52 <HugoDaniel> :)
17:08:54 <parcs> shachaf: probably the one from coreutils
17:09:17 * shachaf opts to delete ~/.cabal and ~/.ghc and start over.
17:10:06 <parcs> i once had a 3gb big ~/.cabal, and nothing was broken
17:10:15 <parcs> then i woke up
17:10:20 <cmccann> haha
17:11:02 * shachaf needs to reorganize his ~.
17:11:13 <shachaf> shachaf@argon:~$ ls | egrep '^..?$' | wc -l
17:11:14 <shachaf> 27
17:11:18 <Eduard_Munteanu> Dashkal: nice
17:12:16 <Dashkal> Eduard_Munteanu: I love that thing.  It even looks like a way too long emoticon.
17:12:18 * Eduard_Munteanu too
17:12:29 <Eduard_Munteanu> I have lots of files in ~/ :(
17:12:46 <parcs> shachaf: your ls shows dot files?
17:12:52 <shachaf> parcs: Nope.
17:13:03 <hpc> egrep adds them?
17:13:05 <shachaf> shachaf@argon:~$ echo $(ls | egrep '^..?$')
17:13:05 <shachaf> a B c D df FF g hp io is k m M MC o O R Ro rt t u U v W x xf Z
17:13:44 * shachaf is in the process of taking the UNIX "short directory name" philosophy to its logical conclusion.
17:14:10 <parcs> oh, right
17:14:20 <parcs> yeah that's extreme
17:14:23 <hpc> shachaf: may your headaches be perpetual and karmically agonizing
17:14:41 * Eduard_Munteanu wonders if there's anything like an automated file reorganizer
17:14:53 * shachaf used to put everything in one directory.
17:14:56 <parcs> mv * tmp
17:15:03 <shachaf> It was called Downloads/, but don't be misled by its name.
17:15:44 <hpc> i put everything in one of /host/home/dropbox, /var/www, ~
17:21:36 <econg> does anyone know if ghc creates thunks for strict arguments?
17:22:15 <hpc> econg: a strict argument triggers evaluation of an existing thunk
17:22:34 <hpc> the question you should be asking, i think, is does it create thunks for strict data structures
17:22:38 <hpc> which i don't know
17:23:59 <econg> hpc: so it seems like you are saying that there is always a thunk, even for a strict argument
17:24:15 <econg> what i was wondering is,
17:24:16 <hpc> econg: the thunk isn't of the argument, it is of the value
17:24:25 <econg> is there a case where thunks arent created
17:24:41 <econg> hpc: i see
17:24:42 <hpc> say, let x = Just 5 in strictFromJust x
17:24:49 <hpc> x is a thunk
17:24:54 <hpc> then it is evaluated
17:25:03 <hpc> well, evaluated when strictFromJust x is evaluated
17:25:20 <econg> hpc: cool thanks
17:25:23 <hpc> let x = StrictConstructorOfDunnoWhatType 5 in ...
17:25:27 <hpc> ^ hell if i know
17:25:46 <econg> hpc: what about for functions like +
17:27:03 <dainanaki> does anyone have any advice for  how to optimize enumerators?
17:49:45 <sshc> "readsPrec": "the operator precedence of the enclosing context (a number from 0 to 11). Function application has precedence 10." ....inclusive on both ends?
17:50:49 * hackagebot anansi 0.3.2 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.3.2 (JohnMillikin)
17:55:49 * hackagebot anansi 0.3.2.1 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.3.2.1 (JohnMillikin)
17:59:21 <coppro>  /win 2
18:03:34 <ivanm> anansi looks rather interesting actually
18:05:49 * hackagebot vector-instances 2.0.2 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-2.0.2 (EdwardKmett)
18:07:08 <ivanm> edwardk: instances of your stuff I'm presuming?
18:08:10 <edwardk> that and crap like Monad, Traversable, etc.
18:08:27 <edwardk> Data.Vector has a shocking paucity of instances
18:08:44 <edwardk> but yes, since i needed them i also put my instances in there ;)
18:09:06 <ivanm> I wonder why they didn't bother with Monad, etc.
18:09:11 <ivanm> maybe push them upstream?
18:09:17 <edwardk> nah
18:09:27 <edwardk> er
18:09:29 <edwardk> well i tried
18:09:57 <ivanm> and?
18:10:27 <edwardk> "
18:10:27 <edwardk> As you correctly point out, some of the instances won't be very efficient and it seems a bit wrong to implement them and then discourage users from using them. I'm just not sure why, say, a Monad instance would be useful. Also, most of these can't be defined for unboxed vectors so there is the question of uniformity."
18:10:50 <edwardk> at which point i gave up
18:12:50 <ivanm> but you want/need Monad instances for something?
18:12:54 <edwardk> yes
18:12:56 <ivanm> (your graph package?)
18:13:00 <edwardk> lots of things
18:13:15 <edwardk> i would actually use data vector fairly extensively if it actually bothered to come up to snuff with the rest of the world
18:13:41 <edwardk> for example it'd let people pass vectors around in my ad package
18:14:00 <edwardk> as it is you can use any kind of vector except an actual Vector
18:14:03 <cmccann> what kind of "not very efficient" are we talking about in this case, anyway
18:14:12 <edwardk> we're talking a dictionary =P
18:14:21 * ivanm wildly guesses that it goes via lists
18:14:32 <edwardk> traversable is probably the hardest to stomach
18:14:36 <edwardk> no
18:14:40 <edwardk> traversable does
18:14:43 <edwardk> but nothing else has to
18:15:18 <edwardk> traversable is forced to do some annoying things because the notion of streams used by data vector is tied intrinsically to monads
18:15:42 <edwardk> oh, and the applicative
18:16:01 <edwardk> https://github.com/ekmett/vector-instances/blob/master/Data/Vector/Instances.hs
18:16:03 <cmccann> I can sort of see not bothering with, say, the diagonalizing monad instances for some data structures
18:16:19 <cmccann> unless there's a more efficient way to do those
18:16:32 <edwardk> vector isn't fixed length vectors
18:16:35 <edwardk> its the list monad
18:16:44 <cmccann> yeah
18:16:55 <cmccann> I was just wondering if this was something similarly horrible for some reason
18:17:09 <edwardk> nah
18:17:15 <edwardk> the applicative is actually rather nice
18:17:16 <edwardk> =)
18:17:41 * cmccann wonders what sort of type hackery to implement next
18:17:46 <danharaj> is that the zip applicative?
18:17:50 <edwardk> no
18:17:53 <edwardk> it is compatible with the monad
18:17:56 <danharaj> ah
18:18:08 <edwardk> it does however count the elements in each side, and premultiply to get the new vector length
18:18:31 <cmccann> the applicative instance of the standard list monad is just the unfiltered cartesian product, right?
18:18:43 <edwardk> yep
18:20:47 <cmccann> edwardk, any thoughts on what sort of type hackery might actually be useful? I know you're at least somewhat interested in that stuff
18:20:49 * hackagebot taffybar 0.1.1 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-0.1.1 (TristanRavitch)
18:21:56 <edwardk> well, all my needs are icky operational things right now. i need to rewrite intern, but that is more creative abuse of a contravariant runST-like hack
18:22:07 <edwardk> and not truly type hackery
18:22:56 <marv> is the problem described at http://flyingfrogblog.blogspot.com/2009/04/more-on-haskells-hash-table-problems.html still present in haskell?
18:23:18 <edwardk> no
18:24:07 <edwardk> and it wasn't nearly the problem that harrop made it out to be at the time either
18:24:25 <marv> oh, well good. i only ask because i googled for haskell and hashtables and that was the 3rd hit
18:24:29 <edwardk> but he needs to sell his services and likes to hate on haskell
18:24:35 <aavogt> are there array libraries that check bounds at compile time?
18:24:35 <cmccann> hashtables are overrated anyway
18:24:48 <edwardk> aavogt: Data.Array does
18:24:53 <edwardk> er
18:24:55 <edwardk> wait compile time
18:24:56 <edwardk> sorry
18:24:59 <cmccann> aavogt, I think oleg has an example of that
18:25:00 <edwardk> vector-static
18:25:15 <danharaj> http://hackage.haskell.org/package/unordered-containers
18:25:28 <aavogt> there's vec, but I'm looking at something whose storage is unboxed arrays (for FFI-purposes)
18:25:29 <edwardk> go far enough back and fred eaton had one, but he dropped off the scene 3-4 years back
18:25:30 <danharaj> I think this is the hottest hash map implementation right now?
18:25:42 <cmccann> edwardk, anyway I was more thinking in general than any immediate needs, since I'm finally getting all my type hackery nonsense organized and uploaded
18:26:02 <cmccann> might as well at least try to get something useful in there as well
18:26:08 <edwardk> danharaj: though it is just that a hash map, not a hash table in the traditional sense ;)
18:26:13 <hpaste> ClaudiusMaximus pasted “ghc build failure” at http://hpaste.org/50345
18:26:29 <ClaudiusMaximus> line 20 looks very odd...
18:27:00 <aavogt> hmm, copumpkin abandonded vector-static
18:28:32 <edwardk> yeah i think jake mcarthur picked it up for a while, but it is now rudderless
18:28:40 <edwardk> clearly you should take up the mantle
18:28:52 <edwardk> though i warn you it has led all before you to the pit of agda
18:29:59 <edwardk> where they were devoured by exotic type errors while looking at frilly operators
18:30:15 <ClaudiusMaximus> any ideas? or should i just hit 'make' again and hope it works?
18:31:00 <edwardk> aavogt: i also have some partially finished blas bindings that were intended to compile down to blas code using quantifier tricks, but it fell of my critical path and I never picked it up again
18:31:02 <aavogt> there's no repo for vector-static
18:31:31 <cmccann> pff, doing arithmetic with peano numerals
18:31:32 <aavogt> the blas aren't very many routines
18:31:59 * cmccann should hack vector-static to do better arithmetic
18:32:06 <edwardk> true, but it was more about the compiling process
18:33:36 <cmccann> aavogt, https://github.com/copumpkin/vector-static seems relatively recent
18:34:39 <aavogt> cmccann: Saizan seems to have a more recently changed fork
18:35:21 <cmccann> edwardk, oh, I also think my recent batch of type hackery includes the most useless thing I've ever written, a function that attempts to serialize functions to an Integer
18:35:32 <aavogt> edwardk: could you explain what you mean by quantifier trick
18:35:34 <aavogt> ?
18:35:52 <cmccann> I tested it on (&&) and (||) and it worked, probably going to leave it at that though
18:36:12 <aavogt> function serialization would be very useful
18:36:21 <cmccann> aavogt, not the way I was doing it
18:36:44 <cmccann> which was the most stupid and generic way possible
18:37:16 <pumpkin> aavogt: I abandoned it because GHC haskell kind of sucks to do interesting type-level programming in
18:38:06 <aavogt> cmccann: the same idea as   instance (Enum a, Bounded a, Show b) => Show (a -> b)?
18:38:37 <edwardk> aavogt: its mostly the germ of an idea right now, but using the trick from reflection to make a dictionary for a class that contains an array of mvars of hashmaps
18:39:06 * aavogt digests
18:39:08 <edwardk> then using unsafePerformIO to write entries into that map for hash consing or memoization
18:39:11 <cmccann> aavogt, I expect so. I bolted it onto a sort of generalized Enum class I wrote
18:39:26 <edwardk> but then when the quantified cache goes out of scope there'd be no way to access it, so all good
18:39:46 <edwardk> basically a comonadic ST for caching
18:39:50 <edwardk> and hash consing
18:40:37 <edwardk> rather more of a contravariant ST
18:42:16 <cmccann> aavogt, here's the implementation if you're curious https://github.com/isomorphism/typewriter/blob/master/Data/Typewriter/Types/Algebraic/Card.hs
18:42:43 <cmccann> I'm aware it's terrible but I don't see there being enough utility to try and make it more efficient
18:44:19 <d-day> cmccann: re: the Applicative discussion you were in on, on reddit...
18:44:21 <edwardk> anywys the reflection trick lets you use it in monoid instances, etc. without plumbing a lambda around
18:44:46 <cmccann> d-day, ?
18:45:22 <hpaste> ClaudiusMaximus annotated “ghc build failure” with “ghc build failure (annotation)” at http://hpaste.org/50345#a50346
18:45:42 <cmccann> aavogt, also if you have any suggestions on stuff I should toss into that library I'd be happy to hear them
18:45:47 <ClaudiusMaximus> seems my `ld` doesn't look in the right dirs...
18:45:58 <d-day> with some like filter ( <> <$> <*> ... <*> ... <*>) [inputs]
18:46:18 <d-day> the point of that kind of construct that you can see all of the things between <*> happening at the same time?
18:47:27 <cmccann> d-day, if you're talking about that code snippet from a question on stack overflow, what's going on there is that <*> is applying multiple functions to a common argument, then to each other
18:47:44 <cmccann> and <$> just applies a function to the results alone
18:47:55 <aavogt> cmccann: maybe this is possible:  instance Data a => Card a
18:48:17 <cmccann> d-day, it's just a convoluted way of gluing functions together without using lambdas and such
18:48:34 <cmccann> aavogt, oh, probably
18:48:38 <cmccann> that's actually not a bad idea, hm
18:50:04 <dainanaki> is there any way to have a bytestring builder render in parallel?
18:50:29 <aavogt> @hoogle gread
18:50:30 <lambdabot> Data.Generics.Text gread :: Data a => ReadS a
18:50:43 <dainanaki> it looks like it's all function composition under the hood, which I can't figure out how to parallelize...
18:51:05 * cmccann was also considering attempting to serialize polymorphic functions operating on Num instances by some sort of trickery along the lines of how AD works
18:51:56 <cmccann> since obviously enumerating every possibility for a function with a type like (Int -> Int -> Int) is not really going to happen
18:52:35 <nyingen> how trivial is it to convert a package that uses Parsec 2 to one that uses Parsec 3?
18:52:54 <edwardk> its easy
18:53:05 <nyingen> ah, good
18:53:06 <cmccann> but again, I'm not that enthusiastic about the whole serializing functions thing, since the general case is intractable and the easy cases are boring
18:53:10 <aavogt> > let f x y = x / y + 3 :: Expr in f a b
18:53:11 <lambdabot>   a / b + 3
18:53:15 <edwardk> there is also a compatibility layer
18:53:26 <aavogt> cmccann: ^^ that kind of serialization?
18:53:32 <edwardk> Text.Parsec.* is the new stuff Text.ParserCombinators.Parsec is the existing stuff
18:53:40 <edwardk> er old stuff i guess
18:53:44 <nyingen> edwardk: indeed, but this package (tagsoup-parsec) pulls in parsec2 specifically
18:53:53 <edwardk> by old stuff i mean it goes out of its way to ape the old api
18:53:53 <edwardk> yeah
18:54:03 <edwardk> but that was back when parsec 3 was an actual performance hit
18:54:10 <cmccann> aavogt, yeah, with some extra hacks to deal with functions that don't work exclusively on numeric types, etc. not too hard.
18:54:18 <nyingen> edwardk: ah yes
18:54:18 <edwardk> that changed with antoine latter's cps improvements to parsec
18:54:46 <nyingen> tagsoup-parsec is only 1 relatively small source file so I figured I'd go ahead and convert it, if it weren't going to be too much trouble
18:54:56 <edwardk> ah
18:54:58 <nyingen> though I guess I could probably just change its cabal file?
18:55:10 <edwardk> that's a start
18:55:20 <edwardk> you may not have to do any more than that
18:55:24 <nyingen> cool
18:55:31 <ivanm> where in ~/.cabal/config do I specify my hackage username + password?
18:55:50 <edwardk> hackage-username: EdwardKmett
18:55:51 <ivanm> I have the username and password values set, but cabal upload still asks me for them :s
18:55:55 <edwardk> hackage-password: ....
18:55:59 <nyingen> as a broader question, should packages generally be "upgraded" to parsec3? is parsec2 obsolescent?
18:56:08 <ivanm> ahhh
18:56:13 <ivanm> so what is username and password for?
18:56:17 <edwardk> no idea
18:56:25 <ivanm> nyingen: in general, you should try to let them be compatible with both if possible
18:56:25 <hpaste> Cale pasted “Curious warning resulting from SPECIALISE pragmas.” at http://hpaste.org/50347
18:56:35 <ivanm> (AFAIK, all parsec2 parsers work with parsec3)
18:56:39 <Cale> ^^ anyone understand what's going on there?
18:56:40 <edwardk> i only discovered i could do this myself recently
18:56:42 <ivanm> but, parsec2 is apparently faster than 3
18:56:49 <edwardk> ivanm: used to be
18:56:52 <nyingen> ivanm: yeah, I think that's true (about the compatibility)
18:56:57 <edwardk> this fud ceased to hold around 3.1
18:57:26 <cmccann> Cale, obviously your LHS is too complicated, you should simplify it :D
18:57:36 <ivanm> edwardk: I know someone sped it up, but thought it was still a tad slower in general
18:57:38 <Cale> lol
18:57:54 <ivanm> edwardk: I just use polyparse and avoid the issue :p
18:58:14 <colah> How do I write an array of Floats to a file?
18:58:32 * cmccann assumed that nobody really used Parsec for its blazing speed anyway
18:58:32 <edwardk> the difference between 2 and 3 is within the margin of error
18:58:37 <edwardk> worst case 5% or so
18:58:43 <ivanm> yeah, I think that's the case now
18:58:53 <edwardk> it used to be a factor of 2
18:59:02 <ivanm> edwardk: even then, I never got a straight answer regarding speed whether they re-wrote them to use the new parsers or just the compatability stuff
18:59:47 <colah> I can encode them as Word16 s, but I don't know what to do after that.
18:59:51 <Cale> It's worth noting that Component is an associated type
19:00:09 <edwardk> i should try converting something big like pandoc to trifecta and seeing how bad the slowdown is
19:00:43 <ivanm> edwardk: yeah, good luck with that...
19:00:51 <ivanm> since there are so many parsers in pandoc
19:00:52 <ivanm> ;)
19:00:53 <edwardk> i do somethings that parsec doesn't which should help, but then i spend a lot of time gilding the lily tracking error messages, etc.
19:01:17 <ivanm> edwardk: you can try porting graphviz if you want... biggest issue I have with polyparse is lack of error reporting :s
19:01:43 <edwardk> you're commit based though
19:01:54 <ivanm> edwardk: actually, I think I only use commit itself once...
19:01:57 <edwardk> and i don't have a polyparse combatibility layer yet
19:02:01 <ivanm> but yeah, I do a lot of `orElse`
19:02:18 <ivanm> hackagebot: hurry up and announce my uploads! ;)
19:04:45 <edwardk> i may start with something smaller like json or something
19:05:49 * hackagebot graphviz 2999.12.0.0 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.12.0.0 (IvanMiljenovic)
19:05:51 * hackagebot Graphalyze 0.12.0.0 - Graph-Theoretic Analysis library.  http://hackage.haskell.org/package/Graphalyze-0.12.0.0 (IvanMiljenovic)
19:05:54 * hackagebot SourceGraph 0.7.0.1 - Static code analysis using graph-theoretic techniques.  http://hackage.haskell.org/package/SourceGraph-0.7.0.1 (IvanMiljenovic)
19:06:13 <colah> Agh, never mind, I'll convert them into char's manually
19:06:38 <mustelo> what are people's opinion of numeric-prelude?
19:06:49 <edwardk> it was henning'd
19:06:55 <ivanm> mustelo: unmaintained
19:07:03 <ivanm> edwardk: not _another_ json library!
19:07:05 <mustelo> ah, that's discouraging
19:07:20 <ivanm> edwardk: though I note that bos put in a custom parser in aeson rather than using an existing one
19:07:28 <edwardk> ivanm: yeah
19:07:48 <luite> yay another json lib, make it work with ghci please ;)
19:07:49 <edwardk> i was literally just going to take the parsec parser in the 'json' package and see how it ported ;)
19:07:59 <edwardk> not planning on distributing it
19:08:13 <edwardk> throw it in the examples folder, etc.
19:08:26 <ivanm> luite: why don't any of the others?
19:08:34 <ivanm> edwardk: ahhh, fair enough
19:08:37 <edwardk> but i don't expect trifecta to win any benhmarks
19:08:41 <edwardk> it isn't designed to
19:08:49 <luite> ivanm: oh yesod uses aeson but that has some problems due to dynamic linker limitations
19:08:52 <d-day> don't be so hard on yourself
19:08:59 <d-day> but please, please do mark down instead of json :o
19:09:11 <edwardk> not tracking lots of extra interval trees, for syntax highlighting purposes, etc.
19:09:27 <luite> ivanm: so it can't (always) be used in template haskell, ghci or when using ghc to dynamically run code
19:09:28 <edwardk> and completion info for interactive use and what not
19:10:02 <ivanm> oh, it links to C?
19:10:06 <luite> C++
19:10:15 <ivanm> d-day: why do we need another markdown prser?
19:10:17 <edwardk> i want to wire it into haskeline and try out the completions, but i have to admit the interface is painful
19:10:34 <ivanm> luite: it does? I thought linking to C++ was almost impossible :/
19:10:54 <luite> ivanm: it uses C++ as some deep dependency, double-convert
19:10:56 <cmccann> ivanm, we need another markdown parser because the current ones don't fully exhaust the space of subtle incompatibilities
19:11:05 <d-day> ivanm: because I am writing something to do that in Ruby, and I'd love to see the difference.
19:11:05 <edwardk> cmccann: hah
19:11:14 <edwardk> i do actually need a markdown parser
19:11:22 <luite> ivanm: and yes, C++ objects have all kinds of special sections that the ghc dynamic linker doesn't understand
19:11:22 <edwardk> for parsing comments in a toy language
19:11:39 <edwardk> because it is MUCH more regular than haddock
19:12:14 <luite> ivanm: but some people think projects using ghci or template haskell aren't real projects so they use it anyway ;p
19:13:06 <d-day> yeah. The other approach I'm taking, is the idea that you can specify a restriction on the lax md syntax, and un-overload things like (+,-,*) being treated the same, and allowing things like ++ ++- (diff symbols and list manip symbols) as bullets
19:13:11 <luite> bah this git bisect thing on ghc will take some time....
19:14:14 <luite> does anyone have a 24-core server or so, that I can borrow for a while? :p
19:14:20 <d-day> and most importantly, reparsing md lists and tables back into code (for defaults)
19:14:33 <d-day> luite: I used to have access to a cell cluster you could borrow :(
19:14:33 <mustelo> is there a name for this guy? (****) :: (a -> b -> c) -> (d -> e -> f) -> (a,d) -> (b,e) -> (c,f)
19:14:46 <luite> d-day: I doubt those are useful for rebuilding ghc :)
19:14:57 <d-day> luite: no.
19:15:23 <d-day> well, as of 7.2.1, maybe, since some aspects of x-compiling now work?
19:15:24 <d-day> maybe?
19:16:08 <cmccann> mustelo, not that I'm aware of, though I'm sure there's one somewhere on hackage
19:16:13 <copumpkin> mustelo: nope, but you can construct it point-free fairly easily
19:16:43 <mustelo> copumpkin, really? best I could do was just write it myself?
19:18:40 <mustelo> I don't recommend the @pl version ;p
19:19:28 <ivanm> edwardk: and you don't want to use pandoc as a library?
19:20:34 <edwardk> ivanm: i'm not wedded to doing things one way or the other there
19:21:42 <ivanm> edwardk: I meant for wanting a markdown parser for something
19:21:50 <dainanaki> grr, I can't seem to find any computations in my program that are coarse enough to get any real benefit from parallelism.
19:21:52 <edwardk> yeah
19:22:02 <edwardk> i was mostly looking for interesting test grammars
19:22:29 <edwardk> i wanted to see if all this free syntax highlighting stuff i have is useful to other grammars
19:22:53 <ivanm> than just regular languages, etc.?
19:23:41 <edwardk> yeah
19:25:23 <aavogt> @pl \f1 f2 x1 x2 -> (uncurry (***) $ (f1 *** f2) x1) x2
19:25:24 <lambdabot> ((uncurry (***) .) .) . (***)
19:25:28 <thoughtpolice> edwardk: ping! trifecta 0.32.1 doesn't build, because it depends on comonad and semigroup, but trifecta depends on semigroup 0.8.* and comonad depends on < 0.8
19:25:34 <thoughtpolice> thought you should know :)
19:25:43 <edwardk> odd i should have a current version of comonad out there
19:26:01 <cmccann> thoughtpolice, when was the last time you updated your cabal package list?
19:26:08 <edwardk> i guess i didn't push it
19:26:15 <thoughtpolice> 1.1.1 says it depends on semigroups >= 0.7.1 & < 0.8
19:26:19 <cmccann> I recommend updating no less than five minutes before trying to install any of edwardk's stuff
19:26:22 <thoughtpolice> that's the latest version of comonad on hackage
19:26:30 <thoughtpolice> cmccann: cabal update && cabal install trifecta :D
19:26:31 <luite> what's the standard way to build a ghc from say 6 months ago? sync-all doesn't work when not on the master branch, and when I sync-all on master and then checkout the old version, the libraries are incompatible
19:26:34 <cmccann> heh
19:26:34 <edwardk> uploading
19:26:43 <edwardk> uploaded
19:26:46 <edwardk> try now
19:26:47 <thoughtpolice> edwardk: ta
19:27:03 <luite> unfortunately the haskell.org server doesn't keep an archive of older ghc snapshots
19:27:23 <edwardk> basically all i've added is an interval map for tracking syntax highlighting information
19:27:31 <edwardk> and i simplified the result type a bit
19:28:36 <mustelo> aavogt, nice.
19:29:14 <luite> does anyone know whether there's an archive with older source and/or binary snapshots for ghc somewhere?
19:30:12 <thoughtpolice> luite: the general problem is, you can't. at least not from vcs. :( because the bootlibs are tracked independently of GHC, but they also naturally require updates as GHC does. so reverting to an 'old copy of the tree' is actually quite difficult in practice
19:30:34 <thoughtpolice> because you have to have ghc's repo + all bootlib repos in sync properly
19:30:50 * hackagebot comonad 1.1.1.1 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-1.1.1.1 (EdwardKmett)
19:30:51 <thoughtpolice> (otherwise strange things could happen.)
19:30:52 <d-day> that sounds like what he's trying to do
19:30:54 <luite> thoughtpolice: yeah this is really crappy :(
19:31:02 <luite> makes it impossible to test stuff with older ghc
19:31:06 <thoughtpolice> luite: yeah it sucks. :( david peixetto solved this recently
19:31:13 <thoughtpolice> but only in the past few months
19:31:22 <d-day> the cabal GSoC guy?
19:31:25 <d-day> (just a random guess)
19:31:28 <thoughtpolice> no
19:32:01 <thoughtpolice> luite: he added a 'fingerprint' script to the GHC repo that keeps track of the latest git sha1's from ghc + all the bootlibs. but this was pretty recent. in the future it should hopefully make syncing back to previous tree states easier
19:32:14 <thoughtpolice> but that requires it being used more, naturally.
19:32:51 <luite> thoughtpolice: yeah that's a problem for me since the change I'm trying to track down is in 7.2.1, but not in 7.0.4 :)
19:32:55 <thoughtpolice> luite: are older source packages not an option?
19:33:07 <thoughtpolice> ah
19:33:10 <luite> thoughtpolice: if they're available anywhere
19:33:20 <luite> the official server doesn't have packages older than june or july
19:33:32 <thoughtpolice> yeah i don't know about weekly snapshots or anything
19:33:37 <thoughtpolice> maybe that would be something nice to have
19:33:41 <luite> and 7.0.4 is from last year, the change might have been introduced in master even earlier
19:35:10 <luite> weekly would probably be ok, after the correct week has been located, copy the bootlibs to the ghc repo, run git bisect on that week
19:35:19 <luite> bootlibs from the source pkg
19:35:30 <luite> they're not very likely to change
19:37:20 <luite> does sanyone have backups of the ghc/dist/curent/dist directory with decent history?
19:37:46 <d-day> luite: the guy who runs hackage is responsive to email
19:38:00 <d-day> or, the guy who responds to emails to the specified address is... responsive to emails.
19:38:02 <luite> that's a different server
19:38:07 <luite> dunno if it's the same guy
19:38:34 <ClaudiusMaximus> so it seems ghc-7.2.1 won't build with binutils-gold ...
19:40:50 * hackagebot taffybar 0.1.2 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-0.1.2 (TristanRavitch)
19:41:05 <luite> d-day: I don't know where exactly hackage is hosted, but its in the US, www.haskell.org is Germany
19:46:48 <gwern> > 11.11 * 2.99 / 10
19:46:49 <lambdabot>   3.32189
20:03:26 <d-day> luite: I was just saying he might have access to a collection of old (packaged) versions of haskell stuff
20:03:51 <d-day> s/haskell/ghc
20:04:24 <dainanaki> so I've got a program that I've spent a lot of time optimizing to have good speed and memory usage tradeoffs, but I'm hitting a bottleneck with printing out lots of data at once, particularly in building the bytestrings using blaze-builder. does anyone have any advice on how to improve performance in this regard?
20:04:42 <ivanm> dainanaki: heh, that's my bottleneck as well
20:04:54 <ivanm> you sure you're not me... ? :p
20:05:13 <dainanaki> heh, it's possible.
20:05:18 <luite> d-day: yes that's possible
20:05:34 <dainanaki> ivanm, how have you dealt with it thus far?
20:05:42 <d-day> dainanaki: are you generating documents or changing documents?
20:05:49 <d-day> (or both?)
20:05:49 <dainanaki> generating.
20:05:53 <d-day> aw :(
20:05:57 <d-day> human readable?
20:05:59 <ivanm> dainanaki: moved on to something else
20:06:01 <dainanaki> yes.
20:06:09 <dainanaki> ivanm: what did you find that's faster?
20:06:10 <ivanm> my main concern was counting the number of objects + serialising them
20:06:19 <ivanm> "something else" == "another project" :p
20:06:23 <dainanaki> aha
20:06:29 <ivanm> but yeah, my first port from binary to blaze-builder was _slower_ :s
20:08:56 <dainanaki> i figured that building bytestrings would be fast enough, but it's taking up about 50% of my memory allocations and 50% of the computation time, but I'm wondering if that's just the inherent cost of dealing with any sort of strings.
20:11:56 <kmc> dainanaki, are you building lots of small bytestrings and gluing them together?
20:12:08 <dainanaki> yes.
20:12:18 <dainanaki> I'm not sure how else to do it though.
20:13:18 <kmc> imperatively
20:13:25 <Axman6> are you using a bytestring builder?
20:13:32 <dainanaki> yes.
20:13:39 <kmc> blaze-builder might be smart enough to do that for you
20:13:48 <Axman6> yeah, that's what i was going to suggest
20:13:51 <dainanaki> I am using blaze-builder.
20:14:23 <Axman6> care to share the code?
20:14:37 <dainanaki> I can share the relevant parts, sure.
20:15:41 <d-day> are the sizes of each of the small strings identical?
20:15:56 <d-day> or always known?
20:16:00 <d-day> I suppose, 'regular'?
20:16:44 <hpaste> dainanaki pasted “Blaze Builder Allocation” at http://hpaste.org/50348
20:16:45 <ivanm> dainanaki: I'm finding the same thing actually
20:16:54 <dainanaki> this isn't the whole program, but it should make the gist of it clear.
20:16:56 <ivanm> I got confused with blaze-builder between Builder and Writer :/
20:17:28 <dainanaki> d-day: yes, they are generally about 140 words long.
20:17:52 <d-day> oh.
20:18:36 <d-day> try allocating big blocks of bytestrings, `mod` 140 or something along those lines?
20:18:36 <dainanaki> by words, i mean the computer kind
20:18:43 <d-day> oh, i thought twitter kind
20:18:53 <d-day> (characters)
20:18:58 <d-day> but yeah, even better I guess
20:19:06 <d-day> (just because of the particular number 140)
20:19:38 <dainanaki> that's just me counting the typical length.
20:20:31 <dainanaki> Axman6: any advice?
20:24:09 <bmars> I'm trying to install ghc and cabal-install without the haskell platform on linux.  I'm using the cabal-install unix script which is supposed to download everything I need but I get an error telling me that it can't find the unix base.
20:25:07 <d-day> in McBride's applicative paper, he mentions [page 4] that 'we could alternatively use the variant of ap that performs the computations in opposite order'
20:25:21 <d-day> that isn't referring to Alternative, is it?
20:25:25 <dainanaki> well, if anyone does have any ideas, then just leave me a small message.
20:25:27 <dainanaki> thanks all.
20:25:48 <cmccann> d-day, no
20:26:08 <d-day> cmccann: didn't think so, since that has a monoid prereq too... what is it?
20:26:14 <d-day> is it just ordering them the other way?
20:26:15 <cmccann> it's just referring to there being no intrinsic direction to an applicative instance
20:26:28 <d-day> so, is it possible for them to have both?
20:26:33 <d-day> i mean, to run both at the same time?
20:26:39 <cmccann> the "effects" or whatnot that come with the structure can be combined in either direction
20:26:42 <cmccann> no
20:26:55 <d-day> not even with a double ended traversable structure?
20:26:58 <d-day> like a pair of trees?
20:27:07 <d-day> or a BiPlate?
20:27:20 <cmccann> that doesn't really have anything to do with the applicative instance, I don't think
20:27:49 <cmccann> the point there is just that applicative is oblivious to how the structure is combined, unlike monad, which imposes a linear ordering
20:29:24 <d-day> like, for instance, (\f) <$right> -n <*> -1 <*> 0 <*> +1 <*> +n <$goleft> (\f)?
20:29:29 <d-day> if that's correct
20:29:47 <d-day> where the function does something as a base case at 0?
20:30:08 * cmccann isn't really sure what you're getting at
20:35:55 * hackagebot libxml-sax 0.7.2 - Bindings for the libXML2 SAX interface  http://hackage.haskell.org/package/libxml-sax-0.7.2 (JohnMillikin)
20:52:33 <kmc> any more thoughts on the FAQ?
20:53:07 <copumpkin> @faq can haskell think about the FAQ?
20:53:08 <lambdabot> The answer is: Yes! Haskell can do that.
20:53:24 <cmccann> kmc, I feel like a slacker for not contributing more, does that count?
20:53:35 <copumpkin> what faq is this?
20:53:40 <shachaf> @where faq
20:53:41 <lambdabot> http://haskell.org/haskellwiki/FAQ
20:56:56 <hpaste> Sordina pasted “gravity” at http://hpaste.org/50350
20:59:02 <Eduard_Munteanu> 5.1 Doesn't a static type system just make it harder to write programs? Yes. In particular, it makes it much harder to write incorrect programs.     -- liked that :)
20:59:59 <kmc> thanks Eduard_Munteanu
21:00:04 <kmc> there's a few ways to look at that
21:01:11 <mustelo> what's that from?
21:01:16 <kmc> @where faq
21:01:16 <lambdabot> http://haskell.org/haskellwiki/FAQ
21:01:19 <kmc> written by me
21:01:22 <kmc> soon written by all y'all
21:01:30 <mustelo> sweet
21:01:32 <kmc> tis a wiki
21:01:32 <cmccann> @faq can Haskell write incorrect programs?
21:01:33 <lambdabot> The answer is: Yes! Haskell can do that.
21:01:56 * Eduard_Munteanu should register on the wiki sometime
21:02:09 <mustelo> this is extensive! nice work, kmc
21:02:11 <mustelo> kmc++
21:03:08 <shachaf> s/No really/No, really/
21:03:56 <shachaf> (In entry 5.1.)
21:07:10 <bmars> does anyone know of a paper or tutorial on monadic fixpoints that doesn't involve circuits?
21:08:46 <copumpkin> monochrom's one?
21:08:53 <copumpkin> I think he had one
21:09:45 <copumpkin> oh, it's on the wiki
21:09:46 <copumpkin> http://www.haskell.org/haskellwiki/MonadFix
21:09:59 <shachaf> People keep linking to the Typeclassopedia page, which says "look in TMR issue 13". Maybe it would make sense to put it on its own page?
21:10:11 <shachaf> @where typeclassopedia
21:10:11 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
21:10:41 <bmars> thx
21:11:39 <Eduard_Munteanu> Hm, yeah, maybe it should be wikified or otherwise published independently of TMR.
21:12:10 <shachaf> preflex: seen byorgey
21:12:11 <preflex>  byorgey was last seen on #haskell 7 hours, 34 minutes and 28 seconds ago, saying: thanks, I'll look into that
21:13:01 <kmc> i'm wondering if the FAQ is / will be too big for one wiki page
21:14:11 <shachaf> Seems OK so far.
21:14:20 * shachaf is biased toward single-page everything, though.
21:18:13 <kmc> has anyone used the new generic programming support in GHC 7.2?
21:18:43 <kmc> i'm thinking of implementing generic diff for arbitrary algebraic data
21:18:48 <kmc> and wondering if it's appropriate
21:19:52 <kmc> looks like there is already http://hackage.haskell.org/packages/archive/gdiff/1.0/doc/html/Data-Generic-Diff.html
21:20:55 * hackagebot chell 0.1.2 - Quiet test runner  http://hackage.haskell.org/package/chell-0.1.2 (JohnMillikin)
21:26:12 <dylukes> kmc: wait what?
21:26:21 * kmc waits
21:26:46 <dylukes> reading
21:27:17 <kmc> which
21:27:22 <kmc> the gdiff library?
21:27:23 <dylukes> http://www.haskell.org/haskellwiki/Generics
21:27:40 <kmc> oh, cool, i didn't know that page existed!
21:28:23 <cmccann> hm, I keep forgetting that the generics stuff is still a thing that exists
21:28:31 <cmccann> I really should use some of that for my type hackery
21:30:20 <dylukes> when is HP2011.3?
21:32:05 <shachaf> You mean .4?
21:32:41 <dylukes> is .3 out?
21:32:53 <shachaf> Every six months is the general plan.
21:33:04 <dylukes> yeah but its behind
21:33:06 <shachaf> No, but odd version numbers are testing pre-releases.
21:33:06 <dylukes> the previous one should have been july
21:33:13 <dylukes> mmk
21:33:23 <shachaf> 2011.2 came out in March.
21:33:26 <shachaf> How is it behind?
21:33:32 <dylukes> no no, nmd
21:33:35 <dylukes> http://trac.haskell.org/haskell-platform/wiki/ReleaseTimetable
21:33:47 <dylukes> I misread
21:34:00 <dylukes> well no
21:34:05 <dylukes> .4 says Jul
21:34:05 <dylukes> but w/e
21:34:51 <shachaf> That page hasn't been updated for 4 months.
21:35:20 <shachaf> But, as you so eloquently put it, "w/e". :-)
21:39:10 <kmc> cmccann, yeah, there was a totally different -XGenerics in older GHC
21:39:14 <kmc> which wasn't very useful iirc
21:39:23 <kmc> and there's SYB and GHC support for deriving its classes
21:39:40 <cmccann> kmc, yeah, but I read about the new stuff a while back and then forgot
21:39:41 <kmc> and Uniplate and Multiplate and DrIFT and Derive and a bunch of other stuff
21:39:56 <kmc> derive is probably excessively fancy
21:40:05 <cmccann> and was probably going to end up reinventing a lot of it because of that so glad to be reminded!
21:42:40 <kmc> for diffs i'll want to treat certain type constructors specially
21:42:43 <kmc> [] for one
21:42:51 <kmc> but also other list-like types, like Seq
21:42:55 <kmc> possibly designated by the user
21:43:06 <kmc> i think I can do this with GHC 7.2 generics, though
21:43:16 <coppro> yes you can
21:43:24 * cmccann should switch his ridiculous cardinality class to use the new generics
21:43:32 <kmc> because what you export is a class method with a default implementation that uses generics
21:43:41 <kmc> but you can also write an explicit implementation
21:44:10 <coppro> .win 12
21:44:47 <shachaf> coppro: M-w
21:45:05 <coppro> shachaf: I don't have sufficient keybindings for all my windows
21:45:20 <shachaf> coppro: Sure, but you do for that one.
21:45:40 <coppro> shachaf: yes, but it is mentally faster to just type /win # rather than determine if it has a keyboard shortcut
21:45:55 <kmc> why 12 = w?
21:46:04 <shachaf> kmc: 1-0, q-o
21:46:16 <ClaudiusMaximus> it's just underneath 2 on a qwerty keyboard
21:46:25 <kmc> ah
22:06:42 <nyingen> this is probably a faq, but where's cabal uninstall
22:08:40 <kmc> there is none :/
22:08:48 <nyingen> :(
22:08:56 <kmc> you can use ghc-pkg to hide the package
22:09:01 <kmc> you can probably rm the files manually
22:09:03 <shachaf> Or to unregister.
22:09:11 <shachaf> Which presumably you want to do if you're rming the files.
22:09:18 <nyingen> ah, true
22:09:22 <shachaf> Frequently-requested feature, that one.
22:21:46 <hpaste> “Chris Lloyd” pasted “Simplification w/ Generics” at http://hpaste.org/50353
22:23:48 <chrislloyd> hello! I've got a programming language class at Uni so I thought I'd do my assignment in Haskell as an excuse to learn it
22:24:06 <chrislloyd> (don't worry, I'm not asking for somebody to do my homework!)
22:24:40 <mustelo> hey chrislloyd
22:25:34 <chrislloyd> I'm trying to use Data.Generics.Schemes.everywhere to do a tree traversal and I'm getting a cryptic error, I'm unsure of where to look next: http://hpaste.org/50353
22:25:40 <shachaf> chrislloyd: And you're already using features that were only released in the last week?
22:25:41 <chrislloyd> hey mustelo
22:25:46 <shachaf> Oh, it's not that kind of Generics.
22:25:54 <mustelo> heh
22:26:38 <chrislloyd> eek! really? I'm literally about three hours young to Haskell :)
22:26:41 <shachaf> Hmm, hpaste is a bit presumptuous.
22:27:08 <kmc> SYB is more than a week old
22:27:32 <kmc> what's the error?
22:28:15 <chrislloyd> https://gist.github.com/1148514 "Could not deduce"
22:28:16 <kmc> chrislloyd, i think your "otherwise" should be _
22:28:31 <kmc> > otherwise
22:28:32 <lambdabot>   True
22:28:34 <hpaste> darkangel pasted “Seq grep” at http://hpaste.org/50354
22:28:39 <kmc> "otherwise" is just a cheeky global name for True
22:28:41 <kmc> it's for use in guards
22:29:00 <kmc> not patterns
22:29:07 <kmc> _ is a wildcard pattern
22:29:17 <hpaste> darkangel pasted “Par grep” at http://hpaste.org/50355
22:30:14 <chrislloyd> kmc: still the same error.
22:30:15 <chrislloyd> I have a feeling the error has something to do with not implementing a way of traversing the type tree?
22:30:23 <kmc> also i might rewrite it as "simplify = everywhere f where { f (SNot (SNot a)) = a; f _ = node }"
22:30:30 <kmc> (with newlines instead of braces and semicolons, if you like)
22:30:43 <darkangel> Hi there!
22:30:47 <kmc> chrislloyd, you implemented that when you derived Data for Query, no?
22:30:55 <shachaf> You probably want mkT?
22:31:03 <darkangel> I need help in parallelizing simple grep like program
22:31:09 <nyingen> ivanm: yay, graphviz update
22:31:11 <kmc> ah, everywhere (mkT f) ?
22:31:11 <shachaf> everywhere (mkT (\...)) instead of everywhere (\...)
22:31:15 <darkangel> can anybody help&
22:31:17 <chrislloyd> kmc: :/ uhh
22:31:21 <shachaf> It compiles when you add that.
22:31:53 <chrislloyd> shachaf: what does mkT do?
22:32:13 <ivanm> nyingen: yup
22:32:19 <ivanm> should be nicer to use now as well
22:32:26 <mustelo> chrislloyd, I annotated your hpaste, see if you can make sense of it
22:32:27 <kmc> http://hackage.haskell.org/packages/archive/syb/0.3.3/doc/html/Data-Generics-Aliases.html
22:32:32 <kmc> "Make a generic transformation; start from a type-specific case; preserve the term otherwise"
22:32:40 <kmc> :t mkT
22:32:41 <lambdabot> forall b a. (Typeable a, Typeable b) => (b -> b) -> a -> a
22:33:12 <nyingen> ivanm: looking forward to trying it out.
22:33:54 <darkangel> I had a seq program http://hpaste.org/50354 and parallel version http://hpaste.org/50355
22:34:04 <hpaste> “this seems to work” annotated “Simplification w/ Generics” with “Simplification w/ Generics (annotation)” at http://hpaste.org/50353#a50357
22:34:06 <darkangel> but parallel version is 10 time slower
22:34:35 <darkangel> what I'am diong wrong? Please help me
22:36:22 <shachaf> mustelo: Your annotation is non-exhaustive. :-)
22:36:47 <mustelo> ah, well. I've never actually used syb ;)
22:37:05 <shachaf> mustelo: Well, your lambda only matches SNot (SNot x), and crashes on any other input.
22:37:23 <shachaf> chrislloyd: Anyway, the another annotation seems to work. :-)
22:37:48 <shachaf> chrislloyd: I think https://docs.google.com/viewer?url=http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/Boilerplate%20v3.ppt was a nice introduction to SYB.
22:37:49 <mustelo> yeah, now that I think about it, it doesn't make any sense. the function should have type Query -> Query and I only considered one minute case
22:38:21 <chrislloyd> shachaf: ah awesome. I tried to follow the link in the docs but it lead to a 404
22:38:35 <shachaf> chrislloyd: Also the paper, https://docs.google.com/viewer?url=http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/hmap.ps
22:39:09 <jake1> Hi, I'm fairly new to Haskell and trying to figure out how to use "shuffle" in Data.Random.Extras. Can't figure out what to do with the RVar
22:39:10 * shachaf wonders how one encounters SYB three hours into learning Haskell.
22:40:29 <shachaf> I'm not even sure if SYB makes sense in that context.
22:41:34 <chrislloyd> shachaf: I'm friends with the mwotton (github.com/mwotton/Hubris) and he pointed me in that direction :)
22:41:58 <shachaf> That's blackdog, right?
22:45:45 <chrislloyd> shachaf: yep :)
22:47:37 <blackdog> chrislloyd: they sorting you out? :)
22:49:12 <chrislloyd> blackdog: trying to figure out why mustelo's annotation is non-exhaustive
22:49:39 <mustelo> chrislloyd, try calling that lambda with a query that is not of the form (SNot (SNot a))
22:49:50 <shachaf> chrislloyd: The function (\(SNot (SNot x)) -> x) only deals with the case that -- yes.
22:50:06 <mustelo> shachaf, partial redemption? :)
22:50:13 <shachaf> So, in fact, simplify is guaranteed to crash the program on almost any input.
22:50:28 <shachaf> I guess the only input it doesn't crash on is (fix SNot), in fact. :-)
22:51:45 <shachaf> (Or anything where the output is equivalently not examined, I suppose.)
22:52:42 <shachaf> blackdog: Isn't SYB a bit excessive three hours into learning Haskell, when only used on one type? :-)
22:53:09 <blackdog> shachaf: :) well, maybe i got overenthusiastic
22:53:33 <chrislloyd> mustelo: I tried adding the pattern "x = x" but it still complains when I pass it `simplify (SNor (SNot (SNot (SVar "A"))) (SVar "B"))`
22:53:34 <blackdog> still, it's a nice technique, and the original formulation he had was almost useless
22:54:04 <blackdog> chrislloyd: can't see anything new on the gist - you working somewhere else now?
22:54:30 <shachaf> chrislloyd: You can't add a pattern to a lambda.
22:54:49 <shachaf> blackdog: http://hpaste.org/50353
22:55:08 <chrislloyd> blackdog: updated (and for those following along at home: https://gist.github.com/1144680 - although ignore the coffeescript bit)
22:55:58 <mustelo> chrislloyd,  simplify (SNor (SNot (SNot (SVar "A"))) (SVar "B")) works for me with shachaf's annotation code
22:57:03 <chrislloyd> it's funny, the example in that press is exactly the same as the first Bondi example: http://bondi.it.uts.edu.au
22:57:24 <blackdog> chrislloyd: generics has a lot to do with barry's work
23:00:45 <chrislloyd> blackdog: yeah, he's thanked in that paper. maybe it's time to pick up my copy of Pattern Calculus again
23:02:01 <chrislloyd> mustelo: d'oh, didn't :l
23:02:28 <chrislloyd> mustelo kmc shachaf thanks for your help guys, really appreciated
23:21:58 <ared> heyeveryone
23:22:43 <mustelo> heyaredhow'sitgoing?
23:25:16 <ared> summer, sea, everything is fine
23:25:34 <mustelo> and your spacebar works, sounds like the good life
23:27:35 <ared> yeah, thenx
23:27:47 <elliott_> Using repa, is there a way to get a pointer (any level of abstraction -- even if it involves octothorpes) to the element values after a certain index? My array is one-dimensional, so I'm not concerned about row vs. column order.
23:29:07 <kniu> :t mapM
23:29:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
23:29:54 <kniu> @hoogle forall a (m :: * -> *) b (f :: * -> *). (Monad m, Functor f) => (a -> m b) -> f a -> m (f b)
23:29:54 <lambdabot> Parse error:
23:29:55 <lambdabot>   --count=20 "forall a (m :: * -> *) b (f :: * -> *). (Monad m, Functor f) => (a -> m b) -> f a -> m (f b)"
23:29:55 <lambdabot>                       ^
23:30:15 <kniu> @hoogle (Monad m, Functor f) => (a -> m b) -> f a -> m (f b)
23:30:15 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
23:30:16 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
23:30:16 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
23:30:30 <kniu> oh yeah, traversable
23:31:07 <kniu> is forM just flip mapM?
23:32:26 <c_wraith> yep
23:37:38 <kniu> :t concatMap
23:37:39 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
23:37:50 <kniu> @hoogle (a -> f b) -> f a -> f b
23:37:51 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
23:37:51 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
23:37:51 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
23:38:10 <kniu> I don't even
23:39:52 <mustelo> kniu, anything in particular you're looking for?
23:40:29 <kniu> nvm found it
23:40:39 <mustelo> kthxbye
