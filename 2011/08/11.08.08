00:32:25 <joe6> i am trying to use this module: uri: http://hackage.haskell.org/packages/archive/ioctl/0.0.1/doc/html/System-Posix-IOCtl.html. Is there any simple usage manual for it.?
00:32:32 <joe6> could not find any tests
00:32:40 <joe6> @hoogle fd
00:32:40 <lambdabot> System.Posix.Types newtype Fd
00:32:41 <lambdabot> System.Posix.Types Fd :: CInt -> Fd
00:32:41 <lambdabot> Network.Socket fdSocket :: Socket -> CInt
00:33:14 <joe6> how do I open a file "/dev/parport1" in read mode to return a file descriptor?
00:33:32 <joe6> @hoogle filepath
00:33:32 <lambdabot> package filepath
00:33:32 <lambdabot> module System.FilePath
00:33:32 <lambdabot> Prelude type FilePath = String
00:33:36 <shachaf> openFile "/dev/parport1" ReadMode
00:33:46 <joe6> shachaf: ok, thanks.
00:34:08 <shachaf> @google haskell open file
00:34:09 <lambdabot> http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-IO.html
00:34:09 <lambdabot> Title: System.IO
00:34:37 <joe6> shachaf: openFile "/dev/parport1" ReadMode :: IO Handle
00:34:47 <joe6> how do i get a filedescriptor?
00:34:57 <joe6> or, are they both the same?
00:34:58 <shachaf> You want the actual int?
00:35:31 <joe6> shachaf: i am tying to use the ioctl function of uri: http://hackage.haskell.org/packages/archive/ioctl/0.0.1/doc/html/System-Posix-IOCtl.html
00:36:12 <joe6> and it talks about "newtype Fd". Would it be the same as the actual Int?
00:39:44 <shachaf> Wow, GHC's Handle is a mean type.
00:40:17 <c_wraith> you mean the way it shuts itself down if you also extract the fd from it?
00:40:27 <c_wraith> or some other entirely unrelated strange stuff it does?
00:41:06 <mauke> joe6: depends on your definition of "same" :-)
00:41:36 <harblcat> is there a function that can do the following: f succ "aaa" -> ["baa", "aba", "aab"]?
00:41:40 <shachaf> c_wraith: I just mean that it contains a lot of things.
00:42:06 <c_wraith> that's true.  it's a very stateful type
00:42:13 <shachaf> harblcat: Presumably f succ "abc" -> ["bbc", "acc", "abd"]?
00:42:27 <joe6> i want to use the ioctl function and it needs an fd.
00:42:29 <kmc> harblcat, yes, that is a computable function
00:42:30 <kmc> :D
00:42:39 <harblcat> shachaf, yes, sorry if I was vague
00:42:40 <mauke> joe6: openFd should give you one
00:42:50 <joe6> mauke, ok, thanks.
00:42:55 <joe6> @hoogle openFd
00:42:55 <lambdabot> No results found
00:43:01 <mauke> joe6: http://www.haskell.org/hoogle/?q=openfd
00:43:26 <c_wraith> harblcat: doesn't look exactly like a trivial operation to build from existing combinators
00:43:33 <joe6> mauke, thanks. exactly what I need.
00:43:55 <harblcat> c_wraith: which is why I am asking :)
00:44:05 <mauke> > liftA2 zip heads tails "aaa"
00:44:06 <lambdabot>   Not in scope: `heads'
00:44:12 <mauke> > liftA2 zip inits tails "aaa"
00:44:13 <lambdabot>   [("","aaa"),("a","aa"),("aa","a"),("aaa","")]
00:44:25 <kmc> > map ($ "abc") [ replicate n id ++ [succ] ++ repeat id | n <- [0..2] ]
00:44:26 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> b'
00:44:27 <lambdabot>         against inferr...
00:44:46 <kmc> :t [ replicate n id ++ [succ] ++ repeat id | n <- [0..2] ]
00:44:47 <lambdabot> forall a. (Enum a) => [[a -> a]]
00:44:56 <kmc> dur
00:45:21 <shachaf> > let foo f [] = []; foo f (x:xs) = (f x:xs) : map (x:) (foo f xs) in foo succ "abc"
00:45:22 <lambdabot>   ["bbc","acc","abd"]
00:45:24 <kmc> > map (zipWith (flip ($)) "abc") [ replicate n id ++ [succ] ++ repeat id | n <- [0..2] ]
00:45:26 <lambdabot>   ["bbc","acc","abd"]
00:45:36 <shachaf> I don't think that's clearer than just writing it out.
00:45:38 <mauke> > let f (xs, c : ys) = xs ++ succ c : ys in liftA2 zipWith f inits tails "aaa"
00:45:39 <lambdabot>   Couldn't match expected type `a -> b -> c'
00:45:39 <lambdabot>         against inferred type `[...
00:45:50 <mauke> > let f xs (c : ys) = xs ++ succ c : ys in liftA2 zipWith f inits tails "aaa"
00:45:51 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `[t]'
00:46:15 <mauke> > let f xs (c : ys) = xs ++ succ c : ys in liftA2 (zipWith f) inits tails "aaa"
00:46:17 <lambdabot>   ["baa","aba","aab","*Exception: <interactive>:3:4-36: Non-exhaustive patter...
00:46:20 <mauke> there we go
00:48:06 <harblcat> that is some really amazing chatter, there
00:48:16 <mauke> > let f xs (c : ys) = xs ++ succ c : ys in (zipWith pure =<< liftA2 (zipWith f) inits tails) "aaa"
00:48:18 <lambdabot>   ["baa","aba","aab"]
00:49:00 <joe6> what are the different values of FileMode? http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-IO.html#v:openFd
00:49:02 <shachaf> harblcat: Now you've got them started.
00:49:25 <joe6> it says CMode.
00:49:30 <mauke> joe6: numbers, apparently
00:49:37 <mauke> joe6: do you want to create the file you're opening?
00:50:04 <joe6> nope. i just want to open /dev/parport1 to read the parallel port.
00:50:10 <shachaf> joe6: In the very link you linked: See System.Posix.Files for information on how to use the FileMode type.
00:50:21 <mauke> joe6: then you don't need a FileMode
00:50:23 <joe6> shachaf: yes, it points to CMode.
00:50:28 <mauke> shachaf: yes, but there is no information there
00:50:31 <joe6> mauke, ok. thanks. Nothing then.
00:50:44 <mauke> joe6: "Just x => creates the file with the given modes, Nothing => the file must exist. "
00:50:46 <shachaf> What?
00:50:50 <shachaf> http://www.haskell.org/ghc/docs/7.0.4/html/libraries/unix-2.4.2.0/System-Posix-Files.html seems to have information.
00:51:11 <mauke> shachaf: oh, I was on the wrong page
00:51:24 <joe6> me too.
00:51:28 <joe6> shachaf: thanks.
00:52:22 <mauke> you don't need all that stuff from System.Posix.Files
00:53:15 <mauke> instead of (ownerWriteMode `unionFileModes` ownerReadMode `unionFileModes` groupReadMode) you can simply say 0o640
00:56:01 <edwardk> @pl \f g d l -> g d (f d l)
00:56:02 <lambdabot> flip (liftM2 (.))
00:56:22 <joe6> mauke, what does that do?
00:56:31 <joe6> (ownerWriteMode `unionFileModes` ownerReadMode `unionFileModes` groupReadMode)
00:56:40 <joe6> mauke, do I need that to open a file for reading?
00:57:33 <mauke> no
00:57:55 <mauke> joe6: that's initial file permissions for newly created files
00:58:03 <joe6> mauke, ok. thanks.
00:58:05 <mauke> are you new to unix?
00:58:20 <joe6> @hoogle unionFileModes
00:58:20 <lambdabot> No results found
00:59:06 <mauke> joe6: http://en.wikipedia.org/wiki/Open_(system_call)#POSIX_usage_and_semantics   http://en.wikipedia.org/wiki/File_permissions#Traditional_Unix_permissions
01:05:12 * hackagebot base-unicode-symbols 0.2.2.1 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.2.2.1 (RoelVanDijk)
01:05:14 * hackagebot containers-unicode-symbols 0.3.0.4 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/containers-unicode-symbols-0.3.0.4 (RoelVanDijk)
01:18:44 <edwardk> i love working on haskell, if only because the code keeps shrinking as i write it
01:21:38 <juodis> excuse me, I don't get "Try Haskell"
01:23:07 <juodis_> I type 2+2, and get "Terminated!"
01:24:03 <shachaf> juodis_: Looks like it's broken.
01:24:25 <shachaf> preflex: seen chrisdone
01:24:26 <preflex>  chrisdone was last seen on #haskell 9 hours, 58 minutes and 16 seconds ago, saying: stack overflows in haskell are possible, but the general case is different to those languages
01:24:42 <c_wraith> I think he's using mueval, which has issues when things start timing out, like not cleaning up properly.
01:24:56 <shachaf> juodis_: Looks like it's working now?
01:25:58 <c_wraith> Hmm, that is acting more like a gateway was down, and it's back up now
01:26:05 <c_wraith> in any case, it's working now :)
01:27:50 <yitz> edwardk: what version of OpenType are you using?
01:28:46 <edwardk> no idea
01:29:25 <yitz> edwardk: must be something wrong with font rendering if the code keeps shrinking
01:30:10 <edwardk> hahahaha
01:30:30 <edwardk> each module individually at least ;)
01:31:15 <c_wraith> Yes, I've noticed you tend to shrink code by publishing more packages. :P
01:31:31 <yitz> try haskell is working for me
01:31:53 <shachaf> yitz: It was broken for me when juodis_ said it, but now it seems to work again.
01:31:55 <edwardk> well, within one package today, i've been working, and it started out with one enormous module that keeps shrinking as i find nice ways to rethink it
01:50:12 * hackagebot trifecta 0.8 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.8 (EdwardKmett)
01:50:17 <joe6> i have http://pastebin.com/Hi0PLGEY and fd <- openFd "/dev/parport0" ReadOnly Nothing defaultFileFlags -- returns Pic24FProgrammer: /dev/parport0: openFd: permission denied (Permission denied) as the user "joe"
01:50:19 <mauke> The paste Hi0PLGEY has been copied to http://hpaste.org/49969
01:50:33 <joe6> it works as root, though.
01:51:11 <mauke> try strace?
01:51:23 <joe6> ok, will do.
01:51:29 <joe6> mauke, thanks.
01:52:11 <c_wraith> hmm.  a bit annoying that the docs for trifecta appear not to build on hackage
01:52:20 <edwardk> yeah
01:52:23 <edwardk> i just noticed
01:52:39 <edwardk> i removed the — ^ 's that it doesn't like because they don't play well with {-# UNPACK #-}'s
01:52:45 <edwardk> hopefully 0.8.0.1 will build with docs
01:53:16 <edwardk> pushed
01:53:32 <edwardk> in the meantime the github repo works
01:53:41 <edwardk> and is nicely browsable, if not haddocked =)
01:55:12 * hackagebot monad-control 0.2.0.2 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.2.0.2 (BasVanDijk)
01:55:14 * hackagebot trifecta 0.8.0.1 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.8.0.1 (EdwardKmett)
02:12:23 <joe6> when I do "ghc --make ...hs", it builds a .o file, when I have a "module .. where" in the file.
02:12:59 <joe6> is there a way to build the executable with the "module .. where" in the file?
02:13:51 <Botje> either rename your module to Main or call ghc with --main-is (iirc)
02:13:59 <joe6> ok, thanks.
02:25:22 <tigerpaw> what's hello world in haskell look like?
02:25:28 <tigerpaw> plz
02:25:35 <edwardk> main = putStrLn "hello world"
02:25:49 <tigerpaw> what's Ln ?
02:25:54 <edwardk> line
02:26:02 <edwardk> putStr doesn't put the newline on it
02:26:04 <tigerpaw> so i presume it'd append \n ?
02:26:04 <mauke> main = putStr "Hello, world!\n"
02:26:09 <mauke> @src putStrLn
02:26:10 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
02:26:12 <tigerpaw> nice
02:26:14 <edwardk> yeah
02:26:26 <c_wraith> ick.  that implementation of putStrLn isn't thread-safe! :)
02:26:36 <tigerpaw> how could you make it thread safe?
02:26:50 <shachaf> c_wraith: Haven't you ever seen the "tthhrreeaadd  kkilleedd" sorts of messages?
02:27:05 <edwardk> because it uses two smaller writes it tends to cause multiple writes to interleave before the \n
02:27:21 <tigerpaw> yea obviously
02:27:23 <Ptival> atomically $ do ... ?
02:27:26 <tigerpaw> what's solution in haskell tho
02:27:32 <c_wraith> well.  assuming putStr is thread-safe (which is questionable, at best), you could make it thread-safe by appending \n first, then printing.
02:27:40 <Ptival> no I'm saying nonsense...
02:27:41 <shachaf> Ptival: ...atomically doesn't work on arbitrary IO code.
02:27:42 <c_wraith> but given the nature of strings in haskell, that's inefficient.
02:27:46 <shachaf> Would be nice, though! :-)
02:27:49 <Ptival> shachaf: yeah :D
02:28:00 <Ptival> on arbitrary code!
02:28:11 <tigerpaw> wait so this isn't possible in haskell or what?
02:28:18 <Ptival> atomically . bugfree . fixmymistakes $ mysequentialcode
02:28:29 <edwardk> @tell dankna i packaged up your changes, stripped the haddock #ifdefs, and removed a bunch of parens that bugged my modern sensibilities and shipped it
02:28:29 <lambdabot> Consider it noted.
02:28:34 <c_wraith> tigerpaw: it's possible, it's just at a different level of abstraction than "hello world"
02:28:47 <c_wraith> tigerpaw: at least, doing it correctly is.
02:29:04 <Ptival> @can haskell output a bunch of strings thread-safely?
02:29:04 <lambdabot> Maybe you meant: faq map run wn
02:29:08 <tigerpaw> what would that be like then ?
02:29:13 <Ptival> erf what was that again?
02:29:23 <c_wraith> tigerpaw: and people tend to work around it in complex apps by just having a single thread do all the output
02:29:33 <c_wraith> tigerpaw: then being thread-safe doesn't matter.
02:29:43 <tigerpaw> oh
02:30:00 <tigerpaw> so have all threads append output to a single threads queue, and single thread processes queue serially?
02:30:07 <mauke> tigerpaw: why do you think there are multiple writes there?
02:30:08 <c_wraith> and the inter-thread communication abstractions are good enough that you write it once and never think about it again.
02:30:27 <tigerpaw> mauke, cause there is
02:30:39 <tigerpaw> the append of \n then the print
02:30:40 <mauke> tigerpaw: no, there isn't
02:30:57 <tigerpaw> whatchu talkin' bout willis
02:31:08 <mauke> what are you talking about?
02:31:14 <tigerpaw> not sure
02:31:15 <tigerpaw> anyway thx
02:31:18 <mauke> @src putStr
02:31:19 <lambdabot> putStr s  = hPutStr stdout s
02:31:43 <edwardk> @tell dankna though now i really want to clean up the exports ;)
02:31:43 <lambdabot> Consider it noted.
02:32:49 <edwardk> it'll be really funny when the haddock finally builds for type-int again
02:35:12 * hackagebot type-int 0.5 - Type Level 2s- and 16s- Complement Integers  http://hackage.haskell.org/package/type-int-0.5 (EdwardKmett)
03:13:24 <koeskoes> hmm, is there something special i should know before trying cabal install hscurses?
03:16:57 <dschoepe> koeskoes: It probably requires some non-Haskell development packages to be installed (like the header files for curses). What's the error it fails with when you try?
03:20:05 <koeskoes> dschoepe: i'll try checking the packages again
03:21:48 <coppro>  /win 4
03:22:28 <joe6> i am trying to use the ioctl package with ppdev? but, am struggling to bridge them both given my inexperience with ioctl and ppdev.
03:22:36 <joe6> ioctl package: uri: http://hackage.haskell.org/packages/archive/ioctl/0.0.1/doc/html/System-Posix-IOCtl.html
03:22:51 <joe6> ppdev: uri: http://people.redhat.com/twaugh/parport/html/x623.html
03:22:56 <joe6> any suggestions, please?
03:23:17 <joe6> i can open up the fileDescriptor with:  fd <- openFd "/dev/parport1" ReadOnly Nothing defaultFileFlags
03:23:34 <joe6> but, then I am not able to figure out how to put the ioctl command together.
03:23:51 <joe6> ioctl fd :: IOControl req d => req -> d -> IO d
03:24:09 <joe6> any thoughts on what "req" or "d" could be?
03:25:15 * hackagebot data-default 0.3.0 - A class for types with a default value  http://hackage.haskell.org/package/data-default-0.3.0 (LukasMai)
03:26:06 <hvr> @tell bos are you aware that aeson-0.3.2.10 is broken?
03:26:06 <lambdabot> Consider it noted.
03:26:14 <koeskoes> dschoepe: yeah, i was missing a dev pack.  seems to rock n roll now.  *blush*
03:26:50 <joe6> should I be adding ppdev bindings to haskell, before being able to use ioctl with ppdev commands?
03:31:42 <identity_> hvr: I already reported the bug on his issues list
03:31:52 <identity_> hvr: I also posted instructions there on how to build it
03:33:07 <identity_> hvr: never mind, see you already saw it
03:40:39 <hvr> identity_: :-)
03:41:22 <cwl> RWH says better use foldr than foldl
03:41:47 <cwl> but in some case, code looks cleaner using foldl, then which should I choose
03:42:13 <cwl> http://hpaste.org/49971
03:42:25 <hvr> cwl: whether to use foldr or foldl' depends on the properties of the operator you want to fold with
03:43:30 <hvr> cwl: in your case I'
03:43:40 <cwl> hvr: so, if the operator for foldl' looks prettier, it is no bad to choose foldl', right?
03:43:41 <hvr> I'd use foldl' as your operation is strict
03:44:27 <hvr> cwl: I'd make it dependend on whether your operator always evaluates all operands
03:44:54 <hvr> cwl: e.g. a '||' operator doesn't need to evaluate its second operand if the first is True
03:45:43 <hvr> in that case you could use foldr
03:47:53 <hvr> cwl: but better read what people write that know better what they're talking about, e.g. http://stackoverflow.com/questions/384797/implications-of-foldr-vs-foldl-or-foldl
03:49:09 <cwl> hvr: in my case, there is no advantage using foldr because there is no short circuit
03:49:26 <hvr> cwl: then use foldl' which is most likely more efficient
03:49:53 <cwl> hvr: ok
03:50:32 <cwl> btw, is there any function do digits2Integer
03:50:50 <cwl> and, also Integer2digits
03:51:06 <osfameron> cwl: as in :: [Char] -> Integer  ?
03:51:11 <cwl> @src show :: [Integer]
03:51:11 <lambdabot> Source not found. Just try something else.
03:51:47 <hvr> osfameron: his example is more like [Int] -> Int
03:51:49 <cwl> osfameron: I don't know if it's efficient
03:52:14 <cwl> osfameron: though I can convert String to Int by read
03:53:38 <osfameron> cwl: yes, it sounds like you want read and show, but I wasn't sure I'd understood what you were doing
03:55:13 <cwl> osfameron: I am solving problems from projecteuler.net, dealing with the digits of an Integer
03:56:03 <cwl> osfameron: It is ok to use show, I wander the efficient
03:56:23 <osfameron> oh I see.  because you have to show to get the digit, and read back to get each digit as a number
03:56:59 <kalven> foldl1 (\x y -> x*10+y) digits
03:59:05 <quicksilver> > foldl1 (\x y -> x*10+y) [1,2,3,4,5]
03:59:06 <lambdabot>   12345
03:59:22 <quicksilver> > foldl' 0 (\x y -> x*10+y)  [1,2,3,4,5]
03:59:23 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
03:59:23 <lambdabot>    arising from a use...
03:59:35 <quicksilver> > foldl' (\x y -> x*10+y) 0  [1,2,3,4,5]
03:59:36 <lambdabot>   12345
04:01:49 <cwl> quicksilver: how about int to digits
04:02:20 <quicksilver> well, it's an obvious algorithm, just write it :P
04:02:45 <quicksilver> there is a oneliner using unfoldr which is probably not obvious unless you're used to that kind of thing.
04:04:37 <ion> > unfoldr (\n -> swap (n `divMod` 10) <$ guard (n /= 0)) 12345 -- wrong order
04:04:38 <lambdabot>   Not in scope: `swap'
04:04:45 <ion> Ah, lambdabot has an old version of Data.Tuple
04:04:48 <cwl> quicksilver: ok, I just write one, but ugly
04:04:58 <ion> > let swap = snd &&& fst in unfoldr (\n -> swap (n `divMod` 10) <$ guard (n /= 0)) 12345 -- wrong order
04:04:59 <lambdabot>   [5,4,3,2,1]
04:05:29 <ion> > let swap = snd &&& fst in reverse . unfoldr (\n -> swap (n `divMod` 10) <$ guard (n /= 0)) $ 12345
04:05:30 <lambdabot>   [1,2,3,4,5]
04:05:51 <quicksilver> > let swap = snd &&& fst in reverse . unfoldr (\n -> swap (n `divMod` 10) <$ guard (n /= 0)) $ 12045
04:05:52 <lambdabot>   [1,2,0,4,5]
04:05:57 * quicksilver nods
04:08:06 <ion> Doesn’t handle negative numbers, though. You probably want to prepend the resulting string with '-' and pass a positive number to the stringifier anyway.
04:08:11 <ion> ...or just use show ;-)
04:08:27 <ion> > let swap = snd &&& fst in reverse . unfoldr (\n -> swap (n `quotRem` 10) <$ guard (n /= 0)) $ negate 12345
04:08:28 <lambdabot>   [-1,-2,-3,-4,-5]
04:08:58 <cwl> ion: cool...
04:09:17 <cwl> ion: I need some time to learn it
04:09:45 <cwl> ion: how show implement this
04:09:46 <ion> Let me rewrite it without using Arrow or Applicative or Monad.
04:10:44 <kalven> make it more difficult
04:10:46 <ion> > let swap (a,b) = (b,a) in reverse . unfoldr (\n -> case n of 0 -> Nothing; _ -> Just (swap (n `quotRem` 10))) $ 12345
04:10:48 <lambdabot>   [1,2,3,4,5]
04:11:11 <ion> @src unfoldr
04:11:11 <lambdabot> unfoldr f b  = case f b of
04:11:11 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:11:11 <lambdabot>    Nothing        -> []
04:11:28 <ion> That should be most of the information needed to understand that.
04:14:25 <joe6> anyone has ppdev bindings for haskell?
04:18:41 <nda> hi
04:18:42 <cwl> get it
04:19:07 <nda> @pl \(a, b) (a, c) -> (a, b + c)
04:19:08 <lambdabot> (. snd) . ap (,) . (+) . snd
04:25:10 <ion> > (+) <$> ("foo", 3) <*> ("bar", 4)
04:25:11 <lambdabot>   ("foobar",7)
04:28:53 <siracusa> > - "foo"
04:28:53 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
04:28:54 <lambdabot>    arising from a use of syn...
04:30:20 * hackagebot clipper 0.0.1 - Haskell API to clipper (2d polygon union/intersection/xor/clipping API)  http://hackage.haskell.org/package/clipper-0.0.1 (ChetanTaralekar)
04:44:26 <kalven> I've been waiting for that lib
04:45:14 <joe6> i am trying to add bindings to ppdev.h: http://pastebin.com/d2mcHp7j, mainly for PPCLAIM. How can I add bindings for: #define PPSETMODE	_IOW(PP_IOCTL, 0x80, int)
04:45:16 <mauke> The paste d2mcHp7j has been copied to http://hpaste.org/49972
04:45:48 <joe6> #define PPSETMODE _IOW(PP_IOCTL, 0x80, int)
04:46:01 <joe6> how can I add a binding for something like this?
04:46:09 <joe6> i mean a haskell binding.
04:47:17 <edcaceres> ih?
04:47:23 <edcaceres> ih?
04:47:27 <edcaceres> hi?
04:47:35 <Ptival> olleh
04:47:40 <edcaceres> lol
04:48:04 <Ptival> you did spell "lol" backwards, didn't you?
04:48:14 <edcaceres> which is a good usage for haskell?
04:48:39 <merijn> edcaceres: Same things as every other programming language?
04:48:40 <Ptival> programming
04:49:08 <merijn> edcaceres: Although, general consensus is that haskell is one of the nicest languages to write compilers in because of the nice type system and awesome parsing libraries
04:49:50 <geheimdienst> i wouldn't limit it to compilers ... haskell is one of the nicest languages, period.
04:49:57 <merijn> geheimdienst: I agree
04:50:30 <edcaceres> im  java, abap programmer
04:50:39 <edcaceres> abap is procedural too
04:50:41 <merijn> It's just one of the things where I think everyone agrees haskell excels. Haskell is good for other things too, but those things can often also be really nicely done in other languages
04:50:47 <mikeplus64> I am a noob at haskell: how would I go about "monitoring" a file (say every few seconds) to check if it has changed to something, and performing a task if so?
04:50:48 <merijn> I don't even know abap :x
04:51:22 <edcaceres> is sap especific prog language
04:51:26 <merijn> mikeplus64: Do you need a hard timer or is "approximately" every N seconds close enough?
04:51:39 <derdon> mikeplus64: watch out for an inotify package, if something like that exists ;)
04:51:39 <mikeplus64> merijn: approximately every N seconds is close enough
04:52:10 <mikeplus64> derdon: yeah there are ways I can do this without haskell or effort (and I have :)) but I just want to know how I would
04:52:17 <merijn> mikeplus64: I would just spawn a thread and do "sleep; check" for simple things. If you need something fancier probably inotify
04:52:35 <mikeplus64> alright
04:52:41 <merijn> mikeplus64: I think he means use haskell inotify bindings :p
04:52:42 <derdon> mikeplus64: "without haskell"? it would be *with* haskell
04:52:49 <derdon> merijn: yup
04:53:02 <mikeplus64> and now to jump into a vat of boiling IO :D
04:54:53 <merijn> edcaceres: I would personally use Haskell for almost everything except OS code (for which we have C, of course). If you only know something like Java I also think learning Haskell (or any significantly different language) will also help you program better (though I must admit if you're not used to learning new languages it can take quite a bit of effort to learn haskell)
04:56:33 <derdon> oh no, effort! better not learn new things then! </irony>
04:57:02 <edcaceres> no is good, im going to learn it, thats my hobby, i already learn ruby, perl, python
04:57:47 <merijn> I can recommend the book "Learn You a Haskell"
04:57:59 <merijn> It's available online for free
04:58:01 <merijn> @where lyah
04:58:02 <lambdabot> http://www.learnyouahaskell.com/
04:58:36 <edcaceres> oh nice, thank you
04:59:43 <psysine> is there any book using haskell to teach somewhat advanced computer science, that maybe a bit like sicp (the wizard book), and that has difficult and abstract exercises?
05:00:08 <merijn> psysine: Not yet, I think
05:00:24 <merijn> Plenty of papers, though (of course those don't have exercises)
05:00:36 <hpc> the wikibook has some exercises
05:00:41 <derdon> psysine: there is also "Real World Haskell"
05:00:44 <Axman6> psysine: there's a tutorial teaching you to write a scheme compiler in 48 hours
05:00:46 <hpc> lyah has a few i think
05:00:58 <merijn> Derander: That is teaching practical haskell, not advanced CS
05:01:03 <merijn> s/Derander/derdon
05:01:13 <psysine> merijn,  can you point me to some interesting paper?
05:01:23 <merijn> Unless I misunderstood he wants to learn theoretical CS (using haskell)
05:01:30 <psysine> derdon, that one is so booring....
05:01:31 <earthy> psysine: there is 'The Haskell road to logic, maths and programming'
05:01:43 <derdon> merijn: I wasn't sure, so I just mentioned it
05:02:03 <psysine> earthy, that sounds interesting
05:02:26 <merijn> psysine: "Monads for functional programming" by Wadler, "A tutorial on the universality and expressiveness of fold" by Hutton, "Generalising Monads to Arrows" by Hughes
05:02:28 <earthy> but it's somewhat introductory. :)
05:03:01 <psysine> merijn, those sound really cool
05:03:03 <merijn> Those are still fairly easy papers about FP, if you want harder you can try asking in a few hours when more of our US theoretical friends are online. They can drown you in papers no problem :p
05:03:04 <psysine> thanks everyone!
05:03:17 <psysine> hehe
05:04:28 <psysine> is there any book just teaching haskell that is a bit more condensed that real world haskell?
05:05:02 <merijn> Also interesting, but not directly using haskell and assuming some knowledge of lambda calculus: "Introduction to Generalized Type Systems" by Barendregt, "Inductive Families" by Dybjer and "An Extended Calculus of Constructions" by Luo
05:05:09 <psysine> where i can see the beauty of functional programming as compared to imperative programmer more quickly :)
05:05:35 <merijn> psysine: "A Gentle Introduction to Haskell" is fairly condensed, but doesn't really compare with imperative programming
05:05:43 <psysine> ok
05:06:02 <psysine> thanks
05:06:28 <hpaste> Steve pasted “Lynchrel” at http://hpaste.org/49973
05:06:30 <merijn> But, as someone said
05:06:36 <merijn> <Brend> Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
05:06:47 <merijn> @remember Brend Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
05:06:47 <lambdabot> It is stored.
05:07:16 <psysine> hehe
05:09:00 <psysine> a gentle introduction seems a bit old, might that pose any problem?
05:09:16 <merijn> Naah, almost all of it is still correct
05:09:59 <psysine> hmm, why does it call scheme an "almost fuctional" language? what's nonfunctional about scheme?
05:10:10 <merijn> psysine: Not referentially transparent
05:10:50 * psysine checks that up
05:11:11 <merijn> Referentially transparent means that if I call a function with the same arguments I will always get the same value back
05:11:26 <merijn> In Scheme you have mutable variables, so that is not always true
05:12:09 <merijn> Imagine a function "if globalVar then A else B" in Haskell this will always return the same thing since globalVar can't change. In Scheme globalVar could change
05:12:27 <frerich> merijn: I thought that referentially transparent means that you can replace a function invocation with it's implementation and have the same effect, but now I realize that's probably the same thing.
05:12:36 <psysine> so it's closely related to the concept of "pure code"?
05:12:37 <merijn> frerich: Well, yes
05:12:55 <merijn> frerich: But you can't do that unless any invocation with the same arguments always return the same thing ;p
05:13:11 <merijn> Potato, potahto :p
05:13:29 <merijn> psysine: That pure is usually used to mean referentially transparent, yes
05:13:41 <Axman6> can someone explain the purpose (and hopefully usage) of showsPrec?
05:13:41 <psysine> ok :)
05:14:13 <Axman6> i'm writing a show instance for a propositional logic type, and i've been advised that showsPrec is a good way to do this
05:14:34 <Axman6> actually, maybe i lie...
05:14:54 <Axman6> anyway, my current implementation isn't very good :(
05:16:12 <Axman6> hmm, i seem to have made it better. never mind me!
05:17:11 <Botje> showsPrec is for 1) avoiding the O(n^2) append problem 2) intelligently adding parentheses
05:17:23 <kmc> psysine, merijn, i wouldn't describe Scheme as "almost functional"
05:17:48 <Axman6> yeah, i was trying to avoid too many parens, but i have no idea how to use it to do that
05:17:59 <kmc> it's inconsistent with how that word is usually used
05:18:19 <kmc> Haskell has unsafePerformIO too
05:18:39 <merijn> kmc: I agree, but the apparently the Gentle Introduction calls it that
05:18:41 <kmc> Haskell's "purity" is really a matter of community norms, not a technical feature
05:18:43 <kmc> *nod*
05:19:12 <merijn> I'm in favor of unsafePerformIO being renamed to either simonSaysPerformIO or hereBeDragons :>
05:21:08 <Axman6> some people like dragons
05:21:15 <Axman6> and everyone likes simons
05:21:18 <merijn> Ay
05:21:34 <Axman6> no one really likes unsafe, and no one should like IO :P
05:23:22 <increpare> I make games.  I love IO.
05:24:00 <merijn> Carmack likes him some Haskell too, apparently
05:25:07 <Botje> so does epic's tim sweeney
05:25:19 <kmc> i love imperative programming in haskell
05:25:21 <increpare> But neither of them use it for games.
05:25:41 <merijn> kmc: I know, it's like python, but faster :>
05:25:53 <kmc> it's like python but i can abstract things
05:26:06 <kmc> also a nice threading model instead of one that punches you in the balls
05:26:17 <kmc> also lots of people like "unsafe"
05:26:23 <kmc> talk to the C macho assholes
05:26:30 <kmc> it's fine because they don't make any mistakes, you see
05:26:34 <merijn> Hah!
05:26:35 <kmc> only bad programmers make mistakes.
05:26:36 <kmc> bbl
05:26:40 <increpare> it's not a matter of testosterone, it's a matter of usefulness
05:26:46 <merijn> I just spend 6 days debugging races conditions in threaded C code
05:26:57 <merijn> Screw that shit >.>
05:27:13 <merijn> Gimme Haskell any day :p
05:27:13 <Botje> merijn: .. so you rewrote it in haskell? :)
05:27:15 <increpare> I spent a week tracking down time leaks in a game prototype
05:27:15 <Axman6> sounds like you need some STM!
05:27:25 <merijn> Botje: I actually started that, yeah.
05:27:45 <merijn> But not enough time left in my master project to rewrite everything. Also my supervisor doesn't like that idea :p
05:29:13 <dankna> grah
05:29:21 <dankna> "Cycle in type synonym declarations."
05:29:25 <dankna> bad TH, bad
05:31:23 <dankna> ah, known limitation of TH, found the ticket.  ugh?
05:40:10 <merijn> dankna: Hah! Time for me to bug you again, did you ever get your cabal extensions/Te stuff to build under OSX? :p
05:41:55 <dankna> merijn: thank you for the reminder, but alas!  I did not; I have been focusing on speech-synthesizer stuff for my "work" project and dimensioned quantities for my "play" one.
05:42:15 <dankna> when speech-syn winds down in a couple months it'll be back to Te stuff
05:42:35 <dankna> I prioritize projects based on how much commercial potential I think they have, cause I'm poor ><
05:42:48 <merijn> :p
05:42:56 <merijn> MOP ;)
05:42:58 <dankna> I appreciate your interest though
05:43:01 <merijn> Money Oriented Programming
05:43:04 <dankna> yes, haha
05:45:20 <hpaste> harlekin pasted “readProcess with binary data” at http://hpaste.org/49974
05:45:42 <merijn> dankna: Looking for something to hack on once I'm done with my project, but having to first fix some cabal extensions before starting is a bit daunting :p
05:45:52 <dankna> I understand, yes
05:45:53 <dankna> well
05:46:06 <dankna> how soon do you expect that will be?  I could spare some time to fix the extensions
05:46:13 <harlekin> Hi. I'm trying to read the stdout of a programm outputing a PNG image with Haskell. A test program doesn't behave as expected, see http://hpaste.org/49974. Why is that and what would be the correct approach?
05:46:43 <merijn> My project should officially be done this week, but I expected somewhere in the coming 2-3 weeks
05:47:00 <quicksilver> harlekin: readProcess is assuming UTF8 input.
05:47:10 <dankna> also he doesn't want to show the output, does he?
05:47:29 <Botje> harlekin: you should use bytestrings if you really want strings of binary bytes
05:47:31 <dankna> merijn: so in other words you have 1-2 weeks of time for working on this?
05:48:02 <quicksilver> dankna: well 'show'ing the output is a reasonable way to display ugly binary data without currupting your terminal
05:48:06 <quicksilver> if you just want to test it works.
05:48:23 <dankna> no, my understanding of his question was that he wanted to use the output as binary input to something else
05:48:35 <dankna> perhaps I misunderstood, but.
05:48:35 <harlekin> quicksilver: That is because the System.IO functions assume UTF-8 data?
05:48:42 <quicksilver> my understanding was that the putStrLn show part was just for testing
05:48:59 <dankna> well, we have him here to ask :)
05:49:15 <quicksilver> harlekin: sort of, but not exactly.
05:49:43 <harlekin> quicksilver: What would be the right functions to read binary data into a String, ByteString, [Word8] or something?
05:50:00 <Botje> ByteString
05:50:13 <quicksilver> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#g:23
05:50:14 <Botje> since [] have the unfortunate tendency to blow up immensely
05:50:15 <merijn> danka: No, I'll have time to hack on this 2-3 weeks from now (since I'll be jobless and close enough to graduating that I don't have much university stuff to occupy me :p) so I need something to work on while jobhunting ;)
05:50:31 <quicksilver> harlekin: the System.IO functions can choose which encoding they use, see the link I pasted.
05:50:42 <dankna> merijn: oh, gotcha :) well, that gives me a looser deadline
05:50:50 <quicksilver> but System.Process.readProcess is a shortcut which doesn't give access to this functionality.
05:51:23 <harlekin> quicksilver: thank you very much. :)
05:51:50 <merijn> dankna: So I'm just providing some peer pressure to stop you from slacking off ;)
05:51:50 <quicksilver> runInteractice{Command,Process} both give you a binary mode file handle
05:51:53 <quicksilver> from which you can read bytes.
05:51:55 <dankna> merijn: appreciated :D
06:03:31 <ksf> how was that package called that automatically derives guis from adts?
06:07:31 <Botje> ruby on rails?
06:10:47 <ksf> I think I meant autoforms, but it's wx and bitrotted
06:11:42 <ksf> there's sybwidget and datatreeview, though.
06:16:35 <Phyx-> Morning
06:17:06 <Phyx-> Quick question, a bug in cabal sdist prevents me from using it to make a tar, if i just make my own will upload find it? or does sdist make a config somewhere?
06:18:01 <mauke> download sample tar from hackage, unpack, compare to your own
06:18:14 <mauke> my guess: no hidden magic
06:18:35 <mauke> oh wait, you want automatic uploading
06:19:32 <Phyx-> what i meant was, does cabal sdist put something cabal uploads needs in the dist directory.
06:20:00 <mauke> yeah, I always upload via browser so I didn't think of that
06:20:24 <Phyx-> oh, wasn't aware you could do that. I'll do that then
06:20:52 <Phyx-> the bug in sdist is that it does not get passed the list of custom preprocessors, only the default ones. took a peek at the source to verify it
06:21:16 <Phyx-> whoops, g2g,
06:30:20 * hackagebot acid-state 0.5.0 - Add ACID guarantees to any serializable Haskell data structure.  http://hackage.haskell.org/package/acid-state-0.5.0 (DavidHimmelstrup)
06:47:25 <jonkri> my library exposes a concurrent api through a session object (wrapping a Chan). i'm thinking about what should happen if the library crashes for some reason. would it be suitable to throwTo all client threads to notify them of the crash?
06:47:51 <kmc> why might it crash?
06:48:09 <kmc> can you restart instead?
06:48:17 <jonkri> it shouldn't, but i read somewhere that if a client crashes due to some error it's preferrable to let the whole application crash
06:48:27 <merijn> jonkri: Depends
06:48:39 <merijn> Libraries should *NEVER* decide for me whether it is ok to crash
06:48:59 <merijn> The library's user should be in control of when an application crashes
06:49:06 <kmc> if you can't articulate a scenario where your library's threads crash, then don't worry about it
06:49:51 <dainanaki> Does anyone know if the GHC API provides the ability to access the RTS's profiling facilities? I'd like to access cost-centre information while a given program is still running.
06:50:03 <jonkri> i don't think restarting the library would work. that would most likely mean restarting the whole xmpp session. nice idea though
06:50:07 <jonkri> yeah, ok :)
06:54:21 <dainanaki> So, no API for profiling then? Just command line options?
06:54:49 <kmc> don't know of an API
06:55:00 <kmc> you can call RTS functions through the FFI
06:56:07 <dainanaki> the rts is in C?
06:56:14 <merijn> dainanaki: Parts of it
06:56:43 <kmc> C and Cmm, yes
06:56:50 <kmc> check out a GHC source tree and go digging :)
06:57:06 <dainanaki> yeah, that's what I figured I'd have to do.
06:57:43 <kmc> good luck
06:57:43 <kmc> bbl
07:19:24 <pommes_> what's wrong with my checkLynchrel function? http://hpaste.org/49973
07:19:49 <dainanaki> line 32
07:20:00 <dainanaki> you only partially applied the checkLynchrel function
07:20:32 <dainanaki> you need a second numeric argument
07:22:02 <pommes_> yes, you are right, sometimes I am blind, thx
07:46:52 <sheyll> hi
08:03:43 <bscarlet> sheyll: hi
08:05:24 <dainanaki> Compiling the qt bindings for Haskell takes a lot of memory!
08:06:05 <bscarlet> what is "a lot of memory"?
08:06:27 <dainanaki> currently 2/3 done and GHC is using 1.7GB
08:07:34 <bearophile> OK, I'll ask here too. I have written my longest Haskell program so far, but it's kind of my first program in this language. Is someone willing to take a look at it and give any kind of suggestion?
08:07:46 <bearophile> This is the original Python version: http://ideone.com/kRcfP
08:07:57 <bearophile> The Haskell version: http://ideone.com/OURJ6
08:08:12 <bearophile> The program solves a game. (The Haskell program works and it seems efficient enough)
08:08:53 <bearophile> But it looks badly even to my untrained eye
08:09:01 <quicksilver> bearophile: the construction "else more\n    where more =" seems wasteful
08:09:15 <quicksilver> bearophile: why name something you only use once, and put the definition immediately next to the use?
08:09:19 <copumpkin> you use last and elem a lot
08:09:39 <ClaudiusMaximus> is_solution (1,1) = True; is_solution _ = False  -- perhaps clearer
08:09:53 <dainanaki> but wrong
08:09:57 <Jeanne-Kamikaze> indeed
08:10:00 <dainanaki> it's an or statement
08:10:03 <ClaudiusMaximus> oops
08:10:04 <osfameron> quicksilver: to document what the expression is for, perhaps?
08:10:14 <copumpkin> the pour could be done nicely with pattern matching
08:10:19 * ClaudiusMaximus need more coffee
08:10:20 <copumpkin> at least some of it
08:10:24 <Jeanne-Kamikaze> :)
08:10:27 <quicksilver> osfameron: perhaps, but 'more' is not much documentation. Use a comment for that if you want to  :)
08:10:35 <bearophile> Don't supposed I am doing something smart, I have found something that works almost by trial and error :-)
08:11:18 <bearophile> the construction "else more\n where more =" seems wasteful : I don't know another way to write it
08:11:58 <benmachine> bearophile: if you put your code on hpaste.org, then hlint will give you suggestions
08:12:01 <benmachine> http://hpaste.org/
08:12:22 <bearophile> copumpkin: if you take a look at the original Python code, it uses "yield" in pour, but I didn't know how to do the same :-(
08:12:37 <bearophile> benmachine: OK
08:13:34 <quicksilver> bearophile: just put the entire code where the more is
08:13:40 <bearophile> Wow :-) http://hpaste.org/49976
08:14:02 <quicksilver> bearophile: instead of "else more \n where more = foo bar baz" just write "else foo bar baz"
08:14:26 <bearophile> quicksilver: Isn't this like a bit long?  if (is_solution (last sol)) then [sol] else concat [back (sol ++ [next]) a b | next <- pour (last sol) a b, not (elem next sol)]
08:14:30 <bearophile> line
08:14:47 <benmachine> bearophile: you can break it
08:14:51 <benmachine> you just have to get the indentation right
08:15:03 <benmachine> er, actually you don't
08:15:07 <benmachine> it just needs to be indented at all
08:15:14 <quicksilver> bearophile: just break the line wherever looks good to you
08:15:29 <quicksilver> bearophile: I would personally break after then, and put else on a line on its own
08:15:34 <bearophile> I see. In languages I know people to use auxiliary variables (like more) when expressions are huge...
08:15:35 <quicksilver> but it's your call.
08:15:41 <bearophile> OK
08:15:53 <ClaudiusMaximus> hm, would it actually make more sense to build the lists in the other direction - instead of last and ++[next] do head and next:
08:16:21 <dainanaki> yeah, you're taking most efficiency hits by using the list in the wrong direction
08:17:49 <bearophile> I see. I was not thinking about efficiency, indeed. Sorry.
08:18:00 <zygoloid> bearophile: does the order of results from pour matter?
08:18:12 <bearophile> It doesn't matter
08:18:31 <bearophile> It's just the alternative branches in a dumb backtracking algorithm
08:18:55 <bearophile> There are not heuristics implemented here, so the order doesn't matter
08:20:14 <bearophile> Do you know how to write pour better? I know a bit how to do pattern matching, but those patterns are not mutually exclusive
08:20:33 <benmachine> bearophile: I'll show you another way of writing it in a sec
08:20:48 <bearophile> OK, I am not in a rush :-)
08:21:34 <hpaste> benmachine annotated “---” with “--- (annotation)” at http://hpaste.org/49976#a49977
08:22:00 <benmachine> bearophile: http://hpaste.org/49977 this didn't turn out as well as I'd hoped
08:22:11 <benmachine> but it's an interesting idea anyway
08:22:55 <bearophile> I see. And I understand it. It's simpler
08:23:24 <benmachine> I think I can get rid of the ifs
08:23:46 <bearophile> But I like ifs :o)
08:23:58 <benmachine> (max (i + j - b) 0, min b (i + j))
08:24:32 <bearophile> An if seems more readable that this :-)
08:24:37 <benmachine> if you like
08:24:47 <quicksilver> benmachine: you could use guard instead
08:24:53 <benmachine> quicksilver: yeah, I thought about that
08:25:03 <benmachine> and hlint suggested list comprehensions
08:25:07 <benmachine> there's a few ways of doing it
08:25:14 * bearophile nods
08:25:19 <quicksilver> > guard 1 == 1 <$ (2,3) :: [(Int,Int)]
08:25:19 <lambdabot>   Precedence parsing error
08:25:20 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
08:25:30 <quicksilver> > guard (1 == 1) <$ (2,3) :: [(Int,Int)]
08:25:31 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:25:31 <lambdabot>         against inferred type ...
08:25:33 <quicksilver> bah
08:25:35 <dainanaki> So I just about got qtHaskell built, and then I got this error: http://hpaste.org/46234/qt114_build_failure_under_g?pid=46234&lang_46234=literatehaskell
08:25:36 <quicksilver> something like that :)
08:25:45 <dainanaki> does anyone have any experience with this issue?
08:25:51 <bearophile> It seems hlint hates brackets :-)
08:25:51 <benmachine> > (2,3) <$ guard (1 == 1)
08:25:52 <lambdabot>   No instance for (GHC.Show.Show (f (t, t1)))
08:25:52 <lambdabot>    arising from a use of `M7081...
08:25:53 <benmachine> there we go
08:25:57 <benmachine> oh fff
08:26:07 <benmachine> bearophile: heh, yes
08:26:32 <benmachine> > (2,3) <$ guard (1 == 1) :: [(Integer,Integer)]
08:26:33 <lambdabot>   [(2,3)]
08:26:37 <bearophile> But I don't hate them, especially in my first programs.
08:26:39 <benmachine> > (2,3) <$ guard (1 == 0) :: [(Integer,Integer)]
08:26:40 <lambdabot>   []
08:26:49 <bearophile> It works, it seems.,
08:26:50 <benmachine> bearophile: sure, don't feel obliged
08:27:02 <benmachine> we can only offer suggestions we can't tell you what to do :P
08:27:27 <bearophile> I am here for suggestions :-)
08:27:35 <bearophile> I think this is enough for now. I will try to improve the code given all the suggestions, from the lint too
08:27:43 <bearophile> Thank you. See you later.
08:28:11 <dainanaki> so, how can I work around this issue? http://hpaste.org/46234/qt114_build_failure_under_g?pid=46234&lang_46234=literatehaskell
08:28:21 * benmachine wonders if there should be a library combinator for x <$ guard p, I seem to do it a lot
08:28:27 <benmachine> and x <$ guard (p x)
08:28:33 <benmachine> (ap (<$) (guard . p)
08:28:34 <benmachine> )
08:29:35 <dainanaki> never mind, think I got it.
08:29:39 <hpaste> zygoloid annotated “---” with “--- (annotation)” at http://hpaste.org/49976#a49978
08:30:13 <zygoloid> ;( too late
08:51:37 <roconnor> Hmm
08:52:30 <roconnor> sometime between 1998 and 2010 someone added an (Ix i) prerequisate to the Functor (Array a)
08:56:00 <dainanaki> I'm getting a "ld: scattered reloc r_address too large for architecture i386" on OS X when trying to build a large library.
08:56:08 <dainanaki> What can I do?
08:56:32 <luite> hmm, 7.2.1 released?
08:56:58 <dainanaki> i'm on 7.0.3
09:02:10 <byorgey> luite: there is a release candidate but I don't think it has been released yet
09:03:22 <luite> http://www.haskell.org/ghc/dist/stable/dist/ there's a 7.2.1 here, but it's not been announced yet
09:03:35 <zygoloid> roconnor: archeology: ghc 6.6 had the Ix constraint
09:03:44 <luite> but I don't know if this is going to be the final version
09:03:44 <roconnor> :D
09:05:24 * hackagebot pastis 0.1.1 - Interface to the past.is URL shortening service  http://hackage.haskell.org/package/pastis-0.1.1 (AlpMestanogullari)
09:07:05 <luite> at least that 7.2.1 thing fixes the text build issue that I had with rc1 :)
09:08:20 <zygoloid> roconnor: the "Ix i =>" constraint is there because... data Ix i => Array i e
09:08:29 <roconnor> :O
09:08:32 <zygoloid> the instance required by the '98 report is unimplementable :)
09:08:39 <roconnor> :O:O
09:08:41 <JuanDaugherty> 7.2.1
09:09:17 <zygoloid> i have no idea why the constraint wasn't removed from Array, rather than added to the Functor instance, though
09:09:44 <roconnor> zygoloid: good sleuthing.
09:11:38 <bscarlet> zygoloid: okay, maybe I'm being naive here, but how would one implement Array without Ix?
09:12:56 <quicksilver> Array is a data type not a class
09:13:16 <quicksilver> not sure if you already realise that
09:13:28 <quicksilver> constraints on the *data type* array are not necessary
09:13:35 <quicksilver> you can just put them on any/all functions which need it.
09:13:56 <dainanaki> seems like data type constraints are usually a misfeature
09:15:10 <zygoloid> indeed, you have to put them on any/all functions whihc need it anyway :)
09:16:35 <bscarlet> Fair enough, I guess. How useful is it to leave off the constraint, then? What does it allow? I presume Map not requiring Ord is analogous.
09:16:44 <zygoloid> dainanaki: removal of this misfeature is the only difference between "haskell 2011" and haskell 2010
09:21:11 <byorgey> bscarlet: some functions, such as e.g. 'size :: Map k a -> Int', do not need an Ord constraint
09:21:51 <c_wraith> that's not really *too* useful, since constructing a Map of size > 1 requires the Ord constraint...
09:21:58 <c_wraith> But it is worth something.
09:22:13 <byorgey> bscarlet: but the main reason that leaving it off is useful is that putting it on is misleading and does almost nothing anyway.
09:22:13 <bscarlet> c_wraith: why?
09:22:56 <c_wraith> bscarlet: because Map is implemented as a binary search tree, which requires there be an ordering on the keys
09:23:16 <c_wraith> bscarlet: you can ignore that if there are only 0 or 1 keys, but once you have 2, you need the ordering.
09:23:31 <ClaudiusMaximus> :t M.singleton
09:23:31 <lambdabot> forall k a. k -> a -> M.Map k a
09:24:06 <bscarlet> c_wraith: yes. I meant why is it worth something to be able to talk about those nearly useless maps?
09:24:29 <fozze> haskell noob here: how should I go about resolving installing haskell-src-exts via cabal? https://gist.github.com/1130534
09:24:46 <c_wraith> bscarlet: because they can be created, as ClaudiusMaximus pointed out with.
09:24:47 <kmc> cabal install happy
09:25:03 <bscarlet> c_wraith: can does not imply should.
09:25:23 <c_wraith> bscarlet: well, it's not like the compiler will let you create something invalid.
09:26:08 <byorgey> fozze: cabal-install does not (yet) resolve the existence of executables required for the build process.  In this case you just need to 'cabal install happy' first.
09:26:10 <fozze> kmc: i did, but it seems to not be able to install it, sounds like a PATH issue...
09:26:30 <byorgey> fozze: can you paste the error you get?
09:26:32 <c_wraith> fozze: it installed happy in ~/.cabal/bin, probably.  add that to your path and try again
09:26:38 <fozze> byorgey: sure can
09:26:39 <bscarlet> I just don't think it's obvious that the language shouldn't allow the creator of Map or Array to decide such things as invalid.
09:27:07 <c_wraith> bscarlet: it still does allow it, just more usefully.  via GADTs or smart constructors
09:27:21 <fozze> this is after I installed happy with cabal: https://gist.github.com/1132164
09:27:45 <fozze> byorgey: i installed with sudo
09:27:58 <c_wraith> bscarlet: if you use a GADT, it actually stores the instance with the constructor, so that pattern-matching on that constructor exposes the instance without it being in the signature.  that's far better than the current situation.
09:28:19 <byorgey> fozze: installing with sudo should not be necessary
09:28:38 <fozze> byorgey: ok
09:28:39 <byorgey> fozze: and as c_wraith said, the problem is likely to be that by default cabal installs executables in ~/.cabal/bin
09:28:52 <fozze> byorgey: oh yes, i can see it there
09:29:01 <byorgey> fozze: the easiest solution is to add that directory to your $PATH
09:29:08 <bscarlet> Why shouldn't the current syntax mean the same thing (just for all constructors, I guess)?
09:29:21 <kmc> bscarlet, because the Haskell Report says it does not
09:29:32 <fozze> byorgey: gotcha, i will try that
09:29:35 <fozze> byorgey: thx
09:29:53 <bscarlet> kmc: aren't we talking about the hypothetical value of changes to the language spec?
09:30:02 <bscarlet> kmc: or at least why the spec is as it is?
09:30:11 <kmc> oh, in that case i think there's no reason
09:30:23 <ClaudiusMaximus> i prefer .cabal/config symlink-bindir: /home/claude/opt/bin  and  .profile PATH="$HOME/opt/bin:$PATH"
09:31:04 <kmc> but if we're talking about new language versions I'd prefer standardizing on GADTs as the one and only data syntax
09:31:13 <kmc> the H98 data syntax is weird and misleading
09:31:52 <mornfall> kmc: H98 is nice and concise in the simple cases though.
09:32:03 <kmc> so's perl
09:32:05 <c_wraith> It's really only misleading with record syntax.
09:32:17 <kmc> no, i think it's worse than that
09:32:21 <c_wraith> oh, really?
09:32:32 <c_wraith> I thought record syntax was bad enough. >_>
09:32:34 <kmc> for the most part Haskell syntax makes it clear which things are values and which are types
09:32:45 <kmc> but "data" syntax doesn't
09:32:45 <c_wraith> Ah, I see.
09:32:52 <kmc> "data Foo = Bar (Baz Quux)"
09:32:55 <c_wraith> that's the one place where you mix values and types
09:33:01 <c_wraith> after the equals
09:33:02 <kmc> how are you to know that Bar is a value and the rest are types?
09:33:23 <c_wraith> and GADT syntax certainly clears that up.
09:33:28 <shachaf> Also the newtype syntax. :-)
09:33:29 <kmc> this confuses beginners often
09:33:38 <shachaf> kmc: Do you propose GADT syntax for newtypes too?
09:33:40 <mornfall> newtype is evil yes :D
09:33:49 <shachaf> newtype is the opposite of evil.
09:33:55 <shachaf> Its syntax might be a little evil, though.
09:33:58 <kmc> coevil?
09:34:01 * shachaf 's not made his mind up on that.
09:34:03 <kmc> but yeah, GADT syntax is a bit verbose
09:35:01 * shachaf wonders how GADT syntax works with record syntax.
09:35:07 <c_wraith> there's an extension in GHC 7.2 that allows GADT syntax without enabling GADTs
09:35:15 <c_wraith> that seems a bit silly to me...
09:35:26 <shachaf> Oh, I see.
09:35:27 <c_wraith> But maybe it'll make compiling faster if people want to use GADT syntax
09:36:20 <kmc> i think the main point is to avoid gratuitous deviations from Haskell's type system
09:36:33 <shachaf> Hmm, GADT syntax with record syntax looks like data Foo where { Bar { x :: Int, y :: Char } :: Foo }
09:36:34 <kmc> recall that in GHC 7, GADTs implies MonoLocalBinds
09:36:38 <shachaf> No ->s.
09:37:38 <wolverian> what does a lambdabot passwd.rc look like?
09:37:47 <shachaf> I wonder whether that :: Foo is really necessary in that case?
09:37:49 <kmc> making GADTs the default would probably lead to even more abuse of existentials in favor of simpler approaches
09:37:59 <kmc> shachaf, you might still have type arguments
09:38:11 <kmc> data Foo t where { Bar { x :: Int } :: Foo Char }
09:38:23 <shachaf> kmc: True, but it could be implicit in every case that the normal data syntax is implicit.
09:38:24 <jocom> Are there clear advantages of GADTs?
09:38:40 <c_wraith> jocom: they're strictly more expressive
09:38:52 <jocom> Ok
09:38:56 <kmc> they allow you to embed more correctness properties into your types
09:39:00 <c_wraith> jocom: after all, that's what the G in there means.  *Generalized*. :)
09:39:11 <shachaf> data Bool where { False; True } isn't so bad.
09:39:14 <jocom> ok... (-;þ
09:39:37 <kmc> for example "typed syntax"
09:40:09 <shachaf> If the {}-style syntax was allowed even for non-records, it could be a substitute for the regular data syntax completely, maybe.
09:40:14 <kmc> if you're writing a compiler or some other tool that manipulates programs
09:40:30 <shachaf> data Maybe a where { Nothing; Just { a } } -- Or something.
09:40:42 <kmc> you can prove that your compiler respects the type system of the language you're compiling
09:41:26 <jocom> Still I would regret moving away from ->s
09:41:33 <kmc> hmm?
09:41:38 <kmc> the normal GADT syntax has them
09:42:00 <kmc> data Maybe t where { Just :: t -> Maybe t; Nothing :: Maybe t }
09:42:20 <jocom> Ok
09:42:39 <kmc> and the standard Haskell (non-GADT) syntax doesn't
09:42:43 <shachaf> jocom: The syntax I used there isn't actually valid. :-)
09:42:45 <kmc> data Maybe t = Just t | Nothing
09:42:51 * jocom goes away to read another bunch of pages
09:42:55 * shachaf wonders if there are any disadvantages to it, though.
09:43:33 <jocom> Hmmz, but the standard syntax is way more concise and comprehendable in my eyes
09:43:47 <edwardk> jocom: it is for most cases
09:43:59 <shachaf> jocom: It also has a weird mixture of types and values, as kmc never fails to point out.
09:44:26 <shachaf> I think that people frequently become confused when first seeing it.
09:44:44 <shachaf> Particularly with collisions between the data constructor name and the type constructor name.
09:44:58 <kmc> data Foo = Bar Baz; data Bar = Foo Baz
09:45:06 <shachaf> @slap kmc
09:45:06 * lambdabot jabs kmc with a C pointer
09:45:18 <shachaf> Take that. It was probably NULL, too.
09:45:30 <jocom> Ouch
09:45:47 <EvanR7> shachaf: worse, it was not null but invalid anyway
09:45:55 * jocom is getting the point though. Bows humbly in front of kmc 
09:46:07 <kmc> yes that's worse
09:46:14 <jocom> I guess lambdabots jab had side-effect anyhow
09:46:21 <EvanR7> like an anthrax coated dagger
09:46:25 <kmc> it was an ERR_PTR
09:46:25 <shachaf> kmc isn't the kind to dereference random pointer from IRC, though.
09:46:39 <DukeDave> Hi all, I'd like to do a Data.Map.mapWithKey, except the function I'm mapping uses Reader
09:46:54 <kmc> :t runReader
09:46:55 <lambdabot> forall r a. Reader r a -> r -> a
09:47:14 <shachaf> @ty id -- Monad (r ->)
09:47:15 <lambdabot> forall a. a -> a
09:47:28 <DukeDave> Is there a way I can lift mapWithKey to return a (Reader (Map k b))
09:47:52 <kmc> what's the type you want?
09:48:09 <wolverian> hrm. lambdabot doesn't want to start: the rc command fails on openFile: does not exist every time. yes, the file does exist.
09:48:29 <bscarlet> DukeDave: perhaps you want Data.Traversable.sequence
09:50:24 * hackagebot trifecta 0.9 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.9 (EdwardKmett)
09:50:44 <hatds> so newtype wrapping/unwrapping has no runtime cost, but what happens if you 'map unwrap' some list of newtype'd values?
09:51:02 <kmc> no guarantees
09:51:06 <shachaf> hatds: It'll turn into "map id".
09:51:15 <shachaf> No guarantees about it, yes.
09:51:22 <shachaf> If you want guarantees you can use unsafeCoerce.
09:51:24 <kmc> with GHC you can read the Core output
09:51:27 * shachaf is never typing *that* sentence again.
09:51:29 <kmc> shachaf, how ironic
09:51:42 <kmc> GHC actually does say that this is a safe use of unsafeCoerce
09:52:13 <shachaf> Is it possible to make a type-safe sort of unsafeCoerce for this sort of thing?
09:52:28 <DukeDave> bscarlet: Aha, thanks,
09:52:32 <EvanR7> Typeable?
09:52:33 <Saizan> http://hackage.haskell.org/packages/archive/intern/0.5.1.1/doc/html/src/Data-Interned-Internal-String.html <- how does the definition of identify make sense here?
09:52:40 <hatds> define a "class Newtype" maybe?
09:52:54 <Saizan> oh, one is identify the other identity
09:53:14 <kmc> Typeable won't help unless you lie in one of the instances, which is bad bad bad bad
09:53:20 <shachaf> You read the scroll labeled VELOX NEB. It's a scroll of identity! --More--
09:53:39 * EvanR7 thinks of maude
09:53:42 <Botje> shachaf: *G*
09:54:05 <byorgey> there already is a 'class Newtype' in the newtype package
09:54:08 <byorgey> @hackage newtype
09:54:09 <lambdabot> http://hackage.haskell.org/package/newtype
09:54:15 * byorgey <3 Newtype
09:54:28 <copumpkin> I still want type families for it :)
09:54:42 <copumpkin> screw broken GHCs
09:54:50 <shachaf> Botje: "*G*"?
09:54:57 <hatds> ah so Conor did implement the idea, I was reading about it recently
09:55:05 <copumpkin> hatds: djahandarie did
09:55:14 <shachaf> There should be a Haskell compiler that isn't GHC.
09:55:24 <byorgey> shachaf: um
09:55:32 <hatds> copumpkin: oh, I see
09:55:39 <shachaf> That's actually useful and/or used.
09:55:52 <byorgey> shachaf: UHC seems rather nice
09:55:58 <Botje> shachaf: *giggle*
09:56:28 <shachaf> Ah.
09:56:28 <hpaste> eyeris pasted “Intertwining effects” at http://hpaste.org/49980
09:57:03 <edwardk> saizan: hah yeah the names are pretty close
09:57:18 <edwardk> i did it deliberately to help myself but i can see how they get confused at first glance
09:57:26 <eyeris> Could someone take a look at my paste and tell me how you would write that in a declarative way?
09:58:01 <edwardk> saizan: identify adds an identity, identity asks for it back
09:58:36 <edwardk> shachaf: there have been tons, but they don't keep up
10:00:40 <wolverian> hrm. 'cabal info lambdabot' says 'Not Installed' right after installing it.
10:00:55 <wolverian> I do not see any fatal errors, and the binary is there, and works. weird.
10:01:16 <ClaudiusMaximus> cabal only knows about installed libraries, is my guess
10:01:33 <wolverian> that might be.
10:04:23 <byorgey> it is.
10:05:11 <Saizan> edwardk: the funny part is that i even stared at it for quite a while being sure the names had to differ but couldn't see it
10:05:12 <edwardk> ClaudiusMaximus: it does know some executables. iirc it tracks happy, etc.
10:05:17 <edwardk> =)
10:05:38 <edwardk> saizan: the trifecta code uses intern a fair bit if you want more examples
10:06:06 <edwardk> i currntly intern 'paths' and 'hunks
10:06:46 <edwardk> though i need to write a more efficient path prefix checker, right now its linear, and it could be log n
10:16:24 <wolverian> hrm. now running '> 1+1' in the lambdabot console gives me 'Could not find module ShowIO'
10:16:33 <wolverian> lambdabot: how do I show web
10:16:42 <wolverian> erghm. typoed the meme.
10:18:43 <wolverian> would have tested the darcs version, but it requires mtl>2 and mueval requires mtl<1.2
10:18:48 <wolverian> giving up. :)
10:19:13 <wolverian> would the lambdabot admins want to run lambdabot on ircnet/#lambda?
10:22:24 <joe6> i want to add haskell ffi bindings to C macros? is that possible? ppdev.h: http://pastebin.com/V70kJZiW <-- file that I am trying to add haskell bindings for.
10:22:26 <mauke> The paste V70kJZiW has been copied to http://hpaste.org/49984
10:23:14 <NS_tech> where can i find some Haskell self teaching material?
10:23:27 <Polarina> NS_tech: http://learnyouahaskell.com/
10:23:33 <joe6> NS_tech: google "learn you a haskell"
10:23:43 <EvanR7> if we told you it wouldnt be self teaching
10:24:08 <ClaudiusMaximus> joe6: possible, look at hsc2hs, bindings-dsl, ...
10:24:33 <ClaudiusMaximus> joe6: that header looks easy enough, as all the #define are just constants
10:24:46 <joe6> ClaudiusMaximus: checked out hsc2hs, but, was not sure of how to do the bindings for macros.
10:24:55 <joe6> ClaudiusMaximus: the constants are macros.
10:25:01 <ezyang> Is 'block' and 'unblock' (in Haskell's exception handling) considered to be a good idea or not?
10:25:11 <ezyang> *to have been
10:25:35 <ClaudiusMaximus> joe6: #const MACRONAME  or similar, iirc
10:25:53 <joe6> ClaudiusMaximus: oh, really.
10:26:47 <ClaudiusMaximus> joe6: yep, gl_LINEAR = #const GL_LINEAR     -- actual code example
10:33:17 <benmachine> ezyang: superseded by mask
10:33:41 <benmachine> block/unblock wasn't really satisfactory but it was the best you could do
10:35:51 <ezyang> benmachine: Ah yes, good catch!
10:36:08 <ezyang> I re-state my question for mask/restore
10:37:08 <singpoly1a> is there a "fallthrough" in haskell pattern matching?  Ie: is there a better way to write this: http://pastie.org/2340546
10:37:18 <benmachine> ezyang: do you mean "is blocking async exceptions a good idea", or "is mask/restore a good way to block async exceptions"?
10:37:41 <janiczek> hi guys, is here anyone of you to whom I sent the haskell code that beat my c++ in regex parsing few days ago? :)
10:37:46 <joe6> ClaudiusMaximus: thanks. It works.
10:38:14 <bscarlet> janiczek: yes. How's the PCRE go? Any luck?
10:38:35 <janiczek> bscarlet: http://pastie.org/2340554
10:39:20 <bscarlet> Hmm. Care to show your C++?
10:39:41 <ezyang> benmachine: Both, I think.
10:39:41 <edwardk> singpoly: _ | val `elem` [1..3] -> val + 1
10:39:57 <ezyang> I see why mask/restore is a better way than block/unblock
10:40:04 <janiczek> sure thing, wait a moment
10:40:06 <singpoly1a> edwardk: Sure, I guess elem on a list is a bit cleaner
10:40:18 <janiczek> bscarlet: the pcre one?
10:40:19 <ezyang> Has it mostly been sufficient? And has masking exceptions worked OK, or had sort of fundamental problems?
10:40:36 <ezyang> (I must admit, I don't deal with it very much, but it seems to have quite a complicated semantics.)
10:40:36 <bscarlet> janiczek: Yes.
10:40:57 <joe6> how do i get rid of these warnings: http://pastebin.com/FtByMmqg
10:40:59 <mauke> The paste FtByMmqg has been copied to http://hpaste.org/49985
10:41:07 <janiczek> bscarlet: here you are: http://pastie.org/2340567
10:41:08 <joe6>  Warning: -#include and INCLUDE pragmas are deprecated: They no longer have any effect
10:41:25 <copumpkin> joe6: you just write #include and use {-# LANGUAGE CPP #-}
10:41:49 <ClaudiusMaximus> copumpkin: this is from hsc2hs i think
10:41:52 <copumpkin> oh
10:41:56 * copumpkin doesn't know then
10:42:13 <ClaudiusMaximus> i guess hsc2hs could be modified to fix it
10:42:33 <joe6> PpDev.hsc: http://pastebin.com/dWkH46Py
10:42:35 <mauke> The paste dWkH46Py has been copied to http://hpaste.org/49986
10:42:42 <joe6> yes, it is from the hsc2hs
10:45:26 * hackagebot trifecta 0.10 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.10 (EdwardKmett)
10:51:49 <bscarlet> janiczek: Is the v8 result new?
10:52:19 <janiczek> well yeah, along with perl it showed up today
10:52:25 <janiczek> oh, I forgot about the perl completely
10:52:29 <janiczek> should time it too :)
10:52:42 <bscarlet> How many trials are you running for these timing tests?
10:53:18 <janiczek> I usually try two or three times to see that the "ranks" don't change
10:53:54 <janiczek> anyways, the javascript totally owned us :)
10:55:44 <janiczek> or, at least, the v8 engine under it.
10:56:53 <bscarlet> yep. :-)
10:57:10 <bscarlet> Have you tried bash/egrep?
10:58:52 <janiczek> wow, making a shell script for all that? :) didn't try, no. do you think the unix regex tools will do a better job? :)
11:00:01 <bscarlet> janiczek: at least one page I looked at comparing regex implementations showed egrep as quite competitive. It's very much a specialist.
11:01:40 <bscarlet> Is your test machine any sort of SMP? In bash it'd be very easy to run egreps in ||. You could even use make -j n to limit the number running at once if you wanted to be cute about it.
11:04:58 <bscarlet> Anyway, to focus on the Haskell side of things, now that you're using the same library as the Haskell version, my best guess as to the source of the differences would be Haskell's superior heap management - but that's a fairly uneducated guess on the Haskell side. When you get into the details of what happens in using C++ strings, for instance, it can be remarkably frustrating how hard it is to get C++ not to do something stupid like extraneous copies.
11:05:00 <bscarlet> You're likely paying to deallocate/reallocate your string body for each line, for instance.
11:05:36 <bscarlet> With GHC those allocations will be much cheaper.
11:06:24 <psysine> when i define an infix operator, what will its precedence be? can i set it myself?
11:07:42 <burp> sure, with infixl
11:07:51 <saati> infixr/infixl value operator
11:08:01 <psysine> ah
11:08:09 <psysine> but, what's the default?
11:08:31 <burp> you can find out in ghci with :info
11:08:42 <janiczek> bscarlet: sorry, was afk. SMP - I don't know about that. Macbook probably won't be SMP, huh? :) Anyways, all the other programs run single-core, so I wouldn't cheat ... :) or maybe the V8 is secretly cheating under the hood! :) and about that C++ extraneous copying - yeah, I'm probably paying some overhead in exchange for relatively easy way to write the code (for me)...
11:08:56 <bscarlet> psysine: 9
11:09:20 <psysine> burp, it doesn't show
11:09:25 <psysine> bscarlet, thanks
11:09:36 <luite> hmm, aeson doesn't build with 7.2.1
11:09:38 <bscarlet> psysine: http://www.haskell.org/onlinereport/decls.html#fixity
11:09:46 <burp> psysine: hm, no? :info (+) does for me, for example
11:10:48 <psysine> burp, it doesn't for the one i defines myself without specifying fixity
11:11:02 <burp> psysine: oh, ok
11:13:20 <psysine> how to define a function in ghci if it needs several "cases"
11:13:21 <psysine> ?
11:13:41 <NihilistDandy> edwardk: Are you around and not overly busy?
11:15:34 <fozze> @help irc-connet
11:15:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:15:38 <fozze> @help irc-connect
11:15:38 <lambdabot> irc-connect tag host portnum nickname userinfo.  connect to an irc server
11:16:14 <fozze> @list
11:16:14 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:16:49 <fozze> @help passwd
11:16:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:23:36 <tommd> luite: There's a large list of packages that don't build on 7.2.x (GHC ML has it, I think)
11:31:58 <joe6> @hoogle ord
11:31:59 <lambdabot> Data.Char ord :: Char -> Int
11:31:59 <lambdabot> module Data.Ord
11:31:59 <lambdabot> Prelude class Eq a => Ord a
11:32:24 <psysine> why doesn't "1 `(+)` 1" work?
11:32:58 <shachaf> psysine: `` only works on identifiers, not arbitrary expressions.
11:33:08 <psysine> oh
11:33:16 <psysine> thansk
11:33:20 <shachaf> A more serious complaint would be that (`foo`) is invalid.
11:33:25 * shachaf is annoyed at that.
11:33:34 <ion> > (`elem` [2..4]) 3
11:33:35 <lambdabot>   True
11:33:48 <shachaf> @ty (`elem`)
11:33:49 <lambdabot> parse error on input `)'
11:33:58 <tommd> Don't you mean "is annoyed at `shachaf` that"?
11:33:58 <shachaf> @slap haskell
11:33:58 * lambdabot hits haskell with a hammer, so they breaks into a thousand pieces
11:34:13 <joe6> @hoogle sizeOf
11:34:13 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
11:34:14 <lambdabot> Network.Socket.Internal sizeOfSockAddr :: SockAddr -> Int
11:34:14 <lambdabot> Network.Socket.Internal sizeOfSockAddrByFamily :: Family -> Int
11:34:18 <joe6> @maxBound
11:34:19 <lambdabot> Unknown command, try @list
11:34:25 <joe6> @hoogle maxBound
11:34:26 <lambdabot> Prelude maxBound :: Bounded a => a
11:34:55 <joe6> > maxBound Integer
11:34:56 <lambdabot>   Not in scope: data constructor `Integer'
11:35:01 <joe6> > maxBound Int
11:35:02 <lambdabot>   Not in scope: data constructor `Int'
11:35:13 <tommd> > maxBound (undefined :: Int)
11:35:13 <lambdabot>   No instance for (GHC.Enum.Bounded (GHC.Types.Int -> a))
11:35:14 <lambdabot>    arising from a u...
11:35:23 <tommd> grrr
11:35:23 <Lemmih> > maxBound :: Int
11:35:24 <lambdabot>   9223372036854775807
11:35:27 * hackagebot wl-pprint-terminfo 0.2.3 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.2.3 (EdwardKmett)
11:35:31 <tommd> right, I must be tired
11:35:37 <joe6> > maxBound Integer
11:35:37 <lambdabot>   Not in scope: data constructor `Integer'
11:35:57 <tommd> Integer isn't bounded, and you need to specify that as the type via (::) as Lemmih just did.
11:36:58 <ion> > maxBound :: Float
11:36:59 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Float)
11:36:59 <lambdabot>    arising from a use of...
11:37:43 <ion> Floats definitely have a maximum numeric boundary in addition to infinity. Dunno which one maxBound should return.
11:37:59 <copumpkin> they probably didn't either
11:38:11 <copumpkin> I'd say that forall a. a <= maxBound
11:38:17 <copumpkin> so that would suggest infinity
11:38:25 <copumpkin> except for NaN :)
11:38:32 <edwardk> the problem is the invariant for maxBound isn't held because of NaN
11:38:45 <ion> Ah, good ol’ NaN.
11:38:52 <psysine> how can an operator be non-associative? i mean 1-2-3 has to mean either (1-2)-3 or 1-(2-3), right?
11:39:07 <copumpkin> psysine: the point is that those two give different answers
11:39:15 <shachaf> > True==False==True
11:39:16 <lambdabot>   Precedence parsing error
11:39:16 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
11:39:30 <edwardk> psysine: it means you have to say which you mean, also some simply don't have types that make sense when you associate them either way
11:39:44 <psysine> ooh i see, thanks
11:40:31 <ion> > True == ((42 == 42) == True)
11:40:31 <lambdabot>   True
11:40:56 <shachaf> > if True == ((42 == 42) == True) then True else False
11:40:56 <lambdabot>   True
11:41:40 <NihilistDandy> Oh, that reminds me of a question I had
11:42:06 <NihilistDandy> Can you have operation that associate in both directions?
11:42:14 <dmwit> Nope.
11:42:26 <shachaf> Associates in four direction simultaneously in a single rotation.
11:42:30 <NihilistDandy> Such that f * g * h = (f * g) * h = f * (f * h)
11:42:44 <NihilistDandy> * f * (g * h)
11:42:57 <NihilistDandy> Where * is a general operator symbol
11:42:59 <shachaf> NihilistDandy: What do you mean by "="?
11:43:01 <dmwit> NihilistDandy: mappend is supposed to have that property, but it doesn't actually parse as both associations.
11:43:11 <dmwit> (What would it even mean to parse as "both"?)
11:43:22 <shachaf> Fork a thread for each one.
11:43:23 <NihilistDandy> shachaf: Equality.
11:43:30 <copumpkin> three-way equality
11:43:40 <shachaf> NihilistDandy: Oh, well, it just means the operator is associative if that's true.
11:43:44 <byorgey> presumably if it were possible to specify that an operator was associative, the compiler could use it to do optimization.  But I don't really know how that would work.
11:43:52 <shachaf> But it's only going to be evaluated one way or the other.
11:44:05 <bscarlet> well, isn't it possible to use GHC magic to inform GHC that the rotation might or should be done or some such?
11:44:09 <NihilistDandy> NihilistDandy: I know. I was mixing my math and Haskell terminology in a really unpleasant way
11:44:12 * roconnor_ thinks you could parse associative operations using species.
11:44:23 <NihilistDandy> shachaf:
11:44:25 <NihilistDandy> I meant
11:44:26 <NihilistDandy> Shit
11:44:28 <edwardk> byorgey: see equality saturation
11:44:30 <NihilistDandy> What the hell was I doing
11:44:32 <shachaf> The Perl 6 fold operator takes the fixity of its argument into consideration to decide whether to foldl or foldr.
11:44:42 <edwardk> http://cseweb.ucsd.edu/~rtate/publications/eqsat/
11:45:21 <byorgey> edwardk: ah, neat
11:49:11 <joe6> @hoogle IOControl
11:49:12 <lambdabot> No results found
11:50:09 <joe6> i am trying to figure out how to use this: http://pastebin.com/rc6u2WqX
11:50:11 <mauke> The paste rc6u2WqX has been copied to http://hpaste.org/49987
11:50:52 <joe6> PpDev.hs: http://pastebin.com/R1z3DRQn, PpDev.hsc: http://pastebin.com/cXMdcvPH
11:50:55 <mauke> The pastes R1z3DRQn cXMdcvPH have been copied to http://hpaste.org/49988 http://hpaste.org/49989
11:50:59 <joe6> any suggestions, please?
11:51:47 <psysine> can all functions be written as lambda functions?
11:51:59 <joe6> trying to use the ioctl library. but, I seem to be missing something about "d". It seems to be an indexed type.
11:52:28 <ClaudiusMaximus> joe6: you need to create a new type for each ioctl
11:53:16 <joe6> a newtype for PPCLAIM?
11:53:24 <joe6> ClaudiusMaximus: is that what you meant?
11:53:29 <luite> tommd: yes but that list is because of an incompatible base version
11:53:37 <joe6> ClaudiusMaximus: not, just a constant, but also a type.
11:53:52 <luite> tommd: aeson gives me this error    No instance for (Data.String.IsString Builder)
11:55:03 <ClaudiusMaximus> joe6: let me double check
11:55:11 <byorgey> psysine: yes
11:55:12 <joe6> ClaudiusMaximus: thanks.
11:55:51 <psysine> byorgey, cool :)
11:56:01 * psysine likes haskell
11:56:14 * byorgey too =)
11:56:24 <ClaudiusMaximus> joe6: using bindings-dsl i did it like this:
11:56:26 <ClaudiusMaximus> #num VIDIOC_TRY_EXT_CTRLS
11:56:26 <ClaudiusMaximus> #opaque_t VIDIOC_TRY_EXT_CTRLS
11:56:26 <ClaudiusMaximus> instance IOControl C'VIDIOC_TRY_EXT_CTRLS C'v4l2_ext_controls where ioctlReq _ = c'VIDIOC_TRY_EXT_CTRLS
11:56:32 <jerji> byorgey: have you composed anything with Euterpea?
11:57:31 <ClaudiusMaximus> joe6: where #num is something like c'MACRONAME = #const MACRONAME   and   #opaque_t is something like {-# LANGUAGE EmptyDataDecls #-} data C'MACRONAME  (guessing there...)
11:58:13 <joe6> ClaudiusMaximus: let me check bindings-dsl code again. btw, is this the best place for browsing bindings-dsl code/docs: uri: https://bitbucket.org/mauricio/bindings-dsl/wiki/Home
11:58:29 <ClaudiusMaximus> joe6: yeah i think that's the main website
11:58:42 <joe6> ok, thanks. let me check.
12:00:27 * hackagebot wl-pprint-extras 1.3 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-1.3 (EdwardKmett)
12:05:27 * hackagebot wl-pprint-terminfo 0.3 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.3 (EdwardKmett)
12:09:42 <byorgey> jerji: no, I have never used it yet
12:09:53 <byorgey> jerji: have you been using it?
12:10:58 <jerji> byorgey: not yet, just going through the book slowly. there is some sort of problem with Sound.Midi where it doesn't recognize general midi on my mac
12:11:04 <jerji> so I haven't been able to run the examples either yet
12:11:33 <byorgey> jerji: sad =(
12:11:56 <jerji> yea, it's a bit frustrating to run into problems like that when you don't know how to debug them yet!
12:18:16 <gwern> > (1/1400) ^
12:18:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:18:19 <gwern> > (1/1400) ^ 3
12:18:20 <lambdabot>   3.6443148688046644e-10
12:18:45 <ion> > (1/1400) ^ 3 :: Rational
12:18:45 <lambdabot>   1 % 2744000000
12:20:27 * hackagebot wl-pprint-extras 1.4 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-1.4 (EdwardKmett)
12:20:29 * hackagebot wl-pprint-terminfo 0.3.0.1 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.3.0.1 (EdwardKmett)
12:26:30 <joe6> @hoogle VIDIOC_TRY_EXT_CTRLS
12:26:31 <lambdabot> No results found
12:27:01 <sm__> hi all
12:28:12 <sm__> I think I've pinpointed one of the ways ghci's loading/namespacing confuses
12:28:27 <NihilistDandy> sm__: Do tell.
12:28:52 <sm__> :load *MOD forces interepreted loading, and permits non-exported names to be added with :add or :module, but does not itself load non-exported names
12:29:06 <sm__> isn't that pretty nonintuitive and suboptimal ?
12:30:02 <sm__> does not itself bring non-exported names into the current namespace, to be precise
12:31:39 <byorgey> does anyone know, when using HXT to parse an XML file, is there a way to configure it so it does not try to go over the network to fetch namespace/DTD files mentioned in the header?
12:33:51 <luite> withValidate False
12:33:55 <joe6> ClaudiusMaximus: where is the .hsc file for the bindings-dsl?
12:34:27 <joe6> ClaudiusMaximus: there are .h files, but I cannot find the .hsc file in the src.
12:34:37 <luite> byorgey: readDocument [withValidate False]
12:35:04 <byorgey> luite: I already have that, it is still trying to access the network
12:35:15 <joe6> ClaudiusMaximus: would you mind sharing the file with the VIDIOC_TRY_EXT_CTRLS?
12:35:18 <luite> oh that's odd
12:35:22 <joe6> ClaudiusMaximus: the .hsc file, I mean.
12:35:30 <ClaudiusMaximus> byorgey: withProxy "localhost:9999" maybe?
12:35:54 <ClaudiusMaximus> byorgey: though, would be a kludge
12:36:07 <ClaudiusMaximus> joe6: it's generated by a script
12:36:13 <byorgey> yeah, I'd just like to turn it off altogether
12:36:32 <byorgey> right now I can't even get it to compile without specifying an HTTP method and epending on the hxt-http library
12:36:40 <byorgey> *depending
12:36:47 <byorgey> but it is totally unnecessary
12:36:52 <ClaudiusMaximus> joe6: https://gitorious.org/hsv4l2/bindings-linux-videodev2 for source
12:37:00 <byorgey> well, perhaps I will email the maintiners to ask
12:37:28 <ClaudiusMaximus> joe6: http://hackage.haskell.org/packages/archive/bindings-linux-videodev2/0.1/doc/html/src/Bindings-Linux-VideoDev2.html for source view on hackage
12:37:47 <luite> byorgey: maybe it's still used for the entities?
12:38:16 <byorgey> luite: what is an entity?
12:38:23 <ClaudiusMaximus> &foo;
12:38:23 <byorgey> <--- XML n00b
12:38:28 <luite> &something; in a text node
12:38:29 <ClaudiusMaximus> you can define them
12:38:53 <ClaudiusMaximus> and you can define them such that they take exponential space from linear code
12:38:58 <byorgey> hehe
12:39:12 <luite> I've used HXT some time ago, but it felt overly complicated...
12:39:12 <ClaudiusMaximus> @google xml entity explosion
12:39:14 <lambdabot> http://www.ruby-lang.org/en/news/2008/08/23/dos-vulnerability-in-rexml/
12:39:14 <lambdabot> Title: DoS vulnerability in REXML
12:39:21 <byorgey> well, the XML files I am trying to parse do not even contain the character &
12:39:43 <byorgey> HXT is rather monstrous but I've found it quite nice so far
12:40:06 <byorgey> every thing I set out to do so far has turned out to be a few lines of code
12:40:08 <ClaudiusMaximus> i tend to try XML parsing but eventually give up and resort to regexp
12:40:18 <ClaudiusMaximus> and feel dirty
12:40:20 <joe6> ClaudiusMaximus: thanks
12:40:37 <sm__> hmm, perhaps I'm expecting * to apply to all submodules as well, but it doesn't
12:40:51 <luite> I tried to process pdf-xml fiels with it, but abandoned the project
12:40:54 <luite> files
12:41:16 <byorgey> thanks for the help, I'm off to swim
12:43:38 <joe6> ClaudiusMaximus: i am checking out uri: https://gitorious.org/hsv4l2/bindings-linux-videodev2/trees/master, but I cannot find the .hsc file used
12:44:13 <ClaudiusMaximus> joe6: right, it's generated by a shell script
12:45:00 <joe6> ClaudiusMaximus: I am checking out the shell script and I wonder if I need the complexity and if I can get away by using a .hsc file?
12:45:29 <joe6> ClaudiusMaximus: i see comments like ; {-# LINE 92 "Bindings/Linux/VideoDev2.hsc" #-}
12:45:35 <ClaudiusMaximus> joe6: sure, i only wrote a script to make my hsc because the header was million lines long
12:45:42 <joe6> oh, ok.
12:46:11 <ClaudiusMaximus> (well, 1613 lines, but that's more than enough)
12:47:28 <joe6> i am just installing the library. i want to look at the .hsc file to get a feel for it.
12:47:48 <joe6> bindings-linux-videodev2, i mean.
12:48:30 <ClaudiusMaximus> joe6: cabal unpack should be enough, no need to install
12:48:48 <joe6> ClaudiusMaximus: ok, thanks. good to know.
12:53:11 <edwardk> gah. does anyone know where the page is with the description of the 4 different flags that can come on a gcc # 8 "foo.hs" 0 1 2 3  — line?
12:53:18 <edwardk> i keep googling the wrong words
12:53:52 <copumpkin> http://gcc.gnu.org/onlinedocs/cpp/Line-Control.html
12:54:20 <edwardk> that doesn't have the extras though
12:55:48 <edwardk> http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC40
12:55:51 <edwardk> found it
12:56:04 <luite> whoah 2.95.3 :)
12:56:48 <yrlnry> Neat, I didn't know about that.
12:56:59 <edwardk> it was driving me nuts trying to find that page =)
12:58:10 <edwardk> i was hunting for which one popped the virtual include stack ;)
13:00:47 <mwc> @tell dcoutts_ can you have a look at the patches I posted on cabal-devel on Aug 5? http://article.gmane.org/gmane.comp.lang.haskell.cabal.devel/7778
13:00:48 <lambdabot> Consider it noted.
13:09:13 <ksf> who's ddosing haskell.org?
13:09:32 <erus`> damn imperatives
13:09:54 <Igloo> ksf: Hmm?
13:10:33 <sm__> I will pay money to anyone who can make a script that loads up all top-level hledger-lib and hledger symbols into ghci scope
13:10:55 <erus`> sm__: bitcoins?
13:11:10 <sm__> sorry, just actual money!
13:11:22 <sm__> I'm serious.. this is getting ridiculous
13:12:19 <hatds> can't you write a .ghci macro?
13:13:13 <erus`> when you load a module it unloads another?
13:13:43 <sm__> this is the closest I've come: https://gist.github.com/1132680
13:14:16 <sm__> it's close, but gets confused trying to add modules from two packages (I guess)
13:14:55 <sm__> final message is "module 'Hledger.Cli.Main' is from another package; this command requires an interpreted module"
13:15:02 <ClaudiusMaximus> can you make a small .hs file with the imports that re-exports them?
13:15:13 <ClaudiusMaximus> or am i missing the point...
13:16:18 <sm__> ClaudiusMaximus: I'm not sure. I don't want to spend more time on it today, if you can make it work that way my offer stands!
13:16:20 <ksf> wait, it's only hackage that's being ddosed.
13:18:22 <ClaudiusMaximus> sm__: module Common (module Foo, module Bar) where import Foo ; import Bar  -- is what i have in mind
13:24:23 <danharaj> I just realized that the '<-' and '-<' in arrow notation draw an arrow >_<
13:26:02 <pedro3005> what is the purpose of signum in the Num typeclass?
13:26:51 <dmwit> > map signum [-5, -3, -1, 0, 2.5, 72]
13:26:52 <lambdabot>   [-1.0,-1.0,-1.0,0.0,1.0,1.0]
13:27:53 <bscarlet> > -1.0/0.0
13:27:54 <lambdabot>   -Infinity
13:28:02 <bscarlet> > signum (-1.0/0.0)
13:28:03 <lambdabot>   -1.0
13:28:08 <ClaudiusMaximus> > signum . sqrt . sqrt . negate $ 1 :: Complex Double
13:28:09 <lambdabot>   0.7071067811865476 :+ 0.7071067811865475
13:28:20 <pedro3005> so, you're gonna make me guess
13:28:29 <pedro3005> o i see
13:29:10 <Itkovian> Are there any packages that can open and read content from a gzipped tarball?
13:29:10 <kmc> it's http://en.wikipedia.org/wiki/Sign_function
13:29:19 <ClaudiusMaximus> @check \x ->  abs x * signum x == (x :: Int)
13:29:20 <lambdabot>   "OK, passed 500 tests."
13:29:47 <thoughtpolice> Itkovian: there's both 'gzip' and 'tar'
13:29:49 <thoughtpolice> @hackage tar
13:29:49 <lambdabot> http://hackage.haskell.org/package/tar
13:29:51 <thoughtpolice> @hackage gzip
13:29:51 <lambdabot> http://hackage.haskell.org/package/gzip
13:30:22 <Itkovian> bot not one that does both? just making sure before I start using both
13:30:33 <thoughtpolice> Itkovian: oh, nvm, it's not 'gzip', the gzip functionality is actually in the 'zlib' package
13:30:40 <thoughtpolice> so zlib/tar is your combo
13:30:42 <int80_h> I'm trying to do a one-line case statement in ghci. Could I just some help getting it right? case resp of Left err -> print err; Right body -> let bodyTest = body
13:30:52 <Itkovian> ok
13:30:53 <Itkovian> thx
13:30:56 <thoughtpolice> Itkovian: np
13:32:05 <bscarlet> pedro3005: among other things, it at least can be implemented for IEEE floating point more efficiently than with conditionals (in hardware, actually), so it's not unusual to have a primitive function for it in numerical APIs.
13:32:30 <bscarlet> bscarlet: I have no idea if GHC actually does that, though.
13:33:03 <kmc> int80_h, doesn't make sense.  "let bodyTest = body" in what?
13:33:18 <ClaudiusMaximus> int80_h: let Right bodyTest = resp  -- will fail if it's not Right
13:34:18 <int80_h> kmc : Well, wasn't sure what to put there, was trying to isolate "body". Original code I am doing this ">     Right body -> writeFile ("/home/ixia/in_progress/" ++ "formattedcookies.txt") =<< (obtainCookies curl body ipFilename)"
13:36:37 <ceii_>  int80_h, what about: let bodyTest = case resp of Left err -> print err ; Right body -> body
13:37:03 <int80_h> ceii_ : that loosk much better!
13:37:06 <zzo38> Why does GHC make messy LLVM codes? And even more messy when you increase the optimizatino level?
13:37:11 <ksf> haaaackaaaaaage!!!
13:37:25 <ceii_> (let a = ... without the "in" part is special syntax, not an expression, so you can't nest it inside an if expression)
13:37:45 <ksf> it is, in fact, a statement.
13:37:52 <ksf> statement as in do-block.
13:37:56 <ceii_> well, yes
13:39:13 <ksf> seems it's time to take that hackage torrent idea more seriously.
13:39:36 <NihilistDandy> I like that idea
13:40:33 <thoughtpolice> hm... i wonder i wonder what's going on in this branch: https://github.com/ghc/ghc/compare/master...ghc-kinds
13:40:51 <ksf> having a distributed database, instead of just a data store, is going to be a bit harder, though.
13:41:03 <byorgey> thoughtpolice: I can explain if you like
13:41:18 <byorgey> though I can only type with 1 hand atm
13:41:26 <thoughtpolice> byorgey: i'm just curious, but please do if you have the time :D
13:42:06 <byorgey> the basic idea is explainef in my talk from the 2010 HIW
13:42:15 <kmc> zzo38, the output of an optimizing compiler is usually difficult to understand
13:42:28 <byorgey> to be able to auto-lift types to the kind level
13:42:28 <ksf> for starters, we could put DHT-enabled .torrents in the database, and have an rss of the database somewhere safe.
13:42:47 <byorgey> although the details are somewhat different now
13:43:11 <thoughtpolice> byorgey: ooo! so this is also what you blogged about before that even, yes? i've been waiting :D
13:43:18 <ksf> teach combinatorrent how to do http downloads, and integrate it with cabal-install.
13:43:19 <byorgey> 1yes =)
13:43:22 <thoughtpolice> (for type-kind-ish things, that is)
13:43:27 <thoughtpolice> byorgey: wooohooo!
13:44:01 <zzo38> kmc: It is difficult even when optimization is not used
13:44:13 <ksf> ...hackage is still there, but exceedingly slow.
13:44:23 <dainanaki> does anyone know of an already-existing data type that wraps atomic types and maybes into one big type?
13:44:25 <byorgey> thoughtpolice: there is a wiki page, let me find it for you
13:44:47 <thoughtpolice> zzo38: haskell has a substantially different evaluation model than traditional languages, so it's not going to look like code from a C/C++ compiler at any rate
13:45:04 <byorgey> thoughtpolice: http://hackage.haskell.org/trac/ghc/wiki/GhcKinds
13:45:04 <thoughtpolice> although LLVM typically does a pretty good job from what I understand
13:45:07 <thoughtpolice> byorgey: ta!
13:45:57 <byorgey> thoughtpolice: one nice thing is that this will also give us (some form of) kind polymorphism
13:46:17 <zzo38> Do you know when the speed and size of the resulting program can be improved a lot in some cases? Is there option to "assume there is no errors"?
13:46:30 <byorgey> I hope we can eveen get as far as kind-indexed type families but we'll see =)
13:46:37 <thoughtpolice> byorgey: yeah, i saw that in the slides
13:48:07 <thoughtpolice> zzo38: i'm not sure what you mean at all or what you're trying to accomplish. is LLVM generating slow code? or are you just curious?
13:48:55 <zzo38> I have not actually tested the code of LLVM, since the program I compiled has no main function. Rather, I am just curious as to when the GHC can be improved to make better compiled code.
13:49:36 <zzo38> (Maybe it would help to make it avoid generating some unnecessary output by having pragmas to tell it to assume certain things would be the case)
13:50:34 <thoughtpolice> GHC is constantly improving, so it can generate better code with less effort on your part. but you can control various phases of the compiler and optimizers with pragmas inside of your code. whether or not that's going to be a 'win' for you is highly dependent on what you're doing.
13:50:39 <kmc> try running the code before you complain that it's slow
13:51:05 <copumpkin> kmc: speculative optimization!
13:51:08 <thoughtpolice> there isn't just a complete "winning set of optimizations." compilers have to be tuned to work well on a large body of code. you need to benchmark.
13:51:10 * copumpkin coins new term
13:51:43 <zzo38> Does GHC do constraint optimization?
13:51:46 <thoughtpolice> copumpkin: telepathic optimization!
13:52:28 <kmc> "i haven't used GHC but i hear it sucks, when will this be fixed"
13:52:36 <copumpkin> zzo38: meaning what?
13:52:44 <thoughtpolice> zzo38: I have no clue as to what "constraint optimization" is, can you give an example?
13:55:02 <zzo38> thoughtpolice: Something I have thought LLVM also ought to do, but I can explain. It is, that, you can specify that something is double, and then where it is used, you can place the assumption that the value is even, so you might be able to change things to a better code. And in case of conflicting assumptions in some place of the code, it can be eliminated (and replaced with "unreachable" in the case of LLVM).
13:55:27 <copumpkin> "change things"
13:55:46 <copumpkin> sounds like the panacea for dependently typed languages
13:55:55 <copumpkin> "omg no runtime checks of anything unnecessary ever"
13:56:02 <copumpkin> I don't know of anything that does that
13:56:14 <copumpkin> to the full extent that it should be possible
13:57:07 <zzo38> I do have some ideas about how to do things like that in LLVM, actually.
13:57:28 <zzo38> It would be done differently in Haskell, though.
13:57:30 <copumpkin> how would you specify it and check it?
13:57:38 <mm_freak_> edwardk: i have tried a few things with comonads…  is it inherent to them that 'extend' always modifies the whole structure?
13:57:57 <mm_freak_> i can imagine that the laws require this
13:58:40 <mm_freak_> but actually if something is not a comonad, but just an Extend, wouldn't it be possible to have a store, for which 'extend' only modifies the current position?
13:59:07 <Saizan> if you've to go from w a to w b you need to modify all those a's
13:59:21 <mm_freak_> good point, indeed
13:59:30 <edwardk> mm_freak: yes
14:00:00 <edwardk> mm_freak: monads also have to modify 'all those a's as well =)
14:00:25 <mm_freak_> true
14:00:30 * hackagebot wl-pprint-terminfo 0.4 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.4 (EdwardKmett)
14:00:32 * hackagebot trifecta 0.11 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.11 (EdwardKmett)
14:00:33 <edwardk> woot. i now have nested diagnostics working in trifecta
14:01:14 <edwardk> @hpaste
14:01:14 <lambdabot> Haskell pastebin: http://hpaste.org/
14:01:24 <stevse> Hello. I want to put a 2d point into a Set. This means that I have to instantiate Ord for my point. However, 2d points don't have a single ordering, so what do i do?
14:01:49 <mm_freak_> stevse: define an ordering arbitarily
14:02:07 <mm_freak_> as long as the order is total, Set works
14:02:13 <byorgey> since the ordering is only for storing the points efficiently it doesn't matter which ordering is used
14:02:21 <byorgey> lexicographic would be the simplest
14:02:24 <c_wraith> as long as it's consistent. :)
14:02:28 <stevse> so i could just order by y*width + x?
14:02:30 <kmc> well it matters some for efficiency
14:02:31 <hpaste> edwardk pasted “trifecta multiline diagnostic” at http://hpaste.org/49991
14:02:38 <mm_freak_> stevse: simpler…  use the same ordering as tuples
14:02:40 <kmc> but probably not worth thinking about
14:02:45 <stevse> tuples - that's it
14:02:46 * edwardk bounces happily
14:02:46 <kmc> > compare (2,3) (3,2)
14:02:47 <lambdabot>   LT
14:02:53 * edwardk channels his inner shapr
14:02:53 <stevse> thanks very much!
14:03:19 <byorgey> edwardk: looks neat!
14:03:19 <zzo38> I can give examples of constraint optimizations in LLVM. There can be both forward and backward constraints. Such as, if you multiply something by 2, you know the result is even. So, you check if even later, and branch condition, it can be replaced by unconditional branch (and unused branches can be deleted). In case you do exact division by 2, then you do a backward constraint saying it was even.
14:03:33 <byorgey> edwardk: this is some sort of generic package for displaying error messages?
14:03:42 <zzo38> And in case of an "unreachable" instruction, that is also a backward constraint saying nothing exists.
14:03:42 <mm_freak_> stevse: if you want some meaningful ordering, you can order by magnitude and secondarily by angle in polar coordinates, but for the sole purpose of using Set that's overkill
14:03:44 <edwardk> byorgey: and you can put multiple annotations on a single line
14:03:57 <byorgey> edwardk: right, looks very cool!
14:04:01 <stevse> i'm just after put them into a set, so i'd be happy with some random hash value really
14:04:26 <byorgey> edwardk: that is a lot of package dependencies =)
14:04:32 <edwardk> byorgey: that is included. it is a toolchain for building 'human scale' parsers. basically you can wrap it in parsec, feed it input in chunks, it deals with the line numbers, grabbing the contents of the current line, etc.
14:04:33 <zzo38> There are a lot more possibilities, but with Haskell it would be very different and I don't know exactly what it would be.
14:04:47 <byorgey> edwardk: cool =)
14:05:10 <edwardk> well, it uses crazy amounts of finger trees, and interning to increasing sharing, etc. so it more or less brings in the kitchen sink
14:05:11 <mustelo> edwardk, do you have an example of how the parsec wrapping goes?
14:05:26 <edwardk> and the output there is in color, but you can't see it on that hpaste ;)
14:06:03 <joe6> ClaudiusMaximus: i like the bindings-dsl. I seem to be getting the hang of it. Thanks for suggesting it.
14:06:32 <ClaudiusMaximus> joe6: :)
14:07:08 <edwardk> supplyEOF $ supply "world\n" $  supplyPath (file "file") $  supply "hello\nworld" $ runParserT (Text.Parsec.string "hello" >> newline >> Text.Parsec.string "w" >> careted (Text.Parsec.string "orld")) () "-" (Columns 0 0)
14:07:24 <edwardk> basically you runParserT, then feed it via 'supply'
14:07:32 <mustelo> hmm, cool.
14:07:39 <edwardk> and the result is a Text.Trifecta.It
14:07:46 <edwardk> which is an iteratee
14:07:46 <zzo38> If you do a exact division by 2 followed by a multiplication by 2, those instructions can be eliminated but replaced by a constraint instead, which can be used in further optimization.
14:08:01 <edwardk> the problem is that parsec isn't polymorphic in its error type, so i can't just dump my errors in theirs =(
14:08:11 <edwardk> so i may have to copy and paste the bulk of parsec in
14:08:37 <edwardk> otoh that would let me strip out their fairly naive position type
14:08:46 <zzo38> The SSA format of LLVM makes such optimizations easy to understand.
14:09:06 <zzo38> Can you understand how it would relate to Haskell?
14:09:12 <zzo38> Because, I don't know.
14:09:18 <zzo38> So, that is why I ask.
14:09:36 <Saizan> zzo38: see hoopl, it's a library they have been recently using ghc to propagate assumptions about the code like that, this gets done at the C-- level i think
14:09:52 <Saizan> s/using ghc/using in ghc/
14:11:45 <bscarlet> zzo38: SSA is in some sense like a functional assembly language. To that extent, any equational reasoning about Haskell code is similar to the constraints you're describing: any defintion is such a constraint. Do you mean something deeper?
14:11:58 <edwardk> mustelo: basically you supply the parser with hunks of text, paths (representing #line directives parsed up stream) and finally an EOF, then you look at the Done or Fail result of the iteratee
14:12:45 <mustelo> edwardk, right, I guess I'm wondering what the division of labor is between Parsec and Trifecta in that scenario
14:13:14 <edwardk> parsec provides the stock parser combinators. trifecta supplies it with a better cursor, a notion of location, backtracking, etc.
14:13:17 <zzo38> bscarlet: I suppose it is something like what you said. But I am better at LLVM than at Haskell.
14:13:33 <mustelo> okay, I like that. gonna have to find a place to use it :)
14:13:36 <edwardk> contents of the current line on demand, etc.
14:14:04 <edwardk> it also supplies cheap slicing of the input from a given starting point to an ending point which 'mostly shares' with the raw input chunks
14:14:10 <ddarius> et cetera, etc.
14:14:13 <edwardk> because it internaly holds onto the input in a rope of buffers
14:14:39 <edwardk> ddarius is bored, having heard all this crap before ;)
14:15:55 <ddarius> Someone should abuse hoopl for something.
14:16:26 <zzo38> ddarius: Like, what kind of things do you mean?
14:16:38 <thoughtpolice> edwardk: oh, is this trifecta stuff what you mentioned working on at the hackathon?
14:18:10 <edwardk> at the hackathon i was working on intern, the library i'm using inside of it to share some computations
14:18:23 <mm_freak_> edwardk: any chance to see your comonad/monad composing code on hackage any time soon?
14:18:25 <edwardk> the hackathon mostly had me hacking on other peoples stuff and a bit on that
14:18:29 <edwardk> it is
14:18:32 <edwardk> check kan-extensions
14:18:36 <edwardk> Control.Monad.Co
14:18:43 <mm_freak_> ah, thanks
14:19:18 <mm_freak_> but i wonder whether Store using arrays is really useful practically…  it copies all the time
14:19:36 <edwardk> think of it like applying an image filter in photoshop
14:19:50 <mm_freak_> a Map-based store may be more useful (i don't need it to be a comonad)
14:19:51 <edwardk> big operation, done a few times ;)
14:19:58 <mm_freak_> or IntMap actually
14:20:03 <edwardk> there is a representable store as well
14:20:11 <edwardk> so you can use a memotrie of content
14:20:12 <mm_freak_> edwardk: i understood that, but i'm more concerned about speed now
14:20:16 <mm_freak_> ah
14:20:29 <mm_freak_> how does that perform?
14:20:42 <edwardk> you only pay for the parts you look at
14:20:52 <edwardk> it'll leak memory like a sieve though =P
14:21:00 <edwardk> if you don't look at everything
14:21:38 <mm_freak_> hmm
14:22:04 <mm_freak_> what about IntMap?  as said, Extend would suffice
14:22:31 <mm_freak_> i would guess that gives me O(n * log n) updates of the whole thing
14:22:42 <edwardk> i have an Apply instance for IntMap, but there is no cursor supplying the focus into an IntMap for it to extend
14:22:59 <edwardk> checking
14:23:01 <edwardk> one sec
14:23:16 <mm_freak_> newtype MapStore a = MapStore (IntMap a) Int
14:23:19 <mm_freak_> wouldn't that work?
14:23:20 <edwardk> yeah
14:23:36 <edwardk> it'd work, subject to the invariant that the Int is in the store
14:24:01 <edwardk> its a pointed intmap
14:24:49 <mm_freak_> would an out of bounds pointer be bad actually?  i would think that it's only a problem for comonads
14:25:18 <edwardk> well, you can have the extract if you never have out of bounds pointers ;)
14:25:31 <zzo38> There is something I wrote information about, with some things related to Haskell, although it is not Haskell. Can you read it? If you know some things about Haskell would you know the answers of some of these things?   https://devlabs.linuxassist.net/projects/texnicard/wiki/Dangelo_Programming_Language
14:25:49 <mm_freak_> edwardk: obviously that's impossible, as long as i have 'seek' =)
14:25:52 <EvanR7> comonads are interesting
14:25:59 <mm_freak_> at least with the type signature it has
14:26:03 <edwardk> and recall, that the comonadic extend operation will never add a new point
14:26:28 <mm_freak_> yes, i think of comonads as things, where it's safe to get out, but not safe to put in =)
14:27:30 <EvanR7> no one will ever get monads because of the names of the methods ;)
14:27:51 <int80_h> I'm only interested in what my function's side-effects do, not binding a return value. Given that, what should the last part of my function's type signatur look like?
14:28:05 <mm_freak_> zzo38: answers of what?
14:28:05 <kmc> functions don't have side effects
14:28:08 <edwardk> keep in mind peek and seek become partial here or pick up a Maybe in the return type
14:28:09 <mm_freak_> i don't see any questions
14:28:19 <kmc> a function can return a description of some effects that could be returned
14:28:24 <int80_h> kmc: okay it's a procedure then.
14:28:37 <Eduard_Munteanu> If it's something in IO, then IO ()
14:28:38 <kmc> no, it's a function that returns an IO action
14:28:45 <kmc> if those effects produce no useful result, the action has type (IO ())
14:28:46 <zzo38> mm_freak_: Answers of what is written in there. Including, anything wrong with it, how to improve. And, there is one question it says "How should this be done?"
14:29:00 <kmc> your function looks like Int -> (Char -> Bool) -> IO ()
14:29:12 <mm_freak_> zzo38: first improvement: get rid of "basic types"
14:29:20 <int80_h> kmc: okay, that looks right
14:29:20 <zzo38> (If you want to, create an account and type directly on the wiki as sub items)
14:29:26 <kmc> but if you think of this only as an "impure function" or "procedure" then you're missing the point of IO
14:29:46 <kmc> IO actions are first-class values
14:29:53 <kmc> they're not tangled up with the notion of argument dependence
14:30:03 <kmc> or the notion of delayed evaluation
14:30:15 <kmc> Haskell separates these three concepts, while most languages lump them together
14:30:18 <c_wraith> IO (IO (), IO ()) is a fun and useful type.
14:30:18 <zzo38> mm_freak_: OK, then what to do about this? Get rid entirely? Integers probably should be a basic type in here.
14:30:41 <kmc> i recently found a use for Int -> IO (forall a. IO a -> IO a)
14:30:53 <copumpkin> kmc: did you ever implement that? I liked it
14:30:56 <mm_freak_> zzo38: i don't know the problem domain, but having ADTs you don't need "basic" or let me call them 'primitive' types
14:30:59 <kmc> granted that's impredicative but it's still useful if you float the quantifier out
14:31:12 <kmc> copumpkin, http://hackage.haskell.org/packages/archive/spawn/0.2/doc/html/Control-Concurrent-Spawn.html#v:pool
14:31:36 <mm_freak_> zzo38: ADTs take care of points 2 and 3
14:32:00 <kmc> another fun one is «data Stuff = Stuff (Int -> IO Stuff)»
14:32:06 <mm_freak_> c_wraith: i find myself using IO (SomeStuff -> IO ()) a lot
14:32:07 <zzo38> mm_freak_: OK, I understand. However, the reason for primitive integers (you might be right that the other two should not be; booleans can be enumerations and strings can be preprocessing steps) is having to do with compiling and optimization.
14:32:08 <kmc> and other recursive nonsense
14:32:19 <c_wraith> mm_freak_: also very useful
14:32:24 <copumpkin> kmc: aww, not the impredicative one
14:32:51 <c_wraith> impredicative types inside of IO are fun.
14:32:52 <mm_freak_> zzo38: ADTs are a theoretical concept…  they do not influence performance per se
14:33:17 <mm_freak_> zzo38: but the language of ADTs covers everything written in the two points
14:33:26 <joe6> i cannot figure out the ioctl haskell library usage. Anyone aware of a simple usage sample that I could check to understand it? uri: http://hackage.haskell.org/packages/archive/ioctl/0.0.1/doc/html/System-Posix-IOCtl.html
14:33:48 <mm_freak_> c_wraith: that's usually for actions forking threads
14:33:53 <zzo38> mm_freak_: O, OK. But still, I don't completely understand. Feel free to correct it by adding subitems to the wiki (if you want to) or explain it a bit better
14:33:58 <mm_freak_> they usually return a function to communicate with the thread
14:34:06 <Saizan> it's easier to do low-level arithmetic optimizations if Int is an abstract type rather than an isomorphic ADT
14:34:19 <zzo38> Also note I did change a few things now, so you can read it.
14:34:22 <mm_freak_> but in fact nowadays i prefer:  ((Msg -> IO ()) -> IO a) -> IO a
14:34:56 <zzo38> Saizan: Well, OK, I can mention that on the list too if it is the case
14:34:56 <mm_freak_> Saizan: nothing wrong with ADTs with hidden constructors
14:34:59 <copumpkin> kmc: we should call that the kombinator
14:35:04 <copumpkin> k for kmc
14:35:08 <kmc> yes
14:35:23 <mm_freak_> just like Int in haskell (unless you consider Num literals constructors)
14:35:23 <EvanR7> mortal kombinator
14:35:25 <zzo38> OK, I wrote that now.
14:36:02 <NihilistDandy> EvanR7: get/here
14:36:14 <zzo38> Note that, I don't need floating point. And you probably don't need unlimited integers either (although it could be a compiler option to decide)
14:36:23 <EvanR7> NihilistDandy: lol
14:36:47 <mm_freak_> zzo38: one idea i like in that language is the last one
14:36:52 <mm_freak_> Duplicate definitions are allowed as long as they agree with each other
14:36:58 <mm_freak_> i wish that were true in haskell
14:36:59 <zzo38> Do you understand "That you can have types that you can select zero or more" or am I being unclear about it?
14:37:08 <mm_freak_> then you could safely define swap (x, y) = (y, x)
14:37:14 <joe6> i am trying to understand the definiton of IOControl here, but I have no clue what it is doing: http://pastebin.com/xxjKGDD5
14:37:16 <mauke> The paste xxjKGDD5 has been copied to http://hpaste.org/49992
14:37:18 <zzo38> mm_freak_: Yes, I agree with you about that.
14:37:23 <mm_freak_> zzo38: i don't understand that, no
14:37:38 <joe6> the usage of the IOControl is : http://pastebin.com/1n8uV863
14:37:40 <mauke> The paste 1n8uV863 has been copied to http://hpaste.org/49993
14:37:51 <joe6> is it an indexed type?
14:38:34 <zzo38> mm_freak_: To understand, describing something in Haskell, such as, hypothetically if you had a command like the "data" command except the choices of constructors, the value can be zero constructors, or any combination of the specified constructors of the type.
14:39:00 <mm_freak_> zzo38: still don't understand
14:39:04 <mm_freak_> example?
14:39:17 <NihilistDandy> Any emacs wizards about?
14:39:18 <zzo38> If you play Magic: the Gathering, note how a card can have multiple card types.
14:39:35 <zzo38> And there are combinations that create objects having no card types.
14:39:58 <mm_freak_> zzo38: you mean like a number, which can be both Integer and Float?
14:40:10 <zzo38> The same thing applies to creature subtypes and so on.
14:40:34 <zzo38> mm_freak_: No. That is not quite what I mean.
14:40:51 <mm_freak_> zzo38: multiple types or multiple values?
14:41:51 <zzo38> Multiple constructors in one value. For example, if the command is "polydata" and you have "polydata A = B Int | C Int Int | D Int" then the value can be both "B 2" and "C 6 11" for example, and have no "D" constructor. But not duplicate "B" constructors or stuff like that.
14:42:17 <mm_freak_> ah, understood
14:42:37 <kmc> data A = MkA (Maybe Int) (Maybe (Int, Int)) (Maybe Int)
14:42:47 <mm_freak_> sounds like a feature, which may get handy, but i don't know what implications that would have
14:43:00 <kmc> what motivates this feature?
14:43:17 <zzo38> kmc: The card types of Magic: the Gathering.
14:43:18 <ksf> hmmm. is it a good idea to store not smallish binary chunks in acid-store?
14:43:24 <ksf> *acid-state
14:43:26 <mm_freak_> kmc: i could imagine that a "both A and B" value matches an A pattern
14:43:32 <mm_freak_> and a B pattern, too
14:43:38 <mm_freak_> but yes, you can do that with Maybe just as well
14:43:40 <ion> data A = B Int | C Int Int | D Int; type As = [A]
14:43:51 <kmc> zzo38, so you're designing a programming language specifically for representing M:TG cards?
14:44:15 <zzo38> kmc: No, it is meant to be more general than that. Although that is meant to be one of its uses.
14:44:26 <kmc> how is the feature motivated more generally, then?
14:44:28 <mm_freak_> ksf: if you checkpoint often enough, yes
14:45:05 <zzo38> In some cases the number of constructors might be a lot, such as: polydata CreatureSub = Angel | Bear | Cat | Cleric | Goblin | Human | etc.....
14:45:50 <mm_freak_> zzo38: perhaps you want something like existential quantification?
14:45:53 <mm_freak_> or type classes
14:46:02 <zzo38> kmc: How is it motifated more general, could be, to design similar kinds of games. Not necessarily Magic: the Gathering.
14:46:42 <mm_freak_> classes and existentials capture different objects with common behaviours very well
14:46:52 <kmc> you know what else captures different objects with common behaviors?
14:46:54 <kmc> functions
14:46:59 <kmc> and data structures that hold functions
14:47:16 <mm_freak_> if you find that convenient, yes
14:47:20 <kmc> don't jump to the most complicated solution first
14:47:41 <mm_freak_> sometimes even a simple ADT and pattern matching functions suffice
14:47:49 <kmc> zzo38, Haskell is a great host for embedded domain-specific languages
14:47:59 <ksf> mm_freak_, well, I'm not even modifying them often (rather, at all)
14:48:06 <kmc> that is, libraries which feel like new mini-languages but keep the abstraction power of Haskell
14:48:17 <kmc> this will be a lot less work than designing a language from scratch
14:48:22 <zzo38> kmc: I would think so especially since many of the things I described in that wiki article are similar to Haskell.
14:48:27 <kmc> and if you design a language from scratch, you will make a lot of mistakes
14:48:29 <zzo38> But there are some differences, too.
14:48:32 <kmc> because language design is hard
14:48:40 <kmc> library design is somewhat easier
14:48:43 <ion> Case in point: PHP
14:48:48 <mm_freak_> ksf: yes, but acid-state only keeps the steps to reproduce in a textual form, i.e. not very compact
14:49:04 <kmc> ion, i don't think that's a good example, as there's no evidence an attempt was even made
14:49:04 <mm_freak_> if you save not-so-small binary stuff, you better checkpoint often
14:49:13 <zzo38> PHP is just very bad in general, I think. It is also slow. Yet, I do use it sometimes. But I prefer not to.
14:49:14 <kmc> in fact there are direct quotes from the designer to the contrary
14:49:36 <kmc> anyway most "new" languages are rehashing 40-year-old concepts and make 40-year-old mistakes
14:49:54 <benmachine> @quote Rasmus_Leidorf
14:49:54 <lambdabot> No quotes match. Are you on drugs?
14:49:58 <benmachine> @quote Rasmus
14:49:58 <lambdabot> No quotes match. Are you on drugs?
14:49:59 <kmc> @where leidorf
14:50:00 <lambdabot> I know nothing about leidorf.
14:50:03 <kmc> @where Leidorf
14:50:03 <lambdabot> I know nothing about leidorf.
14:50:10 <kmc> lambdabot keeps forgetting things
14:50:23 <shachaf> @where lerdorf
14:50:23 <lambdabot> http://en.wikiquote.org/wiki/Rasmus_Lerdorf
14:50:34 <kmc> anyway Haskell is superior because its concepts are only 20 years out of date
14:50:37 <zzo38> OK, I can understand. Perhaps the first option under "How should this be done?" would work best, then.
14:50:38 <kmc> and GHC Haskell perhaps 5 or 10 years
14:50:39 <shachaf> @quote RasmusLerdorf
14:50:39 <lambdabot> RasmusLerdorf says: "I don't know how to stop it [PHP], there was never any intend to write a programming language [...] I have absolutely no idea how to write a programming language, I just kept
14:50:39 <lambdabot> adding the next logical step on the way."
14:50:47 <benmachine> oh, ler
14:50:58 <mm_freak_> zzo38: i agree with kmc…  you may spend your time more productively learning to exploit haskell instead of rolling your own language
14:51:15 <kmc> a 5-year-old computer or web framework is considered hilariously antiquated, but 40-year-old language features are considered state of the art
14:51:18 <zzo38> Some of these things could be implemented using Template Haskell, possibly.
14:51:19 <kmc> i don't really get it
14:51:26 <mm_freak_> most likely any feature you will ever come up with has already a counterpart in haskell, or you create a feature, which only improves a failed concept
14:51:55 <zzo38> But how would you do rulebooks? I don't think Haskell has that. Inform 7 does, but not to the extent which I want to use them.
14:52:05 <mm_freak_> that's why people find "aspect oriented programming" so great…  it improves the failed concept of OO
14:52:09 <mm_freak_> +P
14:52:23 <kmc> what's a "rulebook"?
14:52:37 <kmc> i don't consider OOP a failed concept
14:52:46 <kmc> Java and C++ are pretty far from the idea of OOP
14:52:50 <kmc> C++ is almost a parody of OOP
14:53:12 <kmc> it's what you'd get if a bunch of C hackers wanted to discredit the idea of OOP once and for all
14:53:40 <companion_cube> kmc: which language is a good example of OO ?
14:53:44 <kmc> shrug
14:53:45 <zzo38> kmc: For example, it specifies the rules for overriding other rules, and functions, in speicific circumstances, and after or before, stuff, trigger, etc. Inform 7 has rulebooks but not to the extent which I wanted to use in the programming language I describe in the wiki.
14:53:45 <mm_freak_> kmc: perhaps smalltalk/objc do it better, but still i don't see the value in wrapping everything in an object…  you should use the proper abstraction for the problem domain
14:53:48 <int80_h> smalltalk
14:53:49 <kmc> i find OOP in Python to be pleasant enough
14:53:53 <mm_freak_> and there is always a better abstraction than OOP
14:54:04 <kmc> the problem is languages which force you into one mode of thought
14:54:11 <mm_freak_> only thing is that most of those abstractions can only be expressed conveniently in haskell =)
14:54:12 <ksf> does hackage.haskell.org time out frequently for anyone else?
14:54:17 <kmc> Haskell is a multiparadigm language and Java is the extremist position
14:54:21 <mm_freak_> ksf: yes, me
14:54:22 <kmc> of course that's not how the world sees it
14:54:28 <mm_freak_> it doesn't time out, but it's slow as hell
14:54:42 <kmc> the problem is languages which force you into one mode of thought *and* make that mode of thought extremely cumbersome to implement
14:55:08 <ksf> well, depends on client, it seems. firefox waits long enough, wget doesn't.
14:55:39 <mm_freak_> ksf: depends on the IP address, too…  it's fast from my home connection, but slow from my server
14:55:42 <zzo38> ksf: But wget must have some option to configure timeout?
14:56:04 <ksf> it certainly has, but it's portage that's calling wget
14:56:05 <companion_cube> kmc: C++ does not force you into OO, does it ?
14:56:30 <benmachine> kmc: I don't think I'd call haskell a multiparadigm language
14:56:32 <mm_freak_> ksf: .wgetrc
14:56:34 <ksf> google.* is slow for me, too.
14:56:43 <mayahustle> kmc: yeah, I'm not so sure what you mean by multiparadigm
14:56:50 <benmachine> it can theoretically support multiple paradigms, but it doesn't *aim* to
14:56:51 <ksf> actually, half of the internet.
14:56:54 <benmachine> it has clear priorities
14:57:02 <kmc> shrug
14:57:19 <kmc> i'm not a fan of the "paradigm" paradigm to begin with
14:57:57 <kmc> i think the question is "does Haskell force me into a single narrow mode of thought" and everyone who hasn't learned Haskell thinks it does
14:58:06 <kmc> but the opposite is true
14:58:18 <kmc> Haskell forces you to *learn* pure FP, but once you come out the other side it's just one among many tools
14:58:26 <mm_freak_> i could excuse a bad type system, as long as i work alone and have no other option…  what pisses me off mainly (and mainly with PHP) is the extreme amount of noise you need
14:58:40 <benmachine> kmc: but there are definitely modes of thought that haskell discourages
14:58:44 <kmc> sure
14:59:06 <ksf> like the one where you wouldn't give in to the sudden urge of having a cup of earl grey
14:59:11 <int80_h> haskell discourages quick and dirty scripting.
14:59:21 <mm_freak_> haskell:  (+)
14:59:34 <mm_freak_> PHP: function ($x, $y) { return $x + $y; }
14:59:48 <djahandarie> kmc, I think it's more about the libraries than the language.
14:59:49 <mm_freak_> much worse when the function should have a closure
15:00:09 <mm_freak_> int80_h: i do quick-n-dirty scripting in haskell
15:00:11 <thoughtpolice> kmc: that's wrong, because everything is pure functional, you can't create mutable variables! period! it's impossible! i concluded this factoid based on what I heard on reddit! pfft, you guys are way too smug
15:00:20 <kmc> haha
15:00:30 <thoughtpolice> "haskell doesn't force you into a narrow mode of thought" <- TOTAL BS
15:00:40 <kmc> if evolution is true then why are there still monkeys HMMMMMMM?
15:00:45 <djahandarie> Namely, in Java you could just write everything with static functions, but you'd be stuck rewriting everything since most libraries use objects.
15:00:46 <kmc> QED
15:00:46 <thoughtpolice> GOOD QUESTION
15:00:55 <shachaf> Using Haskell has forced me to believe that Haskell lets you use mutable variables.
15:00:59 <int80_h> mm_freak_: me too, and I realized recently that it's a bad idea. At least if I want my dept to accept my code.
15:01:03 <shachaf> Before I used Haskell I was free to believe whatever I wanted about it.
15:01:11 <djahandarie> Similarly, in Haskell, you can litter every single function you write with IO and mutable bullshit, but if you pick up a random library it probably will not be written like that.
15:01:22 <shachaf> But now "facts" ar getting in my way.
15:01:38 <mm_freak_> int80_h: i don't see why one would love to get static error checks in larger applications, but be happy to accept bad code, when it comes to executing one-time tasks
15:01:41 <thoughtpolice> shachaf: they do that
15:01:56 <mm_freak_> most one-time tasks are much more critical than applications, which run for a long time
15:02:37 <shachaf> thoughtpolice: Fortunately I won't let them stop me.
15:02:46 <mm_freak_> djahandarie: even if you do that, haskell is still very safe
15:03:10 <mm_freak_> djahandarie: you allow side effects everywhere, but still everything has a type and the type checker is still watching you
15:03:19 <shachaf> Haskell won't let me write 446-byte demos.
15:03:25 <benmachine> haskell genuinely doesn't have *global* mutable variables though, unsafePerformCheating aside
15:03:32 <shachaf> That's clearly a narrow mode of thought.
15:03:35 <zzo38> shachaf: Then write it in machine-code instead.
15:03:52 <mm_freak_> benmachine: it does, but "global" has just a different meaning
15:03:54 <shachaf> zzo38: Pft. That's what I'd do. I'm just pointing out how narrow it is.
15:04:04 <mm_freak_> main = newIORef …  -- effectively global
15:04:29 <benmachine> mm_freak_: well, if you redefine global enough, sure
15:04:32 <mm_freak_> haskell has no top-level implicit global variables
15:04:53 <benmachine> libraries can't store global state, for example
15:05:18 <mm_freak_> LibraryT m
15:05:22 <mayahustle> don't you use monads to simulate global state in some libraries?
15:05:28 <kmc> "Haskell doesn't have feature X, if you ignore all the features I dislike personally"
15:05:44 <aavogt> you could use implicit parameters or type classes to pass the ioref around
15:05:51 <benmachine> mm_freak_: how do you enforce that, though?
15:06:02 * shachaf uses monads to simulate global state all the time.
15:06:06 <shachaf> It's what they're for, after all.
15:06:08 * dainanaki too.
15:06:16 * shachaf should probably go away for a bit.
15:06:20 * benmachine hugs shachaf 
15:06:24 <mm_freak_> benmachine: myLibraryFunction :: Int -> LibraryT m Int
15:06:29 * dainanaki hi fives shachaf
15:06:40 <mm_freak_> myImpureLibraryFunction :: MonadIO m => Int -> LibraryT m Int
15:06:45 <shachaf> dainanaki: You're too much like dankna.
15:06:51 <dainanaki> nah
15:06:57 <benmachine> mm_freak_: but you eventually have to have a runLibraryT, and then you can have two global states
15:07:02 <benmachine> which isn't very global :P
15:07:24 <mm_freak_> benmachine: i prefer the library user to have control over the scope anyway
15:07:52 <benmachine> mm_freak_: well, it's not a feature I miss
15:08:02 <mm_freak_> a library enforcing you to initialize it somewhere exactly once is broken by concept, unless it is connected to some hardware, which can only work once and then explode =)
15:08:04 <benmachine> but I think it's a nontrivial qualification of "haskell can do that too"
15:08:09 <dankna> lol
15:08:36 <aavogt> benmachine: the library supplies a TH splice that writes your main given the LibraryT IO ()
15:08:42 <mm_freak_> anyway, i found that monads are not the best abstraction for state
15:09:00 <companion_cube> mm_freak_: even for, say, connections to databases and such ?
15:09:06 <mm_freak_> i'm using FRP as an abstraction for state now
15:09:08 <companion_cube> (about initializing libs)
15:09:13 <mm_freak_> companion_cube: sure
15:09:22 <kmc> i'm going to start saying "Haskell doesn't have type classes" on the same grounds as "Haskell doesn't have impure functions / global variables"
15:09:25 <aavogt> by splice I mean   ( f ::   Expr -> Q [Dec])
15:09:30 <benmachine> aavogt: that's uhm, not exactly super-convenient
15:09:45 * aavogt agrees
15:09:55 <aavogt> benmachine: but that satisfies the requirement?
15:10:08 <totimkopf> is there a point in getting a quad-core for most programming?
15:10:26 <benmachine> aavogt: being convenient was part of the requirement, otherwise "turing-complete" gets you everything, no?
15:10:42 <kmc> totimkopf, yes
15:10:50 <mm_freak_> "turing-complete" gives you too much sometimes =)
15:10:59 <mm_freak_> (hidden reference to agda)
15:11:04 <benmachine> :D
15:11:07 <aavogt> yeah, the problem was about restricting usage
15:11:08 <totimkopf> kmc: hmm, really, why?
15:11:09 <Eduard_Munteanu> totimkopf: for one thing you might want to do concurrent programming
15:11:21 <totimkopf> hmm
15:11:26 <mm_freak_> Eduard_Munteanu: you can very well do concurrent programming without multicore
15:11:34 <Eduard_Munteanu> Sure, but it's nice to test.
15:11:41 <kmc> because if you can't do parallel programming you will become obsolete as a programmer
15:11:45 <mm_freak_> interestingly most concurrent programs will run much faster without -N in the small scale
15:11:59 <kmc> sure, cooperative multithreading has a very low overhead
15:12:03 <Eduard_Munteanu> Ah, I wasn't talking just Haskell.
15:12:05 <alpounet> bos, did you get my email about aeson ?
15:12:44 <mm_freak_> Eduard_Munteanu: you were talking about concurrent programming…  perhaps confusing it with parallel programming
15:12:52 <aavogt> if main was an indexed monad, I think you could enforce the distinction between   IO Uninitialized   vs.  IO Initialized
15:13:30 <Eduard_Munteanu> Hm, maybe :)
15:13:53 <Eduard_Munteanu> What's the difference anyway, again?
15:14:13 <mm_freak_> in simple terms concurrent programming is a control structure
15:14:59 <mm_freak_> two subprograms running at the same time (not necessarily parallel), and the concurrency becomes meaningful, as soon as they correlate in some way
15:15:03 <Eduard_Munteanu> So where do mutual exclusion, locking etc. fit?
15:15:25 <mm_freak_> one thread may send a message to the other, or both threads may wait on a handle, which gets translated to a single select/poll/epoll call
15:15:36 <bos> alpounet: yep
15:16:00 <mm_freak_> mutual exclusion, locking, etc. are communication effects
15:16:23 <mm_freak_> and there are nice abstractions for eliminating them, like STM
15:16:43 <kmc> concurrency refers to semantics.  parallelism refers to an implementation technique.
15:16:54 <Eduard_Munteanu> Ah.
15:17:18 <mm_freak_> Eduard_Munteanu: see the monad-coroutine package for concurrency on the library level =)
15:17:22 <kmc> if you run a bunch of threads that do blocking IO on a uniprocessor, you have concurrent semantics without parallel execution
15:17:33 <kmc> you still have the full problems of nondeterminism, synchronization, etc.
15:17:54 <kmc> if you use GHC's "par" with -threaded on multi-core, you have parallel evaluation without concurrent semantics
15:18:12 <kmc> the semantics are still those of sequential lazy evaluation
15:18:19 <dainanaki> is it fair to say that parallelism is generally preferable to concurrency where possible?
15:18:24 <kmc> say "non-strict semantics"
15:18:31 <kmc> dainanaki, they aren't comparable in that way
15:18:34 <mm_freak_> dainanaki: that's a meaningless statement
15:18:34 <kmc> is gasoline preferable to fuel?
15:18:41 <kmc> concurrency refers to semantics.  parallelism refers to an implementation technique.
15:18:59 <kmc> dainanaki, it's fair to say that adopting concurrent semantics just for the sake of parallel performance is silly
15:19:10 <kmc> and is still the dominant way to achieve parallel performance
15:19:11 <Eduard_Munteanu> Some would say implementation-independent abstractions are nicer.
15:19:14 <mm_freak_> concurrency is semantics, and concurrent programming is a design pattern
15:19:19 <dainanaki> that's what i was getting at
15:19:28 <kmc> but there are many valid reasons to want concurrent semantics, with or without parallel execution
15:19:35 <companion_cube> that's very interesting
15:20:07 <gwern> lambdabot: @join #lesswrong
15:20:23 <companion_cube> so eg pi-calculus is a language with concurrency semantic but which can be implemented in a sequential way
15:20:29 <mm_freak_> dainanaki: for any multi-connection networking program in haskell you will want to use concurrent programming
15:20:37 <dainanaki> i understand that
15:21:01 <mm_freak_> without concurrent programming you need to employ explicit select()/poll()/epoll
15:21:34 <Peaker> mm_freak_: or abstract those away in a Reactor, essentially boiling down to CPS, which is really just a different syntactic representation for IO threads :)
15:21:42 <mm_freak_> parallel execution of threads is something you get for free in haskell, but it's not always something you actually want
15:22:12 <dainanaki> I was just getting at the concept of having a task which could be implemented concurrently or not, and thinking that parallelism doesn't imply the same sort of issues that arise in concurrent programming.
15:22:26 <Peaker> In mutable-by-default languages, I actually like cooperative multitasking CPS with a reactor
15:22:47 <mm_freak_> Peaker: in those languages i like trampolines
15:22:49 <Peaker> the "yield points" should be explicit, and the explicit CPS helps that..
15:22:51 <mm_freak_> for coroutines
15:23:18 <mm_freak_> i don't know what a reactor is, and CPS is not an option in PHP =)
15:23:25 <mm_freak_> well, it is, with a trampoline
15:24:08 <Peaker> a reactor is basically an event loop + a table you can [un]register callbacks to for various types of events
15:24:28 <mm_freak_> oh
15:24:38 <mm_freak_> so it's the mega-imperative way =)
15:24:51 <Peaker> so you use epoll via the standard event loop, and to read from a socket, for example, you register a handler on incoming socket data
15:25:00 <Peaker> mm_freak_: well, IO threads are mega-imperative too :)
15:25:33 <mm_freak_> haskell IO threads give you STM =)
15:25:40 <Peaker> which is also imperative..
15:26:43 <mm_freak_> controlled imperative programming
15:26:53 <mm_freak_> i don't like event loops or registering callbacks
15:27:27 <mm_freak_> although we may be comparing apples and bananas here
15:27:48 <Saizan> some would say that every use of >>= is registering a callback
15:27:59 <MHD> Anyone checked out the 10/GUI concept?
15:28:18 <companion_cube> Saizan: like in lwt for ocaml ?
15:28:54 <Saizan> i don't know lwt
15:29:04 <companion_cube> never mind then
15:29:31 <Peaker> I also like the idea that the API for file handles looks like:  makeFileHandle :: DataHandler -> IO Writer   -- such that the type guarantees there's always exactly 1 receiver of data... unlike a Handle you can "read" from 0 to N threads, where 0 or 1 is valid, but 2 and upwards has ambiguous and probably undesirable semantics
15:29:59 <mm_freak_> Peaker: there is a better way to do that
15:30:03 <Peaker> mm_freak_: how?
15:30:13 <Peaker> though then I'm not sure how to "flow control" (represent 0 readers at the moment)
15:30:45 <mm_freak_> withFile :: FilePath -> IOMode -> (forall s. Handle s -> FileIO s a) -> IO a
15:32:14 <Peaker> Hmm, interesting.. But FileIO (or any other transformer stack in IO) may be somewhat restrictive (e.g: can't use IO combinators that expect IO in a negative position)
15:32:37 <mm_freak_> FileIO can be isomorphic to IO
15:32:45 <mm_freak_> newtype FileIO s a = FileIO (IO a)
15:33:06 <Peaker> mm_freak_: btw: The handle there seems superfluous.. if you're in the FileIO s  monad, you can just have a monadic primitive in that monad to read or write "the" file
15:33:17 <zzo38> Is there heap profile that does not use PostScript?
15:33:19 <Peaker> mm_freak_: if you expose this isomorphism you lose the type safety
15:33:28 <mm_freak_> Peaker: no, you don't
15:34:00 <mm_freak_> the sole presence of the "forall s" ensures that handles cannot leave their scope
15:34:19 <Peaker> mm_freak_: yes, until you expose the FileIO data constructor..
15:34:27 <mm_freak_> even then
15:34:36 <Peaker> Then, you can take the actions that manipulate the handle directly and leak them out to any context
15:34:57 <mm_freak_> you can't, because those actions also have that nasty 's' in their signature =)
15:35:15 <Peaker> mm_freak_: case nastyAction of FileIO notSoNastyAnymore -> ...
15:35:24 <Peaker> the "s" disappears inside the data constructor
15:35:46 <mm_freak_> the actions themselves are opaque…  you cannot decompose them
15:35:52 <mm_freak_> FileIO doesn't have to be opaque
15:35:59 <mm_freak_> see how ST works
15:36:05 <Peaker> ST doesn't expose the data constructor :)
15:36:44 <Peaker> mm_freak_: basically you can "cast" the "s" to anything you would like, too, once you expose the data constructor
15:37:36 <ClaudiusMaximus> zzo38: hp2pretty is one i wrote (svg output, though ps is planned at some point..)
15:38:01 <mm_freak_> Peaker: i see what you mean
15:38:13 <Peaker> mm_freak_: it seems like a nice idea -- where is it from?
15:38:14 <mm_freak_> well, it would make sense to have an opaque FileIO type
15:38:35 <mm_freak_> it's a combination of the idea of monadic regions with the idea of ST =)
15:38:52 <mm_freak_> not terribly convenient, but well possible
15:39:04 <Peaker> ah, so.. what about my other question: Why not replace the phantom type -- with "read" and "write" actions that read "the" file?
15:39:33 <Peaker> e.g: newtype FileIO a = FileIO (ReaderT Handle IO a)
15:39:52 <Peaker> then you don't give an explicit Handle, so you can only access the file you're allowed to
15:40:09 <Peaker> (and you don't expose the ReaderT functionality in there, of course :)
15:40:21 <mm_freak_> i'm not overly fond of hiding things in a monad for the purpose of hiding =)
15:40:38 <Peaker> FileIO seems like a heavier hammer for the same purpose though
15:40:43 <Peaker> (FileIO s)
15:40:48 <hpaste> “Ben Gamari” pasted “Perplexing type error” at http://hpaste.org/49997
15:41:20 <mm_freak_> yes, but FileIO s gives you a handle and also is isomorphic to IO, which makes mapping some control constructs easy
15:41:21 <hpaste> “Ben Gamari” annotated “Perplexing type error” with “Perplexing type error (error)” at http://hpaste.org/49997#a49998
15:41:26 <mm_freak_> like exception handling (MonadControlIO)
15:41:31 <bgamari> Would someone mind taking a look at the above?
15:41:37 <bgamari> The compiler seems to be very confused
15:41:58 <Peaker> mm_freak_: but I'm not sure how you expose that isomorphism without breaking the guarantees
15:41:59 <bgamari> it completely misinfers the typing of a fold
15:42:09 <Peaker> bgamari: why are you using ==True and ==False?
15:42:27 <Peaker> bgamari: just use the Bool value directly, or   not yourBool
15:42:33 <bgamari> Peaker: Would you rather I'd pattern match?
15:42:49 <kmc> > map (== True) [False, True]
15:42:50 <lambdabot>   [False,True]
15:43:12 <kmc> it's better than "if b then True else False" which I see a lot
15:43:35 <bgamari> Peaker: The reason was I wanted to name the elements of the tuple
15:43:37 <Peaker> @check liftA2 (==) (==True) id
15:43:38 <lambdabot>   "OK, passed 500 tests."
15:43:46 <hatds> True == isTrue flag
15:43:51 <hatds> ;0
15:43:52 <Peaker> bgamari: (==True) is the identity function,  (==False) is not
15:43:53 <kmc> isTrue = id
15:44:01 <bgamari> Peaker: Since it won't be entirely clear how the fold works
15:44:09 <bgamari> Ahhh
15:44:11 <bgamari> alright
15:44:14 <kmc> (==True) is not "not"; (==False) is not not "not", i.e. is not
15:44:19 <kmc> hope that clears it up
15:44:28 <mm_freak_> Peaker: by using some packages like monad-control
15:44:44 <mm_freak_> they take the idea of MonadIO further to generalizing control structures
15:44:45 <ion> > map (maybe False (const True) . guard) [False, True]
15:44:46 <lambdabot>   [False,True]
15:45:18 <hatds> nice
15:45:25 <kmc> >
15:45:33 <mm_freak_> > filter id [True, False, False, True, True]
15:45:34 <lambdabot>   [True,True,True]
15:45:35 <ion> > map (maybe False (const True) . guard . (== True)) [False, True]
15:45:37 <lambdabot>   [False,True]
15:45:43 <kmc> > map (([False.. ] !!) . fromEnum) [False, True]
15:45:43 <lambdabot>   <no location info>: parse error on input `]'
15:45:55 <kmc> > map (([False ..] !!) . fromEnum) [False, True]
15:45:56 <lambdabot>   [False,True]
15:45:59 <bgamari> Any ideas about the actual type issue?
15:46:29 <Peaker> http://hpaste.org/edit/49997 <-- slightly cleaned it up -- what's the type error?
15:47:27 <Peaker> appears hpaste rejeceted my annotation.. oh well
15:47:43 <hpaste> Peaker pasted “Annotated” at http://hpaste.org/49999
15:49:09 <bgamari> Peaker: cleanup isn't quite right
15:49:22 <bgamari> Peaker: Note the prefix strings; they aren't the same
15:49:29 <bgamari> but I see your point, thanks for the suggestion
15:49:35 <Peaker> Oh :-)
15:49:45 <zomg> I'm trying to install mueval, but the binary doesn't seem to do anything
15:49:52 <bgamari> Peaker: http://hpaste.org/49997
15:49:53 <zomg> it just... does nothing at all
15:50:03 <bgamari> Peaker: Look at the annotation; it lists the error
15:50:15 <bgamari> Peaker: The compiler wants Text to be Char
15:50:21 <bgamari> and I can't figure out why
15:50:35 <hpaste> Peaker annotated “Annotated” with “Annotated (annotation)” at http://hpaste.org/49999#a50000
15:50:36 <bgamari> The types appear to be exactly what I want them to be
15:50:54 <Peaker> bgamari: are you sure f isn't partial then? Not sure you cover all the conditions if it's a different isPrefix test
15:51:27 <Saizan> bgamari: check the type of foldl'
15:51:36 <zomg> gwern: ping
15:51:41 <gwern> eek!
15:51:48 <zomg> Have a moment?
15:51:58 <gwern> no more than I always do
15:52:22 <zomg> No idea what that means but I tried installing mueval using cabal, and now running the binary just produces absolutely no output
15:52:25 <zomg> Any ideas?
15:52:31 <gwern> zomg: well, what are the args?
15:52:59 <zomg> It doesn't matter, it never produces any output
15:53:10 <gwern> what, for every and all args?
15:53:18 <zomg> Even if I just run it without any args
15:53:18 <Peaker> Saizan: I don't see the type problem with his use of foldl' at a glance.. what are we both missing?
15:53:21 <mm_freak_> bgamari: perhaps first try to simplify your code
15:53:27 <mm_freak_> there is a lot of opportunity to do that
15:53:30 <aavogt> bgamari: you have the wrong foldl'
15:53:37 <gwern> zomg: well, what happens with the test script?
15:53:51 <aavogt> bgamari: use    Data.List.foldl'
15:54:15 <bgamari> but Doh
15:54:36 <aavogt> ah, Saizan spotted it quicker
15:54:54 <zomg> gwern: bah, it started working as soon as I put it in $PATH... :P
15:54:56 <bgamari> aavogt: Which one did I have?
15:55:03 <singpoly1a> Does anyone use -Wall in ghc, or just -W ?
15:55:08 <bgamari> I didn't import Data.Foldable
15:55:09 <aavogt> bgamari: one from Data.Text
15:55:16 <gwern> zomg: that is a weird error. doesn't your shell tell you when you invoke an executable which doesn't exist?
15:55:26 <Peaker> ohh
15:55:28 <zomg> I was trying to execute it using ./mueval in the .cabal/bin dir
15:55:30 <bgamari> Doh
15:55:40 <bgamari> aavogt: Looks like I should have imported qualified
15:55:51 <Peaker> unqualified imports bite another ass!
15:55:52 <zomg> I just added .cabal/bin to $PATH so I could run the tests.sh script, and then it just started working
15:55:58 <Peaker> Off with their heads :)
15:56:04 <gwern> zomg: I have no idea why that wouldn't work
15:56:11 <ksf>  -Wall -fno-warn-name-shadowing
15:56:16 <bgamari> Peaker: You used ! as not in that code
15:56:16 <NS_tech> ok what are all the equality symbols?       if /=  is "less than" then what is "less than or equal to"?
15:56:20 <mm_freak_> bgamari: you are using foldl' from Data.Text, i think
15:56:22 <ksf> -fno-warn-unused-do-bind if you want.
15:56:26 <bgamari> Peaker: Is that correct?
15:56:31 <aavogt> ksf: is that supposed to catch bgamari's problem?
15:56:32 <gwern> singpoly1a: I've always used -Wall, and it's pretty common
15:56:34 <zomg> gwern: guess I'll just make sure cabal/bin stays in my path then :) Thanks
15:56:35 <Peaker> bgamari: Yes.. shame on me :)
15:56:35 <bgamari> Thanks all, you are absolutely right
15:56:38 <mm_freak_> import Data.List and import Data.Text qualified
15:56:38 <gwern> NS_tech: <= ?
15:56:42 <Peaker> bgamari: to my defense I write a LOT of C now :)
15:56:45 <mm_freak_> foldl' is not defined in the prelude
15:56:52 <ksf> aavogt, no, answer singpoly1a's question.
15:57:02 <Peaker> NS_tech: that's not less-than
15:57:04 <Peaker> @type (/=)
15:57:05 <lambdabot> forall a. (Eq a) => a -> a -> Bool
15:57:26 <bgamari> Peaker: heh, no worries. I'm sorry to hear that ;)
15:57:29 <Peaker> It means "not equal" (opposite of (==))
15:57:31 <joe6> can anyone explain what this means: class Storable d => IOControl req d | req -> d where
15:57:34 <Peaker> bgamari: Hey, I enjoy writing C :)
15:57:38 <joe6> especially, the "|"
15:57:42 <singpoly1a> gwern: I'm seeing  Warning: The import of `Map' from module `Data.Map' is redundant -- is that because I also include a module that includes Data.Map.Map or something?
15:57:45 <NS_tech> why does oh
15:57:49 <NS_tech> ok
15:57:53 <gwern> singpoly1a: sounds plausible
15:57:55 <NS_tech> the exaplmes were misleading
15:57:58 <joe6> i understand that IOControl class is being defined, with d as Storable
15:58:16 <joe6> but, what does "IOControl req d | req -> d" mean?
15:58:23 <aavogt> joe6: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/type-class-extensions.html
15:58:27 <dainanaki> I need some advice on how to represent something: I have a datatype that contains a description and a field that holds an atomic type. I want this to be similar to a maybe, except I need to know what atomic type I'm trying to construct. I need the type signature for this container to not differ based upon what atomic type it contains.
15:58:32 <singpoly1a> gwern: that seems really weird... shouldn't I import any module I'm going to use?  Otherwise I have to know what modules the modules I use import, and that just seems odd
15:58:49 <aavogt> it's the section 7.6.2. Functional dependencies
15:58:54 <mm_freak_> joe6: it's a functional dependency stating that 'rep' determines 'd'
15:58:58 <gwern> singpoly1a: what GHC is warning you is that it's ambiguous where you want Map to come from
15:59:13 <joe6> mm_freak_: more like an indexed type?
15:59:45 <gwern> singpoly1a: you get rid of it by enumerating your imports or alternately hiding Map from one of them
15:59:55 <mm_freak_> joe6: class ReaderMonad m e | m -> e
16:00:05 <mm_freak_> instance ReaderMonad (Reader e) e
16:00:14 <mm_freak_> the 'e' follows from 'Reader e'
16:00:43 <aavogt> dainanaki: what do you want to do with these atomic types later on?
16:01:19 <dainanaki> based upon the atomic type needed, i render an input field.
16:01:21 <mm_freak_> it lets the compiler know that if you use the ReaderMonad instance of a type 'Reader Int', then the 'e' in the typeclass must be Int
16:01:36 <singpoly1a> gwern: So, I put hiding (Map) on the module that imports Data.Map and it says "module does not export Map" -- so it must be something else  -- *looks*
16:01:43 <dainanaki> the reason that I need to know the type is for reading the proper value back in.
16:01:57 <Peaker> bgamari: why not use a parser combinator for that code?
16:02:05 <singpoly1a> gwern: Oh!  does it warn me if I don't use the thing I'm importing?
16:02:14 <gwern> singpoly1a: I'm not sure
16:02:31 <singpoly1a> gwern: because I just looked and I'm not using that anymore.  maybe that's it
16:02:45 <singpoly1a> gwern: do you know if there's good documentation on the warnings somewhere?
16:03:19 <gwern> singpoly1a: don't think there is. I learned them by trial and error. if there is, it'd be the ghc manual. (they're listed in the index).
16:04:02 <aavogt> if you run ghci,  :set -fwa<tab>   shows you a whole bunch of warnings too
16:05:22 <singpoly1a> gwern: ok.  also, does ghc enforce Haskell standard by default?  or do I need a flag to say "no extensions please"
16:05:24 <joe6> mm_freak_: thakns.
16:05:28 <joe6> mm_freak_: thanks.
16:05:48 <zzo38> How would I compile rulebooks into Haskell codes?
16:05:49 <gwern> singpoly1a: well, you're getting some extensions by default - hierarchical modules comes to mind
16:05:50 <mm_freak_> you're welcmoe
16:05:54 <mm_freak_> you're welcome
16:06:08 <gwern> singpoly1a: there's the haskell98 package, but that's about modules, IIRC.
16:06:11 <aavogt> dainanaki: you can use -XExistentialQuantification and have       data Atm b = forall a. Read a => Atm a (a -> b); where your b is some type you end up with from all your different 'a'
16:06:42 <aavogt> (or you don't have to parameterize the b if you've got something specific)
16:06:58 <dainanaki> hmm, that's true
16:07:43 <dainanaki> I was using type witnesses before, but it was getting pretty hairy
16:07:53 <singpoly1a> gwern: oh, so do you know if there's a "no extesions please" switch?  I see -fno-glasgow-exts, but using that says it's deprecated
16:08:17 <gwern> singpoly1a: didn't know that was deprecated. I think besides that, all you can do is not request any extensions
16:08:30 <singpoly1a> gwern: hmm, ok
16:09:13 <hatds> in ghci at least you can say ":show languages" which shows what language flags are enabled
16:09:35 <Peaker> Having:  exists a. (a, a -> b) in there  seems isomorphic to just having a b
16:09:44 <hatds> the default set in ghci should be (nearly?) the default set in ghc
16:09:49 <aavogt> dainanaki: you still need to pass some Atm around to pick the instance like       readAtm :: Atm b -> String -> Atm b; readAtm (Atm _ f) s = Atm (read s) f
16:09:54 <Peaker> dainanaki: what's an atomic type?
16:10:27 <dainanaki> atomic type being the Int, Double, etc.
16:10:33 <aavogt> Peaker: it's different because of the Read constraint
16:10:40 <dainanaki> i just need a union over all of them
16:10:56 <Peaker> aavogt: the function you build the "b" from can carry around the Read constraint
16:12:03 <Peaker> dainanaki: I didn't quite understand your requirements.. what are you going to do with this type? Represent input fields?
16:14:32 <aavogt> Peaker: I don't follow how you translate the constraint on 'a' into something on 'b'
16:14:43 <dainanaki> I have a type that I'm attempting to construct in such a way that I can know what type in a union of types I am programmatically constructing.
16:15:28 <dainanaki> And I need to do this over a collection of this type.
16:17:06 <dainanaki> The use case is this: I want to be able to require command line arguments if the program is being run as a cli app, or I want to be able to render visual forms using Qt if the app is being run in visual mode.
16:18:31 <zzo38> Is it possible to use the RULES pragma to generate Template Haskell codes and vice versa?
16:18:35 <dainanaki> I want to be able to have the type of these values that I "demand" be such that I can carry lists of heterogenous demands around the program with minimal fuss.
16:18:38 <Peaker> aavogt: yes, you're right, the existential isn't quite opaque there.. But if you have both:  Read a, and a -> b, then you can just replace that with:  String -> b   in there
16:19:15 <hatds> dainanaki: what are the values are being demanded?
16:19:44 <Peaker> dainanaki: data InputType a = InputType { fromCommandLine :: String -> a, buildQtWidget :: IO (IO a) } ?
16:20:07 <Peaker> s/InputType/Input
16:20:37 <Peaker> dainanaki: what else do you need from the type -- except being able to be parsed from cli or build-a-dialog in Qt?
16:21:46 <dainanaki> well, ideally I was trying make it such that I could have a type class to render on other platforms in the future.
16:21:49 <Peaker> dainanaki: You can then even have combinators:  combineInputs :: InputType a -> InputType b -> InputType (a, b)    or maybe even instantiate Applicative (probably not Monad though)
16:22:10 <Peaker> dainanaki: So you want open extensibility?  Because closed extensibility is easy -- just extend that record
16:22:18 <dainanaki> right.
16:22:38 <dainanaki> i think existential quantification is probably the route I need to go.
16:22:55 <mm_freak_> dainanaki: take inspiration from HDBC
16:23:32 <hatds> dainanaki: I personally avoid typeclasses/existentials for this sort of thing
16:23:33 <mm_freak_> HDBC only provides the API, while other packages provide the actual database connections as types
16:24:44 <dainanaki> mm_freak_, thanks
16:24:54 <Peaker> class QtInput a where ... whatever is needed to build input this from qt .. ; class CLIInput a where ... whatever is needed to input from CLI ; ...   Then you can have a subclass as sort of a "class alias":  class (QtInput a, CLIInput a) => ProgramInput a where {}
16:24:54 <dainanaki> that just gave me the lightbulb I needed.
16:25:17 <dainanaki> thanks everyone, think I have a clue what i'm doing now.
16:25:27 <Peaker> or even just records instead of type-classes, actually
16:25:38 <mm_freak_> dainanaki: works well, as long as you don't have multiple values of different types in a homogenous data structure
16:25:48 <mm_freak_> but even for that HDBC has a solution:  the ConnWrapper type
16:27:56 <Peaker> IMO, instead of coercing the type with existential wrappers -- just coerce them into a single record-of-operations type, or use Applicative/etc combinators to put them in tuples rather than lists
16:28:27 <zzo38> Is it possible to display the Haskell code resulting from the INLINE and RULES pragmas and of Template Haskell codes?
16:28:35 <mm_freak_> i'm not sure how records are an improvement from a practical perspective
16:28:48 <cmccann> zzo38, pretty sure there's a flag to dump splices for TH at least
16:29:27 <Peaker> mm_freak_: well, I find the set of operations (or "destructors" of the type) which is not existential to be nicer than an existential type that's kept around only as a middle man for said operations
16:29:42 <zzo38> And what exactly is "external core"?
16:30:27 <cmccann> Peaker, just church-encode everything in sight
16:30:31 <mm_freak_> Peaker: i don't follow
16:30:36 <cmccann> that'll take care of it
16:31:37 <mm_freak_> Peaker: IMO the operations are just the same, where ones are record functions and the others are class member functions
16:31:43 <Peaker> mm_freak_: existentials are relatively opaque -- there is very little you can do with them, and that closed set of things you can do with them is apparent right there in the context of the existential.  So instead of storing the existential, you can pre-apply that closed set of things you can do with them, and store the result
16:32:09 <zzo38> Is it possible to use Template Haskell and the "reify" command to make duplicate definitions to not make errors?
16:32:21 <mm_freak_> Peaker: got that, but how is that an improvement?
16:32:41 <Peaker> mm_freak_: It's simpler, more portable, more approachable
16:33:09 <Peaker> GHC is somewhat restrictive about what you can do with existentials, too
16:33:15 <mm_freak_> i'm happy with the two latter points, but i find existentials much easier to work with
16:34:31 <Peaker> Would you rather have:  data Showable = forall a. Show a => Showable a   ;  [Showable]      or just  [String] ?
16:35:01 <mm_freak_> depends on the application
16:35:37 <Peaker> There are some cases where I don't know of an alternative to the existential... e.g: conal's WithCont type
16:35:57 <singpoly1a> Is shadowing bindings considered rather bad form?
16:36:33 <cmccann> Peaker, well, existentials in data types can be replaced with higher-rank polymorphism, but that's more an equivalence than an alternative
16:36:39 <Peaker> singpoly1a: In most contexts, yeah -- but where you use it as sort of a poor man's state monad, it can be good form
16:36:47 <Peaker> cmccann: yeah
16:37:20 <singpoly1a> Peaker: well, the big case for me is pattern matches like    Rec {a = a, b = b}, etc.  that's frowned upon?
16:37:40 <Peaker> oh, it just occurred to me that Conal's WithCont needs an existential for similar reasons that the Stream Fusion needs them -- because it has a desired operational semantics
16:37:55 <Peaker> if you only cared about denotational semantics you could get rid of the existentials in both very easily
16:38:23 <Peaker> singpoly1a: Not frowned upon at all, in fact there's a special GHC extension that gives you that as: Rec {a, b}
16:38:44 <aavogt> also   Rec {...}
16:39:36 <singpoly1a> Peaker: hmm, ok.  maybe I'll turn that warning off, then
16:40:54 <Peaker> singpoly1a: I don't get a warning for that kind of shadowing
16:41:14 <Peaker> singpoly1a: what flag are you using for that warning?
16:41:38 <mm_freak_> Peaker: i don't necessarily take the most basic approach…  i take the approach, which expresses my problem very well
16:41:39 <aavogt> the ghc version might matter too
16:42:43 <Peaker> mm_freak_: Well, I don't think choices such as these affect the expression that much, they're very localized choices
16:42:43 <singpoly1a> oh, nm, that may not be what I'm getting the warning on.  I'm also doing    field <- get; Rec {field = field}
16:43:26 <mm_freak_> Peaker: not at all…  i'm also considering the performance
16:43:51 <singpoly1a> nome, also getting it for the pattern match case.  ghc 7.0.3 with -Wall
16:45:17 <Peaker> mm_freak_: Well, existential types' main legitimate use is performance, yeah..  awesome performance trickery using them in "from lists to streams to nothing at all"
16:45:40 <mm_freak_> Peaker: most uses of them are no trickery at all
16:45:56 <mm_freak_> more realistic example would be Buildable instead of Showable
16:46:00 <mm_freak_> producing a Builder
16:46:12 <Peaker> mm_freak_: What's a Builder?
16:46:39 <mm_freak_> blaze-builder is a ByteString building library
16:49:09 <mm_freak_> saving a 'later' form and not using it always makes your run-time performance less predictable in haskell…  hence you'll want to save the earliest form possible
16:49:38 <NS_tech> what is the command to exit GHCi>?
16:49:49 <mm_freak_> NS_tech: press ctrl+d
16:50:11 <mm_freak_> (or type ":q", if you feel like it)
16:50:38 <mm_freak_> ctrl+d is a convenient universal graceful exiter =)
16:50:49 <NihilistDandy> Breaking news important to no one: http://esolangs.org/wiki/Collatz_function
16:51:22 <Peaker> mm_freak_: not sure what form you're talking about
16:54:17 <mm_freak_> Peaker: given you have some showable values, [String] is a later representation (after applying 'show')
16:54:53 <mm_freak_> later form
16:55:21 <Peaker> mm_freak_: Ah.. I see now.  Sounds like making the later form and not using it should have exactly the same operational behavior as saving the earliest form and only applying when you're actually going to use it
16:56:00 <Peaker> Except when the earlier form is not opaque and still amenable to optimized composition/changes that are more expensive on the opaque/later form
16:56:13 <singpoly1a> ok, the only warning I'm not sure about now is Defaulting the following constraint(s) to type `Double' -- I guess that's because it can't tell for 100% what type to use so it just picks one it thinks will be good enough?
16:56:35 <c_wraith> singpoly1a: that's exactly what causes that warning
16:57:00 <singpoly1a> c_wraith: So, should I put a type specifier on the line to supress it?
16:57:18 <Peaker> singpoly1a: A type annotation or some sort of forcing on the type would suppress it
16:57:30 <c_wraith> singpoly1a: or anywhere that will make the type concrete.  doesn't necessarily need to be on the line that's warning you, depending on the code
16:57:47 <mm_freak_> Peaker: so much for the theory =)
16:58:25 <NS_tech> thanks
16:58:47 <Phyx-> dcoutts: you around by any chance?
16:58:51 <mm_freak_> the sole presence of the list already implies some unevaluated shows
16:59:19 <singpoly1a> werid.  the warning is on a literal numeric constant
16:59:44 <mm_freak_> and in my case it wouldn't be a list usually, but a more efficient data structure, possibly a strict one
17:00:39 * hackagebot BiobaseInfernal 0.5.4.0 - Infernal data structures and tools  http://hackage.haskell.org/package/BiobaseInfernal-0.5.4.0 (ChristianHoener)
17:06:46 <zzo38> Are my questions difficult for you to understand?
17:07:14 <Peaker> zzo38: why do you want duplicate definitions not to errorize?
17:07:57 <zzo38> Peaker: In case, you might define it in many places
17:07:59 <singpoly1a> What in the world is the logic on having / only defined for fractional and a seperate `div` for Integral?
17:08:04 <Peaker> zzo38: why do that?
17:08:13 <zzo38> I am also just curious about Template Haskell and that stuff.
17:08:46 <Peaker> singpoly1a: these two operators are really different from a semantics/mathematical/denotational standpoint... one means division, the other means floor division
17:08:53 <zzo38> Peaker: It might also be useful when doing this stuff https://devlabs.linuxassist.net/projects/texnicard/wiki/Dangelo_Programming_Language so that TeXnicard can generate a Dangelo code which then generates a Haskell code, for example.
17:09:24 <Peaker> singpoly1a: support of (/) implies support of   floor after (/)   but support of div does not imply support for (/)
17:09:27 <singpoly1a> Peaker: well, they're more different in the type they output than anything else.  I guess it's to prevent accidental 3/4=0 ?
17:10:01 <Peaker> singpoly1a: floor $ x / y      /=    x / y
17:10:19 <Peaker> singpoly1a: it is merely coincidental that the best approximation of (/) on some types happens to be   floor after (/)
17:10:33 <Peaker> singpoly1a: it's not the (/) operator as implemented in those types
17:11:12 <Peaker> singpoly1a: the laws of (/) and (*)  are different from the laws of   div/mod/*   for example
17:11:13 <zzo38> A definition might occur in multiple card sets so that when the files are combined, you will get duplicate definitions.
17:11:48 <singpoly1a> sure.  but if one's really concerned about the 3/4=0 problem when not define   (/) :: (Num a, Num b, Fractional c) => a -> b -> c   ?
17:11:51 <Peaker> zzo38: if you're generating code programmatically, just prune the duplicates
17:12:36 <singpoly1a> or a -> a -> c, whichever
17:13:06 <Peaker> singpoly1a: is that a function or a method?
17:13:19 <Peaker> singpoly1a: if a method -- then in what class,  if a function, how do you define it?
17:13:32 <ion> > ((-6) `divMod` 5, (-6) `quotRem` 5)
17:13:33 <lambdabot>   ((-2,4),(-1,-1))
17:13:51 <zzo38> Peaker: Yes, that can be done, I suppose. You could have TeXnicard->Dangelo, all the Dangelo codes are conbined into a single file, and then during the step of compiling this single file into a Haskell code it can prune duplicates. It can be done like a preprocessor to Haskell.
17:14:20 <singpoly1a> Peaker: I'd say a method on Num, moving (/) up from Fractional to Num and just saying there's always a fractional output
17:14:46 <singpoly1a> mostly I'm just unhappy that `div` looks ugly, heh
17:14:52 <Peaker> singpoly1a: but then it would have a different semantics on Integers and on Doubles?
17:15:10 <Peaker> 3 / 4   would mean something else according to which type was chosen for 3 and 4?
17:15:16 <singpoly1a> no, it would always output fractional
17:15:25 <Peaker> singpoly1a: but what would the *value* be?
17:15:32 <Peaker> 0 or 0.75 -- depending on type selection?
17:16:03 <rwbarton> in general arithmetic operations in Haskell don't have types like (/) :: (Num a, Num b, Fractional c) => a -> b -> c
17:16:05 <Peaker> AFAIK Haskell's current ugly Num class doesn't have this problem: Type selection can make things compile or not compile, or change precision of the results, but it cannot change the *meaning* of the results
17:16:12 <rwbarton> they have types like (...) => a -> a -> a
17:16:13 <ion> :t (/) `on` realToFrac
17:16:13 <singpoly1a> 0.75   if we were going to make it 0 (which I wouldn't mind, but I do see the 3/4=0 problem) we wouldn't need Fractional output :)
17:16:14 <lambdabot> forall b a. (Fractional b, Real a) => a -> a -> b
17:16:39 <Peaker> singpoly1a: ah, I see, my bad, I should have read that meaning :)
17:16:41 <ion> > ((/) `on` realToFrac) (3 :: Integer) 4 :: Rational
17:16:41 <lambdabot>   3 % 4
17:17:04 <Peaker> singpoly1a: you generally expect binary arithmetic operators in Haskell to be   a->a->a  though, yeah
17:17:10 <Peaker> as rwbarton said above
17:17:25 <Peaker> otherwise type ambiguity would be a bitch :-)
17:18:11 <singpoly1a> Like I said, I'm mostly just upset that (length / 3) gave me a type error, and that I had to say something ugly like (length `div` 3) instead
17:18:16 <singpoly1a> it doesn't really matter that much
17:18:33 <ion> fromIntegral l / 3
17:18:48 <singpoly1a> I'd have been ok with   (floor $ length / 3), but (floor $ fromIntegral length / 3) is a bit silly
17:19:06 <singpoly1a> since that's just a terribly verbose `div`
17:19:31 <ion> I like explicit numeric type conversions much more than the implicit conversions many languages have.
17:19:33 <Peaker> singpoly1a: if you had used:  fromIntegral (length x) / fromIntegral 3  -- you'd have a point     -- but since you WANT that floor, then you want the `div` semantics and not / semantics, so why use  floor $ a / 3     when "div" composes those for you already :)
17:19:49 <Peaker> ion: We've had *countless* bugs due to C's trigger happy type conversions
17:20:09 <Peaker> ion: I'll take the annoying (and it is annoying) spraying of fromIntegral in Haskell over it
17:20:14 <singpoly1a> floor $ a / 3   is just more intuitive + looks nicer, that's all
17:20:34 <Peaker> :t (//)
17:20:35 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
17:20:37 <aavogt> you can definitely write a function '/' that does that
17:20:53 <Peaker> @let (//) = div
17:20:54 <lambdabot>  Defined.
17:20:57 <Peaker> :t (//)
17:20:58 <lambdabot>     Ambiguous occurrence `//'
17:20:58 <lambdabot>     It could refer to either `L.//', defined at <local>:1:0
17:20:58 <lambdabot>                           or `Data.Array.//', imported from Data.Array
17:21:03 <Peaker> oy vey :-)
17:21:06 <singpoly1a> aavogt: sure, but that would be confusing to haskell programmers reading my code, I expect
17:21:28 <Peaker> singpoly1a: `div` isn't that ugly
17:22:05 <singpoly1a> Peaker: it's not terrible. just looks weird
17:22:31 <aavogt> singpoly1a: part of the reason things are as they are might be because then you couldn't infer the argument types from the result type
17:23:10 <aavogt> then again that was already enough of a problem that they added defaulting
17:25:57 <hpc> does anyone know how to convert from some haskell time type to int?
17:26:14 <hpc> i don't care how, it's for a uniquely obnoxious SQL query
17:26:33 <hpc> google and hoogle are being uncharacteristically useless
17:26:49 <Phyx-> morn hpc
17:27:13 <Peaker> hpc: I think UTCTime has a Num instance?
17:27:34 <aavogt> or maybe you can use  toRational
17:27:34 <mm_freak_> hpc: what would that integer be?
17:27:48 <hpc> mm_freak_: seconds since 1970
17:27:49 * ski . o O ( `const 0' )
17:28:18 <hpc> same as the machine int
17:28:21 <mm_freak_> hpc: a messy way would be to use diffUTCTime
17:28:21 <sm__> hpc: perhaps getCurrentTime >>= utcTimeToPOSIXSeconds
17:28:54 <mm_freak_> NominalDiffTime is a Real, so you can use round . realToFrac
17:28:57 <sm__> or the type-correct version
17:29:08 <hpc> :t round
17:29:09 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:29:13 <ski> (.. iirc POSIX doesn't count leap seconds, for braindead reasons)
17:29:39 <hpc> it doesn't have to be exact; the system clock is off by about five minutes :P
17:29:43 <Peaker> hpc: http://hackage.haskell.org/packages/archive/time/1.2.0.5/doc/html/Data-Time-Clock-POSIX.html
17:29:44 <hpc> will try round . realToFrac
17:29:46 <wli> Remind me about leap seconds.
17:29:47 <mm_freak_> hpc: SQL usually accepts some fancy string representation, which is probably the safer variant
17:30:09 <hpc> mm_freak_: can't compare strings, and hell if im gonna do string conversions into their wonky format
17:30:17 <joe6_> i have a c function that does not return anything.
17:30:22 <mm_freak_> hpc: why would you compare strings?
17:30:26 <Peaker> hpc: posixSecondsToUTCTime  and  utcTimeToPOSIXSeconds    give you UTCTime and NominalDiffTime equivalence.  And NominalDiffTime is Num
17:30:38 <mm_freak_> SQL reads time strings into a lower level format
17:30:57 <mm_freak_> joe6_: me too
17:31:15 <mm_freak_> Peaker: where are those defined?
17:31:25 <Peaker> http://hackage.haskell.org/packages/archive/time/1.2.0.5/doc/html/Data-Time-Clock-POSIX.html
17:31:38 <mm_freak_> oh, good to know
17:31:45 <mm_freak_> never noticed that module before
17:32:06 <ion> int a = 2000000000, b = 2; double x = a*b/3.0, y = a*(b/3.0); printf ("%f %f\n", x, y);
17:32:07 <mm_freak_> then you can just as well use getPOSIXTime
17:32:10 <ion> -98322432.000000 1333333333.333333
17:32:15 <mm_freak_> instead of getCurrentTime
17:32:19 <ion> How obvious
17:32:29 <sm__> yay time lib!
17:32:44 <danharaj> o.O
17:32:57 <danharaj> You can't do: `_ <- foo -< bar' ?
17:33:01 <hpc> @hoogle getPOSIXTime
17:33:01 <lambdabot> Data.Time.Clock.POSIX getPOSIXTime :: IO POSIXTime
17:33:08 <mm_freak_> danharaj: sure you can
17:33:18 <mm_freak_> danharaj: more concisely you can do:  foo -< bar
17:33:22 <mm_freak_> if you disregard the result
17:33:24 <hpc> time <- round . realToFrac <$> liftIO getPOSIXTime
17:33:25 <hpc> solved
17:33:28 <danharaj> derp you're right
17:33:30 <hpc> thanks all
17:33:33 <hpc> that was too damn hard
17:33:36 <danharaj> I'm getting a 'pattern syntax in expression context' error
17:33:47 <Peaker> hpc: why not liftIO outside?
17:34:04 <danharaj> but that is from another problem elsewhere I surmise.
17:34:08 <hpc> Peaker: because im dumb :P
17:34:23 <danharaj> oh, duh. It's because I'm using arrows without arrows enabled.
17:34:31 <danharaj> Oh you, GHC. You and your coy error messages.
17:34:31 <mm_freak_> danharaj: just wanted to suggest =)
17:34:38 <Peaker> hpc: I remember struggling for *ages* to find these time functions... but in retrospect, they're placed in the "obvious" place for them to be :)
17:35:01 <Peaker> hpc: there's the problem of having time, old-time, datetime or who remembers what other time handling packages, each of which with multiple modules, each of which with multiple time types
17:35:01 <sm__> they're just a bit fragmented and there's no good overview doc
17:35:10 <mustelo> does anyone have experience hacking on the 'pointfree' package? I'm trying to add some rules just for fun, and I can't seem to get them to apply
17:35:26 <Peaker> now if you know/remember that "time" is the right package -- and pay attention to the module names -- then you're left with just a few types, and those types are probably all necessary
17:36:22 <hpc> Peaker: wooooow! next time i ask a dumb time question, just remind me to look at the package page
17:36:46 <danharaj> oh great.
17:36:49 <beezir> Anyone have any idea why ghc (Windows 7 x64, latest Haskell Platform) would just hang when I try compiling anything?
17:37:06 <danharaj> So I just converted my frp library into arrows, and now it crashes in GHCi but it works fine compiled.
17:37:08 * danharaj flips a desk.
17:37:19 <Peaker> hpc: Yeah, I've learned that lesson too :)
17:37:39 <mm_freak_> danharaj: converted which one?
17:37:55 <danharaj> mm_freak_: My own monstrosity that relied on comonad and applicative.
17:38:26 <danharaj> mm_freak_: Now I'm just taking the automata arrows from Ross's paper and adding hook ups to whatever monad I want to add 'sources' from.
17:38:30 <shachaf> danharaj: Cale does it better than you.
17:38:41 <mm_freak_> interesting…  i desperately tried to extend my FRP arrow into a monad, but found that it's simply not a monad
17:38:43 <danharaj> shachaf: Probably. Cale is a wizard.
17:38:59 <Cale> wat
17:39:17 <danharaj> mm_freak_: If it's anything like automata, then it won't be a monad. I don't have an instance for ArrowApply.
17:39:23 <djahandarie> Cale, you are a wizard, don't ask questions.
17:39:29 <shachaf> Cale: danharaj is having trouble flipping a desk as impressively as you do.
17:39:32 <Cale> ah
17:39:49 <Cale> （╯°□°）╯︵ ┻━┻﻿
17:39:55 <NihilistDandy> YES
17:39:55 <danharaj> that is amazing.
17:39:58 <danharaj> Cale++
17:40:01 <danharaj> Cale++++
17:40:13 <danharaj> fix ((++ "++")) Cale
17:40:20 <byorgey> @remember Cale （╯°□°）╯︵ ┻━┻
17:40:21 <lambdabot> I will remember.
17:40:22 <NihilistDandy> @karma Cale++
17:40:22 <lambdabot> Cale++ has a karma of 1
17:40:29 <mm_freak_> Cale: have you seen netwire?
17:40:36 <Cale> nope
17:40:38 <danharaj> > fix ((++ "++")) "Cale"
17:40:39 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
17:40:39 <lambdabot>         against inferr...
17:40:48 <danharaj> I never get the types correct the first time.
17:41:09 <mm_freak_> Cale: may i query you?
17:41:25 <Cale> sure, though I may be slightly unresponsive for the next couple minutes
17:41:39 <shachaf> > "Cale"++fix("++"++)
17:41:41 <lambdabot>   "Cale++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++...
17:42:17 <shachaf> @karma ((
17:42:17 <lambdabot> (( has a karma of 19
17:42:23 <danharaj> @karma c
17:42:23 <lambdabot> c has a karma of 4
17:42:32 <shachaf> @karma (
17:42:32 <lambdabot> ( has a karma of 265
17:42:36 <danharaj> @karma lambdabot
17:42:36 <lambdabot> lambdabot has a karma of 10
17:42:52 <Peaker> C++ is apparently discussed more than C-- :-)
17:42:58 <ski> wli : search for `POSIX' at <http://tunes.org/~nef/logs/scheme/11.01.28> for some discussion of the aforementioned brain damage
17:43:05 <shachaf> Peaker: lambdabot disregards "C" as a special case.
17:43:19 <Peaker> shachaf: so how's the 4 karma?
17:43:34 <shachaf> @karma+ c
17:43:34 <lambdabot> c's karma raised to 5.
17:43:45 <shachaf> @karma c/c
17:43:45 <lambdabot> c/c has a karma of 632
17:44:12 <danharaj> @karma c/
17:44:12 <lambdabot> c/ has a karma of 14
17:45:58 <srap> is any body familiar with pi-calculus?
17:46:45 <sm__> interesting to read a little of the time's formative discussions: http://www.haskell.org/pipermail/libraries/2005-January/002908.html
17:51:04 * ion found http://comonad.com/haskell/Comonads_1.pdf informative.
17:52:21 <alpounet> hooray
17:54:22 <dmwit> srap: Just ask your question.
17:54:27 <dmwit> If somebody knows, they'll answer.
17:55:02 <srap> so can pi-calculus help solve race condition?
17:55:12 <BMeph> dmwit: Maybe that _was_ his question.... ;)
17:55:47 <dmwit> No, the pi-calculus does not prevent race conditions.
17:56:13 <srap> does it prevent starving?
17:56:34 <dmwit> However, it is a basic enough core that you can prove that *particular programs* don't have race conditions, if you wish.
17:57:27 <dmwit> No, the pi calculus does not solve the resource starvation problem.
17:57:29 <srap> so can compiler identify that at compile time?
17:57:47 <dmwit> However, it is a basic enough core that you can evaluate different scheduling strategies and their starvation characteristics, if you wish.
17:58:45 * cmccann thinks this is beginning to sound like "does lambda calculus solve the recursion problem?"
17:59:01 <srap> i learnt its core briefly on wikipedia. but dunno what its implementation can do
17:59:08 <ion> @vixen Does lambda calculus solve the recursion problem?
17:59:08 <lambdabot> who's to say?
17:59:24 <dmwit> cmccann: What am I supposed to say? The pi calculus isn't designed to *solve* problems, it's designed to *study* problems.
17:59:42 <cmccann> dmwit, my point exactly
17:59:54 <djahandarie> Pie solves starvation problems for me
18:00:04 <betta_y_omega> what's the difference between lambda-calculus and pi-calculus? XD
18:00:05 <cmccann> I think djahandarie has the right answer here
18:00:49 <cmccann> > fromEnum 'λ' - fromEnum 'π'
18:00:50 <lambdabot>   -5
18:00:52 <danharaj> I thought we were all implicitly agreeing not to make that pun.
18:00:58 <cmccann> betta_y_omega, negative five, apparently
18:01:09 <srap> dmwit: i understood it's designed to describe problems, just like lambda calculus does.
18:01:29 <dmwit> right
18:02:27 <dmwit> So: "What can you do with the pi calculus?" "You can model concurrent processing with the pi calculus."
18:02:48 <srap> my point is, PLs and compilers basing on lambda calculus, can help prove a lot of characristics of a program, like the type system
18:03:19 <dmwit> Yep, there are lots of extensions to the lambda calculus. There are lots of extensions to the pi calculus, too.
18:03:27 <ion> Can econometrics solve the debt crisis?
18:03:32 <srap> my question is, what ability do PLs and compilers basing on pi-calculus have so far?
18:03:43 <dmwit> There's a fair number of type systems, and there are located calculi.
18:03:49 <srap> by current time slot.
18:04:29 <dmwit> I think there are a few pi-calculus interpreters designed for simulations, as well.
18:04:41 <dmwit> i.e. with extensions for biological and chemical interactions
18:04:57 <Eduard_Munteanu> There are places I wouldn't want calculi to be located.
18:05:46 <copumpkin> your kidneys?
18:05:54 <srap> someone familiar with research status of pi-calculus should be able to help answer that question. or i can do that with several hours' paper reading...
18:06:06 <Eduard_Munteanu> Yeah.
18:06:11 <betta_y_omega> is pi-calculus the concurrent version of lambda-calculus?
18:07:08 <srap> hi ManateeLazyCat
18:07:11 <dmwit> betta_y_omega: sort of
18:07:30 <ManateeLazyCat> srap: Hye. :)
18:07:42 <dmwit> betta_y_omega: In lambda calculus, there are only lambdas and function application; in pi calculus, there are only communication channels and send/receive pairs.
18:07:53 <zomg> Shouldn't -XOverlappingInstances get rid of "Overlapping instances for GHC.Show.Show ...." type errors?
18:08:32 <zomg> Trying to get mueval to give something meaningful for things like just a function name ("map" for example)
18:09:07 <dmwit> Actually, that's not quite fair. There's also parallel composition (run both things at the same time) and an operator for making up a brand new named channel.
18:09:25 <cmccann> zomg, no, you still get errors on ambiguous overlaps and from instances that were declared without overlapping enabled
18:09:48 <zomg> Ah I see
18:09:50 <dmwit> Looks like Wikipedia has a decent page on it.
18:11:21 <srap> dmwit: yeah. but the definition and reduction rules does not tell much. we need to dig into its implementations to find out their abilities.
18:12:16 <ski> '
18:13:16 <ski> EKEYBOARD
18:13:23 <mm_freak_> ManateeLazyCat: hi there =)
18:13:24 <zomg> > map
18:13:25 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> [a] -> [b])
18:13:26 <lambdabot>    arising...
18:13:28 <zomg> Oh.
18:13:35 <zomg> lambdabot doesn't get it right either :D
18:14:08 <ski> zomg : it's probably two `instance Show (a -> b)', fighting to death
18:14:32 <hpc> there was one custom one for lambdabot, then another one came from vector i think
18:14:50 <zomg> Yeah I recall lambdabot used to be able to produce output from that kind of input
18:14:58 <hpc> vector being the package that gives us the magic of "sin**2 * cos**2 $ 1"
18:15:18 <mm_freak_> hpc: vector-space
18:15:52 <zomg> Hmm... Actually that overlapping instances error contains the output that it should produce ((a -> b) -> [a] -> [b])
18:16:06 <zomg> think I'll just see if I can parse it from that for my project :D
18:17:24 <roconnor> oooh, there are arctic semirings too.
18:19:06 <ski> ohh, what are those ?
18:19:30 <roconnor> ski: they are max-plus semirings with non-negative number and +inf and -inf.
18:22:16 <ski> what does "with non-negative number" mean more precisely ?
18:24:50 <NihilistDandy> 0 or more of them
18:25:11 <roconnor> ski: I mean to say non-negative numbers
18:26:20 <ski> does that mean that `forall x. x = -inf \/ x >= 0' ?
18:26:32 <roconnor> ski: yes
18:41:42 <copumpkin> roconnor: your tropical semiring stuff over a graph reminds me of the sum-product algorithm
18:41:44 <copumpkin> you come across that?
18:41:55 <roconnor> copumpkin: Horner's rule?
18:42:14 <roconnor> http://patternsinfp.wordpress.com/2011/05/05/horners-rule/
18:42:51 <copumpkin> roconnor: http://www.comm.utoronto.ca/~frank/papers/KFL01.pdf
18:43:44 <roconnor> copumpkin: yikes
18:43:51 <roconnor> copumpkin: you'll have to make it into a blog post :D
18:43:54 <copumpkin> lol
18:44:02 <copumpkin> you heard of belief propagation
18:44:03 <copumpkin> ?
18:44:18 <copumpkin> viterbi and forward-backward and BP can be expressed in terms of it
18:44:33 <copumpkin> with suitable semirings
18:45:14 <djahandarie> This paper looks complicated
18:45:24 <copumpkin> it's really not that bad
18:45:43 <copumpkin> I have an implementation of it in haskell somewhere, but it was when I was first learning haskell and sucked
18:45:49 <copumpkin> not even sure where it is now
18:46:08 <roconnor> semirings ought to be part of the Prelude.
18:46:20 <djahandarie> A lot of things ought to be part of the Prelude.
18:46:25 <miyako> hello
18:46:33 <djahandarie> yo
18:46:41 <roconnor> but semirings are apparently a big part of CS algorithms
18:47:00 <copumpkin> yeah
18:47:03 <copumpkin> as that paper will tell you :)
18:47:10 <copumpkin> it also manages to express the FFT in terms of them iirc
18:47:17 <roconnor> copumpkin: not the only paper that says this :D
18:47:20 <Phyx-> does anyone know if the web upload of packages is broken?
18:47:23 <hpaste> miyako pasted “List Directories” at http://hpaste.org/50037
18:47:27 <Phyx-> i keep getting HTTP 400 errors
18:47:35 <copumpkin> roconnor: where else can I read about it? I like that kind of stuff
18:47:41 <roconnor> copumpkin: though it seems that dioids are even more important than fields :D
18:48:01 <copumpkin> those are those idempotent semirings, right?
18:48:06 <copumpkin> like the tropical ones?
18:48:10 <roconnor> copumpkin: there are the references in my blog post. ... but I'm not sure they cover much beyond what I covered in my post.
18:48:16 <copumpkin> ah
18:48:21 <copumpkin> still haven't read your entire post :)
18:48:22 <roconnor> copumpkin: ya, idemponent semi-rings ...
18:48:30 <roconnor> copumpkin: my post is long :(
18:48:41 <copumpkin> I think the correct statement of the problem is
18:48:43 <copumpkin> long post is long
18:48:47 <copumpkin> I like it though
18:48:51 <djahandarie> Are we talking about 'A very general method of computing shortest paths'?
18:48:52 <miyako> I didn't realize the pastebin would auto submit the link, but regarding that, does anyone know why the code above will only list the files or directories in the current working directory, but returns an empty list when looking at subdirectories or parent directories?
18:49:04 <roconnor> copumpkin: though some reference I was reading claimed that dioids were only ordered semirings, and that idemponent semi-rings were just a special case of dioids
18:49:17 <roconnor> copumpkin: but wikipedia says that dioids are idempotent semirings.
18:50:34 <roconnor> miyako: I'm surprised your definition of joinPaths even typechecks.
18:50:41 <roconnor> oh wait
18:50:47 <roconnor> you have joinPath
18:50:48 <roconnor> sorry
18:51:38 <roconnor> miyako: can you paste a sample output?
18:52:49 <hpaste> miyako pasted “Sample Output” at http://hpaste.org/50041
18:53:15 <roconnor> miyako: are the directories empty?
18:53:30 <miyako> roconnor: no, I included sample output from ls -R to show what is in the directories
18:53:39 <roconnor> ah
18:55:32 <roconnor> miyako: I find isHidden = (/=) '.' . head  a very hard to read definition. :D
18:56:30 <roconnor> I woudl be inclined to write isHidden  = not . (=='.') . head
18:56:33 <roconnor> but that is just me.
18:56:54 <Peaker> head :-(
18:56:59 <roconnor> actually I wouldn't use head
18:57:01 <roconnor> :D
18:57:27 <miyako> what would you suggest?
18:58:06 <Peaker> safety over convenience... get head/tail/fromJust out of the stdlib...
18:58:13 <roconnor> isHidden ('.':_) = True
18:58:15 <Peaker> put div in Maybe..
18:58:18 <roconnor> isHidden _ = False
18:58:39 <miyako> roconnor: hmm, that does seem better :)
18:58:45 <liyang> I'd take 1 == "."
18:58:47 <dmwit> hidden = isPrefixOf "."
18:58:53 <roconnor> liyang: that's nice
18:59:20 <roconnor> dmwit: that's really nice
18:59:50 <aavogt> hidden = ("." `isPrefixOf`) -- noisier but easier to read
19:01:03 <roconnor> miyako: anyhow your problem is that listDirs and listFiles is asking doesDirectoryExist on a subdirectory but is asking in the current directory, where it doesn't exist.
19:01:18 <roconnor> IO is hell.
19:01:24 <roconnor> well
19:01:28 <roconnor> File IO is hell
19:01:32 <hatds> is there a standardized way to determine if a file is hidden?
19:02:07 <dmwit> I don't really think Linux offers a way to check if a file is hidden.
19:02:20 <dmwit> Windows probably does, since it has first-class "hidden"-ness support.
19:02:21 <liyang> There's nothing special about file names beginning with . except by convention in most user tools.
19:02:36 <NihilistDandy> Why not just bracketOnError and create the directory if it doesn't exist?
19:02:52 <liyang> (or the equivalent of mkdir -p)
19:03:13 <NihilistDandy> Oh, I see, it's a subdir issue
19:03:19 <NihilistDandy> Nevermind.
19:03:43 <dmwit> ?hoogle FilePath -> IO ()
19:03:44 <lambdabot> System.Directory createDirectory :: FilePath -> IO ()
19:03:44 <lambdabot> System.Directory removeDirectory :: FilePath -> IO ()
19:03:44 <lambdabot> System.Directory removeDirectoryRecursive :: FilePath -> IO ()
19:03:53 <dmwit> ?hoogle workingdirectory
19:03:53 <lambdabot> No results found
19:03:56 <dmwit> hum
19:04:06 <miyako> roconnor: okay, I understand what you're saying but I'm trying to see where I did that in my code
19:04:33 <dmwit> The web-interface hoogle says changeWorkingDirectory :: FilePath -> IO ()
19:04:37 <ski> roconnor : which blog post is this ?
19:04:47 <roconnor> ski: which blog post is what?
19:04:59 <roconnor> ski: oh what I was talking to copumpking about?
19:05:01 <ski> <roconnor> copumpkin: my post is long :(
19:05:11 <roconnor> http://r6.ca/blog/20110808T035622Z.html
19:05:14 <ski> ty
19:05:59 <Phyx-> hmm why does hackage warn about, "Exposed modules use unallocated top-level names: WinDll"
19:06:02 <Phyx-> is that a bad thing?
19:06:32 <danharaj> shouldn't that be WinDLL?
19:07:22 <miyako> roconnor: nevermind, I see it now
19:07:43 <hatds> one would think that using an allocated(?) top-level name would be a problem
19:07:50 <Phyx-> danharaj: I have to change it to something else, just don't know what to call it, since I support more then just windows
19:08:00 <roconnor> miyako: :)
19:11:29 <hatds> are you exposing modules for each OS and only one gets used?
19:13:05 <Phyx-> hatds: no.. it's just originally i only supported windows, and so the entire project was called WinDll, along the way I added code for linux and renamed the project to Hs2lib, but the namespaces stayed the same
19:15:24 <Phyx-> hmm so uploading via the web interface doesn't announce via hackagebot
19:18:56 <roconnor> I think it will eventually
19:19:18 <miyako> is there a function that is something like: split :: Eq a => (a->Bool) -> [a] -> [[a]] to split/partition a list?  Specifically I'd like something like: split (=='/') "/foo/bar/baz" that returns ["foo","bar","baz"]
19:19:35 <sm> Phyx-: it was detected in the feed two minutes ago, but there's an rss2irc bug where it sometimes thinks it has reached the maximum 5 announcements and waits till the next interval
19:19:50 <roconnor> miyako: http://hackage.haskell.org/package/split
19:20:10 <Phyx-> sm: ah, ok, thanks :)
19:20:16 <sm> more noticeable now with the longer 5m interval
19:20:23 <miyako> roconnor: thanks :)
19:20:39 <miyako> I'm going to try implementing it myself once to understand it, then use the package
19:20:39 * hackagebot Hs2lib 0.5.0 - A Library and Preprocessor that makes it easier to create shared libs from Haskell programs.  http://hackage.haskell.org/package/Hs2lib-0.5.0 (TamarChristina)
19:20:52 <joe6> how do I submit a package to hackage?
19:20:59 <roconnor> miyako: sounds like a good plan.
19:21:17 <sral> @src fix
19:21:17 <lambdabot> fix f = let x = f x in x
19:21:18 <Phyx-> ah there it goes
19:21:21 <sral> @src fixed
19:21:21 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
19:25:30 <sral> >fix (x:)
19:25:37 <sral> > fix (x:)
19:25:38 <lambdabot>   [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,...
19:26:00 <copumpkin> > fix fail
19:26:01 <lambdabot>   ""
19:35:12 <miyako> okay, I have a feeling that this could be more elegant.  Anyone have suggestions...
19:35:17 <hpaste> miyako pasted “splitOn” at http://hpaste.org/50042
19:43:13 <sral> > fix (\g x -> if x = 1 then 1 else x + (g (x - 1))) 4
19:43:13 <lambdabot>   <no location info>: parse error on input `='
19:43:28 <sral> > fix (\g x -> if x == 1 then 1 else x + (g (x - 1))) 4
19:43:29 <lambdabot>   10
19:44:07 <hatds> miyako:  if I were writing this function directly, I'd pattern match on str.  There are two cases, sep:xs and _:xs   You'd accumulate the splitted string one character at a time
19:45:09 <hatds> well not exactly pattern matching...  x:xs | x == sep or something
19:46:20 <sral> > fix (const 0)
19:46:21 <lambdabot>   0
19:46:59 <hatds> or, using any number of parsing libs you could simply say: runParser . many $ manyTill next (char sep)
19:48:03 <Phyx-> hmm, I really should get off using show and read to save and load my results
19:48:05 <miyako> hatds: well yeah, I can use a parsing lib, the goal was to figure out how to write it on my own before I used a library for the learning experience :)
19:49:45 <hatds> I agree, it's always worthwhile to do stuff yourself :)
19:51:19 <hatds> do .ghci files not allow {- -} style comments?
19:54:26 <hpaste> “mysterious stranger” pasted “a flawed splitOn for miyako” at http://hpaste.org/50043
19:56:12 <byorgey> hatds: .ghci files allow whatever syntax is allowed at the ghci prompt
19:56:27 <byorgey> or so I would have thought
19:56:48 <sm> hatds: I don't think so
19:57:13 <hatds> huh, you can use {- -} at the prompt?
19:57:34 <byorgey> it turns out you can!  I just tried it
19:57:58 <sm> in one line only ? maybe :{ :} can help
20:00:38 <sm> can I set a cpp flag within a .hs file ? so any build including that file will set the flag without user having to type -DFLAG ?
20:01:44 <hatds> sm: I think so, via a 'GHC options pragma' http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/pragmas.html
20:02:43 <azaq23> sm: Well, you could do {-# LANGUAGE CPP -#} and then #define FLAG
20:02:55 <sm> perfect! thanks both
20:04:53 <sm> well, perfect would be no CPP, but it's the only way I've found of tweaking cmdargs options
20:05:40 * hackagebot narc 0.1.3 - Query SQL databases using Nested Relational Calculus embedded in Haskell.  http://hackage.haskell.org/package/narc-0.1.3 (EzraCooper)
20:05:53 <hatds> really?  what options are you addressing?
20:06:32 <sm> hatds: I posted on -cafe today.. I have different executables needing mostly the same but slightly different options
20:06:57 <sm> and they all need to speak to the underlying lib using a common options type
20:08:38 <sm> with cpp I can include all the variant fields in the options type, but enable them selectively
20:10:34 <sm> my options type is an algebraic data type. If I used something lower-level, like a list or map of string pairs, I would have this problem, but that seems sad
20:10:43 <sm> would not
20:12:31 <hatds> hmm
20:13:13 <hatds> if you are sharing a common lib for an options type, but your users actually want different ADTs, then the common code needs to be reorganized somehow
20:14:00 <sm> hatds: well.. I'm all ears, I haven't found a good way with cmdargs (or getopts really)
20:15:03 <sm> I can make it more concrete. There's a generic set of report options that should be available to all hledger-lib users. Ideally those would be defined in hledger-lib.
20:15:50 <sm> Each ui program (hledger, hledger-vty, hledger-web..) wants to expose those options on the command-line, plus add custom ones of its own
20:16:50 <sm> I'm sort of trying to use the same data structure for command-line option handling, and for passing to the lib to control its behaviour, but separating those two is ok too
20:18:32 <gwern> sm: I'm surprised cmdargs or getopt don't do something like 'consume as many args as possible and return a tuple of the parsed ADT and String of leftovers', so then you could supply a default parse function which ate the common subset, and each UI would then eat the String of leftovers
20:18:34 <sm> currently the hledger-lib api is awkward, because you have to prepare this clunky options datatype to get it to do anything
20:19:24 <sm> gwern: weell.. there may be way, but by default cmdargs will pass through unknown options only after --
20:19:52 <sm> I suppose I can do my own preparsing and mucking about with the args
20:20:13 <sm> it just gets more complicated the more I work on it ! :)
20:20:31 <hatds> there's two things that come to mind: one is that when you pass parameters (e.g., parsed options) to a library/function it is always better to only actually pass options that are relevant, even if that's less convenient (because you might already have a datatype for holding a big basket of settings)
20:20:31 <sm> not good
20:20:40 * hackagebot yesod-json 0.1.1.2 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-0.1.1.2 (MichaelSnoyman)
20:22:23 <hatds> the second is what gwern is getting at.  parsers that return a ADT aren't flexible enough
20:23:32 <sm> hatds: re 1, I agree, I think that's what I'm trying here: http://joyful.com/darcsden/simon/hledger/browse/hledger-lib/Hledger/Data/Types.hs#L-195
20:24:11 <sm> and I have a newer version of that complicating the api further
20:24:31 <sm> it may be time to step back
20:24:55 <hatds> all of that is poke'able from the command line? :0
20:24:56 <sm> re 2, that seems to be what I'm finding - ADTs are so nice, it's a pity
20:25:20 <hatds> I've been doing something new recently that may be relevant
20:25:47 * sm ponders how peek and poke will help
20:25:49 <hatds> I have my parsers return values through continuations in such a way that if you fill the continuations with constructors, you get the nice ADT
20:29:08 <singpoly1a> If I preferred to write brances and semicolons vs using signficant whitespace (which is seems haskell supports) -- would most haskellers be able to read that?
20:29:29 <hatds> the benefit is that you can write parsers for "subsets of your ADT" more cleanly... you don't have to decide what is or is not a variant in your ADT, your parser's continuations instead specify which variants they are parsing
20:30:10 <hatds> singpoly1a: they would be able to read it, although the preference is very much in favor of whitespace
20:30:46 <singpoly1a> hatds: sure
20:31:47 <sm> hatds: sounds clever
20:33:36 <sm> got to go, thanks all
20:40:36 <kmc> singpoly1a, a few people have uploaded code in that style to hackage
20:40:41 <kmc> because they are blind, and use screen readers
20:40:55 <kmc> people might yell at you if you have less of an excuse ;)
20:41:05 <kmc> but at the end of the day, free code is free code
20:41:39 <kmc> i don't remember how good the haskell-src-exts pretty-printer is, but it might be able to whitespace-ify your code automatically
20:42:21 <kmc> and certainly it's common to use braces-and-semicolons here and there, within a program generally written using layout
20:42:53 <kmc> nice that they really are equivalent, by construction
20:44:47 <hatds> you can use semicolons without braces too, for fitting two things onto one line
20:56:25 <mustelo> how do I get lambdabot to un z-encode something?
20:57:29 <kmc> preflex can do it
20:58:00 <mustelo> ah, thanks
20:58:01 <kmc> preflex, zdec zczuzuzuzuzuzc
20:58:01 <preflex>  ^_____^
20:58:45 <mustelo> he's just happy to get attention
21:03:50 <Ke> gaah
21:04:06 <Ke> where do I place the deprecated pragma
21:05:33 <kmc> i've seen it after the decl
21:07:04 <danharaj> preflex, preflex
21:15:43 * hackagebot alms 0.6.3 - a practical affine language  http://hackage.haskell.org/package/alms-0.6.3 (JesseTov)
21:20:43 * hackagebot aeson 0.3.2.11 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.3.2.11 (BryanOSullivan)
21:25:11 <sohum> okay, pixbufNewFromFile "m.png" is segfaulting on me
21:28:55 <Ke> well it seems I just had some other syntax error and the pragma was fine.
21:29:34 <Ke> I bet there is no way to call C function by address
21:29:43 <kmc> from haskell?
21:29:49 <kmc> there is
21:30:13 <kmc> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html look at the "mkFun" example
21:32:26 <kmc> (why would you phrase the question that way?)
21:32:27 <Ke> thanks
21:33:48 <Ke> well it seemed unprobable at that moment even though I had actually seen FunPtr before
21:34:46 <shachaf> All Ptrs are fun.
21:35:43 * hackagebot naturals 0.2.0.2 - Constructors and related functions for natural numbers  http://hackage.haskell.org/package/naturals-0.2.0.2 (ChristopherHoward)
21:36:21 <zzo38> The rulebook programming I want to implement and figure out how to compile (probably into Haskell) is similar to that of Inform 7 (refer to chapter 18 of the Inform 7 manual), although the Inform 7 rulebooks is insufficient, and Inform 7 is very insufficient. Do you know anything about this?
21:36:27 <zzo38> I can describe various examples (including both things in the Inform 7 manual and things that are not in Inform 7 at all) if you want example, please.
21:50:02 <guerrilla> 13:41 <pigworker> Hancock loves to quote (I forget from whom) "Do not worry about other people stealing your ideas. If your ideas are any good, you will have to force them down people's throats."
21:50:23 <NihilistDandy> lol
21:50:30 <fengshaun> nice one guerrilla
21:52:44 <hydo> definitely going to have to remember that one.
22:04:00 <hatds> zzo38: what is rulebook programming? You were talking about Mtg earlier.
22:10:52 <dolio> Magic: the Gathering?
22:10:52 <shachaf> Is there a name for \foo -> Just <$> foo `catch` const (return Nothing)?
22:11:06 <hatds> yes
22:11:07 <shachaf> I suppose I could call it that.
22:16:05 <quicksilver> shachaf: I have called it such daft things as "maybeOnError" or "errorToMaybe" or "liftToMaybe" or "hoistMaybe" - but I haven't liked any of them.
22:17:29 <wobsite> Hey - so I'm having a timing issue with a simple program that I'm not sure how to deal with. basically, I'm creating a channel (TChan), forking off a thread to send values down it at regular intervals, then reading them in from the other end and printing them out as they arrive. but I'm not seeing them printed out at regular intervals; they're somwhat erratic.
22:18:30 <quicksilver> wobsite: are you compiling with -threaded?
22:18:35 <wobsite> here's the code : http://pastie.org/2343378 it's behaving correctly, technically, but the timing won't do.
22:18:40 <wobsite> ah, no, I'm not
22:19:13 <quicksilver> I think you want to compile with -threaded and I have a strong suspicion you don't want to call SDL.Delay
22:19:15 <wobsite> ...but that doesn't seem to have an effect, when I do.
22:20:05 <quicksilver> SDL.delay will presumably lock up an entire FFI thread which is a very heavyweight way to delay, and might not use an accurate timer.
22:20:14 <wobsite> good call.
22:20:16 <quicksilver> use GHC's own threadDelay primitive
22:21:14 <quicksilver> of course, GHC's RTS is not real time scheduling. But it should be reliable enough for 30fps. I've written 60fps game demos with threadDelay and they've run smoothly enough.
22:21:36 <wobsite> yeah. not looking for real time, just not noticeable to humans.
22:23:04 <wobsite> ok, that did the trick, thanks. (with or without -threaded, actually.)
22:24:14 <hatds> DVP = digital video playback?
22:25:36 <wobsite> hah, no, "Dragon vs. Panda." a codename. just kinda toying around with some things.
22:26:33 <wobsite> probably a better name for that type could be found, though.
22:26:48 <hatds> sounds like a game :)
22:27:14 <wobsite> that's the notion.
22:27:43 <hatds> scheduling frames and simulations seems very complex to do right
22:28:27 <wobsite> mm. It's not going to be a particulary bleeding edge tech demo though, just a simple 2d thing.
22:28:51 <hatds> you still want to minimize input delay though
22:30:05 <wobsite> yeah. I'll cross that bridge when I come to it I suppose.
22:32:29 <dobblego> what is the name of the linux distribution that used haskell instead of typical shell scripting (or am I imagining it)?
22:32:53 <hatds> prompted by the reddit post?
22:33:13 <kmc> linspire had some tools in haskell
22:33:20 <kmc> i don't think it's like what you said
22:33:33 <dobblego> oh what is it like?
22:34:08 <NihilistDandy> I saw a package on Hackage recently that purported to enable Haskell as a simple scripting language.
23:59:27 * hackagebot css-text 0.1.0 - CSS parser and renderer.  http://hackage.haskell.org/package/css-text-0.1.0 (MichaelSnoyman)
