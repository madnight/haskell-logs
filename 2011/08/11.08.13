00:00:04 <edwardk> it could be sone of the diagnostics rendering code, thats about all i have that does array indexing
00:00:21 <edwardk> so you might have pushed one of the 'off by one' corner cases there one step too far
00:00:21 <mustelo> the other thing is that I'm in a very dumb terminal (emacs buffer)
00:00:27 <edwardk> ah
00:00:33 <edwardk> so the terminal probably gets old fast ;)
00:00:41 <mustelo> ha
00:00:55 <edwardk> or you mean that could be the source of the fault ?
00:01:45 <mustelo> well, I know you use some terminal libraries and stuff. maybe there's a corner case when the terminal is dumb
00:01:54 <edwardk> yeah
00:02:18 <edwardk> you can ransack the code for parseTest and put together a console-less version that uses pretty instead of prettyTerm
00:02:37 <mustelo> hmm, just got it to segfault again
00:02:51 <mustelo> ...hpasting...
00:03:47 <edwardk> hell. intern may be shot =(
00:05:00 <hpaste> mustelo pasted “ghci segfault parseTest -- edwardk” at http://hpaste.org/50256
00:05:06 <edwardk> i can probably resurrect it with the reflection hack, carrying a dictionary of the hash cons table in a quantified variable
00:05:22 <Entroacceptor> ghc-cabal: epollCreate: unsupported operation (Function not impl
00:05:24 <Entroacceptor> emented)
00:05:38 <Entroacceptor> while make installing ghc :(
00:06:05 <edwardk> ghci> parseTest mnemonic "bad"
00:06:06 <edwardk> (interactive):1:1: error: error, expected add, mov, mul
00:06:06 <edwardk> bad
00:06:14 <edwardk> with caret as expected
00:06:36 <mustelo> yeah, I've seen that behavior too :) not sure what's causing it to fail sometimes
00:07:20 <edwardk> i think i'm going to remove the hash consing from it until i have a chance to retackle intern
00:07:35 <edwardk> which is annoying because i _REALLY_ liked the asymptotics of comparing paths this way
00:09:02 <edwardk> i can probably make some kind of reifyCache :: (forall r. ReifiesCache r a => Proxy r -> w) -> w
00:09:27 <edwardk> which would make a hash consing table and hide it in a dictionary, but not let garbage collection clean it up
00:09:57 <edwardk> storing actual references, and then letting the closing of the reifyCache scope clean up the region of hash consed terms
00:16:57 <mustelo> edwardk, it's not the terminal. same behavior in xterm
00:17:17 <edwardk> going to try gutting the use of intern and push up a copy and see if that helps you
00:26:12 <edwardk> it may take me an hour or two, i'm using this opportunity to fix related stuff up
00:26:54 <mustelo> no worries. note that `parseTest (string "hello") "bad"` exhibits the same behavior for me: first time is array exception, second time is segfault
00:32:31 <edwardk> the array index is weirding me out
00:32:41 <edwardk> i only talk to an array at one point i can think of
00:32:49 * mustelo shrugs
00:32:53 <edwardk> and that is in Text.Trifecta.Diagnostics.Rendering.Prim
00:33:25 <edwardk> if you want to take a look and see if you can figure out if that is what is causing the problem, i'll go through and keep gutting the intern
00:33:34 <edwardk> er the intern library, that probably sounded wrong
00:34:00 <mustelo> haha. you gut the intern, I'll clean up the mess in the other room.
00:39:57 <mustelo> this is where we need simon marlow's new backtrace stuff
00:40:20 <shachaf> mustelo: By "this" you mean "Haskell in general", right?
00:40:39 <mustelo> shachaf, sure. this is my first real use case for it though
00:51:50 <alpounet> i've had many, many use cases for it
00:58:09 <_RIP_DREAMS> i'm having some trouble with the following: i want to generate a tuple with 2 random numbers (of integer type). if I try something like (randomRIO(1,2), randomRIO(1,2)) I'll get something of the form (IO a, IO a), which is not what I want.I could otherwise do x <- randomRIO(1,2), y <- randomRIO(1,2), (x,y), but I am left wondering whether there's something more suscint?
01:00:01 <mustelo> :t liftM2 (,)
01:00:01 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
01:00:15 <mustelo> _RIP_DREAMS, ^^ perhaps
01:02:19 <edwardk> (,) <$> randomRIO <*> randomRIO
01:09:51 <mustelo> edwardk, can you describe the bounds of a typical instance of `Lines`?
01:10:35 <edwardk> they start out as (0,beginning of line) to (-1, end of line) making them empty, then when you go to draw something i grow it to ensure there is room
01:10:52 <edwardk> the beginning of line to end of line is optimistic because in practice i have to clip to the screen
01:11:00 <_KY_> How do I remove "Just" from something?
01:11:16 <edwardk> so window will clamp it down to make it fit horizontally while keeping the target delta's column in focus
01:11:54 <mustelo> edwardk, so in my case, grow is being called with a lines instance whose bounds are  ((0,453890),(-1,-453890))
01:11:57 <edwardk> then when i render through 'draw' any attempt to draw outside of the bounds of the array should be trapped by the filter
01:12:04 <edwardk> hahahaha
01:12:16 <edwardk> then perhaps the bug is in window
01:13:07 <edwardk> the idea is that it tries to keep the column of the focus in view, while sliding left and right and only using at most the number of columns of the window width
01:13:26 <mustelo> yeah, mine's big, but it's not that big ;)
01:13:28 <edwardk> ideally i'd let it slop over a few more bytes on the right for dealing with long fixits as well
01:13:31 <edwardk> hahah
01:13:43 <edwardk> plus your upper bound is negative
01:13:44 <edwardk> so something hinky is happening
01:13:53 <edwardk> the 0,  and -1 look right
01:14:06 <edwardk> but those other two numbers should never be transposed like that
01:14:25 <edwardk> can you debug farther up and see what args window is getting?
01:14:30 <mustelo> yup, on it
01:15:39 <mustelo> window(0,3,-907779)
01:16:52 <edwardk> whoa
01:17:45 <edwardk> i may be getting gobbledigook out of terminfo or something when calculating column counts
01:17:55 <mustelo> sound like it
01:18:28 <mustelo> let me dive into wl-pprint-terminfo
01:18:32 <edwardk> can you go up a bit farther, that is being called in prettyTerm
01:18:36 <edwardk> yeah
01:19:10 <edwardk> i'd be curious what the nesting and column args are as well
01:19:29 <edwardk>   prettyTerm (Rendering d ll l f) = nesting $ \k -> columns $ \n -> go (n - k) , n - k is the crazy number
01:19:56 <mustelo> sure
01:20:21 <edwardk> it seems to be saying you are at nesting level something ridiculous and want to figure out how to draw a 3 character wide window in that set of constraints ;)
01:20:44 <edwardk> i can _mask_ the problem by just clamping to something reasonable, but thats icky
01:21:02 <mustelo> well let's dig a bit more before that
01:21:08 <edwardk> *nods*
01:21:35 * hackagebot snap-core 0.5.3 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.5.3 (GregoryCollins)
01:21:38 * hackagebot snap-server 0.5.3 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.5.3 (GregoryCollins)
01:21:40 * hackagebot snap 0.5.3 - Snap: A Haskell Web Framework: project starter executable and glue code library  http://hackage.haskell.org/package/snap-0.5.3 (GregoryCollins)
01:21:58 <edwardk> using the need to strip out all the intern plumbing for housekeeping. got the rope modules down to about half the amount of code
01:22:08 <mustelo> woot
01:22:46 <_KY_> How can I access the structure quoted inside "Just" ?
01:22:58 <mustelo> _KY_, what do you want to do to it?
01:23:31 <_KY_> mustelo: just pass it to a function that expects it instead of Maybe
01:23:50 <alpounet> are you sure it's not gonna be Nothing?
01:24:00 <_KY_> Yeah
01:24:06 <mustelo> > (Just 3) >>= (+5)
01:24:07 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
01:24:08 <lambdabot>    arising from a use of...
01:24:17 <mustelo> > (Just 3) >>= return . (+5)
01:24:19 <lambdabot>   Just 8
01:24:28 <edwardk> you can do a couple of things, you can map the function over the Just
01:24:39 <edwardk> giving you a new Just wrapped around your answer
01:24:43 <mustelo> > (+5) <$> (Just 3)
01:24:44 <lambdabot>   Just 8
01:24:46 <edwardk> or you can use pattern matching to pull it apart
01:25:01 <edwardk> foo (Just a) = .. do something with a
01:25:07 <alpounet> _KY_, if you are *100%* sure it's not gonna be Nothing, you can pattern match on it or use fromJust
01:25:11 <edwardk> foo Nothing = do soething when its not a
01:25:31 <alpounet> but you really should handle the case it's Nothing
01:25:32 <edwardk> finally, there is a convenient 'maybe' function that takes the two cases for pattern matching as arguments
01:25:34 <mustelo> edwardk, re: prettyTerm, nesting = 0, columns = -907777
01:25:35 <edwardk> @type maybe
01:25:35 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
01:26:27 <edwardk> > maybe 10 length (Just "some string")
01:26:28 <lambdabot>   11
01:26:36 <edwardk> > maybe 10 length Nothing
01:26:37 <lambdabot>   10
01:27:01 <edwardk> mustelo, hrm, ok, i definitely need a sanity check in terminfo then
01:27:12 <edwardk> can you check to see which branch is feeding you lies?
01:27:19 <mustelo> yeah
01:27:20 <edwardk> it tries 2-3 ways to guess the terminal width
01:27:38 <edwardk> if i had to guess its ncurses
01:27:56 <edwardk> because i only initScr for a split second
01:28:39 <_KY_> How can I use "let" to get the thing that is quoted by "Just"?
01:29:33 <opqdonut> let (Just x) = thing in expr
01:29:53 <_KY_> But I already have that in y
01:29:58 <opqdonut> > let a = Just 1; (Just x) = a in x
01:29:59 <lambdabot>   1
01:30:14 <alpounet> but in that case, if thing is actually Nothing, the program will stop
01:30:17 <opqdonut> yes
01:30:36 <opqdonut> > let a = Just 1 in case a of (Just x) -> x+1; Nothing -> 7
01:30:37 <lambdabot>   2
01:30:42 <alpounet> > let a = Nothing ; (Just x) = a in x
01:30:43 <opqdonut> > let a = Nothing in case a of (Just x) -> x+1; Nothing -> 7
01:30:43 <lambdabot>   *Exception: <interactive>:3:18-29: Irrefutable pattern failed for pattern (...
01:30:44 <lambdabot>   7
01:30:50 <alpounet> with that error :)
01:30:52 <_KY_> What if y is the thing "Just ...."
01:31:10 <_KY_> And I want x to be that "...."
01:31:29 <alpounet> then replace "a" by "y" in our previous codes
01:31:45 <opqdonut> _KY_: "let (Just x) = y"
01:31:51 <edwardk> > let Just x = Just 4 in x
01:31:52 <lambdabot>   4
01:32:02 <chrisdone> heh, hjscript won't let me write window.location.href = …
01:32:11 * chrisdone drops it
01:32:11 <opqdonut> _KY_: this is called pattern matching, looking inside the fields of a constructor with let
01:32:41 <_KY_> Oh that final one works =)
01:34:45 <aninhumer> What's the range of the Random Integer instance? Is it the same as Int?
01:35:28 <benmachine> it occasionally comes up with skewes' number
01:37:16 <alpounet> seems so yes aninhumer
01:37:49 <alpounet> instance Random Integer where { randomR ival g = randomIvalInteger ival g ; random g = randomR (toInteger (minBound::Int), toInteger (maxBound::Int)) g }
01:37:56 <benmachine> http://hackage.haskell.org/packages/archive/random/1.0.0.3/doc/html/System-Random.html
01:38:01 <benmachine> "For Integer, the range is (arbitrarily) the range of Int. "
01:42:02 <edwardk> benmachine: well they had to give up something
01:42:04 <chrisdone> k, hpaste has a report button now. please use it to report spam posts/you want deleting
01:42:17 <edwardk> either they give up the instance or they give up the 'uniformly distributed property
01:42:27 <edwardk> or they make up a new class that describes a locally finite ordeer
01:42:36 <efie> http://codepad.org/TyVeW0fl i guess it has something to do with the return type "IO [a]" but, id like to say shuffle [1,0,0] and get a shuffled list,but nothing is returned and instead i can type things in the dialogebox
01:42:49 <benmachine> what's a locally finite order?
01:42:51 <edwardk> and while i have one of those, i don't think that was within the scope ;)
01:42:55 <benmachine> also why am I still at home
01:43:15 <edwardk> given x and y, the set [ z | x <= z <= y ] is finite
01:43:27 <edwardk> the Integers satisfy this property
01:43:54 <edwardk> which is enough that you should be able to define randomR, if not random
01:44:26 <benmachine> well sure, randomR is defined sensibly
01:47:35 <mustelo> edwardk, you were right, it's ncurses.
01:47:42 <edwardk> figures
01:48:25 <edwardk> i guess i just need to figure out a way to make it not lie so badly or recognize when it lies
01:48:36 <mustelo> negative is a good hint :)
01:50:03 <edwardk> yeah i'll add a guard and check for < than some threshod and reset up to the 80 or let the other case just do so
01:50:16 <edwardk> wait
01:50:17 <mustelo> yeah, the other case already defaults to 80
01:50:19 <edwardk> first time it works?
01:50:40 <edwardk> maybe linux doesn't like me running initScr after i shut down the window
01:50:44 <mustelo> well, first time is what we're working on: the array exception
01:50:51 <edwardk> ah
01:51:07 <mustelo> massively negative index into an array that can't handle it
01:58:12 <mustelo> though I just looked and the segfault happens in ncurses too. it's in the scrSize call, not initScr. not sure what to make of that
01:59:40 <mustelo> edwardk, and that seems to indicate that even if the garbage coming out of ncurses is recognized, it's still a lost cause
01:59:47 <edwardk> yeah
02:00:04 <edwardk> i really like ncurses when it works ;)
02:00:52 <ivanm> preflex: seen chrisdone
02:00:52 <preflex>  chrisdone was last seen on #haskell 18 minutes and 49 seconds ago, saying: k, hpaste has a report button now. please use it to report spam posts/you want deleting
02:01:07 <ivanm> chrisdone: does haskell-emacs do syntax highlighting yet?
02:01:15 <chrisdone> ivanm: sure
02:01:33 <ivanm> using haskell-mode? or did you re-invent the wheel? :p
02:01:34 <chrisdone> it's not great, more of a placeholder. that's not the interesting part of the project. why?
02:01:40 <edwardk> ok, i simplified the code in the repo, i'll go tweak wl-pprint-terminfo now and see what we can see
02:01:58 <mustelo> alright, shall I pull and see if anything changes?
02:02:06 <ivanm> chrisdone: because I like coloured code when editing, and if haskell-emacs does it I might consider using that on this new setup rather than haskell-mode
02:02:31 <edwardk> bah, that is doing exactly what it should
02:02:40 <chrisdone> ivanm: it does colouring yeah
02:03:14 <chrisdone> ivanm: did you already try it? i asked a few people in here to try it and the process stuff works on linux as expected
02:04:39 <ivanm> @slap flakey network connections
02:04:40 * lambdabot karate-chops flakey network connections into two equally sized halves
02:05:05 <ivanm> chrisdone: so, is haskell-emacs in a usable state? will I be missing much as opposed to haskell-mode?
02:05:29 <ivanm> and no, I haven't tried it (after finding your reply on online logs :p)
02:05:54 <edwardk> i wonder if my ncurses book is still hiding on my shelf
02:06:09 <chrisdone> ivanm: you'll be missing indentation support—i don't use any of the provided ones, persoanlly… i use it daily at work, it's suited to me (probably too much, that's why i'd like more people to try it)
02:06:18 <ivanm> heh
02:06:26 <ivanm> I quite like indentation support... hmmm...
02:06:35 <ivanm> OK, fine, I'll try it
02:06:45 <chrisdone> try it out, in the README there's a one-liner to try it on a fresh emacs -q
02:06:53 <chrisdone> cd haskell-emacs; emacs -nw -Q -l examples/init.el
02:06:54 <ivanm> chrisdone: also: what can I do to convince you to use my graphviz library for flo?
02:08:07 <chrisdone> ivanm: i think i looked at it and couldn't actually find out how to write out dot syntax which is all i wanted. :p
02:08:08 <edwardk> mustelo: mind if i try to do a more direct binding and see if that gives you the same result?
02:08:19 <ivanm> chrisdone: so what does it need? more docs?
02:08:25 <edwardk> e.g. directly calling the foreign impot ccalls
02:08:38 <mustelo> sure, but I'm getting different results already with the fresh stuff from git
02:08:45 <chrisdone> ivanm: i think it's ok. i just didn't have time to sit and absorb it all
02:09:00 <chrisdone> it's only a prototype i whipped up for my colleague to try :)
02:09:05 <ivanm> heh, fair enough
02:09:06 <edwardk> i think i added some clamping, poorly in retrospect
02:09:36 <ivanm> I'm going to try and get the new version out this weekend (so people stop whining about the current version using an old version of polyparse :p) and one of the main changes is that I've tried to simplify aspects of it
02:09:37 <mustelo> (min (max (cols - 2) 30) 200)
02:09:41 <mustelo> shame
02:09:46 <edwardk> =)
02:10:14 <edwardk> that wasn't for you per se, so much as not wanting to deal with extreme aspect ratios and corner cases in the pretty printing
02:10:15 <mustelo> well, it works. stdScr still returns -907777. really likes that particular number
02:10:21 <chrisdone> ivanm: examples in the docs would be nice
02:10:31 <ivanm> right
02:10:44 <mustelo> edwardk, happy to try the direct bindings too
02:10:45 <ivanm> I've also got a tutorial I have started a while back but never finished
02:10:46 <chrisdone> like graphviz's homepage has examples of use
02:11:13 <ivanm> (mainly because the library didn't have the functionality I wanted for the tutorial :p)
02:11:27 <chrisdone> heh
02:11:56 <ivanm> that's mainly why this release has taken so long
02:12:00 <chrisdone> i'd just give an example for the simple case. that gives a good picture of how things work in general very quickly
02:12:02 <ivanm> I kept thinking of things to add :p
02:12:06 <chrisdone> hehe :)
02:12:18 <edwardk> going through behind the scenes in hscurses to see if they do anything exotic
02:13:03 <mustelo> I looked briefly and didn't see anything weird, but it was more of a glance
02:13:09 <ivanm> well, as a short list of whats new: pure haskell implementations of tred and dot -Tcanon, a simplified attribute system if you don't care about all of them, a graph-based representation, a monadic representation, now using Text rather than String, etc.
02:14:39 <ivanm> chrisdone: "cannot open load file: auto-complete"
02:14:53 <chrisdone> ivanm: are you using the line above?
02:15:02 <ivanm> yeah, but it wasn't from that directory
02:15:10 <chrisdone> lol
02:15:19 <ivanm> obviously I need to add that dir to the load path
02:15:29 <chrisdone> what dir are you running it from?
02:16:15 <chrisdone> cd haskell-emacs; emacs -nw -Q -l examples/init.el  # init.el adds the load-paths
02:17:25 <mustelo> edwardk, from the curses man pages: " A program that  needs  to
02:17:26 <mustelo>        inspect  capabilities, so it can continue to run in a line-oriented mode
02:17:26 <mustelo>        if the terminal cannot support a screen-oriented program, would also use
02:17:26 <mustelo>        newterm."
02:17:39 <mustelo> wow, sorry about newlines there
02:17:49 <edwardk> hrmm
02:18:08 <mustelo> not sure what that means at the hscurses level
02:18:40 <edwardk> its been like 15 years since i last used this thing, gah
02:19:51 <ivanm> chrisdone: I was trying to run it via a launcher
02:20:03 <ivanm> so, does this mean I _shouldn't_ try and use it with my everyday setup?
02:21:07 <chrisdone> lol it just means try it as instructed in the tutorial and see if you actually want to use it before doing the involved setup :p
02:21:46 <kamaji> Why can't I do this? data Matrix a = V.Vector (V.Vector a)
02:21:58 <kamaji> I previously did import qualified Data.Vector as V
02:22:07 <ivanm> chrisdone: heh, fair enough
02:22:12 <kamaji> I get "Qualified name in binding position"
02:22:25 <ivanm> thing is, that means that all my usual customisations (ido-mode, darcsum, etc.) aren't enabled :/
02:22:39 <mustelo> kamaji, you want s/data/type/ maybe?
02:22:40 <chrisdone> ido-mode is enabled in the init.el at least :p
02:22:49 <ivanm> oh... good-o ;)
02:23:04 <kamaji> mustelo: oh... apparently... why is that?
02:23:10 <kamaji> mustelo: also thanks ^^
02:23:38 <mustelo> well, if you want to use data, you need to give a constructor name before the vector stuff
02:23:46 <kamaji> oh right
02:23:59 <kamaji> makes sense.. thanks
02:24:09 <chrisdone> ivanm: ah, might wanna cabal install hasktags
02:24:24 <ivanm> OK, doing that
02:24:51 <chrisdone> ivanm: it uses hasktags to generate a TAGS file from your project, when you save files, and then the autocomplete and M-. stuff works
02:24:58 <chrisdone> i'll add that point to the readme
02:25:03 <mustelo> kamaji, more here: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
02:25:59 <ivanm> oh, I just use imenu
02:26:09 <ivanm> haven't really done tag stuff before
02:27:38 <chrisdone> i started fiddling with imenu recently. i wanted to be able to use the side bar thing with per file func/type browsing
02:29:32 <chrisdone> edwardk: http://chrisdone.com/crap/lang.avi
02:30:20 <mustelo> chrisdone, that's awesome. how do I get my hands on that
02:30:31 <edwardk> chrisdone i have to load anothermachine, on a mac ;)
02:31:04 <kamaji> How do I check the version of 'containers'?
02:31:06 <chrisdone> mustelo: heh, it's part of haksell-emacs, WIP: https://github.com/chrisdone/haskell-emacs
02:31:32 <edwardk> kamaji: i usually ghc-pkg list | grep foo -- i believe there is a more direct way
02:32:35 <kamaji> edwardk: I have containers 0.3 and 0.4 installed and it   seems to be causing problems :|
02:33:08 <edwardk> kamaji: yeah, ghc-pkg can unregister, but you need to be careful you can easily bork your entire installation ;)
02:33:52 <kamaji> erk :D
02:34:26 <chrisdone> ivanm: it works then?
02:34:33 <kamaji> is it just ghc-pkg unregister containers-0.3 ?
02:35:15 <ivanm> chrisdone: hang on! I need to get everything off my laptop onto this machine so I can actually hack on it!
02:35:22 <ivanm> too many damn uncommited patches, etc, :s
02:35:44 <edwardk> chrisdone: cute =)
02:36:01 <chrisdone> hehe
02:36:57 <edwardk> mustelo: i can give you an environment variable you can set to say that NCURSES_IS_BORKED ;)
02:37:20 <edwardk> kinda ugly if its a wider-spread problem than just you though ;)
02:37:38 <mustelo> yeah... I mean I use other ncurses apps, so what's specific here?
02:38:07 <edwardk> *nods*
02:38:40 <ivanm> chrisdone: OK, starting it up; when it says "Cabal dir", should I be looking for a project?
02:39:33 <edwardk> sadly, i'm stuck trying to put the ship together in the bottle. my system works fine, so i got nothing
02:40:30 <edwardk> i can make a parseTermEx that takes a TermDoc -> IO () action and uses that, and you can initialize it with displayDoc'' "xterm" 0.9 80 manually
02:40:33 <ivanm> chrisdone: OK, that initial "find directory" doesn't use ido or anything: no tab completion!
02:40:51 <edwardk> just to give you some path forward
02:40:58 <kamaji> I'm having a lot of trouble fixing this: cabal: dependencies conflict: ghc-7.0.3 requires containers ==0.3.0.0 however containers-0.3.0.0 was excluded because ghc-7.0.3 requires containers==0.4.0.0
02:41:06 <kamaji> when I try to install snap
02:42:14 <mustelo> edwardk, don't worry about it. at least not for now. I'm happy with the clamping hack
02:42:51 <mustelo> (which some how also solved the segfault problem...)
02:42:59 <edwardk> heh
02:43:06 <ivanm> chrisdone: and I had no idea when it asked me for the dir that that was the dir for ghci
02:43:12 <ivanm> now, how do I load the file into ghci?
02:43:20 <chrisdone> ivanm: f5
02:44:00 <chrisdone> ivanm: it prompts for the cabal dir and the ghci load dir, yeah. if you open another .hs file, if it's not in the same directory tree as any current projects open it'll prompt to choose or make a new one
02:44:16 <chrisdone> ivanm: by default that example starts a project by default, just to get things kicking
02:44:19 <ivanm> right, you could have made that clearer
02:44:33 <ivanm> and it tab-completion and ido don't seem to be working when you have to choose a dir
02:45:07 <ivanm> chrisdone: any inbuilt way of re-starting ghci when I've installed a new package?
02:45:19 <chrisdone> ivanm: hit :q and then it prompts to restart
02:45:19 <benmachine> kamaji: when you ghc-pkg list, is either of the containerses installed in your home directory?
02:45:23 <benmachine> ghc-pkg list containers
02:45:43 <ivanm> OK, it's frozen on me :p
02:45:45 <chrisdone> ivanm: i.e. quit with normal ghci :q and it asks to restart it. this is what i use when i install a new pkg
02:46:03 <chrisdone> ivanm: frozen?
02:46:06 <ivanm> yup
02:46:09 <chrisdone> why aren't you at camhac?
02:46:19 <ivanm> chrisdone: because I'm on the other side of the world?
02:46:21 <chrisdone> this would be much easier :p
02:46:35 <ivanm> I started doing :restart, and it started doing some kind of completion... and froze :/
02:46:39 * hackagebot wl-pprint-terminfo 0.5 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.5 (EdwardKmett)
02:46:51 <chrisdone> heh
02:46:57 <chrisdone> ivanm: Don't Follow Instructions :p
02:47:26 <chrisdone> "how do I restart?" ":q" "I put :restart" "T_T"
02:48:01 <chrisdone> hitting C-g doesn't stop it?
02:48:19 <mustelo> edwardk, that version of wl-pprint-terminfo doesn't build for me
02:48:25 <edwardk> ack
02:48:37 <edwardk> ah
02:49:24 <kamaji> benmachine: I think they both were, but I'm not up to date with my OS package manager
02:49:28 <kamaji> so i'll try that first
02:49:40 <edwardk> uploaded a fix
02:49:57 <benmachine> kamaji: unless ghc is entirely installed locally, I'm pretty sure at least one must be in the system dirs
02:50:39 <ivanm> chrisdone: I was starting to do that before you answered
02:50:44 <ivanm> and no, C-g doesn't work :s
02:50:55 <chrisdone> oh well mission failed
02:50:59 <edwardk> now to see how much of trifecta i broke by replacing 80% of the rope code ;)
02:51:08 <increpare> http://hpaste.org/50259 getting a "Could not deduce (b ~ b1)" error on a pretty simple-lookin' function - I don't understand what's going wrong with it
02:51:32 <kamaji> benmachine: ok, that's probably what's happened then
02:51:39 * hackagebot trifecta 0.27 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.27 (EdwardKmett)
02:51:48 <benmachine> kamaji: containers comes with ghc
02:51:58 <benmachine> kamaji: you want *only* the version that came with ghc to be installed, I think
02:53:00 <ivanm> chrisdone: OK, so does it actually have support for cabal-dev in that it will install every dep for you?
02:53:18 <mustelo> increpare, are you sure this is the right type? groupPairs :: Eq a => [(a,b)] -> [(a,[b])]
02:53:41 <mustelo> the [(a,[b])] part looks wrong
02:53:42 <benmachine> thatseems like a sensible type to me
02:53:43 <ivanm> chrisdone: OK, so I :q and tell it to restart, I then reload the file, it asks me which dir (again!), then it says I have to reload again
02:53:52 <ivanm> and there's no indication that I can see when it's loaded the file
02:53:55 <benmachine> mustelo: how so?
02:54:32 <benmachine> increpare: your problem is that your type signature in the where
02:54:38 <mustelo> oh I see, you want to merge everything with the same key
02:54:47 <benmachine> increpare: the a and b there don't necessarily mean the same thing as the a and b in the typesig of the function
02:54:56 <increpare> benmachine: oh.
02:55:02 <willem> When creating a package, how do you resolve conflicts between modules e.g. I have a function complete in module A and B of different types, should I rename the functions to completeA and completeB or do I expect users to import the modules qualified.
02:55:02 <chrisdone> ivanm: it says "OK" when it's loaded OK
02:55:18 <ivanm> right, in the minibar; it would be nice if it said so in the ghci buffer, as it's more obvious
02:55:23 <benmachine> increpare: you can use ScopedTypeVariables or just not put that sig there
02:55:26 <ivanm> (especially if you're doing something else whilst waiting)
02:55:33 <chrisdone> i'll make that an option, because i hate that
02:55:35 <increpare> benmachine: ok, thank you : )
02:55:45 <ivanm> chrisdone: even just the actual module you loaded?
02:55:55 <ivanm> I sometimes even do that with haskell-mode just to re-fresh the ghci environment
02:56:41 * hackagebot wl-pprint-terminfo 0.5.1 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-0.5.1 (EdwardKmett)
02:56:42 <chrisdone> I mean echo'ing "Loaded OK." 10 times whenever you recompile
02:56:43 * hackagebot data-list-sequences 0.1 - Utilities for working with sequences within lists.  http://hackage.haskell.org/package/data-list-sequences-0.1 (JonasKramer)
02:58:33 <chrisdone> maybe it can say "Loaded [5]" if you've loaded five times. but otherwise it's just a waste of space, and in the REPL i really concentrate of conserving screen space (hence why error messages are collapsed)
02:58:37 <mustelo> edwardk, things look not entirely broken. thanks for the help. let me know if you discover some ncurses magic
02:59:08 <edwardk> so in your current configuration, the screen goes to 80 columns fixed?
02:59:28 <ivanm> chrisdone: OK
02:59:43 <mustelo> edwardk, yeah
02:59:53 <edwardk> tolerable i guess
02:59:54 <ivanm> chrisdone: is't just that there's no way of knowing if/when you've loaded a file, so if you're not paying attention to the minibuffer there's no way of knowing when it's done
03:00:16 <ivanm> chrisdone: is the window setup configurable? I usually have ghci on the RHS :p
03:00:28 <edwardk> was it you who wanted the characterChar parser exported?
03:00:31 <chrisdone> ivanm: well, the point is you kinda *do* pay attention to the minibuffer if you want to know it's loaded
03:00:34 <mustelo> yeah
03:00:49 <edwardk> wanting to use it for parsing strings?
03:00:51 <chrisdone> the window setup is arbitrary for init.el. it's emacs; put it where you want
03:00:53 <ivanm> chrisdone: not if you're doing something else whilst waiting because you have a large number of buffers to load! ;)
03:01:04 <ivanm> chrisdone: so does f5 do :reload ?
03:01:09 <ivanm> or always :load ?
03:01:10 <chrisdone> a large number of buffers to load?
03:01:13 <edwardk> there are like 2 or 3 different in-string escape parsers in here is why
03:01:18 <chrisdone> it's :load
03:01:28 <ivanm> do you have a :reload?
03:01:35 <ivanm> I have a lot of large modules that get loaded... :/
03:01:38 <chrisdone> nope. never used that
03:01:41 * hackagebot cmdargs 0.8 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.8 (NeilMitchell)
03:01:43 * hackagebot multirec 0.6 - Generic programming for families of recursive datatypes  http://hackage.haskell.org/package/multirec-0.6 (AndresLoeh)
03:02:09 <chrisdone> I have 80~ modules in one project-- what does the number matter?
03:02:14 <mustelo> edwardk, my use case is parsing a simple assembly language which uses a prefixed backslash-single-quote instead of surrounding single quotes
03:02:25 <ivanm> it takes a long time to load them all up again?
03:02:31 <chrisdone> ivanm: don't you use -fobject-code?
03:02:38 <ivanm> chrisdone: {- ... -} -style comments aren't coloured
03:02:44 <edwardk> ah, k. i'll export both then
03:02:44 <ivanm> never heard of that one...
03:03:26 <chrisdone> ivanm: it generates .o files for everything loaded. then you only reload the modules that need to be reloaded. this is indispensable for a big project… without it i can only load one of my projects once in ghci, and after that it starts swapping like mad
03:03:41 <ivanm> chrisdone: and it doesn't like me using backspace to delete them :/
03:03:59 <ivanm> huh... don't think I've heard of it
03:04:03 <ivanm> where are the .o files loaded?
03:04:11 <ivanm> s/loaded/created/
03:04:17 <chrisdone> ivanm: they're put next to the .hs and .hi
03:04:17 <ivanm> does it muck up the source tree?
03:04:30 <ivanm> huh..... might investigate that with -outputdir
03:05:05 <ivanm> but yeah, not playing well with {- ... -} comments is really annoying
03:05:14 <ivanm> luckily using delete works
03:05:22 <chrisdone> yeah, that's paredit mode
03:05:37 <jkramer> Ahoy
03:05:46 <ivanm> ahhhh
03:05:47 <chrisdone> doesn't let you have unbalanced (),  {}, [] and ""
03:05:53 <ivanm> any way of dealing with that?
03:05:55 <chrisdone> type { and you get {|}, etc
03:06:13 <chrisdone> just migrating up stairs to hack on hackage, brb
03:06:16 <ivanm> maybe I'll just disable it; I'm not used to it and don't really need it
03:06:17 <ivanm> heh
03:06:19 <jkramer> I just uploaded my first package to hackage. How long does it usually take until the haddock docs are generated?
03:06:25 <shachaf> chrisdone: What if you type }? :-)
03:06:41 <chrisdone> shachaf: takes you to the nearest }
03:06:56 <ivanm> shachaf: OK, disabling paredit mode didn't do anything :/
03:07:02 <ivanm> jkramer: up to an hour
03:07:02 <shachaf> ivanm: ?
03:07:13 <chrisdone> it's not using paredit mode, it's keybindings
03:07:17 <chrisdone> brb!
03:07:25 * shachaf >>= undefined
03:07:33 <aninhumer> Where's the repository for HaskellTorrent? the git repo listed on hackage doesn't exist, looks like it's been deleted
03:07:40 <ivanm> shachaf: whoops, that was meant for chrisdone
03:09:07 <hnsz> I'm reading a book and want to try some things out but how do I get a basic program to run in codepad?
03:09:35 <ivanm> ..... why would you?
03:09:46 <ivanm> rather than using a local install?
03:09:56 <ivanm> though if you must, programs are defined by "main = ..."
03:10:23 <hnsz> ivanm: main = myFun  ?
03:10:40 <ivanm> assuming myFun is of type IO a, sure
03:10:52 <hnsz> ah right
03:11:28 <hnsz> ah well, I'll putty into something and use hugs
03:13:50 <tulcod> why doesn't 3 `(*)` 5 work?
03:13:58 <ivanm> tulcod: because you can't do that
03:14:17 <ivanm> also, note that you can't do: x `f y` z
03:14:28 <tulcod> ah
03:14:34 <tulcod> so i guess there are very strict rules to the use of `
03:14:48 <edwardk> the contents of the ``'s have to be a word (this notion is slightly stretched to allow for .'d paths to identifiers)
03:15:00 <merijn> tulcod: afaik it only works with a single identifier which is a function
03:15:00 <lambdabot> merijn: You have 1 new message. '/msg lambdabot @messages' to read it.
03:15:13 <edwardk> yeah otherwise it becomes a syntactic nightmare as one misplaced ` and you don't know where to resume nicely
03:15:42 <tulcod> a single identifier which is a function... works for me
03:15:51 <tulcod> thanks ivanm, edwardk, merijn!
03:15:55 <ivanm> np
03:15:59 <merijn> tulcod: Of course it is trivial to use let/where bindings to turn any arbitrary expression into something you can use with ` :p
03:15:59 <edwardk> you can make a data type and function with the right fixity to give you some kind of: foo -: bar baz quux :- quaffle   combinator for verbose infix
03:16:05 <rostayob> Is there a standard procedure to fix cabal packages when updating ghc?
03:16:18 <ivanm> rostayob: sure, install them all again
03:16:18 <tulcod> merijn: well yeah, so that's why i htought, why not allow it in the first place
03:16:32 <rostayob> ivanm: cabal install --reinstall world still leaves me with broken packages
03:16:43 <Spockz> dreixel_: can I two queries that look like ([] `mkQ` somethingright)?
03:16:53 <rostayob> i mean i could run it until everything works but that's not really practical
03:17:03 <merijn> tulcod: Mostly ease of parsing and generating sensible errors as edwardk says. I don't see myself wanting to use it for something complicated that much anyway :)
03:17:34 <edwardk> basically data RHS m r = m :- r      and l -: (m :- r) = … with an appropriate fixity to let you write them together
03:18:13 <edwardk> first time i saw that trick was something ken shan wrote many years ago
03:19:52 <ivanm> chrisdone: any particular reason why imenu doesn't work?
03:20:45 <dreixel> Spockz: I'm not entirely sure what you mean with "two queries"
03:20:49 <dreixel> can you give an example?
03:21:42 * hackagebot trifecta 0.28 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.28 (EdwardKmett)
03:21:52 <edwardk> mustelo: Text.Trifecta.Parser.Token.Prim now exports the characterChar parser for you
03:22:10 <mustelo> great, thanks!
03:22:30 <Spockz> dreixel: like this https://gist.github.com/6929558f6cadb7edf244
03:23:20 <ivanm> edwardk: OK, where is the docs on keybindings, etc.?
03:23:24 <ivanm> gah, not edwardk
03:23:26 <ivanm> sorry
03:23:29 <edwardk> hah
03:23:34 <ivanm> chrisdone: where are the docs on keybindings, etc.
03:23:41 <edwardk> for once its not one of my packages you're inquiring about ;)
03:24:03 <dreixel> Spockz: I see a problem
03:24:04 <edwardk> for a second i thought you were psychic or could see my screen and my current side-project ;)
03:24:21 <dreixel> Spockz: listConstructors and listFunctions have the same type
03:24:44 <dreixel> Spockz: so the override mechanism won't work as you want it to
03:25:21 <edwardk> (i was just playing with how to do keybindings with readline/editline/haskeline when you said that)
03:25:28 <Spockz> dreixel: ah yes I see
03:27:40 <Spockz> dreixel: I don't want to traverse multiple times, so how could I merge this? I would to keep my queries grouped by what they find, and not on which type they work
03:28:35 <dreixel> Spockz: newtypes?
03:29:13 <dreixel> Spockz: or group the queries, but indeed you will have to group them by what they match on, and not on what they find...
03:29:36 <Spockz> dreixel: I'll give the newtypes a try
03:31:54 <ivanm> edwardk: you looked busy enough tonight ;)
03:33:32 <edwardk> ivanm: well, its related. what i've been trying to figure out is how one would edit a grammar to annotate it with enough information to help with a.) fixits, and b.) let you run the parser to a point and ask for completions
03:34:24 <edwardk> so e.g. passing in a lexical scope to the identifier parser or capturing a continuation that'll let me pass it back later, etc.
03:35:21 <Itkovian> If I wish to store a custom datatype, say data D = A | B | C deriving (Show, Read) into a database, D should be an instance of Convertible D SqlValue, right?
03:35:32 <Itkovian> This seems like pretty straightforward.
03:36:01 <Itkovian> But to get it back, after having it stored as e.g., an SqlString "A" or SqlString "B", it seems more awkward
03:36:21 <Itkovian> If I understand it correctly, I need a convertible SqlValue D instance
03:37:11 <Itkovian> Yet, safeConvert (SqlString s) and checking for the possible values of s does not seem to be the right way, or is it?
03:39:14 <ivanm> depends on the database library
03:47:11 <Itkovian> HDBC.Sqlite3
03:47:51 <Itkovian> Normally the data retrieved from that table will only contain desirable values, so I should be able to do a read?
03:48:32 <jkramer> ivanm: Should the links to the module docs show up automatically on the package overview page when the docs haven been generated? Right now the modules are listed but there are no links.
03:50:05 <ivanm> chrisdone: how can I re-do previous commands in ghci?
03:50:15 <ivanm> jkramer: huh?
03:50:36 <jkramer> ivanm: Still about the haddock docs for freshly uploaded hackage packages :)
03:50:50 <ivanm> if it's just been uploaded, it takes a while
03:50:56 <ivanm> hackage does haddock runs in batches
03:51:37 <ivanm> which package is this?
03:51:42 * hackagebot data-endian 0.0.1 - Endian-sensitive data  http://hackage.haskell.org/package/data-endian-0.0.1 (MikhailVorozhtsov)
03:51:42 <jkramer> It's been a little over an hour now. I'm just wondering if the job already ran but failed, because the package overview is there but there are not links to the modules docs
03:51:46 <jkramer> ivanm: http://hackage.haskell.org/package/data-list-sequences
03:52:05 <ivanm> jkramer: it might be a bit over an hour
03:52:12 <ivanm> they're also hacking on hackage at camhac atm
03:52:27 <ivanm> if it ran but failed, it would say so
03:52:36 <ivanm> the package overview is there because it's from the cabal file
03:52:43 <ivanm> links to the modules happens when haddock is run
03:52:50 <jkramer> But is it normal that the package overview is there before the haddock docs and will the links on the overview be added when haddock has been run?
03:52:55 <jkramer> Ah ok
03:52:56 <jkramer> Thanks
03:55:31 <ivanm> chrisdone: the completion is also a little eager: I have a variable in ghci called dg; it keeps wanting to complete it to dgs and DGS (which I guess are from the tag files, because they're not in scope)
04:00:31 <ivanm> chrisdone: and the completion doesn't like it when you backspace, etc.
04:15:33 <ivanm> chrisdone: and the C-<right,left> commands interefere with using it for forward-{right,left} :/
04:16:41 <ivanm> chrisdone: another reason to not use just "OK": if you have compilation errors and then fix them, the compilation errors are still listed in ghci so I just thought I still had those same problems :p
04:23:11 <mistertim> Hi all - I was wondering if I could get a bit of advice on some code quickly - The following file doesn't compile and GHC suggests that the type of the 'reduce' member of the Simulation type is illegal in some way - however, It doesn't seem to mind the type of the 'runAgent' member of my Agent type which appears to be of a similar form - can anyone explain what the difference is, and how the signature of 'reduce' is illegal?
04:23:19 <mistertim> oh yeah, the file: https://gist.github.com/1143765
04:23:23 <mistertim> :-)
04:26:50 <ivanm> mistertim: for starters, I would suggest that m be a type parameter of your data type
04:27:04 <mistertim> ivan: aah, ok - that makes sense
04:27:06 <ivanm> and that you don't have the class restriction in the definitioin; just put it in your functions that use it
04:27:31 <ivanm> (since you need them there anyway)
04:27:40 <ivanm> e.g. runSim :: (Message m) => Simulation m a -> [a]
04:28:08 <mistertim> ivanm: aah, that's good advice also! however, can you explain the difference between the 'reduce' function and the 'runAgent' function that causes the compile error on one and not the other?
04:28:11 <ivanm> mistertim: in runSim, having "reducer = reducer s" is just asking for trouble down the track
04:28:21 <ivanm> as you may mix up which "reducer" value you're referring to
04:28:32 <mistertim> aah, good spot - that wasn't intentional :-)
04:28:47 <ivanm> ummm.... no idea tbh
04:29:10 <ivanm> mistertim: could just be that ghc hasn't really analysed Agent yet
04:29:37 <ivanm> (since you don't seem to be using Agent yet)
04:29:52 <ivanm> oh, you do, inside runSim
04:29:53 <mistertim> ivanm: aah, that would make sense - I don't know why i assumed it would analyse Agent first
04:30:14 <ivanm> mistertim: put it this way: if you fix up Simulation and then it bitches about Agent, that's the reason ;)
04:30:29 <ivanm> mistertim: for readability, you probably want to consider splitting your data types over multiple lines
04:30:37 <mistertim> aah cool, I think I'll parameterise my Simulation type by the type of message too
04:30:43 <mistertim> as you suggest - thanks!
04:33:26 <merijn> mistertim: Also, personally I prefer using $ to parenthesis in lines like: functions = map (starling runAgent agentId) (agents s)
04:33:52 <merijn> But that's largely personal preference, I guess
04:34:43 <ivanm> merijn: yeah, in that case it's short enough that it doesn't make too much of a difference
04:34:50 <ivanm> but using $ is usually more scalable
04:35:15 <ivanm> until you start using it with other operators like >> ... :s
04:35:27 * ivanm has spent a _lot_ of time working out wtf is with type errors before realising that's it
04:36:23 <mistertim> merijn aah good point - I can get as far as 'map  (starling runAgent agentId) . agents $ s' but can't quite see how to get rid of the other parens
04:37:01 <merijn> I'd do it simpler: functions = map $ starling runAgent agentId $ agents s
04:37:08 <mistertim> aha!
04:37:14 <mistertim> yep that's much nicer
04:37:55 <mistertim> I forget that $ also associates to the left
04:38:32 <ski> it doesn't
04:38:40 <mistertim> oops... to the right?
04:38:55 <ski> `f $ g $ x' means `f (g x)'
04:39:04 <ivanm> merijn: yeah, I'm not a big fan of that style
04:39:05 <merijn> Oh wait, did I screw it up again then?
04:39:28 <ivanm> @type map $ (<) 3 $ [1..10]
04:39:29 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Bool'
04:39:29 <lambdabot>     In the second argument of `($)', namely `(<) 3 $ [1 .. 10]'
04:39:29 <lambdabot>     In the expression: map $ (<) 3 $ [1 .. 10]
04:39:44 <ivanm> @type map ( (<) 3) $ [1..10]
04:39:45 <lambdabot> [Bool]
04:39:56 <merijn> > map $ (+1) $ [1..10]
04:39:57 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[t]'
04:40:01 <mistertim> aha
04:40:01 <merijn> ah, bollocks
04:40:07 <merijn> I did screw it up
04:40:13 <ivanm> I knew there was a reason I didn't like that style :p
04:40:16 <mistertim> cool, nevermind - one lot of parens ain't too bad :-)
04:40:25 <mistertim> Thanks a lot everyone!
04:40:26 <ivanm> that said, there have been a few people that have advocated left-associative $
04:40:31 <ivanm> and some packages re-define it that way
04:40:37 <ski> (otoh, one might argue that `$' ought to associate to the left)
04:40:45 <mistertim> i can see the argument
04:41:05 <ski> at least for `$!', that would be handy
04:41:12 <merijn> :t ($!)
04:41:13 <lambdabot> forall a b. (a -> b) -> a -> b
04:41:25 <merijn> Strict function application?
04:41:27 <ski> @src foldl'
04:41:27 <lambdabot> foldl' f a []     = a
04:41:28 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
04:42:18 <ski>   foldl' f a (x:xs) = (foldl' f $! f a x) xs
04:42:34 <ski> that could have been written as
04:43:05 <ski>   foldl' f a (x:xs) = foldl' f $! f a x $ xs
04:43:17 <ski> if `$!' and `$' associated to the left
04:43:42 <ski> @src $!
04:43:42 <lambdabot> f $! x = x `seq` f x
04:45:09 <jmcarthur> mistertim: functions = starling runAgent agentId <$> agents s
04:45:45 <Taejo> does ARR_WORDS in a heap profile indicate an array?
04:55:24 <HugoDaniel> hey
04:57:23 <ivanm> hey HugoDaniel
04:57:31 <ivanm> preflex: seen thoughtpolice
04:57:32 <preflex>  thoughtpolice was last seen on #haskell 6 hours, 29 minutes and 55 seconds ago, saying: so lots of stuff will fail to build
05:11:20 <ivanm> chrisdone: for syntax highlighting, it's annoying that "as" is highlighted in non-import lines
05:15:01 <Kosh_> hi
05:15:27 <mistertim> jmcarthur - oh, nice! thanks
05:16:04 <Kosh_> What is a saturated constructor?
05:16:56 * ski assumes it's a constructor that has been applied to all its parameters
05:19:33 <Taejo> :t iterate
05:19:34 <lambdabot> forall a. (a -> a) -> a -> [a]
05:21:42 * hackagebot HaXml 1.22.5 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.22.5 (MalcolmWallace)
05:23:11 <Kosh_> > let a = Just
05:23:12 <lambdabot>   not an expression: `let a = Just'
05:23:17 <Kosh_> > let a = Just in a
05:23:18 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> Data.Maybe.Maybe a)
05:23:18 <lambdabot>    arisin...
05:23:26 <Kosh_> > let a = Just 5 in a
05:23:27 <lambdabot>   Just 5
05:23:35 <Kosh_> > let a = Just  in a 5
05:23:35 <lambdabot>   Just 5
05:23:59 <Kosh_> > let a = (:) 5 in a
05:23:59 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
05:24:00 <lambdabot>    arising from a use ...
05:24:17 <Kosh_> > let a = (:) 5 in a 7
05:24:18 <lambdabot>   No instance for (GHC.Num.Num [t])
05:24:18 <lambdabot>    arising from a use of `e_157' at <inte...
05:24:24 <Kosh_> > let a = (:) 5 in a []
05:24:25 <lambdabot>   [5]
05:25:08 <Kosh_> is ((:) 5 ) a no saturated constructor?
05:26:59 <rostayob> is anybody using ghc-mod?
05:29:56 <merijn> Kosh_: ((:) 5) is not a saturated constructor, no. Since (:) takes two arguments
05:32:38 <Kosh_> ok
05:41:43 * hackagebot hssqlppp 0.3.1 - SQL parser and type checker  http://hackage.haskell.org/package/hssqlppp-0.3.1 (JakeWheat)
05:46:55 <mistertim> Here's a question - is there any advantages or disadvantages to one or other of the following approaches to using the WriterT monad transformer over the other, when you have more than one type of value that needs to be written? "MultiWriter a b = WriterT a WriterT b Identity" or "MultiWriter' a b = WriterT (a, b) Identity"
05:47:10 <mistertim> god sorry, that's a really badly written sentence
05:47:31 * mistertim should read through what he's written before pressing <enter>
05:52:10 <ivanm> mistertim: well, the latter requires you always write (a,b), does it not?
05:52:20 <aninhumer> Is there a data structure in the standard library that combines Map and Queue properties, i.e. O(logn) or better key lookup, and O(1) lookup for the first node inserted?
05:52:29 <ivanm> the former lets you write either an a or a b, but you have to use lift to get the inner writer
05:52:42 <ivanm> aninhumer: Queue = Seq ?
05:52:56 <aninhumer> ivanm: most likely
05:53:24 <ivanm> what do you mean by "O(1) lookup for the first node inserted" ?
05:53:48 <ivanm> oh, I think I see what you mean...
05:53:51 <rostayob> mistertim: well (a, b) is not a monoid in the first place, what sense does it make to have that as the Writer type?
05:53:57 <aninhumer> Queue as in FIFO
05:54:19 <ivanm> I doubt such a structure exists: the latter implies a linear lookup
05:54:21 <rostayob> aninhumer: priority search queue
05:54:41 <ivanm> rostayob: that gives you O(log n) lookup for the queue?
05:54:42 <ivanm> huh
05:55:19 <rostayob> ivanm: yes
05:56:06 <rostayob> well wait, accessing the head is not O(1)
05:56:36 <rostayob> no sorry, it does lol
05:56:36 <Nisstyre> yes
05:56:42 <rostayob> yes I got confused
05:57:00 <rostayob> deleting the head is O(log n)
05:57:13 <rostayob> aninhumer: anyway yeah a PSQueue should work
05:58:31 <aninhumer> rostayob: yeah this looks like what I asked for... whether it's what I actually want though... :P
06:00:23 <mistertim> rostayob: sorry, i meant [a] and [b] rather than [(a,b)]
06:00:39 <mistertim> rostayob: I think i might just have answered my own question
06:01:44 * hackagebot xss-sanitize 0.3.0.1 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.0.1 (GregWeber)
06:03:12 <rostayob> so you mean [(a,b)] or [a] and [b]?
06:04:04 <rostayob> if you can use the [a,b] with a single monad it will be simpler and faster, but in that case you'd have to put the two types always in couples, which probably won't be the case
06:04:18 <rostayob> *[(a,b)]
06:05:30 <mistertim> rostayob: this was pretty much my thinking- I guess I'm confused about how you make the entire transformer stack into an instance of MonadWriter if there are two writer 'layers' within it
06:06:05 <mistertim> in my use case I need to be able to write to the two different writers seperately, so this won't necessarily be the case
06:06:22 <mistertim> sorry, that makes no sense
06:06:35 <rostayob> mistertim: well WriterT [a] (WriterT [b] Identity) is already a MonadWriter
06:06:44 * hackagebot swish 0.4.0.0 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.4.0.0 (DouglasBurke)
06:06:44 <mistertim> rostayob - aah, ok
06:07:28 <rostayob> but writing the inner list will be kind of awkward
06:07:30 <mistertim> that's interesting - I wonder what the tell function does for that instanec
06:07:38 <mistertim> aah - it writes to the outer writer
06:07:42 <rostayob> yep
06:07:51 <mistertim> ok, so to write to the inner, i have to lift and 'tell' the inner layer
06:07:55 <mistertim> gotcha
06:08:03 <rostayob> yes
06:08:13 <mistertim> I can wrap that up into a helper function though so that shouldn't be a problem
06:08:18 <rostayob> actually it's not awkward
06:08:20 <rostayob> yes
06:08:22 <mistertim> thanks a lot, I think that's the way i need to go
06:09:08 <rostayob> cool
06:16:44 * hackagebot fclabels 1.0 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.0 (SebastiaanVisser)
06:19:16 <Rc43> Hi, guys.
06:20:26 <Rc43> I am newbie, can anybody explain, why in this example http://pastebin.com/Ns6efPcF second part is not correct (ghc can't compile it) ?
06:20:28 <mauke> The paste Ns6efPcF has been copied to http://hpaste.org/50262
06:21:13 <Rc43> It talks something about Data.Functor.Identity.Identity, I dont understand.
06:23:13 <sjoerd_visscher> try: asks (fst.head)
06:24:46 <Rc43> Yes, it fixed strange problem with identity, but there is problem with type k and v.
06:27:00 <Rc43> And as i understand, this problem equals to such:
06:27:06 <Rc43> tst3 :: [(k,v)] -> v
06:27:06 <Rc43> tst3 = fst.head
06:27:59 <Rc43> Haha, sorry, i mistyped.
06:28:17 <Rc43> [(k,v)] -> k of course, now everything is alright
06:29:22 <chrisdone> ivanm: i'm judging by all your criticisms that you intend to use it ;)
06:29:41 <ivanm> chrisdone: I'm finding it quite nice overall
06:29:46 <ivanm> the ghci integration is rather good
06:30:02 <ivanm> (though it misbehaves with some multiline stuff)
06:30:27 <ivanm> chrisdone: docs would be nice, at least detailing your workflow so that I know how it's meant to be used
06:30:38 <ivanm> (even in terms of using cabal-dev)
06:30:48 <ivanm> as for saying using -fobjects, etc., where do you specify that?
06:31:04 <chrisdone> I just put it in my ~/.ghci as I rarely don't want it
06:31:17 <chrisdone> :set -fobject-code
06:32:09 <ivanm> ahhhhh
06:32:15 <ivanm> that makes sense
06:32:27 <ivanm> since I didn't find any settings there for ghci
06:32:45 <chrisdone> ah ok
06:34:03 <chrisdone> the keybindings aren't set in stone, they're just what I use, configure as you like
06:34:07 <ivanm> yup
06:34:15 <chrisdone> I use C-f/C-b. I never use the arrow keys
06:34:33 <chrisdone> (so I thought it fitting to use for movement in this case)
06:34:51 <chrisdone> do you find the C-left/right function (not the bindings) useful?
06:34:57 <ivanm> yeah, I use it when doing C-<space> C-<right> C-w, etc.
06:35:09 <ivanm> the indentation/un-indentation?
06:35:13 <chrisdone> yeah
06:35:13 <ivanm> so far, I just do it by accident :p
06:35:18 <ivanm> so haven't really played with it
06:35:27 <ski> (`C-SPC M-f C-w' ?)
06:35:28 <chrisdone> I wonder how I got by without it now
06:36:07 <chrisdone> ah, hit f8 to go to import lines and C-cC-. aligns/sorts your imports
06:36:14 <chrisdone> do you know any elisp?
06:36:15 <ivanm> there are some cases I"d like the indentation to be smarter (e.g. creating a record block { ... }, and wanting to hit enter with a comma; the first line you want a comma you need to indent again; after that it's OK)
06:36:18 <ivanm> some
06:36:30 <ivanm> enough to slowly work my way through what's going if need be
06:36:44 <tarrasch> Does cabal use anything else than what's in ~/.cabal? I thought of having 2 cabal folders, one where I only install tested packages from hackage and one where I install things that could break anything. Is that an OK idea?
06:37:00 <ivanm> tarrasch: maybe cabal-dev for the latter?
06:37:03 <mistertim> tarrasch: have you looked at using cabal-dev?
06:37:12 <chrisdone> the indentation is kind of a big TODO. the existing haskell-mode ones are really big and complicated, but it's trivial to find cases where they break down. I'd rather implement indentation with a crap load of unit-tests
06:37:27 <mistertim> tarrasch: you can use it to sandbox installed packages within certain projects
06:37:35 <tarrasch> Nope, but it sounds like the thing im looking for
06:37:58 <paper_cc> hmm. I remember that some functional language was doing side-effects and exceptions using free algebras rather than monads, but I can't remember which one; can someone help me?
06:38:25 <tarrasch> Certainly I'm not alone getting thrown into dependency hell, or?
06:38:36 <ivanm> chrisdone: I think the biggest problems I'm finding are (in no specific order): incomplete highlighting (block comments, keywords like "as" being highlighted in non-import statements, etc.); some fudginess in the ghci stuff (worked out that M-{p,n} repeated lines, but sometimes if something went wrong it got stuck at a multi-line, can't easily repeat a line from way back found with C-r, etc.) and no easy way to move around (imenu doesn't work, and something
06:38:36 <ivanm>  is iffy with the TAGS stuff)
06:38:41 <chrisdone> dependency hell is a rite of passage
06:39:05 <ivanm> paper_cc: maybe DDC ?
06:39:11 <ivanm> preflex: seen m3ga
06:39:12 <preflex>  m3ga was last seen on #haskell 36 days, 7 hours, 1 minute and 26 seconds ago, saying: yeah, shachaf is right
06:39:31 <chrisdone> ivanm: what's iffy with the tag stuff?
06:39:34 <paper_cc> ivanm: no, not Disciple
06:39:45 <ivanm> chrisdone: M-. doesn't seem to list all functions in scope
06:39:56 <ivanm> but when I do the command to list all TAGS for that file, it has them all there
06:39:59 <ski> > ("a","b") `mappend` ("c","d")  -- rostayob,ivanm,mistertim
06:40:00 <lambdabot>   ("ac","bd")
06:40:39 <ivanm> ski: my comment earlier was that if you don't want to always have an a and b value, then having Writer (a,b) isn't correct; you can do more stuff with Writer a (Writer b)
06:40:47 <ivanm> (assuming the types are correct :p)
06:40:58 <ski> ivanm : `tell (mempty,b)'
06:41:16 <ivanm> ski: oh, so as long as a and b are both Monoids? fair enough
06:41:39 * ski figured that was obvious, judging from mistertim's question
06:41:48 <chrisdone> ivanm: M-. is find-tag, yeah
06:42:06 <chrisdone> when does it list things?
06:42:11 <ski> you can only use `WriterT a (Writer b)' if both `a' and `b' are monoids
06:42:13 <mistertim> tarrasch: not in the slightest  :-)
06:43:07 <ivanm> chrisdone: list-tags has tags that M-. doesn't have
06:43:12 <ski> ivanm : so, ignoring `OverlappedInstances', `(a,b)' is only a monoid iff `a' and `b' is
06:43:14 <ivanm> probably not your fault though
06:43:19 <ivanm> ski: *nod*
06:43:31 <ivanm> chrisdone: oh, also: the completion stuff is a little iffy: some odd delays, it is sometimes too eager to add a completion (so I have to delete it) and sometimes it wants to add in nonsensical completions from who knows where, but doesn't list sensible ones
06:43:38 <tarrasch> mistertim, Have you used cabal-dev, have it helped?
06:44:00 <ivanm> chrisdone: at the very least, it would be nice if completion on modules (both within ghci for :m and import statements) only contained module info
06:44:04 <ivanm> not sure if that's possible
06:44:05 <chrisdone> ivanm: you know you can just keep typing over the completion right?
06:44:07 <ivanm> just suggestions ;)
06:44:35 <ivanm> chrisdone: yeah, but in the ghci buffer, I go to type: foo dg <enter>
06:44:36 <paper_cc> aha, got it. it was Eff (http://math.andrej.com/category/eff)
06:44:37 <chrisdone> yeah context-specific completion would be better
06:44:50 <luite> hmm, where is the completion stuff from? I don't think I have that in my emacs
06:44:51 <chrisdone> ivanm: oh, yeah, ret is 'choose completion' sometimes. that's annoying yeah
06:44:52 * ski recalls the DrScheme^WRacket repl copies down the older input that one found with search to the current prompt, when one presses return
06:44:54 <chrisdone> that's from autocomplete.el
06:44:56 <ivanm> as soon as I type the "dg", completion comes up, listing dgs, and thus the enter selects it instead of sending the command through to ghci
06:45:14 <ivanm> luite: from chrisdone's haskell-emacs stuff
06:45:25 <ski> i wonder if it would be hard to implement something like that in `*ghci*'
06:45:32 <luite> ah
06:45:37 <ivanm> chrisdone: OK, I think that's my four biggest bug-bears; not sure how much of it is your fault, but you have my feedback
06:45:43 <chrisdone> ski: mine does that
06:45:44 <luite> I'm still using just an old haskell-mode
06:45:51 <ski> chrisdone : nice :)
06:46:02 <ivanm> chrisdone: did you have a look at ghc-mod when developing haskell-emacs?
06:46:09 <ivanm> it claims to have some similar functionality to yours
06:46:19 <chrisdone> yeah ghc-mod is ok but I could never get it to work
06:46:19 <ivanm> (tag-based completion, etc.)
06:46:24 <ivanm> *nod*
06:46:57 <ivanm> chrisdone: I've got to hit the sack; any chance of having "the official chrisdone workflow for using haskell-emacs" by the time I get back to hacking (probably tomorrow arvo) ? ;)
06:47:18 <chrisdone> sure
06:47:23 <rostayob> ivanm: I've actually been trying to have ghc-mod working for 3 hrs today
06:47:24 <rostayob> no success
06:47:30 <mistertim> tarrasch: yep - i keep each project sandboxed in its own repo now, and start new projects for playing with experimental stuff
06:47:32 <chrisdone> rostayob: try haskell-emacs :p
06:47:42 <rostayob> chrisdone: you mean haskell mode?
06:47:43 <ivanm> chrisdone: because I've never used cabal-dev, etc. before and it seems your stuff would work much better with it than what I'm doing now
06:47:58 <ivanm> rostayob: no, haskell-emacs is chrisdone's new from-scratch haskell support for emacs
06:48:05 <ivanm> much more project-based/IDE-ish than haskell-mode
06:48:17 <rostayob> I've had autocomplete working for a while but it's completely non context-sensitive, it just collects words and suggests them
06:48:22 <rostayob> oh cool!
06:48:34 <ivanm> rostayob: yeah, unfortunately that's all chrisdone has got going so far as well
06:48:52 <rostayob> does it have type lookup and jumping to definitions? that's mostly what I need
06:49:02 <rostayob> auto completion is a lot less useful in haskell then in OO languages
06:49:10 <chrisdone> yeah it has jumping
06:49:17 <ivanm> but jumping was giving me issues
06:49:26 <ivanm> but that could be because of dodgy TAG support
06:49:30 <rostayob> oh that's really cool
06:49:33 <ivanm> I don't think that's chrisdone's fault
06:49:40 <rostayob> I've always wanted cscope for haskell
06:50:19 <chrisdone> if you type foo<space> it shows the :i info for it in the minibuffer, for types and functions. marginally useful
06:50:26 <mistertim> So, i've just come up with this little combinator to take a list of monadic actions and create a new one that distributes its input to all of them, executing them in sequence: https://gist.github.com/1143893. It seems like a fairly natural thing to want to do, yet I haven't found anything similar in any libraries - is it because it's either (a) more of a corner case than I supposed, (b) a hideous abomination in some respect,  and a technique that should be a
06:50:26 <mistertim> voided, or (c) there's something similar that exists already and I just didn't spot it? :-)
06:50:27 <chrisdone> ivanm: yeah i'll write a wee guide of my workflow
06:51:17 <rostayob> chrisdone: I will definitely try it
06:51:18 <ivanm> chrisdone: oh, completion happens inside comments as well...
06:51:30 <ivanm> and multiline -- | style comments don't have subsequent lines highlighted the same
06:51:35 <chrisdone> ivanm: yeah i know about that
06:51:59 <chrisdone> the hs-mode is more of a placeholder until i get something decent in place, but at least i understand every line of code in it
06:52:30 <ivanm> chrisdone: oh, weird things happen with \ chars
06:52:42 <ivanm> I wanted to escape a " in a haddock comment... it refuses to let me insert the "
06:52:59 <chrisdone> yeah that's a paredit problem
06:53:17 <ivanm> OK
06:53:18 <chrisdone> i might just take the code from paredit and patch it
06:53:27 <ivanm> so if I get rid of all your paredit keybindings it should be right?
06:53:32 <chrisdone> \ is escape characters for lisp
06:53:35 <chrisdone> yeah it'll be fine
06:55:23 <ivanm> OK
07:10:40 <mm_freak> given an IntMap or IntSet, what complexity does it have to find that a key is /not/ contained in the map/set, if the key is larger than the largest key/member?
07:11:06 <mm_freak> like in an IntSet containing 10, 20, 30, how long does it take to find that 40 is not a member?
07:11:18 <mm_freak> still O(log n) or just O(1)?
07:15:31 <willem> When creating a package, how do you resolve conflicts between modules e.g. I have a function complete in module A and B of different types, should I rename the functions to completeA and completeB or do I expect users to import the modules qualified (or is this a question of taste?).
07:16:12 <mm_freak> willem: it's a question of taste…  generally there is nothing wrong with modules with name clashes
07:16:49 <mm_freak> willem: my way of handling this is to have an auxilliary module, which reexports all important modules and perhaps wraps them in a different interface in some way
07:17:03 <c_wraith> and honestly, there aren't that many good names, overall.  Many things are designed to be used imported qualified, because it just makes the names easier.
07:17:52 <mm_freak> a name is good, when you can memorize it and connect it to its purpose easily
07:18:16 <mm_freak> like >>=, <*>, ***, =>>, >=>, <|>, fix, …
07:18:47 <willem> yeah the problem was just functions 'complete :: TypeX -> IO ()' in different modules with different types for TypeX
07:18:50 <mm_freak> but seriously, clashing alphanumeric names are fine
07:19:06 <mm_freak> but clashing symbolic names are a pain in the ass…  be sure to use symbols, which aren't very common
07:19:38 <mm_freak> willem: sometimes, when functions have the same name, they may have something in common, which you could encode as a type class, thereby eliminating the name clashing
07:20:47 <willem> mm_freak: you got a point there, It's in a binding library to a c library so I'll see if it makes sense.
07:26:31 * increpare cusses at Data.Graph
07:27:58 <Taejo> am I evil if I define an instance of AdditiveGroup with negateV = undefined?
07:28:21 <thoughtpolice> ivanm: ping
07:30:07 <jmcarthur> Taejo: yes. that kind of defeats the purpose of AdditiveGroup
07:30:18 <jmcarthur> Taejo: you might as well just use Monoid
07:31:30 <jmcarthur> i'm guessing, though, that you are wanting to use AffineSpace but don't have an inverse for your Diff type?
07:32:10 <jmcarthur> if so this is an interesting coincidence because i am dealing with a similar situation (although i am not using the vector-space package right now)
07:32:57 <jmcarthur> but my troubles are implementation dependent. the denotation of my type says it should be a valid AdditiveGroup instance
07:40:07 <chenwl> what is the difference between (_:t) and ~(_:t) in pattern matching
07:40:57 <jmcarthur> chenwl: the former always forces the (:) constructor, but the latter only does so if you force t
07:41:02 <roconnor> chenwl: ~(_:t) won't mach the constructor until t is used.
07:41:36 <roconnor> > case undefined of ~(_:t) -> 7
07:41:36 <lambdabot>   7
07:41:39 <roconnor> > case undefined of (_:t) -> 7
07:41:39 <lambdabot>   *Exception: Prelude.undefined
07:41:43 <jmcarthur> chenwl: you will mostly want to avoid using lazy pattern matching (the ~ version) unless the pattern is irrefutable
07:41:44 * hackagebot JsonGrammar 0.3.1 - Combinators for bidirectional JSON parsing  http://hackage.haskell.org/package/JsonGrammar-0.3.1 (MartijnVanSteenbergen)
07:41:49 <roconnor> > case undefined of ~(_:t) -> 7:t
07:41:50 <lambdabot>   [7*Exception: Prelude.undefined
07:42:05 <roconnor> > head (case undefined of ~(_:t) -> 7:t)
07:42:06 <lambdabot>   7
07:42:13 <chenwl> is it something about lazy
07:42:13 <jmcarthur> chenwl: since another effect of this is that the pattern will always succeed
07:42:26 <roconnor> > head (case undefined of (_:t) -> 7:t)
07:42:27 <lambdabot>   *Exception: Prelude.undefined
07:42:59 <jmcarthur> chenwl: yes. ~ means that you want to match the pattern lazily (only if needed during the evaluation of the right hand side)
07:43:11 <Axman6> > case [] of (_:t) -> 7
07:43:13 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
07:43:19 <Axman6> > case [] of ~(_:t) -> 7
07:43:19 <lambdabot>   7
07:43:22 <jmcarthur> chenwl: but as i also said, it has the effect of making the pattern always match
07:43:26 <Axman6> ... ouch
07:43:34 <Axman6> i wasn't actually expecting that
07:43:38 <chenwl> > case [] of ~(_:t) -> 7
07:43:38 <Axman6> > case [] of ~(_:t) -> 7:a
07:43:39 <lambdabot>   7
07:43:39 <lambdabot>   Couldn't match expected type `[t]'
07:43:40 <lambdabot>         against inferred type `SimpleRef...
07:43:46 <Axman6> > case [] of ~(_:t) -> 7:t
07:43:47 <lambdabot>   [7*Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed for pa...
07:44:10 <Axman6> > case [] of ~(_:t) -> 7:t; [] -> [8];
07:44:11 <lambdabot>   [7*Exception: <interactive>:(3,0)-(4,21): Irrefutable pattern failed for pa...
07:44:12 <chenwl> jmcarthur: but what if the pattern doesn't match
07:44:25 <chenwl>  > case [] of ~(_:t) -> t
07:44:29 <jmcarthur> chenwl: then it's an error. that's why i said to avoid it unless the pattern is irrefutable
07:44:47 <jmcarthur> and even then, only use it if you know you need it
07:45:00 <jmcarthur> *unless you know it's safe
07:45:11 <roconnor> chenwl: if the pattern doesn't mach you may get an Irrefutable pattern failed error eventually
07:45:24 <chenwl> jmcarthur: when will I need it, does it improve the performance
07:45:34 <jmcarthur> it increases laziness in some circumstances
07:45:44 <Axman6> chenwl: i think the general advice is not to use it with sum types, only product types
07:45:59 <jmcarthur> > case undefined of (a, b) -> "foo"
07:45:59 <lambdabot>   "*Exception: Prelude.undefined
07:46:03 <Axman6> so, no [], Maybe, Either etc, but (,), (,,) etc is fine
07:46:10 <jmcarthur> > case undefined of ~(a, b) -> "foo"
07:46:11 <lambdabot>   "foo"
07:46:15 <roconnor> chenwl: irrefutable patterns are often used when making circular data structures.
07:46:35 <Axman6> becayse when you have a product type, you know that there's only one constructor, so it should always match
07:46:47 <applicative> > > let foo ~(_:xs) = 7 in foo []
07:46:48 <lambdabot>   <no location info>: parse error on input `>'
07:46:53 <applicative> > let foo ~(_:xs) = 7 in foo []
07:46:53 <lambdabot>   7
07:46:59 <roconnor> chenwl: though they are often hidden in let statements which are always irrefutable.
07:47:19 <jmcarthur> yeah, that's something about let that's easy to forget
07:47:39 <chenwl> sorry, I don't know 'sum types, product types, circular data structures'
07:47:47 <roconnor> > let (_:t) = [] in 7
07:47:48 <lambdabot>   7
07:48:04 <applicative> sum types are ones with | in the definition,
07:48:09 <applicative> only not recursive
07:48:15 <jmcarthur> chenwl: product types are like C structs. sum types are like C unions (except they are tagged in haskell)
07:48:21 <applicative> product types are ones with several fields
07:48:39 <jmcarthur> chenwl: sorry if you don't know C either, though
07:49:03 <chenwl> data Color = Red | Green | Black
07:49:05 <chenwl> is sum types
07:49:07 <applicative> chenwl: Either a b is the paradigmatic sum type; (a,b) is the paradigmatic product
07:49:10 <chenwl> jmcarthur: I know c
07:49:14 <jmcarthur> good good
07:49:24 <jmcarthur> and yes, your Color type is a sum type
07:49:28 <Axman6> chenwl: data Either a b = Left a | Right b is a sum type, but data Both a b = Both a b is a product type
07:49:49 <Axman6> both is usually known as (,)
07:50:02 <jmcarthur> generally, data declarations allow you to define sums of products
07:50:08 <applicative> chenwl your type is isomorphic to Either () (Either () ()) --- Red = Left (Left ()) , Green = Right (Left ()) , etc
07:50:08 <roconnor> > (,) 6 7
07:50:09 <chenwl> Axman6: (,) ?
07:50:09 <lambdabot>   (6,7)
07:50:15 <roconnor> > (6, 7)
07:50:16 <lambdabot>   (6,7)
07:50:21 <jmcarthur> each constructor defines a product, and since you can define multiple constructors then you can define a sum
07:50:23 <Axman6> chenwl: tuples
07:50:54 <Axman6> applicative: i'm not sure that makes it any clearer :P
07:51:42 <jmcarthur> you can think of it like this. if the number of values of type A is m and the number of values of type B is n, the number of values of type (A, B) is m*n, and the number of values of type (Either A B) is m+n
07:51:47 <applicative> Axman6: maybe not, I was pressing the idea that sum types reduce to Either, and Products to (,)
07:51:52 <jmcarthur> ignoring bottoms, which if you don't know what that means then don't worry about it
07:52:09 <chenwl> BTW, I am confused with "2" ADTs haskell
07:52:22 <Axman6> ?
07:53:16 <chenwl> Algebraic Data Type vs Abstract Data Type
07:53:37 <chenwl> what is Algebraic Data Type
07:54:14 <chenwl> never appear in other programming language I've learnt
07:54:50 <applicative> algebraic data types are what we are discussing now.
07:54:59 <roconnor> algebraic data types are data types formed using sum types and product types and such
07:55:44 <applicative> Either Int Char is like "Int + Char" , Either (Int,Int) Char is like "Int ^ 2 + Char"
07:55:51 <applicative> to use a familiar analogy
07:56:02 <chenwl> roconnor: what is the difference between Algebraic Data Type vs Abstract Data Type
07:56:32 <Axman6> where "Int + Char" means the number of different Ints plus the number of different Chars
07:56:34 <monochrom> "data X = A Int Bool | B Char | C" is an algebraic data type. it is called algebraic because you combine sums and products, you get polynomials
07:56:58 <roconnor> chenwl: Abstract Data types are types where the implementation is hidden and only some operations on the type are exposed through a module interface.
07:57:10 <ocharles> Hey, I was wondering if I could pick the collection brains of #haskell about html form processing... I'm trying to design my own little library atm (a bit for education, a bit because what I want doesn't seem to play to the strengths of digestive-functors) and I'm considering types.
07:57:56 <ocharles> Say I have data Book = Book { name :: Text, author :: Text } and I need a form for this. I want to be able to pass this "form" to my view, that's Form -> Html, for example
07:58:10 <ocharles> I'd like to be able to get all errors for the 'name' field, and all errors for the author field...
07:58:27 <chenwl> roconnor: then what is Abstract Data Type
07:58:30 <ocharles> it feels like what I want is BookForm { name :: Field Text, author :: Field Text } - but to autogenerate that, I probably need Template Haskell
07:58:42 <chenwl> roconnor: I am confused between these 2
07:58:50 <ocharles> there's not really any other way to annotate fields of the Book data type, is there?
07:59:29 <ocharles> Or I could have Form Fields Book, where Fields is a monoid that collects the validation results for each field or something (or maybe a Map)
07:59:35 <monochrom> algebraic data type and abstract data type are unrelated. treat them independently, then you will not be confused
07:59:46 <ocharles> but then I feel like I lose some type benefits
08:00:04 <Axman6> chenwl: when you do module Foo (Bar) where data Bar = A | B | C Int, you're only exporting the type Bar, but no code using the module can actually use those constructors for pattern matching etc
08:01:41 <Axman6> chenwl: if you do module Foo (Bar(..)) where data Bar = A | B | C Int, then code using the module Foo can also pattern match on A, B and C, and can also create things of type Bar by writing things like C 4. in the previous example, writing that would be an error because the constructor C would not be in scope
08:05:24 <aavogt> ocharles: you could instead define       data Book wrapper = Book { name, author :: wrapper Text }, but that makes dealing with the original a bit awkward (say wrapper == newtype Identity a = Identity a)
08:05:41 <ocharles> yea, I considered that and don't really like it
08:05:44 <aavogt> ocharles: what are the 'type benefits' you're thinking of?
08:05:50 <monochrom> you already have abstract data type in java by marking fields as private and/or expose only factory methods and interfaces. java doesn't provide algebraic data types. this shows that the two are unrelated
08:06:12 <ocharles> aavogt: for one, knowing that I can't stick 'bookName' errors inside something like 'bokName' (typos)
08:06:29 <ocharles> I guess I'm not exactly sure of the benefits that I could get
08:06:39 <ocharles> actually, it's more the reverse a bit too...
08:06:39 <mistertim> Does Haskell even have Abstract Data types? I only think i've come across them in Miranda
08:06:50 <mistertim> although I guess typeclasses are 'abstract' in some sense
08:06:55 <ocharles> my view wouldn't be able to show errors for bokName, because the 'bokName' field doesn't exist (but bookName would)
08:07:16 <aavogt> mistertim: you can use a module to hide implementation
08:07:23 <monochrom> you can get abstract data type in haskell by module and limited export
08:07:27 <mistertim> aavogt: oh yes, i see
08:07:30 <Axman6> mistertim: see my discussion above to chenwl about the difference between exporting constructors and not. when they're not exported, you have an abstract type
08:07:38 <mistertim> aha that makes sense
08:07:47 <mistertim> so you export the type without the data constructor
08:07:51 <mistertim> that's pretty neat
08:08:07 <mistertim> sorry, only caught the end of that conversation, clearly :-)
08:08:10 <Axman6> can you export only specific constructors?
08:08:16 <ocharles> yep
08:08:17 <monochrom> generally any access barrier gives you abstract data type, and almost every language provides some access barrier
08:08:26 <ocharles> just use Type(Constructor1,Constructor2) instead of (..)
08:08:33 <Axman6> yeah
08:08:41 <Axman6> i couldn't remember if i'd seen that before
08:08:48 <Axman6> i'm not sure i see the use in that
08:09:45 <aavogt> Axman6: one of your 'factory' methods could end up being exactly the same as one of your constructors (and you don't mind people pattern matching with the constructor)
08:10:46 <jmcarthur> i think exporting some but not all constructors for a type sounds like a mistake
08:11:22 <monochrom> the epoll package exports a "Record(field1, field2)" so you can't build arbitrary values yourself but, given a valid value from a smart constructor, you can read its fields
08:12:17 <monochrom> however, that confuses haddock, and so although docs for field1 and field2 have been written, haddock doesn't render them
08:12:33 <jmcarthur> that sounds different from what i'm talking about though, no?
08:12:59 <monochrom> the end result is that you look at examples, you see field1 and field2 mentioned, but you have no idea where they come from, or even that you are allowed to use them
08:13:13 <jmcarthur> that's more like exposing a limited set of accessors
08:13:22 <jmcarthur> yeah haddock has some issues sometimes :\
08:13:36 <jmcarthur> at least it beats ocamldoc
08:13:40 <monochrom> so that is one use of exporting only "Record(field1, field2)". to confuse both haddocks and humans :)
08:15:12 <aavogt> ocharles: if you have records like     data Name = Name; data Author = Author;   type Book = ((Name,Text) , ((Author,Text), ())), you can write classes that can convert the Text to other things
08:15:55 <aavogt> lookup Name and Author, basically re-doing HList
08:17:09 <ocharles> aavogt: you mean with the Convertible type class, for example?
08:20:49 <aninhumer> How do you write a type constrained instance over list? I tried 'instance (C a) => [a] where'
08:21:03 <aavogt> ocharles: yes. Or say you want to (+1) all the Int in the record and ("omg"++) all the String, you end up writing a data F = F; instance Apply F Int Int where ... ; instance Apply F String String where ...
08:21:11 <mauke> aninhumer: missing class name before [
08:21:24 <ocharles> ah, I haven't seen that type class before
08:21:28 <aninhumer> mauke: Oh right...
08:21:42 <aavogt> though maybe Convertible won't work so well because the types aren't constrained enough
08:22:16 * aninhumer looks for a stupider rubber duck
08:22:43 * edwardk waves hello.
08:25:13 <edwardk> @tell illissius fixed
08:25:14 <lambdabot> Consider it noted.
08:27:56 <joe6> is there a simpler way of writing: if 0 then x else y
08:28:24 <joe6> like a C ":?" operator oslt?
08:28:28 <mistertim> I've got a small problem with the WriterT transformer - I have a value in the monad transformer stack "WriterT [Int] (StateT Int Identity) String", however, a call to  "lift $ modify (+1)" stops my code compiling, as apparently there's no MonadTrans instance for "WriterT [Int]" - I'm assuming there's something wrong with the parentheses in my definition of the monad transformer stack, but I'm struggling to see what - can any of you show me where I'm going wr
08:28:28 <mistertim> ong? thanks, and sorry for all the questions today :-)
08:28:37 <benmachine> joe6: if 0? that's a type error
08:28:43 <aavogt> joe6: you wrote    instance Num Bool?
08:29:02 <benmachine> (unless you write instance Num Bool but why would you even do that)
08:29:53 <joe6> i want to something like this: (\x -> if (x == 0) then x else x + 20)
08:29:58 <aavogt> > let (?) = \b x y -> if b then x else y in   [ True ? 3 $ 4,  False ? 3 $ 4 ]
08:29:59 <lambdabot>   [3,4]
08:30:03 <mistertim> joe6 (ignoring the type error in 'if 0') - why not use a pattern match? "f 0 = x; f_ = y"
08:30:38 <joe6> mistertime, yes ,that is possible. was just curious if there is a builtin for this..
08:30:41 <edwardk> don't use lift $ modify (+1), just use modify (+1)
08:30:59 <mistertim> aavogt: aah cool! I do miss the ternary operator...
08:31:18 <Botje> mistertim: if then else is an expression like the rest of them
08:31:29 <edwardk> the main idea of mtl is that those instances carry up over the things you wrap them in
08:31:36 <mistertim> edwardk: thanks! Does that mean that WriterT x (StateT y m) is itself an instance of MonadState?
08:31:42 <edwardk> yep!
08:31:51 <mistertim> edwardk: aah, thanks!
08:32:16 <edwardk> instance (MonadState s m, Monoid w) => MonadState s (WriterT w m)
08:33:04 <edwardk> however, there should be a monadtransinstance for WriterT [Int] because [a] is a monoid for all a.
08:33:20 <aavogt> if you make it  infix 1, that probably works reasonably. If only $ was infixl 0 rather than infixr 0, so you could make   infixl 0 ?
08:33:28 <mistertim> hmm - Couldn't match expected type `WriterT [Int] (StateT Int Identity) a'  against inferred type `StateT Int m ()'
08:33:49 <edwardk> mistern: can you hpaste?
08:33:50 <edwardk> @hpaste
08:33:50 <lambdabot> Haskell pastebin: http://hpaste.org/
08:34:36 <mistertim> edwardk: https://gist.github.com/1143987
08:34:54 <mistertim> edwardk: i've only got 'transformers' installed - do i need mtl-fd or similar too perhaps?
08:35:16 <edwardk> you need 'mtl'
08:35:25 <edwardk> and use Control.Monad.Writer and Control.Monad.State
08:35:48 <edwardk> those use the same types as the Control.Monad.Trans.* except they provide the MonadFoo methods
08:36:15 <edwardk> you can write what you want with just transformers, but then you'd need to modify the increment function to explicitly lift the modify
08:36:37 <mistertim> edwardk: aha! I took the advice of this post http://stackoverflow.com/questions/2769487/mtl-transformers-monads-fd-monadlib-and-the-paradox-of-choice and went for transformers instead, I'll switch back to mtl for ease of use.
08:36:37 <edwardk> (otoh, the resulting code would be haskell 98, and thus more palatable so some people)
08:36:52 <edwardk> mtl is currently built on top of transformers
08:37:13 <edwardk> that is a reasonably current response
08:37:24 <mistertim> edwardk: aah ok, that's good to know
08:37:44 <edwardk> i don't recommend his last idea, which was to download category-extras though ;)
08:37:58 <edwardk> which i don't bother to maintain any more, since i split it apart
08:38:45 <edwardk> anyways, since that article was written the mtl == transformers ++ monads-fd actually happened. mtl was made an alias for what was 'monads-fd' at the time
08:39:01 <edwardk> well, there is a more complicated bit of shimming but that is basically it
08:39:10 <mistertim> aah i see - I hadn't noticed that question was a year old
08:39:18 <mistertim> thank you very much!
08:39:45 <edwardk> heh i actually replied to that answer
08:40:06 <aninhumer> Is there a guideline somewhere as to what top level module namespaces should be used for different purposes?
08:40:23 <edwardk> yes, not sure where it is hiding on the haskell wiki though
08:40:28 <aavogt> aninhumer: if in doubt put it in Data.
08:41:10 <edwardk> what are you working with?
08:41:23 <edwardk> aavogt: that advice has led to data becoming a complete sewer =P
08:42:20 <aninhumer> edwardk: I'm currently writing a typeclass for BEncodeable data
08:44:02 <aninhumer> Most likely I should just patch Data.BEncode locally (or indeed in repo)
08:44:11 <aninhumer> But I'll worry about that later
08:45:20 <mistertim> @help
08:45:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:45:54 <edwardk> http://www.haskell.org/haskellwiki/Hierarchical_module_names
08:45:57 <edwardk> found it =)
08:45:57 <mistertim> hmm - can I /msg lambdabot? cos otherwise this might get annoying for everyone else in here...
08:46:15 <merijn> mistertim: Yes
08:46:17 <Entroacceptor> you should be able to, yes
08:46:31 <mistertim> Entroacceptor - so I see! thanks
08:47:22 <edwardk> i'm pretty evenly distributed between Data, Control and Numeric for the most part, though I guess I'm rapidly bringing Text up to the levels of the other 3
08:47:56 <aninhumer> edwardk: Ah thanks
08:47:56 <matthiasgoergens> Does anybody know of a haskell tutorial that focusses on _reading_ Haskell code?  I'm currently preparing a talk to give the rest of my team, and my boss is mostly interested in re-viewing the code that those crazy haskellers on the team write.
08:49:12 <Entroacceptor> matthiasgoergens: I'd guess writing code helps with that
08:49:28 <aavogt> matthiasgoergens: the haskell report?
08:49:54 <Botje> matthiasgoergens: I think identifying the types involved and their operations helps.
08:50:34 <matthiasgoergens> botje, yes, I thought of concentrating on type signatures for the very beginning.
08:50:47 <matthiasgoergens> They are more important for reading than for writing.
08:51:21 <matthiasgoergens> Entroacceptor, yes, writing helps with reading to a certain extent.  and vice versa.
08:51:23 <edwardk> yeah if your boss wants to learn anything then i suppose having him focus on the type level, and ignoring that pesky term level wouldn't be a bad idea
08:51:31 <Entroacceptor> matthiasgoergens: writing helps a lot and tons more
08:51:42 <matthiasgoergens> oh, reading helps with writing, too.
08:51:45 * hackagebot hlint 1.8.15 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.15 (NeilMitchell)
08:51:52 <Entroacceptor> I've head seven years of latin in school
08:51:54 <edwardk> that way he can read the signatures for your methods, and can fall back in the faith that 'if it compiles, it is correct' in haskell
08:51:59 <Entroacceptor> but that focused just on reading
08:52:03 <Entroacceptor> I remember nothing of it
08:52:12 <matthiasgoergens> Entroacceptor, Haskell isn't a natural language.
08:52:25 <Entroacceptor> but the same principles apply
08:52:32 <danharaj> not really.
08:52:37 <matthiasgoergens> Entroacceptor, I had Russian in school, and did reading and writing, and remember nothing of it, too. ;o)
08:52:39 <merijn> Entroacceptor: I strongly disagree
08:52:57 <Botje> matthiasgoergens: does your team currently use literate haskell?
08:53:06 <matthiasgoergens> Botje, no.
08:53:17 <matthiasgoergens> Botje, though literal programming would be a nice thing.
08:53:32 <Botje> matthiasgoergens: it might make sense to take the 'important' types and document them in group
08:53:43 <matthiasgoergens> Botje, around 3.5 people use haskell on a team of around 20.
08:54:08 <Botje> focusing on small functions first will help people understand what the types are for, what they do, and what invariants they maintain
08:54:11 <monochrom> you may need to justify the API itself, i.e., why choose those types and those functions? you justify that by use cases, examples to show that those types and functions let you do amazing things with ease
08:54:12 <matthiasgoergens> botje, oh, we often have a Types.hs module in our programs.
08:54:17 <Botje> and along the way you can explain features :)
08:54:48 <matthiasgoergens> monochrom, yes, I thought of explaining just what we wrote so far in the concrete, instead of haskell in the abstract.
08:55:24 <monochrom> indeed often haskellers are considered crazy just because they design unorthodox and unorthodoxically effective APIs
08:55:25 <matthiasgoergens> We also have some other team members who'd like to learn haskell, writing included.
08:55:54 <matthiasgoergens> monochrom, I consider all those C people crazy, with their unnecessarily stateful APIs.
08:56:11 <monochrom> oh yeah, crazy = "not like me"
08:56:35 <matthiasgoergens> monochrom, unless used ironically.
08:56:41 <matthiasgoergens> thanks for your thoughts!
08:56:49 <danharaj> stateful apis can go to hell.
08:57:35 <matthiasgoergens> I thought stateful APIs were already hell.
08:57:55 <danharaj> Hey they're not *that* bad. Usually.
08:58:09 <monochrom> stateful api is fine with me as long as it is "every procedure takes a handle, state is stored there" as opposed to "only one global state instance"
08:58:54 <matthiasgoergens> monochrom, agreed.
08:59:37 <danharaj> monochrom: Even better is if the API actually tells you which procedures modify state.
09:00:39 <monochrom> hell, die-hard imperative programmers prefer the use-handles-multiple-instances story. you will eventually want multiple instances
09:01:18 <danharaj> I hate freetype2 because it uses global state just to handle memory management.
09:01:23 <danharaj> As if I couldn't do it myself.
09:01:36 <danharaj> It was painful and sketchy to wrap it purely.
09:01:45 * hackagebot GenericPretty 1.1.4 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-1.1.4 (RazvanRanca)
09:02:58 <mistertim> matthiasgoergens: debashish ghosh's blog posts on domain modelling with haskell might help with that - I'll dig out the urls for  you
09:03:09 <matthiasgoergens> mistertim, thanks!
09:04:40 <hpaste> “Mekeor Melire” pasted “make that more elegant” at http://hpaste.org/50263
09:04:57 <mistertim> matthiasgoergens: http://debasishg.blogspot.com/2010/10/domain-modeling-in-haskell-follow-types.html, http://debasishg.blogspot.com/2010/10/domain-modeling-in-haskell-combinators.html, and http://debasishg.blogspot.com/2010/11/domain-modeling-in-haskell-applicative.html - they probably only really scratch the surface of what you want, but it might be a good starting point
09:05:13 <matthiasgoergens> Good.  I'll have a look.
09:06:06 <mekeor> i just made a (h)paste, did you see that?
09:06:12 <mekeor> can anybody help me please with that code? it works, but it's not that elegant :/
09:06:16 <c_wraith> mekeor: Doesn't the structure of your answer possibly suggest to you that a loop would be a good idea?
09:06:46 <c_wraith> mekeor: you're manually looping over the operator list.  make it a true loop, not a manually unrolled loop.
09:07:06 <mekeor> c_wraith: yea, actually yes; but how?
09:07:28 * mekeor is a HS-beginner ...
09:08:08 <c_wraith> sorry, I can't help with that.  I actually have to leave.  But if you explain what it is you're having trouble with, in terms of not seeing how to make it a loop, I bet someone else will lend a hand.
09:08:49 <matthiasgoergens> mistertim, the blog posts look interesting so far.
09:09:23 <matthiasgoergens> mekeor, sorry, I didn't see your paste.  could you post the url again, and I'll have a look?  Thanks.
09:09:29 <Ptival> mekeor: wow, this is pretty redundant :s
09:09:32 <mekeor> my problem is that the loop has to break under a special condition..
09:09:42 <mekeor> matthiasgoergens: http://hpaste.org/50263
09:10:03 <Ptival> what loop?
09:10:19 <dylukes> loop?
09:10:21 <dylukes> We don't use loops.
09:10:24 <mekeor> c_wraith suggested to make eval a loop or sth ..
09:10:29 <dylukes> We just call recursively or not.
09:10:45 <mekeor> yea, thats what he/i ment
09:10:49 <dylukes> case blah of continue -> call recursively _ -> dont
09:10:55 <mistertim> Here's a question - is it possible, given list of monadic actions [a -> m b] , a function  that unwraps the monadic value (m a -> b) and an initial value of type a, to write a function that returns a list [b] of the result of every 'step' of the computations in the list composed together such that for list [m, n], the function f and the initial value x it returns [f $ return x, f $ return x >>= m, f $ return x >>= m >>= n], and (this is the tricky bit to my
09:10:55 <mistertim> mind) runs in constant time by only computing each element in the list once?
09:11:09 <matthiasgoergens> mekeor, do you know how foldr works?
09:11:21 <mekeor> matthiasgoergens: yep.
09:11:24 <matthiasgoergens> good.
09:11:31 <Ptival> mekeor: first habit to take, whenever you write something that is redundant, spot the pattern, see what changes, and create a function that applies the pattern (and takes as arguments the things that change)
09:11:32 <dylukes> @hoogle [(a -> mb)] -> a -> [b]
09:11:33 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
09:11:33 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
09:11:34 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
09:11:53 <dylukes> mistertim: Dunno, but it looks like a monad within (the list) mona.
09:11:56 <dylukes> Monadception.
09:12:21 <hpaste> “https://plus.google.com/games” pasted “https://plus.google.com/games” at http://hpaste.org/50264
09:12:22 <mekeor> Ptival: yea, that's what i was trying to do..
09:12:31 <dylukes> You could probably express that as Monad m => Incremental m
09:12:53 <mistertim> dylukes: exactly! It's a pattern that's in the gist i posted earlier, but my solution runs in O(n^2) time, as it recomputes the chain of computations from the beginnning each time
09:12:57 <dylukes> and then it'd be monadAction <*> initial
09:13:06 <mistertim> dylukes: aah, that looks like a very interesting idea
09:13:06 <dylukes> I kind of want to try this. Metamonad!
09:13:26 <matthiasgoergens> mekeor, have you considered folding over operators?
09:13:45 <mistertim> hmm... that's a brain melting, but potentially really elegant way of looking at it
09:13:52 <dylukes> mistertim: so let me get this straight
09:13:52 <matthiasgoergens> mistertim, if you have m a -> b, that looks like a co-monad to me.
09:13:56 <dylukes> you want to take a starting value,
09:14:01 <dylukes> and a list of monadic actions,
09:14:08 <mistertim> a list of actions which compose together
09:14:09 <mekeor> matthiasgoergens, Ptival; thank you, i think i'll make it now =) thanks
09:14:16 <dylukes> and produce a list where each item is all of the n previous ones composed.
09:14:22 <dylukes> this sounds fold-like as well.
09:14:26 <mistertim> yep, exactly!
09:14:37 <dylukes> like a fold + map >_>
09:14:41 <dylukes> you're mapping fold
09:14:44 * Ptival wasn't really helpful :)
09:14:54 <dylukes> map + fold + monadception = sounds fun
09:15:20 <matthiasgoergens> dylukes, map is actually a fold.
09:15:29 <dylukes> matthiasgoergens: True true.
09:15:30 <mistertim> dylukes: like 'runWritey' here, but progressively yielding the 'unwrapped' value so it runs in constant time: https://gist.github.com/1143987
09:15:36 <matthiasgoergens> producing a list of values is also an unfold.
09:15:43 <mistertim> rather than building the computations than mapping over them
09:15:52 <mistertim> s/than/then/
09:15:58 <dylukes> anamorphism then. :\
09:16:03 <dylukes> I don't actually know read/write
09:16:06 <dylukes> reader/writer
09:16:10 <dylukes> but I'm going to play a bit
09:16:17 <matthiasgoergens> dylukes, reader is quite trivial.
09:16:27 <dylukes> digest version?
09:16:28 <matthiasgoergens> writer is slightly more complicated, but not much.
09:16:31 <mistertim> dylukes: yep, i keep running into anamorphisms, i need to work on my category theory to properly grok them though i think
09:16:51 <dylukes> mistertim: eh, I don't know any of the related CT.
09:17:50 <dylukes> oh eek
09:17:53 <dylukes> I just realized one problem
09:18:01 <dylukes> you have m a -> b
09:18:04 <dylukes> er
09:18:07 <dylukes> a -> m b
09:18:15 <dylukes> but you want to "unwrap" b, and stick it in the list monad
09:18:21 <dylukes> You can't just extract it.
09:18:34 <dylukes> (unless the monad is ALSO a comonad… can a monad be its own dual?)
09:18:45 <dylukes> (is that like, some sort of bizarre type level fix point)
09:19:15 <dylukes> mistertim: In any case, I think you could remove the N^2 with some basic memoization.
09:19:41 <mistertim> dylukes : yep, that's pretty much what i'm after - i'd like to memoize each step so that it can be used to compute the next one in the list
09:20:00 <dylukes> http://www.haskell.org/haskellwiki/Memoization
09:20:06 <mistertim> I think it probably involves judicious use of strictness annotations somewhere
09:20:10 <mistertim> aah that looks useful
09:20:10 <dylukes> anyways, I'm going to try to generalize this ...
09:20:12 <mistertim> thankyou!
09:20:26 <dylukes> It's really just abusing let/in and how the GHC RT does stuff.
09:20:37 <dylukes> (also, its the only situation where that monomorphism restriction is (apparently) helpful)
09:21:20 <jit> tryhaskell is cool..1
09:21:23 <jit> !
09:21:39 <dylukes> mistertim: I'm dubious about the m a -> b function
09:21:52 <dylukes> thats a lossy transformation :\
09:22:55 <dylukes> naive implementation time...
09:23:03 <dylukes> mistertim: I'm just going to try for f :: [a -> m b] -> a -> [m b]
09:23:07 <matthiasgoergens> dylukes, if you look at the trivial monad: data Trivial a = Trivial a
09:23:15 <matthiasgoergens> you can make that a monad and a comonad.
09:23:22 <dylukes> you can map the m b -> a over the result.
09:23:24 <danharaj> That's not the trivial monad! That's the identity monad!
09:23:30 <danharaj> The trivial monad is Trivial a = Trivial
09:23:39 <dylukes> Jeez how could you mix them up!!!
09:23:55 <brisingr> I got lynched ou of #maths for asking about the injectivity of functors
09:24:00 <danharaj> "And then the professor says that's no hydroxyl ion, that's my wife!"
09:24:05 <brisingr> s/ou/out/
09:24:16 <matthiasgoergens> danharaj, thanks for the correction.
09:24:29 <danharaj> in your defense, the trivial monad is trivial.
09:24:58 <matthiasgoergens> brisingr, there's no #maths. :o)
09:25:04 <brisingr> sorry,
09:25:05 <brisingr> #math
09:25:15 <brisingr> got it wrong twice
09:25:18 <dylukes> I point at the rise of Haskell, and I point at increasing twin births. That's all.
09:25:20 <danharaj> why were yo ulynched out?
09:26:19 <brisingr> I don't know why, all I know is that I got lynched at about the point in time they figured out I was interested "haskellory"
09:27:08 <dylukes> Greenfieldisms are my favorite new meme.
09:27:25 <mistertim> dylukes: re lossiness - exactly! I'm thinking of that being a function like runState which takes State s a -> (a, s) (and forces the stateful computation)
09:27:27 <danharaj> dylukes: like what?
09:27:51 <dylukes> danharaj: http://knowyourmeme.com/memes/greenfieldism
09:27:58 <dylukes> Look at the gallery.
09:28:14 <dylukes> explanation:
09:28:14 <dylukes> http://neuroskeptic.blogspot.com/2011/08/susan-greenfield-causes-autism.html
09:29:37 <mistertim> @t runState
09:29:37 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:29:44 <mistertim> @type runState
09:29:45 <lambdabot> forall s a. State s a -> s -> (a, s)
09:29:59 <mistertim> oh yeah, i got that wrong
09:31:06 <dylukes> mistertim: I'm going to play with it, I think I see how it'll g.
09:31:25 <brisingr> quote (JordiGH), #math: "I should realise every time someone walks in here asking about category theory, what they really want is Haskellory theory."
09:31:29 <kmels> how can I downgrade cabal-1.8 to cabal-1.10? reinstalling? do I get every package removed?
09:31:33 <mistertim> dylukes- thanks! don't worry too much about it on my account though, i was thinking out loud as much as anything else!
09:31:43 <dylukes> mistertim: nah, its just an interesting little w/e
09:35:16 <dylukes> oh, wait mistertim
09:35:21 <dylukes> if you have a list of a -> m b
09:35:24 <dylukes> and you're composing them
09:35:28 <dylukes> they must really be a -> m a no?
09:35:38 <dylukes> :t [a - > m a] -> [a -> m a]
09:35:39 <lambdabot> parse error on input `>'
09:35:55 <dylukes> :t [(a - > m a)] -> [(a -> m a)]
09:35:56 <lambdabot> parse error on input `>'
09:36:02 <dylukes> :t [a -> m a] -> [a -> m a]
09:36:03 <lambdabot> parse error on input `->'
09:36:05 <dylukes> ...
09:36:19 <jaspervdj> edwardk: How about a meeting somewhere next week? (Greetings from CamHac btw!)
09:36:38 <dylukes> You guys need to have something in Pittsburgh :<
09:37:16 <dylukes> mistertim: Oh god… I just realized, taking a list of things.. and expanding that to all of the possible things...
09:37:21 <dylukes> You know what that sounds like?
09:40:08 <mistertim> dylukes - oh yep of course - (a -> m a)
09:40:23 <dylukes> I was thinking more like
09:40:24 <mistertim> dylukes - the power set of the list?
09:40:25 <dylukes> w a -> w (w a
09:40:43 <mistertim> well not quite as it's ordered
09:41:15 <dylukes> Its a subset of the powerset.
09:41:26 <mistertim> @type heads
09:41:26 <lambdabot> Not in scope: `heads'
09:41:41 <mistertim> @hoogle [a] -> [[a]]
09:41:41 <lambdabot> Data.List inits :: [a] -> [[a]]
09:41:42 <lambdabot> Data.List permutations :: [a] -> [[a]]
09:41:42 <lambdabot> Data.List subsequences :: [a] -> [[a]]
09:41:48 <dylukes> let powerset = filterM (const [True, False]) in powerset [1,2,3]
09:41:54 <dylukes> > let powerset = filterM (const [True, False]) in powerset [1,2,3]
09:41:55 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:41:56 <mistertim> > inits [1,2,3]
09:41:57 <lambdabot>   [[],[1],[1,2],[1,2,3]]
09:42:15 <dylukes> the above definition of poweset
09:42:17 <dylukes> my mind = blown
09:42:23 <dylukes> how the heck does that even work .__.
09:42:26 <mistertim> wow
09:42:31 <dylukes> > let powerset = filterM (const [True, False]) in powerset [1,2,3]
09:42:32 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:42:35 <mistertim> wtf?
09:42:41 <dylukes> http://evan-tech.livejournal.com/220036.html
09:42:48 <mistertim> @type const
09:42:48 <lambdabot> forall a b. a -> b -> a
09:42:59 <dylukes> const just ignores the second parameter.
09:43:04 <mistertim> aah yep
09:43:08 <mistertim> @type filterM
09:43:09 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:43:27 <dylukes> Runs a monadic action over a list of [a]'s
09:43:35 <dylukes> if the action returns true, the a value is kept.
09:43:38 <dylukes> the result is within the same monad.
09:43:50 <mistertim> aah yes
09:43:53 <dylukes> @src filterM
09:43:53 <lambdabot> Source not found. You speak an infinite deal of nothing
09:44:00 <dylukes> @src Control.Monad.filterM
09:44:01 <lambdabot> Source not found. That's something I cannot allow to happen.
09:44:30 <dylukes> reading the explanation...
09:45:00 <dylukes> oh god.
09:45:07 <dylukes> the fucking list monad. nondeterminism strikes again .__.
09:45:22 <mistertim> aha i think i get it
09:45:26 <dylukes> that's how it's happening. flg <- [True, False] is in the list monad.
09:45:31 <mistertim> hahahah yes
09:45:32 <dylukes> It's branching to two different paths.
09:45:34 <dylukes> XD
09:45:37 <dylukes> that's pretty clever :P.
09:45:38 <mistertim> that's amazing
09:45:48 <dylukes> But isn't it kind of dependent on the filterM implementation/
09:45:51 <dylukes> ?*
09:45:51 <lambdabot> Maybe you meant: . ? @ v
09:47:32 <frerich_> Before I try to implement a solution myself: is there a Haskell function which can give the n'th permutation of a list of 106 elements in a reasonable time (i.e. faster than using (!! n) . permutations))?
09:48:06 <frerich_> I read that there's a nice recursive trick to get a specific permutation in a very short time, but I didn't find out whether there's a Hakell implementation of that.
09:49:33 <Botje> doesn't that depend on the way you generate your permutations?
09:50:20 <dylukes> mistertim: An amusing thought. this is now [a -> m a] -> [a -> m a] right?
09:50:52 <Botje> frerich_: for a list of 106 elements there will be 105! where list!!0 is the first, 105! where list!!1 is the first
09:50:55 <Botje> and so on
09:51:15 <dylukes> well, a -> m a matches return… so if you have a peano numeral type expressed as a monad where return is Succ… oh w/e I'm thinking aloud.
09:51:21 <dylukes> it feels like Fin.
09:51:29 <dylukes> >_>
09:51:29 <Botje> so the first element is (index)`div` 105!
09:51:59 <Botje> then you repeat the process for index `div` 104! and so on
09:52:18 <frerich_> Botje: I believe that's basically the recursive solution I read about.
09:52:37 <Botje> off the top of my head ..
09:52:42 <mistertim> dylukes - hmm - i think I've confused myself now
09:52:44 <gwern> lambdabot: @join #lesswrong
09:52:45 <dylukes> hehe, yeah
09:52:46 <mistertim> dylukes - yes, it is!
09:52:49 <mistertim> exactly
09:52:52 <dylukes> ?
09:53:01 <mistertim> well actually not quite
09:53:04 <mistertim> :-)
09:53:10 <dylukes> :>
09:53:14 <frerich_> Botje: Ah, just found  Python version wihc uses the recursive (which may be what you're describing) approach to find the n'th permutation of some [1..10] list in (approximately) constant time: http://tafakuri.net/?p=68
09:53:18 <dylukes> anyways, one moment
09:53:49 <dylukes> @hoogle [a] -> [a]
09:53:49 <lambdabot> Prelude cycle :: [a] -> [a]
09:53:50 <lambdabot> Prelude init :: [a] -> [a]
09:53:50 <lambdabot> Prelude reverse :: [a] -> [a]
09:53:56 <dylukes> > init [1,2,3]
09:53:57 <lambdabot>   [1,2]
09:54:00 <dylukes> > inits [1,2,3]
09:54:00 <lambdabot>   [[],[1],[1,2],[1,2,3]]
09:54:09 <jonkri> i'm thinking about how to go about extendibility in my library. i'm pondering having some kind of event system where applications can hook themselves to certain events, and so far so good, but is there a way to let third party applications generate events on their own? i guess this would mean having some kind of typeclass with an arbitrary payload type or something?
09:54:37 <Botje> go [] idx = []; go elems idx = let selectedidx = idx `div` factorial (length nums - 1) in (nums !! selectedidx) : go (delete (nums !! selectedidx) nums) (idx `mod` (factorial (length nums - 1)))
09:54:43 <jonkri> the flip side of having this wonderful type system i guess :)
09:55:06 <mistertim> say you've got [m,n,o] :: [a -> ,m a], and you take that to [m, m >>=n, m >>= n >>= o], using some combination of inits and (foldl1 (>>=))
09:55:22 <Botje> frerich_: something very roughly like that. you probably want to turn the factorial and nums !! selectedidx things into proper variables
09:55:28 <dylukes> mistertim: something like that.
09:55:54 <frerich_> Botje, Cool, let me tinker a bit with that...
09:55:55 <mistertim> the tricky bit to my mind is then executing those actions, such that the action m isn't evaluated 3 times, and n 2.
09:56:14 <frerich_> Botje: Thanks for your feedback :-)
09:56:21 <mistertim> so it's basically just memoization
09:56:31 <mistertim> but a tricky example of it
09:56:51 <dylukes> idk...
09:56:55 <dylukes> gimme a second
09:57:26 <Botje> you can do smarter things like pass the factorial thing along and divide by length nums every time, but this should be a good basis
09:58:15 <Botje> is this for project euler by any chance?
09:58:41 <dylukes> mistertim: On a side note, attempting to fold >>= constructs an infinite type...
09:59:07 <gwern> hm. so if we think of monoids as 'things which get bigger' and have a 'smallest' element, what's the opposite? things that get smaller and have a largest element? perhaps a random number generator with a finite period which you can use up?
09:59:08 <dylukes> @hoogle [a -> m a] -> a -> a
09:59:09 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
09:59:09 <lambdabot> Data.Generics.Aliases extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
09:59:09 <lambdabot> Data.Data gfoldl :: Data a => (c (d -> b) -> d -> c b) -> (g -> c g) -> a -> c a
09:59:30 <dylukes> @hoogle [a -> m a] -> a -> m a
09:59:31 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
09:59:31 <lambdabot> Data.Generics.Aliases extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
09:59:31 <lambdabot> Data.Data gfoldl :: Data a => (c (d -> b) -> d -> c b) -> (g -> c g) -> a -> c a
09:59:33 <mistertim> dylukes aah. that's not quite what i meant then
09:59:38 <Botje> gwern: RandomSupply with a finite supply?
09:59:52 <dylukes> foldM maybe
10:00:12 <gwern> Botje: I guess, but I was wondering if there was any existing abstraction like this. 'comonoid' would be my random guess at its name but I really have no idea
10:00:41 <dylukes> :t foldM (>>=)
10:00:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> [a -> m (m a)] -> m (m a)
10:01:01 <dylukes> I need foldM1
10:01:24 <gwern> co- things tend to be infinite while I want something that is finite, so I doubt whatever a 'comonoid' is, it's what I'm thinking of. 'unfold' is kind of close
10:02:04 <mistertim> foldM1 f (x:xs) = foldM f x xs
10:02:14 <mistertim> (off the top of my head)
10:02:19 <dylukes> yep
10:02:21 <jocom> gwern: But monoid tend to be infinite as well
10:02:49 <gwern> jocom: right. there is no biggest list or integer for those 3 monoids. so wouldn't the opposite be finite?
10:03:01 <mistertim> aargh - foldM1 (>>=) also constructs an infinite type
10:03:11 <jocom> gwern: Don't think so
10:04:07 <jocom> gwern: Dually, a comonoid in a monoidal category C is a monoid in the dual category
10:04:17 <gwern> mathmatically, there are inverse thingies... https://secure.wikimedia.org/wikipedia/en/wiki/Presentation_of_a_monoid#Inverse_monoids_and_semigroups <-- but I have no idea what the math means
10:05:06 <jocom> gwern: I've no idea what the Haskell means (-;
10:05:29 <jocom> gwern: You know what a group is?
10:05:32 <gwern> nope
10:05:37 <Rc43> Guys, i can't understand what is wrong : http://pastebin.com/epfgiitb
10:05:41 <mauke> The paste epfgiitb has been copied to http://hpaste.org/50266
10:05:41 * gwern analogizes us to two blind men feeling each other up
10:05:46 <Rc43> hashtable.hs:30:50:     Couldn't match expected type `Entry v0'                 with actual type `[Entry v1]'
10:06:22 <jocom> gwern: Haha
10:06:53 <jocom> gwern: I just gave the math def for a comonoid
10:10:42 <dylukes> mistertim: It occurs to me this might be easier to handle with Kleisli arrows.
10:10:56 <dylukes> er, kleisli composition
10:11:08 <dylukes> >=> specificall.
10:11:44 * hackagebot smallarray 0.2.2.2 - low-level unboxed arrays, with minimal features.  http://hackage.haskell.org/package/smallarray-0.2.2.2 (AntoineLatter)
10:12:09 <mistertim> dylukes - aah that sounds promising - a lot of what I'm working on looks very much like something that could be tackled well with arrows, but so far I haven't got around to attempting it
10:12:56 <mistertim> aah hang on - kliesli composition ?= arrow composition?
10:13:18 <dylukes> monads for an arrow under kleisli I believ.e
10:13:21 <dylukes> form*
10:14:02 <Botje> Rc43: asks is a monadic action
10:14:25 <dylukes> hahaha mistertim
10:14:27 <dylukes> XD
10:14:29 <Rc43> Botje, so? I am newbie =/
10:14:30 <Botje> Rc43: so you should do " e <- find (...) `fmap` asks entries
10:14:38 <Rc43> fmap?
10:14:41 <Rc43> lol
10:14:48 <dylukes> foldl1 (>=>
10:14:49 <Botje> or liftM
10:14:50 <dylukes> :|
10:14:56 <mistertim> map (foldl1 (>=>)) . tail . inits
10:14:58 <dylukes> mistertim: foldl1 (>=>)
10:15:07 <dylukes> looks like we got on the same track >_<
10:15:07 <mistertim> :t map (foldl1 (>=>)) . tail . inits
10:15:08 <lambdabot> forall (m :: * -> *) b. (Monad m) => [b -> m b] -> [b -> m b]
10:15:09 <dylukes> you were just quicker.
10:15:10 <Botje> Rc43: the type of asks entries is not [Entry v], it's Reader (HashTable v) [Entry v]
10:15:12 <Rc43> ok, ty, i will try to understand, then will ask again, if i can't
10:15:40 <Botje> Rc43: you can also do it in two steps, of course.
10:15:45 <Botje> es <- asks entries
10:15:52 <Botje> let e = find (...) es
10:16:15 <Rc43> Botje, hm, i have tried something about it, but it failed, one sec
10:17:36 <Rc43> If do "es <- asks ..." then it talks "Could not deduce (v ~ Hashtable v0)     from the context (Show v)       bound by the type signature for                  findValue :: Show v => Hashtable v -> v -> Bool       at hashtable.hs:(28,1)-(33,48) "
10:17:43 <dylukes> mistertim: so that works?
10:17:47 <dylukes> (but needs memo?)
10:17:54 <mistertim> dylukes - yes! just no memoization
10:18:04 <mistertim> and the more i think about it, the less convinced i am it's even possible
10:18:07 <Rc43> Could not deduce (v ~ Hashtable v0) from the context (Show v) bound by the type signature for findValue :: Show v => Hashtable v -> v -> Bool at hashtable.hs:(28,1)-(33,48)
10:18:11 <dylukes> mistertim: idk...
10:18:20 <dylukes> I need to fully grok the definition
10:18:24 <dylukes> :t tail.inits
10:18:24 <lambdabot> forall a. [a] -> [[a]]
10:18:29 <dylukes> (oh, you're just removing the [])
10:18:29 <dylukes> >_>
10:18:35 <mistertim> yep that's it
10:18:49 <mistertim> then folding each list together with (>=>)
10:19:00 <dylukes> > inits [1,2,3,4]
10:19:01 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4]]
10:19:12 <ski> @let inits1 = tail . inits
10:19:12 <lambdabot>  Defined.
10:19:21 <ski> @let tails1 = init . tails
10:19:22 <lambdabot>  Defined.
10:19:32 <Botje> Rc43: hmm. i don't really know with so little information.
10:19:33 <dylukes> @let worst_game = sonic . tails
10:19:33 <lambdabot>  <local>:4:13: Not in scope: `sonic'
10:19:40 <mistertim> > tails1 [1,2,3]
10:19:42 <lambdabot>   [[1,2,3],[2,3],[3]]
10:19:45 <dylukes> > init . tails [1,2,3]
10:19:46 <lambdabot>   [[1,2],[2],[],*Exception: Prelude.init: empty list
10:19:47 <Botje> Rc43: try giving your Reader code an explicit type
10:20:01 <dylukes> mistertim: what would you name what you're doing?
10:20:06 <Rc43> Botje, ok, i wil ltry
10:20:12 <Botje> << food
10:20:14 <mistertim> dylukes - I'm not entirely sure
10:20:19 <dylukes> I call foldl1 (>=>) "chain"
10:20:31 <mistertim> yep, that would make sense
10:20:31 <dylukes> since it chains together a list of actions
10:20:48 <mistertim> although it returns a list of chains
10:20:49 <dylukes> what's the whole thing tho?
10:20:54 <mistertim> aah yep that's what i mean
10:20:58 <mistertim> chains?
10:20:59 <mistertim> hmm
10:21:01 <mistertim> one sec
10:21:02 <ski> > (([] :) . concatMap tails1 . inits1) "abcd"
10:21:03 <lambdabot>   ["","a","ab","b","abc","bc","c","abcd","bcd","cd","d"]
10:21:34 <dylukes> ski: If you don't stop I'm removing your I combinator.
10:21:39 <dylukes> You don't need it.
10:21:42 <dylukes>  /nick sk
10:21:45 <ski> stop what ?
10:21:53 <dylukes> dunno, just messing with you.
10:22:31 <dylukes> mistertim: ordered_chains?
10:22:31 <mistertim> in my mind, it's a little like a monadic version of iterate
10:22:47 <mistertim> but it's not quite as it's finite
10:22:48 <dylukes> it's the subset of all chains that are in proper order
10:22:55 <mistertim> yep that makes sense!
10:23:33 <kate_r> in logic speak, a function takes one or more arguments, but what if it has no argument, is it a constant?
10:24:18 <parcs> then it's not a function
10:24:36 <kate_r> parcs, but what would that kind of object be called?
10:25:45 <frerich_> Botje: Your code worked (almost) out of the box! Here's what I ended up with http://hpaste.org/50267
10:25:56 <parcs> you can call it a constant. i don't know the proper term, though. someone else here should know
10:26:19 <frerich_> It seems to work well enough for me, even for very large lists. It scales good enough up to a list of 106 elements.
10:27:38 <frerich_> kate_r: I think it's just a primitive value. I don't think of things as 'constant' because that always makes me thing of constant functions (e.g '\_ -> 3', functions which always yield the same value no matter what they are given).
10:27:39 <mm_freak> kate_r: a value
10:28:18 <mm_freak> a function necessarily involves the (->) type constructor
10:28:26 <mm_freak> everything else is not a function
10:29:01 <kate_r> ok thanks
10:29:33 <parcs> a function is also a value, though
10:29:34 <ski> kate_r : in e.g. first-order logic, then it's a nullary function
10:29:44 <hpaste> Rc43 pasted “Reader Problem” at http://hpaste.org/50268
10:29:45 <ski> kate_r : often `zero()' would be abbreviated as `zero', though
10:30:02 <Rc43> oh, automessage :3
10:30:04 <kate_r> ski, but what would 'zero' be called? constant? value...?
10:30:21 <Rc43> Botje, now i have new problem
10:30:26 <ski> kate_r : nullary function (symbol), or constant (symbol)
10:30:40 <parcs> wikipedia says "Sometimes it is useful to consider a constant as an operation of arity 0, and hence call it nullary or point-free"
10:30:41 <kate_r> ok thanks
10:30:43 <Rc43> Botje, but it was earlier, when i experimented with previous
10:30:59 <Rc43> Botje, Could not deduce (Eq (Entry v)) arising from a use of `=='
10:31:10 <ski> kate_r : in the case of function variables, i suppose it would have to be nullary function variable (if you care to have that in addition to ordinary individial variables, i.e.)
10:31:20 <Rc43> Botje, why it thinks that e is entry, but now Maybe Entry?
10:31:21 <ski> kate_r : in Haskell, something is a function iff its type has shape `... -> ...'
10:31:33 <ski> kate_r : so e.g. `getChar :: IO Char' is not a function
10:32:04 <mm_freak> i think the term "constant" has really little meaning in haskell
10:32:17 <dylukes> mistertim: I'm trying to find an actual use for this I can test >_>...
10:32:24 <kate_r> thanks
10:32:24 <mm_freak> because effectively all nonfunctions are constants
10:32:25 <ski> kate_r : btw, if you want, you could probably say that `f :: () -> Foo' is a nullary (uncurried/tupled) function in haskell
10:32:26 <dylukes> i.e, a trivial case
10:32:27 <dylukes> .
10:33:14 <dylukes> @hoogle a -> m a
10:33:14 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> a -> m a
10:33:14 <lambdabot> Prelude return :: Monad m => a -> m a
10:33:15 <lambdabot> Control.Monad return :: Monad m => a -> m a
10:33:22 <dylukes> bah, I know its return...
10:33:26 <dylukes> :t just
10:33:27 <lambdabot> Not in scope: `just'
10:33:29 <dylukes> oh
10:33:31 <dylukes> :t Just
10:33:31 <lambdabot> forall a. a -> Maybe a
10:33:34 <dylukes> bingo
10:33:59 <merijn> ski: Don't let conal catch you saying that!
10:34:11 <mistertim> dylukes - hmm - something in the Writer monad might be a good way of doing it
10:34:31 <dylukes> peano numeral monad >.>
10:34:33 <dylukes> :P
10:34:55 <dylukes> ord_chains [Just, Just, Just] <*> ([1,2,3])
10:34:55 <dylukes> [Just 1,Just 2,Just 3,Just 1,Just 2,Just 3,Just 1,Just 2,Just 3]
10:34:56 <dylukes> anyways
10:35:06 <dylukes> something might be odd there.
10:35:18 <dylukes> Just won't stack.
10:35:20 <dylukes> boo
10:35:22 <dylukes> :t ([])
10:35:22 <lambdabot> forall a. [a]
10:35:23 <ski> merijn : why ?
10:35:42 <ski> merijn : note the "uncurried/tupled" qualification
10:35:52 <dylukes> :t Trivial
10:35:52 <lambdabot> Not in scope: data constructor `Trivial'
10:36:08 <ski> (which explicitly says that we're talking about the arguments inside an argument tuple)
10:36:10 <dylukes> > Identity 10
10:36:11 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity t))
10:36:12 <lambdabot>    arisi...
10:36:26 <dylukes> there's no Show for Identity?
10:36:27 <dylukes> really?
10:37:56 <mm_freak> i understand a Storable-based vector (Data.Vector.Storable) as an unboxed, strict vector
10:38:00 <mm_freak> is that right?
10:39:25 <dylukes> gah mistertim
10:39:30 <dylukes> something is *not* right here
10:39:32 <dylukes> > Just Just 10
10:39:33 <lambdabot>   Couldn't match expected type `t1 -> t'
10:39:33 <lambdabot>         against inferred type `Data....
10:39:39 <dylukes> > Just (Just 10)
10:39:40 <lambdabot>   Just (Just 10)
10:39:44 <dylukes> it shouldn't be collapsing.
10:39:52 <dylukes> but ord_chaisn [Just, Just, Just] <*> [1,2,3]
10:39:55 <mistertim> dylukes: what definition of ordered_chains are you using?
10:40:00 <mistertim> the same as above?
10:40:13 <dylukes> mm
10:40:19 <dylukes> @let chain = foldl1 (>=>)
10:40:20 <lambdabot>  Defined.
10:40:28 <dylukes> @let ord_chains = map chain . inits1
10:40:29 <lambdabot>  Defined.
10:40:36 <dylukes> > ord_chains [Just, Just, Just] <*> [1,2,3]
10:40:38 <lambdabot>   [Just 1,Just 2,Just 3,Just 1,Just 2,Just 3,Just 1,Just 2,Just 3]
10:40:47 <mistertim> aha
10:40:51 <mistertim> weird
10:40:57 <ski> @type ord_chains
10:40:58 <lambdabot> forall b (m :: * -> *). (Monad m) => [b -> m b] -> [b -> m b]
10:41:07 <mistertim> ord_chains [Just, Just, Just] $ 5
10:41:13 <mistertim> > ord_chains [Just, Just, Just] $ 5
10:41:14 <lambdabot>   Couldn't match expected type `a -> b'
10:41:15 <lambdabot>         against inferred type `[b1 ->...
10:41:17 <mistertim> oops
10:41:33 <mistertim> :t ord_chains [Just, Just, Just]
10:41:34 <lambdabot> forall b. [b -> Maybe b]
10:41:45 <dylukes> they're all just Just tho :P
10:41:51 <mistertim> > map (ord_chains [Just, Just, Just]) 5
10:41:52 <lambdabot>   Couldn't match expected type `a -> b'
10:41:52 <lambdabot>         against inferred type `[b1 ->...
10:42:02 * ski wonders what mistertim is trying to do
10:42:10 * mistertim wonders that too
10:42:22 <mistertim> :-)
10:42:32 <dylukes> > map (5 . flip) (ord_chains [Just, Just, Just])
10:42:32 <lambdabot>   Couldn't match expected type `a -> b'
10:42:33 <lambdabot>         against inferred type `Data.M...
10:42:40 <dylukes> anyways, our implementation is *not* correct.
10:42:53 <mistertim> hmm - i guess it's something to ponder anyway!
10:43:38 <dylukes> ord_chains (replicate 3 Id) <*> [1,2,3]
10:43:38 <dylukes> [Id 1,Id 2,Id 3,Id 1,Id 2,Id 3,Id 1,Id 2,Id 3]
10:43:39 <dylukes> here
10:43:47 <dylukes> https://gist.github.com/1144109
10:43:52 <ski> @let zap = zipWith ($)
10:43:53 <lambdabot>  Defined.
10:43:57 <ski> > ord_chains [Just, Just, Just] `zap` [1,2,3]
10:43:58 <lambdabot>   [Just 1,Just 2,Just 3]
10:44:07 <dylukes> ...zap?
10:44:11 <mistertim> ooh thanks dylukes
10:44:17 <mistertim> bbl - got to go and eat
10:44:18 <mistertim> thanks all!
10:44:19 <dylukes> kk
10:44:20 <ski> `ap' for `ZipLists'
10:44:33 <dylukes> ski: theoretically, ord_chains should return
10:44:38 <Botje> frerich_: cool! glad it works :)
10:44:44 <dylukes> [Id, Id >=> Id, Id >=> Id >=> Id]
10:44:53 <dylukes> > (Just >=> Just) 10
10:44:54 <lambdabot>   Just 10
10:44:58 <Botje> Rc43: is your issue solved, in the meantime?
10:45:00 <dylukes> oh.
10:45:02 <dylukes> :|
10:45:35 <dylukes> @let just_add a = Just (a + 1)
10:45:36 <lambdabot>  Defined.
10:45:37 <Botje> Rc43: also, please post the error you get in a comment
10:45:42 <Botje> or an annotation
10:45:47 <Botje> saves me from scrolling up and down
10:46:07 <Rc43> Botje, ok, also what is the "step" on hpaste?
10:46:11 <dylukes> > ord_chains (replicate 3 (just_add 1)) <*> [1,2,3]
10:46:12 <lambdabot>   Couldn't match expected type `a -> m a'
10:46:12 <lambdabot>         against inferred type `Data...
10:46:17 <dylukes> :t just_add
10:46:18 <lambdabot> forall a. (Num a) => a -> Maybe a
10:46:27 <Rc43> Botje, no, it isn't solved yet
10:46:32 <dylukes> @unlet just_add
10:46:32 <lambdabot>   TemplateHaskell is not enabled
10:46:37 <dylukes> @forget just_add
10:46:37 <lambdabot> Incorrect arguments to quote
10:46:40 <Botje> Rc43: 'step' is for showing evaluation steps, if i understand correctly
10:46:47 <Botje> can you annotate your paste?
10:46:47 <dylukes> @let just_inc a = Just (a +1)
10:46:48 <lambdabot>  Defined.
10:46:55 <dylukes> > ord_chains (replicate 3 (just_inc)) <*> [1,2,3]
10:46:57 <lambdabot>   [Just 2,Just 3,Just 4,Just 3,Just 4,Just 5,Just 4,Just 5,Just 6]
10:47:00 <dylukes> bingo!
10:47:04 <ski> > ord_chains [Just, Just, const Nothing, Just] `zap` [0,1,2,3]
10:47:04 <Rc43> Botje, =/ i dunno what it is
10:47:05 <lambdabot>   [Just 0,Just 1,Nothing,Nothing]
10:47:15 <Botje> Rc43: click 'annotate' at the top of the page
10:47:24 <Botje> Rc43: it allows you to attach a new piece of information to the paste
10:47:39 <Rc43> Botje, ye ye I know, just wait while loading
10:47:39 <dylukes> > ord_chains (replicate 3 (just_inc)) <*> (replicate 3 1)
10:47:41 <lambdabot>   [Just 2,Just 2,Just 2,Just 3,Just 3,Just 3,Just 4,Just 4,Just 4]
10:47:46 <Botje> okay
10:48:18 <ski> dylukes : mistertim wants to turn `[f,g,h]' into `[return,f,f >=> g,f >=> g >=> h]' ?
10:48:41 <dylukes> We're slicing off the return case
10:48:47 <dylukes> @src inits1
10:48:47 <lambdabot> Source not found. My mind is going. I can feel it.
10:48:52 <dylukes> anyways
10:49:03 <hpaste> Rc43 annotated “Reader Problem” with “Reader Problem (annotation)” at http://hpaste.org/50268#a50269
10:49:03 <hpaste> Rc43 annotated “Reader Problem” with “Reader Problem (annotation)” at http://hpaste.org/50268#a50270
10:49:08 <dylukes> just f, f >=> g, f >=> g, f >=> g >=> h, etc
10:49:23 <dylukes> thats what ord_chains does.
10:49:34 <Botje> Rc43: oh.
10:49:46 <dylukes> so in
10:49:46 <dylukes> > ord_chains (replicate 3 (just_inc)) <*> (replicate 3 1)
10:49:48 <lambdabot>   [Just 2,Just 2,Just 2,Just 3,Just 3,Just 3,Just 4,Just 4,Just 4]
10:49:50 <Botje> Rc43: if you use == on a Maybe a value, it expects a to be an instance of Eq as well
10:50:02 <dylukes> the first three has just_inc applied
10:50:05 <dankna> hmm
10:50:09 <dylukes> the next three have just_inc >=> just_inc
10:50:11 <dylukes> and so forth.
10:50:15 <ski> > scanl1 (>=>) [Just,Just,const Nothing,Just] `flip` 3
10:50:16 <lambdabot>   [Just 3,Just 3,Nothing,Nothing]
10:50:17 <dankna> I wonder if it's bad form to shadow prelude arithmetic functions
10:50:21 <ski> > scanl1 (>=>) [Just,Just,const Nothing,Just] `zap` [0,1,2,3]
10:50:23 <dankna> (for my dimensioned-quantities thing)
10:50:23 <lambdabot>   [Just 0,Just 1,Nothing,Nothing]
10:50:30 <ski> dylukes : that ^ ?
10:50:32 <dylukes> ski: I'm confused what you're doing.
10:50:37 <dylukes> haha.
10:50:38 <Botje> Rc43: you could uncomment your Eq (Entry v) instance and tweak it a bit
10:50:45 <Botje> Rc43: but it's slightly better to use pattern matching in this case
10:50:45 <dylukes> :t scanl1
10:50:46 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
10:50:56 <Rc43> Botje, oh, i forgotten about this; obviously - it can be possible to compare inner values
10:51:01 <ski> > scanl1 (+) [0,1,2,3] :: [Expr]
10:51:02 <lambdabot>   [0,0 + 1,0 + 1 + 2,0 + 1 + 2 + 3]
10:51:13 <Botje> Rc43: case e of Nothing -> return False; Just v -> return True
10:51:25 <Botje> Rc43: or spread it over two lines, of course.
10:51:27 <ski> > scanl (+) 41 [0,1,2,3] :: [Expr]
10:51:28 <lambdabot>   [41,41 + 0,41 + 0 + 1,41 + 0 + 1 + 2,41 + 0 + 1 + 2 + 3]
10:51:47 <dylukes> > scanl1 (>=>) (replicate 3 just_inc) :: [Expr]
10:51:48 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
10:51:49 <lambdabot>         against inferred ...
10:51:51 <dylukes> :<
10:52:01 <ski> `Expr' is a numeric type
10:52:05 <mm_freak> what would you guys consider a very compact and fast way to denote absence of a Double?  optimally it would not take any extra memory like NaN
10:52:13 <ski> @type just_inc
10:52:14 <lambdabot> forall a. (Num a) => a -> Maybe a
10:52:21 <Rc43> Botje, WOOOOOOOOW it compiled
10:52:22 <dylukes> yeah.. nope
10:52:26 <Rc43> Botje, thanks
10:52:41 <ski> > scanl1 (>=>) [just_inc,just_inc,const Nothing,just_inc] `flip` 0
10:52:43 <lambdabot>   [Just 1,Just 2,Nothing,Nothing]
10:52:49 <Rc43> Botje, also, why it was necessary to write explicitly Reader?
10:52:51 <ski> dylukes : nope what ?
10:53:02 <dylukes> ski: nmd. nice.
10:53:15 <dylukes> :t scanl1 (>=>)
10:53:16 <lambdabot> forall (m :: * -> *) b. (Monad m) => [b -> m b] -> [b -> m b]
10:53:20 <Botje> Rc43: i'm not sure it's necessary, but it often helps me to fix type errors.
10:53:24 <dylukes> :t foldl1 (>=>)
10:53:24 <lambdabot> forall (m :: * -> *) b. (Monad m) => [b -> m b] -> b -> m b
10:53:28 <Botje> Rc43: you can try inlining it again, see what happens.
10:53:31 <ski> @type ord_chains
10:53:31 <monochrom> (Maybe Double) or (Double with NaN)
10:53:32 <lambdabot> forall b (m :: * -> *). (Monad m) => [b -> m b] -> [b -> m b]
10:54:02 <ski> `scanl' gives all the intermediate results of `foldl'
10:54:12 <dylukes> so scanl1 (>=>)  =  map (foldl1 (>=>)) . inits1
10:54:15 <ski> mutatis mutandis with `scanl1' and `foldl1'
10:54:26 <dylukes> english?
10:54:44 <monochrom> down with mutations and mutatis mutandis!
10:54:50 <ski> "mutatis mutandis" is latin for "ditto/the same"
10:55:04 <Botje> "change what needs to be changed"
10:55:14 <ski> (something like "changing what ought to be changed", i think)
10:55:16 <edwardk> 'changing what needs to be changed'
10:55:25 <Botje> indeed
10:55:30 <monochrom> YKWIM
10:55:37 <Botje> WKWYM!
10:55:47 <dylukes> WYSIWYG!
10:56:05 <monochrom> W/E
10:56:17 <Botje> weekend? ;)
10:56:39 <Rc43> Botje, inlining failed
10:56:40 <monochrom> W/E = whatever, but heh
10:56:48 <dylukes> preflex: tell mistertim ord_chains = scanl1 (>=>)
10:56:48 <preflex>  Consider it noted.
10:57:20 <Botje> Rc43: again with the v ~ Entry v thing?
10:58:06 <Rc43> Yep, `[Entry v0] -> Maybe (Entry v0)'
10:58:41 * ski wonders why the GHC team chose the `~' symbol there ..
10:59:13 <Botje> Rc43: can you annotate with the error?
11:02:29 <hpaste> Rc43 annotated “pastebin.com/epfgiitb” with “pastebin.com/epfgiitb (annotation)” at http://hpaste.org/50266#a50271
11:02:49 <Rc43> Botje, http://hpaste.org/50266#a50271
11:03:22 <Rc43> Botje, i am inattentive now, may be ther is something obvious.
11:04:00 <Botje> Rc43: uh, your find call is missing an argument
11:04:20 <parcs> ski: in the "Fun with Type Functions" paper there is a footnote stating that "= is used for too many other things."
11:04:31 <Botje> should be find (...) es
11:04:57 <Botje> Rc43: if you see it is trying to match a function type to a value, you missed an argument
11:10:27 <Rc43> Botje, ha, really; but error doesn't change if fix it.
11:14:36 <ski> parcs : ok, *grmbl*
11:16:16 <Rc43> Botje, =/ i am retarded, have seen what are you talking about, now it compiles
11:16:57 <Botje> yeah, I can't see how to fix the other issue though.
11:17:22 <Botje> it needs the rigid type to be convinced the two v's are the same
11:20:20 <Rc43> Botje, have you read any books about haskell? I know basics and solved about 20 different problems at university, but i havent system of this knowledge and dunno what to read "by steps".
11:20:52 <Botje> Rc43: try writing a compiler ;)
11:21:43 <shepheb> @seen snoyberg
11:21:43 <lambdabot> Unknown command, try @list
11:21:43 <preflex>  snoyberg was last seen on #haskell 262 days, 6 hours, 11 minutes and 46 seconds ago, saying: a preliminary search implies this has to do with gcc, any thoughts on how to fix this?
11:23:07 <Botje> Rc43: I learned haskell mostly by reading the gentle introduction and all about monads
11:23:07 <Rc43> Botje, there is trouble not in lack of problems, but in source from i can get knowledge; but it is solvable
11:23:18 <Botje> Rc43: and then I set out to solve project euler
11:23:32 <Botje> but most of project euler is just computation, not really interesting programming-wise
11:23:43 <Rc43> Botje, ha, solved about 10 first problems with haskell :)
11:23:52 <Rc43> yep
11:24:17 <Rc43> Botje, how many you have solved problem on PE?
11:24:30 <Botje> Rc43: I would suggest you start writing a toy compiler/editor/browser/todo list manager/...
11:25:26 <Botje> Problems Solved: 142 out of 344
11:25:37 <Rc43> Botje, yesterday i have think about new cool toy proglang.
11:25:42 <Rc43> Botje, cool.
11:25:56 <Botje> I have like the first 125 + change
11:26:57 <Botje> Rc43: I wrote a compiler from ML to C, with the help of "compiling with continuations" by Andrew Appel and "Implementation of functional programming languages" by SimonPJ
11:27:16 <Botje> Rc43: if you want to write an interpreter, check out "scheme in 48 hours"
11:27:31 <Phyx-> > maxBound :: Int
11:27:31 <lambdabot>   9223372036854775807
11:28:16 <Rc43> Botje, compiler demands good knowledge of low-level things, i think, so interpreter is more attractive for me.
11:28:33 <Botje> Rc43: you can compile to whatever you want, depending on how comfortable you are
11:28:46 <Botje> Rc43: I compiled ML to C, but you can compile to e.g. javascript or llvm
11:28:47 <ddarius> Rc43: Compiling to C doesn't.
11:29:01 <ddarius> Also what's wrong with learning low-level things?
11:29:05 <Rc43> Botje, uderstood
11:29:31 <Rc43> ddarius, there are too many other interesting things
11:30:07 <merijn> Rc43: You can also compile to any high level language. Compiling doesn't necessarily mean "to ASM"
11:30:18 <merijn> Ah, I'm late to the party I see
11:30:31 <dylukes> Botje: Compiling with Continuations looks neat. Should I get it if I'm implementing a functional language come September?
11:30:35 <ddarius> Rc43: What makes you think the low-level stuff isn't interesting or is less interesting?
11:30:37 <dylukes> (Senior project at school)
11:31:02 <ddarius> dylukes: It wouldn't hurt, but there are many, many other resources as well.
11:31:03 <Botje> dylukes: I learned a *lot* from it
11:31:19 <Rc43> ddarius, i don't think so, but now i have things, that are planned to be learned
11:31:26 <Botje> dylukes: I read all kinds of CPS papers, but I couldn't grasp how you went from the equations to actual code
11:31:26 <Rc43> omg, my english so awesome
11:31:36 <dylukes> mm.
11:31:37 <Botje> dylukes: the book helped me get it.
11:31:40 <ddarius> Botje: "Equations"?
11:31:57 <Botje> dylukes: they also have a really good discussion about closure conversion and representation
11:33:10 <Botje> ddarius: the part where they go [[e e1]] k = [[e1]] (e1'. [[e]] (e'. k (e' e1')))
11:33:33 <Botje> or is it the other way round, i forgot
11:33:56 <Phyx-> anyone know what might be wrong here?
11:33:56 <Phyx->         a1sx <- toNative (length a1) :: IO CInt
11:33:56 <Phyx->         (#poke ApiFail_t, apiresults_apifail_var1_Size) newptr479247 a1sx
11:34:05 <ddarius> Botje: It can be either way, it just determines whether arguments get evaluated first (as you've written it) or the functions.
11:34:06 <Phyx-> i'm just getting random sizes at the other end
11:34:17 <Botje> ddarius: well, yes :)
11:34:27 <Botje> but translating that into haskell code is a bit weird
11:34:43 <Botje> until you've done it once
11:34:51 <Botje> and then you say 'what was the fuss all about?'
11:35:01 <ddarius> Botje: Anyway, that goes to code as: cps (App e e1) k = cps e1 $ \e1' -> cps e $ \e' -> k (e' e1')
11:35:42 <hpaste> ian pasted “very simple function not working” at http://hpaste.org/50272
11:35:45 <Botje> yep
11:36:13 <Botje> whoever 'ian' is: "not working" is the most vague error description you can give
11:36:46 <merijn> Next time paste the compile error
11:36:56 <ian__> sorry
11:36:57 <ddarius> But the problem is the missing Eq constraint.
11:36:57 <merijn> But to answer the question, you need another type class
11:36:59 <merijn> Eq
11:37:08 <ian__> for x?
11:37:14 <ian__> okay, thanks
11:37:26 <ddarius> ian__: You can just look at what type GHC(i) infers for the function.
11:37:41 <hpaste> merijn annotated “very simple function not working” with “very simple function not working (annotation)” at http://hpaste.org/50272#a50273
11:37:55 <merijn> :t (==)
11:37:56 <lambdabot> forall a. (Eq a) => a -> a -> Bool
11:38:13 <merijn> As you can see "==" only works for types which are instances of Eq
11:38:39 <ian__> so i want this? amount          :: (Eq a, Num b) => a -> [a] -> b
11:38:39 <ddarius> Your function is bad in other ways.
11:38:43 <ddarius> as well
11:39:01 <ddarius> Albeit not in ways that will keep it from compiling.
11:39:05 <merijn> You probably want "(Eq a) => a -> [a] -> int"
11:39:07 <merijn> eh
11:39:09 <merijn> s/int/Int
11:39:46 <ddarius> merijn: Why?
11:40:09 <merijn> ddarius: Well, I guess it's no necessary but why make it return Num a?
11:40:23 <hpaste> ian__ pasted “amount function still not working included error message” at http://hpaste.org/50274
11:40:25 <merijn> The count of items is always an Int anyway
11:40:30 <ddarius> merijn: So you can use other types and handle lists longer than Int can hold.
11:40:37 <ddarius> merijn: On 64-bit systems yes.
11:40:40 <ddarius> (effectively)
11:40:48 <merijn> ian__: Oh, duh
11:41:01 <merijn> "amount n xs" on the last line, instead of "amount xs"
11:41:23 <ian__> thanks
11:41:26 <ddarius> merijn: I could want to count mod N or I may be processing a streaming list with more than 2 billion items on a 32-bit system.
11:41:39 <merijn> ddarius: I guess Integer would be more appropriate
11:41:57 <ddarius> Of course, in the latter case the function would fail due to its other problems.
11:42:03 <ian__> Num a
11:56:45 * hackagebot data-lens-template 2.1.0 - Utilities for Data.Lens  http://hackage.haskell.org/package/data-lens-template-2.1.0 (EdwardKmett)
12:05:56 <illissius`> can someone help me figure out what this type error is trying to tell me?
12:06:01 <illissius`> http://hpaste.org/50275
12:06:08 <illissius`> I've been staring at it a while and can't do it.
12:06:11 <illissius`> (GHC 7.2.1)
12:09:11 <mauke> I have no idea what most of these extensions do
12:09:18 <mauke> but it looks pretty obvious
12:09:35 <mauke> copyST must work for all types s
12:09:54 <mauke> but your default definition requires s ~ PrimState m
12:10:01 <mauke> otherwise it can't call copyPrim
12:14:01 <illissius`> hmm. but copyPrim is itself polymorphic, and works for all types PrimMonad m => m -- can't the typechecker unify it to an m whose PrimState ~ s?
12:14:02 <Fuco> if I import both Data.List and Data.Set, how can I make 'map' refer to Data.List.map? Only solution I have now is to import one as L and the other as S and use L.map
12:14:07 <Fuco> can there be a "default" namespace somehow?
12:14:50 <psii> you can write "import Data.List (map)"
12:15:19 <parcs> import Data.List as L, import qualified Data.Set as S
12:15:19 <mauke> illissius`: copyPrim requires PrimMonad m and s ~ PrimState m. this is not what copyST's type signature provides.
12:15:55 <illissius`> also, the error message says "Could not deduce (s ~ PrimState m0)", rather than plain m, which is probably significant -- why is it introducing a new type variable, rather than using the m from the type signature?
12:16:51 <mauke> AFAICT your problem is isomorphic to: class Foo a where { foo :: a -> Int; bar :: (Num a) => a -> Int; foo = bar }
12:17:14 <mauke> hmm, except I'm confusing myself with type variables here
12:17:44 <illissius`> yeah I'm doing that a lot too.
12:19:11 <mauke> class Foo a where { foo :: a -> Int; bar :: (Num b) => a -> b -> Int; foo x = bar x x }  -- now with valid invalid code
12:19:16 <copumpkin> what does the Copy class mean?
12:19:17 <copumpkin> illissius`
12:19:31 <illissius`> what do you mean what does it mean? :)
12:20:07 <copumpkin> what are instances of it?
12:20:43 <mauke> what does it model?
12:20:55 <copumpkin> I don't really have a good sense of what it is
12:21:06 <Fuco> thanks, works like a charm. So I assume using 'qualified' enforces me to use the package "prefix"
12:21:06 <copumpkin> so it makes it hard to say what it should be to work :)
12:21:19 <illissius`> well it's stripped down to just showcase the type error
12:21:23 <copumpkin> yeah, sure
12:21:30 <copumpkin> but what is the basic meaning of the class and the methods in it?
12:21:50 <copumpkin> how would you comment those methods? :P
12:21:54 <illissius`> semantically it's types whose values can have copies made in PrimMonads (ST or IO)
12:22:08 <copumpkin> so things like arrays?
12:22:29 <illissius`> or example STRef could be an instance with copyST = readSTRef >=> newSTRef (probably wrote that wrong)
12:22:30 <copumpkin> or vectors
12:22:32 <illissius`> *for
12:22:33 <illissius`> yeah
12:22:36 <copumpkin> ah
12:22:48 <copumpkin> I don't get why s is the parameter to t then
12:23:00 <copumpkin> that'd be saying Vector s -> ST s (Vector s)
12:23:00 <illissius`> copumpkin: the state thread/token
12:23:07 <illissius`> oh right, STRe can't actually directly be an instance
12:23:10 <illissius`> *STRef
12:23:14 <copumpkin> you'd need a newtype and stuff around it
12:23:25 <illissius`> need newtype Flip t a s = Flip { unFlip :: t s a }
12:23:27 <illissius`> yeah
12:23:34 <copumpkin> why not make t :: * -> * -> *
12:23:43 <copumpkin> if it's going to have to take a state parameter anyway
12:23:46 <illissius`> anyway, imagine a monomorphic version of STRef with only s as a type parameter and that could be an intance.
12:23:52 <illissius`> *instance
12:24:02 <illissius`> gah, should proofread more before pressing enter.
12:24:19 <copumpkin> instead of having a newtype
12:24:23 <copumpkin> why not give Copy an associated type too
12:24:27 <copumpkin> to make its state token a function
12:24:40 <copumpkin> then instead of forcing people to parametrize it by that
12:24:47 <copumpkin> you could just put a constraint on CopyST
12:25:29 * copumpkin tries the idea
12:25:38 <illissius`> copumpkin: I tried that, it becomes impossible to type runST-style functions using the class that way, that would've been my first approach.
12:26:29 <illissius`> there's also freeze/thaw/unsafeFreeze/unsafeThaw methods/functions not included in the paste, and I'd like a freezeRunST function and such.
12:26:41 <illissius`> anyway
12:26:45 * hackagebot GenericPretty 1.1.5 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-1.1.5 (RazvanRanca)
12:26:45 <copumpkin> ah
12:26:46 <copumpkin> hmm
12:26:50 <illissius`> I only have both copyST and copyPrim to make defining instances easier
12:27:31 <illissius`> question is whether/how I can define default implementations in terms of each other, or if my thinking's all wrong
12:30:15 <kmels> how can I have a unix-2.5.0.0 listed in ghc-pkg but the latest unix version on hackage is 2.4.2 ?
12:30:35 <kmels> it came with the install of ghc 7.2.1 btw
12:30:47 <mauke> time travel
12:31:42 <kmels> is 7.2.1 too new?
12:33:19 <parcs> sort of
12:37:30 <edwardk> annoyingly the hackage version is the old one, so stuff doesn't build right
12:38:00 <luite> is that a problem, you already have it installed if you have ghc 7.2.1 right?
12:38:18 <edwardk> luite: only if folks want to read my haddocks
12:38:31 <luite> why would they want that ;)
12:39:20 <monochrom> 7.2.1 is at once too new and too old. why too old: "this is a preview, 7.4 will come out right after ICFP" (end of september)
12:39:42 <edwardk> yeah
12:39:54 <luite> what new things will 7.4.1 bring?
12:40:37 <monochrom> features of 7.2 stabilized and fixed
12:40:39 <edwardk> lots of dph stuff i guess
12:41:47 <luite> will it bump the base version again?
12:41:54 * monochrom predicts that ubuntu 11.10 will mistakenly go with 7.2.x
12:42:58 <luite> monochrom: hasn't it already been frozen?
12:43:04 <luite> 7.0.3 is in the repositories
12:44:27 <monochrom> oh ok, just being cynical :)
12:45:05 <luite> ubuntu is like java, easy to make fun of ;p
12:46:35 <monochrom> I respect and agree with well-intending to be conservative when a distro picks versions. but the road to hell is paved with well intentions. in practice, ubuntu usually picks the wrong versions. example: 10.10 LTS picked 6.12.1, which had a fatal bug
12:47:18 <luite> hasn't it been patched since?
12:47:22 <luite> and 10.10 is no LTS
12:47:31 <monochrom> 10.04. I erred
12:47:37 <luite> ah
12:48:34 <monochrom> pretty sure not fixed in ubuntu's package
13:04:48 <copumpkin> > scanl (curry (uncurry (+) . ((0.4*) *** (0.6*)))) 0 [1..10]
13:04:49 <lambdabot>   [0.0,0.6,1.44,2.376,3.3504,4.34016,5.3360639999999995,6.334425599999999,7.3...
13:22:35 <minsa> test
13:27:52 <b0fh_ua> Hello! I need to take String and decode it with Codec.Binary.Url, which has decode :: String -> Maybe [Word8]. And then from that list of Word8 I need to get a String. Only 8-bit symbols can be used
13:28:17 <b0fh_ua> pls advice how to convert Word8 into char, so perhaps I could use Data.ByteString.Char8.unpack method
13:28:26 <edwardk> you can toEnum . fromIntegral
13:28:50 <edwardk> there is also Data.ByteString.Internal.w2c
13:28:51 <b0fh_ua> so map ( toEnum . fromIntegral ) word8Array ?
13:29:02 <edwardk> yeah
13:29:37 <edwardk> w2c may be slightly faster because normal char inserts are bounds checked, but its not worth it unless this becomes some crazy bottleneck
13:30:45 <And[y]> > return ()
13:30:45 <lambdabot>   No instance for (GHC.Show.Show (m ()))
13:30:46 <lambdabot>    arising from a use of `M426840296...
13:32:02 <And[y]> > exitSuccess
13:32:03 <lambdabot>   Not in scope: `exitSuccess'
13:36:41 <incluye> > return "1"
13:36:42 <lambdabot>   No instance for (GHC.Show.Show (m [GHC.Types.Char]))
13:36:42 <lambdabot>    arising from a use ...
13:44:18 <saco> @hoogle io
13:44:19 <lambdabot> module Data.Array.IO
13:44:19 <lambdabot> module System.IO
13:44:19 <lambdabot> Prelude data IO a
13:45:27 <mauke> if you're referring to the one from xmonad, that's liftIO
13:46:11 <saco> is there a way to get fmap to work with sets?
13:47:00 <ion> Yes, if they’re ordered and unsorted, a.k.a. lists/arrays. :-P
13:47:13 <Eelis> saco: Data.Set has its own map and mapMonotonic functions
13:47:14 <ion> (and can contain duplicates)
13:47:36 <Eelis> saco: but Data.Set.Set is not a Functor, for good reason.
13:47:46 <saco> I would like to write more abstract code
13:48:06 <saco> so it works with lists and sets
13:48:40 <saco> Eelis: what is the good reason for it to be not afunctor?
13:49:00 <mauke> fmap (const 42)
13:49:00 <saco> (other than the fact that it requires ord)
13:50:12 <Eelis> saco: the Ord requirement is the problem.
13:51:34 <danharaj> also, general uses of fmap's won't respect the ord relation, even between Ord'd sets, so fmap wouldn't preserve the invariant that makes sets efficient.
13:52:12 <saco> Eelis: in Learn you a Haskell it says to not use type constraints in when making a datatype.
13:52:41 <saco> Eelis: so would this problem be solved if that were done?
13:52:44 <Saizan> fmap : OrderPreservingMap a b -> Set a -> Set b, of course!
13:52:46 <_KY_> Can I have a function that returns either a list or a boolean?
13:53:14 <Eelis> danharaj: a specialized fmap could still maintain the invariant, it would just be costly to do so
13:53:15 <luite> danharaj: is that a problem? it could rebuild the tree for a non-monotonic map function. from the user point of view, that structure is invisible anyway
13:53:29 <Eelis> saco: sounds plausible
13:53:38 <koala_man> _KY_: you can use Either for that
13:53:43 <danharaj> The ord constraint is not on Set.
13:53:50 <danharaj> It's on the interface of Set.
13:53:56 <_KY_> koala_man: thanks =)
13:54:13 <danharaj> That's what LYAH means, it is saying that you shouldn't put class constraints in " data ... = ..." declarations.
13:55:07 <danharaj> luite: Yes, technically that would be fine but using it would signal that Set is not the right structure for your use case.
13:55:32 <ClaudiusMaximus> @hoogle monotonic
13:55:32 <lambdabot> Data.Map mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
13:55:33 <lambdabot> Data.Set mapMonotonic :: (a -> b) -> Set a -> Set b
13:56:51 <ClaudiusMaximus> > S.mapMonotonic negate (S.fromList [-5..5]) -- wonder what happens here...
13:56:52 <lambdabot>   fromList [5,4,3,2,1,0,-1,-2,-3,-4,-5]
13:57:21 <danharaj> that's strange
13:57:23 <danharaj> @hoogle map
13:57:23 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
13:57:24 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
13:57:24 <lambdabot> Data.IntMap map :: (a -> b) -> IntMap a -> IntMap b
13:57:40 <danharaj> lambdabot y u no show map in Data.Set
13:57:45 <danharaj> map :: (Ord a, Ord b) => (a -> b) -> Set a -> Set b
13:57:56 <danharaj> It seems like the lack of ord constraints in mapMonotonic is an oversight?
13:58:14 <ClaudiusMaximus> > S.toAscList $ S.mapMonotonic negate (S.fromList [-5..5]) -- wonder what happens here...
13:58:14 <edwardk> danharaj: no
13:58:15 <lambdabot>   [5,4,3,2,1,0,-1,-2,-3,-4,-5]
13:58:19 <ion> instance Functor S.Set where fmap = S.mapMonotonic
13:58:20 <ion> ghci> fmap init (S.fromList ["foo", "foo", "bar", "baz"])
13:58:20 <ion> fromList ["ba","ba","fo"]
13:58:24 <ion> ;-)
13:58:41 <edwardk> i can map monotonically to something that doesn't have a notion f order temporarily as long as i map back ;)
13:58:54 <ClaudiusMaximus> "the precondition is *not* checked"
13:59:21 <danharaj> edwardk: But if you use it polymorphically you lose all ability to manipulate the resulting Set, because the ord constraint isn't there.
13:59:27 <edwardk> yes
13:59:38 <edwardk> but i might round trip through a difference list or something
13:59:58 <danharaj> I see. It seems like there should be two functions then.
14:00:08 <edwardk> where i temporarily don't have an ordering, but i can still get them out in 'ascending order' according to the original order, view the minimum according to that no longer extant order, etc.
14:00:42 <edwardk> i don't believe in passing class constraints that aren't actually necessary to perform the last
14:00:44 <edwardk> er the task
14:01:16 <edwardk> they just create burdens on the compiler to figure out maybe that they can change your calling convention if they inline you some day, and otherwise they waste their time building useless dictionaries
14:01:46 <danharaj> I suppose if you want to use it in a polymorphic function and want Ord constraints, you can put the constraints on your function instead.
14:01:51 <danharaj> fair enough.
14:05:07 <saco> So is this a defect of Data.Set?
14:05:14 <ddarius> edwardk: Amy?
14:05:34 <edwardk> shoot you wanted me to ask her something and she's home, but i forgot what ;)
14:05:44 <edwardk> saco: no
14:05:51 <saco> (It doesn't seem to be a standard part of Haskell so it seems plausible)
14:05:57 <ion> ghci> S.fromList [id, (*10)] <*> S.fromList [0..5]
14:05:57 <ion> fromList [0,1,2,3,4,5,0,10,20,30,40,50]
14:06:07 <edwardk> saco: the lack of constraints on the data type?
14:06:13 <edwardk> saco: they don't _ever_ help
14:06:36 <edwardk> all they did was block useful code
14:07:11 <saco> edwardk: You mean the Ord constraint on Data.Set is blocking useful code, right?
14:07:18 <edwardk> yes
14:07:19 <saco> in our specific case
14:07:30 <ion> “Functor and Applicative instances for Data.Set. The precondition is not checked.” Perhaps i could contribute this to Prelude.
14:07:32 <edwardk> i can make a singleton set with no knowledge about the type
14:07:41 <edwardk> ion: hahahaha
14:07:46 <c_wraith> :t Data.Set.singleton
14:07:46 <roconnor> edwardk: what do you think of this new fclabels?
14:07:46 <lambdabot> forall a. a -> S.Set a
14:07:53 <saco> so this is basically a bad implementation
14:08:00 <edwardk> roconnor: haven't looked, the docs don't build
14:08:02 <c_wraith> note the lack of Ord a => on that type
14:08:20 <edwardk> does it still have the non-law-compliant functions for lifting over applicatives?
14:08:27 <ddarius> edwardk: Places where there are racquetball courts.  Ideally ones where I can pay just for access to the racquetball court, or are cheap, but any will do.
14:08:30 <Saizan> saco: there _isn't_ an Ord constraint on Data.Set.Set
14:08:42 <Saizan> saco: so it's not blocking anything
14:08:51 <Saizan> saco: in fact: singleton :: a -> Set a
14:09:06 <saco> I tried to use it as a functor but it seemed the ord got in the way.
14:09:12 <saco> Maybe that wasn't the problem then
14:09:13 <roconnor> edwardk: I'm not sure.  I've never used fclabels. :)
14:09:22 <Saizan> Ord is needed for Data.Set.map
14:09:28 <Saizan> and that can't be avoided
14:09:41 <ddarius> (Unless we make a type of monotonic functions.)
14:09:59 <danharaj> saco: Data.Set doesn't have a constraint on it.
14:10:08 <danharaj> You can use singleton to make a singleton set of any type.
14:10:25 <danharaj> All the other functions have an ord constraint because you can't define Set efficiently without Ord.
14:10:33 <ddarius> type Set a = a -> Bool
14:10:37 <Peaker> It would be nice if you could use Map and say the Ordering doesn't matter, choose some arbitrary ordering (e.g: Allow Complex number keys)
14:11:02 <danharaj> The whole point is to make an efficient Set.
14:11:15 <saco> OK. So should I give up trying to use Data.Set with functions that use functors?
14:11:45 <saco> I was hoping to not have to rewrite that code
14:12:14 <Eliel> Peaker: I think Set needs the Ordering so it has a way to decide which branch to descend to.
14:12:17 <saco> It would seem it would be basically the same except requiring things to be Ord
14:12:34 <danharaj> http://hackage.haskell.org/package/unordered-containers-0.1.4.0
14:12:48 <Peaker> Eliel: Yeah, I know -- but often-times you want a binary search tree just for the algorithmic benefit, and only care about the Eq instance, not the Ord instance
14:12:49 <danharaj> You can use these containers instead.
14:13:17 <Peaker> Eliel: but since Ord is used for the "correct mathematical ordering" then Complex cannot have an instance, and so you cannot have a Map of Complex (directly) even though it is a sensible thing to have in some cases
14:13:21 <edwardk> ddarius: she mentioned the 'cambridge athletic club' and some Y on the other side of town, but wasnt aware of anything particular about either one
14:13:30 <ion> ghci> S.fromList [0..5] >>= \x -> S.fromList [x, x*10]
14:13:30 <ion> fromList [0,1,10,2,20,3,30,4,40,5,50]
14:14:01 <saco> Thanks danharaj
14:14:15 <Eliel> Peaker: true, not a good idea to define Ordering for Complex, you might accidentally use it for other things then.
14:14:41 <hpaste> ion pasted “Functor, Applicative and Monad instances for Data.Set” at http://hpaste.org/50278
14:14:49 <Eliel> that HashSet from danharaj's link looks like it works for this though :)
14:15:00 <aavogt> Peaker: are newtypes that bad?
14:15:08 <Peaker> Eliel: yeah, that's why it *might* make sense to have an ArbitraryOrd class -- but class duplication is not a nice thing.. So perhaps:  ArbitraryOrd could be a base class of Ord, and Ord could be empty, and just be a "blessing" that the order is meaningful mathematically
14:15:27 <Peaker> aavogt: generalized-newtype-deriving is pretty bad :-)
14:15:40 <saco> My goal is to have something just like a list except it doesn't contain repeats. And I want it to work as a functor.
14:15:48 <edwardk> i have a Order class inside of the algebra package for partial orders
14:15:49 * aavogt doesn't think you need it here
14:15:55 <ddarius> edwardk: Tell her "thanks."
14:16:08 <Peaker> edwardk: but Map wants an absolute order
14:16:12 <edwardk> peaker: sure
14:16:19 <edwardk> partial orders kinda suck for maps ;)
14:16:46 * hackagebot HUnit 1.2.4.2 - A unit testing framework for Haskell  http://hackage.haskell.org/package/HUnit-1.2.4.2 (RichardGiraud)
14:16:51 <Eliel> Peaker: well, Hashable does that :)
14:17:00 <Eliel> that's the ArbitraryOrd :D
14:17:01 <edwardk> otoh, we have the godawful instance for double, so i guess we can't take too principled a stance ;)
14:17:34 <edwardk> kmc: btw- i may have to revamp intern
14:17:49 <edwardk> kmc: so i wouldn't go out of your way to build on top of the current design
14:18:07 <ClaudiusMaximus> has someone already written a "finite float" newtype wrapper around RealFloat that throws an exception on any NaN or Inf?
14:18:13 <edwardk> once you get a few hundred thousand elements the current caching strategy doesn't work perfectly
14:18:23 <Saizan> ion: i'd rather use Codensity Set, at least you're sure you get valid sets at the end
14:18:38 <Peaker> Eliel: Hashable is not quite Ord-but-arbitrary, though.. if the hash function result is something like Int it would also have to compute too much compared with Ord
14:18:44 <edwardk> saizan: yeah, but if you do more than about 5 steps with any decent branching factor your asymptotics go to hell
14:18:46 <ion> claudiusmaximus: Yes! Fix the nastiness of floats by adding *exceptions*! ;-)
14:19:09 <edwardk> saizan: you can use the LZ78 monad =)
14:19:15 <ClaudiusMaximus> ion: can make the difference between termination and infinite loop
14:19:20 <Saizan> edwardk: do they get worse than []?
14:19:41 <edwardk> same
14:19:46 <edwardk> actually yes
14:19:48 <edwardk> they do get worse
14:19:53 <edwardk> set building is slower in the end ;)
14:19:59 <edwardk> so you lose a log factor ;)
14:20:21 <Eliel> Peaker: huh? why would it have to compute too much?
14:20:44 <edwardk> saizan: a monad for your 'share as much as you can please' needs http://hackage.haskell.org/packages/archive/compressed/0.1.2/doc/html/Data-Compressed-LZ78.html
14:20:45 <Eliel> Peaker: all you need from Hashable is a reasonable spread of the values it gives.
14:21:02 <Peaker> Eliel: if the hash generates an Int, and your keys are large bytestrings, every comparison would look at the entire bytestring
14:21:04 <Eliel> duplicates are not a real problem, as long as they're not too frequent.
14:21:12 <Peaker> Eliel: an Ord comparison between two long bytestrings would look at just the start
14:21:20 <edwardk> the monad, etc. for that was fun to build
14:21:30 <Peaker> (except when they're equal, but then that'd typically happen once)
14:22:03 <Eliel> Peaker: That's actually simple. Just take the first 4 bytes to be the hash :P
14:22:07 <saco> ion: Thanks ion for the instances
14:22:16 <edwardk> and it actually tries to share computations fairly aggressively
14:22:16 <edwardk> peaker: then use intern ;)
14:22:26 <Eliel> alternatively, if that's a problem, use a tree designed for bytestring keys, it'll work better anyhow
14:22:27 <ion> saco: Do NOT use that. Seriously. :-D
14:22:43 <Peaker> Eliel: that hash would suck for other reasons, compared with Ord..
14:22:47 <saco> will it be slow?
14:23:28 <edwardk> peaker: anyways the argument for it doing the slower comparison is pretty much academic. hashmap rather solidly dominates the bytestring-tries in benchmarks. you have to work to make anything at all go the other way
14:23:51 <ion> saco: That’s just a joke. That will also give you AIDS if you try to use it.
14:24:01 <saco> ion: ok.
14:24:04 <dylukes> So… the july release of HP isn't happening huh?
14:24:17 <dylukes> Skip to 7.2.1 I suggest.
14:24:53 <ddarius> saco: Unless you are extremely careful it will break things magnificently.
14:25:01 <saco> ion: i wasn't going to try it before reading it carefully
14:25:14 <Peaker> edwardk: I'd supposed there are many factors involved (inefficiency of Map in practice, bytestrings do not have similar prefixes, etc)
14:26:48 <saco> What about the containers from danharaj? Would it be good to use those?
14:27:02 <ion> saco: Did you notice the examples of using the instances i pasted? They compiled and produced a result – an utterly broken result that’s nowhere near a valid Set.
14:27:06 <ddarius> Justin Zobel defined burst tries specifically for the application of loading textual data into a full-text database.  The goal was to have a compact, efficient data structure.  They were beaten in every way by a relatively simple move-to-front hash table (also designed by Zobel.)
14:27:08 <edwardk> i think its mostly that bytestring trie has to keep starting and stopping on the string, so it keeps opening it up and closing it down
14:27:51 <edwardk> whereas the hashable version opens it once on a miss, and twice on most hits
14:31:01 <elliott> If I'm in a Control.Exception.catch handler block, and I've decided that I don't care about the exception and want to propagate it, I should just use throwIO, right?
14:36:09 <jmcarthur> yes! i finally found the "My brain just exploded" error again. i thought it had been lost for all time
14:36:59 <edwardk> =)
14:37:11 <edwardk> escaped existential?
14:37:45 <dolio> No. It's irrefutable matches on existentials.
14:37:57 <jmcarthur> what dolio said
14:38:08 <jmcarthur> i matched an existential in a let binding
14:38:18 <c_wraith> yeah.  I ran into that recently.
14:38:26 <c_wraith> GHC was like "I can't do that.  use a case."
14:38:36 <edwardk> ah yes
14:38:47 <c_wraith> and I responded: "that's the only constructor.  why?!"
14:38:54 <ion> Reminds me of http://pulseaudio.org/ticket/672
14:38:57 <jmcarthur> that was my response as well
14:39:07 <applicative> > vcat [text "My brain just exploded",text "I can't handle pattern bindings for existential or GADT data constructors.", text "Instead, use a case-expression, or do-notation, to unpack the constructor."]
14:39:08 <newsham> ?faq can haskell do that without a case?
14:39:08 <lambdabot> The answer is: Yes! Haskell can do that.
14:39:08 <lambdabot>   My brain just exploded
14:39:08 <lambdabot>  I can't handle pattern bindings for existential or ...
14:39:54 <saco> ion: OK, I see what you did there.
14:40:27 <applicative> jmacarthur, how do you generate the error?
14:40:56 <dolio> data E = forall a. E a ; f v = let E x = v in ()
14:41:05 <jmcarthur> applicative: data Foo = forall a. Foo a ; foo = let (Foo x) = Foo x in undefined   -- i think should do it
14:42:02 <dolio> Sometimes it'd be okay.
14:42:09 <dolio> Sometimes not.
14:42:47 <saco> ion: I didn't know you could do that but I see how bad it is now.
14:43:25 <saco> ion: by "that" I mean making those very general instances
14:44:46 <ddarius> So does let !(E x) = v in () work?
14:45:35 * jmcarthur 's brain just exploded
14:45:48 <ion> saco: Data.Set provides these nice functions documented as “the precondition is not checked” (but not named unsafe* for some reason) that lets you shove anything into a “set” without the Ord constraint. And the pretty “for any functions f and g, f ≠ g and f > g” instances help in shoving functions into sets for the Applicative instance. :-P
14:46:54 <saco> ion: thanks. I'll go hoogle for that
14:47:24 <newsham> this iteratee tutorial http://www.haskell.org/haskellwiki/Enumerator_and_iteratee could be better.  its nice that one exists, but this one uses a few analogies and then tells you to ignore them, and has coding examples that assume you know some fancy things like how to use fix
14:47:49 <newsham> could be a little friendlier to n00bs
14:47:53 <saco> By the way, is there a way to get hoogle to act like hoogle in irc?
14:48:10 <applicative> data Something where Something :: a ->  Something; unSomething  v = let Something x = v in x
14:48:17 <ion> saco: Try its command-line version. cabal install hoogle
14:48:21 <applicative> certainly explodes whats left of my brain
14:48:22 <kmc> 'unsafe' is used for a lot of things, but an incorrectly-constructed set isn't going to segfault your program or anything
14:48:24 <kmc> afaik
14:48:25 <saco> Sometimes I want to hoogle a module but it always only looks for sets
14:48:35 <kmc> i don't think it will even break referential transparency
14:49:03 <kmc> saco, you can private-message lambdabot
14:49:15 <edwardk> newsham: there is always my almost non-existent iteratee-type
14:49:42 <kmc> newsham, not to be That Guy, but it is a wiki
14:49:46 <newsham> i dont think the tutorial needs to be discarded.. just needs a little love
14:50:06 <newsham> kmc: *nod* I know. but i dont feel warm and fuzzy about rewriting someones tutorial
14:50:14 <saco> I mean hoogle only looks for *functions* -- not sets
14:50:24 <kmc> shrug
14:50:28 <kmc> it's not very long
14:50:30 <kmc> i'd say Be Bold
14:50:33 <newsham> and I dont mind you being that guy
14:50:34 <newsham> :)
14:50:55 <kmc> if you don't want to edit it, you could make comments on the talk page
14:51:07 <jmcarthur> kmc: i take "unsafe" to mean "breaks things that the type system otherwise guarantees"
14:51:12 <saco> ion, the command line version lists Data.Set, but how do I get more info like on hackage?
14:51:30 <dolio> ddarius: It's not that smart yet, apparently.
14:51:30 <jmcarthur> s/breaks/can break/
14:51:31 <newsham> *nod*  i may make coments.. wanted to discuss it here first if there's anyone around linked to that
14:51:31 <applicative> ddarius, f v = let !(E x) = v in ()  explodes brain just fine
14:51:35 <kmc> jmcarthur, the type system doesn't guarantee referential transparency
14:52:31 <jmcarthur> kmc: the types in Data.Set would guarantee certain properties about the Set if not for functions like the one we are discussing though
14:52:43 <jmcarthur> properties like it being a valid Set
14:53:13 <jmcarthur> i suppose it's not the types...
14:53:15 <applicative> kmc, what guarantees referential transparency then??
14:53:27 <jmcarthur> it's really just that that function doesn't preserve certain invariants
14:53:35 <kmc> applicative, the fact that you haven't imported any functions that aren't referentially transparent
14:53:44 <jmcarthur> it has preconditions not checked by the type system
14:54:02 <applicative> honest intentions preserve referential transparenct
14:54:06 <kmc> yes
14:54:26 <applicative> transparency reather
14:54:28 <kmc> to convince yourself that the type system does not guarantee referential transparency, ask yourself these questions: what is the type of a referentially-transparent function? and what is the type of a non-transparent function?
14:54:29 <applicative> rather, rather
14:55:49 <kmc> Haskell's "purity" is not a type system thing
14:56:02 <kmc> it's a property of how the standard library is constructed
14:56:13 <kmc> and community norms on which things are okay
14:56:18 <kmc> which are far from consensus anyway
14:56:24 <saco>     /privmsg lambdabot @type map
14:56:52 <kmc> having a way to describe IO without side-effecting functions is still useful in a language where side-effecting functions are allowed
14:56:52 <saco> kmc, the privmsg beeps but doesn't show anything
14:57:51 <Peaker> kmc: if you disallow the FFI, unsafePerformIO, etc, then the type system can guarantee referential transparency (modulus some kinds of bottoms, maybe)
14:58:13 <jmcarthur> kmc has a point that it still depends on the standard library though
14:58:21 <kmc> Peaker, that's nothing to do with the type system
14:58:40 <kmc> "if you disallow all the non-transparent things then the type system guarantees transparency"
14:58:53 <harry__> hello all
14:59:47 <kmc> "if you disallow fromInteger then the type system guarantees the absence of integer literals in your code"
15:00:05 <kmc> "if you disallow multi-line comments then the type system guarantees the absence of multi-line comments"
15:00:08 <applicative> doesnt {-# LANGUAGE SafeHaskell #-} keep the FFI &co out?
15:00:19 <kmc> yep
15:00:45 <kmc> it's a real stretch to consider that part of "the type system"
15:01:11 <jmcarthur> kmc: it's the type system *combined* with the standard library that guarantees RT. if you were allowed implicit casts then you could potentially break RT
15:01:33 <jmcarthur> where by "cast" i mean relying on things having the same representation
15:01:36 <kmc> sure
15:01:47 <kmc> but i can make the same claim about Python
15:02:23 <Peaker> kmc: Yeah, I see.. It's different in a language with an ambient monad/auto-lifting
15:03:16 <harry__> is haskell a scripting language?
15:03:18 <kmc> jmcarthur, you're right that memory safety is a necessary condition to be able to convince yourself that code is referentially transparent
15:03:25 <kmc> harry__, "scripting language" is a useless term
15:03:29 <applicative> harry__: whats a scripting language?
15:04:43 <leod> quick question: what's the recomended library for sqlite3?
15:04:54 <saco> harry__, I think the easy answer is no
15:04:54 <harry__> something that runs on windows -:)
15:05:06 <kmc> yes, GHC and Haskell Platform exist for windows
15:05:20 <kmc> (machine code is a scripting language)
15:05:23 <applicative> harry__: yes, the leading compiler writers use Windows inter alia
15:05:24 <kmc> (?)
15:06:05 <applicative> harry__: e.g. our amusing benefactor http://research.microsoft.com/en-us/people/simonpj/
15:06:13 <kmc> jmcarthur, Peaker, you're right that the type system gives you memory safety, which is a necessary condition for ref. transparency, but it's hardly sufficient, and hardly uncommon
15:06:20 <applicative> @where Platform
15:06:20 <lambdabot> http://hackage.haskell.org/platform/
15:07:00 <applicative> ^^^ harry__ there's a (fairly big) windows installer there for the system most people use
15:07:03 <kmc> if that's all you mean, then I can say that Java's type system enforces referential transparency
15:07:33 <jmcarthur> i'm attempting no argument that the standard libraries are not necessary for RT
15:07:48 <kmc> now, an important property of Haskell is that constructs which might break ref. trans. are all imported things, and are not built in
15:07:58 <jmcarthur> just that a type system *is* necessary
15:07:59 <applicative> harry_ have you read much about Haskell? Our friends here can give you advice
15:08:31 <kmc> jmcarthur, yeah, the type system is necessary, but it's not sufficient and not the right thing to focus on
15:08:40 <Peaker> jmcarthur: is dynamic type checking also a "type system"?
15:08:48 <jmcarthur> Peaker: it counts in this case
15:08:55 <jmcarthur> i think
15:08:56 <kmc> actually I lied, not all of the problematic constructs are imports
15:09:10 <jmcarthur> kmc: floating point :(
15:09:10 <kmc> e.g. FFI
15:09:23 <kmc> floating point types are imported
15:09:27 <kmc> they're imported by default
15:09:32 <jmcarthur> ah
15:09:40 <kmc> but if we're auditing import lists we can insist on "import Prelude hiding (Float, Double)"
15:09:42 <jmcarthur> didn't realize you counted the Prelude as an import here
15:09:43 * applicative hadn't seen this spj et al paper "Termination combinators forever"
15:10:06 <kmc> jmcarthur, yes, compare to Java where there's no way to say "don't let me use global state in this function"
15:10:06 <harry__> I'm totally new to it. Just "Trying Haskell". Very nice interactive tool!
15:10:29 <erus`> 'Trying haskell' ?
15:10:34 <kmc> tryhaskell.org
15:11:02 <kmc> fwiw the SafeHaskell feature goes beyond memory safety and referential transparency, and tries to ensure "semantic consistency"
15:11:20 <kmc> hence prohibiting RULES and OverlappingInstances
15:11:34 <jmcarthur> cool! didn't know that
15:11:35 <applicative> harry__: oh cool.  You can experiment a bit more, writing your own modules, with the out of date ideone.com and codepad.org
15:11:45 <dolio> FFI is an import.
15:11:47 <applicative> i mean before downloading the mighty Platform
15:11:58 <kmc> dolio, oh?
15:12:03 <dolio> foreign import ...
15:12:13 <kmc> not what i meant, but point taken
15:12:36 <kmc> it seems to me that SafeHaskell is a very complex feature, and while this complexity may be unavoidable, it makes me think there are probably lurking bugs
15:12:41 <applicative> harry__:  also check out the Learn You a Haskell tutorial, the going starting tutorial along with tryhaskell.org.  I guess they link to it, if I remember
15:12:47 <kmc> blacklisting is always a dubious proposition
15:12:57 <Peaker> OverlappingInstances are restricted, not prohibited (they must only overlap with instances of the same module)
15:13:02 <saco> Is there a better way to read haskell cafe than using http://www.haskell.org/pipermail/haskell-cafe/  ?
15:13:20 <Botje> subscribe with your email client
15:13:22 <applicative> saco, subscribing?
15:13:29 <saco> but I want to read old stuff
15:13:55 <saco> subscribing only gives me the messages written after I subscribe
15:14:29 <applicative> harry_ and if you have trouble with something you do well to post it on hpaste.org and ask here, there's always all kinds of talk, but people will tell you what's wrong whatever they're on about.
15:14:50 <Botje> saco: you could download the gzip'd archives and import them as an mbox file
15:16:21 <harry__> thank you guys, I'll look around a bit here.
15:20:40 <applicative> harry_ I forgot to say, you can also private message 'lambdabot' who evaluates expressions beginning with a '>' like '> 1 + 1' or '> foldr (+) 0 [1..10]'
15:20:53 <ddarius> applicative: Not in private messages, you have to use @run.
15:21:01 <Peaker> >"> is probably not enough"
15:21:20 <mauke> ddarius: no, > works fine
15:21:23 <ddarius> Nope, I'm wrong.  But I'm pretty sure you can't use :t and :k.
15:21:26 <mauke> what doesn't work is :t
15:22:45 <ddarius> I've said it before, and unfortunately I'll probably say it again, but I fucking hate Java and the Java ecosystem.
15:23:46 <kmc> i really enjoy Clojure, except for the parts that involve interacting with Java tools and ecosystem
15:24:05 <applicative> ddarius, oh I think I am using a wrong definition of pm
15:26:02 <nurato> Hi
15:26:31 <applicative> hi nurato
15:26:40 <nurato> how can I make an algebraic datatype with a list and un Int?
15:26:57 <mauke> data T = C [Something] Int
15:27:08 <nurato> data Foo = Int | [Int] ?
15:28:53 <Peaker> nurato: You need to give each possible choice in there a name, called a "data constructor"
15:29:10 <Peaker> nurato: data Foo = FirstDataConstructor Int   |   SecondDataConstructor [Int]
15:30:19 <atsampson> saco: http://news.gmane.org/gmane.comp.lang.haskell.cafe isn't too bad; gmane also exports an NNTP interface so you can use a newsreader to look at the archive
15:47:25 <joe6> i am using the nanosleep of the System.Posix.Unistd and I notice with the oscilloscope that the time period between sleeps is closer to 150microseconds, though the sleep is for 100 nanoseconds.
15:47:29 <joe6> Is that expected?
15:47:36 <joe6> @hoogle nanosleep
15:47:36 <lambdabot> No results found
15:49:26 <kmc> joe6, it's not surprising
15:49:28 <ClaudiusMaximus> joe6: consult `man nanosleep` on your system; on mine it mentions things about "rounding up to granularity" and "until at least the time interval has passed"
15:49:36 <geheimdienst> joe6: i guess the haskell nanosleep uses this function: http://linux.die.net/man/2/nanosleep
15:49:40 <geheimdienst> "nanosleep() pauses always for at least the specified time, however it can take up to 10 ms longer than specified"
15:50:08 <joe6> kmc, ClaudiusMaximus, geheimdienst oh, ok. thanks.
15:50:40 <kmc> you have to do more work to get actual real-time signals
15:51:31 <joe6> kmc, like what?
15:56:09 <kmc> joe6, if you need to sleep for precisely 150μs you'd probably busy-loop
15:56:45 <kmc> and you don't want to get interrupted by the OS scheduler
15:57:21 <kmc> so set SCHED_FIFO (on Unix)
15:58:48 <ion> Or write your own realtime kernel and use a timer interrupt. :-P
15:58:59 <kmc> or write a Linux kernel module
15:59:16 <kmc> or use one of the realtime patches for linux
15:59:31 <kmc> joe6, you also have the Haskell-side stuff to worry about
15:59:35 <kmc> garbage collection, etc.
15:59:47 <ClaudiusMaximus> > 1 / 150e-6
15:59:48 <lambdabot>   6666.666666666667
15:59:51 <kmc> joe6, if I were doing this I'd split it into two programs
16:00:29 <kmc> one written in C, which reads waveform descriptions from a pipe, and outputs them using SCHED_FIFO and busy-waiting
16:00:33 <ClaudiusMaximus> > 1 / 100e-9
16:00:34 <lambdabot>   1.0e7
16:00:36 <kmc> and then the Haskell program feeds that
16:02:01 <zzo38> I can use (.) to do compose of one argument. But how do I do compose of function with two arguments?
16:02:11 <hvr> zzo38: (.).(.)
16:02:22 <zzo38> OK. Thank you.
16:02:25 <ClaudiusMaximus> @pl \f g x y -> f (g x y)
16:02:25 <lambdabot> (.) . (.)
16:02:28 <kmc> (f. ) . g
16:03:00 <kmc> it's ugly
16:03:05 <kmc> but some people will recognize the "pattern"
16:03:17 <ClaudiusMaximus> @pl \f g x y z -> f (g x y z)
16:03:18 <lambdabot> (.) . (.) . (.)
16:03:26 <zzo38> Is there any operator that can do that directly? Or would such an operator should be made?
16:03:27 <sshc> :t (.)(.)
16:03:28 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
16:03:32 <sshc> ^ not ugly
16:03:57 <zzo38> Like, if you want to use it where an operator is expected
16:04:47 <ion> (.:) = (.).(.); (.::) = (.).(.).(.); (.:::::::::) = (.).(.).(.).(.).(.).(.).(.).(.).(.).(.)
16:05:34 <sshc> zzo38: In the standard Prelud, no, there isn't such a definition.  You can always define it yourself or use a Prelude that includes it
16:05:35 <Botje> that's a lot of boobs.
16:05:45 <zzo38> OK.
16:06:17 <joe6> kmc: ok, thanks.
16:06:18 <ion> > let f = negate .: (+) in f 3 4
16:06:20 <lambdabot>   -7
16:06:38 <ion> I dislike this disparity:
16:06:47 <ion> > let f = (negate . negate) .: (+) in f 3 4
16:06:48 <lambdabot>   7
16:06:59 <sshc> Is it possible to usto use cabal to install a package whileP passing a flag to the compiler?  (I'm trying to install GPipe-Collada from hackage with a higher -fcontext-stack value.)
16:07:00 <ion> > let f = negate .: (negate .: (+)) in f 3 4
16:07:02 <lambdabot>   7
16:07:27 <sshc> (Without unpacking and editing the .cabal manually)
16:09:21 <ClaudiusMaximus> sshc: cabal install --ghc-options "-fcontext-stack=666"  doesn't spit an out an error message immediately, so i guess it might work
16:10:30 <ddarius> ion: What disparity?
16:11:27 <elliott> sshc: oh hey, GPipe.
16:11:46 <sshc> ClaudiusMaximus: Oh, that worked.  Great.  Thanks!
16:11:50 <ClaudiusMaximus> :)
16:11:52 <sshc> That *really* should be in the documentation
16:11:52 <elliott> it... might be changing soon, if I write the patches I was planning to
16:12:21 <ClaudiusMaximus> sshc: i think pretty much anything in .cabal files can be prefixed with -- on the command line
16:12:25 <ClaudiusMaximus> mabye
16:12:53 <ClaudiusMaximus> sshc: probably things from .cabal/config too
16:13:42 <ClaudiusMaximus> is it possible to have too much documentation?  i know most of my projects have too little...
16:14:38 <sshc> elliott: That won't be a problem for me at all.  I won't even be using it for a while since I need to finish multiple other libraries first
16:14:58 <elliott> sshc: well, hopefully it won't be a problem; it's intended to be a change for the better :)
16:15:06 <sshc> elliott: Really glad to see that it's still being worked on :)
16:15:10 <augur> koninkje_away! be less away!
16:15:19 <elliott> sshc: it... isn't really, but I submitted some issues on github and the maintainer has replied
16:15:37 <elliott> sshc: I did a rough port to GLFW-b from GLUT, and am ostensibly working on a generalisation so that it can be plugged into any windowing library
16:15:51 <elliott> and hopefully replacing Vec with something else since its error messages are really obscure and it's very slow
16:15:56 <elliott> and the cause of the -fcontext-stack requirement
16:16:37 <ClaudiusMaximus> Vec is the one with :. and ridiculously long typeclass contexts for everything?
16:16:52 <zzo38> How do you compose one function that takes two arguments with two functions each of which takes one argument?
16:17:14 <kmc> :t on
16:17:15 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:17:22 <kmc> :t compare `on` snd
16:17:23 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
16:17:40 <elliott> ClaudiusMaximus: yep
16:17:49 <ClaudiusMaximus> didn't realise it was "very slow"
16:17:53 <elliott> ClaudiusMaximus: to compile
16:17:57 <ClaudiusMaximus> oh
16:18:05 <kmc> @pl \x y -> h (f x) (g y)
16:18:05 <lambdabot> (. g) . h . f
16:18:08 <elliott> at runtime it's probably just typical linked list complexity
16:18:13 <elliott> like all the vector libraries
16:18:24 <elliott> (if anyone knows a good polymorphic one, please let me know; all the ones I checked out were inappropriate)
16:18:50 <elliott> https://github.com/tobbebex/GPipe/issues/1 and https://github.com/tobbebex/GPipe/issues/2 for anyone who wants to track it, fwiw (sshc)
16:18:52 <ClaudiusMaximus> i know my 1-4D vector library sped up when i did crazy things like data M44 = M44 !R !R !R ... !R -- 16 in total
16:19:09 <elliott> ClaudiusMaximus: well, with GPipe, it's basically a compiler DSL
16:19:16 <elliott> so the vectors aren't in the critical path, as I understand it
16:19:30 <zzo38> How do you compose one function that takes two arguments with two functions each of which takes one argument? Do you know?
16:19:44 <elliott> zzo38: you might find ?. pl djinn useful
16:19:51 <elliott> ?. pl djinn (a -> b) -> (b -> c) -> (a -> c)
16:19:51 <lambdabot> f = flip (.)
16:19:51 <kmc> zzo38, i asked @pl above
16:20:03 <zzo38> elliott: What does "?. pl djinn" mean?
16:20:09 <kmc> @pl \x y -> h (f x) (g y)
16:20:09 <lambdabot> (. g) . h . f
16:20:11 <elliott> zzo38: it runs djinn on the argument, then pl on the result
16:20:12 <kmc> @help pl
16:20:12 <lambdabot> pointless <expr>. Play with pointfree code.
16:20:14 <kmc> @help djinn
16:20:14 <lambdabot> djinn <type>.
16:20:15 <lambdabot> Generates Haskell code from a type.
16:20:15 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
16:20:19 <elliott> ?djinn (a -> b -> c) -> (b -> a -> c)
16:20:20 <lambdabot> f a b c = a c b
16:20:21 <kmc> @help .
16:20:21 <lambdabot> . <cmd1> <cmd2> [args].
16:20:22 <lambdabot> . [or compose] is the composition of two plugins
16:20:22 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
16:20:25 <elliott> ?pl f a b c = a c b
16:20:25 <lambdabot> f = flip
16:20:27 <elliott> ?. pl djinn (a -> b -> c) -> (b -> a -> c)
16:20:27 <lambdabot> f = flip
16:20:44 <zzo38> OK.
16:22:51 <zzo38> But how do you use the result?
16:22:52 <ion> ddarius: The need for different operators in ((f . g) .: h) vs. (f .: (g .: h)).
16:23:30 <elliott> zzo38: well that's the definition of the function to do it
16:23:41 <elliott> if it says " f= ...", then ... is a function of the type you asked for
16:27:04 <ddarius> ion: Write all your code in an uncurried style and you won't have that problem.
16:28:11 <ion> Heh, yeah
16:28:55 <dolio> You'll just have other problems.
16:29:17 <christo_m> im trying to understand list comprehensions.. Why is it that I can calcBmis xs = [bmi w h | (w, h) <- xs]
16:29:34 <christo_m> is haskell able to just extract w h from the tuple and use it as parametrs to the bmi function?
16:30:01 <Botje> christo_m: it pattern matches against each element of xs, yes
16:30:06 <pedro3005> yes, pattern matching
16:30:57 <shachaf> Is there supposed to be a module called "System"?
16:30:58 <jmcarthur> christo_m: the desugars to something that might look like   calcBmis xs = map (\(w, h) -> bmi w h) xs
16:31:02 <jmcarthur> s/the/that/
16:31:38 <jmcarthur> i bet it's not exactly that though
16:32:07 <Botje> if the match fails the element is just skipped
16:32:10 <Botje> @src catMaybes
16:32:11 <lambdabot> catMaybes ls = [x | Just x <- ls]
16:32:11 <ion> @unpl [ bmi w h | (w, h) <- xs ]
16:32:11 <lambdabot> [bmi w h | (w, h) <- xs]
16:32:19 <ion> err
16:32:21 <christo_m> i originally thought that if you're doing (w,h) <- xs as the generator, bmi would have to have a type signature which accepts a tuple-pair as a paramater
16:32:21 <ion> @undo [ bmi w h | (w, h) <- xs ]
16:32:21 <lambdabot> concatMap (\ (w, h) -> [bmi w h]) xs
16:32:24 <christo_m> not 2 distinct values
16:32:33 <jmcarthur> Botje: ah right, so it probably would look more like monad stuff, with fail
16:32:41 <Botje> yeah
16:32:43 <ion> It desugars to precisely that.
16:33:17 * jmcarthur approaches @undo with suspicion
16:33:34 <Botje> christo_m: it's not a generator. you literally pattern match the pattern against each element of xs in turn and execute the body with those bindings
16:33:57 <Botje> christo_m: you can write stuff like [ bmi w h | (w,50) <- xs ] as well
16:34:18 <ion> @undo [ bmi w h | (w, 50) <- xs ]  -- the fail thing applies here
16:34:19 <lambdabot> concatMap (\ a -> case a of { (w, 50) -> [bmi w h]; _ -> []}) xs
16:34:46 <Botje> ah, @undo is smart enough. cool :)
16:34:48 <Botje> << oblivion
16:38:18 <zzo38> No, what I should need to do, is, if you have a function called "x" that takes one parameter and returning type "Z", and "y" that takes one parameter and returning type "Z", I want "z" to take two parameters of type "Z", and I want to compose "z" to take the output of "x" and "y".
16:39:18 <zzo38> Can you understand me or did I not write it clearly enough?
16:39:21 <aavogt> @src on
16:39:21 <lambdabot> (*) `on` f = \x y -> f x * f y
16:40:19 <ion> A few function composition operators that come in base. http://heh.fi/haskell/functors/#function-instance
16:40:24 <zzo38> That might be it.
16:41:15 <ddarius> ion: Perhaps you should learn J/APl if you haven't already.
16:42:15 <ion> Erro, s/function composition operators/function combinators/
16:42:49 <ion> ddarius: Heh
16:43:56 <ddarius> That wasn't a joke.
16:45:21 <zzo38> I think it might be liftA2 which is the function I want. How to import that?
16:45:30 <geheimdienst> @hoogle liftA2
16:45:30 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:45:36 <zzo38> OK thanks
16:45:44 <geheimdienst> you're welcome
16:45:54 <ssbasi> hey, i was wondering if someone could help me out with an installation via cabal
16:46:32 <ssbasi> the package i am trying to install is hakyll-2.3.1 which grabs the latest hamlet (0.9) when it should be grabbing hamlet-0.8.2.1
16:46:47 * hackagebot haskeline 0.6.4.3 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.6.4.3 (JudahJacobson)
16:46:49 <ssbasi> is there anyway to force it to use that package via the command interface?
16:47:00 <Saizan> you can use --constraint="hamlet == 0.8.2.1"
16:47:33 <ssbasi> nice, it worked
16:47:34 <ssbasi> <3
16:47:36 <ssbasi> thanks
16:47:41 <Saizan> np
16:47:46 <ssbasi> I spent a good 30-40 minutes on it before coming here
16:47:49 <ssbasi> lol
16:48:38 <zzo38> I am not using the Applicative or Functor or Monad class, does that make any difference?
16:50:10 <zzo38> Is there any command to declare a function as commutative?
16:50:18 <Saizan> no
16:52:34 <applicative> zzo38 instance Applicative ((->) a) comes with Control.Applicative
16:53:50 <Peaker> zzo38: you can make a quickcheck property
16:54:55 <applicative> @check \x y -> x + y == y + x
16:54:56 <lambdabot>   "OK, passed 500 tests."
16:55:29 <Peaker> @let commutative :: Eq b => (a -> a -> b) -> a -> a -> Bool ; commutative f x y = f x y == f y x
16:55:30 <lambdabot>  Defined.
16:55:31 <homie> what about x*y=y*x ?
16:55:37 <Peaker> @check commutative (==)
16:55:37 <lambdabot>   Not in scope: `commutative'
16:55:38 <homie> and about x-y=y-x ?
16:55:54 <homie> and about xoy=yox ?
16:56:32 <ClaudiusMaximus> @check \a b -> a + b - b == (a :: Double)
16:56:32 <lambdabot>   "Falsifiable, after 5 tests:\n0.8333333333333334\n6.0\n"
16:56:45 <homie> or about xΔy=yΔx
16:57:12 <ion> zzo38: If you pass your functions to liftA2 you *are* using both Functor and Applicative, but you don’t need to care about that at all if you don’t want to. In this case, you can just imagine liftA2 f g h = \x → f (g x) (h x).
16:57:28 <zzo38> ion: OK.
17:00:29 <clsmith> :t liftA
17:00:30 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
17:00:49 <ion> Also note that liftA2 foo bar baz = foo <$> bar <*> baz. You get to decide which one suits your needs. Depending on the situation, one of them might require more parentheses than the other, which is the basis on which i often choose.
17:04:44 <fosskers> hey guys
17:05:07 <fosskers> I've just been through learning about newtype
17:05:27 <fosskers> and i want to make a type that is a list, but only holds items of the Ord type
17:05:35 <fosskers> which of the three should I use? type data or newtype?
17:06:02 <kmc> newtype is mostly a restricted, optimized version of data
17:06:16 <kmc> for the case of one constructor with one field
17:06:25 <kmc> it has only slightly different semantics
17:06:32 <cmccann> alternatively, it's like a version of type that allows recursive definitions
17:06:54 <kmc> it's very different from 'type'
17:06:58 <ddarius> cmccann: I think that description would be rather misleading.
17:07:04 <ion> cmccann: And has completely different instances etc.
17:07:17 <kmc> 'type' introduces a simple synonym which is interchangeable with the old type
17:07:17 <fosskers> Is somethign like this possible? ->        type Heap = Ord a => [a]
17:07:35 <kmc> 'data' and 'newtype' introduce new types
17:07:36 <ion> and can’t be interchanged with the original type freely anywhere.
17:07:37 <fosskers> i essentially want my type to BE a list, just to be restricted to Ords
17:07:38 <kmc> fosskers, "Heap a"
17:07:58 <kmc> anyway class constraints on types don't work right in standard Haskell
17:08:10 <fosskers> oh?
17:08:16 <edwardk> fosskers: you don't restrict types to only hold things of certain classes, you instead change the way you write methods that use that type or the class instances that you define to place those restrictions
17:08:29 <fosskers> oh ok
17:08:40 <ddarius> kmc: They would produce ill-formed types if expanded (except in the most trivial case).
17:08:48 <fosskers> so then using 'type' to mask a list of any type
17:08:49 <Peaker> (or you use GADT constructors)
17:09:00 <luite> are the scripts that run haddock on hackage available anywhere?
17:09:00 <fosskers> type Heap = [] ?
17:09:01 <edwardk> so what you'd do is make insert :: Ord a => a -> Heap a -> Heap a
17:09:02 <cmccann> after newtypes are stripped out during compilation, they're not particularly different from the type they wrap
17:09:08 <edwardk> fosskers: yeah
17:09:22 <ddarius> cmccann: They aren't different at all.
17:09:23 <fosskers> ahhh
17:09:39 <ddarius> cmccann: But by that type all the typechecking is done, so the whole point of type or newtype is moot.
17:09:50 <cmccann> yes, newtype introduces an opaque alias for type-checking, while data does rather a lot more
17:09:53 <edwardk> fosskers: its because its when you go to use the structure that the different things you can do with it are determined by what properties its elements have, etc.
17:10:13 <fosskers> alright thanks, ill go change my code around
17:10:18 <fosskers> but
17:10:19 <fosskers> should it be
17:10:22 <ddarius> cmccann: I agree, but that still doesn't make newtype like type which just is a syntactic short-cut.
17:10:24 <fosskers> type Heap a = [a] ?
17:10:30 <edwardk> fosskers: this turns out to be a lot more flexible way to do things, because you can later on figure out uses for a data type that only hold once you get some extra constraint
17:10:31 <fosskers> or just
17:10:32 <edwardk> yeah
17:10:34 <fosskers> type Heap = []
17:10:35 <Peaker> newtype also has GeneralizedNewtypeDeriving which breaks Haskell's type system guarantees
17:10:38 <ddarius> fosskers: The latter.
17:10:39 <edwardk> yep
17:10:55 <ddarius> The former is not incorrect though.
17:11:15 <fosskers> k gimme a sec ill go test this out
17:11:18 <cmccann> ddarius, they're both simple aliases,  the only real difference is whether they're expanded before or after type-checking. which is admittedly a very large difference, yes.
17:11:27 <edwardk> ddarius: except that you can't partially apply it later
17:11:45 <ddarius> cmccann: They aren't both -syntactic- short-cuts.
17:12:01 <edwardk> whatever will i do when i want a free monad over his heap! =)
17:13:32 <clsmith> something about [] being of sort * -> * or something, right? ^^;
17:13:44 <fosskers> okay, it compiled
17:13:57 <edwardk> fosskers: sweet =)
17:14:17 <fosskers> now all i gotta do is implement heap cascading in haskell and my life will be complete
17:14:41 <zzo38> No,  (.) . (.)   is not the type I need
17:14:44 <edwardk> is your actual heap going to be a list or something more exotic?
17:15:12 <edwardk> because as a list it takes O(n) to access the nth element
17:15:21 <fosskers> a list. index arithmetic saves the day
17:15:21 <edwardk> so you don't want to just program with that like it is an array
17:15:37 <kmc> lists are linked lists
17:15:38 <ddarius> clsmith: Haskell does not let you use a type synonym not fully applied (for good reason) therefore it is in your interest to eta reduce type aliases as much as possible.
17:15:40 <cmccann> ddarius, several GHC extensions blur the distinctions a bit, but you're right as far as plain Haskell with no funny business goes
17:15:41 <fosskers> bah
17:15:42 <kmc> you don't want to do random access
17:15:51 <kmc> use Data.Sequence
17:15:57 <edwardk> you can work with an array if you want something flat or you can make a data type for bin heaps
17:16:11 * cmccann notes that GHC does, actually, have an extension that allows using type synonyms that aren't fully applied
17:16:15 <fosskers> Data.Sequence eh?
17:16:15 <edwardk> data Heap a = Bin (Heap a) a (Heap a) | Tip
17:16:20 <kmc> yes
17:16:38 <edwardk> the bin heap type there is pretty simple to implement
17:16:39 <kmc> a sequence type with efficient random access and insertion and removal at either end
17:16:53 <fosskers> ooo
17:16:56 <fosskers> yeah, thats what i need
17:16:57 <edwardk> Data.Sequence woud let you compute with array indices, but you lose a log factor to the seq operations
17:17:06 <kmc> "log factor"
17:17:28 <fosskers> cause i need to do a lot of random access for cascading, especially for heapsort
17:17:51 <Peaker> If you care enough about performance to choose a Heap, you probably will be better off using a Heap-over-Array or such in ST
17:17:54 <kmc> if you're talking about real code and you reach the point of caring log factors, you're already beyond what asymptotic complexity will give you
17:17:56 <fosskers> okay, i get it now. and normal lists would be terrible for that
17:18:11 <cmccann> ddarius, in particular liberal type synonyms makes them slightly more tangible, while general newtype deriving makes it harder to justify newtypes as really introducing a distinctly separate type
17:18:36 <edwardk> heapsort using data.sequence will be O(n log^2 n), you can do it with a simple ADT in O(n log n)
17:18:57 <fosskers> edwardk: ADT?
17:19:02 <kmc> conceptually, GeneralizedNewtypeDeriving is just part of the "deriving" mechanism
17:19:08 <kmc> and therefore a sideshow
17:19:10 <ddarius> cmccann: The former doesn't do that and the latter doesn't do that.
17:19:12 <edwardk> data Heap a = Bin (Heap a) a (Heap a) | Tip
17:19:15 <kmc> i agree that GHC's implementation is sketchy, though
17:19:29 <edwardk> insert a Tip = Bin Tip a Tip -- i leave the rest to you ;)
17:19:33 <kmc> fosskers, algebraic data type
17:19:39 <fosskers> ah
17:19:42 <fosskers> roger
17:20:08 <ddarius> cmccann: Well the former doesn't do that where that = allows partial application of type synonyms.  It does allow them to be used in places where Haskell 2010 arbitrarily says they cannot be used, but they still must be fully applied.
17:20:23 <edwardk> instead of making up a new name for lists or sequences, i made up a new type, and said it has binary tree nodes and tip nodes, and the binary tree nodes have a value, and two children
17:20:50 <edwardk> Tip plays the role of 'null' in a pointer based heap
17:21:16 <Peaker> kmc: I don't think the standard "deriving" mechanism can break the usual guarantees of Haskell's type system the way GNTD can
17:21:23 <ion> zzo38: What’s your input, what are your functions and what do you want as output?
17:21:37 <ddarius> Peaker: That's essentially a bug.
17:21:50 <Peaker> ddarius: It is a bug -- but what is the fix to the bug?
17:21:57 <zzo38> Actually I think I figured it out now
17:22:05 <fosskers> edwardk: thanks, ill brb
17:22:32 <ddarius> Peaker: See http://research.microsoft.com/~simonpj/papers/ext-f
17:22:34 <cmccann> ddarius, they must be fully applied eventually. They can be left partially applied in contexts that GHC knows will expand to leave them fully applied.
17:22:41 <Cale> Peaker: The fix is just to generate the code as proof that the instance is valid and then discard it.
17:22:57 <Cale> (or a fix, anyway)
17:23:17 <Peaker> Cale: last time you brought a Functor/Contravariant constraint on wrapper types as a solution -- which would probably work, but seems like too special of a case
17:23:40 <Cale> Well, if you want to extend it even that far.
17:23:44 <ddarius> Peaker: I actually meant the second listed paper, but I think both of the top two address that problem.
17:23:46 <zzo38> In fact I did not at first realize what it actually was I wanted, but then I realized and correct it
17:23:50 <Cale> You could just completely disallow those instances altogether as well.
17:24:35 <ddarius> cmccann: type Foo a = [a]; data X f = X (f a); foo :: X Foo; foo = foo fails because you can't partially apply type synonyms even with -fglasgow-exts and -XLiberalTypeSynonyms
17:24:35 <Cale> (e.g. disallow any instance where the newtype appears as anything more than a parameter to (->)
17:24:37 <Cale> )
17:24:50 <Peaker> ddarius: But the second one seems like a huge hammer for a small problem
17:25:28 <Cale> I don't think that anyone actually cares about deriving instances that are really problematic or hard to handle.
17:25:52 <ddarius> Peaker: You didn't ask for a small fix, nor is losing type safety a small problem, nor is this "huge hammer" solely for that purpose.
17:25:55 <Peaker> It's an arbitrary constraint, you don't know when it'll come back to bite you
17:26:04 <Cale> So you can probably be quite conservative in what you accept and still be fine.
17:26:27 <Peaker> ddarius: Well, there appears to be several possible small fixes.. but your last point is good -- if it is fixed as part of something Haskell needs anyway, all the better
17:26:46 <cmccann> ddarius, but type Foo a = [a]; type Bar f = f String; foo :: Bar foo; foo = ["foo"] does work
17:27:31 <Cale> It's not that arbitrary if it's only the instances you could write with only lambdas/case and the newtype constructor
17:27:50 <Peaker> That's probably fine, yeah
17:28:09 <ddarius> Peaker: I recommend reading "Generative Type Abstraction and Type-level Computation"
17:28:24 <Cale> in practical terms that'll cover all the cases people commonly use generalised newtype deriving for as well
17:31:48 * hackagebot trifecta 0.29 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.29 (EdwardKmett)
17:32:58 <Peaker> trifecta has no haddock at all?
17:33:23 <edwardk> peaker: the new unix version is in 7.2.x but it can't build the haddocks on hackage because they aren't on the server =/
17:33:24 <geheimdienst> peaker, it takes some minutes to generate it. check the slightly older version
17:33:41 <edwardk> gehemdeinst: that slightly older version is almost entirely alien by comparison
17:33:42 <edwardk> ;)
17:33:51 <kmc> Peaker, the "abstract feature" behind GNTD -- the thing that would be in the spec if there were one -- is fine
17:33:54 <edwardk> you have to go pretty far back before you find a doc that builds
17:34:00 <kmc> GHC's implementation is dodgy and so has a bug
17:34:12 <Peaker> geheimdienst: I checked ALL older versions :)
17:34:47 <kmc> conceptually it's just producing a bunch of boilerplate like «instance C T where f (T x) = f x»
17:34:57 <kmc> nothing wrong with that
17:35:59 <geheimdienst> Peaker: yeah ... i meant in general that's what's up with the links that hackagebot posts
17:36:00 <edwardk> peaker: the github repo is pretty browseable
17:37:07 <geheimdienst> apparently hackage, haddock and ghc are not sure yet if they want to allow all of edwardk's stuff ... :)
17:37:59 <fosskers> edwardk: relocated. I looked at Data.Sequence... but I should skip that and just use my own ADT?
17:38:01 <edwardk> nah, i just for once actually depended on a system package that didn't supply monads or containers, so of course that is the one that doesn't make it to hackage
17:38:24 <edwardk> fosskers: you'll learn more about the functional way to do things and actually implement a better algorithm
17:38:58 <fosskers> using my own ADT
17:39:40 <hpaste> “C. McCann” pasted “ridiculous misuse of liberal type synonyms” at http://hpaste.org/50281
17:40:19 <cmccann> just to demonstrate the extent to which partial application is actually allowed
17:40:35 <Peaker> Is there any plan to improve the situation of Haskell's polymorphic containers?  e.g: Will length ever not be fixed on lists? (or alternatively, is there an alternate Prelude that fixes length and the various list-centric features to be generalized more nicely than in ListLike?)
17:40:38 <edwardk> peaker: basically it generates parsers where its easy to make pretty error messages, and which you can wrap in monad transformer stacks without having to lift everything
17:40:41 <edwardk> http://i.imgur.com/UVbhG.png
17:41:05 <shachaf> cmccann: Why is that an abuse?
17:41:12 <hpaste> christo_m pasted “euler” at http://hpaste.org/50282
17:41:25 <christo_m> why would it take so long to run this?
17:41:27 <cmccann> shachaf, anything involving counting that high with unary numbers is abusive somehow
17:41:54 <shachaf> cmccann: Counting in non-unary numbers in the type system is surely more of an abuse? :-)
17:42:05 <edwardk> and along the way it gives me a chance to scratch most of the itches i've had with regards to third party parsing libraries. ;)
17:42:16 <cmccann> shachaf, more abuse of the type system perhaps, but less abusive of general good taste
17:42:50 <Peaker> edwardk: cool.. when I touch a parsing library again... :-)
17:43:00 <Saizan> edwardk: does it also commit early like parsec?
17:43:09 <edwardk> saizan: yes
17:43:46 <edwardk> saizan: but unlike parsec it actually doesn't go out of its way to consume the input, so the commit is more about trimming the continuation than the input buffer
17:44:25 <dylukes> I'd like to make a suggestion.
17:44:48 <shachaf> I'd like to type a line into IRC.
17:44:55 <dylukes> I think something like ruby koans (in website form) would make an excellent tool for teaching newbies abstractions such as Monads, Zippers etc.
17:44:56 <edwardk> =)
17:45:06 <dylukes> Kind of, have them walk themselves through developing the abstraction.
17:45:10 <christo_m> I'd like to know why this takes so long: http://hpaste.org/50282
17:45:13 <christo_m> =(
17:45:23 <justinjay> google is everywhere
17:45:23 <dylukes> edwardk: Seems like a good idea, no?
17:45:23 <shachaf> dylukes: Why don't you make it and see?
17:45:28 <geheimdienst> ruby koans ~ haskell kans
17:45:31 <dylukes> shachaf: Because my website skills = terrible
17:45:32 <justinjay> then i look into haskell
17:45:38 <justinjay> and google is nowhere to be found
17:45:39 <edwardk> dylukes: not really my thing, but knock yourself out
17:45:40 <shachaf> dylukes: Come on, the context is what's relevant.
17:45:59 <mauke> christo_m: because your fib is fucking slow AND you're calling it twice per number
17:46:01 <luite> christo_m: that will take very long, in fact it will never end
17:46:16 <mauke> oh yeah, and the infinite list
17:46:20 <zzo38> It didn't work. What I want is, that if I have a function f x y and it takes a list y and replaces its head with x (is there such a function? Tell me) and then f .++ const = f and f .++ f replaces the head of the head of the list y with x. How to do that?
17:46:42 * cmccann finds a certain self-referential elegance in implementations of fib with time complexity O(fib N)
17:46:46 <christo_m> luite: yes
17:47:06 <luite> > length [x | x <- [1..], x < 10]
17:47:10 <lambdabot>   mueval-core: Time limit exceeded
17:47:31 <luite> christo_m: your situation is similar, you take the sum
17:47:33 <geheimdienst> so what are these ruby koans, little examples that demonstrate how to do one thing?
17:48:03 <zzo38> Do you know how to do what I mentioned?
17:48:10 <dylukes> geheimdienst: Uh, easier to show
17:48:11 <luite> christo_m: you will probably do something like   takeWhile (<40000) $  map fib [1..]
17:48:12 <edwardk> christo_m: what you want is to unfold the list, so that it knows its done. the way you have that now there is no way to know that even though fib n was >= 400000, that the next one won't be, so it keeps trying all the numbers
17:48:26 <dylukes> https://github.com/edgecase/ruby_koans
17:48:43 <luite> christo_m: takeWhile actually stops processing the list when the condition is not met anymore
17:48:47 <ddarius> cmccann: It's simply the fact that you only ever add 1 at a time.  So it must take at least fib n time.
17:48:53 <dylukes> It's basically a series of pre_broken unit tests, which fixing are supposed to teach you ruby.
17:49:03 <dylukes> Or rather, subtleties of it, like the weird nil handling and such.
17:49:08 <dylukes> I don't exactly like them *that* much.
17:49:10 <geheimdienst> hm okay
17:49:15 <dylukes> except this one
17:49:16 <dylukes> http://www.rubyquiz.com/quiz67.html
17:49:17 <dylukes> this one is amazing.
17:49:28 <dylukes> The first time it takes you 1~2 hours
17:49:32 <dylukes> afterwards its like 10 minutes.
17:49:56 <dylukes> if you generalize obsessive compulsively, you'll find like 6 finish at once :)
17:50:03 <dylukes> (if you generalize Object/Class -> Module)
17:50:08 <cmccann> ddarius, yes, it's a very simple thing. it's the way it falls out of a certain naive implementation that I find charming in a completely useless sort of way.
17:50:11 <ion> > let f x (drop 1 -> ys) = x:ys in (f 42 [0..10], f 42 [])
17:50:12 <lambdabot>   ([42,1,2,3,4,5,6,7,8,9,10],[42])
17:50:24 <luite> christo_m: (that will still be very slow though)
17:50:35 <ion> > let f x ys = x : drop 1 ys in (f 42 [0..10], f 42 [])
17:50:36 <lambdabot>   ([42,1,2,3,4,5,6,7,8,9,10],[42])
17:51:05 <ddarius> cmccann: The "naive" definition of addition takes n steps for n+m for exactly the same reason.
17:51:33 <ion> zzo38: I didn’t get this .++ business. What’s the input and what do you want as output?
17:52:15 <justinjay> haskell made my head hurt
17:52:20 <sshc> Is anybody here able to build GPipe-Examples?  If I'm not too impatient, compiling the second example (.o) seems to not be terminating.  (A simple "cabal install GPipe-Examples" should be sufficient)
17:52:23 <justinjay> like
17:52:27 <justinjay> physical pain
17:53:17 <zzo38> ion: I explained it didn't I? I don't know better explain
17:53:33 <zzo38> I want to define the operator .++ to do what I said.
17:53:40 <dmwit> sshc: I'll give it a shot.
17:53:53 <mauke> zzo38: why?
17:53:54 <dmwit> sshc: Oh, wait, never mind, I won't (sorry).
17:53:57 <sshc> dmwit: Thanks.  Which version are you using?  (Hopefully >= 7)
17:54:05 <zzo38> And also, if g replaces the tail then g .++ g replaces the tail of the tail, and so on.
17:54:28 <dylukes> geheimdienst: I think for some abstractions, its easy to sort of build them as a way to explain/teach them.
17:54:39 <dylukes> It would work well in context, I think.
17:54:50 <sshc> 'k.
17:55:06 <zzo38> The function works but I cannot compose it
17:55:08 <dmwit> sshc: Well, I'm trying it (with ghc-6.12), but I broke my package database last night, so I don't expect it will make it very far.
17:55:18 <kmc> justinjay, sounds about right
17:55:32 <justinjay> thats normal?!
17:55:44 <kmc> it's not easy to learn a new way to think
17:55:48 <mauke> justinjay: it's your brain expanding
17:55:56 <mauke> or maybe a tumor
17:56:02 <kmc> ITS NOT A TUMOR
17:56:04 <dylukes> Most people report that feeling.
17:56:14 <mauke> maybe it's lupus?
17:56:23 <geheimdienst> it's never lupus, mauke
17:56:25 <christo_m> luite: hah, mine got the same result except, as mentioned, it was hanging and not terminating at the end
17:56:25 <dylukes> I wonder if that feeling Has Kell'd anyone?
17:56:29 <dylukes> …forgive me.
17:56:51 <zzo38> ion: I want as input, the function (f x y) where x is a value and y is a list, and when the inputs are (f) and (const) then the output should be the same function (f) but when the inputs are both (f) the function should be the one replacing the head of the head of (y) with the value (x) instead
17:56:53 <dmwit> sshc: Compiling the second example is taking a long time here, too.
17:57:15 * dmwit goes to get a coffee while he waits
17:57:18 <sshc> Ah, good, so it's not just me
17:57:22 <mauke> dylukes: not if you eat a nice healthy curry and go to church
17:57:24 <sshc> Somebody should ticket this.
17:58:02 <dylukes> mauke: If you use Haskell too much you'll end up Alon(zo).
17:58:13 <zzo38> Did I explain it better this time?
17:59:31 <zzo38> I have a function (f x y) that replaces the head of the list (y) with (x) and keeps the tail intact, returning the resulting list, already.
17:59:32 <dmwit> sshc: Well, it finished now.
17:59:53 <sshc> Ah.  I must have crappy hardware then.
17:59:55 <dmwit> sshc: So just give it a bit longer, I guess. =)
18:00:01 <sshc> (I do.)
18:00:35 <sshc> Thanks for trying to build it.
18:00:55 <dmwit> Well, it took no more than three minutes here (just looking at IRC timestamps), and I've got a 2.4GHz core2.
18:01:09 <dmwit> So you do the math to decide how long you'd have to wait for yours and decide whether it's worth it. =)
18:01:48 <kmc> dylukes, that reminds me of an *awful* pun in intro CS
18:01:53 <kmc> "separation of Church and state"
18:02:11 <dylukes> hnghhh....
18:02:22 <zzo38> So I want to have a special kind of composing where composing (f) with itself results in the function (g x y) that replaces the head of the head of the list (y) with the value (x) and leaves the rest intact.
18:02:23 <dmwit> youch
18:02:24 <sshc> ..Pentium 4 here.
18:02:29 <dmwit> That's pretty bad, kmc.
18:02:35 <luite> hehe
18:02:41 <geheimdienst> separation of church and ST
18:02:49 <dmwit> sshc: So, multiply by four or five, then? =)
18:03:18 <sshc> (Also trying on a PowerPC G5 (2.2)
18:03:22 <dmwit> Let's see... there were four years between my Pentium 4 and Core2 purchases.
18:03:31 <dmwit> > 2^(4 * 12 / 18)
18:03:32 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:03:32 <lambdabot>    `GHC.Real.Fractional t'
18:03:32 <lambdabot> ...
18:03:35 <dmwit> > 2^(4 * 12 / 18) :: Double
18:03:36 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:03:37 <lambdabot>    `GHC.Real.Fractional t'
18:03:37 <lambdabot> ...
18:03:43 <dmwit> > 2**(4 * 12 / 18) :: Double
18:03:44 <lambdabot>   6.3496042078727974
18:03:57 <dmwit> So, multiply by about 6 then.
18:04:07 <dmwit> Give it twenty minutes?
18:04:15 <ion> > let modHead f (x:xs) = f x : xs in (modHead (const 'z') "aaaa", (modHead . modHead) (const 'z') ["aaa", "bbb", "ccc"])
18:04:17 <lambdabot>   ("zaaa",["zaa","bbb","ccc"])
18:04:38 <ion> zzo38: ↑
18:04:38 <sshc> That's a long time for a single object file :P
18:04:40 * sshc waits
18:08:20 <sshc> I suspect that the rediculous compile time might pertain to the list that spans a few thousand lines (the list that contains the bytes for the demon head texture)
18:09:10 <sshc> I could probably try adding a data file to the cabal project and reading that, and seeing how quickly it builds then
18:10:19 <ddarius> GHC handles large source files rather poorly.
18:11:29 <dmwit> sshc: Yes, that would speed it up a really lot.
18:16:08 <sshc> If I really wanted the texture in the source, I'd zlib-compress it and base64-encode it.  Unfortunately (iirc), 'zlib' uses asynchrous errors that are only handleable in the IO monad instead of user-handleable pure types, so you can't purely decompress anything if you don't know that the data[C is valid without some serious hacks (like tablespoon).
18:17:02 <dmwit> sshc: Have you considered that hackage package that lets you embed files in your Haskell projects?
18:17:31 <sshc> dmwit: That doesn't sound familiar.  What is it?
18:17:39 <shachaf> dmwit: Are you referring to base?
18:17:54 <dmwit> http://hackage.haskell.org/package/file-embed
18:18:13 <shachaf> Oh, in the actual executable.
18:20:22 <christo_m> Would you use Arrays in Haskell or is there a better type suited for a 2 dimensional array (trying to think how best to represent a grid in haskell)
18:21:18 <edwardk> 2 dimensional arrays is fine
18:21:50 <edwardk> the question then becomes which kind of array to use, we have so many
18:22:59 <sshc> 35 minutes and still hasn't finished compiling
18:23:32 <dmwit> sshc: =( =(
18:23:54 <christo_m> edwardk: okay, which one ? :)
18:24:28 <ClaudiusMaximus> i started (and then kinda abandoned when cross platform issues that i couldn't easily fix) a project to embed files using assembly/linker instead of preprocessor/compiler...
18:24:42 <edwardk> christo_m: depends on usage pattern, i'd start with nice functional Data.Array arrays, then consider unboxing them if you need to, then only move to STArray or IOArray as a last resort
18:25:05 <parcs> why does evalStateT have an unnecessary Monad m constraint?
18:25:13 <hpc> :t evalStateT
18:25:14 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
18:25:22 <hpc> @src evalStateT
18:25:23 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
18:25:29 <kmc> did someone (Cale?) have a little
18:25:31 <edwardk> parcs: someone was having an off day that day i guess
18:25:33 <kmc> did someone (Cale?) have a little writeup about OOP in Haskell?
18:25:58 <hpc> parcs: runStateT is the record name for that data type, so presumably evalStateT does extra monady stuff?
18:26:16 <kmc> i'll bet it uses liftM snd
18:26:21 <_KY_> Can I define a data type with another data type in it?
18:26:29 <kmc> _KY_, you can do no other
18:26:29 <hpc> evalStateT m s = do ~(a, _) <- runStateT m s return a
18:26:32 <parcs> yeah, never mind. it's necessary.
18:26:35 <ClaudiusMaximus> sshc: http://hackage.haskell.org/package/binembed-example (probably doesn't work on anything but the machine i wrote it on, though)
18:26:38 <hpc> okay, that was meant to have newlines
18:26:40 <kmc> well, not true
18:26:44 <kmc> "Bool" has no other type ni
18:26:45 <edwardk> yeah evalStateT needs to get into the underlying monad
18:26:46 <kmc> in
18:26:47 <kmc> bah
18:26:50 * kmc needs a new keyboard
18:28:13 <_KY_> But when I do that I get an error "Multiple declarations"
18:30:30 <zzo38> I was doing the question wrong. A better way is a different question I will write. If I have (f x y) to replace the head of y with x, and (g x y) to replace the tail of y with x, how do I make a function to replace the head of the tail, or the tail of the head, in terms of the (f) and (g) functions?
18:30:32 <_KY_> kmc: seems that the second data type needs its own new data constructors
18:31:02 <zzo38> Now I made a better question.
18:31:10 <zzo38> Can you answer it now?
18:31:41 <kmc> _KY_, yes
18:31:45 <kmc> you can't define two types at once
18:31:58 <zzo38> What if I instead have the pairs (f, head) and (g, tail) can you make the combined function using these two pairs?
18:32:10 <_KY_> kmc: what I want is to define the second type using the first type
18:33:23 <mun> hi everyone
18:33:39 <mun> im getting a problem
18:33:46 <mun> can anyone help me?
18:33:51 <mun> please
18:33:53 <mun> ?
18:34:18 <kmc> only if you tell us what the problem is
18:34:27 <mun> ok
18:34:34 <mun> im stuck on some work
18:34:40 <mun> i can continue
18:34:41 <kmc> i've occasionally answered a question before it's asked
18:34:45 <mun> wait
18:34:49 <kmc> but that only really works on one question
18:35:16 <kmc> mun, ask your question
18:35:16 <geheimdienst> which question is that?
18:35:23 <mun> The program should meet the following objectives:
18:35:30 <kmc> geheimdienst, "why am i getting linker errors"
18:35:41 <kmc> though "should i learn haskell" might be a better one
18:35:43 <mauke> is this homework?
18:35:47 <mun> 1.	To determine the number of items purchased per customer (it should be in the range of 1-10)
18:35:47 <geheimdienst> kmc, use --make. it's the default since 7 or something
18:35:49 <geheimdienst> ;)
18:35:52 <kmc> geheimdienst, ;)
18:36:02 <mun> ive to write a program
18:36:11 <mun> for a shop
18:36:28 <kmc> in Haskell?
18:36:30 <mun> ang do the average per customer
18:36:49 <mun> can anyone help me?
18:36:59 <ddarius> mauke: I don't think any real shop would limit the number of items a customer can buy to 10.
18:37:03 <kmc> are you writing this program in Haskell?
18:37:16 <mauke> I bet it's java homework
18:37:19 <mun> im using C
18:37:25 <ddarius> mun: You haven't asked a question.  But if the question is "Will you do my homework for me?" the answer is "No."
18:37:26 <mauke> ooh, nice
18:37:29 <kmc> then you're in the wrong channel
18:37:30 <kmc> try ##c
18:37:35 <mun> ive dne some coding
18:37:36 <kmc> (i'm sure that will end well)
18:37:40 <mun> i can show u
18:37:47 <mauke> mun: why are you in #haskell?
18:37:52 <mun> but i cant do the loop
18:37:54 <mauke> mun: why are you in #haskell?
18:38:01 <ssbasi> lololol
18:38:03 <mun> i can calculate for only one customer
18:38:04 <mauke> mun: why are you in #haskell?
18:38:14 <kmc> @where ops
18:38:14 <ddarius> mauke: Just +q him and move on.
18:38:14 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
18:38:36 <geheimdienst> mun, we don't discuss c in here, this is a channel for haskell
18:38:42 <mun> oh
18:38:44 <mun> ok
18:38:48 <mun> anyways
18:38:50 <mun> thanks
18:38:57 <kmc> *cough* yes, we never discuss C here
18:39:07 <mauke> s/C/C homework/
18:39:43 <ddarius> We should have some more Sather discussions.
18:41:23 <geheimdienst> kmc, i feel like i'm the mom who told the baby "sweetie we don't go poopy-poo on the living room floor" with you being the dad going "*cough* well actually, when i was out with the guys last week ..."
18:41:33 <kmc> can we get Freenode to lie about the size of this channel
18:41:59 <ddarius> kmc: Just hack the ircd.
18:42:02 <solrize_> "The last good thing written in C was Schubert's Ninth Symphony."
18:42:11 <kmc> haha
18:42:22 <geheimdienst> @remember solrize "The last good thing written in C was Schubert's Ninth Symphony."
18:42:23 <lambdabot> Done.
18:42:37 * shachaf supports Sather discussions.
18:42:38 <Cale> Hey, was that mun the same guy who wrote Frag?
18:42:48 <ddarius> Cale: I doubt it.
18:42:54 <ddarius> But "Mun" is the name of the Frag guy.
18:43:07 <Cale> Ah, yeah, reading over it, probably not the same guy :P
18:43:32 <edwardk> wow, sather is a name i haven't heard in a long time
18:43:32 * ddarius ponders how to make an abstraction in Java.
18:43:34 <zzo38> I think C is good programming language though. Haskell is good for different thing than C. And, also the thing with other programming languages, too.
18:43:50 <solrize_> quote was from http://coding.derkeiler.com/Archive/Python/comp.lang.python/2009-02/msg02680.html
18:44:20 <shachaf> ddarius: I don't think that's how Java works.
18:44:47 <cmccann> shachaf, I think they have code generators for that
18:44:48 <ddarius> solrize_: It looks like he is quoting from elsewhere.  Also Python programmers aren't really in a position to make that claim.  In fact, few are in a position to make that claim.
18:45:16 <ddarius> edwardk: Have you ever used Sather?
18:45:34 <shachaf> Is anyone in a position to make that claim?
18:45:57 <edwardk> yeah, i rather liked sather as a cleaner eiffel
18:46:03 <edwardk> i wrote a lot of eiffel
18:46:11 <solrize_> i liked penguinofdoom's quote
18:46:19 <ddarius> Wow, I didn't know people had actually used Sather.
18:46:30 <shachaf> ddarius: I'm told its iterators are nice.
18:46:33 * shachaf has never used it.
18:46:41 <kmc> hey, i put together a FAQ for #haskell:  http://haskell.org/haskellwiki/FAQ
18:46:45 <ddarius> Admittedly, I was also pretending that people didn't use Eiffel.
18:46:49 <kmc> you all should give me feedback, or just edit it
18:47:07 <kmc> or write in common questions with a "FIXME" answer
18:47:13 <Cale> I think there are better languages than C for the things that C is good at. LLVM in particular seems like a better compilation target.
18:47:23 <wli> C has a number of problems related to its late 1960's / early 1970's origin.
18:47:30 <edwardk> eiffel, or how i learned to stop worrying and use mixin inheritance to do EVERYTHING
18:47:38 <kmc> yeah, the lack of a clean way to do guaranteed tail calls in C nearly kills it as a compiler target
18:47:52 <solrize_>     PenguinOfDoom: Being enlightened gentlemen, we split all programming languages into two groups, sucks and doesn't-suck and put all of them into the first group.
18:48:00 <cmccann> I have a hard time taking Eiffel seriously when it manages to get variance actively, exactly wrong
18:48:00 <shachaf> kmc: Guaranteed tail calls are pretty easy, aren't they? :-)
18:48:06 <edwardk> a lot of my goals in kata are to help me get that level of productivity back in some ways
18:48:15 <zzo38> Well yes there are some things wrong with C for sure; LLVM is designed better in my opinion.
18:48:24 <wli> The C module system (or lack thereof) is a real killer in large programs such as kernels.
18:48:34 <sshc> @faq
18:48:35 <lambdabot> The answer is: Yes! Haskell can do that.
18:49:16 <kmc> i like that Linux actually bolts on an additional scoping level in C
18:49:21 <kmc> and it's even nice to use
18:49:21 <wli> Some of its singlepass affairs have disappeared in recent language revisions.
18:49:24 <zzo38> wli: I have never had the problem. I generally write even a large program as a single book and it compiles a single C source file into the executable file.
18:49:27 <wli> kmc: Which is this?
18:49:44 <wli> zzo38: "Single book" meaning what?
18:49:44 <kmc> wli, EXPORT_SYMBOL
18:49:51 <kmc> (technically, there's a whole family of those)
18:50:10 <zzo38> wli: Meaning, a single ".w" (CWEB source) file producing a single ".c" file and a single ".tex" file.
18:50:30 <kmc> C seems like a great language for writing kernels, until you look at how many GCC extensions Linux uses
18:50:41 <kmc> i'd say GNU C is a pretty good language for writing kernels, though
18:51:26 <wli> Tailcalls would still help kernels massively.
18:51:33 <cmccann> kmc, did... you write that whole FAQ just now?
18:51:43 <kmc> not just now
18:51:51 <kmc> sporadically over the course of a few days
18:52:02 <zzo38> Yes, and that makes LLVM what I consider better designed than C in many ways.
18:52:05 <kmc> but yeah, essentially all the content is written by me
18:52:13 <cmccann> kmc, ok, that's a little more reasonable
18:52:31 <zzo38> I think LLVM is a pretty good programming language.
18:52:32 <kmc> see, i have all these answers in mental cache due to spending an unreasonable amount of time in #haskell
18:52:40 <kmc> i think LLVM is a pretty cool guy
18:52:41 <ddarius> Haskell is not a typical "functional language" because most "functional languages" are not functional.
18:52:57 <kmc> Haskell is a true Scotsman
18:53:10 <geheimdienst> ka-ching
18:53:17 <kmc> a Glaswegian even
18:53:34 <cmccann> there's more to Haskell than GHC :T
18:53:51 <kmc> ;)
18:53:52 <ddarius> No, there is less to Haskell than GHC.
18:53:58 <kmc> also true
18:54:06 <wli> There used to be nhc(98), hbc, yhc, not sure what else.
18:54:28 <zzo38> Another (unrelated) question: Do any of you in this channel understand Magic: the Gathering as well as understanding Haskell?
18:54:42 * shachaf wonders if there could be a Haskell compiler that doesn't end with "hc".
18:54:50 <kmc> hbc
18:54:54 <ddarius> shachaf: You mean like the first one?
18:54:55 <shachaf> Oh. Well, yes.
18:55:07 <shachaf> I suppose there is that.
18:55:09 <cmccann> ddarius, actually I vaguely recall there being some obscure point where GHC only implements a limited subset of something in the Haskell report... but I can't recall what.
18:55:15 <geheimdienst> and lhc, uhc, jhc i believe ... no clue what they do however :-) one of them seems aimed at whole-program optimization or some such, istr
18:55:27 <kmc> GHC doesn't implement the prohibition on dots in module names ;)
18:55:27 <edwardk> hrmm. one common idiom i keep seeing in monadic code is the x <- foo, y <- bar, z <- baz; return $! f foo bar baz
18:55:37 <edwardk> i wonder if it would make sense to capture a combinator like
18:55:41 <wli> jhc I vaguely remember once mentioned; I don't remember lhc or uhc.
18:55:41 <shachaf> cmccann: GHC implements a superset of a subset of Haskell.
18:55:42 <ddarius> geheimdienst: LHC was a fork of JHC.
18:55:43 <kmc> sounds like liftM3'
18:55:52 <cmccann> shachaf, I agree completely
18:55:59 <edwardk> f <$!> m = do a <- m; return $! f a
18:56:01 <edwardk> or something
18:56:04 <kmc> JHC, UHC, and Hugs all have cool extensions GHC doesn't
18:56:21 <shachaf> Doesn't Yhc, too?
18:56:24 <kmc> probably
18:56:25 <kmc> which?
18:56:37 * shachaf doesn't remember.
18:56:44 <wli> hbi had some niceties ghci lacks to this day.
18:56:58 <kmc> even if nobody wants to use !GHC, it's worth acknowledging they exist and taking ideas from them
18:57:01 <ddarius> HBC, to this day, is a very nice implementation of Haskell.
18:57:11 <shachaf> What extensions that Hugs have that GHC doesn't?
18:57:13 <wli> I think data definitions at the interpreter prompt, not sure if class definitions or instance definitions were.
18:57:18 <shachaf> Maybe Yhc has "exists"?
18:57:22 <kmc> shachaf, Trex, an extensible record system
18:57:36 <kmc> you know, that thing people always say they wish existed
18:57:42 <kmc> despite that, we never talk about Trex
18:57:45 <kmc> ever
18:57:46 <ddarius> Also restricted type synonyms.
18:57:48 <kmc> yes
18:57:51 <ddarius> Because TREX is pretty crappy.
18:57:55 <kmc> probably
18:58:10 <kmc> but isn't it worth talking about how and why it's crappy, and what we'd improve?
18:58:24 <kmc> there's certainly a lot of that about Haskell 98's records
18:58:27 <ddarius> kmc: There are many, many papers about better module/record systems.
18:58:37 <kmc> yeah, probably
18:58:44 <kmc> they don't come up here either
18:58:54 <kmc> it's just "Haskell records suck!" "yeah!" "..."
18:58:55 <ddarius> Moral of the story: People are ignorant.
18:59:21 <cmccann> edwardk, not sure if the infix style there makes sense. you'd need to do things differently to handle different arities, wouldn't you?
18:59:24 <kmc> JHC has ACIO
18:59:28 * kmc wants ACIO in GHC
18:59:36 <kmc> i might try implementing it
18:59:41 <kmc> but it seems likely to touch off a shitstorm
18:59:42 * ddarius doesn't personally have any problem with Haskell's record system or module system.  They could certainly be better, but they aren't broken; just simple.
18:59:44 <zzo38> What does ACIO mean?
18:59:51 <kmc> "affine central IO"
18:59:56 <kmc> means IO actions executed at top level of a module
19:00:03 <kmc> for things like global IORefs
19:00:15 <kmc> which right now you do in GHC with an unsafePerformIO hack
19:00:37 <shachaf> It's a good thing unsafePeformIO hacks aren't controversial.
19:00:50 * shachaf wonders why the nick "unsafePerformIO" is apparently banned in this channel.
19:00:55 <shachaf> Would be nice to have tab completion for it.
19:01:12 <cmccann> I suspect that, considering quality of module systems in languages, Haskell's occupies the simplest local maximum
19:01:17 <kmc> yeah
19:01:24 <kmc> i like Haskell's module system for what it is
19:01:28 <geheimdienst> kmc, what, it runs these actions when the module loads?
19:01:40 <kmc> the various sorts of imports etc. are nicely orthogonal
19:01:48 * hackagebot tkyprof 0.0.5.1 - A visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.0.5.1 (MitsutoshiAoe)
19:01:50 <shachaf> unsafePerformIO++
19:01:50 * hackagebot tkyprof 0.0.5.2 - A visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.0.5.2 (MitsutoshiAoe)
19:01:58 <shachaf> Sadly applicative won't get the karma.
19:02:02 <kmc> geheimdienst, yeah.  they're restricted to things which commute with the rest of IO, so order between modules doesn't matter
19:02:19 <kmc> "affine" = if result is ignored, it's like the action never executed
19:02:23 <kmc> "central" = commutes with all other IO
19:02:34 <kmc> so it's mostly things like newIORef
19:03:38 <cmccann> kmc, a more structured, generalized, and deliberate way to describe doing things like "topLevelBinding = unsafePerformIO $ newIORef foo", right?
19:03:51 <kmc> yeah
19:03:52 <kmc> and safer
19:04:05 <wli> I like LLVM from the POV of coverage of the low-level mechanics needed for kernel hacking, but as far as abstraction-building at least as it's done in languages like C (unsure what else to throw in for comparison), it's not entirely ideal.
19:04:07 <kmc> that topLevelBinding will break in GHC unless you use the NOINLINE pragma
19:04:25 <_KY_> Can I define: data Var = Var Int, and then data Atom = Var | ...?
19:04:28 <cmccann> kmc, right, I should have added "easier to do correctly" as well
19:04:30 <kmc> any point where you're relying on optimization-control pragmas for correctness, you should step back and reconsider your life choices
19:04:53 <kmc> and yeah it also solves the ordering problem, by restriction
19:05:10 <kmc> there's an embedding function of type IO a -> ACIO (IO a)
19:05:10 <ddarius> kmc: Agreed, because that means you are a programmer, and thus should reconsider your life choices.
19:06:08 <kmc> which returns an IO action that performs the input action iff it's not been performed yet
19:06:13 <kmc> and gives you the (new or old) result
19:06:31 <kmc> you can imagine implementing this with ACIO MVars
19:06:37 <kmc> so it's not a fundamental addition
19:07:44 <ddarius> kmc: You may want to emphasize that unsafeCoerce is generally not used.
19:08:01 * cmccann still thinks most things ACIO would be used for are symptoms of suboptimal design in the first place, but that's a harder battle to fight, alas
19:09:01 <hatds> _KY_: no, you can't conflate the notion of a constructor and a data def
19:09:33 <kmc> cmccann, yeah, e.g. suboptimal design in the C library you're wrapping
19:09:47 <cmccann> kmc, yes, I really can't complain in that case
19:10:12 <cmccann> but it makes me sad to see people do that sort of thing in code that's not tied to FFI bindings or whatnot :[
19:10:20 <sshc> ACIO: that's the hypothetical concept, right?
19:10:27 <kmc> it's implemented in JHC
19:10:34 <talk> i have an application that deal with unicode. If i use bytestrings would the letter be truncated?
19:10:40 <sshc> kmc: Are you aware of any documentation?
19:10:50 <kmc> sshc, somewhere.  i had trouble finding it
19:10:53 <_KY_> hatds: what if I want to include in the data type Atom a component as Var?
19:10:56 <kmc> talk, that's an ill-posed question
19:11:16 <kmc> ByteString holds bytes
19:11:21 <kmc> you can read a file as bytes
19:11:27 <kmc> and then convert those bytes to Unicode characters
19:11:29 <hatds> _KY_: you could do Atom = Con1 (Var) | ... more constructors...
19:11:30 <talk> http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html
19:11:33 <kmc> see Data.Text.Encoding
19:11:36 <talk> the first warning
19:11:42 <kmc> or you can use Text IO directly
19:12:17 <talk> for now i just want to put the text in a db
19:12:19 <hatds> _KY_: it isn't in general easy to make the decision between Atom = Con1 Var | ..  vs Atom = Con1 Int | ...
19:13:03 <_KY_> Do I need to put () over Var?
19:13:10 <ddarius> No.
19:13:12 <hatds> _KY_: no, that was just me
19:13:19 <ByronJohnson> talk: Unicode has different encodings.
19:14:32 <shachaf> kmc: let Just x = mx in ... also gives a reasonably-helpful error message.
19:14:33 <ByronJohnson> talk: UTF-8, for example, is backwards compatible with ASCII for characters <= 0x7F.  When the first bit is 1, there are several bytes that represent a single unicode character.
19:14:43 <kmc> shachaf, good point
19:15:35 <talk> ByronJohnson, I mean, I have a unicode text if i keep it in a bytestring, would i be fine?
19:15:52 <kmc> you can't keep "Unicode text" in a Bytestring
19:15:53 <ByronJohnson> Those represenstations are stil made up of bytes.
19:15:54 <zzo38> talk: Depends what you are doing with it, I would think.
19:16:01 <kmc> you can keep UTF-8 or UTF-16 or UTF-32 in a ByteString
19:16:10 <kmc> http://www.joelonsoftware.com/articles/Unicode.html
19:16:17 <ByronJohnson> talk: You can keep representations of unicode in a bytestring, yes
19:16:49 <kmc> @where unicode
19:16:49 <lambdabot> I know nothing about unicode.
19:16:56 <kmc> @where+ unicode http://www.joelonsoftware.com/articles/Unicode.html
19:16:56 <lambdabot> Good to know.
19:17:29 <kmc> @flish
19:17:30 <lambdabot> Not enough privileges
19:17:32 <kmc> :(
19:17:42 <kmc> why is that a privileged operation?
19:17:49 <Axman6> @fl
19:17:49 <lambdabot> Not enough privileges
19:17:52 <Axman6> @f
19:17:52 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber flush foldoc forget fortune fptools free freshname ft . ? @ bf v
19:18:41 <applicative> talk, why not just use String?
19:18:41 <hatds> Bytestring seems poorly named.  Why "string"?
19:18:41 <Axman6> i guess it causes IO to happen (saving the state to disk) and it might be quite easy to fill up the @where db with spam
19:19:32 <talk> because the db package uses bytestrings, the blaze packega uses it. turtles all way down
19:19:35 * ddarius thinks that programmers forget that the word "string" has non-code related meanings.
19:20:08 <shachaf> ddarius: "string" is a string, not a word.
19:20:27 <shachaf> Unless your word size is 48 bits, or something like that, I guess.
19:20:41 <hatds> ok, but there are words besides "string" that make more sense in both ordinary English and within the context of programming
19:21:03 <kmc> it's better than FastPackedString
19:22:28 <RyanRN> Anyone have neat tricks for determining the type of a subexpression within a larger program?  (Like you can, for example, with F# / visual studio.)  Personally I just introduce a type error by adding a number or something so I can get it in the error message...
19:22:31 <RyanRN>  but I'm thinking about implementing something for this that uses GHC as a library and digests its typechecking output to divine the answer.  I'm not aware of any existing package that does it.
19:24:02 <RyanRN> This page makes an effort at addressing the question:  http://www.haskell.org/haskellwiki/Determining_the_type_of_an_expression
19:24:32 <cmccann> RyanRN, have you seen https://github.com/sebastiaanvisser/ghc-goals ?
19:24:53 <cmccann> incomplete, and needs a bit of tinkering to get what's there to work, but does exist
19:25:13 <RyanRN> No, I haven't.  (Checking it out.)
19:25:27 <ivanm> preflex_: seen chrisdone
19:25:28 <preflex_>  chrisdone was last seen on #haskell 12 hours, 32 minutes and 16 seconds ago, saying: yeah it'll be fine
19:25:44 <applicative> there was a pretty amusing response to a question about the type of where clauses on -Cafe.
19:26:45 <applicative> the solution was to give an obviously absurd type "where grrr :: Char ; grrr x y = x * y etc..." and pray the ghc gives its opposing opinion.
19:27:13 <RyanRN> Yep, that's basically my tack too
19:28:02 <RyanRN> it's a common problem with type inferenced languages it seems… I remember having the same issue with OCaml… there's a top-level-expression bias.  The compiler will happily report the signatures of top level expressions.
19:28:14 <sshc> dmwit: After 1 hour and 12 minutes, that object file *FINALLY* compiled on my PowerPC G5 (2.2).  On my Pentium 4, it's still compiling (as of now, 1 hour and 40 minutes).  (This is the second example of GPipe-Examples, which is availabel on hackage).
19:28:29 <zzo38> I figured out how to do replacing the head of the head, tail of the head, etc, now. Now I do not need help with that anymore because I figured that out.
19:28:29 <sshc> Interestin.g  I've often had similar thoughts. (WRT types)
19:28:30 <RyanRN> Are the output of the -ddump-tc flags supposed to be easily parsable?  Or just for humans?
19:28:44 <ddarius> RyanRN: Things become much more complicated in context.  Even just being able to notate a reference to subexpression does not have a clear answer.
19:29:14 <sshc> kmc: I think this should be added to the FAQ
19:29:19 <zzo38> In fact no composing is needed at all.
19:29:56 <RyanRN> @ddarius — Could you unpack that a bit more?  What do you mean to "notate a reference to subexpression"?
19:29:56 <lambdabot> Unknown command, try @list
19:30:05 <RyanRN> ddarius — Could you unpack that a bit more?  What do you mean to "notate a reference to subexpression"?
19:32:34 <hpaste> “C. McCann” pasted “ghc-goals sorta works” at http://hpaste.org/50284
19:32:50 <cmccann> RyanRN, take a look at what I hpaste'd there
19:33:21 <RyanRN> Thanks, I justed checked out ghc-goals but haven't figured out what it does yet.  (I don't know what agda goals are.)
19:33:32 <ddarius> RyanRN: With a GUI interface like Visual Studio you can just highlight a section, but with a textual interface like GHCi how do you say that you want the right subexpression of the + in the third function of the where clause?  (Implementing even the highlighting is more difficult than it may at first seem.)
19:34:06 <hatds> I don't see what's so difficult.  The compiler has an AST, so it already has a clean notion of subexpressions.  Notating that to the user could be done as "source file + line number + print what the subexpression consists of (like "filter f xs").
19:34:22 <hatds> Conversely, the user could specify a subexpression to the compiler a similar way single-steppng works in ghci
19:34:25 <cmccann> RyanRN, it's not exactly what you're after but might be a starting point if you want to implement something to suit your needs
19:34:28 <ddarius> hatds: The question is how does the -user- tell the compiler.
19:34:39 <RyanRN> Yeah I just want an interface that does it based on File,Line,Col
19:34:44 <RyanRN> Then I can call it from emacs
19:34:44 <ddarius> hatds: That is one possibility.
19:34:48 <RyanRN> Or Leksah can integrate it
19:35:00 <RyanRN> (Leksah only gives you types of top level expressions currently)
19:35:28 <ddarius> RyanRN: You will find that that is a bit trickier than you might at first expect, though certainly doable.
19:35:28 <kmc> can http://hackage.haskell.org/package/scion do this?
19:36:21 <cmccann> also, note that for single identifiers it's not too hard to extract types using the GHC API
19:36:27 <RyanRN> ddarius — yes, even figuring out what the current "expression" is based on the single point emacs cursor will be a bit of a hack
19:36:42 <RyanRN> cmccann, in that hpaste, is the idea that the ghc-goals comment was generated and inserted by ghc-goals?
19:36:51 <cmccann> it's mostly dealing with complex subexpressions with polymorphic types that gets tricky
19:36:59 <cmccann> RyanRN, no, that was me, sorry
19:37:14 <cmccann> I ran it from the command line and dropped the output into the comment
19:37:19 <RyanRN> ah, got it
19:37:23 <cmccann> likewise copy+paste on the GHCi session
19:37:36 <RyanRN> So it just fills in the type for uses of undefined?  Nice.
19:37:46 <Phyx-> @hoogle poke
19:37:47 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
19:37:47 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
19:37:47 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
19:37:51 <cmccann> RyanRN, it can do a bit more, though I think the output there isn't actually correct, heh
19:38:10 <sshc> kmc: I'd rewrite the last paragraph of the FAQ.  Conceptually, ST is a valid concept and can be implemented; it's just optimized to use the same memory.
19:38:14 <talk_> and how do convert strict to lazy bytestrings ? unpack . pack ?
19:38:18 <cmccann> RyanRN, but yeah by default it'll spit out the expected type for any "undefined"s.
19:38:40 <RyanRN> (cmccann) That's the first step to the kind of autocomplete I'd like to see one day… the tab completion that leksah for example implements is not as useful for functional languages as for OOP.
19:38:42 <edwardk> one rather annoying consequence of the current cps'd implementation of parsec is if you use most any form of recursive applicative definition, it fails horribly
19:38:46 <ddarius> sshc: Actually it can't be completely implemented.
19:39:07 <RyanRN> Really what I want to autocomplete would be the possible functions that can apply to a value of a given type…
19:39:22 <hatds> recursive applicative definition?
19:39:32 <kmc> talk_, no, that's horribly inefficient
19:39:35 <cmccann> RyanRN, the idea behind ghc-goals is a different sort of autocomplete, namely where you leave a placeholder and then expand it semi-automatically based on its context
19:39:41 <RyanRN> So for x, (undefined x), then ghc-goals for example can find the type of undefined… then the tricky part is to search the available functions for applicable ones
19:39:41 <kmc> talk_, Lazy has fromChunks iirc
19:39:47 <kmc> which takes a list of strict ByteStrings
19:40:04 <edwardk> manyTill p end = go where go = ([] <$ end) <|> ((:) <$> p <*> go)
19:40:24 <cmccann> RyanRN, yes, that was the eventual plan I think. someone who's used agda can probably give you a better idea of what they were aiming at.
19:40:43 <parcs> will `sequence . repeat . f` be more performant than `let g x = liftM2 (:) (f x) (g x)`
19:40:44 <edwardk> is logically the same as manyTill p end = scan where do { end; return [] } <|> do x <- p; xs <- scan; return (x:xs)
19:44:14 <hatds> really, parsec fails with the applicative one?
19:44:28 <edwardk> ah
19:44:37 <edwardk> no it looks like it is my applicative instance at fault
19:44:39 <edwardk> hrmm
19:44:51 <edwardk> but there are a number of hacks in place around many, etc.
19:45:28 <christo_m> i have a function that is triangleNumber::Int -> Int and divisors::Int->[Int]  . i want to zip and have a pairing such of (triangle number, list of its divisors)
19:46:26 <saco> The Industrial Haskell Group says it has 3 full members, but I only see Galois and Amgen. Who is the third?
19:46:49 <saco> Also I wonder why Amgen uses Haskell. It's not obvious from their page.
19:46:54 <ivanm> @tell chrisdone F8 seems to go to the top of the file rather than the import list, and F8 only sorts them, doesn't do the transformation :/
19:46:54 <lambdabot> Consider it noted.
19:47:06 <ivanm> saco: it's a sikrit!
19:47:16 <ddarius> :t let tN :: Int -> Int; divisors :: Int -> [Int]; tN = tN; divisors = undefined in tN &&& divisors
19:47:17 <lambdabot> Int -> (Int, [Int])
19:47:19 <ivanm> and they use Haskell because they want to? *shrug*
19:47:49 <ivanm> ddarius: any particular reason why you use tN = tN but divisors = undefined?
19:47:53 <edwardk> yay, i finally got trifecta to where it can run non-toy parsers =)
19:48:12 <ivanm> edwardk: example?
19:48:14 <ddarius> ivanm: undefined is easier to type.
19:48:18 <ivanm> heh
19:48:41 <cmccann> :t \f -> zip <*> map f
19:48:41 <lambdabot> forall a b. (a -> b) -> [a] -> [(a, b)]
19:48:50 <edwardk> well, its still toy-ish, but i got it to parse RFC2616 which seems to be the parser hello world
19:49:20 <shachaf> > [length"error\"\"", length "undefined"]
19:49:21 <lambdabot>   [7,9]
19:49:28 <ivanm> I notice in some of chrisdone's examples for his haskell emacs stuff that he has import statements like: `import "abc" Eight ' ; what's the significance of the String in there?
19:49:41 <ddarius> ivanm: It's a package import.
19:49:51 <edwardk> mostly because it then enables it to parse http headers, so bryan o'sullivan can show off how much faster his parser is than everyone else's ;)
19:49:54 <ivanm> duh
19:50:05 <ivanm> thanks ddarius
19:50:11 <ivanm> edwardk: heh
19:51:12 <Axman6> edwardk: what makes trifecta interesting/different from other parsers?
19:51:31 <cmccann> Axman6, I think mostly that he wrote it himself ;]
19:51:37 <Axman6> heh
19:52:08 <Axman6> i wrote my own parser the other day too (mainly because i thought the lecturer might not want us to use a parser library...)
19:52:14 <edwardk> Axman6: pretty diagnostics: http://imgur.com/lSBWE
19:52:38 <edwardk> Axman6: also, it handles input differently so you can seek forward and backward in ways that let me use my monoidal parsing stuff
19:52:55 <Axman6> ah nice, looks like what you'd get from clang :)
19:53:01 <edwardk> (it can do more clang like things on those than just draw a caret)
19:53:03 <edwardk> yeah
19:53:10 <mauke> edwardk: that seems pretty trivial
19:53:13 <Axman6> sounds awesome
19:53:24 <mauke> and shouldn't even be part of the parser itself
19:53:24 <edwardk> mauke: the diagnostics are a side-effect in many ways
19:53:34 <edwardk> you are entitled to that opinion
19:53:45 <edwardk> but it isn't likely to make me stop work =P
19:54:05 <mauke> as long as the parser can work on abstract streams, you get that feature for free
19:54:08 <edwardk> other differences are that most of it is built in a parser neutral fashion so you can rip out the implementation
19:54:14 <edwardk> i can't work on abstract streams
19:54:17 <edwardk> deliberately so
19:54:23 <mauke> only String?
19:54:46 <edwardk> it works over ropes of bytestrings with optional gaps to replace line directives
19:54:55 <ivanm> Axman6: note though that with trifect, as edwardk currently has it you can't do lazy parsing as it reads the entire input into memory
19:54:57 <ivanm> (IIUC)
19:55:11 <mauke> oh wow
19:55:35 <edwardk> the idea is that i can make a few more passes and bring over my monoidal c preprocessor
19:55:57 <edwardk> then you'll get parallel preprocessing, with error messages that say what macro you're in, what files included you,e tc.
19:56:07 <edwardk> without actually writing any code for that tracking in your language
19:56:10 <edwardk> still trivial?
19:56:27 <Jafet> How should I implement Eq and Ord? data Error a = E { val :: a, err :: a }
19:56:30 <mauke> edwardk: parallel how?
19:56:32 <edwardk> i wanted to stake out a different point in the design space
19:56:33 <ddarius> IHasFields
19:56:41 <mauke> Jafet: ... deriving (Eq, Ord)
19:57:03 <Jafet> Okay... how should I define Eq and Ord?
19:57:23 <edwardk> parallel as in i can take a large file, scan chunks of it on different cores identifying the preprocessing directives, without doing macro expansion within the runs, then evaluate the preprocessing skeleton, and enable macro expansion in parallel over the chunks
19:57:26 <sshc> dmwit: It finished.  2 hours and 6 minutes :)
19:57:46 <dmwit> sshc: YOW
19:57:49 <dmwit> sshc: That's horrible.
19:57:59 <edwardk> i had the bulk of such an implementation in a toy compiler but i hadn't ported it to something consumable by others
19:58:00 <luite> what cpu?
19:58:03 <edwardk> this is part of me doing that
19:58:16 <sshc> luite: Pentium 4
19:58:16 <dmwit> luite: And that's just *one source file*.
19:58:32 <Jafet> Like, if you had a library for computing with error terms, how would you want it to define Eq and Ord.
19:58:55 <dmwit> Jafet: Good question.
19:59:03 <sshc> dmwit: Interestingly, the other three source files build reasonably quickly.
19:59:04 <dmwit> Jafet: But the type itself is weird.
19:59:18 <Jafet> The numeric hierarchy is weird!
19:59:20 <dmwit> Jafet: I mean, Either is the canonical error thing; what's the use case for this one?
19:59:26 <edwardk> mauke: anyways the main focus of the current implementation is on writing parsers for things like compilers, not for dealing with streaming xml or arbitrary token types
19:59:34 <dmwit> Jafet: Oh!
19:59:38 <luite> sshc: which package is this? it sounds interesting :p
19:59:42 <Jafet> dmwit: E x e represents the value x +/- e.
19:59:43 <dmwit> Jafet: err is like a rounding-error term or something?
19:59:47 <dmwit> got it
19:59:56 <dmwit> Now the question about Eq/Ord makes a lot more sense.
20:00:00 <mauke> edwardk: what I like about arbitrary token types is that it gets me location information for free
20:00:05 <Jafet> The closest thing I've found on hackage is edwardk's intervals
20:00:09 <sshc> luite: GPipe-Examples.  dmwit's said that it takes him 3 minutes to build the second example.
20:00:15 <edwardk> i have location information for free, its tracked in the delta monoid ;)
20:00:27 <mauke> edwardk: can you parse backwards?
20:00:32 <edwardk> yes
20:00:32 <dmwit> Jafet: Personally, I would want exactly what deriving gives, plus separate operations like
20:00:35 <mauke> sweet
20:00:42 <edwardk> i can seek to arbitrary locations as well
20:00:50 <edwardk> you can mark and resume, etc.
20:00:57 <dmwit> maybeEq (E a b) (E c d) = c - d < a + b || a - b < c + d
20:00:59 <dmwit> or whatever
20:01:02 <mauke> edwardk: how do you merge errors?
20:01:11 <dmwit> Jafet: (But I definitely wouldn't want that as the implementation of (==).)
20:01:49 <edwardk> https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Diagnostic/Prim.hs is the user visible diagnostic type
20:01:53 <Jafet> Or I could be evil and do (==) = (==)
20:02:08 <dmwit> maybeEq a b = anyPartOf a (elementOf b)
20:02:12 <Jafet> Not sure if that breaks any instance defaults though
20:02:13 <edwardk> basically its a comonad of an error tree, for nested effects,
20:02:36 <dmwit> Jafet: It breaks patterns, if you're planning on implementing Num.
20:02:46 <edwardk> you can log those as a writer basically, you can also throw errors and they'll track back to the containing try, accumulating 'expected' token information
20:02:47 <dmwit> Since "f 1 = foo" compiles to "f x | x == 1 = foo".
20:02:57 <mauke> oh shit, comonads
20:03:03 <Jafet> Aha, thanks for mentioning that
20:03:13 <mauke> the generalest thing I've been able to come up with was error monoids
20:03:31 <edwardk> you can at any point catch non fatal errors, and just push them out to the log
20:03:33 <edwardk> and each error in the log can have this structure
20:03:51 <sshc> They're like burritos, but the beany stuff is on the outside
20:03:56 <edwardk> there is a monoid used in my error handling, but its fairly simple
20:04:31 <edwardk> https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Diagnostic/Err/State.hs wraps my basic error type and accumulates expectations
20:04:57 <edwardk> https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Diagnostic/Err.hs is a 'diagnostic in flight' while it can still be inspected by the system and before i've fixed its location
20:05:39 <edwardk> but very little actual depends on the particular mechanism used to implement the parser
20:06:19 <edwardk> https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Parser/Class.hs exposes the core parsing functionality and all the combinators are parametric in their choice of parsing monad
20:06:40 <edwardk> this lets you plumb user state, environments, take the codensity monad of a naive parser, etc.
20:07:00 <edwardk> the latter effectively right factors your grammar for you
20:08:20 <edwardk> mauke: but i'm entangling a lot of concerns in the parser, in particular i'm working on extracting type-ahead information so you can run a parser to a given point and have it emit a the information i need for readline completion
20:08:37 <edwardk> a lot of this stuff that folks COULD write by hand once for some language
20:08:44 * Samy sends edwardk an interrupt
20:08:48 <edwardk> heya samy
20:09:03 <Samy> Hey.
20:09:49 <mauke> edwardk: sort of related: http://blogs.perl.org/users/jeffrey_kegler/2010/06/parsing-with-ruby-slippers.html
20:10:16 <christo_m> http://hpaste.org/50285  why does this give me non exhuastive patterns , ihave an otherwise
20:11:21 <ivanm> christo_m: empty list
20:11:21 <luite> christo_m: (x:xs) doesn't match []
20:11:40 <ivanm> christo_m: also, repeated length operations get expensive...
20:12:13 <ivanm> oh, wait, you're doing length on a function of x, not xs
20:13:08 <christo_m> can i mix guards and pattern matching?
20:13:16 <luite> yes
20:13:31 <luite> you can just add findIt [] = ... below
20:14:34 <parcs> what do the functional dependencies x ->, -> x, and -> do?
20:14:54 <luite> christo_m: or you can use the pattern guards synax
20:14:58 <luite> syntax
20:15:00 <kmc> "-> x" says there's only one type allowed for x, period
20:15:14 <kmc> i think "x ->" would be a no-op but might be forbidden
20:15:17 <christo_m> luite: something like | xs = [] = error "empty"
20:15:18 <christo_m> or something?
20:15:21 <ivanm> or above
20:15:38 <parcs> kmc: makes senso
20:15:40 <parcs> e*
20:16:01 <parcs> x -> and -> are not forbidden. are they both no-ops?
20:16:05 <luite> christo_m: findIt [] = error "empty"
20:18:35 <christo_m> luite: right thats a pattern, not a guard
20:18:51 <christo_m> luite: thats exactly what i wrote also, thought i could do it in the guard like above but oh well
20:19:05 <parcs> is `-> a b` the same as `a -> b, b -> a`?
20:19:16 <luite> christo_m: you can write something like:
20:19:36 <christo_m> this things taking a very long time to execute, im not very good at this haha
20:19:41 <luite> f xs | (y:ys) <- xs, y > 10 = ...
20:20:11 <luite> in that case, you catch the empty list with the otherwise guard
20:21:42 <cmccann> parcs, I wouldn't expect them to be
20:21:44 <kmc> parcs, no, it's "-> a, -> b"
20:22:06 <kmc> knowing all of these suffices to determine -> any of these
20:23:26 <parcs> yeah, i'm familiar with fundeps just not the edge cases like these
20:23:42 <kmc> well i don't think "-> a b" is handled specially
20:23:52 <edwardk> mauke: yeah that is very much like what i'm playing with
20:23:55 <kmc> it says an empty set of knowledge suffices to determine both a and b
20:24:01 <cmccann> parcs, a -> b, b -> a means that each parameter determines the other
20:24:08 <kmc> i.e. there is only one type allowed for a, and only one for b
20:24:24 <parcs> i see now
20:24:40 <cmccann> so you could have instances for Foo Int Char and Foo Bool String, but not both Foo Bool Int and Foo Bool Char
20:24:40 <edwardk> basically i currently have the 'expected' sets from parsec. i'm looking at embellishing them (well, actually making a separate one) that lets you attach a completion guesser to each one
20:26:04 <parcs> but like with `a -> b, b -> a`, with `-> a b`, if you know a then you know b and vice versa. it's just more restricted
20:27:01 <kmc> sure
20:27:05 <parcs> so what about `->` and `a ->` ?
20:27:06 <kmc> "-> a" implies "b -> a"
20:27:16 <kmc> @djinn a -> (b -> a)
20:27:17 <lambdabot> f a _ = a
20:27:26 <kmc> "a ->" should be a no-op
20:27:42 <kmc> as "->"
20:27:46 <parcs> ghc should warn about that
20:27:48 <kmc> if there's nothing on the RHS, there's no constraint
20:27:59 <ddarius> I don't think it's a big deal.
20:27:59 <parcs> or it shouldn't even parse it
20:28:07 <NihilistDandy> So, stupid question: Is Ix just short for IndeX? Or is there some esoteric meaning I'm missing?
20:28:08 <ddarius> It should definitely parse it.
20:28:27 <cmccann> A warning would be sensible, though.
20:28:31 <kmc> introducing syntactic special cases is the greater evil
20:28:36 <parcs> haha
20:28:59 <cmccann> It warns about other useless things, like duplicate constraints in a context e.g. foo :: (Monad m, Monad m) => ...
20:29:32 <parcs> which doesn't catch all duplicates
20:29:34 <ddarius> I wouldn't have an problem with a warning, but I don't think it's a common occurrence at all or one you are likely to miss.
20:30:05 <parcs> yes but it makes ghc feel more 'robust' :P
20:30:17 <kmc> warnings are allowed to be complex heuristics
20:30:29 <kmc> the language itself should remain simple and consistent
20:33:39 <dmwit> NihilistDandy: Nope, that's it.
20:33:45 <dmwit> IndeX, nothing deaper
20:33:45 <NihilistDandy> dmwit: Awesome.
20:33:53 <dmwit> s/deaper/deeper/ jeepers
20:34:08 <NihilistDandy> I keep seeing it while reading code and it keeps tripping a curiosity switch
20:34:11 <kmc> NihilistDandy, it stands for "ixomorphic functor" which is a kind of co-natural monoidal topos
20:34:28 * kmc tries to keep a straight face
20:34:46 <NihilistDandy> kmc: Go google ixomorphic and notice how many times it comes up :D
20:35:05 <kmc> fun
20:35:14 <ddarius> kmc: Something wouldn't be both a functor and a topos.
20:35:15 <dmwit> Typos for isomorphic, maybe?
20:35:23 <NihilistDandy> dmwit: It seems that way
20:35:23 <kmc> ddarius, indeed
20:37:27 <ddarius> Though a Freyd category is actually a functor.
20:38:01 <ddarius> Though that's the common vernacular of talking about subobjects rather than the inclusions which they actually are categorically.
20:38:03 <parcs> in the Functional Dependencies section of the handbook: "There should be more documentation, but there isn't (yet). Yell if you need it."
20:38:19 <parcs> i should yell about it
20:38:56 <dmwit> To be fair, nobody really, really understands exactly what's up with functional dependencies.
20:40:05 <dolio> That's why they must die.
20:40:12 <parcs> i bet mark p jones does
20:40:26 <dmwit> Nah.
20:40:31 <dmwit> He knows how they're implemented.
20:40:47 <dmwit> But there's lots of properties that we just don't know much about.
20:41:27 * cmccann finds type families much nicer to work with in practice, though still pretty clumsy for anything nontrivial 
20:42:21 <dmwit> I mean, let me be clear about what I mean: we have a nice operational definition of how we take functional dependencies and do type inference.
20:42:35 <dmwit> But that's a far shot from understanding all the properties that those operations give rise to.
20:44:18 <cmccann> dmwit, there are some very peculiar situations you can get into with complicated interdependencies and partial information, at least last time I tried
20:44:35 <dmwit> yep
20:44:46 <ddarius> Why is Java forged from pure evil?
20:44:52 <dmwit> I attended a presentation a month or two ago whose punchline was, "functional dependencies aren't functional".
20:45:12 <ddarius> They're relational.
20:46:28 * cmccann had some situations with things like several interrelated classes with fundeps that would narrow down instance selection given partial information until it somehow managed to loop around and figure out a consistent choice for everything despite only sort of having enough information to do so
20:47:00 <parcs> what
20:47:25 <dmwit> Yes. It's more accurate to say, "functional dependencies are dependencies that give the compiler enough information to direct its instance search" rather than "functional dependencies are type-level functions".
20:47:27 <christo_m> http://pastebin.com/REtg3CXW why is this so slow when doing findIt [1..] :(
20:47:33 <mauke> The paste REtg3CXW has been copied to http://hpaste.org/50286
20:47:40 <cmccann> or classes with fundeps between some parameters that were intentionally never given enough information to pick an instance, and only used in contexts elsewhere to specialize other types
20:48:09 <dmwit> christo_m: Your triangleNumber function is crappy.
20:49:17 <dmwit> christo_m: Also, you should :set mouse=a in vim.
20:49:18 <cmccann> dmwit, I had one case where I was using a class to give a mapping between types where actually selecting an instance would unify too many things and break, but using parts of the fundeps (in ways that would have violated other fundeps) let the lookup work
20:49:43 <ddarius> dmwit: No one has ever said they are type level functions.  They are constraints on the type level relations that are type classes to be functional relations.
20:49:50 <ddarius> Just like they do in database theory.
20:51:27 <dmwit> ddarius: I don't recall enough of the crazy example to validate it against your refined definition. Perhaps you're right.
20:52:02 <dmwit> But I've never seen a theorem to that effect.
20:52:55 <ddarius> How would there be a theorem?  Functional dependencies are an extension to a feature in a language with no formal semantics.
20:53:32 <dmwit> There are theorems about what ~ means. Why can't there be theorems about functional dependencies?
20:53:43 <dmwit> Just because Haskell isn't formalized doesn't mean GHC's version isn't.
20:53:47 <ddarius> dmwit: There are theorems about what ~ means in System FC.
20:53:50 <dmwit> Yes.
20:53:53 <lewis1711> Is #haskell one of those programming channels that hates homework questions?
20:53:58 <ddarius> dmwit: GHC is even less formalized.
20:54:13 <ddarius> lewis1711: If it is C homework, yes.
20:54:14 <kmc> lewis1711, not universally, but we expect you to put some effort in yourself
20:54:25 <kmc> good: "i tried to do foo and it broke, here's a hpaste of my code and error message"
20:54:25 <dmwit> ddarius: Compare: "there are theorems about what ~ means in System FC", "there are theorems about what functional dependencies mean in ..."
20:54:36 <kmc> bad: "SOLVE IT" *copy-paste from homework page*
20:54:55 <lewis1711> kmc: ha, naturally. alright then
20:55:09 <kmc> good questions about homework look like other good questions
20:55:18 <ddarius> dmwit: Yes, there have not been too many formalizations of type systems with type classes.
20:55:19 <kmc> most of us learned haskell by giving ourselves homework
20:56:14 * cmccann learned Haskell mostly by typing a lot of really dumb things into an editor window, then feeding them to GHC
20:57:48 <ivanm> @remember cmccann [I] learned Haskell mostly by typing a lot of really dumb things into an editor window, then feeding them to GHC
20:57:48 <lambdabot> I will remember.
20:58:04 <hpaste> lewis1711 pasted “hw problem effort” at http://hpaste.org/50287
20:58:23 <lewis1711> problems in the comments. i am just not seeing how this can be done recursively
20:58:41 <cmccann> lewis1711, how is "filter" implemented, do you think?
20:59:21 <lewis1711> ...that's a good point. i remember reading a recursive defn of filter somewhere
20:59:37 <cmccann> lewis1711, try implementing it without using any built-in list functions
20:59:37 <aavogt> with the guard you did the same thing as    if b then True else False
21:00:42 <lewis1711> cmccann: will do. aavogt: yeah, the gaurd was part of the question :/
21:00:54 <cmccann> also, checking the length of the list is not a very good way to do that
21:01:15 <cmccann> and you'll probably figure out why that's the case if you implement your own list functions
21:01:25 <ivanm> lewis1711: consider pattern matching on the list
21:01:36 <ivanm> as it stands, I don't see why you even bother with the [] case
21:02:11 <cmccann> note that pattern matching is the only way to examine a list, so if you avoid the standard library functions as I suggest you won't have much choice :P
21:02:39 <ddarius> Please don't ever write: if x then True else False or if x then False else True ever again.
21:02:57 * cmccann writes if x then True else True
21:02:59 <parcs> yes, if then else is bad
21:02:59 <ivanm> ddarius: nah, my favourite is: | f x == True = True
21:03:04 <parcs> pattern match instead
21:03:16 <aavogt> @src findIndices
21:03:16 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
21:03:40 <lewis1711> ddarius: me? I didn't use an if else
21:03:49 * ddarius is afraid that parcs is not joking.
21:03:58 <ivanm> lewis1711: that's what your guards say
21:04:00 <cmccann> lewis1711, guards are equivalent to if then else
21:04:03 <ddarius> lewis1711: Don't do it's moral equivalent either.
21:04:31 <ivanm> the only time you should have something like "= True" is for pattern matching (e.g. "isJust Just{} = True") or parsing the equivalent of True
21:05:06 <parcs> fear not, ddarius :)
21:05:30 <ivanm> parcs: so he should be terrified rather than afraid?
21:05:31 <ivanm> :p
21:05:51 <ddarius> Really I'm not sure if there is ever a time when you should have a boolean valued result from if-then-else.
21:06:11 <ddarius> That said, down with Booleans!
21:06:21 <lewis1711> probably a hold over from C and the like, where I am usually doing a side effect and returning a boolean to indicate the success of it
21:06:21 <NihilistDandy> Dualism is a lie
21:06:24 <parcs> Maybe () all the way!
21:06:24 <lewis1711> that's my excuse anyway
21:06:34 <danharaj_> Replace Bool with (Either (Not a) a)!
21:06:45 <ddarius> lewis1711: That doesn't explain it.
21:08:19 <lewis1711> ddarius: fine. maybe it's a bit habit of mine :P
21:08:45 <cmccann> parcs, why not Either () ()?
21:09:43 <NihilistDandy> Why not RedundantBoolFactoryOfRedundancy?
21:09:53 <ivanm> NihilistDandy: doesn't sound redundant enough to me
21:09:56 <cmccann> parcs, if you're getting rid of True and False I don't see how Nothing is any better. In fact, also replace Maybe a with Either () a.
21:10:11 <danharaj> You mean AbstractBoolFactoryAdaptor
21:10:21 <NihilistDandy> danharaj: Of course, how could I be so foolish?
21:10:30 <parcs> cmccann: convincing argument. i'm on board!
21:10:56 <newsham> ddarius: both of em?
21:11:21 <ddarius> newsham: Yes.
21:12:28 <cmccann> parcs, (), (,), Either, and (->) ought to be plenty. More than plenty, really.
21:12:56 * ddarius wants Void.
21:12:56 <cmccann> but I suppose we can keep a few luxuries
21:13:17 <newsham> I want Void -> c
21:13:33 <cmccann> ddarius, a legitimate empty type, I assume?
21:13:47 <cmccann> rather than what just "data Void" does.
21:20:54 <NihilistDandy> Does anyone know of some good resources re time and space complexity (and, by extension, B-L notation)? Books or articles are welcome.
21:22:36 <danharaj> How much complexity theory do you want?
21:23:55 <NihilistDandy> danharaj: Likely the more the better.
21:24:38 <NihilistDandy> I've been looking through some algo books, but their treatment of complexity is a bit wanting
21:25:50 <atomie> I'm creating a binding to a library using c2hs. It complains it cannot find the definition of a struct I defined in an extra C source file. Do you perhaps have any hints? I'm slowly going mad.
21:26:18 <luite> NihilistDandy: sipser, introduction to the theory of computation has some chapters on complexity
21:26:31 <atomie> I have "c-sources: cbits/adapter.c" in the cabal file. It contains the struct definition.
21:27:55 <NihilistDandy> luite: I'll give it a look, thanks.
21:35:50 <wavewave> hi.
21:37:05 <edwardk> heya
21:37:18 <wavewave> is there any library using HaXml with enumerator or iteratee?
21:37:30 <wavewave> hi! good to see you.
21:37:50 <edwardk> not that i'm aware of
21:38:43 <lewis1711> "cmccann: also, checking the length of the list is not a very good way to do that" why not? I implemented my own list functions and never saw it. if you can even remember what I was talking about
21:39:19 <wavewave> HaXml might be okay with ~ 100 MB file?
21:39:39 <edwardk> most likely
21:40:25 <wavewave> I am also thinking using xml-enumerator. but it seems still at early stage yet.
21:41:53 <wavewave> I am now porting xournal into a haskell program :-)
21:42:46 <ClaudiusMaximus> > length (repeat 1) > 1   -- lewis1711
21:42:48 <edwardk> sounds fun
21:43:00 <wavewave> a pen note-taking program
21:43:01 <lambdabot>   thread killed
21:43:25 <edwardk> normally i'd be true to form for the last week or so and try to sell you on using my shiny new parsing library but your application is precisely what it doesn't do well ;)
21:43:41 <wavewave> now I figured out how a wacom device can be used in gtk2hs
21:44:02 <cmccann> lewis1711, because you don't actually need to know the length, only whether it's > 1
21:44:23 <wavewave> edwardk: what is the name of your parsing library?
21:44:29 <edwardk> trifecta
21:44:46 <ClaudiusMaximus> > case (repeat 1) of { [] -> False ; [_] -> False ; _ -> True }
21:44:47 <lambdabot>   True
21:44:53 <cmccann> lewis1711, even leaving aside the issue of infinite lists, there's no reason to have to traverse the list and count up the length just to see if there's more than one element
21:45:01 <edwardk> uploading a new version as we speak actually
21:45:14 <wavewave> edwardk: ah, I remember that I read your talk file.
21:45:27 <_KY_> How come I can't use elemIndex? it's in the base library
21:45:28 <cmccann> lewis1711, the examples ClaudiusMaximus gave get the point across well, I think
21:45:34 <huangyi> it seems `Test.QuickCheck.Property.liftIOResult` no longer exists, chp-plus package use it, what should it be replaced with?
21:45:41 <edwardk> yeah this is only tangentially related to that. its still using the little iteratee with ropes of bytestrings
21:45:45 <ClaudiusMaximus> @index elemIndex
21:45:46 <lambdabot> Data.List
21:45:59 <lewis1711> cmccann: that makes sense. sort of. close to clicking :/
21:46:15 <lewis1711> ClaudiusMaximus: never seen that function before, i guess it may be useful
21:46:29 <edwardk> but i had to write a parser last week at work, and got annoyed at the standard tools, so i blew a couple weekends hacking this up
21:46:41 <wavewave> what will be the selling point for trifecta in your mind?
21:46:47 <_KY_> Thanks=)
21:47:09 <cmccann> lewis1711, think of if you were implementing it all yourself. If you want to see if the length is greater than one, would you keep counting at 2 and up? Or just return True because you know all you need?
21:47:47 * cmccann looks forward to the day when hackage is deprecated in favor of just installing things directly from edwardk's github
21:47:49 <wavewave> I am now reading RFC2616.hs example..
21:47:52 <kmc> unfortunately Int is not lazy :/
21:47:54 <edwardk> pretty diagnostics, support for using the grammar automatically for completions when typing in interactively, http://i.imgur.com/Tk2UN.png
21:48:10 <lewis1711> cmccann: yeah that makes a lot of sense. The only solution I can think of involves a function with an inner function, which is usually a sign i'm doing it wrong. I'll do it that way anyway since at least it's a solution
21:48:27 <edwardk> and the ability to do online parsing a la attoparsec
21:48:53 <edwardk> but with parsec like expected token tracking
21:49:18 <wavewave> I see.
21:49:47 <cmccann> lewis1711, why would an inner function be wrong? Other than possibly overcomplicating this specific case, because checking if a list is nonempty is pretty simple
21:50:07 <wavewave> do you have your own implementation of iteratee?
21:50:12 <edwardk> it also includes for instance, all the anal retentive posix and unicode character class information, has fast optimized-for-utf-8/ascii/etc character sets, etc.
21:50:12 <edwardk> yeah
21:50:23 <edwardk> mine serves a different purpose though
21:50:30 <edwardk> so its not quite morally an iteratee
21:50:41 <edwardk> however, unlike an iteratee, it is actually a monad ;)
21:50:58 <wavewave> what style do you prefer? cps style or constructor?
21:51:04 <wavewave> for iteratee
21:51:12 <edwardk> (you can fix iteratees to make them really a monad, but thats a separate issue)
21:51:15 <lewis1711> cmccann: yeah checking if a list is non empty is fine, but surely to find the duplicates i have to construct a list but stop constructing when it's over 2
21:51:53 * hackagebot trifecta 0.30 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.30 (EdwardKmett)
21:52:06 <edwardk> cps-style is necessary in some fashion
21:52:18 <edwardk> i showed that asymptotically on my blog recently
21:52:19 <cmccann> lewis1711, well, in your earlier code you were using filter to find the elements and then checking the length, so I was assuming you'd still be doing the search separately
21:52:25 <hpaste> lewis1711 annotated “hw problem effort” with “hw problem effort (annotation)” at http://hpaste.org/50287#a50288
21:52:39 <christo_m>    | (x `mod` 2) /= 0 = (3*x + 1)
21:52:44 <christo_m> this keeps giving me some f ractional int error
21:52:49 <christo_m> its not seeing the /= as "not equal"
21:52:54 <lewis1711> I made that, which counts up the number of duplicates. using recursion. but it was supposed to be a boolean, of course.
21:53:14 <edwardk> once you fix an iteratee it is a cofree comonad and almost a free monad, then it becomes obvious you pay exorbitantly for left associated binds without cps transformation
21:53:42 <_KY_> How do I test if something is Nothing?
21:53:50 <cmccann> :t isNothing
21:53:51 <lambdabot> forall a. Maybe a -> Bool
21:53:58 <_KY_> Thanks=)
21:54:12 <cmccann> _KY_, might need to import Data.Maybe for that
21:54:18 <cmccann> I can't recall if it's in Prelude or not
21:54:52 <cmccann> lewis1711, yeah, your new version looks equivalent to the filter part of your original
21:55:07 <wavewave> cofree comonad.. scary word for me.. :-)
21:55:08 <_KY_> But it still gives an error if I do (isNothing one)
21:55:12 <_KY_> But it still gives an error if I do (isNothing 1)
21:55:28 <edwardk> the one i use in trifecta right now looks like data It r a = Pure a | It a (r -> It a) -- which doesn't have the usual remaining rope content in Done, this is because the existing iteratee libraries conflate the notion of an iteratee that is being stepped by some enumerator with the iteratee itself
21:55:43 <cmccann> _KY_, because those aren't a Maybe type I imagine
21:56:13 <ivanm> lambdabot: wakey wakey!
21:56:18 <ivanm> @hoogle isNothing
21:56:18 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
21:56:23 <edwardk> if you look at the (>>=) operation for iteratees a la oleg you find they discard the returned input from the right hand side of the bind, this is logical because if it hasn't been supplied input, how could it have any to give back?
21:56:27 <cmccann> lewis1711, so if you're sticking with the same concept you'd probably want to move all that to a helper function in the where clause, and then check if the result is nonempty
21:56:30 <ivanm> oh, my net connection was just being laggy...
21:56:33 <_KY_> I see...
21:56:41 <edwardk> but then we go and introduce these very exotic terms by using the enumerator plumbing
21:57:36 <wavewave> So would you explain 'cofree comonad' in the new typeclassopedia?
21:57:42 <edwardk> yes
21:57:48 <lewis1711> cmccann: but that still has to traverse the whole list, when it's not really needed. I am not clicking as to how I can just terminate the recursion
21:57:54 <edwardk> it also isn't that hard to explain by looking at it
21:57:55 <christo_m> nevermind
21:58:00 <wavewave> I would like to see the relation between comonad and iteratee sincerely.
21:58:05 <edwardk> data Cofree f a = a :< f (Cofree f a)
21:58:15 <cmccann> lewis1711, nah, it only has to traverse the list if the result depends on the whole list
21:58:17 <ddarius> edwardk: Looking at the image you posted, it is just as I expected.  Very pretty useless error messages.
21:58:26 <wavewave> Hmm. it is really like iteratee.
21:58:38 <edwardk> ddarius: hah, well, i didn't do anything interesting on top yet =P
21:59:31 <edwardk> wavewave: a common 'cofree' comonad is the rose tree type Data.Tree that is in containers.
21:59:31 * ddarius prepares some vim macrology in true Java programming style.
21:59:46 <cmccann> lewis1711, if you stop after finding more than more element (sorry, I keep saying nonempty when you actually need to check for more than one) there's no reason for the rest of the filtering to happen
21:59:47 <lewis1711> cmccann: blergh I am not getting this. thanks for your help but i am going to take 5 then read my notes again
22:00:29 <edwardk> ddarius: i also didn't annotate that grammar at all, its exactly the one used by bos to benchmark against parsec, etc.
22:00:45 <cmccann> lewis1711, it's about lazy evaluation. "are there at least two of these?" only needs to look until it finds two. "how many are there?" needs to look at everything always.
22:01:02 <wavewave> are iteratee, coroutine and cofree comonad synonym then?
22:01:16 <kmc> with maximum laziness "length xs > 1" would stop after two elements
22:01:26 <kmc> but Haskell's Int type doesn't represent partial information this way
22:01:48 <kmc> "genericLength xs > (1 :: Nat)" would, for an appropriate inductive naturals
22:01:57 <cmccann> kmc, and making Int lazy enough would be... awkward
22:02:04 <kmc> yeah
22:02:14 <wavewave> I am somewhat confused whether coroutine and iteratee are the same.
22:02:15 <Jafet> Making length :: [a] -> Int was awkward
22:02:17 <lewis1711> cmccann: I think I get the concepts, I mean I understand I can stop at |list| = 2, but I don't get how I stop
22:02:17 <cmccann> whereas lazy nats, which are actually appropriate for something like this, would work
22:02:22 <edwardk> they are close
22:02:34 <kmc> i'd like a language where the built-in numeric types are specified as lazy inductive thingies
22:02:41 <cmccann> lewis1711, if nothing in your final result depends on the rest, then... it won't be calculated.
22:02:45 <kmc> and the compiler is so awesome it can implement them as machine ints when appropriate
22:02:46 <edwardk> you can actually make a similar free monad construction to model asymmetric coroutines
22:03:10 <Jafet> I just want Double constructors...
22:03:28 <edwardk> wavewave: go to comonad.com, there are three posts that end with one called 'yielding IO' in that i describe how to build an efficient cps transformed free monad for handling IO, which is exactly an asymmetric coroutine
22:03:36 <cmccann> kmc, heh, there was a question on stack overflow a while back where someone had a cute corecursive graph distance algorithm that required lazy nats to work at all
22:03:40 <edwardk> it may clear things up for you
22:03:48 <wavewave> yes, I just noticed it ;-)
22:03:52 <edwardk> you probably want to start at the first of the three
22:05:37 <wavewave> I think this yielding IO can be a beautiful approach to GUI programming.
22:05:43 <cmccann> kmc, also, why not go further and wish for a compiler smart enough to optimize church numerals into machine ints as well. ;]
22:05:51 <edwardk> we're using it for exactly that
22:05:55 <wavewave> cheaper than functional reactive programming
22:06:15 <edwardk> almost everything is cheaper than functional reactive programming ;)
22:06:39 <wavewave> I would like to use it for my xournal porting.
22:07:21 <wavewave> FRP seems to need dependent type not to have memory leak problem.
22:07:55 <edwardk> well, agda seems to have demonstrated to me that nice dependent types have a conservation law where memory leaks are conserved. they just move them to compile time
22:08:17 <hpaste> christo pasted “14” at http://hpaste.org/50289
22:08:29 <wavewave> yes. I skimmed through the paper using agda for FRP.
22:08:30 <christo_m> Can someone tell me what im doing wrong here?
22:08:45 <wavewave> too advanced for me. :-P
22:09:27 <wavewave> How is the status of simulating dependent type in haskell? using GADT and type families.
22:09:35 <ClaudiusMaximus> christo_m: a : b $ c  == (a : b) $ c
22:09:39 <wavewave> and of course using all typeclass hackery.
22:10:39 <wavewave> can we make effectively dep typed language using current ghc extension in principle? or do we need more radical change in language?
22:11:11 <edwardk> ghc will never be dependently typed
22:11:30 <edwardk> you may get some crazy kinds, but i doubt we'll see dependent types here, not a great power to weight ratio
22:11:50 <wavewave> I know. I would also object to it if they decide to go to full dep type
22:12:10 <cmccann> wavewave, keep in mind there's a fine line between "simulating" and embedding an implicit interpreter for an EDSL
22:12:15 <christo_m> ClaudiusMaximus: ugh, thank you, so tired
22:13:40 <cmccann> wavewave, a lot of the really crazy tricks are pretty close to crossing the line of being not really something GHC is doing for you, but something you're just implementing in a very weird way
22:13:41 <wavewave> cmccann: another mind-boggling sentence to me.. would you elaborate it for me?
22:14:16 <dolio> You can encode arbitrary dependently typed programs in GHC.
22:14:25 <dolio> It's just a question of how terrible it is.
22:14:44 <cmccann> wavewave, say there's some way to fake full dependent types using crazy type hackery. It involves some sort of type-level computation to ensure the types work out.
22:14:53 <cmccann> Is that simulating dependent types in Haskell?
22:15:05 <cmccann> Or is that writing a dependent type checker in Haskell's type system and using that?
22:15:31 <wavewave> I mean the former.
22:16:34 <cmccann> wavewave, so you'd say that embedding your own dependent type-checker at compile-time counts as simulating dependent types in Haskell?
22:16:53 <dolio> Encoding dependently typed programs in GHC doesn't involve writing your own type checker.
22:17:46 <cmccann> dolio, hm, what do you have in mind?
22:18:17 <wavewave> I would rather watch the conversation between cmccann and dolio ;-)
22:18:26 <dolio> There's a standard way to encode dependent types.
22:18:34 <cmccann> wavewave, nah, just listen to dolio, he knows this stuff better than I do.
22:18:41 <dolio> First you build your type at the type level.
22:18:55 <dolio> Then you build a GADT indexed by the type level 'values'.
22:18:56 <cmccann> I was just trying to establish some sort of boundary for what even counts
22:19:10 <dolio> Then you existentially quantify around the indexed type to get the value-level thing.
22:20:10 <cmccann> dolio, hm, so that actually gets you everything? I didn't realize that.
22:20:25 <dolio> So instead of (x : A) -> B x, you do forall x. A x -> B x.
22:20:45 <_KY_> How do I test for Left or Right in an Either value?
22:20:58 <wavewave> dolio: that's something new I haven't thought of.
22:21:07 <edwardk> yay
22:21:07 <Jafet> isLeft (Left _) = True; isLeft _ = False
22:21:15 <dolio> cmccann: It involves increasing amount of duplication, though.
22:21:17 <edwardk> i finally figured out the incantation to get github to host haddocks for me
22:21:19 <edwardk> http://ekmett.github.com/trifecta/index.html
22:21:46 <dolio> And, for instance, have fun implementing IEEE floats at the type level, and then not using the built-in floats, because they aren't indexed by your type level floats.
22:21:46 <edwardk> that'll do until 7.4 comes out and they fix the copy of unix on hackage
22:22:26 <cmccann> dolio, eh, details. being able to encode arbitrary dependently-typed programs that way is interesting anyway.
22:22:27 <dolio> This is essentially how ATS does things, though.
22:22:52 <wavewave> edwardk: what's happening on unix on hackage?
22:23:11 <dolio> Except it's better for it, because it has actual static data, instead of doing dumb stuff like 'data Z ; data S n' to encode type naturals.
22:23:36 <edwardk> wavewave: the new version is distributed with ghc 7.2.1 but the version on hackage is older, so anything that depends on it (or i'd hazard some other packages) gets no haddocks in the meantime
22:24:05 <wavewave> some duplication will be ameliorated when type-level numeral will be introduced in ghc, isn't it? :D
22:24:31 <edwardk> the type level numbers in ghc scare the hell out of me
22:24:32 <dolio> I don't know if the stuff they're adding automatically duplicates stuff at the type level.
22:24:43 <dolio> The SHE preprocessor does.
22:24:45 <ddarius> My monstrosity rises.
22:24:52 <wavewave> I see.
22:25:27 <wavewave> type-level template haskell :D
22:25:30 <edwardk> i like the idea of adding a new natural number kind, but there is no real formalization of what class of arithmetic constraints it can solve, and there is no real mechanism in place whereby you'd be able to help it along
22:25:47 <edwardk> so it either gets it right or you're hosed
22:26:41 * cmccann just wishes it was less painful to do simple type-level computation in general
22:27:15 <dolio> Of course, it's not quite so simple as I described.
22:27:30 <dolio> Because the type level computation in GHC is restricted in some inconvenient ways.
22:27:32 <dolio> For good reason.
22:27:39 <_KY_> isLeft is imported from Data.Either?
22:28:00 <wavewave> practically, how much burden of type-level computation for compiler?
22:28:02 <Jafet> KY: no, I just made it up to answer your question.
22:28:11 * cmccann has tried several times to find a sane way to abstract simple recursion at the type level and it always ends up a pain to use or a complete monstrosity or both.
22:28:18 <dolio> I guess maybe it's not a real restriction, but you can't write functions by overlapping pattern matching at the type level.
22:28:22 <edwardk> _KY_ no, it doesn't exist
22:28:24 <dolio> Because that'd be unsound for type families.
22:28:39 <Jafet> KY: you determine whether a value has a Left constructor by pattern-matching on that constructor.
22:28:41 <_KY_> So how can I implement isLeft?
22:28:45 <edwardk> Data.Either doesn't actually export anything useful work working with Either, that would just be silly ;)
22:28:53 <edwardk> isLeft (Left x) = x
22:29:11 <_KY_> I see...
22:29:14 <Jafet> That would be fromLeft, which does get exported from Data.Either
22:29:15 <edwardk> isLeft (Right x) = error "but you told me it was a left and I trusted you!"
22:29:23 <edwardk> oh sorry
22:29:24 <Jafet> And does that, yes.
22:29:25 <edwardk> yeah
22:29:28 <cmccann> ugh, partial functions
22:29:32 <Jafet> Usefully.
22:29:49 <edwardk> isLeft Left{} = True; isLeft Right{} = False
22:30:11 <cmccann> isLeft (Right x) = error "no, your other left!"
22:30:19 <edwardk> cmccann: =)
22:30:40 <shachaf> edwardk: Data.Either exports *some* useful things.
22:30:46 <edwardk> some
22:30:54 <Jafet> Partial useful things
22:31:00 <edwardk> just not any of the things you'd expect by analogy to Data.Maybe
22:31:05 <dolio> It probably exports either.
22:31:26 <cmccann> it exports partitionEithers, I think.
22:31:53 <cmccann> which is actually useful.
22:32:56 <edwardk> so then all you have to do is take your Either, put it in a list, partition it, map one to True and the other to False, then concatenate the lists and take the head and you have isLeft!
22:33:03 <yitz> @hoogle either
22:33:03 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
22:33:03 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
22:33:04 <lambdabot> module Data.Either
22:33:05 <edwardk> so easy
22:34:17 <yitz> isLeft = either (const True) (const False)
22:34:42 <cmccann> :t null . rights . pure
22:34:42 <lambdabot> forall a a1. Either a1 a -> Bool
22:34:48 <yitz> isLeft = (either `on` const) True False
22:34:49 <cmccann> > null . rights . pure $ Left ()
22:34:51 <lambdabot>   True
22:34:54 <dolio> We need overloaded booleans so that can be either true false.
22:35:44 <Jafet> partitionEither s = foldr id ([], []) . map (either ((*** id) . (:)) ((id ***) . (:)))
22:35:49 <Jafet> s/ //
22:35:54 <shachaf> @wn need
22:35:55 <lambdabot> *** "need" wn "WordNet (r) 2.0"
22:35:55 <lambdabot> need
22:35:55 <lambdabot>      n 1: a condition requiring relief; "she satisfied his need for
22:35:55 <lambdabot>           affection"; "God has no need of men to accomplish His
22:35:55 <lambdabot>           work"; "there is a demand for jobs" [syn: {demand}]
22:35:57 <lambdabot> [23 @more lines]
22:36:16 <edwardk> @type head . uncurry (++) . ((True <$) *** (False <$)) . Data.Either.partitionEithers
22:36:17 <lambdabot> forall b b1. [Either b b1] -> Bool
22:36:58 <edwardk> oops
22:37:11 <Jafet> See, KY, Haskell is so easy.
22:37:20 <_KY_> =)
22:37:22 <edwardk> @type head . uncurry (++) . ((True <$) *** (False <$)) . Data.Either.partitionEithers . return
22:37:23 <lambdabot> forall b b1. Either b b1 -> Bool
22:37:42 <cmccann> pf, return? use pure.
22:37:53 <edwardk> =)
22:37:55 <cmccann> saves characters
22:37:55 <Jafet> KY: you should read about pattern matching, which (in theory) underlies most computation in Haskell
22:38:17 <_KY_> Thanks...
22:38:20 <Jafet> Use the monkey
22:38:41 <cmccann> Jafet, meh, pure doesn't require the shift key
22:39:09 <Jafet> Your keyboard doesn't have a CONS key?
22:39:48 <cmccann> Jafet, sadly no
22:41:07 <Jafet> Hm, the space cadet put '[' and ']' on shift. But you could type '() without shifts.
22:41:17 <Jafet> That is, "'()"
22:41:26 <wavewave> i would like to have monad reader issue with summary of type hackery in haskell. :P
22:41:29 <kmc> http://en.wikipedia.org/wiki/Space_Cadets_(television_hoax)
22:41:30 <Jafet> Clearly we need a keyboard optimized for Haskell
22:41:51 <cmccann> Jafet, mine would have at least two different keys dedicated to <*> I think
22:42:26 <cmccann> wavewave, just browse Oleg's site until everything makes sense or nothing makes sense
22:42:30 <cmccann> one of the two will happen eventually
22:42:46 <shachaf> Jafet: It had an key for CONS?
22:43:17 <wavewave> cmccann: that's definite good, but I need some lower-level introduction.
22:43:22 <shachaf> I thought syntax that you couldn't make the equivalent of yourself was frowned upon among LISPers.
22:43:22 <Jafet> shachaf: you'd think it would have!
22:43:42 <shachaf> ...To be fair, my keyboard has a CONS key too. For Haskell, at least.
22:43:58 <wavewave> Also I want to see some use of GADTs..
22:44:08 <kmc> wavewave, the GHC manual has a good example of GADTs
22:44:29 <Jafet> .oO(CONS isn't syntax)
22:44:54 <shachaf> Jafet: It does get special treatment, though!
22:44:58 <cmccann> wavewave, what kind of stuff are you looking for? I could probably whip up some examples.
22:45:22 <cmccann> I've actually been half-heartedly collecting some of my assorted type hackery with the intent to dump it all on github at some point
22:45:30 <edwardk> @tell roconnor re: earlier, the fclabels stuff looks pretty clean except the names require qualified import
22:45:30 <lambdabot> Consider it noted.
22:45:43 <wavewave> ah, I just want to see what dolio said in example..
22:46:04 <wavewave> cmccann: that sounds wonderful!
22:46:28 <shachaf> cmccann++
22:46:32 <wavewave> cmccann: please write a monad reader issue, too, hihi
22:46:39 <shachaf> cmccann: That karma point is on credit, by the way.
22:46:49 <cmccann> shachaf, duly noted :P
22:47:05 <lewis1711> shachaf: ...did you just increment a variable in #haskell?
22:47:16 <shachaf> lewis1711: Sure. Haskell supports variables!
22:47:24 <wavewave> #haskell is ST monad.
22:47:31 <shachaf> Even IO.
22:47:34 <Jafet> #haskell is unsafe.
22:48:06 <cmccann> wavewave, hm, if you're after GADTs, somewhere around here I had a simple expression tree GADT with typed terms that would build a type-level equivalent of the expression in a phantom type on the GADT
22:48:37 <cmccann> so that you could either ignore the phantom type and treat it like a plain AST, or reconstruct arbitrary subexpressions by examining the type-level AST
22:48:49 <shachaf> > let (++) = modifyIORef (+1) in (undefined++)
22:48:51 <lambdabot>   <IO ()>
22:49:09 <cmccann> otherwise things like function application destroy information (or leave you dealing with existentials) while building the expression
22:49:29 <cmccann> not really the sort of thing dolio was talking about, though
22:49:39 <Jafet> (++) should modify the bits of the thunk
22:49:39 <kmc> Jafet, #haskell is bad for your job satisfaction
22:50:09 <Jafet> (It should be easy! Thunks have uniform representations!)
22:50:16 <wavewave> cmccann: would you show me a link for what you're saying?
22:50:37 <cmccann> wavewave, can't right now, not sure where I put it and it's getting late :T
22:51:15 <cmccann> wavewave, the only interesting type hackery I know I have uploaded anywhere is some fun with type families from the other day on Stack Overflow
22:51:37 <cmccann> everything else is just scraps and disorganized snippets :T
22:51:38 <wavewave> cmccann: I see. I will look it up, thanks.
22:51:50 * WUriel likes to think of #haskell as "unsafePerformanceArtOnMACID"... ;þ
22:52:17 <wavewave> One thing I am interested in for some curiosity is
22:52:28 <cmccann> wavewave, this is the type families stuff I mentioned: http://stackoverflow.com/questions/7030476/haskell-polyvariadic-function-with-io/7035253#7035253
22:52:32 * BMeph does, too.
22:52:46 <wavewave> how I can express multiple inheritance with phantom type in haskell.
22:53:08 <cmccann> wavewave, I'm not sure what multiple inheritance would mean in this context
22:53:16 <wavewave> Thanks!
22:53:26 <wavewave> Ah.. just random thing.
22:53:57 <wavewave> You know single inheritance can be expressed as a chain of type constructor
22:54:03 <wavewave> with a phantom type.
22:54:26 <wavewave> ParentA ( ParentB ( ParentC a ) ) )
22:54:45 <cmccann> wavewave, yes, though that's exceedingly clumsy already
22:54:59 <wavewave> something like that. That's how gtk2hs and qthaskell implement the inheritance.
22:55:27 <cmccann> those are both bindings to C++ libraries?
22:55:29 <wavewave> This is a kind of implementing list in type space.
22:55:41 <wavewave> gtk2hs is not, but in fact, yes..
22:56:23 <kmc> gtk uses the GObject system, doesn't it?
22:56:24 <yitz> wavewave: yes, since they are bindings to OO libraries, they are forced to model the ugly idea of inheritance somehow.
22:56:26 <wavewave> So to have multiple inheritance, we have nonlinear kind of type function in type space..
22:56:28 <cmccann> wavewave, inheritance as a concept doesn't really work well in Haskell, so you kind of need a motivating example before trying to imitate it, I think
22:56:28 <kmc> don't recall if that has MI
22:56:36 <kmc> fwiw MI in C++ is a trainwreck
22:56:52 <cmccann> if you're trying to imitate something specific, like for FFI bindings, then that's one thing
22:57:12 <wavewave> cmccann: I know ;-) I am just curious.
22:57:17 <kmc> if your "objects" are just records of functions, then most of the fancy OOP stuff becomes ordinary functions
22:57:23 <cmccann> if you're trying to accomplish something not tied to another language, then it's probably better to start by "how to solve this problem" not "how to do multiple inheritance"
22:57:29 <kmc> which is nice because functions can abstract over other functions
22:57:55 * yitz pats cmccann on the back - well said
22:58:20 <ivanm> @ask chrisdone is your copy of auto-complete customised? either way, it would make it easier if the directory was unversioned (so that others using haskell-emacs won't have to change their config when you bump the version)
22:58:20 <lambdabot> Consider it noted.
22:58:30 <cmccann> but as a first step, if I needed to do inheritance-ish stuff in Haskell, I'd probably take the objects-as-records-of-functions, types-as-abstract-classes route
22:58:43 <cmccann> then use some type-hackery to fake structural subtyping of some sort
22:58:50 <wavewave> I am raising this question because this has some interesting nontrivial graph structure among types.
22:58:59 <cmccann> with as much safe implicit casting as possible
22:59:24 <wavewave> I want to see some type-level nontrivial data structure regardless of usefulness.
22:59:29 <kmc> i like that Haskell has basically no subtyping
22:59:37 <cmccann> the type families thing I posted on SO is actually surprisingly relevant here, since that's exactly doing implicit casting while accounting for variance and other complications
22:59:43 <wavewave> kmc: I second that, too.
22:59:45 <kmc> as an example of how it's not necessary
22:59:53 <cmccann> wavewave, you've seen HList, right?
23:00:25 <wavewave> cmccann: yes, that's probably the closest to my relevance.
23:00:52 <cmccann> HList generalizes easily to trees rather than lists
23:01:22 <cmccann> and if you define an ordering relation over a closed set of types (which I think is also on Oleg's site somewhere?) then you can reimplement Data.Map at the type level
23:01:46 <wavewave> cmccann: this sounds very interesting to me.
23:01:54 <cmccann> or just use linear searching like HList does, since type-level stuff is so slow anyway that you'll never be building a large tree anyhow :]
23:03:34 <wavewave> cmccann: by the way, your post on stack overflow is very relevant to my current problem. thanks a lot!
23:04:34 <ivanm> @ask chrisdone any plans about literate haskell support? (mainly for writing blog posts, etc.) ?
23:04:34 <lambdabot> Consider it noted.
23:04:44 <cmccann> I also have an implementation somewhere of a two-level collection data structure with set operations. Based on something like HList, but with some extra structure and various ways of (say) taking the type-level union of two collection types, while merging two lists of records with that type filtering by equality on the types in the intersection
23:05:16 <cmccann> utterly ridiculous and impractical of course, but amusing
23:07:35 <wavewave> cmccann: hope to see those examples soon, too. :D
23:07:57 <cmccann> wavewave, yeah, it's all stuff that I'm going to dump into a repo on github eventually
23:08:27 <wavewave> yup, please announce it some time!
23:08:53 <cmccann> I just wish I could find some non-horrible way to implement recursive combinators at the type level :[
23:09:30 <cmccann> wavewave, oh, here's the full code from the SO post if you're interested: https://github.com/isomorphism/evangelist
23:09:59 <cmccann> was working on some changes based on sclv's comment but not finished yet.
23:10:50 <wavewave> cmccann: Oh, thanks!!!
23:11:12 <cmccann> do note that you'll need GHC 7.2
23:11:39 <wavewave> Hmm? what ghc extension did you use for this?
23:11:50 <cmccann> lots
23:12:01 <cmccann> but the sticking point is equality constraints in class contexts.
23:12:25 <cmccann> you'll see if you try loading the code in an older GHC
23:12:26 <wavewave> In fact, I did encounter exactly the same problem before, and I solved it in a very dirty way.
23:12:42 * cmccann wouldn't exactly say that the type hackery is a "clean" solution
23:13:03 <wavewave> I recently uploaded a FFI library on hackage.
23:13:44 <cmccann> but the alternatives are lots of manual boilerplate, auto-generated boilerplate, or TH, none of which are terribly satisfying
23:13:46 <wavewave> my method is similar to the original poster in your stack overflow link.
23:14:11 <wavewave> and I did that manual boilerplate :-(
23:14:35 <wavewave> xform2 , xform3, xform4, .... xform12, xform13 ....
23:14:40 <cmccann> :[
23:16:43 <wavewave> Hmm, you use class constraints, that's why you need 7.2.
23:17:13 <cmccann> wavewave, right, specifically equality constraints (the ~ stuff)
23:17:27 <wavewave> yes
23:17:46 <wavewave> that's the coolest thing in ghc 7.2 for me.
23:18:02 <cmccann> I'm not certain how necessary those are here, since I didn't try to do it without them, but I doubt it would be trivial to remove them (short of doing everything in fundeps instead)
23:18:38 <wavewave> maybe there exists some other workaround, but ~ is really easy to reason about. I like it.
23:19:39 <cmccann> well, the workaround for not having ~ is Oleg's TypeCast class
23:19:49 <cmccann> which I usually renamed to (:~) anyway
23:20:02 <dmwit> When you want ~, you really want ~.
23:20:06 <wavewave> I see, that's great..
23:20:35 <wavewave> I will try to figure out implementing your solution for ghc 7.0 or 6.12 for my library.
23:21:16 <cmccann> I think Oleg's hackery manages to accomplish most (all?) of the same stuff, but is nowhere near as easy to understand since ~ is part of the actual type checking, whereas TypeCast just abused unification
23:21:23 <wavewave> although making xform23, xform24,... xform100.... is not that difficult. ;-)
23:22:35 <wavewave> practically xform12 or 13 is enough, since most functions have smaller than ten arguments, though.
23:23:03 <wavewave> but I like to have general solution like yours.
23:23:30 <cmccann> one problem with the approach I used is that there's no way to have a default base case on the recursion
23:24:32 <cmccann> the only way to do that is going back to fundeps and overlapping instances and the headaches that come up with polymorphic types getting wedged somewhere in the middle of things :T
23:24:39 <dmwit> Oh, huh.
23:25:36 <dmwit> I just picked an example of uncurry out of thin air, and it happened to be exactly the example the SO post asked about (in a section I didn't actually read until just now).
23:25:39 <dmwit> happy coincidence
23:26:12 <wavewave> oh, what a coincidence!!
23:26:57 <wavewave> in fact, we were also talking about the problem out of other discussion.
23:27:06 <dmwit> Yeah, I know.
23:27:13 <dmwit> I saw cmccann's epic answer to that.
23:27:34 <cmccann> dmwit, oh, the "splat" operator thing? I think that actually wants a polymorphic generalized uncurry, but yeah
23:27:41 <wavewave> lol
23:28:04 <cmccann> which is easy to do with nested pairs but obviously not on arbitrary tuples without TH :[
23:28:35 <dmwit> Yep, having one instance per tuple type is a bit weary.
23:28:49 <cmccann> and writing (foo, (bar, (baz, ()))) kind of ruins any benefit of doing things automatically
23:28:56 <dmwit> But, on the other hand... it's pretty much fine for almost all uses I can think of.
23:29:04 <wavewave> ah.. generalized uncurry function?
23:29:15 <cmccann> :t uncurry
23:29:16 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
23:29:22 <wavewave> that would be awesome.
23:29:24 <cmccann> :t curry
23:29:25 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
23:29:38 <wavewave> (a -> b -> c -> d) -> (a,b,c) -> d
23:29:43 <dmwit> wavewave: Have you seen http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Curry.html ?
23:29:46 <solrize_> whooie
23:29:49 <wavewave> (a->b->c->d->e) ->....
23:29:49 <solrize_> oop
23:29:51 <solrize_> oops
23:29:52 <dmwit> It's not totally general, but it does tuples up to size 15
23:29:52 <solrize_> sorry
23:30:15 <cmccann> wavewave, can do something similar to my conversion example for nested pairs, just recursing on tuples instead of (->)
23:30:26 <cmccann> but that's not really much nicer
23:30:46 <wavewave> yes.. that's what I imagined no.
23:30:49 <wavewave> now
23:30:59 <cmccann> wavewave, oh, you might like this: https://gist.github.com/1086615
23:31:31 <cmccann> type-nat-indexed reordering of function arguments, heh
23:32:21 <wavewave> ha.. this is cool.
23:33:07 <marens> any idea what might cause this error during cabal install snap-server? http://hpaste.org/50290
23:33:32 <cmccann> wavewave, oh, and another recent answer I wrote on SO, showing Oleg's TypeEq: http://stackoverflow.com/questions/6939043/is-it-possible-to-place-inequality-constraints-on-haskell-type-variables/6942637#6942637
23:33:57 <dmwit> marens: Bad dependencies in a cabal file somewhere, maybe?
23:34:03 <dmwit> i.e. too-lax dependencies
23:36:52 <wavewave> TypeEq is using fundep with boolean type-level type for equality constraint, I see
23:37:51 <cmccann> wavewave, yes, it uses fundeps with overlapping instances and a trick to delay when GHC picks the instance
23:37:55 <wavewave> thanks for teaching me.
23:38:02 <sohum> hm.
23:38:06 <marens> dmwit: i had to do a minar update on ghc yesterday from 6.12.3 to 6.12.3-r2 might that be related?
23:38:12 <cmccann> so that when the types are the same, it coerces the "result" to Yes, and No if they aren't
23:38:16 <sohum> I know a multigraph is where you can have multiple edges between nodes
23:38:26 <sohum> what's the kind of graph where you can have edges between edges?
23:38:27 <marens> *minor
23:38:27 <cmccann> then other classes can select instances based on the type boolean
23:38:55 <wavewave> I got it.
23:39:46 <dmwit> marens: Hard to say without poking your actual system. See if you can find which package is supposed to provide mask_ and install a few different versions.
23:39:49 <wavewave> I think your evangelist can be implementable for ghc 7.0, 6.12
23:40:12 <cmccann> wavewave, yes, but probably needs fundeps to translate it exactly
23:40:34 <wavewave> that's okay at least if it works :-)
23:41:06 <wavewave> especially for such FFI problem, nobody will see inside once after it compiles. :)
23:41:36 <wavewave> though we cannot use it in hugs
23:41:54 <cmccann> this is already ridiculously unportable code anyway, so I'm satisfied with "most recent GHC" being required
23:41:55 <marens> dmwit: seems to be Control.Exception.mask_
23:42:56 <wavewave> in fact, haskell world is changing too fast~~
23:43:24 <wavewave> we are avoiding all success by moving too fast.
23:43:34 <kmc> just like Firefox
23:44:32 <cmccann> ok. I need some sleep.
23:44:49 <cmccann> I'll see if I can get the first batch of type hackery stuff on github tomorrow, maybe.
23:44:50 <wavewave> cmccann: yes, in fact I do.
23:45:07 <wavewave> cmccann: thanks so much. it's very helpful to me.
23:45:21 <cmccann> heh, I can't really promise any of it is of practical use
23:45:56 <wavewave> cmccann: l look forward to seeing them!!
23:46:48 <cmccann> wavewave, ok, glad to hear it :]
23:49:32 <ivanm> marens: could be a dep error
23:49:38 <ivanm> otherwise, it's a problem with snap
23:50:27 <ivanm> gah, I hate this stupid buffering stuff that's going on with IRC atm :@
23:52:56 <ivanm> @tell chrisdone it might also be nice to have some unique prefix/suffix for the ghci buffer (because I have a lot of buffers with "graph" in them :p)
23:52:56 <lambdabot> Consider it noted.
23:53:25 <hvr> marens: could well be that noone tested snap-server w/ base-3.0
23:54:00 <c_wraith> I don't think anyone developing Snap (including me) cares about supporting base 3.
23:54:17 <c_wraith> base 4 has been available since at least 6.10
23:54:38 <hvr> curiously, ghc loads up "Loading package base-3.0.3.2 ... linking ... done."
23:54:45 <shachaf> GHC 6.6 is such an improvement over 6.4, isn't it?
23:54:53 <ivanm> hvr: are you using cabal-install? if so, which version?
23:55:03 <ivanm> it might still be using the "don't use base-4!" constraint
23:55:14 <shachaf> http://www.haskell.org/ghc/docs/6.6/html/users_guide/release-6-6.html
23:55:34 <hvr> ivanm: I'm just talking about marens' hpaste
23:55:45 <hvr> ivanm: for me it builds fine w/ GHC 7.0 and 7.2
23:55:50 <ivanm> hvr: bah, that was meant for marens ;)
23:55:55 <hvr> I haven't got any 6.12 to test with
23:55:59 <marens> ivanm, hvr, looks like a dependency problem. monad-control isn't installed via cabal nor via system's package manager, i'll manually install it when the other compiles finish
23:56:33 <jrockway> hi all, any recommended graph representation libraries, preferably that include a pathfinding algorithm?
23:56:41 <ivanm> dammit, this isn't in a released Cabal yet: http://hackage.haskell.org/trac/hackage/ticket/656#comment:16 :(
23:56:58 <ivanm> jrockway: none have a pathfinding library as such
23:57:12 <ivanm> fgl has djikstra's, etc.
23:57:27 <ivanm> and I've got some stuff in Graphalyze I have to get around to merging into fgl one of these days...
23:58:19 <thoughtpolice> ivanm: weren't you going to release a new, awesomer version of fgl?
23:58:31 <ivanm> thoughtpolice: sure, when I have time to hack on it :s
23:58:48 <ivanm> actually, I'm starting to lean towards just targetting edwardk's graph library
23:58:59 <ivanm> (just because he stole my module namespace :p)
23:59:47 <jrockway> i'll take a look at fgl
