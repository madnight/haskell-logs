00:11:04 <siracusa> andares: Apparently, Haskell just sounded better than Alonzo :-P
00:15:06 <RayNbow`TU> anyone seen today's xkcd? :)
00:18:46 <jlaire> @pl \g -> f (g x)
00:18:47 <lambdabot> f . ($ x)
00:20:27 <Schalken> I'm reading that to perform recursion in lambda calculus I need a fixed point combinator, the simplest of which is Y. But what is wrong with, given some recursive function defined as \f. … f … binding the first parameter to itself using (\h h h)  ? I'm talking about untyped lambda calculus here, I know that's not typable in Haskell.
00:20:58 <Schalken> Accidentally hit <Enter>. Err, let me finish that…
00:21:03 <NihilistDandy> @hoogle mips
00:21:03 <lambdabot> No results found
00:21:07 <NihilistDandy> Ooh, exciting
00:21:15 <NihilistDandy> That'll be my project for my assembler class
00:21:20 <Jafet> Not really, hoogle is woefully incomplete
00:21:41 <Jafet> Or at least @hoogle is
00:21:56 <Schalken> I'm reading that to perform recursion in lambda calculus I need a fixed point combinator, the simplest of which is Y. But what is wrong with, given some recursive function defined as \f. … f … binding the first parameter to itself as (\h. h h) (\f. … f … ) ?
00:22:05 <NihilistDandy> Jafet: Well, Hackage yields no more results
00:22:11 <Schalken> That's better. :)
00:22:16 <shachaf> Schalken: What you want isn't \h -> h h, it's \h -> h (h (h (h (h ...
00:22:20 <NihilistDandy> So I guess I'll have to write a MIPS interpreter :D
00:22:30 <NihilistDandy> Just have to devise a clever pun for a name
00:22:31 <mauke> Schalken: the problem with that is that f then needs to invoke itself as f f
00:22:36 <shachaf> Schalken: Otherwise the function wouldn't be able to call iself recursively the second time.
00:22:40 <mauke> Schalken: so that's basically half of Y
00:23:03 <Schalken> mauke: shachaf: Ahhhh.
00:23:05 <Jafet> > fix (\f n -> if n == 0 then 1 else n * f f (n-1)) 5
00:23:06 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> t
00:23:21 <shachaf> This is what Y does for you. Y = \f -> (\x -> x x) (\x -> f (x x))
00:23:30 <Jafet> Wait, you can't do that in this language.
00:23:51 <Jafet> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 42 -- not the fixpoint you are looking for
00:23:52 <lambdabot>   1405006117752879898543142606244511569936384000000000
00:24:00 <quicksilver> Jafet: well you can, actually, if you don't mind a lot of newtype noise
00:24:14 * Jafet hears the moo
00:24:30 <shachaf> Schalken: http://www.ccs.neu.edu/home/matthias/BTLS/sample.ps is a pretty good explanation/derivation of Y in Scheme.
00:24:38 <Schalken> Jafet: Yeah, I'm kinda just talking about LC in general, which I'm not sure is allowed in here. :/
00:24:46 <shachaf> Schalken: In Haskell, fix is sometimes defined as fix f = f (fix f)
00:25:01 <Jafet> You can! but only if it gives some of us an excuse to abuse lambdabot
00:27:03 <Schalken> shachaf: mauke: What if it was more like \f … f f … and in fact it used "f f" every time it wanted to recurse. Would that solve it, or only go one more level deep?
00:27:28 <mauke> that would work
00:27:36 <shachaf> That's pretty much what Y does for you. :-)
00:27:42 <mauke> in fact I've written code like this because I couldn't wrap my head around Y
00:27:53 <Schalken> mauke: Haha.
00:27:59 <mauke> and in the beginning I didn't even know you could write something like Y
00:28:07 <Schalken> mauke: shachaf: That makes sense. Thanks for your help.
00:35:16 <Jafet> Okay, so how do you use Mu to do fix points
00:35:50 <shachaf> Jafet: I think people usually use rec for that.
00:36:03 <shachaf> @src Rec
00:36:04 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
00:36:49 <Jafet> @type let y (InR f) = let x = f (InR x) in x in y
00:36:50 <lambdabot>     Occurs check: cannot construct the infinite type: t = Rec t -> t
00:36:50 <lambdabot>     Probable cause: `f' is applied to too many arguments
00:36:50 <lambdabot>     In the expression: f (InR x)
00:39:41 <shachaf> @ty \f -> (\x -> outR x x) (InR (\x -> f (outR x x)))
00:39:42 <lambdabot> forall a. (a -> a) -> a
00:40:39 <willem> Is there actually a use for the const function? I can't really see where it would be useful.
00:40:41 <Jafet> Thanks! (for convincing me that one shouldn't bother with this stuff in Haskell)
00:41:09 <Jafet> willem: pay attention when you use Haskell, and notice that half of its features exist just to save you typing
00:41:20 <shachaf> Jafet: Yep, that's pretty much my conclusion.
00:41:58 <shachaf> On the other hand, when this discussion came up I tried to test something in one line in the Scheme prompt, and was reminded of one of the reasons I don't use Scheme.
00:42:02 <Jafet> willem: well, if you want to be more bombastic, const corresponds to K in the SK-calculus)
00:42:10 <Jafet> s/well/(well
00:42:49 <quicksilver> willem: it is useful as a parameter to a higher order function
00:42:52 <Jafet> shachaf: why else do you think people need emacs to write scheme
00:43:05 <erus`> @hoogle fmap
00:43:06 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
00:43:06 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
00:43:06 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
00:43:16 <shachaf> Jafet: Wait, I thought they needed LISP to write Emacs.
00:43:19 <quicksilver> e.g if you have a Data.Map with information in and you want to preserve only the 'shape' of it, you could use map (const ())
00:43:24 * shachaf must have had it backwards.
00:43:34 <Jafet> shachaf: see, lisp is all about fix-points.
00:43:39 <erus`> @hoogle (a -> Maybe b) -> f a -> f b
00:43:40 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
00:43:40 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
00:43:40 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
00:43:55 <NihilistDandy> shachaf: But you can't write Lisp without emacs
00:43:57 <erus`> i need fmapMaybe
00:43:59 <shachaf> > zipWith const [1,2,3] [5,6,7,8,9,10]
00:44:00 <lambdabot>   [1,2,3]
00:44:05 <NihilistDandy> A time machine was involved
00:44:13 <mauke> erus`: what would that do?
00:44:41 <erus`> return [b] for only Just;s
00:44:44 <Jafet> Perhaps Scheme is approaching the least fixed point. I won't comment on Common Lisp.
00:44:45 <erus`> like mapMaybe
00:44:54 <shachaf> ...What?
00:44:57 <shachaf> What would its type be?
00:45:02 <mauke> erus`: that's mapMaybe
00:45:11 <mauke> you're welcome
00:45:26 <Jafet> erus`: that requires Foldable
00:46:55 <willem> Ah yeah, I can see how it would come in handy in higher order functions. The following is a line from xmonad that I assume that can be simplified (working on a patch)? ./Core.hs: Just x -> throw e `const` (x `asTypeOf` ExitSuccess)
00:47:20 <mauke> heh, type hackery
00:47:21 <dibblego> willem: have you ever written "\_ ->" ?
00:47:23 <shachaf> willem: Oh, that's just used to force a type constraint.
00:47:24 <Jafet> Probably not... it happens to enforce the type of x
00:47:38 <shachaf> Kind of weird code.
00:48:01 <willem> shachaf: but will the force ever be evaluated? Since const is non-strict in its second argument?
00:48:12 <quicksilver> willem: never evaluated, that's right
00:48:21 <quicksilver> willem: it's not there for runtime, it's there for compile time.
00:48:21 <shachaf> willem: A *type* constraint.
00:48:27 <shachaf> It forces x to be of a particular type.
00:48:31 <quicksilver> they could have written
00:48:51 <shachaf> x :: ExitCode
00:48:58 <quicksilver> Just (x :: ExitCode) but they wanted to avoid PatternSignatures, I guess.
00:49:00 * shachaf wonders what the context of that line is.
00:49:03 <quicksilver> or they could have written
00:49:11 <shachaf> throw e `const` (x :: ExitCode)
00:49:12 <quicksilver> Just x -> throw e :: Maybe ExitCode
00:49:25 <mauke> quicksilver: that looks wrong
00:49:30 <Jafet> :t throw
00:49:31 <lambdabot> Not in scope: `throw'
00:49:32 <shachaf> quicksilver: Are you sure throw e returns a Maybe?
00:49:39 <quicksilver> ah, no, I'm not :)
00:49:46 <mauke> quicksilver: are you sure e is an ExitCode?
00:49:49 <quicksilver> we have no idea what throw returns from the context given.
00:49:55 <quicksilver> good point.
00:49:55 <shachaf> Can you be sure of anything these days?
00:50:07 <quicksilver> I can be sure that I like doughnuts.
00:50:38 <Jafet> > let snail n = r 0 n `map` [1..n] where r o k 1 = map (o+) [1 .. k]; r o k i | i==k = map (o+) [ 3*k-2, 3*k-3 .. 2*k-1] | True = [o+4*k-2-i] ++ r (o+4*k-4) (k-2) (i-1) ++ [o+k+i-1] in snail 4 -- erus`
00:50:39 <lambdabot>   [[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]]
00:50:45 <willem> hehe, okay so the point is that it has to do with compile time typing? Then I can probably figure it out from there.
00:51:04 <erus`> :O
00:51:04 * shachaf has quite the .ghci these days.
00:51:06 <shachaf> 36 imports.
00:51:15 <Jafet> You and int-e were considering a "recursive" snail, which I think that satisfies
00:51:41 <Jafet> willem: type inference and polymorphism in Haskell can be (ab)used in many ways
00:52:16 <Jafet> willem: (in fact, asTypeOf is also const, but with a different type)
00:52:34 <shachaf> Everything in Haskell is const.
00:52:36 <shachaf> Unless it's ap.
00:52:37 <shachaf> Or fix.
00:52:41 <shachaf> Or callCC.
00:52:52 <quicksilver> willem: const isn't a compile time thing.
00:53:00 <quicksilver> willem: that particular use of it, is only relevant at compile time.
00:53:12 <erus`> my snail was about 70 lines
00:53:15 <erus`> yours is one
00:54:13 <Jafet> More importantly, it generates them in constant (?) space. Though I'm not sure if it's actually O(n^2)
00:55:13 <Jafet> Oh, maybe O(n) space for the recursion
00:56:30 <quicksilver> are there O(n) nested calls to r? it looks like it.
00:56:54 <quicksilver> in that case there is an n-deep chain of (++) thunks as you evaluate the middle of that list, so, yes, O(n) space
01:07:23 * hackagebot ad 1.2.0.2 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.2.0.2 (EdwardKmett)
01:10:48 <Johannes`> hi, how do i match one of multiple choices in a case expression? eg. 1 OR 2 OR 3 -> body instead of 1 -> body ; 2 -> duplicate ; 3 -> duplicate
01:12:28 <erus`> does readFile work for utf8?
01:14:01 <erus`> System.IO.UTF8
01:14:06 <erus`> System.IO.UTF8.readFile :D
01:15:16 <quicksilver> Johannes`: you can't do precisely that, although consider a guard
01:15:28 <quicksilver> case x of _ | x `elem` [1,2,3] -> body
01:15:37 <ion> Don’t use readFile. It does lazy IO which is evil.
01:17:20 <mreh> sloth, the deadliest of the all the sins
01:17:41 <Eduard_Munteanu> Not using lazy I/O is a bit of a strong assertion...
01:17:52 <osfameron> yeah, nasty claws
01:18:04 <Eduard_Munteanu> In a lot of situations it's fine.
01:18:39 <shachaf> Eduard_Munteanu: Sure, all the situations that don't matter.
01:19:18 <quicksilver> the point is, it should be a concious decision
01:19:28 <quicksilver> understanding the consequences some of which are a little subtle
01:19:44 <quicksilver> not a default choice
01:20:09 <Eduard_Munteanu> Dunno, I wouldn't go about using iteratees if I were to map a function over each byte in the file.
01:20:49 <merijn> Iteratees seem like such a simple idea, but all the documentation of them and their libraries seems so awfully complex compared to the basic idea...
01:20:57 <quicksilver> perhaps you understand the consequences then Eduard_Munteanu ;)
01:21:25 <quicksilver> the problems of lazy IO generally arise when you're doing the IO gradually, in a large program (possibly concurrent), perhaps a long lived one.
01:21:41 <quicksilver> for a single purpose program which reads a single file...
01:21:58 <Johannes`> quicksilver: thank you
01:23:03 <Eduard_Munteanu> Besides I think it provides for an attractive FP style in _some_ situations, a-la interact.
01:23:19 <quicksilver> it's superficially attractive
01:23:20 <Eduard_Munteanu> e.g. simple access patterns.
01:23:24 <quicksilver> but it's a leaky abstraction
01:23:35 <quicksilver> because you need to understand you're throwing away all ability to sensibly handle errors
01:23:46 <quicksilver> people from other programming languages would laugh at that.
01:24:22 <erus`> @hoogle Maybe [a] -> [a]
01:24:23 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
01:24:23 <lambdabot> Prelude cycle :: [a] -> [a]
01:24:23 <lambdabot> Prelude init :: [a] -> [a]
01:24:29 <osfameron> is there any way to provide a similarly appealing access pattern that *does* give you the ability to handle errors?
01:25:42 <Eduard_Munteanu> Well you can catch exceptions and exit semi-gracefully. In some situations the only possible thing that could happen is getting some fatal error or hitting EOF at the end.
01:26:06 <quicksilver> Eduard_Munteanu: and lose all the (partial) work you have do so far.
01:26:14 <Eduard_Munteanu> Yeah.
01:26:15 <quicksilver> again, other programming languages would laugh uproariously at that.
01:26:23 <quicksilver> osfameron: "similarly appealing"?
01:26:50 <osfameron> quicksilver: the "superficially attractive" "simple access pattern"
01:26:53 <quicksilver> osfameron: this is what iteratees do and the idea is appealling enough but most people find the details of the implementation not entirely simple.
01:27:11 <merijn> ^^^ that
01:27:56 <osfameron> cool
01:28:25 <quicksilver> it's basically "get data chunk by chunk and call a callback when a chunk is ready"
01:28:38 <merijn> Like I said, I really like the idea of iteratees, but I have yet to find an implementation which is as simple as the idea
01:28:42 <quicksilver> although it can be rather more nuanced.
01:29:33 <erus`> @hoogle (\a -> m b) -> [a] -> m [b]
01:29:33 <lambdabot> Parse error:
01:29:34 <lambdabot>   --count=20 "(\a -> m b) -> [a] -> m [b]"
01:29:34 <lambdabot>                ^
01:29:45 <erus`> @hoogle (a -> m b) -> [a] -> m [b]
01:29:45 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:29:46 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:29:46 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
01:32:19 <hpaste> willem pasted “Const use for type constraints” at http://hpaste.org/49880
01:34:09 <willem> Okay, so I tried to replicate the same behavior of the xmonad code (I assume the asTypeOf causes that pattern rule to fail based on the type), however I ran into some errors. http://hpaste.org/49880 contains the comparison between the code snippets
01:38:32 <quicksilver> willem: no, it doesn't make the pattern do anything.
01:38:43 <quicksilver> willem: it's compile time. All it's doing is guiding the type inference.
01:41:03 <willem> quicksilver: ah, so it actually just binds the type variable from fromException to the appropriate type?
01:41:11 <erus`> @hoogle a -> b -> (a, b)
01:41:11 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (a -> e -> (a, e)) -> a -> d -> (a, d)
01:41:11 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
01:41:11 <lambdabot> Data.ByteString mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
01:41:42 <quicksilver> willem: I don't think that phrasing gives quite the right impression, but yes.
01:41:54 <quicksilver> willem: without it, there would be an ambiguous type (compile-time) error
01:42:03 <quicksilver> with it, the type inference engine picks the correct type.
01:42:17 <quicksilver> erus`: (,)
01:44:29 <willem> quicksilver: Well, it doesnt really seem that the type is actually used. Is it just that there is a type needed i.e. could you replace ExitCode by some bogus instance?
01:45:08 <willem> quicksilver: *instance of Exception
01:49:48 <mreh> i might be moving to cambridge, does anyone have an empty room?
01:50:47 <mreh> to work at the university might I add
01:58:40 <erus`> whats a name for something with children
01:58:52 <erus`> a syntax tree
01:58:55 <mauke> parent
01:58:57 <merijn> Parent
02:03:48 <quicksilver> willem: I don't know because I don't know the context :) There must be some reason x would otherwise be ambiguous
02:04:11 <quicksilver> willem: oh, right, it's exception catching
02:04:22 <quicksilver> willem: well they're making sure they only catch exceptions of type ExitCode
02:04:27 <quicksilver> other exceptions remain uncaught
02:16:03 <mstrlu> Is dbus-client-0.4.0.4 broken? A very simple test program gives `DBusClientTest: thread blocked indefinitely in an MVar operation'
02:17:18 <hpaste> mstrlu pasted “DBusClient.hs” at http://hpaste.org/49881
02:50:41 <gienah> mstrlu: I dont' know if dbus-client-0.4.0.4 works or not, but just wanted to note that dbus-client functionality has been moved into dbus-core, so dbus-client seems to have been deprecated
02:52:32 <mstrlu> gienah: Thanks, then I will look at dbus-core
02:53:21 <gienah> mstrlu: there was an announcement email I think on haskell-cafe rececntly I think with some hints on dbus-core simple client stuff
02:56:09 <mstrlu> Yeah I found it... thanks again
02:57:27 * hackagebot bytedump 0.9 - Flexible byte dump helpers for human readers.  http://hackage.haskell.org/package/bytedump-0.9 (VincentHanquez)
02:58:34 <erus`> @hoogle [a] -> [a] -> Bool
02:58:34 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
02:58:34 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
02:58:34 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
02:58:58 <hpaste> nooodl pasted “Y combinator factorial” at http://hpaste.org/49882
02:59:15 <nooodl> ^ what's wrong with this definition?
02:59:42 <nooodl> it's supposed to be a haskell version of the one in http://secs.ceas.uc.edu/~franco/C511/html/Scheme/ycomb.html
02:59:46 <mauke> it's lambda calculus, not haskell
03:00:03 <mauke> that is, it isn't well typed
03:00:05 <Claudius1aximus> :t \rec -> rec rec
03:00:06 <lambdabot> parse error on input `rec'
03:00:18 <Claudius1aximus> :t \r -> r r
03:00:18 <mauke> and rec is a keyword in lambdabot, apparently
03:00:19 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
03:00:19 <lambdabot>     Probable cause: `r' is applied to too many arguments
03:00:19 <lambdabot>     In the expression: r r
03:00:52 <nooodl> weird, you can't write that in haskell?
03:00:54 <ion> > fix (\f x -> if (x == 0) then 1 else x * f (x-1)) 10
03:00:55 <lambdabot>   3628800
03:01:02 <mauke> nooodl: not without shenanigans
03:01:18 <nooodl> ion: it's supposed to be like fix, but i'm explaining the Y combinator to someone
03:01:37 <nooodl> actually, using the haskell definition of fix is not a bad idea
03:01:55 <mauke> @src fix
03:01:55 <lambdabot> fix f = let x = f x in x
03:01:56 <nooodl> fix f = f (fix f)
03:02:04 <mauke> nooodl: that's not the real one
03:02:52 <zygoloid> fix f = fix where fix = f fix
03:03:54 <nooodl> both of the other two seem weird
03:04:25 * zygoloid ponders whether foldr can be written nicely as a palindrome
03:04:31 <nooodl> zygoloid's is a nice palindrom--yeah
03:04:31 <mauke> zygoloid: delicious
03:04:57 <mauke> > fmap fix return "nice"
03:04:58 <lambdabot>   "nice"
03:05:07 <nooodl> can anyone explain that definition? it seems to be something else than "fix f = f (fix f)"
03:05:29 <mauke> nooodl: well, you want to compute the fixed point of f
03:05:43 <mauke> a fixed point x has the property that x = f x
03:05:45 <nooodl> ohh wait, i think it makes sense, magically
03:05:59 <nooodl> fix f = a fixed point "fix" where fix = f fix
03:07:55 <nooodl> "fix" and the Y combinator are essentially the same, right?
03:08:11 <mauke> they do the same thing
03:08:21 <mauke> I think "Y combinator" refers to a specific implementation
03:09:05 <quicksilver> the fix f = let x = f x in x version has two operational virtues, I think.
03:09:12 <quicksilver> it's not recursive so it can be inlined
03:09:17 <quicksilver> and it's more likely to get maximum sharing.
03:09:56 <NihilistDandy> Haskell's based on simply-typed LC, right?
03:10:08 <merijn> No
03:10:16 <NihilistDandy> No?
03:10:22 <merijn> More based on System F I think
03:10:43 <merijn> STLC only has terms depending on terms, Haskell also support terms depending on types and types depending on types
03:10:53 <NihilistDandy> Ah, yes
03:10:59 <merijn> So that's two of the three lambda cube axes
03:11:04 <quicksilver> I suppose it depends what you mean by 'based on'
03:11:10 <quicksilver> STLC doesn't have base types either
03:11:16 <quicksilver> or custom data types.
03:11:33 <NihilistDandy> I'm trying to think about how to represent lists as lambdas, because why not?
03:11:37 <merijn> NihilistDandy: Of course that means it includes most things from STLC as well
03:11:39 <quicksilver> as well as not having polymporphism.
03:12:03 <quicksilver> NihilistDandy: http://en.wikipedia.org/wiki/Church_encoding#List_encodings
03:12:10 <quicksilver> NihilistDandy: (spoilers) :)
03:12:17 <NihilistDandy> :D
03:12:33 <mauke> the trick is to represent each type as its foldr
03:13:49 <quicksilver> STLC isn't normally taken to have recursion, either.
03:19:24 <NihilistDandy> Does that mean, then, that these type signatures are equivalent?
03:19:26 <NihilistDandy> @type (\z snd -> (snd z))
03:19:26 <lambdabot> forall t t1. t -> (t -> t1) -> t1
03:19:30 <NihilistDandy> @type tail
03:19:30 <lambdabot> forall a. [a] -> [a]
03:20:00 <quicksilver> no, I woudln't say they were equivalent.
03:20:21 <NihilistDandy> Hmm
03:20:21 <quicksilver> Int and (a -> a) -> a -> a are not equivalent type signatures either.
03:20:33 <quicksilver> but there is an interesting relationship between them.
03:20:55 <NihilistDandy> Oh?
03:21:05 <NihilistDandy> Do tell.
03:21:09 <quicksilver> that's the church encoding for (positive) integers
03:21:23 <quicksilver> I'm brushing negative numbers under the carpet for the moment.
03:21:24 <NihilistDandy> Aha
03:21:28 <NihilistDandy> Heh
03:21:33 <merijn> ooh, time to break out my stolen joke again!
03:21:41 <merijn> Peano SSSSZ Life! :)
03:21:42 <quicksilver> Equally I wouldn't say that :: Integer, and :: Rational are equivalent type signatures
03:21:55 <quicksilver> even though there is an bijection Rational <-> Integer.
03:21:56 <ehamberg> merijn: i laughed :(
03:25:28 <NihilistDandy> merijn: I also laughed
03:26:17 <Eduard_Munteanu> It's been in blah's topic for a while...
03:26:37 <merijn> Really? That's what I get for not hanging around in -blah often enough :\
03:35:47 <erus`> i want to write a C compiler for my language
03:35:55 <erus`> but my language has lots of recursion
03:36:08 <erus`> how can i turn recursive functions into loops?
03:36:51 <merijn> If they're tail recursive its easy, if not...
03:37:05 <zygoloid> erus`: search for 'tail call optimization'
03:38:26 <quicksilver> erus`: you don't turn them into loops, you turn them into gotos
03:38:36 <quicksilver> and decide how to handle parameters.
03:38:37 <erus`> ah
03:38:43 <quicksilver> BTW C is a horrendous compilation target :)
03:38:45 <merijn> Ah, yeah
03:38:53 <merijn> goto's are probably nicer
03:39:27 <quicksilver> GHC used to compile to a sick variant of C
03:39:32 <quicksilver> JaffaCake still wears the scars.
03:39:33 <merijn> C--
03:39:44 <quicksilver> I was not referring to C--.
03:39:48 <quicksilver> C-- is much nicer.
03:39:56 * JaffaCake winces
03:39:57 <merijn> Oh, you mean before C--?
03:39:58 <dibblego> GHC no longer compiles to C?
03:40:07 <merijn> dibblego: Not for a while now
03:40:10 <quicksilver> dibblego: no, the native code gen is the standard one now
03:40:12 <erus`> i might just worry about all this later and write an interpretter in haskell for now
03:40:16 <merijn> dibblego: The backend is still supported, but native is default
03:40:16 <dibblego> well blimey, never knew
03:40:19 <erus`> i have my parser working :D
03:40:25 <qwr> erus`: gcc can to tco imho
03:40:25 <quicksilver> merijn: Cmm has always has always been part of the process
03:40:27 <merijn> erus`: Might wanna compile to haskell or llvm if you want to support native code generation
03:40:42 <merijn> Probably cleaner then compiling to C
03:41:05 <quicksilver> merijn: but it used to be Core -> STG -> Cmm -> hideous variant of C -> weird variant ASM -> evil manger -> real ASM -> code.
03:41:24 <quicksilver> s/manger/mangler/;
03:41:45 <quicksilver> (Cmm is not exactly the C-- from cminusminus.org but it is a cousin on friendly terms)
03:54:13 <erus`> merijn: the thing about compiling to haskell is, tracking what is lazy and what is strick
03:54:18 <erus`> strict*
03:57:31 <erus`> @src putStr
03:57:31 <lambdabot> putStr s  = hPutStr stdout s
03:57:40 <erus`> @src hPutStr
03:57:41 <lambdabot> Source not found.
03:58:16 <erus`> hmmm
04:00:49 <erus`> my string are made from tuples like this ('a', ('b', ('c', ())))
04:01:17 <erus`> so print looks something like this print (a, b) = (putch a, print b)
04:04:19 <erus`> i dont even know how i'm gonna handle lazyness
04:04:51 <erus`> maybe just any calls to getch will be strict
04:04:56 <erus`> would that work?
04:05:11 <erus`> no...
04:05:36 <kizzx2> hey guys, what are your opinions on the importance of understanding the "academic side" of haskell (such as proofs or formula heavy papers) when doing real world programming?
04:05:48 <merijn> erus`: You mean how to handle the problem of referential transparency when doing IO?
04:06:03 <merijn> kizzx2: Not remotely important
04:06:54 <merijn> kizzx2: You can write plenty of programs without needing any of that. Overtime writing basic programs will be simple and you might be interested in more advanced stuff, but you can easily code without a lot of the theoretical stuff
04:07:15 <erus`> merijn: i have explicit impure functions
04:07:21 <erus`> which can call IO stuff
04:07:34 <merijn> erus`: Did you look at Clean's uniqueness typing?
04:07:42 <merijn> That's an alternative to haskell's monads
04:07:52 <kizzx2> merijn: i asked because the haskell scene is flooded with PhD papers (i'd say over 50% of the materials), i wonder deciphering them is essential to really understanding haskell
04:07:57 <merijn> kizzx2: And other "theoretical stuff" (monads, arrows, etc) you can easily understand without understanding the proofs/formula's once you grok haskell's type system
04:08:36 <merijn> kizzx2: I'd say that if you've read Learn You a Haskell and Real World Haskell that should be more then enough for understanding haskell basics and writing code
04:08:41 <merijn> And both are fairly easy
04:09:06 <kizzx2> merijn: yeah i am through them both
04:09:15 <merijn> kizzx2: It also depends on how much of haskell's details you want to understand :p But like I said, I don't think full understanding of all the details is important for writing real world code
04:09:57 <kizzx2> merijn: arr while we're at it, do you define your own Monads often?
04:10:27 <kizzx2> last time i asked, one person responded with "through 2 years of Project Euler experience, i've never needed to invent a monad", but then i thought "i probably never need to define a class in C++ to do Project Euler" :P
04:10:35 <erus`> "when calling an impure function, arguments are evaluated" thats easy enough
04:10:45 <merijn> I don't write all that much haskell at the moment :p
04:11:07 <merijn> kizzx2: Writing your own monads is fairly useful, but it depends on the programs your writing
04:11:23 <merijn> Project Euler is vastly different from real world programs :p
04:11:52 <merijn> You could take a look at Xmonad, that's a case of using a custom monad for a "real world" program
04:12:16 <kizzx2> umm
04:12:31 <kizzx2> so i think a inventing new monad is not as often as inventing a new interface or class in Java?
04:12:41 <erus`> @hoogle a -> b -> b
04:12:42 <lambdabot> Prelude seq :: a -> b -> b
04:12:42 <lambdabot> Control.Parallel par :: a -> b -> b
04:12:42 <lambdabot> Control.Parallel pseq :: a -> b -> b
04:12:47 <merijn> Not as often, but not really rare either
04:13:16 <merijn> kizzx2: Although you do almost nothing as often as writing a new interface/class in Java, cause every little thing needs new classes :p
04:13:24 <kizzx2> lol
04:13:25 <kizzx2> yeah
04:13:40 <erus`> maybe i will just build in seq :O
04:13:51 <erus`> @src seq
04:13:51 <lambdabot> Source not found. You type like i drive.
04:13:57 <kizzx2> such as an anonymous function (IRunnable? maybe the scene has changed haven't looked at Java for several years)
04:14:16 <merijn> kizzx2: Also, not all Haskell papers are completely obscure and undecipherable. You just need to pick the right papers ;)
04:14:34 <merijn> kizzx2: Java 7 recently got released, which means they now have first class functions :p
04:14:51 <kizzx2> merijn: any pointers would be greatly appreciated (obviously i'm quite discouraged by the perceived condescendence-ness most papers convey :P)
04:14:51 <erus`> is seq only used for IO/
04:15:18 <merijn> Wadler's "Monads for Functional Programming" should be very readable if you've finished RWH/LYAH
04:15:36 <mornfall> There's no such thing as kind overloading, hm? :)
04:15:55 <kizzx2> merijn: thanks :)
04:17:00 <merijn> Also interesting and fairly readable is "A tutorial on the universality and expressiveness of fold" by Hutton, discusses how any recursive function can be rewritten as fold + a trivial function
04:17:10 <mornfall> merijn: Are you sure about Java 7?
04:17:22 <mornfall> merijn: WP says that lambdas (and maybe closures) are planned for Java 8.
04:17:22 <merijn> mornfall: Yes
04:17:31 <merijn> mornfall: Oh, did they get pushed back then?
04:17:51 <merijn> mornfall: I knew 7 was released and closures/lambda's were planned for 7, but maybe that got postponed
04:17:52 <cheater> i'm thinking it's probably a result of ocaml existing
04:17:54 <cheater> er
04:17:55 <mornfall> Dunno. I don't use Java, I was just curious what they actually got.
04:18:05 <cheater> wtf am i saying, not ocaml. what's that java vm thing?
04:18:08 <cheater> clojure?
04:18:16 <mornfall> cheater: Scala?
04:18:20 <cheater> ah right.
04:19:06 <Ptival> (Clojure is also on JVM though)
04:19:08 <merijn> kizzx2: And lastly "Generalising monads to arrows" by Hughes (I think these should be approximately in ascending order of difficulty too :)
04:19:30 <merijn> Clojure actually seems kinda nice
04:19:34 <merijn> Scala just seems boring
04:19:42 <gienah> kizzx2: "Fun with type functions" is a really neat tutorial paper
04:19:43 <mornfall> Java 7 brings XRender support in Java 2D. Cool, now that everyone else switched to GL. :D
04:19:51 <Ptival> merijn, I think it got postponed yes, 7 didn't have real big new features
04:20:28 <gienah> http://www.haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
04:20:45 <kizzx2> gienah: last time i tried Fun with Type Functions i got thrown off in the middle :P
04:20:54 <mornfall> Well, clojure is a lisp dialect.
04:21:18 <Ptival> it has cool STM features
04:21:25 <mornfall> It probably doesn't have static types...
04:21:29 <Ptival> nope
04:21:49 <erus`> 3 is the 'sum' of 1 + 2.       1 is the ? or 2 - 1
04:21:54 <gienah> kizzx2: ok it does seem easier to write stuff using simple haskell techniques, and maybe more advanced stuff can like in fun with type functions can be added later
04:22:10 <mornfall> I'd totally dig Clojure, like 6 years ago.
04:22:33 <merijn> Clojure and haskell are the only languages I'm aware of that have a functioning STM and I like their focus on immutable data
04:23:04 <companion_cube> scala (with akka) also has STM
04:23:16 <Peaker> does golang also make the mistake of everything being nullable by default?
04:23:18 * gienah really likes lisp as well, a really neat chapter on Haskell STM: http://research.microsoft.com/pubs/74063/beautiful.pdf
04:23:21 <merijn> companion_cube: By functioning I meant "reasonably performing" :p
04:23:41 <companion_cube> merijn: do you have benchmarks ? :)
04:23:58 <Ptival> gienah: +1, I really liked Beautiful Concurrency :)
04:24:06 <merijn> companion_cube: Vague recollection of some benchmarks I read somewhere and broad generalisations :)
04:24:14 <merijn> Peaker: All pointers can be nullable of course, but Go relies much less on pointers
04:24:38 <merijn> I actually really like Go, extremely boring language. But boring in a good way :)
04:24:45 <merijn> It is what I always wanted C to be :p
04:24:49 <companion_cube> merijn: however i wonder if other STM also have condition-like behavior and such
04:24:53 <Peaker> merijn: Why "of course"?  They could be non-nullable by default
04:24:54 <gienah> Ptival: its that chapter that got me hooked on haskell
04:25:02 <Peaker> merijn: It's GC'd
04:25:17 <merijn> Peaker: Like I said, everything I wanted C to be :p
04:25:58 <MasseR> companion_cube: Clojure doesn't have retry and or-else operators at least
04:26:02 <Ptival> is Go too consensual? :D
04:26:03 <MasseR> If that's what you meant
04:26:09 <mornfall> Automatic destructors might be actually more important than GC for C-like languages.
04:26:19 <companion_cube> MasseR: yeah, i was thinking of this
04:26:21 <companion_cube> too bad then
04:26:39 <erus`> go's lack of generics is a bit of a pain
04:26:57 <companion_cube> seems that scala's STM has retry
04:27:04 <merijn> erus`: Can't you adequately fake that with their interface system?
04:27:05 <companion_cube> and orElse
04:27:10 <companion_cube> which is cool
04:27:16 <erus`> merijn: have you tried
04:27:23 <merijn> Not a lot
04:27:26 <erus`> using the vector pkg for example
04:27:47 <mornfall> I'm still waiting for a language that beats C++ templates.
04:28:08 <merijn> Haskell? :D
04:28:13 <mornfall> (That's not Haskell, anyway.)
04:29:39 <erus`> seq is the saving grace of lazy languages
04:30:13 <gienah> @google "An Extended Comparative Study of Language Support for Generic Programming" siek
04:30:15 <lambdabot> http://portal.acm.org/citation.cfm?id=1230757
04:30:15 <lambdabot> Title: An extended comparative study of language support for generic programming
04:30:34 <hpaste> erus` pasted “lambdurp prelude” at http://hpaste.org/49883
04:30:45 <erus`> what do you guys think?
04:31:01 <gienah> mornfall: ^^^ one of the authors of the above paper was also one of the authors of the C++ Boost Graph Library
04:31:23 <erus`> theres a list of built ins at the bottom which i cannot implement in the language itself
04:32:07 <mornfall> erus`: You could use church numerals. :D
04:32:26 <mornfall> erus`: And impure looks like a builtin to me, too.
04:32:42 <erus`> its a function type
04:32:54 <erus`> there are pure functions and impure functions
04:33:26 <erus`> its not a wrapper function or anything
04:34:08 <mornfall> gienah: I can't find a fulltext link on that ACM page. :|
04:34:14 <mornfall> Even when logged in.
04:34:42 <merijn> Did you try plugging the title into Google Scholar/Citeseerx
04:34:58 <gienah> mornfall: oh yeah, lambdabot google gives a different hit, its here: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.110.122&rep=rep1&type=pdf
04:34:59 <mornfall> Aha, citeseer has one.
04:35:13 <Ptival> yes
04:35:31 <mornfall> ACM fail.
04:35:44 <Ptival> I hate this shit :(
04:36:04 <Ptival> just put the PDFs on your univesity page...
04:36:40 <mornfall> "type-safe polymorphic containers is routine programming practice" ... I *so* wish.
04:38:51 <merijn> Ptival: IEEE transactions no longer allow that
04:38:55 <merijn> Vile criminal scum
04:39:13 <Eduard_Munteanu> Then don't publish through IEEE?
04:39:19 <Ptival> meh
04:39:39 <mornfall> merijn: They cannot not allow that. C'mon.
04:39:45 <merijn> Eduard_Munteanu: I won't, but that's easy for me to say. My academic career does not yet depend on being published :p
04:41:33 <mornfall> The comparison table on page 4 is telling. :-)
04:42:12 <gienah> mornfall: yes especially given the C++ credentials of some of the authors
04:43:36 <Eduard_Munteanu> Isn't full IEEE membership/access costly?
04:44:02 <gienah> mornfall: the authors do have a note on that table that the - dashes for the C++ entries mean that C++ templates can do this stuff anyway
04:44:03 <Eduard_Munteanu> In this case, I don't see how IEEE is a good venue for getting work published, especially considering these things are selling articles for.
04:44:29 <Eduard_Munteanu> (do they even provide peer review?)
04:45:19 <merijn> Eduard_Munteanu: IEEE transactions do
04:45:23 <merijn> afaik
04:45:33 <gienah> C++ templates are really powerful, the C++ syntax though is really verbose and weird compared to the beauty of Haskell
04:52:08 <mornfall> gienah: It's still good when compared to "modern" OO languages like Java or C#. :)
04:53:58 <mornfall> I was rather disappointed back when Java Generics were a relatively new thing.
04:54:46 <gienah> mornfall: yes I agree Java generics are really weak compared to C++ templates and Haskell
04:55:55 <Favonia> hmm but Java has <? extends X>, which in some sense is a weak version of context. the committee gave up "Concept" in C++0x :P
04:56:18 <mornfall> Which is a shame. Especially when you inherit a Java codebase and you find out a whole lot of otherwise natural refactorings that would shrink it by a factor of 2 are impeded by the language.
04:56:41 <erus`> ghc isnt producing an exe for my file
04:56:47 <erus`> is it because it's a module?
04:56:52 <mreh> what exactly is NoSQL about acid-state, i'm not exactly up to scratch on my buzzwords, but doesn't that imply there is no relational model implemented?
04:57:21 <merijn> mreh: I would guess?
04:57:25 <gienah> mreh: I sort of thought that NoSQL meant No ACID
04:57:29 <mornfall> Favonia: Well, explicit concepts will greatly help error reporting in C++.
04:57:41 <merijn> It's kinda weird but NoSQL usually sacrifices ACID for scalability...
04:57:46 <hpc> i thought nosql meant it didn't use a string-based query language?
04:57:51 <mornfall> Favonia: But I think the priority is to not impede expressive power on that account. Which is somewhat tricky.
04:58:01 <Jafet> mornfall: the error messages filter out the weak
04:58:02 <mreh> hpc: it does on the face of it!
04:58:12 <Jafet> It's true to a smaller extent with ghc...
04:58:18 <mreh> a certain string based query language at least
04:58:20 <mornfall> Jafet: Good point. :-)
04:58:30 <gienah> hpc: supposedly, but most NoSQL databases are also no ACID
04:58:46 <Jafet> Everything is better with ACID.
04:58:50 <mike-burns> It sure is.
04:58:54 <mornfall> Jafet: When you involve associated types and/or GADT matching, you can get out into error message wastelands...
04:58:56 <mreh> relevant nickname
04:59:00 <mreh> oh this isn't reddit
04:59:45 <mreh> besdise, the acid monad sounds cooool
05:00:01 <mornfall> mreh: That's a cool typo.
05:00:28 <Jafet> erus: what if you specify -o?
05:00:29 <mreh> bedside
05:00:47 <Jafet> Let's not go into this bedside monad
05:05:35 <mornfall> Bedside monad for each household. Lulls the most unruly children to sleep in no time.
05:06:42 <mreh> RAMcloud sounds equally opaque too :(
05:06:46 <HalfWayMan> Hey guys, I'm stuck writing an Iteratee (from enumerator package) that has the behaviour of zipWith. Any pointers?
05:07:34 <mornfall> HalfWayMan: I'd start by looking whether there's a zip and a map.
05:07:52 <HalfWayMan> mornfall: There is map, but no zip :(
05:10:53 <weirdo> hello
05:11:01 <mreh> hi
05:11:35 <weirdo> i'm new to the subject of type inference and code analysis. could you please recommend me some papers to implement both, esp. for recursive and mutually-recursive functions?
05:12:03 <Jafet> Hindley-Milner?
05:12:11 <mornfall> weirdo: What do you mean with code analysis?
05:12:19 <mornfall> What is your type system you want to infer in? :)
05:12:31 <mreh> how many are there?
05:12:39 <weirdo> mornfall, i have a dynamically-typed language and i need to optimize arith not to use generic dispatch each time
05:12:48 <mornfall> mreh: Enough to make that question vastly ambiguous.
05:12:56 <Nisstyre> weirdo: anything written by Philip Wadler is good
05:13:21 <mornfall> weirdo: I see. So you want to attach a static label to stuff that can only contain numbers.
05:13:32 <weirdo> not just numbers, but yes
05:13:41 <weirdo> i have a Scheme numerical tower
05:13:46 <mornfall> Oh.
05:14:08 <Jafet> Sounds like you want to ask #scheme then
05:14:16 <Jafet> Or readscheme
05:14:25 <mornfall> But I sort of suspect that a lot of folks already did this. :-)
05:14:29 <Jafet> There are a few compiler writers in #scheme.
05:14:29 <weirdo> someone on #lisp suggested me the channel because you're type heads :P
05:14:48 <weirdo> at least stereotypically
05:14:56 <mornfall> Jafet: Is there something about scheme that's not about implementing it? :D
05:15:00 <merijn> weirdo: Yeah, but mostly static typeheads :p
05:15:15 <weirdo> merijn, it's not that different, really :-)
05:15:22 <weirdo> just type unions, for instance
05:15:26 <Jafet> mornfall: sure, the other half of scheme is to standardize all those implementations
05:15:26 <Nisstyre> omg, reading his blog right now. People are using Haskell to design traintracks
05:15:28 <weirdo> and how they unify
05:15:29 <Nisstyre> that's fucking awesome
05:16:19 <mreh> Nisstyre: who?
05:16:19 <mornfall> weirdo: Type unions, that sounds like Trade union.
05:16:28 <Nisstyre> mreh: http://wadler.blogspot.com/2011/06/combinator-library-for-design-of.html
05:16:34 <weirdo> :)
05:18:00 <mornfall> weirdo: Hm, are you implementing scheme, or something else, btw? What kind of dynamic dispatch there is in scheme?
05:18:23 <mreh> is that a kind of polymorhpism?
05:18:25 <Nisstyre> what exactly is dynamic dispatch btw?
05:18:37 <merijn> Nisstyre: Determining which function to call at runtime
05:18:38 <mornfall> Nisstyre: Function overloading (possibly on more than one parameter).
05:18:49 <mornfall> I.e. dynamic-type-dependent dispatch.
05:18:53 <weirdo> mornfall, if one passes to '+ a complex number and a rational, the rational has to become r+0i before it can be added
05:18:57 <Nisstyre> mornfall: does ghc use it with pattern matching?
05:19:10 <merijn> Nisstyre: Sometimes, also for typeclasses
05:19:29 <Nisstyre> merijn: but it's different for class instances right?
05:19:32 <weirdo> mornfall, also, rationals can only contain the same integer type, bignum/int
05:19:32 <mornfall> That's not dynamic dispatch, though. :P
05:19:36 <merijn> Nisstyre: Think of a function "(Eq a) => [a] -> b", which version of "==" gets called inside that function depends on which a
05:19:59 <Nisstyre> so it's a form of ad-hoc polymorphism?
05:20:10 <weirdo> it's very ad-hoc
05:20:16 <Nisstyre> cool
05:20:20 <mornfall> merijn: But that's a static dispatch. You can entirely compute which implementation you need at compile time. It's just that you want to save on generated code volume so you pass around dictionaries.
05:20:25 <weirdo> because it has to be written in javascript because of circularity issues
05:20:46 <merijn> weirdo: Really? What if I reading in data from a file and don't know which value a will have until after parsing?
05:20:50 <merijn> eh
05:20:53 <merijn> s/weirdo/mornfall
05:21:03 <mornfall> merijn: Can't do in Haskell. :) Without cast, that is.
05:21:07 <weirdo> mornfall, also, there's stuff like SCM_sub methods for subtraction, that work for all kinds of numbers, but it's always T.SCM_div(T)
05:21:59 <weirdo> s/div/sub
05:22:15 <Nisstyre> scheme has pattern matching, does that use dynamic dispatch?
05:22:17 <mornfall> merijn: The Haskell types are, well, static. They can be erased, and register values don't *know* their types in Haskell runtime.
05:22:30 <weirdo> Nisstyre, scheme has no pattern matching unless one writes a macro
05:22:38 <weirdo> Nisstyre, pattern matching is runtime-only
05:22:41 <Nisstyre> weirdo: that's what I was referring to
05:22:54 <Nisstyre> weirdo: so it's dynamic?
05:22:58 <weirdo> yes
05:23:11 <Nisstyre> all right
05:23:13 <mornfall> Yes, scheme values don't have a static type, but they carry their type around at runtime.
05:23:18 <mornfall> That's dynamic dispatch.
05:23:27 <mornfall> But it only apparently affects the numeric tower.
05:23:40 <Nisstyre> I need to read the rest of SICP
05:23:40 <mornfall> Since I don't think you can do these kinds of things to user types.
05:23:41 <merijn> mornfall: Hmm, guess you're right.
05:23:46 <weirdo> numeric tower is my biggest gripe, because the rest works fine
05:24:20 <weirdo> i had 4 seconds of runtime, and it became 1 minute after adding the numerical tower
05:24:20 <mornfall> If you write a "foo" method, it'll always be the same "foo" in a given lexical scope.
05:24:26 <mornfall> s/method/function/
05:24:42 <weirdo> mornfall, there's also 'set!'
05:24:54 <Nisstyre> mornfall: what if you define a new 'foo' ?
05:25:09 <mornfall> Nisstyre: foo is a variable binding... lexical scoping applies
05:25:21 <mornfall> You only can have one at a time.
05:25:26 <mornfall> In scope that is.
05:25:35 <Nisstyre> mhmm
05:26:01 <weirdo> guys, how hard is it to type-infer a recursive or mutually-recursive function? check whether the unions unify after a cycle, and if not, continue until some limit?
05:26:13 <weirdo> s/unions unify/types unify/
05:26:28 <mornfall> weirdo: Well, in a static type system, you don't care about recursion.
05:26:39 <mornfall> weirdo: And the inference doesn't need to care in your case either.
05:26:42 <mornfall> I suppose.
05:26:51 <weirdo> yeah, you don't have union types in the same meaning scheme as
05:27:01 <weirdo> s/as$/has
05:27:04 <Nisstyre> weirdo: maybe this will help? http://research.microsoft.com/en-us/um/people/simonpj/papers/gadt/
05:27:16 <weirdo> thank you
05:27:17 <mornfall> Nisstyre: GADT inference? Better not. :)
05:27:29 <Nisstyre> mornfall: I just googled peyton jones type inference
05:27:44 <mornfall> That's probably two levels too strong for this problem.
05:27:53 <Nisstyre> that page has other papers anyway
05:28:13 <Nisstyre> the one at the bottom might be helpful
05:28:34 <mornfall> The Hindley-Milner inference algorithm is wikipedia-study material.
05:28:49 <mornfall> wp type inference for starters
05:28:57 <weirdo> how do i simplify unions, btw?
05:29:21 <weirdo> i need to think of an algebraic type system first, i guess
05:30:01 <weirdo> all types deriving from T, then numbers, symbols, lists, etc. in numbers, complex -> rational etc.
05:30:19 <weirdo> but i have a crazy idea about weakly typed, but typed conses
05:30:29 <mornfall> That really sounds crazy.
05:30:38 <Nisstyre> o_O
05:30:48 <mornfall> Typing conses sounds like something that'll give you a non-terminating type checker.
05:31:08 <mornfall> Don't even *think* about inference. :D
05:31:29 <weirdo> so all conses have to be untyped?
05:31:35 <weirdo> :(
05:31:39 <Nisstyre> I don't think so
05:31:40 <weirdo> how about typed lists?
05:32:10 <weirdo> or about (cons function (list nubmer))? can it be terminating?
05:32:24 <mornfall> Well, if you can prove that a given list only contains numbers, then you are good to go. But conses can contain, well, anything.
05:32:55 <JuanDaugherty> nubmer
05:33:02 <weirdo> yes, but i have access to functions that cons
05:34:02 <Nisstyre> data Tree a = Empty | Leaf Int | Branch (Tree a) (Tree a) deriving (Show)
05:34:12 <Nisstyre> what would you classify that as?
05:34:28 <mornfall> Nisstyre: ADT
05:34:31 <Axman6> a binary tree with a phantom parameter?
05:34:33 <weirdo> i don't plan on having typeclasses
05:34:46 <mornfall> Ah, and that phantom is really weird. :D
05:34:53 <Jafet> (system "stalin" ...)
05:35:07 <Jafet> Oh, you want to compile to javascript or something
05:35:14 <weirdo> yes
05:35:16 <Jafet> You horrible little man
05:35:19 <Axman6> ew
05:35:29 <weirdo> oh come on
05:35:38 <weirdo> browsers needs some real language
05:35:39 <weirdo> :)
05:35:49 <mornfall> They don't deserve one.
05:35:50 <mornfall> :P
05:35:58 <mornfall> And then, you can have Haskell if you have to.
05:36:16 <Jafet> But it ain't webscale
05:36:19 <weirdo> i had some irreconcilable differences with haskell
05:36:26 <Nisstyre> the Mozilla people want to stick a python interpreter in Firefox iirc
05:36:29 <weirdo> one is type errors with typeclasses
05:36:46 <ion> The Chrome people want it to run native code.
05:36:47 <weirdo> other is how io monads poison everything they touch
05:36:54 <weirdo> ion, chrome people don't want it, they do
05:36:55 <weirdo> already
05:36:56 <weirdo> :)
05:36:57 <merijn> weirdo: That's kinda the point
05:37:06 <Nisstyre> webGL is a bad idea...
05:37:09 <weirdo> the latter?
05:37:18 <merijn> weirdo: Write a thin wrapper of IO code and write the rest pure
05:37:29 <Axman6> w if you want safe programs, you have to segregate IO away. it's the most sane way to do it
05:37:33 <mornfall> weirdo: Capturing side effects in the static type system is the idea.
05:37:33 * mux wants to stick a fork in the eyes of Mozilla people
05:37:38 <ion> weirdo: That’s how you should write *all* software. Haskell just makes it explicit in the types.
05:37:40 <merijn> And yeah, browsers doing hardware acceleration and compiling to native code is a stupendously DUMB idea
05:37:53 <Axman6> weirdo*
05:37:55 <weirdo> ion, but what about localized side-effects?
05:38:02 <mornfall> merijn: Well, not really.
05:38:08 <merijn> mornfall: Yes it is
05:38:16 <Axman6> weirdo: such as?
05:38:20 <merijn> They can't even secure normal browsers with just interpreted javascript
05:38:21 <mornfall> merijn: What's wrong with it, really?
05:38:27 <weirdo> if i cons something, i should be able to mutate it without io monad poison
05:38:30 <Jafet> weirdo: by definition, there can't be localized side-effects.
05:38:39 <merijn> mornfall: The security implications are completely disastrous
05:38:39 <Axman6> why?
05:38:45 <Jafet> Side effects are effects. They affect effects on other stuff.
05:38:51 <Axman6> that breaks referential transparency
05:38:52 <weirdo> Jafet, (nreverse (loop for i below 10 collect (i))
05:38:54 <weirdo> as a trivial example
05:39:00 <mornfall> merijn: What's the difference between running the binary blobs in the closed, secure-as-a-sieve flash plugin?
05:39:07 <mornfall> merijn: And the browser itself...
05:39:07 <merijn> mornfall: I actually saw someone who managed to gain root via Firefox compiling JS to native code
05:39:18 <merijn> mornfall: Flash is also horrendously dumb
05:39:24 <Nisstyre> mornfall: you can't blame the browser authors
05:39:38 <zygoloid> merijn: someone was running ff as root?
05:39:48 <mornfall> Nisstyre: If I were a browser author, I'd rather have a fast JS engine than having to wrap around that flash abomination.
05:39:59 <mornfall> zygoloid: Probably a local root exploit.
05:40:04 <Nisstyre> mornfall: I'm sure they all would agree
05:40:11 <zygoloid> mornfall: that's hardly ff's fault :)
05:40:18 <Nisstyre> another huge problem is tag soup compatibility
05:40:20 <merijn> zygoloid: No, privilege escalation exploit in the javascript compilation process
05:40:24 <Jafet> weirdo: (let ((x (loop for i below 10 collect (i))) (cons x (nreverse x)))
05:40:37 <mornfall> merijn: That's frankly nonsense. :-)
05:40:37 <weirdo> Jafet, that differs from my example
05:40:38 <luite> hmm, how can compiling javascript get you root?
05:40:42 <weirdo> i don't use the mutated form anywhere
05:40:49 <merijn> Let me look up the article again
05:40:53 <Jafet> weirdo: and how do you express that in the type system?
05:40:58 <Nisstyre> it must've been a bug in the JS interpreter
05:41:03 <zygoloid> js -> arbitrary code execution is clearly ff's fault
05:41:17 <mornfall> zygoloid: Right, and a disastrous one at that.
05:41:18 <mornfall> :-)
05:41:19 <weirdo> Jafet, nreverse list => list
05:41:34 <Nisstyre> anyway, I forget what you were discussing
05:41:37 <weirdo> (sorry, i already forgot Hs syntax from my LYAH time)
05:41:38 <Jafet> weirdo: well, Haskell doesn't have linear typing.
05:41:40 <luite> I think running native code, or at least generating native code in the browser should be ok
05:41:56 <Axman6> weirdo: haskell provides ways to have local side effects through the ST monad anyway. it's IO without any actual IO, just mutation of variables and arrays
05:41:56 <zygoloid> mornfall: :) doesn't everyone run firefox in a chroot jail as an unprivileged user?
05:42:01 <merijn> Oh, I'm mixing it up. It was remote arbitrary (native) cod execution, not root exploit
05:42:09 <mornfall> Well, generating native code is not really different from interpreting.
05:42:11 <weirdo> Axman6, but it's still poison
05:42:11 <luite> webgl is a different matter though, since it depends on huge amounts of existing driver code traditionally not designed with security in mind
05:42:11 <Axman6> and it's guaranteed by the type system to give a pure result
05:42:17 <weirdo> right?
05:42:19 <Jafet> Axman6: you mean GHC?
05:42:21 <merijn> But that just means your one local root exploit away from remote rooting the box
05:42:21 <Axman6> weirdo: how? o.O
05:42:25 <mornfall> As anyone who had bash exposed to internet should know.
05:42:25 <Nisstyre> zygoloid: no, everyone runs downloads the html with wget and then views it in vim
05:42:35 <rwbarton> it's not poison
05:42:40 <weirdo> Axman6, i thought IO monads poison everything they touch
05:42:41 <rwbarton> @type runST
05:42:42 <lambdabot> forall a. (forall s. ST s a) -> a
05:42:47 <weirdo> oh
05:42:49 <weirdo> great!
05:42:54 <weirdo> i might look at haskell again
05:42:56 <zygoloid> Nisstyre: but they run vim in a sandbox, though, right? :)
05:42:59 <Axman6> the IO monad cannot be escaped. that doesn;t mean everything has to be in IO
05:43:03 <Nisstyre> zygoloid: absolutely
05:43:04 <merijn> weirdo: No. It's just that you cannot get anything *out* of the IO monad
05:43:06 <luite> mornfall: there's a major difference in that you have writable memory pages with code, while with just an interpreter you could have a more strict separation between data and code
05:43:14 <merijn> weirdo: But you can stuff any pure code into it no problem
05:43:21 <Nisstyre> zygoloid: or they have it printed and then mailed to them
05:43:29 <Nisstyre> ala Stallman
05:43:50 <Axman6> main = do {str <- readFile "foo"; let x = puerlyProcessFileContents str; print x }
05:43:54 <zygoloid> Nisstyre: i think you're supposed to print it out and take a photo and then mail that.
05:44:01 <Nisstyre> oh yeah
05:44:03 <Axman6> purely*
05:44:06 <Nisstyre> I forgot about ink exploits
05:44:11 <zygoloid> yeah. plus the wooden table adds 30% extra security
05:44:24 <weirdo> Axman6, is readFile a monad thingie?
05:44:28 <Nisstyre> laminating it isolates the exploits
05:44:32 <Axman6> readFile is an IO thing
05:44:35 <Axman6> :t readFile
05:44:35 <lambdabot> FilePath -> IO String
05:44:35 <mornfall> :D
05:44:38 <weirdo> :-(
05:44:39 <mornfall> Confusion galore.
05:44:49 <Jafet> zygoloid: but don't use the WMF image format; there was a code injection exploit in that
05:44:49 <mornfall> weirdo: You can't read files without doing IO, right?
05:44:57 <weirdo> mornfall, but it's referentially transparent
05:44:57 <Axman6> weirdo: it seems your problems with haskell are quite misfounded ;)
05:45:02 <mornfall> weirdo: No way.
05:45:13 <Axman6> weirdo: of course it's not
05:45:29 <mornfall> It's not even remotely approaching anything that could be labelled referentially transparent.
05:45:46 <Nisstyre> referential transparency? in my monads?
05:45:52 <weirdo> err, what, getpid() is a monad too i suppose?
05:45:53 <Axman6> if you read the same file twice, there is absolutely no guarantee that it will have the same content
05:45:57 <merijn> weirdo: Example, if I read in a file I get an "IO String", now it is impossible to turn IO String into a String. But if I have a function that has type "String -> a" I can turn "IO String" into an "IO a"
05:46:04 <mornfall> weirdo: Monad /= IO.
05:46:06 <Axman6> weirdo: you're not using the word monad correctly
05:46:14 <Axman6> not even close
05:46:16 <weirdo> i see
05:46:25 <Axman6> lists are monads
05:46:31 <Axman6> that's a pure monad
05:46:34 <mornfall> You got your types all mixed up. :)
05:46:36 <Axman6> so is Maybe, and Either
05:46:42 <Axman6> even functions are monads
05:46:52 <Nisstyre> Axman6: so anything that boxes something up?
05:46:53 <merijn> weirdo: I highly recommend reading Learn You a Haskell, its explanation of monads and IO is really clear
05:46:54 <Axman6> monad doesn't imply anything about side effects
05:47:08 <Axman6> Nisstyre: no, not really :P
05:47:15 <weirdo> merijn, i almost read it to the end, even asked you guys when i couldn't get my head around it and got excellent answers
05:47:16 <Nisstyre> what's the distinction there?
05:47:19 * mornfall boxes Nisstyre up.
05:47:21 <EvilTerran> Hello haskellers, long time no see
05:47:21 <Axman6> plenty of things can hold things that aren't monads
05:47:33 <qwr> weirdo: pid can change too :)
05:47:41 <weirdo> qwr, :)
05:47:42 <merijn> I think that IO/monad confusion is such a shame, since monads are really simple when you look at the Maybe monad instead of IO
05:47:50 <Nisstyre> you said Maybe is a monad, all it does is box things up as Just, or you have Nothing, right?
05:47:55 <Axman6> type Foo a = Foo Int is certainly not a... well.. useful monad anyway. you can use undefined everywhere, but that's... not cool >_>
05:48:05 <mornfall> Nisstyre: But that's not what makes it a monad.
05:48:07 <merijn> Nisstyre: The Maybe monad implements short-circuiting evaluation
05:48:21 <aavogt> you're allowed to substitute    let rf = readFile "a", whenever you've got a  `readFile "a"', no?
05:48:24 <JuanDaugherty> well a pid value is unchanging
05:48:29 <zygoloid> Jafet: naturally you convert it to ppm, print it, then fax it.
05:48:31 <mornfall> (Hm, and all this just because I wanted to get a confirmation that I can't kind-overload stuff in Haskell...)
05:48:37 <merijn> Nisstyre: You can use it to string lots of "a -> Maybe b" computations together and return Nothing whenever any of them return a Nothing
05:48:53 <Nisstyre> merijn: ok
05:48:59 <Axman6> aavogt: but that's different from running the same computation twice
05:49:02 <merijn> Nisstyre: For example, looking a key up in a Map obviously returns a Maybe, right?
05:49:12 <JuanDaugherty> (i.e. the value associated with the OS object instance)
05:49:16 <Axman6> the results are not guaranteed to be the same
05:49:17 <Nisstyre> merijn: yeah
05:49:20 <erus`> @hoogle IO a -> IO b
05:49:20 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
05:49:21 <lambdabot> Control.OldException finally :: IO a -> IO b -> IO a
05:49:21 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
05:49:25 <mornfall> merijn: Not obviously. It could be any number of things, and it's only a coincidence that Maybe is a Monad.
05:49:29 <erus`> @hoogle m a -> m b
05:49:30 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
05:49:30 <lambdabot> Foreign.ForeignPtr castForeignPtr :: ForeignPtr a -> ForeignPtr b
05:49:30 <lambdabot> Foreign.Ptr castFunPtr :: FunPtr a -> FunPtr b
05:49:31 <Jafet> weirdo: the trippy BSD people had some implementation of freezing a unix process and thawing it out again
05:49:31 <EvilTerran> I'm wanting to put together something with a fairly basic graphical UI -- what's trendy in haskell circles for that these days? Grapefruit?
05:49:41 <Jafet> I imagine it needn't have the same pid afterwards
05:49:46 <merijn> Nisstyre: Now imagine using the key that was looked up to do more lookups, now you would have to check for Nothing at any point, right?
05:50:01 <mornfall> Jafet: Well, just the reality of "fork" is enough to make it clear that getpid is not referentially transparent.
05:50:12 <Nisstyre> merijn: yes
05:50:13 <mornfall> Jafet: You don't need fancy devices for that.
05:50:16 <Axman6> Jafet: wouldn't that be almost trivial? there's probably some details i haven't thought about
05:50:21 <Ptival> and as much as monads aren't all about IO, IO isn't all about monads (it's just a type class, then it is made an instance of Monad for some reasons)
05:50:21 <Jafet> mornfall: well, you can't fork in ghc?
05:50:23 <Nisstyre> I think I understand what you mean now
05:50:35 <mornfall> Axman6: Like open descriptors, sockets and stuff? :)
05:50:41 <Jafet> Axman6: hey, we're talking about unix here
05:50:44 <merijn> Nisstyre: The Maybe monad takes a Maybe value and a "a -> Maybe b" function, if the Maybe value is "Just a" it will return the function and its "Maybe b" return value. If the input value is nothing it will return Nothing immediately
05:50:47 <Axman6> yeah, heh
05:50:56 <merijn> Without needing to write the Nothing check at every point
05:51:09 <Axman6> k hadn't even got that far, i was wondering how difficult linking would be.
05:51:12 <JuanDaugherty> Jafet, yes you can createProcess.
05:51:44 <Jafet> But that doesn't fork the program, only the process
05:51:44 <Axman6> merijn: that explanation wasn't particularly clear :(
05:51:51 <Axman6> @src Maybe (>>=)
05:51:51 <lambdabot> (Just x) >>= k      = k x
05:51:51 <lambdabot> Nothing  >>= _      = Nothing
05:52:01 <mornfall> Jafet: You can via the FFI, if nothing else.
05:52:07 <EvilTerran> Axman6, I imagine there could be some serious complexities when freezing/thawing arbitrary processes, involving open handles and things
05:52:15 <Nisstyre> merijn: maybe an example?
05:52:16 <Axman6> yeah
05:52:21 <mornfall> EvilTerran: Yeah. It's actually impossible in practice. :)
05:52:42 <EvilTerran> what happens if the file you had open when you froze the process isn't there when you thawed? or the server you had a socket to isn't there any more?
05:52:43 <Axman6> the supercomputer i got to play with last semester used to do that somewhat, but i think it was just sending processes SIGSTOP and SIGCONT to wake them up again
05:52:44 <Jafet> weirdo: your concerns are valid, but it's not productive for a newbie to bash haskell on them
05:52:53 <mornfall> EvilTerran: Or you *were* the server.
05:52:54 <merijn> Nisstyre: LYAH has several examples at: http://learnyouahaskell.com/a-fistful-of-monads#getting-our-feet-wet-with-maybe
05:53:08 <weirdo> Jafet, true
05:53:25 <Jafet> weirdo: if you want to know more about this stuff, there's eg. a paper by oleg on how to encode one-time program configurations in the type system in a more-or-less pure way
05:53:32 <Jafet> But of course, that is not newbie stuff
05:53:52 <Axman6> Jafet: :|
05:54:10 <weirdo> i can write and understand some common recursion patterns, but other than that... nope :|
05:54:16 <qwr> Jafet: forkProcess :: IO () -> IO ProcessID
05:54:22 <EvilTerran> perhaps you could do something cunning with, say, haskell's restricted side-effects so you could freeze/thaw within some non-IO monad that only provides freezable functionality
05:54:25 <qwr> Jafet: System.Posix.Process
05:54:27 <Jafet> And someone here is working on a string interning library. It uses GHC's unsafe IO primitives, but resents a pure interface
05:54:53 <weirdo> resents?
05:54:53 <mornfall> Jafet: That's so far the best typo today. :D
05:54:56 <EvilTerran> Jafet, "resents"? Freud would be proud :P
05:55:08 * Jafet bows
05:55:12 <weirdo> :)
05:55:45 <Jafet> Well, there's currently a bug in that pure interface, so I was also correct
05:56:01 <Axman6> is this Text?
05:56:04 <weirdo> is unify a boolean function?
05:56:14 <mornfall> Anything that uses unsafePerformIO in nontrivial ways is almost bound to contain bugs.
05:56:17 <Axman6> unify?
05:56:23 <weirdo> Axman6, unification of types
05:56:35 <Axman6> no idea what you mean by that
05:56:37 <mornfall> weirdo: What is a boolean function?
05:56:40 <Jafet> afaik, it uses unsafePerformIO to set MVars.
05:56:50 <weirdo> mornfall, a function that returns a boolean
05:56:56 <Axman6> i thought it was all Ptr's?
05:56:59 <EvilTerran> hm... I note "In contrast to the released version [of grapefruit], the classic version contains support for [...] user interfaces whose widget structure may change". I guess that makes it unsuitable for what I want to do.
05:57:27 <EvilTerran> I guess, if I want to do that sort of thing, I'll be limited to, what, gtk2hs, wxHaskell, HTk, that kinda thing
05:57:44 <aavogt> Axman6: you're saying this should be a valid transformation (to be RT)?:     do x <- f; y <- f; ....    ===>   do x <- f; case x of y ->  ....
05:57:56 <Axman6> i thought it was similar to ByteString, Text {offset, length :: !Int, content :: Ptr Word8 } or somesuch
05:58:12 <weirdo> ok
05:58:22 <mornfall> weirdo: Well, the result of unify is more than a boolean.
05:58:23 <weirdo> i think i get it now how to do unification (not!)
05:58:34 <weirdo> unify and return type params?
05:58:56 <Axman6> aavogt: i guess
05:59:04 <mornfall> weirdo: Well, unification is simple on simple terms.
05:59:05 <weirdo> like, unify '(list number) '(list function) => '(list t)?
05:59:10 <mornfall> And your terms are pretty simple, aren't they? :)
05:59:17 <weirdo> mornfall, they have unions
05:59:23 <weirdo> does that change stuff?
05:59:32 <mornfall> weirdo: What even is a union? Doesn't it just have a limited form of subtyping?
05:59:33 <rwbarton> that's the opposite of unification
05:59:45 <weirdo> mornfall, no. (or number symbol) is exactly that
05:59:48 <Axman6> seems to me that's a pretty useless type system :\
05:59:56 <weirdo> mornfall, and that is a number
05:59:57 <weirdo> ugh
05:59:59 <mornfall> weirdo: What *is* (or number symbol) and why would you care?
05:59:59 <weirdo> a union
06:00:19 <aavogt> Axman6: I think that only works for Monad like  Reader or Identity
06:00:25 <weirdo> mornfall, because in Scheme that "union" is a valid variable, type designator etc.
06:00:36 <mornfall> weirdo: But you don't need that info in your optimisations.
06:00:36 <Axman6> yeah
06:00:54 <mornfall> weirdo: You just need "number", "complex" ... and "whatever".
06:01:16 <Axman6> aavogt: my point was jusr that the result of running readFile twice on the same file is not guaranteed to return the same string each time
06:01:22 <Axman6> just*
06:01:32 <weirdo> mornfall, i can call (if (symbol? <(or symbol number)> 0 (+ <(the-same-or-symbol-number)> 0) and it should work just fine
06:01:54 <weirdo> messed up the parens
06:02:40 <EvilTerran> man, these high-level GUI libs (http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries#High-level) look interesting but confusing :/
06:02:43 <mornfall> weirdo: You can actually add up symbols to numbers?
06:02:51 <mornfall> Ah, I see.
06:02:54 <weirdo> :-)
06:03:15 <mornfall> weirdo: Well, in that else branch, you know it's actually not a symbol. But that's all you know anyway.
06:03:33 <aavogt> Axman6: right, but even for 'pure' monads like list you get different results if you 'run' a function twice instead of once
06:03:44 <mornfall> weirdo: And it only works as long as symbol? has not been redefined in a local scope.
06:03:48 <Axman6> yeah
06:04:07 <Jafet> mornfall: so let's thank our gods that he isn't compiling elisp.
06:04:34 <Jafet> Perhaps you want to look into structural, rather than nominative type systems.
06:05:35 <Jafet> In other words, ML type interference
06:05:39 <Jafet> ...
06:05:40 <weirdo> mornfall, true
06:05:45 <weirdo> but i can take care of that
06:05:45 <Jafet> I should call it a day
06:06:01 <weirdo> mornfall, i already have in my compiler a local and toplevel scope separately
06:06:40 <weirdo> Jafet, nominative? structural?
06:06:54 <weirdo> i'd like to keep Scheme Scheme
06:07:07 <Jafet> http://en.wikipedia.org/wiki/Structural_type_system
06:07:45 <mornfall> weirdo: Scheme doesn't say anything about a static type system.
06:08:07 <weirdo> mornfall, that's just optimization, not a static type system :)
06:08:11 <weirdo> like SBCL does for CL
06:08:22 <weirdo> so i could add a DEFKNOWN form
06:08:22 <mornfall> weirdo: Right, so you can use any static type system that fits.
06:09:02 <weirdo> Jafet, mornfall: but some types are primitive, like cons, for instance
06:09:08 <Jafet> FORTH and brainfuck have no type system. Nearly every other language has a type system, whether you like it or not
06:09:15 <Jafet> Except maybe tcl
06:09:41 <mornfall> Jafet: And bash. ;P
06:09:52 <weirdo> and ircii scripting language :)
06:10:23 <EvilTerran> tcl has a type system... typeOf _ = String
06:10:24 <EvilTerran> :P
06:10:40 <erus`> @src concat
06:10:41 <lambdabot> concat = foldr (++) []
06:10:43 <weirdo> tcl today just fakes these semantics, it's no longer a macro language
06:10:44 <weirdo> :)
06:11:00 <erus`> @src ++
06:11:01 <lambdabot> []     ++ ys = ys
06:11:01 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
06:11:01 <lambdabot> -- OR
06:11:01 <lambdabot> xs ++ ys = foldr (:) ys xs
06:11:16 <dylukes> Jafet: Brainfuck has a type system. It just only has one type, and its always inferred.
06:11:29 <mornfall> dylukes: A "byte"? :)
06:11:35 <dylukes> a "cell", but, yes.
06:11:39 <hatds> decidable type inference!
06:11:44 <qwr> what typesystem awk has?
06:11:50 <Jafet> Kind of like the C byte... must be 8 bits, but may be larger
06:11:51 <dylukes> hatds: I think this is a degenerate case.
06:11:57 <dylukes> Jafet: haha.
06:12:08 <weirdo> hmm, i have to unify '() with (list x) to (list x)
06:12:08 <weirdo> hmm
06:12:37 <Jafet> '() isn't already a list?
06:12:44 <Jafet> They didn't invent #f for nothing.
06:12:53 <erus`> is there a name for prefix ++ ?
06:13:06 <nooodl> (++) :)
06:13:11 <Axman6> prepend?
06:13:19 <weirdo> Jafet, it's "null"
06:13:26 <Axman6> or append, depending on how you look at it
06:13:52 <rwbarton> mappend I suppose
06:13:52 <Jafet> weirdo: the only usage in scheme is as the empty list
06:13:59 <weirdo> Jafet, yes
06:14:06 <nooodl> @src mappend
06:14:06 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:14:55 <rwbarton> @src Monoid
06:14:55 <lambdabot> class Monoid a where
06:14:56 <lambdabot>     mempty  :: a
06:14:56 <lambdabot>     mappend :: a -> a -> a
06:14:56 <lambdabot>     mconcat :: [a] -> a
06:15:06 <Jafet> The rutabaga won. I smashed it up.
06:21:02 <erus`> in haskell main is a value isnt it
06:21:05 <erus`> not a function
06:21:13 <Botje> functions are values too.
06:21:26 <Jafet> It's not a data value, either
06:21:27 <roconnor> is wren on irc?
06:21:34 <erus`> main is not a function, right?
06:21:45 <zygoloid> erus`: that is correct.
06:22:08 <dylukes> main is a value of type IO ___ usually
06:22:22 <dylukes> Can I bring up the "are nullary functions and values the same thing" question again?
06:22:33 <dylukes> Or rather, nullary functions and constant values.
06:22:46 <Jafet> dylukes: do you want to be answered "there are no nullary functions" again?
06:23:03 <dylukes> Jafet: :<
06:23:05 <Jafet> That's what the report says, so it's pretty uncontroversial
06:23:09 <dylukes> Ah, okay.
06:23:13 <Jafet> (Unlike some other things that the report says...)
06:23:29 <dylukes> The report seems more widely reinterpreted and misinterpreted than the Bible...
06:26:29 <zygoloid> if you want to be technically precise, all functions are unary. we can choose to define an n-ary function as the result of applying ((->) t_i) n times. under that definition, all values are 0-ary functions, but not all n-ary functions are functions.
06:26:34 <Jafet> Thou shalt not have polymorphic pattern bindings
06:27:16 <cheater> what n-ary function is not a function?
06:27:29 <zygoloid> () is a 0-ary function under that definition
06:27:45 <cheater> i didn\t get that sorry
06:28:44 <erus`> in one year more people will be using lambdurp than haskell
06:29:48 <erus`> umad haskellers
06:30:14 <erus`> just need to get the interpreter working...
06:31:20 <aninhumer> erus`: okay...
06:32:41 <Peaker> merijn: was away.. if you want C to be GC'd you don't want C :-)
06:33:25 <merijn> Peaker: Exactly! :p
06:33:27 <Peaker> merijn: I like GC-less programming. I think manual mm difficulty is over-rated -- there are some nice techniques that make it easy&manageable and have very little overhead compared to GC or typical malloc/free-all-over-theplace mm code
06:33:40 <mornfall> erus`: what even *is* lambdurp? :)
06:33:54 <mornfall> Peaker: RAII forever.
06:34:09 <erus`> haskell on roofies
06:34:13 <Jafet> Peaker: A WILD CALL/CC APPEARED
06:34:42 <applicative> mornfall, it's *all over* hpaste http://hpaste.org/49883
06:34:42 <mornfall> Jafet: You don't *need* call/cc.
06:34:44 <merijn> Fight, Programing Language, Lambda, Run?
06:34:52 <Peaker> mornfall: And intrusive allocations are awesome
06:34:59 <mornfall> applicative: I have seen 49883.
06:35:21 <applicative> then you know
06:35:23 <ezyang> Peaker: My personal favorite is memory pools, but I was wondering if you had others in mind.
06:35:30 <mornfall> applicative: I actually don't. :-)
06:35:36 <mornfall> Memory pools? Oh dear.
06:35:53 <mornfall> Memory pool abuse is my regular nightmare.
06:35:58 <ezyang> :-(
06:36:12 <applicative> :)
06:36:18 <ezyang> They're OK for pretty specific uses. I think Apache uses them properly.
06:36:45 <Peaker> ezyang: memory pools are nice O(1) alloc/free and almost no metadata overhead.. But one pool per object life-span is good, I see some have lots of pools with objects that have exactly same life-span, because they don't pass allocations as arguments
06:37:27 <mornfall> ezyang: Yes, everything is OK as long as used properly.
06:37:33 <mornfall> Well, mostly.
06:37:35 <ezyang> It's true :-)
06:37:35 <applicative> erus` why does this lambdurp calculus forbid definitions like "compose f g x = f (g x)" or anyway "compose f g = \x -> f (g x))".  why all the lambdas??
06:37:39 <Peaker> also, lots of times people write code that makes a pool and allocates from it, when if they had just taken allocation as argument - it could come from the stack which is even cheaper
06:37:56 <applicative> explicit lambdas are for people who dont know how to type where
06:37:57 <ezyang> :-/
06:38:02 <Peaker> or of course, from a bigger allocation that someone had already paid for
06:38:09 <ezyang> OK, so what did you have mind? :^)
06:38:23 <erus`> applicative: so i dont have to parse function syntax AND anonymous function syntax
06:38:28 <erus`> i only have anonymous
06:38:39 <mornfall> applicative: I suspect it's because someone discovered unicode lambda.
06:39:03 <erus`> mornfall: \ work too ;)
06:39:39 <Peaker> ezyang: In some async programming in C, I have something like:  struct { parallel_thing_data a; union { parallel_thing_data b; and_then c; }.. }.   it's nice to use structs for parallel things, and union for sequential ones -- you can see the sequence in there and there's no allocation overhead (except once for the whole thing, which can be nested in another such struct/union or come from a pool)
06:39:54 <applicative> mornfall, I think we can find a cool unicode equality sign reserved for definitions
06:40:09 <mornfall> applicative: Maybe that'll tip the balance. :D
06:41:23 <mornfall> erus`: You do realize that parser is the simplest part of a compiler, right? (Maybe not for C++, but for almost any language anyway...)
06:41:49 <mornfall> Desugaring definitions is, um, cheap.
06:42:03 <erus`> maybe for a good compiler
06:42:14 <mornfall> It's so dirty cheap that it's almost bad manners to force humans to do it manually.
06:42:14 <erus`> but my shit interpretter is pretty simple
06:43:05 <erus`> also i wanted very simple syntax
06:43:06 <ion> Designing languages for the benefit of parsers resulted in things like C and C++.
06:43:13 <erus`> the whole theme is 'minimal'
06:43:16 <mornfall> ion: You mean LISP don't you?
06:43:31 <mornfall> ion: C++ parser is pretty awkward.
06:43:36 <dainanaki> Indeed.
06:43:46 <ion> mornfall: Lisp has *some* benefits for humans, too.
06:43:52 <applicative> erus` it is only from a parser's point of view that lambdas are more minimal than "compose f g x = f (g x)"
06:44:11 <applicative> erus` bring back Principia notation, *301. p . q .=. ~(~p v ~q)     Df
06:44:31 <byorgey> is haskell.org taking a long time to load for anyone else?  (yes, I already tried downforeveryoneorjustme.com, but I don't trust it)
06:44:33 <Peaker> anonymous lambdas aren't that important.. Python catching so much flaming for requiring names for its lambdas is silly IMO
06:44:40 <applicative> never mind you need a phd to explain it http://plato.stanford.edu/entries/pm-notation/
06:44:59 <applicative> Peaker, I see is that one of the complaints about python lambdas?
06:45:13 <mornfall> Peaker: It's a bit silly, but maybe substantiated because python definition syntax is a bit heavyweight.
06:45:16 <mornfall> Peaker: Compared to where.
06:45:17 <Jafet> applicative: maybe the obvious complaints were too obvious
06:45:35 <applicative> Peaker, does this mean you cant embed lambdas somehow?
06:45:39 <Jafet> Like, python doesn't actually have lambda procedures
06:45:54 <Peaker> applicative: Python lambdas are crippled (expressions only, no statements), but if you name them, they're not crippled
06:46:27 <mokus> byorgey: comes up fine for me
06:46:29 <applicative> Haskell is crippled, there are only expressions, no statements!
06:46:33 <mornfall> Oh. There are statements in python. Too bad. :D
06:46:50 <applicative> heartbreaking, really
06:47:18 <ion> Haskell has things such as let...in... and >>= to make a single expression out of multiple expressions. Python has ; and the line feed. Neither of which can be used in Python’s lambdas.
06:47:25 <mornfall> Peaker: But I can closure over a normal function in Python, right?
06:47:30 <dainanaki> People say, "I just love Python!". I say, "my condolences."
06:47:32 * hackagebot Allure 0.4.1 - Near-future roguelike game in early development  http://hackage.haskell.org/package/Allure-0.4.1 (MikolajKonarski)
06:47:44 <mornfall> (Apart from the fact that it's horribly slow, or something like that.)
06:48:16 * mornfall cabal update && cabal install Allure # :-)
06:48:46 <mornfall> It's been a long time since roguelike.
06:49:11 <Peaker> mornfall: yes, you can, except python's variable scoping has funny rules
06:49:23 <Jafet> I gave up trying to make sense of lambdahack
06:49:37 <Peaker> mornfall: the scope of a variable is determined by whether or not the function you're in has any assignment into it (syntactically, not at runtime)
06:49:41 <kosmikus> Jafet: how sad. Allure is based on lambdahack ...
06:49:57 <Peaker> if you have no assignment, the variable scopes from "outside" (outer function scope lexically, or global). If you have an assignment, it is local
06:50:20 <mornfall> Peaker: Yeah, well, unfortunate. But I don't have to code in it.
06:50:22 <Jafet> crawl was nice. It had an interactive tutorial
06:50:49 <Peaker> so:  def f(x): def g(): print x ;; return g          will work.   But:   def f(x): def g(): print x ; if 0: x=1       (non-used assignment in g's context) will make "x" a local to "g" and not work
06:50:50 <mornfall> Peaker: And I sort of suspect it can't be much worse than C...
06:51:20 <Jafet> The thing about roguelikes is the high degree of symbolism
06:51:46 <Peaker> I think Python's funny rules are actually the best rules you can have without explicit scoping.  Javascript's other possibility (global by default) is simpler and more consistent, but far worse
06:51:58 <Peaker> but of course explicit scoping is cheaper and better
06:52:40 <Peaker> mornfall, applicative: There are statements in Haskell, they're called "do" blocks :)
06:52:56 <Peaker> dainanaki: Python is indeed kind of fun
06:55:08 <kosmikus> Jafet: oh, you mean you gave up understanding how to play it?
06:55:33 <kosmikus> Jafet: when did you try? there's better documentation now. anyway, LambdaHack is only a demo. Allure intends to be a full game sooner or later.
06:55:55 <Jafet> Yeah, it seemed to have no way of effectively extending one's lifespan
06:56:29 <Jafet> So it just demos lighting, moving around, combat?
06:57:15 <kosmikus> Jafet: yes
06:57:24 <Jafet> Ah, I see
06:57:47 <Jafet> In that case, I probably did all there was to be done
06:57:48 <kosmikus> Jafet: I mean, it's playable. But it's not interesting. At least not for more than 10 minutes.
06:57:56 <applicative> Peaker, these 'statements' can be desugared, of course; but maybe that's what we say of statements in, e.g. C too?
06:59:59 <Peaker> applicative: the distinction is syntactic anyway, so syntactically both Haskell and Python have a statement<->expression distinction.. though a do block in its entirety is an expression (and a Python block is not). In C there's an extension that makes a statement block an expression (but with less useful semantics than in Haskell)
07:04:49 <alpounet> is darcsden having an issue ?
07:06:38 <erus`> @type fix
07:06:38 <lambdabot> forall a. (a -> a) -> a
07:06:56 <alpounet> ok, seems to work now
07:07:00 <erus`> > fix (\1 -> 2)
07:07:03 <lambdabot>   mueval-core: Time limit exceeded
07:07:15 <erus`> > fix (\1 -> 1)
07:07:19 <lambdabot>   mueval-core: Time limit exceeded
07:07:26 <Jafet> > fix (\() -> undefined)
07:07:30 <lambdabot>   mueval-core: Time limit exceeded
07:07:48 <Jafet> The function parameter is the fixed point.
07:08:09 <Jafet> You can't use the fix point to compute the fix point
07:08:41 <erus`> > fix ((+) 1)
07:08:44 <erus`> > fix ((+) 1) 0
07:08:45 <lambdabot>   mueval-core: Time limit exceeded
07:08:46 <lambdabot>   *Exception: stack overflow
07:08:50 <dylukes> @src fix
07:08:51 <lambdabot> fix f = let x = f x in x
07:08:53 <jix> > fix (\(~1) -> 1)
07:08:54 <lambdabot>   1
07:08:54 <dylukes> ^^
07:09:00 <Jafet> > fix (\(1:xs) -> (1:1:xs)) [1]
07:09:01 <lambdabot>   Couldn't match expected type `[t1] -> t'
07:09:01 <lambdabot>         against inferred type `[t2]'
07:09:29 <mokus> > fix (1 +) :: Expr
07:09:30 <lambdabot>   1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (1 + (...
07:09:41 <Jafet> > fix ((1:) . (\(1:xs) -> 1:1:xs))
07:09:42 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:09:54 <erus`> what do people use that for?
07:10:24 <Jafet> http://foldl.com
07:10:39 <Jafet> Oops, http://foldr.com
07:11:01 <Jafet> I find it amusing that someone leased two domain names for this
07:11:15 <roconnor> @free trans :: (F a -> a) -> (G a -> a)
07:11:15 <lambdabot> f . g = h . $map_F f => f . trans g = trans h . $map_G f
07:12:31 * hackagebot bifunctors 0.1.1.3 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-0.1.1.3 (EdwardKmett)
07:13:06 <mornfall> Oh, not fix again. :D
07:13:50 <mornfall> It's turning into a daily diversion, lately.
07:14:13 <tsuraan> is there some trick to get haskell's case statement to match on variables rather than masking them?  i.e. I have x defined a 7, and I want to do "case y of 0 -> A; x -> B; _ -> C" and have the "x" term match only when y == x
07:14:33 <mornfall> tsuraan: No, you can't.
07:14:33 <roconnor> > runWriter (mfix (\x -> tell [7] >> return (1:x))
07:14:34 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:14:39 <roconnor> > runWriter (mfix (\x -> tell [7] >> return (1:x)))
07:14:40 <lambdabot>   ([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:14:41 <Eelis> tsuraan: i, too, really really miss such functionality
07:14:49 <Saizan> use ==
07:14:57 <mornfall> Yeah, use guards and equality.
07:15:16 <Saizan> case y of 0 -> A; y | y == x -> B; _ -> C
07:15:25 <tsuraan> oh, cool
07:15:39 <tsuraan> that's better than nested "if" statements, anyhow :)
07:15:47 <mornfall> tsuraan: Everything is. :-)
07:16:16 <roconnor> FWIW, I almost never use case statements and perfer to write a helper function in the where clause.
07:16:34 <mornfall> I am ambivalent.
07:16:35 <tsuraan> yeah, I tend to use helpers with matches a lot, but sometimes I feel like I'm going overboard
07:17:04 * roconnor didn't realize there was an acid rain theorem.
07:17:16 <tsuraan> although in this case, the case/guard can't really be replaced by a helper, can it?
07:17:28 <mornfall> tsuraan: You can use guards in definitions.
07:17:47 <mornfall> foo x | x == y = X
07:18:31 <mornfall> Or foo x | EQ <- x `compare` y = ... :-)
07:18:42 <tsuraan> is it possible to put a where statement inside the body of a function so you can capture the "y" value?
07:18:54 <roconnor> mornfall: that requires pattern guards?
07:18:57 <mornfall> tsuraan: let
07:19:03 <mornfall> roconnor: Oh, it does indeed.
07:19:18 <Eelis> and here's a nice horrible way to do it with view patterns:  case 3 of { ((== 3) -> True) -> 9; x -> x*2}
07:19:19 <mornfall> But pattern guards are teh cool.
07:19:35 <roconnor> tsuraan: the where clause will capture the parameters to the function but nothing else.
07:20:03 <roconnor> mornfall: I've never looked at pattern gaurds, only view patterns.
07:20:30 <tsuraan> mornfall: yeah, let would do it :)
07:20:40 <tsuraan> rconnor: that's what I thought
07:20:51 <mornfall> But you can nest where clauses, too.
07:20:55 <roconnor> yes
07:21:06 <mornfall> Although it does look a bit silly IMHO.
07:21:23 <roconnor> it's fairly common to nest where clauses
07:21:42 <mornfall> I find it awkward to read.
07:22:31 <roconnor> I guess you sould lay out your code in the way that is as readable as possible while still maintaining the efficency you require.
07:23:20 <mornfall> I also find that for different people, different traits make code more/less readable.
07:24:51 <mornfall> I want kind overloading. :(
07:27:36 <Jafet> Overloading is rarely kind
07:28:35 <parcs> pattern guards are haskell2010
07:33:00 <roconnor> parcs: what about view patterns?
07:33:56 <Entroacceptor> why is there no Data.Tree.Zipper.map?
07:34:52 <parcs> roconnor: extension
07:38:51 <wjlroe> When you define dependencies in your .cabal file - how to you get cabal to install those dependencies?
07:39:10 <wjlroe> configure just returns something useless: "At least the following dependencies are missing:"
07:39:11 <dschoepe> wjlroe: "cabal install" in the same directory
07:39:23 <byorgey> Entroacceptor: good question, you should send a patch.  In the meantime a few standalone deriving instances ought to do the trick: deriving instance Functor {Full, Empty, TreePos t}
07:39:24 <wjlroe> ah
07:39:58 <parcs> cabal install --only-dependencies
07:40:10 <Entroacceptor> byorgey: ok, thanks
07:40:11 <wjlroe> parcs: that's the ticket! thanks
07:40:19 <wjlroe> dschoepe: thanks
07:44:17 <nda> @pl \(a,b) (c,d) -> (a*c, b+d)
07:44:17 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (*))
07:44:33 <nda> hmmm, not what i had in mind
07:45:18 <copumpkin> :t uncurry (***) . ((*) *** (+))
07:45:19 <lambdabot> forall c c'. (Num c, Num c') => (c, c') -> (c, c') -> (c, c')
07:45:40 <copumpkin> > (uncurry (***) . ((*) *** (+))) (5,6) (7,8)
07:45:41 <lambdabot>   (35,14)
07:45:57 <identity_> nda: you sure that's not what you had in mind? heh
07:45:57 <nda> looks _way_ better
07:46:13 <Axman6> i prefer your original
07:46:26 <Axman6> clarite > wankiness
07:46:29 <nda> yes, i actually forgot to uncurry (***)
07:46:45 * copumpkin prefers great wankiness, obviously
07:46:45 <roconnor> @type (*) *** (+)
07:46:46 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
07:47:46 <copumpkin> Axman6: I'd prefer the original if not for that fucking backslash
07:47:47 <roconnor> @type (uncurry (*) *** uncurry (+))
07:47:48 <lambdabot> forall a a1. (Num a, Num a1) => ((a, a), (a1, a1)) -> (a, a1)
07:48:05 <roconnor> > (uncurry (*) *** uncurry (+)) (5,6) (7,8)
07:48:06 <lambdabot>   Couldn't match expected type `t1 -> t'
07:48:06 <lambdabot>         against inferred type `(a, a...
07:48:08 <Axman6> heh
07:48:10 <copumpkin> you need to uncurry it again
07:48:11 <roconnor> damn
07:48:18 <copumpkin> :t uncurry (uncurry (*) *** uncurry (+))
07:48:19 <lambdabot>     Couldn't match expected type `b -> c'
07:48:19 <lambdabot>            against inferred type `(a, a1)'
07:48:19 <lambdabot>     In the first argument of `uncurry', namely
07:48:20 <roconnor> > curry (uncurry (*) *** uncurry (+)) (5,6) (7,8)
07:48:21 <lambdabot>   (30,15)
07:48:22 <copumpkin> oh wait
07:48:26 <copumpkin> yeah :)
07:48:39 <roconnor> ... I got a different answer :/
07:48:52 <nda> i think in this case the latter can be preferred, since in math you would say "plus in the first, times in the second component" instead of describing how these functions are applied to actual pairs
07:48:53 <copumpkin> yeah, yours is doing it pairwise the other way
07:48:56 <roconnor> bah, mine is all wrong
07:49:38 <copumpkin> @let transpose' = uncurry (***) . ((,) *** (,))
07:49:39 <lambdabot>  Defined.
07:49:44 <copumpkin> > transpose' (1,2) (3,4)
07:49:46 <lambdabot>   ((1,3),(2,4))
07:50:28 <copumpkin> > transpose'' ((1,2),(3,4))
07:50:30 <lambdabot>   ((1,3),(2,4))
07:50:35 <copumpkin> there we go
07:51:04 <dolio> @type curry . ((***) `on` uncurry)
07:51:05 <lambdabot>     Couldn't match expected type `(a, b)'
07:51:05 <lambdabot>            against inferred type `a1 -> b1 -> c'
07:51:05 <lambdabot>     In the second argument of `on', namely `uncurry'
07:51:25 <dolio> @type (curry .) . ((***) `on` uncurry)
07:51:26 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b -> c) -> (a, b) -> (a, b) -> (c, c)
07:56:02 <dolio> :t (.:)
07:56:03 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
07:56:16 <dolio> :t curry .: (***) `on` uncurry
07:56:17 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b -> c) -> (a, b) -> (a, b) -> (c, c)
07:56:58 <roconnor> I'm currently reading "Fusion of recursive programs with computational effect and so far the introduction has a beautiful introduction to a catagorical view of folds, unfolds, hylomorphism and monads. ... either that or I just happen to be primed to read this stuff now.
07:58:10 <roconnor> who knew that good papers on functional programming come from Uruguay?
07:58:54 <nda> is (.:) defined somewhere beyond the fgl (functional graph library)?
07:59:11 <dolio> It's probably just defined in lambdabot.
07:59:28 * roconnor didn't know that in a CCC thre is a one-to-one correspondence between strengths and enrichments of functors.
08:00:56 <Axman6> would there be a way using type classes to implement a function which could any arbitrary nesting of functors and apply the given function to the innermost a?
08:01:27 <dolio> I think that's been done before, yes.
08:01:27 <Axman6> i guess you just need instance (Functor f, Functor g) => Functor uh... hmm
08:01:31 <roconnor> Axman6: only by turning on dangrous typeclass extensions.
08:02:00 <Axman6> i was going to say Functor f (g a) but that of course doesn't work
08:02:14 <roconnor> Axman6: ... => Functor (Compose f g)
08:02:22 <Axman6> yeah
08:02:32 <roconnor> @hoogle compose
08:02:32 <lambdabot> No results found
08:02:37 <roconnor> @hoogle Compose
08:02:37 <lambdabot> No results found
08:02:39 <Axman6> type Compose f g a = f (g a)?
08:02:49 <roconnor> Axman6: well, normally it is a new type
08:02:57 <copumpkin> it has to be
08:03:11 <Axman6> how come?
08:03:18 <copumpkin> you're partially applying it
08:03:21 <copumpkin> for the functor instance
08:03:48 <Axman6> why is that a problem?
08:03:53 <roconnor> copumpkin: why do type synynoms need to be fully applied?
08:04:15 <Axman6> seems like an odd, and annoying restriction
08:04:25 <roconnor> Axman6: would need to turn on type synonym instances for that to work (one of the dangerous extensions)
08:04:41 <Axman6> yeah, i'd realised that
08:05:24 <dolio> Type synonym instances isn't dangerous.
08:05:32 <roconnor> Axman6: it works "fine" with newtypes, but you end up with a lot of wrapping and upwrapping.
08:05:56 <rwbarton> it's maybe slightly "dangerous" if you don't understand what it does
08:06:14 <roconnor> dolio: isn't it dangrous when chaning the type signature to an equivalent one changes the behavour of your function?
08:06:19 <roconnor> *changing
08:06:27 <c_wraith> the worst thing it could do is convince you you also want OverlappingInstances, which is more dangerous
08:06:45 <dolio> roconnor: That isn't what type synonym instances do.
08:06:56 <roconnor> hence they are dangerous =D
08:07:01 <dolio> They just let you write 'instance C String' instead of 'instance C [Char]'.
08:07:13 <c_wraith> except that String is a special case, IIRC
08:07:18 <roconnor> I guess you are the type of person who says goto isn't dangerous if you know what it does.
08:07:44 <roconnor> dolio: oh, is that all it does?
08:07:46 <roconnor> okay
08:07:47 <dolio> They don't allow you to have instances for both.
08:07:47 <c_wraith> No, type synonym instances aren't dangerous, unless they make you turn on more extensions
08:08:10 <c_wraith> So the worst danger is that you'll also turn on OverlappingInstances because of error messages
08:08:11 <roconnor> then Axman6 needs more powerful type class magic.
08:08:23 <dolio> Anyhow, type synonyms are essentially arbitrary type functions.
08:08:28 <rwbarton> you just need a newtype
08:08:34 <Axman6> omg haskell's type system sux, itz so primitive lolz
08:08:36 <dolio> Which is why they're required to be fully applied.
08:08:54 <dolio> If they were first-class, you'd have arbitrary functions floating around at the type level.
08:09:00 <roconnor> Axman6: anyhow Compose is defined in Applicative or transformers or both
08:09:09 <dolio> As is, they can just be removed by a preprocessing phase.
08:09:10 <rwbarton> there's no way that type inference can ever figure out that you want fmap :: (a -> b) -> f (g a) -> f (g b) to use the "\t. f (g t)" instance of Functor
08:09:55 <dolio> Having arbitrary first-class type functions kind of ruins inference.
08:10:02 <roconnor> http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Control-Applicative.html#t:Const
08:10:05 <roconnor> opps
08:10:20 <rwbarton> Probably you can do something like that with some kind of deepFmap function/class, if that's what you meant, yeah
08:10:30 <dolio> Does Int unify with f Char? Yes. type F a = Char.
08:10:48 <dolio> Er, type F a = Int
08:11:15 <roconnor> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Data-Functor-Compose.html
08:11:54 <c_wraith> dolio: don't type families get you close to that?
08:12:14 <c_wraith> I mean, F could be a type function
08:12:14 <Axman6> what's a good example of something that looks like it could be a monad, but isn't?
08:12:17 <dolio> Type families have the same restrictions as type aliases. You can't partially apply them.
08:12:24 <dolio> And they're not first-class types.
08:13:16 <Axman6> i was thinking that something like data F a = F might be an example, but that can be implemented pretty trivially: instance Monad f where return _ = F; _ >>= f = f undefined
08:13:56 <c_wraith> Axman6: something that beginners often try to implement is a type that counts the number of binds.  You can implement return and (>>=), but what you get isn't a monad.
08:14:07 <dolio> Axman6: Not a monad.
08:14:16 <Axman6> beginners? I did that like three weeks ago :(
08:14:22 <dolio> undefined >>= return = F /= undefined
08:14:33 <rwbarton> the ZipList applicative functor, perhaps
08:14:46 <rwbarton> it fails for a pretty subtle reason
08:15:10 <roconnor> dolio: oh come one; monads laws are only applicable to total values.  If you are going to bring partial values into the mix then half of our monads are not monads.
08:15:21 <Axman6> dolio: i don't see what law requires that that isn't a monad
08:15:34 <dolio> roconnor: He used a partial value to define the monad.
08:15:53 <roconnor> dolio: I know.
08:16:02 <c_wraith> You can define that monad without partial values.
08:16:02 <roconnor> Axman6: the proper definiton of bind is _ >>= _ = F
08:16:19 <roconnor> Axman6: your F a is equivalent to the Reader Void monad.
08:16:59 <roconnor> ... I think
08:17:17 <dolio> Seems like it should be.
08:17:47 <roconnor> > 0^0
08:17:48 <lambdabot>   1
08:17:51 <roconnor> ah right
08:17:52 <Axman6> well, while you all figure that out, i'm going to bed. need to beat off this bronchitis somehow :(
08:18:03 <roconnor> F is equivalent to Reader Void
08:18:25 <dolio> If you did F >>= f = F, then undefined >>= return = undefined.
08:19:02 * Axman6 names this the Fail monad... because it's pretty fail >_>
08:19:11 <dolio> However, return x >>= f = f x is still a problem, unfortunately, if you take bottoms into account.
08:19:14 <roconnor> If I do F >>= f = F, then undefined >>= return = F.
08:19:25 <roconnor> oh
08:19:28 <roconnor> sorry I see
08:19:38 <dolio> Yeah, it's a match.
08:19:38 <roconnor> ya, you can make bind strict
08:20:12 <mokus> roconnor: wouldn't Reader Void be equivalent to Identity?
08:20:14 * roconnor never takes bottoms into account; reasons fast and loose.
08:20:25 <mokus> roconnor: with runReader undefined =~ runIdentity
08:20:27 <roconnor> mokus: nope.  Reader () is equivalent to Identity.
08:20:28 <c_wraith> yeah, Reader Void is not what this is.
08:20:35 <mornfall> It's bit of a nuisance to rebuild all of your .cabal every minor GHC upgrade. :|
08:20:53 <Axman6> mornfall: indeed
08:21:29 <mokus> roconnor: because runReader undefined (return 1) is 1, even in Reader Void - but there can never be any runF such that runF (return x) == x
08:21:40 <erus`> roconnor: did you buy that paper?
08:21:46 <roconnor> erus`: yes
08:22:57 <roconnor> mokus: when you runReader on partial values anything the resulting behaviour is unspecified.
08:23:05 <erus`> $40 wtf
08:23:09 <roconnor> mokus: when you runReader on partial values the resulting behaviour is unspecified.
08:23:18 <erus`> $40 for some 1s and 0s
08:23:40 <mornfall> erus`: The right 1s and 0s are worth billions. :-)
08:23:41 <roconnor> erus`: oh I thought you were asking if I bought into the concept of fast and loose reasoning.
08:24:05 <mornfall> Paper, which paper? :)
08:25:09 <roconnor> mokus: The Fact is that Reader Void a ~~ Void -> a ~~ ()  and Reader () a ~~ () -> a ~~ a when we restrict our attention to total values (which is what most people normally do).
08:26:28 <mornfall> Void is a really funny type.
08:27:02 <mornfall> (And GHC 7.0.4 *still* spews half a million SpecConstr messages...)
08:34:15 <roconnor> mornfall: this paper: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.59.8232
08:34:15 <weirdo> Jafet, one more thing, i only define a type system for primitive types, so notion of non-nominative type system doesn't make much sense
08:34:19 <weirdo> *shrug*
08:34:27 <weirdo> everything else will get a 'record type
08:56:41 <Entroacceptor> damn, I didn't want fmap, I wanted tree-walk
09:00:41 <djahandarie> copumpkin, so I guess that you guys decided to not do Boston Haskell today
09:03:43 <danharaj> does anyone know how to type unicode characters on win7 from a plain old keyboard?
09:06:37 <erasmas> I know you can access different ascii characters by pressing numbers while holding the alt key (like alt-1061). I think there's something similar for unicode
09:11:01 <copumpkin> djahandarie: one might assume that!
09:12:31 * hackagebot pastis 0.1 - Interface to the past.is URL shortening service  http://hackage.haskell.org/package/pastis-0.1 (AlpMestanogullari)
09:16:46 <DukeDave> Can anyone suggest why cabal install might not grab the latest version of something on hackage? I've done a cabal update since it was put up..
09:19:43 <benmachine> DukeDave: is it parsec or quickcheck?
09:20:02 <Peaker> Does anyone else find Debug.Trace severely lacking?  I always end up using:  traceId prefix x = trace (prefix ++ show x) x     and  traceIdVia  that lets me pre-process a value before showing it
09:20:27 <Jafet> You want a utility library for trace??
09:20:47 <Peaker> Jafet: Well, I keep repeating the 3-5 lines of trace definitions, surely everyone who uses trace would want them :)
09:21:01 <Peaker> traceAround f = traceId "after = " . f . traceId "before = "      (with a string arg and more strings for uniqueness there)
09:21:20 <Jafet> Okay then, upload them!
09:21:32 <Jafet> You should read that ! as !!1
09:21:35 <sm__> yes, everybody is reinventing those. There are some in the error-location lib
09:21:36 <benmachine> I don't find debug.trace severely lacking on account of how I don't ever read it :P
09:21:42 <benmachine> er use
09:22:10 <Peaker> if it's a hackage dependency, it would be very annoying to add to an existing project (need to add the dep and remember to remove it later)
09:22:27 <Peaker> benmachine: sometimes I find it is the most cost-effective way of debugging (yes, debugging is rare but it happens)
09:22:31 * hackagebot cabal2nix 1.0 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.0 (PeterSimons)
09:22:32 <benmachine> :)
09:22:33 * hackagebot cabal2nix 1.1 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.1 (PeterSimons)
09:22:41 <DukeDave> benmachine: cabal: There is no available version of AC-Vector that satisfies ==2.4.0
09:22:41 <DukeDave> Despite: http://hackage.haskell.org/package/AC-Vector-Fancy-2.4.0
09:22:58 <Peaker> Jafet: how do people install it such that it is available without any dep spec?
09:23:03 * sm__ debugs with trace all the time
09:23:11 <benmachine> DukeDave: AC-Vector /= AC-Vector-Fancy?
09:23:24 <Jafet> Surely it depends on base?
09:23:51 <benmachine> Peaker: don't, just add the dep and get rid of it and cope with the intense suffering involved :P
09:23:56 <benmachine> alternatively, inline the package
09:23:58 <DukeDave> benmachine: Yes, you're right, I'm being a tool :D
09:24:05 <Peaker> Jafet: Yes, I mean if someone wants to use it in his cabal package, it would be annoying to edit .cabal for that
09:24:21 <Jafet> Hence the !!1
09:24:42 <Peaker> benmachine: I guess inlining the TraceUtils file should be easy, but only if it doesn't have a "Debug." prefix in the module name
09:24:52 <Peaker> unless copying the functions directly
09:25:19 <benmachine> Peaker: I'm confused, what's the problem with a Debug. prefix?
09:26:40 <Peaker> benmachine: if you throw the module alongside your modules, you're going to need to put it in a Debug subdir
09:26:50 <Peaker> I'll stop complaining about this trivialities :-)
09:26:55 <Peaker> these*
09:27:19 <benmachine> if it's in a subdir it's easier to bin when you don't need it anymore :)
09:37:32 * hackagebot cabal2nix 1.2 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.2 (PeterSimons)
09:42:17 <Entroacceptor> ooh, nice
09:42:24 <Entroacceptor> (cabal2nix)
09:45:00 * roconnor wonders how cabal2nix compares to hack-nix
09:55:33 <sm__> chris forno, are you here ? http://jekor.com/ is nice
09:57:35 * hackagebot TraceUtils 0.1 - Functions that should have been in Debug.Trace  http://hackage.haskell.org/package/TraceUtils-0.1 (EyalLotem)
10:00:29 <Peaker> benmachine, Jafet, sm__: TraceUtils is on Hackage!!11!!
10:01:17 <Jafet> einseinself
10:01:21 <benmachine> Peaker: aaaawesome
10:04:43 <dolio> Heh. How can you be sure you'll be compatible with base-9!?
10:05:26 <benmachine> that is an outrageous claim
10:05:33 <benmachine> base < 5 is bad enough >:[
10:05:35 <Peaker> dolio: who cares? :-)
10:05:45 <Peaker> I saw that in augustuss's packages :)
10:05:54 <Peaker> if it's good enough for augustuss, it's good enough for me..
10:07:02 <dolio> We could use a slightly better versioning system than we have right now.
10:07:27 <Peaker> http://hackage.haskell.org/package/uglymemo  only has base < 10
10:07:35 <Peaker> and unspecified contains version constraints
10:07:42 <Peaker> container*
10:08:16 <Peaker> I actually think the version constraints in hackage are doing more harm than good atm.. but then I prefer false positives (ghc build error) to false negatives (cabal refusing to build something or using old versions unnecessarily)
10:08:41 <Peaker> I can debug ghc build errors more easily -- and the successful result is a better one (use of more up-to-date packages)
10:09:03 <dolio> I think the version constraints are a significant cause of the recent edwardk storms.
10:09:08 <danharaj> for the love of god tell me haskell.org isn't down.
10:09:33 <Peaker> http://www.downforeveryoneorjustme.com/haskell.org
10:09:42 <Peaker> dolio: what storms?
10:09:44 <sm__> Peaker: cool. Is getting these into base out of the question ?
10:10:19 <Peaker> sm__: I have no idea..  my Synopsis/description are "functions that should have been in Debug.Trace"
10:10:34 <benmachine> there's a library proposals process
10:10:39 <benmachine> I've never actually worked out what it is though
10:10:39 <dolio> Peaker: I think twice in the last week he's released about 30 packages mostly with minor version bumps triggered by one or two real changes.
10:10:50 <dolio> And hackagebot reports all of them in here.
10:10:54 <Peaker> How long until Hackage has the generated haddock?
10:10:54 <sm__> checking them out now. Here are mine: http://joyful.com/darcsden/simon/hledger/browse/hledger-lib/Hledger/Utils.hs#L-302
10:11:38 <alpounet> Peaker, 12 hours max iirc
10:11:41 <fragamus> does anyone know how to poke Cale about RandT?
10:11:49 <Peaker> dolio: ah.  IMO we just need to have import/export module signatures.. they can be explicit if it's undecidable to generate them.  For TH packages (rare?) we can keep the version deps.  We can have "virtual" things in the signatures to represent bug fixes we depend on
10:12:00 <Peaker> alpounet: thanks
10:12:31 <Peaker> dolio: then cabal-install needs to match up the signatures -- allowing different implementations if they implement the proper export signature
10:12:42 <alpounet> Peaker, if i remember well hackage builds the doc twice a day
10:13:12 <sm__> Peaker: and here are gweber's (fyi): https://github.com/gregwebs/FileLocation.hs/blob/master/Debug/FileLocation.hs
10:14:04 <Peaker> sm__: maybe I ought to incorporate some of these too...
10:14:18 <Peaker> then again, it's on https://github.com/peaker/TraceUtils so anyone can send a pull request :)
10:14:37 <alpounet> using cabal's data-files field isn't that easy
10:14:38 <alpounet> phew.
10:15:24 <Peaker> hmm.. my prefix strings ought to always add the ": " probably...
10:15:41 * sm__ runs a cable between Peaker and gweber and steps back
10:17:35 * hackagebot TraceUtils 0.1.0.1 - Functions that should have been in Debug.Trace  http://hackage.haskell.org/package/TraceUtils-0.1.0.1 (EyalLotem)
10:39:10 <knoc> hi all, who can I lookup the hex-value of an ascii-char?
10:40:00 <bscarlet> look in Data.Char
10:40:10 <copumpkin> > ord 'a'
10:40:11 <lambdabot>   97
10:40:16 <copumpkin> there :)
10:40:18 <looopy> hmm so will haskell ever expand past the world of academia?
10:40:25 <copumpkin> looopy: it has
10:40:42 <looopy> oh???
10:40:57 <copumpkin> most of us are not academics
10:41:03 <looopy> i like it more so than erlang…i'm still on the hunt for cool things o_O;
10:41:09 <copumpkin> a few companies use it exclusively
10:41:16 <looopy> hmm, i see your point =P
10:41:17 <copumpkin> most of us enjoy using it for most of our personal projects
10:41:24 <looopy> like?
10:41:40 <copumpkin> I think the main barrier to more people adopting it is people assuming that people haven't adopted it
10:42:16 <bscarlet> (64-Bit windows support wouldn't hurt, though)
10:42:34 * hackagebot streamproc 1.4 - Stream Processer Arrow  http://hackage.haskell.org/package/streamproc-1.4 (PeterSimons)
10:43:03 <knoc> copumpkin: is there some simple function to show an int as hex value (for ascii chars)
10:43:24 <knoc> sth. like toHex $ ord 'c'
10:43:41 <sm__> haskell totally failed to stay within academia quite some time ago
10:44:16 <looopy> yeah i'll admit i like it more than erlang…after doing a few chapters on each
10:45:05 <looopy> i understand erlangs syntax but it doesn't feel right to me.  so
10:48:47 <bscarlet> knoc: look in Numeric at showHex
10:49:49 <knoc> bscarlet: ok, I build that myself^^ displayHex int = showIntAtBase 16 intToDigit int ""
10:51:35 <knoc> if I have some chars like: '8b', how can I map that to an ascii character?
10:52:41 <copumpkin> > let (f :: String -> Integer) = read . ("0x" ++) in f "8b"
10:52:42 <lambdabot>   139
10:52:58 <copumpkin> > let f = chr . read . ("0x" ++) in f "8b"
10:52:59 <lambdabot>   '\139'
10:53:06 <copumpkin> > let f = chr . read . ("0x" ++) in f "5a"
10:53:08 <lambdabot>   'Z'
10:53:16 <knoc> ok
10:53:34 <knoc> if I want to represent hex values, i begin with 0x
10:53:47 <knoc> cool thanks ;)
10:53:55 <copumpkin> np
10:54:22 <bscarlet> > let f = chr . fst . head . readHex in f "5a"
10:54:23 <lambdabot>   Ambiguous occurrence `fst'
10:54:23 <lambdabot>  It could refer to either `L.fst', defined at <l...
10:55:28 <CindyLinz> lambdabot: @hoogle sort
10:55:28 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
10:55:29 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
10:55:29 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
10:55:54 <bscarlet> how did fst get overloaded in lambdabot, and can it be undone?
10:56:52 <bscarlet> > let fst = \(a,_) -> a, f = chr . fst . head . readHex in f "5a"
10:56:53 <lambdabot>   <no location info>: parse error on input `,'
10:56:55 <companion_cube> > Prelude.fst (1,2)
10:56:56 <lambdabot>   1
10:57:06 <merijn> bscarlet: Lambdabot is full with filthy, dirty lies
10:57:22 <merijn> :t (.)
10:57:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:57:27 <merijn> :t (Prelude..)
10:57:28 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:57:29 <parcs> :t fst
10:57:30 <lambdabot>     Ambiguous occurrence `fst'
10:57:30 <lambdabot>     It could refer to either `L.fst', defined at <local>:2:0
10:57:30 <lambdabot>                           or `Data.Tuple.fst', imported from Data.Tuple
10:57:32 <bscarlet> let f = char . Prelude.fst . head . readHex in f "5a"
10:57:37 <parcs> @undefine
10:57:39 <parcs> :t fst
10:57:40 <lambdabot> forall a b. (a, b) -> a
10:57:52 <bscarlet> > let f = char . Prelude.fst . head . readHex in f "5a"
10:57:53 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
10:57:54 <lambdabot>    arising from a use of `Nume...
10:58:28 <dainanaki_> Does anyone know of command-line argument processing libraries besides cmdargs?
10:59:18 <bscarlet> pttth. What'd I do this time?
11:00:01 <merijn> :t readHex
11:00:02 <lambdabot> forall a. (Num a) => String -> [(a, String)]
11:00:03 <bscarlet> oh
11:00:15 <bscarlet> let f = chr . fst . head . readHex in f "5a"
11:00:16 <merijn> :t char
11:00:17 <lambdabot> Char -> Doc
11:00:21 <micahjohnston> :k a
11:00:22 <lambdabot> Not in scope: type variable `a'
11:00:26 <micahjohnston> :k Integer
11:00:27 <lambdabot> *
11:00:28 <bscarlet> > let f = chr . fst . head . readHex in f "5a"
11:00:30 <lambdabot>   'Z'
11:00:32 <micahjohnston> :k Show
11:00:32 <lambdabot>     Class `Show' used as a type
11:00:33 <lambdabot>     In the type `Show'
11:06:28 <zzo38> What is the command to retrieve the value stored in the monad?
11:07:57 <merijn> zzo38: What do you mean?
11:08:12 <merijn> It depends on the monad...some monads don't have anyway to get values out
11:08:19 <merijn> s/anyway/any way
11:08:54 <micahjohnston> zzo38: if it's a comonad, extract
11:09:05 <micahjohnston> zzo38: otherwise, it's specific to the type
11:09:26 <micahjohnston> zzo38: it would defeat the purpose of the IO type to have that function for it, so there isn't one for IO
11:09:32 <zzo38> How do you  Q Info -> Info
11:09:56 <merijn> zzo38: Like I just said, it depends on what Q is
11:10:11 <merijn> For example "IO a -> a" is impossible
11:10:16 <zzo38> merijn: It is the Template Haskell
11:12:10 <zzo38> I mean the "Q Info" for the Template Haskell.
11:12:29 <doserj> there is no function that does Q a -> a
11:13:50 <zzo38> Why isn't there such a thing? How do you do work-around?
11:14:36 <pumpkin> instead of taking things out to work on them
11:14:39 <pumpkin> you put the things doing the work in
11:14:55 <elliotstern> How does ghc actually implement IO?
11:15:08 <zzo38> OK.
11:15:29 <zzo38> I am a bit confuse can you tell me what command does that?
11:15:42 <imc> elliotstern: black magic
11:15:49 <zzo38> Maybe, Haskell is a bit confuse
11:15:53 <hatds> zzo38: I've never used reify in TH, I think most people access it inside the Q monad to build up their TH expressions
11:16:16 <hatds> zz038: but if you turn the 'a' into an Exp, you can splice it into a variable.
11:16:39 <thoughtpolice> elliotstern: IO is basically a just a data type that is only used to make actions in IO 'sequential' as we would expect. the actual implementation is tied to GHC (in particular, almost all of the data types are magically 'erased' entirely at runtime)
11:16:40 <hatds> zz038: whoops 'a' = 'Info'
11:16:43 <thoughtpolice> elliotstern: http://www.haskell.org/haskellwiki/IO_inside
11:17:13 <elliotstern> Right, I understand the IO = RealWorld -> a thing
11:17:16 <thoughtpolice> ^^ that has a pretty good formulation of how IO works, and has a formulation pretty similar to GHC. look at section 3
11:17:22 <thoughtpolice> ah, ok
11:18:42 <thoughtpolice> elliotstern: technically in this case, then, the GHC formulation is surprisingly similar to that (only you have things called RealWorld# and State# etc to pass around the 'world' parameters.) it pretty much all goes away at runtime, the IO data constructor is rather special in that way
11:18:47 <pumpkin> the RealWorld thing isn't necessarily a good way of thinking about it, but works fine for implementing it
11:18:54 <conal> oh, oik :(. That IO_inside page perpetuates the (bogus) myth that IO a = RealWorld -> (a,RealWorld) . (section 3)
11:19:13 <pumpkin> it isn't a myth :P it's how it works, but isn't a good way for people to conceptualize it
11:19:13 <elliotstern> In Imperative Functional Programming, they have a generic ccall function to call c functions, and there's something about the IO monad being isomorphic to a continuation based approach
11:19:22 <pumpkin> it's just an implementation detail
11:20:10 <copumpkin> having said that, the wiki page is a little iffy
11:20:12 <conal> i hope there's a later section saying that section 3 is a lie.
11:20:49 <merijn> I dunno, I think that explanation helped my understanding
11:20:50 <monochrom> RealWorld# -> (# a, RealWorld# #) is not even an implementation. it is a trick. a trick to fool the compiler into not re-ordering generated code
11:21:02 <copumpkin> yeah, I'd call that an implementation detail
11:21:21 <elliotstern> If I wanted to implement the IO  Monad in a toy call-by-need interpreter, are there any papers I should read?
11:21:35 <copumpkin> elliotstern: read edwardk's blog posts
11:21:47 <conal> and that definition has to be violated in order to implement interaction and concurrency.
11:22:09 <copumpkin> elliotstern: http://comonad.com/reader/2011/free-monads-for-less/
11:22:34 <zzo38> OK, I figured it out.
11:22:41 <zzo38> I figured out how to do it.
11:24:44 <conal> elliotstern: so i hope you don't believe what you read on that IO wiki page .
11:25:54 <ddarius> copumpkin: GHC isn't the only implementation.
11:26:04 <merijn> I like how I always see people complain about the RealWorld -> (a, RealWorld) explanation but none of them can apparently be bothered to write a better one :p
11:26:07 <zzo38> Can you please tell me what "VarI a_1627393677 (VarT t_1946157056) Nothing (Fixity 9 InfixL)" means?
11:26:09 <copumpkin> ddarius: so?
11:27:07 <elliotstern> I take it with a large grain of salt, yes
11:27:08 <ddarius> merijn: Plenty of people have described other ones.  The two most popular being a continuations based on and a data structure oriented one.
11:27:35 <merijn> The data structure one being the "monads are trees with grafting" thing?
11:27:36 <conal> merijn: cant-be-bothered is probably missing the boat. it's extremely unlikely that there is *any* valid denotational/functional explanation. and by design (of IO). see http://conal.net/blog/posts/notions-of-purity-in-haskell/#comment-22829
11:27:59 <dolio> hbc didn't even use World -> (a, World), from what I've heard.
11:28:09 <dolio> I.E. the first Haskell compiler.
11:28:20 <ddarius> It used a continuations based approach.
11:28:34 <ddarius> As does Hugs.
11:28:52 <dolio> I suppose that isn't surprising since it probably predates the introduction of monads.
11:29:01 <hatds> zzo38: you'll have to check the API http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.5.0.0/Language-Haskell-TH.html#t:Info (or, in this case the source code)
11:29:28 <ddarius> dolio: These are the implementations of the IO monad.
11:29:59 <hatds> looking like a_nnn is the variable name (after renaming), t_nnn is it's type and TH can't describe it's declaration location
11:30:08 <elliotstern> dolio:  Moggi's paper on Monads was in '91
11:30:14 <dolio> Right, but why would you rewrite the whole I/O system to be World -> (a, World) just because IO was introduced?
11:30:39 <ddarius> GHC isn't much younger than HBC and is older than Hugs.
11:31:15 <dolio> elliotstern: Moggi's paper didn't introduce monads to Haskell.
11:31:51 <elliotstern> True, but it introduced monads as a useful computer science idea
11:32:09 <zzo38> OK, I looked, it seems the "Nothing" in here is supposed to be a declaration except that it is missing. Maybe it is because a function is not allowed to access its *own* declaration, I guess.
11:33:03 <dolio> Anyhow, I guess GHC probably had to be rewritten from something other than world passing at some point.
11:33:05 <elliotstern> Imperative Functional Programming is from '92, so it's not like monads were introduced that much later
11:33:05 <dolio> So, point taken.
11:33:32 <monochrom> see Andrew Gordon's phd thesis. if you already have continuation-based I/O, you can just slap a monadic api on it
11:33:39 <conal> merijn: the "awkward squad" paper gives some explanations of IO. one was the standard denotational definition accompanied by an admission and explanation of its incorrectness. the other is operational.
11:33:46 <dolio> The Haskell 1.0 report is from 1990.
11:33:59 <zzo38> Am I correct or am I confuse and wrong?
11:34:08 <ddarius> dolio: GHC development started in 1987.
11:34:33 <cec24> hi, does anyone know where "all about monads" has gone on haskell.org, i get a 404 right now for http://www.haskell.org/all_about_monads/
11:35:00 <zzo38> It says   Nothing for lambda-bound variables, and
11:35:11 <zzo38> for anything else TH can't figure out E.g. [| let x = 1 in $(do { d <- reify 'x; .. }) |]
11:35:11 <hatds> zz038: I can't say for sure.  TH is sparsely documented.
11:35:20 <merijn> conal: I agree that there probably is no valid denotational explanation of IO, but that does not mean that those explanation cannot be useful in learning to think about how the IO monad behaves
11:35:40 <zzo38> hatds: Then how can you learn TH properly?
11:36:21 <conal> merijn: about a subset of IO that almost no one really uses.
11:36:39 <hatds> zz038: a valid complaint!
11:36:47 <elliotstern> monochrom:  That's "Monadic I/O in Haskell 1.3" from '95?
11:37:08 <conal> merijn: what worries me is that people actually *believe* these explanations. they're usually presented as if they were true.
11:37:17 <monochrom> I don't know haskell 1.3
11:37:31 <ddarius> monochrom: You can slap a monadic interface on most of the schemes presented.
11:37:41 <elliotstern> The title of Andrew Gordon's phd thesis
11:37:45 <monochrom> but I would bet haskell 1.3 wouldn't dictate to you how to implement
11:37:50 <merijn> conal: You have to start *somewhere*, and personally I have not seen many better starting places. Maybe that just means I haven't looked enough, but...
11:37:52 <hatds> zz038: If you are curious about nailing down the answer I would also try asking on the haskell-cafe mailing list.  It'd also be a good way to raise the visibility that TH still needs better documentation :)
11:38:11 <elliotstern> Or is it a different paper by the same guy?
11:38:13 <conal> we could perhaps preface such stories by saying "the following story about IO cannot actually explain some important aspects of IO, but some people find it useful to begin developing an understanding.
11:38:17 <conal> "
11:38:46 <merijn> conal: Well, I didn't realize GHC used a dummy realworld value, and without that knowledge it seems fairly obvious that of course you don't take the "real world"
11:38:50 <zzo38> hatds: Thanks for a suggestion. But, I do not use mailing list
11:38:51 <monochrom> no, the thesis title is "functional programming and input/output"
11:39:12 <zzo38> In case you are interested, this is what I typed:    a = $( do x <- reify 'a; return (LitE $ StringL $ show x) )
11:39:44 <ddarius> fmap (LitE . StringL . show) (reify 'a)
11:39:58 <conal> merijn: i'm confused. lack of knowledge made something obvious to you? or maybe the knowledge helped you notice an assumption.
11:40:10 <dolio> What's wrong with the continuation and term models?
11:40:24 <merijn> dolio: I'm not sure, I didn't encounter them
11:40:28 <zzo38> ddarius: Is that a same kind of thing? Is that a better way?
11:41:23 <merijn> conal: Lack of knowledge led me to not make the assumption that an actual implementation method was being discussed. To me the entire "real world as an argument" was obviously an analogy since I didn't know a similar thing was being used in the actual implementation
11:42:00 <zzo38> Yes,   fmap (LitE . StringL . show) (reify 'a)   also works I have tried it
11:42:14 <zzo38> Probably it is better way, since it is not "do" notation
11:42:38 <dolio> Clean actually explicitly uses token passing for I/O.
11:42:47 <dolio> With some syntax sugar to make it more bearable to actually write.
11:43:01 <merijn> The whole uniqueness types thing, right?
11:43:09 <dolio> Yes.
11:43:17 <dolio> So does Mercury.
11:43:22 <merijn> I should look up how that works sometime
11:43:23 <dolio> If I recall correclty.
11:43:50 <dolio> It's exactly GHC implementation, but the type system prevents you from duplicating 'the world.'
11:44:01 <conal> Sadly, that IO_inside page also conflates a particular concrete (and bogus) representation of IO with "monadic", which is an interface+laws, not anything concrete.
11:44:04 <dolio> So they don't need to wrap it in an abstract type.
11:49:14 <conal> I added the warning to that IO Inside page. Hopefully people will still get the intuitive help from the story but will be less tempted to believe it.
11:51:42 <hatds> pumpkin: but you see conal's point.. what is the implementation doing on the IO inside page?  There's a place for talking about RealWorld on that page, but it should be in the context of a whimsical analogy
11:51:58 <hatds> pumpkin: whoops, I was scrolled way up :)
11:54:18 <cec24> \quit
11:54:39 <argiopeweb> conal: s/about IO in incorrect/about IO is incorrect/
11:55:02 <singpolyma> Does standard haskell have support for conditional compilation at all?
11:55:07 <ddarius> No.
11:55:21 <ddarius> The Report says nothing about compilation.
11:55:36 <c_wraith> the only support for conditional compilation is via the CPP extension.
11:55:39 <singpolyma> ddarius: hmm, I guess that's reasonable
11:55:47 <imc> how do i tell sbt the exact version of a package?
11:55:51 <c_wraith> Which is kind of sad because CPP chokes on some legal Haskell source
11:55:59 <argiopeweb> c_wraith: And assertions, technically.
11:55:59 <conal> argiopeweb: are you referring to an earlier remark of someone's? if so, i'm not seeing it.
11:56:04 <ddarius> That's why there's cpphs
11:56:16 <imc> wrong chan, sorry
11:56:17 <argiopeweb> conal: My bad... In the warning on IO Inside.
11:56:30 <conal> argiopeweb: oh. thanks! will fix. :)
11:56:52 <singpolyma> ok, I guess what I want will require maybe editing source then.  not the end of the world, but less clean :)
11:58:16 <conal> there. fixed.
11:58:32 * argiopeweb refrehses
11:58:41 <argiopeweb> Apparently I can't spell either.
11:58:43 <conal> "A thought is harmless unless we believe it." - Byron Katie
11:58:44 <argiopeweb> Much better. Thanks. :)
12:02:34 * hackagebot cabal2nix 1.3 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.3 (PeterSimons)
12:02:36 * hackagebot cabal2nix 1.4 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.4 (PeterSimons)
12:03:11 <sanjoyd> Debugging tips?
12:03:35 <monochrom> debugging tips: the only way to win is not to play
12:04:11 <merijn> When in doubt, rewrite from scratch :p
12:04:29 <argiopeweb> And that's the sad truth...
12:04:37 <monochrom> actually, my real debugging tips: debug your mind, not your code
12:04:46 <merijn> ^^ truth
12:04:56 <ddarius> monochrom: Yes, that segfault is only in your head.
12:05:57 <merijn> If I don't have any suspects for a bug within 15 minutes I assume the difference between code and my brain is to big and the only way to solve that is rewrite the code
12:06:13 <merijn> Or rewrite your brain, but rewriting the code is usually easier and more cost effective :p
12:06:52 <monochrom> no, segfault isn't just in one's head, it is on the computer too. but the cause is in your head, you have a make-believe there, and that needs the debugging
12:07:34 * hackagebot cabal2nix 1.5 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.5 (PeterSimons)
12:07:36 * hackagebot cabal2nix 1.6 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.6 (PeterSimons)
12:09:52 <merijn> ugh...
12:11:06 <merijn> Spend one week debugging a race condition in C code, thought I just fixed it. Turns out I turned a race which always appeared into a race which appears one run out of 20 >.>
12:11:27 <sanjoyd> Nah, debugging Haskell.
12:11:31 <sanjoyd> So no segfaults.
12:11:43 <sanjoyd> But, yes, the bug is probably in my head.
12:11:52 <merijn> Sure there are, just a bit harder to trigger :>
12:12:19 <sanjoyd> I've always wondered if bugs are actually Freudian slips.
12:22:34 * hackagebot cabal2nix 1.7 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.7 (PeterSimons)
12:27:20 <sanjoyd> http://projects.haskell.org/hat/ seems to be empty. Is Hat still under development?
12:28:07 <hatds> does anyone have a good naming convention for transforming data decls like "data Foo = ... Int ..." into "data FooGen a = ... a ...   type Foo = FooGen a" ?
12:28:35 <hatds> Foo = FooGen Int of course
12:30:44 <AtnNn> type FooInt = Foo Int
12:32:09 <hatds> I was thinking the other way around.. Foo is the type you plan to use everywhere,  FooGen is just something you stick in the internal module
12:32:23 <hatds> 'FooPoly' maybe?
12:34:42 <benmachine> hatds: why does FooGen even exist?
12:35:06 <dmead> edwardk: whats gershon's nick?
12:35:07 <hatds> benmachine: allows flexibility later, or for testing
12:35:24 <benmachine> hatds: I don't very much buy either of those arguments :P
12:35:29 <pumpkin> dmead: he's not on IRC
12:35:31 <benmachine> if you want flexibility later, change the implementation
12:35:33 <copumpkin> (gershom)
12:35:56 <benmachine> if you want testing, then test behaviours that actually exist :P
12:37:33 * sanjoyd smells OOP.
12:37:39 <dmead> copumpkin: like at the moment, or at all?
12:37:57 <copumpkin> dmead: haven't seen him
12:38:06 <dmead> kk
12:39:17 <dainanaki_> Hooray, I uploaded my first hackage package!
12:40:32 <benmachine> hooray!
12:40:37 * benmachine pokes hackagebot
12:41:24 <dainanaki_> I guess it takes a while to get back to you.
12:42:25 <ddarius> It's a timer, not on-demand.
12:42:34 * hackagebot zoom 0.1 - A rake/thor-like task runner written in Haskell  http://hackage.haskell.org/package/zoom-0.1 (IanDuncan)
12:42:42 <dainanaki_> there we go.
12:43:03 <copumpkin> your github link is broken
12:43:10 <copumpkin> you need the full http:// prefix
12:43:16 <dainanaki_> I noticed. Time for 0.1.0.1
12:44:01 <sm> hackagebot is announcing less frequently now (5m)
12:44:10 <dainanaki_> Thanks to edwardk
12:45:06 <sm> yes thanks to *certain people* being so frickin productive :)
12:45:26 <dainanaki_> That day was terrible.
12:45:28 <tgeeky__> dainanaki_: also, you may want to check out https://github.com/nfjinjing/nemesis
12:45:30 <benmachine> heehee
12:45:35 * sm is envious
12:46:42 <tgeeky> I can't tell the difference between version bumping and actual development when ek updates so many packages
12:47:04 <dainanaki_> tgeeky_: thanks for the link. I hadn't seen that. Still, I'll probably hack away at mine. It's mostly a for-fun project anyways.
12:47:17 <Nimatek> Hmm, how would one go about putting an UI written in Python into a Haskell OpenGL application?
12:47:34 * hackagebot zoom 0.1.0.1 - A rake/thor-like task runner written in Haskell  http://hackage.haskell.org/package/zoom-0.1.0.1 (IanDuncan)
12:47:40 <tgeeky> dainanaki_: I didn't intend to do anything other than inform you of its existence
12:48:16 <dainanaki_> don't worry, it wasn't taken that way.
12:48:22 <merijn> Nimatek: Call C from python (probably using Cython, #python can help here) and then call into haskell code exported using the FFI
12:48:23 <tgeeky> dainanaki_: hehe :)
12:48:31 <tgeeky> dainanaki_: also, you may want to check out boson (in ruby)
12:48:35 <merijn> Or vice versa
12:48:41 <Nimatek> merijn: Thanks, I'll look into that.
12:48:45 <mafs> Hmm, hackagebot (and the automated tweets and stuff) should maybe be adjusted to not announce until the documentation is generated
12:49:05 <tgeeky> dainanaki_: https://github.com/cldwalker/boson
12:49:09 <mafs> That way people can look into that as soon as they see the announce, instead of having to check back later
12:49:14 <tgeeky> dainanaki_: I would love to work on a project that replicated that in Haskell
12:49:25 <dainanaki_> yeah, that's pretty cool!
12:49:34 <ddarius> tgeeky: Nothing is stopping you.
12:49:51 <tgeeky> ddarius: my intelligence and time constraints
12:49:59 <sm> mafs: sounds good, tweak hackage server feed, and ideally make it run the haddock right away!
12:50:22 <luite> tgeeky: should be doable with hint
12:50:25 <tgeeky> dainanaki_: anyway, the nice things about boson: regular methods (in haskell's case, functions, probably) are elevated to command-line and console functions
12:50:43 <dainanaki_> tgeeky, that's exactly how my zoom app works.
12:51:06 <dainanaki_> you just wrap them in a small datatype that holds a little metadata.
12:51:07 <tgeeky> dainanaki_: and there is a reasonable (but flawed, IMO) option parser
12:51:17 <tgeeky> dainanaki_: i'll take a look then
12:51:47 <dainanaki_> tgeeky: 0.1 has *very* basic argument support
12:51:51 <tgeeky> dainanaki_: the other thing that boson has is automatic views (generates trees and tables from tree-like or table-like data)
12:51:54 <dainanaki_> fair warning.
12:52:13 <dainanaki_> yeah, I do like that about boson.
12:52:39 <dainanaki_> 0.2 is going to be geared towards adding more utility functions and better argument handling.
12:52:48 <tgeeky> dainanaki_: it's interesting to note, the only default functions that are included in boson are [put, get, libraries, commands] and two others i can't remember
12:53:07 <tgeeky> dainanaki_: have you looked at cloudhaskell?
12:53:50 <dainanaki_> nope, haven't seen that.
12:53:56 <dainanaki_> looks neat though!
12:54:18 <dainanaki_> is there an actual implementation?
12:54:24 <tgeeky> yeah, oh github
12:55:08 <tgeeky> dainanaki_: I would recommend splitting 'desc' into 'sdesc' and 'ldesc' or something like that
12:56:12 <dainanaki_> Yeah, zoom in its current implementation is too minimalist. It was mostly just a rush to get a basic implementation working before I lost motivation.
12:56:20 <tgeeky> dainanaki_: haha, smart
12:56:32 <tgeeky> dainanaki_: another thing that's probably relevant
12:56:39 <tgeeky> is Forest (which has a paper but no implementation yet)
12:56:47 <tgeeky> but I bet that would be a mean combo
12:56:55 * ddarius loses motivation before the fact to save time.
12:56:58 <dainanaki_> do you have a link?
12:57:59 <tgeeky> dainanaki_: http://www.cs.cornell.edu/~jnfoster/papers/forest-icfp11.pdf
12:58:14 <tgeeky> also http://www.forestproj.org/
12:58:24 <dainanaki_> tgeeky: how do you see that fitting in with zoom?
12:58:28 <mwc> cabal problem: how do I specify an extra-library which is build during the buildHook phase? The configure fails because the lib doesn't exist
12:58:37 <tgeeky> dainanaki_: it's a type-safe abstraction over a filesystem
13:00:27 <dainanaki_> what would be the use case for something that heavy-duty in a task runner?
13:00:57 <tgeeky> well, say, you want to store files inside a VCS repository
13:01:26 <tgeeky> like a workflow that git clone's something, does some work, and commits it
13:01:59 <tgeeky> I guess it's a little heavy for something like thor :O
13:02:14 <dainanaki_> I guess I could see that use case.
13:04:15 <tgeeky> dainanaki_: for example, say you have a collection of files that are haskell code in some literate format
13:04:51 <tgeeky> dainanaki_: you could use Forest to split the files into [documentation, code], do some processing, make a hakyll page, and then push it to github
13:05:18 <merijn> danka: Ping!
13:05:42 <tgeeky> *the sound of a ping releases a caesium atom, killing a cat*
13:05:55 <deech> Hi all, can I have a project that has mutiple main functions? The use case is that I have several modules each of which could be a stand-alone command-line program but can also be hooked into my web framework's main function.
13:05:55 <dainanaki_> x_x
13:06:08 <tgeeky> deech: yes
13:06:21 <tgeeky> deech: you mean, can a cabal file specify multiple executables?
13:06:29 <deech> tgeeky: Yes.
13:06:32 <tgeeky> deech: yes
13:06:33 <dainanaki_> deech: you just create multiple executable sections in your cabal file.
13:07:21 <deech> dainanaki_: Do they all have seperate build dependencies. For example the command line programs don't need the web framework.
13:07:57 <tgeeky> deech: they can each specify that
13:08:05 <dainanaki_> deech: exactly. You specify Main-is, Build-depends, and Other-modules for each executable.
13:08:41 <deech> tgeeky, dainanaki_ I see, is there documentation on the Cabal site for that?
13:09:03 <tgeeky> dainanaki_: another thing of note is nfjinjing's use of his 'air' prelude which results in some nice-looking haskell code
13:09:50 <tgeeky> deech: http://www.haskell.org/cabal/users-guide/#executables
13:09:52 <tgeeky> i guess?
13:11:19 <deech> tgeeky: Awesome, thanks for your help!
13:13:29 <shurikas> > pi == 22/7
13:13:30 <lambdabot>   False
13:13:33 <int80_h> I will load a module using both :l and :m in ghci. But when I try to use a function from the file I get an "out of scope" error. What do I need to do to bring these functions in scope?
13:14:48 <tgeeky> :m +Module.Name
13:14:50 <janiczek> guys, you'll surely be super happy to answer this question ... :D at work, we did a little contest - who can write the fastest code (in any language) that did certain thing - it was parsing a csv file of regexes and then parsing a (big) logfile with them, outputting number of matched vs not-matched lines. so some of us wrote python code, some lua, some (me) c++, and this one guy writes it in haskell, nobody can comprehend the code, and it's the
13:14:50 <janiczek> fastest program around. the times are like this: hs 26.79, cc_boost 29.07, luajit 31.77, lua 33.90, py_match 39.36, cc_re2 50.92 ... and my question is: why the hell is haskell the fastest one? does it have to do with the static vs dynamic language thing?
13:15:39 <tgeeky> janiczek: isn't cc_boost static?
13:15:45 <dainanaki_> Haskell being a pure functional language allows for many optimizations not doable in procedural languages.
13:15:47 <merijn> janiczek: In some cases the laziness + referential transparency of haskell lets do compiler crazy stuff which other compilers cannot
13:16:48 <tgeeky> janiczek: the real question is, what did the winner get?
13:16:53 <dainanaki_> Also, a compiled language will generally run faster than an interpreted one.
13:17:00 <merijn> janiczek: I remember compiler class and almost every optimization discussed went like this "except that we can't guarantee X won't happen, so we can use this optimization almost never". With immutable variables that is less of a problem
13:18:20 <tech2> dainanaki_: I thought HP disproved that many moons ago?
13:19:00 <dainanaki_> Not really since I qualified my statement with the word 'generally'
13:19:08 <tech2> Fair enough
13:19:09 <tgeeky> heehe
13:19:11 <shurikas> > let test [Int] = [Int]
13:19:12 <tgeeky> I was going to say
13:19:12 <lambdabot>   not an expression: `let test [Int] = [Int]'
13:19:17 <shurikas> > let test a = a
13:19:18 <lambdabot>   not an expression: `let test a = a'
13:19:19 <janiczek> hmm :) thanks for the answers! dainanaki_: i knew that about compiled vs interpreted, but didnt know about the optimalizations. makes sense
13:19:36 <tgeeky> "generally, one can not prove statements that include the qualifier 'generally'"
13:19:38 <shurikas> what's wrong with first one?
13:20:20 <dainanaki_> janiczek, not sure if relevant to your contest, but Haskell also allows for very simple concurrency and parallelization for similar reasons.
13:20:36 <shurikas> how can I define a function which takes [Int] as argument and returns Int?
13:20:42 <tgeeky> also, I think haskell has some crazy good CSV parsers
13:20:45 <shurikas> without a type declaration
13:21:05 <dainanaki_> Haskell really does have absurdly good parsing libraries.
13:21:08 <shurikas> or how can I do type declaration inline with writing a function (using Prelude)
13:21:40 <merijn> janiczek: In general Haskell will be a bit slower then optimized C, but when GHC's optimizations kick in they tend to kick in hard :)
13:21:52 <tgeeky> shurikas: the general case of taking a list, doing something to the elements, and returning an "summary" element of the list is called fold
13:22:21 <tgeeky> probably not the best description
13:22:27 <tech2> merijn: does GHC do JIT optimisation like Java hotspot and pypy?
13:22:34 <tgeeky> tech2: no
13:22:36 <merijn> tech2: GHC doesn't do JIT
13:22:38 <dainanaki_> I don't think so.
13:22:44 <shurikas> tgeeky, right now I understand only how to declare polymorphic functions. But how to declare functions with defined types?
13:22:56 <tgeeky> tech2: though LLVM does, and GHC has an evolving LLVM backend
13:22:59 <tech2> Just a matter of "nobody's gotten around to it yet", or something deeper?
13:23:06 <tech2> tgeeky: ah, cute, thanks
13:23:16 <tgeeky> tech2: I don't think JIT makes sense with a totally compiled language?
13:23:23 <tgeeky> but maybe I'm wrong
13:23:30 <merijn> tech2: Then again, GHC already compiles to machine code, now you could JIT machine code to more optimal machine code, but it won't have the same effect as with an interpreted language like Java and python
13:23:40 <merijn> tgeeky: It can, you can optimize for constants in functions
13:23:47 <hatds> shurikas: you would give a type signature declaration.  "f :: [Int] -> Int"
13:23:49 <merijn> Project here at uni does that
13:23:54 <janiczek> dainanaki_: looking at his code right now (crazy!! at least for me :) I'm really not used to the functional thinking) and it doesnt seem to use any parallelization. that's sad, if there was any, we could have said he cheated :D thanks for the info on parsing abilities of Haskell :) I'm looking at how he does the csv parsing and it's something like B.split ',' s
13:24:08 <janiczek> dainanaki_: and he's using PCRE for regex
13:24:08 <tech2> It's not just JIT I was thinking about but how things like pypy seems to focus on areas that execute in a particular fashion.
13:24:22 <shurikas> hatds, and can I do that inline? in interpreter?
13:24:47 <merijn> Their language supports general multi-dimensional array coding, they are doing some work on recompiling code at runtime for case where the dimensionality of the arrays are known
13:24:52 <hatds> shurikas: let f xs = {- calculate something -} :: Int where xs :: Int
13:24:55 <shachaf> edwardk was working on a a JIT for x86-64.
13:25:04 <janiczek> but seriously, my eyes hurt from looking at that code... :D
13:25:06 <shurikas> ahh ok
13:25:09 <shurikas> thanks, hatds
13:25:12 <sm> janiczek: :) want to paste it ?
13:25:21 <janiczek> I guess I could
13:25:24 <dainanaki_> i'm curious to see too.
13:25:26 <janiczek> pastebin
13:25:38 <tech2> damn, edward, when does he sleep? (he does sleep, right?)
13:25:46 <sm> http://hpaste.org/new/haskell
13:25:49 <tgeeky> tech2: I haven't seen any proof that he does
13:25:52 <tech2> :/
13:26:00 <janiczek> http://pastebin.com/r5WH5vK3
13:26:03 <mauke> The paste r5WH5vK3 has been copied to http://hpaste.org/49890
13:26:11 <sm> woah
13:26:40 <tgeeky> i bet it's the 'type SomeShit = ByteString' that makes it so fast
13:26:44 <dainanaki_> wow, kind of ugly
13:26:56 <shurikas> hahah a:DDD
13:26:58 <dainanaki_> love the type alias
13:27:04 <janiczek> :D
13:27:16 <janiczek> so, ByteStrings are megafast? :)
13:27:17 <tgeeky> janiczek: the regex is fast because it's compiled
13:27:30 <janiczek> well I compile regexes too, of course, but it's still slower! :)
13:27:42 <copumpkin> you compile them every time, don't you?
13:27:53 <janiczek> no, only when I read the file with regexes
13:28:01 <shachaf> janiczek: ByteStrings aren't for text.
13:28:04 <janiczek> when I read the logfile to match them, i have them in a vector or something
13:28:05 <copumpkin>           header line = PCRE.match (PCRE.compile "^(\\w\\w\\w [ \\d]\\d [ \\d]\\d:\\d\\d:\\d\\d) (\\w+) ([^:[]+)(?:\\[(\\d+)\\])?:\\s+(.*)$" []) line []
13:28:11 <copumpkin> I mean that
13:28:40 <tgeeky> janiczek: you could run his program with profiling
13:28:44 <tgeeky> and pretty much figure out why it's fast
13:28:52 <dainanaki_> that would be quite relevant.
13:28:54 <tgeeky> someone will have to tell you the options to use
13:29:15 <tgeeky> i'm guessing it's because of partitionLength
13:29:16 <copumpkin> you could also move that compile out of the function
13:29:18 <tgeeky> and that unboxing or whatever
13:29:26 <copumpkin> so it doesn't parse/compile the same regex over and over again
13:29:29 <dainanaki_> Do the unboxed integers really do that much here?
13:29:34 <janiczek> Well I have that long regex precompiled and then I just reuse it ... I dont get why he's recompiling it every time :) ...
13:29:35 <copumpkin> dainanaki_: I doubt it
13:29:38 <dainanaki_> seems like overkill
13:29:44 <copumpkin> janiczek: because that's what you've told it to do
13:30:06 <tgeeky> copumpkin: well that would make the haskell code faster
13:30:16 <tgeeky> copumpkin: which is sort of, un-answering the original question (which is the haskell code so much faster?)
13:30:17 <copumpkin> oh, that isn't the goal?
13:30:21 <janiczek> well OK, I *WON'T* tell him that :D
13:30:22 <copumpkin> oh
13:30:34 <dainanaki_> copumpkin: janiczek posted a coworker's code for us.
13:30:35 <copumpkin> I didn't realize the goal was to make it slower
13:30:39 <copumpkin> ah
13:30:43 <mornfall> Hm, a Q: in Data.Set, can it be expected that Tip values are "inlined" in the Bin's?
13:30:43 <tgeeky> copumpkin: hehe :O
13:31:04 <janiczek> I'll ask him about how he compiled and run the program and I'll try to run it with profiling, I'm really curious :)
13:31:07 <mornfall> Or maybe that question doesn't even make much sense. Hm.
13:31:13 <janiczek> but right now it's kind of midnight ... :)
13:31:48 <sm__> the hacking hour!
13:32:20 <bscarlet> janiczek: what RE implementation did you use?
13:32:53 <janiczek> boost
13:32:58 <mornfall> So a different question: is it reasonable to expect all Tip values to be shared?
13:33:03 <janiczek> do you think pcre would be faster?
13:33:25 <c_wraith> mornfall: If it's a constructor with no args, it will be shared.
13:33:34 <mornfall> c_wraith: Yep, it is.
13:35:22 <sm__> janiczek: how did the entries compare in lines of code ?
13:35:59 <janiczek> sm__: I'll look it up, wait a sec
13:37:47 <bscarlet> janiczek: yes
13:39:12 <janiczek> haskell 66 lines of super-ugly code, cc_boost 76, cc_re2 104, lua+luajit 63, python 51
13:39:47 <tgeeky> hehe
13:39:55 <janiczek> bscarlet: hm, so if I'd try to implement it using PCRE, it could own the haskell's *ss? :D
13:40:06 <dainanaki_> tgeeky: just looking at the code for nemesis. It actually compiles nemesis scripts to object  files and stuff using shell commands.
13:40:08 <dainanaki_> lol
13:40:11 <janiczek> (not to offend any of you :D )
13:40:12 <bscarlet> janiczek: possibly, yes.
13:40:18 <tgeeky> dainanaki_: yeah I noticed that today :o
13:40:28 <tgeeky> dainanaki_: if you look at all of his other projects, you can see him using nemesis
13:40:33 <tgeeky> dainanaki_: i liked the syntax
13:41:05 <bscarlet> janiczek: though once the Haskell is decent enough there shouldn't be much difference if the bulk of the work is in the regex evaluation.
13:41:35 <bscarlet> janiczek: what's your input like? How many regexes and how many lines of input?
13:41:43 <dainanaki_> tgeeky: I just expected it to use hint as the interpreter or something like zoom does.
13:41:56 <tgeeky> dainanaki_: *shrug*
13:42:09 <dainanaki_> i'm just amused
13:42:20 <tgeeky> dainanaki_: I suppose both would be ideal
13:42:57 <dainanaki_> yeah, zoom is written such that you can globally install tasks and it uses the ghc api to find relevant modules, so that way you can have speed when necessary.
13:43:06 <janiczek> bscarlet: 3834 regexes (317 kB), 1074018 lines of log to be parsed (105.6 MB)
13:43:20 <sm__> janiczek: thanks!
13:43:36 <sm__> about what I epected
13:43:41 <sm__> python always does well
13:43:58 <sm__> at least on small tasks
13:45:30 <janiczek> sm__: about python, it surely does :) in highschool we wrote programs in c (well, we HAD TO :D ), bubble sorts etc., and for the fun of it, I wrote a python version of each program too. the python version was always min. half shorter than the c version :)
13:46:38 <janiczek> also more comprehensible too
13:48:19 <sm__> I'm not sure why it's hard to write small haskell progs as concisely as python. It's not very satisfactory
13:48:50 <dainanaki_> I find that with the right libraries they can be concise.
13:48:58 <sm__> python has more syntactic sugar ? more polished batteries ?
13:49:05 <dainanaki_> Usually this means that I have 20 lines of imports and 20 lines of code
13:49:34 <sm__> the long list of imports gets me down too. Python has that too, though you can put several on a line
13:49:38 <janiczek> I guess Python is at the right level of pseudocode-ness :)
13:51:04 <janiczek> I *tried* Haskell, but, well, I didn't get used to the functional style of programming. I guess I'll try again at the right time and it'll somehow click :)
13:51:25 <dainanaki_> janiczek, Haskell can sometimes require repeated trial and error.
13:51:35 <sm__> janiczek: yeah, just try a bit every so often and it'll click soon enough
13:51:38 <dainanaki_> It took me years to really feel comfortable with it.
13:51:44 <roconnor> sm__: it's hard to write small haskell programs?
13:51:58 <dainanaki_> Now it's the most comfortable way to program for me.
13:52:02 <benmachine> I do sometimes wish I could write haskell programs with an auto-importer
13:52:05 <sm__> roconnor: it's often hard to make them quite as concise as idiomatic python
13:52:07 <dainanaki_> me too!
13:52:08 <roconnor> hmm
13:52:14 <Bfig> haskell Rocks.
13:52:17 * roconnor should look at more idiomatic python
13:52:18 <benmachine> "any time you compile and find something missing, hoogle it and add it to the list"
13:52:26 <dainanaki_> Haskell's imports are my least favorite portion of the syntax
13:52:31 <sm__> roconnor: ruby, even more so, but don't mind them
13:52:43 <dainanaki_> especially having to qualify overlapping functions
13:53:05 <dainanaki_> why isn't there an -XUseTheFrakkingFunctionIWant extension?
13:53:32 <bscarlet> janiczek: at those data scales, the test is much more about the speed of the underlying regex implementation and avoiding dumb coding than it is about the language. I think you'll find that across the languages use the language used to implement the regex library doesn't correlate too well to the language used to write the test program.
13:53:38 <sm__> import All
13:53:51 <roconnor> sm__: my programs all all main = mapM_ (print . foo . lines) getContents and I'm done.
13:55:02 <sm__> question, is there much cost to importing a bunch of modules you don't use ?
13:55:19 <dainanaki_> Perhaps a series of convenience modules that reexport commonly needed modules and data types could be useful
13:55:27 <dainanaki_> import Convenience.ShellScript
13:55:35 <dainanaki_> etc.
13:55:37 <sm__> yes
13:56:01 <janiczek> sm__: when it compiles, it throws away the things it doesnt need, or am I wrong?
13:56:46 <janiczek> bscarlet: will try the PCRE ... :)
13:58:05 <janiczek> bscarlet: also, do you think the ghc somehow sees that the haskell program recompiles a const string regex, so to speak, and compiles it only once and remembers it somewhere?
13:58:59 <janiczek> I always wondered about that. If there is a penalty of the compiler really doing it the dumber (but easier to write) way
13:59:48 <janiczek> like that regex compilation. header line = PCRE.match (PCRE.compile "blablabla regex" []) line []
14:00:20 <mike-burns> In e.g. Ruby programs you don't have to specify a long list of imports because there's seldom a namespace conflict.
14:00:27 <mike-burns> Haskell's imports are a fine tradeoff.
14:00:32 <bscarlet> janiczek: dunno. I suppose it might if the PCRE FFI bindings claim enough is pure.
14:01:36 <bscarlet> janiczek: I'm not sure how much it matters, actually. PCRE uses backtracking, not DFA construction, so it may not have much startup overhead.
14:06:26 <janiczek> Thought about looking at regex libs benchmarks. http://lh3lh3.users.sourceforge.net/reb.shtml , http://stackoverflow.com/questions/1759991/regular-expressions-performance-boost-vs-perl - tl;dr of the latter is to try both (pcre and boost) and see which is faster for the particular dataset. will do :)
14:06:49 <lucca> perl also uses NFA+backtrack, because it supports things outside what regexes should strictly be able to do.
14:06:55 <benmachine> janiczek: GHC doesn't tend to do that sort of memoisation (only compiling the thing once) because it tends to cost memory, sometimes a lot
14:07:00 <benmachine> to remember stuff rather than recomputing it
14:07:25 <dainanaki_> it will do it if you make it a top-level CAF though, right?
14:07:47 <benmachine> yes, I think so
14:11:09 <phil_c> It's not wrong to be a little bit suspicious of this "pure" functional kool-aid, I'm drinking, is it?
14:11:42 <mwc> phil_c: sure, it's at odds with how you know a computer actually works, by flipping a bunch of ones and zeroes
14:11:49 <merijn> What's there to be suspicious about?
14:12:03 <bscarlet> benmachine: even hoisting computations out of loops?
14:12:11 <mwc> take on faith that there's an efficient way to represent the pure functional goodness in the von Neuman machine language, and you can learn how that works later
14:12:15 <merijn> As long as you realize that the implementation of said pure behaviour is of course inherently non-pure (current computers not being pure)
14:13:08 <roconnor> how do I get ghc to warn about unused imports?
14:13:43 <mwc> -Wall will do it, not sure what the precise flag is
14:14:04 <dibblego> -fwarn-unused-imports
14:14:14 <identity_> mmm kool-aid
14:14:23 <merijn> phil_c: It's a matter of knowing what to use, in some situations state mutation is just the easiest/most efficient way of doing things. The advantage of Haskell is that it makes you be explicit when stuff is mutable and when it is not. As time progresses you'll notice you prefer immutable whenever possible :p
14:14:35 <ddarius> Machine languages are less and less von Neumann, their implementations even less so, and their foundations not at all.
14:14:50 <dainanaki_> True that.
14:15:11 <merijn> @quote Berengal referential.transparency
14:15:11 <lambdabot> Berengal says: I just can't get over how awesome it [referential transparency] is. I feel like instituting a holiday or something...
14:15:33 <mokus> i'd celebrate that holiday
14:15:49 <dainanaki_> I'm currently using it as an excuse for a holiday!
14:15:53 <merijn> So do I
14:16:02 <benmachine> bscarlet: I don't know the details
14:16:12 <dainanaki_> aka, I got done with work early thanks to Haskell (™)
14:16:22 <benmachine> phil_c: be suspicious of everything, but don't dismiss things without a fair trial :P
14:17:01 <phil_c> <benmachine> Yeah, I guess.
14:17:23 <benmachine> (skepticism > cynicism)
14:17:31 <benmachine> (...possibly)
14:17:46 <dainanaki_> psh, like that approach to life will work...
14:17:47 <mwc> A cynic is a skeptic with experience.
14:18:07 <merijn> On related note:
14:18:11 <merijn> @quote no.variables
14:18:12 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
14:18:12 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
14:18:57 <Olfway> quick question: anyone on here running slackware? If so, can I ask for help installing?
14:18:59 <dainanaki_> true that.
14:19:08 <ddarius> mwc: A cynic is a person with experience.
14:19:43 <phil_c> No variables?
14:20:02 <phil_c> well, this should be interesting.
14:20:27 <merijn> phil_c: Well, that's a lie. But they are all immutable (i.e. if you're coming from Java/C++ everything is a const)
14:20:39 <merijn> or final, I guess in Java-speak
14:20:54 <dainanaki_> they're variables in the math sense rather than the imperative programming sense.
14:21:12 <hatds> which is to say names represent values, not mutable locations
14:21:41 <Gracenotes> coroutines in C. they would be nice. :|
14:21:52 <Gracenotes> kind of off-topic though. but yes.
14:22:28 <ion> There are libraries that implement that.
14:22:31 <ddarius> Gracenotes: http://www.sics.se/~adam/pt/
14:22:56 <Gracenotes> huh :o
14:22:59 <ddarius> (Adam Dunkels is getting older.)
14:23:56 <merijn> Gracenotes: I'm currently using PCL (Portable Coroutine Library) in a project, so they do exist :p
14:26:10 <ddarius> There are quite a few of them.
14:26:26 <Gracenotes> it also seems as though, somewhere between abstract coroutines and plain old C, there are some memory-management-related things to worry about
14:26:34 <Gracenotes> depending on how the library's designed I suppose
14:27:12 <ddarius> It depends on how powerful the coroutines are.
14:30:23 <phil_c> I come from some functional background from the Javascript and Python world.
14:30:34 <phil_c> The tuples and lists are familiar territory.
14:30:38 <joe1> "Once a programmer as learned the basics, then for Real World use, should the programmer import Data.Foldable and Data.Traversable and hide the corresponding Prelude function?"
14:30:50 <joe1> s/as/has/
14:32:24 <benmachine> joe1: not unless they feel the need to do so
14:32:26 <shachaf> phil_c: Are tuples and lists actually different in Python, other than one being mutable?
14:32:32 <benmachine> no advantage to generality you don't use
14:32:37 <merijn> shachaf: Python tuples aren't mutable
14:32:43 <companion_cube> shachaf: that's the only difference
14:32:49 <merijn> eh
14:32:52 <merijn> Misparsed that
14:32:59 <benmachine> that's not an insignificant difference though!
14:33:05 <hatds> joe1: It depends on the module for me.  If some non-list type is prominent then I hide the Prelude, otherwise I imported qualified for isolated uses
14:33:15 <merijn> Well, in general you're expected to store homogeneous data in a list in python
14:33:19 <shachaf> Of course. But it's pretty different from the difference in Haskell. :-)
14:33:21 <benmachine> in fact, excessive generality is a bad thing
14:33:28 <dainanaki_> as time goes on it becomes more and more clear to me that we need a training wheel's Prelude, and a generalized Prelude.
14:33:30 <shachaf> merijn: Are you really?
14:33:31 <janiczek> guys, just offtopic. does that s/x/y/ substitution thing come from Perl? the first time I saw it was when I learnt Vim, and naturally I thought it's a Vim invention, but day after day I see little pieces of evidence it comes from Perl. does it really?
14:33:35 <benmachine> it makes type errors less prevalent
14:33:39 <phil_c> I've done my bit of filter,map,reduce so it might apply in haskell ... maybe
14:33:41 <shachaf> janiczek: It probably comes from ed.
14:33:42 <opqdonut> janiczek: comes from sed, originally
14:33:42 <benmachine> type errors make you write better code
14:33:55 <merijn> shachaf: #python will yell at you loudly if you don't
14:33:58 <shachaf> opqdonut: I think ed predates sed. :-)
14:33:58 <opqdonut> oh, right, ed. that predates sed
14:34:02 <benmachine> hah
14:34:05 <opqdonut> echo
14:34:09 <shachaf> @echo off
14:34:10 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "shachaf!~shachaf@204.109.63.130", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo off"]} rest:"off"
14:34:14 <merijn> phil_c: A lot of the python functional stuff carries over. It's just more convenient in haskell
14:34:25 <telephone_> is it possible to define a operator "multifix"? like # a # b, which translates to (# #) :: a -> b -> c
14:34:28 <shachaf> merijn: Python hates "functional stuff".
14:34:40 <shachaf> telephone_: Not in general, no.
14:34:46 <merijn> shachaf: Yes, but that doesn't mean the stuff that's there doesn't apply to haskell too
14:34:52 <dibblego> python has nothing at all to do with functional programming
14:34:52 <shachaf> Agda can do it! :-)
14:34:54 <ion> “grep” also comes from ed.
14:34:54 <merijn> phil_c: There's list comprehensions too (python copied those from haskell)
14:34:56 <telephone_> shachaf: in special?
14:35:03 <shachaf> ?
14:35:07 <benmachine> python is a lot more functional than some of its competitors
14:35:11 <benmachine> well
14:35:12 <shachaf> Everything comes from ed!
14:35:21 <dibblego> functional programming in java is easier than in python
14:35:22 <shachaf> @google ed man
14:35:23 <lambdabot> http://www.gnu.org/fun/jokes/ed.msg.html
14:35:23 <lambdabot> Title: Ed, man! !man ed- GNU Project - Free Software Foundation (FSF)
14:35:30 <merijn> dibblego: ...
14:35:39 <dibblego> yes, you can fail harder than python, but that's not saying much
14:35:44 <merijn> I....but...what?
14:35:55 <pikhq> Uh. Last I checked Java didn't have closures.
14:35:57 <ion> What is this i don’t even
14:35:58 <dainanaki_> easier in scala or clojure, maybe
14:36:04 <merijn> Can't tell if trolling...
14:36:05 <telephone_> shachaf: you said not in general, but is it possible in some cases?
14:36:17 <dibblego> try it
14:36:21 <hatds> I've never felt the s/thing/thing flows very well in text conversation, and it's more inscrutable than it needs to be if you don't know what it means
14:36:32 <companion_cube> dibblego: i've tried both, really, and java is really not functional
14:36:33 <pikhq> (admittedly, Python has retarded anonymous functions, and no TCO, but hey. The named functions close, at least.)
14:36:34 <shachaf> telephone_: Well, you might be able to use some trickery to emulate it, depending on the specific case.
14:36:43 <shachaf> Probably not for what you mentioned, though.
14:36:46 <dibblego> companion_cube: I've tried both too and really java is not functional too, neither is python
14:36:49 <ddarius> s/^hatds.*$//
14:37:11 <companion_cube> python offers list comprehensions, nested functions with closures and yield
14:37:22 <pikhq> Python has closures, Java does not. I think Python wins by default.
14:37:30 <companion_cube> java hasn't even () operator or anything like that
14:37:42 <hatds> ddarius: that is a weird smiley you got there!
14:37:43 <silver> java have anon types
14:37:44 <dibblego> companion_cube: http://functionaljava.org/
14:38:16 <dibblego> I wrote that ^ Java is easier to do FP than it is in Python; both are extremely difficult to do FP, so much so, that this conversation is already far too long
14:38:18 <silver> which can replace closures at some degree, but syntax is pretty ugly
14:38:56 <janiczek> hatds: oh, man :D well played
14:38:58 <companion_cube> dibblego: just do scala instead of java, and you'll be much happier :)
14:39:04 <dibblego> companion_cube: I do
14:39:09 <DukeDave> @pl (\g i -> fst ((+) g i))
14:39:10 <lambdabot> (fst .) . (+)
14:39:10 <pikhq> silver: I consider those about as closure-like as struct closure {void*func;void*data};
14:39:17 <Peaker_> dibblego: I think doing FP in Python isn't very hard.. it just has slow & potentially buggy results
14:39:32 <Peaker_> (doing FP in Python is easy, doing it well to get nice results is hard)
14:39:37 * ddarius is not sure if Scala is happy-making either.
14:39:53 <erus`> i do functional programming in 386
14:39:56 <pikhq> (and yes, I'm aware that's UB in ISO C; it's perfectly valid in POSIX, so I care not.)
14:40:10 <ddarius> erus`: You can do some fun stuff with stack manipulation at the assembly level.
14:40:12 <silver> pikhq, why? you can bind outside stuff inthere, you can have well typed params there
14:40:13 <companion_cube> let's use ATS !
14:40:13 <dibblego> Scala is just a better Java, it's still a joke
14:40:47 <erus`> dibblego: agreed
14:41:06 * ddarius recommends C# as a better Java.
14:41:17 <telephone_> so is it absolutely not possible to write a function 'f :: a -> b -> c' as '# a # b', where # and # are symbols? (I want to do this because ofnice syntactic sugar in my case)
14:41:29 <ddarius> Unfortunately, the CLR isn't a better JVM in some important ways (it is in other important ways.)
14:42:11 <Peaker_> dibblego: I got to Haskell when I realized my pure FP in Python was getting clumsy and that re-inventing pure FP is probably a bad idea, and that I should get to know the state of the art
14:42:19 <silver> ddarius, can you enlighten us about those ways?
14:42:32 <benmachine> telephone_: prefix operators don't exist (apart from - which is special)
14:42:51 <benmachine> telephone_: in some cases you might be able to hack it with infix operators, but it's probably not worth it :P
14:43:30 <telephone_> benmachine: do you know how it works with the type (,,,)?
14:43:34 <erasmas> if you're used to problem solving in fp, do you find the problem solving style translates to python or java? having one or two fp techniques in an imperative language doesn't usually help with my overall approach
14:43:39 <benmachine> telephone_: magic, I'm afraid :)
14:43:48 <benmachine> tuples are builtin syntax
14:43:50 <benmachine> like lists
14:44:20 <benmachine> erasmas: I find the principle of immutable data being a good idea
14:44:25 <benmachine> to extend to imperative languages well
14:44:30 <ddarius> silver: It's nowhere near as prevalent, but it, for example, actually supports "generics."
14:46:14 <erasmas> benmachine: do you mean separating out data handling functions from IO functions, or do you go as far as, say, not modifying a list in-place even though you can?
14:46:54 <Olfway> anyone here ever have any troubles installing Haskell to Slackware?
14:47:02 <benmachine> erasmas: the latter, when I can afford it
14:47:02 <ddarius> erasmas: I would think he would go further than that, such as making an immutable list type.
14:48:14 <benmachine> (which is usually because I don't find myself writing performance-critical code)
14:48:16 <erus`> there over 9000 copies of you list in memory!
14:48:31 <benmachine> erus`: if it's a list of three numbers I'm actually kinda okay with that :P
14:48:47 <erasmas> benmachine, ddarius: that's interesting. to stay sane, I've tried to keep the two styles separate
14:48:58 <ddarius> If you are using an immutable type, you can share much structure.
14:50:53 <erasmas> ddarius: I guess the other solution is simply programming more in haskell. I've been using it for more and more tasks, professionally and as a hobby
14:52:05 <janiczek> guys, it's probably a dumb question for which I think I know an answer, but are you on ProjectEuler? :D
14:52:17 <cheater> no
14:52:25 <stobix> affirmative. :)
14:52:42 <erasmas> janiczek: yes. another 32 problems till immortality
14:52:45 <ddarius> janiczek: It's a dumb question to ask a channel with 773 people in it.
14:53:26 <janiczek> ddarius: well I addressed you active guys :)
14:54:14 <pokoko222> some of you guys here mix math and programming? you get hot about category theory and stuff? :)
14:54:40 <copumpkin> pokoko222: what happened to HaskellLove?
14:54:41 <janiczek> I have only 127 done problems, but for an high-school math I think it's good enough. And I'll be attending math college so I look forward to solving more of them ... :D
14:54:58 <pokoko222> copumpkin oh my sweetest friend, how you doing :D
14:55:01 <Taslem> I think Captcha just gave me an upside down wor...
14:55:15 * copumpkin takes a nap
14:55:23 <pokoko222> janiczek solved what?
14:55:47 <janiczek> pokoko222: http://projecteuler.net/index.php?section=problems
14:56:10 <pokoko222> copumpkin its been awhile, i have covered calculus, probability and statistics and linear algebra in college, and on my own i did abstract algebra 1
14:56:17 <janiczek> (the first 50 of them are really just for warming up)
14:56:20 <pokoko222> slowly moving towards category theory
14:56:29 <pokoko222> ah i used to solve those too
14:57:11 <erasmas> I'm one of those guys who went to school for something completely different and is trying to make up for it now. I need to find an accredited online university for math and haskell.
14:57:51 <tech2> ddarius: from earlier you mentioned CLR vs. JVM as better and worse than others in various ways. care to explain? Because on one side I see F# and the other I see Clojure and I don't really see the competition.
14:58:04 <pokoko222> erasmas sorry to disapoint you but cant be done, it takes years to master all the math and programming needed
14:58:12 <pokoko222> it is not a summer school thing
14:58:25 <Taslem> What's the integer division function?
14:58:29 <companion_cube> div
14:58:29 <shachaf> div
14:58:45 <c_wraith> > 99 `divMod` 13
14:58:46 <lambdabot>   (7,8)
14:58:48 <telephone_> this is why I want to write a multifix operator: http://hpaste.org/49891. Is this possible in some way?
14:58:57 <shachaf> > 99 `quotRem` 13
14:58:58 <lambdabot>   (7,8)
14:59:24 <pokoko222> janiczek wont have time now but i wanted to do Skiena book programming challenges, do that instead of euler, much better
14:59:25 <pr> @type divMod
14:59:25 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
14:59:29 <pr> @type quotRem
14:59:30 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
14:59:37 <pokoko222> janiczek plus there is video course by skiena himself on that
14:59:38 <erasmas> pokoko222: sure, but I'm not talking about phoenix.edu. are you saying someone who didn't learn advanced math or haskell in school shouldn't seek self improvement?
14:59:59 <c_wraith> telephone_: if you don't need them to be identical operators, you can usually find a workaround involving two infix operators.
15:00:00 <janiczek> erasmas: well I'm still figuring out if I did the right thing signing up to math ... it's a lot of FUN for me, I can spend hours browsing through math/programming-related wiki articles, but I can't say I had good grades in math at high school :)
15:00:10 <pokoko222> erasmas i dont know your background in math and programming, you will be best to judge for yourself ;)
15:00:13 <janiczek> pokoko222: will look at Skiena, thanks
15:00:30 <mike-burns> You can totally teach yourself math or programming without going to a school for it.
15:00:31 <pokoko222> janiczek seriosly do it, the guy had a team that won ACM
15:00:54 <pokoko222> janiczek another good book of him is algorithms design manual, bookmark these two i told u
15:00:58 <ddarius> tech2: I did explain.  Also, I was talking about the VMs (there) not the languages on top of them.
15:01:29 <pokoko222> mike-burns that is bunch of crap sorry
15:01:31 <janiczek> pokoko222: did already :) thanks a lot.
15:01:46 <mike-burns> pokoko222: Apology accepted.
15:02:33 <iFire> hmm I wonder how much effort it'll be to write a haskell openid provider
15:02:36 <janiczek> pokoko222: does he explain the things in the challenges books? I'd like to have something similar to the PE solved-problems-forums
15:02:56 <iFire> I looked up openid and authenticate
15:02:57 <telephone_> c_wright: it is possible to define a single infix operator (<-@) which connects all the 'outputX' together. But n+1 terms has n operators, which is one less...
15:03:09 <erasmas> pokoko222: I can't tell if you're being sarcastic, but there is no one true path to learning that only occurs at one point in every individual's life.
15:03:15 <iFire> authenticate looks to be alive
15:04:00 <pokoko222> janiczek well he talks about stuff in the video lectures
15:04:06 <drbean> @src lookup
15:04:06 <lambdabot> lookup _key []          =  Nothing
15:04:06 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
15:04:06 <lambdabot>                         | otherwise = lookup key xys
15:04:32 <pokoko222> janiczek but he suposes you already had some programming courses, that you are not a noob
15:04:41 <HugoDaniel> how do i change f :: Int -> Int -> Int -> Int into: fm :: Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int ?
15:04:48 <HugoDaniel> is there some magical operator ?
15:04:51 <ddarius> liftA3
15:05:03 <ddarius> or liftM3
15:05:13 <roconnor> @type liftM3
15:05:14 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
15:05:23 <parcs> liftA2?
15:05:34 <pokoko222> janiczek anyways good luck solving, that way you will learn the most, i wish i had time to do skiena but i just finished big part of CLRS and now i have to work on something else
15:05:37 <parcs> :t liftA2 . join
15:05:38 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> a -> b -> c) -> f a -> f b -> f c
15:06:06 <roconnor> HugoDaniel: if you are feeling very magical you can also write f <$> maybex <*> maybey <*> maybez
15:06:15 <tech2> gah
15:06:20 <parcs> oh nevermind i can't count
15:06:59 <roconnor> @src liftA3
15:06:59 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:07:27 <HugoDaniel> roconnor: yes!
15:07:29 <HugoDaniel> oh ok
15:08:53 <telephone_> c_wraith, benmachine: to solve my multifix operator, I might use template Haskell. but I only want syntactic sugar, so it is not very important!
15:09:07 <benmachine> telephone_: try a quasiquoter perhaps
15:13:19 <augur> edwardk: ping
15:16:44 <drbean> @src last
15:16:45 <lambdabot> last [x]    = x
15:16:45 <lambdabot> last (_:xs) = last xs
15:16:45 <lambdabot> last []     = undefined
15:26:42 <Dashkal> :t <$>
15:26:43 <lambdabot> parse error on input `<$>'
15:26:48 <Dashkal> :t (<$>)
15:26:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:27:02 <Dashkal> :t (<*>)
15:27:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:31:11 <hpaste> dpratt71 pasted “type functions example” at http://hpaste.org/49892
15:31:37 <dpratt71> question about what I just pasted (take from http://research.microsoft.com/~simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf):
15:32:08 <dpratt71> in the definition of MkEdge1, is 'Vertex G1' equivalent to Int?
15:41:41 <edwardk> dmead: sclv
15:42:35 * hackagebot compressed 0.1 - Compressed generators and reducers  http://hackage.haskell.org/package/compressed-0.1 (EdwardKmett)
15:42:46 <edwardk> lz78 as a monad ;)
15:43:16 <djahandarie> edwardk, so what did you decide to do with Boston Haskell?
15:43:28 <edwardk> djahandarie: going to do it later this month
15:44:33 <dpratt71> what's Boston Haskell?
15:44:42 <edwardk> boston haskell user group
15:44:50 <edwardk> meets every 1-3 months or so
15:45:00 <edwardk> more frequently when i'm less busy ;)
15:45:07 <dpratt71> hmm
15:45:31 <dpratt71> 4 hrs away, but it might be worth it
15:45:50 <danharaj> only if there's free food
15:45:51 <danharaj> and booze.
15:46:04 <mokus> the free monads aren't enough?
15:46:08 <edwardk> its usually done as a pair of talks on MIT's campus, one targeted towards the entry level or at least not assuming mastery and one that is allowed to talk about anything ;)
15:46:12 <danharaj> oh you
15:46:15 <mokus> :)
15:46:28 <danharaj> edwardk: Do you all put on robes and wizard hats for the second talk? :)
15:46:32 <edwardk> there is usually free food, but alas no booze. though we do go out for drinks at the cambridge brewing company
15:46:54 <edwardk> heh
15:46:58 <benmachine> cofree cofood?
15:47:13 <danharaj> you're not supposed to have more than one co in a term :\
15:47:19 <danharaj> it's like a law or something
15:47:23 <edwardk> trying to bring myself to code an efficient version of Adjustable for LZ78.
15:47:25 <benmachine> so sue me
15:47:28 <danharaj> it should be cofree monads and free comonads.
15:47:50 <edwardk> danharaj: actually coassociative counital coalgebras are the way its said in algebra ;)
15:47:51 <dpratt71> what's the typical # in attendance?
15:48:03 <hatds> come for the free monads, stay for the free comonads
15:48:05 <edwardk> dpratt71: varies, 10-27 or so
15:48:13 <shachaf> danharaj: I guess they never drink cocoa?
15:48:21 <edwardk> hatds: the comonads are actually cofree ;)
15:48:29 <edwardk> hatds: right adjoint not left to a forgetful functor
15:48:37 <danharaj> shachaf: clever.
15:48:45 <olsner> edwardk: are there no free comonads?
15:49:02 <olsner> or cofree monads?
15:49:13 <edwardk> olsner: go look for one and report back =P
15:49:22 <bscarlet> where does one find out when "later this month" will turn out to be?
15:49:36 <shachaf> danharaj: Do you go to the meetings?
15:49:39 <edwardk> bscarlet: i usually email the list about 2-3 weeks before hand
15:49:48 <danharaj> shachaf: Alas I am in New York.
15:49:48 <edwardk> bscarlet: there is a boston haskell mailing list one sec.
15:50:06 <shachaf> By the way, there's apparently going to be a mini-hackathon in San Francisco in ~2 weeks.
15:50:10 <shachaf> Everyone should come.
15:50:15 <olsner> edwardk: maybe I'll do that once I've figured out what free, cofree and comonad mean :P
15:50:32 <edwardk> http://groups.google.com/group/bostonhaskell?pli=1
15:51:03 <edwardk> i've been trying to find a usable space with wifi to run one in boston
15:51:26 <edwardk> MIT lets us use the reading room, but it may be problematic to get everyone wireless access
15:51:43 <danharaj> wireless access? pff. BYOEC
15:51:50 <edwardk> I'm hoping to get some place nearby like akamai to let us use their conference room for the weekend
15:51:51 <danharaj> and just have 10 or so routers ready.
15:52:23 <edwardk> but until i get a confirmed location i can't really do much
15:53:03 <edwardk> anyone feel like poking at https://github.com/ekmett/compressed/blob/master/Data/Compressed/Internal/LZ78.hs and seeing if there are any obvious bugs?
15:53:47 <edwardk> (cabal install compressed) will get it
16:03:31 <Ivan64> I'm on the Try Haskell page and using the chat session in a side panel of my chrome browser.
16:03:50 <c_wraith> Ivan64: welcome.  how's it going?
16:04:22 <Ivan64> I'm in the tutorial and I don't know if I'm looking at the correct encoding.
16:05:13 <Ivan64> Step 10 says to type 'a' : [] which gives me "a" and not ['a']
16:05:30 <c_wraith> Ivan64: they're equivalent
16:05:47 <c_wraith> Ivan64: try this expression:  "a" == 'a':[]
16:05:58 <edwardk> ivan64: in haskell a string is a list of chars with some syntactic sugar on top
16:05:59 <djahandarie> Or  "a" == ['a']
16:06:08 <erus`> posting haskell questions on stackoverflow = chooo chooo all aboard the karma train!
16:06:10 <edwardk> > ['a']
16:06:11 <lambdabot>   "a"
16:06:16 <edwardk> > head "a"
16:06:17 <lambdabot>   'a'
16:06:22 <edwardk> > tail 'a'
16:06:23 <lambdabot>   Couldn't match expected type `[a]'
16:06:23 <lambdabot>         against inferred type `GHC.Types...
16:06:25 <edwardk> er
16:06:28 <edwardk> > tail "a"
16:06:29 <lambdabot>   ""
16:06:30 <erus`> 20 upvotes per answer
16:06:43 <Ivan64> I see now.
16:06:57 <c_wraith> List of characters are just shown in a special way.
16:07:00 <edwardk> > map fromEnum "hello"
16:07:01 <danharaj> sometimes I wish fromIntegral were one symbol long.
16:07:01 <lambdabot>   [104,101,108,108,111]
16:07:19 <djahandarie> danharaj, your solution is only a line away ;)
16:07:30 <djahandarie> Though one could probably say that about anything in Haskell... :)
16:07:33 <shachaf> danharaj: With constants, it's zero symbols long!
16:07:38 <danharaj> djahandarie: Can't make a unary operator :\
16:07:50 <edwardk> djahandarie: nah, function application can take 0 ;)
16:07:59 <shachaf> danharaj: Sure you can.
16:08:09 <danharaj> nuh uh
16:08:27 <danharaj> wait, can you? I swore you couldn't.
16:08:33 <shachaf> > let u = fromIntegral in u (5::Int) + 1.0
16:08:34 <lambdabot>   6.0
16:08:37 <shachaf> Unary.
16:09:02 <shachaf> > let (!) n = product [1..n] in (5!)
16:09:02 <lambdabot>   120
16:09:05 <shachaf> More unary!
16:10:15 <Ivan64> So "a" is the list with one character 'a'. What is 'a'? The character a?
16:10:18 <shachaf> a
16:10:21 <shachaf> Er.
16:10:25 <edwardk> ivan64: yep
16:10:35 <shachaf> That was mistyped.
16:11:21 <c_wraith> :t 'a'
16:11:21 <lambdabot> Char
16:12:12 <shachaf> @ty a'a
16:12:13 <lambdabot> forall rahC. rahC
16:12:27 <shachaf> Bah, explicit foralls ruin everything.
16:14:06 <c_wraith> I don't even know how you tricked lambdabot into doing that.
16:14:41 <siracusa> > let foo = undefined :: foo
16:14:42 <lambdabot>   not an expression: `let foo = undefined :: foo'
16:14:43 <c_wraith> oh.  just an explicit rigid type variable
16:14:44 <aavogt> @ty let x = undefined :: funnytyvar in x
16:14:45 <lambdabot> forall funnytyvar. funnytyvar
16:18:02 <hpaste> wjlroe pasted “Aeson problems ” at http://hpaste.org/49895
16:19:22 <Ivan64> The tutorial in step 10 needs to be clarified. It's confusing to a complete beginner that ['a'] and "a" are semantically equivalent.
16:19:32 <hpaste> wjlroe annotated “Aeson problems ” with “Aeson problems  (annotation)” at http://hpaste.org/49895#a49896
16:20:07 <Ivan64> I'm using the Try Haskell web interface, and I think it's neat.
16:20:33 <sheeple> I was wondering what a Comonoidal structure would look like in haskell (akin to the Monoidal class mentioned in the latest Monad Reader) but my category foo isn't strong enough to reverse the arrows. Is there anyone here who can help? :)
16:21:15 <DrSyzygy> Is this Monad.Reader 18?
16:21:39 <sheeple> yeah
16:21:44 <DrSyzygy> Ok.
16:21:51 <sheeple> they redefine Applicative in terms of Monoidal
16:21:57 <DrSyzygy> (looking at the class definition now)
16:22:14 <DrSyzygy> You have a unit :: () -> f ()
16:22:25 <DrSyzygy> And a mult :: f a -> f b -> f (a,b)
16:22:51 <sheeple> I'm stuck at counit
16:23:11 <edwardk> sheeple: there are no interesting comonoids over set. this is why you dont find any in haskell, which acts like set
16:23:28 <DrSyzygy> So, dualizing everything in sight, I'd say that the counit should most likely be utterly trivial.
16:23:39 <DrSyzygy> It'll be f () -> (), of which there can only be one.
16:23:42 <edwardk> sheeple: a category where you do find them is the category of vector spaces
16:23:49 <edwardk> then you can talk about coalgebras as comonoids
16:23:59 <edwardk> and i have a package chock full of those =P
16:24:21 <tgeeky> edwardk: what's the spin on your new printer/parser library thing?
16:24:22 <DrSyzygy> And there, the counit is a map V -> k, such as "summing the coefficients".
16:24:40 <sheeple> heh. yeah I looked at that package once
16:24:55 <tgeeky> edwardk: forget parsers, I guess
16:25:00 <Ivan64> oh oh step 15
16:25:00 <edwardk> tgeeky: basically i started extracting a lot of code ive had lying around privately and turning it into something i can use publically
16:25:22 <tgeeky> edwardk: well, specifically, what's the reason I might use your wl-pprint library instead of using one of the several existing ones
16:25:23 <pr> @type out
16:25:24 <lambdabot> forall (t :: * -> *). Mu t -> t (Mu t)
16:25:24 <DrSyzygy> edwardk: Are there no interesting comultiplications over Set either?
16:25:49 <DrSyzygy> I fully see how the counit can only be boring, but does a boring counit force a boring comonoid?
16:25:57 <Ivan64> Step 15 says I can only have a list of numbers or a list of characters.
16:25:58 <edwardk> tgeeky: basically trifecta is intended to be a nice to use parsing library for 'human scale' parsing demands. basically parsers for things like source code, not massive quantities of xml.
16:26:04 <edwardk> DrSyzygy: there are plenty of those.
16:26:23 <edwardk> consider splittable
16:26:30 <tgeeky> edwardk: ok. is it going to integrate any of the features of invertible-syntax? or is it more general?
16:26:50 <edwardk> tgeeky: no, i don't go down that road. i don't believe in invertible computing as a rule =P
16:27:10 <edwardk> mainly because the bidirectional lens guys haven't managed to get things to work nicely enough to be worth the pain
16:27:35 * hackagebot reducers 0.1.1 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-0.1.1 (EdwardKmett)
16:27:39 <edwardk> i am however integrating part of the tokenization for pretty printing purposes into the parser. it'll make more sense when its integrated
16:28:04 <tgeeky> edwardk: is there a use case where your library would be obviously better?
16:28:08 <edwardk> as for why wl-pprint-extras or wl-pprint-terminfo over what is already out there? wl-pprint-extras gives you an extensible pretty printer
16:28:16 <hpaste> fragamus pasted “RandT/MonadPlus” at http://hpaste.org/49897
16:28:24 <tgeeky> i'm aware of the several generic wl pprinters, the one with source line locations, and 'mpppc'
16:28:29 <edwardk> i use that functionality in wl-pprint-terminfo to let me pretty print to a terminal with color, bold, blinking, etc.
16:28:53 <tgeeky> edwardk: would you like me to test it in Windows / MSYS / cygwin?
16:29:14 <edwardk> but it is just a monad, so you can transform it, and use that to implement precedence on top for instance
16:29:24 <edwardk> feel free. its just using the terminfo package
16:29:30 <edwardk> so it should work wherever that is supported
16:29:51 <tgeeky> edwardk: I think MSYS fakes that package, so it might be incompatible. but I'll check it out.
16:30:14 <edwardk> what should be coming soon is my diagnostics package (or it'll get folded into trifecta), which supports clang style diagnostics
16:30:42 <edwardk> which uses trifecta's cursor machinery to just make it so i can automatically give you carets into source locations, with highlighted ranges, etc
16:30:47 <tgeeky> btw, is there some sort of drug you take that makes you work 26 hours a day producing all of this abstract haskell code?
16:30:52 <edwardk> using the terminfo pretty printer to get colored errors, etc.
16:31:05 <tgeeky> edwardk: that sounds nice
16:31:53 <edwardk> anyways if terminfo builds but fails to run, it should degrade relatively gracefully.
16:32:32 <edwardk> i'd like to just give you compile flags but i expose parts of the actual terminfo api through mine, so i can't really just degrade where it doesn't work
16:32:59 <sheeple> edwardk: I was wondering, how many of the abstractions in your algebra package have actually found a real use? is your goal mostly to just make everything fit in an as elegant framework as possible? or hhm
16:32:59 <tgeeky> ok, i'll let you know
16:33:11 <tgeeky> are you developing this on 7.2 or 7.0?
16:33:12 <edwardk> anyways the other thing that trifecta does interestingly is it aggressively hash conses a lot of structures
16:33:42 <edwardk> sheeple: i'm using the geometric algebra. i'm also using some pade approximant machinery on top for function approximation. i'll be integrating it shortly
16:34:35 <applicative> tgeeky, you can always a package 'algebra-examples' or something ...
16:34:35 <edwardk> but i need a good notion bezout domains and prufer domains to be integrated for all of that. some of the intermediate layers are there just because they fit the general framework and provide a proof of concept of bigger ideas
16:34:47 <edwardk> i'm on 7.0 right now
16:34:55 <tgeeky> applicative: -->
16:35:06 <edwardk> i did bump up the base cap though because some users are on 7.2
16:35:47 <edwardk> anyways it was mining through that old code that made me want to resurrect my old LZ78 compressive generator, etc.
16:36:18 <edwardk> then i realized i could make a usable monad, etc. out of that type
16:36:27 <edwardk> and there went my afternoon
16:36:29 <applicative> maybe the now separate thing about recursion-schemes-examples would be cool
16:36:58 <applicative> i mean an associated examples package.  It would be fun to make.
16:37:12 <tgeeky> edwardk: you throw invertible-syntax (partial-isomorphisms) in the same vein as all of the lens work?
16:38:08 <fragamus> edwardk: can you have a look at my paste
16:38:12 <edwardk> it has the same set of problems, needing neat embedding projection pairs, using restored invariants, etc.
16:38:57 <edwardk> fragamus: you need RandT $ StateT $ \_ -> mzero
16:39:02 <edwardk> or RantT mzero
16:39:04 <edwardk> for instance
16:39:11 <edwardk> the actual StateT constructor goes inside
16:39:54 <edwardk> i don't particularly like the bidirectional lens stuff, it neither subsumes nor is subsumed by the notion of a functional reference
16:40:11 <edwardk> there is a common pullback though which hasn't really been explored. i should write that up
16:43:30 <tgeeky> edwardk: how would you approach making ASCII tables like those on this page ( https://github.com/cldwalker/hirb ), but which can be written to file and re-read as configuration settings?
16:44:15 <edwardk> hrmm
16:44:31 <edwardk> probably with lots of manual hacks
16:45:35 <edwardk> i guess you could define an axis aligned graph of some sort to start, hunt through for +'s, then try to connect them with -'s and |'s to find the outlines
16:46:11 <tgeeky> hehe.
16:46:19 <applicative> fragamus, is this RandT from the MonadRandom package?
16:46:19 <tgeeky> the characters in the graph are variants
16:46:30 <tgeeky> no worries
16:46:34 <tgeeky> i'm gonna do it in ruby first, then haskell second
16:47:20 <edwardk> applicative: yes
16:47:30 <edwardk> applicative: he wants a monadplus, and cale didn't give him one
16:47:35 * hackagebot compressed 0.1.1 - Compressed generators and reducers  http://hackage.haskell.org/package/compressed-0.1.1 (EdwardKmett)
16:47:47 <applicative> baffling, for me it isn't exporting the constructors, of which there is one: RandT
16:48:01 <applicative> so the instance cant get started
16:48:41 <fragamus> applicative: yes
16:49:03 <fragamus> I copied the code inline
16:50:05 <fragamus> Strange that the authors of RandT, who seem so devoted to encapulation, would favor having everyone copy the code and make their own versions of it
16:50:09 <applicative> doesn't that seem insane? there are ways to destruct a RandT exported, but no way to construct one. (Or is that mysterious rational in this case?)
16:50:34 <tgeeky> cleverly enforcing entropy laws? *grin*
16:51:14 <applicative> I looked at them a long time ago in connection with the excellent tutorial posts of E Kidd, but the thing is always a mess somehow
16:52:11 <edwardk> applicative: personally it strikes me as silly
16:52:59 <edwardk> but i've been bitten enough by over-encapsulated APIs (i'm looking at you Data.Text!) that i tend to export internal modules for everything
16:54:04 <edwardk> and from there i rely on a scheme that says i change the first digit of the minor version when i can break someone who depends on my internals modules
16:54:07 <applicative> I notice that Kidd is listed as the maintainer, Cale  et al as authors, and the lastest version (it was breaking for several versions of ghc) was uploaded by chrisdone.
16:54:46 <applicative> fragamus, maybe you should make a rational MonadRandomer package
16:55:49 <fragamus> woe thanks i made progress!
16:56:07 <Cale> I originally just wrote the code as an example and put it on the Haskell Wiki, and other people took it and made it into a package.
16:56:43 <applicative> see, it's all your fault, casual haskelling, can lead to ... hackages?
16:56:56 <applicative> Cale, you should be more responsible...
16:57:12 <fragamus> I have it!!!
16:57:19 <fragamus> it is awesome!!!
16:57:47 <fragamus> now I can use ListT and RandT together and my guards work!!!!
16:58:08 * tgeeky basks in rays of awesomeness
16:58:35 <fragamus> * beaming with gratitude for the awesome haskellers here
16:59:01 <applicative> fragamus, I adjusted my version of MonadRandom with Rand(..), RandT(..)  and reinstalled so now I can follow you
16:59:09 <edwardk> cale: can you export the constructor?
16:59:22 <fragamus> cool
16:59:36 <edwardk> and poke at fragramus's idea of letting it have a monadplus? i haven't checked it for validity
16:59:37 <fragamus> lemme put my paste together for ya
17:00:00 <edwardk> as it stands right now he's shut out and can't do anything with it
17:01:14 <hpaste> fragamus pasted “thanks edwardK” at http://hpaste.org/49898
17:01:29 <applicative> edwardk, there is a mysterious comment, "-- but not the data constructors" in the list of exports.  But that there is also no function to build one seems ...odd.
17:02:34 <fragamus> This is so much better than using IO for randomness
17:04:15 <applicative> Now make a MonadZip instance so we can use it with the upcoming 'monad comprehensions', in particular parallel monad comprehensions
17:04:27 <fragamus> because RandT is like StateT and it is pure even though it is monadic
17:04:40 * applicative has been reading about it in the Monad Reader
17:05:16 <fragamus> man all this is so over my head but I'm just going to keep slogging ahead
17:05:17 <edwardk> fragramus: anyways the monadplus is probably missing for a reason.  ;)
17:05:35 * ddarius sees little sense in parallel list comprehensions, and not all that much in list comprehensions in general.
17:06:01 <ddarius> +even
17:06:07 <fragamus> * cant figure out how you guys post remarks that start with *
17:06:42 <mustelo> fragamus, /me probably
17:06:51 * fragamus learned something
17:07:00 <applicative> ddarius, did you see the parser example, it seemed kind of cool.
17:07:21 * applicative somehow regrets that one stops using list comprehensions after Week 3 of Haskell.
17:07:22 <mustelo> which monad.reader is this in?
17:07:31 <applicative> the newest?
17:07:44 <applicative> http://themonadreader.files.wordpress.com/2011/07/issue18.pdf -- mustelo
17:07:48 <mustelo> woot, thanks
17:09:31 <applicative> the MonadZip function, mzip is m a -> m b -> m (a,b)  .  I take it the point is that you can interpret this differently as in the case of ZipList?
17:10:07 <ddarius> "one stops using list comprehensions after Week 3 of Haskell" ??
17:10:22 <applicative> obviously a general definition follows from the monad instance, but it might not be the one you want for parallel comprehensions -- I guess
17:10:52 <applicative> ddarius, I was going to write "week n"  They do seem to go away, not just because #haskell runs them down....
17:11:29 <edwardk> https://github.com/ekmett/compressed/blob/master/Data/Compressed/Internal/LZ78.hs has lots of list comprehensions in it. sometimes they are nicer, especially when doing lots of pattern matching
17:11:44 <applicative> nevertheless they are lovely, so I harbor the goofy hope the generalization might catch on
17:11:59 <applicative> edwark, there are very good counter examples
17:12:22 <ddarius> do-notation seems to better fit most monads, so I don't expect that aspect of the generalization to make a big splash.
17:12:30 <applicative> edwardk, I was thinking they were also professors teaching haskell to undergraduates though.
17:13:27 <applicative> ddarius, probably.  But it is all a matter of what strikes people as elegant, intelligible, economical.  It might be so for some cases
17:13:40 * applicative grants probably not.
17:14:27 <ddarius> applicative: I'm not saying that there are never cases where list comprehensions or monad comprehensions won't be better in some way, and I'm certainly not saying that people won't/don't find it so (many seem enamored to list comprehensions.)
17:14:43 <dolio> Might be good for Maybe.
17:16:01 <dolio> Also non-list nondeterminism implementations.
17:22:18 * ddarius has a desire for some 1930s-ish, hokey, sci-fi/fantasy reading.
17:23:04 <paqnsp_> uh
17:23:20 <edwardk> ddarius: you can swing by and grab an old edgar rice burroughs novel or something if you want
17:23:39 <ddarius> edwardk: My friend has been telling me to read some of them.
17:23:49 <ddarius> I might do just that.  I was about to head out to get a sub.
17:24:02 <edwardk> i'm on my way home now, i shoud be there in about 30 minutes
17:24:05 <edwardk> (at the office)
17:24:35 <iFire> ddarius http://www.magicdragon.com/UltimateSF/timeline1940.html
17:24:37 <iFire> take a look
17:46:59 <amindfv> anyone know of a library that can return volume values, from an audio file?
17:54:17 <aavogt> kmc: did you figure out that stack overflow with parMap?
17:54:51 <kmc> no, i got your message though
17:54:52 <kmc> thanks
18:03:58 <RomyEatsDrupal> anyone recommend a good Haskell guide or book for a total n00b?
18:04:13 <RomyEatsDrupal> i'm so n00b it's not even funny :(
18:04:17 <kmc> @where LYAH
18:04:17 <lambdabot> http://www.learnyouahaskell.com/
18:04:21 <kmc> that one
18:04:29 <RomyEatsDrupal> i hear that book is kind of rough for a total n00b too though
18:04:42 <kmc> well, it's as gentle as i know
18:04:56 <kmc> i wouldn't trust all of what you hear about Haskell
18:05:19 <RomyEatsDrupal> thank you kmc
18:05:28 <RomyEatsDrupal> as long as it's very gentle
18:05:37 <kmc> no book is going to eliminate the fact that learning an *actually* new language, as opposed to a new syntax for Java, is hard
18:05:47 <kmc> anyway you should feel free to ask questions here if you run into trouble
18:06:15 <applicative> LYAH is good, RomyEatsDrupal    People here can help you with any difficulties.  Just paste problematic code on hpaste and ask why the compiler objects... :)
18:06:29 <RomyEatsDrupal> Sigh
18:06:36 <RomyEatsDrupal> Such a kind community!
18:06:40 <RomyEatsDrupal> Deeply moved.
18:06:43 <RomyEatsDrupal> Thank you SO much
18:06:44 <coppro> RomyEatsDrupal: are you a Haskell noob or a programming noob?
18:06:56 <RomyEatsDrupal> Coppro I'm both  ((blush blush))
18:07:01 <coppro> RomyEatsDrupal: Ok
18:07:02 <RomyEatsDrupal> well my background is i'm a web designer
18:07:15 <coppro> RomyEatsDrupal: How much Javascript experience?
18:07:19 <RomyEatsDrupal> i tried learning PHP on my own a handful of times through the years, but failed
18:07:34 <RomyEatsDrupal> then this past week i decided i will, at whatever cost, teach myself Ruby
18:07:46 <RomyEatsDrupal> i spent a few hours absorbing terms earlier this week.
18:08:06 <RomyEatsDrupal> then on my flight from New York to Los Angeles yesterday, it all clicked
18:08:11 <RomyEatsDrupal> well - at least the very basics
18:08:14 <coppro> cool
18:08:16 <kmc> RomyEatsDrupal, PHP is basically the worst language.  here are some quotes from its "designer": http://en.wikiquote.org/wiki/Rasmus_Lerdorf
18:08:39 <RomyEatsDrupal> I was moved nearly to tears when suddenly, the light bulb went off, and I understood Ruby's ternary operator
18:08:47 <RomyEatsDrupal> so, so, so, beautiful…. so concise, so clear
18:08:56 <RomyEatsDrupal> so simple and easy, yet so nice!
18:09:02 <dpratt71> regarding this: http://hpaste.org/49892 can someone confirm for me that Vertex G1 is equivalent to Int?
18:09:02 <mauke> uh, ok
18:09:07 <RomyEatsDrupal> what a beautifully placed question mark!
18:09:09 <coppro> RomyEatsDrupal: Well, if you can get a handle on it, it sounds like you'll enjoy Haskell
18:09:12 <mauke> we call it if/then/else here
18:09:19 <RomyEatsDrupal> anyway, the reason why i bring up ruby
18:09:26 <RomyEatsDrupal> is because before ruby, i wanted to teach myself Haskell
18:09:34 <kmc> dpratt71, yes
18:09:39 <RomyEatsDrupal> the idea of a purely functional  / declarative language is a fascinating concept
18:09:47 <dpratt71> kmc: ok, thanks
18:09:48 <coppro> yeah
18:09:54 <coppro> RomyEatsDrupal: I would recommend trying LYAH
18:09:55 <RomyEatsDrupal> very enticing, however, not really something a total n00b should embark
18:10:10 <RomyEatsDrupal> so I figured--- since Ruby is multi-paradigm
18:10:14 <kmc> some say Haskell is easier to learn if you are new to programming in general
18:10:20 <kmc> also, Haskell is multi-paradigm
18:10:27 <kmc> i write a lot of imperative code in Haskell, and some functional too
18:10:33 <RomyEatsDrupal> if I can get myself to learn basics of Ruby, then I may dare be so bold as to stomach Haskell
18:10:34 <kmc> err
18:10:35 <kmc> some OOP
18:10:38 <RomyEatsDrupal> wow really?
18:10:40 <kmc> some functional as well ;)
18:10:41 <kmc> yeah
18:10:42 <RomyEatsDrupal> Haskell can do OOP also?
18:10:42 <coppro> RomyEatsDrupal: Yeah
18:10:51 <kmc> RomyEatsDrupal, sure, these things are just styles
18:10:53 <RomyEatsDrupal> sigh!!!  sounds so cool
18:11:03 <RomyEatsDrupal> so you guys are familiar with Scala too, I guess?
18:11:04 <kmc> languages have features to help or hinder a particular style
18:11:10 <coppro> I'm not familiar with Scala
18:11:15 <copumpkin> kmc: wow, those are some pretty valuable quotes
18:11:35 <kmc> RomyEatsDrupal, the Linux kernel is written in C and makes heavy use of functional, OOP, and aspect-oriented styles
18:11:38 <coppro> C++ does functional code too, for instance, but not as elegantly as Haskell or Lisp
18:11:54 <dpratt71> RomyEatsDrupal: people who like Haskell tend to be polygots
18:12:06 <RomyEatsDrupal> dpratt71:  indeed, that's what i have observed
18:12:21 <RomyEatsDrupal> that, and those who like lisp and the sharp's, tend to be programming polyglots
18:12:32 <RomyEatsDrupal> I myself am a polyglot, but alas- in foreign languages, not programming
18:12:33 <kmc> RomyEatsDrupal, anyway, I encourage you not to get hung up on "paradigms"... it really is an antiquated concept at best
18:12:45 <coppro> I agree with kmc
18:12:47 <RomyEatsDrupal> Duly noted, kmc
18:12:57 <dpratt71> RomyEatsDrupal: I wouldn't qualify that as "alas" at all
18:13:02 <kmc> the "paradigm" concept would suggest that, at best, your imperative Haskell code should be separate from your functional Haskell code, but I've noticed the opposite
18:14:18 <RomyEatsDrupal> Hm, I really did not know Haskell does OOP, also
18:14:50 <kmc> that's the wrong way to phrase it
18:14:51 <RomyEatsDrupal> I have much energy and excitement for it- primarily because I see it's been developed by mathematicians
18:14:55 <kmc> you can do OOP in Haskell
18:14:55 * roconnor wonders what the complexity of computing matrix asteration is
18:15:01 <kmc> you can do OOP in C or assembly
18:15:11 <kmc> it is a style of code, not a language feature
18:15:13 <RomyEatsDrupal> like Scala's Odersky
18:15:14 <kmc> languages have features to help or hinder a particular style
18:16:03 <dylukes> kmc: I've noticed you, myself and others have come to this conclusion or rehashed it way too often.
18:16:12 <dylukes> Can we get a conveniently linkable blog post on this matter?
18:16:20 <dylukes> So it doesn't have to be reexplained every time...?
18:16:27 <dylukes> Perhaps even a lambdabot @where to bring it up
18:16:28 <kmc> RomyEatsDrupal, Haskell isn't really designed by mathematicians.  it's designed by people who programmers would consider to be mathematicians and mathematicians would consider to be programmers
18:16:37 <RomyEatsDrupal> If I am new to programming, and I am teaching myself Ruby, would it hinder me in my joint endeavors to learn both Ruby and Haskell concurrently?
18:16:40 <copumpkin> this is why I wanted a @kmc command
18:17:02 <kmc> RomyEatsDrupal, Haskell is a programming language designed by people who have studied in detail the problem of how to design programming languages
18:17:08 <kmc> which, it turns out, is hard
18:17:11 <Axman6> RomyEatsDrupal: they're extremely different languages
18:17:16 <dylukes> RomyEatsDrupal: They're really very very different. It would be interesting.
18:17:18 <kmc> for some reason most languages are designed by people who have no idea what they're doing
18:17:40 * kmc is sounding more and more like a bitter conspiracy theorist
18:17:46 <RomyEatsDrupal> I just trepidations I would end up severely confusing myself.  I just think I'm nowhere near being gifted in that way
18:18:08 <RomyEatsDrupal> I have been creatively and visually oriented all my life, yet fascinated by the concepts of programming
18:18:29 <RomyEatsDrupal> Programming, when done well, is another dimension of creativity and artful expression
18:18:49 <RomyEatsDrupal> After Ruby's ternary operator made *sense*, i found myself staring out the airplane window looking down at the tops of wispy clouds
18:19:20 <RomyEatsDrupal> watching but not really 'seeing', per se, and noting to myself, "how beautiful, beautiful, beautiful the world can be" ---- even virtual worlds
18:19:38 <RomyEatsDrupal> it took me a long time to get to that point, however. hours and hours.
18:20:09 <Axman6> haskell is a beautiful language, but it takes many programmers a while to see that
18:20:10 <dylukes> If the ternary operator had that kind of effect on you...
18:20:26 <Axman6> usually because they've been tainted by other, lesser languages >_>
18:20:36 <dylukes> Haskell will be like LSD, Sex and high school crushing rolled into one package.
18:20:37 <RomyEatsDrupal> yes, yes, dylukes , even I in my n00b forays can recognize the ternary operator is VERY simple and basic logical expression
18:20:42 <dylukes> In multiple waves,
18:20:45 <RomyEatsDrupal> ***sigh***
18:20:51 <RomyEatsDrupal> i am totally seduced!
18:20:59 <RomyEatsDrupal> ((swoon))
18:21:34 <RomyEatsDrupal> i'm officially addicted to this room.  i will report my learning process and hope that people can orient me in better directions if i am taking clumsy paths
18:21:53 <RomyEatsDrupal> because i can waste away HOURS staring at terms in vain, struggling to understand the concepts, but getting increasingly lost
18:22:10 <dylukes> Write code. If it doesn't work try again. If it does, celebrate, then try again.
18:22:18 <RomyEatsDrupal> then i end up being depressed and feeling incredibly stupid for hours :(  but i think my approach was not good.
18:22:22 <dylukes> Play a drinking game. Every time you see a type error, take a shot.
18:22:37 <RomyEatsDrupal> no way dylukes , i stay away from alcohol.  i'm already pretty insane as is.
18:22:48 <Nimatek> dylukes: Not a good idea for Haskell beginners
18:22:52 <RomyEatsDrupal> i'm new to linux, but i became quite addicted a few weeks ago
18:23:00 <dncr> Nimatek: nor drinking beginners
18:23:09 * dylukes suggests zsh and emacs for additional programmatic orgasms.
18:23:10 <RomyEatsDrupal> i set up my very first virtual machine (debian) a couple weeks ago, and installed Haskell onto it
18:23:10 <Nimatek> dncr: Indeed :D
18:23:24 <RomyEatsDrupal> (whispers) i'm VI all the way
18:23:36 <dylukes> Not even vim.
18:23:39 <dylukes> ¬___¬
18:23:43 <RomyEatsDrupal> lol lol lol
18:23:49 <RomyEatsDrupal> (hands in the air) alright you got me
18:23:55 <RomyEatsDrupal> but i always type 'vim'
18:23:58 <dylukes> I've noticed this shocking trend where most people who claim to be "stolid emacs/vim users"
18:24:03 <dylukes> really just haven't used the other one at all,
18:24:09 <dylukes> and have gone with the first one they learned.
18:24:19 <RomyEatsDrupal> dylukes: ahem… i have an emacs book waiting for me back in NY in my apartment
18:24:24 <RomyEatsDrupal> BECAUSE
18:24:27 <dylukes> ...book?
18:24:34 <RomyEatsDrupal> the first time i tried to do Haskell in Terminal (I have a mac)
18:24:44 <RomyEatsDrupal> I found out I Needed to download the entire package/compiler
18:24:48 <dylukes> So do I. :| I do all my haskell in emacs.
18:24:58 <RomyEatsDrupal> but in emacs, the dev environment allows Haskell very fluidly
18:25:04 <RomyEatsDrupal> anyway
18:25:06 <dylukes> install haskell pltform,
18:25:10 <dylukes> install haskell-mode for emacs
18:25:13 <dylukes> thats all you need to do
18:25:22 <RomyEatsDrupal> easier said than done for a linux n00b, dylukes
18:25:36 <dylukes> Neither of those is intrinsically linux.
18:25:39 <dylukes> at all.
18:25:45 <RomyEatsDrupal> at one point i had glorious haskell compiler (!!!! "glorious!!" so cute!!)
18:25:50 <RomyEatsDrupal> running in my terminal
18:25:59 <RomyEatsDrupal> and i played around with basic haskell logical expressions- like math
18:26:11 <RomyEatsDrupal> and then 2 days ago my 3 year old macbook DIED.  hard drive failure
18:26:24 * dylukes just replaced his hard drive with a shiny Intel SSD.
18:26:35 <RomyEatsDrupal> i took it to the apple store and the apple employee sadly reported it was deceased.
18:26:43 * dylukes sealed enclosure, 1500G max shock, 5 year warranty.
18:26:49 <RomyEatsDrupal> i ended buying a Macbook air with an entire paycheck
18:26:52 <dylukes> Btw.
18:26:53 <dylukes> Protip.
18:26:57 <roconnor> If I learn how to compute matrix asterations, then I can solve any graph optimization problem or linear algebra problem for free :D
18:26:58 <dylukes> Stop wasting time gushing, and write some code.
18:27:07 <dylukes> You could have learned GADT's in the time you just spent typing all of this.
18:27:10 <RomyEatsDrupal> anyway, i'm getting to that point
18:27:14 <RomyEatsDrupal> so as of NOW
18:27:27 <RomyEatsDrupal> I no longer have the Haskell compiler in my terminal
18:27:36 <tmvphil> asteration?
18:27:40 <RomyEatsDrupal> because my Mac unix bash doesn't recognize aptitude or apt-get install
18:27:48 <dylukes> *blinks*
18:27:51 <dylukes> are you shitting me?
18:28:01 <dylukes> aptitude is a linux (debian really) manager.
18:28:04 <dylukes> of course its not on OS X.
18:28:14 <RomyEatsDrupal> yup
18:28:16 <dylukes> you might find this similar
18:28:17 <dylukes> http://mxcl.github.com/homebrew/
18:28:27 <RomyEatsDrupal> on my previous computer, i had Debian as a virtual machine, which i used to get haskell
18:28:37 <dylukes> homebrew is relatively idiot-proof.
18:29:06 <dylukes> Note, if you're on OS X Lion, GHC cannot actually compile code, just interpret, due to a linker error… but I don't see what you'd need to compile atm.
18:29:22 <dylukes> Dankna has a fixed package, but you'd have to manually manage installed stuff… that might be too much for you.
18:29:37 <RomyEatsDrupal> MataHaris-MacBook-Air:~ stickycake$ sudo apt-get ghc
18:29:37 <RomyEatsDrupal> sudo: apt-get: command not found
18:29:47 <dylukes> aptitude is the debian package manager.
18:29:50 <dylukes> you won't find it on OS X.
18:30:10 <dylukes> you won't find it on other non-debian derived linux distros either.
18:30:19 <dylukes> install brew
18:30:23 <RomyEatsDrupal> wow. thanks for the brew tip
18:30:26 <dylukes> run `brew install haskell-platform`
18:30:31 <RomyEatsDrupal> i'm on there now.  friggin awesome
18:30:33 <dylukes> That will install everything you need.
18:30:40 <hatds> does anyone know of work doing bidirectional lenses in haskell?
18:30:43 <dylukes> then install this
18:30:44 <dylukes> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
18:31:03 <RomyEatsDrupal> (Eyebrows raised) dylukes  are you converting me to Emacs...
18:31:07 <dylukes> Get to coding. Gushing doesn't build knowledge, just arrogance.
18:31:20 <dylukes> Discuss *after* the fact.
18:31:23 <dylukes> I'm guilty of this too.
18:31:30 <RomyEatsDrupal> for a total n00b, i can't gush nor exude arrogance
18:31:57 <RomyEatsDrupal> so on Lion, I do NOT need Xcode to download and install Brew?
18:32:14 <dylukes> You do.
18:32:21 <dylukes> you need the Xcode developer tools for just about everything,
18:32:30 <dylukes> since they include the llvm-gcc compiler and such.
18:32:36 <dylukes> (which you need to compile just about everything)
18:32:40 <RomyEatsDrupal> eugh
18:32:47 <dylukes> install Xcode from the mac app store
18:32:51 <dylukes> it'll take maybe 40 minutes to download.
18:33:06 <dylukes> in the mean time, start reading on haskell or something
18:33:07 <RomyEatsDrupal> this is why i wish i didn't lose my debian setup after the computer died
18:33:24 <RomyEatsDrupal> through LearnYouHaskell.  got it
18:34:25 <dylukes> you're "through" it?
18:34:32 <dylukes> Did you actually *do* anything in it?
18:34:41 <RomyEatsDrupal> what?
18:34:44 <dylukes> Believe it or not, learning something involves more than scanning a book.
18:34:51 <hatds> I think he meant "though" as in "via"
18:34:54 <hatds> *through
18:34:58 <dylukes> Did you?
18:35:04 <RomyEatsDrupal> dylukes, past a certain point, drop the condescending air.
18:35:13 <RomyEatsDrupal> hatds:  i'm a she, by the way
18:35:43 <RomyEatsDrupal> your help is appreciated, but not when you sneer ;)
18:35:50 <hatds> noted :)
18:36:00 <RomyEatsDrupal> and yes, i meant via.
18:36:24 <dylukes> Anyways… have fun with it.
18:36:35 <RomyEatsDrupal> i said that statement as a followup to dylukes  saying to read up during the 40 minute Xcode download
18:36:56 <ezyang> @seen tibbe
18:36:56 <lambdabot> Unknown command, try @list
18:36:56 <preflex>  tibbe was last seen on #ghc 2 days, 8 hours, 17 minutes and 2 seconds ago, saying: bos, you can use the haskell organization on github if it's a HP package
18:37:54 <ddarius> @tell kmc This is late, but the important thing is that Haskell was designed by people who wouldn't call themselves mathematicians and who would call themselves programmers.
18:37:55 <lambdabot> Consider it noted.
18:43:04 <coppro>  /win 114
18:43:24 <djahandarie> coppro, jesus man, close some of those windows :p
18:43:34 <coppro> djahandarie: never!
18:43:55 <ddarius> edwardk: I expect that you're home now?
18:44:19 <geekosaur> observation:  in large part, the mathematical "underpinings" of haskell are either actiually overpinnings or retrofits; in particular, category theory is a big retcon, which is why it and laziness interact rather poorly in the theoretical arena :)
18:44:52 <Cale> geekosaur: I'm not sure I agree...
18:45:19 <RomyEatsDrupal> geekosaur:  what's "Retcon" ?
18:45:21 <coppro> how does the category-theoretical stuff interact badly with non-strictness?
18:45:22 <ddarius> Actually, it's not a "retcon" really, and not really used in the "underpinnings" of Haskell (and interacts fine with laziness.)
18:45:30 <coppro> RomyEatsDrupal: tvtropes
18:45:40 <RomyEatsDrupal> uh.. huh?
18:45:44 <ddarius> @wn retcon
18:45:46 <lambdabot> No match for "retcon".
18:45:54 <roconnor> ddarius: I think geekosaur is saying that CPOs don't have coproducts.
18:46:13 <djahandarie> Man, I can't figure out how to work these damn Iteratee things. Trying to hook a file into a Data.Enumerator.List.head and I want it to end before I get Nothing from that.
18:46:22 <ddarius> roconnor: I doubt that, but even if so, so?
18:46:27 <RomyEatsDrupal> anyway, Xcode is 3 gigabytes, holy shi*, and I'm at the starbucks so I guess i am thwarted for now :/
18:47:04 <geekosaur> retcon predates tvtropes, it's from fandom.  "retroactive continuity"
18:47:17 <roconnor> ddarius: ya I don't know.  For me the more category theory I learn the more impressed I am that it maps directly into Haskell.
18:47:44 <ddarius> Yes, most of the talk of "category theory and Haskell" has nothing to do with the "underpinnings" of Haskell.
18:47:57 <amindfv> hatds: dimwit is doing symmetric lenses, I think. Not sure if that's the same.
18:47:58 <geekosaur> yeh, it took me several days to download it (I'm at amotel with lossy network, and eded up using a prepaid mifi... and 3GB goes over the 2GB limit at which it gets limited to 1G speeds)
18:48:29 <roconnor> ddarius: right; if anything the category theory is overlaid on Haskell.  Haskell existed well before Monads in Haskell existed.
18:48:32 * djahandarie pokes mm_freak_ 
18:48:37 <edwardk> amindfv: they are not the same. neither symmetric lenses nor functional references subsume the other
18:48:53 <edwardk> though, if you weaken the symmetric lens you can find a common ancestor
18:49:02 <roconnor> edwardk: what are symmetric lenses?
18:49:14 <ddarius> roconnor: However, monads applied to semantics existed before (barely) Haskell existed.  And certainly Scott and Strachey were not completely ignorant of category theory (and have become less so.)
18:49:21 <Cale> Even ML was inspired by category theory to some extent wasn't it?
18:49:24 <hatds> amindfv: thanks for the pointer
18:49:34 <ddarius> Cale: Certainly Caml was.
18:49:59 <RomyEatsDrupal> geekosaur:  i was an English and Philosophy major in college, so no math past high school, but last week, i "discovered" category theory- a mathematician friend explained the "basic", or "gist" of it in simple terms to me, and i was VERY intrigued
18:50:08 <Cale> Indeed, the C stands for categorical, doesn't it? :)
18:50:13 <edwardk> symmetric lenses are (exists c. s * c -> v * c, v * c -> s * c,  c) with symmetric put laws
18:50:15 <roconnor> ddarius: right, monads existed to describe semantics of effects of programming langauges;  Wadler's big insight was that you could directly transcribe the definition of a monad right into Haskell and it works beautifully.
18:50:30 <RomyEatsDrupal> so it's eerie to see category theory and haskell in the same sentence!!!
18:50:38 <ddarius> Yes, Caml was originally implemented on the CAM, the categorical abstract machine.  CAML stands for Categorical Abstract Machine Language.
18:50:44 <RomyEatsDrupal> two subjects i found out recently that are very fascinating!
18:50:47 <edwardk> the laws basically make it so the putting and putting back is idempotent, but nothing else
18:50:48 <acowley> edwardk: is there a TH component for your lenses package similar to fclabels?
18:50:56 <edwardk> acowley: data-lens-template
18:50:59 <amindfv> hatds: edwardk (who knows what he's talking about) says they're different, but here's a reference if it's useful: http://dmwit.com/papers/201009SL.pdf
18:51:14 <acowley> edwardk: thanks
18:51:55 <RomyEatsDrupal> well i'm off to read some of this learnyou book, and type a few lines into an online server that already has ghci installed
18:51:57 <roconnor> ddarius: and then they dropped the CAM since it was slow?
18:52:06 <RomyEatsDrupal> see you people later!
18:52:34 <ddarius> roconnor: Well the CAM evolved for quite a while in ways completely uninspired by mathematics, and then was eventually replaced with the ZINC machine.
18:52:35 <edwardk> anyways, if you want the common ground, you can make (exists c, d. s * c -> v * d, v * d -> s * c, c), then the traditional asymmetric lenses are those given by an isomorphism and where c = (), and symmetric lenses are those where c = d
18:52:38 <amindfv> RomyEatsDrupal: good luck
18:53:37 <RomyEatsDrupal> one last thing- so anyone here ever learn Haskell as one of their first programming languages ever?
18:53:44 <amindfv> edwardk: and that's (the ancestor to) bidirectional lenses?
18:53:47 <ddarius> RomyEatsDrupal: Many have.
18:54:02 <edwardk> amindfv: thats basically the common ancestor i was hunting for at hac phi
18:54:03 <amindfv> RomyEatsDrupal: truly wish I had
18:54:25 <ddarius> edwardk: I guess I'll run over and knock on your door.
18:54:30 <RomyEatsDrupal> this would officially be my first, or second, depending on what you consider my n00b fumblings of ruby on the airplane the other day
18:54:33 <edwardk> ddarius: sounds good
18:54:37 <edwardk> i'll go hunt for the book
18:54:59 <RomyEatsDrupal> okay that's rather reassuring.  i'm off to check this book out :P :P bye for now!
19:16:11 <hpaste> Entro pasted “to List or not to List...” at http://hpaste.org/49899
19:16:57 <Entroacceptor> anyone here to take a quick look at that? it must be something trivial
19:17:55 <Entroacceptor> basically I'll want to filter out directories which don't fit certain criteria
19:18:57 <aavogt> maybe it's less portable, but you could just call 'find'
19:19:08 <mustelo> Entroacceptor, looks like the return type should be IO (Tree DirEntry)
19:19:15 <pr> hah, finished scrolling/skimming  1 1/2 days of #haskell, yay
19:19:53 <hatds> Entroacceptor:  foldM getnFilter [[]] perhaps?  or make getnFilter return a concat'ed list?
19:20:36 <Entroacceptor> aavogt: no, I want those trees
19:21:02 <Entroacceptor> and I fear that I misunderstood something obvious
19:21:21 <hatds> :t foldM
19:21:22 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
19:21:29 <Entroacceptor> why eos it expect Tree DirEntry anyway?
19:21:55 <Entroacceptor> getFiles' wants a Forest, which is just [Tree]
19:25:36 <Entroacceptor> arg
19:25:39 <Entroacceptor> yes, concat
19:25:41 <Entroacceptor> not :
19:26:47 <Entroacceptor> or rather, append
19:27:06 <Entroacceptor> ha, now it's equal to forM
19:27:22 <tgeeky> hmmm
19:27:27 <tgeeky> talk of Forest?
19:39:18 <MHD> So, I was thinking... Isn't using LLVM for jitting haskell functions a really versatile tool?
19:40:39 <ezyang> Huh, I thought finalizers were guaranteed to run at the end of a program. Is this not true?
19:40:47 <mauke> that would surprise me
19:41:20 <ezyang> http://hackage.haskell.org/trac/ghc/ticket/1364
19:41:56 <ezyang> Oh, but this is C finalizers.
19:42:46 <ezyang> Hmm, I can't get this finalizer to run at all. Fascinating.
20:04:06 * jmcarthur is exhausted
20:04:17 <jmcarthur> oh sorry, meant for haskell-blah
20:08:56 <kizzx2> what is the modern haskell way to provide "default implementation" for a type class? example http://ideone.com/IruET         (how to implement what i want in `XXX` ??)
20:09:10 <kizzx2> s/for a type class/for a type class function/
20:09:42 <hpc> just give a definition, i think
20:09:56 <hpc> class Foo a where f :: a -> a; f = id
20:10:10 <hpc> then you can write instance Foo Int
20:10:17 <hpc> instance Foo Integer where f = succ
20:10:30 <hpc> i am 90% sure that will work
20:11:27 <sshc> Is "unsafeCoerce :: Identity a -> a" (and "unsafeCoerce :: a -> Identity a") intrinsically guaranteed to be safe with standard-compliant implementations?  (Identity is a *newtype* wrapper)
20:11:36 <sagelywizard> A friend of mine was saying that Haskell's type system makes it more difficult to make certain mistakes and makes code more expressive, relative to the type systems to many other languages. Would you guys agree?
20:11:56 <mauke> yes
20:12:08 <hpc> sshc: unsafeCoerce doesn't have any specification, i don't think
20:12:11 <dolio> unsafeCoerce isn't in the standard.
20:12:16 <shachaf> sshc: unsafeCoerce isn't really part of the Haskell spec, so I don't think you get any guarantees about it.
20:12:24 <hpc> and the standard doesn't say anything about internal representations of data structures
20:12:29 <aavogt>  class Foo a where f :: a -> a;  instance Foo a where f = id -- means you don't need all those
20:12:45 <hpc> aavogt: needs an extension?
20:12:48 <aavogt> all those instance, if you're ok with having Foo work with all types
20:12:50 <aavogt> yes
20:12:50 <kizzx2> hpc: looks like i'm missing something really fundamental.... my failed attempt  http://ideone.com/o12Ul
20:12:59 <aavogt> -XOverlappingInstances
20:13:26 <sagelywizard> mauke: Why?
20:13:28 <hpc> kizzx2: probably me; i know it works for stuff like Eq where (==) and (/=) are defined in terms of each other
20:13:39 <hpc> do what aavogt says
20:13:52 <mauke> sagelywizard: because it's true
20:14:19 <shachaf> OverlappingInstances are evil.
20:14:24 <shachaf> Particularly for that use. Don't use them for that.
20:14:30 <kizzx2> aavogt: the thing is i want specialized versions for specific types
20:14:48 <sagelywizard> mauke: Okay, why is it true?
20:15:02 <cmccann> shachaf, worse, OverlappingInstances are insidious evil, because they seem reasonable at first
20:15:06 <aavogt> hpc: the standard says "newtype does not change the underlying representation of an object."
20:15:14 <kizzx2> in C++, i would say         template <typenmae T> std::string foo(T){/*default impl}       std::string foo(int ){/*specialized version for int*/}
20:15:55 <hpc> aavogt: ah, forgot about that
20:16:41 <aavogt> cmccann: if you don't export the class (but export the methods) can things accidentally go wrong?
20:17:01 <mauke> sagelywizard: what kind of answer do you expect?
20:17:29 <dolio> Can you export the methods without exporting the class?
20:17:47 <aavogt> dolio: yes
20:18:23 <aavogt> the effect being that you can't define any new instances (and have trouble writing type signatures)
20:18:46 <cmccann> aavogt, I don't know. I wouldn't be surprised if you could get funny results that way depending on how the classes and instances are written.
20:19:20 <cmccann> But not as bad as the non-locality issues that arise otherwise
20:19:48 <cmccann> just the sort of funny business that can happen when overlapping instances and polymorphic types are combined in odd ways
20:20:10 <cmccann> higher-rank polymorphism can make things interesting that way
20:21:20 <aavogt> I think the thing that Eq does with    (==) in terms of (/=) in terms of (==) is horrible because   instance Eq T;  gives no warnings and has non-terminating methods
20:21:22 <dolio> Wow, you can.
20:21:22 <sagelywizard> Well, what about Ruby's type system vs Haskell's type system? What mistakes are you going to make in Ruby that Haskell's type system prevents you from making?
20:21:31 <dolio> And that makes it impossible to write types for certain functions.
20:27:11 <cmccann> haha, I just got a "typeclass" tag badge on Stack Overflow
20:27:35 <ezyang> Is that for the 'typeclass' tag?
20:27:40 <cmccann> yes
20:27:52 <cmccann> which has a total of 171 questions in it
20:29:19 <edwardk> cmccann: nice =)
20:29:23 <cmccann> which is why I'm the second person to have a badge for that tag
20:29:29 <cmccann> to go with my "monads" badge, heh
20:30:05 <shachaf> cmccann: You should get a #haskell badge.
20:30:08 <shachaf> We need a badge system.
20:30:13 <shachaf> @karma+ cmccann
20:30:13 <lambdabot> cmccann's karma raised to 1.
20:30:21 <edwardk> i worry what badges i would get
20:30:39 <shachaf> I think you'd get badges from Hackage.
20:31:03 <edwardk> wrote 5 corrections for 1 line of text. got hackage bot banned from channel. most obtuse explanation, most uses of co in one sentence.....
20:31:11 <cmccann> hahaha
20:31:46 <edwardk> linked to personal domain name over 200 times, etc.
20:32:27 <aavogt> cmccann: so if you have a  instance C a; instance C Int; it's a problem that you'll get a different instances chosen for     f :: (forall a. C a => a -> b) -> b     vs.   g :: C a => (a -> b) -> b?
20:32:32 <edwardk> cmccann: btw- i really liked your type inequality constraint post
20:32:56 <cmccann> edwardk, oh? The sensible part, or the ridiculous type hackery?
20:33:06 <edwardk> the ridiculous part of course
20:33:41 <cmccann> eh, most of that is just copy and paste from Oleg
20:34:10 <Saizan> which post?
20:34:10 <cmccann> plus a few of my superficial adjustments, like "No" and "Yes" for the type bools
20:34:35 <edwardk> sure, but the tweaking from TypeCast to equality constraints, and flipping the definition to suit the problem
20:34:48 <edwardk> my first reaction was to answer 'no' then i saw your response ;)
20:34:59 <edwardk> http://stackoverflow.com/questions/6939043/is-it-possible-to-place-inequality-constraints-on-haskell-type-variables
20:35:21 <cmccann> aavogt, depends on your definition of "problem". My complaint is mostly lack of clarity about what overlapping instances are going to do combined with no solid foundation to start with
20:36:16 <cmccann> edwardk, I thought it was amusing how I gave "assertion, not condition" as one reason it wouldn't be useful, then proceded to define it using an equality condition plus an assertion of "No"
20:36:30 <edwardk> =)
20:37:10 <cmccann> With the wonderful result that violating the inequality constraint produces an error message that No isn't Yes. Really? Thanks, GHC
20:38:48 <danharaj> That's basically how 90% of GHC's errors sound to me.
20:39:37 <cmccann> edwardk, speaking of type hackery, did you see generalized flip I wrote a while back? I kind of liked that one.
20:39:45 <ddarius> From earlier, the GHC docs say when you can safely use unsafeCoerce (of course, this only applies to GHC.)
20:39:53 <edwardk> @type flip
20:39:54 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
20:39:57 <edwardk> that one?
20:40:08 <cmccann> edwardk, nah
20:40:14 <danharaj> o.O
20:40:16 <cmccann> a function "rotate n" that shifts the first n arguments one space to the left, wrapping the leftmost around to the back
20:40:22 <edwardk> ah
20:40:31 <cmccann> where n is a type-level number obviously
20:40:33 <danharaj> @src flip
20:40:34 <lambdabot> flip f x y = f y x
20:40:36 <edwardk> we had to write one of those here for use in defining our elimination forms in our toy language
20:40:43 <copumpkin> except in HOAS
20:40:47 <edwardk> yeah
20:40:51 <copumpkin> :(
20:40:54 <edwardk> the hoas made it hard
20:41:04 <danharaj> hoas? are those like boas?
20:41:06 <cmccann> ah, here https://gist.github.com/1086615
20:41:34 <edwardk> ah cute
20:42:02 <cmccann> yeah, I'm actually tempted to keep that one, it seems like it might actually be useful
20:42:21 <edwardk> it is clean
20:42:29 <cmccann> surprisingly so, yeah
20:42:47 <edwardk> variations can be written to apply the nth argument as well
20:43:12 <edwardk> i suppose that becomes rotate, apply and rotate back
20:43:17 <cmccann> yeah, can generalize easily to any nested type constructor assuming there's something sensible to do at the term-level
20:44:34 <edwardk> trying to figure out the right way to clean up the uncons instance in trifecta to get it to sum over any intervening path hunks properly
20:44:41 <aavogt> cmccann: http://hpaste.org/49900
20:44:41 <cmccann> nah, apply nth would probably just apply for zero, or make a lambda for the first argument and then apply (n-1)th inside
20:44:45 <edwardk> there should be a nice way to encode it
20:45:13 <edwardk> yeah
20:46:07 <cmccann> aavogt, yeah, I was tempted to do something like that but didn't feel like rewriting it and didn't have my random type hackery snippets at hand to grab from
20:46:08 <aavogt> which adds another oleg trick
20:46:58 <cmccann> aavogt, couldn't you write If as a type family?
20:47:14 <edwardk> what i'm trying to figure out how to express elegantly is the uncons definition in https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/It.hs  —
20:47:25 <aavogt> definitely
20:47:25 <edwardk> in particular the d <> delta c is very wrong
20:49:11 <cmccann> aavogt, I've been trying to purge fundeps from my type hackery, is the only reason I mention it :P
20:49:49 <aavogt> type family If a x y; type instance If Yes x y = x; type instance If No x y = y
20:50:18 <edwardk> one might argue that i shouldn't be putting path directives in the middle of a character, so perhaps i can just take the byte count and use that to ask the finger tree for a cursor at the end
20:52:01 <cmccann> edwardk, pretty sure I'd have to spend some time figuring out what the rest of the library is doing to help clean up that function :T
20:52:15 <edwardk> i welcome eyeballs =)
20:54:36 <cmccann> if anything I really should finish some of my own half-baked libraries :[
20:54:44 <edwardk> fair nuff
20:55:15 <aavogt> wouldn't it be nice if ghc let you use either syntax (fundeps or type families) in cases where the translation is straightforward (like that If)
20:55:48 <cmccann> aavogt, either syntax in what sense?
20:58:53 <edwardk> i think i have it
20:58:59 * cmccann wonders if anyone would be interested in a library to generate church encodings with TH
20:59:16 <aavogt> like        class And a b c | a b -> c    vs.    class AndC a b where type And a b
20:59:53 <cmccann> aavogt, ah, right. Eh, problem is a lot of fundeps of that form can't be defined as a type family
21:00:17 <cmccann> so it would need to be somewhat clever
21:03:39 <aavogt> the simplest thing might be just to desugar        ( And (And a b) (And c d) ~ Yes ) =>      to     ( And a b ab, And c d cd, And ab cd Yes ) =>
21:04:24 <aavogt> (say you've written the And with fundeps)
21:05:10 <cmccann> aavogt, seems like an awful lot of effort to implement, I'd rather see more stuff added for type families so that fundeps can just go crawl into a corner and die
21:26:23 <edwardk> i don't want to see either die
21:26:49 <ddarius> I doubt either will unless something dramatic happens.
21:29:14 <cmccann> I'd like fundeps more if they'd actually try to be a better logic language
21:29:36 <ddarius> I'd like Prolog more if it would actually try to be a better logic language.
21:31:47 * ddarius would be happy with it just -trying-.
21:31:55 <cmccann> haha
21:32:07 <cmccann> still better than doing anything nontrivial with fundeps though
21:33:12 <edwardk> fundeps and type families are both good at an overlapping set of problems, but neither one makes me want to give up the other
21:35:13 <ddarius> There's little reason other than "simplicity."
21:48:39 <cwl> is haskell.org down?
21:48:51 <cwl> @src isdup
21:48:52 <lambdabot> Source not found. :(
21:48:55 <cwl> @src isDup
21:48:56 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:49:14 <cwl> @src set
21:49:15 <lambdabot> Source not found. You type like i drive.
21:50:42 <absz> cwl: http://www.downforeveryoneorjustme.com/haskell.org — doesn't appear so
21:55:03 <cwl> @src nub
21:55:03 <lambdabot> nub = nubBy (==)
21:55:13 <cwl> @src nubBy
21:55:13 <lambdabot> nubBy eq []             =  []
21:55:13 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
21:55:34 <cwl> > nub [1,2,1,1,2]
21:55:35 <lambdabot>   [1,2]
21:56:19 <NihilistDandy> Why do people bother with other languages? Is there anything you *can't* do with Haskell?~
21:57:41 <cmccann> @faq is it possible to find things Haskell can't do?
21:57:42 <lambdabot> The answer is: Yes! Haskell can do that.
21:58:06 <NihilistDandy> Best answer
21:58:06 <cwl> lol
21:58:11 <absz> :-)
21:58:50 <cwl> @faq which is better, haskell v.s. lisp
21:58:50 <lambdabot> The answer is: Yes! Haskell can do that.
21:58:53 <NihilistDandy> @remember cmccann @faq is it possible to find things Haskell can't do?  <lambdabot> The answer is: Yes! Haskell can do that.
21:58:54 <lambdabot> Okay.
21:59:18 <cwl> @src group
21:59:19 <lambdabot> group = groupBy (==)
21:59:27 <cwl> @src groupBy
21:59:28 <lambdabot> groupBy _  []       =  []
21:59:28 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
21:59:28 <lambdabot>     where (ys,zs) = span (eq x) xs
22:03:46 <cwl> is there any function that detect if a list contains duplicates
22:04:31 <cwl> length xs == length (nub xs) cost to much
22:04:56 <kmc> :t any ((>1) . length) . group . sort
22:04:57 <lambdabot> forall a. (Ord a) => [a] -> Bool
22:05:06 <cmccann> cwl, depends, do you have an Ord constraint, or just Eq?
22:05:26 <ddarius> cmccann: You could have something better than an Ord constraint.
22:05:27 <cwl> cmccann just Eq
22:05:42 <kmc> with just Eq you can't build a fast lookup structure
22:05:58 <kmc> you can still do better than length xs == length (nub xs)
22:06:05 <kmc> but not by much
22:06:08 <cwl> what if Ord
22:06:13 <kmc> then see above
22:06:52 <ddarius> kmc: Incidentally, the length there could be albeit it won't change the asymptotics.
22:07:06 <shachaf> all (null . drop 1) . group . sort
22:07:16 <kmc> ah, that's better
22:07:16 <copumpkin> genericLength
22:07:37 <shachaf> Lazy supernaturals.
22:07:49 <cwl> @src all
22:07:50 <lambdabot> all p =  and . map p
22:07:50 <kmc> :t let dup [] = False; dup (x:xs) = case partition (== x) xs of ([], ne) -> dup ne; _ -> True in dup
22:07:51 <lambdabot> forall a. (Eq a) => [a] -> Bool
22:07:57 <copumpkin> shachaf: are those ordinals?
22:08:10 <shachaf> You could probably do better than group . sort, too?
22:08:32 <copumpkin> :t foldr (const (In . Just)) (In Nothing)
22:08:33 <lambdabot> forall a. [a] -> Mu Maybe
22:08:43 <shachaf> That'll do a bunch of extra (Eq) comparisons. It probably doesn't matter, though.
22:08:57 <copumpkin> there's genericLength on lazy naturals for you
22:09:06 <cwl> so the cost is no less than sort
22:09:24 <shachaf> @slap copumpkin++
22:09:24 * lambdabot jabs copumpkin++ with a C pointer
22:09:29 * shachaf wonders whether that worked.
22:10:03 <copumpkin> > foldr (const (In . Just)) (In Nothing) [1..]
22:10:05 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
22:10:10 <copumpkin> > foldr (const (In . Just)) (In Nothing) [1..3]
22:10:11 <lambdabot>   In (Just (In (Just (In (Just (In Nothing))))))
22:10:22 <ddarius> shachaf: Lambabot doesn't listen for ++ in commands given to her and doesn't listen to her output at all.
22:10:32 <ddarius> preflex, though, may have listened.
22:10:35 <shachaf> That's what I thought.
22:10:38 <shachaf> Oh, preflex.
22:10:42 <kmc> why the first restriction?
22:11:06 <ddarius> Well, it could have changed, but it's just the way the commands are processed.
22:11:10 <ddarius> @karma kmc
22:11:11 <lambdabot> kmc has a karma of 21
22:11:13 <ddarius> @slap kmc++
22:11:13 * lambdabot hits kmc++ with a hammer, so they breaks into a thousand pieces
22:11:15 <ddarius> @karma kmc
22:11:16 <lambdabot> kmc has a karma of 21
22:11:21 <shachaf> preflex: karma kmc
22:11:21 <preflex>  kmc: 35
22:11:26 <shachaf> @slap kmc++
22:11:27 * lambdabot hits kmc++ with a hammer, so they breaks into a thousand pieces
22:11:30 <shachaf> preflex: karma kmc
22:11:30 <preflex>  kmc: 36
22:11:33 <kmc> ow
22:11:40 <shachaf> Does preflex ignore lambdabot?
22:11:44 <shachaf> > text "kmc++"
22:11:44 <lambdabot>   kmc++
22:11:48 <shachaf> preflex: karma kmc
22:11:49 <preflex>  kmc: 37
22:11:57 <shachaf> @show kmc++
22:11:57 <lambdabot> "kmc++"
22:12:00 <shachaf> preflex: karma kmc
22:12:01 <preflex>  kmc: 38
22:12:08 <shachaf> Huh.
22:12:20 * shachaf isn't sure what's going on.
22:12:29 <ddarius> shachaf: Yes.
22:12:34 <mauke> shachaf: no
22:12:34 <kmc> kinda weird to see a whole page of scroll that's highlighted
22:12:43 <kmc> i guess this is how other people feel when they say "halp what is monad"
22:12:44 <ddarius> mauke: I though preflex did for the most part.
22:12:48 <mauke> nope
22:13:15 <shachaf> mauke: What happened there, then?
22:13:15 <ddarius> mauke: So why only one karma increment?
22:13:26 <monadlove> halp what is monad
22:13:42 <shachaf> @whatis monad
22:13:42 <lambdabot> I know nothing about monad.
22:13:43 <ddarius> Does preflex ignore things that look like lambdabot commands?
22:13:58 <shachaf> preflex: karma kmc
22:13:58 <preflex>  kmc: 38
22:14:00 <shachaf> "kmc++"
22:14:01 <shachaf> preflex: karma kmc
22:14:02 <preflex>  kmc: 38
22:14:06 <shachaf> @show kmc++
22:14:06 <lambdabot> "kmc++"
22:14:07 <shachaf> preflex: karma kmc
22:14:07 <preflex>  kmc: 39
22:14:11 <shachaf> Doesn't look like it.
22:14:13 <monadlove> halp
22:14:20 <cmccann> > text $ concat ["kmc", "++"]
22:14:21 <lambdabot>   kmc++
22:14:28 <shachaf> preflex: karma kmc
22:14:28 <preflex>  kmc: 40
22:14:46 <mauke> shachaf: "foo++" ends with ", not ++
22:14:47 <monadlove> halp++
22:15:00 <cmccann> > show $ concat ["kmc", "++"]
22:15:01 <lambdabot>   "\"kmc++\""
22:15:02 <shachaf> mauke: Right, but why does "@slap kmc++" only increment kmc by 1?
22:15:05 <cmccann> preflex: karma kmc
22:15:06 <preflex>  kmc: 40
22:15:16 <shachaf> @slap kmc++
22:15:16 <lambdabot> I'd rather not; kmc++ looks rather dangerous.
22:15:20 <shachaf> preflex: karma kmc
22:15:20 <preflex>  kmc: 42
22:15:26 <mauke> it doesn't
22:15:28 <shachaf> ...OK.
22:15:47 <kmc> @quote preflex
22:15:47 <lambdabot> preflex says: god was last seen on ##c++ 96 days, 6 hours, 19 minutes and 16 seconds ago, saying: I don't really know either actually
22:15:50 <kmc> preflex, be lambdabot
22:15:50 <preflex>  no quotes found for lambdabot
22:15:55 <shachaf> mauke: See the lines at :34.
22:16:32 <mauke> shachaf: looks like it doesn't listen to actions
22:16:40 <shachaf> Oh.
22:16:43 <shachaf> preflex: karma kmc
22:16:43 <preflex>  kmc: 42
22:16:45 * shachaf kmc++
22:16:46 <shachaf> preflex: karma kmc
22:16:46 <preflex>  kmc: 42
22:16:51 <shachaf> @karma kmc
22:16:52 <lambdabot> kmc has a karma of 21
22:16:54 * shachaf kmc++
22:16:55 <shachaf> @karma kmc
22:16:55 <lambdabot> kmc has a karma of 21
22:17:05 * shachaf has had enough of spamming #haskell for now.
22:17:22 <mauke> kmc-- kmc-- kmc-- kmc-- kmc-- kmc-- # karma deflation
22:17:30 <NihilistDandy> kmc++++
22:17:31 <shachaf> @karma kmc
22:17:32 <lambdabot> kmc has a karma of 15
22:17:38 <shachaf> preflex: karma kmc
22:17:39 <preflex>  kmc: 36
22:17:39 <NihilistDandy> @karma kmc++
22:17:39 <lambdabot> kmc++ has a karma of 1
22:17:55 <mauke> preflex: karma C++
22:17:55 <preflex>  C++: -59
22:17:58 <kmc> karma police, arrest this man
22:18:06 <mauke> preflex: karma karma karma chameleon
22:18:06 <preflex>  karma karma chameleon: 1
22:18:12 <NihilistDandy> lol
22:18:36 <copumpkin> man, this channel has gone to hell
22:18:45 <shachaf> copumpkin++
22:18:47 <copumpkin> poor monadlove is getting no halp
22:19:01 <copumpkin> people are too busy stroking kmc's ego
22:19:03 <shachaf> @quote a.monad.is.just
22:19:03 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
22:19:15 <CindyLinz> preflex: karma C
22:19:15 <preflex>  C: 172021
22:19:33 <shachaf> preflex: karma c/c
22:19:33 <preflex>  c/c: 5358
22:19:45 <NihilistDandy> lol again
22:19:46 <mauke> you need to work harder, that still fits in 31 bits
22:20:04 <pikhq> c/c+=UINT_MAX
22:20:14 <shachaf> preflex uses a machinteger?
22:20:48 <mauke> no, Karma is Integer and Seen uses picosecond precision timestamps
22:20:49 <monadlove> no halp :(
22:20:56 <shachaf> Hmm, according to Google that word has been used once before, and also in #haskell.
22:21:01 <shachaf> Shame on you, #haskell!
22:21:16 <cwl> (vec[i]+i for i in cols) what's the equivalence in haskell
22:21:35 <cwl> map lambda vec
22:21:45 <copumpkin> o.O
22:21:55 <mauke> map (\i -> vec ! i + i) cols
22:22:10 <fengshaun> [(vec i) + i | i <- cols]
22:22:29 <mauke> map (ap (+) (vec !)) cols
22:22:29 <shachaf> @pl \i -> vec ! i + i
22:22:29 <lambdabot> (+) =<< (vec !)
22:22:33 <cwl> fengshaun: cool
22:23:02 <shachaf> @unpl (ap (+) (vec !))
22:23:03 <lambdabot> ((+) >>= \ c -> (\ a -> vec ! a) >>= \ b -> return (c b))
22:23:28 <NihilistDandy> Makes so much more sense~
22:23:32 <fengshaun> cwl, sorry, vec ! i is correct, I thought vec was a function.
22:24:28 <shachaf> @pl \i -> i + vec ! i
22:24:28 <lambdabot> ap (+) (vec !)
22:26:15 <NihilistDandy> What do you call (!)?
22:26:21 <shachaf> "not"
22:26:21 <kmc> array indexing
22:26:36 * shachaf pronounces "!!" as "not not".
22:26:39 <kmc> not to be confused with list indexing, which is (!!)
22:26:44 <NihilistDandy> Right
22:26:54 <kmc> shachaf, !! is used in C as "not not"
22:26:56 <NihilistDandy> I just haven't worked with arrays, yet, so I haven't seen it
22:27:09 <shachaf> kmc: I know. That's whence the confusion comes. :-)
22:27:19 <pikhq> Aaaah, the boolean cast operator.
22:27:44 <NihilistDandy> Apropos of nothing, how difficult would you imagine a MIPS simulator written in Haskell would be? :D
22:27:56 <shachaf> NihilistDandy: 14
22:28:10 <NihilistDandy> shachaf: Perfect
22:28:17 <kmc> 8.75
22:28:24 <ddarius> NihilistDandy: It depends on whether you want it to be fast or not.
22:28:28 <kmc> Napier's Constant times the speed of light squared
22:28:29 <NihilistDandy> That's the exact amount of arbitrarily scaled difficulty I can handle
22:29:19 <shachaf> C has such great operators. Like -->.
22:29:30 <kmc> buh
22:29:33 <pikhq> One of my favorites.
22:29:42 <NihilistDandy> ddarius: Well, speed's not necessarily goal one, but I'd like it to be useful. I'm taking a MIPS class in the fall and I think for a nice non-trivial Haskell project I'd like to make an equivalent to spim
22:30:05 <pikhq> while(x --> 0) almost makes it look like a reasonable language.
22:30:06 <cmccann> the --> is extensible as well, isn't it?
22:30:19 <cmccann> like using ----> to make it go faster
22:30:26 <shachaf> cmccann: I don't think so.
22:30:29 <ddarius> NihilistDandy: Well it probably won't be so slow as to be unusable.
22:30:43 <copumpkin> I think -- wants an lvalue or something
22:30:45 <pikhq> I don't think -- gets you an lvalue.
22:31:01 <cmccann> ah, must be thinking of some other language :T
22:31:07 <micahjohnston> pikhq: you should use while (0 <-- x)
22:31:12 <micahjohnston> pikhq: it's better-behaved
22:31:18 <micahjohnston> it doesn't leave x and -1
22:31:23 <ddarius> NihilistDandy: My experience making a VM implementation in Haskell didn't go too great (though GHC and I have advanced a decent amount since then.)  I did, however, just turn the Haskell code into a Haskell C code generator that produced a VM.
22:31:31 <micahjohnston> although it clashes with c's 0-indexing
22:31:38 <micahjohnston> because it doesn't execute the loop while x is 0
22:32:07 <shachaf> micahjohnston: You're like those people who write "0 == x" to avoid accidentally typing =.
22:32:11 <micahjohnston> @pl \ f (a, b) -> (f a, b)
22:32:11 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
22:32:14 <shachaf> A disgusting behavior.
22:32:18 <micahjohnston> :/
22:32:26 <shachaf> @ty first
22:32:27 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
22:32:30 <micahjohnston> why doesn't @pl know about Applicative (->)
22:32:31 <shachaf> > first (+1) (5,'a')
22:32:32 <lambdabot>   (6,'a')
22:32:37 <micahjohnston> @pl first
22:32:38 <lambdabot> first
22:32:39 <micahjohnston> lol
22:32:54 <shachaf> Because @pl is a mess.
22:32:55 <micahjohnston> shachaf: no, it's just not leaving x at -1
22:33:05 <micahjohnston> :P
22:33:31 <NihilistDandy> ddarius: It doesn't have to be an enormously full-featured VM, in my case, at least. It really just has to be able to load the MIPS source and run it. I'm probably going to dig into the spim source and see what kinds of things they get up to in there.
22:33:33 <ddarius>  @pl preceded Applicative by a decent chunk, though, that certainly doesn't explain why it hasn't been altered.
22:33:45 <NihilistDandy> I'm a little curious about the type signatures I'll end up with :D
22:34:12 <ddarius> NihilistDandy: The more featureful it was, the more performance and ease of coding would tilt in Haskell's favor.
22:34:16 <NihilistDandy> And you can bet if it works it'll be up on Hackage ASAP. I was a little surprised such an undertaking hadn't already occurred
22:34:28 <shachaf> Someone should make @pl better.
22:34:47 <shachaf> Someone who refers to it as an optimizing compiler and likes to say "lol".
22:34:48 <ddarius> NihilistDandy: I would think you would want to add tracing and debugging features.
22:34:49 <NihilistDandy> ddarius: Hmm, I'll have to take that into consideration/obsess over the MIPS specifications for weeks
22:34:57 <micahjohnston> first could have been @pl'd like this:
22:35:02 * shachaf may have described an empty set.
22:35:06 <ddarius> shachaf: Yes.
22:35:07 <micahjohnston> (,) <$> (f . fst) <*> snd
22:35:26 <NihilistDandy> shachaf: @pl is an optimizing compiler, lol
22:35:28 <ddarius> Also, again, optimizing compiler -to combinators- or via combinators.
22:35:47 <ddarius> @google "David Turner" combinators compiler
22:35:48 <lambdabot> http://en.wikipedia.org/wiki/Coders_at_work
22:35:48 <lambdabot> Title: Coders at work - Wikipedia, the free encyclopedia
22:36:03 <cwl> https://gist.github.com/1129057 eight queens in haskell
22:36:12 <mauke> micahjohnston: first is already pointless
22:36:24 <ddarius> Stupid page rank.
22:36:27 <copumpkin> @let second' f = (snd &&& fst) . fmap f . (snd &&& fst)
22:36:28 <lambdabot>  Defined.
22:36:32 <copumpkin> oh wait, that's first
22:36:51 <copumpkin> @let first' = fmap
22:36:51 <lambdabot>  Defined.
22:36:53 <mauke> "first: the other second"
22:36:54 <copumpkin> just to confuse it more
22:36:55 <micahjohnston> mauke: yeah, I knkow
22:36:59 <ddarius> copumpkin: You wanted fmap to be first.
22:37:04 <micahjohnston> mauke: arrows are pointless
22:37:04 <copumpkin> > first' (+1) (2,4)
22:37:06 <lambdabot>   (2,5)
22:37:10 <copumpkin> there we go
22:37:11 <DevHC> @where troll
22:37:11 <lambdabot> ffconsultancy.com
22:37:18 <copumpkin> > second' (+1) (2,4)
22:37:19 <DevHC> @where trol
22:37:19 <lambdabot> I know nothing about trol.
22:37:20 <lambdabot>   (3,4)
22:37:22 <copumpkin> :)
22:37:29 * shachaf >> threadDelay 900000000
22:37:43 <NihilistDandy> DevHC: lol
22:37:43 <janhye> Hello, every body. How can I use Haskell to develop iOS apps?
22:37:50 <NihilistDandy> @type L.fst
22:37:51 <lambdabot> Not in scope: `L.fst'
22:37:57 <mauke> > 900/60
22:37:58 <lambdabot>   15.0
22:38:00 <NihilistDandy> Aww, my definitions have been purged
22:38:09 <mauke> shachaf sleeps for 15 minutes
22:38:35 <mauke> after he's dead
22:38:46 <DevHC> @remember troll #haskell
22:38:47 <lambdabot> Good to know.
22:38:54 <NihilistDandy> @where troll
22:38:54 <lambdabot> ffconsultancy.com
22:38:59 <DevHC> D:
22:39:02 <NihilistDandy> DevHC: Use @where+
22:39:03 <ddarius> @forget troll #haskell
22:39:03 <mauke> @forget troll #haskell
22:39:03 <lambdabot> Done.
22:39:03 <lambdabot> No match.
22:39:22 <NihilistDandy> But also leave that where for troll
22:39:27 <NihilistDandy> It's perfect
22:39:34 <kmc> sigh
22:39:50 <kmc> if we all acknowledge jdh is a troll, why do we keep bringing him up in conversations
22:40:02 <cmccann> because he's a good troll
22:40:09 <cwl> '-' * 3 in python can be  take 3 (repeat '-'), any better way?
22:40:09 <NihilistDandy> An hilarious troll
22:40:11 <DevHC> to ph33d him
22:40:14 <cmccann> he manages to say a lot of things that are technically correct but subtly misleading
22:40:19 <mauke> cwl: replicate
22:40:20 <cmccann> and then reaches absurd conclusions
22:40:23 <ddarius> kmc: Don't forget you're on the internet.  Internet people cannot be reasoned with.
22:40:29 <NihilistDandy> cwl: replicate 3 '-'
22:40:32 <cwl>  > replicate 3 '-'
22:40:40 <mauke> tail cwl
22:40:45 <cwl> > text "..."
22:40:46 <lambdabot>   ...
22:40:52 <ddarius> "---"
22:40:52 <kmc> Python doesn't distinguish between characters and one-element strings, though
22:40:54 <cwl> > replicate 3 '-'
22:40:55 * ddarius wins.
22:40:55 <lambdabot>   "---"
22:41:00 <kmc> so ("abc" * 3) is
22:41:04 <DevHC> > cycle 'F' ++ cycle 'U'
22:41:05 <kmc> > take 9 (cycle "abc")
22:41:05 <lambdabot>   Couldn't match expected type `[a]'
22:41:06 <lambdabot>         against inferred type `GHC.Types...
22:41:06 <lambdabot>   "abcabcabc"
22:41:17 <DevHC> > repeat 'F' ++ repeat 'U'
22:41:19 <lambdabot>   "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF...
22:41:19 <cwl> > ("abc" * 3)
22:41:20 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
22:41:20 <lambdabot>    arising from the literal ...
22:41:46 <mauke> *> "abc" * 3
22:41:46 <mauke> "\291\294\297"
22:43:02 <DevHC> btw, "art of" autocompletes to "art of trolling" in google
22:43:30 <janhye> can i use haskell to develop iphone apps?
22:43:30 <DevHC> > let troll = "jhd"
22:43:31 <lambdabot>   not an expression: `let troll = "jhd"'
22:43:35 <DevHC> @let troll = "jhd"
22:43:35 <lambdabot>  Defined.
22:43:44 <mauke> @undefine
22:43:49 <NihilistDandy> janhye: Technically, yes
22:43:56 <NihilistDandy> Practically, less so
22:44:14 <mauke> @let a === b = cast a == Just b
22:44:15 <lambdabot>  Defined.
22:44:20 <fengshaun> janhye: highly doubt it.  I would say no.
22:44:39 <mauke> > "a" === 'a'
22:44:41 <lambdabot>   False
22:45:07 <ddarius> There are people doing/working on it.
22:45:34 <fengshaun> janhye: http://haskell.org/haskellwiki/IPhone
22:45:35 <ddarius> But if you just want to write an app and have no desire to put in effort working on the infrastructure to do so, then the answer is "no."
22:45:53 <janhye> thanks.
22:54:55 <micahjohnston> :t cast
22:54:56 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
22:55:33 <PatrickRobotham> Not everything's typeable?
22:56:02 <kmc> correct
22:59:10 <kmc> i can't think of a (monomorphic) type which fundamentally "shouldn't" be an instance of Typeable
22:59:43 <kmc> GHC can derive the instances
23:00:00 <kmc> in fact you should never write a Typeable instance yourself, because you can make the type system unsound if you make a mistake
23:00:17 <kmc> even if GHC provided a Typeable instance for every type automatically,
23:00:28 <kmc> it would still be important to have the explicit constraint
23:00:39 <kmc> because using Typeable destroys parametricity
23:01:42 <cmccann> just make everything an existential with a typeable constraint
23:01:47 <cmccann> that sounds like a very productive approach
23:01:52 <kmc> you can write a function «(Typeable a) => (a -> b) -> [a] -> [b]» which does the same thing as 'map' unless a = Bool
23:03:05 <shachaf> mauke: My estimate was a bit off.
23:03:43 * shachaf return
23:03:52 <ddarius> shachaf: Well you haven't terminated yet.
23:05:44 <shachaf> kmc: Some opaque types define their own Typeable instances.
23:05:49 <shachaf> No, wait, I'm thinking of Data.
23:09:14 <kmc> shachaf returned but saved a continuation somewhere?
23:09:37 <ddarius> kmc: return was passed as a continuation to shachaf
23:55:57 <zhulikas> data BookInfo = Book Int String [String]
23:55:57 <zhulikas>                 deriving (Show)
23:56:07 <zhulikas> BookInfo is a type constructor and Book is value constructor
23:56:20 <zhulikas> I don't get why we need a value constructor when defining data types
23:56:28 <zhulikas> can somebody explain it to me?
23:57:51 <mauke> zhulikas: how else are you going to make BookInfos in your code?
23:58:10 <zhulikas> well, I see an example below:
23:58:10 <zhulikas> myInfo = Book 9780135072455 "Algebra of Programming"
23:58:10 <zhulikas>          ["Richard Bird", "Oege de Moor"]
23:58:19 <zhulikas> why can't it use BookInfo instead of Book in this line?
23:58:19 <mauke> that uses 'Book'
23:58:29 <mauke> oh, types can have more than one constructor
23:58:43 <zhulikas> ahh
23:58:47 <zhulikas> hmm
23:59:00 <kmc> you can name the type and value constructors the same
23:59:05 <mustelo> zhulikas, when your type has only one constructor, it's common to name them the same
23:59:07 <kmc> you should only do this if there's only one value constuctor
23:59:31 <mauke> data Book = Book Int String [String] -- but I wouldn't do that in a tutorial because it tends to confuse people even more
23:59:42 <zhulikas> ok so type has some structure for data and can have multiple constructors, right? So what a constructor is for?
