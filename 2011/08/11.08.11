00:02:48 <fengshaun> is it not possible to put type signatures for fmap when instancing?
00:03:47 <Axman6> no, just stick them in a comment above
00:04:03 <fengshaun> Axman6: oh ok, thanks!
00:05:29 <aleator> Hmm.. Can ghc plugins be used to generate additional modules from existing ones? For example,  is it possible to write a simple plugin that finds every testable function and produces a module that runs them?
00:05:58 <c_wraith> doesn't seem like a job for ghc plugins
00:06:05 <c_wraith> that sounds more like a job for template haskell
00:06:15 <kmc> or a simple hack
00:06:20 <kmc> (SPJ has one)
00:06:23 <kmc> or haskell-src-exts
00:06:28 <c_wraith> ghc plugins are about core->core transformations
00:06:37 <aleator> Well, not the exact example I had in mind, but thought it was simpler to explain.
00:06:53 <c_wraith> well, I was thinking haskell-src-exts automated by template haskell, so just recompiling re-scans. :)
00:07:45 <aleator> I just thought about a thing that could compile list comprehensions into cuda-kernels and have them linked in the resulting program
00:08:12 <aleator> Which would similarily need to generate additional modules with ffi and stuff
00:08:19 <c_wraith> with ghc 7.2, you could do that with monad comprehensions
00:09:13 <c_wraith> there's also been some work at using template haskell/quasiquotation for shader programs
00:09:23 <aleator> c_wraith: Oh indeed. Thats actually a nice idea.
00:09:24 <c_wraith> which is basically the same thing, right?
00:09:29 <aleator> Basically yes
00:10:57 <aleator> Though, I'm not sure if template haskell can be used to instruct the compiler to include object files produced as a side effect
00:13:00 * hackagebot dph-examples 0.5.1.1 - Examples using the DPH library.  http://hackage.haskell.org/package/dph-examples-0.5.1.1 (BenLippmeier)
00:21:34 <qnikst> can somebody advice a package that can be used to work with bitstrings, i.e. I want to make bitstring package from bytestring then search/update bits by index, and finally pack it pack into bytestring
00:22:36 <qnikst> I've found BitStream and BitString packages but they do not give a "native" avaliability to search/update bits. only if I'm convert them into 1/0 list
00:26:42 <MichaelBurge> What's the best way to store state in a Haskell module?
00:26:56 <kmc> there are a lot of ways
00:27:02 <kmc> there's no "best way"
00:27:21 <MichaelBurge> The modules are intended to be plugins to a base module that expose an interface but keep their own state
00:27:28 <dcoutts> qnikst: can you use an UArray Int Bool? That's a bitmap
00:28:27 <shachaf> The Best Way is to use unsafePerformIO malloc
00:28:43 <shachaf> inlinePerformIO, actually, because inlining makes your code more efficient.
00:30:07 <qnikst> this way will I able to use functions outside IO monad?
00:30:35 <dcoutts> shachaf: no, never use inlinePerformIO on things that allocate
00:30:43 * shachaf was not serious.
00:30:50 <dcoutts> shachaf: phew!
00:30:51 <shachaf> I should probably not do that when people are actually asking serious questions.
00:30:58 <dcoutts> yeah :-)
00:31:08 <kmc> just go do it in ##c++ instead
00:31:14 <dcoutts> friends don't let friends use inlinePerformIO
00:34:13 <quicksilver> qnikst: I think you underestimate BitStream, it's quite clever and in most cases the 1/0 list is not actually constructed.
00:34:36 <quicksilver> however it's suited for 'stream processing' of bits, not random access mutation.
00:35:04 <qnikst> the main thing is that I should change some bits..
00:35:23 <c_wraith> inlinePerformIO is terrifying. :)
00:35:42 <shachaf> Except for dmead-style programming!
00:35:49 <shachaf> Wait, no, it's terrifying there too.
00:36:00 <c_wraith> viewing the source for it has a similar effect on the sanity as does viewing cthulhu
00:36:13 <qnikst> on the one hand I can make an additional structure where I can store all changes and on "commit" use fold to apply them
00:36:16 <hatds> what does inlinePerformIO do?
00:36:32 <shachaf> Performs IO in a way that can be inlined.
00:36:51 <c_wraith> it's an extra-unsafe (but sometimes more optimizable) unsafePerformIO
00:37:18 <kmc> should basically only be used to read memory that isn't going to change
00:37:54 <c_wraith> the implementation is terrifying.  It pattern matches the IO constructor, contrives a new Realworld, and throws that at the guts of the IO implementation.
00:38:00 * hackagebot dph-examples 0.5.1.2 - Examples using Data Parallel Haskell  http://hackage.haskell.org/package/dph-examples-0.5.1.2 (BenLippmeier)
00:38:11 <shachaf> Where's the implementation?
00:38:19 <c_wraith> Data.ByteString.Internal
00:39:02 <shachaf> Oh, that's lovely.
00:47:07 <chrisdone> woot camhac
00:47:23 <chrisdone> who's in cambridge now? shall we start a #camhac channel?
00:48:39 <chrisdone> Twey: are you coming tomorrow or saturday?
00:48:59 <chrisdone> Philippa: in cambridge yet? ^-^
00:52:20 <benmachine> chrisdone: I'm living here for the time being
00:52:34 <chrisdone> benmachine: :o wanna meet up?
00:53:14 <benmachine> chrisdone: hmmmm
00:53:25 <benmachine> I'm working at a summer school and we're having a welcome dinner tonight
00:53:30 <benmachine> so I can't do dinner, maybe afterwards though?
00:53:32 <chrisdone> "I dunno... chrisdone always struck me as a keyboard-murderer"
00:53:42 <chrisdone> ah, ok
00:53:43 <benmachine> you sure do hate those keyboards
00:53:54 <minsa> I am reading through boyer-moore and think it is pretty elaborate for me right now.
00:54:00 <edwardk> yeah, that one didn't start out as a das keyboard did it?
00:54:23 <minsa> any boyer-moore code in haskell ? want to look at it after I finish reading. thnx.
00:54:29 <chrisdone> I left my das in italy ;_; i was torn over bringing it too… :p
00:54:46 <chrisdone> benmachine: so you're working right now?
00:54:56 <benmachine> chrisdone: no but I will be in like, twenty minutes
00:55:03 <benmachine> so I'd better go and get ready
00:55:09 <chrisdone> fmap chatOnIRC work
00:55:24 <benmachine> chrisdone: I miss the last job I had where I could do that :P
00:55:28 <chrisdone> ah, righto. you'll be at camhac though right? fri-sat-sun?
00:55:32 <benmachine> yep
00:55:38 <chrisdone> splendidé
00:55:54 <benmachine> :)
00:57:12 <benmachine> my first project is wiping and reinstalling my eeepc so I can double my total battery life
00:57:35 <benmachine> or I might just do some API design on paper instead :o
00:57:49 <chrisdone> what is… pay per?
00:58:00 * hackagebot trifecta 0.16 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.16 (EdwardKmett)
01:00:14 <kmc> a magical and revolutionary new technology at an unbeatable price
01:00:30 <edwardk> hah
01:00:53 <edwardk> the low low price of installing half of hackage admittedly
01:01:16 <coppro> Why should I use it instead of Parsec?
01:01:24 <quicksilver> it has a better name
01:01:47 <coppro> tbh I disagree
01:01:55 <quicksilver> then you should use parsec.
01:02:00 <edwardk> it draws pretty error messages (in color on appropriate terminals) with user configurable fixit annotations (like clang) and range selections, etc.
01:02:18 <coppro> ok that is pretty sweet
01:02:25 <coppro> as a clang developer I approve
01:02:29 <edwardk> it also allows you to use monad transformers, has a story for incremental parsing as you get more content
01:03:15 <edwardk> basically the diagnostics are targeted towards folks familiar with clang, though you can draw pretty much anything on the surface, and aren't limited to a color per line like the fixed clang diagnostics
01:03:18 <chrisdone> hpaste is using resident 252m of mem, 2566M virt
01:03:33 <edwardk> since its more of a toolbox for compiler writers it doesn't pre-judge how you'll use the fixits, etc.
01:03:52 <quicksilver> edwardk: do you have a screenshot of some cool fixit examples?
01:04:10 <edwardk> not handy, but i can whip something up
01:04:19 <edwardk> most of mine have been about convincing me ;)
01:04:25 <edwardk> and testing boring corner cases
01:04:51 <quicksilver> it would help other people understand the coolness, though
01:04:53 <quicksilver> e.g. me.
01:05:22 <edwardk> yeah
01:05:25 <edwardk> one sec
01:05:36 <edwardk> i can at east capture a simple one or two
01:07:21 <edwardk> trying to figure where i can easily share images these days
01:08:10 <kalven> imgur
01:08:12 <quicksilver> imagebin perhaps if you don't have a convenient host
01:08:46 <edwardk> and what was the magic key combo to capture a image range on a mac?
01:08:58 <quicksilver> cmd-shift-4
01:09:02 <quicksilver> then drag with mouse
01:09:10 <quicksilver> or hit space to grab a whole window instead.
01:09:21 <edwardk> i just broke all my bigger examples, so i can only show a single caret, without manually constructing spans
01:11:30 <edwardk> http://imgur.com/DmynM
01:11:36 <edwardk> not much of a demo at the moment
01:11:37 <edwardk> =)
01:11:43 <edwardk> i'll see if i can show you something with a fixit
01:13:06 <edwardk> but you can draw on the 'render' target of a diagnostic pretty easily, they are monoidal, you can tell whether two ranges are 'near' one another, so you won't draw on the wrong annotation, etc.
01:14:10 <edwardk> the parser lets you emit diagnostics as a log (via tell, etc) or by throwing them
01:14:40 <edwardk> and it'll do the parsec style 'expected' tracking, to modify your exception to say what was expected if it was a resut of a parse error
01:16:53 <quicksilver> edwardk: *nod*
01:17:05 <quicksilver> nic
01:17:07 <quicksilver> nice
01:19:06 <edwardk> http://imgur.com/D4DXz shows a span constructed in a particularly hackish fashion
01:19:46 <shachaf> edwardk: Isn't that ghci prompt a bit long?
01:19:53 <edwardk> mebbe
01:20:04 <edwardk> i wasn't planning on interacting with this this way for long ;)
01:20:05 <shachaf> I wish you had more control than "%s" in showing your ghci prompt.
01:20:16 <shachaf> I'd want it to show "*Main" but not all the extra modules I've imported.
01:20:34 * shachaf just sets it to a string not containing %s nowadays, and has >30 imports in ~/.ghci
01:20:45 <quicksilver> edwardk: hmm, I don't see what "render x" does in that?
01:20:48 <quicksilver> x should be "this " ?
01:21:01 <edwardk> render takes the 'span' and turns it into a 'render'
01:21:05 <quicksilver> oh it's the green underline?
01:21:09 <edwardk> yeah
01:21:21 <edwardk> i manually constructed a diagnostic, then told it to put it in the log
01:21:34 <edwardk> so the parseTest when it was done emitted all the warnings in the log, and then showed the output
01:21:42 <edwardk> yep
01:22:03 <edwardk> you can merge multiple such annotations in an error
01:22:39 <edwardk> i'm playing with annotating them with identifiers so i can refer to them in subsequent subdiagnostics
01:22:58 <edwardk> (diagnostics form a comonad, and you can nest them)
01:23:09 <edwardk> they'll render nested (optionally) as well
01:23:44 <quicksilver> hmm
01:23:52 <quicksilver> clever but might produce things which are hard to read :)
01:24:26 <edwardk> well, in my case i'm using it to describe type errors
01:24:36 <quicksilver> not sure I want diagnostics which have footnotes[1] which have footnotes [1] like a terry pratchett novel[2] [2] maybe there is a reason terry pratchett doesn't write compilers.
01:24:45 <edwardk> unable to unify this with that, showing the source ranges and the ranges for all of the actual variable instantiations, etc.
01:25:08 <edwardk> haskell errors already have footnotes of footnotes
01:25:39 <edwardk> anyways the nesting structure is analgous to the notes that you can attach in clang, just not flat
01:26:00 * quicksilver nods
01:26:03 <edwardk> in my case derivation trees cause me to have structure and flattening it made things harder to read
01:28:52 <edwardk> i didn't start out to write a whole new parser library
01:28:59 <edwardk> i was just going to shim this on top of parsec and be done
01:29:14 <edwardk> but then parsec doesn't interact with third party error types well at all
01:29:18 <edwardk> so i lost my diagnostics
01:31:47 <edwardk> oh, other things you can do nicely are hook in to PCRE, etc, because you can easily get the remaining text on the current line (as a side-effect of the diagnostics plumbing)
01:32:12 <edwardk> anyways, its kept me entertained ;)
01:41:01 <aki> morning
01:53:01 * hackagebot splot 0.2.3 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.2.3 (EugeneKirpichov)
02:08:01 * hackagebot uuagc-bootstrap 0.9.38.6.1 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-bootstrap-0.9.38.6.1 (ArieMiddelkoop)
02:08:03 * hackagebot fclabels 0.11.2 - First class accessor labels implemented as lenses.  http://hackage.haskell.org/package/fclabels-0.11.2 (ErikHesselink)
02:13:14 <mm_freak_> when using boolean operations like (&&) and (||), is fast low level boolean arithmetic used?
02:13:45 <Entroacceptor> just to see if I get this: fclabes is supposed to be the better records?
02:14:27 <shachaf> mm_freak_: In what context?
02:14:54 <shachaf> I would imagine that not in general, but maybe there are some optimizations for UArray or something?
02:14:58 * shachaf doesn't know.
02:15:40 <quicksilver> Entroacceptor: fclabels is useful library for dealing with haskell datatypes; some of its functionality address what other languages have in their record system
02:15:51 <quicksilver> but fclabels goes far further than any record system I've ever seen.
02:16:34 <quicksilver> mm_freak_: && and || are only defined on Bool
02:16:54 <quicksilver> it's not very hard to compile that efficiently.
02:17:04 <quicksilver> maybe you wanted .|. and .&. ?
02:21:13 <adimit> … Y DO U ENGAGE HERE?
02:23:01 * hackagebot uuagc-bootstrap 0.9.38.6.2 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-bootstrap-0.9.38.6.2 (ArieMiddelkoop)
02:23:12 <adimit> whoops, sorry, wrong channel.
02:39:22 <MichaelBurge> shachaf: unsafePerformIO was exactly what I needed - thanks for the suggestion
02:39:33 <shachaf> MichaelBurge: Wait, what?
02:39:39 <shachaf> Did I suggest unsafePeformIO somewhere?
02:39:53 <shachaf> Whatever the context was, I was probably joking.
02:40:06 <MichaelBurge> Probably, but it works to get me global variables per-module
02:40:22 <identity_> MichaelBurge: but it's bad.
02:40:23 <quicksilver> 08:53 < MichaelBurge> What's the best way to store state in a Haskell module?
02:40:23 <quicksilver> 08:55 < shachaf> The Best Way is to use unsafePerformIO malloc
02:40:50 <identity_> thus the "unsafe"
02:40:51 <coppro> ahahahahah
02:40:59 <coppro> MichaelBurge: use the state monad
02:41:11 <shachaf> I was joking there, yes. But "unsafePeformIO $ newIORef ..." is a reasonably common idiom.
02:41:28 <identity_> or the state transformer
02:42:03 * shachaf needs to stop doing that.
02:42:24 <MichaelBurge> I have a higher-level module that calls into a lower-level module. It already uses the state transformer for that, but if I use it in reverse the lower-level module needs to know the type in a higher module so I get a circular dependency
02:43:12 <quicksilver> shachaf: could have been worse
02:43:13 <quicksilver> http://qdb.us/306541
02:43:25 <quicksilver> (NB do not run the python code in that paste)
02:43:41 <coppro> MichaelBurge: put a typeclass in the lower module and give your type an instance
02:43:44 <shachaf> Well, that's just mean-spirited.
02:45:33 <identity_> shachaf: that's reminds me of some guy's python irc bot that allowed you to run commands via bash and get the output
02:46:15 <identity_> he tried to sanitize output by only allowing certain dirs and stuff.. I tried some stuff and eventually, he goes "wtf, my server's monitor just went blue and it's giving me a bunch errors about X"
02:46:35 <identity_> it was good times
02:46:54 <aninhumer> I like how the guy who did it calls someone else a douche -_-
02:50:20 <MichaelBurge> coppro: Is it possible using that method to have a list of such instances, all of which might be states from different modules?
02:50:54 <MichaelBurge> The list would be in the lower module
02:52:54 <mm_freak_> quicksilver: no, specifically (&&) and (||) and other logical operations
02:53:02 * hackagebot uuagc-cabal 1.0.0.0 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.0.0 (ArieMiddelkoop)
02:53:07 <quicksilver> identity_: I thought it was obviously stupid to even attempt to sandbox something like that. And then geordi proved me wrong.
02:53:17 <mm_freak_> i'm not asking for whether it's easy to compile them to efficient code, but for whether that's actually done
02:53:23 <mm_freak_> in recent versions of GHC at least
02:54:01 <coppro> MichaelBurge: Sure
02:54:05 <coppro> :t map Just
02:54:06 <lambdabot> forall a. [a] -> [Maybe a]
02:54:06 <coppro> as an example
02:54:22 <quicksilver> mm_freak_: if they are used in a context in which full strictness can be inferred they'll be compiled find.
02:54:25 <quicksilver> fine.
02:54:26 <coppro> err wait you want them all to be stored simultaneously?
02:54:31 <MichaelBurge> yes
02:54:32 <coppro> that requires more finesse
02:55:06 <coppro> best approach is probably to parameterize your types if possible
02:55:29 <identity_> quicksilver: well, he didn't really jail it properly
02:55:32 <identity_> he didn't chroot it or anything
02:55:39 * quicksilver nods
02:55:50 <quicksilver> geordi is considerably cleverer than chroot though.
02:55:53 <identity_> he was a novice programmer using python for a short time and was merely trying to disallow slashes and stuff
02:56:06 <identity_> I remember having a look at what geordi did but I dont' remember how it was done
02:56:31 <quicksilver> ptrace
02:57:36 <mauke> http://i.imgur.com/zTItf.jpg <- This is an ADULT LINK. Click at your own risk; you have been warned.
02:57:53 <coppro> geordi uses a chroot and ptrace, yeah
02:58:04 * hackagebot uuagc-bootstrap 0.9.38.6.3 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-bootstrap-0.9.38.6.3 (ArieMiddelkoop)
02:58:27 <identity_> mauke: Didn't figure you for one to post nudity :P
03:00:14 <hvr> mauke: ...rather disturbing link :-/
03:00:40 <identity_> Yeah, too old for me tbh
03:01:20 <aninhumer> Well you were warned
03:03:14 <mm_freak_> quicksilver: ok, thanks
03:04:18 <koala_man> haha
03:05:03 <cheater__> mauke, OMG DIDN'T MENTION NSFW
03:21:06 <NihilistDandy> Jesus, kmc, why not just get *all* the quotes in the HWN? :P
03:28:09 * hackagebot uuagc-bootstrap 0.9.38.6.4 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-bootstrap-0.9.38.6.4 (ArieMiddelkoop)
03:28:29 <mekeor> hello?
03:29:50 <NihilistDandy> Hello
03:31:47 <NihilistDandy> What's up, mekeor?
03:33:02 <mekeor> NihilistDandy: all right :] i'm fine; what about you? how are you?
03:33:10 <NihilistDandy> Pretty good
03:33:59 * mekeor is currently learning the big O notation oO
03:34:07 <NihilistDandy> Fun stuff
03:39:02 <erus`> how can i calculate the worth of a property in monopoly?
03:39:20 <erus`> try and guess the turns left in the game and guess the number of hits?
03:43:12 <NihilistDandy> I guess. Or just loosen your definition of "worth"
03:43:46 <NihilistDandy> Two huge guesses have the potential to cause a lot of trouble
03:44:23 <aninhumer> Perhaps the total assets of the opponents should be a factor also, since it's perhaps worth more if you can bankrupt someone
03:46:10 <NihilistDandy> I guess you could define worth as "percentage of opponent's liquid cash"
03:46:21 <NihilistDandy> s/cash/assets/
03:47:27 <aninhumer> Also, properties are worth more, since mortgaging/selling eliminates rent
03:47:39 <aninhumer> As a component of assets
03:48:58 <erus`> which haskellers should i be following on google+ ?
03:51:40 <NihilistDandy> That's not how Google+ works
03:51:45 <NihilistDandy> They have to decide to share with you
03:52:19 <NihilistDandy> You could totes follow me, though~
03:52:34 <quicksilver> NihilistDandy: well lots of people on Google+ are posting lots of posts to Public
03:52:38 <quicksilver> so following them is enough.
03:52:44 <quicksilver> particularly haskellers.
03:52:47 <quicksilver> I don't think it works very well though.
03:53:40 <joseanpg> > 1
03:53:41 <lambdabot>   1
03:53:51 <joseanpg> Hello
03:53:55 <mauke> > "Hello"
03:53:56 <lambdabot>   "Hello"
03:54:16 <NihilistDandy> erus`: Don Stewart, Edward Kmett, Shae Erisson, Daniel Peebles, Dan Knapp, in no particular order
03:55:36 <hpaste> harlekin pasted “extending happstack modules” at http://hpaste.org/50167
03:56:31 <joseanpg> I have a question
03:56:38 <joseanpg> why
03:56:49 <harlekin> I'm trying to extend the happstack-auth module by e-mail adresses and avatar support and I'm wondering if this is the right way to do it: http://hpaste.org/50167.
03:56:56 <mauke> joseanpg: because
03:56:57 <tulcod> i see that in haskell, game loops (and anything that in some sense "keeps running") uses iteration to do so... doesn't have haskell have a classical stack to run out of, then?
03:57:07 <joseanpg> why seq (case (undefined,undefined) of (x,y) -> (y,x)) 1 is 1  and
03:57:23 <joseanpg> and seq (case (undefined,undefined) of (x,y) -> x) 1 breaks ?
03:57:37 <harlekin> Basically, I am creating data-types with the same name which retain the data types from happstack-auth and extend them by the records I need. Then I wrap the functions of happstack-auth around them.
03:57:42 <saati> tulcod: i think if you don't return anything "up" haskell optimizes it out
03:57:44 <mauke> joseanpg: because seq only forces the top-level constructor
03:57:50 <harlekin> However, I am wondering if I am using happstack's Dependencies correctly.
03:57:51 <opqdonut> joseanpg: because seq only evaluates to weak head normal form
03:57:54 <mauke> joseanpg: which is (,)
03:58:02 <opqdonut> joseanpg: that is, it only evaluates up to the top-level constructor, like mauke says
03:58:07 <mauke> (,) _ _
03:58:38 <tulcod> saati: i suspected somehting like that, but it seems to me that it's quite radical to depend on optimization procedures for your application to work :P
03:58:39 <joseanpg> ok, thanks
03:59:07 <mauke> tulcod: I don't think haskell uses a normal call stack at all
03:59:18 <tulcod> then what?
03:59:28 <tulcod> a virtual one?
03:59:49 <joseanpg> what functions evals to normal form? Only IO?
03:59:56 <mauke> joseanpg: what?
04:00:18 <mauke> tulcod: I don't know how lazy evaluation works internally
04:00:53 <tulcod> mauke: but you're pretty sure it has to do with lazy evaluation, then?
04:01:09 <joseanpg> > seq (case (undefined,undefined) of (x,y) -> (y,x)) 1
04:01:10 <lambdabot>   1
04:02:00 <joseanpg> seq evaluates to weak head normal form, it stop in (,) _ _ in that example
04:02:15 <joseanpg> > case (undefined,undefined) of (x,y) -> (y,x)
04:02:16 <lambdabot>   (*Exception: Prelude.undefined
04:02:28 <mauke> tulcod: yes
04:03:02 <quicksilver> if I parse yor question correctly, joseanpg, the answer is 'no functions'.
04:03:06 <joseanpg> Now lambdabor evaluates to normal form because output function evaluates to normal form, isn't it?
04:03:06 <tulcod> mauke: okay, fair enough. will dive into that then i suppose. thanks mauke and saati!
04:03:07 <quicksilver> joseanpg: nothing evaluates to normal form.
04:03:34 <mauke> joseanpg: you can see the "(" at the beginning
04:03:43 <quicksilver> all evaluation is only as much as is required
04:03:45 <mauke> that's because it was trying to print "(" x "," y ")"
04:03:48 <quicksilver> (by pattern matching, or seq)
04:05:28 <joseanpg> then print evaluates to deep
04:05:34 <fryguybob> > seq (fst $ case (undefined,undefined) of (x,y) -> (y,x)) 1
04:05:35 <lambdabot>   *Exception: Prelude.undefined
04:07:05 <quicksilver> joseanpg: printing it evaluates just as much as the Show instance requires.
04:07:15 <quicksilver> you could have a Show instance which didn't evaluate all the way to NF
04:07:19 <joseanpg> > seq (fst $ case (undefined,(undefined,undefined)) of (x,y) -> (y,x)) 1
04:07:20 <lambdabot>   1
04:07:30 <quicksilver> although, certainly, show instances for normal data types will almost always evaluated to NF.
04:07:35 <joseanpg> case (undefined,(undefined,undefined)) of (x,y) -> (y,x)
04:07:48 <joseanpg> > case (undefined,(undefined,undefined)) of (x,y) -> (y,x)
04:07:49 <lambdabot>   ((*Exception: Prelude.undefined
04:08:02 <joseanpg> > print $ case (undefined,(undefined,undefined)) of (x,y) -> (y,x)
04:08:03 <lambdabot>   <IO ()>
04:08:04 <parcs> > testBit (5::Word16) 0
04:08:05 <lambdabot>   True
04:09:43 <fryguybob> > let show (_,_) = "(_,_)" in show (case (undefined,undefined) of (x,y) -> (y,x))
04:09:44 <lambdabot>   "(_,_)"
04:10:49 <quicksilver> exactly, fryguybob.
04:11:19 <joseanpg> > seq (show $ case (undefined,(undefined,undefined)) of (x,y) -> (y,x)) 1
04:11:19 <lambdabot>   1
04:11:45 <joseanpg> show doesn't go to normal form
04:12:49 <zhulikas> how to pattern-match such data type? data List a = Item a (List a) | Nil
04:12:51 <quicksilver> joseanpg: well if you only 'seq' the show, you are only forcing the first element of the list.
04:12:59 <quicksilver> joseanpg: (the list = the string that show returns)
04:13:13 * hackagebot stringsearch 0.3.6.2 - Fast searching, splitting and replacing of ByteStrings  http://hackage.haskell.org/package/stringsearch-0.3.6.2 (DanielFischer)
04:13:19 <mauke> zhulikas: case x of Nil -> ...; Item x xs -> ...
04:13:28 <zhulikas> ok thanks
04:13:34 <quicksilver> what I meant was - if you allow print to run to completion, so that it outputs the entire string, then it will still only evaluate as much as it needs for the Show instance.
04:14:52 <joseanpg> then (again) the only "thing" that evaluate to normal form is "print"?
04:15:02 <fryguybob> > let s = show (undefined,undefined) in (head s, s)
04:15:02 <lambdabot>   ('(',"(*Exception: Prelude.undefined
04:15:22 <quicksilver> joseanpg: (again) no
04:15:27 <quicksilver> joseanpg: *nothing* evalutes to normal form.
04:15:28 <benmachine> quicksilver: surely you're only forcing whether the list is nonempty or not
04:15:29 <joseanpg> :)
04:15:33 <benmachine> er, empty or not
04:15:39 <quicksilver> everythign evaluates only as much as is required.
04:15:46 <quicksilver> benmachine: yes 'whether the first element exists'
04:15:53 <quicksilver> I was slightly imprecise.
04:15:55 <benmachine> k
04:16:14 <quicksilver> joseanpg: so 'print' does not evaluate to normal form - it evaluates as much as it is required to evaluate
04:16:27 <benmachine> could you argue that deepSeq evaluates to normal form?
04:16:32 <quicksilver> (and that requirement is set in the first instance by the 'Show' instance for the datatype in question)
04:16:40 <quicksilver> benmachine: deepSeq is not part of the haskell language.
04:16:51 <quicksilver> benmachine: in order to implement deepSeq you have to write an instance for each data type
04:16:59 <quicksilver> there are many datatypes for which you cannot write one
04:17:04 <benmachine> quicksilver: sure, but the same goes for show, right?
04:17:09 <quicksilver> and you can, of course, write an instance which doesn't do that.
04:17:18 <benmachine> no function evaluates *every* input to NF
04:17:27 <quicksilver> so, if you accept the four caveats above, a cautious "yes".
04:17:37 <quicksilver> benmachine: absolutely. That is why I said "*nothing* evalutes to normal form."
04:17:58 <benmachine> yes, ok
04:18:07 <quicksilver> the running of a haskell process is not the process of reducing terms to normal form.
04:18:15 <quicksilver> (this *is* the definition of some other languages, but not of haskell)
04:18:30 <quicksilver> haskell only reduces terms as much as it needs to, to do what it's trying to do.
04:18:38 <quicksilver> which is what we mean when we call it a lazy language.
04:18:48 <zhulikas> I don't see how Item a (List a) is evaluated to Item x xs
04:19:17 <quicksilver> zhulikas: I would call that process not evaluation, but matching.
04:19:19 <zhulikas> why isint it Item x (List xs)
04:19:22 <joseanpg> umm
04:19:26 <zhulikas> ok, not matched
04:19:36 <joseanpg> the problem is in my question
04:19:45 <quicksilver> zhulikas: "Item a (List a)" is part of the type definition
04:19:47 <Cale> zhulikas: Can you perhaps give more context? It looks like the first of those might be a type and the second a value?
04:19:55 <quicksilver> zhulikas: "Item x xs" is a value pattern
04:20:03 <quicksilver> zhulikas: so your question doesn't quite make sense.
04:20:07 <joseanpg> it's a bad question
04:20:08 <quicksilver> but, the xs matches the 'List a' part.
04:20:19 <quicksilver> joseanpg: well, it's an interesting question :)
04:20:19 <benmachine> it's a somewhat confusing part of haskell's syntax that
04:20:23 <Cale> Note that there can be something called Item in the world of values and something called Item in the world of types, and those are two separate things.
04:20:27 <benmachine> when defining data types, you mix value names and type names
04:20:30 <quicksilver> Cale: the context is a page or so up.
04:20:40 <Cale> ah, I see
04:20:54 <quicksilver> 12:40 < zhulikas> how to pattern-match such data type? data List a = Item a (List a) | Nil
04:20:58 <quicksilver> 12:40 < mauke> zhulikas: case x of Nil -> ...; Item x xs -> ...
04:20:58 <benmachine> this is why some people prefer GADT syntax, even when used on normal types
04:21:24 <zhulikas> quicksilver, It works, but I want to know why :)
04:21:26 <mreh> how can I pop off a patch and save it for later?
04:21:27 <Cale> Yeah, perhaps we should write that out:
04:21:31 <Cale> data List a where
04:21:36 <Cale>   Nil :: List a
04:21:48 <Cale>   Item :: a -> List a -> List a
04:22:01 <Cale> So if x :: a, and xs :: List a
04:22:08 <Cale> then Item x xs :: List a
04:22:09 <hpaste> zhulikas pasted “Recursive data types” at http://hpaste.org/50169
04:22:10 <quicksilver> zhulikas: the "Item a (List a)" part of your type definition says that there is a constructor 'Item' which takes two parameters, one of type a and one of type List a
04:22:34 <quicksilver> zhulikas: you match such a constructor with "Item x xs", and 'x' gets the 'a' and 'xs' gets the 'List a'
04:22:45 <mreh> despite the obvious dependencies that may cause
04:22:48 <mauke> zhulikas: let's take for example: data Foo = Bar Int Int
04:22:58 <mauke> zhulikas: you match that with case x of Bar y z -> ...
04:23:10 <mauke> zhulikas: why don't you write case x of Bar Int Int -> ...?
04:23:11 <zhulikas> oh...
04:23:20 <zhulikas> there is value constructor name in the case x of ....
04:23:23 <zhulikas> sorry :|
04:23:39 <zhulikas> Soooo confusing
04:23:56 <joseanpg> It's true that print doesn't eval to NF
04:23:57 <joseanpg> > (1, (\x->2) undefined)
04:23:58 <lambdabot>   (1,2)
04:23:59 <zhulikas> after Haskell C would look like a piece of cake
04:24:25 <cheater__> after haskell c is like building houses out of pebbles.
04:24:37 <ion> on a hill of sand
04:24:47 <mokus> in a hurricane
04:24:52 <zhulikas> :))
04:24:53 <mreh> on venus
04:25:04 <Cale> zhulikas: Have you ever written a linked list datastructure in C?
04:25:04 <mreh> i win
04:25:05 <cheater__> while dead.
04:25:09 <cheater__> i won.
04:25:11 <mreh> d'oh
04:25:17 <Cale> (let alone an attempt at a polymorphic one)
04:25:26 <ion> I have. It’s fun.
04:25:32 <Cale> Yeah, it's "fun"
04:25:47 <cheater__> hey Cale, i have managed to check out ghc source :)))
04:25:48 <zhulikas> Cale, I have enough nightmares
04:25:54 <mreh> quicksilver: curves is broken :(
04:25:58 <zhulikas> I don't need one more :0
04:26:00 <Cale> But it's a lot more trouble than  data List a = Nil | Cons a (List a)
04:26:04 <cheater__> Cale, any idea how i'd get info about the GHC module? i have tried searching but can't find *antything*
04:26:08 <mreh> quicksilver: crayon sorry
04:26:12 <cheater__> also i can't find anything either.
04:26:36 <mreh> quicksilver:  Constructor `WeightedProperties' should have 4 arguments, but has been given 1
04:26:39 <mreh> :<
04:27:12 <mreh> i don't expect you to remember projects from over a year ago btw
04:27:54 <Cale> cheater__: hmm, there ought to be haddock documentation for at least your installed ghc somewhere on your system, depending on how you installed ghc
04:28:06 <Cale> (the ghc api has haddock documentation)
04:28:24 <cheater__> Cale, my ghc is on a server somewhere. i can only do text mode for that.
04:28:31 <Cale> oh
04:28:41 <cheater__> one reason why i hate html docs
04:28:43 <Cale> Any reason for that?
04:28:56 <cheater__> yeah, my pc has slow internet
04:29:04 <cheater__> i can only do "bigger" downloads on the shell
04:29:07 <quicksilver> mreh: oh, bother.
04:29:07 <Cale> ah, okay, hmm
04:29:10 <cheater__> or order dvds :)))
04:29:17 <quicksilver> mreh: I had to patch my own copy of OpenGL because it was broken.
04:29:20 <quicksilver> mreh: I forgot that :(
04:29:21 <Cale> maybe you could still copy the html docs locally.
04:29:38 <quicksilver> mreh: they fixed my bug upstream but fixed it a different way, so the code needs changing.
04:30:05 <joseanpg> show stops in the constructor
04:30:12 <joseanpg> > seq (show (undefined,undefined) ) 1
04:30:13 <lambdabot>   1
04:30:15 <quicksilver> no.
04:30:21 <quicksilver> show does whatever show does.
04:30:26 <cheater__> Cale, not necessarily.. but isn't there an online version of that?
04:30:32 <quicksilver> in most cases show will, in fact, force NF on its argument
04:30:34 <cheater__> and if not.. why? that's very bad
04:30:34 <Cale> oh, probably...
04:30:40 <quicksilver> but that's only if you consume the result.
04:30:43 <cheater__> do you have a copy on your pc?
04:30:46 <quicksilver> the result of show is a String = [Char]
04:30:50 <cheater__> maybe you can give me a string i could google for
04:30:50 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/index.html
04:31:00 <quicksilver> so if you 'seq' that, you're only checking top top constructor of the [Char]
04:31:00 <joseanpg> quicksilver: it doesn't eval to NF in that example
04:31:02 <joseanpg> > seq (show (undefined,undefined) ) 1
04:31:03 <lambdabot>   1
04:31:03 <Cale> ^^ first google result for "ghc api haddock"
04:31:19 <quicksilver> joseanpg: yes, which I am just explaining to you.
04:31:45 <quicksilver> joseanpg: the show instance on tuples does indeed put the tuple in NF (if that's true also fo the show instance for the two contained types)
04:31:46 <cheater__> ohh perfect thanks
04:31:48 <cheater__> haddock, ok
04:31:57 <quicksilver> joseanpg: but, the show instance, like everything else, is only evaluated as needed.
04:32:03 <cheater__> i keep getting confused by all those haskell things.. haddock, hoogle. hayoo, ..
04:32:14 <quicksilver> joseanpg: you are only 'seq'ing the show instance, so you are only forcing the top constructor of the String
04:32:17 <Cale> haddock is the documentation generator
04:32:26 <quicksilver> joseanpg: so it only has to check if the String has at least one char (the '(')
04:32:34 <mreh> quicksilver: stars works
04:32:37 <Cale> hoogle and hayoo are type-based search engines
04:32:56 <quicksilver> mreh: yeah, stars doesn't try to use the opengl tesselator
04:32:57 <Cale> I actually don't use those two as much as perhaps I ought to.
04:33:04 <mreh> quicksilver: okay
04:33:08 <mreh> i'll look into it
04:33:45 <Cale> But perhaps when you're less familiar with the really standard stuff, it'd be quite good.
04:35:30 <Cale> Most people end up reimplementing half the Prelude and list library in bits and pieces while learning. I actually consider this not a bad thing, as most of the things in the Prelude and list library are really good exercises :)
04:36:53 <fryguybob> > let seq [] b = b; seq (_:_) b = b in seq (show (undefined,undefined)) 1
04:36:54 <lambdabot>   1
04:36:57 <fryguybob> > let seq [] b = b; seq (_:_:_) b = b in seq (show (undefined,undefined)) 1
04:36:58 <lambdabot>   *Exception: Prelude.undefined
04:38:53 <cheater__> why do i need to use mapM if my function is a -> m b?
04:38:58 <cheater__> why can't i just use map?
04:39:04 <quicksilver> you can
04:39:11 <cheater__> then why does mapM exist?
04:39:24 <quicksilver> but you'll get [m b] not m [b]
04:39:37 <cheater__> ahh
04:39:57 <cheater__> is there a common name for a function [ m b ] -> m [b] ?
04:40:06 <quicksilver> sequence
04:40:16 <cheater__> :t sequence
04:40:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:40:24 <cheater__> interesting
04:40:27 <cheater__> thanks
04:40:30 <quicksilver> mapM f = sequence . map f
04:40:52 <cheater__> :t sequence . map f
04:40:53 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Show a1, SimpleReflect.FromExpr (m a)) => [a1] -> m [a]
04:41:09 <cheater__> :t sequence $ map f
04:41:10 <lambdabot>     Couldn't match expected type `[m a]'
04:41:10 <lambdabot>            against inferred type `[a1] -> [b]'
04:41:10 <lambdabot>     In the second argument of `($)', namely `map f'
04:41:13 <cheater__> hm
04:41:18 <joseanpg> Conslusion: I don't understand the evaluation process :)
04:41:20 <mreh> sequence and the list monad, that's a mind bending combination
04:41:20 <cheater__> why not sequence $ map f?
04:41:33 <quicksilver> map f is a function.
04:41:42 <quicksilver> you don't apply sequence to a function
04:41:48 <cheater__> oh right
04:41:49 <quicksilver> you apply sequence to a list
04:41:52 <quicksilver> - the output of map f
04:42:00 <quicksilver> (having stuffed 'xs' in there)
04:42:04 <quicksilver> sequence $ map f xs
04:42:07 <quicksilver> would be right.
04:42:12 <fryguybob> @type foldr (liftA2 (:)) (pure [])
04:42:13 <lambdabot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
04:42:14 <cheater__> yeah, i forgot that second parm :)
04:42:15 <cheater__> thanks :)
04:42:24 <quicksilver> the different between $ and . is just how many arguments you have already provided and how many are still waiting.
04:42:47 <mreh> :t (f =<< g) x
04:42:48 <lambdabot>     Ambiguous type variable `a' in the constraints:
04:42:48 <lambdabot>       `Show a' arising from a use of `f' at <interactive>:1:1
04:42:48 <lambdabot>       `SimpleReflect.FromExpr a'
04:42:54 <quicksilver> (actually that's a massive oversimplication but it is an interesting rule of thumb)
04:43:05 <mreh> :t \x -> (f =<< g) x
04:43:06 <lambdabot> forall a b t. (Show a, SimpleReflect.FromExpr (t -> b), SimpleReflect.FromExpr (t -> a), Monad ((->) t)) => t -> b
04:43:21 <hpc> :t f
04:43:22 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
04:43:55 <joseanpg> How *main* function works?
04:44:01 <mreh> :t \f g x -> (f =<< g) x
04:44:02 <lambdabot> forall a b t. (Monad ((->) t)) => (a -> t -> b) -> (t -> a) -> t -> b
04:44:26 <hpc> joseanpg: same as any other function
04:44:51 <joseanpg> his type must be IO a , isn't it?
04:45:46 <mreh> IO ()
04:46:06 <hpc> it can be IO a, then the runtime executes main >>= print
04:46:16 <quicksilver> hpc: does it? I didn't know that.
04:46:21 <quicksilver> that's a GHC special, if so.
04:46:26 <hpc> yeah
04:46:43 <mekeor> but usually main :: IO (), right?
04:46:48 <hpc> usually
04:46:48 <quicksilver> joseanpg: the only thing about main that is special is the fact that the runtime actually *executes* the IO actions in main.
04:47:14 <quicksilver> in terms of how you write it, it is quite a normal haskell expression
04:47:24 <quicksilver> but it is treated specially but the compiler in the sense that is in the 'entry point'.
04:47:48 <quicksilver> (incidentally, it's not really a function either, but it's quite common to use that word loosely)
04:48:19 <hpc> ((in general, IO a types are called actions))
04:49:55 <joseanpg> when the *engine* evaluates main, when it stops?
04:50:22 <joseanpg> no WHNF
04:50:24 <joseanpg> no NF
04:50:50 <hpc> when it executes, not evaluates
04:50:53 <fryguybob> The report says "When the program is executed, the computation main is performed, and its result (of type t) is discarded."  I think only ghci will print the a in IO a.
04:51:51 <hpc> hmm, seems you are right
04:51:56 <hpc> just tested with main = getLine
04:52:33 <fryguybob> I'm not sure about  ghci> main  vs  ghci> :main
04:52:42 <hpc> oh no, i remember what it was
04:53:00 <hpc> compiling it will have the final value discarded, but runghc will print it
04:53:31 <hpc> and experimenting confirms
04:53:46 <aninhumer> Hmm, how do I avoid syntactic negation if I actually want say (-2) as a function? Do I just have to do flip (-) 2?
04:53:52 <mauke> subtract 2
04:54:03 <quicksilver> joseanpg: it evalutes it, and then executes the actions.
04:54:19 <quicksilver> joseanpg: it's not clear what WHNF means for the IO type - the type is abstract by definition.
04:54:19 <joseanpg> hpc: could tou explain it a little more? What is the difference ? executes vs evaluates
04:54:36 <mekeor> > map (subtract 2) [1..5]
04:54:37 <lambdabot>   [-1,0,1,2,3]
04:54:37 <quicksilver> joseanpg: it evaluates it 'just enough' to carry out the actions.
04:54:43 <mekeor> col
04:54:45 <mekeor> cool
04:54:53 <hpc> joseanpg: my personal horrible metaphor is that evaluation is kind of like compilation
04:55:17 <joseanpg> umm
04:55:28 <hpc> i would listen to someone else for a good explanation :P
04:55:29 <joseanpg> "<quicksilver> joseanpg: it's not clear what WHNF means for the IO type - the type is abstract by definition."
04:55:37 <joseanpg> that is the problem then
04:57:18 <mekeor> aninhumer: this works, too:
04:57:20 <mekeor> > map ((-)1) [1..5]
04:57:21 <lambdabot>   [0,-1,-2,-3,-4]
04:57:50 <quicksilver> joseanpg: why is it a problem? It's abstract so you don't need to know what happens
04:58:02 <quicksilver> joseanpg: different implementations are free to do different things.
04:58:22 <joseanpg> ok, that *was* my problem :D
04:58:23 <quicksilver> joseanpg: certainly main isn't put into NF.
04:58:30 <mux> > map (subtract 2) [1..5]
04:58:31 <lambdabot>   [-1,0,1,2,3]
04:58:49 <quicksilver> evaluation is driven by demand
04:58:54 <quicksilver> "call-by-need"
04:59:34 <joseanpg> I'm trying understand that unspecified abstraction
04:59:49 <joseanpg> (I was)
04:59:51 <aninhumer> Is there a reason main couldn't/shouldn't be [[Char]] -> IO () ?
05:00:03 <hpc> :t getArgs
05:00:04 <lambdabot> Not in scope: `getArgs'
05:00:10 <mauke> aninhumer: no
05:00:12 <opqdonut> aninhumer: I guess not, other than simplicity
05:00:14 <Cale> aninhumer: It could be
05:00:28 <Cale> aninhumer: and you can always do something like:
05:00:30 <quicksilver> aninhumer: just a decision not to wed to traditional unix design, I think.
05:00:31 <opqdonut> but then it should maybe be [Arg] -> Env -> IO ()
05:00:34 <Cale> main = getArgs >>= main'
05:00:40 <Cale> main' xs = ...
05:00:51 <mekeor> which module includes getArgs?
05:00:57 <hpc> System.IO
05:01:01 <hpc> probably
05:01:05 <hpc> @hoogle getArgs
05:01:05 <lambdabot> System.Environment getArgs :: IO [String]
05:01:09 <hpc> or that
05:01:27 <mekeor> cool :)
05:01:46 <hpc> looks like System.IO is all handle stuff
05:01:50 <mauke> opqdonut: [Arg] -> Env -> IO Word8
05:01:57 <hpc> methinks that should have a better name
05:03:54 <aninhumer> mauke: [Arg] -> Env -> IO [Word8] -> IO ([Word8],[Word8]) :3
05:04:17 <mauke> huh?
05:04:24 <hpc> main :: a -> b
05:04:25 <opqdonut> mauke: oh, right
05:04:34 <hpc> begin panic
05:04:42 <aninhumer> stdin -> (stdout, stderr)
05:04:59 <mauke> aninhumer: those aren't parameters of main()
05:05:03 <opqdonut> yeah
05:05:15 <mauke> aninhumer: and stdin is [Word8], not IO [Word8]
05:05:22 <joseanpg> No evaluation of z here:  let z = undefined in case z of x ->7
05:05:25 <joseanpg> > let z = undefined in case z of x ->7
05:05:26 <mauke> aninhumer: and you forgot the exit status
05:05:26 <lambdabot>   7
05:05:34 <Cale> haha
05:05:45 <Cale> joseanpg: yes
05:05:52 <Cale> joseanpg: x is an irrefutable pattern
05:05:53 <aninhumer> mauke: I misunderstood what IO Word8 was for, and yes it should just have been [Word8]
05:05:57 <quicksilver> joseanpg: yes, because it is not required.
05:05:59 <Cale> joseanpg: so it doesn't evaluate
05:06:02 <aninhumer> yeah exit status
05:06:03 <joseanpg> But here yes:  let z = undefined in case z of 1 ->7
05:06:13 <quicksilver> joseanpg: evaluation is required by pattern matching.
05:06:17 <quicksilver> that's one of the main ways.
05:06:19 <Cale> joseanpg: z might not be 1, so it has to check
05:06:28 <joseanpg> ok
05:06:29 <quicksilver> in particular, checking constructors forces evaluation
05:06:37 <Cale> But z will always match x, so it doesn't look
05:07:01 <mightybyte> Where in the base package is the module corresponding to the System module in haskell98?
05:07:09 <Cale> System.IO
05:07:25 <joseanpg> then case evaluates to WHNF if no lazy patterns, isn't it?
05:07:34 <mightybyte> Cale: Thanks
05:08:03 <Cale> mightybyte: well, pretty much. There are some other System.* modules with I think one or two things which used to just be in System
05:08:52 <mightybyte> Cale: That seemed to do the trick for my immediate needs.
05:09:12 <quicksilver> joseanpg: no.
05:09:21 <quicksilver> joseanpg: case evaluates precisely as much as is required by the pattern.
05:09:32 <quicksilver> case x of ((a,b),c) ->
05:09:43 <quicksilver> evalutes 'two-deep' on the left and one-deep on the right.
05:09:55 <joseanpg> I read bad docs, ok
05:10:01 <quicksilver> case x of a:b:c:d:xs ->
05:10:08 <quicksilver> evaluates four :s deep.
05:10:15 <joseanpg> ok ok
05:10:38 <quicksilver> the only construct for which WHNF is special is 'seq'
05:10:48 <joseanpg> ok ok ok
05:10:49 <quicksilver> if seq was removed from the language we wouldn't need to know what WHNF was.
05:11:00 <mux> we'd have others problems though :-P
05:11:00 <aninhumer> quicksilver: Is using _ different to not using a named match, in terms of evaluation?
05:11:02 <quicksilver> (and seq is, in fact controversial)
05:11:19 <quicksilver> aninhumer: _ is just like using a name 'x' and never referring to it
05:11:31 <quicksilver> except the latter gives a warning with GHC if you have -Wall
05:11:57 <quicksilver> joseanpg: it might be important to note that "seq" is a language primitive. You couldn't write it yourself.
05:13:57 <fryguybob> quicksilver: You can write seq for some specific data types though right?
05:14:17 <opqdonut> no
05:14:53 <mightybyte> Cale: Ahh, yes.  System.Environment and System.Exit
05:15:02 <opqdonut> fryguybob: you're maybe thinking of rnf or some other stuff in Control.Parallel.Strategies or Control.DeepSeq
05:15:08 <mightybyte> ...for getArgs and exitWith respectively
05:15:15 <Cale> yeah
05:16:21 <quicksilver> fryguybob: yes, you could, but you'd have to write it each time.
05:16:31 <quicksilver> fryguybob: so it would have to be a typeclass
05:19:31 <parcs> @hoogle liftM11
05:19:31 <lambdabot> No results found
05:19:35 <parcs> :(
05:21:48 <Entroacceptor> M-eleven?
05:21:57 <parcs> yeah
05:22:04 <joseanpg> Is this a possible fold' implementation?  foldl' f a (x:xs) = let a' = f a x in seq a' fold f a' xs ?
05:23:12 <joseanpg> Could we replace seq with a case?
05:25:05 <joseanpg> Is this a possible fold' implementation?  foldl' f a (x:xs) = let a' = f a x in case a' of {0-> foldl' f 0 xs ;a'->a' fold f a' xs }?
05:25:22 <erus`> is there a haskell parser in the platform sdk?
05:25:25 <joseanpg> (again fold is foldl')
05:26:13 <rwbarton> only if the type of a is Integer
05:26:46 <rwbarton> that's what quicksilver means about having to write seq for each type separately
05:28:05 <rwbarton> (that implementation would also work for specific other numeric types like Int and Double but a Num context for a wouldn't be enough)
05:28:58 <joseanpg> hello?
05:29:42 <mekeor> hi joseanpg
05:30:00 <parcs> joseanpg: no
05:30:18 <fryguybob> @type \f' a b c d e f g h i j k -> f' <$> a <*> b <*> c <*> d <*> e <*> f <*> g <*> h <*> i <*> j <*> k -- parcs?
05:30:19 <lambdabot> forall a a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 b (f :: * -> *). (Applicative f) => (a -> a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> b) -> f a -> f a1 -> f a2 -> f a3 -> f a4 -> f a5 -> f
05:30:20 <lambdabot> a6 -> f a7 -> f a8 -> f a9 -> f a10 -> f b
05:30:32 <joseanpg> why?
05:30:39 <joseanpg> parcs?
05:30:42 <parcs> forcing a value of type 'a' is impossible without seq
05:30:46 <parcs> :t foldl'
05:30:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:31:28 <joseanpg> fotget the polymorphism
05:31:34 <DevHC> > foldl' (\a b -> a ++ " " ++ b) "." ["Y", "HALO", "THAR"]
05:31:36 <lambdabot>   ". Y HALO THAR"
05:31:43 <parcs> then it's not foldl'
05:31:44 <rwbarton> joseanpg: let's pretend overloading of numeric literals doesn't exist for now, so that 0 has type Integer, since that's a distraction here
05:32:25 <joseanpg> foldl' ::(Int -> Int -> Int) -> Int -> [Int]-> Int
05:32:27 <rwbarton> then your case version only gives you foldl' of type (Integer -> b -> Integer) -> Integer -> [b] -> Integer
05:32:47 <rwbarton> it is in fact the normal foldl' with that restricted type.
05:32:49 <joseanpg> is it possible?
05:33:21 <DevHC> someone say yes
05:33:43 <joseanpg> is it possible replace seq with a case in a foldl' restricted to Int?
05:33:49 <rwbarton> yes
05:33:55 <joseanpg> ok
05:33:59 <parcs> > foldl (+) [1..1000000]
05:34:00 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
05:34:00 <lambdabot>    arising from a us...
05:34:04 <parcs> > foldl1 (+) [1..1000000]
05:34:06 <lambdabot>   *Exception: stack overflow
05:34:14 <parcs> > foldl1' (+) [1..1000000]
05:34:15 <lambdabot>   500000500000
05:34:51 <joseanpg> case a' of {...}
05:35:16 <parcs> > case undefined of 0 -> (); _ -> ()
05:35:17 <lambdabot>   *Exception: Prelude.undefined
05:35:18 <joseanpg> rwbarton: what do you put in?
05:35:57 <rwbarton> the point being that you can implement seq yourself for Int, like you id in your definition of foldl' above,  seq a b = case a of { 0 -> b; _ -> b }
05:36:18 <harlekin> I'm trying to extend the happstack-auth module by e-mail adresses and avatar support and I'm wondering if this is the right way to do it: http://hpaste.org/50167.
05:37:14 <deech> Hi all, what is the rationale for putting record names and data constructors in the global namespace? The use case is that I'd like to have two data types that are similar so I'd like to have common accessors for the similar fields.
05:37:46 <joseanpg> foldl' f a (x:xs) = let a' = f a x in case a' of {0-> foldl' f 0 xs ;_-> foldl' f a' xs }?
05:37:55 <DevHC> deech: this is a known suckery, live with it :P
05:38:03 <rwbarton> joseanpg: yes that works
05:38:46 <deech> DevHC: ok, can I stick similar datatypes in different modules and use fully-qualified accessors?
05:38:47 <merijn> Type theory question of the day: Is there any correctness to saying that STLC is based on Martin-Löf (or vice versa)?
05:39:28 <DevHC> not sure
05:39:29 <joseanpg> foldl' f a (x:xs) = let a' = f a x; next = foldl' f a' xs in case a' of {0-> next ;_-> next}
05:39:41 <rwbarton> yes, that works too
05:40:03 <joseanpg> > let foldl' f a (x:xs) = let a' = f a x; next = foldl' f a' xs in case a' of {0-> next ;_-> next} in fold' (+) 0 [1..1000]
05:40:04 <lambdabot>   Not in scope: `fold''
05:40:15 <joseanpg> > let foldl' f a (x:xs) = let a' = f a x; next = foldl' f a' xs in case a' of {0-> next ;_-> next} in foldl' (+) 0 [1..1000]
05:40:16 <lambdabot>   *Exception: <interactive>:3:4-95: Non-exhaustive patterns in function foldl'
05:40:33 <DevHC> but if the data types are similar, then consider putting them in 1 data type (more constructors). that way accessors will be the same.
05:40:52 <rwbarton> deech: the "common" accessors would have different types, wouldn't they?
05:40:59 <rwbarton> I think that is the reason
05:41:15 <joseanpg> > let {foldl' _ a [] = a;foldl' f a (x:xs) = let a' = f a x; next = foldl' f a' xs in case a' of {0-> next ;_-> next} } in foldl' (+) 0 [1..1000]
05:41:16 <lambdabot>   500500
05:41:23 <joseanpg> > let {foldl' _ a [] = a;foldl' f a (x:xs) = let a' = f a x; next = foldl' f a' xs in case a' of {0-> next ;_-> next} } in foldl' (+) 0 [1..100000]
05:41:24 <lambdabot>   5000050000
05:41:31 <joseanpg> It works!
05:41:36 <joseanpg> hehehe
05:41:54 <rwbarton> or you're saying you'd prefer for only RecordName.fieldName to be defined or something like that
05:42:48 <zomg> Out of curiosity, how do you generally perform simple string parsing in Haskell? For example, say you want to split "foo!bar@baz" into three strings containing "foo", "bar" and "baz"
05:43:09 <joseanpg> > t: ' f a (x:xs) = let a' = f a x; next = foldl' f a' xs in case a' of {0-> next ;_-> next} } in foldl' (+) 0 [1..100000]
05:43:10 <lambdabot>   <no location info>:
05:43:10 <lambdabot>      lexical error in string/character literal at chara...
05:43:12 <zomg> I opted for regular expressions since that's what I'm used to using, but just wondering if there's a more "haskelly" way of going about it :)
05:43:23 <deech> rwbarton: Because Haskell doesn't have subtyping, so given two datatypes A and B, both of which have a "name" field I'd like to write "A.getName a" and "B.getName b".
05:43:25 <parcs> zomg: parser combinators
05:43:35 <joseanpg> How could I ask the type of that foldl' to lambdabot?
05:43:47 <Cale> zomg: The split library in Hackage can be useful for simple things, but parser combinator libraries like Parsec cover most of the cases for regular expressions.
05:43:49 <parcs> :t ()
05:43:50 <lambdabot> ()
05:44:09 <joseanpg> >:t let {foldl' _ a [] = a;foldl' f a (x:xs) = let a' = f a x; next = foldl' f a' xs in case a' of {0-> next ;_-> next} }
05:44:13 <Cale> (and do a lot more besides)
05:44:17 <rwbarton> deech: right, in that case you coul define A and B in separate modules and use qualified imports... it's a little awkward since it means one module per record
05:44:40 <zomg> parcs, Cale, I see.. I'll check it out. Thanks
05:44:41 <joseanpg> :t foldl' _ a [] = a
05:44:42 <lambdabot> parse error on input `='
05:44:46 <rwbarton> @type let {foldl' _ a [] = a;foldl' f a (x:xs) = let a' = f a x; next = foldl' f a' xs in case a' of {0-> next ;_-> next} } in foldl'
05:44:47 <lambdabot> forall t t1. (Num t) => (t -> t1 -> t) -> t -> [t1] -> t
05:44:48 <merijn> zomg: Depends, for REALLY simple string matching I'd just use pattern matching, for something slightly more complex maybe regex's (although I don't really like haskell's regex libraries) for anything that is beyond really simple I'd probably use parsing and go full blown parsing :p
05:45:04 <joseanpg> Perfect! thanks rwbarton
05:45:19 <saml> > > > > > > >
05:45:20 <lambdabot>   <no location info>: parse error on input `>'
05:45:28 <deech> rwbarton: I guess the "heavy-weight" solution is to introduce a common typeclass. But for some reason that makes me a little nervous.
05:45:30 <rwbarton> joseanpg: note that for a general type t, this function may not actually be foldl'
05:45:40 <rwbarton> deech: probably good reason :)
05:45:50 <joseanpg> I know, thanks rwbarton
05:46:18 <zomg> merijn: yeah noticed you could do some of that with just pattern matches... Text.Regex seemed to fit the bill for my case though :) Parsec seems interesting but just wanted to get it done quickly for starters
05:46:59 <merijn> zomg: Parsec is really easy, though :) wrote some fairly simple parsing code within like 15 minutes of first looking at it :p
05:47:15 <merijn> Real World Haskell (available online for free) has a nice intro chapter on it
05:47:33 <saml> some grammar cannot be parsed by parsec
05:47:44 <deech> Speaking of which, I'm a little confused as to when I should introduce a typeclass? Is it when I see that two or more datatypes share the same functionality?
05:48:00 <merijn> saml: And some grammars cannot be parsed by lex and yacc, what's your point?
05:48:08 <saml> data don't share functionality
05:48:12 <mux> deech: not necessarily, ADTs can be sufficient in that case; I think the most distinguishing feature of type-classes is that it leaves the datatype open
05:48:16 <merijn> deech: When it makes your code easier to read or simpler
05:48:25 <rwbarton> zomg: in this case you could also use standard list functions like break
05:48:28 <quicksilver> deech: no, when you want to overload the same identifier with two implementations.
05:48:49 <quicksilver> deech: your example here - a common record selector for two similar types - seems like a good reason to overload an identifier, yes.
05:49:27 <quicksilver> it's not really about types being similar : Integer and Double aren't similar - it's about having operations in common.
05:49:36 <joseanpg> > let {foldl' _ a [] = a;foldl' f a (x:xs) = let a' = f a x; next = foldl' f a' xs in case a' of {0-> next ;_-> next} } in foldl' (+) 0 [1..100000]
05:49:37 <lambdabot>   5000050000
05:49:43 <saml> > let f 1 = 1; f 'a' = 'a'; f x = x in f "asdf"
05:49:44 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
05:49:44 <lambdabot>         against inferred type...
05:49:51 <joseanpg> > let {foldl' _ a [] = a;foldl' f a (x:xs) = let a' = f a x; next = foldl' f a' xs in case a' of {_-> next} } in foldl' (+) 0 [1..100000]
05:49:52 <lambdabot>   5000050000
05:49:57 <quicksilver> deech: as for "why are field names in the global scope", it's because they're not really field names. They're just identifiers, mostly selector functions.
05:50:18 <rwbarton> > let { input = "foo!bar@baz" ; (x, '!':rest) = break (== '!') input ; (y, '@':z) = break (== '@') rest } in (x, y, z)
05:50:19 <lambdabot>   ("foo","bar","baz")
05:50:27 <joseanpg> > foldl (+) 0 [1..100000]
05:50:27 <lambdabot>   5000050000
05:50:34 <joseanpg> > foldl (+) 0 [1..1000000]
05:50:35 <merijn> The person to implement nicer accessors for recordtypes will be heralded as a hero amongst mortals
05:50:35 <lambdabot>   *Exception: stack overflow
05:50:41 <joseanpg> > let {foldl' _ a [] = a;foldl' f a (x:xs) = let a' = f a x; next = foldl' f a' xs in case a' of {_-> next} } in foldl' (+) 0 [1..1000000]
05:50:42 <lambdabot>   *Exception: stack overflow
05:50:45 <rtharper> the new releasae of GHC
05:50:48 <rtharper> is it more lion friendly?
05:50:50 <joseanpg> > let {foldl' _ a [] = a;foldl' f a (x:xs) = let a' = f a x; next = foldl' f a' xs in case a' of {0-> next ;_-> next} } in foldl' (+) 0 [1..1000000]
05:50:52 <lambdabot>   500000500000
05:50:56 <rtharper> than the current haskell platform release?
05:51:01 <saml> calm down
05:51:13 <saml> rtharper, no. use haskell platform
05:51:14 <deech> quicksilver: yes, I think I read that somewhere, for a users' standpoint it seems like a counterintuitive design choice.
05:51:19 <rtharper> saml: kk =/
05:51:22 * rtharper is sick of ld warnings, heh
05:51:24 <rwbarton> zomg: in this case it's a little ugly and what I wrote doesn't handle the nonmatching case at all--but just as an idea
05:51:32 <quicksilver> deech: if helps if you don't think of it as a record system.
05:51:46 <quicksilver> deech: it isn't. It's just some really simplistic extra syntax for ADTs.
05:51:46 <saml> rtharper, oh never mind. i misread it.  lion is osx? disregard my tweet
05:51:48 <deech> quicksilver: hah!
05:52:03 <rtharper> saml: haha yes
05:52:15 <saml> use a real operating system, not osx :P
05:52:15 <quicksilver> deech: however, haskell is sufficiently expressive that we can write quite good record systems in it; see the fclabels package on hackage.
05:52:15 <merijn> deech: I agree, like I just said "The person to implement nicer accessors for recordtypes will be heralded as a hero amongst (haskell programming) mortals" :p
05:52:25 <zomg> rwbarton: thanks, wasn't aware of all those funcs :)
05:52:28 <rtharper> saml: a fair number of haskellers use OS X ;)
05:52:43 <saml> more use something else
05:52:47 <merijn> saml: AFAIK a significant share of #haskell consists of OSX users :p
05:52:53 <rtharper> aye
05:52:58 <merijn> saml: More people use windows then linux, what's your point?
05:53:00 <saml> let's stop flamewar
05:53:10 <rtharper> ZOMG FLAMEWAR
05:53:24 <DevHC> merijn: than*
05:53:25 * Phyx- sharpens his tools
05:53:35 <Phyx-> bring it, i'll take you all on :P
05:53:53 * merijn sharpens his grammar nazi stabbing knife...
05:54:04 <deech> quicksilver: fclabels looks interesting
05:54:12 <saml> haskell needs CMS
05:54:18 <Phyx-> why?
05:54:31 <quicksilver> I don't think there is a nice way to solve the multiple accessors in scope thing.
05:54:32 <saml> because cms solves all problems
05:54:35 * DevHC loads his GP-40 (gr4mm4r p1st0l)
05:54:40 <quicksilver> or at least, I think the typeclass is the only nice way.
05:54:44 <merijn> saml: A Content Managing System? >.>
05:54:52 <merijn> s/managing/management
05:54:56 <quicksilver> if you have two types with a field called 'foo'
05:55:08 <deech> saml: If my cms you mean "Content Management System", I agree. I would help spread Haskell among web developers.
05:55:13 <quicksilver> then 'foo' should still be a normal haskell value, which means it has a single type.
05:55:33 <saml> quicksilver, put the two data in differnt module?
05:55:45 <rtharper> so back to my oriignal question, is 7.2.1 Lion (OS X 10.7) friendly? =p
05:56:20 <mightybyte> saml: My long-term goal has Snap ending up looking like a CMS
05:56:35 <saml> yes, CMS means haskell will replace java
05:56:49 <saml> and we get to curse haskell on a daily basis
05:57:18 <deech> Maybe a hacky solution would be to use TH to take each datatype with accessors and stick it in it's own module so that it can only be accessed in a fully qualified way. Or even better, grab the common accessors and stick them in a typeclass on-the-fly.
05:57:33 <quicksilver> deech: there are tools to do that.
05:57:34 <DevHC> todo: "qualified data T = C { a :: ... ... ...} " syntax
05:57:57 <quicksilver> deech: I don't really see how that's an improvement on
05:58:01 <quicksilver> sorry, DevHC
05:58:11 <quicksilver> data T = C { ta :: ..... }
05:58:14 <DevHC> deech: yes that works (i've just tested)
05:58:24 <quicksilver> I mean, you have to write qualified once, instead of 't' N times
05:58:31 <quicksilver> but that doesn't seem like a big difference ;)
05:58:37 <quicksilver> ta is less typing than T.a
05:58:45 <parcs> :t either throwError return
05:58:46 <lambdabot> forall a (m :: * -> *) a1. (MonadError a m) => Either a a1 -> m a1
05:58:51 <DevHC> meh
05:59:40 <quicksilver> the important question is whether you think the same symbol should be usable for two types
05:59:59 <quicksilver> and I'm definitely against any kind of 'ambiguous symbol' resolution which isn't the typeclass system we already have
06:00:06 <deech> DevHC: Thanks for doing that.
06:01:27 <saml> data T = C { ta :: ... }    data U = C { ta :: ... }       T.C   U.C  to construct.     T.ta   U.ta  to access
06:01:31 <saml> data should be module
06:01:35 <saml> amirite?
06:02:10 <deech> saml: right. That is what I was thinking of.
06:02:16 <saml> then hasekll will look more like java. module has data definition and functions
06:02:25 <saml> and with cms, haskell will be so popular
06:02:44 <deech> saml: but no state.
06:02:47 <saml> rid of purity, mix everything together. a fine language
06:02:47 <DevHC> data definition?
06:02:50 <joseanpg> rwbarton: where coluld I read more about seq implementation based in case?
06:03:09 <deech> I begin a use-case for having multiple modules in one file.
06:03:18 <deech> s/begin a/begin to see a
06:03:30 <saml> public module SameAsFileName where ...      private module Foo where
06:03:37 <applicative> rharper are you using  ghc-7.0.* on 'lion'?
06:03:56 <saml> public module SameAsFileName where {  private static module Foo where ... }
06:04:05 <DevHC> i have a funny idea
06:04:07 <DevHC> f :: type
06:04:09 <Phyx-> @src everything
06:04:09 <lambdabot> Source not found. My pet ferret can type better than you!
06:04:19 <DevHC> f a = ... where subFunction x = ...
06:04:27 <DevHC> subFunction is local to f
06:04:35 <johndded> Hello. I'm creating a Data.Array.Array using Data.Array.array and passing it a list of some of the elements of the array. Is there an elegant way to set to a default value all the values that I'm not explicitly passing it?
06:04:36 <saml> DevHC, yes
06:04:38 <DevHC> to use: f.subFunction :D
06:04:50 <saml> DevHC, no
06:05:00 <DevHC> well, acutually
06:05:03 <saml> use module
06:05:09 <DevHC> (f a).subFunction
06:05:21 <DevHC> because the subfunction may depend on the arguments to f
06:05:52 <rwbarton> joseanpg: the only thing I can think of is take a look at the Haskell Report and read about case statements and seq
06:06:52 <deech> Well pie-in-the-sky I guess. Haskell's still the funnest language to develop with and I'm glad it's popular enough that I can bitch about it!
06:06:53 <DevHC> saml: no u
06:07:01 <Cale> DevHC: That violates referential transparency
06:07:06 <quicksilver> deech: multiple modules in the same file would be great.
06:07:10 <DevHC> Cale: ?
06:07:32 <saml> > array (1,2) [(1,'a'), (2, 'b')]
06:07:33 <lambdabot>   array (1,2) [(1,'a'),(2,'b')]
06:07:45 <Cale> DevHC: As it stands, a function in Haskell is completely determined by which results it gives for various values of its parameters.
06:07:52 <quicksilver> deech, DevHC : the data-as-module idea is fine; I don't dislike it although I'm not desperate for it either. But the point (for me) is that it only solves a small part of the problem.
06:08:06 <saml> johndded, i think you have to pass all elements
06:08:07 <Cale> DevHC: That feature would let you see inside the function definition, and would mean that otherwise equal functions are not equivalent.
06:08:14 <quicksilver> because these things (like ta or T.ta) are only accessors.
06:08:26 <saml> > array (1,2) [(1,'a')]
06:08:27 <lambdabot>   array (1,2) [(1,'a'),(2,*Exception: (Array.!): undefined array element
06:08:35 <quicksilver> solving the whole problem means abstracting update as well as selection
06:08:38 <quicksilver> which means you need lenses
06:08:56 <quicksilver> and by the time you're using lenses (e.g. fclabels) the scope problem pretty much goes away.
06:09:07 <DevHC> Cale: new definition: a name f refers to the function f AND a namespace of f's subfunctions
06:09:15 <Cale> (two implementations of the same function would present different fields depending on what was inside their where clause, and would probably need to have different types which expressed all the names of the things in their where clauses)
06:09:20 <johndded> saml: thanks
06:09:28 <quicksilver> although some metaprogramming to set up the lenses and possibly typeclass instances would be handy.
06:09:33 <quicksilver> such things have been written, too.
06:09:41 <Cale> It would greatly complicate the type of most functions.
06:09:44 <rwbarton> johndded: I guess I would write something like   listArray yourBounds (repeat defaultElement) // keyValuePairs
06:09:49 <saml> johndded, how are you calling array?
06:09:54 <rwbarton> @type (//)
06:09:55 <lambdabot>     Ambiguous occurrence `//'
06:09:55 <lambdabot>     It could refer to either `L.//', defined at <local>:1:0
06:09:55 <lambdabot>                           or `Data.Array.//', imported from Data.Array
06:10:16 <rwbarton> @type (Data.Array.//)
06:10:17 <DevHC> Cale: well, yes, typing would be tedious if we were to make typing required
06:10:17 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
06:10:24 <parcs> > let x = 5 :: Num a => a in (x :: Int, x :: Integer)
06:10:24 <lambdabot>   (5,5)
06:10:27 <Cale> Because what is the type of that f? You'll have to include all the types of the things defined in the where clause for f in the type of f
06:10:29 <johndded> rwbarton: that sounds like a solution - create a default array, and then update with my values - thanks
06:10:34 <Cale> It's better just to use data for this
06:10:47 <Cale> You can construct a record of a bunch of functions too.
06:11:13 <Cale> (what you're doing is turning where clauses into records of their definitions)
06:11:35 <DevHC> Cale: still, for debugging, this "(f a).subf" hack sound very interesting
06:12:01 <DevHC> Cale: records of functions r not the same
06:12:05 <Cale> maybe GHCi could let you see inside the where clauses of functions somehow
06:12:11 <DevHC> i'm thinking of function definitions like:
06:12:13 <Cale> (auto let-lift)
06:12:13 <saml> DevHC, f a is a value. you can probably do that
06:12:30 <saml> f a  :: ModuleThatHas_subf
06:12:34 <DevHC> f a b = g b where g x = (something depending on x AND a)
06:12:47 <saml> can you return module? module isn't first class right?
06:13:04 <DevHC> saml: it'll be firstclassed S00N(TM) :]
06:13:28 <saml> can you make it firstclass now? my business depends on it. thanks. and make sure oracle won't sue for patent
06:13:42 <saml> which company has patent for modules?
06:13:58 <DevHC> THC
06:14:04 <DevHC> organization
06:14:08 <DevHC> (The Haskell Community)
06:15:20 <erus`> i have a patent on 'where'
06:15:31 <erus`> you will all have to use let's or pay me
06:15:34 <DevHC> http://www.patentstorm.us/patents/7028023.html
06:16:28 <DevHC> erus`: i have a patent on apostrophes, and u will not use apostrophes for plural. u cannot negotiate ur way out of this.
06:16:51 <osfameron> I thought datastructures weren't patentable (being algorithmic)
06:17:05 <erus`> god bless america
06:17:12 <erus`> fucking greedy bastards
06:17:19 <DevHC> lol
06:17:28 <merijn> I feel compelled that point out that you're typing "u" and "ur" after calling me out on accidentally mixing up "then" and "than" >.>
06:17:42 <DevHC> ROFL
06:18:02 <DevHC> @let u = you
06:18:03 <lambdabot>  <local>:6:4: Not in scope: `you'
06:18:04 <merijn> Anyway, I'm off to patent parenthesis in an attempt to troll the Lisp community...
06:18:11 * Lycurgus was told software patents really only apply in the US
06:18:36 <merijn> Lycurgus: The EU doesn't acknowledge software patents as of yet. Outside the EU YMMV
06:18:47 <DevHC> Lycurgus: US patents only apply in the US
06:18:50 <erus`> it makes me sick
06:19:21 <merijn> erus`: That's bad, considering the lack of socialized healthcare... :>
06:19:29 <Lycurgus> DevHC, acknowledged, all patents are nation-state franchises.
06:19:43 <merijn> I should probably join -blah for political trolling >.>
06:19:43 <erus`> merijn: its ok i live in england :)
06:19:47 <mekeor> in Foobar.hs, i wrote this: 'data Foo = F { foo :: Bar, bar :: Baz }'. i want to use the 'Bar'- and 'Baz'-constructors in other modules, too.  how can i allow other modules to use *all* constructors of one type (here: 'Foo') (using the 'module'-keyword) ?
06:19:56 <erus`> england also makes me sick
06:20:32 * mekeor btw HATES software patents..
06:21:16 <erus`> if you can write any algorithm in haskell then its maths, right? and cant be patented
06:22:17 <merijn> erus`: That is the usual defense, yes
06:22:22 <DevHC> mekeor: like: 1. Foohar.hs: module Foohar where data Foo = ...     2. Main.hs: import Foohar ...?
06:22:42 <mekeor> DevHC: yes
06:22:47 <merijn> The problem is not so much software patents (unless you think ALL patents are a problem, but lets leave that out of scope)
06:23:16 <mekeor> DevHC: or rather: 'Foobar.hs: module Foobar (Foo, ...) where ...'
06:23:26 <merijn> The problem is the lack of understanding of software amongst patent reviewers. Leading them to OK completely trivial patents and patents with prior art
06:23:40 <DevHC> indeed :P
06:24:45 <zomg> lack of understanding of software is an issue in all government I'm afraid, not just patent stuff :P
06:25:07 <merijn> s/in all government I'm afraid, not just patent stuff//
06:25:08 <zomg> perhaps lack of understanding of computers / IT in general..
06:25:33 <merijn> We have no clue what the hell we're doing when it comes to computers
06:25:48 <johndded> would anyone here want to work reviewing patents? i wouldn't, so no wonder they get crap people
06:26:11 <merijn> In a thousand years (assuming we're not extinct) people will look back on us the way we look back on medicine in the Roman empire
06:26:26 <zomg> Trepanation!
06:26:36 <erus`> in 1000 years we will be dead
06:27:17 <DevHC> would anyone here want to work on reviewing P vs NP proofs? i would :]
06:27:28 <zomg> Too mathy
06:27:29 <zomg> :D
06:27:59 <parcs> erus`: i won't
06:28:07 <plat0> DevHC: There are plenty of P vs NP proofs on the arXiv you can review if you like :] ... not to mention proofs of the Riemann hypothesis
06:28:22 <mekeor> DevHC: just start. i listen =)
06:28:36 <DevHC> plat0: orly.
06:28:37 <merijn> DevHC: Did you see the informal poll of TCS researchers on P vs NP? With their opinion on "what will the answer be, when will we find it, etc" and most interesting "additional comments/fears" :p
06:29:01 <Phyx-> :t log_action
06:29:02 <lambdabot> Not in scope: `log_action'
06:29:07 <merijn> One wrote down "I fear that P vs NP will be proved by a French mathematical PhD student who will only publish his results in French" :D
06:29:20 <DevHC> ROFL
06:29:34 <zomg> plat0: I wish wikipedia pages for that sorta stuff listed things like why solving it would be good for people like myself who don't understand it at all :D
06:29:56 <DevHC> google can translate french speech, but can't translate french math xD
06:30:38 <DevHC> well i've read some bits of some P vs NP proofs
06:30:46 <DevHC> a couple were utter failures
06:31:00 <hpaste> mekeor pasted “my current problem (concerning 'module' and 'data')” at http://hpaste.org/50173
06:31:12 <plat0> zomg: Most in the field think that P != NP, and if this is proved the consequences will be very little, since that's what we think anyway.
06:31:25 <DevHC> one was written by some italian n00bs who wrote more english grammar failures than characters in the paper
06:31:56 <zomg> mekeor: oh that's what you meant
06:32:05 <zomg> foo and bar are not constructors, but rather accessors
06:32:24 <mekeor> oh, kay :)
06:32:32 <zomg> use module Foobar (Foo (..)) to allow everything
06:32:44 <zomg> or Foo (x, y) to allow specifics
06:33:04 <DevHC> and they write things like "specialty of our algorithm is dynamic adaptation", which sounds like a stupid attempt to allow claims like "but our algorithm does just that!" when someone really discovers that P=NP
06:33:05 <mekeor> zomg: '..' ?? is that regular haskell syntax? cool!
06:33:14 <zomg> mekeor: no idea, but it works :D
06:34:00 <mekeor> zomg: great stuff! thanks! :)
06:34:32 <merijn> DevHC: Found a link to the poll: http://www.cs.umd.edu/~gasarch/papers/poll.pdf
06:34:43 <merijn> Quite an interesting read
06:35:40 <DevHC> LOL, i vote for: S00N(TM)
06:43:15 <erus`> how do i get the area under a 4 dimensional plane?
06:43:50 <merijn> Simple, take the technique for a 3 dimensional plane and generalize it to 4 dimensions
06:43:52 * merijn ducks
06:45:00 <dainanaki> ducks!? where!?
06:47:11 <erus`> what is a 4d plane?
06:48:14 <merijn> Depends on what the fourth dimension you are using is.
06:48:18 <DevHC> set of (a,b,c,d) real^4 points which satisfy ax + by + dz + ew = f
06:48:34 <quicksilver> that's a plane in 4d
06:48:50 <quicksilver> planes themselves are two dimensional, in the language I'm used to using.
06:49:21 <cheater__> erus`, you need to define the set of points inside that plane.
06:49:58 <quicksilver> not sure if DevHC's definition gives a 2d plane in 4d, or a 3d volume in 4d.
06:50:00 <cheater__> if your plane is specified by f(x, y, z, w) = C, then your points may or may not lie at f(x, y, z, w) < 0
06:50:08 <quicksilver> clearly I need more coffee.
06:50:21 <cheater__> planes in 4d are three-dimensional.
06:50:39 <rtharper> hrm, how might I resolve this
06:50:42 <ClaudiusMaximus> you get to pick!  i pick 2d-planes
06:50:43 <cheater__> volumes in 4d are four-dimensional.
06:50:51 <rtharper> Implicit import declaration: Ambiguous module name `Prelude':  it was found in multiple packages: base haskell98-2.0.0.0
06:50:52 <quicksilver> that's a possible generalisation, cheater__, but that's not the one I'm used to.
06:51:15 <quicksilver> in my experience planes are always 2-spaces and volumes are always 3-spaces.
06:51:27 <quicksilver> (4-spaces are occasoinaly called 4-volumes, but normally just 4-spaces)
06:51:43 <cheater__> i think you mean "manifolds" there
06:51:52 <rwbarton> a linear subspace of codimension 1 is often called a hyperplane
06:51:53 <zhulikas> (_:x:_) matches two-element list. Is it because second underscore means [] ? Like in "z : x : []" ?
06:52:08 <quicksilver> yes, what rwbarton said.
06:52:34 <quicksilver> zhulikas: no.
06:52:46 <quicksilver> zhulikas: the second underscore means either [] or (_:_)
06:52:46 <companion_cube> zhulikas: i think you have a prize in the "smiley like expression" category
06:53:12 <quicksilver> zhulikas: (_:x:_) matches two or more, not merely exactly two.
06:53:40 <zhulikas> quicksilver, yesh. I wasn't clear but I understand that second _ may match everything what is after x
06:54:00 <zhulikas> but ok. You answered my question
06:54:02 <zhulikas> thanks
06:54:08 <quicksilver> :)
06:54:15 <cheater__> why does _:x:_ not match two-element lists?
06:54:22 <zhulikas> it does match. :)
06:54:31 <zhulikas> second underscore is either [] or remaining elements of a list!
06:54:32 <zhulikas> :D
06:55:07 <cheater__> ok.
06:55:24 <cheater__> what did quicksilver mean then by "not merely exactly two"?
06:55:51 <quicksilver> cheater__: could be three or four or more....
06:55:55 <merijn> cheater__: The implicit part of that sentence was "but also lists longer then two"
06:56:01 <merijn> than, even
06:56:13 <quicksilver> cheater__: "two or more, not merely exactly two"
06:56:15 <zhulikas> another new haskeller in here?:)
06:56:26 <merijn> Screw this English grammar business >.>
06:57:12 <cheater__> quicksilver, but it does match two.
06:57:18 <cheater__> so what you said is not true.
06:57:33 <quicksilver> I think it is true.
06:57:37 <quicksilver> It matches exactly two.
06:57:41 <cheater__> or did you mean that it matches two, and more, but not two, and not more?
06:57:43 <quicksilver> But it does not only match exactly two
06:57:43 <byorgey> "not merely X" means "X, but not just X"
06:57:52 <quicksilver> it also matches other things (more than two)
06:57:53 <mauke> cheater__: do you know english?
06:58:03 <quicksilver> well it was a strange reading sentence
06:58:04 <cheater__> mauke, no u
06:58:12 <quicksilver> I tried a couple of other ways to write it and didn't like them :)
06:58:28 <Axman6> cheater__: i guess that's a no :P
06:58:30 <byorgey> mauke: unnecessary.
06:58:44 <cheater__> quicksilver,  :)
06:59:03 <Axman6> byorgey: i felt is was a sincere question :\
06:59:12 <merijn> So did I
06:59:17 <Phyx-> @hoogle GhcApiCallbacks
06:59:17 <lambdabot> No results found
06:59:19 <Phyx-> booo
06:59:22 <merijn> Maybe I'm just an optimist
06:59:26 <cheater__> because it was
06:59:31 <quicksilver> mauke is unnecessary, but he's also useful :)
06:59:42 <Axman6> heh
06:59:43 <cheater__> mauke is just unfriendly
06:59:54 <Axman6> unfriendly?
06:59:55 <byorgey> cheater__ obviously knows English.
07:00:14 <Phyx-> heh
07:00:17 <hpaste> ricree pasted “build error” at http://hpaste.org/50174
07:00:19 <byorgey> but "knowing English" does not mean "able to perfectly parse and comprehend eve English sentence"
07:00:22 <Phyx-> it seems GHC 7.2 has played with the api again
07:00:22 <byorgey> *every
07:00:38 <cheater__> byorgey, yeah, when someone asked me whether i felt so terribly inadequate :(
07:00:41 <ricree> heh.  so that's what the channel option does
07:00:44 <Axman6> i believe the question was to assertain whether he knew english well, ie, was it his first language. where the conversation goes after the answer may well depend on that
07:00:48 <cheater__> *whether i did
07:00:56 <cheater__> see, it's taking its toll already.
07:01:03 * Phyx- doesn't wanna figure it out all over again
07:01:07 <cheater__> btw, i have a question
07:01:13 <Phyx-> i'll wait for the RTW version
07:01:56 <byorgey> ricree: the error message means you have not given enough arguments to doDrawOp
07:02:49 <cpa> readProcess cmd [opt1,opt2] seems to execute cmd "opt1" "opt2". How can I execute cmd opt1 opt2 ?
07:02:57 <byorgey> ricree: you still have to give it an argument of type (b -> extArgs)
07:03:00 <cheater__> say i have GHC.getInfo, like here: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/GHC.html
07:03:14 <byorgey> cpa: what's the difference?
07:03:14 * hackagebot doctest 0.4.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.4.1 (SimonHengel)
07:03:21 <cheater__> i can't really instantiate it in a ghc interpreter... how can i "play around" with it to see what it does?
07:03:26 <cheater__> without recompiling GHC every time?
07:03:36 <ricree> I'm about to add one that does work.  when I do, could you look at that and help me figure out why one works but  not the other?
07:03:38 <rtharper> If I have a cabal package that depends on both base and haskell98*
07:03:42 <rtharper> is there any way to resolve this?
07:03:49 <cpa> byorgey: well I feed it to some external program which very happy with cmd "opt1"
07:03:50 <byorgey> ricree: sure
07:03:55 <rtharper> If I hide one or the other it still throws an error
07:04:00 <quicksilver> cheater__: AFAIK there is no way to play with the GHC API directly from inside GHCi
07:04:01 <rtharper> why are both not allowed?
07:04:04 <quicksilver> cheater__: is that what you meant?
07:04:21 <cheater__> yeah pretty much
07:04:26 <byorgey> rtharper: what version of GHC are you using?
07:04:32 <rtharper> 7.2.1
07:04:34 <cheater__> i want to modify the GHC source to add a new :command, but i don't really know how
07:04:42 <quicksilver> cheater__: unfortunately GHCi can't load the GHC API (it collide with itself)
07:04:45 <cheater__> so i thought i'd start by modifying :info
07:05:00 <quicksilver> and it doesn't give you access to its own copy of itself
07:05:03 <quicksilver> if that makes any sense at all.
07:05:07 <cheater__> :t GHC.getInfo
07:05:08 <lambdabot> Couldn't find qualified module.
07:05:11 <cheater__> ?????????????
07:05:18 <cheater__> et tu, lambdabot?
07:05:23 <rtharper> byorgey: 7.2.1
07:05:23 <quicksilver> lambdabot doesn't have the GHCI modules loaded.
07:05:44 <cheater__> quicksilver, my problem right now is to figure out what Name is
07:05:56 <cheater__> aka the first argument of getInfo
07:06:30 <hpaste> ricree annotated “build error” with “build error (annotation)” at http://hpaste.org/50174#a50175
07:06:46 <byorgey> rtharper: yes, the version of haskell98 and base that come with ghc 7.2 are incompatible (by design)
07:06:57 <ocharles> Function composing question... I have something that returns   Maybe a  and something that is  a -> m b  - How can I compose these to get something that takes Maybe a -> m (Maybe b)  ?
07:07:01 <byorgey> rtharper: you are dealing with a package that has not been updated to work with ghc 7.2 yet.
07:07:03 <Phyx-> cheater__: every value in a haskell file is given a unique Name to identify it,  that's that name
07:07:24 <rtharper> byorgey: this is true =) what needs to be modified? just the cabal file or the source as well?
07:07:38 <quicksilver> ocharles: fmap
07:07:44 <ocharles> I thought it would be fmap
07:07:51 <ocharles> but I end up getting Maybe (m b)
07:07:54 <quicksilver> right
07:08:06 <ocharles> so presumably I'm fmaping at the wrong time
07:08:07 <quicksilver> well if you don't have an 'a'
07:08:20 <quicksilver> then you can't run the action which is your second one
07:08:24 <ocharles> right
07:08:27 <byorgey> rtharper: I don't know, it depends on the source I suppose.  try removing one or the other from the list of dependencies in the .cabal file and see if it builds.
07:08:34 <ocharles> so I return Nothing
07:08:38 * quicksilver nods
07:08:39 <cheater__> Phyx-, what structure does Name have?
07:09:04 <dainanaki> will I see any compilation speedups by passing GHC +RTS -N4?
07:09:16 <quicksilver> ocharlse : maybe (return Nothing) (fmap Just f)
07:09:21 <quicksilver> :t maybe
07:09:22 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:09:27 <ocharles> yep, I know  maybe
07:09:28 <quicksilver> that's not quite right either
07:09:31 <ocharles> heh
07:09:32 <Phyx-> cheater__: http://www.haskell.org/ghc/docs/7.0.2/html/libraries/ghc/src/Name.html#Name
07:09:54 <Phyx-> cheater__: i haven't found anyway to reliably construct a name when doing lookups
07:10:03 <Phyx-> cheater__: so instead I look them up in the tree
07:10:07 <quicksilver> :t traverse
07:10:08 <lambdabot> Not in scope: `traverse'
07:10:11 <rtharper> byorgey: It complains that it is missing "Maybe" from haskell98
07:10:16 <cheater__> Phyx-, what are you doing that for?
07:10:19 <quicksilver> ocharles: I have a feeling the generalisation involves 'traverse'
07:10:20 <cheater__> what does your program do?
07:10:20 <rtharper> byorgey: but surely this can be found in base?!
07:10:28 <ocharles> I have a feeling I've tried to do this before, and it ended up being with traverse
07:10:31 <quicksilver> ocharles: try traverse after the fmap.
07:10:33 <quicksilver> yes.
07:10:41 * ocharles does a git-grep for traverse
07:10:47 <byorgey> rtharper: aha, no, base contains Data.Maybe, not Maybe
07:10:48 <rtharper> byorgey: is that in Data.Maybe?
07:10:55 <rtharper> byorgey: ahh, kk =)
07:10:58 <acowley> ocharles: maybe (return Nothing) (fmap Just . f)
07:11:07 <byorgey> rtharper: the haskell98 standard specified libraries like Maybe, List, etc.
07:11:08 <Phyx-> cheater__: if it helps at all, this is my code for callong getInfo http://pastebin.com/MmQsW9Tf
07:11:12 <mauke> The paste MmQsW9Tf has been copied to http://hpaste.org/50176
07:11:19 <Phyx-> cheater__: intellisense quickinfo
07:11:23 <byorgey> rtharper: but the Haskell 2010 standard now includes the hierarchical modules
07:11:47 <rtharper> byorgey: why were they made incompatible, btw/
07:11:58 <cheater__> Phyx-, interesting
07:12:12 <rtharper> byorgey: ohh, okay, so really Maybe, etc are deprecated
07:12:12 <rtharper> or will be
07:12:18 <cheater__> Phyx-, do you have to compile your own version of ghc in order to use this code?
07:13:40 <Phyx-> cheater__: yes, but that's because hsc_entrypoint isn't in the ghc api. I had no way of finding the name of the module that was loaded, so i had to write my own. All the examples using the api that I found online hardcoded the module name. which was not useful to me
07:13:46 <byorgey> rtharper: indeed, they are no longer part of the latest Haskell standard
07:13:52 <ocharles> Sweet,  traverse getByKey (editionFormat . copoint $ edition)  does what I want
07:14:04 <byorgey> rtharper: haskell98 and base export incompatible versions of the Prelude
07:14:05 <cheater__> Phyx-, what's hsc_entrypoint for?
07:14:32 <byorgey> rtharper: what package are you trying to build, by the way?
07:15:08 <rtharper> byorgey: okay, one other strange error, this lib had INLINE pragmas for typeclass fucntion names
07:15:08 <rtharper> byorgey: GHC 7.2.1 seems to hate this
07:15:08 <rtharper> I get the "    The INLINE pragma for default method `****' lacks an accompanying binding
07:15:19 <Phyx-> cheater__: it's a value that refers to the actual module name of the file you loaded, the GHC apis require you to give the module name when doing stuff like typechecking. but the module name is never really returned to you after you load it
07:15:25 <ricree> byorgey: Not sure if you saw, but I posted the one that works  http://hpaste.org/50175.   In retrospect, though, the nonworking one wouldn't accomplish what I was after anyways.  What I was trying for was to make it so that the function winds up with an IO() so I can use some of the Foreign.C functions inside of it
07:15:31 <byorgey> rtharper: hmm, no idea about that one
07:15:33 <Phyx-> cheater__: http://mistuke.wordpress.com/2010/08/09/quickinfo/ is what i'm using it for. with pics, lol
07:15:40 <rtharper> is this no longer allowed?
07:15:49 <ricree> But the way I was going at it wouldn't accomplish that.
07:16:11 <byorgey> ricree: OK.
07:16:42 <Phyx-> cheater__: another way of doing it is by doing a dep analysis and looking at the node with no incoming edges, but that's not reliable
07:16:49 <joseanpg> &q lambdabot
07:17:14 <rtharper> anyone else? ;)
07:17:26 <cheater__> Phyx-, i'm sort of trying to hack together a modification to ghc which will let me view the ghc docs for a certain function/module using ghc itself
07:17:27 <acowley> rtharper: you'd need the INLINE pragmas on instance definitions, so emitting warnings when such pragmas are on class functions that lack default bindings sounds user-friendly to me
07:17:47 <rtharper> acowley: it's not warnings
07:17:57 <rtharper> acowley: they are errors =p
07:18:14 <ion> ocharles: I take it it’s okay for the side effect of the a → m b not to happen if the Maybe a is Nothing?
07:18:20 <acowley> rtharper: I guess it's a tough love variant of user-friendly
07:18:39 <ocharles> ion: hrm, traverse something Nothing, will still run "something"?
07:18:52 <ocharles> How? What parameter could 'something' get?
07:18:55 <rtharper> :t traverse
07:18:56 <lambdabot> Not in scope: `traverse'
07:19:04 <acowley> Which is a good slogan for Haskell, come to think of it. Agda will user-friendly you until it hurts, Haskell stops just short of that.
07:19:04 <ocharles> :t Data.Traversable.traverse
07:19:05 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:19:22 <zong_sharo> i'm working on parser for a binary stream where sub-octet fields are common
07:19:32 <acowley> ocharles: why not just use the maybe eliminator?
07:19:47 <zong_sharo> is thre anything on hacakge for such stuff?
07:20:15 <Phyx-> cheater__: I'm not really sure that that's one of the things you'd get from getInfo. Although I haven't tried to grab comments yet
07:20:18 <zong_sharo> i mean, literally, there is sequences of 4 bit length data in there
07:20:20 <ricree> byorgey,: What I'm trying to get at is a function that looks like "(Ptr DrawContext -> cType1 -> ... -> cTypeN -> IO ()) -> haskellType1 -> ... -> haskellTypeN -> IO (Ptr DrawContext).
07:20:21 <zong_sharo> and 7 bit too
07:20:33 <cheater__> Phyx-, i'm looking
07:20:35 <willem> Would 'newtype Display    = Display    (Ptr Display)' be equivalent to 'data Display2 = Display2; type Display = Ptr Display2'?
07:20:36 <ocharles> acowley: because "traverse getByKey (editionFormat . copoint $ edition)" feels quite clean to me
07:20:41 <ricree> I can get it to work with just numeric types, but I'd like to get it with strings as well
07:20:41 <plat0> ocharles: do you want to use sequence to flip the two functors?
07:20:57 <cheater__> Phyx-, do you think it would be good if ghc was pluggable in that area?
07:21:00 <ocharles> um, I don't think know? :)
07:21:14 <cheater__> i mean, there are several fairly good patches for ghci floating around already
07:21:26 <cheater__> one that gives you :info about modules for example, i find that's nice
07:21:51 <acowley> zong_sharo: what we need is an Erlang-like bitfield syntax done in TH, but I don't think one exists
07:22:00 <ion> > runState (traverse (\a -> modify (++ "bar") *> return (a+1)) Nothing) "foo"
07:22:01 <lambdabot>   Not in scope: `traverse'
07:22:16 <ion> > runState (Data.Traversable.traverse (\a -> modify (++ "bar") *> return (a+1)) Nothing) "foo"
07:22:18 <lambdabot>   (Nothing,"foo")
07:22:21 <Phyx-> cheater__: Maybe, I don't usually extend ghci, but it could be useful
07:22:23 <ion> > runState (Data.Traversable.traverse (\a -> modify (++ "bar") *> return (a+1)) (Just 5)) "foo"
07:22:24 <lambdabot>   (Just 6,"foobar")
07:23:12 <ion> Just pointing out that the side effect doesn’t happen if the ‘Maybe a’ is Nothing. It’s probably what you want, just making sure.
07:23:12 <Phyx-> cheater__: i read that 7.2 supports plugins now for certain compile phases
07:23:26 <acowley> zong_sharo: well, http://hackage.haskell.org/packages/archive/BitSyntax/0.3.2/doc/html/Data-BitSyntax.html claims to be like Erlang's bit syntax, actually. I've not used it.
07:24:18 <ocharles> ion: yea, that's what I want
07:24:20 <cheater__> Phyx-, but your code for intellisense is a ghci extension, right?
07:24:30 <cheater__> ghc rather
07:24:44 <cheater__> but like, really, it's ghci because you're using things that are made for ghci only
07:24:58 <cheater__> Phyx-, or am i wrong here
07:26:12 <Phyx-> cheater__: I'm guessing it was originally made for ghci, but it's just exposed through the usual GHC api. I don't enter ghci code with my calls (yet) because i don't have an InteractiveContext
07:26:13 <dgpratt> Phyx-: I've been meaning to ask you if you were able to get anywhere with that VS project you were working on?
07:26:44 <cheater__> Phyx-, why don't you have one?
07:26:48 <Phyx-> dgpratt: I was side tracked for a while, I've only recently stated up again
07:27:11 <Phyx-> cheater__: don't need one. I can get almost everything from the ASTs and normal API calls.
07:27:33 <ricree> byorgey:  I could, perhaps, take the "-> IO ()" out of intargs and explicitly add it to the signatuure for the doDrawOp function, but I'm not sure what the stop condition would be.
07:28:11 <willem> Anyone has experience with this style for FFI bindings? newtype EnvHandle = EnvHandle (Ptr EnvHandle) What are the implications?
07:28:19 <dgpratt> Phyx-: ok, I was worried that you decided the project was impractical
07:29:41 <erus`> will we ever have strong ai?
07:29:43 <Phyx-> dgpratt: no, it wasn't that. I had my thesis to finish, and once that was done I had to stabalize the interface for hs2lib, since i kept changing the code generator output, fix bugs and add support for a few things
07:30:04 <dgpratt> Phyx-: ah
07:30:12 <ion> Will we ever have strong i?
07:30:19 <Phyx-> dgpratt: and most recently finding memory leaks and performance fixes
07:30:30 <erus`> i have strong i
07:30:56 <Phyx-> dgpratt: the biggest hurdles were bugs in visual studio (now most are fixed if not all), and figuring out how to support Cabal
07:32:00 <mistertim> HI all, just wondering, is there some typeclass or general concept that generalises Arrows from 2-tuples to lists / tuples of arbitrary length? I'm thinking of the way in which the liftA2 combinator can be used to apply two computations to a single initial value, then combine their results, but generalised to a list of n computations.
07:32:09 <dgpratt> Phyx-: bugs fixed since SP1?
07:32:40 <dgpratt> Phyx-: I mean: fixed by SP1?
07:33:14 * hackagebot bindings-parport 0.0.3 - parport bindings  http://hackage.haskell.org/package/bindings-parport-0.0.3 (SivaramGowkanapalli)
07:33:16 * hackagebot bindings-ppdev 0.0.3 - PPDev bindings  http://hackage.haskell.org/package/bindings-ppdev-0.0.3 (SivaramGowkanapalli)
07:33:18 <Cale> mistertim: I haven't seen such a class, but if you find a particularly elegant solution to that problem, I'd be happy to hear about it.
07:33:52 <ski> mistertim : `liftA2' is not related to arrows, it's related to applicative functors
07:33:53 <ksf> john millikin around?
07:33:58 <mistertim> Cale: yep, it's tricky - I've been scratching my head trying to fine a nicely general way of doing this for a while. Arrows come very close
07:34:03 <ksf> or someone else who has some dbus experience?
07:34:07 <acowley> mistertim: applicatives get towards this quite nicely
07:34:12 <Cale> mistertim: One thing that we have done is defined a class ArrowPair which defines generalisations of fst, snd, swap, and left/right associators
07:34:17 <Cale> But it does so for pairs
07:34:18 <ksf> *especially* how to best relate it to static typing.
07:34:18 <mistertim> ski: aah, interesting -  I was thinking about Applicatives
07:34:41 <Phyx-> dgpratt: fixed by SP1, the original release also lacked a few things, most of what i've asked for was put in though
07:34:42 <acowley> Foo <$> bar <*> baz <*> quux <*> mistertim
07:35:00 <ski> mistertim : .. what acowley said :)
07:35:10 <dgpratt> Phyx-: nice
07:35:11 <acowley> ski: I have a question for you, sir!
07:35:13 <darrint> @hoogle Integer -> Char
07:35:14 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
07:35:14 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:35:14 <lambdabot> Prelude show :: Show a => a -> String
07:35:15 <owst> Is it possible to add profiling cost-centres to functions in let bindings?
07:35:17 <mistertim> acowley: ski: aah, very nice
07:35:22 <mistertim> thanks!
07:35:27 <hpaste> mekeor pasted “layout concerning (++)” at http://hpaste.org/50179
07:35:36 * ski interrogates acowley about the nature of this question
07:35:48 <mekeor> what do you think about my paste? http://hpaste.org/50179
07:35:56 <ksf> I have, basically, three alternatives: make a method return a) a map of string to variant b) a struct, that is, a tuple (with dbus-core not supporting giving members name in introspection) or c) make more than one method.
07:35:59 <mekeor> it's (again) a layout-issue :/
07:36:06 <Cale> mistertim: ArrowPair instances look a lot like braided monoidal categories built in some funny way from Haskell types
07:36:14 <darrint> > fromInteger 3::Char
07:36:14 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:36:15 <lambdabot>    arising from a use of `GHC....
07:36:27 <ion> > toEnum 3 :: Char
07:36:28 <lambdabot>   '\ETX'
07:36:36 <darrint> thx
07:36:37 <acowley> ski: I was thinking about our discussion about cata and fold. You raised the example of an Expr var type that had some Int constants (I think), and pointed out that writing instances that Foldable would use make getting at these Ints hard even though you are writing a per-constructor case. But an Algebra has the same limitation!
07:36:38 <ski> mekeor : i usually use the middle one, ymmv
07:36:51 <mekeor> ymmv?
07:36:58 <ion> @google ymmv
07:36:59 <ski> your mileage may vary
07:36:59 <lambdabot> http://www.urbandictionary.com/define.php?term=YMMV
07:36:59 <lambdabot> Title: Urban Dictionary: YMMV
07:37:04 <ksf> hmmm. d) re-work HList now that we have proper equality contexts
07:37:44 <acowley> ski: because if we have Expr var -> var, then the Ints are again somewhat tricky to work with
07:38:07 <Cale> mekeor: All of those look acceptable to me, though I prefer the ++ at the start of line to being at the end. There are cases where putting an operator at the end of a line is happier though (particularly $ before a long block)
07:38:17 <ski> acowley : an `Algebra' being edwardk's `type Algebra f a = f a -> a', here ?
07:38:18 * hackagebot bindings-parport 0.0.4 - parport bindings  http://hackage.haskell.org/package/bindings-parport-0.0.4 (SivaramGowkanapalli)
07:38:19 <acowley> ski: so it seems one is back to the cata expressing a traversal order over the a's
07:38:20 * hackagebot HaXml 1.22.4 - Utilities for manipulating XML documents  http://hackage.haskell.org/package/HaXml-1.22.4 (MalcolmWallace)
07:38:21 <acowley> ski: yes
07:38:41 <acowley> ski: edwardk is my mathematical reference
07:38:49 <Cale> But yeah, I think I like #3 best
07:40:16 <zong_sharo> acowley: PackedBits can decode only octets, will do the job for 4 bit values, but no good for 7bit
07:40:37 <rtharper> omg this "deprecation" is a massive pain
07:40:45 <joseanpg> rwbarton, quicksilver , Cale what do you think about http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/SeqMagic ?
07:40:56 <acowley> zong_sharo: I think BitSyntax can handle it as PackedBits [7,1]
07:41:08 <acowley> zong_sharo: but the limitation is that the entire message must fit into a whole number of bytes
07:41:12 <mistertim> Cale: interesting, I'm not sufficiently up on cat. theory to fully appreciate that, but it sounds very close to what I'm trying to achieve (given that 'braided' implies a commutativity constraint, which is about the limit of my knowledge of it)
07:41:29 <mistertim> Cale: is any of your work on this online anywhere?
07:41:41 <byorgey> rtharper: what are you trying to build? and why are you so eager to ugrade to ghc 7.2?
07:42:03 <acowley> zong_sharo: it's hard to see how a protocol could give you just 7 bits and stop
07:42:06 <ski> acowley : assume we want to collect all the `Ints' in a list, then we can do basically `cata (\x -> case x of Var _ -> []; Int i -> [i]; Add is0 is1 -> is0 ++ is1)'
07:42:08 <rtharper> byorgey: a bunch of University of Utrecht tools,
07:42:11 <zong_sharo> acowley: http://www.dreamfabric.com/sms/hello.html -- i can hardly imagine how can i use PackedBits for this
07:42:30 <rtharper> byorgey: wasn't too eager, just thought it would be a "simple" way to solve the ld errors that were drive me nuts in Lion
07:42:32 <rtharper> my bad for thinking so ;)
07:42:35 <rwbarton> joseanpg: you should be aware that the 'case' used there is not the same as Haskell's case
07:42:50 <hpaste> ricree annotated “build error” with “build error (annotation) (annotation)” at http://hpaste.org/50174#a50181
07:43:02 <ski> Cale : whence `ArrowPair' ?
07:43:12 <acowley> ski: you had a data Expr var = ..., and my point is that the first argument to your cata there is no longer f a -> a
07:43:14 <Phyx-> crap.. found a bug
07:43:29 <Cale> ski: In IPwn.FRP, which is a library we haven't released (yet)
07:43:35 <mekeor> ski: *which* 'middle' one?
07:43:55 <rtharper> byorgey: I suppose the changse have to be made sometime ;)
07:43:55 <copumpkin> :O
07:44:13 <ski> acowley : the given formulation of `cata' relies on you having done `type Expr var = Mu (ExprF var); data ExprF var expr = Var var | Int Int | Add expr expr'
07:44:26 <Cale> ski: We might actually get at least that into the standard Arrow library, since the translation of Arrow syntax you can do for ArrowPair instances is better than the translation you can do for Arrow.
07:44:32 <byorgey> rtharper: yes, I suppose so =)
07:44:36 <acowley> zong_sharo: If you really are dealing the output of some weird process that's never heard of bytes, then I think I would drop down to using [Bool] or something :/
07:44:59 <rtharper> byorgey: do you know why they took such a hard line at this point?
07:45:09 <byorgey> rtharper: why who took a hard line?
07:45:25 <joseanpg> thanks rwbarton
07:45:25 <rtharper> byorgey: the GHC authors, in making base/haskell98 incompatible
07:45:38 <ski> acowley : of course, you can always change the representation to `data Expr var = Var var | Int Int | Add (Expr var) (Expr var)', if you change the `(ExprF var r -> r) -> ' in `cata's type to `(var -> r) -> (Int -> r) -> (r -> r -> r) ->'
07:46:05 <ski> mekeor : why, the one in the middle, naturally :)
07:46:13 <cheater__> rtharper, sorry, incompatible with what?
07:46:18 <byorgey> rtharper: it's not really a question of taking a hard line.  Just that there is a new language standard (Haskell 2010) which is slightly incompatible with the old standard (Haskell 98)
07:46:25 <zong_sharo> acowley: it's not a weird proess, it's a sms
07:46:25 <ski> mekeor : you know the one in the absolute middle
07:46:52 <mekeor> ski: oh, i see. you mean the third one (from five); all right. yea, actually, i prefer that one, too :)
07:46:55 <ski> Cale : how does this `ArrowPair' look like / work ?
07:47:17 <byorgey> cheater__: the versions of base and haskell98 that come with ghc 7.2 are incompatible, since they both export (different versions of) the Prelude
07:47:34 <cheater__> byorgey, oh, i wonder why too
07:47:52 <Cale> class (Arrow (~>)) => ArrowPair (~>) where fst :: (a,b) ~> a; snd ...; swap ...; lassoc :: (a,(b,c)) ~> ((a,b),c); rassoc ...
07:47:56 <ski> mekeor : in case i'm using something longer than `++', and the name of the defined thing is short enough, that will "hit the ground", so then i'd usually add some spaces before (or after ?) the `='
07:47:57 <byorgey> if you want Haskell 2010 you use base.  if you want Haskell 98 you use haskell98 instead.
07:48:12 <byorgey> Idon't see what's so surprising about this.
07:48:39 <byorgey> the haskell98 package is provided as a means of backwards compatibility for packages coded to the old standard.
07:48:42 <mekeor> ski: like the last example?
07:48:50 <acowley> zong_sharo: I mean "weird" in that you don't really have bytes. In this case, you do have whole bytes, coming in.
07:48:58 <ski> Cale : no `(a ~> b0) -> (a ~> b1) -> (a ~> (b0,b1))' ?
07:49:16 <Cale> We already have that via Arrow, no?
07:49:38 <ion> :t (&&&)
07:49:39 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:49:43 <Cale> exactly
07:50:17 <rwbarton> also this page about seq is pretty scary, I mean I could abstract foldl' or one of these examples over seq and pass in seq as an argument, will these transformations still work?  seq is supposedly just a function
07:50:57 <Cale> This allows us to eliminate a lot of the uses of 'arr' in the translation of arrow syntax, which makes arrows capable of running a good deal more efficiently.
07:51:04 <hpaste> ski annotated “layout concerning (++)” with “long infix operator” at http://hpaste.org/50179#a50182
07:51:11 <DevHC_> let's test !
07:51:27 <ski> mekeor : note that this applies in this case because `mplus' is long and `x' is short
07:51:29 <DevHC_> > foldl' seq () [(), (), (), ()]
07:51:30 <lambdabot>   ()
07:51:32 <DevHC_> :]
07:51:46 <ski> Cale : oh, i missed the `Arrow' superclass
07:51:47 <Cale> (because 'arr' is opaque and completely impossible to analyse)
07:52:07 <DevHC_> > foldl' seq () [1, 2.2, 3]
07:52:08 <lambdabot>   No instance for (GHC.Real.Fractional ())
07:52:08 <lambdabot>    arising from the literal `2.2' ...
07:52:11 <ski> yeah, removing dependencies on `arr' is good
07:52:23 * ion cringers at grave accent pseudoquotation.
07:52:23 <DevHC_> > foldl' seq 9 [1, 2.2, 3]
07:52:24 <lambdabot>   3.0
07:52:29 <Cale> We got a 2 or 3 times speedup in out code from that
07:52:30 <ion> −r
07:52:31 <DevHC_> > foldl' seq 9 [1, 2.2, 3 :: Int]
07:52:32 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
07:52:33 <lambdabot>    arising from the lit...
07:52:33 <Cale> our*
07:52:44 <mekeor> @hoogle seq
07:52:45 <lambdabot> Prelude seq :: a -> b -> b
07:52:45 <lambdabot> Data.Sequence data Seq a
07:52:45 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
07:52:53 <Cale> and we're not even taking full advantage of it yet
07:53:16 <mekeor> how can i make lambdabot say the implementation of a function?
07:53:28 <ion> @src (++)
07:53:28 <lambdabot> []     ++ ys = ys
07:53:29 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:53:29 <lambdabot> -- OR
07:53:29 <lambdabot> xs ++ ys = foldr (:) ys xs
07:53:32 <Cale> mekeor: @src has a library of hand-defined versions of things
07:53:40 <mekeor> @sec seq
07:53:40 <lambdabot> Source not found. My pet ferret can type better than you!
07:53:41 <ricree> If anyone has a sec, would you mind taking a look at this to see where I'm screwing up the types at? http://hpaste.org/50181
07:53:41 <Cale> mekeor: they're not the real definitions in many cases
07:53:48 <Cale> seq is a language primitive
07:53:55 <mekeor> oO
07:53:59 <mekeor> what does it do?
07:54:07 <mekeor> > seq 5 4
07:54:09 <lambdabot>   4
07:54:13 <acowley> ski: I guess my confusion is where you get the opportunity to return an Int, given the type of cata (I'm looking here for that, http://knol.google.com/k/catamorphisms#). More speicifically, I'm not sure which type constructor you'd want to apply to Int.
07:54:16 <ski> Cale : what about `class Arrow (~>) => ArrowProduct (~>) p where fst :: p a b ~> a; ...' ?
07:54:16 <Cale> seq undefined b = undefined, but seq x y = y otherwise
07:54:17 <mekeor> > seq 4 5
07:54:17 <lambdabot>   5
07:54:36 <mux> meaning that operationally, seq will reduce its first argument to WHNF
07:54:40 <DevHC_> seq a b = assert that a is not an error and return b
07:55:00 <Cale> mekeor: This ensures that in seq x y, the value x is evaluated before the result of evaluating y is made available to pattern match.
07:55:03 <rwbarton> it looks like Problem 3 on that page is the only one that breaks the denotational semantics of seq
07:55:06 <mux> > seq (undefined,undefined) 1
07:55:07 <lambdabot>   1
07:55:26 <ion> mekeor: Try this in ghci: “let a = [0..]”, “:p a”, “seq a 42”, “:p a”
07:55:33 <Cale> (note this is different from evaluating x before evaluating y -- the compiler can still choose to evaluate y first, and then x)
07:56:24 <ski> acowley : i'm not sure what you mean by "return an Int" and "which type constructor you'd want to apply to Int"
07:56:27 <Cale> seq x x is equivalent to x
07:56:31 <mekeor> what does ':p' do in ghci? (i can't find it with ":help"..)
07:56:46 <Cale> seq x (seq y x) is equivalent to seq y x
07:56:54 <ion>    :print [<name> ...]         prints a value without forcing its computation
07:57:04 <acowley> ski: cata :: Functor f => Algebra f a -> Mu f -> a
07:57:14 <ski> acowley : i assumed here `type Expr var = Mu (ExprF var)' (or `newtype' if you prefer), and then `data ExprF var expr = Var var | Int Int | Add expr expr'
07:57:15 <mekeor> ion: a's type has changed... O_O
07:57:16 <acowley> ski: so cata :: Functor f => (f a -> a) -> Mu f -> a
07:57:20 <Cale> which is equivalent to seq x (seq y x)
07:57:26 <ocharles> How do I debug something that uses  error  to throw errors? Mostly Data.Map's "find" which just has an extremely unhelpful "element not in the map" error
07:57:34 <ski> acowley : yeah, in my example `a' was `[Int]'
07:57:34 <Cale> er, seq y (seq x x), sorry
07:57:51 <rwbarton> oh and if I abstracted that third issue over seq and passed it in, that would certainly block the wrong optimization
07:58:01 <Cale> ocharles: You don't use find anymore
07:58:05 <acowley> ski: so who's f?
07:58:14 <ion> mekeor: I don’t think so. :-)
07:58:15 <ocharles> Cale, well I'm using (!), which uses find
07:58:16 <mekeor> ion: oops, no, not its type... i mean..
07:58:16 <Cale> ocharles: use findWithDefault or lookup
07:58:17 <ski> `f' is `ExprF var', of course :)
07:58:21 <ocharles> hrm
07:58:25 <ocharles> ok
07:58:27 <mekeor> ion: the output of ':p a', sry
07:58:28 <ski> so that `Mu f' becomes `Expr var'
07:58:51 <Cale> ocharles: Only use find or (!) if you're *certain* that the lookup can't fail
07:58:59 <rwbarton> oh they mention this at the end of the second example
07:59:02 <mekeor> ion: actually, i still didn't understand it :/
07:59:13 <ocharles> in this case an error is the right behavior if the lookup fails, it would be nice if it was just a bit more... useful
07:59:20 <acowley> ski: So then we have var = [Int] as a result of that application
07:59:22 <ski> acowley : so, the situation here is `cata :: (ExprF var [Int] -> [Int]) -> (Expr var -> [Int])'
07:59:22 <Axman6> ocharles: there's no easy way to making that error any more helpful without putting a much more annoying Show constraint on its type
07:59:39 <acowley> oops, no
07:59:42 <Cale> ocharles: You can write your own findWithDefault which calls error with a better message in the default case.
07:59:47 <ocharles> Maybe I should make use of the fact that I'm in MonadIO and use maybe and throw an error as default
07:59:49 <ocharles> ok, cool
07:59:56 <ocharles> or findWithDefault, yea
08:00:16 <ski> acowley : not at all
08:00:20 <DevHC_> btw ion, way to get ppl acquainted and in love with haskell :P
08:00:34 <ski> (but if we had, we could `fmap (const [])')
08:00:47 <mekeor> @src ($!)
08:00:48 <lambdabot> f $! x = x `seq` f x
08:01:03 <acowley> ski: I see, the Add [Int] [Int] case captures specifically the recursion we're interested in
08:01:27 <ski> i suppose that's one way to put it, yes
08:01:36 <Axman6> :|
08:01:41 <mekeor> O_O
08:01:46 <Axman6> bloody irccloud
08:01:47 <mekeor> what the hell happend?
08:01:57 <ski> someone pulled the plug
08:02:29 <Axman6> for something that's in the 'cloud', it sure isn't very reliable. i've seen this happened a few times
08:02:56 * mekeor is astonished
08:03:08 <acowley> clouds dissipate
08:03:20 <DevHC_> Axman6: clouds aren't very reliable, weather forcasts mispredict clouds all the time
08:03:20 <acowley> this is bioinspired telecommunications
08:03:47 <acowley> "Look, that cloud looks like #haskell! ... oh, well, it did a few moments ago."
08:03:57 <ski> this is just our overlords' way of telling us they're watching us
08:04:09 <ski> acowley : unrelated to this is `instance Monad Expr', which is also interesting
08:04:09 <DevHC_> the kell Has spoken !
08:05:43 <acowley> could someone mute the kell?
08:06:59 <mekeor> “when a seq expression is evaluated, it forces its first argument to be evaluated, then returns its second argument” -- oooh, i finally got it! =)
08:07:08 <mekeor> (source: http://book.realworldhaskell.org/read/functional-programming.html)
08:08:10 <ksf> am I missing some finer point of the syntax or are equality contexts for type/data families still not implemented?
08:08:15 <ski> mekeor : note that that doesn't make any guarantees about the order in which `a' and `b' are evaluated in `seq a b', though
08:09:45 <rwbarton> it's interesting that people use seq in functions like foldl' and it seems not to cause any problems
08:10:11 <rwbarton> even though the compiler would be totally justified in using as much space as foldl does
08:10:27 <DevHC_> > foldl' seq seq [seq, seq, seq, seq] seq seq seq 1
08:10:28 <lambdabot>   1
08:10:31 <mekeor> ski: but seq doesnt guarantee that 'b' is evaluated at all, does it? (in 'seq a b')
08:11:07 <ski> mekeor : `seq a b' is evalauted because someone wants the result, so `b' will have to be evaluated as well
08:11:09 <DevHC_> ROFL @ ghci: ":p seq"
08:11:30 <rwbarton> DevHC_: nice find
08:11:32 <DevHC_> Alternatively, this link failure might indicate a bug in GHCi.
08:11:32 <DevHC_> If you suspect the latter, please send a bug report to:
08:11:32 <DevHC_>   glasgow-haskell-bugs@haskell.org
08:11:39 <DevHC_> I SUSPECT A BUG IN HASKELL !
08:11:58 <EvanR7> @faq can haskell have bugs
08:11:58 <lambdabot> The answer is: Yes! Haskell can do that.
08:12:24 <EvanR7> omg what CANT it do
08:12:41 <mekeor> haha :D
08:13:07 <confab> I have a question about this: http://www.haskell.org/tutorial/functions.html#sect3.2.1 it says, "map (+) [1,2,3]" should return a list of functions.  I understand why it should, but I can't seem to make it do it in ghci.
08:13:11 <confab> what am I missing here?
08:13:21 <Botje> :t map (+) [1,2,3]
08:13:22 <lambdabot> forall a. (Num a) => [a -> a]
08:13:31 <EvanR7> confab: functions can be 'show'ed
08:13:35 <EvanR7> ... canNOT
08:13:46 <Botje> confab: by default, GHCi tries to show its result. functions are not instances of Show
08:13:48 <DevHC_> @faq can haskell show functions
08:13:48 <lambdabot> The answer is: Yes! Haskell can do that.
08:13:55 <confab> oh
08:13:56 <EvanR7> >_>
08:13:59 <Botje> > map (+) [1,2,3]
08:14:00 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:14:00 <lambdabot>    arising from a use of `...
08:14:04 <ski> @faq Can Haskell fail to have an answer to this question ?
08:14:04 <lambdabot> The answer is: Yes! Haskell can do that.
08:14:10 <Botje> yes, in fact haskell can do it.
08:14:17 <Botje> it's not hard to write a show instance for functions
08:14:23 <Botje> however, you cannot read them back in
08:14:25 <mekeor> @faq do you alwys answer like that?
08:14:25 <lambdabot> The answer is: Yes! Haskell can do that.
08:14:28 <DevHC_> ROFL
08:15:02 <DevHC_> Botje: u will die trying to write a show instance for functions
08:15:11 <EvanR7> @faq can haskell create something that haskell cant do
08:15:11 <lambdabot> The answer is: Yes! Haskell can do that.
08:15:30 <ski> confab : try `map ($ 100) (map (+) [1,2,3])' ?
08:15:34 <DevHC_> @faq can haskell troll EvanR7 ?
08:15:34 <lambdabot> The answer is: Yes! Haskell can do that.
08:16:09 <mekeor> when haskell can do everything, is it then able to make it not able to do sth? :D
08:16:19 <mekeor> s/when/if/
08:16:28 <EvanR7> is haskell god
08:16:30 <ski> mekeor : yeah, if it wanted to. the point is that it doesn't want to :)
08:16:57 <mekeor> https://secure.wikimedia.org/wikipedia/en/wiki/Omnipotence_paradox
08:17:20 <mekeor> "Can [an omnipotent being] create a stone so heavy that it cannot lift it?"
08:17:33 <EvanR7> can god microwave a burrito so hot not even he can eat it
08:17:52 <cheater__> does a god have a god
08:18:15 <ricree> Sorry to post this again so soon, but  can anyone take a look at http://hpaste.org/50181 and see if they can figure out why the type is off?  I've been trying to figure it out for a while now, but I'm stumped
08:18:30 <confab> ski: thanks
08:18:38 <Botje> ricree: can't open that url
08:18:46 <Botje> hpaste is down
08:18:46 <ski> EvanR7 : see <http://www.sfu.ca/~swartz/modal_fallacy.htm#omnipotence> :)
08:18:48 <mistertim> ricree: sorry, hapaste is down for me - Nginx 'bad gateway' error
08:19:09 <ski> preflex: xseen chrisdone
08:19:09 <preflex>  chrisdone was last seen on freenode/#haskell 7 hours, 16 minutes and 5 seconds ago, saying: hpaste is using resident 252m of mem, 2566M virt
08:19:20 <ski> (chrisdone is down too)
08:19:38 <Botje> that's a lot of ram for a pasting website :(
08:20:35 <ricree> why so it is.  Here's one on pastebin.  http://pastebin.com/3NkA6Sz6
08:20:38 <Cale> From what I recall, it keeps all the pastes in memory
08:20:56 <rostayob> Suggestions on a nice 2D graphics library in haskell?
08:21:18 <rostayob> Are the SDL bindings low level bindings to the C lib?
08:21:25 <EvanR7> ski: haha
08:21:46 <EvanR7> rostayob: yes. try graphics combinators?
08:22:00 <Botje> Cale: hopefully not as [Char] ?
08:22:15 <rostayob> EvanR7: what's that?#
08:22:24 <Cale> ricree: op is supposed to take a parameter of type intArgs, but you don't supply one
08:22:29 <EvanR7> rostayob: a 2d graphics lib
08:22:32 <rostayob> I mean I can imagine what it is - vaguely - but have you got a link?
08:22:46 <Cale> er...
08:22:49 <EvanR7> rostayob: yes
08:23:02 <rostayob> EvanR7: http://hackage.haskell.org/package/graphics-drawingcombinators ?
08:23:11 <EvanR7> yes
08:23:17 <EvanR7> bit.ly/mVvwBe
08:23:27 <cheater__> what is the simplest function that does abcdef -> fabcde?
08:23:30 <cheater__> just rotate once
08:23:31 <Cale> oh!
08:23:31 <rostayob> cool, my aim is exactly that, I don't want to write C-like code to go graphics
08:23:49 <mauke> :t liftA2 (:) last init
08:23:50 <lambdabot> forall a. [a] -> [a]
08:24:03 <ricree> Cale:  But doDrawOp should be expecting (Ptr DrawContext -> intArgs -> IO ()) as its first argument.
08:24:04 <mauke> > liftA2 (:) last init "cheater"
08:24:05 <lambdabot>   "rcheate"
08:24:24 <ricree> so an intArg shouldn't need to be provided
08:24:46 <rostayob> @pl \s -> last s : init s
08:24:47 <lambdabot> liftM2 (:) last init
08:24:48 <ski> EvanR7 : yeah, many of the explanations there are fun :)
08:24:50 <rostayob> right.
08:25:13 <Cale> If that first parameter is op, then when you use op to get an IO action, you need to apply it to a Ptr DrawContext, and a value of type intArgs
08:25:22 <ricree> Cale:  By contrast, http://pastebin.com/Q70J7re1 works
08:25:24 <mauke> The paste Q70J7re1 has been copied to http://www.ideone.com/GKxRa
08:25:40 <Axman6> ideone?
08:26:11 <ricree> Cale:  ah, I think I kinda get what you're saying
08:26:19 <EvanR7> rostayob: im reading it, but i dont really understand the concept of Draw a
08:26:44 <yitz> > (:) <$> last <*> init $ "cheater"
08:26:45 <lambdabot>   "rcheate"
08:26:46 <EvanR7> rostayob: guess its supposed to be used as a Functor
08:27:35 <Cale> ricree: In your second instance, intArgs is a function type
08:27:55 <Cale> ricree: and you seem to be supplying realToFrac a as the intArgs parameter to op
08:28:19 <Cale> (It's slightly confusing because you have two variables named intArgs, one in the class, and a different one in the instance
08:28:20 <Cale> )
08:28:36 <Cale> intArgs = a -> intArgs'
08:29:15 <rostayob> EvanR7: you mean an Image a
08:29:22 <EvanR7> Draw a
08:29:32 * mekeor CRIES "HPASTE.ORG IS DOWN!!"
08:29:45 <rostayob> EvanR7: I see no Draw type :P
08:29:49 <EvanR7> rostayob: oops i was looking at an old version
08:29:53 <Cale> ricree: anyway, that means that realToFrac a had better be a function, which seems suspicious unless you have some extra instances lying around
08:30:15 <ricree> Cale:  what I'm trying to do is get it so that I can accept Strings and have it convert them to CStrings to be passed to Op.  It's easy enough if I limit to numeric types, but the functions for creating new CStrings are all IO.  Since it all winds up as an IO, it seems like there should be a way, but I'm not sure how
08:30:18 <Axman6> mekeor: this ideone.com paste site looks pretty cool, maybe try that?
08:30:33 <ricree> CStrings among other C types, that is
08:30:48 <merijn> Axman6: Yeah, ideone.com is reasonably non-sucky
08:31:08 <Cale> Isn't there withCString?
08:31:28 <Cale> Or is that the other way around?
08:31:31 <merijn> Although if hpaste doesn't work I prefer something completely simple like dpaste.com which does nothing except syntax highlighting
08:31:32 <mekeor> Axman6: do you know a pastebin supporting STDIN, too?
08:31:49 <mekeor> Axman6: i mean, that you can write your stdin there, too
08:31:51 <Cale> withCString :: String -> (CString -> IO a) -> IO a
08:31:59 <Cale> ^^ why not use that?
08:32:02 <Axman6> no, though couldn't you maybe write to stdin inside your main function?
08:32:32 <mekeor> Axman6: well, the site you mentioned even supports that, as i spotted right now; -- doesnt it? -- it does.
08:32:39 <ricree> Cale:  Wouldn't that just wind up with the same problem I have now where op doesn't wind up as an IO until I apply all the arguments?
08:32:46 <rage__> can somebody help me to get started with parsec? I wanted to try out the ExpressionParser example but it doesn't compile due to the use of parens. whats wrong? http://codepad.org/mM7EX2Ve
08:32:58 <mekeor> Axman6: thx
08:33:08 <Cale> ricree: I'm not sure I understand the meaning of the class that you're defining
08:33:11 <mauke> rage__: error message?
08:33:33 <rage__> mauke: http://codepad.org/ilwve7vg
08:34:06 <ricree> Cale:  So I have a  bunch of foreign functions that have a variable number of arguments.  But they're all of the type (Ptr DrawContext) -> someCType1 -> ... -> someCTypeN -> IO
08:34:29 <thoughtpolice> *gasp* it happened, dph is on hackage!
08:34:47 <Cale> ricree: okay...
08:35:03 <mauke> rage__: ok, and what does that have to do with use of parens?
08:35:08 <DevHC> what does the standard say about the semantics about bottom programs?
08:35:11 <ski> @type System.Process.runInteractiveProcess
08:35:11 <mekeor> any ideas why http://ideone.com/XI413 doesnt work? (i am a monad-noob =))
08:35:12 <lambdabot> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (GHC.IO.Handle.Types.Handle, GHC.IO.Handle.Types.Handle, GHC.IO.Handle.Types.Handle, System.Process.Internals.ProcessHandle)
08:35:32 <ricree> Cale:  I want a function that works on all of those functions, so I can have something like "externalFunction = doDrawOp internalFunction"
08:35:40 <ski> mekeor : `if' needs an `else
08:35:40 <mauke> mekeor: unrelated to monads. you're missing the 'else' in if-then-else
08:35:41 <ski> '
08:35:51 <Botje> mekeor: missing else
08:35:59 <ski> mekeor : maybe you wanted `unless' ?
08:36:02 <ski> @type unless
08:36:02 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:36:06 <mauke> @type when
08:36:07 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:36:09 <Cale> ricree: er... I'm not sure I'd bother attempting that. It might be possible.
08:36:19 <mauke> rage__: I'm not sure how Parsec is supposed to work, but reservedOp is missing an argument
08:36:23 <mekeor> when === unless ?
08:36:26 <ski> no
08:36:38 <ski>   unless = when . not
08:36:39 <Axman6> when = unless . not :P
08:36:40 <mauke> rage__: that is, it's a record selector and you don't have a record here
08:36:41 <Axman6> ha
08:36:46 * Axman6 high fives ski 
08:36:51 * ski grins
08:37:03 <rage__> mauke: I do neither. I was just trying to pick it up and sadly the examples don't work^^
08:37:15 <mauke> rage__: link?
08:37:16 <rage__> mauke: what does that mean?
08:37:33 <ski> mekeor : either `unless (length foo == 2) $ exitFailure', or `when (length foo /= 2) $ exitFailure'
08:37:43 <rage__> mauke: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html you have to scroll down to expressiosn
08:37:44 <mekeor> ski: thx
08:37:46 <DevHC> Cale: poke
08:37:52 <Cale> DevHC: hi
08:37:57 <DevHC> uhm
08:37:58 <DevHC> what does the standard say about the semantics about bottom programs?
08:38:05 <ski> i suppose the `$' is totally unneeded here
08:38:12 <mekeor> OK
08:38:33 <Axman6> hmm, can you write to stdin from within a program?
08:38:37 <ricree> Cale:  Maybe.  But I got it working with just numeric types, and I really want to see if it can work for strings as well
08:38:46 <ski> Axman6 : you can use `System.Process.runInteractiveProcess' e.g.
08:38:53 <Cale> DevHC: not much. Bottom represents nontermination (which includes spinning forever, and emitting an error which kills the program immediately)
08:38:56 <mauke> rage__: you're missing the rest of that file
08:39:03 <mauke> rage__: specifically, the '...' part
08:39:29 <Cale> ricree: Okay, I think if you want it to have a chance of working, the IO () has to be part of the type parameter to the class
08:39:34 <acowley> zong_sharo: I took a look at the SMS encoding, and I think it's actually more straightforward to write it as a ByteString fold then to try to write patterns.
08:39:45 <monochrom> "reservedOp= P.reservedOp lexer"
08:39:53 <yitz> DevHC: the result of a bottom program is intentionally undefined, but the standard recommends that some kind of informative message be shown to the user when possible.
08:39:59 <ski> (also including spinning just long enough that you think it's spinning forever and kills it just the moment before it would have errored out)
08:40:00 <Axman6> ski: i meant of the current program, so that you can provide input to the current program: main = do {hPutStr stdin "foo"; str <- getContents; putStrLn str } outputs foo
08:40:07 <Cale> ricree: You can't build it into the type of the method, because then it becomes possible to say how many parameters the function has without saying which instance you're looking at.
08:40:26 <Cale> (since IO () obviously is not a function type)
08:41:00 <ski> Axman6 : i'm not sure, but i would assume no
08:41:03 <rage__> I don't quite get it anyway. Is there any decent tutorial on Parsec for beginners?
08:41:23 <ski> Axman6 : maybe there's some `withStdin' operation somewhere ..
08:41:31 <Cale> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html -- it's aging a bit, the modules have moved around a bit
08:41:32 <merijn> rage__: Did you read the Real World Haskell chapter on parsec?
08:41:38 <Cale> but that tutorial is good
08:41:38 <mekeor> @hoogle when
08:41:39 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
08:41:49 <mauke> rage__: are you going to actually read the text?
08:41:57 <ski> @index when
08:41:57 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
08:42:00 <Kaidelong> is there a way to use type level naturals to write a function that takes a binary function and returns an n-ary function?
08:42:19 <merijn> Kaidelong: I hope so! :p
08:42:30 <Axman6> Kaidelong: find out!
08:42:33 <Cale> Probably
08:42:43 <rage__> merijn: I'll have a look, thanks
08:42:47 <ski> the problem would be taking the tuple apart, i think
08:42:55 <monochrom> rage__, the point is there is a line of code "reservedOp= P.reservedOp lexer" you're missing, and many more lines of code
08:44:04 <monochrom> there is no such thing as "decent tutorial" if by that you mean a fractal property: every fragment of the tutorial taken out of context is still working code
08:44:22 <Axman6> Kaidelong: i assume it'd have to be a function of type a -> a -> a?
08:44:33 <Kaidelong> yeah
08:46:37 <rage__> monochrom: oh that explains quite a bit. I guess I didn't pay enough attention
08:47:43 <applicative> does the real world haskell discussion presuppose parsec-3?
08:49:38 <monochrom> no, it still "import Text.ParserCombinators.Parsec"
08:50:52 <EvanR7> rostayob: oh, this also makes it sane, i think, to associate regions of the screen with values for the purposes of mouse clicking
08:51:20 <rostayob> EvanR7: Yeah I'm checking it out
08:51:33 <rostayob> my goal is to make little games/experiment
08:51:40 <EvanR7> thats what the 'a' is for in Image a
08:51:51 <rostayob> but afaik there is no "game" library, and anyway I'm not sure I'd want to use one
08:52:19 <rostayob> EvanR7: yeah the a serves mainly to make it a monoid
08:52:20 <EvanR7> game library is a basically meaningless term, it could mean nothing but graphics to something like quake engine
08:52:37 <rostayob> EvanR7: well it could mean graphics+sound+input+physics....
08:52:42 <Entroacceptor> I'm trying to install the ghc7 binary, and I'm getting ghc-cabal: epollCreate: unsupported operation (Function not implemented)
08:52:43 <EvanR7> rostayob: it could
08:52:51 <rostayob> that's what it means to me anyway
08:53:27 <mwc> Oh no, hpaste.org is down?
08:53:36 <EvanR7> rostayob: the a is not necessary to make it a monoid
08:53:45 <EvanR7> arrays of color could be a monoid
08:54:02 <rostayob> EvanR7: Monoid m => Monoid (Image m)
08:54:02 <EvanR7> the 'a' here is to associate additional data with 'pixels' (points in space)
08:54:03 <quicksilver> probably its because they like the simple syntax you get for do blocks
08:54:11 <arcatan> does GHC 7.2.1 work with the compilers that come with Xcode 4?
08:54:23 <quicksilver> oh, not then.
08:54:25 <EvanR7> quicksilver: its not a monad
08:54:30 <quicksilver> good :)
08:54:38 <EvanR7> yeah, bizarre
08:54:57 <EvanR7> additional data beyond the color
08:56:00 <rostayob> EvanR7: what do you mean with "the a is not necessary to make it a monoid"?
08:56:49 <EvanR7> rostayob: Bool has a monoid instance with ||
08:56:58 <rostayob> EvanR7: that's a type they defined, Any
08:57:01 <EvanR7> called Any in this lib
08:57:10 <EvanR7> theres no type variable in that case
08:57:14 <rostayob> yeah, Image Bool wouldn't be a monoid
08:57:17 <EvanR7> in general you dont need type variable for monoids
08:57:31 <EvanR7> Image m where m is a monoid is a monoid in this case
08:57:39 <rostayob> yeah that's what I meant
08:57:45 <EvanR7> if Image were just arrays of color, then it could also be a monoid
08:58:16 <Entroacceptor> is kernel 2.6.26 too old?
08:58:25 <EvanR7> no
08:58:31 <Eduard_Munteanu> Kinda. What for?
08:58:34 <Kaidelong> EvanR7: I think Conal's continuous images are monoids
08:58:37 <Kaidelong> in more than one way
08:58:39 <rostayob> I don't get you, my whole point is that Image is a monoid if the inner type is a Monoid.
08:58:50 <rostayob> anyway, I'll try it out ehe
08:59:04 <EvanR7> Image isnt a monoid
08:59:27 <Kaidelong> hmm, that a type from a particular library then?
08:59:28 <rostayob> well Image isn't, Image [a] is for example
08:59:31 <EvanR7> Kaidelong: they 'continuous' in this lib too
08:59:31 <Eduard_Munteanu> At least use one of the long-term stable series if you don't plan on upgrading the minor version.
08:59:43 <Eduard_Munteanu> erm, the third number
08:59:47 <EvanR7> rostayob: Image could be if Image were just R2 -> Color
09:00:29 <EvanR7> the m in Image m is the additional data R2 -> (Color,m)
09:00:36 <rostayob> yes
09:01:17 <rostayob> I still don't get what you mean with "the a is not necessary to make it a monoid", but it's not important :P
09:01:23 <EvanR7> Color is a monoid with alpha blending
09:01:32 <EvanR7> so R2 -> Color could be a monoid in the same exact way
09:01:39 <EvanR7> as R2 -> (Color,m)
09:02:08 <rostayob> yes, but the type as it is needs m to be a Monoid for Image m to be a monoid :P
09:02:23 <rostayob> if it didn't have the additional information it would be a monoid already I agree :P
09:02:26 <EvanR7> i didnt disagree with that, what i said was m isnt necessary at all
09:03:05 <EvanR7> hmm is () a monoid?
09:03:24 <rostayob> > () `mappend` ()
09:03:25 <lambdabot>   ()
09:03:28 <rostayob> yes.
09:03:34 <rostayob> apparently :P
09:03:43 <EvanR7> so yeah Image () if you just want to draw
09:03:46 <rostayob> yeah
09:04:00 <edwardk> is there a known issue with haddock and unboxed tuples in apis?
09:04:53 <rostayob> actually, no
09:05:19 <rostayob> you need Any, so that it knows what to draw in the first place
09:05:30 <rostayob> otherwise it just draws the entire screen, I guess?
09:05:32 <rostayob> boh
09:05:33 <EvanR7> rostayob: ... no
09:06:18 <rostayob> EvanR7: well what they do for shapes is that they set the points in the circle to True and the others to False
09:06:20 <EvanR7> rostayob: for example lines and points are False everywhere
09:06:37 <EvanR7> yes thats a default behavior for overlap testing
09:06:45 <EvanR7> like click on something or 'not'
09:07:04 <mm_freak_> storable vectors (Data.Vector.Storable) are strict and sort of unboxed, right?
09:07:24 <roconnor> copumpkin, edwardk: Good afternoon o/
09:07:28 <rostayob> EvanR7: mhm right, so does it just draw the entire screen each time?
09:07:34 <copumpkin> roconnor: yo!
09:07:37 <EvanR7> rostayob: doubt it
09:07:38 <rostayob> when you draw a shape
09:07:47 <EvanR7> rostayob: if you draw a line, it will only draw the line
09:08:12 <rostayob> EvanR7: yeah but how does it know where the line is?
09:08:14 <EvanR7> but semantically i guess you think of it as mapping the entire screen to the image function
09:08:15 * hackagebot hssqlppp 0.3.0 - SQL parser and type checker  http://hackage.haskell.org/package/hssqlppp-0.3.0 (JakeWheat)
09:08:32 <EvanR7> rostayob: the data is R2 -> (Color,
09:08:54 <rostayob> EvanR7: yeah but I'd guess that data covers the entire screen space
09:09:09 <EvanR7> the implementation wont map each pixel with the function though
09:09:24 <rostayob> mhm ok
09:09:29 <EvanR7> the function is semantics only
09:09:37 <EvanR7> it uses opengl as a backend
09:10:15 <rostayob> ok, I don't have clear ideas on denotational semantics :P
09:10:42 <EvanR7> imagine a line being transparent everywhere in the plane except.. on the line ;)
09:11:16 <rostayob> yeah but I read that as "function from point to colour"
09:11:23 <EvanR7> right
09:11:33 <EvanR7> true false is auxilliary info
09:11:39 <EvanR7> in the case of line, false everywhere
09:11:48 <rostayob> yep yep makes sense
09:11:51 <EvanR7> the aux info is independent of the color
09:12:14 <EvanR7> you can make an image with a line going 45 and a line of falses going -45 if you wanted ;)
09:12:20 <EvanR7> everywhere else true
09:17:49 <edwardk> scumbag haddock, complains about problem in file. problem actually in other file
09:18:04 <EvanR7> rostayob: and it looks like the only way to anything but Any is unsafeOpenGLImage
09:18:11 <EvanR7> to use*
09:18:19 * hackagebot trifecta 0.16.1 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.16.1 (EdwardKmett)
09:18:21 <edwardk> that'll teach me to actually try to write docs )
09:19:22 <isBEKaml> edwardk: feels weird to see "scumbag x" usage on #haskell. reddit? :)
09:19:37 <edwardk> =) yeah
09:19:40 <isBEKaml> edwardk: I mean, reddit spawned that usage, right?
09:19:59 <ocharles> If I have something a -> b -> c -> ... etc I can use applicative to obtain each parameter from some monad (e.g IO). Is it possible to do this with something that has the type (a, b, c, d) -> e -> f ..?
09:20:17 <ocharles> that is, find values for a, b, c, d, e, f using applicative
09:20:29 <edwardk> http://knowyourmeme.com/memes/scumbag-steve
09:20:44 <ocharles> Right now I'm just binding each action to a variable, and then finally assembling everything
09:20:48 <isBEKaml> edwardk: ah, yes. =)
09:20:55 <DevHC> Cale, yitz: is a bottom program strictly either one of a error message or an infinite loop; or is a bottom program undefined?
09:21:27 <Cale> DevHC: It won't hurt to assume that. It can't be anything else in the current implementation.
09:21:33 <EvanR7> > _|_
09:21:34 <lambdabot>   <no location info>: parse error on input `|'
09:21:46 <ski> ocharles : `foo <$> ((,,,) <$> ia <*> ib <*> ic <*> id) <*> ie <*> if' ?
09:22:05 <ocharles> oh, pretty much what I imagined!
09:22:15 <Cale> DevHC: heh, I also want to mention that it's the other way around: undefined is a bottom program! :)
09:22:19 <ocharles> I thought the ( (,,) <$> ..) bit would end up being m (,,,)
09:22:21 <Cale> > undefined
09:22:22 <lambdabot>   *Exception: Prelude.undefined
09:22:36 <ocharles> but I guess that's not a problem, because it's later used with foo <$>
09:22:54 <isBEKaml> > None
09:22:55 <lambdabot>   Not in scope: data constructor `None'
09:23:00 <ski> ocharles : `(,,,) <$> ia <*> ib <*> ic <*> id :: i (a,b,c,d)', yes
09:23:13 * ocharles nods
09:24:15 <rostayob> EvanR7: I'm not sure how much I would get out of a library like that anyway. Maybe I'm good just modelling all the logic and then paint some data type
09:24:48 <DevHC> Cale: because if a bottom program is undefined, then the definition of seq (bottom if arg1 is bottom, and arg2 otherwise) is equivalent to const arg2
09:25:01 <EvanR7> rostayob: whats wrong with it?
09:25:14 <DevHC> ... which makes a lot of sense
09:25:29 <rostayob> EvanR7: nothing, but maybe it's easier the other way
09:25:39 <DevHC> and makes the workings of some haskell interpreter (hugs?) standard-compliant
09:25:52 <EvanR7> which way
09:26:23 <Cale> DevHC: whaaaaat
09:26:26 <EvanR7> and what logic
09:26:40 <Cale> DevHC: no, it's not at all equivalent to const arg2, unless arg1 isn't bottom
09:27:20 <DevHC> Cale: but if arg1 is bottom, then the the program is undefined. hugs defines the program to be arg2 in this case.
09:27:41 <Cale> That would be incorrect, and I doubt that hugs does that
09:27:50 <gwern> > 11.27 + 3.95 + 15.40 + 3.95
09:27:51 <lambdabot>   34.57
09:27:54 <Cale> Hugs> seq undefined 2
09:27:54 <Cale> Program error: Prelude.undefined
09:27:54 <rostayob> EvanR7: lets say I want to write a little game, I'll just have some "state" data type that holds the state of the game and I'll just have a simple paint function
09:28:02 <Cale> ^^ nope
09:28:04 <rwbarton> programs that are bottom aren't undefined, for instance they may not terminate with normal exit code
09:28:06 <EvanR7> rostayob: of course
09:28:22 <EvanR7> rostayob: this lib is only the simple paint function
09:28:58 <Cale> Hugs> seq (let x = x in x) 2
09:28:58 <applicative> wow, the gloss demos for dph-examples is pretty good.  how do i apprentice myself to b. lippmeier?
09:28:58 <Cale> ^C{Interrupted!}
09:29:00 <DevHC> rwbarton: H$X
09:29:29 <rostayob> EvanR7: I mean if I structure the data type well, maybe writing the paint function in straight SDL would be simpler
09:29:41 <rostayob> since it's quite an "imperative" task, there is no logic behind it
09:29:50 <rostayob> (again if I do the hard work before painting anything)
09:30:00 <EvanR7> >_>
09:30:20 <EvanR7> yes you can do for loops through the surface pixel pointer and write bytes to the video memory
09:30:31 <EvanR7> or use the sprite function in this lib
09:30:48 <EvanR7> or line or whatever
09:31:01 <EvanR7> and its not an imperative task
09:31:09 <Cale> DevHC: seq undefined 0 should never result in 0
09:31:20 <rostayob> EvanR7: well I'll judge that :P
09:31:21 <DevHC> Cale: says who?
09:31:32 <Cale> DevHC: because undefined is bottom, so the result can't be a non-bottom value
09:31:44 <EvanR7> if you have images A B C and D then painting them in different orders amounts of mconcat [D,C,B,A] or whatever
09:31:45 <ski> `seq' is strict in both arguments
09:31:58 <EvanR7> amounts to*
09:32:16 <Cale> seq _|_ y = _|_ and seq x y = y *only if* x is not _|_
09:32:25 <Cale> is what the standard says
09:32:40 <EvanR7> you can do the low level graphics but software sdl is going to be slow and anyway its going to be hellish to do this in haskell
09:32:47 <Cale> So if the first parameter is _|_, the result must be _|_ as well
09:33:18 <ski> Cale : well, if `x' and `y' are both `_|_', then `seq x y = y' *and* `x = _|_' :)
09:33:20 <rostayob> EvanR7: is it? I don't know, I'll see, I've done SDL before and at least it's really simple
09:33:34 <Cale> oh, well, yes :)
09:33:43 <DevHC> Cale: indeed the value of x = (seq undefined 0) is bottom, but an IO () program which evaluates x becomes undefined, and an imaginary haskell compiler defines x to be 0
09:33:57 <Axman6> seq a b = unsafePerformIO $ evaluate a >> return b
09:34:00 <Axman6> >_>
09:34:12 <Cale> DevHC: what?
09:34:16 <DevHC> more precisely, defines the program to be what the program would be if x were 0
09:34:21 <Cale> DevHC: no
09:34:23 <EvanR7> rostayob: lol. ok.
09:34:25 <rwbarton> DevHC: why do you think 'undefined' produces undefined behavior
09:34:25 <Cale> DevHC: That's not valid.
09:34:45 <DevHC> that's what i'm asking about
09:34:48 <rwbarton> "A call to error terminates execution of the program and returns an appropriate error indication to the operating system. It should also display the string in some system-dependent manner. When undefined is used, the error message is created by the compiler."
09:34:49 <EvanR7> rostayob: what sort of graphics are you planning on? nothing but bitmap sprites?
09:35:23 <Cale> DevHC: undefined is a value which is defined in the prelude
09:35:28 <DevHC> a call to error? that sounds stupid as pure functions don't get called, lol
09:35:36 <saml> DevHC, u still chat here?
09:35:39 <rostayob> EvanR7: I was planning to draw most of the stuff separatedly yeah
09:35:45 <DevHC> saml: problem?
09:35:55 <saml> i thought you had a paper to write
09:35:58 <EvanR7> rostayob: >_>
09:36:03 <rostayob> EvanR7: ?
09:36:11 <EvanR7> rostayob: i dont understand what separately means
09:36:15 <DevHC> saml: to write? :S
09:36:24 <Cale> DevHC: If you want, replace "a call to error" with "evaluating an application of error to a string parameter"
09:36:33 <rostayob> EvanR7: I don't think I'll draw shapes directly
09:36:42 <rostayob> I'll just import images
09:36:49 <EvanR7> rostayob: what about fades and tints
09:36:53 <EvanR7> and color manipulation
09:36:57 * ski . o O ( `catch theProgram (\(ErrorCall errMsg) -> ..errMsg..)' )
09:37:05 <DevHC> ok so formally haskell has several bottom values
09:37:28 <DevHC> like division by zero, error "write me", infinite loop, etc.?
09:37:39 <saml> division by zero isn't bottom
09:37:42 <Cale> DevHC: Those all get mapped to bottom
09:37:44 <rostayob> EvanR7: I don't know, I'll just do what's simpler I'm not doing anything complex :P
09:37:47 <saml> i think bottom is computation not halting
09:37:48 <rostayob> I don't think I'll need those
09:37:53 <ski> > 1 `div` 0
09:37:54 <lambdabot>   *Exception: divide by zero
09:37:56 <Cale> Well, division by 0 for non-float values :)
09:37:58 <EvanR7> rostayob: well just sprites is very easy with this drawing combinators lib
09:38:06 <Cale> > 1 / 0 :: Rational
09:38:07 <lambdabot>   *Exception: Ratio.%: zero denominator
09:38:13 <EvanR7> and it will be higher performance than sdl
09:38:14 <isBEKaml> I don't think error qualifies as bottom, it's more of a breakout IMHO.
09:38:17 <Cale> > 1/0 :: Double
09:38:18 <lambdabot>   Infinity
09:38:18 <rwbarton> you can call those different values if you like but you can't distinguish them with a pure function, or anything in the haskell 98 report afaik
09:38:20 <rostayob> EvanR7: yeah it is
09:38:32 <isBEKaml> > @type 1/0
09:38:33 <lambdabot>   <no location info>: parse error on input `@'
09:38:38 <Cale> @type 1/0
09:38:39 <isBEKaml> > :t 1/0
09:38:39 <lambdabot> forall t. (Fractional t) => t
09:38:40 <lambdabot>   <no location info>: parse error on input `:'
09:38:41 <ski> isBEKaml : `error x' qualifies as `_|_'
09:38:45 <Cale> :t 1/0
09:38:46 <lambdabot> forall t. (Fractional t) => t
09:38:46 <saml> bottom refers to a computation which never completes successfully. That includes a computation that fails due to some kind of error, and a computation that just goes into an infinite loop
09:38:48 <DevHC> well even if i could, i can't write Eq Bottom
09:38:59 <Cale> DevHC: sure
09:39:05 <saml> > head []
09:39:06 <EvanR7> :t undefined
09:39:06 <lambdabot>   *Exception: Prelude.head: empty list
09:39:07 <lambdabot> forall a. a
09:39:13 <isBEKaml> ski: I'm not sure now. can you match types against it?
09:39:14 <Cale> DevHC: Well... Bottom isn't a type
09:39:20 <rostayob> EvanR7: anyway I'll definitely try it out, thanks
09:39:34 <DevHC> Cale: seq is magic, too
09:39:44 <Cale> DevHC: It's not *that* magical
09:39:55 <Cale> DevHC: You can define seq explicitly for algebraic datatypes
09:39:56 <saml> http://www.haskell.org/haskellwiki/Bottom
09:40:02 <Cale> like:
09:40:09 <EvanR7> :t pure.pure.pure
09:40:10 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a (f2 :: * -> *). (Applicative f, Applicative f1, Applicative f2) => a -> f (f1 (f2 a))
09:40:17 <Cale> seq :: Maybe a -> b -> b
09:40:21 <DevHC> Cale: well it's highly magical, for example we can pass any value to seq
09:40:22 <Cale> seq Nothing y = y
09:40:25 * roconnor tries to remember to eta-expand everything in ocaml.
09:40:29 <Cale> seq (Just _) y = y
09:40:44 <saml> seq is eager evaluation
09:40:44 <teurastaja> im a schemer and i was wondering how kaskell managed to work without assignments
09:40:45 <EvanR7> DevHC: that doesnt sound very magical. id :: a -> a
09:40:51 <teurastaja> *haskell
09:40:52 <DevHC> > id 1
09:40:53 <lambdabot>   1
09:40:56 <isBEKaml> ski: I think I see what you mean. for a function e that maps A -> B and somewhere error's thrown, that will still type check.
09:40:56 <Cale> DevHC: but yes, seq is magical in that it knows how to "pattern match" an arbitrary first parameter
09:40:57 <saml> teurastaja, let
09:40:58 <DevHC> FUUUUUU
09:41:02 <Cale> DevHC: including a function
09:41:15 <EvanR7> teurastaja: you can still do assignment, writeIORef, etc
09:41:16 <teurastaja> sam: weve got the same name
09:41:17 <roconnor> teurastaja: we have assignments, just no re-assignments :D
09:41:23 <Cale> > seq (undefined :: a -> a) 0
09:41:23 <lambdabot>   *Exception: Prelude.undefined
09:41:24 <ski> isBEKaml : i'm not sure what you mean by "can you match types against it?"
09:41:31 <Cale> > seq (const undefined :: a -> a) 0
09:41:32 <lambdabot>   0
09:41:43 <teurastaja> how is state implemented?
09:41:46 <Cale> So seq can tell the difference between undefined and const undefined
09:41:49 <Axman6> with functions
09:41:53 <teurastaja> mutual recursion?
09:41:54 <EvanR7> or IO
09:41:55 <saml> teurastaja, there is StateMonad
09:41:56 <isBEKaml> ski: never mind, I was thinking pattern matching and argument checking.
09:42:07 <saml> or do you mean state machine?
09:42:10 <ski> teurastaja : do you mean the `State s' monad ?
09:42:11 <roconnor> teurastaja: with functions: s -> (s,a)  where s is the type of state.
09:42:17 <DevHC> seq also knows how to "not pattern match" functions that can't be evaluated yet
09:42:31 <Cale> teurastaja: That's kind of an odd question. You know that Haskell *does* have mutable references and arrays and such in IO, yeah?
09:42:39 <EvanR7> as ive been saying
09:43:02 <isBEKaml> ski: look at what I said above in context of functions. Is that correct?
09:43:11 <Axman6> teurastaja: haskell teaches you that side effecting state is not a good thing, and has many elegant ways to avoid and reduce it
09:43:17 <teurastaja> ze BIG question (im sure im the first one asking it here ;)): monads. why cant someone explain them in less than 100 lines?
09:43:27 <Cale> teurastaja: It's just that functions have no access to that stuff, only IO actions (and indirectly, functions which construct IO actions) do.
09:43:28 <EvanR7> monads are like burritos
09:43:36 <hvr> teurastaja: why should one? :)
09:43:48 * isBEKaml expects the monads analogy avalance
09:43:54 <hvr> teurastaja: and 100 lines of what btw?
09:43:55 <isBEKaml> *avalanche
09:43:56 <confab_> EvanR7: you make a lot of references to burritos
09:43:58 <ski> isBEKaml : could you quote the line you're referring to ? -- #haskell is moving pretty quickly atm
09:44:00 <Axman6> teurastaja: they're simply an abstraction for sequencing functions
09:44:05 <confab_> EvanR7: makes me hungry
09:44:07 <saml> monads are like poketmon
09:44:09 <EvanR7> me too
09:44:09 <DevHC> monads r cheeez factories
09:44:20 <saml> you gatta catchem all
09:44:21 <isBEKaml> ski: I think I see what you mean. for a function e that maps A -> B and somewhere in the function, error's thrown, that will still type check.
09:44:23 <Cale> teurastaja: So if you have a function with type Integer -> Integer, it is only allowed to depend on the Integer you give it, and is only allowed to produce a result of type Integer, and can't do anything else (except use memory and CPU power)
09:44:30 <isBEKaml> ski: ^^
09:44:34 <teurastaja> even a paper making an analogy of monads with monsters couldnt explain in less lines
09:44:46 <roconnor> teurastaja: http://www.youtube.com/watch?v=efv0SQNde5Q is an nice video by edwardk about using lenses to do (re-)assignment in Scala, but it mostly applies to Haskell as well
09:44:52 <ski> @quote what's.the.problem
09:44:52 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
09:44:55 <ski> teurastaja ^
09:45:05 <Cale> Could we have fewer trolls please?
09:45:14 <parcs> i can explain monads in three lines of haskell code
09:45:15 <DevHC> i can see the headlines now... MONADS EXPLAINED IN 100 LINES BY 100 ANALOGIES...by #haskell
09:45:20 <teurastaja> i sort of know what functors are but whats an endofunctor?
09:45:34 <Cale> teurastaja: An endofunctor is just a functor from a category to itself.
09:45:36 <ski> teurastaja : a functor with the same category as domain and codomain
09:45:36 <Axman6> teurastaja: the thing about monads is that they're actually amazingly simple, once you 'get' how to use them. i found that using them was a lot easier than understanding them (which is exactly what a good abstraction should do right?)
09:45:54 <roconnor> teurastaja: endo- means the domain and codomain are function/functor are the same.
09:46:02 <EvanR7> they are too simple to understand, or maybe thats Functors
09:46:19 <Axman6> teurastaja: you do not need to know what an endofunctor is to understand monads in haskell
09:46:33 <copumpkin> why do people expect them to be understandable in a couple of lines with no background?
09:46:56 <isBEKaml> copumpkin: because they are monads? ;)
09:46:57 <Axman6> i've been using haskell for three and a half years, and i still have no idea what an endofunctor is, and i don't really care
09:47:03 <copumpkin> it seems kind of arrogant to show up to a new language and understand the new concepts with no effort at all
09:47:04 <ski> teurastaja : in Haskell, the short explanation of what monads are is just the definition of the class `Monad', together with the three monad laws
09:47:05 <teurastaja> make an analogy with continuations
09:47:10 <roconnor> teurastaja: edwardk's video is really good though.  I recommend it highly.
09:47:14 <teurastaja> i know scheme so...
09:47:23 <Axman6> teurastaja: well, there's a continuation monad...
09:47:26 <copumpkin> teurastaja: that doesn't help you at all
09:47:27 <teurastaja> how are they related?
09:47:28 <Axman6> there's also a list monad
09:47:40 <copumpkin> teurastaja: _why_ are you looking to understand monads?
09:47:43 <Cale> teurastaja: You probably are aware of combinator libraries?
09:47:45 <Axman6> :t (>>=)
09:47:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:47:49 <EvanR7> class MonadCont
09:48:09 <Axman6> teurastaja: have you ever used haskell?
09:48:14 <ski> teurastaja : well, if you have delimited continuations, you can reflect any (computational) monad, using Andrzej Filinski's "Representing Monads" at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/>
09:48:17 <teurastaja> damn i cant read haskell yet
09:48:24 <Cale> teurastaja: As far as programming is concerned, Monad is basically a formalisation of a particular set of combinators which often crop up in many libraries.
09:48:33 <hvr> roconnor: url?
09:48:41 <ski> teurastaja : but you probably should understand monads before tackling that one :)
09:48:42 <hvr> roconnor: nevermind
09:48:51 <EvanR7> :t fmap
09:48:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:48:57 <Phyx-> wth, since when does SYB have an everythingBut
09:49:03 <Axman6> because, trying to understand monads in haskell without using haskell would be like trying to understand how to play mozart without knowing how to us a piano at all
09:49:06 <Axman6> use*
09:49:09 <Cale> teurastaja: That is, it's kind of a common "shape" that a lot of library APIs have. We abstract over that shape so that we can write code that works with all such libraries.
09:49:26 <Cale> (which is the main reason for any abstraction in programming)
09:49:37 <Cale> So what is the shape?
09:49:41 <EvanR7> Cale: which is just explaining what a library is, not just the Monad library
09:49:51 <ski> isBEKaml : well, it holds for evaluating any expression that calls `error', not just functions, but yes
09:49:53 <Cale> EvanR7: what?
09:50:04 <Cale> EvanR7: Well, what a typeclass is, perhaps
09:50:14 <Cale> But I'm about to explain :)
09:50:37 <EvanR7> k
09:50:49 <Cale> So if Monad is a common pattern among many libraries that we want to abstract out, what is that pattern?
09:51:27 <isBEKaml> ski: Ah, in that case, I got a question. How does haskell check types (I think it doesn't have subtyping, per se). Any links?
09:51:30 <hvr> Cale: sequencing with effects ... I'd guess
09:51:42 <Cale> Well, it's the presence of a parametrised datatype T, together with a couple of operations.
09:52:09 <Axman6> isBEKaml: bottom has type forall a. a
09:52:10 <isBEKaml> ski: IOW, if X is a bottom type and a function returns another type T, how does haskell check those two types so it passes the compile checks?
09:52:12 <Cale> teurastaja: are you familiar with parametrised datatypes like [a] and Tree a and so on?
09:52:13 <ski> isBEKaml : it uses type inference. coupled with parametric polymorphism
09:52:29 <Axman6> since it never returns a value, you can say it's value is of any type
09:52:45 <Cale> isBEKaml: "bottom type" isn't a thing
09:52:49 <ski> isBEKaml : there is no "bottom type" in this discussion
09:53:06 <Cale> bottom is a value which belongs to each type separately
09:53:14 <ski> isBEKaml : `error "foo !"' has any type `a' you want it to have
09:53:27 <Axman6> Cale: or a lack of value perhaps?
09:53:29 <Cale> teurastaja: are you still here?
09:53:42 <Cale> Axman6: You still kinda have to consider it a value
09:53:42 <isBEKaml> ski: sorry, I got confused. if you say type any, that sounds suspiciously like casting.
09:54:08 <Cale> isBEKaml: You can make a polymorphic definition of bottom
09:54:09 <isBEKaml> Cale: what you just said makes sense. bottom is a value that's associated to each type.
09:54:10 <Axman6> Cale: well, i guess, if you've decided that only values can have types
09:54:12 <ski> isBEKaml : there is no "any" type either, no casting is going on
09:54:47 <Axman6> isBEKaml: does the idea that since bottom never returna a value, it can have any type make sense to you?
09:54:50 <Axman6> that's how i'd think about it
09:54:54 <ski> isBEKaml : consider `length :: [a] -> Int', if you use it as `length "abcd"', then in that case it has type `length :: [Char] -> Int'
09:54:54 <Axman6> returns*
09:55:17 <ski> isBEKaml : `length' has type `[a] -> Int' for any type `a' that you like
09:55:24 <isBEKaml> Axman6: I can't see the connect. AFAICS, values must have types associated with it.
09:55:37 <ski> isBEKaml : similarly `error "foo !" :: a', so it has any type `a' that you like
09:55:42 <Cale> (and this isn't a 'cast' unless you want to redefine the word ;)
09:55:46 <Axman6> isBEKaml: what type shoudl let x = x in x have?
09:55:56 <isBEKaml> Axman6: void? assignment's void?
09:56:06 <EvanR7> dont expressions have types too?
09:56:18 <ski> EvanR7 : yes they do
09:56:29 <confab_> :t let x = x in x
09:56:30 <lambdabot> forall t. t
09:56:32 <Axman6> isBEKaml: well, i could write: let x = x :: Int in x, and it now has type Int
09:56:47 <Axman6> i can also write let x = x :: Bool in x, and it's got type Bool
09:56:50 <Cale> > let x = x in x
09:56:54 <lambdabot>   mueval-core: Time limit exceeded
09:56:56 <EvanR7> _|_
09:56:58 <ski> isBEKaml : there is no "assignment's void", either it doesn't type-check, or it type-checks and in that case it has to be assigned a type
09:57:06 <zygoloid> hmm, types form a lattice, so there is a bottom type, but we don't call it that.
09:57:09 <Axman6> so, we can see that it can have any type we want it to
09:57:20 <ski> > (let x = x in x) :: Bool
09:57:24 <lambdabot>   mueval-core: Time limit exceeded
09:57:35 <Cale> zygoloid: What are the meet and join?
09:57:48 <Axman6> > let x = x in (x :: Int, x :: Bool)
09:57:49 <Eduard_Munteanu> zygoloid: isn't that more relevant when discussing subtyping, though?
09:57:52 <lambdabot>   mueval-core: Time limit exceeded
09:57:53 <isBEKaml> ski: I understand parametric polymorphism.
09:58:02 <Axman6> o.O, i can't believe that type checked, heh
09:58:06 <zygoloid> Eduard_Munteanu: sure, but haskell has subtyping (not much like OO subtyping, but still)
09:58:09 <ski> zygoloid : what is the ordering used ? generic instances ?
09:58:19 <Axman6> :t let x = x in (x :: Int, x :: Bool)
09:58:20 <lambdabot> (Int, Bool)
09:58:32 <Axman6> :t let x = x in (x :: Int, x :: Bool, x :: String)
09:58:32 <lambdabot> (Int, Bool, String)
09:58:38 <Eduard_Munteanu> Hm? Do you mean the typeclass stuff?
09:58:38 <isBEKaml> Axman6: I can't see how that type checked!
09:58:40 <zygoloid> ski: a > b iff every value of a is a value of b
09:58:40 <thoughtpolice> Axman6: makes sense. let x = x, therefore x :: a
09:59:12 <chrisdone_> Eduard_Munteanu: Igloo: btw, the bancomat card worked here in the uk :)
09:59:14 <isBEKaml> :t let x = x in (x :: (Int, Bool, String))
09:59:14 <thoughtpolice> x = x is 'bottom' as much as 'undefined' is, which is also of type 'a', so you can instantiate it at any type, anywhere
09:59:15 <lambdabot> (Int, Bool, String)
09:59:21 <Axman6> thoughtpolice: yeah, but i thought the monomorphism restriction or something wouldn't let me do that
09:59:30 <isBEKaml> Axman6: whoa, anything there? :s
09:59:32 <ski> zygoloid : not the other way around, then ?
09:59:48 <rwbarton> monomorphism restriction only applies when there is a type class involved
09:59:54 <zygoloid> ski: i'm not sure which way is conventional :)
09:59:59 <Axman6> isBEKaml: see, bottom can have any type, so it always type checks
10:00:05 <mwc> What's the proper way to refer to the builddir in the .cabal file? I need to do extra-libraries: $builddir/build/c/libblah.a but $builddir is actually a variable
10:00:05 <mwc> For now I suppose erroring out if the user specifies an alternate builddir is the only way to handle this
10:00:07 <Eduard_Munteanu> What's a bancomat there? Here that's the name for an ATM.
10:00:10 <Eduard_Munteanu> Wow
10:00:11 <Axman6> bloody irccloud!
10:00:28 <Axman6> or not, that wasn't it that time
10:00:38 <ski> zygoloid : well, it would feel more natural to me to say `(forall a. a) < Int < (exists a. a)' ..
10:00:40 * chrisdone_ watches as a bunch of harps fall to the earth
10:01:03 <ski> (zygoloid : and then `forall a. a' is the bottom element and `exists a. a' is the top one)
10:01:11 <Axman6> chrisdone: every time there's a netsplit, got kills an angle?
10:01:29 <ski> chrisdone : someone said hpaste died
10:01:33 <zygoloid> ski: other than convention, i think it's arbitrary, but i agree that it seems 'nicer' for 'forall a. a' to be the bottom type
10:01:37 <isBEKaml> I'm having a tough time following this. Don't types form a certain hierarchy?
10:01:53 <ski> zygoloid : it also seems to conform with inclusion in set theory better
10:01:59 <isBEKaml> Or is bottom associated to every type so it always typechecks?
10:02:05 <Eduard_Munteanu> ski: what's that sort of subtyping called?
10:02:11 <zygoloid> ski: indeed.
10:02:16 <Axman6> bottom has every type, because it never returns a value
10:02:17 <chrisdone> ski: yeah, i restarted it. the system ran out of memory and hpaste was killed. i stopped a bunch of php processes to make room
10:02:22 <thoughtpolice> isBEKaml: bottom inhabits every type.
10:02:23 <chrisdone> Axman6: it was a joke about clouds :p
10:02:29 <ski> Eduard_Munteanu : it's not subtyping, it's generic vs. generic instances
10:02:31 <isBEKaml> that is, for a function that returns Int, the bottom value is 0. For Char, it's ''
10:02:33 <Axman6> chrisdone: ah, heh
10:02:35 <isBEKaml> and so on. ?
10:02:36 <chrisdone> Axman6: are you coming to camhac?
10:03:00 <Axman6> it's several thousand kilometers away... so probably not
10:03:05 <chrisdone> ah, us?
10:03:17 <Axman6> AU
10:03:19 <ski> isBEKaml : no
10:03:27 <ski> isBEKaml : the bottom "value" is always `_|_'
10:03:40 <isBEKaml> ski: no, because it returns nothing?
10:03:42 <Axman6> i prefer to think of bottom having no value
10:03:45 <ski> isBEKaml : for `Int', the bottom value is not `0'
10:04:04 <ski> isBEKaml : "bottom value" means something that doesn't return a proper value
10:04:10 <chrisdone> Axman6: just dig a hole. wear a raincoat to protect you from magma and mantle, and getting a bit wet when you arrive in the atlantic. then the UK is just round the corner
10:04:14 <thoughtpolice> isBEKaml: no, bottom does not refer to some specific value of a certain type, like the 'lowest' value or anything. bottom can mean a lot of things, but you can think of bottom as being 'no value', or an improper value
10:04:19 <zygoloid> ski: let's pretend i'd arbitrarily picked the other one
10:04:40 <ski> zygoloid : ok
10:04:42 <thoughtpolice> isBEKaml: so in the case of haskell, we typically call bottom 'undefined'. this is a very special value which has a very special type:
10:04:45 <thoughtpolice> :t undefined
10:04:46 <lambdabot> forall a. a
10:04:49 * isBEKaml needs to clear his head. Is badly in need of reading material. 
10:05:05 <EvanR7> thats not a special type
10:05:36 <EvanR7> oh
10:05:39 <thoughtpolice> well, not really special, but what other values have that type which are not bottom?
10:05:41 <EvanR7> anything with that type is bottom?
10:05:50 <thoughtpolice> (honest question there)
10:06:13 <ski> (zygoloid : if you're waiting for some response, i'm afraid you'll have to reask the question, too much is going on atm so i forgot the context)
10:07:00 <ski> EvanR7 : yes, that turns out to be the case
10:07:01 <thoughtpolice> i mean, technically if you view haskell types as a logic, such a special value makes the logic inconsistent, because you can use 'undefined' to prove any proposition - because bottom inhabits can inhabit that type.
10:07:06 <ski> thoughtpolice : no other values
10:07:07 <zygoloid> ski: there was no question, i just wanted consensus on the nicer choice
10:07:09 <Saizan> every type has a bottom element in its domain, forall a. a happens to not have any other.
10:07:10 <thoughtpolice> ski: that's what i thought
10:07:12 <EvanR7> ski: no even in theory?
10:07:14 <EvanR7> not*
10:07:22 <Eduard_Munteanu> Well, how can you define a function   f :: ... -> (forall a. a)?
10:07:33 <chrisdone> and yeah...  memory usage on hpaste is big. suppose i should profile it. I think stuff isn't being GC'd, maybe need to compile hscolour and hlint with -O2
10:07:33 <Eduard_Munteanu> It can only give bottom.
10:07:41 <ski> EvanR7 : `forall a. a' is an "inconsistent type", it doesn't have any (proper) values
10:07:46 <Saizan> you don't need to got through "undefined" to get a bottom of some other type, though
10:08:00 <EvanR7> ski: but a -> a is ok?
10:08:05 <EvanR7> and (a,a)
10:08:09 <EvanR7> [a]
10:08:12 <ski> "is ok?" means ?
10:08:18 <Eduard_Munteanu> That's forall a. a -> a
10:08:20 <chrisdone> a -> a has a value
10:08:21 <EvanR7> not bottom
10:08:46 <thoughtpolice> EvanR7: [a] can be inhabited by the empty list - []
10:08:58 <EvanR7> k
10:09:01 <ski> EvanR7 : `a -> a' always have a (proper) value, regardless of what type `a' is, namely `id'
10:09:01 <zygoloid> EvanR7: those types are all inhabited by values other than _|_. however, (a,a) is not inhabited by any 'total' values
10:09:16 <EvanR7> interesting
10:09:22 <Axman6> :t id
10:09:22 <EvanR7> so (a,a) is inconsistent like a
10:09:23 <lambdabot> forall a. a -> a
10:09:35 <isBEKaml> > id undefined
10:09:35 <ski> EvanR7 : in the `(a,a)' case, you could say it fails to have a proper value in case `a' fails to
10:09:36 <lambdabot>   *Exception: Prelude.undefined
10:09:44 <zygoloid> EvanR7: not in quite the same way. it has two values: _|_ and (_|_, _|_), which are distinguishable
10:09:59 <EvanR7> bah
10:10:01 <isBEKaml> > let x = undefined . id in (x 5)
10:10:02 <lambdabot>   *Exception: Prelude.undefined
10:10:06 <EvanR7> this whole business is whack
10:10:10 <Axman6> EvanR7: a -> a basically says, if you give me something of type a, where a can be anything at all, i'll give you something back of type a
10:10:13 <zygoloid> fsvo distinguishable :)
10:10:18 <chrisdone> > let (_,_) = "OK!" in (undefined,undefined)
10:10:19 <lambdabot>   Couldn't match expected type `(t, t1)'
10:10:20 <lambdabot>         against inferred type `[GHC....
10:10:20 <thoughtpolice> heh
10:10:23 <zygoloid> semi-distinguishable? :)
10:10:26 <chrisdone> woops
10:10:45 <Eduard_Munteanu> Or you could avoid mentioning undefined explicitly, say, f :: forall a. (a, a); f = (f, f)
10:10:47 <thoughtpolice> chrisdone: what's the memory usage for hpaste like out of curiosity?
10:10:49 <chrisdone> > let f (_,_) = "OK" in f (undefined,undefined)
10:10:50 <lambdabot>   "OK"
10:11:03 <ski> EvanR7 : you have to distiguish between a "totally undefined value", i.e. `_|_', "partially undefined value", which contains `_|_', and "totally defined value", which doesn't contain any `_|_'
10:11:04 <dmwit> zygoloid: How about, "which behave differently"?
10:11:07 <chrisdone> thoughtpolice: for the paste few weeks it's stablized to 250M~
10:11:34 <ski> zygoloid :)
10:11:39 <Axman6> EvanR7: if you've ever done any propositional logic, you might be able to see that types are propositions (x -> y is literally implication, if we you give me an x, i can give you a y), and programs are actually proofs of their types
10:11:57 <chrisdone> thoughtpolice: i've seen it at 300 and then go down again to 250 (which i put down to GC)
10:12:04 <Eduard_Munteanu> Wait, I'm not sure if that needs to be impredicative, hrm.
10:12:05 <zygoloid> dmwit: well, (undefined,undefined) behaves differently, and you can't observe whether undefined does :)
10:12:10 <ski> Eduard_Munteanu : that doesn't type-check
10:12:18 <isBEKaml> Axman6: wait, that was for functions.. No?
10:12:26 <Eduard_Munteanu> Yeah, you need the forall on the inside I guess.
10:12:31 <Axman6> isBEKaml: ?
10:12:49 <isBEKaml> Axman6: types are propositions, I could say that about functions too.
10:13:04 <Axman6> functions are proofs of their types
10:13:06 <dmwit> zygoloid: Yes, I can too observe it.
10:13:06 <thoughtpolice> isBEKaml: no, types are propositions. values of that type is a 'proof of that propositions'
10:13:19 <isBEKaml> Axman6: that is, a function f always maps some value of type A to another of type B.
10:13:30 <ski> Eduard_Munteanu : doesn't work either
10:13:32 <zygoloid> purely not! :)
10:13:42 <Axman6> isBEKaml: yes, and functions tell the compiler how to do that mapping
10:13:46 <Phyx-> ok, so GHC 7.0.3 has removed 'ensureFlattenedExtensionFlags', does that mean you no longer need to flatten ExtensionFlags?
10:13:46 <chrisdone> thoughtpolice: i'm guessing i'm leaking values somewhere. i could probably make a script to submit and view a load of pages and then profile memory usage. as there're a few libraries i'm using as well as my own code that could be leaking
10:13:47 <dmwit> zygoloid: After one second, a pattern match on (_|_ , _|_) will certainly have succeeded, because my computer is fast, but a pattern match on _|_ will not have (or will have thrown an exception).
10:14:09 <dmwit> zygoloid: We're doing metatheory here, so purity is irrelevant. Pure functions aren't observers.
10:14:10 <thoughtpolice> isBEKaml: for example, in FOL, if you have A -> B, and I give you an A, you give me a B. if you have a function in haskell of type f :: A -> B, you give f a value of type A, you get a B. if 'f' can be properly defined, you have 'proven you can go from A to B'
10:14:15 <zygoloid> dmwit: ah, but what if your computer is swapping? :)
10:14:26 <dmwit> I can observe my computer swapping.
10:14:38 <isBEKaml> thoughtpolice: so functions are plain proofs?
10:14:48 <Axman6> thoughtpolice: thanks for the clearer explanation :)
10:14:56 <thoughtpolice> isBEKaml: yep. types are propositions, and programs are proofs
10:15:00 <isBEKaml> thoughtpolice: and types are propositions.
10:15:05 <thoughtpolice> yep!
10:15:13 <dmwit> zygoloid: I think the main point here is you and I have different ideas about what it means to "observe" something.
10:15:17 <zygoloid> dmwit: sure, operationally they're clearly distinguishable. you can catch undefined in IO, for instance
10:15:18 <ski> dmwit : maybe your computer is just swapping long enough to delude you into thinking it won't terminate ?
10:15:19 <isBEKaml> excellent. I grokked one, atleast. :)
10:15:34 <Eduard_Munteanu> ski: hrm, I thought that'd do. Any idea what type it needs to have?
10:15:37 <thoughtpolice> isBEKaml: so when you look at haskell types as a logic, you suddenly see a big problem from a consistency point of view with 'undefined' - because it is of type 'a', you can use undefined to 'prove any proposition you please'
10:15:57 <dmwit> zygoloid: I certainly can't tell whether *a particular term* is going to evaluate to _|_ or (_|_, _|_) in general, but I can just as certainly tell if *a value* is (_|_, _|_) or not.
10:16:00 <ski> Eduard_Munteanu : well, `f :: (exists a. a,exists a. a)' would work ..
10:16:01 <chrisdone> ski: Evil Automata Theory!
10:16:21 <thoughtpolice> isBEKaml: you could prove for example, that Int is equal to Bool, or other nonsensical things. this corresponds to the classical distinction between 'consistent' and 'complete' axiomatic systems (cf godel)
10:16:22 <Eduard_Munteanu> Ah.
10:16:28 <isBEKaml> thoughtpolice: thanks for stating the "undefined" problem so clearly. I was clearly grabbing at it unsuccessfully for the past few moments...
10:16:33 <zygoloid> dmwit: but even still, there's an important distinction. suppose we write a computation which will check all possible proofs of (your favourite unsolved mathematical hypothesis) and produce (_|_,_|_) if it's true (and _|_ if it's false)
10:16:40 <zygoloid> you can never know that it will not produce (_|_,_|_)
10:17:05 <zygoloid> (without proving both the complement and the consistency of the system)
10:17:13 <thoughtpolice> chrisdone: yeah, writing something to hammer out your common access patterns help a lot
10:17:19 <dmwit> That's a term, not a value.
10:17:22 <erus`> zygoloid: in english plox
10:17:23 <thoughtpolice> (turn profiler on, hammer away, look later :)
10:17:49 <ski> zygoloid : have you read Escard's paper on topology, yes ?
10:17:50 <chrisdone> thoughtpolice: are YOU coming to camhac? :)
10:18:34 <zygoloid> ski: probably not.
10:18:35 <thoughtpolice> chrisdone: i would if i wasn't in the US. :) bit of a long trip (plus i just took a day off to go to hac phi the other week :P)
10:18:36 <isBEKaml> thoughtpolice: that's what I was thinking (albeit unconsciously, and unable to articulate it clearly).
10:18:39 <ski> @where topology
10:18:39 <lambdabot> "topology in Haskell" <http://www.haskell.org/pipermail/haskell/2004-June/014134.html> and "Synthetic topology of data types and classical spaces" <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|
10:18:40 <lambdabot> dvi|ps)> by Martn Escard
10:19:07 * thoughtpolice will go on a haskell hackathon world tour, one year...
10:19:08 <chrisdone> thoughtpolice: oic
10:19:11 <chrisdone> hehe
10:19:43 <chrisdone> i whipped up some elisp to parse Haskell Show instances: http://paste.lisp.org/display/123970
10:19:57 <chrisdone> gonna use it to make an 'expander' in the REPL
10:20:08 <zygoloid> dmwit: yours is a fair point. but i think mine is too. while you can operationally distinguish different sorts of bottom, that's a quirk of the implementation not of the language
10:20:22 <erus`> wow it matches the braces :O
10:20:24 * dmwit nods
10:21:02 <erus`> does lisp/scheme turn "hello" into ('h', ('e', ('l' etc etc
10:21:05 <thoughtpolice> isBEKaml: yea. when you look at haskell programs/types in such a way, you begin to see how really deeply connected computing and other mathematical systems are, IMO. if you want to look up more, this magical correspondence is called the 'curry-howard isomorphism' (which states types = propositions, programs = proofs)
10:21:27 <chrisdone> erus`: no, strings are distinct object types
10:21:41 <zygoloid> ski: thanks! i'm familiar with some of the results in that paper, but not the paper itself
10:21:49 <chrisdone> more like haskell's Text or ByteStrings
10:22:11 <thoughtpolice> isBEKaml: there's lots of rich and deep theory in this area if you ask me, ranging from people like cantor to turning and godel :D
10:22:24 <mizu_no_oto_> Is Imperative Functional Programming a good paper to read to understand how modern compilers (e.g. ghc) implement monadic IO?
10:22:29 <ski> @where impossible
10:22:29 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
10:22:31 <chrisdone> Anla Turning
10:22:32 <Eduard_Munteanu> Turning and Yodel...
10:22:38 <ski> zygoloid : i assume you've seen those ^, then ?
10:22:39 <chrisdone> Eduard_Munteanu: xD
10:22:44 <isBEKaml> thoughtpolice: C-H Isomorphism again? Now, I must really go read that stuff up (been on my reading-to-do-list for some time now) :D
10:22:48 <mizu_no_oto_> Or has the thinking on how to implement IO shifted since then?
10:23:08 <chrisdone> byorgey: http://paste.lisp.org/display/123970
10:23:25 <thoughtpolice> ski: the andrej thing on impossible functional programs still blows my mind quite a bit
10:23:33 <thoughtpolice> i don't think i can yet appreciate it :)
10:23:35 <KirinDave> Man, building ghc is not a quick process.
10:23:40 <KirinDave> Even for my computer.
10:23:43 <byorgey> chrisdone: what's this?
10:23:52 <isBEKaml> thoughtpolice: godel? Godel's inconsistency problem? :D
10:23:53 <thoughtpolice> KirinDave: okay, off the bat, did you set your build mode to 'quick' in mk/build.mk?
10:24:10 <ski> thoughtpolice : well, it's really Martn Escard, not Andrej Bauer. it's just hosted on Bauer's blog
10:24:24 <KirinDave> thoughtpolice: I followed the directions on the wiki for building on OSX.
10:24:30 <thoughtpolice> isBEKaml: yep, that's what i was hinting at with the 'consistency vs completeness' thing, technically haskell types are an inconsistent logic if you account for 'undefined', since you can prove anything
10:24:33 <KirinDave> thoughtpolice: So if they do not say to do that, I did not do it. :)
10:24:59 <chrisdone> byorgey: a parser (and printer) for haskell's Show output. my next step is to make something to produce embedded overlays that can be expanded sub-expression at a time
10:25:03 <thoughtpolice> KirinDave: ah. okay, because on my corei7 w/ 8 hw threads, i can build a full GHC in about 10 minutes. but if you don't have the right mk/build.mk settings, that'll take a long time
10:25:07 <thoughtpolice> ski: ah
10:25:07 <isBEKaml> thoughtpolice: ah, undefined's a bit of a basket case. ;)
10:25:12 <thoughtpolice> KirinDave: let me see if i can find the wiki page
10:25:14 <byorgey> chrisdone: neat!
10:25:39 <chrisdone> :D
10:25:50 <thoughtpolice> KirinDave: http://hackage.haskell.org/trac/ghc/wiki/Building/Hacking#Beforestartingyourbuild
10:25:54 <ski> isBEKaml : no, not that
10:26:07 <chrisdone> still figuring out the peg.el library
10:26:08 <thoughtpolice> KirinDave: tl;dr you should set 'BuildFlavor=quick' in your mk/build.mk
10:26:09 <KirinDave> thoughtpolice: So should I stop my build?
10:26:17 <KirinDave> It's been running for about half an hour.
10:26:24 <isBEKaml> ski: :D
10:26:28 <thoughtpolice> KirinDave: well, if it's a one time thing then maybe not. if you're going to be rebuilding frequently, you may want to
10:26:29 <KirinDave> Also this is on OSX. The sheer amount of linking errors.. The linking errors!
10:26:38 <KirinDave> Well warnings I guess
10:26:43 <thoughtpolice> KirinDave: all of those should be fixed as of 7.2.1, btw
10:26:49 <thoughtpolice> but 7.0.4 will still have them. they're harmless
10:26:55 <ski> isBEKaml : this is stuff like implementing `Eq' on `Stream Bool -> Bool', e.g.
10:27:28 <ski> isBEKaml : where `data Stream a = Cons {head :: a,tail :: Stream a}'
10:27:31 <isBEKaml> ski: relax, I was just joking. (evidently, the smileys were either too small or invisible)
10:27:46 <thoughtpolice> KirinDave: but if you're going to rebuild at any sort of frequency, then setting BuildFlavor=quick will save you a LOT of time. it's the difference between compiling all of GHC with optimizations and without, and that incurs a lot more build time
10:27:58 <KirinDave> thoughtpolice: I am using 7.0.2 to bootstrap 7.2.1
10:28:02 <thoughtpolice> KirinDave: i'd also advise running with all the cores you're willing to give since it will go faster with every one (not linear, but it cuts it down quite a bit)
10:28:08 <KirinDave> designer evidently had a hard fail on OSX lion with this process
10:28:22 <ian__> just wondering, why is my 1-line haskell program 650kb when compiled?
10:28:25 <KirinDave> thoughtpolice: How do I correctly instruct the build to do that?
10:28:25 <chrisdone> isBEKaml: ski is relaxed, he's a teaching machine :p
10:28:31 <ian__> is it normal for compiled haskell programs to be so large?
10:28:32 <KirinDave> ian__: Static links
10:28:34 <Eduard_Munteanu> ian__: because of static linking
10:28:35 <chrisdone> ian__: that's all the ghc runtime among other stuff
10:28:45 <KirinDave> ian__: It is an island. It's like an uberjar.
10:28:50 <Eduard_Munteanu> You can try -dynamic (IIRC) to see the "actual" size.
10:28:53 <ski> chrisdone : hehe
10:29:00 <rwbarton> don't worry, your 2-line program won't be 1300kb
10:29:03 <Eduard_Munteanu> And maybe 'strip' it further.
10:29:04 <thoughtpolice> KirinDave: when you run 'make', instead say something like 'make -j8' - on my corei7, i have 4 cores, but 8 total hardware threads, so i normally set it to like 'make -j9' (one thread for I/O overlapping on the terminal)
10:29:14 <KirinDave> ian__: And honestly, this is probably a good state of affairs. Dynamic linking is an incredible buttpain in an operationalized context.
10:29:20 <KirinDave> thoughtpolice: Oh -j is okay?
10:29:24 <thoughtpolice> KirinDave: yep
10:29:27 <KirinDave> thoughtpolice: So few people take the time to make that work
10:29:43 <thoughtpolice> yeah, it's pretty much always there when I build GHC. it seriously makes it go soooooo much faster
10:30:16 <thoughtpolice> KirinDave: but if you're going to install 7.2.1 to use it, I'd say don't kill your build. BuildFlavor=quick means "do not build GHC itself with optimizations, but build optimized libraries" - but you probably want the resulting GHC to be optimized/as fast as possible
10:30:35 <thoughtpolice> the default is BuildFlavor=perf, which says "build GHC with full optimization", which naturally just takes a bit longer
10:30:45 <KirinDave> Well I suspect j8 will fix this problem
10:30:50 <thoughtpolice> yes, probably :)
10:30:59 <KirinDave> is "perl boot" still required? It's not mentioned on the other build pages
10:31:07 <thoughtpolice> KirinDave: not for a source distribution, no
10:31:09 <KirinDave> I do want profiling.
10:31:15 <thoughtpolice> you need to 'perl boot' if you're pulling from git however
10:31:22 <KirinDave> cool
10:31:27 <Eduard_Munteanu> I wouldn't expect Hyperthreading to give much in the sense of CPU throughput.
10:32:04 <thoughtpolice> Eduard_Munteanu: well, it makes my builds a hell of a lot faster, and activity monitor etc. on OS X report me as having 8 cores (even though i only have a quad i7)
10:32:07 <ian__> how large is the standard program compiled, say... 300 lines
10:32:22 <KirinDave> ian__: The curve goes up pretty slowly.
10:32:31 <isBEKaml> chrisdone: :P
10:32:31 <thoughtpolice> Eduard_Munteanu: i'd be willing to bench a GHC 'make -j4' vs 'make -j8' build however when i get home :)
10:32:33 <Eduard_Munteanu> ian__: dunno, a hello world is probably around 10KiB or so
10:32:53 <KirinDave> ian__: But for example my full-featured hakyll binary is 8mb.
10:33:03 <Ke> some applications actually give 200% throughput on HT
10:33:04 <Eduard_Munteanu> thoughtpolice: yeah I don't think it hurts though. Having a few more threads than actual cores is usually beneficial.
10:33:08 <Ke> almost
10:33:16 <Eduard_Munteanu> Since some may wait on I/O.
10:33:20 <KirinDave> Wow
10:33:23 <thoughtpolice> Eduard_Munteanu: oh yeah, definitely. even on a single core, actually doing at least 'make -j2' will normally net you speed increases
10:33:26 <isBEKaml> thoughtpolice: thanks for all the great info. I was hitting a bit of a lull in my haskell journey after some LYAH and RWH, looking for something to make things interesting. You obviously made that happen!
10:33:29 <KirinDave> I cannot see what is happening it's going by so fast.
10:33:39 <thoughtpolice> isBEKaml: just stay in #haskell :D
10:33:43 <Eduard_Munteanu> Ke: wasn't it meant for multimedia / interactive workloads?
10:33:45 <KirinDave> I've _never_ seen this laptop's load at 10.77
10:33:46 <thoughtpolice> KirinDave: yep
10:33:47 <KirinDave> Whee
10:33:55 <isBEKaml> thoughtpolice: no, no. it's a firehose! :P
10:34:14 <thoughtpolice> isBEKaml: coming to #haskell for a cup of water and ending up with the firehose isn't totally uncommon
10:34:14 <Ke> thus far some openssl on some intel cpu's and some floating point stuff has given almost 200%
10:34:17 <KirinDave> I'm actually almost done with a blog post writing about why people tend to have such a hard time learning haskell coming from the software industry.
10:34:17 <thoughtpolice> tbqh
10:34:27 <KirinDave> hoping I can run the draft by people who are here for commentary in a bit.
10:34:31 <ski> isBEKaml : you must stay so that we can trick you into using obscure abstractions from category theory
10:34:49 <KirinDave> It's not amazingly insightful, but I'm trying to a crowd that isn't traditionally receptive to anything but taligent-style OO derivative languages.
10:35:03 <isBEKaml> ski: and join a Ph.D programme to be Permanently head.Damaged. :D
10:35:14 <thoughtpolice> don't listen to ski! they're not obscure abstractions here, they're par for the course
10:35:17 <chrisdone> one day a newbie will come in here asking for something, and it will turn out that zygohistormorphic prepomorphisms will be exactly what they need
10:35:18 <isBEKaml> ski: no, thank you so much. ;)
10:35:23 <Eduard_Munteanu> KirinDave: a link would be nice, once you finish it.
10:35:42 <ski> isBEKaml : that's optional, but fully endorsed
10:35:49 <thoughtpolice> in fact i am consistently amazed that given i haven't written a paper on category theory or directly used them in my code, my haskell license has not been revoked
10:35:51 <KirinDave> Eduard_Munteanu: I need haskell to work before I can publish. Hakyll!
10:35:57 <Eduard_Munteanu> Oh, heh.
10:36:08 <KirinDave> Eduard_Munteanu: Actually I could just gist it I guess
10:36:11 <KirinDave> When i am done, I will
10:36:25 <chrisdone> thoughtpolice: expect a letter in the post
10:36:42 <parcs> ian__: a dynamically linked application is about 80kB and a statically linked one depends wholly on the libraries you use
10:36:43 <thoughtpolice> :(
10:37:22 <parcs> ian__: ~300 lines
10:37:26 <isBEKaml> chrisdone: I can understand that. I came in here the other day asking about folds and the discussion went into hylo, cata and ana. like hylo = cata . ana
10:37:33 <ian__> okay, thanks
10:38:03 <isBEKaml> chrisdone:  and I had to go, "folds and hylo is cata composed ana, duh"
10:38:11 <isBEKaml> :D
10:38:16 * ski . o O ( `catana = cata . ana' )
10:38:28 <chrisdone> these are all good names for projects
10:38:55 <Eduard_Munteanu> Katana sounds more like a KDE project, unfortunately :(
10:39:03 <thoughtpolice> gah
10:39:07 <thoughtpolice> ATS, Y U SO UGLY
10:39:19 * thoughtpolice doesn't know how to do the table flipping unicode-thing
10:39:34 * chrisdone waits for Cale to oblige
10:41:48 <TotoTitus> Seeing people talking here about interesting stuff is so refreshing; tomorrow i have to go to work and use some 'agile web platform' or something :(
10:41:55 <ski> another interesting library is <http://haskell.org/haskellwiki/Multiplate>
10:42:06 * ski still doesn't really understand that
10:42:59 * Eduard_Munteanu likes the bit about "Multiplate does not require GADTs and does not require multi-parameter type classes. It only requires rank 3 polymorphism."
10:43:08 <ski> i mean `mkPlate :: Multiplate p => (forall a. (forall f. p f -> a -> f a) -> a -> f a) -> p f' -- huh ? :)
10:43:51 <Cale> （╯°□°）╯︵ ┻━┻
10:44:01 <thoughtpolice> there it is!
10:44:15 <thoughtpolice> Cale++
10:44:51 <dmwit> ski: I read the paper, which made it clear as mud.
10:45:00 <dmwit> For a little while.
10:45:16 <dmwit> Now it's back to mud with oil mixed in.
10:45:18 <ski> oh, there's a paper too ?
10:45:33 * ski ought to have suspected that
10:46:14 <dmwit> http://arxiv.org/abs/1103.2841
10:47:18 <BMeph> App : paper :: iPhone : Haskell ? ;)
10:47:37 <dankna> what on earth is the relationship for that analogy?
10:48:01 <dmwit> dankna: roconnor's, or BMeph's?
10:48:10 <dankna> bmeph's.
10:48:27 <dankna> I don't see one by roconnor in scrollback.
10:48:47 <dmwit> Maybe he meant app : iPhone :: paper : Haskell
10:49:01 <dmwit> "there's a paper for that"
10:49:06 <dankna> well, analogies commute sorta :)
10:49:11 <zygoloid> ski: yeah, i've seen those. it's one of those things which sounds impossible but is sorta obvious in retrospect
10:49:29 <dmwit> Do they?
10:49:31 <dankna> but yeah, hm.  that's probably the best explanation.
10:49:32 <dmwit> Not really.
10:49:41 <Cale> a/b = c/d <=> a/c = b/d
10:49:48 <ski> .. what Cale said :)
10:50:03 <zygoloid> (like there being open subsets of the reals which contain all the rationals, with arbitrarily small measure on any finite interval)
10:50:22 <dankna> sure.  food : eating :: drink : drinking <=> food : drink :: eating : drinking
10:50:45 <dmwit> dankna: Also, as for your confusion about what roconnor's analogy is, it's in my link; Functor : Lens :: Applicative : Biplate
10:50:49 <dankna> oh, okay
10:50:53 <KirinDave> Even with ghc 7.2.1, I still get a huge number of ld warnings on compiles.
10:50:55 <KirinDave> I mean, a HUGE number.
10:51:17 <KirinDave> also
10:51:24 <KirinDave> Configuring Cabal-1.10.1.0...
10:51:24 <KirinDave> Setup: At least the following dependencies are missing:
10:51:24 <KirinDave> base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.5
10:51:32 <KirinDave> Anyone have any advice on how to solve this?
10:51:39 <luite> yeah ghc 7.2 has Cabal 1.12
10:51:43 <copumpkin> unix has a constraint that prevents it from building with 7.2.1
10:51:47 <copumpkin> you just raise that
10:51:51 <copumpkin> the PVP is annoying as hell
10:52:03 <dmwit> It can be, yeah.
10:52:23 <luite> I'd try to change the other packages' dependencies to build them with the newer cabal
10:52:29 <KirinDave> copumpkin: Not sure I know how to do what you're suggesting. Care to help me out here?
10:52:32 <c_wraith> just be like bindings-dsl, and say your package works with base <=10000
10:53:02 <Cale> IT'S OVER 9000
10:53:15 <dankna> sorry, the player versus player?  ?. oh, package versioning policy
10:53:18 <c_wraith> (given that bindings-dsl includes only a single empty module as its haskell portion, I question the need for a dependency on base at all...)
10:53:59 <dmwit> Just wait until the libraries folks decide to adopt Firefox's versioning policy, we'll beat 10,000 in no time.
10:54:02 <isBEKaml> c_wraith: maybe the author made themselves a plate of copy pasta? :)
10:54:15 <dmwit> (nyuk nyuk nyuk)
10:54:16 <thoughtpolice> copumpkin: ugh, yeah, it's annoying. the real thing is that nobody has taken the time to upload the newer GHC bootlibs to hackage :|
10:54:25 <thoughtpolice> i assume ian will get to this soon
10:54:29 <copumpkin> yeah :/
10:54:34 <copumpkin> but so much other stuff breaks too
10:54:35 <KirinDave> How might I go about fixing it temporarily?
10:54:43 <luite> KirinDave: why do you need Cabal?
10:54:56 <KirinDave> luite: Because development is pretty tedious without it?
10:54:56 <dmwit> KirinDave: "cabal unpack unix && cd unix-* && vim *.cabal"
10:55:05 <thoughtpolice> copumpkin: 7.2.1 is a technology preview ==> BREAK EVERYTHING
10:55:12 <luite> KirinDave: no I mean, the Cabal-1.10.1.0 library
10:55:13 <mizu_no_oto_> So, does anyone know much about how IO is really implemented?  Is "Imperative Functional Programming" a good paper to read to learn how ghc really does IO?
10:55:14 <dmwit> KirinDave: Then bump the dependency on base (I guess? not sure I understood copumpkin) and "cabal install".
10:55:15 <Saizan> KirinDave: you already have a Cabal library installed
10:55:26 <Saizan> KirinDave: are you trying to build cabal-install ?
10:55:28 <luite> KirinDave: gch already comes with Cabal, a newer version, you should try to use that
10:55:32 <copumpkin> thoughtpolice: well, it breaks because the PVP tells you to put a low upper bound on packages
10:55:36 <KirinDave> okay
10:55:46 <copumpkin> thoughtpolice: so whenever a new release comes out, everything breaks
10:55:50 <Cale> mizu_no_oto_: How it really does IO is that it cheats.
10:55:52 <c_wraith> mizu_no_oto_: if you want to know how IO is *implemented*, look at Lazy Functional State Threads.  Or Functional Lazy State Threads
10:56:06 <c_wraith> mizu_no_oto_: but that won't be very enlightening about how to work with it
10:56:16 <KirinDave> Saizan: Yes
10:56:19 <luite> KirinDave: if you're trying to build cabal-install, use the one from the darcs repository
10:56:20 <mwc> mizu_no_oto_: essentially, type IO a = ST RealWorld a
10:56:21 <Saizan> copumpkin: i don't think the PVP talks about that
10:56:24 <KirinDave> luite: Okay
10:56:50 <KirinDave> Head branch?
10:56:54 <Saizan> hackage enforces that for base though :)
10:56:58 <luite> yeah
10:57:08 <luite> at least that's what I use :p
10:57:12 <KirinDave> Okay
10:57:41 <Cale> mizu_no_oto_: It's essentially implemented as   data IO a = IO (Token -> (Token, a)), where the Token type doesn't actually have values and the functions which are used are allowed to have side effects unlike ordinary Haskell functions.
10:57:52 <Cale> mizu_no_oto_: (In GHC)
10:57:53 <luite> I tried to build the older version from hackage first, with modified dependencies, but that had an annoying problem
10:58:23 <Cale> mizu_no_oto_: This is basically a cheat to get GHC's existing dependency analysis to work on IO actions too
10:58:28 <luite> KirinDave: oh for the other packages with problems, I use a private hackage depository, to which I push my own versions of packages with minor patches or dependency changes
10:58:36 <Cale> mizu_no_oto_: It works, but there are better mental models
10:58:45 <luite> repository
10:58:48 <Saizan> i think the wise choice would be to not put information you're not sure about in .cabal files, but rather have cabal-install have a conservative mode where it won't try to use versions of deps that weren't there when the package was uploaded
10:58:55 <KirinDave> luite: That sounds pretty exciting.
10:59:02 <KirinDave> luite: If by "excitement" i mean "ugh."
10:59:14 <Saizan> and a less conservative mode that will bet on them working anyhow
10:59:15 <KirinDave> But if 7.2.1 really fixes the lion problems, then I am willing to go there.
10:59:17 <copumpkin> Saizan: "When publishing a Cabal package, you should ensure that your dependencies in the build-depends field are accurate. This means specifying not only lower bounds, but also upper bounds on every dependency.
10:59:17 <copumpkin> "
10:59:26 <copumpkin> Saizan: "At some point in the future, Hackage may refuse to accept packages that do not follow this convention. "
10:59:34 <KirinDave> copumpkin: That is a bummer of a policy.
10:59:40 <KirinDave> At least in this scenario
10:59:45 <Saizan> copumpkin: ok, i was wrong :)
10:59:59 <mwc> Well, as long as they follow the ABI/Versioning policy, you can at least predict the upper bound
11:00:07 <mwc> it's not a total catastrophe
11:00:25 <Cale> mizu_no_oto_: a better mental model in most cases is something like this:
11:00:26 <Saizan> ABI doesn't have much to do with this
11:00:30 <Cale> data IO a where
11:00:35 <Cale>   ReturnIO :: a -> IO a
11:00:43 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
11:00:54 <Cale>   GetChar :: IO Char
11:00:57 <luite> KirinDave: hehe, yes it really shouldn't be necessary, but it's easy to do. fixing a package takes less than a minute: cabal unpack packagename, cd packagename-version, edit cabal file (update deps, add minor version), publish (single command that generates an sdist and uplaods it), cabal update
11:00:58 <thoughtpolice> copumpkin: yeah, anything that GHC updates that people have an upper bound as a dependency on will break pretty much, since some of those old versions may not work with GHC for whatever reasons (although some might)
11:01:00 <Cale>   PutChar :: Char -> IO ()
11:01:06 <mwc> Saizan: yeah, I meant API
11:01:07 <Cale>   ... other IO primitives ...
11:01:11 <copumpkin> BindIO could be called CallbackIO for people more familiar with other languages
11:01:33 <thoughtpolice> copumpkin: disregard scumbag pvp policy, set base == 4.* :)
11:01:34 <Cale> mizu_no_oto_: and you can think of the runtime system as pattern matching on these values and carrying out the instructions they describe
11:01:37 <KirinDave> copumpkin: Nooooode.
11:01:39 <thoughtpolice> (among other things)
11:01:44 <luite> KirinDave: and after that, all my installs/platforms can use the fixed package, no more manual cabal installs from source dirs
11:01:50 <mokus> it would be nice if there were separate upper bounds for "not known to work with versions above this" vs "known not to work with versions above this", and a cabal-install option for "try it anyway" in the former case
11:01:58 <copumpkin> thoughtpolice: base < 100
11:02:00 <copumpkin> there, upper bound!
11:02:01 <copumpkin> yay
11:02:16 <thoughtpolice> i prefer the bindings-dsl approach, where the upper bound is totally over 9000
11:02:20 * ski kindof prefers the CPS version of what Cale did
11:02:32 <copumpkin> lol
11:02:55 <KirinDave> So the assertion that ghc-7.2.1 ends linker error spam on OSX Lion is false.
11:02:55 <Cale> Yeah, if you do it in CPS, then you could safely expose it to the user without breaking the monad laws.
11:02:56 <KirinDave> I can prove it.
11:03:02 <KirinDave> Because I am getting all the linker errors right now.
11:03:06 <ski> (so you get associativity for free)
11:03:16 <Saizan> mokus: right, and the "not known to work with versions above this" could actually be deduced from the upload dates
11:03:28 <copumpkin> ski: how do you mean?
11:03:41 <Cale> I just give the direct style because I think it's the easiest to understand right away
11:04:03 <mokus> Saizan: yea, even better - or could be inferred from the package list at time of 'cabal sdist'
11:04:46 <Saizan> mokus: that'd encourage too narrow version constraints imo
11:05:18 <thoughtpolice> KirinDave: submit a bug report then :) manuel was pretty sure he eliminated all the warnings (primarily the libffi weirdness, and the PIE linker weirdness)
11:05:53 <KirinDave> thoughtpolice: I will.
11:06:05 <mokus> Saizan: true
11:06:10 <KirinDave> I'll just look over the install instructions on the wiki again to make sure I didn't miss a step
11:06:22 <mwc> my kingdom for first class record labels.
11:06:33 <thoughtpolice> KirinDave: also, FWIW, on snow leopard I can confirm that the "_ffi_unix_call" goes away with GHC 7.2.1 and XCode 4.0
11:06:39 <ski> copumpkin : `data IOResult r = Result r | GetCharBind (Char -> Result r) | PutCharBind Char (Result r); type IO a = forall r. ContT r IOResult a'
11:06:42 <thoughtpolice> KirinDave: i haven't upgraded to lion yet, primarily for the exact reason of GHC :P
11:06:58 <copumpkin> ski: oh, fair enough
11:07:00 <thoughtpolice> KirinDave: I can't test the PIE one though, since that was a system wide change in lion
11:07:37 * thoughtpolice should probably upgrade to lion now
11:08:22 * ski wonders whether mizu_no_oto_ is still with us
11:12:21 * ski . o O ( "Parallel Parsing Processes", Koen Claessen, <http://hackage.haskell.org/packages/archive/Encode/1.3.4/doc/html/Parsek.html> )
11:13:08 <KirinDave> thoughtpolice: You can join us in the world of a non-functional ghci
11:13:29 * hackagebot text-format 0.3.0.5 - Text formatting  http://hackage.haskell.org/package/text-format-0.3.0.5 (BryanOSullivan)
11:13:42 <Axman6> ghci is working fine for me on lion :\
11:13:45 <EvanR7> drawing combinators seems cool, but how would a haskell game get input
11:15:33 <mizu_no_oto_> sorry, was AFK for a little bit
11:15:51 <dmwit> EvanR7: From one of the many window toolkits, I guess.
11:16:16 <dmwit> There are bindings to raw X11, gtk2, wxwindows, OpenGL, etc.
11:16:27 <EvanR7> well drawing combinators requires gl
11:17:26 <EvanR7> also opengl has no input (or window)
11:17:39 <dmwit> I don't know about the specific libraries you're trying to interface, but I do know gtk2 has a way to expose a DrawWindow backed by OpenGL, and I wouldn't be surprised if the other toolkits have something similar.
11:17:49 <EvanR7> Graphics.DrawingCombinators
11:18:02 <dmwit> There's GLUT, as well. No idea if there are Haskell bindings.
11:18:21 <EvanR7> yeah, seems like youd want an X11 window with gl
11:18:28 <EvanR7> to get events
11:18:37 <EvanR7> and reimplement that for each environment
11:18:38 <EvanR7> windows etc
11:18:46 <dmwit> Not me, personally. I'd much rather let gtk2 do all the work for me.
11:19:40 <EvanR7> what i dont understand is how the lib works at the gl level
11:19:55 <EvanR7> if you initialize gl from one of twelve other libs, it 'just works' ?
11:19:57 <cheater_> if i have a list l and functions f, g then how do i get  f l ++ g l ?
11:20:09 <cheater_> is there a better way than this?
11:20:19 <dmwit> That doesn't look bad to me.
11:20:37 <dmwit> You can do something like liftM2 (++) f g l, but it's kind of pointless.
11:20:48 <dmwit> Since that steps in one evaluation step to f l ++ g l anyway.
11:20:56 <dmwit> And f l ++ g l is significantly more readable.
11:21:00 <ski> .. or `(uncurry (++) . (f &&& g)) l'
11:21:21 <dmwit> ski: Yes, thank goodness.
11:21:35 <cheater_> hmm
11:21:41 <cheater_> liftM2: not in scope
11:21:44 <cheater_> how do i get that again?
11:21:47 <ski> @index liftM2
11:21:47 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:22:10 <dmwit> You'll probably need Control.Monad.Instances or Control.Monad.Reader, too.
11:22:19 <ski> you'll need the `instance Monad (rho ->)' for that
11:24:18 <Phyx-> ghc. you're killing me here
11:24:28 <cheater_> > liftM2 (++) head head "abcd"
11:24:29 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
11:24:29 <lambdabot>    arising from a use o...
11:24:39 <cheater_> don't work.
11:24:53 <Saizan> head has the wrong type
11:24:53 <ski> > liftM2 (++) tail tail "abcd"
11:24:54 <lambdabot>   "bcdbcd"
11:25:07 <cheater_> hm
11:25:16 <ski> > (liftM2 (++) `join` tail) "abcd"
11:25:18 <lambdabot>   "bcdbcd"
11:25:47 * Phyx- reeaaaally wishes he could hide instances
11:26:31 * Phyx- turns on OverlappingInstances and prays to the gods
11:26:42 <dmwit> cheater_: It works exactly as well as this (which is what you told us you wanted):
11:26:47 <dmwit> > head "abcd" ++ head "abcd"
11:26:48 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
11:26:48 <lambdabot>    arising from a use o...
11:27:10 <cheater_> hmm
11:27:13 <dmwit> It's not our fault that you didn't want what you said you wanted. =)
11:27:19 <dmwit> > [head "abcd", head "abcd"]
11:27:19 <lambdabot>   "aa"
11:27:20 <Phyx-> @pl \f g l-> f l ++ g l
11:27:21 <lambdabot> liftM2 (++)
11:27:22 <Phyx-> :P
11:27:32 <dmwit> > liftM2 (\x y -> [x, y]) head head "abcd"
11:27:33 <lambdabot>   "aa"
11:27:44 <cheater_> @hoogle a -> [a]
11:27:45 <lambdabot> Prelude repeat :: a -> [a]
11:27:45 <lambdabot> Data.List repeat :: a -> [a]
11:27:45 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
11:28:02 <ski>   return :: a -> [a]
11:28:07 <dmwit> > liftM2 (++) (return . head) (return . head) "abcd"
11:28:08 <lambdabot>   No instance for (GHC.Show.Show (m GHC.Types.Char))
11:28:08 <lambdabot>    arising from a use of...
11:28:15 <dmwit> > liftM2 (++) (return . head) (return . head) "abcd" :: String
11:28:17 <lambdabot>   "aa"
11:28:33 <dmwit> > join (liftM2 (++)) (return . head) "abcd" :: String
11:28:34 <lambdabot>   "aa"
11:28:35 <cheater_> interesting
11:28:43 <cheater_> what does join do?
11:28:49 <confab> :t join
11:28:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:28:54 <ski>   join :: Monad m => m (m a) -> m a
11:28:55 <dmwit> join = (>>= id)
11:29:07 <dmwit> For functions, join f x = f x x
11:29:08 <cheater_> i don't understand monads yet
11:29:10 <ski>   join :: (rho -> rho -> a) -> (rho -> a)
11:29:11 <cheater_> aha
11:29:13 <cheater_> ok
11:29:41 <ski> > f `join` x :: Expr
11:29:41 <lambdabot>   f x x
11:29:52 <confab> how does the hoogle work in channel?
11:29:56 <dmwit> ski: cute
11:30:08 <ski> @hoogle zipWith
11:30:09 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:30:09 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
11:30:09 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:30:13 <ski> @hoogle+
11:30:14 <lambdabot> Data.ByteString.Char8 zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
11:30:14 <lambdabot> Data.ByteString.Lazy zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
11:30:14 <lambdabot> Data.ByteString.Lazy.Char8 zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
11:30:17 <confab> k
11:30:20 <confab> @hoogle join
11:30:21 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
11:30:21 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
11:30:21 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
11:30:28 <ski> @index join
11:30:28 <confab> thanks
11:30:28 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
11:30:44 <confab> what does index do?
11:30:57 <ski> reports (some) modules the identifier is defined in
11:31:08 <confab> ah
11:31:10 <confab> cool
11:31:21 <ski> so if you ask "what module do i need to import", `index' is your friend
11:31:47 <ski> @help index
11:31:47 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
11:31:53 * ski nods
11:32:00 <confab> @help
11:32:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:32:08 <confab> @help list
11:32:08 <lambdabot> list [module|command]
11:32:08 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
11:32:23 <confab> hmm
11:32:25 <dmwit> ?list quote
11:32:25 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo nixon farber
11:32:28 <confab> that's a decent list of commands
11:32:35 <dmwit> ?nixon
11:32:36 <lambdabot> Finishing second in the Olympics gets you silver. Finishing second in politics gets you oblivion.
11:33:08 <parcs> what is the 'best' package that provides a Random monad transformer? the MonadRandom package doesn't have a MonadError instance on its transformer
11:33:31 <confab> ?ghc
11:33:31 <lambdabot> ghc says: Use -fglasgow-exts to allow multi-parameter classes
11:33:38 <confab> ?yow
11:33:38 <lambdabot> Couldn't find fortune file
11:33:46 <confab> ?fortune
11:33:46 <lambdabot> Couldn't find fortune file
11:34:10 <confab> ?yhjulwwiefzojcbxybbruweejw
11:34:11 <lambdabot> "\""
11:34:15 <parcs> also MonadRandom uses data type contexts
11:34:24 <confab> hmm
11:35:06 <dmwit> ?yhjulwwiefzojcbxybbruweejw
11:35:07 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
11:35:21 <confab> wait
11:35:26 <confab> why did you get a different one?
11:35:28 <ski> @v
11:35:28 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
11:35:35 <dmwit> confab: It likes me better.
11:35:44 <confab> weaksauce
11:35:49 <confab> ?yhjulwwiefzojcbxybbruweejw
11:35:49 <lambdabot> "\"#$%&'()*+,\""
11:35:52 <confab> oh
11:35:55 <confab> i get it
11:36:36 <ski> @keal
11:36:36 <lambdabot> lamadabot took 5 to 8 whole seconds to return []
11:36:53 <confab> @karma
11:36:54 <lambdabot> You have a karma of 0
11:37:01 <confab> @karma-all
11:37:01 <lambdabot>  "pmichaud"           1018
11:37:01 <lambdabot>  "moritz"              955
11:37:01 <lambdabot>  "C/C"                 634
11:37:01 <lambdabot>  "jnthn"               607
11:37:01 <lambdabot>  "lwall"               530
11:37:03 <lambdabot> [3576 @more lines]
11:37:07 <ski> hehe
11:37:26 <parcs> @more
11:37:26 <lambdabot>  "masak"               457
11:37:27 <lambdabot>  "pmurias"             404
11:37:27 <lambdabot>  "g"                   392
11:37:27 <lambdabot>  "Weed"                334
11:37:27 <lambdabot>  "("                   268
11:37:28 <lambdabot> [3571 @more lines]
11:37:37 <confab> @more 10
11:37:37 * ski wonders who pmichaud might be
11:37:37 <lambdabot>  "+"                   252
11:37:37 <lambdabot>  "br1"                 178
11:37:37 <lambdabot>  "colomon"             175
11:37:38 <lambdabot>  "ruoso"               164
11:37:40 <lambdabot>  "azawawi"             149
11:37:42 <lambdabot> [3566 @more lines]
11:37:52 <djahandarie> ski, someone from #perl I think.
11:38:02 <confab> @seen pmichaud
11:38:02 <preflex>  pmichaud was last seen on #perl6 2 years, 159 days, 19 hours, 28 minutes and 28 seconds ago, saying: anyway, gotta head off to soccer practice.  Back later.
11:38:02 <lambdabot> Unknown command, try @list
11:38:05 <dmwit> C/C++ makes me laugh
11:38:08 <ski> @karma dons
11:38:09 <lambdabot> dons has a karma of 14
11:38:12 <ski> @karma Cale
11:38:12 <lambdabot> Cale has a karma of 54
11:38:21 <dmwit> g++ and (++, too
11:38:22 <confab> dmwit: why's that?
11:38:37 <confab> @vixen
11:38:38 <lambdabot> Sex is the mysticism of materialism and the only possible religion in a materialistic society.
11:38:48 <confab> @vixen
11:38:48 <lambdabot> you remind me of that actor, whatshisname
11:38:51 <dmwit> confab: It's clear that nobody named C/C has a high karma, only that people often mention C/C++ and that gets parsed as increasing the karma for user C/C.
11:38:56 <dmwit> Which is mildly humorous.
11:39:07 <ski> @vixen How's the weather in Atlanta?
11:39:08 <lambdabot> let me answer that later, okay?
11:39:26 <c_wraith> @vixen how's the weather in cali?
11:39:26 <lambdabot> however you want
11:39:28 <dmwit> ?karma +
11:39:29 <lambdabot> + has a karma of 252
11:39:33 <confab> oh
11:39:35 <dmwit> > f +++ g
11:39:35 <lambdabot>   No instance for (GHC.Show.Show
11:39:36 <lambdabot>                     (a (Data.Either.Either b...
11:39:39 <dmwit> ?karma +
11:39:39 <lambdabot> + has a karma of 253
11:39:42 <c_wraith> yep
11:39:47 <confab> @karma c/c
11:39:47 <lambdabot> c/c has a karma of 636
11:39:49 <ski> @vixen a/s/l
11:39:49 <lambdabot> 19/f/California
11:39:53 <confab> c/c++
11:39:56 <confab> @karma c/c
11:39:56 <lambdabot> c/c has a karma of 637
11:39:56 <c_wraith> fortunately, +++ isn't as common as &&& or ***
11:40:05 <dmwit> yep
11:40:22 <confab> +++
11:40:26 <mwc> Poor ---
11:40:28 <confab> @karma +
11:40:28 <lambdabot> + has a karma of 255
11:40:31 <mwc> @karma -
11:40:31 <lambdabot> - has a karma of -1074
11:40:36 <confab> haha
11:40:43 <ski> haha
11:40:48 <dmwit> ------------
11:40:51 <dmwit> ?karma -
11:40:51 <lambdabot> - has a karma of -1074
11:41:02 <ski> @karma ----------
11:41:03 <lambdabot> ---------- has a karma of -20
11:41:04 <dmwit> ?karma ----------
11:41:05 <lambdabot> ---------- has a karma of -20
11:41:10 <dmwit> Ah, beat me to it.
11:41:11 <dmwit> ?karma --------
11:41:11 <lambdabot> -------- has a karma of -19
11:41:14 <dmwit> ?karma ------
11:41:14 <lambdabot> ------ has a karma of -9
11:41:16 <dmwit> ?karma ----
11:41:17 <lambdabot> ---- has a karma of -23
11:41:21 <dmwit> ?karma --
11:41:21 <lambdabot> -- has a karma of -147
11:41:29 <confab> is it one or two?
11:41:29 <mwc> you guys are sick.
11:41:44 <confab> oh, i guess two
11:41:47 <ski> mwc : ty :)
11:41:56 <cheater_> if i have a function in haskell, can i find an inverse function somehow?
11:41:58 <cheater_> given there is one
11:42:02 <confab> @unlambda
11:42:02 <lambdabot>   unlambda: Parse error at end of file
11:42:06 <dmwit> cheater_: Sometimes.
11:42:09 <cheater_> how?
11:42:09 <confab> @unlambda x
11:42:09 <lambdabot>   unlambda: Unknown operator 'x'
11:42:14 <ski> cheater_ : not algorithmically
11:42:18 <dmwit> cheater_: For example, if the domain and range are bounded and enumerable.
11:42:18 <confab> @help unlambda
11:42:19 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
11:42:27 <cheater_> why not, ski?
11:42:29 <confab> :t unlambda
11:42:30 <ski> cheater_ : in Mercury, you can sometimes get an inverse automatically
11:42:30 <lambdabot> Not in scope: `unlambda'
11:42:35 <cheater_> this should be possible for some subsets
11:42:37 <cheater_> at least
11:42:39 <confab> @hoogle unlambda
11:42:39 <lambdabot> No results found
11:42:48 <cheater_> ski, what's Mercury?
11:42:56 <ski> cheater_ : what's the inverse to `const () :: Bool -> ()' ?
11:42:58 <confab> @pretty
11:43:05 <cheater_> ski: if there isn't one, i don't want it
11:43:14 <cheater_> ski: i'm talking only about some well-defined subset
11:43:25 <cheater_> what is the inverse to f = (*) 2 ?
11:43:28 <dmwit> :t let invert f output = fromJust (lookup output [(f i, i) | i <- [minBound..maxBound]]) in invert
11:43:29 <confab> @babel
11:43:29 <lambdabot>   bzzt.
11:43:29 <lambdabot> forall a a1. (Eq a1, Enum a, Bounded a) => (a -> a1) -> a1 -> a
11:43:31 <cheater_> that's sort of obvious
11:43:47 <confab> okay, i'm done
11:44:01 <confab> wait
11:44:04 <ski> cheater_ : <http://www.mercury.csse.unimelb.edu.au/>, a Prolog-descendant which adds static types (and modes), plus function, also borrowing things in the type system (like type classes and polymorphism) from Haskell
11:44:04 <confab> @help undo
11:44:04 <lambdabot> undo <expr>
11:44:05 <lambdabot> Translate do notation to Monad operators.
11:44:06 <yitz> @karma google
11:44:07 <lambdabot> google has a karma of 2
11:44:10 <dmwit> cheater_: But, if you really want that kind of thing, it's traditional to write an Iso type that carries around both the function and its inverse, and some combinators for constructing them.
11:44:20 <dmwit> cheater_: Or, use lenses. ;-)
11:44:32 <dmwit> ?where impossible
11:44:32 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
11:44:38 <cheater_> how do lenses help here
11:44:38 <yitz> when google upgrades to the next version of their social networking, and give it the obvious name, they're going to get a lot of karma around here
11:44:39 <cheater_> ?
11:44:47 <ski> @babel la en id est
11:44:47 <dolio> (*)2 doesn't necessarily have an inverse either.
11:44:48 <lambdabot> Plugin `babel' failed with: Error: Language la not supported
11:44:51 <ski>  confab : ^
11:44:52 <dmwit> Sometimes you can even invert functions over unbounded domains. =)
11:44:59 <dmwit> (See the impossible program above. =)
11:45:02 <confab> ski: ?
11:45:09 <dmwit> cheater_: Lenses are a generalization of invertible functions.
11:45:11 <dolio> Or, I suppose it has a left inverse, but not necessarily a right inverse.
11:45:16 <confab> oh
11:45:21 <cheater_> dmwit, in what way are they generalized?
11:45:22 <confab> ski: translater?
11:45:26 <confab> translator*
11:45:32 <ski> confab : `babel' is (well, *was*) used to translate between different langauges, such as `la' (Latin)' and `en' (English)
11:45:41 <ski> confab : it doesn't work at the moment, though
11:45:55 <confab> @bable fr en je m'apple confab
11:45:55 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
11:45:58 <confab> bah
11:46:10 <dmwit> cheater_: Different lens formalisms generalize in different ways. The most common (for now) way is, rather than tracking isomorphisms between A and B, to track an isomorphism between A and (B, C), where B is the bit you're interested in and C is the some "left-over" information available in A but not B.
11:46:47 <confab> i gotta say, lambdabot is pretty interesting
11:46:49 <cheater_> ok so basically we're "keeping the information around"?
11:46:50 <confab> lambdabot++
11:46:54 <confab> @karma lambdabot
11:46:55 <lambdabot> lambdabot has a karma of 11
11:46:58 <confab> 11!
11:47:01 <confab> why so low?
11:47:04 <edwardk> preflex: xseen tibbe
11:47:04 <preflex>  tibbe was last seen on freenode/#ghc 6 hours, 12 minutes and 9 seconds ago, saying: ordering data types by frequencies seems to help
11:47:05 <dmwit> cheater_: yep
11:47:18 <edwardk> @tell tibbe i am disappoint. hashset is not hashable ;)
11:47:18 <lambdabot> Consider it noted.
11:47:32 <cheater_> dmwit, that's a fairly good idea. i like it. i've been considering something similar while at uni.
11:47:38 <ski> cheater_ : if you define e.g. `foo([]) = []. foo([X]) = [X]. foo([X0,X1|Xs]) = [X1,X0|Xs].', then you can get the inverse of foo/1 easily
11:48:06 <dmwit> cheater_: There's lots of similar ideas.
11:48:07 <cheater_> ski, what is foo/1 ?
11:48:08 <ski> cheater_ : namely as `inv_foo(Xs0) = Xs1 :- Xs0 = foo(Xs1).'
11:48:19 <ski> cheater_ : the function named `foo', with arity one
11:48:29 <yitz> @vixen confab says you're pretty interesting
11:48:29 <lambdabot> am i? i'm glad you think so at least
11:48:33 <cheater_> what does "with arity one" mean?
11:48:36 <dmwit> cheater_: (<- currently doing research in the area of bidirectional programming)
11:48:48 <dmwit> "arity one" means it takes one argument
11:48:54 <cheater_> ok
11:48:57 <ski> cheater_ : in Haskell, you'd write `foo [] = []; foo [x] = [x]; foo (x0:x1:xs) = x1:x0:xs'
11:49:03 <cheater_> so unary.
11:49:28 <dmwit> yes, but more smoothly generalizable -- e.g. what's the corresponding word for "arity 18"? ;-)
11:49:31 <cheater_> ski: yeah i understood the notation
11:49:46 <cheater_> decaoctory
11:49:53 <cheater_> no..
11:49:54 <dmwit> bleh
11:49:58 <cheater_> octoidecary
11:50:10 <ski> cheater_ : unfortunately `inv_foo xs0 = xs1 where foo xs0 = xs1' doesn't work in Haskell :)
11:50:13 <cheater_> something like that.
11:50:18 <cheater_> ski, aha
11:50:42 <ski> er, sorry, `inv_foo xs0 = xs1 where foo xs1 = xs0', rather
11:50:53 <dmwit> ski: You can solve that equation in exactly the same instances in Haskell as you can in Prolog (and I even gave the code above).
11:50:58 <cheater_> dmwit, i believe the guys at snap framework use lenses a lot. i think they're fond of them.
11:51:05 <dmwit> yep
11:51:13 <cheater_> maybe talk to them how they end up in practice
11:51:23 <cheater_> practical uses are often a good source of inspiration
11:51:30 <ski> dmwit : my `vgrep' fails to find that code ..
11:51:44 <dmwit> :t let invert f output = fromJust (lookup output [(f i, i) | i <- [minBound..maxBound]]) in invert
11:51:45 <lambdabot> forall a a1. (Eq a1, Enum a, Bounded a) => (a -> a1) -> a1 -> a
11:52:08 <dmwit> Instead of "no", you get an error from "fromJust". ;-)
11:52:10 <ski> dmwit : that's less general
11:52:25 <dmwit> Okay, I believe that.
11:52:34 <dmwit> I don't believe you can't write the more general version, though.
11:53:10 <dmwit> (Would you mind pointing out in what way it's less general, by the way?)
11:53:18 <ski> Mercury has language support for running functions (and predicates, of course) both forward and backwards
11:53:58 <ski> dmwit : the foo/1 example will work just fine for lists of functions, which aren't `Bounded' or `Enum'erable, in general
11:54:18 <ski> in comparision, Haskell only allows the forward mode for functions
11:54:37 <chrisdone> cheater_: i didn't notice that. do they use fclabels?
11:54:56 * dmwit nods
11:55:02 <ski> (of course, not all function implementations can be run backwards, so it's decided in each particular case which directions are possible)
11:55:14 <dmwit> Right. Cool.
11:55:47 <cheater_> chrisdone, no idea.
11:55:48 <mreh> i was playing braid and wondering how to do that using reversable functions
11:56:01 <chrisdone> i was pondering darcs's patch algebra and thought it reminded me of lenses, but lenses are overkill for the task
11:56:01 <cheater_> chrisdone, why not ask 'em?
11:56:36 <ski> (e.g. `bar([0,1,2] ++ Xs) = ..Xs..' is perfectly fine in Mercury, running `(++)' backwards)
11:56:52 <dmwit> ski: Actually, it probably wouldn't be too hard to write a function "invert_list :: (forall a. [a] -> [a]) -> (forall a. [a] -> [a])".
11:57:18 <mercury^> ski: what does it mean to run a functor backwards?
11:57:23 <mercury^> function*
11:57:26 <dmwit> Again, I recognize that this is not as general as what Mercury is doing.
11:57:27 <ski> dmwit : yeah, but you can't apply that to `[Nat -> Bool] -> [Nat -> Bool]' e.g.
11:57:36 <dmwit> Right.
11:57:37 <dmwit> I know.
11:57:47 <dmwit> But you can do a lot even in Haskell.
11:57:49 <ski> mercury^ : given `f' and `y' compute `x' such that `f x = y'
11:57:56 <chrisdone> mercury^: instead of deconstructing you construct, and vise versa
11:58:08 <ski> mercury^ : another way to look at it is allowing `f x' as a pattern
11:58:19 <mercury^> ski: that's an arbitrarily hard problem.
11:58:38 <dmwit> Yes it is.
11:58:38 <ski> mercury^ : yes. Mercury only solves it in a case-by-case basis
11:58:57 <dolio> Mercury just doesn't use functions as its basis for computation, really.
11:59:04 <dolio> It's based on arbitrary logical relations.
11:59:10 <ski> mercury^ : each function has one or more mode declarations which describes which modes of operation are possible
11:59:34 <dolio> With modes for each position of the relation.
12:00:11 <ski> yeah, like
12:00:26 <ski>   :- mode in ++ in = out is det.
12:00:34 <ski>   :- mode in ++ out = in is semidet.
12:00:39 <ski>   :- mode out ++ out = in is semidet.
12:01:03 <ski> er, should be `multi', not `semidet' in that last one
12:01:40 <cheater_> is there an opposite to the $ operator?
12:01:47 <ski> so if the two arguments are input, then the result will be output, and there's exactly one solution
12:01:53 <mreh> :t flip ($)
12:01:54 <lambdabot> forall a b. a -> (a -> b) -> b
12:01:54 <mercury^> cheater_: flip id
12:01:55 <dolio> Functions are only the special case where you have one (or more, I guess) input position, exactly one output, and the relation is deterministic.
12:02:03 <chrisdone> :t let reverse'Me (x:xs) = x : 1 : [] in let (n:1) = reverse'Me [5,6] in \xs -> x : xs
12:02:04 <lambdabot>     No instance for (Num [t])
12:02:04 <lambdabot>       arising from the literal `1' at <interactive>:1:45
12:02:05 <lambdabot>     Possible fix: add an instance declaration for (Num [t])
12:02:10 <ski> if the first argument and the result is input, then the second argument can be output, but that has at most one solution
12:02:32 <ski> and if the two arguments are to be output while the result is input, then you can get one or more solutions
12:02:35 <chrisdone> :t let reverse'Me (x:xs) = x : 1 : [] in let (n:1) = reverse'Me [5,6] in \xs -> n : xs
12:02:36 <lambdabot> forall t. (Num t, Num [t]) => [t] -> [t]
12:02:53 <cheater_> say i want (stuff) stuff2    -> stuff (someoperator) stuff 2
12:03:00 <rwbarton> does mercury "typecheck" these modes?
12:03:00 <cheater_> (stuff) stuff2    -> stuff (someoperator) stuff2
12:03:11 <ski> rwbarton : yes, it's called mode-checking
12:03:15 <chrisdone> ski: would you say that's an accurate reversal of the reverse'Me function?
12:03:22 <cheater_> sorry, this arrow isn't appriopriate
12:03:22 <rwbarton> makes sense :)
12:03:36 <cheater_> i think i want (stuff) stuff2  <=> stuff (someoperator) stuff2
12:03:46 <cheater_> flip ($) isn't it, is it?
12:03:48 <ski> rwbarton : the compiler knows at each instant how much instantiated each datum is
12:04:09 <ski> rwbarton : the same code for a predicate/relation generates different compiled code for each mode, for efficiency
12:04:31 <cheater_> i still want stuff to be the function and stuff2 to be the parameter
12:04:35 <cheater_> or argument
12:05:15 <ski> chrisdone : i assume you mean something like `\(x:1:[]) -> x:undefined' ?
12:05:22 <elliott> Is there any tool that gives a number of packages that depend on a named Hackage package? it would be nice to help decide between competing libraries
12:05:47 <ski> (chrisdone : i'm not really following your code there, after the first `let')
12:05:51 <chrisdone> ski: well, i thought with undefined it's kinda broken, at least with \xs -> n:xs it works
12:05:52 <cheater_> i can already see it
12:05:55 <cheater_> dependency spammers
12:06:25 <elliott> I seem to recall hearing about such a thing but I don't know if it still exists in any sort of compileable form.
12:07:10 <ski> chrisdone : well, with `foo (x:_) = x : 1 : []', `foo' is not injective. in Mercury i think you could get the reversal to return `x:_', given `x:1:[]' (where `_' is not instantiated yet, so is allowed to be anything)
12:07:45 <ski> chrisdone : but maybe you should explain what you meant by the `let (n:1) = reverse'Me [5,6] in \xs -> n : xs' part, since i don't follow what you're trying to do there
12:08:45 <ski> elliott : <http://hackage.haskell.org/trac/hackage/ticket/576>
12:09:26 <chrisdone> > let foo (n:xs) = n : 1 : xs; reverse_foo (n:1:xs) = n : xs in reverse_foo (foo [1,2,3]) -- so here's a total reversal by changing deconstructions (patterns) to constructors, and vise versa
12:09:27 <lambdabot>   [1,2,3]
12:09:43 <elliott> ski: well, OK. I was thinking something that runs locally as a stopgap
12:10:15 <chrisdone> for foo (n:_) = n : 1 : [], i thought a good way around it would be reverse_foo (n:1:[]) = \xs -> n : xs, otherwise, i guess it can't be reversed totally
12:11:11 <chrisdone> i guess it only works on injectives huh?
12:11:40 <ski> `reverse_foo (n:1:[]) = \xs -> n : xs' would have the wrong type
12:11:52 <chrisdone> ok
12:12:06 <ski> with relations/predicates in Mercury, it wouldn't have to be injective
12:12:50 <ski> it's just that the reversal of a non-injective function, seen as a relation, is not deterministic/functional
12:17:06 <ski> rwbarton : <http://www.mercury.csse.unimelb.edu.au/information/papers.html> has lots of interesting papers
12:17:51 <luite> what's the best way to download all versions of all packages from hackage?
12:37:35 <hpaste> dfhgdfgh pasted “sdryjyrdjs” at http://hpaste.org/50187
12:39:44 <dylukes> @hoogle [(a,b)] -> ([a], [b])
12:39:44 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
12:39:45 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
12:40:22 <tulcod> bah, why doesn't case [2,2] of b:[b] -> b work :(
12:42:02 <ocharles> Gr, I was hoping I could figure this out on my own but I'm stuck. If I have: m [a], and I want to get to m [b], how can I do that? I'm looking for something that's (a -> m b) -> m [a] -> m [b], but hoogle doesn't show anything
12:42:14 <ocharles> I've tried poking around with mapM and sequence, but not quite got there
12:42:27 <dmwit> tulcod: case [2,2] of b:[c] | b == c -> b
12:42:36 <ski> tulcod : only affine patterns allowed
12:42:54 <ski> (each variable name mentioned at most once in the pattern)
12:42:58 <tulcod> bah
12:43:05 <tulcod> i'm switching back to prolog then
12:43:07 <dmwit> ocharles: Let's do it bit by bit.
12:43:15 <ocharles> that sounds good to me :)
12:43:19 <ski> tulcod : hehe, you might like Mercury or Erlang, as well
12:43:43 <tulcod> actually looked into erlang
12:43:48 <tulcod> it's a bit too much typing work
12:43:58 <ski> too much typing ?
12:44:00 <tulcod> yeah
12:44:04 <bragh> haha, i just had a moment of enlightenment when i realized that list comprehensions are pretty damn similar to SELECT in SQL.
12:44:08 <dmwit> ocharles: Let's assume (f :: a -> m b) and (mlista :: m [a]), just to have concrete names to use when talking.
12:44:12 <ski> tulcod : what is too much typing ?
12:44:14 <tulcod> erlang
12:44:21 <tulcod> there are no dense notations
12:44:34 <tulcod> no smart list stuffs
12:44:36 <ski> oh, you mean `fun blah -> bloh end' ?
12:44:39 <ocharles> dmwit: ok, with you there
12:44:52 <dmwit> ocharles: (sorry, got distracted for a second)
12:44:57 <ocharles> no rush
12:45:01 <tulcod> ski: dense notation like prolog, haskell, or even python for that matter
12:45:20 <ski> @type (=<<) . mapM
12:45:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m [a] -> m [b]
12:45:21 <dmwit> ocharles: Okay, so we'll probably want to operate on a blank [a] thing instead of an m [a], so let's start with that:
12:45:30 <dmwit> ski: hush
12:45:31 <ocharles> yep, I thought fmap for that
12:45:39 <ocharles> don't worry, I haven't read any spoilers:)
12:45:42 <dmwit> ocharles: great! let's start with fmap
12:45:52 <dmwit> ocharles: fmap (???) mlista
12:45:56 <ocharles> yep
12:46:13 <dmwit> ocharles: The simplest thing we can put in fmap is (map f).
12:46:16 <dmwit> ocharles: So then
12:46:19 <ocharles> so now we can map the input to that, to get [m b]
12:46:25 <ocharles> right
12:46:32 <dmwit> fmap (map f) mlista :: m [m b]
12:46:33 <ski> tulcod : i'm wondering which things in Erlang you think are non-denser than corresponding in Haskell and Prolog ..
12:46:45 <ocharles> dmwit: right, this is where I'm stuck
12:46:48 <dmwit> ocharles: Cool. Now it looks like we're a bit stuck, but we're not.
12:46:52 <dmwit> ocharles: We're saved by (>>=).
12:46:53 <ski> @type sequence
12:46:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:46:54 <ocharles> I thought squence, but then we get m (m b)
12:46:58 <tulcod> ski: well maybe i'm wrong. i looked into it some time ago and didn't like it back then
12:47:00 * ocharles listens
12:47:05 <ski> @type join
12:47:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:47:07 <tulcod> ski: it's good for phone companies, i guess, and htat's about it :P
12:47:18 <ocharles> :t (>>=)
12:47:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:47:40 <dmwit> ocharles: (>>=) :: Monad m => m [m b] -> ([m b] -> m [b]) -> m [b]
12:47:42 <ski> tulcod : anonymous functions are a little clumsy in Erlang -- i just wondered which things you had in mind above
12:47:43 <mreh> it gives you load of expressive ways of recovering from errors, haskell gives you a load of expressive ways of avoiding them, that's what someone told me
12:47:56 <ocharles> ooo
12:48:20 <dmwit> ocharles: I guess you can see what function has the type we need for the second argument, right?
12:48:22 <ocharles> so  I want (>>= sequence)
12:48:26 <dmwit> right!
12:48:33 <dmwit> fmap (map f) mlista >>= sequence
12:48:38 <dmwit> ocharles: Now, we're not done.
12:48:38 <tulcod> ski: in prolog and python, there are loads of nifty ways to do basically everything. yeah, anonymous functions are one, lambda notation in python is great, as well as its simple to use classes
12:48:39 <ocharles> ahhhhh!
12:48:42 <dmwit> ocharles: We can simplify a lot.
12:48:43 <luite> what's the nicest way (least load to server/traffic) to download all package versions for all packages from hackage?
12:48:43 <ski> @type fmap sequence (fmap (map ?f) ?mlista)
12:48:44 <lambdabot> forall (m :: * -> *) a a1 (f :: * -> *). (Monad m, ?f::a1 -> m a, ?mlista::f [a1], Functor f) => f (m [a])
12:48:45 <ocharles> I was trying to sequence inside that function
12:48:52 <ski> @type liftM sequence (fmap (map ?f) ?mlista)
12:48:53 <lambdabot> forall (m :: * -> *) a a1 (m1 :: * -> *). (Monad m, ?f::a1 -> m a, ?mlista::m1 [a1], Functor m1, Monad m1) => m1 (m [a])
12:48:57 <ski> @type join (liftM sequence (fmap (map ?f) ?mlista))
12:48:57 <ocharles> (the fmap function)
12:48:57 <lambdabot> forall (m :: * -> *) a a1. (Monad m, ?f::a1 -> m a, ?mlista::m [a1], Functor m) => m [a]
12:49:12 <mreh> luite: it might be faster to have it fedexed
12:49:29 <luite> mreh: shouldn't be more than a few gigabyte, I hope
12:49:57 <dmwit> ocharles: Now, fmap f x >>= g === x >>= g . f
12:50:12 <dmwit> ocharles: So, fmap (map f) mlista >>= sequence === mlista >>= sequence . map f
12:50:18 <ski> tulcod : i don't know Erlang that well, but i'd expect they have some share of nifty tricks as well
12:50:23 * ocharles parses
12:50:45 <tulcod> ski: hm well i might have missed them. but i suppose haskell is the True Language anyway, so don't bother ;)
12:51:01 * ski hands dmwit a simple `='
12:51:08 <ocharles> ok, that fmap identity makes sense yea
12:51:12 <ocharles> on to the next line
12:51:25 <ocharles> it all seems so simple now :)
12:51:30 <dmwit> ocharles: And we've got a handy function mapM f = sequence . map f, so mlista >>= sequence . map f === mlista >>= mapM f
12:51:55 <ocharles> oh.. of course
12:52:11 <ocharles> I might have go to that if I wrote what I was doing with 2 separate lines in do notation and then removing the sugar
12:52:11 <dmwit> ski: I'm trying to differentiate between Haskell's "definition" syntax =, Haskell's "decide equality" function ==, and identities ===.
12:52:13 <mreh> i keep saying mlista in an italian accent
12:52:16 <mreh> in my mind
12:52:22 <ocharles> but I've much prefered working from first principles here
12:53:03 * ski thinks Haskells "definition" syntax `=' is a special case of "identities"
12:53:16 <ski> (also "identities" is just equalities)
12:53:30 <dmwit> s/identities/laws/ maybe
12:53:38 <mreh> sequence (mx:mxs) = liftM2 (:) mx mxs
12:53:41 <luite> mreh: I think I'll just download all packages with http then
12:53:54 <dmwit> They're not definitely true, it's just that we've got a convention that we don't make definitions that violate them.
12:54:18 <mreh> luite: how do you collect all the links?
12:54:25 <mreh> oh, the homepage
12:54:29 <luite> mreh: 00-index.tar.gz for all package versions
12:54:42 <luite> that's the same index that cabal update downloads
12:54:47 <ski>   sequence = foldr (liftM2 (:)) (return [])
12:54:49 <mreh> oh, I didn't know that
12:55:07 <ski>   transpose = foldr (zipWith (:)) (repeat [])
12:55:45 <mustelo> mreh,  your sequence definition doesn't have the right type...
12:55:50 <mreh> i know :)
12:56:26 <dmwit> sequence (mx:mxs) = liftM2 (:) mx (sequence mxs)
12:56:34 <mreh> thank you
12:57:03 <mreh> i realised when ski expressed it as a foldr
12:57:30 <copumpkin> > let transpose = ala ZipList Data.Traversable.traverse [[1,2,3],[4,5,6],[7,8,9]]
12:57:31 <lambdabot>   not an expression: `let transpose = ala ZipList Data.Traversable.traverse [...
12:57:38 <copumpkin> > ala ZipList Data.Traversable.traverse [[1,2,3],[4,5,6],[7,8,9]]
12:57:39 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
12:57:42 <ski> > (getZipList . Data.Traversable.sequenceA . map ZipList) [[0,1],[2,3]]
12:57:43 <lambdabot>   [[0,2],[1,3]]
12:58:06 <mreh> my mind hurts
12:58:17 <ski> that's a good sign :)
12:58:56 <mreh> what are you traversing with?
12:59:04 <mreh> :t Data.Traversable.traverse
12:59:05 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:59:35 <ski> @type Data.Traversable.traverse `asTypeIn` \traverse -> ala ZipList traverse [[1,2,3],[4,5,6],[7,8,9]]
12:59:36 <mreh> i'm tight with ala
12:59:36 <lambdabot> forall b. (Num b) => ([b] -> ZipList b) -> [[b]] -> ZipList [b]
13:00:12 <mreh> huh
13:00:30 <copumpkin> :t ala ZipList
13:00:31 <lambdabot> forall a b n' o'. (Newtype n' o') => (([a] -> ZipList a) -> b -> n') -> b -> o'
13:00:32 <ski> @type Data.Traversable.sequenceA `asTypeIn` \sequenceA -> (getZipList . sequenceA . map ZipList) [[0,1],[2,3]]
13:00:32 <lambdabot> forall a. (Num a) => [ZipList a] -> ZipList [a]
13:00:42 <ion> :t asTypeIn
13:00:43 <lambdabot> forall a b. a -> (a -> b) -> a
13:01:58 <ski> `asTypeIn' is a trick to easily see the exact type used for some subexpression in some expression
13:02:02 <dmwit> asTypeIn looks like a handy innovation to have available in ghci
13:02:17 * ski invented it some while ago
13:02:28 <mreh> three cheers for ski
13:02:32 <mustelo> how does it work?
13:02:41 <ski> @src asTypeIn
13:02:42 <lambdabot> a `asTypeIn` f = a where _ = f a
13:02:42 <lambdabot> infixl 0 `asTypeIn`
13:02:48 <dmwit> asTypeIn = const
13:02:50 <mreh> i thought i was tight with newtype...
13:02:56 <ski> it's comparable to `asTypeOf'
13:02:59 <ski> @src asTypeOf
13:02:59 <lambdabot> asTypeOf = const
13:03:15 <ski> (i.e. the magic is in the type signature)
13:03:25 <mustelo> I see, cool
13:03:53 <dmwit> where _ = f a is a cute way to restrict the type without actually writing a type signature
13:03:59 <dmwit> asTypeIn is just cute all around
13:04:00 <mreh> so the type system infers f
13:04:01 <dmwit> ski++
13:04:07 * ski beams
13:04:12 <ion> :t (<*>) `asTypeIn` \(<*>) -> (+) <*> succ
13:04:13 <lambdabot> forall b. (Num b, Enum b) => (b -> b -> b) -> (b -> b) -> b -> b
13:04:33 <ion> :t (<*>) `asTypeIn` \(<*>) -> (<*>) (undefined :: a -> b -> c)
13:04:34 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
13:04:36 <mustelo> I really like that.
13:04:58 <ion> :t (<*>) `asTypeIn` ($ (undefined :: a -> b -> c))
13:04:59 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
13:05:11 <ion> Awesome
13:06:02 <ski> i suppose you can also use `asTypeIn' in similar circumstances that you use `asTypeOf' in, i.e. passing around `undefined's of various types
13:06:06 <ion> :t (>>=) `asTypeIn` ($ getLine)
13:06:07 <lambdabot> forall b. IO String -> (String -> IO b) -> IO b
13:06:50 <mreh> does seem useful for debugging
13:07:31 <ski> (so if you want to get an `undefined' the same type as the argument to `f', you do  undefined `asTypeIn` f  instead of having to do explicit tricks like `_ = f a' above)
13:08:34 * hackagebot spreadsheet 0.1.1.1 - Read and write spreadsheets from and to CSV files in a lazy way  http://hackage.haskell.org/package/spreadsheet-0.1.1.1 (HenningThielemann)
13:09:50 <mustelo> is there a list of cool stuff like asTypeIn that lambdabot uses?
13:09:55 <mreh> Henning your type convention makes me = T_T
13:10:35 <ion> If you are equal to T_T, T_T is equal to you.
13:11:07 <mreh> me :: T_T
13:11:12 <mreh> better?
13:11:32 <ion> mreh :: T_T a => a
13:12:02 <ski> mustelo : <http://code.haskell.org/lambdabot/State/L.hs> ?
13:12:09 <mustelo> woot
13:13:02 <Cale> mreh: I've actually considered writing a program to try to automatically undo the damage that Henning Thielemann does to his types and classes, but I got somewhat stuck on the fact that Haskell imports can in general be quite complicated.
13:13:31 <roconnor> ski: mkPlate is much easier to use than its type appears.
13:14:29 <ion> :t (>>=) `asAppliedTo` (undefined :: IO a)
13:14:30 <lambdabot> forall a b. IO a -> (a -> IO b) -> IO b
13:14:33 <ion> nice
13:14:51 <ski> regardless of Henning.T's style, i think haddock ought to explain better where the external identifiers used come from, c.f. lazy and strict `ByteString's, e.g.
13:15:30 <ski> roconnor : yeah, the examples don't look so complicated. i'm wanting to understand the generality of the type
13:17:00 <illissius> so. question. is there any way to make this work? http://pastebin.com/rgVk6EPS I'm trying to come up with words to explain it but am failing, hopefully the code is clear enough.
13:17:05 <ski> (the examples at <http://haskell.org/haskellwiki/Multiplate>, i mean)
13:17:06 <mauke> The paste rgVk6EPS has been copied to http://www.ideone.com/mrEdN
13:17:37 <luite> why ideone now, hpaste not ok anymore?
13:17:42 <ski> mauke : i think `hpaste.org' is up now
13:18:30 <mreh> Cale: :)
13:18:35 * hackagebot uniplate 1.6.1 - Help writing simple, concise and fast generic operations.  http://hackage.haskell.org/package/uniplate-1.6.1 (NeilMitchell)
13:18:56 <roconnor> ski: I really need to expand that tutorial page
13:19:00 <hpaste> illissius pasted “http://pastebin.com/rgVk6EPS” at http://hpaste.org/50190
13:19:00 <mauke> The paste rgVk6EPS has been copied to http://www.ideone.com/mrEdN
13:19:12 * ski impersonates illissius
13:19:32 <ski> mauke : hahaha :)
13:20:07 <mauke> note that it's the same url
13:20:26 <ski> ah, nice
13:20:26 <Efie> i followed these steps: http://projects.haskell.org/gtk2hs/archives/2005/06/24/installing-on-windows/  with version 6.6.1 but when i try for example "ghc –make Noughty.hs" it still says " Could not find module `Graphics.UI.Gtk’:". one user reportet this in the comments below too (it know works for him), but for me it doesnt :| does anyone have an idea?
13:20:40 <Efie> now*
13:21:07 <illissius> ski: if you want to understand the generality of it, probably read the paper, it's fairly mind-expanding. unfortunately I did it the other way around and read the paper first, and didn't manage to get too much out of it beyond "woah", and only then looked at the examples to figure out what you can actually use it for. so now that I have a chance of understanding it I'll have to go back and read the paper again at some point.
13:21:22 * ski didn't recall `a -> b s' was allowed
13:21:52 <ski> illissius : just to make sure, you're talking about multiplate, yes ?
13:21:57 <illissius> yes
13:22:36 <roconnor> augustuss is right; in ocaml I have to fuse everything by hand.  What a pain.
13:23:18 <illissius> I have a half-started multiplate-th package sitting around among the billion other things I should finish.
13:23:47 <roconnor> illissius: using template haskell to generate plates and multiplate instances?
13:24:24 <illissius> roconnor: using template haskell to generate plates+instances on the one hand, and plates and instances for Language.Haskell.TH on the other.
13:24:49 <ski> roconnor : augustss is right where ?
13:24:50 <illissius> (the plural may or may not be appropriate)
13:25:09 <roconnor> illissius: woah.  That's even more impressive than I had imagined.
13:26:07 <newsham> whats a good way to limit the size of quickcheck tests?
13:26:12 <roconnor> ski: http://augustss.blogspot.com/2011/05/more-points-for-lazy-evaluation-in.html -- under "reuse"
13:26:19 <illissius> roconnor: well. it's only half-started, as I said. and once you have the TH (which I don't) it's fairly trivial to generate the other hand using it.. :)
13:26:26 <newsham> ie. when using large values for certain args is too slow
13:26:48 <ion> newsham: What kind of values? Integers? Lists?
13:26:54 <newsham> Integers in my case.
13:27:24 <newsham> like say you want to test that power function for peano numbers behaves like (^).
13:27:25 <ion> > let f (min 42 -> x) = x in map f [0,10..100]
13:27:26 <lambdabot>   [0,10,20,30,40,42,42,42,42,42,42]
13:27:58 <roconnor> Endo is like the Codensity for monoids!
13:28:11 <roconnor> it even turns things that are not monoids into monoids!
13:28:25 <ion> For lists, simply use «take n».
13:28:26 <illissius> (unfortunately I initially wanted to go the other way around and wrote a long-ass boilerplate plate+instance for L.H.TH, and started writing the autogenerating TH code using it, but then realized that if I want to be able to easily generate plates/instances for multiple different versions of TH I should use plain TH for the generating.
13:28:30 <illissius> )
13:29:47 <newsham> so you recommend explicitely using "max" in the quickcheck properties?
13:30:50 <tulcod> a tutorial here gives the example "let take (x:xs) = x : skip xs". do the parentheses () simply indicate "order of interpretation", like they're used in arithmetic expressions in most languages?
13:31:10 <ion> newsham: Well, min in this case. Why not?
13:31:51 <ion> tulcod: take x:xs would be parsed as (take x):(xs) because the space binds tighter than the colon.
13:31:56 <newsham> wait..  "let f (min 42 -> x) = x"   hmm.. thats new to me.
13:32:09 <newsham> where can I read about that construct?
13:32:12 <roconnor> newsham: pattern views
13:32:19 <tulcod> ion: ah, now that makes it very clear indeed!
13:32:19 <roconnor> or veiw patterns
13:32:22 <ion> > let f x = x' where { x' = min 42 x } in map f [0,10..100]
13:32:23 <lambdabot>   [0,10,20,30,40,42,42,42,42,42,42]
13:32:25 <roconnor> *view
13:32:31 <ion> The ViewPatterns extension.
13:32:45 <newsham> danke
13:33:06 <roconnor> newsham: they are quite nice; though that is a little bit of an usual use for them.
13:33:11 <ion> > let f (take 10 -> xs) = xs in f [0..]
13:33:12 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
13:33:24 <roconnor> newsham: although not inapporpriate either.
13:34:29 <roconnor> newsham: I use them with my colour library as in foo (hslView -> (hue, saturation, lightness)) = ...
13:35:18 <newsham> not sure how i feel about this yet.  seems useful but also potentially confusing.
13:35:22 <roconnor> this results in foo :: RGB  -> ...
13:35:26 <newsham> i mean.. more unusual syntax.
13:35:36 <Peaker> https://plus.google.com/107890464054636586545/posts/LqgXK77FgfV <-- Simon Marlow says stack is allocate din 32k chunks. Does this mean every forkIO costs 32k?
13:35:41 <roconnor> newsham: ya ... I sort of agree.  Just pretend you are reading Epigram
13:35:42 <ion> No need to use them if you don’t want to.
13:35:53 <newsham> sorry, i dont read epigram :)
13:35:57 <roconnor> :)
13:36:40 <tibbe> edwardk1: I guess we can make HashSet hashable
13:36:48 <roconnor> newsham: often I take a parameter called x and then define x' = bar x in a where clause and then proceed to use x' everywhere.
13:37:01 <tibbe> edwardk1: I've spent the day finishing up the next big release of unordered-containers, will finish during CamHac
13:37:04 <roconnor> newsham: except when I forget a ' and then I get a bug in my program and I never notice it. :(
13:37:28 <roconnor> newsham: viewpatterns are nice because the x variable never appears and cannot accidentally be used.
13:37:47 <newsham> roconnor: sounds like something you could fix with scoping
13:37:58 <ion> Well, you could use «f x' = blah x blah where { x = foo x' }» instead.
13:38:26 <newsham> func = func' . bar
13:38:29 <roconnor> ion: ya maybe that would be better; though not as good as removing x' entirely.
13:38:34 * hackagebot MonadCatchIO-mtl 0.3.0.4 - Monad-transformer version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-mtl-0.3.0.4 (DanielGorin)
13:39:01 <roconnor> newsham: once get get several parameters, point free starts getting a  bit messy.
13:39:30 <ion> Or «f x' = go (foo x') where { go x = blah x blah }»
13:39:34 <Peaker> It's supposed to be OK to create even millions of forkIO'd threads, right?
13:39:41 <ion> to put the foo near the start
13:39:42 <Peaker> In that case I'd expect each to take less than 4KB of stack, even..
13:39:53 <ion> But yeah, i’d just go with ViewPatterns.
13:40:04 <newsham> does each forkIO get a stack?
13:40:23 * roconnor never remembers the difference between forkIO and forkOS
13:40:39 <dolio> Peaker: Initial stack size is a different parameter.
13:40:46 <dolio> 1k default.
13:40:59 <Peaker> dolio: so only the 2nd chunk is 32K?
13:41:07 <dolio> Presumably.
13:41:43 <illissius> roconnor: forkOS ensures all foreign calls happen from the same OS thread, afaik.
13:42:13 <kmc> correct
13:42:34 <kmc> it doesn't have any bearing on where your Haskell code executes
13:42:52 <Peaker> so the thread-local-storage is guaranteed to behave consistently in a forkOS's thread, basically?
13:43:05 <kmc> poorly named imo
13:43:17 <Peaker> forkPinnedThread?
13:43:25 * Eduard_Munteanu thinks 1 KiB is a bit expensive anyway
13:43:26 <illissius> that would be even worse :)
13:43:27 <kmc> they're called "bound threads" in general
13:43:34 <Peaker> forkBound then, I guess
13:44:12 <dolio> Yes, I need more than 8 million threads.
13:44:14 <illissius> pinning execution to a particular CPU core is forkOnIO
13:44:20 <Peaker> dolio: what?
13:44:36 <kmc> why does forkOS need to exist?  what's wrong with forkIO . runInBoundThread
13:44:45 <dolio> > 8 * (1024*1024*1024) `div` 1024
13:44:46 <lambdabot>   8388608
13:46:08 <efie> many tutorials lead to http://www.gtk.org/download-windows.html - it does not work, does anybody know the correct link?
13:46:16 <dolio> I have 8 gigabytes of memory, which is 8 million threads at the initial stack size, roughly.
13:46:24 <efie> i for example as at http://aadamov.wordpress.com/2010/12/11/gtk2hs-installation-under-windows-and-haskellgui-programming-with-gtk2hs/
13:46:27 <Eduard_Munteanu> Heh.
13:46:47 <shachaf> kmc: runInBoundThread creates an additional bound thread for the purposes of running the computation.
13:48:47 <coppro>  /win 113
13:49:13 <ion> /lose 114
13:50:32 <hpaste> int80_h pasted “puzzling over this signal handling code” at http://hpaste.org/50191
13:51:24 <shachaf> int80_h: That's SIGUSR1
13:51:41 <totonex> I have a rather self-centric desire; i have some questions about Haskell, would anyone knowledgeable and willing spare some minutes? Thank you
13:51:47 * shachaf isn't sure why GHC people decided to rename all these signals with perfectly-valid anmes.
13:51:55 <shachaf> totonex: Only if you ask your questions!
13:52:21 <totonex> the thing is, there is soup in my head right now, and i would not like to pollute the global channel :)
13:52:33 <shachaf> The global channel is mostly fine with it.
13:52:41 <shachaf> If they're particularly long you can @paste them.
13:52:56 <parcs> why is forkOS named forkOS? it's like, misleading and stuff
13:52:56 <Eduard_Munteanu> totonex: you're not polluting at all, feel free to ask
13:53:02 <int80_h> chachaf: I just figured that out ust now. Yeah why not use the terms that are already there?!
13:53:13 <int80_h> shachaf: I just figured that out ust now. Yeah why not use the terms that are already there?!
13:53:17 <Eduard_Munteanu> Heh.
13:53:35 * hackagebot dstring 0.4.0.1 - Difference strings  http://hackage.haskell.org/package/dstring-0.4.0.1 (BasVanDijk)
13:54:18 <shachaf> totonex: Seriously, this channel has seen worse than you could possibly throw at it.
13:54:21 <shachaf> @protontorpedo
13:54:21 <lambdabot> hu me/
13:54:24 <shachaf> @protontorpedo
13:54:24 <lambdabot> waht is this D&D
13:55:52 <int80_h> @hoogle forever
13:55:53 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
13:56:57 <ourfrank> Hello. Can I profile code that uses template haskell? I get a "unknown symbol `entering_PAP`" error after I compile first the regular way, and then with -prof -osuf ".o".
13:57:42 <ourfrank> Simon Marlow says here it can't be done, but that's five years ago: http://web.archiveorange.com/archive/v/2B0uXdqvORuxyISoYTcN
13:57:56 <ourfrank> The issue he links to has been marked as fixed, but nobody commented anything there.
14:01:23 <ourfrank> Found the cause of my misery: I should've used "-osuf p_o".
14:03:35 * hackagebot GenericPretty 1.1.0 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-1.1.0 (RazvanRanca)
14:07:17 <totonex> Since i have been encouraged to do so,
14:09:55 <totonex> Since i have been encouraged to do so,
14:10:02 <totonex> I will start talking by myself some things about programming, which will eventually lead up to Haskell, or me becoming annoying and being begged to cease ! Here i go
14:10:22 <totonex> My first programming experience was in the 9th grade, High School.
14:10:36 <totonex> In Romania, my country, the language of choice for informatics-mathematics high schools is C
14:10:52 <totonex> Pretty odd - pointers are pretty much the core of C, and they're rather difficult to understand as a newbie
14:11:06 <totonex> Some years ago, Pascal had been this choice, but due to the language getting old, it got (and is getting) slowly expelled from high schools
14:11:18 <totonex> ah, i recall my first "program", written in BorlandC 3.0 for DOS on a machine with Windows XP
14:11:27 <totonex> #include <iostream.h> void main() { something_trivial_here }
14:11:35 <totonex>  man, when i saw that i can manipulate stuff like that
14:11:42 <totonex> i didn't care what <iostream.h> mean, or what void main() was, i was just told to put them there
14:11:46 <totonex> meant*
14:11:55 <totonex>  and that everything between the brackets would just execute
14:12:01 <totonex> we weren't even taught about compiling, linking, and stuff like that
14:12:06 <totonex> we just pressed CTRL-F9 and it worked
14:12:12 <totonex> flash forward a few years later, in the 12th grade (terminal grade for High-school in Romania, and pretty much around the world)
14:12:22 <totonex> We had learned some simple sorting algorithms, functions, pointers, backtracking, matrices, arrays, and stuff like that
14:12:30 <totonex>  I still hadn't gotted pointers right !
14:12:35 <totonex> char * somestring = "blabla" //C character-strings are terrible !
14:12:53 <totonex> I had done a simple battleships-like game for some paper that would attest that i had programming competences
14:12:56 <azaq23> (you should use int main(void), not void main(), void main() is dangerous)
14:12:59 <totonex> Written in Borland C++ Builder 5 (RAD Tool)
14:13:28 <totonex> (I will put that on the to-do list after i post this bio-thingie, thanks ! )
14:13:35 * hackagebot uulib 0.9.14 - Haskell Utrecht Tools Library  http://hackage.haskell.org/package/uulib-0.9.14 (ArieMiddelkoop)
14:13:59 <totonex> It was pretty cool, it had some socket code, it would work between 2 players on 2 machines
14:14:06 <totonex> Though when i had to present it, it crashed
14:14:12 <totonex> (Only the vs. computer option, players vs player still worked ;) )
14:14:18 <chrisdone> indeed. any ambiguous names
14:14:28 <chrisdone> woops, i'm replying to backscroll
14:14:36 <totonex>  The AI was terrible, it was rather AR (Articial randomness) since it would hit randomly
14:14:43 <chrisdone> ski: yeah, haddock should disambiguate ambiguous names like bytestrings
14:15:14 <totonex> I read a PHP book, a C# book, learned some OOP (not how to think in OOP, but basic concepts)
14:15:35 <totonex> in my first year of college (Computer & Information Technology), i finally understood them pointers
14:16:12 <totonex> And then i started reading David S. Touretzky's "A Gentle introduction to Common Lisp "
14:16:28 <totonex> Woooah ! Functions as PARAMETERS? You kidding me ?
14:16:32 <totonex> Lambdas ?
14:16:39 <totonex> Man, this language is on fire !
14:16:45 <kmc> the finest in 1960's technology
14:16:46 <chrisdone> is this #tonotex-life-history?
14:16:54 <totonex> programming-history
14:16:57 * chrisdone takes a seat and eats popcorn
14:17:04 <totonex> which ends up in haskell interest
14:17:11 <totonex> My college mates thought i was nuts
14:17:19 <totonex> about Lisp
14:17:22 <monochrom> a competent C programmer would be able to use the library functions qsort and bsearch, which take functions as parameters, too
14:17:23 <totonex> And in a way, i was
14:17:28 <HugoDaniel> #totonex-should-go-install-xmonad-on-netbsd
14:17:40 <chrisdone> HugoDaniel: COMING TO CAMHAC‽ ;)
14:17:40 <copumpkin> totonex: this isn't really relevant to the almost 800 people in here
14:17:47 <HugoDaniel> :D yoo chris!
14:17:49 <totonex> I know, i was suggested to do so
14:17:51 <HugoDaniel> no, im attending CCC camp
14:17:56 <chrisdone> nice
14:18:05 <HugoDaniel> i wish i could go to camhac
14:18:06 <copumpkin> totonex: well, you're being suggested not to now :)
14:18:13 <totonex> Alright then
14:18:20 <HugoDaniel> im trying to evangelize haskell around people here, but i fear i lack the skills
14:18:21 <copumpkin> totonex: I'm sure #haskell-blah would love to know though
14:18:25 <monochrom> I think totonex will finish soon anyway
14:18:35 <totonex> Yeah, i', in my 3rd year of college
14:18:38 * BMeph likes squirrels, 'cause they're nuts about...nuts. ;)
14:18:40 <totonex> and the story was in the 1st year
14:18:42 <chrisdone> HugoDaniel: CCC camp sounds cool anyways :)
14:18:48 <totonex> so only 2 years left haha :)
14:19:02 <luite> has camhac already started?
14:19:07 <monochrom> I mean, we're already at lisp, the haskell part can't be too far
14:19:12 <chrisdone> luite: starts tomorrow
14:19:20 <HugoDaniel> chrisdone: yeah, its amazing :) but i crave for that haskell comunity love
14:19:56 <shachaf> totonex: I was suggesting that if you have some Haskell questions you should ask them, and that it's fine to provide a bit of background. :-)
14:19:57 <chrisdone> BMeph: i thought of a joke today. ‘i used to aspire to be a suicide bomber… but i couldn't find any work.’
14:20:03 <totonex> If anyone wants to hear the story till today, i'm on #haskell-history
14:20:09 <chrisdone> HugoDaniel: hehe
14:20:10 <totonex> Yeah, i warned you :)
14:21:10 <sm> ack, I was just getting into it
14:21:12 <shachaf> totonex: You could @paste it and post the link here if you wanted to, maybe, and it led to some questions eventually.
14:21:20 * sm thinks, now THAT's a question 
14:21:37 <totonex> Well, i got one chap on #haskell-history, so i'm going on !
14:22:38 * BMeph wonders when the question will show up...
14:22:52 <monochrom> well, it will show up in another channel now
14:23:02 <chrisdone> I can summarize mine in a nice flowchart: BASIC → Visual Basic → C → JavaScript, PHP → Common Lisp → Scheme → Haskell ↩
14:23:38 <edwardk1> @tell tibbe btw- your hashmap/hashset stuff rocks for parsers
14:23:39 <lambdabot> Consider it noted.
14:24:05 <monochrom> wait, how does hashmap/hashset rock for parsers?
14:24:06 <chrisdone> edwardk1: PEG caching?
14:24:50 <edwardk1> chrisdone: not yet, no peg layer at the moent
14:25:17 <edwardk1> monochrom: i have a lot of crazy identifier lookup tables, etc.
14:25:26 <edwardk1> avoids string based map lookups
14:26:09 <edwardk1> and most of mine are in bytestring form, so the hash computation is fast, etc.
14:30:59 <monochrom> speaking of tibbe! :)
14:31:40 <tibbe> monochrom: !
14:31:41 <lambdabot> tibbe: You have 1 new message. '/msg lambdabot @messages' to read it.
14:32:03 <tibbe> I had to reboot my machine
14:32:23 <tibbe> edwardk1: I'll probably release a new, much faster version of unordered-containers after CamHac
14:34:24 <tibbe> lookup times are now 0.34x those of the last release
14:34:36 <chrisdone> nice
14:35:13 <tibbe> I'll try to get some more compiler improvements into 7.4, should give us another 10-20%
14:35:40 <tibbe> if someone could help figure out the right combinators to create maps in a linear fashion (e.g. unfolds) we could have 50% better insert performance
14:35:53 <tibbe> e.g. fromList is 50% faster than foldl' insert
14:36:02 <tibbe> since it mutates/freezes behind the scenes
14:38:36 * hackagebot uuagc-cabal 1.0.0.1 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.0.1 (ArieMiddelkoop)
14:38:57 <Phyx-> cabal plugin?
14:39:52 <Eduard_Munteanu> Hm, are those improvements in generated code, or GHC running times?
14:40:38 <monochrom> "UUAGC is the Utrecht University Attribute Grammar Compiler It is a preprocessor for Haskell which..." so perhaps a cabal plugin integrates the preprocessor with cabal
14:40:47 <Eduard_Munteanu> (or maybe it's not compiler-related at all)
14:41:15 <Phyx-> monochrom: i'm familiar with the tool, just didn't know cabal supported plugins
14:41:28 <monochrom> I didn't know either
14:41:31 <thoughtpolice> monochrom: that's what i'm thinking, cabal only recognizes a handful of preprocessors by default (uuagc not being one of them)
14:41:38 <thoughtpolice> Phyx-: it's more like a module you import into your Setup.hs file
14:41:43 <Eduard_Munteanu> You know, we learned something today.
14:42:13 <monochrom> yeah, seems like it requires custom build
14:42:20 <thoughtpolice> (note the 'Distribution.Simple' prefix, a few other packages in the past have done this)
14:42:23 <thoughtpolice> including hgettext, i think
14:42:39 <thoughtpolice> and yeah it'll require a custom directive, otherwise cabal-install just ignores Setup.hs i'm pretty sure
14:42:56 <Phyx-> thoughtpolice: ah, so it registers a preprocessor then
14:42:56 <thoughtpolice> darcs also does something similar with a custom Setup.hs
14:43:00 <thoughtpolice> Phyx-: right
14:43:11 <thoughtpolice> (although darcs does it for testsuite harness stuff, i think)
14:43:19 <Enigmagic> Custom is required for Setup.hs/lhs
14:43:23 <Phyx-> thoughtpolice: too bad that breaks sdist and clean :(
14:43:59 <alpounet> hsffig generates cabal projects with a Custom build policy
14:44:36 <Enigmagic> it's pretty easy to plug in a preprocessor but it only works for preprocessors that generate one file per input
14:45:08 <Enigmagic> i want preprocessor support that gives me all the inputs at once :-)
14:45:39 <Phyx-> am I the only one that sdists fails for using a custom preprocessor?
14:46:22 <thoughtpolice> huh, weird
14:46:41 <thoughtpolice> Arie just uploaded uuagc-cabal, which is clearly a cabal hook, but the regular 'uuagc' package already has one of these :)
14:46:43 * ski wonders whether HugoDaniel meant "Cartesian Closed Categories camp" ..
14:46:53 <thoughtpolice> i guess it's so you can explicitly specify a dependency on the hook and nothing else
14:48:10 <Phyx-> isn't the regular uuagc package program only
14:48:16 <Phyx-> no exposed modules?
14:49:15 <Phyx-> well i'll be. it's not..
14:49:35 * Phyx- never noticed that
14:53:36 * hackagebot explicit-iomodes 0.6.0.3 - File handles with explicit IOModes  http://hackage.haskell.org/package/explicit-iomodes-0.6.0.3 (BasVanDijk)
14:53:38 * hackagebot explicit-iomodes-bytestring 0.2 - Extends explicit-iomodes with ByteString operations  http://hackage.haskell.org/package/explicit-iomodes-bytestring-0.2 (BasVanDijk)
14:53:40 * hackagebot explicit-iomodes-text 0.1.0.6 - Extends explicit-iomodes with Text operations  http://hackage.haskell.org/package/explicit-iomodes-text-0.1.0.6 (BasVanDijk)
14:58:42 * hackagebot uuagc-bootstrap 0.9.39.0.0 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-bootstrap-0.9.39.0.0 (ArieMiddelkoop)
14:59:43 <deech> I'm reading the Haskell 98 Revised Report and the only mention of type inference I can find is in section 4.1.4. Am I missing something?
15:02:08 <monochrom> there is also 4.5, 4.6. you should know hindley-milner from elsewhere, then the haskell report only says additions and modifications
15:03:36 * hackagebot trifecta 0.17 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.17 (EdwardKmett)
15:03:38 * hackagebot GenericPretty 1.1.1 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-1.1.1 (RazvanRanca)
15:04:12 <deech> Ah I see. Now I see there's also a link to the "Typing Haskell in Haskell" paper.
15:04:26 <totonex> Hey, how mad of an errand i to try and make a Haskell compiler...in Haskell ?
15:04:26 <ski> for whom it concerns : totonex's story <http://pastebin.com/0KathHe5>
15:04:29 <mauke> The paste 0KathHe5 has been copied to http://hpaste.org/50193
15:04:37 <sully> totonex: it is the standard language to do it in
15:04:45 <edwardk1> totonex: never been done before, don't do it! =)
15:04:52 <totonex> It Has been done before
15:05:04 <totonex> Not successfully, though, at least not fully
15:05:36 <edwardk> plenty of haskell compilers are written in haskell
15:05:36 <preflex>  edwardk: you have 1 new message. '/msg preflex messages' to read it.
15:05:54 <totonex> I am thinking of trying this, but the sole reason is to pump Haskell muscles, if anyone has a better idea on how to do that, i'm listening (i already have received some ideas)
15:06:28 <totonex> Ah, and because i like how the bowels of abstract algebra are injected in Haskell
15:06:47 <totonex> and category theory, topology and whatnot
15:07:16 <chrisdone> a haskell→js compiler would be nice
15:07:23 <totonex> javascript?
15:07:34 <EvanR7> doesnt exist yet?
15:08:14 <chrisdone> there're some, but all incomplete
15:08:26 <ski> totonex : i mentioned that maybe a mini-Prolog implementation in Haskell would be easier to start with
15:08:35 <totonex> yeah, i mentioned it in the idea bag
15:08:36 * hackagebot trifecta 0.18 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.18 (EdwardKmett)
15:08:45 <EvanR7> chrisdone: seems easy, except for the type checker
15:09:02 <EvanR7> and make it fast ;)
15:09:02 <totonex> javascript is virtually typeless
15:09:24 <totonex> everything is everything..makes me tipsy
15:09:29 <EvanR7> yes, js sucks
15:09:39 <totonex> no, i find prototypes great
15:09:40 <EvanR7> but you can think of it like the machine code of web browsers
15:09:55 <EvanR7> implementation inheritance sucks
15:10:03 <totonex> Well, the greatness of it did not stop me from writing 7000 lines of spaghetti at work
15:10:14 <byorgey> totonex: sounds like a fun and worth project, but I would start by identifying a very stripped-down subset of Haskell and write a compiler for that
15:10:16 <EvanR7> thats it?
15:10:31 <byorgey> totonex: otherwise you are likely to get bogged down in lots of tricky and uninteresting details
15:10:39 <totonex> Good advice, thank you
15:10:42 <edwardk> byorgey++
15:11:10 <chrisdone> an interpreter for a subset of haskell is fairly easy, you get laziness for free
15:11:14 <edwardk> and clearly you should use my shiny new parser library…. aw who a mi kidding you probably don't want to keep up with the api changes ;)
15:11:23 <augur_> byorgey++ would be a great programming language. easy to understand!
15:11:31 <totonex> byorgey?
15:11:37 <augur_> edwardk++ would be horrible. powerful but inscrutible, no doubt!
15:11:51 <edwardk> yeah but in byorgey++ you spend all your time writing documentation
15:12:04 <byorgey> hahaha
15:12:05 <chrisdone> AugUr — augmented Ur
15:12:14 <monochrom> haskell++ adds powerful metaprogramming to haskell XD
15:12:19 <byorgey> edwardk: how did you know I am currently writing documentation?
15:12:21 <augur> and templates
15:12:25 <augur> dont forget templates
15:12:31 <edwardk> byorgey: well, you seemed awake
15:12:32 <augur> turing complete parsing
15:12:36 <byorgey> hehe
15:12:42 <augur> byorgey: what do you document
15:12:48 <byorgey> I write code sometimes too!
15:12:59 <byorgey> at the momemt, moment, diagrams
15:13:02 <augur> good code is self documenting! :|
15:13:05 <shachaf> Are there any Haskell compilers *not* written in Haskell?
15:13:06 <augur> |:
15:13:07 <augur> :|
15:13:12 <deech> Speaking of Ur didn't some guy challenge the Haskell community to rewrite his Ur web app in Haskell?
15:13:12 <edwardk> byorgey: my parser library is coming together. it even has a profunctor or two
15:13:21 <byorgey> edwardk: excellent!
15:13:21 <Nimatek> Good documentation is self-coding.. wait.
15:13:33 <augur> Nimatek: that too
15:13:41 <augur> actually thats sort of true
15:14:02 <augur> ive found that if i do a detailed enough job explaining what something is supposed to do, its easier to translate it into code
15:14:03 <chrisdone> and make sure to add flow-charts! http://hackage.haskell.org/package/flo-0.1
15:14:06 <byorgey> deech: yes, but I doubt anyone will do it.
15:14:33 <totonex> This channel, and business programming (coding for money) are two so very different worlds; In one, OOP, and multi-tier-whatever, in the other, elegant stuff about programming
15:14:53 * chrisdone uses haskell in bidness
15:15:01 <totonex> WOWW you are so lucky
15:15:06 <totonex> chrisdone
15:15:08 <edwardk> some of us work in functional code in business
15:15:30 <totonex> :( All jobs posted near me are in PHP/Java/C#
15:15:32 <chrisdone> oddly i've never needed OOP concepts
15:15:53 <totonex> I had to read 'Design Patterns' to clear up my mind on OOP
15:15:55 <Nimatek> The others hold cardboard signs saying 'will do morphisms for money'
15:16:08 <augur> OOP has made a lot of sense for game programming for me
15:16:28 <deech> The most functional code I've done at work all week is a Java inner class.
15:16:52 <totonex> how?
15:16:59 <ski> shachaf : i think HBC is written in Lazy ML ?
15:17:02 <baguasquirrel> augur: sometimes writing up math in any language can be obtuse. diagrams can be useful in those situations.
15:17:12 <shachaf> ski: Hah, OK.
15:17:24 <ski> (HBC was the first Haskell compiler)
15:17:40 <chrisdone> i thought the first compiler was in common lisp :o
15:17:46 <totonex> hahaha
15:17:49 <shachaf> ski: Was it written before any Haskell interpreters?
15:17:54 <totonex> lisp was written in lisp ! ^^
15:18:03 <deech> Thought it was hacked togher in Perl.
15:18:07 <ski> (deech : that guy was Smerdyakov, the creator of Ur :)
15:18:10 <totonex> aw, dissapointment
15:18:16 <confab> deech, nice
15:18:17 <chrisdone> ski: what, really?
15:18:32 <totonex> deech: Which was coded directly from transistors
15:18:45 <chrisdone> but that guy Adam is such a nice guy. smerdy on IRC was cthulhu's mean stepdad
15:19:08 <ski> Smercyakov is Adam Chlipala
15:19:13 <totonex> It would be so nice to have some hardware to do parallel IF's in if/else constructs
15:19:16 * chrisdone boggles
15:19:19 <ski> s/c/d/
15:19:38 * ski mostly find Smerdyakov ok
15:19:48 <deech> He's Tyler Durden
15:20:18 <totonex> Heavy is Spy !
15:20:21 <edwardk> he's mellowed these days quite a bit
15:20:49 <confab> has anyone here tooled around with wyas?
15:20:53 <dmwit> Ah, a TF2 connoisseur.
15:21:08 <Phyx-> MEDIC!!!
15:21:44 <monochrom> everyone grows old and kind. I was aggressive "do you even know how to read?" when young
15:21:45 <totonex> I am...dispenser !
15:22:12 <dolio> Yeah, you're definitely kind now.
15:22:15 <ddarius> HBC was originally written/bootstrapped in LML.  YHC's first version was CL.
15:22:21 <chrisdone> monochrom: haha. that's not how you hold a crayon, and you're supposed to be 3 years old? you act like you're 1!
15:22:22 <monochrom> (well, these days I'm kinder: "do you know you have a scroll buffer?")
15:22:42 <totonex> TF2 videos on Youtube featuring hacked GMod voices are some of the most brain-disturbing things
15:24:23 <mreh> Jules, what is your nick again?
15:25:47 <mreh> conal: it doesn't seem that Jules' implementation of Futures reveal partial information, is that true?
15:26:44 <conal> mreh: hm. i don't remember his Future implementation.
15:27:01 <dolio> What was GHC originally written in? Or did it start in Haskell?
15:27:25 <mreh> conal: it all takes place in IO using concurrent haskell
15:27:47 <mreh> does that jog your memory? i've got the source
15:27:49 <int80_h> I want to send a (foo,bar) from one process to another. Is using MVars the right way to do that?
15:27:54 <conal> mreh: ah. then probably a very difficult question to pose precisely and answer reliably.
15:28:01 <int80_h> or rather, a possible way to do that.
15:28:22 <conal> mreh: ie without hand-waving and wishful thinking.
15:28:39 <mreh> hmm, okay :)
15:28:45 <ski> int80_h : if you're talking about threads within one OS process, then that works
15:29:00 * conal wanders off for a few minutes ...
15:29:26 <int80_h> ski: no, it would be two seperate processes I want to use. This would be a one-way communication.
15:29:28 <ski> int80_h : alternatives are `Chan' and `SampleVar'
15:30:12 <ski> int80_h : if it's different OS processes, then i think you probably have to marshall through an OS pipe
15:30:39 <int80_h> ski: piping! okay what are the typical constructs to do that in Haskell?
15:31:21 <ski> `System.Process' has some things
15:33:36 * hackagebot trifecta 0.19 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.19 (EdwardKmett)
15:33:55 <TotoTitus> a
15:34:21 <ddarius> dolio: It was first built with HBC.
15:34:29 <dolio> Okay.
15:38:38 * hackagebot GenericPretty 1.1.2 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-1.1.2 (RazvanRanca)
15:44:08 <BrianHV> holy linker spam on Lion, batman...
15:44:13 * BrianHV upgrades ghc
15:48:38 <zong_sharo> is it possible to know how much of input was consumed by an arbitrary attoparsec expression?
15:49:30 <zong_sharo> i'd like to write a guard function to esure that underlying expression consumed exact amount of input
15:51:59 <chrisdone> doesn't look like it from the api
15:53:36 * hackagebot uuagc-cabal 1.0.0.2 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.0.2 (ArieMiddelkoop)
15:54:30 <aavogt> zong_sharo: run the parser separately on input you've got from   take
15:54:54 <chrisdone> zong_sharo: looks like you could write your own easily. you'd have to patch it tho
15:55:11 <aavogt> at least with parsec you can adjust the input to put it back if you didn't use it
15:55:17 <chrisdone> consumedBytes :: Parser a -> Parser (a,Int) or something
15:56:29 <hatds> I'm writing a string interpolation quasi quoter which allows escaped Haskell expressions like "blah \(reverse some_str) blah".  I'm strongly considering just writing a .hs preprocessor instead.  What are the advantages, if any, of using a QQ'er?
15:58:29 <zong_sharo> hatds: preprocessors are stupid
15:58:43 <hatds> zong_sharo: explain
15:58:45 <aavogt> hatds: such a quasiquoter already exists http://hackage.haskell.org/packages/archive/haskell-src-meta/0.2/doc/html/Language-Haskell-Meta-QQ-HsHere.html (I forget which package it moved to)
15:59:46 <hatds> aavogt: I'm simplifying the discussing a little because there are custom things I need to do besides
16:00:08 <aavogt> maybe those things are simplified by features of the Q monad
16:01:07 <zong_sharo> hatds: either you will cut some corners and, threfore preprocessor will fail under some circumstances, or you will make a fully operational translator from your haskell-as-ghc-knows-it+your-extension to just haskell-as-ghc-knows-it
16:01:31 <zong_sharo> but this will be hella lot of trouble
16:02:31 <aavogt> zong_sharo: Expr can't express all of ghc haskell unfortunately, so a preprocessor could support more extensions (-XImplicitParams for example)
16:02:32 <zong_sharo> on the other side, if you choose qq, then ghc will handle most of the hassle for you
16:03:02 <hatds> zong_sharo: it is suprsingly a hella lot of trouble to do what I want with QQ'er.  TH doesn't give you access to it's internal parser String -> Exp, but thankfully you can get such a thing on hackage
16:03:03 <zong_sharo> aavogt: is there anyone who really need such a thing?
16:03:37 <hatds> I already have the combinators to write a robust .hs preprocessor (because I need to do things I can't accomplish with QQ'er)
16:04:12 <aavogt> hatds: what are those things?
16:05:14 <ddarius> Writing a parser for existing language is a singular limit.
16:05:17 <hatds> aavogt: a EDSL which allows you use capitalized identifiers as normal ones.  like "where N = 3"
16:05:36 <zong_sharo> hatds: well, it's up to you anyway, but my point was that with qq you're on much safer ground
16:06:59 <Peaker> Does parsec have a simple decimal-number parser that's not inside some lexical environment thing?
16:08:05 <edwardk> no
16:08:12 <edwardk> it requires the lexeme plumbing.
16:08:20 <edwardk> trifecta does, but its tied to all my other crap
16:09:18 <edwardk> https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Parser/Token/Combinators.hs#L200
16:09:35 <idnar> ouch
16:09:41 <idnar> apparently I don't have enough memory to build Yi from git
16:09:55 <edwardk> i need to take some of that apart, for instance, that one doesn't use lexeme
16:10:08 <edwardk> so its kinda silly to have it in TokenParser, i should probably move it
16:10:26 <idnar> or at least not enough free
16:10:33 <idnar> (I was thrashing swap really hard there for a minute)
16:10:55 <aavogt> hmm, it might be nice if ghc accepted let a = b where [d| b = 5 |] in a
16:10:58 <idnar> oh actually I think I'm building some dep
16:10:59 <Peaker> edwardk: I was wondering why -- it seems like a pretty basic thing that's typically needed in examples, parsing config files/cmd line args, etc
16:11:04 * idnar frowns
16:11:12 <Peaker> And I can't say my config file is a "Haskell token grammar" or such
16:11:27 <idnar> where's the "cabal install --no-deps"?
16:11:35 <edwardk> peaker: i agree
16:11:52 <idnar> maybe --dry-run is good enough
16:11:54 <edwardk> peaker: i've been trying to strip away the layers of cruft and voodoo that parsec has piled on top of token parsing
16:12:29 <edwardk> well you can build a haskell token grammar, just to get the whitespace rules (if you can comply with their comment style limitations)
16:12:30 <Peaker> edwardk: it seems reasonable to have the tokenizers for various existing things.. But that should not preclude also having simple stuff out of their context
16:12:52 <edwardk> yeah, the main issue is the 'lexeme' combinator that is used throughout those number types
16:12:55 <hpaste> int80_h pasted “parse error” at http://hpaste.org/50197
16:13:02 <ski> aavogt : itym s/[d| b = 5 |]/$([d| b = 5 |])/
16:13:09 <Peaker> edwardk: well, I got another coworker to try out Haskell :) She wrote a parser for some text data in parsec, but had to revert to "read" or such for numbers
16:13:25 <Peaker> edwardk: and she didn't want to lie to parsec that it's a Haskell grammar - and I agree
16:13:28 <edwardk> ick
16:13:38 <dylukes> Peaker: co-worker?
16:13:44 <dylukes> is that the categorical dual to a worker?
16:13:48 <Peaker> :-)
16:13:51 <aavogt> ski: oh, that makes more sense
16:15:05 <edwardk> you may be in luck i think i can strip out the core of the number parsers at least, well, using my parser library ;)
16:15:20 <hatds> I'm sure I've seen out-of-context decimal parsers in some hs Parser lib, but it's buried in the source (possibly as a local function)
16:16:01 <edwardk> yeah i've stolen them from parsec's token parser a few times (along with the string parsing, etc)
16:16:10 <int80_h> could anyone help me with my parse error?
16:17:44 <ion> int80_h: The indentation seems broken. The definitions should be at the same level of indentation as the type annotations.
16:18:53 <ion> That seems to have been the intent but Haddock seems to have rendered it in a different way than the author thought: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Concurrent-MVar.html
16:20:40 <int80_h> ion: is code from the url you just gave idented correctly?
16:21:17 <int80_h> it looks exactly the same as what I have.
16:21:28 <hatds> I think I realized what is really bothering me about preprocessor vs QQ'er for interpolation.  The QQ'er needs to parse a string in a Exp, which is a complicated ADT.  The preprocessor only needs to do lexing and insertion of ++ in the right places.
16:21:31 <int80_h> oh wait, I see the difference
16:21:52 <hatds> anywho with hackage I can do either route easily enough, but it is strange
16:22:27 <ddarius> The only correct parser is your implementation's parser.
16:23:37 * hackagebot uuagc 0.9.39.0 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.39.0 (ArieMiddelkoop)
16:28:57 <hpc> can someone help me figure out why a program isn't compiling for me?
16:29:05 <hpc> i am compiling with `ghc --make -O1 Data/Main.hs -main-is Data.Main -o data'
16:29:11 <hpc> not using any extensions
16:29:14 <hpc> the error i get is:
16:29:22 <hpc> Warning: output was redirected with -o, but no output will be generated
16:29:22 <hpc> because there is no Main module.
16:31:00 <Lemonator> @hoogle (a -> m b) -> (b -> m c) -> (a -> m c)
16:31:01 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
16:31:01 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
16:31:01 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
16:33:24 <Enigmagic> hpc: is this on a osx box?
16:33:31 <hpc> linux
16:34:07 <Enigmagic> hpc: might be a bug or a case insensitive compare somewhere
16:34:07 <hpc> The Glorious Glasgow Haskell Compilation System, version 6.12.1
16:34:26 <aavogt> hpc: you a   Data.Main.main for sure?
16:34:47 <hpc> aavogt: still nope
16:34:50 <Enigmagic> hpc: if you change it from "-o data" to "-o data2" it works for me... but on OSX "Data/" and "data" are the same (the filesystem isn't case sensitive)
16:34:55 <ian__> hello, all
16:34:55 <kmc> :O
16:34:58 <kmc> hi  ian__
16:35:09 <ian__> any good resources for understanding monads
16:35:25 <hpc> trying -o dataBot
16:35:30 <ion> The Typeclassopedia
16:35:31 <kmc> why do you want to understand monads?
16:35:48 <ian__> so i can have a deeper understanding of the programs i'm writing
16:35:53 <monochrom> learnyouahaskell.com has a good section on monads
16:35:53 <hpc> ian__: go through lyah; when it gets to monads, you will be good and ready for them
16:36:08 <zomg> kmc: kinda like asking why do you want to understand oop if you were learning java :P
16:36:09 <hpc> still no compiling, same error
16:36:13 <pikhq> Enigmagic: That seems implausible; that's in violation of POSIX, and OSX claims to be POSIX compliant.
16:36:14 <kmc> zomg, no it's not
16:36:14 <monochrom> and lyah = learnyouahaskell.com
16:36:17 <kmc> Haskell is not "about monads"
16:36:28 <zomg> kmc: well you can code java without understanding oop
16:36:36 <zomg> Only the result is not really so great then
16:36:38 <zomg> =)
16:36:56 <monochrom> you need to understand monads for java, too
16:36:58 <zomg> But if you actually understand the concepts, you will write better code
16:36:59 <kmc> zomg, the reason I ask is that the answer is sometimes "to do IO", and then "how do i understand monads" is actually totally the wrong question
16:37:05 <zomg> I think that applies for monads in Haskell as well.
16:37:13 <zomg> Once you understand them, you will write better code
16:37:16 <kmc> sure
16:37:17 <Enigmagic> pikhq: osx isn't case sensitive, it's case preserving. checking the timestamp on "data" will return the timestamp on "Data/" if it exists.
16:37:19 <zomg> Maybe OOP is a bit too strong comparison
16:37:22 <kmc> but the same is true of a dozen other concepts
16:37:30 <pikhq> Enigmagic: Violates POSIX.
16:37:33 <kmc> "Monad" is just one of many useful type classes
16:37:38 <hpc> wait, never mind
16:37:39 <Enigmagic> pikhq: go file a bug with apple.
16:37:46 <hpc> my build script is failing on a different file
16:37:56 <hpc> should probably add some echos :P
16:37:57 <monochrom> indeed, you need to understand functors too, and lyah has a good section on that one too
16:37:59 <pikhq> s/bug/lawsuit/; that'd be false advertising.
16:39:28 <Enigmagic> yeah go sue them then, you'll be rich.
16:39:50 <Enigmagic> they have a big wad of cash
16:41:09 * Peaker has explained covariance/contravariance/invariance and how they relate to Functor/CoFunctor and to positive/negative positions in types to a friend today..
16:41:28 <kmc> cool
16:41:36 <kmc> was your explanation well-received?
16:41:58 <Peaker> Yeah, I tested him and he understood which types would be Functor'able and which won't :)
16:42:05 * ski wishes people would stop to use the name `CoFunctor'
16:42:06 <kmc> nice
16:42:14 <Peaker> I wonder if there's a good concise explanation of all this on the web somewhere -- it's all fairly simple, but I don't think I've ever seen it put in one place (linking the 3 concepts)
16:42:16 <kmc> iran contrafunctor
16:42:32 <kmc> Peaker, that sounds like something i'd write a blog post about :)
16:42:55 <Peaker> kmc: I'm too busy+lazy for that :-) I hope to finish with my workplace soon and then I intend to have lots of time for various Haskell stuff :)
16:42:56 <hpc> solved it, i think
16:43:04 <ski> kmc : .. and `ContraFunctor' also, of course
16:43:12 <kmc> what's wrong with ContraFunctor?
16:43:14 <hpc> deleted `module Data.Admin where'
16:43:22 <kmc> should one write out ContravariantFunctor?
16:43:29 <Peaker> btw: Maybe Functor could be named Covariant?
16:43:36 <edwardk> kmc: i just called it 'Contravariant' in hackage
16:43:38 <kmc> ok
16:43:42 <hpc> it couldn't produce an executable for a file that wasn't module Main
16:43:50 <kmc> is there a thing called a cofunctor?
16:43:54 <edwardk> we already say 'Applicative' rather than 'ApplicativeFunctor'
16:43:56 <edwardk> no
16:43:59 <edwardk> cofunctor = functor
16:44:22 <ddarius> You can, however, have lax and oplax functors.
16:44:24 <edwardk> (a -> b) -> (f a -> f b)  — flipped = (b -> a) -> (f b -> f a) — which is the same thing =P
16:44:50 <Enigmagic> hpc: it works fine on 7.2.1, but this might have changed since 6.12.1
16:45:15 <ion> (f a → f b) → (a → b)
16:46:00 <luite> is there an admin of the hackage server here?
16:46:01 <hpc> yeah, this installation is less than a year old and already has too much history for my tastes
16:46:05 <edwardk> peaker: ok, new version of trifecta now has a separated set of lexical parsers for string literals, char literals, numbers, etc.
16:46:13 <hpc> want to wipe and reinstall with platform instead of apt
16:46:20 <Peaker> edwardk: cool - how does trifecta relate to Parsec?
16:46:33 <edwardk> the only sticking point is in integer, where integer' unlike integer actually can't support space between the sign and the number
16:46:45 <monochrom> the relation is trifecta > parsec :)
16:46:52 <hpc> but waiting for myself to do something irreparably dumb first, so i have an excuse to go through the process of copying everything back over
16:46:53 <alpounet> hpc, you were telling ghc -main-is Data.Main, instead of Data.Admin (apparently)
16:46:56 <edwardk> haha
16:46:58 <kmc> > compare "trifecta" "parsec"
16:46:59 <lambdabot>   GT
16:47:02 <edwardk> unless the metric is 'level of testedness'
16:47:10 <edwardk> hahahaha
16:47:10 <Peaker> hehe
16:47:14 <hpc> alpounet: no, you missed the part where i misread my build script output ;)
16:47:23 <Peaker> edwardk: does trifecta make Applicative parsers fast? That's my main gripe with parsec...
16:47:25 <hpc> there were a few layers of fail
16:47:30 <edwardk> @remember kmc > compare "trifecta" "parsec"     —>   GT
16:47:31 <lambdabot> I will remember.
16:47:48 <benmachine> edwardk uses emdashes but not →? :P
16:47:57 <ddarius> Where < means "depends on."
16:48:19 <rwbarton> cofunctor is oldfashioned terminology for contravariant functor
16:48:20 <ddarius> s/</>
16:48:23 <Peaker> btw, there's always the debate of how to generalize (.) --> the Category way, or the Functor way..  Can anyone think of a super-generalization that can be special-cased to either one?
16:48:26 <edwardk> i don't currently go out of my way to support swierstra style applicative parsing, mostly because it wasn't on my critical path
16:48:32 <ddarius> rwbarton: ?
16:48:38 * hackagebot trifecta 0.20 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.20 (EdwardKmett)
16:48:41 <edwardk> oldfashioned mostly in that its a abuse of language that has refused to die
16:48:44 <kmc> Peaker, class HasCompose t where { (.) :: t }
16:48:47 <kmc> problem.  solved.
16:48:49 <rwbarton> thankfully not in common use nowadays
16:49:15 <Peaker> kmc: Heh, a useful one :)
16:49:31 <alpounet> 0.20 ? haha
16:49:51 <benmachine> edwardk: how do you know which arrows to flip when you're taking a dual?
16:49:53 <edwardk> when people say cofunctors i say 'oh you mean covariant functor'? until they stop
16:50:20 <edwardk> think of the -> between them as the definitional arrow. given the thing on the left i can give you the thing on the right
16:50:24 <Peaker> edwardk: It would perhaps be nice if attoparsec/Binary's Get/etc would all be more unified into one parser library to rule them all.. (or at least competing libraries rather than supplamental libs)
16:50:27 <ddarius> I don't think anyone ever says "cofunctor."
16:50:29 <edwardk> (>>=) is all screwed up though
16:50:32 <rwbarton> hmm I wonder who says cofunctor
16:50:50 <Peaker> ddarius: I just did above, particularly CoFunctor :)
16:50:54 <ddarius> edwardk: The -> between them is a function type.
16:51:01 <ddarius> Peaker: You were reading aloud?
16:51:11 <edwardk> rwbarton: conal started a storm of it here in the haskell community but the more anal retentive of us have largely squelched it ;)
16:51:11 <Peaker> ddarius: heh
16:51:30 <alpounet> having cereal and binary "merged" would already be nice...
16:51:48 <Peaker> alpounet: yeah -- too many incompatible parsing libs
16:51:50 <ddarius> I'm not aware of any categorists ever using the term "cofunctor" for contravariant functor.
16:52:09 <Peaker> also -- I would really like to see a pickler-combinator library that lets you control the underlying format
16:52:22 <Peaker> Writing parsers/builders in parallel is error-prone (and annoying)
16:52:26 <rwbarton> I think maybe Grothendieck used it? (in French)
16:52:46 <edwardk> peaker: right now i'm focused on programming languages. i'm hard coded to utf-8, tracking positions, etc.
16:53:04 <Peaker> edwardk: what benefits does the hard-coding yield?
16:53:15 <rwbarton> if so it probably survives among some algebraic geometers
16:54:47 <kmc> benmachine, the way you know which to flip is that a truly general definition of Functor would be like
16:55:02 <edwardk> i can use cheap decoding techniques when dealing with ascii range characters, for instance the CharSet type there is specifically optimized for it, most of the code special cases for that kind of thing,
16:55:06 <edwardk> it tracks the current line constantly so i can give you fixit annotations against it, but also i need to be able to seek to a given position and resume parsing, with character and column counts
16:55:24 <edwardk> and i can't really do that unless i know what an actual 'character' is
16:55:26 <kmc> class (Category (~>), Category (~~>)) => Functor (~>) (~~>) f where { fmap :: (a ~> b) -> (f a ~~> f b) }
16:56:01 <benmachine> kmc: I see, so the way you know is by being aware of the underlying categorical concept, in which context it's more obvious
16:56:42 <edwardk> benmachine: yeah this is where building your intuition using haskell burns you because so many things collapse to the same arrow type
16:57:02 <benmachine> mm
16:57:34 <kmc> right
16:57:41 <edwardk> peaker: also, knowing that no encoded character is a legal prefix of another encoded character is important to some optimizations
16:57:56 <kmc> despite its reputation as "the maths language", Haskell makes a terrible mash of some math concepts
16:57:57 <edwardk> er suffix
16:59:14 <RichardBarrell> kmc: *Haskell98's standard libraries are a terrible mash of...
16:59:20 <hpaste> sfultong pasted “optimization help?” at http://hpaste.org/50198
16:59:36 <RichardBarrell> Kudos to the people who work with no implicit Prelude.
17:00:08 <ski> benmachine : you dualize by replacing a category parameter by its opposite
17:01:44 <ski> benmachine : so if you have a concept `P C' parameterized over any category `C', `P C^op' is the dual concept
17:02:19 <benmachine> ski: fair enough
17:12:31 <hpaste> int80_h pasted “confusion over GHC.Prim.Any” at http://hpaste.org/50199
17:16:22 <ski>   foo <- newSkipChan :: IO (SkipChan TheTypeYouWantHere)
17:17:03 * ski thinks GHCi should implement what O'Caml and some SMLs do here
17:17:35 <int80_h> ski: thanks. I'm in new territory here.
17:18:26 <ski> GHCi using `Any' really means that it refuses to let `foo :: SkipChan a' to be polymorphic in `a' (for type safety reasons)
17:18:59 <ski> it would possibly be better for it to generate a fresh new skolem type here
17:19:30 <ski> even better would be to say `foo :: SkipChan _a', where `_a' is a type whose instantiation is deferred, so it's not polymorhic
17:20:11 <ski> if you later use `getSkipChan foo' of type `SkipChar Bool', then the `_a' would be instantiated to `_a' so that it backpropagates into `foo :: SkipChan Bool'
17:20:15 <int80_h> Ima listening. Also playing with what you gave. Thinking about the type I want.
17:20:44 <Cale> in practical terms, you can just add a type signature when you run it on the ghci commandline
17:21:08 <ski> foo :: SkipChan TheTypeYouWantHere <- newSkipChan  -- is probably nicer that what i suggested first, but probably requires some extension
17:21:10 <Cale> So something like  foo <- newSkipChan :: IO (SkipChan String)
17:21:34 <Cale> oh, yeah, ski already mentioned that :)
17:21:49 <ski> yeah, already got that covered :)
17:21:58 <int80_h> foo <- newSkipChan :: IO (SkipChan (Int,[String]))
17:22:05 <ski> should work fine
17:22:08 <int80_h> this will do for my experimenting purposes
17:22:18 <ivanm> does anyone know if John Lato hangs out around here (and if so, under what nick)?
17:22:24 <int80_h> works fine so far
17:22:44 * ski wonders who that might be
17:22:44 <Cale> int80_h: The trouble is mainly just that ghci can't infer the type you want right away, like it probably could with a complete program
17:23:38 <Cale> ski: http://hackage.haskell.org/package/iteratee
17:24:39 <int80_h> zomg it works!
17:24:58 <int80_h> could one of you tell me what dupSkipChan does?
17:25:08 <ski> Cale : ok (i knew i'd seen the name somewhere, but not where)
17:25:34 <ivanm> ski: yeah, he responded to my stack overflow question, and I wanted to check some of the details with him if he was here
17:26:05 <int80_h> does dupSkipChan make a copy of an existing SkipChan?
17:26:35 <ski> int80_h : gets a copy of a `SkipChan a' so that if you `getSkipChan' on one of them, the other is not affected -- is what i would guess
17:26:54 <luite> does hackage limits connections to ~500kB/sec?
17:27:03 <ski> @hoogle dupChan
17:27:03 <lambdabot> Control.Concurrent.Chan dupChan :: Chan a -> IO (Chan a)
17:27:06 <ski> cf. ^
17:27:33 <int80_h> this si very exciting :)
17:31:19 <mun> hi
17:31:31 <mun> does anyone know if infinite sets can be formalised in first-order logic?
17:31:43 <danharaj> ZFC?
17:33:14 <mun> danharaj, but isn't the notion of infinitely higher-order, like real numbers?
17:33:24 <mun> *infinity
17:34:13 <kmc> first-order set theory allows infinite sets, yes
17:34:18 <hatds> the question only makes sense relative to some axioms
17:34:20 <ski> real numbers can be formalized in second-order logic, iirc
17:34:30 <ski> (more specifically, analysis)
17:35:38 <mun> but then, only countably infinite sets is first-order, right?
17:35:46 <zygoloid> mun: x is infinite iff: exists y. y \subset x /\ (exists f. f is a function /\ f y = x)
17:36:30 * ski thinks zygoloid wants a `map' in there
17:36:37 <benmachine> zygoloid: strict subset?
17:36:45 <zygoloid> benmachine: yeah.
17:36:50 <danharaj> mathematicians pun all the time.
17:36:52 <mun> zygoloid, but since you're ranging over functions, that's second order and not first order. no?
17:36:53 <danharaj> don't need no maps.
17:37:11 <danharaj> mun: A function in ZFC is a set.
17:37:11 <zygoloid> mun: no. a function is just a certain type of relation, which is just a certain type of set.
17:37:21 <ski> danharaj : they need to be punished for it ..
17:38:56 <ski> mun : ZF set theory is a way to simulate higher-orderness in a first-order theory
17:39:13 <zygoloid> mun: x is at least as large as the reals iff: exists y. y is uncountable /\ (exists f. f is a function /\ map f (P y) == x)
17:39:22 <mun> now i'm confused. isn't the quantification over functions a feature of second-order?!
17:39:27 <zygoloid> s/uncountable/infinite/ oops
17:39:56 <ski> mun : "function" here means something else than in higher-order theories
17:39:57 <danharaj> mun: Functions in a logic are different from functions in set theory.
17:40:14 <hatds> mun: quantification over predicates is higher order when talking about higher order logic
17:41:58 <mun> right. so how are these two notions of functions different?
17:42:20 <ski> ZF simulates/encodes functions in terms of (sub)sets
17:43:04 <int80_h> ski: after all I did today with MVars, I realized I wouldn't be using them as they were intended to be used. I need a state monad.
17:43:39 <ski> `MVar's are intended for inter-thread communication
17:44:34 * ski hands a nice state monad to int80_h
17:44:38 <kmc> int80_h, State is just sugar for passing states in a pure functional way
17:44:45 <kmc> this makes it totally different from IORef / MVar / etc
17:44:49 <kmc> which are real mutable reference cells
17:45:15 <ski> the difference is mainly that the latter can be allocated dynamically
17:45:39 <kmc> the semantic difference, yes
17:45:45 <kmc> there's a big implementation difference in GHC
17:45:51 <kmc> and a performance difference
17:45:58 <ski> *nod*
17:47:44 <int80_h> kmc: the docs on MVar says something to the effect that they are for synchronization between threads, right? I don't need that. I just wanted a way to keep track of (numOfThingsToDo,[TheThingsToDo])
17:47:58 <int80_h> which sounded to me like what State is for.
17:48:45 <mun> so now, is the quantification over predicates second-order?
17:48:53 <int80_h> kmc: am I getting this right?
17:49:10 <ski> int80_h : sounds ok
17:49:16 <ski> mun : yes
17:49:17 <int80_h> cool
17:50:20 <int80_h> I can take a performance hit for now
17:51:19 <mun> ski, but even unary predicates? are sets not essentially unary predicates, e.g., P(a) = true iff a belongs to set P?
17:52:03 <ski> as i said, sets *encode* higher-orderness in a first-order theory
17:54:33 <mun> ok
17:55:42 * ski recalls Weil talked about "`m'-ary sets"
17:57:37 <hpaste> BrianHV pasted “Configure error” at http://hpaste.org/50200
17:58:04 <BrianHV> ghc-paths seems to be installed, but not quite... why?
17:58:16 <BrianHV> (in reference to the hpaste url)
17:59:34 <BrianHV> is there something I need to do to tell runghc to look in ~/.cabal ?
18:00:20 <ivanm> BrianHV: runghc Setup.hs configure --local
18:00:32 <kmc> int80_h, MVar has nice concurrent semantics, but it's not impossible you'd want one in a sequential context
18:00:39 <ivanm> or use cabal-install instead, which does --local by default
18:00:57 <kmc> int80_h, "State s a" is just a wrapper on "s -> (a, s)"
18:01:07 <kmc> it's implemented in a couple lines of pure Haskell
18:01:12 <kmc> it's not magical like IO, ST, etc.
18:01:26 <kmc> you may or may not gain anything from the syntactic sugar
18:01:41 <BrianHV> ivanm: runghc says "unrecognized option `--local'" and ghcjs doesn't seem to be in cabal...
18:01:41 <kmc> if your problem is easiest to solve by just explicitly passing around the state
18:01:42 <kmc> then do that
18:01:51 <ivanm> BrianHV: well, it's something like that ;-)
18:01:59 <ivanm> runghc Setup.hs configure --help
18:02:31 <ivanm> BrianHV: and I use "cabal configure", etc. as a shortcut for "runghc Setup.hs configure", etc. (but defaulting to local rather than global)
18:02:48 <int80_h> kmc: hey thanks for that. I'll mull this over.
18:02:48 <BrianHV> --user seems to have done it. thanks :)
18:03:00 <ivanm> yeah, that's the one
18:03:12 <BrianHV> oh, and cabal configure works too.  I get it.
18:03:40 <BrianHV> erg. build failure. that was fun while it lasted...
18:03:53 <ivanm> heh
18:04:39 <ivanm> @ask dons I happened to be looking at the source for Data.ByteString.Internal, etc. and it says to see a ghc ticket for why you don't list all the LANGUAGE pragmas... but there's no ticket number there :s
18:04:40 <lambdabot> Consider it noted.
18:04:44 <zomg> BrianHV: Have you got that ghcjs thing working ever? =) Just wondering if the JS code it produces is any good / whether it's useful in general
18:05:12 <zomg> I can write JS blindfolded but it might be fun to see how haskell would work for browser scripting
18:06:02 <ivanm> zomg: yeah, but is your blindfolded JS any good? :p
18:06:27 <zomg> Depends if you allow me to go over it once to correct the typos ;)
18:09:59 * ddarius is sure there are plenty of blind programmers who write javascript.
18:10:05 <BrianHV> zomg: haven't tried until just now.
18:21:45 <BrianHV> why would ghc be claiming Module `HscTypes' does not export `liftIO' ?
18:24:12 <ivanm> ... because it doesn't?
18:24:33 <ivanm> @hoogle liftIO
18:24:33 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
18:24:59 <BrianHV> in 6.12 it did. granted, that was a while ago...
18:25:23 <ski> @index liftIO
18:25:24 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
18:25:29 <ivanm> maybe HscTypes re-exported it
18:25:32 <ivanm> but it doesn't come from there
18:26:08 <BrianHV> hm. I tried importing from Control.Monad.Trans instead and that threw other errors... but if that's the right path, I'll work on those errors
18:26:20 <aphyr> Haskell noob here--trying to figure out the best way to unpack a String containing a 2-byte big-endian unsigned int.. to an integer. Any suggestions?
18:26:41 <shachaf> aphyr: You probably don't want to use a String for that in the first place.
18:26:49 <aphyr> It's from Network.recv
18:26:54 <shachaf> Given that a String contains Unicode codepoints, not bytes.
18:27:11 <ivanm> shachaf: agreed
18:27:36 <shachaf> @hackage network-bytestring
18:27:36 <lambdabot> http://hackage.haskell.org/package/network-bytestring
18:27:44 <ivanm> shachaf: isn't that merged into network now?
18:27:51 <ivanm> aphyr: do you mean recvFrom?
18:27:51 <aphyr> Says it's obsolete, replaced by network.
18:27:52 <kmc> aphyr, String doesn't contain bytes; it contains characters
18:27:59 <ivanm> the Network module doens't have a recv function
18:28:00 <kmc> aphyr, use ByteString IO on that Handle
18:28:05 <aphyr> Yeah, I figured. I'm pretty confused by all this.
18:28:14 <shachaf> ivanm: Oh, I guess.
18:28:16 <aphyr> Ah, sorry, Network.Socket.recv.
18:28:18 <ivanm> aphyr: Network.Socket.ByteString, etc.
18:28:38 <ivanm> aphyr: the docs say: Do not use the send and recv functions defined in this module in new code, as they incorrectly represent binary data as a Unicode string. As a result, these functions are inefficient and may lead to bugs in the program. Instead use the send and recv  functions defined in the Network.Socket.ByteString module.
18:28:46 <aphyr> Ah, sweet.
18:32:21 <aphyr> OK. So... is there an analogue to pack/unpack? Or erlang-style byte syntax?
18:34:10 <ivanm> aphyr: what do you mean by an "analogue" ?
18:34:21 <ivanm> you can get the individual bytes from the ByteString
18:34:26 <ivanm> @hoogle ByteString -> [Word8]
18:34:27 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
18:34:27 <lambdabot> Data.ByteString.Lazy unpack :: ByteString -> [Word8]
18:34:27 <lambdabot> Data.ByteString head :: ByteString -> Word8
18:34:43 <ivanm> oh, right, that _is_ unpack :p
18:35:19 <ivanm> so... get the first two bytes, and create the Int from that (with the appropriate endianness)
18:35:39 <kmc> if you have a bunch of them, and care a lot about efficiency
18:35:48 <kmc> you can convert ByteString to vector's Data.Vector.Storable
18:35:50 <kmc> without a copy
18:36:17 <aphyr> I don't think that's necessary for now. Just want to transform my ByteString to an Int.
18:37:04 <ivanm> what, the entire thing?
18:37:16 <aphyr> Uh, it's a network daemon.
18:37:27 <aphyr> Reads a 2-byte length header, and a message, then repeats.
18:37:45 <aphyr> in ruby: socket.read(2).unpack('n').first
18:37:45 <ivanm> so, may I suggest a parsing library such as attoparsec or polyparse?
18:37:59 <aphyr> I'm not familiar, but certainly willing to look into those!
18:38:01 <shachaf> You can also use Data.Binary.
18:38:05 <aphyr> Was going to use protobuffs for the payload.
18:38:37 <ivanm> shachaf: I found Data.Binary to be painful for custom encodings
18:38:59 <shachaf> ivanm: Sure, but it's not painful for getting an unsigned big-endian integer from a ByteString. :-)
18:39:10 <ion> There’s Data.Serialize as well.
18:40:08 <shachaf> s/Sure, but i/I/
18:40:21 <ivanm> possibly
18:40:35 <shachaf> λ> :t runGet getWord16be
18:40:35 <shachaf> runGet getWord16be :: LB8.ByteString -> Word16
18:40:38 <ivanm> but if aphyr has a recursive encoding to parse, I found it annoying
18:40:57 * shachaf has never used Data.Binary so doesn't know.
18:42:22 <ivanm> shachaf: well, for starters you need to do the loop yourself...
18:42:28 <aphyr> shachaf: ah, looks promising.
18:42:53 <aphyr> ivanm: Just a linear sequence: [size][message][size][message]...
18:43:14 <shachaf> Maybe you want iteratees!
18:43:19 <ivanm> aphyr: right, but it still repeates
18:43:28 <kfish> everone wants iteratees
18:43:36 <ivanm> and you presumably want it to keep looping until it consumes the entire ByteString
18:43:42 <ivanm> kfish: eh, I'm trying not to :p
18:43:49 <aphyr> Is that problematic? I was planning to just have my receive function recurse into itself, yeah, until socket closed.
18:43:53 <kfish> :)
18:44:29 <ivanm> aphyr: right, which is what I meant: with Get, you have to do that by hand; with a parsing library you can just do "many getMessage" or something to get it to parse all of them for you
18:44:48 <aphyr> I think I'm OK with tail recursion, haha.
18:44:59 <aphyr> I've written some nontrivial erlang, but wrapping my head around haskellland is... tricky.
18:45:24 <aphyr> Seems like there are a hundred ways to do everything, and none of them use the same types, haha
18:45:26 <ivanm> aphyr: the point is: you shouldn't have to recurse manually
18:45:32 <ddarius> Iteratees are just a poor man's concurrency monad.
18:45:36 <aphyr> It's eight characters. It's not that hard.
18:45:41 <ivanm> HOFs mean you should be able to use a pre-defined recursing function
18:45:48 <aphyr> I trust the compiler is tail-recursive
18:45:51 <ivanm> nope
18:45:54 <aphyr> Oh.
18:45:57 <ivanm> if by "tail-recursive" you mean TCO
18:45:59 <roconnor> heh. If you are used to tail-recursion, you are in big trouble in Haskell =D
18:45:59 <aphyr> Yes.
18:46:09 <ivanm> laziness doesn't play nicely with TCO
18:46:13 <ddarius> roconnor: No you're not.
18:46:17 <aphyr> Haha, could you enlighten me? I've read a few hundred pages of Learn You Some Haskell, but haven't picked up everything yet.
18:46:23 <ddarius> ivanm: Laziness is completely orthogonal to TCO.
18:46:26 <monochrom> "tail recursion" means nothing here
18:46:34 <ivanm> ddarius: I thought that was the main reason given about why GHC doesn't do TCO
18:46:43 <ddarius> ivanm: GHC does "do" TCO.
18:47:00 <roconnor> ddarius: people comeing from ML often write left folds when right folds would give better preformance.
18:47:19 <ddarius> roconnor: That's true.
18:47:25 <ivanm> ddarius: oh, am I mixing it up with TCE ?
18:47:31 <aphyr> (roconnor: if I'm following along correctly, because of the inversion problem due to list pointer direction?)
18:47:51 <ddarius> ivanm: I don't know what you mean by "TCE."
18:47:51 <ski> ddarius : "Functional Pearls: A Poor Man's Concurrency Monad", Koen Claessen, <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.39.8039> is iteratees ?
18:48:04 <ivanm> tail call elimination (which I thought was the same thing...)
18:48:12 <roconnor> aphyr: not really.  It is due to the fact that in haskell it is better to do guared recursion rather than tail recursion when possible. ...
18:48:12 <ddarius> It is as far as I know.
18:48:22 <roconnor> *guarded recursion
18:48:52 <roconnor> aphyr: Guarded recursion is when the recursive call is underneath or "guarded" by some constructor.
18:48:58 <monochrom> no, it is better to know ghc's evaluation order and execution order properly
18:49:21 <monochrom> and I carefully say it's ghc's rather than haskell's
18:49:30 <roconnor> aphyr: Guarded recursion means that the recursive call gets suspended until the constructor guarding the call is consumed by a pattern match.
18:49:41 <ddarius> monochrom: I agree with your first statement but less so with your second.
18:49:59 <roconnor> aphyr: this suspection allows other computation to proceed, often freeing up memory in the process.
18:50:10 <roconnor> aphyr: it is also what makes processing infinite sturctures possible.
18:50:26 <ski> knowing about tail calls is useful for knowing to write `Cont ma >>= amb = Cont (\k -> ma (\a -> runCont (amb a) k))' instead of `Cont ma >>= amb = Cont (\k -> ma (\a -> runCont (amb a) (\b -> k b)))', e.g.
18:50:30 <aphyr> Got it. Thank you.
18:51:02 <DukeDave> Boo: setup: happy version >=1.17 is required but it could not be found.
18:51:13 * DukeDave is trying to cabal install hlint
18:51:18 <ivanm> DukeDave: if that's from cabal-install, it doesn't automatically get happy for you
18:51:23 <ivanm> you need to build it explicitly
18:51:28 <zeta-> I've just upgraded to ghc 7.0.4 : Should I remove my distro's llvm package? as it is now included in ghc 7
18:52:04 <DukeDave> ivanm: Hehe, but I always get happy when I use cabal :D
18:52:27 <ivanm> *groan*
18:52:45 <ivanm> zeta-: ummm.... last I checked it wasn't...
18:53:10 <thoughtpolice> zeta-: llvm is not included with ghc. you need to have it installed for the LLVM backend to work
18:53:13 <thoughtpolice> (it's not on by default)
18:53:15 <ivanm> GHC has an LLVM backend, but still needs LLVM installed (2.7 if memory serves)
18:53:51 <ddarius> ski: As far as I can tell, the main thing iteratee libraries can provide that you can't trivially do with external iterations (e.g. handle based IO) is "forking" a stream to two consumers in a manner that keeps them in lock-step.
18:54:03 <roconnor> @type foldr
18:54:04 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:54:27 <roconnor> today I realized that foldr can be seen as a monoidal fold on endomorphisms
18:55:00 <ddarius> The various views of monoid actions.
18:55:10 <roconnor> @type flip . foldr
18:55:11 <lambdabot> forall b a. (a -> b -> b) -> [a] -> b -> b
18:55:37 <zeta-> ivanm: OK that makes sense, but is http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM a little misleading? what changed in 7.0?
18:55:51 <roconnor> @type Endo . flip . foldr . (Endo .)
18:55:52 <lambdabot>     Couldn't match expected type `b -> b' against inferred type `[a]'
18:55:52 <lambdabot>       Expected type: b -> (b -> b) -> b
18:55:53 <lambdabot>       Inferred type: b -> [a] -> b
18:56:03 <ivanm> zeta-: it _targets_ LLVM
18:56:17 <ivanm> but it still needs the actual LLVM to be able to run it, etc.
18:56:17 <ski> ddarius : i see
18:56:30 <roconnor> @type Endo . flip . foldr
18:56:30 <lambdabot>     Couldn't match expected type `b -> b' against inferred type `[a]'
18:56:31 <lambdabot>       Expected type: (a -> b -> b) -> b -> (b -> b) -> b
18:56:31 <lambdabot>       Inferred type: (a -> b -> b) -> b -> [a] -> b
18:57:21 <thoughtpolice> zeta-: the LLVM backend was included in ghc 7.0. with it, GHC generates llvm bitcode. but you need the actual LLVM toolchain installed to compile that bitcode to native code.
18:57:22 <ski> @type (Endo .) . flip . foldr . (appEndo .)
18:57:23 <lambdabot> forall a a1. (a1 -> Endo a) -> [a1] -> Endo a
18:57:49 <roconnor> ski: thanks
18:57:51 <Lycurgus> does 7.2 break much stuff?
18:58:07 <thoughtpolice> zeta-: that page is not misleading either, if you follow the install link which goes here: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/Backends/LLVM/Installing <- it states you need the llvm toolchain somewhere in your $PATH, but that's about it
18:58:19 <thoughtpolice> if you have that you should be fine
18:58:31 <zeta-> ivanm: Ah 'it' refers to the code generator.
18:58:39 <ivanm> yeah
18:58:46 <thoughtpolice> Lycurgus: there's bound to be plenty of breakages right now, a lot of updates haven't hit hackage so things will fail to build due to various constraints
18:58:55 <ski> roconnor : i think it's relatively common to use `foldr' this way
18:59:00 <aavogt> how do people handle array bounds dealing with FFI code?
18:59:06 <aphyr> Ahhhh, Data.ByteString.Parser!
18:59:16 <gienah> Lycurgus: ghc 7.2.1 does break some things, some stuff has already been fixed though (like uniplate, scrap your boilerplate with class)
18:59:35 * ski e.g. sees `fun fold x y z = List.foldr x z y' in the MetaML source
19:00:15 <thoughtpolice> 7.2.1 adds good stuff though. :D i suspect lots of people will eventually start using the new generics stuff, on that note
19:00:20 <Lycurgus> thx, thoughtpolice, gienah
19:00:44 <Lycurgus> I'm glad I made an account to install it in
19:01:28 <Lycurgus> preliminary impression is that it will break bunches of stuff
19:02:05 <thoughtpolice> breakages normally get fixed pretty fast
19:02:23 <Lycurgus> true, it's only two days out
19:02:26 <Saizan> some macros expert should help SPJ sort the newName mess.
19:03:12 * gienah thinks Saizan is referring to this template-haskell change: http://hackage.haskell.org/trac/ghc/ticket/5398
19:03:27 <Saizan> yep
19:05:29 <aavogt> Saizan: I always though newName generated a fresh name you had to refer to by the result Name, and it works just fine (if a bit inconvenient sometimes) to assume that
19:06:02 <Lycurgus> i guess DPH makes it worth it if it works itself
19:06:11 <Saizan> aavogt: right, they instead changed so that you could refer to a name generated by newName "foo" by using mkName "foo"
19:06:37 <ski> Saizan : i'd assume hygienic macro experts in Scheme would probably be the best ..
19:07:26 <monochrom> there were a lot of macro experts among msword users :)
19:07:26 <Saizan> aavogt: mostly so that in [| \x -> $( .. ) |] you could refer to that x in .. by mkName "x", since that quotation is translated with newName
19:07:46 <ski> monochrom : but presumably no hygienic ones ? :)
19:08:36 <ski> Saizan : obviously you ought to refer to that by `[| x |]' .. no ?
19:08:49 <monochrom> msword users tend to be white collars with strict dress code and hygiene code
19:08:55 <Saizan> ski: yeah, or by 'x if you want the Name
19:09:36 <Saizan> ski: but in those tickets SPJ also makes a point about quoted data declarations which i don't fully follow
19:14:38 <ddarius_> @tell roconnor I recommend (re)reading section 4.2 of Barr and Wells' ESSLLI lecture notes.
19:14:38 <lambdabot> Consider it noted.
19:15:49 <aavogt> Saizan: is there some way to refer in TH to the type aliases here http://hackage.haskell.org/package/type-level-0.2.4 such that I don't need to re-export that Aliases module?
19:15:49 <aavogt> basically I want the same effect as    ''D1234, but I have    1234 as an Int
19:15:49 <aavogt> and it would be nice to write the types as the shorter alias, rather than     D1 :* D2 :* D3 :* D4   (which I can get from dec2TypeLevel)
19:15:50 <Phyx-> Hi, I'm getting an unexpected error http://pastebin.com/TTUziXkF, however I never import or re-export the offending module. So i don't understand why i'm getting the error
19:15:50 <ddarius> @tell roconnor I recommend (re)reading section 4.2 of Barr and Wells' ESSLLI lecture notes.
19:15:52 <mauke> The paste TTUziXkF has been copied to http://hpaste.org/50204
19:15:56 <lambdabot> Consider it noted.
19:16:05 <edwardk> hah. i realized the one flaw with my quest to simplify a lot of code by eliminating do sugar. ; effectively has lower fixity than $ and <?> etc. but nothing i write combinator wise can
19:16:23 <aavogt> Phyx-: you indirectly import both modules, no?
19:16:34 <ddarius_> edwardk: Yes, that is one of the benefits of do-notation.
19:17:23 <aavogt> 10 fixity levels ought to be enough for anyone
19:17:25 <ddarius> That was interesting.
19:18:26 <Phyx-> aavogt: yes, but don't i have to explicitly re-export the module in question in order to expose the instance?
19:19:44 <aavogt> right, you can't control the export of instances
19:21:08 <Phyx-> so if a module imports a module, and I import that module, i automatically get the instances too?
19:21:13 <Phyx-> that seems rather broken to me
19:21:56 <ddarius> Phyx-: Instances are global.=
19:21:59 <edwardk> phyx-: it turns out to be VERY necessary
19:22:24 <edwardk> phyx-: without it you can do things like get Sets that one module sorted one way and hands off to another module, which thinks its sorted another way
19:22:45 <ski> Saizan : Plan A seems more sane than Plan B, to me
19:23:02 <edwardk> @hpaste
19:23:02 <lambdabot> Haskell pastebin: http://hpaste.org/
19:23:03 <ski> Saizan : which point were you thinking about ?
19:23:46 * hackagebot trifecta 0.21 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.21 (EdwardKmett)
19:24:28 <ivanm> edwardk: do you have docs yet?
19:24:30 <ivanm> ;)
19:24:44 <ski> aavogt : i demand at least one precedence for each surreal number !
19:24:45 <mustelo> edwardk, same question.
19:24:55 <thoughtpolice> edwardk: zounds! i actually tested out trifecta 0.21 a few hours ago :D i can't wait until you're done.
19:25:00 <ddarius> edwardk: Please write a user manual even though you don't have a 1.0 release.
19:25:24 <thoughtpolice> he's the most popular man around right now, clearly.
19:25:36 * ivanm thinks edwardk treats hackage as a secondary VCS in case github goes down, going by how often he makes a release
19:25:57 <ivanm> thoughtpolice: he just released 0.21, so how did you test it a few hours ago? :/
19:25:57 <Phyx-> edwardk: yes, i get that, but it's rather annoying and now I have to recompile ghc just for this
19:26:00 <Phyx-> bah
19:26:07 <thoughtpolice> ivanm: github
19:26:22 <ivanm> thoughtpolice: oh, using HEAD?
19:26:25 <thoughtpolice> (the version was already bumped technically) - actually it was also apparently about an hour ago :P
19:26:39 <ivanm> huh, hackagebot is just slow then...
19:27:05 <thoughtpolice> ivanm: er, well, it was only in github at the time. i just built locally and looked through the source.
19:27:09 <edwardk> ivanm: hahahaha
19:27:16 <edwardk> thoughtpolice: its coming together slowly
19:27:19 <edwardk> @hpaste
19:27:20 <lambdabot> Haskell pastebin: http://hpaste.org/
19:27:33 <ivanm> thoughtpolice: *nod*
19:27:44 <hpaste> edwardk pasted “diagnostic swallowing” at http://hpaste.org/50205
19:27:47 <thoughtpolice> edwardk: yeah, i was just testing out the diagnostics class stuff and seeing how the combinators and stuff fit together so far
19:27:57 <edwardk> trying to figure out why that is happening
19:27:57 <Saizan> aavogt: have you tried mkName $ "D" ++ show 1234 ?
19:28:00 <ivanm> edwardk: well, you _do_ seem to go "here's another new feature, time for a release!"
19:28:07 <edwardk> the fatal error is killing all the others in the log
19:28:45 <edwardk> i realize i'm throwing the exception but the log is maintained by the monad and should be merging together
19:28:51 <ddarius> Ed is showing RMS and ESR how it's done.
19:29:16 * ivanm -> tutoring
19:29:19 <Phyx-> edwardk: shouldn't IncoherentInstances and UndecidableInstances allow me to compile anyway?
19:29:38 <edwardk> phyx-: if you think that is a good idea, good luck ;)
19:29:49 <edwardk> compiling and working are different things
19:30:17 <aavogt> Saizan: that works, except I need to re-export the module which defines that D. I'm looking for writing a  (NameG NameSpace PkgName ModName)  so things don't break if you don't have the D1234 in scope at the moment
19:30:30 <edwardk> thoughtpolice: i started adding some better combinators for putting those together
19:30:43 <edwardk> thoughtpolice: so now you can mapped renderings, etc.
19:30:46 <edwardk> er mappend
19:30:56 <Phyx-> edwardk: the instances are both exactly the same, it should work fine, but even with those pragmas it's giving the error
19:31:24 <edwardk> instances infect. the problem is the compiler has no way to know those instances are the same
19:31:38 <edwardk> this is why orphan instances are almost ALWAYS a bad idea
19:31:40 <thoughtpolice> edwardk: yeah i noticed. i'm just having fun :D are you basically going to end up reimplementing most of parsec? i noticed you dropped the ParserT stuff from parsec
19:31:49 <edwardk> i already did
19:31:59 <thoughtpolice> oh, i was really just wondering if that was all of it :P
19:32:00 <edwardk> look at the current build ;)
19:32:04 <ddarius> Parsec isn't a large library.
19:32:07 <edwardk> i skipped the permutation parsers
19:32:19 <edwardk> i also brought in my charset code from another project
19:32:38 <edwardk> so you have fast sets and the ability to look up posix and unicode standard character classes and blocks, for generating parsers
19:33:28 <Saizan> ski: the one in #5375
19:33:56 <edwardk> can another set of eyes spot why the exceptions thrown by https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Parser/Prim.hs#L134 are eating my error log?
19:33:59 <Phyx-> edwardk: k, well thanks then, i'll just recompile ghc and remove the instance
19:34:20 <Saizan> ski: also, here http://hackage.haskell.org/trac/ghc/ticket/5398#comment:1 <- i think he means "A consequence of PLAN A .." rather than "PLAN B", and that wouldn't be a nice consequence
19:35:03 <Saizan> ski: i.e. i feel like toplevel binders should be treated specially if we go with PLAN A, which otherwise seems more reasonable
19:35:15 <Saizan> ski: though i'm not sure how to really justify this
19:36:09 <aavogt> Saizan: it works to change the OccName inside  ''D123 to contain the  number I want
19:38:10 <edwardk> think i'm just going to add the log to the monad and give up on threading it through ErrState
19:45:15 <ski> Saizan : afaict, they do mean "A consequence of PLAN B .."
19:47:16 <shachaf> edwardk: When's Hac-Beans-or-whatever-you're-going-to-call-it going to happen?
19:48:10 <Saizan> ski: but it works in 7.2.1 which is supposed to use PLAN B
19:49:04 <edwardk> shachaf: still need a venue
19:49:23 * shachaf would suggest somewhere in CA.
19:49:46 <ski> Saizan : hum, maybe you're right
19:50:08 <fengshaun> what number of spaces (for indentation) is the most common among haskell programmers?
19:50:22 <edwardk> fengshaun: varies greatly. i use 2
19:50:28 <edwardk> i used to use 4
19:50:39 <ski> Saizan : in any case, imio, `mkName' appears bad
19:50:43 <shachaf> TABS FOR EVERYTHING
19:50:53 * shachaf uses 4, usually, but sometimes 2 for "small" indentations.
19:51:03 * ski uses two, mostly
19:51:06 <fengshaun> edwardk: yea, I was thinking 2 makes the code look nicer.
19:51:19 <fengshaun> 2 it is, then.  Thanks a lot!
19:52:01 <cmccann> anyone up for some overwrought type-hackery?
19:52:05 <edwardk> it works well with the prevalence of one letter identifiers, f a puts the a at the same indentation as the next line of code ;)
19:52:50 <cmccann> I spent way, way too long on this, so I'm gonna bother people about reading it http://stackoverflow.com/questions/7030476/haskell-function-with-both-an-arbitrary-number-of-arguments-and-io/7035253#7035253
19:53:19 <shachaf> cmccann earns every one of his stackoverflow medals.
19:53:39 <cmccann> shachaf, well, don't say that until you've read it
19:53:48 <cmccann> and I know you haven't because holy crap it's long
19:55:04 * ski thinks `id' is a function with arbitrary number of arguments and `IO'
19:57:59 <HalfWayMan> I upped cmccann's post just for it's shear verbosity :)
20:05:23 * shachaf wants something with infixity lower than $. :-(
20:09:12 <ski> join the "a precedence for every surreal" campaign ?
20:09:37 * shachaf has grown to like $ less and less as time has gone by.
20:11:40 * ddarius joins the "a precedence for every surreal" game, but as left or right?
20:12:00 <ddarius> shachaf: Do you have a wife?
20:12:34 <shachaf> ddarius: Not as far as I know. Should I?
20:13:04 <ddarius> shachaf: That's up to you, but it may change how much you like $.
20:13:35 * shachaf wonders if ddarius speaks from experience.
20:13:44 <drbean> $ is good in zipWith ($) fs args
20:14:01 <kmc> (¥)
20:14:26 <kmc> drbean, you can just as well write «zipWith id» except that it's harder to read
20:15:12 <edwardk> schachaf: ;
20:15:44 <shachaf> ddarius: "id" is one character shorter.
20:15:48 <shachaf> s/ddarius/drbean/
20:15:59 <shachaf> Anyway, I'll grant you that sections of $ are sometimes useful.
20:16:24 <shachaf> Except for left(/right, whichever one the useless one is called) sections
20:17:17 <ski> ddarius : well, do you want an `infixl' or `infixr' operator
20:17:24 <ski> ?
20:17:48 <ski> (which leaves the option `infix' unexplained ..)
20:20:14 <ricree> cmccann:  That's a really, really impressive answer
20:20:30 <HalfWayMan> shachaf: Sections as in ($ arg) or (fn $)? In which case, how is either useless? I don't understand :(
20:20:33 <cmccann> ricree, oh, that was your question, right?
20:20:37 <ricree> yees
20:20:46 <edwardk> (fn $) is kinda silly
20:21:05 <edwardk> (fn $) = fn
20:21:09 <cmccann> ricree, ok, glad you liked it!
20:21:27 * cmccann is thinking of tossing the full code from his example on github or something
20:21:29 <edwardk> the only real use would be if you want to use it to force it to be a function rather than some other type constructor
20:21:35 <ricree> cmccann, always nice to be reminded how much more there is to learn
20:21:36 <edwardk> but even thats silly
20:21:36 <mustelo> cmccann, please do that
20:23:09 <HalfWayMan> edwardk: Force function vs. type constructor? What would be the difference?
20:23:38 <edwardk> the only real reason i can think of is for really terrible asTypeOf-like games
20:23:39 <edwardk> =P
20:23:48 <kmc> :t (runST $)
20:23:49 <edwardk> in short, no practical use
20:23:49 <lambdabot> forall a. (forall s. ST s a) -> a
20:25:05 <Saizan> so you use ScopedTypeVariables these days?
20:25:18 <edwardk> rarely =)
20:25:21 <HalfWayMan> edwardk: How would (asTypeOf) be different to (asTypeOf $)? Or am I being stupid?
20:25:46 <Saizan> ?type \x -> x
20:25:47 <lambdabot> forall t. t -> t
20:25:54 <Saizan> ?type \x -> (x$)
20:25:54 <edwardk> halfwayman: in the guts of the reflection package i wind up using a bunch of asFoo combinators to force one type to match up with another
20:25:55 <lambdabot> forall a b. (a -> b) -> a -> b
20:26:22 <edwardk> halfwayman: the (x$) could be used in a similar fashion
20:26:43 <edwardk> not very usefully
20:26:44 <edwardk> but still
20:28:16 <Saizan> i.e. it'd just force x to have a function type
20:28:22 <HalfWayMan> I'm obviouslt missing something...
20:29:09 <HalfWayMan> Just type trickery?
20:29:12 <edwardk> you're making a way bigger deal out of this than there is. it literally just requires the type to be a function type.
20:29:20 <edwardk> whereas previously i could have unified it with Int, etc.
20:29:28 * ski thinks the example in <http://hackage.haskell.org/trac/ghc/ticket/4429#comment:5> sounds wrong
20:30:18 <Axman6> well, the indentation is wrong...
20:30:50 <ivanm> Axman6: oh? where?
20:31:02 <ivanm> I thought you were allowed to have the entire module indented like that
20:31:11 <Axman6> really?
20:31:19 * ski does that all the time
20:31:23 <Axman6> i thought all top level declararions had to start with no indent
20:31:26 <Axman6> D:
20:31:30 <ivanm> Axman6: with the _same_ indent
20:31:32 <ski>   module Foo
20:31:34 <ski>     where
20:31:36 <ski>     ...
20:31:42 <Axman6> huh, interesting
20:31:47 * Axman6 -> food
20:31:50 <ivanm> ski obviously doesn't have to worry about long lines :p
20:31:55 <ivanm> Axman6: yeah, I'm thinking that as well
20:31:56 <ski> it's just an ordinary `where'-clause, more or less
20:31:57 <ivanm> you on campus?
20:32:06 <edwardk> the 'where' in the module definition opens a layout rule
20:32:10 <Axman6> nah, home... just woke up >_>
20:32:11 <atomie> I'm making a Haskell wrapper around the libsmbclient library. I'm new to FFI and friends, and am getting errors. I can't seem to successfuly import a foreign function. Maybe you'll see an obvious mistake I'm making? Here's a paste:
20:32:22 <hpaste> test pasted “foreign import undefined references” at http://hpaste.org/50206
20:32:29 <ski> ivanm : i try to keep lines below 70 characters, why ?
20:33:12 <ivanm> ski: well, you've already lost a couple of characters
20:33:14 <Axman6> atomie: that looks like a problem during linking?
20:33:20 <thoughtpolice> atomie: you have to tell ghc to link with the smbclient library
20:33:25 <Axman6> atomie: are you using the appropriate linker flags?
20:33:33 <ski> Axman6 : what i objected to was more the unhygienic capture of `muggle', there
20:34:10 <atomie> Axman6: I'm not. I assumed it would work magically since it worked for math.h, but I guess math.h is special? How do I tell ghc to link with smbclient?
20:34:45 <ivanm> all I know about FFI is that there's a chapter on it in RWH :p
20:34:58 <atomie> ivanm: That's where I came from! :D
20:35:49 <ivanm> edwardk: why does your parser use parsec?
20:35:55 <ivanm> just for some definitions?
20:36:01 <edwardk> i haven't removed the dependency woops
20:36:10 <edwardk> it used to be built on top
20:36:32 <ivanm> heh
20:37:41 <atomie> Linking is done with "-lsmbclient", just like usual.
20:37:49 <atomie> Thanks for the tips, guys and gals!
20:41:56 <edwardk> yay the diagnostic log works right now!
20:43:21 <Axman6> atomie: math.h is usually provided by the compiler, and always in scope. and the problem is notthe headers, it's the libraries not being found
20:47:29 <ivanm> dammit, I just realised that John Lato's solution to my SO question does the wrong thing :(
20:47:51 <edwardk> i wish there was a way to get cabal to warn when you state a dependency on a package that you don't actually depend on
20:48:55 <edwardk> tricky because you might put a version number in even though you don't use something directly to keep from linking with someone who uses the older version or something
20:49:11 <edwardk> ivanm: parsec dependency dropped
20:50:29 <ivanm> edwardk: OK, so now I just have to convince you to drop all of your semigroups, etc. packages :p
20:50:41 <edwardk> uh hell no
20:51:17 <edwardk> heck the pretty printer it uses uses <> from semigroups directly
20:51:38 <edwardk> so the whole thing would kinda suck without that =P
20:51:38 * cmccann decides to include a frivolous dependency on the newtype package in his type hackery example, just to annoy people
20:51:39 <ivanm> heh
20:51:52 <ivanm> is <> just mappend ?
20:51:59 <edwardk> sure
20:52:09 <edwardk> but it isn't required to have a mempty
20:52:16 <ivanm> ahhh, OK
20:52:31 <edwardk> i use it on some types in the library where i can concatenate them but not construct them out of whole cloth
20:52:42 <ivanm> I meant literally though (as in (<>) = mappend)
20:52:47 <edwardk> nah
20:53:06 <edwardk> class Semigroup s where (<>) :: s -> s -> s; (and a couple other things that are irrelevant and freely defined)
20:53:28 <edwardk> igloo!
20:53:54 * hackagebot trifecta 0.22 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.22 (EdwardKmett)
20:53:56 * hackagebot trifecta 0.23 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.23 (EdwardKmett)
20:54:44 <ivanm> edwardk: do you ever consider getting a library to a usable state before releasing? :p
20:54:55 <edwardk> ivanm: =P
20:54:57 <shachaf> Code that edwardk writes is by definition usable.
20:55:19 <ivanm> or at least leave a big enough gap such that Hackage has time to build docs for the previous version so people can get an idea of wtf it does? :p
20:55:39 <cmccann> I think about 90% of edwardk's code is of the "so generic, if it typechecks it must work" variety
20:55:42 <edwardk> hack age can't build the docs until i can get igloo to bump the base limit on unix =(
20:55:52 <ivanm> ahhh, I was about to ask that
20:56:02 <ivanm> cmccann: yeah
20:56:15 <HalfWayMan> Code that edwardk writes is by definition, to me, unintelligable :)
20:56:35 <ivanm> s/me/most people/
20:56:36 <ivanm> :p
20:56:39 <HalfWayMan> Haha :)
20:57:31 <cmccann> HalfWayMan, my own code is scary enough that nothing else bothers me much :]
20:57:57 <HalfWayMan> cmccann: Somtimes I barely why my code even works.
20:58:22 <HalfWayMan> Luckily I had luite to explain the difference between f and (f $) :)
20:59:21 <HalfWayMan> The old (->) constructor is one that I always fail to grasp.
21:00:19 <kmc> type constructor?
21:00:33 <HalfWayMan> kmc: What?
21:00:55 <atomie> HalfWayMan: Difference between f and (f $)? There is a difference?
21:01:08 <HalfWayMan> atomie: I didn't think so.
21:01:10 <edwardk> oh noes, it starts again
21:01:21 <cmccann> it keeps happening :[
21:01:40 <cmccann> edwardk, hey, did you see my nonsense with type families earlier? :D
21:01:41 <Axman6> $ception
21:01:54 <edwardk> fraid not
21:02:00 <edwardk> been head down trying to get parser code working
21:02:15 <Axman6> me too!
21:02:22 * Axman6 sucks at parsers apparently :(
21:02:52 <Axman6> i got it working, but i need to rewrite it once i've figured out how to avoid left recursion in my grammar
21:03:04 <cmccann> edwardk, https://github.com/isomorphism/evangelist
21:04:11 <cmccann> wrote a lengthy SO answer showing how to use type families to do some stuff, cleaned up the example code and just put it on github
21:04:54 <edwardk> cute
21:05:06 <cmccann> ricree, if you're still around, I just uploaded the rest of my code on github
21:05:26 <cmccann> yeah, it was pretty fun to hack together :]
21:07:04 <kmc> HalfWayMan, trying to understand the context of "The old (->) constructor is one that I always fail to grasp."
21:07:26 <kmc> the difference between x and (x $) is that the latter forces x to have a function type
21:07:40 <kmc> that is all, in H98
21:07:48 <kmc> (x $) might wreck Rank2Types or other extensions
21:07:52 <ricree> cmccann, cool.  thanks
21:08:04 <edwardk> kmc: on some compilers
21:08:16 <edwardk> kmc: it has alternated in and out in ghc, currently it works
21:08:19 <kmc> yeah
21:08:33 <kmc> does it generally work, or only for Control.Monad.ST.runST and (Prelude.$) specifically
21:08:38 <edwardk> but flip ($) foo runST doesn't =)
21:08:42 <kmc> yeah :/
21:08:53 <edwardk> its only the id type basically
21:08:58 <kmc> i see
21:09:14 <cmccann> ricree, if you feel like using my code directly rather than writing something simpler for yourself, feel free to let me know if there's anything important missing :]
21:09:19 <shachaf> > id runST (return True)
21:09:20 <lambdabot>   Couldn't match expected type `m GHC.Bool.Bool'
21:09:21 <lambdabot>         against inferred typ...
21:09:40 <edwardk> there are various simple ways to deal with universal quantification that let it work for the flip case like HMF, but they don't play nice with the equality constraints and other nonsense we get
21:10:44 <kmc> would this get better or worse if we scrapped all the special cases for dependent types?
21:10:50 <kmc> i gather inference in Agda is kind of touch-and-go
21:11:27 <edwardk> most likely worse =P
21:11:45 <edwardk> what is this inference of which you speak? basically it handles applications but you annotate all the top level types
21:13:22 <ricree> cmccann, out of curiosity, where is the repo?  I checked cmccann on github, but there were no public repositories under that name
21:13:47 <cmccann> the impression I got from a little bit of playing with agda was that it mostly uses the fact that the types are very detailed to grab obvious type arguments in a way that looks like inference if you don't peek behind the curtain :P
21:13:54 * hackagebot gtk-traymanager 0.1.0 - A wrapper around the eggtraymanager library for Linux system trays  http://hackage.haskell.org/package/gtk-traymanager-0.1.0 (TristanRavitch)
21:14:14 <cmccann> ricree, oh, sorry, it's https://github.com/isomorphism/evangelist
21:16:50 <luite> yay downloaded over 15000 packages from hackage :)
21:17:15 <edwardk> heh i wonder if i've uploaded that many yet ;)
21:17:30 <ivanm> edwardk: you? easily :p
21:17:44 <edwardk> =)
21:17:45 <luite> hehe there are 15903 in my index file
21:18:01 <ivanm> maybe not then...
21:19:43 <luite> http://hdiff.luite.com/cgit/trifecta/diff?id=0.8&id2=0.9
21:20:48 <ivanm> ooooohhhhh....
21:21:05 <ivanm> luite: ideally, though, you wouldn't be having your name up the type making it look like you wrote all of hackage :p
21:21:13 <luite> but I did!
21:21:14 <luite> :p
21:21:17 <ivanm> and it has "unnamed repository" up the top
21:21:57 <ivanm> you could always use Cabal to parse the .cabal file of each new one you add in to get its synopsis
21:22:05 <luite> yeah it's just a first version, it's probably also committed some things in the wrong order. won't matter if you request a diff with version numbers in the url, but the parentl links are probably messed up
21:22:24 <luite> it's still downloading the last packages from hackage :)
21:22:45 <ivanm> *nod*
21:23:13 <ivanm> is it possible to customise cgit to avoid presenting the actual git repo? or is that too much work? :p
21:24:11 <luite> I think I've already disabled downloading and the git urls
21:24:24 <luite> but it should be possible to add some comment in the header or something :)
21:24:55 <luite> ah trifecta already shows the wrong order of commits
21:25:09 <ivanm> yeah, I see what you mean about ordering possibly being wrong: for graphviz it has 2008.7.11 before .10 :/
21:25:09 <luite> 0.1 -> 0.10 -> 0.11 -> ... -> 0.16.1 -> 0.2
21:27:56 <huangyi> what's the problem with  left associate (++), e.g. (("aaa"++"bbb")++"ccc")+"ddd"
21:28:22 <ivanm> huangyi: OK, to do ("aaa"++"bbb") it copies all of "aaa" onto the front of "bbb" to get "aaabbb"
21:28:35 <huangyi> (++) is lazy, so complexity ifself should be O(1), not?
21:28:48 <ivanm> then it does "aaabbb"++"ccc", so it copies all of the first string to the front of the second
21:28:50 <huangyi> Only travering the list cost O(n)
21:28:57 <ivanm> but note now that the "aaa" is being copied _twice_
21:29:14 <ivanm> then when we do the ++"ddd", the "aaa" is copied a third time, and the "bbb" a second time
21:29:28 <mustelo> huangyi, you're right that it's lazy, but it doesn't cancel duplicate work, just delays it until it's needed
21:29:52 <ivanm> yeah, what mustelo said
21:29:58 <ivanm> so the extra work is being done
21:30:15 <ivanm> if you want to keep appending stuff, get a better data structure: DList, Seq, etc.
21:30:44 <mustelo> or rephrase the algorithm (I wasn't paying attention to the context here)
21:31:35 <ivanm> mustelo: no algorithm mentioned; just why you don't want to do left-associative ++
21:31:40 <luite> ivanm: there are probably lots of other tweaks to make it better, I can try to adjust the commit times to match the original upload time
21:32:16 <ivanm> luite: oooohhh...
21:32:30 <luite> although I have no idea where to get tat information :)
21:32:50 <ivanm> heh
21:33:01 <ivanm> or just do version-based comparison to re-order?
21:33:11 <luite> oh I know, the upload log
21:33:13 <ivanm> (ignore when, just re-order all the commits in a repo _now)
21:33:37 <huangyi> I try to simulate the evaluation steps to understand what is the extra work.
21:34:02 <hpaste> huangyi pasted “evaluation steps of ++” at http://hpaste.org/50213
21:34:36 <ivanm> huangyi: nope, you skipped too many
21:35:05 <Axman6> yeah, that's not evaluated right. the brackets are important
21:35:13 <augur> koninkje_away: :|
21:35:22 <hpaste> ivanm pasted “For huangyi” at http://hpaste.org/50214
21:35:39 <ivanm> dammit, that didn't work
21:35:44 <ivanm> I was trying to get stepeval to work
21:36:23 <huangyi> I guess the extra work is open thunks ?
21:37:11 <hpaste> “C. McCann” pasted “Hackage Uploads High Score Table” at http://hpaste.org/50215
21:37:36 <hpaste> ivanm annotated “For huangyi” with “For huangyi (annotation)” at http://hpaste.org/50214#a50216
21:37:39 <Axman6> ("a" ++ "b") -> ('a':(([] ++ "b")) -> ('a':"b") <"ab"> then you have ("ab" ++ "c") -> ('a':("b"++"c")) -> ('a':'b':([] ++ "c")) -> ('a':'b':"c") <"abc">
21:37:43 <ivanm> huangyi: ^^
21:37:47 <luite> I'm running an update now, to add the packages added during the initial download
21:37:52 <luite> most of them by edwardk :)
21:38:04 <edwardk> hah
21:38:07 <ivanm> Axman6: that doesn't look quite right...
21:38:11 <cmccann> luite, did you see my hpaste? :P
21:38:24 <ivanm> Axman6: oh, you did even more steps
21:38:29 <Axman6> yours doesn't look right ;)
21:38:34 <Axman6> toy forgot the base case of []
21:38:34 <ivanm> huangyi: the thing is, you're consing 'a' multiple times
21:38:50 <luite> hehe
21:38:50 <ivanm> Axman6: I was doing more the effect rather than one step at a time
21:39:01 <ivanm> and it was going to make it messier to do full on 'b' : [], etc.
21:39:07 <luite> I'll tell Michael that he should upload more :p
21:39:34 <ivanm> I wonder who wins on a <total>/<number of unique packages>
21:39:36 <luite> ok all updated :)
21:39:46 <ivanm> (i.e. who has the most average number of uploaded versions)
21:40:09 <cmccann> ivanm, I was just counting lines in http://hackage.haskell.org/packages/archive/log
21:40:31 <ivanm> cmccann: yeah, which would be the easiest approach
21:41:14 * ivanm decides to call it a day and head off home
21:41:35 <ivanm> it helps when you remember to bring food with you to uni... ;)
21:42:21 * cmccann was actually surprised that dons is only #3 on total uploads to hackage
21:42:42 <ivanm> cmccann: he's been slacking off recently, hasn't he
21:43:32 <cmccann> yeah, though given edwardk is in the lead by a factor of two I don't think it'd make much difference :P
21:43:57 <edwardk> hah
21:44:10 <edwardk> who is #2? andy stewart?
21:44:39 <cmccann> edwardk, I posted the list here: http://hpaste.org/50215
21:44:41 <edwardk> and yeah dons has been slacking
21:44:52 <edwardk> ah snoyman
21:45:14 <cmccann> yeah, prolly cause yesod has a separate package for every twenty lines of code or so :P
21:45:28 <edwardk> hahahaha
21:45:49 <edwardk> yeah yesod makes me feel good about how dense my packages are ;)
21:46:07 <luite> hmm, git gc'ing everything takes a while :)
21:46:35 <cmccann> not that it actually bothers me, but I'm not sure how much benefit there really is to splitting things out as much as yesod does
21:50:10 <kadoban> hmm, i must be misunderstanding. if i have core.sharedrepository set to 0660, it's supposed to create files group writable, right? it doesn't seem to be...
21:50:37 <kadoban> wow, wrong channel, sorry
21:52:43 <luite> ok the tar.gz archives are 1.2GB, the git repositories created from them are 2.9GB
21:52:47 <luite> not too bad
21:55:08 <tgeeky_> luite: hehe, you indexing the haskell-i-verse?
21:56:08 <tgeeky> is there an option to tell cabal to re-try the compilation, with (some) or (any that it complains about) extensions on?
21:57:04 <tgeeky> like, cabal install --with-XFlexibleInstances ?
21:59:58 <luite> tgeeky: stuffing all versions of all packages in git repositories
22:00:05 <luite> to make it easy to view diffs
22:00:22 <tgeeky> yes
22:00:35 <tgeeky> I assume that means things have progressed nicely?
22:00:38 <luite> since haskell people don't believe in changeslogs (at least not publicly listed on hackage)
22:00:50 <tgeeky> well changelogs are often poooorrrly maintained anyway
22:00:58 <tgeeky> and in the age of dcvs, the code can often speak for itself
22:01:15 <ddarius> The Haskell way is just to harass the author on IRC.
22:01:25 <tgeeky> lol
22:01:46 <tgeeky> some of the extensions that come with 7.2.1 seem really juicy
22:01:46 <shachaf> ddarius: I assume most Haskellers don't use IRC.
22:01:59 <ulfdoz> you can easily get a changelog from the RCS. Some published and well aggregated Release Notes are much more important.
22:02:28 <cmccann> shachaf, I think a significant number of library maintainers are in here somewhat regularly, actually
22:02:39 <shachaf> Hmm.
22:03:27 <tgeeky> ulfdoz: when the end result is an API, pasring people's plain english (assuming they bothered to write a changelog), seems more tenuous than just looking at the revision history in place
22:03:33 * shachaf wonders how many Haskellers there are.
22:03:39 <luite> tgeeky: http://hdiff.luite.com/cgit/base/commit/?id=4.3.1.0
22:04:29 <tgeeky> though not all of us *cough* leave actual breadcrumbs like edwardk
22:04:50 <edwardk> hah
22:05:15 <edwardk> i view it as leaving an evidence trail for future computer historians ;)
22:05:45 <edwardk> some day there shall be a study on the effects of prolonged sleep deprivation on coding quality based on this dataset
22:05:53 <d-d> hm.
22:06:31 <cmccann> in the distant future, entire departments of software archaeologists will exist purely in order to study edwardk's output
22:07:22 <edwardk> 'this work was produced in edwardk's younger 'WTF' period. we tend not to consider these works 'canon'
22:07:23 <ddarius> In the distant future, people will use demagnetized metal disks as fill.
22:07:32 <luite> d-d: I'm too tired now to write the code for properly committing everything in the right order, and with the right author name
22:07:47 <d-d> hell, if the suriving species is monkey, we'll know the 1M monkies writing shakespeare was a silly scenario, but because s/shakespeare/edwardk/.
22:08:27 <edwardk> 1 million monkeys? no just one very sleep deprived edwardk ;)
22:09:07 <ddarius> We've had more than a million monkeys pounding away for much more than a thousand man-years and only one has produced the works of Shakespeare so far.
22:09:59 <edwardk> hah
22:10:03 <shachaf> I imagine at least one other monkey has produced the entire works of Shakespeare.
22:10:19 <shachaf> Though they may have used the works of Shakespeare for it.
22:10:28 <d-d> what is the general principle at play when I read Haskell papers about 'round-tripping' laws being satisfied?
22:10:45 <d-d> I see this often in papers about lenses, parsing combinators
22:11:20 <ddarius> I don't know about parsing combinators, but lenses are probably referring to isomorphisms being isomorphisms.
22:11:44 <ddarius> If by parsing combinators you meant parse-print pairs, then that would also be a case for isomorphism or at least an embed-project pair.
22:11:54 <coppro> ddarius: as opposed to isomorphisms being ellipses?
22:12:28 <d-d> ddarius: what about in the 'Forest' paper
22:13:08 <ddarius> That would likely be an embed-project pair.  As the paper explicitly states, it's just doing tree parsing.
22:13:18 <d-d> round-tripping there is something like a cycle of [file] -> |load| -> [memory] -> |store| -> [file]
22:13:32 <d-d> ok.
22:14:51 <edwardk> ideally you have an idempotent read-write cycle given by that, so then the trick becomes finding the retract and splitting the idempotent, taking the Karoubi envelope of your world if necessary
22:15:27 <d-d> had me until Karoubi
22:15:50 <edwardk> (that just makes it so you can always split it)
22:16:07 <edwardk> well, i was only half facetious there
22:16:31 <edwardk> the retract describes the amount of information present after you quotient out whatever the idempotent endomap is forgetting
22:16:38 <cmccann> edwardk, I think that was missing a couple "it's just ____" and "what
22:16:41 <cmccann> 's the problem?"
22:17:04 <edwardk> =P
22:17:15 <d-d> hm
22:17:21 <cmccann> or maybe needs something about burritos or whatever
22:17:27 <d-d> pre-additive cateogry -> almost-abelian category
22:17:30 <ddarius> Paul Taylor uses the Karoubi envelope his deeper papers on abstract stone duality which introduce sub-spaces.
22:17:40 <ddarius> A subspace is defined by an idempotent.
22:18:22 <d-d> that sounds like, a conserved quantity :: a conserved symmetry
22:18:34 <d-d> in physics analogy
22:18:40 <d-d> (your thing, not mine)
22:18:45 <edwardk> i keep playing with it in the context of describing all of those 'the smallest relation over some set that preserves beta, eta, delta, etc. reduction' clauses that pop up in type theory
22:19:03 <d-d> yeah, I dislike those.
22:19:08 <d-d> and in physics too.
22:19:32 <d-d> edwardk: have you read roconnor's | F : Lens :: Ap : Biplate | paper?
22:19:37 <edwardk> yeah
22:19:42 <ddarius> edwardk: As related to the closure/interior operators?
22:19:45 <edwardk> we talked about it fairly extensively before it was published
22:20:16 <edwardk> in fact a lot of the names for the operators come from my comonad-transformers library ;)
22:24:10 <plat0> oh
22:24:15 <plat0> you're edward kmett!
22:24:17 * cmccann tries to decide if an equivalent of Applicative for contravariant functors would be useful
22:24:29 <d-d> Alternative?
22:24:31 <plat0> edwardk: just been reading your blog a lot ... didn't realise it was you :)
22:24:37 <d-d> there's an alternative Alternative
22:24:43 <edwardk> thats me
22:24:51 <cmccann> d-d, how's that?
22:25:22 <edwardk> cmccann: what members?
22:25:43 <ddarius> cmccann: You could consider strong oplax monoidal functors.
22:26:02 <cmccann> edwardk, counterparts to pure () and liftA2 (,) are what I have
22:26:04 <d-d> some of the names... good god
22:27:15 <cmccann> the former basically ends up as something with type (f a) that's guaranteed to have no information from the a, vs. pure which has only information from a
22:27:17 <ddarius> Though I guess every functor is a strong oplax monoidal functor in Haskell.
22:27:42 <d-d> cmccann: http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf -> s/contravariant/1of6
22:27:48 <augur> edwardk: /msg!
22:27:49 <cmccann> whereas the latter ends up just lifting Either instead of (,)
22:28:54 * hackagebot transformers-base 0.1 - Lift computations from the bottom of a transformer stack  http://hackage.haskell.org/package/transformers-base-0.1 (MikhailVorozhtsov)
22:28:56 * hackagebot prototype 0.5.0 - prototype-based programming on Haskell  http://hackage.haskell.org/package/prototype-0.5.0 (YoshikuniJujo)
22:37:06 <hpaste> “C. McCann” pasted “contravariant stuff” at http://hpaste.org/50217
22:37:17 <cmccann> that's the stuff I had lying around
22:37:32 <cmccann> actually used it for a bit of hacking on something at one point but not sure it'd actually be generally useful :T
22:37:55 <dolio> Oplax monoidal functors needn't be contravariant.
22:38:07 <d-d> edwardk: is the 'only requires rank3types' (instead of GADTs) a positive, negative, incommesurate comparison (and now that 7.2.1 has some kind of GADT support built in?)
22:38:15 <ddarius> dolio: I didn't say anything about variance.
22:38:28 <edwardk> d-d: eq?
22:38:34 <dolio> cmccann did, though.
22:38:36 <edwardk> d-d: its mostly humorous
22:39:05 <d-d> edwardk: i know it kills the joke, but why would that be funny?
22:39:07 <edwardk> d-d: i suppose we're more likely to have rank-3 types working on the compiler at work though than GADTs at this rate ;)
22:39:59 <ddarius> Higher-rank types are relatively explored areas compared to GADTs (though still woefully underexplored in pragmatics.)
22:40:00 <d-d> edwardk: is the fact that GADTs and Generics come in on the same GHC release a coincidence? or are they connected?
22:40:06 <edwardk> rank (>2) types are undecidable for type inference.
22:40:18 <edwardk> you need to use some type checking craziness to accommodate them
22:40:48 <edwardk> basically you need some kind of principal typing giving you ordering of variables for skolemization or other side-conditions
22:40:51 <d-d> is this Biplate thing the craziness?
22:40:57 <edwardk> nah
22:41:07 <d-d> is turning on -XRankNTypes the craziness?
22:41:19 <fengshaun> is it good practice to nest where clauses?
22:41:19 <Saizan>  /whois gienah
22:41:51 <edwardk> well, turning that on enables it
22:42:04 <kmc> fengshaun, it's not necessarily *bad* practice
22:42:11 <d-d> but there isn't an instant degredation of type safety or performance or anything? hehe
22:42:12 <kmc> if it's nicer than the alternatives
22:42:24 <DukeDave> Just a quick one: What's the syntax for export an instance declaration?
22:42:33 <fengshaun> kmc: what are the alternatives?
22:42:53 <ddarius> DukeDave: You can't not export an instance.
22:42:54 <fengshaun> the code reads more naturally if I use nested where than if I use let
22:43:19 <Saizan> d-d: no, the only downside is that type inference doesn't cope so well with them
22:43:25 <DukeDave> ddarius: Wah?
22:43:28 <cmccann> fengshaun, I think that if anything lots of nested where clauses might be a sign something belongs at top-level instead
22:43:43 <cmccann> DukeDave, importing "nothing" from a module imports instances
22:43:44 <fengshaun> cmccann: no, it's just 1 level of nesting!
22:44:25 <cmccann> instances get into everything, you can't get rid of them
22:44:47 <DukeDave> I'm not sure I understand :|
22:44:47 <DukeDave> I'm getting a "No instance .." error
22:45:05 <cmccann> DukeDave, then you don't have a valid instance
22:45:43 <cmccann> if the instance you think you want is in a module you're importing already, then your problem is something else
22:45:47 <DukeDave> cmccann: Could qualified imports be breaking it?
22:46:02 <DukeDave> ccasin: Okay, thanks, I'll have another look
22:46:21 <ddarius> DukeDave: class names are qualified just like (most) everything else.
22:46:43 <cmccann> pretty sure that all you have to do is give a module a funny look and it will export all its instances into your code whether you wanted them or not
22:46:53 <fengshaun> I get "parse error on input 'where'" on the line that I start my nested where clause!
22:47:20 <cmccann> edwardk, did you look at the stuff I hpaste'd, btw?
22:47:39 <edwardk> the score table?
22:47:46 <cmccann> no, the contravariant stuff
22:47:57 <edwardk> missed it
22:48:19 <DukeDave> cmccann: Curious. So just to be clear I have a data definition in file A, an instance definition for that data in file B, and I'm using the data instance in file C. File C imports both A and B, and that should work, right?
22:48:30 <cmccann> edwardk, http://hpaste.org/50217
22:48:47 <edwardk> ok
22:48:54 * hackagebot gtk-traymanager 0.1.1 - A wrapper around the eggtraymanager library for Linux system trays  http://hackage.haskell.org/package/gtk-traymanager-0.1.1 (TristanRavitch)
22:48:56 * hackagebot taffybar 0.1.0 - A desktop bar similar to xmobar, but with more GUI  http://hackage.haskell.org/package/taffybar-0.1.0 (TristanRavitch)
22:49:13 <cmccann> DukeDave, sounds like it, assuming there's nothing weird going on
22:50:02 <cmccann> edwardk, mostly I'm not sure there's anything else any of that would be useful for, not much point to a type class when you won't be writing more instances
22:50:30 <edwardk> well, there aren't many useful contravariant functors in haskell
22:50:58 <cmccann> there's really only one
22:51:04 <edwardk> exactly
22:51:04 <cmccann> and ones that are equivalent to it in some way
22:51:45 <cmccann> but there's enough of said variations to justify the contrafunctor business itself
22:51:53 <cmccann> it's just messing with the other stuff that seems dubious
22:52:02 <edwardk> well, i have Contravariant in a package, i even have Corepresentable ;)
22:52:44 <cmccann> not surprised, I think you have a dual of traversable somewhere also that I found after writing my own
22:53:10 <edwardk> you may derive some benefit from playing with the corepresentable machinery  and seeing if it gives you any insight into what you can do with them
22:53:10 <edwardk> yeah
22:53:12 <edwardk> distributive
22:53:24 <ski> cmccann : there's `CoYonedaOp IORef', e.g.
22:53:59 * DukeDave cries
22:54:10 <edwardk> notice the type on distributive is weaker than that of traversable, since i don't need the command or non-existent 'coapplicative', just a functor.
22:54:28 <cmccann> edwardk, yeah, that's all I had
22:54:45 <coppro> the category theory hurts
22:55:11 <cmccann> actually I pretty much just wanted a way to pull ((->) e) out through other functors, then generalized for the hell of it
22:55:15 <edwardk> er s/command/comonad/
22:55:19 <edwardk> yeah
22:55:23 <edwardk> thats the canonical exampe
22:55:43 <edwardk> all other representable functors are distributive because they are isomorphic to ((->)e) for some e.
22:55:47 <cmccann> and I think the whole thing started by trying to gratuitously generalize flip for some reason, don't even remember anymore
22:56:16 <edwardk> er RepresentableFunctor with capital letters that is
22:56:17 <ddarius> :t flip
22:56:18 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
22:57:00 <edwardk> anyways back to work, too many conversations running, lots of code in the air
22:57:01 <cmccann> oh, right, I wanted a more general signature for that type-Nat-indexed argument permuting thing
22:57:03 <ski> cmccann : `data CoYonedaOp f b = forall a. ContraMapIncl (b -> a) (f a)'
22:57:44 <cmccann> ski, yeah, sorry, I saw that earlier but didn't say anything
22:57:55 <cmccann> that's pretty close to the example I pasted, actually
22:58:08 <fengshaun> can someone give me an example of how to nest a where clause?  I keep getting "parse error on input 'where'" no matter what indentation I use!
22:58:20 <ski> cmccann : you pasted something more than <http://hpaste.org/50217> ?
22:59:01 <cmccann> and pushing values into a write-only reference is one of the obvious uses for contravariant stuff
22:59:14 <cmccann> ski, no, just that
22:59:17 * DukeDave is an idiot
22:59:32 <DukeDave> Why is it never GHC that is wrong, it's always me isn't it :(
22:59:39 <ski> DukeDave : and i assume `B' imports `A'. so what's the error message ?
22:59:50 <cmccann> DukeDave, GHC tends to be like that, yes
23:00:17 <ski> cmccann : i don't think `CoYonedaOp' is that similar to `AnnouncerT'
23:00:37 <cmccann> ski, could be put to similar use, is all
23:00:40 <DukeDave> ski: Amusingly I had two copies of the data type, one left over in a difference namespace :|
23:00:44 <ski> fengshaun : paste what you have got ?
23:00:58 <DukeDave> ski: So thanks, but problem solved
23:01:05 <fengshaun> ski: hold on
23:01:17 <ski> cmccann : the existential in `CoYonedaOp' is an essential part of it
23:02:18 <ski> (cmccann : otherwise it couldn't be a contravariant functor)
23:02:35 <ski> DukeDave : i see
23:02:58 * ski holds off
23:03:32 <cmccann> ski, yeah, I think the existential lets it work in the general case whereas what I was doing relied on properties of the wrapped type constructor
23:04:13 <cmccann> I just find working with existentials in Haskell to be kind of a pain in the neck :T
23:04:59 <kmc> cmccann, are you talking about the support in GHC? do you think it'd be better with a direct "exists" quantifier?
23:05:02 <ski> it's usually not that hard
23:05:19 <ski> sometimes the lack of an explicit `exists' is felt
23:05:36 <ski> (having to CPSify some operations is not so nice)
23:05:58 <hpaste> fengshaun pasted “nested where” at http://hpaste.org/50218
23:06:09 <kmc> when do you have to CPS things in GHC?
23:06:19 <fengshaun> ski: http://hpaste.org/50218
23:06:58 <dolio> When you don't want to invent a new datatype.
23:07:03 <cmccann> kmc, nah, I suspect the awkwardness is unavoidable for the most part
23:07:07 <ski> fengshaun : yeah, hpaste already told us :)
23:07:20 <ski> fengshaun : the indentation looks ok
23:07:27 <cmccann> the quasi-CPS version of existentials are just the church encoding of the datatype version anyway
23:07:32 <ski> hm, actually no it doesn't
23:07:41 <ski> the latter `where' should be more indented
23:07:44 <fengshaun> how should it be?
23:07:54 <fengshaun> oh
23:07:57 <kmc> further than "liftRotate"
23:08:30 <ski> i would indent the latter `where' as much as `splitted', and then indent the former one as much as `liftRotate', for consistency
23:09:15 <fengshaun> ski: so that a where clause and its "contents" have the same indentation level?
23:09:18 <ski> (and maybe i'd change the overall indentation of the former `where'-block to be two spaces more than the start of `rotate'
23:09:21 <ski> )
23:09:31 <ski> fengshaun : yeah, that's what i usually do
23:09:40 <ski> it's not required to do that
23:10:01 <fengshaun> what indentation is dominant among haskellers?
23:10:04 <ski> what is required is that the `where' attaching to `liftRotate' is indented more than `liftRotate'
23:10:11 <ski> i'm not sure
23:10:35 * ski usually goes with what he considers pretty (unsurprisingly)
23:10:54 <fengshaun> ski: thanks a lot!
23:10:58 <ski> np
23:11:44 <ski> fengshaun : btw, are you sure you mean `snd . splitted' rather than `snd splitted' ?
23:12:01 <ski> if you do (and similarly for the `fst') one, then you could do instead
23:12:17 <coppro> [A6
23:12:19 <fengshaun> ski: yup, I just got the error now! :)
23:12:22 <ski>   liftRotate n xs = back ++ front
23:12:24 <ski>     where
23:12:31 <ski>     (front,back) = split n xs
23:12:37 <ski> which is nicer
23:12:55 <fengshaun> hmmm didn't think of that!  Thanks a lot!  That makes it a lot nicer!
23:13:48 <fengshaun> ok, now it's working.  My first 'lifting' practice!
23:14:14 * ski idly wonders what's "lifting" in it ..
23:15:20 <fengshaun> ski: what is lifting then?
23:15:31 <ski> dunno, lot's of things
23:15:40 <ski> like `liftM',`lift',`liftIO'
23:16:24 <fengshaun> I haven't read about Monads yet!  I guess I'm just 'factoring' code then to prevent copy/paste.
23:16:26 <ski> fengshaun : btw, if you don't want to, you don't have to pass `xs' as argument to `liftRotate'
23:17:06 <fengshaun> how come?
23:17:36 <ski> (if you wanted to (now or later) move `liftRotate' to be a definition of its own, defined outside `rotate', then you couldn't do that)
23:18:20 <fengshaun> why?
23:18:38 <ski> well, `(front,back) = split n xs' can "see" `xs' even if it's not passed explicitly as an argument to `liftRotate', just because `liftRotate' (and therefore `split') is defined in a scope where `xs' is in scope
23:19:00 <fengshaun> oh, interesting!
23:19:19 <ski> your two calls to `liftRotate' is calling `liftRotate' with the same `xs' in both cases, which `liftRotate' locally calls `xs' again
23:19:51 <ski> otoh, those two calls call with `(length xs - n)' resp. `n', which `liftRotate' then calls `n', so you couldn't omit that parameter to `liftRotate'
23:20:04 <kmc> :t uncurry (++) (split ?n ?xs)
23:20:05 <lambdabot>     Couldn't match expected type `t -> (a, a)'
23:20:05 <lambdabot>            against inferred type `(g, g)'
23:20:05 <lambdabot>     In the second argument of `uncurry', namely `(split ?n ?xs)'
23:20:27 <kmc> err
23:20:28 <ski> @type uncurry (++) . (arr snd &&& arr fst) . split ?n ?xs
23:20:29 <lambdabot>     Couldn't match expected type `t -> f (a, a)'
23:20:29 <lambdabot>            against inferred type `(g, g)'
23:20:30 <lambdabot>     In the second argument of `(.)', namely `split ?n ?xs'
23:20:45 <fengshaun> you're right, it works!
23:20:50 <ski> @type (uncurry (++) . (arr snd &&& arr fst) . split ?n) ?xs
23:20:51 <lambdabot>     Couldn't match expected type `t1 -> t'
23:20:51 <lambdabot>            against inferred type `((a, a), a)'
23:20:51 <lambdabot>     In the expression:
23:20:53 <shachaf> Hmm, you can use ImplicitParams to fake keyword arguments.
23:20:55 <ski> bah
23:20:57 <shachaf> I suppose it's a terrible idea.
23:21:21 <ski> @type (uncurry (++) . (arr snd &&& arr fst) . splitAt ?n) ?xs
23:21:22 <lambdabot> forall a. (?n::Int, ?xs::[a]) => [a]
23:21:43 * ski wonders which `split' fengshaun was using
23:21:56 <kmc> shachaf, that's great if you want your callers to set the defaults for any kwargs you don't specify :D
23:22:04 <fengshaun> ski: actually splitAt, it was just a type I noticed after the paste
23:22:15 <shachaf> kmc: Right, that's what I was thinking of.
23:22:22 <kmc> a nicer way to do kwargs is record update syntax
23:22:39 <shachaf> kmc: To be fair, they can only set the defaults for keyword parameters that you also accept!
23:23:42 <kmc> can we think of implicit params as a single, ad-hoc extensible product type with subtyping?
23:27:00 <NihilistDandy> I used to be in three channels on Freenode. Now I'm on 16. Thanks, #haskell and #esoteric
23:27:50 <kmc> are you in ##electronics?
23:28:00 <kmc> you should join ##electronics, if you like electronics.  or furry role-playing.
23:28:08 <fengshaun> ski: http://paste.pocoo.org/show/457051 any other recommendations?
23:28:36 <ski> (.. only 16 channels ?)
23:29:43 <NihilistDandy> kmc: Well, that was expected. Only furries like electronics
23:29:44 <ski> fengshaun : any particular reason you didn't annotate the original paste ?
23:31:17 <kmc> i know people who have hit the server-side channel limit
23:31:18 <ski> fengshaun : if i felt like, i might have done the negative case in a single traversal (i.e. avoiding having both `length' and `splitAt' traverse the list)
23:31:20 <fengshaun> ski: what?
23:31:31 <fengshaun> annotate what*
23:31:44 <ski> fengshaun : you pasted before on hpaste, now you had a modified version but didn't annotate the original paste
23:32:07 <ski> see the "annotate" button on <http://hpaste.org/50218> ??
23:32:10 <ski> s/??/?/
23:32:18 <fengshaun> oh sorry, I just realized I had lodgit plugin on vim!
23:34:22 <fengshaun> ski: thanks!
23:37:09 <ski> np
23:37:33 <ski> fengshaun : otherwise, it looks fine
