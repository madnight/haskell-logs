00:00:00 <Cale> kmc: Basically you use variant for each constructor, and >< on the coarbitraries of the arguments
00:01:04 <kmc> i see
00:02:33 <Cale> kmc: So  instance (Coarbitrary a) => Coarbitrary (Tree a) where coarbitrary Tip = variant 0; coarbitrary (Branch x l r) = variant 1 >< coarbitrary x >< coarbitrary l >< coarbitrary r
00:02:46 <Cale> Oh, sorry, CoArbitrary
00:03:35 <kmc> yeah, i should have just read the source :)
00:03:36 <kmc> thanks
00:04:19 <Cale> It seems like they use (.) rather than (><) for a lot of the instances in QuickCheck itself.
00:04:27 <Cale> I'm not sure why. Probably because it's faster.
00:04:58 <Cale> ah, perhaps where there's already a 'variant' present
00:06:04 <Cale> I wonder why they decided to split coarbitrary into its own class.
00:06:26 <Cale> Maybe because it's harder to understand :)
00:07:18 <Cale> I can't think of any instances of Arbitrary which couldn't be instances of CoArbtirary as well though.
00:08:39 <Cale> Also, they seem to prefer to use 0 and (-1) rather than 0 and 1
00:08:43 <Cale> interesting.
00:17:27 <c_wraith> yeah, it's really just about "I don't understand CoArbitrary, and I don't need it anyway..."
00:19:18 <cwl> The function always evaluates the same result value given the same argument value(s).
00:19:55 <cwl> How to judge if the return values are the same, if the return type is not instance of Eq
00:20:11 <kmc> nothing can distinguish them
00:20:13 <shachaf> You don't need to judge.
00:20:36 <shachaf> A lot of things can't be compared in general.
00:21:14 <cwl> but how to judge if the function is pure or not
00:21:24 <shachaf> cwl: "Yes" will usually do.
00:21:26 <kmc> if there's any possible way to tell the two results apart, then it's not
00:21:28 <ClaudiusMaximus> is there a review/comparison of all the different haskell web frameworks anywhere?
00:21:30 <kmc> x is "the same" as y if, for all f,  f x == f y
00:21:30 <shachaf> Unless you do something evil.
00:21:43 <kmc> here (f x) is a type with Eq but x isn't
00:21:46 <shachaf> kmc: Wher "==" really means "the same", so that definition is a bit circular. :-)
00:21:49 <kmc> of course i'm kind of begging the question here
00:21:50 <shachaf> Oh.
00:21:57 <kmc> because it only works because f is pure
00:22:07 <NihilistDandy> ClaudiusMaximus: Not that I've seen. It seems to depend on how many features and which ones you want.
00:22:11 <xarch> hello, I'm trying to compile the Haskell version of LazyFoo's SDL tutorials. That works, but when I launch the program I have a black window, although it should display an image
00:22:15 <xarch> do you know why?
00:23:24 <kmc> cwl, in Haskell functions are pure by construction
00:23:35 <kmc> unless you use one of a few obvious mechanisms to break the rules
00:23:49 <kmc> so you usually don't have to judge whether a function is pure
00:24:04 <cwl> kmc, then putStrLn is pure
00:24:15 <cwl> :t putStrLn
00:24:16 <lambdabot> String -> IO ()
00:24:30 <shachaf> > isPure putStrLn
00:24:32 <lambdabot>   True
00:24:33 <kmc> yes
00:24:35 <shachaf> Yep.
00:24:40 <kmc> cwl, it always returns the same IO action
00:24:53 <kmc> (for a given input)
00:24:58 <kmc> you can't compare them with (==), but you can't tell them apart in any way
00:25:05 <cwl> shachaf, can you give some example that isPure returns false
00:25:09 <ClaudiusMaximus> NihilistDandy: well, i don't yet know which ones have which features, was hoping not to have to work hard finding out :)
00:25:23 <shachaf> cwl: Nope. There are none.
00:25:36 <kmc> i have a feeling shachaf defined "isPure _ = True"
00:25:49 <cwl> lol
00:26:00 <NihilistDandy> ClaudiusMaximus: Well, yesod's pretty easy to work with, for instance. The scaffolding pretty much does all the work for you
00:27:25 <kmc> > isPure isPure
00:27:27 <lambdabot>   True
00:27:41 <shachaf> > isPure True
00:27:42 <lambdabot>   Couldn't match expected type `a -> b'
00:27:42 <lambdabot>         against inferred type `GHC.Bo...
00:28:05 <ClaudiusMaximus> NihilistDandy: mm, bit wary of scaffolding thingies, i tried out ruby/rails once years ago and it seemed to be really quick to get started but maintaining it was nightmarish
00:29:13 <NihilistDandy> ClaudiusMaximus: Are you on the web-devel mailing list?
00:29:16 <sully> > isPure unsafePerformIO
00:29:17 <lambdabot>   Not in scope: `unsafePerformIO'
00:29:29 <sully> I guess it makes sense for lambdabot to not have that in scope.
00:29:34 <ClaudiusMaximus> NihilistDandy: no, maybe i should check out its archives
00:29:38 <shachaf> sully: isPure is a lambdabot-only function.
00:30:01 <shachaf> It assumes the constraints of mueval.
00:30:10 <NihilistDandy> ClaudiusMaximus: web-devel@haskell.org
00:30:24 <sully> @src isPure
00:30:24 <lambdabot> Source not found. I feel much better now.
00:34:34 <dibblego> can someone please confirm, is Data.Map.insertLookupWithKey (const const) the equivalent of doing no modification? (I just want the Maybe out the other end)
00:34:38 <efie> botje: i hope i remeber it right: i think that you were the one who yesterday gave me the advice that i could improve my function which tells after which element a list shall be splitted so that the sums will be the closest by 'taking the sum and scanl over the list, subtracting from the total" - is this what you meant?:
00:34:39 <hpaste> efie pasted “Splitting Lists” at http://hpaste.org/50483
00:34:42 <cwl> :info IO
00:34:49 <cwl> > :info IO
00:34:50 <lambdabot>   <no location info>: parse error on input `:'
00:34:56 <cwl> type IO a = World -> (a, World)
00:35:07 <shachaf> cwl: No, it's not that.
00:35:15 <kmc> cwl, that model of IO is very misleading
00:35:16 <shachaf> cwl: Anyone who tells you that is wrong.
00:35:20 <cwl> shachaf:http://research.microsoft.com/en-us/um/people/simonpj/Papers/marktoberdorf/mark.pdf
00:35:42 <shachaf> cwl: Read another introduction to IO. :-)
00:35:55 <shachaf> Wouldn't it be nice if there was a page on the wiki that had an Introduction To IO?
00:35:58 <kmc> it's an analogy, but a pretty bad one
00:36:03 * shachaf wonders if kmc knows of one.
00:36:10 <kmc> what if the world changes between steps of your action?
00:36:23 <mustelo> conal has indoctrinated #haskell against that model :)
00:36:33 <sully> I mean, the actual type of IO is something a lot like that
00:36:36 <shachaf> mustelo: conal has more fundamental objections to that model than most people here.
00:36:43 <kmc> sully, the actual type in GHC
00:36:47 <sully> yes
00:36:49 <shachaf> sully: Right, but it's a terrible model to understand IO.
00:36:49 <kmc> and actually it's nothing like that
00:36:54 <kmc> because (->) in Haskell means "pure function"
00:36:58 <shachaf> And RealWorld isn't actually "the world", it's just a token.
00:37:03 <kmc> but the GHC IO implementation is based on *impure* functions
00:37:03 <sully> yes
00:37:25 <shachaf> kmc: I thought the point of that model is that the world *can't* change except through an IO primitive.
00:37:30 <kmc> anyway no less a personage than SPJ still propagates this bad model of IO
00:37:49 <kmc> shachaf, other people can change it while you're not looking
00:37:50 <mustelo> is there a better one?
00:38:01 <kmc> the better analogy is the actual non-analogy truth
00:38:02 <cwl> @_@, how to understand IO, where is pure and impure
00:38:02 <lambdabot>  how to understand IO, where is pure and impure
00:38:11 <shachaf> I like data IO = Done | PutStrLn String IO | GetLine (String -> IO) | ...
00:38:31 <shachaf> As an abstract data type which the RTS evaluates.
00:38:31 <kmc> which is that a value of type (IO T) represents a description of how some IO could be performed to produce a value of type T
00:38:44 <shachaf> Or what kmc says, of course. :-)
00:38:50 <shachaf> Best to keep the data type abstract.
00:39:08 <kmc> <kmc>	cwl, read http://www.haskell.org/haskellwiki/Introduction_to_IO
00:39:08 <kmc> <kmc>	cwl, read http://www.haskell.org/haskellwiki/Introduction_to_IO
00:39:08 <kmc> <kmc>	cwl, did you read http://www.haskell.org/haskellwiki/Introduction_to_IO ?
00:39:08 <kmc> <kmc>	cwl, you really should read that Introduction to IO article.  your question is not about monads
00:39:23 <sully> fail
00:39:30 <ion> :-D
00:39:42 <kmc> cwl, the answer is that there's no "impure"
00:39:50 <kmc> so it's easy to understand which bits are pure and which are impure
00:39:53 <cwl> kmc: yes
00:39:58 <kmc> IO actions are pure values like any other
00:40:02 <kmc> evaluating them has no special effect
00:40:06 <cwl> kmc: but ...
00:40:23 <cwl> the real world is changed
00:40:33 <kmc> not by evaluating, no
00:40:38 <kmc> only by executing
00:40:49 <shachaf> You ought to read some sort of introduction to IO.
00:40:50 <kmc> you can evaluate any value anywhere in a Haskell program
00:40:58 <kmc> but the only action executed is the one named "main"
00:41:00 <cwl> evaluating v.s. executing
00:41:05 <kmc> cwl, did you read "Introduction to IO"?
00:41:13 <cwl> kmc, yes I did
00:41:15 <kmc> ok
00:41:32 <kmc> evaluation is computation
00:41:41 <kmc> it's what happens when you apply a function to arguments and then pattern-match on the result
00:41:46 <cwl> now, it is the problem of executing
00:41:46 <kmc> evaluation has no side effects
00:41:58 <kmc> execution is what happens when you take apart an IO action and perform the steps described by it
00:42:29 <kmc> when you run a Haskell program, the runtime system will execute the action named 'main'
00:42:41 <kmc> and when you type an expression of type (IO T) into GHCi, it will execute it
00:42:53 <cwl> is the concept 'execution' only for IO action or all Monad types
00:42:54 <kmc> and those are basically the only times anything gets executed
00:42:57 <kmc> only for IO
00:43:01 <kmc> the way i'm using it here
00:43:11 <kmc> in particular "main" always has IO type
00:43:52 <kmc> so IO is special, but not special because it's a monad
00:44:01 <kmc> in fact it's an atypical monad
00:44:58 <kmc> as a phrase, "monadic IO" is really a red herring
00:45:19 <kmc> the fact that IO is a monad is not very important to how it works
00:46:21 <dibblego> I am in favour of no longer using the term "the IO monad"
00:46:25 <cwl> so IO action only executes inside main
00:46:44 <kmc> the only IO action which ever gets executed is 'main' itself
00:46:53 <kmc> however, you have functions like (>>=) that let you glue together IO actions
00:47:12 <kmc> so typically main is a big IO action made from gluing together lots of other actions, which come from calling functions all over your program
00:47:28 <kmc> and the effect looks a bit like calling impure functions and using the results
00:47:36 <kmc> but it's actually something different and much nicer
00:47:48 <shachaf> Unless you're conal. :-)
00:48:36 <kmc> i think even conal agrees that Haskell's IO type is better than most other imperative languages
00:49:18 <cwl> who is conal
00:49:24 <kmc> except in as much as it's a "good enough" solution that discourages people from working on better solutions
00:49:28 <dibblego> there are also people who agree that imperative languages are better than IO, but are unable to construct a coherent reason why
00:49:37 <Saizan> "the IO monad" is actually a nice name, but you appreciate it only after you've seen denotational semantics done with monads
00:49:52 <kmc> cwl, Conal Elliott
00:50:06 <kmc> is here under the nick 'conal' sometimes
00:50:10 <kmc> has a cool blog
00:50:18 <dibblego> Saizan: yeah, it would certainly be nice to save its usage, but too often I see "the IO monad" to mean "nothing to do with the IO monad and something to do with IO" -- I am torn
00:50:22 <ClaudiusMaximus> `cabal install yesod` fails with ghc-7.0.4/integer-simple :(  why does a web framework (indirectly) need a specific implementation of Integer ?!
00:50:43 <cheater> because the ghc stdlib sux
00:50:54 <kmc> did you build ghc against integer-simple?
00:51:02 <kmc> the default is integer-gmp, (almost) everywhere
00:51:07 <Saizan> dibblego: there isn't much of a difference, though
00:51:13 <ClaudiusMaximus> kmc: yes, that's why i explicitly mentioned it
00:51:13 <kmc> what's the dpendency chain?
00:51:35 <ClaudiusMaximus> `cabal` claims blaze-textual is to blame
00:52:01 <kmc> hmm, it lists ghc-prim as a dep
00:52:03 <kmc> but not integer-*
00:52:06 <dibblego> Saizan: why do we not call it "the IO applicative functor"?
00:52:21 <kmc> oh, it's in there, just hidden from hackage
00:52:44 <cwl> (>>=) for IO a must be tricky
00:53:01 <cwl> it will execute IO a
00:53:14 <kmc> cwl, the implementation of IO is left unspecified by the Haskell Report
00:53:15 <cwl> but (>>=) for others will not
00:53:19 <kmc> so you can't write (>>=)
00:53:23 <kmc> cwl, it doesn't execute its argument
00:53:25 <ClaudiusMaximus> kmc: ah, i see - flag fun...
00:53:37 <kmc> cwl, it just takes an IO action and returns another
00:53:46 <Saizan> dibblego: if we were trying to model a first order language we would, but we don't
00:53:47 <kmc> x >> y = "execute " ++ x ++ ", then " ++ y
00:53:57 <kmc> in a manner of speaking
00:54:13 <kmc> cwl, it takes an inert description of IO and returns another inert description
00:54:29 <kmc> nothing *in* Haskell will trigger execution
00:55:11 <shachaf> unsafeTrollKmc
00:55:51 <cwl> in the action called 'main', how the chain of IO types executed one by one, doesn't (>>=) do that work?
00:56:04 <kmc> no, the runtime system does
00:56:18 <kmc> (>>=) just builds up a data structure that describes IO which could be performed
00:56:25 <kmc> the runtime system traverses that data structure and performs the IO
00:56:36 <kmc> conceptually this is the way to think about it
00:56:49 <kmc> the reality in GHC is uglier, but that has no bearing on how you use IO
00:58:11 <cwl> outside the main, I can treat IO a as a normal data type
00:58:25 <kmc> it is a normal data type, inside or outside main
00:58:46 <kmc> it's an "abstract data type" because you can't see its constructors and therefore can't play with the representation
00:58:52 <kmc> but there are many other abstract data types
00:59:02 <kmc> that bit is not unusual
00:59:27 <kmc> once you have the value (x >> y) there's no way to take it apart into x and y again
00:59:54 <shachaf> Well, not in general.
01:00:00 <kmc> not in IO, i mean
01:00:18 <kmc> actually i think it's rather hard to do in any case, and would break the monad laws
01:00:26 <kmc> but that's a tangent
01:00:39 <shachaf> data Null a = Null
01:05:13 <c_wraith> > [1..3] >> "hi"
01:05:14 <lambdabot>   "hihihi"
01:11:10 <ion> > let io cmd = do { v <- new; v <$ push ("let " ++ v ++ " be (" ++ cmd ++ ")") }; push cmd = modify (first (++ [cmd])); new = ('a':) . show <$> (gets snd <* modify (second succ)) in concat . intersperse ", then " . fst . flip execState ([], 0 :: Integer) $ do line <- io "read line"; io ("print 'Hello, ' " ++ line)
01:11:12 <lambdabot>   "let a0 be (read line), then let a1 be (print 'Hello, ' a0)"
01:11:56 <ion> Now, it’s up to someone to *execute* that combined IO action that was serialized in readable form for us. :-P
01:12:59 <shachaf> ion: I still prefer data IO = Done | PutStrLn String IO | GetLine (String -> IO) | ..., or something of the sort.
01:13:52 <ion> shachaf: Absolutely, now type that to lambdabot. ;-)
01:14:20 <shachaf> lambdabot's a terrible RTS.
01:16:08 <efie> :l sum [0.3,0.3,0.1,0.1,0.1,0.1]
01:16:32 <efie> :lamdabot sum [0.3,0.3,0.1,0.1,0.1,0.1]
01:17:07 <efie> lambdabot sum [0.3,0.3,0.1,0.1,0.1,0.1]
01:17:23 <efie> sum [0.3,0.3,0.1,0.1,0.1,0.1]
01:17:27 <efie> grmph
01:18:47 <efie> :lambdabot sum [0.3,0.3,0.1,0.1,0.1,0.1]
01:19:06 <efie> anyway, why is this not rounded automatically to 1.0?
01:19:22 <shachaf> > sum [0.3,0.3,0.1,0.1,0.1,0.1]
01:19:23 <lambdabot>   0.9999999999999999
01:19:28 <shachaf> Not sure where ":lambdabot" came from.
01:19:32 <shachaf> efie: Why would it be?
01:20:11 <efie> well the sum is 1.0 and not 0,99....9, is it not?
01:20:14 <shachaf> Nope.
01:20:22 <shachaf> > 0.1 + 0.2
01:20:23 <lambdabot>   0.30000000000000004
01:20:25 <kmc> efie, read about how floating point numbers work
01:20:29 <kmc> the short answer: they don't
01:20:30 <shachaf> That's floating point "numbers" for you.
01:20:36 <ClaudiusMaximus> > sum [0.3,0.3,0.1,0.1,0.1,0.1] :: Rational
01:20:37 <lambdabot>   1 % 1
01:20:50 <efie> okay
01:21:21 <kmc> nearly every language has this same problem, so there's plenty to read about it
01:22:07 <kmc> and as ClaudiusMaximus points out, there are other non-floating-point types you can use
01:22:36 <efie> rounding by hand makes no sense as other results would be rounded to 1 as well
01:22:56 <efie> ok, i will check it out
01:24:29 <ClaudiusMaximus> > read ("0." ++ replicate 300 '0' ++ "1") :: Double
01:24:31 <lambdabot>   1.0e-301
01:28:34 <mustelo> as a historical note, ML forbids equality on real types because they didn't want systems crashing from wonky results
01:29:29 <kmc> which types? and why would it crash?
01:29:54 <shachaf> I assume mustelo is referring to floating-point-type types.
01:30:19 <mustelo> the ML type for real numbers did not allow equality
01:30:27 <mustelo> and by did, I mean does
01:30:45 <kmc> oh, 'real'.  i understand :)
01:31:30 * hackagebot amqp 0.3.0 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.3.0 (HolgerReinhardt)
01:31:30 <mustelo> haha, I can see how that might sound weird otherwise: "ML disallows the use of equality!"
01:31:59 <shachaf> Well, someone might have read your statement as being about pointer equality, or something.
01:32:06 <shachaf> (Which is of course forbidden in Haskell.)
01:33:58 <kmc> in fact it's reallyUnsafe :)
01:36:37 <mustelo> this is also a good example of how ad-hoc polymorphism is better understood today (in Haskell) than it was in ML. the ML solution is to special case the class of types which have equality defined; it gets ugly.
01:38:24 <roiupeo> hi
01:38:53 <mustelo> hi roiupeo
01:38:58 <yourstruly> Which higher order construct in Haskell lets you traverse a list and then stop when a certain predicate is True
01:39:04 <yourstruly> if there is one that is
01:39:08 <shachaf> yourstruly: takeWhile
01:39:14 <yourstruly> ah, of course
01:41:40 <yourstruly> shachaf: I was stuck on the idea of using a fold, which I'm sure is possible somehow, but I just wasn't thinking of the right tool
01:42:12 <roiupeo> Do you know if there is a stack implementation on the haskell library?
01:42:31 <mustelo> roiupeo, lists work well as stacks
01:43:01 <roiupeo> yes, OK
01:43:03 <shachaf> > let tW p = foldr (\x xs -> if p x then x : xs else []) [] in tW even [2,4,1,3]
01:43:04 <lambdabot>   [2,4]
01:43:09 <shachaf> yourstruly: That works as a fold.
01:44:01 <dibblego> yourstruly: this might help http://blog.tmorris.net/haskell-beginner-exercises-with-tests/
01:44:06 <mustelo> shachaf beat me to it :)
01:44:43 <shachaf> mustelo: Don't worry, you can still provide the 3-character @pl version. :-)
01:44:55 <shachaf> @pl tW p = foldr (\x xs -> if p x then x : xs else []) []
01:44:56 <lambdabot> tW = flip foldr [] . flip flip [] . (flip .) . (`ap` (:)) . (((.) . if') .)
01:44:57 <shachaf> Hrm.
01:45:06 <shachaf> @pl (\x xs -> if p x then x : xs else [])
01:45:06 <lambdabot> flip flip [] . ap ((.) . if' . p) (:)
01:46:11 <shachaf> @pl \x xs -> guard (p x) >> (x : xs)
01:46:12 <lambdabot> ap ((.) . (>>) . guard . p) (:)
01:46:16 <shachaf> Eh, something like that.
01:48:34 <romanm> hlint lies?
01:49:07 <romanm> z$g$x!!0 -> why not: head (z $g $x)
01:49:20 <romanm> because head(z $g $x) is something totally different?
01:50:10 <shachaf> z$g$x!!0 === z (g (head x))
01:50:25 <romanm> yes
01:50:29 <romanm> but not head(z $g $x)
01:51:03 <shachaf> Yep.
01:51:12 <shachaf> Oh, you're referring to hlint there.
01:51:42 <romanm> Yep. Hlint appearently sometimes gives suggestions which are wrong.
01:52:00 <shachaf> Disgusting.
02:24:20 <mornfall> Why I keep forgetting returns and why I get such cryptic errors when I do? :(
02:25:37 <dibblego> honestly, I don't use return all that much
02:25:55 <Botje> 'expected: IO a inferred: a' is not really cryptic :)
02:26:27 <dibblego> 'expected: IO a inferred: a. You missed out return didn't you? DIDN'T YOU!?'
02:27:11 <Eduard_Munteanu> Compare to "non-void function f() does not return a value" :)
02:27:35 <Botje> that's still super clear :)
02:27:51 <Botje> .oO(unfortunately that error is hidden behind -Wall for some reason)
02:32:53 <augustss> Howdy!
02:33:28 <cinimod> Hello
02:37:02 <cinimod> I've just written a quick script to process a large file (lazily)
02:37:20 <cinimod> If I change it to use Data.Text.Lazy instead of String
02:37:31 <cinimod> What performance improvement should I see?
02:37:50 <cinimod> At the moment I am seeing very little difference
02:38:44 <augustss> Did you profile your code before switching?
02:39:19 <cinimod> Well I looked at heap usage to make sure it was processing the file lazily
02:39:36 <cinimod> What else should I look at?
02:39:44 <augustss> Are you expecting a speedup or less memory use?
02:39:53 <cinimod> I still have both versions
02:39:57 <Eduard_Munteanu> cinimod: do you use unpack and pack? You shouldn't
02:39:58 <cinimod> Speedup
02:40:27 <augustss> Well, String be as good as Data.Text.  It all depends on the actual application.
02:40:36 <cinimod> Only to create constants for e.g. span
02:40:49 <Eduard_Munteanu> Ah, that's ok.
02:41:08 <augustss> You should do a some profiling to see if the time is spent on string processing in the old version.
02:41:25 <cinimod> Ok
02:41:47 <augustss> And also profile the new version.
02:42:09 <cinimod> I guess most of the time might be in IO
02:42:23 <cinimod> Anyway I will have a go at profiling
02:44:15 <erg_> hi
02:44:47 <augustss> hi
03:02:55 <illissius_> heh
03:03:37 <illissius_> it took quite a while after looking at the new reflection package and thinking 'where the heck does this new lower-case version of Proxy come from' before I realized that it's a frickin' type variable.
03:13:04 <iwtu> hi. this is my type..
03:13:06 <iwtu> import qualified Data.Map as Map
03:13:08 <iwtu> import qualified Data.Sequence as Seq
03:13:10 <iwtu> type Automata a = Seq.Seq (Map.Map a Int)
03:14:08 <iwtu> if I know the index of sequence I would to like to make recursive call through all the values in the map
03:14:36 <iwtu> but function Map.Map has firmly type
03:14:52 <iwtu> I don't know what I can use
03:19:04 <RenJuan> new reflection package?
03:19:55 <iwtu> I have to go. I give a simple sample when I return. bye
03:24:16 <taylanub> tuples in haskell are like vectors in lisp ?
03:24:35 <opqdonut> probably not
03:25:05 <taylanub> what's the difference between tuples and lists, in haskell ?
03:25:19 <opqdonut> tuples are constant length
03:25:26 <opqdonut> lists have all their elements of the same type
03:25:30 <shachaf> A tuple is a fixed-size-at-compile-time record of different types.
03:25:39 <opqdonut> yeah, a tuple is just a simple record
03:25:46 <shachaf> A list is a variable-size linked list of elements of the same type.
03:25:49 <opqdonut> (with integers for field names)
03:25:50 <shachaf> There's very litle similarity, really.
03:26:04 <taylanub> i see, lisp lists/vectors are quite different then
03:26:56 <opqdonut> the main difference between haskell lists and lisp lists is that haskell lists are typed: you can't have something like [1,2,[3,4,5],6]
03:28:40 <Eduard_Munteanu> data List a = Nil | Cons a (List a); data TuplePair a b = Pair a b, so...
03:29:30 <Eduard_Munteanu> Also, lists are O(n) for random access.
03:30:05 <shachaf> Eduard_Munteanu: To be fair, so are tuples.
03:30:12 <shachaf> Except n is fixed at compile time. :-)
03:30:18 <shachaf> (So n = 1.)
03:30:51 <opqdonut> are they?
03:31:00 <Eduard_Munteanu> shachaf: hm? There's no head to a tuple, all their elements are equally easy to access, AFAIK.
03:31:05 <opqdonut> I thought they had a structish implementation
03:31:18 <opqdonut> just like data Tuple4 a b c d = Tuple4 a b c d
03:31:38 <shachaf> Eduard_Munteanu: Right, but even if it was a "linked list", since the size is knows at compile time, it's still constant. :-)
03:31:48 <shachaf> Well, that's not really true.
03:31:51 <opqdonut> yeah
03:31:52 <shachaf> But anyway it doesn't matter.
03:33:19 <Jafet> It could be O(log(n)), which is O(log(1)), which is O(0). Accessing tuples are free!
03:34:13 <shachaf> But 1 = 0.5, right?
03:34:29 <shachaf> So it's really O(log(0.5)), which means your program actually gets faster the more tuple access you do.
03:35:02 <augustss> Be careful with big-O
03:35:03 <Jafet> That explains why GHC core is full of tuples.
03:35:35 * shachaf still wants an O(1/n) algorithm.
03:36:31 <opqdonut> I often prefer a one-off record
03:36:38 <opqdonut> to tuples
03:36:53 <opqdonut> for state/accumulator-like things
03:37:18 <Jafet> We just need first class constructors
03:37:27 <Jafet> They Will Solve Everything.
03:39:12 <Eduard_Munteanu> O(-(2^n)) sounds even better
03:45:12 <qff> Hi, regarding Dynamic Programming/Memoization in Haskell
03:45:54 <qff> most tutorials seem to separate the recursion into a where clause
03:46:21 <hpaste> qff pasted “One-line memoization” at http://hpaste.org/50484
03:47:14 <qff> is there some hidden logic in that or can you just as well do it in one line without the extra layer of indirection
03:48:09 <qff> e.g. http://hpaste.org/50484
03:48:10 <agks> hi
03:49:19 <Jafet> qff: fibs is Array a; fibs is n -> a
03:49:48 <Jafet> And sure, you can do it in one line.
03:50:35 <qff> So there's no 'behind the scenes' difference?
03:50:38 <Jafet> But note that you might not be able to, if the argument to listArray was overly strict
03:50:52 <Jafet> It works in Haskell due to laziness.
03:52:07 <qff> Yup, that's why I thought it ought to work
03:52:09 <Eduard_Munteanu> I think you want to force all terms up to n here, no?
03:52:11 <qff> Thank you
03:52:41 <qff> I know, that's more efficient and you won't have the delay
03:52:45 <Jafet> It may or may not work if listArray is storing into a strict array
03:53:08 <Jafet> Eduard_Munteanu: it already does
03:53:23 <Jafet> Well, GHC might give you a stack error; I'm not sure
03:55:17 <qff> Well, it seems to work
03:56:29 <Eduard_Munteanu> That might depend on n.
03:56:32 <Jafet> Try with a smaller stack.
03:57:25 <Eduard_Munteanu> > let fibs = listArray (1,10^6) $ 1:1:[ fibs ! (i-1) + fibs ! (i-2) | i <- [3..10^6] ] in fibs 10000
03:57:26 <lambdabot>   Couldn't match expected type `t1 -> t'
03:57:26 <lambdabot>         against inferred type `GHC.A...
03:57:29 <Eduard_Munteanu> > let fibs = listArray (1,10^6) $ 1:1:[ fibs ! (i-1) + fibs ! (i-2) | i <- [3..10^6] ] in fibs ! 10000
03:57:32 <lambdabot>   336447648764317832666216120051075433103021484606800639065647699746800814421...
03:57:37 <johan___> bonjour
03:57:41 <Eduard_Munteanu> Hi.
03:58:21 <Eduard_Munteanu> @hoogle a i e -> i -> e
03:58:21 <lambdabot> Control.Monad.Reader runReader :: Reader r a -> r -> a
03:58:21 <lambdabot> Control.Monad.State.Lazy evalState :: State s a -> s -> a
03:58:21 <lambdabot> Control.Monad.State.Strict evalState :: State s a -> s -> a
03:59:01 <Jafet> > let fibs = listArray (1,10^6) $ 1:1:[ fibs ! (i-1) + fibs ! (i-2) | i <- [3..10^6] ] in fibs ! 999999
03:59:02 <Eduard_Munteanu> Ah, wait, that's the Array (!), not (!!)
03:59:04 <lambdabot>   *Exception: stack overflow
03:59:36 <Jafet> Unfortunately, it might be tricky to find the right time to force the evaluation.
04:00:44 <qff> hmm
04:01:22 <Jafet> It might also play screwball with GHC's poor man's scheduling, since (if Array Int) it might end up not doing allocation
04:01:42 <Jafet> Array i Int, that is
04:02:35 <Eduard_Munteanu> Do lists even fuse with listArray?
04:02:41 <dibblego> I wish GHCi would allow me to !foldr to run the last foldr that I typed
04:02:53 <Jafet> Oh, guess not
04:06:36 <qff> is forcing evaluation the smartest way to avoid stack overflow in this case?
04:07:38 <Rc43> Hi.
04:08:07 <Jafet> Well, forcing it is the source of stack overflow.
04:08:31 <Rc43> How can I concatenate parsing result in Parsec? E.g. test =  letter >> many digit will produce "123" on input "a123".
04:08:37 <Rc43> And why it is so?
04:08:56 <Rc43> For what I need to use `skip' if results are skipped by defaults.
04:09:06 <Eduard_Munteanu> Jafet: hm? I thought the issue was it didn't force until it hit 'n'.
04:09:23 <Eduard_Munteanu> Well, besides the list not fusing.
04:09:52 <Jafet> Stop agreeing with me!
04:10:04 <Eduard_Munteanu> Oh :)
04:10:50 <Jafet> Rc43: (>>) discards the left-side result; (>>=) retains it
04:11:04 <Jafet> You may want to read some Monad tutorials
04:11:22 <ClaudiusMaximus> > let x !+! y = x `seq` y `seq` x + y ; fibs = listArray (1,10^6) $ 1:1:[ fibs ! (i-1) !+! fibs ! (i-2) | i <- [3..10^6] ] in fibs ! 999999
04:11:23 <lambdabot>   Occurs check: cannot construct the infinite type:
04:11:23 <lambdabot>    e = GHC.Arr.Array i e
04:11:44 <ClaudiusMaximus> > let x !+! y = x `seq` y `seq` x + y ; fibs = listArray (1,10^6) $ 1:1:[ (fibs ! (i-1)) !+! (fibs ! (i-2)) | i <- [3..10^6] ] in fibs ! 999999
04:11:46 <lambdabot>   *Exception: stack overflow
04:12:07 <Jafet> Your listArray isn't strict in the arguments.
04:12:28 <Jafet> Actually, it might overflow the stack even if it was, because it's supposed to be able to evaluate the elements in any order.
04:12:32 * Jafet kicks GHC.
04:13:28 <Eduard_Munteanu> Array should really have a primitive to build an array without using lists.
04:13:29 <augustss> !+! is the same as + for most types.
04:13:44 <Jafet> Rc43: I haven't used Parsec, but I presume that the following would work: letter >>= \l -> many digit >>= \ds -> return (l, ds)
04:13:59 <augustss> The extra seq in !+! don't do anything interesting
04:14:07 <Jafet> Hey, that's Cale's line
04:14:15 <augustss> I don't care
04:14:21 <augustss> :)
04:15:37 <Jafet> I don't have any good ideas for working around this stack overflowing.
04:16:32 <ClaudiusMaximus> i can't seem to reproduce it in my ghci
04:16:35 <Jafet> I guess you could embed your own stack-clearing trampoline into the recursion, but that sounds worse than the time I composed three "unsafe" functions in a row
04:16:44 <Rc43> Jafet, yes, I know about it, but split strings and concatenate thme than is slow way, i think.
04:17:13 <Jafet> I don't know any parsec specific answers, but there should be one in the manual
04:20:36 <qff> Well, thank you. I'll try and find a solution for the stack overflow
04:21:31 <ClaudiusMaximus> my ghci goes ok up to fibs ! 99999 with 20k decimal digits, still seeing if ! 999999 will complete
04:26:17 <ClaudiusMaximus> well, it got OOM-Killed (64bit, 8GB)
04:36:29 * hackagebot data-timeout 0.1 - 64-bit timeouts of nanosecond precision  http://hackage.haskell.org/package/data-timeout-0.1 (MikhailVorozhtsov)
04:38:38 <Philonous> Lemmih:  Regarding acid-state, is there a way to prune the logs once a checkpoint is written?
04:40:00 <Lemmih> Philonous: Yes.
04:40:57 <Philonous> Lemmih:  Any hint where to look? It doesn't seem to do it on it's own
04:41:42 <Lemmih> Philonous: You need to get the development version and then use 'createArchive'.
04:41:59 <Philonous> Ah, fair enough, thanks!
04:42:29 <Lemmih> Philonous: What are you using acid-state for, OOI?
04:43:27 <Philonous> I'm hacking together a feed reader.
04:44:50 <Lemmih> Philonous: So you're mainly concerned with convenience over, say, performance?
04:49:44 <Philonous> Lemmih: Yes, performance is basically a non-issue, I chose acid-state because it adapts to my choice of data structures rather than the other way around
04:57:48 <erus`> anyone on arch in here?
04:57:56 <shachaf> Yes.
04:58:03 <shachaf> (Not me, though.)
04:58:33 <erus`> its not like ubuntu :|
04:58:43 <erus`> i feel like a real hacker
04:59:12 <seit> I'm trying to use a where clause in a lambda function, but can't get the syntax correct.  Could anyone give an example?
04:59:26 <shachaf> seit: You can't.
04:59:37 <seit> shachaf, ah, that explains why it is difficult :-)
04:59:41 <shachaf> seit: where only works on binding/declarations, i.e., places where you have an =.
04:59:48 <erus`> > (\ s -> a where a = s) 1
04:59:49 <lambdabot>   <no location info>: parse error on input `where'
05:00:03 <shachaf> seit: You can use let, though.
05:00:28 <Philonous> > (\x -> let foo = x+2 in foo *3) 5
05:00:29 <lambdabot>   21
05:00:44 <seit> shachaf, excellent, let me try that.
05:00:56 <seit> erus`, I'll give your example a try as well, thanks
05:01:04 <erus`> seit: it didnt work
05:01:16 <shachaf> seit: See lambdabot's responses. :-)
05:01:36 <seit> ha, ok.  I see lambdabot's response
05:03:26 <seit> Great, the let clause works perfectly and looks like a cleaner description for the function as well
05:03:27 <seit> thanks
05:23:02 <Entroacceptor> hi Fleurka
05:29:25 <blomqvist> Hi everyone
05:29:38 <blomqvist> Is it possible to build GHC without bootstrap GHC ?
05:32:42 <dibblego> is there a foldl1 returning Maybe instead of launch a nuclear attack?
05:33:55 <Botje> hmm?
05:34:08 <dibblego> foldl1 (+) []
05:34:11 <dibblego> > foldl1 (+) []
05:34:12 <lambdabot>   *Exception: Prelude.foldl1: empty list
05:34:50 <Botje> you could use foldl instead
05:35:02 <Botje> or wrap foldl1
05:35:09 <dibblego> sure, was hoping to have a nicer function
05:36:30 * hackagebot swish 0.5.0.1 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.5.0.1 (DouglasBurke)
05:37:58 <n0den1te> maybe I'm missing something. Using foldl won't even pass the typechecks with (+)
05:38:03 <n0den1te> > foldl (+) []
05:38:03 <lambdabot>   Overlapping instances for GHC.Show.Show ([[a]] -> [a])
05:38:04 <lambdabot>    arising from a us...
05:38:22 <dibblego> you missed the 1
05:38:37 <dibblego> foldl (+) alone type-checks
05:38:44 <dibblego> foldl1 (+) [] type-checks
05:38:47 <n0den1te> dibblego: yes, ofcourse. I was referring to Botje's suggestion of using foldl.
05:38:50 <dibblego> foldl (+) [] does not
05:39:04 <n0den1te> dibblego: exactly.
05:39:09 <dibblego> oh he meant to use foldl instead of foldl1 but with different function, which is what I did
05:39:52 <n0den1te> Oh, I see. :)
05:40:20 <dibblego> just annoys me
05:40:28 <dibblego> and the writer of the spoon package I suppose
05:41:08 <n0den1te> then wire up safe_fold or sffold. ;)
05:41:23 <dibblego> boo
05:44:26 <n0den1te> heh. Does anybody else find the latest Opera sucks at page scrolling? It scrolls 1.5 pages with a single press of page down.
05:44:57 <Botje> 1 page for me
05:45:14 <Botje> opera 12 pre-alpha build 1047 on osx
05:45:54 <n0den1te> Opera 11.5 on x86 Linux. :/
05:46:12 <Botje> I should have that installed as well, i could cehck
05:46:28 <Botje> but i should be writing on my paper instead :)
05:47:53 <n0den1te> Botje: Never mind. It just annoys me at times. :)
06:41:06 <illissius_> C-C-C-COMBO BREAKER!
06:42:21 <erus`> have we got more users than python?
06:42:46 <merijn> erus`: On freenode? I think so
06:43:16 <erus`> we have reached the first milestone on the way to world domination
06:43:59 <merijn> @quote ivory.towers
06:43:59 <lambdabot> dons says: we had 15 years building ivory towers - time to throw rocks from the top!
06:50:05 <Jafet> Ivory Towers? Sounds like an up-and-coming area
07:00:07 * RenJuan wonders at whom
07:05:27 <merijn> RenJuan: Everyone who isn't writing haskell, of course ;)
07:33:22 <mysticc> How to covirt a string to ByteString
07:33:49 <Jafet> How to convert [Char] to [Word8]?
07:33:49 <roconnor> Data.ByteString.Char.pack
07:33:57 <roconnor> @hoogle Data.ByteString.Char.pack
07:33:58 <lambdabot> No results found
07:34:06 <Jafet> @slap roconnor
07:34:06 * lambdabot places her fist firmly on roconnor's jaw
07:34:13 <illissius_> @hoogle Data.ByteString.Char8.pack
07:34:14 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
07:34:14 <lambdabot> Data.ByteString.Char8 packCString :: CString -> IO ByteString
07:34:14 <lambdabot> Data.ByteString.Char8 packCStringLen :: CStringLen -> IO ByteString
07:34:22 <roconnor> illissius_: thanks
07:34:37 <roconnor> mysticc: Data.ByteString.Char8.pack
07:34:40 <illissius_> yw
07:35:10 <Jafet> Isn't Char8 partial?
07:35:14 <RenJuan> anybody using 7.2 heavily and finding that aside from breaking older pkgs it is _ ?
07:35:45 <mysticc> roconnor: Is there  a function similar to getArgs which returns bytestring or I will have to convert it ... I need to search the argument in a file read as bytestring ..
07:36:02 <roconnor> mysticc: oh right, this only works for ISO-LATIN-1 strings
07:36:33 <Jafet> Okay, you guys can make up for this mess by teaching mysticc the concept of character encodings
07:36:44 <mysticc> :)
07:37:21 <roconnor> mysticc: what is the encoding used for the file being read?
07:38:44 <mysticc> roconnor: ascii
07:39:02 <roconnor> mysticc: are you absolutely sure?
07:39:33 <zygoloid_> @google getargs haskell bytestring
07:39:34 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-ByteString.html
07:39:34 <lambdabot> Title: Data.ByteString
07:39:35 <Jafet> Are you absolutely sure he is absolutely sure??
07:39:36 <mysticc> roconnor: It depends because I am making a general program
07:39:52 <Jafet> mysticc: how many different characters are there in ASCII?
07:40:01 <zygoloid_> mysticc: ^^ Data.ByteString.getArgs returns a ByteString :)
07:40:06 <Botje> 127.
07:40:15 <mysticc> The test file I am using has encoding us-ascii about 2 mb
07:40:16 <zygoloid_> or rather, it's an IO [ByteString] :)
07:40:37 <mysticc> zygoloid_: Thanks ....
07:41:24 <Jafet> I guess the stupidest way is also the best way
07:42:02 <mysticc> zygoloid_: http://www.haskell.org/ghc/docs/7.0.3/html/libraries/bytestring-0.9.1.10/Data-ByteString.html nothing mentioned as getArgs here
07:42:46 <zygoloid_> mysticc: hmm, possibly it's very new?
07:43:03 <mysticc> @hoogle Data.ByteString.getArgs
07:43:04 <lambdabot> No results found
07:43:23 <mysticc> See no function like that
07:54:51 <roconnor> mysticc: ya, but you can use String -> ByteString to tranfrom the getArgs into something producing ByteStrings
07:55:26 <roconnor> mysticc: (though in theory it would be better to convert the file from ByteString to something like String.
07:56:30 * hackagebot AspectAG 0.3.4.1 - Attribute Grammars in the form of an EDSL  http://hackage.haskell.org/package/AspectAG-0.3.4.1 (MarcosViera)
07:56:36 <mysticc> roconnor: What if file is very large .. I was planning to use Bytesting.Lazy
07:57:45 <monochrom> there are 128 characters in ASCII. C tries to use only 127 of them, but see http://queue.acm.org/detail.cfm?id=2010365
07:59:15 <roconnor> mysticc: Presumably there is some sort of iteratee-based UTF-whatever decoding library since this is exactly the problem that Iteratees were designed to solve.
08:02:17 <kizzx2> i find that many functions are actually not total (i.e. return result is Maybe), what's the best practice to prevent Maybe from propagating resulting in a lot functions returning Maybe?
08:02:37 <kizzx2> s/many functions/many functions i write/
08:02:40 <Botje> uh, you generally _want_ to propagagte a Maybe.
08:03:03 <ezyang> kizzx2: That's OK. You can use the maybe monad to make propagating this less painful.
08:03:04 <Botje> if the situation is uncommon (eg. indicative of a programmer error) you could use the error function
08:03:05 <kizzx2> Botje: yeah i get that... but is it normal for a lot of functions end up returning Maybe?
08:03:26 <Botje> kizzx2: can you hpaste a few functions you are not 100% certain of?
08:03:28 <ezyang> kizzx2: You may want to consider alternative error reporting mechanisms if it's not obvious what the particular error was.
08:03:37 <ezyang> But yeah, that's pretty normal.
08:03:56 <roconnor> kizzx2: you can use the type system to restrict the input domain of your functions whenever possible to make them total once again.  (i.e. using non-empty list types, etc)
08:04:45 <monochrom> depends on why you get a Maybe in the first place
08:05:01 <kizzx2> roconnor: is it something like making my own list type (a newtype) an ADT and providing a constructor that ensures a non empty list? so that sort of throws the ball back to the caller
08:05:16 <kizzx2> roconnor: (not that it's bad, i'm just re-stating what i get)
08:05:41 <roconnor> kizzx2: only if the caller cannot prove the list isn't non-empty
08:06:09 <kizzx2> umm let's say, for example
08:06:15 <kizzx2> i am re-writing head
08:06:17 <roconnor> in my examples I can usually push the error all the way back to parsing data, which is already necessarily a partial function.
08:06:37 <kizzx2> and my caller *can* prove the list is empty or not, but as the caller, i dont know whether `head` can handle a non-empty list or not
08:07:01 <kizzx2> as `head`'s author, short of asking ppl to look up doc, what's the best way using the type system to advertise that i cannot accept an empty list?
08:07:15 <roconnor> make head operate on a non-empty list type.
08:07:37 <merijn> kizzx2: Well, me (and numerous others) think "head" should return a Maybe too
08:07:41 * ezyang wrinkles nose at non-empty list type 
08:07:42 <monochrom> head x xs = x
08:07:43 <roconnor> er, I'm probably using "prove" in a technical sense here.
08:07:47 <kizzx2> uh i'm not sure i'm following, does that just mean the current head implementation?
08:07:53 <ksf> data List a = Cons a (List a) | End a
08:08:07 * merijn is in favor of renaming "head" to "unsafeHead" for clarity and puns sake :)
08:08:15 <roconnor> it means something like data NonEmptyList a = NEList a [a]
08:08:26 <kizzx2> roconnor: ook
08:08:27 <roconnor> and neHead (NEList x _) = x
08:08:38 * monochrom should post his head x xs = x idea to haskell-cafe for more people to enjoy
08:09:05 <merijn> kizzx2: The other solution is to do something like the "maybe" function
08:09:07 <merijn> :t maybe
08:09:08 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:09:15 <merijn> eh
08:09:17 <merijn> Wrong one
08:09:25 <kizzx2> i'm starting to write a "real world project", i've read the theories (make ADT (like NEList)), returning Maybe, etc.
08:09:27 <kizzx2> i think it's
08:09:27 <monochrom> that's the right one
08:09:28 <kizzx2> :t fromMaybe
08:09:29 <lambdabot> forall a. a -> Maybe a -> a
08:09:37 <merijn> There we go
08:09:49 <kizzx2> i'm just wondering whether sprinkling all these extra types, or Maybe, is normal
08:09:57 <merijn> monochrom: Oh, I missed the b at the start
08:10:29 <ksf> the easier way is not using head.
08:10:48 <ksf> if you want to take your list apart, just pattern match.
08:11:03 <monochrom> yeah, head is not a relevant example, there are only few legit uses
08:11:05 <kizzx2> it seems like for any large programs, all top level functions will end up being a Maybe or an Either of some sort
08:11:18 <kizzx2> "top level" means outward facing
08:11:24 <kizzx2> er, whatever that means :P
08:11:44 <ksf> only if you can stick invalid input into them.
08:11:59 <merijn> kizzx2: Designing APIs is hard in any language. You have the same issue in Java/C (does a function return NULL or not, etc)
08:12:03 <monochrom> those Maybes and Eithers don't propagate into the internals
08:12:32 <merijn> dankna: Ping?
08:12:36 <kizzx2> ksf: i guess most non-trival systems have to deal with the possibility of invalid input
08:12:42 <mysticc> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-ByteString.html#v%3AgetArgs This thinks shows there is a getArgs for bytestring ... Anybody knows which module is it in ghc...
08:12:44 <monochrom> and yes it's the same thing regardless of language
08:12:44 <roconnor> kizzx2: I really don't have many partial functions much beyond parsing
08:13:53 <ksf> kizzx2, well, in that case you have the choice between having the caller construct the query in a type that can't represent invalid input, report an error, or rely on a contract and bail out hard.
08:13:56 <roconnor> if your data types really capture only valid data, then you don't have partial functions.
08:14:02 <kizzx2> e.g. i am writing an PDF "encoder"
08:14:30 <kizzx2> like many spec'ed file format, there are things like integer values which correspond to some table in the spec
08:14:47 <kizzx2> and non-spec'ed integers are obvioulsy invalid inputs
08:15:02 <merijn> Use a data type to represent that table, only accept that data type?
08:15:02 <roconnor> kizzx2: encoding from what?  If all inputs have a valid PDF output, then everything should be total
08:15:26 <monochrom> that sounds like parsing
08:15:35 <kizzx2> for example coordinate cannot be negative
08:15:50 <kizzx2> and then font names can be not found in teh system
08:15:56 <ksf> there's number types that can't be negative.
08:16:40 <ksf> the latter doesn't sound like an error, the system generating the pdf might not have it, but the one displaying it.
08:16:50 <ksf> definitely worth a warning, though.
08:16:57 <kizzx2> PDF is basically built from PostScript commands, which can be strings, so there's also the possibility of simply invalid PostScript (OK, this is clearly parsing)
08:17:18 <kizzx2> ksf: o i was talking from the embedding font case
08:17:56 <roconnor> we can expand parsing to the general topic of "validating input"
08:17:56 <ksf> have one module which finds system fonts, packs them into a newtype with unexported constructor, then use that type.
08:18:12 <ksf> so you have a guarantee that all fonts you can use are actually on the system.
08:18:13 <roconnor> so not finding the font is part of validating input
08:18:16 <kizzx2> for the record the system generating the PDF need to  have it in general, because layouting PDF you often need to access the metrics
08:18:23 <kizzx2> (anyway, i digress)
08:18:52 <roconnor> but once the font is found (and locked) you are good to go.
08:20:54 <kizzx2> roconnor: so I get that a strategy is to set up Maybe and Errors at system boundaries where internal functions can use safely use things like  `fromJust` or `head`
08:21:36 <roconnor> well, ideally the internal functions wouldn't need to use fromJust or head, but sometimes this ideal is difficult to achive.
08:21:37 <monochrom> you have a fence of external API that needs to tell the caller "wtf". this need doesn't propagate to internal code.
08:22:53 <roconnor> but at the very least you need to set things up so that head and fromJust are only used in cases where it is impossible for them to fail, and have documentiation of all the invarients required to achieve this fact.
08:28:49 <hiptobecubic> RealWorldHaskell just gave a 1 page blurb to "Maybe" and "Just". Can someone clarify what those actually do? Specifically "Just".
08:29:16 <roconnor> Just is a constructor for building a Maybe Foo value that isn't Nothing.
08:29:56 <hiptobecubic> ... :D
08:29:59 <monochrom> have you seen "data Maybe a = Nothing | Just a"? do you know that syntax?
08:30:19 <hiptobecubic> a "Maybe a" is either Nothing or Just a
08:30:37 <monochrom> then you know
08:30:47 <hiptobecubic> so the Just does nothing really, just let's you know it's not Nothing?
08:30:53 <hiptobecubic> lets8
08:30:59 <monochrom> it also carries data
08:31:25 <monochrom> this is why it is not "data Maybe a = Nothing | Just"
08:32:26 <hiptobecubic> why can't it be "data Maybe a = Nothing | a"
08:32:41 <monochrom> every case needs a label
08:32:45 <kizzx2> hiptobecubic: i think you can start from LearnYouHaskell for a gentler understanding of the foundations :P
08:32:57 <roconnor> hiptobecubic: mostly so that we have unique types for every value
08:33:04 <parcs> > runST (newSTRef 0 >>= \r -> forever (modifySTRef r succ))
08:33:08 <lambdabot>   mueval-core: Time limit exceeded
08:33:26 <illissius> it's sort of like an enum in C, except the various enumerators can also have data belonging to them
08:33:47 <parcs> is modifyIORef strict?
08:33:47 <hoknamahn> hiptobecubic, think of it as of C pointer. you either have a NULL value which gives you nothing or you can take some data if a pointer isn't NULL
08:34:06 <hiptobecubic> alright, sure
08:34:31 <hiptobecubic> So if it's possible that something won't have a value it has to be Maybe a, and then if it happens to have a value it's of type Just a
08:34:46 <kizzx2> hiptobecubic: the type is still Maybe a
08:34:48 <monochrom> of value Just a
08:34:54 <hiptobecubic> oh, sorry. yes
08:34:55 <kizzx2> hiptobecubic: Just is a data constructor
08:35:09 <hiptobecubic> i feel like they should have gone with 'Surely' or 'Definitely' instead of 'Just'
08:35:24 <hiptobecubic> :)
08:35:37 <monochrom> yes you can mince words to no end. SML calls it "data Option a = None | Some a"
08:35:47 * illissius likes Surely
08:35:49 <kizzx2> hiptobecubic: that would get quite confusing when you read about List monad's non-determinstic behavior and then you have Definitely [a]
08:35:50 <hiptobecubic> gross.
08:36:03 <roconnor> don't call me Surely
08:36:10 <kizzx2> * List monad's modelling of non-determinstic computation
08:36:22 <monochrom> why don't you define your own "data Maybe a = Nothing | Surely a" and upload it to hackage so everybody can use it?
08:36:25 <hiptobecubic> "data Maybe a = Nothing | Definitely a" :)
08:36:30 <kizzx2> lol
08:36:48 <hoknamahn> Shuskell
08:38:52 <hpc_> data Maybe a = NotSure
08:39:15 <monochrom> this illustrates the stellar success of the great idea of "meaningful" names
08:41:51 <hoknamahn> data Maybe a = SurelyNot
08:42:16 <Botje> data Maybe a = TheresNoBudgetForIt | ThinkOfTheChildren a
08:42:18 <hoknamahn> or Naah | Okay a
08:49:35 <hiptobecubic> data Maybe a = GoneAlready | Ephemeral a
08:51:08 <hiptobecubic> As silly as this has been, I think it's actually taught me how this works. Thanks ladies and gentlemen.
08:53:31 <Botje> yay, learning!
08:53:36 <illissius> data Maybe a = Ain'tNothin'
08:57:34 <hiptobecubic> i like these exercises in RWH
08:59:53 <erus`> is the biggest haskell codebase ghc?
09:01:09 <merijn> erus`: The biggest open source codebase, at least
09:01:11 <monochrom> hackage may be bigger
09:01:30 * hackagebot git-annex 3.20110819 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20110819 (JoeyHess)
09:10:38 <hiptobecubic> "Define a tree type that has only one constructor. Instead of the Empty constructor, use the Maybe type to refer to a node’s children."
09:11:05 <hiptobecubic> Will that require defining a Node type ahead of time?
09:11:16 <merijn> hiptobecubic: No
09:11:19 <hiptobecubic> hmm
09:11:20 <Botje> what do you mean 'ahead of time'?
09:11:33 <Botje> haskell data structures can be recursive; e.g. lists
09:11:46 <merijn> One possible example: data Tree a = Node a (Maybe Tree a) (Maybe Tree a)
09:11:48 <hiptobecubic> So you have a tree, and each node can be either nothing or just tree
09:12:14 <zoomzim> hey guys, im doing a boat load of Bytestring.spliAt followed by printfs. every time i call splitAt i have to bind the remainder to a new name. pretty ugly. is there a better way?
09:12:16 <Botje> Maybe (Tree a), but yes
09:12:20 <merijn> (might need brackets around "Tree a" as well
09:12:39 <merijn> Botje: close-enough.jpg :p
09:13:01 <augustss> zoomzim: a state monad, perhaps
09:13:12 <hiptobecubic> Is there another way to do it?
09:13:19 <kniu> What is "subsumption"?
09:13:25 <zoomzim> im doing io though
09:13:45 <hiptobecubic> data Tree a = Maybe (Node a (Tree a) (Tree a)) ?
09:13:49 <augustss> zoomzim: that's ok
09:14:20 <parcs> hiptobecubic: Tree a = Tree (Maybe (Node a (Tree a) (Tree a)))
09:14:22 <merijn> hiptobecubic: Maybe as a constructor for tree won't work
09:14:34 <kniu> type Tree a = Maybe (a, Tree a, Tree a)
09:14:54 <zoomzim> how do you combine io and state?
09:15:12 <augustss> zoomzim: you can use the StateT monad transformer on top of IO
09:15:15 <hiptobecubic> "data Tree'' a = Just (Node'' a (Tree a) (Tree a))"  :D
09:15:23 <merijn> data Tree a = Tree (Maybe a) (Tree a) (Tree a)
09:15:35 <augustss> zoomzim: but maybe there's a better way to do what you do.  It's hard to tell
09:15:46 <merijn> Bit inefficient since you'll have two empty nodes at each junction
09:15:48 <kniu> zoomzim, hpaste
09:15:58 <merijn> hiptobecubic: As you can see, plenty of possibilities
09:16:36 <hiptobecubic> ok i think i'm seeing this now
09:16:50 <augustss> data Tree a = Node a [Tree a]
09:16:56 <benmachine> kniu: type synonyms can't be recursive I don't think
09:17:19 <merijn> augustss: Like my first example that disallows empty trees
09:17:34 <merijn> "data Tree a = Node Maybe a [Tree a]" would work, though
09:17:52 <augustss> benmachine: the recursion has to go through a data type
09:18:11 <zoomzim> cant hpaste, im ircing from my phone. no internet
09:18:22 <benmachine> augustss: right, newtypes are often used for this
09:18:30 <augustss> benmachine: yes
09:18:51 <benmachine> or if you're particularly perverse, Mu :P
09:18:53 <zoomzim> basically im processing udp packets
09:20:04 <augustss> zoomzim: maybe you should consider a parser
09:20:40 <zoomzim> the structure is too trivial for a parser
09:20:52 <zoomzim> and speed is important
09:20:55 <augustss> Nothing is too trivial for a parser
09:21:10 <augustss> If you're using printf speed is obviously not important. :)
09:21:33 <zoomzim> whats the alternative?
09:22:08 <augustss> zoomzim: depends on if you need the fancy formatting of printf or not
09:25:14 <zoomzim> i do (to print the time)
09:26:40 <KirinDave> I dunno if this sort of thing would resonate in here
09:26:51 <KirinDave> but I've been trying to explain to people why I have been devoting so much time to failing at haskell projects
09:27:01 <KirinDave> http://dave.fayr.am/posts/2011-08-19-lets-go-shopping.html
09:27:10 <KirinDave> Would appreciate comments for improvements.
09:27:39 <kniu> how do I debug infinite loops?
09:27:48 <augustss> zoomzim: as long as printf is fast enough…
09:27:53 <KirinDave> kniu: Preferably in a finite amount of time.
09:28:32 <KirinDave> kniu: I am not a pro at this, but Debug.Trace.trace has helped me out of logic errors more than once now.
09:28:51 <KirinDave> kniu: http://www.haskell.org/haskellwiki/Debugging has some idioms.
09:29:03 <kniu> KirinDave, okay thanks
09:30:37 <applicative> @quote oasis --irresistable, as usual
09:30:38 <lambdabot> No quotes for this person. Just try something else.
09:30:45 <applicative> @quote oasis
09:30:45 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
09:37:07 <ricree> Is there a gui for viewing the results from profiling a program?
09:37:36 <KirinDave> Haha
09:37:42 <KirinDave> That quote is fantastic.
09:37:58 <KirinDave> Ugh
09:37:59 <KirinDave> https://bitbucket.org/paradoxiology/hreddit/src
09:38:05 <KirinDave> People really need to learn to use cabal.
09:38:21 <KirinDave> ABC, where C is Ca'ballin'.
09:39:26 <thoughtpolice_> KirinDave: indeed
09:39:38 <thoughtpolice_> i would offer to help, but i hate mercurial :>
09:39:41 <KirinDave> Yeah
09:39:53 <KirinDave> I mean, I'm glad people are using dvcs.
09:40:07 <KirinDave> but not SO glad that I am going to get my fingers dirty touching something with such a weird model.
09:40:32 <KirinDave> (it's a shame about darcs, tho)
09:42:51 <zachk> what happened to darcs?
09:43:00 <nihtml> :t (=<<)
09:43:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
09:43:15 <KirinDave> zachk: It is sorta.. not even a real option for people with non-trivial projects.
09:43:32 <nihtml> (=<<) = flip (>>=) ?
09:43:54 <KirinDave> zachk: Git and Mercurial just sort of consumed the whole space, with everyone left on perforce trying to figure out how to get over to git or mercurial.
09:44:03 <sshc> If I run 'finalizeForeignPtr' on a ForeignPtr, and use it with 'withForeignPtr', what will happen?  Will the program safely / informatively crash, or will there be undefined behaviour?
09:44:27 <monochrom> I think that's bad
09:44:37 <c_wraith> you should never run finalizeForeignPtr manually anyway
09:44:47 <c_wraith> you should register it as a finalizer
09:45:04 <c_wraith> So it's only called after the ForeignPtr goes out of scope
09:45:47 <monochrom> withForeignPtr does a tocuh at the end
09:46:47 <KirinDave> Is anyone from #haskell doing that ludum dare thing?
09:47:25 <c_wraith> does touchForeignPtr need special support to not get compiled out as a no-op?
09:49:26 <sshc> 17:18:27 < monochrom> I think that's bad — …Yes.  I don't think that really answers my question.
09:50:01 <c_wraith> My answer *does* answer it though.  why think about it.  Unless you really try to do something wrong, it won't happen.
09:53:47 <sshc> c_wraith: I still don't know whether the behaviour of that is defined (whether it'll crash nicely or not).  As far as I understand it, your response was to never do it, not whether it'll crash nicely or not.
09:55:38 <c_wraith> my response was "it'll never happen unless you try.  It's not like a double-free in C, where it can happen accidentally.  You have to be malicious."
09:57:17 <sshc> c_wraith: What's the first "it" referring to? :)
09:57:29 <KirinDave> sshc: Why do you want to explicitly finalizeForeignPointer?
09:57:36 <sshc> KirinDave: I don't.
09:57:40 <KirinDave> sshc: Ah
09:58:13 <c_wraith> the first "it" referred to using a ForeignPtr after finalizeForeignPtr was called.
10:11:49 <jophish> Hi all!
10:12:07 <jophish> I'm using ghci, I have this:
10:12:23 <jophish> let fib n = fib (n-1) + fib (n-2)
10:12:34 <jophish> let fib 0 = 1
10:12:42 <jophish> let fib 1 = 2
10:12:46 <opqdonut> you have to define those in the same "let"
10:12:51 <opqdonut> separate the definitions with ;
10:12:51 <jophish> ah
10:13:01 <opqdonut> and put the constant cases first
10:13:02 <jophish> thanks opqdonut!
10:13:09 <opqdonut> since patterns are matched in order
10:13:13 <jophish> why the constant cases first?
10:13:15 <jophish> ah ok
10:13:19 <jophish> thanks again
10:13:48 <opqdonut> np:)
10:24:05 <hiptobecubic> "data Tree''' a = Tree''' (Maybe a) (Tree''' a) (Tree''' a) deriving (Show)"   can someone make one of these? I couldn't even do it
10:25:30 <hiptobecubic> Tree''' Nothing (Tree''' Nothing (.......       no?
10:25:48 <NihilistDandy> Aren't trees usually made of branches?
10:25:51 <hpc_> let node = Tree''' Nothing node node in node
10:26:04 <NihilistDandy> Fractal trees
10:26:04 <hpc_> ^ an infinite tree of nothing
10:26:08 <NihilistDandy> Nevermind, I have a book to write
10:34:07 <hiptobecubic> Ok i was just confirming
10:34:20 <hiptobecubic> that was a suggested construction in here an hour or two ago
10:41:54 <peterise1ins> is there a way to simplify this expression (in IO)     then (ndMerge xx ys >>= \l -> return (x:l))
10:42:21 <Botje> (x:) `liftM` ndMerge xx ys
10:42:34 <Botje> or `fmap` or <$>, your choice.
10:42:47 <peterise1ins> thanks, that was blazingly fast
10:44:25 <Rotsor> @pl ndMerge xx ys >>= \l -> return (x:l)
10:44:26 <lambdabot> (x :) `fmap` ndMerge xx ys
10:52:39 <dankna> merijn, poing
10:52:42 <dankna> *pong
11:04:21 <mwc> @pf \a b -> flip snd $ g c b a
11:04:21 <lambdabot> Maybe you meant: bf pl
11:04:27 <mwc> @pl \a b -> flip snd $ g c b a
11:04:28 <lambdabot> (flip snd .) . flip (g c)
11:06:02 <mwc> @pl \a b -> fmap snd $ g c b a
11:06:03 <lambdabot> (fmap snd .) . flip (g c)
11:07:29 <sully> @pl \f a b c -> f b c a
11:07:29 <lambdabot> flip . (flip .)
11:07:45 <sully> @pl \f a b c d -> f b c d a
11:07:45 <lambdabot> flip . ((flip . (flip .)) .)
11:07:55 <sully> @pl \f a b c d -> f b c d a a
11:07:55 <lambdabot> join . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .)
11:08:39 <sully> @pl \f  -> f f
11:08:39 <lambdabot> join id
11:08:58 <sully> @pl \f x -> f x x x x
11:08:58 <lambdabot> join . join . join
11:11:32 <kniu> so
11:11:39 <kniu> what is "subsumption"?
11:13:04 <geheimdienst> technical term used in marine engineering to indicate the amount of umption a sub has
11:13:26 <monochrom> loosely, like "1+2=2+1 is subsumed by x+y=y+x"
11:13:34 <mwc> kniu: subsumption is when a more general rule or inference replaces a special case of that
11:14:06 <mwc> kniu: all dogs are mammals subsumes the rule my dog is a mammal
11:14:19 <kniu> mwc, okay thanks
11:14:30 <mwc> or similarly, on the other side of the implication
11:14:43 <kniu> http://research.microsoft.com/pubs/132621/hmf.pdf
11:14:44 <geheimdienst> monochrom, mwc: thanks for your opinions, but i like my explanation better
11:14:52 <kniu> In this paper, in the definition of the subsumption function
11:15:10 <monochrom> "1+2=2+1 is subsumed by x+y=y+x" is subsumed by "special rule is subsumed by general rule" :)
11:15:10 <kniu> the author writes "S - Beta"
11:15:32 <kniu> and I can only guess what that means,
11:15:46 <kniu> since Beta is a sequence of type variables and S is a substitution.
11:16:02 <mwc> My favourite way to zen out when coding haskell is to work out by hand how the types of subexpressions in a point free expression work out
11:16:30 <kniu> no, wait
11:16:32 <kniu> nvm
11:16:41 <kniu> I gotta read these things more carefully
11:16:50 <mwc> like ((fmap snd .) .) :: Functor f => (y -> z -> f(a,b)) -> y -> z -> f b
11:16:57 <kniu> the definition is tucked away in a sentence at the bottom of the paragraph about substitution.
11:26:00 <dylukes> Hm.
11:26:18 <dylukes> So for a tree, you could do a normal order or a post order traversal for a map.
11:26:30 * hackagebot text-format-simple 1.0.0 - Simple text formatting library.  http://hackage.haskell.org/package/text-format-simple-1.0.0 (DmitryBespalov)
11:26:31 <dylukes> Are they both unique definitions of Functor for trees?
11:26:36 <edwardk> dylukes: but purity makes it not matter
11:26:59 <dylukes> That's true.
11:27:05 <edwardk> dylukes: now, the Foldable and Traversable definitions could differ
11:27:16 <edwardk> but by convention we go left to right
11:27:45 <edwardk> and just reorder the arguments in the Bin nodes depending on the intended order
11:28:08 <dylukes> mm...
11:28:09 <edwardk> Bin (Tree a) a (Tree a) vs Bin a (Tree a) (Tree a) vs. Bin (Tree a) (Tree a) a
11:28:18 <minhajud1in> How can I install GHC 7 on ubuntu 10.10, the ubuntu repositories seem to have GHC 6.12
11:28:38 <dylukes> Is there such a thing as a functional recursive tree?
11:28:45 <edwardk> minhajud1in: download the haskell platform
11:29:05 <edwardk> dylukes: define
11:29:12 <minhajud1in> just downloaded it and tried to run ./configure
11:29:27 <dylukes> A tree in which the root note is a child of some other node (which is, at some degree of separation,
11:29:29 <dylukes> a child of the root node).
11:29:42 <minhajud1in> it says ghc-7.0.3 is required to build it
11:29:43 <dylukes> i.e, you will always *eventually* return to the root node.
11:29:48 <dylukes> So all traversals are infinite
11:29:51 <edwardk> dylukes: ah
11:29:56 <edwardk> sure
11:30:10 <edwardk> in part you can implement that with just codata
11:30:15 <dylukes> Not sure how that'd be useful though. Perhaps for representing program flow.
11:30:20 <dylukes> In a program with a central loop.
11:30:26 <edwardk> but uustalu and vene wrote a paper on how to encode trees with loops
11:30:51 <dylukes> I see.
11:30:57 <edwardk> the easiest version is to just enforce that you have an infinite tree by not giving a constructor for a leaf ;)
11:31:01 <minhajud1in> edwardk: It's throwing an error about ghc-7.0.3 not being found
11:31:08 <edwardk> but that doesn't enforce that it loops eventually
11:31:22 <dylukes> It seems it would be a codata structure.
11:31:35 <edwardk> minhajud1in: i haven't had to manually install the haskell platform in a while, so i'm not much help
11:31:39 <dylukes> Or at least, the "largest" solution to the tree equations.
11:32:01 <dylukes> Anyways, m going to get back to my work
11:32:13 <minhajud1in> Here is the ./configure output http://pastie.org/2402893
11:32:20 <edwardk> i use the codata tree representation in my supply comonad
11:32:29 <edwardk> well, its stolen from lennart and iavor iirc
11:33:17 <edwardk> minhajud1in: you can download and install 7.0.3 directly first
11:34:24 <minhajud1in> edwardk: Thanks I'll try that, However, I got confused by the message on the ghc download page which says that "installing the 'Haskell Patform' is recommended instead of GHC"
11:34:44 <minhajud1in> http://www.haskell.org/ghc/download_ghc_7_0_4#x86_64linux
11:34:44 <edwardk> i don't quite understand why they aren't installing together honestly
11:35:23 <edwardk> http://hackage.haskell.org/platform//linux.html says to download 7.0.3 before installing
11:35:40 <edwardk> those would be the instructions to follow
11:36:58 <hoknamahn> hi guys, emerge cabal is failing on linking. it says "missing dependencies: base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.5"
11:37:03 <hoknamahn> how do i fix it?
11:37:43 <edwardk> hoknamahn: what version of ghc do you have installed?
11:37:58 <hoknamahn> 7.2.1
11:38:14 <edwardk> hoknamahn: if you ghc-pkg list | grep unix what version number does it show?
11:38:31 <hoknamahn> 2.5
11:38:38 <edwardk> that is probably your problem
11:38:48 <edwardk> i don't know how to get 7.2.1 to work right ;)
11:39:10 <peterise1ins> @pl ndMerge [1..] [1..10] >>= \l -> putStrLn $ show $ take 10 l
11:39:11 <lambdabot> putStrLn . show . take 10 =<< ndMerge [1..] [1..10]
11:39:46 <hoknamahn> hey edwardk, so 7.0.3 is my choice for now?
11:39:56 <edwardk> yeah
11:40:02 <hoknamahn> okay thanks
11:40:07 <edwardk> the platform isn't built on 7.2.1 and it breaks a bunch of things
11:40:29 <edwardk> wait until the end of september or so when 7.4 comes out and the new platform with it
11:40:42 <edwardk> 7.2.1 is more of a preview release than anything usable right now
11:40:48 <hoknamahn> i see
11:40:52 <hoknamahn> good to know :)
11:41:03 <edwardk> it mostly serves to break my documentation on hackage at this point ;)
11:41:14 <hoknamahn> :))
11:42:37 <NihilistDandy> Is there ever a particular downside to compiling with -O2?
11:42:48 <Botje> compilation time
11:43:41 <Edu__> minhajud1in: can you install it using debian packages? http://packages.debian.org/wheezy/ghc I'm actually bit suprised if this is not available somewhere in ubuntu also
11:44:28 <NihilistDandy> hoknamahn: You could just build cabal-install from the dev branch
11:44:32 <hpaste> Peteris pasted “ndMerge” at http://hpaste.org/50485
11:44:41 <NihilistDandy> I think I just had to edit the cabal file to get it to build
11:45:37 <peterise1ins> anybody have a clue why ndMerge does not halt for two lazy lists?
11:45:44 <hoknamahn> NihilistDandy, thanks. did you have any other problems after installing cabal?
11:46:11 <NihilistDandy> hoknamahn: My only problem was that I had to recompile everything I had been using on 7.0.4 :D
11:46:25 <Edu__> minhajud1in: https://launchpad.net/ubuntu/+source/ghc says latest upload is 7.0.3-1ubuntu4 four days ago
11:46:41 <NihilistDandy> hoknamahn: I'm doing it again on a fresh build to double-check, though
11:47:00 <hoknamahn> okay
11:47:44 <edwardk> NihilistDandy: -O2 can take a good long time and make bigger binaries
11:48:22 * NihilistDandy nods
11:48:41 <NihilistDandy> Though bigger binaries don't concern me except on systems with limited resources
11:48:45 <minhajud1in> Edu__: Thanks for pointing that out, gonna add that to my sources and see
11:49:00 <edwardk> sure
11:49:05 <edwardk> its mostly the compilation speed
11:49:10 <Botje> peterise1ins: the liftM will evaluate the right hand side first
11:49:16 <edwardk> this is why cabal complains when you set a package to -O2
11:49:29 <edwardk> most packages don't really benefit
11:49:33 <Edu__> minhajud1in: yes, seems that oneiric is needed
11:49:38 <Botje> so if that is an infinite computation, you'll never return to do the actual liftM
11:50:59 <NihilistDandy> edwardk: I see. Hmm. Also, I still need to talk to you about semigroups at some point, but I have to run to work :D
11:51:22 <edwardk> sure
11:51:22 <edwardk> what about in particular, anyways?
11:51:30 <edwardk> but don't let me hold you
11:51:55 <dylukes> Mind if I ask whist semigroups are?
11:52:06 <dylukes> I always get confused with semigroups, groupoids, etc...
11:52:17 <dylukes> and especially when someone mentions a certain "algebra"
11:52:24 <dylukes> (in the context of monads/etc)
11:52:25 <edwardk> class Semigroup a where (<>) :: a -> a -> a -- such that (a <> b) <> c = a <> (b <> c)
11:52:29 <NihilistDandy> edwardk: I was just trying to make a simple implementation of permutation groups (mostly because I'd like to be able to think of abstract algebra in Haskell terms, as well)
11:52:35 <edwardk> its just an associative binary operation
11:52:42 <dylukes> edwardk: So its a set with an associative binary op
11:52:46 <edwardk> yep
11:52:50 <dylukes> So all monoids are semigroups then?
11:52:56 <edwardk> dylukes: exactly
11:53:01 <edwardk> monoids are semigroups with a unit
11:53:06 <dylukes> semigroups with a --
11:53:09 <dylukes> heh, yeah
11:53:10 <dylukes> setoid?
11:53:21 <edwardk> and categories are semigroupoids identity arrows
11:53:32 <dylukes> okay, you totally lost me
11:53:37 <dylukes> whats a semigroupoid anyways
11:53:41 <peterise1ins> Botje: would fmap help?
11:53:57 <edwardk> class Semigroupoid k where o :: k b c -> k a b -> k a c
11:54:04 <edwardk> read 'o' like (.)
11:54:12 <dylukes> Reminds me of Arrow.
11:54:16 <dylukes> >_>
11:54:18 <edwardk> @type (.)
11:54:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:54:22 <edwardk> bah
11:54:22 <Botje> peterise1ins: fmap is implemented in exactly the same way as liftM for monads
11:54:24 <edwardk> thats cale'd
11:54:32 <edwardk> @type (Control.Category..)
11:54:33 <Botje> and so is <$>, before you ask.
11:54:33 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
11:54:57 <edwardk> arrows build on category
11:55:06 <edwardk> category is a semigroupoid with identity arrows
11:55:07 <dylukes> but then,
11:55:17 <dylukes> what's the relationship of a semigroup and semigroupOID
11:55:21 <dylukes> and group/groupOID
11:55:29 <edwardk> a semigroup is a semigroupoid with one object
11:55:44 <dylukes> I'm confused TT_TT
11:55:45 <edwardk> or more generally a semigroupoid is a semigroup with more than one object
11:55:49 <peterise1ins> Botje: well fmap is <$> afaik :)
11:56:09 <edwardk> a monoid is a category with one object
11:56:10 <dylukes> what would the single object in a semigroup be though?
11:56:18 <dylukes> isn't 'a' in your example a whole set of objects?
11:56:20 <Botje> yes.
11:56:25 <dylukes> or is 'a' itself the "object"
11:56:27 <dylukes> (a type)
11:56:27 <edwardk> a semigroup is a semigroupoid with one object
11:56:32 <dylukes> What is the "object".
11:56:35 <edwardk> 'a' is the object
11:56:40 <edwardk> the set
11:56:42 <dylukes> Okay.
11:56:45 <edwardk> okays that role
11:56:49 <edwardk> er plays
11:56:53 <dylukes> so a semigroupoid is the same thing, but with more types/sets
11:56:54 <dylukes> w/e
11:56:56 <edwardk> yeah
11:57:07 <dylukes> and then a group?
11:57:12 <dylukes>  /groupoid
11:57:17 <edwardk> a group is a groupoid with one object ;)
11:57:27 <edwardk> groupoids have reversible arrows
11:57:39 <dylukes> so a semigroup is SEMI because its not reversible?
11:57:47 <edwardk> so every group is a monoid, every groupoid is a category
11:58:11 <dylukes> so...
11:58:13 <dylukes> semigroups
11:58:13 <edwardk> the semi comes historically from them being groups where some objects were invertible and some weren't. it eventually weakened to its current usage
11:58:15 <dylukes> a) are not reversible
11:58:20 <dylukes> b) do not have identities?
11:58:25 <edwardk> correct
11:58:38 <dylukes> so theres no categorial dual for a semigroup/oid?
11:58:51 <edwardk> nah, the dual of a category is a category
11:58:57 <edwardk> the dual of a semigroupoid is a semigroupoid
11:59:11 <edwardk> Dual f . Dual g = Dual (g . f)
11:59:16 <dylukes> no, I mean, if the arrows are not reversible,
11:59:22 <dylukes> then how can you get the dual?
11:59:33 <edwardk> the dual of a category just reverses the order of composition
11:59:46 <dylukes> ay... I'm still confused.
11:59:54 <dylukes> I'd love to understand this though.
11:59:54 <edwardk> sok
12:00:17 <dylukes> Would you mind explaining what you would consider the "basics"?
12:00:19 <edwardk> dual /= inverse
12:00:20 <dylukes> I guess, first of all,
12:00:24 <dylukes> in all of these examples,
12:00:33 <dylukes> the objects are sets.
12:00:40 <dylukes> and the arrows are...
12:00:42 <edwardk> they don't have to be though
12:00:52 <dylukes> okay, sure.
12:00:59 <edwardk> you could have the objects be numbers and the arrow be the witness that one is <= the other
12:01:02 <hiptobecubic> Can someone tell me what's wrong with length'' here? http://vpaste.net/nWxbV
12:01:05 <dylukes> okay.
12:01:12 <edwardk> then that composes, and is transitive
12:01:27 <edwardk> and every number is <= itself so it has identity arrows
12:01:37 <edwardk> but each number is an object in the category
12:01:45 <hiptobecubic> Not worried about the logic right, but it doesn't compile because of the xs == [] and i don't see why
12:02:02 <edwardk> swap out the relationship for < and now you have composition still, but no identity arrows
12:02:08 <dylukes> so then would the case of N, < --
12:02:10 <edwardk> so (<) forms a semigroupoid, but not a category
12:02:11 <edwardk> yeah
12:02:13 <dylukes> yeah, would that be a semigroup then?
12:02:25 <dylukes> I mean, theres only one object, in this case N.
12:02:40 <edwardk> -oid, each object is a different number
12:02:52 <dylukes> Ah, alright.
12:02:55 <edwardk> the arrows are proofs, not yielding some element of N
12:02:56 <copumpkin> ohai
12:03:01 <edwardk> heya copumpkin
12:03:09 <copumpkin> still haven't touched the mpfr project, sorry :)
12:03:11 <dylukes> edwardk is explaining CT to me. It's interesting :)
12:03:23 <dylukes> So, if you had a type graph,
12:03:23 <edwardk> mostly just trying to explain its flavor
12:03:30 <copumpkin> what's yo flava
12:03:43 <dylukes> it could form a groupoid under <:
12:03:47 <dylukes> but.. each object...
12:03:54 <edwardk> you can have types be objects, and functions from a -> b be the arrows
12:04:06 <dylukes> sounds like a messy category :P.
12:04:13 <edwardk> you can have types as objects and have the <: relationship give you arrows and have a different category
12:04:21 <dylukes> mm, I get that.
12:04:34 <dylukes> So, then a functor is a mapping between categories?
12:04:39 <edwardk> yep
12:04:43 <dylukes> i.e, from N to the english names.
12:04:47 <dylukes> could be a functor
12:05:01 <dylukes> but then could you have a category of functors where the arrows are compositions of the functors D:?
12:05:02 <edwardk> could be, but you want it to preserve the notion of arrows involved
12:05:23 <edwardk> so that if you composed arrows in the source category, then mapped you'd get the same answer as if you'd mapped each arrow, then composed in the target category
12:05:34 <edwardk> and it needs to preserve the notion of identity arrows as well
12:05:43 <edwardk> exactly
12:05:50 <edwardk> this is the category 'Cat' of small categories
12:05:54 <edwardk> where the objects are categories
12:05:58 <edwardk> and the arrows are functors
12:06:11 <dylukes> .... and I'm guessing this is in turn,
12:06:15 <dylukes> an object in Cat1 or something.
12:06:28 <dylukes> a larger category of smaller categories :<
12:06:32 <dylukes> (of smaller categories)
12:06:34 <edwardk> yeah, because you don't want it to contain itself lest you admit all of russell's lovely paradoxes
12:06:39 <edwardk> yep
12:06:39 <dylukes> its categories all the way down!
12:06:55 <copumpkin> dylukes: but there's even more categories hidden there
12:06:57 <dylukes> So what I'm getting from this is
12:07:00 <dylukes> Categories == Tortoises
12:07:22 <edwardk> and then you can talk about given any two categories, the category that describes the natural transformations between the functors that go between them
12:07:45 <dylukes> "natural transformations"?
12:07:47 <edwardk> and you can compose these natural transformations, etc.
12:07:54 <edwardk> in haskell the analogue would be
12:07:58 <edwardk> (forall a. f a -> g a)
12:08:23 <edwardk> think of a transformation from [a] -> Maybe a -- that is polymorphic in a
12:08:24 <dylukes> oh, so like, flattening a tree
12:08:32 <dylukes> or unflattening a list into a tree
12:08:45 <dylukes> (based on some predefined algorithm to do so I guess, it has to preserve the shape)
12:08:48 <edwardk> it can't decide to do anything differently based on the contents of the list, just choose one of the elements based on some property about the number of elements, or choose the last or the first, etc.
12:09:01 <dylukes> Right.
12:09:02 <edwardk> it can change the shape, but it can't know anything about the content
12:09:11 <dylukes> [a] -> Maybe a would be lossy :<
12:09:24 <dylukes> But I guess that's fine.
12:09:27 <edwardk> naturality basically says it doesn't matter if you fmap before or after you apply the transformation
12:09:50 <edwardk> parametricity ensures naturality in haskell for us
12:09:56 <dylukes> So, if you have some functor F a -> b, does it have to go b -> a as well?
12:09:57 <edwardk> in other categories it can be trickier
12:10:03 <dylukes> Or CAN it just go the other way.
12:10:26 <edwardk> a natural transformation can lose information along the way
12:10:37 <edwardk> a natural isomorphism is reversible
12:11:04 <dylukes> :|
12:11:14 <dylukes> I'm confused by how it can be reversible if you lose information.
12:11:27 <edwardk> two different things
12:12:06 <hpc_> natural isomorphisms are a subset of natural transformations that don't lose information
12:12:09 <edwardk> a natural transformation is just the mapping from one functor to another that says it doesn't matter if i fmap f . transform   or transform . fmap f
12:12:44 <edwardk> a natural isomorphism consists of two such maps (forall a. f a -> g a) and (forall a. g a -> f a) such that they are mutual inverses
12:12:45 <dylukes> okay
12:12:50 <edwardk> so no information can be lost along the way
12:13:01 <edwardk> it is a restriction of the concept, as hpc pointed out
12:13:03 <dylukes> so "isomorphism" implies no loss of information
12:13:06 <edwardk> yeah
12:13:11 <dylukes> "same shape"
12:13:13 <dylukes> makes sense >.>
12:13:20 <ezyang> Have contracts made it into mainline GHC Haskell yet?
12:13:27 <copumpkin> ezyang: I doubt it
12:13:28 <edwardk> can be different shapes, just have to be shapes with the same amount of information in them =)
12:13:33 <dylukes> right right.
12:13:37 <copumpkin> ezyang: I see spj working on it in gitbub every so often
12:13:50 <dylukes> Is this Eiffel now?
12:13:51 <ezyang> "I mean, someone did a PhD thesis on it, surely that means it should've gone in by now..."
12:14:07 <edwardk> ezyang: how does this relate to dana xu's old stuff?
12:14:14 <dylukes> Haskell is just a way for a bunch of PhD's to claim they're practically applicable.
12:14:21 <dylukes> :P
12:14:39 <copumpkin> edwardk: what was the failing call in precision you wanted me to look at?
12:15:14 <edwardk> i just used it to build one, and then tear it apart, and i think i wound up screwing up the precision * sign calculation
12:15:29 <edwardk> i'm not wedded to that approach but it kept everything under 8 args
12:15:55 <copumpkin> oh I mean
12:15:59 <copumpkin> you gave me an example yesterday
12:16:01 <edwardk> fromInt 1 + fromInt 2
12:16:05 <copumpkin> ah okay
12:16:10 <edwardk> :: Rounded TowardZero Double
12:16:10 <copumpkin> hmm, weird
12:16:12 <edwardk> should detonate
12:16:19 <copumpkin> ghci is complaining that precision is a hidden package o.O
12:16:27 <edwardk> hah
12:16:34 <copumpkin> any idea why?
12:16:38 <edwardk> no idea
12:16:43 <edwardk> i don't go out of my way to hide
12:16:52 <edwardk> did you build it
12:16:53 <edwardk> ?
12:16:53 <copumpkin> yeah, I'm not used to ghci complaining about hidden packages
12:17:00 <copumpkin> yeah, it's built and installed
12:17:23 <copumpkin> and not hidden
12:17:29 <copumpkin> oh
12:17:31 <copumpkin> I see
12:17:33 <copumpkin> I'm dumb
12:17:33 <edwardk> ?
12:17:34 <Phyx-> copumpkin: i am :P
12:17:51 <Phyx-> expose it dear lad!
12:17:54 <Phyx-> use the force
12:18:19 <copumpkin> oh I was just trying to import a hidden module from precision :P
12:18:23 <copumpkin> and was misreading the error
12:18:25 <copumpkin> :-[
12:18:36 <copumpkin> okay
12:18:38 <Phyx-> "-[
12:18:40 <copumpkin> reproduced the error :)
12:18:47 * copumpkin puts his spelunking helmet on
12:19:14 <edwardk> sweet
12:19:25 <edwardk> i love it when someone else figures out my bugs for me =)
12:19:38 <edwardk> especially when its buried in c--
12:19:42 <copumpkin> :P
12:19:45 <Phyx-> edwardk: does that happen often?
12:19:56 <copumpkin> I still want to finish up my gmp natural library at some point
12:20:04 <edwardk> Phyx-: more than it used to, i actually get fairly regular bug reports and patches from folks these days
12:20:05 <copumpkin> and maybe get naturals to be a first-class citizen
12:20:06 <rovar> join #scala
12:20:06 <edwardk> its really nice
12:20:12 <rovar> mutter
12:20:14 <rovar> grumble
12:20:16 <edwardk> no ;)
12:20:17 <Phyx-> edwardk: hehee
12:20:34 <edwardk> yeah
12:20:37 * Phyx- spend the entire day playing around with indexed type families and dependent types
12:20:43 <edwardk> i'd really like nicer natural numbers than the ones i have in semigroups
12:20:46 <Phyx-> getting pages full of ghc errors is fun
12:21:01 <edwardk> if you get it farther along i'd switch semigroups to using yours
12:21:01 <rovar> Phyx-: as long as they're intelligible
12:21:15 <rovar> getting pages full of template haskell errors is not fun.
12:21:32 <copumpkin> edwardk: ah, simple mistake :)
12:21:35 <edwardk> compared to errors from the scala compiler?
12:21:42 <edwardk> copumpkin: what'd i flub?
12:21:43 <Phyx-> rovar: i don't even read them
12:21:45 <rovar> oh you just had to bring that up, didn't you :P
12:21:48 <Phyx-> they're just too large
12:21:54 <copumpkin> foreign import prim "mpfr_cmm_init_si" mpfrFromInt#
12:21:55 <copumpkin>   :: CRounding# -> CPrecision# -> Int# -> (# CSignPrec#, CExp#, ByteArray# #)
12:22:01 <copumpkin> it doesn't actually take a CRounding#
12:22:04 <copumpkin> not sure if it should
12:22:05 <edwardk> ahhh
12:22:13 <edwardk> duh
12:22:22 <edwardk> nah it shouldn't
12:23:29 <Edu__> hiptobecubic: I'm not sure about the original error, apparently some problem of comparing [] with ==, but I'm not sure (beginner myself). However, I would write your solution without guards as http://vpaste.net/kefFE
12:23:33 <copumpkin> now it crashes for some other reason
12:23:37 <edwardk> doh
12:23:38 <copumpkin> :D
12:27:07 <Botje> hiptobecubic: comparing [] with == requires your element to be an instance of Eq
12:27:29 <hiptobecubic> Botje, ah.. and because it's generic, it might not be
12:27:29 <Edu__> thanks, botje :-)
12:27:44 <edwardk> ooh segfault
12:27:48 <copumpkin> yeah
12:27:49 <edwardk> such an improvement ;)
12:28:00 <copumpkin> there's another bug in get double, but that leads to yet another bug
12:28:02 <edwardk> progress is messy i suppose
12:28:09 <edwardk> whats that one?
12:28:10 <copumpkin> the registers are off by 1
12:28:13 <edwardk> ah
12:28:16 <copumpkin>   MPFR__mpfr_exp(mpfr) = R3;
12:28:16 <copumpkin>   MPFR__mpfr_d(mpfr) = R4;
12:29:02 <edwardk> ah
12:29:10 <edwardk> patching and retrying
12:30:20 <edwardk> ok, patched that but still crashed
12:30:25 <edwardk> next stupid error? =)
12:30:37 <copumpkin> yep, trying to figure out what's wrong now :)
12:33:34 <hiptobecubic> head : tail :: ____ : last
12:33:49 <edwardk> init
12:34:02 <hiptobecubic> edwardk, thanks :)
12:34:07 <hpc> > init []
12:34:09 <lambdabot>   *Exception: Prelude.init: empty list
12:34:10 <edwardk> well, probably last : init to be anal retentive ;)
12:34:29 <edwardk> > init [1,2,3,4]
12:34:30 <lambdabot>   [1,2,3]
12:34:43 <hpc> > tail []
12:34:44 <lambdabot>   *Exception: Prelude.tail: empty list
12:34:47 <hpc> > init [1]
12:34:48 <lambdabot>   []
12:35:06 <edwardk> > (init *** tail) [1,2,3,4]
12:35:08 <lambdabot>   Couldn't match expected type `([a], [a1])'
12:35:08 <lambdabot>         against inferred type `[...
12:35:20 <edwardk> > (init &&& tail) [1,2,3,4]
12:35:21 <hpc> > init &&& tail $ [1..4]
12:35:22 <lambdabot>   ([1,2,3],[2,3,4])
12:35:23 <lambdabot>   ([1,2,3],[2,3,4])
12:35:36 <edwardk> > (init &&& last) [1,2,3,4]
12:35:37 <lambdabot>   ([1,2,3],4)
12:37:08 <kniu> @hoogle f (a -> b) -> a -> f b
12:37:10 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:37:10 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
12:37:10 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
12:37:40 <kniu> hurm
12:38:55 <edwardk> fromInt 1 :: Rounded TowardZero Double still crashes, without the + so its either in the get_d or init_si
12:39:54 <edwardk> hah
12:40:10 <edwardk> i forced it and it worked, but then later on sitting at the ghci prompt i crashed
12:40:12 <edwardk> GC?
12:40:33 <edwardk> literally 5 seconds after i forced it
12:42:06 <edwardk> so nothing other than init_si was ever called
12:42:29 <edwardk> @hpast
12:42:30 <lambdabot> Maybe you meant: part paste
12:42:32 <edwardk> @hpaste
12:42:33 <lambdabot> Haskell pastebin: http://hpaste.org/
12:42:50 <edwardk> http://hpaste.org/50486
12:49:08 <copumpkin> edwardk: yeah, something is wrong with the limbs
12:49:11 <copumpkin> I was doing the same thing
12:49:43 <edwardk> crud this was the thing we moved to c-- to work with in the first place =(
12:50:12 <copumpkin> oh!
12:51:09 <copumpkin> okay, it's a bit better now, but still crashes
12:51:50 <copumpkin> so one bug
12:52:08 <copumpkin> is that we need to subtract SIZEOF_StgArrWords from the limbs address we return
12:52:20 <copumpkin> mpfr wants the bytes, but haskell wants the beginning of the closure
12:52:34 <copumpkin> not sure how my earlier example worked
12:52:45 <copumpkin> but it still crashes, so need to figure out moar :P
12:56:01 <edwardk> ah we used to
12:56:21 <edwardk> dunno what i did with that fragment though, hrmm
12:57:30 <edwardk> the first time we did this we manually constructed the limbs
12:57:39 <copumpkin> yeah
12:57:55 <edwardk> so we could put the bytearray# header in front
12:58:28 <edwardk> i'm guessing that is what we're missing now
12:58:31 <copumpkin> well
12:58:37 <copumpkin> the allocator callbacks should be doing that for us
12:58:40 <edwardk> or something to that effect
12:59:03 <copumpkin> I wonder if this is secretly setting malloc &co. as allocators again
12:59:05 <edwardk> i'm dubious, because they only get used by mpfr in certain circumstances iirc
12:59:07 <copumpkin> I'll add a constructor
12:59:44 <edwardk> something like if we pass in one explicitly allocated it uses it, but it may sidestep the allocator hooks when you go and ask it to print something, and it has to allocate a temporary
12:59:57 <copumpkin> well, when we ask it to init2
13:00:02 <copumpkin> it has to go call the allocator to build some limbs
13:00:31 <edwardk> init2 uses the gmp allocator
13:00:35 <edwardk> http://perso.ens-lyon.fr/philippe.theveny/coverage/mpfr-trunk/init2.c.gcov.html
13:00:37 <edwardk> so we should be good
13:00:58 <copumpkin> ah, fair enough
13:01:16 <copumpkin> but might something in mpfr be resetting the gmp allocator behind our backs?
13:01:26 <edwardk> mebbe
13:01:36 <copumpkin> I sort of doubt it
13:10:05 <copumpkin> gah fucking hell
13:12:04 <edwardk> do we need to apply all this craziness? https://github.com/ekmett/natural-gmp/blob/master/cbits/gmp-wrappers.cmm#L269
13:13:43 <copumpkin> maybe eventually, but this is failing before we even take any mpfrs as input
13:14:11 <edwardk> point
13:15:42 <copumpkin> how does it even store tiny values?
13:16:04 <copumpkin> if I create an mpfr with integer 5
13:16:08 <copumpkin> it gives it an exponent of 3
13:16:16 <copumpkin> hmm
13:16:20 <copumpkin> and the limbs seem to contain 0
13:16:28 <edwardk> odd
13:16:41 <edwardk> exponent 3 i could believe
13:16:46 <copumpkin> yet it is able to find the value is 5
13:16:47 <hiptobecubic> man.... have you guys looked at ghc's mergesort since it was updated in late 2009? what a beast
13:16:49 <copumpkin> somehow :P
13:16:57 <hiptobecubic> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#sortBy
13:17:59 <ColonelJ> Hi I'm looking for a function like foldl except that it is possible to terminate the folding at some point through the list
13:18:12 <edwardk> guessing a leading 1, not not sure where the last 1 would come from
13:18:48 <ColonelJ> like for example it folds until it finds a number greater than 100
13:19:01 <ceii_> ColonelJ, use scanl, which produces a list of intermediate fold results
13:19:12 <ceii_> you can then cut off the list where you need to
13:19:35 <edwardk> ColonelJ usally i'd just foldr producing something productively
13:19:45 <ColonelJ> foldr isn't an option here
13:19:55 <ColonelJ> list being processed is infinite length
13:20:02 <edwardk> thats fine
13:20:10 <edwardk> you don't have to reach your base case
13:20:17 <edwardk> hence 'productive
13:20:34 <ColonelJ> maybe I didn't understand
13:20:53 <edwardk> foldl foo bar . takeWhile (<100)
13:21:12 <edwardk> is probably closer to what you are looking for though
13:21:51 <edwardk> in general i can foldr just find as long as every thing i produce from the fold always adds a layer of a constructor to the output
13:21:55 <ColonelJ> yea I think that was a bad example
13:22:02 <ColonelJ> I actually wanted to condition on the result of the folding
13:22:05 <edwardk> foldr (:) []  works just fine even infinitely
13:22:17 <ColonelJ> thus scanl could work
13:22:23 <ColonelJ> I don't understand how foldr operates here
13:22:33 <edwardk> foldl can be implemented as a foldr
13:22:43 <ColonelJ> vaguely remember that
13:22:52 <ceii_> > takeWhile (<100) $ scanl (+) 0 [1..]
13:22:53 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91]
13:23:09 <edwardk> ceii_ probably gave the simplest derivation
13:23:20 <edwardk> that whole thing can be made into a single foldr directly though if you're careful
13:25:04 <gwern> > (35/300) * 100
13:25:05 <lambdabot>   11.666666666666666
13:25:09 <gwern> > (300/25) * 100
13:25:10 <lambdabot>   1200.0
13:25:20 <gwern> > (25/300)
13:25:21 <lambdabot>   8.333333333333333e-2
13:25:31 <copumpkin> hmm, something fishy going on
13:26:10 <copumpkin> hmm!
13:26:22 <edwardk> copumpkin: ?
13:26:23 <copumpkin> mpfr must be writing its value somewhere bad
13:26:25 <copumpkin> because
13:26:45 <copumpkin> if I ask mpfr for the double value of the mpfr I just allocated
13:26:47 <copumpkin> in _si
13:26:51 <edwardk> i'm willing to hand construct all the limbs if we have to
13:26:53 <copumpkin> it remembers what I set it to
13:26:55 <copumpkin> however!
13:27:04 <copumpkin> I cannot observe the difference in any of the places I'd expect to look
13:27:07 <edwardk> it isn't there if you look at it
13:27:09 <edwardk> yeah
13:27:12 <copumpkin> it must be writing the limbs somewhere bad
13:27:19 <edwardk> i'd believe it
13:27:26 <copumpkin> we shouldn't have to allocate it ourselves
13:27:35 <copumpkin> I think the integer-gmp thing just rolls that in for small integers to optimize
13:27:38 <edwardk> shouldn't and don't are two different things ;)
13:27:43 <copumpkin> the allocation function is already doing all that
13:27:58 <copumpkin> it calls the allocator, sets the closure headers appropriately
13:28:02 <copumpkin> and then returns a pointer to the contents
13:28:12 <gwern> > 25/400
13:28:13 <lambdabot>   6.25e-2
13:28:18 <gwern> > (25/400) * 100
13:28:19 <lambdabot>   6.25
13:37:29 <kniu> @hoogle Id
13:37:30 <lambdabot> Prelude id :: a -> a
13:37:30 <lambdabot> Control.Category id :: Category cat => cat a a
13:37:30 <lambdabot> Data.Function id :: a -> a
13:46:30 <DrTeggy> Good evening.
13:47:18 <kosmikus> DrTeggy: hi
13:47:29 <DrTeggy> Hi there.
13:47:55 <Rc43> Hi, guyz.
13:49:29 <ColonelJ> > foldr (\x g s -> if (s > 100) then s else g (s + x)) id [1..] 0
13:49:31 <lambdabot>   105
13:49:46 <ColonelJ> have no idea why it works still but it does
13:50:05 <hpaste> Rc43 pasted “Parsec” at http://hpaste.org/50487
13:50:31 <edwardk> rc43: what can we help with?
13:50:53 <DrTeggy> ColonelJ: Reading RWH, eh? ;-)
13:51:04 <Rc43> When I call parseTest argument <anything> it gos to endless recursion.
13:51:05 <ColonelJ> nope
13:51:20 <Rc43> edwadk, there is test example at the bottom, it works
13:51:31 * hackagebot swish 0.5.0.2 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.5.0.2 (DouglasBurke)
13:51:35 <ColonelJ> was just following up on edwardk's proposition that you could use foldr for infinite lists
13:51:36 <edwardk> rc43: probably due to left recursion
13:52:16 <edwardk> ColonelJ: did you learn functional programming first in lisp, scheme or ml?
13:52:24 <ColonelJ> ml
13:52:33 <Rc43> edwardk ?
13:52:34 <edwardk> that is why your intuition is backwards here =)
13:52:50 <edwardk> rc43: sorry haven't had a chance to look yet
13:53:09 <edwardk> ah the recursion is between node and argument
13:53:17 <Rc43> edwardk, I didnt understand you words about left recursion
13:53:23 <Rc43> *your
13:53:36 <edwardk> node = do left <- argument; …     but argument = try (bracketed …) <|> argument'   and argument' = try node <|> ...
13:53:39 <monochrom> ColonelJ: it can be mechanically rewritten to f [] s = s; f (x:xs) s = if s>100 then s else f xs (s+x)
13:53:40 <edwardk> notice the cycle?
13:53:47 <edwardk> before making any progress it gets back to itself
13:53:51 <Rc43> Also, i dont know: is it right to use `try' there?
13:54:10 <edwardk> its okay, but you can't recurse into node from node without consuming something
13:54:23 <edwardk> or you'll spin forever
13:54:41 <Rc43> edwardk, oh, really; it is easy =/
13:54:57 <edwardk> http://en.wikipedia.org/wiki/LL_parser you want to look up how to left-factor a grammar
13:55:09 <Rc43> edwardk, i had have to look it more attentively
13:55:42 <edwardk> you can also lean on http://hackage.haskell.org/packages/archive/parsec/3.0.1/doc/html/Text-Parsec-Expr.html to deal with the operator precedence if you want
13:56:05 <ColonelJ> thanks monochrom
13:56:42 <ColonelJ> seems blatantly obvious now... :/
13:56:59 <monochrom> mechanical calculations make things obvious
13:57:42 <Rc43> edwardk, so i should program not like   'try to parse operation and arguments at left and right of it'    but like   'try to parse argument then operation then argument'   ?
13:57:59 <edwardk> yeah
13:58:19 <eiro> hello all
13:58:19 <edwardk> this is the main difference between LALR or LL and the larger Earley style parsers
13:58:34 <edwardk> in exchange the asymptotics are better
13:59:44 <eiro> i'm trying to write my first grep command as an exercice. i want this grep to be lazy
14:00:29 <eiro> main = readFile "/etc/passwd" >>= mapM_ print lines doesn't work, am i close to the solution ?
14:00:39 <eiro> (this is a cat for the moment)
14:01:05 <DevHC> eiro: yes
14:01:08 <edwardk> main = do xs <- readFile "/etc/passwd"; mapM_ print (lines xs)
14:01:23 <edwardk> you could have gotten there wth a . between print and lines
14:01:25 <edwardk> as well
14:02:17 <eiro> edwardk, i really would like to use a "unix pipe style", that's why i used >>=
14:03:04 <eiro> thanks for this solution anyway. perhaps it's more haskellish ?
14:03:04 <edwardk> *nods* though in this case it doesn't scale much past this example ;)
14:03:14 <edwardk> and like i said
14:03:30 <edwardk> you can readFile >>= mapM_ print . lines
14:03:38 <Cale> main = mapM_ print . lines =<< readFile "/etc/passwd"
14:03:42 <eiro> oh god yes! i was so close :)
14:03:49 <Cale> please flip it over if you're using (.) too
14:03:59 <edwardk> yeah
14:04:35 <eiro> now i'll try to add a filter :)
14:04:49 <DevHC> Cale: that's WRONG(TM) in the following way:
14:04:55 <copumpkin> hmm, I see something funky
14:05:08 <edwardk> copumpkin: what'd you track down?
14:05:12 <copumpkin> well
14:05:16 <Cale> DevHC: wat
14:05:18 <copumpkin> I hooked the custom allocator
14:05:29 <copumpkin> and it returns 0x100705638
14:05:37 <copumpkin> however, by the time we get the value back from mpfr
14:05:41 <copumpkin> it's ...40
14:05:45 <copumpkin> not 38
14:05:47 <edwardk> hrmm
14:05:48 <copumpkin> so someone is adding a word
14:05:50 <Cale> You could also write  mapM_ print . lines <=< readFile $ "/etc/passwd"
14:05:57 <Cale> if you import Control.Monad
14:06:16 <eiro> main = readFile "/etc/passwd" >>= mapM_ putStrLn . grep . lines  where grep = filter (isInfixOf "root")
14:06:21 <eiro> \o/
14:06:24 <edwardk> well, mpfr is probably telling it to is with the STG header words added in
14:06:27 <eiro> thanks guys!
14:06:29 <edwardk> so it points right at the limbs
14:06:34 <edwardk> er it to us
14:06:40 <Cale> eiro: Do you see why it's nicer to use =<< here?
14:06:41 <permagreen> Sometimes I think Haskell takes the TMTOWTDI principle even more to heart than Perl does
14:07:00 <eiro> Cale, no. i have to admit
14:07:03 <permagreen> (Haskell still looks prettier though)
14:07:11 <Cale> permagreen: Well, it's pretty impossible to prevent there from being more than one way.
14:07:18 <edwardk> eiro: because you have to switch to reading left to right for the >>= to right to left for the (.)'s
14:07:26 <Cale> eiro: because the data all flows in the same direction then
14:07:49 <DevHC> the LTR reading of "f (g x)" is analogous to the evaluation strategy: use the definition of f, and if f requires the value of arguments (ie., (g ...)), proceed to use them as well
14:07:52 <edwardk> using cale's approach with the =<< you can start reading at the right and then just keep viewing step after step as you go to the left
14:07:54 <DevHC> Cale^
14:08:05 <monochrom> amazing how people press "enter" prematurely. "that's wrong in the following way:\n" then he crashes
14:08:06 <eiro> oh! good point there :)
14:08:27 <Cale> DevHC: ?
14:08:31 <Cale> DevHC: sure
14:08:38 <edwardk> even better using the do notation you can break that up across multiple lines and it doesn't matter so much if the intervening steps need to perform IO
14:08:44 <DevHC> Cale: in a do expression, the LTR reading of readFile "blargious.txt" >>= doSomethingElse corresponds to the evaluation
14:08:55 <Cale> huh?
14:09:01 <eiro> is this code lazy ? i mean: only one line in memory ?
14:09:07 <Cale> The evaluation order starts with (>>=)
14:09:21 <DevHC> read the file. if that succeeds, do something else with the contents
14:09:26 <Cale> eiro: readFile is magical, so yes
14:09:27 <edwardk> eiro: 'kinda', it is lazy because readFile only slurps as it needs to
14:09:36 <DevHC> yes, evaluation actually starts with >>=, as in the (.) case
14:09:46 <edwardk> eiro: you can slurp terabytes through that and gc will throw away old unused lines
14:09:51 <Cale> DevHC: Execution and evaluation are two separate things though.
14:09:55 <eiro> edwardk, that was my question :)
14:10:03 <DevHC> but >>= is just a very basic notation just like (.)
14:10:28 <edwardk> devHC: >>= doesn't cause any evaluation, it just chains it when it finally happens
14:10:31 <eiro> awesome! now i have to handle parameters
14:10:32 <mm_freak> does anyone know a simple to use graphics library like gloss, but which doesn't insist on modelling the entire system purely?
14:10:41 <DevHC> edwardk: tell me something i don't know
14:10:51 <eiro> s/parameters/command line arguments/
14:10:54 <Cale> um...
14:10:57 * DevHC awaits epic facts from edwardk
14:11:02 <mm_freak> gloss with a monadic simulateInWindow would be exactly what i need
14:11:11 <edwardk> DevHC: okay. you can sandwich a comonad in a left kan extension, and the result is a comonad transformer
14:11:12 <Cale> I'm still waiting to be told why my code is incorrect.
14:11:28 <DevHC> edwardk: ORLY :>
14:11:50 <DevHC> Cale: was that directed at me?
14:12:11 <Cale> yeah
14:12:19 <monochrom> I think he just means he wants to read left-to-right
14:12:34 <Cale> Yeah, I don't get it. :)
14:12:52 <DevHC> i did not say the code is incorrect
14:12:57 <DevHC> i said that it's WRONG(TM)
14:13:04 <Cale> lol
14:13:36 <DevHC> note the (TM), ie., a proprietary definition suitable to conclude that i am correct, without requiring me to explain the reasoning behind the usage/definition
14:13:52 <edwardk> copumpkin: so if we allocate the limbs ourselves and copy the code out of init2 then what blows up? =)
14:14:06 <copumpkin> edwardk: well, it's going to call the allocator in a bunch of other places behind our backs
14:14:11 <copumpkin> so if this is fucked, I'm sure a lot more will be too
14:14:12 <DevHC> however, i'll state the reason, again:
14:14:13 <Cale> I think the data dependencies between parts of the code is far more important than evaluation or even execution order.
14:14:15 <edwardk> copumpkin: yeah
14:14:25 <copumpkin> there's an off-by-one-word here somewhere
14:14:29 <copumpkin> just gotta find it
14:14:44 <Cale> and so respecting that in the shape of the code on the page is way more important than ensuring that the code reads as it is evaluated
14:15:27 <DevHC> data dependency, evaluation strategy, etc.... they all point to the fact that =<< is WRONG(TM)
14:15:32 <Cale> Evaluation order isn't even defined by the standard and is an implementation detail.
14:15:39 <Cale> what?
14:15:53 <tomh-> hmm is there some function in ghci to time functions?
14:15:54 <edwardk> copumpkin: btw- what is the value of SIZEOF_StgArrWords?
14:16:03 <copumpkin> edwardk: for example, if I return     MPFR__mpfr_d(mpfr) - SIZEOF_StgArrWords - 8 for the ByteArray#, it no longer crashes the GC
14:16:04 <edwardk> not metaphorical, but the physical value
14:16:08 <dylukes> edwardk: btw,
14:16:12 <DevHC> i'm talking about the lazy-equivalent evaluation
14:16:14 <dylukes> whats an endofunctor, specifically?
14:16:24 <copumpkin> edwardk: 16
14:16:25 <DevHC> and an analogy between that and monads
14:16:27 <edwardk> it is a functor from a category to the same category
14:16:28 <Cale> The evaluation order of an IO action doesn't matter.
14:16:36 <parcs> why is the type of atomicModifyIORef the way it is?
14:16:41 <monochrom> he means execution order
14:16:43 <dylukes> edwardk: so its an identity morphism in Cat?
14:16:44 <edwardk> parcs: how so?
14:16:50 <edwardk> dylukes: not an identity morphism
14:16:53 <parcs> IORef a -> (a -> (a, b)) -> IO b
14:16:54 <Cale> The execution order matters, but here it's sensibly right to left.
14:16:57 <edwardk> just one from the object ot the same object
14:16:59 <dylukes> just to itself.
14:17:02 <dylukes> okay
14:17:06 <parcs> as opposed to modifyIORef :: IORef a -> (a -> a) -> IO ()
14:17:07 <edwardk> you can have lots of non-identity arrows from something to itself
14:17:25 <edwardk> considering a monoid as a category you have one object, but lots of arrows, where the arrows are each of the values your monoid takes on
14:17:31 <edwardk> and composition is the monoidal action
14:17:36 <DevHC> as i said, to evaluate "f (g (h ...))", u first look at the definition of f, then possibly at g, and finally at (h ...)
14:17:40 <edwardk> only the 'unit' of the monoid is an identity arrow
14:17:47 <dylukes> Interesting :).
14:17:51 <dylukes> And the object is?
14:17:51 <Cale> DevHC: I know that, I've been programming in Haskell for 10 years ;)
14:17:53 <edwardk> identity implies that composed with any other arrow it doesn't change the meaning
14:17:58 <dylukes> The unit function?
14:18:05 <dylukes> er, the function*
14:18:07 <dylukes> the binary associative one
14:18:15 <edwardk> the object is irrelevant, you can view categories 'object-less', but you can view it as the carrier set if it makes you feel better
14:18:23 <DevHC> to execute do { doSomething1 ; doSomething2 ; ... }, u first have to execute doSomething1, then possibly doSomething2, then ...
14:18:28 <dylukes> carrier set...?
14:18:37 <dylukes> I've often been confused by object-less categories when they were mentioned before.
14:18:40 <Cale> DevHC: sure, so?
14:18:43 <edwardk> the set over which you have a binary operation
14:18:49 <DevHC> i'd note the Maybe monad as an example
14:18:56 <edwardk> the object itself doesn't have any meaning except being a defined place to attach all your arrows
14:18:57 <copumpkin> aha!
14:19:05 <edwardk> copumpkin: that is a good sound
14:19:09 <copumpkin> #define MPFR_SET_MANT_PTR(x,p) \
14:19:09 <copumpkin>    (MPFR_MANT(x) = (mp_limb_t*) ((mpfr_size_limb_t*) p + 1))
14:19:12 <copumpkin> that's where the off-by-one comes from
14:19:14 <dylukes> I see :|
14:19:16 <DevHC> where a result of Nothing "terminates" the rest of the do expression
14:19:18 <copumpkin> now to figure out why the hell mpfr defines it that way
14:19:49 <applicative> dylukes sometimes the objects are just identified with their id morphisms
14:20:02 <dylukes> The object is the id morphism? GREAT. :|
14:20:07 <dylukes> that makes things even more confusing.
14:20:29 <monochrom> objects take the back seat in category theory
14:20:38 <dylukes> It's all about archery...
14:20:45 <edwardk> dylukes: objects exist as a theoretical sort of index on the category, you can connect any two arrows head to tail by composition when they go to and leave from the same object
14:20:51 <edwardk> dylukes: that is their only purpose
14:21:01 <applicative> dylukes, go with the flow, it's all morphisms
14:21:08 <dylukes> :P
14:21:12 <eiro> what are you using to parse argv ? i just seen UI.command
14:21:20 <dolio> The "only arrows" formulation of category theory isn't so great, though.
14:21:22 <edwardk> you could just as easily give up on the notion of objects all together and just say that you have a -> a -> Maybe a
14:21:30 <DevHC> and ... so the point is that i see that though =<< basically corresponds to (.), it's just WRONG(TM), because it doesn't correspond to the read-as-u-evaluate nature of (.)
14:21:33 <edwardk> where you compose two 'arrows' and maybe get an arrow
14:21:47 <applicative> dolio, I only know it from reading old Lawvere papers, it suited his hot-headedness, I think.
14:22:29 <Eliel> DevHC: so, basically, you're lazy and don't want to learn that =<< does things in the opposite order?
14:22:33 <dolio> applicative: Yeah, that's the only place I've seen it. It works well if you want to axiomatize category theory directly in single-sorted first-order logic.
14:22:48 <edwardk> subject to the condition that that composition is associative, this is a 'partial semigroup', but if you can describe 'when it will return Just rather than Nothing' that is describing the arrows that are compatible with each other
14:22:48 <dolio> Which is what he was doing.
14:23:47 <DevHC> Eliel: it has nothing to do with not learning, but rather following a way of thinking
14:24:07 <Eliel> DevHC: ok, let me rephrase, you don't want to learn to think in the way needed for =<<
14:24:19 <applicative> does it bolt in place the 'composition is a partial function' language?  it seems like it would.
14:24:21 <dolio> =<< doesn't correspond to (.)
14:24:32 <dolio> It corresponds to ($).
14:24:36 <edwardk> dylukes: for instance, when describing Haskell functions, the 'index' of objects for the category is just the set of Haskell types.  a function of the form Int -> Bool is an arrow in that category
14:25:07 <DevHC> Eliel: well if u want to put it that way :>
14:25:25 <edwardk> dylukes: on the other hand in the Kleisli category for some monad m, the index of objects for the category is the set of Haskell types, and Kleisli m a b = a -> m b
14:25:25 <edwardk> notice that the 'object' that that arrow goes to is 'b' even though the function arrow goes to m b
14:25:35 <applicative> objects give us something for the homsets to depend on, so we can say (.) :: HomSet a b -> HomSet b c -> HomSet a c, or whatever
14:25:36 <edwardk> that way you can know that Kleisli composition lets you compose
14:25:47 <edwardk> Kleisli m b c -> Kleisli m a b -> Kleisli m a c
14:25:50 <copumpkin> edwardk: oh, they secretly store the allocated behind our backs, I think
14:25:50 <edwardk> or
14:26:04 <edwardk> the count of how much was allocated?
14:26:40 * applicative gives up git for mercurial after only 20 minutes experience.
14:26:55 <edwardk> applicative: it is worth sticking to if only for github
14:27:01 <hiptobecubic> git is the best
14:27:02 <monochrom> so quickly? why?
14:27:09 <applicative> bitbucket crushes github
14:27:17 <copumpkin> edwardk: yeah, one of those. Trying to correct for that shit now
14:27:17 <hiptobecubic> applicative, at what?
14:27:26 <applicative> there is no comparison, i now believe all claims about git idiocy.
14:27:44 <monochrom> what is nice about mercurial?
14:28:08 <edwardk> i use github for my projects because i really like the ease of github's network model and fork/pull machinery
14:28:10 <applicative> i was busy pushing pulling committing patching revising after 10 minutes, including registering everything.
14:28:26 <applicative> edwardk, copied from bitbucket, no?
14:28:40 <applicative> but without the 'social' angle
14:29:05 <ColonelJ> github's network model and fork/pull machinery << eh?
14:29:08 * applicative admits his new love is basically groundless, like most of them.  he is not mentioning his 'real' revision control system
14:29:43 <applicative> hg told me everything i had to do. it's insane how simple it is.
14:29:45 <edwardk> ColonelJ: it is very easy for me to see all the forks folks have made of my projects, what patches they have in flight, and for them to signal me to pull those
14:29:46 * monochrom should horrify everyone by using RCS
14:30:14 <ColonelJ> and other sites don't have that?
14:30:31 <edwardk> not as such
14:30:38 <edwardk> within a repository you can see a lot
14:30:48 <applicative> edwardk, bitbucket is just as lucid.  you've been taken in!!
14:30:55 <edwardk> meh
14:31:06 <edwardk> i have 100+ repositories in github, i'm not changing course now
14:31:32 <ColonelJ> single point of failure
14:31:32 <edwardk> i switched to git because i had folks who wanted to collaborate in git
14:31:58 <edwardk> github has been far more robust than darcsden and patchtag were ;)
14:32:07 <edwardk> and i have backups on other machines
14:32:12 <applicative> edwardk, at most my feeble praise pertains to new user friendliness. I'm just kidding.
14:32:14 <dolio> None of these are compelling arguments for applicative to use git.
14:32:17 <luite> I switched to git because by the time I wanted to properly learn darcs al the cool kids were already using git
14:32:23 <edwardk> true
14:32:27 <ColonelJ> git is awesome, no one's arguing about that... or maybe they are...
14:32:34 <dolio> Unless applicative and edwardk are the same person.
14:32:40 * applicative continues not to mention his real revision control system and the sites that host for it :)
14:32:46 <edwardk> nah, there are limits to my schizophrenia
14:33:04 <applicative> edwardk, bos uses them both at once!
14:33:10 <ColonelJ> I thought that the nice thing about git is you don't even need a central repository
14:33:19 <edwardk> yeah but doesn't bos work on mercurial? or used to?
14:33:37 <kmc> ColonelJ, that's one of many nice things
14:33:38 <edwardk> ColonelJ: it is. the github site is just 'one repository of many'
14:34:04 * applicative contemplates mirroring edwarks repositiories on bitbucket, but maybe theres and asymmetry in the hg/git relation
14:34:16 <edwardk> ColonelJ: however, it is one that lets me accept patches when i'm away from my desktop from the web, lets me edit right there, etc.
14:34:17 <applicative> there's an asymmetry
14:35:14 <Rc43> edwardk, do you know how to do 'one-or-zero' in parsec?
14:35:18 <ColonelJ> well I suppose it depends what the software is
14:35:21 <edwardk> optional
14:35:51 <edwardk> there are a couple of other optionFoo combinators in Text.Parsec.Combinators as well
14:35:54 <ColonelJ> if you want to personally vet all changes to some code then I don't see a great lot of benefit from that feature, however I guess that isn't the case for most open source projects
14:36:07 <applicative> i'm only going to tell you about the contradiction i found in semigroupoids via mercurial!
14:36:10 <ColonelJ> which is why the code can get rather unruly
14:36:22 <edwardk> ColonelJ: nothing prevents you from declaring one of these as the 'master' and pushing to that
14:36:33 <edwardk> ColonelJ: it just doesn't force you into that workflow
14:36:46 <edwardk> *shrug*
14:36:46 <ColonelJ> of course, it's not a problem#
14:37:01 <copumpkin> edwardk: getting closer, I think
14:37:08 <edwardk> yay!
14:40:09 <applicative> edwardk, i think bos uses mercurial as the main thing, but then uses the hg-git plug in to go back and forth with the social clones on github
14:40:40 * applicative hasn't used the punk rock/west hollywood sense of 'clone' in ... uh ... some time
14:42:34 <Axman6> Rc43: you sould be able to use (Just <$> parser) <|> return Nothing
14:46:13 <edwardk> axman6: that is exactly what optional does ;)
14:46:23 <edwardk> or optionMaybe or whatever it is
14:46:52 <edwardk> rc43: http://hackage.haskell.org/packages/archive/parsec/3.1.1/doc/html/src/Text-Parsec-Combinator.html
14:48:50 <DevHC> Cale: want to invent doReverse expressions? :]
14:49:53 <monochrom> redo { return (); forkIO (putStrLn s); s <- getLine }
14:50:21 <DevHC> :D
14:50:22 <monochrom> some people may say "finally the <- points in the correct direction!"
14:50:37 <monochrom> but it is not perfect yet
14:50:45 <monochrom> { return (); forkIO (putStrLn s); s <- getLine } redo
14:50:55 <DevHC> lol
14:50:58 <monochrom> no, that is sitll not perfect
14:51:17 <monochrom> { () return; (s putStrLn) forkIO; s <- getLine } redo
14:51:34 <DevHC> move the ;s
14:51:45 <fryguybob> { () return; (s putStrLn) forkIO; getLine -> s } od
14:51:49 <monochrom> no, the ;s are fine, separators
14:52:08 <monochrom> { ;() return; (s putStrLn) forkIO; s <- getLine; } redo  is impeccable
14:52:33 <DevHC> { () return ;(s putStrLn) forkIO ;s <- getLine } redo
14:52:36 <edwardk> devhc: i have… for comonads
14:52:47 <monochrom> oh, I see
14:52:55 <monochrom> { ; () return ; (s putStrLn) forkIO ; s <- getLine ; } redo  is impeccable
14:53:25 <DevHC> edwardk: lol, i can haz?
14:53:37 <shachaf> > text . reverse $ "do { s <- getLine; forkIO (putStrLn s); return () }"
14:53:39 <lambdabot>   } )( nruter ;)s nLrtStup( OIkrof ;eniLteg -< s { od
14:54:13 <edwardk> devhc: its fairly easy, just replace >>= with flip extend in the existing do sugar, and it works fine comonadically
14:54:57 <edwardk> fib = 1 `fby` 1 `fby` undo n :< m :< _ <- fib; n + m
14:55:46 <DevHC> let {f'{'='}';f'}'='{';f'('=')';f')'='(';f'<'='>'} in text . reverse . map f $ "do { s <- getLine; forkIO (putStrLn s); return () }"
14:55:51 <DevHC> > let {f'{'='}';f'}'='{';f'('=')';f')'='(';f'<'='>'} in text . reverse . map f $ "do { s <- getLine; forkIO (putStrLn s); return () }"
14:55:52 <lambdabot>   <no location info>: parse error on input `''
14:55:53 <edwardk> notice the pattern side of the <- is the entire comonadic value and that the last result is 'a' not 'w a'
14:56:24 <DevHC> > let {f'{' = '}';f'}' = '{';f'(' = ')';f')' = '(';f'<' = '>'} in text . reverse . map f $ "do { s <- getLine; forkIO (putStrLn s); return () }"
14:56:25 <lambdabot>   <no location info>:
14:56:26 <lambdabot>      lexical error in string/character literal at chara...
14:57:00 <DevHC> > let { f '{' = '}' ; f '}' = '{' ; f '(' = ')' ; f ')' = '(' ; f '<' = '>' } in text . reverse . map f $ "do { s <- getLine; forkIO (putStrLn s); return () }"
14:57:01 <lambdabot>   {*Exception: <interactive>:3:6-72: Non-exhaustive patterns in function f
14:57:12 <DevHC> > let { f '{' = '}' ; f '}' = '{' ; f '(' = ')' ; f ')' = '(' ; f '<' = '>' ; f c = c } in text . reverse . map f $ "do { s <- getLine; forkIO (putStrLn s); return () }"
14:57:14 <lambdabot>   { () nruter ;(s nLrtStup) OIkrof ;eniLteg -> s } od
14:57:20 <DevHC> finally
14:57:46 <DevHC> edwardk: it's*
14:58:03 <Phyx-> I'm trying to learn indexed type families, but something confuses me somewhat... http://pastebin.com/YKqcEkVT the type constructors, are their scope limited to the members of the class (e.g. they can't be used in the head of the class). and what is the kind of Foreign, is it * -> * or just *,
14:58:06 <mauke> The paste YKqcEkVT has been copied to http://hpaste.org/50488
14:58:22 <monochrom> mauke++
14:58:28 <Phyx-> mauke--
14:58:32 <monochrom> mauke++
14:58:39 <Phyx-> i'm not gonna fight with an OP
14:58:41 <Phyx-> :P
14:58:45 <monochrom> fundep and type family together? you're 31337
14:59:36 <Phyx-> well.. ghc 7.0.3 doesn't support type family equalities yet right, so not much choice ;/
15:00:41 <monochrom> Foreign is a type function. I suppose that means kind *->* as you guess
15:00:47 <Phyx-> hrm.. those types aren't even used anymore.. so I guess they could be removed..
15:01:25 <monochrom> because eventually you will write "instance Convert Int Char where type Foreign Char = Bool" etc so Foreign maps Char to Bool
15:02:18 <Phyx-> hmmm did I properly convert the class.. feels like I did something wrong.. previous head was "(Foreign int ~ ext, Native ext ~ int) => Convert ext int"
15:02:48 <monochrom> not sure
15:03:55 <Phyx-> monochrom: instinctively, i would think I would still need to use Foreign and Native *somewhere*
15:05:03 <monochrom> if you want Foreign to serve a purpose
15:05:19 <Phyx-> so if I had Foreign int ~ ext, does that mean I can replace ext with Foreign int?
15:05:54 <monochrom> I don't know type equality
15:06:47 * Phyx- pokes McManiaC 
15:07:47 <Phyx-> well, i did so, and it still compiles
15:07:48 <Phyx-> so yay..
15:08:12 <monochrom> nice
15:16:02 <kmc> so i'm trying to add incremental input to hdis86
15:16:48 <kmc> so the user can feed in ByteStrings and get back lists of instructions
15:17:04 <kmc> and get the remaining ByteString at each point
15:17:19 <copumpkin> yay
15:17:58 <kmc> i'm wondering if i should implement an enumeratee or whatever
15:19:06 <kmc> my concern with using iteratees is a) i'd have to learn it, b) fewer people will use it, and c) seems we haven't standardized on an iteratee library or API yet
15:19:40 <benmachine> standardise on one! :P
15:21:21 <kmc> lazy
15:21:36 <kmc> frankly i don't find the problem that interesting
15:21:48 <benmachine> heh
15:21:51 <benmachine> fair
15:21:59 <kmc> i just want to provide some useful API for incremental disassembly
15:22:23 <kmc> what i'm thinking now is just ByteString -> ( [(Instruction, ByteString)], ByteString )
15:22:30 <kmc> maybe with some new types to make that less heinous
15:22:42 <kmc> just return the remainder with every instruction, and at the end
15:22:45 <kmc> lazily
15:22:49 <copumpkin> I'd just do ByteString -> (Instruction, ByteString)
15:22:52 <copumpkin> as the primitive
15:23:09 <copumpkin> then wrap it in a state action or something
15:23:15 <copumpkin> or unfold that to make the list
15:24:06 <kmc> it'd actually be ByteString -> (Maybe Instruction, ByteString)
15:24:22 <kmc> if you have not a full instruction
15:24:29 <copumpkin> fair enough
15:24:52 <kmc> can distinguish that from a full invalid instruction by a slight hack
15:26:11 <kmc> anyway i was worried about the overhead of re-initializing udis86 for every instruction
15:26:19 <kmc> but maybe it doesn't matter
15:26:39 <kmc> i guess strictly speaking i don't have to, either
15:26:45 <Yxven> I decided I'd start learning haskell today. Is this a decent tutorial? http://learnyouahaskell.com/
15:26:49 <kmc> yes
15:26:58 <Yxven> thanks
15:26:58 <kmc> we typically recommend that one and RWH
15:27:00 <kmc> @where RWH
15:27:01 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:27:09 <kmc> either in that order, or you can just read whichever you like more
15:34:28 <mm_freak> data X :: * -> * where Num a => a -> X a  -- is there a name for this kind of GADT?  it's neither an ADT nor an existential
15:35:09 <kmc> it has a constructor that captures a class constraint
15:35:31 <mm_freak> i understand it, i just can't name it
15:35:41 <kmc> that's how i would name it
15:35:49 <mm_freak> hmm
15:37:04 <parcs> is that a valid GADT definition?
15:37:22 <jmcarthur> not quite. it needs a constructor
15:38:00 <parcs> with the constructor it's an existential no?
15:38:03 <kmc> no
15:38:05 <jmcarthur> no
15:38:09 <jmcarthur> the type is exposed
15:38:16 <kmc> the type variable 'a' appears in the type of the result
15:38:26 <parcs> oh
15:38:28 <kmc> data X where MkX :: (Num a) => a -> X
15:38:30 <kmc> is existential
15:39:23 <mm_freak> indeed, i forgot the constructor name
15:40:20 <mm_freak> i use it to have some elegant static proofs
15:41:19 <kmc> data Ǝ F where W :: f x → Ǝ f
15:42:21 <kniu> @hoogle a -> b -> c -> c
15:42:22 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
15:42:22 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
15:42:22 <lambdabot> Network.BufferType buf_snoc :: BufferOp a -> a -> Word8 -> a
15:42:31 <kniu> @hoogle a -> b -> b
15:42:32 <lambdabot> Prelude seq :: a -> b -> b
15:42:32 <lambdabot> Control.Parallel par :: a -> b -> b
15:42:32 <lambdabot> Control.Parallel pseq :: a -> b -> b
15:43:40 <mm_freak> right now i'm collecting a limited number of samples by using an MVector as a ring buffer…  i forget the oldest element and save a new one by simply overwriting…  however, that gives me a nasty MonadIO constraint, which i would like to get rid of
15:43:54 <kmc> hmm, «ByteString → (Maybe Instruction, Bytestring)» or «ByteString → Maybe (Instruction, ByteString)»
15:44:24 <mm_freak> how bad would it perform to have a pure vector instead, on which i just use tail and snoc?
15:44:42 <mm_freak> probably much worse
15:44:55 <kmc> mm_freak, there are pure-functional queue structures
15:45:05 <kmc> it's one of the main things discussed in Okasaki's book
15:45:11 <kmc> and there's examples on Hackage
15:45:36 <mm_freak> kmc: suitable for very large datasets?
15:45:43 <kmc> how large?
15:45:56 <mm_freak> it's a library, so i can't predict it
15:46:14 <mm_freak> an unboxed vector is just perfect for the purpose
15:46:35 <mm_freak> but anyway, i need O(1) access to the head and the last elements
15:46:53 <mm_freak> Seq would do, but it's not nearly as compact
15:47:47 <ezyang> What percentage of Haskellers would you say would be able to take some function definition and write out how it reacts to bottoms, the way you can take 'seq' and write seq x _|_ = x?
15:48:10 <kmc> ezyang, depends entirely on how you define "Haskellers" :)
15:48:13 <ezyang> erm, seq x _|_ = _|_
15:48:15 <ezyang> :o)
15:48:42 <ezyang> Mmm, let's say, knows what weak head normal form means.
15:49:15 <kmc> i do think we need a really good writeup about whnf, sharing, and the abstract graph-reduction model of Haskell
15:49:21 <kmc> i haven't seen anything like that
15:49:32 <kmc> did you do one ezyang?
15:49:35 <ezyang> What's bad about the Wikibooks article? (Not advocating it, but curious)
15:49:36 <kmc> i must confess i'm behind on your blog
15:49:37 <ezyang> No.
15:49:40 <kmc> link?
15:49:50 <ezyang> But I keep trying and I keep thinking, "wait, this is trivial" and not writing it.
15:50:03 <ezyang> http://en.wikibooks.org/wiki/Haskell/Laziness
15:50:17 <ezyang> maybe also http://en.wikibooks.org/wiki/Haskell/Graph_reduction
15:51:02 <ezyang> (this may be partially because I'm currently in "big research thoughts" mode, e.g. everything I can think of has already been done before...)
15:54:07 <kmc> cool
15:54:19 <ezyang> Relatedly, is the form of demand analysis GHC uses explained anywhere?
15:54:27 <kmc> not afaik
15:54:35 <kmc> is that part of strictness analysis or something else?
15:54:49 <augustss> does it matter?
15:55:03 <ezyang> Yeah, it does the strictness analysis.
15:55:10 <kmc> i'm just trying to contextualize the unknown-to-me term "demand analysis"
15:55:15 <ezyang> augustss: I'm trying to write a research proposal about it, so it does matter!
15:55:29 <augustss> ah, yes, then it does
15:55:31 <ezyang> It's "backward abstract interpretation"
15:55:42 <augustss> back to the 80s!
15:56:05 <ezyang> It's true. Maybe that makes it a not very good thing to pitch your research tent on.
15:56:27 <sannysanoff> hello gentlemen, i converted my function to primitive types (Word#, Int#), but profiler still shows function allocates heap. I have no ideas left. How do I catch these places?
15:56:34 <ezyang> () is allocation.
15:56:38 <ezyang> use (# , #) instead.
15:56:59 <sannysanoff> no, I used braces like in literate text ;)
15:57:05 <kmc> can you hpaste your code?
15:57:07 <sannysanoff> (i.e. just here on irc)
15:57:16 <ezyang> yeah, post your code.
15:57:27 <kmc> ezyang, spice it up, use a SMT solver to do demand analysis :)
15:57:42 <ezyang> Aw man.
15:57:53 <ezyang> I hear SMT solvers are all the rage these days.
15:58:14 <kmc> kids these days, with their SMT solvers and their rock & roll music
15:58:19 <augustss> ezyang: have you looked at all the old stuff from the 80s?
15:58:24 <kmc> back in my day SAT was hard and that's how we liked it!
15:58:32 <ezyang> I am in the process of doing literature search.
15:58:38 * jmcarthur starts a rocks back called SMT and the Solvers
15:58:41 <jmcarthur> *rock band
15:58:51 <jmcarthur> sounds more like jazz or swing, really
15:58:56 <geheimdienst> *rock and roll
15:58:57 <ezyang> It's pretty humbling, really.
15:59:15 <ezyang> "Yeah, we figured that out in 80s..."
15:59:18 <jmcarthur> yeah, it always seems like everything has already been done and forgotten
15:59:31 <kmc> especially in programming languages
15:59:33 <jmcarthur> the "forgotten" part always frustrates me
15:59:39 <geheimdienst> "SMT and the Humbling Solvers"
16:00:26 <kmc> what's really funny is that people have been lamenting that everything's already been done for thousands of years
16:00:32 <augustss> The problem with strictness analysis is that a very simple one buys you a lot, and then beyond that it gets very, very difficult.
16:00:56 <kmc> i think most compiler optimizations are like that
16:01:05 <ezyang> Oh, I'm not actually interested in building a better strictness analyzer: I want to create a strictness type system.
16:01:15 <hpaste> sannysanoff pasted “still allocates” at http://hpaste.org/50489
16:01:21 <ezyang> But I can't decide whether or not to base it on demand analysis or projections.
16:01:29 <augustss> Ah, ok
16:01:44 <augustss> I think that's been attempted too. :)
16:02:02 <ezyang> Yeah, probably :^)
16:02:04 <jmcarthur> good lord that's a lot of unboxed code
16:02:04 <kmc> sannysanoff, honestly, i would have given up and written it in C by this point :)
16:02:16 <ezyang> sannysanoff: Are you sure the heap allocation is not coming from things like TSOs?
16:02:33 <hpaste> sannysanoff annotated “still allocates” with “still allocates (annotation)” at http://hpaste.org/50489#a50490
16:02:43 <kmc> TSO?
16:02:45 <ezyang> augustss: I actually haven't seen a paper to that effect, so if you know what the keyword is, I should keep looking.
16:02:49 <ezyang> Thread State Object
16:03:07 <sannysanoff> kmc, that is SPOJ
16:03:19 <ezyang> oh, he's looking at byte poking functions.
16:03:19 <sannysanoff> ezyang, please explain
16:03:35 <ezyang> sannysanoff: No, what's more likely is you need to be using unboxed versions of the byte poking functions.
16:03:38 <augustss> ezyang: I wish I could remember.  Clean has strictness annotations in the types, but I'm not sure how systematic it is.
16:03:48 <Volatile> are there unicode characters that are useless in Haskell? That is, are there characters that has not been assigned to any usage whatsoever?
16:03:49 <sannysanoff> ezyang, Am I not using it?
16:04:17 <ezyang> peekElemOff looks pretty boxed to me...
16:04:21 <ColonelJ> Volatile: I'd imagine Haskell uses hardly any of them
16:04:38 <sannysanoff> ezyang, it is commented
16:05:35 <ezyang> where does copyIntElemFrom come from?
16:05:58 <kmc> Volatile, control characters probably
16:06:05 <Volatile> ColonelJ: Well, if you turn on unicode support, you can use many of them, either as data constructors or variable names or operators. I'm just curious if there are any that cannot be used at all... :)
16:06:17 <hpaste> sannysanoff annotated “still allocates” with “still allocates (annotation) (annotation)” at http://hpaste.org/50489#a50491
16:06:23 <ColonelJ> probably stuff like zero-width spaces and stuff might be difficult to use
16:06:26 <kmc> Unicode support is in the Report
16:06:35 <Volatile> kmc: guess so. It also seems to have some problem with some hindic alphabets...
16:06:40 <sannysanoff> ezyang, added to annotation
16:06:47 <kmc> Volatile, the language does, or some implementation?
16:07:02 <ezyang> Here's a not very useful email from 2003 http://www.haskell.org/pipermail/haskell-cafe/2003-October/005359.html
16:07:06 <Volatile> kmc: heh. good call. :) Ghci does, at least. :)
16:07:10 <kmc> http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-140002
16:07:12 <sannysanoff> ezyang, in general, apart from looking at the code, do I have any tools? What should stg/core say?
16:07:41 <kmc> "any Unicode character defined as whitespace", "any Unicode lowercase letter", "any uppercase or titlecase Unicode letter", "any Unicode symbol or punctuation", "any Unicode decimal digit"
16:07:52 <ezyang> sannysanoff: It's pretty easy to look at core and see if things are being allocated.
16:07:58 <kmc> Unicode has character classes besides those thuogh
16:07:59 <ezyang> -ddump-simpl is perhaps a good first step.
16:08:01 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/Data-Char.html#g:3
16:08:08 <ezyang> Look for references to constructors.
16:08:21 <sannysanoff> ezyang, how they should look like?
16:08:37 <ezyang> There shouldn't be any references to constructors.
16:08:44 <ezyang> These include things like W#
16:08:48 <ezyang> You're compiling with -O, right?
16:08:52 <sannysanoff> ezyang, -O2
16:09:12 <ezyang> That's fine.
16:09:30 <kmc> i wonder what's in "Letter, Other"
16:09:38 <sannysanoff> ezyang, how do I launch ghc? -ddump-what?
16:10:08 <Volatile> ooh, so characters not being upper or lower case has no haskell use, then?
16:10:16 <kmc> or title case
16:10:24 <ezyang> Just add -ddump-simpl as a flag
16:10:29 <kmc> i think that's right
16:10:31 <ezyang> -fforce-recomp too, if you didn't remove teh compiler output.
16:11:01 * Volatile tries japanese chars
16:11:45 <Volatile> yep. seems to be out of the question.
16:12:04 <Volatile> hm
16:12:10 <Volatile> s/bad english/good english/
16:13:08 <Volatile> Nice, so now I know that there are a LOT of alphabets which can convey no haskellish meaning as of now.
16:13:38 <ColonelJ> GHC is open source, why don't you fix it?
16:13:43 <Volatile> :)
16:14:28 <Volatile> Include a new kind of thing which is neither data nor vars? I'll put that on the TODO heap for now... ;)
16:16:14 <mm_freak> ok, i made a nice, pure version using unsafeThaw and unsafeFreeze
16:16:25 <mm_freak> the data dependencies should make this safe
16:16:28 <ezyang> Literature search is nice and easy when you've hit a vein of papers, but kind of difficult otherwise.
16:16:28 <kmc> ColonelJ, that wouldn't fix it
16:16:40 <kmc> ColonelJ, you can't change the Haskell language by changing what GHC accepts
16:17:31 <ColonelJ> what wouldn't fix what kmc?
16:17:44 <kmc> changing GHC to allow non-cased alphabets
16:17:50 <Volatile> ColonelJ: changing how GHC behaves won't change how Haskell is defined. :)
16:18:00 <kmc> brb
16:18:08 <Volatile> I think he meant.
16:18:23 <Volatile> Hm, gotta sleep some. bbl.
16:18:34 <ColonelJ> I'm not aware of how haskell is defined.  But I guess unicode in source code isn't a standard feature
16:18:56 <ColonelJ> and indeed haskell cares about case so it would pose some difficulties
16:19:38 <sannysanoff> ezyang, does <<GHC.Prim.State# GHC.Prim.RealWorld>> count?
16:19:38 <Volatile> ColonelJ: exactly. :) What to do with non-casey languages...
16:19:46 <ColonelJ> http://www.reddit.com/r/programming/comments/jmqtx/should_utf16_be_considered_harmful/ heh
16:20:05 <Volatile> Anyways, off to bed, see ya latorz
16:20:05 <ezyang> No.
16:20:13 <ezyang> That gets compiled into nothingness.
16:20:18 <ezyang> Post your core.
16:24:11 <sannysanoff> ezyang, http://hpaste.org/50489#a50493
16:24:13 <applicative> > take 10 . drop 1000 $ zip `ap` (map generalCategory) $ [minBound .. maxBound]
16:24:15 <lambdabot>   [('\1000',UppercaseLetter),('\1001',LowercaseLetter),('\1002',UppercaseLett...
16:24:26 <leod> beautiful
16:25:26 <applicative> i guess you have to figure out some way of formatting and write to file if you want to see the unicode letters?
16:25:57 <edwardk> ezyang: when i'm not distracted we should talk about strictness vs. relevance and how they interact with type systems
16:26:32 <ezyang> edwardk: Yes we should! What is 'relevance'?
16:27:10 <edwardk> ezyang: relevance and affinity are the two halves of linearity in linear types
16:27:29 <ezyang> "Things I need to learn"
16:27:43 <ezyang> Dammit, why is there so much knowledge in this world :-)
16:27:43 <edwardk> relevance is that you use it one or more times, affinity is that you use it at most once
16:27:56 <edwardk> relevance removes weakening, affinity removes contraction
16:28:04 <edwardk> together you get linearity
16:28:30 <edwardk> if you have a copy of advanced topics in types and programming languages the first chapter, by david walker talks about how these fit together
16:29:02 <edwardk> anyways, once you get the framework of substructural logic, you can base a form of strictness analysis on it.
16:29:24 <ezyang> Ooooh.
16:30:08 <edwardk> in particular relevance is too strong a side-condition, saying that in all uses are not weakened, but what you really care is that there is one unweakened use
16:30:20 <ezyang> Is this the '09 POPl paper?
16:30:28 <edwardk> which one is that?
16:30:31 <edwardk> the ideas predate 09
16:30:36 <ezyang> "A substructural type system for backward strictness analysis"
16:30:51 <edwardk> i never read it
16:31:07 <edwardk> but the ideas go back to 06 or so when i stumbled upon them
16:31:30 <ezyang> that's... amazingly recent.
16:31:39 <sannysanoff> ezyang, sorry to interrupt...
16:32:01 <edwardk> anyways, try there. i'll catch up with you later
16:32:08 * edwardk &
16:32:20 <ezyang> OK.
16:33:00 <ezyang> sannysanoff: Can you give us a heap profile of your program?
16:33:10 <ezyang> I'm curious to know what's in the heap. I don't see any obvious allocation in the core.
16:34:26 <sannysanoff> ezyang, will give... but say, does cpu/alloc report lie?
16:34:32 <sannysanoff> s/say/tell
16:34:48 <ezyang> It's pretty accurate.
16:38:17 <sannysanoff> ezyang, sent you profile, but in it, most of allocations are related to read/parse.
16:39:58 <zzo38> I think Template Haskell ought to have some way to include declarations usable by Template Haskell without the other module, such as something like ${ ... } contains declarations which are only visible to Template Haskell for the current module.
16:40:23 <zzo38> Can they put in any such thing in later version?
16:43:07 <ezyang> Hmm. It's possible the profiler is misattributing costs stemming from lazy evaluation.
16:43:17 <ezyang> Can you strictify your input before running it through teh code?
16:43:25 <ColonelJ> umm I've gone back to designing a programming language I was working on last year.  It's a concatenative language originally intended to work directly with functional code and with very high performance.  However a couple of changes I have made in the interests of expressivity and generality have resulted in a cataclysm of type confusion.  Any assistance would be appreciated...  Should best be discussed in its own channel - you can com
16:44:58 <sannysanoff> ezyang, I did (print $ length $ show arr)
16:45:00 <Cale> ColonelJ: "you can co"
16:45:08 <Cale> ColonelJ: (your message was cut off)
16:45:24 <ezyang> Already?
16:45:27 <ColonelJ> Assuming that last message was truncated it meant to say anyone is welcome to come to #starpial to discuss anything about the language...
16:45:45 <sannysanoff> ezyang, ./SHPATH +RTS -s -p
16:45:46 <sannysanoff> ("len farr=",2511228)
16:45:46 <sannysanoff> ("farr=","array (0,9999) [(0,[(6,8801),(27,8591),(47,7873),(32,7820),(9,7726),(51,7288),(45,7148),(7,6794),(83,6770),(54,6311),(43,6009),(31,5904),(90,5130),(38,5016),(75,4651),(63,4208
16:47:00 <zzo38> Do you know about my question?
16:47:24 <sannysanoff> ezyang, apart from that array, all remaining data is mallocArray-d :: Ptr Word32
16:49:36 <ezyang> OK, next step, time to do some C-- snooping.
16:49:41 <ezyang> Can you -ddump-cmm and paste it?
16:52:03 <kmc> ColonelJ, Haskell is defined by http://haskell.org/haskellwiki/Language_and_library_specification
16:52:48 <sannysanoff> ezyang, you're going to great depth ;) I'd better read assembly output, but too many rubbish is here, I'm lost. wait a sec.
16:52:49 <kmc> ColonelJ, Unicode in source code *is* a standard feature
16:53:15 <kmc> the "Lexical Structure" section of the Report is where I pulled those character classes from
16:53:23 <ColonelJ> well ok
16:53:53 <kmc> it was ASCII-only in some earlier versions of the spec
16:54:15 <kmc> GHC has an extension to use Unicode symbols for certain ASCII reserved words / operators
16:54:26 <kmc> ∀ for "forall", ∷ for "::", → for "->", etc.
16:54:42 <ColonelJ> interestingly the web pages for this specification don't specify an encoding for their content in either the HTML protocol headers or the source resulting in it not displaying correctly
16:55:07 <kmc> heh, interesting
16:55:14 <theorbtwo> {-# DifficultToType -}
16:55:31 <kmc> i wonder if the HTML or the PDF spec is normative
16:55:31 <ColonelJ> I think I'll go with the PDF edition...
16:55:45 <kmc> bilingual countries have this problem
16:55:46 <applicative> {-#LANGUAGE UnTypeable#-}
16:55:47 <ColonelJ> I guess it would be the pdf
16:55:49 <ezyang> sannysanoff: I've worked a bit with C-- representation, so I'm pretty comfortable with it.
16:55:53 <kmc> in Canada, is the English or the French version of a law normative?
16:56:19 <sannysanoff> ezyang, I can read it too, but indirect jumps all the way..
16:56:20 <theorbtwo> kmc: The version that the Queen^WLt. Gov. signed.
16:56:28 <kmc> aha
16:56:30 <applicative> surely as in pre Cold War California, the lawyers interpret each in terms of the other.
16:57:06 <applicative> surely difficult questions of interpretation can be decided by adverting to the other version
16:58:09 <kmc> wasn't there something where a Canadian MP was writing a book, and wanted a free translation to French, so he read it out loud as a "statement" in Parliament?
16:58:18 <parcs> ghci doesn't seem to kill forked threads after an interrupt of the parent function. any way to change this behavior?
16:59:15 <theorbtwo> kmc: Sorry, I should be careful about making statements that appear as other then guesses.
16:59:20 * applicative thinks he would have proved himself a greater benefactor of mankind if he had read out Grothendieck in French
17:00:02 <theorbtwo> Wikipedia claims that The Canadian Charter of Rights and Freedoms says that "all statutes...with the English and French versions both holding equal status before the courts"
17:00:13 <kmc> applicative, or the spec for the OCaml Virtual Machine
17:00:29 <kmc> i was so lucky to have a French-speaking lab partner in that class...
17:00:45 <applicative> there's an idea
17:00:57 <theorbtwo> kmc: He probably didn't have to actually read it aloud, just say anything and then have it edited into the offical record as if he read it aloud.
17:01:02 <kmc> heh
17:01:04 <kmc> hax
17:01:16 <theorbtwo> Happens all the time in Parliment.  Congress too, IIRC.
17:01:24 <theorbtwo> UK Parliment and US Congress, that is.
17:01:57 <ezyang> sannysanoff: Correction: please give me the C-- MINUS all of the framework cruft.
17:02:05 <ezyang> I'm going to go snooping for Hp > HpLim checks.
17:02:10 <ezyang> but there's too much noise.
17:02:57 <kmc> ezyang, you can do that from disassembly!
17:03:03 <zzo38> I am trying to write some Haskell program for using some other libraries that are C, I did some of it already.
17:03:11 <zzo38> I need to write it in both Haskell and in C.
17:04:02 * applicative thinks hpaste should recognize an {-#OPTIONS_HLINT -fno-warn-anything #-}
17:04:23 <sannysanoff> ezyang, you see, my function is split to several parts by GHC which I cannot collect for you....    I would need to trace all symbol references (jumps) from Main_roll_entry, but I gave up after 4 generated names.
17:05:05 <ezyang> No no, what I mean is, compile just the library code (what you pastebinned). It doesn't have to be runnable. Stick it in a module.
17:05:34 <zzo38> Is there a way to specify types of things in other modules which are not yet accessible, and use them, like you can in C?
17:05:49 <ezyang> zzo38: foo = undefined?
17:06:04 <ezyang> But you need to implement it at some point.
17:07:28 <zzo38> ezyang: No, I mean if the actual implementation is in another module which you do not yet have access to.
17:11:24 <zzo38> And when I finished writing this program can I send it using Cabal? If I type in "cabal" it there is no such program how do I do it?
17:11:50 <ColonelJ> My language has functions of any arity, including zero, nested inside each other, and can return any number of objects/functions as a result, including zero.  And calling a constant results in the same constant, while a zero argument function returning a constant and doing nothing else is equivalent also to that constant...
17:12:12 <zachk> zzo38: http://hackage.haskell.org/platform// get that it has cabal
17:12:28 <ColonelJ> also the number of items returned from a function depends on the arguments you give it
17:12:37 <ezyang> sannysanoff: What's this SHPATHzupart_MyBinaryHeap2_con_info
17:12:37 <zzo38> I did install that but still there is no "cabal" program
17:12:44 <zachk> what os
17:12:55 <ezyang> I still see a 'main' function...
17:13:09 <zzo38> Windows
17:13:17 <sannysanoff> ezyang, 1sec
17:13:18 <zzo38> There is a directory for Cabal but no executable program to do it
17:13:29 <zachk> pull up command prompt: cabal install name-of-package-here
17:13:34 <ezyang> Also, I see literally two heap allocations in the C--, so if this code profiles with alloc, the profiler is lying, I reckon.
17:14:04 <zzo38> zachk: There is no such program installed.
17:14:08 <ezyang> Unless it's counting stack. Which is plausible.
17:14:09 <zzo38> So, it doesn't work.
17:14:26 <ColonelJ> cabal install cabal
17:14:35 <zzo38> There is no cabal.
17:15:28 <sannysanoff> ezyang, http://hpaste.org/50489#a50494
17:15:39 <zzo38> There are the programs:  ghc ghci-7.0.3 ghci ghc-pkg haddock hp2ps hpc hsc2hs runghc runhaskell   but there is no cabal.
17:15:48 <sannysanoff> ezyang, one of the functions is part of the class
17:16:15 <ColonelJ> cabal-install
17:16:17 <sannysanoff> hmm, I64[Hp] is heap pointer!
17:16:46 <zzo38> There is a directory lib/Cabal-1.10.1.0 but no executable program.
17:17:53 <ezyang> you need cabal-install for the executable.
17:18:01 <ezyang> but that's a little tough to install if you don't have cabal-install...
17:18:06 <zzo38> I have no cabal-install
17:18:11 <applicative> how did you get ghc?
17:18:18 <sannysanoff> ezyang, no, it's not class, but it there's a constructor.... let me see...
17:18:55 <zzo38> I downloaded the Haskell Platform file which contains a bunch of things, some of which are no use to me, but there is also some things missing
17:19:15 <dibblego> is it possible to get ghc -e to not return a 0 exit code?
17:20:18 <ezyang> "patch GHC"
17:20:19 <applicative> zzo38  that is a puzzle, it includes the cabal-install executable.  you should be able to install it from source, but will it break everything to reinstall the platform?
17:20:31 <kmc> (ghc -e 'print 3'; exit 1)
17:21:13 <kmc> ghc -e 'import System.Exit' -e 'exitWith (ExitFailure 3)'
17:21:26 <zzo38> It does not have source files of the cabal either
17:22:22 <dibblego> yeah I am calling a function returning IO ExitCode thinking it will fail with that exit code
17:22:42 <sannysanoff> ezyang, I don't see this code is used... this seems to be constructor for ADT declared in the class.
17:22:43 <kmc> only if you use exitWith
17:22:48 <dibblego> right
17:23:01 <ezyang> OK, then you have no heap allocation, let's go home and party.
17:23:23 <ColonelJ> zzo38: ghc --make Setup.hs
17:23:43 <Phyx-> isn't --make redundent nowadays?
17:24:06 <jmcarthur> yes
17:24:12 <geheimdienst> since ghc 7 i believe. there's probably people out there with ghc 6, however
17:24:18 <kmc> lots
17:24:23 <Phyx-> :O
17:24:40 <sannysanoff> ezyang, thanks for cmm ref, and therefore, .prof file lies ;(
17:24:45 <Phyx-> lol, that's like people who stick with XP :P
17:24:47 * Phyx- hides
17:25:14 <ColonelJ> uhh how do you show version from ghci
17:25:17 <Phyx-> redundant*
17:25:32 <ezyang> I think it's counting stack allocation. I'm checking the GHC sources...
17:25:35 <kmc> s/XP/windows/
17:25:42 <kmc> ColonelJ, version of what?
17:25:47 <Phyx-> ghci --version
17:25:48 <applicative> zzo38 you can get the tarball for cabal-install on hackage
17:25:51 <applicative> @hackage cabal-install
17:25:51 <lambdabot> http://hackage.haskell.org/package/cabal-install
17:25:52 <ColonelJ> version of ghci from inside ghci
17:25:57 <ColonelJ> not by restarting it
17:26:04 <kmc> :! ghci --version
17:26:08 <applicative> :! which ghci
17:26:09 <Phyx-> lol
17:26:12 <ColonelJ> ...
17:26:18 <applicative> version, ratehr
17:26:18 <ColonelJ> yea whatever lol
17:26:30 <Phyx-> hahahaha
17:27:11 <ColonelJ> well it appears I'm on windows XP and using GHC version 6.10.4
17:27:24 <ColonelJ> how about that
17:27:43 <zzo38> applicative: OK thanks
17:27:53 <ezyang> Nope, I'm wrong, it's only checking heap allocation.
17:28:07 <ezyang> Though, this comment "ToDo: This is almost certainly wrong" doesn't inspire confidence.
17:28:16 <Phyx-> ColonelJ: to be fait, i have every version of GHC since 6.10.4 still installed
17:28:23 <kmc> :! /proc/$(pgrep -f 'ghc.*--interactive' | head -n 1)/exe --version
17:28:52 <ColonelJ> [02:01] <ColonelJ> well it appears I'm on windows XP
17:31:45 <applicative> zz38 if you do runhaskell.exe Setup.hs configure --help it will give you some options for configure, like where to put it. then you do runhaskell Setup.hs build , then runhaskell Setup.hs register, but first do the commands with --help which gives fairly straightforward advice
17:32:42 <ColonelJ> yea my cabal.exe ended up in a pretty wacky location
17:33:29 <kmc> yeah windows XP probably doesn't have procfs
17:33:33 <applicative> zzo30, wait maybe do runhaskell Setup.hs --help first, i forgot that it can install, haven't used it since the Haskell platform gave me a reliable .... cabal instaall
17:35:09 <ColonelJ> c:\Program Files\Haskell Platform\extralibs\bin\cabal << not as bad as I thought
17:35:29 <ColonelJ> cabal still makes its own folder in application data though
17:36:24 * applicative likes this idea of \libs\bin... maybe he'll invent \lib\bin\usr\bin\share
17:37:49 <ColonelJ> The Foreign Function Interface (FFI) has two purposes: it enables (1) to describe in Haskell the interface to foreign language functionality << that include French?
17:38:45 <applicative> zzo30 the main trouble might be that you don't have all the dependencies, you can check what you have with `ghc-pkg list`
17:39:32 <applicative> that it calculates and hunts down the dependencies is the principal advantage of cabal install over runhaskell Setup.hs install
17:41:14 <kmc> ColonelJ, oui
17:51:21 <applicative> ColonelJ French Haskell is comparatively rare, but awesome.
17:55:35 <applicative> http://www.google.com/codesearch#K6vyve6ptkg/src/Main.hs&type=cs module Main where import Typage; import Parsage
17:57:39 <ColonelJ> :]
17:59:36 <sm_> have folks here seen Category theory, Monads, and Duality in the world of (BIG) Data at http://ecoop11.comp.lancs.ac.uk/?q=content/keynote-speakers ?
17:59:39 <ColonelJ> the actual code seems to be all english but the filenames and comments aren't... meh
17:59:59 <ColonelJ> and strings
18:01:41 <applicative> i'm finding better Spanish, admittedly
18:03:20 <ColonelJ> infer_args arbre = case arbre of Un (op, Just t_op) (Var x (Just [])) t ->
18:03:51 <applicative> http://code.google.com/p/tps-plp/source/browse/trunk/tp1/src/jay.hs
18:04:00 <applicative> asig nombre valor estado =      if (var nombre estado == 0) then  .... it's beautiful
18:04:18 <applicative> another argument against the menace of 'if..then .. else'
18:05:04 <ColonelJ> it has to like alternate between spanish and english in weird and wonderful ways
18:05:42 <applicative> the writer doesn't realize that at least if ... then ... else ... spares them the need for parentheses
18:05:59 <dilinger> they shoud provide wrappers.   'si = if'
18:06:08 <applicative> it can be view as exotic foreign bracketing
18:06:16 <applicative> viewed
18:06:19 <ColonelJ> there's nothing wrong with extra parentheses if they actually make things more clear
18:06:55 <ColonelJ> in a concatenative language like mine parentheses might not be needed at all for a long stretch of code but it's damn near impossible to figure out its structure
18:07:28 <ColonelJ> then on the other end of the scale there's LISP and that ilk
18:07:59 <ColonelJ> where parentheses are mandated at every possible place you could put them
18:09:18 <applicative> in an S expression the parenthesis can be viewed as one item with the first term so (+ .....) is all one expression, this was Quine's original idea
18:12:11 <permagreen> Homoiconicity is pretty awesome, I have to say
18:12:23 <ColonelJ> speaking of quines this is a quine in my language that I wrote yesterday"(q x'q x')print 34 chr!q"(q x'q x')print 34 chr!q
18:14:02 * applicative was speaking of Quine, not a quine, of course
18:14:32 <ColonelJ> yes but... anywya
18:15:05 <ColonelJ> the primitive type of my language is the stack
18:16:11 <applicative> what, not the lambda?
18:16:27 <ColonelJ> well, actually lambda stacks
18:16:45 <ColonelJ> but even that's not an accurate description
18:17:38 <ColonelJ> plus that term barely makes sense in the first place
18:17:44 <ColonelJ> I'll stick with just stack
18:17:54 <ColonelJ> that makes it homoiconic
18:18:56 <ColonelJ> ... kind of
18:21:00 <ColonelJ> well I don't know if this is sufficient but you can do stuff like :(... code ...) compile
18:26:36 <geheimdienst> so, is there some rule about  System.Posix.Lolcats vs. System.Lolcats.Posix? cause i'd clearly prefer the latter
18:36:45 <chenwl_> does anyone deployed haskell project on heroku
18:40:42 <kmc> @google haskell heroku
18:40:44 <lambdabot> http://www.yesodweb.com/blog/2011/07/haskell-on-heroku
18:40:44 <lambdabot> Title: Yesod :: Haskell on Heroku
18:44:22 <applicative> geheimdienst: how do you feel about System.Lolcats.Win32
18:45:03 <applicative> > let isLeft c = case generalCategory c of OpenPunctuation -> [c]; _ -> [] in let onTheLeft = concatMap isLeft [minBound..maxBound] in (length &&& text) onTheLeft
18:45:04 <lambdabot>   (72,([{
18:45:25 <chenwl> lambdabot: I followed that article, but failed
18:45:26 <applicative> ^^^ that's not 72 characters!?!
18:46:06 <geheimdienst> applicative: yeah, that's the consequence. i mean, rather make System.Foo.{Posix,Win} than put Foo and all kinds of other things in generic namespaces System.Posix and System.Win32
18:46:14 <kmc> chenwl, you should describe how you failed, and ask your question
18:46:44 <chenwl> kmc, I failed to push the demo code to heroku
18:46:58 <applicative> so much for my new {-#LANGUAGE SwankyUnicodeBrackets#-} or {-#LANGUAGE StylinScottBrackets#-} extension
18:47:06 <chenwl> Heroku push rejected, no Rails or Rack app detected
18:47:44 <chenwl> kmc: https://github.com/mwotton/heroku_haskell_demo/issues/2
18:48:58 <byorgey> applicative: hmm, it also doesn't have a closing ) which is odd
18:49:15 <byorgey> applicative: I wonder if it includes some funky character that is making the printing screw up
18:49:34 <applicative> byorgey, its like there was a silent error after a dangerous left bracket
18:49:40 <applicative> right, like you said
18:49:40 <byorgey> yeah
18:50:41 <byorgey> applicative: when I run it in ghci I get (72,"([{\3898\3900\5787\8218\8222\8261\8317\8333\9001\10088\10090\10092\10094\10096\10098\10100\10181\10214\10216\10218\10220\10222\10627\10629\10631\10633\10635\10637\10639\10641\10643\10645\10647\10712\10714\10748\11810\11812\11814\11816\12296\12298\12300\12302\12304\12308\12310\12312\12314\12317\64830\65047\65077\65079\65081\65083\65085\65087\65089\65091\65095\65113\65115\65117\65288\65339\65371\65375\6
18:51:29 <applicative> yes I see the characters if I use Text.PrettyPrint.text but lambabot is suspicious
18:52:12 <ghartshaw> @pl
18:52:12 <lambdabot> (line 1, column 1):
18:52:12 <lambdabot> unexpected end of input
18:52:12 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
18:52:39 <applicative> it occurred to me a use of fancy brackets to express one place functions (like fromIntegral or indeed join) might enhance legibility if tastefully employed
18:52:41 <byorgey> @pl \x y -> map y x
18:52:41 <lambdabot> flip map
18:53:05 <ghartshaw> @pl \f g h x -> f (g x) (h x)
18:53:06 <lambdabot> liftM2
18:53:22 <byorgey> applicative: indeed, although I think that sort of thing is more likely to be domain-specific
18:53:36 <byorgey> or maybe that's what you meant
18:53:51 <chenwl> why GHCi isn't like the interactive python, what we put interactively is what we write in source file
18:53:59 <applicative> i was thinking of it on the model of PostfixOperators.  My deep conceptual advance this evening was to realize that left and right brackets are already constructors in Data.Char
18:54:38 <applicative> chenwl, this is a very great question, in my view, ghci is too much like python>
18:55:28 <ghartshaw> @pl \f g h x y -> f (g x y) (h y)
18:55:29 <lambdabot> ((flip . (ap .)) .) . (.) . (.)
18:55:31 <applicative> in fact when you write "let moo = "moo"" in ghci you are in the middle of an IO do block
18:56:10 <applicative> chenwl it is rather remote from what you are doing when you write "moo:: String    moo = "moo"" in a Haskell module
18:56:11 <chenwl> applicative: why? I don't think ghci is like python> . we type different code in ghci and *.hs
18:56:20 <romildo> Hi.
18:56:31 <applicative> chenwl, it is the same inside a do block and inside ghci
18:56:54 <chenwl> applicative: oh... do-block
18:57:03 <applicative> chenwl this came as a revelation to me when it was explained to me here.  many curiousities are explained when you see this.
18:57:32 <romildo> I am having some difficulty in understanding the book title "Learn You a Haskell for Great Good!". What does it mean? (My mother tongue is Portuguese.)
18:57:55 <mustelo> romildo, heh, don't think about it too much. focus on the content :)
18:58:08 <applicative> it was only then that I realized you could type file <- readFile "moo.txt"  inside ghci, which is nonsense in the left margin of a haskell module
18:58:23 <applicative> (actually jhc permits it)
18:58:27 <ion> chenwl: If you type the following lines into ghci, what do you suppose should happen?
18:58:31 <ion> putStrLn str
18:58:33 <ion> str = "o hai"
18:58:37 <romildo> mustelo, yes. But being a teacher, my students will ask me, and I would like to have an answer.
18:59:02 <mustelo> I suppose it means that learning haskell will have good consequences
18:59:03 <jmcarthur> romildo: the title intentionally has bad grammar
18:59:04 <applicative> romildo: the author is not a native speaker of English!
18:59:24 <ion> chenwl: In fact, if you’re really restricting ghci to what we write in a source file, you can’t just write “putStrLn something”.
18:59:49 <chenwl> ion: not in scope: `str'
18:59:58 <ion> Then it isn’t like a source file.
18:59:58 <jmcarthur> romildo: it's not supposed to mean a whole lot. it's just a silly way of saying "Learn Haskell"
19:00:38 <ghartshaw> @pl \f g x -> f (g x)
19:00:39 <lambdabot> (.)
19:00:39 <applicative> chenwl: yes like ion says, there is unrelenting 'sequencing' in what you say inside ghci, like in an IO do block
19:00:53 <romildo> jmcarthur, what would be the title without the intentionall bad grammar?
19:01:29 <applicative> romildo, its strange, but many people I know couldnt stop laughing for days after they saw it
19:01:56 <geheimdienst> romildo: "learn haskell. it will be great."
19:01:57 <mustelo> romildo, maybe "learn haskell. it's good!"
19:02:28 <applicative> no "learn haskell -- for the greater glory of G-d"
19:02:33 <ghartshaw> @pl \f x g y -> f x (g y)
19:02:33 <lambdabot> ((.) .)
19:02:34 <chenwl> applicative: in this way 'inside do-block', it inconvenient to try out a function
19:02:49 <ion> If i had a dog, i’d probably name him D-g.
19:02:52 <jmcarthur> romildo: basically just "Learn Haskell" along with some implication that it is good for you or for the world
19:03:05 <applicative> but when you revise you so to say overwrite the earlier definition
19:03:58 <applicative> or rather the earlier binding passes out of scope
19:04:34 <applicative> > let a = 3 in a + (let a = 4 in a)
19:04:35 <lambdabot>   7
19:05:24 <romildo> applicative, maybe for a native English speaker the title is amusing. Being a foreigner, I do not see too much fun in it.
19:06:07 <applicative> romildo, I think that's right, it is as if a Slavic speaking person were imitating someone from the US South ... for example
19:06:41 <confound> romildo: for this native English speaker, it's just weird
19:07:22 <romildo> Maybe the author could comment on the title somewhere ...
19:07:25 <applicative> confound, actually I still can't think of it without laughing.:)
19:08:12 <confound> applicative: ok...?
19:08:15 <chenwl> have you tried haskell on heroku
19:10:02 <applicative> chenwl, it occurs to me isnt there a #yesod ?  I'm not sure you'll be able to wake anyone up, it's low bandwidth, i'd think
19:11:48 <chenwl> applicative: ok
19:12:19 <ghartshaw> @pl \f g h x y -> f (g x y) (h y)
19:12:19 <lambdabot> ((flip . (ap .)) .) . (.) . (.)
19:12:35 <ghartshaw> @pl \f g h x -> f (g x) (h x)
19:12:36 <lambdabot> liftM2
19:12:57 <applicative> chenwl: i'm not sure when might be best to go there; the principal developer lives in the middle east
19:13:53 <chenwl> applicative: do you know any host support haskell?
19:14:41 <applicative> no, never touch IO myself
19:25:24 <jmcarthur> chenwl: like a web host?
19:25:37 <jmcarthur> chenwl: any that supports binaries should work, i'd think
19:25:53 <jmcarthur> unless you mean something more first class than that somehow
19:31:32 * hackagebot swish 0.5.0.3 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.5.0.3 (DouglasBurke)
19:34:35 <parcs> chenwl: any VPS provider supports haskell
19:34:45 <parcs> linode is the best of those
19:34:53 <kmc> lambdabot runs off linode, doesn't she?
19:35:00 <kmc> it can be pretty ugly to compile your code on a RAM-limited VPS, though
19:35:01 <parcs> /whois lambdabot
19:35:07 <kmc> it's fine to compile on your dev machine and copy binaries
19:35:12 <parcs> indeed
19:37:34 <chenwl> parcs: thanks
19:46:20 <ghartshaw> @pl \f g h i x -> f g (h x) i
19:46:20 <lambdabot> (((flip .) . (.)) .)
19:49:44 <augur> blah
19:50:00 <augur> people who dont realize that types are compile time assertions :|
19:50:36 <kmc> types are just for performance, right? and for telling the compiler how many bits to use
19:50:36 <kmc> ;P
19:51:20 <augur> im in a convo on reddit about this and im waiting for the guy to reply, since i just said precisely that
19:51:28 <augur> "types are essentially compile-time assertions"
19:51:34 <augur> im waiting for him to try and say they're not
19:51:42 <augur> so i can "suggest" a few slight modifications
19:52:39 <augur> instead of   function foo(x) { assert(isa(x, Int)); ... }   we can make it simpler, just put the assertion next to the variable declaration
19:52:49 <augur> function foo(x isa(x,Int)) { ... }
19:52:50 <kmc> and make it even simpler by leaving it off!
19:52:55 <augur> but then why bother repeating x
19:53:04 <augur> function foo(isa(x,Int)) { ... }
19:53:07 <kmc> "<augur> [...] reddit [...]"  ←  found your problem
19:53:16 <augur> but thats ugly, why not use : instead of isa
19:53:23 <augur> function foo(x : Int) { ... }
19:53:26 <augur> oh look, a type
19:53:36 <augur> kmc: nah its actually a good conv
19:53:48 <shachaf> augur: I don't think anyone disputes that.
19:54:03 <augur> shachaf: dispute, maybe not. not realize? certainly.
19:54:15 <shachaf> Eh.
19:54:16 <kmc> which reddit augur?
19:54:22 <augur> kmc: r/programming
19:54:33 <augur> so, not functional programmers
19:54:40 <kmc> dysfunctional programmers
19:54:41 <augur> its in the dependent types thread
19:54:47 <augur> you know the one
19:54:47 <kmc> that place is a cesspool
19:54:50 <kmc> don't waste your time there
19:54:58 <kmc> do something, anything, better with your life
19:54:59 <augur> where someone pretended Java has dependent types
19:55:07 <kmc> i say this as a long-time addict
19:55:08 <augur> and everyone who knows what dependent types are wanted to stab their eyes out
19:55:21 <augur> i actually posted a nice explanation of some stuff
19:55:26 <augur> bunch of upvotes, no downvotes
19:55:28 <augur> so maybe theres hope
19:57:30 <ghartshaw> @pl \f g h x -> f (g x) h
19:57:31 <lambdabot> (flip .) . (.)
19:57:53 <ghartshaw> @pl \x y -> elem (snd x) y
19:57:53 <lambdabot> elem . snd
19:58:09 <ghartshaw> @pl \x y -> elem (snd y) x
19:58:09 <lambdabot> flip (elem . snd)
20:10:57 <chenwl> ghc app.hs --make -optl-static -fforce-recomp
20:11:24 <chenwl> undefined reference to `pthread_mutex_lock'
20:11:49 <kmc> try -optl-threads or -optl-lpthreads
20:12:04 <kmc> why are you using -optl-static
20:12:54 <chenwl> kmc: to statically link
20:13:13 <kmc> i gathered as much
20:13:18 <kmc> i meant, why do you need a static binary
20:13:29 <kmc> Haskell libraries are linked statically by default, without -optl-static
20:13:35 <kmc> you only need that to statically link libc and the like
20:13:45 <chenwl> kmc: to push to heroku
20:13:53 <chenwl> http://www.haskell.org/haskellwiki/Web/Literature/Static_linking
20:14:01 <kmc> heroku doesn't let you dynamically link libc?
20:14:08 <hpaste> t pasted “IterateeIO.hs” at http://hpaste.org/50504
20:14:21 <ghartshaw> @pl \f -> matchRule (f rule) (neighbors cells)
20:14:21 <lambdabot> flip matchRule (neighbors cells) . ($ rule)
20:15:51 <chenwl> http://hpaste.org/50505
20:16:44 <tcard> I have an issue that I believe is a basic monad transformer problem, in the context of iteratees and WAI.  Please see http://hpaste.org/50504 for details.
20:17:03 <tcard> Any help would be greatly appreciated!
20:17:25 <parcs> tcard: liftIO
20:18:05 <ghartshaw> @p \f -> g x (f y)
20:18:06 <lambdabot> Maybe you meant: palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices . ? @
20:18:06 <lambdabot> v
20:18:16 <ghartshaw> @pl \f -> g x (f y)
20:18:16 <lambdabot> g x . ($ y)
20:18:26 <tcard> parcs: thanks; I was wondering about liftIO, but I was unable to figure out where to import it from...
20:18:35 <shachaf> @where hoogle
20:18:36 <lambdabot> http://haskell.org/hoogle
20:18:37 <parcs> it's is Control.Monad.Trans
20:18:48 <tcard> parcs: thank you!  I will try it now!
20:19:44 <chenwl> kmc: fixed by adding -optl-pthread
20:20:09 <kmc> cool
20:20:12 <ghartshaw> @pl \f -> g (flip f x) ((i y . ($ z)) h)
20:20:12 <lambdabot> flip g (i y (h z)) . flip flip x
20:20:51 <shachaf> ghartshaw: What are you trying to figure out with all your @pls?
20:22:41 <tcard> parcs: works fine; thank you!
20:22:59 <parcs> you're welcome
20:24:48 <ghartshaw> @pl \f w x y z -> (f w x) ++ (f y z)
20:24:48 <lambdabot> flip =<< ((flip . (((.) . (.) . (++)) .)) .)
20:25:13 <ghartshaw> @pl \w x y z -> (fun w x) ++ (fun y z)
20:25:13 <lambdabot> flip flip fun . (((.) . (.) . (++)) .) . fun
20:28:52 <fazzone> Is there any way to make something like this work?  class A a where someFunction :: (A b) => a -> b ?
20:30:49 <mysticc> what is @pl actually ??
20:31:50 <shachaf> fazzone: What do you want that for?
20:32:56 <Phyx-> doesn't that already just work?
20:33:02 <Phyx-> my ghci accepts it...
20:34:48 <kmc> mysticc, converts code to "pointless" aka points-free style
20:34:55 <Phyx-> though I aint sure how useful it is
20:35:00 <kmc> fazzone, does it not work as is?
20:35:05 <kmc> fazzone, also, what are you actually trying to do?
20:35:25 <Terry> @pl s f a b = f b a
20:35:25 <lambdabot> s = flip
20:35:38 <kmc> we get a lot of questions of the form "how do i contort type classes to achieve this very complex design" where the correct answer is "do this other very simple thing not involving type classes"
20:36:28 <Phyx-> can you actually use such a definition?
20:37:29 <kmc> well, imagine a function of type «(A b) => Int -> b»
20:37:40 <parcs> i don't think you can provide a valid definition of that function
20:37:41 <kmc> it requires some way to synthesize arbitrary values using only the A typeclass API
20:37:49 <kmc> so you can only return "undefined"
20:37:59 <Phyx-> right
20:38:23 <Phyx-> i guess something like this would do it though
20:38:25 <Phyx-> class A a where type Res a :: * foo :: a -> Res a
20:38:30 <Phyx-> err
20:38:55 <Phyx-> class A a where { type Res a :: *; foo :: a -> Res a }
20:39:08 <Phyx-> why did my client remove the newlines...
20:39:36 <kmc> that would be a different class
20:40:36 <ion> It doesn’t have the ‘A b’ restriction.
20:41:09 <Phyx-> right, but it would also be equivalent to changing a to A a b | a -> b, b -> a
20:41:12 <Phyx-> right?
20:41:16 <cdsmithus> Any one know where I can find an example of the GHC API ( or hint) loading a package that depends on types from the current package?  Or is that not possible?
20:41:54 <Phyx-> cdsmithus: i don't follow..
20:42:29 <cdsmithus> I want to load some code with the GHC API, but that code uses types I define in my own program.  I can't seem to make that work
20:43:02 <HTML-Hacker> i know how 2 access ring0 via html
20:43:14 <Phyx-> hahaha
20:43:19 <Phyx-> short lived spambot
20:43:26 <fazzone> Algebra...probably stupid.  class Expression e where simplify :: (Expression b) => e -> b   , so then things like   simplify (Product e (Sum a b)) = Sum (Product e a) (Product e b)   work
20:43:31 <kmc> bravo
20:43:31 <ghartshaw> @pl m (e,b) = filter (flip e c) (mt (n c) (b r))
20:43:32 <lambdabot> m = uncurry ((. (mt (n c) . ($ r))) . filter . flip flip c)
20:43:52 <Phyx-> cdsmithus: that's pretty hard i Think... can't you just segment those parts of to a lib?
20:44:12 <cdsmithus> I guess I can.  I just hoped to avoid complicating the installation
20:44:24 <cdsmithus> Okay, I'll put it in a library then
20:44:56 <Phyx-> I can't think of any other way where GHC's sanity checkers don't scream bloody murder
20:45:53 <parcs> fazzone: just create a function simplify :: Expr -> Expr
20:46:28 <ghartshaw> @pl m n r = map fst $ filter (flip (elem . snd) r) n
20:46:29 <lambdabot> m = (map fst .) . flip (filter . flip (elem . snd))
20:47:17 <ghartshaw> @pl m r n = map fst $ filter (flip (elem . snd) r) n
20:47:18 <lambdabot> m = (map fst .) . filter . flip (elem . snd)
20:47:25 <ion> Just keep the r. :-)
20:47:49 <fazzone> parcs: That's probably what I want, thanks!  kmc: another successful prediction (which I suppose is unsurprising, given that that sort of thing happens a lot)
20:49:00 <fazzone> parcs: So Expr = Sum a b | Product a b    and so on?
20:49:38 <parcs> Expr = Val Int | Sum Expr Expr | Product Expr Expr
20:49:39 <ion> Something like data Expr = Constant Integer | Sum Expr Expr | Product Expr Expr
20:49:57 <parcs> Constant's a better name
20:51:07 <mysticc> How to know all the function instances defined for class .. like I want to know all functions for Num ..
20:51:21 <parcs> @instances Num
20:51:22 <lambdabot> Double, Float, Int, Integer
20:51:30 <ion> Run «:i Num» in ghci.
20:51:31 <parcs> :i Num
20:51:59 <mysticc> Thanks :)
20:54:48 <parcs> @faq
20:54:49 <lambdabot> The answer is: Yes! Haskell can do that.
20:54:51 <parcs> @where faq
20:55:07 <parcs> @where faq
20:55:47 <parcs> where's the faq
20:55:56 <ivanm> parcs: which FAQ?
20:56:05 <parcs> kmc's faq
20:56:07 <fazzone> what if you wanted to have the Constant data constructor work for any instance of Num, not just Integer?
20:56:21 <shachaf> @where+ faq http://www.haskell.org/haskellwiki/FAQ
20:56:21 <lambdabot> Done.
20:59:45 <parcs> fazzone: data Expr a = Constant a | ... then simplify :: Num a => Expr a -> Expr a
21:00:00 <pedro3005> can anyone help me with this code? http://paste.pocoo.org/show/461689/
21:00:29 <ivanm> pedro3005: what's your error?
21:00:36 <ivanm> and any particular reason for rolling your own?
21:00:47 <pedro3005> is there a std function for this?
21:01:03 <pedro3005> the error is
21:01:05 <pedro3005>     Occurs check: cannot construct the infinite type: a = [[a]]
21:01:06 <pedro3005>     When generalising the type(s) for `partitions'
21:01:31 <ivanm> pedro3005: oh, you want partitions of a specified length?
21:01:47 <pedro3005> no,  a specified number of partitions
21:01:50 <ivanm> pedro3005: partitions xs 1 = [[xs]]
21:02:03 <pedro3005> oh yes
21:02:09 <pedro3005> same error though
21:02:19 <ivanm> pedro3005: if that's what you want, you're better off having a function that generates _all_ partitions, and then do a take on the results
21:03:16 <pedro3005> for ex., partition [a, b, c] in 2, we have the possibilities [[a, b], [c]], [[a, c], [b]] etc
21:03:19 <pedro3005> that is what i want
21:04:05 <ivanm> pedro3005: every possible way of splitting it up into blocks of length 2 + what's left over?
21:04:30 <pedro3005> no, every possible way of splitting it up into 2 blocks
21:04:36 <ivanm> ahhhh, OK
21:06:37 <ivanm> yeah, I don't know of any existing functions that do that
21:06:41 <pedro3005> so I was thinking
21:06:41 <pedro3005> for each subset of xs
21:07:03 <pedro3005> we have this subset put along with every way to partition the set minus this subset in n - 1 blocks
21:07:20 <pedro3005> since the subset will be 1 block
21:07:35 <kmc> don't use (\\)
21:07:40 <kmc> it's slow and probably a sign you're doing it wrong
21:08:05 <ivanm> my thinking of how to do this: you want n blocks.  For each x in xs, put it in one of those blocks
21:08:16 <miyako> I need to do some (somewhat) fancy terminal IO, and I've found both HSCurses and System.Console.ANSI, anyone have sufficient experience with these to recommend one over the other, or an alternative?
21:08:28 <kmc> miyako, look at vty also
21:09:17 <pedro3005> ivanm, I see, but don't have much of an idea of how I'd complete that as an algorithm
21:09:22 <pedro3005> kmc, suggestions?
21:09:27 <miyako> kmc: thanks
21:09:28 <kmc> sec
21:09:32 <kmc> this has come up before
21:09:52 <ivanm> pedro3005: you might get somewhere with http://hackage.haskell.org/packages/archive/multiset-comb/latest/doc/html/Math-Combinatorics-Multiset.html#v:partitions
21:10:02 <ivanm> but it doesn't specify the number of partitions
21:11:11 <psii> @src Data.List.subsequences
21:11:12 <lambdabot> Source not found. The more you drive -- the dumber you get.
21:11:15 <kmc> pedro3005,
21:11:27 <kmc> (sorry, sec)
21:11:28 <ivanm> pedro3005: OK, one recursive way of doing it: for the ith partition, for each value either take it or not
21:11:32 <kmc> pedro3005, http://hpaste.org/49156
21:11:53 <ivanm> which is what kmc just did ;)
21:12:21 <kmc> 'bisect' takes a list and returns all ways of splitting it into two sublists
21:12:44 <kmc> 'partition' takes a list and returns all ways of splitting it into an arbitrary number of sublists
21:13:03 <kmc> to do this, we 'bisect' the input list, take the left half as our first sublist, and recursively partition the right half
21:13:39 <pedro3005> clever
21:13:41 <miyako> you know, every time I come to this channel, I find myself distracted because it seems like someone else is trying to solve a problem more interesting than mine :)
21:14:31 <kmc> pedro3005, this last came up on July 17 of this year, if you'd like to read the logs
21:15:01 <mysticc> :p ^^
21:15:36 <ivanm> pedro3005: I think that's kinda what you were trying to do, but expressed better
21:15:59 <pedro3005> I can easily filter the partition function to get only the ways of partitioning into k subsets
21:18:14 <ivanm> pedro3005: ummm.... filtering by calculating the length would be expensive
21:18:38 <ivanm> kmc: well, I asked about combinations of specified length not partitions, so that couldn't have been me asking... :p
21:18:43 <pedro3005> yeah
21:18:55 <kmc> pedro3005, you can thread through an Int argument saying how many sublists you want
21:31:07 <ghartshaw> @unpl mr = (map fst .) . filter . flip (elem . snd)
21:31:08 <lambdabot> mr g p = map fst (filter (\ d -> elem (snd d) g) p)
21:37:05 <zzo38> What is the command in GHC to check everything in a program can be compiled including foreign import/export and so on, and warnings/errors message, etc, but without making any output file?
21:38:03 <kmc> cabal build && rm -r dist/
21:38:28 <ghartshaw> @unpl map $ (head &&& length)
21:38:29 <lambdabot> (map (head &&& length))
21:39:06 <ghartshaw> @unpl group . sort . concatMap n
21:39:07 <lambdabot> (\ c -> group (sort (concatMap n c)))
21:41:06 <zzo38> How can I make it to ignore foreign exports when using GHCi, so that the program can be loaded in GHCi?
21:42:58 <kmc> there might be a CPP macro you can test to see if you're in ghci
21:43:11 <kmc> you can also compile the module and then load the compiled code in ghci
21:44:01 <zzo38> But I want to be able to call functions that are not exported in the module export list in ghci
21:44:38 <hpaste> kmc pasted “CPP and GHCi” at http://hpaste.org/50506
21:44:40 <kmc> zzo38, ^^^
21:44:44 <zzo38> Will GHC remove stuff that is neither exported nor used?
21:44:50 <kmc> yeah, it can
21:45:20 <zzo38> OK thanks I will try that
21:46:07 <zzo38> Does the module export list need to contain things that are foreign export and only called from C codes?
21:46:17 <kmc> i don't think so
21:46:20 <kmc> not ure
21:46:22 <kmc> not sure
21:47:01 <zzo38> They are never called from other Haskell modules, only from C.
21:47:25 <miyako> Hmm, not sure if using Vty will make life easier or harder
21:48:13 <miyako> kmc: I'm trying to write a syntax highlighting pager, any idea how good of a fit Vty would be for that compared to HSCurses?
21:49:11 <ghartshaw> @unpl (map $ (head &&& length)) . (group . sort . concatMap n)
21:49:11 <lambdabot> (\ c -> map (head &&& length) (group (sort (concatMap n c))))
21:49:57 <kmc> i don't know
21:51:25 <miyako> I guess I'll play with both and find out then :)
21:52:32 <kmc> it'd be really great if you could do a little write up about your experiences with both
21:52:47 <kmc> in general it's hard to know which of the n libs on hackage for a given task is best
21:55:01 <miyako> kmc: I'll be sure to do so :)
22:00:38 <ghartshaw> @pl \x -> map fst . filter (flip (elem . snd) x)
22:00:39 <lambdabot> (map fst .) . filter . flip (elem . snd)
22:01:06 <pedro3005> kmc, yeah this code is rather slow
22:01:14 <kmc> the one i pasted?
22:01:26 <pedro3005> well
22:01:28 <pedro3005> http://paste.pocoo.org/show/461713/
22:01:33 <pedro3005> the one i made from the one you pasted
22:01:40 <kmc> okay
22:01:54 <kmc> instead of generating all the partitions and then throwing most out
22:02:02 <kmc> you can thread an Int through 'partition'
22:02:07 <kmc> to make it stop at the right level
22:03:46 <yourstruly> Why isn't ++ defined inside a typeclass so you can create instances of it for types other than lists?
22:04:22 <kmc> :t (++)
22:04:23 <lambdabot> forall m. (Monoid m) => m -> m -> m
22:04:25 <kmc> lambdabot's is ;)
22:04:31 <ivanm> oh, yay, Caleskell... :s
22:04:34 <yourstruly> well, GHC's isn't
22:04:42 <kmc> you can fix that easily
22:04:45 <yourstruly> I want to define ++ for other recursive data types
22:04:47 <ivanm> yourstruly: I prefer it this way, because it reduces the barrier (IMHO) of teaching
22:04:56 <kmc> import Prelude hiding ( (++) ); import Data.Monoid; (++) = mappend
22:05:05 <kmc> anyway why do you want to call it (++) and not, say (+++)
22:05:12 <kmc> reusing names creates confusion
22:05:14 <ivanm> kmc: with the fixity stuff; you'll probably want it to be infixr to start with
22:05:41 <kmc> you should reuse names sparingly, to denote closely related concepts
22:05:48 <kmc> i think (++) for Monoid's mappend is probably a legit case
22:05:57 <yourstruly> ok
22:06:06 <kmc> but in general it's something one should be careful of
22:06:19 <pedro3005> kmc, yes but when is that?
22:06:27 <kmc> when is what?
22:06:53 <pedro3005> I mean, I don't get the code
22:06:57 <rothwell> lo. is there any usage documentation for http://hackage.haskell.org/package/tls ?
22:07:04 <rothwell> the haddock documentation isn't worth having
22:07:10 <kmc> pedro3005, then you should try to understand the code first :)
22:07:13 <kmc> i can answer questions
22:07:35 <rothwell> am trying to write a small server with Network.Socket.accept and forkIO... it's not clear what i'm supposed to do with the TLS contexts
22:10:28 <zzo38> What is the use of comonads?
22:10:31 <pedro3005> kmc, so, for each partition a, b of xs
22:10:42 <pedro3005> it takes a
22:10:48 <pedro3005> along with each partition of b
22:10:49 <kmc> zzo38, http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
22:10:50 <pedro3005> makes sense
22:10:59 <pedro3005> yeah it is simple enough
22:13:43 <zzo38> kmc: That document uses the names "cojoin" and "coreturn" although a package I have seen uses "duplicate" as the dual of "join" and "extract" as the dual of "return".
22:14:39 <kmc> ok
22:14:40 <pedro3005> kmc, adding the condition 'length p < k'?
22:14:51 <pedro3005> k being the given integer
22:19:55 <kmc> pedro3005, that's still filtering
22:20:36 <pedro3005> kmc, actually length p == k - 1 does the job. but yeah.
22:21:34 <pedro3005> if not that, then?
22:21:46 <kmc> pass an integer through the recursive calls to 'partition'
22:21:50 <kmc> that says how many sublists you want
22:24:30 <pedro3005> kmc, doesn't seem to stop partitions with length < k though
22:24:37 <kmc> you have to have the right base cases
22:24:48 <kmc> which is what i'm currently trying to figure out :)
22:24:59 <pedro3005> also
22:25:11 <pedro3005> there looks like there is a lot of repetition
22:25:19 <kmc> yes, it gives you every order of the list
22:25:48 <pedro3005> I think slowness is more due to that than the filtering, to be honest
22:26:29 <kmc> you can fix that by changing 'bisect' i think
22:26:39 <elliott> What's the most efficient way to turn a ByteString into a Data.Vector.Storable immutable Vector? Preferably just passing the ForeignPtr across. I want to make sure that the ByteString being GC'd won't destroy the Vector.
22:26:57 <kmc> elliott, i have code for that
22:27:07 <kmc> if you keep the ForeignPtr it won't be GC'd
22:27:39 <elliott> kmc: Great. (I'm then going to immediately unsafely cast the Vector to another element type. If I work fast enough every Haskell programmer on the planet will have an aneurysm by next week.)
22:27:58 <kmc> my main worry with that approach is that Vector might have alignment requirements
22:28:14 <jophish> Hi all!
22:28:18 <elliott> kmc: Then it shouldn't expose unsafeFromForeignPtr :-)
22:28:37 <kmc> > take 6 "unsafeFromForeignPtr"
22:28:38 <lambdabot>   "unsafe"
22:28:52 <kmc> hi jophish
22:29:28 <hpaste> kmc pasted “partitions of a specific length (for pedro3005)” at http://hpaste.org/50507
22:29:40 <kmc> pedro3005, btw, are you using QuickCheck to test your functions?
22:29:43 <kmc> i found it very useful, just now
22:29:53 <pedro3005> no, i'm using ghci
22:30:00 <elliott> kmc: Can you paste the code anywhere? I guess it wouldn't be so hard to write myself, but I'd rather avoid relying on Data.ByteString.Internals...
22:30:10 <kmc> that's what i'm using...
22:30:12 <pedro3005> kmc, that is pretty much what I did
22:30:24 <kmc> elliott, and i just remembered something is wrong with this code
22:30:25 <kmc> but i don't remember what :X
22:30:31 <kmc> i thought of it while walking to work one day
22:30:36 <elliott> kmc: heh :/
22:30:43 <kmc> and forgot by the time i sat down at my computer
22:30:51 <kmc> but i can remember exactly where I was when I thought of it!
22:30:56 <kmc> maybe if I go back there I will remember the bug
22:31:15 <elliott> I'm using cereal, so I suspect that it'll just be a slice of the input, which should be fun :-/
22:32:08 <elliott>         toForeignPtr,           -- :: ByteString -> (ForeignPtr Word8, Int, Int)
22:32:11 <elliott> Eh, it's the right signature.
22:32:42 <hpaste> kmc pasted “ByteString to Vector (may be wrong?)” at http://hpaste.org/50508
22:32:51 <kmc> elliott, i was going to put this on hackage actually
22:32:55 <kmc> if i can convince myself it's valid
22:32:58 <kmc> (and the other direction)
22:33:05 <jophish> Ok, I have this at the moment to create an infinite series of primes: "let primes = 2 : [x | x <- [3..10], foldr (\ y p -> if ( x `mod` y ) == 0 then False else p ) True primes]" I realize why it isn't working, referring to primes at the end of the fold is recursing without stopping. I'm not entirely sure how to stop this behaviour though
22:33:07 <kmc> if you spot any bugs, do let me know :)
22:33:36 <kmc> «if q then False else p» ≡ «p && not q»
22:33:39 <jophish> I realize that this isn't particularly efficient either !
22:33:45 <hpaste> pedro pasted “kmc, separable 16 2 still takes a while to compute” at http://hpaste.org/50509
22:33:46 <elliott> kmc: That's pretty much what I just wrote, except I don't need any division because my vectors are all one-byte-element :P
22:33:55 <kmc> ok
22:34:02 <elliott> Hooray for cheating!
22:34:06 <kmc> yep
22:34:59 <kmc> one thing I like about GHC Haskell is that it's all high level and safe and shit, but it trusts you to break the rules if you want
22:35:25 <yourstruly> kmc: SPJ is awesome
22:35:42 <kmc> this would doom it for large projects with lots of mediocre developers
22:35:54 <kmc> but i don't think anyone's aiming for that niche
22:36:13 <yourstruly> kmc: John Carmack was talking about using it for developing games because of the safety
22:36:22 <yourstruly> you probably saw that
22:36:22 <kmc> yeah
22:36:35 <pedro3005> in fact it's still going at it
22:36:35 <kmc> all members of #haskell and /r/haskell had a simultaneous nerdgasm
22:36:44 <kmc> the shockwave was detected on the Moon
22:37:19 <kmc> what's funny is that all the "safety" and "purity" is really enforced by library design and community norms, not in the language
22:37:34 <kmc> but i guess the other side of the coin is making a language where you can be safe and pure and still get shit done
22:39:11 <kmc> elliott, oh, one worry is that ByteString and Vector.Storable use different allocators
22:39:17 <kmc> or might
22:39:19 <elliott> kmc: heh :/
22:39:46 <kmc> i'm not sure, when you append to a Vector.Storable, if it ever resizes in place
22:39:55 <kmc> if so it might very well break
22:49:40 <ghartshaw> @pl \fs -> pam . (pam fs)
22:49:40 <lambdabot> (pam .) . pam
22:50:26 <ghartshaw> @pl \fs x y -> concat (pam2 fs x y)
22:50:27 <lambdabot> ((join .) .) . pam2
22:50:29 <kmc> :t iterate ?pam ?fs !! 2
22:50:30 <lambdabot> forall a. (?fs::a, ?pam::a -> a) => a
22:51:19 <kmc> maybe i should email rl and ask about that vector issue
22:51:40 <solrize> http://hpaste.org/50511   any idea how to spot the space leak?
22:51:41 <ghartshaw> @pl \fs x -> concat (pam fs x)
22:51:42 <lambdabot> (join .) . pam
22:52:33 <kmc> solrize, merge xo@(x:xs) yo@(y:ys) ... | x > y = y : merge xo ys
22:52:40 <kmc> i don't actually know if that will help
22:52:43 <kmc> but it will reduce allocation
22:52:55 <solrize> trying
22:53:21 <kmc> did you do heap profiling? what type of object is filling up the heap?
22:53:42 <solrize> sec
22:53:56 <solrize> i used -hc to see the total consumption
22:54:03 <solrize> gotta find option for types
22:54:35 <solrize> running
22:55:41 <solrize> mostly ARR_WORDS
22:55:58 <solrize> with -hy
22:56:29 <solrize> that does lower space consumption from 70mb to 14mb
22:56:45 <solrize> but it's still growing approx linearly
22:56:56 <kmc> using the @-pattern does?
22:57:08 <solrize> yeah
22:57:13 <kmc> cool
22:57:17 <solrize> wait i'm looking at wrong #
22:57:20 <kmc> i don't actually know what ARR_WORDS is
22:57:24 <solrize> # at top is still 80mb
22:57:32 <kmc> :/
22:57:41 <solrize> lemme run other way again
22:57:49 <solrize> that's 80MB-sec
23:00:43 <solrize> yeah the @ actually increased consumption a tiny amount
23:11:15 <solrize> maybe it's inherently linear space
23:21:35 <Athas> Why did I not know about System.Console.Ansi before?  I have been looking for exactly this!
23:21:38 <Athas> Goodbye Ncurses.
23:23:49 <elliott> Athas: Maybe I can make your day even better: http://hackage.haskell.org/package/ansi-wl-pprint
23:26:33 <Athas> I think that's too high-level for me.  I'm writing a TTY backend to a GUI library.
23:27:10 <Athas> It's nifty, though.
23:29:53 <elliott> Athas: Fair enough then.
23:30:05 <elliott> Athas: It's great when you're basically just printing out formatted colourised text.
23:30:25 <Athas> Yes, I'll certainly keep it in mind for non-interactive uses.
23:30:27 <xil> hello. I'm trying to figure out some autocompletion things with leksah. I'd like to either turn off the autocompletion box that appears EVERY TIME I START TYPING, or somehow change it to include my own functions in the list. Does anyone know how to do this? I can't find anything in the settings apparently
23:44:55 <elliott> With Data.Vector.Storable, will Vector (Vector a) be unrolled to have the same representation as Vector a?
23:45:04 <elliott> I guess not, since the inner Vector could have arbitrary length.
23:45:25 <elliott> I suppose I should just use repa for fixed-size two-dimensional arrays. Seems overkill though (13x13).
23:45:39 <elliott> Although repa requires far more boilerplate for an element type than just Storable :/
23:45:41 <elliott> Anyone have any suggestions?
23:48:43 <elliott> I guess I could just define my own indexing function :)
23:52:48 <permagreen> That's what I always do. I'm not comfortable playing with other peoples' functions.
23:53:15 <elliott> Would be nice to have a proper two-dimensional structure to it, but oh well.
23:55:16 <bfig> hello, i wanna compute the mean value of time it takes to reach a certain state in an absorbent markov chain. i have a function that gives me the value of the transition matrix from state i to state j, how can i use matrices?
23:56:01 <bfig> i want to write the matrix and then compute an approximate sum of iterates or something
23:57:13 <bfig> i just need 1) a way to represent matrices, 2) a way to multiply them, 3) a way to sum a related quantity of it
23:59:23 <RenJuan> sounds like a school assignment
23:59:38 <bfig> the algorithm would be 'start from state x with transition matrix M, then compute the approximate nth Expected value sum (i <=n) (M^i x)_f *i where _f is the coordinate i want to reach
23:59:56 <bfig> well, it kind of is... only i'm doing it for fun
