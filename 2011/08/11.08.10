00:03:31 <frerich> Why doesn't '(x:_) = ""' throw an exception?
00:04:02 <Axman6> why should it?
00:04:04 <frerich> Ah, maybe because it's lazy? I do get an exception if I attempt to do something with 'x'.
00:04:07 <Axman6> it only will if you use x
00:06:04 <frerich> Hmm.
00:06:18 <frerich> I'm still missing something.
00:06:43 <jocom> Being?
00:06:50 <frerich> > let y = [x | (x:_) <- [""]]  in print y
00:06:51 <lambdabot>   <IO ()>
00:06:58 <frerich> Oh, sorry.
00:07:16 <frerich> Anyway, this doesn't yield an exception, but 'let y = map head [""]' does
00:07:26 <kmc> once you use "y"
00:07:32 <frerich> Yes, but not in the former case.
00:07:39 <frerich> If I use a list comprehension, I always get [""]
00:07:48 <kmc> pattern match failure in list comprehensions is special
00:07:53 <kmc> it drops that element
00:08:06 <jocom> that's what your intuition wants, right?
00:08:10 <kmc> usually
00:08:33 <jocom> list comprehensions are Maybe evil
00:08:53 <frerich> kmc: Ah, interesting!
00:09:21 <frerich> kmc: I read a question about this on StackOverflow a bit ago and started playing with it, but I couldn't explain it. Mind if I quote you?
00:09:42 <kmc> fine by me
00:10:07 <kmc> > do { (x:_) <- [""]; return x }
00:10:07 <lambdabot>   ""
00:10:15 <kmc> the specialness arises from the definition of "fail"
00:10:19 <kmc> @src [] fail
00:10:19 <lambdabot> fail _      = []
00:11:21 <frerich> So when using list comprehensions, the fail function is called for every element for which the given pattern fails to match?
00:12:12 <ddarius> frerich: Or when using do-notation.
00:12:19 <edwardk> heya ddarius
00:12:46 <ddarius> Hola
00:13:17 <edwardk> i think i have a cleaner way to manage the cps transform behind the scenes of parsec. in particular the code i'm using for dealing with it in trifecta is a lot simpler and does a lot less juggling for basically the same set of continuations
00:13:45 * hackagebot trifecta 0.12 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.12 (EdwardKmett)
00:14:15 <edwardk> https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Parser/Prim.hs
00:14:33 <edwardk> is the relevant part
00:14:54 <edwardk> its basically my 'right kan extension' golden hammer
00:15:05 <ddarius> I'd be very unsurprised if Antoine's CPS code could be improved.
00:15:14 <edwardk> =)
00:15:40 <edwardk> basically i moved the error state from writer to state effectively, which lets the continuations that don't care about it ignore it
00:15:58 <edwardk> and then flopped all the arguments over the continuations so they can also be ignored
00:16:39 <edwardk> decided to go with a polyparse-style commit parser though rather than a parsec try parser
00:17:38 <edwardk> ultimately only 2 real definitions need to change to flip back and forth for me, but given the fact that i get nothing from 'discarding' the input history, and only gain because i don't have to backtrack the <|>'s it seemed prudent
00:18:41 <edwardk> i think trifecta now boasts the tiniest iteratee-like data type out there as well ;)
00:19:22 <edwardk> data It a = Pure a | It a (Rope -> It a) — sadly it isn't quite free
00:22:16 <ddarius> Well you can factor the a out and get It a = (a, Maybe (Rope -> It a)) which makes it a cofree comonad.
00:22:18 <edwardk> it is cofree though: data It a = It a (Maybe (Rope -> It a))
00:22:21 <edwardk> yeah
00:22:26 <edwardk> i have the comonad instance
00:23:45 <edwardk> i kept it separate because i didn't want to pay for the extra constructor, due to the fact  that almost everything case analyses it
00:24:39 <edwardk> one nice thing about the approach i'm using is it allows me to pile monad transformers on top of the parser stack
00:24:59 <edwardk> (without all the lifts)
00:28:58 <dmwit> Quick, which package has "data Iso a b = Iso (a -> b) (b -> a)" and the smallest dependency tree?
00:29:38 <ddarius> Probably one of the lense libraries.
00:29:54 <dmwit> edwardk: BTW I sent you a pull request for reducers.
00:30:03 <edwardk> dmwit: k
00:30:14 <edwardk> dmwit: what'd you change?
00:30:16 * ddarius needs to move to Georgia.
00:30:56 <edwardk> ah
00:30:57 <dmwit> edwardk: moved the SPECIALIZE pragmas slightly
00:31:02 <edwardk> i see
00:31:17 <edwardk> hrmm i wonder what other old code i have that specializes that way
00:31:22 <dmwit> yeah
00:31:47 <dmwit> I've found a few other packages with similar bugs, where there were pragmas that didn't actually do anything because they were being applied to a (non-existent) default method.
00:32:00 <dmwit> If that's how old GHC's behaved, it's nice that those things are errors now. =)
00:32:30 <edwardk> yeah
00:33:09 <edwardk> merged and pushed
00:33:09 <dmwit> (INLINE has the same caveat.)
00:33:12 <dmwit> rock
00:33:45 * hackagebot reducers 0.1.3 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-0.1.3 (EdwardKmett)
00:38:19 <kmc> ddarius, which one?
00:38:30 <quicksilver> @faq can haskell move ddarius to Georgia?
00:38:30 <lambdabot> The answer is: Yes! Haskell can do that.
00:38:39 <quicksilver> that's a relied.
00:38:41 <quicksilver> relief.
00:39:50 <Kaidelong> lambdabot is up!
00:40:05 <Kaidelong> I wonder what the temperature down in hell is
00:43:50 <somestrangerinan> any redditor's here?
00:44:04 <somestrangerinan> i need upbeats please
00:44:05 <somestrangerinan> http://redd.it/jee5g
00:44:05 <edwardk> yeah
00:44:27 <somestrangerinan> upbeats please, i'd appreciate it edwardk
00:45:09 --- mode: ChanServ set +o quicksilver
00:45:18 <mreh> @vixen do you reddit?
00:45:19 <lambdabot> i do occassionally, i guess
00:45:20 --- mode: quicksilver set +b *!*tinu@*.nycmny.fios.verizon.net
00:45:20 --- kick: somestrangerinan was kicked by quicksilver (let me think. The answer is, go away.)
00:45:30 --- mode: quicksilver set -o quicksilver
00:52:51 <frerich> kmc: http://stackoverflow.com/questions/7007222/haskell-list-comprehension-to-combinatory/7007369#7007369 <-- I hope I quoted you correctly
00:56:25 <kmc> looks good :)
00:57:10 <shachaf> I don't think list comprehensions actually get translated to fail, do they?
00:57:21 <shachaf> Since the whole thing is specialized to lists anyway.
00:57:24 <shachaf> @undo [x | Just y <- z]
00:57:24 <lambdabot> concatMap (\ a -> case a of { Just y -> [x]; _ -> []}) z
00:57:39 <dmwit> They do with the MonadComprehensions extension.
00:58:22 <quicksilver> shachaf: that seems like an irrelevant implementation detail :)
00:58:28 <shachaf> dmwit: But that extension doesn't apply to the list comprehensions discussed there. :-)
00:58:33 <shachaf> quicksilver: Well, fail is evil.
00:58:38 <quicksilver> IIRC, list comprehensions don't actually get translated to haskell at all.
00:58:45 * hackagebot kqueue 0.1.1 - A binding to the kqueue event library.  http://hackage.haskell.org/package/kqueue-0.1.1 (ErikHesselink)
00:58:54 <quicksilver> they get translated directly into Core
00:58:56 <ddarius> Burroughs mock science is atrocious.
00:59:12 <quicksilver> this is one of the things that help up MonadComprehensions.
00:59:17 <shachaf> http://www.haskell.org/onlinereport/exps.html#list-comprehensions
00:59:28 <quicksilver> shachaf: that's what the report specifies rather than what GHC does
00:59:43 <quicksilver> and, like I said, this is an implementation detail so we're talking about an implementation.
00:59:55 <quicksilver> Having a method to define how to handle pattern match failure isn't evil anyhow.
00:59:55 <shachaf> The report just says it satisfies those identities.
01:00:06 <quicksilver> it was only including it in the main Monad class which was.
01:00:31 <shachaf> At any rate, if neither the report nor GHC says that fail is involved, it seems a bit silly to that it is.
01:00:34 <ddarius> quicksilver: List comprehensions are subject to fusion which would suggest that they are translated to functions so that rewrite rules could be applied.
01:00:45 <shachaf> "This is due to the definition of the fail function which is called by the list comprehension in case a pattern fails to match some element:"
01:00:59 <quicksilver> ddarius: certainly the details of the translation were chosen carefully to make sure fusion works
01:01:12 <quicksilver> ddarius: but my memory is that there was something odd about it. I may have misremembered.
01:01:45 * shachaf wasn't saying it was implemented one way or the other, just that to claim that it uses fail is pointless.
01:01:56 <edwardk> i love when testing seemingly pure code when you get a segmentation fault
01:01:56 <shachaf> As long as you're claiming things like that, you might as well say it uses mzero. :-)
01:02:18 <ddarius> edwardk: If you stick to C you won't have those problems.
01:02:27 <quicksilver> shachaf: well it's not entirely pointless
01:02:39 <quicksilver> shachaf: it makes the strong analogy with do { Just x <- blah; ... }
01:02:43 <quicksilver> shachaf: ...which definitely does use fail.
01:02:54 <quicksilver> and obviously list comp syntax is very closely related to do syntax
01:03:01 <quicksilver> so it's not unreasonable to draw out a commonality.
01:03:45 * hackagebot prototype 0.3 - prototype-based programming on Haskell  http://hackage.haskell.org/package/prototype-0.3 (YoshikuniJujo)
01:03:47 * hackagebot type-equality 0.1.0.1 - Type equality, coercion/cast and other operations.  http://hackage.haskell.org/package/type-equality-0.1.0.1 (ErikHesselink)
01:03:51 <yitz> edwardk: you can get that if you use OverloadedStrings
01:04:03 <edwardk> ?
01:04:13 <yitz> edwardk: or, similarly, a misbehaving Num or Integral instance
01:04:29 <edwardk> i don't think it is either of those at this point
01:04:56 <willem> when you 'branch' using darcs, do you do a 'darcs get' from a local repository (gotten from the remote repo) or directly from the remote repo?
01:05:17 <edwardk> i must be doing something bad with a bytestring or somethin
01:05:18 <frerich> shachaf: For the record, it's me to blame (and not kcm) in case it's wrong to claim that list comprehensions call 'fail' in case an element fails to match a pattern. It's just what I understood from kmc's (most certainly accurate) explanation.
01:05:26 <yitz> edwardk: OverloadedStrings causes string literals to call user-defined functions, which can do just about anything
01:05:57 <yitz> edwardk: that's not supposed to segfault.
01:06:11 <kmc> shrug
01:06:18 <kmc> i kind of implied that list comprehensions call fail
01:06:25 <kmc> "do" syntax does
01:06:35 <kmc> i don't know whether GHC translates list compr. to "do" before desugaring
01:06:39 <kmc> and anyway it's an implementation detail
01:06:44 <ddarius> It doesn't.
01:06:45 <dmwit> willem: There's no real difference between the two options (other than network speed vs. disk speed).
01:06:46 <edwardk> too tired to debug further. i think i'm going to get a couple hours of sleep and then peer at it with fresh eyes
01:07:39 <willem> dmwit: yeah it got both advantages and disadvantages I was just wondering what you guys used.
01:08:00 <dmwit> ah
01:08:33 <dmwit> I just get from my local repo.
01:08:45 * ddarius should do NoImplicitPrelude and then do fail <- foo; True <- bar; ...
01:09:00 <yitz> > [ x | x <- fail "oops"]
01:09:01 <lambdabot>   []
01:09:06 <dmwit> You can also "get" from a local repo, then set up all the remaining operations to be relative to the remote repo.
01:09:11 <dmwit> darcs is pretty flexible that way.
01:09:32 <dmwit> Or just "cp -r" the local repo. ;-)
01:10:41 <willem> Hehe that might be best. Then you don't have to do two pulls to get up to date again.
01:10:55 <yitz> > let fail = [42] in do fail
01:10:56 <lambdabot>   [42]
01:12:11 <willem> Does there exist a package with bindings for libstartupnotification or is someone working on it? Might want to start a project about that.
01:13:45 * hackagebot flock 0.2.5 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.2.5 (ErikHesselink)
01:13:47 * hackagebot trifecta 0.13 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.13 (EdwardKmett)
01:23:45 * hackagebot type-int 0.5.0.1 - Type Level 2s- and 16s- Complement Integers  http://hackage.haskell.org/package/type-int-0.5.0.1 (EdwardKmett)
01:24:30 <ricree> So I'm working with an FFI that requires some teardown and setup before and after a particular set of operations, but in theory I can have as many of those calls as I want between the setup and teardown.  Is there a good way to structure the haskell side to allow these to be chained together with multiple operations between the ends, assuming the setup and teardown should be invisible to whoever is using the api
01:25:02 <frerich> Is C. A. McCann around here sometimes?
01:25:09 <edwardk> yeah
01:25:22 <edwardk> cmccann
01:25:39 <frerich> Ah, thanks.
01:26:24 <mreh> am I missing a more general type class that does this already?
01:27:05 <mreh> (Node f fs) <*> (Node as as) = Node (f a) (zipWith (<*>) fs as)
01:28:13 <shachaf> That does what?
01:28:42 <edwardk> oh you want a zipping class
01:28:42 <edwardk> yeah
01:28:45 <edwardk> i have one of those
01:28:53 <edwardk> it may even have an instance for Tree
01:29:56 <edwardk> hrmm i don't per se, but i do have an instance for Cfree, so if you use Cofree [] as Tree you're all set ;)
01:30:12 <mreh> yeah, I expected it seeing as ZipList is common enough
01:30:40 <edwardk> Data.Key has 'Zip' which has zipping semantics for all of its inhabitants
01:31:10 <mreh> hmm, interesting
01:32:03 <mreh> shachaf: it zips trees up with each other
01:32:33 <mreh> I read the whole zippers article thinking it was what I wanted
01:33:42 <dmwit> ricree: Invisible, no.
01:33:53 <dmwit> ricree: But the "withFoo" style is fairly common, so I recommend that.
01:34:37 <dmwit> ricree: Alternately, you can define a new monad, and provide a runFoo operation that does setup and teardown (to enforce that setup and teardown happen).
01:39:04 <ricree> thanks dmwit
01:39:45 <mreh> you could use newtype (the hackage package)
01:40:02 <mreh> scrap that
01:42:12 <edwardk> i'm uploading a modified version of semigroupoids and keys with the Tree instances
01:43:28 <mreh> wooo
01:43:45 * hackagebot semigroupoids 1.2.5 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.2.5 (EdwardKmett)
01:44:01 <mreh> I am a published haskell programmer!
01:44:02 <edwardk> that adds Foldable1 and Traversable1 so i can make the Data.Key stuff install
01:49:04 <kmc> yay mreh
01:49:07 <kmc> congrats
01:51:23 <ricree> dmwit:  Could you suggest a good example of the "withFoo" style you were talking about?
01:53:04 <mreh> kmc: I shall be presenting a paper soon
01:58:43 <mreh> kmc: I hope you realise I was only joshing
01:58:57 <kmc> did not notice
01:58:59 <mreh> edwardk just incorporated an idea into his libs
01:59:14 <kmc> :)
01:59:34 <yitz> edwardk: thanks for the modified version of semigroupoids. *now* can you please get some sleep and not run yourself into the ground? we need you.
01:59:42 <edwardk> not yet
01:59:47 <edwardk> adding Tree to Key
01:59:52 <edwardk> then i'll sleep
01:59:58 <yitz> edwardk: uncurable
02:00:04 <metaperl_> I was wondering about languages that allow functions to have optional arguments ...
02:00:20 <metaperl_> it would seem that the options imply another function needs to be written?
02:00:21 <yitz> edwardk: found the segfault?
02:00:33 <edwardk> yitz: nah
02:00:37 <yitz> ok
02:00:38 <edwardk> busy shaving this other yak ;)
02:01:52 <edwardk> adding the instances for Tree required me to go add the missing instances for NonEmpty which required me to go add the ....
02:01:58 <dmwit> :t withFile -- ricree
02:01:59 <lambdabot> Not in scope: `withFile'
02:02:05 <dmwit> ?hoogle withFile
02:02:06 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
02:02:30 <metaperl_> dmwit from #go? :)
02:02:43 <dmwit> metaperl_: The very same. =)
02:04:38 <dmwit> ricree: Another good example is http://hackage.haskell.org/packages/archive/cairo/0.12.0/doc/html/Graphics-Rendering-Cairo.html#v:withImageSurface
02:04:39 <nda> hi
02:04:43 <dmwit> nda: howdy
02:04:59 <mreh> seeing that reactive's primitves were defined in terms of each other was rather suprising
02:04:59 <ebzzry> Hi! Is putting a space after and before a [ and ], respectively, a matter of personal taste, e.g., in list comprehensions?
02:05:18 <kmc> yes
02:05:48 <dmwit> ebzzry: yes
02:06:04 <ebzzry> OK. Thank you.
02:06:40 <shachaf> ebzzry: It's a matter of personal taste, but only one personal taste is the right one.
02:06:57 <ebzzry> OK.
02:07:19 * shachaf actually has been known to do both.
02:07:29 <ebzzry> :)
02:08:04 <ebzzry> Does the Haskell community have a recommended definitive book for the language, setting aside the standard?
02:08:06 <dmwit> So, how annoying would it be for a parser of [a,b,c] style things to allow an optional leading comma and optional trailing comma?
02:08:10 <mreh> you can break it onto multiple lines like some kind of hybrid do syntax with the return at the top
02:08:29 <dmwit> e.g. let [a], [,a], and [a,] all mean the same thing?
02:08:44 <shachaf> dmwit: Some languages do that sometimes.
02:08:45 <mreh> dmwit: some browsers do tis already for javascript
02:08:47 * hackagebot keys 2.0.1 - Keyed functors and containers  http://hackage.haskell.org/package/keys-2.0.1 (EdwardKmett)
02:08:50 <edwardk> ok, added the missing instances for NonEmpty and Tree
02:08:55 <mreh> notoriously not so in IE
02:09:06 <dmwit> I sometimes wish for it, especially in record syntax.
02:09:18 <shachaf> In fact, doesn't GHC allow it?
02:09:21 <shachaf> In module export syntax?
02:09:31 <dmwit> Yes, that's another place I wish for it.
02:09:37 <dmwit> Let me test.
02:09:39 <mreh> dmwit: so you can comment out lines with single flick of your wrist?
02:09:45 <mreh> any line
02:09:51 <shachaf> ANY LINE AT ALL.
02:10:08 <mreh> not the top line
02:10:11 <nda> @pl \(i,x) (j, y) -> (i, x + y)
02:10:12 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . const) .) . (. (+)) . (.) . (,))
02:10:12 <dmwit> seems to =)
02:10:30 <ebzzry> (I'm sorry to urgently bring it up again, but do we have one?)
02:10:38 <kmc> @type uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . const) .) . (. (+)) . (.) . (,))
02:10:39 <lambdabot> forall a a1 a2. (Num a1) => (a2, a1) -> (a, a1) -> (a2, a1)
02:10:41 <sp3ctum> what
02:10:45 <dmwit> mreh: Yes, or add a line with a flick of the wrist.
02:11:03 * shachaf 's entire project is composed of careful wrist flicks.
02:11:14 <edwardk> ok, night folks
02:11:21 <dmwit> ebzzry: RWH and LYAH are both excellent books.
02:11:32 <ebzzry> dmwit: OK
02:11:34 <dmwit> But no, nothing definitive other than the Report.
02:11:37 <shachaf> Oh, a book.
02:11:42 <ebzzry> dmwit: OK
02:11:46 <shachaf> I don't think many languages have definitive books.
02:11:51 <dmwit> yeah
02:12:10 <kmc> The C Programming Language
02:12:12 <kmc> The Camel book
02:12:26 <shachaf> There's an "official" introduction to Haskell, but it's not usually recommended.
02:12:40 <dmwit> mreh: ...even the top line; see: module Main (\nfoo,\nbar,\n) where
02:12:48 <ebzzry> shachaf: official?
02:12:52 <kmc> the Gentle Introduction is more a guided tour of the Report than a tutorial proper
02:13:10 <dmwit> ...or did you mean the "module Main (" as the top line? Then yeah, you need that one. =P
02:13:25 * dmwit recommends it every chance he gets
02:13:36 * kmc wonders if RWH is actually excellent or if everyone just says that
02:13:42 <shachaf> dmwit: Hey, dmwit, can you recommend a Haskell introduction to me?
02:13:44 <kmc> i really enjoyed the topics chapters
02:13:44 <ebzzry> Hmm. So, RWH and LYAH then.
02:13:52 <kmc> i don't know if it's good for learning the language itself
02:13:55 <dmwit> kmc: hah, good question
02:14:00 <dmwit> shachaf: I like this one:
02:14:02 <kmc> at a few points i've gotten annoyed with the evangelical tone
02:14:03 <dmwit> ?where gentle
02:14:03 <lambdabot> http://www.haskell.org/tutorial/
02:14:04 <dmwit> =)
02:14:07 <shachaf> dmwit++
02:14:19 <kmc> i think "convincing you to learn Haskell" and "teaching you Haskell" should be separate
02:15:01 <kmc> beginning Haskell is frustrating and so there's an impulse to write "noooo it's really good trust us don't leave me" after every third paragraph
02:15:09 <kmc> but, screw that
02:15:45 <dmwit> ok, bedtime
02:15:48 <dmwit> love you
02:16:52 <frerich> ebzzry: I bought RWH and it's okay, but what really got me going was just writing little 20 lines-of-code programs which do funky stuff with lists. There's really good standard support for lists and there are plenty of functions available for lists (and strings are lists!). I was able to appreciate a lot of Haskell features just by doing this. And I had some motivating successes early on, including the "I-cant-believe-how-much-of-a-good-time-Im-having"
02:16:53 <frerich>  feeling.
02:17:20 <frerich> ebzzry: That plus hanging out in here and following StackOverflow got me quite a long way. I never really got past the third chapter of RWH or so.
02:18:03 <ebzzry> Wow.
02:18:25 <ebzzry> I'd like to learn Haskell because I'm interested in the way it does things.
02:18:45 <frerich> ebzzry: In my opinion, the most important thing is fun. You get better automagically by just doing it for some time, so the expertise comes more or less for free. As long as it's fun, it's easy to motivate you to tinker around.
02:20:13 <ebzzry> I'd have to agree that I'm also motivated by fun. I've been putting off learning Haskell for five years already.
02:20:18 <frerich> ebzzry: It might be different if you have a proper math education (unlike me, I dropped out of university early without finishing my CS study) and appreciate thinks like "categories" and "arrows" and "comonads" and such things (disclaimer: I don't know whether they are math concepts)
02:20:39 <kmc> :D
02:20:40 <kmc> yep, strings are lists, which is great until you need good performance
02:20:40 <kmc> storing text in a singly-linked list of heap cells containing pointers to heap cells containing (probably) 32-bit codepoint values is kind of ridiculous
02:20:40 <kmc> then you use Data.Text instead and all is well
02:20:46 <quicksilver> I don't find appreciating those concepts mathematically makes haskell more fun.
02:21:00 <ebzzry> frerich: I'm relearning math concepts that I have previously skimmed over before.
02:21:01 <quicksilver> (it doesn't make them less fun, either - I just think it's mostly orthogonal to the fun of hacking programs)
02:21:13 <mreh> who was it that independtly implemented reactive?
02:21:14 <shachaf> quicksilver: What if you're edwardk?
02:21:18 <quicksilver> it may work the other way around, though.
02:21:24 <quicksilver> shachaf: fortunately, only one of us is.
02:21:28 <quicksilver> shachaf: and it's not me :)
02:21:34 <quicksilver> mreh: me?
02:21:38 <mreh> ah yes
02:21:38 * shachaf hopes that by "us" quicksilver doesn't mean "you and me".
02:21:40 <quicksilver> although I don't think I'm the only one.
02:21:45 <mreh> quicksilver: which bits need fixing?
02:21:57 <quicksilver> which bits of conal's implementation or which bits of mine?
02:22:15 <mreh> quicksilver: the union of those two
02:22:17 <ebzzry> Thinking in Haskell is different from thinking in Lisp.
02:22:25 <shachaf> Hmm, Cale and lambdabot timed out at the same time.
02:22:39 <shachaf> Could it be that Cale runs lambdabot in a non-screen SSH session or something like that?
02:22:45 <mreh> quicksilver: i suppose you still need someone to aggregate the working bits
02:23:06 <quicksilver> mreh: conal's implementation doesn't have a working joinE and other things which depend on that, as I recall.
02:23:16 <mreh> quicksilver: but yours does!
02:23:25 <quicksilver> mreh: my implementation has a working joinE but doesn't have quite the right guarantee on merging Futures
02:23:33 <quicksilver> there is a race where the earlier Future can win
02:23:43 <quicksilver> my implementation needs more tests :)
02:24:03 <mreh> quicksilver: conal's unearthed a GHC bug I recall
02:24:10 <quicksilver> yes, indeed.
02:24:17 <quicksilver> although only because he was doing Evil(tm) behind the scenes.
02:24:25 <quicksilver> I don't believe that amb and lub are good constructs
02:24:30 <mreh> is it your implementation of unamb that's broke?
02:24:45 <quicksilver> I don't like using blocking of evaluation to implement futures
02:24:50 <quicksilver> I don't use unamb at all
02:25:01 <quicksilver> underneath, my futures use conventional blocking IO actions
02:25:03 <kmc> ebzzry, indeed
02:25:03 <mreh> interesting
02:25:06 <quicksilver> the interface is still pure, though.
02:25:29 <quicksilver> I have some confidence in my implementation because I wrote a non-trivial demo which does several things at once and doesn't have a memory or time leak
02:25:37 <quicksilver> (then again, conal has too ;)
02:25:49 <mreh> quicksilver: you require evil to break out of the IO monad though
02:26:10 * frerich finally found quicksilver on Google+
02:26:32 <quicksilver> mreh: not at all.
02:26:43 <quicksilver> mreh: just a top level construct to "run" your reactive program
02:26:50 <mreh> quicksilver: okay
02:26:55 <quicksilver> precisely the role 'main' plays in an imperative IO program.
02:27:01 <quicksilver> I don't use any unsafePerform or unsafeInterleave
02:27:18 <nda> @pl \x y -> f (g x) (g y)
02:27:29 <mreh> quicksilver: could I attempt to fix things?
02:27:30 <quicksilver> frerich: I don't say anything on it though. Maybe one day I will ;)
02:27:40 <mreh> I was cry if I could make efficient games in haskell
02:27:46 <mreh> s/was/would
02:27:46 <quicksilver> mreh: you're most welcome. The source code is on the reactive mailing list somewhere.
02:27:54 <mreh> github?
02:28:39 <mreh> okay
02:29:04 <quicksilver> mreh: http://www.haskell.org/pipermail/reactive/2008-December/000139.html
02:29:10 <mreh> lad
02:29:40 <quicksilver> mreh: also http://www.haskell.org/pipermail/reactive/2009-March/000253.html
02:29:58 <quicksilver> I'd forgotten I'd uploaded crayon.
02:30:38 <quicksilver> there was a simpler non-GUI example too. I wonder where I sent that.
02:31:52 <mreh> cabal man! use cabal!
02:32:03 <mreh> upload that baby
02:32:10 <quicksilver> I don't know how to :)
02:32:24 <quicksilver> also the library is very unfinished and bundled with other unfinished stuff.
02:34:30 <mreh> great stuff, i'll look it over when I've got a moment
02:35:35 <TotoTitus> seen qualle
02:36:26 <eddayyy_> geekup
02:40:44 <mreh> quicksilver: just had a quick look at the archive, is your reactive impl. included?
02:40:55 <mreh> myreactive.hs :)
02:42:14 <mreh> spend 30 mins learning how to do a cabal, well worth it in my opinion
02:44:13 <lundstrj> Good morning fellow haskellers
02:44:31 <lundstrj> anyone has a take on type vs data?
02:44:46 <lundstrj> like, what is the point?
02:44:55 <lundstrj> why do we have both?
02:45:07 <mreh> types are populated by data
02:46:13 <lundstrj> mreh: and data is populated by rhinos?
02:46:38 <mreh> my troll senses are tingling
02:46:50 <lundstrj> mreh: hehe =)
02:46:58 <lundstrj> made me smile
02:47:01 <lundstrj> well done good sir
02:47:26 <lundstrj> mreh
02:47:33 <mreh> yes
02:47:45 <lundstrj> but seriously though. When should I go with a type and when should I go with data?
02:47:56 <mreh> OH, i understand what you mean
02:48:00 <mreh> the syntax
02:48:40 <mreh> type is a synonym, a short hand, it doesn't define a new type
02:48:51 <mreh> data (and newtype) define new types
02:48:54 <lundstrj> so, it's like where?
02:49:11 <lundstrj> is type sort of like where?
02:49:14 <mreh> type String = [Char]
02:49:23 <mreh> that's the most commonly used synonym I'd say
02:49:28 <mreh> it's in the prelude
02:49:54 <mreh> the compiler makes no distinction between the two, it just makes code more readable
02:50:02 <lundstrj> I see
02:50:21 <mauke> do you know C?
02:50:40 <lundstrj> mauke: I have used it. To say I know it would be an overstatement
02:52:02 <lundstrj> mreh: Okay, so they are pretty much the same. but the syntax is different
02:52:05 <ricree> you know.  I think hoogle may easily be one of my favorite things about haskell
02:52:25 <lundstrj> and code looks nicer depending on which one you use
02:53:22 <mreh> they aren't the same
02:53:36 <lundstrj> but but but but
02:53:37 <mreh> two types may infact be equal, but two types can never be equal
02:53:53 <mreh> lol
02:54:02 <lundstrj> that sounds like a contradiction from where I am sitting
02:54:03 <mreh> s/types/synonym
02:54:45 <lundstrj> so, synonyms can be equal but types can never be equal?
02:54:56 <mreh> with respect to the type checker, yes
02:55:07 <mreh> two distinct synonyms and types
02:55:08 <mreh> yes
02:55:31 <mreh> e.g. type String1 = [Char]
02:55:36 <lundstrj> hmm
02:55:48 <quicksilver> the general rule is always use data, never use type
02:56:02 <quicksilver> type is a very limited tool for introducing 'nicknames' or 'shorthands'.
02:56:16 <quicksilver> it gives you no type safety - it's probably a badly named keyword :)
02:56:22 <mauke> unless you know what you doing; take off every `zig`
02:56:41 <quicksilver> data is the powerful construct that lets you define new data types and abstract interfaces
02:57:02 <mreh> and newtype is even more amazing
02:57:08 <quicksilver> type String = [Char] is a good example of using type
02:57:16 <quicksilver> the point being, we want to continue to be able to use all list functions on the String
02:57:19 <mreh> allows you to wrap other types and make new types
02:57:23 <mreh> hence the name
02:57:28 <quicksilver> (the cost is, we get no abstraction)
02:57:58 <mreh> who came up with the sytax for "type Xyz = Abc"?
02:58:09 <mreh> it creates maximum confusions when talking about it
02:58:11 <lundstrj> fascinating
02:59:46 <mreh> putStrLn1 :: String1 -> IO () ; putStrLn1 = putStrLn -- this would be valid
03:00:26 <lundstrj> well, gentlemen/ladies, thank you for the input. I appreciate the help.
03:26:35 <ricree> btw, dmwit.  the withFoo style seems to have worked out pretty well.  Thanks again for answering my question
03:37:12 <hpaste> lewis1711 pasted “odd return messages” at http://hpaste.org/50125
03:38:02 <NihilistDandy> lewis1711: What's the odd message?
03:38:05 <lewis1711> ahem yes. when I run that function in ghci I get "Nothing" or "just $char'
03:38:31 <lewis1711> Shouldn't it just print out a char? :/
03:39:31 <NihilistDandy> Well, if it's printing Nothing then you've got a Maybe in there
03:39:41 <NihilistDandy> So it has to print Just
03:40:00 <NihilistDandy> What's the type of `valid tbl`?
03:40:10 <lewis1711> isn't that a monad? man I still don't even know what a monad is. how did this happen
03:40:25 <lewis1711> ah, maybe it's easier if I post that code as well
03:40:56 <mornfall> Anything around to portably find the name of the logged-in user?
03:41:11 <mornfall> (unix-compat seems to only give you dummies on non-POSIX...)
03:41:45 <NihilistDandy> "A monad is just a monoid in the category of endofunctors, what's the problem?"
03:41:50 <Ptival> :)
03:42:01 <hpaste> lewis1711 annotated “odd return messages” with “odd return messages (annotation)” at http://hpaste.org/50125#a50126
03:42:35 <lewis1711> NihilistDandy: endofunctors. monoids I am familiar with. but that's another kettle of fish :D
03:42:39 <Leif_Bork> Hi! Is it possible to use a let or where expression inside list comprehensions?
03:43:04 <NihilistDandy> Leif_Bork: Try it.
03:43:55 <Ptival> lewis1711: what function returns Just/Nothing?
03:44:21 <int-e> lewis1711: yep, what expression did you try when you got those Just/Nothing results?
03:44:22 <lewis1711> Ptival: lookup'. I don't understand why it if I feed it a char that's not in the table it doesn't just return that char
03:44:22 <Ptival> the ones you pasted shouldn't given their types...
03:44:42 <lewis1711> aughgh
03:44:45 <lewis1711> I used the wrong lookup
03:44:50 <NihilistDandy> Ah
03:44:52 <Ptival> yes probably :)
03:45:00 <NihilistDandy> That'd do it
03:45:10 <Leif_Bork> NihilistDandy:  Thank you! Very stupid of me.
03:45:22 <lewis1711> not the silliest question I've asked in IRC but close to it :)
03:45:24 <int-e> > lookup 'a' [('b',1)] -- this one?
03:45:35 <NihilistDandy> Leif_Bork: Nah. But as long as ghci is there, it's more fun to experiment than just to be told. :D
03:45:38 <int-e> oh, no bot.
03:45:44 <NihilistDandy> Leif_Bork: Haskell's fun, remember? :D
03:46:05 * hackagebot tkyprof 0.0.1 - A visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.0.1 (MitsutoshiAoe)
03:46:07 * hackagebot tkyprof 0.0.2 - A visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.0.2 (MitsutoshiAoe)
03:46:07 <NihilistDandy> int-e: Yep, that one
03:46:16 <NihilistDandy> lookup :: Eq a => a -> [(a, b)] -> Maybe b
03:46:29 <Ptival> NihilistDandy: but sometimes, you just don't know the right syntax to try with...
03:47:05 <NihilistDandy> Ptival: That's what experimentation's all about. It's still fun to figure out the error messages, at times. Unless you used hugs T_T
03:47:39 <Ptival> I mean, what if you try the wrong thing, then assume the feature does not exist while in fact, it existed but with a different syntax
03:47:46 <ceii> NihilistDandy, figuring out GHC parse errors is not fun at all
03:48:06 <NihilistDandy> Parse errors are boring
03:48:08 <ceii> "Parse error: possibly incorrect indentation?" ... ?
03:48:21 <NihilistDandy> ceii: What's hard to figure out about that?
03:48:33 <lewis1711> ceii: they give you a line and column number though, it's usually fairly easy to see where they are
03:48:48 <NihilistDandy> Ptival: Then you keep trying wrong things, of course
03:48:59 <NihilistDandy> Assumptions are silly
03:49:11 <ceii> NihilistDandy, actually I remember getting line numbers that were off by two screens. But maybe GHC has improved since then
03:50:05 <NihilistDandy> ceii: Yeesh, that's pretty awful.
03:50:19 <NihilistDandy> Haskell-mode has been saving me a lot of trouble on the indentation front, at least
03:51:08 <lewis1711> Haskell-mode?
03:51:44 <ceii> I think I should stop writing stuff like
03:51:48 <ceii> foo = do baz
03:51:52 <ceii>              bar
03:52:06 <NihilistDandy> lewis1711: Emacs thingy
03:52:06 <ceii> that make indentation dependent on the length of identifiers
03:52:20 <lewis1711> ah. *obligatory vim comment*
03:52:23 <ceii> but it's a hard habit to kill
03:52:36 <NihilistDandy> lewis1711: There's a haskellmode-vim, but I think it's terrible
03:52:58 <NihilistDandy> ceii: Indeed.
03:53:05 <ceii> haskellmode-vim's documentation lookup is really nice
03:53:06 <lewis1711> I haven't felt the need for a haskell mode. I just edit and and load scripts
03:53:25 <ceii> the only thing it lacks is emacs's easy autoindent
03:53:44 <NihilistDandy> ceii: Also, fontlock
03:54:19 <NihilistDandy> lewis1711: Haskell-mode + yasnippets will increase your coding pleasure :D
03:55:10 <NihilistDandy> ceii: Forgive the tiff: http://dl.dropbox.com/u/21008274/emacs.tiff
03:56:11 <ceii> I have a serious cultural problem with one character actually being two of them :)
03:56:33 <lysgaard> I unregistered a package with ghc-pkg. How do i register it again?
03:57:06 <NihilistDandy> ceii: Well, you can comment out that line
03:57:13 <NihilistDandy> In the fontlock file
03:57:35 <psysine> would for example python be less suitable to be compiled to machine code than haskell?
03:57:59 <Ptival> wow sexy lambda
03:58:05 <NihilistDandy> Ptival: I know, right?
03:58:14 <ceii> NihilistDandy, you're right.
03:58:42 <NihilistDandy> The best bit is that it doesn't actually alter the source
03:58:48 <ceii> Well, the only reason I switched to vim was because I couldn't find Haddock support for emacs.
03:58:50 <NihilistDandy> It just looks prettier while you're working on it
04:00:38 <NihilistDandy> ceii: Ah. Hmm, not sure about that in the emacs version. What sort of things can you do with the haddock access?
04:00:45 <Leif_Bork> NihilistDandy: Damn, the problem is, I don't know how to combine it with a filter, I want to filter on the variables defined using let
04:01:08 <NihilistDandy> Leif_Bork: Paste the list comprehension here
04:01:34 <NihilistDandy> ceii: I just used docidx to put together a nice index file and work with that
04:01:40 <NihilistDandy> *use
04:02:14 <ceii> oh, that's a trick I don't know
04:02:46 <NihilistDandy> Fairly new package on Hackage, though it's been on github for a while.
04:02:48 <NihilistDandy> Very slick
04:03:10 <ceii> to answer your question, vim can open the doc for an identifier or module, autocomplete from imported modules, automatically insert imports, stuff like that
04:03:24 <ceii> I'll take a look at docidx
04:03:25 <Leif_Bork> NihilistDandy: It's long, and I'm not proud of it, but this one will also not work: [y | x<-[1..10], y/=3, let y=x+1]
04:03:36 <NihilistDandy> Uses the stylesheet from Hackage for the index, lists all your installed packages (even multiple versions). :D
04:03:51 <NihilistDandy> ceii: That does sound mighty convenient
04:04:18 <ceii> Leif_Bork, you can only refer to y after it's defined, so you need two switch the last two parts
04:04:19 <NihilistDandy> Leif_Bork: What do you want the comprehension to do?
04:05:04 <NihilistDandy> ceii's right
04:05:18 <NihilistDandy> [y | x<-[1..10], let y=x+1, y /= 3]
04:07:13 <NihilistDandy> Also, filter (/= 3) [y + 1 | y <- [1..10]]
04:08:09 <Leif_Bork> ceii, NihilistDandy; Thank you!
04:08:17 <ceii> Leif_Bork, you're welcome
04:08:24 <Leif_Bork> =D
04:08:52 <NihilistDandy> No problemo
04:11:07 <NihilistDandy> I need to get better with applicative functors
04:11:28 <Entroacceptor> :t <$>
04:11:41 <shachaf> NihilistDandy: I'm so good with applicative functors, man, I can actually join them.
04:12:01 <shachaf> (And >>= them, if the lighting is right.)
04:12:13 <Leif_Bork> So the right side of a list comprehension is like do, (in newbie terminology), a bit imperative, that's why it is possible to use <- and stuff like that?
04:12:32 <shachaf> Leif_Bork: do isn't "a bit imperative".
04:12:51 <Cale> Well, it is for sufficiently general definitions of imperative :)
04:12:57 <shachaf> A list comprehension is pretty much like a particular special case of do-notation, though.
04:13:01 <ceii> Leif_Bork, that's right, they're very similar syntax.
04:13:02 <shachaf> Cale: True. Most things are.
04:13:21 <mreh> isn't it innapropriate to call anything in haskell imperative apart from IO?
04:13:29 <shachaf> > do { x <- [1..5]; y <- [2..6]; return (x,y) }
04:13:32 <mreh> even IO has laziness
04:13:35 <shachaf> Oops, no lambdabot.
04:13:36 <shachaf> Cale?
04:13:58 <shachaf> mreh: What does laziness have to do with imperativity?
04:14:06 * shachaf would call plenty of other things than IO imperative.
04:14:08 <mreh> shachaf: ordering of effects
04:14:10 <NihilistDandy> do { x <- [1..5]; y <- [2..6]; return (x,y) }
04:14:10 <NihilistDandy> [(1,2),(1,3),(1,4),(1,5),(1,6),(2,2),(2,3),(2,4),(2,5),(2,6),(3,2),(3,3),(3,4),(3,5),(3,6),(4,2),(4,3),(4,4),(4,5),(4,6),(5,2),(5,3),(5,4),(5,5),(5,6)]
04:14:14 <shachaf> The word isn't very clearly defined, though.
04:14:20 <dabblego> uh oh, not this discussion
04:14:21 <shachaf> mreh: You can order effects just fine with laziness.
04:14:31 <Cale> man, my ssh connection to lambdabot's server is slow
04:14:36 <mreh> shachaf: okay, I beleive you :)
04:14:42 <shachaf> Cale: Do you not run her in a screen session?
04:14:51 <shachaf> I noticed that you timed out the same time she did, earlier.
04:14:51 <Cale> I do
04:14:56 <Cale> oh?
04:15:01 <mreh> i would like my own personal lambdabot
04:15:04 <Cale> Well, probably that was freenode's fault.
04:15:05 <shachaf> Well, within a minute or so.
04:15:18 <ceii> mreh, you can install her locally
04:15:20 <Cale> I run lambdabot on lispy's server
04:15:22 <ceii> or you could at least
04:15:26 <shachaf> mreh: Example: [PutStr "Hello ", putStrLn "World"]
04:15:30 <shachaf> See? Ordering.
04:15:46 <mreh> :)
04:15:49 <Cale> lol
04:16:15 * shachaf is kind of serious. That's pretty much the same kind of ordering that IO has, and it has nothing to do with laziness.
04:16:33 <mreh> i actually defined something IO that behaved so unexpectedly
04:16:43 <Cale> Well, almost. IO has something a little stronger than that :)
04:16:52 <shachaf> Cale: What do you mean?
04:16:53 <mreh> it was a putStr following a read, and the output didn't show until after the user pressed return
04:17:02 <NihilistDandy> mreh: Got get one, then
04:17:08 <shachaf> mreh: That's a buffering issue, probably.
04:17:11 <function_Al> hi there, I'm new to monadic IO, but have to modify a program. At a certain point I  realise that something went wrong so would like to do an action at a completely other place of the program . How can I do this? How can I make the connection?
04:17:13 <shachaf> You'll get that in a C program too. :-)
04:17:19 <Cale> Well, it lets you make the tail of the "list" depend on the results of earlier actions.
04:17:25 <shachaf> Cale: Oh, well, sure.
04:17:28 <mreh> shachaf: a OS issue?
04:17:39 <shachaf> And it uses continuations rather than just a list because of that.
04:17:40 <ceii> shachaf, but if every IO primitive was wrapped in unsafeInterleaveIO, the IO monad's ordering wouldn't be useful at all would it?
04:17:52 <Cale> function_Al: ummm... not sure that I understand
04:18:02 <shachaf> mreh: FSVO "issue"
04:18:38 <NihilistDandy> function_Al: Maybe you want bracketOnError?
04:18:44 <shachaf> ceii: And if GHC was actually a COBOL compiler, your program wouldn't compile at all.
04:18:47 <shachaf> (I hope.)
04:18:58 <mreh> i'm hoping it's not an issue of abstraction leak
04:19:03 * shachaf isn't sure how unsafeInterleaveIO got into it.
04:19:11 <NihilistDandy> shachaf: You don't write all your Haskell in COBOL? How do you get anything done?
04:19:45 <shachaf> NihilistDandy: That must be the trick.
04:20:03 <ceii> shachaf: I was trying to ergue that lazyness does have some relation to ordering, since unsefaInterleaveIO introduces lazyness in the IO DSL itself.
04:20:08 <ceii> argue*
04:20:29 <ceii> also, unsafe*. man...
04:20:40 <shachaf> ceii: Of course laziness has to do with *evaluation* order; but the point of the IO type is that evaluation order is distinct from execution order.
04:20:50 <ceii> shachaf, right.
04:21:00 <shachaf> You're describing some IO action which is just a static value.
04:21:05 <Cale> function_Al: could you elaborate on your question?
04:22:26 <mreh> aw, putStr buffers output...
04:22:43 <shachaf> mreh: No, your OS does.
04:22:48 <ceii> function_Al, do you think you could paste a code sample to hpaste.org? that's make things faster.
04:22:51 <Cale> mreh: hSetBuffering stdout NoBuffering
04:23:06 <mreh> which one is it?
04:23:13 <mreh> guys? :)
04:23:45 <Cale> ?
04:23:49 <ceii> mreh: buffering is a property of file descriptors, not operations like putStr
04:24:02 <Peaker> hmm...   newtype X = X <-- "warning: unused type X, unused data constructor X".   newtype X = X deriving (Show)  <-- no warning!
04:24:27 <ceii> stdout is opened with no buffering in GHCi, but in GHC compiled programs it defaults to block buffering (I think)
04:24:51 <Cale> Though GHC Handles are not quite the same thing as file descriptors
04:25:00 <Peaker> Ok, I finally understand how generalized new type deriving breaks stuff.. it appears to be related to deriving of MTPC's only
04:25:05 <shachaf> GHC Handles are much more complicated than I expected.
04:25:12 <shachaf> I thought they'd just be a newtype over Int or something.
04:25:52 <ceii> actually, what happens to buffering for handles don't wrap an OS file descriptor? Is that handled on the Haskelll side?
04:25:53 <mreh> i expected them to be full of bacon
04:26:20 <shachaf> ceii: What sorts of handles?
04:26:23 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.0.0/src/GHC-IO-Handle-Types.html#Handle
04:26:51 <Peaker> Why does generalized newtype deriving allow deriving of a partially-applied type-class?  I think it is not legitimate given that you can have instances that relate the type variable arguments of the class
04:26:53 <Cale> In particular, check out that Handle__ type :)
04:27:06 <ceii> Cale, thanks :)
04:27:39 <Cale> GHC does its own buffering to some extent
04:28:10 <shachaf> Cale: It's lovely.
04:28:17 <mreh> Cale: can I guarantee no buffering with that IO call above?
04:28:18 <Cale> and mostly asynchronous I/O operations at a low leve
04:28:19 <Cale> l
04:28:23 <shachaf> Oh, :i in ghci is displaying it as a GADT.
04:28:28 <ClaudiusMaximus> ghc compiled programs seem to default stdout to different buffering depending if the output is a terminal or otherwise (which is a bit annoying if you want to pipe output through 'ts' or similar)
04:28:30 <Cale> mreh: yeah
04:28:34 <mreh> cool
04:28:44 <shachaf> For some reason it's stripping off the record identifiers in the GADT, too.
04:29:03 <Cale> shachaf: wat
04:29:38 <Cale> oh, Handle__ ?
04:29:44 <shachaf> Yes.
04:30:11 <Cale> interesting
04:30:32 <Cale> Maybe they auto-convert existentials to GADTs now, but that's bad for prettyprinting.
04:30:43 <shachaf> It's horrible for prettyprinting.
04:31:02 <Cale> It totally breaks the prettyprinter here
04:31:03 <hpaste> anonymous pasted “:i Handle__” at http://hpaste.org/50129
04:31:20 <shachaf> Yep.
04:31:36 <cheater_> cale: i still wish functions in haskell had docstrings
04:32:00 <Cale> another thing which really annoys me about both GHC and Haddock is that they both elide parens around infix type operators in cases where they're used as a parameter
04:32:03 <shachaf> By the way, !-annotations for GADTs are another inconsistency between GADT syntax and normal type syntax.
04:32:14 <Cale> which means that Event (~>) a shows up as Event ~> a
04:32:23 <shachaf> Ugh.
04:32:34 * shachaf wonders if it's doing the GADT thing because it's an existential type.
04:33:16 <Cale> cheater_: Well, there's Haddock...
04:33:29 <cheater_> cale: i can't haddock from inside my interpreter
04:33:31 <cheater_> that's pretty bad
04:33:38 <shachaf> You can add a :-command for it, maybe.
04:33:51 <shachaf> But, yes, it would be nice if it was accessible somehow.
04:34:04 <cheater_> i usually write my code inside an interpreter, for any language i code for
04:34:07 * shachaf still wonders what a nice GADT syntax would be.
04:34:19 <ricree> with FFI.  how does one convert between haskell and c types.  Like, from Foreign.C.CDouble to the haskell Double
04:34:27 <Cale> cheater_: That's not really how GHCi is supposed to be used
04:34:35 <Cale> cheater_: You'll find it really hard.
04:34:38 <cheater_> Cale, why not
04:34:39 <shachaf> UNSAFECOERCE
04:34:49 <ceii> shachaf, argh
04:35:09 <cheater_> when you want to experiment a little bit what's better than to load up the interpreter, open up your module, and experiment with what it does for different inputs?
04:35:12 <cheater_> that's the best way there is
04:35:26 <Peaker> hmm.. ok the generalized newtype deriving problem has nothing to do with mptc...
04:35:29 <Cale> Oh, sure, but you have a module then
04:35:52 <cheater_> yeah sure
04:35:52 <Cale> which means that to edit your code, you'll open up a texteditor alongside GHCi, which is what you're supposed to do :)
04:35:53 <ceii> ricree, it depends on the type in question. For Doubles, you want realToFrac.
04:35:59 <cheater_> yeah
04:36:15 <cheater_> but when i figure out what i'm supposed to type into the text editor, i often experiment in the interpreter
04:36:26 <ricree> thank you ceii
04:36:32 <cheater_> and often i forget what library functions work like
04:36:40 <shachaf> ceii: Doesn't that go through toRational?
04:36:40 <cheater_> so in python if i forget that i can do help(modulename)
04:36:42 <shachaf> @src realToFrac
04:36:43 <lambdabot> realToFrac = fromRational . toRational
04:36:44 <NihilistDandy> cheater_: Use GOA
04:36:55 <shachaf> I doubt you want realToFrac for converting a newtype.
04:36:57 <cheater_> or even python -c "help(str.endswith)" and that works great
04:37:08 <cheater_> NihilistDandy, as in goa trance?
04:37:17 <NihilistDandy> cheater_: As in GHCi on Acid
04:37:22 <cheater_> what's that
04:37:27 <ceii> same here, I often use GHCi to explore libraries. I really wish I could just type :doc fooBar and get a pretty-printed haddock
04:37:28 <NihilistDandy> It's lambdabot, but in GHCi
04:37:40 <NihilistDandy> So you can :src and :hoogel and so on
04:37:42 <Cale> cheater_: If you set up cabal to generate documentation, you can get an HTML index of all installed packages.
04:37:42 <shachaf> lambdabot doesn't do :doc either.
04:37:44 <NihilistDandy> *hoogle
04:37:47 <shachaf> And :src is a big hack.
04:38:07 <NihilistDandy> cheater_: Also, look into docid
04:38:08 <NihilistDandy> cheater_: Also, look into docidx
04:38:11 <NihilistDandy> *
04:38:48 <cheater_> Cale, i want something that will (without delays associated with internet access) display the needed information in less
04:39:03 <cheater_> i often work with broken internet access or none at all
04:39:10 <cheater_> i can't do this webapp thing
04:39:13 <Cale> It's locally generated
04:39:25 <NihilistDandy> ^^
04:39:29 <profmakx> heya. is there an elegant way to apply a pair of functions to a pair of values? (i might also just want to rewrite my code, but just in case)
04:39:31 <Cale> There's no internet required (except to get your cabal packages in the first place)
04:39:35 * shachaf >>= sleep
04:39:39 <cheater_> bye shachaf
04:39:42 <NihilistDandy> And docisx will create a global index, which is pretty nice
04:39:44 * shachaf return
04:39:46 <NihilistDandy> *docidx
04:39:47 * shachaf >>= undefined
04:39:52 <NihilistDandy> jesus, my typing
04:39:54 <Cale> profmakx: f *** g
04:39:56 <mreh> :t (***)
04:39:57 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
04:41:00 <mreh> > :t (+1) *** id
04:41:01 <lambdabot>   <no location info>: parse error on input `:'
04:41:04 <mreh> :t (+1) *** id
04:41:05 <lambdabot> forall b b'. (Num b) => (b, b') -> (b, b')
04:41:06 <ceii> I'd written a small client/daemon thing that would keep a Haddock index in memory, so you could query like "hsdoc show map" and it'd open map's doc in a browser.
04:41:19 <mreh> profmakx: like that
04:41:33 <ceii> but I lost it when my last netbook broke down (backups dammit)
04:41:54 <ceii> well, it was 4 hour's work, so
04:41:59 <mreh> ceii: backuppc saved my bacon before
04:41:59 <ceii> hours'*
04:42:08 <hpaste> Cale pasted “bash commands” at http://hpaste.org/50130
04:42:22 <profmakx> i was looking for the type (t->t1, t2->t3) -> (t,t2) -> (t1,t3) but i think the arrow stuff + (un)curry does it
04:42:27 <Cale> ^^ those are also kinda useful (if somewhat imprecise)
04:42:31 <Kaidelong> :t let f = (+1) in f *** f
04:42:31 <lambdabot> forall b b'. (Num b', Num b) => (b, b') -> (b, b')
04:43:22 <Cale> Especially if you're working on a large project and you don't know where things are yet.
04:43:53 <Peaker> Is nobody here worried about generalized newtype deriving breaking Haskell, at all? :-)
04:44:04 <Cale> Peaker: what?
04:44:22 <Peaker> Cale: http://www.haskell.org/pipermail/haskell-cafe/2010-March/074305.html
04:44:31 <frerich> NihilistDandy : http://dl.dropbox.com/u/21008274/emacs.tiff looks very nice
04:44:39 <cheater_> Cale, that's just a ctags clone :)
04:44:45 <Peaker> Cale: you can use it to subvert the invariant of a Set/Map, for example
04:45:02 <NihilistDandy> frerich: It is. Twilight color-theme, too, because it's the best theme
04:45:14 <NihilistDandy> I've used it in every editor that's supported it
04:45:14 <cheater_> Cale, but trust me, if ghci could get python's help() it would be a MILLION times easier to use for newcomers
04:45:25 <cheater_> let me try out GOA btw
04:45:46 <mux> I've never even used python's help()
04:45:49 <frerich> NihilistDandy : That's emacs? Makes me wonder whether this nice display of arrows and lambda and () is possible with gvim, too
04:45:51 <Kaidelong> not sure how useful help() would be for most haskell functions
04:46:03 <mux> I doubt it will be of much help to most, if not all, haskell programmers
04:46:13 <NihilistDandy> cheater_: Make sure to check the wiki. It tells you how to set up the necessary commands
04:46:19 <Kaidelong> a lot of them are hard to explain to people who need it explained to them
04:46:20 <Kaidelong> like (.)
04:46:21 <Peaker> Cale: my first reaction to that was: "Hey, it must be due to the MPTC" (instance a a  is circumvented to mean   instance a b), but then I realized you can just fix the "a" to any type and get the same problem (for a specific type)
04:46:55 <cheater_> NihilistDandy, i'm looking at: http://www.haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
04:47:04 <cheater_> but.. that's not it either :'(
04:47:04 <NihilistDandy> cheater_: Good :D
04:47:08 <NihilistDandy> What?
04:47:26 <cheater_> well it just doesn't do what i need
04:47:39 <NihilistDandy> What sort of output does python's help thingy give you?
04:48:06 <cheater_> are you on an unix?
04:48:11 <NihilistDandy> Yeah
04:48:17 <cheater_> start python with "python"
04:48:20 <cheater_> then type in help(str)
04:48:59 <Peaker> Cale: http://hackage.haskell.org/trac/ghc/ticket/1496 <-- see the Down example on how to subvert the invariant ordering guarantee of a Set using generalized newtype-deriving
04:49:10 <ceii> cheater_: I want that!
04:49:13 <NihilistDandy> cheater_: o_o
04:49:13 <ceii> :)
04:49:15 <NihilistDandy> That's kinda awful
04:49:20 <NihilistDandy> Like, I don't like it
04:49:27 <cheater_> why is it awful
04:49:37 <mux> python associates documentation strings to classes, methods, etc
04:49:42 <cheater_> you got a less listing of info about the str class, right?
04:49:49 <NihilistDandy> yes
04:49:52 <mux> AFAIU, help() mostly digs this doc string out and displays it.
04:49:57 <cheater_> what's bad about it?
04:50:02 <mux> it's not bad per se
04:50:06 <NihilistDandy> And digging through less pages is awful for getting work done
04:50:17 <cheater_> NihilistDandy, no it's perfect for me
04:50:24 <mux> it's a lot less interesting for Haskell though, I think; most of the time a type signature is enough documentation in Haskell
04:50:39 <mux> and when it isn't, you'll have troubles writing a short and intelligible explanation of, say, >>=
04:50:54 <cheater_> if i'm looking for e.g. the endswith method of a string
04:50:58 <cheater_> and i don't remember what it's called
04:51:06 <cheater_> i'll go to the interpreter, and type in dir(str)
04:51:13 <cheater_> it shows me all methods of str.
04:51:20 <mux> you can type :browser <module> in Haskell
04:51:22 <cheater_> then i'll see "aha, endswith.. i forgot how to call that"
04:51:29 <cheater_> then i do help(str.endswith)
04:51:31 <ceii> mux: but that means you start exploring libraries with just :browse and :i in ghci, and then when that's not enough you need to move to a browser and dig through the Haddock.
04:51:34 <mux> and you'll get the types, type classes, instances and functions defined by the module
04:51:35 <cheater_> and i get info for that thing
04:51:43 <ceii> I find that's a (minor) annoyance
04:51:44 <cheater_> mux: yeah, that's cool
04:51:46 <mux> ceii: yep, but you meant to tell this to cheater_
04:52:11 <cheater_> i'm just explaining my workflow which i repeat at least a million times a day
04:52:19 <cheater_> the time saved is really substantial
04:52:19 <NihilistDandy> mux: That's neat. I didn't know about that
04:52:28 <ceii> mux: no, I meant that as an answer to "type signatures are enough"
04:52:35 <cheater_> the convenience saves a lot of energy which i can put into actually doing my work
04:52:42 <NihilistDandy> ceii: Then there's GOA
04:52:51 <mux> ceii: please don't omit the "most of the time" bit
04:52:51 <cheater_> mux: type signatures are not enough. i can't ever understand stuff from type signatures.
04:52:57 <mux> cheater_: please don't, either.
04:53:02 <dabblego> @hoogle Eq a => [a] -> [a] -> Bool
04:53:03 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
04:53:03 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
04:53:03 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
04:53:13 <cheater_> mux: it's not even "some of the time" for me
04:53:13 <mux> hayoo and hoogle are fine when they're not enough
04:53:17 <dabblego> cheater_: you should cheat more often by using hoogle
04:53:21 <mux> and usually, haddock generated documentation is good
04:53:29 <mux> cheater_: that's only because you're starting with haskell
04:53:38 <mux> so go use hayoo and hoogle :-)
04:53:50 <cheater_> mux: and the tool i'm asking for is for people who are starting with haskell
04:53:53 <NihilistDandy> Or just learn more about interpreting type signatures
04:53:59 <cheater_> mux: i know i can use those two. but they're very inconvenient to use.
04:54:11 <dabblego> or perhaps force yourself to write your code in a way that you can utilise hayoo/hoogle, since you'll get better code as a result anyway
04:54:16 <cheater_> NihilistDandy, that's not a practical suggestion
04:54:16 <Cale> Peaker: that seems somewhat easily fixed by just checking that the instances can actually be written and then throwing away the generated code
04:54:27 <mux> cheater_: just because you're used to python and the way thigns are done there doesn't mean the ideas apply as successfully to haskell
04:54:29 <dabblego> why is learning about types not a practical suggestion?
04:54:33 <Cale> Peaker: but yeah, it probably should carry some more restrictions
04:54:36 <Peaker> Cale: Yeah, I thought about that too -- you have to actually try to copy the implementation
04:54:36 <cheater_> dabblego, not everyone is writing "hello world". not all code i use will have been written by me
04:54:42 <cheater_> dabblego, you can't just say "go learn"
04:54:51 <dabblego> cheater_: that's interesting, but I'm not sure why you said it
04:54:52 <NihilistDandy> cheater_: That's what #python says
04:54:53 <cheater_> there's a thing called the "learning process"
04:55:04 <Peaker> Cale: it's nicer to be able to just verify the types though
04:55:08 <cheater_> NihilistDandy, #python is full of trolls
04:55:13 <Cale> Learning to interpret type signatures is one of the first things you should be doing :)
04:55:17 <dabblego> cheater_: well, as it happens, I "lobby" two universities to teach more about types in their undergraduate course -- so I don't see why not
04:55:17 <cheater_> and google employees
04:55:32 <dabblego> yes I know about "the learning process", I studied psych
04:55:38 <cheater_> dabblego, i'm not in your university. none of your suggestions applies to me
04:55:48 <Cale> Peaker: There's probably some expressible restriction on the types and classes involved
04:56:03 <dabblego> cheater_: I am asking you to convince me why my lobbying may be futile, since it appears that "learning about types" is extremely important and certainly practical
04:56:08 <NihilistDandy> Learning Haskell without learning about types is like learning C without learning about pointer arithmetic
04:56:15 <NihilistDandy> Or something equally bizarre
04:56:18 <cheater_> if i want to write a piece of code that does something specific, i can't just take out two weeks to "go and learn about type signatures". proper documentation cannot, and never will be, replaced by understanding type signatures.
04:56:30 <Peaker> Cale: I think SPJ is saying the solution of differentiating TypeParam=*->* (e.g: IO or [])  from TypeFunc=*=>*  (Map or Set)  and treating   TypeParam a ~ TypeParam (newtype of a)   but TypeFunc a /~ TypEFunc (newtype of a)
04:56:45 <dabblego> NihilistDandy: it's worse than that
04:56:48 <Peaker> Cale: not sure how you you get Set and Map to be marked as TypeFunc rather than TypeParam though
04:56:54 <mux> cheater_: seriously, give the #haskell community some credit before bashing our suggestions :-) you might find out that it's rather helpful
04:57:01 <NihilistDandy> dabblego: True, but I couldn't think of a parallel in C.
04:57:23 <dabblego> NihilistDandy: typing random code until it compiles
04:57:23 <cheater_> NihilistDandy, i'm not saying i don't want to learn about types, i'm just saying that i'm not experienced enough, and won't be for a long time, during which this sort of approach disables me from actually getting any work done
04:57:24 <cheater_> it's a huge problem.
04:57:32 <NihilistDandy> dabblego: Isn't that called Java?
04:57:40 <dabblego> NihilistDandy: C, Java, same same
04:57:41 <Cale> Peaker: Probably based on the structure of the data constructors.
04:57:53 <Cale> hmm
04:58:02 <dabblego> cheater_: you could do it incrementally, since you're not going to get much done if you don't learn about types anyway
04:58:06 <Cale> Though yeah, why [] and not Set is tricky :)
04:58:15 <ceii> cheater_: well, from a practical perspective reading the HTML doc isn't that awful, even if it's a different workflow
04:58:20 <NihilistDandy> cheater_: I've been using Haskell in a way that could barely be called regular for less than two months, and vaguely following this channel since the spring
04:58:31 <NihilistDandy> It doesn't take long to learn what you must know about types
04:58:39 <Peaker> Cale: Well, the difference is in the invariants -- and those only apply to the functions, not the data declaration itself -- maybe the distinction should be abstract vs concrete type (exposed constructors)
04:58:54 <Cale> Peaker: yes, that's certainly part of it
04:59:01 <cheater_> ceii, it's terrible because 1. browsers are slow 2. searching in html is terrible (grep results in html are useless) 3. i often don't have internet access.
04:59:02 <Cale> hmm
04:59:24 <NihilistDandy> cheater_: Did you miss "haddock docs are local"?
04:59:37 <dabblego> cheater_: hoogle installs as a shell command
04:59:46 <dabblego> $ which hoogle
04:59:47 <dabblego> /home/tmorris/.cabal/bin/hoogle
04:59:48 <mux> cabal haddock
04:59:52 <hpc> you also have the source code of all your packages
04:59:53 <NihilistDandy> And build the databases locally
04:59:57 <NihilistDandy> *builds
04:59:58 <ceii> cheater_: 1. is solved with a fast, minimal browser (I use conqueror), 3. is void because cabal installs local documentation for all your packages
05:00:06 <hpc> and parts of GHC even, i think?
05:00:22 <cheater_> NihilistDandy, i said i don't have internet access because searching a website with google is one way of solving 2. but that solution does nto apply to me.
05:00:22 <Cale> Peaker: OH, Functor instance
05:00:39 <cheater_> dabblego, what does that shell command give me?
05:00:47 <Peaker> Cale: But Down has a Functor instance -- the problem is that the deriving inherits the "id" implementation rather than the "fmap Down" implementation
05:00:55 <dabblego> cheater_: the ability to search by type
05:01:03 <dabblego> @hoogle Eq a => [a] -> [a] -> Bool
05:01:03 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
05:01:04 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
05:01:04 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
05:01:05 <dabblego> like this
05:01:07 <Peaker> Cale: fmap Down is "id" representation-wise, but "fmap" is not "id" in the Set/Map case
05:01:19 <Peaker> s/fmap Down/Down
05:01:33 <cheater_> searching by type isn't very useful if i'm looking for one of a billion ways of manipulating a string, for example.
05:01:45 <NihilistDandy> cheater_: It is if you know about types
05:02:05 <ceii> cheater_, but in this case reading the doc for Data.String is a good starting point
05:02:07 <NihilistDandy> Describe a string manipulation, we'll describe the type
05:02:13 <dabblego> cheater_: when you say "manipulating strings", do you mean in the way you said earlier (is it a suffix?), for which hoogle responded with 3 answers?
05:02:14 <Cale> Peaker: no, the problem is that 'item' in the type of conv doesn't have a Functor constraint, so it should refuse to generate the instance
05:02:20 <cheater_> ok so i'm looking for a function that makes my snake_case string camelCase. how do i search for it?
05:02:38 <cheater_> assuming there's a library somewhere that does that
05:03:10 <Cale> cheater_: There isn't in the standard libraries
05:03:28 <Cale> search on hackage, I guess?
05:03:35 <NihilistDandy> Well, String -> String would be your type signature
05:03:38 <Cale> Though I doubt anyone would have packaged something like that
05:03:44 <Peaker> Cale: Or a contra-functor constraint
05:03:47 <NihilistDandy> @hoogle camelcase
05:03:47 <lambdabot> No results found
05:03:48 <Peaker> Cale: seems a bit arbitrary..
05:03:51 <cheater_> yes go on NihilistDandy
05:03:59 <cheater_> so i search for String -> String
05:03:59 <Cale> You can do it easily using the stuff in the split package
05:04:06 <NihilistDandy> @hoogle String -> String
05:04:06 <lambdabot> Network.URI normalizeCase :: String -> String
05:04:06 <lambdabot> Network.URI normalizeEscape :: String -> String
05:04:07 <lambdabot> Network.URI normalizePathSegments :: String -> String
05:04:13 <cheater_> @hoogle String -> String
05:04:14 <lambdabot> Network.URI normalizeCase :: String -> String
05:04:14 <lambdabot> Network.URI normalizeEscape :: String -> String
05:04:14 <lambdabot> Network.URI normalizePathSegments :: String -> String
05:04:28 <NihilistDandy> @src Network.URI.normalizeCase
05:04:29 <lambdabot> Source not found. Take a stress pill and think things over.
05:04:29 <cheater_> ok, now how do i know what normalizeEscape does?
05:04:41 <NihilistDandy> @src normalizeEscape
05:04:42 <lambdabot> Source not found. My brain just exploded
05:04:43 <Peaker> Cale: also, in the conceivable case GHC is extended to handle a Functor instance for Set...
05:04:54 <cheater_> see
05:04:59 <cheater_> that's you hitting a brick wall
05:05:05 <NihilistDandy> cheater_: No, it's not
05:05:09 <Cale> http://www.haskell.org/hoogle/?hoogle=String+-%3E+String
05:05:09 <Peaker> (Using a restriction on the type parameter of the functor..)
05:05:16 <cheater_> well it's me hitting a brick wall
05:05:18 <cheater_> ok cale wait
05:05:19 <Cale> you click on it to see the documentation
05:05:20 <Peaker> well, I guess maybe that's not conceivable.. :)
05:05:23 <Cale> Encoding normalization; cf. RFC3986 section 6.2.2.2
05:05:27 <cheater_> look, i am clicking on the url... now
05:05:29 <Cale> and then you look up the RFC
05:05:47 <Cale> or you realise that it's in Network.URI and so probably isn't what you're looking for :P
05:05:50 <ceii> cheater_, if I understand correctly you'd like to just type help(String) and get a list of all the string manipulating functions?
05:05:51 <Peaker> I agree with cheater_ that "help" would be nice -- haddock is nice, types are awesome.. But "help" would be nice too
05:05:56 <cheater_> ok and NOW
05:06:04 <cheater_> i can see what normalizeEscape does
05:06:14 <cheater_> that took me what, 30 seconds to get my information
05:06:21 <Peaker> ceii: I think help(x) should generally pull the docstring an author explicitly associated with x
05:06:21 <dabblego> I'd prefer to just see the QC tests to determine that
05:06:21 <Cale> http://hackage.haskell.org/packages/archive/network/latest/doc/html/src/Network-URI.html#normalizeEscape
05:06:28 <NihilistDandy> cheater_: You can also just go to your haddock index and click "Network.URI"
05:06:30 <cheater_> which in at least two other languages is accessible immediately
05:06:30 <Cale> It took me about 10 seconds
05:06:45 <cheater_> NihilistDandy, do you know why some people despise using the mouse?
05:06:48 <dabblego> cheater_: if you think other languages do this better, then you're kidding yourself
05:06:50 <Peaker> NihilistDandy: that takes more time than staying in the same interactive context and using help(x)
05:06:55 <NihilistDandy> cheater_: I didn't use the mouse
05:07:03 <ceii> cheater_, no, information on non-installed packages isn't available instantly in any language I know.
05:07:08 <dabblego> cheater_: I certainly don't use the mouse, because I use xmonad
05:07:30 <Cale> What are you trying to do? Decide what normalizeEscape does, or decide that it doesn't do the thing you want? I think that it should be kinda obvious that it's at least probably not the thing you want.
05:07:31 <NihilistDandy> cheater_: Anyway, if you'd like this functionality and you find it lacking, why not write a module?
05:07:38 <Peaker> dabblego, NihilistDandy, ceii: Are you claiming docstrings that are instantly accessible in the context of the interactive shell are not a useful thing?
05:07:42 <cheater_> NihilistDandy, how would i do that?
05:07:50 <cheater_> i wouldn't know where to start
05:07:54 <dabblego> Peaker: no
05:08:05 <NihilistDandy> cheater_: Well, thinking is a good first step
05:08:07 <NihilistDandy> Whiteboards help
05:08:15 <ceii> Peaker, I'm definitely not. I was arguing that haing a :doc command in GHCi would be awesome, but then I got sidetracked.
05:08:21 <Cale> Peaker: Having access to haddock from GHCi would be useful, but not useful enough that I'd go to the trouble of implementing it myself.
05:08:21 <ceii> havong*
05:08:25 <ceii> HAVING*
05:08:25 <Peaker> ceii: then what's the argument?
05:08:44 <Peaker> cheater_: aren't you essentially arguing for :doc?
05:08:48 <NihilistDandy> Peaker: I believe it's "types aren't enough"
05:09:05 <Peaker> NihilistDandy: of course types aren't enough.. why else would we have documentation?
05:09:07 <ceii> Peaker, the argument is that someone said "all you need is the type signatures"
05:09:18 <cheater_> Peaker, i think :doc just gives you a link to hoogle or something, right?
05:09:20 <Peaker> All you need is a "C>" prompt
05:09:24 <Cale> Often that's true. It's not true in the case of String -> String functions.
05:09:33 <dabblego> Peaker: Using the type by default usually gets you as far as you need to go. This is usually because of the method of code structuring e.g. parametricity. When it doesn't, I would like to see QC tests or perhaps also the docstring. At least, haskell is way ahead of other languages in this regard.
05:09:38 <Peaker> cheater_: :doc is a hypothetical feature :)
05:09:44 <Cale> But those are almost a special case.
05:09:47 <cheater_> Peaker, then yes, i am arguing for that.
05:09:58 <Cale> (along with things like Num a => a -> a)
05:10:01 <Peaker> dabblego: sure, types are awesome.. but instant-accessible doc would be great too
05:10:25 <dabblego> Peaker: right, haskell completely shits on second-place, but it's not an excuse to sit back -- I agree on that
05:10:39 <Cale> Types of things in well-written libraries will usually tell you quite a lot about what they do.
05:10:46 <cheater_> types are just documentation, they're accessible from within the interpreter, i don't see why the rest of documentation shouldn't be
05:11:04 <Peaker> Cale: I don't think anyone is arguing that what Haskell has sucks -- only that what it doesn't have is also great
05:11:15 <dabblego> cheater_: it's not anywhere near as useful, and may even be an impediment
05:11:25 <Cale> Well, this isn't a Haskell thing, it's a GHCi thing.
05:11:27 <companion_cube> ghci is great
05:11:43 <ceii> but then there are the badly-written ones (e.g. C lib wrappers), and the type-hacky ones where people don't expect you to try and write type signatures when you use them
05:11:43 <cheater_> dabblego, ok, if you don't like it, then don't use it and that's a great way to spend your life too.
05:11:47 <companion_cube> ipython too, but ghci still is one of the best repl
05:11:50 <Peaker> cheater_: Types are accessible because they're needed for the type-safety implementation anyway, and docs aren't.. so it's more of an implementation convenience thing.. Just like the reason ghci cannot declare types
05:11:55 <Cale> I'm sure someone could implement this pretty easily.
05:12:00 <dabblego> cheater_: it's not that I don't like it. It's the extent to which it provides utility
05:12:04 <cheater_> Peaker, yeah
05:12:09 <Peaker> dabblego: How are instantly-accessible docs an impediment?
05:12:34 <dabblego> Peaker: > :type id; {- formats your hard disk -} forall a. a -> a
05:12:37 <NihilistDandy> Peaker: Feature creep
05:12:38 <cheater_> dabblego, it provides no utility for you. we have understood it the 10th time you've reiterated that. saying "it's useless for me" is not part of a constructive conversation, though.
05:13:00 <dabblego> cheater_: I am talking about providing utility independently of you and I
05:13:17 <Peaker> dabblego: bad documentation is bad, not the feature that allows its presentation..  you can have bad types too:  f :: (a -> b) -> Maybe a -> Maybe b ; f = const . const $ Nothing
05:13:34 <cheater_> utility os directly related to the person using it. i'm not going to get into an argument over whose way of doing work is better. if you want that try #php
05:13:39 <dabblego> Peaker: right, but in this case, there is no useful documentation to put there, since the type says it all
05:14:02 <Peaker> dabblego: It doesn't say it all..    Look at the type of    trace "hello world"
05:14:26 <cheater_> Peaker, dabblego is bent on tearing this down, don't lose your time
05:14:27 <dabblego> Peaker: {- this function's type doesn't use any lies -}
05:14:34 <dabblego> how about that then?
05:14:46 <cheater_> NihilistDandy, how would you write a module which provides such a functionality?
05:14:51 <Peaker> dabblego: Sure, perhaps that's the default and you might look at the doc to see if it does lie
05:15:04 <cheater_> NihilistDandy, i understand the hoogle docs are automatically generated.. how does this happen?
05:15:05 <dabblego> Peaker: right, of course it is the default, hence there is nothing to put there, sincethe type says it all
05:15:32 <ceii> this is my first time seeing an actual argument on #haskell. I'm a little bit moved.
05:15:41 <Peaker> dabblego: also, id and const are the exception, not the rule -- there's often one sensible way to implement something, but also different (less sensible) choices. Also, sometimes you can *figure out* something from the type, but it's nice to have it spelled out to reduce cognitive load of a new API
05:15:46 <NihilistDandy> cheater_: Not really sure. I'd probably dig into the GHCi sources and see how the other commands are implemented. Or I might just hack together a script in something else to reference the docs and just call out to it from ghci
05:16:07 <dabblego> Peaker: right, so what should we about those other cases?
05:16:10 <Peaker> dabblego: Also, there's a whole eco system of useful code in IO and such where the type is as useless as in other languages
05:16:12 <cheater_> NihilistDandy, do you know how GOA implements its things?
05:16:23 <NihilistDandy> It loads lambdabot
05:16:26 <Peaker> dabblego: we spell out the meaning in the documentation
05:16:33 <dabblego> Peaker: you seem to think I am disagreeing, I am not, merely pointing out the relative lack of utility
05:16:34 <cheater_> hm.
05:16:46 <dabblego> Peaker: I would prefer QC tests, machine-checked at least
05:16:51 <Peaker> dabblego: Consider the utility in IO-heavy stuff
05:17:00 <Peaker> dabblego: non-pure code in general
05:17:01 <dabblego> Peaker: right, I can see it there
05:17:01 <Cale> http://hackage.haskell.org/packages/archive/haddock/2.9.2/doc/html/Documentation-Haddock.html
05:17:08 <dabblego> Peaker: haskell doesn't have non-pure code
05:17:19 <Peaker> dabblego: Well, effectful code
05:17:28 <dabblego> let's just stick with IO
05:17:29 <Cale> ^^ that, along with some stuff from the Cabal library to look up the relevant .haddock files will get you most of the way there
05:17:42 <dabblego> where the type says "whatever goes dude!"
05:18:07 <Peaker> dabblego: Even without IO, Haskell types don't tell you much about partiality, resource use, strictness, etc.
05:18:18 <Peaker> dabblego: there's plenty of usefulness in accessible documentation..
05:18:24 <dabblego> Peaker: sure, but I would need convincing that "English" is the right answer to that
05:19:58 <Peaker> dabblego: it's a better answer than no answer
05:20:04 <mreh> do I have to compose types to make an applicative type wrapper?
05:20:14 <Cale> http://trac.haskell.org/haddock/attachment/ticket/157/haddock-index.hs
05:20:17 <Peaker> dabblego: I agree more meaningful types would be great.. but until they exist, the documentation can fill the gap (somewhat poorly)
05:20:21 <mreh> seeing as it wants a type of kind * -> *
05:20:23 <Cale> ^^ example program using the haddock api
05:20:28 <dabblego> Peaker: QC tests are better than English at least
05:20:45 <Peaker> dabblego: They tell you about properties, they don't spell out the meaning
05:20:45 <dabblego> mreh: ? are you composing two Applicative instances?
05:20:52 <dabblego> Peaker: in many cases they do
05:21:17 <dabblego> those "properties" are usually what you would fumble about trying to express in English
05:21:28 <mreh> dabblego: they compose to make an Applicative
05:21:33 <mreh> how do I express that in haskell
05:21:42 <Peaker> dabblego: compare: QC: fooTwice xs =  xs == foo (foo xs)        with:   foo: Reverses the input argument   (I'm intentionally using a bad name because otherwise both would have some documentation and we are comparing QC to documentation)
05:21:57 <dabblego> newtype Compose f g x = Compose (f (g x)); instance (Applicative f, Applicative f) => Applicative (Compose f g) where ...
05:22:28 <Peaker> dabblego: I'd much rather read "Reverses the input list"   than the QC property
05:22:29 <mreh> hmmm, lovely
05:22:44 <Peaker> mreh: that's almost verbatim what exists in conal's TypeCompose library :)
05:22:48 <dabblego> Peaker: compare \x y -> foo (x ++ y) == foo y ++ foo x with "reverses the list, promise! No don't bother checking!"
05:23:25 <Peaker> dabblego: The QC property gives better guarantees -- the doc gives better/quicker understanding with less cognitive effort
05:23:33 <Peaker> Having both is the best of both worlds
05:23:40 <NihilistDandy> Less cognitive effort is what made Java happen
05:24:01 <ceii> Java was an improvement over the previous status quo
05:24:02 <dabblego> Peaker: I completely disagree that it is less cognitive effort, and in fact, is quite the contrary
05:24:10 <Peaker> NihilistDandy: It's what motivated them but they failed
05:24:10 <dabblego> but I'm willing to be persuaded
05:25:01 <Peaker> dabblego: The QC property you provided can be proven to show it reverses the list if it universally holds -- which is great. With a bit of cognitive effort, you can *figure out* it reverses the list.   The text "foo reverses the list" just spells it out, so you have nothing to figure out. Minor cognitive load saved. While minor, it adds up
05:25:27 <drbean>  /qui
05:25:57 <Cale> So if you're adding something like this to ghci, the thing to do would be to get the list of modules which are currently loaded, get all the installed haddock documentation, and get the instDocMap for the appropriate module, and then do a Map.lookup in that and see if there's attached haddock documentation.
05:26:36 <mreh> Peaker: yeah, i'd completely forgotten about that, and I was reading his paper last night
05:26:40 <Peaker> and enable haddock and profiling installs in cabal install by default (at least until they figure out recursively fixing missing docs/profiling packages when enabling..)
05:27:10 <Cale> yeah
05:27:31 <sayu> hi
05:27:57 <mreh> man the default Tree applicative is wacky
05:28:07 <sayu> I get some errors while I run This program:http://pastie.org/2350174 .Any help is wellcome.
05:28:09 <Cale> cheater_: So the good news is that there *is* an API for this stuff. The bad news is that it's new and experimental and not integrated into anything.
05:28:44 <andrewlockdale> Can anyone let me ssh into your machine for a bit?
05:29:21 <Cale> sayu: you're presumably trying to define main
05:29:32 <Cale> sayu: main = do ...other stuff...
05:29:47 <Cale> or since there's only one IO action in your do-block
05:30:01 <Cale> main = xmonad $ defaultConfig { ... }
05:30:25 <Cale> the 'do' is unnecessary because it's only for gluing multiple IO actions together, so when there's only one, it's not needed
05:30:36 <cheater_> if i have a function in ghci, how would i find out what "actual" function that is
05:30:45 <Cale> :info func
05:30:59 <cheater_> yeah but maybe in haskell
05:31:24 <Cale> ?
05:32:00 <Cale> It'll tell you where the function is defined, so you'll be able to disambiguate which one is loaded, if that's what's confusing you. I guess I don't really understand the question?
05:32:37 <Cale> ghci> :info sxs1
05:32:38 <Cale> sxs1 :: Set.Set (Down Char) 	-- Defined at nt.lhs:41:3-6
05:32:38 <Cale> ghci> let sxs1 = "foo"
05:32:38 <Cale> ghci> :info sxs1
05:32:38 <Cale> sxs1 :: [Char] 	-- Defined at <interactive>:1:5-8
05:32:41 <cheater_> yeah, i want to know which one is loaded
05:33:00 <cheater_> except i want to get this info in my haskell code
05:33:09 <Cale> ???
05:33:20 <Cale> Are you running an interpreter, like using hint?
05:33:43 <Cale> That information is thoroughly discarded by compilation
05:34:07 <sayu> Cale: I sill get the same error form here:http://pastie.org/2350174
05:34:10 <Cale> In fact, the function bound to a name might not even exist, because it might just be inlined.
05:34:19 <HalfWayMan> I like that: "thoroughly discarded by compilation" :)
05:34:25 <Cale> Certainly the names of defined functions are thrown away
05:34:32 <Cale> and don't exist at runtime
05:35:46 <Cale> sayu: Your code is exactly the same?
05:36:27 <Cale> oh, do you mean: http://pastie.org/pastes/2350200
05:36:48 <sayu> Cale: This is the code after chage:http://pastie.org/2350200
05:36:51 <cheater_> cale: i want to maybe write a module in haskell which defines a function doc
05:37:06 <cheater_> then i could do       doc myFunc        and then it would print out the haddock docs.
05:37:09 <Cale> indent the } on the last line so that it is more indented than 'main ='
05:37:19 <Cale> so that the line is a continuation of the definition of main
05:37:51 <Cale> cheater_: That's the wrong thing to do
05:38:00 <Cale> cheater_: Make it take a String
05:38:05 <Cale> doc "myFunc"
05:38:11 <Cale> not a function
05:38:20 <Cale> You want an identifier, which is different from a function.
05:38:41 <cheater_> Cale: why?
05:38:46 <Cale> doc sin
05:38:48 <Cale> for example
05:38:53 <Cale> passes the sine function to doc
05:39:01 <cheater_> what if i do x = myFunc, and want to find out what x is
05:39:08 <Cale> It would have to evaluate the sine function at various points and guess which function it was
05:39:19 <erus`> im on crazy pills!
05:39:20 <Cale> which seems pretty ridiculous
05:39:27 <cheater_> then i would do doc x and i would get "x is a myFunc with the following methods: ... "
05:39:48 <cheater_> Cale, isn't there some way to hack it like :info does
05:40:03 <Cale> :info isn't a Haskell function
05:40:06 <Cale> It's a command to ghci
05:40:09 <cheater_> yeah i realize
05:40:17 <cheater_> but doesn't haskell have like.. ghci bindings or something
05:40:24 <Cale> and thus has access to the interpreter state, and the parameter is parsed as a string
05:40:28 <frerich> NihilistDandy : Inspired by your screenshot, I toke some vim script I found and tuned it a bit to achieve a similiar effect. Check http://imageshack.us/photo/my-images/18/haskellunicodevim.png/ for how my Haskell code now looks in vim :-)
05:40:44 <frerich> NihilistDandy : This is also just the display, the unicode characters are not used in the file.
05:41:02 <NihilistDandy> frerich: Very nice
05:41:14 <Cale> (the string following :info is treated as an identifier, and looked up in the interpreter context)
05:41:29 <Cale> That interpreter context doesn't exist in an arbitrary running Haskell program.
05:41:52 <NihilistDandy> frerich: Almost makes me want to try vim again
05:42:00 <ceii> Is there a way to use functions from the GHC API from GHCi using GHCi's own GhcMonad session? I can't find that in the ghc docs, but I'm not really familiar with them.
05:42:09 <Cale> (because for the most part, you don't interpret Haskell programs, and even when you are running them in GHCi, it doesn't pass that information into the program that it's running)
05:42:29 <NihilistDandy> The argument has moved to -blah :D
05:42:34 <cheater_> Cale: well i'm doing this only in an interpreter anyways, so that's fine
05:43:03 <Cale> You can however, run another piece of Haskell code using hint or the GHC API, and have access to all the information that GHCi does.
05:43:15 <ceii> I'm hoping I could use parseName to look up an identifier in the current GHCi scope
05:43:42 <Cale> ceii: I doubt it very much.
05:43:45 <Cale> Well...
05:44:11 <Cale> Maybe with enough ridiculous unsafe low-level hackery... but even then I doubt anyone would manage :)
05:44:19 <ceii> :)
05:45:00 <Cale> (you'd have to find relevant things in memory, and do insane things to them)
05:45:17 <ceii> yah, being the noob I am I'll avoid that
05:45:19 <mux> that sounds exciting
05:45:39 <cheater_> <Cale> You can however, run another piece of Haskell code using hint or the GHC API, and have access to all the information that GHCi does. < how?
05:45:55 <argiopeweb> I can't manage to get System.IO.UTF-8 to work properly. Even using "interact id" in ghci returns a few bytes of gibberish before the character I paste in. "print $ chr 0x00A2" does the same.
05:45:56 <Cale> http://hackage.haskell.org/packages/archive/hint/0.3.3.2/doc/html/Language-Haskell-Interpreter.html
05:46:04 * hackagebot Hs2lib 0.5.1 - A Library and Preprocessor that makes it easier to create shared libs from Haskell programs.  http://hackage.haskell.org/package/Hs2lib-0.5.1 (TamarChristina)
05:46:12 <cheater_> so how would that work Cale?
05:46:14 <Cale> hint is the simpler way to do it, but it's still pretty involved
05:46:22 <Cale> and I don't think that it actually helps you
05:46:48 <Cale> (it's not going to help you access documentation any better than the string would)
05:47:56 <Cale> cheater_: anyway, if you write  x = y  somewhere in a Haskell program, it's valid for the compiler to simply replace all copies of x by y, inlining the definition where it occurs.
05:48:37 <Cale> cheater_: Also, for any function f, whenever x = y, we have that f x = f y
05:49:04 <Cale> (the results of the function will be the same, regardless)
05:49:45 <Cale> Even if x and y are defined in completely different ways and have different performance characteristics, if they have the same value, Haskell functions are not capable of differentiating between them.
05:49:57 <cheater_> ok yeah
05:50:22 <cheater_> ok let's try taking a string and getting from it the data that :info gives
05:50:25 <cheater_> how do we do that?
05:50:55 <NihilistDandy> :info string
05:50:58 <NihilistDandy> lol
05:51:59 <Cale> Essentially we'll be writing a small version of GHCi using the GHC API to do it.
05:52:23 <cheater_> well then maybe it's worth it to have a haskell-based version of ghci features
05:52:41 <Cale> GHCi's features aren't available without an interpreter state.
05:52:50 <cheater_> so give it interpreter state
05:52:53 <Cale> and to get an interpreter state, you have to do all kinds of stuff
05:52:59 <cheater_> put everything in the interpreter state monad
05:53:20 <cheater_> that's fine by me :)
05:53:38 <Cale> But that only makes sense if you interpret everything. It would make every Haskell program run a lot slower.
05:54:45 <Cale> It also would allow programs to mysteriously depend on their own documentation
05:54:53 <cheater_> i'm not considering using this inside haskell programs
05:55:06 <Cale> So changing the documentation of a program could conceivably affect its result.
05:55:08 <cheater_> i'm only considering using this in the interactive interpreter for developing
05:55:11 <Cale> Which is *horrible*
05:55:21 <NihilistDandy> Cale: Oh, god, that is horrible
05:55:37 <cheater_> Cale, you can always take a fork and stab yourself in the eye
05:55:38 <cheater_> but you don't
05:55:42 <cheater_> obviously you CAN
05:56:04 <Cale> So in Haskell, our general philosophy is that whenever the machine can prevent you from stabbing yourself with the fork, we make it do so.
05:56:15 <NihilistDandy> cheater_: Is it really that inconvenient to just have your haddock index open?
05:56:20 <mreh> it turns it into a spoon
05:56:28 <cheater_> NihilistDandy, yes.
05:56:41 <NihilistDandy> You are a strange person
05:56:43 <cheater_> i'm not being funny or joking, it's incovenient.
05:57:06 <Cale> http://hackage.haskell.org/package/spoon -- if you want to dig your eyes out with a spoon, we have one of those handy.
05:57:06 <mreh> are you programming on 80x24?
05:57:45 <mreh> WOW
05:57:50 <mreh> that's magic
05:57:58 <Cale> cheater_: What you want is not a Haskell function. It's a new GHCi command.
05:58:21 <cheater_> Cale, ok, how do i write a new GHCi command?
05:58:22 <Cale> cheater_: The code you want to write doesn't belong in a library, it belongs inside the GHCi program.
05:58:37 <Cale> GHCi is thankfully open source ;)
05:58:46 <cheater_> that doesn't help me further
05:59:32 <NihilistDandy> cheater_: Then get good enough that you can do it
05:59:40 <cheater_> D:
05:59:53 * cheater_ does his "face of despair" expression
06:00:04 * mux does his "look of disapproval" one
06:00:11 <lysgaard> Id
06:00:22 <cheater_> D:
06:01:19 <lysgaard> I'd like to make a mapWithKeyM, is there a way to lift this. It would have the signature: (Monad m, Ord k) => (k -> v1 -> m v2) -> Map.Map k v1 -> m (Map.Map k v2)
06:01:49 <Cale> In the ghc source, you'll find ghc-7.0.4/ghc/InteractiveUI.hs
06:02:15 <Cale> which defines the commands which are available in ghci, and what they do
06:02:35 <Cale> ("info",      keepGoing' info,                completeIdentifier),
06:02:54 <Cale> info :: String -> InputT GHCi () -- line 827
06:03:30 <cheater_> ok, let's see
06:03:38 <hpaste> Cale pasted “The info command” at http://hpaste.org/50134
06:05:04 <cheater_> ok so GHC.parseName is what gets me the module etc names?
06:05:18 <Cale> parseName :: GhcMonad m => String -> m [Name]
06:05:22 <Cale> Parses a string as an identifier, and returns the list of Names that the identifier can refer to in the current interactive context.
06:06:26 <Cale> (Somewhat ironically, I'm almost completely unfamiliar with this code and am just using haddock to look things up :)
06:07:07 <cheater_> hey cale, should i get the sources with darcs or git?
06:07:10 <Cale> getInfo seems to do most of the work
06:07:15 <Cale> getInfo :: GhcMonad m => Name -> m (Maybe (TyThing, Fixity, [Instance]))
06:07:17 <Cale> Looks up an identifier in the current interactive context (for :info) Filter the instances by the ones whose tycons (or clases resp) are in scope (qualified or otherwise). Otherwise we list a whole lot too many! The exact choice of which ones to show, and which to hide, is a judgement call. (see Trac #1581)
06:07:49 <Cale> I think they're using git
06:07:53 <cheater_> i can only see info on how to do it with git, but the git seems to be checking out from a server named "darcs"
06:07:55 <cheater_> i wonder why?
06:07:57 <Cale> yes
06:08:06 <Cale> because it used to be a darcs repo
06:08:18 <Cale> and changing the server name is more trouble than it's worth, I think
06:08:50 <andrewlockdale> again, could anyone give me their ip to ssh into? just quikcly
06:08:52 <cheater_> ah
06:09:05 <cheater_> andrewlockdale, wtf?
06:09:14 <Cale> andrewlockdale: why?
06:09:20 <cheater_> andrewlockdale, are you a bot?
06:09:28 <andrewlockdale> no, bear with me
06:09:41 <Cale> (and why are you asking in #haskell?)
06:10:03 <cheater_> maybe he's typing a really believable explanation
06:10:06 <andrewlockdale> I'm running an atom and I need to compile something on a faster processor to test it's real performance over my worst case complexity
06:10:38 <cheater_> ah
06:10:42 <cheater_> i know your pain
06:10:56 <cheater_> i really lament the fact that there are no public-access haskell compilers
06:10:58 <cheater_> there SHOULD be
06:10:58 <phiV> phiV
06:11:02 <andrewlockdale> I swear I can't get anything reliable from this atom
06:11:04 <dainanaki> heh
06:11:11 <phiV> can some on say my name : phiV, I'm testing notification
06:11:13 <andrewlockdale> cheater_: yes!
06:11:21 <cheater_> phiV, there you go
06:11:27 <phiV> thank you it works!
06:11:36 <cheater_> yw
06:11:44 <dainanaki> i tell you guys what, when I'm rich and famous, I will make a fancy compilation server available.
06:11:50 <cheater_> andrewlockdale, that's very very needed for web apps which usually run on (lots of) tiny machines.
06:12:19 <andrewlockdale> cheater_: what are you referring to as "that's"?
06:12:49 <cheater_> andrewlockdale, "public access haskell compilers"
06:12:54 <cheater_> sorry, was that gramatically incorrect?
06:13:02 <cheater_> should i say "it's" instead?
06:13:28 <andrewlockdale> thank you for correcting that
06:16:22 <andrewlockdale> There was a recent Haskell survery asking what people's favourite non-Haskell language is. The number one answer was Java. What is yours?
06:16:33 <Botje> perl
06:16:38 <cheater_> andrewlockdale, is "it's" more correct than "that's" in that context?
06:16:41 <Botje> scala is nice too
06:18:15 <andrewlockdale> cheater_: no
06:18:20 <andrewlockdale> Botje: what dialect?
06:18:39 <cheater_> andrewlockdale, ok.
06:18:53 <cheater_> andrewlockdale, my daily-use language right now is Python
06:19:00 <cheater_> whether that's my favourite or not, it's the least painful
06:19:19 <cheater_> i don't really have a favourite like that
06:19:35 <andrewlockdale> cheater_: do you even know Java?
06:19:55 <companion_cube> andrewlockdale: scala or ocaml, for me
06:20:06 <companion_cube> java is not expressive enough
06:20:07 <cheater_> i used to know some of it when i was a kid, and i once passed the final exam of a college class without learning it at all. so no.
06:20:48 <andrewlockdale> pff, everyone knows Java now, cheater_. You need to "get with it"
06:21:10 <cheater_> ya
06:21:34 <Botje> andrewlockdale: of what?
06:21:40 <andrewlockdale> oh well, you'll get there hopefully ;)
06:21:54 <andrewlockdale> Botje: pel
06:21:55 <andrewlockdale> perl
06:22:13 <Botje> uh .. the one everybody uses?
06:22:22 <dabblego> it has been my experience that very few people know Java, especially those who claim to know Java
06:22:48 <andrewlockdale> dabblego: can you elaborate?
06:22:59 <companion_cube> dabblego: but then, if you really know java, should you claim to know java or not ?
06:23:28 <andrewlockdale> companion_cube: why the hell not, man?
06:23:33 <dabblego> andrewlockdale: sure, sometimes someone will tell me two things 1) I know Java 2) Knowing Java is important. I disagree with 2), but at least 1) is testable. When I test it, I typically get poor results.
06:23:51 <mayahustle> what's your java test?
06:24:00 <companion_cube> andrewlockdale: because otherwise dabblego will think you do not know java
06:24:07 <copumpkin> andrewlockdale: link to the survey please
06:24:07 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
06:24:17 <dabblego> I ask them questions about Java. I wrote them in 2002 when I was working on the Java implementation
06:24:34 <andrewlockdale> dabblego: you helped create java?
06:24:48 <companion_cube> dabblego: which features do people that pretent to know java ignore?
06:24:55 <dafis> andrewlockdale: not in 2002
06:24:59 <dabblego> andrewlockdale: I worked on the implementation, felt guilt for some practices of the corporation I was working for, and quit
06:25:24 <andrewlockdale> dabblego: such as?
06:25:47 <andrewlockdale> (sorry I'm doing a thesis on Java and I'm very interested on people's opinions)
06:25:59 <mayahustle> uh oh.. we're not about to get JVM Spec questions, are we?
06:26:08 <copumpkin> can we move this conversation out of #haskell?
06:26:13 <dabblego> andrewlockdale: essentially what boiled down to "ripping customers off", which may be sound economic practice, but I'm just not into it -- I quit for reasons of interest, not morals
06:26:16 <dabblego> yes
06:26:23 <jocom> #haskell-java for example
06:26:37 <andrewlockdale> excuse me but this is related!
06:26:38 <jocom> Or #jaskell
06:26:57 <dabblego> andrewlockdale: we can go to #haskell-blah if you like
06:27:07 <copumpkin> andrewlockdale: I'm still not convinced you aren't a troll, and you haven't linked to the survey in question
06:27:10 <jocom> Even if it is related, we can jump into another channel all together, not?
06:27:36 <mayahustle> i'm interested in this discussion as well
06:27:39 <andrewlockdale> copumpkin: it's none of your business and it's thesis work anyway
06:28:01 <mayahustle> is #haskell-blah the place to go?
06:28:11 <dabblego> andrewlockdale: it is fair to other channel users to move to another place, like #haskell-blah
06:28:14 <dabblego> mayahustle: yes
06:28:24 <mayahustle> ok, thanks
06:28:36 <andrewlockdale> An admin can move me then
06:29:52 <jocom> You're acting like a troll
06:30:00 <jocom> Quite pretentious
06:30:30 <andrewlockdale> whatever, I'm going to quit this conversation now. If you want to talk about it more then we can do it elsewhere
06:30:57 <cheater_> outside?
06:31:02 <cheater_> mano a mano?
06:32:49 --- mode: ChanServ set +o Philippa
06:33:07 <Philippa> andrewlockdale: AFAIK I can't move you to -blah. I can most certainly move your current connection out of here
06:33:39 <Philippa> you don't know who does/doesn't have ops 'til they op up or you ask. Just sayin'
06:33:45 --- mode: Philippa set -o Philippa
06:36:08 <andrewlockdale> how do I block someone on IRC?
06:36:18 <copumpkin> o.O
06:36:45 <andrewlockdale> (xchat)
06:37:01 <dabblego> andrewlockdale: /j #xchat
06:37:08 <Cale> andrewlockdale: Window -> Ignore List...
06:37:25 <andrewlockdale> dabblego: that just opened up a new window...
06:37:41 <Cale> andrewlockdale: He was suggesting you ask there
06:37:50 <andrewlockdale> thank you, Cale
06:37:57 <andrewlockdale> good to see some people helping with Haskell for one
06:37:59 <andrewlockdale> once
06:38:07 <Cale> heh
06:47:17 <patricxkd> i'm writing a program with Control.Concurrent. I have very independent jobs which use STM. I'd like to forkIO one process per haskell IO thread - as in x threads where +RTS -Nx. how do i read x from within my haskell program, or am i approaching this from the wrong direction?
06:50:29 <mayahustle> I haven't used control.concurrent in a while, maybe two years, but I remember when I needed to do that, I defined a function that would fork, and return the count for me
06:50:40 <Cale> GHC.Conc.numCapabilities
06:50:46 <mayahustle> I'm not so sure that's the best way to do things though
06:51:55 <patricxkd> well i have large totally independent tasks, so best to one as many at the same time as haskell can, while avoiding context switching while tasks are running, so i guess one per physical core
06:52:29 <Cale> patricxkd: It's generally okay to have more haskell threads than the number of processors.
06:53:20 <Cale> Well, getting up into the millions will start to be expensive.
06:54:04 <Cale> But you shouldn't usually be too worried about having a few hundred going, say.
06:54:06 <patricxkd> but if you have shared resources, you will increase contention on them
06:54:50 <patricxkd> and it must be awful for cache constancy if you're always switching between jobs
06:55:04 <Cale> true, though STM guarantees progress (at least in terms of completed transactions), though it doesn't guarantee that long-running transactions won't be starved out
06:56:41 <patricxkd> there's no point trying to do N jobs at once surely, when you're going to spend half your time switching them around just two cores, when you could do N jobs sequentially in pairs, one per core at a time
06:57:02 <patricxkd> people say just launch as many threads as you want, but that will kill your cache
06:58:11 <path[l]> wouldnt that depend on whether the jobs are io bound or cpu bound?
06:58:24 <opqdonut> the cache point might hold, but haskell threads are really lightweight
06:58:43 <roconnor> what is cache constancy?
06:59:08 <opqdonut> the "threads" are really just tasks on a task queue that get handled by some amount of "real" worker threads
06:59:09 <patricxkd> that's what everyone says! but it ignores the cache, and the cache is pretty much _the_ bottleneck for computationally intensive apps
06:59:23 <roconnor> @type foldr
06:59:24 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:59:42 <patricxkd> yeah, so you end up switching them all the time between the os threads, so the scheduler is doing work uselessly, and the cache is constantly being invalidated
07:00:05 <opqdonut> I'm pretty tired with C programmers who whine about cache without any data to support them
07:00:13 <opqdonut> I have to put up with the type at work already
07:00:22 <opqdonut> so I'm not going to participate in this fight
07:00:56 <opqdonut> but I urge you: try parallelism in haskell. it's surprisingly painless and fast
07:01:33 <Cale> Yeah, I wouldn't recommend worrying about performance before you actually have a program which runs too slowly.
07:01:38 <Peaker> opqdonut: I've done some micro-optimization of C code recently, and I was surprised that virtually *all* of the time was memory accesses (cache line misses) and computation was of negligible costs
07:02:02 <lysgaard> How does one make a function with the sigrature: (Monad m) ?
07:02:03 <Peaker> I reduced some inner inner loop from 7.1 microsec to 2.9 microsec by saving on memory accesses, mostly
07:02:11 <Cale> Once you do, then you can start asking meaningful questions about why it runs too slowly, and the answers are often not what you'd expect.
07:02:12 <mauke> lysgaard: that's not a type signature
07:02:22 <opqdonut> Peaker: yes, sure. but that's a completely different argument on a completely different level
07:02:31 <opqdonut> also, what Cale said
07:02:33 <lysgaard> Sorry: (Monad m) => (a, m b) -> m (a, b)
07:02:56 <Peaker> In a way, I was surprised the model was relatively *simple* when people say it's so complicated...  Memory bandwidth or memory latency determine the speed, depending on whether you do random/sequential access.. computational costs IME are almost negligible
07:02:56 <mauke> lysgaard: that looks trivial
07:03:25 <mauke> lysgaard: you don't even need the full power of Monad; Functor is sufficient
07:03:32 <Cale> lysgaard: f (a, mb) = do b <- mb; return (a,b)
07:03:34 <dainanaki> f (x, m) = m >>= \y-> return (x, y)
07:03:54 <lysgaard> Ah, now I feel stupid :S
07:04:01 <lysgaard> Hehe, thanks guys =)
07:04:08 <mauke> :t uncurry (fmap . (,))
07:04:09 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
07:04:17 <patricxkd> but what are the advantages to running more haskell threads than physical cores if you're not doing an IO? there are none, and you have the disadvantage of extra scheduling time, potential cache invalidation
07:04:33 <dainanaki> not necessarily
07:04:54 <Cale> patricxkd: The advantage might be that it supports the abstraction you're trying to create using concurrency in the first place.
07:05:16 <Cale> There are advantages to using concurrency on a uniprocessor, after all.
07:05:31 <dainanaki> interleaved computations would be one example.
07:05:32 <Cale> (when it's the right thing for the job)
07:06:04 <patricxkd> well lets say that i'm intelligent enough to have determined that i want to solve this problem using concurrency, due to the data structures and computation involved - now what are the advantages to more haskell threads than io threads
07:06:36 <Cale> A network server is a really good example of something where concurrency is a natural abstraction to want
07:07:07 <Cale> ... he left?
07:07:17 <dainanaki> troll?
07:07:48 <dainanaki> is it just me, or are people being aggressive this morning?
07:08:05 <mauke> what are you trying to say?!
07:08:09 <Cale> U MAD BRO?
07:08:17 <mux> lol @mauke
07:08:20 <huangyi> :t (**)
07:08:21 <lambdabot> forall a. (Floating a) => a -> a -> a
07:08:31 <huangyi> Is there a (**) for Integer, why it's for Floating ?
07:08:33 <mux> yeah, there were a few people that I found quite confrontational
07:08:36 <Ptival> dainanaki: IT'S JUST YOU!!! @#!
07:08:37 <dabblego> @type (^)
07:08:38 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
07:08:38 <mux> :t (^)
07:08:39 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
07:08:42 <mux> :t (^^)
07:08:43 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
07:08:43 <mux> also
07:08:52 <dainanaki> heh.
07:09:06 <dainanaki> I wasn't aware of (^^)
07:09:12 <dainanaki> but it makes me happy.
07:09:41 <mux> yeah, it makes for easy trolling with developer friends: "does your language have 3 different exponentiation operators? mmm?"
07:09:49 <Cale> (^^) allows arbitrary integer exponents, but requires a fractional base, while (^) only allows non-negative exponents, but works on any Num type of base
07:10:06 <roconnor> Peaker: are you claiming that the way that memory caches are synchronized between cores is simple?
07:10:09 <dainanaki> I was referring primarily to the fact that it looks like an emoticon.
07:10:23 <mux> :t (:[])
07:10:24 <lambdabot> forall a. a -> [a]
07:10:34 <Peaker> roconnor: no, I was optimizing a simple single-core case
07:10:45 <mux> Haskell: type-safe emoticons
07:10:52 <dainanaki> ah yes, the monkey face.
07:10:59 <mauke> mux: does your language have 6 different equality operators?
07:11:03 <roconnor> Peaker: oh.  What was the model that people claim is complicated then?
07:11:18 <mux> mauke: six? some people went overboard while I wasn't looking
07:11:28 <mux> having both == and === is already bad enough in my book
07:11:33 <Peaker> roconnor: I've heard people say performance is complicated even in the single-core case
07:11:40 <mauke> EQ, EQL, EQUAL, EQUALP, STRING=, =
07:11:42 <mauke> possibly more
07:11:48 <mauke> fuck "yeah", common lisp
07:11:50 <mux> dude
07:12:04 <roconnor> Peaker: ah okay.
07:12:25 <Peaker> roconnor: with multiple cores -- I am guessing it would be similar except something can be in two read caches but only in one write cache (i.e: memory accesses out of cache still determine the slowness, with nuances about what "out of cache means")
07:12:31 <dainanaki> so, does anyone know where the getWarnings function in the GHC API went?
07:12:36 <mux> if I ever wanted to learn common lisp, that desire is now 100% dead and buried
07:12:37 <Peaker> roconnor: probably depends on the processor involved, though
07:12:38 <dainanaki> I can't find it on 7.2.1
07:12:53 <Cale> Peaker: Recover sane performance analysis from this situation by making every computational operation do lots of allocation. ;)
07:13:35 <Peaker> Cale: I think if you write before you read, it may be a cache hit so you might not get slow-as-hell everywhere :)
07:14:09 <roconnor> Peaker: okay, I won't make any claims about how to model performace costs on multiple cores; only recite claim from a presenation that I attended that the model of how caches are made consistent (hint: they are not) is so complicated that Intel's manual was wrong even after extensive revisions until the more or less removed all consistnency guarentees.
07:14:34 <roconnor> IIRC
07:15:03 <mux> I also heard claims that cache-coherency algorithms are devilishly complicated
07:15:18 <Peaker> roconnor: well, cache consistency guarantees are quite different from general cost approximation on low-level code
07:15:35 <Peaker> roconnor: and I think a semi-absolute statement like "computation is cheap" still holds
07:15:38 <roconnor> Peaker: ya; that's why I wanted to know what you meant by "model"
07:16:05 * hackagebot dependent-sum 0.2.0.1 - Dependent sum type  http://hackage.haskell.org/package/dependent-sum-0.2.0.1 (JamesCook)
07:16:12 <roconnor> Peaker: computation may be cheap, but you have no idea what the result will be :D
07:16:23 <Peaker> roconnor: what do you mean?
07:16:34 <mux> I never thought about this before, but I think it would maybe be easier to have Haskell work under a more lax coherency memory model (such as sparcv9's RMO) than other languages
07:16:54 <Peaker> I think you get latency hiding when writing -- so you only pay for the writing if you hit the bandwidth limit
07:17:18 <mux> are those lax memory models even used by people?
07:18:06 <huangyi> how to let quickCheck only generate positve integer for one  of arguments ?
07:18:08 <roconnor> Peaker: The Intel people try hard to make the cores appear to model the standard shared memory, multiple thread model of concurrency that we are taught in university, but they have failed to do so.  So if you expect your parellel program to behave like you were taught in university you will be surprised.
07:18:18 <Lycurgus> even but not just
07:18:19 <dabblego> huangyi: \x -> x > 0 ==>
07:18:25 <Peaker> roconnor: I wasn't taught in university :-)
07:18:47 <roconnor> Peaker: what model of concurrency were you taught?
07:18:59 <Peaker> roconnor: the semantics may be complicated, but how complicated are (approximate) models of speed of various operations?
07:19:50 <Peaker> roconnor: I toyed around with various ones -- In imperative languages I generally liked CPS + event loop (reactor) for concurrency. In Haskell, shared immutable memory
07:20:14 <roconnor> Peaker: I'm just making claims about semantics.  I'm not disputing any claims about speed when I said, " computation may be cheap, but you have no idea what the result will be :D"
07:20:27 <Peaker> roconnor: oh, so that's what you meant :)
07:21:05 * hackagebot dependent-map 0.1.1.1 - Dependent finite maps (partial dependent products)  http://hackage.haskell.org/package/dependent-map-0.1.1.1 (JamesCook)
07:21:09 <Peaker> roconnor: but people claim that understanding the speed is nigh-impossible, or that doing some inline assembly for an inner loop is a futile endeavor, etc.
07:21:14 <mux> chose 2: fast, correct, convenient
07:21:30 <dainanaki> what happened to the WarnLogMonad in the GHC API?
07:21:33 <Peaker> (which I find are somewhat anti-knowledge: "it's too complicated, don't even try to understand how it behaves"
07:22:04 <dylukes> Wait wait
07:22:08 <dylukes> how is 7.2.1 released.
07:22:09 <rwbarton> it's impossible to understand speed if you take the oldfashioned view that "this is an add instruction so it takes 2 cycles"
07:22:13 <dylukes> It's only 34% to the milestone.
07:22:57 <edwardk> @tell mreh you also got a patch to comonads-fd for tree now ;)
07:22:58 <lambdabot> Consider it noted.
07:24:05 <willem> Are pattern guards supposed to be included in the core of ghc later on since they seem to be a language extension although it is defined in haskell 2010?
07:24:30 <applicative> dylukes: the note says The 7.2 branch is intended to be more of a "technology preview"
07:24:37 <dylukes> mmk.
07:24:39 <roconnor> Peaker: ya, if shared memory is immutable, these problems go away.
07:24:52 <dylukes> Well I'm going to go edit/update the brew package locally.
07:24:59 <dylukes> One request,
07:25:04 <dylukes> could we have checksums on the ghc downloads page?
07:25:07 <dylukes> ^^;
07:25:11 <applicative> dylukes, oh are you handling that?  good work.
07:25:24 <dylukes> It's not a hard package, I was just going to throw it together.
07:25:35 <Peaker> rwbarton: now the new model is "this add instruction is parallelized with the cache misses that happen around it, so takes essentially 0 almost always"
07:25:51 <applicative> it might be best to wait, not everything in the haskell platform seems to compile.
07:26:04 <dylukes> applicative: yeah, I'll test it first :)
07:26:33 <applicative> i've just been fiddling with -fllvm, which is very pleasing..
07:26:38 <dylukes> :)
07:28:20 <dylukes> okaaay
07:28:22 <dylukes> brew package is done
07:28:29 <dylukes> testing then I'll send mxcl a pull request ^^
07:29:23 <dylukes> I'm glad my QT patch finally made it upstream ;~;
07:29:36 <dylukes> lol, only took three months of bullshitting around and no one wanting to do it.
07:30:13 <edwardk> prefiex: xseen roconnor
07:30:31 <edwardk> preflex: xseen roconnor
07:30:31 <preflex>  roconnor was last seen on freenode/#haskell 5 minutes and 52 seconds ago, saying: Peaker: ya, if shared memory is immutable, these problems go away.
07:30:34 <roconnor> last seen roconnor 0 seconds ago
07:30:50 <edwardk> hah
07:31:05 * hackagebot prim-uniq 0.1.0.1 - Opaque unique identifiers in primitive state monads  http://hackage.haskell.org/package/prim-uniq-0.1.0.1 (JamesCook)
07:31:07 <edwardk> thinking about something like telescope :: [Lens (f (Cofree f a)) (Cofree f a)] -> Lens (Cofree f a) a
07:31:07 * hackagebot comonads-fd 2.0.1 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-2.0.1 (EdwardKmett)
07:31:09 * hackagebot tkyprof 0.0.3 - A visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.0.3 (MitsutoshiAoe)
07:31:17 <dylukes> Okay… seems to compile on here.
07:31:23 <dylukes> does GHC come with a test suite?
07:31:34 <roconnor> edwardk: have you seen thirst zippers?
07:31:47 <edwardk> i'd be happier with telescope :: (forall b. [Lens (f b) b]) -> Lens (Cofree f a) a
07:32:01 <edwardk> thirst or thrist?
07:32:11 <roconnor> oh
07:32:15 <edwardk> link?
07:32:16 <roconnor> is it thrist
07:32:21 <dylukes> edwardk: That stuff gets so complex, I have to wonder if its actually useful.
07:32:24 <dylukes> :P
07:32:33 <roconnor> how do you pronounce that?
07:32:33 <dylukes> I'm sure there's some use, i.e Comonads I've seen are really useful… but...
07:32:47 <roconnor> @wn thrist
07:32:49 <edwardk> like thrist ;)
07:32:49 <lambdabot> No match for "thrist".
07:33:00 <roconnor> good damn it
07:33:04 <willem> What exactly are language extensions? First I thought it were extensions not included in the specification, but the Haskell 2010 report defines pattern guards _and_ suggests implementing the PatternGuard extension without cross-referencing the two
07:33:05 <dylukes> @wn comonad
07:33:06 <lambdabot> No match for "comonad".
07:33:12 <byorgey> rhymes with wrist?
07:33:28 <edwardk> dylukes: the example there, is you have a tree like structure, and a bunch of selections that know how to get through any one level, so compose them and get a path all the way down
07:33:43 <dylukes> Oh, that sounds useful actually.
07:33:43 <edwardk> dylukes: not very abstract, quite useful
07:33:53 <dylukes> NOt sure how the Cofree stuff gets in there
07:34:00 <roconnor> edwardk: http://www.reddit.com/r/haskell/comments/hhg38/isomorphism_lenses/c1vj7hd?context=3
07:34:04 <edwardk> that is the tree =P
07:34:06 <dylukes> But, I don't know what "Cofree" functors or what not ARE.
07:34:08 <roconnor> edwardk: I have to go now; I'll be back in a few hours.
07:34:13 <edwardk> data Cofree f a = a :< f (Cofree f a)
07:34:24 <dylukes> :D
07:34:26 <edwardk> look at data Tree a = Node a [Tree a]
07:34:27 <dylukes> cmon...
07:34:28 <dylukes> lets see....
07:34:30 <edwardk> and you see the same pattern
07:34:37 <dylukes> btw
07:34:39 <dylukes> one strange thing.
07:34:44 <roconnor> edwardk: ooh :< is a nice constructor
07:34:44 <edwardk> its just letting you choose the functor to be something other than []
07:34:53 <dylukes> GHC compiled in like… a minute.
07:34:55 <roconnor> edwardk: though I'd be tempted by :E if that were legal.
07:34:58 <dylukes> As opposed to the usual fifteen.
07:34:59 <edwardk> roconnor: yeah its what i use in comonad-transformers
07:35:04 <dylukes> What sort of magic did you guys do.
07:35:32 <edwardk> the unix package has a broken upper bound =(
07:35:43 <applicative> willern, is it just this, that you can use haskell98 + PatternGuards (because you insist on n+k patterns or something)
07:35:47 <edwardk> trifecta stopped building on hackage because of that
07:35:48 <drdo> How can i tell an exception is from Network and which one it is?
07:36:13 <edwardk> roconnor: feel like working through the recursion for that telescope function?
07:36:31 <edwardk> roconnor: i need to get into the office
07:37:53 <dylukes> Good news everyone!
07:37:58 <dylukes> The brew package seems to be good!
07:38:02 <dylukes> Haskell platform is compiling :).
07:38:04 <dylukes> So, I'll pull request now.
07:38:55 <zhulikas> hello haskellers \o/
07:39:04 <stobix> yo
07:39:05 <willem> applicative: ah nevermind, I was just confused seeing the old pragma used so I thought it was necessary but it isn't.
07:39:32 <RGW> I have a question concerning network.cgi (please have a look at http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell (section 7))
07:40:51 <RGW> how can I replace function "greet" by a function with signature FilePath -> IO [FilePath]
07:41:19 <RGW> I have no idea how to get rid of the IO-Monad in that case
07:41:39 <mokus> sigh... 'cabal check' barfs on both 'extensions: Safe' and 'ghc-options: -XSafe'... so it's telling me the only option I have is to foul up my code with CPP?
07:42:15 <RGW> The background is that I want to output all files in a given directory
07:42:27 <RGW> and that function has signature FilePath -> IO [FilePath]
07:42:30 <Lycurgus> mokus, CPP?
07:42:48 <mokus> Lycurgus: the C preprocessor
07:43:01 <Lycurgus> i c
07:43:05 <mokus> because {-# LANGUAGE Safe #-} won't work in older GHCs
07:43:18 <mokus> so it has to be inside an #if
07:43:26 <Lycurgus> older meaning pre 7?
07:43:32 <mokus> pre 7.2
07:43:42 <RGW> any idea?
07:44:15 <zhulikas> how can I construct a list recursivelly? Can anyone give me a simple example?
07:44:19 <robnormal> @RGW: can't you just use files <- io_thing?
07:44:19 <lambdabot> Unknown command, try @list
07:44:37 <applicative> > let ones = 1 : ones in ones
07:44:38 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:44:38 <robnormal> RGW: can't you just use files <- io_thing?
07:44:46 <mauke> zhulikas: florp n = n : florp (n + 1)
07:44:59 <RGW> robnormal: I have tried but that's not easy in this case
07:44:59 <zhulikas> ok... thanks :)
07:45:03 <cheater_> mauke, *I* was gonna do florp!
07:45:04 <dylukes> Okaaay.
07:45:05 <zhulikas> I added : [] in the end...
07:45:09 <cheater_> damn you.
07:45:13 <applicative> florp is a recursive function definition, ones is a recursive list definition
07:45:30 <RGW> robnormal: getInput :: (MonadCGI m) => String -> m (Maybe String)
07:45:39 <RGW> has another signature and is no IO-Monad
07:46:07 <RGW> so there is no chance to extract the filepaths
07:46:09 <dylukes> Would a stand-alone cabal package for Brew be useful to anyone?
07:46:55 <cheater_> Cale: ok, i have the sourcez!
07:47:12 <robnormal> hmm - is MonadCGI what it appears to be? Ie, a Monad type? If so, the arrow operator should still work...
07:48:19 <rwbarton> @type liftIO
07:48:20 <lambdabot>     Ambiguous occurrence `liftIO'
07:48:20 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
07:48:20 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
07:48:44 <RGW> I inserted a line to extract the IO-Monad after the first extraction and received
07:48:47 <RGW>     Couldn't match expected type `CGI CGIResult'
07:48:49 <RGW>            against inferred type `IO CGIResult'
07:49:25 <RGW> this results from
07:49:26 <RGW>  28 cgiMain = do mn <- getInput "name"
07:49:26 <RGW>  29              c <- getRecursiveContents "."
07:49:47 <RGW> whereby getRecursiveContents is of signature Filepath -> IO [FilPath]
07:49:56 <dylukes> Configuring Cabal-1.10.2.0...
07:49:57 <dylukes> Setup: At least the following dependencies are missing:
07:49:57 <dylukes> base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.5
07:49:58 <dylukes> hnghh....
07:50:28 <rwbarton> c <- liftIO $ getRecursiveContents "."
07:50:39 <rwbarton> should work assuming CGI is an instance of MonadIO
07:50:52 <dylukes> I have base 4.4.0.0 and unix 2.5.0.0
07:50:57 <dylukes> :<
07:51:03 <dylukes> y u no support unix 2.5 cabal.
07:51:04 <byorgey> dylukes: you need base 3i + 6
07:51:11 <RGW> cool, seems to work, thank you
07:51:16 <RGW> I didn't know that function
07:51:18 <dylukes> byorgey: what?
07:51:31 <byorgey> dylukes: notice it says base >= 4 && <3
07:51:37 <dylukes> that makes no sense.
07:51:39 <dylukes> XD
07:51:53 <dylukes> the hell.
07:52:00 <RGW> seems to be a monad-transformer :D
07:52:04 <byorgey> dylukes: why are you compiling Cabal?
07:52:07 <dylukes> Any thoughts on fixing it :P
07:52:30 <ceii> oh, you can actually coerce between any two types using GeneralizedNewtypeDeriving and TypeFamilies.
07:52:38 <ceii> I didn't realize it was that bad
07:52:50 <mokus> dylukes: GHC 7.2 comes with cabal 1.12.0
07:53:06 <dylukes> oh, where is it?
07:53:08 <byorgey> ceii: yep
07:53:12 <mokus> in the global package db
07:53:19 <dylukes> I mean, where's the bin
07:53:28 <dylukes> I need to make sure I symlink it, and add that to the formula, stat
07:53:33 <byorgey> ceii: there is a paper from this year's POPL explaining how to fix it but I don't think it's been implemented yet
07:53:38 <mokus> sorry, meant Cabal (the lib) not cabal (the executable)
07:53:46 <dylukes> yeah, I mean cabal-install
07:53:51 <ceii> oh, there's a solution? that's great.
07:53:55 <dylukes> er wait, this was me trying to install cabal-lib
07:54:09 <ceii> I'll check that
07:54:35 <hpaste> zhulikas pasted “Problem?” at http://hpaste.org/50140
07:54:43 <zhulikas> please take a look :)
07:54:46 <cheater_> hey mauke, to add new ghci commands do i need to edit anything other than InteractiveUI.hs ?
07:55:27 <zhulikas> if I remove that guard, it says that Non-exhaustive patterns in function Main.diagonalList
07:55:28 <mauke> cheater_: uh, no idea
07:55:41 <cheater_> oh :(
07:55:48 <Saizan> cheater_: seen :def ?
07:55:58 <ceii> zhulikas, don't you want [] instead? You're returning a list.
07:56:07 <cheater_> Saizan, hmm
07:56:16 <zhulikas> sure. Thanks
07:56:26 <zhulikas> I just thought it would add [] to the list
07:56:35 <zhulikas> like [1,2,3,[]]
07:56:41 <zhulikas> but once again, that would be another type.
07:56:41 <cheater_> Saizan,   ("def",       keepGoing (defineMacro False),  completeExpression),
07:56:45 <mokus> dylukes: not sure if it's considered ready for release, but there's a cabal-install 0.11.2 in the darcs repo at http://darcs.haskell.org/cabal-branches/cabal-1.12
07:56:47 <cheater_> but what do you mean if i've "seen" it?
07:56:55 <ceii> zhulikas, no, 1 : 2 : 3 : [] is just [1,2,3]
07:57:10 <dylukes> boot strapping cabal...
07:57:11 <mokus> dylukes: i'm guessing by that version number that it's not "finished" though
07:57:16 <dylukes> we'll see how it goes.
07:57:21 <zhulikas> sure it is :)
07:57:23 <zhulikas> thanks
07:57:27 <ceii> yw
07:57:29 <dylukes> it's trying to install an older version of cabal lib too…
07:57:30 <ski> `1 : 2 : 3 : []' is `1 : (2 : (3 : []))'
07:57:31 <dylukes> >_>
07:57:40 <dylukes> I need a darcs version
07:58:01 <cheater_> Saizan ?
08:00:04 <cheater_> earth to Saizan :)
08:03:41 <zhulikas> is it possible (and is it a good practice then) to overload functions in Haskell
08:03:57 <zhulikas> that supposed to be a question
08:04:00 <robnormal> it is not possible
08:04:12 <byorgey> it is possible using type classes.
08:04:12 <Saizan> you can only do it via typeclasses
08:04:20 <robnormal> To do something similar
08:04:41 <zhulikas> kthxbye
08:04:47 <robnormal> right, typeclasses - define a different action for the function on each type constructor in your type
08:05:20 <zhulikas> then I'll just make another function which takes other number of variables and calls first function
08:06:06 * hackagebot cabal2nix 1.8 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.8 (PeterSimons)
08:06:34 <parcs> cheater_: you can define a command in ghci using :def
08:09:31 <applicative> zhulikas what is diagonalList supposed to do when current == limit?
08:09:47 <zhulikas> applicative, I fixed that :) that was also a problem
08:09:58 <zhulikas> now I check current <= limit
08:10:19 <cheater_> :t print "aaa"
08:10:20 <lambdabot> IO ()
08:10:58 <applicative> I can't tell what the outcome is supposed to be, but if you replace Nothing with [] it compiles
08:11:03 <ksf> \o/ equality constraints in contexts!
08:12:15 <zhulikas> yesh :)
08:13:02 <zhulikas> I am writting a solution to http://projecteuler.net/index.php?section=problems&id=28
08:13:52 <cheater_> what am i doing wrong? :def aaa \x -> show x
08:14:22 <cheater_> :def aaa \x -> show x
08:14:29 <cheater_> (does lambdabot respond to thsoe?)
08:14:34 <cheater_> (i guess it doesn't)
08:14:48 <parcs> cheater_: parens?
08:15:00 <applicative> > let aaa = \x -> show x -- ?
08:15:01 <lambdabot>   not an expression: `let aaa = \x -> show x -- ?'
08:15:03 <cheater_> parcs, where?
08:15:12 <parcs> also the expression must be of type String -> IO String
08:15:12 <applicative> > let aaa = \x -> show x in aaa 3
08:15:13 <lambdabot>   "3"
08:15:26 <parcs> :def aaa (\x -> return x)
08:15:29 <parcs> try that
08:15:30 <cheater_> yes, how do i make it IO String?
08:15:31 <cheater_> oh
08:15:32 <cheater_> hm
08:15:48 <cheater_> yes, that seems to have worked
08:17:59 <hpaste> willem pasted “Defaults” at http://hpaste.org/50141
08:18:41 <willem> Could anyone explain why defaults are used here or is this something else? http://hpaste.org/50141
08:19:20 <cheater_> uh, ok, how do i compile ghc from source?
08:19:43 <mjrosenb> cheater_: ./configure; make?
08:19:45 * cheater_ delves into the docs
08:19:52 <cheater_> yeah, you don't really need to answer :D
08:19:58 <cheater_> is it usually a painful process?
08:20:06 <mjrosenb> willem: that is ghci being magical... ghc won't do that.
08:20:09 <cheater_> will i stand tall with my puny 2 gb free ram?
08:20:25 <dafis> cheater_: should be okay, if a tad slow
08:20:45 <cheater_> ok, let's give it a go
08:20:51 <parcs> willem: it has to do with the monomorphism restriction
08:21:06 * hackagebot cabal2nix 1.9 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.9 (PeterSimons)
08:21:07 <parcs> do `:set -XNoMonomorphismRestriction` to disable it in ghci
08:21:08 <dafis> cheater_: I buiild GHC with 1G RAM
08:21:18 <cheater_> dafis, how long was the build?
08:21:27 <dafis> (takes a couple of hours, though)
08:21:38 <cheater_> i don't want it to take a couple hours :((
08:21:50 <dafis> cheater_: two and a half hours or so
08:21:55 <cheater_> omg
08:22:32 <dafis> cheater_: on my box before that, it used to take four hours (256MB first, then 512)
08:23:00 <dafis> Now on my new box, it's a bit under one hour :D
08:23:07 <willem> parcs: and how is it monomorphic? I mean in what way is a type variable free?
08:23:15 <cheater_> "again, could anyone give me their ip to ssh into? just quikcly"
08:23:23 <cheater_> heh.
08:23:32 <dafis> cheater_: 127.0.0.1
08:23:37 <cheater_> :D
08:23:52 <zygoloid> cheater_: 192.0.43.10
08:23:54 <cheater_> no i'm just quoting a troll from a couple hours ago :)
08:24:02 <cheater_> zygoloid, ooo, nice one.
08:24:52 <mokus> dafis: I hax0red your machine at 127.0.0.1!!! hahaha!
08:24:54 <d7> So if I ditch haskell-platform for ghc-7.2.1, will I see some of the problems with OSX Lion resolved?
08:24:58 <d7> I hope so. :(
08:25:06 <mokus> dafis: it wasn't very hard, you had the same password as me!
08:25:11 <rs463`> hi, can anyone tell me whether, when using hackage's "check" facility, the exposed modules should be clickable to reveal the interface page, with the function Type Signatures etc... along with the link to "source"  for each function?
08:25:25 <thoughtpolice> d7: 7.2.1 should work be fine on lion. 7.0.4 should also be fine, but it will have some very annoying linker errors
08:25:32 <dafis> mokus: bye, then ;)
08:25:44 <thoughtpolice> the linker errs are harmless however.
08:25:44 <Ke> wonder if people emphasize the platform too much, it doesn't really seem to have any relevance
08:25:46 <rs463`> I've just uploaded a .tar.gz file into the check system, and none of the exposed modules are clickable links ?
08:25:49 <d7> thoughtpolice: I had ghci segfaults too.
08:25:56 <thoughtpolice> d7: try 7.2.1
08:26:05 <d7> I've never gone off haskell-platform. Is it difficult?
08:26:18 <cheater_> hey guys, is the GHC module available to :l in the interpreter as well? or is it just available inside of GHC/GHCi itself?
08:26:33 <mokus> d7: it's a bit of work to get cabal-install running if you don't already have it, but once you do it's pretty easy going
08:26:37 <thoughtpolice> d7: you should be fine, as long as you still have 'cabal'.
08:26:42 <applicative> thoughtpolice are the haskell platform libraries all up to date with 7.2
08:26:51 <cheater_> @hoogle GHC
08:26:52 <lambdabot> No results found
08:26:56 <d7> applicative voices the concern
08:26:56 <thoughtpolice> mokus: 1) download cabal source code, 2) run included './bootstrap.sh' script :D
08:27:01 <cheater_> @hayoo GHC
08:27:01 <lambdabot> Unknown command, try @list
08:27:11 <thoughtpolice> applicative: i have no idea what's included in the package. hold on.
08:27:13 <mokus> thoughtpolice: ah, didn't know they had a script for all the dependencies - that's handy
08:27:29 <thoughtpolice> mokus: it's simple stuff like parsec/network but it makes it really easy, yeah
08:27:33 <d7> Oh I am surprised at that, thoughtpolice.
08:27:40 <d7> Although I guess I should not be
08:27:52 <d7> Haskell's platform stuff is shockingly good.
08:27:59 <mokus> thoughtpolice: yea, it's not hard to do it manually, just tedious - that script will save me time in the future, thanks :)
08:28:37 <parcs> willem: in that they are not bound to a concrete type. fromIntegral is not monomorphic because its type has two free type variables, a and b
08:29:35 <mun> hi
08:29:42 <dafis> hi
08:30:04 <thoughtpolice> applicative: okay, so off hand I see no reason why almost all of the stuff included in the platform wouldn't work for 7.2.1.
08:30:12 <thoughtpolice> if you want, i can test it all, since i'm installing 7.2.1 now :)
08:30:12 <willem> parcs: hold on, the definition of being monomorphic is that the type is free right?
08:30:17 <dylukes> thoughtpolice: Most of it doesnt.
08:30:24 <dylukes> alex will not build, i.e
08:30:25 <mun> i have a logic related question: are functions of functions typically considered to be second-order rather than first-order?
08:30:28 <thoughtpolice> dylukes: know why off hand?
08:30:34 <dylukes> ope
08:30:35 <thoughtpolice> oh, didn't alex just get a new version?
08:30:35 <dylukes> nope*
08:30:42 <dylukes> I just tried compiling the HP.
08:30:46 <dylukes> after installing GHC 7.2.1
08:30:52 <dylukes> (which works on OS X Lion! Hurray!)
08:31:01 <thoughtpolice> oh, i just meant the packages as they are on hackage. i don't really deal with the HP at all.
08:31:06 <thoughtpolice> hold on
08:32:08 <parcs> willem: quite the opposite. monomorphic means that its type is contains concrete types like Int, Bool, etc, and not type variables
08:34:36 <acowley> mun: no, functions that take other functions as arguments are usually referred to as higher order
08:35:11 <acowley> second order depends on quantification
08:35:40 <willem> parcs: and how did fi2 become monomorphic?
08:35:53 <Saizan> mun, acowley: second, third, etc.. order is used in this way too
08:36:44 <Saizan> mun: (Int -> Int) -> Int would be second order, ((Int -> Int) -> Int) -> Int third order etc..
08:36:45 <acowley> Saizan: what I meant is that you can have a monomorphic higher order function
08:36:51 <rwbarton> "second-order" is one of those terms that can mean many things depending on context
08:36:56 <acowley> ah
08:37:05 <acowley> well, I apparently am more particular in my usage than I should be!
08:37:22 <thoughtpolice> dylukes: i just compiled alex 3.0 and pretty much everything in the HP off of hackage just fine. the only exception is HTTP, and that i'm not sure is actually due to a code problem, but just because the maintainers were cautious and constrained the version of base < 4.4 (which is what comes with 7.2.1)
08:37:44 <thoughtpolice> oh, and fgl, but I think it's the exact same reason
08:38:01 <mjrosenb> willem: ohh right... in ghc-7, they changed the way type inference works... they now monomorphize in a let binding, unless you have explicityl supplied a polymorphic type
08:38:05 <rwbarton> ... with not particularly much in common between its various meanings
08:38:29 <mjrosenb> willem: http://hackage.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7
08:38:34 <dafis> thoughtpolice: alex-3.0 had a bug, though, probably better to upgrade to 3.0.1
08:38:45 <thoughtpolice> dafis: looking back at it i did
08:38:50 <thoughtpolice> since simon uploaded it a few hours ago
08:38:59 <dafis> fine, then
08:39:03 <thoughtpolice> actually, the FGL build failure is also due to GHC becoming more pessimistic i guess?
08:39:07 <thoughtpolice> "Illegal bang-pattern (use -XBangPatterns)"
08:39:22 <thoughtpolice> other than that and HTTP, everything else looks like it installed just fine. oh wait
08:39:29 <thoughtpolice> i didn't try GLUT but that's because i don't have those -dev packages
08:39:32 * thoughtpolice looks that up
08:39:36 <parcs> willem: the monomorphism restriction applies only to pattern bindings
08:39:43 <Saizan> rwbarton: the System F_n use of order is quite similar, just transposed at the level of the kinds of types you can quantify over
08:39:52 <dafis> thoughtpolice: didn't GHC reject bang patterns without the extension for some time already?
08:39:54 <parcs> `fi2 x` is a function binding
08:40:04 <thoughtpolice> dafis: yes, so i don't know why it's complaining now
08:40:09 <acowley> I usually think of second order as referring to quantification in logic
08:40:16 <acowley> so wouldn't call ((Int->Int)->Int) second order
08:40:25 <mun> acowley, so why are functions taking other functions as arguments higher-order? doesn't higher-order only give the extra feature that allows quantification over functions?
08:40:33 <acowley> but if I wanted to distinguish it from functions over non-function values, I'd call it a HOF
08:41:35 <willem> o.o I guess I don't understand poly and monomorphism. Where is the best place to read up on that? The 2010 spec?
08:42:07 <mun> aconbere, can't functions of functions be formulated in first-order logic?
08:42:18 <acowley> mun: you can see it as a nesting of arrows
08:42:24 <acowley> mun:I don't really understand your last question
08:42:33 <mokus> willem: monomorphic types are types that have no type variables - polymorphic types are all others
08:42:50 <acowley> mun: your question to aconbere reflects my apparently narrow usage of the terms
08:43:30 <mun> acowley, sorry, that was addressed to you.
08:43:35 <mun> acowley, but why does the nesting of arrows make it more expressive than first-order?
08:43:38 <acowley> mun: as to why functions taking functions as arguments needs a name, I think it might be a less technical usage
08:43:44 <acowley> they're different things
08:44:11 <acowley> what is a functional programming language? One characteristic is that functions are treated as "first-class values" thus greatly enabling the usage of functions of functions
08:44:15 <parcs> willem: anywhere, really. just google "polymorphism haskell" and start reading
08:44:40 <acowley> mun: first order is a term that, in my book, is from logic, and is not related to the question of functions as first-class values
08:45:27 <acowley> mun: the usage of a HOF also suggests a higher level of abstraction
08:45:30 <applicative> mun, in logic, 'first order' means 'no first class functions of any kind, higher or not'
08:45:37 <acowley> mun: e.g. abstracting a traversal pattern
08:46:06 * hackagebot oneOfN 0.1.0.1 - Anonymous coproduct type  http://hackage.haskell.org/package/oneOfN-0.1.0.1 (JamesCook)
08:46:41 <cheater_> hey guys, i'm looking at this ticket: http://hackage.haskell.org/trac/ghc/ticket/1463
08:46:43 <mun> applicative, right, being first-class means being able to be quantified over?
08:46:48 <acowley> applicative: I don't think that's right.
08:46:57 <applicative> right, that's what i'm thinking.
08:47:00 <cheater_> i've tried out e.g. :i List but it doesn't work. however, according to this ticket, it should be implemented and should work. what gives?
08:47:00 <acowley> applicative: first order logic can express ((Int -> Int) -> Int)
08:47:19 <applicative> acowley, yes there is a crossing of nomenclatures.
08:47:43 <acowley> applicative: so what do you mean by "first class"?
08:47:51 <applicative> I was thinking mun was seeing 'higher order' something akin to the use in logic, second order logic, higher order logic
08:47:58 <cheater_> does anyone know?
08:48:04 <mun> applicative, yes i am, indeed.
08:48:12 <applicative> like mun said, that you can quantify over them
08:48:31 <acowley> Yes, but you said that in first order logic you can't have first class functions of any kind
08:48:36 <applicative> in specific theories, like set theory, of course, the regular quantifier ranges over something called functions
08:48:37 * ski . o O ( "Functional Programming Koans" <http://web.archive.org/web/20041012103936/http://www.bagley.org/~doug/ocaml/Notes/okoans.shtml> )
08:49:07 <acowley> I don't think first order logic precludes me from quantifying over values of type Int->Int
08:49:13 <applicative> acowley, yes, in first order logic you cant quantify over functions, unless "function" means some type of individual, as in set theory
08:49:25 <cheater_> help!
08:49:58 <acowley> cheater_: where is "List" defined?
08:50:04 <acowley> cheater_: try :i Int
08:50:12 <mun> acowley, but quantifying over Int->Int is quantifying over functions, which isn't first-order, right
08:52:41 <acowley> mun: I don't really see why not. Can't I have a domain that is all functions of type Int -> Int, and quantify over them to see ∃f.f(2)?
08:53:38 <applicative> in set theory given a set N there will be N ^ N of course, so you can restrict the regular quantifiers and quantify over all of them.
08:53:38 <cheater_> acowley, please look at the link i posted. List is a module.
08:54:08 <mokus> i think there's some confusion of terms here - there's quantification of types and quantification of terms (the latter being lambda abstraction) - higher order functions are functions that quantify over other function _terms_, and they can have first-order types
08:54:19 <mun> acowley, the way i see it is that the quantification over Int -> Int requires second-order reasoning.
08:54:45 <applicative> acowly, but in the usual formulation of the replacement axiom, for example, which is like "map" one uses an infinite number of schemata
08:55:04 <acowley> mokus: that is how I see it
08:55:25 <applicative> mokus there's plenty of confusion of terms, everyone agrees on that much
08:55:32 <acowley> yes, we're all quite confused
08:55:36 <mun> mokus, then how about quantification over types?
08:55:39 <mokus> but can themselves be considered to have higher 'order's WRT to the "quantification" lambda abstraction
08:56:03 <mokus> mun: quantification over types is what you're doing when you have type variables
08:56:44 <mun> mokus, yes, and is that at least second-order?
08:56:48 <DukeDave> Hi gang, I have two types, each a vector type (representing two coordinate spaces). At the moment I have some pretty hairy function names such as, "modelPositionToScaledScreenPosition" and permutations upon this.
08:56:48 <DukeDave> I wondered if there's a general strategy where I can have several functions called, "to", defined for varies type combinations, and let some polymorphic behaviour choose the correct implementation.
08:57:04 <dainanaki> is there a way to get command line args as an unprocessed string?
08:57:05 <mun> mokus, polymorphism is a feature of at least second-order logic, right?
08:57:05 <acowley> applicative: I don't really see why that means I can't quantify over functions
08:57:19 <mokus> mun: not necessarily - only if you're wanting to instantiate a type variable to values which are themselves quantified
08:57:48 <mokus> mun: so, forall a. a -> a is first order, but (forall a. a -> a) -> (forall b. b -> b) is second order
08:57:48 <applicative> acowly I was only trying to clarify the standard logical use of the expressions
08:58:05 <EvanR7> 'what is state, really'
08:58:12 <mun> the reason i ask is that i'm looking at the second-order Peano axioms, and the wikipedia page has axioms like f(0) = 0 and f(S(n)) = S(f(n)). but then these are can be expressed in FOL since there's no quantification.
08:59:13 <applicative> mun the induction principle is what may or may not be second order
08:59:52 <applicative> if you use infinitely many schemata, it is still first order, on usual way of using words; if you say
08:59:57 <acowley> cheater_: that usage of :info isn't mentioned in the current user guide http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-commands.html
09:00:17 <robnormal> DukeDave: you can do what you want to do with typeclasses
09:00:29 <applicative> forall P, P 0 ^ (P n -> P (n+1)) -> forall n P n  then it's a second order formulation
09:00:41 <applicative> ^ should be &
09:01:23 <mun> applicative, right. so the f in the second-order axioms is implicitly quantified?
09:01:36 <mun> http://en.wikipedia.org/wiki/Peano_axioms#Models
09:02:07 <DukeDave> robnormal: That's reassuring, I'd just come to the same conclusion myself :)
09:02:11 <acowley> I'm going to stop trying to use specific words to refer to specific things. It leads to a lot of confusion; best to embrace imprecision and chaos.
09:02:27 <EvanR7> agreed
09:02:47 <zygoloid> having decidable notions of correctness is overrated anyway
09:03:15 <mun> mokus, so why is it that if a type variable is instantiated to values which themselves are quantified second-order?
09:03:25 <acowley> mun: the ninth axiom is second order because it quantifies over the set K
09:04:01 <applicative> mun, the phi in the induction schema is bound by a quantifier "forall phi..." or the K is
09:04:11 <mokus> mun: that was poorly phrased actually... i think a better phrasing would be that in a second order language, first-order sentences can appear as terms
09:04:35 <acowley> and if φ is monomorphic you get back to applicative's reference to schemata, but recover first-orderedness
09:04:36 <ski> mokus : `(forall a. a -> a) -> (forall b. b -> b)' is rank-2
09:04:37 <applicative> mun, in a 'first order formulation' there isn't really and induction principle 9, but infinitely many, one for each predicate you can form in the ambient language
09:04:57 <mokus> ski: hmm... yea, i might be crossing my terminology
09:05:27 <copumpkin> :t let f :: (forall a. a -> a) -> (forall b. b -> b); f x = x in f
09:05:28 <lambdabot> forall b. (forall a. a -> a) -> b -> b
09:05:41 <acowley> ski: that's an interesting function
09:05:41 <ski> applicative : bound by a meta-quantifier
09:05:53 <monochrom> http://en.wikipedia.org/wiki/Peano_axioms#Models talks at the meta level. I am not sure whether it is useful to ask "is my metalogic 2nd-order"
09:05:54 <applicative> ski, yes
09:06:08 * hackagebot fig 1.3.1 - Manipulation of FIG files  http://hackage.haskell.org/package/fig-1.3.1 (AndersLauOlsen)
09:06:20 <acowley> monochrom: I look at myself in the mirror every morning and ask, "Is my metalogic second order?"
09:06:23 <phao> does haskell has continuations (or the possibility of implementing it without going too far from the purpose of the language) ?
09:06:24 <applicative> monochrom the first/second order distinction arises earlier.
09:06:29 <phao> s/has/have
09:06:46 <cheater_> acowley, i realize, that's why i wonder why it's suddenly gone?
09:06:53 <applicative> monochrom, thus it mentions that first order formulations have funky models, but the second order formulation is categorical
09:07:23 <ski> phao : first-class continuations is a side-effect, so no (but see <http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters>)
09:07:52 <ski> phao : it's possible that *linear* first-class continuations wouldn't yield side-effects, though
09:08:25 <mun> ok i'll look more into this
09:08:26 <mun> thanks a lot guys
09:08:32 <acowley> cheater_: I've never used it so I don't know when it went away
09:09:16 <acowley> mun: you are always welcome to get us to argue about overloaded names for complicated things, it's what we do!
09:09:30 <mun> lol
09:09:51 <mjrosenb> ski: linear first class continuations?
09:10:34 <acowley> Is Cont really not what phao is after?
09:10:39 <monochrom> applicative, there was a question of whether the "f" there is quantified. I was answering that. the "f" there is at the meta level, not part of the target logic axioms.
09:10:55 <erus`> http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html
09:11:04 <erus`> You're going to have to get serious  about my monads, or that's the last time you're going to play with
09:11:06 <erus`> them!  Got it?"
09:11:15 <ski> mjrosenb : yes
09:11:51 <mjrosenb> ski: paper?
09:12:38 <ski> iirc Andrzej Filinski's "Linear Continuations" in 1992 at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/LC.ps.gz> talk some about them
09:13:05 <acowley> ski: but why not at least point him to to ContT?
09:13:08 <applicative> monochrom, I'm not sure if we are differing over anything. The topic under discussion in that sentence is in fact the second order theory, though you would use f the same way when saying the opposite of a first order formulation
09:13:28 <ski> (i don't recall whether that talks about having them first-class, though)
09:13:47 <applicative> ski, there is no evidence phao wasn't looking for something like ContT.  You brought in firstclassness, no?
09:13:59 <ski> acowley : that's more or less just CPS, you can't reify the implicit continuations to that
09:14:37 <acowley> ski: I still think it's the best first answer if someone asks about continuations in Haskell
09:14:42 <ski> applicative : phao said "continuations" as opposed to "CPS"
09:15:06 <applicative> phao ?  where are you??
09:15:11 <acowley> he left
09:15:15 <ski> -!- phao [~phao@pontenova.dpi.ufv.br] has quit [Quit: Leaving]
09:15:35 <applicative> :(
09:15:41 <acowley> we failed him
09:15:52 <acowley> he should've asked about higher order logic
09:15:53 <ski> you can @tell him about CPS, if you want to
09:16:45 <ski> to me, "continuations", with no further qualifier is about first-class continuations
09:17:36 <ski> or, more properly, the continuations which can be made first-class, if you have first-class continuations :)
09:18:17 <acowley> what about this: http://okmij.org/ftp/continuations/implementations.html#CC-monads
09:18:20 <ski> so in a program `..(2 + f 3)..' the continuation to `f 3' is `..(2 + <>)' with `<>' representing the hole in the program
09:18:29 <acowley> it's good to push newcomers to oleg as soon as possible
09:18:57 <applicative> phao isn't a newcomer, or not totally.
09:19:15 <mokus> well, if someone is wanting continuations they're halfway to oleg's territory anyway
09:19:15 * ski has seen phao here for maybe some months at least
09:19:45 <acowley> (I was kidding)
09:20:16 * ski sometimes points continuation-seekers to papers by Filinski, Thielecke, Danvy
09:20:40 <applicative> i can't search tunes.org anymore.  I notice lots of phaos in #scheme :)
09:21:15 <acowley> he's reusing his own continuation
09:21:16 * applicative comes around to ski's view of the matter
09:21:31 <acowley> continuation seekers sounds like CPS to me! :P
09:21:46 <ski> applicative : hm ?
09:22:14 <applicative> ski, just that phao might have meant to ask the very precise question you answered
09:22:38 <mjrosenb> ski: oh hey, a paper from cmu... what a suprise :-p
09:23:04 <ski> which paper is that ?
09:24:25 <mjrosenb> ski: the one you just pointed me at... linear continuations
09:25:27 <ski> ok. it was some years since i read the paper
09:25:56 <hpaste> DukeDave pasted “Error with default class function” at http://hpaste.org/50143
09:26:02 <ski> there's possibly papers that better explain how linear continuations could be used. that paper was the one i could recall was relevant
09:27:17 <DukeDave> Some weirdness there, the error says that I can't define a default class function, because the function uses other functions which are defined by the class :|
09:27:47 <DukeDave> Could it be something to do with functional dependencies?
09:27:49 <rwbarton> the problem is it doesn't know which instance of transform_ to use in transform
09:27:53 <rwbarton> yes, in a way
09:27:56 <ski> `cast :: aPos -> bPos' is ambiguous
09:28:13 <rwbarton> or yeah, cast is even worse
09:28:21 <DukeDave> Do you see what I'm trying to do there?
09:28:35 <ski> an FD could solve the problem, but only if the FD is appropriate to add, wrt the problem domain
09:29:16 <rwbarton> I understand what you are trying to do on line 6, but not in the rest of the code :)
09:29:36 <Guest> Hello! Could you please freenode me?
09:29:47 <DukeDave> It just seemed silly having to pick the right function name every time, I ended up with things like "castAtoB", "castBtoA", "transformAtoBasA", "transformAtoBandCasttoB"
09:30:09 <ski> DukeDave : another possibility would be to normalize the class into two classes (cf. database relation normalization)
09:30:14 <rwbarton> yes
09:30:25 <rwbarton> cast seems to want its own type class
09:30:31 <DukeDave> ski: One for the casting, and one for the translating?
09:30:35 <DukeDave> Aha, interesting idea
09:30:36 <Guest> COULD YOU PLEASE FREENODE ME?!
09:30:45 <rwbarton> could you please english
09:30:47 <ski> Guest : sorry ?
09:30:54 <mokus> Guest: what does that even mean?
09:31:05 <DukeDave> And then define 'transform' in terms of both
09:31:09 * hackagebot wumpus-basic 0.20.0 - Basic objects and system code built on Wumpus-Core.  http://hackage.haskell.org/package/wumpus-basic-0.20.0 (StephenTetley)
09:31:11 * hackagebot wumpus-drawing 0.5.0 - High-level drawing objects built on Wumpus-Basic.  http://hackage.haskell.org/package/wumpus-drawing-0.5.0 (StephenTetley)
09:31:12 <DukeDave> I'll give it a go, thanks guys :)
09:31:17 <Guest> It means to connect me with the internet.
09:31:30 <ski> DukeDave : maybe having one of the classes a superclass of the others, i'm not sure
09:31:37 * DukeDave nods
09:31:51 <ski> Guest : presumably you're already connected with the internet, as you're talking here
09:32:05 <ski> this is the internet
09:32:10 <rwbarton> welcome
09:32:14 * ski vaguely gestures wildly about the room
09:32:15 --- mode: ChanServ set +o copumpkin
09:32:30 * mokus picks up the lamp that ski just knocked over
09:32:35 <mokus> :)
09:32:36 <RGW> hi haskellers
09:32:41 <Guest> But I want to go to freenode.
09:32:48 <copumpkin> Guest: type /join #freenode
09:32:49 <rwbarton> you're in luck
09:32:54 <ski> Guest : anyway, this is a channel for discussion topics related to the Haskell programming language
09:32:54 <rwbarton> oh
09:33:06 <ski> Guest : did you have any question or problem pertaining to Haskell ?
09:33:20 <Guest> What is haskell?
09:33:34 <ski> Haskell is a statically typed functional programming language
09:33:38 <copumpkin> Guest: somehow you ended up in #haskell
09:33:40 <jocom> Haskell is meant to be next world order
09:33:42 <copumpkin> that's where you are speaking now
09:33:48 <applicative> @faq can Haskell make Guest and other human beings happy?
09:33:49 <lambdabot> The answer is: Yes! Haskell can do that.
09:33:56 --- mode: copumpkin set -o copumpkin
09:34:04 <stobix> #haskell IS on freenode, so you're on freenode already
09:34:20 <acowley> Is #haskell the default channel in some IRC client?
09:34:28 <jocom> freenode is a huge bunch of chatrooms (channels) and you landed in this one
09:34:33 <copumpkin> acowley: you'd think so, but I think a lot of people just use /list
09:34:34 <jocom> you are very welcome!
09:34:35 <monochrom> only one irc client defaults to #haskell
09:34:37 <stobix> acowley: that would be cool. :)
09:34:39 <copumpkin> which is why I proposed making this channel +s
09:34:46 <copumpkin> and it was for a while, but people took it off again
09:34:46 <mokus> acowley: i need that client if so :)
09:34:47 <Guest> How many chatrooms are on freenode?
09:34:56 <copumpkin> Guest: lots, but this isn
09:34:58 <stobix> ∞ -  3
09:34:59 <ski> copumpkin : `+s' is ?
09:35:07 <copumpkin> ski: secret, won't show up in /list or /whois
09:35:09 <applicative> Guest zillions
09:35:13 <jocom> Guest: About 3 million (unestimated guess)
09:35:31 <Guest> I want to buy a channel.
09:35:34 <jocom> Guest: What do you want to chat about?
09:35:38 <jocom> channels are free
09:35:41 <copumpkin> Guest: this is not the place to talk about that
09:35:49 <copumpkin> join #freenode and ask them how it works
09:35:52 <jocom> Type "/join #weeyyyMyChannel"
09:35:53 * stobix proposes keeping Guest as a pet.
09:36:05 <ski> copumpkin : do you reckon it would help ? i've got the impression that some sites list #haskell early in lists of programming channels
09:36:32 <jocom> Guest: If you want to talk about racing type "/join #racing"
09:36:51 <jocom> If you want to talk about decent IRC clients type "/join #irssi"
09:36:54 <copumpkin> ski: I feel that if you want to spam efficiently, sorting /list by usercount and moving down the list is an efficient way to go about it
09:36:58 <monochrom> too little data to know whether it will help. it is not like this happens often enough.
09:37:07 <jocom> Aaah the poor guy closed the web IRC client!!!
09:37:10 <copumpkin> monochrom: the question is what is the downside?
09:37:23 --- mode: ChanServ set +o copumpkin
09:37:25 <stobix> aww...
09:37:31 --- mode: copumpkin set +b *!5b87a963@gateway/web/freenode/ip.91.135.169.99
09:37:32 --- kick: copumpkin_ was kicked by copumpkin (okay, you're a troll)
09:37:37 <acowley> to be fair, someone joining the channel and asking us to connect him to the internet is pretty awesome
09:37:41 --- mode: copumpkin set -o copumpkin
09:38:00 <jocom> acowley: +1
09:38:04 <monochrom> don't you also own copumpkin_ and therefore can just nick-ghost it? :)
09:38:10 <copumpkin> I don't, actually :)
09:38:14 <stobix> acowley :)
09:38:17 <monochrom> darn
09:38:32 <monochrom> well, I guess I don't own monochrom_ either
09:38:45 <copumpkin> you should!
09:38:49 * stobix owns stobix in some other languages
09:39:44 <dafis_> Hm, do I smell a nickname abuse war coming?
09:40:44 <monochrom> oh, I own monochrom_ afterall
09:40:59 <hpaste> DukeDave annotated “Error with default class function” with “Error with default class function (annotation)” at http://hpaste.org/50143#a50144
09:41:34 <DukeDave> rwbarton: ski: Okay, now I think I've just broken the type system :|
09:41:35 <copumpkin> DukeDave: what do the type variables represent?
09:41:38 <dafis> monochrom: shouldn' mypation then have been undone pretty soon?
09:42:04 <dafis> fat fingered : shouldn't my usurpation ...
09:42:05 <copumpkin> DukeDave: you seem to be doing something a bit odd for typeclasses :)
09:42:06 <DukeDave> copumpkin: I have to coordinate space, which unfortunately each have their own types as well.
09:42:20 <copumpkin> DukeDave: it seems like aPos might be a function of aPlane?
09:42:24 <copumpkin> and same with bPos and bPlane?
09:42:25 <monochrom> you misspelt, you missed an "o"
09:42:36 <copumpkin> DukeDave: or vice versa?
09:42:52 <dafis> monochrom: oh, oops
09:43:16 <ski> DukeDave : why is `bPos' an argument of `Transformable' ?
09:43:46 <DukeDave> ski: That's an error :)
09:44:41 <DukeDave> Ah, it works now, having removed `bPos' from `Transformable'
09:45:11 <DukeDave> For reference: I have a "model" in one vector space and I'm converting it to another vector space to draw things in WX
09:46:14 <DukeDave> I use Vector2 (Double representation) for my model space (with 0,0 in the centre), and WX.Point (Integer representation) for the calls to WX's drawing functions.
09:46:38 <DukeDave> So I often need to do both type conversion and a transformation at the same time
09:47:23 <DukeDave> To minimise confusion I'm keeping all model space vectors as Vector2s, and all screen/render space vectors as Points
09:47:28 * DukeDave breaths
09:47:47 <DukeDave> I'm open to other approaches :D
09:48:50 <DukeDave> I was inspired by the "toIntegral" type functions, i.e. there's just one, and not "doubleToInteger", "floatToInteger", "integerToFloat", "intToFloat", ...
09:49:11 <mm_freak_> if i want to derive a functor instanct for a newtype, is there any difference between DeriveFunctor and GeneralizedNewtypeDeriving?
09:50:53 <c_wraith> type-level roman numerals?  some people are crazy.
09:51:05 <sm__`> edwardk: can stable-map store heterogenous values, like a HList ? or is it just the keys that are heterogenous ?
09:51:27 <robnormal> DukeDave: what you want is a function that will do the following?
09:51:28 <robnormal> cast (Vector2 x) -- yields Point
09:51:28 <robnormal> cast (Point x) -- yields Vector2
09:51:51 <ski> `GeneralizedNewtypeDeriving' is to "inherit" the instance of the representation type (the definiens) to the new type (the definiendum)
09:52:18 <hatds> mm_freak: I think they should be the same
09:52:33 <ski> while `DeriveFunctor' can derive that a `data' type is a functor, without having to necessarily work on an existing instance
09:52:37 <ski> mm_freak_ : ^
09:52:57 <mm_freak_> ski: ah, thanks
09:53:02 <ski> so you pobably want `GeneralizedNewtypeDeriving' for your `newtype'
09:53:04 <ksf> $ ~/.cabal/bin/cabal --version
09:53:04 <ksf> cabal-install version 0.10.2
09:53:04 <ksf> using version 1.12.0 of the Cabal library
09:53:06 <ksf> \o/
09:53:12 <ksf> only a couple of version bumps away.
09:53:15 <mm_freak_> ski: but in the case of a newtype, is there any difference?
09:53:55 <DukeDave> robnormal: Yes, exactly, and I think I have that now
09:53:58 <ski> mm_freak_ : i would assume both to work, but `DeriveFunctor' to use in a few cases more than `GeneralizedNewtypeDeriving'
09:54:19 <DukeDave> robnormal: Although I'm looking at Data.Typeable
09:54:26 <ski> mm_freak_ : `GeneralizedNewtypeDeriving' basically just reuses an existing instance, translating the old type to the new
09:54:37 <ski> mm_freak_ : while `DeriveFunctor' actually derives a new instance
09:55:09 <ski> mm_freak_ : so i assume in `newtype Identity a = MkIdentity a', you could use `DeriveFunctor', but not `GeneralizedNewtypeDeriving'
09:55:21 <mm_freak_> ski: ok, thanks
09:56:04 <ski> also, for `newtype Foo a = MkFoo (Bar (Baz a))' i'd expect only `DeriveFunctor' to work
09:56:13 <jonkri> could it be argued that using a json/soap/xmpp etc api of a agpl licensed software makes for a derivative work?
09:56:20 <jonkri> could ANYONE, like the fsf, argue that?
09:57:40 <Entroacceptor> btw., there's no way to do standalone derviving when the module doesn't export all constructor?
10:01:10 * hackagebot MazesOfMonad 1.0.7 - Console-based Role Playing Game  http://hackage.haskell.org/package/MazesOfMonad-1.0.7 (JeanPhilippeMoresmau)
10:05:03 <acowley> An interesting side effect of having good, automated spam filters on email is that it takes a really long time to determine if a mis-addressed email in your inbox is spam/phishing that beat the filter or an honest mistake.
10:06:45 <mjrosenb> acowley: and you *never* think to check in your spam filter when you're expecting an email, and it doesn't show.
10:07:38 <acowley> mjrosenb: I do occassionally, and usually regret it. It's like arguing with the type checker: you're probably wrong.
10:09:22 <jocom> You guys get serious phishing attempts?
10:09:25 <jocom> You must be rich
10:09:33 <jocom> I've never had a serious one
10:09:50 <jocom> All of them were ridiculous
10:12:25 <mjrosenb> acowley: i *have* found bugs in released type checkers before...
10:12:26 <acowley> that's my point! When I get a plausible-sounding, personal email from a stranger who seems to have their wires crossed, I need to decide if the phishers have gotten really smart or if I should let the person know of their mistake
10:13:35 <acowley> mjrosenb: well, we've all seen "the impossible" happen, too, but I still say that you need to work really, really hard to eliminate other possibilities before you're justified in blaming the compiler
10:13:54 <acowley> (in the case of popular compilers, not your weekend project compiler)
10:15:15 <singpoly1a> So, I had a thought earlier taht Haskell probably doing memoization automatically, and so I should be able to write (eg) tree recursive fibonacci without significant performance problems.  Actually trying that on GHC, however, shows the tree recursive fibonacci still very slow compared to the linear iterative one
10:16:48 <monochrom> correct, you have to do work to get memoization
10:18:54 <mjrosenb> unless you consider "storing computations that are actually the same, rather than just look the same" to be memoization
10:19:33 <mjrosenb> e.g. let x = expensive_computation 1000000000 in (x,cheap_computation x)
10:23:48 <singpoly1a> ok, so I found the wiki page and wrote http://pastie.org/2351444 which does what I originally expected.  not entirely sure what's going on in that code
10:25:42 <clsmith> huh, the monadic join makes way more intuitive sense than bind does
10:25:46 <parcs> @src unfoldr
10:25:46 <lambdabot> unfoldr f b  = case f b of
10:25:47 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
10:25:47 <lambdabot>    Nothing        -> []
10:26:06 <benmachine> clsmith: bind tends to be more useful in practice
10:26:10 * hackagebot language-haskell-extract 0.2.1 - Module to automatically extract functions from the local code.  http://hackage.haskell.org/package/language-haskell-extract-0.2.1 (OscarFinnsson)
10:26:12 * hackagebot test-framework-th 0.2.2 - Automagically generate the HUnit- and Quickcheck-bulk-code using Template Haskell.  http://hackage.haskell.org/package/test-framework-th-0.2.2 (OscarFinnsson)
10:27:12 <clsmith> benmachine: well, apparently bind is just (\x f -> join $ fmap f x), so it's kinda redundant. i don't know, maybe people do "special things" with it :p
10:27:30 <benmachine> clsmith: join is just \x -> x >>= id
10:27:41 <benmachine> so they're each as redundant as each other in a sense
10:27:58 <benmachine> but when you're writing code, bind tends to be more common
10:28:05 <clsmith> yeah. i don't know, learning about join just made sense a lot quicker than bind did
10:28:11 <benmachine> sure
10:28:17 <benmachine> people have different experiences though
10:28:29 <benmachine> I like (=<<) better than (>>=)
10:28:38 <mjrosenb> clsmith: possibly because most instantiations of it have an analogue with a different name.
10:28:53 <monochrom> singpoly1a: that code creates only one copy of "(map fib [0..])" and looks it up every time
10:29:28 <benmachine> mjrosenb: what is there apart from concat?
10:29:50 <singpoly1a> monochrom: sure, but what specifically makes that get cached but just defining fib you don't get caching?
10:30:00 <mjrosenb> benmachine: sml has one for maybe, but i guess haskell does not have that one :(
10:30:59 <monochrom> there is no caching. understand that first.
10:32:29 <monochrom> there is only certain names in scope pointing to data in the heap. understand that secondly
10:33:13 <monochrom> if you write "x = [True, False, True]" at the top level, how many lists does that generate, ever?
10:33:26 <singpoly1a> monochrom: hopefully only one
10:33:39 <monochrom> yes.
10:33:47 <copumpkin> well, you can be pedantic
10:34:20 <copumpkin> > tail [True, False, True]
10:34:21 <lambdabot>   [False,True]
10:34:23 <monochrom> if you write "y () = [True, False, True]", y does not point to a list, y points to a function, anyone could use that function to generate yet another list
10:34:27 <copumpkin> > tails [True, False, True]
10:34:28 <lambdabot>   [[True,False,True],[False,True],[True],[]]
10:35:28 <singpoly1a> mfib = ((map fib [0..]) !!)     also points to a function, though
10:35:45 <monochrom> of course, "y () = blah blah" generates only one function, but that's irrelevant today
10:37:22 <monochrom> ok, I guess "y () = blah blah  generates only one function" is relevant afterall
10:38:16 <monochrom> "mfib = blah blah" generates only one function, but you can set up that function to point to just one list and hold on to it forever. then there is only one list, too
10:39:58 <monochrom> to make it explicit, "y = let s=[True, False, True] in \() -> s" vs "y = \() -> let s=[True, False, True] in s"
10:42:05 <singpoly1a> so... I'm not really clear on what makes it decide the list is just one list instead of a list it needs to recompute
10:42:53 <mun> hi
10:43:43 <mun> i have a question about FOL and HOL again in terms of functions having other functions as arguments. according to the wikipedia article on FOL, it says: "The adjective "first-order" is used to distinguish first-order theories from higher-order theories in which there are predicates having other predicates..."
10:44:18 <mun> so it seems to imply that in FOL, (Int -> Int) -> Int cannot be expressed. but that's not true.
10:44:32 <edwardk> sm_ you can store heterogeneous values, the value 'type' has kind * -> *, so you can use a (contra)functor of the argument type, or whatever you want.
10:45:17 <monochrom> let's use an unsafe method to see. import Debug.Trace and try these two examples: "y1 = let s = trace "hello" [True, False, True] in \() -> s", "y2 = \() -> let s = trace "hello" [True, False, True] in s"
10:45:25 <mizu_no_oto> is it possible to get heap usage statistics from a function in ghci?  e.g. the number of allocations made during execution of the function, or some such?
10:45:57 <monochrom> evaluate both "y1 ()" and "y2 ()" several times, see under what circumstances "hello" is printed
10:46:54 <benmachine> mizu_no_oto: you can get very crude statistics with :set +s
10:46:59 <Dashkal> I was reading the notes about safe haskell and one thing jumped out at me as confusing: How does GeneralizedNewtypeDeriving allow one to violate module export restrictions?
10:47:00 <dpratt71> anyone here have a problem with leksah-server running out of memory?
10:47:03 <benmachine> mizu_no_oto: if you want more than that you'll have to use profiling I think
10:47:07 <monochrom> "create the data structure before I even look at parameters" vs "look at parameters before deciding to create the data structure"
10:47:15 <Saizan> mun: you're missing the distinction between "function" and "predicate"
10:48:31 <mun> Saizan, can a predicate not be viewed as a function returning a boolean value?
10:49:02 <monochrom> you can also try it on mfib = trace "hello" ((map fib [0..]) !!)
10:49:56 <singpoly1a> monochrom: so, as long as the data structure is set up logically before any parametres are considered then it will only be set up once?
10:50:03 <monochrom> err, maybe better is mfib = ((trace "hello" (map fib [0..])) !!)
10:50:35 <parcs> why isn't there an unfoldl?
10:50:40 <monochrom> yes
10:50:44 <singpoly1a> parcs: There is, in Data.Seq
10:51:12 <singpoly1a> monochrom: and (
10:51:42 <singpoly1a> monochrom: and because fib doesn't mention its arguments at all it counts?  so would mfib n = ((map fib [0..]) !! n)    not work?
10:52:02 <monochrom> try it!
10:52:04 <parcs> in what package is Data.Seq
10:52:26 <singpoly1a> monochrom: just tried it, still worked.  so I'm not sure why that map gets counted as something to only do once
10:52:47 <singpoly1a> oh!  because it's not *in terms of* the params?
10:52:56 <parcs> @hoogle unfoldl
10:52:56 <lambdabot> No results found
10:53:07 <monochrom> what is "work"? "work" = "fast"?
10:53:20 <singpoly1a> parcs: sorry.  Data.Sequence
10:53:24 <singpoly1a> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Sequence.html
10:53:56 <Saizan> mun: not wrt this restriction that FOL makes, i.e. in this formalization predicates and functions have pretty distinct roles
10:54:09 <singpoly1a> monochrom: "work" is "only creates the data structure once"
10:54:15 <parcs> singpoly1a: i don't see an unfoldl there
10:54:55 <singpoly1a> parcs: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html
10:55:03 <singpoly1a> there, that's the best docs.  it's listed there
10:55:49 <mun> Saizan, right. so how are predicates interpreted in this context?
10:55:52 <singpoly1a> monochrom: hmm, re-looking at your examples, nothing is in terms of the params, so that's not it
10:56:57 <monochrom> "mfib n = ((map fib [0..]) !! n)" is very slow
10:57:23 <coppro> wha
10:57:27 <parcs> why isn't there an unfoldl in base for lists?
10:57:27 <coppro> that's a horrible horrible thing to do
10:57:43 <monochrom> adding "trace "hello"" to it shows that many lists are created
10:57:44 <Saizan> mun: in FOL you have functions building up objects in your "universe of discourse" and predicates being properties that these objects (or tuples of objects) can have
10:58:18 <singpoly1a> monochrom: "mfib n = ((map fib [0..]) !! n)" is fast for me...
10:58:33 <Saizan> mun: it's quite clear if you look at the formal grammar for FOL formulas
10:58:47 <monochrom> try "mfib 50"
10:59:18 <singpoly1a> monochrom: I am.  seems the same speed as without the n
11:00:00 <monochrom> mfib n = (trace "hello" map fib [0..] !!) n   reload, evaluate mfib 5, how many times "hello" is printed?
11:00:10 <dafis> singpoly1a: which GHC version, what compile options?
11:00:12 <monochrom> s/reload/save, reload/
11:00:26 <singpoly1a> dafis: 6.12.1, just --make
11:01:12 <singpoly1a> wtf, now it's slow :P
11:01:19 <parcs> anyway the unfoldl in Data.Sequence isn't truly unfoldl i think
11:01:19 <singpoly1a> maybe it wasn't recompiling when I told it to
11:01:40 <dafis> hmm, I think 6.12 definitely didn't memoise mfib n = (map fib [0 .. ]) !! n
11:02:01 <singpoly1a> dafis: yeah, it seems it wasn't recompiling properly or something
11:02:14 <dafis> singpoly1a: anyway, compile with -O (or -O2)
11:03:03 <mun> Saizan, but in FOL, the universe does not contain functions, right?
11:03:46 <singpoly1a> monochrom: ok, so, basically it will only create it once if there are no parameters at all, and otherwise it will create it every time?
11:04:20 <mun> Saizan, what do you mean by "building up"?
11:04:36 <ski> mun : in FOL, there is no function application expressions where you apply a function expression to an argument expression
11:05:16 <ski> mun : if you want, you could have a function symbol `apply' that can be applied to two expressions, the first of which will be interpreted as a function
11:05:19 <monochrom> yes. optimizations may change it.
11:05:47 <mun> ski, so f(f) where f :: Int --> Int is not a FOL formula?
11:05:47 <ski> mun : also note that usual formulations of FOL are single-typed/sorted
11:08:02 <ski> mun : yes, both because it's ill-formed, and because there are no types
11:08:08 <RGW> Do you know a neat tutorial for Text.XHtml apart from the module-documentation
11:09:05 <mun> ski, according to the wikipedia page on FOL, functions are terms and functions are in the shape of f(t1,...,tn) where t1...tn are terms. since t1..tn are terms, so that means f(f(t1..tn)) is a valid FOL sentence. no?
11:10:33 <ski> mun : no, since each function symbol has a single associated arity (which is the vestige of types left)
11:11:16 <mun> ski, sorry, i should have meant f(g...) where f and g are functions
11:11:31 <rampion> anyone here able to help me w/ cabal?
11:11:38 <ski> in that case, yes (assuming the arities are right)
11:11:41 <rampion> I'm thoroughly confused
11:11:53 <Lycurgus> rampion, there's a channel for that, I think
11:11:55 <dafis> rampion: by what?
11:11:56 <mun> ski, ok. so functions taking in functions are valid in FOL.
11:12:05 <ski> mun : no, that's another thing
11:12:07 <monochrom> make fewer assumptions to become less confused
11:12:10 <rampion> #cabal?
11:12:17 <Lycurgus> or ##
11:12:28 <ski> mun : `f(g(t_1,...,t_n))' is `f' taking the result of `g' applied to `t_1',...,`t_n'
11:12:36 <Lycurgus> or -install, i forget
11:13:24 <ski> mun : in FOL, functions means either function symbols or "terms with holes in them"
11:13:25 <mun> ski, oh right. so f(g) would be something invalid.
11:13:37 <ski> yes, assuming `g' is a function symbol
11:13:41 <mun> ski, yes.
11:13:44 <ski> `f(g())' would be ok, though
11:13:52 <joe6> is there a better way of writing this: startProgramming (undefined :: Fd) >> return (undefined :: Word8) >>= (\x -> endProgramming (undefined :: Fd) >> return x) :: IO Word8
11:14:13 <ski> (if `g' had arity zero, in which case it's often called a constant and `g()' is often shortened to `g')
11:14:22 <joe6> startProgramming (undefined :: Fd) :: IO ()
11:14:29 <mun> ski, so on "The adjective "first-order" is used to distinguish first-order theories from higher-order theories in which there are predicates having other predicates..." how are predicates and functions differ?
11:14:44 <joe6> endProgramming (undefined :: Fd) :: IO ()
11:15:09 <monochrom> "return 5 >>= \x -> ...x..." = "...5..."
11:15:16 <ski> mun : functions build terms, predicates build formulae
11:16:09 <ski> mun : to be able to describe higher-order functions and predicates, you need at least some aspects of types, though
11:16:33 <hpaste> dainanaki pasted “Type Confusion” at http://hpaste.org/50148
11:16:38 <hatds> joe6: look up "bracket" from Control.Exception
11:16:42 <mun> ski, FOL has types, right?
11:16:46 <joe6> monochrom, was that for me?
11:16:47 <dainanaki> Hmm, I'm having a hard time wrapping my mind around how to make something like this work.
11:16:50 <monochrom> yes
11:17:00 <dainanaki> Could someone give me guidance?
11:17:19 <dainanaki> namely, in my pasted example, how can I make Arb work?
11:17:29 <joe6> monochrom: I put return (undefined :: Word8) as a placeholder for another function.
11:17:33 <ski> mun : no, usual formulations of FOL does not have types
11:17:42 <joe6> hatds: bracket should do it. Thanks.
11:18:06 <rwbarton> isn't a "structure" basically a little type system
11:18:17 <monochrom> well, then you should write >> somebody :: IO Word8 >>= \x ->
11:19:05 <rwbarton> oh I guess some formulations only have one "sort" or whatever they call it
11:19:38 <monochrom> and then you could define "f somebody = startProgramming undefined >> somebody >>= \x -> endProgramming undefined >> return x" if you find it resuable
11:19:42 <mun> ski, according to the page: "Each function symbol f of arity n is assigned a function I(f) from Dn to D. In particular, each constant symbol of the signature is assigned an individual in the domain of discourse."
11:19:50 <dainanaki> monochrom: you're familiar with existential quantification & GADTs right?
11:19:51 <mun> ski, "Each predicate symbol P of arity n is assigned a relation I(P) over Dn or, equivalently, a function from Dn to {true,false}."
11:20:02 <monochrom> I don't know how familiar I am
11:20:16 <ski> mun : indeed. note how there's only a single domain `D'
11:21:21 <ski> mun : to some extent, you could consider the arities "types" .. but the argument tuples are not first class
11:22:55 <joe6> monochrom: that works like a charm. Thanks.
11:22:59 <monochrom> the benefit of a higher-order logic with a type system is that you can unify terms, formulae, sentences. you just look at the type, Int vs Int->Bool
11:23:08 <mun> ski, so if one wants types on top, then one would need a higher order logic?
11:23:26 <ski> yeah, or at least a many-sorted/typed logic
11:23:54 <ski> (consider e.g. universal algebra)
11:24:21 * ski mumbles something about `Bool' and `Prop'
11:24:42 <monochrom> you and your heretic intuitionistic logic
11:25:38 <monochrom> Prop/=Bool is for paranoid people only!
11:27:07 <mun> ski, ok, right. so does functions taking functions as arguments fall under "predicates having other predicates or functions as arguments"? since we're keeping quite a clear distinction between functions and predicates in this context.
11:27:28 * ski . o O ( `(forall P : A -> Prop. exists n : Nat. R (P,n)) -> (exists n : Nat. forall P : A -> Prop. R (P,n))' )
11:28:16 <ski> mun : you could probably add predicatates taking predicates without adding functions taking functions, and vice versa
11:28:31 <ski> .. the possibilities are endless ! ;)
11:29:37 <monochrom> if you bound the order, e.g., making it 2nd-order, there are only finitely many combinations
11:31:09 <mun> ski, ok. so why does FOL cannot have types? in description logics, the notion of classes could be viewed as types (of course, they are simply sets).
11:31:43 <ski> it's not so much that it cannot have types than that it traditionally hasn't had types
11:31:50 <monochrom> FOL can have types. but people don't want that, apart from arity and "function/=predicate"
11:32:25 * ski thinks the "arities" described in one of the books on Martin-Lf type theory are interesting
11:32:48 <monochrom> actually "function/=predicate" stems from "term/=sentence"
11:33:01 <parcs> @djinn ((((a -> b) -> c) -> d) -> e) -> (a' -> a) -> ((((a' -> b) -> c) -> d) -> e)
11:33:02 <lambdabot> -- f cannot be realized.
11:33:05 <rwbarton> in practice most of the theories you'd want to study like the theory of groups or whatever only need one type (element of the group)
11:33:25 <ski> parcs : obviously ..
11:33:29 <monochrom> two types, the group and the booleans
11:33:37 <rwbarton> and also I guess you can always convert a theory in a multisorted logic to a theory in a logic with one sort, so there's no loss of generality in the theory
11:33:46 <monochrom> rather, two ground types, the group and the booleans
11:33:52 <rwbarton> well, booleans are sort of grandfathered in
11:34:16 * ski mentions vector spaces and modules and (multi-edge) graphs
11:34:31 <rwbarton> sure, hence most
11:34:51 <parcs> ski: my naive intuition tells me otherwise
11:35:02 <monochrom> @djinn ((((a -> b) -> c) -> d) -> e) -> (a -> a') -> ((((a' -> b) -> c) -> d) -> e)
11:35:03 <lambdabot> f a b c = a (\ d -> c (\ e -> d (\ f -> e (b f))))
11:35:43 <monochrom> @djinn a -> (a -> a') -> a'
11:35:43 <lambdabot> f a b = b a
11:35:50 <benmachine> @. pl djinn ((((a -> b) -> c) -> d) -> e) -> (a -> a') -> ((((a' -> b) -> c) -> d) -> e)
11:35:50 <lambdabot> f = (. (flip (.) . flip (.) . flip (.))) . (.)
11:36:05 <monochrom> @djinn ((a -> b) -> c) -> (a -> a') -> ((a' -> b) -> c)
11:36:05 <lambdabot> f a b c = a (\ d -> c (b d))
11:36:11 <monochrom> that is the pattern
11:36:19 <dcoutts> rampion: cabal Qs are legit here
11:36:31 <parcs> ah right
11:36:39 <parcs> a -> a', not a' -> a
11:36:51 <monochrom> in "a" alone, "a" is covariant. in "((a->b)->c)", "a" is covariant again. etc.
11:37:10 <ski> parcs : you're basically trying `forall a0 a1. (a1 -> a0) -> (f a0 -> f a1)' where `forall x. f x = ((((x -> b) -> c) -> d) -> e)' and since `x' occurs in `f x' covariantly, this doesn't work
11:37:30 <mun> monochrom, so in HOL, function == predicate?
11:38:02 <monochrom> at least in two higher-order-logic theorem provers I have seen
11:38:26 <monochrom> but they have real type systems too. perhaps that is the real reason
11:38:36 <ski> mun : rather predicates are functions with a specific codomain (like `Prop')
11:39:17 <dainanaki> Is it possible to make a typeable instance for a data type of kind (* -> *) -> *?
11:39:28 * ski can't refrain from smiling when seeing mun's nick
11:39:32 <roconnor> edwardk: I'm back
11:39:49 <ski> dainanaki : i think you need a new class for that
11:39:57 <monochrom> if you have a dumb type system, you build it right into the syntax and not bother to have a separate type system
11:40:03 <dainanaki> ski: what do you mean?
11:40:17 <ski> @type Data.Typeable.typeOf
11:40:18 <lambdabot> forall a. (Typeable a) => a -> TypeRep
11:40:19 <mun> ski, right.. ok things are much clearer now. thanks!
11:40:21 <ski> @type Data.Typeable.typeOf1
11:40:22 <lambdabot> forall (t :: * -> *) a. (Typeable1 t) => t a -> TypeRep
11:40:37 <mun> ski, my nick??
11:40:53 <ski> dainanaki : `Typeable :: * -> constraint', `Typeable1 :: (* -> *) -> constraint'
11:40:58 <dainanaki> I got it.
11:41:19 <dainanaki> Thanks!
11:41:32 <ski> dainanaki : you want `TypeableFoo :: ((* -> *) -> *) -> constraint', but `Typeable2 :: (* -> * -> *) -> constraint'
11:41:39 <rampion> dcoutts Lycurgus: So here's my cabal question in long-form: http://stackoverflow.com/questions/7016319/cabal-cabal-configure-fails
11:41:44 <ski> mun : "mun" means "mouth" in swedish :)
11:43:00 <dcoutts> rampion: you can't build the base package with cabal, it can only be done as part of the ghc build
11:43:12 <mun> ski, oh!! lol
11:43:13 <Lycurgus> rampion, will shave my yak after I decide what color to paint the bikeshed
11:43:29 <monochrom> perhaps rampion just wants the doc
11:43:29 <rampion> ok, I'm good with that
11:44:31 <monochrom> but of course the first obstacle is that cabal-install treats base specially regarding which version of base to choose. this is why it goes for 3.x
11:45:29 <rampion> so cabal configure; cabal haddock worked fine for another package (AC-PPM)
11:45:30 <profmakx> I am having  a strange problem here, perhaps some of the more knowledgable people can help me with that: I produce a list of (almost) all strings over an alphabet (a monoid generating set of a group) while keeping track of exponent sums. so far so good, if I now filter for balanced word the memory use explodes. where am i being stupid?
11:45:32 <monochrom> but with or without that, "cabal configure" is going to be really weird. yes yes, you just want the doc, but "cabal configure" does not know that
11:45:52 <rampion> which let's me go back down my yak-shaving tree to the person who suggested trying that
11:46:00 <rampion> s/let's/lets
11:46:01 <ski> dainanaki : so you want such a `class TypeableFoo (f :: (* -> *) -> *) where typeOfFoo :: f g -> TypeRep' and also `instance (TypeableFoo f, Typeable1 g) => Typeable (f g)'
11:46:04 <dcoutts> you really do have to configure to be able to build the docs
11:46:13 <dcoutts> haddock needs the dependent packages too
11:46:15 <bscarlet> what does it mean that I can't build a package for lack of "ghc -any"?
11:46:36 <dainanaki> ski: thanks. I ended up just existentially quantifying away the (* -> *) as a simpler solution.
11:46:43 <rampion>  dcoutts: So should I not be able to run haddock on a simple .lhs file?
11:47:24 <dcoutts> rampion: you should be able to do that fine
11:47:47 <dcoutts> rampion: but you're talking about building the docs for the base package, the answer is don't do that
11:47:54 <monochrom> bscarlet, you have too many packages and too many versions installed. that breaks things. look at the output of "ghc -v" and be horrified. see my http://www.vex.net/~trebla/haskell/sicp.xhtml
11:48:00 <dcoutts> rampion: just use the ones supplied with ghc
11:48:00 <rampion> oh, I'm fine with not building the docs for the base package
11:48:03 <ski> dainanaki : hm, that works in your case as well ?
11:48:14 <rampion> the problem I'm really trying to solve is http://stackoverflow.com/questions/6986854/haskell-ghc-using-haddock-on-osx
11:48:50 <dainanaki> Yes, because all of the types of kind (* -> *) will be monad instances.
11:49:30 <monochrom> by default, haddock cannot find links to those things and emit those warnings. do you really know its consequences?
11:49:44 <rampion> Nope! :)
11:49:59 <dafis> rampion: methinks you would have to tell haddock to use the index files for the installed docs to get it to link to
11:50:18 <monochrom> its worse consequence is only that in the doc of TrianglePuzzle, whenever you see "Bool" you don't have a link to a doc page on what is "Bool"
11:50:34 <dafis> rampion: just put your Triangle thingy in a cabal package and use cabal haddock on that
11:51:09 <mistertim> hi all - I've got a problem that's causing me a fair bit of brain-ache, involving combining a list of (independent) stateful functions into one function. I've written it out in more detail here: https://gist.github.com/1137865 I'm sure it's probably fairly simple, but does anyone have any idea how I can do this in an elegant, idiomatic way?
11:51:12 * hackagebot bindings-ppdev 0.0.1 - PPDev bindings  http://hackage.haskell.org/package/bindings-ppdev-0.0.1 (SivaramGowkanapalli)
11:51:16 <monochrom> if you add the correct switch with some correct path to your haddock command, you can get that back. cabal does that, so cabalize your thing
11:51:19 <dcoutts> rampion: the fact is, the args you have to supply to haddock are rather involved
11:51:28 <joe6> i uploaded a wrong package to hackage. Is it possible to delete it?
11:51:46 <rampion> dcoutts: Ah good to know.  I assumed it was fairly smart.  Wrong assumption.
11:51:56 <dcoutts> joe6: only by asking someone to do it manually
11:52:39 <dcoutts> rampion: when you do it via cabal haddock -v, you'll see that it passes a --read-interface flag for every package your package depends on, that's how it links to the docs of other packages.
11:53:02 <bscarlet> monochrom: what should I be looking for to be suitably horrified? I see a list of 10 moderately interesting lines, the first two of which look perhaps moderately dubious (hiding package foo-x to avoid conflict with later version foo-y), and the other 8 of which of the fairly innocuous looking wired-in package bar mapped to bar-z.
11:53:19 <monochrom> not dubious. fatal errors
11:53:39 <rampion> dcoutts: Thanks for the explanation!
11:53:42 <hpaste> DukeDave annotated “Error with default class function” with “Error with default class function (annotation) (annotation)” at http://hpaste.org/50143#a50150
11:54:00 <willem> How do you group patches? I've read on the darcs wiki that no patch should alter more than one file. Is this correct?
11:54:17 <monochrom> one of them is "package ghc-<version here> is unusable because ..." and that is why you can't build more packages
11:54:19 <dcoutts> willem: no, it's perfectly reasonable to alter multiple files.
11:54:37 <dcoutts> willem: a patch should be one logical change, even if it spans multiple files.
11:55:00 <DukeDave> rwbarton: ski: I've made some changes as per your suggestions, and now I have an even more bizarre error ^
11:55:01 <monochrom> whereas "wired-in etc" is normal
11:55:24 <edwardk> roconnor: did you get a chance to figure out that telescope impl?
11:55:26 <willem> dcoutts: Yeah I was expecting something like that. Thanks.
11:55:29 <bscarlet> monochrom: I see no such line. Did you mean I should run "ghc -v" or that I should add -v to some part of the build giving me trouble?
11:55:37 <monochrom> "ghc -v"
11:55:49 <roconnor> edwardk: nope.  I haven't thought about it at all.
11:55:56 <roconnor> I just got back
11:56:05 <ski> DukeDave : your `transform_' in `Transformable' is ambiguous, its type doesn't mention `bPos'
11:56:08 <bscarlet> monochrom: then I see no such "...is unusable..." line.
11:56:13 <roconnor> edwardk: what is a telescope?
11:56:23 <hpaste> DukeDave annotated “Error with default class function” with “Error with default class function (annotation) (annotation) (annotation)” at http://hpaste.org/50143#a50151
11:56:25 <edwardk> well, it was a bunch of lenses in a series ;)
11:56:34 <roconnor> *L*
11:56:53 <roconnor> different sort of telescope than I was thinking of (I was thinking a long dependent record type)
11:56:55 <edwardk> something like — telescope :: [Lens (f (Cofree f a)) (Cofree f a)] -> Lens (Cofree f a) a
11:56:57 <edwardk> yeah
11:57:05 <DukeDave> ski: I thought as much, can I specify which transform_ it should use?
11:57:27 <monochrom> well then, perhaps you are one of those fedora users, which fragments ghc too much and omits packages that everyone else has
11:57:32 <edwardk> basically i was thinking about lenses for keyed functors, and cofree is kind of my goto example
11:57:52 <roconnor> edwardk: keyed functors is your new name for napierian/representable functors?
11:57:58 <DukeDave> ski: I had hoped by adding a type (:: ModelPosition) after the transform_ call I could force it, but that doesn't seem to work :(
11:58:04 <edwardk> well, keyed is weaker than representable
11:58:05 <roconnor> edwardk: BTW, I see reprsentable functors everywhere now. :/
11:58:09 <edwardk> hahah
11:58:11 <edwardk> welcome to my life
11:58:31 <edwardk> roconnor: the keys package provides a bunch of combinators that are mostly weaker than representable
11:58:43 <edwardk> Indexable from there makes one half of the Representable isomorphism
11:58:44 <mreh> does import qualified not import everything by default?
11:58:44 <lambdabot> mreh: You have 1 new message. '/msg lambdabot @messages' to read it.
11:59:12 <ski> DukeDave : the problem is that it thinks that it is possible to have another instance `Transformable ModelPlane ScreenPlane ModelPosition bPos', for a type `bPos' different from `ScreenPosition'
11:59:12 <bscarlet> monochrom: bingo. Slightly old fedora too (13). The second part of your diagnosis interests me, though. It sounds like something might be improved if I were to install those packages which 'everyone else has'.
11:59:15 <edwardk> but in there are a ton of instances that lift the 'key' from the underlying functor into a cofree comonad
11:59:22 <edwardk> so i was curious if i could do the same thing with the lenses
11:59:54 <DukeDave> ski: Figures, I'm just confused why this doesn't fix it: http://hpaste.org/diff/50151/50152
11:59:57 <ski> DukeDave : since the type of `transform_' doesn't mention `bPos', it can't use the calling context (argument and result types) of the call to `transform_' to decide which instance to use
12:00:03 <roconnor> edwardk: lift the key?
12:00:06 <edwardk> and i rather like the idea of using (forall a. Lens (f a) a) as an 'index' onto a structure
12:00:27 <edwardk> open the keys package and look at the instances for a sec
12:00:48 * roconnor opens Data.Key
12:00:58 <edwardk> type instance Key (Cofree f) = [Key f]
12:01:08 <edwardk> the key is your 'Log'
12:01:12 * hackagebot bindings-ppdev 0.0.2 - PPDev bindings  http://hackage.haskell.org/package/bindings-ppdev-0.0.2 (SivaramGowkanapalli)
12:01:24 <monochrom> the package "ghc" refers to a lib that comes with GHC (the compiler) and lets you write your own programs that calls out some of GHC's functionality (e.g., you can drive GHC's interpreter). on fedora it is split out as another rpm. I'm too lazy to look up which. it takes a lot of fighting against rpmfind.net's dumb search engine
12:01:40 <DukeDave> ski: Do you know if there is a way around it? Thanks by the way :)
12:01:50 <ski> DukeDave : the problem is that it knows it must use a `transform_ :: ModelPlane -> ScreenPlane -> ModelPosition -> ModelPosition', but it doesn't know *which* instance `Transformable ModelPlane ScreenPlane ModelPosition bPos' it should select that `transform_' implementation from
12:01:57 <edwardk> so if I know Log of f, then Log (Cofree f) = [f] lets you index into a cofree comonad
12:02:26 <edwardk> er then Log (Cofree f) = [Log f] lets you go back and forth from Cofree f a to [Log f] -> a
12:02:30 <DukeDave> ski: Ahaaa, I see, so it can only work the types out from the instance, but not the other way round...?
12:02:52 <dpratt71> getting an error trying to build in leksah that apparently comes from GHC: Setup: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.8.0.6, now Cabal-1.10.1.0). Additionally the compiler is different (was ghc-6.10, now ghc-7.0) which is probably the cause of the problem.
12:03:04 <dpratt71> what configure command?
12:03:29 <rwbarton> it can work out which instance to use *if* every type variable of the class appears as part of the type of the function you're using
12:03:55 <roconnor> edwardk: that seems to make sense
12:04:02 <ski> DukeDave : it tries to figure out which types `aPlane',`bPlane',`aPos',`bPos' to use in the instance, from knowing what the types `aPlane',`bPlane',`aPos' are from the call to `transform_ :: aPlane -> bPlane -> aPos -> aPos'
12:04:16 <edwardk> roconnor: of course it does =)
12:04:19 <roconnor> edwardk: now you want to update rather than just read?
12:04:21 <monochrom> it means "cabal configure" or "Setup configure"
12:04:32 <monochrom> or "runghc Setup.hs configure" or ...
12:04:39 <edwardk> well, i was just thinking about adding a combinator for telescoping through a bunch of lenses to the data-lens library
12:04:53 <ski> DukeDave : the problem is that knowing the types of the arguments and result of `transform_' still doesn't determine the type `bPos', and so it can't fully determine which instance `Transformable aPlane bPlane aPos bPos' to use, i.e. which implementation of `transform_'
12:04:55 <roconnor> edwardk: did you look at this pez?
12:05:08 <edwardk> had the thought on the ride in, but didn't get a chance to hack on it
12:05:11 <edwardk> pez?
12:05:18 <roconnor> http://hackage.haskell.org/package/pez
12:05:45 <roconnor> perhaps it is unrelated; I haven't looked at it myself
12:05:52 <ski> DukeDave : for all it knows, you could later add a `instance Transformable ModelPlane ScreenPlane ModelPosition Color', with a different implementation of `transform_ :: ModelPlane -> ScreenPlane -> ModelPosition -> ModelPosition'
12:06:02 <edwardk> looks messy
12:06:13 * hackagebot bindings-parport 0.0.1 - parport bindings  http://hackage.haskell.org/package/bindings-parport-0.0.1 (SivaramGowkanapalli)
12:06:18 <edwardk> i prefer the focused state hack i gave the snap guys
12:06:29 <DukeDave> ski: Gotha
12:06:33 <dpratt71> monochrom: ok, I think I'm farther ahead now, thanks
12:06:40 <roconnor> okay, let us ignore pez for the moment.
12:06:57 <DukeDave> ski: It looks like I makes more sense to go back to have three separate type classes then
12:07:04 <ski> DukeDave : usual solutions are what i said before : (a) add an FD (only do that if it's sensible in your problem domain. if it's not, it will cause problems); (b) split the class (possibly with superclassing)
12:07:08 <DukeDave> ski: Which is what I did before
12:07:14 <edwardk> roconnor: well, the problem is pretty succinctly stated. just need to implement ;)
12:07:21 <joe6> i uploaded this package uri: http://hackage.haskell.org/package/bindings-parport-0.0.2 . Wondering if you have any comments, please?
12:07:34 <edwardk> actually, i'm not sure if i made cofree representable, hrmm
12:07:34 <roconnor> edwardk: so we just need to write telescope?
12:07:35 <ski> DukeDave : another solution which is sometimes useful is adding a dummy (unused) argument which mentions the missing type variable
12:07:36 * DukeDave is tempted by FDs because he's never used them and they sound impressive
12:07:37 <joe6> anything I can learn or do better?
12:07:37 <edwardk> yeah
12:07:56 <ski> DukeDave : edwardk can tell you how to do that without actually have to pass an `undefined' argument
12:07:58 <rwbarton> DukeDave: if you don't need nondefault definitions of transform then you could pull it out of the type class and then remove the bPos type argument
12:08:00 <roconnor> so telescope [] = fstLens -- roughtly speaking
12:08:09 <edwardk> roconnor: yeah that one is easy
12:08:18 <edwardk> the rest arent hard
12:08:26 <edwardk> just were harder than i could do with a screaming kid sitting next to me
12:08:34 <edwardk> well the 'rest' is just one other case
12:08:48 <ski> DukeDave : of course another solution that sometimes is possible is factoring your functionality into operations differently .. but that probably doesn't help here
12:08:55 <DukeDave> I have the feeling this is getting silly now :(
12:09:00 <roconnor> and telescope (l,ls) = telsecope ls . l . sndLens
12:09:05 <DukeDave> ski: I was just thinking that
12:09:07 <roconnor> and telescope (l:ls) = telsecope ls . l . sndLens
12:09:17 <edwardk> hrmm
12:09:26 <roconnor> edwardk: isn't that all?
12:09:27 <edwardk> that should do it
12:09:52 <hpaste> “Noah Easterly” pasted “Awesome.lhs” at http://hpaste.org/50153
12:10:02 <DukeDave> rwbarton: I'd rather leave it in there, so I have a consistent naming scheme
12:10:08 <ski> DukeDave : adding an FD from any (one or more) of `aPlane',`bPlane',`aPos' to `bPos' should fix the technical problem in your case
12:10:21 <ski> DukeDave : the question is whether any such FD would be sensible
12:10:22 <roconnor> edwardk: *l*
12:10:40 <rampion> So what does 0% coverage mean for haddock?
12:11:25 <benmachine> rampion: none of the things in that module have documentation
12:11:26 <dafis> rampion: no haddock documentation for exported functions
12:12:05 <DukeDave> ski: Yep, adding the FD `bPlane -> bPos' does indeed work (insomuch as it compiles)
12:12:51 <roconnor> edwardk: I was making this question out to be harder than it really was.
12:12:55 <edwardk> yeah
12:13:03 <edwardk> it was just a quick 2 liner =)
12:13:23 <DukeDave> ski: A position and the plane on which it is defined are intimately linked, is that all an FD encapsulates?
12:13:48 <roconnor> edwardk: I like the name telescope.
12:14:08 * DukeDave is just trying to mash the concept of fundeps into his head
12:15:19 <ski> DukeDave : generally, if you have `class C a b c d | a c -> b', this means that `forall a c. unique b. exists d. C a b c d' which means that `forall a b0 b1 c d0 d1. (C a b0 c d0,C a b1 c d1) => b0 ~ b1'
12:16:13 * hackagebot bindings-parport 0.0.2 - parport bindings  http://hackage.haskell.org/package/bindings-parport-0.0.2 (SivaramGowkanapalli)
12:16:21 <ski> which means that if you have two potentially different instances with the `a' and `c' parts being the same, then the `b' part must also be the same -- i.e. you're not allowed to have two instances sharing the same `a' and `c' but having different `b's
12:17:22 <dafis> @hoogle Integer -> Int
12:17:22 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
12:17:23 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
12:17:23 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
12:17:25 <ski> in your case, `bPlane -> bPos' means that you're not allowed to have two instances with the same `bPlane' type but different `bPos'
12:17:28 <ski> type
12:17:43 <ski> in short : `bPlane' determines `bPos' (wrt this type class)
12:17:50 <rampion> benmachine dafis: So how do I get haddock to take a lhs file like http://gitit.johnmacfarlane.net/_showraw/Literate%20Haskell%20Example and generate a page like http://gitit.johnmacfarlane.net/Literate+Haskell+Example if it ignores the comments?
12:18:16 <DukeDave> ski: Wow, that explanation was considerably more palatable than the wiki one :)
12:18:21 <benmachine> rampion: that's not what haddock does, that's what pandoc does
12:18:30 <yitz> hi roconnor just saw your nice post
12:18:34 <roconnor> yitz: hi
12:18:35 <benmachine> rampion: there might be a good way to do it that I don't know, you should read the haddock docs
12:18:36 <ski> DukeDave : if you can conceive it useful to want to have two instances with the same `bPlane' type but different `bPos' types, then you should *not* add an `bPlane -> bPos' FD :)
12:18:57 <roconnor> yitz: it's nice isn't it. I've been meaning to write it for a year now; ever since I read those papers.
12:19:07 <DukeDave> ski: I can conceive of no such case :)
12:19:11 <yitz> roconnor: my dtd-types package already has a copy of your RE. i'd really rather import it from something more general.
12:19:32 <roconnor> yitz: I have nothing on hackage and no plans to make one.
12:19:43 <ski> DukeDave : if you feel fine with forbidding that forever (apart from changing your class, of course), then there should be no problem adding such an FD
12:19:46 <DukeDave> ski: I've extended it to this, for completeness:   | aPlane -> bPos, bPlane -> bPos where
12:19:51 <yitz> roconnor: pity
12:20:10 <ski> DukeDave : but if you're adding FDs, you should probably add all relevant ones ... yeah, like that
12:20:26 <roconnor> of course someone else can make a star-semiring package ... like edwardk =)
12:20:35 <edwardk> hah
12:20:40 <DukeDave> ski: Wow, well thanks for nursing me through my first FD :)
12:20:43 <edwardk> too much on my plate this week
12:20:48 <edwardk> busy reinventing parsing, remember? =)
12:20:56 <ski> (of course one should always add all relevant FDs, but if you only add some, then readers might think you've added all relevant ones, as opposed to not having thought about FDs at all)
12:21:07 <roconnor> I used to think dioids were some funny abstract structure that people like toying with in their spare time.
12:21:13 <yitz> edwardk: but star-semirings will solve all of those problems. certainly parsing, for example.
12:21:13 * DukeDave nods
12:21:25 * fds should've done more research before choosing his nick.
12:21:26 <roconnor> Now I think dioids are of centeral important to computer science.
12:21:28 <edwardk> yitz: you're confusing them for right seminearrings
12:21:33 <roconnor> *importance
12:21:57 <roconnor> I can't beleive I got a CS degree without being taught about dioids.
12:22:18 * yitz doesn't wear nearrings
12:22:26 <ski> DukeDave : if you know anything about (relational databases) you should note how FDs are borrowed from database theory. also the idea of splitting a type relation/class (i.e. normalization) comes from there
12:22:34 <edwardk> you will… when you find the rightseminearring ;)
12:22:44 * roconnor groans
12:23:16 <ski> fds : hehe, sorry
12:23:30 <roconnor> yitz: funny thing is that I used to think RE was about language parsing; and now i think REs are about graph traversals.
12:23:42 <fds> ski: It's my own fault really. :-)
12:23:47 <rampion> benmachine: ah, thank you.  I'd seen people posting "this page is a literate haskell file" all over the place, but never seen anyone mention pandoc, so I assumed they were using haddock.
12:24:07 <DukeDave> ski: I fear I have reached the depth of my understanding
12:24:09 <yitz> roconnor: the early RE papers are all about finite autonoma
12:24:17 <ski> fds : maybe you should change your nick to `FunctionalDependencies', since we usually don't bother to write that out in full :)
12:24:26 <benmachine> rampion: literate haskell doesn't necessarily mean pandoc
12:24:26 <DukeDave> Lol
12:24:56 <benmachine> rampion: it can just mean a text document that contains code that can be easily extracted and run
12:25:07 <benmachine> rampion: or, sometimes a LaTeX document
12:25:13 <roconnor> yitz: ya, and apparently finite automata are just a facy way of saying graph traversal ... which I suppose is a bit obvious in retrospect.
12:25:15 <yitz> fds: change your nick to ats, that'll be good for a while...
12:25:38 <ski> DukeDave : no worry if you know nothing about database theory (well, you ought to know something about that, but that's a different topic), i just wanted to connect this to that, if you already knew anything about it
12:25:57 <dainanaki> ski: I decided to follow your advice to make a new class for ((* -> *) -> *), but I'm kind of lost here. can you help me any more?
12:26:59 <ski> dainanaki : i'm not very familiar with `Data.Typable', so i think you have to explain/show a bit more what you're trying to do
12:27:21 <ski> dainanaki : afaics, you at least have to make that new class and instance i mentioned above
12:28:53 <hpaste> dainanaki pasted “Typeable Instance Brain Pain” at http://hpaste.org/50154
12:29:43 <dainanaki> Part of the problem is that Data.Typeable is really mysterious to me.
12:29:53 <DukeDave> ski: Thanks again :)
12:29:54 <dainanaki> I'm kind of fumbling in the dark on this.
12:29:58 <ski> looking at <http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.0.0/src/Data-Typeable-Internal.html#line-369> possibly gives some hint of how to do the instance
12:30:04 <ski> dainanaki : yw :)
12:30:06 <ski> er
12:30:11 <ski> DukeDave : yw :)
12:30:48 <ski> (.. clearly there should be a functional dependency from nick in #haskell to first letter of the nick)
12:31:13 * hackagebot free 2.0.1 - Monads for free  http://hackage.haskell.org/package/free-2.0.1 (EdwardKmett)
12:31:41 <edwardk> (added telescope)
12:32:59 <ski> dainanaki : i don't see a default implementation in the other `Typeable',`Typeable1',&c. classes, so i don't think you should have one either
12:33:25 <bscarlet> dainanaki: is there a reason you're not using DeriveDataTypeable and letting ghc do it?
12:33:36 <dainanaki> GHC doesn't know how.
12:33:41 <c_wraith> ghc is pretty bad at deriving typeable
12:33:45 * roconnor replaces a "[citation needed]" link on Wikipedia with a citation.
12:34:06 <ski> bscarlet : he wants a `Typeable'-like class for `(* -> *) -> *'
12:34:15 <bscarlet> ah.
12:34:36 <dainanaki> I'm beginning to think it's an exercise in futility.
12:34:50 <c_wraith> dainanaki: this isn't that hard, you just need to know a lot in advance
12:35:17 <c_wraith> dainanaki: First: implement Typeable1.  There's an instance that will take care of typeable for you, given that.
12:35:39 <c_wraith> dainanaki: second, the code for doing this will change entirely (unfortunately) in ghc 7.2
12:35:54 <dainanaki> what if I'm using 7.2 currently?
12:36:25 <c_wraith> dainanaki: then it's simpler, but mkTyCon3 doesn't exist in older versions of GHC
12:36:26 <ski> dainanaki : i think you want to do something similar to <http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.4.0.0/src/Data-Typeable-Internal.html#typeOfDefault>
12:36:46 <c_wraith> dainanaki: it's simpler because you don't need to worry about a NOINLINE pragma, because the unsafe stuff is gone
12:36:58 <ski> c_wraith : i thought dainanaki already had `Typeable1' ?
12:37:57 <c_wraith> there's an instance:  (Typeable1 t1, Typeable t2) => Typeable (t1 t2)
12:38:10 <c_wraith> If you have Typeable1, that instance should take care of your Typeable instance
12:38:32 <yitz> roconnor: perhaps you could add a few words about the two Eq instances for RE.
12:38:39 <ski> c_wraith : yeah, but dainanaki needs `instance (TypeableParam1 t1,Typeable1 t2) => Typeable (t1 t2)'
12:38:58 <yitz> roconnor: you just say that there are two, but don't say anything about how they differ
12:39:06 <ski> c_wraith : `t1 :: (* -> *) -> *',`t2 :: * -> *'
12:40:11 <roconnor> yitz: Hmm, maybe I'm unclear.  There is an algorithm that compares two REs for equality (and actually inequality), but there isn't two algorithms.
12:40:34 <roconnor> yitz: I can send you a link to a paper that implements RE comparision in coq.
12:40:42 <dainanaki> o_O
12:41:10 <yitz> roconnor: right i figured out what you meant, but the post would be more clear if you added just a few words there
12:41:10 <roconnor> dainanaki: would you like the link?
12:41:11 * ski . o O ( Recursively Enumerable )
12:41:13 * hackagebot free 2.0.1.1 - Monads for free  http://hackage.haskell.org/package/free-2.0.1.1 (EdwardKmett)
12:41:25 <yitz> roconnor: typo: "the resulting matrix is a bit to big to fit"
12:41:46 <roconnor> yitz: ah thanks.
12:42:02 <yitz> roconnor: yes, i would appreciate a link to that
12:42:29 <yitz> roconnor: though i'm not literate in coq :(
12:42:31 <dainanaki> OK, i'm just confused by this whole thing.
12:42:47 <roconnor> http://sardes.inrialpes.fr/~braibant/atbr/
12:42:51 <roconnor> yitz: ^^
12:42:57 <yitz> roconnor: thanks!
12:43:17 <siracusa> Is there already an implementation of Conor McBride's type derivatives?
12:43:47 <ski> oh, regexen
12:44:03 <roconnor> yitz: it actually decides all inequalites over kleene algebras, but the decision produce for RE actually solves all kleene algebra inequailites; it's just a bit of work to prove that this is so.
12:45:09 <yitz> roconnor: the Eq instance on RE decides if two RE's match equivalently, whereas the Eq instance on the underlying expression type compares the expressions formally.
12:45:10 <roconnor> yitz: their motiviation is to solve problems about binary relations, which can be nicely expressed in typed Kleene algebras (Kleene algebroids
12:46:27 <ski> dainanaki : afaiu, your `TypeableParam1' class is ok, except you shouldn't have a default implementation in it
12:46:35 <roconnor> yitz: well, I want the Eq instance on RE to compare the values as regular expressions. ... eg I want Empty `Seq` Empty == Empty to be true, even if they are different values.
12:47:00 <roconnor> just like 0.0 == -0.0 even if they are different floating point values.
12:47:57 <c_wraith> > 0 == -0.0
12:47:58 <lambdabot>   True
12:48:08 <c_wraith> equality!
12:48:14 <roconnor> > map (isNegativeZero) [0.0,-0.0]
12:48:15 <lambdabot>   [False,True]
12:48:19 <copumpkin> different but equal
12:48:46 <roconnor> yes
12:48:55 <copumpkin> cong on == doesn't work on floats
12:49:06 <ski> dainanaki : then you should probably define a `typeOfParam1Default :: forall t a. (TypeableParam1 t, Typeable1 f) => t f -> TypeRep'
12:49:36 <ion> > case (0.0 :: Float) of -0.0 -> "foo"; 0.0 -> "bar"; _ -> "baz"
12:49:37 <lambdabot>   "foo"
12:50:39 <ski> dainanaki : hm, i suppose it shouldn't be named `typeOfParam1Default', though, since it's really an alternate to `typeOfDefault'
12:50:45 <roconnor> ion: yep numerical literals in patterns use == under the hood.
12:50:46 <ski> dainanaki : then you can use that in your `instance (TypeableParam1 f, Typeable1 g) => Typeable (f g)'
12:51:34 <eddayyy> whats the best way to send large files across the network in haskell? currently i'm using network.bytestring.lazy to send it across
12:51:55 <eddayyy> however i'm not doing any buffering
12:52:08 <ion> The sendfile libc function if your system has one.
12:52:37 <eddayyy> ion: oh really, so using lazy bs is slower?
12:52:41 <eddayyy> (or worse?)
12:52:48 <dainanaki> ski: what's confusing me is primarily how to actually implement the function
12:53:10 <ion> eddayyy: When using sendfile, the data never goes via userspace at all.
12:53:13 <ski> dainanaki : which function ?
12:53:25 <dainanaki> the typeOfParam1 function
12:53:30 <eddayyy> ion: wow.
12:53:33 <ion> @hoogle sendfile
12:53:33 <lambdabot> No results found
12:53:43 <ski> dainanaki : for `instance TypeableParam1 ZoomTask' ?
12:53:47 <ion> It seems someone has already made a wrapper: http://hackage.haskell.org/package/sendfile
12:53:50 <dainanaki> right.
12:54:02 <Peaker> is there a torrent of the new ghc download?
12:54:22 <Peaker> also, did the ghci declarations improvement go in?
12:55:54 <eddayyy> ion: thanks dude i just checked out this package, looks like it has an amazing interface, and now i can finally have fun with iteratees!
12:56:29 <yitz> roconnor: by "values as regular expressions" you mean the way they match, not their values in the sense of elements of the type of formal regular expressions
12:56:49 <yitz> Peaker: ghci declarations improvement?
12:57:38 <Peaker> yitz: allowing declarations of new types/instances/classes in the ghci prompt
12:58:08 <roconnor> yitz: yes
12:58:48 <roconnor> yitz: I want to consider two REs as equal if they accept the same language
12:58:51 <yitz> roconnor: or you could say equal if they represent the same language accepted by the autonoma i suppose.
12:58:56 <yitz> he right
12:59:09 <ski> dainanaki : i think `instance TypeableParam1 ZoomTask where { typeOfParam1 _ = mkTyConApp zoomTaskTc []}' with `zoomTaskTc = mkTyCon3 "my-package" "My.Module" "ZoomTask"', after glancing around the source for `funTc',`realWorldTc',`instance Typeable2 (->)',`instance Typeable RealWorld'
12:59:29 <yitz> Peaker: oh yeah? wow! hope it's in.
12:59:32 <eddayyy> ion: one thing that isn't obvious from the lib is how to receive the file afterwards :p
13:00:08 <yitz> eddayyy: you don't. that's the other guy's problem.
13:00:34 <dolio> Peaker: I don't recall seeing that on the change log.
13:00:35 <eddayyy> yitz: in this case its my prob since the client is going to send files to a custom server
13:00:51 <dolio> Peaker: It has multi-line expressions without :{ :} though.
13:02:01 <Peaker> https://plus.google.com/107890464054636586545/posts/ab2seALBm8F
13:05:29 <dolio> Peaker: Yeah, that didn't make it for 7.2.
13:16:48 <clsmith> okay, so is Data.Foldable.fold a catamorphism?
13:16:53 * clsmith is struggling with all these new words :p
13:17:27 <ski> @type Data.Foldable.fold
13:17:28 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
13:17:43 <acowley> clsmith: yes
13:18:00 <clsmith> \o/ one step closer to understanding maths :p
13:18:10 <ski> i'm not sure i would call it one
13:18:20 <acowley> ski: why not?
13:18:53 <erus`> who is the google+ dev in here?
13:18:57 <ski> given a functor `f', a catamorphism for it has type isomorphic to `forall r. (f r -> r) -> (Mu f -> r)'
13:19:42 <Phyx-> Mu ==?
13:19:51 <ski> @src Mu
13:19:51 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
13:19:56 <Phyx-> ah
13:20:26 <mreh> > toEnum 12 :: Bool
13:20:27 <lambdabot>   *Exception: Prelude.Enum.Bool.toEnum: bad argument
13:20:37 <mreh> > toEnum 1 :: Bool
13:20:38 <lambdabot>   True
13:21:35 <ski> `Foldable' could probably have been named `ListLike' if one wanted to
13:21:48 <acowley> ski: but isn't Mu f the same as the recursively defined type that is an instance of Foldable?
13:22:10 <ski> `Data.Foldable.fold :: forall t m. (Foldable t,Monoid m) => t m -> m' basically is `mconcat :: forall m. Monoid m => [m] -> m'
13:23:00 <acowley> clsmith: in any case, the idea that fold <-> catamorphism is widespread and will usually be written as a generalization of the usual fold
13:23:19 <clsmith> hm, okay
13:23:24 <acowley> because fold is often specialized to lists, while a catamorphism is defined more generally for recursive types
13:23:26 <clsmith> i didn't follow the rest ;)
13:23:33 <byorgey> @hoogle unlink
13:23:34 <lambdabot> No results found
13:23:41 <Phyx-> ski: only for the list instance i would think
13:23:48 <mreh> loads of foldables aren't list like
13:23:59 <clsmith> i saw there's Foldable Maybe
13:24:03 <ski> acowley : consider `newtype TreeF a r = Leaf a | Branch r r'
13:24:04 <acowley> clsmith: when you define your own List type, you give the tail of a cons cell the type of List
13:24:06 <clsmith> which was quite strange
13:24:31 <clsmith> acowley: sure
13:24:56 <byorgey> Maybe is like a list of length at most one
13:24:57 <ski> (s/newtype/data/)
13:25:16 <clsmith> byorgey: hmm, i suppose so
13:25:26 <ski> acowley : then the catamorphism has type `forall r. (TreeF a r -> r) -> (Mu (TreeF a) -> r)', which is basically the same as `forall r. (a -> r) -> (r -> r -> r) -> (Tree a -> r)', given `data Tree a = Leaf a | Branch (Tree a) (Tree a)'
13:25:45 <clsmith> another question. isn't 'forall' kinda superfluous?
13:25:52 <byorgey> fold Nothing = mempty; fold (Just x) = x
13:26:00 <roconnor> clsmith: yes
13:26:13 <erus`> http://www.google.co.uk/trends?q=haskell%2C+depression i have observed a clear rise in depression after an increase in popularity of haskell. after Q2 2008
13:26:24 <erus`> i do not think this is a coincidence
13:26:45 <ski> mreh : afa `Foldable' is concerned, it's basically a list
13:26:46 <roconnor> depression is causing an increase in popularity of Haskell
13:26:48 <roconnor> makes sense to mee
13:26:48 <NihilistDandy> I blame all these people trying to make things more user-friendly
13:27:05 <erus`> roconnor: no the haskell comes first in the graph
13:27:30 <ski> acowley : note that `fold' as in "catamorphism" is distinct from `foldr' and `foldl'
13:27:46 <acowley> clsmith: if you couldn't write a recursive definition for some reason, you could do it yourself using something like Mu. data IntList t = Nil | Cons Int t; type List = IntList (Mu IntList)
13:27:50 <NihilistDandy> erus`: HASKELL'S METEORIC RISE
13:27:56 <roconnor> ski: it is distinct from foldr?
13:28:02 <NihilistDandy> ______-_-________
13:28:10 <erus`> lol
13:28:11 <ski> `Data.Foldable' is providing `foldr' and `foldl' for other data types, which therefore doesn't have that much to do with catamorphisms
13:28:15 <NihilistDandy> Hard to draw graphs
13:28:33 <erus`> NihilistDandy: it looks like its on the way up again :P buy buy buy
13:28:39 <ski> roconnor : in the case of right-associated lists, they coincide
13:29:14 <ski> but it's a mistake to think that the specific types of `foldr' and `foldl' generalize that directly to other types, if we're talking about catamorphisms
13:29:20 <acowley> I don't see how you can say it doesn't have much to do with catamorphisms
13:29:50 <sm> edwardk: thanks, are there any examples of code using this out there ?
13:30:09 <ski> for finite lists, you could represent them isomorphically as `data SnocList a = Nil | Snoc a (SnocList a)' -- note that here the `foldl' operation is the catamorphism
13:30:11 <sm> (stable-map)
13:30:39 <edwardk> sm: not really. i have some at home, but its mostly been for my personal projects
13:30:40 <ski> er, sorry, that should be `data SnocList a = Nil | Snoc (SnocList a) a'
13:31:00 <sm> alrighty, thanks
13:31:21 <edwardk> the api should be pretty straightforward though http://hackage.haskell.org/packages/archive/stable-maps/0.0.2/doc/html/System-Mem-StableName-Map.html
13:31:36 <ion> @hoogle Mu
13:31:36 <lambdabot> Text.Html multiple :: HtmlAttr
13:31:36 <lambdabot> Text.XHtml.Frameset multiple :: HtmlAttr
13:31:36 <lambdabot> Text.XHtml.Strict multiple :: HtmlAttr
13:31:41 <edwardk> you use the stablenames as keys, and the 'f a' term about the stable name as a value
13:31:59 <edwardk> hashically its a HashMap just using hashStableName
13:32:19 <edwardk> i probably should replace its guts with HashMap internally
13:33:09 <edwardk> er basically
13:33:11 <acowley> hashically depends on your personal hash function and what you do with collisions
13:33:20 <edwardk> =)
13:33:37 <NihilistDandy> lol
13:33:41 <acowley> these two things are hashically the same!
13:34:16 <ski> @type Data.Foldable.foldMap (:[])
13:34:17 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t a -> [a]
13:34:19 <Peaker> cabal-install's newest version is 0.10.2  (http://hackage.haskell.org/package/cabal-install)  but ghc-7.2.1 doesn't seem to be supported
13:34:30 <ski> Phyx-,acowley,clsmith : that embeds `t' into `[]'
13:34:46 <sm> I didn't quite grok it the first time but will look again. I'm thinking about heterogenous collections as a way to build cmdargs modes that compose together, without giving up rich types
13:34:48 <Peaker> does cabal-install not work with ghc 7.2.1?
13:35:01 <benmachine> Peaker: well, 7.2.1 has been out for all of a day or something :)
13:35:07 <Peaker> benmachine: :-)
13:35:29 <hvr> Peaker: cabal-install seems to lag behind GHC releases
13:35:31 <acowley> ski: I guess I still don't see how the canonical type signature you gave for a cata conflicts with Data.Foldable.fold
13:36:00 <ski> Phyx-,acowley,clsmith : so, since you can't observe any other structure with the operations in `Foldable', `t' acts like a subtype of `[]'
13:36:10 <Peaker> sm: they start out as homo-lists [String] -- you then convert them into a finite sum type of possible args, so they're still a homo list.. or you could use some nice Applicative trickery to build a big tuple out of them without an explicit sum type
13:36:18 <ski> if `t' is `Maybe' then that subtype is the subtype of lists of at most length one
13:36:28 <luite> Peaker: you can change the cabal version constriant, I did that, and it will compile
13:36:31 <acowley> ski: are you objecting to the way I happily replaced the Mu f -> r with t -> r?
13:36:39 <Peaker> luite: Bitten by over-conservative constraints again :-P
13:36:43 <luite> Peaker: but I ran into a bug, so it's probably better to use the darcs version
13:36:45 <ski> acowley : `cata' is a higher-order operation
13:36:49 <Peaker> PVP considered harmful
13:37:19 <acowley> ski: I know, but I don't understand why you feel that the type for cata prevents fold from being a cata
13:37:19 <ski>   cata :: forall f r. Functor => (f r -> r) -> (Mu f -> r)
13:37:25 <luite> Peaker: don't know if it's actually over-conservative :)
13:37:28 <sm> Peaker: thanks, what did you mean by "they" there ?
13:37:29 <ski> @type Data.Foldable.fold
13:37:29 <lambdabot> forall (t :: * -> *) m. (Data.Foldable.Foldable t, Monoid m) => t m -> m
13:37:44 <Peaker> sm: cmdline args
13:37:47 <ski> acowley : the type for `fold' there is not higher-order
13:37:51 <Peaker> sm: I'm saying hetero lists don't seem necessary anywhere
13:37:52 <acowley> yes it is
13:37:59 <ski> acowley : `fold' and `cata' are doing completely different things
13:38:07 <luite> Peaker: but you the package constraints are annoying indeed. it would be nice to have a simple way to override version constraints globally
13:38:09 <acowley> ski: the dictionary associated with the Monoid constraint carries the function
13:38:29 <ski> acowley : `fold' is merging (using a monoid) the (essential) list of elements of type `a' in the structure of type `t a'
13:38:59 <ski> acowley : `cata' is allowing the function argument to handle each constructor in the structure in a different way
13:39:14 <ion> @hoogle cata
13:39:15 <sm> Peaker: aha, well you're right that's the approach I have now - initial parsing to a map of strings with cmdargs, then convert to appropriate ADT afterwards. But I was looking for shortcuts
13:39:15 <lambdabot> No results found
13:39:19 <acowley> can't I do that with my monoid instance?
13:39:27 <ski> acowley : `fold' for a tree will ignore the nesting of the tree, once you've fixed the traversal order that `fold' will use
13:39:43 <sm> that would let me chop and change options without a lot of ongoing maintenance
13:40:00 <sm> I seem to end up with quite a lot of code no matter what
13:40:15 <ski> acowley : so `fold' is effectively operating on a list that you get from a fixed `traversal :: forall a. t a -> [a]' function
13:40:40 <ski> in general, that `traversal' operation will forget information (such as nesting) in the input
13:41:11 <ski> ion : `cata :: forall f r. Functor => (f r -> r) -> (Mu f -> r)'
13:41:26 <ski> er, s/Functor/Functor f/ :)
13:41:47 <ion> I just wanted a link to a package with preferably some haddock documentation.
13:42:00 <ski>   cata psi = loop where loop = psi . fmap loop . out
13:43:02 <ski> ion : <http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Morphism-Cata.html>
13:43:05 <ion> Thanks!
13:43:24 <ski> `FixF' is `Mu'
13:43:40 <ski> also `type Algebra f a = f a -> a'
13:44:04 <ski> so `cata :: Functor f => Algebra f a -> FixF f -> a' is my `cata :: forall f r. Functor f => (f r -> r) -> (Mu f -> r)'
13:47:47 <clsmith> it confuses me when people make types like Algebra f a = f a -> a. the unnamed meaning is more intuitive...
13:47:50 <dainanaki> Is there any way to clean up repetitive GADT declarations that only differ slightly?
13:48:21 <ski> clsmith : s/people/edwardk/ ? :)
13:48:38 <clsmith> if he is the only person ever to have done that, sure :p
13:48:51 <dainanaki> i.e. ConA :: String -> String -> Val m A, where A varies per constructor?
13:49:15 <edwardk> clsmith: i don't do that any more for that reason
13:49:26 <benmachine> dainanaki: template haskell!
13:49:41 <dainanaki> ok, I figured that was the answer.
13:49:41 <ski> dainanaki : you factor them to `Con :: Foo a -> String -> String -> Val m a'
13:49:52 <benmachine> or that
13:50:04 <ski> s/factor/could factor/
13:50:13 <clsmith> edwardk: ah :)
13:50:16 <Peaker> Is there and cmdline lib that looks like:  let Right (a, b, c)  = liftA3 (,,) (param 'a' "aaa" "Description for aaa") (param 'b' "bbb" ..) ...      using return-type polymorphism to choose how to parse the args + applicative instance to compose the parsers?
13:50:39 <Peaker> oops:   =  parseCmdLine $ liftA3 ...
13:51:04 <Peaker> could also throw "positionArg" in there for non-switch options
13:51:14 * hackagebot hstzaar 0.8.1 - A two player abstract strategy game.  http://hackage.haskell.org/package/hstzaar-0.8.1 (PedroVasconcelos)
13:51:41 <Peaker> I think all the cmdline libs require a lot more effort than that, don't they? e.g: Manually-defined sum-types
13:51:43 <dainanaki> I wish there was a way to make GADTs extensible.
13:52:13 <ski> you'd need a way to make the matching functions extensible too, for it to be useful
13:52:38 <acowley> shoot, I missed a lot of debating
13:52:56 <ski> (?)
13:53:16 <acowley> I had to leave the keyboard and didn't respond to you saying that Data.Foldable.fold isn't higher order
13:53:23 <acowley> wait, I did
13:54:24 <ion> > let a = In [In []]; cata f = f . fmap (cata f) . out in cata sum a
13:54:25 <acowley> It is higher order, as captured in the class constraint, but it's not as generic as you want for Algebra
13:54:25 <lambdabot>   0
13:54:28 <acowley> which is fair
13:54:50 <ion> Well, it typechecks. I guess i’ll need some different types to do anything useful with it. :-P
13:55:10 <ion> Anything in Prelude or lambdabot that’s useful with Mu as-is?
13:55:20 <acowley> but writing a Foldable instance that defines fold must include a case for each constructor
13:56:08 <HalfWayMan> gweber: I usually just start Irssi; /set nick HalfWayMan; /set real_name Blake Rain;
13:56:14 <HalfWayMan> Then /save to save all settings locally.
13:56:24 <copumpkin> Foldable should be called ListlikethingyOrSomethingABitLikeAFreeMonoid
13:56:28 <HalfWayMan> Er... wrong channel.
13:56:41 <pedro3005> if when I create a newtype, the instances of the old type do not carry into the new one, what's the advantage of this? how's it different from making a completely new type?
13:56:57 <benmachine> :t let cata f = f . fmap (cata f) . out in cata
13:56:58 <lambdabot> forall (f :: * -> *) b. (Functor f) => (f b -> b) -> Mu f -> b
13:57:17 <roconnor> pedro3005: it has a more efficient runtime representation
13:57:27 <benmachine> > let a = In [In [],In [In [], In []]]; cata f = f . fmap (cata f) . out in cata length a
13:57:28 <lambdabot>   2
13:57:32 <ski> acowley : sure, but it doesn't allow the user-passed function (either explicitly or in the monoid instance) to decide what to do based on the constructor. `fold' unanimously decides to only tell the user the elements of the structure, in a certain order
13:57:32 <benmachine> ...k
13:57:42 <benmachine> oh, obviously :P
13:58:07 <benmachine> > let a = In [In [],In [In [], In []]]; cata f = f . fmap (cata f) . out in cata (liftA2 (+) length sum) a
13:58:08 <lambdabot>   4
13:58:25 <benmachine> a sort of tree-depth function?
13:58:34 <pedro3005> roconnor, I don't quite get it
13:58:37 <acowley> ski: but it's an order decided by the instance writer
13:58:41 <joe6> @hoogle Foreign.C.Types.CUChar -> Char
13:58:41 <lambdabot> Parse error:
13:58:42 <lambdabot>   --count=20 "Foreign.C.Types.CUChar -> Char"
13:58:42 <lambdabot>                     ^
13:58:48 <ski> pedro3005 : one of the common uses of `newtypes' is precisely to *not* carry over the instances
13:59:07 <ski> (pedro3005 : so that you can add your own, alternate ones, e.g.)
13:59:13 <pedro3005> yeah, that's useful
13:59:20 <pedro3005> but why not make a newtype instead?
13:59:25 <pedro3005> er
13:59:29 <pedro3005> a new type*
13:59:35 <pedro3005> i.e. using data
13:59:37 <acowley> pedro3005: because newtype has no runtime impact
13:59:38 <identity_> hmm
13:59:40 <ski> acowley : sure, but once that order is decided, it treats all `t a's as lists of `a's, in the order that traversal visites them
13:59:50 <identity_> implementing something like "mapUntil" wasn't as simple as I had thought :(
13:59:56 <ion> benmachine: Heh, indeed.
13:59:59 <benmachine> pedro3005: you get free functions for converting between the newtype and the other type
13:59:59 <dolio> The monoid case may reveal extra information if you lie about your type being a monoid.
14:00:13 <roconnor> pedro3005: data Foo = mkFoo Bar has extra runtime overhead compared to newtype Foo = mkFoo Bar.
14:00:25 <benmachine> *MkFoo
14:00:49 <acowley> ski: that's the same as writing f a -> a
14:01:01 <roconnor> pedro3005: data Foo = MkFoo Bar boxes Bar, but newtype Foo = MkFoo Bar doesn't box Bar.
14:01:06 <benmachine> pedro3005: also, you can wrap primitive types in a newtype, but you can't define e.g. your own Int very easily
14:01:10 <ion> I guess i’ll have to remember Mu whenever i need a self-recursive type in the future.
14:01:11 <acowley> ski: such a function makes choices
14:01:20 <ski> acowley : no, note that `t' here corresponds to `Mu f', not to `f'
14:01:33 <pedro3005> benmachine, but I could do "data MyInt = MyInt Int", no?
14:01:50 <benmachine> pedro3005: sure, but then the stuff roconnor is talking about is important
14:02:00 <acowley> ski: yeah, and I'm not making a big distinction there because I don't see the significance
14:02:05 <benmachine> your MyInt isn't *exactly* the same as an Int
14:02:16 <DukeDave> Team math: Does this have a name: (\n d -> ((fromIntegral . floor) (n / d)) * d)
14:02:16 <DukeDave> (it finds the largest number less than or equal to n, who's modulo d is zero)
14:02:18 <benmachine> because undefined :: MyInt is different from MyInt undefined
14:02:32 <benmachine> with a newtype, they're the same, so the two types have exactly the same elements
14:03:04 <ski> acowley : in case `t' is `Tree' as in `data Tree a = Leaf a | Branch (Tree a) (Tree a)', then `f' is `TreeF' in `data TreeF a r = Leaf a | Branch r r'
14:03:13 <hpaste> identity_ pasted “mapUntil” at http://hpaste.org/50156
14:03:17 <identity_> How does one know if something 'fuses' or whatever it is called? Will this evaluate the entirety of (map f ls) and then apply takeWhile (not . c) to it?
14:03:36 <benmachine> ion: [a] = Mu (Maybe . (,) a), woo
14:03:45 <ski> acowley : the user-input that `fold' gets is an `mempty :: a' and `mappend :: a -> a -> a' operation
14:04:05 <acowley> ski: and the rest of the Foldable instance
14:04:18 <benmachine> identity_: that's not fusion
14:04:19 <ski> no, i'm talking about a particular instance here
14:04:21 <benmachine> fusion is more subtle
14:04:21 <dolio> identity_: That should fuse, yes.
14:04:24 <pedro3005> benmachine, types created with newtype have kind *?
14:04:30 <identity_> benmachine: I see
14:04:41 <identity_> well, I guess i'm asking whether it's lazy, then?
14:04:49 <benmachine> identity_: indeed you are, and indeed it is
14:04:56 <identity_> good stuff!
14:04:57 <identity_> thanks
14:05:00 <ion> @check n d -> (floor (fromIntegral n / fromIntegral d)) * d == fromIntegral (n - n `mod` d)
14:05:00 <lambdabot>   Parse error at "->" (column 5)
14:05:04 <ion> @check \n d -> (floor (fromIntegral n / fromIntegral d)) * d == fromIntegral (n - n `mod` d)
14:05:05 <lambdabot>   "*Exception: divide by zero
14:05:13 <ski> acowley : the instance is decided once for the type, you as a user calling `fold' can't vary it
14:05:34 <benmachine> pedro3005: I suppose so. I don't think haskell thinks about kinds very much
14:05:41 <benmachine> I'm not sure they're actually in the report
14:05:46 <ion> @check let p ==> x = if p then x else True in \n d -> (d /= 0) ==> ((floor (fromIntegral n / fromIntegral d)) * d == fromIntegral (n - n `mod` d))
14:05:47 <lambdabot>   "OK, passed 500 tests."
14:05:49 <pedro3005> so they can have any kind?
14:06:05 <acowley> ski: yes, but you have foldMap or foldr
14:06:09 <benmachine> pedro3005: oh, you were just asking about arity
14:06:12 <ski> acowley : hm, i suppose in this case it's somewhat nicer to compare `cata' to `foldMap'
14:06:20 <benmachine> pedro3005: newtypes can have parameters, if that's what you mean
14:06:22 <ski> @type Data.Foldable.foldMap
14:06:23 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
14:06:33 <benmachine> newtype Action f = Action { runAction :: f () }
14:06:38 <benmachine> Action :: (* -> *) -> *
14:06:42 <ski> so you're also getting an `a -> m', in addition to `mempty :: m' and `mappend :: m -> m -> m'
14:07:22 <ski> while in the `cata' case you're getting `TreeF a r -> r' which is isomorphic to one `a -> r' and one `r -> r -> r'
14:07:32 <ion> dukedave: Dunno about the name, but n - n `mod` d seems to do the same thing with integrals.
14:07:38 <ski> the difference is that in the `foldMap' case, `mappend :: m -> m -> m' must be associative
14:07:48 <pedro3005> benmachine, but isn't this supposed to be defined in terms of some other type?
14:07:57 <acowley> so the associativity is what prompted you to say cata has nothing to do with fold?
14:07:57 <ski> but the `m -> m -> m' inherent in the `TreeF a r -> r' operation need not be associative
14:08:04 <parcs> pedro3005: a newtype must have a data ctor with a single parameter, that's all
14:08:08 <benmachine> pedro3005: sure, Action f = f ()
14:08:18 <Eduard_Munteanu> You can't have stuff like * -> * -> * though
14:08:23 <benmachine> Eduard_Munteanu: huh?
14:08:27 <pedro3005> parcs, ctor?
14:08:29 <ski> note that this is just in the example of `data Tree a = Leaf a | Branch (Tree a) (Tree a)'
14:08:33 <benmachine> pedro3005: no, it can only have one constructor
14:08:34 <parcs> pedro3005: constructor
14:08:39 <benmachine> it can have however many parameters
14:08:45 <benmachine> newtype Fun a b = Fun (a -> b) is valid
14:09:01 <Eduard_Munteanu> Oh, right, my mistake.
14:09:02 <ski> acowley : another example is `data Expr var = Var var | Int Int | Add (Expr var) (Expr var)'
14:09:04 <benmachine> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r } for a real example
14:09:22 <ski> acowley : in this case, `fold' and friends can't get at the `Ints' stored in the tree, while `cata' can
14:09:27 <parcs> benmachine: i don't think that's the definition of ContT :P
14:09:57 <ski> parcs : looks ok to me ..
14:10:06 <parcs> (r -> m a) -> m a
14:10:12 <ski> no
14:10:12 <benmachine> parcs: http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-Cont.html#ContT
14:10:36 <parcs> snap.
14:12:04 <ski> acowley : in general, `fold' and friends can only see the elements of type `a' in `t a', and can't determine the nesting (due to associativity), only the order that you get from the traversal can be used
14:12:27 <ski> acowley : while `cata' can see every nested constructor
14:12:51 <gwern> > 150 / (ln 1.03)
14:12:52 <lambdabot>   Not in scope: `ln'
14:13:07 <gwern> gah. I forgot what natural log was in haskell... default log? let's see
14:13:10 <gwern> > 150 / (log 1.03)
14:13:11 <lambdabot>   5074.6305203523225
14:13:16 <acowley> ski: I agree. I just think you're being hyperbolic when you say the two have nothing to do with each other.
14:13:27 <parcs> > log 10
14:13:28 <lambdabot>   2.302585092994046
14:13:45 <edwardk> > log (exp 1)
14:13:45 <lambdabot>   1.0
14:13:54 <edwardk> zomg amazing ;)
14:14:10 <gwern> edwardk: I'd be more impressed by a '1' rather than '1.0'
14:14:15 <gwern> > log (exp 1::CReal)
14:14:16 <lambdabot>   1.0
14:14:22 <ion> > log (exp 1) == (1 :: Float)
14:14:22 <lambdabot>   True
14:14:23 <edwardk> > log (exp 1.0)
14:14:24 <lambdabot>   1.0
14:14:35 <gwern> > log (exp 1) ::CReal
14:14:35 <acowley> ski: perhaps you should propose the name change copumpkin suggested :P
14:14:36 <lambdabot>   1.0
14:14:39 <ski> acowley : as general concepts, i don't think they do
14:14:42 <ion> ghci> log (exp 1) - (1 :: Float)
14:14:42 <ion> -5.9604645e-8
14:14:59 * ski vgreps for copumpkin
14:15:01 <gwern> oh floating point! you're so tsundere
14:15:06 <dainanaki> wow
14:15:13 * benmachine giggles
14:15:22 <dainanaki> o_o
14:15:31 <ski> ah, `ListlikethingyOrSomethingABitLikeAFreeMonoid'
14:15:36 <dented42> when I 'cabal install' wxcore, it fails to build, but if I go 'cabal configure ; cabal build' then it builds fine. how do I go about investigating this oddity?
14:15:40 <rwbarton> is Float different on 64-bit systems
14:15:48 <copumpkin> no
14:15:54 <rwbarton> Prelude> log (exp 1) == (1 :: Float)
14:15:54 <rwbarton> False
14:16:13 <rwbarton> why is that happening then
14:16:29 <benmachine> due to float >_>
14:16:33 <ion> libc differences perhaps?
14:16:37 <ski> > log (exp 1) == (1 :: CReal)
14:16:38 <rwbarton> right but lambdabot said True
14:16:38 <lambdabot>   True
14:16:45 <Eduard_Munteanu> What's the exponent usually?
14:17:05 <rwbarton> I will just blame Cale and not worry about it :P
14:17:17 <Saizan> dented42: error message?
14:17:30 <ion> Caleskell has non-broken floats!
14:17:36 <Eduard_Munteanu> um, base, I mean
14:18:46 <dolio> They work the same on my 64-bit Linux GHC and 32-bit Windows GHC (running on 64-bit Windows).
14:19:00 <dolio> In GHCi.
14:19:05 <Eduard_Munteanu> Hm, it seems to be 2 according to IEEE 754, so maybe it's not being that smart about the computation (exp using 'e')?
14:19:14 <rwbarton> is that the False / -5.9604645e-8 way?
14:19:29 <dolio> Wait, hold on.
14:20:04 <dolio> I forgot the :: Float. It is False on 32-bit.
14:20:37 <ion> And on 64-bit?
14:20:40 <dolio> True.
14:20:44 <ion> ok
14:21:03 <rwbarton> @hoogle mantissa
14:21:03 <lambdabot> No results found
14:21:11 <Eduard_Munteanu> I think this sort of stuff goes through SSE by default on x86-64, no?
14:21:14 <rwbarton> @hoogle decodeFloat
14:21:14 <dented42> Saizan: nothing terribly revealing, after trying to compile Graphics.UI.WXCore.WxcClassesMZ (which takes a while) it bonks with "wxcore-0.12.1.7 failed during the build phase. The exception was ExitFailure 9".
14:21:14 <lambdabot> Prelude decodeFloat :: RealFloat a => a -> (Integer, Int)
14:21:28 <rwbarton> > decodeFloat (log (exp 1))
14:21:29 <lambdabot>   (4503599627370496,-52)
14:21:41 <rwbarton> > decodeFloat (log (exp 1) :: Float)
14:21:42 <lambdabot>   (8388608,-23)
14:21:54 <dainanaki> how long does it usually take for Hint to be updated?
14:22:11 <Saizan> dented42: well, you've edited out the interesting part..
14:22:12 <rwbarton> so it just produces a different value for some reason
14:22:51 <gwern> dainanaki: as a student (I think), it depends on the whim and energy of the maintainer. when I was working to get mueval using hint, he responded with patches in days, but I see the repo hasn't apaprently changed since last november
14:22:52 <copumpkin> rwbarton: I'd guess it's a GHC bug / codegen issue
14:23:02 <Saizan> dented42: ah, wait, ExitFailure 9 is probably due to the OOM killing it at the linking stage
14:23:33 <gwern> dainanaki: it compiles in ghc 7.0.4 for me, anyway, and mueval seems to work
14:24:14 <dainanaki> it seems that the GHC API has changed for 7.2, so it doesn't build properly.
14:24:40 <dented42> Saizan: so I should allocate it more memory and cross my fingers?
14:25:12 <Jeanne-Kamikaze> How does one go about designing stuff like octrees in haskell ? I've done a little naive version for managing dynamic objects in the scene. The thing is that every time I update the scene I basically call an update function on all the entities, creating an entirely new octree and leaving the old one for GC business; problem is that the application spends 30% of the time collecting garbage.
14:25:18 <gwern> dainanaki: oh, 7.2? dunno then. maybe you should ping him and tell him
14:25:21 <Saizan> dented42: that might work
14:25:36 <Jeanne-Kamikaze> the memory usage is pretty impressive though
14:26:52 <luite> Jeanne-Kamikaze: you can first try tuning the GC parameters, for example an increased allocation area or heap size can help a lot
14:27:09 <Jeanne-Kamikaze> oh
14:27:58 <luite> Jeanne-Kamikaze: and other than that, if possible try to reuse parts of the old tree
14:28:42 <Jeanne-Kamikaze> quite hard when all it holds is a list of entities (which is new) and its children (also new)
14:29:12 <dainanaki> Jeanne-Kamikaze: also, you might consider using the ST monad. you can do referentially transparent in-place updates .
14:29:57 <Jeanne-Kamikaze> will take a look at those then, thanks
14:30:00 <ion> > (decodeFloat . uncurry encodeFloat . decodeFloat) (1 :: Float) == (decodeFloat) (1 :: Float)
14:30:02 <lambdabot>   False
14:30:57 <ion> > (uncurry encodeFloat . decodeFloat) (1 :: Float) == (1 :: Float)
14:30:59 <lambdabot>   True
14:31:00 <rwbarton> probably the lhs is defaulting to the decodeFloat of a Double
14:31:43 <ion> Ah, good point.
14:32:15 <ion> > (decodeFloat . (id :: Float -> Float) . uncurry encodeFloat . decodeFloat) (1 :: Float) == decodeFloat (1 :: Float)
14:32:17 <lambdabot>   True
14:32:18 <ion> True
14:33:35 <dented42> Saizan: but then what would compiling a file run out of memory when installing, but not when building?
14:34:49 <ion> > map (\d -> let n = uncurry encodeFloat . first (+d) . decodeFloat $ (1 :: Float) :: Float in log (exp n) == n) [-10 .. 10]
14:34:51 <lambdabot>   [True,True,False,True,True,True,True,True,True,True,True,True,True,True,Tru...
14:34:57 <ion> Here: [True,True,False,True,True,False,True,True,False,True,False,True,True,True,True,True,True,True,True,True,True]
14:35:22 <Saizan> dented42: can you paste the whole logs of both on some pastebin site? e.g. hpaste.org
14:40:34 <dented42> Saizan: I just gave it some more memory, and it seems to have worked. just a minute and I'll restore it to the original size and post the logs
14:45:03 <mwc> @seen dcoutts_
14:45:04 <preflex>  dcoutts_ was last seen on #haskell 52 days, 3 hours, 43 minutes and 20 seconds ago, saying: augur: yeah, at least temporarily to be able to install
14:45:04 <lambdabot> Unknown command, try @list
14:45:08 <mwc> @seen dcoutts
14:45:08 <preflex>  dcoutts was last seen on #ghc 1 hour, 35 minutes and 37 seconds ago, saying: which was a mistake
14:45:08 <lambdabot> Unknown command, try @list
14:46:15 * hackagebot trifecta 0.14 - Parser combinators with slicing and diagnostic support  http://hackage.haskell.org/package/trifecta-0.14 (EdwardKmett)
14:49:06 <Phyx-> > return id
14:49:07 <lambdabot>   No instance for (GHC.Show.Show (m (a -> a)))
14:49:07 <lambdabot>    arising from a use of `M301...
14:49:52 <Saizan> dented42: well, it's not necessary if you've solved the problem, what i suspect is that "cabal build" gets similarly interrupted but without an explicit error
14:50:13 <dented42> oh ok
14:50:55 <Phyx-> typing "return id :: IO (Int -> Int)" does nothing in ghci, I was expecting an error...
14:51:20 <thoughtpolice> edwardk: btw, earlier i noticed that hscurses fails to build on 7.2.1 and thus wl-pprint-terminfo won't build (nor trifecta.) i sent stefan a patch on github to fix it, hopefully he should upload a new fixed version of hscurses soon
14:51:26 <edwardk> yeah
14:51:33 <edwardk> unix was also capped iirc
14:51:43 <Saizan> Phyx-: when you feed ghci a IO X where X is not an instance of Show it just executes the effects
14:51:44 <thoughtpolice> yeah
14:52:15 <edwardk> i'm going through adding a bunch of combinators now, its starting to feel solid
14:52:17 <Phyx-> Saizan: ah ok
14:53:04 <thoughtpolice> edwardk: it looks pretty sweet. once it's more solid i wanna try and use trifecta for something :D
14:53:09 * thoughtpolice loves good diagnostics
14:53:37 <edwardk> yeah. probably by the end of the weekend, when i get some time off work to hack on it
14:53:45 <parcs> damn you haskell-src-exts
14:53:55 <parcs> always taking forever to compile
14:56:15 * hackagebot gps2htmlReport 0.1 - GPS to HTML Summary Report  http://hackage.haskell.org/package/gps2htmlReport-0.1 (RobStewart)
14:56:16 <Phyx-> i'm getting an error consistently from ghci
14:56:18 <Phyx-> "<interactive>: HsLexer_stub.o: unknown symbol `_HsLexer_zdflexSourceFileAzua39b_closure'"
14:56:36 <Phyx-> anyone got any clues for me?
14:56:36 <benmachine> preflex: zdec _HsLexer_zdflexSourceFileAzua39b_closure
14:56:36 <preflex>  _HsLexer_$flexSourceFileA_a39b_closure
14:56:45 <benmachine> ...
14:56:54 <benmachine> that was fairly pointless
14:56:57 <Phyx-> lol
14:57:07 <Phyx-> "lexSourceFileA" is the function i'm calling
14:57:11 <yitz> Phyx-: sounds like an out of date object file.
14:57:12 <Phyx-> and HsLexer my module name
14:58:13 <Phyx-> yitz: the .o was just generated, the closure should be there
14:58:18 <dcoutts> mwc: mm?
14:58:19 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
14:58:30 <Phyx-> i'm getting a really weird problem with my compiled program, it just hangs
14:58:36 <Phyx-> no errors, nothing
14:58:43 <Phyx-> just hangs on a call
14:58:55 <dcoutts> mwc: oh, message, got it
14:59:24 <Enigmagic> Phyx-: calling what? your own code?
14:59:30 <Phyx-> Enigmagic: yup
15:00:18 <Enigmagic> Phyx-: if you link with -debug, you can dump out all the threads in gdb. it will usually say what its hung on... a black hole, mvar, extern (C) code, etc
15:00:37 <yitz> Phyx-: if it's not a huge compile, i still suggest delete the *.hi and *.o and compile again.
15:00:42 <Phyx-> Enigmagic: that's a useful tip, thanks!
15:00:54 <Enigmagic> Phyx-: run "call printAllThreads()"
15:00:54 <yitz> Phyx-: all in the directory.
15:00:55 <Phyx-> yitz: will do
15:02:06 <Phyx-> yitz: maybe it's complaining because i removed the foreign export statements, since ghci wouldn't load with them
15:02:12 <hpaste> siracusa pasted “overlapping type family instances” at http://hpaste.org/50157
15:02:51 <siracusa> ^^ Is it possible to resolve this problem still using type families?
15:03:13 <copumpkin> no
15:03:17 <Phyx-> Enigmagic: one sec, recompiling the tool that generates the program to include the flag
15:03:46 <siracusa> copumpkin: So the only way would be using type classes?
15:03:52 <Phyx-> i need to make an --optGhc or something
15:03:59 <copumpkin> siracusa: I think so
15:04:09 <siracusa> Okay
15:04:35 <mwc> dcoutts: yeah, just a couple of trivial patches I'd like to see available
15:04:46 <mwc> dcoutts: guess it's too late to get them into 1.12 :)
15:04:53 <Phyx-> dcoutts: btw, found another bug in cabal, cabal sdist doesn't get passed the list of custom preprocessors. So it fails on packaging. Was trying to fix it myself but hasn't gotten around to it yet
15:05:54 <Phyx-> I did however look at the source for sdist and it does indeed only use the known preprocessors.
15:09:28 <mightybyte> When I try to build with ghc 7.2.1 I get "Ambiguous module name 'Prelude'".  How do I get around this?
15:10:07 <benmachine> mightybyte: are you using the haskell98 package?
15:10:16 <mightybyte> Yeah
15:10:21 <mightybyte> Both haskell98 and base
15:10:31 <benmachine> nowadays haskell98 is meant to be used without base
15:10:45 <benmachine> all the stuff in haskell98 is in base anyway, you just need to change module names
15:11:22 <mwc> I had a weird error trying to compile code as haskel2010 the other day, no instance for Monad (Either Foo) even after I had imported both Control.Monad and Data.Either
15:11:27 <benmachine> the idea is you can write a package that only uses haskell98 modules and then not depend on base at all
15:12:00 <benmachine> mwc: unfortunate hysterical raisins
15:12:08 <mightybyte> benmachine: When I take out haskell98 I get an error about missing the Locale module.
15:12:08 <benmachine> the instance Monad (Either Foo) is orphan
15:12:17 <benmachine> mightybyte: try changing the import to System.Locale
15:12:26 <mightybyte> Ok, thanks.
15:12:34 <benmachine> mwc: try Control.Monad.Instances
15:12:42 <mwc> benmachine: where the hell does instance Monad (Either e) live anyways?
15:12:56 <benmachine> it's in Control.Monad.Instances since base 4.3 I think
15:13:10 <mwc> Huh.
15:13:15 <benmachine> or *possibly* 4.2, I don't remember
15:13:34 <mwc> I guess there's a good reason it can't be in Data.Either?
15:13:45 <mwc> the instance isn't in the 98 report?
15:14:36 <mightybyte> benmachine: Same thing for missing Char?
15:14:45 <benmachine> mightybyte: Data.Char
15:15:24 <mightybyte> benmachine: Excellent, that fixed everything.  Thanks.
15:16:01 <Phyx-> Enigmagic: have a problem, the code is compiled to a DLL and loaded by a program which makes a call and hangs.. from that program's point of view all that the threads tell me is "[External code]"
15:20:26 <Phyx-> Enigmagic: PRIMARY_PROBLEM_CLASS:  HEAP_CORRUPTION
15:20:32 <Phyx-> think I know what's wrong
15:21:42 <Phyx-> well, actually no i don't..
15:31:15 * hackagebot gps 0.7 - For manipulating GPS coordinates and trails.  http://hackage.haskell.org/package/gps-0.7 (ThomasDuBuisson)
15:31:44 <Phyx-> Enigmagic: found the problem, thanks :)
15:31:47 <dainanaki> is it possible to unsafeCoerce to something like (Monad m => m Int)? Or does it have to be a monomorphic type?
15:32:11 <Enigmagic> Phyx-: what was it?
15:33:05 <Phyx-> Enigmagic: i was freeing a CWString in the haskell code which was allocated using a different allocation function then the one C uses
15:33:16 <Enigmagic> ah
15:33:19 <Enigmagic> yeah that'd do it
15:33:32 <Phyx-> odd enough my earlier benchmarks never pointed this out
15:33:47 <Phyx-> they ran fine for some reason
15:33:49 <Phyx-> *shrug*
15:33:51 <parcs> dainanaki: yes
15:33:57 <kmc> dainanaki, short answer is that it is possible
15:34:08 <kmc> (that particular type will get you in huge trouble though)
15:34:10 <hpc> dainanaki: eventually all concrete values have to be monomorphic, but you can have "foo :: Int -> m Int; foo = unsafeCoerce" stuff
15:34:20 <Enigmagic> Phyx-: sometimes the C allocator will turn on extra checks if it is started under a debugger
15:34:50 <kmc> dainanaki, do you understand explicit polymorphism a la System F?
15:35:05 <dainanaki> no.
15:35:20 <dainanaki> at least not in those terms?
15:35:31 <Phyx-> Enigmagic: yeah, I have to think how i can solve this. I'm calling C# <-> Haskell, the problem is that if i leave it up to the .NET marshaller to convert String to char* i'll get a memory leak. So i think i have to ditch the managed type all together
15:36:19 <kmc> dainanaki, http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
15:36:51 <kmc> a polymorphic value is a function that takes a type and returns a value
15:38:04 <kmc> you use Λ (upper-case lambda) to take a type argument, the way λ takes a value argument
15:38:22 <dainanaki> OK.
15:38:40 <dainanaki> I think I get it.
15:38:53 <kmc> and just as a λ term gives rise to a → type, a Λ term gives rise to a ∀ type
15:39:08 <kmc> the difference is that ∀ also binds a type variable at the type level
15:39:23 <dainanaki> ok, tracking so far.
15:39:23 <Enigmagic> Phyx-: you could also just define an extern for CoTaskMemFree or whatever function you need to free it
15:39:38 <kmc> anyway, Haskell usually hides the Λ and ∀'s
15:39:43 <kmc> they're implicit
15:39:48 <dainanaki> right.
15:39:54 <kmc> but it's still very helpful to think about them
15:40:23 <dainanaki> yeah, I'm familiar with them through using existential quantification on occasion.
15:40:57 <Phyx-> Enigmagic: the problem is, I need to be able to free it in Haskell, since that's the only place i know what the pointer is. So i would have to somehow pass the CoTaskMemFree to Haskell then, possibly using a callback, but that seems messy
15:41:05 <kmc> so what you'd be doing with unsafeCoerce is a function that takes a type, and invokes unsafeCoerce at that type
15:41:18 <kmc> which is different from invoking unsafeCoerce at a ∀-type
15:41:48 <kmc> btw, what are you actually using this for?
15:41:53 <Phyx-> Enigmagic: i'm looking at StringBuilder, since that's according to the documentation mutable and implemented as a wchar_t*, so that shouldn't leak, since it just passes the underlying pointer to C and then on return if the GC determines it's not used anymore it should be freed
15:42:36 <Enigmagic> Phyx-: you should just be able to "foreign import" it directly in your haskell code
15:43:18 <Phyx-> Enigmagic: would that work against a .NET assembly?
15:43:45 <Enigmagic> Phyx-: if you're using something like Marshal.StringToCoTaskMemUni, you can free it directly from C or Haskell using CoTaskMemFree
15:43:46 <Phyx-> hm, i could look at the implementation of CoTaskMemFree, maybe it's calling a native dll
15:44:00 <dainanaki> kmc: I'm trying to interpret a value that is of kind ((* -> *) -> *) where I know that (* -> *) is always a monad instance.
15:44:09 <Enigmagic> Phyx-: yep, it uses http://msdn.microsoft.com/en-us/library/ms680722(v=vs.85).aspx under the covers
15:44:36 <Phyx-> Enigmagic: oh, I was not aware of this
15:45:01 <ocharles> Hmmm. I have a few data types, and I want to make a type class specifying that they can be fetched from the database with getById. I could write  class Select a where getById :: Int -> IO a (handwaving), but all the getByIds are similar so I really want a way to say what table to select from
15:45:09 <Phyx-> that makes it easier, although I need to just use the standard free function when the lib is compiled on linux
15:45:18 <ocharles> But I can't write class Select a where tableName :: String, because that's ambiguous...
15:45:21 <ocharles> what do, #haskell!
15:45:22 <dainanaki> kmc: but Hint requires a monomorphic type of instance typeable.
15:45:34 <dainanaki> *that is an instance of typeable
15:45:51 <Phyx-> Enigmagic: and no i'm not using the explicit Marshal.StringToCoTaskMemUni call, i'm just adding the MarshalAs(UnmanagedType.LPWStr) to the String argument
15:46:27 <Enigmagic> Phyx-: should be the same
15:46:45 <Phyx-> Enigmagic: I figured as much, I'll go give it a try
15:46:47 <Phyx-> thanks!
15:47:01 <Enigmagic> Phyx-: the CLR for the most part was designed to interop with COM (the core of the runtime is all native COM objects)
15:47:44 <Phyx-> Enigmagic: yeah, I know that part, though for some reason I didn't connect the dots in this case :/
15:48:13 <Phyx-> Enigmagic: usually, I don't free anything in my library, I leave it to the caller to, but this is just one specific case where I *have* to free it
15:48:44 <nyingen> anyone around who's familiar with fgl?
15:49:17 <kmc> dainanaki, "a value that is of kind ((* -> *) -> *)" ?
15:49:26 <kmc> values don't have kinds
15:49:29 <kmc> types have kinds
15:49:39 <dainanaki> sorry, I'm not great with terminology.
15:49:43 <kmc> and only a type with kind * can have values
15:50:19 <Saizan> ocharles: ... where tableName :: Proxy a -> String; where data Proxy a = Proxy
15:50:33 <kmc> so i don't really follow
15:50:50 <kmc> do you have a value that's polymorphic across all monads, like "return 3"?
15:50:50 <ocharles> Saizan: ahh...
15:51:08 <kmc> or do you have a value that's in some specific monad, and you want to use it through the monad API
15:51:16 <dainanaki> kmc: that's what I meant.
15:51:19 <kmc> which?
15:51:25 <dainanaki> the second
15:51:25 <ocharles> Saizan: I also considered tableName :: Identity String, and then when I use it I just did runIdentity
15:51:35 <Saizan> ocharles: another way is newtype Tagged t a = Tagget a; ... tableName :: Tagged t a
15:52:02 <Saizan> err, tableName :: Tagged a String; i meant
15:52:14 <Saizan> ocharles: Identity String still doesn't mention the typeclass parameter
15:52:21 <ocharles> oh yea
15:52:23 <kmc> dainanaki, okay, then coercing to ((Monad m) => m Int) is going to end in tears
15:52:33 <kmc> that says "this value can be used as *any* monad types"
15:52:54 <kmc> so you can coerce Maybe Int to (Char -> Int)
15:53:03 <kmc> which is going to fail bigtime
15:53:14 <dainanaki> :(
15:53:54 <kmc> dainanaki, i think you should wrap your monadic value in an existential before you pass it through Hint
15:54:04 <Phyx-> Enigmagic: one last thing, what do you think about the StringBuilder way? Would that work too? The problem I have is that freeing using coTaskMemFree forces me to also alloc using CoTaskMemAlloc in C instead of just being able to pass a unicode string right?
15:54:14 <kmc> the existential wrapper type is a simple monomorphic type
15:54:42 <kmc> dainanaki, but what's the point of a value of type (m Int) for unknown monad m?
15:54:48 <kmc> what can you actually do with this value?
15:55:28 <Saizan> maybe he wants a polymorphic component wrapper, instead? (i've not seen the beginning)
15:56:02 <kmc> Saizan, you might as well replace (forall m. (Monad m) => m Int) with Int
15:56:34 <Saizan> Either String Int
15:56:35 <kmc> modulo strictness and laws being obeyed, it will be equivalent to "return n" for some n
15:57:19 <kmc> oh, i guess there is "fail"
15:57:20 <kmc> sigh
15:57:38 <dainanaki> kmc: there is also an unwrapped that gets interpreted too.
15:57:43 <dainanaki> *unwrapper
15:57:54 <kmc> and they have to be interpreted separately?
15:58:53 <dainanaki> they come together in the same datatype
15:59:28 <kmc> why not apply the unwrapper to the wrapped thing, inside the interpreter?
15:59:43 <kmc> maybe you can draw a general sketch of how this all fits together
15:59:46 <eyu100_> Num b => Int -> (forall a. Num a => a -> a) -> b -> b
15:59:59 <dainanaki> ok, I'll do that in a while. will you be around in 45 minutes or so?
16:00:07 <singpoly1a> If I have an expression: MPI (fromOctets 256 (reverse final))   where MPI is newtype MPI Integer -- why is anything needed to be defaulted there?  Shouldn't it know to make it Integer?
16:00:32 <kmc> dainanaki, probably, or someone else can help
16:00:52 <Saizan> singpoly1a: 256 is probably what's being defaulted, check the type of fromOctets
16:01:35 <singpoly1a> fromOctets :: (Integral b, Integral a) => a -> [Octet] -> b
16:01:50 <singpoly1a> oh
16:01:54 <singpoly1a> I see now
16:02:31 <dainanaki> kmc: thanks for the help thus far.
16:02:50 <kmc> no problem :)
16:22:40 <frerich_> Does anybody have suggestions how to improve the createPlayers function in the code at http://hpaste.org/50158 ? It's currently a bit broken because the list of players it yields also includes the "dummy" player I add to the end of the list. However, fixing this would make the code a lot more uglier, even more than it is already.
16:22:46 <frerich_> I wonder whether this could be rewritten.
16:23:15 <frerich_> The problem is to distribute chips among players when starting a game. Each player gets three chips. In the end, I need a list of players and the set of chips which haven't been distributed.
16:24:18 <kmc> why the dummy player?
16:24:22 <frerich_> My idea was to give the use the first three chips for the first player name in the list and then recurse. Unfortunately, when terminating this recursion, I need an ugly "dummy player" for the list of tuples.
16:24:54 <frerich_> kmc: As it is, the 'go' function yields a [(Player, Set)], a list of players and each tuple also has the remaining chips after constructing the player value.
16:26:40 <frerich_> "createPlayers ["Bob", "John"]" should yield ([Player {name = "Bob", chips = [1,2,3]},Player {name = "John", chips = [4,5,6]}], [7,8,9,10,11,12,13,14,15])
16:27:29 <frerich_> It *almost* does that (the 'map fst distributedChips' causes the list of players to include the dummy player) but I find this function very ugly and I'm sure I don't understand what's going on when I look at it later.
16:27:38 <frerich_> I wonder whether there is a better approach.
16:28:39 <sully> does anybody know of a good paper or reference about doing type inference for type classes?
16:29:05 <sully> I have a solid understanding of HM polymorphic type inference but not much about extending it
16:30:00 <ocharles> Hey, having a bit of trouble with types... http://gist.github.com/1138599
16:30:10 <ocharles> I get the error "Could not deduce (TableLike a1)"
16:30:15 <ocharles> and I'm not sure what it means...
16:32:20 <ocharles> Ah, presumably that "a" from the class definition is not the same a on line 10
16:33:14 <doserj> it works with {-# LANGUAGE ScopedTypeVariables #-}
16:33:24 <siracusa> sully: Have you looked at the papers by Philip Wadler? http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html
16:33:49 <ocharles> doserj: do I want that though?
16:33:58 <ocharles> Or is there a non-extension way to express this?
16:35:34 <sully> siracusa: I just found "How to make ad-hoc polymorphism less ad-hoc" from wikipedia; the others look interesting too
16:35:37 <sully> awesome. thanks.
16:37:09 <doserj> ocharles: is there a reason why you can't use "class TableLike a where tableName :: String" ?
16:37:25 <deech> Does is there some way to indent a block in emacs-mode?
16:37:26 <ocharles> doserj: because that doesn't use "a" and is thus ambiguous, I thought?
16:37:34 <ocharles> (tableName)
16:38:29 <doserj> erm, tableName :: a -> String
16:38:46 <ocharles> I don't have an "a" value to pass though, when I need the tableName
16:38:55 <ocharles> I construct the a from the result of a SELECT using tableName
16:40:34 <EvanR> a -> String can only be const "foo" or id
16:40:55 <EvanR> er, id wont work
16:41:07 <kmc> or undefined or const undefined
16:41:14 <EvanR> ok
16:41:16 * hackagebot quicklz 1.5.0.7 - binding to QuickLZ compression library  http://hackage.haskell.org/package/quicklz-1.5.0.7 (AustinSeipp)
16:41:19 <Saizan> ocharles: yes, you want {-# LANGUAGE ScopedTypeVariables #-}
16:41:24 <ocharles> cool
16:41:47 <ocharles> well it does indeed work a treat with this!
16:41:54 <ocharles> man, refactoring Haskell is so FUN
16:42:21 <Saizan> ocharles: read the docs on that extension though
16:42:45 <ocharles> will add it to the bed time reading list
16:42:58 <mustelo> frerich, I've annotated your hpaste with some suggestions.
16:43:27 <mustelo> basically, boils down to adding the chipset as an argument to the function rather than as a global
16:44:58 <mustelo> frerich_, ^^... wrong nick
16:56:17 * hackagebot cityhash 0.0.3 - Bindings to CityHash  http://hackage.haskell.org/package/cityhash-0.0.3 (AustinSeipp)
16:56:19 * hackagebot openpgp 0.2 - Implementation of the OpenPGP message format  http://hackage.haskell.org/package/openpgp-0.2 (StephenWeber)
16:58:22 <Leftmost> For haddock, if an identifier is surrounded by '', is it possible to follow that with another apostrophe (for possessive) and still have it link?
17:04:01 <DukeDave> So, here I am looking at this: http://hackage.haskell.org/packages/archive/AC-Vector-Fancy/2.4.0/doc/html/Data-Vector-Transform-Fancy.html#t:Transformable
17:04:01 <DukeDave> And I'm thinking, "I'd sure like to scale a Vector2, perhaps I can just do `transform (scaleT_ 2) (Vector2 3 3)', right?"
17:06:41 <DukeDave> But apparently I can't, because...
17:07:16 <hpaste> DukeDave pasted “Data.Vector.Transform trouble” at http://hpaste.org/50160
17:12:18 <Saizan> Leftmost: maybe you've to escape that other '?
17:13:23 <Leftmost> Tried that and it ends up printing 'Identifier'\' verbatim.
17:13:54 <joe6> i have a lot of functions with a type signature of : ... -> Fd -> IO () . Is there anyway I could use some monad or something to merge them into one parameter?
17:16:17 * hackagebot file-location 0.2.4 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.2.4 (GregWeber)
17:18:03 <joe6> i could use a type synonym of "type FdIO = Fd -> IO ()"
17:18:11 <dmwit> DukeDave: looking
17:18:18 <joe6> but, am just curious if there is a better way of doing it.
17:19:26 <Eduard_Munteanu> ReaderT?
17:19:53 <Eduard_Munteanu> @src Reader
17:19:54 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:21:17 * hackagebot prototype 0.4.1 - prototype-based programming on Haskell  http://hackage.haskell.org/package/prototype-0.4.1 (YoshikuniJujo)
17:21:54 <dmwit> DukeDave: How about
17:22:04 <dmwit> transform (scaleT_ 2 :: Transform2) (Vector2 3 3)?
17:30:38 <parcs> joe6: leave it alone :P
17:36:17 * hackagebot file-location 0.3.0 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.3.0 (GregWeber)
17:36:37 <joe6> parcs, no thoughts on making it better?.. there's got to be some way to make it better.
17:38:56 <Dashkal> joe6: Running everything in a reader monad you thread the fd through is about it.  It of course only works when the fd can be implicit like that.  If you need to specify it at call time, leaving it alone is probably best.
17:40:02 <dmwit> "If you need to specify it at call time"?
17:40:19 <joe6> Dashkal: fd is the file descriptor. I need to use it to read/write to that file-descriptor.
17:40:49 <joe6> What do you mean by "if you need to specify it at call time"?
17:40:55 <parcs> joe6: better in what way? you can use a ReaderT Fd IO () instead of Fd -> IO () but then you'll have to sprinkle liftIOs and gets in your code. you can use a type synonym but that is pretty useless and sometimes confusing (no one expects a function arrow inside a type synonym)
17:41:17 * hackagebot uuid 1.2.3 - For creating, comparing, parsing and printing Universally Unique Identifiers  http://hackage.haskell.org/package/uuid-1.2.3 (AntoineLatter)
17:41:23 <dmwit> ?src ReadS
17:41:23 <lambdabot> Source not found. It can only be attributed to human error.
17:41:30 <dmwit> ?src ShowS
17:41:31 <lambdabot> type ShowS = String -> String
17:41:38 <dmwit> Nobody expects the Spanish Inquisition!
17:41:48 <DukeDave> dmwit: Aha! Excellent! Thank you :)
17:41:51 <parcs> you can also use implicit parameters but that provides hardly any benefit either
17:42:02 <joe6> ok, thanks.
17:42:19 <ion> globalFd :: Fd
17:42:24 <ion> globalFd = unsafePerformIO ...
17:42:27 * ion ducks
17:42:35 * dmwit quacks
17:42:43 <joe6> it would be great if I can make the IO and Fd into one monad without having to use a monad transformer..
17:42:53 <joe6> but, I guess that is out of haskell realm..
17:43:14 <dmwit> Why do you want to do it without using a transformer?
17:51:17 * hackagebot chell 0.1 - Quiet test runner  http://hackage.haskell.org/package/chell-0.1 (JohnMillikin)
17:52:56 <hpc> haha, awesome package name
17:56:19 * hackagebot chell-hunit 0.1 - Quiet test runner (HUnit support)  http://hackage.haskell.org/package/chell-hunit-0.1 (JohnMillikin)
17:56:21 * hackagebot chell-quickcheck 0.1 - Quiet test runner (QuickCheck support)  http://hackage.haskell.org/package/chell-quickcheck-0.1 (JohnMillikin)
17:56:23 * hackagebot Hs2lib 0.5.2 - A Library and Preprocessor that makes it easier to create shared libs from Haskell programs.  http://hackage.haskell.org/package/Hs2lib-0.5.2 (TamarChristina)
17:59:32 <ryant5000> what does the remote-build-reporting flag do in the .cabal/config file?
18:02:15 <dmwit> I think Hackage2 has a section for user-submitted build reports. Perhaps remote-build-reporting is for interfacing with that.
18:02:42 <dmwit> That's pure speculation, though -- not based on any facts.
18:02:45 <ryant5000> dmwit: interesting; it would be nice to know what information it's uploading :P
18:51:26 <gwern> @quote loving.*god
18:51:26 <lambdabot> kmc says: I refuse to believe that any loving god would invent the monomorphism restriction
18:51:46 <ion> @quote
18:51:46 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
18:51:59 <ion> What?
18:52:07 <ion> @quote
18:52:07 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
18:52:13 <gwern> hehe
18:52:24 <gwern> @quote gwern
18:52:25 <lambdabot> gwern says: Haskell has the best arrays around; problem is, we don't know which module it is.
18:52:45 <shachaf> preflex: be kmc
18:52:45 <preflex>  i think "do the opposite of C++" is a decent design guideline
18:52:53 <gwern> I think we have even more arrays now thanks to DPH than when I said that...
18:52:57 <shachaf> preflex: be gwern
18:52:57 <preflex>  be warned preflex, your time will come! you too shall make use of mueval
18:53:06 <ivanm> :o
18:53:14 <ivanm> preflex: be shachaf
18:53:14 <preflex>  There was a study once where they gave one group real placebos and the other group fake placebos, and the effects were exactly the same.
18:53:20 <shachaf> preflex--
18:53:31 <gwern> shachaf: so, does preflex use mueval yet?
18:53:33 <ivanm> preflex: help be
18:53:33 <preflex>  be NAME - impersonate NAME
18:53:35 <dmwit> preflex: be lambdabot
18:53:36 <preflex>  no quotes found for lambdabot
18:53:43 <shachaf> gwern: How should I know?
18:53:45 <shachaf> preflex: be preflex
18:53:45 <preflex>  no quotes found for preflex
18:53:46 <gwern> dmwit: honor among bots!
18:54:02 <dmwit> ?quote blargle
18:54:03 <lambdabot> No quotes match. You speak an infinite deal of nothing
18:54:09 <dmwit> ?remember blargle test
18:54:10 <lambdabot> Nice!
18:54:15 <dmwit> ?forget blargle test
18:54:15 <lambdabot> Done.
18:54:19 <dmwit> ?quote blargle
18:54:19 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
18:54:23 <dmwit> interesting
18:54:25 <ivanm> preflex: be blargle
18:54:25 <preflex>  no quotes found for blargle
18:54:37 <dmwit> I bet that bug is so easy to fix.
18:54:40 <dmwit> ?where lambdabot
18:54:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
18:54:47 <shachaf> @quote shachaf
18:54:47 <lambdabot> shachaf says: boost::lambda: The ultimate error message.
18:54:49 <dmwit> 403'd!
18:54:51 <shachaf> Grr.
18:54:52 * ivanm wonders what the conversation would be about for roconnor's quote
18:54:57 <shachaf> It used to do the empty list thing.
18:55:42 <dmwit> ?hackage lambdabot
18:55:42 <lambdabot> http://hackage.haskell.org/package/lambdabot
18:57:09 <ivanm> @hackage not-lambdabot
18:57:09 <lambdabot> http://hackage.haskell.org/package/not-lambdabot
18:57:16 <shachaf> @hackage maybe-lambdabot
18:57:17 <lambdabot> http://hackage.haskell.org/package/maybe-lambdabot
18:57:41 <dmwit> @version
18:57:41 <lambdabot> lambdabot 4.2.2.1
18:57:41 <lambdabot> darcs get http://code.haskell.org/lambdabot
18:57:47 <dmwit> There we go.
18:58:01 <Phyx-> does anyone know what spits out the error "Program returned error in computation"
18:58:04 <Phyx-> ?
18:58:10 <dolio> roconnor is fairly negative on the haskell platform in general.
18:58:20 <dmwit> Man, the darcs sad-face is so disappointed.
18:58:32 <dmwit> Phyx-: ack knows
18:58:47 <ivanm> dolio: yeah, I know
18:58:50 <Phyx-> oh... I DID write that error msg... (>.<) nvm..
18:58:52 <ivanm> but that implies he doesn't even use base...
18:58:55 <dolio> Although, it contains a lot of pretty indispensable stuff, so I don't know how you can avoid all packages in it.
18:58:59 <ivanm> Phyx-: heh
18:59:14 <ivanm> dolio: C-based manipulation of the GHC API? :p
18:59:31 <dolio> I guess you could use monadLib instead of mtl.
18:59:42 <dmwit> Phyx-: The information content of that error is pretty low. I'd probably be less angry at a simple "error" than at that line. =P
19:02:51 <Phyx-> dmwit: well, there is a '' after the line but i guess that doesn't help much :P
19:03:08 <Phyx-> it was supposed to print out the error message, but i just got ''
19:03:12 <Phyx-> for some reason, lol
19:03:41 <dmwit> whoops
19:09:46 <dmwit> ?brain
19:09:46 <lambdabot> I think so, Brain, but don't you need a swimming pool to play Marco Polo?
19:09:56 <parcs> :t testBit 4 0
19:09:57 <lambdabot>     Ambiguous type variable `t' in the constraint:
19:09:58 <lambdabot>       `Bits t' arising from a use of `testBit' at <interactive>:1:0-10
19:09:58 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
19:10:18 <parcs> > testBit (4::Word16) 0
19:10:18 <lambdabot>   False
19:10:27 <parcs> > testBit (5::Word16) 0
19:10:28 <lambdabot>   True
19:10:38 <danharaj> ?brain
19:10:39 <lambdabot> Uh, I think so, Brain, but we'll never get a monkey to use dental floss.
19:10:44 <danharaj> <3 <3
19:10:51 <dmwit> ?brain Are you pondering what I'm pondering?
19:10:51 <lambdabot> But where will we find an open tattoo parlor at this time of night?
19:10:54 <danharaj> Are these the actual quotes?
19:11:01 <roconnor> ivanm: edwardk has shown me that most of my concerns about the packages in the HP have been addressed.
19:11:10 <dibblego> is there a version of cabal-install that will install with GHC 7.2.1 on debian?
19:11:12 <ivanm> fair enough
19:11:15 <dmwit> danharaj: Pinky and the Brain was a pretty awesome show, yup.
19:11:15 <roconnor> ivanm: so I cannot complain as much about the HP anymore.
19:11:18 <ivanm> dibblego: darcs?
19:11:23 <ivanm> roconnor: awwww..... ;)
19:11:25 <danharaj> roconnor: what were your issues with it?
19:11:43 <roconnor> danharaj: wrong implemenation for callCC in StateT Cont
19:11:49 <dmwit> dibblego: The cabal-install that was already installed before I upgraded to GHC 7.3 works fine with GHC 7.3.
19:11:54 <danharaj> roconnor: :o
19:12:09 <roconnor> danharaj: but that isn't the case anymore.
19:12:55 <danharaj> what was wrong with the implementation?
19:13:33 <roconnor> danharaj: it didn't follow the laws of modular monad transformers
19:13:41 <danharaj> oh
19:15:27 <danharaj> roconnor: Does that arise from a strictness issue or was it a complete fudge up?
19:18:12 <dibblego> http://paste.pocoo.org/show/456335/ trying to install cabal-install-0.10.2 with ghc-7.2.1 on debian x86_64
19:18:24 <dysinger> I am playing around with 7.2.1 - is there a cabal-install that works ?
19:18:34 <dysinger> oh jinx to dibblego
19:19:04 <dysinger> I get the same error on Mac
19:19:22 <dysinger> I've tried 0.10/0.12 & HEAD
19:20:07 <ivanm> @hoogle foldM
19:20:07 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
19:20:08 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
19:20:08 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
19:29:05 <roconnor> danharaj: it was arguably a fudge-up, but the mtl was written before this was well understood.
19:29:16 <roconnor> so it isn't exactly their fault.
19:31:58 <danharaj> roconnor: Ah well. This is what happens when your abstractions are mathematical objects instead of AbstractAdHocFactoryFactoryAdapterPatterns
19:34:08 <roconnor> danharaj: the problem was that there was too little abstract mathematical objects
19:34:41 <ion> AbstractAdHocFactoryFactoryAdapterPatternBeans
19:35:04 <shachaf> AbstractMorphismFactoryFunctor
19:35:06 <danharaj> roconnor: Monad transformers weren't understood at the time? Come to think of it, what *is* a monad transformer?
19:35:18 <danharaj> It has a strange kind.
19:35:37 <shachaf> Monad transformers are still not really understood.
19:35:49 <roconnor> danharaj: I'd have to reread the modular monad transformers paper
19:35:51 <shachaf> ...By me, anyway.
19:36:15 <shachaf> At least, they don't seem to be the right solution for a lot of things they're used for.
19:39:31 <danharaj> roconnor: hmm, interesting paper. I might read it eventually.
19:49:12 <johntromp> any osx liom users here?
19:49:22 <hatds> naming time: right now I have a function lift :: forall a . (S-> a) -> (T -> a).  What should I name func :: (S -> S) -> (T -> T) ?
19:50:47 <dibblego> hatds: modify
19:51:18 * hackagebot repa 2.1.1.4 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.1.1.4 (BenLippmeier)
19:51:20 <hatds> not bad
19:51:22 <hatds> :)
19:52:38 <dibblego> hatds: http://twanvl.nl/blog/haskell/isomorphism-lenses
19:53:01 <dibblego> (i.e. lenses, being the origin of that suggestion)
19:54:58 <hatds> I suppose it is also a 'map', of sorts
19:59:02 <ddarius> @hoogle yoneda
19:59:02 <lambdabot> No results found
19:59:21 <ddarius> When will you learn Hoogle.  When will you learn...
19:59:22 <Saizan> lately i've been thinking that it's weird that we don't have a type to compose monad transformers anywhere
19:59:52 <shachaf> We need monad transformer transformers.
20:00:30 <ddarius> Saizan: It would just be functor composition, admittedly without kind polymorphism we have to make a family of them.
20:00:39 <danharaj> ((* -> *) -> (* -> *)) -> ((* -> *) -> (* -> *)) ?
20:00:45 <Saizan> ddarius: right
20:00:54 <dmwit> Is there a tool that tells which package is providing a particular module?
20:00:58 <dmwit> :i doesn't seem to do it
20:01:05 <Saizan> ghc-pkg find-module
20:01:11 <dmwit> thanks
20:04:39 <ddarius> :t let lift :: (Int -> a) -> Bool -> a; lift = lift; f :: Bool -> Int; f = f in (lift id, (Prelude.. f))
20:04:40 <lambdabot> forall c. (Bool -> Int, (Int -> c) -> Bool -> c)
20:04:49 <Saizan> going at it like (StateT s `O` ReaderT r `O` ..) IO would make MonadIO unnecessary, maybe we gain something more important too
20:13:18 <hoopy> >take 100 (fold ((*) 1..))
20:13:27 <hoopy> > take 100 (fold ((*) 1..))
20:13:28 <lambdabot>   <no location info>: parse error on input `..'
20:13:33 <hoopy> > take 100 (fold ((*) 1...))
20:13:34 <lambdabot>   Not in scope: `fold'Not in scope: `...'
20:13:39 <hoopy> > take 100 (foldl ((*) 1...))
20:13:40 <hatds> you want [1..]
20:13:40 <lambdabot>   Not in scope: `...'
20:13:46 <hoopy> ah, sorry
20:13:53 <hoopy> > take 100 (foldl ((*) [1..]))
20:13:54 <lambdabot>   Couldn't match expected type `b -> [t]' against inferred type `[t]'
20:14:12 <hoopy> wow. i've lost everything. (which wasn't much to begin with)
20:14:13 <mustelo> > take 100 $ foldl (*) [1..]
20:14:14 <lambdabot>   Couldn't match expected type `[a]'
20:14:14 <lambdabot>         against inferred type `[[t]] -> ...
20:14:26 <hatds> foldl (*) 1 [1..] or foldl1 (*) [1..]
20:14:32 <mustelo> dammit.
20:14:54 <hoopy> take 100 (foldl (*) 1 [1..])
20:14:59 <hoopy> > take 100 (foldl (*) 1 [1..])
20:15:00 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
20:15:00 <lambdabot>    arising from a use...
20:15:17 <mustelo> wait, hoopy why are you doing `take 100`?
20:15:30 <ddarius> foldling an infinite list isn't going to end in happiness.
20:15:33 <hoopy> because i thought doing a fold over an infinite list would never terminate
20:15:40 <hatds> :t scanl
20:15:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
20:15:46 <mustelo> hoopy, but what's take going to do about that?
20:15:57 <hoopy> take 5 ([1..])
20:16:01 <hoopy> > take 5 ([1..])
20:16:02 <lambdabot>   [1,2,3,4,5]
20:16:09 <hoopy> > [1..]
20:16:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:16:13 <hoopy> stop it
20:16:18 * hackagebot repa 2.1.1.5 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.1.1.5 (BenLippmeier)
20:16:19 <ddarius> > take 5 (fix id)
20:16:23 <lambdabot>   mueval-core: Time limit exceeded
20:16:28 <danharaj> ooh repa update
20:16:28 <mustelo> :t foldl1 (*) [1..]
20:16:29 <lambdabot> forall a. (Num a, Enum a) => a
20:16:41 <mustelo> hoopy, that's not a list, so you can't take from it
20:16:46 <hoopy> i see
20:16:46 <ddarius> danharaj: There was another just ten minutes ago.
20:16:58 <hoopy> > foldl (*) [1..100]
20:16:59 <ddarius> mustelo: You could have some really evil Num instance.
20:16:59 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
20:16:59 <lambdabot>    arising from a us...
20:17:11 <hoopy> yowza.  i just need to read.
20:17:13 <ddarius> Actually, for [()] it wouldn't even be that evil.
20:17:37 <dmwit> > foldl (*) 1 [1..100]
20:17:38 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
20:17:44 <dmwit> > product [1..100]
20:17:44 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
20:17:49 <mustelo> ddarius, :)
20:18:03 <dmwit> > scanl (*) 1 [1..] !! 100
20:18:04 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
20:18:46 <ddarius> dmwit: Now write the tree-structured fold that will perform even better.
20:18:49 <dmwit> hoopy: Generally, "foldr" and "scanl" are friendlier with respect to infinite lists than "foldl" and "scanr".
20:19:06 <dmwit> ddarius: Done, at least three times, and saved in a file so I don't make it four. =)
20:19:20 <ddarius> I'm not sure how many times I've done it.
20:19:21 <dmwit> (Three times... I'm a slow learner. =P)
20:19:29 <hoopy> dmwit :)  dmwit: makes sense... how can foldl know from what point to fold
20:19:33 <hoopy> wasn't thinking about that
20:19:59 <hoopy> > foldr (*) [1..100]
20:20:00 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
20:20:00 <lambdabot>    arising from a us...
20:20:09 <dmwit> needs a base case
20:20:14 <dmwit> > foldr (*) 1 [1..100]
20:20:15 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
20:21:21 <hoopy> beer and haskell don't mix
20:21:36 <ddarius> When the Prelude revolution comes, I hope (^) :: Monoid m => m -> Natural -> m
20:21:45 <ddarius> hoopy: I hear that you are mistaken about that.
20:21:57 <danharaj> I code better inebriated.
20:22:59 <dmwit> Man, I have hosed my package repository so badly.
20:23:19 <hoopy> which one do you use?
20:23:37 <dmwit> um
20:23:40 <dmwit> ghc?
20:23:56 <hoopy> could have been apt, brew, etc
20:24:00 <hoopy> i'll shut up now.
20:24:10 <dmwit> Ah, no, I mean my Haskell package repository.
20:24:50 <dmwit> Maybe now would be a good time to upgrade GHC. As long as things are broken and I'm starting over, I might as well start over properly.
20:36:18 * hackagebot repa 2.1.1.6 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-2.1.1.6 (BenLippmeier)
20:41:06 <Polarina> Is it possible to depend on a name I defined previously with DataD later in the same DecsQ?
20:51:21 * hackagebot buildbox 1.5.2.2 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-1.5.2.2 (BenLippmeier)
20:51:24 * hackagebot buildbox-tools 1.5.0.2 - Tools for working with buildbox benchmark result files.  http://hackage.haskell.org/package/buildbox-tools-1.5.0.2 (BenLippmeier)
20:53:48 <ddarius> Polarina: My understanding, though it may be very out of date, is that you cannot depend on spliced declarations within the same file at all, let alone the same splice.
20:55:20 <Polarina> ddarius: How unfortunate. :(
20:55:34 <Saizan> sounds wrong to me
20:56:19 <kmc> that's my recollection as well
20:56:26 <edwardk> polarina: i've had a really hard time talking between slices =(
20:57:10 <Saizan> but here it's talking within a single splice
20:57:19 <Saizan> $([d| data Foo = Foo
20:57:19 <Saizan>       foo Foo = Foo
20:57:19 <Polarina> edwardk: I would like to define lots of top-level declarations that some of those depend on each other, but in a single slice.
20:57:20 <Saizan>   |])
20:57:22 <Saizan> that works
20:57:28 <edwardk> that should work
21:03:30 * ddarius was talking about a different scenario.
21:05:09 * ddarius is not sure how he managed to get moisture in his phone again.
21:05:56 <Polarina> o.O
21:06:23 <ddarius> edwardk: Your Martian Tales Trilogy is horriby edited by the way.
21:06:32 <edwardk> hah
21:06:34 <edwardk> sorry man
21:06:45 <edwardk> feel free to go forage in the wilds of gutenberg ;)
21:10:43 <ivanm> OK, I've given in and ended up using stack overflow
21:10:47 * ivanm feels a little unclean
21:13:07 <edwardk> hah 15 minutes to track down i'd used <$> instead of <?> by reflex
21:13:29 <ddarius> And it type-checked?
21:13:39 <edwardk> nah
21:13:42 <edwardk> that was the problem
21:13:48 <edwardk> it was in the middle of a huge mess
21:16:13 <hpaste> tgeeky pasted “ghc 7.2rc?” at http://hpaste.org/50165
21:16:18 * ddarius wonders if Telerik's tree view handles the infinitely deep case.
21:16:30 <edwardk> i wouldn't hold my breath
21:16:45 <tgeeky> #h: < http://hpaste.org/50165 > should I report this or upgrade to 7.2.1 or ...?
21:17:32 <ddarius> It depends on how much effort you want to put out.  Certainly, though, before reporting something you should check the bug tracker.
21:18:19 <ddarius> But I would try 7.2.1 before reporting a bug if you want to be nice.
21:18:57 <tgeeky> yep
21:19:00 <tgeeky> looks like it's fixed
21:21:21 * hackagebot trifecta 0.15 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.15 (EdwardKmett)
21:21:34 <tgeeky> wow, though, the changelog for 7.2.1 is pretty nice
21:21:42 <tgeeky> or imposing at least
21:23:38 <ivanm> edwardk: what do you mean by "modern" ?
21:24:10 <edwardk> i mean it doesn't shy away from applicative, or using stuff that has been invented in the last 10 years
21:24:30 <ivanm> though unless 0.15 is different, I see that trifecta has the usual edwardk problem of being in lots of little modules with no documentation :p
21:24:32 <edwardk> it incorporates a bunch of tricks from clang to present pretty error messages, etc.
21:24:45 <edwardk> starting to evolve docs
21:24:51 <edwardk> but it'll be a while
21:24:59 <tgeeky> edwardk: do you expect it to be fast, soon?
21:25:01 <ivanm> how long is a "while" ?
21:25:12 <edwardk> tgeeky: trifecta?
21:25:16 <tgeeky> edwardk: yes
21:25:19 * ivanm still likes polyparse
21:25:36 <edwardk> ivanm: heh, well, i had 'commit' semantics for a little while here, but switched back to try
21:25:47 * hatds is polyparsing as we speak
21:26:13 <edwardk> it only requires me to change about 4 places in the grammar to swap back and forth
21:26:21 * hackagebot gloss 1.3.4.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.3.4.1 (BenLippmeier)
21:26:32 <ivanm> edwardk: at least for graphviz, having backtracking by default is rather nice as it needs to backtrack a fair amount
21:26:35 <edwardk> sadly i can't just package up the choice behind a class interface
21:27:07 <edwardk> i may switch back eventually
21:27:08 <ivanm> admittedly, there are one or two places where malcolmw and I differ on how lazy a combinator should be so I have to re-duplicate it...
21:27:11 <ivanm> *shrugh*
21:27:20 <ivanm> edwardk: yeah, that would be nice if it was feasible
21:27:37 <ivanm> but would probably requrie too much re-writing of parsing logic to be able to just switch + compare anyway
21:27:37 <hatds> I've been thinking about commit semantics, and it seemed like there is a better design
21:28:09 <edwardk> well, its particularly nice for me because my parsers have access to the entire history and can seek, etc.
21:28:20 <edwardk> so there is little win to requiring try
21:28:44 <ivanm> *nod*
21:28:56 <edwardk> otoh, my experience with the two seems to be that i use try at a <|> point where i'm calling something else, but i want to use a commit inline, which means introducing a second do block
21:29:05 <edwardk> so try is less obtrusive
21:29:15 <edwardk> at least with the combinators i have and the grammar i use
21:29:41 <ivanm> I think I've only used commit once or twice, it doesn't seem to make much of a difference for me
21:29:51 <ivanm> but I do wish polyparse had better error reporting facilities
21:30:08 <edwardk> yeah, i was able to get all of the parsec style error reporting layered into my diagnostics system
21:30:26 <ivanm> as I tend to have to write some funky code when it's difficult to tell which option it is to start with
21:30:33 <edwardk> so it'll say what was expected, etc.
21:31:14 <ivanm> right; it's really fun when QC spits out a massive DotGraph saying there was a parsing error and I need to dig through it a bit at a time to work out _where_ it is :s
21:31:45 <edwardk> heh with trifecta you get a caret showing you right into the line ;)
21:31:57 <ivanm> ooooohhhhhh....
21:32:10 <edwardk> and can associate ranges, etc of you want to talk about more robust errors, so it'll draw them with ~~~~ ^ ~~~~~ etc.
21:32:14 * ivanm heads off to go tutor
21:32:38 <edwardk> even rather pointlessly in color ;)
21:34:14 <hatds> everything about trifecta sounds awesome :)
21:34:33 <edwardk> its mostly me porting a bunch of parsing and pretty printing code from other projects
21:34:54 <edwardk> the main focus is on 'human scale' languages, so don't expect to deal nicely with gigabytes of xml
21:35:07 <edwardk> it holds the entire buffer in memory
21:35:43 <hatds> I'm also speaking about the typeclasses/datatypes/etc design you've got going.  The code looks interesting to read itself.
21:36:00 <edwardk> i may eventually add the ability to deal with fractions of the rope at a time, because the "It" mini-iteratee machinery i'm using is somewhat extensible.
21:37:22 <edwardk> ok, ported the last big thing out of parsec
21:37:35 <edwardk> (the Expr parser)
21:37:43 <edwardk> i don't really care about the permutation parsers
21:38:29 * ddarius has never seen the permutation parsers used in practice.
21:38:57 <edwardk> i'm going to punt on porting my c preprocessing stuff. i have the vestigial support i need for it in the form of the path fragments in the tree
21:39:14 <edwardk> i'll come back to it when i have a week or so to kill
21:39:57 <edwardk> i also need to add all the monad transformer instances for MonadParser and MonadTokenParser
21:40:09 <edwardk> i just have the state one to show how its done so far
21:41:05 <edwardk> and i tweaked the way the token parser right so that i can supply a magic 'whiteSpace' combinator that does layout based on one of my kata layout parsers
21:41:15 <edwardk> er the way the token parser works right
21:41:21 * hackagebot bcrypt 0.0.1 - Haskell bindings to the bcrypt password hash  http://hackage.haskell.org/package/bcrypt-0.0.1 (AndrewMiller)
21:42:08 <shachaf> Isn't there already a bcrypt library?
21:42:38 <edwardk> there is a haskell-bcrypt library iirc
21:42:51 <edwardk> http://hackage.haskell.org/packages/archive/haskell-bcrypt/0.1/doc/html/Data-Digest-BCrypt.html
21:43:10 <ddarius> @google site:hackage.haskell.org hackagedb bcrypt
21:43:11 <lambdabot> http://hackage.haskell.org/package/haskell-bcrypt-0.1
21:43:11 <lambdabot> Title: HackageDB: haskell-bcrypt-0.1
21:44:32 <edwardk> hrmm any idea what haddock is complaining about when it says
21:44:32 <edwardk> haddock: internal error: unexpected argument to declName
21:44:43 <kmc> permutation parsing?
21:45:23 <ddarius> For when you need to parse permutations.
21:46:01 <ddarius> More seriously, think command line parameters or keyword arguments.
21:46:11 <hatds> what does "slicing support" in trifecta mean?
21:46:21 * hackagebot trifecta 0.15.1 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.15.1 (EdwardKmett)
21:47:05 <edwardk> you can 'mark' at any point in the grammar, and release back to it, you can split the rope for the input using this to seek, but you can also take any two marks and get a bytestring for what is between them
21:47:28 <edwardk> the usual idiom is to
21:47:36 <edwardk> sliced $ some crazy complicated parser
21:48:08 <edwardk> and it marks before and after, and replaces the result with the bytestring direct from the input spanning the range you parsed
21:48:40 <edwardk> useful for things like identifiers which when you parse them usually you build up some string one character at a time when you had a perfectly good contiguous representation right in the input
21:49:06 <edwardk> here you can just use a recognizing parser which can efficiently use skipMany, etc. and then slice the result when done
21:49:26 <hatds> ah I understand
21:49:45 <edwardk> since i intern the bytestring fragments that make up the input this can make a big dent in memory usage as well, if you don't mind paying for the entire source representation
21:49:59 <edwardk> this is why i keep talking about 'human scale'
21:50:12 <edwardk> aiming at programming languages, not the xml mines ;)
21:51:19 <hatds> all the interesting parsing I want to do is on tidy .hs files so that's perfectly fine :)
21:52:29 <edwardk> eventually i'll get done adapting the c preprocessor i had from another project (which was built using my older cruftier annotated ropes library)
21:53:03 <edwardk> then you should be able to get c preprocessed input to your parser, with diagnostics that understand the macro expansions
21:53:51 <ddarius> Maybe we should add "human-scale" to the description of Parsec so people stop complaining that it doesn't parse bytes into 4kb blocks faster than Binary.
21:54:01 <edwardk> haaahaha
21:55:39 <erasmas> ddarius: I second that!
21:57:29 <erasmas> I'm jumping in on a slightly off-topic question, but are there any haskell libraries that let you build a parser at runtime from a series of definitions? I've been working on something that will let you specify delimiters, quote characters, etc. and don't want to redo something out there already
21:57:44 <kmc> that sounds like any parser combinator library
21:58:22 <kmc> parsec, attoparsec, uu-parsinglib, edwardk's new trifecta hotness, etc
21:58:26 <erasmas> kmc: yes, but I'm looking more for the end business user and not the developer. For instance, editing a simple config file and running the program with your config file as a command line argument
21:58:53 <kmc> can you give a more specific example?
22:01:46 <erasmas> Sure -- usually it's dealing with delimited text, so I can narrow the scope down that much. The files are organized in the usual rows and columns, and a business user may need to say "sum the 3rd column where the 2nd column is equal to 'charge'". The business works with too many changing file formats and types to simply import into one database
22:02:49 <hatds> I want to tell the ghci debugger "continue to the next break point" but I can't seem to find the command.
22:03:17 <shachaf> hatds: Is there a difference between that and ghci
22:03:20 <kmc> erasmas, i don't see how it's a parsing problem
22:03:29 <shachaf> Er, s/ghci/regular continue?/
22:03:49 <hatds> shachaf: continue seems to ignore breakpoints and just finish evaluation
22:03:58 <shachaf> Oh.
22:04:04 * shachaf has never really used the ghci debugger.
22:04:21 <Phyx-> oh it's pretty awesome :)
22:04:25 <Phyx-> usually
22:04:28 <Phyx-> sometimes..
22:04:40 <kmc> erasmas, it sounds like you're designing and implementing a little programming language for describing reports
22:04:42 <Phyx-> on occasion..
22:05:33 <erasmas> kmc: The main issue is it's not convenient to write new parsers every time they receive a new delimited text file that they need to extract information from. I'd like to give them a meta-parser that can read a plain text config file to decide how to handle the parsing. But yes, it is starting to look like that...
22:06:19 <kmc> yes, your "config file" will rapidly become a Turing-complete programming language, which will eventually contain an ad-hoc broken slow implementation of half of common lisp
22:06:53 <hatds> oh man, one dream project I have filed away is to write an analyzer that reads a text file and comes up with an ad hoc AST
22:07:11 <kmc> erasmas, this is one reason to prefer an embedded domain-specific language
22:07:11 <hatds> and parse the file into that AST
22:07:17 <kmc> you get all the programming-language parts for free
22:09:27 <erasmas> kmc: I've been looking into EDSLs actually, but it's a bit advanced for me right now. I was able to get part of the way to my goal by creating a custom data type that could hold different data types, and the parser would decide how to parse a given "cell" based on the user definition. I stopped when it stopped feeling like Haskell... hence the request for advice
22:09:45 <kmc> i don't claim this EDSL should be a Haskell EDSL necessarily
22:10:40 <ddarius> kmc: Half of Common Lisp would be gigantic.
22:11:18 <kmc> it's hard enough to design a good programming language when you acknowledge that's the goal
22:12:09 <kmc> the things that grow out of "config files" or "personal home page generators" are generally monstrous
22:12:31 <ddarius> The problem could be simplified by only trying to convert to an Excel or database format from whence any processing could be performed.
22:13:24 <ddarius> I'll write a hosting service where you email your pages to upload them.  Let's see if we can get PHP implemented in Sendmail.
22:14:37 <erasmas> kmc: what do you recommend I research as far as the best way to handle parsing delimited "columns" into a user-specified data type? The reason I ask is, while my initial question was quite ambitious, it would be possible to limit most of the parsing to a handful of known formats (like csv and tab-delimited). The only questionable part would be whether to try treating a given cell as a...
22:14:39 <erasmas> ...string, integer, double, etc.
22:15:44 * ddarius will make a format with DOS line delimited postscript-style strings.
22:16:21 * hackagebot HTTP 4000.1.2 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.1.2 (GaneshSittampalam)
22:18:59 <erasmas> ddarius: the unfortunate part in all this is some small businesses are stuck with crappy software and limited reporting. They need a way to make the most of it while they look for better services. This program wouldn't have to hold up to everything, just most of their use cases
22:21:42 <edwardk> i need a name for a monad that is a parser which supports the whiteSpace combinator (and lexeme combinator) from languageDef, anything sufficiently catchy come to mind ?
22:21:59 <edwardk> later on i'll be using this to port my layout combinators
22:22:36 <tgeeky> grow?
22:22:54 <tgeeky> tense?
22:23:00 <kmc> i recommend pokémon names
22:23:05 <edwardk> =P
22:23:40 <hatds> Lexer?
22:24:00 <edwardk> i could go with MonadLexer
22:24:10 <edwardk> of course that being stronger than MonadParser seems silly
22:24:23 <copumpkin> MonadLuthor
22:24:27 <edwardk> =P
22:24:29 <c_wraith> lexing has never been easier than parsing
22:24:34 <edwardk> Luthor is already taken ;)
22:24:37 <copumpkin> only the 100th time someone's made that joke
22:24:38 <copumpkin> yeah
22:24:41 <copumpkin> but not MonadLuthor
22:25:46 <hatds> MonadParserLexicallyAware
22:26:17 <hatds> I'm not sure if MonadLexer sounding weaker than MonadParser is a problem
22:26:49 <shachaf> I wish there was a nicer Map syntax than lists of pairs.
22:27:02 <shachaf> s/Map/map type of data/
22:27:22 <quicksilver> lists of pairs are OK
22:27:30 <tgeeky> zip?
22:27:40 <quicksilver> also, let (==>) = (,) in [foo ==> bar, baz ==> bam]
22:27:53 <hatds> syntax? so you want something like map.key instead of lookup map key?
22:28:01 <shachaf> I guess, ==> makes it nicer.
22:28:16 <edwardk> MonadLexer works for now
22:28:49 <hatds> shachaf: find a nice unicode arrow :)
22:35:56 <ivanm> edwardk: going back through what you wrote: so trifecta doesn't work on lazily read values?
22:37:07 <edwardk> effectively i build a rope up and let you seek back and forth through it
22:37:13 <edwardk> clang and gcc don't either
22:37:39 <edwardk> they maintain the source in a set of source buffers annotated with a bunch of data
22:37:46 <edwardk> trifecta operates like that
22:38:36 <edwardk> basically the Parser type sits on a tiny little wannabe iteratee that only knows how to say that it wants more input and what the answer is if you don't happen to have any more for it
22:39:31 <edwardk> i may eventually revisit this, but don't hold your breath ;)
22:40:22 <ivanm> hmmmm....
22:41:25 <edwardk> but every time you hand this 'It' type your input, you have to hand it all of the input, because it doesn't hold onto any of it itself, it relies on the pump to push it a new rope when needed
22:41:32 <ivanm> what kind of parsing stuff does thsi give you over parsec, etc. ?
22:42:22 <edwardk> you can read the file incrementally, even if you have to hold all of it in memory, you can use user specified error types. you can transform the parsers with monad transformers and the result still admits parser commands
22:43:05 <edwardk> so i can do stream processing, you just need to keep the entire stream
22:44:51 <edwardk> other than that it gives a bunch of diagnostic support, and the position type is aware of preparsed line directives, so you can factor the need to think about those from your grammar, it gives efficient access to the current line, the ability to seek in the input
22:45:20 <tgeeky> edwardk: can you, or have you thought of parsing a document with an explicit width and a modulus?
22:46:04 <edwardk> you can use the input as a fingertree of buffers annotated with file position information, so if you want to find the 300th line of your file you can use the fingertree to get you in the ballpark quickly
22:46:08 <tgeeky> like deciding that you want to render column `mod` (5,6,7) a particular color if it's whitespace?
22:46:45 <edwardk> for old school fortran like things?
22:46:45 <tgeeky> i guess that means that if you know all of the lines have a specific width, you could do even better?
22:46:53 <tgeeky> no, for 'tensing' documents
22:47:03 <tgeeky> can i send you a screenshot of random thoughts?
22:47:05 <tgeeky> in vim
22:47:10 <edwardk> i don't quite follow the use of 'tensing' in that sentence
22:47:16 <tgeeky> i mean, taking a line of code
22:47:29 <tgeeky> and inserting whitespace judiciously
22:47:37 <tgeeky> s/taking a line/taking a *block*/ of code
22:47:48 <tgeeky> so that things line up... let me send you an ss
22:47:53 <edwardk> ah
22:48:19 <tgeeky> it may be ramblings of a mad man, but maybe it'll make sense to you
22:48:24 <edwardk> well, if you use my layout combinators you get some knowledge of indentation ;)
22:48:31 <edwardk> i need to port them over though
22:48:39 <edwardk> they were written on parsec originally
22:48:56 <tgeeky> another thing I am really thinking I'm dependent on
22:49:11 <tgeeky> is literate (or anti-literate) code
22:49:22 <tgeeky> like, markdown with embedded haskell, or haskell with markdown for comments
22:49:27 <tgeeky> but that's different
22:49:33 <tgeeky> and is above what you're doing
22:50:20 <edwardk> well, it'd be nice to have a little markdown parser, etc. but yeah not really in my scope
22:50:31 <tgeeky> edwardk: what I'm talking about a is a little more general
22:50:38 <tgeeky> edwardk: a simple (but probably wrong) way to say it
23:00:09 <tgeeky> edwardk: -> pm
23:01:21 * hackagebot zeromq-haskell 0.7.1 - bindings to zeromq  http://hackage.haskell.org/package/zeromq-haskell-0.7.1 (ToralfWittner)
23:06:13 <plat0> I've see the quote <“The next Haskell will be strict” -- Simon Peyton Jones> thrown around all over the place.  Is there substance to this rumour?
23:08:14 <shachaf> plat0: That depends on what you mean by "the next Haskell".
23:08:26 <shachaf> That quote doesn't refer to "the next version of Haskell", it refers to some future language.
23:08:59 <MichaelBurge> What's the best way to store state within a module? I want to attach plugins to a base module, and each plugin should be able to store its own state.
23:09:13 <ddarius> Languages never die, so there is no opportunity for there to be a "next Haskell."
23:09:24 <fengshaun> is it possible to make a tuple an instance of Functor?
23:09:30 <fengshaun> how would I do that?
23:09:38 <ddarius> Tuples are instances of Functor.
23:09:41 <shachaf> @instances Functor
23:09:42 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
23:09:43 <fengshaun> instance Functor (,) where?
23:09:45 <ddarius> > fmap (1+) (2,3)
23:09:46 <lambdabot>   (2,4)
23:09:52 <fengshaun> oh thanks!
23:10:08 <fengshaun> where can I find its definition?
23:10:11 <plat0> shachaf: I see.  I assumed he meant the next Haskell standard would incorporate it somehow.
23:10:23 <ddarius> plat0: If that were the case, it would already be false.
23:10:30 <plat0> Laziness is great.  Why would anyone want to get rid of it?
23:10:44 <plat0> ddarius: OK, thanks.
23:11:15 <plat0> It seems that with laziness you get to control your own evaluation strategies, whereas with strictness you have far less control.
23:11:21 * hackagebot dph-base 0.5.1.1 - Common utilities and config for Data Parallel Haskell  http://hackage.haskell.org/package/dph-base-0.5.1.1 (BenLippmeier)
23:12:53 <hatds> I'm intrigued though by the original statement that the "next Haskell" will be strict
23:13:16 <hatds> why single out strictness as being key?
23:13:37 <ddarius> hatds: Without the context, what makes you think that that is what is being done?
23:14:36 <shachaf> Here is the context: http://www.cs.nott.ac.uk/~gmh/appsem-slides/peytonjones.ppt
23:14:45 <edwardk> i don't think the next haskell will be strict. and if it is, it won't be the next haskell ;)
23:15:36 <ddarius> edwardk: Just like the next Haskell won't have dependent types.
23:16:18 * ddarius really likes xmonad by the way.
23:17:07 <ddarius> (Anyway, as I said above, there will never be a "next Haskell.")
23:17:09 <plat0> Me too.  Started using it yesterday.
23:17:40 <shachaf> ddarius: As a WM or as a piece of Haskell code? :-)
23:17:48 <ddarius> shachaf: The former.
23:17:56 <shachaf> Ah.
23:18:06 <shachaf> Weren't you using fvwm or something like that until recently?
23:18:12 <ddarius> shachaf: Me?
23:18:32 <shachaf> Yes (but I might be thinking of someone else).
23:18:50 <edwardk> yeah 'this 'next haskell' thing reminds me of something john scalzi wrote once about how you can't copy his career path because it doesn't exist any more. you can have your own path, and you may be inspired loosely by his or others, but you can't have his, or heinleins, or ursula k. leguin's, etc.
23:18:55 * jocom not only likes Xmonad, but also /the/ Xmonad
23:19:14 <edwardk> same with languages you can't be haskell — its already there. you can draw some loose inspirations and see if you can carve out your own niche
23:19:15 <ddarius> shachaf: I've been using xmonad for about as long as it has existed.  Immediately before that I was using Windows XP, though I've used ion and BlackBox before then.
23:19:33 <shachaf> Oh.
23:19:55 * shachaf used xmonad from about the time it was renamed to xmonad to ~September of last year.
23:20:13 <jocom> shachaf: And after that?
23:20:30 <shachaf> Metacity, because I'm using a new computer and haven't gotten around to setting it up again.
23:20:39 <jocom> k
23:20:53 <shachaf> kmc: I'd use kmcwm, though. :-)
23:21:21 * hackagebot dph-prim-interface 0.5.1.1 - Backend Interface for Data Parallel Haskell  http://hackage.haskell.org/package/dph-prim-interface-0.5.1.1 (BenLippmeier)
23:21:23 * hackagebot dph-prim-seq 0.5.1.1 - Sequential Primitives for Data-Parallel Haskell.  http://hackage.haskell.org/package/dph-prim-seq-0.5.1.1 (BenLippmeier)
23:21:25 * hackagebot dph-prim-par 0.5.1.1 - Parallel Primitives for Data-Parallel Haskell.  http://hackage.haskell.org/package/dph-prim-par-0.5.1.1 (BenLippmeier)
23:22:11 <edwardk> interestingly 90% of the power of the language definitions in Text.Parsec.Language come from having the whiteSpace combinator
23:22:29 <edwardk> there are only 4 combinators you can't build with that alone
23:23:06 <ddarius> My experience using Windows 7 for work and also watching others use more traditional WMs just drives home that xmonad's (and other similar WMs') approach is just more usable.
23:23:22 <shachaf> ddarius: More than Ion's?
23:23:47 <ddarius> ion's is similar to xmonad, though I do think xmonad is noticable better than ion.
23:24:04 <ddarius> I really liked ion when I used it.  I can prove this because I was using it on Windows.
23:24:39 * shachaf kind of bought kmc's arguments about Ion's general approach being better than xmonad's.
23:25:03 <shachaf> ddarius: Just to manage X11 windows, or for Windows windows too?
23:25:06 <kmc> yeah; in Ion you choose where to split the screen
23:25:09 <ddarius> I don't use most of the power xmonad provides.  I virtually never use tiling.
23:25:31 <kmc> iirc you can split any rectangle horizontally or vertically, so you draw exactly the 2D tree you want
23:25:38 <ddarius> shachaf: Just for X11 Windows, though if I had Firefox in it, that would have been most of what I needed.
23:25:55 <kmc> in xmonad this is decided for you by an algorithm that takes window info and maybe a few tunable parameters
23:26:24 <kmc> the model xmonad implements is fundamentally not what i want
23:26:38 <ddarius> kmc: In normal window managers you can shape every window to whatever size you want.
23:26:42 <kmc> but the implementation of that wrong model is so good (compared to ion, for example) and it's close enough
23:26:54 <shachaf> When I used xmonad I mostly used windows in full-screen mode, except for the occasional tilings for specific workspaces, which usually didn't change much. When a window accidentally took over the place of a different one, I became annoyed.
23:26:56 <ddarius> The model in xmonad is also not what I want, but it includes what I want as a special case.
23:27:12 <kmc> ddarius, right -- what I'm asking for is intermediate on the control / automation tradeoff
23:27:18 <ddarius> Also, I'm pretty sure you can grow windows.
23:27:38 <kmc> i'm fine with xmonad-style layout algorithms as long as i can adjust the output arbitrarily
23:27:40 <ddarius> I.e. make a tile taller an arbitrary amount via the user interface.
23:27:45 <kmc> really?
23:28:01 <kmc> most layouts have one or two parameters that sort of do this
23:28:09 <ddarius> I'm pretty sure, though it's been a long time since I looked.
23:28:15 <kmc> which is obviously fewer degrees of freedom than being able to move any split-edge
23:28:35 <ddarius> At any rate, you can certainly implement what you want fairly easily, so why not just do that?
23:28:43 <kmc> easily?
23:29:05 <ddarius> Why would it be difficult?
23:29:35 <kmc> the way xmonad core, your layout algorithm, and the UI communicate are not well-suited to this task
23:30:08 <kmc> i have in fact looked into it
23:30:12 * shachaf liked how Ion let you nest window management arbitrarily. I.e. workspaces are artbirary splittings/tabbings of other workspaces (or windows).
23:30:35 <ddarius> kmc: It may not be trivial, but I still can't imagine it being very difficult.
23:30:35 <plat0> This is what SLPJ wrote about laziness: "Purity is more important than, and quite independent of, laziness.  The next ML will be pure, with effects only via monads.  The next Haskell will be strict, but still pure."
23:30:47 <kmc> ddarius, argument by lack of imagination ;P
23:31:01 <kmc> i think the complexity of a *good* static layout manager for xmonad would be on the same order as a new window manager using some code from xmonad
23:31:10 <kmc> there's not a sharp line between those two, anyway
23:31:11 <ddarius> kmc: It can't be any more difficult than implementing ion.
23:31:21 * hackagebot dph-seq 0.5.1.1 - Data structures for Nested Data-Parallel Haskell.  http://hackage.haskell.org/package/dph-seq-0.5.1.1 (BenLippmeier)
23:31:23 * hackagebot dph-par 0.5.1.1 - Data structures for Nested Data-Parallel Haskell.  http://hackage.haskell.org/package/dph-par-0.5.1.1 (BenLippmeier)
23:31:42 <kmc> plat0, is that a factual statement about the next ML, or a prediction?
23:32:08 <ddarius> kmc: It's a vacuously true tautology.
23:32:25 <kmc> because there will never be a new version of ML
23:32:44 <kmc> plat0, SPJ did say that, yes
23:32:56 <kmc> others have compelling arguments for the value of pervasive laziness
23:33:00 <ddarius> kmc: That wasn't "next version of ML."
23:33:03 <kmc> i'm not sure how it will all shake out
23:34:10 <fengshaun> where can I find the definition file for Control.Monad.Instances?
23:34:54 <kmc> fengshaun, http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
23:34:58 <kmc> those docs have source links
23:35:24 <kmc> guess http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/index.html is more comprehensive
23:35:48 <fengshaun> kmc: thanks a lot!
23:36:04 <kmc> fengshaun, if it's not on there you can look up the package on Hackage
23:36:20 <fengshaun> I did, I couldn't find a link to the source
23:36:35 <fengshaun> oh wait, hackage or hoogle?
23:36:38 <kmc> hackage
23:36:39 <kmc> http://hackage.haskell.org/package/base
23:36:52 <fengshaun> oh, I didn't check that, thanks a lot!
23:37:02 <kmc> you do have to know which package it's from, though :/
23:37:26 <ddarius> Why would someone do something silly like check the place where all the source is stored for distribution?
23:37:59 * hackagebot tkyprof 0.0.4 - A visualizer for GHC Profiling Reports  http://hackage.haskell.org/package/tkyprof-0.0.4 (MitsutoshiAoe)
23:39:31 <fengshaun> kmc: none of those links gives me the definition for Function ((,) a)
23:39:35 <fengshaun> Functor*
23:40:13 <shachaf> fengshaun: http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/src/Control-Monad-Instances.html does...
23:40:15 <kmc> it's there
23:40:35 <kmc> btw you can do ":i Functor" or ":i (,)" in GHCi and get:
23:40:40 <kmc> instance Functor ((,) a) -- Defined in Control.Monad.Instances
23:41:07 <fengshaun> oh, source on the top right!
23:41:11 <fengshaun> shachaf: thanks
23:41:32 <shachaf> kmc: Right, but fengshaun already knew what file it was in, presumably, having asked about the source of that file earlier. :-)
23:41:51 <fengshaun> yea, I had already checked :info
23:42:00 <ddarius> The fundamental problem is a lack of reading, something which is difficult to address over IRC...
23:42:09 <kmc> fengshaun, or "Control-F source" in your browser
23:42:33 <fengshaun> that, too! :)
23:55:39 <kolbsoft> hello all
