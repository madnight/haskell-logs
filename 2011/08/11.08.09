00:39:06 <frerich> Is there some other aggregation of useful Haskell blogs besides planet.haskell.org - or is that the one-stop-shop for my daily dose of Haskell food-for-thought?
00:44:16 <Ke> which one is preferred way for FFI wrapper, take [a,b,c] as parameter or let user do a .|. b .|. c
00:47:20 <arcatan> frerich: there's http://www.reddit.com/r/haskell
00:59:16 <luite> is there still some site that shows reverse dependencies for hackage?
00:59:28 * hackagebot thespian 0.9 - Lightweight Erlang-style actors for Haskell  http://hackage.haskell.org/package/thespian-0.9 (AlexConstandache)
00:59:52 <sordina2> I'm having trouble with installing Codec-Image-DevIL-0.2.3. There it doesn't seem to be able to detect my libraries for libdevil that I installed with macports.
01:05:45 <NihilistDandy> You could try configuring manually and pointing to the libs
01:05:58 <NihilistDandy> Also, you could try not using Macports because it's a dinosaur
01:06:38 <Lymee> NihilistDandy, dinosaurs arn't alive anymore.
01:06:44 <NihilistDandy> Lymee: Exactly
01:06:57 <Lymee> You can't use something that's dead!
01:07:17 <NihilistDandy> Macports users continue to make the attempt
01:07:43 <Lymee> Oh. So it's like trying to revive dinosaurs from fossiles?
01:07:45 <Lymee> Makes sense!
01:09:01 <stobix> how do I do a strict assignment? (google sucks when searching for non-ascii...)
01:09:06 <sordina2> NihilistDandy: what do you recommend?
01:09:12 <NihilistDandy> Homebrew
01:09:43 * stobix just realizes that "haskell strict assignment" is pure ascii, and flees in shame
01:09:44 <NihilistDandy> But as long as you're in your current situation, how did you install GHC?
01:10:01 <NihilistDandy> And what version, and so on
01:10:06 <quicksilver> stobix: but what do you mean by assignment?
01:10:44 <sordina2> NihilistDandy: I used the haskell platform. GHC seems fine, it's only complaining about devil
01:11:15 <NihilistDandy> Is it complaining about it, or not finding it?
01:11:30 <NihilistDandy> Nevermind, I remembered
01:11:52 <NihilistDandy> Is there a config script in the source files for the package you want?
01:11:58 <sordina2> The crucial error message is "Missing C library: IL"
01:12:20 <sordina2> however I have it installed in /opt/local/include and /opt/local/lib
01:12:47 <quicksilver> cabal install won't search /opt by default.
01:12:52 <NihilistDandy> ^^
01:13:02 <NihilistDandy> Just edit your .cabal/config
01:13:19 <NihilistDandy> extra-libdirs, extra-includes
01:13:23 <sordina2> Yes, which is why I have referenced extra-include-dirs: /opt/local/include And,  extra-lib-dirs: /usr/lib, /opt/local/lib
01:13:28 <NihilistDandy> Ah
01:13:55 <NihilistDandy> hmm
01:13:57 <sordina2> Doesn't seem to make any difference though.
01:14:08 <NihilistDandy> Welp, gimme a minute to download the source
01:14:19 <sordina2> Are multiple values comma separated in .cabal/config?
01:15:23 <quicksilver> does cabal-install have docs anywhere?
01:15:33 <quicksilver> in particular, the format of .cabal/config
01:16:20 <NihilistDandy> sordina2: Also, am I correct that you are using the current HP, or are you using an older one?
01:16:29 <stobix> quicksilver: hm. I think I want to make foo = (+3)[1..100] more eager, perhaps. Or, rather, to have a big list instead of a CAF, to see if that would improve performance.
01:16:33 <sordina2> quicksilver: I couldn't find it
01:16:52 <sordina2> NihilistDandy: 7.0.3 I believe
01:16:54 <quicksilver> stobix: "foo =" isn't an assignment, it's a definition.
01:17:04 <NihilistDandy> Yup
01:17:07 <stobix> ah, right
01:17:14 <quicksilver> stobix: definitions don't do any work so making it 'more strict' won't change anything.
01:17:33 <quicksilver> foo is a big list (as well as being a CAF).
01:18:41 <stobix> quicksilver: hmkay. Guess I'll just drop it, then, and think about it differently. Thanks. :)
01:19:27 <NihilistDandy> sordina2: Okay, do you have the source tarball?
01:19:36 <NihilistDandy> Well, you do, but can you get to it?
01:20:06 <sordina2> For libdevil, or codec-image-devil
01:20:33 <NihilistDandy> codec-image-devil
01:21:12 <sordina2> I can just cabal unpack it if that will help.
01:21:23 <NihilistDandy> Whatever will get you into the directory
01:22:14 <sordina2> okay done
01:22:30 <NihilistDandy> Then incant `cabal configure --extra-include-dirs=/usr/opt/include --extra-lib-dirs=/usr/opt/lib
01:22:33 <NihilistDandy> `
01:22:46 <quicksilver> stobix: thinking differently is the key :) There are certainly cases wher eyou want to understand when evaluation occurs.
01:22:47 <NihilistDandy> Grep the output for when it looks for libdevil, and see if it finds it
01:23:08 <quicksilver> stobix: but map (+3) [1..100] should be fine. it should do the work on demand but only once.
01:23:33 <NihilistDandy> sordina2: Sorry, add -v to that incantation
01:23:47 <sordina2> ah
01:25:08 <NihilistDandy> Also, macports installs pkg-config, right?
01:25:47 <luite> hmm, cabal-install for some packages breaks other packages for me, how can I find out why this happens?
01:26:07 <sordina2> Yes, it does
01:26:25 <NihilistDandy> luite: ghc-pkg list, look for conflicts
01:26:29 <sordina2> NihilistDandy: It looks like it's installing with the flags provided on the commandline
01:26:32 <sordina2> Very odd
01:26:36 <NihilistDandy> Oh, cool
01:26:45 <luite> NihilistDandy: how? I only get a list of packages, some are marked broken, but I don't know why
01:26:53 <quicksilver> luite: probably to do with installing some in the local DB and some in teh global DB.
01:27:31 <luite> quicksilver: no, everything is local
01:27:35 <NihilistDandy> luite: Do you have multiple version of some packages?
01:29:35 <sordina2> Lol: http://stackoverflow.com/questions/6597599/documentation-cabal-install-configuration-file/6619725#6619725
01:29:57 <luite> hmm, only for data-default (though in general having multiple versions of a package shouldn't be a problem)
01:30:37 <quicksilver> luite: in general it is a massive problem.
01:30:43 <quicksilver> in some specific cases it may not be a problem.
01:32:36 <NihilistDandy> What's actually broken?
01:32:37 <NihilistDandy> Anything?
01:32:59 <NihilistDandy> Are any executables broken because of this supposedly broken library structure?
01:33:17 <luite> hmm, it does appear to be related to this package
01:33:35 <NihilistDandy> ghc-pkg check will help
01:35:15 <NihilistDandy> I don't know how in the hell I managed to build cabal-install without mtl :|
01:35:56 <ArnoVanLumig> I'm reading data from a socket using an enumerator from enumHandle, but I need to set a buffer size
01:36:15 <luite> hmm, I accidentally fixed it
01:36:22 <ArnoVanLumig> I want it to give me as much data as it currently has
01:36:44 <NihilistDandy> luite: What'd you do?
01:36:49 <ArnoVanLumig> if I set the buffer size too large, will it wait for that much data to arrive or just give me whatever is available right now?
01:38:56 <luite> NihilistDandy: removed one of the data-default packages and installed the broken packages in some specific order
01:39:01 <NihilistDandy> neato
01:39:11 <luite> but I've found the problem now
01:40:11 <NihilistDandy> I just nearly cleared all the errors I got from check
01:40:22 <NihilistDandy> How I lost half my libs, I'll never know
01:47:48 <cheater_> anyone know if XQuery's "return" is similar to Python's "yield"?
01:56:51 <Nisstyre> cheater_: I don't know xquery, but I doubt it
01:57:01 <Nisstyre> does xquery support generators?
01:57:42 <Nisstyre> yield is usually meant to implement a lazy iterator in python
01:58:26 <Nisstyre> it can also do this weird thing similar to coroutines where it can switch context between the generator and other code
02:07:44 <cheater_> Nisstyre, xquery has for loops that can use return
02:07:50 <cheater_> but i don't know if return is used in other places as well
02:09:07 <chrisdone> Kind mis-match
02:09:08 <chrisdone>     An enclosing kind signature specified kind `(* -> *) -> (* -> *) -> *',
02:09:08 <chrisdone>     but `SubmissionEntity' has kind `* -> * -> *'
02:09:08 <lambdabot> chrisdone: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:09:15 <chrisdone> : (
02:09:30 * hackagebot yesod-auth 0.6.1.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.6.1.1 (MichaelSnoyman)
02:09:32 * hackagebot bindings-levmar 1.0.0.1 - Low level bindings to the C levmar (Levenberg-Marquardt) library  http://hackage.haskell.org/package/bindings-levmar-1.0.0.1 (BasVanDijk)
02:09:34 * hackagebot levmar 1.1.0.1 - An implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/levmar-1.1.0.1 (BasVanDijk)
02:09:38 * chrisdone adds more annotations
02:09:46 <chrisdone> is there no kind inference?
02:10:09 <quicksilver> there is kind inference but it's of a particularly simple form
02:10:24 <quicksilver> it assumes the simplest possible kinds
02:10:24 <Nisstyre> cheater_: so you can return more than once?
02:10:32 <Nisstyre> that sounds like it could be similar to yield
02:10:37 <quicksilver> data Foo a b = MkFoo (a b)
02:10:46 <quicksilver> ^^ will infer * for b and *->* for a
02:10:57 <quicksilver> although there are other kinds consistent with that.
02:11:28 <quicksilver> (all kinds of the form b :: k, a :: k -> *, would be valid, but we don't infer 'polymorphic kinds')
02:11:46 <chrisdone> (ah, ok. for: type SubmissionEntity (typ :: * -> *) (wrap :: * -> *) = …, and then type Definition (entity :: (* -> *) -> (* -> *) -> *) = entity Table Expr, then Defintion SubmissionEntity, it's ok— but without the annotation on SubmissionEntity it fails)
02:11:56 <chrisdone> hmm
02:12:09 <chrisdone> right, it infers that for a
02:13:10 <quicksilver> kind inference is also done independently per definition, AFAIK
02:13:13 <quicksilver> although I've never tested that.
02:13:29 <quicksilver> so later constraints - like teh way you happen to use 'Definiton' in a later type - will never feed back to the kinds inferred.
02:13:41 <quicksilver> in general if you're doing something subtle and higher-kinded, annotate.
02:14:10 <chrisdone> i see. makes sense
02:14:31 <Nisstyre> cheater_: what do you think? Did you test to see if you could use it elsewhere?
02:16:45 <chrisdone> i feel like i'm stretching the limits of the type system when hacking on haskelldb types -_-
02:17:19 <chrisdone> damn, no partial application for type synonyms
02:17:52 <quicksilver> chrisdone: general rule - don't use type synonyms :P
02:18:06 <chrisdone> :p
02:18:15 <chrisdone> type Record r = RecNil -> r  	-- Defined in Database.HaskellDB.HDBRec
02:18:31 <Nisstyre> quicksilver: I thought they were good for small oneoff things, like defining [Char] as String
02:18:32 <quicksilver> the only thing they are really useful for, IMO, is encapsulating huge typeclass contexts
02:18:39 <quicksilver> which is hard to do in another way.
02:18:57 <quicksilver> I would always use a newtype when I wanted to make a real simplification to a complex type / family of types.
02:19:04 <chrisdone> don't you do huge typeclass contexts with class aliases?
02:19:11 <quicksilver> chrisdone: well, not everyone follows the wisdom of quicksilver :(
02:19:12 <chrisdone> i've never put a class context in a type synonym
02:19:17 <chrisdone> lol yeah
02:19:46 <quicksilver> yes, forgot about using a class for that
02:19:49 <quicksilver> feels like a hack to me.
02:20:28 <chrisdone> type Definition entity = entity Table Expr
02:20:29 <chrisdone> -- type Result entity = entity Record TId -- can't write this, annoying (Table is a concrete type of course)
02:20:45 <chrisdone> can't think of a way to define the second one… not without type lambdas or something. hmm
02:21:46 <quicksilver> use a newtype.
02:21:57 <Nisstyre> chrisdone: I assume it's because the value constructors are conflicting right?
02:22:04 <chrisdone> i was thinking that but then all the functions constructing the values will have to use that newtype
02:22:11 <quicksilver> indeed.
02:22:40 <Nisstyre> can't you just use an algebraic type there?
02:22:53 <chrisdone> like what?
02:23:13 <cheater_> Nisstyre, i don't have an interpreter for that
02:23:41 <Nisstyre> oh wait nvm
02:23:48 <Nisstyre> that wouldn't work for what you want either
02:34:18 <chrisdone> hmm. how do you define a type equality operator?
02:34:58 <chrisdone> ah, i guess this will do eq :: a -> a -> x; eq = undefined
02:35:06 <companion_cube> with church boolean ? :)
02:36:23 <dmwit> data Eq a b where Refl :: Eq a a
02:37:03 <dmwit> Alternately, you can just write (a ~ b) in your context if you want to demand that a and b are equal.
02:37:27 <dmwit> e.g. instead of foo :: Eq a b -> c it would be foo :: a ~ b => c
02:38:36 <dmwit> chrisdone: (no content here, just writing your name so it highlights you =)
02:38:47 <dmwit> gotta run
02:38:49 <chrisdone> haha, nice
02:38:51 <chrisdone> undefined :: Definition SubmissionEntity ~ Result SubmissionEntity => c
02:39:05 <chrisdone> Couldn't match expected type `Result SubmissionEntity'       against inferred type `Definition SubmissionEntity' — not exactly what i expected
02:39:38 <luite> I'm trying to do cabal-dev add-source HTTP-4000.1.1.1, but it complains: cabal: dist/src/sdist.-7709/HTTP-4000.1.1.1: does not exist
02:39:43 <luite> how do I make that file?
02:40:43 <dcoutts> luite: are you using a dev version of cabal-install?
02:40:51 <chrisdone> :t eq (undefined :: Definition SubmissionEntity) (undefined :: Result SubmissionEntity) gives more information: Couldn't match expected type `Expr Int'    against inferred type `TId Int'
02:40:51 <lambdabot> parse error on input `type'
02:42:17 <luite> dcoutts: hmm, I think I might have patched it to build cabal-install with Cabal 1.2
02:42:21 <luite> err, 1.12
02:42:47 <dcoutts> luite: but I mean a non-release version of cabal-install
02:43:06 <dcoutts> luite: there was an intermediate cabal-install version with a bug that looks like what you're seeing
02:43:43 <luite> dcoutts: it's 0.10.2 with Cabal 1.12.0
02:43:55 <luite> oops, 0.10.2.1
02:43:58 <luite> oh wait
02:44:03 <luite> that's my own patched version
02:44:03 <chrisdone> ah, :t Refl :: Eqq (Definition SubmissionEntity) (Result SubmissionEntity) at least gives Couldn't match expected type `Expr Int' against inferred type `TId Int'
02:44:10 <luite> it' just 0.10.2 with modified dependencies
02:44:52 <kostis> Oh, this is cool.
02:45:20 <quolle> Coming from Java, the main difference I'm seeing between Java and Haskell is memory allocation. Can anyone add to this? (I'm very interested in finding out the differences etc)
02:45:45 <luite> whoah is that the main difference?
02:45:51 * chrisdone needs to test with smaller types
02:45:58 <froztbyte> that..seems a bit of a simplistic comparison
02:46:15 <froztbyte> not that I know enough about haskell to even start pointing at examples though :(
02:46:37 <luite> quolle: do you mean that values in haskell are immutable?
02:47:07 <quolle> luite: yes and how that relates to GC
02:47:56 <Cale> Functions are a pretty big difference. Haskell has proper support for functions while Java doesn't.
02:48:01 <Axman6> quolle: that is the thing you differentiate haskell and java? not the completely different way of building programs?
02:48:03 <chrisdone> http://chrisdone.com/crap/merg.png ~_~
02:48:22 <luite> quolle: hmm, GC is just an implementation detail I think, but doesn't java use a similar approach, a generational GC that copies longer living data?
02:49:02 <quolle> Cale: expand
02:49:11 <Cale> By which I mean that in Haskell, functions are values, and you can construct new ones at runtime.
02:49:12 <Axman6> java has no functions
02:49:41 <frerich> quolle: There are plenty of other differences; for instance, Haskell is statically typed but the types are deduced to a large degree - so you often don't have to type out the types of expressions. Another difference is that in Haskell, functions are "pure" by default (they have no side effects - when given the same arguments, they will always return the same value) and impure only if you explicite make them.
02:49:44 <Cale> and not only this, but beyond that, functions are proper mathematical functions, which means that if you give the same parameters to a function, you always get the same result
02:49:58 <Cale> (functions are pure)
02:50:03 <Axman6> objects have methods which you can use a functions, but they're not first class. there's also no such thing as ADT's in java (they can be emulated, but damn it's ugly)
02:50:34 <quicksilver> chrisdone: why did you pixel double the screenshot?
02:50:49 <Cale> Haskell also has first class IO actions which have no decent approximation in Java.
02:50:54 <quicksilver> or actualy, looks like you pixel-16-ed it.
02:51:13 <Cale> Those two things alone change the way that you write programs quite a lot.
02:51:19 <Axman6> quolle: looks fine to me
02:51:21 <Peaker> Cale: Suspended computations can be represented in Java, that's a (sad) approximation
02:51:39 <Cale> Peaker: yes, sort of, if you do closure conversion by hand
02:52:07 <Axman6> quolle: haskell's type system is vastly more powerful than java's as well
02:52:21 <dcoutts> luite: ah, ok, yes that'll do it. Your older cabal-install version built against the newer Cabal library will indeed exhibit that bug.
02:52:24 <quolle> Fair enough. Thanks for your input on this. Also, is there any major point you would bring forward if someone was debating whether to teach Java or Haskell in an first year undergraduate unit?
02:52:26 <Peaker> Cale: closure conversion by hand is done even in languages that have closures, OOP people love them :)   (self.x = x ; self.y = y ; ...)
02:52:38 <quolle> Had a choice out of Java and Haskell, I mean
02:52:40 <quolle> To teach
02:52:49 <Axman6> quolle: my first year CS course was haskell and java
02:53:09 <Axman6> 2/3 Haskell, 1/3 Java (the java was only so they could do the next semester's course)
02:53:13 <luite> dcoutts: good, I'll try HEAD instead, thanks :)
02:53:31 <quolle> Did you do compare the two languages in your course?
02:53:40 <Axman6> yes
02:53:46 <Axman6> java lost :P
02:53:50 <quolle> As in try to use each language to implement the same algorithm?
02:53:57 <Axman6> it wasn't a competition, but java still lost ;)
02:54:02 <Axman6> yes
02:54:18 <dcoutts> luite: make sure you get the patch 'Update cabal sdist to follow the changes in the Cabal lib'
02:54:34 <ksf> about the only discipline in which java wins is "overhyped management-driven programming"
02:54:47 <Axman6> http://cs.anu.edu.au/student/comp1100/ is the course if you're interested. i ended up tutoring the course for the last two years too
02:54:54 <luite> dcoutts: ok
02:55:03 <quolle> very nice. And finally: (totally hypothetical question), if someone told you that they were going to rewrite the Linux kernel in Haskell, your first response would be?
02:55:18 <ksf> bad idea.
02:55:23 <ksf> work on ddc and use that, then.
02:55:27 <quolle> (bear with me))
02:55:35 <quolle> oh, and also why
02:55:35 <Axman6> good, that might remove a lot of bugs and security concerns >_>
02:55:50 <Cale> Well, I think it's not a terrible plan, but the end result won't be Linux.
02:55:53 <Axman6> there's been a few OS's written in Haskell
02:55:56 <ksf> that's not to say that there isn't a research kernel thingy in haskell, which is interesting on its own.
02:56:08 <quolle> Axman6: examples?
02:56:09 <Axman6> the most recent and sucessful was the seL4 kernel from NICTA
02:56:19 <Axman6> there's also the house operating system
02:56:41 <Cale> Writing an operating system in Haskell is somewhat reasonable (though you may end up working on extra tools to some extent), writing Linux in Haskell seems silly.
02:56:51 <Axman6> yeah
02:57:07 <ksf> speaking of house and security, house could be completely secure on my hardware.
02:57:11 <Axman6> haskell would be much better suited fo a kernel that's small, and needs to be verified (like seL4)
02:57:11 <ksf> I've got an iommu.
02:57:50 <arcatan> ksf: what's that?
02:57:52 <frerich> quolle: The linux kernel has a huge C-centric community, shifting the programming paradigm to functional programming would lose a lot of momentum. That aside, the kernel appears to be working good enough for a lot of people, so why bother taking the risk of regressions by doing such a large rewrite.
02:58:02 <ksf> arcatan, virtual memory for dma, in a nutshell.
02:58:14 <Cale> It would essentially be a complete rewrite.
02:58:23 <Cale> No matter what you did
02:58:23 <quolle> time for poopoo brb sorry guys :P
02:58:29 <ksf> so some device driver can't hijack your whole system by telling the hdd to dma over main kernel memory
02:58:31 <Axman6> :|
02:58:54 <Axman6> on IRC, you can leave, take a shit, and come back, and no one ever has to know. that should also be a rule
02:59:03 <ksf> that's a very, very nice thing for virtualisation.
02:59:22 <Axman6> ksf: that's pretty sweet. what hardware?
02:59:23 * dcoutts agrees with Axman6 
02:59:31 * hackagebot unbounded-delays 0.1.0.2 - Unbounded thread delays and timeouts  http://hackage.haskell.org/package/unbounded-delays-0.1.0.2 (BasVanDijk)
02:59:34 <ksf> amd 990x chipset
02:59:42 <ksf> all 9-series chipsets have on
02:59:48 <markus3> hi guys! question: is there a place to define a deafault use list of language pragmas? I have been looking, but found no way..
02:59:51 <ksf> ...and they're am3+
02:59:57 <dcoutts> I thought all amd64 chips had an IOMMU
03:00:25 <ksf> it's listed in the chipset, not cpu features.
03:00:38 <ksf> also, I kinda doubt my ole athlon64 3200+ had one.
03:01:17 <kostis> Hello, chrisdone. I'm using tryhaskell.org :)
03:01:23 <kostis> Thanks for this awesome thing :D
03:01:26 <ksf> (if you want to buy a system *now*, go for a good am3+ board and a phenom II 955, and upgrade later to bulldozer. don't listen to intel fanboys)
03:01:52 <Axman6> i quite like my i7 :\
03:02:07 <quolle> when is bulldozer going to be released? I recently built an AM3+ system
03:02:16 <ksf> late september
03:02:35 <quolle> I bet that will run Haskell well.
03:02:37 <dcoutts> ksf: hmm, you're right. I'd always thought it was in the cpu itself. According to AMD they've been in chipsets since 2007
03:02:47 <ksf> by my upgrade strategy that'd be at least half a year early to buy stuff, though.
03:02:51 <Axman6> also the next Intel chips are going to be amazing for laptops, given the supposed power usage
03:03:01 <ksf> and sucky graphics
03:03:27 <Ke> not all AMD chips have iommu, I managed to get one without in 2010
03:03:38 <ksf> ARM is amazing for laptops.
03:03:50 <quolle> ARM laptops are hard to find
03:03:54 <Axman6> the intel graphics in my MBP are not noticibly bad, and sure reduce power usage when they're in use
03:04:06 <Ke> you really can't run proper linux on arm
03:04:09 <Axman6> quolle: buy an macbook air in about a year ;)
03:04:14 <Ke> it barely even has valgrind
03:04:28 <quolle> Axman6: really? Is this actually confirmed?
03:04:32 <Axman6> no
03:04:32 * hackagebot concurrent-extra 0.7.0.1 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.7.0.1 (BasVanDijk)
03:04:34 <Ke> 66% of toolchain breakage
03:04:55 <ksf> if with "not noticably bad" you mean "I don't ever use gl", then, yes.
03:05:01 <Axman6> but there's been lots of reports from various sources suggesting Apple are already testing such machines
03:05:14 <Axman6> ksf: i use OS X, everything uses OpenGL
03:05:27 <quolle> As long as they don't run iOS...
03:05:28 <ksf> desktop stuff isn't the type of gl I mean, though.
03:05:34 <Axman6> (not everything, but far more than one might expect)
03:07:33 <quolle> Alright, last question for my thesis: What OS do you Haskell hackers use as a "main" OS (main as in most used)
03:07:56 <ksf> linux
03:08:00 <ksf> almost sole, even.
03:08:08 <Axman6> there's lots of people using windows, OS X and linux
03:08:35 <quolle> ... a bit more specific :P (ie, distro/version etc)
03:08:41 <ksf> judging from the platform support, most use linux, a chunk osx, and then some windows. that is, at least there's not many *contributing* people using windows.
03:09:02 <TitusToia> Hello
03:09:03 <ksf> gentoo
03:09:10 <Axman6> at the hackathon i ran last month, more than half of the people were using macs
03:09:14 <ksf> arch has very good support, too.
03:09:29 <quolle> I've been learning Haskell on Arch myself.
03:09:32 * hackagebot threads 0.4.0.1 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.4.0.1 (BasVanDijk)
03:10:18 <quolle> ksf: Do you reckon Gentoo is bad for the environment in the way that they're constantly compiling and using a higher amount of power?
03:10:32 <ksf> I also can't think of a hackage package that would run on windows but not on *nix. the other way round is quite common.
03:10:51 <ksf> significantly less worse than my fridge.
03:11:02 <roderyk> speaking of osx, I've got an issue with gtk2hs. Maybe someone can help? Installed gtk and friends via Homebrew, cabal install gtk2hs-buildtools && cabal install gtk. Getting the following error: Building gio-0.12.0...
03:11:02 <roderyk> <command line>: cannot satisfy -package-id mtl-2.0.1.0-5b7a9cce5565d8cc8721ba4f95becf1b
03:11:32 <TitusToia> Hello, i must recognise i have a rather selfish plea at the moment; would anyone knowledgeable in Haskell wish to answer some questions for about 5 minutes?
03:11:50 <roderyk> using Haskell Platform 2011.2.0.1 x64 and cabal list mtl shows 2.0.1.0 installed
03:12:24 <quolle> TitusToia: go for it
03:12:28 <quolle> I'll do my best
03:12:37 <ksf> roderyk, try ghc-pkg list -v
03:12:40 <sordina2> Well that sucks... Devil continues to frustrate me - /bin/sh: line 1:  9479 Segmentation fault      ./mandel
03:12:48 <ksf> the hash has to match, too.
03:13:44 <TitusToia> Let me just figure out how to open a distinct chat window (i am using webchat)
03:14:46 <arcatan> i suggest you ask your questions here in the channel
03:17:09 <roderyk> ksf: I think that did it! ghc-pkg list -v complained that the cache was stale; after running 'ghc-pkg recache' the build seems to keep going
03:17:54 <luite> dcoutts: updated cabal-install works, I still had to bump some versions (unix, process, Cabal) to get it to build with 7.2.1
03:23:35 <jasonsudo> hello. i'm using ghci to test a module, and i want to be able to call functions private to that module from within ghci. do i have to export all these functions in the module definition, or is there some command in ghci that will let me access them?
03:24:02 <ksf> you can remove the .hi and .o of the module
03:24:19 <ksf> ...I think there's a flag to force interpretation (instead of using the compiled stuff), too.
03:24:55 <mauke> :l *foo.hs
03:25:09 <jasonsudo> why does the presence of the compiled code make a difference?
03:25:20 <luite> is there a way to have a global cabal-dev package list, available to all sandboxes?
03:25:24 <mauke> because the compiled code only exports the exported functions
03:26:45 <jasonsudo> and ghci uses it if it's there? gotcha
03:26:46 <Cale> jasonsudo: Because ghci will load that code instead if it's available
03:26:52 <Cale> yeah
03:27:12 <luite> say I have 20000 packages with small patches to get them to build with ghc 7.2.1 and I want cabal-dev tho find them automatically for all sandboxes
03:34:55 <roderyk> ksf: many thanks, gtk2hs works on my macbook.
03:35:57 <roderyk> I wonder if someone has experience with http://gtk-osx.sourceforge.net/ - it would be nice if gtk apps looked more native, but I'm not sure if the project is still active and worth the effort.
03:44:36 * hackagebot murmur-hash 0.1.0.4 - MurmurHash2 implementation for Haskell.  http://hackage.haskell.org/package/murmur-hash-0.1.0.4 (ThomasSchilling)
03:55:17 <ksf> is there any package that implements worker pools?
03:55:36 <cheater_> erlang?
03:55:39 <ksf> I've got a hackish implementation but I don't feel like improving on it.
03:55:43 <cheater_> that's written in haskell.. right?
03:56:19 <ksf> priority-sync solves the rest of my threading stuff, I think.
03:56:28 <cheater_> seriously though: i've seen people recommend using the erlang interface for this purpose
03:56:42 <ksf> but it doesn't manage keeping workers that are rather expensive to initialise around.
03:57:07 <ksf> you can write perfectly fine erlang in haskell.
03:57:29 <ksf> better, even, as you can have multiple chans per actor, and STM in general rocks.
03:58:04 <quicksilver> also, strong types rock :)
03:59:06 <ksf> ...I was thinking of using priority-sync as a manager for everything my gui needs to do.
03:59:53 * ksf hates unresponsive, not-decoupled guis
04:00:27 * Ptival approves
04:05:52 <pr> @hoogle cwd
04:05:53 <lambdabot> No results found
04:05:58 <ksf> also, haskellmode with -Wall rocks.
04:06:21 <mauke> @hoogle currentDirectory
04:06:21 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
04:06:21 <lambdabot> System.Directory makeRelativeToCurrentDirectory :: FilePath -> IO FilePath
04:06:22 <lambdabot> System.Directory setCurrentDirectory :: FilePath -> IO ()
04:06:26 <ksf> makes me even consider enabling -Werror for building
04:06:29 <pr> thanks mauke :)
04:06:41 <mauke> useMoreVerbosity
04:06:47 <pr> ohISee
04:07:12 <int-e> ah, but it should be  getCurrentWorkingDirectory  then.
04:07:19 <mauke> file a bug
04:20:06 <hpaste> Sordina pasted “DevIL Example” at http://hpaste.org/50052
04:21:16 <sordina2> Does that work for anyone else? I just seem to get a blank image, although the data can be read back in with Devil...
04:22:54 <sohum> @pl \(a,b) -> (f a, fb)
04:22:54 <lambdabot> flip (,) fb . f . fst
04:22:55 <sohum> @pl \(a,b) -> (f a, f b)
04:22:56 <lambdabot> f *** f
04:22:59 <sohum> right!
04:23:02 <ksf> what could be the reason that I can have two processes opening a .so and using it concurrently works, but having two threads (IO or OS) doing the same messes up?
04:24:53 <ksf> shouldn't opening a .so via dlopen give them completely different contexts?
04:26:05 <mux> a bug in the libc of your system making dlopen() not thread-safe? :-)
04:26:50 <sohum> @pl \x y -> foo x y a b
04:26:50 <lambdabot> flip flip b . flip flip a . foo
04:26:54 <Ke> it's not listed in thread safe functions
04:27:10 <Ke> dlerror eg. is
04:27:34 <mux> yeah but there is no a-priori reason for it not to be thread-safe, except maybe lazy coders
04:27:35 <ksf> I'm not calling dlopen() concurrently.
04:28:28 <zygoloid> ksf: why would they have different contexts? if you dlopen the same .so twice, you get the same handle back.
04:28:52 <mux> I don't see why things should be that way.
04:29:33 <ksf> yes, indeed, I do.
04:29:55 <ksf> the library only barfes its init blurb once, then reloads instead of doing a full init the next time.
04:30:16 <mux> that sounds like a rather stupid optimization
04:30:59 <mux> I obviously don't mind the runtime linker doing this when a library gets pulled out of different places, but not when I dlopen()
04:32:22 <zygoloid> mux: if you don't want that behaviour, use some mechanism other than dlopen; posix specifies that it works this way
04:32:43 <zygoloid> sadly, afaik there is no other suitable mechanism :(
04:33:22 <mux> uhu? last I checked dlopen() isn't even part of POSIX
04:33:31 <zygoloid> such a mechanism would be implementable, albeit hugely non-portably, in user-space
04:33:36 <mux> ah, it is
04:33:43 <mux> anyway the whole dlopen() API is implicitely broken
04:34:28 <mux> or rather, dlsym() is from the POV of the C standard
04:34:29 <zygoloid> if you want separate contexts for multiple loadings of the same .so, you'll need a policy for dealing with that .so's dependencies too
04:35:32 <zygoloid> rather than loading and relocating multiple copies of the code, it seems better to me to make it not depend on global state in the first place ;)
04:35:43 <ksf> RTLD_PRIVATE
04:35:53 <ksf> ...acording to the internets
04:36:14 <ksf> zygoloid, I'm not sure that'd be trivial.
04:38:14 <zygoloid> ksf: looks like RTLD_PRIVATE only loads that .so privately, so if it uses another .so with the same issue, you're still hosed
04:39:01 <BajaCalifornia> Hi.
04:39:06 <BajaCalifornia> Has anybody here ever had an enema?
04:39:18 <ksf> yeah, probably isn't worth the risk.
04:39:33 <zygoloid> BajaCalifornia: this is a forum for discussing the Haskell programming language
04:39:53 <ksf> wrapping the .so into a server seems more sensible.
04:42:43 <zygoloid> yeah. you'd need some kind of inter-process RPC layer, but i guess there's one^Wseveral of them on hackage :)
04:43:08 <ksf> ipc is deprecated.
04:43:19 <ksf> and, according to the wiki, is broken for chunks >4k
04:44:56 <ksf> msgpack looks like what I'm looking for.
05:19:57 <zhulikas> why does this fail? 'lines (readFile "D:\myfile.txt")'
05:20:09 <zhulikas> it can't match String IO type
05:20:18 <quicksilver> readFile returns IO String
05:20:22 <quicksilver> lines just wants a String.
05:20:25 <zhulikas> yup
05:20:32 <quicksilver> well, that's why it fails :)
05:20:33 <ion> Also, you need to escape the \
05:20:36 <zhulikas> so is there a function of type IO String -> String ?
05:20:44 <ion> :t (<$>) --zhulikas
05:20:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:20:46 <quicksilver> zhulikas: no, there is no, and that's important to understand
05:20:55 <quicksilver> you are about to get six different answers
05:20:58 <quicksilver> please listen to mine.
05:21:07 <zhulikas> ok
05:21:12 <Entroacceptor> IO String is a burrito
05:21:15 <quicksilver> my best guess at the right answer for you is:
05:21:27 <quicksilver> do data <- readFile "D:\\myfile.txt"
05:21:32 <quicksilver>    return (lines data)
05:21:42 <mauke> quicksilver: terrible!
05:21:43 <ksf> fuck msgpack-rpc is completely and utterly unsafe.
05:21:49 <quicksilver> the lesson here is that, you can't directly go from IO String to String
05:22:02 <quicksilver> but in 'do' notation you have the special <- syntax
05:22:05 <ion> entroacceptor: No, monad is a burrito, IO is one with mustard and cockroaches.
05:22:06 <zhulikas> but I don't see a difference between what I did and you did
05:22:15 <mauke> zhulikas: do you happen to know javascript?
05:22:17 <quicksilver> which binds a value to the result of an IO action.
05:22:22 <zhulikas> nope
05:22:25 <mauke> ah, too bad
05:22:34 <mauke> zhulikas: do you know any other programming languages?
05:22:34 <quicksilver> zhulikas: the difference is, that I used "<-" and do notation.
05:22:43 <quicksilver> zhulikas: 'data' is not the return value of readFile
05:22:43 <zhulikas> mauke, sadly I do
05:22:47 <mauke> which ones?
05:22:49 <ksf> in addition to listening on everything by default, it doesn't have any auth mechanism, short of say passing a secret with *every* request.
05:22:51 <quicksilver> it's the actual string
05:23:05 <zhulikas> Java/C#/ a bit of Scala
05:23:13 <quicksilver> so the 'do' keyword lets you execute the action and get at the result (using the special <- syntax)
05:23:30 <ion> data is also a keyword. :-)
05:23:30 <zhulikas> :t do
05:23:31 <lambdabot> Empty 'do' construct
05:23:46 <quicksilver> "IO String" is something like "a computer program which, if you run it, will compute a String"
05:23:48 <mauke> zhulikas: Haskell does everything with callbacks. 'do' notation is syntactic sugar for callback registration. (if that doesn't make sense, I may have confused you)
05:23:56 <quicksilver> ion: bother. yes. Don't use 'data' ;)
05:24:15 <quicksilver> this is very different from "String" which is, simply, a string.
05:24:25 <quicksilver> a better example for understanding is 'getLine'.
05:24:32 <zhulikas> :t getLine
05:24:33 <lambdabot> IO String
05:24:36 <quicksilver> each time you execute getLine you will (potentially) get a different value
05:24:37 * hackagebot todos 0.5.1 - Easy-to-use TODOs manager.  http://hackage.haskell.org/package/todos-0.5.1 (IlyaPortnov)
05:24:41 <quicksilver> so it's a good example of an IO String
05:25:08 <quicksilver> the reason ":t do" didn't work is that do isn't a function, it's a built in part of the language.
05:25:12 <illissius-> an 'IO a' is like the Runnable class/interface from various languages, which returns a value of type 'a' when run() is called on it
05:25:20 <mauke> illissius-: except not
05:25:21 * quicksilver nods at illissius- 
05:25:26 <mauke> because there is no 'run'
05:25:27 <illissius-> except you don't actually call run() on it.
05:26:03 <illissius-> but chain it to be run after some other Runnable
05:26:30 <zhulikas> :|
05:26:33 <quicksilver> zhulikas: other possible answers to your initial question were (lines <$> readFile "blah") or (liftM lines (readFile "blah")) or (fmap lines (readFile "blah")) or (readFile "blah" >>= \s -> return (lines s))
05:26:54 <quicksilver> but the reason I didn't give you any of those answers is that, personally, I think the do syntax is the easiest one to use as a new haskeller
05:26:56 <applicative> zhulikas, fmap lines (readFile filename)
05:26:57 <zhulikas> last two are almost understandable.
05:27:15 <mauke> zhulikas: if you want to understand the last one, see http://mauke.dyndns.org/stuff/haskell/how-to-io.html
05:27:21 <zhulikas> :t fmap
05:27:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:27:37 <zhulikas> I regret checking fmap type
05:27:43 <mauke> and I strongly disagree with quicksilver in that 'do' syntax is unsuitable for beginners
05:27:54 * quicksilver nods
05:27:55 <mauke> it's bad magic
05:28:06 <ion> lines :: String → [String]
05:28:12 <applicative> ^^ zhulikas it takes and ordinary function (a -> b) and makes it one that can act on IO a yielding IO b or [a] yielding [b]
05:28:17 <ion> fmap :: (String → [String]) → IO String → IO [String]
05:28:18 <zhulikas> I'll look into an article
05:28:21 <quicksilver> I find many beginners manage to abstract and generalise 'do' examples without fully understanding them, and then com eback and understand it later.
05:28:28 <ion> fmap lines :: IO String → IO [String]
05:28:33 <ion> fmap lines getLine :: IO [String]
05:28:41 <quicksilver> ...which (anecdotally) I think is easier than trying to understand >>= and fmap. Obviously mauke differs from me here.
05:28:44 <joe6> @hoogle File
05:28:45 <lambdabot> System.Posix.Types type FileID = CIno
05:28:45 <lambdabot> System.Posix.Types type FileMode = CMode
05:28:45 <lambdabot> System.Console.Editline.Readline filenameCompletionFunction :: String -> IO [String]
05:28:53 <applicative> > fmap lines ["hahah\nhaha"]
05:28:54 <lambdabot>   [["hahah","haha"]]
05:29:05 <mauke> quicksilver: screw fmap, teach them IO's >>=
05:29:05 <frerich> I think the explanation of actions or ("compotations") as callbacks or "Runnables" which are chained together is quite funky, I never viewed it like that.
05:29:12 <applicative> >  lines ["hahah\nhaha"]
05:29:13 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
05:29:13 <lambdabot>         against inferred type...
05:29:23 <mauke> and only IO
05:29:25 <applicative> ^^^ this is the same type error, mutatis mutandins
05:29:26 <mauke> no generalization
05:29:29 <applicative> ^^^ this is the same type error, mutatis mutandis
05:29:30 <zhulikas> > lines "asdfasdf\nasdf"
05:29:31 <lambdabot>   ["asdfasdf","asdf"]
05:29:48 <applicative> right, but now suppose you have a list of strings with newlines
05:30:10 <zhulikas> ok let's just leave it by now
05:30:13 <applicative> then you need to lift 'lines' so it acts on the separate strings, so you use map or fmap
05:30:14 <cizra2> Hi. How do I compile xmobar from Darcs source, telling it about my cabal-installed parsec and stm? It can't find them outta the box.
05:30:41 <mauke> cizra2: how did you configure it?
05:31:41 <cizra2> mauke: runhaskell Setup.lhs configure --flags="with_utf8"
05:31:47 <mauke> cizra2: try adding --user
05:31:50 <cizra2> mauke: (assuming you're talking about xmobar)
05:32:04 <Entroacceptor> cizra2: try cabal install --flags etc.
05:32:37 <cizra2> --user worked, thanks (=
05:33:45 <illissius-> frerich: I've viewed it like that ever since I came across use cases in Qt/C++ where I realized I could use QRunnable to solve a problem because I would've used IO () in the same situation in Haskell :)
05:33:47 <wjlroe> Has anyone used Haskell with collectd?
05:33:59 <illissius-> (whereas if I hadn't been Haskelling, I'm not sure if it would have occured to me.)
05:34:07 <zhulikas> is IO executable?
05:34:14 <mauke> zhulikas: depends on what you mean by that?
05:34:18 <illissius-> though obviously it can be viewed more than one way simultaneously
05:34:35 <zhulikas> mauke, http://mauke.dyndns.org/stuff/haskell/how-to-io.html#a4
05:34:54 <mauke> zhulikas: and?
05:34:56 <zhulikas> it says putChar '!' returns an IO action to print '!'
05:35:00 <mauke> yes
05:35:03 <zhulikas> and that action is assigned to main
05:35:06 <zhulikas> then runtime executes main
05:35:09 <mauke> yes
05:35:17 <zhulikas> that means it executes an IO action
05:35:20 <mauke> yeah
05:35:28 <mauke> the runtime is the only thing that can execute IO actions
05:35:42 <zhulikas> so if I store Haskell code in file and read it into IO, can I execute it? :)
05:35:51 <mauke> zhulikas: that makes no sense
05:36:11 <zhulikas> ok then I need to know the difference between IO action and a function
05:36:16 <mauke> zhulikas: well, you could parse it, analyze it, generate IO actions from it, then bind it to main
05:36:22 <mauke> that would work
05:36:30 <ion> IO action is a value like any other.
05:36:32 <mauke> but then you'd have effectively written a Haskell interpreter in Haskell
05:37:07 <mauke> zhulikas: a function is ... well, it's a value that you can apply to another value
05:37:12 <mauke> and get a third value back
05:37:12 <ion> IO String is a value. Maybe Integer is a value. [Bool] is a value. Function is anything of type a → b.
05:37:59 <ion> All functions are values but only a subset of values are functions.
05:38:01 <mauke> apply function to argument, receive return value
05:38:24 <mauke> zhulikas: what do IO actions and functions have in common?
05:39:09 <zhulikas> both return values?
05:39:17 <mauke> hmm, good answer
05:39:21 <zhulikas> \o/
05:39:37 <mauke> zhulikas: the difference is that functions require an input, and you can call them in plain Haskell
05:40:05 <mauke> zhulikas: IO actions don't take an input and you can't "call" them, especially not in Haskell. they have to be executed by the runtime system
05:40:08 <zhulikas> function without input is value?
05:40:17 <mauke> there are no functions without input
05:40:29 <ion> Functions return values, IO actions result in values when executed by the runtime.
05:40:40 <mauke> well, unless you want to call 'x' a function ... but I'd say it's just a Char
05:40:55 <ion> Rather: functions return values when applied to input values, IO actions result in values when executed by the runtime.
05:42:04 <ion> In ‘do’, you can draw the result value from the action with ←.
05:42:59 <ion> The type of the do block is an IO action as well. It combines the IO actions within to a new IO action which may be executed by the runtime.
05:43:04 <zhulikas> so with 'do' and <- I invoke the runtime execution of IO action?
05:43:09 <mauke> no
05:43:11 <zhulikas> damn
05:43:15 <mauke> that's exactly what doesn't happen
05:43:21 <ion> No, you only invoke the runtime execution of an IO action by assigning it to main.
05:43:22 <mauke> which is why I don't like ion's explanation
05:44:28 <zhulikas> so runtime execution is done only to the result of main ? and everything which is in main 'do' block is put into one joint IO action and then passed to runtime?
05:44:39 <mauke> zhulikas: yeah, basically
05:44:47 <zhulikas> hmm
05:44:49 <mauke> and it's not the "result" of main, really; main is a constant
05:45:13 <ion> :t readLine  -- an IO action
05:45:14 <lambdabot> Not in scope: `readLine'
05:45:19 <ion> :t getLine  -- an IO action
05:45:20 <lambdabot> IO String
05:45:21 <zhulikas> so runtime evaluates main, but what evaluates my code? Does a compiler compile my code into IO?
05:45:33 <ion> :t do l <- getLine; print l  -- the whole thing is an IO action as well
05:45:33 <lambdabot> IO ()
05:45:34 <zhulikas> sounds wrong...
05:45:51 <mauke> zhulikas: not evaluates; executes
05:45:57 <mauke> very important difference
05:46:21 <mauke> zhulikas: IO is a data structure, like lists or whatever
05:46:25 <zhulikas> well I thought runtime executes main :)
05:46:26 <mauke> zhulikas: what do you mean by "compile my code into IO"
05:46:27 <cebewee> if i would identify a looping ghc run with some ancient haskell-src-exts version, would anybody care?
05:46:48 <zhulikas> mauke, I define something inside main, then everything is combined into IO action (BY WHAT?) and then sent to runtime
05:47:05 <ion> :t let foo = do { l <- getLine; print l } in do { foo; print "done" }  -- this is an IO action as well. Just a value you can choose to assign to main to have it executed.
05:47:05 <lambdabot> IO ()
05:47:10 <mauke> zhulikas: no, you define a value and bind it to 'main'
05:47:18 <mauke> zhulikas: you combine stuff into one action
05:47:31 <mauke> by using the appropriate functions and operators, mainly >>=
05:48:29 <zhulikas> once again, do is a syntactic sugar for >>=?
05:48:36 <ion> yes
05:48:39 <mauke> zhulikas: http://mauke.dyndns.org/stuff/haskell/how-to-io.html#a7
05:48:52 <zhulikas> i didn't finish reading that
05:48:59 <zhulikas> wait 5mins, I'll get back
05:49:05 <zhulikas> if I will have any more questions :)
05:51:57 <Axman6> zhulikas: do is syntactic sugar for a bit more than that, but it's not much more
05:56:51 <ski> @undo do x <- foo; y <- bar x False; baz y x
05:56:52 <lambdabot> foo >>= \ x -> bar x False >>= \ y -> baz y x
05:57:08 <ski> @undo do x <- foo; bar x False; baz x
05:57:08 <lambdabot> foo >>= \ x -> bar x False >> baz x
05:57:29 <new_to_haskell> where is haskell used ?
05:57:41 <new_to_haskell> <extensively>
05:59:13 <Axman6> academia, and in industry it's used a a fair bit by banks, and companies doing high assurance systems
05:59:27 <Axman6> but it's beginning to be used everywhere
05:59:45 <Entroacceptor> there's a window manager, a game server browser, a wiki system
05:59:58 <new_to_haskell> wow!
06:00:00 <mux> Axman6: that was an impressively bold statement
06:00:09 <Axman6> mux: >_>
06:00:19 <new_to_haskell> lol
06:00:33 <copumpkin> new_to_haskell: Axman6 has been paid to write haskell!
06:00:34 <copumpkin> imagine that
06:00:40 <Axman6> new_to_haskell: it's used quite a lot to teach computer science, because it makes a lot of concepts very easy to understand
06:00:45 <mauke> hah
06:00:46 <incluye> you can do that??
06:00:48 <Axman6> yeah, i was paid well too
06:00:55 <mux> was?
06:01:03 <mux> how long did it last?
06:01:04 <Axman6> i was an intern at Tsuru capital
06:01:07 <copumpkin> of course
06:01:08 <mux> oh
06:01:10 <Axman6> three months
06:01:11 <zhulikas> it is used for financial analysis systems
06:01:12 <copumpkin> if you get into haskell for the money
06:01:21 <copumpkin> the people with the money probably don't want you
06:01:27 <copumpkin> or are less likely to want you :P
06:01:40 <zhulikas> so what motivates you to use haskell?
06:01:50 <copumpkin> me? the lack of money
06:01:52 <copumpkin> I hate money
06:01:57 <Axman6> heh
06:02:04 <zhulikas> I guess all of you who are Haskell gurus
06:02:05 <Younder> copumpkin, Well haskell is used by at least one financial investor company
06:02:05 <Axman6> zhulikas: it's fun, and extremely interesting
06:02:14 <copumpkin> Younder: I know
06:02:16 <Axman6> i'm not a haskell guru, i just like it
06:02:29 <Axman6> i
06:02:31 <zhulikas> getChar >>= doStuff
06:02:34 <Younder> copumpkin, Haskell is a language not a political affliction
06:02:38 <illissius-> zhulikas: it made my brain continually explode for an entire summer
06:02:41 <copumpkin> Younder: ?
06:02:43 <bscarlet> I'm being paid to write Haskell right now, for the record.
06:02:45 <Axman6> i'm more than happy programmiung in C, even Ada, and i can get by with Java if i have to
06:02:45 <zhulikas> does it say that resunt of getChar IO is assigned as an argument to doStuff function?
06:02:46 <new_to_haskell> so many programming languages !!
06:02:49 <mauke> zhulikas: no
06:02:58 <mauke> zhulikas: it creates a new IO action
06:03:02 <zhulikas> ahhhrrrr
06:03:11 <zhulikas> illissius-, I can feel your pain
06:03:25 <mauke> zhulikas: this new IO action, when executed, will first execute getChar, then call doStuff with the result
06:03:29 <illissius-> nah, it was the very opposite of painful.
06:03:36 <zhulikas> mauke, and that's basically what I said
06:03:47 <zhulikas> ok maybe not
06:03:53 <Axman6> yeah, not really ;)
06:04:14 <mauke> zhulikas: it's important that stuff doesn't happen when you use >>=
06:04:22 <mauke> stuff happens when the result of >>= is executed
06:04:34 <bscarlet> mauke: what does "when you use >>=" mean?
06:04:48 <Axman6> new_to_haskell: if you're actually interested in programming as a hobby, ie it's something you find enjoyable and will happily do in your spare time, then haskell is an amazing language to learn
06:05:02 <mauke> like just putting getChar >>= doStuff in your program somewhere doesn't read a character or call doStuff
06:05:17 <joe6> i am trying to do something like this: http://pastebin.com/kyVvQhnF
06:05:20 <mauke> The paste kyVvQhnF has been copied to http://hpaste.org/50055
06:05:30 <joe6> any suggestions on how I can get it to work.
06:05:40 <joe6> this works: release fd =  ioctl' fd C'PPRELEASE >> return ()
06:05:44 <mauke> > let doStuff = return in  length [getChar >>= doStuff, getChar >>= doStuff]
06:05:45 <new_to_haskell> Axman6, I'm a S.E.
06:05:45 <lambdabot>   2
06:06:03 <Axman6> new_to_haskell: do you enjoy programming? or is it just your job?
06:06:04 <joe6> i am trying to leverage the ioctl' function call into a different function that can be reused.
06:06:12 <new_to_haskell> I do enjoy
06:06:16 <Axman6> good :)
06:06:19 <dylukes> composing monadic expressions yields a bigger one.
06:06:22 <joe6> into something like: ioctlNoOutput fd request =  (ioctl' fd request :: IO d) >> return ()
06:06:23 <dylukes> Imagine you're in a shell
06:06:27 <new_to_haskell> mainly web app dev based
06:06:29 <dylukes> and yoiu set BLAH = x | y | z
06:06:34 <zhulikas> I'll just assume that >>= passes type a from IO (a) to the next function in a chain
06:06:37 <dylukes> BLAH is not evaluated yet, but its composed of three operations.
06:06:49 <Axman6> zhulikas: yeah basically
06:06:57 <Entroacceptor> :t >>=
06:06:58 <lambdabot> parse error on input `>>='
06:07:02 <Entroacceptor> :t (>>=)
06:07:02 <ion> :t (>>=)
06:07:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:07:03 <dylukes> :t (>>=)
06:07:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:07:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:07:09 <ion> Can we get one more?
06:07:10 <zhulikas> flooders
06:07:17 <Axman6> zhulikas: this may or may not help you understand things: http://random.axman6.com/blog/?page_id=70
06:07:26 <zhulikas> I almost got it :D
06:07:44 <ion> axman6: The formatting is broken.
06:07:46 <mauke> zhulikas: the reason I asked you if you knew javascript is because javascript's IO system is very similar
06:07:57 <ion> At least in my browser. (Chromium)
06:08:00 <mauke> specifically, XMLHttpRequest and setTimeout
06:08:03 <Axman6> qurgh, what happened there :(
06:12:41 <Axman6> ion: better?
06:12:58 <Entroacceptor> Axman6: yes
06:13:12 <Axman6> it was somehow missing a </pre> tag
06:15:52 <ski> Axman6 : "Well the first thing was str &lt;- getLine"
06:16:17 <Axman6> ah, thanks :)
06:17:43 <ricree> Could someone please take a look at this and tell me if there's a general way to do this for a variable number of arguments.  http://hpaste.org/50057
06:18:24 <Axman6> ski: thanks. fixed
06:21:43 <zhulikas> :t putChar 'a'
06:21:44 <lambdabot> IO ()
06:21:55 <zhulikas> IO action which returns nothing.
06:22:01 <zhulikas> :t return 'a'
06:22:02 <lambdabot> forall (m :: * -> *). (Monad m) => m Char
06:22:15 <zhulikas> same IO action which returns a value which was given to it?
06:22:24 <zhulikas> not the same. But similar
06:22:46 <ski> @type return 'a' :: IO Char
06:22:47 <lambdabot> IO Char
06:23:39 <ski> zhulikas : that is an `IO'-action that does no I/O effects, just returning back the given `Char', when executed
06:23:57 <ion> s/returns/results in/
06:25:33 <dylukes> Type-wise its identical to say,
06:25:39 <dylukes> @type hGetChar
06:25:40 <lambdabot> Not in scope: `hGetChar'
06:25:44 <dylukes> er
06:25:57 <dylukes> anyways. the point is you should infer there *may* or *can* be side effects from the ()
06:25:59 <dylukes> IO*
06:25:59 <zhulikas> return 'a' >>= \c -> doStuff c
06:26:02 <dylukes> from the IO*
06:26:07 <Botje> or reformatMachine >> return 'a'
06:26:39 <zhulikas> is it safe to assume that result value of given IO is temporary stored into c for further execution?
06:26:50 <zhulikas> return 'a' will be IO Char
06:26:58 <zhulikas> then \c becomes IO Char with 'a' inside
06:27:01 <dylukes> zhulikas: that could be written c <- return 'a' >>= doStuff c
06:27:03 <zhulikas> oh wait. Just Char
06:27:06 <dylukes> or
06:27:08 <dylukes> do c <- return 'a'
06:27:11 <dylukes> doStuff c
06:27:27 <zhulikas> I want to evade 'do' for now.
06:27:34 <zhulikas> I need to get used to >> and >>=
06:27:51 <dylukes> As long as you can sugar/desugar it, its fine ^^.
06:28:04 <dylukes> :t (>>=)
06:28:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:28:11 <zhulikas> stop doing that, please
06:28:12 <dylukes> besides, its pretty obvious from the type signature ;P
06:28:23 <zhulikas> this type signature is scary
06:28:29 <dylukes> No it's not :<
06:28:34 <zhulikas> yesh it is
06:29:24 <dylukes> :t liftM5
06:29:24 <lambdabot> forall a1 a2 a3 a4 a5 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
06:29:26 <dylukes> Better?
06:29:28 <zhulikas> :D
06:29:31 <zhulikas> I hate you
06:29:38 <dylukes> (this one is also very simple...)
06:29:45 <dylukes> It's the same as
06:29:45 <zhulikas> when you know how to read it ;)
06:29:55 <dylukes> :t a1 `ap` a2 `ap` a3
06:29:56 <lambdabot> Not in scope: `a1'
06:29:56 <lambdabot> Not in scope: `a2'
06:29:56 <lambdabot> Not in scope: `a3'
06:29:57 <dylukes> and so forth
06:30:09 <bscarlet> ricree: like this? http://hpaste.org/50057
06:30:46 <Ptival> zhulikas: good idea to get used to (>>=) and (>>) before beginning the do notation imho
06:30:48 <zhulikas> :t (->)
06:30:48 <lambdabot> parse error on input `->'
06:31:16 <Entroacceptor> zhulikas: the >>= type signature is easy. Drop the forall, which only will make sense waay later (I hope, still don't get it*g*).
06:31:33 <mauke> the >>= signature is not easy
06:31:41 <zhulikas> I understand forall
06:31:48 <zhulikas> that's not the issue
06:31:49 <mauke> it gets almost simple if you ignore everything before '=>' and replace 'm' by 'IO'
06:31:53 <mauke> but only almost
06:32:06 <zhulikas> :t (>>=)
06:32:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:33:35 <zhulikas> return 'a' >>= \c -> doStuff c
06:33:41 <zhulikas> I don't understand some syntax in this one
06:33:44 <zhulikas> \c -> this part
06:33:59 <zhulikas> what does this arrow do here
06:34:01 <tensorpudding> it's a lamdba
06:34:07 <tensorpudding> lambda*
06:34:12 <ceii> zhulikas: this is an anonymous function (lambda)
06:34:19 <mauke> zhulikas: ah
06:34:24 <zhulikas> can somebody put parentheses around this lambda?
06:34:29 <ski>   (>>=) :: IO a -> (a -> IO b) -> IO b
06:34:32 <mauke> ok, my IO page sort of assumes you already know the rest of the language
06:34:38 <zhulikas> haha :D
06:34:39 <ceii> return 'a' >>= (\c -> doStuff c)
06:34:41 <ski>   return 'a' >>= (\c -> doStuff c)
06:34:41 <tensorpudding> you can put parentheses around it if you like, it doesn't change the meaning
06:34:48 <mauke> zhulikas: ((return 'a') >>= (\c -> (doStuff c)))
06:34:50 <Ptival> it's like "if you've got an m of a, well, don't expect me to give you the a... but if you're kind enough, I can shove it in an (a -> m b) and give you back the m of b... but don't look while I'm doing this, the secret of extracting the a out of the m is mine!"
06:35:14 <zhulikas> Ptival, cool story bro
06:35:16 <ski> > (\x -> x * x) 5
06:35:17 <lambdabot>   25
06:35:21 <Ptival> (ofc that would be the "container" point of view...)
06:35:23 <ski> > map (\x -> x * x) [4,5,6]
06:35:24 <lambdabot>   [16,25,36]
06:35:27 <zhulikas> WAIT :D
06:35:37 <mauke> zhulikas: '\' means "watch out, I'm defining a function here! the next thing is the parameter list"
06:35:48 <ski> > map (\x -> x * x) [4,5,6] :: [Expr]
06:35:49 <lambdabot>   [4 * 4,5 * 5,6 * 6]
06:35:49 <mauke> zhulikas: '->' means "ok, done with the parameter list; the next thing is the function body"
06:35:50 <zhulikas> ok so it's the syntax for defining lambda expressions, ok
06:35:51 <tensorpudding> an anonymous function is like a regular function, but not given a name
06:35:53 <ski> > map f [4,5,6] :: [Expr]
06:35:54 <lambdabot>   [f 4,f 5,f 6]
06:36:14 <zhulikas> now let me try to explain it
06:36:16 <ski> zhulikas : not for *defining*, for *writing* them
06:36:19 <Entroacceptor> is there some theoretical reason why it's -> in lambdas, but = in function definition?
06:36:34 <zhulikas> to differentiate them
06:36:41 <mauke> Entroacceptor: because "function definition" is wrong
06:36:50 <mauke> you're binding a value to a name
06:37:01 <ceii> Entroacceptor: \x = x * x would look weird, what's equal to x*x? the parameter x?
06:37:01 <mauke> it's just that 'foo bar = baz' is syntactic sugar for 'foo = \bar -> baz'
06:37:07 <ski> zhulikas : `(3,4)' is not the syntax for *defining* a pair of numbers, it's the syntax for writing a pair of numbers
06:37:23 <Entroacceptor> ah, yes
06:37:42 <zhulikas> (return 'a') >>= returns a value which is a parameter of lambda (\c -> <do_something_to_c_parameter>)
06:37:44 <ski> zhulikas : similarly, `\x -> x * x' is the syntax for the squaring function
06:37:54 <tensorpudding> a squaring function
06:38:18 <ski> zhulikas : if you want, you can say `square = \x -> x * x', and this then is defining `square' to be that value (the function value)
06:38:36 <tensorpudding> @type \x -> x * x
06:38:37 <lambdabot> forall a. (Num a) => a -> a
06:38:37 <ski> zhulikas : then, as a shorthand, that definition can be written as `square x = x * x'
06:38:38 <zhulikas> > let a = \c -> c + 1
06:38:39 <lambdabot>   not an expression: `let a = \c -> c + 1'
06:38:41 <zhulikas> > a 5
06:38:42 <lambdabot>   Couldn't match expected type `t1 -> t'
06:38:42 <lambdabot>         against inferred type `Simpl...
06:38:44 <zhulikas> :/
06:39:06 <ski> @let zhulikas_a = \c -> c + 1
06:39:07 <lambdabot>  Defined.
06:39:11 <ski> > zhulikas_a 5
06:39:12 <lambdabot>   6
06:39:14 <tensorpudding> > let a = \c -> c + 1 in a 5
06:39:14 <lambdabot>   6
06:39:29 <tensorpudding> can't have a let without an in
06:39:31 <zhulikas> I see...
06:39:50 <ski> > (\c -> c + 1) 5
06:39:50 <lambdabot>   6
06:39:56 <mauke> tensorpudding: you can in 'do' blocks and ghci (because ghci pretends to be a do block)
06:40:08 <zhulikas> Now I will now lambda expressions pretty well :D
06:40:28 <mauke> > (\f -> f 10) sqrt
06:40:29 <lambdabot>   3.1622776601683795
06:40:33 <mauke> ^ oh yeah?
06:40:43 <zhulikas> no
06:41:03 <tensorpudding> > fix sqrt
06:41:06 <zhulikas> that's tricky
06:41:07 <lambdabot>   mueval-core: Time limit exceeded
06:41:18 <zhulikas> :t \f -> f 10
06:41:19 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
06:41:23 <zhulikas> whoa :D
06:41:28 <ski> @type \f -> f False
06:41:29 <lambdabot> forall t. (Bool -> t) -> t
06:41:34 <mauke> zhulikas: we're just plugging 'sqrt' into where 'f' appears in the function body
06:41:53 <mauke> (\f -> f 10) sqrt == sqrt 10
06:41:59 <zhulikas> I see
06:42:21 <zhulikas> but that's also kinda strange syntax for that
06:42:35 <mauke> why?
06:42:35 <tensorpudding> > ((\f -> (\c -> f c)) sqrt) 10
06:42:36 <lambdabot>   3.1622776601683795
06:42:51 <zhulikas> > (\f -> f 10) in sqrt
06:42:52 <lambdabot>   <no location info>: parse error on input `in'
06:43:15 <ski> > let at_ten = \f -> f 10  in  at_ten sqrt
06:43:16 <lambdabot>   3.1622776601683795
06:43:16 <tensorpudding> no 'in' required
06:43:24 <zhulikas> ahhh ok
06:43:24 <tensorpudding> you're applying the function
06:43:26 <zhulikas> ski, thanks
06:43:37 <ski> > let at_ten f = f 10  in  at_ten sqrt
06:43:38 <lambdabot>   3.1622776601683795
06:43:38 <zhulikas> because f can be even functions, not only values
06:43:46 <mauke> zhulikas: functions are values :-)
06:43:50 <zhulikas> :D
06:43:51 <ski> yes, since functions are just another kind of values
06:44:07 <tensorpudding> an anonymous function will have a type as polymorphic as possible
06:44:21 <tensorpudding> unless you make it otherwise
06:44:42 <ski> hehe
06:44:58 <zhulikas> > (\f a -> f a) sqrt 4
06:44:59 <lambdabot>   2.0
06:45:01 <zhulikas> yay \o/
06:45:08 <mauke> you win the prize!
06:45:28 <mauke> zhulikas: that function is actually in the standard library
06:45:30 <mauke> it's called ($)
06:45:41 <mauke> > ($) sqrt 4
06:45:41 <lambdabot>   2.0
06:45:47 <zhulikas> :t $
06:45:48 <lambdabot> parse error on input `$'
06:45:52 <zhulikas> :t ($)
06:45:52 <lambdabot> forall a b. (a -> b) -> a -> b
06:46:12 <zhulikas> :t (\f a -> f a)
06:46:12 <lambdabot> forall t t1. (t -> t1) -> t -> t1
06:46:34 <ski> > map (\f -> f 10) [\x -> x,\x -> x * x,\x -> x * (x + 1) `div` 2]
06:46:34 <lambdabot>   [10,100,55]
06:46:42 <zhulikas> but that's just useles with (sqrt)
06:46:45 <zhulikas> > ($) sqrt 4
06:46:46 <lambdabot>   2.0
06:46:47 <zhulikas> > sqrt 4
06:46:48 <lambdabot>   2.0
06:46:52 <ski> zhulikas : can you figure out that one ^ ?
06:47:22 <zhulikas> hmm
06:47:28 <zhulikas> :t map
06:47:29 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:47:29 <ski> (have you seen `map', yet ?)
06:47:35 <zhulikas> I did.
06:47:44 <zhulikas> it applies given function to every element in list
06:47:46 <zhulikas> right?
06:47:49 <mauke> yeah
06:47:49 <ski> > map f [a,b,c,d] :: [Expr]
06:47:50 <lambdabot>   [f a,f b,f c,f d]
06:48:41 <zhulikas> > map (\f -> f 10) [10]
06:48:41 <ski> > map ($ 10) [\x -> x,\x -> x * x,\x -> x * (x + 1) `div` 2]  -- a variant
06:48:42 <lambdabot>   [10]
06:48:42 <lambdabot>   [10,100,55]
06:49:00 <ski> > map (\f -> f 10) [\x -> 42]
06:49:01 <lambdabot>   [42]
06:49:24 <zhulikas> oh I see what you did here...
06:49:40 <zhulikas> you gave value in lambda expression and functions in list
06:50:01 <ski> sure did
06:50:28 <zhulikas> so its a list of functions and by mapping given lambda expression to a list makes lambda expression to be executed using each element as a parameter to itself
06:50:51 <zhulikas> nobody understands me I guess :D
06:50:59 <zhulikas> maybe I confused things a bit
06:51:00 <ski> s/executed/evaluated/, but yeah
06:51:36 <zhulikas> damn that's a good one
06:51:52 <zhulikas> I didn't know you can do such funky things in Haskell
06:52:09 <zhulikas> now it also totally makes sense that function is a value
06:52:26 <ski> you can do many funky things in Haskell ..
06:52:30 <zhulikas> thanks a lot, guys
06:52:43 <ski> yw
06:52:48 <zhulikas> I'll do a break and return to my initial problems \o/
06:53:29 <mauke> yeah, the "functions are first-class values" thing is not just marketing :-)
06:53:33 <mauke> we mean it
06:54:12 <ski> zhulikas : did you get the difference between defining a function, and writing a function (value) ?
06:54:32 <zhulikas> defining a function is just showing it's types, right?
06:54:58 <ski> defining is giving a value a *name*
06:55:04 <zhulikas> myFunction :: [Char] -> Char
06:55:12 <zhulikas> it's a definition
06:55:13 <ski>   myValue = 42
06:55:17 <ski> is a definition
06:55:23 <fazzone> :t flip id
06:55:23 <lambdabot> forall a b. a -> (a -> b) -> b
06:55:27 <fazzone> i am confused by this
06:55:37 <ski>   myFunction = \chars -> '!'
06:55:43 <ski> is a definition
06:56:05 <zhulikas> so writing a function is calling a function?
06:56:34 <ski> writing `f x' is calling the function `f' on the argument `x'
06:56:36 <fazzone> Why is 'flip id' the same thing as 'flip ($)' ?
06:56:39 <mauke> fazzone: why it typechecks or what it does?
06:56:55 <mauke> @src flip
06:56:55 <lambdabot> flip f x y = f y x
06:57:09 <mauke> fazzone: flip f = \x y -> f y x
06:57:10 <bscarlet> (zhulikas: what you wrote, 'myFunction :: [Char] -> Char' is a declaration)
06:57:12 <ski> writing `\x -> ..x..' is writing a function value, that, when called on an argument `x', will return `..x..'
06:57:17 <zhulikas> oh, ok
06:57:19 <mauke> fazzone: flip id = \x y -> id y x
06:57:30 <zhulikas> so what is writing a function?
06:57:41 <fazzone> mauke: ah, i get it.  thanks!
06:57:42 <mauke> zhulikas: a description of a programming activity
06:57:50 <zhulikas> :D
06:57:57 <ski> zhulikas : `\f -> f 10' is function value
06:58:16 <zhulikas> part after -> is function value
06:58:23 <mauke> hmm, no
06:58:29 <ski> zhulikas : `at_ten = \f -> f 10' is giving that function value the name `at_ten', i.e. *defining* `at_ten' to refer to that function (value)
06:58:38 <o__> after the -> is the function body
06:58:41 <ski> zhulikas : the whole `\f -> f 10' is the function value
06:59:04 <ski> the part after the '->' is the "function body", i.e. what it will return, when applied/called on an argument `x'
06:59:21 <bscarlet> zhulikas: "function value" is used here to mean the value that is the function, not the value resulting from evaluating the function
06:59:32 <ski> good point
07:00:20 <zhulikas> so how can I separate them in words? function value is a function and function return value is what function returns after execution? or what
07:00:34 <ski> that works
07:00:38 <zhulikas> ok
07:00:59 <ski> one can also say "function result" instead of "function return value"
07:01:07 <zhulikas> can I reffer to function value just as function?
07:01:18 <mauke> yeah, I do that all the time
07:01:18 <ski> yes
07:01:24 <zhulikas> ok
07:01:24 <o__> i tend to just make up my own terminology
07:01:38 <ski> we don't usually talk about number values and list values, &c.
07:01:52 <zhulikas> o__, that also works for me. I'll keep in mind the real terminology and associations with my own :)
07:02:03 <dabblego> http://paste.pocoo.org/show/455316/ is this the correct way to write a script to run on all platforms (including/especially OSX)?
07:02:29 <zhulikas> ohh this is a nice script
07:02:43 <ski> if we have a function that can take any kind of value as input, then it's more common to call it a "value"
07:03:54 <ski> e.g. `map' will take a function, and a list of values, and return a new list with every list value replaced by the function applied to that value
07:04:45 <Axman6> dabblego: works fine here on OS X, after a chmod +x
07:05:02 <dabblego> Axman6: thanks, I suspect it doesn't work if you change it to #!/usr/bin/runhaskell
07:05:30 <Axman6> dabblego: yeah, i suspect so. i think ghc is by default installed under /usr/local on OS X
07:05:39 <dabblego> Axman6: great thanks
07:05:40 <Axman6> (it should be on most systems imo)
07:06:18 <o__> is there anyway of showing a function definition in GHCi?
07:06:26 <copumpkin> no
07:06:28 <Axman6> no
07:06:38 <Botje> doesn't ghci on acid do that?
07:06:43 <Botje> i thought that morphed into \bot
07:06:45 <o__> so nothing similar to have javascript can coerce functions into strings?
07:06:49 <o__> how javascript*
07:07:09 <Axman6> Botje: it might be able to show implementations from the H98 standard
07:07:28 <Axman6> o__: no, haskell has no form of introspection
07:08:26 <Axman6> serialising haskell functions would be pretty difficult i think
07:08:48 <Botje> mobile haskell does it
07:08:51 <Axman6> since a function may be a partial application, which has some parameters filled in already
07:08:54 <Botje> however, there's enough warts there :)
07:09:00 <Axman6> mobile haskell?
07:09:15 <Axman6> i know cloud haskell has some way of doing it, but it's somewhat restricted i think
07:09:39 <bscarlet> Does Data.Data count at all?
07:10:29 <kamaji> Is Enum also Bounded?
07:10:51 <bscarlet> no
07:11:07 <kamaji> Shouldn't it be? aren't all Enums bounded?
07:11:19 <ski> > succ 0 :: Integer
07:11:20 <lambdabot>   1
07:11:30 <kamaji> oh
07:11:57 <kamaji> oh.. it just means something that can be assigned to a number?
07:12:07 <kamaji> or have a number assigned to it, even
07:13:04 <bscarlet> technically it looks to be something 1-1 with Int. Hmmm.
07:13:24 <bscarlet> > succ (fromIntegral (maxBound :: Int) :: Integer)
07:13:25 <lambdabot>   9223372036854775808
07:13:29 <rwbarton> it's also where the [a..b] and related functions live
07:13:43 <bscarlet> > maxBound :: Int
07:13:44 <lambdabot>   9223372036854775807
07:13:45 <rwbarton> it is sort of an odd type class
07:14:09 <kamaji> heh
07:14:19 <bscarlet> > fromEnum (succ (fromIntegral (maxBound :: Int) :: Integer))
07:14:20 <lambdabot>   -9223372036854775808
07:15:10 <ski> > ((toEnum . fromEnum) `asTypeOf` id) `graph` pi
07:15:11 <lambdabot>   (3.141592653589793,3.0)
07:15:12 <Axman6> @src Enum
07:15:12 <lambdabot> class  Enum a   where
07:15:12 <lambdabot>     succ                     :: a -> a
07:15:12 <lambdabot>     pred                     :: a -> a
07:15:12 <lambdabot>     toEnum                   :: Int -> a
07:15:13 <lambdabot>     fromEnum                 :: a -> Int
07:15:15 <lambdabot> [3 @more lines]
07:15:19 <ski> @more
07:15:20 <lambdabot>     enumFrom                 :: a -> [a]
07:15:20 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
07:15:21 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
07:15:29 <Axman6> kamaji: Enum is the class of things that can be enumerated
07:15:51 <bscarlet> (within the implementation limits of Int)
07:15:56 <sohum> @pl \a -> foo a / bar a > z
07:15:56 <lambdabot> (> z) . liftM2 (/) foo bar
07:16:25 <ski> > fromEnum (succ (fromIntegral (maxBound :: Int) :: Integer))
07:16:26 <lambdabot>   -9223372036854775808
07:16:47 <ski> (oh, bscarlet already did that ..)
07:17:15 <frerich> Is there a collection (maybe a blog article?) of polymorphic values which make clever use of type classes? Like, I recently saw "entireRange :: Enum a => [a]" with "entireRange = range(minBound, maxBound)" or something along the lines of that.
07:17:18 <kamaji> Axman6: I guess I was more asking why "can be enumerated" is not also implicitly bounded
07:17:30 <Axman6> no
07:17:42 <Axman6> though, the reliance on Int in the class itself is unfortunate
07:17:49 <copumpkin> kamaji: you can enumerate the (unbounded) integers or the rationals
07:17:57 <copumpkin> I have a package that does that :)
07:18:03 <ski> > fromEnum (2 % 3)
07:18:04 <lambdabot>   0
07:18:13 <Axman6> but toEnum and fromEnum are generally designed for use on small ADT's
07:18:16 <copumpkin> you can even enumerate functions if they meet certain criteria
07:18:25 <Axman6> well, that's my feeling anyway
07:18:25 <copumpkin> yeah, Enum is horrible
07:18:29 * copumpkin kicks Enum
07:18:37 <ski> @slap Enum
07:18:37 <lambdabot> *SMACK*, *SLAM*, take that Enum!
07:18:38 <kamaji> haha
07:18:45 <Axman6> > fromEnum (2^128 :: Integer)
07:18:46 <lambdabot>   0
07:18:55 <Axman6> > fromEnum (2^63 :: Integer)
07:18:56 <lambdabot>   -9223372036854775808
07:18:57 --- mode: ChanServ set +o copumpkin
07:18:59 --- mode: copumpkin set +b *!112d8769@gateway/web/freenode/ip.17.45.135.105
07:19:00 --- kick: Enum was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
07:19:02 <Axman6> > fromEnum (2^63 +1 :: Integer)
07:19:02 --- mode: copumpkin set -o copumpkin
07:19:03 <lambdabot>   -9223372036854775807
07:19:25 <sohum> @pl \b -> (foo bar baz b) > z
07:19:25 <lambdabot> (> z) . foo bar baz
07:19:31 <Axman6> > fromEnum (2^64 :: Integer)
07:19:31 <lambdabot>   0
07:19:35 <kamaji> > fromEnum (2^31 + 1 :: Integer)
07:19:36 <lambdabot>   2147483649
07:19:37 <Axman6> > fromEnum (2^64 -1  :: Integer)
07:19:38 <lambdabot>   -1
07:19:41 <Ptival> I say kick corruptmemory too!
07:19:51 <Axman6> toEnum (-1) :: Integer
07:19:54 <copumpkin> nah, I like corruptmemory
07:19:57 <Axman6> > toEnum (-1) :: Integer
07:19:58 <lambdabot>   -1
07:20:01 <Ptival> :)
07:20:05 <Axman6> weak
07:20:28 * corruptmemory sobs
07:21:01 <Ptival> (nothing personal, you just had the wrong nickname at the wrong time)
07:21:18 <kamaji> I was wondering what was going on :P
07:21:42 <corruptmemory> Encountered some corrupt memory?
07:23:38 <Axman6> well we are now
07:24:11 <frerich> I think Enum would be nice if it just had 'succ' and 'pred'.
07:24:15 * corruptmemory failed to parse ;-)
07:24:27 <ski> > pred False
07:24:28 <lambdabot>   *Exception: Prelude.Enum.Bool.pred: bad argument
07:25:01 <Ptival> memory is just like Enum, it fakes to be infinite, but on closer inspection it's just bounded :(
07:25:38 <Axman6> > succ (2^128 :: Integer)
07:25:39 <lambdabot>   340282366920938463463374607431768211457
07:26:00 <fazzone> are there any reasons to not make Enum just 'succ' and 'pred' and then maybe have a 'Countable' typeclass or something ? (besides breaking code)
07:34:16 <stobix> Hm, would  (,) <$> (filter g) <*> (filter (not . g)) $ [1 .. ] run g only once on each number, or have I misunderstood laziness?
07:35:36 <quicksilver> you have misunderstood laziness
07:35:36 <rwbarton> it would not run g only once on each number
07:35:48 <stobix> lol
07:35:57 <quicksilver> you have mistaken it for "magic all-seeing compiler/optimiser"
07:35:57 <stobix> hmkay
07:36:12 <rwbarton> it sounds like you're assuming that once the program evaluates "g 3" to "True" then it won't ever have to do that work again?
07:36:15 <quicksilver> laziness says that a single expression is only evaluated once
07:36:25 <stobix> rwbarton: that's kinda what I thought, yes.
07:36:27 <quicksilver> not that two different expressions which happen to be the same willa utomatically be shared
07:36:52 <rwbarton> what is true is if you write   let x = g 3 in .... x ... x ...  then g 3 will be evaluated at most once
07:38:40 * stobix goes back to rewrite things
07:38:56 <rwbarton> btw,
07:38:58 * frerich reads "(,)  (filter g) <*> (filter (not . g))" and thinks that you can have too much brevity.
07:38:59 <rwbarton> @type partition
07:39:00 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:39:27 <c_wraith> yes, the problem with that expression is insufficient brevity :)
07:39:43 <c_wraith> when there's a single function that does the same job
07:39:50 <ion> Should that be (,) <$> filter g <*> filter (not . g)?
07:40:01 <ion> :t \g -> (,) <$> filter g <*> filter (not . g)
07:40:02 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:40:04 <ion> :t partition
07:40:05 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:40:13 <quicksilver> however, they are not the same.
07:40:39 <ion> Indeed, partition is more efficient and lazy.
07:40:43 <zygoloid> frerich: there are unnecessary parens in that expression :)
07:40:53 <quicksilver> actually I'm mistaken about the monad involved. bad quicksilver.
07:41:42 <ion> @pl \g -> (,) <$> filter g <*> filter (not . g)
07:41:42 <lambdabot> ((,) <$>) . liftM2 (<*>) filter (filter . (not .))
07:41:45 <ion> There, much better!
07:42:25 <ion> In the words of benmachine, it’s point-free and therefore readable.
07:43:09 <stobix> oo
07:43:10 <ion> (He was joking, of course.)
07:43:43 <frerich> Some time ago I saw some fun page about how persons with different degrees of Haskell expertise would write a 'product' function and that made me think that the most important point about things like point-free expressions and then (.) operator is to understand when you should *not* use them. :-}
07:43:59 <stobix> :)
07:44:10 <stobix> You wouldn't happen to have the link somewhere? ;)
07:44:18 <aki> I'm interested too
07:44:19 <aki> :)
07:44:27 <dolio> Most of the examples are way beyond point-free obfuscation.
07:44:34 <dolio> @google evolution of a haskell programmer
07:44:35 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
07:44:35 <lambdabot> Title: The Evolution of a Haskell Programmer
07:44:40 <aki> thanks
07:44:46 <frerich> That's the one!
07:45:00 <stobix> \o/
07:46:37 <o__> i wish i had a deeper understanding of accumulators
07:47:33 <dainanaki> what does it mean when I get a warning "Iface id out of scope"?
07:47:39 <sohum> o__: my understanding is that they're quite simple
07:47:52 <o__> deceptively simple
07:48:25 <o__> sum' xs = foldl (\acc x -> acc + x) 0 xs
07:48:26 <sohum> o__: collect your answer in another argument (maybe with some final processing in the base case) to get tail recursion
07:48:51 <o__> is foldl passing the lambda the running total in the first argument?
07:49:21 <sohum> o__: no, it's foldl :p
07:49:34 <quicksilver> o__: yes.
07:49:43 <o__> ?_?
07:49:47 <quicksilver> o__: foldl keeps calling that lambda with the result from last time
07:49:48 <frerich> o__: Yes, with foldl the accumumator is the left-hand side argument, with foldr the accumulator is right-hand-side.
07:49:51 <quicksilver> (in the first parameter, as you say)
07:49:53 <frerich> o__: that's how I memorize it
07:50:02 <quicksilver> the first time, it calls it with the '0' you gave it
07:50:04 <dainanaki> does my "iface id out of scope" indicate an error?
07:50:08 <quicksilver> becasue there isn't a "last time" yet.
07:50:09 <sohum> I think he's referring to foldl vs foldl'
07:50:11 <o__> okay, that was my understanding too
07:50:16 <sohum> no?
07:50:29 <sohum> because the "which one is the accum" thing is easily answered from type signature
07:50:41 <quicksilver> dainanaki: doesn't look like a haskell error, can you hpaste a little context?
07:51:18 <stobix> Heh, the "Interpretive Haskell Programmer" on that page reminds me of Java... So much code for so little...
07:52:54 <hpaste> dainanaki pasted “Iface ID out of scope” at http://hpaste.org/50065
07:53:32 <quicksilver> that's either corrupted .hi files or a ghc bug, dainanaki
07:53:42 <dainanaki> corrupted hi files?
07:53:45 <quicksilver> ...and in general corrupted .hi files could only arise by a ghc bug :(
07:53:53 <dainanaki> :/
07:53:56 <quicksilver> yes. For example - /Users/ian/Library/Haskell/ghc-7.0.3/lib/qt-1.1.4/lib/Qtc/Gui/QWidget.hi
07:53:59 <quicksilver> that's a .hi file
07:54:02 <dainanaki> right
07:54:07 <quicksilver> and your error message shows it to be corrupt. Weird.
07:54:15 <dainanaki> but how would it be corrupted is what I'm wondering.
07:54:26 <quicksilver> you haven't done something like part compile with one compiler version and partly with another?
07:54:31 <dainanaki> nope.
07:54:48 <dainanaki> clean build using 7.0.3
07:55:48 <dainanaki> I was trying to make a little GUI for my zoom app.
07:56:17 <dainanaki> most things work, but the labels just aren't showing up, and I noticed this issue.
07:56:21 <quicksilver> dainanaki: JaffaCake (who is a GHC dev) says, can you make a ticket for that in the GHC trac?
07:56:30 <quicksilver> it is peculiar and might be a GHC bug indeed.
07:56:42 <dainanaki> sure. what info should I include?
07:56:59 <quicksilver> http://hackage.haskell.org/trac/ghc/newticket?type=bug
07:57:20 <quicksilver> version of GHC, version of the qt libraries
07:57:38 <quicksilver> and I guess that complete program and error message, since it's ratehr small.
07:58:13 <mm_freak_> the (.) operator from Control.Category is functor composition, isn't it?
07:58:32 <c_wraith> so.  Simon Marlow says he's found a way to do call stacks in GHC.  This is exciting news!
07:58:46 <dainanaki> ok, for the life of me I can't read the captchas for registering on trac.
07:58:48 <c_wraith> more precisely, report call stacks when there's an error.
07:58:57 <JaffaCake> dainanaki: include enough info that we can reproduce the problem
08:02:54 <quicksilver> dainanaki: hopefully there is still a guest account for reporting bugs
08:02:59 <dainanaki> it's alright
08:03:03 <quicksilver> I think it was guest / guest
08:03:05 <dainanaki> I just registered for an account
08:03:46 <JaffaCake> quicksilver: better to register, then you get emails related to your ticket
08:04:13 <JaffaCake> we often have to ask people for more info
08:04:27 <o__> could someone please explain to me what i'm doing wrong http://privatepaste.com/11dedb83dc
08:04:30 <o__> i'm very new to haskell
08:05:35 <Botje> o__: (:) takes an element and a list
08:05:43 <quicksilver> JaffaCake: it's a fair point although, before I regiestered, I just used to bookmark the ones I'd submitted and visit them occasionally :)
08:05:44 <Botje> o__: you're giving it a list and an element
08:06:03 <Botje> o__: use ++ instead, which concatenates two lists
08:06:40 <Botje> so, rev xs ++ [x]
08:06:46 <o__> okay, thanks
08:06:53 <o__> i thought x took an element and a list though
08:06:55 <o__> err, :
08:07:04 <zygoloid> warning: that's quadratic-time.
08:07:04 <Botje> :t :
08:07:05 <lambdabot> parse error on input `:'
08:07:07 <Botje> :t (:)
08:07:08 <lambdabot> forall a. a -> [a] -> [a]
08:07:23 <o__> oh, i see
08:07:29 <o__> can't have the list first
08:07:33 <Botje> no
08:09:49 <dainanaki> ok, posted the report.
08:09:56 <JaffaCake> great, thanks
08:10:42 <dainanaki> I'll probably try building qtHaskell again just to see if I can even reproduce it myself.
08:12:37 <lundstrj> Greetings
08:13:15 <lundstrj> Quick question. Anyone familiar with: Generators, QuickCheck and Sample?
08:13:35 <joe6> @hoogle Char -> CUChar
08:13:36 <lundstrj> I have been told to try my generators using this fancy sample function
08:13:36 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:13:36 <lambdabot> Prelude error :: [Char] -> a
08:13:36 <lambdabot> Prelude read :: Read a => String -> a
08:14:01 <joe6> is there a better way of converting Char -> CUChar?
08:14:17 <joe6> other than using unsafeCoerce.
08:14:21 <lundstrj> the professor just hack sample (choose (1,10) :: Gen Integer)
08:14:25 <lundstrj> and it works for them
08:14:37 <lundstrj> but I seem to be having issues finding that module
08:14:45 <lundstrj> not included by default?
08:15:41 <lundstrj> I can import Test.QuickCheck just fine, but Sample is nowhere to be found =(
08:17:58 <ski> stobix : what you were thinking of is known as memoization/tabling
08:18:11 <lundstrj> anyone ever tried to use sample?
08:19:31 <kosmikus> lundstrj: what version of QuickCheck are you using?
08:20:16 <kosmikus> @type sample
08:20:16 <lundstrj> kosmikus: excellent question
08:20:17 <lambdabot> forall a. (Show a) => Gen a -> IO ()
08:20:20 <lundstrj> I have no idea
08:20:27 <kosmikus> lundstrj: lambdabot knows about it :)
08:20:51 <lundstrj> I downloaded winhugs a couple of weeks ago and I got ghci at the same time
08:20:53 <lundstrj> ohh
08:21:14 <ski> @type sample'
08:21:15 <lambdabot> forall a. Gen a -> IO [a]
08:21:45 <kosmikus> lundstrj: it should really just be available if you import Test.QuickCheck
08:22:06 <lundstrj> kosmikus: I see, so I must have fudged that up some how
08:22:20 <lundstrj> other parts of QuickCheck are working fine though.
08:22:28 <joe6> > (unsafeCoerce $ chr 0xff ) :: CUChar
08:22:28 <lambdabot>   Not in scope: type constructor or class `CUChar'Not in scope: `unsafeCoerce'
08:22:41 <joe6> is there a better way of doing the above?
08:22:42 <lundstrj> could I have grabbed the wrong download somehow?
08:22:50 <joe6> instead of using unsafeCoerce?
08:22:59 <kosmikus> lundstrj: strange. what version of ghc is this?
08:23:27 <kosmikus> lundstrj: and what does ghci say about the QuickCheck version if you start it with "ghci -package QuickCheck" ?
08:23:29 <zygoloid> joe6: what is CUChar?
08:23:42 <lundstrj> hang on
08:23:50 <bscarlet> joe6: fromIntegral?
08:23:50 <c_wraith> loooks like C unsigned char, to me.
08:24:00 <thoughtpolice> joe6: that's not going to work
08:24:10 <joe6> zygoloid: this: http://pastebin.com/LPmf3f3x
08:24:12 <mauke> The paste LPmf3f3x has been copied to http://hpaste.org/50067
08:24:18 <joe6> thoughtpolice: yes, C unsigned Char
08:24:26 <lundstrj> kosmikus: QuickCheck-2.1.0.3
08:24:31 <lundstrj> links fine
08:24:37 <thoughtpolice> Char is most certainly boxed (and UTF8 or whatever encoding is set anyway) and that coerce is going to coerce the pointer representation i'm pretty sure
08:24:40 <thoughtpolice> not the actual char value
08:24:45 <joe6> just realised that it is a Word8. Can use a Word8 instead of a Char.
08:24:54 <zygoloid> joe6: obey bscarlet :)
08:24:55 <lundstrj> kosmikus: GHCi version 2.12.1
08:25:06 <thoughtpolice> either way Char is not guaranteed to be the size of a unsigned C Char
08:25:19 <dolio> Char is a unicode codepoint.
08:25:24 <zygoloid> even if it were the same size, unsafeCoerce is still unsafe
08:25:26 <joe6> thoughtpolice: so, a Word8 is a better representation in Haskell?
08:25:44 <ski> @type Foreign.C.String.castCharToCChar
08:25:45 <lambdabot> Char -> Foreign.C.Types.CChar
08:25:46 <zygoloid> joe6: use fromIntegral to convert.
08:25:59 <ski> @type Foreign.C.String.castCharToCUChar  -- hm
08:26:00 <lambdabot>     Not in scope: `Foreign.C.String.castCharToCUChar'
08:26:02 <thoughtpolice> word8 is probably going to be a pointer too
08:26:20 <joe6> thoughtpolice: so, which is the best way of doing it?
08:26:27 <kosmikus> lundstrj: I hope you mean 6.12.1, not 2.12.1 :)
08:26:40 <thoughtpolice> if you just want to convert a Char or whatnot to a C-style string, you should use functions in Foreign*
08:26:46 <kosmikus> lundstrj: anyway, while that's quite old, QuickCheck-2.1.0.3 definitely has the "sample" function
08:26:49 <joe6> i do not want to carry the CUChar around, hence looking for an equivalent haskell representation.
08:27:02 <bscarlet> joe6: fromIntegral!
08:27:15 <lundstrj> kosmikus: Quite right. 6.12.1
08:27:38 <thoughtpolice> joe6: the rule of thumb is that unsafeCoerce is pretty much always wrong. because things in haskell are very regularly thunks (or pointers or whatever you want to call them,) you will almost never have the expected results - you'll be coercing pointers to weird representations. when you begin doing that, the GC is going to get messed up following pointers, and bad things will happen (you'll segfault quickly, most likely)
08:27:46 <joe6> bscarlet, zygoloid : isn't fromIntegral mostly for conversions between numbers
08:28:02 <lundstrj> kosmikus: I thoght it was a bit strange too. That's why I came here. So, it all loads just fine in winHugs
08:28:15 <zygoloid> joe6: C's unsigned char type represents a number.
08:28:20 <ski> `unsafeCoerce :: a -> b' is safe iff `a' is the same type as `b' ..
08:28:29 <bscarlet> joe6: what do you think a CUChar is?
08:28:36 <bscarlet> joe6: it's an 8 bit number.
08:28:38 <kosmikus> lundstrj: it's QuickCheck-1 that doesn't have "sample".
08:28:43 <joe6> thoughtpolice: thats is what is thought of unsafeCoerce, hence looking for better ways of doing it.
08:28:46 <kosmikus> lundstrj: you may have both versions installed.
08:28:50 <thoughtpolice> unsafeCoerce is *always* wrong. except for when it's not - but these situations are quite rare, and normally exist when you can prove yourself that two terms are the exact same type, but GHC isn't smart enough to understand you
08:29:10 <lundstrj> kosmikus: Hmm, if I just load my code in ghci, it cant find Test.QuickCheck
08:29:15 <joe6> bscarlet, zygoloid: ok, froIntegral it is. Thanks.
08:29:21 <lundstrj> didn't we just check that it linked fine?
08:29:34 <dolio> ski: I think you can coerce to/from Any as well, as long as you're going between it and the 'real' type of whatever your value is.
08:29:50 <ski> oh, ok
08:30:09 <ski> sortof like `void *' then, i assume
08:30:16 <kosmikus> lundstrj: strange again.
08:30:27 <dolio> Something like that.
08:30:42 <bscarlet> joe6: that'll get you as far as Int. Then you need chr to get you to Char.
08:31:07 <joe6> bscarlet, zygoloid: Thanks, fromIntegral did the job for me. I just want an 8-bit number to a CUChar.
08:31:07 <dolio> I'd probably think of Any = exists a. a, except it's baked in because there are no first-class, overheadless existentials in GHC.
08:31:24 <joe6> bscarlet, zygoloid: just used Word8 for the intermediate haskell representation
08:31:39 <joe6> bscarlet, zygoloid: and fromIntegral took care of the conversion.
08:32:12 <lundstrj> kosmikus: I thought I'd write you privately to avoid the noise in the main chat
08:32:53 * ski thinks `forall a. a' would probably also work as well
08:33:48 <dolio> Work for what?
08:34:57 <quicksilver> ski: `forall a.a` is only a first class type if you're using Rank2Types
08:35:06 <quicksilver> but yes, I think you're right that it works just as well as GHC.Any
08:35:17 <dolio> No.
08:35:23 <rwbarton> you might accidentally try to use a value of type forall a. a
08:35:36 <dolio> It's at the entire other end of the lattice.
08:35:38 <zhulikas> Unbelievable! I just solved Project Euler problem with Haskell!! \o/
08:35:57 <applicative> good work zhulikas
08:36:22 <Axman6> zhulikas: let the addiction begin
08:36:25 <dolio> If you coerce an Int to a (forall a. a), then you can instantiate that to anything you want, like something that isn't Int.
08:36:30 <applicative> zhulikas you're lost now!
08:36:58 <zhulikas> http://hpaste.org/50068
08:37:01 <zhulikas> this is it :D
08:37:09 <zhulikas> I combined everything I learned today from you guys
08:37:28 <zhulikas> not the most effective code and output formatting kinda sux, but it works fine and fast
08:37:39 <ski> dolio : what matters would be the composition of the `toAny' and `fromAny' operations, the type `Any' is abstract anyway, no ?
08:37:51 <Axman6> zhulikas: heh, wow, that's amazingly unreadable :P
08:37:57 <zhulikas> haha I know :D
08:38:02 <Axman6> everything on one line is not a good idea
08:38:05 <zhulikas> I evaded 'do' for a reason :D
08:38:11 <dolio> Any is abstract. It's not equivalent to (forall a. a).
08:38:46 <zhulikas> to strengthen my understanding of IO actions
08:39:04 <Axman6> zhulikas: there's no use for the if n == 0 then "" in your code, the first case makes sure that n is not zero when you reach the second case
08:39:23 <dolio> For the same reason (forall a. a) and (exists a. a) are quite different.
08:39:26 <zhulikas> ahh sure, thanks :D
08:39:42 <Axman6> should run lik twice as fast now! :P
08:40:12 <zhulikas> seriously? :D
08:40:49 <Axman6> no, but it should be a little faster without the additional check
08:40:50 <ski> dolio : sure. i'm just saying it doesn't really matter if you say `Any = forall a. a' and have `toAny = unsafeCoerce; fromAny = id', or if you say `Any = exists a. a' and have `toAny = id; fromAny = unsafeCoerce'
08:41:30 <dolio> There's no toAny or fromAny.
08:41:37 <Saizan> ski: what dolio means is that "exists a. a" already has the required abstractness, while "forall a. a" doesn't
08:41:52 <Axman6> zhulikas: next step it to start writing things in a more idiomatic way, using library functions. digits is just concatMap show . take n
08:41:53 <bscarlet> Axman6: wouldn't be surprised if the compiler could figure that one out so there's no speed gain.
08:42:09 <Axman6> > concatMap show . take 10 $ [10..]
08:42:11 <lambdabot>   "10111213141516171819"
08:42:20 <zhulikas> hah :D
08:42:41 <Saizan> though exists a. a would support a toAny
08:42:42 <Axman6> wait, maybe it isn't
08:43:07 <Axman6> i think it might actually be take n . concatMap show
08:43:19 <zhulikas> I can't understand any of these two
08:43:25 <zhulikas> so its ok either way
08:43:26 <zhulikas> :D
08:43:30 <ski> Saizan : i don't follow. neither `forall a. a' nor `exists a. a' are abstract, afaiu
08:43:38 <zhulikas> :t (.)\
08:43:39 <lambdabot> parse error on input `\'
08:43:41 <zhulikas> :t (.)
08:43:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:43:44 <Axman6> urgh
08:43:49 <Axman6> don't look at that type
08:43:50 <zhulikas> a boob
08:43:57 <zhulikas> I see it for the first time
08:44:24 <Axman6> (.) :: (b -> c) -> (a -> b) -> a -> c; (f . g) x = f (g x)
08:44:28 <dolio> exists a. a is a safe type to cast all types to, and it can be done naturally if the construct exists in the language.
08:44:38 <zhulikas> :t ($)
08:44:39 <lambdabot> forall a b. (a -> b) -> a -> b
08:44:53 <Axman6> zhulikas: do you understand what `|' does in the shell?
08:44:57 <dolio> And you could say it's okay to cast back out if you cast to the same type.
08:45:09 <zhulikas> Axman6, is it "OR" ?
08:45:18 <Axman6> it's the pipe operator
08:45:21 <dolio> forall a. a is not okay to cast to, because it can be instantiated to any other type.
08:45:23 <Axman6> i guess you're a windows user
08:45:29 <zhulikas> haha yes I am :D
08:45:44 <bscarlet> Axman6: bummer. That was an awesome analogy.
08:45:54 <Axman6> oh well, be none of us perfect
08:47:51 <bscarlet> zhulikas: f (g (h a)) == (f $ g $ h a) == (f.g.h) a
08:48:34 <zygoloid> zhulikas: for meditation: main = interact $ take 10 . show . sum . map (read :: String -> Integer) . lines
08:49:16 <zhulikas> I see...
08:50:29 <hpaste> ski annotated “yay \o/” with “better ?” at http://hpaste.org/50068#a50070
08:50:46 <ski> zhulikas ^
08:50:53 <applicative> yeah I annotated similarly http://hpaste.org/50069
08:50:55 <zhulikas> go away, I want to fix it myself :D
08:51:18 <zhulikas> at first I'll figure out $ and . and then I'll improve it
08:51:58 <Axman6> . is function composition
08:51:59 <zhulikas> :t interact
08:51:59 <lambdabot> (String -> String) -> IO ()
08:52:15 <zhulikas> bscarlet gave a pretty good example
08:52:45 <ski> dolio : it's ok to cast to `forall a. a' if you subsequently instantiate it back to the original type
08:53:18 <bscarlet> zhulikas: f (g (h a)). hmm. I am annoyed by these parentheses. I'll use $. f $ g $ h a.
08:53:19 <dolio> So what?
08:53:27 <ski> it's just a matter of where the unsafe operation is -- either in the "to" operation, or in the "from" operation
08:53:46 <ski> bscarlet : `(f . g . h) a'
08:53:56 <Axman6> bscarlet: f . g . h $ a is the typical usage
08:54:09 <copumpkin> oh sweet, I can finally write hello world in haskell
08:54:15 <Axman6> which is the same as (f . g . h) a
08:54:17 <copumpkin> a ph.d. position in category theory has opened up at strathclyde
08:54:32 <Axman6> copumpkin: in the type system?
08:54:32 <bscarlet> ski, Axman: thanks, but that doesn't help break down teaching . and $ very well. :-)
08:54:48 <zhulikas> $ expressed verbaly sounds for me like "is applied to"
08:54:50 <copumpkin> Axman6: nah, just regular haskell
08:55:02 <copumpkin> I heard I need to have a ph.d in category theory to write hello world
08:55:06 <zhulikas> function a is applied to function b: a $ b
08:55:07 <Axman6> copumpkin: weak man, i expected more from a PhD
08:55:17 <zhulikas> right?
08:55:29 <bscarlet> zhulikas: no
08:55:31 <zhulikas> damn it
08:55:34 <ski> `($) $ a $ b' -- function `a' is applied to `b'
08:55:39 <copumpkin> zhulikas: function a is applied to value b, which could itself be a function
08:55:51 <dolio> ski: Any is (exists a. a) with an injection that happens to be missing.
08:56:13 <zhulikas> ski o.O
08:56:19 <zhulikas> too many $ signs
08:56:36 <Phyx-> oh oh.. infinite loop time
08:56:37 <copumpkin> zhulikas: oh, I was gonna give you this briefcase of cash
08:56:43 <copumpkin> but I guess you don't like $ signs
08:56:45 * copumpkin keeps the cash
08:56:47 <zhulikas> :(
08:56:53 <Phyx-> refactoring fail++
08:56:54 <ski> > id `id` sin `id` (pi / 2)  -- zhulikas, better ?
08:56:55 <lambdabot>   1.0
08:57:16 <zhulikas> y u keep confusing me
08:57:21 <dolio> If you want to use (forall a. a) you _must_ hide the fact that it is (forall a. a) for it to be safe to cast to. It requires further abstraction facilities.
08:57:22 <bscarlet> zhulikas: a $ b means the same as a b, except $ has very low precedence, so a $ b c d means a (b c d).
08:57:56 <ski> zhulikas : we just want to see your brain explode. it's for your own good, honest !
08:58:03 <zhulikas> a $ b $ c d = a (b ( c d )) ?
08:58:12 <bscarlet> zhulikas: yep!
08:58:13 <ski> yes
08:58:15 <zhulikas> ok then
08:58:22 <zhulikas> why did ski put $ BEFORE first function?
08:58:23 <dolio> (exists a. a) requires unsafeCoerce to get out of, which is explicitly unsafe.
08:58:46 <ski> dolio : i'm just saying it could equally well be seen as `forall a. a' with a missing projection
08:58:50 <dolio> (forall a. a) requires unsafeCoerce to get into, but then you can get out of it with what looks like normal language facilities, but it is infact unsafe.
08:59:00 <bscarlet> zhulikas: it's an extra complicated example, just to help your brain explode.
08:59:04 <zhulikas> :D
08:59:06 <Peaker> dolio: so both are explicitly unsafe
08:59:14 <zhulikas> :t a $ b
08:59:15 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
08:59:15 <lambdabot>     In the first argument of `($)', namely `a'
08:59:15 <lambdabot>     In the expression: a $ b
08:59:20 <zhulikas> woops
08:59:38 <ski> re, `Any', it's not `toAny :: a -> Any' or `fromAny :: Any -> a' which is unsafe in isolation. it's only when you combine them that you may do something unsafe
08:59:45 <bscarlet> zhulikas: putting an infix operator in parentheses converts it to a "normal" prefix function.
08:59:54 <dolio> ski: You might as well say that Any = [Int] with its implementation abstracted away.
08:59:56 <zhulikas> a $ b $ c d = (a . b . c) d ?
09:00:04 <bscarlet> zhulikas: yes!
09:00:08 <zhulikas> ok
09:00:14 <zhulikas> and all this is just syntactic sugars?
09:00:17 <dolio> Or anything else.
09:00:20 <Axman6> no
09:00:21 <ski> dolio : with both operations implemented with `unsafeCoerce', yes
09:00:23 <zhulikas> hah :D
09:00:27 <Axman6> zhulikas: they're just normal functions
09:00:31 <dolio> Except, for instance, it's not safe to cast to ().
09:00:33 <Axman6> @src (.)
09:00:33 <lambdabot> (f . g) x = f (g x)
09:00:33 <lambdabot> NB: In lambdabot,  (.) = fmap
09:00:36 <dolio> Because that can confuse the garbage collector.
09:00:37 <Axman6> @src ($)
09:00:37 <lambdabot> f $ x = f x
09:00:41 <dolio> So Any is actually special.
09:00:44 <zhulikas> ok :D
09:00:53 <ski> dolio : my point is that no one of `toAny' and `fromAny' is somehow more unsafe than the other
09:00:58 <zhulikas> bscarlet, I'll get to prefix functions later
09:01:13 <dolio> Yes, it is.
09:01:22 <dolio> Any is supposed to be the union of all types.
09:01:30 <dolio> As opposed to None or something.
09:01:38 <bscarlet> zhulikas: sure - that's just enough of a hint for you to have a label for the weird ($) $ a $ b thing when you want to come back to it.
09:01:48 <dolio> So injection should be safe, and projection not safe.
09:01:57 <zhulikas> thanks for that
09:02:07 <ski> i thought `Any' was supposed to be such that `fromAny . toAny :: a -> b' is safe and is `id', in case `a' is `b'
09:03:09 <ski> another way to look at it is that `toAny :: a -> Any' is treating `Any' like `exists a. a', while `fromAny :: Any -> a' is treating it as `forall a. a'
09:03:22 <dolio> There _is no toAny or fromAny_.
09:03:38 <quicksilver> there is only Zuul
09:03:43 <copumpkin> ZUUL
09:04:03 <dolio> For instance, Any is also used when a type variable must be instantiated to something, but it is completely parametric.
09:04:32 <dolio> If you do 'r <- newIORef undefined' in GHCi for instance, you'll get an IORef Any.
09:05:51 <ski> could you point me to the documentation for `Any' ?
09:06:06 <dolio> I don't know if there is any. It's in the bowels of GHC.
09:07:07 <ski> this latter use of `Any' above seems similar to how e.g. SML/NJ invents new type skolems
09:07:37 <quicksilver> what would be haskell 98 behaviour?
09:07:45 <quicksilver> reject with an ambiguous type error?
09:08:17 <dolio> No, but I don't think it's within the scope of H98, really.
09:08:29 <dolio> You can't observe the behavior outside of something like GHCi.
09:08:54 <dolio> If something totally parametric is ambiguous, it just gets accepted.
09:09:10 <dolio> It doesn't matter what it gets instantiated to.
09:09:12 <quicksilver> but why is this different from let r = [] ?
09:09:22 <quicksilver> which just gets the parametric type [a]
09:09:27 <quicksilver> no ANY involved
09:09:37 <copumpkin> u mad bro?
09:09:50 <dolio> let is subject to generalization.
09:09:58 <dolio> r <- is a lambda binding.
09:10:15 <roconnor> > let dovetail f a b = concat $ map (zipWith f b . reverse) (inits a) in dovetail (,) [0..] [0..]
09:10:17 <lambdabot>   [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2...
09:10:22 <dolio> And thus monomorphic.
09:10:39 <quicksilver> dolio: aha.
09:10:51 <Saizan> generalizing arguments would be very unsafe
09:10:58 <quicksilver> so the difference is that ghci lets us inspect "in the middle" of lambda bindings
09:11:09 <dolio> Yes, something like that.
09:11:28 <copumpkin> λ> x <- return []
09:11:29 <copumpkin> λ> :t x
09:11:29 <copumpkin> x :: [GHC.Prim.Any]
09:11:29 <copumpkin> λ> :t case [] of x -> x
09:11:29 <copumpkin> case [] of x -> x :: [a]
09:11:30 <dolio> You can probably trigger the behavior with MonoLocalBindings now, too.
09:11:44 <quicksilver> Saizan: yes, I am familiar with the unsafeness argument
09:11:54 <quicksilver> Saizan: but I was failing to see the difference between the two situations
09:11:59 <quicksilver> I think I see now.
09:16:13 <rampion> can anyone help me out - I'm trying to use haddock for the first time and running into issues
09:18:21 <Saizan> quicksilver: thought so, but i've just realized it's really about what typing rule we want for lambdas, i.e. if (\x -> B) :: forall a. a -> Int was typechecked by generalizing (x :: a) to (x :: forall a. a) when checking B it'd be a mess. usually you get some argument about IORef's and unsafeCoerce
09:18:34 <hpaste> zhulikas annotated “yay \o/” with “best!” at http://hpaste.org/50068#a50071
09:18:46 <zhulikas> 8-)
09:19:05 <Saizan> though the IORef argument works at the level of do-notation directly rather than it's desugaring
09:19:40 <bscarlet> zhulikas: so now try to do it using . instead of $ to never name "input".
09:19:44 * hackagebot xss-sanitize 0.3.0 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.0 (GregWeber)
09:21:08 <zhulikas> hmm
09:21:15 <zhulikas> I don't know how can I do that
09:21:18 <zhulikas> can you give me a clue?
09:21:35 <bscarlet> zhulikas: \a -> f $ g a = f . g
09:21:42 <bscarlet> sorry. I meant ==
09:22:02 <singpoly1a> Does GHC always build all your imports into the output binary?
09:22:13 <zhulikas> hmmm
09:22:29 <rampion> @singpoly1a: link them you mean?
09:22:29 <lambdabot> Unknown command, try @list
09:22:33 <bscarlet> zhulikas: with parenthesis for clarity: (\a -> f $ g a) == f . g
09:22:40 <dolio> (forall a. a) -> Int is a special case of forall a. a -> Int so I'm not sure why you'd want to make that step anyway.
09:23:01 <singpoly1a> rampion: statically link them.  I don't see any of them in ldd
09:23:07 <dolio> At least, if you allow the sort of impredicativity that even GHC allows without thinking.
09:23:10 <Saizan> singpoly1a: http://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary/6115703#6115703
09:23:46 * ski recovers from local screen collapse
09:23:57 <singpoly1a> Saizan: cool, thx
09:24:21 <zhulikas> bscarlet, where does parameter a go in this example?
09:24:25 <zhulikas> f . g
09:24:43 <bscarlet> zhulikas: parameter? What parameter :-)
09:24:51 <rampion> anyone know why haddock might be telling me "could not find link destinations" for basic GHC types (eg GHC.Real.Integral) and giving me 0% coverage?
09:25:27 <zhulikas> bscarlet, I need more parentheses :D
09:25:40 <ski> anyway, in O'Caml, and i think in some SML implementations as well, when it can't generalize some type variables, it just defers the decision of which types to instantiate them to
09:25:46 <zhulikas> (\a -> f) $ g a = f . g     right?
09:25:54 <bscarlet> zhulikas: nope.
09:26:00 <zhulikas> ok then
09:26:11 <zhulikas> because I saw it that way and it didn't make much sense
09:26:34 <bscarlet> zhulikas: (\a -> f $ g a) == (\a -> (f $ g a)) == (\a -> f (g a)) == f . g
09:26:52 <ski> -| val my_id = id id;
09:26:52 <ski> val my_id = fn  : '1  -> '1
09:26:52 <ski> -| my_id false;
09:26:52 <ski> val it = false : bool
09:26:52 <ski> -| my_id;
09:26:54 <ski> val it = fn  : bool -> bool
09:27:20 <joe6> i want to upload a package to hackage. Do I need a username for that?
09:27:33 <joe6> or, some  kind of login?
09:28:09 <dolio> Yes, you do.
09:28:15 <jaspervdj> joe6: http://hackage.haskell.org/packages/accounts.html
09:29:25 <zhulikas> bscarlet, so readFile "D:/nums.txt" >>= f . g      the result of readFile "D:/nums.txt" automatically is assigned to g function?
09:30:04 <bscarlet> zhulikas, I wouldn't say "assigned", I'd think something like "fed to" or "passed to"
09:30:11 <ski> the result is passed as input to `f . g'
09:30:11 <zhulikas> ok, passed to
09:30:20 <bscarlet> zhulikas: and I think you may need parens around the f.g
09:30:33 <ski> bscarlet : no, you don't
09:30:34 <bscarlet> zhulikas: 'cause I don't know the relative precedence of . and >>=
09:30:42 <zhulikas> input to f. g   That means that input of f is g and input of (f . g) is that something which is passed, right?
09:30:42 <ski>   f . g =<< readFile "D:/nums.txt"  -- this is a nicer order to write this in
09:30:43 <bscarlet> zhulikas: guess not. :-)
09:31:03 <bscarlet> zhulikas: not quite.
09:31:27 <isBEKaml> zhulikas: this is important bit --> (\a -> (f $ g a)) == (\a -> f (g a))
09:31:28 <bscarlet> zhulikas: the input to f is the result that comes out of g.
09:31:30 <dolio> ski: I suspect GHCi is way too top-to-bottom for that.
09:31:44 <zhulikas> oh yesh. Of course it is. My bad :)
09:31:48 <dolio> As opposed to the ML REPLs usually handling arbitrary language constructs.
09:32:12 <zhulikas> isBEKaml, I am already familiar how dollar works, thanks :)
09:32:17 <rudyl313> If I create a data type with the record syntax (with one value constructor) and I'd like to create a value instance of the type with a list of values for the fields in the order I defined them.. whats the easiest way to do that ... e.g. data Type = Type { val1 :: String, val2 :: String } ... and I have a = [ "1", "2"] .. is there a faster way than going let b = Type { val1 = a !! 0, val2 = a !! 1 }?
09:32:31 <ski> dolio : i don't see how that would affect this particular point
09:32:37 <isBEKaml> zhulikas: I was just stating what bscarlet said against the composition operator.
09:32:54 <zhulikas> which one is composition operator? $ or . ?
09:32:55 <zhulikas> or both?
09:32:59 <joe6> jaspervdj: is Ross on this channel?
09:33:00 <isBEKaml> zhulikas: .
09:33:04 <ski> dolio : replace `val my_id = id id' with `my_id <- id id' for the GHCi equivalent
09:33:04 <zhulikas> ok
09:33:07 <isBEKaml> (dot)
09:33:25 <joe6> jaspervdj: i emailed him, but was hoping that if i can find him on this channel, I could have a quicker response.
09:33:26 <dolio> ski: GHCi punts on any kind of forward reference.
09:33:46 <jaspervdj> joe6: I don't think he's in here. But you should get a response very soon.
09:33:46 <tommd> preflex: seen tibbe
09:33:46 <preflex>  tibbe was last seen on #ghc 33 minutes and 50 seconds ago, saying: the one I tried to add to ghc-prim, the RTS, etc
09:33:56 <bscarlet> zhulikas: $ is the application operator.
09:33:58 <ski> dolio : it's not like ML repls allow any (non-explicit) mutual recursion either
09:33:59 <joe6> jaspervdj: ok, thanks.
09:34:04 <parcs> rudyl313: let (val1:val2:_) = a in let b = Type {..}
09:34:05 <tommd> tibbe: FYI, you've had a pull request sitting (no hurry on my end, purely an FYI)
09:34:13 <dolio> Ah. Okay.
09:34:13 <tommd> @tell tibbe FYI, you've had a pull request sitting (no hurry on my end, purely an FYI)
09:34:14 <lambdabot> Consider it noted.
09:34:25 <parcs> rudyl313: that requires a language extension though
09:34:27 <ski> dolio : this is just a "back-patching", by instantiating a type variable earlier left uninstantiated
09:35:18 <rudyl313> parcs: thanks
09:36:12 <ski> (dolio : btw, this doesn't only happen in the interactor, but also in source files. if something can't be generalized, it defers instantiating the type variables. if the later context doesn't instantiate them, i think you'll either get an error, or they get arbitrarily instantiated to fresh skolems (like `Any', but a new one for each of the free type variables))
09:37:11 <dolio> Ah.
09:37:35 <dolio> I imagine GHC uses Any if you can actually get it to happen in a source file.
09:37:39 <dolio> Although that'd be difficult.
09:38:29 <Phyx-> quick question, is it possible to pull a package version from hackage?
09:38:42 <dolio> Actually, it's not that difficult.
09:38:55 <dolio> (f, g) = (\x -> g x, \y -> g y)
09:39:03 <dolio> f, g :: Any -> Any
09:40:15 <dolio> (f, g) = (f, g) works, actually.
09:42:00 <dolio> I guess that is relevant to H98.
09:42:18 <dolio> Unless monomorphic pattern bindings is an extension, I forget.
09:43:14 <zhulikas> main = return . take 10 . show . sum . map (\f -> read f :: Integer) lines =<< readFile "D:/nums.txt"
09:43:19 <zhulikas> I don't see why this is wrong
09:43:27 <zhulikas> besides missing argument for lines
09:43:42 <zhulikas> which should be provided by =<<
09:43:58 <ben> maybe add another . before lines
09:44:14 <zhulikas> :D
09:44:16 <zhulikas> WHY :D
09:44:21 <zhulikas> aaa
09:44:21 <zhulikas> ok
09:44:30 <zhulikas> because there are no functions which take two arguments (I speak about map)
09:44:38 <zhulikas> it's just one function applied to another
09:44:39 <hatds> rudy1313: the better way is to have your data be in a tuple, not a list
09:44:43 <roconnor> > map reverse (inits [1,2,3]
09:44:43 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:44:47 <zhulikas> thank you
09:44:50 <roconnor> > map reverse (inits [1,2,3])
09:44:51 <lambdabot>   [[],[1],[2,1],[3,2,1]]
09:45:01 <roconnor> > tails (reverse [1,2,3])
09:45:02 <lambdabot>   [[3,2,1],[2,1],[1],[]]
09:45:09 <chrisdone> Igloo: “We've been told by the venue that the main meeting room can accommodate 18 laptops plugged in at a time, so we will have to rotate.” — does that preclude extension chords? :-)
09:45:16 <ben> Because function call 'map whatever lines' has a higher precedence than =<< so =<< does not get around to passing an argument to lines before map tries to do its thing
09:45:28 <roconnor> > reverse (tails (reverse [1,2,3]))
09:45:29 <lambdabot>   [[],[1],[2,1],[3,2,1]]
09:45:33 <ski>   main = liftM (ake 10 . show . sum . map (\f -> read f :: Integer) . lines) (readFile "D:/nums.txt"
09:45:36 <ski> zhulikas ^
09:45:44 <ski> s/ake/take/ :)
09:45:47 <roconnor> I suppose reverse . tails . reverse is better than map reverse inits?
09:45:48 <Igloo> chrisdone: The issue is power rather than sockets AIUI, yes
09:45:58 <chrisdone> Igloo: ah, really? fair enough
09:46:44 <ski> zhulikas : generally, `return . f =<< foo' can be simplified to `liftM f foo'
09:46:56 <zhulikas> :t liftM
09:46:56 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:47:01 <zhulikas> useless
09:47:05 <roconnor> oh wait laziness
09:47:12 <roconnor> > map reverse (inits [1..])
09:47:13 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1],[6,5,4,3,2,1],[7,6,5,4,3,2,1],[...
09:47:16 <ski>   liftM :: Monad m => (a -> b) -> (m a -> m b)
09:47:18 <roconnor> > reverse (tails (reverse [1..]))
09:47:22 <lambdabot>   mueval-core: Time limit exceeded
09:47:30 <roconnor> damn you infinite lists!
09:47:40 <bscarlet> zhulikas: it means "convert this function to something that work on stuff in my monad"
09:47:47 <ski> zhulikas : so `liftM' converts any function of type `a -> b' into a function of type `IO a -> IO b'
09:48:29 <roconnor> I must be able to write this as some sort of scanl
09:48:38 <zhulikas> I am not familiar with monads yet. :)
09:48:41 <roconnor> > scanl (:) [] [1..]
09:48:44 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:48:46 <zhulikas> but thanks for a hint
09:48:54 <zhulikas> I'll for a few more Euler problems now \o/
09:48:54 <Ivan64> I've installed GHC 7 on my PowerBook. In an Intro to Haskell that I attended last evening there was an import Text.Parsec statement. The statement didn't work.
09:48:55 <roconnor> > scanl (flip (:)) [] [1..]
09:48:57 <lambdabot>   [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1],[6,5,4,3,2,1],[7,6,5,4,3,2,1],[...
09:49:02 <roconnor> :D
09:49:12 <ski> > (tail . inits) "abcd"
09:49:14 <lambdabot>   ["a","ab","abc","abcd"]
09:49:18 <ski> > (init . tails) "abcd"
09:49:20 <lambdabot>   ["abcd","bcd","cd","d"]
09:49:22 <chrisdone> Igloo: do you know if Bancomat cards work in the UK? I doubt it, but saves me bringing cash if so
09:49:32 <chrisdone> (or do any europeans who are aware of Bancomat know?)
09:49:49 <zygoloid> chrisdone: i've never heard of a bancomat card, so i guess... outlook bleak.
09:49:58 <Igloo> I've never heard of it either
09:50:09 <pisum> i'm looking for such a function: f func (x:xs) (y:ys) = (func x y):(f func xs ys) -- i'm sure it already exists in the prelude or in data.list or so, but i dont know its name :/
09:50:16 <ski> > (map (tail . inits) . tails) "abcd"
09:50:18 <lambdabot>   [["a","ab","abc","abcd"],["b","bc","bcd"],["c","cd"],["d"],[]]
09:50:30 <roconnor> this is what I have to implement dovetailing: dovetail f l1 l2 = concat $ map (zipWith f l1) (scanl (flip (:)) [] l2) ++ map (flip (zipWith f) (reverse l2)) (tail (tails l1
09:50:35 <chrisdone> it's one of those 'supposed to work in europe', I used it in germany, for example. but yeah I'll hold no hope for the UK
09:50:54 <hatds> Ivan64: Parsec is a package you can obtain from hackage.  It doesn't come bundled with GHC.
09:51:06 <ski> roconnor : cut off at "(tail (tails l1"
09:51:20 <zygoloid> chrisdone: looks like 'bancomat' just means 'cash machine'?
09:51:24 <roconnor> ski: oops. "...))"
09:51:44 <roconnor> hopefuly ghc has some sort of map-scanl fusion?
09:51:46 <chrisdone> zygoloid: it's a brand of card used for shops and ATM withdrawals, but it may be a synonym in some places, yeah
09:52:24 <zygoloid> chrisdone: if it's not visa or switch or mastercard or maestro, then it's unlikely it'll work here
09:52:37 <hatds> :t scanl
09:52:39 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
09:52:54 <ski> @let dovetail f l1 l2 = concat $ map (zipWith f l1) (scanl (flip (:)) [] l2) ++ map (flip (zipWith f) (reverse l2)) (tail (tails l1))
09:52:55 <lambdabot>  Defined.
09:53:01 <ski> @type dovetail
09:53:02 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
09:53:26 <roconnor> > dovetail (,) [1,2] [1,2,3]
09:53:28 <lambdabot>   [(1,1),(1,2),(2,1),(1,3),(2,2),(2,3)]
09:53:41 <roconnor> > dovetail (,) [1,2] [1..]
09:53:43 <lambdabot>   [(1,1),(1,2),(2,1),(1,3),(2,2),(1,4),(2,3),(1,5),(2,4),(1,6),(2,5),(1,7),(2...
09:53:50 <roconnor> > dovetail (,) [1..] [1,2]
09:53:51 <lambdabot>   [(1,1),(1,2),(2,1),(2,2),(3,1),(3,2),(4,1),(4,2),(5,1),(5,2),(6,1),(6,2),(7...
09:54:00 <pisum> f func (x:xs) (y:ys) = (func x y):(f func xs ys) -- is there a already existing function (in the prelude or sth) which does exactly this?
09:54:39 <hatds> :t zipWith
09:54:40 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
09:54:41 <c_wraith> pisum: is that zipWith?
09:54:55 <pisum> c_wraith, hatds: thanks =]
09:55:00 <chrisdone> zygoloid: guess I'll just bring lots of cash
09:55:04 <zhulikas> let forEven (even n == True) = n * 2 + 1
09:55:09 <zhulikas> can I make such patterns ?
09:55:14 <zhulikas> this one doesn't compile though
09:55:23 <c_wraith> zhulikas: you can make it guard
09:55:32 <hatds> no, only constructors and literals are allowed in patterns
09:55:38 <ski> > let forEven n | even n = n * 2 + 1 in forEven 4
09:55:39 <lambdabot>   9
09:55:41 <ski> > let forEven n | even n = n * 2 + 1 in forEven 5
09:55:43 <lambdabot>   *Exception: <interactive>:3:4-33: Non-exhaustive patterns in function forEven
09:55:55 <roconnor> ski: this scanl is a trace of (reverse l2).  In principle I ought to be able to reuse the last element of (scanl (flip (:)) [] l2) to replace the call to (reverse l2)
09:56:08 <ski> > let forEven n@(even -> True) = n * 2 + 1 in forEven 4
09:56:08 <lambdabot>   9
09:56:10 <zhulikas> :t (|)
09:56:11 <lambdabot> parse error on input `|'
09:56:25 <ski> > let forEven n | True <- even n = n * 2 + 1 in forEven 4
09:56:26 <lambdabot>   9
09:57:10 <c_wraith> zhulikas: | is syntax.  look up guard syntax
09:57:39 <ski> roconnor : i'm not clear yet what the function is supposed to do
09:58:03 <zhulikas> ok thanks
09:58:17 <roconnor> ski: dovetail (,) enumerates all pairs from two lists even if the lists are infinite.
09:58:30 <ski> > scanl (flip f) z [a,b,c] :: [Expr]
09:58:30 <roconnor> compare
09:58:31 <lambdabot>   [z,f a z,f b (f a z),f c (f b (f a z))]
09:58:37 <roconnor> > dovetail (,) [1..] [1,2]
09:58:38 <lambdabot>   [(1,1),(1,2),(2,1),(2,2),(3,1),(3,2),(4,1),(4,2),(5,1),(5,2),(6,1),(6,2),(7...
09:58:38 <chrisdone> copumpkin, Saizan: what do you do for cash when you go to other countries? my bank gave me the option for bancomat, which is probably useless for the UK. they also gave me a "SuperFlash" which is a kind of pay-as-you-go top-up card that you add money to via your bank web site, but I've found that is very hit-and-miss and not likely to work in the UK, either. I don't appear to be able to get a US/UK-ish credit card (draw funds on loan from a comp
09:58:39 <chrisdone> any and pay back later) or debit card (draw only funds from your current account). ideas?
09:58:43 <roconnor> > zipWith (,) [1..] [1,2]
09:58:44 <lambdabot>   [(1,1),(2,2)]
09:58:47 <roconnor> er
09:58:53 <roconnor> > liftM2 (,) [1..] [1,2]
09:58:54 <lambdabot>   [(1,1),(1,2),(2,1),(2,2),(3,1),(3,2),(4,1),(4,2),(5,1),(5,2),(6,1),(6,2),(7...
09:58:57 <ski> roconnor : oh, so it's a fair cartesian product ?
09:59:04 <roconnor> > dovetail (,) [1,2] [1..]
09:59:07 <lambdabot>   [(1,1),(1,2),(2,1),(1,3),(2,2),(1,4),(2,3),(1,5),(2,4),(1,6),(2,5),(1,7),(2...
09:59:10 <roconnor> > liftM2 (,) [1,2] [1..]
09:59:11 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
09:59:13 <roconnor> ya
09:59:56 <ski> > [0,1,2] >>- \x -> "abc" >>- \y -> [(x,y)]
09:59:57 <lambdabot>   [(0,'a'),(1,'a'),(0,'b'),(2,'a'),(0,'c'),(1,'b'),(2,'b'),(1,'c'),(2,'c')]
10:00:12 <c_wraith> roconnor: I'm just not convinced that any function that uses ++ is as good as it can be.
10:00:15 <ski> > [0 ..] >>- \x -> [0,10 ..] >>- \y -> [(x,y)]
10:00:16 <lambdabot>   [(0,0),(1,0),(0,10),(2,0),(0,20),(1,10),(0,30),(3,0),(0,40),(1,20),(0,50),(...
10:00:39 <roconnor> c_wraith: yep
10:03:15 <roconnor> c_wraith: wait.  ++ isn't so bad
10:03:20 <hpaste> zhulikas pasted “guardz” at http://hpaste.org/50074
10:03:35 <Eduard_Munteanu> chrisdone: get a regular debit card, or some sort of prepaid / preloaded card? These are a lot easier to get than credit cards.
10:03:43 <zhulikas> no instance for fractional int.
10:03:55 <zhulikas> but if I know it's even, I can divide it by 2!
10:04:09 <Eduard_Munteanu> If you're in the US, those cards should be compatible with EU stuff IIRC
10:04:31 <NihilistDandy> zhulikas: Ints are Ints
10:04:38 <zhulikas> should I prefer pattern matching or guards where possible?
10:04:41 <chrisdone> Eduard_Munteanu: ah, you mean you buy one like 'give me a card with 1.000EUR on it'?
10:04:44 * ski . o O ( "Credit Card Transform" <http://okmij.org/ftp/Haskell/index.html#ccard-transform>)
10:05:12 <Eduard_Munteanu> chrisdone: yes, that's one option. Though beware of the fees and transaction limits.
10:05:14 <zhulikas> my question doesn't make much sense. nevermind
10:05:27 <ski> zhulikas : pattern-matching
10:05:45 <Eduard_Munteanu> They also go by the name of "gift cards".
10:05:48 <bscarlet> :t div
10:05:48 <lambdabot> forall a. (Integral a) => a -> a -> a
10:05:49 <ski> zhulikas : use  x `div` 2
10:05:56 <zhulikas> oh, ok
10:06:06 <ski> > 10 `div` 2
10:06:07 <lambdabot>   5
10:06:08 <ski> > 11 `div` 2
10:06:09 <lambdabot>   5
10:06:11 <ski> > 12 `div` 2
10:06:12 <lambdabot>   6
10:06:32 <zhulikas> what do these ` ` do?
10:06:38 <ski> `div' is integral division, rounding downwards
10:06:43 <ski> > div 12 2
10:06:44 <lambdabot>   6
10:06:54 <Eduard_Munteanu> zhulikas: it transforms a function into an infix operator
10:06:56 <ski> zhulikas : they make `div' an infix operator
10:07:03 <zhulikas> :D ok...
10:07:10 <zhulikas> can I do that to any function?
10:07:14 <bscarlet> zhulikas: yep
10:07:16 <Eduard_Munteanu> '(' and ')' do the opposite
10:07:17 <zhulikas> cool
10:07:24 <Eduard_Munteanu> infix to prefix, that is
10:07:31 <Eduard_Munteanu> :t (+)
10:07:32 <lambdabot> forall a. (Num a) => a -> a -> a
10:07:36 <ski> > (False `not`)
10:07:37 <Phyx-> :t newArray
10:07:37 <lambdabot>   True
10:07:37 <lambdabot> Not in scope: `newArray'
10:07:38 <Eduard_Munteanu> > (+) 1 2
10:07:39 <lambdabot>   3
10:07:59 <zhulikas> > 11 `div` 2
10:08:00 <lambdabot>   5
10:08:06 <zhulikas> > 11 'div' 2
10:08:07 <lambdabot>   <no location info>:
10:08:07 <lambdabot>      lexical error in string/character literal at chara...
10:08:22 <zhulikas> my bad. chars are put in ' '
10:10:04 <roconnor> dovetail: http://hpaste.org/50075
10:10:20 <roconnor> not a very nice recursion scheme though :(
10:11:23 <roconnor> maybe I can turn the whole thing into one big scanl
10:12:11 * ski wonders whether it could be done with delimited continuations
10:12:25 <roconnor> not a bad idea
10:12:28 <roconnor> :P
10:12:41 <roconnor> @src scanl
10:12:41 <lambdabot> scanl f q ls = q : case ls of
10:12:41 <lambdabot>     []   -> []
10:12:42 <lambdabot>     x:xs -> scanl f (f q x) xs
10:14:11 <bscarlet> what's a delimited continuation?
10:14:35 <ski> a continuation which can return
10:15:03 <ski> or, a continuation minus another (smaller) continuation
10:15:08 <hatds> I want to make a haskell EDSL which allows identifiers to begin with capital letters but is otherwise like haskell.  You would be able to refer to non-constructors already in scope.  Presumably I'm going to use TH.  Any ideas how to do this though?
10:16:13 <ski> bscarlet : you'd probably want to learn regular CPS before turning to delimited continuations
10:17:26 <bscarlet> ski: thanks, I know CPS, at least in rudimentary form - well enough to use ContT, for instance.
10:19:13 <bscarlet> ski: but not well enough to understand your use of "minus".
10:19:20 <hatds> my plan is to prefix identifiers as u_xxx or l_xxx under the hood to indicate whether they are capitalized in the EDSL.  The problem is that I'd want to use haskell's module system, but then the u_xxx and l_xxx names would be how I would refer to imported names...
10:20:56 <ski> bscarlet : well, composable/delimited/sub-continuations correspond to nqCPS
10:21:16 <ski> meaning "not-quite Continuation-Passing Style" :)
10:21:28 <ski> meaning that most, but not all call, are tail-calls
10:21:38 <tibbe> tommd: oh, what did I miss?
10:21:51 <bscarlet> ski: ok.
10:23:54 <ski> bscarlet : in a hypothetical Haskell with delimited continuations side-effects, `1 + reset (2 * shift c in c (c 100))' would evaluate to `401'
10:24:15 <ski> where `reset' and `shift' are the two basic primitives that replace `callCC'
10:24:40 <tibbe> tommd: found it, reviewing
10:25:52 <ski> <http://community.schemewiki.org/?composable-continuations-tutorial> has some more examples of it
10:26:49 <chrisdone> Igloo: zygoloid: Eduard_Munteanu: fwiw my british friend assures me that his bancomat worked in the UK because it's a Maestro and if the ATM supports maestro it should work. we'll see…
10:27:49 <Igloo> Maestro should be OK, yes
10:28:20 <Eduard_Munteanu> I find Visa more common.
10:28:49 <ski> bscarlet : anyway, in that example, `c' becomes bound to `\x -> 2 * x', so the continuation captured by the `shift' there is delimited by the (dynamically enclosing) `reset'
10:28:52 <Eduard_Munteanu> Dunno about UK in particular though.
10:29:00 <chrisdone> i'll take a poll at camhac of what features haskellers would like to see for their emacs
10:32:34 <byorgey> chrisdone: ooh! I would like to be able to auto-insert LANGUAGE pragmas based on suggestions in GHC's error messages
10:33:30 <chrisdone> I would also like that…
10:33:33 * chrisdone adds to TODO list
10:33:53 * ski imagines byorgey auto-inserting `OverlappingInstances' without noticing
10:34:17 * Phyx- imagines Undecideableinstances
10:34:50 <copumpkin> chrisdone: I think you can get a cirrus bancomat that works in multiple countries
10:35:17 * byorgey doesn't mind UndecidableInstances at all
10:35:23 <byorgey> but I do try to avoid Overlapping
10:35:24 <chrisdone> copumpkin: mine has a cirrus logo on the back. good enough?
10:35:30 <copumpkin> chrisdone: should be, I think
10:35:35 <copumpkin> chrisdone: you speak italian yet?
10:35:37 <chrisdone> QED.
10:35:56 <chrisdone> nah. I only speak to you guys :p
10:36:02 <copumpkin> lol
10:36:45 <chrisdone> actually I think I know a fair bit, I can hold a conversation but I rely heavily on context and body language
10:38:18 <copumpkin> ah
10:38:32 <Phyx-> copumpkin: anything with a Maestro logo on it should work
10:39:17 <chrisdone> copumpkin: the only practise i get is when i need something. at work we speak english, it's only 20% italians in the dev team. and, well, i do what i'm doing now, talk to people on IRC @_@ do I suck?
10:39:32 <copumpkin> :P
10:39:34 <copumpkin> yep
10:40:27 <chrisdone> ;_;
10:42:17 <chrisdone> sono sapere di piu parola male e.g. fanculo stronzo :p
10:43:09 <chrisdone> (si questo é stronzo)
10:43:45 <bscarlet> ski: I'm not sure I understand the syntax of your pseudo language with it's use of "in". Could you parenthesize more?
10:46:19 <NihilistDandy> chrisdone: heh
10:46:41 <dylukes> What's the proper way in a shell script to apply something recursively throughout subdirectories?
10:47:05 <chrisdone> copumpkin: anyway basta, sei fare mi sento male :-(
10:47:05 <dylukes> Like if I have a src directory and I want to apply etags to everything in it (including files within the subdirectories)
10:48:39 <chrisdone> what's the italian equivalent for 'engrish'? italianu?
10:49:08 <osfameron> chrisdone: itangliano ?
10:49:17 <chrisdone> lol
10:49:28 <chrisdone> perfetto xD
10:49:38 <osfameron> chrisdone: actually, that's not quite right
10:49:55 <osfameron> I think itangliano is loan words from English into Italian
10:50:00 <osfameron> as opposed to badly translated stuff
10:50:04 <chrisdone> that's a real word? huh
10:51:06 <osfameron> well, I've heard it used, and google has hits for it
10:51:25 <chrisdone> that's enough criteria for real word, for me :)
10:51:43 <osfameron> ;-)
10:54:35 <pisum> i defined a new data-type (using 'data'). now i wanna make [MyNewDataType] manually an instance of Show. (Like this: 'instance Show [MyNewDataType] where ...".) But is that possible/allowed at all? (I get an error…)
10:55:48 <benmachine> ion: I don't remember saying that :P
10:55:52 <benmachine> ion: however, liftA2 (liftA2 (,)) filter (filter . (not .))
10:56:00 <benmachine> what's the problem :o
10:56:07 <ski> bscarlet : `1 + (reset (2 * (shift c in (c (c 100)))))'
10:57:18 <copumpkin> chrisdone: :O
10:58:05 <rwbarton> @type showList
10:58:05 <lambdabot> forall a. (Show a) => [a] -> String -> String
10:58:32 <rwbarton> pisum: in this particular case you can do this by defining showList in the Show instance for MyNewDataType
10:58:41 <mm_freak_> > showList [1,2,3] "test"
10:58:42 <lambdabot>   "[1,2,3]test"
10:58:52 <pisum> rwbarton: coool!!! thanks very much! :]
10:59:21 <mm_freak_> i guess that's just part of a bigger picture, so i won't ask, why the hell you wouldn't just use 'show' and (++)
10:59:36 <bscarlet> ski: okay, I can parse it and see why it'd evaluate as you say, at least.
10:59:59 <rwbarton> I assume it's because you don't want the default syntax with [,] for some reason?
11:00:43 <monochrom> @bots
11:00:44 <lambdabot> :)
11:00:45 <chrisdone> copumpkin: haha
11:01:40 <sm> good day all.. how's haskell life on osx lion ?
11:02:32 <NihilistDandy> sm: Quite goof
11:02:34 <NihilistDandy> *good
11:02:41 <monochrom> freudian slip :)
11:03:33 <NihilistDandy> I said one thing, but I meant my mother T_T
11:04:31 <sm> I just upgraded to snow leopard, to get GHC 7 on this mac. Lion is tempting me
11:10:17 <bos> GHC doesn't work on Lion yet
11:10:25 <bos> there's a good chance that 7.2.1 will
11:11:06 <NihilistDandy> bos: That's not true
11:11:19 <NihilistDandy> I'm using ghc 7.0.4 on Lion
11:11:33 <bos> i assume you had to do some hacking to get it to use the right gcc
11:11:39 <thoughtpolice> i think manuel has sorted out all the issues in 7.2.1 and xcode 4.1 etc. the only thing that won't work is you cannot build say, ghc 7.0.4 on lion without some modifications
11:11:47 <NihilistDandy> bos: Nope. I just used Homebrew
11:11:48 <thoughtpolice> (mostly just saying --use-cc=gcc-4.2 when you ./configure)
11:12:11 <NihilistDandy> thoughtpolice: I didn't have to hack at anything
11:12:15 * NihilistDandy shrugs
11:12:16 <thoughtpolice> NihilistDandy: that's not surprising. homebrew uses a binary package anyway
11:12:22 <NihilistDandy> Ah, that'd do it
11:12:40 <bos> ah
11:12:42 <thoughtpolice> binary packages will work fine. 7.0.4 binaries will work on lion. but you cannot build 7.0.4 on lion without specifically pointing it to gcc 4.2
11:12:54 <thoughtpolice> 7.2.1 is OK all the way through however, it'll build/work on both SL and lion
11:13:28 <thoughtpolice> from what i've heard in #homebrew I hope some of david's clang patches are merged soon. word on the streetz are that xcode 4.2 will completely get rid of gcc 4.2
11:13:32 <thoughtpolice> :/
11:14:29 <ski> bscarlet : in Haskell, you could have `reset :: Cont2 p q q -> Cont2 o o p; shift :: ((a -> p) -> Cont2 o q q) -> Cont2 o p a'
11:14:32 <thoughtpolice> which is kind of bleh, since some stuff doesn't work with llvm-gcc or even clang correctly just yet. i don't know for example how compiling valgrind will be possible :|
11:14:54 <ski> bscarlet : given `newtype Cont2 o p a = MkCont2 {runCont2 :: (a -> p) -> o}'
11:15:10 <hatds> hmm.. on snow leopard my connection to freenode gets reset after inactivity, anyone know how to disable that?
11:15:48 <thoughtpolice> hatds: it's probably an idle timeout on your IRC client? i've never had that problem with irssi
11:15:51 <chrisdone> mine does that if it opens the screensaver, i think. whether the two are related or just coincidental, I don't know
11:15:56 <sm> thanks, I guess I'll cool my heels for a bit
11:17:21 <ski> bscarlet : you can also do `newtype Cont2T o p m a = MkCont2T {runCont2T :: (a -> m p) -> m o}', and then you can do fun stuff like `for :: Monad m => [a] -> Cont2T [o] o m a'
11:18:53 <bscarlet> ski: okay. Cont2 generalizing Cont gets at the heart of my pondering what's different. Thanks.
11:19:46 <hatds> hmm, probably is the computer sleep mode that kicks in before the screensaver
11:20:38 <ski> bscarlet : this is usefully used together with `class IxMonad m where ixreturn :: a -> m i i a; ixbind :: m i j a -> (a -> m j k a) -> m i k a'
11:21:22 <ski> bscarlet : another type that can be used for this class is `newtype State2 s t a = MkState2 {runState2 :: s -> (t,a)}'
11:22:09 <bscarlet> ski: stack overflow. dumping to emacs for later consideration. :-)
11:24:10 <dainanaki> when building ghc, how do I set the arch to build for?
11:27:20 <ski> bscarlet : some more things to put on the "to read list" : <http://blog.sigfpe.com/2009/02/beyond-monads.html>,<http://okmij.org/ftp/Computation/monads.html#param-monad>,<http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed.html>
11:31:19 <luite> I have a dependency problem, cabal install wants to install some version of Cabal, but I don't know why. is it possible to show a graph of which packages in the requested installation depend on cabal, directly or indirectly?
11:32:34 <sm__> luite: does cabal --install -v3 --dry help ?
11:34:42 <luite> sm__: well it does probably show why it's been selected, but also lots more
11:34:50 <jonkri> would it be cool/redundant to build an open source e-commerce web/json server in haskell? :)
11:35:02 <luite> not redundant
11:35:20 <luite> there's no free e-commerce thing in haskell yet
11:35:25 <luite> at least not that I'm aware of
11:35:35 <jonkri> i'm thinking as a serverside component for web shops
11:35:46 <jonkri> ok
11:35:50 <luite> based on yesod or snap? happstack?
11:36:01 <jonkri> i'm currently looking at happstack and acid state
11:36:12 <jonkri> but i guess the happstack/yesod part would be pretty minimal
11:36:25 <luite> hmm, really? why?
11:37:26 <jonkri> i'm thinking that most of the code will be operating in the database/transaction layer
11:37:37 <jonkri> but maybe i'm wrong (i'm a novice developer)
11:38:00 <jonkri> ah
11:38:06 <jonkri> i'm thinking that the web client is completely separate
11:38:31 <luite> you just want to generate json?
11:38:44 <jonkri> maybe yeah
11:38:54 <jonkri> that's what i thought
11:39:15 <jonkri> about doing
11:39:29 <luite> but you probably still need multiple handlers for different types of requests, validation of user input, maybe sessions, authentication
11:39:40 <luite> those are all provided, to some extent, by those frameworks
11:40:09 <jonkri> aha, right
11:41:10 <chrisdone> so you'd write all the front-end in javascript?
11:41:19 <jonkri> i guess the level of javascript usage is interesting here. do i use web storage for sessions? do i need auth?
11:41:39 <chrisdone> I have a large application that has this model presently
11:42:08 <jonkri> cool. how is that working for you?
11:42:12 <chrisdone> each json request includes the session token, the server has a session cache that it consults, and otherwise queries our internal single-sign-on service to see if the session is valid
11:42:35 <chrisdone> it works fine but I hate programming in JavaScript with a passion
11:42:48 <jonkri> haha, tell me about it :P
11:42:59 <bscarlet> I tried programming in JavaScript with no passion, but I hated that too.
11:43:01 * chrisdone has much interest in ghcjs
11:43:21 <jonkri> are you making use of jquery?
11:43:30 <chrisdone> yeah, that's what i use for generation of the UI
11:43:56 <jonkri> what about parsing the json?
11:44:15 <jonkri> brb phone
11:44:42 <chrisdone> that's all automatic. i just write query(some_resource,{param1:…,paramN:…},function(result_obj){ … }); and on the server side:
11:44:45 <chrisdone> controller "user.activity" [| do
11:44:46 <chrisdone>   uid <- getGenericUserId
11:44:46 <chrisdone>   events <- db $ getUserActivity 20 uid
11:44:46 <chrisdone>   success events
11:44:46 <chrisdone>  |]
11:44:49 <chrisdone> for example
11:45:43 <chrisdone> (this macro adds user.activity to a list of json handlers)
11:46:23 <sm> it sounds nice chrisdone
11:46:36 <chrisdone> there're about 200 controllers >_>
11:47:53 <luite> hmm, is there something that can generate dependency graphs for hackage packages?
11:47:54 <chrisdone> it's alright, yeah. i'd prefer the client to be written in haskell, too
11:48:25 <dainanaki> lute I think cabal can do graphviz output?
11:48:27 <dainanaki> *luite
11:48:37 <sm> chrisdone: sure
11:48:51 <dcoutts> dainanaki: you're thinking of ghc-pkg
11:49:00 <dainanaki> ok.
11:49:25 <dainanaki> Thanks. I've never used it, I just remember seeing the option at some point.
11:50:04 <luite> dainanaki: oh I need it for an uninstalled package, I want to find out where some dependency comes from
11:51:17 <joe6> is there a simple tutorial to getting started with the haddock documentation in a haskell file? I am trying to use "cabal haddock" and it complains about some comments.
11:51:22 <chrisdone> sm: around the 20219 lines of code mark, language really starts to matter. I can't trust JS code like I can trust haskell code. refactoring is hard, maintaining is hard
11:51:28 <joe6> I am looking for something simple to get the basics correct.
11:51:38 <dcoutts> joe6: there's the haddock user guide
11:51:47 <joe6> i can see the haddock user guide, but am looking for something simpler.
11:51:48 <chrisdone> @google haddock user guide
11:51:49 <lambdabot> http://www.haskell.org/haddock/doc/html/index.html
11:51:49 <lambdabot> Title: Haddock User Guide
11:51:58 <dainanaki> so nobody knows how to compile ghc on a Mac for 64-bit?
11:52:36 <thoughtpolice> dainanaki: procedure - step 1) download 64bit GHC binary distribution that already exists. step 2) build GHC source code.
11:52:49 <chrisdone> the haddock user guide is pretty straight-forward… how simpler do you want?
11:52:55 <jonkri> thanks chrisdone :)
11:52:56 <dainanaki> ah, so I can't build it with a 32-bit compiler installed?
11:53:00 <jonkri> interesting stuff
11:53:00 <thoughtpolice> manuel recently got the whole testsuite among other things passing on 64bit GHC, so as of 7.2.1 it should be nice and stable
11:53:31 <thoughtpolice> dainanaki: er, no. not easily at least. porting GHC is a massive PITA at the moment, and OS X is a bit of a weirdo because it's simultaneously both 32-bit and 64bit (in the leopard/snow leopard case, lion is full 64bit)
11:53:58 <jonkri> i guess javascript would be a requirement of the web shop application
11:54:12 <thoughtpolice> porting it was quite a challenge even a year or two ago when i tried a lot. i eventually got a mostly working build, but it broke really soon afterwords, and I think gcollins inevitably did the work to bring it back up to speed, and he put it in macports
11:54:23 <dainanaki> yeah, I was just confused since when I ran ./configure and told it to target x86_64, it didn't complain until I ran make.
11:54:50 <thoughtpolice> since then most people have just been using the 64bit binaries that you can download in order to bootstrap/develop on x86_64
11:55:06 <jonkri> how mature is ghcjs?
11:55:10 <dainanaki> hrm, well if that's all that's needed to bootstrap, that's fine.
11:55:48 <thoughtpolice> dainanaki: yeah, you can get 64bit 7.0.4 from the download page. i think there's also a HP installer for it. 7.0.4 has some known bugs/test failures on x86_64 OS X, but 7.2.1 should be relatively stable
11:55:53 <thoughtpolice> and it'll be out soon too
11:56:06 <dainanaki> Yeah, I need to build head though.
11:56:10 <thoughtpolice> ah
11:56:23 <dainanaki> ezyang has made some commits in head that I want to look at.
11:57:15 <thoughtpolice> in that case you can just grab a 64bit binary build. HEAD etc should 'just work' on 64bit OS X as of recently
11:57:28 <chrisdone> jonkri: it's alpha. I'm beginning to think that someone should use it for a big application in order to force it to be stable/weed out the show-stopping issues. that'll encourage adoption and encourage development on it
11:57:34 <thoughtpolice> (after all the xcode 4.1 confusion/linker weirdness got sorted out)
11:57:54 <dainanaki> yikes, yeah that linker stuff was awful
11:58:07 <thoughtpolice> it wasn't really harmful at all. just annoying
11:58:08 <NihilistDandy> Quite so
11:58:14 <dainanaki> i know
11:58:50 <thoughtpolice> lion made it worse because they defaulted to PIE, so that had to be taken care of too. it was all fairly harmless, it just made f'ed up some testsuite output in my experience
11:58:57 <dainanaki> ok, so to be clear: downloading the 7.0.4 64-bit build is all that I need to bootstrap head?
11:59:00 <thoughtpolice> yes
11:59:07 <dainanaki> great
11:59:08 <dainanaki> thanks.
12:00:16 <roconnor> If propositions are types then relations are graphs
12:00:20 <chrisdone> jonkri: there's also the nice property of sharing server-side and client-side data-types if both your server and client are in haskell
12:01:03 <dainanaki> I wouldn't mind that!
12:01:49 <thoughtpolice> i was about to say marshalling that between client/server might be interesting. then i forgot you'd just compile 'binary' to javascript anyway and be done with it :P
12:02:35 <chrisdone> yeah. any serialization lib
12:02:39 <dainanaki> hehe. it would be interesting to mess with the node.js guys by compiling yesod into js and running it on v8.
12:03:30 <dainanaki> albeit more work than it's worth.
12:03:50 <thoughtpolice> with an online optimizing native code compiler like v8, ghc generated javascript is blazing fast, i hear.
12:03:54 <chrisdone> but yeah… i might try rewriting my numbergeddon game with haskell and ghcjs. see how performant it is
12:04:30 <chrisdone> ( http://chrisdone.com/numbergeddon -- simple enough to rewrite, busy enough to reasonably test twitch performance )
12:05:25 <joe6> when I have something like this, http://pastebin.com/PBhKVctJ , the numbering is getting initialized to 1. instead of 5.
12:05:27 <mauke> The paste PBhKVctJ has been copied to http://hpaste.org/50079
12:05:32 <joe6> when I run "cabal haddock"
12:06:08 <frerich_> Hm, I have a list of 'Chip' values, e.g. [Chip {color=Red, value=Two}, Chip {color=Red, value=Three}, Chip {color=Red, value=Four}]; is there a nicer way to check that they all have the same color than using "(length $ group $ map color chips) == 1"?
12:06:31 <chrisdone> thoughtpolice: lol how fast is blazingly fast? :p
12:06:32 <dcoutts> joe6: http://haskell.org/haddock/doc/html/ch03s08.html#id566282
12:06:55 <dcoutts> joe6: that is, the number you use doesn't matter
12:07:03 <chrisdone> thoughtpolice: "not dog slow as you'd expect from a JS-based runtime"?
12:07:04 <frerich_> I tried to do something like 'let colors = map color chips in all (== head colors) colors', can that be improved even further?
12:08:10 <chrisdone> (==0) . length . nubBy (on (==) color)
12:08:15 <chrisdone> (joke)
12:08:16 <thoughtpolice> chrisdone: but but but but node.js is blazing fast thanks to v8! (i also make sure to make it faster by rewriting performance sensitive modules in C++ when necessary)
12:08:24 <chrisdone> (er, 1)
12:08:33 <chrisdone> thoughtpolice: good point. v8 is web scale
12:09:00 <thoughtpolice> chrisdone: the future is very bright and web-scaled, indeed
12:09:01 <hatds> :t all
12:09:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:09:10 <dainanaki> I'm so tired of hearing web-scale
12:09:20 <dainanaki> it's like web 2.0
12:09:26 <thoughtpolice> web 2.omg
12:09:29 <chrisdone> > (==1) . length . nubBy (on (==) fst) $ [(1,1),(1,2),(1,3)]
12:09:31 <lambdabot>   True
12:09:35 <chrisdone> > (==1) . length . nubBy (on (==) fst) $ [(1,1),(1,2),(2,3)]
12:09:37 <lambdabot>   False
12:09:40 <chrisdone> win
12:09:45 <hpaste> cebewee pasted “GHC 7.0.4 does not terminate” at http://hpaste.org/50080
12:10:08 <chrisdone> Haskell: Encouraging me to make really slow but pretty code since 2008™
12:10:24 <cebewee> does anyone have an idea why the snippet above leads GHC to non-termination?
12:10:34 <chrisdone> trim = reverse . dropWhile isSpace . reverse . dropWhile isSpace -- 4 lyfe
12:10:45 <NihilistDandy> chrisdone: You should try Agda, then
12:10:55 * chrisdone was reading an Agda tutorial last night…
12:11:11 <mauke> chrisdone: trim = join (.) (reverse . dropWhile isSpace)
12:11:35 <chrisdone> mauke: nice :D
12:11:43 <mauke> that's from my xmonad.hs
12:13:42 <chrisdone> > join (.) (subtract 5) 0
12:13:43 <lambdabot>   -10
12:13:58 <dainanaki> gotta love join over (->)
12:14:06 <chrisdone> > join (.) ((*2) . subtract 5) 0
12:14:08 <lambdabot>   -30
12:14:55 <chrisdone> nice ^
12:16:12 <dainanaki> so when I have multiple builds of ghc, is there an easy way to switch between them>
12:16:14 <dainanaki> ?
12:17:06 <hvr> dainanaki: I have multiple versions installed in /opt/ghc/<version>/
12:17:07 <chrisdone> mauke: I wonder what you call \g -> join (.) (f . g)  it has a certain -ness about it
12:17:27 <dainanaki> hvr: do you just change your PATH when you want to use a different one?
12:17:33 <hvr> dainanaki: exactly
12:17:54 <hvr> dainanaki: it's the easiest one, if you don't want to pass around --with-ghc lines
12:18:01 <sjoerd_visscher> :t \f g -> join (.) (f . g)
12:18:02 <lambdabot> sjoerd_visscher: You have 1 new message. '/msg lambdabot @messages' to read it.
12:18:02 <chrisdone> what would you call `reverse` CS-wise? a bijective function?
12:18:02 <lambdabot> forall a a1. (a1 -> a) -> (a -> a1) -> a -> a
12:18:02 <dainanaki> *sigh*, ok then. I was hoping that something akin to rvm existed.
12:18:25 <hvr> dainanaki: maybe there is...
12:18:41 <hvr> dainanaki: maybe cabal-dev has something for that
12:18:55 <dainanaki> cabal-dev is more like bundler, really
12:19:25 <dainanaki> it manages dependencies for a specific project, but doesn't really do much between versions of ghc as far as I'm aware.
12:20:23 <joe6> error: http://pastebin.com/zzVbqveQ , source: http://pastebin.com/bbz5piZj -- Any suggestions on what I am doing wrong?
12:20:26 <mauke> The pastes zzVbqveQ bbz5piZj have been copied to http://hpaste.org/50081 http://hpaste.org/50082
12:20:42 <mauke> joe6: yeah, you're still using pastebin
12:20:49 <frerich_> @pl all (== head xs) xs
12:20:49 <lambdabot> all (head xs ==) xs
12:20:54 <frerich_> Hm.
12:21:07 * chrisdone goes bed
12:21:17 <chrisdone> see you guys at camhac ^-^
12:21:25 <chrisdone> mauke: you coming?
12:21:39 <hvr> chrisdone: to bed?
12:21:46 <chrisdone> :)
12:21:47 <dainanaki> I wish that I wasn't the only Haskeller within 100 miles of where I live.
12:22:02 <joe6> mauke: is the hpaste utility working? need to figure it out and replace my pastebin utility with that.
12:23:01 <mayahustle> :dainaki I feel the same way
12:23:35 <dainanaki> whereabouts are you from?
12:23:50 <mayahustle> New Orleans
12:24:03 <hatds> let (*)=Nothing in (*)
12:24:15 <hatds> >let (*)=Nothing in (*)
12:24:16 <dainanaki> Ah. I'm currently living in the middle of nowhere, Texas.
12:25:05 <mayahustle> I was the only person at my grad school that programmed in haskell, even though the majority of the cs students their learn it briefly as part of a course
12:25:16 <kmc> dainanaki, is it anywhere near Haskell, TX
12:25:27 <dainanaki> interestingly enough, it is.
12:25:30 <dainanaki> Abilene.
12:25:30 <hatds> huh, so one can define operators of any airty, but they can only be used infix if airty >= 2
12:25:47 <mauke> hatds: ?
12:25:48 <Eduard_Munteanu> arity
12:26:01 <hatds> whoops, arity :)
12:26:12 <hatds> > let (*)=Nothing in (*)
12:26:13 <lambdabot>   Nothing
12:26:19 <hatds> > let (*)=Nothing in *
12:26:20 <lambdabot>   <no location info>: parse error on input `*'
12:26:49 <kmc> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#postfix-operators
12:26:57 <parcs> > let (!) = product . enumFromTo 0 in (5!)
12:26:59 <lambdabot>   0
12:27:07 <mauke> 1
12:27:14 <parcs> o
12:27:18 <parcs> right
12:27:46 <NihilistDandy> dainanaki: I also feel the same way
12:28:33 <dainanaki> we should start a small country.
12:28:40 <dainanaki> Haskellia.
12:28:45 <dainanaki> or something.
12:29:16 <hatds> Haskelland
12:29:34 <hatds> (the happiest place on Earth!)
12:29:46 <dainanaki> The purest place on Earth!
12:29:55 * hackagebot file-location 0.2.3 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.2.3 (GregWeber)
12:30:01 <dainanaki> Unfortunately, everybody there is kind of lazy.
12:30:06 <Eduard_Munteanu> :)
12:30:07 <joe6> when I add this line to my documentation header, haddock fails: -- >  fd <- openPort
12:30:08 <pisum> :D
12:30:21 <joe6> the error message is: doc comment parse failed:  use withPort instead of the below pattern >  fd <- openPort
12:30:31 <sm__> why unfortunately ? they don't waste their time on unnecessary work
12:30:48 <joe6> haddock error: http://pastebin.com/1XScJQf2
12:30:48 <NihilistDandy> dainanaki: But garbage collection is top notch
12:30:49 <mauke> The paste 1XScJQf2 has been copied to http://hpaste.org/50083
12:31:06 <bos> http://twitter.com/#!/parallax00/status/101012191414730753
12:31:11 <joe6> code that is causing the error: http://pastebin.com/1JJ8e1uv
12:31:12 <bos> oops
12:31:12 <dainanaki> And the curry there is great!
12:31:13 <mauke> The paste 1JJ8e1uv has been copied to http://hpaste.org/50084
12:31:19 <joe6> any thoughts, please?
12:31:37 <joe6> the haddock manual says that code blocks can be prefixed with >
12:31:44 <joe6> and that is exactly what I am doing.
12:32:10 <NihilistDandy> bos: lol
12:32:54 <NihilistDandy> joe6: You have to prefix all the code with >
12:32:59 <Eduard_Munteanu> Is that about the UK situation?
12:34:09 <joe6> NihilistDandy: i just want one comment with a line of code
12:34:10 <sm> joe6: try adding a blank -- line between 2 and 3
12:34:22 <NihilistDandy> Ah
12:34:24 <frerich_> Is there an existing function which computes the 'deltas' of a list of numbers by subtracting subsequent numbers? For instance 'deltas [1,3.10]' should yield [2,2,2,2]. I wrote a function myself, but I'm using plain old recursion and Iwonder whether some higher level function ccan be applied.
12:34:49 <joe6> sm, that was it. Thanks.
12:34:59 <sm> np
12:35:07 <rwbarton> frerich_: how about something involving zipWith
12:35:17 <mauke> > ap (zipWith subtract) tail [1, 3 .. 10]
12:35:18 <lambdabot>   [2,2,2,2]
12:35:29 * dainanaki realizes I was running make without -j4
12:35:31 <dainanaki> :(
12:36:51 <frerich_> rwbarton, mauke: Cool, I didn't realize that zipWith together with tail could be useful here!
12:39:17 <frerich_> Hm, or maybe I should have asked my real question instead: is there a better way to check that some list of Enum'erable values is ascending? E.g. [1..10] should yield True. My idea was to verify that all deltas equal 1.
12:40:12 <mustelo> frerich, some context might be helpful. why do you want to check that?
12:40:24 <frerich_> I just realized that using deltas won't help since the values in my list are not members of Num.
12:40:54 <joe6> i do not get the "Source" link (to the right of the function) when I generate the documentation with "cabal haddock". Is that something that hackage adds?
12:40:55 <bscarlet> frerich_: fromEnum will get you to Int if you've got Enum
12:40:56 <luite> frerich_: isAsc xs = let xs' = map fromEnum xs in xs' == sort xs'
12:41:03 <frerich_> mustelo: I have a list of Chip values like [Chip Yellow Two, Chip Yellow Three, Chip Yellow Four] and I want to verify that they are all the same color (I solved this) and that they are ascending.
12:41:04 <luite> if converting to Int is ok
12:41:17 <frerich_> mustelo: The 'Value' part is an Enum.
12:41:33 <mustelo> frerich, why not just derive Ord, then sort, and be done?
12:41:52 <frerich_> sort wouldn't detect gaps, would it?
12:41:58 <ion> > and . (<*>) (zipWith $ \a b -> b == succ a) tail $ [-5..10]
12:41:59 <lambdabot>   True
12:42:06 <mustelo> oh are you checking for a straight in poker or something?
12:42:11 <joe6> i think i need --source
12:42:16 <frerich_> mustelo: Yes, a different game, but same idea.
12:42:26 <dcoutts> joe6: you get it if you use cabal haddock --hyperlink-source
12:42:40 <joe6> dcoutts: cool, thanks.
12:43:03 <mustelo> frerich, then luite's idea of fromEnum and then using deltas sounds okay
12:43:49 <mustelo> frerich, if you know the length in advance you could also just check for equality of lists,
12:44:27 <bscarlet> frerich_: how about x == [head x .. last x]
12:44:37 <frerich_> ion's solution made me come up with "zipWith (\x y -> succ x == y) values (tail values)
12:44:44 <frerich_> Where 'values' is just 'map value chips'
12:44:56 * hackagebot hslogger 1.1.5 - Versatile logging framework  http://hackage.haskell.org/package/hslogger-1.1.5 (JohnGoerzen)
12:45:14 <frerich_> That gives me a list of bools suitable for 'and'.
12:45:55 <ion> «f x (g x)» *is* «(<*>) f g x». http://heh.fi/haskell/functors/#function-instance
12:46:32 <bscarlet> frerich_: it's two traversals of the list, which is inelegant, but it's quite readable...
12:47:30 <ion> > let f (x:xs) = and (zipWith (==) xs [succ x ..]) in f [-5..5]
12:47:31 <lambdabot>   True
12:48:20 <erus`> stop rioting now guys
12:48:20 <frerich_> That's funky, too.
12:48:35 <erus`> no even recognises its a riot against imperitive languages anymore
12:51:13 <ocharles> Anyone have any tips for getting 100% coverage with haddock easily?
12:51:25 <ocharles> Right now I'm doing: cabal haddock | grep 'haddock coverage' | grep -v '100%'
12:51:27 <ocharles> is that really the best way?
12:52:33 <TotoTitus> I have logged in previously on this channel, and have received help from someone called 'Qualle' or the like, does anyone know him ?
12:53:05 <roconnor> Cale?
12:53:11 <TotoTitus> not, something with Q
12:53:26 <TotoTitus> ah, my question is rather ridiculou
12:53:33 <mauke> preflex: seen quolle
12:53:33 <preflex>  quolle was last seen on #haskell 9 hours, 41 minutes and 23 seconds ago, saying: I'll do my best
12:53:47 <psysine> why doesn't "next = (1+)" work?
12:53:47 <TotoTitus> Ah! Thank you ! That's the chap, thank you very much
12:54:06 <mauke> psysine: it does
12:54:18 <ocharles> psysine: define "doesn't work"
12:54:47 <psysine> mauke, ocharles i have it in a .hs that I load in ghci
12:54:48 <azaq23> > let next = (1+) in next 3
12:54:49 <lambdabot>   4
12:55:00 <joe6> is there a better way of formatting this haddock: http://pastebin.com/gmEXvhRC, the produced output ignores the indentation..
12:55:02 <mauke> The paste gmEXvhRC has been copied to http://hpaste.org/50085
12:55:20 <ocharles> joe6: does it work with {-| -} ?
12:55:23 <ocharles> (just guessing)
12:55:38 <ocharles> joe6: oh, you probably want to surround it with @
12:55:45 <psysine> i get "No instance for (Num ([a0] -> [a0])) arising from the literal `1'"
12:55:52 <joe6> ocharles, the @ sounds a good idea.
12:56:04 <mauke> psysine: how are you using it?
12:56:08 <ion> psysine: Paste the code and the full error.
12:56:10 <ocharles> psysine: then you need to paste some code
12:56:19 <ocharles> because that's not apparent in what you mentioned before
12:57:06 <psysine> mauke, ion, ocharles: i'll try to play a bit with it....
12:57:50 <frerich_> Is there an official name for the values of an enumeration? "Values"? "Members"?
12:58:32 <dgpratt> psysine: just based on past experience, such errors are often the result of misplaced (or absent) parentheses
12:58:49 <joe6> ocharles: when I surround it with @, the .html file does not show it. I have to navigate to the source link to see it.
12:59:04 <ocharles> joe6: can you update your paste?
12:59:17 <ocharles> preferably the full file, if you can share all of that
12:59:27 <psysine> dgpratt, actually, the problem was that it was actually indirectly passed Prelude.init :P
12:59:58 * hackagebot convertible 1.0.11.0 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-1.0.11.0 (JohnGoerzen)
13:00:55 <joe6> ocharles: full file: http://pastebin.com/YddyLk9X
13:00:57 <mauke> The paste YddyLk9X has been copied to http://hpaste.org/50086
13:01:09 <joe6> ocharles, this is without the @
13:01:42 <shachaf> class Convertible?
13:01:53 <hpaste> ocharles annotated “joe” with “joe (annotation)” at http://hpaste.org/50086#a50087
13:01:55 <shachaf> Since when do type classes end in "ible" or "able"?
13:01:57 <ocharles> joe6: do you have any luck with that?
13:02:05 <ocharles> (see my annotation)
13:04:36 <shachaf> And it arbitrarily chooses that converting from Double to Int is done by truncating. :-(
13:04:49 <shachaf> There should be a lossless convertible class.
13:04:54 <joe6> ocharles: annotated file: http://pastebin.com/aT08YfZa and it is missing the module comments in the .html file
13:05:15 <ocharles> fraid I'm not sure then
13:06:16 <joe6> ocharles: html file generated: http://pastebin.com/Esv33Xv6
13:06:29 <joe6> without the comments
13:07:34 <dainanaki> is it possible to run cabal builds with any sort of parallelism?
13:09:49 <joe6> ocharles: actually, this worked.
13:09:59 * hackagebot HDBC 2.3.1.0 - Haskell Database Connectivity  http://hackage.haskell.org/package/HDBC-2.3.1.0 (JohnGoerzen)
13:10:14 <tommd> dainanaki: Not yet.
13:10:27 <dainanaki> thought so.
13:18:39 * sm wonders what "Unicode support has generally been improved across the core libraries" means
13:19:18 <sm> and "Programs may now get exceptions when writing strings in the wrong encoding to (for example) stdout.". What happened before ? junk output ?
13:19:51 <sm> oh, read on.. more details..
13:22:16 <lysgaard> Is it possible to serialize functions in haskell? Does it make sense at all?
13:24:08 <Eduard_Munteanu> lysgaard: it does, though AFAIK it's not implemented
13:24:17 <int-e> In theory that could work nicely, but I'm not aware of any Haskell implementation that supports it.
13:25:30 <lysgaard> How would one do that?
13:25:45 <fergie_> I'm trying to make a typeclass. Is there some way to refer to the data constructor for a type?
13:25:50 <int-e> (It becomes really hard once you have a compiler erasing type information and also when generating machine code.)
13:27:32 <fergie_> eg. if I have "type MyType a where" how do I refer to the data constructor for a?
13:29:06 <zhulikas> how can I take 10 last elements of a list?
13:29:23 <zhulikas> all I can think of is take 10 $ reverse $ myList
13:29:36 <zhulikas> whoops...
13:29:36 <int-e> lysgaard: Basically the same way that garbage collection works - start with some partial application on the heap (representing the function) and copy it somewhere else. It may even work that way based on ghc's runtime *if* the compiled program is the same on both ends. If you want something more flexible, ghc is probably a bad place to start.
13:29:50 <zhulikas> take 10 (reverse myList)
13:30:13 <fergie_> zhulikas: that is how I would do it
13:30:18 <zhulikas> but that's quite expensive
13:30:36 <lysgaard> zhulikas: Lists are linked Lists, they are expensive.
13:30:39 <sm> that's lists for you...
13:30:43 <int-e> lysgaard: Which is sad because in theory it should be really pretty, thanks to purity (so you can simply copy all code and data associated with a function without having to worry that it maintains some state ...)
13:30:44 <zhulikas> I have a list of 3001 elements
13:31:07 <fergie_> zhulikas: I might be wrong here, but to get to the end of a normal list all elements have to be evaluated. So however you get the last 10, you'll have to go through all of them
13:31:24 <zhulikas> ok then.
13:31:35 <fergie_> zhulikas: there might be other data types that are better. Maybe arrays?
13:31:52 <fergie_> I hope someone will jump in if I'm talking crap here
13:31:52 <lysgaard> zhulikas: Data.Vector has O(1) access, maybe it could be used instead in your code.
13:31:55 <zhulikas> oh it's ok. I just solved http://projecteuler.net/index.php?section=problems&id=48
13:32:05 <zhulikas> and wanted to think of any other way to get 10 last elements
13:32:07 * int-e wonders how erlang does it.
13:32:12 <mizu_no_oto> If I were to implement an interpreter for  small functional language, what primitives would I need to implement to get an IO monad?
13:32:31 <mizu_no_oto> Err, to implement an IO monad
13:32:47 <mizu_no_oto> Other than the obvious constructor and case statements
13:33:35 <mrsolo> hmm any decent haskell book after 'learn you a haskell for great good?'
13:34:32 <Eliel> mrsolo: real world haskell is pretty commonly suggested book.
13:34:44 <mrsolo> oh in term of publishing date
13:34:47 <fergie_> mrsolo: I liked real world haskell
13:34:52 <mrsolo> real world haskell came before
13:35:28 <mizu_no_oto> You mean "are there any good haskell books more recent than LYAH"
13:35:40 <mrsolo> basically  'good' is important
13:36:16 <ocharles> anyone know if jeremy from seereason hangs out here, and if so by which alias?
13:38:31 <lysgaard> int-e: Yeah, sending functions should not be hard in Haskell, they are pure after all. Does there exist some eval function that could take source code and load it as new functions?
13:39:29 <sm> ocharles: you'll find him in #happs
13:40:08 <ocharles> excellent, thank you
13:40:18 <ocharles> sm: as 'jeremy'?
13:40:42 <sm> ask in there.. I don't want to blow his cover, you might be from the irs...
13:40:51 * ocharles is fullof evil
13:40:59 <sm> j/k
13:41:19 <lysgaard> int-e: Look at this: http://hackage.haskell.org/packages/archive/plugins/1.5.1.4/doc/html/System-Eval-Haskell.html
13:41:33 <int-e> lysgaard: not really (in ghc). but see packages like  hint  or, as you mention, plugins.
13:41:49 <tommd> preflex: seen nmitchell
13:41:49 <preflex>  Sorry, I haven't seen nmitchell
13:41:51 <tommd> preflex: seen ndm
13:41:51 <preflex>  ndm was last seen on #haskell 233 days, 1 hour, 52 minutes and 6 seconds ago, saying: if you don't, then there was a parse error
13:42:23 <sm> tommd: there's a guy I'd like to talk to
13:42:23 <tommd> Well, chances are high he'll return soon now that he's been going for that duration.
13:42:42 <int-e> lysgaard: they essentially use the ghc compiler to compile the code, then load the object code using the RTS' linker, and execute it. So it's quite involved.
13:42:48 <tommd> sm: Are you porting hoogle?
13:42:58 <sm> nope, just using cmdargs
13:43:03 <tommd> ahh
13:43:40 <thoughtpolice> plugins is a bit of a magic hack that works inside the GHC linker in order to load things at runtime. as int-e said there's actually quite a bit of infrastructure needed to make that work. the cloud haskell stuff proposes a GHC extension that would allow the serialization of certain kinds of 'static' functions, but nobody is working on this, as far as I can tell
13:44:18 <Saizan> ghc-eden or whatever is called does have this working
13:44:31 <thoughtpolice> people are still working on that?
13:45:07 <Saizan> no idea
13:45:49 <Saizan> last patch i see is from march 25, but this is a darcs repo
13:46:47 <thoughtpolice> also with function serialization you quickly hit some tough decisions. there was a big mailing list discussion about this a while back with a lot of opinions
13:47:40 <thoughtpolice> someone else also did independent research on 'checkpointable' haskell so you could checkpoint executable states and restart them later, and part of that required the ability to serialize things like functions
13:47:45 <thoughtpolice> i can't remember who did that, though
13:50:03 <int-e> thoughtpolice: Do you remember any details? Did they try to make it work across recompilations, or was it essentially a (major) garbage collection followed by writing the new heap space to a file?
13:50:05 * hackagebot HDBC-sqlite3 2.3.3.0 - Sqlite v3 driver for HDBC  http://hackage.haskell.org/package/HDBC-sqlite3-2.3.3.0 (JohnGoerzen)
13:50:38 <lysgaard> int-e: I see, but it seems possible, but maybe not productive.
13:53:01 <Saizan> what's a true pain for serialization is if your functions are closing over mutable references or file handles
13:53:08 <lysgaard> Is it possble to install ghc from cabal-install? I have ghc from Ubuntu right now.
13:53:22 <Saizan> no, you can't
13:53:27 <dainanaki> nope
13:53:29 <int-e> lysgaard: I think it's a hard problem. Imagine you have to Data.Map clones with the same underlying data type but which treat left and right subtrees in opposite ways. Should, those types, for the purpose of serialization, be identical? What about different versions of the same implementation? What if you serialize an 'insert' from such a Map implementation, and later deserialize it in a program with a new version?
13:53:37 <int-e> s/to/two/
13:53:43 <dainanaki> lysgaard: you'll have to check it out from source and build it.
13:53:55 <dainanaki> or install the haskell platform
13:54:05 <dainanaki> which is probably what you want.
13:54:07 <tommd> lhc was on Hackage for a time though
13:54:07 <Saizan> or rather you can just use the ghc binaries from the download page
13:54:25 <Saizan> ?hoogle ghc download
13:54:26 <lambdabot> No results found
13:54:30 <Saizan> ?google ghc download
13:54:31 <lambdabot> http://www.haskell.org/ghc/download
13:54:31 <lambdabot> Title: The Glasgow Haskell Compiler
13:54:58 <tommd> ghc download :: URL -> IO Tarball
13:55:06 * hackagebot HDBC-odbc 2.3.1.0 - ODBC driver for HDBC  http://hackage.haskell.org/package/HDBC-odbc-2.3.1.0 (JohnGoerzen)
13:56:45 <applicative> well golly, -fllvm works with ghc-7.2 on my mac
13:56:46 <thoughtpolice> int-e: i can't remember. if i find the paper i'll link you
13:56:51 <int-e> lysgaard: It's much easier if you insist on the program to be unchanged between serialization and deserialization but even that doesn't eliminate all these problems, although it does become a lot easier (you can rely on data representation to be the same, you can rely on function pointers to the compiled code (up to address space randomization, possibly)
13:57:24 <thoughtpolice> tommd: that's because LHC managed to be a cabal package only thanks to a god-awful amount of atrocious Setup.hs hackery I whipped up a few years ago :)
13:57:49 <tommd> And what a good job it was!
13:58:09 <tommd> How is LHC doing in its current state?  Happy with the to/from extcore route?
13:58:31 <coppro> LHC?
13:58:50 <tommd> http://lhc.seize.it/
13:58:51 <thoughtpolice> neither me nor lemmih have worked on it very recently. other things have been afoot. now that plugins just got released with GHC 7.2, i've played with the idea of moving the compiler to a plugin somehow
13:59:05 <thoughtpolice> (well, at least i haven't done much recently, i won't speak for lemmih but just assume)
13:59:42 <tommd> Ahh, to have 50 hours x 20 weeks to work on that!
13:59:59 <thoughtpolice> tommd: the external core route worked but it was part of the reason we needed so much hackery in the interface and cabal infrastructure. we had to bundle versions of base/integer/etc we were compatible with and compile those as an ad-hoc after setup, register all the core files, etc. we also had to probe GHC in order to get proper compilation flags etc
14:00:09 * hackagebot HDBC-postgresql 2.3.2.0 - PostgreSQL driver for HDBC  http://hackage.haskell.org/package/HDBC-postgresql-2.3.2.0 (JohnGoerzen)
14:00:10 <roconnor> Is there a name for meet-semilattice enriched categories or lattice enriched categories?
14:00:15 <thoughtpolice> i also had to do a crazy amount of hackery to get the frontend executable to work 'as close as possible' to GHC with minimal intervention
14:00:32 <thoughtpolice> (part of this included copying part of GhcMain.hs out of the source tree and heavily modifying it. oh man...)
14:00:32 <ocharles> How do I document things generated by template haskell?
14:00:44 <ocharles> I get an error about duplicate type signatures if I try to write the signature myself
14:00:54 <tommd> thoughtpolice: Wow, I didn't know it was such a production.
14:01:02 <tommd> Fragile sounding.
14:01:06 <thoughtpolice> tommd: i think for a POC the external core approach worked pretty well. but yeah, making it remotely usable was quite high maintenance
14:01:10 <thoughtpolice> and yes, really fragile
14:01:22 <tommd> POC?
14:01:25 <thoughtpolice> proof of concept
14:01:31 <tommd> ahh
14:01:59 <thoughtpolice> for the past week or two though like I said i've been throwing around the idea of using a compiler plugin to re-implement it. i think it would be doable, although GHC plugins don't really give you much infrastructure to write a backend
14:02:09 <thoughtpolice> (not like we had any infrastructure to write a backend, anyway :P)
14:03:53 <tommd> I'm interested in that path.  Will you be keeping things public (blogs, repos, etc)?
14:05:23 <lysgaard> int-e: The reason I'm asking for serialization of haskell is that I'm thinking of a typed haskell file system, where all files, actually are haskell functions. A fun thought experiment, but not anything I think I could make.
14:13:44 <eddayyy> hello, i made a library, anyone interested in a snap riak extension?
14:13:54 <eddayyy> would be nice to get feedback
14:14:23 <mm_freak_> eddayyy: i recommend to send to the -cafe list
14:14:45 <eddayyy> mm_freak_: whats that?
14:14:53 <mm_freak_> eddayyy: the haskell-cafe mailing list
14:14:57 <Eduard_Munteanu> @google haskell-cafe
14:14:58 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
14:14:58 <lambdabot> Title: Haskell-Cafe Info Page
14:15:10 * hackagebot blaze-textual 0.2.0.4 - Fast rendering of common datatypes  http://hackage.haskell.org/package/blaze-textual-0.2.0.4 (BryanOSullivan)
14:15:18 <eddayyy> mm_freak_: okay sure
14:15:33 <jerji> i think that's the first hackagebot message i've seen since i started lurking here that wasn't from edwardk
14:15:41 <Eduard_Munteanu> Heh.
14:15:51 <mm_freak_> lol
14:15:59 <mm_freak_> apropos edwardk
14:16:30 <mm_freak_> does anyone know of a library, which implements various fast pointed comonadic stores?
14:17:11 <mm_freak_> comonad-extras only provides an Array-based store
14:17:43 <mm_freak_> i would like to have also Map, IntMap, Vector, etc.
14:19:17 <roconnor> mm_freak_: maybe http://hackage.haskell.org/packages/archive/representable-functors/2.0.0.5/doc/html/Control-Comonad-Representable-Store.html
14:20:43 <NihilistDandy> > (((*).).(.(*))) 2 90 3
14:20:45 <lambdabot>   6
14:21:08 <roconnor> mm_freak_: I guess part of the problem is that Maps are not really fixed shaped functors.
14:21:15 <NihilistDandy> > (((*).).(.(*))) 2 60000 3
14:21:16 <mm_freak_> roconnor: thanks, but i'm specifically looking for actual physical data structures, not functions
14:21:17 <lambdabot>   6
14:21:32 <roconnor> mm_freak_: representable functors are usually physical data structures.
14:21:45 <mm_freak_> roconnor: the one you linked is a function
14:22:15 <roconnor> mm_freak_: I don't think so
14:22:22 <roconnor> data StoreT g w a = StoreT (w (g a)) (Key g)
14:22:36 <mm_freak_> uhm
14:22:45 <mm_freak_> somehow my brain added an arrow there
14:22:48 <mm_freak_> ok, sorry
14:22:59 <mm_freak_> would you mind explaining why exactly it has to have a fixed shape?
14:22:59 <roconnor> maybe you were looking at the store function
14:23:37 <roconnor> mm_freak_: that is a fair question.  I know that having a fixed shape is sufficent.  I haven't thought about necessary.
14:24:02 <roconnor> mm_freak_: I'm inclined to flip the question around and for you to show that a unfixed shape functor can be a comonadic store.
14:24:40 * roconnor ponders this
14:25:15 <roconnor> mm_freak_: I'm worried that duplicate won't really work out unless the shape is fixed.
14:25:25 <mm_freak_> roconnor: i think that a non-fixed-shape functor would amount to a partial function in the function-based store
14:25:58 <mm_freak_> true
14:26:24 <mm_freak_> i wonder what duplicate is supposed to do for a store…  it returns a store of stores…
14:26:58 <roconnor> mm_freak_: it creates a collection of stores that have the same contents, but with the selected location moved about.
14:27:10 <mm_freak_> i see
14:27:22 <mm_freak_> let me try something
14:28:17 <roconnor> Hmm, since comonadic operations doen't really fiddle with the shape of the container, maybe there is no problem with duplicate.
14:29:40 <Saizan> in a total language to write extract you'd also need a proof that the (Key g) in the store is valid for the shape of the current structure in it
14:29:40 <roconnor> I guess pointed lists are an example of a store-like comonad without a fixed shape container.
14:30:11 * hackagebot openpgp 0.1 - Implementation of the OpenPGP message format  http://hackage.haskell.org/package/openpgp-0.1 (StephenWeber)
14:31:01 <mm_freak_> Saizan: that wouldn't be a problem in my use case
14:31:02 <Saizan> and i guess the zipper comonad is essentially a roundabout way to solve that
14:31:05 <roconnor> Saizan: right, so the problem isn't with the comonad operations, it with the pos and peek operations.
14:31:16 <thoughtpolice> tommd: totally! if i do any work on it i'll be sure to let people know (probably through /r/haskell, although I guess i could request to add my blog to planet haskell too.)
14:31:25 <roconnor> mm_freak_: I think if your container changes shape then it isn't really a Store anymore.
14:31:38 <mm_freak_> roconnor: it doesn't
14:31:54 <mm_freak_> i really just want to generalize away from Array to try the performance of different data structures
14:32:02 <mm_freak_> the comonadic operations are exactly what i need
14:32:09 <roconnor> yep
14:32:17 <roconnor> not every comonad is a store :)
14:32:17 <thoughtpolice> or the LHC blog if i can even remember my login to it :P
14:32:37 <mm_freak_> sure, but i can generalize to ComonadStore =)
14:32:57 <ocharles> Hey, I'm trying to understand the ShowURL class at http://hackage.haskell.org/packages/archive/web-routes/0.25.2/doc/html/Web-Routes-RouteT.html#t:ShowURL
14:33:00 <ocharles> what does "associated types" mean?
14:33:06 <roconnor> mm_freak_: what happens when you try to peek out of your array bounds?
14:35:47 <jensonbu> Hello. I have a mysterious head [] error that i'm trying to find the cause of. I followed the instructions in http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging to use -xc, but i don't get any kind of call stack, just "<GHC.List.CAF>seq: Prelude.head: empty list". which isn't really any more use. what else can i do?
14:36:14 <joe6> is there a better way of doing this: http://pastebin.com/dQxyKpc3
14:36:16 <mauke> The paste dQxyKpc3 has been copied to http://hpaste.org/50089
14:36:23 <mm_freak_> roconnor: bottom
14:36:32 <mm_freak_> but in my application that happens only when there is a bug
14:37:13 <roconnor> okay
14:37:32 <roconnor> mm_freak_: then you just need to use representable stores =)
14:37:59 <mm_freak_> unfortunately i'm unable to find any useful Representable instances, even though the library depends on 'array' and 'containers'
14:38:04 <mm_freak_> that's weird
14:38:19 <mm_freak_> perhaps i'm misunderstanding something
14:38:23 <roconnor> mm_freak_: well, you understand why people haven't made them right?  There is that issue with bottoms and out of band values.
14:38:59 <roconnor> mm_freak_: If someone made Maps into representable functors then PHP programmers would come in and abuse it.
14:39:18 <mm_freak_> i can totally see your point, but what to do about it?
14:39:27 <mm_freak_> is there any comonad-like concept for this?
14:39:31 <tommd> thoughtpolice: Great!  I'll keep my eye out.
14:39:59 <roconnor> mm_freak_: I think you need to newtype wrap up your Map and build turn it into an abstract data type and use smart constructors to make sure that no "bugs" can occur.
14:40:26 <mm_freak_> yeah, perhaps
14:40:49 <roconnor> mm_freak_: maybe edwardk or someone else has a better idea
14:41:31 <roconnor> joe6: use the Data.Time library instead?
14:41:40 <mm_freak_> well, i actually want this only to test the speed of different data structures
14:41:41 <joe6> roconnor: thanks, will check it out.
14:42:07 <roconnor> mm_freak_: even more reason to use abstract data types.
14:42:09 <sonoflilit> I have lazy IO troubles
14:42:20 <mm_freak_> joe6: there is a type for that
14:42:23 <mm_freak_> NominalDiffTime
14:42:24 <sonoflilit> seems like IO is lazy where I don't want it to be
14:42:32 <sonoflilit> how can I force strictness of an hPut?
14:42:33 <mm_freak_> joe6: it's defined in Data.Time.Clock
14:42:48 <mm_freak_> sonoflilit: hPut is strict
14:43:01 <Saizan> sonoflilit: it has nothing to do with laziness, it's just your OS buffering writes
14:43:07 <joe6> i am not worried about the difference in times. I want to store a time period: http://pastebin.com/984hHXnb
14:43:07 <Saizan> sonoflilit: use hFlush
14:43:12 <mauke> The paste 984hHXnb has been copied to http://hpaste.org/50090
14:43:14 <mm_freak_> sonoflilit: all put operations are strict, in fact, since they need the data to, well, "put" it =)
14:43:15 <realannoyingoran> hey hey adimit
14:43:19 <sonoflilit> Saizan: that sounds right, thanks
14:43:29 <Peaker> is hPut implemented on top of FILE * rather than POSIX fd's directly?
14:43:34 <joe6> mm_freak_, and I do not want to store it as an Integer.
14:43:39 <realannoyingoran> :(
14:43:41 <TotoTitus> Man, at work i have to work with stupid technologies, and my boss cares only about getting the job done, not actually writing good code; seeing everyone here so interested in actually interesting stuff is so refreshing
14:43:44 <sonoflilit> mm_freak_: what I meant by "lazy" is that the next operation happened before this one was done
14:43:51 <Peaker> Saizan: bufering is just the c stdlib (FILE*), not the OS, afaik
14:43:53 <Saizan> or if not the OS it might be GHC's RTS
14:43:55 <joe6> mm_freak_, does that make sense?
14:43:56 <mm_freak_> joe6: the word "diff" may be misleading there
14:44:03 <Saizan> or whatever in the middle
14:44:44 <mm_freak_> joe6: NominalDiffTime encodes a time delta…  a current time + a time delta would give you an absolute time interval, where a sole NominalDiffTime gives only the interval length
14:45:00 <singpoly1a> I'm building my first cabal package, and I just uploaded it to Hackage, but the haddock does not appear.  Do I have to do something special to get Hackage to generate haddock?
14:45:08 <Peaker> Well, with the POSIX module, you can represent absolute times with NominalDiffTime
14:45:19 <dcoutts> singpoly1a: just wait
14:45:20 <Peaker> (The POSIX way..)
14:45:21 <mm_freak_> joe6: + the interval direction, of course…  NominalDiffTime can also be negative
14:45:41 <singpoly1a> dcoutts: oh?  it just takes awhile?
14:46:07 <mm_freak_> singpoly1a: it takes a few hours usually…  the documentation is rebuilt at fixed intervals
14:46:22 <singpoly1a> mm_freak_: ah, ok.  that makes sense, then :)
14:46:23 <joe6> mm_freak_, i think i understand what you said. let me try it.
14:47:35 <mm_freak_> joe6: reviewing your code, NominalDiffTime is really just an abstract variant of what you wrote
14:48:14 <TotoTitus> seen qualle
14:48:31 <joe6> mm_freak_: it appears so. Thanks for guiding me to it.
14:49:50 <roconnor> joe6: perhaps you want DiffTime instead
14:50:00 <roconnor> http://www.haskell.org/ghc/docs/6.12.3/html/libraries/time-1.1.4/Data-Time-Clock.html#t%3ADiffTime
14:50:21 <roconnor> joe6: there is a subtle difference between NominalDiffTime and DiffTime and it is important to get it right.
14:50:38 <roconnor> joe6: but if you are insterested in nanoseconds, then DiffTime is probably what you want.
14:50:46 <mm_freak_> ok, let me get this straight…  there is no problem with dynamic-shape data structures as comonads within the comonadic framework itself…  it's really just constructing and seeking, which is the problem, right?
14:50:54 <hpaste> osaunders pasted “show instance with ~ preceding” at http://hpaste.org/50091
14:51:01 <joe6> roconnor: ok, thanks for the help. i will stick with DiffTime.
14:51:26 <osaunders> Oh wow an hpaste bot, nifty
14:51:30 <roconnor> joe6: DiffTime used Fixed Precision numbers with a resolution of 1 pico second.
14:52:03 <mm_freak_> so it's essentially the inverse problem of monads and extraction…  while it's safe to get stuff out of a comonadic structure, it's unsafe to put something in…  just like it's safe to get stuff into a monadic structure, but unsafe to get something out
14:52:49 <mm_freak_> do i understand this right?
14:53:05 <roconnor> joe6: if you don't want to deal with absolute time for anything, you can also just directly use Pico from http://www.haskell.org/ghc/docs/7.0.1/html/libraries/base/Data-Fixed.html#t:Pico
14:53:10 <roconnor> joe6: (or Nano)
14:56:49 <joe6> roconnor, the Data.Fixed is very interesting. it is good to know about Pico and Nano.
14:57:37 <roconnor> joe6: DiffType is just a newtype wrapper around Pico
14:57:53 <roconnor> *DiffTime
14:58:13 <joe6> oh, ok.
14:59:57 <osaunders> case statements are great, why did I never realize this
15:00:26 * roconnor dislikes case statements
15:00:36 <roconnor> maybe I'm missing out on something
15:01:11 <osaunders> roconnor: See my hpaste, without case you would have to duplicate the function name lots of times
15:02:05 <roconnor> osaunders: I think duplicating the function name enhances readability a tiny bit.
15:02:48 <roconnor> osaunders: I don't know of a less duplicated way of doing that without resorting to something like Template Haskell.
15:03:09 <osaunders> Each to their own I guess
15:03:18 <osaunders> OK, I’ll just have to live with it I guess
15:03:44 <roconnor> osaunders: I do something similar with http://hackage.haskell.org/packages/archive/colour/2.3.1/doc/html/src/Data-Colour-Names.html#readColourName
15:04:07 <NihilistDandy> djahandarie: I just realized that you're on bash.org
15:04:23 <osaunders> roconnor: Hm yeah, that’s a bit of a bummer
15:04:43 <osaunders> roconnor: Do you generate that with TH?
15:05:21 <roconnor> osaunders: Nope. By regular expressions.
15:05:31 <roconnor> osaunders: oh I guess in my case it is a little imperfect too.
15:05:33 <roconnor> i.e.
15:05:36 <roconnor> readColourName "gray" = return gray
15:05:43 <roconnor> no wait
15:05:47 <roconnor> that is the same
15:05:50 <roconnor> nevermind then
15:05:56 <osaunders> You could factor out the return pretty easily BTW
15:06:07 <roconnor> osaunders: the last case don't use return
15:06:35 <osaunders> I don’t think that’s a problem
15:06:55 <osaunders> Oh maybe it is
15:06:58 <osaunders> OK, nm
15:07:42 <djahandarie> NihilistDandy, yep, that's me.
15:07:51 <NihilistDandy> Classy
15:08:11 <alpounet> oh my
15:08:38 <alpounet> djahandarie, just saw your 'flow' on bash.org :P
15:10:14 <joe6> roconnor: this is what I ended up with: http://pastebin.com/RixgAV80 . I am wondering if there is a smarter way of defining functions as millisecondsToDiffTime, nanoSecondsToDiffTime, without explicitly putting each function down..
15:10:18 <mauke> The paste RixgAV80 has been copied to http://hpaste.org/50093
15:10:29 <djahandarie> alpounet, :)
15:10:37 <joe6> roconnor: i could create a class ToPico and add Nano, Micro and all those as instances.
15:10:45 <djahandarie> A little outdated though. It was years before I had even heard of Haskell
15:10:54 <joe6> roconnor: wondering if there is a better way than that.
15:12:46 <aavogt> osaunders: you could use  newtype Symm = Symm Sym, define   Sym ... deriving Show,   then   instance Show Symm where show (Symm a) = '~':show a
15:13:28 <joe6> roconnor: something like this: timePeriod :: HasResolution a => Fixed a Integer -> DiffTime
15:13:32 <aavogt> that's probably more inconvenience than just writing it out
15:13:57 <osaunders> aavogt: It is going to get longer
15:15:09 <osaunders> Hm, I don’t think that’s good enough reason but a cool idea nonetheless
15:15:11 <nyingen> on a debian system with ghc7, where are the docs for the base libs likely to be found?
15:15:38 <gigamonkey> How possible is it to introspect Haskell's data definitions? I.e. if I have a bunch of data types defined, could I, say, write a Haskell program that generates some sort of structured representation of those data types?
15:15:41 <aavogt> probably the shortest is to make a new class for pretty-printing (with    instance Show a => PP a where pp = show, if you have so many types with that kind of instance)
15:16:38 <aavogt> gigamonkey: there are a couple ways, say template-haskell or classes like Data or Typeable (whose instances ghc can write for you)
15:16:42 <monochrom> oh w00t, new ghc version 7.2.1
15:17:25 <aavogt> gigamonkey: but maybe what you're looking to accomplish with introspection can be done more easily with other language features
15:18:17 <gigamonkey> Well, what I'm thinking of is, suppose I've written a bunch of data types in Haskell because it's a great way to express data types.
15:18:29 <gigamonkey> Now I want to generate some code in another language to represent those data types.
15:18:46 <joe6> @hoogle Fixed a -> Integer
15:18:47 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:18:47 <lambdabot> Prelude id :: a -> a
15:18:47 <lambdabot> Data.Function id :: a -> a
15:18:59 <gigamonkey> How do I go about that?
15:19:44 <monochrom> onoes, and 7.2.x is intended to be short-lived
15:20:07 <applicative> nyingen: not debian, but mine are in /usr/local/share/doc/ghc/html/libraries/
15:20:32 <applicative> nyingen: I think the docs are a separate debian package
15:21:16 <applicative> nyingen: right like this http://packages.debian.org/sid/ghc-doc
15:21:34 <mekeor> i'd like to learn how to use the gnuplot package, but i can't find a documentation anywhere… is there one at all?
15:21:36 <Saizan> how short lived?
15:21:38 <nyingen> I installed ghc-doc, but I cant' find any docs other than those for ghc itself
15:21:50 <nyingen> I need the docs for the packages it comes with. base, etc
15:22:28 <joe6> @hoogle Micro -> Integer
15:22:29 <lambdabot> Data.Fixed resolution :: HasResolution a => a -> Integer
15:22:29 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:22:29 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
15:23:00 <monochrom> 7.4.x to come out right after icfp
15:23:07 <joe6> how can I convert a Fixed to Integer?
15:23:36 <roconnor> joe6: toInteger?
15:23:41 <kmc> :t floor
15:23:42 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:23:45 <roconnor> oh right
15:23:54 <roconnor> round
15:24:04 <roconnor> or floor
15:24:10 <kmc> "how do i convert A to B" is another way to ask "pick a function of type A -> B"
15:24:20 <monochrom> const 0
15:24:27 <roconnor> @hoogle Fixed a -> Integer
15:24:27 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:24:27 <lambdabot> Prelude id :: a -> a
15:24:28 <lambdabot> Data.Function id :: a -> a
15:24:37 <roconnor> kmc: unsafeCoerce!
15:24:41 <kmc> obviously
15:25:02 <roconnor> ... I kinda feel that the Unsafe module should be removed from lambdabot's hoogle =)
15:25:57 <Eduard_Munteanu> > unsafeCoerce (5 :: Word8) :: Int
15:25:58 <lambdabot>   Not in scope: `unsafeCoerce'
15:26:06 <monochrom> unsafeCoerce has its place. if you want to force the asker to refine his/her question, you can answer unsafeCoerce initially
15:26:28 <joe6> roconnor: http://pastebin.com/DrTGxtxD , just wanted to show you the direction I am headed in.
15:26:30 <mauke> The paste DrTGxtxD has been copied to http://hpaste.org/50094
15:29:20 <roconnor> joe6: well, I'm not sure what your goals are.  This sort of looks like unnecessary functionality to me, but it is hard to say for sure.
15:30:25 <roconnor> joe6: I'd write nanoseconds :: Integer -> DiffTime; nanoseconds  x = picoseconds (1000*x)
15:30:32 <Cale> joe6: You know about Data.Fixed right?
15:30:37 <roconnor> joe6: and then use it as (25 `nanoseconds`)
15:30:51 <Cale> It looks like you're reimplementing Data.Fixed, only with time.
15:30:56 <roconnor> similarly for microseconds and milliseconds.
15:31:34 <Cale> Errr... you're even importing Data.Fixed
15:31:36 <Cale> I don't understand.
15:31:43 <Cale> Why not just use that? :)
15:32:24 <Cale> oh, you want to be able to represent fixed precision times at different scales in the same type.
15:32:29 <Cale> But still...
15:32:38 <joe6> @hoogle nanoseconds
15:32:38 <lambdabot> No results found
15:33:07 <roconnor> nanoseconds  x = picoseconds (1000*x)
15:33:10 <joe6> Cale, i cannot find the function nanoseconds
15:33:12 <roconnor> or if you like
15:33:21 <roconnor> nanoseconds  x = ((1000*x) `picoseconds`)
15:33:22 <monochrom> DiffTime and NominalDiffTime are in fact newtypes over Data.Fixed.Pico
15:33:23 <joe6> unless, I define it as roconnor says.
15:33:29 <Cale> I never said there was such a function...
15:33:48 <Cale> (roconnor is talking about nanoseconds which he defined though)
15:34:58 <HugoDaniel> 6 reasons to use haskell:
15:35:02 <HugoDaniel> 1. purity
15:35:09 <HugoDaniel> 2. immutable datatypes
15:35:13 <HugoDaniel> 3. lazyness
15:35:17 <monochrom> <3 more lines>
15:35:17 <HugoDaniel> 4. first-class functions
15:35:22 <HugoDaniel> :)
15:35:27 <HugoDaniel> i can tstop now
15:35:29 <HugoDaniel> ok
15:35:31 <HugoDaniel> so 5
15:35:37 <monochrom> you can use 1 line.
15:35:40 <HugoDaniel> hmm
15:35:44 <HugoDaniel> wait let me finish first
15:35:48 <HugoDaniel> so 5
15:35:57 <HugoDaniel> 5 closures
15:36:15 <HugoDaniel> 6 static datatypes with inferring from the compiler
15:36:18 <HugoDaniel> :)
15:36:29 <HugoDaniel> monochrom: how could you sum these into 1 ?
15:36:47 <applicative> nyingen: sorry I vanished, I have /usr/share/doc/ghc/html/libraries/base-4.3.1.0/GHC-IO-Buffer.html for example
15:37:01 <roconnor> first-class functions and closures?
15:37:11 <monochrom> 6 reasons to use haskell: 1. purity; 2. immutable datatypes; 3. laziness; 4. first-class functions; 5. closures; 6. static inferred types
15:37:17 <monochrom> (is that so hard?)
15:37:22 <HugoDaniel> :D
15:37:22 <HugoDaniel> ah
15:37:23 <HugoDaniel> sorry
15:37:34 <mekeor> Does anybody in here know where i can find a description (tutorial, docs or sth) on Graphics.Gnuplot ?
15:37:40 <aavogt> gigamonkey: I think if you use -XDeriveDataTypeable, there are methods in the Data class to say write a C struct for each haskell constructor appearing in  Data.Tree.Tree
15:38:14 <joe6> roconnor: something like this: http://pastebin.com/JyqTc7kj
15:38:16 <mauke> The paste JyqTc7kj has been copied to http://hpaste.org/50095
15:38:38 <joe6> to reuse the resolutions already defined in Data.Fixed.
15:39:02 <gigamonkey> aavogt: I see.
15:39:08 <gigamonkey> Sort of.
15:39:25 <roconnor> joe6: again I don't know what you are really trying to accomplish.
15:39:27 <aavogt> I mean there are some methods you can use to write that code
15:39:30 <gigamonkey> But could I get at the underlying information if I wanted to generate something else?
15:39:36 <Operator> ----------------------
15:39:42 <Operator> how may i help you
15:39:52 <HugoDaniel> roconor, by closures i meen using variables from a function that was defined previously
15:39:58 <HugoDaniel> you know, like in >>=
15:40:12 <HugoDaniel> something like the scheme environments, but not so much
15:40:13 * hackagebot splot 0.2.2 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.2.2 (EugeneKirpichov)
15:40:15 <aavogt> gigamonkey: you mean to access however ghc stores the data?
15:40:16 <HugoDaniel> eh, im drunk :/
15:40:17 <mekeor> Operator: you could say me how to use Graphics.Gnuplot  =)
15:40:21 <roconnor> joe6: I presume all you need is a data type of high precision time periods, and you have that with DiffTime.  No need to write any of these functions.
15:40:57 <gigamonkey> aavogt: I'm not sure what I mean. ;-) In Java if I had defined a bunch of classes I could use reflection to find out all about them (their names, their fields, methods, the types of those things, etc.)
15:41:10 <Operator> How to create a smily face 1.: 2.) 3.:)
15:41:13 <gigamonkey> I'm wondering if there's any similar facility in Haskell.
15:41:18 <mekeor> Operator: i need simple examples or sth like that
15:41:47 <Operator> i am sorry but that is not avalible in chat, you can look it up on google.
15:42:55 <Operator> anything else?
15:42:56 <joe6> roconnor: i have lots of these timePeriods, that I want to use in a haskell program. http://pastebin.com/YEGxGdPu
15:43:05 <applicative> mekeor, have you seen the file Demo.hs inside the gnuplot package?  http://code.haskell.org/gnuplot/src/
15:43:08 <mauke> The paste YEGxGdPu has been copied to http://hpaste.org/50096
15:43:10 <aavogt> gigamonkey: Data and Typeable let you do those things, but say only for monomorphic types ex. [Int] and not [a]
15:43:36 <aavogt> but that's probably not a restriction that's going to hurt your application?
15:44:03 <roconnor> joe6: ya, I'd just write that tPGC = (100 `nanoseconds`) with my definition of nanoseconds.
15:44:09 <Operator> welcome to chat, how may i assist you?
15:44:34 <mekeor> applicative: cool! thanks so far. :]  do i have this file on my computer, too (i installed the package with "cabal install -fbuildExamples gnuplot")?
15:44:45 <gigamonkey> aavogt: well, my application is largely hypothetical at the moment so, no.
15:45:04 <gigamonkey> I'm just trying to understand some stuff. Thanks.
15:45:19 <applicative> mekeor, funny it should have built them  I notice the file doesn't compile unless you strike a couple things, it's clearly meant to build as you did
15:45:19 <Operator> why is that gigamonkey?
15:45:26 <mauke> Operator: hello!
15:45:29 <joe6> roconnor: something like this: http://pastebin.com/hMKRynCd
15:45:41 <Operator> how may i help you mauke
15:45:49 <mauke> Operator: do you have a haskell question?
15:45:56 <applicative> oh mekeor, I do have an executable gnuplot-demo in .cabal/bin so maybe you do.
15:46:12 <Operator> do you have a queston?
15:46:20 <mauke> no
15:46:23 <roconnor> joe6: ya, I'd just write that as tPGC = (100 `nanoseconds`) with my definition of nanoseconds.
15:46:36 <joe6> roconnor: ok, thanks.
15:46:48 <Operator> sorry then i cannot help you!~~
15:47:06 <mauke> Operator: well, I had that one question. you could answer that
15:47:13 <mekeor> applicative: well, the executable works for me... but i cant find the Demo.hs on my local computer... so, i have to download it, right? OK.
15:47:22 <Operator> what was the queston?
15:47:34 <mauke> Operator: do you have a haskell question?
15:47:53 <Operator> no
15:48:08 <mauke> Operator: do you know any haskell?
15:48:18 <applicative> mekeor you should probably do  "cabal unpack gnuplot"  and use src/Demo.hs just to make sure they're the same, I guess
15:48:59 <mekeor> applicative: thank you very much! :)
15:49:05 <Operator> welcome to chat how may i assist you?
15:49:11 <mauke> Operator: hello?
15:49:14 <mekeor> Operator: are you a bot?
15:49:18 <Operator> What now?
15:49:25 <mauke> Operator: do you know any haskell?
15:49:29 <Operator> yes i am a bot
15:49:32 <Peaker> mauke: just k/b?
15:49:58 <mekeor> honestly, i think, we should kick Operator :/
15:50:11 <Peaker> Either a bot or a troll emulating a bot
15:50:17 <Operator> I will any one else
15:50:25 <hpc> @ops
15:50:25 <lambdabot> Maybe you meant: docs oeis pl
15:50:29 <hpc> @where ops
15:50:29 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:50:32 <mauke> hpc: ...
15:50:38 <hpc> threw up the bat signal
15:50:43 <hpc> :P
15:50:46 <mauke> yes, I saw the highlight
15:50:56 <Operator> welocme to chat how may i assist you?
15:50:59 --- mode: ChanServ set +q *!*@204.73.49.220
15:50:59 --- mode: ChanServ set +o mauke
15:51:00 --- kick: Operator was kicked by mauke (come back when you're more sentient)
15:51:10 --- mode: ChanServ set -q *!*@204.73.49.220
15:51:49 --- mode: mauke set -o mauke
15:54:30 <dainanaki> lol
15:57:27 <dainanaki> wow, 7.2 seems to compile large projects significantly faster
15:58:06 <applicative> dainanaki: I noticed that too, or rather it seemed so to me too.
15:58:25 <djahandarie> Haven't tried it out yet. That sounds like good news though.
15:58:30 <blackdog> somehow i've forgotten - how do you get the haskell platform with 7.2.1? there doesn't seem to be a haskell-platform package on hackage...
15:59:01 <applicative> dainanaki: on osx the best part is that fllvm works, i've just been fooling with it.
15:59:07 <dainanaki> i know
15:59:08 <dainanaki> it'
15:59:10 <dainanaki> it's lovely
15:59:59 --- mode: ChanServ set +o mauke
15:59:59 --- topic: set to '["Paste code/errors: http://hpaste.org/new/haskell ", "Haskell Platform 2011.2: http://is.gd/dCGPn", "GHC 7.2.1: http://is.gd/IU2lRI", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/", "admin/spam issues: #haskell-ops"]' by mauke
16:00:00 <siracusa> Has 7.2 been officially released yet?
16:00:22 <mauke> :-)
16:00:32 <applicative> i don't think so there are binaries up for the clutzy platforms, so i'd think not long?
16:00:36 <Headofsecurity> Head of security
16:00:38 <applicative> wait, mauke is smiling
16:00:49 --- mode: mauke set -o mauke
16:01:03 <Headofsecurity> We are now tracing IP addresses
16:01:22 --- mode: ChanServ set +o mauke
16:01:23 --- mode: mauke set +b *!*@204.73.49.220
16:01:24 <applicative> sure enough http://www.haskell.org/pipermail/glasgow-haskell-users/2011-August/020718.html
16:02:28 --- mode: mauke set -o mauke
16:03:20 <alpounet> siracusa, yes, 7.2.1
16:03:37 <alpounet> but it hasn't been propagated yet to distro repos, etc ofc
16:07:12 <benmachine> it was released hours ago wasn't it?
16:07:24 * roconnor wishes he was better educated about join-semilattice-semigroupoids
16:07:25 * applicative is going to be the first on his block to make a ghc plugin
16:07:57 <alpounet> benmachine, yep
16:10:14 * hackagebot syb-with-class 0.6.1.2 - Scrap Your Boilerplate With Class  http://hackage.haskell.org/package/syb-with-class-0.6.1.2 (AndreaVezzosi)
16:15:02 <Cale> Is anyone aware of a game system emulator project which isn't fundamentally an interpreter? Why aren't there static compilers?
16:15:27 <lucca> there was one NES emulator that did JIT compilation of 6502 machine code to intel, iirc
16:15:33 <Cale> I've seen some projects using JIT compilation, yeah.
16:15:46 <mauke> dohoho, {-# LANGUAGE DefaultSignatures #-}
16:15:53 <mauke> I'm so going to use that
16:16:25 <mauke> class Default a where def :: a; default def :: Num a => a; def = 0
16:16:33 <lucca> Cale: i think mostly the systems that are understood well enough are already fast enough.  Those that aren't have imperfect documentation available.
16:16:51 <parcs> Cale: "you can't statically compile self-modifying code" http://fms.komkon.org/EMUL8/HOWTO.html#LABD
16:16:52 <Cale> Well, I just read: http://arstechnica.com/gaming/news/2011/08/accuracy-takes-power-one-mans-3ghz-quest-to-build-a-perfect-snes-emulator.ars
16:17:39 <mauke> oh shi-
16:17:46 <lucca> most systems aren't using self-modifying code, but they may play games with undocumented cpu instructions and bus capacitance
16:18:29 <mauke> class Functor f where fmap :: (a -> b) -> f a -> f b; default fmap :: (Applicative f) => (a -> b) -> f a -> f b; fmap = liftA
16:19:15 <Cale> The article makes it sound like correctly modelling synchronisation between processors makes up a lot of the cost of accurately emulating these systems.
16:19:42 <heatsink> That's true, at least for older systems.
16:19:50 <Cale> It seems like some sort of static analysis should be possible to determine where synchronisation will have an effect, and could be used to enable optimisations.
16:20:26 <c_wraith> the great fun is the games that included extra processing units in the cartridges...
16:20:41 <heatsink> Programmers played a lot of timing tricks, such as writing to video memory during the specific time when the display isn't updating.
16:21:14 <monochrom> I suggest looking at the demograph of those who write those emulators and examining their educational background
16:21:17 <mauke> oh yeah, didn't chrono trigger use that for gradient effects or something?
16:21:33 <Peaker> I was wondering about Iteratees' use of explicit Chunk lists -- besides being quite ugly (why not chunk up above the Iteratee layer?) -- is it really faster to build a list and then fold on it, then re-apply a potentially-inlined function pipeline multiple times?
16:22:14 <acowley> Peaker: it's a really frustrating wart, but I believe it makes a big difference when consuming individual bytes
16:22:44 <acowley> My usage of the pattern does chunking at the byte level, but not above that
16:23:10 <Peaker> acowley: yeah, many Iteratees have chunk lists of bytestrings, so there's 2-levels of chunking
16:23:46 <Peaker> I guess that's legitimate though since the bytestring-break-points are semantically meaningful
16:25:08 <acowley> Peaker: sometimes they are, sometimes they're not. I usually feel like dealing with EOF is enough sand paper, and the chunks push the unpleasantness too far
16:25:40 <dainanaki> enumerators are fast as heck though, when done properly
16:26:24 <ddarius> X is fast as heck when done properly.
16:26:36 <Peaker> On the one hand, having 4 different Iteratees libraries is part of the problem, and another one would aggravate that.. otoh, I think I can choose much better names for the combinators, and I think the chunks can be thrown to another layer, ..
16:27:09 <acowley> Peaker: as ridiculous as it is, now's the time to advocate such a library before anything gets too entrenched
16:27:28 <Eduard_Munteanu> How's iteratee performance, compared with plain Bytestrings?
16:28:02 <dainanaki> iteratee is for more than just bytestrings
16:28:10 <Eduard_Munteanu> It seemed easier to get (a bit) better performance with Bytestrings, AFAICT.
16:28:18 <Saizan> that's like asking how is foldl performance compared to [a]
16:28:26 <acowley> ddarius: except for a passacaglia
16:28:55 <dainanaki> Saizan, good analogy.
16:29:47 <Peaker> acowley: In a few weeks time, I will hopefully have almost full time to toy around with programming stuff.. Toying with iteratee alternatives is high on the list :)
16:30:03 <Eduard_Munteanu> Well, iteratees make a nice API, no? The question is whether you get performance similar to lazy Bytestrings.
16:30:16 <dainanaki> that's not the right question
16:30:27 <acowley> also, "no"
16:30:57 <Eduard_Munteanu> How so?
16:31:14 <dabblego> I use iteratees with java.sql.ResultSet on some production code
16:31:43 <acowley> The crux of the complaint is that iteratees don't make a nice API. The question of whether bytestrings are an alternative isn't entirely well-defined as they are not substitutes for each other.
16:32:18 <acowley> it is reasonable, and common, to use iteratees in conjunction with bytestrings
16:32:40 <Peaker> First, the names Iteratees/Enumerators/Enumeratees are bad.. I'd much prefer: Consumer, Producer, Transformer  (If they're all in a qualified Flow module or such, then Flow.Transformer makes some sense, perhaps)
16:32:55 <Eduard_Munteanu> Well, it's not like lazy Bytestrings or plain lazy I/O are good enough in some cases.
16:33:08 <Eduard_Munteanu> So in a sense iteratees are a better API.
16:33:23 <ddarius> better /= nice
16:33:33 <Peaker> I think it might also be nice to be able to use the same pipe operator to hook up   Producer and Transformer, Transformer and Transformer, and Transformer and Consumer -- such that you don't have to take up a large operator namespace
16:33:50 <acowley> Peaker: I agree with everything except I'm not so sure about "Flow"
16:34:02 <Peaker> acowley: people complain that "Transformer" is too vague
16:34:06 <Eduard_Munteanu> ddarius: indeed, if only a lazy I/O approach could be used in all cases...
16:34:23 <acowley> Peaker: I know they do, but I'm on your side with this one
16:34:37 <dainanaki> me too
16:34:39 <monochrom> I suggest Transducer
16:34:53 <dainanaki> the naming scheme was the hardest thing for me to grok
16:34:59 <acowley> Used without qualification, all those names are terrible. But we have modules.
16:35:16 <Peaker> monochrom: the dictionary says it's something like an A2D
16:35:17 <hpaste> mrakan pasted “In trying to derive an instance of Binary using the derive package, I get an exception.” at http://hpaste.org/50100
16:35:31 <monochrom> what is A2D?
16:35:32 <Eduard_Munteanu> Maybe some sort of Data.Stream.* ?
16:35:32 <Peaker> or electrical<->other-analog
16:35:38 <Peaker> monochrom: analog-to-digital or back
16:35:50 <mrakan> Hi. I pasted the problem. Is this a bug or am I doing something wrong?
16:35:57 <ddarius> @wn transducer
16:35:58 <acowley> Transducer is fine, but is it any better than Transformer? It lacks the association with transformers, but bumps into lens work.
16:35:58 <lambdabot> *** "transducer" wn "WordNet (r) 2.0"
16:35:58 <lambdabot> transducer
16:35:59 <lambdabot>      n : an electrical device that converts one form of energy into
16:35:59 <lambdabot>          another
16:36:09 <Peaker> acowley: do you agree with having a single operator to hook up these pipelines?   Then there's a need for a name for a "full" pipeline (one that has a Producer and Consumer on both ends)
16:36:21 <Peaker> Maybe just "Pipe"
16:36:41 <monochrom> then my next suggestion is Scrambler
16:37:09 <acowley> and now we're painting the bike shed turqoise which makes nobody happy
16:37:25 <ddarius> What's wrong with turqoise?
16:37:25 <danharaj> How aboutt feeders and eaters and chefs.
16:37:28 <acowley> Peaker: Probably, but you've got to code it up and see how it looks in practice
16:37:30 <Peaker> There's also a problem with contravariance: Iteratee is basically an indexed parsing(state) monad -- and so it has "unparsed stuff" in a covariant position -- ruining the contravariance of its input type
16:38:15 <acowley> ddarius: a turqoise bike shed is too festive. It's misleading as to its purpose and contents and will lead to many disapointed children.
16:38:23 <mauke> 「The "evil mangler" has been removed」 - yes!
16:38:42 <Saizan> mauke: why so excited?
16:38:52 <monochrom> oh! I know! Consumer, Producer, EvilMangler
16:38:53 <mauke> because the evil mangler is evil, and I like perl
16:38:53 <Peaker> if you remove the "unparsed stuff" then it becomes weaker (also in a good way, as Iteratees can lie and add/enumerate input that never existed, but also in a bad way, since they may need to accumulate before rejecting)
16:38:54 <acowley> he's tired of being mangled
16:39:20 <mauke> seeing code as terrible as the mangler makes me sad
16:40:04 <mercury^> mauke: do you have any perl pearl to share?
16:40:32 <acowley> monochrom: I'm sure that was Oleg's first choice but he avoided it out of respect for GHC
16:40:44 <monochrom> haha
16:41:18 <mauke> mercury^: what do you mean?
16:41:23 <mercury^> I liked a lot of perl I have seen so far, as it read like concise english.
16:41:40 <mercury^> mauke: a reasonably short perl program that is awesome to look at.
16:42:06 <monochrom> twitter has better concise english than perl
16:42:27 <mauke> my really awesome perl is more like "shock and awe" (also, terrible)
16:42:38 <mercury^> :(
16:43:43 <blackdog> mercury^: i have the same problem with perl that i do with ruby - the right code reads like english, but so does the wrong code
16:43:56 <mauke> not particularly awesome, but http://mauke.dyndns.org/stuff/perl/flatten
16:44:15 <mauke> it flattens directory hierarchies while preserving the relative order of filenames
16:44:45 <parcs> tabs?!
16:44:49 <mauke> yes
16:45:41 <mauke> and here some obfuscated code, usenet signature compatible: http://mauke.dyndns.org/stuff/perl/hq9+.pl
16:46:27 <mauke> http://mauke.dyndns.org/stuff/perl/yes.pl - almost on topic now
16:47:19 <Peaker> mauke: Liking Perl is weird :-)
16:47:30 <mauke> no u
16:47:37 <kakazza> use bytes;  # FFFFUUUUUUUU
16:47:45 <Peaker> mauke: Do you at least hate Perl without "use strict"? :)
16:47:49 <mauke> Peaker: of course
16:48:06 <Peaker> mauke: Does Perl have function argument signatures?
16:48:14 <mauke> Peaker: depends
16:48:18 <Peaker> (I remember it doesn't without use strict)
16:48:24 <mauke> strict is unrelated
16:48:43 <Peaker> What happens if you give too few arguments to a Perl function?
16:48:47 <mauke> strict has 3 effects, 2 compile time, 1 runtime
16:48:48 <Peaker> Or too many?
16:49:15 <mauke> 1) you must quote your strings, 2) undeclared variables aren't assumed to be globals, 3) you can't dereference strings
16:49:26 <mauke> Peaker: define "too few"/"too many"
16:50:14 <Peaker> mauke: def f(x, y):  if x: return y   else: return bazoogla        f(False)  # Python would yell about incorrect arg signature here
16:50:35 <mauke> http://search.cpan.org/~mauke/Data-PrioQ-SkewBinomial-0.03/lib/Data/PrioQ/SkewBinomial.pm - I'm still not sure if this module is meant to be taken serious or not
16:50:50 <mauke> definitely an okasaki overdose
16:50:56 <mauke> Peaker: and?
16:51:13 <mrakan> Using the derive package, I can derive an instance of Binary for (data A = B Int), but not for (data A = B). Notice the constructor with no arguments in the second example. Does anyone know if this is a bug?
16:51:28 <Peaker> mauke: What would be the Perl equivalent?
16:51:42 <dmwit> mrakan: Sounds like a bug.
16:51:47 <acowley> mrakan: did you fix your earlier problem?
16:52:00 <mrakan> dmwit: Thanks, I'll report it.
16:52:13 <mauke> Peaker: sub f { my ($x, $y) = @_; $x ? $y : bazoogla } f(undef)  # more or less, sort of
16:52:20 <mrakan> acowley: Only by adding an argument to the data constructor. Then it compiles fine.
16:52:40 <ion> % perl -lwe 'sub foo ($) { print shift }; foo (1, 2)'
16:52:41 <ion> Too many arguments for main::foo at -e line 1, near "2)
16:52:43 <acowley> What do the binary instances derive generates look like?
16:52:57 <acowley> If you only have one constructor, it's all meaningless
16:52:58 <lucca> Peaker: Better to think of perl functions as always taking a list; inside they often assign lexicals (my-vars) with scatter or shift, which hands out undef values as needed.
16:53:00 <mauke> ion: eww, prototypes, bad, etc
16:53:01 <acowley> there's no information beyond the type
16:53:09 <Peaker> mauke: the tuple unpacking would yell?
16:53:09 <dmwit> mrakan: By the way, you might consider "newtype A = B () deriving Binary" with -XGeneralizedNewtypeDeriving in the meantime.
16:53:15 <lucca> perl prototypes aren't terribly useful
16:53:17 <mauke> Peaker: no, and that's not a tuple
16:53:27 <mauke> Peaker: it's basically like javascript
16:53:41 <mauke> with @_ playing the role of 'arguments'
16:53:44 <acowley> I'd believe it's a bug if you had multiple nullary constructors and still couldn't get an instance
16:53:48 <dmwit> acowley: I think a non-buggy Binary instance for "data A = B" ought to force the constructor, then output no bits. =)
16:53:56 <Peaker> mauke: IMO we have 3 levels: A) Catching errors at compile time (Haskell)  B) Catching errors at runtime (Python)  C) Never catching errors (Perl) :-P
16:54:01 <Peaker> Perl and Javascript
16:54:39 <acowley> dmwit: this is far from an elegant way to get whnf :/
16:54:47 <mauke> I've written a module to give you parameter list syntax, though
16:54:52 <acowley> TH derives a Binary instance so we eliminate a bottom
16:55:15 <Peaker> mauke: I'm not sure why anyone would want some of the most common mistakes (incorrect arg passing) to not yield errors even at runtime
16:55:17 <lucca> Peaker: perl leaves argument count determination to the user by design.  Considering you can do completely different things based on the type of your /return/ context, this is reasonable.  (or hideously reasonable, take your pick)
16:55:22 <mrakan> acowley: I agree the example was silly. Using multiple nullary constructors works; I just checked it. Defining just a single nullary constructor does fail with a non-exhaustive pattern, though.
16:55:31 <acowley> dmwit: also the deserialization reads no bits and is just empty?
16:55:40 <Peaker> lucca: How do you do different things based on a return context?
16:55:42 <dmwit> acowley: Yes, why not?
16:55:47 <mauke> Peaker: how do you determine "incorrect"?
16:55:54 <dmwit> Read no bits and return B.
16:55:57 <ion> peaker: D) It’s not an error, feel free to concatenate that file handle with that integer and use that as a database query. (PHP)
16:55:58 <dmwit> What's wrong with that?
16:55:58 <lucca> Peaker: see perldoc -f wantarray
16:55:59 <acowley> mrakan: but there's no information in such a Binary instance
16:56:05 <acowley> dmwit: it angers my sensibilities?
16:56:14 <dmwit> acowley: Why??
16:56:24 <Peaker> mauke: Code conveys a meaning that would surprise its author and/or gives incorrect results
16:56:24 <dmwit> There's no bits of information, so why shouldn't it read/write no bits?
16:56:46 <mauke> Peaker: ok, and how is perl supposed to check the author's intent?
16:56:52 <Peaker> ion: wouldn't JS and Perl minus strict also allow that?
16:56:58 <Peaker> mauke: Be strict about argument list checking
16:57:05 <mauke> Peaker: perl has no argument lists
16:57:11 <acowley> I don't know; I'm a very angry person! It's really just because if I was trying to figure out what some code did, and found a TH splice deriving an instance and chased this all down to find empty functions I'd be a bit sore.
16:57:11 <Peaker> mauke: that's a problem :)
16:57:17 * ion covers his ears. THERE’S NO PERL WITHOUT STRICT
16:57:26 <dmwit> acowley: (I'd even be happy enough if the instance didn't even bother to force the B constructor before it output zero bits. =P)
16:57:40 <acowley> dmwit: it could lazilly do nothing
16:57:44 <acowley> my favorite funciton
16:57:48 <mauke> Peaker: hmm, maybe I'll add a strict checking mode to Function::Parameters
16:57:52 <dmwit> I'd be happy with that.
16:58:00 <Peaker> mauke: Or at least, the lack of strict pattern matching on the argument is a problem (one that lets you make sure the caller has given an exactly-structured argument)
16:58:12 <acowley> dmwit: You're a flexible guy. It's admirable :)
16:58:13 <mauke> Peaker: the problem is that checking just the number of arguments is very limited
16:58:16 <Peaker> mauke: How does one use Function::Parameters?
16:58:29 <mauke> Peaker: you usually want some kind of type checks as well, which is hard in a language without a type system
16:58:44 <mauke> Peaker: use Function::Parameters; fun foo($x, $y) { $x * 2 + y }
16:58:56 <mauke> I mean $y
16:59:06 <Peaker> mauke: ah, cool, can you also implement keyword/default-args?
16:59:25 <mauke> I could, but ... meh
16:59:39 <mauke> hacking the core syntax is hard enough
16:59:44 <lucca> Peaker: some perl libs have functions, constructors, methods, etc., that treat their argument list as a hash...
17:00:02 <roconnor> are categories with a semi-lattice structure on their hom-sets an enriched-category somehow?
17:00:05 <mauke> currently it simply expands to my ($x, $y) = @_;
17:00:28 <mauke> you can do fun (%kw) and get something like keyword args
17:01:11 <lars__> could anyone invite me to google+'s haskell circle?
17:01:16 <mauke> fun ($x) { $x->($x) }->(fun ($x) { $x->($x) })  # so I heard you like infinite recursion
17:01:21 --- mode: ChanServ set +o mauke
17:01:21 --- mode: mauke set -b *!*@204.73.49.220
17:01:22 <Peaker> lucca: I think Python's argument passing/checking is a good minimum to strive for -- if you have more arguments than you expected -- it represents a very likely programmer error.. If you have less than expected, ditto.. Better to err on the side of annoyance, than on the side of sliding bugs
17:01:42 <lucca> Peaker: fair enough.  I'm not a perl developer.  I ESCAPED.
17:02:11 --- mode: mauke set -o mauke
17:02:28 <Peaker> In programming, I think generally safety should trump convenience.. because unsafety translates to a whole lot more inconvenience later :)
17:02:44 <lucca> welcome to cobol.
17:02:55 <Peaker> lucca: how is cobol safe?
17:03:11 <Peaker> Unfortunately, even those who do pretty good on this side of preferring safety to convenience (Haskell) still mess up (Providing "head" and "fromJust", bah)
17:03:20 <lucca> I'm teasing.  That's largely inconvenience for the sake of... something else entirely.
17:03:32 <Peaker> Of course you should get convenience when there's no trade-off
17:03:38 <Peaker> But when it conflicts with safety -- choose safety
17:04:53 <ion> PHP’s magic quotes feature is an example of choosing both safety and convenience at the same time.
17:05:07 * mauke rages softly
17:05:09 <hatds> at some point it's not worth the trouble to have types rich enough to say all your functions are total
17:05:21 <ski> Peaker : one could also use some selected dosages of syntactic salt in some cases
17:06:00 <Peaker> ski: sounds like adding convenience without sacrificing safety
17:06:29 <ski> i.e. Mercury requires you to prefix every application of an impure function with `impure' (and it's transitive/contagious, of course)
17:06:29 <mauke> 「ypeRep and TyCon now have Ord instances」 - yes!
17:06:57 <clsmith> Peaker: i would guess you can do deep pattern exhaustion analysis to detect when 'head' or 'fromJust' are unsafe
17:07:05 <ion> Convenience: you don\'t need to escape strings because they\'re escaped for you. Security: you can just feed input from web users to SQL, it\'s safe now. Guaranteed.
17:07:06 <Peaker> hatds: Non-Haskellers say "At some point it's not worth the trouble to have types rich enough to say all your functions have no effects".. Dynamic language users say "to have rich enough types at all", and so forth.. I don't think Haskell is the sweet spot.. we need more types
17:07:21 <mauke> ion: where SQL = mySQL
17:07:26 <Peaker> clsmith: doing it in the general case is of course solving the halting problem
17:07:27 <shachaf> mauke: What, you want to use them as keys of a Map or something like that?
17:07:32 <mauke> shachaf: yep
17:07:33 <ski> `impure' is mostly intended to be able to write nicer C-wrappers for FFI in Mercury instead of writing them in C, but so that you eventually wrap up a nice pure interface which you promise is pure
17:07:38 <ion> mauke: There\'s no SQL but MySQL.
17:07:42 <shachaf> mauke: Sounds a little evil.
17:08:13 <ion> Want to see something funny? http://sunsite.univie.ac.at/textbooks/mysql/manual.html#Broken_Foreign_KEY
17:08:23 <mauke> shachaf: lookup :: (Typeable k, Ord k) => HMap v -> k -> Maybe v
17:08:29 <clsmith> Peaker: well, i suppose so, but those particular functions can be proven safe.
17:08:43 <hatds> Peaker: I'll admit we should look for better sweet spots, sure :)
17:09:19 <mauke> ion: a guy I know had a query like SELECT * FROM foo WHERE bar IS NULL AND bar IS NOT NULL
17:09:24 <mauke> ion: 1 row returned
17:09:29 <ion> hah
17:09:34 <clsmith> :|
17:10:00 <mercury^> roconnor: if multiplication is a semilatice homomorphism, of course.
17:10:04 <mauke> I think it was a not-null datetime column with 0 in it
17:10:23 <mercury^> lattice*
17:10:24 <Peaker> hatds: It would be real nice to have a Partiality monad, if our types were strong enough to prove totality.. Adding it as is to Haskell would just put most of the program in Partial with no escape
17:10:42 <clsmith> mauke: new year 1970 was a magical date
17:10:42 <roconnor> mercury^: a join-semilattice homomorphism preserves join I guess?
17:10:51 <mercury^> Yes.
17:11:00 <pedro3005> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html  how do I install this?
17:11:11 <mauke> cabal install split
17:11:20 <mrakan> pedro3005: Do "cabal update; cabal install split".
17:12:07 <hatds> Peaker: I think it's practically important to have, for example, head and fromJust exist as ordinary functions.  The type system is already rich enough to make them uneeded, but removing them means you can't factor out expressions as easily
17:12:09 <roconnor> mercury^: hmm, multiplication is a binary function, not a function.
17:13:00 <mercury^> roconnor: it is a function hom(b,c) (x) hom(a,b) -> hom(a,c);
17:13:04 <roconnor> mercury^: but I guess the cartesian product of two semilattices is a semilattice
17:13:06 <Peaker> hatds: Every use of head and fromJust is regretted later :)
17:13:11 <mercury^> In your case the monoidal product will be the cartesian product.
17:13:41 <ski> Peaker : i wonder if refinement types could be used here ..
17:13:42 <mercury^> (the category of semilattices is bicomplete as far as I can tell, so that is no problem)
17:13:44 <Peaker> hatds: you should factor your uses of "head" to use "listToMaybe" and your uses of "fromJust" to an "unsafeUnjust" which takes a String with a verbal proof of why it should not be Nothing
17:13:58 <Peaker> ski: what are refinement types?
17:14:37 <Peaker> People who use unsafeUnjust without a good proof in there should automatically get their code stamped "unprofessional"
17:15:09 <ski> Peaker : given e.g. `data Nat = Zero | Succ Nat' you can do two refinement types `data Nat :> Even = Zero | Succ Odd; data Nat :> Odd = Succ Even'
17:15:27 <ski> Peaker : you can imagine similar things with non-empty trees, non-empty lists, &c.
17:16:11 <ski> Peaker : so, given an existing variant type, a subtype of that type, like the above
17:16:37 <Peaker> ah, sounds like a possibly-more-modular approach than type-tagging every interesting property of every interesting constructor in a GADT-way
17:16:47 <hatds> Peaker: If you have a big case statement then on the RHS of each alternative you know whether pattern matching on (x:xs) or (Just x).  Of course it is better to use 'x' here directly than head or fromJust, but what if it really is more practical to use a partial function on the RHS?
17:17:12 <Peaker> hatds: Why is it more practical?
17:17:13 <azaq23> ski: Are :> and <: a generally used notation for "is supertype of" and "is subtype of"?
17:17:30 <ski> azaq23 : i think so
17:17:44 <ion> Both are also smileys encountered in IRC occasionally.
17:18:26 <hatds> Peaker: lexical reasons say, but more importantly if you can't guard your partial functions with patterns, only with if/then/else, you don't really have a better style to choose from.
17:19:05 <dolio> There's never a situation where if/then/else is possible, but case isn't.
17:19:36 <Peaker> hatds: if you're passing booleans representing "isJust" for example, you're doing it wrong, restructure it
17:19:58 <hatds> that might be the API you are given
17:20:22 <ski> hm, this reminds me that i would like `Right a >>= amb = amb a; m@(Left _) >>= _ = m' to type-check
17:20:35 <clsmith> hatds: if that is the api you're given, surely you could just ignore it and check anyway
17:20:44 <hatds> and the API designers might have been constrained by the conditional being expensive to compute, so it wasn't precomposed to the partial function
17:21:17 <Peaker> hatds: not sure why a computation being expensive is related to using a boolean vs using a Just constructor
17:21:23 <ski> we know `m :: Either a b' here, but since we know it also matched `Left _', the type ought to be generalized to `m :: forall b. Either a b'
17:21:55 <dolio> ski: Have you ever seen a system in which that works?
17:22:02 <Peaker> hatds: if the API is stupid, you may have to do bad things, sure..
17:22:28 <hatds> Peaker: if you have a partial function and a boolean function to guard it you can compose them to get a total function, at the cost of being unable to use the partial function without rechecking
17:22:29 <ski> dolio : no. i've pondered attempting a simple prototype myself ..
17:23:01 <acowley> roconnor: I'm really enjoying your *-semiring article
17:24:02 <hatds> Peaker: arrays are "stupid" in this way
17:24:21 <Eduard_Munteanu> azaq23: that's what TAPL is using for the subtyping relation too
17:24:48 <Peaker> hatds: Use Oleg's index-safe arrays :)
17:25:05 <acowley> dolio: does agda not do that? (honest question)
17:25:14 <dolio> Nah, not that I know of.
17:25:31 <hatds> Peaker: I don't need to, I can write my own safe arrays using the partial functions that I naturally have already
17:25:32 <acowley> you'd think it might
17:26:14 <hatds> Peaker: if partial functions were locked inside some restrictive type, I couldn't do that
17:26:41 <Peaker> hatds: Oleg's arrays give you totality without runtime overhead of checking every index use
17:26:42 <ski> istr reading that O'Camls polymorphic variants removed each failed match alternative from the type, so that a final catch-all case didn't include the previously handled cases
17:26:43 <dolio> What exactly is your disagreement? If it's impossible to not use partial functions, then you're just stuck. That doesn't make them good.
17:26:57 <Peaker> hatds: your arrays wouldn't be safe if you compose partial functions
17:26:58 <roconnor> acowley: thanks!
17:28:48 <hatds> dolio: I agree
17:30:07 <hatds> dolio: my disagreement is whether "Haskell gets it wrong by having head be a function"
17:30:41 <azaq23> Eduard_Munteanu: Well, then it's a pretty safe bet to assume those are the correct symbols even though they are not used in conversation in any social environment of the more prominent, non functional languages although they, contrary to haskell, assign more value to the whole notion of subtyping
17:31:14 <dolio> I don't see how whether or not people have designed array libraries that require you to use partial functions has any bearing on whether head is a good idea or not.
17:32:36 <hatds> dolio: are you saying you didn't follow the conversation, or that you followed by think it is irrelevant for head (arguably being much different because you can pattern match on lists)?
17:32:46 <hatds> *by think = but think
17:33:49 <dolio> I mean, "array libraries use partial functions, therefore head is good," is a non sequitur as far as I can tell.
17:34:27 <hatds> well I don't know what that quote is taken from, but the example was you can combine partial functions over arrays to get total functions on arrays
17:38:00 <dolio> You don't need head to build good total functions over lists. The built-in, primitive construct for operating on them could be made total.
17:38:04 <dolio> With no loss of performance.
17:39:51 <hatds> 1) how would you design a language that disallows anyone defining head? Does that design impact partial functions on non-lists? 2) why uglify the following function map (head &&& length) . group . sort
17:39:53 <Eduard_Munteanu> azaq23: note F_<: is a pretty common notation too
17:40:05 <Eduard_Munteanu> F sub, that is
17:40:57 <Eduard_Munteanu> Well, their idea of subtyping is a subset (unintended pun) of actual subtyping, AFAICT.
17:40:58 <dolio> There are quite a few total languages out there.
17:41:08 <hatds> dolio: I know of course
17:41:13 <Eduard_Munteanu> (if you mean C++ and stuff like it)
17:41:47 <hatds> dolio: the point was the followup.  I'm sure the designers of Haskell also knew about total languages and had some reason not to do it that way
17:42:08 <dolio> And group can easily be given a signature that indicates that it returns a list of non-empty lists, the latter of which admit a safe head.
17:42:19 <Eduard_Munteanu> Total programming is still pretty much unexplored.
17:42:21 <ion> group :: Eq a => [a] -> [NonEmptyList a]
17:42:25 <ion> head :: NonEmptyList a -> a
17:43:05 <ion> (Yeah, wouldn’t really work like that.)
17:44:08 <hatds> dolio: Yes you could give group a better signature.  But if you want to know where I stand, I don't think it is practical to encode totality into your types for every function.
17:44:10 <Eduard_Munteanu> ion: yeah, the whole point is working with possibly-empty lists.
17:44:28 <Eduard_Munteanu> Or converting a possibly-empty list to a non-empty one, which might still look partial.
17:44:49 <dolio> I'd be very surprised if anyone considered making Haskell a total language back in its early stages.
17:44:59 <dolio> At least, considered seriously.
17:45:44 <hatds> but you think today is different?
17:46:05 <Eduard_Munteanu> Lesson k + 1: Never ever think something is too crazy, otherwise you may not manage to avoid success properly.
17:46:16 <dolio> No, I don't think anyone's considering it now, either. But even if they were, it wouldn't matter, because it's too late for that.
17:46:53 <blackdog> dolio: that's sort of the role agda & coq & all those languages are fulfilling, right?
17:47:10 <blackdog> just as you wouldn't try to impose type inference on top of ruby
17:47:46 * Eduard_Munteanu would settle with a totality switch
17:48:56 <Peaker> type NonEmptyList a = (a, [a]) ; head = fst ; tail = snd
17:49:18 <Eduard_Munteanu> Or something that at least tries to prevent partiality.
17:49:48 <hatds> Eduard_Munteanu: we have that already, use pattern matching :)
17:50:21 <Peaker> speaking of that.. it's pretty sad you need -Wall for exhaustiveness warnings
17:50:22 <Eduard_Munteanu> > tail $ tail [1,2,3,4]
17:50:23 <lambdabot>   [3,4]
17:50:31 <dolio> blackdog: I guess. You could probably do stuff toward making a usable total language that doesn't involve dependent types and proofs and whatnot.
17:50:59 * ski . o O ( `data [a] :> NonEmptyList a = a : [a]' )
17:51:07 <dolio> The refinement types ski mentioned earlier would be useful to that end, for instance.
17:51:11 <Peaker> dolio: totality in recursion without DT sounds OK, but you'd probably end up with a lot of your program unnecessarily in a Maybe
17:51:16 <dolio> So that you don't have to write every list function twice.
17:51:21 <Eduard_Munteanu> Peaker: maybe   data NonEmptyList a = Cons a (NonEmptyList a)  | Singleton a   is better?
17:51:39 <ski> Eduard_Munteanu : no, refinement types is better
17:52:04 <jkff> Hi. What can be the reason for having all zero entries (except the MAIN one) in a profile of my executable? (+RTS -p)
17:52:04 <Eduard_Munteanu> Ah, indeed. I kinda want those in Agda. I don't even know how it'd look like.
17:52:06 <scooty-puff> is david of "david's blog" here?
17:52:09 <dolio> Refinement types can be desugared to types + proofs, but the former are certainly nicer to use.
17:52:15 <scooty-puff> http://overtond.blogspot.com/2008/07/haskell-sudoku-solver-using-finite.html, etc.?
17:52:23 <Eduard_Munteanu> But IIRC, I hear it'd make developing verified software easier.
17:52:26 <jkff> Ouch - probably I forgot to say "auto-all"
17:52:26 <Eduard_Munteanu> No?
17:53:37 <ski> Peaker : yeah, possibly non-overlapping warnings should also be enabled by default
17:53:47 <roconnor> mercury^: Hmm, it is begining too look like join-semilattice-categories are more tahn join-semilattice-enriched-categories.
17:54:14 <joe6> @sleep usleep
17:54:14 * lambdabot orders her trained monkeys to punch usleep
17:54:17 <roconnor> mercury^: because composition is left and right distributive over join
17:54:22 <joe6> @hoogle usleep
17:54:22 <lambdabot> No results found
17:54:30 <dolio> Peaker: The issue with total recursion is that it can be difficult to make the machine smart enough to recognize total functions.
17:54:36 <jkff> Turned out to be -auto-all indeed.
17:54:37 <roconnor> mercury^: and I don't think enrichment suffices to derive this
17:54:51 <dolio> And without dependent types, it gets hard to explicitly justify the termination.
17:55:08 * jkff regrets about not following the good advice of making most functions top-level
17:55:28 <Eduard_Munteanu> dolio: maybe just sized types could help?
17:55:44 <dolio> Maybe. I haven't looked at those much.
17:58:13 <Peaker> dolio: similarly with something that returns a Maybe in the general case but you can prove it's a Just
17:58:20 <Peaker> dolio: (e.g division and you can prove it's not a zero divisor)
17:58:29 <joe6> @hoogle DiffTime -> Integer
17:58:30 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:58:30 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
17:58:30 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
17:58:50 <Eduard_Munteanu> I do wonder what's keeping Haskell/GHC from getting a dependent types extension, though.
17:59:30 <ski> Peaker : i think side-effects could be useful in such a case
17:59:59 <Peaker> ski: In the division case?
18:00:03 <ski> yes
18:00:30 <ski>   x : A,y : A |- x / y : A | ZeroDivisor y
18:01:03 <ski> so `x / y' is in general side-effectful (it might throw an exception)
18:01:32 <joe6> how do I convert DiffTime -> Integer? i tried :t toInteger . picosecondsToDiffTime  $ 1
18:01:40 <joe6> > toInteger . picosecondsToDiffTime  $ 1
18:01:40 <lambdabot>   Not in scope: `picosecondsToDiffTime'
18:02:06 <ski> but if you have proven that `ZeroDivisor y' is not the case in the current context, that call would become pure, with no redundant `Maybe' wrapper to remove
18:02:51 <joe6> > toInteger . (undefined :: DiffTime)
18:02:52 <lambdabot>   Not in scope: type constructor or class `DiffTime'
18:02:58 <joe6> > toInteger (undefined :: DiffTime)
18:02:59 <lambdabot>   Not in scope: type constructor or class `DiffTime'
18:03:10 <ski> i don't know how such a system would work in general -- it's just a gut feeling that something like that should be possible
18:08:28 <roconnor> joe6: round
18:08:49 <monochrom> DiffTime is instance of Num, Fractional, Real. do you know what that means?
18:09:16 <joe6> roconnor: http://pastebin.com/rsv3z81N
18:09:19 <mauke> The paste rsv3z81N has been copied to http://hpaste.org/50102
18:09:23 <monochrom> @type realToFrac
18:09:23 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
18:09:46 <roconnor> hmm
18:10:03 <monochrom> for example "realToFrac ((x :: DiffTime) * 2) :: Rational" is well-typed
18:10:11 <joe6> round . realToFrac (undefined :: DiffTime)
18:10:16 <joe6> seems to work.
18:10:19 <roconnor> ya
18:10:22 <monochrom> @type round
18:10:23 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
18:11:11 <roconnor> I don't quite get why Real isn't a subclass of RealFrac
18:11:33 <roconnor> oh
18:11:39 <monochrom> it is the other way round
18:11:41 <roconnor> Real is a subclass of RealFrac
18:11:59 <roconnor> I don't quite get why that is
18:12:21 <roconnor> Actually I can almost vaugely see why
18:12:24 <roconnor> okay I see why
18:12:37 <monochrom> NominalDiffTime is further an instance of RealFrac. you can round it directly
18:12:49 <roconnor> ah
18:13:01 <roconnor> It seems like DiffTime should be an instance of RealFrac ...
18:13:15 <roconnor> or that Fixed should be
18:13:39 <roconnor> oh Fixed is an instance of RealFrac
18:13:50 <roconnor> so it seems like a mistake that DiffTime isn't an instance of RealFrac
18:15:40 <joe6> i am trying to get the DiffTime in nanoseconds
18:15:50 <joe6> so, I can use nanosleep on it.
18:16:42 <joe6> @hoogle Integer -> Fractional
18:16:42 <lambdabot> Warning: Unknown type Fractional
18:16:42 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
18:16:42 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:17:08 * pisum has troubles with haskell's whitespace syntax :/
18:17:16 <joe6> i have this: (realToFrac . picosecondsToDiffTime $ 1) * ( fromInteger . resolution $ (1::Nano))
18:17:23 <joe6> any better ways of doing that.
18:17:33 <Phyx-> Hey guys, I'm having trouble defining a class instance, it's all explained http://pastebin.com/vhs0szpL here, I'm wondering if this is at all possible without the use of unsafePerformIO
18:17:35 <mauke> The paste vhs0szpL has been copied to http://hpaste.org/50103
18:17:50 <Phyx-> pisum: you get used to it
18:17:53 <ski> pisum : any particular snippet you have problems with ?
18:18:15 <joe6> nanosleep . ceiling $ (realToFrac . picosecondsToDiffTime $ 1) * ( fromInteger . resolution $ (1::Nano))
18:18:26 <joe6> any better ways of doing the above?
18:18:56 <roconnor> joe6: what is nanosleep?
18:19:04 <pisum> ski: no, actually, i meant it very general: i'm always uncertain how to indent things, e.g. er... long lists (on several lines) or sth
18:19:08 <joe6> @hoogle nanosleep
18:19:09 <lambdabot> No results found
18:19:38 <Phyx-> anyone got any hints for me?
18:19:41 <ion> (realToFrac . picosecondsToDiffTime) 1 * (fromInteger . resolution) (1 :: Nano)  -- redundant $s
18:19:42 <joe6> roconnor: System.Posix.Unistd has the function nanosleep
18:20:10 <hpaste> pisum pasted “syntax” at http://hpaste.org/50104
18:20:44 <pisum> that was an accident (it wasnt finished...)
18:20:48 <ski> pisum : the words `let',`where',`of',`do' start a layout-block, each item in that block has to start at the same column
18:20:57 <joe6> roconnor: uri: http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-Unistd.html#v:nanosleep
18:21:14 <joe6> ion, thanks.
18:22:00 <roconnor> joe6: isn't ceiling $ (realToFrac . picosecondsToDiffTime $ 1) * ( fromInteger . resolution $ (1::Nano)) just a long way to write 0
18:22:21 <roconnor> I mean 1
18:23:10 <luite> joe6: keep in mind that those sleep functions may not sleep for as long as you expect, they can be interrupted by signals
18:23:37 <luite> the threaded rts uses a lot of those
18:23:51 <hpaste> pisum pasted “syntax” at http://hpaste.org/50105
18:23:59 <pisum> ski: ^
18:24:43 <ski> pisum : in that case, there's no layout-introducing keyword, so it's just a question of style and taste
18:24:47 <pisum> ski: how would you align/indent that?
18:25:11 <pisum> ski: yea, and that's exactly my problem, actually =(
18:25:32 <ion> phyx: I don’t think you can convert a → IO b to IO (a → b) in a very useful way. IO (a → b) implies you get the (a → b) after the action has been executed. I guess you could do IO (a → IO b) but that seems nasty.
18:26:41 <hpaste> ski annotated “syntax” with “styles” at http://hpaste.org/50105#a50106
18:26:51 <ski> pisum ^
18:27:11 <Phyx-> ion: yeah, but that IO (a -> IO b) isn't usefull to me in this case. I think I'll remove the instance all together.
18:28:41 <scooty-puff> for finite domain solvers, would it be an improvement, or possible, to track which variables are constrained against each other, and solve them alone?
18:28:44 <scooty-puff> or do they already do that?
18:29:04 <scooty-puff> it seems like a reverse topoligically sorted SCC could give you the deps pretty easily
18:29:43 <pisum> ski: and what about 'deriving ...' ?
18:30:06 <ski> Phyx- : i wonder whether `instance (FFIType b a, FFIType c d) => FFIType (a -> c) (b -> d)' is possible ..
18:30:43 <ski> pisum : i'd put it either aligned under the constructor name, or after the `}'
18:30:50 <hpaste> pisum pasted “my current indent-style” at http://hpaste.org/50107
18:30:52 <Phyx-> ski: That's what i'm wondering aswell, I've tried it very different ways, but can't seem to do it, and logically it seems a bit impossible. but I though i'd ask
18:31:01 <cmccann> Phyx-, what are you trying to do?
18:31:53 <ski> Phyx- : seeing how `->' is contravariant in its left argument, flipping the `a' and `b' in the assumption seems more reasonable .. but maybe a second class would be more appropriate for the `a' and `b' there -- not sure
18:32:11 <ski> cmccann : marshall functions, afaiui
18:32:32 * cmccann figured something like that
18:32:41 <ski> pisum : hehe, i'd `deriving Eq' instead :)
18:32:43 <Phyx-> cmccann: the general idea was, to convert functions, so if you have a function of Int -> Int, a call to toNative would give you a function of CInt -> CInt, originally I was able to do this rather easily since toNative was of the type a -> b, the problem was, that meant that for things like newArray, i needed unsafePerformIO, so I didn't want that, hence the new type a -> IO b, but now I think that specific instance can't be defined anymore
18:32:51 <pisum> regarding 'instance' i actually always use this syntax: "instance MyDataType AnAlreadyExistingTypeclass where ..."... (actually i didnt know about your syntax at all
18:32:59 <pisum> ski: Well, yep
18:33:33 <pisum> ski: but what's hlint's exercise then? ;)
18:34:07 <ski> pisum : i usually write like `lookup :: Eq key => key -> [(key,value)] -> Maybe value', instead of using `(Eq key) =>' there, just because the brackets are redundant in the one-constraint case
18:34:30 <ski> pisum : what does "Why is text-area is fail: ..." refer to ?
18:34:46 <pisum> well, the text-area on hpaste.org...
18:34:58 * ski blinks
18:35:08 <pisum> w8.. i take a screenshot
18:35:19 <ski> oh, you're watching the page in some fancy graphical browser
18:35:25 <joe6> roconnor i plan to replace the ...$ 1 .. with a parameter.
18:36:11 <Phyx-> ski: well, I could create a new class with the type toNative :: a -> b, and have the instance be (a -> b) (c -> IO d)
18:36:22 <Phyx-> it would complicate my codegen a bit, but I could use that
18:36:23 <ski> pisum : anyway, for similar reasons i write like `deriving Eq', when there's only one class to derive
18:36:56 <ski> Phyx- : i'm not sure i'm following what you mean
18:37:47 <cmccann> Phyx-, so you have a type class for converting the types, and you need an instance for functions?
18:38:17 <pisum> ski: http://www8.pic-upload.de/10.08.11/hwgayzvnn15.png
18:38:29 <Phyx-> cmccann: precisely, well, as it turns out, I don't *need* it, functions are handled differently by myself. I thought it would be nice to have, if possible
18:38:50 <Phyx-> ski: well, the current type of fromNative is a -> IO b, the IO around b is the problem
18:38:51 <ski> Phyx- : i suppose i was maybe imagining a `class IFFType phi ix where fromNative :: ix -> IO phi', and then attempt `instance (IFFType a0 a1,FFIType b0 b1) => FFIType (a0 -> b0) (a1 -> b1)'
18:39:09 <pisum> ski: and the text-color in the text-area is WHITE!! -.-
18:39:20 <Phyx-> ski: that's what i'm doing now
18:39:29 <pisum> ski: ... so FG- and BG-color are same, that sux
18:39:46 <Phyx-> ski: but that makes toNative have to return IO (a1 -> b1) which I can't see how I can do that without unsafePerformIO
18:39:50 <ski> pisum : i can't discern any text in that text box ..
18:40:57 <pisum> ski: me, too.  --> that's my problem
18:41:11 <Phyx-> cmccann: my codegens handle functions by having repeated calls to toNative, one for every argument. so an instance for functions isn't needed. I was wondering if i could simplify it
18:41:19 <pisum> ski: doesnt hpaste.org appear like that for you?
18:41:42 <ski> pisum : no, i'm viewing it in a text browser, in a terminal :)
18:43:24 <ski> pisum : you might try changing your bgcolor in the browser or system, or tell the browser to override the fgcolor (and possibly bgcolor as well, if you want)
18:43:39 <Eduard_Munteanu> Use the "raw" link.
18:43:49 <ski> good idea
18:44:53 <joe6> roconnor: something like this: http://pastebin.com/MgEdvp7P
18:44:55 <mauke> The paste MgEdvp7P has been copied to http://hpaste.org/50112
18:46:20 <cmccann> Phyx-, hm, why would you need to have toNative returning IO (a1 -> b1) for ski's suggestion?
18:46:33 <ski> Phyx- : i suppose if we have `fromNative :: aNative -> IO a', `f :: a -> b', `toNative :: b -> IO bNative', we can only get `aNative -> IO bNative', since we need to do the marshalling of `fromNative' and `toNative' after the resulting `aNative -> IO bNative' is called on an `aNative' argument ..
18:47:35 <roconnor> joe6: yes
18:48:01 <ski> maybe in some cases the marshalling could be treated as pure, i'm not sure
18:48:25 <Phyx-> cmccann: because of other types, converting [a] to Ptr a, the class instance would be instance [a] (Ptr a) where, but to create a pointer requires io, which is why toNative return an IO
18:49:29 <Eduard_Munteanu> Is fromNative supposed to give you the same function, except pre and post-composed with other fromNative/toNative calls?
18:49:40 <Phyx-> ski: yes, in cases such sas Float -> CFloat, where just realToFrac can be used.
18:49:40 <cmccann> Phyx-, why not make the instance [a] (IO (Ptr a)) or some such, to distinguish types that need IO for conversion?
18:50:34 <ski> Eduard_Munteanu : i think so
18:50:43 <Phyx-> cmccann: that still doesn't solve the problem, I would be able to define (a -> b) (c -> d) only for those types that still don't have IO in the head
18:50:57 <Phyx-> Eduard_Munteanu: yes
18:51:40 <Phyx-> cmccann: I infact have something *kinda* like this, http://pastebin.com/E2T4PCqt these are the actual members of the class
18:51:42 <mauke> The paste E2T4PCqt has been copied to http://hpaste.org/50113
18:51:59 <Phyx-> I can define (a -> b) (c -> d) using fromFFI/toFFI
18:52:27 <Phyx-> but it'll error out in a function such as Int -> Foo , where Foo is a user datatype
18:54:51 <cmccann> Phyx-, well, obviously in the general case you can only turn (a -> b) into (c -> IO d), but I assume you don't want to just force that for everything
18:55:18 * hackagebot prototype 0.1 - prototype-based programming on Haskell  http://hackage.haskell.org/package/prototype-0.1 (YoshikuniJujo)
18:56:08 <Phyx-> cmccann: what do you mean for it for everything?
18:57:29 * Eduard_Munteanu wonders about fromNative f = (\x -> fromNative x >>= f) >=> toNative, but should check its type (and the conversions)
18:57:51 <Eduard_Munteanu> Hrm, maybe 'f' should be in IO too.
18:58:30 <cmccann> Phyx-, I mean building IO into everything at the expense of conversions that can be done without it, would probably make it easier to be consistent that way
18:58:41 <pisum> hpaste.org seems offline
18:58:47 <pisum> or at least slow
18:58:52 <pisum> -- the latter.
18:59:37 <Phyx-> cmccann: yeah, currently I do everything in IO, even for functions which do not need it, it made generating code easier, I only had one pattern then
18:59:45 <Phyx-> Eduard_Munteanu: lemme check
19:00:54 <Eduard_Munteanu> Ah, no it's probably not going to work.
19:01:08 <Phyx-> Eduard_Munteanu: right, so that type is (a -> IO b) -> (c -> IO d)
19:01:24 <phiV> hey what's the command to find my WAN IP Address?
19:01:44 <ski> Eduard_Munteanu : hm, i suppose one might `instance (MonadIO m,...) => FFIType (Kleisli m a0 b0) (Kleisli m a1 b1)'
19:02:21 <Phyx-> :info Kleisli
19:02:38 <cmccann> Phyx-, Kleisli m a b = (a -> m b)
19:02:43 <Phyx-> ah
19:02:50 <cmccann> just a wrapper to allow an Arrow instance
19:02:54 <ski> phiV : <http://www.whatsmyip.org/> ?
19:03:32 <cmccann> Phyx-, anyway, after I think about it for a bit, I'm not sure you can really do this in a tidy, parametric way, as I guess you've already discovered
19:03:35 <phiV> ski: So if I want to SSH to my desktop over the internet would I choose this address?
19:04:09 <ski> phiV : hm, choose which address ?
19:04:42 <Phyx-> cmccann: yeah, I guess my current approach is the best, converting the arguments as they get passed to the functions and then convert the result before returning it
19:06:14 <Phyx-> thanks for all the help cmccann, ski , Eduard_Munteanu-kun, I appreciate it :) now i know not to waste more time trying
19:06:33 <cmccann> Phyx-, actually, got one more suggestion, gimme a moment to try something
19:06:41 <Eduard_Munteanu> phiV: if you're not behind NAT
19:07:02 <Phyx-> cmccann: sure :)
19:07:10 <phiV> Eduard_Munteanu: I'm behind a router
19:07:23 <ski> phiV : if your IRC client is on your home computer, you could `/whois' yourself
19:07:55 <Phyx-> or, ipchicken.com
19:07:56 <Eduard_Munteanu> phiV: then you'll have to configure port forwarding or put yourself into the DMZ.
19:08:10 <Phyx-> or what i like to give people with speakers on.. moanmyip.com
19:08:11 <Phyx-> lol
19:08:22 <phiV> Eduard_Munteanu: is the only way to do that through a router?
19:08:31 <Phyx-> ^^ that last link is funny
19:09:15 <Castizo> Hi!  I am a gay BDSM enthusiast, and my last name is Haskell!
19:09:34 <pisum> hehe :D
19:09:34 <Axman6> ok?
19:09:40 <phiV> lol cool story bro
19:09:42 <Phyx-> Eddy Haskell?
19:09:46 <Phyx-> that you bro?
19:09:51 <Eduard_Munteanu> phiV: you have to tell it some way or another to forward inbound packets on that specific port to your computer.
19:09:52 <Castizo> Juan Haskell
19:09:52 <Phyx-> I've been looking for you!
19:10:05 <Castizo> I am the head of the Bondage Society of Hermosillo
19:10:25 <phiV> Eduard_Munteanu: k, thanks for your help eduard
19:10:37 <Eduard_Munteanu> @vixen Do you like it rough?
19:10:37 <lambdabot> yeah, i like
19:11:42 <roconnor> @type properFraction
19:11:43 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
19:12:34 <roconnor> joe6: Ashley in now preparing a version where DiffTime is an instance of RealFrac
19:13:01 <Phyx-> hmm my code is locking up...
19:13:03 <Phyx-> wonder why...
19:13:07 <joe6> roconnor: cool, thanks a lot for acting upon it.
19:13:21 <Phyx-> how i wish ghc could produce .pdb files :(
19:13:36 <ski> > properFraction (1 :: CReal)
19:13:37 <lambdabot>   (1,0.0)
19:21:09 <Axman6> @src Sum
19:21:09 <lambdabot> Source not found. I am sorry.
19:21:12 <Axman6> bah
19:21:23 <Eduard_Munteanu> @index Sum
19:21:24 <lambdabot> bzzt
19:21:34 <Axman6> i've forgotten how to use record syntax D:
19:21:46 <Axman6> ah, maybe not
19:22:27 <ski> > Sum {getSum = 2}
19:22:28 <lambdabot>   Sum {getSum = 2}
19:22:43 <ski> > fix (\sum -> sum {getSum = 2})
19:22:43 <lambdabot>   Sum {getSum = 2}
19:24:30 <hpaste> axman6 pasted “parser.hs” at http://hpaste.org/50114
19:24:46 <Axman6> can anyone see what i've done wrong here?
19:25:43 <Axman6> i'm getting 'Couldn't match type `a' with `b'', which isn't particularly helpful
19:25:48 <ski> `(Parser p) >>= f' could be `Parser p >>= f'
19:26:00 <ski> `return x = Parser $ \ts -> (x,ts)' should probably be `return x = Parser $ \ts -> Right (x,ts)'
19:26:07 <Axman6> ah yes
19:26:28 <Axman6> i'm still getting problems with the type of >>=
19:26:41 <Axman6> (which i should have pasted..., i shall do that now)
19:26:43 <ski> `x   -> x' unfortunately have to be expanded
19:26:55 <ski> (i complained about exactly that a few hours ago ..)
19:27:00 <Axman6> ah yes, that would be right -_-
19:27:35 <Axman6> thanks ski. i keep forgetting the compiler can't infer that x has to be a Left value
19:28:01 <ski> imo, it ought to be able to infer that :)
19:28:31 <ski> (i.e. that `x' has type `forall a. Either String (a,[Token])', there)
19:30:19 * hackagebot time 1.3 - A time library  http://hackage.haskell.org/package/time-1.3 (AshleyYakeley)
19:30:25 <clsmith> i don't know, inferring that would seem weird to me
19:30:39 <ski> why ?
19:31:03 <ski> it's the next best thing to inferring that `x' has the respective subtype
19:31:09 <clsmith> because in that case, x is Left something
19:31:21 <clsmith> Left String
19:31:30 <ski> @type Left "some string"
19:31:31 <lambdabot> forall b. Either [Char] b
19:32:14 <ski> oh, i suppose you mean it should be `forall b. Either [Char] b', as opposed to the more restricted `forall a. Either String (a,[Token])'
19:32:55 <ski> yeah, i suppose i'd agree with that
19:39:25 <hatds> wow, I got ghci to define a name containing brackets [ ]
19:39:32 <hatds> using a TH splice
19:39:53 <hatds> but I can't refer to it
19:40:08 <kmc> haha
19:40:52 <kmc> it's the MissingNo. of Haskell identifiers
19:41:19 <aavogt> hatds: does   $(varE (mkName "[missingno]"))  work?
19:41:30 <phiV> hey I have a question: what type of server does a multiplayer game use?
19:41:38 <phiV> obviously hot HTTP
19:41:41 <phiV> not*
19:41:52 <hatds> aavogt: not sure, this was using "newName"
19:41:58 <kmc> phiV, HTTP is definitely an option
19:41:59 <hatds> one sec
19:42:13 <phiV> kmc: but I doubt minecraft uses HTTP.
19:42:16 <kmc> HTTP is used for bloody *everything* these days
19:42:24 <kmc> but a lot of games use their own custom protocol on top of TCP or UDP
19:42:57 <phiV> so they make their custom server sending and receiving TCP and UDP?
19:43:01 <phiV> how slow is HTTP?
19:43:10 <phiV> for a real time game
19:43:35 <kmc> that depends entirely on the speed of the software at either end
19:43:35 <shachaf> phiV: From what I hear, taking design decisions from Minecraft might not be wise. :-)
19:43:37 <aavogt> hatds: with newName you need to keep the result Name around as long as you want to refer to the variable
19:43:45 <shachaf> phiV: It's almost 8.4 slowness units.
19:43:48 <phiV> shachaf: lol just an example
19:43:48 <kmc> HTTP doesn't necessarily add much overhead
19:43:54 <hpaste> hatds pasted “ghci TH bug” at http://hpaste.org/50117
19:44:09 <parcs> phiV: http adds a couple of bytes of overhead
19:44:24 <shachaf> A couple of bytes?
19:44:28 <phiV> I guess the best way to know is to try it myself
19:44:31 <Saizan> aavogt: that's no longer true in ghc-7.2.1 apparently, and it's a mess
19:44:35 <kmc> HTTP doesn't add much overhead but it doesn't give you many advantages either
19:44:53 <hatds> aavogt: heh, this was just so I could splice decls without creating duplicate definition errors
19:44:59 <singpoly1a> Anyone have ideas on how to solve this:  http://hackage.haskell.org/packages/archive/openpgp/0.1/logs/failure/ghc-7.0  ?
19:45:08 <kmc> phiV, i advise against implementing a protocol from scratch
19:45:19 <kmc> you will make mistakes
19:45:31 <kmc> those mistakes can have exploitable security consequences, especially if you're writing it in C
19:45:40 <phiV> kmc: what's a good protocol to use for a real time game then?
19:45:45 <Saizan> aavogt: http://hackage.haskell.org/trac/ghc/ticket/5398
19:45:52 <phiV> is HTTP my best bet for starting out
19:46:03 <shachaf> kmc: Well, it depends on how simple the protocol is.
19:46:05 <kmc> use somebody else's solution to the question "how do i encode this structured data as bytes"
19:46:12 <kmc> HTTP doesn't do that for you either
19:47:10 <kmc> i'm talking about Protobuf or Thrift or ASN.1 or BSON or JSON or XML or YAML or ...
19:47:17 <kmc> this particular wheel has been reinvented many, many times
19:47:58 <kmc> JSON inside HTTP is a popular option
19:48:04 <Eduard_Munteanu> There was some general-purpose message passing protocol over TCP, I don't remember the name
19:48:04 <kmc> phiV, how "real time" is your game?
19:48:29 <Eduard_Munteanu> Anyway, I can't see how HTTP fits the bill, though.
19:48:29 <kmc> how many messages/sec, how big are the messages, and what guarantees do you need on latency?
19:48:38 <shachaf> What kmc is hinting at is that you should use more XML than was previously thought possible.
19:48:56 <phiV> kmc: like real time actions (shooting, FPS, etc)
19:49:04 <kmc> ok
19:49:08 <kmc> look at Thrift
19:49:10 <kmc> and Protobuf
19:49:28 <ezyang> "An Oleg a Day, Keeps the Type System Away"
19:49:28 <phiV> k
19:49:51 <kmc> shachaf, a rack full of these: http://www-01.ibm.com/software/integration/datapower/xa35/
19:50:01 <Eduard_Munteanu> Something like UDP or SCTP might be a better pick than TCP.
19:50:03 <Saizan> how can you have your oleg without a type system?
19:50:22 <Eduard_Munteanu> *something working over
19:50:24 <shachaf> "XML Acceleator"?
19:50:35 <shachaf> I hope they do it completely in hardware.
19:50:53 <kmc> "in hardware"
19:51:05 <kmc> they'll also sell you an XML Processor for your zSeries mainframe
19:51:16 <hatds> aavogt: mkName "[missingno]" fails when the decl is spliced, but mkName "foo_[missingno]"  doesn't
19:51:27 <kmc> which means they turn on an additional CPU, and tell it that it can't do anything except XML
19:51:38 <kmc> which is cheaper than getting them to turn it on with no restriction
19:51:42 <shachaf> That sounds like just what I need.
19:52:33 * shachaf can't tell whether kmc is serious anymore.
19:53:29 <shachaf> Wait, you actually are serious.
19:54:02 <shachaf> "Currently a zAAP engine contains the same underlying hardware as any other mainframe engine. However, IBM uses microcode to limit code execution to Java and XML workloads only."
19:54:10 <kmc> oh i forgot that it does Java too
19:54:25 <kmc> really what else do you need
19:54:46 <kmc> did anyone invent an XML-based alternative syntax for Java yet
19:54:56 <hatds> lol
19:56:22 <mauke> Peaker: the problem with making F:P argument checking stricter is that you really, really want default arguments to make it useful
19:56:38 <shachaf> kmc: The first time I read about Ant I thought it was a joke.
19:56:39 <cmccann> kmc, no they just use XSLT for that
19:56:40 <mauke> Peaker: and that basically means parsing arbitrary perl expressions in the parameter list
19:56:44 <Eduard_Munteanu> Or a CPU which parses an XML tree and executes statements :P
19:57:02 <cmccann> if memory serves me XSLT is turing-complete so yeah
19:58:14 <DevHC> a ghc.core file... hmm...
19:58:26 <kmc> <class visibility="public" name="Foo"><method name="main" visibility="public" linkage="static"><returntype><void /></returntype><args><arg><argtype><array><string /></array></argtype><argname>args</argname></arg></args><body><expression><call><callee><qualname><name>System</name><name>out</name><name>println</name></qualname></callee><args><arg><literal type="string">Hello, world!</literal></arg></args></body></method></class>
19:58:56 <kmc> romulans on the enterprise
19:59:15 <cmccann> kmc, congratulations you've actually found a way to make java more verbose
19:59:33 <kmc> and the best part is, you can pass it through XML-in-XML a few more times
19:59:39 <Eduard_Munteanu> <instruction name="mov"><operand type="register">...
19:59:40 <kmc> to add the appropriate amount of enterprise
20:00:04 <mauke> http://harmful.cat-v.org/software/xml/xml_ascent.png
20:00:14 <kmc> <tag><name>class</name><attribute><name>visibility</name><value>public</value</attribute> ...
20:00:30 <kmc> exactly mauke
20:01:09 <shachaf> kmc: Looks like you have a lot of practice writing XML.
20:01:18 * shachaf is envious.
20:01:53 <joe6> i have a situation where I write a data bit and toggle the clock bit for every write of the data bit. Should I be using the State Monad to hold the status of the clock bit?
20:02:03 <joe6> bit 0 = Clock Bit, bit 1 = Data Bit.
20:02:25 <kmc> do you need to read that clock bit?
20:02:35 <kmc> > zip (cycle "01") "hello world"
20:02:36 <joe6> and I need to know the status of the Clock bit everytime I change the Data bit.
20:02:36 <lambdabot>   [('0','h'),('1','e'),('0','l'),('1','l'),('0','o'),('1',' '),('0','w'),('1'...
20:02:39 <kmc> ok
20:02:52 <joe6> kmc, that is cool.
20:03:01 <joe6> kmc, i do not need to read that clock bit.
20:03:49 <joe6> kmc, that is awesome in its' simplicity.
20:06:10 <Eduard_Munteanu> You can flip bits using a XOR mask without keeping track of the actual value there, in ppdev.
20:06:20 <Eduard_Munteanu> PPFROB or something like that, IIC
20:06:22 <Eduard_Munteanu> *IIRC
20:12:23 <aavogt> are there any existing FFI tools using DWARF symbols rather than looking at the source code?
20:12:54 <kmc> o_O cool idea
20:13:16 <aavogt> somebody mentioned it some months ago
20:15:06 <Eduard_Munteanu> Hm, you need the source code to write FFI bindings?
20:15:30 <kmc> no, but if you want to *auto-generate* bindings, parsing the source is one approach
20:15:52 <Eduard_Munteanu> Or a header file, I guess.
20:16:00 <kmc> the only information you need to write FFI bindings to C libs is the same information you'd need to write a C program using that lib
20:16:17 <kmc> which is most convenient to use in C header file form
20:16:25 <kmc> but could be conveyed otherwise
20:16:31 <hatds> is there no way to turn a string like "global = 1" into a TH Declaration?  The declaration quote [d| some_str |] doesn't work apparently ("Declaration splices are not permitted inside declaration brackets")
20:17:09 <joe6> Eduard_Munteanu: that is an option too.. thanks.
20:17:56 <shachaf> hatds: Is some_str a literal [Char]?
20:18:17 <shachaf> hatds: [d| global = 1 |] should work.
20:19:28 <hatds> shachaf: [d| global = 1 |] does work, but that is using a string from the source code directly.  I want to generate a string and feed it into [d| ... |]
20:20:20 * hackagebot GenericPretty 1.0.0 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-1.0.0 (RazvanRanca)
20:22:53 <shachaf> hatds: You want to generate it completely from a String? Why?
20:23:05 <joe6> is there a better way of doing this: showIntAtBase 2 intToDigit (10::Word8) ""
20:23:09 <joe6> > showIntAtBase 2 intToDigit (10::Word8) ""
20:23:10 <lambdabot>   "1010"
20:23:15 <shachaf> > "1010"
20:23:16 <lambdabot>   "1010"
20:23:54 <joe6> shachaf: haha..
20:24:06 <shachaf> Hexadecimal and octal have functions for that; I don't know if there's one for that.
20:24:11 <shachaf> (What kind of weird base is 2, anyway?)
20:24:16 <joe6> binary?
20:24:48 <shachaf> Right, who came up with that?
20:24:49 <hatds> shachaf: it's for an EDSL.  I want to basically do [d| some_str |] where some_str is normal haskell source code passed through a simple String->String function
20:26:20 <joe6> shachaf: i am trying to convert a Word8 into a list of binary digits.
20:26:39 <joe6> such as 9 :: Word => [1,0,0,1]
20:27:00 <joe6> something like this: http://pastebin.com/ehqRd4zs
20:27:17 <joe6> found it at : uri: http://stackoverflow.com/questions/1959715/how-to-print-integer-literals-in-binary-or-hex-in-haskell
20:28:28 <Axman6> > let b 0 = []; b n = case divMod n 2 of (r,d) -> b r ++ [d] in b 123
20:28:29 <lambdabot>   [1,1,1,1,0,1,1]
20:29:21 <Axman6> > let b 0 = []; b n = case divMod n 2 of (r,d) -> b r ++ [d]; make = foldl (\x a -> 2*a + x) 0 in make $ b 123
20:29:22 <lambdabot>   <no location info>: parse error on input `='
20:29:51 <Axman6> > let b 0 = []; b n = case divMod n 2 of (r,d) -> b r ++ [d] in b 42
20:29:53 <lambdabot>   [1,0,1,0,1,0]
20:30:00 <Axman6> hooray, it works
20:30:02 <Axman6> > let b 0 = []; b n = case divMod n 2 of (r,d) -> b r ++ [d] in b 0
20:30:03 <lambdabot>   []
20:30:06 <Axman6> > let b 0 = []; b n = case divMod n 2 of (r,d) -> b r ++ [d] in b 1
20:30:07 <lambdabot>   [1]
20:30:09 <Axman6> > let b 0 = []; b n = case divMod n 2 of (r,d) -> b r ++ [d] in b 2
20:30:11 <lambdabot>   [1,0]
20:34:02 <parcs> > unfoldr (\x -> guard (x/=0) >> return (swap (x `divMod` 2))) 42
20:34:03 <lambdabot>   Not in scope: `swap'
20:35:03 <baguasquirrel> did you mean "flip"?
20:35:28 <parcs> > reverse $ (0:) $ unfoldr (\x -> guard (x/=0) >> return (x `mod` 2, x `div` 2)) 42
20:35:28 <lambdabot>   [1,0,1,0,1,0,0]
20:35:53 <ski> @let swap = arr snd &&& arr fst
20:35:54 <lambdabot>  Defined.
20:36:11 <parcs> > reverse $ unfoldr (\x -> guard (x/=0) >> return (swap (x `divMod` 2))) 42
20:36:12 <lambdabot>   [1,0,1,0,1,0]
20:36:14 <baguasquirrel> my bad
20:36:23 <shachaf> @ty \p f x -> guard (p x) >> return (f x)
20:36:24 <lambdabot> forall t (m :: * -> *) b. (MonadPlus m) => (t -> Bool) -> (t -> b) -> t -> m b
20:36:57 <shachaf> Does that exist?
20:37:31 <shachaf> @hoogle (MonadPlus m) => (t -> Bool) -> (t -> b) -> t -> m b
20:37:31 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
20:37:31 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
20:37:31 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
20:37:34 <shachaf> @hoogle (a -> Bool) -> (a -> b) -> a -> Maybe b
20:37:34 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
20:37:35 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
20:37:35 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
20:37:38 <aavogt> @ty on (>>) (guard . p) f
20:37:39 <lambdabot>     Couldn't match expected type `a -> Bool'
20:37:39 <lambdabot>            against inferred type `Expr'
20:37:39 <lambdabot>     In the second argument of `(.)', namely `p'
20:37:43 <ski> @type \p f g x -> (if p x then f else g) x  -- is sometimes called `cond'
20:37:43 <lambdabot> forall t t1. (t -> Bool) -> (t -> t1) -> (t -> t1) -> t -> t1
20:38:01 <shachaf> Oh, I guess there's that.
20:38:03 <aavogt> @ty liftM2 (>>) (guard . p) f
20:38:04 <lambdabot>     Couldn't match expected type `m Bool' against inferred type `Expr'
20:38:04 <lambdabot>     In the second argument of `(.)', namely `p'
20:38:04 <lambdabot>     In the second argument of `liftM2', namely `(guard . p)'
20:38:16 <aavogt> @ty \p f -> liftM2 (>>) (guard . p) f
20:38:17 <lambdabot> forall (m :: * -> *) b (m1 :: * -> *). (MonadPlus m, Functor m1, Monad m1) => m1 Bool -> m1 (m b) -> m1 (m b)
20:39:02 <joe6> map (testBit (8::Word8)) [0..(4-1)]
20:39:05 <joe6> > map (testBit (8::Word8)) [0..(4-1)]
20:39:06 <lambdabot>   [False,False,False,True]
20:40:20 * hackagebot terminfo 0.3.2.1 - Haskell bindings to the terminfo library.  http://hackage.haskell.org/package/terminfo-0.3.2.1 (JudahJacobson)
20:53:04 <ItBlends> is there some way to get cabal-install to compile/link on a remote machine? The link step crushes my poor netbook
20:53:14 <kmc> swap over nfs
20:54:36 <kmc> you can download the tarball, "cabal build" it on the other machine, copy that dir, "cabal install
20:54:38 <kmc> "
20:54:44 <fengshaun> is it possible to write a case expression all in one line?
20:55:21 <ItBlends> kmc, would it matter if the other machine is 64 bit and the netbook is 32?
20:55:32 <shachaf> > case True of True -> True
20:55:33 <lambdabot>   True
20:55:49 <aavogt> > case 1 of 0 -> 'a'; 1 -> 'b'
20:55:50 <lambdabot>   'b'
20:56:01 <fengshaun> aavogt: oh, the semicolon, thanks a lot!
20:56:04 <kmc> ItBlends, yes
20:56:17 <fengshaun> aavogt: although I would say that's bad practice, right?
20:56:36 <shachaf> ItBlends: You can also use { } for e.g. nesting.
20:56:59 <ddarius> You can write any Haskell program all in one line.
20:57:10 <shachaf> ddarius: Not true.
20:57:10 <kmc> ItBlends, i'd set up a 32-bit VM, but a chroot is probably enough
20:57:17 <shachaf> ddarius: Some programs require more than one module.
20:57:32 <hatds> fengshaun: not bad practice unless the line gets too long
20:57:34 <aavogt> if it's short like that example, I'm not sure you'll bother most people to use a ;
20:57:47 <fengshaun> hatds: thanks a lot!
20:58:29 <fengshaun> aavogt: it's actually not that short, but I was wondering about the possibility.  It's nice to know I *can* do it if I wanted to!
20:58:32 <fengshaun> thanks!
21:01:13 <hatds> if I need to recursively install a bunch of packages in order to install one package foo that depends on them, can cabal automate any of this for me?
21:01:24 <kmc> yes, that's what "cabal install" does
21:01:31 <kmc> you can "cabal install foo" to download from hackage
21:01:38 <kmc> or just "cabal install" inside the directory
21:01:45 <hatds> I must not be looking at the right place for documentation
21:02:27 <hatds> http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package says to recursively follow these instructions :)
21:02:29 <ddarius> shachaf: A while back Hal Daume III made a tool that would put all the source code of a program into one module.
21:02:34 <shachaf> I kind of dislike that "guess what I want" behavior of Cabal.
21:03:09 <shachaf> I'm always nervous typing "cabal install foo" when I happen to be in a directory with a .cabal file.
21:03:45 <shachaf> ddarius: Did it work with TH quasiquotation?
21:03:57 <shachaf> I suppose that's not official Haskell.
21:05:19 <shachaf> s/ quasiquotation//
21:05:24 <rwbarton> you could expand the TH first
21:05:55 <hpaste> jeeez pasted “problem8_99qs” at http://hpaste.org/50119
21:06:03 <jeeez> hi, a function i wrote works correctly when i pass ['h','e','l','l','o'], but not for "hello"... aren't both [Char]?
21:06:15 <aavogt> there's this rotted utility for rwbarton's suggestion http://hackage.haskell.org/package/zeroth
21:06:16 <shachaf> jeeez: Not if you use -XOverloadedStrings
21:06:55 <jeeez> shachaf: i just ran `ghci`, is it a default i should override?
21:07:31 <hatds> no, that extension is off by default
21:07:31 <shachaf> jeeez: No, it's off by default.
21:07:44 <shachaf> jeeez: If you're referring to your consecEl example, it should work fine for either.
21:07:45 <hatds> you can verify with :show languages if need be
21:08:19 <aavogt> shachaf: supposedly an implementation of TypeCast (in HList) works only when the couple instances/classes are compiled separately
21:08:24 <shachaf> shachaf@argon:~$ wc -l .ghci # 29 .ghci
21:08:34 * shachaf is still not satisfied.
21:09:13 * cmccann prefers "~" as an implementation of TypeCast
21:09:55 <hatds> jeez: it should be the same, can you paste the function and what goes wrong?
21:10:09 <ddarius> shachaf: TH of any sort was pretty new then.
21:10:40 <jeeez> shachaf: consecEl isn't working same for both the inputs
21:11:52 <shachaf> > let consecEl [] = []; consecEl [x] = [x]; consecEl (x:rem@(y:xs)) | x == y = x:(consecEl xs) | otherwise = x:(consecEl rem) in consecEl "hello"
21:11:53 <lambdabot>   "helo"
21:12:43 <hatds> both give "helo" for me
21:13:25 <hatds> check for typos maybe? "hel1o" ;)
21:13:35 <hpaste> jeeez pasted “q8 code & o/p” at http://hpaste.org/50120
21:13:43 <jeeez> i've posted it
21:14:19 <shachaf> jeeez: "hello" isn't the same thing as ["hello"]
21:14:21 <hatds> ["hello"] :: [String]
21:14:28 <coppro> uh duh
21:20:20 * hackagebot GenericPretty 1.0.1 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-1.0.1 (RazvanRanca)
21:22:39 <ddarius> It's raining a lot tonight.
21:22:53 <joe6> dataInEEnable  w =  w {wdDataInEnable = Bit True}
21:23:09 <joe6> i have more than a few functions in that format.
21:23:27 <joe6> i am wondering if I can do something like: trueField w f = w {f = Bit True}
21:23:45 <joe6> where the fieldname is a parameter to that function..
21:24:03 <joe6> ghci fails with this message: `f' is not a (visible) constructor field name
21:24:15 <joe6> just curious if there is a different way of doing that..
21:24:19 <shachaf> No (what would the type of it be?), but look at e.g. fcLabels.
21:24:25 <shachaf> @hackage fclabels
21:24:25 <lambdabot> http://hackage.haskell.org/package/fclabels
21:25:12 <joe6> templateHaskell magic?
21:25:29 <shachaf> Only for mkLabels, but you can write them yourself if you want.
21:26:43 <joe6> shachaf: very interesting. Thanks.
21:30:30 <jeeez> shachaf, hatds silly me, thanks
21:41:09 <Phyx-> that's odd.. across multiple execution of my program, the address i get back from a StablePtr is always the same (I only have one)
21:41:40 * Phyx- wonders how it's implemented
21:44:08 <kmc> afaik they are indexes into a table
21:46:43 <kmc> they're not guaranteed to be valid pointers
21:53:54 <Phyx-> kmc: makes sense
21:54:31 <ddarius> Wouldn't pointers still be pretty stable?
21:54:33 <Phyx-> I just noticed it because when in the debugger it would always have the same value filled in
21:55:27 <Phyx-> ddarius: if they were valid pointers, I wouldn't expect them to be at the same address every time
21:55:35 <ddarius> Why not?
21:55:42 <kmc> ASLR
21:55:59 <kmc> things can move around during GC
21:56:06 <kmc> which is what makes a raw heap pointer not "stable"
21:56:13 <Phyx-> what kmc said :)
21:57:15 <ddarius> kmc: Yes, but if there are no GCs before the stable pointer, why would it be different?  Even with GCs everything is deterministic.
21:57:51 <kmc> oh, you meant "stable" in the other sense, Phyx-'s original observation
21:59:02 <kmc> also doesn't the GHC RTS do context-switching and garbage collection based on a realtime clock?
21:59:07 <kmc> see RTS options -C and -V
21:59:45 <ddarius> kmc: I can easily see Phyx- allocating the StablePtr before any GC is done.
21:59:52 <kmc> sure
22:00:04 <ddarius> If he is using threads, then context-switching matters, but if not, then it doesn't matter.
22:00:20 <kmc> it matters because it's a potential GC point,
22:00:21 <kmc> iirc
22:00:27 <kmc> anyway i think we are on the same page
22:00:30 * kmc maps page 0
22:00:45 <ddarius> My little OS core unmaps page 0.
22:01:13 <Phyx-> granted, what about kmc's original point though ASLR, even if done before any GC, the location of the heap itself should be different and hence a raw pointer in it too
22:01:21 <Phyx-> or am I missing something here
22:01:37 <ddarius> Yes, ASLR would probably cause the addresses to be different.
22:01:50 <ddarius> ASLR is more widely used than I thought it was.
22:02:09 <kmc> afaik it's on by default in all modern Linux distros and in Windows
22:02:16 <Phyx-> and Mac Os
22:02:26 <Phyx-> since 10.5 according to wiki pedia
22:02:36 <kmc> though there are various caveats
22:02:37 <ddarius> kmc: Pretty much everything does it by "default" nowadays to varying degrees.
22:02:49 <kmc> relocating program text is harder
22:03:03 <kmc> that matters if you want to mitigate ROP attacks
22:03:46 <ddarius> ROP looks fun.
22:04:13 * Phyx- did not know about rop
22:04:41 * Phyx- downloads whitepaper
22:04:42 <kmc> http://cseweb.ucsd.edu/~hovav/dist/geometry.pdf
22:04:56 <kmc> is the original paper presenting the idea
22:05:03 <Phyx-> ooh
22:05:27 * Phyx- wishes he could come up with clever paper titles too
22:05:44 <kmc> 1) read bob dylan lyrics 2) ??? 3) clever title
22:06:03 <Phyx-> thanks kmc, now I have something to read in the car tomorow :)
22:06:18 <Phyx-> lol, bob dylan
22:06:29 <kmc> i like how it's an academic paper in LaTeX, yet the bibliography cites people named "dark spyrit" and "riq"
22:06:32 <kmc> infosec is a funny field
22:06:50 <kmc> \begin{greetz}
22:06:54 <Phyx-> lol
22:07:02 <ddarius> The follow-on work is somewhat more interesting.
22:07:06 <kmc> ddarius, which?
22:07:08 <Phyx-> I know one guy in the field
22:07:16 <Phyx-> he's usually funny, but he turns on a dime
22:07:28 <Phyx-> without warning he'll go dead serious on you
22:07:48 <Phyx-> ddarius: got a link?
22:08:32 <ddarius> http://cseweb.ucsd.edu/~hovav/papers/brss08.html
22:08:33 <kmc> other security papers i've recently enjoyed include http://www.phrack.org/issues.html?issue=57&id=15 and http://www.semantiscope.com/research/BHDC2010/BHDC-2010-Paper.pdf
22:09:11 <kmc> yeah, the "jump into the middle of an instruction" aspect of ROP is not fundamental
22:09:23 <ivanm> preflex: seen dmead
22:09:24 <preflex>  dmead was last seen on #haskell 3 days, 14 hours, 58 minutes and 47 seconds ago, saying: @hoogle fmap
22:09:35 <kmc> it's just a way to get a lot more gadgets
22:09:45 <ivanm> @tell dmead you may want to fix the maintainer field in the cabal file for your clojure converter...
22:09:45 <lambdabot> Consider it noted.
22:09:52 <kmc> but this paper looks like it has the juicy PL content kids crave
22:10:31 <Phyx-> kmc: that text file looks like someone spend a great deal f time making it
22:10:41 <Phyx-> and thanks ddarius
22:11:00 <kmc> this is as good a time as any to plug http://io.smashthestack.org:84/
22:12:02 <Phyx-> hmm "Interpreter exploitation: Pointer inference and JIT" looks interesting
22:13:24 <cmccann> Phyx-, btw I didn't get the thing I was trying to do for your FFI conversion stuff to work properly :T
22:14:16 <Phyx-> cmccann: ah, that's ok, appreciate the effort :)
22:14:21 <ddarius> The depressing thing about so much black hat work is that much of it is just exploiting stupidity.
22:14:31 <Phyx-> hahahaha
22:14:44 <Phyx-> and that likely the next week it's all patched
22:15:10 <dmwit> kmc: haha, "It's probably a good idea to disable javascript when browsing the links below!"
22:15:19 <cmccann> Phyx-, was trying to do something cute with type families to deduce the ideal types and make it all combine nicely but it didn't work very well and I didn't feel like breaking out the heavy-duty type hackery :T
22:15:20 * hackagebot yap 0.0 - yet another prelude - a simplistic refactoring with algebraic  classes  http://hackage.haskell.org/package/yap-0.0 (RossPaterson)
22:15:31 <ddarius> Phyx-: Only by the not stupid.
22:16:31 <Phyx-> cmccann: I'll read up on type families and give it a go then
22:16:35 <Phyx-> ddarius: true
22:16:38 <ivanm> ooohhh, yap has a polynomial module...
22:17:50 <ivanm> but it's only polynomials, not multinomials :(
22:17:57 <cmccann> Phyx-, type families give you a simple sort of function on types, I was trying to do something where it would map a given type to its native equivalent, and to the contexts needed for conversion in each direction, but combining things was too awkward because of non-injectivity
22:18:04 <ddarius> One of the more interesting things I've read in computer security recently is Appel's paper on attacking JVMs via memory errors.
22:18:50 <Phyx-> The last thing i saw was a video on a talk about how absolutely bonkers pdfs files are. i think it was a mauke link
22:19:01 <cmccann> it's sort of a rule of thumb in computer security that doing anything interesting in any way is probably a security hole somehow
22:19:38 <ddarius> Phyx-: What was considered "bonkers" about PDF files?
22:20:17 <ivanm> Phyx-: referring to javascript in PDF files
22:20:18 <ivanm> ?
22:20:19 <Phyx-> ddarius: that you can pretty much do anything with them and some pdf readers like adobe's would happily execute them
22:20:21 <dmwit> ?remember cmccann it's sort of a rule of thumb in computer security that doing anything interesting in any way is probably a security hole somehow
22:20:21 <lambdabot> Done.
22:20:25 <cmccann> like timing how long it takes for a bad password to be rejected and working backwards to get statistical information about what the correct password looks like
22:20:35 <Phyx-> heck, he showed one pdf that doubled as a pdf and a zip file
22:20:37 <cmccann> that one really surprised me the first time I heard of it
22:20:44 <ivanm> Phyx-: :o
22:20:48 <ddarius> Phyx-: PDF is a restricted sub-language of postscript which is explicitly a Turing complete programming language.
22:21:01 <mauke> ddarius: no, PDF is far more insane than that
22:21:04 <Phyx-> cmccann: hm so it would automatically determine if IO was needed?
22:21:36 <dmwit> Phyx-: huh?
22:22:09 <ddarius> mauke: Modulo a library import, technically every file that starts with a valid postscript identifier could be a valid postscript file, no matter what follows it.
22:22:14 <cmccann> Phyx-, yeah, like for Float it would leave the type unchanged, but for [a] it would add an IO context to the result of a function
22:22:15 <Phyx-> dmwit: you're gonna have to be more specific :P
22:22:25 <fengshaun> is it just me or there are other people who enjoy writing one-liners just for the sake of it being a one-liner?
22:22:41 <fengshaun> are there*
22:22:42 <dmwit> Phyx-: What do you mean, automatically determine if IO was needed?
22:22:43 <Phyx-> cmccann: hmm that sounds awesome, I'll definitely give it a go then
22:23:01 <cmccann> Phyx-, but like I said it didn't end up working out very well for a variety of reasons somewhat inherent to how type families work
22:23:15 <dmwit> Phyx-: Oh, you weren't talking about the password reverse-engineering attack. Never mind, I retract my "huh?".
22:23:22 <Phyx-> dmwit: lol
22:23:42 <dmwit> fengshaun: Oh my yes.
22:23:43 <cmccann> Phyx-, but maybe a slightly different approach would be viable, since the problem isn't intrinsic to the idea, just the way I was doing it
22:24:21 <Phyx-> cmccann: ah ok, guess now is a good time as any to learn about type families. I vaguely remember them.
22:24:25 <mauke> ddarius: http://www.youtube.com/watch?v=54XYqsf4JEY is the talk
22:24:54 <fengshaun> dmwit: :) good thing I'm not alone!
22:26:08 <hpaste> “C. McCann” pasted “not gonna work but oh well” at http://hpaste.org/50121
22:26:18 <cmccann> Phyx-, that's the gist of what I was doing
22:26:21 <cmccann> well, trying to do.
22:26:41 <cmccann> probably a dead end but maybe offers some inspiration?
22:27:28 <ddarius> mauke: As far as I know, every PDF file is still a valid postscript file modulo a library of definitions.  Admittedly, PDF provides much more "standard" semantics than postscript did.
22:28:05 <Phyx-> cmccann: cool, thanks!
22:28:30 <ivanm> ddarius: especially if you use one of the archival PDF formats
22:28:35 <Phyx-> ddarius: every? how about those with JS or flash embedded?
22:28:47 <mauke> ddarius: that would surprise me
22:30:10 * cmccann thinks ddarius's point is that, given a sufficient quantity of willful absurdity, postscript ends up being little more than a file saying "here's a program; run it!"
22:30:24 <Phyx-> cmccann: hmm think I understand what you were trying to do
22:30:32 <ddarius> mauke: Worst-case scenario, as I said, the first token could be an entire parser and intepreter for PDF.  However, you certainly could not provide the semantics of everything PDF provides using only the "standard" semantics of postscript.  For example, there is no way to pop-up a window in postscript.
22:30:59 <ddarius> cmccann: A postscript file is a program.
22:31:44 <ivanm> IIRC, I've seen a webserver written in postscript...
22:33:00 <cmccann> Phyx-, unfortunately calculating the types for functions ended up being intractable, because type families aren't injective (you can't work backwards from "Foo a" to "a") and because there's no way to return a true identity function on types in a standalone manner
22:34:18 <dolio> Why does my portable document format need to render OpenGL and access arbitrary databases on my machine?
22:36:01 <ddarius> For the same reason your browser needs to.
22:36:02 <Phyx-> cmccann: how do they behave if you for instance have a call to toNative inside a definition of toNative, does that force the cxts to be the same for both?
22:36:32 <Phyx-> ddarius: to get exploited?
22:36:51 <cmccann> ddarius, hunh, now that I look at more information about postscript, I think I significantly underestimated the extent to which that is true, rather than it being some sort of data format with scripts tacked on
22:37:20 <ddarius> It is explicitly and unambiguously a Turing-complete programming language.
22:37:43 <cmccann> Phyx-, in my example? supposedly it would collapse contexts, but that's another awkward part I didn't get working, sadly.
22:37:44 <ddarius> It's actually a reasonably nice one other than the library being annoying due to being aimed a devices with limited resources.
22:38:03 <Phyx-> cmccann: ah okk
22:38:27 <Phyx-> eek, 2 am, bed time
22:38:28 <cmccann> being turing-complete is actually pretty useful for theoretically descriptive files
22:38:30 <Phyx-> gn everyone
22:38:38 <Phyx-> cmccann: thanks for the help!
22:38:42 <cmccann> Phyx-, sure thing
22:38:47 <Phyx-> cmccann++
22:38:48 <Phyx-> :)
22:39:48 <ddarius> cmccann: Yes, I want my printer to get into an infinite loop
22:40:36 <mauke> OM NOM NOM FEED ME PAPER
22:41:25 <cmccann> ddarius, power-cycling fixes a lot of problems, and in my experience printers tend to be unreliable anyway
22:41:38 <shachaf> mauke: Presumably "infinite loop" implies that the sheet of paper is connected.
22:41:55 <shachaf> cmccann: It could be that in your experience, PostScript programs are unreliable!
22:42:45 <cmccann> shachaf, perhaps!
22:43:41 <cmccann> ok, I need some sleep.
22:59:06 <ddarius> mauke: A lot of this talk seems to be "If I write something that is not a PDF file, Acrobat interprets in an arbitrary way."
23:00:22 <mauke> if adobe interprets it, it's a pdf
23:00:53 <pikhq_> mauke: PDF is a formally specified format.
23:00:53 <kmc> haha
23:01:07 <kmc> pdf as she is spake
23:01:15 <mauke> pikhq_: so is OOXML
23:01:57 <pikhq_> Yes. And as such, I'd feel perfectly justified in disregarding what Office does to it for considering whether something is valid OOXML.
23:02:12 <pikhq_> If they don't accept valid OOXML, well, that's their bug, isn't it?
23:02:44 <pikhq_> </platonicidealism>
23:03:00 <kmc> this is all well and good but you can still get people to execute your malicious Not PDF Files
23:03:14 <kmc> that's true even though they're Not PDF
23:03:28 <pikhq_> Pretty massive bug on Adobe's part, then, and certainly needs fixing.
23:03:34 * kmc designs a spec where any malicious document is definitionally out-of-spec
23:03:36 <ddarius> mauke: That would be fine except she is specifically saying that the PDF spec doesn't define behavior on files that are not PDF files anyway.
23:03:50 <pikhq_> My preferred solution would be to nuke Acrobat from orbit.
23:04:09 <pikhq_> ddarius: Behavior being undefined is no excuse for behavior being utterly retarded. :)
23:04:31 <ddarius> kmc: I'm not saying know how Acrobat behaves isn't useful and fascinating, but this talk is mostly about Acrobat not PDF.
23:04:43 <ddarius> Admittedly, there is plenty of completely insane stuff PDF can do.
23:05:42 <pikhq_> Such as Flash.
23:06:44 <pikhq_> And, really, almost everything that's not in Postscript.
23:06:48 <ddarius> Also, some of the behavior she seems confused about makes a reasonable amount of sense from the perspective of what is valid and invalid PDF.
23:07:09 <ddarius> pikhq_: The restrictions PDF originally imposed on postscript made a lot of sense.
23:07:43 <pikhq_> ddarius: The extensions it then made made little sense.
23:07:53 <pikhq_> And make less sense with the passing of time.
23:08:24 <pikhq_> Does a document format (a *document format*!) need public-key crypto?
23:14:22 <mux> http://www.haskell.org/pipermail/glasgow-haskell-users/2011-August/020718.html
23:15:20 * hackagebot prototype 0.2 - prototype-based programming on Haskell  http://hackage.haskell.org/package/prototype-0.2 (YoshikuniJujo)
23:18:01 <augur> koninkje_away: ping
23:38:04 <frerich> Does anybody have some good tips to keep in mind when prototyping software with Haskell? I think the language is a lot of fun, but most of the benefist seem to pay out only if you already know where you're going. Unfortunately, I often don't know exactly what pieces I need and how to fit them together upfront - and it seems that rewriting code seems to take a lot of time since I immediately get type errors.
23:38:23 <frerich> One trick I learned is that I can just make up functions with arbitrary types and implement them as 'undefined'. This is really great.
23:38:35 <kmc> yes
23:38:47 <kmc> type errors during refactoring are /great/
23:38:53 <kmc> that's how you know when you're done refactoring
23:38:59 <frerich> Oh I'm not even refactoring.
23:39:02 <frerich> I don't try to keep the behaviour.
23:39:06 <kmc> you can also keep the old version around and compare them automatically with QuickCheck
23:39:07 <kmc> ah
23:39:21 <frerich> I'm tinkering around, wondering whether I should have this as two functions or as one, or maybe this functions hould take an extra argument, and that one should yield a tuple.
23:39:33 <kmc> anyway in most cases a type error would be a runtime crash in another language
23:39:33 <frerich> I know what I want to know, but I don't quite know how to get there. So I tinker a lot.
23:39:53 <kmc> so if anything it takes less time, because you get more info up front
23:39:56 <kmc> of course there are exceptions
23:40:37 <frerich> One thing I'd love is to have ghci load just a single function from my source file. I noticed I often write some function and then play with it for a while to see whether it behaves. I have a bottom-up approach so far - writing most primitiev functions first and others on top.
23:40:45 <kmc> yeah
23:40:49 <frerich> I think "No matter how it will work in the end, I will need some function which does this"
23:40:52 <kmc> and the problem is that the file as a whole won't load?
23:40:59 <frerich> Yeah
23:41:14 <kmc> yeah, that would be a nice feature
23:41:25 <kmc> would not be all that difficult to implement as a little script
23:41:28 <kmc> maybe i'll do it some day
23:41:38 <frerich> What's *really* nice is how much support there is in the Prelude for plain old lists. That's awesome for prototyping
23:41:39 <ddarius> You could then bind that "little script" to a : command.
23:41:44 <kmc> yes
23:42:32 <kmc> yeah, another trick would be to make a "template" file with a bunch of imports
23:42:37 <kmc> that you copy when you start your prototype
23:42:51 <kmc> unfortunately you can't make this into an importable module itself
23:42:57 <kmc> because there's no way to re-export qualified names
23:43:02 <frerich> Oh, yes. That might be neat. I already noticed that the first thing I always write is 'import Data.List' :-)
23:43:15 <kmc> and many of my boilerplate imports are qualified
23:43:30 <kmc> then when you want to clean it up, "ghc -Wall" will tell you about unused imports
23:44:38 <frerich> I don't like dynamically typed languages and their barely predictable behaviour at runtime, but it's great that you can write buggy code for the sake of getting a better idea of how it should work in your mind.
23:44:58 <frerich> So far, I tend to do that in Python. It's broken, but after a few iterations I have a good idea how it could be structured - and then I start using Haskell.
23:45:17 <frerich> Just sketching code.
23:45:33 <kmc> yeah
23:45:48 <kmc> but you can do the same with "undefined" as you pointed out
23:45:56 <kmc> also you can leave off type signatures while prototyping
23:45:59 <kmc> and put them in later
23:46:03 <kmc> this will only occasionally bite you
23:46:24 <frerich> Oh, aactually, I find that type signatures are really helpful to my thinking. It's a tiny bit of typing work, but it helps me a lot.
23:46:34 <frerich> Granted, it causes errors sometimes.
23:47:54 <kmc> yeah, they are helpful for thinking, but slow you down if you're changing things rapidly
23:48:04 <kmc> you can leave them off and get the inferred types from ghci instead
23:48:16 <kmc> maybe some IDE / editor mode can insert the inferred signatures
23:48:30 <frerich> I have a vim plugin for that, yes.
23:49:20 <frerich> I like this approach of just writing type signatures and defining the functions as 'undefined' though. It's kind of drawing the outline of puzzle pieces without painting the interior. You can tell that the pieces will fit, but you don't know exactly what the entire thing will look like.
23:49:47 <frerich> (in particular, you don't *have to* know)
23:49:57 <kmc> yeah
23:50:10 <kmc> the first step is to define the types themselves
23:50:20 <frerich> Yep that's also what I start with.
23:50:25 <kmc> i usually spend a long time on that
23:50:26 <kmc> then declare functions and their type signatures
23:50:39 <kmc> in the best case, the last step of defining all the functions is almost mechanical
23:50:52 <kmc> you just pattern-match for each of the constructors of the input type
23:51:07 <kmc> and there's some obvious result
23:51:44 <frerich> While defining types, I sometimes omit the arguments in the beginning. Like, I don't write 'data Action = DoThis | DoThat { value :: String }' straight away but just 'data Action = DoThis | DoThat' since I don't yet know what information a value created with 'DoThat' will need to carry.
23:52:08 <frerich> E.g. in a game I'm working on, I couldn't decide whether a "Turn" should carry the player who played it? Or the game state? Or what?
23:53:24 <frerich> I usually do realize that I need more information when implementing the functions.
