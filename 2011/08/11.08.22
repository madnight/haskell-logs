00:09:01 <aki> morning
00:09:43 <mux> morning
00:09:48 <aki> :)
00:17:15 <kmc> hi aki
00:18:24 <aki> hi kmc
00:25:09 <erus`> I know what monads are and how they work
00:25:21 <erus`> and it wasnt a eureka moment.
00:25:29 <erus`> i was using them all along
00:25:59 <erus`> i better get to work on that blog post now i guess
00:42:13 <Botje> *sniff* they grow up so fast :')
00:46:15 <zzo38> Why can't the Template Haskell "recover" command recover from illegal foreign declaration errors?
00:47:33 <zzo38> This is what I have:  foreign_export :: Name -> Q [Dec]; foreign_export x = recover [d| |] (do { VarI _ t _ _ <- reify x; return [ForeignD $ ExportF CCall (nameBase x) x t]; });
00:49:15 <zzo38> Since, GHCi does not allow foreign declarations
00:53:48 <kmc> erus`++
00:58:12 <zzo38> Does GHCi have any environment variables the GHC does not have or vice-versa, which can be used for this purpose?
01:01:28 <kmc> you mean C preprocessor macros?
01:01:32 <kmc> or something else?
01:01:34 <Kaidelong> why is there no instance (Num t) => Num (RVar t)
01:01:47 <Kaidelong> if you throw exceptions where Eq and Show are involved
01:01:52 <Kaidelong> it seems like it should work just fine
01:02:26 <zzo38> It doesn't work with C preprocessor I checked. But I found that getArgs can tell you (it says "--interactive" at first in GHCi) so I can use that.
01:02:43 <Kaidelong> someone pointed it out to me today when he said that "integralUniform 1 100 ^ 2" should work just fine and I realized he was right
01:02:44 <kmc> ah, i see
01:04:01 <DrTeggy> G'day all.
01:04:36 <kmc> hi DrTeggy
01:06:44 <zzo38> That worked! Now I have:   foreign_export x = runIO getArgs >>= \y -> if head y == "--interactive" then [d| |] else (do { VarI _ t _ _ <- reify x; return [ForeignD $ ExportF CCall (nameBase x) x t]; });
01:06:56 <zzo38> Tell me if it is anything you see wrong with that
01:07:50 <kmc> \(y:_) -> if y == "--interactive" then ...
01:08:19 <kmc> or:  foreign_export x = runIO getArgs >>= f where f ("--interactive":_) = [d| |]; f _ = ...
01:09:14 <zzo38> OK
01:09:45 <zzo38> I changed it to \(y:_) -> if y == "--interactive" then
01:10:45 <frerich> Is there a better way than 'catch (readFile "/etc/mtab") (\_ -> exitFailure)' to check whether some file is readable? That should be quite cheap, right? I seem to recall readFile reads in 64kB chunks or the like - does it actually read *anything* in this case?
01:10:53 <zzo38> Or maybe the second one is better in case of empty list, but I don't know why it would result in empty list!!
01:11:22 <kmc> frerich, i think readFile uses the lazy IO hack
01:11:28 <kmc> so probably not
01:12:59 <frerich> kmc: Interesting, thanks.
01:13:06 <Botje> :t doesFileExist
01:13:09 <lambdabot> Not in scope: `doesFileExist'
01:13:13 <Botje> hmm
01:13:27 <Botje> frerich: http://hackage.haskell.org/packages/archive/directory/latest/doc/html/System-Directory.html#v:doesFileExist
01:13:55 <frerich> I took this fucntion from http://rigaux.org/language-study/scripting-language/ which does some comparisons of various languages for shell scripting purposes. The 'scores' aren't too convincing but I find it interesting to see "everyday programming problems" like this solved in different languages, side-by-side.
01:13:56 <Botje> frerich: or you can do getPermissions + readable
01:14:07 <frerich> Of course, as usual with such things, the author of that page is probably not an expert in all the languages he tried.
01:14:15 <frerich> So I wondered how much his Haskell versions could be improved.
01:14:27 <kmc> freiksenet, in POSIX you can check permissions with access(2)
01:14:27 <zzo38> Is this a good way to write the program for making foreign exports? I try to fix two things I dislike about foreign export
01:15:08 <kmc> importantly, this checks against real UID not EUID
01:15:19 <kmc> that's important when running setuid
01:15:31 <kmc> but don't get me started on how fundamentally broken the whole setuid concept is
01:15:46 <frerich> Botje: Ah, I didn't know that System.Directory has a doesFileExist! thanks for pointing that out :-)
01:16:03 <Athas> Is there a way to measure the code coverage of my QuickCheck-based test suite.
01:16:39 <kmc> Athas, hpc?
01:18:18 <kmc> i think RWH talks about it
01:18:30 <Athas> That looks interesting, thanks.
01:28:59 <Maxdamantus> What terms do you use to differentiate between existence (eg, Java) and absense (eg, Haskell) of dynamic types?
01:29:37 <Maxdamantus> (when talking about a type system)
01:29:52 <increpare> dynamic/static
01:30:17 <Maxdamantus> Dynamic as in: Foo f = bar(); /* what type is f's object? */
01:30:34 <Maxdamantus> "Dynamic typing" seems to refer to lack of static typing though.
01:30:40 <Maxdamantus> eg, JavaScript.
01:31:24 <Kaidelong> I thought the distinguishing charateristic was that all the type checks are runtime checks
01:31:25 <kmc> Maxdamantus, so you're interested in languages that can be said to have both?
01:31:34 <Maxdamantus> kmc: Java has both.
01:31:38 <kmc> sort of
01:31:42 <kmc> so does Haskell
01:31:50 <Kaidelong> and thus the behavior of polymorphic functions can be extended at run-time
01:32:05 <Maxdamantus> Hm. How so?
01:32:16 <kmc> Data.Typeable, Data.Dynamic
01:32:36 <Maxdamantus> I think the differentiation is related to ad-hoc vs subtype polymorphism.
01:33:45 <Maxdamantus> Hm. That doesn't really seem dynamic though.
01:33:51 <kmc> Data.Dynamic doesn't?
01:34:07 <Maxdamantus> Don't think so; not properly.
01:34:18 <kmc> how so?
01:34:55 <Maxdamantus> Oh, maybe.
01:35:19 <Maxdamantus> But it's not really supported by the language.
01:35:52 <Maxdamantus> Dynamic is just one type.
01:36:04 <Maxdamantus> It doesn't refer to a set of types.
01:37:19 <kmc> it's sort of like Java's Object
01:37:38 <kmc> you can cast a Dynamic down to any type T
01:37:44 <kmc> and either get something of that type, or Nothing
01:38:38 <Maxdamantus> So what exactly is dynamic?
01:38:54 <kmc> what do you mean?
01:39:26 <Maxdamantus> It's all still static because each expression only has one type, depending where it's used.
01:39:50 <Maxdamantus> (and the value you get by evaluating that is that exact type)
01:40:03 <kmc> shrug
01:40:20 <kmc> it's hard to tell if you're talking about substantive differences between type systems, or just about terminology
01:40:36 <kmc> you could say each expression in Python "only has one type" -- that type is "Python value"
01:40:59 <companion_cube> "dictionary"
01:41:21 <Leif_Bork> Hi!
01:41:26 <kmc> hi Leif_Bork
01:41:38 <Maxdamantus> Yes, I'm wondering at that level.
01:42:46 <Maxdamantus> You can think of so-called "dynamic languages" just having one static type.
01:43:04 <kmc> well i'd be careful with the term "dynamic language"
01:43:13 <Maxdamantus> Java's only more static in the sense that you can have expressions that restrict the dynamic type.
01:43:14 <kmc> the way i see it used, it means a lot more than dynamic types
01:43:24 <Maxdamantus> dynamically typed languages*
01:43:26 <kmc> it's sort of a cluster of related but separate language features
01:43:27 <kmc> yeah
01:43:44 <Leif_Bork> If I have a function for generating uuids, uuid :: IO UUID, and a list, how do I generate a list of uuids for every item in the list?
01:44:18 <kmc> that's not a function; it's an IO action
01:44:21 <kmc> functions have (->) in their types
01:44:28 <kmc> :t mapM
01:44:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
01:44:49 <kmc> :t \f -> mapM (const f)
01:44:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => m b -> [a] -> m [b]
01:48:17 <Leif_Bork> Maybe ugly, but
01:48:18 <Leif_Bork> mapM (\x -> uuid) [1..4]
01:48:31 <kmc> that's fine
01:48:38 <kmc> or  mapM (const uuid) [1..4]
01:48:51 <kmc> but if you just want 4 uuids you can do:   replicateM 4 uuid
01:49:40 <Maxdamantus> Data.Dynamic does seem interesting though.
01:49:45 <kmc> it is
01:49:55 <kmc> it's not the right answer that often, though
01:50:24 <kmc> most dynamically-typed languages lack the ability to create convenient sum types and pattern-match on them
01:50:45 <kmc> even though this deficiency is not fundamental to dynamic typing
01:50:46 * Maxdamantus had a quick thought today that it might be interesting to create a language with a Haskell-like type system, that compiles fairly directly to JavaScript or something.
01:51:03 <kmc> in those languages, you're encouraged to use the dynamic type system itself as a single, global, ad-hoc sum type
01:51:16 <Maxdamantus> But then I thought it'd get messy trying to integrate with existant interfaces .. but that system should help.
01:51:23 <kmc> the proper way to translate this design thinking to Haskell isn't to emulate dynamic typing but to define a sum type
01:52:34 * Maxdamantus wonders whether type classes would be very usable without purity.
01:52:51 <kmc> i don't see the connection between type classes and purity
01:55:09 <Maxdamantus> With laziness and purity, it's fairly reasonable going from Set a to Set b when you have an a -> b
01:56:45 <Maxdamantus> Seems less desirable without it .. you'd want to just make the set ensure .. I dunno, I should do this assignment.
01:56:46 <Leif_Bork> I'm very bad at IO and monads, how can a list of type [UUID], instead of IO [UUID]?
01:57:18 <Botje> depends on how you intend to use those UUIDs
01:57:27 <Maxdamantus> Leif_Bork: by.
01:57:40 <kmc> Leif_Bork, http://haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
01:57:44 <kmc> Leif_Bork, http://haskell.org/haskellwiki/Introduction_to_IO
01:57:56 <peterise1ins> preflex: seen conal
01:57:56 <preflex>  conal was last seen on #haskell-blah 2 days, 7 hours, 38 minutes and 19 seconds ago, saying: augur: you?
01:58:05 <kmc> Maxdamantus, first, i don't see what that has to do with type classes
01:58:07 <Leif_Bork> Thank you!
01:58:14 <kmc> 'fmap' is in a type class but 'map' isn't
01:58:27 <kmc> Maxdamantus, second, practically every language has 'map'; most of them aren't pure or lazy
01:58:40 <Botje> if those UUIDs are going to be used as constants in an otherwise pure program i'd advocate using the u-word
01:58:52 <Maxdamantus> kmc: as an alternative implementation of polymorphism to say, what Java has.
01:59:13 <kmc> (Set a) isn't type class polymorphism
01:59:20 <Maxdamantus> I know.
02:00:26 <Maxdamantus> I guess what I'm thinking of is a different issue, and I don't think I was thinking of it properly.
02:03:27 <Maxdamantus> It's convenient to have dynamic types, so you can have some Set<Foo> where Bar and Baz implement Foo .. I guess it's nicer, but not as easily done in Java (more classes), to rather derive Foo things from both Bar and Baz: class Fooable a where foo :: a -> Foo
02:03:56 <kmc> that's not dynamic types; that's subtyping
02:04:33 <kmc> the thing Java lets you do that's dynamic-typing-like is a) instanceof b) cast Foo back down to Baz, with 'null' if it was actually Bar
02:04:41 <kmc> you could forbid these and still keep subtyping
02:04:46 <Maxdamantus> Dynamic typing in Java is based on subtyping.
02:05:09 <kmc> on what basis do you call this "dynamic typing"?
02:05:12 <Maxdamantus> The elements in the former set are of type Bar or Baz.
02:05:23 <kmc> you're not using that phrase the way it's typically used
02:05:37 <Maxdamantus> Because I don't know what to call it.
02:05:43 <kmc> call it subtyping
02:06:16 <Maxdamantus> But subtyping is relevant elsewhere.
02:06:19 <Maxdamantus> I think.
02:06:56 <kmc> yes, Java is not the only language with subtyping
02:07:06 <Maxdamantus> within Java.
02:07:35 <Maxdamantus> You can say that something is a subtype of something else.
02:07:40 <kmc> subtyping has more than one use case
02:07:52 <kmc> that doesn't mean you shouldn't call it "subtyping" in both cases
02:07:55 <Maxdamantus> That's not directly talking about dynamic type.
02:08:48 <kmc> the reason you have to talk about the "dynamic type", i.e. run-time type, of Java objects is that you have "instanceof" and down-casting
02:09:06 <Maxdamantus> Mm, run-time type would be better, I guess.
02:09:22 <Maxdamantus> Run-time typing?
02:09:25 <kmc> they're both fine terms
02:10:14 <kmc> but there's no reason to invoke this concept when you're just filling a Set<Foo> with Bars
02:11:07 <kmc> when you get a Foo out and say "give me a Bar or else a NullPointerException", that's where you need to talk about dynamic types
02:23:45 <ivanm> preflex: seen Axman6
02:23:46 <preflex>  Axman6 was last seen on #haskell-blah 18 hours, 51 minutes and 5 seconds ago, saying: and touching colours
02:29:58 * hackagebot network-address 0.1.0 - IP data structures and textual representation  http://hackage.haskell.org/package/network-address-0.1.0 (SebastianNowicki)
03:09:44 <erus`> pro tip: dont unplug the power cable for a laptop screen while it is on
03:10:04 <erus`> my thumb smells of burning
03:13:48 <kmc> yikes
03:16:05 <guerrilla> how do i enable the exists keyword? i enabled -XRankNTypes and -XExistentialQuantification but i still get Illegal symbol '.' in type
03:19:04 <kmc> GHC does not support the 'exists' keyword, period
03:19:34 <kmc> existential quantification has to be wrapped in a data constructor, and then you use forall syntax
03:19:49 <kmc> data Exists f = forall x. Witness (f x)
03:20:06 <kmc> or GADT syntax:  data Exists f where { Witness :: f x -> Exists f }
03:20:11 <guerrilla> ok, i didn't know that. i kept seeing exists in the documentation (e.g. http://www.haskell.org/ghc/docs/6.6/html/users_guide/type-extensions.html)
03:20:30 <guerrilla> that's cool, thanks for the tip, thats nice
03:20:38 <kmc> it's only in that one place?
03:20:47 <kmc> that's not a real GHC type
03:20:53 <kmc> also those are the docs for GHC 6.6 which is mega-old
03:21:01 <kmc> by the way, UHC supports 'exists'...
03:21:38 <guerrilla> i saw it also on http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification and http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantifier
03:21:56 <guerrilla> but haskell prime isn't supported yet, right? (in 7.0 anyway)
03:22:10 <guerrilla> by ghc that is
03:22:36 <Accidus> What's the right type class for a type over which I can iterate? Sounds like Foldable, but Foldable is a property of functors, not types (unless the proper solution is to look at the constant functor?).
03:22:37 <kmc> Haskell Prime is a process which produces new versions of the Haskell language spec
03:22:40 <kmc> it does not refer to a particular present or future version of Haskell
03:23:03 <guerrilla> oh sorry, i got confused, iw as thinking of the last one that was released of the spec
03:23:15 <kmc> yeah, it's not in Haskell 2010
03:23:22 <kmc> Haskell 2010 is a very conservative change to Haskell 98
03:23:23 <guerrilla> clever naming in that case :)
03:23:45 <kmc> Accidus, afaik there's no popular class for iterating over non-polymorphic containers
03:23:58 <kmc> it would have to be a multi-param type class or use associated types or something
03:24:04 <guerrilla> yeah, its what removed like those sily function calls in pattern matching and minor things like that, right?
03:24:10 <guerrilla> ignore me, ill read up on it
03:24:24 <kmc> http://haskell.org/haskellwiki/FAQ#My_textbook_uses_Haskell_98._Is_it_very_different_from_Haskell_2010.3F
03:24:30 <guerrilla> but thanks anyway, what you pasted above is what i wanted
03:24:34 <Accidus> kmc, so I should just define my own then? Oh well...
03:24:43 <kmc> Accidus, why do you need it?
03:25:27 <kmc> we get a lot of questions of the form "how do I use type classes to do X?" and the answer is usually "don't use type classes; there is a simpler way"
03:25:54 <Accidus> I'm writing code that needs to lift (equality) relations through monads. In order to lift equality through the State monad (or just the Environment monad), I need to somehow iterate over all states (or assume Haskell can check extensional equality :P).
03:26:25 <kmc> ah, i see
03:26:42 <kmc> isn't that (Enum a, Bounded a)
03:27:11 <Accidus> Perhaps. My biggest problem is that I don't know Haskell well enough.
03:27:17 <Accidus> I know the /theory/ behind it
03:27:34 <Accidus> But I haven't programmed enough in it to know its inns and outs
03:27:38 <Accidus> * ins
03:27:53 <kmc> Accidus, http://hackage.haskell.org/package/enumerable
03:28:29 <Accidus> Oooh, what's that: Data.Enumerable.FunctionEquality
03:28:29 <kmc> when you said "type over which I can iterate", i thought you meant like "getting every t out of a [t]" or "getting every Word8 out of a ByteString"
03:28:38 <kmc> but now it sounds more like "getting every possible value of type t"
03:28:52 <kmc> click the source link for that module
03:30:11 <Accidus> OK, cool. Thanks for that! I think that's going to cut it.
03:30:32 <kmc> cool :)
03:32:17 <Dave> hi
03:32:21 <kmc> hi Dave
03:35:40 <guerrilla> """
03:37:46 <kmc> > iterate show ""
03:37:47 <lambdabot>   ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\...
03:39:18 <kmc> Accidus, just out of idle curiosity, where did you learn the theory behind Haskell?
03:39:36 <kmc> i'm always curious about people's backgrounds when they start learning Haskell
03:40:16 <Accidus> kmc, Many different places, I guess. Reading and writing research papers is probably the majority of my knowledge
03:40:27 <Accidus> * the source of the majority
03:41:26 <Accidus> Hmm... If I had to put down book names, though, it would probably be Mac Lane's CWM and Levy's CBPV.
03:46:43 <kmc> cool
03:46:59 <Accidus> What kidn of answer were you expecting?
03:47:52 <kmc> shrug
03:48:06 <kmc> i wasn't sure what you meant by "the theory behind Haskell", specifically
03:48:56 <Accidus> I see. Denotational semantics, basic type system theory, domain theory, calculi for effects, category theory
03:50:12 <obiwahn> is there a trick to define functions in ghci?
03:51:05 <TubeSteak> obiwahn: you can use let
03:51:09 <int-e> you can use 'let', ghci> let f x = x+1
03:51:22 <obiwahn> mh in hugs the same:(
03:51:30 <obiwahn> Hugs> frac x = x * frac(x-1)
03:51:30 <obiwahn> ERROR - Syntax error in input (unexpected `=')
03:51:45 <kmc> Accidus, i see :) that's a pretty broad background, then
03:51:51 <kmc> what reading would you recommend on domain theory?
03:51:57 <obiwahn> so i need the let keyword to define functions in the interactive mode:)
03:51:58 <int-e> hugs doesn't have such a feature I believe.
03:52:11 <Accidus> Abramsky and Jung have a chapter on it
03:52:24 <int-e> ghci mimics a 'do' block, syntax-wise.
03:53:32 <Accidus> http://www.cs.bham.ac.uk/~axj/pub/papers/handy1.pdf
03:53:48 <int-e> you can also do things like  ghci> foo <- readFile "foo.txt"
03:54:14 <Accidus> Although they choose directed-complete partial orders, whereas for many applications omega-complete partial orders are enough.
03:54:23 <kmc> cool, thanks
04:05:08 <Jester_Racer> ah damn, haskellwiki should have a "Broken link" button. There are lots of broken links
04:05:25 <benmachine> it's a wiki
04:05:36 <benmachine> just fix them :P
04:05:37 <benmachine> or
04:05:40 <benmachine> unlink them
04:05:41 <benmachine> or
04:05:42 <benmachine> talk page
04:05:42 <benmachine> or
04:05:51 <benmachine> something else.
04:06:08 <Jester_Racer> ok, I've never used a wiki before... Do I have to register?
04:06:23 <benmachine> yes
04:06:46 <kmc> it's automatic though
04:06:49 <xarch> hi
04:06:56 <Jester_Racer> what automatic?
04:07:12 <kmc> registration
04:07:17 <xarch> I'm looking for a good package to read png files
04:07:17 <kmc> you used to have to email someone, i think ;P
04:07:19 <kmc> but no more
04:07:23 <xarch> do you know a good one?
04:07:33 <Jester_Racer> oh ok :) that's good
04:07:40 <kmc> xarch, http://hackage.haskell.org/package/stb-image will
04:07:47 <kmc> beware it's not to be used on untrusted input
04:07:51 <kmc> the underlying C library is not secure
04:07:55 <xarch> hm
04:08:06 <xarch> ok thanks!
04:08:24 <Jester_Racer> xarch: what do you want to do with the pic? SDL-image works great
04:08:49 <xarch> Jester_Racer: I'd like to know what color a pixel is
04:09:09 <xarch> I don't think SDL-image can do that
04:09:19 <xarch> or even SDL
04:09:36 <xarch> I read the documentation and I didn't find anything about that
04:09:44 <kmc> SDL-image will give you an SDL surface, which is a memory buffer you can index
04:09:45 <kmc> i think
04:09:45 <xarch> except maybe the surfaceGetPixels function
04:09:54 <xarch> which returns a IO Pixels
04:10:07 <xarch> but it looks like the Pixels type doesn't exist
04:10:17 <xarch> or at least I don't find it in the documentation
04:10:18 <benmachine> you can castPtr it
04:10:24 <benmachine> by being devious
04:10:35 <xarch> hm
04:10:47 <Jester_Racer> I think SDL can do that, but if you don't want to display it or something, then you should use something lightweight lib
04:11:50 <xarch> hm ok
04:12:06 <kmc> xarch, if you search 'png' on the hackage package list, there's a few pkges
04:12:51 <xarch> ok
04:13:30 <xarch> I had already seen some packages (like pngload and Codec-Image-DevIL)
04:14:13 <xarch> but pngload gives a StorableArray which I don't like
04:14:18 <kmc> why not?
04:14:21 <kmc> odd that we don't have a binding to C libpng
04:14:27 <kmc> you should write one and upload it :D
04:15:30 <xarch> hm :-)
04:15:47 <xarch> I'll try
04:15:55 <hpaste> benmachine pasted “get pixel array” at http://hpaste.org/50543
04:16:08 <benmachine> xarch: the above may interest you
04:16:15 <benmachine> I think it makes assumptions about the pixel format though
04:16:27 <benmachine> oh wait, should probably paste the types too
04:16:37 <xarch> oh thanks
04:17:09 <hpaste> benmachine annotated “get pixel array” with “get pixel array (annotation)” at http://hpaste.org/50543#a50544
04:20:06 * hackagebot hledger-interest 1.2 - computes interest for a given account  http://hackage.haskell.org/package/hledger-interest-1.2 (PeterSimons)
04:26:19 <jonkri> off-topic: i'm looking at http://en.wikipedia.org/wiki/Project_triangle and there is one thing i don't get - how can they say that a high-quality project can be produced over a long time cheaply? what's the factors affecting the costs so significantly in the "Design something quickly and to a high standard" case? i'm thinking that the man hours are the same
04:28:56 <kmc> "personal obsession hobby project" seems like the canonical case there
04:29:58 <jonkri> kmc, what do you mean?
04:30:49 <kmc> a project with one or a small number of developers, who care a lot, and put a lot of effort in, but only irregularly
04:30:55 <zomg> jonkri: well assuming they have a highly paid consultant working 15 minutes a day for a year in a tiny project...
04:30:58 <zomg> :P
04:31:26 <kmc> in general i think you can get very good outcomes if you have a small number of people who care a lot, and have as much time as they need
04:31:50 <hpc> the other way is to open-source your project
04:32:07 <kmc> but what do i know, i'm just some guy on the internet spouting off advice about managing software projects, without any real evidence to back up my claims
04:32:07 <hpc> cost per time is however much it takes to maintain the repo
04:32:20 <kmc> plenty of that to go around
04:32:26 <guerrilla> jonkri: ever read the mythical man month?
04:32:49 <hpc> that's a good one to read
04:33:29 <guerrilla> that explains why smaller teams can, in certain conditions, produce higher quality products and also explains often why some things take as long as they do
04:33:39 <erus`> what other languages have algebraic types?
04:33:40 <guerrilla> http://en.wikipedia.org/wiki/Mythical_man_month
04:33:43 <gorakhargosh> are type classes like Java interfaces for types?
04:34:06 <gorakhargosh> (new to haskell and finding it intriguing)
04:34:17 <hpc> type classes are closer to java interfaces than types
04:34:18 <erus`> ok i found on wikipedia
04:34:21 <guerrilla> erus`: http://en.wikipedia.org/wiki/Algebraic_data_type#Programming_languages_with_algebraic_data_types
04:34:29 <guerrilla> there's a lot more
04:34:33 <kmc> gorakhargosh, only a little bit
04:34:35 <erus`> i beat you :D
04:34:41 <kmc> gorakhargosh, http://haskell.org/haskellwiki/FAQ#Is_Haskell_similar_to_Language_X.3F
04:34:53 <hpc> class C x where foo :: x <=> interface C<x> { public x foo(); }
04:35:12 <guerrilla> erus`: coq, agda, etc too. algebraic specification languages too, i suppose
04:35:26 <gorakhargosh> hpc: ah
04:35:31 <gorakhargosh> thank you kmc
04:35:33 <guerrilla> erus`: but if you don't mean first class, then so do Java and C# using certain patterns
04:35:58 <erus`> guerrilla: i thought c# might support something like it
04:36:06 <erus`> because it seems to have everything
04:36:11 <guerrilla> erus`: yeah not in the same way, justi n the way you set up your classes
04:36:25 <kmc> the "visitor pattern" in OOP is kind of a standard workaround for the lack of algebraic data
04:36:37 <guerrilla> yeah, that's it. thanks kmc, was just gonna look it up
04:36:38 <kmc> most "patterns" are a standard boilerplate workaround for some language flaw
04:37:00 <guerrilla> interesting, kmc, never thought of it that way
04:37:07 <kmc> they're macros you type in by hand
04:37:18 <kmc> every language has them
04:37:21 <guerrilla> indeed
04:37:23 <jonkri> thanks everyone for your thoughts. guerrilla: that seems like an interesting book, i will definitely check it out :)
04:37:30 <kmc> the important thing is to see them as an evil to be minimized
04:37:37 <guerrilla> erus`: http://lambda-the-ultimate.org/node/1134
04:37:45 <jonkri> i like that "language x" faq entry :)
04:37:51 <kmc> Haskell has some boilerplate patterns... people are continually working out how to turn them into libraries or language extensions
04:38:12 <guerrilla> yeah
04:38:13 <kmc> in Java they've given up, so they try to convince you the patterns are a great virtue
04:38:17 <kmc> and get rich writing books about them
04:38:38 <guerrilla> yeah, those books really make me sick. the names and excuses they come up with..
04:39:06 <jonkri> i think i would prefer a cost-scope-quality triangle, at least for the projects where i work alone :)
04:39:23 <frerich> kmc: I think I don't understand what you mean by "algebraic data" - what do you mean with "the "visitor pattern" in OOP is kind of a standard workaround for the lack of algebraic data"?
04:39:53 <kmc> frerich, http://en.wikipedia.org/wiki/Algebraic_data_type
04:40:41 <tomberek> anyone familiar with loeb, the generic knot tying? I've been playing with a monadic variation, I found an interesting use for a mutable doubly linked structure. I'd like any feedback, comments, discussion.
04:40:45 <hpaste> tomberek pasted “loebM” at http://hpaste.org/50545
04:41:14 <kmc> frerich, a visitor class looks a lot like a "case" expression in Haskell
04:41:21 <kmc> but more limited, and usually vastly more code
04:41:24 <guerrilla> yeah i disagree with this project triangle too. i'd have to ead more on the justification but on the face of it, no
04:41:52 <kmc> most of what's said about managing software projects is unjustified nonsense
04:42:03 <kmc> at best it's just people spouting off because they like the sound of their own voices
04:42:10 <kmc> at worst it's trying to sell you a particular flavor of snake oil
04:42:23 <frerich> kmc: I thought that the visitor pattern was a hack to work around the lack of ability to dispatch a function depending on more than one type.
04:42:39 <kmc> is it?
04:42:40 <guerrilla> i also generally disagree with triangles
04:42:43 <kmc> maybe it can be used for that too
04:42:52 <kmc> btw some OOP systems let you dispatch on more than one type
04:43:38 <guerrilla> we're taught in security CIA (confidentiality, integrity, availability) triangle. while CIA classification is useful, i find many problems with that triangle as well. many cases where compromises are not necessary
04:44:54 <guerrilla> rather the fact it's a silly triangle
04:45:17 <gorakhargosh> guerrilla: we generally disagree with things, so we come up with more things to disagree with.
04:45:23 <int-e> "even, prime, greater than 2: pick any two"
04:45:58 <benmachine> at most two, surely
04:46:13 <guerrilla> gorakhargosh: i dont enever think we need more things, just simplify it. the outcome is affected by the three variables in some way. and if you want to specifyin which way, prove it
04:46:18 <guerrilla> brb
04:49:31 <gorakhargosh> guerrilla: metaphors and abstractions have lifetimes. learning outgrows these shells at some point. so i'd treat them as useful while they're useful and move on to something else when they aren't. =)
04:51:59 <kmc> project management is like a burrito
04:52:08 <kmc> @where burrito
04:52:09 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
04:52:12 <kmc> gorakhargosh, did you see this article?
04:54:21 <gorakhargosh> kmc: nah, checking it out now.
04:57:03 <guerrilla> gorakhargosh: (re; metaphors) makes sense. i agree
04:57:13 <Jester_Racer> monads are burritos! Great :D
04:57:42 <tomh-> hmm is this the number of ms since epoch?
04:57:45 <tomh-> > getClockTime >>= (\(TOD sec m) -> return ((realToFrac sec) * 1000 + (realToFrac m/1000000000)))
04:57:45 <lambdabot>   Not in scope: `getClockTime'Not in scope: data constructor `TOD'
04:57:49 <tomh-> oh
04:59:02 <gorakhargosh> kmc: nice article. i've learned this while trying to introduce logarithms to a 6 year old: log of 8 to the base 2 is 3 or "how many times do i multiply 2 by itself to get 8?"  he had his aha moment after he went through the second statement. so i think metaphors do help but only for a while.
04:59:41 <Botje> except that's not a metafor, that's how log works.
04:59:49 <gorakhargosh> yes
04:59:54 <guerrilla> wish someone taught me logarithms when i was 6
05:00:16 <ion> λ> getPOSIXTime
05:00:16 <ion> 1314016531.012653s
05:00:17 <gorakhargosh> a metaphor is simply one of the tools
05:05:08 <gorakhargosh> there needs to be a "Head First Haskell" book.
05:05:54 <Apocalisp> What's missing from the existing Haskell books?
05:06:10 <gorakhargosh> pictures
05:07:04 <guerrilla> wrong, learn you a haskell has tons of beautiful pictures :P
05:07:06 <mux> I guess that was a joke, but you know there _are_ many pictures in LYAH
05:07:14 <guerrilla> beatcha
05:07:20 <mux> dang.
05:07:24 <danr> can anyone help me give this function a general Rank2Types-signature?  f (*) (x,y) (z,w) = (x*y,z*w)
05:07:53 <danr> I want to be able to do f (++) ("ab","cd") ([1],[2,3])
05:09:07 <kmc> f :: (forall a. [a] -> [a] -> [a]) -> ([b],[b]) -> ([c],[c]) -> ([b],[c])
05:09:33 <kmc> > let f :: (forall a. [a] -> [a] -> [a]) -> ([b],[b]) -> ([c],[c]) -> ([b],[c]); f (*) (x,y) (z,w) = (x*y,z*w) in f (++) ("ab","cd") ([1],[2,3])
05:09:37 <lambdabot>   mueval-core: Time limit exceeded
05:09:55 <danr> why doesn't f :: (forall a . a -> a -> a) -> (b,b) -> (c,c) -> (b,c)
05:09:56 <kmc> that's odd
05:09:57 <danr> work?
05:10:13 <kmc> it would work, except that you'll have a hard time coming up with an interesting function of type (forall a. a -> a -> a)
05:10:22 <kmc> that's too general for (++)
05:10:27 <danr> oh...
05:10:38 <danr> yeah, it worked with const, and const id
05:11:01 <kmc> the key thing about higher-rank types is that a function of higher-rank type *requires* polymorphism from its argument instead of *promising* polymorphism
05:11:12 <kmc> so in this case you've required too much polymorphism
05:11:34 <danr> oh, I didn't know that
05:11:35 <kmc> and yeah the only values not involving undefined are const and (const id)
05:11:36 <tomberek> f :: Monoid a,b,c => (forall a.a -> a -> a) -> (b,c) -> (b,c) -> (b,c)         something like this? similar?
05:11:50 <kmc> you'd have to move (Monoid a) inside the forall
05:11:56 <danr> I was hoping to be able to use it on (+) as well
05:12:11 <mux> I would have used Monoid a, Monoid b => (a, a) -> (b, b) -> (a, b)
05:12:42 <gorakhargosh> guerrilla: not the kind of pictures i'm talking about. =)
05:12:42 <mux> err, (a, b) -> (a, b) -> ...
05:12:51 <gorakhargosh> brb
05:13:21 <danr> kmc: thanks a lot!
05:15:44 <tomh-> any haskell glut user here knows why a timer callback immediately executes the callback and again when the timeout passed?
05:16:37 <Botje> is it possible you're using it wrong? can you show code?
05:16:41 <Botje> (on hpaste.org)
05:17:26 <tomh-> yeah one moment
05:18:32 <Accidus> Is there a functor corresponding to Flip?
05:18:42 <Accidus> * flip
05:18:55 <tomh-> Botje: http://hpaste.org/50546
05:19:13 <tomh-> maybe IO causes strict evaluation?
05:19:34 <kmc> Accidus, you mean newtype Flip f x y = MkFlip (f y x) -- ?
05:19:38 <kmc> that's probably in some lib
05:19:40 <kmc> but i don't know which
05:21:19 <Accidus> I can define it myself, I was wondering whether there is a standard definition in the libraries.
05:21:57 <Botje> tomh-: and why are you sure it's being executed immediately?
05:22:10 <tomh-> look at the differences in the result
05:22:16 <danr> @unpl join . ((flip . ((.) .)) .) . (.)
05:22:16 <lambdabot> (\ n -> (\ y b c f -> n (y c) (b f)) >>= \ o -> o)
05:22:19 <tomh-> it prints out the current time in MS
05:22:38 <tomh-> the difference is always 1000 ms, 3-4 ms, 1000 ms, 3-4 ms ..etc
05:24:02 <Botje> could it be that you're installing the callback twice somehow?
05:24:08 <Botje> or that you call loop somewhere by accident?
05:24:19 <tomh-> no, I only call it in those places
05:25:10 <tomh-> let me scale down the problem
05:25:18 <tomh-> in an executable file
05:30:44 <tomh-> Botje: try this: https://gist.github.com/1162329
05:33:55 <Botje> tomh-: i don't see any reason why it would be doing that..
05:34:03 <Botje> you could try contacting the author
05:34:25 <tomh-> isn't it haskell specific rather than GLUT specific?
05:34:45 <tomh-> I mean, could it be that 'loop' is  evaluated because the type is IO or something?
05:34:49 <Botje> no
05:34:56 <Botje> I looked through the source of addTimerCallback
05:35:10 <Botje> and all it does is make a timer function and pass it to glutTimerFunc
05:36:06 <tomh-> ok, so where do you think this bug is located?
05:37:56 <Botje> the openGL faq says glutTimerfunc is immediately canceled, whereas other documentation says there is NO support for canceling callbacks.
05:38:26 <Botje> so maybe the re-registration is not necessary
05:38:34 <tomh-> it is
05:38:35 <Botje> or the callback is not deactivated in time, i don't know
05:38:50 <tomh-> I mean, you cannot cancel a callback when you have passed it in
05:38:58 <tomh-> but after it ran, you have to add it again
05:39:14 <Botje> tomh-: hmm.
05:39:18 <Botje> that _could_ be it
05:39:32 <Botje> comment from the GLUT source:
05:39:32 <Botje> -- Here is the really cunning stuff: If an element is added to the cleanup list
05:39:32 <Botje> -- when it is empty, register an immediate callback at GLUT to free the list as
05:39:32 <int-e> tomh-: hmm, works fine here.
05:39:33 <Botje> -- soon as possible.
05:39:52 <erus`> £120 computer :) http://www.ebuyer.com/267867-emachine-er1401-desktop-pt-nbzec-004
05:39:59 <erus`> its gonna be my new webserver
05:40:05 <Botje> tomh-: it _could_ be that your loop code runs when it is scheduled at tiem T and again at time T+1, before the cleanup can act
05:40:08 <tomh-> int-e: can you copy paste your output?
05:40:23 <tomh-> Botje: hmm
05:40:23 <Botje> but that would be a Graphics.UI.GLUT issue.
05:40:44 <tomh-> Botje: you mean in GLUT itself or in haskell bindings to glut?
05:41:07 <erus`> dont use GLUT, use GLFW
05:41:11 <Botje> haskell bindings.
05:41:34 <tomh-> erus`: the wiki said it had some problems with threading
05:42:10 <tomh-> Botje: ok cool, I think I will send an email to the author, to see if he has an idea about this
05:46:43 <int-e> tomh-: I get a strictly increasing sequence, with difference 1, occasionally 2. Just what you'd expect.
05:54:12 <int-e> tomh-: err. sorry. The differences are all around 1000 (most often 1001), and I can't read. System is Linux (x86-64), GLUT-2.2.2.0, GLUT is freeglut3 (http://packages.debian.org/sid/freeglut3)
05:54:51 <tomh-> int-e: you dont occasionally have differences of just 1 or 2 ms?
05:54:59 <int-e> tomh-: right. I don't.
05:55:15 <tomh-> mm interesting
05:55:20 <tomh-> maybe its my glut then?
05:55:48 <tomh-> no idea what kind of glut is delivered with macosx
05:56:55 <int-e> and it works fine compiled and in ghci (slight surprise there). ghc version is 7.0.3.
05:57:27 <tomh-> then its probably my glut
05:57:34 <tomh-> I use ghc 7 and glut 2.2.2.0 too
05:58:15 <int-e> (And 7.2.1 is also works. I'd blame glut, yeah.)
05:58:25 <int-e> s/is//
06:02:15 <parcs> tomh-: can you point to that wiki page?
06:02:29 <tomh-> parcs: which wiki page?
06:02:51 <parcs> tomh-: the one that said glfw has threading issues
06:04:48 <tomh-> http://www.haskell.org/haskellwiki/GLFW
06:06:27 <parcs> http://www.glfw.org/faq.html#2_9
06:08:04 <tomh-> parcs: I didn't mean glfw, just the bindings
06:08:29 <tomh-> which I assume it has, if the wiki sais it has them
06:08:30 <parcs> use GLFW-b
06:08:56 <parcs> glut is like 5 years old
06:09:41 <parcs> wait no, it's 13 years old
06:10:14 <tomh-> parcs: well if the bindings have issues, I rather use a 13 year old library
06:11:19 <erlanglearner> hello - i'm trying to pattern match against a list that starts with an empty in haskell. so a : _, where a is an empty list, but obviously [] : _, matches against an empty list, not a list of empty lists. what am i doing wrong? thanks
06:11:46 <parcs> tomh-: do the bindings have issues?
06:12:58 <parcs> the library is itself thread-unsafe, so the bindings will be too
06:14:11 <tomh-> parcs: well they say it has issues on their wiki..
06:15:07 <zachk> match against just []
06:15:46 <erlanglearner> sorry, i'm trying to match against [[], [], …]
06:15:48 <Botje> erlanglearner: [] : _ matches against a list where the first element is an empty list..
06:16:04 <erlanglearner> ok.. must be some other error, thanks anyway
06:25:11 <Phyx-> :t \(f :: forall a. a -> Int) -> (f 1, f 'g')
06:25:12 <lambdabot> (forall a. a -> Int) -> (Int, Int)
06:25:54 <Phyx-> > let g = \(f :: forall a. a -> Int) -> (f 1, f 'g') in g (const 1)
06:25:55 <lambdabot>   (1,1)
06:26:27 <Phyx-> > let g = \(f :: forall a. a -> a) -> (f 1, f 'g') in g (const 1)
06:26:27 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
06:26:28 <lambdabot>    arising from the li...
06:26:38 <Phyx-> :t \(f :: forall a. a -> a) -> (f 1, f 'g')
06:26:39 <lambdabot> forall t. (Num t) => (forall a. a -> a) -> (t, Char)
06:26:50 <Phyx-> :t mkT
06:26:51 <lambdabot> forall b a. (Typeable a, Typeable b) => (b -> b) -> a -> a
06:27:01 <Phyx-> > let g = \(f :: forall a. a -> a) -> (f 1, f 'g') in g (mkT id)
06:27:02 <lambdabot>   Could not deduce (Data.Typeable.Typeable a) from the context ()
06:27:02 <lambdabot>    arising ...
06:29:37 <greg_72> hi there, I'm learning monads in another language but I guess seasoned Haskell programmers will be able to answer the following:  when I have   head <- source End; tail <- source head ;l
06:30:13 <greg_72> return {Head = head, Tail = tail}, is ; (= bind) left- or right-associative?
06:30:32 <greg_72> I ask this because I want to type this expression
06:31:04 <chenwl> @src (!!)
06:31:04 <lambdabot> xs     !! n | n < 0 = undefined
06:31:05 <lambdabot> []     !! _         = undefined
06:31:05 <lambdabot> (x:_)  !! 0         = x
06:31:05 <lambdabot> (_:xs) !! n         = xs !! (n-1)
06:31:40 <ceii> greg_72: if your notation is somewhat close to Haskell, this yould be equivalent to source End >>= (\head -> source head >>= (\tail >>= ...))
06:31:50 <ceii> so, right-associative
06:32:35 <ceii> (>>= is Haskell's bind)
06:39:06 <byorgey> sb 17:19
06:39:17 <byorgey> oops, sorry
06:40:13 <greg_72> ceii: thanks
06:40:17 <Phyx-> :t mkT id
06:40:18 <lambdabot>     Ambiguous type variable `b' in the constraint:
06:40:18 <lambdabot>       `Typeable b' arising from a use of `mkT' at <interactive>:1:0-5
06:40:18 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
06:40:23 <greg_72> ceii: thanks
06:40:31 <Phyx-> :t mkT
06:40:32 <lambdabot> forall b a. (Typeable a, Typeable b) => (b -> b) -> a -> a
06:40:36 <Phyx-> ah
06:40:57 <Phyx-> :t mkT ((+1) :: Int -> Int)
06:40:58 <lambdabot> forall a. (Typeable a) => a -> a
06:41:21 <Phyx-> > let g = \(f :: forall a. a -> a) -> (f 1, f 'g') in g (mkT ((+1) :: Int -> Int)
06:41:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:41:26 <Phyx-> > let g = \(f :: forall a. a -> a) -> (f 1, f 'g') in g (mkT ((+1) :: Int -> Int))
06:41:27 <lambdabot>   Could not deduce (Data.Typeable.Typeable a) from the context ()
06:41:27 <lambdabot>    arising ...
06:41:47 <Phyx-> can that function even be invoked?
06:43:49 <byorgey> > let g = \(f :: forall a. Typeable a => a -> a) -> (f 1, f 'g') in g (mkT ((+1) :: Int -> Int))
06:43:50 <lambdabot>   (1,'g')
06:44:09 <byorgey> mkT does not construct a function of type  a -> a, it constructs one of type  Typeable a => a -> a
06:44:31 <Phyx-> hmmm
06:44:54 <byorgey> the only function of type  a -> a  is id.
06:45:02 <byorgey> (discounting undefined)
06:45:19 <Phyx-> > let g = \(f :: forall a. a -> a) -> (f 1, f 'g') in g id
06:45:20 <lambdabot>   (1,'g')
06:45:25 <Phyx-> wtf
06:45:31 <Phyx-> i'm pretty sure i tried that
06:45:43 <Phyx-> oh stupid
06:45:46 <Phyx-> i added a mkT
06:45:53 <Phyx-> *brain fart*
06:45:55 <byorgey> hehe oops =)
06:50:09 <Phyx-> :t cast
06:50:10 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
06:50:24 <Phyx-> :t typeOf
06:50:25 <lambdabot> forall a. (Typeable a) => a -> TypeRep
06:52:13 <Phyx-> :t dataTypeOf
06:52:14 <lambdabot> forall a. (Data a) => a -> DataType
06:52:30 <Phyx-> > dataTypeOf 8
06:52:31 <lambdabot>   DataType {tycon = "Prelude.Integer", datarep = IntRep}
06:52:41 <Phyx-> :t 8
06:52:42 <lambdabot> forall t. (Num t) => t
06:55:32 <ian__> func (+) [1..] [2..] // [3, 5, 7..]
06:55:35 <ian__> what is the name of func
06:55:54 <ian__> /=>*
06:56:37 <Phyx-> zipWith?
06:57:05 <Phyx-> > take 4 $ zipWith (+) [1..] [2..]
06:57:06 <lambdabot>   [3,5,7,9]
06:59:43 <incluye> > let pl a b = a + b in take 4 $ zipWith (pl) [1..] [2..]
06:59:44 <lambdabot>   [3,5,7,9]
07:01:54 <chenwl> is there any rc file for ghci just like .vimrc for vim
07:03:12 <parcs> .ghci
07:03:20 <chenwl> ~/.ghci ?
07:03:23 <Phyx-> > take 4 $ zipWith mod [1..] [2..]
07:03:24 <lambdabot>   [1,2,3,4]
07:03:26 <parcs> or ./.ghci
07:03:36 <Phyx-> > take 10 $ zipWith mod [1..] [2..]
07:03:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:03:55 <Phyx-> > take 10 $ zipWith mod [5..] [2..]
07:03:56 <lambdabot>   [1,0,3,3,3,3,3,3,3,3]
07:04:48 <Phyx-> > take 10 $ zipWith rem [5..] [2..]
07:04:49 <lambdabot>   [1,0,3,3,3,3,3,3,3,3]
07:05:15 <Phyx-> > take 4 $ zipWith (+) [1..] [2..]
07:05:16 <lambdabot>   [3,5,7,9]
07:05:27 <Phyx-> > take 4 $ zipWith (\joined #haskell) [1..] [2..]
07:05:28 <lambdabot>   <no location info>: parse error on input `#'
07:07:02 <Phyx-> > take 4 $ zipWith (\a b-> sum [a,b]) [1..] [2..]
07:07:03 <lambdabot>   [3,5,7,9]
07:07:09 <parcs> @hoogle comparing
07:07:10 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
07:07:25 <Phyx-> @src (+) Int
07:07:25 <lambdabot> Source not found.
07:07:30 <Phyx-> @src Num Int
07:07:30 <lambdabot> Source not found. You speak an infinite deal of nothing
07:07:37 <Phyx-> @src Int Num
07:07:38 <lambdabot> Source not found.
07:07:58 <Phyx-> @src Int
07:07:58 <lambdabot> data Int = I# Int#
07:08:03 <Phyx-> @src Int#
07:08:03 <lambdabot> Source not found.
07:08:38 <Phyx-> :t unsafeCoerce
07:08:39 <lambdabot> Not in scope: `unsafeCoerce'
07:08:44 <byorgey> Int# is an unboxed, machine-sized integer, hardwired into ghci
07:08:46 <Botje> Phyx-: you can /query lambdabot, you know
07:08:48 <meric> is it possible to write a new "filter" that operates on arrays instead of lists?
07:08:49 <byorgey> *ghc
07:09:05 <Phyx-> byorgey: i know
07:09:23 <Phyx-> Botje: i know too.. but since no one was talking, lol
07:09:25 <erus`> this is my proposal for a haskell mascot http://imgur.com/9lSD7
07:09:32 <erus`> hes called lambdamage
07:09:35 <erus`> and hes mad
07:09:37 <Botje> meric: for arrays you have to know the size up front :)
07:09:57 <Botje> erus`: looks like a sheep. a very pissed off sheep :)
07:10:09 <Phyx-> erus`: rofl..
07:10:18 <Phyx-> does indeed look like a sheep
07:10:33 <meric> Botje: I can use sum $ map (\x -> (cond arr) ? (1, 0)) arr to find the size up front.
07:10:44 <meric> but I can't figure out how to do the filter.
07:10:49 <Phyx-> with a very weird gun
07:11:54 <byorgey> meric: well, you could use 'assocs' to get an association list from the first array, filter that, then use the results to build another array
07:12:08 <erus`> now send me bitcoins
07:12:19 <yezariaely> Phyx-: how are sheep connected with haskell?!
07:12:26 <yezariaely> are they lazy?
07:12:29 <Phyx-> yezariaely: idk, ask erus`
07:12:35 <erus`> lamb damage
07:12:39 <erus`> lambda
07:12:40 <yezariaely> argh
07:12:41 <yezariaely> ok ...
07:12:43 <Phyx-> arrgg
07:12:49 <byorgey> meric: you may protest about memory usage, but honestly I don't think you can do much better than that without low-level munging
07:13:22 <byorgey> meric: although I guess if you want to use a mutable array you can allocate it up front and then write a little loop to go through and write it element by element
07:14:00 <meric> byorgey: I'm using http://hackage.haskell.org/package/accelerate and I'm only allowed arrays, no assocs or mutables :(.
07:14:43 <tomberek> anyone familiar with loeb, the generic knot tying? I've been playing with a monadic variation, I found an interesting use for a mutable doubly linked structure. I'd like any feedback, comments, discussion.
07:14:47 <hpaste> tomberek pasted “loebM” at http://hpaste.org/50548
07:15:15 <byorgey> meric: oh, you should have said you were using accelerate, I thought you were just using Data.Array =(
07:15:31 <meric> oh sorry. I didn't want to assume many people used it. :(
07:15:40 <Phyx-> @info accelerate
07:15:40 <lambdabot> accelerate
07:15:43 <Phyx-> lol
07:16:08 <copumpkin> meric: an associative array on a GPU sounds like a bad idea
07:16:22 <meric> what about filter on a GPU?
07:17:05 <zomg> :t mkRegex
07:17:06 <lambdabot> Not in scope: `mkRegex'
07:17:54 <incluye> :t Int
07:17:55 <lambdabot> Not in scope: data constructor `Int'
07:18:14 <Phyx-> :t I#
07:18:15 <lambdabot> Not in scope: data constructor `I#'
07:18:23 <copumpkin> :k Int
07:18:23 <lambdabot> *
07:18:28 <thoughtpolice_> lambdabot doesn't know about GHC.Prim :>
07:22:15 <Tomsik_> meric: what are you going to use the filter for?
07:22:35 <meric> implement SMO SVM using accelerate.
07:22:45 <Tomsik_> I don't think filter would leave the array with a reasonable shape/indexing
07:22:50 <Tomsik_> SMO SVM?
07:23:03 <meric> sequential minimal optimisation support vector machine
07:23:37 <meric> I thought of an idea... use scan on (map (\x -> (cond arr) ? (1, 0))), that'll get me the indices the permute needed.
07:24:13 <Tomsik_> "sequential" doesn't mix well "parallel"
07:25:08 <bfig> in terms of performance, what foldl >> foldr right?
07:25:16 <meric> hmm I should go tell the professor who told me to do this, that.
07:25:21 <copumpkin> bfig: it isn't that simple
07:25:34 <copumpkin> meric: depends what the "sequential" means there, really
07:26:48 <bfig> copumpkin, in case you're dealing with very large lists foldl should leave it easier for the compiler or interpreter to deallocate as it reads, right?
07:27:07 <copumpkin> not necessarily
07:27:12 <copumpkin> also, foldl is almost never what you want
07:27:16 <copumpkin> foldl' possibly
07:27:33 <copumpkin> that corresponds roughly to tail recursion
07:27:46 <copumpkin> if you have a strict operation you're folding over the list, then that's probably what you want
07:28:08 <copumpkin> if your operation isn't fully strict, and you can consume its result incrementally
07:28:12 <copumpkin> foldr might be better
07:28:41 <bfig> buti n that dcase, won't it allocate the whole list and then compute up to the last value and just then start folding?
07:28:52 <bfig> (all that while holding everything in memory)
07:28:59 <copumpkin> no
07:29:18 <Cale> bfig: Remember that evaluation for the most part proceeds outermost first
07:29:42 <copumpkin> bfig: you're right that in a strict language, you rarely want to use foldr
07:29:47 <copumpkin> but haskell is not strict
07:29:47 <Cale> So if you have f (g x), you evaluate f first, substituting (a reference to) (g x) into the body
07:30:16 <iwtu> Hi guys. Have anyone any idea? http://codepad.org/bwxXCF2n
07:30:22 <bfig> ok, in the case you have !!n ~= !!(n-1) (if you understand what i mean) then it has that problem right?
07:30:26 <Cale> and g x only gets evaluated if something inside the definition of f pattern matches on it
07:30:58 <Botje> iwtu: you cannot patternmatch on a value like that.
07:31:02 <bfig> because you go to the end, then need to compute all the way back to the first index, allocating all memory
07:31:37 <copumpkin> bfig: I don't really understand what you mean by that notation :P but I qualified my statement earlier with "if your operation isn't fully strict"
07:31:39 <Cale> ins' (x:xs) 0 s | s == Seq.empty  would work
07:31:42 <int-e> > foldr (\x xs a -> xs $! x + a) id [1..1000000] 0 -- foldl' (+) 0 [1..1000000] in terms of foldr :-)
07:31:42 <bfig> then you need to recompute everything for each value (unless the compiler is intelligent enough to know that in the next list step you can use the other result
07:31:43 <lambdabot>   500000500000
07:31:57 <Botje> bfig: or | Seq.null s
07:32:00 <bfig> copumpkin, strict means that it always returns the same right? ie, mathematical operation
07:32:04 <copumpkin> no
07:32:07 <Botje> which doesn't impose an Eq constraint on your values
07:32:10 <copumpkin> bfig: all functions are strict in that sense in haskell
07:32:17 <bfig> no side effects?
07:32:20 <copumpkin> never
07:32:21 <Cale> Perhaps I should do my evaluation order demo :)
07:32:25 <bfig> lol
07:32:29 <parcs> Cale: of Seq.null s
07:32:30 <parcs> or*
07:32:34 <Cale> parcs: yeah
07:32:36 <iwtu> Botje: Botje thanks :)
07:32:38 <copumpkin> bfig: haskell is a very different language from ones most people are used to :P
07:32:47 <iwtu> bfig: thanks :)
07:32:50 <bfig> but strict then means no side effects?
07:32:52 <copumpkin> no
07:32:53 <Cale> no
07:32:56 <copumpkin> pure might
07:32:58 <bfig> iwtu, emm?
07:33:02 <Cale> strict is about evaluation order
07:33:04 <bfig> thanking the wrong person :p
07:33:06 <copumpkin> but we don't use it much because everything is
07:33:10 <Cale> (or semantics, but let's not get into that)
07:33:19 <Cale> bfig: So, imagine we have the definition  double x = x + x
07:33:20 <Phyx-> :t 0
07:33:21 <lambdabot> forall t. (Num t) => t
07:33:30 <Cale> and the expression double (double 5)
07:33:35 <Cale> and we want to evaluate it
07:34:00 <Cale> Under innermost-first evaluation (also called strict evaluation), this goes as follows:
07:34:06 <Cale> double (double 5)
07:34:06 <donri> strict is similar in meaning to "greedy" (with non-strict being similar to "lazy")
07:34:10 <Cale> -> double (5 + 5)
07:34:12 <Cale> -> double 10
07:34:16 <Cale> -> 10 + 10
07:34:18 <Cale> -> 20
07:34:24 <copumpkin> Calebot++
07:34:28 <Cale> ;)
07:34:39 <copumpkin> bfig: note that what he just wrote is NOT how haskell works in most cases
07:34:57 <Cale> Right, so we chose to evaluate the innermost function application each time
07:35:14 <Cale> (innermost/leftmost, say, though we didn't have to choose between siblings)
07:35:27 <bfig> we were talking about this the other day in class, you go till you have a weak normal form (or similar term, can't remember)
07:35:33 <Cale> We could also choose to evaluate the outermost function application, which would go like this:
07:35:37 <Cale> double (double 5)
07:35:43 <Cale> -> (double 5) + (double 5)
07:35:49 <Cale> -> (5 + 5) + (double 5)
07:35:53 <Cale> -> 10 + (double 5)
07:35:57 <Cale> -> 10 + (5 + 5)
07:35:58 <Cale> -> 10 + 10
07:36:00 <Cale> -> 20
07:36:30 <Cale> But this is obviously wasteful now, because we duplicated work, evaluating double 5 twice because the x occurs twice in the body of double x = x + x
07:37:34 <Cale> So lazy evaluation says that we do things outermost first, but function parameters are evaluated at most once, and the result shared between their occurrences
07:37:51 <Cale> So, using let/in to represent that sharing, the evaluation looks like this:
07:37:55 <Cale> double (double 5)
07:38:11 <Cale> -> let x = double 5 in x + x -- note that this is outermost-first still
07:38:21 <Cale> -> let x = 5 + 5 in x + x
07:38:26 <Cale> -> let x = 10 in x + x
07:38:30 <Cale> -> 10 + 10
07:38:31 <Cale> -> 20
07:39:25 <Cale> So, this is how a simple Haskell evaluator would do all its evaluation. GHC is actually smarter still, and will choose to do some strict evaluation based on some static analysis of the code, but this is a good approximation to what it'll do.
07:40:07 <Cale> After all, since everything is pure, the order in which we evaluate things doesn't affect the result, as long as we choose an order which terminates.
07:40:27 <Cale> (and if there's an evaluation order which terminates, then the outermost first evaluation will terminate)
07:40:50 <mux> someone should really log this kind of stuff when Cale goes berserk (in a good way)
07:40:54 <Cale> So: under strict evaluation every parameter to a function is evaluated exactly once.
07:40:58 <mux> it'd make for a nice LYAH chapter
07:41:14 <Cale> Under outermost-first evaluation, each parameter is evaluated zero or more times.
07:41:27 <copumpkin> bfig: getting back to your actual question about foldl vs. foldr, another issue is that in many cases the functions aren't even comparable :P you have an implicit assumption, when comparing them, that your operation is associative
07:41:33 <Cale> Under lazy evaluation, you get the best of both worlds, and each parameter is evaluated zero or one times.
07:41:49 <copumpkin> with * or +, in most cases, foldl' would be more efficient
07:41:53 <Cale> bfig: Does all that make sense? :)
07:42:14 * mux pictures bfig nervously writing this stuff down
07:42:18 <Cale> (if it does, we can try evaluating some applications of foldl/foldr and see what happens to understand the performance)
07:42:40 <roconnor> copumpkin: they are compariable in the sense that you can write foldl using foldr
07:43:00 <copumpkin> roconnor: and vice versa, on finite lists :P
07:43:06 <copumpkin> I don't think that's too relevant here though
07:43:21 <Cale> Well, you can even write foldl' in terms of foldr, but you can't do the reverse.
07:46:30 <bfig> Cale, well, i will restate my question in more precise terms, in the case of a pure function dependent on the index, possibly an inductive function, and an associative operation, is it equally performant to foldr or foldl?
07:47:19 <copumpkin> it still depends on whether your operation is strict :)
07:47:30 <copumpkin> keep in mind that when you evaluate a call to foldr
07:47:33 <copumpkin> nothing actually happens
07:47:41 <copumpkin> same when you evaluate a call to foldl
07:47:57 <copumpkin> it gives you a thunk saying "I'll tell you later"
07:47:59 <bfig> i can't find the definition of strict on google
07:49:17 <Cale> bfig: Okay, a function f is strict if when applied to a nonterminating (bottom) argument, it will always fail to terminate.
07:49:25 <roconnor> bfig: a strict strict homomorphism between CPOs is a function mapping bottom to bottom.
07:49:25 <Cale> That is, if f _|_ = _|_
07:49:32 <roconnor> bfig: a strict homomorphism between CPOs is a function mapping bottom to bottom.
07:49:39 <copumpkin> roconnor: clearly that will help him a lot :)
07:49:48 <bfig> ahh yes! now i remember. :)
07:49:49 <roconnor> oh opps
07:49:54 <hpaste> ian__ pasted “:32:7: Empty 'do' construct” at http://hpaste.org/50553
07:49:59 <bfig> what's a CPO?
07:50:07 * hackagebot BiobaseXNA 0.5.0.1 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.5.0.1 (ChristianHoener)
07:50:07 <roconnor> continuous partial order
07:50:09 <Botje> protocol droid.
07:50:22 <Botje> ian__: check that you're not mixing tabs and spaces.
07:50:44 <ian__> there is only one indented line
07:50:46 <Botje> (also, data is a lousy variable name
07:50:49 <Cale> bfig: Strict evaluation is so named because it essentially makes every function be strict by forcing the evaluation of the parameter first.
07:50:55 <Botje> ian__: are you using tabs?
07:50:57 <ian__> no
07:50:58 <roconnor> bfig: it is the structure that Data Scott used to give dentational semantics to programming in such a way that we can solve the equation U = U -> U.
07:51:22 <roconnor> ... I'm not really helping am I
07:51:24 <dolio> I thought CPO was complete partial order.
07:51:29 <Cale> Complete partial order
07:51:34 <roconnor> dolio: ah crap you are right.
07:51:40 <Cale> and actually, I think CPO isn't really what we want
07:51:47 <Cale> we want a directed-complete partial order
07:51:56 <ian__> can't even run it with the error
07:51:56 <copumpkin> bfig: ANYWAY
07:51:57 <Botje> ian__: oh.. it's complaining about your use of the variable name data
07:51:57 <dolio> What's that add?
07:52:04 <Cale> (which just has limits of ascending chains)
07:52:05 <ian__> lolwut
07:52:11 <ian__> data is reserved?
07:52:17 <mux> ETOOMUCHCT
07:52:24 <Botje> ian__: for data declarations, yes
07:52:35 <dolio> What does a plain complete partial order have limits of?
07:52:35 <Cale> That's not category theory, though I could categorify it :)
07:52:38 <Botje> data Maybe a = Nothing | Just a -- and all that
07:52:44 <ian__> oh, derp
07:52:45 <copumpkin> bfig: you can write map, for example, using foldr. In that case, you ideally want the generated list to be incrementally computable
07:53:35 <mux> Cale: please don't :-P
07:54:13 <ciaranm> is mux one of those dirty heretics who thinks maths should be "about something"?
07:54:24 <roconnor> dolio: finite chains? :{
07:54:25 <bfig> i wrote a program using foldr where actually i should've used foldl' i think
07:54:28 <roconnor> dolio: :P
07:54:28 <copumpkin> and this is how newbies learn that category theory is essential to understanding haskell
07:54:40 <copumpkin> "which is faster, foldl, or foldr?"
07:54:47 <copumpkin> "BLAH BLAH BLAH MATH LBAHBLAHB"
07:54:58 <roconnor> copumpkin: my bad
07:55:05 * mux dies laughing
07:55:06 <Cale> Oh, sorry, not just chains, but directed sets: sets with the property that any pair of elements has an upper bound
07:55:06 * hackagebot BiobaseFR3D 0.1.0.1 - Importer for FR3D resources  http://hackage.haskell.org/package/BiobaseFR3D-0.1.0.1 (ChristianHoener)
07:55:09 * hackagebot BiobaseDotP 0.1.0.0 - Vienna / DotBracket / ExtSS parsers  http://hackage.haskell.org/package/BiobaseDotP-0.1.0.0 (ChristianHoener)
07:55:10 <dolio> roconnor: Isn't the limit of a finite chain the last element? :)
07:55:16 <roconnor> dolio: yes!
07:55:16 <Cale> (dcpos have limits for those)
07:55:16 <mux> ciaranm: actually no, i tend to enjoy math :-)
07:55:17 <bfig> what is a good place to learn category theory? i tried a few years back but it was too heavy :(
07:55:32 <ciaranm> bfig: that depends upon how much other maths you know
07:56:02 <bfig> i know some elementary topology and measure theory... some statistics... no idea
07:56:12 <bfig> i don't know much algebra
07:56:12 <roconnor> bfig: the only book on category theory that I've ever understood is Baar & Wells: Category Theory for Computing Science
07:56:14 <ciaranm> bfig: lawvere if you don't want topology, mac lane if you do
07:56:26 <Cale> bfig: you might try http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf
07:56:31 <copumpkin> bfig: we also have ##categorytheory
07:56:42 <roconnor> *Barr & Wells
07:56:44 <Cale> It's my favourite intro book, and doesn't assume too much about the reader.
07:57:12 <Cale> roconnor: Have you tried reading Awodey's book?
07:57:22 <ciaranm> there's also pierce's really really short book
07:57:27 <bfig> i have a mamooth book by Switzer sitting on my shelf
07:57:35 <bfig> i couldn't get past the first chapter
07:58:02 <bfig> it is not about category theory, it is about algebraic topology
07:58:02 <roconnor> Cale: I don't think so
07:58:09 <bfig> completely insane
07:58:15 <Cale> bfig: The Springer book?
07:58:21 <Cale> (yellow)
07:58:59 <bfig> yes
07:59:06 <ciaranm> springer needs to branch out colour-wise. half my bookshelf is yellow. it doesn't match the carpet.
07:59:21 <Botje> ciaranm: change your carpet.
07:59:30 <Cale> Algebraic topology is a decent way to get into category theory (it's the traditional way), but it does tend to lend itself to certain biases about what categories in general are like.
08:00:10 <bfig> i think i'm long past my expiration date on the mathematics department
08:00:10 * hackagebot BiobaseTrainingData 0.1.0.0 - RNA folding training data  http://hackage.haskell.org/package/BiobaseTrainingData-0.1.0.0 (ChristianHoener)
08:00:12 * hackagebot StatisticalMethods 0.0.0.1 - Collection of useful statistical methods.  http://hackage.haskell.org/package/StatisticalMethods-0.0.0.1 (ChristianHoener)
08:00:29 <bfig> i'd like to learn programming better though :)
08:00:30 <ciaranm> the problem with algebraic topology is that in order to understand it, you need to understand basic topology. and to understand that, you need to understand analysis and metric spaces. and in order to understand analysis you need to understand all sorts of useless stuff about reals.
08:00:36 <Cale> bfig: But yeah, if you're just interested in learning CT, then you don't need a book on homotopy theory :)
08:00:42 <Cale> (at least not until later :)
08:00:43 <bfig> i understand topology
08:01:00 <bfig> according to thermo i only need to understand algebra :p
08:01:12 <Cale> hehe
08:01:19 <bfig> admittedly i know NOTHING about algebra
08:01:31 <ciaranm> lawvere's book only assumes (finite) set theory. and it's annoying because of that.
08:01:37 <roconnor> bfig: if you like non-Hausdorff spaces, you'll love programming.
08:01:54 <bfig> when i first picked McLane's CT i couldn't get past the first two pages
08:02:14 <bfig> he suddenly defines categories on about 10 things, and id didn't knew what half of them meant >_>
08:02:32 <ciaranm> you can still get a lot from mac lane even if you only understand half the examples
08:02:33 <Cale> bfig: Awodey was MacLane's student, and he's managed to do a much better job than his predecessor of making his book accessible, I think.
08:03:13 <tomh-> is there a caball command to install profiling libs for a package?
08:03:25 <copumpkin> someone needs to write "learn category theory the hard way"
08:03:32 <ciaranm> speaking of books, has anyone managed to get their hands on moore's "nature of computation"?
08:03:52 <roconnor> tomh-: yes, but I forget what it is.
08:04:02 <kmc> tomh-, set 'library-profiling: True' in ~/.cabal/config
08:04:03 <ciaranm> copumpkin: lawvere!
08:04:03 <ocharles> Hey, I think it's about time I started to look at testing for my app, and I was wondering if QuickCheck was a good option. I mostly want to test some database interaction, so I was going for invariants like: getById 5 returns something with id 5 (or Nothing)
08:04:12 <bfig> copumpkin, several people have tried so far
08:04:17 <kmc> tomh-, then cabal install --reinstall foo
08:04:17 <ocharles> does that seem a good choice for QuickCheck, or should I go for something more xunit like?
08:04:19 <tomh-> kmc thanks!
08:04:22 <kmc> there is also a commandline option
08:04:28 <roconnor> tomh-: there is a command line option
08:06:09 <bfig> copumpkin, most have succeeded as far as i'm concerned >_>
08:06:13 <tomh-> im using the config option now
08:06:14 <copumpkin> :P
08:06:44 <Cale> ocharles: Probably, yes.
08:07:37 <roconnor> BTW, what is the typical tool for making vector graphics drawings of categorical diagrams?
08:07:46 <ocharles> My only concern was that my test database will only have about 5 ids, so there's not a huge amount of possible test data
08:09:06 <maltem> roconnor, do you mean xypic?
08:10:02 <Cale> roconnor: xy-pic or Paul Taylor's diagrams package
08:12:24 <Cale> Or TikZ for things more complicated than commutative diagrams. (It's not great at commutative diagrams, but it can draw arbitrary things.)
08:12:31 <tomh-> ugh is there any command flag that also installs all dependencies with profiling enabled? :P
08:12:54 <maltem> cabal -p ?
08:13:07 <edwardk> you can put the profile enabling flag in your .cabal/config
08:13:11 <Cale> tomh-: Put  library-profiling: True  in your ~/.cabal/config
08:13:18 <tomh-> Cale: I have that
08:13:23 <Cale> also,  documentation: True
08:13:32 <Cale> (though that's unrelated)
08:13:41 <Cale> It should always build profiling stuff then...
08:13:44 <tomh-> but when I reinstall something it complains that the dependencies don't have profiling enabled
08:13:50 <tomh-> so I have to reinstall those aswell
08:13:53 <edwardk> yeah
08:13:56 <Cale> Maybe things installed before you added the flag?
08:13:58 <tomh-> so I was wondering if I could resolve that automatically
08:14:01 <tomh-> yeah
08:14:04 <edwardk> fraid not
08:14:08 <tomh-> ok
08:14:23 <Cale> Just reinstall those packages that you installed before adding the flag (or blow away your .ghc and start over :P)
08:15:40 <tomh-> I guess im just reinstalling all my packages again
08:16:40 <Cale> It's kind of absurd that those flags aren't default.
08:17:37 <tomh-> unfortunately..
08:17:50 <tomh-> if you enable profiling, does it impact the performance?
08:18:19 <maltem> it will always also install the non-profiling library
08:18:51 <thoughtpolice_> it just sucks because it increases build time so substantially, since you have to build 2 copies of one package. same with building shared
08:18:56 <tomh-> ok, so those profiling versions are only used if you compile your program with the -prof flag right?
08:19:05 <maltem> right
08:19:10 <thoughtpolice_> tomh-: yes, unfortunately :( -prof also disables optimizations IIRC
08:20:04 <tomh-> thats ok
08:20:06 <kmc> Cale, the problem is that it's not clear whether Haskell Platform is for Haskell developers or end-users of Haskell software
08:20:41 <Cale> -prof doesn't disable optimisations
08:20:47 <Cale> At least not all of them
08:21:29 <Cale> Well, I honestly don't know about recent GHCs, but I know that in the past, my profiling output has been drastically affected by optimisations being on or off (due to inlining)
08:21:52 <tomh-> the book adds both -O2 and -prof
08:21:55 <mm_freak> what's the state of haskell on smartphones?
08:21:57 <tomh-> (real world haskell)
08:22:16 <thoughtpolice_> hm, I may be thinking of something else.
08:22:18 * thoughtpolice_ looks
08:27:31 <ocharles> Any idea what this means? I get this error when I run `cabal build` - Loading package bookbrainz-0.1 ... linking ... ghc: /home/ollie/Work/BookBrainz/dist/build/HSbookbrainz-0.1.o: unknown symbol `bookbrainzzzm0zi1_BrainzzStemziTypes_rkey_closure'
08:27:32 <ocharles> ghc: unable to load package `bookbrainz-0.1'
08:27:42 <tomh-> profiling is quite nice, just found that one function uses 99.9% of the execution time :)
08:28:04 <ocharles> cabal build successfully builds bookbrainz-0.1 (the library defined in the cabal file), and this error happens when it tries to build the associated executable, when it uses TH
08:40:07 * hackagebot netwire 1.1.0 - Arrowized FRP implementation  http://hackage.haskell.org/package/netwire-1.1.0 (ErtugrulSoeylemez)
08:45:07 * hackagebot instinct 0.1.0 - Fast artifical neural networks  http://hackage.haskell.org/package/instinct-0.1.0 (ErtugrulSoeylemez)
09:00:08 * byorgey makes grilled peach halves topped with whipped lambda
09:03:53 <ion> Why doesn’t Data.Monoid define an instance for IO, i wonder?
09:04:41 <kmc> well, that's a kind error
09:04:47 <kmc> do you mean (IO ()) ?
09:05:08 <ion> instance Monoid a => Monoid (IO a) where { mempty = return mempty; mappend = liftM2 mappend }
09:05:14 <kmc> oh
09:06:00 <kmc> is that commonly wanted?
09:06:14 <byorgey> that works for any Applicative, not just IO
09:06:22 <kmc> yeah
09:06:39 <ion> Dunno, i was just wondering, since it has a number of instances for Prelude types.
09:07:06 <kmc> unfortunately "instance (Monoid a, Applicative f) => Monoid (f a)" does not really work the way one would like
09:07:19 <kmc> so you're stuck writing a separate instance for every applicative functor
09:07:27 <copumpkin> or instance Monad m=> Monoid (m a)
09:07:34 <copumpkin> or Applicative
09:07:36 <byorgey> well, you could make a newtype wrapper
09:07:49 <copumpkin> :t (*>)
09:07:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
09:07:55 <copumpkin> :t (*>) `asTypeOf` mappend
09:07:56 <lambdabot> forall (f :: * -> *) a. (Applicative f, Monoid (f a)) => f a -> f a -> f a
09:08:07 <mm_freak> why would one want that anyway?  i'm happier using 'pure mempty' and 'liftA2 mappend' directly
09:08:17 <mm_freak> appears to be cleaner to me
09:08:26 <benmachine> mm_freak: e.g. in a Writer monad
09:08:31 <byorgey> mm_freak: because you get to use all the other machinery defined in terms of Monoids
09:08:38 <byorgey> Writer monad, Foldable, ...
09:08:47 <mm_freak> i see
09:08:55 <Cale> As a good example of the lifting instance being useful:
09:08:57 <mm_freak> i think, i've never used Writer
09:09:15 <benmachine> Writer is p cool
09:09:23 <Cale> > sortBy (comparing length `mappend` compare) (words "here is a list of words to sort first by length and then alphabetically")
09:09:25 <lambdabot>   ["a","by","is","of","to","and","here","list","sort","then","first","words",...
09:09:25 <copumpkin> writer is money
09:09:27 <copumpkin> totally money
09:09:34 <benmachine> writer is my bro
09:09:45 <mm_freak> dunno, never found a use for Writer, which wouldn't be either more elegantly or more efficiently expressed using other abstractions
09:09:46 <copumpkin> benmachine: you a brogrammer like thoughtpolice_ ?
09:09:48 <Cale> So, that's lifting a monoid instance over functions, twice :)
09:09:53 <benmachine> copumpkin: umm, sure
09:09:56 * mux really likes the Ord instance of Monoid too
09:10:01 <benmachine> whatever those are :<
09:10:19 <edwardk> writer is pretty nice, but the monoid constraint is annoying, and pass and listen are something that belong in a refined subclass
09:10:28 <copumpkin> > sortBy (comparing length `mappend` compare) cake
09:10:30 <lambdabot>   ["Alpha resins.","Cranial caps.","Four large eggs.","Fish shaped dirt.","On...
09:10:42 <byorgey> I define the lifting instance here: http://hackage.haskell.org/packages/archive/diagrams-core/0.3/doc/html/Graphics-Rendering-Diagrams-Monoids.html#g:4
09:10:48 <byorgey> really ought to pull it out into its own tiny package
09:10:51 <copumpkin> edwardk: one with a monocle?
09:11:02 <edwardk> byorgey: it is in 'reducers'
09:11:08 <byorgey> oh, is it?  good to know
09:11:24 <edwardk> and the older 'monoids' package which is largely deprecated in favor of reducers
09:11:40 <byorgey> hmm, that's a lot of dependencies to pull in just for that instance though
09:12:11 <edwardk> well, i have lots of competing concerns, reducers wound up on the heavyweight side to keep other things light
09:12:37 <edwardk> maybe i can pull some of the instances out and put them in semigroups, at least the haskell 98 ones
09:12:41 <byorgey> yeah, I understand
09:13:05 <byorgey> that could be nice, I already depend on semigroups anyway
09:13:07 <edwardk> most of the Data.Semigroup.* instances in there don't depend on the reducer functionality
09:13:12 <byorgey> right
09:13:39 <kmc> i'm wondering whether i should add "deriving Generic" to one of my libs, and if so, how to best conditionalize it to GHC 7.2
09:13:59 <dolio> CPP
09:14:02 <dolio> Unfortunately.
09:14:03 <edwardk> byorgey: i'll do so then, it may take me a couple of days to find time
09:14:13 <byorgey> edwardk: thanks. no rush.
09:14:32 <dolio> Unless you want to make a separate module with an orphan deriving or something.
09:14:56 <edwardk> yeah CPP is pretty much the way to do it
09:14:59 <ezyang> Hey edwardk!
09:15:04 <edwardk> heya
09:15:22 <ezyang> Do you have time to chat about substructural logics, or not really? :^)
09:15:31 <edwardk> i have a meeting in about 15 minutes or so, but after that definitely
09:15:32 <kmc> dolio, iirc {-# LANGUAGE #-} inside #ifdef didn't work correctly before GHC 7
09:15:44 <ezyang> k
09:15:50 <edwardk> kmc: what i do is put the CPP in the extensions list for my cabal file
09:16:05 <edwardk> er the LANGUAGE pragma i need conditionally in the extensions list
09:16:18 <kmc> hmm
09:16:26 <kmc> i'm currently not listing extensions in .cabal at all
09:16:29 <edwardk> so i make a flag for it, make the flag turn on the extension and toggle it on by default or when i have a compiler that gives it to me
09:16:32 <kmc> should i do that?
09:16:37 <edwardk> in general no
09:16:46 <kmc> edwardk, which of your packages does this? i'd like an example i can crib off of
09:17:00 <edwardk> i recommend using other-extensions: to document the ones you use, then using extensions: to toggle on conditional dependencies
09:17:08 <Ihmahr> Hy. I'm used to program in Prolog. I'm finding it difficult to have my haskell give output. For example, how would you have a factorial function (defined recursively) give output on every iteration?
09:17:13 <edwardk> lots of them do, let me see if i can find one that does it the way i prefer though ;)
09:17:28 <kmc> Ihmahr, generally you don't.  in Haskell, function evaluation can't cause IO to occur
09:17:35 <Ihmahr> Just the regular     fac 0 = 1     and        fac n = fac ( n-1 ) * n
09:17:36 <kmc> Ihmahr, but there's Debug.Trace for quick hack debugging sorts of things
09:18:33 <Ihmahr> Okay, more specifically I would like to print a grid. Say ... a 9x9 sudoku grid and print 9 variables per line.. how would I go about that?
09:18:39 <edwardk> https://github.com/ekmett/data-lens/blob/unboxed/data-lens.cabal from the unreleased rewrite of data-lens is pretty solid
09:18:53 <kmc> Ihmahr, http://www.haskell.org/haskellwiki/Introduction_to_IO
09:19:02 <kmc> Ihmahr, what Haskell tutorial are you reading?  it should discuss IO at some point
09:19:51 <kmc> Ihmahr, one option is to turn the whole grid into a string
09:19:57 <kmc> :t unlines . map (unwords . map show)
09:19:58 <lambdabot> forall a. (Show a) => [[a]] -> String
09:20:15 <kmc> > unlines . map (unwords . map show) [[1,2,3],[4,5,6],[7,8,9]]
09:20:16 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
09:20:16 <lambdabot>         against inferred ty...
09:20:25 <edwardk> kmc: that example straightforward enough?
09:20:25 <kmc> > unlines . map (unwords . map show) $ [[1,2,3],[4,5,6],[7,8,9]]
09:20:27 <lambdabot>   "1 2 3\n4 5 6\n7 8 9\n"
09:20:38 <dolio> kmc: I always put the extensions used in the cabal file.
09:20:45 <edwardk> kmc: though i don't recommend exposing modules based on flags that way
09:21:00 <confound> hmm, wish I'd known about Debug.Trace earlier
09:21:07 <kmc> @quote oasis
09:21:08 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
09:21:11 <dolio> There's kind of a weird situation there, though.
09:21:18 <kmc> edwardk, hmm, looking
09:21:21 <edwardk> using other-extensions tells you what extensions are being used in the package, using extensions turns on all sorts of stuff you may not need everywhere
09:21:35 <kmc> i see
09:21:49 <kmc> are the LANGUAGE_ macros special, or is that just your convention?
09:21:51 <edwardk> kmc: there i'm saying i always want to use CPP, and give me Rank2Types and UnboxedTuples if they are available
09:21:55 <edwardk> just my convention
09:22:00 <dolio> If you put them in the cabal, you don't need to put them in the files. And if you put them in the files, you don't need to put them in the cabal, at least for compiling purposes.
09:22:26 <kmc> turning on DeriveGeneric everywhere seems pretty harmless though
09:22:26 <edwardk> dolio: not yet, though there is talk about making it so that cabal can check if the extensions you use are in the other-extensions list
09:22:32 <Ihmahr> would there be a way where I could go threw the array recursively in order to print (parts of) the array..? Anyone who is used to program in PROLOG?
09:22:42 <edwardk> kmc: if the compiler supports it
09:22:46 <kmc> Ihmahr, i showed you above one way to do it
09:22:51 <kmc> Ihmahr, also you didn't answer my questions
09:23:07 <kmc> edwardk, right... so can i make one of these blocks conditional on a GHC version instead of a flag?
09:23:13 <kmc> istr yes, but don't remember the syntax
09:23:19 <edwardk> yeah
09:23:23 <edwardk> one sec
09:23:58 <Ihmahr> kmc, I'm working from the book 'seven languages in seven weeks' and 'yaht'
09:24:14 <kmc> uh huh
09:24:16 <edwardk> if impl (ghc < 6.9) { …. }
09:24:20 <kmc> Haskell is not a language you learn in a week
09:24:29 <kmc> Ihmahr, take a look at LYAH and RWH
09:24:30 <kmc> @where LYAH
09:24:31 <lambdabot> http://www.learnyouahaskell.com/
09:24:32 <kmc> @where RWH
09:24:32 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:25:04 <Ihmahr> No, that book is aimed at giving an intro to several declarative languages.
09:25:52 <Ihmahr> Yes, I have also been working with learnyouahaskell
09:27:02 <kmc> i'm looking at the code examples from that seven languages book
09:27:06 <kmc> for haskell
09:27:52 <kmc> i am... suspicious
09:27:58 <kmc> but it's hard to judge, out of context
09:28:12 <kmc> edwardk, thanks
09:28:14 <kmc> i'll try that
09:28:59 <Ihmahr> Kmc, It's not covered in the Seven book.
09:29:09 <mistertim> Hi all! This might be a silly question, but I was wondering - it's possible to write a function type signature that takes, for instance, two arguments, both of which are lists of the same type: f :: [a] -> [a] -> b. It's also possible to write one where the lists may contain different types: g :: [a] -> [b] -> c. However, is it possible to express in a type signature that two type variables MUST represent different concrete types?
09:29:24 <edwardk> mistertim: yes
09:29:32 <kmc> i was about to say "no" :)
09:29:39 <mistertim> edwardk - aah cool! How could i go about doing that?
09:29:39 <kmc> there's a hack for it, i think
09:29:51 <kmc> it's not generally a reasonable thing to do
09:29:59 <mistertim> it seems a little grungy, but seemed like an interesting idea
09:30:10 <edwardk> casey mccann posted it to stack overflow a few weeks back, one sec.
09:30:16 <d-day> type families?
09:31:11 <edwardk> http://stackoverflow.com/questions/6939043/is-it-possible-to-place-inequality-constraints-on-haskell-type-variables
09:31:25 <edwardk> see his const' :: (a ~/~ b) => a -> b -> a example
09:31:41 <erus`> i wish i could put cash into my modem
09:31:44 <mistertim> aah, thanks edward, that's fantastic - I'll have a read!
09:31:48 <erus`> i should go on dragons den
09:32:36 <kmc> olegggggggg
09:32:43 <edwardk> heh
09:32:54 <kmc> :/~
09:33:10 <kmc> that operator name pretty much sums up how i feel about this hack
09:33:47 <dolio> Yep.
09:34:05 <edwardk> looks like the operator is leaning out the door and waving at us
09:34:25 <kmc> to me it's a drooling version of :/
09:34:38 <byorgey> I thought it was barfing
09:35:30 <danr> mistertim: out of curiosity, why would you want to do this? :)
09:38:05 <kmc> it's probably useful for type-level computation
09:39:04 <shachaf> kmc: Where could it be useful there?
09:39:17 <kmc> iunno
09:41:33 <danr> his example seemed to suggest lists
09:49:01 <zzo38> Now you can do conditional compilation with Template Haskell because I wrote a code to do it. Is it useful to you?
10:15:41 <mistertim> danr: i've been playing with using generalised algebraic data types to work with securities market orders in a type-safe way, so each order has type Order Buy Limit , Order Buy Maret, Order Sell Limit, or Order Sell Market, and it's a type error to pass one to a function that expects another. However, I've got also got an order matching function that matches a market order to a limit order on the other side of the book, that would intuituvely have type Order
10:15:41 <mistertim> a Limit -> Order b Market -> Trade , where a != b - was wondering whether I could express this through the type system
10:15:51 <mistertim> (lists was just a convenient example)
10:21:18 <kmc> mistertim, maybe a multi-param type class
10:21:31 <kmc> class Matches a b; instance Matches Limit Market; instance Matches Market Limit
10:21:43 <kmc> match :: (Matches s t) => Order a s -> Order b t -> Trade
10:21:44 <erus`> how does haskell compile an ID function (\a -> a) into a module?
10:21:54 <kmc> "Haskell" doesn't compile anything
10:22:02 <kmc> the Report has little to say about implementation details
10:22:16 <erus`> ghc
10:22:31 <kmc> you're asking how ghc compiles an identity function?
10:22:33 <Botje> erus`: much like gcc compiles an id function.
10:22:48 <kmc> (i don't know how relevant the module concept is)
10:22:59 <erus`> C cant return a forall :|
10:23:11 <Botje> sure it can
10:23:21 <erus`> void* ?
10:23:36 <Botje> int id(int x) { return x; } -- cast as appropriate.
10:23:37 <kmc> erus`, you should read "implementing lazy functional languages on stock hardware" and then "how to make a fast curry"
10:24:03 <Botje> erus`: or the book "implementation of functional programming languages" by simonPJ. especially the chapter about the G machine
10:24:51 <erus`> Botje: if i call id() with a long long it will return an int
10:25:10 <edwardk> botje: that is a good reference. another one is rob ennals' thesis. which being about an improvement to the spineless tagless g-machine talks a LOT about the current implementation
10:25:45 <Botje> erus`: fair enough. so you compile id_int and id_long_long and id_char* and id_void* and so on
10:25:50 <Botje> erus`: guess what GHC does .. :)
10:26:10 <erus`> yeah but it cant know every type :|
10:26:21 <Botje> it doesn't have to
10:26:35 <Botje> it knows exactly which instances of id to compile
10:26:46 <erus`> im talking about a binary module. is that even possible?
10:27:01 <erus`> liek a dynamic link lib
10:27:02 <Botje> you mean module as in haskell module?
10:27:21 <kmc> erus`, http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution
10:27:21 <edwardk> erus`: types of kind * have a fairly homogeneous representation
10:27:25 <erus`> could i compile id a = a as a binary and use it from another program?
10:27:33 <edwardk> erus`: yes
10:28:00 <kmc> there was some ghc wiki page with great detailed examples of how various haskell functions compiled
10:28:08 <kmc> can't find it now :/
10:28:12 <erus`> ghc complexity is approaching the level of magnets
10:28:20 <kmc> erus`, indeed
10:28:49 <byorgey> most physical realizations of ghc actually involve magnets
10:29:06 <thoughtpolice_> some parts of GHC are pretty complex, yea. the RTS is no joke and probably the scariest thing if you ask me (also because SimonM is a rather large 'bus factor' :)
10:31:10 <kmc> GHC is pretty fancy, yeah
10:31:15 <mistertim> kmc - aah, that's a very good idea, thanks!
10:31:42 <mistertim> should get rid of a hell of a lot of hacky nonsense I've written but not been massively pleased with
10:31:43 <kmc> the core answer to "how do I compile Haskell code to something approaching efficient machine code" is not all that complicated
10:31:50 <kmc> but it does take a while to wrap your head around
10:31:57 <kmc> erus`, the two papers i mentioned should get you pretty far
10:32:12 <erus`> thanks kmc
10:32:19 <thoughtpolice_> there are also various papers by SPJ et al that study more specific optimizations more in depth
10:32:47 <thoughtpolice_> CPR, specific inlining strategies, etc. granted the 'secrets of the GHC inliner' paper is probably woefully, woefully out of date
10:32:47 <kmc> it's actually really good to know this stuff if you want to write fast haskell code
10:33:02 <kmc> the actual details of what machine code GHC emits are not all that relevenat
10:33:17 <kmc> but having a really good understanding of the abstract graph reduction model is quite important
10:33:25 <thoughtpolice_> yeah, it's more leveraging the execution model than really hardcore looking at ASM
10:33:48 <thoughtpolice_> (although sometimes you want to, but you need C-- and core and everything else to make a lot of sense of it)
10:33:56 <kmc> i started working on a GHC decompiler
10:33:59 <kmc> for amd64
10:34:01 <kmc> fun stuff
10:34:14 <copumpkin> :O
10:34:31 <kmc> it's one of n+1 projects i may or may not ever return to
10:34:41 <copumpkin> sounds familiar :)
10:34:49 <kmc> along with the ptrace-based live profiler
10:35:02 <shachaf> ptrace-based live profiler?
10:35:04 <kmc> live meaning you can attach to a running process, which was not built with -prof, and get some stats right away
10:35:12 <kmc> i know Hades is supposed to do that and a lot more
10:35:37 <copumpkin> we should kidnap zygoloid_ and make Hades happen
10:35:56 <kmc> i actually thought of a new, more efficient way to do it
10:36:18 <luite> how do you find out to which cost center an instruction belongs?
10:36:46 <kmc> it would give you rather different info from what GHC's profiling gives you
10:37:16 <kmc> basically a count of how many times each entry function was called in the past n seconds
10:37:48 <kmc> i was going to do this by placing breakpoint interrupt instructions at each one
10:38:12 <kmc> but now i think i'd rather inject the counting code into the target process
10:38:15 <kmc> and place jumps instead
10:38:17 <kmc> much lower overhead :)
10:38:30 <luite> ah i thought it would be more the random sampling kind of profiler
10:38:39 <kmc> you could do that too
10:38:59 <kmc> but i think it's less useful, because you can't walk the stack on each sample
10:39:10 <kmc> if you walk the GHC stack you get something weird
10:39:43 <kmc> linux's ptrace syscall is fun
10:39:56 <kmc> it's not exactly what i would call a well-designed API
10:40:00 <luite> in a scary kind ofway:p
10:40:01 <kmc> but you can do some nice tricks with it
10:40:43 <kmc> i.e. http://blog.nelhage.com/2010/08/write-yourself-an-strace-in-70-lines-of-code/ http://blog.nelhage.com/2011/01/reptyr-attach-a-running-process-to-a-new-terminal/ http://mainisusuallyafunction.blogspot.com/2011/01/implementing-breakpoints-on-x86-linux.html
10:42:22 <kmc> other fun things you can do include: hijacking running SSH sessions
10:44:30 <copumpkin> yay
10:44:46 <copumpkin> I've used dtrace to sniff SSL connections :)
10:44:50 <copumpkin> it's fairly straightforward and fun!
10:45:17 <luite> ubuntu has some patch that makes that impossible for regular users
10:45:28 <copumpkin> oh yeah, you need to be superuser on mac os to do it, too
10:45:44 <copumpkin> but it's very handy
10:46:00 <luite> are you selling rootkits or something? ;p
10:46:09 <copumpkin> if proprietary programs you run are speaking things you don't understand, and you want to understand
10:46:24 <copumpkin> I used it a lot when documenting all the protocols itunes uses to talk to the iphone
10:46:36 <copumpkin> since it opens a virtual tcp connection over usb to it, and then initiates an SSL session over that
10:47:59 <danr> mistertim: ok, interesting!
10:50:02 <luite> copumpkin: ah, interesting.
10:50:23 <thoughtpolice_> ptrace is quite the handy little thing. as another example of it's versatility, user-mode-linux is built entirely on top of ptrace :)
10:50:46 <kmc> yeah
10:50:57 <kmc> though uml wants host kernel patches for best performance, or at least it did last time i used it, n years ago
10:51:02 <thoughtpolice_> (that is, it's the only thing in the host kernel that's absolutely 100% required, you can trim a lot of other crap and still run UML)
10:51:09 <kmc> *nod*
10:51:09 * copumpkin tries to remember what he used UML for a few years ago
10:51:11 <thoughtpolice_> yeah, using only ptrace has bad performance ramifications on that note
10:52:04 <thoughtpolice_> on the note of performance stuff i've been playing around with 'perf' since i updated my linux kernel to 3.ZOMG
10:52:06 <kmc> what's the best way for me to set up a cleanroom environment where i can play with GHC 7.2?
10:52:08 <thoughtpolice_> it's quite the awesome little tool
10:52:52 <thoughtpolice_> kmc: use binary dist, I believe you can --prefix it somewhere in the ./configure step and just keep it out of $PATH
10:52:56 <thoughtpolice_> (iirc)
10:52:59 <luite> kmc: a separate user account where you install ghc in your homedir?
10:53:09 <kmc> i really should set up a sane debian vm that i can clone for such experiments
10:53:14 <kmc> but ugh, virtualization is such a brute-force solution
10:53:15 <thoughtpolice_> so just ./configure --prefix=$HOME/ghc-7.2, etc
10:53:25 <thoughtpolice_> yeah, almost overkill just for GHC :/
10:53:27 <luite> I always install my GHC in ~/haskell/ghc
10:53:51 <kmc> "i need process isolation, but my OS is from the 1970's"  "okay, let's reimplement an x86 CPU and all the PC platform hardware in C... that'll be more secure, right?"
10:53:56 <thoughtpolice_> personally i just man up and install shit into /usr/local, then differentiate thanks to cabal install's -w flag
10:53:59 <thoughtpolice_> :P
10:54:08 <thoughtpolice_> granted this gets confusing when i need to install something and i forget -w sometimes
10:54:29 <kmc> i'm getting ghc: panic! (the 'impossible' happened) (GHC version 7.2.1 for x86_64-unknown-linux): Prelude.read: no parse
10:54:35 <kmc> on my package.conf.inplace
10:54:56 <kmc> when i build with ~/prefix/bin/cabal and then run ~/prefix/bin/ghci -package-conf package.conf.inplace
10:58:41 <kmc> huh, i think it's still using the old ghc
10:58:50 <kmc> i'll use ptrace to find out!
11:01:12 <kmc> yep, it calls the old ghc
11:13:05 <kmc> hmm, so i have to import GHC.Generics to derive Generic, and i have to depend on ghc-prim to do that?
11:13:12 <kmc> i guess that's fair, but less than ideal
11:22:03 <dreixel> kmc: yes
11:22:15 <erus`> why is dons in Singapore ?
11:22:22 <dreixel> why is that less than ideal?
11:22:46 <ezyang> Because Singapore is awesome!
11:22:50 <kmc> it adds an extra dependency i don't need otherwise
11:22:52 <kmc> is all
11:23:12 <kmc> what's the rationale for putting it int ghc-prim and not base?
11:23:24 <dreixel> kmc: it was there already
11:23:35 <dreixel> from the times of the earlier generic classes
11:23:39 <dreixel> I've never given it much thought
11:23:49 <dreixel> but it depends on things like GHC.Types, for instance
11:23:55 <dreixel> which are also on ghc-prim
11:26:07 <erus`> @src sum
11:26:07 <lambdabot> sum = foldl (+) 0
11:26:35 <erus`> @src foldl'
11:26:36 <lambdabot> foldl' f a []     = a
11:26:36 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:26:40 <erus`> @src foldl
11:26:40 <lambdabot> foldl f z []     = z
11:26:40 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:28:15 <copumpkin> preflex: seen dons
11:28:15 <preflex>  dons was last seen on #haskell 52 days, 19 hours, 12 minutes and 55 seconds ago, saying: tommd: i manually ran it a couple of times, after the captcha was added
11:28:31 <erus`> @src fix
11:28:31 <lambdabot> fix f = let x = f x in x
11:30:55 <wkmanire> Anyone willing to give their opinion on Learn You A Haskell as an introduction to the language?
11:31:06 <kmc> wkmanire, it's highly recommended by this channel
11:31:10 <kmc> i haven't read much of it myself
11:31:12 <erus`> i have only just learnt that one can do f (x + 1) = blah
11:31:20 <erus`> can i use any function in pattern match?
11:31:20 <kmc> erus`, not in Haskell 2010
11:31:22 <kmc> no
11:31:27 <kmc> n+k is a limited special case
11:31:33 <kmc> but read about the ViewPatterns extension
11:31:33 <erus`> aww
11:31:38 <kmc> for something kind of similar
11:31:40 <erus`> mind nearly fucked
11:31:46 <kmc> erus`, another definition of fix is:  fix f = f (fix f)
11:31:49 <erus`> *blown
11:31:59 <kmc> this is equivalent to the "let" one, except sometimes less efficient
11:32:46 <benmachine> wkmanire: it formed a significant component of my education, I liked it
11:32:47 <roconnor> @type fix
11:32:48 <lambdabot> forall a. (a -> a) -> a
11:33:10 <copumpkin> "if X implies X, then X"
11:33:25 <erus`> could functions in patterns work in theory?
11:33:27 <kmc> not exactly logically sound
11:33:35 <benmachine> @type fix id
11:33:37 <lambdabot> forall a. a
11:33:38 <benmachine> "X"
11:33:55 <kmc> erus`, you need to invert them
11:34:02 <copumpkin> "sheep have wings" implies "sheep have wings"
11:34:07 <copumpkin> therefore, sheep have wings
11:34:12 <benmachine> erus`: suppose you had f (const 0 x) = x, that can't really work
11:34:24 <benmachine> copumpkin: false, therefore shh
11:34:31 <benmachine> or rather
11:34:41 * benmachine searches a bit
11:34:47 <erus`> :t (const 0 2)
11:34:48 <lambdabot> forall t. (Num t) => t
11:35:03 <benmachine> ⊥, therefore copumpkin smells
11:35:03 <DevHC_> guess what
11:35:05 <kmc> if f's inverse is g, you can convert "h (f x) = y" to use a view pattern: "h (g -> x) = y"
11:35:12 <DevHC_> i've made a directory chain on my filesystem
11:35:16 <DevHC_> trol/trol/trol/trol/...
11:35:21 <DevHC_> depth: 1000000
11:35:35 <DevHC_> </sp4m>
11:35:43 <erus`> thank god for rm -r
11:35:52 <DevHC_> that will run forever, lol
11:36:07 <gajop> erus`, also i don't think it will always work if it's too deep or something
11:36:36 <gajop> remember a friend telling me he had trouble with something similar, a really deep tree and commands would fail with f.e "too deep path"
11:36:47 <erus`> kmc: what if i wanted to match f (add 1 2) = 3
11:37:45 <erus`> or would no one ever need todo that
11:37:50 <shachaf> > let f (subtract 1 -> 2) = 3; f _ = 0 in (f 3, f 4)
11:37:51 <lambdabot>   (3,0)
11:38:11 <shachaf> But it's probably not really what you want.
11:38:41 * shachaf wonders if the =>-for-Maybe view pattern syntax will ever be implemented.
11:39:29 <erus`> you could potentially do away with guards :O
11:39:30 <wkmanire> benmachine, kmc: Thanks. The "Holy Shit" sun was funny too. So I'll give it a good read through.
11:40:11 <cheater> what is the holy shit sun?
11:40:30 <wkmanire> cheater: http://learnyouahaskell.com/
11:41:06 <cheater> ahh yes
11:41:10 <erus`> did anyone else uninstall haskell platform after getting half way through that book?
11:41:14 <cheater> i had my input into that page
11:41:18 <cheater> i like it
11:41:26 <cheater> and into the book
11:41:53 <cheater> wait, no, not the book, just the page
11:42:19 <gajop> erus`, how's that? the book looks good to me so far :P
11:42:42 <erus`> gajop: what other programming languages do you know?
11:42:52 <gajop> a lot
11:43:22 <gajop> not any purely functional though
11:43:57 <erus`> i just found haskell too different i guess
11:44:21 <erus`> so i was like fuck this shit. and then a week later i installed again and here i am months later :P
11:44:40 <gajop> yep, me too, but i've been cracking at it slowly, i'm still newbie in it
11:44:43 <Twey> Personally I find that the more different the better :þ
11:45:30 <Twey> Took me months to get monads, but then back in those days we were stuck with YAHT and the like… none of these nice friendly introductions like LYAH and RWH.  You kids don't know how good you've got it…
11:45:44 <copumpkin> you kids should stop trying to learn monads :P
11:45:47 <copumpkin> fuck monads
11:45:52 <wkmanire> gajop: I work in a lot of other langauges too. From the little bit of study I've done so far on functional programming, it has made some improvements on how readable my code is
11:45:57 <erus`> give me gonads over monads any day of the week
11:46:00 <copumpkin> learn haskell
11:46:41 <wkmanire> gajob: I'm looking forward to digging into this way of thinking differently about problems.
11:46:58 <wkmanire> Especially for the javascript work I do.
11:47:00 <clsmith> i'd sometime like to write a blog post on how monads are like poor metaphors which confuse beginners into not really knowing what the hell monads are.
11:47:25 <shachaf> @quote metaphor
11:47:26 <lambdabot> psnl says: this metaphor is like a leaky screwdriver
11:47:31 <shachaf> @quote monad.*metaphor
11:47:32 <lambdabot> tensorpudding says: A monad metaphor is like a metaphor, but less helpful.
11:47:57 * gajop *skips 5 chapters ahead to monads*, right, let's get started
11:48:16 <erus`> i watched this really funny video
11:48:39 <confound> about monads
11:48:53 <erus`> with this guy explaining monads; and throughout the whole thing he was reassuring the watcher that this is not complicated or hard. like every 20 secs
11:48:57 <erus`> i was dead funny
11:49:08 <kmc> erus`, that's kind of the feeling i get reading RWH
11:49:29 <cheater> erus you got an url?
11:49:35 <erus`> yeah hang on
11:49:58 <erus`> http://channel9.msdn.com/ShowPost.aspx?PostID=358968#358968
11:50:02 <cheater> lol ok
11:50:03 <erus`> you need silverlight :(
11:50:07 <cheater> oh
11:50:15 <chee1> erus`: Is that the greg meredith series?
11:50:24 <cheater> im on a free operating system
11:50:28 <cheater> so i dunno
11:50:53 <chee1> oh, I guess not
11:51:01 <wkmanire> This guy sure is odd.
11:51:06 <cheater> o ok
11:51:33 <erus`> cheater: there is a .wmv li8nk at the side if you have a player that plays those
11:51:44 <cheater> thanks for the link
11:51:45 <cheater> i gtg
11:51:46 <cheater> bbl
11:57:49 <chrisdone> just saw this paste: http://hpaste.org/50553 — isn't this a bug in the parser that it shows this error?
11:57:49 <lambdabot> chrisdone: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:58:51 <benmachine> chrisdone: which error?
11:58:52 <chrisdone> it looks like it's something like doExpr = do stmts <- many (try stmt); check (length stmts > 0) "Empty 'do' construct"; return (DoExpr stmts)
11:58:55 <c_wraith> chrisdone: as opposed to "illegal use of 'data' as an identifier" or something?
11:58:58 <chrisdone> Empty 'do' construct
11:59:01 <chrisdone> c_wraith: right
11:59:12 <benmachine> I get chrisdone.hs:3:11: parse error on input `data'
11:59:34 * chrisdone tests
12:00:04 <benmachine> ah, 7.2.1 gives that error and 7.0.4 gives the empty-do error
12:00:14 <benmachine> I assume because it sees 'data' and thinks 'ok, end the do'
12:00:14 <chrisdone> yeah, i guess it was fixed :-)
12:00:32 <benmachine> with nothing in it
12:00:35 <chrisdone> you get this kind of error if the parser is structured like the above ^
12:02:57 <Jester_Racer> weird question: In a mathematical expression, how do you call the different orders of the brackets? so 1+2+3 = ((1+2)+3) but 1^2^3 = (1^(2^3)? :D
12:03:09 <kmc> associativity
12:03:10 <chrisdone> it's called precedence
12:03:14 <kmc> left associative, right associative
12:03:29 <kmc> in GHCi do ":i +" or ":i ^" and it'll say "infixl" or "infixr"
12:03:50 <benmachine> an operator * is associative if (x * y) * z = x * (y * z)
12:04:09 <Jester_Racer> kmc: Thanks, that's it :) I should improve my english :)
12:04:40 <chrisdone> i keep getting the same lambdabot messages from ivanm
12:04:45 <chrisdone> either that or he's a persistent bugger
12:05:00 <dmwit> chrisdone: Convince a \bot admin to ?flush before it crashes again.
12:05:42 <chrisdone> Dear Beautiful Righteous Lambdabot Admins,
12:06:04 <chrisdone> What he said. Sincerely, me
12:07:07 <Phyx-> the lambdabot admins require a human sacrifice....
12:08:02 <chrisdone> i have some salami in the fridge, does that count?
12:08:36 <Botje> THE GOD OF LUTEFISK DEMANDS SACRIFICE
12:08:45 <DrSyzygy> Om nom nom lutfisk!!
12:08:50 <ciaranm> you're all sick
12:09:14 <DrSyzygy> ciaranm: No, seriously. With boiled potatos, and a white pepper hollandaise. It's the perfect christmas meal!
12:09:38 <copumpkin> fermented shark is where it's at
12:09:45 <copumpkin> none of that tame lutefisk stuff
12:09:46 <DrTeggy> Lutefisk!
12:10:04 <ciaranm> DrSyzygy: i come from a place where we think it's funny to tell foreigners that haggis is a food and see if they'll eat it, and i say you've crossed the line!
12:10:12 <arcatan> i'm intrigued by surströmming
12:10:16 <DrSyzygy> ciaranm: Oh, yeah! I'm moving there in a week or so.
12:10:32 <DrSyzygy> arcatan: I'm not. Those crazy northerners eat it. We in the south of sweden are too civilized.
12:10:35 <ciaranm> DrSyzygy: did you hear about a bird we have called the "haggis"? it's really tasty
12:10:51 <DrSyzygy> ciaranm: Sorry. I've already been to scotland.
12:11:02 <DrSyzygy> and I've had haggis. It's almost like Pölsa, feels like home.
12:11:34 <DrSyzygy> copumpkin, arcatan: http://satwcomic.com/nordics-like-fish
12:12:43 <copumpkin> lol
12:12:46 <arcatan> :D
12:13:29 <arcatan> the obligatory Finnish delicacy: http://en.wikipedia.org/wiki/M%C3%A4mmi
12:13:43 <edwardk> ciaranm: Compared to lutefisk and surströmming, haggis is pretty mild ;)
12:13:45 <DrSyzygy> Yaay! Mämmi! My wife doesn't let me eat it often enough.
12:13:58 <ciaranm> haggis is just about plausibly a food
12:14:04 <ciaranm> rotten fish isn't
12:14:25 <edwardk> heh, or the shark the icelandic guys eat that they have to let rot to get rid of the poison
12:14:49 <DrSyzygy> edwardk: See about 3 references to that shark above. ;-)
12:14:56 <edwardk> ah
12:14:59 <edwardk> just tuned in
12:15:33 <edwardk> yeah copumpkin and i both work with the same crazy icelander ;)
12:15:40 <DrSyzygy> :-D
12:15:41 <chrisdone> Mämmi looks really tasty
12:15:48 <bleakgadfly> lutefisk. Good god.
12:15:50 <edwardk> hákarl, thats it
12:15:59 <DrSyzygy> O, that reminds me. People here know Kevin Hammond, right?
12:16:01 <byorgey> DrSyzygy: you're moving to Scotland?
12:16:17 <DrSyzygy> byorgey: I'll be office mate (kinda) with Kevin Hammond. ;-)
12:16:27 <DrSyzygy> byorgey: Starting a postdoc @ St. Andrews Sept. 1.
12:16:31 <byorgey> oh, cool, congrats!
12:17:01 <DrSyzygy> On mämmi: http://satwcomic.com/exotic-food (and other weird food)
12:17:04 <byorgey> I heard him give a talk once, but I don't think that counts as "knowing"
12:17:27 <DrSyzygy> Also on mämmi: http://satwcomic.com/make-a-good-impression
12:18:03 <edwardk> clearly there needs to be an cooking show challenge where the contestants are given access to hakarl, surstromming and lutefisk
12:18:09 <DrSyzygy> HAH!
12:18:39 <DrSyzygy> “Remember to soak it 12h, changing waters every 4h... You don't want to accidentially etch the throats of your guests.”
12:20:17 <hpaste> peteriserins pasted “Pair problems” at http://hpaste.org/50555
12:20:36 <peteriserins> I'm getting a kind error when compiling this
12:20:49 <kmc> well yeah, p is supposed to be a 2-argument type constructor
12:20:53 <kmc> which your function type isn't
12:21:22 <kmc> you need newtype ChurchPair a b = MkP (forall c. (a -> b -> c) -> c)
12:21:23 <peteriserins> kmc: sort of like data Pair a b = Pair a b?
12:21:29 <kmc> which also requires PolymorphicComponents
12:21:30 <kmc> yes
12:21:32 <kmc> or like (,) itself
12:21:36 <kmc> > (2,3) :: (,) Int Int
12:21:37 <lambdabot>   (2,3)
12:23:18 <chrisdone> why is russia so big? :/
12:23:34 * chrisdone goes to bed, pondering this question
12:23:45 <peteriserins> kmc: is there a way to do this without needing wrappers?
12:23:53 <kmc> no
12:24:03 <kmc> not with that class
12:24:10 <kmc> you could remake it into a multi-parameter class
12:24:12 <peteriserins> kmc: yes but perhaps with a different class?
12:24:13 <ciaranm> chrisdone: so sarah palin can see it from her house
12:24:19 <frerich_> I currently have a 'type Set = [Int]' and 'sets :: [Set]'. I'd now like to move a number from a certain position in a certain set to another set (inserted at a certain position). I got this working, but fiddling with lists and int indices is really ugly. What data structure would you suggest to make this task simpler?
12:24:22 <kmc> class Pair p a b where { cons :: a -> b -> p }
12:24:32 <kmc> you might instead want
12:24:41 <Botje> frerich_: an array of sets?
12:24:41 <kmc> class Pair p a b | p -> a, p -> b where { cons :: a -> b -> p }
12:24:49 <kmc> that says "type p is enough to determine types a,b"
12:24:50 <peteriserins> kmc: yes indeed
12:24:54 <ciaranm> frerich_: by 'set' we usually understand something where order is irrelevant
12:24:57 <kmc> er i guess you can write "| p -> a b"
12:25:02 <Botje> frerich_: also, if they have an ordering they're not really sets
12:25:31 <frerich_> Botje: Oh yes, it didn't occur to me that my idea of "set" (I have a set of chips) collides with the data structure commonly known as Set.
12:25:38 <frerich_> Maye I should call it 'Group' instead.
12:25:41 <kmc> peteriserins, or use an associated type:   class Pair p where { type Fst p :: *; type Snd p :: *; cons :: Fst p -> Snd p -> p; car :: p -> Fst p }
12:25:48 <kmc> all of these require language extensions
12:26:02 <ciaranm> frerich_: by 'group' we usually understand a set with an associated operation that has an identity and inverses
12:26:22 <frerich_> ciaranm: Hm how do you call a set of chips in a game? :-)
12:26:49 <Botje> a stack! *ducks*
12:26:56 <ciaranm> frerich_: 'collection' is the generic term. and we have other names depending upon what properties you assume.
12:27:02 <d-day> frerich_: a set, probably a bag, a collection
12:27:23 <frerich_> Set!
12:27:33 <frerich_> Maybe I go for 'ChipSet'
12:27:42 <ciaranm> frerich_: 'newspaper'
12:27:43 <frerich_> Or just 'Chips'.
12:27:58 <d-day> well, if there are repeats of items in a set, then it's a "bag", not a set
12:28:09 <d-day> I think?
12:28:22 <ciaranm> d-day: 'bag' still implies no particular ordering
12:28:39 <ciaranm> it's probably a list
12:29:02 <copumpkin> cons (fst p) (snd p) == p would be a law
12:29:03 <copumpkin> unless you're lucy lawless
12:29:40 <frerich_> Anyway, this nomenclature aside: if I want to have a function which can move the n'th element of the m'th set of a 'sets :: [[Chip]]' into the v'th position of the w'th set - which data structure would you use? I looked at Data.Sequence and Array so far but nothing seems to allow removing elements out of the box.
12:30:15 <Botje> is the amount of sets constant?
12:30:19 <ciaranm> frerich_: a list if it's small, and a fancy skip list if it's large
12:30:28 <frerich_> Botje: No, it's not.
12:30:55 <frerich_> ciaranm: Yes, that's what I have right now, but this 'move :: [[a]] -> Int -> Int -> Int -> Int -> [[a]]' function became really ugly, even with little 'removeAt' and 'insertAt' helper functions I wrote.
12:31:15 <frerich_> I know that lists + Ints are really clumsy, but I can't seem to find a data structure which makes this more convenient.
12:31:52 <d-day> do the sets have an empty disjoint union?
12:32:46 <frerich_> Let me try to translate that..
12:33:05 <d-day> if you find a Chip in one set, can it also be found in another set?
12:33:23 <ezyang> Inlining versus rewrite rules: ewwwwww
12:33:30 <frerich_> d-day: Yes, it can
12:34:19 <dmwit> :t scanl1
12:34:20 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
12:34:39 <d-day> out of curiosity, what kind variety of chips? potato? silicon? decorative? poker?
12:34:46 <hpaste> peteriserins pasted “Pair problems #2” at http://hpaste.org/50556
12:34:51 <d-day> s/kind/kind of/
12:35:08 <peteriserins> kmc: now it complains about car/cdr
12:35:14 <peteriserins> kmc: it cannot get the expected type c
12:35:17 <kmc> hpaste?
12:35:20 <Jester_Racer> is there a library function for reading an integer from a string, until it's a valid integer. so readValid "445sdf" -> 445
12:35:30 <frerich_> d-day: Four colors  (red green blue yellow), thirteen values (1-13), each chip appears twice.
12:35:34 <peteriserins> kmc: look up
12:35:35 <frerich_> d-day: Plus two jokers.
12:35:54 <edwardk> Jester_Racer: you can use the decimal parser in parsec or trifecta for that
12:36:02 <d-day> so your 'chips' are decks of playing cards? :O
12:36:20 <Jester_Racer> edwardk: ok thanks, I'll check out parsec
12:36:21 <edwardk> you can also takeWhile isDigit and feed that to read ;)
12:36:39 <Jester_Racer> hmm, that sounds better :P
12:37:04 <frerich_> d-day: No, this: http://hpaste.org/50557 :-)
12:37:14 <Jester_Racer> edwardk: thanks, it's working :)
12:37:25 <kmc> peteriserins, did you paste the error message too?
12:37:47 <dmwit> frerich_: So, playing cards, but with colors instead of suits. Gotcha.
12:38:11 <d-day> dmwit: hehe.
12:38:45 <d-day> frerich_: the point is, these defnitions define a 'playing card' deck which is a pretty thoroughly studied thing
12:38:55 <dmwit> frerich_: In any case, finger trees offer a relatively efficient "split" operation, which would be pretty much just what you need to implement modifyAt, insertAt, and removeAt.
12:39:18 <hpaste> peteriserins annotated “Pair problems #2” with “Pair problems #2 (annotation)” at http://hpaste.org/50556#a50558
12:39:41 <dmwit> sorry
12:39:53 <dmwit> efficient "split" *and* efficient "++"
12:40:10 * hackagebot convertible-text 0.3.0.10 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.3.0.10 (MichaelSnoyman)
12:40:46 <dmwit> peteriserins: Perhaps you meant "instance Pair (forall c. ...) a b where"?
12:41:37 <frerich_> dmwit: Hmm, I'll google for that.
12:41:48 <frerich_> dmwit, d-day: FWIW, this is what I have right now: http://hpaste.org/50559 <-- it works, but I think it's ugly.
12:41:53 <dmwit> Otherwise you're declaring a (different) instance of Pair for each possible monomorphic choice of "c".
12:43:25 <nominolo> edwardk: I think it's time for a GSoC evaluation reminder
12:43:35 <Clint> is there no suffix equivalent to Data.List.stripPrefix?
12:43:44 <peteriserins> dmwit: it says the forall is illegal
12:43:57 <dmwit> peteriserins: Add the Rank2Types extension or whatever it's called.
12:43:59 <kmc> dmwit, i think it should work without that
12:44:24 <dmwit> kmc: Really? It makes perfect sense to me for it not to work.
12:44:38 <peteriserins> dmwit: still complaining
12:44:40 <kmc> hmm
12:44:59 <kmc> well, you won't be able to create a pair and then use it on two projections of different type
12:45:12 <dmwit> frerich_: Oh, if somebody suggested Data.Sequence, you should listen to them. Data.Sequence is fingertree-backed.
12:45:14 <edwardk> nominolo: yeah, the ability to submit them just went live like 20 minutes ago, i was waiting for that ;)
12:45:15 <dmwit> (Didn't know that.)
12:45:17 <kmc> ah, and 'car' and 'cdr' have different type in general
12:46:01 <edwardk> nominolo: (i didn't want to send it out before folks could act on the email)
12:46:04 <kmc> but yeah, it doesn't like foralls in class heads
12:46:11 <kmc> even with Rank2Types
12:46:18 <frerich_> dmwit: Is there some convenience package to provide 'all' or 'any' or 'group' over Data.Sequence?
12:46:41 <maltem> Clint, fmap reverse . stripPrefix (reverse suff) . reverse, and it's as inefficient as it looks
12:47:07 <Clint> maltem: hrm
12:47:27 <dmwit> peteriserins: Yep, looks like you'll have to wrap this type in a data or newtype declaration.
12:47:28 <maltem> frerich_, maybe Data.Foldable
12:47:30 <dmwit> Sorry about that.
12:47:57 <maltem> (for all, any)
12:48:48 <frerich_> matelm: Indeed!
12:48:59 <maltem> Clint, well, lists are basically stacks - they don't like to be balanced in one hand while manipulated with the other
12:49:56 <nominolo> edwardk: oh.  I was wondering abuot that.  So, it was just a happy accident that I checked so shortly after it went live.
12:50:03 <nominolo> edwardk: tl;dr:  FIRST!
12:50:18 <edwardk> yeah
12:50:53 <edwardk> nominolo: yeah, you had good timing. i had the email open in another window waiting for the site to be ready ;)
12:51:18 <Clint> maltem: clearly i'm thinking aobut this the wrong way
12:51:44 <peteriserins> dwit: I'll see if I can make the type family way work
12:51:45 <mysticc> what this is about , edwardk ??
12:54:02 <edwardk> mysticc: we're at the end of the google summer of code
12:54:51 <mysticc> edwardk: Whats the site ....
12:55:14 <edwardk> http://socghop.appspot.com/gsoc/homepage/google/gsoc2011
12:55:59 <dasi> Can anyone tell me anything about the <+> operator? My Google-fu has failed me.
12:56:05 <dmwit> peteriserins: Hopefully, you will run into the same error with type families.
12:56:12 <kmc> dasi, what library is it coming from?
12:56:14 <roconnor> dasi: it is not a globally recognized name
12:56:23 <roconnor> dasi: it will be local to some package
12:56:25 <kmc> @hoogle (<+>)
12:56:25 <dmwit> ?hoogle <+>
12:56:25 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
12:56:26 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
12:56:26 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
12:56:26 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
12:56:26 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
12:56:27 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
12:56:38 <dasi> kmc, rconnor: Ah, it is from xmonad.
12:56:46 <hpaste> peteriserins annotated “Pair problems #2” with “Pair problems #2 (annotation) (annotation)” at http://hpaste.org/50556#a50560
12:56:49 <dmwit> <+> = mappend in xmonad
12:56:49 <kmc> check the xmonad docs :)
12:56:56 <dasi> Thanks folks.
12:57:10 <dmwit> dasi: Also, you may enjoy #xmonad.
12:57:32 <peteriserins> kmc: I tried to implement your type family idea
12:58:22 <kmc> yeah
12:58:32 <kmc> i don't actually know how to bring the type variables into scope
13:02:46 <edwardk> nominolo: nag email sent to the mentors
13:03:10 <mysticc> edwardk: what was your project ..
13:03:39 <edwardk> mysticc: i was working with jaspervdj on determining whether or not it made sense to switch Data.Text to UTF8 internally
13:04:23 <edwardk> and acting as org admin, making sure everything happened on time, evaluations happened, people got paid, etc.
13:05:20 <erus`> can anyone point me to some snobby haskell reading?
13:05:31 <edwardk> erus`: probably my blog )
13:06:09 <erus`> url?
13:06:16 <roconnor> ya, edward's blog is good for zygohistomorphisms
13:06:16 <edwardk> comonad.com
13:06:31 <hpc> sigfpe.blogspot.com is full of good stuff
13:14:51 <erus`> can lambdabot unsugar do notation?
13:14:54 <kmc> yes
13:15:08 <kmc> @undo do { x <- a; y <- b x; return (f x y) }
13:15:08 <lambdabot> a >>= \ x -> b x >>= \ y -> return (f x y)
13:15:29 <ian__> is there a foldWhile or something
13:15:43 <conal> kmc: might be prettier with (>=>)
13:15:44 <benmachine> @. pl undo do { x <- a; y <- b x; return (f x y) }
13:15:45 <lambdabot> liftM2 (>>=) b ((return .) . f) =<< a
13:15:45 <erus`> @undo do { let x = 2; return 1 }
13:15:45 <lambdabot>  Parse error at "}" (column 26)
13:15:52 <benmachine> ew
13:16:03 <benmachine> erus`: you need {}s
13:16:50 <erus`> i have them?
13:16:55 <benmachine> more :P
13:17:03 <benmachine> @undo do { let {x = 2}; return 1}
13:17:04 <lambdabot> let { x = 2} in return 1
13:17:55 <erus`> why does ghci need me todo that?
13:18:35 <ian__> foldWhile1 (> 13) (*) [1..]
13:18:40 <nominolo> edwardk: thanks
13:18:42 <ian__> anything like that?
13:19:43 <chee1> ian__: maybe a combination of takeWhile and scanl?
13:19:49 <chee1> or scanr.
13:20:17 <erus`> @undo do { x <- getLine; return "nolol" }
13:20:17 <lambdabot> getLine >>= \ x -> return "nolol"
13:21:12 <erus`> I havnt looked at how do works since i first started learning haskell. That used to all look foreign to me but now it makes sense :)
13:23:34 <erus`> and it makes sense why people tell me not to use fromJust
13:23:35 <ian__> i have a list of lists, that i want to concatenate until the result is greater than or equal to a certain length
13:24:03 <erus`> mind blown...
13:24:23 <ian__> foldl1While ((< 10) . length) (++) ["blah", "basdf", "etc"]
13:24:24 <DrTeggy> ian__: What would the function's type?
13:24:34 <DrTeggy> +be
13:24:54 <ian__> i'm not good with types :(
13:25:33 <DrTeggy> Oh, I see. ++, not concat
13:25:56 <copumpkin> ian__: think different
13:26:02 <ian__> i'm trying
13:26:08 <hkarim> is there a partial function support in Haskell?
13:26:20 <koeien37> hkarim: generally we use Maybe to do that.
13:26:35 <copumpkin> > map fst $ zip (concat ["blah", "basdf", "etc"]) (replicate 10 ())
13:26:36 <lambdabot>   "blahbasdfe"
13:26:44 <copumpkin> oh wait
13:26:46 <copumpkin> duh
13:26:50 <benmachine> yeah that's not quite the spec
13:26:57 <copumpkin> oh
13:27:01 <ion> hkarim: ITYM “a lack of partial function prevention”.
13:27:10 <koeien37> hkarim: all Haskell functions can be partial (e.g. head) though.
13:27:13 <benmachine> I can think of several ways of doing it but none that are sufficiently concise
13:27:13 * _Ray_ would write out the damn 2 lines of haskell code, as opposed to concatenate premade functions. </newbie>
13:27:38 <koeien37> > head []
13:27:39 <lambdabot>   *Exception: Prelude.head: empty list
13:27:49 <copumpkin> > last . takeWhile ((<10) . length) . scanl (++) [] $ ["blah", "basdf", "etc"]
13:27:51 <lambdabot>   "blahbasdf"
13:28:01 <benmachine> scanl!
13:28:01 <copumpkin> ugly though
13:28:05 <benmachine> I knew there was something like that
13:28:14 <ian__> thanks copumpkin
13:28:15 <koeien37> that traverses the list too often
13:28:17 <hkarim> koeien37:  I mean a function that is not defined on all of its domain
13:28:20 <copumpkin> yeah, it does
13:28:32 <ian__> yeah, is a bit redundant but sufficient for what i'm doing
13:28:43 <jfdklfdas> > take 10 (concat ["bla", "basf"]
13:28:44 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:28:49 <koeien37> hkarim: yes, those can exist in Haskell
13:28:50 <jfdklfdas> oops
13:29:06 <koeien37> @src head
13:29:06 <lambdabot> head (x:_) = x
13:29:06 <lambdabot> head []    = undefined
13:29:19 <koeien37> > 3 / 0 :: Integer
13:29:19 <copumpkin> I think he's asking about something like scala's partial function
13:29:20 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
13:29:20 <lambdabot>    arising f...
13:29:27 <copumpkin> which we typically just do with a function to Maybe
13:29:29 <koeien37> > div 3 0 :: Integer
13:29:31 <lambdabot>   *Exception: divide by zero
13:29:50 <koeien37> @src Maybe
13:29:50 <lambdabot> data Maybe a = Nothing | Just a
13:30:05 <hkarim> lambdabot: can I pattern match undefined?
13:30:08 <benmachine> no
13:30:11 <koeien37> so safeHead could be defined as safeHead [] = Nothing; safeHead (x:_) = Just x
13:30:22 <benmachine> koeien37: cf. listToMaybe
13:30:31 <benmachine> (silly name, btyg)
13:30:58 <hkarim> in Scala I can do f.isDefinedAt(x)
13:31:12 <hkarim> then, f(x)  is safe
13:31:42 <copumpkin> hkarim: I don't really see the benefit of that over a function to Option
13:32:10 <copumpkin> it seems like a fancy name for Function1[A,Option[B]]
13:32:42 <erus`> one cannot escape the IO monad because their is no IO constructor ?
13:32:44 <AndroUser> how would guys do printf "%02d%02d%02d%02d" ..., but faster?
13:33:03 <maltem> isn't printf pretty fast?
13:33:25 <koeien37> erus`: there is no (useful) IO a -> a function
13:33:27 <benmachine> erus`: that's not really the reason; IO's constructors are hidden, but even if you could see them you'd still be stuck unless you could create RealWorlds
13:33:28 <AndroUser> its my bottleneck
13:33:39 <copumpkin> realWorld#
13:33:43 <AndroUser> print is a touch faste
13:33:49 <AndroUser> r
13:34:16 <dmwit> zoomzim: Remind me: what does the 02 do in %02d?
13:34:25 <zoomzim> maybe unbuffered io would be faster
13:34:38 <benmachine> dmwit: zero-padded, width 2, I think?
13:34:42 <zoomzim> width 2 pad with 0
13:34:50 <zoomzim> im printing time
13:35:07 <benmachine> there's a formatTime function, btw
13:35:23 <benmachine> if you're using string IO then there's a fair chance that is your problem :P
13:35:34 <benmachine> (although I don't know how to format time into bytestrings)
13:35:43 <zoomzim> im printing ints buddy
13:35:56 <dmwit> Don't be rude.
13:36:16 <koeien37> zoomzim: benmachine means that String is slow. ByteString is way faster
13:36:19 <dmwit> It's possible that somebody unfamiliar with the time API would convert a time to ints and then print, unknowingly making a too-long conversion trip.
13:36:20 <zoomzim> buddy is friendly, pal
13:36:51 <dmwit> Are you willing to assume that your values are in some range (say, 0-99)?
13:37:11 <benmachine> koeien37: right
13:37:13 <benmachine> although
13:37:20 <benmachine> bytestring is only way faster if you do it right
13:37:25 <kmc> String and ByteString are not alternatives
13:37:26 <zoomzim> yeah
13:37:29 <benmachine> just making a [Word8] and then packing it doesn't count :P
13:37:38 <koeien37> benmachine: :)
13:37:45 <kmc> repeat after me: String and ByteString are not alternatives
13:37:52 <benmachine> kmc: they are alternative parameters to IO primitives
13:38:00 <kmc> String stores text; ByteString stores bytes
13:38:12 <koeien37> kmc: are you referring to text vs word8?
13:38:13 <brisbin> so where's Text fit in?
13:38:17 <kmc> Char vs Word8
13:38:20 <edwardk> Text stores text as well ;)
13:38:24 <dmwit> \x -> let (q, r) = quotRem x 10 in map intToDigit [q, r] -- probably faster than printf "%02d"
13:38:26 * brisbin figures
13:38:28 <kmc> brisbin, Text is packed like ByteString, but stores text
13:38:30 <dmwit> But benchmark it to be sure. =)
13:38:42 <kmc> unfortunately it lacks O(1) indexing because it uses UTF-16
13:38:43 <zoomzim> so i would do (putStr (formatTime ...))?
13:38:58 <monochrom> String lacks O(1) indexing too :)
13:39:00 <edwardk> Text is utf16 encoded in a flat array, Bytestring is just unencoded bytes in a flat array, String is a linked list of Chars.
13:39:01 <koeien37> O(1) indexing in unicode text is difficult anyway :)
13:39:07 <kmc> benmachine, the thing about RealWorld is either a dirty implementation detail from GHC or a bad analogy
13:39:10 <dmwit> zoomzim: Yes, if you have something that formatTime understands, that is the preferred way.
13:39:10 <kmc> i don't know which one you meant
13:39:11 <edwardk> monochrom: sadly, so does Text.
13:39:19 <benmachine> kmc: the former
13:39:23 <kmc> oh
13:39:29 <edwardk> i use utf8 encoded strings and just track the tail byte locations
13:39:33 <dmwit> > quotRem 32 10
13:39:34 <lambdabot>   (3,2)
13:39:41 <edwardk> er encoded bytestrings
13:39:44 <zoomzim> cool!
13:39:56 <dmwit> > quotRem 02 10
13:39:57 <lambdabot>   (0,2)
13:40:02 <benmachine> admittedly it was an answer specific to GHC when the question wasn't
13:40:27 <copumpkin> kmc: even with UCS-4 you couldn't do O(1) indexing unless you pre-normalized everything
13:40:38 <edwardk> copumpkin: ?
13:40:47 <kmc> yeah
13:40:53 <koeien37> edwardk: there are some characters that alter the previous character afaik
13:40:53 <edwardk> copumpkin: referring to multi-character glyphs?
13:40:54 <kmc> though O(1) indexing by code point may still be useful
13:40:58 <dmwit> Depends on just what kind of indexing you mean, I guess.
13:41:01 <kmc> or by whatever it's called
13:41:05 <edwardk> koeien37: those are still considered separate codepoints
13:41:09 <kmc> scalar value?
13:41:09 <copumpkin> edwardk: combining characters
13:41:11 <kmc> sigh
13:41:15 <copumpkin> users typically don't want to index by code point
13:41:19 <copumpkin> they want logical characters
13:41:45 <edwardk> that i'm not so sure of.
13:41:53 <dmwit> type LogicalCharacter = String
13:42:04 <edwardk> i'm happy to offer routines to stp forward by a glyph, etc.
13:42:07 <edwardk> er step
13:42:10 <copumpkin> you'd want to break the text between the ´ and the ?
13:42:12 <zoomzim> formatTime cant handle hundredths of a second :/
13:42:13 <copumpkin> and the e
13:42:14 <monochrom> I read the unicode document a bit. yes there are multiple-codepoint characters
13:42:15 <edwardk> but i'd like to be able to slice anywhere
13:42:16 <edwardk> yes
13:42:23 <dmwit> edwardk: glyphs aren't logical characters, either... =/
13:42:33 <edwardk> dmwit: correct
13:42:44 <edwardk> hence why i don't like just trying to lean on \x or \X or whatever it is
13:43:23 <dmwit> glyphs can even be font-specific, so "step forward by a glyph" seems like a really strange primitive to offer
13:43:26 <erus`> what is the point of (>>) ?
13:43:45 <copumpkin> erus`: it's the primitive for most imperative languages
13:43:47 <monochrom> forkIO blah >> return () is the point of >>
13:43:47 <copumpkin> "do x, then do y"
13:43:51 <edwardk> dmwit: yes
13:44:01 <kmc> erus`, to produce an action that consists of executing two other actions in sequence
13:44:02 <erus`> so its like seq?
13:44:05 <kmc> that's the point for IO, anyway
13:44:05 <copumpkin>  no
13:44:07 <kmc> no it's not erus`
13:44:09 <koeien37> erus`: not at all like seq
13:44:09 <kmc> seq is about evaluation
13:44:11 <kmc> (>>) is about execution
13:44:17 <kmc> did you read "Introduction to IO"?
13:44:33 <copumpkin> intrIOduction
13:44:36 <ocharles> hrm, is there a type class for stuff that's a bit like a monad, in that it specifies (>>=), but doesn't have 'return' ?
13:44:39 <copumpkin> IOntroduction?
13:44:51 <monochrom> introductIOn
13:44:52 <copumpkin> ocharles: edwardk has one
13:44:56 <dmwit> ocharles: Don't know of one.
13:44:56 <erus`> > Just 3 >> Just 5
13:44:56 <ocharles> I only want to be able to get into this monad-like-thing through a set of primitives that I define
13:44:56 <lambdabot>   Just 5
13:45:04 <benmachine> I like how copumpkin put the IO everywhere except for where it actually was
13:45:06 <dmwit> ocharles: You might like Applicative, which offers ap (but not (>>=)).
13:45:08 <kmc> > "ab" >> "cdef"
13:45:08 <copumpkin> monochrom: :(
13:45:09 <lambdabot>   "cdefcdef"
13:45:11 <zoomzim> the never ending monad!
13:45:19 <edwardk> ocharles: Data.Functor.Bind in semigroupoids
13:45:28 <ocharles> edwardk: thanks, I'll look into that
13:45:29 <zoomzim> co monad?
13:45:38 <benmachine> do-notation doesn't use return at all, does it?
13:45:48 <monochrom> right
13:45:49 <copumpkin> no
13:45:49 <dmwit> Hah, but of course there's such a class. edwardk++
13:45:50 * ion troduction
13:45:52 <kmc> benmachine, maybe in desugaring pattern-match failure
13:45:59 <kmc> @undo do { Just x <- a; return x }
13:45:59 <edwardk> zoomzim: it merely states that kleisli composition is a semigroupoid rather than a category
13:46:00 <lambdabot> a >>= \ b -> case b of { Just x -> return x; _ -> fail ""}
13:46:06 <benmachine> kmc: hmm. can we just gloss over that? :P
13:46:07 <edwardk> zoomzim: for that type
13:46:08 <kmc> oh, hmm
13:46:15 <kmc> yeah i guess it doesn't
13:46:17 <edwardk> zoomzim: the do sugar doesn't care about return
13:46:18 <kmc> @undo do { Just x <- a; f x }
13:46:18 <lambdabot> a >>= \ b -> case b of { Just x -> f x; _ -> fail ""}
13:46:22 <benmachine> ok cool
13:46:29 <copumpkin> monad comprehensions use return
13:46:48 <zoomzim> if you take away merely ill agree with that
13:46:56 <zoomzim> @palomer
13:46:57 <edwardk> then it is good that they are monad comprehensions and not semimonad comprehensions ;)
13:46:57 <lambdabot> Pfft
13:47:06 <DrTeggy> Monad comprehensions!
13:47:11 <erus`> so >> executes and seq evaluates?
13:47:16 <mauke> monad incomprehensions
13:48:06 <koeien37> a >> b is the action that means "first run a, then run b"
13:48:38 <monochrom> x >> y  =  x >>= \_ -> y
13:48:49 <monochrom> if you know what is >>=, you know what is >>
13:48:59 <maltem> >> and seq don't really stand comparison
13:49:14 <erus`> seq does x then y?
13:49:36 <maltem> seq is a built-in that makes the expression strict in the first argument
13:49:51 <mauke> erus`: no
13:50:00 <zoomzim> so a >> lola run means a, then run lola run?
13:50:24 <edwardk> erus`: no. pseq has that guarantee, seq merely says that a `seq` b fails to terminate of a fails to terminate
13:50:39 <erus`> ah ok
13:50:40 <maltem> roughly, seq a b is _|_ if a = _|_, and b otherwise
13:50:46 <edwardk> erus`: they could both execute at the same time, or it could just use some magic oracle to determine if the left hand argument will terminate, etc.
13:50:51 <erus`> my idea of seq is was wrong
13:50:52 <monochrom> in fact, even x>>y doesn't have to do x then y. it depends. see my http://hpaste.org/41790/controlmonadstatelazy
13:50:52 <zoomzim> head normal form, yes?
13:51:02 <edwardk> erus`: almost invariably when you want to use seq you really want pseq
13:51:08 <mauke> my intuition of seq is that it will evaluate both args before returning a result
13:51:41 <zoomzim> monochrom you sly dog
13:52:14 <edwardk> of course one might argue that lazy state isn't a monad ;)
13:52:36 <mauke> how about the reverse ST monad?
13:52:47 <edwardk> reversing state is fine
13:52:48 <benmachine> that sounds fun :D
13:53:15 <dolio> How about (->) r.
13:53:25 <mauke> (->) r is simple
13:53:26 <dolio> That doesn't need to "do" x.
13:53:31 <edwardk> yeah
13:54:08 <Watermind> I was looking at the "Typing Pitfalls", and it mentioned "Let-Bound Polymorphism" in the Hindley-Milner type system... what is the reason for this restriction? Any pointers?
13:54:35 <Watermind> first impression is that multiple instantiations shouldn't be problematic
13:54:38 <dolio> I don't know for whom it's true that you always want pseq instead of seq, either.
13:54:39 <monochrom> my http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/ makes fun of "seq x y evaluates x first"
13:54:40 <Watermind> but I'm sure that is wrong :S
13:54:52 <hpc> http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/ -- relevant to reverse ST
13:54:53 <zoomzim> this little thing called decidability
13:55:07 <dolio> You'd have to almost always be doing parallelism stuff, and never just writing ordinary Haskell that wants to hint to the strictness analyzer.
13:55:28 <Watermind> zoomzim: is that an answer for me?
13:55:36 <mauke> http://mauke.dyndns.org/stuff/haskell/posi.hs - Positronic.hs is essentially reverse ST
13:55:38 <zoomzim> yes
13:55:44 <Watermind> zoomzim: I thought so :)
13:55:48 <benmachine> monochrom: that sounds like fun
13:56:12 <rwbarton> this has confused me for a while, why doesn't foldl' use pseq?
13:56:15 <edwardk> anyways regarding unicode glyphs vs. code points i tend to like to grab at arbitrary codepoint (not glyph) boundaries, then perform both NFC and NFKC normalizations on the input, validating that dereferencing by each yields the same result
13:56:16 <ion> > snd . last . takeWhile ((< 10) . getSum . fst) . scanl mappend mempty . map (Sum . length &&& id) $ ["blah", "basdf", "etc"]  -- :-P
13:56:18 <lambdabot>   "blahbasdf"
13:56:32 <monochrom> why would state.lazy not be a monad? which law does it break, by what counterexample?
13:56:32 <Watermind> zoomzim: do you know of any place that shows or explains why it becomes undecidable... or is it simple to give me an idea why?
13:56:44 <edwardk> this invalidates a lot of agda-style code, but means you can be sure that an a with an accent compares the same as every other, or that it fails
13:56:52 <Watermind> apparently not :S
13:56:53 <Watermind> argh
13:57:20 <dolio> rwbarton: For one, because pseq doesn't exist in the documents that define foldl'.
13:57:32 <rwbarton> Well, sure
13:57:33 <edwardk> monochrom: the problem is that when you fmap id (s -> _|_) you get s -> (_|_,_|_),
13:58:27 <dylukes> I have a serious problem with my language design.
13:58:33 <dylukes> I want the bottom type to be a trollface.
13:58:33 <edwardk> monochrom: the other 'lazy' versions in the mtl have the same problem
13:58:33 <dolio> And the reason it doesn't exist in those documents is that they try not to be overly specific about the evaluation order of their stuff.
13:58:37 <dylukes> But the troll face is not in Unicode.
13:58:38 <dylukes> :<
13:58:57 <rwbarton> right, I really mean the foldl' that's in the GHC libraries
13:58:58 <ocharles> wow, that was weird. I just had a "hrmm. i guess the operator I'm really trying to define is (.)... did I just invent a category"?
13:59:05 <ocharles> Only a true haskell nerd would get that feeling :P
13:59:06 <dylukes> I might make it (╬ ಠ益ಠ)
13:59:15 <ocharles> time to see if it obeys other category laws
13:59:25 <edwardk> mind you, you can still right some cute code with them that you can't write the other way, the question is that extra flexibility worth compromising to get ;)
13:59:46 <edwardk> s/is/is is/
13:59:56 <monochrom> I see. thanks.
14:00:03 <dolio> seq is sufficient for even a stupid compiler to get the right behavior out of foldl'. And it only requires talking about denotation of Haskell functions, not operation.
14:00:08 <benmachine> monochrom: don't you think your foldl' example is a bug in ghc?
14:00:17 <edwardk> i'm probably going to rip the lazy versions out of comonad-transformers for that reason
14:00:26 <edwardk> cuts the number of modules in a third
14:00:26 <rwbarton> I certainly don't think it is a bug in ghc
14:01:02 <ash> anyone have some experience with Parsec? I had a few questions if so…
14:01:14 <Watermind> so, if expressions in let clauses were provided with a type signature, would Let Bound Polymorphism not be necessary?
14:01:15 <edwardk> rwbarton: foldl' is really only talking about a strictness guarantee anyways, so it isn't that bad that it only uses seq
14:01:23 <edwardk> ash: ask away
14:01:25 <dolio> seq lets the compiler do smart things, too.
14:01:44 <edwardk> seq gives more flexibility to ghc
14:01:44 <rwbarton> right but "nobody" uses foldl' for the strictness guarantee
14:02:05 <monochrom> in the first hour after discovering it, I considered it a bug. afterwards, I consider it a great feature, one that you can shove into people's face whenever they believe "seq orders evaluation" :)
14:02:10 <rwbarton> even when people teach beginners about foldl' they are talking about the operational behavior
14:02:14 <edwardk> rwbarton: BS. I use it for that all the time. i want it to use its extra strictness knowledge to avoid building a huge thunk
14:02:18 <dolio> They use it for the optimization that the strictness guarantee allows.
14:02:30 <benmachine> monochrom: the bug for me is that -O slows a program down
14:02:31 <edwardk> that guarantee doesn't care about evaluation order
14:02:33 <ash> edwardk: whats the difference between Parsec.Prim.(<|>) and Parsec.Combinator.choice?
14:02:40 <rwbarton> well it allows it, it doesn't demand it though
14:02:49 <edwardk> ash: binary vs. a list of alternatives
14:02:57 <edwardk> choice = foldr (<|>) empty
14:03:02 <ash> ah, okay
14:03:19 <rwbarton> you say yourself you want to avoid building a huge thunk, but of course the compiler is free to do that also in the version with seq
14:03:21 <dolio> People use ST for the optimization it allows.
14:03:29 <dolio> It could be implemented with an association list.
14:03:29 <ash> also, is there a way of doing longest token matching? e.g., if there are multiple tokens that contain the same substring, to select the longest one
14:03:35 <monochrom> building vs not building large thunk is operational
14:04:13 <dolio> But it isn't implemented that way.
14:04:20 <ion> > let mconcatWhile p = go mempty where { go acc [] = acc; go acc (x:xs) | p acc' = go acc' xs | otherwise = acc where { acc' = acc `mappend` x } } in mconcatWhile ((< 10) . getSum . fst) . map (Sum . length &&& id) $ ["blah", "basdf", "etc"]
14:04:22 <rwbarton> if I write sum [1..1000000] I know the answer is not _|_, so if I implement sum in terms of foldl' it is not because I care about the semantic difference between foldl' and foldl.
14:04:22 <lambdabot>   (Sum {getSum = 9},"blahbasdf")
14:05:27 <rwbarton> (er, not that the answer is not _|_, but that no partial result is _|_, of course)
14:05:45 <monochrom> the only tenable way to say "use strictness" and "avoid large thunks" together is "use strictness to just encourage but not mandate avoiding large thunk, but it's just a hint, optional, not compulsory, if ghc decides to build large thunks anyway I'm fine", which is strange but whatever floats your boat
14:06:06 <ion> > let mconcatWhile p = last . takeWhile p . scanl mappend mempty in mconcatWhile ((< 10) . getSum . fst) . map (Sum . length &&& id) $ cycle ["foo"]  -- This probably should handle infinite lists.
14:06:08 <lambdabot>   (Sum {getSum = 9},"foofoofoo")
14:07:25 <edwardk> http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg11022.html the haskell report is very careful to not talk about evaluation order
14:07:58 <rwbarton> The report doesn't even require "lazy" evaluation
14:08:04 <edwardk> correct
14:08:06 <rwbarton> unless that has changed in haskell 2010?
14:08:19 <edwardk> well, it requires certain behavior with regards to bottoms
14:08:28 <edwardk> that kind of push you towards such an implementation
14:08:30 <rwbarton> I mean, handling sharing in the expected way
14:08:40 <rwbarton> rather than pure call-by-name
14:08:45 <dolio> It requires non-strict evaluation.
14:08:45 <ion> Human society also requires certain behavior wrt. bottoms.
14:08:49 <dolio> But that's it.
14:09:48 <erus`> lol ion
14:09:56 <erus`> i think that was a joke anyway...
14:10:56 <rwbarton> My position is that monochrom's example is certainly not a bug in ghc, but that the ghc standard library fails to some extent by not defining foldl' in terms of pseq
14:11:13 <benmachine> rwbarton: why don't you think the interaction with optimisations is a bug?
14:11:18 <ion> In fact, both human society and Haskell prefer similar behavior wrt. bottoms. Don’t expose them and usually don’t touch them.
14:13:06 <DukeDave> ghci is upset because "Ambiguous interface for...", can I specify one which package I want to use?
14:13:20 <rwbarton> it's not a bug with respect to the Haskell Report because there is nothing in the Report that specifies the evaluation order in seq x y, like the email edwardk linked to says
14:13:20 * DukeDave is aware he probably shouldn't be in the situation 
14:13:29 <edwardk> and that fmap id should leave bottoms as it found them ;)
14:13:48 <benmachine> rwbarton: the bug as I see it is that optimisations slow down a program, that shouldn't happen
14:13:53 <edwardk> rwbarton: well, the report can't specify anything more strict, and pseq is arguably more strict than you want foldl' to be.
14:13:54 <benmachine> by optimisations I mean -O
14:14:06 <benmachine> so it's a performance bug; those are still bugs
14:14:30 <rwbarton> that is certainly unfortunate, I don't know whether it's reasonable to expect your optimiser to both be generally useful and never make a program slower, though.
14:14:40 <ash> does parsec do much analysis on strings to know when to look for stuff? Like, if you had string "foo" <|> string "fooo" does it know that those two expressions have a common subexpression?
14:14:49 <edwardk> if you want to be really anal retentive about it you'd want something that said, evaluate this thing on the left, some time when you get around to it before returning the result of this thing on the right, but it shouldn't have to say one comes before the other
14:14:52 <mauke> ash: probably not
14:14:58 <edwardk> ash: nope.
14:15:07 <ion> Does Trifecta, btw?
14:15:07 <edwardk> ash: for that you need a swierstra and duponcheel style parser
14:15:20 <clsmith> hey. could someone tell me what i'm doing wrong with this parsec code? http://sprunge.us/DALU -- i suspect it's something very stupid, but basically it never terminates on some of the parser defs
14:15:28 <edwardk> ion: its getting there. not yet, but applicative fragments will probably support that analysis soon
14:15:33 <benmachine> rwbarton: it's a bug even if you don't intend to fix it :P
14:15:45 <edwardk> ion: monadic fragments won't
14:15:58 <monochrom> my theory is that the forefathers engaged in double-thought. bird and wadler (of all people) wrote in their textbook the oxymoronic "strict evaluation" "use strict evaluation to keep the thunk small". so when it comes to writing the Haskell Reports, I'm pretty sure they were thinking "yeah yeah we just say 'strict' to be politically correct but everyone knows it is about order in secret", this is why they call it "seq", it's
14:15:58 <monochrom> about order in secret
14:16:57 <dolio> It's not about order anymore, though. GHC will reorder seq sometimes.
14:17:10 <ion> edwardk: Yeah, that’s to be expected. Cool.
14:17:30 <hpc> most strictness that i see is in the form of bang patterns
14:17:32 <monochrom> oh yes absolutely
14:18:20 <monochrom> but the choice of the name "seq" was like way back when ghc was still version 3 or 4
14:18:29 <edwardk> though bang patterns like seq can be reordered
14:18:56 <dolio> Bang patterns are just seq, or sugar for the same underlying construct.
14:19:01 <edwardk> yeah
14:19:10 <ash> clsmith: term leads to abstraction which leads to term
14:20:27 <edwardk> term leads to application which leads to term
14:20:35 <clsmith> ash: doesn't the term in abstraction affect the string *after* '[x]'?
14:20:37 <edwardk> ash: the abstraction consumes a char in the meantime
14:21:24 <clsmith> ah, i see. so application is the problem
14:21:30 <edwardk> clsmith: the problem comes when the char isn't '['
14:21:31 <edwardk> yeah
14:21:55 <edwardk> generally better to munch all your applications in a run of a simpler room
14:21:59 <edwardk> er rule
14:22:34 <monochrom> you should do something like application = chainl1 term (return Application)
14:22:57 <monochrom> which is what edwardk says
14:23:52 <monochrom> if you are into "meaningful" names, consider the "meaning" of the parser name "application" to be "potentially an application"
14:24:27 <monochrom> (just like in the C grammar "additive expression" "means" "potentially additive expression")
14:25:53 <clsmith> hmm, chainl1 term (return Application) doesn't seem to work. i suppose i need .. "term other than application" as a parser?
14:28:08 <monochrom> rewrite "term". for example delete "application" from it
14:28:34 <clsmith> yeah, right now i've split term into ~ simpleTerm <|> application
14:28:35 <monochrom> rewrite "rule". for example it should be based on "application"
14:29:16 <monochrom> since now "application" "means" a term or an application chain of terms
14:29:58 <mwc> Is there a way to refer to the build directory (./Setup configure --builddir=DIST) from within a cabal spec file? I don't see it documented as one of the macros
14:30:02 <monochrom> did you first learn parsing via things like yacc bison happy? because that makes a difference
14:30:32 <clsmith> monochrom: sort of. i wouldn't describe myself as having learnt parsing :p
14:30:32 <edwardk> mwc: you can refer to it in a custom Setup.lhs
14:30:36 <monochrom> writing a grammar for yacc is very different from writing a grammar for recursive descent parsers like parsec
14:30:42 <dcoutts> mwc: no, but I don't think it makes sense to refer to it anyway
14:30:50 <mwc> I have a secondary build system that builds a legacy C lib with all sorts of fun SIMD macros and really needs to be kept as is.
14:31:18 <mwc> dcoutts: basically: extra-libary-dirs: dist/cmake_build
14:31:29 <dcoutts> mwc: as edwardk says, that's the role of the Setup.hs (what vs how)
14:31:36 <mwc> edwardk: yeah, have the custom Setup all wired up to call Setup
14:31:52 <mwc> dcoutts: hmm, so you're suggesting I just replace all paths starting with dist/ with the builddir?
14:31:59 <mwc> that could work I suppose
14:32:08 <edwardk> mwc: darcs uses a hook in their build script that lets them add a source file with the version #, and what patches were applied, etc. directly in during the build
14:32:15 <dcoutts> mwc: certainly you cannot hard code dist anywhere, since the user can modify it
14:32:38 <mwc> dcoutts: right, that's why I need to refer to it by reference as it were
14:32:54 <dcoutts> mwc: in any case extra-libary-dirs: dist/cmake_build would not work, since it has to be an absolute path, since it's still used in the installed package registration file
14:33:21 <mwc> Yeah, thankfully this is currently an executable and the lib in question is built static
14:33:50 <dcoutts> mwc: ah, simplifies things slightly
14:34:45 <dcoutts> so you want to use the pre-build hook
14:34:55 <mwc> yeah, currently I just rig an abort on buildDir lbi /= "dist", seems a little too restrictive for no good reaosn
14:35:13 <mwc> dcoutts: right, and then modify the hooked build info produced there
14:35:19 <dcoutts> yep
14:36:07 <mwc> my thinking is just to map every relative path starting with dist/ to the new build dir
14:36:20 <mwc> Does that seem reasonable?
14:38:16 <mwc> dcoutts: btw, did you see my patches posted to cabal-devel to enable CWD and ENV settings on Distribution.Simple.Program.Run functions?
14:38:39 <dcoutts> mwc: thanks, it's in my backlog
14:38:45 <mwc> dcoutts: appreciate it
14:38:51 <dcoutts> I need them too
14:39:10 <mwc> dcoutts: interfacing to a secondary build system or...?
14:39:11 <dcoutts> I'm only half way through converting everything to use that mechanism
14:39:29 <dcoutts> mwc: just the rest of the stuff in the Cabal lib, and cabal-install
14:39:33 <mwc> Ah
14:39:56 <dcoutts> I was pondering whether it was ok to start relying on base-4 stuff
14:40:00 <dcoutts> like the new process api
14:40:06 <dcoutts> and the new exceptions
14:40:08 <mwc> fwiw, I wasn't sure what the environment field in the prog invoke record means, the problem was the [(String, String)] type
14:40:22 <dcoutts> hmm?
14:40:34 <mwc> does that mean it's the entire environment? I took the point of view that it overrides the evironment, that they're supplemental
14:40:37 <edwardk> dcoutts: i wouldn't complain
14:40:46 <mwc> but then there's no easy way to unset variables
14:40:59 <dcoutts> mwc: yes, it's an override, and as you say it should be String, Maybe String
14:41:06 <mwc> the Distribution.Simple.Program.Script bits is override
14:41:07 <mwc> yeah
14:41:18 <edwardk> i think you've offered historical support for an admirably long time
14:41:35 <dcoutts> edwardk: it means it'll probably stop working with hugs and nhc
14:41:52 <edwardk> dcoutts: they can actually compile it now?
14:41:55 <dcoutts> I mean stop building with them
14:41:59 <dcoutts> edwardk: yes
14:42:01 <edwardk> wow
14:42:47 <edwardk> meh, you'd still get my vote ;)
14:43:05 <mwc> dcoutts: any objection to my opening a feature enhancement bug request for the patch so I can be notified as to when it gets merged?
14:43:28 <dcoutts> mwc: fine
14:47:34 <archit> hiii
14:49:54 <ocharles> Could I pick the collective brains of #haskell? :) I'm trying to design my own form validation library, and http://gist.github.com/1163808 is what I have so far
14:50:20 <ocharles> I kinda like bits of it, but it's not quite there yet..
14:50:34 <ocharles> I'm mostly stuck on how to string the users original input in my "Field" values
14:51:02 <archit> what is the advantage of haskell over any other language??
14:51:16 <archit> can nebody tell me
14:51:20 <ciaranm> it is named after a cooler dude than any other language except ada
14:51:20 <mauke> it's got this IRC channel
14:51:21 <zachk> concise code
14:51:27 <mauke> zachk: APL
14:51:48 <zachk> concise code that is alphanumeric and readability
14:51:57 <mauke> lisp
14:52:10 <ciaranm> he said readable
14:52:12 <zachk> i grew tired of the parentheses
14:52:13 <monochrom> ada was not a cool dude anyway. cool girl.
14:52:18 <rostayob> archit: you'll sound cool
14:52:25 <ciaranm> monochrom: which is what makes her cooler than any dude
14:52:30 <rostayob> you can use terms you've never heard of
14:52:49 <monochrom> APL is readable
14:52:59 <rostayob> you can be the guy who always brings haskell up when talking of languages
14:53:22 <monochrom> also I grew tired of alphanumeric names
14:53:22 <zachk> or you can bring up things from category theory in calc class and have the proffesor ask you if you are making terms up again :)
14:53:22 <mauke> haskell, the #1 language for zygohistomorphic prepromorphisms
14:53:38 <ciaranm> if you code in c++, those pesky java programmers think they're nearly on the same level as you and deserve the same salary, just because they think they know what a class is. but they don't pretend to understand haskell.
14:53:39 * zachk concurs 
14:53:50 <rostayob> I'll catamorph you if you don't shut up
14:54:03 <rostayob> stuff like that.
14:54:10 <mauke> horph dorph
14:54:40 <rostayob> actually i'll anamorph you sounds more painful.
14:55:19 <shachaf> ciaranm: Haskell has classes too, though!
14:55:27 <mauke> automorphism: 'tis shaped like itself
14:55:52 <rostayob> "i never do it without a monad"
14:55:54 <ciaranm> shachaf: yes, but they're not even remotely javalike so it's ok
14:56:07 <rostayob> ciaranm: well type classes are kind of like interfaces
14:56:15 <rostayob> but yeah not like classes
14:56:23 <ciaranm> in the same way that spam is kind of like bacon
14:56:40 <rostayob> ciaranm: no I mean they actually are similar...
14:56:49 <ciaranm> that is to say, spam is a cheap and nasty version of ham, and ham and bacon can both go in a sandwich
14:56:57 <RenJuan> spam is a lot like bacon
14:57:02 <monochrom> kevin spam is kind of like kavin bacon
14:57:08 <rostayob> shit spam is bacon i never knew! aaahhhhh
14:57:11 <monochrom> err, kevin bacon!
14:58:24 <monochrom> a type class is like a club of types with a reasonable barrier to entrance
14:58:47 * RenJuan bets there has been a lang named after (roger) bacon.
14:59:10 <rostayob> RenJuan: or francis maybe.
14:59:50 <shachaf> monochrom: Not very reasonable.
14:59:52 <ciaranm> not richard?
14:59:55 <RenJuan> yeah that's the one I meant, not the painter
14:59:57 <shachaf> It's not as if you have to prove all the laws.
15:02:00 <monochrom> oh haha ok!
15:02:31 <RenJuan> apparently it's called BaCon http://bkhome.org/bacon/
15:02:36 <rostayob> actually type classes are probably the most familiar concept in haskell for OO programmers
15:02:49 <rostayob> RenJuan: yeah that's francis.
15:07:16 <Cale> rostayob: only not familiar at all
15:07:30 <Cale> because they're extremely different from OO classes
15:07:48 <rostayob> Cale: they're really similar to interfaces/abstract classes
15:07:57 <Cale> (though kind of related to Java interfaces, sort of)
15:08:08 <monochrom> I only agree that "class" is the most familiar name.
15:08:15 <rostayob> Cale: that's what I was referring to, the name is confusing
15:08:42 <monochrom> and to help you, "method" is also a familiar name
15:09:21 <monochrom> we also thank the category theorists for adopting the familiar name "object"
15:09:53 <mauke> C also has "objects"
15:09:58 <mauke> and "bytes"
15:10:02 <monochrom> Num is a class, negate is a method of that class, Int is an object of that class. it all works out
15:10:04 <hpc> C++ has "functors"
15:10:06 <mauke> both probably don't mean what you think
15:10:12 <rostayob> monochrom: eheh
15:10:31 <rostayob> no but jokes aside, in explaining type classes to a java programmer, interfaces help
15:10:39 <monochrom> Int is an object of Num, and so Int has the negate method, too
15:11:31 <monochrom> if you hide the "class Blah t where maxBound :: t" example, interfaces help
15:13:02 <zzo38> If I export a type from a Haskell module, will it export the constructors or not?
15:13:10 <rostayob> monochrom: why? "interface Blah<T> { T maxBound() }"
15:14:52 <monochrom> someone had a breaking example. or else the mapping works if you have generics
15:15:29 <rostayob> monochrom: type families? rank-n types?
15:15:33 <monochrom> so try to go back to java 1.4 and you can't translate the maxBound example
15:15:43 <rostayob> monochrom: why would I go back to java 1.4 lol
15:16:21 <rostayob> of course they are not the same thing but they're quite similar
15:16:49 <monochrom> well, I don't know, you try to link up type class with interface, but in the end you link up type class with <T>
15:17:16 <rostayob> monochrom: ?
15:17:49 <rostayob> well you can't express functional dependencies too
15:17:52 <monochrom> actually, I think "interface Blah<T> { T maxBound() }" is a wrong translation
15:18:25 <shachaf> That's maxBound :: T -> T
15:18:37 <rostayob> monochrom: that are not the same thing but they're pretty similar concepts
15:18:50 <rostayob> shachaf: why?
15:19:22 <rostayob> T maxBound(T) would be maxBound :: T -> T
15:19:47 <shachaf> rostayob: Well, you have to call it as a method on a T, don't you?
15:20:32 <rostayob> right. you should define it as static
15:21:09 <shachaf> And then how do you use it?
15:21:34 <rostayob> shachaf: no but you can't define a static method in an interface
15:22:01 <int80_h> does anyone have any urls I can look at to learn about AI methods for implementing card games?
15:22:11 * shachaf isn't sure what rostayob is getting at.
15:22:43 <adxp_> I'm having some trouble understanding this syntax: "XState { windowset = old } <- get". I get the State monad "get" on the right, but don't really follow the LHS. Any suggestions for what to google to clear it up?
15:22:44 <rostayob> that's not my point. I'm not arguing that type classes are equivalent to interfaces. they're still pretty similar
15:23:10 <int80_h> my company is developing a programming contest for students. Oh yeah and the web server is WARP and the aaplication server is Yesod. Hah!
15:23:36 <rostayob> shachaf: nothing, I just realized that type classes are close to java interfaces in some ways
15:24:19 <psii> adxp: maybe record pattern matching
15:25:05 <rostayob> shachaf: they are different because data types and objects are totally different. but interfaces : concrete classes = type classes : data types (more or less)
15:25:09 <slack1256> I don't have a CS background, I'm just a hobbist, but I guess I need something as "learn you a haskell.." for algorithms, ideas?
15:25:11 * hackagebot cmdlib 0.3.3 - a library for command line parsing & online help  http://hackage.haskell.org/package/cmdlib-0.3.3 (PetrRockai)
15:25:33 <monochrom> how do you implement "interface Blah<T> { T maxBound() }"? I have a class called BigInt and I want to make it implement Blah, how would it look like?
15:26:05 <monochrom> "class BigInt implements Blah<T> { T maxBound() { ... } }"?
15:26:12 <shachaf> monochrom: BigInts don't have a maxBound. :-)
15:26:17 <adxp_> psii: yeah, that makes sense. so... rewriting, we have "get >>= (\x -> XState { windowset = old })"
15:26:23 <monochrom> so maxBound returns a T rather than BigInt?
15:26:40 <adxp_> psii: and I'm confused as to what exactly is happening with the result of the "get" / what's going on with the record pattern match
15:27:03 <zzo38> I am currently writing Haskglk which needs both a Haskell code and a C code. The C codes might need some parts specific to different computer but the same Haskell code can be used in all systems you do not have to modify it. Can it be send when it works?
15:27:04 <monochrom> or is it "class BigInt<T> implements Blah<T> { T maxBound { ... }}"?
15:27:20 <psii> adxp_: rewriting is more like get >>= (\XState{windowset=old} -> ...)
15:27:57 <monochrom> either way is unlike "instance Blah BigInt where maxBound = 100" which specializes maxBound to maxBound :: BigInt
15:27:57 <rostayob> monochrom: yes I don't think you can achieve what you do with Bounded in haskell in java
15:28:28 <rostayob> monochrom: actually, the first parameter of the class is implicit in java
15:28:38 <rostayob> well...
15:28:38 <psii> adxp: you match the record XState against the value "get" gives you and then the name "old" is bound to the field windowset of XState... hope i don't miss anything
15:28:39 <monochrom> ok so you agree with my <monochrom> if you hide the "class Blah t where maxBound :: t" example, interfaces help
15:29:17 <rostayob> monochrom: yeah that example is broken in java, agreed
15:29:26 <rostayob> it is valid syntax but it doesn't do much
15:30:56 <rostayob> monochrom: well wait
15:31:05 <adxp_> psii: aha, that makes much more sense -- thanks. which leaves me wondering about two things (sorry for being a pita) -- 1) how does the order of assignment end up reversed (wouldn't "old = windowset" be logical?), and 2) what exactly will we be matching against?
15:31:24 <rostayob> can you say "class BigInt implements Bounded<BigInt>"?
15:31:34 <monochrom> I don't know
15:31:38 <rostayob> that'd work
15:31:58 <shachaf> How would you use it?
15:32:02 <dolio> It would work. But then you need to construct a BigInt to get the bounds of a BigInt.
15:32:24 <fazzone> Does   map f . takeWhile (not . null) . iterate tail   compile into something like the following pseudo-C:  for (node; node->next; node = node->next) f(node);  ?
15:32:28 <rostayob> dolio: well that's what you get with Bounded in haskell, the maximum value that the data type can hold
15:32:57 <shachaf> fazzone: FSLVO "like"
15:33:14 <kng> thr?
15:33:40 <fazzone> shachaf: FSLVO?
15:33:49 <fazzone> for S. L. values of?
15:34:01 <shachaf> "sufficiently loose", I think.
15:34:03 <monochrom> "for some lax value of"
15:34:10 <shachaf> What monochrom said.
15:34:33 <fazzone> so you can trust that method of iterating through a list to not be an atrocity performance-wise?
15:35:04 <mauke> fazzone: 'for (node; ' is an atrocity
15:35:05 <shachaf> Why are you doing iterate tail?
15:35:36 <shachaf> mauke: It's very-pseudo-C.
15:36:25 <monochrom> change "map" to "mapM_" for a better like
15:36:27 <jerojasro> hi all. I'm trying to :load a file containing this: http://pastebin.com/71Sb5ZcQ into ghci. I'm getting a "BookStore.hs:5:1: parse error (possibly incorrect indentation)" message. any hints
15:36:29 <mauke> The paste 71Sb5ZcQ has been copied to http://hpaste.org/50563
15:36:45 <jerojasro> ?
15:36:46 <hpaste> psii pasted “record pattern match” at http://hpaste.org/50564
15:36:50 <mauke> jerojasro: that file only has 3 lines
15:36:54 <fazzone> mauke: i suppose, i wanted it to be clear that i was talking about a variable node.  mauke: because I want a pointer to the rest of the list, not just that specific element of the list
15:37:06 <fazzone> *the second one should be shachaf:
15:37:24 <dmwit> :t tails -- fazzone
15:37:25 <lambdabot> forall a. [a] -> [[a]]
15:37:33 <psii> adxp_: rewriting adxp: hope that helps a bit. but i didn't get the first part of your question
15:38:00 <fazzone> dmwit: ah, i thought that did something else, thanks
15:38:14 <mauke> jerojasro: are you sure you pasted the right file?
15:38:15 <jerojasro> mauke: found the problem. was working with a different copy of the file
15:38:30 <shachaf> tails will give you the empty list at the end, though.
15:38:36 <jerojasro> oh dear. Please do bash me *sigh*
15:38:45 <dmwit> shachaf: Omitting it was a bug in his code anyway. ;-)
15:38:46 * benmachine cshs jerojasro 
15:38:53 <mauke> cruel and unusual!
15:39:00 <benmachine> definitely both
15:39:07 <jerojasro> oh noes
15:42:03 <adxp_> psii: ah, cool, I think I get it now -- thanks again. Basically, it corresponds to "evaluate 'get', match that against \XState { windowset = old }, which will presumably match, and then let "old" be the "windowset" attr of that. Equivalent to "old = getState.windowset" in some language (though that lacks the pattern match).
15:42:34 <adxp_> psii: what'll old be if the match fails, or should the type system be guaranteeing it'll succeed?
15:45:36 <dmwit> adxp_: That pattern won't fail to match, as it happens. But the type system isn't helping with that guarantee.
15:45:50 <dmwit> It's just that XState only has one constructor, and the rest of the pattern is irrefutable.
15:46:17 <dmwit> You can ask the type system to help catch incomplete matches, but it's not the default.
15:46:31 <dmwit> When incomplete matches fail to match, an exception is thrown.
15:46:40 <dmwit> I think that covers the entire question.
15:46:40 <adxp_> dmwit: but what if get returns, say, "2", rather than an XState -- or is that not possible?
15:46:50 <dmwit> That is not possible.
15:46:56 <dmwit> Thank Truth.
15:47:13 <adxp_> dmwit: because we're in a state monad computation with the state being an XState?
15:47:41 <dmwit> Yes.
15:47:46 <dmwit> More specifically
15:48:25 * dmwit decides against the more specific sentence
15:49:04 <adxp_> dmwit: :)
15:49:13 <adxp_> dmwit/psii: thanks a lot. that clears it up.
15:56:50 <mm_freak> i'd like to repeat my question:  what's the current state of haskell on smartphones?
15:59:56 <monochrom> runs on jailbroken iPhones
16:00:05 <dcoutts> mm_freak: there's a slightly ageing iphone port, but I hear there is work on a new port
16:00:14 <dcoutts> monochrom: I don't think they need to be jailbroken
16:00:21 <mm_freak> what about android?
16:00:35 <mm_freak> any work in progress or even something to see?
16:00:54 <dcoutts> mm_freak: not afaik, but the work required is much the same.
16:00:56 <monochrom> nice
16:00:58 <shachaf> mm_freak: You might ask Cale.
16:01:02 <dcoutts> mm_freak: interested in helping?
16:01:15 <mm_freak> shachaf: i know, that's why i'm asking =)
16:01:18 <shachaf> Or in #haskell-game.
16:01:35 <shachaf> Well, you need to summon Cale. :-)
16:01:37 <shachaf> @quote stereo
16:01:38 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
16:01:40 <mm_freak> dcoutts: i'm not so good at writing compilers
16:01:44 <shachaf> What!
16:01:45 <shachaf> @quote stereo
16:01:46 <lambdabot> lambdabot says: omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
16:01:51 * shachaf sighs.
16:02:49 <dcoutts> monochrom: as I understand it, you either use jailbroken phones or you sign up to the apple dev programme
16:03:06 <dcoutts> which lets you sign apps so they can run on ordinary iphones
16:03:15 <shachaf> ryant5000 is also a good option. :-)
16:03:23 * monochrom applies excluded middle to simplify the disjunction!
16:04:26 <mm_freak> shachaf: i don't know exactly, but apparently Cale is working on something commercial, and i don't want him to tell me his secrets…  what i'm asking for is publicly available material
16:04:57 <ryant5000> mm_freak: we (Cale, me, blackh, etc.) have GHC 6.10 working for iPhone, and it's open-sourced (BSD)
16:05:03 <deech> Silly question, why is it hard to write a competing Haskell compiler that can do what GHC can?
16:05:10 <franny> Haskell on Android would basically entail compiling Haskell to the JVM, wouldn't it?
16:05:15 <ryant5000> mm_freak: we're working on Android still
16:05:19 <edwardk> deech: because ghc is _huge_
16:05:20 <shachaf> deech: Because GHC does a lot.
16:05:21 <ddarius> deech: GHC is 20+ years of development.
16:05:22 <Cale> deech: Because there are a ton of extensions
16:05:22 <ryant5000> franny: no, Android supports native apps
16:05:28 <dcoutts> franny: no, you'd target arm code
16:05:30 <ryant5000> franny: (ARM)
16:05:46 <mm_freak> deech: because GHC is a collection of a vast amount of work and knowledge, which is very difficult to replicate
16:05:47 <franny> ryant5000: ah; how much of the Android API do you get from the native side?
16:05:51 <edwardk> deech: 20+ years of development by some of the smartest functional programmers on the planet is hard to beat
16:06:12 <ryant5000> franny: not all of it, but you can just write wrappers in Java
16:06:12 <mm_freak> ryant5000: android would be more of interest to me, because i'm planning to buy an android phone
16:06:24 <deech> Is it huge compared to say, Common Lisp? There are mutiple implementations of that.
16:06:26 <ryant5000> mm_freak: yeah; well, we've got work underway that will provide that
16:06:36 <Cale> http://research.microsoft.com/~simonpj/papers/constraints/jfp-outsidein.pdf -- you may want to start here if you're interested in duplicating GHC's feature set.
16:06:44 <ryant5000> deech: don't the CL implementations generally have compatibility issues?
16:06:52 <mm_freak> deech: from an implementation standpoint haskell is a complicated language, much more complicated than common lisp, so yes
16:06:57 <ryant5000> i always got the impression that it wasn't quite as Common as one might think
16:06:58 <edwardk> deech: yes
16:07:03 <monochrom> ghc is evidently larger than allegro common lisp
16:07:11 <mm_freak> deech: actually it's not complicated to compile, but it's complicated to compile /well/
16:07:14 <ddarius> mm_freak: There aren't too many -very good- implementations of CL, and most of the good ones are commercial.  And CL has a lot of implementation history to draw from.
16:07:31 <monochrom> don't forget that a lisp compiler pretty much doesn't have to worry about laziness
16:07:41 <mm_freak> ddarius: of course, not questioning that, but compared to haskell CL is a very simple language
16:07:45 <monochrom> and oh, a lot of type checking
16:07:50 <ddarius> mm_freak: No, it isn't.
16:07:52 <deech> ryant5000: I've used CLISP and SBCL in the past and things have compiled on successfully.
16:07:54 <dcoutts> ryant5000: btw, if you wouldn't mind poking blackh to send me something about the current technical status I'd be much obliged. I'm going to chat to Tim again later this week.
16:07:57 <franny> Most of the Common Lisp implementations are about as old as GHC, aren't they? So you've got all those years of work, too.
16:08:02 <ddarius> mm_freak: And I actually meant my first comment for deech.
16:08:15 <edwardk> deech: that isn't to say writing a new haskell compiler with a feature set near that of GHC is impossible. I can see in 10 years time there being a competitive implementation if there was a financial motivation for one to exist
16:08:20 <mm_freak> ddarius: ah, i see
16:08:26 <ryant5000> dcoutts: yeah; i'll talk to him, sorry we've both been quite busy for the last few days
16:08:36 <mm_freak> ddarius: do you think that CL is more complicated to compile well?
16:08:39 <dcoutts> ryant5000: s'ok, I know busy :-)
16:08:49 <ddarius> mm_freak: Yes.
16:08:51 <edwardk> deech: you can write a lot of Haskell code that will compile and run well on each of Hugs and NHC, and GHC.
16:09:00 <edwardk> deech: but ghc isn't just haskell 98
16:09:15 <mm_freak> ddarius: assuming that you use the same language to compile both…
16:09:37 <deech> edwardk: my understanding is that it is Haskell 98 + extensions.
16:09:42 <mm_freak> CL is a strict language after all and doesn't require a smart runtime system
16:09:47 <ddarius> mm_freak: CL is a pretty hostile language toward compilation.
16:09:48 <mm_freak> only garbage collection
16:09:56 <monochrom> my tic-tac-toe program is as old as ghc. this tells you nothing about how sophisticated my tic-tac-toe program is
16:10:09 <edwardk> deech: and more importantly the type system that we want is somewhat unresolved. so you can build your shiny new haskell, only to have ghc veer left on the way they are handling type families or data families and be stuck in an intellectual backwater
16:10:12 <ddarius> mm_freak: It doesn't require a smart run-time system only insofar as you are making a crappy implementation.
16:10:13 <Cale> deech: Yes, but Haskell 98 is not really a whole lot
16:10:16 <zachk> how sopisticated is it?
16:10:18 <mm_freak> i can see where you're getting it…  CL is not really meant to be compiled…  compiling CL essentially means wrapping an interpreter around the source code
16:10:42 <Cale> deech: Probably implementing Haskell 98 will be 1% of your work.
16:11:06 <franny> Common Lisp can be and is compiled.
16:11:23 <edwardk> franny: but to do so is hard.
16:11:34 <ddarius> s/do so/do so well/
16:11:45 <dcoutts> Cale: btw, I understand I should also be talking to you about the commercial side of development of ghc on iphone
16:11:46 <monochrom> haha, my tic-tac-toe program is trivial :)
16:11:56 <mm_freak> franny: every language can be compiled, but the source code structure doesn't really go away, at least if you use CL seriously
16:11:59 <dcoutts> Cale: so if you have a moment some time
16:12:04 <Cale> dcoutts: Well, ryant5000 is probably better for that
16:12:10 <rostayob> ghc is slightly older than me
16:12:26 <monochrom> the easy word "extensions" hides the need for a totally different level of type-checking.
16:12:35 <dcoutts> Cale: yes I have been talking to ryant5000, I'd not realised you had an interest in it too
16:12:35 <Cale> Or even blackh, since he's responsible for the actual compiler patches :)
16:12:39 <ddarius> monochrom: Indeed.
16:12:43 <deech> Ok, competing with GHC is out. Is there documentation on understanding GHC source? I just feel as though I type things into a black box and that a very small number of people understand how it works.
16:12:47 <Cale> oh, I see
16:12:53 <Cale> I'm working for ryant5000
16:13:00 <dcoutts> Cale: ahh, I see
16:13:01 <ddarius> The core theory that GHC uses to type check has evolved quite a bit since Haskell 98.
16:13:06 <edwardk> deech: yes, there is a code commentary on haskell.org
16:13:08 <ddarius> (Well, actually before Haskell 98...)
16:13:19 <dcoutts> Cale: ok, confusion cleared up :-)
16:13:21 <rostayob> deech: http://hackage.haskell.org/trac/ghc/wiki/Commentary
16:13:30 <ryant5000> dcoutts: the more the merrier, though; we should add Cale to our email thread
16:13:36 <mm_freak> deech: competing with GHC when it comes to general purpose compilers is probably out, but there is still reason to write alternative compilers:  special purpose programs
16:13:41 <ddarius> deech: You can compete with GHC, just don't expect to do so without like five years of effort.
16:13:58 <mm_freak> one may want to write a compiler specifically targetting embedded systems, which would be a huge task by its own…  one that GHC doesn't cover
16:14:03 <deech> Plan B
16:14:16 <ddarius> mm_freak: That would require changes to the language most likely.
16:14:23 <monochrom> try to generate javascript and do it very well
16:14:26 <deech> Plan B: Fork GHC on Github, rename to DHC ... profit.
16:14:59 <ryant5000> mm_freak: jhc and yhc have done some embedded-specific stuff, iirc
16:15:01 <monochrom> oh, while you fork GHC, some people take issues with the choice of the keywords "data", "type", "newtype". maybe you can fix that too
16:15:09 <deech> rostayob: Thanks, this is really cool.
16:15:12 <dcoutts> ryant5000: right :-).  Talk to you again later this week hopefully.
16:15:19 <rostayob> monochrom: do you mean for in-browser use? because i have trouble imagining all the concurrency stuff in javascript
16:15:20 <Cale> deech: Yeah, part of the problem is that the interaction between all the various type system extensions is not something that was well-thought-out from the start, and there has been recent work (that paper I linked) on this, but it's not really a completely solved problem.
16:15:24 * dcoutts disappears
16:15:24 <mm_freak> ddarius: what kind of changes?
16:15:30 <mm_freak> ryant5000: oh, interesting
16:15:33 <monochrom> yeah javascript for in-browser use
16:15:55 <mm_freak> a haskell-to-javascript compiler would be awesome…  then i could finally write everything in the same language
16:16:03 <mm_freak> i think ur/web has done that to some extent
16:16:10 <rostayob> monochrom: well than having a complete haskell98 in awkward is going to be hard
16:16:17 <Cale> deech: It's even true that the semantics of the interactions between type system extensions, and what the compiler would accept has changed a bit between versions of GHC.
16:16:18 <rostayob> mm_freak: there was a yhc core -> js compiler
16:16:18 <ryant5000> mm_freak: have you used ur/web? it looked very interesting
16:16:23 <Dashkal> CLR and JVM targets would also be awesome
16:16:29 <rostayob> monochrom: IO on files, concurrency, etc
16:16:33 <ddarius> mm_freak: You'd probably really want to make memory management more explicit, probably want to control evaluation in a more fine-grained manner, very likely want to explicitly represent time in some manner, and very, very likely will need to dramatically restrict the language.
16:16:44 <ddarius> @google embedded frp
16:16:46 <lambdabot> http://www1.ccny.cuny.edu/prospective/gsoe/upload/Andrew-Tibbetts-MS-2008.pdf
16:16:46 <lambdabot> Title: cache:http://www1.ccny.cuny.edu/prospective/gsoe/upload/Andrew-Tibbetts-MS-2008. ...
16:16:55 <mm_freak> ryant5000: found it interesting, too, but gave up, when i realised that i just couldn't find any editor support for it
16:17:02 <ryant5000> ah
16:17:04 <rostayob> Dashkal: the JVM is quite hostile towards tail recursion afaik
16:17:15 <ddarius> @google embedded functional reactive program
16:17:17 <lambdabot> http://www.cs.nott.ac.uk/~nas/papers_and_talks/icfp09.pdf
16:17:18 <lambdabot> Title: Safe Functional Reactive Programming through Dependent Types
16:17:18 <ryant5000> mm_freak: yeah, that can be tough; even haskell could definitely use some more editor support
16:17:22 <rostayob> but yeah
16:17:23 <ddarius> Bloody shite.
16:17:25 <Dashkal> rostayob: Sadly so.  That seems to be an "implemented never" feature
16:17:39 <mm_freak> ddarius: does that really require changing the language?  perhaps a change in evaluation strategy would suffice
16:17:42 <rostayob> Dashkal: clojure has a construct to solve that problem and it works out nicely
16:17:49 <Dashkal> With that said, tail recursion is possible.  Scala has one as well.
16:17:50 <rostayob> well less nicely than having tail recursion
16:17:56 <rostayob> Dashkal: kind of
16:18:04 <ddarius> mm_freak: The Timber people changed both the evaluation strategy and the language.
16:18:14 <mm_freak> ryant5000: the editor support for haskell is actually not bad, unless you insist on using one of the commercial IDEs
16:18:17 <ddarius> Also, changing the evaluation strategy would be a rather significant change to the language.
16:18:26 <Dashkal> Well, a less efficient solution to the same problem
16:18:43 <ryant5000> mm_freak: yeah, i use haskell-mode in emacs, which is quite good; however, it's not nearly as tightly integrated as, e.g. VC#
16:18:53 <deech> So is GHC pretty much the Simons?
16:18:56 <rostayob> Dashkal: it's not tail recursion, it compiles functions into loops
16:19:24 <mm_freak> ryant5000: well, in haskell i can live with having my local library documentation open in a browser all the time
16:19:45 <mm_freak> it's not like in PHP or C#, where that would really hold you back
16:19:52 <Dashkal> rostayob: Fair enough.  I never dug into the code behind @tailreq
16:19:58 <ryant5000> mm_freak: yeah; we (iPwn Studios) have a haddock/hayoo server, which fills the gap fairly well
16:20:37 <ddarius> deech: Pretty much.  There have been many, many other contributors, but they are the main developers.
16:20:39 <Cale> deech: They're certainly major contributors, and SPJ can be considered the main author, but lots of people work on it.
16:20:48 <rostayob> I actually tought about haskell -> js, and I'm not sure it'd be that useful in the end... they did a clojure -> js compiler recently
16:21:01 <mm_freak> ryant5000: only problem is that it has a non-neglible learning curve to set up your environment for effective haskell programming
16:21:15 <ryant5000> mm_freak: yeah
16:21:52 <ryant5000> mm_freak: and there are some small annoyances here and there; for example, haskell-mode doesn't understand quite all of the haskell syntax
16:21:54 <rostayob> ryant5000: ghc-mod is supposed to do great stuff with emacs but I can't get it to work
16:22:08 <rostayob> ryant5000: also, chrisdone is working on something similar
16:22:19 <rostayob> ryant5000: https://github.com/chrisdone/haskell-emacs
16:22:22 <deech> rostayob: Neither can I. And it chokes on Arrow notation.
16:22:23 <monochrom> I certainly miss auto-completion and auto-add-imports
16:22:24 <ryant5000> rostayob: ah, i'll have to take a look at that
16:22:57 <rostayob> deech: for me it doesn't work at all. did you get something working at all?
16:23:28 <deech> rostayob: Yup, I used it for a Snap app I made a couple of weeks ago.
16:23:59 <deech> rostayob: I pulled from the repository.
16:24:03 <rostayob> deech: did the instruction on the website just work? because i've been trying to figure it out for some time
16:24:16 <rostayob> deech: uh ok, i'll try with the repo version
16:25:26 <deech> rostayob: Just looked at my .emacs. It's pretty much the same as the website.
16:25:53 <rostayob> deech: and when you open an haskell file, you can auto complete and do what you're supposed to do?
16:25:53 <chtaube> Hello
16:26:11 <mm_freak> monochrom: i use the dabbrev functionality of emacs
16:26:15 <mm_freak> for complection
16:26:17 <mm_freak> -c
16:26:30 <mm_freak> it works very well most of the time
16:26:34 <chtaube> My source compiles with ghc, but haddock complains "The last statement in a 'do' construct must be an expression"
16:26:40 <chtaube> http://hpaste.org/50567
16:26:42 <rostayob> mm_freak: yeah but that just gets the words in the file
16:26:43 <deech> rostayob: Uh, I don't think I ever got auto-complete to work, but module browsing and continous compilation seem to work ok.
16:26:55 <rostayob> deech: yeah flymake is what I'm interested in
16:26:58 <mm_freak> rostayob: which has been sufficient for me so far
16:27:14 <chtaube> haddock complains about the line after the 'do'... starting with: hdr <- getOpcHeader
16:27:30 <mm_freak> chtaube: is that the last line?
16:27:38 <chtaube> No
16:27:39 <mm_freak> of the do-block
16:27:48 <chtaube> Its at the beginning of the do-block
16:28:12 <mm_freak> i wouldn't know why haddock would examine function definitions
16:28:26 <luite> does anyone know who's the admin of the server that builds the haddock for hackage, or the scripts that are used for that?
16:28:33 <mm_freak> it should only look at the type signatures of the documented functions
16:28:52 <monochrom> delete the two "^"s
16:29:03 <chtaube> command was: haddock -o doc --html Komnet.hs
16:29:58 <chtaube> monochrom: That worked
16:30:15 <chtaube> Removing the "^" did the trick
16:30:40 <rostayob> deech: nothing, it doesn't work for me. it doesn't even seem to trigger the haskell mode hook, flymake doesn't start
16:31:04 <mm_freak> chtaube: just as a side note, you may want to use cabal for your project
16:31:11 <mm_freak> 'cabal haddock' builds the documentation
16:31:39 <mm_freak> s/use cabal/use cabal-install/
16:32:51 <hpaste> deech pasted “ghc-mod-init” at http://hpaste.org/50568
16:33:27 <deech> rostayob: This is what my .emacs looks like without adding file paths etc. Do you have the same?
16:33:35 <chtaube> mm_freak: Thanks for the advice. I'm still learning haskell and this is going to be my first program which does something useful.
16:34:38 <rostayob> deech: yes, I've got the same
16:35:01 <deech> rostayob: If you start emacs in debug mode does it throw any errors?
16:35:24 <rostayob> deech: could it be because I have (setq exec-path (append exec-path '("/home/deech/.cabal/bin")))
16:35:35 <rostayob> afterwards? I know next to nothing about elisp
16:35:49 <rostayob> I'd think that they just add stuff to the hooks, but let's try...
16:36:30 <rostayob> deech: oh, yes. that did it.
16:37:07 <deech> rostayob: You can always check current value of a variable with M-x customize-variable.
16:38:14 <rostayob> deech: cool, thanks
16:39:15 <rostayob> deech: ahah! it works! this is great
16:39:45 <rostayob> deech: thanks
16:40:50 <deech> rostayob: sure
16:44:13 <rostayob> deech: wait, it highlights when importing non-existant modules
16:44:31 <rostayob> but it doesn't seem to work for other compilation errors
16:44:46 <rostayob> also, wtf is going on?
16:45:57 <deech> rostayob: did you fix the non-existent module errors? It might be stuck on those.
16:48:44 <mm_freak> chtaube: if you feel comfortable doing it the way you do right now, just go on and write code
16:49:09 <mm_freak> you can come back to cabal, when you want to release it to the public
16:50:05 <rostayob> deech: oh yeah, it works. This is great.
16:53:42 <chtaube> mm_freak: I think have still a lot to learn, but I'm evolving.
16:54:16 <mm_freak> have fun =)
16:54:21 <chtaube> I thought it might be a good idea to rewrite a file conversion tool in Haskell which I wrote in Python last year.
16:55:28 <chtaube> I just learned how to use the module Data.Binary.Get
16:56:06 <chtaube> Next step would be an to generate output in CSV format.
16:59:32 <DevHC_> how are haskell comments defined from a (parser's point of view)?
17:01:09 <rostayob> DevHC_: I think it's -- whitespace stuff newline
17:01:21 <rostayob> but ------- stuff is a comment too
17:01:25 <rostayob> --> isn't, for example
17:01:30 <permagreen> Not sure exactly what you mean, but it can't be much different from comments in other languages
17:01:56 <rostayob> permagreen: it's actually quite tricky, because -- can be used as part of an operator
17:02:14 <aavogt> {- -} -} -- is valid I think
17:03:14 <rostayob> DevHC_: http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-170002.3
17:03:20 <DevHC_> meh
17:03:24 <fryguybob> > let x = {- -} -} 42 in x
17:03:25 <lambdabot>   <no location info>: parse error on input `}'
17:04:36 <rostayob> DevHC_: gthe stuff about lexemes are above
17:05:14 <rostayob> the lesson is that haskell is hard to parse.
17:05:18 <aavogt> fryguybob: ah I remember it's that you're allowed  {- {- -} -}, which isn't valid with some other languages multi-line comments
17:05:30 <fryguybob> ah
17:05:43 <fryguybob> > let x = {- {- nested -} -} 42 in x
17:05:44 <lambdabot>   42
17:05:51 <fryguybob> > let x = {- {- ??? -} 42 in x
17:05:52 <lambdabot>   <no location info>: unterminated `{-'
17:06:23 <DevHC_> > --
17:06:24 <lambdabot>   not an expression: `--'
17:06:41 <DevHC_> > 1 --
17:06:42 <lambdabot>   1
17:06:59 <rostayob> > 1 --|
17:06:59 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:07:04 <rostayob> > 1 -->
17:07:05 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:07:19 <rostayob> > 1 ---
17:07:20 <lambdabot>   1
17:08:43 <fryguybob> > let x --— y = 42 in 1 --— 2
17:08:44 <lambdabot>   42
17:16:27 <DevHC_> oh crap, this sux
17:16:30 <DevHC_> "If some code is commented out using a nested comment, then any occurrence of {- or -} within a string or within an end-of-line comment in that code will interfere with the nested comments. "
17:17:09 <DevHC_> > "trol" ++ "{-"
17:17:11 <lambdabot>   "trol{-"
17:17:17 <DevHC_> > {- "trol" ++ "{-" -}
17:17:18 <lambdabot>   <no location info>: unterminated `{-'
17:17:31 <DevHC_> > {- "trol" ++ -- "{-" -}
17:17:32 <lambdabot>   <no location info>: unterminated `{-'
17:17:42 <mauke> (nested comments)--  # are either not nested or not comments
17:18:39 <DevHC_> ?
17:18:44 <permagreen> If I may ask, why the sudden fascination with deep, inner workings of haskell's comments?
17:18:49 <mauke> haskell's aren't nested
17:19:12 <DevHC_> what r u saying?
17:19:42 <Dashkal> > {- nesting {- is -} fun -} 1
17:19:42 <lambdabot>   1
17:19:44 <mauke> http://i.imgur.com/HL1ZR.jpg
17:19:51 <Dashkal> > {- nesting {- is broken -} 1
17:19:52 <lambdabot>   <no location info>: unterminated `{-'
17:20:42 <DevHC_> @let r = are
17:20:43 <lambdabot>  <local>:1:4: Not in scope: `are'
17:20:48 <DevHC_> @let u = you
17:20:49 <lambdabot>  <local>:1:4: Not in scope: `you'
17:21:05 <DevHC_> @undef y
17:21:12 <DevHC_> @let y = yes
17:21:12 <lambdabot>  <local>:1:4: Not in scope: `yes'
17:23:18 <DevHC_> permagreen: i was just curious... wether haskell's comments work intuitively
17:23:50 <DevHC_> zomfg some aspects of C comments work better D:
17:24:20 <DevHC_> for example // or /* in constant strings don't start comments
17:25:03 <Dashkal> The flip side is in C and related, you can't block comment out code with /* */ comments in it.
17:25:18 <mauke> Dashkal: and you shouldn't!
17:25:36 <Dashkal> mauke: Happens at the time in quick compile/test/fix cycles
17:25:38 <mauke> 1) that's what #if 0 .. #endif is for  2) C got this very, very right
17:25:39 <Dashkal> all*
17:25:45 <DevHC_> some C++ extension: {+ +} nested comments :P
17:25:53 <mauke> DevHC_: there is no such thing as nested comments
17:26:01 <permagreen> The only code I ever block out is printf's I used for debugging
17:26:11 <Dashkal> mauke: Not all languages that use C style /* */ have cpp
17:26:12 <DevHC_> mauke: {- -} is a nested comment
17:26:16 <mauke> DevHC_: no
17:26:21 <DevHC_> ORLY
17:26:25 <mauke> Dashkal: yes, and that sucks
17:27:09 <Dashkal> mauke: What construct would you say is being used here? {- nesting {- is -} fun -}
17:27:21 <mauke> Dashkal: broken comments
17:27:33 <Dashkal> It's valid GHC Haskell
17:27:37 <mauke> yes
17:27:50 <Dashkal> From that I state that it is not broken
17:27:55 <Dashkal> Poor style, perhaps, but not broken
17:27:58 <mauke> that doesn't follow
17:28:05 <DevHC_> zomfg, a #haskell op is against haskell, quick let's nail him !
17:28:18 <Dashkal> Using it leaves you with valid source.  Ergo not broken
17:28:27 <mauke> Dashkal: that doesn't follow
17:28:34 <Dashkal> Where broken is defined as a syntax error or code with undesirable results
17:28:40 <mauke> your definition is wrong
17:28:55 <Dashkal> I disagree
17:31:16 <DevHC_> in a large function definition: ... map {-(f 4 'a')-} (g "trol") $ ...
17:31:47 <KirinDave> Is anyone working on an avro interface for haskell?
17:32:34 <DevHC_> the inline {- -} is a result of me wanting to test the effect of (g "trol") instead of (f 4 'a')... now i suddently can't comment out the whole function... that is without nested comments
17:33:10 <mauke> DevHC_: there is no such thing as nested comments
17:33:19 <DevHC_> look here: {- -}
17:33:32 <mauke> comments
17:33:42 <Axman6> eh? i was told that haskell supported nested comments
17:33:45 <DevHC_> look here: {- {- -} -}
17:33:55 <mauke> Axman6: there is no such thing as nested comments
17:33:58 <Axman6> in fact i think i've seen the code that's used to keep track of the nesting somewhere
17:34:03 <DevHC_> Axman6: mauke is just trolling
17:34:03 <mauke> DevHC_: an abomination, but not nested
17:34:12 <DevHC_> @remember troll #haskell
17:34:13 <lambdabot> It is forever etched in my memory.
17:34:15 <DevHC_> @where troll
17:34:15 <lambdabot> ffconsultancy.com
17:34:17 <DevHC_> D:
17:34:21 <DevHC_> @where troll
17:34:21 <lambdabot> ffconsultancy.com
17:34:22 <DevHC_> @where troll
17:34:23 <lambdabot> ffconsultancy.com
17:34:25 <mauke> DevHC_: stop putting crap in the quote database
17:34:33 <mauke> @forget troll #haskell
17:34:33 <lambdabot> Done.
17:34:34 <DevHC_> u can't handle the truth
17:36:11 <DevHC_> oh and
17:36:19 <DevHC_> C got this very very WRONG(TM)
17:36:35 <mauke> how so?
17:37:29 <DevHC_> i am relieved from the burden to justify the correctness of the use of a trademarked word
17:38:17 <mauke> what
17:38:50 * ski notes that  (* (* "*)" *) *)  works in O'Caml
17:39:02 <monochrom> DevHC, please don't abuse lambdabot like this
17:39:18 <mauke> ski: yep, the "nested comments" in OCaml aren't comments
17:39:30 <DevHC_> btw, about the #if 0 #endif case: that's based on how u define preprocessor steps, like 1. apply comments-to-whitespace, 2. apply # stuff, etc.
17:39:36 <ski> yep, they're tokenized, iirc
17:39:40 <mauke> exactly
17:39:45 <DevHC_> haven't read the details of the C preprocessor
17:41:19 * ski ponders how to "comment out" preprocessor directives
17:41:59 <mauke> ski: with comments :-)
17:42:19 <ryant5000> ski: get rid of one of the #'s
17:42:45 <DevHC_> is that an apostrophe used for plural?
17:45:58 <ryant5000> DevHC_: yes; i should've said '#'s
17:46:54 <ryant5000> DevHC_: although i think "'"s for plural of a single character is generally accepted :P
17:49:05 <ezyang> I know strictness analysis can permit unboxing optimizations. Are there any other optimizations it enables?
17:49:46 <zzo38> Is this always a proper way in Haskell to check if it is GHCi or not, using Template Haskell?   GHCi = runIO getArgs >>= \(x:_) -> (x == "--interactive")
17:50:29 <AshtonK> Hey, anyone having issues install haddock? I keep getting a type-error on Haddock.lex
17:51:12 <AshtonK> GHC 7.0.3, trying to install Haddock 2.9.2.
17:52:10 <DevHC_> ryant5000: yes it is accepted by many, and that's a problem; it shouldn't be accepted, because it's WRONG(TM)
17:52:32 <ryant5000>  DevHC_: i agree
17:53:56 <hpaste_> “Ashton K.” pasted “Haddock failure” at http://hpaste.org/50569
17:54:08 <AshtonK> Hey, that's a neat pastebin you guys have there.
17:55:12 * hackagebot husk-scheme 3.2.1 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-3.2.1 (JustinEthier)
18:06:12 <blbrown_win3> lskjlj
18:07:41 <Cale> Firefox is already running, but is not responding. Rather than attempting to tell the process to exit and starting normally, we're displaying this pretty useless error message to you and giving up. Have a nice day!
18:08:03 <aavogt> AshtonK: if you use an older alex (<3.0), does it work?
18:11:19 <dmwit> Cale: Oy, yes. I recently had one of those rare moments where software makes you happy when sup told me, "Hey, it looks like this is already running with process ID 4192, do you want I should give it the ol' k-9 and try again?".
18:11:28 <dmwit> ...with a bit of paraphrasing
18:11:44 <shachaf> dmwit: Paraphrasing? Aw.
18:11:58 * shachaf would use software that talked like that.
18:16:47 <kevea> what was your first programming language?
18:18:04 <permagreen> Python, with the occasional confused foray into lisp.
18:18:06 <Phyx-> vb6 :P
18:18:54 <kevea> Phyx-: what is the difference between VB and BASIC? I've always wondered
18:19:29 <dmwit> kevea: the "v"
18:19:36 <Phyx-> lol
18:19:45 <kevea> dmwit: you username serves you well
18:19:49 <Phyx-> visual basic is a variant of basic.
18:19:52 <dmwit> ;-)
18:20:07 <Phyx-> but I've never really used BASIC
18:20:14 <dmwit> But yeah, VB is a real language. It's got, like, functions and stuff. And objects.
18:20:24 <Phyx-> and the whole visual aspect of it too
18:20:32 <Phyx-> support for events etc are also new i think
18:20:32 <kevea> dmwit: while BASIC has not? And visual as in GUI?
18:20:34 <dmwit> Oh, yeah, it's got much more modern libraries.
18:20:42 <permagreen> I once tried explaining a for loop to someone who only knew Basic. It was painful.
18:20:59 <Phyx-> permagreen: why? Basic has loops
18:21:11 <permagreen> Not because they didn't get the concept mind you, but because they couldn't see why a for loop was superior to a goto
18:21:15 <Phyx-> although, i think it's 1 indexed
18:21:18 <dmwit> kevea: Correct, BASIC has not. I'm not sure the "visual" is actually as in GUI, though that's probably what it's come to mean.
18:21:37 <azaq231> l
18:21:38 <Phyx-> the "Visual" I beleive came about because of the way you build the GUI
18:21:42 <Phyx-> making it a RAD language
18:21:54 <kevea> as in radical?
18:21:56 <Phyx-> i beleive that was VB's strongest selling point
18:22:05 <dmwit> as in rapid application development
18:22:08 <Phyx-> Rapid Application Development
18:22:11 <kevea> damn
18:22:25 <kevea> I used to say Java was rad
18:22:34 <kevea> but not as in RAD
18:22:55 <Phyx-> also, most Basic had a rather limited datatype support
18:23:05 <dmwit> I'd be pretty surprised if there wasn't a VB-builder-alike for Java by now.
18:23:39 <dmwit> (Google confirms: I am not surprised.)
18:23:41 <Phyx-> dmwit: I would be too, they're pretty common
18:24:16 <dmwit> :t findIndices
18:24:16 <kevea> Phyx-: Couldn't you make your own adts?
18:24:17 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
18:25:18 <Phyx-> kevea: no sure.. but then again, it depends on which basic we're talking about
18:25:33 <Phyx-> different implementations had different features
18:25:50 <dmwit> Is this really a fruitful discussion?
18:25:57 <kevea> Fairo, and did Bill Gates develop BASIC or is that a farce?
18:26:22 <Phyx-> he made a version of Basic
18:26:27 <Phyx-> for the Altair
18:26:51 <Phyx-> good old days of Micro-Soft
18:27:08 <dmwit> sigh
18:27:14 <dmwit> > 0 :: Sum Int
18:27:15 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
18:27:16 <lambdabot>    arising fr...
18:27:25 <dmwit> =/
18:27:30 <Phyx-> hm?
18:27:39 <Phyx-> @src Sum
18:27:39 <lambdabot> Source not found. It can only be attributed to human error.
18:27:45 <Phyx-> :k Sum
18:27:46 <lambdabot>     Ambiguous occurrence `Sum'
18:27:46 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
18:27:46 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
18:27:53 <dmwit> newtype Sum a = Sum { getSum :: a }
18:28:17 <Phyx-> lambdabot knows this?
18:28:24 <dmwit> (With the interesting bit being instance Num a => Monoid (Sum a) where mappend = (+).)
18:28:44 <Phyx-> I'm lost on the benefits this would have
18:29:08 <dmwit> Really?
18:29:14 <Phyx-> yes, it's late :)
18:29:32 <dmwit> Interfaces that are generalized to Monoid can be provided with a Sum value or a Product value to specialize to something useful.
18:29:59 <dmwit> > Sum 3 ++ Sum 5
18:30:00 <lambdabot>   Sum {getSum = 8}
18:30:07 <Phyx-> what I meant was, that specific instance doesn't seem to provide anything above just using Int
18:30:13 <dmwit> > msum [Sum 3, Sum 7, Sum 32]
18:30:14 <lambdabot>   No instance for (Control.Monad.MonadPlus Data.Monoid.Sum)
18:30:14 <lambdabot>    arising from a...
18:30:23 <dmwit> > msum [Sum 3, Sum 7, Sum 32] :: Sum Int
18:30:24 <lambdabot>   No instance for (Control.Monad.MonadPlus Data.Monoid.Sum)
18:30:25 <lambdabot>    arising from a...
18:30:27 <dmwit> oh, right
18:30:33 <dmwit> > mconcat [Sum 3, Sum 7, Sum 32] :: Sum Int
18:30:34 <lambdabot>   Sum {getSum = 42}
18:30:51 <dmwit> Phyx-: No, but it does provide a Monoid instance (which just Int doesn't have).
18:30:57 <dmwit> > 3 ++ 5 :: Int
18:30:58 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
18:30:58 <lambdabot>    arising from a use of...
18:32:03 <dmwit> Perhaps the monoid interface is too limited to be convincing.
18:32:04 <Phyx-> Guess i need to read more on category theory to see why this is useful, lol
18:32:31 <dmwit> But I also have another class Monoid m => Foo m where {- some more interesting function types than the monoid ones go in here -}.
18:32:45 <Kaidelong> @ty (<*>)
18:32:46 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
18:32:48 <dmwit> I'd like to use the Int instance of Foo, but Int isn't a Monoid. What to do?
18:32:57 <dmwit> Answer: use the Sum Int instance of Foo instead.
18:33:45 <Phyx-> right, ok
18:33:53 <aavogt> > ala Sum mconcat [3,7,32]
18:33:54 <lambdabot>   Couldn't match expected type `o -> Data.Monoid.Sum o'
18:33:54 <lambdabot>         against infer...
18:34:07 <dmwit> :t foldMap
18:34:08 <lambdabot> Not in scope: `foldMap'
18:34:27 <Phyx-> so it's more about your function is generalized to work on *any* monoid then to make a monoid for Int for no reason
18:34:49 <dmwit> Naturally I wouldn't make a monoid instance for Int for no reason.
18:34:58 <Phyx-> dmwit: just checking :)
18:35:24 <adam__> hello everybody
18:35:29 <aavogt> > ala Sum Data.Foldable.foldMap [3,7,32]
18:35:30 <Phyx-> hello
18:35:30 <lambdabot>   42
18:35:40 <Phyx-> @type ala
18:35:41 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
18:35:49 <Phyx-> lol, Newtype again
18:36:00 <Phyx-> just found out about it a day or two ago
18:36:05 <adam__> how can I define a cartesian product datatype?
18:37:03 <Phyx-> i'm lost
18:38:13 <Phyx-> what exactly are you trying to do adam__ ?
18:38:43 <dmwit> adam__: type CartesianProduct = (,)
18:38:52 <Phyx-> define the cartesian product for your own datatype or?
18:39:41 <dmwit> type CartesianProduct a b = (a, b) -- if you're feeling pointy
18:40:03 <ddarius> The former is better than the latter.
18:40:23 <dmwit> Yes, it is.
18:40:24 <Phyx-> but they are the same
18:40:32 <dmwit> No, they are not.
18:40:38 <Phyx-> how so?
18:40:42 <dmwit> type aliases must be fully applied.
18:41:02 <dmwit> Since "type CartesianProduct = (,)" has no variables on the left, it is always fully applied.
18:41:06 <dmwit> So it may be used in more places.
18:42:36 <dmwit> For example, if you had some wacky data type like "data Wrapper f a b = Wrapper (f a b)", then "Wrapper CartesianProduct" would be okay for the first definition, but not the second one.
18:42:53 <Phyx-> that's going to require some more explanations.. the kind of the former is still * -> * -> * isn't it?
18:43:13 <dmwit> The kind of "CartesianProduct" is * -> * -> * for the first, but doesn't have a kind for the second.
18:43:36 <dmwit> However, the kind of "CartesianProduct a b" is * for both (whenever a :: * and b :: *).
18:44:35 <dmwit> For the sake of sanity, maybe we'd better take "type CP = (,)" and "type CP' a b = (a, b)" for the rest of the discussion, to avoid ambiguity.
18:44:39 <Phyx-> if you had Wrapper CartesianProduct, what are the types of the arguments to (,) ?
18:45:04 <dmwit> Wrapper CP :: * -> * -> *
18:45:12 <dmwit> The arguments to (,) haven't been supplied yet.
18:45:17 <dmwit> But Wrapper CP' is ill-formed.
18:45:30 <Phyx-> right
18:45:32 <Phyx-> i know
18:45:40 <dmwit> okay
18:45:44 <Phyx-> if you had Wrapper (CP' a b) a b you would know the type of the tuple
18:46:33 <Eelis> byorgey: ping (question about Text.PrettyPrint.Boxes)
18:46:37 <dmwit> Wrapper :: (* -> * -> *) -> * -> * -> *
18:46:45 <dmwit> so Wrapper (CP' a b) is ill-kinded
18:46:54 <Phyx-> butah
18:46:55 <Phyx-> true
18:47:02 <Phyx-> ah*
18:47:16 <Phyx-> yeah ok, I see it now
18:47:45 <dmwit> Yeah, that one is a bit subtle.
18:48:19 <adam__> hi again
18:48:26 <Phyx-> I seem to vaguely remember we've covered this a long time ago in AFP class
18:48:42 <ddarius> It would be an odd thing to cover.
18:48:50 <adam__> if I want to change "( a,b )" for "a x b" , how I can I do?
18:49:09 <Phyx-> ddarius: why? I think it was in relation to defining a type alias for StateT
18:49:21 <Kaidelong> adam
18:49:29 <Kaidelong> looks impossible
18:49:43 <Kaidelong> unless you use some kind of a preprocessor or other way to extend the syntax
18:50:04 <ddarius> Phyx-: I guess that's a reasonable place for it to come up.  Most of the time this doesn't matter.
18:50:07 <dmwit> adam__: Add the InfixTypeOperators extension, and use, e.g. type (:⊗) = (,)
18:50:08 <Kaidelong> if you use the infix multiplication operator in unicode perhaps you'd be able to get the same effect
18:50:21 <dmwit> Then you can use a :⊗ b for (a, b).
18:51:15 <adam__> wait
18:51:19 <Phyx-> you add the extension by putting {-# LANGUAGE InfixTypeOperators #-} at the top of your file
18:51:41 <Phyx-> ddarius: yeah, I don't think I've ever used it again, which is why I probably forgot the details
18:51:47 <Phyx-> untill dmwit pointed it out :)
18:52:10 <dmwit> It's usually not an issue.
18:52:32 <ddarius> The only thing to remember is always eta reduce your type aliases as much as possible.
18:53:53 <Primoz128> ummmm...
18:53:58 <Phyx-> good to know
18:54:21 <Phyx-> time for a movie.. then code a bit
18:54:21 <Primoz128> ok weird question is Haskell good o.O ?
18:54:30 <Phyx-> define good
18:54:44 <Primoz128> define answer ME
18:55:23 <mauke> ME sucked
18:55:29 <dmwit> > partition id [False, True]
18:55:31 <lambdabot>   ([True],[False])
18:55:53 <mauke> > partition ask [minBound .. maxBound]
18:55:54 <lambdabot>   ([True],[False])
18:56:14 <dmwit> Thanks, much more readable.
18:56:21 <Axman6> :t ask
18:56:22 <Primoz128> Omg Haskell code is weird <.<
18:56:22 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
18:56:34 <Phyx-> @check \x -> ask x == x
18:56:34 <lambdabot>   "OK, passed 500 tests."
18:56:36 <Axman6> :t partition
18:56:37 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
18:56:39 <adam__> <dmwit> how I can write that pragma in emacs?
18:56:55 <ddarius> wtf?
18:57:11 <Phyx-> adam__: by putting {-# LANGUAGE InfixTypeOperators #-} at the top of your file
18:59:17 <dmwit> > [0..5] >>= findIndices [2,3,0,1,4,5]
18:59:18 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
18:59:18 <lambdabot>         against inferred ...
18:59:29 <dmwit> :t findIndices
18:59:31 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
18:59:50 <dmwit> > [0..5] >>= flip findIndices [2,3,0,1,4,5] . (==)
18:59:52 <lambdabot>   [2,3,0,1,4,5]
19:00:52 <dmwit> :t findIndex
19:00:53 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
19:01:42 <byorgey> Eelis: what's up?
19:01:55 <Eelis> byorgey: ah, hey. i'd like to write a function   addBorder :: Box -> Box   that adds an ascii-art border around a box, but i don't know how to do it without a way to query a given Box's dimensions. i'm guessing you deliberately didn't expose rows/cols? if so, any suggestions on how to implement addBorder?
19:02:58 <byorgey> Eelis: oh man, it's been forever since I wrote that
19:03:13 <Eelis> i'm having a blast using it :D
19:03:13 <ddarius> Code never dies.
19:03:21 <byorgey> Eelis: hmm, I see no good reason not to export rows and cols
19:03:57 <Eelis> byorgey: ah, then exposing those looks like an easy fix :)
19:04:01 <byorgey> I don't think anyone has ever taken me up on the offer to maintain/extend it
19:04:11 <byorgey> if you send me a patch I'd be happy to release a new version
19:04:18 <Eelis> sure thing, one sec
19:04:19 <byorgey> better yet, you could just take over maintaining it yourself
19:04:34 <Eelis> works for me. i've never maintained a hackage package before. what's the procedure?
19:04:55 <AshtonK> Ah, that appears to have gotten it aavogt. Thank you.
19:04:58 <Eelis> or rather, i've never maintained a hackage package that i didn't write myself
19:05:04 <dmwit> Put yourself as maintainer in the cabal file, upload updated package to Hackage. =)
19:05:15 <dmwit> (Hackage's security model is O_o)
19:05:25 <byorgey> no special procedure. let me find the address of the repo for you...
19:05:27 <Eelis> haha, ok, i'll give it a shot :)
19:05:28 <ddarius> Hackage's security model is Ross.
19:05:35 <dmwit> yeah =)
19:05:48 <Eelis> byorgey: thanks
19:06:01 <adam__> <Phyx-> I need to load any library or something?
19:06:02 <byorgey> Eelis: http://code.haskell.org/~byorgey/code/boxes/
19:06:16 <Eelis> byorgey: great, thanks
19:06:27 <byorgey> Eelis: that's a darcs repo, feel free to just take the content and put it in your favorite VCS
19:06:37 <byorgey> or fork a new darcs repo if you like darcs
19:06:49 <Eelis> i'll make it git and put it on github if that's okay
19:07:05 <adam__>    <Phyx> apear :" Unsupported extension: InfixTypeOperators"
19:07:06 <byorgey> you're the maintainer now, it's OK if you say it is =)
19:07:10 <Eelis> great :)
19:07:24 <byorgey> Eelis: once you upload a new version listing yourself as maintainer let me know, and I can take down the darcs one to avoid confusion
19:07:39 <dylukes> hey byorgey
19:07:40 <Eelis> byorgey: ok, will probably be tomorrow (getting late in my time zone)
19:07:47 <byorgey> ok, off to bed, if you have any other questions I'll be around tomorrow
19:07:50 <dylukes> given your experience with diagrams and what not, I kind of have a selfish request.
19:07:50 <byorgey> yep, me too
19:07:53 <Eelis> alrighty
19:07:56 <dylukes> ah, really quick...
19:08:14 <dylukes> If you ever have nothing to do (unlikely) please write a GOOD C-based plotting library. The lack of one is killing me. :P
19:08:24 <dylukes> gnuplot_i/pipes is terrible to work with.
19:08:29 <dylukes> Even though gnuplot is p. good.
19:08:38 <byorgey> dylukes: sorry to disappoint, I have plenty to do =P
19:09:09 <dmwit> dylukes: FFI calls to the diagrams library ;-)
19:09:21 <dylukes> byorgey: just a silly request ;P
19:09:33 <dylukes> dmwit: I need to plot thousands/millions of data points, cartesian
19:09:42 <dmwit> (More realistically: wouldn't plain old cairo cover pretty much everything you want for plotting?)
19:10:03 <dylukes> hm
19:10:14 <dylukes> I've never tried plain old cairo ^^;
19:10:51 <dmwit> Cairo has a pleasantly clean API (given the domain it's trying to deal with).
19:15:19 <adam__> <dmwit> it works with {-# LANGUAGE TypeOperators #-} type a :×: b = (a,b)
19:15:28 <adam__> thanks
19:50:13 * hackagebot enumerator 0.4.14 - Reliable, high-performance processing with left-fold enumerators  http://hackage.haskell.org/package/enumerator-0.4.14 (JohnMillikin)
19:50:15 * hackagebot boxes 0.1.2 - 2D text pretty-printing library  http://hackage.haskell.org/package/boxes-0.1.2 (eelis)
19:52:06 <dmwit> Wow, I've found a situation where "forall" does not appear in my file, but the file only compiles cleanly if ScopedTypeVariables is turned on.
19:52:10 <dmwit> O_o
19:53:31 <dolio> Do you use types in a pattern match?
19:54:33 <dmwit> No, I figured it out: it was in a class instance.
19:55:20 <Kaidelong> RVar is so huge
19:55:35 <Kaidelong> random-fu I should say
19:55:42 <Kaidelong> all I want to do is take an RVar Int
19:55:52 <Kaidelong> and make a function seed -> [Int]
19:55:56 <Kaidelong> using that RVar Int
19:56:15 <Kaidelong> but I've dug for a long while and I can't see how
19:56:31 <Kaidelong> with Cale's MonadRandom that sort of thing was straightforward
19:56:51 <dmwit> replicateM (sample rvar)
19:57:06 <dmwit> :t runState
19:57:07 <lambdabot> forall s a. State s a -> s -> (a, s)
19:57:29 <Kaidelong> dmwit: Is it not possible to use the list monad directly?
19:57:31 <dmwit> runState (replicateM numberofresultsyouwant (sample rvar)) seed
19:58:00 <Kaidelong> @hoogle runState
19:58:01 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
19:58:01 <lambdabot> Control.Monad.State.Strict runState :: State s a -> s -> (a, s)
19:58:02 <lambdabot> Control.Monad.State.Lazy runStateT :: StateT s m a -> s -> m (a, s)
19:58:47 <dmwit> :t evalState -- eh, maybe you want this instead of runState
19:58:48 <lambdabot> forall s a. State s a -> s -> a
20:02:19 <Kaidelong> @ty evalState (replicateM 10 (integralUniform 1 100))
20:02:20 <lambdabot> Not in scope: `integralUniform'
20:03:20 <Kaidelong> well I guess the problem is simple enough here
20:03:42 <Kaidelong> runState wants a StateT but the thing it's being fed is an RVarT
20:03:54 <Kaidelong> hmm
20:06:26 <Kaidelong> runStateT . lift  works but it leafs you with an RVarT rather than a list
20:06:31 <Kaidelong> leaves even
20:08:50 <Kaidelong> oh whoops dmwit
20:08:56 <Kaidelong> I forgot to use sample
20:09:36 <hpaste_> geheimdienst pasted “strings to signals” at http://hpaste.org/50570
20:10:46 <geheimdienst> ^^ any opinions which option is to be preferred? cause i favor number 2
20:12:34 <mkscrg> So I get that typeclasses are a stricter concept than interfaces, so the functions of the class have to involve the type variable of the class
20:12:58 <mkscrg> But then what's a good way to say that a class has to define, say, a function that takes no arguments and just returns a String?
20:16:28 <mustelo> mkscrg, it might help to understand how type classes are implemented operationally to know why something like that is not possible (in the most direct way)
20:18:31 <ghartshaw_> @pl \dc c -> drawRect dc (cellrect c) []
20:18:31 <lambdabot> flip flip [] . (. cellrect) . drawRect
20:20:13 <rwbarton> mkscrg: the issue is you can't just write  class HasString a where f :: String  and then go about using f (which would have type HasString a => String), since the compiler will never know what type a you want
20:20:37 <rwbarton> one way around this is to define  newtype Labeled lab t = Labeled t; class HasString a where f :: Labeled a String
20:21:17 <rwbarton> unlabel :: Labeled lat t -> t; unlabel (Labeled x) = x; and then use, for example, unlabel (f :: Labeled Int String) to specify that you want the Int instance
20:22:04 <Kaidelong> found what I need
20:22:06 <Kaidelong> sampleState
20:22:14 <Kaidelong> in particular I could to
20:22:47 <Kaidelong> toList rvar s = sampleState rvar s : toList rvar s
20:22:48 <Kaidelong> I think
20:22:58 <geheimdienst> mkscrg: suppose you have two instances of the typeclass, one defining f = "lol" and the other defining f = "cat". if you then do "print f", there'd be no way for the compiler to know which of the two you want
20:24:12 <mkscrg> Right. I grok the problem from the type system's perspective. I'm just wondering what's an idiomatic/succint way to get the behavior I want.
20:24:49 <rwbarton> another common solution is to just define  class HasString a where f :: a -> String  and then never use the argument of type a
20:24:57 <rwbarton> @type sizeof
20:24:58 <lambdabot> Not in scope: `sizeof'
20:25:20 <rwbarton> @type sizeOf
20:25:22 <lambdabot> Not in scope: `sizeOf'
20:25:22 <mkscrg> rwbarton: Yeah, I was about to say that seems like a cleaner solution
20:25:30 <rwbarton> it's really less clean
20:25:38 <rwbarton> but somewhat more convenient
20:26:00 <Kaidelong> every time I think I have it, something else thwarts me
20:26:08 <rwbarton> @hoogle sizeOf
20:26:09 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
20:26:09 <lambdabot> Network.Socket.Internal sizeOfSockAddr :: SockAddr -> Int
20:26:09 <lambdabot> Network.Socket.Internal sizeOfSockAddrByFamily :: Family -> Int
20:26:17 <rwbarton> there we go, that's what is used by sizeOf for example
20:26:27 <geheimdienst> mkscrg: mind telling us what exactly what you're looking to do?
20:27:16 <mkscrg> I'm thinking about writing an ODM (object-data mapper) for Haskell and mongoDB
20:27:52 <mkscrg> It involves some config data, like the db name, collection name, mongo server address, etc
20:28:54 <mkscrg> Ideally it would just be a typeclass that only requires defining a toBson function and somehow passing that config
20:30:01 <mkscrg> I'm starting to think that a HOF-based approach would be a cleaner way to handle the config
20:30:26 <kevea> anyone compile on an i7?
20:31:47 <mkscrg> kevea: Yah
20:31:48 <luite> kevea: yeah my server is an i7, wat about it?
20:31:59 <Kaidelong> okay something smells
20:32:12 <Kaidelong> if I try the example in Data.Random.RVar
20:32:20 <geheimdienst> mkscrg: i don't really see how typeclasses fit into that picture ... you might want to look at the Reader monad, which is simpler to use than it sounds. you can put all the functions that need the db config in that monad and have the config available there via a "get" method
20:32:20 <Kaidelong> GHCi complains about a missing instance
20:32:32 <Kaidelong> so I think I need a language extension or another import
20:32:34 <luite> mkscrg: have you looked at persistent, this has a mongodb backend and does mapping between the db and haskell types
20:32:42 <Kaidelong> sampleState (uniform 1 100) :: StdGen -> (Int, StdGen)
20:32:44 <Kaidelong> doesn't work
20:33:06 <geheimdienst> an alternative is implicit parameters (language extension). or of course the basic solution, passing around a record with the config
20:33:42 <mkscrg> luite: That is exactly what I was about to reinvent! Excellent.
20:34:11 <mkscrg> geheimdienst: I'll look into that.
20:34:16 <luite> mkscrg: most larger programs have some monad transformer stack that somewhere has a state, typically a connection pool or something
20:35:01 <wli> I don't get the point of implicit parameters, or how they're in keeping with the functional programming theme.
20:35:15 <luite> mkscrg: if you have a yesod scaffolded application, this is somewhat hidden for you, but you can run queries with the runDb function
20:36:00 <luite> mkscrg: by the way, persistent has ben overhauled, to make selecting/filtering/sorting stuff much more flexible, you might want to look at the latest version on github
20:36:57 <mkscrg> Will do. The github version has yet to be pushed to hackage?
20:37:25 <luite> yeah, there will probably be a release candidate soon, for the new yesod/persistent/hamlet things
20:37:36 <mkscrg> Ah, good to know.
20:38:47 <luite> there were some issues building yesod with ghc 7.2.1, but I think the last fixes were merged 5 minutes ago
20:39:47 <Kaidelong> @hoogle sampleRVar
20:39:48 <lambdabot> No results found
20:45:29 * Kaidelong finally figures it out
20:45:47 <Kaidelong> for some reason
20:46:01 <Kaidelong> sampleState does not work the same as (runState . sampleRVar)
20:46:16 <Kaidelong> explicitly saying (runState . sampleRVar) fixed the overlapping instances
20:46:54 <Kaidelong> I guess because it eliminated the ambiguity with StateT Identity and State
20:47:23 <Kaidelong> rVarToList var s = x : rVarToList var s' where (x,s') = (runState . sampleRVar) var s
20:47:42 <Kaidelong> will take an RVar, a StdGen, and give you a list of random values
20:47:52 <Kaidelong> it seems to run and compile without any language extensions
21:04:17 <guerrilla> parsec question. i put "type Parser = Parsec String History" and use Parser a for the type of my parsers, but when checking the invocation of runParser, i keep getting "No instance for (Stream String Data.Functor.Identity.Identity t0)" but i can see in the manual that there is an instance for Stream [tok] m tok, what's going on?
21:05:18 <mustelo> guerrilla, that's a nasty error. I think I recall fixing it by adding explicit type signatures to various parsers... have you tried that?
21:05:49 <mustelo> if that doesn't work, can you paste an example of something that doesn't work?
21:05:52 <mauke> a general note: if you're not getting an instance that you see in the manual, you may be missing an import
21:05:55 <guerrilla> yes, allof them has explicit signatures
21:06:02 <mustelo> please paste then
21:06:04 <guerrilla> mauke: ok good point, let me verify
21:06:27 <guerrilla> nah Stream is in Text.Parsec.Prim, which i've imported
21:06:39 <guerrilla> mustelo: past which part exactly?
21:06:52 <mauke> classes, types, and instances can be in completely separate modules
21:06:53 <mustelo> the smallest thing you can reasonably paste that still fails
21:07:05 <guerrilla> ah the instance could be, good point
21:07:16 <guerrilla> how do i found that out?
21:07:18 <guerrilla> http://hackage.haskell.org/packages/archive/parsec/3.1.1/doc/html/Text-Parsec-Prim.html#t:Stream
21:07:59 <mustelo> I've seen these errors before with Stream... I recall the fix being non-intuitive, meaning it's not actually an instance issue, but I could be wrong
21:08:01 <guerrilla> it's true, the instance isn't in the source for Prim
21:08:58 <guerrilla> found it
21:09:00 <guerrilla> http://hackage.haskell.org/packages/archive/parsec/3.1.1/doc/html/src/Text-Parsec-String.html
21:09:20 <guerrilla> there, fixed
21:10:05 <guerrilla> thanks guys
21:17:55 <mgsloan> http://www.mgsloan.com/wordpress/?p=36 </shameless-plug>  any nit-picks 'n such?  It's my first haskell-related blog post!
21:24:29 <MichaelBurge> I'm doing some purely functional processing of some data, and the code returns the result that I want. But now I want to record different events that happen, so that I can prettyprint a result of what happened. What's the best way to record events happening throughout the processing code?
21:24:58 <Modius> join #iphonedev
21:25:02 <ash_> do you mean like trace?
21:25:23 <shachaf> MichaelBurge: There's Control.Monad.Writer.
21:25:26 <MichaelBurge> I've been using trace to debug it
21:25:49 <ivanm> RWH has a chapter on the Writer monad
21:27:11 <shachaf> I wonder if "the Writer monad" is really a reasonable name for it.
21:27:57 <mustelo> shachaf, what do you recommend? the Accumulator monad?
21:28:09 <lpsmith> Is there anybody here that knows the new GHC I/O manager reasonably well?    What's the point of having multiple event managers?   How are they supposed to be used?
21:28:32 <shachaf> mustelo: I mean using "the Foo monad" when referring to Foo.
21:29:06 <mustelo> hmm, okay let me rephrase: what do you recommend using instead? ;)
21:29:33 <mauke> Writer
21:30:08 <MichaelBurge> If I'm using the Writer monad, I can just keep all my logic at the end of the do statement with "return X" and it won't change the correctness of the results?
21:30:13 <mustelo> but that doesn't have the word "monad" in it :o
21:30:16 <mauke> like when you need to store a bunch of characters, do you use String or do you use the [] monad?
21:30:18 <MichaelBurge> and then record things before it?
21:30:33 <shachaf> What mauke said.
21:31:06 <shachaf> MichaelBurge: Yep -- look at the implementation of Writer.
21:31:13 <mustelo> heh, well let's just call it Monoid m => ((,) m) then
21:31:17 <mauke> or when you need to square numbers, you should use the (->) Integer applicative functor
21:31:41 <shachaf> mauke: Sure you mean monad? Applicative functors don't have join. :-)
21:31:45 <shachaf> > join (*) 3
21:31:47 <lambdabot>   9
21:31:49 <MichaelBurge> Thanks for your help, then
21:31:57 <mauke> shachaf: doesn't mean it's not an applicative functor
21:32:07 <mauke> shachaf: "monad" doesn't capture all of it either
21:32:27 <shachaf> Yep.
21:32:37 <shachaf> Anyway, that terminology annoys me a bit.
21:32:48 <shachaf> Particularly things like "the IO monad", just because IO is a bit of a generic name.
21:34:13 <MichaelBurge> What *exactly* does the IO monad encapsulate? Calling C functions?
21:34:39 <mauke> the IO *monad*?
21:34:46 <_Ray_> Computations which write and read from standard output and input, and return a value.
21:34:49 <mauke> sequencing of side effects, I suppose
21:35:01 <mauke> read/write is not part of the monad interface
21:35:22 * shachaf is pleased to have gotten mauke started.
21:35:40 <_Ray_> It's not part of the general monad interface, but it is part of the IO monad.
21:35:45 <mauke> no
21:35:47 <mauke> it's part of IO
21:36:16 <_Ray_> If one is to be pedantic, they are functions that use the IO monad.
21:36:24 <mauke> no
21:36:29 <mauke> they are functions that use IO
21:36:35 <shachaf> No. They are functions that have types involving IO.
21:36:37 <applicative> getChar isn't a function
21:36:40 <mauke> except getChar
21:36:43 <mauke> yeah :-)
21:36:54 <shachaf> s/functions/values/
21:36:55 <_Ray_> That's what I meant by "use" the IO monad.
21:37:07 <shachaf> _Ray_: Why do you keep saying "the IO monad"?
21:37:18 <_Ray_> Because its name is IO and it is a monad?
21:37:22 <shachaf> foo :: Int -> Int -> Maybe Int; does foo "use the Maybe monad"?
21:37:26 <mauke> _Ray_: it's also a Functor
21:37:26 <shachaf> It's a thousand other things, too.
21:37:27 <_Ray_> Sure.
21:37:40 <applicative> don't say it, say the IO functor, you'll find your thoughts become instantly clearer :)
21:37:45 <_Ray_> shachaf, it inequivocably defines what I want to say.
21:38:05 <mauke> except when it doesn't, such as now
21:38:09 <_Ray_> ...
21:38:12 <mustelo> well, I'm sure we can all agree that monads are the most important thing in haskell. really there's nothing else. ;)
21:38:15 <_Ray_> *unequivocally
21:38:30 <_Ray_> mauke, it surely does. We all know what I'm talking about when I say "the IO monad".
21:38:39 <_Ray_> It is the type constructor IO.
21:38:44 <applicative> there's nothing else but the identity monad, i.e. the type system
21:38:45 <mauke> no
21:38:53 <Cale> It's okay to say "the IO monad" when referring to the entire IO library, but people *do* emphasise the fact that it's a monad a bit too much.
21:39:06 <mauke> in the current context it means something like "I'm clueless" or "I'm obnoxious"
21:39:08 <mustelo> nobody took my bait...
21:39:12 <applicative> it's a menace it must go
21:39:17 <mauke> mustelo: too obvious
21:39:25 <shachaf> I think we should call it "the IO applicative".
21:39:26 <mustelo> better luck next time
21:39:32 <shachaf> So that applicative's IRC client beeps.
21:39:34 <_Ray_> I don't think I'm clueless or obnoxious, and I do say "the IO monad" to describe that monad.
21:39:36 <mauke> shachaf: I'm going to go with "the IO PrintfType"
21:39:39 <applicative> it's too obvious that's why I took it
21:39:56 <kfish> people like doing sequences of stuff in IO, using do syntax, so they talk about the monad ... yay
21:40:00 <_Ray_> That it is a Functor is irrelevant - dogs are mammals, and I still call them dogs, and very rarely mammals.
21:40:12 <mauke> _Ray_: you're not talking about its monadic structure
21:40:13 <applicative> it doesn't beep i just get pleasant highlighting
21:40:19 <geheimdienst> the KitchenSink
21:40:27 <_Ray_> I am talking about its ability to join and bind, sure.
21:40:34 <geheimdienst> the EverythingAndTheDog
21:40:40 <ivanm> is there a comparison between the different iteratee implementations anywhere?
21:40:41 <mauke> _Ray_: and by the same argument you could say that it is a Monad is irrelevant
21:40:45 <shachaf> geheimdienst: *and* the dog?
21:40:56 <_Ray_> It's implicit in the word "monad". I could also say monoid in the endofunctor of Hask category. I choose not to, because you all understand what I mean.
21:41:02 <kfish> ivanm, saw one somewhere ... what do you want to do?
21:41:11 <_Ray_> Unless, of course, one pretends not to understand to, as you said, be obnoxious.
21:41:19 <applicative> geheimdienst: I have a tab trigger KitchenSink, for ugly pragmas like IncoherentRankNFamilies
21:41:46 <shachaf> _Ray_: But why bring up *that* type class, of all the ones you can bring up?
21:41:51 <shachaf> It's just irrelevancies.
21:42:01 <shachaf> This is a productive discussion.
21:42:03 <_Ray_> It's the most used aspect of IO.
21:42:13 <_Ray_> Its monadic structure.
21:42:16 <mauke> _Ray_: [citation needed]
21:42:23 <mauke> in fact, that would surprise me
21:42:30 <_Ray_> Citation: do notation.
21:42:31 <ivanm> kfish: something along the lines of John Lato's answer to my question here, but I like the fact that the enumerator library has fewer deps than the iteratee one: http://stackoverflow.com/questions/7020854/serialising-and-counting-a-list-of-values
21:42:35 * applicative uses readFile and writeFile most
21:42:46 <mauke> _Ray_: that's not a citation
21:42:54 <dolio> Like main = readFile?
21:43:09 <mauke> _Ray_: I can almost guarantee that every occurrence of do notation is going to contain a non-monadic use of IO
21:43:36 <_Ray_> By definition, when you use the do notation inside the IO monad, you are using IO's monadic structure.
21:43:45 <ivanm> _Ray_: AFAIK, most people consider IO to be an abnormal Monad
21:43:52 <_Ray_> The whole point is to use join and bind transparently.
21:43:59 <ivanm> and learning IO /= learning monads
21:44:07 <mauke> _Ray_: yes, but you said it was more common than the non-monadic parts
21:44:08 <kfish> ivanm, i use iteratee because it seems to have better support for seeking (and earlier it had better support for binary data / bytestrings)
21:44:10 <mauke> that doesn't follow
21:44:15 <applicative> > do {a <- ["haha","hoho"]; b <- a ; return $ ord b}
21:44:16 <lambdabot>   [104,97,104,97,104,111,104,111]
21:44:27 <ivanm> kfish: *nod*
21:44:53 <_Ray_> mauke: You /need/ to use its monadic structure, at least once, every time you use it.
21:45:01 <mauke> _Ray_: no, I don't
21:45:17 <mauke> proof: trivial
21:45:32 <_Ray_> This is sort of tautological, since I mean "use" as in perform a computation that does input/output.
21:45:41 <mauke> input/output is not monadic
21:45:53 <shachaf> _Ray_: When you say x = [1,2,3], are you using []'s monadic structure?
21:45:55 <_Ray_> It is when you use the IO monad to handle it.
21:46:04 <mauke> all programs of the form 'main = interact f' don't use the monadic parts of IO
21:46:08 <mauke> _Ray_: no
21:46:19 <_Ray_> shachaf, I would say so, yes.
21:46:23 <mauke> _Ray_: and you can't use "the IO monad" to handle it, only IO. which is my point.
21:46:33 <dolio> @src interact
21:46:34 <lambdabot> interact f = do s <- getContents; putStr (f s)
21:46:40 <shachaf> dolio: Implementation detail.
21:46:53 <mauke> '@src' isn't real anyway
21:46:54 <applicative> thats a post-monad-madness definition
21:47:02 <_Ray_> I'm afraid I do not get your point in distinguishing between IO and "the IO monad", unless by IO you mean the abstract practice of input and output in, say, a turing machine.
21:47:14 <_Ray_> Input and output, in Haskell, is mediated by the IO monad.
21:47:15 <mauke> _Ray_: no, by IO I mean the actual type defined in System.IO
21:47:19 <mauke> _Ray_: no.
21:47:27 <_Ray_> That type implements the monad interface.
21:47:27 <mauke> input and output is mediated by IO
21:47:32 * _Ray_ sighs.
21:47:37 <_Ray_> I am too easily trolled.
21:47:38 <mauke> _Ray_: that type implements the PrintfType interface
21:47:42 <mauke> which is irrelevant here
21:48:04 <_Ray_> I'm sorry, I do not feel there is anything for me to learn from this conversation.
21:48:26 <shachaf> _Ray_: One might say the same thing about mauke, given this conversation...
21:49:03 <applicative> mauke it is a massive drag that to say what you mean you have to say that IO is a type
21:49:12 <applicative> as if it had kind (* -> *)
21:49:34 <applicative> It should be called a functor, that's as minimal as we can get without being very confusing
21:49:45 <mauke> applicative: parse error
21:50:03 <_Ray_> failure in the automatic comma insertion algorithm.
21:50:11 <applicative> it seems nonsense to say " by IO I mean the actual type defined in System.IO"
21:50:17 <_Ray_> mauke, it is a massive drag that, to say what you mean, you have to say that IO is a type.
21:50:24 <mauke> applicative: s/type/type constructor/ ?
21:51:21 <applicative> type constructor is hopeless for several reasons, above that a constructor is an expression builder
21:51:50 <mauke> I'm having trouble parsing you
21:52:17 <applicative> there's no way out of calling IO "the IO (*->*)" or, better, the IO functor.
21:52:33 <mauke> why?
21:52:49 <applicative> the language of 'type constructors' is not pedagogically helpful.  It isn't a question of the 'correct expression' technically, which is devoid of interest
21:53:10 <applicative> a constructor is an expression, a word, a term
21:53:17 <mauke> yeah, I'm just going to stop here
21:53:23 <applicative> it is a certain number of letters long
21:53:27 <mauke> I'm not convinced you're making any sense
21:53:34 <dolio> Actually, "the IO monad" isn't that bad a name, from a certain perspective.
21:53:53 <applicative> it's a pedagogical catastrophe
21:55:13 <dolio> Because it's obviously the free monad generated by the same functor whose initial algebra one would use for the type of IO descriptions that one should actually be the type of main.
21:55:37 <dolio> -one
21:55:47 <jokar> hello all
21:56:05 <jokar> What is haskell? and what is good for?
21:56:13 <shachaf> jokar: The FAQ answers that a bit.
21:56:15 <shachaf> @where faq
21:56:15 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
21:56:51 <jokar> can you tell me,haskell is used for what?
21:56:58 <applicative> @faq
21:56:58 <lambdabot> The answer is: Yes! Haskell can do that.
21:57:28 <applicative> @faq can jokar do what he or she pleases with haskell?
21:57:28 <lambdabot> The answer is: Yes! Haskell can do that.
21:58:25 <jokar> i understand
21:58:28 <Axman6> jokar: anything you want
21:58:30 <shachaf> Haskell is good for monading.
21:58:33 <jokar> but
21:58:37 <shachaf> That's pretty much it, though.
21:59:02 <applicative> dolio, no doubt. I still find it an unending pedagical nightmare that there is no simple non falsifying word for thinks of kind (*->*) calling them types is extrememly confusing, calling them constructors is insane
21:59:04 <jokar> haskell is for low lovel programming like asm or high level
21:59:08 <jokar> ?
21:59:09 <applicative> things of kind....
21:59:14 <Axman6> it's particularly good at certain thing though, like writing compilers, easy concurrent and parallel programming, mathematical stuff
21:59:28 <dolio> They're type functions.
21:59:41 <jokar> for example PHP is for web,but what haskell for is it?
21:59:45 <Axman6> jokar: it's generally considered a high level programming language, but can also be used for low level programming quite easily
22:00:16 <applicative> dolio, well yes, i guess, functions in the type system, thats why we use an arrow in (*->*)
22:00:27 <jokar> Axman6: i know some programming language like ASM,Python,C,C++,Pascal
22:00:40 <jokar> and i want know haskell is used for what?
22:00:46 <mauke> jokar: what is C++ used for?
22:00:49 <jokar> is it special?
22:00:54 <applicative> jokar what is C used for?
22:01:02 <applicative> what is python used for?
22:01:02 <dolio> IO actually is a type constructor.
22:01:05 <applicative> haskell is the same
22:01:06 <jokar> C++ is used for many system programming
22:01:13 <luite> I'd say that haskell is a better web programming language than php
22:01:13 <dolio> Which is a special category of type function.
22:01:19 <applicative> A type constructor is a piece of language.
22:01:33 <dolio> I suppose Int counts as a type constructor, too.
22:01:34 <jokar> luite: it is used for web?
22:01:35 <dolio> 0-ary.
22:01:45 <applicative> IO types are types of action
22:01:46 <Axman6> jokar: it's used for everything, like C or C++
22:01:49 <Axman6> or Java
22:01:52 <_Ray_> applicative, why is calling them type constructors insane?
22:02:12 <applicative> _Ray_ because they are not words
22:02:16 <jokar> Axman6: ok,therefor it is a general purpose
22:02:24 <Axman6> yes
22:02:30 <dolio> They look like words to me.
22:02:33 <applicative> it is a 'use mention' confusion
22:02:38 <Axman6> but you probably wouldn't use it for a lot of the things you
22:02:41 <mauke> can anyone tell me if applicative is making sense or not?
22:02:43 <jokar>  Axman6: hacker can be useing haskell?
22:02:44 <san> hi, i'm new in haskell i just read it in an article and i'm curious bec. i've never heard of it.
22:02:48 <luite> jokar: yes, among other things, see this: http://blog.johantibell.com/2011/08/results-from-state-of-haskell-2011.html
22:02:52 <Axman6> you'd use C for (like lots of low level code)
22:03:07 <_Ray_> applicative, I don't understand what you mean by "they are not words". Both "type" and "constructor" are words.
22:03:12 <_Ray_> You could call them parametric types?
22:03:42 <jokar> thanks very much
22:03:49 <san> what makes haskell good about other programming languages.
22:04:03 <applicative> the think that has kind (*->*), viz IO, is not a word.
22:04:20 <Eduard_Munteanu> They're not plain type functions, as they don't really evaluate to some other type.
22:04:23 <applicative> the thing
22:04:40 <mauke> applicative: why do you think a type constructor is a piece of language?
22:05:09 <applicative> because data constructors are :)
22:05:12 <_Ray_> Eduard_Munteanu, you could say they don't evaluate to anything since they're not functions in the traditional, userspace sense of the word.
22:05:22 <mauke> applicative: I don't think they are
22:05:31 <applicative> the proof of this is that we do not simply identify isomorphic types when
22:05:39 <applicative> the constructors differ by spelling
22:05:39 <Eduard_Munteanu> e.g. in some languages you can define F :: * -> *, F _ = Int
22:05:51 <applicative> which entail exactly this:
22:05:58 <_Ray_> right, this is why they aren't functions in that sense
22:06:01 <applicative> CONSTRUCTOR CAN DIFFER BY SPELLING
22:06:10 <applicative> CONSTRUCTORS, rather
22:06:26 <_Ray_> I don't see why that disqualifies them as words?
22:06:33 <Eduard_Munteanu> Dunno about that :)
22:06:46 <mauke> applicative: and those words refer to different entities
22:07:01 <applicative> mauke right
22:07:08 <mauke> so spelling is irrelevant
22:07:40 <applicative> not if the entities are different because the words are different
22:07:57 <san> can you give me some known software that haskell was used as the language.
22:08:03 <mauke> applicative: but that's not the reason
22:08:09 <Axman6> san: Xmonad
22:08:14 <Axman6> san: the GHC Haskell compiler
22:08:20 <applicative> san, darcs?  the glasgow haskell compiler?  xmonad? pandoc ?
22:08:23 <Eduard_Munteanu> san: http://www.haskell.org/haskellwiki/Applications_and_libraries
22:08:30 <Axman6> also
22:08:32 <Axman6> @where hackage
22:08:33 <lambdabot> http://hackage.haskell.org/package/
22:09:37 <applicative> san ^^^ check it out
22:09:53 <applicative> it's a bit of a confusing heap, but it might give one an idea?
22:10:03 <geheimdienst> san: my opinion is that in haskell, it's hard to get a program to compile, but once it compiles, it rarely has many bugs in it anymore. in other languages, the compiler accepts lots of programs, but later (when you run them) you notice they're quite broken
22:10:37 <kmc> san, are you a newspaper reporter?
22:10:43 <kmc> san, http://haskell.org/haskellwiki/FAQ#The_real_world
22:11:35 <kmc> Haskell is mostly used for sophisticated internal tools at banks, biotech, hardware design companies, Facebook, Google, telecom, defense, intelligence agencies, ...
22:11:38 <kmc> http://haskell.org/haskellwiki/Haskell_in_industry
22:11:46 <kmc> it's not used much in consumer-visible software
22:12:33 <kmc> in the same way, you would never hear about Linux if you only look at what's running on your desktop
22:12:46 <san> kmc: no i'm not. :)
22:12:48 <kmc> even though it runs most web servers, embedded devices, etc
22:12:49 <shachaf> kmc: Untrue.
22:13:54 <kizzx2> kmc: unfortunately it seems like many devices now run Windows, most ATMs here run Windows (i've seen them reboot with the Windows logo)
22:14:00 <kizzx2> here <- Hong Kong
22:14:55 <applicative> awesome, the more Windows in the banks, the sooner they will all come crashing down....
22:14:56 <kmc> *nod*
22:15:00 <kmc> haha
22:15:16 <kmc> http://blogs.computerworld.com/london_stock_exchange_to_abandon_failed_windows_platform
22:16:12 <kmc> tl;dr: the London Stock Exchange's Windows-based trading platform crashed and took down the market for almost an entire day
22:16:30 <kmc> not just any day, but one of the most important days of the 2008 financial crisis
22:17:02 <applicative> there used to be a left wing view, a theory, 'military Keynsianism'  We were to side with extensive military spending, since maintained the economy and
22:17:11 <applicative> anyway, none of it works, so who cares
22:17:30 <applicative> this is my theory of evil programming languages and twisted operating systems
22:18:14 <applicative> we need to fill the banks, the military and menaces like reddit.com with as much C PHP etc as possible!
22:18:37 <kmc> haha
22:19:14 <kmc> sadly it seems all seriously high-frequency trading software must be written in C or C++
22:19:22 <psii> applicative:: you mean like in facebook?
22:19:31 <kmc> C++ may be the best language in this niche, but it's still terrible
22:20:10 <shachaf> <kmc> ... C or C++
22:20:29 <applicative> they use C++, why? because it's God's plan ... to bring them all to imcomprehensible total collapse.
22:20:36 <shachaf> kmc: Is there really no language nowadays that gives you sufficient control over memory and what not to replace C and C++?
22:21:00 <san> lua.
22:21:01 <psii> shachaf: ada <3
22:21:03 <_Ray_> You could have D, but C++ has more support and libraries.
22:21:44 <kmc> shachaf, none that's popular enough
22:21:49 <kizzx2> it's the performance, for serious raw speed C is still unmatched
22:22:06 <kmc> it's not just about throughput in this case, but latency
22:22:14 <kmc> these people live and die by microseconds
22:22:34 <shachaf> Isn't D garbage-collected?
22:22:42 <kmc> suspect so
22:22:43 <_Ray_> can be or can not be
22:23:09 <kmc> interesting replacement candidates: D, Felix, BitC, ATS, Habit
22:23:14 <kmc> but like i said, none of them are popular enough
22:23:33 <applicative> ATS is not interesting
22:23:42 <_Ray_> you could do assembly
22:23:48 <_Ray_> then again, you could also stick needles in your eyes
22:24:16 <dolio> C++ has assembly beat, as discussed.
22:24:22 <psii> Ada is extensively used in hard real-time software. mostly for embedded devices. Performance is like C, but it has a more sophisticated type system and many features for realtime and threading. if it would be more popular, then it would surely be a good candidate.
22:24:24 <applicative> indeed you could stick needles in your eyes.  it makes excellent work for the doctors, not that they need any.
22:24:32 <kizzx2> if we really need memory control, toy around with cache miss and assembly instructions, C++ probably isn't too badc
22:25:59 <kmc> yeah, a significant amount of inline assembly is involved
22:26:07 <kmc> psii, interesting
22:26:10 * applicative is not yet convinced that C++ is a language, properly speaking.  It is closer to a pair of pliers.
22:26:28 <kmc> look shachaf makes fun of me because i say this every day but: C++ is an esolang
22:26:57 <applicative> right, it's amazing, who would have thought you could type a pair of pliers?
22:28:29 <_Ray_> kmc: Define esolang.
22:28:30 <applicative> why doesnt anyone have a sensible elementary  error message from the ghc to interpret?  this is my real utility
22:29:26 <applicative> defined, can't kmc exhibit it with @bf ?
22:29:54 <applicative> meaning, why define it when you can exemplify it.
22:31:14 <psii> kmc: seems it is already used in financial software... http://www.adacore.com/home/ada_answers/lookwho
22:31:58 <kmc> cool
22:32:41 <applicative> psii, French finance!
22:38:50 * ivanm suspects that his attempt to translate Iteratee code to Enumerator code is doomed
22:39:39 * applicative is so far making little progress 'pimping his .haskeline' ...  now that he knows about the existence of the .haskeline file
22:40:03 <ivanm> heh
22:40:49 * kmc wonders if GHC will shit brix deriving 'Generic' for this 600-constructor enumeration type
22:41:18 <kmc> signs point to 'yes'
22:42:05 <applicative> can ghc compile a 600 constructor type? i mean without melting everything?
22:42:43 <kmc> haven't had serious problems other than 'deriving (Generic)'
22:43:26 <kmc> that one involves constructing a huge type expression
22:46:01 <kmc> and typechecking a function of that type
22:46:39 <dolio> I expect 600 constructors doesn't work very well.
22:47:25 <kmc> in general?
22:47:50 <kmc> it's for a disassembler
22:47:58 <kmc> i want to allow pattern-matching on opcodes
22:48:03 <kmc> so far it works fine
22:48:47 <dolio> I thought I'd heard of people having trouble with things that big.
22:48:52 <dolio> I can't recall with what exactly.
22:48:55 <kmc> ah, i'd be interested to know
22:49:29 <Eduard_Munteanu> Why pattern-match on the opcodes?
22:49:52 <kmc> cause... sometimes you care... which opcode an instruction has?
22:49:54 <Eduard_Munteanu> I mean, you only need to know the "kind" of the instruction to print it.
22:49:59 * kmc boggles
22:50:08 <kmc> it's not just for printing
22:50:22 <shachaf> If you define foo :: Word8 -> ..., and match on all 256 possibilities, GHC still gives you a warning, by the way.
22:50:37 <ivanm> kmc: how long does it take to compile?
22:50:54 <ivanm> shachaf: heh
22:51:07 <dolio> Oh that rings a bell.
22:51:08 <Eduard_Munteanu> You might want to use a Map along with an actual string for the name.
22:51:10 <ivanm> because 22959343 still returns a value on fromInteger?
22:51:13 <dolio> It might have been gigantic case statements.
22:51:29 <ivanm> > fromInteger 300 :: Word8
22:51:29 <lambdabot>   44
22:51:33 <kmc> Eduard_Munteanu, i'm not interested in reimplementing 'objdump'... the idea is to disassemble to an AST, to make code analysis easier
22:51:41 <kmc> Eduard_Munteanu, http://mainisusuallyafunction.blogspot.com/2011/03/x86-disassembly-in-haskell-with-hdis86.html
22:51:51 <Eduard_Munteanu> Ah.
22:51:59 <kmc> that has a small code analysis example
22:52:27 <kmc> i thought of representing opcodes as strings
22:52:31 <kmc> you could still pattern-match
22:52:43 * ivanm -> home
22:53:06 <shachaf> kmc: I like Hdis86.Internal.Opcode.
22:53:08 <kmc> but it's uglier; I'd rather do it the 'correct' way as long as there are not serious practical issues prevent that from working
22:53:21 <kmc> maybe i should re-enable the haddock docs for that module
22:53:32 <kmc> or make it actually not exposed
22:53:40 <shachaf> Oh, that's what was just discussed here.
22:53:56 <Eduard_Munteanu> kmc: with view patterns I guess you could avoid actual pattern-matching, if that's convenient for you.
22:54:25 <Eduard_Munteanu> So the actual matching algorithm could be anything.
22:55:33 <Eduard_Munteanu> It probably still is more verbose and uglier.
23:02:46 <kmc> so is unordered-containers the preferred alternative to hashmap now?
23:05:58 <lpsmith> out of curiousity,  is there a way to tie a particular GHC green thread to a particular OS thread?
23:06:20 <kmc> afaik not in general
23:06:26 <kmc> but forkOS will tie it for the purposes of FFI calls
23:06:32 <kmc> and may in practice do more than that
23:06:41 <frerich> kmc: Geez, you really do like hanging out in this channel, don't you? Shortly before I go to bed, I can see messages from you among the last twenty messages. After I got up -  messages from you again. In fact, I think I can maximize this IRC client at arbitrary moments - you'll be there. :-)
23:06:49 <kmc> the other way is to compile without -threaded :)
23:06:57 <kmc> frerich, yeah, maybe i should get a job or something
23:07:00 <kmc> but it's always better on holiday
23:07:19 <shachaf> kmc: If you spend too much time in #haskell, you'll get bored of it.
23:07:22 <shachaf> Just like peanut butter.
23:07:46 <kmc> "As a comedian, you have to start the show strong and you have to end the show strong. Those are the two key elements. You can't be like pancakes... all exciting at first, but then by the end you're fuckin' sick of em."
23:08:15 <_Ray_> clearly a failing pancake maker
23:09:05 <lpsmith> kmc: well, I don't have a concrete use case in mind, but the scenario I'm considered is that you have an app that has both a compute-bound component and calls out to some foreign IO libraries that call their own select/poll/epoll/kqueue
23:09:16 <luite> lpsmith: you can fix an action to a single OS thread with runInBoundThread
23:09:26 <luite> dunno if it's related to what you want
23:09:35 <kmc> it only fixes FFI calls
23:10:05 <lpsmith> So the question is,  how do you run those calls in the OS thread while keeping any CPU bound computations *out* of that OS thread
23:10:35 <kmc> the "bound thread" mechanism should suffice
23:10:44 <kmc> FFI calls don't block Haskell execution, anyway
23:10:49 <kmc> unless they're marked "unsafe"
23:11:27 <lpsmith> well,  a safe FFI call that blocks will block that OS thread, no?
23:11:43 <lpsmith> I mean, Haskell will keep going in other OS threads, I understand that.
23:12:37 <kmc> and Haskell threads that were scheduled on that OS thread will get rescheduled elsewhere
23:12:40 <kmc> is my understanding
23:12:46 <lpsmith> right
23:12:54 <kmc> in fact FFI can be done by dedicated FFI worker threads
23:12:58 <kmc> i don't recall if that's what GHC does
23:13:44 <frerich> Does it make sense to model game logic as one big chain of monadic values, instead of a set of pure functions which all take some 'Game' value and yield some new 'Game' value?
23:13:47 <lpsmith> but say I need 8 OS threads to do IO,  but only have a quad-core processor,  so I want 3 OS threads to handle my CPU-bound task so I don't use too many.
23:15:38 <lpsmith> so I guess my question is... does a bound thread also keep other threads out?
23:15:54 <lpsmith> if so, that would cover my scenario.
23:21:42 <lpsmith> See, reading the documentation it doesn't sound like it,  because the main function runs in a bound thread,  you wouldn't be able to use forkIO to do anything useful,  as they wouldn't have any place to go.   Of course,  the real solution is to integrate the library's use of epoll with GHC's thread manager.
23:21:52 <lpsmith> But I'm curious about work-arounds.
23:27:45 * applicative notes that DeriveFunctor can handle a seven hundred constructor type.
23:31:38 <kmc> cool
23:39:14 <tcrayford> testing
23:39:27 <tcrayford> well, that seems to work (new irc client)
23:40:46 <kevea> Any good processors you use for compiling in haskell?
23:41:20 <luite> I've tried a few but they all give me the same type errors :(
23:42:04 <kevea> kevea: what kind have you used?
23:42:15 <kmc> o_O
23:42:32 <kevea> as in i7, phenom II etc.
23:42:58 <kevea> or basically, what processor do you use and compile Haskell with and how does it fair?
23:43:33 <companion_cube> i heard the brand new crays are pretty good
23:43:42 <tcrayford> the processor shouldn't matter dude
23:44:09 <kmc> my CPU is a neural net processor
23:44:13 <kmc> a learning computer
23:44:31 <kevea> I'm thinking of getting an i7 because they're the best, but is it really worth the money for the compile time?
23:44:47 <kevea> companion_cube: as in the cray supercompyunter...?
23:44:56 <tcrayford> I have an i7, but I tend to write really tiny haskell programs (so compile times don't matter so much)
23:45:23 <tcrayford> it's only 1.8ghz as well, but I really never notice compile times (but again, small programs)
23:45:33 <kmc> i've no reason to believe GHC performance varies differently from general performance measures
23:45:37 <kmc> if you're restricting to x86 chips
23:45:59 <kmc> running a 64-bit OS on a 64-bit chip may matter a bit more for GHC-compiled code, including GHC itself
23:46:10 <kevea> tcrayford: 1.8ghz? Is it a mobile i7?
23:46:11 <companion_cube> kevea: yep :]
23:46:16 <tcrayford> kevea: yep
23:47:02 <kevea> companion_cube: I'm won't be getting a supercomputer as I'm a student
23:47:22 <companion_cube> oh that's too bad :)
23:47:38 <kevea> companion_cube: so what do you compile Haskell on?
23:47:50 <luite> tcrayford: macbook air?
23:48:23 <companion_cube> well, a mobile core 2 duo :D
23:48:33 <companion_cube> (when i happen to write haskell)
23:48:48 <kevea> luite: there is more mobile system that use i7 than macbook air
23:49:00 <kevea> companion_cube: I would prefer cray
23:49:03 <tcrayford> luite is correct though
23:49:38 <luite> kevea: I know, but I'm using statistical data from the past to make my predictions :p
23:50:09 <kevea> luite: could you provide that data on request?
23:50:12 <luite> and the 1.8 GHz i7 is the fastest cpu in the new macbook air models
23:51:37 <luite> kevea: look at pictures from hac phi for example, or camhac, and see which laptops are popular among haskellers :)
23:52:13 <kevea> luite: I'm not even interested in laptops!
23:53:03 <kevea> anyway, what processors do you guys use to compile haskell in and how do you rate it?
23:53:25 <tcrayford> kevea: do you have a huge project to compile?
23:53:35 <luite> dunno, I have a E8400 and an i7 950, the latter is faster, nothing surprising there....
23:54:07 <kevea> tcrayford: no
23:54:32 <tcrayford> so maybe saying 'compile' is misleading
23:54:38 <kevea> luite: have you measured/graphed compile times?
23:54:51 <kevea> tcrayford: why is that?
23:55:04 <tcrayford> are you worried about compile times then?
23:55:13 <luite> no, since that doesn't help anyway ;)
23:55:28 <kevea> tcrayford: yes
23:55:41 <tcrayford> ah, that had me confused then :) nvm
23:57:41 <edwardk> i have to admit I'm rather fond of the macbook air
23:58:35 <edwardk> even carrying both it and the ipad is much lighter than my old macbook pro
23:58:57 <edwardk> and compile times aren't much worse
23:59:27 <kevea> edwardk: I'd very much like a macbook air like everyone else, but the price is a major distuple for me
23:59:31 <edwardk> they make up a relatively insignificant portion of my haskell programming time anyways
23:59:42 <luite> the difference will be greater when ghc supports parallel compiling
