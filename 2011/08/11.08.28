01:07:21 <luite> nominolo: I'm trying out scion with the emacs client, but with scion-load it asks for a component in the minibuffer. when I enter something, or just press enter, it gives me a new line. how does this work?
01:16:23 <luite> hmm, now my emacs stuff is has crashed
01:24:51 <GlenK> hi.  I'm finding this amazingly complicated seeming.  I have an int I want to pass to a function that takes strings.  how do I easily convert it?
01:25:04 <Lemmih> > show 10
01:25:05 <lambdabot>   "10"
01:25:15 <GlenK> thank you
01:33:07 <ddarius> @hoogle Int -> String
01:33:07 <lambdabot> Prelude show :: Show a => a -> String
01:33:08 <lambdabot> Text.Show show :: Show a => a -> String
01:33:08 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
01:34:48 <kish> prelude!
02:32:34 <rostayob> > generalCategory ₁
02:32:34 <lambdabot>   <no location info>: lexical error at character '\8321'
02:32:38 <rostayob> > generalCategory '₁'
02:32:38 <lambdabot>   OtherNumber
02:33:02 <rostayob> > generalCategory '₊'
02:33:03 <lambdabot>   MathSymbol
02:50:28 <aristid> > generalCategory '+'
02:50:29 <lambdabot>   MathSymbol
02:50:54 <aristid> > map ord ['₊', '+']
02:50:55 <lambdabot>   [8330,43]
02:52:02 <augustss> @src (&&)
02:52:03 <lambdabot> True  && x = x
02:52:03 <lambdabot> False && _ = False
02:53:41 <geheimdienst> :t (&&)
02:53:41 <lambdabot> Bool -> Bool -> Bool
02:58:45 --- mode: leguin.freenode.net set +o ChanServ
03:02:54 <DonaldDuck> hello. what are the pros/cons of haskell as compared to q/k (of kdb+)?
03:04:12 <Saizan> what is q/k ?
03:05:29 <DonaldDuck> the proprietary language (mostly functional) of this database http://www.kx.com/
03:08:44 <ville> For one Haskell sounds more generic and thus applicable to more sittuations so learning it seems like a better deal.
03:09:57 <DonaldDuck> fair enough. The context is that I"m using q a lot on a daily basis and I'm wondering if Haskell has anything to offer as a complement.
03:16:44 <DonaldDuck> is haskell good at handling large amounts of data? I tried R, which isn't, so I wonder if haskell is better suited.
03:17:20 <ddarius> DonaldDuck: Haskell is a general purpose language.
03:18:26 <DonaldDuck> ok. thanks
03:26:19 <DonaldDuck> How does Haskell compare to the J programming language: http://www.jsoftware.com/ ?
03:27:04 <ddarius> The compare unequal for equality.
03:27:54 <nlogax> > compare "Haskell" "J"
03:27:56 <lambdabot>   LT
03:28:54 <confab> time to switch to J?
03:29:03 <ddarius> J is fun.
03:30:47 <DonaldDuck> Are they complementary?
03:31:17 <ddarius> DonaldDuck: Do you know J or Haskell?
03:31:37 <DonaldDuck> Neither, but I'm open to trying either.
03:32:04 <ddarius> DonaldDuck: Then how does it matter if they are complementary or not?
03:32:33 <DonaldDuck> Mostly trying to get a better understanding of your replies...
03:33:19 <ddarius> Why do you care what my replies are?  What are your goals then maybe people can tell you whether Haskell is a suitable language for you and/or steer you to a more suitable language.
03:33:23 <Spockz> I'm having an issue with classes/instances and lists I want to try the following but I get stuck on lists :) https://gist.github.com/1481f4a5de47c1e6fa76
03:34:29 * RayNbow is trying to get hmatrix-glpk working under Windows... (currently battling missing DLL errors)
03:37:22 <DonaldDuck> ddarius: good point. (however, I do care about understanding your answers, otherwise what's the point of asking). Goals: an efficient language which handles large amount of data (scales well) and is very expressive (does a lot for the amount of code you type), and ideally has some libraries for statistical stuff for instance.
03:38:40 <rajeshsr> i was going through SICP and was reading Streams and came across this interesting example: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-24.html#%_sec_3.5.5 I know it's a old text. Guess we have solved the "merge problem" in FP world. Anyone like to throw some light?
03:39:52 <nlogax> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:statistics might be of interest, DonaldDuck
03:40:35 <DonaldDuck> thanks nlogax!
03:41:11 <ddarius> DonaldDuck: Then Haskell is capable of meeting those needs except the statistics libraries may or may not be adequate depending on your needs.  If they are not, you can likely bind to a, C say, statistics library to make up the difference.
03:41:39 <DonaldDuck> cool, thanks ddarius!
03:41:54 <cari_veri_epdsk> hello guys. Im new to haskell and my .hs dont find any imports. what can I do?
03:42:26 <ddarius> J is probably(?) better for statistics calculations, particularly out-of-the-box, but I'm not sure how J does with large data.  I'd think there'd be a way to back an array directly against a file which would allow that.
03:42:38 <ddarius> But I'm just guessing about that last part.
03:43:15 <DonaldDuck> thanks
03:45:06 <cari_veri_epdsk> please. I need help on importing packages to a .hs.
03:46:06 <ddarius> J is somewhat more "special-purpose" than Haskell, so Haskell knowledge would be more widely useful for other general programming tasks.
03:46:22 <kmc> cari_veri_epdsk, put your code on hpaste.org
03:46:28 <DonaldDuck> I see.
03:47:25 <ddarius> DonaldDuck: If you have fairly sophisticated statistics needs, then searching for languages geared toward statistics or with strong statistics libraries may be sensible.  The obvious choice there is R or S, but apparently those fail to meet your other criteria.
03:48:27 <DonaldDuck> Yes. Thanks.
03:50:45 <kmc> @arr
03:50:45 <lambdabot> Aye Aye Cap'n
03:52:37 <cari_veri_epdsk> kmc: I need to know how it works. in general when I import a packages by "import <packagename>" where does it have to be installed? I tried "cabal install X11" in terminal e.g.
03:53:55 <Jafet> cabal-install installs packages to either the global package directory, or your user package directory
03:54:04 <Jafet> You can list both with ghc-pkg list
03:54:11 <fryguybob> cari_veri_epdsk: You don't "import <packagename>".  You "import <modulename>"
03:54:48 <fryguybob> The package X11 contains the module Graphics.X11 (among others).
03:54:55 <cari_veri_epdsk> jafet: how ouwld the IDE or editor find those package directories?
03:55:13 <kmc> why would the IDE or editor find them?
03:56:08 <Jafet> Editor? What editor?
03:56:14 <ddarius> kmc has failed to stay the course.
03:56:25 <kmc> oh yeah?
03:56:26 <kmc> @arr
03:56:27 <lambdabot> Avast!
03:56:38 <ddarius> kmc: Your initial response was the correct route to go.
03:56:51 <cari_veri_epdsk> kmc: well the IDE leksah e.g. tells me it cannot find the module Graphics.X11.Xlib.
03:56:53 <ddarius> Nothing clears up ambiguity like compiler input and output.
03:57:16 <cari_veri_epdsk> alternatively I edit in vim. if I could compile it from temrinal it owudl be ok too.
03:58:05 <Jafet> Yeah, computers are good at deterministically mapping garbage to garbage.
03:59:12 <Jafet> ~ Babbage's retort
03:59:17 <kmc> hmm, http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/release-7-2-1.html mentions "new pragmas VECTORISE, VECTORISE_SCALAR and NOVECTORISE for controlling the behaviour of the vectoriser."
03:59:26 <kmc> but nothing about them here: http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/pragmas.html
03:59:37 <Jafet> Vectoriser? What vectoriser?
03:59:43 <ddarius> Jafet: For DPH.
03:59:46 <kmc> DPH, i think
03:59:51 <Saizan> cari_veri_epdsk: use ghc or ghci from terminal
03:59:53 <kmc> i found http://hackage.haskell.org/trac/ghc/wiki/DataParallel/VectPragma
03:59:57 <Jafet> Oh, shame
04:00:53 <ddarius> kmc: They probably just failed to update the manual.  You should be able to email someone about it.
04:01:02 <kmc> meh
04:01:23 <kmc> DPH is already undocumented in the manual
04:02:05 <ddarius> Sooner or later it will be documented.  By which I mean sooner or later it will be "ready."
04:04:14 <cari_veri_epdsk> Saizan: ghc -i X11directory myprog.hs , like this?
04:04:51 <Saizan> cari_veri_epdsk: no, if the X11 package is installed correctly ghc will find it automatically
04:05:15 <Saizan> you can check if it is by ghc-pkg list
04:06:04 <Saizan> cari_veri_epdsk: btw, you might need "ghc --make myprog.hs"
04:07:38 <cari_veri_epdsk> Saizan:  it worked . funnily leksah does not find the imports and I dont know why.
04:08:10 <Saizan> cari_veri_epdsk: try restarting it, or its ghci session
04:09:05 <jutaro>  cari_veri_epdsk: The metadata uses haddock, which fails on some modules, so don't trust it completely
04:19:45 <cari_veri_epdsk> Saizan, jutaro : I can set paths to look for libraries in leksah, maybe that helps me here?
04:20:03 <cari_veri_epdsk> I just dont know which path to specify.
04:21:19 <jutaro> cari_veri_epdsk: You have the package in the cabal file?
04:21:33 <jutaro> or is it just a problem with metadata?
04:25:56 <cari_veri_epdsk> lol. seems to have something to do with user scopes. in root mode I run leksah. in user mode I successfully compiled my.hs. root# compile did not work! :)
04:27:22 <jutaro>  cari_veri_epdsk: leksah does a cabal build for compilation. So you can try this from the command line
04:29:12 <cari_veri_epdsk> There wy I see it, I should have leksah installed with my user instead of root or tell it where to look for modules.
04:31:48 <cari_veri_epdsk> but in anyway, I have come one step further. I need to go now for a while. but ill come back. thank you very much so far !
04:54:49 <hpaste> jkramer pasted “Conflicting definitions” at http://hpaste.org/50731
04:55:06 <jkramer> Can someone please help me with this? I don't understand what's wrong :(
05:00:13 <kmc> jkramer, which lines are 75 and 78
05:00:21 <kmc> oh,o you commented it
05:00:38 <jkramer> :)
05:00:57 <kmc> capitalization
05:01:01 <kmc> updateSession vs updatesession
05:01:10 <koeien1> updateSession is not always capitalized
05:01:15 <Axman6> also, the types can't possibly match can they?
05:01:18 <kmc> the equations for a given function must always be contiguous
05:01:30 <Axman6> ah, maybe they can
05:01:43 <Axman6> guessing boolean :: String -> Bool?
05:01:54 <jkramer> Oh, damn me, so stupid :)
05:01:58 <koeien1> s/guessing/inferring ;)
05:02:05 <jkramer> Works fine with proper capitalization :)
05:03:47 <Axman6> jkramer: you should be using an editor that can complete knows words for you, so you type up<tab> or up<esc> in my case and it'll start cycling words that begin with that prefix
05:03:57 <Axman6> sames a lot of time and errors
05:04:21 <jkramer> Yeah, I already do, I have no idea how that happened :)
05:12:22 <koeien1> Axman6: seems useful. is that emacs?
05:12:43 <Axman6> any decent editor can do it. in my case i use textmate
05:21:45 <nschoe> Hi all, I'm trying to understand a bit more Monads Transformers, and I'm having troubles understanding the 'lift' function, particularly in this example: http://en.wikibooks.org/wiki/Haskell/Monad_transformers#Application_to_Password_Example
05:23:24 <nschoe> If I'm correct, getLine has type IO String, so lift getLine has type Maybe IO String. But I don't understand how come 's' has type String when they do: s <- lift getLine. Can someone explain this to me please?
05:23:55 <Axman6> you mean MaybeT IO String?
05:24:09 <koeien1> lift :: m a -> t m a
05:24:24 <koeien1> in our case, lift :: IO String -> MaybeT IO String
05:24:56 <koeien1> so the purpose of lift is to execute actions in the wrapped monad to the "higher" monad
05:25:16 <Axman6> and when you're in the MaybeT IO a monad, and write do {...; x <- y; ...} then if y has type MaybeT IO a then x has type a
05:25:45 <koeien1> yes, for every monad m,  (MaybeT m) is a monad.
05:26:07 <nschoe> Okay, so '<- ' doesn't remove "one wrapper" only?
05:26:22 <kmc> correct
05:26:29 <koeien1> no. Then you're thinking of Maybe (IO String) or something of that sort
05:26:35 <nschoe> I thought that if y had type MaybeT IO a then x would be of type IO a.
05:26:38 <rostayob> How does quickcheck generate values for the functions to test?
05:26:46 <kmc> rostayob, the Arbitrary type class
05:26:46 <koeien1> rostayob: using the Arbitrary typeclass
05:27:01 <ddarius> nschoe: Match the type of (>>=) to the types you are using.
05:27:08 <rostayob> Ok there's arbitrary, but how does it call the function with the correct number of args
05:27:13 <kmc> nschoe, (MaybeT IO) is a monad.  a single one
05:27:23 <kmc> rostayob, there's some other type class
05:27:33 <kmc> :t quickCheck
05:27:34 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
05:27:45 <Axman6> rostayob: there's probably a typeclass that lets it work
05:27:47 <nschoe> kmc, okay that is why "<-" gives back a value of type a
05:27:47 <kmc> instance (Arbitrary a, Testable b) => Testable (a -> b)
05:27:48 <kmc> or something
05:27:51 <kmc> yeah
05:27:56 <koeien1> nschoe: yes
05:28:00 <kmc> though <- isn't really an ordinary operator
05:28:08 <kmc> it desugars to the operator (>>=)
05:28:14 <Axman6> nschoe: because if it didn't, it wouldn't be very useful :)
05:28:20 <kmc> (>>=) :: M a -> (a -> M b) -> M b
05:28:25 <kmc> here M = MaybeT IO
05:28:30 <nschoe> Okay okay, thanks.
05:28:43 <kmc> partial application for type constructors works basically the same way as for functions
05:28:52 <rostayob> kmc, Axman6: thanks, I'll took into that. I want to do somethins similar, generating values for functions, but with a different aim
05:29:07 <nschoe> So, in askPassword from the wiki example, when they write: ... = do ... Inside the do block, in which Monad are we in?
05:29:11 <kmc> MaybeT IO a -> (a -> MaybeT IO b) -> MaybeT IO b
05:29:27 <koeien1> MaybeT IO is the monad.
05:29:39 <kmc> nschoe, just desugar the "do" and figure out what type (>>=) is used at
05:29:50 <nschoe> kmc, okay, I'll do that.
05:30:03 <hpc> nschoe: MaybeT IO a isn't the same as MaybeT (IO a), but it is the same as (MaybeT IO) a
05:30:06 <hpc> if that helps
05:30:16 <kmc> hmm, is it ever possible for two (>>=)s from the same "do" to instantiate to different monads?
05:30:17 <nschoe> koeien1, okay, so what "lift" does is bring the "getLine" function from the IO monad to the MaybeT IO moand, right?
05:30:30 <hpc> kmc: no
05:30:32 <koeien1> kmc: no.
05:30:37 <koeien1> kmc: but you could nest it somehow
05:30:44 <koeien1> nschoe: yes
05:30:49 <hpc> kmc: you would have to do blah; blah; newMonad $ do ...
05:31:00 <nschoe> koeien1, okay, thx.
05:31:30 <nschoe> Well, thank you all for your help, I'll desugar the (>>=) just to be sure I got it, but I think I'm okay now, thanks!
05:32:50 <ddarius> kmc: Just throw in some unsafeCoerce.
05:33:20 <ddarius> Oh man, I really need to find an example that works and does something "reasonable" now.
05:36:11 <kmc> i suspected not, but didn't prove it
05:36:31 <kmc> ddarius, Reader and ((->) e) is a fairly boring one
05:38:45 <ddarius> Unfortunately, there's no good place to stick the unsafeCoerce (other than in a no-implicit-prelude (>>=)) that wouldn't be like using lift.
06:46:09 <RayNbow> yay... finally managed to install hmatrix-glpk
06:46:37 <jkramer> Has anyone made use of http://hackage.haskell.org/packages/archive/xml-enumerator/0.3.4/doc/html/Text-XML-Enumerator-Parse.html yet?
06:47:06 <jkramer> It looks like a very nice and clean way to parse XML, but it lacks some more sophisticated examples
06:49:04 <jkramer> For example, how would I parse this: <person>-name_Michael</name><age>25</age></person> (based on the example)
06:49:24 <jkramer> Should be <name>
06:52:59 <ddarius> jkramer: You would presumably just use tagName again where it uses content in the example.
06:53:15 <ddarius> And ignoreAttrs instead of requireAttr
06:54:07 <jkramer> Makes sense I guess, I'll try :)
06:56:25 <joe6> how to load a shared library into ghci: http://codepad.org/GdGlG7XY
06:56:40 <joe6> don't bother
06:56:47 <joe6> i think I figured it out.
07:05:55 <joe6> test.c: http://codepad.org/iTJDguLp, test.h: http://codepad.org/2mVPLAmd, test.gld: http://codepad.org/ug7E0psM, .hsc file: http://codepad.org/OHfw85QT, build log: http://codepad.org/98151hvW
07:06:00 <joe6> ghci error: http://codepad.org/7X2BZaDz
07:06:53 <joe6> this is the ghci error, <interactive>: /home/j/.cabal/lib/bindings-snsrusb-0.0.4/ghc-7.0.4/HSbindings-snsrusb-0.0.4.o: unknown symbol `test'
07:07:07 <joe6> when I build the library as a shared library.
07:07:13 <joe6> any suggestions, please?
07:08:19 <dylukes> Can you mix Alex/Happy files?
07:08:36 <dylukes> Into the same file?
07:08:44 <dylukes> It would be silly to do so... but just curious if they overlap at all...
07:24:25 <accel> http://hackage.haskell.org/trac/ghc/wiki/ObjectiveC <-- has this actually achieved anything in terms of usable code?
07:34:49 <joe6> has anyone used a shared library with bindings-DSL?
07:39:46 <kmc> it makes me sad how many Haskell libraries use Int for numbers that have to be non-negative
07:39:51 <kmc> repeating the mistakes of the past...
07:40:02 <kmc> however, I do the same in my code, for compatibility and because I'm lazy
07:40:22 <confab> what should they use?
07:40:40 <jkramer> How would I use the parseBytes function when I only have a ByteString containing XML? http://hackage.haskell.org/packages/archive/xml-enumerator/0.3.4/doc/html/Text-XML-Enumerator-Parse.html#v:parseBytes
07:40:56 <u_> is sortWith stable?
07:41:38 <u_> yep
07:43:21 <ClaudiusMaximus> my compiler that i wrote wasn't behaving right, so i replaced a few type ... = Int  with newtype in case i made a mistake there.  in the end removing -ffast-math from the g++ command line magically made the binary work properly :/
07:57:38 <kmc> ClaudiusMaximus, :(
07:58:06 <kmc> do you have an explanation for why this is possible?
07:58:13 <kmc> also, why is g++ involved? are you compiling to c++?
07:58:36 <ClaudiusMaximus> kmc: i'm compiling to macro-heavy C++ - it's a dirty dirty hack to get something up and running quickly
07:59:45 <kmc> fun
08:00:00 <kmc> i've written a few Haskell programs that output C++
08:00:16 <zachk1> really?
08:00:20 <kmc> yes
08:00:23 <kmc> also a Python program that produced C++
08:00:46 <kmc> when I asked in #python which templating engine would be best for C++ code, they looked at me like i was a nine-eyed space alien from beyond pluto
08:00:53 <kmc> then they told me i was dumb for wanting to do that
08:01:41 <ClaudiusMaximus> heh, i'm using Monoid (String, String, String)   for bits of struct, initialisation code and main loop code
08:01:46 <kmc> haha
08:03:12 <kmc> in #python if you want to do something strange they assume you're a stupid noob
08:03:27 <kmc> rather than someone with complex well-justified design decisions that lead down this path
08:03:45 <kmc> it's much like me assuming that the answer to each type class question in #haskell is "don't use type classes"
08:04:23 <confab> #python is quite frustrating
08:04:28 <confab> for mnay reasons
08:05:40 <ClaudiusMaximus> the haskell portion of this project is 300 lines long, all in one file, and the only use of comments is to say "-- FIXME" :(
08:05:50 <kmc> haha
08:06:00 <kmc> i wonder how many FIXME's i've added in my life, and how many i've fixed
08:06:33 <kmc> i've seen a bunch of Linux security holes where they had a comment to the effect of "FIXME: buffer overflow"
08:06:39 <kmc> which sat there for years
08:06:56 <kmc> before anyone got around to fixing it
08:08:17 <Trusejens> @help
08:08:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:08:52 <ClaudiusMaximus> i have to go now, but if you're curious the code is at https://gitorious.org/maximus/tilde/trees/master with some example output at http://claudiusmaximus.goto10.org/code/tilde/tilde-examples-0.1.tgz
08:09:58 <kmc> cool ClaudiusMaximus
08:12:43 <cmccann> hm, seems a bit windy today
08:16:14 <zhulikas> @src negate
08:16:14 <lambdabot> negate x = 0 - x
08:22:17 * hackagebot hdis86 0.2 - Interface to the udis86 disassembler for x86 and x86-64 / AMD64  http://hackage.haskell.org/package/hdis86-0.2 (KeeganMcAllister)
08:22:42 * edwardk waves hello.
08:22:47 <kmc> hi edwardk!
08:22:49 <kmc> keeping dry?
08:22:53 <edwardk> preflex: xseen dcoutts
08:22:53 <preflex>  dcoutts was last seen on freenode/#ghc 2 days, 2 hours, 50 minutes and 54 seconds ago, saying: what mirror?
08:23:00 <edwardk> yeah
08:23:24 <edwardk> yesterday i kinda soaked through wandering around with pumpkin and cmccann
08:23:36 <edwardk> today i'm not feeling so ambitious
08:23:49 <cmccann> it wasn't that much rain.
08:23:53 <accel> is there something like a minimal linux diestro that supports haskell?
08:23:58 <accel> err, s/haskell/ghc
08:23:58 <cmccann> you even had an umbrella!
08:24:09 <kmc> @tell copumpkin http://hackage.haskell.org/package/hdis86-0.2
08:24:09 <lambdabot> Consider it noted.
08:24:18 <edwardk> it wasn't much rain, just spread over a long amount of time
08:24:32 <kmc> accel, Arch is supposed to have good Haskell support
08:24:35 <cmccann> yeah, that's the part that did get tiresome.
08:24:44 <kmc> and i'm told the minimal install of Arch is pretty small
08:24:46 <kmc> why do you ask?
08:26:01 <cmccann> was a nice walk otherwise, though. hadn't really had the chance to stretch my legs for a while. :]
08:26:25 <accel> kmc: beaus I need to run haskell inside of a linux vm on my osx
08:26:54 <cmccann> not many good places to walk in Grand Rapids. neither urban nor rural enough I guess.
08:27:06 <kmc> the base install of Debian is also pretty small
08:27:19 <accel> good call
08:27:25 <accel> I can't believe I forgot debian
08:28:02 <edwardk> If you want to get out of your hotel let me know. Amy suggested setting up a table in the living room for hacking on code and ordering pizza.
08:29:43 <copumpkin> omgwtfhax
08:29:43 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
08:29:50 <djahandarie> sup
08:29:59 <copumpkin> kmc: w00t
08:30:00 <edwardk> a mini-hac-bos ;)
08:30:48 <djahandarie> I'll walk up there
08:31:07 <edwardk> djahandarie: sounds like quite a walk
08:31:11 <djahandarie> Be there in a few.
08:31:13 <djahandarie> Few hours.
08:31:15 <djahandarie> Might be dead.
08:31:16 <edwardk> hope you have your galoshes
08:32:30 <copumpkin> I gotta say
08:32:33 <copumpkin> this weather is pretty tame
08:32:41 <cmccann> looks like more wind than rain still.
08:32:48 <djahandarie> I don't understand how my power is still up
08:32:59 <copumpkin> omg it's a bogiebro
08:33:05 <edwardk> heya bogiebro
08:33:06 <cmccann> anyway, I'm going to make some crappy complementary hotel room coffee first, then see how much I feel like going outside.
08:33:20 <copumpkin> cmccann: we can show you the sights around boston!
08:33:27 <copumpkin> perfect new england weather
08:33:35 <copumpkin> the sights as they were meant to be seen
08:33:42 <hpc> copumpkin: beneath a hurricane?
08:33:49 <copumpkin> yeah
08:33:55 <copumpkin> except it's a pretty weak hurricane
08:34:28 <zhulikas> why does fold function requires accumulator parameter?
08:34:41 <zhulikas> I know it uses it internally, but why would it be exposed to programmer?
08:34:56 <glguy> zhulikas: if you didn't provide it , how would it know which to use?
08:35:07 <zhulikas> can't it make something like fold step list = fold' step 0 list where fold' has real implementation
08:35:26 <cmccann> copumpkin: well, it's not a hurricane.
08:35:33 <glguy> :t \ f xs -> foldl f 0 xs
08:35:34 <lambdabot> forall a b. (Num a) => (a -> b -> a) -> [b] -> a
08:35:43 <glguy> zhulikas: See, this fold would only be suitable for numbers
08:35:48 <glguy> and folds which started with 0
08:35:54 <benmachine> zhulikas: it's the 0 which is the problem; different fold operations have different zeros
08:35:57 <zhulikas> well yes
08:36:02 <benmachine> and sometimes you don't want a zero there at all but something else
08:36:12 <zhulikas> can anyone give me an example where zero will be different?
08:36:14 <benmachine> as in xs ++ ys = foldr (:) ys xs
08:36:23 <glguy> zhulikas: there are also foldl1 and foldr1
08:36:29 <glguy> :t (foldl1, foldr1)
08:36:30 <lambdabot> forall a a1. ((a -> a -> a) -> [a] -> a, (a1 -> a1 -> a1) -> [a1] -> a1)
08:36:39 <glguy> But these don't work on empty lists
08:36:42 <benmachine> right
08:36:54 <edwardk> cmccann: sounds good. let me know if you want to escape
08:36:59 <benmachine> if you want to have a function returning 'b' that works on an empty list, you have to provide a value of type 'b'
08:37:06 <kmc> zhulikas, product = foldr (*) 1
08:37:12 <kmc> concat = foldr (++) []
08:37:14 <benmachine> because fold can't possibly produce a value of a type it knows nothing about it
08:37:17 <benmachine> -it
08:37:48 <hpc> zhulikas: suppose you had a list l = x:y:z:[]
08:37:51 <benmachine> I don't know if I'd describe the parameter in foldr as an accumulator though
08:37:54 <benmachine> foldl, maybe
08:38:13 <hpc> zhulikas: and you wanted to do fold (<+>) n l
08:38:28 <zhulikas> :t (<+>)
08:38:28 <lambdabot>     Ambiguous occurrence `<+>'
08:38:28 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
08:38:28 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:54:0-46
08:38:35 <hpc> zhulikas: the result would "look the same" as l, only with (:) replaced with (<+>) and [] replaced with n
08:38:38 <benmachine> (in which case product = foldl (*) 1 is an equally good example, as is reverse = foldl (flip (:)) []
08:38:42 <benmachine> )
08:38:46 <hpc> x <+> y <+> z <+> n
08:39:11 <kmc> > foldr f z (a : b : c : [])
08:39:12 <lambdabot>   f a (f b (f c z))
08:39:19 <kmc> each (:) becomes f, and [] becomes z
08:39:20 <hpc> zhulikas: a right fold will look like x <+> (y <+> (z <+> n))
08:39:40 <hpc> zhulikas: a left fold will look like ((x <+> y) <+> z) <+> n
08:39:50 <hpc> make sense?
08:40:10 <benmachine> zhulikas: part of your problem is that you asked about a "fold function" when in fact there are at least two such functions :)
08:40:10 <zhulikas> kind of
08:40:44 <kmc> if your definition of fold has 0 baked in, then it's only good for lists of numbers
08:41:07 <kmc> the generic foldl / foldr work for anything you can put in a list
08:41:21 <kmc> there's a precise sense in which a list is equivalent to its foldr
08:41:24 <edwardk> and what happens whan you want to fold to take a product?
08:41:28 <edwardk> you want 'zero' to be 1
08:42:22 <zhulikas> ok, explains much about this acc :)
08:44:58 <cmccann> in general, you want "zero" to be an identity value for the accumulating function
08:45:47 <hpc> this might be a good point for you to look up the Monoid type class, btw
08:45:52 <benmachine> in general but not necessarily, cmccann
08:45:54 <benmachine> cf. (++)
08:46:52 <parcs> is there a terse way to create a function ([a] -> a) -> (Maybe [a] -> Maybe a)
08:46:55 <cmccann> in the context of wanting a fold that doesn't need an explicit seed value, I'm not sure when anything other than an identity element would make sense
08:47:07 <parcs> err, [Maybe a] -> Maybe a
08:47:23 <hpc> :t catMaybes
08:47:24 <lambdabot> forall a. [Maybe a] -> [a]
08:47:26 <zhulikas> ok, it's clear why fold functions need zero :)
08:47:27 <zhulikas> thank you
08:47:29 <hpc> er
08:47:36 <hpc> parcs: what do you want it to do?
08:47:47 <kmc> cmccann, or foldr1 / foldl1
08:47:57 <hpc> parcs: a trivially terse definition would be head :P
08:48:28 <cmccann> kmc, those are the ones that generate runtime errors if used on an empty list, right?
08:48:32 <kmc> yeah
08:48:35 * cmccann frowns
08:48:40 <kmc> parcs, fmap would do the first one
08:49:18 <hpc> cmccann: if you don't mind a class context, foldrm1 f l = foldr f mempty l
08:49:50 <cmccann> hpc, yeah, that's fine.
08:49:58 <cmccann> I just don't like needlessly partial functions.
08:50:20 <hpc> @src mconcat
08:50:21 <lambdabot> Source not found. :(
08:50:33 <kmc> anyone have an example of footnotes / citations in .cabal description field?
08:50:42 <cmccann> on the other hand, with a monoid constraint anyway, why not just skip straight to foldr mappend mempty and be done with it
08:50:55 <cmccann> note the "fold" function in Data.Foldable
08:51:15 <joe6> is it possible to access how ghci loads an object file?
08:51:17 <kmc> that's msum isn't it
08:51:24 <kmc> er, mconcat?
08:51:25 <kmc> :t mconcat
08:51:26 <lambdabot> forall a. (Monoid a) => [a] -> a
08:51:33 <joe6> i want some addresses allocated before ghci loads an object file.
08:51:43 <hpc> cmccann: \f -> mconcat . map f = foldMap -- i think
08:51:51 <hpc> :t \f -> mconcat . map f
08:51:52 <lambdabot> forall a a1. (Monoid a) => (a1 -> a) -> [a1] -> a
08:52:02 <hpc> :t \f -> mconcat . fmap f
08:52:03 <lambdabot> forall a a1. (Monoid a) => (a1 -> a) -> [a1] -> a
08:52:14 <hpc> or something like that
08:52:24 <cmccann> hpc, yep, though obviously Foldable isn't limited to lists
08:52:41 <hpc> yeah
08:53:01 <hpc> ...and suddenly i understand the purpose of Foldable :D
08:53:26 <cmccann> hpc, it's things you can fold like lists, yes. it's right there in the name!
08:53:50 <cmccann> that's why it has a toList function that works on any Foldable
08:54:13 <cmccann> which is just foldr (:) [] as you'd expect
08:55:50 * cmccann still doesn't like foldl1 and foldr1 though
09:00:55 <sm> hi jaspervdj, are you around ? I wonder how to run IO actions within RuleM, equivalent to http://joyful.com/darcsden/simon/hledger/site/hakyll.hs#L-60
09:02:31 <benmachine> Foldable is kind of an optimisation
09:02:34 <benmachine> it's not that interesting
09:02:53 <benmachine> you *could* define it to have only the toList method
09:03:10 <benmachine> and you wouldn't lose much
09:06:57 <parcs> :t filterM
09:06:58 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:08:23 <sm> jaspervdj: I guess you can't, doing it separately
09:14:10 <koeien1> is there an API for the GHC RTS?
09:14:18 <ornicar> hi! newcomer here.
09:14:21 <kmc> hi ornicar!
09:14:30 <koeien1> i would like to obtain information such as "how much memory is my program currently using"
09:14:34 <ornicar> I've been looking at hoogle but I cannot find the function I need
09:14:48 <kmc> what function do you need? :)
09:14:57 <kmc> koeien1, i think ezyang worked on something like that recently
09:15:04 <ornicar> [a,b,c,d,e,f,g,h,i] -> [[a,b,c], [d,e,f], [g, h i]]
09:15:23 <ornicar> something that "groups" a list in groups of 3 elements
09:15:25 <kmc> ornicar, the 'split' package can do that, i think
09:15:34 <ornicar> oh, thank you
09:15:39 <kmc> otherwise you can build it yourself with take and drop etc.
09:15:44 <kmc> it should be in the standard lib but isn't
09:15:57 <copumpkin> I don't think the RTS currently exports that information
09:16:01 <copumpkin> there's one counter that you can bind to
09:16:06 <copumpkin> that ghci uses for total allocation
09:16:16 <koeien1> kmc: ah, googling says that something like it is in ghc head
09:16:18 <copumpkin> you can read it with a simple foreign call
09:16:21 <copumpkin> oh?
09:16:22 <kmc> so, if Haskell is the egghead academic language, then how come I can't find a single example of the Cabal markup for citing a paper from a package's description field?
09:16:23 <koeien1> viz. ezyang's blog
09:16:45 <copumpkin> kmc: oh no, you gonna pull another Monoid?
09:17:08 <copumpkin> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/Data-Monoid.html
09:17:09 <copumpkin> :P
09:17:22 <kmc> haha
09:17:25 <kmc> not much markup, that
09:17:40 <copumpkin> I guess that's in haddock, not cabal
09:17:41 * copumpkin fails
09:18:25 <applicative> kmc http://hackage.haskell.org/package/majority
09:18:29 <ornicar> : splitAt 3 [1..20]
09:18:35 <ornicar> > splitAt 3 [1..20]
09:18:35 <lambdabot>   ([1,2,3],[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])
09:18:45 <kmc> thanks applicative
09:18:45 <ornicar> bah, I'll try to implement it myself :)
09:22:42 <applicative> haha, another pleasing 'pigworker' answer on 'stack overflow' http://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad
09:23:12 <cmccann> > let justIf p x = if p x then Just x else Nothing in unfoldr (justIf (not . null . snd) . splitAt 3) [0..20]
09:23:12 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16,17]]
09:23:31 <ornicar> uh.
09:23:51 <cmccann> adjust as needed if you want the leftovers in a shorter list. :]
09:24:00 * cmccann likes unfolding things
09:26:55 <byorgey> justIf p = mfilter p . return
09:27:43 <byorgey> > unfoldr (mfilter (not . null . snd) . return . splitAt 3) [0..20]
09:27:45 <lambdabot>   Not in scope: `mfilter'
09:27:56 <koeien1> :t filterM
09:27:57 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:28:15 <byorgey> what?? it's in Control.Monad
09:28:22 <byorgey> no, filterM is different
09:28:28 <koeien1> i see, yes
09:28:37 <byorgey> :t Control.Monad.mfilter
09:28:38 <lambdabot> Not in scope: `Control.Monad.mfilter'
09:28:48 <byorgey> hmm, maybe it's been added recently
09:30:04 <cmccann> byorgey: I'm not sure if that really improves readability in this case, though. unfoldr needs Maybe so the polymorphism isn't adding anything.
09:30:35 <roconnor> Ugh
09:30:52 <roconnor> people need to understand that typeclass laws are meant to hold in the PER of total values.
09:31:14 <roconnor> mempty = undefined  is not proper.
09:31:50 <Saizan> for the empty type?
09:31:56 <roconnor> or any time
09:31:59 <roconnor> or any type
09:34:30 <benmachine> roconnor: you can say "people need to understand" but I don't see why it's anything other than a matter of opinion
09:34:49 <benmachine> it doesn't state what you say in the report or in the library docs
09:35:38 <Saizan> hard to satisfy the identity laws with mempty = undefined anyhow
09:35:38 <roconnor> benmachine: if people try take laws seriously for DCPOs then basically none of the type class instances are correct.
09:35:56 <benmachine> Saizan: with Data.Void it's easy, on the grounds that that's the only value
09:36:12 <benmachine> roconnor: I wouldn't say basically none; certainly fewer than I'd like, but it's far from impossible to satisfy the laws
09:38:39 <roconnor> where as if you the fast and loose PER they basically all hold as expected.
09:39:03 <roconnor> these are the facts
09:39:23 <roconnor> you can draw your own opinion from this (either the right opinion or wrong opinion).
09:40:00 <benmachine> roconnor: what's your opinion on the strictness of mappend for ()?
09:40:26 <benmachine> (i.e. is mappend undefined mempty = () in violation of the identity law?)
09:40:35 <parcs> how mould one optimize 'maximum xs > maximum ys'?
09:40:45 <edwardk>  benmachine: why?
09:40:48 <roconnor> it doesn't matter since it doesn't change denations of any productive program.
09:40:53 <benmachine> edwardk: why what?
09:41:04 <edwardk> benmachine: mappend _ _ = () works fine
09:41:07 <benmachine> roconnor: are productive programs the only programs that matter?
09:41:11 <roconnor> yes
09:41:15 <edwardk> it is clearly associative
09:41:19 <edwardk> as is mappend () () = ()
09:41:39 <edwardk> both are valid monoids
09:41:55 <benmachine> roconnor: why is that?
09:42:11 <parcs> :t foldr1 ((&&) . flip any ?xs . (>))
09:42:12 <lambdabot> (?xs::[Bool]) => [Bool] -> Bool
09:43:03 <dfjkaldfas> edwardk: if mappend () () = (), what is mempty?
09:43:21 <roconnor> benmachine: Hang on, I need to compute the answer to your question...
09:43:43 <edwardk> I tend to prefer the _ _ = () because I don't like wasting time matching needless patterns
09:43:43 <edwardk> and it tends to act nicer when you use it in foldmaps, etc.
09:43:43 <edwardk> spends a lot less time trying to accumulate 'just the right error'
09:43:55 <benmachine> roconnor: would you object if main = forever (return ()) >> putStrLn "hello" wrote to stdout?
09:44:06 <benmachine> ok, that's probably a bad example
09:44:21 <benmachine> but tell me anyway :P
09:44:34 <roconnor> benmachine: I wouldn't object.
09:44:38 <benmachine> oh
09:44:39 <benmachine> I would
09:45:14 <edwardk> dfjkaldfas: mempty = ()
09:45:14 <edwardk> benmachine: lots of c compilers will do that to you
09:45:15 <Eduard_Munteanu> See, Haskell proves to be a really expressive language. You can instruct the computer to do stuff after the world ends.
09:45:24 <roconnor> Prays for the day that GHC would give me a flag to do those sorts of optimizations.
09:45:36 <roconnor> s/^/\/me/
09:46:04 <edwardk> but regardless, the monoid for () is ambiguous, nothing requires it to capture those errors, nothing requires it not to
09:46:23 <edwardk> the _ _ = () version has the benefit that it makes for much more efficiently productive folds
09:46:32 <benmachine> edwardk: I object to those C compilers
09:47:17 <edwardk> i do too, but what they do is far more egregious than the mappend _ _ = () example, which passes all the laws it needs to
09:47:18 <roconnor> benmachine: you take DCPOs too seriously.  They are simply a tool for computing fixedpoint.  It is like worry about the complex solutions to real-valued optimization problems.
09:47:32 <ciaranm> c's getting _Noreturn to deal with that
09:48:03 <benmachine> roconnor: I don't think I take them too seriously :P
09:48:11 <Eduard_Munteanu> That's merely a "trust me", I think.
09:48:38 <Eduard_Munteanu> just like __attribute__((pure))
09:48:40 <kmc> DCPO more like C-3PO
09:48:46 <Saizan> but you don't define (>>) like _ >> x = x
09:48:47 <Eduard_Munteanu> :)
09:49:24 <benmachine> roconnor: but anyway, I'm not trying to say that you're wrong, merely that it's not as obvious as you describe
09:49:38 <benmachine> haskell doesn't mandate one interpretation or the other itself
09:49:53 <roconnor> Maybe
09:49:57 <roconnor> but it is still pretty obvious
09:50:20 <Eduard_Munteanu> And the point of those things in C is optimization, rather than correctness.
09:50:30 <roconnor> either almost all the instance declairations in haskell are broken, or those semantics are wrong.
09:50:49 <edwardk> saizan: depends on the monad ;)
09:51:20 <roconnor> though chosing that the semantics are broken doesn't necessarily imply the PER semantics are right.
09:51:43 <Eduard_Munteanu> For instance, a non-returning function might get away with permanently clobbering callee-saved registers.
09:52:59 <kmc> gcc has an attribute for that
09:53:08 <kmc> it also has an attribute for functions that return more than once!
09:53:09 <Eduard_Munteanu> Yep.
09:53:18 <roconnor> there's an att for that
09:54:36 <jonkri> where is ask defined?
09:54:52 <roconnor> jonkri: it is part of the MonadReader class.
09:55:05 <Eduard_Munteanu> But it will apply heuristics to check if it is indeed non-returning, at most.
09:55:14 <benmachine> jonkri: various places, depending on which package you use, and which ask you mean, but probably Control.Monad.Reader or Control.Monad.Trans.Reader
09:57:52 <jonkri> hmm... i'm confused. ask = Reader id
09:58:15 <edwardk> jonkri: well, you have a function from e -> e -- what is it?
09:58:20 <Eduard_Munteanu> @src Reader
09:58:21 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:59:26 <edwardk> Eduard_Munteanu: well, its not used any more, being replaced by ReaderT
09:59:36 <Eduard_Munteanu> @src ReaderT
09:59:37 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:59:41 <Eduard_Munteanu> :)
10:01:09 <Eduard_Munteanu> Anyway, it should be a newtype for   (->) e
10:01:56 <kmc> foo.c:5:5: warning: function declared ‘noreturn’ has a ‘return’ statement [enabled by default]
10:01:56 <kmc> foo.c:5:5: warning: ‘noreturn’ function does return [enabled by default]
10:01:58 <edwardk> newtype ReaderT e m a = ReaderT { runReaderT :: e -> m a } -- the old mtl Reader was newtype Reader e a = Reader { runReader :: e -> a }
10:02:12 <kmc> amusingly, though, i don't get a warning for calling it in non-void context, or for declarinig its return type non-void
10:02:19 <edwardk> now it is just type Reader e = ReaderT e Identity
10:04:11 <Eduard_Munteanu> kmc: yep but I doubt it will catch returning (explicit or falling through the end) that depends on complicated conditions which you can prove one way or the other.
10:04:44 <kmc> right
10:05:04 <kmc> i think some noreturn functions in Linux end with for(;;); just to make the warnings go away
10:07:00 <jonkri> edwardk, what function are you referring to? id?
10:07:06 <cmccann> nonsense code to make warnings go away is the best kind of code.
10:07:08 <edwardk> jonkri: yes
10:07:22 <edwardk> jonkri: i was pointing out how it is the only sensible definition for ask for Reader
10:08:22 <jonkri> aha, since "<-" or ">>=" strips the monadic context :)
10:08:46 <edwardk> that and what you need is ask :: Reader e e
10:08:48 <Eduard_Munteanu> Replace id's type into runReader
10:08:58 <edwardk> which means runReader :: e -> e
10:09:10 <edwardk> and there is only one (useful) definition for that
10:11:54 <Eduard_Munteanu> Compare with    return a = Reader $ \_ -> a
10:12:16 <jonkri> thanks. what i really meant to figure out was how to create my own monad that can access some internal value from its record
10:13:18 <jonkri> hmm
10:14:10 <Eduard_Munteanu> It simply ignores the environment and returns what you give it.
10:14:50 <Eduard_Munteanu> Reader id, OTOH, will output exactly the environment
10:17:30 <cmccann> interestingly, despite return and ap giving you the K and S combinators for Reader, I don't think it's possible to implement ask with them, despite it merely being the I combinator
10:17:32 <KirinDave> Ugh. http://research.microsoft.com/en-us/groups/ese/nagappan_tdd.pdf
10:17:56 <KirinDave> I guess it's time to warm up your explanations of basic scientific method. I expect PMs and managers nationally to start citing this paper as proof positive you must use TDD.
10:18:17 <cmccann> you can build id, of course, but I don't see how you'd get the actual type for ask.
10:20:11 <applicative> Hadn't know this was part of 'TDD' -- "Check morale of the team at the beginning and end of the project. "
10:20:35 <cmccann> KirinDave, type signatures are just a template for auto-generating exhaustive tests. so with Haskell we tighten the cycle further by collapsing the "writing failing tests" step into "this doesn't type check yet"
10:20:57 <applicative> why do they put a test in for the stuff they fixed?
10:21:14 <KirinDave> applicative: Because it could be broken in the future
10:21:16 <jonkri> i find looking at the info (type Reader r = ReaderT r Data.Functor.Identity.Identity) and :k (* -> * -> *) of Reader confusing. is the "r" the first parameter, and the last parameter of ReaderT the second?
10:21:17 <KirinDave> The idea is not to refute testing
10:21:28 <applicative> everything could be broken in the future
10:21:42 <applicative> hmm, where is that lecture by quickcheck guy, what's his name?
10:21:45 <KirinDave> applicative: I don't think it's bad to have a test suite for a large piece of software.
10:21:48 <ciaranm> rebreaking things is surprisingly common
10:21:49 <KirinDave> But
10:21:54 <siracusa> For a data type data N = Zero | Succ N, what does the implementation of a derived compare *exactly* look like? The report is pretty vague at that point.
10:21:54 <KirinDave> This paper is garbage.
10:21:56 <KirinDave> Methodologically
10:21:58 <jonkri> applicative, http://ulf.wiger.net/weblog/2008/02/29/john-hughes-testing-with-quickcheck/
10:22:00 <applicative> ciaranm: maybe that's right
10:22:03 <KirinDave> It draws no conclusion.
10:22:16 <cmccann> if you did something wrong once, it's plausible you'll screw it up again. so adding tests for fixed bugs makes sense. more sense than a lot of other testing schemes, really
10:22:37 <KirinDave> Software project lifespans in industry settings tend to be longer than the tenure of any one programmer.
10:22:50 <ciaranm> the other advantage of that is if you write the tests for the bug before you fix it then you can be reasonably sure you're fixing the right thing
10:22:50 <KirinDave> As such, codifying 'correct' behavior as a test suite is beneficial despite the cost.
10:22:52 <applicative> jonkri, oh yeah.  I was thinking of this though http://video.google.com/videoplay?docid=4655369445141008672
10:22:54 <monochrom> every time you fix a problem, you probably learn one more valuable test case, and you do not want to lose it
10:23:20 <kmc> siracusa, ghc -ddump-deriv
10:23:27 <kmc> of course that's not normative
10:23:30 <KirinDave> QuickCheck is even better
10:23:51 <KirinDave> But sadly, not universally applicable.
10:23:59 <siracusa> kmc: Hhm, let me try ...
10:24:52 <mauke> siracusa: "The latter seven operators are defined so as to compare their arguments lexicographically with respect to the constructor set given, with earlier constructors in the datatype declaration counting as smaller than later ones."
10:25:14 <applicative> why isn't it universally applicable KirinDave?
10:25:30 <KirinDave> applicative: Because there is this pesky thing called IO.
10:25:49 <monochrom> "lexicalgraphical" means Zero < Succ x, Succ x < Succ y iff x < y
10:25:55 <mauke> compare Zero Zero = EQ; compare Zero (Succ _) = LT; compare (Succ _) Zero = GT; compare (Succ x) (Succ y) = compare x y
10:26:02 <KirinDave> applicative: QuickCheck is feasible for pure functions. That's why you only see that approach automated in languages where pure code is more common.
10:26:11 <KirinDave> applicative: You see quick check stuff for haskell, ocaml, scheme, erlang...
10:26:15 <KirinDave> applicative: Not so much for C#.
10:26:18 <siracusa> mauke: Okay, thanks!
10:27:27 <monochrom> otoh if you wrote "data N = Succ N | Zero deriving (Eq,Ord)", you would get Succ x < Zero instead
10:27:27 <applicative> KirinDave, yes, it certainly easier, Hughes' company does it with crazy things, though, with cameras reading cell phone screens. etc
10:28:38 <jonkri> applicative, thanks for the link :)
10:29:03 <applicative> jonkri, it has some pretty stunning arguments, if I remember, not that I'm really in a position to judge.
10:29:05 <KirinDave> applicative: Cool. I only meant to say that it can be difficult to apply to sequenced events.
10:30:27 <Eduard_Munteanu> jonkri: Reader r a, ReaderT r m a
10:30:54 <Eduard_Munteanu> That definition is just pointfree in a to say so.
10:33:28 <jonkri> Eduard_Munteanu, what does pointfree mean? that the extra parameter is "inherited" from the ReaderT type, like with currying?
10:34:29 <Eduard_Munteanu> I mean, just like   f x = g 1 x    is   equivalent to f = g 1
10:34:46 <cmccann> pointfree style means not binding new identifiers
10:34:46 <monochrom> siracusa: http://www.vex.net/~trebla/haskell/testbed.cgi hehe!
10:34:51 <jonkri> yeah, that's what i meant too :P
10:35:00 <jonkri> ok
10:35:03 <elliott> jonkri: it's a partially-applied type
10:35:04 <lambdabot> elliott: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:35:09 <elliott> huh
10:35:10 <Eduard_Munteanu> Reader r :: * -> *
10:35:27 <Eduard_Munteanu> ReaderT r Identity :: * -> *
10:36:22 <siracusa> Nice
10:36:28 <Peaker> applicative: Writing a test for what you fix in TDD *before* you fix it gives you both a test that the fix actually works, and a test that the test actually tests
10:36:44 <Peaker> (writing the test after-the-fact may not actually check anything, and go green, yay)
10:37:41 <Peaker> applicative: writing something without a test (especially in languages where type correctness means virtually nothing) gives you no assurances about what you wrote -- and fixing any problem later is far more expensive than fixing it now, so even the extra costs of tests now justify themselves
10:37:55 <applicative>  Peaker, certainly if you already wrote it, you might as well keep it around.
10:38:11 <monochrom> but yeah if your questions is "I know that's what GHC does, but is that what Haskell 98/2010 requires?" then it really goes back to those reports, but fortunately the answer is still yes
10:38:26 <Peaker> applicative: yeah, and if you have a good test environment, writing a formal test is not much harder than interactively toying with it until it works
10:38:46 <kmc> ease of writing / generating tests is one of many arguments in favor of pure functions
10:39:14 <kmc> unfortunately it's hard to get very far with pure functions if the standard library uses mutation everywhere
10:39:26 <monochrom> chrisdone++
10:39:39 <applicative> Peaker,  I don't think we disagree, I was trying to make like a quickcheck ideologue
10:40:14 <kmc> Haskell is nice not because it forces pure functional style (which it doesn't) but because the language and libraries actually permit this style
10:40:33 <cmccann> kmc, which is one reason why I'm unimpressed by arguments of the form "but ____ uses the __ VM so it can use all the libraries written for the ____ language"
10:40:41 <kmc> yep
10:40:48 <applicative> Peaker, I will be wandering to your country on Tuesday, for a few months, if I remember what your country is
10:40:49 <cmccann> because, no, I don't want to use most of the libraries
10:40:49 <kmc> Clojure takes pure FP seriously, though
10:40:58 <monochrom> turing tarpit is tarpit
10:41:01 <kmc> and they do see Java libs as a last resort kind of thing
10:41:14 <cmccann> kmc, I've certainly gotten that impression
10:41:14 <kmc> whereas Scala tries to incorporate all of Java's concepts as first-class citizens
10:41:29 <kmc> like, Java is to Clojure as C FFI is to Haskell
10:41:36 <kmc> that's a reasonable approach
10:41:48 <kmc> in fact a better Java FFI for Haskell would be great
10:41:51 <cmccann> the more I hear JVM languages the more I think Clojure is the only one I'd care for
10:41:55 <kmc> (and no, you don't need to compile to JVM to make that happen)
10:42:12 <cmccann> not that compiling to the JVM wouldn't have uses as well
10:42:15 <kmc> *nod*
10:42:27 <kmc> JNI is pretty nasty though
10:42:34 <mike-burns> Perhaps someone can help me use Data.Object.Json. I get this error: https://gist.github.com/76f75ea8a8bf9aa80249
10:42:48 <kmc> when i've built Java - JNI - C - FFI - Haskell bridges, I usually have more trouble on the Java side
10:43:11 <micahjohnston> > let not True = True in not True
10:43:12 <lambdabot>   True
10:43:34 <Peaker> applicative: Israel? Cool! :-)
10:43:41 <applicative> yeah, for the Fall
10:43:53 <cmccann> edwardk: what're you up to at this point? weather seems to be staying bland and I'm thinking the hotel room isn't the most appealing place to sit around.
10:44:09 <Peaker> applicative: business or pleasure?
10:44:14 <edwardk> sitting around, hacking on code
10:44:39 <edwardk> give me about a half hour then swing by?
10:44:51 <applicative> Peaker, i will be at some 'research institute'. I don't really know what my duties will be.
10:45:07 <cmccann> edwardk, ok.
10:45:27 <cmccann> edwardk, just let me know when, I'll be on IRC in the meantime anyhow.
10:45:32 <edwardk> k
10:46:34 <Peaker> applicative: Weizmann?
10:49:06 <applicative> no, http://www.as.huji.ac.il/ I'm in some 'group'. I will comprehend my situation better once I am there, I hope.
10:51:03 <Peaker> applicative: the Hebrew university in Jerusalem.. said to be a very good uni
10:52:39 <applicative> Peaker, hopefully i won't bring down the level to far :)
10:52:50 <Peaker> heh
10:52:59 <mike-burns> No guesses on how I'm supposed to use Data.Object.Json? https://gist.github.com/76f75ea8a8bf9aa80249 - would love to be able to get past this error.
10:57:47 <applicative> mike-burns decode :: Failure JsonDecodeError m => ConvertSuccess Data.ByteString.ByteString k => IsJsonScalar v  => Data.ByteString.ByteString  -> m (Object k v)
10:57:58 <applicative> have you specified what m k and v should be?
10:58:08 <Eduard_Munteanu> mike-burns: try    decode $ pack $ show "hello" :: Maybe JSONObject
10:58:55 <Peaker> forall r. (a -> r) -> r     is isomorphic to a, right?
10:59:04 <mike-burns> Eduard_Munteanu: That was it, thanks!
10:59:16 <hpc> Peaker: yes
10:59:21 <hpc> with x == ($ x)
10:59:25 <Peaker> I'm wondering how to get this isomorphism when viewing these as exponents:  r ^ (r ^ a) ~= a
10:59:41 <hpc> oh, that i can't help with :P
11:00:24 <benmachine> pick r = 1? >_>
11:00:24 <Peaker> It's clear why (Either a b -> c) ~= (a -> c, b -> c)   (c ^ (a+b) ~= c^a * c^b)
11:01:26 <Eduard_Munteanu> Do you mean as exponential objects in an arbitrary category?
11:01:31 <kmc> they're probably not actually isomorphic in Haskell
11:01:38 <kmc> but i doubt that's relevant
11:02:14 <Peaker> kmc: yeah trying to see it algebraically
11:02:40 <benmachine> hmm
11:02:47 <kmc> i think you have to invoke parametricity
11:02:58 <kmc> ((a -> Int) -> Int) is definitely not isomorphic to a
11:03:13 <kmc> that might actually justify setting r=1 as benmachine said
11:03:18 <benmachine> the trouble is there aren't any functions forall r. a -> r
11:03:19 <kmc> i don't know the proper way to look at it though
11:03:30 <copumpkin> setting r =1 wouldn't give you the equivalence
11:03:41 <benmachine> oh, copumpkin is right and I am silly
11:03:50 <copumpkin> @free zomg :: (a -> r) -> r
11:03:50 <lambdabot> g . h = k . f => g (zomg h) = zomg k
11:03:53 <jonkri> how can i create a monad that inherits that of ReaderT like "newtype XMPPT m a = MonadIO m => ReaderT ReaderState m a"?
11:04:08 <kmc> jonkri, look at GeneralizedNewtypeDeriving
11:04:58 <copumpkin> although that isn't quite the right type, is it
11:07:36 <jonkri> kmc, i'd rather not use that extension, but instead do it on my own
11:07:56 <jonkri> copumpkin, no, that's why i'm asking :)
11:09:32 * cmccann notes that if you treat (a -> b) as (b / a), then ((a -> r) -> r) becomes (r / (r / a)) which is r * (a / r), or just a
11:10:14 <edwardk> cmccann: yeah i think the categories package does it that way
11:10:25 <cmccann> where converting from (r / (r / a)) to r * (a / r) is just currying/uncurrying of course
11:10:29 <kmc> jonkri, then you write out the boilerplate yourself
11:10:38 <edwardk> cmccann: feel free to swing by. i'll see who else wants to swing by and hack on stuff
11:10:42 <jonkri> kmc, what's a boilerplate?
11:10:51 <edwardk> preflex: xseen ddarius
11:10:51 <preflex>  ddarius was last seen on freenode/#haskell 4 hours, 17 minutes and 43 seconds ago, saying: And ignoreAttrs instead of requireAttr
11:11:01 <copumpkin> edwardk: foiled again!
11:11:09 <kmc> jonkri, boring repetitive code
11:11:14 <cmccann> edwardk, yes, I once spent an hour or two trying to figure out how to interpret that equivalent in terms of the exponential view, then you mentioned the division interpretation to me some time back and it made more sense :P
11:11:44 <copumpkin> how does the division interpretation work?
11:11:45 <edwardk> yeah its a pretty weak analogy though, only really useful for thinking about currying, etc.
11:12:13 <cmccann> the term boilerplate comes from big, heavy, plates used for printing presses when printing the same thing a lot of times, btw.
11:12:16 <edwardk> see cmccann's comment about if you treat a -> b as b / a
11:12:32 <copumpkin> that's the step I don't understand :)
11:12:38 <jonkri> ok
11:12:38 <copumpkin> what's the justification for doing that?
11:12:41 <cmccann> yes, edwardk mentioned this to me in terms of thinking of coexponentials as subtraction
11:12:49 <edwardk> copumpkin: notational convenience ;)
11:12:49 <cmccann> copumpkin: because cancelling corresponds to application
11:13:03 <copumpkin> hm
11:13:10 <dylukes> I don't understand :<
11:13:12 <cmccann> functions eliminate products, coexponentials end up eliminating sums
11:13:15 <edwardk> it is a purely syntactic hack
11:13:25 <cmccann> I don't know if it's useful in any other way than that analogy
11:13:26 <dylukes> Oh!
11:13:28 <dylukes> I get it!
11:13:42 <byorgey> (a -> b) -> (c -> d) == (d / c) / (b / a) = (d * a) / (b * c) = (b,c) -> (d,a)   <-- I don't think so
11:13:46 <benmachine> the justification of the exponential interpretation to me was that if you have a set A and a set B then |A → B| was |B|^|A| for combinatorics reasons
11:13:47 <edwardk> i came up with it when hacking on category-extras
11:13:48 <cmccann> especially since coexponentials aren't really a thing that exists in Haskell
11:14:12 <dylukes> Wait... do I really get it?
11:14:13 <dylukes> I guess.
11:14:14 <edwardk> one of those is an arrow, not an exponential
11:14:18 <dylukes> I see the idea, I think.
11:14:43 <edwardk> byorgey: the central / in your derivation wasn't legal
11:15:00 <byorgey> edwardk: why not?
11:15:06 <cmccann> edwardk: the worst thing about learning category theory via Haskell is that it's easy to forget that everything isn't cartesian closed everywhere all the time
11:15:33 <copumpkin> that's why you should do it with agda!
11:15:38 <cmccann> funny thing is that a lot of categories don't resemble lambda calculus, funny thing that
11:16:07 <cmccann> copumpkin, yes. I was actually serious about working through the exercises in TTT that way at some point.
11:16:26 <copumpkin> that'd be cool :)
11:16:37 <cmccann> you mentioned having a bunch of CT machinery implemented in agda already. that on your github?
11:17:15 <copumpkin> yep
11:17:23 <copumpkin> https://github.com/copumpkin/categories
11:17:24 <edwardk> byorgey: i mentioned that 'as an analogy it is pretty weak' it only stretcthes as far as the curry/uncurry and apply morphisms. i use it as a mnemonic trick to remember them
11:17:25 <Eduard_Munteanu> BTW, do you also merge what xplat's been working on in there? I seem to remember there was some sort of collaboration going on.
11:17:38 <copumpkin> Eduard_Munteanu: I usually do, but haven't done it in a while
11:18:05 <cmccann> copumpkin: ok. don't think I have agda on this laptop, unfortunately.
11:18:26 <cmccann> and I think I broke it on my desktop at home when I upgraded GHC and reinstalled some things.
11:18:33 <copumpkin> mokus has also been working on it
11:18:33 <copumpkin> looks like mokus has a self-adjunction in there
11:18:57 <copumpkin> so we can actually get Cont out of it, I think
11:19:08 <copumpkin> with the magic adjunction -> monad machinery
11:21:08 * copumpkin typechecks Everything.agda
11:21:20 <cmccann> edwardk: anyway, I'm closing things up here, will head over in a moment or two.
11:21:24 <edwardk> sounds good
11:21:39 <edwardk> if any other boston haskellers want to swing by ping me ;)
11:23:12 <cmccann> fortunately my visual memory is vastly more useful than my sense of direction, so I should be able to find my way easily enough. need a place to actually park this time though.
11:24:50 <ovrskr> .
11:25:05 <ovrskr> Parsec is so easy to use it feels like cheating.
11:25:17 <dylukes> For some things.
11:25:27 <ovrskr> I guess.
11:25:27 <dylukes> I'm just learning how to use alex/happy... I think this is easier, personally :3.
11:25:36 <copumpkin> lolwtf
11:25:36 <kmc> ugh
11:25:39 <cmccann> ovrskr: if it makes you feel better it does have some limitations and is not necessarily very efficient
11:25:45 <kmc> standalone parser generators are, like, so 1980's
11:25:49 <ovrskr> What does Parsec suck at?
11:25:50 <copumpkin> edwardk's library is where it's at
11:25:56 <dylukes> copumpkin: Trifecta?
11:25:57 <kmc> ovrskr, performance
11:25:59 <dylukes> I was going to look at that too.
11:26:00 <copumpkin> yep
11:26:09 <dylukes> It's really terrfying though.
11:26:11 <ovrskr> 'k
11:26:13 <kmc> maybe not "suck", but compiling your parser ahead of time is theoretically better for performance
11:26:15 <dylukes> Is there an example or tutorial?
11:26:24 <kmc> also, Parsec is very flexible and generic
11:26:27 <copumpkin> dylukes: don't be silly
11:26:30 <kmc> attoparsec is a lot more specialized, and a lot faster
11:26:31 <ovrskr> The docs does state that upfront though
11:26:37 <dylukes> alex generates some absolutely terrifying tables.
11:26:38 <dylukes> ;~;
11:26:44 <kmc> doesn't it generate unsafeCoerce too
11:26:48 <ovrskr> Anyway, I'm learning and so not going to produce efficient code anytime soon !
11:26:48 <kmc> or maybe Happy does?
11:26:53 <dylukes> ...I see "cofree", "profunctor"...
11:26:59 <dylukes> this is definitely an edwardk production...
11:27:06 <Eduard_Munteanu> Heh.
11:27:10 <dylukes> there goes semigroup... adjunctions....
11:27:15 <dylukes> >_>
11:27:26 <copumpkin> just because it _is_ one
11:27:28 <copumpkin> doesn't mean you have to care
11:27:56 <dylukes> yep I know :3
11:27:59 <dylukes> Just saying.
11:28:09 <cmccann> most of that stuff is just edwardk using category names for the simple and obvious structures you'd use in Haskell anyway
11:28:23 <dylukes> i.e, what IS a profunctor .__.
11:28:34 <copumpkin> nobody knows!
11:28:35 <jonkri> having specified "newtype XMPPT m a = XMPPT { runXMPPT :: ReaderT (ReaderState m) m a } deriving (Monad)", how come i can't call ask in the XMPPT context? i'm getting the error "No instance for (Control.Monad.Reader.Class.MonadReader a0 (XMPPT m)) arising from a use of `ask'"
11:28:41 <dylukes> oh theres a sigfpe post.
11:28:47 <geheimdienst> cmccann: yes but you don't pick up many girls with "simple and obvious"
11:28:50 <kmc> deriving (Monad, MonadReader) -- jonkri
11:29:14 <jonkri> ah, of course. wrong question, sorry :P monadreader is not of arity 1 it says
11:29:48 <kmc> ah, you'd do something like "deriving (Monad, MonadReader ReaderState)"
11:29:56 <kmc> except it seems your ReaderState is also parametrized
11:30:01 <kmc> so i think you have to used StandaloneDeriving
11:30:37 <kmc> "deriving instance MonadReader (ReaderState m) (XMPPT m)"
11:30:48 <kmc> as a declaration by itself
11:31:06 <ovrskr> how would you write a predicate that checks for either '0' or '1'
11:31:15 <ovrskr> syntax fail on my part
11:31:21 <dylukes> edwardk: please fix trifecta on 7.2?
11:31:22 <dylukes> :<
11:31:25 <kmc> :t (`elem` "01")
11:31:26 <lambdabot> Char -> Bool
11:31:33 <ovrskr> (== '0' || == '1')
11:31:33 <edwardk> dylukes: i have a patch in progress
11:31:36 <ovrskr> oh, genius
11:31:40 <edwardk> dylukes: its part of a much bigger set of changes
11:31:44 <kmc> that'd be \x -> x == '0' || x == '1'
11:31:57 <kmc> @pl \x -> x == '0' || x == '1'
11:31:58 <lambdabot> liftM2 (||) ('0' ==) ('1' ==)
11:31:59 <edwardk> dylukes: i also submitted a request to stephan wehr to patch hscurses
11:32:02 <dylukes> By the way kmc,
11:32:03 <mauke> :t any
11:32:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:32:07 <kmc> dylukes,
11:32:08 <edwardk> so one of those will come through today or tomorrow ;)
11:32:15 <dylukes> couldn't most of the issues with precompiled parsers/lexers be solved with TH?
11:32:18 * hackagebot dewdrop 0.1 - Find gadgets for return-oriented programming on x86  http://hackage.haskell.org/package/dewdrop-0.1 (KeeganMcAllister)
11:32:30 <dylukes> Like, couldn't you turn alex/happy into exorbitantly magic TH?
11:32:34 <kmc> another paradigm supported by Haskell!
11:32:47 <kmc> dylukes, yes.  in fact i think it's been done
11:33:00 <kmc> alex-meta, happy-meta
11:33:18 <kmc> you can basically turn any external program that generates Haskell code into a TH QQ
11:33:20 <MasseR> Is there a function for something like this. let partitionBy [] = []; partitionBy xs = takeWhile (pred) xs : partitionBy (dropWhile pred xs)
11:33:30 <dylukes> kmc: Adding to confusion...
11:33:35 <dylukes> Quasi quote template haskell...
11:33:38 <dylukes> with alex inside...
11:33:41 <dylukes> with inline haskell inside...
11:33:50 <dylukes> but what if you have inline template haskell.
11:33:52 <dylukes> :0
11:33:59 <kmc> T E M P L A T E  H A S K E L L
11:34:06 <dylukes> BUUMMMMM
11:34:09 <dylukes> BUUMMMMM
11:34:13 * ovrskr waiting for Hoost, the boost analogue in the TH world
11:34:14 <dylukes> BUUMMMMM
11:34:33 <ovrskr> takes 8GB to compile, 3 days of recursing around
11:34:52 <dylukes> Does Boost really take that long?
11:34:56 <ovrskr> dunno
11:34:57 <dylukes> If so, holy fucking crap.
11:34:57 <kmc> compile errors longer than the language spec
11:35:03 <dylukes> kmc: XD
11:35:09 <ovrskr> those i've seen tho
11:35:46 <dylukes> oh bother.
11:35:50 <dylukes> TH doesn't work on 7.2 either.
11:35:52 <dylukes> >:<
11:36:05 <hpaste> jonkri pasted “deriving instance error” at http://hpaste.org/50735
11:36:17 <jonkri> kmc, ^
11:36:28 <cmccann> ovrskr: I thought we already had something like that, namely GHC.
11:36:29 <kmc> deriving instance (Monad m) => MonadReader (ReaderState m) (XMPPT m)
11:36:31 <cmccann> ever tried compiling that?
11:38:01 <ovrskr> Well, I notice ghc is not the fastest compiler around.
11:38:19 <ovrskr> i.e. leksah takes ages to compile
11:38:47 <jonkri> kmc, it works... it's a little magical :D
11:38:54 <hpaste> kmc pasted “compiling GHC on a Phenom II X6 1075T” at http://hpaste.org/50736
11:39:17 <ovrskr> holy fuck
11:39:34 <ovrskr> pardon my french
11:39:35 <Eduard_Munteanu> ovrskr: it does produce the best code so far, amongst all other Haskell compilers, though.
11:39:57 <kmc> compiling GHC is not that bad
11:40:10 <kmc> 3.2 GB resident is a little terrible
11:40:25 <KirinDave> I feel like everything I am reading is pushing me to understanding the Yoneda lemma. :\
11:40:42 <randomwords> Does any know of any good code that efficiently uses Unboxed Mutable Vectors. My current use of them ends up using way more heap than I would expect
11:40:42 <edwardk> alex-meta is kinda silly though, all those top level modules make me wince
11:40:44 <kmc> but that CPU isn't super high end or anything
11:40:49 <KirinDave> But I've been warned by no fewer than 5 different people that the yoenda lemma is probably harder to understand than its actual worth in reading literature.
11:40:54 <KirinDave> Fudge.
11:41:00 <kmc> i never got around to building GHC on the 48-core server at work :/
11:41:03 <copumpkin> it isn't that bad
11:41:05 <dylukes> btw
11:41:10 <dylukes> how do you uninstall a package again?
11:41:11 <dylukes> :3
11:41:18 <copumpkin> ghc-pkg unregister
11:41:20 <copumpkin> delete files if you want
11:41:21 <cmccann> okay, heading out for real now.
11:41:25 <randomwords> I'm using RealWorld as the PrimMonad instance - so maybe that's the problem?
11:41:34 <cmccann> edwardk, where should I park, just anywhere along the street that's not obviously a bad idea?
11:41:35 <ovrskr> I should try compiling ghc on my dual-core ARM netbook
11:41:43 <kmc> you have an ARM netbook??
11:41:46 <kmc> cool, which one?
11:41:46 <maurer_> ovrskr: Your biggest issue is likely to be RAM
11:41:59 <edwardk> yeah
11:41:59 <ovrskr> kmc, tablet, ASUS transformer
11:42:11 <edwardk> park on the street. i'll bring you out a parking pass
11:42:20 <kmc> nice
11:42:23 <kmc> how's the battery life?
11:42:26 <ovrskr> insane
11:42:31 <ovrskr> not kidding
11:42:35 <dylukes> oooooo ffs
11:42:36 <dylukes> kmc:
11:42:37 <dylukes> ghc-pkg: unregistering template-haskell-2.6.0.0 would break the following packages: ghc-7.2.1 QuickCheck-2.4.1.1 (use --force to override)
11:42:42 <kmc> can it run a standard Linux distro instead of Android?
11:42:56 <dylukes> I added {-# LANGUAGE FlexibleInstances #-} to one TH's files so cabal install would succeed...
11:43:04 <dylukes> but it doesnt work "Bad interface file: /Users/dlukes/.cabal/lib/template-haskell-2.5.0.0/ghc-7.2.1/Language/Haskell/TH.hi
11:43:04 <dylukes>         Something is amiss; requested module  template-haskell-2.5.0.0:Language.Haskell.TH differs from name found in the interface file template-haskell:Language.Haskell.TH"
11:43:08 <ovrskr> kmc, some guys are porting Ubuntu
11:43:38 <dylukes> oh wait. I did remove 2.5... I think...
11:43:39 <dylukes> :\
11:43:45 <randomwords> Or does Data.Vector.Unboxed.Mutable have known performance issues?
11:43:46 <dylukes> I have 2.6...
11:43:49 <cmccann> edwardk: ok. be there in a few minutes then.
11:45:09 <Eduard_Munteanu> kmc: what did you generate that make -j12 report with?
11:45:56 <kmc> /usr/bin/time -v -o time.out make -j12
11:46:11 <Eduard_Munteanu> Ah, nice.
11:46:23 <parcs> kmc: what BuildFlavour did you use?
11:46:25 <randomwords> I would expect Data.Vector.Unboxed.Mutable and Data.Array.IO to have similar performce for the right choice of PrimMonad - is this not correct?
11:46:30 * Eduard_Munteanu didn't know 'time' kept track of all that
11:46:31 <kmc> default
11:46:44 <kmc> Eduard_Munteanu, the bash builtin 'time' does not
11:47:24 <shapr> @quote
11:47:24 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
11:47:27 <shapr> @quote
11:47:27 <edwardk> randomwords: Data.Array.IO doesn't have the fusion opportunities that Data.Vector.Unboxed.Mutable does
11:47:27 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
11:47:31 <shapr> @quote
11:47:31 <lambdabot> mama says: The time to sleep!
11:47:35 <parcs> the default is 'slowest' i think :P
11:47:46 <dylukes> alex-meta's quasiquoting is written in alex.
11:47:47 <dylukes> >_>
11:47:52 <dylukes> how meta.
11:48:04 <mauke> preflex: quote
11:48:05 <preflex>  <canyonman> Wow, I wasn't paying attention and I accidentally peed on the wall.
11:48:12 <mauke> :-|
11:48:25 <ovrskr> Ireeeeeeene
11:48:35 <ovrskr> whyyy, helloo irreenee
11:49:09 <kmc> ovrskr, so would you recommend the eee pad?
11:49:22 <dylukes> Does cabal handle .x/.y files?
11:49:22 <ovrskr> totally
11:49:36 <ovrskr> but, don't really expect a linux machine.
11:50:00 <randomwords> edwardk: OK, but aside from that they should be similar?
11:50:27 <edwardk> randomwords: i would hope vector would be a bit faster but they should be in the same ballpark
11:50:46 <kmc> ovrskr, well, i wouldn't buy it if i can't put a real desktop linux on
11:51:05 <ovrskr> kmc, then don't.
11:51:06 <randomwords> I'm finding that vector is slower, and using more heap for some reason
11:51:13 <kmc> looks like it's been done
11:51:30 <Eduard_Munteanu> kmc: which one is that then?
11:51:41 <kmc> Eduard_Munteanu, what?
11:51:42 <Eduard_Munteanu> I don't seem to have another 'time'.
11:51:55 <kmc> you don't have /usr/bin/time?
11:52:07 <ovrskr> Is there a Java FFI?
11:52:13 <Eduard_Munteanu> Hm, there is a sys-process/time in Portage.
11:52:26 <kmc> i wouldn't expect it to handle full ubuntu desktop crapware
11:52:39 <Eduard_Munteanu> kmc: well, it's Gentoo. You most likely don't get stuff you don't explicitly install :)
11:52:50 <kmc> then i don't know what the package name is
11:53:08 <kmc> ovrskr, i'd run a minimal debian install with xmonad, which works pretty well even on my current netbook, which has a 900 Mhz Celeron M
11:54:22 <ovrskr> Hmm. I've been meaning to try something like this. Check the driver status. I think touchpad needs some love, but wifi is functional. The most recent revision, B70 is not rootable for the moment, so if you get one get it from NCIX or something.
11:54:30 <kmc> sigh
11:54:41 <kmc> is it really too much to ask to own something after you buy it
11:54:54 <shapr> kmc: AT&T thinks so
11:55:13 * shapr hugs edwardk 
11:55:20 <edwardk> heya shapr =)
11:55:23 <shapr> I want to write more Haskell code!
11:55:32 <shapr> Is this channel still about Haskell? :-/
11:56:29 <kmc> sorry shapr
11:56:35 <edwardk> haskell, texas
11:57:56 <ovrskr> hehe
11:58:03 <ovrskr> you guys so trolled this city
11:58:42 <edwardk> yeah most of us aren't even there, we just keep talking about it like we are
11:59:14 <ovrskr> are any of you actually from Glasgow ?
12:02:14 <shapr> I'm from Glasgow, Texas! It's near Haskell, Texas.
12:06:38 * ddarius lived near Haskell, TX for years.
12:07:10 <randomwords> When I run with +RTS -s I get "   4,494,700,128 bytes allocated in the heap
12:07:19 <randomwords> any way to profile where that's coming from
12:07:21 <nisstyre> there's a place called Curry in Ireland
12:07:51 <TubeSteak> i had a curry for lunch...
12:08:00 <nisstyre> randomwords: how large is your program?
12:08:28 <randomwords> randomwords: Not large - it's not allocating anything near that size AFAIK. I only have ~1MB "in use" but it seems to allocate 4GB
12:09:14 <randomwords> nisstyre: I think I'm using mutable unboxed vectors in some incorrect manner
12:09:18 <ovrskr> There are a few cities named "Reader"
12:09:53 <nisstyre> randomwords: it's obviously allocating it for a reason
12:10:21 <randomwords> nisstyre: Yup - but I don't think it's anything i'm explicitly doing at least
12:10:33 <randomwords> nisstyre: Possible due to my use of GHC.Bade.RealWorld?
12:10:59 <kmc> there's a chapter on heap profiling in RWH
12:11:11 <nisstyre> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/prof-heap.html
12:11:42 <randomwords> nisstyre: Yeah that doesn't help - the heap profile only shows the 16KB that are actually being used
12:14:43 <nisstyre> randomwords: how large are your arrays?
12:15:08 <randomwords> nisstyre: Nominally about 5KB
12:15:20 <nisstyre> that doesn't seem like it would be a problem then...
12:15:20 <randomwords> they contain 5000 Int at least
12:15:40 <nisstyre> I'm just reading about unboxed mutable arrays on the wiki
12:16:25 <randomwords> nisstyre: I think the problem is the way I'm using them - I was implemented a simple bubble sort to test performance
12:16:26 <ddarius> 5000 Int would be about 20KB so using 16KB is actually impressive.
12:16:51 <randomwords> ddarius: I think 16KB was back when I was using 4000
12:17:16 <nisstyre> randomwords: I keep thinking it might be allocating all that memory in anticipation of you using it
12:17:37 <nisstyre> maybe someone who knows a lot more about GHC can help
12:19:27 <nisstyre> randomwords: are you sure it's not allocating new memory for each time you run through the array?
12:19:35 <nisstyre> 5000*5000 = 25000000
12:19:35 <randomwords> nisstyre: That has to be whats happening
12:19:37 <Guest48817> I want to remove the warning "overlapping patterns" in ONE source file. how do I place -fno-warn-overlapping-patterns in that file?
12:19:40 <nisstyre> yeah
12:19:43 <nisstyre> because bubble sort
12:19:46 <randomwords> randomwords: But I don't really understand why
12:20:10 <nisstyre> because bubble sort changes the values each time it goes through
12:20:28 <shapr> ooh, parallel cabal : http://dissocial.st/blog/2011-08-22-GSoC-Final
12:20:28 <nisstyre> it must be garbage collecting the old array each time or something
12:20:36 <randomwords> nisstyre: Presumably
12:20:51 <nisstyre> randomwords: try it with an O(n) sorting algo
12:21:51 <randomwords> http://hpaste.org/50738
12:22:19 <randomwords> that's my code - I'm not really concerned about implementing an efficient sort - I just want to understand how to use mutable vectors correctly
12:22:49 <nisstyre> well I'm fairly sure the memory problem is related to bubble sort
12:23:10 <randomwords> nisstyre: I agree - but this algorithm shouldn't be recreating the vector at all, as far as I can tell
12:23:21 <nisstyre> That is a bit confusing
12:24:00 <randomwords> nisstyre: Yeah the code grew as my confusion did
12:24:59 <randomwords> I don't see why that would allocate GBs though
12:25:25 <nisstyre> that's the only idea I can come up with
12:25:28 <nisstyre> it could be totally unrelated
12:26:01 <randomwords> nisstyre: I believe that's whats happening, there's not much else going on in my program apart from generating a vector
12:26:37 <randomwords> nisstyre: and removing the call to sort removes the problem
12:27:10 <nisstyre> ok then
12:29:50 <copumpkin> has anyone thought of making a Maybe instance for Data.Vector.Unboxed?
12:32:52 <ClaudiusMaximus> randomwords: total allocated is not that meaningful as far as i've experienced, the productivity figure is more important
12:33:16 <ddarius> There isn't one?
12:34:20 <copumpkin> nope
12:34:34 <randomwords> ClaudiusMaximus: But 4GB totally allocated is a bit of a red flag
12:34:51 <randomwords> ClaudiusMaximus: besides, I have a massive performance problem, so i think there is something going wrong here
12:35:34 <ddarius> I'm pretty sure there was one for PArr.  You just split it into Arr (Bool, a).
12:35:50 <ddarius> (which becomes (Arr Bool, Arr a)
12:36:00 <opqdonut> hmm, locality
12:36:07 <randomwords> My Vectors are of type V.MVector RealWorld Int. I don't know much aobut RealWorld - perhaps that's the problem?
12:36:24 <kmc> randomwords, that just means they're mutable vectors in the IO monad
12:36:30 <kmc> the RealWorld type itself has no values
12:36:33 <randomwords> kmc: Good, I thought so
12:36:48 <randomwords> OK well i'm completely stumped
12:36:50 <kmc> if you were using ST, the RealWorld parameter would be replaced with the 's' type variable
12:37:00 <kmc> either way it should be the same code at runtime
12:39:59 <ClaudiusMaximus> randomwords: how are you generating the source vector?
12:40:04 <randomwords> My bubblesort on Vector.Unboxed.Mutable is orders of magnitude slower than the same code on lists
12:40:18 <randomwords> ClaudiusMaximus: sanely - it's definietly not the bottle neck
12:40:41 <randomwords> ClaudiusMaximus: V.replicateM n (randomIO :: IO Int)
12:40:54 <ClaudiusMaximus> unfortunately that's not sane :(
12:41:32 <randomwords> well regradless, it's not the relevant problem
12:41:56 <randomwords> but I would be interested to know what's wrong with it
12:42:00 <ClaudiusMaximus> with V.replicateM n getChar  and piping from /usr/share/dict/words, i get almost no garbage collection
12:42:37 <randomwords> but that will only ever double the heap right?
12:43:12 <copumpkin> what's the advantage to ByteString over Vector Word8?
12:43:30 <ddarius> randomwords: Where's the rest of your function?
12:43:51 <randomwords> ddarius: http://hpaste.org/50738
12:44:00 <ddarius> randomwords: Where's the rest of your function?
12:45:08 <hpaste> ClaudiusMaximus annotated “BubbleSort on Mutable Vector” with “BubbleSort on Mutable Vector (annotation)” at http://hpaste.org/50738#a50739
12:46:15 <ClaudiusMaximus> yeah, i guessed at that - i might have made an error
12:46:45 <randomwords> ClaudiusMaximus: looks sane
12:47:13 <ddarius> Also are you compiling with optimizations?  Haskell code tends to generate a -lot- of garbage normally, though in this case it should be able to run without producing any.
12:47:27 <randomwords> ddarius: Yup
12:49:28 <ClaudiusMaximus> http://article.gmane.org/gmane.comp.lang.haskell.cafe/91756/match=random+crypto+weak+slow is one message on the badness of the default random source, neighbouring comments might have more info
12:50:06 <copumpkin> kmc: what do you like to do with memory?
12:50:17 <copumpkin> gimme some ideas of non-obvious operations that might be helpful
12:51:02 <randomwords> ClaudiusMaximus: Hmm - I guess it is something to do with the generation
12:55:54 <ornicar_> I'm reading LYAHFGG and I love it. I'm now learning about <*> and <$> but I need to kinda pronounce them in my head.
12:56:13 <ornicar> how do you say <*> and <$> loudly?
12:57:38 <mauke> preflex: quote . modem
12:57:39 <preflex>  <monochrom> Do not try to pronounce haskell code. You are not a modem.
12:57:48 <monochrom> heh
12:58:42 <ornicar> hmm I find it hard to reason about things I can't name
12:59:07 <monochrom> <$> is called Jacquelin von Brionee. <*> is called Kuso Katamoto
12:59:17 <ornicar> when you are talking with someone about <$>, how do you say it?
12:59:28 <monochrom> Jacquelin Brionee
12:59:48 <monochrom> now you have a name and you can reason about it!
13:00:27 <ornicar> that's of great help.
13:01:36 <ornicar> it's hard enough to get started with haskell. I though I could find some comprehensive people here.
13:01:57 <copumpkin> the answer is that we don't typically pronounce them
13:02:02 <copumpkin> I'd probably pronounce the first one ap and the second one fmap
13:02:24 <ornicar> alright, that's an answer. Thanks.
13:03:24 <monochrom> @type ap
13:03:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:03:33 <monochrom> @type (<*>)
13:03:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:04:01 <monochrom> there is already another ap, while you thought you could call <*> ap.
13:05:40 <ornicar> ok
13:05:44 <monochrom> of course, this is no worse than having two Simons
13:09:29 <confab> wikipedia is here?
13:09:49 <dylukes> I have an idea for a fun program.
13:09:57 <dylukes> It's a script that analyzes the output of your shell session,
13:10:00 <dylukes> parses out GHC errors...
13:10:06 <dylukes> and lets you play "Type Error Bingo"
13:13:20 <joeyh> I have too many unqualified imports in my code. Is there a good tool to ensure I only import functions my code uses?
13:24:04 <donri> "python"
13:24:06 * donri ducks
13:24:30 <dainanaki> Hello all, I've got an enumeratee that inserts values into a heap for a while and then later removes values that no longer satisfy a predicate from the heap and inserts them into an ordered list. However, when I get to the end of enumerator input, the remaining values in the heap get discarded. Has anyone got a good idea of how I could send the remaining values in the heap to the inner iteratee?
13:25:19 <joeyh> thought I'd seen a simple linter or import rewriter
13:26:03 <parcs> joeyh: -Wall ?
13:26:43 <parcs> joeyh: unless you mean always using an explicit import list when importing stuff
13:26:52 <parcs> that's a bad idea
13:28:58 <joeyh> hm
13:32:17 * hackagebot tagged 0.2.3.1 - Provides newtype wrappers for phantom types to avoid unsafely passing dummy arguments  http://hackage.haskell.org/package/tagged-0.2.3.1 (EdwardKmett)
13:33:47 <Clint> !@$!@
13:34:06 <edwardk> Clint: that is an interesting looking operator
13:34:17 <Clint> edwardk: thank you
13:34:48 <companion_cube> can we have its type now?
13:35:12 <Clint> no
13:35:19 <bfig> :t !@$!@
13:35:19 <lambdabot> parse error on input `!@$!@'
13:35:39 * bfig ::BadWord
13:35:40 <copumpkin> > let (!@$!@) = (+) in 5 !@$!@ 6
13:35:41 <lambdabot>   11
13:36:13 <companion_cube> for more obsfucation, i think !@$!@ should be an alias for callCC
13:36:13 <parcs> would automatic reloading of modified source files be a useful feature to ghci?
13:37:09 <copumpkin> edwardk: have you considered a flip const alias for tagged?
13:37:11 <applicative> > let (!@$!@) = id in (!@$!@ (!@$!@)) 3
13:37:12 <lambdabot>   3
13:37:28 <edwardk> copumpkin: hrmm
13:37:36 <edwardk> copumpkin: feel free to submit a patch ;)
13:37:45 <copumpkin> I just mean s -> a -> Tagged s a, really
13:37:49 <copumpkin> not even flip const
13:38:02 <edwardk> i have one with the other order iirc
13:38:16 <copumpkin> hm, I couldn't see one
13:38:44 <edwardk> guess i don't even have that
13:38:51 <edwardk> just the s -> Tagged s a -> a
13:38:57 <edwardk> patch away =)
13:40:00 <copumpkin> you have s -> Tagged s a -> s
13:40:10 <edwardk> ah yes
13:40:22 <copumpkin> I've also been tempted to use Tagged infix
13:40:24 <copumpkin> do you do that?
13:40:36 <edwardk> i use Proxy now for almost everything
13:40:41 <copumpkin> ah
13:40:42 <edwardk> Tagged is harder to use
13:40:50 <copumpkin> oh, so with reify?
13:40:54 <edwardk> yeah
13:41:00 <edwardk> hence why i switched reflection to Proxy
13:41:04 <copumpkin> I see
13:41:43 <edwardk> i also tend to structure it so that any function i write that would take a proxy I make parametric in the 'proxy' type
13:46:21 <copumpkin> I think tagged fits better here
13:47:04 <randomwords> ClaudiusMaximus: Apologies for earlier, it seems that the actual slowdown in my complete code was a helper function that converted from Vector to List
13:47:16 <randomwords> wasted everyones time slightly
13:48:09 <ClaudiusMaximus> randomwords: no worries, glad you found the problem
13:49:09 <randomwords> thanks for all the help thought, I learned some incidental things, which is always nice :)
13:49:26 <sanjoyd> How do I read unicode in Haskell?  I'm looking for something lightweight, which can read a UTF8 file into a String.
13:51:16 <kmc_> sanjoyd, the standard IO functions do that, if your locale is utf8
13:51:31 <sanjoyd> Just what I wanted to hear. :D
13:51:34 <sanjoyd> kmc_: Thanks!
13:51:37 <kmc_> if by "lightweight" you mean space or time consumption then String is a
13:51:39 <kmc_> bad choice
13:51:57 <sanjoyd> kmc_: more like, "lightweight for now".
13:52:06 <kmc_> (also what I said was not true before GHC 6.12)
13:52:07 <sanjoyd> What I finally use I'll decide later.
13:52:46 <kmc_> to efficiently and portably read a UTF-8 file, I'd read ByteString and then use Data.Text.Encoding.decodeUtf8
13:53:17 <zzo38> I cannot figure out how to modify the Haskell parser. I looked at haskell-src-exts but I cannot figure it out
13:55:31 <kmc_> sanjoyd, though if your text is mostly ASCII, converting it to Data.Text will blow up the memory usage by about a factor of 2
13:55:42 <kmc_> there's this 'smallstring' package instead, which uses utf8 internally
13:55:45 <kmc_> but i haven't used it
13:56:51 <applicative> joeyh: where you looking for -ddump-minimal-imports?
13:57:34 <zzo38> Can you please tell me how to fix the parser?
13:58:52 <roconnor> pattern guards are Haskell 2010?
13:59:04 <copumpkin> yeah
13:59:40 * applicative hasn't even used them, and they're already embalmed in the standard...
14:00:26 <copumpkin> I enjoy them
14:01:00 <zzo38> Is there something like haskell-src-exts but using Parsec?
14:01:08 <copumpkin> I doubt it
14:02:46 <zzo38> Then how do I fix the parser that is used by haskell-src-exts?
14:03:22 <copumpkin> you download the source and modify it
14:03:27 <zzo38> It says "parser produced by Happy Version 1.17" but it does not say what produced it.
14:03:50 <copumpkin> happy produced it
14:03:55 <applicative> what's wrong with Happy producing a parser
14:03:56 <copumpkin> there's a file in there that specifies the parser
14:04:12 <copumpkin> if not, it's just borrowed from ghc
14:04:15 <zzo38> Happy is producing the file from what?
14:04:57 <Saizan> InternalParser.ly
14:05:21 <zzo38> There is no file called InternalParser.ly in there
14:05:33 <copumpkin> http://code.haskell.org/haskell-src-exts/src/Language/Haskell/Exts/InternalParser.ly
14:05:34 <applicative> yes there is, i'm looking at it
14:05:50 <applicative> "Most of the code is blatantly stolen from the GHC module Language.Haskell.Parser"
14:05:56 <zzo38> O, there it is.
14:05:56 <copumpkin> it may not get included in the cabal archive
14:06:03 <zzo38> Why did they put it in the different directory?
14:06:05 <Saizan> it's included
14:06:08 <applicative> maybe you can look there too zzo38
14:06:14 <zzo38> I did find it.
14:06:21 <applicative> yeah, mine is cabal unpacked.
14:06:28 <Saizan> it's in the directory where the other sources are
14:07:24 <zzo38> Yes I did find it, but it is not in the same directory as InternalParser.hs
14:08:14 <copumpkin> because the .hs is generated code?
14:08:18 <copumpkin> and probably gets autogenerated during a buil
14:08:19 <copumpkin> build
14:10:02 <applicative> yes it's under dist if you cabal build.
14:11:12 <zzo38> Is there a program to convert between layout mode and non-layout mode?
14:11:51 <applicative> there is a library, haskell-src-exts :)
14:11:54 <copumpkin> no, because nobody uses non-layout mode
14:11:56 <copumpkin> except for you
14:12:00 <copumpkin> and one other guy
14:12:09 <zzo38> What one other guy?
14:12:15 <applicative> simon p j
14:13:06 <copumpkin> http://semantic.org/
14:13:08 <copumpkin> iirc
14:13:11 <applicative> zzo38: how is haskell-src-exts failing you
14:13:13 <copumpkin> he uses non-layout a lot
14:13:32 <joeyh> applicative: thanks!
14:13:51 <zzo38> applicative: Actually I just try to figure it out now. I am looking to see if I can figure it out.
14:14:55 <applicative> I see this, for example, isn't non-layout, but it indents the whole module after the opening where http://hackage.haskell.org/packages/archive/time-extras/1.1.4/doc/html/src/Data-Time-Instances.html
14:14:58 <zzo38> Where is stuff about which extensions are used, so that you can turn on/off, and add new syntax extensions and so on?
14:15:02 <applicative> very avant garde
14:16:44 <applicative> zzo38 well one of the constructors for Extension is UnknownExtension String
14:17:18 <applicative> zzo38 then there's e.g. readExtensions :: String -> Maybe [Extension]  and parseFileWithExts ::
14:17:18 <applicative>   [Extension] -> FilePath -> IO (ParseResult Module)
14:17:32 <zzo38> No, I mean how do I deal with it in the InternalParser.ly file in order to check which extended syntax is available.
14:18:28 <zzo38> I can add more constructors for Extension to deal with any new extensions I make up for syntax, probably they should start with "X-"
14:20:15 <nisstyre> randomwords: did you solve your heap problem?
14:20:25 <nisstyre> I'm curious to know what the cause was
14:20:35 <zzo38> I look at everything under %token but some of them are only for certain extensions. How do you tell which ones to enable?
14:21:38 <randomwords> nisstyre: It ended up being an unrelated peice of code that converted the Vector to a list
14:22:46 <randomwords> nisstyre: I am still having heap issues though
14:22:47 <zzo38> O, is it the file "Lexer.hs" to do that?
14:23:01 <nisstyre> randomwords: well that makes sense then
14:28:59 <applicative> zzo38 what are you doing that pertains to extensions?
14:29:16 <zzo38> I want to modify haskell-src-exts to add syntax extensions
14:33:27 <zzo38> Is it possible to make cabal to access multiple servers? If so, is it possible to specify prefixes for packages on different servers?
14:38:13 <applicative> zzo38:  I think the theory of cabal install &c was that it could go to any suitable server, but I don't know what has been done to realize the idea
14:43:20 <zzo38> They should support prefixes in case the different servers have conflicting names. If the server has the same packages as another then you can use the same prefix.
14:43:44 <nschoe> And the State would be the map?
14:43:54 <nschoe> (oOPs sorry, wrong window :D)
14:46:52 <zzo38> Haskell seems to have one type name which is not capitalized.
14:48:37 <zzo38> What do you do with cabal when dealing with different line ending of Windows/UNIX? Is there a way?
14:48:39 <mauke> it has a few: [], ->, (,)
14:49:53 <zzo38> mauke: OK, I forgot about [] and (,)
14:50:02 <copumpkin> zzo38: what type name?
14:50:16 <zzo38> copumpkin: mauke listed all of them as far as I can tell
14:50:24 <zzo38> (Other than () and (,,,) and all the other tuple types)
14:50:25 <copumpkin> oh, you meant symbolic
14:50:28 <copumpkin> okay
14:52:56 <zzo38> I don't know if there are capitalized symbolic types, if trying to make one it says you need -XTypeOperators which works
14:53:06 <applicative> zzo38 you can introduce them with
14:53:09 <applicative> ah you see it
14:53:34 <applicative> the initial colon is the 'uppercase' operator, no?
14:53:52 <zzo38> Yes I mean a colon is uppercase symbol, other symbol are lowercase, I think.
14:54:40 <applicative> now I see what you mean, so only the inbuilt (,) [] etc are like that.
14:55:13 <applicative> all others start with : or one of ['A'..'Z']
14:56:49 <zzo38> Yes, 'A'..'Z' are uppercase letters and 'a'..'z' and '_' are lowercase letters, while ' and digits can be used as letters but are neither uppercase nor lowercase, and : is uppercase symbols other symbols is lowercase symbols, I think. At least, it is what seemed to me.
14:57:05 <zzo38> But note that ( ) [ ] are not even considered symbols, they are not lowercase or uppercase
14:57:17 * hackagebot mecab 0.2.0 - A Haskell binding to MeCab  http://hackage.haskell.org/package/mecab-0.2.0 (HideyukiTanaka)
14:57:22 <zzo38> While -> is a noncapitalized symbol name
14:58:26 <zzo38> It seem also, you cannot use 'name notation in Template Haskell for name that is x' or y' or another name like that, since it is conflicting with character constants
15:01:27 <zzo38> They should allow you to put the name in parentheses if you want to, in order to allow you to use that syntax with those names
15:01:41 <gwern> 'McIlroy: This is the nice thing about programming in a language like ML, which we have not... I have not yet been able to say, "All right, I’m going to abandon C, and I’m going to write in ML." I think I ought to. But, I will have burned my bridges. I will no longer be able to work with… I will have left all these old parts… that I could use. Starting from scratch. But, there’s a language which is built on mathematical ideas of algebra: ...
15:01:47 <gwern> ... category theory, how composition of functions and higher level functions in that language… functions that work on functions… functions are return functions… come straight out of modern algebra. ' https://www.princeton.edu/~hos/mike/transcripts/mcilroy.htm#
15:02:12 <roconnor> @hoogle zipWithM
15:02:13 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
15:02:13 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
15:02:13 <lambdabot> Data.Generics.Twins gzipWithM :: Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)
15:05:30 <zzo38> I think the kind (#) should be renamed to ## because I don't like the name with parentheses
15:06:30 <zzo38> Does it make sense?
15:06:56 <kmc> yeah, it is a little bit inconsistent
15:07:28 <kmc> i don't think it matters very much and i don't think anyone's likely to care or to change it
15:08:06 <kmc> it's rare to even see or write a kind, let alone the unboxed tuple kind
15:08:28 <kmc> it's not part of Haskell; you can pick different syntax when you write your Haskell + extensions compiler
15:11:52 <zzo38> Is it possible to replace only the front-end of GHC, while making all version of back-end compatible with all version of front-end?
15:12:47 <zzo38> Some of my extensions would require to modify the Haskell compiler, while others would not require it but would help if it is so that it can be used with Template Haskell and all that other stuff
15:13:30 <kmc> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/ext-core.html
15:13:35 <kmc> "Currently (as of version 6.8.2), GHC does not have the ability to read in External Core files as source. If you would like GHC to have this ability, please make your wishes known to the GHC Team."
15:16:39 <roconnor> @hoogle execStateT
15:16:40 <lambdabot> Control.Monad.State.Lazy execStateT :: Monad m => StateT s m a -> s -> m s
15:16:40 <lambdabot> Control.Monad.State.Strict execStateT :: Monad m => StateT s m a -> s -> m s
15:16:41 <zzo38> Is the front-end used for generating core files? If they add that would it make possible to separate the front-end from the back-end? And if it is done, would everything else still work properly?
15:18:53 <zzo38> But I think it has plugins for Core->Core translation, do such plugins have access to I/O so that you can make it load external files?
15:22:45 <nschoe> Je reponds vite usually moi!
15:22:51 <nschoe> (oOps sorry again :/)
15:23:42 <randomwords> ClaudiusMaximus: If you're still around I have another oddity that I can't explain. In the pasted example ealier, the code slows down several orders of magnitude if the sort function is in a separate module and then imported (it causes a huge space leak). Do you have any ideas?
15:26:31 <applicative> I think the plugins machinery can use some kind of IO.  One of the super-simple illustrations does, zzo30
15:27:17 <applicative> zzo30 I finally remembered the tutorial http://www.haskell.org/wikiupload/f/f0/TMR-Issue12.pdf
15:28:55 <zzo38> Why do they always use PDF? PDF is not a very good format
15:29:05 <applicative> not, its not IO generally I guess, just a kind of trace  plugin = defaultPlugin {getPasses = putMsgS "Hello, GHC World!" >> return []}
15:29:22 <Iceland_jack> zzo38: What would you prefer?
15:29:28 <applicative> zzo38 Im sure they'll give the latex source if you like....
15:29:40 <zzo38> DVI is much better
15:30:05 <zzo38> My own stuff is using DVI
15:30:11 <randomwords> Is there any reason why importing a function from a separate module could cause a space leak when calling that function
15:30:15 <kmc> zzo38, is there anything you won't complain about?
15:30:17 <Iceland_jack> Complaining for the sake of complaining
15:30:46 <kmc> randomwords, compared to having that function defined locally?
15:30:57 <kmc> the latter might allow some optimizations like inlining and strictness analysis
15:31:02 <kmc> which could decrease allocation
15:31:37 <zzo38> No, DVI is much better format. I do have PDF but DVI is better
15:31:59 <randomwords> kmc: Could I potentially see a difference of say 1MB vs 500MB in allocations?
15:32:11 <randomwords> kmc: Can I attempt to get those optimisations cross module?
15:32:19 <kmc> you could potentially see an arbitrarily large difference
15:32:26 <kmc> i don't know what's plausible or likely
15:32:32 <kmc> did you look at the Core code?
15:32:38 <Eduard_Munteanu> randomwords: maybe you should try to fix the underlying issue
15:33:04 <randomwords> Eduard_Munteanu: it's hard to diagnose
15:33:22 <randomwords> kmc: How do I look at the core code?
15:33:37 <Iceland_jack> zzo38: PDF is self-contained, so it works better long-term
15:33:38 <Eduard_Munteanu> Use ghc-core, or pass -ddump-simpl to GHC
15:33:53 <kmc> it's not exactly easy to read
15:34:02 <kmc> it's a Haskell-like language
15:34:21 <kmc> a subset of Haskell (because many things are desugared) but also the semantics of some constructs change
15:34:25 <Eduard_Munteanu> randomwords: maybe you could paste your code
15:34:45 <kmc> randomwords, you can put an INLINE pragma on the thing you want to get inlined
15:35:13 <Eduard_Munteanu> Are you using any -O level?
15:35:22 <randomwords> OK - well I get the same problem with no -O level
15:35:26 <randomwords> and it disappear with -O2
15:35:31 <zzo38> Iceland_jack: No, PDF has a lot of stupid things. Including, audio, animations, etc. You cannot print that out!!! But there is other stupid thing too
15:35:40 <randomwords> so I'll investigate the difference in the core code
15:35:56 <Iceland_jack> zzo38: Apathy, rising.
15:36:17 <copumpkin> why are we talking about PDF in #haskell?
15:36:24 <kmc> zzo38, i'm just some guy, not like an op or anything, but you're really starting to piss me off
15:36:26 <randomwords> or maybe that's beyond me..
15:36:45 <copumpkin> kmc: have anything you'd want to see on that memory-like type?
15:36:51 <kmc> hmm
15:37:18 * hackagebot BiobaseTurner 0.1.0.0 - Import Turner RNA parameters  http://hackage.haskell.org/package/BiobaseTurner-0.1.0.0 (ChristianHoener)
15:37:46 <kmc> so the core semantics are (Word64 -> Maybe Word8), right?
15:37:47 <zzo38> In my IRC server there are no ops.
15:38:21 <copumpkin> zzo38: the point is, the 740 people in here don't care about PDF vs. DVI
15:38:31 <zzo38> OK fine
15:38:49 <copumpkin> #haskell-blah would be fine
15:38:57 <Eduard_Munteanu> That's because they don't regularly have +o on
15:38:58 <kmc> they also don't care about Inform 7, Magic: The Gathering, CWEB, or your IRC server
15:39:13 <kmc> (probably a few people here do care about CWEB)
15:40:07 <randomwords> Eduard_Munteanu: http://hpaste.org/50744 there's the code - it's fine in one module, but it uses huge amounts of space if the sort function is in a separate file
15:41:33 <Eduard_Munteanu> randomwords: consider adding a type signature to bubbleSort
15:41:54 <Eduard_Munteanu> It might help if the principal type is too general.
15:42:03 <zzing> If I want to represent a date / time what is the best datatype to use?
15:42:19 <Jafet> You shouldn't use a type signature for that, but a SPECIALIZE pragma
15:43:42 <Jafet> zzing: something in Data.Time I guess
15:43:44 <Eduard_Munteanu> Yeah, but a type sig is a good thing anyway. Then SPECIALIZE for particular things.
15:43:54 <Jafet> As for which one, I have no idea
15:44:10 <Jafet> There's the golden UTCTime hammer
15:44:27 <parcs> @hoogle splitEithers
15:44:27 <lambdabot> No results found
15:44:38 * BMeph begs: Please, hammer, don't hurt 'em! ;þ
15:45:08 <randomwords> Jafet: Was the SPECIALIZE comment directed at me?
15:45:33 <Jafet> At Eduard, because I think he should have said it
15:46:16 <zzing> Jafet: It all seems to use Day which says it is a Julian day (modified), which is kind of weird to me because we are using gregorian everywhere in the world pretty much.
15:46:17 <randomwords> Eduard_Munteanu: Ok - adding a type sig seemed to solve my problem. I would love to understand why an overgeneralised type signatuer causes more heap to be spent.
15:46:31 <Jafet> I'm guessing that ghc will specialize the bubbleSort if it was defined in the same module
15:46:45 <zzo38> Can the current version of GHC load plugins?
15:46:46 <Jafet> But it doesn't do this across module boundaries, because it wouldn't know what to specialize for
15:46:59 <Jafet> To be sure, you can look at the ghc core (-ddump-simpl)
15:47:00 <Eduard_Munteanu> Jafet: for non-exported stuff, I think
15:47:40 <randomwords> Jafet: Ah - that makes sense. And there's no link time optimisation that would allow that?
15:47:40 <Jafet> If you SPECIALIZE it, ghc should apply the specialized copy even across modules
15:47:59 <Eduard_Munteanu> Or maybe it can generate different definitions even then, I'm unsure.
15:48:21 <Jafet> I have not heard of any link-time optimisation
15:48:29 <Jafet> ghc still uses gcc for linking, so that's unlikely
15:49:10 <randomwords> Ok - so when I had the over general version, why might that be causing huge amounts of heap to be used. Is it just a lack of optimisiations or something more specific?
15:49:17 <parcs> @hoogle tryIO
15:49:17 <lambdabot> No results found
15:49:19 <monochrom> some ghc optimizations work across module boundaries. by including module-internal code in *.hi files
15:49:28 <kmc> zzo38, GHC 7.2 can; not previous versions
15:49:51 <kmc> 7.2 is the most recent release but is not in Haskell Platform yet
15:50:00 <Jafet> randomwords: if ghc knew a particular type was being used, it could apply further optimiations
15:50:31 <randomwords> Jafet, Eduard_Munteanu: Thanks so much for the help!
15:50:32 <Jafet> Well actually, I'm not sure why that bubbleSort would use a lot more space than the usual
15:50:49 <zzo38> kmc: Is 7.2 stable version?
15:50:49 <kadoban> anyone used Graphics.GD? it doesn't seem to be correctly writing transparent png
15:50:57 <kmc> yes
15:51:19 <kmc> stable releases are x.y.z for even y
15:51:22 <zzo38> Is it possible to overwrite the version that is already installed with new one?
15:51:25 <dylukes> Could someone attempt to fix alex-meta?
15:51:25 <randomwords> Jafet: As far as I could tell it was delaying the reads and writes, or at least using a lot of space to do them
15:51:43 <randomwords> Jafet: I suppose if it doesn't know that it's reading and writing a POD then there can be trouble
15:51:49 <dylukes> I'm not sure how to go about it, but it would be somewhat nicer than having to use compiled stuff...
15:51:58 <zzo38> kmc: OK. Thanks you for telling me what is version number for stable.
15:52:00 <dylukes> edwardk: You said the Trifecta thing would be done tomorrow?
15:52:21 <Jafet> randomwords, yeah, but you're operating on unboxed vectors, so I don't see any room for non-strictness
15:52:44 <randomwords> Jafet: good point
15:56:45 <zzo38> Is it possible to use cabal to upgrade GHC?
15:56:51 <monochrom> no
15:57:41 <Peaker> I'll repeat a question I asked a while ago -- maybe someone has thought up an answer?  Is there any way to express the equivalence of (forall r. (a -> r) -> r) ~= a   algebraically?  (r ^ (r ^ a)) ~= a ?  How do you represent the polymorphism constraint?)
15:58:08 <monochrom> each version of ghc does not honour libraries built for other versions of ghc. you will not just substitute ghc and expect existing libs to work
15:59:24 <zzo38> OK, but why is that?
16:00:13 <monochrom> because *.hi files expose module-internal code to help optimizations
16:00:39 <kmc> zzo38, there's no stable ABI between GHC versions.  you can't link binaries produced by two versions of GHC and have anything sane happen
16:00:57 <monochrom> and both *.hi contents and optimizations vary with compiler version
16:03:16 <Peaker> Hmm.. how do dependent functions map to algebraic definitions?
16:04:34 <Peaker> Maybe it makes more sense to look at it as: (r : Set) -> (a -> r) -> r        which is: (r ^ (r ^ a)) ^ Set   but this just complicates it worse :-)
16:04:44 <Peaker> (and ignores the dependency)
16:13:59 <Eduard_Munteanu> Peaker: what do you mean by algebraic there?
16:14:09 <kadoban> anyone recommend a graphics library? i just need to draw simple shapes, and output to hopefully png.  GD works, except it's transparency handling is completely broken, so i can't use that
16:14:21 <Eduard_Munteanu> Peaker: also, maybe you want an arbitrary functor instead of (->)
16:15:18 <Eduard_Munteanu> :t (>>>)
16:15:19 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:15:26 <Eduard_Munteanu> Something like that.
16:15:30 <hpc> kadoban: diagrams?
16:15:48 <hpc> also cairo: http://hackage.haskell.org/package/cairo
16:15:58 <Eduard_Munteanu> Yeah, cairo might be alright.
16:17:18 <Peaker> Eduard_Munteanu: I mean expressing the type as sums,product,exponents,0,1,etc, instead of Either,tuples,functions,Void,(),etc (respectively)
16:17:51 <kadoban> diagrams i didn't really look at because its documentation seems really bad, i'll look again. ill look at cairo too
16:17:54 <Peaker> Eduard_Munteanu: note the "a" appears in a negative position, so if you used an arbitrary function you'd get:  f (f r) ~= ??
16:19:28 <Eduard_Munteanu> Peaker: I mean    (a `f` r) `f` r  ~  a
16:20:14 <copumpkin> Peaker: a dependent function is just a new primitive
16:20:19 <copumpkin> you can express other ones in terms of it
16:20:41 <Peaker> Eduard_Munteanu: oh, arbitrary category, not arbitrary functor?
16:20:51 <copumpkin> in fact, with 0, 1, 2, sigma, and pi, you can express most of the usual types
16:20:52 <Eduard_Munteanu> Yeah.
16:21:11 <Eduard_Munteanu> I'm unsure what you want to do, prove that for arbitrary CCCs?
16:21:12 <Peaker> copumpkin: what does this new primitive correspond to in the algebraic side?
16:21:19 <copumpkin> it doesn't
16:22:43 <zzo38> Is it possible to convert from Core to Haskell source, so that if I make a front-end it can convert and will still work with Haskell compiler?
16:22:46 <Peaker> Eduard_Munteanu: well, for a type-thing in Haskell, I can typically find a corresponding thing in algebraic land, and it's nice. For example:  To show why: Either a b -> c   is like  (a -> c, b -> c)   you can use:  (c ^ (a+b)) = (c ^ a * c ^ b)
16:23:13 <Peaker> and you can get some nice insights about various correspondences
16:23:18 <Eduard_Munteanu> Ah.
16:23:18 <Peaker> but I'm not getting anywhere with  forall r. (a -> r) -> r   :-)
16:23:18 <Eduard_Munteanu> And you want something similar for Cont.
16:24:14 <copumpkin> Peaker: you won't get anywhere with other interestingly quantified types either, I don't think
16:24:17 <_Ray_> Hi. I know Functors must provide a fmap :: (a -> b) -> f a -> f b. How does this work when the type constructor has more than one parameter?
16:24:32 <kmc> _Ray_, in that case 'f' is already applied to n-1 parameters
16:24:50 <Eduard_Munteanu> There are bifunctors, which have bimaps, if that helps you at all.
16:24:52 <kmc> instance Functor (Either t) where { fmap _ (Left x) = Left x; fmap f (Right y) = Right (f y) }
16:24:56 <_Ray_> So it's analogous to curryfication, but with types?
16:24:59 <Peaker> copumpkin: maybe algebra-land can be extended with qualifications?
16:25:01 <elliott> <Peaker> Hmm.. how do dependent functions map to algebraic definitions?
16:25:06 <kmc> _Ray_, yeah
16:25:09 <elliott> Peaker: I think you can consider them like sums and products
16:25:16 <copumpkin> Peaker: it seems like it'd just turn into category theory :P
16:25:22 <Peaker> elliott: did you see my question about (a -> r) -> r?
16:25:30 <elliott> (thus, presumably, the Martin-Löf notation for them)
16:25:33 <elliott> Peaker: no
16:25:40 <copumpkin> elliott: how?
16:26:03 <Peaker> elliott: Either a b -> c  ~=  (a -> c, b -> c)   because:  (c ^ (a+b)) = (c ^ a * c ^ b)
16:26:20 <Peaker> elliott: How do you show why:  (forall r. (a -> r) -> r) ~= a ?
16:26:21 <elliott> copumpkin: well cardinality-wise, you can say |(x:A) -> B| == product (x \in A) B
16:26:29 <Eduard_Munteanu> Well, you can think of it as r ^ (r ^ a), no?
16:26:43 <copumpkin> Eduard_Munteanu: the r is quantified
16:26:44 <elliott> copumpkin: at least iirc, I may have totally stuffed that up :)
16:26:50 <Peaker> Eduard_Munteanu: yeah, except the "r" must be forall'd
16:26:57 <elliott> Peaker: well, that might be difficult :P
16:26:59 <copumpkin> elliott: you can, but that doesn't really help him
16:27:17 <elliott> copumpkin: well yeah, I was answering the question he asked, which may not actually help him achieve his goal :P
16:27:53 <copumpkin> but I guess it does answer what he was asking :)
16:28:01 <copumpkin> elliott++
16:28:05 <Eduard_Munteanu> How does that make much of a difference? Products are still products regardless if you've got polymorphism there.
16:28:09 <elliott> I guess ((r:Set) -> (a -> r) -> r) --> product (r \in Set) r^(r^a)
16:28:23 <elliott> but I don't think that's = |a| at all
16:28:37 <copumpkin> you need to invoke parametricity at some point
16:28:41 <elliott> yeah
16:28:56 <kmc> parametricity is a quotient of some kind
16:29:11 <copumpkin> I don't think you could prove they're isomorphic in agda, for example
16:29:21 <kmc> and they're not isomorphic in Haskell :)
16:29:22 <copumpkin> at least not directly
16:29:23 <kmc> but for dumb reasons
16:29:32 <hpc> kmc: for seq reasons?
16:29:35 <kmc> yeah
16:29:40 <hpc> those don't count :D
16:29:54 <_Ray_> kmc: So Either t is a type constructor as well, correct?
16:29:56 <elliott> hmm, does it work to add a parametricity axiom to Coq or Agda?
16:29:59 <kmc> _Ray_, yes
16:30:06 <elliott> I guess mu-Agda is what I'm thinking about that did it. it was called mu-Agda right
16:30:06 <elliott> ?
16:30:18 <_Ray_> Ah OK, I think I get it.
16:30:22 <Eduard_Munteanu> Parametricity is an axiom?
16:30:27 <kmc> _Ray_, the application of type constructors is classified by "kinds", the way the application of functions is classified by types
16:30:28 <kmc> :k Either
16:30:29 <lambdabot> * -> * -> *
16:30:32 <kmc> :k Either Int
16:30:33 <lambdabot> * -> *
16:30:33 <kmc> :k Either Int Char
16:30:34 <lambdabot> *
16:30:41 <edwardk> dylukes: quite probably. i was planning on working on it today, but have been spending the day hacking on other stuff
16:30:43 <_Ray_> (There's an implicit forall t. instance Functor (Either t) ...
16:30:45 <_Ray_> )
16:30:50 <dylukes> alrighty :)
16:30:55 <kmc> :k ReaderT
16:30:55 <lambdabot> * -> (* -> *) -> * -> *
16:31:00 <kmc> yeah _Ray_
16:31:23 <elliott> Eduard_Munteanu: didn't say that :)
16:31:57 <Eduard_Munteanu> I think you can prove parametricity for Agda functions in Agda without any postulate, no?
16:32:16 <Eduard_Munteanu> Or talk about it.
16:32:26 <elliott> copumpkin implied not.
16:32:35 <copumpkin> no, you can't
16:33:20 <Eduard_Munteanu> Interesting.
16:35:04 <Eduard_Munteanu> copumpkin: any idea what it boils down to? I mean, if you start working on the Set + (->) category, what sort of block do you hit?
16:35:06 <BMeph> Isn't it "supposed" to be "forall f r. (a -> r) -> f r ~= f a" ? :)
16:35:29 <Peaker> kmc: btw, what are the seq reasons for breaking the isomorphism?
16:35:34 <BMeph> Well, "forall (f :: * -> *) r. (a -> r) -> f r ~= f a" ? :)
16:35:43 <Peaker> Oh you can expose the bottomness of functions because of "seq" too, bah @ seq!
16:36:06 <elliott> Peaker: I was assuming you were doing the "pretend _|_ doesn't exist" thing
16:36:11 <Peaker> elliott: I am
16:36:19 <Peaker> elliott: I was just curious about the seq reasons as well :)
16:36:25 <Jafet> @vixen do you like exposed bottoms?
16:36:26 <lambdabot> yah, i like
16:36:29 <Peaker> (though seq should be abolished, along with the lifting of type products, IMO)
16:37:03 <Peaker> (in favor of a Seq type-class that may or may not have no-op instances for forcing products)
16:38:31 <copumpkin> the goal boils down to x (c (λ x' → x')) ≡ c x
16:38:38 <copumpkin> or x (c id) = c x
16:39:04 <napping> hat looks like agda
16:39:15 <copumpkin> onoes
16:39:39 <napping> and that's where I've got stuck trying to show parametricity, yes
16:40:06 <Eduard_Munteanu> Well, I'm not really sure what those are.
16:40:22 <copumpkin> x  : .A → .R, and c  : {R : Set} → (.A → R) → R
16:40:37 <Eduard_Munteanu> Ah.
16:40:57 <Peaker> what's the . mean?
16:41:04 <copumpkin> they just weren't actually in scope at the time
16:41:27 <Peaker> is it valid Agda syntax or just a convention for mentioning "from outside"?
16:41:45 <copumpkin> it is valid agda syntax but it doesn't mean the same thing
16:41:51 <copumpkin> but it's what the goal view shows you
16:42:07 <Eduard_Munteanu> Yeah, '.' also describes irrelevant arguments IIRC
16:42:10 <copumpkin> those dots are seriously overloaded everywhere
16:42:11 <copumpkin> yeah
16:42:21 * hackagebot primitive 0.4 - Wrappers for primitive operations  http://hackage.haskell.org/package/primitive-0.4 (RomanLeshchinskiy)
16:42:23 * hackagebot vector 0.8 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.8 (RomanLeshchinskiy)
16:42:56 <copumpkin> edwardk will be happy
16:42:58 <Peaker> "irrelevant" means that they're passed so the passer proves he has them, and the passee ignores them? (and they're probably erased before runtime?)
16:43:12 <edwardk> copumpkin: ?
16:43:13 <copumpkin> they're erased even at compile time, straight after being checked
16:43:19 <copumpkin> edwardk: new vector with lots of instances
16:43:30 <edwardk> copumpkin: sweet. how many do i have to remove from vector-instances?
16:43:39 <copumpkin> "Functor, Monad, Applicative, Alternative, Foldable and Traversable instances for boxed vectors (WARNING: they tend to be slow and are only provided for completeness)"
16:43:54 <Eduard_Munteanu> Peaker: they're meant for proof terms, so they don't affect runtime performance AFAIK
16:43:55 <copumpkin> Alternative, eh
16:44:33 <Eduard_Munteanu> You could have a function that takes some "real" arguments and a proof that they satisfy some property. The proof is only needed for typechecking.
16:44:45 <copumpkin> for example
16:44:46 <copumpkin> unamb
16:44:46 <edwardk> copumpkin: great!
16:44:54 <copumpkin> you might want it to carry a proof that the two things are equal
16:44:55 <edwardk> copumpkin: i'll go strip them out of vector-instances
16:45:00 <copumpkin> edwardk: :D
16:45:23 <edwardk> that or i can just make everything depend on vector and move the instances out
16:45:46 <kmc> preflex, seen rl
16:45:46 <preflex>  rl was last seen on #go-nuts 55 days, 2 hours, 15 minutes and 44 seconds ago, saying: Rune makes sense in a way though; the term "character" is overloaded
17:01:23 <edwardk> copumpkin: he forgot MonadPlus =(
17:01:38 <copumpkin> edwardk: onoes!
17:01:44 <copumpkin> you'll have to wait another year
17:01:48 <edwardk> or 2
17:02:50 <Jafet> Heh
17:03:36 <Jafet> Rodgers and Hammerstein are somehow popular here
17:04:59 <edwardk> copumpkin: i emailed him asking him for it
17:05:01 <edwardk> we can hope
17:05:10 <copumpkin> now you can set your timer for a year
17:05:16 <edwardk> yeah
17:05:29 <joe6> need some help, please? I am trying to use a file which has been linked (thru ld) with hsffig. Is that possible?
17:05:50 <joe6> i can object files which are not linked to work fine.
17:06:09 <joe6> but, am having trouble with using linked files.
17:07:19 <Eduard_Munteanu> What's the idea behind   forall r. (a -> r) -> r ~= a   anyway?
17:08:13 <Eduard_Munteanu> (In what sense is that true?)
17:08:14 <copumpkin> the only way  forall r. (a -> r) -> r could produce an r, given that it knows nothing about r, is by applying (a -> r) to an a
17:08:20 <copumpkin> which means it has a secret a lying around somewhere
17:08:49 <Eduard_Munteanu> Auto can do it the other way around.
17:08:59 <Eduard_Munteanu> (quite easily)
17:09:04 <copumpkin> yeah, you can translate back and forth easily
17:09:29 <copumpkin> but proving that the translations are inverses (in one direction) doesn't work
17:09:29 <Eduard_Munteanu> Ah, so you need an 'a'.
17:10:07 <copumpkin> that bit is fine
17:10:25 <copumpkin> you'd prove pointwise equality in agda
17:10:30 <copumpkin> since you don't get extensionality of functions
17:10:43 <Eduard_Munteanu> q' : {A R : Set} → A × ((A → R) → R) → A
17:10:46 <Eduard_Munteanu> q' = proj₁
17:10:52 <Eduard_Munteanu> :)
17:11:05 <copumpkin> why do you have a pair?
17:11:23 <joe6> i want to define address locations for symbols used in the object file.
17:11:29 <Eduard_Munteanu> Well, obviously A isn't universally quantified so I know about it.
17:11:40 <joe6> and, I am not sure if there is a better way than doing it with the linker
17:11:45 <copumpkin> that isn't a correct translation
17:12:09 <hpaste> copumpkin pasted “cont” at http://hpaste.org/50745
17:13:30 <Eduard_Munteanu> oh, right, my forall r is also misplaced
17:13:47 <_Ray_> How could I know how many typeclasses a type fits in? Say, if Num is in Eq, Ord, Show, ...
17:14:48 <Eduard_Munteanu> _Ray_: maybe you mean "if Int is in Eq, Ord, Show", no?
17:15:12 <_Ray_> Hrm, I guess I do mean that. Num is the typeclass, Int is the type?
17:15:33 <monochrom> ":info Int" at ghci prompt tells you its type classes
17:16:20 <Eduard_Munteanu> copumpkin: still, how come people think this is actually true. What if A = \bot?
17:16:29 <_Ray_> Cool, thanks :)
17:16:29 <Eduard_Munteanu> Oh!
17:16:34 <Eduard_Munteanu> This is about Haskell.
17:16:45 <copumpkin> Eduard_Munteanu: even in agda
17:17:21 * hackagebot vector-instances 2.0.3 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-2.0.3 (EdwardKmett)
17:17:29 <_Ray_> How does Haskell know when (-4) means the function that subtracts 4, or the additive inverse of 4?
17:17:33 <edwardk> that should remove the instances that overlap with the new version of vector
17:17:45 <Eduard_Munteanu> _Ray_: -4 is a special case
17:17:51 <edwardk> _ray_ the 'sectioning' rules have a special case for -
17:18:01 <monochrom> haskell knows that -4 is always the additive inverse of 4
17:18:05 <_Ray_> Ah, OK.
17:18:13 <edwardk> you have to use subtract or minus to section it
17:18:23 <_Ray_> I'd have to explicitly say ((-) 4)
17:18:37 <Eduard_Munteanu> _Ray_: that'd be 4 -
17:18:40 <edwardk> subtract
17:18:44 <monochrom> > (subtract 4) 1
17:18:45 <lambdabot>   -3
17:18:48 <monochrom> \∩/
17:18:55 <_Ray_> Hrmph. flip (-) then xD
17:18:58 <fryguybob> > ((-) 4) 1
17:18:59 <lambdabot>   3
17:19:09 <Jafet> @src subtract
17:19:09 <lambdabot> subtract x y = y - x
17:19:17 <Jafet> @. pl src subtract
17:19:18 <lambdabot> (line 1, column 1):
17:19:18 <lambdabot> unexpected end of input
17:19:18 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
17:19:25 <copumpkin> > map (– 5) [1..10]
17:19:27 <lambdabot>   [-4,-3,-2,-1,0,1,2,3,4,5]
17:19:30 * copumpkin wins
17:19:46 <Jafet> copumpkin is dashing
17:19:49 <Eduard_Munteanu> copumpkin: do you mean it's somehow true in Agda, yet can't be proved without additional postulates?
17:20:18 <copumpkin> Eduard_Munteanu: oh, I just mean I can write both directions of the translation in agda
17:20:31 <copumpkin> it's just proving both directions of the inverse that requires parametricity
17:20:41 <copumpkin> one of them is trivial
17:21:00 <Eduard_Munteanu> I have a feeling this gets down to bottoms, no?
17:21:13 <copumpkin> how do you mean?
17:21:45 <Eduard_Munteanu> I mean I can't see how (a -> r) -> r can produce an r for every such set a.
17:22:00 <Eduard_Munteanu> Only if all sets contain bottoms.
17:22:31 <copumpkin> all it needs to do is produce an A
17:22:36 <copumpkin> the caller provide (A -> R)
17:22:50 <copumpkin> you pass your A to the caller's provided function
17:22:50 <copumpkin> and then you get the desired return type
17:23:20 <copumpkin> test :: forall a. a -> (forall r. (a -> r) -> r)
17:23:27 <copumpkin> I wonder if djinn can handle that
17:23:30 <copumpkin> @djinn forall a. a -> (forall r. (a -> r) -> r)
17:23:30 <lambdabot> -- f cannot be realized.
17:23:32 <ddarius> It can't.
17:23:37 <Eduard_Munteanu> What happens for A = \bot then?
17:23:41 <kmc> Eduard_Munteanu, you're worried about the case where 'a' is the empty type?
17:23:46 <Eduard_Munteanu> kmc: yeah
17:23:51 <kmc> that's fine.  both ((Void -> r) -> r) and Void are uninhabited
17:23:53 <kmc> so they're isomorphic
17:24:16 <Eduard_Munteanu> Ah, indeed, but you can't do the actual application, I see.
17:24:34 <kmc> application?
17:24:44 <kmc> @djinn ((Void -> r) -> r) -> Void
17:24:44 <lambdabot> -- f cannot be realized.
17:24:51 <Eduard_Munteanu> < copumpkin> you pass your A to the caller's provided function
17:25:00 <kmc> hmm, that's double-negation elimination
17:25:10 <Eduard_Munteanu> Oh.
17:25:17 <kmc> Void -> ((Void -> r) -> r)  is trivial
17:25:36 <copumpkin> Eduard_Munteanu: you can always apply it
17:25:52 <copumpkin> if in the unlikely case you actually have a value of the empty hand in your hand
17:25:53 <kmc> but the other direction isn't constructively valid i guess
17:25:55 <copumpkin> you can do what you want with it
17:26:18 <copumpkin> either by applying it directly (it's no different from any other type in that respect)
17:26:22 <kmc> hmm
17:26:25 <copumpkin> or by applying explosion
17:26:34 <Eduard_Munteanu> I wonder if Agda + excluded middle can do it.
17:26:39 <copumpkin> do what?
17:26:46 <copumpkin> it can prove both ways of that correspondence!
17:26:50 <copumpkin> I pasted code that did that :P
17:26:52 <kmc> no, i think it should be constructively valid
17:27:04 <copumpkin> it's proving they're inverses that it can't do
17:27:10 <Eduard_Munteanu> Wait, I'm confused :)
17:27:29 <Eduard_Munteanu> What's the point of   pf₂ : {A : Set} (c : Cont A) → {R : Set} → ∀ x → f (g c) {R} x ≡ c x    then?
17:27:33 <copumpkin> :t let f :: forall a. a -> (forall r. (a -> r) -> r); f x c = c x in f
17:27:34 <lambdabot> forall a r. a -> (a -> r) -> r
17:28:00 <copumpkin> :t let g :: forall a. (forall r. (a -> r) -> r) -> a; g c = c id in g
17:28:01 <lambdabot> forall a. (forall r. (a -> r) -> r) -> a
17:28:27 <copumpkin> Eduard_Munteanu: that's the half of the inverse proof that can't be proven
17:29:50 <copumpkin> showing the isomorphism requires four parts
17:29:58 <copumpkin> the two conversions back and forth
17:30:03 <Eduard_Munteanu> Oh, so what you can't prove is that they're mutual inverses.
17:30:11 <copumpkin> and then two proofs showing the conversions are inverses
17:30:11 <copumpkin> yep
17:30:16 <copumpkin> I can prove three of those four things
17:30:41 <copumpkin> for the last one, I need to invoke the fact that I "know nothing about the quantified set"
17:31:07 <tgeeky> edwardk: your 'keyed' package has the source listed as github.com/../adjunctions
17:31:17 <edwardk> tgeeky: woops
17:31:19 <Eduard_Munteanu> 3 out of 4 reminds me of de Morgan laws
17:31:33 <copumpkin> it's sad, eh :)
17:31:39 <copumpkin> so many "obvious" things we can't do
17:31:41 <ddarius> @quote MegaMonad
17:31:42 <lambdabot> No quotes match. Just what do you think you're doing Dave?
17:31:49 <copumpkin> ooh
17:31:51 <copumpkin> I want a MegaMonad
17:32:02 <ddarius> @google site:haskell.org MegaMonad
17:32:04 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2004-December/007880.html
17:32:05 <lambdabot> Title: [Haskell-cafe] OT: A little AI fun
17:32:39 <Eduard_Munteanu> What do you get without the inverses part? A mere logical equivalence?
17:36:52 <copumpkin> I guess
17:37:21 * hackagebot keys 2.1.1.1 - Keyed functors and containers  http://hackage.haskell.org/package/keys-2.1.1.1 (EdwardKmett)
17:38:05 <edwardk> tgeeky: fixed
17:38:12 <tgeeky> edwardk: cheers
17:39:04 <copumpkin> hmm, trying to think of a good interface to this memory type I'm writing
17:42:04 <Eduard_Munteanu> Memory type?
17:42:19 <ddarius> new, set, get ?
17:43:33 <copumpkin> I'm not doing the mutable version right now, as I don't need it
17:44:08 <ddarius> Yes, but it should just be a cut-down version of the IntMap interface I would think, unless I'm misunderstanding.
17:44:16 <ddarius> I'm guessing a lot right now.
17:44:26 <copumpkin> I have things like getInt16be :: Address a => Memory a -> a -> Maybe Int16
17:44:42 <copumpkin> it's represented as sort of an interval map of vectors of bytes
17:44:47 <copumpkin> getWord64be :: Address a => Memory a -> a -> Maybe Word64
17:45:07 <copumpkin> I also have something like   getInt16 :: Address a => e `Tagged` Memory a -> a -> Maybe Int16, where e is in an Endian typeclass
17:45:16 <copumpkin> not sure I like it, but I'm just playing around with an API
17:46:24 <copumpkin> so contiguous intervals of memory are mapped to a flat structure for better locality
17:46:30 <Eduard_Munteanu> How about ... -> Maybe b   for b in some typeclass?
17:46:31 <copumpkin> but there can also be unmapped intervals
17:46:52 <copumpkin> I was playing with interpret :: (Address a, Endian e) => Interpretation t -> e `Tagged` Memory a -> (a -> Maybe t)
17:47:00 <copumpkin> but I'm not sure I like that
17:47:27 <tgeeky> is that an infix type constructor?
17:47:43 <copumpkin> yeah, but that was just for the fun of it
17:47:47 <copumpkin> I'll probably take it out
17:47:49 <tgeeky> never seen it
17:47:58 <copumpkin> you need a language extension for it
17:48:06 <copumpkin> TypeOperators
17:48:16 <Eduard_Munteanu> tgeeky: sure... (->), (~>) ...
17:49:22 <copumpkin> the thing is, you typically don't want to treat the entire chunk of memory the same way
17:49:39 <copumpkin> so I can't really treat it as a simple container type
17:49:49 <Eduard_Munteanu> What's this for?
17:50:03 <copumpkin> coming up with a good abstraction for what people typically do with memory
17:50:08 <copumpkin> for binary analysis mostly
17:50:34 <copumpkin> you'd write an abstract loader that takes an object file and loads it into one of these
17:50:41 <copumpkin> then you can dereference pointers into it
17:50:47 <copumpkin> and it'll take care of mapping it to the correct data and type
17:51:28 * _Ray_ is about to post his "Why C++ uses the term covariant" blog post to /r/cpp... to the lions I go.
17:51:35 <ddarius> copumpkin: If you could just apply a "type" to a block of memory then you could just mmap...
17:51:50 <tgeeky> Eduard_Munteanu: hm. Yeah. I said to myself "of course, type functions are functions, doofus!"
17:52:02 <tgeeky> Eduard_Munteanu: I don't think I've seen ~> in type constructors though
17:52:14 <tgeeky> s/constuctors/signatures/
17:52:18 <copumpkin> ddarius: well, I don't want this to be actual pointers, because I don't necessarily have the permission to put things into the actual locations needed
17:52:36 <copumpkin> the iphone bootloaders, for example, expect to be loaded at a specific address
17:52:37 <ddarius> Pointers don't require this.
17:52:51 <tgeeky> copumpkin: that's a property of all bootloaders, I think?
17:52:53 <mike-burns> I have a running ghci session. How can I `cabal install' a package such that the existing ghci can :m it?
17:52:53 <copumpkin> sure
17:53:10 <mike-burns> Or, what do I do in ghci to get it to find the newly-installed package?
17:53:22 <copumpkin> mike-burns: you don't :P
17:53:25 <copumpkin> as far as I know
17:53:41 <mike-burns> Oh but I have all these variables set just so!
17:53:43 <copumpkin> ddarius: I don't see what you mean
17:53:53 <copumpkin> mike-burns: you can ask ghci to give you your current variable bindings
17:53:56 <copumpkin> so you don't forget them :P
17:54:02 <mike-burns> Oh! Perfect.
17:54:07 <copumpkin> :show bidings iirc
17:54:10 <copumpkin> bindings
17:54:30 <mike-burns> Yeah!
17:54:41 <mike-burns> OK that's helpful to know. Thanks, copumpkin .
17:54:45 <copumpkin> np :)
17:54:59 <tgeeky> holy crap. The floodwaters in Vermont are like huge torrents. Crazy strong flooding.
17:56:42 <ddarius> copumpkin: I may have misinterpreted you at one point.  At any rate, you have a block of memory -somewhere- or you can make one or you can mmap one.  If you could say "This block of memory is really this nice pretty (abstract) type" and then have accessors that would handle the "serialization" that may be reasonably pleasant to use.
17:57:54 <copumpkin> ddarius: this is mostly to represent an abstract memory space, possibly with holes. Basically a mapping Address -> Maybe Byte
17:58:21 <copumpkin> think of the kind of data type that IDA would use to represent a loaded binary
17:58:31 <copumpkin> with multiple segments and such
17:59:49 <ddarius> Okay.
18:00:12 <dented42> I have a fold sort of an operation, but I don't know what to call it. http://hpaste.org/50749 any thoughts?
18:00:46 <kmc> copumpkin, i wonder if there's anything to be gained by copying the way MMUs work and actually managing fixed-size pages rather than arbitrary intervals
18:01:14 <copumpkin> probably in terms of performance, but I'm mostly concerned with coming up with a sane API for it for now
18:02:39 <copumpkin> I need to be able to get things of different types out of it, depending on the index
18:02:57 <Jafet> foldUntil?
18:02:58 <copumpkin> which suggests something like all those getInt32be functions
18:03:13 <copumpkin> however, usually contiguous chunks of memory are treated in a similar manner
18:03:22 <ddarius> copumpkin: Ultimately I think you're more or less screwed.  You could possibly encode a hierarchy of "types" into the type corresponding to different levels of following pointers.
18:03:24 <copumpkin> so they could almost be treated like a container type for the type in question
18:03:52 <copumpkin> ddarius: yeah, it smells pretty dependent, doesn't it
18:03:59 <copumpkin> next up, binary analysis in agda!
18:04:00 <copumpkin> ;)
18:04:37 <copumpkin> oh actually
18:04:38 <copumpkin> hmm
18:04:45 * copumpkin tries a trick
18:05:28 <benedikt> what is the string literal `|||` used for in haskell?
18:05:40 <copumpkin> that isn't a string literal
18:05:44 <copumpkin> :t (|||)
18:05:45 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
18:05:54 <ddarius> And generally string literals are used as string literals.
18:06:16 <copumpkin> (b ~> d) -> (c ~> d) -> (Either b c ~> d)
18:06:20 <copumpkin> does that make a bit more sense?
18:06:25 <copumpkin> :t either
18:06:26 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:06:27 <benedikt> ddarius: in the context of my question, it is a string literal. but yes, thanks.
18:07:05 <ddarius> benedikt: I recommend, in the future, the simpler question: "What is ||| used for in Haskell?"
18:07:36 <elliott> What is the answer to the string literal yielded by enclosing this sentence within double quotation marks?
18:08:33 <cmccann_> elliott: "yields falsehood when preceded by its quotation"
18:08:34 <kmc> "What" ain't no country I've ever heard of
18:08:56 <penryu> they speak English there.
18:09:30 <benedikt> cmccann_: "is only a sentence when preceeded by itself"
18:09:47 <tgeeky> elliott: "mu"
18:10:05 <azaq23> dented42: The crucial difference between a complete fold and your fold is that your function doesn't take a default value but uses the one in the correct position (your variable s) directly for the
18:10:05 <azaq23> function, instead giving back Nothing if as = [], and Just ... otherwise
18:10:06 <roconnor> > "\"What is the answer to the string literal yielded by enclosing this sentence within double quotation marks?\"
18:10:07 <lambdabot>   <no location info>:
18:10:07 <lambdabot>      lexical error in string/character literal at end o...
18:10:12 <roconnor> > "\"What is the answer to the string literal yielded by enclosing this sentence within double quotation marks?\""
18:10:13 <lambdabot>   "\"What is the answer to the string literal yielded by enclosing this sente...
18:10:22 <kmc> i used to have a T-shirt that just said "RECURSION" in big block letters
18:10:30 <kmc> it confused the hell out of people
18:10:57 <copumpkin> lol
18:11:53 <benedikt> what is (|||) called so I can read about it
18:12:00 <elliott> |||
18:12:09 <dented42> azaq23: that's because the value being returned might not be of the same type as the value that gets accumulated.
18:12:15 <Jafet> @index (|||)
18:12:15 <lambdabot> Control.Arrow
18:12:21 <benedikt> Jafet: thanks.
18:12:25 <tgeeky> benedikt: it's used to mean different things, but it's usually in Arrow
18:13:17 <edwardk> @type (|||)
18:13:18 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
18:13:57 <dobblego> @hoohle (a -> b) -> (b -> a) -> a -> b
18:13:58 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
18:13:58 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
18:13:58 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
18:14:09 <dobblego> @type \f g -> f . g . f
18:14:10 <lambdabot> forall a b. (a -> b) -> (b -> a) -> a -> b
18:16:25 <parcs> :t (`id` do ())
18:16:25 <lambdabot> forall t. (() -> t) -> t
18:16:27 <ion> @type (|||) `asAppliedTo` (undefined :: a -> b)
18:16:28 <lambdabot> forall b d c. (b -> d) -> (c -> d) -> Either b c -> d
18:16:37 <ion> @type either
18:16:39 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:18:31 <tgeeky> :t asAppliedTo
18:18:32 <lambdabot> forall t b. (t -> b) -> t -> t -> b
18:18:39 <tgeeky> @src asAppliedTo
18:18:40 <lambdabot> Source not found. It can only be attributed to human error.
18:18:49 <tgeeky> @index asAppliedTo
18:18:49 <lambdabot> bzzt
18:19:02 <tgeeky> where is that function? lambdabot builtin?
18:19:27 <ion> a `asAppliedTo` b = a `asTypeIn` ($ b)
18:19:33 <ion> @type asTypeIn
18:19:35 <lambdabot> forall a b. a -> (a -> b) -> a
18:20:02 <ion> @src asTypeIn
18:20:03 <lambdabot> a `asTypeIn` f = a where _ = f a
18:20:03 <lambdabot> infixl 0 `asTypeIn`
18:20:11 <azaq23> dented42: Yes - I would try to emphasize the difference by not directly naming it a fold, as in "foldSomething", but anyhow it goes in the same direction, so not sure what that would be called - I
18:20:12 <azaq23> haven't seen some builtin function or anything which might give a clue how to name this - maybe "eitherCollectFold", but that's a bit awkward
18:21:11 <parcs> :t (`id` \_ -> ())
18:21:12 <lambdabot> forall t t1. ((t -> ()) -> t1) -> t1
18:22:29 <dented42> azaq23: yeah, I'm certainly not planning to call it 'foldThing', I just needed something to put in the paste. I was thinking something along the lines of 'collectPart', but it doesn't seem particularly fitting either.
18:23:06 <_Ray_> Is it wrong to intuitively explain typeclasses as interfaces?
18:23:25 <tgeeky> it's not that helpful
18:23:31 <tgeeky> in my humble opinion
18:23:45 <copumpkin> my opinion, on the other hand, is not humble
18:24:03 <tgeeky> there is a strong tendenacy to relate programming concepts that imperative (or "OO") languages use to those used in a functional language
18:24:08 <tgeeky> the problem is, that situation is backwards
18:24:27 <tgeeky> [mathematics] -> [functional programming] -> [abstractions] <- [imperative programming models]
18:24:55 <ion> [square brackets] → [glyphs]
18:24:59 <kmc> _Ray_, "interfaces" in a general sense or "interface" the Java keyword?
18:25:46 <tgeeky> _Ray_: There's an excellent paper "Types are calling conventions."
18:25:48 <shachaf> _Ray_: Interfaces in the Java sense are a bit similar to type classes, but not the same thing.
18:26:32 <mike-burns> It's only the wrong way to explain it if it doesn't help the person understand it better.
18:26:41 <mike-burns> So we can't help you, but we'd love to discuss it anyway.
18:31:25 <kmc> mike-burns, new channel motto :D
18:31:32 <tgeeky> hehe
18:31:43 <kmc> _Ray_, i'm quite in favor of seeing type classes as generic interfaces / APIs
18:32:15 <kmc> and quite against equating them with specific features in Java (or any other language, except maybe Miranda or the like)
18:35:20 <Sgeo_> http://hackage.haskell.org/packages/archive/hint/0.3.3.2/doc/html/Language-Haskell-Interpreter.html#g:10
18:35:28 <Sgeo_> That =n should be =\n
18:35:35 <dylukes> I've noticed the more pages I put on my screen at once the easier it is to read ebooks...
18:35:42 <dylukes> (novel/dialogue type stuff though, not technical)
18:35:58 <tgeeky> dylukes: I was going to say :o
18:36:16 <tgeeky> I have a handy floating-4 monitor setup
18:36:21 <tgeeky> I try to keep things as big as possible :o
18:36:35 <luite> how big?
18:36:50 <tgeeky> this big: | |
18:36:52 <tgeeky> hehe
18:36:57 <tgeeky> upside down T shape
18:37:00 <tgeeky> center two are 24 inch WS
18:37:08 <tgeeky> outer two (on bottom) are 19 inch 5x4
18:43:24 <tgeeky> has anyone in here implemented monads in Ruby?
18:46:06 <dobblego> Yes.
18:46:33 <shachaf> What does it mean to "implement monads"?
18:46:46 <monochrom> to write "instance Monad Blah where"
18:47:01 <tgeeky> written a library/gem that uses the monad model
18:47:10 <elliott> what's the monad model
18:47:22 <monochrom> oh, sorry, ruby, nevermind
18:47:22 <dobblego> when you call it mapM instead of doesStuffToEachOtherStuffFactorySquizzle, it's implementing monads
18:47:36 <elliott> can we rename mapM to doesStuffToEachOtherStuffFactorySquizzle? that would be cool
18:47:39 <monochrom> I guess I am in the wrong channel!
18:47:56 <copumpkin> tgeeky: monads can't really exist in ruby
18:48:00 <monochrom> now I should be in the right channel!
18:48:01 <tgeeky> copumpkin: oh?
18:48:03 <copumpkin> but you can implement things that resemble them
18:48:14 <tgeeky> copumpkin: there are several librarys that claim to implement them
18:48:21 <tgeeky> mostly using lots of lambdas
18:48:22 <copumpkin> what really makes a monad is the type-level component
18:48:24 <copumpkin> with parametric types
18:48:35 <copumpkin> you can implement a lot of the value-level parts of them
18:48:44 <copumpkin> so that it feels like a monad
18:48:45 <tgeeky> you can implement the type level parts as well
18:48:54 <shachaf> tgeeky: I think most of those articles don't understand what "them" are. :-)
18:48:59 <copumpkin> tgeeky: how?
18:49:01 * shachaf isn't quite sure what tgeeky is getting at.
18:49:09 <monochrom> ruby has a type level?
18:49:15 <copumpkin> ruby has one type
18:49:17 <shachaf> Well, Ruby has a type.
18:49:28 <elliott> copumpkin: you can do the type-level part of monads, just at runtime
18:49:37 <copumpkin> elliott: what does that even mean?
18:49:42 <elliott> modulo ruby's types being really weak
18:50:02 <elliott> copumpkin: well, insofar as you can define "a list of Xs"
18:50:11 <elliott> which is checked by checking the object is a list, and then checking every element is an X
18:50:19 <elliott> that fails for any kind of phantom type obviously
18:50:28 <elliott> or even something like Either
18:50:29 <tgeeky> you can implement type checking by pattern matching on method names, and use stripped classes (::Reader, ::Writer, ::State) to represent types
18:50:38 <elliott> hmm, actually Either is possible
18:50:56 <dolio> You can do monads in Ruby by implementing Haskell and then writing Haskell.
18:51:04 <monochrom> hahaha
18:51:17 <shachaf> elliott: You don't have generic monad operations, though, which is more or less the point of using the word "monad".
18:51:19 <Sgeo_> I think I can express what makes me uncomfortable about duck-typing lately in terms of the microwave metapho.
18:51:21 <Sgeo_> metaphor.
18:51:29 <elliott> shachaf: Duck typing!!!!!!!!!!
18:51:30 <shachaf> Microwaving a burrito?
18:51:34 <Sgeo_> Why did I say that here?
18:51:35 * kmc puts a burrito in Sgeo_'s metaphor
18:51:39 <elliott> Duct typing.
18:51:39 <shachaf> elliott: Can you duck-type return?
18:51:42 <elliott> Duct taping.
18:51:43 <kmc> duct taping
18:51:49 <monochrom> duck-channeling
18:52:08 <elliott> shachaf: Sure, it just has really bad type inference. You need to add a hint with the "X." disambiguation syntax:
18:52:09 <elliott> Foo.return 99
18:52:10 <tgeeky> here is one version (of the Id monad): http://stackoverflow.com/questions/2709361/monad-equivalent-in-ruby
18:52:28 <shachaf> elliott: Well, but then you can't write any generic monad operations.
18:52:47 <elliott> shachaf: monadic_value.class.return 99
18:52:59 <tgeeky> shachaf: like that article has 'sequence(m)'?
18:53:02 <shachaf> That only works if you have a value. :-)
18:53:02 <monochrom> how many monad equivalents are there in ruby? I mean published so far
18:53:06 <elliott> shachaf: I don't see why you oculdn't just pass around the monad class, actually
18:53:08 <elliott> generic_operation(Foo)
18:53:10 <shachaf> tgeeky: What article?
18:53:11 <tgeeky> monochrom: at least 4
18:53:13 <tgeeky>  An internal array iterator [m a] => m [a]
18:53:13 <tgeeky> def sequence(m)
18:53:13 <tgeeky>   snoc = lambda {|xs, x| xs + [x]}
18:53:13 <tgeeky>   lambda {|ms| ms.inject(m.unit[[]], &(lambda {|x, xs| x.liftM2[snoc, xs] }))}
18:53:15 <tgeeky> end
18:53:20 <tgeeky> http://stackoverflow.com/questions/2709361/monad-equivalent-in-ruby
18:53:23 <shachaf> elliott: Right, kmc-style.
18:53:38 <tgeeky> this isn't a very good one: https://github.com/panesofglass/RubyOnMonads
18:53:48 <elliott> shachaf: Just looks like a language without typeclasses to me :)
18:54:08 <tgeeky> here is something that is rather close to Maybe https://github.com/raganwald/andand
18:54:27 <monochrom> it seems bad news that there are 4 and counting. if one of them is any good, you wouldn't see 4 and expect more to come
18:54:35 <shachaf> tgeeky: That sequence doesn't look generic to me.
18:54:54 <tgeeky> monochrom: I dispute that statement.
18:55:00 <elliott> monochrom: this is Ruby, they reimplement everything
18:55:08 <monochrom> for example hackage has like 4 iteratee libraries too because each one has a problem
18:55:09 <shachaf> elliott: m.class.return doesn't work for e.g. writing sequence.
18:55:20 <tgeeky> There are dozens of implementations of the same thing in Haskell -- it's a common argument against the efficacy of the Haskell community (right or wrong)
18:55:36 <shachaf> Hackage has four different iteratee libraries, each one better than the other three.
18:55:41 <elliott> shachaf: Yeah, you need to pass the class in unless you mandate at least one element.
18:56:20 <dolio> shachaf: Exactly.
18:56:22 <shachaf> Looks like somebody didn't pass their monad class.
18:57:19 <monochrom> no, I am not arguing against the efficacy of either the haskell community or the ruby community. I am talking about the languages. language problems are what force you to come up with different instances because the language doesn't let you write one to subsume them all
18:58:29 <shachaf> monochrom: I hate how there's more than one program written in Haskell.
18:58:31 <tgeeky> monochrom: that's fine, but if there are a dozen implemtations of something in a language like Ruby without a strong system of organization underneath (like a type system), then the commonest cause of duplication is ignorance and lack of awareness
18:58:36 <shachaf> If Haskell was good you'd only need to write one program.
18:59:12 <mike-burns> tgeeky: The wrapped gem, which I wrote, implements Maybe in Ruby. It has some monoidic methods.
18:59:53 <shachaf> mike-burns: What does that mean?
18:59:57 <elliott> shachaf: we just need to merge every program into GHC
19:00:05 <elliott> GHC will still depend on itself, but at least it'll have every tool you ever need
19:00:19 <Sgeo_> Would it at all make sense to have a State-like monad that uses phantom types? Would it be comfortable to work with?
19:00:20 <elliott> "to compile GHC, use "ghc --darcs" to take the code out of the repository, then "ghc --configure" ..."
19:00:23 <tgeeky> hm. some pedantry going on tonight
19:00:36 <Sgeo_> Say, SgState v a
19:00:46 <sm> has anyone here printed haskell source code from a mac recently ? how did you do it ?
19:00:58 <Sgeo_> And some functions that ... hmm, I don't see a way to do what I want to do
19:01:02 <copumpkin> tgeeky: what is ruby's category?
19:01:11 <tgeeky> copumpkin: mu
19:01:12 <copumpkin> what are monads in ruby's category?
19:01:15 <copumpkin> mu?
19:01:23 <tgeeky> copumpkin: I'm unasking the question.
19:01:37 * shachaf sighs.
19:01:43 <a215> somebody in here knows about FRP?
19:01:47 <copumpkin> a monad exists within a particular category
19:01:54 <a215> i'm looking to make a 3d game in a way that's cleanly cross platform
19:01:57 <a215> and well documented...
19:02:07 <mike-burns> I have a bridge I'll sell ya.
19:02:26 <tgeeky> copumpkin: I understand that, I think.
19:02:28 <a215> no such thing exists ??
19:02:34 <copumpkin> there is a category for ruby
19:02:41 <copumpkin> it's called a monoid, viewed as a category
19:02:53 <tgeeky> copumpkin: the entire language?
19:02:58 <copumpkin> its type system
19:03:01 <shachaf> copumpkin: Fool. Monads exist within four simultaneous rotations of a category.
19:03:04 <copumpkin> which is all haskell's monads are really talking about
19:03:24 <tgeeky> copumpkin: you can implement as strict of type system on top of Ruby's as you'd like, can you not?
19:03:47 <tgeeky> you could put: argument.is_a? (Blah) for every argument, for every class, in every method
19:03:48 <copumpkin> if I implement another language inside of haskell, have I written another category?
19:04:01 <tgeeky> copumpkin: no, but you can work in categories other than Hask
19:04:02 <copumpkin> it's getting into philosophy at that point :P
19:04:11 <copumpkin> I have a huge category theory library implemented in agda, which is written in haskell
19:04:31 <copumpkin> by simulating a type system in ruby, you're effectively writing a tiny type system in ruby
19:04:42 <copumpkin> it's an interpreter for that language, rolled in with a vague specification of it
19:04:44 <tgeeky> which is exactly what I expected to do
19:04:47 <copumpkin> okay, sure
19:04:52 <copumpkin> then you can implement all of category theory in ruby
19:05:00 <copumpkin> it's what the original comment by dolio was saying
19:05:10 <copumpkin> about implementing another language inside ruby and then you have CT
19:05:17 <copumpkin> a language doesn't need a syntax to be a language
19:05:24 <copumpkin> well, it sort of does :P
19:05:30 <copumpkin> but we're hiding that and rolling it up
19:05:38 <tgeeky> so he meant to say
19:05:45 <copumpkin> "yes"
19:05:46 <tgeeky> you can implement monads in ruby by writing Hask
19:05:53 <copumpkin> or by writing any language that can express them
19:06:02 <tgeeky> right, but my question was, _has_ anybody
19:06:05 <tgeeky> not _can_ anybody
19:06:17 <tgeeky> _has_ anybody _in here_
19:06:22 <copumpkin> yes, I guess :) as Apocalisp's post on stackoverflow shows
19:06:35 <tgeeky> copumpkin: hehe, hence the addition of in here
19:06:54 <copumpkin> it's a bit of a philosophical question as to whether they're ruby's monads, or monads for whatever you implemented inside of it
19:07:05 <copumpkin> speaking of which
19:07:07 <tgeeky> ok
19:07:18 <copumpkin> if you have a monoid viewed as a category
19:07:36 <copumpkin> are monads on those interesting at all?
19:07:49 <tgeeky> are monads in monoids interesting?
19:07:54 <tgeeky> s/in/on?
19:08:08 <copumpkin> well, monads are monoids! but in a different way
19:08:22 <tgeeky> I have seen hints of that idea (catsters, edwardk's work)
19:08:23 <Sgeo_> Suppose I have a monad, SgWorld s a.
19:08:43 * tgeeky supposes
19:09:02 <incluye> okay I'll start the supposition process
19:09:04 <elliott> i'm supposing
19:09:12 <incluye> supposer initialized
19:09:20 <elliott> supposer core overload
19:09:20 <copumpkin> suppository inserted
19:09:22 <Sgeo_> I want to write something like a -> SgWorld LoggedIn a, but only have it typecheck if the monad passed in to >>= is SgWorld LoggedIn a, and not, say, SgWorld Uninitialized a
19:09:24 <elliott> it's gone critical :(
19:09:28 <elliott> sorry i can suppose no more
19:09:34 <incluye> hypothetical situation has been initiated
19:09:39 <tgeeky> copumpkin: I think you made a parse error there
19:09:49 <copumpkin> Sgeo_: you sound like you want one of those 1-parameter parametrized monads
19:09:55 <tgeeky> Sgeo_: that doesn't sound like a general monad
19:10:14 <tgeeky> I think I see your point, though
19:10:16 <elliott> Sgeo_: sounds like (SgWorld LoggedIn) and (SgWorld Uninitialized) are two different monads.
19:10:24 <elliott> so why are they one type?
19:11:01 <Sgeo_> If I make them two different monads, how easy/difficult would it be to have a function that converts from one to the other that looks acceptable in do notation?
19:11:01 <elliott> Sgeo_: login :: LoginInformation -> LoggedIn a -> Uninitialized (Maybe a)?
19:11:12 <copumpkin> you can't
19:11:20 <copumpkin> you probably want an indexed monad
19:11:27 <copumpkin> which doesn't fit in standard do notation either
19:11:28 <elliott> it's nonsense to try and make these two different contexts the same monad imho
19:11:35 <elliott> and I don't see why indexed monads are more appropriate than just having two separate ones, really
19:11:38 <copumpkin> so you'd need overloaded syntax
19:12:01 <copumpkin> elliott: indexed monads can change the index as they go along
19:12:09 <copumpkin> I can't remember how conor's 1-parameter ones work though
19:12:14 <elliott> copumpkin: yeah, but that's basically what my "login" function does
19:12:25 <elliott> I suppose the problem is that you can't do a "logout"
19:12:33 <elliott> but I'd be suspect of such a model, not knowing anything about Sgeo_'s program
19:13:01 <copumpkin> elliott: he gives an example quite close to Sgeo_'s situation (from what I gather) in his oplss video
19:13:05 <tgeeky> mike-burns: thanks for the heads up
19:13:18 <elliott> Sgeo_: what is your actual situation?
19:13:29 <tgeeky> elliott: I think he was trying to teach me something?
19:13:35 <elliott> tgeeky: ?
19:13:42 <elliott> i don't think so
19:13:56 <tgeeky> elliott: ok
19:14:14 <Sgeo_> Very hypothetical, but, in a thing that either is or isn't logged into some server, making sure that functions that only make sense when logged in can't be called when not logged in
19:14:28 <Sgeo_> I mean, I have a use-case in mind
19:14:40 <elliott> sounds like a separate monad to me
19:14:42 <Sgeo_> But hypothetical as in, I doubt I'm actually going to write this code anytime soon
19:14:57 <elliott> type LoggedInT m = ReaderT LoginInfo m
19:15:13 <Sgeo_> There are functions that make sense both logged out and logged in
19:15:17 <elliott> runLoggedInT :: LoggedInT m a -> LoginInfo -> m a
19:15:26 <elliott> Sgeo_: LoggedInT MyMonad
19:15:31 <elliott> just "lift" them
19:15:36 <elliott> or, if you want, have a typeclass to avoid the lifting
19:15:50 <elliott> class MonadMyMonad m where liftMyMonad :: MyMonad a -> m a
19:15:52 <elliott> etc.
19:16:32 * Sgeo_ should probably learn Haskell to a decent level first >.>
19:18:49 <Sgeo_> What if I want more than LoggedIn/NotLoggedIn?
19:19:00 <elliott> too vague; didn't answer
19:19:01 <Sgeo_> Like InWorld/NotInWorld, and Visible/Invisible
19:19:21 <Sgeo_> Your way would have several monad transformers for each option, iiuc
19:19:33 <Sgeo_> Which sounds doable but inconvenient.
19:19:36 <elliott> you can always just make a dummy wrapper -- newtype Invisible = Invisible { runInvisible :: MyMonad a }
19:19:40 <elliott> Sgeo_: why?
19:19:42 <elliott> it's one line of code
19:19:54 <elliott> plus an instance if you go the typeclass route, which is probably for the best
19:20:16 * Sgeo_ needs a way to practice with Haskell first
19:20:27 <elliott> try writing programs
19:23:53 <monochrom> write unambitious easy ones
19:24:12 <shachaf> > id x
19:24:13 <lambdabot>   x
19:24:15 <shachaf> > id id x
19:24:16 <lambdabot>   x
19:24:19 <shachaf> > id id id x
19:24:20 <lambdabot>   x
19:24:38 <shachaf> That last one was kind of ambitious.
19:24:52 <djahandarie> > iterate id x
19:24:53 <lambdabot>   [x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,...
19:24:59 <djahandarie> > last $ iterate id x
19:25:04 <lambdabot>   mueval-core: Time limit exceeded
19:25:14 <Sgeo_> :t x
19:25:19 <lambdabot> Expr
19:25:35 <Sgeo_> @src show
19:25:36 <lambdabot> show x = shows x ""
19:25:38 <monochrom> all good things come to an end. iterate id x does not come to an end. therefore, iterate id x is not a good thing. :)
19:25:40 <Sgeo_> @src shows
19:25:40 <lambdabot> Source not found. Do you think like you type?
19:25:46 <azaq23> @src Show
19:25:47 <lambdabot> class  Show a  where
19:25:47 <lambdabot>     showsPrec :: Int -> a -> ShowS
19:25:47 <lambdabot>     show      :: a   -> String
19:25:47 <lambdabot>     showList  :: [a] -> ShowS
19:25:59 <elliott> Sgeo_: shows x = (show x ++)
19:27:58 <shachaf> elliott: show x = shows x ""
19:28:03 <elliott> shachaf: Yes.
19:28:19 <elliott> shachaf: Monadic zygohistomorphisms prove that these two definitions suffice to show any type in a human-readable form.
19:28:21 <shachaf> @show elliott
19:28:21 <lambdabot> "elliott"
19:28:30 <elliott> ?show Just 9
19:28:31 <lambdabot> "Just 9"
19:31:50 <monochrom> wait what? we have a @show command?
19:32:01 <monochrom> @show id
19:32:01 <lambdabot> "id"
19:32:12 <monochrom> @show 1+1
19:32:12 <lambdabot> "1+1"
19:32:19 <monochrom> interesting
19:32:22 <MichaelBurge> Is there a way to write "changeRecord data record value = data{record = value}"?
19:32:30 <Jafet> @. show nixon
19:32:30 <lambdabot> "Politics would be a helluva good business if it weren't for the goddamned people. \n"
19:32:32 <shachaf> monochrom: It just gets a sring string and shows it.
19:32:37 <shachaf> Not a very interesting plugin.
19:32:58 <kmc> MichaelBurge, not as such, but see 'fclabels' and 'data-accessor' and 'lenses'
19:34:41 <elliott> kmc: lenses? don't you mean data-lens?
19:34:49 <elliott> I recall lenses being pretty terrible
19:34:53 <kmc> eh, maybe
19:34:57 <kmc> i haven't used these much
19:35:01 <kmc> fclabels has good docs
19:35:03 <elliott> yeah, lenses is the one that doesn't even give its lenses a type
19:35:15 <elliott> nobody ping edwardk :)
19:35:23 <edwardk> ?
19:35:30 <kmc> i'd like the community to standardize on one so i have less to type
19:35:42 <elliott> edwardk: lens war!
19:35:48 <elliott> we can't let you get involved :P
19:38:10 * copumpkin unpings edwardk 
19:38:12 <MichaelBurge> When I write "data{record = value}", what exactly is record if it's not a function?
19:38:17 <elliott> a record label
19:38:25 <kmc> you can use that same name as a function elsewhere
19:38:30 <kmc> but in that expression, it's not a function
19:38:36 <elliott> (the record system sucks, don't use it :P)
19:38:41 <edwardk> fclabels is the best of the ones i didn't write
19:38:42 <kmc> i don't agree exactly
19:38:52 <kmc> the record system is fine for certain things
19:39:01 <kmc> it's a nice way to fake keyword arguments on functions, for example
19:39:07 <edwardk> data-lens on the other hand is fast. ;)
19:39:08 <Eduard_Munteanu> MichaelBurge: you also can't make a function that updates a datatype's nth field for any such datatype
19:39:09 <kmc> it's not that good for "actual data"
19:39:19 <roconnor> data-lens is the best of the ones edwardk did write.
19:39:22 <edwardk> but if you don't care about performance…. ;)
19:39:26 <edwardk> hahahahahah
19:39:34 <elliott> kmc: i'd prefer real keyword arguments :P
19:39:49 <elliott> (don't ask me how, that's the tricky part)
19:41:18 <roconnor> edwardk: we need to add partial lenses to compete with fclabels
19:41:28 <edwardk> no, no we don't ;)
19:42:39 <roconnor> edwardk: I need to add partial lenses to compete with fclabels?
19:42:47 <edwardk> =P
19:42:52 <elliott> s/->/~>/
19:42:53 <elliott> job done
19:43:45 <shachaf> /g
19:43:53 <elliott> s/->/~>//g
19:44:41 <maurer_> Anyone have advice on debugging a segfault which occurs in FFI code?
19:45:21 <luite> in the foreign code? then gdb works
19:46:51 <maurer_> luite: It's not in the foreign code itself, it's in a bindings library I wrote to the foreign code
19:46:53 <monochrom> read docs. verify docs with good experiments.
19:46:56 <maurer_> The foreign code is believed correct
19:47:29 <Eduard_Munteanu> Maybe Debug.Trace then?
19:48:23 <luite> maurer_: hmm, it could still be useful to check the arguments to the foreign functions
19:50:11 <maurer_> luite: I guess. I think it's my handling of pointers that's wrong though
19:50:33 <maurer_> Is there a way to turn off the gc to see if I've done something wrong and a pointer's getting freed early?
19:51:11 <monochrom> not exactly turn off but you can beef up the initial heap size so large that gc is unlikely for a good while
19:52:04 <monochrom> otoh if gc-freeing your stuff causes errors, you're using the heap wrong
19:52:39 <maurer_> monochrom: Yes, I am wondering if my problem is "using heap wrong"
19:52:49 <luite> how do you allocate and use your stuff?
19:53:01 <maurer_> There are a couple different calls
19:53:10 <maurer_> If I knew which one was problematic this would be easier >_>
19:53:21 <monochrom> bisection
19:54:08 <monochrom> anyway, out-of-context debugging tips are hard
19:55:35 <monochrom> hire someone to thoroughly understand your code. that is the only way to come up with a strategy. the strategy depends on understanding your code.
19:55:54 * monochrom usually hires himself
19:56:12 * shachaf monochrom: How much do you charge yourself?
19:56:12 <copumpkin> maurer_: what are you binding to?
19:56:21 <copumpkin> 5 dola
19:56:28 <monochrom> $0 special offer!
19:56:59 <maurer_> copumpkin: ptrace
19:57:03 <copumpkin> :O
19:57:17 * copumpkin wonders how you'll pull of a nice pure interface to that in haskell :P
19:57:33 <maurer_> copumpkin: I mean, it's not "pure"
19:57:37 <copumpkin> boo!
19:57:40 <maurer_> I've just removed most of the pointer nonsense
19:57:40 <shachaf> PtrAce
19:57:41 <copumpkin> you need a ptrace monad!
19:57:45 <maurer_> copumpkin: I have one
19:57:48 <copumpkin> oh yay
19:57:53 <maurer_> It's basically a stacked ReaderT and IO
19:58:01 <copumpkin> everything tastes better with a monad
19:59:05 <shachaf> @vixen How do monads taste?
19:59:06 <lambdabot> nevermind about that
19:59:40 <kmc> shachaf, i think you know what they taste like
19:59:54 <shachaf> kmc: I guess I do, living in California and all.
20:00:07 <monochrom> well here is one easy way to use the heap wrong. you use Foreign.Marshal.Alloc to get a buffer and the Ptr X for it. you give that Ptr X to the C side. The C side is known to remember that pointer for now, return, and at some later call use that pointer and buffer.
20:00:13 <confab> wooo! cali!
20:00:29 <confab> sorry
20:00:37 * confab goes back to idling
20:01:25 <shachaf> confab: You live in Sacramento?
20:01:49 <confab> wtf?
20:01:51 <confab> hax?
20:02:06 <confab> or do you just know comcast ip's by heart?
20:02:12 <kmc> doesn't sacramento suck or something?
20:02:24 <monochrom> sorry, that is a fine use of Foreign.Marshal.Alloc
20:02:34 <shachaf> confab: I just know your IP by heart, really.
20:02:53 <confab> how delightfully creepy
20:03:08 <monochrom> (actually depends on which exact one you use)
20:03:10 <copumpkin> @hackage algebra
20:03:10 <lambdabot> http://hackage.haskell.org/package/algebra
20:03:20 <copumpkin> edwardk: feature request! torsors kthx
20:03:33 <maurer_> Found it, alignment on one of my structs was wrong
20:03:37 <edwardk> don't i have those somewhere?
20:03:52 <strongtone> Sorry to interrupt. Is something like this not supported in hs10? prev (x+1) = x I get a parse error: (x+1)?!
20:03:57 <edwardk> guess not
20:04:10 <kmc> strongtone, correct, n+k patterns were removed in Haskell 2010
20:04:23 <kmc> one of relatively few changes from Haskell 98
20:04:26 <Eduard_Munteanu> Heh, Rig and Rng are quite funny
20:04:28 <shachaf> Good riddance, too.
20:04:30 <kmc> you can still enable them in GHC, though
20:04:44 <Eduard_Munteanu> (the names I mean)
20:04:45 <strongtone> K thanks kmc.
20:05:03 <Eduard_Munteanu> Don't they have any "proper" names in math?
20:05:03 <shachaf> Maybe you could use more-notation for patterns.
20:05:12 <shachaf> prev (more X) = x
20:05:27 <elliott> Is more-notation officially a meme yet?
20:05:40 <Eduard_Munteanu> Hah.
20:07:16 <Eduard_Munteanu> shachaf: add it as a motivating example in the proposal
20:07:19 <copumpkin> can newtype families exist?
20:07:27 <copumpkin> or rather, newtypey instantiations of data families
20:08:16 <kmc> yes
20:08:26 <monochrom> the ghc manual has an example
20:09:54 <copumpkin> I see
20:09:57 <copumpkin> thanks
20:22:56 <NemesisD> can you guys review this code and tell me if i'm doing something obviously stupid? https://gist.github.com/1177737
20:23:56 <NemesisD> it seems to work OK except upon hitting special characters, at which point it complains that it cannot decode byte '\x74'
20:30:39 <kmc> what's a special character
20:33:01 <ion> ㈵ U+3235 PARENTHESIZED IDEOGRAPH SPECIAL
20:33:03 <parcs> @hoogle IO a -> (e -> IO a) -> (a -> IO b) -> IO b
20:33:03 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:33:03 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:33:03 <lambdabot> Control.Exception bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
20:33:09 <shachaf> kmc: A character that racist people discriminate against.
20:33:16 <shachaf> By which I mean people who use ByteString.
20:35:03 <ion> @type \a b c -> (undefined :: IO a -> (e -> IO a) -> IO a) a b >>= c
20:35:04 <lambdabot> forall a e b. IO a -> (e -> IO a) -> (a -> IO b) -> IO b
20:36:12 <franny> NemesisD: looks like you're feeding it non-UTF-8 data.
20:37:09 <NemesisD> kmc: funny looking characters that don't fit into utf8 presumably
20:37:40 <franny> NemesisD: what encoding is your input in?
20:37:41 <kmc> all characters fit into utf8
20:38:15 <NemesisD> franny: how can i tell? i just grabbed the biggest csv i could find on my machine
20:38:47 <franny> It seems likely you're feeding it Latin-1 data, it sees a non-ASCII character and thinks it's the beginning of a UTF-8 sequence, than dies on the next one.
20:39:06 <franny> NemesisD: are you on Windows? Probably Windows-1252.
20:40:15 <franny> NemesisD: BTW, I'd highly suggest reading http://www.joelonsoftware.com/articles/Unicode.html :)
20:40:23 <NemesisD> franny: linux. it was generated in ruby by reading data from a database if i'm correct
20:41:11 <NemesisD> franny: will read. beyond eating it when encountering unicode characters, anything else that could be improved with that code?
20:41:22 <franny> NemesisD: I'd suspect Latin-1, but you need to know explicitly.
20:41:42 <kmc> all characters are unicode characters
20:41:47 <kmc> that's what the "uni" bit means
20:42:09 <NemesisD> give me a break i haven't gotten through the article
20:42:13 <kmc> ok
20:44:22 <parcs> :t ?a $ do ?x `?b` ?y
20:44:23 <lambdabot> parse error on input `?b'
20:44:38 <parcs> hmm no implicit infix functions?
20:44:48 <parcs> :t ?a $ do ?x ?`b` ?y
20:44:49 <lambdabot> parse error on input ``'
20:45:01 <parcs> :t \b -> ?a $ do ?x `b` ?y
20:45:01 <lambdabot> forall a b t t1. (?y::t1, ?x::t, ?a::a -> b) => (t -> t1 -> a) -> b
20:45:10 <franny> NemesisD: Looks OK to me, though I'm not really a wizard.
20:46:42 <franny> NemesisD: Oh, the LANGUAGE pragma is incorrect.
20:46:44 <NemesisD> franny: then what's with the robe and hat?
20:47:00 <NemesisD> whoops, just noticed that, good eye
20:47:15 <franny> It should be "{-# LANGUAGE OverloadedStrings #-}", and come before the module line.
20:47:15 <NemesisD> i also don't think i need it
20:47:30 <franny> Probably not, if it compiled. :)
20:47:33 <ddarius> uni = 1
20:47:47 <ddarius> Unicode, stored in a Word0.
20:49:29 <franny> NemesisD: also, check out hlint.
20:51:01 <NemesisD> does any of it look particularly inefficient? it has to map through the entire file before encoding it to json i believe
20:53:14 <cads> who was it that had the franco-envy the other night?
20:53:35 <cads> behold: http://imgur.com/gallery/vWpdy
20:54:45 <NemesisD> woah
20:56:47 <franny> NemesisD: reading your code, I'm kinda puzzled; you're reading it in as a ByteString, then decoding it?  Why not use System.IO?
21:00:29 <copumpkin> franny: why tie yourself to a particular input system?
21:00:45 <copumpkin> what if someone else produces it from a socket, or a zipped file?
21:00:51 <copumpkin> not that I have any clue what you're doing
21:00:53 <copumpkin> :P
21:03:20 <ddarius> Why tie yourself to a specific language, make a CORBA interface description file.
21:03:28 <franny> copumpkin: as long as you've got a (hopefully lazily-read) string from some source, then hopefully a pure function would be doing the bulk of the work, right? :)
21:03:58 <kmc> lazily reading strings is an ugly hack
21:03:58 <NemesisD> franny: because the csv library i use chose bytestrings
21:06:31 <kmc> i guess you can parse CSV without caring whether it's Latin-1 or UTF-8
21:06:47 <kmc> though you're definitely screwed for UTF-16 or UCS-2 or UTF-32 or UCS-4
21:08:09 <NemesisD> hmm well whatever i'm doing for encoding must be wrong seeing how it is choking on characters in the file
21:08:43 <kmc> what encoding is used in the file
21:08:59 <_Ray_> When is a foldl the same as a foldr? When the operation is associative and the starting value is the identity for the operation?
21:09:19 <kmc> that's a sufficient condition _Ray_
21:09:30 <franny> NemesisD: well, you're explicitly using a UTF-8 decoder. That's bound to choke unless you know the input is UTF-8.
21:10:00 <ddarius> kmc: No it isn't.
21:10:08 <kmc> no?
21:10:19 <ddarius> Or it might be if you are very careful.
21:10:20 <kmc> because of strictness?
21:10:30 <ddarius> kmc: Because foldling an infinite list will never work.
21:10:33 <_Ray_> Assuming everything's non bottom :)
21:10:46 <kmc> well, the infinite list has no bottoms in it
21:11:38 <ddarius> I guess if the question "when is a foldl expressible as a foldr" then that is a sufficient condition, but no conditions are necessary.
21:16:21 <NemesisD> how can i tell the encoding of the file?
21:16:48 <copumpkin> that's hard in general
21:16:54 <franny> NemesisD: by consulting what created it.
21:17:11 <franny> And what copumpkin said.
21:17:12 <MatrixFrog> NemesisD, if you have a hex editor that can be helpful
21:17:33 <MatrixFrog> http://frhed.sourceforge.net/en/ works well for me
21:17:59 <franny> NemesisD: you said you used Ruby and a database; I'd suggest seeing what encoding the text in the database uses.
21:18:52 <franny> Also: echo $LANG
21:18:59 <kmc> do you have a program that opens this file and correctly displays the non-ASCII characters in it?
21:19:20 <kmc> NemesisD, http://chardet.feedparser.org/ is allegedly very good at detecting encodings
21:19:49 <franny> Though Ruby tends to treat everything as bytestrings, so the data's probably whatever character set the database is using.
21:20:49 <kmc> it's shocking how few languages process text properly
21:22:14 <NemesisD> wow i had no idea encodings were such a mess
21:22:55 <franny> Yes. Haskell, Java, and newer Python get it right by storing everything as Unicode code points internally and requiring explicit encoding/decoding.
21:23:16 <copumpkin> Java?
21:23:20 <MatrixFrog> http://www.joelonsoftware.com/articles/Unicode.html
21:23:24 <copumpkin> I wouldn't say Java got unicode right
21:23:39 <confab> does java get anything right?
21:24:03 <copumpkin> every so often it doesn't fail miserably :)
21:24:13 <franny> Hmm, right, I forgot it only supports the BMP. But it gets points for trying.
21:24:23 <copumpkin> well, it now supports more
21:24:27 <copumpkin> but not with its native char type
21:24:33 <franny> Yeah, via char I mean.
21:24:40 <copumpkin> you need to use all the fancy static Int functions in Char
21:24:46 <franny> PHP and Ruby do it dead wrong. Everything's a bytestring.
21:28:55 <franny> I've fiddled with MediaWiki quite a bit; even though it uses UTF-8 throughout, being a PHP app, it's chaotic. It has to store everything in the database marked as Latin-1, because MySQL truncates any UTF-8 sequences longer than three bytes...
21:29:15 <_habnabit> mysql is bad; php is bad.
21:29:21 <franny> Oh, they are.
21:30:43 <franny> Why exactly MySQL can get away with mangling data like that--in 2011!--is a mystery to me.
21:31:11 <kmc> Python 2 gets it very wrong
21:31:17 <kmc> by muddling together the 'str' and 'unicode' types
21:31:32 <franny> Yes. If only people actually used Python 3.
21:31:36 <_habnabit> you can disable implicit conversion, but they're still very disparate types.
21:32:15 <MatrixFrog> what's that thing people always say? there are only two hard problems in programming: concurrency, and naming
21:32:17 <_habnabit> that's the only difference between 2.x and 3.x, really. restricting implicit conversion to ascii-only mitigates a lot of issues anyway.
21:32:27 <MatrixFrog> should be concurrency, naming, and unicode, i think
21:32:32 <_habnabit> time zones.
21:32:36 <kmc> unicode is a naming problem
21:33:04 <_habnabit> (3.x gets unicode wrong too, but in very different ways.)
21:33:08 <_habnabit> ((python sucks))
21:34:52 <franny> s/sucks/bites/
21:34:54 <elliott> MatrixFrog: the two hard problems are cache invalidation, naming things, and off-by-one errors
21:35:09 <MatrixFrog> ah yes, thank you
21:38:00 <NemesisD> wow reading this unicode article really makes me feel like an asshole for being american/an english speaker
21:38:22 <MatrixFrog> hehe well it's not as though you invented ascii
21:38:36 <MatrixFrog> you weren't the one that said "8 bits ought to be enough for anybody"
21:38:39 <elliott> us-ascii rules soviets drool
21:40:14 <franny> MatrixFrog: 7 bits, which is why Windows users in Japan and Korea have always seen backslash as ¥ or ₩, respectively!
21:40:18 * _Ray_ had the joy of conflicting between en-US and en_US for a few hours last week...
21:42:30 <franny> (Windows still substitutes those for backslash in paths and many fonts, even though it's long since been unnecessary, because they think that's what users are used to.)
21:43:46 <elliott> they are
21:43:53 <elliott> they did a study iirc
21:43:57 <franny> Ah.
21:44:24 <elliott> and i think it is very hard to fix it system-wide, so they don't feel the inconsistency is wirth it
21:44:28 <elliott> worth
21:48:42 <franny> It was kind of silly to choose a path character that was marked as variant by ISO 646, though IIRC, IBM required that Microsoft choose a path character that didn't require hitting Shift, precluding their first choice, ":".
21:49:37 <kmc> s/8/7
21:49:49 <kmc> oh, i'm late to the party
22:15:25 <maelstrom75> #hpmor
22:15:54 <absz> This may get asked a lot, but is there any good tutorial for understanding how to use (not implement) Enumerators/Iteratees/Enumeratees?
22:17:22 * hackagebot wai-logger 0.0.2 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-0.0.2 (KazuYamamoto)
22:18:08 <ion> absz: http://www.yesodweb.com/book/enumerator
22:19:03 <ion> absz: When you have an understanding of the concept, you’ll know how to use them.
22:19:37 <absz> ion: Fair enough, but I suppose I feel like I want to understand it via combinators, rather than the direct implementation.
22:20:22 <absz> ion: I came across that a while ago, but I'll take a closer look, thanks.
22:22:24 * hackagebot mighttpd2 2.3.2 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.3.2 (KazuYamamoto)
22:41:32 <tommythorn> Hi. Does anyone have the errata for Paul Hudak's "Haskell School of Expression"? The webserver of http://www.google.com/url?sa=D&q=http://plucky.cs.yale.edu/soe&usg=AFQjCNF5-zrxYJQLOvmRHqzmIzSVEoLOow is down
22:41:48 <tommythorn> http://www.google.com/url?sa=D&q=http://plucky.cs.yale.edu/soe&usg=AFQjCNF5-zrxYJQLOvmRHqzmIzSVEoLOow appears to have been down for a while
23:16:55 <hpaste> solrize pasted “scheme” at http://hpaste.org/50752
23:17:21 <solrize> http://hpaste.org/50752   is that sort of the equivalent of [1..] in haskell?
23:18:39 <solrize> oops lmap1 should say lmap everywhere
23:37:11 <solrize> and is software foundations the new sicp?
23:44:28 <azaq23> > let x = 1 : map (+ 1) x in take 10 x -- solrize: If it does what you want, why would you suspect that it isn't? I don't know the exact semantics of force and delay, but googling suggests that
23:44:29 <azaq23> you're using them correctly to create an infinite list
23:44:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
23:46:03 <solrize> azaq23, i was wondering if was using force/delay equivalently to what haskell does
23:47:03 <solrize> mostly whether i'd written lmap correctly
23:47:18 <copumpkin> > let x = 1 : map (+ 1) x in x !! 100000
23:47:20 <lambdabot>   100001
23:47:23 <copumpkin> > let x = 1 : map (+ 1) x in x !! 1000000
23:47:24 <lambdabot>   *Exception: stack overflow
23:47:33 <solrize> [1..] would be more like   let seq n = n : seq (n+1)
23:49:34 <hpaste> PaulLiu pasted “id3 tag converter” at http://hpaste.org/50754
23:56:26 <hvr> solrize: is that a book?
23:56:56 <solrize> software foundations?  yeah, byorgey (from here) is a co-author
23:56:58 <hvr> (couldn't find it on amazon)
23:57:17 <solrize> http://www.cis.upenn.edu/~bcpierce/sf/
23:58:03 <solrize> it's been a frequent topic here lately
23:58:34 <hvr> looks interesting; is it going to be published, or is it meant to stay a "web-book"?
23:58:59 <solrize> dunno.  if they dead-tree it i'd buy  a copy
23:59:40 <hvr> guess I'll have to get me a tablet or ebook reader sooner or later...
