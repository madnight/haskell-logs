00:06:10 <Saizan> there's hGetBuf
00:06:30 <Saizan> ?ty hGetBuf
00:06:31 <lambdabot> Not in scope: `hGetBuf'
00:06:36 <Saizan> ?hoogle hGetBuf
00:06:37 <lambdabot> System.IO hGetBuf :: Handle -> Ptr a -> Int -> IO Int
00:06:37 <lambdabot> System.IO hGetBuffering :: Handle -> IO BufferMode
00:06:37 <lambdabot> System.IO hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
00:06:44 <Saizan> saves you the handleToFd :)
00:08:00 <Jafet> Perhaps this is a sign that I should implement the parsing first
01:02:48 <Jafet> ghci> :t unsafeCoerce 1 :: forall a. a
01:02:54 <Jafet> it :: GHC.Prim.Any
01:02:59 * Jafet lol'ed.
01:06:34 <Jafet> Okay, that operation seems safe and reversible.
01:11:32 <ehamberg> quick mac-related question: when a friend wanted to install ghc using brew it said that 64 bit support was experimental. Have anyone had any real issues with 64-bit GHC on Mac OS?
01:12:00 <Jafet> I believe "not working" might be one of the common issues
01:14:14 <Jafet> Or at least used to be, until the ghc maintainers port it to your OS X version
01:25:59 <nlogax> i have been using it a bit, without problems
01:34:43 <dibblego> instance Monoid b => Monoid (a -> b) -- is there a name for this particular monoid instance?
01:36:22 <chrisdone> could be generalized to instance (Monoid b,Monad m) => m b?
01:37:10 <chrisdone> mappend = liftM2 mappend; mempty = return mempty
01:47:49 <c_wraith> the problem with the m b formulation is it would overlap freaking tons of stuff
01:48:06 <c_wraith> since instance heads aren't used in instance resolution, and all
01:48:42 * chrisdone nod
01:49:43 <Saizan> s/instance heads/contexts/
01:51:27 <c_wraith> err, yes
01:51:31 <c_wraith> totally backwards
01:54:27 <dibblego> does it have a name?
02:11:07 <Cale> dibblego: The lifting instance of Monoid for functions?
02:11:16 <benmachine> chrisdone: actually only needs Applicative :)
02:11:26 <benmachine> liftA2/pure
02:12:08 <Cale> dibblego: Or the induced pointwise monoid.
03:32:33 <hpaste> ‚ÄúTim Cowlishaw‚Äù pasted ‚ÄúWhy don't I understand Data.Sequence?‚Äù at http://hpaste.org/50706
03:32:49 <mistertim> Morning all,
03:33:06 <mistertim> any chance I could get some quick advice with a fairly simple thing that's bothering me? http://hpaste.org/50706
03:33:17 <mistertim> oops, hpaste bot beat me to it :-)
03:37:04 <Saizan> ?type Data.Sequence.viewr
03:37:05 <lambdabot> forall a. Seq.Seq a -> Seq.ViewR a
03:37:18 <mistertim> It concerns the behaviour of the Right View of a data.sequence - calling toList on it returns the elements of the sequence in left-to-right order, where I'd assumed it'd be right-to-left. I've clearly made a mistake in my assumptions, but not sure where
03:37:31 <Saizan> ViewR has a Foldable instance?
03:37:38 <mistertim> Saizan: yes
03:38:10 <Saizan> anyhow, ViewR is only there to let you look at the rightmost element, it doesn't reverse the whole sequence
03:38:18 <Botje> mistertim: viewR is just a view, as it says
03:38:42 <Botje> toList uses Foldable, and viewR doesn't change the folding order
03:39:00 <Saizan> you can use it repeatedly to build up a Seq with the opposite order
03:39:34 <mistertim> aha, thanks
03:40:12 <mistertim> so I can pattern match to do something with the rightmost element, and return  the rest of the sequence, but can't do the same using the foldable instance of viewr
03:40:24 <mistertim> (or at least not in O(1))
03:40:45 <mistertim> as it's involve reversing the seq which is O(n)
03:40:52 <mistertim> gotcha. Thanks!
03:51:05 <kmc> Jafet, yeah, you can unsafeCoerce to Any and back to whatever original type you had
03:51:41 <kmc> that's like half of why Any exists
04:09:34 <luite> is it possible to make hoogle link to a different url for haddocks?
04:12:49 <Saizan> i think the url is set in the hoogle files
04:17:23 <luite> Saizan: yes in the binary ones, but not in the text files
04:17:29 <luite> so it's added by hoogle convert
04:17:42 <luite> but I don't know how to influence that
04:18:46 <Saizan> i've seen some text files with stuff like @haddock: ..url..
04:31:27 * hackagebot file-location 0.4.2 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.2 (GregWeber)
04:34:01 <luite> Saizan: hmm, it doesn't recognize the @haddock attribute in the .hoo text files
04:39:57 <Saizan> maybe the syntax is different or it changed, anyhow there are some scripts in the hoogle darcs repo to generate docs, you can probably find more info there
04:40:05 <Saizan> s/docs/indexes/
04:41:13 <luite> yeah I'm reading them
05:06:08 <luite> ugh it accepts some @url attribute but I have no idea how it uses that
05:06:19 <luite> it still generates http://hackage.haskell.org links
05:54:45 <mistertim> Hmm, another quick one - is it possible to match a wildcard against a data constructor in a pattern match? eg data Foo = Bar Int | Baz Int String; getInt :: Foo -> Int; getInt (_i _) = i; ?
05:55:20 <Botje> no.
05:55:26 <mistertim> aah, as i suspected
05:55:34 <mistertim> thinking about it, it'd be tricky to implement
05:55:38 <mistertim> Thanks a lot!
06:05:28 <gienah> mistertim: with record syntax you can have: data Foo = Bar { getInt :: Int } | Baz { getInt :: Int, s :: String }
06:11:49 <kmc> SYB will let you get the first field of any constructor
06:11:58 <kmc> but the typing is done at runtime, and is kind of awful
06:14:45 <mistertim> gienah: aah ok, i'd tried that approach initially but something else caused a problem - let me just refresh my memory about what it was
06:16:02 <hpaste> ‚ÄúTim Cowlishaw‚Äù pasted ‚ÄúPattern matches, record syntax, etc...‚Äù at http://hpaste.org/50710
06:17:19 <mistertim> gienah: see paste above, it's only really the types, buySide and sellSide function that are relevant - it was the use of existential quantification that meant I couldn't use record syntax IIRC
06:17:57 <kmc> > let f :: (Data a) => a -> [Char]; f = listify (const True :: Char -> Bool) in (f (Just 'x'), f (Left 'y' :: Either Char Int), f "abcd")
06:17:58 <lambdabot>   ("x","y","abcd")
06:19:38 <mistertim> currently my buySide function won't type-check as they return values of type (Order Buy Limit) or (Order Buy Market) for different inputs - despite the fact that its type signature is parameterised as (Order a b) - I can see I'm doing something wrong here, but am struggling to put my finger on exactly what it is...
06:19:44 <kmc> > let f :: (Data a) => a -> [Char]; f = listify (const True) in (f (Just 'x'), f (Left 'y' :: Either Char Int), f "abcd")
06:19:45 <lambdabot>   ("x","y","abcd")
06:19:47 <gienah> mistertim: I haven't tried record syntax with ExistentialQuantification
06:19:58 <kmc> you can always write the accessor separately
06:20:44 <mistertim> kmc: so write seperate accessors eg. buySideForBuyTrade, buySideForSellTrade, buySideForCrossedTrade?
06:21:18 <mistertim> gienah: yep, it's a bit of a corner case I guess
06:28:55 <mistertim> hah! I just realised I don't even need existential quantification in this case.
06:29:04 <mistertim> Doh! thanks for humouring me all :-)
06:29:09 <kmc> can't you write a singel accessor that pattern-matches them all?
06:29:24 <mistertim> kmc: yep - provided I lose the existential quantification :-)
06:29:33 <mistertim> kmc: at least i think so
06:30:24 <kmc> even with?
06:30:55 <mistertim> kmc: hmm - that's what I thought I was doing (see hpaste above) but it wouldn't type-check
06:31:20 <mistertim> src/Simulation/Trade.hs:12:26:
06:31:20 <mistertim>     Couldn't match expected type `Limit' against inferred type `Market'
06:31:20 <mistertim>       Expected type: Order Buy a
06:31:20 <mistertim>       Inferred type: Order a1 Market
06:31:20 <mistertim>     In the expression: b
06:31:21 <mistertim>     In a case alternative: (BuyTrade b _) -> b
06:31:36 <mistertim> oops sorry, should've hpasted that
06:31:48 <kmc> hmm
06:33:29 <mistertim> I've realised i don't need to use existentials at all, so that should greatly simplify the problem
06:34:39 <mistertim> however, I've still got the same issue with the type sig of buySide and sellSide - which I don't understand as I explicitly defined it as Trade -> Order Buy a, so it should happily return either an Order Buy Market or Order Buy Limit
06:34:48 <mistertim> at least, I think it should :-)
06:36:33 <Saizan> yeah, that's where you've got it wrong :)
06:37:10 <Saizan> if f :: Trade -> Order Buy a; that means that the caller gets to choose whatever it likes for 'a', not the implementation of f
06:37:17 <mistertim> aha!
06:37:22 <mistertim> yep, that makes sense
06:37:53 <mistertim> so essentially, there's no way to right a generic buySide function that can return either one or the other
06:38:35 <Saizan> you can use an existential, or even just a sum type
06:38:44 <mistertim> aah, that's interesting
06:39:34 <mistertim> so I cold have a type BuySideOrder that's somehow the sum of (Order Buy Market) and (Order Buy Limit)
06:39:39 <mistertim> sum/union
06:40:15 <Saizan> yeah, f :: Trade -> Either (Order Buy Market) (Order Buy Limit) would work
06:40:21 <Saizan> @src Either
06:40:22 <lambdabot> Source not found. It can only be attributed to human error.
06:40:31 <Saizan> data Either a b = Left a | Right b
06:40:38 <mistertim> aha! yes -
06:40:57 <mistertim> I see, thank you!
07:07:51 <kizzx21> what's the operational difference between saying an ADT, a type class, a Java interface and an existential type?
07:10:20 <ovrskr> Is there a way to get back tab-style completion in Ghci once you load it using Haskell-mode?
07:10:37 <kmc> kizzx21, well, Java interfaces are part of Java, and type classes are a Haskell feature
07:10:38 <ovrskr> It is very useful to browse the namespace
07:10:49 <kmc> that's the first difference that comes to mind
07:10:56 <kmc> kizzx21, ADT = Algebraic Data Type or Abstract Data Type?
07:11:02 <kizzx21> abstract
07:11:10 <kmc> okay
07:11:20 <kmc> those four things are not that similar
07:12:21 <kizzx2> ovrskr: do you mean haskellmode in vim? you can do it using Omni completion ^X^O
07:12:28 <kmc> can i ask what's the context / point of this question?
07:12:45 <kizzx2> ovrskr: i map it to "imap <C-Space> ^X^O" to make it feel like visual studio
07:13:05 <ovrskr> kizzx2, Emacs
07:13:05 <kizzx2> kmc: actually i'm just wondering what's the big difference between an ADT and an existential type
07:13:10 <kizzx2> ovrskr: ah sory :P
07:13:25 <kizzx2> ovrskr: there you go, you see Vi is superior
07:13:38 <ovrskr> hehe I can't stand vim, i tried..
07:13:39 <kmc> kizzx2, abstract just means that the user can't directly see the representation of that data
07:13:55 <ovrskr> stateful programs just suck, you know :)
07:13:56 <kmc> but can only access it through provided functions
07:14:31 <kmc> that's a concept in program design, not a concrete language feature
07:14:45 <kmc> "existential type" is a more specific language feature, that can be useful for implementing abstract types, but is not required
07:15:14 <kmc> the simplest and most popular way to implement an abstract type in Haskell is to export the type and some functions from your module, but not export the type's data constructors
07:15:36 <kizzx2> kmc: yeah i'm fairly confident in groking ADTs, actually i'm focusing on existentials :P
07:15:47 <kmc> okay
07:16:20 <kmc> then it's probably not very helpful to compare the two
07:16:23 <kizzx2> i mentioned Haskell type classes and Java interfaces because they seem to come in the same lot (ok, not theoretically rigorous, dont sue :P)
07:16:23 <kmc> just learn about existentials
07:16:37 <kmc> they're kind of similar and kind of not
07:16:47 <kmc> and aren't very much related to ADTs
07:16:48 <kizzx2> actually
07:16:54 <kizzx2> the gist of the question is
07:17:05 <kizzx2> "well, aren't existential types just ADTs"?
07:17:07 <kmc> you can have an ADT where the abstract interface is also typeclass-overloaded, but that's a separate decision
07:17:33 <kmc> yes, existential quantification hides some aspects of the implementation of a data type
07:17:43 <kmc> it's a lot more fine-grained than module-level ADTs
07:18:00 <kmc> like i said, ADTs are a design idea and existential quantification is a language feature
07:18:06 <kmc> so no, they're not the same thing, that's a type error ;P
07:18:11 <kizzx2> olol
07:18:12 <kizzx2> ok
07:18:48 <kizzx2> actually i was reading the Existential Type Haskell wiki page, it shows using existential types to implement heterogenous lists (a list of Show), the first thing that came to mind "OK, that's just a generic list in Java, what's with the big words"
07:18:58 <kizzx2> "just a generic list in Java with an interface type parameter"
07:19:20 <kmc> yeah, it's kind of like that
07:19:22 <Saizan> semantics of abstract types are usually given through (weak) existentials
07:19:48 <kizzx2> alrighty :)
07:20:02 <kmc> Java would do well to learn some "big words", like "contravariant" and "type inference" and "lambda"
07:20:07 <kizzx2> thanks for clearing up, i was searching for a couple of hours and couldn't find out the diffrence, wondering if i was missing something obvious
07:20:36 <kizzx2> kmc: C# boasted a lot about its "contravariant" and "covariant" making it sound so powerful
07:21:45 <kmc> it's required if you want subtyping and generics to play nice
07:22:15 <kizzx2> yeah, but the general feeling in the C# community was similar to when ppl first hear about Monad
07:22:18 <kmc> although in a language with pervasive mutation, few containers are either covariant or contravariant
07:22:24 <kmc> so maybe it's not worth it
07:22:25 <kizzx2> where the underlying problem was not actually that abstract
07:22:50 <kmc> "this Monad stuff is too abstract, why can't they use simple terminology like Singleton Factory Iterator Visitor"
07:22:59 <kizzx2> o i think i saw that one :P
07:24:49 <roconnor> @type foldr
07:24:51 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:25:54 <mistertim> kmc, kizzx2 - relevant: http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html :-)
07:26:28 * hackagebot HsOpenSSL 0.10.1 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.1 (MasatakeDaimon)
07:26:52 <luite> is that their version of zygohistomorphic prepromorphisms?
07:27:30 <kmc> nice, i think that's even better than http://ws.apache.org/xmlrpc/apidocs/org/apache/xmlrpc/server/RequestProcessorFactoryFactory.html
07:28:52 <luite> whoah those java-ists really like typing: PersistenceExceptionTranslationPostProcessor.postProcessBeforeInitialization(Object bean, String beanName)
07:29:19 <kmc> luite, yeah, to get anything done in Java, you have to use an IDE that auto-completes those names for you
07:29:24 <kmc> i believe the feature is called "type inference"
07:30:02 <kmc> Java isn't a human-readable programming language; it's an intermediate form so that the output of various IDEs can be linked together
07:30:10 <companion_cube> the question is, what is a "PersistenceExceptionTranslationPostProcessor" ?!
07:30:29 <kmc> it post-processes translation of the persistence exceptions, obviously
07:30:39 <luite> companion_cube: you mean that it's not clear? perhaps they should switch to more descriptive names
07:31:22 <companion_cube> indeed
07:31:37 <companion_cube> but why would anyone want to post process such exceptions...
07:32:18 <luite> dunno, its part of their aspect oriented stuff
07:32:33 <luite> org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor
07:33:35 <luite> "Translates native resource exceptions to Spring's DataAccessException hierarchy"
07:33:58 <companion_cube> awesome
07:34:36 <donri> you know they say it's the suites pushing java but it's really developers who wants to get paid doing bullshit
07:38:34 <joe6> has anyone tried this: uri: http://haskell.org/haskellwiki/HSFFIG/Tutorial
07:38:54 <joe6> i am wondering how it interacts with bindings-dsl macros.
07:46:26 <joe6> Eduard_Munteanu: kmc, did you not want me to tell you when I come across something that can create haskell bindings from a c file? I think this is it: uri: http://hsffig.sourceforge.net/
07:46:35 <kmc> cool
07:48:22 <mistertim> I personally prefer java's naming conventions over some of the more egregious stupidity in the ruby community (where I spend my day job): https://github.com/pboling/csv_pirate
07:48:40 <mistertim> That's a real outlier though, and I don't think anyone takes it that seriously
07:48:55 <kmc> zombie bacon pirate ninjas!
07:49:00 <mistertim> :-)
07:49:01 <kmc> hardcore porn on the screen at cons!
07:49:04 <kmc> what's not to like
07:49:29 <mistertim>  has_csv_pirate_ship :booty => [:name, :distance, :spectral_type, {:name => :hash}, {:name => :next}, {:name => :upcase}, :star_vowels],
07:49:29 <mistertim>                       :spyglasses => [:get_stars]
07:49:33 <mistertim> WTF
07:49:42 <tgeeky> heh
07:50:10 <tgeeky> There is something to using (lexically) domain specific language to define a module
07:50:14 <tgeeky> but that one is a little overboard
07:50:18 <mistertim> hah!
07:50:24 <mistertim> "overboard"?
07:50:32 <tgeeky> ;)
07:50:50 * mistertim bows down to tgeeky's superior punning ability
07:50:58 <tgeeky> see bond/boson (cldwalker)
07:51:01 <kmc> @yarr
07:51:01 <lambdabot> Swab the deck!
07:52:06 <mistertim> tgeeky - yeah, totally aggree - especially when monkey-patching core classes with new methods is an established technique for writing ruby libs
07:52:16 <mistertim> anything that stops name clashes is very useful
07:52:41 <tgeeky> true, but I was referring to explaining the general architecture of a module (say, bond, which really does 'autocompletion')
07:52:45 <tgeeky> using a short narritive
07:53:05 <tgeeky> bond (an agent) is assigned missions (autocompletion roles)
07:53:33 <mistertim> aah, that's kinda neat
07:53:48 <mistertim> looking at the lib though, the metaphor isn't quite as pervasive as with the pirate csv thing
07:53:53 <mistertim> methods are sanely named etc
07:54:05 <tgeeky> yeah
07:54:10 <tgeeky> that's what I was getting at
07:54:10 <Jafet> @. vixen yarr
07:54:11 <lambdabot> nothing good is on TV
07:54:12 <parcs> is liftA2 more efficient than liftM2?
07:54:27 <tgeeky> parcs: efficient? I can't imagine a way in which it is
07:54:27 <Jafet> Nope, they're the same length
07:54:36 <kmc> parcs, they're both type-class overloaded
07:54:53 <Jafet> In some cases, it's more efficient to have _<$>_<*>_
07:55:08 <Jafet> Trims out the spaces
07:55:08 <kmc> it's going to depend on the particular Applicative and Monad instances
07:55:19 <Jafet> Wait, I thought we were golfing.
07:55:26 <parcs> liftM2 creates two extra closures
07:55:57 <kmc> how so?
07:56:10 <tgeeky> parcs: in the words of the original McBride paper, "If you have a monad, good. If you also have an applicative, extra good!"
07:56:15 <Jafet> liftM2 is liftA2.
07:56:25 <Jafet> :t liftA2 `asTypeOf` liftM2
07:56:26 <lambdabot> forall a b c (f :: * -> *). (Applicative f, Monad f) => (a -> b -> c) -> f a -> f b -> f c
07:56:31 <parcs> @. undo src liftM2
07:56:31 <lambdabot> ()
07:56:37 <parcs> @src liftM2
07:56:37 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:57:04 <parcs> m1 >>= \x1 -> m2 >>= \x2 -> return (f x1 x2)
07:57:50 <parcs> kmc: two invocations of >>=
07:58:03 <parcs> @src liftA2
07:58:04 <lambdabot> liftA2 f a b = f <$> a <*> b
07:59:55 <tgeeky> parcs: try compiling them both down to bytecode?
08:00:12 <tgeeky> or something intermediate
08:00:15 <tgeeky> or, try running benchmarks?
08:00:51 <Jafet> Closures are so inefficient! Even in functional languages!
08:01:34 <kizzx2> parcs's point seems quite valid
08:02:42 <Jafet> In all likelihood, there are no closures.
08:02:52 <Eduard_Munteanu> joe6: isn't that what c2hs (or whatsitsname) does?
08:03:19 <Jafet> To be sure, read the core or cmm.
08:03:26 <Eduard_Munteanu> Actually, I'm looking for something that creates Agda bindings to Haskell code. :)
08:03:41 <joe6> Eduard_Munteanu: it does? it seems better than defining everything with bindings-dsl.
08:03:48 <Jafet> Even if there are closures, so what.
08:04:52 <kmc> yeah, if you care you should read the GHC Core output
08:05:02 <kmc> closures are everywhere in compiled Haskell code
08:05:07 <kmc> not only at lambdas but at lets
08:05:11 <kmc> because of laziness
08:07:27 <Jafet> The lambdas there should be lifted and applied right away, ma, no closures
08:09:17 <kmc> does that depend on strictness analysis of (>>=) ?
08:10:18 <Jafet> I'm assuming -O. Then again, I could be totally off
08:10:40 <kmc> yeah, there's only one way to resolve speculation like this ;)
08:11:17 <monochrom> that is so sad. people just shouldn't speculate. there just shouldn't be any speculation to resolve
08:14:00 * roconnor wonders if setting socket timeouts works yet
08:14:37 <Antithesis> Good day
08:15:57 <kmc> hi Antithesis
08:22:26 <Antithesis> Since Haskell is a functional programming language, is it a good idea to learn it as my first programming language?
08:22:41 <smop> never
08:22:44 <blbrown_win3> Not really
08:22:44 <Antithesis> Well, I have messed around with Yabasic a bit
08:22:50 <smop> we all started with scheme
08:23:03 <Antithesis> ok
08:23:16 <smop> sicp
08:23:37 <Jafet> @where lyah
08:23:37 <lambdabot> http://www.learnyouahaskell.com/
08:23:42 <Jafet> @where sicp
08:23:42 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
08:23:43 <lambdabot> classes/6.001/abelson-sussman-lectures/>
08:24:10 <Antithesis> I initially wanted to learn Haskell because xmonad seemed the best programming language. Which other TWM would you recommend then? I'm planning to configure it a lot.
08:24:36 <chrisdone> Antithesis: many people have learned haskell as their first programming language, and survived
08:24:47 <Antithesis> But with side-effects?
08:25:22 <chrisdone> super awesome side-effects
08:25:37 <kmc> Antithesis, http://haskell.org/haskellwiki/FAQ#The_real_world
08:26:06 <kmc> Antithesis, the way effects work in Haskell is simple and logical
08:26:12 <kmc> it shouldn't be a big stumbling block
08:26:25 <kmc> however Haskell has a lot of features that go beyond simple FP
08:26:34 <kmc> (there's a FAQ item about that too)
08:27:29 <Antithesis> But will switching from a functional programming language to an imperative one be even harder than vice versa?
08:27:40 <kmc> Haskell is an imperative language too
08:27:52 <kmc> don't get hung up on "paradigms"
08:27:55 <kmc> it's a generally bogus idea
08:28:16 <confound> Antithesis: No.
08:28:28 <chrisdone> ime the type system takes longer to get used to than the purity
08:28:58 <wli> All sorts of nebulous and poorly-defined ideas have large impacts on how people live.
08:29:05 <Antithesis> Guess I'll just try then. How long do you think it'll take for me to be able to configure xmonad to my needs?
08:29:05 <tgeeky> Antithesis: also, 'switching' isn't something that you'll be required to do.
08:29:21 <kmc> plenty of people configure xmonad without "knowing Haskell" at all
08:29:28 <kmc> you can check out #xmonad and talk to some of them
08:29:40 <Jafet> You don't need more than a superfluous knowledge of haskell to use xmonad
08:29:59 <Antithesis> It seems more fun to learn Haskell first
08:30:02 <kmc> Antithesis, people learning Haskell often report some difficulty "un-learning" ideas they picked up from other languages
08:30:10 <kmc> so you might be better off learning Haskell first
08:30:17 <chrisdone> three people in my office use xmonad without any haskell skill, xmonad has a copy-paste quality to it
08:30:19 <Antithesis> Thing is, the others are more common
08:30:29 <monochrom> I write imperative programs in haskell all the time. they look imperative too.
08:30:31 <Antithesis> And unlearning might be required for those as well
08:30:33 <kmc> on the other hand, if you learn Haskell and like it, you'll find languages like Java and PHP to be incredibly frustrating
08:30:46 <confound> plenty of people find those languages incredibly frustrating without learning haskell
08:30:49 <kmc> indeed
08:30:52 <confound> I did when I only knew perl, for example
08:31:04 <roconnor> monochrom: are they buggy like imperative code?
08:31:17 <monochrom> no, I don't do buggy code
08:31:18 <kmc> Antithesis, and it's not about "functional" vs "imperative"
08:31:22 <roconnor> :)
08:31:29 <kmc> it's just about good, careful language design vs. bad, careless design
08:31:32 <chrisdone> (he achieves that by never writing any ;)
08:31:53 <kmc> there are well-designed imperative languages (like Haskell, for example)
08:31:56 <Antithesis> Then it seems wise to learn the good one first, no?
08:32:00 <kmc> shrug
08:32:01 <kmc> probably
08:32:13 <monochrom> I wrote these: http://www.vex.net/~trebla/portfolio/index.html
08:32:33 <Antithesis> Ok, so how long will it take to learn that enough to make an xmonad configuration from scratch?
08:32:34 <chrisdone> yeah. definitely haskell. if 13 year old me asked what language i should learn first, i'd tell him haskell, and hurry up about it
08:32:35 <Antithesis> That's what I'm aiming for
08:32:50 <kmc> meh
08:32:57 <kmc> hard to estimate how long it takes
08:33:00 <chrisdone> a couple of the beginner chapters of Real World Haskell
08:33:01 <kmc> why don't you try and find out
08:33:25 <Antithesis> Eh, what should I count on?
08:33:28 <Antithesis> Too hard?
08:33:32 <Jafet> Your fingers
08:33:57 <kmc> just learn it
08:34:17 <kmc> if it takes too long, give up and write a blog post "debunking the haskell hype"
08:34:22 <chrisdone> kmc is clearly jaded by hearing 20 people a day ask if they should learn haskell and only 2 ever trying ;P
08:34:43 <Jafet> @quote IO.String
08:34:43 <lambdabot> kmc says: it is not hard to troll #haskell for real; you just have to get confused and confrontational about how to convert IO String to String
08:34:44 <kmc> i'm just not sure why people need a time estimate up front
08:34:52 <kmc> to me learning is intrinsically open-ended
08:35:01 <kmc> you're never done learning Haskell, or programming, or CS, or math
08:35:19 <kmc> to be fair "make an xmonad configuration from scratch" is a pretty concrete goal
08:35:32 <kmc> but xmonad configs are arbitrary haskell programs
08:35:39 <kmc> so it depends on how fancy you want your config to be
08:35:47 <kmc> there's no sharp line between configuring and extending xmonad
08:35:50 <chrisdone> kmc: if everyone documented their learning process, at least with time stats, up front time estimates might've been a reasonable question. could at least say "between x and y given this schedule"
08:36:23 <kmc> people differ too much
08:36:43 <ddarius> What kmc said.
08:36:50 <chrisdone> ‚Ä¶ that's why you'd say "between x and y", taking the lowest and highest from the distribution
08:37:09 <kmc> OK.  It will take you between 1 day and 90 years to learn Haskell
08:37:27 <ddarius> People are also pretty horrible about self-reporting such things accurately, and there are tons of confounding factors.
08:37:40 <chrisdone> you can get shirty about it but i don't think it's that far fetched, look at learning stats provided by lecturers
08:38:00 * monochrom is never done learning java and/or c++, too :)
08:38:17 <kmc> chrisdone, the students in those courses differ in how much effort they put in
08:38:18 <monochrom> there is also no done learning python
08:38:35 <chrisdone> kmc: so?
08:38:42 <kmc> so it's a very loose bound
08:38:56 <monochrom> then again most people's "how long" means "how long before my first useful lib"
08:39:15 <dafis> define useful
08:39:28 <kmc> "in 20 weeks, 80% of students drawn from an unknown self-selected pool were able to complete 5 Haskell exercises in somewhere between 1 and 40 hours a week"
08:39:32 <monochrom> "useful" is defined by community consensus
08:39:39 <kmc> is this really useful knowledge
08:39:39 <Jafet> python breaks compatibility faster than you can learn where it did
08:39:56 <monochrom> but yeah, upload your brain for a free analysis! the analysis will take 3 years
08:40:13 <kmc> obligatory link: http://norvig.com/21-days.html
08:41:35 <ddarius> "between 0 and 168 per week"
08:41:42 <dflemstr> all: is it possible to deploy "hint" to a PC that doesn't have the Haskell platform installed? How would one deploy/load packages in that case?
08:42:17 <monochrom> manually chase dependencies and install them in topologically-sorted order
08:42:56 <monochrom> (a loop over wget, tar -xzf, runghc Setup.hs/lhs)
08:43:05 <dflemstr> monochrom, no, I mean: how would I deploy packages so that they could be loaded in the interpreter (provided that I know which packages I need)
08:43:28 <dflemstr> how would I organize a package DB?
08:43:51 <Jafet> ddarius: you can go higher by exploiting synergistic ecphory
08:46:10 <ddarius> Jafet: I don't think you can go higher than using all time.  You can certainly use that time more efficiently, but that doesn't lead to there being more time.
08:46:30 * hackagebot sink 0.1.0.1 - An alternative to lazy I/O that doesn't conflate  execution with evaluation  http://hackage.haskell.org/package/sink-0.1.0.1 (JakeMcArthur)
08:47:46 <ddarius> YAFL
08:55:36 <ovrskr> how does one go about writing a Case .. Of over a Parsec "oneOf" ?
08:55:41 <chrisdone> kmc: if you have stats like "in 20 weeks, 80% of students were able to solve X problem with Y concepts for a project", then you can more readily answer "how long to do my first haskell project?" about 20 weeks if studying as a student, which is better than ¬±‚àû
08:56:10 <kmc> chrisdone, yeah, i don't dispute that the data can be collected
08:56:18 <kmc> i think it's really hard to do properly, and also not that valuable
08:56:18 <chrisdone> ovrskr: oneOf [‚Ä¶] >>= \x -> case x of ‚Ä¶ ?
08:56:28 <kmc> do { x <- oneOf ... ; case x of ... }
08:56:31 <joe6> wow, hsffig is awesome. it works like a charm..
08:56:34 <kmc> equivalent to what chrisdone said
08:56:36 <ddarius> How do you get -‚àû ?
08:56:47 <ovrskr> thanks, will ponder this
08:56:52 <napping> chrisdone: I hope you can at least improve your estimate to 0 <= t <= +‚àû
08:57:12 <kmc> spending infinite time to get more and more confused
08:57:14 <ddarius> napping: You may have done your first Haskell project in the past.
08:57:16 <kmc> sounds familiar
08:57:59 <Jafet> -‚àû is when you find yourself somehow getting your PhD in type theory
08:58:10 <Jafet> Instead of law or something
08:58:23 <ovrskr> so... >>= keeps the result and >> throws it away?
08:58:26 <chrisdone> :)
08:58:31 <kmc> yeah
08:58:31 <ddarius> Law is much more complicated and detailed than type theory.
08:58:37 <kmc> @src (>>)
08:58:37 <lambdabot> m >> k      = m >>= \_ -> k
08:58:41 <kmc> ovrskr, ^^
08:59:03 <ovrskr> << noob
08:59:06 <ovrskr> hehe
08:59:06 <napping> Is there any library for parsing file formats with lots of structures linked by offsets?
08:59:17 <kmc> m >> k  =  m >>= const k
08:59:21 <kmc> think i like that one better
08:59:44 <dflemstr> if I have a .hi and a .so file, can these be loaded using hint? Or what else do I need?
08:59:48 <ddarius> napping: If it is a binary format than binary or attoparsec is probably fine.
08:59:51 <chrisdone> napping: such as binary formats like image or whatnot? binary or cerlea, i'd expect
09:00:02 <chrisdone> er, cereal
09:00:10 <kmc> can you use 'binary' and 'cereal' with an externally-defined format?
09:00:20 <ddarius> kmc: Of course you can.
09:00:22 <kmc> i thought they were just for serializing Haskell structures in an unspecified way
09:00:25 <napping> Those don't seem to include syncing
09:00:28 <napping> er, seeking
09:00:28 <ddarius> kmc: That's the Binary class.
09:00:32 <chrisdone> kmc: i use binary for postgres
09:00:40 <kmc> ah, ok
09:00:51 <ddarius> Mr. FAQ writer should already have known this.
09:00:57 <kmc> ;P
09:01:00 <kmc> it's a wiki ddarius
09:01:23 <chrisdone> napping: there is look-ahead in binary, but i suppose that's not the kind of seeking support you want
09:01:26 <napping> ELF is one example
09:01:29 * hackagebot fixed-point 0.5.0.1 - Binary fixed-point arithmetic  http://hackage.haskell.org/package/fixed-point-0.5.0.1 (JakeMcArthur)
09:01:31 * hackagebot fixed-point-vector 0.5.0.1 - Unbox instances for the fixed-point package  http://hackage.haskell.org/package/fixed-point-vector-0.5.0.1 (JakeMcArthur)
09:01:36 <kmc> there's already a library for elf
09:01:47 <napping> The header is like "there are 12 sections, and the section headers start at such and such offset"
09:02:22 <ddarius> chrisdone: I'm pretty sure there's a skip, but that won't help you going backwards.
09:02:42 <FredOverflow> > 1 + 2
09:02:43 <lambdabot>   3
09:02:57 <chrisdone> ddarius: lookAhead :: Get a -> Get a -- Run ga, but return without consuming its input. Fails if ga fails.
09:03:08 <ddarius> @hoogle skip
09:03:09 <lambdabot> Text.Parsec.Prim skipMany :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
09:03:09 <lambdabot> Text.ParserCombinators.ReadP skipMany :: ReadP a -> ReadP ()
09:03:09 <lambdabot> Text.ParserCombinators.Parsec.Prim skipMany :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
09:03:25 <ddarius> @hoogle Int -> Get ()
09:03:26 <lambdabot> Did you mean: Int -> RequestMethod /count=20
09:03:26 <lambdabot> Prelude toEnum :: Enum a => Int -> a
09:03:26 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
09:03:47 <ddarius> chrisdone: lookAhead is not what you'd (usually) want.
09:03:50 <chrisdone> heh, hoogle probably doesn't know about binary i guess
09:04:06 <chrisdone> i have a use-case for lookAhead presently, actually
09:04:17 <ddarius> chrisdone: For this.
09:04:25 <kmc> ddarius, reminds me of the time I spent about a week helping noobs in ##c, and then they flamed me out of the channel after i answered one question wrong
09:05:00 <ddarius> kmc: Yes, I have flamed you out of the channel.
09:05:03 <kmc> :D
09:05:11 <kmc> we do things in more subtle, refined ways here
09:05:24 <ddarius> Yes, by not doing them.  It is very tricksy.
09:05:33 <chrisdone> lightly grilled out of the channel into a dish
09:05:36 <kmc> that's the best way to do things
09:05:38 <kmc> nom
09:06:23 * dflemstr feels awfully ignored
09:06:32 * hackagebot fixed-point-vector-space 0.5.0.1 - vector-space instances for the fixed-point package  http://hackage.haskell.org/package/fixed-point-vector-space-0.5.0.1 (JakeMcArthur)
09:06:36 <chrisdone> dflemstr: huh, what? where?
09:06:52 <dflemstr> chrisdone, regarding my last two questions
09:07:02 * ddarius cooks kmc at 55∞C sealed in a bag.
09:07:07 <kmc> dflemstr, i don't know if 'hint' can load .so's
09:07:11 <chrisdone> ohh
09:07:12 <dflemstr> but it might just be that nobody is experienced in using hint here
09:07:12 <kmc> look at the 'plugins' package also
09:07:14 <ovrskr> they usually @src us with stuff that makes no sense :D
09:08:27 <dflemstr> kmc, the plugins package only loads binaries, correct?
09:08:28 * ddarius is not sure what is less ambiguous than code.
09:08:52 <dflemstr> I cannot interpret source code as plugins?
09:08:54 <Jafet> Valid code maybe
09:08:59 <Jafet> @src []
09:08:59 <lambdabot> data [] a = [] | a : [a]
09:09:37 <ovrskr> @src oneOf
09:09:37 <lambdabot> Source not found. That's something I cannot allow to happen.
09:09:37 <Jafet> @src (,)
09:09:37 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:09:57 <Jafet> If only you could fix this by removing memory banks
09:10:19 <kmc> dflemstr, it also has functions for compiling source, i thuoght
09:10:21 <c_wraith> I'm not sure lambdabot should sing
09:10:23 <kmc> anyway you were talking about .so's
09:10:49 <ddarius> @vixen are you a good singer?
09:10:49 <lambdabot> thanks, i do my best to be good
09:10:56 <dflemstr> kmc, yes, but it was a follow-up to my last question, which was about deploying hint to a computer without the haskell platform
09:11:08 <Jafet> @vixen are you a naughty singer?
09:11:10 <lambdabot> nope, i'm all sugar :)
09:11:21 <dflemstr> kmc, I need to run scripts that use pre-compiled libraries on a platform without the HP
09:11:32 <chrisdone> dflemstr: fwiw i have two branches on a project in which i try to use hint and hsplugins to make my server reloadable: https://github.com/chrisdone/hulk/commits/plugins  and  https://github.com/chrisdone/hulk/commits/hint  both ended in failures, so i guess my advice on the topic would be unhelpful :p
09:11:35 <kmc> well you can definitely cut down Haskell Platform quite a lot
09:11:47 <ddarius> dflemstr: The term "Haskell Platform" has a specific meaning that just a collection of libraries.  I think you mean without a GHC install or something like taht.
09:11:58 <dflemstr> ddarius, correct
09:12:24 <dflemstr> and also without the bundled C compiler, and the static libs, etc
09:13:11 <dflemstr> I wont need libc.a if I am making plugins
09:13:22 <dflemstr> or whatever
09:13:38 <monochrom> hint requires a majority of ghc's files. generally every program that uses the "ghc api" does
09:14:10 <chrisdone> Failed attempts at using hint caab555cefb48fad04a2 ‚Üí Segfault bullshit fa3c4024b09fab352cba ‚Üí Attempt to to use hsplugins, fails with GHC runtime panic c01b63f466d0d4b603a7
09:14:17 <chrisdone> ‚Äòtwas a grim day in chrisdoneland
09:14:30 <dflemstr> monochrom, is there any alternatives if I want to make a system with HS "script files" as plugins?
09:14:40 <dflemstr> are*
09:14:46 <kmc> use a Haskell interpreter like Hugs
09:14:58 <kmc> actually JHC might be suitable
09:15:12 <kmc> i don't know how big the compiler itself is, but it's known to produce small binaries via portable C
09:15:14 <edwardk> preflex: xseen cmccann
09:15:14 <edwardk> preflex_: xseen cmccann
09:15:15 <preflex_>  cmccann was last seen on freenode/#haskell 13 hours, 11 minutes and 47 seconds ago, saying: * cmccann pushes more egregious type hackery to github, hooray
09:15:22 <ddarius> Hugs doesn't let you have a running program that loads plugins dynamically.
09:15:26 <monochrom> you could bundle ghc. the license of ghc is pretty lax
09:15:51 <dflemstr> monochrom, but ghc is huge
09:15:57 <monochrom> yes it is huge
09:16:00 <chrisdone> not that big actually
09:16:16 <ddarius> dflemstr: Anything using hint is going to effectively include GHC in it.
09:16:18 <chrisdone> ghc consists of four parts and you don't need all of them
09:16:29 <Eduard_Munteanu> Can't you build a .so?
09:16:35 <dflemstr> kmc, how would I go about binding another haskell interpreter's output? is there anything on hackage?
09:16:56 <dflemstr> eduard_munteanu, the plugins need to be compiled on-the-fly
09:16:58 * monochrom retrieved from his archive ghc 4.08 last night! just 12MB when compressed
09:17:02 <Eduard_Munteanu> Ah, hrm.
09:17:55 <chrisdone> dflemstr: i'd try hint and see how large the resulting dependencies actually are
09:17:57 <dflemstr> chrisdone, I'm fine with the stuff hint pulls down as dependencies, but what would I need besides what it depends on, and how large would that package be?
09:18:00 <chrisdone> you don't need the whole of GHC
09:18:49 <dflemstr> like, if I make a "hello world" program that links hint, its around 60 MiB iirc, but what do I need besides that?
09:18:55 <Antithesis> Oh wow, this page just saved me.
09:19:12 <Antithesis> I accidentally used the close window hotkey instead of close window
09:19:13 <monochrom> also back then the profiling libs were in a 2nd tarball
09:19:18 <Antithesis> And this page asked me if I was sure
09:19:44 <ddarius> dflemstr: You shouldn't need anything, but you may need the directory structure that GHC expects.
09:19:53 <ddarius> dflemstr: Check the documentation for hint and the GHC API.
09:20:00 <dflemstr> ddarius, that includes
09:20:07 <dflemstr> ~/.ghc and ~/.cabal?
09:20:32 <dflemstr> ddarius, I've read the documentation, several times :)
09:20:39 <ddarius> .cabal is completely irrelevant to GHC.
09:20:57 <dflemstr> ...yet it stores the actual compiled libraries, is what I meant
09:21:01 <monochrom> both docs don't say what files are needed. but from practice I know they are needed
09:22:44 <chrisdone> last time i tried to compile mueval and run it on a computer without ghc installed i *think* copied over my ~/.ghc ‚Ä¶ not sure what else. that's /one/ way of finding out what you need
09:22:49 <monochrom> and yes, by using the GHC API, you have a static copy of base linked into your executable, and yet once you launch it, it wants yet another copy from disk
09:23:20 <dflemstr> monochrom, does that change if I compile the main executable with -shared?
09:23:21 <chrisdone> (mueval uses hint, so it's a good test program)
09:23:51 <ddarius> dflemstr: If you don't have a .cabal directory GHC will run fine (in fact, even if you don't have a .ghc as that's just per user packages.)
09:23:53 <monochrom> last time with ghc 6.12.x, GHC API and -shared is a crash
09:24:21 <monochrom> or s/-shared/-dynamic/ whichever is the one for executables
09:25:22 <dflemstr> hmm, I might just have to convince some people that we should switch to LUA instead... or something
09:25:39 <monochrom> The poster boy of GHC API is ghci itself. every question can be answered by looking at ghci
09:25:55 <mistertim> Any one know if there is an existing implementation of some sort of heterogenous list data type in hackage at all?
09:26:19 <dflemstr> misterim, yes, HList
09:26:22 <monochrom> (example: does ghci.exe run if you copy just it to another computer? answer: no. there you go)
09:26:27 <dflemstr> mistertim*
09:26:29 <mistertim> dflemstr: fantastic, thanks!
09:26:46 <chrisdone> monochrom: same for mueval, but i'd guess arbitrarily that mueval might require less
09:26:51 <dflemstr> anyways, thanks guys, totally unrelated question (sorta):
09:27:18 <dflemstr> are there any js interpreters available for haskell (off or on hackage)?
09:27:40 <dflemstr> js as in Javascript
09:28:06 <napping> not on hackage
09:28:26 * MatrixFrog is currently being sort of baffled by QuickCheck
09:28:29 <MatrixFrog> (in a good way)
09:28:41 <napping> coarbitrary?
09:28:44 <dflemstr> then I guess I might be wrapping libv8 as my next project... Wish me luck!
09:28:55 <edwardk> dflemstr: i have the better part of one around here somewhere. it was one of the first things i wrote when coming to haskell
09:29:22 <edwardk> dflemstr: nowadays i'd probably just say you'd be better off taking jmacro and adding an eval function to it
09:29:22 <MatrixFrog> i'm trying to implement church numerals, and surprisingly my ChurchN type is an instance of Arbitrary
09:29:25 <dflemstr> edwardk, I'd love to have a look
09:29:46 <chrisdone> there is one on hackage actually
09:29:51 <edwardk> dflemstr: i honestly don't know what machine it'd be on, but I'll look around for it when i get a chance
09:30:02 <MatrixFrog> except the arbitrary "church numerals" that it's coming up with are not actually valid church numerals, i don't think
09:30:45 <dflemstr> edwardk, jmacro isn't an interpreter ;)
09:30:46 <chrisdone> dflemstr: http://hackage.haskell.org/package/hjs
09:30:52 <chrisdone> HJS.Interpreter
09:30:58 <MatrixFrog> i managed to get one of them into a variable "c" using sample' and then i did:
09:31:00 <edwardk> dflemstr: i know, but it takes care of all the parsing bits, and evaluation is easy
09:31:03 <MatrixFrog> let f = c (+1)
09:31:13 <MatrixFrog> and then: map f [-10..10]
09:31:17 <edwardk> dflemstr: hence why i said adding an eval on top.
09:31:23 <ddarius> MatrixFrog: It has instances for functions, but a Church numeral is a inhabitant of forall a. (a -> a) -> a -> a, not of (a -> a) -> a -> a for some particular a.
09:31:37 <MatrixFrog> it appears to be a totally random mapping. it's technically a "function" but not a useful one. or something
09:31:37 <edwardk> dflemstr: i mentioned it as an option to sclv but he didn't see the point, and i didn't want to argue ;)
09:31:48 <MatrixFrog> ddarius: right. that makes sense
09:32:11 <MatrixFrog> well actually, i defined ChurchN like this:
09:32:16 <MatrixFrog> type ChurchN a = (a -> a) -> a -> a
09:32:30 <MatrixFrog> and "ChurchN Int" is an instance of Arbitrary
09:32:41 <edwardk> dflemstr: anyways my old version was pretty boring, it was basically a port of my javascript-in-javascript interpreter
09:32:49 <MatrixFrog> "ChurchN a" probably wouldn't be, more generally
09:33:01 <ddarius> It should be: type ChurchN = forall a. (a -> a) -> a -> a otherwise you allow things that aren't Church numerals as well.
09:33:18 <ddarius> And, at any rate, Natural :: * not * -> *.
09:33:23 * monochrom encourages edwardk to complete the cycle by writing a haskell interpreter in javascript :)
09:33:30 <tgeeky> we can't allow temple or mosque numerals here!
09:33:30 <edwardk> monochrom: =)
09:33:39 <chrisdone> edwardk: does your interpreter support function foo(n){ return bar(); } function bar(){ return foo.arguments[0]; }; foo(1) => 1?
09:33:49 <tgeeky> should we be using jmacro or ghcjs?
09:33:54 <tgeeky> even though they are different things
09:34:00 <chrisdone> ghcjs!!!11repeat 1
09:34:03 <monochrom> we should be using both
09:34:14 <dflemstr> hmm this is very interesting
09:34:22 <edwardk> chrisdone: good question
09:34:33 <dflemstr> pity hjs doesn't let you break out of IO
09:34:45 <chrisdone> edwardk: i discovered this ‚Äòfeature‚Äô recently o_o
09:34:48 <dflemstr> by enforcing reentrance
09:35:32 <ddarius> chrisdone: Javascript is filled with such things.
09:35:43 <chrisdone> tell me about it
09:36:03 <ddarius> chrisdone: That kind of makes sense from a œÉ-calculus perspective.
09:36:08 <luite> hehe javascript talk again :)
09:36:57 <dflemstr> provided that I can convince my coworkers, are there any embeddable pure functional languages?
09:37:16 <ovrskr> C
09:37:35 <ovrskr> joke aside, C++ TMP.
09:37:43 <dflemstr> ovrskr, embeddable as in embeddable into a program
09:37:57 <chrisdone> tgeeky: luite: http://hpaste.org/50477
09:39:08 <luite> hmm, interesting
09:39:18 <monochrom> you may still like to consider hugs. it is still a bunch of files to bundle, but at least the size is small
09:39:51 <monochrom> but I don't know how to call up hugs from a C program
09:40:43 <monochrom> hmm hugs probably implements enough FFI to allow a good enough story of that
09:40:44 <dflemstr> monochrom, exactly, I need to load modules from source and interpret them within a program
09:40:52 <tgeeky> chrisdone: one of the longer hello worlds I've seen, but nice
09:41:03 <edwardk> chrisdone: yes
09:41:18 <chrisdone> edwardk: good job :p
09:41:25 <edwardk> =)
09:42:03 <edwardk> benefits of a rote implementation of the standard without optimization
09:42:19 <monochrom> "#if defined(__BORLANDC__)" in hugs's HsFFI.h :)
09:42:24 <tgeeky> edwardk: wait, what did you do with ghcjs?
09:42:26 <chrisdone> tgeeky: luite: it's still really finicky. very easy to screw up and get inexplicable exceptions. it reminds me of the joke that early GHC would delete your files if you made a type error. ghcjs throws inscrutable messages at you
09:42:44 <edwardk> tgeeky: nothing. i wrote a javascript compiler in javascript, that was what we were talking about
09:42:50 <tgeeky> edwardk: oh ok
09:43:20 <edwardk> tgeeky: and it came up that i had some of a javascript interpreter in haskell, because dflemstr was curious about it
09:43:34 <edwardk> the latter was 4-5 machines ago though
09:43:56 <tgeeky> back when CPUs were driven by hampster wheels
09:43:59 <chrisdone> i started work on a base library (for the DOM access and such), so the hello world ended up as: import JavaScript; main = alert "Hello, World!"
09:44:38 <edwardk> you had hampsters? i'm jealous
09:44:41 <tgeeky> hamster?
09:44:43 <tgeeky> hm
09:44:56 <edwardk> hamster
09:44:56 <tgeeky> i just realiezd hamster doesn't have a p in it
09:45:28 <chrisdone> Noam Chompsky
09:45:57 <napping> dflemstr: if you are looking for something small and embeddable, you might try hugs
09:46:06 <tgeeky> i thought nim was the awesomest thing ever until I learned how he was treated later in life :/
09:46:31 <dflemstr> napping, several people have suggested that already, yet I am looking for something that's easy to bundle, like a good old library
09:46:51 <edwardk> om noam noam
09:46:54 <dflemstr> I am currently looking into wrapping libv8 (yes, 100% serious)
09:47:05 <napping> Do you need much FFI support?
09:47:35 <monochrom> dflemstr: in hugs, look for /usr/local/lib/hugs/docs/server.html , may be sufficient for you
09:47:39 <dflemstr> napping, yes, since I need the system for plugin management
09:47:50 <chrisdone> these are the ways i've identified that people use javascript: http://chrisdone.com/posts/2011-08-20-ghcjs.html#fn9
09:47:56 <napping> plugins written in Haskell, or in C?
09:48:13 <luite> chrisdone: does it support making bindings for, say, a jQuery object, in a somewhat typesafe way?
09:48:14 <napping> (by C, I mean arbitrary .so)
09:48:17 <tgeeky> chrisdone: the main thing I want to do, is use d3.js as a backend for diagrams
09:49:42 <chrisdone> luite: indeed.
09:50:12 <napping> Is the key point that the Haskell be in a shared library, or that you only need to ship a few files?
09:50:15 <chrisdone> tgeeky: should be easy with ghcjs
09:51:19 <dflemstr> napping, I need to be able to ship a program that is extendable via scripts, in any language
09:51:49 <tgeeky> that 'in any language' qualifier
09:51:50 <dflemstr> preferrably haskell, but I am alternatively looking into "common" embedded languages like JS or Lua
09:51:51 <tgeeky> is a tough one
09:52:20 <dflemstr> I mean forsome language . language, not forall language . language
09:52:30 <chrisdone> luite: jquery is what i plan to use for DOM stuff
09:53:32 <napping> Ah. So, if you were going to use Haskell you could fix the set of libraries usable from scripts, and just bundle those (but probably let scripts include other scripts too)
09:53:54 <dflemstr> napping, that would be ideal, yes
09:53:58 * ddarius would recommend lua.
09:55:43 <dflemstr> napping, yet it seems that bundling "hint" or something similar would require me to also bundle half of the HP, so that's not a preferred modus operandi
09:55:44 <napping> Is the main program in Haskell?
09:55:48 <dflemstr> napping, yes
09:55:56 <chrisdone> luite: nice thing is while you can make concrete haskell types (or use type classes), you can still call polymorphic JS using Ptr a. it's nice that the FFI supports that. like foreign import ccall "zdhsziconsoleLog"  jsConsoleLog :: Ptr a -> IO (); consoleLog :: Ptr a -> IO (); consoleLog = jsConsoleLog
09:56:36 <napping> does hint depend on many more packages than you program already does?
09:57:44 <dflemstr> napping, the dependencies don't matter much; it's that hint seems to require stuff besides the package deps to work correctly
09:57:57 <chrisdone> (speaking of the alpha-ness, it doesn't support, for example, converting a CString to String, so i had to do something like this
09:58:00 <hpaste> chrisdone pasted ‚Äúghcjs strings‚Äù at http://hpaste.org/50711
09:58:07 <shane84> could you say \x->x+1 is alpha equivalent to \y->1+y, because addition is commutative?
09:58:23 <napping> shane84: alpha equivalence is just renaming
09:58:29 <monochrom> I would not include +'s properties in alpha equivalence
09:58:39 <dflemstr> shane84, its equivalent but not within lambda calculus
09:58:39 <tgeeky> luite: I assume you checked out the reddit link -> "activehs"?
09:58:47 <napping> so even if you want to call it equivalent, you wouldn't call it "alpha-equivalent"
09:58:58 <napping> Also, + isn't necessarily commutative
09:58:59 <luite> tgeeky: not yet
09:59:17 <shane84> napping: when is (+) not commutative?
09:59:40 <luite> tgeeky: oh that's a development of what they had earlier, right?
09:59:41 <napping> With lazy numbers, mostly
09:59:46 <shane84> okay
09:59:50 <napping> data N = S N | Z
09:59:53 <tgeeky> luite: yep, but it has a nice review and instructions and finally a cabal release
10:00:00 <shane84> napping: okay, that makes sense
10:00:03 <napping> then 1 + x = S x, but y + 1 is strict in x
10:00:03 <monochrom> when (+) does not stand for what you think it stands for
10:00:06 <chrisdone> alpha equivalence is just whether the only thing in the abstraction that changes is the bound variable
10:00:16 <napping> It really should be commutative, but that's another question
10:00:43 <napping> dflemstr: for most purposes of "scripting", lua is probably a good answer
10:00:56 <monochrom> > let x+y = x++y in "x"+"y" == "y"+"x"
10:00:57 <napping> It's well know, and designed for embedding. You might try hslua
10:00:57 <lambdabot>   False
10:00:59 <luite> I don't really follow reddit usually
10:01:19 <shane84> is there a term for two functions, if given the same arguments always produce the same result?
10:01:21 <chrisdone> dflemstr: fwiw there's ECL (‚Äúembeddable Common Lisp‚Äù), which i once used to script an IRC client
10:01:28 <dflemstr> napping, yes I've seen hslua, but I'm currently looking into alternatives
10:01:31 <tgeeky> luite: ok, then consider this a heads up
10:01:40 <monochrom> the two functions are extensionally equal
10:01:53 <tgeeky> luite: http://www.reddit.com/r/haskell/ <- check out 'mmmodularity' and 'activehs ... presentation tool'
10:02:00 <napping> shane84: extensionally equivalent (I'm assuming that you mean referentially transparent functions already)
10:02:04 <shane84> monochrom: thank you
10:02:05 <napping> dflemstr: why not hslua?
10:02:32 <mistertim> hmm - what's the most idiomatic way to deal with sum types with more than one member - (Either a (Either b c)), or something else?
10:02:44 <luite> tgeeky: oh yes, I had found it, but only checked reddit after you mentioned it :)
10:02:54 <deech> Is it possible to give the direct path to a module in the import line?
10:03:03 <napping> mistertim: probably to define you own data type
10:03:10 <dflemstr> napping, because if it's possible to easily embed Haskell, I'd prefer that. Also, I'd prefer to use either a purely functional language (to control what the plugin can do more easily) or a more commonly used language like JS (for ease of use)
10:03:39 <napping> I think lua is more common than javascript for a scripting / plugin language
10:04:15 <tgeeky> wha-wha-whaaaa?
10:04:21 <ddarius> Lua is designed for embedding, has much more experience as an embedded language, and is more sane than Javascript.
10:04:24 <deech> napping: And Haskell has a decent Lua binding, so long as you're just passing primitive types back and forth.
10:04:24 <monochrom> data Threesum a b c = C1 a | C2 b | C3 c; data Threesome a b c = T a b c
10:04:34 <tgeeky> i think that's the kind of statement that should be backed up by evidence :o
10:04:38 <dflemstr> napping, also, lua has limitations when it comes to language features; for example, you get difficulties when nesting tables
10:04:49 <napping> tgeeky: as an extension language for standalone programs, not for webpages
10:05:14 <tgeeky> hm.
10:05:23 <tgeeky> perhaps, but now browsers are moving to using js for extensions
10:05:27 <napping> lots of games are scripted in Lua, I can't think of a single standalone program that uses javascript as a config/modding/scripting language
10:05:36 <tgeeky> mozilla does now?
10:05:43 <dflemstr> and even though lua is more common for embedding, js is more wide-spread still
10:05:51 <tgeeky> doesn't HL2 use Lua behind the scenes?
10:05:54 <napping> Hmm, I guess firefox does some UI stuff in javascript - but it's still a browser
10:05:56 <ion> Does any JavaScript engine have native integers?
10:05:56 <ddarius> tgeeky: It's only rather recently that you've been able to seriously use javascript as embedded scripting language in your own application.
10:06:01 <dflemstr> napping, well, then its about time that some programs are written :D
10:06:03 <tgeeky> ddarius: indeed
10:06:16 <napping> anyway, javascript is way uglier than lua
10:06:33 <tgeeky> yes, Hl-2 does use Lua
10:06:34 <mistertim> napping: aah ok, thanks! I guess that should've been obvious actually, since Either a b is pretty much just Left a | Right b
10:06:34 <napping> also, lua only has access to the functions you provide, so it should be very easy to control programms written in it
10:06:38 <tgeeky> at least, Garry's Mod does
10:06:59 <tgeeky> @src Either
10:06:59 <lambdabot> Source not found.
10:06:59 <napping> mistertim: It just gets too confusing remembering what (Left (Right (Left x))) is supposed to mean
10:07:10 <napping> mistertim: though O'
10:07:46 <tgeeky> napping: you can implement your own, with your own names.
10:07:55 <tgeeky> I did that for several built in types to try and understand them better
10:08:00 <napping> O'Caml's "variants" are definitely worth a look, and there are some typeclass hacks like "Data Type A'la Cart" if you really want an extensible approach
10:08:45 <napping> dflemstr: unless you really need referential transparency, rather than just  controlling access to unsafe functions?
10:10:13 <dflemstr> napping, the main thing I want to embed a pure functional language is that I need a plugin to provide several kinds of functionality, and I dont want a script to access resources its not supposed to when I don't want it to
10:10:46 <dflemstr> for example: when I call "hook_a" in the script, I don't want it to call functions that only should be called from "hook_b"
10:11:10 <dflemstr> this is easily done in pure functional languages, or javascript because I can control the global scope
10:11:29 * hackagebot unix-compat 0.3 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.3 (JacobStanley)
10:11:35 <dflemstr> in lua I have the "lua context" but its a pain to pass around
10:11:51 <napping> you plan to mutate the global scope of a javascript interpreter?
10:12:13 <monochrom> ghc 4.08.1 (minus profiling libs) was merely 45MB unpacked  \‚à©/
10:12:18 <dflemstr> napping, no, I plan to prevent a script from doing so, by clearing it between calls to certain functions
10:12:23 <napping> rather than just making and using separate lua contexts?
10:13:02 <ddarius> monochrom: That probably includes a lot of libraries and tools that are no longer shipped with GHC and split-objs wasn't default thn.
10:13:48 <dflemstr> napping, I guess that I just dont have enough experience with using Lua I guess, while having worked with Javascript interpreters a lot
10:14:13 <hiptobecubic> I am trying to reach into a data type that is parameter to another data type and i don't understand how to do so
10:14:42 <hiptobecubic> I have a Right (Foo {bar = 1}) and i need bar
10:14:51 <dflemstr> hiptobecubic, if you are pattern matching, simply nest patterns: "myfunc (DataA (DataB a b c) d e) = ..."
10:15:08 <copumpkin> jmcarthur: you strapped down?
10:15:41 <copumpkin> wouldn't want the horse head being blown away
10:16:09 <napping> dflemstr: It doesn't take long to read the manual and see how things work. It's a nice little language for what it does
10:16:14 <dflemstr> hiptobecubic, in that case, use "myfunc (Right f) = bar f + 1" or "myfunc (Right (Foo {bar = x})) = x + 1"
10:16:54 <hiptobecubic> hmm
10:18:10 <dflemstr> that also works with "case ... of" of course
10:19:45 <dflemstr> napping, have you got any experience with hslua, and if so, how would I prevent certain library functions from being called, like "io.open"?
10:20:08 <dylukes> holy hell.
10:20:21 <dylukes> Amazon got Hacker's Delight and the Dragon book to me within two days.
10:20:23 <dylukes> Somehow.
10:20:24 <dylukes> ;~;
10:20:57 <dylukes> I'm definitely checking "Send my Items as they become available" from now on.
10:21:26 <ddarius> dylukes: That's not amazing at all.  Toshiba sent the laptop I'm using right now from China to east coast America overnight.
10:21:52 <tgeeky> heh. all of that is amazing. Diplomacy used to *require* ambassadors because of a 6 month message passing delay.
10:22:06 <tgeeky> Now we just use them so politicians can send their friends to appointed overseas vacations
10:22:07 <napping> dflemstr: I've just used the C api, but if it's anything like that, then "io" wouldn't even be supplied by default
10:22:23 <dylukes> ddarius: I didn't pay for quick shipping
10:22:28 <dylukes> I had 6-7 day ground :P
10:22:32 <ddarius> dylukes: Me neither.
10:22:35 <napping> the command line "lua" program explicitly links in a bunch of modules
10:22:37 <dylukes> nice :0
10:22:59 <napping> hang on while I cabal install hslua
10:23:17 <dflemstr> napping, thanks for your efforts
10:24:07 <dylukes> ._.
10:24:08 <dflemstr> napping, I only see luaL_openlibs being wrapped, and it loads "standard libs"
10:24:14 <dylukes> just the index of the dragon book is menacing.
10:24:17 <dylukes> quite the tome.
10:24:28 <dflemstr> I have no way of determining exactly what is being loaded
10:24:37 <dylukes> over 900 pages of small-print LaTeX
10:24:40 <ddarius> There are probably much better books than the dragon book nowadays.
10:26:05 <ddarius> Such as Appel's "Modern Compiler Implementation in *"
10:26:21 <dylukes> I find it's silly to just read *one* book on any topic.
10:26:37 <dylukes> Seminary work or not, regardless of whether the content is exactly the same...
10:26:49 <dylukes> often different books explain different concepts better.
10:26:50 <jmcarthur> copumpkin: i'm fine here
10:26:53 <ddarius> With "Modern Compiler Implementation in *" you can read -three- books on one topic.
10:27:03 <monochrom> that is why you read what ddarius says :)
10:27:20 <dylukes> I'll try to acquire it.
10:27:21 <napping> dflemstr: the binding seems to be a bit incomplete
10:27:36 <dylukes> I'll skip Java though .__.
10:27:41 <dylukes> ML/C sounds fine, tyvm.
10:27:45 <jmcarthur> copumpkin: how bad is boston expected to be?
10:27:55 <dflemstr> napping, indeed...
10:28:02 <copumpkin> jmcarthur: better than there
10:28:07 <ddarius> Actually, I hear that the different versions are actually notably different in more than just language, though probably not different enough to get more than one of them.
10:28:21 <dylukes> I'd imagine different languages lend themselves to different approaches.
10:28:39 <dylukes> the OCaml and C++ LLVM tutorials are the same content wise, but the approaches differ slightly.
10:29:02 <jmcarthur> well, i'm just going to be holed up for a while. taking the opportunity to work on some ideas i've been tossing around
10:29:57 <napping> dflemstr: anyway, you don't need to call openlibs
10:31:36 <dflemstr> napping, but string.format etc seems useful... would I need to implement my own "core library" in that case?
10:33:44 <joe6> i am using haskell ffi and I compile the C code to a .o file and use "ghci -Wall test.o" and load my ffi module to use it.
10:34:20 <joe6> is it possible to use a linked file(after processing by gnu ld) instead of using the .o file?
10:34:25 <hiptobecubic> What is type "IO (Response a)"? I know that Response is defined as "type Response = Either MPDerror", but how do I Monad :D ?
10:35:01 <ClaudiusMaximus> is there a way to turn off     Warning: Pattern match(es) are non-exhaustive
10:35:01 <ClaudiusMaximus>              In a lambda abstraction:
10:35:15 <joe6> "I compile the C code to a .o file" = through gcc to a .s file and through gnu as for a .o file.
10:35:23 <ClaudiusMaximus> without turning it off for other things
10:35:35 <napping> dflemstr: there are individual luaopen_string functions:  do http://www.lua.org/source/5.1/lualib.h.html
10:36:21 <napping> and those just register a bunch of functions (end of http://www.lua.org/source/5.1/lstrlib.c.html)
10:37:09 <maltem> ClaudiusMaximus, probably not; why would you want partial functions unless they are defined without a lambda?
10:37:23 <dflemstr> napping, so I'll have to make a new hslua that wraps more functions... great
10:38:38 <dflemstr> napping, or I could do 'do pushnil; setglobal "io"', I guess
10:38:46 <kmc> hiptobecubic, http://www.haskell.org/haskellwiki/Introduction_to_IO
10:38:49 <jmcarthur> hiptobecubic: what do you mean how do you monad?
10:38:57 <ClaudiusMaximus> maltem: i'd rather write " \[a,b,c] -> f " instead of " \l -> case l of [a,b,c] -> f ; _ -> error "asplode" " -- anyway, not that important
10:38:57 <napping> It's still registered in package.loaded["io"]
10:39:04 <napping> if you've done openlibs, that is
10:39:07 <kmc> it's not really that relevant that IO is a monad
10:39:22 <dflemstr> napping, anyways, thank you so much for your help, I'll investigate this further (and possibly make a new hslua if needed)
10:39:33 <dflemstr> I'll stop bugging you now :)
10:39:52 <monochrom> hiptobecubic: typically you code like "main = do { .... x <- whatever that gives you IO (Response a); case x of { Left x -> ... ; Right y -> ... } ...
10:40:04 <monochrom> unless you're joking
10:40:05 <hiptobecubic> kmc, looking at it now. >> and >>= are a bit tricky
10:40:18 <kmc> tricky how?
10:40:33 <kmc> they're typeclass-overloaded higher-order functions, so it's good to have a grasp of those concepts first
10:41:16 <kmc> though you can stick to the non-overloaded types for IO given in that article
10:41:32 <hiptobecubic> hmm
10:41:36 <kmc> x >> y  is just  x >>= const y
10:41:40 <kmc> now you have only one tricky thing :)
10:41:51 <monochrom> (but const is tricky)
10:41:55 <ddarius> chrisdone: Footnote 10 of your ghcjs blog post is silly.
10:42:01 <MHD> const? tricky?
10:42:05 <napping> dflemstr:  I should mention luajit too. Good luck.
10:42:24 <ddarius> MHD: Yep, many people find A => B => A unintuitive.
10:42:25 <jmcarthur> hiptobecubic: (>>=) :: IO a -> (a -> IO b) -> IO b
10:42:33 <copumpkin> that's quiet a few footnotes
10:42:34 <kmc> (that's in the article)
10:43:04 <hiptobecubic> doesn't const just throw out the first argument?
10:43:08 <jmcarthur> yup
10:43:17 <copumpkin> the second one
10:43:20 <jmcarthur> err
10:43:21 <hiptobecubic> sorry, yes
10:43:22 <jmcarthur> yeah
10:43:23 <copumpkin> const id or flip const throws out the other one
10:43:24 <hiptobecubic> the second one
10:43:24 <jmcarthur> :)
10:43:51 <kmc> (const x) throws out its argument and returns x
10:43:52 <MHD> ddarius: sometimes you need to disrtegard what you have learned about type sigs and remember what you learned in algebra, graphs, functional analysis and calculus
10:44:02 <kmc> you can also write "x >> y  is just  x >>= (\_ -> y)"
10:44:37 <ddarius> MHD: Maybe, but for my example, people usually find it unintuitive in logic.  It makes complete sense with the proof term.
10:44:52 <kmc> hiptobecubic, values of IO type represent imperative programs which haven't been executed yet.  you have some primitive programs like "getLine", and you glue them together using (>>=)
10:45:17 <hiptobecubic> kmc, they are actions, no?
10:45:21 <kmc> then you name one of these programs "main" and that's what actually gets executed
10:45:24 <kmc> sure
10:45:28 <kmc> or "recipes"
10:45:33 <kmc> these are all fine terms, imo
10:45:52 <kmc> the term "IO action" is standard but thinking of them as "imperative programs" or "recipes" may be more evocative
10:46:08 <hiptobecubic> hmm
10:46:15 <dylukes> hiptobecubic: something of type 'IO a' is a pure value representing an "action" which will result in a value of the type 'a'.
10:46:25 <kmc> though the idea of programs manipulating programs is foreign to some
10:46:26 <hiptobecubic> dylukes, right
10:46:29 <dylukes> Of course, it has to stay within the IO monad, so the result is IO a, not just a.
10:46:37 <kmc> which is a shame because it's really fundamental to CS
10:46:45 <kmc> hiptobecubic, what was your question about (>>=) ?
10:46:47 <dylukes> a >> b composes two actions a and b
10:46:54 <ddarius> E.g. people find, "it's raining and the moon is made out of cheese implies that the ground is wet" unintuitive.  See material implication.
10:46:56 <hiptobecubic> like (.) ?
10:46:57 <dylukes> a >>= b composes two actions passing something along.
10:47:01 <dylukes> :t (>>)
10:47:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
10:47:03 <dylukes> :t (.)
10:47:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:47:12 <dylukes> er.... . as fmap...
10:47:17 <dylukes> :P
10:47:20 <dylukes> but no
10:47:25 <dylukes> :t (*>)
10:47:25 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
10:47:26 * maltem has the impression that #haskell is trying to write another monad tutorialÖ
10:47:27 <kmc> substructural logic, eh?
10:47:31 <kmc> indeed
10:47:34 <kmc> it's my fault
10:47:39 <napping> just an IO tutorial, it sounds like
10:47:44 <maltem> heh
10:47:47 <dylukes> hiptobecubic: >> takes two actions, composes them ,resulting in whatever is on theright
10:47:48 <kmc> i linked to the article, but then decided to start writing it out one line at a time
10:47:55 <kmc> and so three other people also started writing it out one line at a time
10:47:58 <napping> (>>=) :: IO a -> (a -> IO b) -> IO b
10:48:00 <dylukes> hiptobecubic: so if readString :: IO String,
10:48:02 <jmcarthur> i dislike when somebody says something is "in IO" because it implies that IO contains an actual value somewhere
10:48:09 <dylukes> then readString >> readString would read two strings, discarding the first one.
10:48:26 * kmc , personally, will wait for hiptobecubic's question about (>>=)
10:48:26 <dylukes> by contrast, >>= lets you pass some state to the next action.
10:48:34 <edwardk> preflex_: xseen cmccann
10:48:35 <preflex_>  cmccann was last seen on freenode/#haskell 14 hours, 45 minutes and 11 seconds ago, saying: * cmccann pushes more egregious type hackery to github, hooray
10:48:39 <dylukes> For instance, say you wanted to read an int, then read that many strings
10:48:50 <hiptobecubic> how about this
10:49:01 <dylukes> readAnInt >>= (\the_int -> readNStrings the_int)
10:49:03 <hiptobecubic> because i'm getting lost in these five concurrent examples
10:49:10 <dylukes> hiptobecubic: the point of >>= is
10:49:14 <dylukes> the _return value_ of the FIRST action,
10:49:22 <ion> result value
10:49:22 <dylukes> is passed to the lambda/function
10:49:24 <ddarius> edwardk: Did he say he would get ahold of you via IRC?
10:49:28 <dylukes> ion: yeah.
10:49:31 <jmcarthur> there was an interesting question on reddit the other day. is sleep a pure function?
10:49:32 <kmc> hiptobecubic, you should probably ignore them all (including mine) and read the Introduction to IO article, if you haven't already
10:49:35 <edwardk> ddarius: well, i tried his phone
10:49:38 <hiptobecubic> i'm reading now
10:49:42 <mauke> jmcarthur: no
10:49:45 <kmc> cool
10:49:59 <ddarius> edwardk: Whether he was flying or driving, he would, hopefully, not (be able to) answer.
10:50:03 <dylukes> jmcarthur: It would differ in a single/multi threaded environemnt.
10:50:06 <ddarius> Presumably he will call you?
10:50:12 <jmcarthur> dylukes: it would?
10:50:17 <dylukes> jmcarthur: I think in a single threaded environment... arguably it would be.
10:50:21 <edwardk> jmcarthur: of course not. I wake up with a fresh outlook. That sounds like a side-effect. I mean how else would it allocate one?
10:50:26 <dylukes> Since it could just be a trivial computation that happens to take a long time.
10:50:45 <copumpkin> jmcarthur: no
10:50:50 <kmc> right, computation time is an observable effect.  this is really important in computer security, by the way
10:50:51 <jmcarthur> we can achieve the same effect by writing a computation that takes some time
10:51:00 <dylukes> But, in a multithreaded environment it might have the side effect of blocking other stuff.
10:51:04 <dylukes> jmcarthur: ^
10:51:13 <dylukes> Like ,for example,
10:51:14 <ddarius> jmcarthur: But we can't require a computation take at least some time.
10:51:18 <jmcarthur> dylukes: which one can only observe in IO anyway
10:51:22 <dylukes> say you wrote a sorting algorithm,
10:51:26 <dylukes> measured it very very well,
10:51:45 <jmcarthur> ddarius: i agree that the specification is difficult to describe as a pure function
10:51:46 <dylukes> and then had a relationship between the number of seconds to sleep, and the number of elements in the array to sort/reorder.
10:51:47 <ddarius> jmcarthur: But yes, from pure code sleep would seem to be pure, but it would also seem to be unnecessary and so could be discarded which is not what you'd want.
10:52:47 <jmcarthur> sleep :: DiffTime -> a -> a    seems no more problematic to me than   pseq :: a -> b -> b
10:52:56 <ddarius> jmcarthur: I find your sink package horrible by the way.
10:53:05 <kmc> pseq is kinda bad, though
10:53:17 <jmcarthur> ddarius: :)
10:53:30 <ddarius> jmcarthur: pseq has semantic import, sleep does not.  We would be able to discard all uses of sleep, we cannot discard all uses of pseq.
10:53:46 <jmcarthur> that is true
10:53:52 <kmc> we'd have stronger parametricity guarantees if seq and pseq had a type class constraint, even if that class were already implemented for all types
10:54:02 <jmcarthur> kmc: agreed
10:54:13 <kmc> (why did they drop the Eval class from Haskell 1.4?)
10:54:26 <copumpkin> ugly types!
10:54:28 <jmcarthur> kmc: although in ghc i don't see how we would have an instance for functions
10:54:51 <jmcarthur> well, aside from just letting it remain a primitive
10:55:06 <kmc> yeah, you wouldn't write the instances yourself
10:55:15 <ion> My computations happen in another time axis, taking no time in the one we sense.
10:55:37 <zzo38> Should I write proposal of more-notation in Haskell Wiki?
10:55:47 <jmcarthur> ddarius: do you see my sink package as more horrible than lazy IO?
10:55:51 <ion> What does more-notation do?
10:56:04 <kmc> zzo38, how much do you know about Haskell? how much code have you written? how long have you studied it?
10:56:14 <ddarius> jmcarthur: I see it as about as equally horrible as lazy IO.
10:56:28 <ion> @hackage sink
10:56:28 <lambdabot> http://hackage.haskell.org/package/sink
10:56:36 <kmc> jmcarthur, in GHC you could write seq for functions:  funSeq f = seq (unsafeCoerce f :: Any)
10:56:44 <napping> who knows about "pure", but referential transparency is defined in terms of values
10:56:44 <maltem> kmc, not sure if that is the relevant question
10:56:44 <zzo38> kmc: I have written one complete program and part of another. But I have studied a lot of Haskell stuff.
10:56:47 <jmcarthur> ddarius: it's intended to only be slightly less horrible than lazy IO, and i only actually have one use case in mind for it right now
10:56:53 <copumpkin> omg it's cmccann
10:56:57 <cmccann> yes
10:56:58 <copumpkin> welcome to the storm
10:57:02 <napping> a pure sleep would still be referentially transparent
10:57:04 <copumpkin> oh wait
10:57:08 <maltem> (I'd rather ask what kind of proposal this is about)
10:57:10 <ddarius> I'm not sure if I consider it less horrible.
10:57:19 <kmc> maltem, oh; I've already heard about it
10:57:22 <kmc> in #ghc
10:57:29 <cmccann> turns out I'm more out of practice with driving anywhere other than the grocery store than I thought
10:57:32 <napping> unless you somehow include evaluation time in your denotational semantics, but then even (+) isn't pure!
10:57:33 <maltem> oh ok
10:57:42 <edwardk> heya cmccann, welcome to the rainy hell that is the east coast
10:57:52 <ddarius> It's barely raining.
10:57:52 <cmccann> you don't want to know how long I spent taking wrong turns between the airport and the hotel here
10:58:03 <copumpkin> lol
10:58:05 <cmccann> yeah the weather is nothing
10:58:06 <djahandarie> Oh, cmccann is on the east coast now?
10:58:07 <cmccann> so far
10:58:11 <edwardk> cmccann: thats boston. i did say something about gps, right?
10:58:13 <ddarius> djahandarie: Yes.
10:58:20 * ddarius abhors GPSes.
10:58:24 <cmccann> edwardk, yes and it confused me as much as helped
10:58:24 <copumpkin> djahandarie: you need to get to boston, asap
10:58:28 <Tyr42> Hello, I am trying to get the Gloss library to work in osx
10:58:29 <edwardk> hah fair nuff
10:58:31 <maltem> apparently I'm not currently following the most cutting edge
10:58:33 <edwardk> where are you staying?
10:58:33 <cmccann> I'm not sure if it was a net benefit or not
10:58:35 <Tyr42> and it's not working
10:58:42 <zzo38> Someone suggested I make up the proper proposal for more-notation, I should use some wiki so that other people can fix it too
10:58:47 <ddarius> napping: One definition of "pure" is behaves the same under call-by-name as call-by-need.
10:58:48 <cmccann> the Hampton which is apparently very near your place
10:58:49 <djahandarie> copumpkin, wait, is he going to be working with you guys too?
10:58:49 <Tyr42> It hangs with a white ox where the main window should be
10:58:52 <copumpkin> nope
10:58:56 <copumpkin> although he should
10:59:02 <ddarius> And I think also call-by-value modulo bottoms.
10:59:07 <jmcarthur> ddarius: just as with lazy IO, you must be aware of evaluation order in order to not be bottom, but whether or not it turns out to be bottom is actually determined by IO code, and unlike lazy IO there is zero risk of evaluation order alone determining whether to launch missiles
10:59:11 <napping> ddarius: yeah, and if you include how long it takes to evaluate in "behaves", nothing is pure
10:59:37 <cmccann> edwardk: btw did you try to call me a bit ago?
10:59:42 <jmcarthur> *just as with lazy IO, you must be aware of evaluation order (in order to not be bottom)
10:59:49 <edwardk> cmccann: yeah
11:00:16 <kmc> some functions take time which does not depend on the input
11:00:19 <kmc> this is important in crypto
11:00:39 <cmccann> edwardk: ok, figured. was driving so couldn't answer easily and my phone battery was low anyhow :T
11:00:45 <ddarius> See Amr Sabry's "What is a purely functional language?" for more details on this definition and its motivation.
11:00:48 <napping> Can you guarantee (let x = expensive in x + x) takes exactly as  long to evaluate as (expensive + expensive)?
11:01:04 <edwardk> no problem. if you want to try to gps your way out here we can figure out something from there, or you can kick back and relax for a bit first
11:01:23 <ddarius> Which does define it to be same modulo non-termination under call-by-value, call-by-need, and call-by-name.
11:01:28 <cmccann> edwardk: think I need a break from dealing with the GPS for a few minutes at least
11:01:48 <ddarius> In that regard, the difference between call-by-value and the others would make sleep fail to provide it's guarantees in some cases and thus violate that definition of purity.
11:01:51 <kmc> driving in boston = doing it wrong
11:01:56 <ddarius> kmc: Agreed.
11:02:03 <cmccann> those things are remarkably good at giving very detailed advice about everything other than what I actually needed to know
11:02:41 <edwardk> cmccann: hah fair nuff
11:02:55 <napping> ddarius: sleep's guarantees about execution time fall outside the things you usually consider in "purity"
11:02:59 <edwardk> kmc: well, he has to make it a good way out of the city
11:03:35 <kmc> ah
11:03:44 <edwardk> cmccann: you're at the hampton inn on monsignor obrien?
11:03:50 <cmccann> edwardk: yes
11:04:09 <edwardk> ah good, then its basically a straight shot from there to my place
11:04:29 <joe6> has anyone used c2hs and hsffig?
11:04:32 <cmccann> after driving everything other than the sane route here from the airport, some parts more than once
11:04:43 <edwardk> hahaha
11:04:44 <ddarius> napping: If we say sleep has no semantics, then there's nothing to talk about.  You can give sleep a semantics by requiring that a gettime before and after sleep is performed differ by at least the time specified.
11:04:46 <edwardk> been there
11:05:00 <ddarius> cmccann: You assume that there -is- a sane route.
11:05:29 <cmccann> ddarius: the least insane route, then
11:05:33 <joe6> any thoughts, please?
11:05:39 <edwardk> cmccann: we'll give you a quick summary of how to get back to the airport later, it is pretty easy if you ignore the gps
11:06:03 <goat_boy> anyone have an argument that haskell is anything but esoterica?
11:06:11 <ddarius> goat_boy: Nope.
11:06:36 <hpc> if you find one, i hear museums pay top dollar for rare things :P
11:06:39 <edwardk> goat_boy: nope. nobody here but academics and ne'er to wells.
11:06:47 <edwardk> er ne'er do
11:06:48 <ddarius> to = do?
11:07:07 <Tyr42> what's the differences between "runhaskell foohs" and "ghc ‚Äîmake foo.hs && ./foo"?
11:08:32 <kmc> Tyr42, in the latter case you get a compiled binary you can run again without compiling again
11:08:40 <kmc> and it probably runs faster
11:08:44 <hpc> Tyr42: runhaskell does the same "compilation" that ghci does
11:09:01 <Tyr42> I'm getting inconsistent results
11:09:19 <Tyr42> my program crashes with runhaskell and not when compiled
11:09:19 <dafis> Tyr42: runhaskell automatically prints the result of main
11:09:44 <Tyr42> I'm using Gloss and it hangs with a white box
11:09:55 <kmc> dafis, woah, it does!
11:10:00 <kmc> didn't know that
11:10:32 <dafis> kmc: only recently learned it myself
11:10:38 <Tyr42> I'm just trying to get started with Sententia cdsmithus's Haskell for Kids, and I'm trying to get my younger brother set up
11:10:59 * dafis (almost) never uses runhaskell
11:11:36 <ddarius> Tyr42: Make your own runhaskell that does ghc --make
11:11:52 <Tyr42> and I can't seem to pass ‚Äîmake to runhaskell, as it say conflice with -e flag
11:12:11 <Tyr42> *conflicts
11:12:13 <kmc> correct
11:12:15 <ddarius> So runhaskell is doing ghc -e main
11:12:22 <kmc> invoke "ghc --make" instead
11:12:56 <Tyr42> ok
11:13:12 <joe6> quick question, if I have a shared library built with ghc, can i use it with ghci?
11:13:16 <Tyr42> but now I'm curious, what is it actually doing?
11:13:45 <kmc> like ddarius said, runhaskell is invoking "ghc -e main"
11:13:53 <kmc> which is like typing "main" at the GHCi prompt after loading that .hs file
11:14:05 <kmc> it compiles to bytecode and interprets that
11:14:36 <Tyr42> ok
11:15:16 <jmcarthur> goat_boy: you'll find that very few of us are interested in such arguments. we're content with just getting things done. perhaps that's an argument, itself.
11:15:16 <Tyr42> ah, yes typing main at ghci prompt also breaks it
11:15:40 * ddarius doesn't know why jmcarthur said anything at this point.
11:15:47 * jmcarthur felt like it
11:17:15 * cmccann has a strict policy of using Haskell only for impractical tasks
11:17:39 <dafis> cmccann: like finding the airport?
11:17:52 <ddarius> Haskell /= #haskell
11:18:14 <dafis> > "Haskell" > "#haskell"
11:18:15 <lambdabot>   True
11:18:20 <kmc> i'm just amused how half-assed most of the troll attempts are here
11:18:36 <cmccann> kmc, yes it's kind of sad
11:18:40 <kmc> of course a truly successful troll is undetectable
11:18:44 <dafis> kmc: where are the troll attempts better?
11:18:51 <cmccann> high-quality trolling is a neglected art form
11:18:59 * dafis wants to take a look
11:19:00 <kmc> just like bank robbers, you only hear about the ones who get caught
11:19:02 <ddarius> One day I may troll this channel on a scale ne'er before seen.
11:19:44 <kmc> that said i can think of a few who were clearly trolls yet went beyond the usual "HASKEL SUX UR GAY" to something resembling originality
11:19:45 <copumpkin> ddarius: sounds exciting
11:19:51 <dylukes> kmc: Trolling biology teacher: http://cl.ly/9eWE
11:20:05 <dylukes> "You must develop the argument exactly as the writer has presented it AND reduce the work by 75-80% of its size/length. (i.e. a pr√©cis for a 30 page chapter will be roughly 6 pages in length)"
11:20:06 <ddarius> copumpkin: Probably not, at least for me, which is why I haven't done it.
11:20:07 <dylukes> is the assignment spec.
11:21:28 <kmc> dylukes, tldr
11:21:37 <dylukes> >_>
11:21:41 <kmc> i gather you were a smartass to your biology teacher in some way
11:21:59 * edwardk is secretly a troll.
11:22:10 <dylukes> kmc: Roughly.
11:22:15 <copumpkin> secret troll is secret
11:22:26 <dylukes> He said "pr√©cis should be 25% of the length of the original text"
11:22:39 <copumpkin> dylukes: why did you bring this to #haskell after posting it in #haskell-blah?
11:22:50 <dylukes> copumpkin: Because I noticed trolling was brought up.
11:26:24 <MatrixFrog> hey could someone help me? i'm trying to compile this thing: https://github.com/benmachine/stepeval
11:26:54 <dafis> MatrixFrog: and the problem is?
11:26:58 <MatrixFrog> i got all the dependencies but i'm getting a couple of compiler errors when i actually try to install it
11:27:20 <hpaste> MatrixFrog pasted ‚Äúcompiler errors‚Äù at http://hpaste.org/50713
11:27:58 <MatrixFrog> it's possible that it's just a mistake in the code, of course. but i suspect it's something i'm doing wrong somehow
11:28:07 <dafis> MatrixFrog: your ghc is too old or too new, I suspect
11:28:22 <dafis> iirc, th changed
11:28:38 <dafis> MatrixFrog: which version have you?
11:28:55 <MatrixFrog> i just downloaded the haskell platform
11:29:20 <MatrixFrog> ghc --version says 7.0.3
11:29:37 <MatrixFrog> i notice that i'm not using the newest haskell-src-exts though...
11:29:52 <MatrixFrog> https://github.com/benmachine/stepeval/blob/master/stepeval.cabal asks for ">= 1.6 && < 1.11"
11:30:03 <MatrixFrog> but hackage has 1.11.1 as the newest
11:30:35 <MatrixFrog> cabal info haskell-src-exts says that i have 1.10.2 installed
11:30:57 <cmccann> edwardk: so, what's the plan at this point? preferably something that involves me finding some coffee and doing as little driving as possible.
11:31:38 <MatrixFrog> oh wait actually. it has a different dependency for the library and the executable
11:31:55 <edwardk> hah, well, probably the easiest thing to do would be for you to up monsignor obrien til it turns into mcgrath and meet me at mcgrath and washington
11:32:04 <edwardk> then we can wander from there
11:32:32 <cmccann> edwardk: I think I drove past there already when I missed a turn, hm
11:32:41 <edwardk> very likely
11:32:44 <copumpkin> cmccann: are you close to a T stop?
11:32:53 <MatrixFrog> i'm thinking maybe they just forgot to update it in one of the spots... let's see...
11:33:06 <cmccann> I haven't the foggiest
11:33:11 <edwardk> once we you grab me, we'll figure things out
11:33:18 <edwardk> probably heading to the T
11:33:21 <copumpkin> ‚ä§
11:33:22 <ddarius> copumpkin: He's on 28.
11:33:24 <peteriserins> which paper/article could serve as a relatively simple introduction to the implementation of FPR? I can understand the definitions of behaviors/events, but have trouble mapping that to the real world.
11:33:27 <copumpkin> as KMC would say
11:33:29 <peteriserins> *FRP
11:33:46 * ddarius finds edwardk's grammar progressively deteriorating.
11:34:04 <edwardk> ddarius finds edwardk progressively more distracted ;)
11:34:47 <ddarius> peteriserins: There are many different implementations of FRP and things that call themselves FRP.
11:35:39 <cmccann> edwardk: ok. this is something I can just walk?
11:35:50 <edwardk> not very easily
11:36:04 * ddarius would walk it, but he isn't indicative.
11:36:08 * MatrixFrog is compiling haskell-src-exts-1.11.1 and crossing his fingers that it will work
11:36:14 <ddarius> Lechmere Station isn't far, but it's the other way.
11:36:23 <ddarius> And it would be awkward for Ed to get to.
11:36:30 <peteriserins> ddarius: ok, would it be useful to look at the history and start with animation, or is that not necessary for Reactive, etc.?
11:36:37 * cmccann figured ddarius was completely typical of Boston residents
11:36:42 <edwardk> drive to washington and mcgrath, grab me, and I'll give you a bit of a tour to get you oriented
11:36:45 <edwardk> then we'll go from there
11:36:50 * ddarius has only been in Boston a few times.
11:36:51 * copumpkin walks everywhere
11:37:07 <copumpkin> well, most places :P
11:37:10 <ddarius> copumpkin: You don't walk to Harvard Square.
11:37:11 <edwardk> basically i want to make sure that driving around here isn't completely traumatic for you ;)
11:37:17 <ddarius> (usually)
11:37:19 <copumpkin> ddarius: I did a couple of times, but not to meet you
11:37:27 <zzing> I am reading a paper on "total functional programming" and it uses a symbol that looks like _|_ (but all connected). It will use it like _|_ T  where T is a type in subscript. Any ideas what that could be?
11:37:39 <ddarius> :t undefined
11:37:39 <lambdabot> forall a. a
11:37:41 <edwardk> ddarius has legs of steel. i wandered with him up to davis square and could barely walk for 3 days after
11:37:50 <djahandarie> Heh
11:37:56 <copumpkin> edwardk: he is also waterproof!
11:37:56 <ddarius> Davis Square is close.  Harvard is about twice as far.
11:37:58 <cmccann> edwardk: eh I've done worse. I just don't like driving in general, prefer to walk or take mass transit when possible
11:38:06 <ddarius> copumpkin: Only once completely soaked.
11:38:12 <edwardk> cmccann: yeah. we'll do that after this
11:38:27 <copumpkin> oh so what's the plan
11:38:32 <cmccann> most things are waterproof once they've absorbed the maximum amount of water possible
11:38:33 <ddarius> (and of course, 2*close = close.
11:38:33 <ddarius> )
11:38:53 <edwardk> copumpkin: well, i was hoping to get cmccann acclimated to the area then wander to the T somewhere
11:39:06 <edwardk> and eventually make it back to CBC
11:39:20 <copumpkin> yeah, get out quickly before it starts pouring cats and dogs
11:39:22 <copumpkin> :P
11:39:24 <edwardk> yep
11:39:35 <cmccann> edwardk: ok, so where am I actually going, then? intersections are awkward as destinations, people don't like it when you stop there
11:39:44 <ddarius> No God would be evil enough to drop dogs from the sky.
11:39:54 * copumpkin needs to adjust his diction to use "yonder" more
11:39:59 <edwardk> i msged the address
11:40:10 <dylukes> zzing: ‚üÇ == _|_
11:40:14 <dylukes> One's just unicode.
11:40:15 <ddarius> He won't get the batcave experience.
11:40:17 <MatrixFrog> seems like it worked! :D
11:40:21 <MHD> Hmmm... Concerning the implementation of domain specific languages in haskell, I think that the operator namespace is a little cluttered.
11:40:26 <ddarius> copumpkin: Yes, you do.
11:40:36 <zzing> dylukes: it used the unicode character but I know not what it is
11:40:39 <dylukes> mmk
11:40:51 <copumpkin> edwardk: CBC for dinner or just for drinks?
11:40:52 <elliott> zzing: _|_ is the bottom value, e.g. any non-terminating program, or an error
11:40:53 <ddarius> _|_ = undefined
11:40:58 <ddarius> _|__T = undefined :: T
11:41:03 <elliott> zzing: _|_T is the bottom value of ... yeah, what ddarius said
11:41:04 <elliott> of type T
11:41:05 <edwardk> copumpkin: either or both
11:41:07 <djahandarie> I didn't have any problems driving into cambridge
11:41:10 <copumpkin> bother
11:41:18 <dylukes> MHD: It would be nice if you could specify "zones" of code to do open imports in.
11:41:34 <dylukes> like C#'s "using"
11:41:36 <MHD> dylukes: Yeah
11:41:43 <kmc> dylukes, they're both unicode.  [/troll]
11:41:46 <zzing> ok
11:41:51 <dylukes> kmc: >_>
11:42:23 <kmc> oh, C# has "using"?  cool, i liked that feature from C++ but i'm embarrassed to say i like any feature from C++
11:42:29 <ddarius> Imagine where we'd be now without SGML.
11:42:40 <dylukes> kmc: But it's a scope.
11:42:40 <ddarius> C#'s using is different that C++'s.
11:42:42 <MHD> kmc: C# has a lot more than C++'s using
11:42:43 <kmc> i think C++ namespaces are pretty good in general, honestly
11:42:48 <dylukes> using System.Blah {
11:42:48 <dylukes> ...
11:42:49 <dylukes> }
11:42:50 <kmc> ok
11:42:50 <zzing> ddarius: do we have anything that can read SGML for ghc?
11:42:52 <elliott> ddarius: ^ASARCASM I don't know what you're talking about.^A
11:42:58 <dylukes> you can also drop the { } and use ;, then its for the whole file.
11:43:02 <kmc> you can scope "using namespace" like that in C++
11:43:05 <zzing> I have some sgml I want to read :P
11:43:08 <dylukes> kmc: I know.
11:43:09 <kmc> { using namespace system::blah;  ... }
11:43:14 <dylukes> using in C++ is equivalent to open kinda.
11:43:20 <dylukes> Oh, you can put it in a scope?
11:43:23 <dylukes> nice
11:43:24 <kmc> yep
11:43:32 <MHD> kmc:
11:43:36 <MHD> whoops
11:43:36 <kmc> MHD:
11:43:50 <MHD> "Shepherd..." "Wrex..."
11:43:57 * ddarius actually didn't know that you could do that with C#'s using, and now that he knows, doesn't really care.
11:44:09 <kmc> maybe i should learn Vala
11:45:44 <MHD> Vala doesn't have type overloading...
11:45:48 <MHD> big minus
11:45:53 <MHD> or something
11:46:19 <MHD> or was that a different language?
11:46:24 <zzing> Vala does has side effects...
11:46:25 <zzing> big minus
11:47:32 <zzing> In fairness to Vala, C++ started out the same way and ended up as another language - so it could go that way :P
11:47:47 <kmc> Haskell has side effects
11:47:54 <dylukes> kmc: SSSSSSH!
11:47:57 <dylukes> DONT TELL ANYONE.
11:47:59 <LeNsTR> ;D
11:48:07 <Shviller> Hello. Can someone help my with ghc -dynamic'ally --mak'ing an app that uses gtk2hs on Windows? It complains about libHSglib-0.12.0-ghc7.0.3.dll missing.
11:48:35 <dylukes> did you cabal install gtk2hs?
11:49:04 <dylukes> kmc: Is there hardware designed for non-strict langauges?
11:49:06 <Shviller> Yup. With  --enable-shared, even.
11:49:34 <ddarius> dylukes: Yes.
11:49:46 <elliott> dylukes: I believe the Reduceron is non-strict.
11:49:58 <copumpkin> it be rainin now
11:50:10 <zzing> Does ghc 7.2 do much that a newbie would be interested in beyond 7.0?
11:50:17 <ddarius> copumpkin: Sounds like it's lessened here.
11:50:19 <cmccann> hooray time to get rained on
11:50:23 <ddarius> zzing: Probably not.
11:50:47 <copumpkin> ooh thunder
11:50:57 * copumpkin loves storms
11:51:02 * ddarius too.
11:51:10 * ddarius heard copumpkin's thunder a bit later.
11:51:32 <edwardk> yeah
11:51:41 <kmc> @google ghc 7.2 release notes
11:51:42 <lambdabot> http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/release-7-2-1.html
11:51:42 <lambdabot> Title: 1.5.ÔøΩRelease notes for version 7.2.1
11:51:45 <kmc> zzing, ^^
11:52:15 <kmc> i'm not sure why Safe Haskell is a "Highlight" but DeriveGeneric isn't
11:52:52 <kmc> anyway i think those two are the most interesting ones, from a user perspective
11:53:01 <kmc> compiler plugins is also quite interesting if you want to hack on ghc
11:53:30 <ddarius> Which is, of course, the first every newbie wants to do.
11:53:59 <kmc> ddarius, indeed sometimes it is
11:54:13 <zzing> There is some data I want to read in, it is available in SGML and CSV. CSV is obviously easier, and it actually has a module I could find. Is there anything for SGML?
11:54:20 * ddarius made a patch for the, then new, TH a few months after he started using Haskell.
11:54:31 <kmc> cool ddarius, what did the patch do?
11:54:39 <kmc> zzing, not afaik
11:54:52 <kmc> out of my total ignorance of SGML: what happens if you parse SGML as XML?
11:55:01 <zzing> kmc: it isn't xml
11:55:07 <kmc> it's similar, right?
11:55:10 <ddarius> kmc: It breaks on all the SGML stuff that XML intentionally omits.
11:55:12 <maltem> it could fail when it shouldn't (and possibly more things)
11:55:18 <zzing> some what
11:55:31 <ddarius> kmc: It added support for records to TH.
11:55:46 <zzing> you can have stuff like: <Person><name>Jeff<age>18</Person> instead of <person name=Jeff age=18>
11:56:00 <zzing> The data is actually ofx financial data
11:56:20 <zzing> which started out sgml and my bank still uses the original standard
11:58:29 <zzing> Although I know ledger exists, I want to try to deal with some things on my own. In that light, I can imagine  the data of an account basically being date, description, debit, credit, amount (this is directly from my csv) and basically having a list. The question I have is how can I have a file which can store this data and my program being able to load partial amounts so it doesn't eat up memory? (sort o
11:58:29 <zzing> f like how a large sql database might only load up 1000 records at a time and processes it progressively).
11:59:45 <maltem> use a database?
12:00:27 <zzing> Do we have such a thing in haskell that would not require something outside?
12:00:43 <ddarius> There are many such things.
12:01:09 <maltem> sqlite bindings if that suits your needs. Also, layers on top of that
12:01:22 <maltem> (not sure about the performance of sqlite)
12:01:47 <Shviller> Okay, the regular effect of seeking help works without fail. Found another place dll are stored in, and that's where libHSglib were. Would anyone care to answer another question? Namely, what is the best way of deploying an app (on Windows, mostly) in such a way that the users can update it without re-downloading all 50 megs of it? Currently I'm planning to simply push every package I use into a dll (hence my original question)
12:01:47 <Shviller> and simply replace the tiny exe with a new one with each update.
12:01:49 <zzing> sqlite itself would perform quite well, under the logic that apple would not choose a slouch to base core data off of
12:03:25 <ddarius> GHC has a tendency to do cross-module inlining so that may not work.
12:03:45 <Shviller> ddarius: huh?
12:04:07 <dylukes> zzing: core data is backend independent. sqlite is _one_ of the backends.
12:04:13 <dylukes> So, not really a valid point.
12:04:23 <dylukes> They also use XML, which is quite a slouch.
12:04:25 <zzing> dylukes: afaik it is the primary one
12:05:01 <dylukes> XML/SQLite are both primary.
12:05:06 <maltem> Shviller, in a Windows context I would actually consider a 50 MB download to be negligible effort when compared to the versioning issues you are seemingly going to face
12:05:10 <dylukes> (they serve different purposes)
12:05:16 <dylukes> I should go do my work.
12:07:05 <zzing> Does there exist a pure haskell database?
12:08:46 <dylukes> http://www.haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces
12:08:49 <Shviller> maltem: (I think) I can easily live without updating the packages I'm relying on. Would that take care of those versioning issues?
12:09:42 <maltem> Shviller, depends on what the parenthesis means :p
12:11:45 <Shviller> maltem: well, this is going to be the first thing I'm doing in Haskell ever, so even though common sense says I can just freeze the versions of the packages I'm using, I can't be sure I won't run into some issue that'll force me to update. Then again, a full 50 meg update once or twice a year is acceptable...
12:12:17 <maltem> yeah that's what I was thinking
12:13:06 <Shviller> maltem: but, barring a package update, does this "keep the dlls, replace the exe" approach hold water? And is there an alternative?
12:13:06 <maltem> it's just not practical to code a packaging system together with an end-user project
12:13:37 <maltem> ugh, I don't know exactly how the Windows programmers do this
12:14:07 <maltem> there was a time where this approach was called dll-hell, but I was told that something changed about dll handling
12:14:14 <mgsloan> Hullo! Has anyone made/seen a library to make and manipulate paths into Data instances?
12:14:57 <Shviller> maltem: Y'see, it's gonna have ~15000 users, half of them on dialup, and none of them with half a brain. So, a full update twice a year I can afford, but the schedule is going to be more along the lines of twice per month. So I'm trying to figure out to keep those updates minimal.
12:15:04 <maltem> mgsloan, not sure what that means, are you thinking of "the zipper"?
12:15:22 <zzing> is 'text' considered a core package that should not be updated?
12:16:32 <Shviller> zzing: was that for me?
12:16:34 <mgsloan> I know zippers, and you could certainly derive a ton of definitions (I want to traverse structures made from a large number of ADTs - e.g. the Haskell AST)
12:16:40 <zzing> Shviller: anyone
12:16:56 <dafis> zzing: no problem updating text
12:17:01 <maltem> Shviller, so the first Haskell app you are deploying will have 15000 usersÖ is this a business we should be involved in?
12:17:28 <dafis> zzing: except of course that you'll need to rebuild a couple of packages depending on it
12:17:57 <maltem> Isn't there an Oleg thing about the "generic zipper"?
12:18:02 <Shviller> maltem: well no, doing stuff for the Russian government doesn't count as a business. ;)
12:18:03 <zzing> probably means it is best not to :p
12:19:18 <mgsloan> maltem - hmm, good point!
12:19:39 <maltem> Shviller, even then I hope *you* get at least paid for it ^^
12:20:18 <dafis> zzing: $ ghc-pkg unregister text; if anything depends on text, it will tell you about it, otherwise nothing will break by unregistering and upgrading
12:21:14 <zzing> Is the next haskell platform near release? If so, there wouldn't be much point in bothering
12:21:18 <maltem> mgsloan, some hackage packages look related, but I don't know any them
12:21:26 <maltem> *of them
12:22:00 <dafis> zzing: the next HP should come shortly after 7.4, I believe
12:22:17 <dafis> (which would be October or so, I guess)
12:22:39 <hiptobecubic> alright
12:22:43 <zzing> So the july release version is completely out?
12:22:48 <maltem> love relative release dates
12:23:09 <hiptobecubic> Prelude Network.MPD> do let st = mpd status in (\(Right st) -> stState st)   works
12:23:23 <dafis> zzing: dunno, looked at HP once and found I wasn't interested
12:23:34 <zzing> hmm, interesting
12:23:35 <hiptobecubic> but     mpd status >>= (\(Right st) -> stState st)   does not
12:23:39 <Shviller> maltem: well, I'm paid $600 per month. Anyway, is the bottom line that it's iffy and it can just randomly break? I mean, lets forget deploying for a moment and assume I'm the only user. Additionally, lets assume I somehow divined a list of all libraries I need, installed them (and compiled them to dlls) and then refused to touch cabal with a 10 feet pole. Given all this, will there be any need for me to recompile the dlls along with the exe?
12:23:59 <hiptobecubic> but >>= takes the output of the left action as the input of the right action, no?
12:24:57 <maltem> Well if you don't change anything then obviously, nothing will break that hasn't before. But you just cannot assume that nothing changes, never
12:25:11 <mgsloan> I kinda like the idea of doing generic paths, though. especially if you had a "toLabel :: Data a => Path a -> (forall a'. Data a' => a :-> a')"
12:25:32 <kmc> hiptobecubic, er, in your working example, the "let st = mpd status" bit isn't even used
12:25:39 <hiptobecubic> well damnit
12:25:49 <kmc> :t let x = "crazy unused thing" in \x -> x + 1
12:25:50 <lambdabot> forall a. (Num a) => a -> a
12:26:10 <kmc> defines x, throws it away, produces a function which takes an argument which also happens to be named x
12:26:12 <Shviller> maltem: I mean, nothing changes except my own code, but it changes within pretty tight limits. The feature set is fixed, I won't ever need more expressive power, etc.
12:26:18 <hiptobecubic> kmc, oh, right
12:26:27 <hiptobecubic> shit ok. so that's why that didn't give me any errors
12:26:34 <hiptobecubic> back to the drawing board
12:26:56 <MHD> Is it possible to eliminate GC with static analysis? And if not enterely then how much?
12:27:19 <kmc> MHD, open problem.  i don't know much about it, but "region inference" is a search term to start with
12:27:27 <kmc> in general it's undecidable, of course
12:27:45 <hiptobecubic> There's no way to get the a out of IO (a) is there? that's the point
12:27:49 <MHD> kmc: thanks. I am just thinking of running some scope analysis and dissallow some reference passing.
12:27:57 <kmc> hiptobecubic, i hesitate to say that's the point.  but it's a true fact
12:28:06 <hiptobecubic> kmc, ok
12:28:07 <kmc> except you can break the rules if you want to
12:28:10 <maltem> Shviller, also, deploying Haskell apps doesn't usually involve dlls --> no experienced people here you can ask about it. On the other hand, if those are governmental offices, the deployment situation is a little differentÖ
12:28:13 <hiptobecubic> so i need to approach this a new way
12:28:37 <kmc> hiptobecubic, the reason i hesitate is that people often think of an (IO T) as like a T that's marked with the taint of the real world
12:28:41 <kmc> but that's an incorrect model
12:28:46 <ion> @type (>>=)
12:28:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:28:54 <maltem> There's also the option to try your method and fallback to the 50 MB download whenever something breaks :)
12:28:54 <hiptobecubic> ion, yes i know
12:29:04 <hiptobecubic> kmc, it is?
12:29:09 <hiptobecubic> kmc, it seems like exactly the model :D
12:29:16 <ion> Pay attention to the ‚Äúm a‚Äù and the ‚Äúa‚Äù.
12:29:19 <kmc> it's a recipe for getting T's
12:29:21 <ddarius> MHD: You -can- do it with regions, but there often tends to be a top-level region that just ends up with all the hard stuff and in practical implementations is garbage collected.
12:29:33 <kmc> the IO has not happened yet; it might never happen or might happen more than once, with different results each time
12:29:35 <ddarius> MHD: More refined systems use substructural logics which allows more flexibility.
12:29:40 <kmc> there's no T buried inside (IO T)
12:29:44 <kmc> any more than there's a cake buried inside a recipe
12:29:57 <ion> The cake is a lie.
12:30:00 <ddarius> MHD: See Matthew Fluet's thesis.
12:30:22 <erus`> IO is like sewage. a vat full of vine with a teaspoon of sewage is a vat full of sewage
12:30:35 <erus`> (simon peyton jones)
12:30:44 <MHD> I just have the idea that with a distinction between references and cells, one can copy/pass data out of a scope, but not copy/pass references
12:30:59 <kmc> that's actually not true.  the FDA sets standards for the acceptable amount of contaminants in food products
12:31:02 <maltem> I need a dictionary for that British joke, assuming it's a joke
12:31:14 <ddarius> maltem: What joke?
12:31:26 <kmc> there's a figure for allowable number of insect parts per pound of chocolate
12:31:27 <kmc> etc.
12:31:37 <maltem> The comparison that erus` cites
12:31:39 <ddarius> Sewage and insect parts are different things.
12:31:42 <erus`> kmc im sure a teaspoon of sewage is too much
12:31:57 <kmc> depends how big the vat
12:32:00 <ddarius> That said, I'm sure there is an allowable amount of "sewage."
12:32:03 <dafis> erus`: depends on the vat's size
12:32:11 <erus`> sewage is human feces....
12:32:12 <kmc> hiptobecubic, that model also breaks down on types like (IO a -> IO a)
12:32:21 <ovrskr> Has anyone implemented Goto in Haskell ?
12:32:32 <MHD> ovrskr: HERETIC
12:32:36 <copumpkin> sort of
12:32:36 <kmc> yes
12:32:39 <ion> ovrskr: Yes. See the BASIC implementation.
12:32:43 <maltem> alright, the dictionary did it
12:32:44 <ovrskr> lol!
12:32:44 <kmc> http://hackage.haskell.org/package/BASIC
12:32:54 <ddarius> maltem: It's not a joke, though I'm sure it's explaining that a little bit of impurity makes a pure computation impure, not explaining the IO monad.
12:33:04 <kmc> ovrskr, continuations are sometimes called "functional goto" and are way more interesting
12:33:27 <Shviller> maltem: okay then, I'll just experiment with it then. A year's plenty of time. Thanks! I have yet another question on a somewhat similar topic. Would you mind if I /msg you about it? I'm not sure I should clutter the channel any further. %D
12:34:00 <erus`> has anyone implemented pointer increment in haskell?
12:34:05 <ddarius> @hoogle plusPtr
12:34:06 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
12:34:10 <maltem> ddarius, yeah I got it then. I should have proabably just keep my mouth shut, and add sewage/vat/vine to my vocabulary :)
12:34:21 <ddarius> Well, vine is presumably a typo.
12:34:22 <erus`> how about post increment?
12:34:56 <erus`> i meant vino or wine
12:34:58 <copumpkin> erus`: that's fairly easy on a *Ref
12:35:38 <maltem> "vat of vine" has something poetic about it though, even if incorrect
12:36:25 <maltem> Shviller, if it isn't Haskell-related then you could consider taking it to #haskell-blah
12:36:34 <ddarius> It has the alliteration of "vat of vino" with the meter of "vat of wine"
12:36:54 <ddarius> Meaning be damned.
12:37:24 <Shviller> maltem: it is Haskell-related. Similar question (basically, "how do I allow plugins for my app?"), but platform-agnostic, and without assuming the users are idiots this time.
12:37:31 <rwbarton> plusPtr changing the type seems a little weird
12:37:42 <rwbarton> is there a reason for that?
12:38:04 <rwbarton> oh the offset is in bytes
12:38:07 <copumpkin> moving somewhere else in memory might give you a different kind of thing
12:38:09 <panchot> hello haskell world!
12:38:19 <rwbarton> I figured it was like C pointer arithmetic
12:38:32 <panchot> anybody working on natural language processing?
12:38:48 <maltem> Shviller, as usual, "don't ask to ask, just ask". You just remind me that I have, theoretically speaking, better things to do than being here
12:38:49 <ddarius> @hoogle Ptr a -> Int -> Ptr a
12:38:50 <lambdabot> Foreign.Ptr alignPtr :: Ptr a -> Int -> Ptr a
12:38:50 <lambdabot> Foreign.Marshal.Array advancePtr :: Storable a => Ptr a -> Int -> Ptr a
12:38:50 <lambdabot> Foreign.Marshal.Alloc reallocBytes :: Ptr a -> Int -> IO (Ptr a)
12:38:51 <kmc> rwbarton, that'd have a Storable constraint
12:38:58 <kmc> yeah advancePtr is that i think
12:38:58 <rwbarton> ah right
12:38:59 <ddarius> rwbarton: advancePtr
12:39:51 <MHD> does alignPtr move forwards or backwards?
12:40:09 <MHD> as in, does it subtract or add to the pointer to get the desired alignment?
12:40:27 <dafis> MHD: I'd think it would have to move forward
12:40:39 <kmc> > fromIntegral . ptrToIntPtr . flip alignPtr 4 . intPtrToPtr $ 3
12:40:40 <lambdabot>   Not in scope: `ptrToIntPtr'Not in scope: `alignPtr'Not in scope: `intPtrToP...
12:43:08 <MHD> it moves forward
12:44:53 * ddarius is an idiot.
12:45:32 <mzy> I have "class A a where f :: (B b) => a -> b -> Int)" but I don't want an instance of A to implement f for every b.  I want an instance of A to implement f for exactly one b (or just 'some b').  How can I model this?
12:45:35 <Shviller> maltem: sorry about clinging to you like that. I bet the others are thankful to you for keeping a noob out of their hair. :) Anyway, I discovered I can't clearly say what I need, so I'll just think it over some more. Thanks for your time!
12:45:51 <kmc> mzy, multi-parameter type class with functional dependency.  or, associated type synonym
12:45:55 <kmc> both are language extensions
12:46:23 <mzy> kmc: thanks, I'll look those up
12:50:41 <mzy> is there anything to worry about when using language extensions?
12:50:48 <mzy> any reason to avoid them?
12:51:00 <PaulV_> I'm having a bit of a problem with cabal-install, it gives "Warning: output was redirected with -o, but no output will be generated because there is no Main module." and then fails because there is no output for the executable, does anyone know what might be wrong?
12:51:21 <Cale> mzy: Not really. Some are a bit more stable than others, but almost nobody gets by with no language extensions at all.
12:51:32 * hackagebot activehs 0.2.0.1 - Haskell code presentation tool  http://hackage.haskell.org/package/activehs-0.2.0.1 (PeterDivianszky)
12:52:10 <RomyEatsDrupal> any one else from cambridge / boston / MIT / harvard here?
12:52:47 <mzy> Cale: ok, thanks
12:53:05 <copumpkin> RomyEatsDrupal: lots of us
12:53:18 <Cale> PaulV_: What are you trying to install?
12:53:30 <RomyEatsDrupal> wow!  what i wouldn't give to meet a haskell programmer here while i am visiting harvard!
12:53:45 <PaulV_> Cale: a library I made 20 months ago
12:54:16 <RomyEatsDrupal> Are there any local Haskell meet up groups?
12:54:27 <copumpkin> RomyEatsDrupal: yeah, bostonhaskell :) hasn't happened much recently though
12:54:33 <copumpkin> but if you bug edwardk enough it'll happen
12:54:45 <PaulV_> Cale: it worked then, but that was on linux and with older versions of everything (now on Windows)
12:54:45 <koeien> PaulV_: did you mark the package as a library?
12:54:46 <kmc> i was thinking of starting a wiki page with a rundown of GHC extensions and whether I think each one is controversial
12:55:09 <RomyEatsDrupal> copumpkin: where are you located?
12:55:12 <kmc> http://haskell.org/haskellwiki/Use_of_language_extensions
12:55:19 <copumpkin> RomyEatsDrupal: I live near fenway
12:55:24 <copumpkin> what are you doing in boston and how long will you be around?
12:55:30 <RomyEatsDrupal> I'm new to the area.  Where is Fenway?
12:55:33 <PaulV_> koeien: it's both a library and an executable (and hi btw :P)
12:55:37 <ovrskr> any montrealers ?
12:55:42 <RomyEatsDrupal> i'm visiting the Algebraic Geometry conference at Harvard
12:55:55 <copumpkin> RomyEatsDrupal: in the back bay (it's where the red sox stadium is)
12:55:55 <RomyEatsDrupal> I am not a Haskell developer/programmer
12:56:25 <koeien> PaulV_: could you paste your .cabal file?
12:56:34 <koeien> @paste
12:56:34 <lambdabot> Haskell pastebin: http://hpaste.org/
12:56:35 <copumpkin> RomyEatsDrupal: ah :)
12:56:54 <RomyEatsDrupal> I am a web designer teaching herself programming.  My first introduction was Ruby, a month ago, on my flight from New York to Los Angeles.  I wanted to learn Haskell but it seemed too advanced to take on without some background first, so I decided to pick up Ruby as a background.
12:57:24 <elliott> Is it just me, or is the "recent package updates" on http://www.haskell.org/haskellwiki/Haskell somewhat lagged behind?
12:57:24 <hpaste> PaulV pasted ‚ÄúPackage file‚Äù at http://hpaste.org/50715
12:57:25 <copumpkin> cool :)
12:57:37 <RomyEatsDrupal> i've seen procedurally dictated scripts and programs, and would die to be able to one day do some functional programming
12:57:44 <maltem> apparently, Haskell is synonymous with advanced maths and luxury universities
12:57:50 <copumpkin> maltem: damn right
12:57:53 <elliott> RomyEatsDrupal: Learning Ruby might have made your future Haskell learning experience more difficult I'm afraid :P
12:58:00 <elliott> (or any imperative language)
12:58:11 <RomyEatsDrupal> After some research, I found Haskell was purely functional, so I was heavily seduced by that notion.
12:58:31 <RomyEatsDrupal> I have "Learn You Haskell" but I wish I can actually take a class with a teacher
12:58:32 <copumpkin> it's a world of its own :D
12:58:36 <RomyEatsDrupal> I learn best one-on-one.
12:59:04 <zachk> how much haskell do you know?
12:59:10 <dylukes> Haskell is best learned through practice, practice, practice.
12:59:10 <Cale> "It complicates the installation, if a user has to install a particular compiler to use your library." -- this is somewhat ironic
12:59:13 <dylukes> Pick small projects, and do them.
12:59:21 <RomyEatsDrupal> zachk: enough to make you scoff
12:59:36 <RomyEatsDrupal> I did the "Try haskell" .org several weeks back
12:59:40 <zachk> do you know about lambdabot?
12:59:51 <RomyEatsDrupal> but a few days ago I dug into the actual book while on the bus to Boston.
12:59:57 <RomyEatsDrupal> I decided to keep a "diary" of my learning progress.
12:59:58 <RomyEatsDrupal> http://nn.mayfirst.org/confessions
13:00:13 <kmc> Haskell's "purely functional" nature is a matter of library design and community norms, and not a language feature
13:00:21 <RomyEatsDrupal> so you can see that I know next to nothing for now, but I will record things i learn there
13:00:42 <kmc> Haskell is interesting not because it "forbids side effects" but because it takes seriously the idea that maybe you shouldn't use side effects everywhere all the time for no reason
13:00:46 <Cale> RomyEatsDrupal: the if/then/else in Haskell isn't an if *statement* though, it's an if *expression* :)
13:01:07 <sm_> PaulV_: looks ok, are you using -o anywhere ? or try with -v3 for more clues
13:01:10 <Cale> (which is why the else is required)
13:01:10 <RomyEatsDrupal> thanks Cale
13:01:16 <monochrom> just add "#define statement expression"
13:01:27 <Shviller> RomyEatsDrupal: BTW, it is an expression in Ruby as well.
13:01:56 <RomyEatsDrupal> Shviller: yes, and the other day, I learned a neat way to express that in Ruby
13:02:31 <RomyEatsDrupal> I've written mediocre, basic ruby scripts that just 'puts' strings and converts them into arrays and back
13:02:39 <confab> RomyEatsDrupal, are you going to share that neat way?
13:02:49 <Shviller> The biggest obstacle in learning Haskell from a Ruby background isn't that Ruby is imperative, but that it's object-oriented.
13:02:56 <RomyEatsDrupal> but while reading how Ruby handles "while" "if" , i came across a neat way to express it
13:03:06 <RomyEatsDrupal> confab: sure :D  I would be happy to
13:03:18 <PaulV_> sm_: I don't use -o anywhere, but will run with -v3 now
13:03:19 <c_wraith> Shviller: eh, if you've been writing OO software long enough, the fact that it's not OO is a very pleasant change :)
13:03:31 <ddarius> RomyEatsDrupal: Nice little naga.
13:03:41 <Shviller> c_wraith: very true
13:03:48 <kmc> it depends; sometimes OOP is actually the right tool
13:03:56 <kmc> but most programmers are taught that it's *the only* tool
13:04:05 <Shviller> kmc: very true x2
13:04:12 <kmc> you can do OOP in Haskell
13:04:16 <RomyEatsDrupal> Let's say we have a Song program that needs to be sung until everything is finished, and  we have a Ruby method for that
13:04:18 <kmc> when it's actually what you need, it's pretty pleasant
13:04:22 <rostayob> kmc: example for OO being the right tool? (not sarcastic)
13:04:24 <ddarius> kmc: No they aren't.  They are taught that there is also procedural programming which is inferior to object oriented programming in every way.
13:04:24 <copumpkin> kmc: we'll just ostracize you if you do
13:04:45 <confab> RomyEatsDrupal, some constructive criticism, your site is a bit hard to read with the colors, cool though
13:05:04 <Shviller> copumpkin: You can ostracize me instead of kmc. Game development. :)
13:05:14 * ddarius thinks OOP should really be COP and, in that context, is incredibly natural.
13:05:29 * copumpkin puts Shviller's name on an ostrakon
13:05:41 <maurer_> ddarius: What is the C in that acronym?
13:05:44 <RomyEatsDrupal> confab, well you should see my older website
13:05:47 <RomyEatsDrupal> it's even worse
13:05:47 <copumpkin> Crap
13:05:47 <ddarius> Concurrency.
13:05:48 <edwardk> copumpkin, ddarius, kmc: we're down in harvard square, open to suggestions
13:05:49 <kmc> rostayob, simulating a game world, maybe
13:05:51 <RomyEatsDrupal> http://romyromy.com
13:06:01 <confab> haha, i'm scared already
13:06:07 <ddarius> edwardk: There are a couple of bubble tea places and a Vietnamese pho place.
13:06:16 <kmc> note that OOP in Haskell does not imply that you invent a new type for each new behavior
13:06:18 <maurer_> kmc: OOP is a DSL for simulations. Accept or reject?
13:06:19 <copumpkin> I was going to say bubble tea
13:06:19 <edwardk> yeah we walked past the pho place
13:06:23 <rostayob> kmc: mhm
13:06:31 <kmc> behaviors are first-class values, so you can store them as data
13:06:37 <kmc> you invent types for interfaces, not implementations
13:06:38 <edwardk> we can wander over to the bubble tea shop, i forgot its name though
13:06:42 <copumpkin> we need first-class first-classness
13:06:46 <RomyEatsDrupal> Song.keep_singing until Song.sung ?
13:06:51 <kmc> this is nicer than using type classes for interfaces and types for implementations
13:06:56 <RomyEatsDrupal> that's the trick i learned in Ruby
13:06:56 <kmc> which is the default for beginners in Haskell
13:06:57 <confab> RomyEatsDrupal, that's not bad, but it's readable.  Something about the font on your new site hurts my eyes
13:07:10 <kmc> because Java teaches them that every new behavior needs a new type -- even though that's not intrinsic to OOP
13:07:27 <dylukes> Hm.
13:07:33 <elliott> shadows on body text are pretty terrible for readability
13:07:34 <RomyEatsDrupal> confab: what colors are hard on your eyes on the new one ?  everything is in shades of gray, lol
13:07:34 <dylukes> Even when I get the HEAD of cabal-install,
13:07:39 <dylukes> it insists on downloading 1.10.1.0
13:07:43 <elliott> RomyEatsDrupal: <elliott> shadows on body text are pretty terrible for readability
13:07:44 <dylukes> which won't work (and I already have 1.12)
13:07:52 <copumpkin> I want a language that can change its syntax at runtime!
13:07:58 <copumpkin> first-class syntax
13:08:03 <elliott> copumpkin: perl six
13:08:08 <copumpkin> not flexible enough
13:08:09 <rostayob> on a different note, I can't get the ghc source for some reason. "error: couldn't connect to host while accessing http://darcs.haskell.org/ghc.git/info/refs" . more surprisingly, I can as su
13:08:17 <copumpkin> arbitrary new syntax as you go along
13:08:19 <dylukes> Does anyone know how I can get a version of cabal install compatible with 1.12?
13:08:21 <ddarius> edwardk: There are two.  There's one if you take the left branch in Mass Ave (JFK) at Out of Town News heading away from Porter Square (i.e. north) and there's one that's just farther down the street heading west on the road just past the Vietnamese place.
13:08:21 <edwardk>  ddarius: vietnamese?
13:08:22 <elliott> copumpkin: Pretty sure Perl six has that, dude
13:08:25 <RomyEatsDrupal> elliott: indeed, i've been meaning to tone down the shadow, thanks!
13:08:28 <copumpkin> your program could start as C and turn into haskell by the end of the file
13:08:29 <elliott> copumpkin: That's one of the design goals
13:08:31 <elliott> RomyEatsDrupal: np
13:08:40 <edwardk> we're right around the corner from that
13:08:48 <elliott> copumpkin: Nemerle too, I believe; http://en.wikipedia.org/wiki/Nemerle#Metaprogramming
13:08:54 <copumpkin> not flexible enough either
13:08:56 <BCoppens> @seen bos
13:08:57 <lambdabot> Unknown command, try @list
13:08:57 <preflex_>  bos was last seen on #haskell 1 day, 21 hours, 21 minutes and 51 seconds ago, saying: An IORef is completely atomic
13:09:01 <RomyEatsDrupal> anyone here ever did web development /  web application programming with Haskell?
13:09:03 <edwardk> lets meet up at the vietnamese place, eat, and plan from there
13:09:07 <rostayob> RomyEatsDrupal: yes
13:09:10 <elliott> copumpkin: How about Forth, then :)
13:09:10 <monochrom> SGML may change syntax at run time
13:09:11 <Shviller> Oh, guys. Speaking of learning Haskell. I've read Learn You a Haskell. Should I read The Haskell School of Expression? I'm trying to switch from OO thinking to FP thinking, and I picked that book based on name alone.
13:09:11 <copumpkin> elliott: I said runtime
13:09:24 <elliott> copumpkin: Well, Perl 6 syntax changing _is_ runtime.
13:09:25 <ddarius> RomyEatsDrupal: Contrast usually makes reading easier.
13:09:26 <rostayob> RomyEatsDrupal: I did some we dev, but nothing actually in production
13:09:33 <elliott> copumpkin: As is Forth's, if you can even call it that.
13:09:34 <copumpkin> RomyEatsDrupal: the #snapframework people do a lot of that :)
13:09:47 <rostayob> RomyEatsDrupal: #happstack and #yesod to eheh
13:09:47 <monochrom> The Haskell School of Expression is good
13:09:51 <kmc> judging a book by its cover eh
13:09:55 <PaulV_> sm_: it works now nvm (http://www.haskell.org/pipermail/haskell-cafe/2007-November/034689.html)
13:09:56 <Shviller> yup
13:10:01 <RomyEatsDrupal> copumpkin: i've just joined snapframework
13:10:05 <RomyEatsDrupal> THANK YOU
13:10:18 <copumpkin> :)
13:10:27 <RomyEatsDrupal> WOW!  Haskell has a package manager!
13:10:34 <RomyEatsDrupal> I wonder if this will work with my Debian!
13:10:37 <kmc> most languages do
13:10:53 <monochrom> haskell does not have a package manager. (for example cabal is not.)
13:10:54 <kmc> and people will protest cabal isn't really a package manager
13:10:58 <Shviller> RomyEatsDrupal: have you used Ruby's gem? cabal's similar.
13:11:02 <kmc> for example it does not allow you to remove packages
13:11:03 <ovrskr> i don't think cabal is considered a package manager
13:11:12 <ovrskr> too late
13:11:15 <kmc> it's more like "make"
13:11:17 <monochrom> cabal doesn't even track some packages
13:11:20 <kmc> though still much better
13:11:23 <ddarius> copumpkin: You should learn Forth.
13:11:23 <c_wraith> yikes.  mixing apt with cabal for installing haskell packages will doom you to agony
13:11:27 <RomyEatsDrupal> Shviller: yes, I've used Ruby's gem numerous times lately
13:11:30 <sm_> copumpkin: racket ?
13:11:34 <kmc> c_wraith, it hasn't bitten me... yet
13:11:41 * ddarius wonders if his Forth-like language supports parsing words.  I think so very indirectly.
13:11:42 <RomyEatsDrupal> Ah, I see.
13:13:36 <sm_> PaulV_: good to know
13:14:35 <bfig> hello. can i store local variables in ghci?
13:14:47 <monochrom> yes. "let x=1"
13:14:54 <bfig> ty
13:14:57 <dafis> bfig: you can bind values via let in ghci
13:15:06 <monochrom> local variable functions too. "let f = \x -> x"
13:15:12 <bfig> awesome
13:15:16 <RomyEatsDrupal> I just read up on Cabal, I see it is indeed, more like 'make'
13:15:37 <monochrom> if the value has to come from an IO command, "y <- getCurrentTime"
13:16:23 <PaulV_> sm_: weirdly enough it worked in 2010, so they fixed it between 2007 and 2010, and then unfixed it after that
13:16:34 <copumpkin> omg an augustss
13:16:49 <rs464> If I define:
13:16:54 <rs464> newtype MyType = MyType Double deriving (Fractional)
13:16:59 <rs464> Why can I not:
13:17:03 <rs464> let i = 2.0::MyType
13:17:07 <rs464> let x::Double = i / 4.0
13:17:08 <rs464> ?
13:17:19 <dafis> :t (/)
13:17:20 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:17:25 <kmc> > (2 :: Float) / (4 :: Double)
13:17:26 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
13:17:26 <lambdabot>         against inferred typ...
13:17:33 <kmc> Haskell does not have implicit conversions, period
13:17:35 <dafis> rs464: args and result have the same type
13:17:44 <augustss> Also let x::Double = ‚Ä¶ is not Haskell
13:17:46 <monochrom> wait, don't you need (Fractional, Show, Num, a lot more)?
13:17:59 <rs464> sure, you'd need more
13:18:11 <monochrom> alright no problem
13:18:12 <rs464> but I put Fractional because that provides (/)
13:18:27 <kmc> it also provides fromRational
13:18:33 <kmc> which is used to implement the literal 2.0
13:18:42 <monochrom> let me see if Fractional is enough for automatic conversion of "2.0"
13:19:00 <kmc> (x :: S) / (y :: T) is never going to work if S /= T
13:19:10 <kmc> you can tell that from the type of (/)
13:19:11 <erus`> is there a haskell dating website?
13:19:15 <erus`> im gonna make one
13:19:19 <rs464> augustss: with -XScopedTypeVariables it is ?
13:19:22 <monochrom> hmm, Fractional should be enough
13:19:22 <dafis> kmc: import Prelude hiding (/)
13:19:25 <monochrom> @type 2.0
13:19:26 <lambdabot> forall t. (Fractional t) => t
13:19:27 <roconnor> erus`: there is haskellers.com
13:19:29 <dafis> *((/))
13:19:52 <sm_> erus`: haskellers.com
13:20:04 <rs464> kmc: even if S derives T ?
13:20:22 <rs464> (x :: S) / (y :: T), where S derives T ?
13:20:32 <sm_> ack
13:21:03 <kmc> rs464, that makes no sense
13:21:08 <kmc> S and T are types, not type classes
13:21:27 <copumpkin> rs464: haskell doesn't have subtyping
13:21:38 <kmc> the things you derive are type classes, and it's just shorthand for writing the boilerplate instance yourself
13:21:52 <monochrom> hmm, "2.0 :: MyType" works in ghci
13:22:08 <kmc> Float and Double are types; Num and Fractional are type classes
13:22:24 <rs464> cool, yup my mistake
13:22:37 <rs464> copumpkin: I think that was the root of my question :-)
13:22:43 <monochrom> but of course (x :: Double) / (y :: Mytype) is not going to work. ever
13:22:47 <MatrixFrog> is there a way to make ghci's ":t" expand out any type synonyms?
13:22:52 <monochrom> > (1 :: Float) / (2 :: Double)
13:22:52 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
13:22:53 <lambdabot>         against inferred typ...
13:23:07 <monochrom> even that is not going to work. type mismatch. simple type mismatch
13:24:40 <kmc> the use of the keyword "deriving" is probably almost as unfortunate as the use of the keyword "class"
13:24:45 <kmc> in terms of building false intuition
13:25:07 <rs464> kmc: that's what's landed me here :-|
13:25:15 <dafis> kmc: it's the OOP use of class that is wrong
13:25:17 <ion> How about the function ‚Äúreturn‚Äù? :-)
13:26:03 <kmc> that goes pretty high on the list too
13:26:07 <kmc> you can't win though
13:26:08 <monochrom> people even take issues with "data", "type", "newtype"
13:26:24 <kmc> "class" and "deriving" are bad because they're familiar; "Monad" is bad because it's weird mathspeak
13:26:27 <kmc> you can't win
13:26:38 <monochrom> "I am defining a NEW TYPE! why is it called data not newtype?"
13:26:48 <kmc> yeah, "newtype" is unfortunate
13:27:07 <kmc> it suggests it's like "type", when it's more like "data"
13:27:17 <monochrom> screw all people who think they can just guess meanings from names
13:27:40 <MatrixFrog> but also, screw misleading names
13:27:48 <kmc> it mostly works when your languages are all trivial syntactic remappings of each other
13:28:13 <monochrom> every short name has to be misleading
13:28:33 <dafis> id?
13:28:38 <MatrixFrog> i don't think that's true at all
13:28:45 <MatrixFrog> "data" is pretty clear
13:28:47 <MatrixFrog> "import"
13:28:59 <kmc> the Haskell meaning of "Monad" or "Functor" is also pretty far from what those words mean in category theory
13:29:16 <rwbarton> id x tells you the ID of x, of course
13:29:20 <monochrom> information theory proves it. two few letters implies not enough information. then people start guessing
13:29:28 <rwbarton> which since haskell is referentially transparent is just x itself!
13:29:35 <copumpkin> lol
13:30:19 <maurer_> kmc: Closer than the C usage of Functor >_>
13:31:06 <co_dh> greeting guys, what are the adjunction of Maybe monad?
13:34:21 <copumpkin> kmc, ddarius : we are summoned to hahvahd square
13:34:33 <copumpkin> I'm gonna leave nowish and it'll take me a little bit to get there
13:34:40 <hpaste> MatrixFrog pasted ‚ÄúChurch numerals‚Äù at http://hpaste.org/50717
13:35:01 <MatrixFrog> can someone help me understand why it doesn't like my type signature for "pow"?
13:35:26 <monochrom> "data" is pretty clear. in BASIC. "100 DATA 10, 20, 30, 20, 50, 700". it's for attaching a lot of data (values) into the program. not for adding a new type, which should be called newtype.
13:35:46 <MatrixFrog> i'm more or less following http://users.info.unicaen.fr/~karczma/Essays/church.html
13:36:00 <monochrom> but I grant you "import" is clear enough
13:36:28 <djahandarie> 'type' is probably better than 'newtype'. Otherwise we'd be sticking 'new' on everything we define ever.
13:36:44 <Cale> Meh, the Haskell meaning of Functor and Monad is just a special case of the categorical one, that's fine.
13:37:03 <dafis> MatrixFrog: coment out the type signature and ask ghci what it thinks
13:37:11 <rwbarton> co_dh: one of the categories involved in the adjunction is not going to be Hask, unless there is some clever trick I'm missing
13:37:14 <MatrixFrog> yup. and i got this:
13:37:15 <ddarius> kmc: With the laws, they are instances of the categorical notion.
13:37:20 <Cale> The Control.Category definition of Category is pretty bizarre though :)
13:37:21 <djahandarie> Cale, if we're being picky, Hask isn't a category so it isn't :p
13:37:27 <ddarius> Cale: It's defining Hom.
13:37:47 <co_dh> rwbarton: It doesn't matter if it's Hask or not, :)
13:37:52 <Cale> djahandarie: oh?
13:38:01 <MatrixFrog> pow :: ChurchN a -> ((ChurchN a -> ChurchN a) -> ChurchN a1 -> t) -> t
13:38:05 <rwbarton> co_dh: there is an adjunction between Hask and the category of types-equipped-with-a-Pointed-instance, where class Pointed a where point :: a
13:38:13 <ddarius> Hask is undefined usually, so saying whether it is a category or not is premature.
13:38:14 <Cale> Are you talking about stuff which is only distinguishable via seq?
13:38:29 <MatrixFrog> i realized that if you set a1=a, and t=ChurchN a, then you can write that as: pow :: ChurchN a -> (ChurchN (ChurchN a)) -> ChurchN a
13:38:36 <Cale> (because the answer to that is easy: ignore it :)
13:38:41 <rwbarton> co_dh: one of the adjoints takes a type with such an instance and forgets about the instance
13:38:55 <rwbarton> co_dh: you might enjoy figuring out how the rest works youself
13:39:26 <gwern> @quote
13:39:26 <lambdabot> commone_sense_says says: : SPJ will be a legend after his death
13:39:36 <Cale> Here's a question: has anyone ever used seq at a function type in a way which is crucial to their program's performance?
13:39:52 <rwbarton> co_dh: I assume you are asking what adjunction has the Maybe monad as its associated monad
13:39:57 <Cale> (Because I haven't)
13:39:59 * MatrixFrog has an idea... sort of...
13:40:00 <co_dh> rwbarton: what are the object, morphism, composition of that category of types-equipped-with-a-Pointed-instance?
13:40:05 <rwbarton> good question
13:40:12 <ddarius> Since lambda is lazy when viewed as the constructor of function types, usually you don't want to do it.
13:40:14 <rwbarton> the objects are not exactly things you can write down in Haskell
13:40:19 <ddarius> Of course, there is the issue of -semantics-.
13:40:27 <co_dh> rwbarton: yes, constructing adjunction from monad.
13:40:50 <rwbarton> but you can think of an object as a type, together with a distinguished value of that type (the "base point")
13:41:05 <Cale> co_dh: Every monad comes from an adjunction in at least two ways (though it's possible for these two to be identical).
13:41:09 <co_dh> using either Eilenberg-Moore algebra or Kleisli Category.
13:41:23 <ddarius> Cale: Equivalent.
13:41:24 <Cale> right
13:41:32 <rwbarton> co_dh: a morphism from (A, a :: A) to (B, b :: B) is a function f : A -> B in Hask which is required to satisfy f a = b
13:41:41 <Cale> Yes, equivalent would be a better choice of word :)
13:41:56 <rwbarton> hmm
13:41:57 <Cale> I guess it's not really possible for them to be *identical* :)
13:42:12 <rwbarton> I'm trying to construct the Maybe monad from a particular adjunction
13:42:19 <ddarius> Cale: I would be impressed to see such an example, but mayhaps it's not completely impossible.
13:42:44 <co_dh> rwbarton:  can we call the point as bottom ?
13:42:50 <Cale> ddarius: It would really depend carefully on how you formalise everything.
13:42:53 <rwbarton> I'm not thinking about bottom at all
13:43:06 <rwbarton> as far as I'm concerned, it doesn't exist
13:43:18 <rwbarton> If you want to include bottom, then the point may or may not be bottom
13:43:23 <rwbarton> it certainly doesn't have to be, though.
13:43:34 <Eduard_Munteanu> That sounds like pointed types :)
13:43:45 <co_dh> rwbarton: yep, you are right. bottom is a point, but not the reverse.
13:44:03 <rwbarton> I suggest working out the situation without worrying about partial values first, and then moving to the setting with bottoms if you like
13:44:14 <Cale> co_dh: Okay, so do you know what the Kleisli category for the Maybe monad looks like?
13:44:48 <Cale> co_dh: It has the same objects as Hask, but the arrows A ~> B in the Kleisli category are arrows A -> Maybe B in Hask.
13:44:54 <co_dh> Cale: need to do some exercise to get that answer.
13:45:16 <co_dh> Cale: yep, with a different composition defined.
13:45:29 <Cale> the identity arrows in this category are given by return, and the composition is (<=<)
13:45:35 <co_dh> I'm trying to write it in Haskell .
13:45:47 <co_dh> great!
13:46:19 <ddarius> rwbarton: The algebras that you are talking about would also be isomorphic to coalgebras.
13:47:14 <co_dh> Cale: then how can I get the adjunction are the Kleisli Category of Maybe monad?
13:47:27 <ddarius> Er nevermind.
13:48:09 <co_dh> Cale: I know it's the initial object of that Kleisli, but just don't know how to express it in Haskell.
13:48:57 <co_dh> @t (<=<)
13:48:58 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:49:06 <co_dh> @type (<=<)
13:49:07 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
13:49:09 <ddarius> It's not the initial object of the Kleisli category, that's not even at the right level.
13:50:29 <co_dh> ddarius: http://en.wikipedia.org/wiki/Eilenberg%E2%80%93Moore_algebra
13:51:32 * hackagebot monad-control 0.2.0.3 - Lift control operations, like exception catching, through monad transformers  http://hackage.haskell.org/package/monad-control-0.2.0.3 (BasVanDijk)
13:51:34 * hackagebot srec 0.1.0 - Parsing and processing s-records.  http://hackage.haskell.org/package/srec-0.1.0 (TomHawkins)
13:51:52 <co_dh> ddarius: yep, you are right.
13:52:16 <ddarius> co_dh: What that is saying is the Kleisli category construction is initial in a category of adjunctions factoring a monad, not that a monad is the initial object in a Kleisli category.
13:53:08 <co_dh> ddarius: yep
13:53:33 <MatrixFrog> (mul n) :: ChurchN a -> ChurchN a
13:53:49 <MatrixFrog> so then, m (mul n) :: ChurchN a -> ChurchN a
13:54:17 <MatrixFrog> of course, succ zero :: ChurchN a
13:54:41 <MatrixFrog> so then it should be true that: m (mul n) (succ zero) :: ChurchN a
13:55:35 <co_dh> but this don't gives me the definition of the adjunction, either in Haskell, or category language
13:56:06 <co_dh> oh, no , It gives an adjunction in category language,
13:56:17 <MatrixFrog> so i really don't see what i'm doing wrong
13:56:18 <ddarius> Yes, and every adjunction gives rise to a monad.
13:56:33 <rwbarton> MatrixFrog: what is the type of 'm' in all this?
13:56:43 <MatrixFrog> ChurchN a
13:56:54 <MatrixFrog> this is the function i'm trying to write:
13:56:55 <MatrixFrog> pow :: ChurchN a -> ChurchN a -> ChurchN a
13:56:55 <MatrixFrog> pow n m = m (mul n) (succ zero)
13:57:03 <ddarius> Well, it would need to be ChurchN (ChurchN a) in this instance.
13:57:04 <rwbarton> but you're trying to apply it to something of type (ChurchN a -> ChurchN a)
13:57:17 <ddarius> This is part of why you need a universal type for Church numerals.
13:57:35 <rwbarton> and ChurchN a is (a -> a) -> (a -> a), and a is not the same as ChurchN a
13:58:28 <ddarius> :t let pow n m = m n where n :: (a -> a) -> a -> a; n = n in pow
13:58:29 <lambdabot> forall t a t1. t -> (((a -> a) -> a -> a) -> t1) -> t1
13:58:59 <ddarius> :t let pow n m = m n `asTypeOf` n where n :: (a -> a) -> a -> a; n = n in pow
13:58:59 <lambdabot> forall t a a1. t -> (((a -> a) -> a -> a) -> (a1 -> a1) -> a1 -> a1) -> (a1 -> a1) -> a1 -> a1
13:59:21 <MatrixFrog> i originally wrote: type ChurchN = (a -> a) -> a -> a
13:59:50 <ddarius> MatrixFrog: Where is that a supposed to come from?
13:59:54 <kmc> really it's data ChurchN = MkN (forall a. (a -> a) -> a -> a)
14:00:02 <kmc> but that's not a Haskell type
14:00:21 <ddarius> type ChurchN = forall a. (a -> a) -> a -> a is a legal with the appropriate extension.  There's no need to make a data type.
14:00:33 <ddarius> Except that you can't make instances of that.
14:00:37 <ddarius> Also, it should be newtype.
14:00:37 <kmc> but they won't be as first class as you'd like
14:00:47 <kmc> newtype is premature optimization ;)
14:00:51 <kmc> but, yes
14:00:54 <djahandarie> No, semantics!!!
14:00:56 <ddarius> kmc: It's semantics not performance.
14:01:10 <kmc> why do the semantics of _|_ ChurchN matter?
14:01:12 <ddarius> Admittedly, even then you are going to have a bunch of "junk" values.
14:01:38 <djahandarie> You get junk values when you work with Haskell no matter what really
14:01:56 * kmc quotes djahandarie out of context, uses it to promote PHP
14:02:05 <djahandarie> D:
14:02:10 <kmc> :D
14:02:18 <ddarius> kmc: Lacking context doesn't really change anything.
14:02:19 <MatrixFrog> i try not to use language extensions, generally
14:02:37 <ddarius> MatrixFrog: Then you will not be able to faithfully represent/use Church encoded types.
14:02:50 <rwbarton> you can start with newtype D = D (D -> D) and go from there
14:03:11 <kmc> i use gratuitous syntactic extensions a lot, but I justify it by saying the code is easily removed
14:03:12 <ddarius> rwbarton: You may want to add another constructor so you can see anything at all.
14:03:12 <rwbarton> though, there's not much you can do with that besides wait and see if it terminates
14:03:28 <kmc> the hardest to eliminate class of extensions is probably the type class stuff
14:03:33 <MatrixFrog> ok fair enough, i'll use it then :) so what is the fundamental difference between my "ChurchN a" and your suggested "type ChurchN = forall a. ..."
14:03:37 <kmc> IncomprehensibleInstances and the like
14:04:14 <djahandarie> IncomprehensibleInstances? What does that do?
14:04:20 <ddarius> MatrixFrog: Given a single ChurchN I can instantiate it to any type I need.  I.e. the user gets to choose rather than the creator of the numeral.
14:04:20 <kmc> not a thing
14:04:24 <djahandarie> lol
14:05:27 <MatrixFrog> so the exact same church numeral could be of type (Int -> Int) -> Int -> Int, and also (Char -> Char) -> Char -> Char
14:05:39 <MatrixFrog> and haskell doesn't decide which one it is until you try to use it as one or the other
14:05:48 <MatrixFrog> or actually it's of BOTH types at the same time sort of?
14:05:50 <zzo38> Is this good so far?     http://www.haskell.org/haskellwiki/User:Zzo38/Proposal_for_more-notation
14:05:52 <ddarius> It can be instantiated to those types.  It's not either of those types.
14:06:32 <ddarius> MatrixFrog: It's like a function.  You don't think of not as being BOTH True and False.
14:08:43 <ddarius> zzo38: My initial impression is that that's completely fucked up.
14:09:19 <jmcarthur> i am confused by this proposal
14:09:30 <zzo38> ddarius: OK. Can you please be more specific with your criticisms and other opinions and ideas etc?
14:09:44 <kmc> it lacks motivating examples, for one
14:10:00 <ddarius> What kmc said would be one of my first criticisms.  Why do I want this?
14:10:13 <zzo38> It does have examples.
14:10:21 <jmcarthur> *motivating* examples
14:10:24 <MatrixFrog> you evaluate it and it gives you a result of either true or false. similarly, you use the same church numeral in different places, and it acts like a different type each time, depending on how you're using it
14:10:30 <ddarius> zzo38: What is the semantics of "more" things from other modules?  What is their scope?  What is the semantics of conflicting ones?  What is their binding structure?  Can I nest them?
14:10:37 <kmc> why is it good; why is it better than the alternatives.  what's the problem being solved?
14:10:49 <zzo38> ddarius: OK, thanks for notifying me of those things.
14:11:39 <MatrixFrog> ok that makes sense
14:11:40 <ddarius> Even if you answered all of those, I'm pretty sure what you seem to be driving at would be grotesque and confusing.
14:12:28 * dafis agrees with ddarius
14:12:45 <zzo38> About "more" things from other modules, I never had any idea; it could be OK if it only works within a module, I suppose (you could use include files). Yes they can be nested. What does "binding structure" mean?
14:13:23 <kmc> zzo38, can you add an example of something simple and concrete, which is ugly to do in Haskell, and nice in Haskell+moresyntax
14:13:59 <ddarius> zzo38: Apparently it can bind names both in declaring a "more"-thing and in using it.  What are the rules for such bindings?
14:14:24 <kmc> when you use a "more" it can bind new names not mentioned locally?
14:14:32 <zzo38> ddarius: Only using the word "more" marks that word as a more-name.
14:14:34 <ddarius> Also, if I use this notation within a declaration, can I do so recursively?
14:14:50 <zzo38> kmc: If it binds new names they must be local to the more-declaration using them.
14:14:54 <Cale> zzo38: What is this I don't even...
14:15:06 <zzo38> ddarius: Yes, you can use them recursively.
14:15:20 <zzo38> But only as far as it is not ambiguous.
14:15:33 <Cale> I don't understand the goal of this notation at all.
14:15:41 <ddarius> In: more Doing a = a <- return $ x a, it looks like it binds Doing, has a bound in it, and binds x when used but uses x from, I guess, the top-level scope within the declaration.
14:15:55 <kmc> i'm still missing the motivation
14:16:07 <Cale> I don't understand why you'd want this either.
14:16:41 <zzo38> This more notation would be especially useful when combined with Template Haskell as well. I have ideas using it with all sorts of kinds of programming, such as inventing rules for Magic: the Gathering or roguelikes or Inform 7 by using a combination of new monads with more-notation.
14:17:34 <zzo38> ddarius: Actually, Doing is already defined. What it does is the "a" there is bound to the "x" in the do-block, while the "x" in that outer is the top-level "x".
14:18:00 <Cale> Isn't this problem already solved by variable binding, or is the point that you can splice in larger chunks of code? I don't get it.
14:18:02 <jmcarthur> can you give an example of how this improves your code?
14:18:15 <jmcarthur> a concrete example, not just a syntactic demonstration?
14:18:20 <zzo38> Cale: You can do other things too.
14:18:22 <Cale> Yeah, I can't really think of a case where this would really be useful.
14:18:24 <zzo38> jmcarthur: OK, I will try.
14:18:45 <ddarius> zzo38: You should have an example ready, otherwise why did you ever want to do this?
14:19:02 <zzo38> ddarius: OK, I will try to write better example.
14:19:13 <Cale> Okay, in the first example under 3.2, what is the type of X?
14:19:22 <kmc> zzo38, something simple and concrete
14:19:26 <Cale> That would be my first question.
14:19:27 <kmc> with a comparison to the way it's done in Haskell
14:19:39 <ddarius> Uh-oh, Cale brought out the big hammer.  The question that resolves all such things.
14:19:42 <zzo38> kmc: OK.
14:19:44 <rwbarton> I don't think X is a value at all
14:20:03 <zzo38> Cale: X does not have a type. It does not have a value either.
14:20:07 <rwbarton> unless it is some sort of template haskell value
14:20:11 <zzo38> X is a more-name.
14:20:19 <Cale> You're saying that X is equal to some things.
14:20:26 <kmc> when this came up in #ghc this reminded me of She's fake aspect-oriented programming
14:20:31 <Cale> But those things aren't equal to each other.
14:20:48 <Cale> So, there's obviously some funky notational business going on here
14:20:54 <zzo38> kmc: Yes it is similar to She's fake aspect-oriented programming, but I think my idea has better a lot of things
14:20:55 <rwbarton> I think that is just syntax, you can pretend the syntax is #define X ... if you like
14:21:07 <Cale> But hey, there's some precedent for that in the language, with data declarations
14:21:10 <zzo38> rwbarton: Yes it is just syntax.
14:21:21 <ddarius> kmc: Yes, this is quite blatantly a weaving implementation of some aspect-oriented notion.
14:21:25 <kmc> zzo38, in general you should have standalone justifications for your extensions.  "making Haskell more like Inform 7 and Magic: The Gathering" is not going to resonate with most people
14:21:54 <kmc> also, the impression i get is that you haven't really used or studied Haskell all that much, and you're already trying to modify the language and do crazy hacks with Template Haskell etc.
14:22:08 <ddarius> My biggest issue is the fact that you can hide bindings within these.
14:22:20 <zzo38> kmc: It isn't more like either of those things; but it allows you to do some of the things those systems will do. But not all of it. Other parts can be done using Template Haskell and/or even with monads and stuff.
14:22:21 <rwbarton> indeed, that seems to be the only point of the first example
14:23:07 <Cale> I don't understand why you'd want to hide the fact that you're binding variables. That just makes for unreadably confusing code.
14:23:54 <Cale> especially when those variables shadow other things in scope
14:24:49 <ddarius> Cale: Here's a fun one.  do x <- foo; more Doing x; more Doing x; return x
14:25:33 <zzo38> Cale: That particular example is not a code you would actually write; it is a bit stupid to shadow other things in that way, but it demonstrates how the scope has to be kept track of properly.
14:26:10 <ddarius> zzo38: It demonstrates that, following a more use, you no longer have any guarantee of what anything means.
14:26:13 <zzo38> ddarius: In that case all the more-declarations are included twice. First all of them once, and then all of them a second time.
14:26:52 <ddarius> zzo38: I know what the intent is, it's just even more confusing than the original.
14:27:02 <Cale> AbcField = age_of :: Int = 0; -- I'm sorry, but this is awful
14:27:13 <co_dh> what are the morphsim in Adj(C,T) in http://en.wikipedia.org/wiki/Eilenberg%E2%80%93Moore_algebra?
14:28:12 <MatrixFrog> :( so my old "ChurchN a" definition had Eq and Show instances
14:28:21 <MatrixFrog> and now i can't seem to do them
14:28:34 <MatrixFrog> Illegal polymorphic or qualified type: ChurchN
14:28:41 <zzo38> One use is for add-ons where you need to add fields for your own purposes and rules that must be followed in a specific order (that is one of the reasons for the "order" of more-declarations). For example, in Magic: the Gathering, as well as being possible to make a roguelike game like that, each card (or item or action or whatever) has its own rules associated so you need to keep track of them including if more things are added (such as creatur
14:28:53 <MatrixFrog> meaning, you can't write typeclass instances for "forall a." types?
14:29:06 <zzo38> Cale: How is that awful? What is wrong with it?
14:29:17 <zzo38> ddarius: OK. How do you think?
14:29:28 * applicative wants more notation, not more-notation
14:29:57 <benmachine> MatrixFrog: three hours ago you were trying to compile a thing I wrote, how did that go
14:30:12 <ddarius> MatrixFrog: Yes, which is what I said earlier.
14:30:23 <zzo38> applicative: O, that is what you want? Then you have to be more specific please
14:30:28 * ddarius wants less notation.
14:30:43 <zzo38> ddarius: And be specific about that too please.
14:30:46 <Cale> zzo38: It parses in my head as   AbcField = (ageOf :: (Int = 0))
14:31:03 <MatrixFrog> benmachine: it worked! i had to change the haskell-src-exts dependency though :)
14:31:04 <ddarius> zzo38: That was a general statement.  I don't want your proposed extension at all.
14:31:08 <MatrixFrog> i was going to do a pull request at some point
14:31:19 <benmachine> oh right
14:31:23 <benmachine> I'll go have a look
14:31:25 <MatrixFrog> ddarius: oh, i see
14:31:38 <ddarius> It also seems to fail at actually solving the problem it seems to be addressing in any meaningful sense, since it seems that you would still have to modify the original module to add cases.
14:31:43 <zzo38> Cale: OK. I see why you think it is wrong, but I disagree.
14:31:44 <benmachine> hmm can I blame chrisdone for this
14:31:44 <MatrixFrog> i didn't really understand you before, sorry :)
14:31:46 <kmc> zzo38, have you implemented a roguelike game in Haskell? have you implemented a M:TG engine in Haskell?
14:31:48 <Cale> zzo38: and even though I can tell it's meant to be something like AbcField = ((ageOf :: Int) = 0), it's still really weird to have two equals signs like that
14:32:19 <benmachine> oh yeah my deps are just completely incompatible
14:32:28 <Cale> zzo38: Also, the semantics are bizarre -- it splices a new field with value 0 into every value of type Abc?
14:32:29 <zzo38> ddarius: You could add both cases and constructors using more-notation. Have one for case and one for data
14:33:03 <ddarius> zzo38: That's not the point of what I said.  The point is that you'd still have to change the original module, at which time it hardly matters where in that file you write this stuff.
14:33:39 <zzo38> Cale: Well, kind of. It makes a new field of type Int and anywhere that "more AbcField" is typed in where an expression is expected (instea of a definition of a constructor), it gives that new field the value zero.
14:34:12 <zzo38> ddarius: If you have include files then it would work.
14:34:17 <Cale> I still don't understand why you want this.
14:34:38 <kmc> you're all too nice
14:34:46 <Cale> Particularly in the case of 3.3, it means that every pattern match is potentially incomplete.
14:35:14 <Cale> Well, every pattern match on a type with one of these more things in it, anyway
14:35:16 <ddarius> zzo38: No, it would just tightly couple the two files.  The point is, I, in my own module, maybe as a separate application, can't extend your cases without rebuilding your library making it then incompatible with the original version.
14:35:17 <zzo38> It could possibly even be designed for use with other modules, where you have a MORE pragma on the import to tell it that it requires to use more-notation to combine these modules
14:35:52 <Cale> zzo38: Can you give us an example of it making some program shorter and/or easier to read?
14:35:57 <zzo38> ddarius: They would not be binary-compatible, is true. But it is probably still source-compatible.
14:36:21 <Cale> Because all of these examples just look much worse than their expansions in terms of the syntax.
14:36:23 <kmc> new pragmas? changing the "import" syntax?
14:36:24 <zzo38> Cale: That is the reason to combine more-notations in data with more-notations in case.
14:36:40 <Cale> zzo38: Like, why would you *want* to write:
14:36:43 <Cale> data T = Zero | more T deriving (Eq);
14:36:43 <Cale> T = Two | Three | Four;
14:36:43 <Cale> T = One | Two;
14:36:43 <ddarius> zzo38: Which means I would need to need to recompile any dependency that also used your library, except they'd likely have their own additions and there would be no resolution at all.
14:36:48 <Cale> rather than just writing:
14:36:51 <Cale> data T = Zero | One | Two | Three | Four deriving (Eq);
14:37:07 <Cale> in the first place?
14:37:11 <ddarius> zzo38: The point is you'd want extensible sums/products without having to rebuild the library.
14:37:44 <zzo38> Cale: That example is very simple, but in much more complicated situations you might want to specify each add-on individually
14:38:26 <kmc> give us a real example
14:38:59 <zzo38> kmc: OK I will try
14:39:29 <ddarius> zzo38: Note that most of this can be done with TH in a way that is more sensible.  I.e. you have your makeT function which takes a list of alternatives and generates the T data type, you can then use it as a splice as $(makeT $ someCases ++ someMoreCases) and then define those cases elsewhere.
14:39:58 <zzo38> Cale: Another thing wrong with that example is that it becomes more useful to see why you do that when deriving Ord or when using the enumeration in the "order" of other more-declarations.
14:40:36 <Cale> I have a feeling that if this feature was used extensively in a program that I had to maintain, it would make me want to tear my eyes out, because it would be nearly impossible to know the complete definition of anything, what variables were in scope at a given point, what those variables referred to, whether a pattern match is complete or not, and a bunch of other things.
14:40:37 <ezyang> Is there a paper describing how GHC's time/space profiler works?
14:40:45 <kmc> yay, a question about Haskell
14:41:03 <ddarius> ezyang: Probably.
14:41:07 <ezyang> Looks like "Time and space profiling for non-strict, higher-order functional languages"
14:41:09 <ddarius> They will be old though.
14:41:18 <dafis> Cale: easy solution: rm *.hs
14:41:26 <kmc> Cale, the problem of invisible binders is my main reservation with RecordWildCards
14:41:30 <kmc> it's a useful extension though
14:41:43 <kmc> rather, with using wildcards in record patterns specifically
14:41:43 <ddarius> kmc: At least that's relatively controlled/localized.
14:41:57 <kmc> it's kind of like local open for a module
14:42:01 <kmc> a first-class module :)
14:42:12 <zzo38> Cale: Then don't maintain such a program.
14:42:21 <kmc> which can define values, and abstract types (through existentials)
14:42:22 <Cale> Yeah, you at least know what you're getting in to there, though perhaps NamedFieldPuns is better in that regard.
14:42:26 <kmc> but not concrete types
14:42:26 <ddarius> Cale: You can't fight that logic.
14:42:51 <kmc> i've used wildcards to lessen the syntactic burden of ReaderT with a bunch of fields in a record
14:42:58 <Cale> zzo38: Right, well, when considering language extensions, this is the sort of question that you have to ask yourself.
14:43:06 <kmc> it becomes more like binding those config parameters at top level
14:43:14 <ddarius> Cale: "Will people kill me because of this?"
14:43:21 <Cale> right
14:43:25 <Cale> and "Would I want to maintain a program which used this extension?"
14:43:45 <kmc> zzo38, you're free to implement any extension you like as a preprocessor, or in a fork of GHC, but nobody here is going to use it if it makes code unmaintainable
14:44:14 <zzo38> I do want to maintain a program which used this extension. As well as other extensions I had ideas about; a few of which have already been planned by other people too but some are different.
14:44:30 <kmc> why don't you learn Haskell instead of trying to fuck it up
14:44:55 <Cale> Can we see the program? Maybe there's a way to get the effect that you want without extending Haskell, and without breaking all sorts of nice language properties.
14:44:56 <ddarius> zzo38: Be careful.  There's a difference between "I want to use this extension when maintaining a program" versus "I want to maintain a program which uses this extension."
14:45:47 <applicative> zzo38, if you make a preprocesser, I will try it.
14:45:52 <zzo38> ddarius: It is the second one I want. The first one is different because if I make changes to existing program that does not use that, I am unlikely to use these kind of new extensions that nobody likes. When writing my own program, I want to write in my own way.
14:45:59 <ddarius> As others have mentioned, you can get what you are talking about to some degree with CPP, but no one uses CPP this way in Haskell.
14:46:20 * applicative could do with a few more wacky preprocessors.
14:46:31 <ddarius> zzo38: The issue wasn't writing your own program.  The issue is working with someone else's program written -their- own way using your extension.
14:46:58 <zzo38> CPP is not a very good preprocessor for Haskell. One of my other ideas is a new kind of preprocessor that is more suitable for Haskell.
14:47:00 <Cale> zzo38: I bet there's a way to get the extensibility that you want using nothing more than plain old typeclasses.
14:47:21 <Cale> and functional programming :)
14:47:24 <zzo38> CPP is designed for C, not Haskell; and it works well in C.
14:47:33 <ddarius> Cale: There is no real extensibility here.  It's more like CWEB style literate programming.
14:47:40 <zzo38> Cale: Yes some of it can be done using these stuff
14:47:54 <zzo38> ddarius: I do use CWEB when programming in C.
14:48:18 <ddarius> zzo38: It doesn't work all that well in C, but the point is, you can get pretty close to what you are describing quite easily with CPP but no one does this.  I don't think it is due to just that bump of difficulty that this would resolve.
14:48:30 <zzo38> However my proposal for more-notation actually does more things, such as checking for duplicates and ordering of specificness, in addition to other things.
14:48:45 <Cale> I'm still really confused about what exactly is desired here -- it looks like you want open datatypes and open function definitions.
14:48:53 <ddarius> zzo38: You could do that with CPP, though it would make it more complicated.  That said, I don't see that usually being a problem.
14:48:57 <Cale> but...
14:48:58 <zzo38> Cale: Well, yes, that is part of it.
14:49:20 <ddarius> Cale: Except they wouldn't really be open in the usual sense.
14:49:25 <zzo38> ddarius: CPP cannot quite do it either because you still have to specify everywhere where it is used for each one individually!
14:50:03 <ddarius> zzo38: Don't underestimate CPP.  That said, I never said CPP could do everything you intend, just that it can do enough of what you intend such that, if this was very desirable, people would have done it already.
14:50:04 <Cale> ddarius: Well, I don't know whether they would or not. It's hard to tell from his description of the feature.
14:50:34 <Cale> zzo38: Are you familiar with the "expression problem"?
14:50:47 <ddarius> Cale: When I asked him about importing from other modules, he said he hadn't thought about it and limiting it to within a module might be okay.
14:50:50 <Cale> http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Ralf-Laemmel-Advanced-Functional-Programming-The-Expression-Problem/ -- if not, then watch this first, and then...
14:50:55 <Cale> http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Lmmel-Advanced-Functional-Programming-Type-Classes -- watch this
14:51:12 <zzo38> Cale: Yes; I have had someone told me about that. But since you have more-notations in both "data" and "case" blocks, you can fix one with the other, kind of.
14:51:15 <ddarius> Cale: His proposed solution to this was "include" files.  As I said, this is much more like a CWEB thing rather than open data types.
14:51:20 <Cale> If it's all in the same module, then this feature is pointless.
14:51:34 <zzo38> As well as lists and do-blocks if it is necessary
14:51:42 <ddarius> In fcat, can't you just use CWEB with Haskell?
14:52:00 <pshrmn> is there a standard function like hGetContents which doesn't automatically close the buffer?
14:52:02 <Eduard_Munteanu> So this "more" thingy allows you to bind more stuff within the callee. If that's what you want, perhaps the State monad can help you achieve something similar.
14:52:03 <zzo38> ddarius: No. CWEB is for C only.
14:52:16 <Cale> You have arrow keys on your keyboard which can be used to move the cursor around a document!
14:52:21 <zzo38> And anyways there are some cases in which WEB-style transclusion will fail to do what I have specified.
14:52:49 <ddarius> zzo38: Does CWEB actually parse the C?
14:52:50 <zzo38> Eduard_Munteanu: Monads do help a bit, so does Template Haskell. But by itself those things won't quite do it.
14:52:51 <Cale> In addition to this, it's usually possible to actually click with the "mouse" and move the editing cursor wherever you click!
14:52:55 <zzo38> ddarius: Yes, it does.
14:53:16 <Cale> This allows you to edit parts of the source file which you have open and have already written.
14:53:46 <Cale> Now, you might say, "What if I'm using ed?"
14:54:01 <Cale> But even ed has a command to edit previously written lines!
14:54:19 <zzo38> When working on a UNIX computer, I usually use vi to edit files and it can do these things too. But that isn't the point.
14:54:22 <ddarius> Template Haskell sounds like it can do all the sane stuff and most of the insane stuff you want to do in a sane way.
14:54:38 <Cale> If you're using the unix 'cat' program as your text editor, then probably you should upgrade :)
14:54:56 <Cale> Every other text editor in the world is capable of editing the definitions you made earlier in the source file.
14:54:58 <ddarius> Cale: Even editing bits with a magnet is random access.
14:55:13 <zzo38> Cale: I know that but that is not the point.
14:55:14 <Eduard_Munteanu> zzo38: but really, I'm not sure this is a feature in any mainstream language
14:55:27 <Cale> zzo38: Then what is?
14:55:33 <ddarius> zzo38: It seems to be the only point.
14:55:42 <zzo38> ddarius: Well, if you try to keep your sanity and the program's sanity all the time, you will miss stuff.
14:55:53 <Cale> zzo38: If you're not interested in exporting open datatypes and extending them in future modules, then there's no point!
14:56:10 <zzo38> Cale: Well, you could extend them in future modules if such a thing would be possible to implement.
14:56:17 <Cale> Your datatype is *right there* in the same module where you're extending it
14:56:24 <zzo38> But it would seem difficult to implement, so instead you use includes files!
14:56:26 <Cale> So just extend it!
14:56:48 <Cale> Move your cursor up a few lines and edit the definition in place!
14:57:49 <zzo38> Including the new kind of preprocessor you could have include files with partially private namespaces and wildcard include file, etc
14:58:01 <Cale> and then when people open the file to find out what the definition of the datatype is, they don't have to scroll through the whole thing to find out if there are any
14:58:01 <kmc> i've developed a new extension to Haskell based on Plutonium Atom Totality theory
14:58:05 <Cale> 'more's
14:58:27 <Eduard_Munteanu> pshrmn: if your access patterns need that, and you're not content with strict stuff, then perhaps you need something like iteratees
14:58:28 <augustss> kmc: sounds dangerous
14:58:57 <Cale> zzo38: Give me a program written using this more syntax, and I will give you a prettier and easier to read program which doesn't.
14:58:58 <Eduard_Munteanu> Or just do your own r/w and seeking.
15:01:14 <zzo38> kmc: What kind of extensions based on Plutonium Atom Totality theory?
15:03:33 <ddarius> "All Matter is made up of atoms, and the Universe is matter, hence the Universe is one big atom"  Well then. QED.
15:03:49 <Cale> lol, Archimedes Plutonium
15:04:51 <applicative> has something like a tutorial appeared on how to use the fancy  -fplugin machinery?
15:04:53 <erus`> did you guys see that reddit post about the non turing complete language like haskell
15:05:02 <erus`> where every function has to terminate
15:05:13 * Eduard_Munteanu sighs
15:05:17 <erus`> and this had a benifit
15:05:21 <erus`> but i forget why
15:05:31 <applicative> erus` its madness, some shameless people will stop at nothing.
15:05:48 <roconnor> erus`: arguably program transformations are easier to do.
15:05:54 <zzo38> The plugins is only Core to Core, I cannot put plugins in other parts of Haskell, such as tokenizer, parser, renamer, typechecker, error recovery, etc
15:05:56 <Eduard_Munteanu> erus`: do you mean Agda?
15:06:02 <roconnor> erus`: you also don't get bugs in your PDF parser.
15:06:08 <Eduard_Munteanu> I kinda misread you on the first pass.
15:06:20 <augustss> erus`: it has the benefits that you can reason about your program in a much simpler way.
15:06:37 <erus`> i thought some guy wrote a web server in agda
15:06:45 <augustss> It was the old David Turner paper on Total Functional Programming.
15:06:47 <erus`> so it must be turing complete?
15:06:57 <azaq23> erus`: http://en.wikipedia.org/wiki/Total_functional_programming
15:06:57 <augustss> No
15:07:06 <ddarius> It also have n `div` 0 = 0
15:07:07 <Cale> erus`: A webserver needn't be Turing complete.
15:07:08 <Eduard_Munteanu> IMHO, totality at face value isn't much, at least for programs.
15:07:23 <ddarius> A web server shouldn't terminate.  It should be productive.
15:08:09 <Eduard_Munteanu> But it enables you to use some techniques, like doing rigorous proofs about certain behaviors.
15:08:30 <applicative> augustss can tell us if there are swank optimizations available where you know functions are total.
15:08:42 <Cale> http://archive.birdhouse.org/etc/kibosig.txt
15:08:43 <erus`> maybe i should try agda again
15:08:47 * Eduard_Munteanu would be interesed as well
15:08:50 <erus`> last time it was a bit confusing
15:08:52 <Eduard_Munteanu> *interested
15:08:58 <augustss> Mmmmmm, total functions.  The compiler can do whatever it wants.
15:09:18 * applicative thought so, but has little experience writing compilers :)
15:09:46 * roconnor feels the complier ought to do whatever it wants anyways and damn the DCPOs.
15:11:11 <gwern> ddarius: a webserver shouldn't terminate, but can't we have a static spearation - like we do for purity - between the bit that terminates and the bit that doesn't? after all, each request ought to terminate... even if the main loop looks like 'main = handleRequest >> main'
15:12:22 <applicative> did Turner ever get to the point of writing something like a specification of the language he intended?
15:12:31 <augustss> Not really
15:12:46 <ddarius> gwern: I said it should be productive.
15:13:07 <applicative> I see, sometimes I have thought of writing him and asking, but somehow i thought the topic would depress him.
15:13:37 <augustss> applicative: oh, you should ask him if you want
15:13:48 <applicative> augustss, is the idea completely impractical in your view?
15:13:57 <augustss> Not at all.
15:14:36 <applicative> it really bugs me that I can't write in such a language. admittedly this is for reasons that wouldn't much move computer people.
15:14:38 <augustss> But I think you mitt want the non-termination in a monad, like Haskell has IO in a monad.
15:14:52 * ddarius has, well had, a fortune cookie with no fortune in it.
15:15:19 <augustss> s/mitt/might/
15:15:47 <applicative> yes, as people have Partiality monads in dependently typed languages (haven't studied them)
15:15:49 <zzo38> I do have some ideas how to implement some of my extensions if the tokenizer could have stuff done with it, the parser could be adjusted, and changing some stuff after the renamer has processed it, before the typechecker. If GHC API cannot do that, is there other program to parse Haskell codes including Template Haskell and so on, and modified it?
15:16:11 <kmc> zzo38, to parse and emit Haskell code, look at haskell-src-exts
15:16:20 <kmc> it's used to implement some of these standalone extension preprocessors
15:16:22 <ddarius> Or just make a TH quasiquoter.
15:16:36 <ddarius> Or just use TH.
15:19:18 <applicative> well, maybe I will write to Turner, making bold to ask if there is anything in the nature of a proto-specification.
15:25:59 <zzo38> But note that I want to be able to reify more-notation and more-declarations, and making a preprocessor do it won't allow it to do such things with Template Haskell.
15:26:46 <zzing_> On a website talking about agda, there is the claim "With Agda, it is possible to find the vast majority of errors in the prototyping / coding phase." which I have heard a lot, in various ways, applied to haskell. Are there any well designed studies that conclude this too?
15:26:47 <joe6> i am using hsffig to bind a C test.o and I can print the variable using "v_test1". But, when I changed the test.o to a shared library, I get a different value when I print with "v_test1".
15:27:15 <Cale> zzo38: What kind of program are you writing?
15:27:26 <joe6> with a shared library: gcc -c -S -o test.s test.c -fPIC ; as -o test.o test.s -a=test.lst --statistics --warn -D; objdump -t test.o; ld -fPIC --output test.so -shared test.o -T test.gld; objdump -t test.so
15:27:37 <Cale> zzo38: Maybe one of us can suggest a better way to write it which won't involve extending the language in such a strange way
15:27:41 <zzo38> Cale: Currently nothing that uses these extensions. But some programs I write in future I would like to use it
15:28:04 <Cale> What programs?
15:29:04 <zzo38> Some of my ideas for extensions, however, could easily be done using preprocessor to transform the tokenized source.
15:29:24 <joe6> any suggestions on using hsffig with a shared library?
15:29:27 <zzo38> Cale: Really insane programs, I guess??????
15:30:52 <Cale> zzo38: well, I'm curious to know how you think it would help
15:32:01 <zzo38> Cale: Look at Inform 7 stuff and Magic: the Gathering stuff for a few details on how it would help a bit. Of course more-notation is not sufficient for these kind of things but it helps a bit.
15:33:55 <Cale> I was unaware that there was a programming language called Magic: The Gathering
15:34:01 <zzo38> Can I add my own extensions to haskell-src-exts? Is it possible to run Template Haskell using such thing?
15:34:05 <kmc> it basically is a programming language
15:34:45 <Cale> zzo38: haskell-src-exts is a completely separate Haskell parser
15:34:50 <benmachine> you know what upsets me? template haskell doesn't seem to be able to generate splice expressions.
15:34:54 <Cale> and has nothing to do with Template Haskell
15:34:56 <Cale> or GHC
15:34:58 <kmc> benmachine, haha
15:35:02 <kmc> you have to go deeper!
15:35:09 <benmachine> :>
15:35:30 <zzo38> benmachine: Yes it seem that to me, too.
15:35:57 <amtal> What do you call a definition with zero arguments? A data structure?
15:36:06 <amtal> What do you get when you apply a function until it can't be applied any more?
15:36:10 <kmc> zzo38, have you considered writing whatever your thing is in Lisp instead of Haskell?
15:36:15 <kmc> amtal, a non-function
15:36:25 <Jafet> Not all non-functions are data values
15:36:31 <Jafet> IO () is neither
15:36:40 <kmc> sometimes non-function types are called "data types", but this is not universally accepted terminology
15:36:41 <Jafet> At least, for your purposes
15:36:51 <kmc> Jafet, I'd say it's one or the other, but you're not allowed to know which
15:36:57 <kmc> such is the case of abstract types
15:36:57 <Cale> amtal: A pattern binding
15:37:15 <kmc> Jafet, anyway, if you can't apply it, it is a data value in some sense, even if it's just a newtype for a function
15:37:16 <Cale> amtal: (is what you call a binding with no function parameters)
15:37:38 <kmc> yeah, that's a syntactic idea
15:37:46 <zzo38> kmc: I have considered but Lisp does not do either.
15:37:47 <kmc> distinct from the semantic / type-level idea of "non-function"
15:37:49 <jmcarthur> zzo38: can you give an example of some code that you believe to be inexpressible in an elegant way as things currently stand?
15:37:58 <jmcarthur> pseudocode, of course
15:38:03 <Jafet> Other than these magical types, they're usually data, ie. they have a constructor
15:38:03 <kmc> jmcarthur, we've been asking that for a while :)
15:38:07 <zzo38> How do you do tokenized using haskell-src-exts?
15:38:08 <jmcarthur> yeah i know...
15:38:25 <kmc> (IO ()) is not particularly magical in that respect.  anyone can create a similarly-abstract type
15:38:36 <kmc> Int is also an abstract type in the Report
15:38:59 <kmc> neither guaranteed to be a function nor guaranteed to be an algebraic data value
15:39:18 <Jafet> I was going to mention NFData, but some weird data types don't have any NF
15:39:18 <Cale> zzo38: I'm not sure I understand what you're referring to with regard to M:tG and Inform 7
15:39:33 <kmc> Jafet, oh?
15:39:42 <Jafet> But generally if it's NFData, it's a regular data type
15:39:52 <Cale> zzo38: I only know about Inform 7 as a language for expressing text adventures.
15:39:57 <kmc> you mean data types with functions in them?
15:40:15 <Cale> If you were to write one of those in Haskell, I still don't see why you'd need or want the more syntax.
15:40:25 <Jafet> Functions are already NFData, if you're a pedant. But I mean data Omega = Omega Omega
15:40:43 <amtal> So at the top level of a module there are function bindings, pattern bindings, type signatures, and a few things like extensions and imports.
15:40:48 <Jafet> s/NFData/in NF/
15:40:54 <amtal> That's interesting: I didn't realize you could define (foo,bar) = (1,2) at the top level!
15:41:11 <Jafet> It's a binding like anything else
15:41:38 <Cale> amtal: yeah
15:41:41 <Peaker> It's annoying, though, because then you need two type declarations separately
15:41:46 <zzo38> Cale: Do you know that Inform 7 has rule syntax, and procedural rules and stuff? Do you also know, you could type something like this in Inform 7: An item has a number called its price. An items price is normally 1.
15:42:41 <zzo38> You could easily type that in more-notation:  ItemProperties = price :: Int = 1;
15:42:57 <MatrixFrog> have a function that takes a Maybe Int. if it's a Just Int, use that as the price, and if it's a Nothing, then use 1 as the price
15:42:58 <Jafet> That wasn't part of yesterday's more-notation
15:43:11 <kmc> Jafet, if I'm a pedant (which I am), a lambda term is (maybe) in normal form, but not all values of function type (that you might pass to deepseq) are lambda terms
15:43:13 <kmc> some are applications
15:43:24 <kmc> (id id) is a function-typed expression not in whnf
15:43:32 <Jafet> You're way too vague to help, zzo
15:43:39 <Cale> zzo38: Except, if you already have the module open, why not just add the price field to the Item datatype declaration? You can also define a default Item which you extend using record syntax.
15:43:50 <kmc> Jafet, you can help, you just have to learn everything about Magic: The Gathering and Inform 7, for no apparent reason
15:44:05 <Cale> data Item = Item { ..., price :: Int, ...}
15:44:18 <Cale> defaultItem = Item { ..., price = 1, ... }
15:44:53 <zzo38> Cale: Yes, it would ultimately be compiled into that, of course.
15:45:07 <Cale> zzo38: But this is shorter and easier to work with.
15:45:08 <MatrixFrog> i don't see why you wouldn't want to write it that way
15:45:12 <Cale> So what's the point?
15:45:18 <zzo38> Or this kind of thing in Inform 7: Instead of picking up the chair, say "It is glued to the floor." In more-notation Haskell: PickUp = Chair -> say "It is glued to the floor."
15:45:38 <Jafet> Why not just use Inform 7
15:45:39 <jmcarthur> kmc: that depends on how you define "value"
15:46:11 <Cale> zzo38: you'd probably have a pickUp field of your chair item, and you'd just replace the default with that one.
15:46:12 <kmc> or Lisp, then you can twist the syntax however you like
15:46:27 <Cale> I don't see the point of the more syntax here.
15:46:30 <jmcarthur> kmc: some define it to mean something that is already reduced as far as it can go
15:46:34 <kmc> right
15:46:37 <kmc> yeah, i used the wrong term there
15:46:51 <kmc> also not all lambda terms are in NF, right? if some reduction under lambda is possible
15:46:57 <jmcarthur> right
15:47:06 <Jafet> I was still talking about NFData there
15:47:07 <kmc> \x -> x + (2 + 2)
15:47:29 <jmcarthur> right. that is WHNF, but not NF
15:47:36 <kmc> i was wondering the other day whether vacuum can reduce under lambda
15:47:37 <Jafet> ghc doesn't play in NF proper
15:47:58 <jmcarthur> i doubt it can
15:49:16 <kmc> it has effectively getClosure :: a -> IO [Any]
15:49:19 <Jafet> kmc: then of course you reduce that to (4 S)
15:49:21 <zzo38> When the Confuser is turned on, move the xyzzy rules after the plugh rules. That is why you need to reify the more-notation.
15:51:01 <Cale> zzo38: what?
15:53:31 <ddarius> zzo38: If you want to make a system like that you should be making the rules first-class, not making a syntactic abstraction.
15:53:38 <kmc> Cale, you are a being of infinite patience
15:53:49 <kmc> jmcarthur, ah, it won't traverse a PAP closure
15:53:52 <kmc> sadness
15:53:55 <MatrixFrog> zzo, is any of this something that you're working on? or just thinking about working on?
15:54:10 <Jafet> Cale is a being who didn't hear zzo yesterday
15:54:33 <confab> heheh
15:55:10 <zzo38> MatrixFrog: Something I am thinking of working on; if I can do so then I will do so.
15:55:43 <zzo38> ddarius: Yes that is one of my ideas too; make the rules first-class. But it would still help more-notation as well as first-class rules.
15:56:06 <kmc> zzo38, what's wrong with doing this in Lisp using macros, again?
15:56:12 <MatrixFrog> i'm sort of inclined to agree with what everyone else is saying... it sounds like what you want is inherently non-haskell-ish. but if you do end up implementing some of your ideas i would be interested to look at it
15:56:47 <zzo38> It also helps if you can use more-notation with Template Haskell, as well.
15:56:55 <Cale> zzo38: If the rules are first class values, you can just define operations on them
15:57:05 <ddarius> zzo38: The rules would be normal values that can be manipulated arbitrarily at run-time.  No syntactic extension will help with that.  Just make the rules however.  If you like make a language with whatever notation you want that gets interpreted at run-time to specify the rules.
15:59:10 <zzo38> Cale: Yes I know. But you could use more-notation to put the rules separately, in order to *declare* rules. And manipulate the declarations using Template Haskell. And then these rules can be placed in a list or do-block or whatever, together with constructors (which is also used sometimes), case, etc, and then using runtime operations on the rules since they are normal values.
16:00:10 <zzo38> The more-notation even allows you to specify ordering in a few different ways.
16:00:28 <Cale> I think you'll find when you write it that no special syntax of any kind is required to separate the definitions of the rules -- since they're values, you can define them using ordinary pattern and function bindings
16:00:49 <jmcarthur> i, too, think this syntax extension is likely to be completely useless
16:00:53 <kmc> that would require actually learning Haskell, though
16:00:55 <ddarius> zzo38: None of these -compile-time- tools will help you once you get to run-time.
16:01:01 <Cale> and that will let you separate them as much as you need
16:01:05 <kmc> it's much more fun to troll #haskell and #ghc than to actually learn and use Haskell
16:01:08 <Cale> even put them in different modules
16:01:14 <zzo38> I have learn about Haskell.
16:02:16 <jmcarthur> try writing your code without this extension first. once you have code, *then* maybe you can revisit this and see if it would actually help
16:02:36 <kmc> you're not the first person to suggest that jmcarthur
16:02:47 <kmc> clearly we're not getting through, or something
16:03:09 <zzo38> But then you have to list all of the rules together, stuff that is added has to be added elsewhere, and everything is getting mixed up. You cannot put each card having everything about it in one place not requiring changing the other stuff (such as adding new constructors and/or cases). And some cards in Magic: the Gathering are different from what other ones do!
16:03:38 <jmcarthur> zzo38: you are making predictions about the nature of code that doesn't exist. that's a pretty difficult thing to do well
16:03:54 <jmcarthur> zzo38: we've all weighed in on this. i think it's time to drop it for now
16:04:29 <Cale> zzo38: If your datatype for Magic: the Gathering cards needs to be repeatedly extended with new cases, then it's not the right datatype.
16:05:04 <Cale> I guarantee you that there's a single datatype for M:tG cards which needs no extension to be completely general and cover every card in existence.
16:05:14 <mauke> is it String?
16:05:16 <roconnor> String
16:05:22 <Cale> No.
16:05:32 <kmc> is it the single type of the untyped lambda calculus?
16:05:36 <ddarius> String is always a correct answer to that question.
16:05:37 <kmc> data F = F (F -> F)
16:05:58 <zzo38> Example:  data CreatureType = more CreatureType;
16:06:13 <Cale> You don't need a sum type here.
16:06:23 <zzo38> Actually, probably it should be:  data CreatureType = more CreatureType deriving (Enum, Eq);
16:06:27 <Cale> (except possibly if you really want to separate land cards from others)
16:06:42 <Cale> and even then, it's only *two* cases
16:06:57 <kmc> this is like a compiler having a constructor for each program it might compile
16:07:01 <kmc> in fact, it's exactly that
16:07:15 <Cale> If your design requires you to add cases to the datatype every time you add a new card, it's probably the wrong design.
16:07:16 <kmc> data GHC = Darcs | Pandoc | XMonad | ...
16:07:48 <kmc> (those are the only three Haskell programs, right?)
16:07:55 <kmc> i forgot data GHC = GHC of course
16:07:58 <ddarius> kmc: Indeed.  If zzo38's goal is to make a system for making Haskell programs that are MtG-like systems, then maybe this is reasonable, but it doesn't require extending Haskell and would be better compiling a DSL to Haskell.  If he actually wants things to be first class, he needs a generic data type.
16:08:00 <Cale> (it's a possible design if you have a finite number of cards you want to support, but even then, probably a little awkward)
16:09:31 <zzo38> You can invent a monad for rules, and then use do-notation to put them together with more-notation.
16:09:38 <Cale> Your card type is most likely a product type, rather than a sum, and it's probably higher-order.
16:10:00 <Cale> In that the rules that it imposes will express changes on the game state at various points of play.
16:10:13 <Cale> which will be encoded as arbtirary functions
16:10:20 <Cale> OR
16:10:36 <Cale> will be encoded using abstract syntax of some language
16:11:08 <Cale> In either case, you don't just have this problem of needing to extend a datatype over and over.
16:11:09 <zzo38> Well, there are static abilities. And rules that can be suppressed by other rules (which shows the more-notation is insufficient; but doesn't necessarily mean it won't work at all!)
16:11:27 <MatrixFrog> zzo38: i really encourage you to actually try it out, put it up on github or something
16:12:30 <zzo38> Of course it will eventually compile to a normal Haskell code; but before it does that you would need to do stuff such as manipulate it with Template Haskell as well as many more things.
16:12:44 <zzo38> If you do not want to help me I can do it myself as well. But, I ask about how I can do it by myself.
16:13:04 <kmc> write a parser for whatever language you're actually implementing
16:13:08 <kmc> maybe base it on haskell-src-exts
16:13:15 <kmc> output haskell code using haskell-src-exts
16:13:44 <kmc> i believe this has already been suggested
16:14:08 <zzo38> kmc: Yes that can work. But I would need to modify the parser then (or do stuff to the tokenized form). And I would need to add some Haskell interpreter or something so that you can reify at compile-time.
16:14:16 <kmc> yeah
16:14:17 <kmc> do that
16:14:23 <kmc> come back when you have questions about it
16:14:41 <Cale> zzo38: What I'm saying is that to write things in a sane fashion where each card's definition is separate from all the others, you don't need the feature you're asking for. You just need ordinary functional programming.
16:14:56 <zzo38> But yes I know agree about some stuff about haskell-src-exts yes it can help.
16:15:45 <ddarius> At any rate, I'm not sure why you presented this as a proposal nor why you asked for feedback on it if 1) you seem to only intend this to be an application-specific tool, and 2) seem to already decided that this was the thing to do.
16:15:50 <zzo38> You need to push your sanity off of the cliff.
16:16:34 <zzo38> ddarius: It is not very application-specific since it is designed to be more general than that. I ask for help in case you found mistakes in the proposal document
16:16:47 <MHD> @source ErrorT
16:16:47 <lambdabot> ErrorT not available
16:17:01 * MHD pouts
16:17:13 <roconnor> @unmtl ErrotT e m a
16:17:14 <lambdabot> ErrotT e m a
16:17:22 <roconnor> @unmtl ErrorT e m a
16:17:23 <lambdabot> m (Either e a)
16:17:32 <MHD> oh... kay
16:17:47 <Cale> @src ErrorT
16:17:47 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
16:17:59 <MHD> thanks guys
16:18:12 <roconnor> what did @source do?
16:18:19 <MHD> I was looking through the source files in mtl and I just can't find it.
16:18:26 <elliott> ?help source
16:18:27 <lambdabot> source <lib>. Lookup the url of fptools libraries
16:18:30 <mauke> @source Data.List
16:18:30 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
16:18:31 <Cale> @source Control.Monad.Error
16:18:31 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs
16:18:34 <elliott> roconnor: mostly, permit arbitrary botloops
16:18:54 <mauke> @source @source
16:18:54 <lambdabot>  @source not available
16:18:55 <kmc> zzo38, the mistakes are that it's crazy and unnecessary.  didn't we already go through that?
16:18:56 <geheimdienst> what are "fptools libraries"?
16:19:04 <elliott> mauke: lambdabot is not the only bot in the world :)
16:19:07 <kmc> you're not interested in hearing actual criticism though
16:19:14 <elliott> ?so !whoops
16:19:14 <lambdabot> !whoops not available
16:19:42 <ddarius> That shouldn't correct into @source.  I'm not sure why it does.
16:19:44 <MHD> How is ErrorT actually implemented?
16:19:49 <ddarius> Unless @so is just an alias.
16:19:54 <elliott> ?src ErrorT
16:19:54 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
16:19:56 <elliott> MHD: like that.
16:19:58 <ddarius> @list-commands source
16:19:59 <lambdabot> Unknown command, try @list
16:19:59 <MHD> Is it just naive Either?
16:20:02 <ddarius> @list source
16:20:03 <lambdabot> source provides: src
16:20:03 <elliott> how is that naive?
16:20:07 <MHD> Why not use continuations?
16:20:07 <ddarius> @list dict
16:20:07 <lambdabot> dict provides: dict dict-help all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
16:20:10 <Cale> MHD: That's the actual implementation.
16:20:14 <ddarius> @list-modules
16:20:14 <lambdabot> activity babel base bf check compose dice dict djinn dummy elite eval fact free fresh ft haddock help hoogle instances irc karma localtime more oeis offlinerc pl pointful poll pretty quote search
16:20:14 <lambdabot> slap source spell state system tell ticker todo topic type undo unlambda unmtl version vixen where
16:20:17 <MHD> Cale: oh
16:20:18 <Cale> MHD: I guess you could...
16:20:26 <elliott> continuations aren't a silver bullet :P
16:20:26 <zzo38> Do you know about CWEB? I have written (not quite complete yet) program in Enhanced CWEB, I do use the feature to make the fields of one structure put in all places in different chapters.
16:20:28 <ddarius> @list quote
16:20:28 <lambdabot> quote provides: quote remember forget ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo nixon farber
16:20:41 <mauke> @src @src
16:20:42 <lambdabot> Source not found. Are you on drugs?
16:20:48 <ddarius> @list haddock
16:20:48 <lambdabot> haddock provides: index
16:20:50 <Cale> zzo38: In C, I can imagine wanting such a feature because C sucks at abstraction.
16:20:52 <ddarius> Bloody shite.
16:20:55 <MHD> elliott: they do perform reasonably well if you have a lot of tagging otherwise
16:21:06 <Cale> zzo38: But in Haskell, it's not needed, because functions are first class values.
16:21:36 <MatrixFrog> zzo: i saw the words "proposal document" somewhere. is there an actual document?
16:21:48 <geheimdienst> @yhjulwwiefzojcbxybbruweejw
16:21:48 <lambdabot> "\""
16:22:04 <geheimdienst> that was a little anticlimactic ...
16:22:05 <zzo38> MatrixFrog: Yes, it is the file [[User:Zzo38/Proposal_for_more-notation]] in Haskell wiki
16:22:12 <kmc> MHD, http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-Error.html#ErrorT
16:22:13 <Cale> @yhjulwwiefzojcbxybbruweejw
16:22:13 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:22:15 <Cale> @yhjulwwiefzojcbxybbruweejw
16:22:16 <lambdabot> "\""
16:22:16 <MHD> newtype ErrorT e m a = ErrorT { unErrorT :: forall b. (a -> Either e b) -> (e -> Either e b) -> m (Either e b) }
16:22:16 <kmc> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
16:22:19 <elliott> yhjulwwiefzojcbxybbruweejw is my favourite command imho
16:22:19 <Cale> heh
16:22:23 <ddarius> At any rate, the input of CWEB is not C.  If you want to make a super-literate Haskell that allows this, go ahead.  It doesn't require changing the language just as C isn't changed by CWEB.
16:22:43 <kmc> should @unmtl be renamed to @untransformers?
16:22:57 <zzo38> Well, more-notation does have a few complicates that simple preprocessor like WEB and so on simply would not do.
16:23:13 <jmcarthur> kmc: i'd rather it just be generalized to newtypes
16:23:36 <elliott> jmcarthur: why just newtypes? expand everything to products and sums!
16:23:37 <ddarius> zzo38: So?  You just make a more complicated preprocessor.  It still doesn't require changing the language.
16:23:58 <jmcarthur> elliott: sure. that would be a reasonable progressing beyond newtypes i suppose
16:24:05 <jmcarthur> *progression
16:24:13 <jmcarthur> more work though
16:24:17 <MHD> Vala is a good preprocessor for C
16:24:29 <Cale> You don't even really want a preprocessor or this language feature at all though.
16:24:34 <elliott> jmcarthur: then make it work on code using the types :)
16:24:39 <Cale> You just want to design your game's types better.
16:24:44 <elliott> and you thought ?pl was good at obfuscation!
16:24:53 <jmcarthur> heh
16:25:19 <zzo38> ddarius: Well, yes it doesn't require changing the language but it does require the parser and stuff, and even reify and so on. Part of it could be done with haskell-src-exts; but it would need to have something doing before it start and reification, and interpreted Haskell codes, as well. But some things I have idea (other than more-notation) can be done simply with tokenized source.
16:25:26 <Cale> (and I say that as someone who has been writing Haskell for 10 years and is working for a game dev company writing Haskell code)
16:25:30 <ddarius> Cale: Indeed.  Either zzo38 wants a program generator or zzo38 doesn't actually understand the problem he's imagining trying to solve.
16:25:56 <ddarius> zzo38: I agree with that.  Doing all of that doesn't require a proposal.
16:26:00 <MatrixFrog> Cale: ooo what company?
16:26:06 <Cale> iPwn Studios.
16:26:19 <zzo38> ddarius: OK fine it doesn't; rename that wiki page if you want to.
16:27:00 <MatrixFrog> zzo do you have an actual link to that wiki page?
16:27:09 <zzo38> MatrixFrog:  http://www.haskell.org/haskellwiki/User:Zzo38/Proposal_for_more-notation
16:27:15 <Cale> zzo38: The reason you think you need this feature is that you're misusing Haskell's datatypes.
16:27:44 <zzo38> Cale: It isn't only for datatypes!
16:28:02 <Cale> Fundamentally, it's the datatypes which are creating the initial problem for you though.
16:28:03 <ddarius> Cale: I recommend dropping it.  zzo38 doesn't have code and doesn't even necessarily intend to have code that will use this.
16:28:17 <Cale> If you were using datatypes the right way, then all the other problems would vanish as well.
16:28:45 <geheimdienst> erm. got banned from all of freenode. i guess the "yhjul..." command is one that i'm not likely to try again
16:28:57 <djahandarie> :(
16:28:58 <MatrixFrog> thanks. i'll look at it when i get a chance. i suspect there might be some small kernels of good ideas in here, even though i'm sure Cale and others are right that the idea is built on some funamendtal misunderstandings...
16:29:04 <elliott> geheimdienst: worksforme
16:29:11 <Cale> The problem is that you're choosing to use a sum type (with |'s in the data declaration) where you actually don't want one.
16:29:27 <kmc> @yhjulwwiefzojcbxybbruweejw
16:29:28 <lambdabot> "\""
16:29:47 <zzo38> MatrixFrog: You might be correct. Maybe. Type on the talk page of that article if it helps. Perhaps they are right too; it is not really a proposal but really a new kind of preprocessor, I guess
16:30:00 <danharaj> What is being discussed?
16:30:04 <ion> > 42
16:30:05 <lambdabot>   42
16:30:09 <zzo38> Cale: O, I don't want one?
16:30:10 <ion> @yhjulwwiefzojcbxybbruweejw
16:30:10 <lambdabot> Exception: <<loop>>
16:30:11 <geheimdienst> kmc, @yhjul checks your evilness. if it's low, nothing happens. if high, you get banned
16:30:53 * ddarius doesn't know what the hell geheimdienst is talking about.
16:31:04 <dafis> @yhjulwwiefzojcbxybbruweejw
16:31:05 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:31:16 <danharaj> @yhjulwwiefzojcbxybbruweejw
16:31:16 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:31:23 <MatrixFrog> @yhjulwwiefzojcbxybbruweejw
16:31:23 <lambdabot> "\"#$%&'()*+,\""
16:31:34 <ovrskr> that's interesting syntax.
16:31:36 <ddarius> @v
16:31:36 <lambdabot> Exception: <<loop>>
16:31:42 <danharaj> What is this strange non-referentially transparent value.
16:31:44 * MatrixFrog shrugs. you're weird, lambdabot
16:31:51 <danharaj> @@
16:31:56 <elliott> it's a reference to when lambdabot exposed the value it was binding, no?
16:32:04 <elliott> originally "v" and then "yhjulwwiefzojcbxybbruweejw"
16:32:08 <elliott> at least olsner told me that once when I asked :-)
16:32:23 <elliott> so you could do "take N (show v)" or whatever...
16:32:26 <ovrskr> @h
16:32:26 <lambdabot> Maybe you meant: hackage help hitchcock hoogle hoogle+ . ? @ v
16:32:36 <dafis> @yhjulwwiefzojcbxybbruweejw
16:32:36 <lambdabot> Just 'J'
16:32:37 <geheimdienst> @hitchcock
16:32:40 <ovrskr> @42
16:32:40 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
16:32:49 <ddarius> Yes, lambdabot evaluated expressions at one point by wrapping them as "let v = ... in v" which binds v leading to infinite loops and such for those unaware or overly aware.
16:32:55 <ovrskr> @do bad stuff
16:32:55 <lambdabot> bad stuff
16:33:10 <ddarius> So v got renamed to yhjulwwiefzojcbxybbruweeejw to lessen the unaware uses.
16:33:18 <elliott> yhjulwwiefzojcbxybbruweejw is a very good name.
16:33:31 <zzo38> Maybe I should somehow modify haskell-src-exts. Unlike GHC, how long is this program to compile? They said GHC takes ages to compile.
16:33:32 <elliott> Makes me think of Zaphod Beeblebrox near the end there.
16:33:45 <ion> So if lambdabot doesn‚Äôt evaluate expressions like that anymore, what defines yhjulwwiefzojcbxybbruweejw?
16:33:49 <kmc> maybe you should download it and try
16:33:50 <ddarius> zzo38: GHC takes like maybe an hour nowadays.
16:33:57 <kmc> instead of harassing us about every detail of your scheme
16:33:57 <mauke> > yhjulwwiefzojcbxybbruweejw
16:33:58 <lambdabot>   Not in scope: `yhjulwwiefzojcbxybbruweejw'
16:34:00 <mauke> ion: nothing
16:34:03 <danharaj> and that's a compile from scratch.
16:34:03 <zzo38> My computer is not the most modern one.
16:34:05 <ddarius> ion: It's just a database of quotes now.
16:34:11 <elliott> ion: it's a quote database
16:34:13 <zzo38> How long does haskell-src-exts take to compile?
16:34:13 <benmachine> haskell-src-exts will take minutes at most
16:34:15 <ion> Hah, ok.
16:34:19 <zzo38> benmachine: OK thanks
16:34:21 <kmc> zzo38, try it
16:34:26 <benmachine> (it's not a program, though, it's a library)
16:34:26 <zzo38> kmc: OK
16:34:27 <MHD> Lambda calculus is so awesome.
16:34:28 <ddarius> zzo38: Unless your computer is a Pentium or earlier it will still take not too much time.
16:34:33 <kmc> fwiw i compiled GHC 7.2 on 6 cores in 20 minutes with about 400% CPU utilization
16:34:33 <MatrixFrog> i gtg but thank you for all your haskelly greatness everyone
16:34:51 <zzo38> It is Celeron 2.00 GHz
16:34:53 <ovrskr> pffa 6 cores
16:34:55 * roconnor worries about his 386 without a co-processor.
16:34:59 <ddarius> zzo38: Then you're fine.
16:35:03 <zzo38> OK.
16:35:05 <kmc> roconnor, you have one set up?!
16:35:09 <ovrskr> intel released a 10 cores with HT, 20 cores
16:35:19 <roconnor> kmc: actually I don't think I have one.
16:35:24 <kmc> roconnor, i wanted one in order to test my toy OS
16:35:39 <roconnor> I have a ZX81
16:35:58 <ddarius> I built 5.4 era GHC which included many libraries that GHC no longer ships with on a AMD K-6 200 with 64MB of RAM.  That took, I think 12 hours.
16:36:04 <ddarius> Mostly due to swapping.
16:36:11 <ovrskr> kmc, haskell OS i hope?
16:36:15 <kmc> no
16:36:21 <ovrskr> oh dang
16:36:35 <ddarius> kmc: What's wrong with the various emulators?
16:37:06 <danharaj> ddarius: hipster.
16:37:20 <elliott> only bochs and qemu are really suited to osdev, the rest cut way too many corners for speed :P
16:37:27 <ddarius> elliott: That's fine.
16:37:33 <ddarius> I've used qemu for that.
16:37:45 <kmc> i specifically wanted to test that it still booted on 386 after i implemented huge pages and SYSENTER
16:37:51 <elliott> haha
16:37:54 <ovrskr> I thought the ZET project was cool, check it out
16:38:04 <elliott> ddarius: I don't know that even bochs is good at emulating the insane kind of bugs old hardware had, though :)
16:38:04 <kmc> but i couldn't find an emulator that lacked those features
16:38:13 <ddarius> kmc: I didn't think the 386 had SYSENTER so wouldn't that definitely be a "no"?
16:38:14 <ovrskr> it's an 8088 implemented in Verilog + all the XT pc periphersal
16:38:17 <kmc> bochs might have the appropriate mode but i can't deal with bochs
16:38:41 <kmc> "implemented" meaning it detects support for these features and uses them if you have support
16:38:47 <kmc> i wanted to test the "if not" path
16:39:11 <MHD> Is ther some snizzy lambda calculus library
16:39:13 <ddarius> kmc: Are just worried about detection (which is understandable) or just the path after successful detection?
16:39:13 <elliott> kmc: you could just invert your conditions :P
16:40:49 <zzo38> But I have other ideas too. One is type-level natural numbers, which is already planned to be implemented. Another one is making cross-compiler to compile Haskell programs into other architecture, including: Java, Glulx, MMIX, and ARM.
16:40:59 <ovrskr> osdevers make all these insane neat OS's.. but then make like 3 drivers for it and let it die :(
16:41:02 <ddarius> zzo38: Good luck.
16:41:24 <ddarius> ovrskr: It's not really their fault.  Entering the OS market is essentially impossible.
16:41:28 <kmc> ddarius, both
16:41:31 <zzo38> (I also want a C compiler for Glulx but that is something completely different)
16:41:33 <danharaj> substitution effect
16:41:40 <danharaj> *cough*
16:41:46 <ddarius> kmc: You can reasonably test the latter by doing what elliott said.
16:41:57 <zzo38> Actually, I mean LLVM, not C.
16:42:06 <ovrskr> ddarius: well, that's not really the goal, but an OS is not just the kernel :)
16:43:00 <ClaudiusMaximus> kmc: i have a 386 in my cupboard, don't have any reasonable means of getting data to it, though
16:43:24 <ddarius> ovrskr: Yes, but making thousands of drivers for something that you are just going to experiment with is not really sensible.  Other than that though, most kernel experiments I've seen implement a UNIX-y layer so that you can do something (unless that layer is also something they are experimenting with.)
16:43:29 <jmcarthur> bochs is insanely accurate
16:43:48 <ddarius> I don't think bochs is trying to be accurate.
16:44:16 <elliott> ddarius: it's targeted at debugging, and doesn't care about speed
16:44:23 <elliott> so, it is, just not directly...
16:46:36 <ovrskr> ddarius: fair enough. i just would like to see one for a change
16:46:55 <MHD> Is there some snizzy lambda calculus library?
16:47:08 <ovrskr> getting some kind of accelerated graphics would blow me away more than the usual stuff
16:47:11 <kmc> MHD, what would it do?
16:47:28 <elliott> MHD: ghc
16:47:42 <MHD> kmc: Just defining and printing basic lambda expressions
16:47:56 <ddarius> ovrskr: There are examples such as Bluebottle and Smalltalk.
16:48:34 <MHD> kmc: I saw something with a syntax like (x f # f * x)  some time ago...
16:49:10 <MHD> kmc: or (x # f # f * x)
16:49:14 <MHD> or something similar
16:49:25 <ddarius> MHD: As an embedded language in Haskell?
16:49:30 <MHD> yeah
16:49:46 -dylukes(~revenantp@pool-71-182-229-20.pitbpa.fios.verizon.net)- like
16:49:57 -dylukes(~revenantp@pool-71-182-229-20.pitbpa.fios.verizon.net)- does
16:50:42 <elliott> dylukes: what
16:50:48 <zzo38> Is there a backward (>=>) operator? It seem it would be useful when doing category theory stuff
16:50:48 <dylukes> oh, wrong channel.
16:50:58 <kmc> :t (<=<)
16:50:59 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
16:51:10 <BMeph> zzo38: Yes
16:51:17 <zzo38> OK thank you
16:52:24 <zzo38> It says monad with Kleisli composition forms a category. But using (<=<) means it matches it a bit more because how you do function composition and morphisms and that kind of stuff.
16:53:21 <zzo38> Is that how it forms a category? I don't know for sure because I don't know a lot of stuff about category theory
16:53:39 <danharaj> :t (<=<)
16:53:40 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
16:53:41 <kmc> instance (Monad m) => Category (Kleisli m) where { id = Kleisli return;  Kleisli f . Kleisli g = Kleisli (f <=< g) }
16:53:45 <azaq23> @src Kleisli
16:53:46 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:53:57 <monochrom> bob? :)
16:53:58 <kmc> newtype Kleisli m a b = Kleisli (a -> m b)
16:54:09 <ddarius> monochrom: BOB
16:54:29 <dafis> ddarius: BOB?
16:54:40 <ddarius> dafis: Yes.
16:54:42 <dylukes> BOB!
16:55:08 <dafis> wtf is BOB?
16:56:59 <Phyx-> Microsoft Bob?
16:57:37 <ezyang> Question: heap liveness analysis in a strict, purely functional language is trivial, right?
16:58:08 <ezyang> (essentially, because you do not need a heap...)
16:58:15 <ddarius> ezyang: Do you mean that (unless you specifically support such) you won't have any graph-like structure, but just a tree.
16:58:31 <ddarius> ezyang: What makes you think you don't need a heap?
16:58:36 <ezyang> Mmm, yes, I think so.
16:58:55 <kmc> then the heap is just an optimization to avoid passing closures by value
16:58:56 <ezyang> ddarius: OK, that's not true.
16:59:08 <kmc> but you get the same semantics if you do that
16:59:19 <ezyang> Right right "all you need are functions"
16:59:22 <ezyang> OK, that's problematic.
16:59:31 <ddarius> Which are typically stored in the heap.
16:59:36 <ovrskr> an OS programmed in many languages would be interesting too
17:00:00 <ovrskr> it would make for research on ABIs and binary compatibility etc
17:00:12 <kmc> ovrskr, GNU/Linux is programmed in many languages
17:00:13 * ovrskr rambling
17:00:36 <ovrskr> I know, talking osdev here
17:01:03 <ovrskr> GNU/BSD/X/MIT/Linux please, btw
17:01:32 <ezyang> OK, does anyone know of papers that address the problem of heap analysis in a language that only has closures?
17:01:34 <Jafet> Mozilla/Emacs/Linux
17:01:39 * ddarius is pretty sure kmc chose that moniker for non-ideological reasons.
17:02:01 <kmc> right, Linux is mostly written in one language
17:02:17 <kmc> that language is "what GCC accepts"
17:02:44 <ddarius> ezyang: How would that case be noticably simpler than the general case.
17:02:45 <ddarius> ?
17:03:34 <ezyang> ddarius: Different representation to build algorithm over, maybe?
17:04:03 <ddarius> ezyang: That response makes no sense to me as a response to my question.
17:04:30 <ddarius> The general case includes closures and closures can be used to model pretty much any data type so all we get is a uniform representation.
17:04:51 <ezyang> The analogy is similar to those of different computation models: you can write any computable function with a TM but a different (though equivalent notion) can be easier.
17:05:05 <ezyang> Yeah, I guess.
17:05:13 <kmc> implementing algebraic data values is not very different from implementing closures
17:05:39 <ddarius> ezyang: The answer is "yes" though, but probably in the OO literature primarily.
17:05:58 <ezyang> The original hope was lack of mutation would make things easier.
17:06:03 <ezyang> ddarius: Ah, that makes sense.
17:06:10 <kmc> changing a constructor to its church encoding only involves switching the info table pointer, in GHC parlance
17:06:17 <kmc> ....oh god, i wonder if you can actually do that
17:06:34 <ddarius> kmc: GHC already essentially represents data types in their Scott-encoding.
17:10:10 * kmc unsafeCoerce (\f -> f 3 'x') :: (Int, Char)
17:10:13 * kmc segfault
17:12:18 <elliott> oh dear, kmc segfaulted.
17:12:37 <ovrskr> haha
17:13:02 <kmc> it's okay, i had a stack protector
17:13:05 <kmc> so i'm not exploitable right
17:13:25 <ovrskr> what's that, even your stack is immutable ?
17:13:56 <Jafet> Is that like a chastity belt
17:14:21 <kmc> yeah
17:14:25 <Phyx-> almost, except with no key
17:14:27 <kmc> there are some canaries involved too
17:14:34 <kmc> sounds pretty kinky
17:15:08 <ddarius> (unsafeCoerce (True, 'x') :: (Bool -> Char -> a) -> a) (\b c -> show b ++ [c])
17:15:08 <ddarius> "\-1008806316526703308"
17:15:11 <Phyx-> not for the canaries
17:15:53 <Jafet> Interesting char
17:15:59 <ddarius> kmc: The main issue is that GHC will use a vectored call for the case on the data type that the function probably can't deal with.  There are probably other issues as well.
17:16:29 <elliott> I wonder how much you can break with insane Chars like that
17:17:07 <kmc> i thought vectored returns went away... or is that something else
17:17:57 <ddarius> For small data types it did.
17:18:00 <Jafet> You just need to coerce an Int to get that Char
17:18:05 <ddarius> Small sums I should say.
17:18:18 <kmc> ok
17:18:32 <kmc> > -1008806316526703308 < (minBound :: Int32)
17:18:32 <lambdabot>   False
17:20:16 <ddarius> > fromIntegral (-1008806316526703308) :: Int32
17:20:16 <lambdabot>   4287796
17:21:22 <parcs> > -1008806316526703308 < toInteger (minBound :: Int32)
17:21:23 <lambdabot>   True
17:21:36 <ddarius> parcs: Was that really necessary?
17:22:12 <ddarius> Also, don't use toInteger.
17:22:56 <ovrskr> unsafeCoerce is kind of fun
17:23:16 <ovrskr> True is worth 1991646347 on my machine.
17:23:53 <ddarius> unsafeCoerce is fun.
17:24:22 <elliott> unsafeCoerce is Fun (for definition of Fun, consult your nearest dwarf dictionary)
17:24:34 <ovrskr> it's probably a monad.
17:24:34 <kmc> program in C, then you get to use it every day!
17:24:43 <kmc> you're a monad
17:25:07 <ddarius> isJust = unsafeCoerce
17:25:22 <kmc> :D
17:25:24 <elliott> I really hope that works
17:25:31 <dibblego> haha
17:25:32 <ddarius> Would I lead you wrong?
17:25:38 <ovrskr> whats that
17:25:45 <ddarius> Of course, you'll need the type signature.
17:25:57 <kmc> indeed it works on GHC usually
17:26:00 <elliott> Prelude Unsafe.Coerce> let isJust :: Maybe a -> Bool; isJust = unsafeCoerce
17:26:00 <elliott> Prelude Unsafe.Coerce> isJust Nothing
17:26:00 <elliott> False
17:26:00 <elliott> Prelude Unsafe.Coerce> isJust (Just ())
17:26:00 <elliott> True
17:26:03 <elliott> i'm crying tears of joy
17:26:21 <kmc> because False and Nothing are the 0th constructor, and True and Just the 1st
17:26:41 <elliott> yeah
17:26:56 <elliott> that's wonderful
17:27:09 <elliott> I wonder if the typical isJust compiles down to that in the end?
17:27:10 <ddarius> Indeed.  This will work with any constructor having less than 4 or 8 constructors and will return false for the first one and True for the second.
17:27:44 <Jafet> @remember ddarius isJust :: Maybe a -> Bool; isJust = unsafeCoerce
17:27:44 <lambdabot> It is stored.
17:27:56 <ddarius> Jafet: That's probably already in the quotes database.
17:27:56 <kmc> and for the third ddarius?
17:28:03 <elliott> ?quote unsafeCoerce
17:28:04 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
17:28:14 <elliott> ?quote unsafeCoerce ddarius
17:28:14 <lambdabot> No quotes for this person. This mission is too important for me to allow you to jeopardize it.
17:28:30 <Jafet> @quote isJust
17:28:30 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
17:28:39 <elliott> ?quote isJust
17:28:40 <lambdabot> ddarius says: isJust . unsafeCoerce
17:28:44 <elliott> ddarius: close
17:29:02 <ddarius> kmc: True for the 3rd or probably any odd numbered constructor.
17:29:08 <ovrskr> Segmentation fault :(
17:29:27 <ddarius> isJust . unsafeCoerce being (not . null)
17:30:32 <ddarius> Related to listToMaybe = unsafeCoerce.
17:30:55 <elliott> ddarius: I wonder if these would actually work as optimisations.
17:31:07 <elliott> I guess it's a bit bad to rely on values that aren't strictly True or False working directly.
17:31:18 <elliott> I mean, theoretically a compiler could depend on the exact values, couldn't it?
17:31:24 <elliott> To do toEnum/fromEnum, or something.
17:31:30 <Jafet> I expect that the machine code is already this
17:31:54 <elliott> Prelude Unsafe.Coerce> fromEnum (isJust (Just 99))
17:31:54 <elliott> 1
17:31:54 <elliott> Hmm.
17:32:29 <ddarius> GHC never actually does anything with the Bool value if its in WHNF.
17:32:30 <Jafet> > enumFromTo minBound maxBound :: [Bool]
17:32:31 <lambdabot>   [False,True]
17:33:15 <ddarius> What is a handy four constructor type?
17:33:51 <elliott> ddarius: Int2.32192809
17:34:03 <elliott> sorry, s/Int/Word/
17:34:07 <elliott> although I guess Int works too
17:35:09 <kmc> data Ghost = Inky | Pinky | Blinky | Clyde
17:35:56 <jmcarthur> Either (Either a b) (Either c d)   :P
17:35:57 <zzo38> When I typed "cabal update" I got the message "Downloading the latest package list from hackage.haskell.org" and "cabal: failed" with no other messages. Adding -v doesn't help it is the same message.
17:36:10 <Eduard_Munteanu> ~ Either Bool Bool
17:36:17 <jmcarthur> bah
17:36:23 <elliott> Eduard_Munteanu: too many _|_s :P
17:36:24 <zzo38> How to fix that?
17:36:30 <byorgey> zzo38: try -v3 ?
17:36:32 <Eduard_Munteanu> Oh.
17:36:34 <zzo38> OK
17:36:47 <Eduard_Munteanu> Hrm, now I get your 2.321...
17:36:57 <elliott> Eduard_Munteanu: :)
17:37:05 <kmc> i think ddarius was looking for something which actually has 4 constructors as far as the STG-machine is concerned
17:37:13 <zzo38> OK, it seems a proxy error. But I do not even use proxy.
17:37:37 <zzo38> It is trying to connect to 0.0.0.0:0
17:37:59 <ddarius> Oddly, map unsafeCoerce [One ..] :: [Bool] on a data type with four or more constructors on my 64-bit machine produces a list of Falses.
17:39:08 <zzo38> I cannot find anything relating to proxy in the cabal config file
17:39:17 <ddarius> It produces [False, True, True] on Ordering.
17:39:34 <Eduard_Munteanu> Interesting.
17:39:42 <mauke> zzo38: env | grep proxy?
17:39:52 <zzo38> It is Windows
17:40:18 <Eduard_Munteanu> It'd be grep -i though
17:40:34 <zzo38> And there is nothing relating to proxy in the environment variables
17:40:37 <mauke> no, windows is case insensitive
17:40:40 <Eduard_Munteanu> zzo38: ping hackage yourself?
17:40:53 <Eduard_Munteanu> Hah.
17:41:26 <zzo38> It won't ping, but I can connect to that server.
17:41:42 <zzo38> But cabal wants to use the proxy 0.0.0.0:0 for some reason I don't know
17:41:57 <Eduard_Munteanu> How did you find that out?
17:42:49 <elliott> -v3
17:43:46 <zzo38> I can connect using wget or nc or a web-browser program or whatever, but cabal says it is using the proxy when I indicate -v3 and I have no proxy.
17:45:52 <Eduard_Munteanu> zzo38: did you check your proxy settings in Windows?
17:46:32 <zzo38> Eduard_Munteanu: O, yes, I remember now, I set Internet Explorer to use that proxy. But I want only Internet Explorer to use that proxy not other programs!
17:47:04 <elliott> there are no IE proxy settings, those are global Windows settings I think
17:47:10 <elliott> but a lot of common browsers ignore them
17:47:27 <zzo38> Even wget and curl ignores it
17:47:36 <zzo38> And nc ignores it, and so do most other programs
17:48:23 <elliott> well, those are not exactly native Windows programs. :p
17:48:39 <mauke> file a bug for wget/curl
17:49:14 <ovrskr> coercing (+) into working with bools does not work. :(
17:49:56 <zzo38> How can I tell Content Advisor to block everything? When trying to remove all rating systems it is error
17:50:29 <Jafet> > let a + b = toEnum . (`mod` (maxBound `asTypeOf` a) + 1) $ fromEnum a P.+ fromEnum b in True + True
17:50:30 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
17:50:30 <lambdabot>    arising from a use of `+' at...
17:50:35 <Eduard_Munteanu> Ask your parents :P
17:50:42 <Eduard_Munteanu> Oh, to "block".
17:51:07 <Jafet> > let a + b = toEnum . (`mod` (maxBound `asTypeOf` a) P.+ 1) $ fromEnum a P.+ fromEnum b in True + True
17:51:08 <lambdabot>   The operator `GHC.Real.mod' [infixl 7] of a section
17:51:08 <lambdabot>      must have lower pr...
17:52:06 <zzo38> I don't use Internet Explorer and I want to block it
17:52:38 <Jafet> Wait, I didn't know alphabetic functions could have fixity.
17:53:05 <elliott> Jafet: yep
17:53:07 <elliott> scares me too
17:53:35 <Jafet> Pft, I'm not scared!
17:54:55 <ddarius> elliott: It's perfectly reasonably.  All infix identifiers can be given fixity declarations.
17:55:15 <ddarius> You do want div/quot to have the right fixities don't you?
17:55:38 <shachaf> The fact that (`foo`) is invalid syntax is not reasonable.
17:56:27 <elliott> ddarius: It scares me because I see `` more as a function from normal prefix identifier (which doesn't have fixity) to infix operation.
17:56:28 <zzo38> shachaf: I agree but it does not seem extremely important
17:56:29 <ddarius> I'm not sure what my opinion is on that.  Though the fact that various type level things are arbitrarily limited with respect to syntax is unreasonable.
17:56:33 <elliott> There's a side-channel of information there. :p
17:57:09 <elliott> shachaf: 9`(`99+90`)`9
17:57:11 <elliott> > (99+90) 9 9
17:57:12 <lambdabot>   189
17:57:21 <shachaf> Given that left or right sections with `` works, it doesn't make any sense that neither-sections wouldn't.
17:57:23 <elliott> shachaf: Definitely the best way to write 189 _I_ can think of.
17:57:42 <shachaf> elliott: ` isn't for expressions. I'm not claiming that it should be.
17:57:50 <elliott> Except it totally should be.
17:57:53 <zzo38> What is 9`(`99+90`)`9 supposed to be?
17:57:58 <elliott> I'm so serious you don't even know.
17:58:00 <ddarius> No it shouldn't.  At least, not with that syntax.
17:58:05 <shachaf> 9 `(` 99 + 90 `)` 9
17:58:08 <ddarius> That said you can hack it.
17:58:18 <shachaf> Clearly the preferable alternate syntax is $(), just like in shells.
17:58:19 <zzo38> And what is `(` and `)` supposed to be?
17:58:19 <elliott> I guess not everyone can understand the endless benefits of arbitrary infix-isation.
17:58:33 <elliott> I wonder how it'd combine with more-notation :-P
17:58:43 <shachaf> elliott: I understand the potential benefit, but backticks are a terrible way to do it.
17:58:53 <ddarius> > let (-|) = flip; (|-) = id in 3 -| id (+) |- 4
17:58:54 <lambdabot>   3
17:59:01 <elliott> shachaf: What about olde Unix style? `abc'
17:59:03 <shachaf> You can do what ddarius says, though.
17:59:08 <ddarius> > let (-|) = flip ($); (|-) = id in 3 -| id (+) |- 4
17:59:10 <lambdabot>   7
17:59:24 <zzo38> elliott: I do not see anything that is going wrong when combining it with more-notation, other than the things that are wrong even without more-notation which remain wrong
17:59:50 <elliott> shachaf: ‚Äõabc‚Äô
17:59:54 <elliott> shachaf: I think we can all agree that's ideal.
18:01:04 <ddarius> elliott: Then we can expand fixity declarations so that we can give expressions fixities.
18:01:30 <elliott> ddarius: Beautiful.
18:01:34 <zzo38> I don't think you need arbitrary infix-isation you can use let or something I think. I don't know if fixity declarations are allowed in let but if it is allowed, then it works.
18:01:44 <zzo38> If it is not allowed, then make it allowed.
18:01:50 <elliott> ddarius: infixr (pi :: CReal) Just "hello world"
18:01:54 <elliott> Sorry,
18:02:01 <elliott> ddarius: infixr (pi :: CReal) ‚ÄõJust "hello world"‚Äô
18:02:23 <elliott> Finally we're making the changes needed to turn Haskell into a truly world-class language.
18:02:31 <Cale> rofl
18:02:44 <ddarius> > let (-) = (Prelude.-); infixl 7 -; in 3-4-5
18:02:45 <lambdabot>   -6
18:02:55 * rwbarton . o O (X = infixl 6 +; let {more X; a + b = ...})
18:03:02 <elliott> rwbarton++
18:03:06 <ddarius> rwbarton: Eugh.
18:03:12 <elliott> beautiful
18:03:17 <Cale> lololol
18:03:42 <ddarius> > (3-4-5, let (-) = (Prelude.-); infixl 7 -; in 3-4-5)
18:03:42 <lambdabot>   (-6,-6)
18:03:51 <Cale> Now we just need to allow multiple conflicting definitions of X
18:03:51 <ddarius> > (3-4-5, let (-) = (Prelude.-); infixr 7 -; in 3-4-5)
18:03:52 <lambdabot>   (-6,4)
18:04:00 <Cale> along with some complicated way to resolve them
18:04:12 <Cale> Like, that the average of the fixities are taken
18:04:16 <ddarius> more (more X)
18:04:22 <elliott> less X
18:04:24 <shachaf> less more
18:04:30 <elliott> it includes the opposite of whatever X does
18:04:36 <zzo38> rwbartin: My specification did not allow more-notation in place of declarations, but I can see what it is doing.
18:04:41 <ddarius> elliott: Define opposite.
18:04:41 <elliott> data Foo = A | B | C | more X; X = B
18:04:42 <elliott> ===
18:04:46 <elliott> data Foo = A | C
18:04:53 <elliott> ddarius: I'll do that separately for each thing you ask about
18:05:10 <zzo38> elliott: Do you mean "less X" there rather than "more X"?
18:05:10 <shachaf> elliott: Do you mean less?
18:05:12 <ddarius> X a = x <- return $ x a
18:05:20 <shachaf> X x = x < x $ x x
18:05:25 <elliott> shachaf: Oops. Well, they're swapped now.
18:05:33 <shachaf> alias more=less
18:05:34 <Cale> and associativity is computed by taking the sum of +1 for r, -1 for l and 0 for nonassociative, and choosing r if positive, l if negative and nonassociative if zero
18:05:38 <Cale> So for example
18:05:46 <Cale> X = infixl 6 +
18:05:53 <Cale> X = infixr 2 +
18:05:56 <Cale> more X
18:05:58 <elliott> You'll all be laughing when Oleg publishes "More-notation: an efficient and well-typed alternative to monadic IO" in a few weeks.
18:06:12 <elliott> s/You'll all/Who will/
18:06:13 <Cale> will define + to be infix 4
18:06:16 <Cale> nonassociative
18:06:33 <elliott> Cale: No, no. Instead, infix takes L or R as a first parameter.
18:06:42 <Jafet> Oleg isn't a fan of more notation
18:06:46 <elliott> Cale: Then, just like fixities can now be arbitrary numeric types, so too can you define your own L and R types.
18:06:53 <elliott> (class (Ord a) => LR a where l :: a; r :: a)
18:07:00 <Cale> And extend them with new cases!
18:07:00 <elliott> Hmm, I guess you also need
18:07:04 <elliott> mix :: a -> a -> a
18:07:10 <elliott> class (Ord a) => LR a where l :: a; r :: a; more LR
18:07:13 <elliott> LR = mix :: a -> a -> a
18:07:26 <elliott> This is looking great if you ask me.
18:07:37 <ddarius> elliott: It is breath-takingly clearer than the alternative.
18:08:19 <elliott> ddarius: Is there even any alternative? I've forgotten what Haskell looks like any more, but I strongly suspect it's less flexible about fixity declarations.
18:08:39 <shachaf> elliott: Haskell doesn't even support morephisms.
18:08:49 <ddarius> elliott: I was referring only to your LR class declaration.
18:08:51 <zzo38> Yes it was in fact one of my other ideas (although I dropped it, but you can use it again if you like it), to allow more-notation inside of class declarations.
18:08:56 <elliott> oerjan demands I give him credit for the Oleg quip.
18:09:22 <elliott> zzo38: What if you use more-notation inside a type name?
18:09:29 <elliott> type more Names = more Constructors
18:09:35 <elliott> deriving (more Derivations)
18:09:48 <ddarius> This is all silly.  Main.hs: more DWIM
18:09:48 <elliott> more LanguageConstruct more Names = more Definitions?
18:09:53 <Jafet> elliott: so you want to make haskell into a world class language by implementing a buggy version of half of the reader of common lisp
18:09:59 <shachaf> "More, more, I'm still not satisfied!"
18:10:01 <elliott> ddarius: Main.hs: fix more
18:10:07 <elliott> ddarius: You might need more more blocks, after all.
18:10:17 <elliott> Jafet: Way more than half.
18:10:26 <elliott> And "buggy" is too kind, I'm elevating bugs to an art form here.
18:10:38 <Jafet> Fix smores
18:11:08 * ddarius dislikes smores, mostly because he dislikes marshmallows and dislikes them even more when heated.
18:11:11 <zzo38> elliott: That doesn't seem right. Can't you just do:  type Name1 = ...; type Name2 = Name1; type Name3 = Name2;  more-notation won't help with that. And "type" doesn't specify constructors; "data" does, isn't it?
18:11:29 <elliott> zzo38: Well, you could retroactively change the "type" by combining more-notation with CPP.
18:11:36 <elliott> #more Declarations
18:11:37 <elliott> type ...
18:11:38 <elliott> Later on:
18:11:42 <elliott> Declarations = #define type data
18:11:44 <zzo38> elliott: O, in that case, yes it can work OK.
18:11:51 <elliott> Yes, precisely.
18:11:53 <elliott> I'm glad we agree.
18:12:07 <ddarius> elliott: Oh god.
18:12:33 <elliott> ddarius: Would you like me to go back in time and receive your assurance that more-notation can only possibly get better?
18:12:34 <ddarius> So type X = Maybe Int would become something that declares the data constructor Maybe taking an Int.
18:12:46 <elliott> I think it would come in handy right about now to assure yourself that things are in fact improving.
18:13:06 <ddarius> elliott: You'd have to do more than go back in time.
18:13:54 <elliott> ddarius: Well, would you have said it could get worse?
18:13:55 <ddarius> elliott: Trust me.  People have suggested worse ideas than this one as extensions.
18:13:59 <ddarius> elliott: Yes.
18:14:09 <elliott> Wow. I need to pay more attention to this channel.
18:14:15 <zzo38> Although I would not have it CPP; I can invent a different preprocessor suitable to Haskell, although it might do something like what you mentioned, especially if it has macros and that stuff, then macros can do that other stuff too.
18:14:19 <ddarius> elliott: Start by going back in time to the beginning.
18:14:24 <zzo38> ddarius: What ideas?
18:14:34 <ddarius> zzo38 doesn't believe me.
18:14:39 <zzo38> CPP is good for C, not for Haskell.
18:14:54 <elliott> ddarius: I wouldn't, if I were the inventor of more-notation.
18:15:17 <zzo38> ddarius: What kind of things you think I do not believe from you?
18:15:33 <ddarius> zzo38: That your idea is not the worst idea I've heard of.
18:16:00 <zzo38> ddarius: I did not say I do not believe that. I was asking you what ideas?
18:16:20 <zzo38> It is not supposed to be a rhetorical question.
18:16:38 <shachaf> Spill the beans, ddarius. What ideas?
18:17:06 <elliott> We must know the horror.
18:17:35 <ddarius> elliott: I'm not sure if I remember one clearly, but certainly zzo38's is limited by being purely compile-time.  There are various reflection-like features similar to this one but at run-time that have been suggested.
18:18:08 <elliott> ddarius: You could just do everything in TH.
18:18:19 <shachaf> elliott: That's still compile-time.
18:18:21 <elliott> It's only limited like that if you limit /your imagination/.
18:18:29 <elliott> shachaf: Yeah, but who needs runtime? Just error out after all's done.
18:19:06 <zzo38> Can you show me the similar stuff but that is at run-time?
18:19:20 <ddarius> elliott: At compile-time, TH is perfectly normal Haskell with just a fancy notation for some values of certain data types.
18:19:40 <elliott> ddarius: Hmm, I guess what you really need is to start a daemon from within TH-land that runs the program after it compiles.
18:19:51 <elliott> Then your program just has to be able to call out to GHC to recompile itself, and you can mingle compile- and run-time freely.
18:20:06 <ddarius> elliott: My point was that TH isn't insane.
18:20:08 <zzo38> I *did* mention in my doucment that you can reify more-declarations.
18:20:17 <shachaf> @quote zzo38
18:20:18 <lambdabot> zzo38 says: When the Confuser is turned on, move the xyzzy rules after the plugh rules. That is why you need to reify the more-notation.
18:20:22 <ddarius> Admittedly, you can write whatever language you want that way.
18:22:48 <ddarius> So researchers should make a calculus that gives #become a meaningful type.
18:23:16 <zzo38> ddarius: What do you mean by that, specifically?
18:23:21 <elliott> ddarius: Mumble mumble linear types mumble?
18:23:58 <ddarius> elliott: Linear types would help but you'd need more than that.
18:24:25 <shachaf> Has there been a proposal for linear kinds yet?
18:24:39 <elliott> We're really pushing the boundaries tonight.
18:24:53 <elliott> Asking: Maybe we've explored all the sane language extensions. What about the insane ones???
18:25:12 <shachaf> Perhaps it is not the language extension that is insane, but you.
18:25:26 <elliott> Also every GHC developer if this stuff gets into the Report.
18:25:32 <elliott> Give or take a few months.
18:25:44 <ddarius> GHC developers don't decide what gets into the Report.
18:25:51 <elliott> ddarius: No, but they get to implement it.
18:26:03 <ddarius> They don't have to implement it.
18:26:10 <ddarius> NHC never implemented the monomorphism restriction.
18:26:40 <elliott> That's a restriction. These are EMPOWERING!
18:26:40 <zzo38> What does linear types and linear kinds means anyways?
18:27:02 <shachaf> NHC just implemented the polymorphism unrestriction.
18:27:11 <ddarius> zzo38: Something that a quick google search will tell you.
18:27:21 <ddarius> Except I'm not sure what will come up for linear kinds.
18:27:25 <ddarius> @google "linear kinds"
18:27:26 <lambdabot> http://ezinearticles.com/?Being-Non-Linear-Minded-In-A-Linear-Minded-World&id=6273684
18:27:26 <lambdabot> Title: Being Non-Linear Minded In A Linear Minded World
18:27:26 <elliott> wait, has anyone actually done linear kinds?
18:27:34 <elliott> haha wow if you google "linear kinds" it highlights "linear types"
18:27:44 <elliott> and seems to just be the same as googling for linear types actually
18:27:47 <shachaf> @google "linear kind"
18:27:48 <lambdabot> http://www.uv.es/gomezb/32Problemsoflinear.pdf
18:27:48 <lambdabot> Title: PROBLEMS OF A LINEAR KIND: FROM VALLEJO TO PEACOCK
18:28:04 <elliott> "This work is concerned with epistemological conceptions linked to a historical and
18:28:05 <elliott> pedagogical alternatives and approximations in the evolution of teaching of algebra,
18:28:05 <elliott> with respect to the solving of linear problems through algebraic method."
18:29:04 <Jafet> Just teach the first three instances of Cramer's rule and be done with it
18:29:13 <Jafet> 4x4 is good enough for anyone
18:30:04 <ddarius> Hmm, I think I more or less meet all of the advantages and disadvantages of "non-linear minded people" except being seen as ADD/ADHD, and I would not describe myself as "non-linear minded" at all.
18:30:27 <elliott> quite an "article", that
18:42:44 <Sgeo> Suppose I want to write something to let me interact with the outside world. Is a common thing to do making a, say, MyWorld monad and a function MyWorld a -> IO a?
18:47:29 <Jafet> It's not uncommon
18:47:49 <Jafet> The function is invariably called runMyWorld or something
18:48:14 <Jafet> Which sounds like the title of a typical europop hit
19:04:06 <zzo38> How do you send a file to the cabal? Can it be done using SSH?
19:04:55 <Jafet> In the glittery white concrete monolith, over there.
19:05:13 <zzo38> Over where?
19:05:23 <Cale> http://hackage.haskell.org/packages/upload.html
19:06:54 <zzo38> O, I think I found it, is it "cabal upload"?
19:08:54 <zzo38> How do I figure out what the Hackage username and password is?
19:11:09 <elliott> "If you need a username, please send mail to ross@soi.city.ac.uk. Your username will be your name in CamelCase (e.g. "JosephBloggs", those already registered). Any real person with a Cabal package to upload is welcome."
19:11:10 <azaq231> zzo38: It asks for the data for your own Hackage account
19:11:11 <elliott> -- http://hackage.haskell.org/packages/accounts.html
19:14:14 <zzo38> But the program is public domain. I don't need my name on it, or anyone else's name on it.
19:15:02 <mauke> put it on thepiratebay.org
19:15:38 <shachaf> @arr
19:15:38 <lambdabot> Avast!
19:15:59 <zzo38> Using FTP or SSH?
19:16:23 <shachaf> sftp
19:16:33 <mauke> I have suddenly lost the last amount of vague interest
19:16:44 <zzo38> OK
19:18:04 <elliott> zzo38: you need an account to upload to hackage
19:18:16 <zzo38> Is there another cabal for anonymous files? Is there possible to make cabal program access multiple servers?
19:18:33 <elliott> that doesn't mean you need to be listed as author or maintainer of anything you upload, necessarily
19:18:53 <zzo38> O, I didn't know that.
19:18:55 <mauke> I, too, wish to distribute malware anonymously and have it run by cabal users
19:19:23 <zzo38> I do not wish to distribute malware. I wish to distribute public domain software.
19:19:41 <mauke> nudge nudge, wink wink, say no more
19:20:19 <shachaf> mauke: I didn't know you wrote "public domain" software.
19:20:26 <shachaf> ...If you know what I mean.
19:21:17 <zzo38> Sometimes I use GNU GPL v3 or later version, but sometimes I write public domain software. Including this Haskell program is public domain software  http://zzo38computer.cjb.net/prog/Constantinople.zip
19:21:42 <mauke> zip. how quaint.
19:21:47 <zzo38> But I want to send Glk program, it is written in C and in Haskell.
19:22:18 <zzo38> mauke: I can put some other formats too if you want the other format too
19:22:51 <mauke> I want .mov because that's what quicktime supports
19:23:36 <shachaf> mov. how quaint.
19:23:53 <zzo38> mauke: Too bad I don't do Quicktime. And that file is not a movie file anyways. If you want .mov then make your own movie please.
19:24:16 <mauke> shachaf: .rmv then?
19:24:29 <shachaf> convert Constantinople.zip Constantinople.mov
19:24:35 <shachaf> ImageMagick does everything, man.
19:24:49 <Jafet> Including mangle gif animations
19:24:51 <zzo38> I don't think it can do that. But I do use ImageMagick and it is very good.
19:24:53 <mauke> sweet
19:25:20 <shachaf> Jafet: Mangle gif animations?
19:25:26 <Jafet> rename 's/.zip$/.mov/'
19:25:28 <zzo38> However, it does not have support for audio (although it is possible to fake it by converting to raw and then to ImageMagick and then back to other formats using SoX)
19:26:30 <ddarius> x = f^-1(b),  x_n = e_n ¬∑ x = e_n ¬∑ f^-1(b), x_n I = e_n ¬∑ f^-1(b) I = e_n ¬∑ (f^-1(b)‚àßI) + f^-1(b) ‚àß e_n ¬∑ I = f^-1(b) ‚àß e_n ¬∑ I, f (x_n I) = x_n f(I) = x_n det(f) I = f(f^-1(b) ‚àß e_n ¬∑ I) = f(f^-1(b)) ‚àß f(e_n ¬∑ I) = b ‚àß f(e_n ¬∑ I) = (determinant in numerator of Cramer's rule) I, so x_n = (determinant in numerator of Cramer's rule)/det(f)
19:26:37 <shachaf> Jafet: /usr/bin/unzip -> /usr/bin/u.mov?
19:27:16 <Jafet> Zip your gun, please
19:27:58 <mauke> mmv '*.zip' '#1.mov'
19:29:54 <zzo38> Did I do anything wrong this program? This program does work it is Constantinople compiler
19:54:26 <blackdog> hoogle has given me nothing - how do i take an indexed substring of a bytestring?
19:55:18 <blackdog> hm, i guess splitAt applied twice would work
19:57:13 <mauke> drop/take
19:57:25 <blackdog> and that's cleaner still. thanks.
19:59:52 <shachaf> If you end up using only a small part of a large bytestring, the whole thing will still be kept in memory, right?
20:01:06 <rwbarton> there's a function to copy only the part of the string you need
20:01:52 <rwbarton> or rather, to copy a string that might be an (offset, length) into another string to its own storage
20:02:56 <blackdog> i don't think it'll be an issue. the references will be pretty short-lived.
20:27:53 <rgrinberg> Hi all.  what would be the haskell function to insert a substring into a string at a given position?
20:28:28 <luite> don't think there is one, but you can make one with splitAt
20:29:10 <rgrinberg> agreed, just didnt want to make my own wheel if it was unnecessary
20:29:27 <blackdog> rgrinberg: and you mean "build a new one from the old string", right?
20:29:36 <rgrinberg> blackdog: ya of course
20:52:13 <ian__> Why can't I do " foldl1 (.) [map, map, map] "
20:52:24 <ian__> Occurs check: cannot construct the infinite type: a = [a]
20:52:46 <mauke> :t map
20:52:46 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:53:03 <mauke> because map :/: x -> x for some type x
20:53:57 <blackdog> :t foldl1 (.) [map (+1), map (3-)]
20:53:59 <lambdabot> forall a. (Num a) => [a] -> [a]
21:06:19 <ian__> I can do " (map . map) (+1) [[1],[2]] " but not " (foldl1 (.) [map, map]) (+1) [[1],[2]] "
21:07:22 <Saizan> yep, correct
21:07:46 <ian__> I don't understand why that is :(
21:07:54 <Saizan> because in the first expression the two uses of map have different types
21:08:10 <Saizan> while if you put them into a list they are forced to have the same type
21:11:11 <Saizan> and in particular foldl1 (.) the list to have a type that matches t -> t, which map can't have anyhow
21:11:29 <Saizan> s/the list/forces the list/
21:16:07 <danharaj> hmm, I feel like there should be a typeclass for data that can be used as a function.
21:21:15 <parcs> does rebindable syntax allow rebinding of function application?
21:22:17 <Saizan> danharaj: http://hackage.haskell.org/packages/archive/keys/2.1.1/doc/html/Data-Key.html#t:Indexable
21:22:40 <ddarius> parcs: No.
21:23:21 * ddarius didn't realize it was 1 in the morning.
21:23:48 <parcs> that probably wouldn't work out to well anyway
21:23:53 <parcs> too*
21:24:37 <ddarius> If you want, you can use SHE's idiom brackets and effectively get that.  You can also fake it to some extent.
21:25:30 <shachaf> Don't idiom brackets restrict you a lot more than arbitrary "rebinding of function application"?
21:25:51 <ddarius> shachaf: In theory...
21:30:23 <ddarius> I guess I should say that you would still need to be abusing the idiom brackets.
21:30:38 <ddarius> Unless your "overloading of application" happens to be Applicative, which is likely if it is reasonably.
21:30:47 <ddarius> s/reasonably/reasonable/
21:35:26 <ddarius> The final thing you could do is just throw some TH around everything relevant and have it add calls to your application overload to the applications.
21:48:08 <ian__> what does s/_____/_____ mean?
21:48:16 <ian__> replace s/this/that?
21:48:47 <madhadron> Yes
21:48:53 <madhadron> It's regular expression syntax
21:49:11 <madhadron> Haskellers use regular expressions more often in conversation than in code, thanks to Parsec (:
21:49:24 <ian__> weird lot
21:50:14 <madhadron> Hey, some of us are semi-normal.  I'm spending my evening trying to force Python's with blocks to do something that would be trivial in Lisp.
21:50:57 <shachaf> madhadron: Trying to abuse them to act like lambdas?
21:51:10 <Jafet> The python bites! The python bites! The python grabs you!
21:51:19 <madhadron> No, they're not assignable expressions unfortunately
21:51:25 <madhadron> They are easily made into let-rec, though
21:51:33 <madhadron> which I found charming
21:51:50 <madhadron> No, I'm trying to get them to skip their bodies if the with binding evaluates to false.
21:54:22 <shachaf> Jafet: The python swings itself around you!
21:54:44 <madhadron> It's very hard to abuse a language that lacks symbols, blocks, progn, real anonymous function, continuations, and macros.
21:55:10 <shachaf> madhadron: Clearly you lack in creativity.
21:55:18 <Jafet> Oh god, not Swing.
21:55:23 <madhadron> And, oh, it has made me want to abuse it over the years for its failure to distinguish between define and set!.
21:55:35 <madhadron> shachaf: Oh, you can abuse it in certain ways.
21:55:38 <sohum> @pl \a b x y -> f b a x y
21:55:39 <lambdabot> flip f
21:55:40 <shachaf> When you want to abuse a language, don't look at what it *doesn't* have; look at what it does.
21:55:44 <madhadron> But it's like being told "You can whip him, except on the right foot"
21:55:48 <shachaf> Python can be abused in many ways Haskell can't.
21:55:48 <sohum> right, okay
21:56:14 <madhadron> shachaf:
21:56:27 <madhadron> Except that I'm usually trying to rectify a design flaw in Python that Haskell doesn't have
21:56:33 <madhadron> (bad enter key, bad)
21:57:07 <madhadron> There are days when I just want to crawl into Common Lisp and pull my Emacs window in after me.
21:57:24 <shachaf> Python has at least three different constructs that could be replaced with lambdas.
21:57:37 <shachaf> (Well, one of them is "lambda", to be fair.)
21:58:08 <madhadron> And I desperately wish they would replace their for loop with a map over a lambda.
21:58:32 <shachaf> "for" is one, "with" is another.
21:59:11 <Jafet> "lambdas are bad." ~ guido
21:59:20 <Jafet> Also, map is bad.
21:59:33 <Jafet> His logic is impenetrable.
21:59:38 <shachaf> "let's go shopping!" ~ consultant_barbie
21:59:53 <madhadron> Jafet: Guido has managed to make a language that morons can be trained to write code that doesn't make you want to tear your eyes out  fairly quickly and reliably.
22:00:25 <madhadron> trained to write code in*
22:01:11 <Jafet> I still can't tear my eyes out quickly and reliably. I hope this doesn't affect my resum√©.
22:01:50 <madhadron> Jafet: Tsk tsk.  The Perl community has some good courses on that.
22:02:06 <madhadron> Or your local BDSM club
22:02:15 <madhadron> which maybe the same thing
22:02:45 <Jafet> I've been near a DBMS; does that count?
22:03:18 <madhadron> I said BDSM, not BDSM and its relations.
22:03:29 <azaq231> madhadron: "with expr as var", and var evaluates to "False"? This shouldn't be doable with a with statement as var is the value of expr.__enter__() and only given to the body of with - this also
22:03:30 <azaq231> seems like a weird use case for with, as var should be some object which is constructed on entering and actually relevant to the opening / closing part of with
22:04:30 <madhadron> azaq231: In Python, if treats False, "", and None all as false.  I find myself writing code like x = ...; if x: do something quite a lot
22:05:03 <madhadron> azaq231: The idea is with maybe(...) as x: stuff should skip stuff is maybe's argument is false
22:06:43 <madhadron> Though even if I managed it, there's the question of what will happen when I start combining such statements at the top of a with block.
22:10:32 <ian__> will learning haskell inhibit writing code in imperative languages
22:14:04 <ddarius> It will take time away from writing code in imperative languages and thereby inhibit it that way.
22:19:32 <Jafet> You could write imperative languages in haskell and then write code in them
22:21:18 <glguy> Haskell has plenty of imperative bits to keep you going
22:21:24 <overscore> When the only tool you have is a hammer, all problems look like nails.
22:21:52 <Jafet> Haskell gives you a nail gun
22:22:08 <mauke> s/nails/thumbs/
22:22:24 * glguy yodels into the echo chamber
22:23:04 <overscore> a thumb gun now that's a novel idea
22:49:01 <djahandarie> ddarius, have any tips on shaving with a straight razor?
22:49:40 <ddarius> djahandarie: You can try reading this: http://www.razorsbarbershop.com/pdf/The-Straight-Razor-Shave.pdf
22:51:31 <ddarius> djahandarie: Other than that, don't expect to succeed the first few times.
23:05:17 <Jafet> In the court of the Gillette King
