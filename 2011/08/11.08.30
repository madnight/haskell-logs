00:01:51 <DevHC_> btw, in http://www.haskell.org/haskellwiki/Monomorphism_restriction, Henning Thielemann wrote:
00:01:52 <DevHC_> let x = y  -- function or pattern binding?
00:01:56 <DevHC_> .
00:02:02 <DevHC_> what's the difference?
00:02:22 <DevHC_> u r either defining a nullary function, or doing 0 decompositions
00:02:34 <DevHC_> in both cases x is whatever there is on the right side
00:02:43 <Jafet> All functions are unary
00:02:50 <Jafet> So that's a pattern binding
00:03:02 <Jafet> :t let x = show in x
00:03:02 <lambdabot> forall a. (Show a) => a -> String
00:03:25 <Jafet> Bah, where's the monomorphism restriction when you need it
00:06:15 <DevHC_> definition: if f cannot be applied to arguments, then f is a nullary function. if f can be applied to 1 argument, but not 2 (ie., the resulting function/whatever is a nullary function), then f is a unary function. etc., if f can be applied n arguments, then f is an n-ary function
00:06:21 <DevHC_> Jafet
00:11:59 <Jafet> DevHC_
00:12:24 <Jafet> @where report
00:12:24 <lambdabot> http://www.haskell.org/onlinereport/
00:12:40 <Jafet> Formally, all functions are unary.
00:12:51 <DevHC_> <Jafet> All functions are unary
00:12:51 <DevHC_> <Jafet> So that's a pattern binding
00:13:00 <DevHC_> let f x y = ... -- pattern binding
00:13:33 <Jafet> Bah, return to your cave.
00:13:55 <DevHC_> this is my cave
00:13:59 <DevHC_> this is the base of trolls
00:14:05 <DevHC_> nw4h4h4h4h4
00:19:23 <shachaf> http://haskell.org/onlinereport/ links to http://haskell.org/definition/ , which has a broken image.
00:23:09 <erus`> and no style sheet
00:40:19 <mysticc> http://paste.pocoo.org/show/466984/ .. why first function is much slower than the second ... and how to make first one faster ...
00:45:57 <mysticc> anyone here ??
00:46:02 <DevHC_> hi
00:46:25 <mysticc>  http://paste.pocoo.org/show/466984/ .. why first function is much slower than the second ...
00:46:46 <DevHC_> i have a feeling that u r repeating urself
00:49:06 * hackagebot appar 0.1.4 - A simple applicative parser  http://hackage.haskell.org/package/appar-0.1.4 (KazuYamamoto)
00:49:49 <mysticc> DevHC_: I thought fold would have been faster
00:51:26 <cwl> how to import state monad, get, put ...
00:51:33 <DevHC_> mysticc: consider using foldr instead of foldl
00:53:58 <adimit> is there a library somewhere that defines first, second and third operations for 3-tuples?
00:54:01 <DevHC_> mysticc: http://paste.pocoo.org/show/466993/
00:55:38 <DevHC_> mysticc: basically, iirc, left-associative (ie, foldl) concatenation of strings is O(n^2)
00:56:08 <mysticc> DevHC_: Yeah I got that ... let me check the performances ...
00:56:36 <int-e> adimit: http://hackage.haskell.org/packages/archive/tuple/0.2.0.1/doc/html/Data-Tuple-Select.html perhaps
00:58:14 <int-e> adimit: (I say 'perhaps because I don't know whether there are more "established" alternatives.)
01:04:56 <jim``> Now ghc-7.2.1-i386-unknown-linux.tar.bz2 has loads of include errors :(
01:07:37 <jim``> make show-install-setup "No rule to make target"
01:15:13 <Axman6> @unmtl StateT [Token] (Either String) a
01:15:13 <lambdabot> [Token] -> Either String (a, [Token])
01:25:08 <adimit> int-e: thank you
02:00:47 <Botje> @pl (\acc x -> 10 * acc + x)
02:00:47 <lambdabot> (+) . (10 *)
02:01:46 <companion_cube> nice
02:01:48 <ski> @pl \acc x -> x + 10 * acc
02:01:49 <lambdabot> (+) . (10 *)
02:01:57 <ski> that's interesting
02:02:44 <ski> (apparently it used commutativity of addition)
02:02:59 <quicksil1er> yes, @pl has a few surprising rules
02:03:23 <ski> @pl \x acc -> x + 10 * acc
02:03:24 <lambdabot> (. (10 *)) . (+)
02:04:06 * hackagebot normaldistribution 1.1.0.2 - Minimum fuss normally distributed random values.  http://hackage.haskell.org/package/normaldistribution-1.1.0.2 (BjornBuckwalter)
02:04:07 * ski wonders who quicksil1er is, and what he/she's done with quicksilver
02:04:27 <Botje> it's an alpha-renamed clone, to avoid confusion
02:05:13 <ski> but there's no `quicksilver' in scope, so how can that be ?
02:10:00 <quicksil1er> apparently freenode won't let me change my nickname right now
02:12:02 <ski> you might have to momentarily part with some channel with a stupid mode
02:12:24 * ski used to have that problem with #screen
02:33:27 <erus`> Why did they name Python Python? Because it invokes the same involuntary response and when you see a Python
02:38:43 <enlga> erus`: after Monty Python
03:11:15 <navaati> hi
03:15:19 <azaq23> navaati: hi
03:17:01 <navaati> i'm discovering the repa library, and i don't understand the difference between index and unsafeIndex, as they have the same type
03:18:55 <quicksil1er> navaati: I expect it skips the bounds checking
03:18:59 <quicksil1er> or other safety checks
03:20:01 <navaati> yes, but how can index do safetyChecks, as it's return type is a plain value, not a Maybe or something like this ?
03:20:45 <navaati> that is, if I try to get an out of range value, how can the failing can be different ?
03:21:02 <quicksil1er> error message instead of segfault?
03:21:04 <quicksil1er> I expect.
03:21:18 <navaati> oh
03:21:56 <navaati> ok, i didn't imagine a segfault could happen, i understand now, thanks
03:22:44 <flux> navaati, it is my understanding in haskell unsafe in general implies "segfault may happen"
03:23:07 <flux> but perhaps there are some other less severe meanings on that word as well
03:23:22 <navaati> i thought it meant "error/exception may happen", like in head
03:23:40 <flux> unsafe as in "type safety has been lost"
03:23:58 <flux> if there was unsafeHead, I would expect it to segfault on empty list :)
03:24:41 <flux> I guess a function that cannot raise exceptions is slightly more safe, still
03:24:42 <aristid> flux: it "just" errors out, which is more or less equivalent to a segfault ;)
03:25:02 <flux> aristid, I'd say there's a severe difference between erroring out and segfaulting :)
03:25:06 <aristid> well, every function can bottom out by recursing infinitely
03:25:12 <flux> for example, from the former you can recover
03:25:15 <aristid> flux: it's all just bottom!
03:25:47 <flux> in the latter your machine may cease to function, if you don't have the equivalent of nice segmentation fault signal around
03:25:55 <navaati> ok, actually there are 3 levels of safety : unsafeFunc may crash, func may raise an exception, and safeFunc is typesafe, thanks to a Maybe output, for example
03:27:07 <hpc> navaati: the last level of unsafety is nontermination
03:27:29 <hpc> it's neither exception nor crash
03:27:55 <navaati> like "if you do wrong things, this function may return anything" ?
03:28:47 <hpc> an unsafe function is one that doesn't return a defined value for all defined input
03:28:59 <hpc> (sort of; sort would technically be unsafe)
03:29:06 <navaati> or like "it may loop/recurse forever" ?
03:29:15 <hpc> so a crash would make it not return a defined value
03:29:24 <hpc> an exception would be undefined too
03:29:44 <hpc> and nontermination doesn't yield a value ever
03:29:47 <hpc> not even an undefined one
03:30:07 <hpc> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#.E2.8A.A5_Bottom
03:43:00 <minh> I have a question regarding return-types and type-classes. Let's say, the datatypes Foo and Bar are both instances of the typeclas FooBar. And there is a "Container" datatype data Container = Foo Bar. Now, I'm having difficulties writing a function f :: (Foobar t) => Container -> t
03:43:37 <Saizan> you mean data Container = Con Foo Bar ?
03:43:40 <minh> i.e. a function that gets the Container datatype and can return either Foo or Bar
03:43:48 <minh> Saizan: right, sorry
03:44:09 <quicksil1er> you need to give the typeclass a method to help you
03:44:12 <quicksil1er> or several.
03:44:23 <Saizan> anyhow, the type f :: Foobar t => Container -> t means that the caller of 'f' gets to choose the concrete type to use for 't'
03:44:32 <quicksil1er> fooIfAvailable :: FooBar x => x -> Maybe Foo
03:44:38 <quicksil1er> or, if you like
03:44:53 <quicksil1er> availableParts :: FooBar x => x -> (Maybe Foo, Maybe Bar, .... )
03:45:01 <Cale> Let's stop using Foo and Bar in our example and talk about what you're actually doing.
03:45:04 <quicksil1er> which encode in the type class the possibilities.
03:45:13 <minh> quicksil1er, Saizan: so...my existing typeclass is for Foo and Bar. To solve my problem, I need another typeclass for the container type, right?
03:45:19 <quicksil1er> minh: no.
03:45:26 <quicksil1er> cale's advice is good, you may want to explain more.
03:45:36 <quicksil1er> but you *could* solve it by adding the methods I suggest to your existing class.
03:45:42 <Cale> It is really really hard to provide quality advice with just this information
03:46:30 <Cale> (as quicksil1er pointed out, we don't even know what methods the FooBar class has, or what that class represents)
03:46:58 <Cale> It could just be impossible to write a function of the type you want
03:47:15 <minh> quicksil1er, Cale, Saizan: I agree, that foobar-jargon isn't the best. But in this very case it's easier than describing the real scenario, believe me
03:47:42 <Cale> Well, it's not easier, because we don't really have enough information to answer the question.
03:48:03 <minh> Cale: what pasteversive do you guys use?
03:48:09 <Cale> hpaste.ord
03:48:12 <Cale> org*
03:49:09 * hackagebot paypal-api 0.1 - PayPal API, currently supporting "ButtonManager"  http://hackage.haskell.org/package/paypal-api-0.1 (StephenBlackheath)
03:49:15 <Cale> The answer to how or whether you can write a function of that type depends on what the methods of the class are.
03:51:50 <hpaste> minh pasted “typeclass” at http://hpaste.org/50783
03:52:01 <Saizan> you basically want some way to tell if the caller is asking for a Foo or for a Bar
03:52:35 <Saizan> ah, no
03:52:44 <Saizan> it seems you want the body of the function to decide
03:52:57 <minh> Saizan: right
03:53:02 <Saizan> then you want an existential (or a sum type) as the return type of affectedPart
03:53:04 <hpc> you should be returning Either Foo Bar
03:53:36 <Cale> minh: We need the definition of the typeclass Injectable
03:53:50 <Axman6> not really
03:54:10 <Axman6> it's pretty obvious the actual type returned by that function can't be known at compile time
03:54:39 <minh> Cale: alright. but the contents of the typeclass Injectable are completely non-relavant for this problem right there.
03:54:41 <Axman6> since jmlPairs :: [JMLPair], and stmts :: [Stmt]
03:54:51 <Cale> They're not irrelevant at all!
03:55:03 <Axman6> sure it is :\
03:55:33 <Cale> In fact, whether it's possible to write a function of type (Injectable t) => Range -> HoareTriple -> [t]  *completely* depends on what methods Injectable t has.
03:55:38 <Axman6> minh: you can't return two different types based on results at runtime. there's no way for the compiler to be able to figure out the type of that function
03:55:55 <minh> Axman6, Cale: I'll post the code that is kind of redundant due to this problem
03:56:02 <hpaste> hpc annotated “typeclass” with “typeclass (annotation)” at http://hpaste.org/50783#a50784
03:56:09 <Axman6> minh: what you
03:56:10 <hpc> fixed for you minh
03:56:19 <quicksil1er> I am fairly sure minh doesn't actually want the type signature he claims to want
03:56:35 <quicksil1er> he actually wants Range -> HoareTriple -> [exists t . Injectable t => t]
03:56:35 <Cale> hpc: Well, now the code is right, but maybe the type isn't the type he wanted?
03:56:44 <Axman6> what you've written is basically equivalent to: foo x = if x < 10 then True else 10, which obvioualy makes no sense
03:56:44 <Cale> quicksil1er: I'm not sure if he does or not!
03:56:50 <quicksil1er> which is different from the signature he asked for.
03:56:58 <quicksil1er> (as well as not being valid at all, the way I wrote it, clearly)
03:57:09 <Cale> He may very well want a function of type  (Injectable t) => Range -> HoareTriple -> [t]
03:57:16 <Axman6> i would wager that Saizan's solution is most likely what is needed
03:57:28 <Cale> But since we have no idea what Injectable is, we can't tell if such a function is possible to write
03:57:32 <hpaste> minh pasted “redundant” at http://hpaste.org/50785
03:57:47 <LambdaFred> @pl (\x -> (* (fst x ^ snd x)))
03:57:47 <lambdabot> (*) . uncurry (^)
03:57:56 <Axman6> ie, Range -> HoareTriple -> Either [JMPairs] [Stmt]
03:58:06 <Cale> minh: Can you please just paste the definition of the Injectable typeclass?
03:58:32 <Axman6> there should be no need at all to use extensions like whatever lets you use exists
03:58:42 <Cale> Axman6: There is no such extension
03:59:03 <Axman6> so what quicksil1er had earlier isn't possible?
03:59:08 <hpaste> minh pasted “Class injectable” at http://hpaste.org/50786
03:59:09 <Cale> Axman6: quicksil1er wrote that type like that as shorthand for defining an existential type and using it
03:59:09 <quicksil1er> it was a convenient shortcut
03:59:12 <hpaste> Saizan annotated “typeclass” with “typeclass (annotation)” at http://hpaste.org/50783#a50787
03:59:14 <quicksil1er> you actually have to define a type.
03:59:14 <benmachine> I have a vague recollection that some non-GHC compiler has an exists keyword, but it still doesn't do that :P
03:59:26 <hpc> benmachine: JHC?
03:59:36 <Saizan> minh: 2 alternatives http://hpaste.org/50783
03:59:47 <quicksil1er> UHC has a first-class exists keyword
03:59:52 <quicksil1er> it has some peculiarities though
04:00:13 <hpc> it was my understanding that exists y. x -> y was a shortcut for x -> (forall y. y)
04:00:19 <Cale> minh: Okay. So is there a way to turn a Range and a HoareTriple into a [Token]?
04:00:44 <benmachine> isn't x -> forall y. y the same as forall y. x -> y?
04:00:59 <Cale> benmachine: yes
04:01:26 <minh> Cale: no. Token is a Alex-Token
04:01:32 <minh> Cale: not related at all
04:01:38 <Cale> minh: Then it's impossible to write a function of the type you want.
04:02:08 <Axman6> bleh, writing a function to execute lambda calculus is more difficult than I had expected :(
04:02:20 <benmachine> Axman6: shadowing fucks it up :P
04:02:20 <Cale> minh: Because the only way to get hold of a polymorphic value of type t according to the class (without already having one) is to apply incParse to a list of tokens.
04:02:23 <hpc> Axman6: to evaluate it?
04:02:32 <Axman6> benmachine: very much so >_<
04:02:49 <minh> Saizan: I'll have to have a real quick smoke. Then I will try your affectedPart2. I'll hit you back in 3-4 minutes
04:03:02 <benmachine> Axman6: I used syb extensively when I was doing something like that
04:03:29 <benmachine> although I talked to neil mitchell and he reckons uniplate could do it better
04:03:38 <Axman6> i think i have problems with expressions like '(\f g x -> g (f x)) (\y -> x) ...' where the x's then conflict
04:03:41 <Cale> minh: Please note that the type affectedPart :: (Injectable t) => Range -> HoareTriple -> [t] means that no matter what type t it is that I want, if I provide a Range and HoareTriple, I can demand that affectedPart give me a list of type t
04:03:51 <Axman6> uh
04:04:00 <Cale> as long as I have an instance of the class Injectable for that type t
04:04:28 <Axman6> ok, not that specific example, that works fine, but things similar
04:04:50 <benmachine> Axman6: so either magically ensure all names are unique, or anticipate problems and eta convert stuff
04:05:04 <mm_freak> what do you guys focus on, when heuristically determining the quality of a library on hackage?  i usually look at the last update and the library dependencies
04:05:09 <Axman6> well, i did make sure names are semi unique
04:05:17 <benmachine> semi, huh?
04:05:28 <benmachine> now you've got me wondering if I've done it right :<
04:05:41 <Cale> mm_freak: The types and the general appearance of the source code. Whether it builds.
04:06:18 <mm_freak> Cale: where quality includes real-world-suitability
04:06:21 <Axman6> like (\x -> (\x -> x)) turns into (\x -> (\a -> a)), but (\x -> (\x -> x)) (\x -> x) becomes (\x -> (\a -> a)) (\x -> x)
04:06:39 <benmachine> right
04:06:42 <Cale> http://hackage.haskell.org/packages/archive/cml/0.1.3/doc/html/Control-Concurrent-CML.html -- here's a package which looks completely sensible according to the haddock
04:06:43 <Axman6> since i'm only using Char's for names, i have a limited supply :P
04:06:51 <benmachine> use strings then :P
04:07:12 <Cale> http://hackage.haskell.org/packages/archive/cml/0.1.3/doc/html/src/Control-Concurrent-CML.html#atchan -- however....
04:07:14 <tomberek> hey Cale. finally found the root cause of my problem with allocation. Laziness.  I had to switch to a strict version of head, and write my own strict version of STRef
04:07:16 <Axman6> yeah... but this is due tomorrow, and execution is purely an extension
04:07:23 <benmachine> oh right
04:07:24 <benmachine> fair
04:07:29 <tomberek> **modifySTRef**
04:07:58 <mm_freak> Cale: that's a simple case, but when it comes to something like protocol implementations
04:08:12 <mm_freak> if it doesn't use any of bytestring or text, i generally just ignore the library
04:08:51 <mm_freak> also if it has a dependency on parsec, but not on enumerator
04:09:04 <Cale> huh, why?
04:09:11 <mm_freak> efficiency
04:09:16 <Cale> Because you want to use those types?
04:09:49 <Axman6> benmachine: i think when i'm done, I may later turn this into using strings (i originally was, but decided for simplicity)
04:10:00 <Axman6> hmmm...
04:10:03 <mm_freak> well, only few network libraries expose a flexible API, even if they do depend on enumerator/iteratee
04:10:30 <Cale> I actually tend to not use anything which would require enumerator, ever.
04:10:37 <Axman6> > [x : show n | n <- [0..], x <- ['a'..'z']]
04:10:38 <lambdabot>   ["a0","b0","c0","d0","e0","f0","g0","h0","i0","j0","k0","l0","m0","n0","o0"...
04:10:48 <mm_freak> Cale: what would be your alternative?
04:10:49 <Axman6> damn, why didn't i just use that -_-
04:10:59 <mm_freak> Cale: signal functions? ;)
04:11:00 <Axman6> maybe i still could
04:11:01 <Cale> mm_freak: Ordinary programming?
04:11:18 <Axman6> > ['a'..'z'] ++ [x : show n | n <- [1..], x <- ['a'..'z']]
04:11:19 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
04:11:19 <lambdabot>         against inferred type...
04:11:27 <mm_freak> Cale: the enumerator pattern seems to be a useful abstraction for simple stream processors
04:11:29 <Axman6> > map return ['a'..'z'] ++ [x : show n | n <- [1..], x <- ['a'..'z']]
04:11:31 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
04:12:00 <mm_freak> Cale: it has some limitations, but those are seldomly relevant in practice
04:12:20 <quicksil1er> the great hacker fallacy is that everyone assumes that the programming they need to do (or choose to do) is typical.
04:12:22 <Cale> Maybe. The types seem kinda ugly to me.
04:12:40 <mm_freak> also there is this new iterIO library, which i would like to give a shot
04:12:42 <quicksil1er> in fact there are all kind of interesting programs which don't process streams
04:12:43 <quicksil1er> (e.g.)
04:12:52 <quicksil1er> just as there are many which do, of course.
04:13:13 <mm_freak> quicksil1er: what is a network protocol implementation, if not a stream processor?
04:13:25 <quicksil1er> I don't care much about Data.Text because I have never needed to efficiently process unicode text, which doesn't mean I don't understand why it's important.
04:16:01 <benmachine> damn it, Axman6, you made me find a bug :(
04:16:10 <Axman6> :(
04:16:15 <benmachine> :P
04:16:21 * benmachine tries to work out a test case
04:16:35 <minh> Saizan: well..It doesn't work :-( ghc complains about not being able to pattern-match on that GADT you suggested (brain-explode). REcord syntax doesn't work either
04:16:49 <Axman6> my bug has been when taking (\f x -> f (f x)) a b to SKI and back again, i've been getting something like b b b b (b b b) >_<
04:16:58 <Cale> minh: What are you trying to accomplish? (Since the type of function you originally wanted to write isn't possible.)
04:17:19 <Axman6> Cale: sure it is, just return [] :P
04:17:35 <Cale> well, sure, a nontrivial function of that type is apparently impossible.
04:17:52 <frerich> Sorry for chipping in, but I was wondering: this pattern of constructing lists by chaining (:) invocation (as used by DLists) - is that particularly memory intensive because each function invocation is a separat thunk or so?
04:18:08 <Cale> frerich: no
04:18:20 <hpaste> minh pasted “redundancy” at http://hpaste.org/50788
04:18:21 <Cale> frerich: I've reduced memory consumption of programs using that trick
04:18:30 <benmachine> no particular reason why (x:) . (y:) should take up more memory than [x,y]
04:18:50 <Cale> Well, there's one reason, but it's not much more memory :)
04:19:30 <Cale> er, no, actually, you're right here :)
04:19:53 <Cale> x : (y : []) and (x :) . (y :) both have x, y, and three other bits each :)
04:20:13 <frerich> Cale: Is there some discussion of that trick (maybe a blog or something) somewhere? I once used it in one of my tiny programs (after I was made aware of it by somebody here - possible you Cale? :-) but now I forgot how it works and reading the DList source code is a bit tricky for me.
04:20:39 <Cale> minh: okay
04:20:48 <Axman6> the main advantage of using DLists is that you get 'O(1)' append
04:20:55 <Cale> minh: So what's the inferred type of  inject rng (incParse . alexScanTokens $ code) (length code)
04:21:05 <Cale> minh: Just chop that out and make it a definition.
04:21:10 <frerich> I jsut remember that the idea is to have a function which yields a composed function in order to "actually" append/prepend elements.
04:22:00 <Cale> frerich: The idea is that (.) is constant time (and space)
04:22:01 <minh> Cale: that's what I tried about an hour ago
04:22:01 <Cale> while xs ++ ys takes O(length xs) time
04:22:07 <Cale> (to fully evaluate)
04:22:32 <frerich> Cale: Does't "." create a new function, which requires a bit of bookkeeping memory or so? I think that's what I Was thinking of when asking about the memory usage.
04:22:36 <Cale> So we can go through our code and replace lists of type [t] with functions [t] -> [t] that add elements to the beginning of a list
04:22:49 <benmachine> frerich: only inasmuch as : creates a new structure
04:22:52 <Cale> frerich: Well, a new function which is only constant space
04:23:12 <Cale> (:) creates something new as well
04:23:18 <Cale> of about the same size
04:23:44 <quicksil1er> I have often wondered about the relative space requirements of (.) and (:) actually
04:23:53 <quicksil1er> it's generally ignored in these discussions
04:24:00 <quicksil1er> it's certainly the same O(), anyhow
04:24:11 <Cale> It's trivial, maybe a few bytes difference
04:24:13 <quicksil1er> they also use the stack differently
04:24:45 <quicksil1er> stack space sometimes has a funny cost model
04:24:53 <quicksil1er> (althought recent GHCs had some changes to make the stack cheaper)
04:25:06 <Axman6> segmented stacks?
04:25:13 * frerich notices he should probably use (.) instead of "." in the future since that's how everybody with a clue about Haskell seems to do it.
04:25:14 <Axman6> or is that only in HEAD
04:25:28 <quicksil1er> Axman6: that might be what I meant, I don't remember :)
04:25:38 <Cale> But I've turned a ByteString-concatenating program which used hundreds of megabytes of memory and took 45 minutes to run into one which used under a megabyte and ran in less than a minute using this trick. :)
04:25:55 <Axman6> i believe the stack is now basicallt a linked list of stacks, with some overlap in contents
04:26:22 <Cale> Anyway, I didn't make it through my explanation of the trick
04:26:36 * frerich listens up
04:26:49 <Cale> The idea is that we're going to replace lists of type [t] with functions of type [t] -> [t] which add elements to the beginning of a given list.
04:26:54 <Cale> We replace (++) with (.)
04:26:58 <Cale> and [] with id
04:27:06 <Cale> and [x] with (x:)
04:27:11 <Cale> throughout our code
04:27:43 <Cale> The main difference being that (++) takes on the order of the length of its left parameter number of steps to reduce fully
04:27:54 <Cale> while (.) always takes exactly one step to reduce
04:28:00 <Cale> [] ++ ys = ys
04:28:08 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
04:28:17 <Cale> ^^ this definition is really the definition
04:28:25 <Cale> (f . g) x = f (g x)
04:28:29 <Cale> ^^ as is this
04:28:39 <frerich> So instead of "[1,2,3]" you'd have "(1:) . (2:) . (3:) . id" and appending to that simply means to add a ". (4:)"?
04:28:59 <Cale> yeah, I suppose :)
04:29:00 * quicksil1er remarks that this is in fact an example of changing a choice of Monoid instance
04:29:14 <Cale> Or even just ([1,2,3] ++)
04:29:18 <Cale> since it's a constant list
04:29:19 <Axman6> > span (<5) [1..10]
04:29:20 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
04:29:24 <Cale> it's okay to use (++) locally like that
04:29:36 * benmachine has an idea (unrelated to the current discussion): a parse tree visualiser to make sure that what you thought you meant was what GHC thought you meant
04:29:52 <Cale> (because the performance will be the same there)
04:30:24 <Cale> frerich: So, for example, if we have this program:
04:30:40 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
04:30:49 <Cale> inorder Tip = []
04:31:04 <Cale> inorder (Branch x l r) = inorder l ++ [x] ++ inorder r
04:31:19 <Cale> inorder :: Tree a -> [a]
04:32:30 <Cale> This has a problem because (inorder l) can be arbitrarily long, and it's recursive, so in left-leaning trees, this will take quadratic time
04:32:49 <Cale> But if we apply this trick, we get:
04:32:52 <frerich> ...then 'inorder' could be made a 'Tree a -> ([a] -> [a])' and defined as '(inroder l:) . (x:) . (inorder r:)'?
04:32:53 <Cale> inorder' Tip = id
04:33:06 <Cale> inorder' (Branch x l r) = inorder' l . (x:) . inorder' r
04:33:10 <Cale> yeah
04:33:12 <Cale> er
04:33:21 <Cale> well, you had some extra (:)'s
04:33:40 <Cale> and now we can recover the original type by:
04:33:47 <Cale> inorder t = inorder' t []
04:34:02 <Cale> and now the function is always going to be linear in the size of the tree
04:34:11 <Cale> Since it takes constant time for each node.
04:35:09 <frerich> Hm that's pretty funky. I think it's my incomplete nomenclature showing, but it "feels" as if such a long chain of composed functions "(1:).(2:).(3:).id" is "less evaluated" than a list "1:2:3:[]"
04:35:21 <Cale> Well, it is
04:35:41 <frerich> I guess this feeling caused the uncertainity of being more memory intensive since there's less to be reduced straight away
04:35:54 <Cale> But it's about as evaluated as ([1] ++ [2]) ++ ([3] ++ [])
04:35:55 * frerich hopes he's making some sense.
04:36:02 <Cale> except that the latter is more expensive
04:36:09 <benmachine> evaluatedness doesn't necessarily correspond to memory size
04:36:18 <Cale> If you could just smash the whole tree into a bunch of conses, then you'd do that
04:36:20 <Cale> But you can't
04:36:22 <benmachine> e.g. repeat 0 grows the more you evaluate it :)
04:36:29 <Cale> Because you're writing a recursive definition
04:36:37 <Cale> which has to work for any tree
04:36:46 <Cale> Not just a constant tree with 4 nodes
04:36:53 <frerich> Cale: True. So my original quesiton was probably - is there some runtime impact (in terms of CPU or memory usage) of a fnction being "less evaluated"
04:37:03 * frerich is sure ther eis a proper term for "less evalutaed"
04:37:14 <Cale> Well, constructors are obviously more evaluated than other functions
04:37:22 <Cale> and don't have a time cost
04:37:32 <Cale> (because you can pattern match them immediately)
04:37:37 <frerich> Hm true4
04:37:46 <frerich> I didn't realize that.
04:37:51 <Cale> But our choice isn't between using constructors and non-constructors
04:37:54 <benmachine> frerich: I think the answer is that sometimes a function can take less memory unevaluated than evaluated, sometimes it can take the same amount, sometimes it can take more
04:37:56 <Cale> It's between using (++) and (.)
04:37:58 <frerich> Right.
04:38:12 <Cale> both of which are functions that require evaluation
04:38:24 <Cale> but (++) potentially much more evaluation than (.)
04:38:35 <Cale> Since when you write:
04:38:39 <Cale> [1,2,3] ++ [4,5]
04:38:45 <Cale> It reduces like:
04:38:55 <Cale> -> 1 : ([2,3] ++ [4,5])
04:39:05 <Cale> -> 1 : (2 : ([3] ++ [4,5]))
04:39:13 <Cale> -> 1 : (2 : (3 : ([] ++ [4,5])))
04:39:19 <Cale> -> 1 : (2 : (3 : [4,5]))
04:39:33 <Cale> (and this is really finished, up to notation
04:39:34 <Cale> )
04:39:44 <frerich> Cale, benmachine: Interesting stuff, thanks for your insightful explanations :-)
04:39:54 * dcoutts tests building pre-release gtk2hs-0.12.1 using ghc-6.10.4, ghc-6.12.3, ghc-7.0.4, ghc-7.2.1 ...
04:39:59 <Cale> So yeah, you can see how that takes time which is linear in the left list
04:40:28 <Cale> But (.) always reduces in one step, since it just makes a composite function out of its two parameters and it's done.
04:40:47 <fryguybob> dcoutts: Exciting!
04:44:49 <Cale> frerich: One of the first things I did when I started working at iPwn was to help make a program which wrote out a terrain file (containing descriptions of landscape heights along with props and monsters and so on) much more efficient, since it was consuming a lot of memory. It was a program that used bytestrings, and needed to concatenate them together in a different order than it was able to construct them.
04:47:15 <Axman6> benmachine: well, i managed to make it work sort of ok, but when i fo something like '(\f x -> f (f x)) f x" i get something like 'ε (ε ο)' back (yeah that's right, i made it produce greek variable names :P)
04:48:07 <Cale> (and the file format was kinda weird in that it needed pointers to other locations in the file embedded in it and so on). I basically converted the types involved so that type Chunk = (Integer, ByteString) and then had it operating on [Chunk] -> [Chunk] functions :)
04:48:26 <Cale> and that sped it up and reduced memory usage a lot, without much thinking :)
04:48:45 <Saizan> minh: you must use case to pattern match on that, not let
04:50:16 <Cale> (the Integer tags just denote the position in the file that the chunk was supposed to go, and we literally just sorted them at the end, but until that point were also able to concatenate lists of chunks together efficiently)
05:12:27 <absence> how do i use callCC in ghc 7? i can only find the documentation for ghc 6, and get an error that Control.Monad.Cont can't be found
05:13:02 <Axman6> absence: do you have mtl installed?
05:14:14 <Cale> absence: Make sure that either mtl or monads-fd installed
05:16:36 <absence> ah, so that's where it went. thanks :)
06:10:56 <hpaste> Axman6 pasted “Sierpinski triangle” at http://hpaste.org/50790
06:13:13 <int-e> Axman6: why didn't you use sqrt 3/2 as the height?
06:13:39 <Axman6> because i couldn't remember what it was supposed to be =)
06:14:29 <int-e> Well, sqrt (1 - (1 / 4)^2)  = sqrt (3 / 4) = sqrt 3 / 2
06:14:40 <int-e> oops. (1 / 2)^2
06:14:51 <Axman6> > sqrt 3
06:14:52 <lambdabot>   1.7320508075688772
06:15:28 <hpaste> Axman6 annotated “Sierpinski triangle” with “Sierpinski triangle (annotation)” at http://hpaste.org/50790#a50791
06:15:39 <Axman6> works a little better
06:16:12 <tromp> c version at http://paste.org/pastebin/view/37785
06:16:34 <roconnor> > sqrt 3 :: CReal
06:16:36 <lambdabot>   1.7320508075688772935274463415058723669428
06:17:28 <Axman6> tromp: N undeclared
06:19:06 <int-e> > (iterate sqrt 3 !! 5)^(2^5) :: CReal
06:19:10 <lambdabot>   mueval-core: Time limit exceeded
06:20:21 <Axman6> > (iterate sqrt 3 !! 5) :: CReal
06:20:22 <lambdabot>   1.034927767079864597988348920532832865389
06:20:38 <Axman6> > (iterate sqrt 3 !! 5) ^ (2^5)
06:20:39 <lambdabot>   3.000000000000005
06:21:04 <Axman6> > let !x = (iterate sqrt 3 !! 5) :: CReal in x^(2^5)
06:21:08 <lambdabot>   mueval-core: Time limit exceeded
06:30:05 <roconnor> > let !x = (iterate sqrt 3 !! 5) :: CReal in x^(2^5)*(fromRational (1/10^20))
06:30:08 <lambdabot>   mueval-core: Time limit exceeded
06:32:14 <roconnor> I find ezyang's advise of using enumerations to distinguish errors in pure code easier said than done.
06:34:10 <roconnor> I would like to see an example of a project that does this.
06:38:28 <roconnor> elaforge says the same thing as me.
06:40:02 <Saizan> example?
06:42:00 <yoff> Hi all, I am trying to install darcs via MacPorts and am having trouble installing ghc. Has anyone done this sucessfully? I am on Leapoard 10.5.8 and Darwin 9
06:42:14 <roconnor> some haskell package that uses enumerations for errors.
06:42:39 <roconnor> you would more or less need one enumeation type for each function that can fail in multiple ways.
06:42:45 <roconnor> *enumeration
06:43:00 <tromp> Axman6, you compile with -DN=some 2 power
06:43:24 <hpc> roconnor: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Exit.html#v:exitWith
06:43:26 <tromp> depending on size of triangle you want
06:43:28 <Saizan> roconnor: and have that function be of type ... -> Either ThatEnumeration ResultType ?
06:43:30 <hpc> roconnor: yes, i am cheating horribly :P
06:43:40 <roconnor> Saizan: yes
06:44:37 <roconnor> hpc says we should use ExitCode the enumeration of errors.
06:44:57 <hpc> roconnor: nah, just being obnoxious
06:44:58 <roconnor> ExitCode is isomorphic to Int + 1
06:45:11 <hpc> i use Either String
06:45:15 <Saizan> roconnor: i'd rather use this so that you get unions of possible errors for free http://hackage.haskell.org/package/control-monad-exception
06:45:23 <roconnor> hpc: ya I know you are kidding :P
06:45:24 <hpc> my programs don't handle errors themselves
06:45:42 <hpc> just print them
06:45:58 <roconnor> Saizan: not that I understand that package, but it does seem to be more reasonable.
06:46:06 <roconnor> Saizan: It feels like a varient type.
06:46:11 <Saizan> yep
06:46:34 <roconnor> hpc: of course, me too.  Which is why you and me any everyone else uses Either String.
06:46:55 <roconnor> not that I'm not sympathetic to using something like enumerations.
06:47:11 <roconnor> I'd even like to go further than using only enumerations.
06:47:20 <roconnor> but it just doesn't seem worth the effort.
06:47:52 <roconnor> If some how the exceptional data type could be generated almost for free, then it would be worth doing.
06:48:09 <Saizan> but if you don't ever plan on catching these errors you could as well use "error", though i guess Either String is more flexible
06:48:45 <hpc> Saizan: i like being able to log errors too :P
06:48:49 <roconnor> (If we follow "the view from the left", we should take our input data type T transform it via an isomorphism into Either Bad Good, where Bad is a data type exactly ismorphic to the Bad inputs of T.
06:49:26 <roconnor> Saizan: someone might plan to catch the errors.
06:49:50 <hpc> error leaves no documentation in the type
06:51:13 <hpc> (except for IO, assuming you aren't totally crazy)
06:51:36 <sully> does haskell have an extensible type a la exn in ML
06:52:19 <hpc> sully: no, but you can use a class+existential to get a similar effect perhaps?
06:53:10 <Saizan> HList has always had variant types
06:54:38 <Saizan> control-monad-exception has something similar too, i've never looked much at it though
07:02:53 <accel> why does haskell objective-c bindings suck so much?
07:03:16 <monochrom> because oop
07:03:50 <monochrom> actually oop without inheritance is easy in haskell. inheritance is the hard part
07:04:16 <earthy> which makes sense
07:04:37 <edwardk> haskell excels at black box inheritance, its that white box stuff it sucks at
07:04:52 <tomberek> ?
07:04:57 <monochrom> .
07:05:02 <hpc> ;
07:05:11 <edwardk> !
07:05:23 <Cale> ^
07:05:27 <monochrom> oop is easier in haskell+trex
07:05:27 <hpc> you can "inherit" just fine in haskell with
07:05:28 <ion> ‽
07:05:37 <edwardk> ,
07:05:37 <erus`> too late ion !
07:05:43 <monochrom> (in the above throughout, I include existential type in haskell)
07:05:48 <tomberek> ion: nice, is that the 'sarcarsm' punctuation?
07:05:48 <hpc> data Parent = P Int; data Child = Child {super :: Parent, foo :: String}
07:06:03 <ion> tomberek: It’s the interrobang, mainly used for interrogation.
07:06:13 <hpc> but then super :: Child -> Parent
07:06:30 <hpc> and can't have the polymorphism that it would have in say, Java
07:07:00 <tomberek> hpc, so the problem is that it's closed? not open like typeclasses?
07:07:02 <erus`> super :: Maybe Parent ?
07:07:12 <Cale> You can build your objects as functions parametrised by themselves, using fix to make proper objects from them, and then inheritance can work on the un-fixed version.
07:07:14 <monochrom> another trick buys you openness
07:07:24 <monochrom> which is what Cale says
07:07:47 <Cale> But inheritance is extremely over-rated.
07:07:53 <hpc> ^
07:08:03 <erus`> cant you just pass functions around in lieu of OOP ?
07:08:10 <Cale> Particularly so when implementation of methods isn't tied to the type of the object.
07:08:23 <Cale> erus`: Well, that is OOP :P
07:08:27 <Cale> more or less
07:08:31 <monochrom> it is also the same trick in every denotational semantics of oop
07:09:13 <Cale> Objects are just values which you think about as being determined by the implementation of their methods
07:09:14 <donri> inheritance is great when you don't have anything even greater ;)
07:09:26 <accel> why does oop matter? if C FFi are just stuffed in an IO () why can't objective-c FFI be stuffed in an IO () ?
07:10:04 <hpc> accel: C FFI isn't stuffed in an IO ()
07:10:14 <hpc> accel: what's the type of ffi_sqrt?
07:10:23 <monochrom> objective-c FFI is full of oop in practice, no? otherwise why was objective-c used in the first place?
07:10:31 <ion> ffi_sqrtAndPrintHello
07:11:07 * monochrom has macos's cocoa in mind
07:16:03 <accel> does haskell ahve qt bindings?
07:16:08 <accel> i'm trying to figure out a way to do gui on osx
07:16:12 <accel> that does not involve javascipt
07:16:15 <accel> or poking out my eyeballs
07:16:22 <dankna> accel:
07:16:24 <hpc> can OSX run gtk?
07:16:33 <dankna> I do it by writing a polyglot ObjC/Haskell program
07:16:41 <monochrom> hahahaha
07:16:42 <dankna> it can, even natively, but the result is unsatisfying
07:16:42 <earthy> there is http://qthaskell.berlios.de/
07:16:59 <Axman6> hpc: supposedly
07:17:08 <Cale> Why unsatisfying?
07:17:20 <dankna> well, because Mac users care heavily about things behaving like native apps
07:17:26 <accel> waht is unsatisfying: polyglot Objc/Haskell, or gtk ?
07:17:27 <dankna> the last time I checked, gtk even had its own open/save dialogs
07:17:32 <dankna> gtk is unsatisfying
07:17:45 <dankna> polyglot is fine, but requires hacks to Cabal to build (until dcoutts gets my patches reviewed :D)
07:17:46 <monochrom> @remember dankna I do [gui on osx] by writing a polyglot ObjC/Haskell program
07:17:47 <lambdabot> Nice!
07:17:58 * dankna blinks
07:18:03 <dankna> I have been quoted!
07:18:07 <thoughtpolice_> i think many people would love an objc-haskell bridge. the objc runtime does have specific APIs for language bridges, after all.
07:18:12 <dankna> I agree
07:18:15 <thoughtpolice_> (also, go dankna!)
07:18:22 <dankna> I have a project to make a real bridge
07:18:25 <accel> yes, I would love a bridge
07:18:26 <earthy> http://code.google.com/p/hoc/ <- is that not an objective-c <-> haskell bridge?
07:18:30 <accel> dankna: what is holding you back?
07:18:32 <dankna> yes, but hoc doesn't work :(
07:18:33 <thoughtpolice_> it is, but hoc is ancient and crufty
07:18:40 <thoughtpolice_> and rather insane in structure, IIRC
07:18:50 <dcoutts> TacticalGrace has apparently been thinking about an Obj-C FFI
07:18:53 <dankna> it's basically just a lot of work, and I have been able to make progress without it
07:18:59 <earthy> andré pang demoed it back in 2004... it was kinda schweet then...
07:19:14 <dankna> you can just use C wrapper functions and interface that way
07:19:14 <thoughtpolice_> a lot of work and none of it very glamorous, i imagine
07:19:21 <copumpkin> yeah, I've been trying to think of it in a decent way for a while too
07:19:26 <thoughtpolice_> i think we all have
07:19:27 <accel> dankna: These are times in history where we are called to make personal sacrifices for the benefit of the community. :-)
07:19:29 <dankna> it's more duplication of effort, but it works
07:19:29 <copumpkin> dankna: you don't even need to write wrappers if you really want
07:19:31 <dankna> accel: hahaha
07:19:33 <edwardk> 2004 was a long time ago ;)
07:19:33 <thoughtpolice_> didn't we used to all be in #haskell-objc
07:19:33 <thoughtpolice_> ?
07:19:34 <hpc> it's amazing how boring it is to deal with huge APIs
07:19:34 <thoughtpolice_> :)
07:19:34 <dankna> copumpkin: wellllll yeah
07:19:49 <copumpkin> objc_msgSend & co is where the magic happens
07:19:51 <Axman6> not #iHaskell?
07:19:57 <mux> hpc: I guess that's one of the reasons API introspection is becoming more and more popular
07:20:13 <stepcut> if I am using OverloadedStrings and do, show "foo", that works fine. But if I do, class MyShow a where myShow :: a -> String, then, myShow "foo", gives me an Ambiguous type variable error. What magic makes the Show instance work?
07:20:28 <copumpkin> but I'm reluctant to go that way until I can think of a good way to make it pleasant to use
07:20:40 <Saizan> stepcut: defaulting, i guess?
07:21:12 <dankna> anyway, if anyone wants to help with my direct-cocoa binding that would be awesome.  I admit I've lost motivation on it myself :)
07:21:28 <accel> everyone, cheer dankna on
07:21:32 <dankna> haha
07:21:37 <accel> else I will start trolling the channel again
07:21:46 <dankna> accel: but for now what I would do if I were you is write polyglot.  it's simple and it works.
07:22:14 <Axman6> finally, you admit it!
07:22:17 <hpc> or we will talk about confluence all day long!
07:22:18 <Axman6> >_>
07:22:29 <Axman6> hmmm, i wonder if the new XRC protocol could somehow be made to work with haskell
07:22:35 <Cale> I never really understood why people get so picky about the widgets in all their programs looking pixel-perfectly identical to each other.
07:22:43 <dankna> XRC?  is that an IRC replacement that isn't Jabber?  it sucks, then :D
07:22:53 <hpc> jabber sucks :P
07:23:01 <Axman6> could be somewhat of a backdoor into haskell/Obj-C programs
07:23:10 <dankna> Cale: because it's more than that.  it's rules such as "the button that means 'do the thing I meant to do' goes in the bottom-right"
07:23:11 <hvr> hpc: with irssi-xmpp it sucks a little less
07:23:27 <monochrom> the same reason people are so picky about fonts at the subpixel level
07:23:30 <stepcut> Saizan: I have, default (String), in the module.. it doesn't seem to help anything
07:23:38 <maurer_> Anyone know how to grab a specific version of ghc out of git? I don't see any version tags
07:23:38 <Axman6> hmm, maybe it's not called xrc
07:23:58 <kmc> defaulting only applies to Prelude numeric classes
07:24:05 <kmc> and to IsString with the relevant extension
07:24:10 <Saizan> and Show
07:24:23 <Saizan> but i guess Show is part of the numeric classes, somehow
07:24:30 <hpc> in short, type defaulting is a horrid hack
07:24:31 <kmc> sadly yes
07:24:36 <kmc> but yeah, i forgot that one
07:24:39 <hpc> and you should just use a typ annotation
07:24:56 <Saizan> stepcut: so if your constraints involve another class you're screwed
07:25:02 <kmc> defaulting is sad
07:25:11 <stepcut> OverloadedString is really annoying.. because it causes lots of Ambiguous type variable errors .. would be nicer if I could do, StringLitAs <someType>
07:25:24 <kmc> hmm?
07:25:36 * kmc isn't sure how that's different / what you mean
07:25:49 <Saizan> stepcut: ("foo" :: someType) ?
07:25:56 <stepcut> like, StringLitAs Text, and then  all string literals in the module would have types like, "foo" :: Text
07:26:08 <kmc> bah, globally?
07:26:21 <monochrom> that is another case of defaulting
07:26:34 <monochrom> "default Integer, Double, Text"
07:26:53 <kmc> i'll just point out that «pack "foo"» is shorter than «"foo" :: Text»
07:27:05 <stepcut> kmc: yes, but, "foo" is even shorter
07:27:17 <kmc> right, but it doesn't work ;P
07:27:28 <yitz> stepcut: OverloadedStrings is bad in a lot of ways. Write a quasiquoter instead.
07:28:05 <kmc> « [text|foo|] » is not shorter than «pack "foo"»
07:28:11 <kmc> and it's uglier and non-standard
07:28:20 <yitz> kmc: [t|foo] isn't too bad
07:28:33 <dankna> except that [t| is already taken for types, isn't it?
07:28:34 <hpc> that one is actually shorter
07:28:34 <kmc> let t = pack
07:28:35 <yitz> kmc: [t|foo|] isn't too bad
07:28:37 <maurer_> kmc: Sometimes the :: Type is implicit
07:28:38 <stepcut> kmc: but that's what I am suggesting. In plain-old haskell string literals always have the type String. With OverloadedString they have the type (IsString a) => a. But what I want is to instead say that all string literals have some other concrete type, like, Text.
07:29:12 <copumpkin> propose adding that to RebindableSyntax?
07:29:20 <yitz> stepcut: right that would be better. but GHC HQ says no need, quasiquoters are for that.
07:29:24 <kmc> it's not already?
07:29:31 <copumpkin> I don't think so
07:29:43 <stepcut> yitz: oh really?
07:29:58 <kmc> i really don't think «t "foo"» is so onerous
07:30:04 <kmc> this is a non-issue
07:30:17 <yitz> stepcut: i submitted a bug about it once, related to other problems with OverloadedStrings. It's a really bad extension actually.
07:30:23 <kmc> there's no need to throw out portability and add hundreds of lines of code to GHC
07:30:39 <stepcut> portability.. to what ?
07:30:46 <kmc> any other Haskell implementation
07:30:50 <stepcut> hahaha
07:30:54 <hpc> there are other haskell implementations? :P
07:30:57 <dankna> yeah, I'm not too convinced by portability arguments when it's Haskell
07:31:04 <kmc> including future or past versions of GHC that can change the meaning of extensions without warning
07:31:07 <dankna> if you had phrased the argument as non-standard, that would be different
07:31:19 <yitz> kmc: what is that chevron notation you are talking about?
07:31:24 <kmc> « these guys » ?
07:31:28 <hpc> yitz: <<code>>
07:31:32 <kmc> that's just how i quote Haskell source in text
07:31:34 <kmc> (sometimes)
07:31:35 <yitz> oh ok
07:31:35 <hpc> <<code>> not code
07:31:39 <kmc> because «» aren't used in Haskell syntax
07:31:46 <maurer_> kmc: Yet
07:31:47 <maurer_> >_>
07:31:49 <kmc> exactly
07:31:53 <Saizan> they are valid operators though
07:32:04 <kmc> i'm sure GHC will add an extension to let «foo» mean pack "foo"
07:32:07 <kmc> and then i'll be screwed
07:32:17 <maurer_> yitz: The one logical purpose of it is to allow you to use string literals for other string-likes
07:32:24 <maurer_> ByteString is a pretty compelling use case
07:32:35 <kmc> no
07:32:36 <yitz> maurer_: it's broken, don't use it for that
07:32:36 <int-e> kmc: hmm, after we have StringLike now?
07:32:48 <kmc> it's wrong for ByteString
07:32:51 <maurer_> yitz: How is it broken
07:32:54 <maurer_> kmc: Why?
07:32:55 <stepcut> well, at present there is a trend of using Text instead of String in web related libraries. But String gets nice built-in syntax and Text does not. Furthermore, I think Text.pack does not get the same performance benefits as fromString ?
07:32:59 <kmc> because ByteString doesn't hold characters
07:33:01 <int-e> kmc: (i.e., the OverloadedStrings extension)
07:33:01 <kmc> it holds bytes
07:33:12 <maurer_> kmc: THe ability to do BS.append "foo" someBS is useful.
07:33:24 <kmc> maurer_, unsafeCoerce is also sometimes useful
07:33:39 <kmc> it's still wrong
07:33:52 <kmc> as a less hyperbolic example
07:33:54 <maurer_> kmc: Sure, but I don't see how translating character strings to bytestrings, defaulting via UTF-8, is in any way dangerous?
07:33:55 <yitz> maurer_: the problem is that people are now writing instances for all kinds of crazy things.
07:33:59 <kmc> the ability to write (3.5 :: Int) and have it mean 3
07:34:03 <kmc> would also be useful
07:34:05 <kmc> occasionally
07:34:10 <kmc> but we don't have instance Fractional Int
07:34:11 <maurer_> yitz: So the problem is that people are using it as a quasiquoter instead?
07:34:11 <int-e> Hah. the jury is still out on reallyUnsafePtrEquality
07:34:25 <yitz> maurer_: so as soon as you turn on OverloadedStrings, you lose compile-time safety for you program.
07:34:25 <maurer_> kmc: Sure, because ints aren't fractional
07:34:30 <kmc> and bytes aren't characters
07:34:33 <maurer_> yitz: How so?
07:34:34 <quicksil1er> maurer_: the OverloadedString instance for bytestrings doesn't use UTF8 does it?
07:34:35 <kmc> maurer_, it uses UTF-8? i thought it just truncated every codepoint
07:34:44 <kmc> which is roughly like truncating Rational literals to Ints
07:34:46 <quicksil1er> it uses the 'truncate to 8 bits' encoding.
07:34:47 <maurer_> kmc: bytes are characters, some characters aren't bytes, they're multiple bytes
07:34:54 <kmc> no
07:34:57 <yitz> maurer_: you can easily write a string literal that will compile to something that crashes at run time
07:34:59 <maurer_> kmc: I assumed it used UTF-8 expansion, as that seemed the only logical thing
07:35:03 <kmc> ass u me
07:35:25 <kmc> "bytes are characters, some characters aren't bytes, they're multiple bytes" ← this is a totally backwards and regressive way to think about it
07:35:38 <kmc> it's the viewpoint that only makes sense if you're trying to shoehorn Unicode into a 1970's programming language like C
07:35:49 <stepcut> maurer_: that is why it is so bogus.. everyone assumes it does the thing they want :)
07:35:50 <maurer_> kmc: What byte isn't a character?
07:36:02 <kmc> maurer_, what Maybe Int isn't a [Int] ?
07:36:13 <maurer_> stepcut: To be fair, I've never put a unicode character in my haskell program, so I wasn't depending on the behavior
07:36:27 <kmc> maurer_, you've only put unicode characters in your Haskell programs
07:36:33 <kmc> ASCII is a subset of Unicode
07:36:42 <maurer_> kmc: You know what I mean, I've not used any unicode-requiring characters
07:36:47 <yitz> using D.BS.Char8.pack explicitly is a little better, because you are explicitly stating that your intention is bytes of ASCII
07:36:54 <hpc> maurer_: this also doesn't prevent others from passing unicode to your programs
07:37:16 <maurer_> hpc: Other people's unicode doesn't get used by the IsString typeclass
07:37:32 <maurer_> kmc: As far as what Maybe Int isn't a [Int], that's why we've got maurer@caladbolg ~ $ hoogle "Maybe a -> [a]" | head -n 1
07:37:35 <maurer_> Data.Maybe maybeToList :: Maybe a -> [a]
07:37:49 <kmc> and i have no problem with decodeUTF8 :: ByteString -> Text
07:37:55 <kmc> and decodeUTF16LE :: ByteString -> Text
07:37:56 <kmc> etc.
07:37:59 <kmc> there are many of these functions
07:38:03 <hpc> kmc: Maybe Text
07:38:06 <kmc> right
07:38:24 <maurer_> kmc: So, coercion of variables I don't like
07:38:32 <maurer_> But the ability to have a convenient literal syntax is useful
07:38:46 <kmc> maurer_, here in the present day, characters aren't bytes, they're an abstract scalar type like Int
07:38:52 <monochrom> you like coercion of constants?
07:39:05 <yitz> maurer_: so use [t|foo|]. that's a convenient literal syntax.
07:39:12 <maurer_> monochrom: It's not really coercion when you think about it--each constant is still exactly one type.
07:39:32 <maurer_> yitz: That invokes template haskell last I checked?
07:39:34 <kmc> there are several ways to encode a character as bytes (utf-8, utf-16 LE, etc.) just as there are several ways to encode an int as bytes (big-endian vs little-endian, word size, two's complement vs other, etc.)
07:39:49 <maurer_> yitz: Macros are kind of an abomination in my view.
07:39:51 <yitz> maurer_: yes a small corner case of it, quasiquoters.
07:40:01 <kmc> you're all insane for thinking «[t|foo|]» is nicer than «t "foo"»
07:40:04 <kmc> i'm just saying
07:40:11 <mokus> in utf-8 there are bytes that aren't characters - the start bytes for multi-byte sequences
07:40:11 <dankna> I agree with what kmc just said ^^'
07:40:14 <maurer_> yitz: Yeah, I try to not invoke TH... ever...
07:40:19 <mokus> so bytes aren't even a subset of characters
07:40:22 <maurer_> If I were going to do that, I'd do it kmc style.
07:40:28 <mokus> in utf-8 anyway
07:40:30 <dbpatterson> OT, but: since apparently* 50% of haskell users use macs, and most haskell users use emacs, does anyone have a mirror of the emacs-23 dmg? emacsformacosx.org seems to be down, and I can't find one. (* so says eric kow - http://www.mail-archive.com/haskell-cafe@haskell.org/msg92760.html)
07:40:38 <monochrom> I will harp with a Maybe Int vs [Int] again, this time coercion of constant/literal. I write "Nothing". literal there. automatic coercion of that to [Int]?  "Nothing :: [Int]"?
07:40:39 <yitz> kmc: not nicer visually, i agree. but it's explicitly a literal, not a runtime function invocation.
07:40:54 <maurer_> monochrom: That is not a literal, that's a constructor
07:40:54 <copumpkin> @remember maurer I'd do it kmc style
07:40:55 <lambdabot> Okay.
07:40:59 <kmc> oh no
07:41:05 <kmc> 50% really?
07:41:20 <maurer_> dbpatterson: Where are those numbers from?
07:41:24 <yitz> maurer_: i'm also not a TH fan at all. But quasiquoters are just a way to create your own syntax for compile-time literals, which is exactly what you are asking for.
07:41:26 * maurer_ unsure how they could monitor htat.
07:41:39 <monochrom> ok mokus nails it
07:41:55 <maurer_> yitz: No, I'm suggesting that if I'm using a string, I should be able to use a string literal.
07:42:03 <dbpatterson> maurer_: linked to source. anecdotal from the UK hackathon. but the file? anyone? :)
07:42:07 <Saizan> kmc: the figure is from CamHac
07:42:36 <yitz> maurer_: and I'm saying that GHC already allows you to do that. you just need to use a different syntax for the literals.
07:42:40 <maurer_> yitz: Unicode does not have a monopoly on the term.
07:42:53 <maurer_> yitz: The different syntax invokes a goddamn macro system.
07:43:07 <maurer_> In macro systems lies the death of separate, parallelizable compilation.
07:43:17 <maurer_> I know we haven't parallelized ghc --make yet, but I'd like to keep it possible
07:43:22 <kmc> it also involves a nonstandard, incomplete language extension that has changed significantly in recent memory
07:43:37 <kmc> you may all laugh at the idea of using a compiler that isn't GHC, but do note that GHC 7.2 is a compiler that isn't GHC 7.0
07:43:41 <accel> alright, I am willing to give up objective-c
07:43:45 <accel> is there a nice way to bind Java/Haskell?
07:43:46 <yitz> maurer_: quasiquoters are very simple. it won't affect that.
07:43:54 <accel> even Java has decent GUI elements that I am willing to use from haskell
07:44:09 <maurer_> yitz: It will unless you have an intelligent parallelizer. Have you tried doing distributed compilation in C?
07:44:12 <yitz> kmc: in recent weeks even
07:44:18 <kmc> monochrom, i like your example of coercion to [Int]
07:44:25 <maurer_> Unless all systems are identically configured, you have to use what is known as "pump" mode.
07:44:37 <maurer_> This makes a single system the bottleneck in preprocessing
07:44:41 <monochrom> thanks
07:45:04 <maurer_> kmc: I would suggest that example does not hold because Nothing is a constructor, bound by the language.
07:45:07 <kmc> let's argue about the lexical syntax of multi-line comments
07:45:10 <maurer_> kmc: Strings were only convenience syntax to begin with
07:45:24 <maurer_> We could have made it a requirement that you do ['a', 'b']
07:45:39 <yitz> maurer_: obviously you're going to need ghc --make for that, and it will be trivial to support quasiquoters there.
07:47:15 <maurer_> Argh, I got sidetracked from what I came here to ask
07:47:20 <yitz> maurer_: anyway, i'd be perfectly happy if there would be a hard-wired way to make regular string literals be Text. but i'm quite convinced that GHC will never support that.
07:47:28 <maurer_> I'm trying to get ghc to build, but I'm getting a parse error reading bootstrap.conf
07:47:30 <kmc> that would not make me happy
07:47:32 <maurer_> Anyone have an idea how to fix it?
07:48:10 <kmc> it's easy to write a standalone preprocessor that turns "foo" into (pack "foo")
07:48:12 <yitz> maurer_: because SPJ really loves quasiquoters in their current form
07:48:31 <yitz> kmc: there goes your parallel compilation
07:48:34 <monochrom> cabal doesn't take arbitrary preprocessors on the fly
07:48:51 <kmc> yitz, really?
07:49:21 <maurer_> yitz: One that weak could be OK.
07:49:31 <maurer_> yitz: The problem is that TH and CPP and the like have state-related power
07:49:43 <yitz> maurer_: quasiquoters have no such power
07:49:56 <mux> shall we talk about impure preprocessors then? :-)
07:50:02 <maurer_> yitz: Can you turn on quasiquoters without turning on full TH?
07:50:30 <yitz> maurer_: it's a separate pragma now i believe
07:50:55 <dcoutts> monochrom: what are you thinking of re pre-processors?
07:51:11 <monochrom> nothing
07:51:37 <maurer_> yitz: I'm also opposed to preprocessors on the separate grounds that they tend to obfuscate source
07:51:45 <maurer_> This isn't to say I've never used them
07:51:54 <maurer_> But I try to avoid them when possible
07:52:00 <int-e> maurer_: what state are you worried about?
07:52:12 <int-e> (i.e. how does TH affect that state?)
07:52:25 <yitz> maurer_: i agree. i've always avoided them.
07:53:02 <yitz> maurer_: but i wan't to be able to specify Text literals at compile time. quasiquoters is the way to do that in GHC.
07:53:30 <yitz> s/'//
07:54:04 <KirinDave> yitz: Can't you use that one string extension
07:54:16 <yitz> KirinDave: which one?
07:54:20 <KirinDave> yitz: OverloadedStrings
07:54:27 <yitz> KirinDave: that one's the problem
07:54:42 <yitz> KirinDave: it's a runtime extension, effectively.
07:54:45 <Saizan> how much compile time is that? doesn't it still splice to code like Text.pack "foo" ?
07:55:10 <kmc> it could splice to a Text literal, except that there's effectively no such thing
07:55:12 <KirinDave> yitz: Right, but that cost is fixed.
07:55:19 <Saizan> kmc: exactly
07:55:40 <KirinDave> yitz: I mean, how big and how many text literals are we talking about in source code here?
07:55:43 <Saizan> maybe there's something for bytearrays..
07:55:48 <kmc> so the real extension we need is a way to declare byte arrays in the static .data section and get a ForeignPtr to them :)
07:55:50 <monochrom> from the makers of Type Directed Name Resolution: Type Directed Literal Resolution!
07:56:04 <KirinDave> kmc: Yeah, or data files. Like sane people. ;)
07:56:27 <yitz> Saizan: well that would be the easiest way to implement it. but no, not necessarily, you could build your quasiquoter to construct a Text at compile time.
07:56:37 <Saizan> a built-in lift that worked with the in-memory representation would be nice
07:56:40 <KirinDave> yitz: Unless your program is meant to run in a flash or run on restricted-capacity hardware, those conversion costs are minuscule compared to the life of most any program.
07:56:53 <int-e> Oh, is Text still UTF-16?
07:57:04 <Saizan> yitz: but how do you represent that Text in the generated code?
07:57:05 <KirinDave> yitz: If haskell is trying to generate code for motorolla star-tacs, we might have a problem. :)
07:57:15 <yitz> KirinDave: the problem is that you lose control of some of the safety of your program.
07:57:31 <KirinDave> yitz: Howso?
07:57:33 <yitz> KirinDave: right i'm not worried about it for efficiency reasons
07:58:15 <yitz> KirinDave: once you turn on that extension, any string literal in your program could theoretically cause a runtime crash if you got the type wrong.
07:58:39 <int-e> @type "123"#
07:58:40 <lambdabot> GHC.Prim.Addr#
07:59:03 <KirinDave> yitz: So, poorly written or malicious instances of IsString, or is there something more fundamental?
07:59:39 <kmc> Text uses UTF-16 internally, yeah
07:59:57 <kmc> int-e, :O
08:00:01 <kmc> @type "hello world"#
08:00:02 <lambdabot> GHC.Prim.Addr#
08:00:03 <yitz> KirinDave: case in point: the Name type in xml-types has an IsString instance. certain strings that are not well-formed names for XML will crash at runtime, not compile time.
08:00:05 <kmc> holy shit
08:00:13 <kmc> where is that used?
08:00:28 <KirinDave> yitz: That seems more like a misapplication of IsString to me. But I see your point.
08:00:32 <quicksil1er> I don't
08:00:33 <int-e> kmc: to implement string literals. They are unpackSomething "..."#
08:00:52 <yitz> KirinDave: I begged the author on my knees to get rid of that, but he refuses
08:00:57 <quicksil1er> it's no different from
08:01:03 <quicksil1er> (mkName "foo") crashing at runtime
08:01:06 <KirinDave> yitz: I dunno if qq is the solution.
08:01:52 <yitz> quicksil1er: ?
08:02:02 <KirinDave> yitz: I don't mean to overstate my feelings with hyperbole, but I can't help myself. I am quite unimpressed with quasi quoting as implemented in haskell.
08:02:07 <yitz> quicksil1er: btw what happened to your
08:02:08 <yitz> v
08:02:10 <int-e> kmc: I learned that from bytestring. they have a rule that turns  pack (unpackCString# s)  into  inlinePerformIO (B.unsafePackAddress s)
08:02:11 <yitz> ?
08:02:16 <KirinDave> yitz: It's ugly, it's awkward, it's no fun to write.
08:02:20 <quicksil1er> freenode took it and won't give it back
08:02:32 <yitz> @slap freenode
08:02:32 * lambdabot places her fist firmly on freenode's jaw
08:02:45 <quicksil1er> I don't see why ("foo" :: Name) being a runtime error is inherently worse than (mkName "foo") being a runtime error
08:03:07 <quicksil1er> or, for that matter, (head . tail . tail . tail . tail $ "foo")
08:03:37 <monochrom> perhaps because you look at the syntax ("foo" :: Name) like (5 :: CReal) and don't expect a runtime error
08:04:05 <int-e> Right. It might not be inherently worse, but it wouldn't be Haskell.
08:04:24 <quicksil1er> (5 :: Blah) could certainly be a runtime error
08:04:30 <quicksil1er> and that's definitely haskell.
08:04:35 <yitz> quicksil1er: an IsString instance should just be coercing something that already Is a String. if it's doing head . tail . tail than it's wrong.
08:04:36 <quicksil1er> custom Num types are permitted by haskell98
08:05:13 <quicksil1er> yitz: I don't really like IsString at all :) But I don't particularly agree with your objection, or at least the bit you are emphasising.
08:05:16 <yitz> quicksil1er: yeah Num has always had the same problem. but somehow for Num that's more of corner case.
08:05:28 <int-e> quicksil1er: Well, it would still be an error of type Blah. :P
08:05:35 <yitz> quicksil1er: why don't you like it?
08:05:56 <quicksil1er> yitz: it feels like a nasty hack and encourages abuses like the once being discussed
08:06:06 <yitz> yeah
08:06:08 <KirinDave> yitz: Well, if we do decided IsString enters CH status, could we fix the horrible qq syntax so we have a more beautiful replacement?
08:06:33 <KirinDave> Opening up quasi-quotes is sort of like drawing a fat man wearing a tube top. It's just really unattractive as syntax goes.
08:07:05 <yitz> KirinDave: i don't think it's quite so bad. not as nice as regular quotes of course.
08:07:24 <stepcut> there is a GSoC project to convert Text to UTF-8 (after proving that switching to UTF-8 would actually be an improvement)
08:07:31 <KirinDave> yitz: Really?
08:07:57 <Saizan> we could extend the ' from identifiers to whole expressions
08:08:00 <KirinDave> yitz: We're taking about the [$thing| … ] syntax here?
08:08:26 <Saizan> not easy to put the quoter name there though
08:08:41 <yitz> stepcut: the conclusion was that in general it's not that much of an improvement. in certain cases it is a big improvement, and for that the GSoC work is available as a library.
08:09:07 <yitz> KirinDave: without the $
08:09:29 <KirinDave> yitz: Okay, but still
08:09:35 <yitz> KirinDave: [text|foo|] or [t|foo] or whatever
08:09:53 <yitz> [t|foo\]
08:09:55 <yitz> ach
08:10:02 <yitz> [t|foo|]
08:10:09 <yitz> KirinDave: hard to type :)
08:10:11 <KirinDave> Yeah I typo'd it too. And then Lion came along and ate the evidence.
08:10:17 <KirinDave> yitz: Yes. There is that, isn't there. :)
08:10:31 <stepcut> should we remove support for String having special syntax and have it use quasi-quotes as well?
08:10:36 <KirinDave> Why oh why did I upgrade. I'm still without a working Haskell on my desktop.
08:10:49 <yitz> KirinDave: well once it takes over the world keyboards will be built to make it easier to type :)
08:11:16 <KirinDave> yitz: Hah. <<Insert obligatory and unfair APL joke here>>
08:11:27 <Saizan> [t|foo|] is taken for regular quoting of types though
08:11:31 <yitz> KirinDave: yeah i'm still pushing it off. my problem is that i have a 2007 white MacBook. I'm afraid it will grind to a halt.
08:11:52 <KirinDave> yitz: It will actually do better.
08:11:53 <KirinDave> yitz: But
08:11:59 <yitz> Saizan: oh right. ok [x|foo|] there i typed it!
08:12:11 <KirinDave> yitz: Lion is atrocious and also makes haskell 7.0* suffer terribly
08:12:24 <Cale> http://www.haskell.org/haskellwiki/Wadlers_Law
08:12:43 <KirinDave> yitz: I'm super disappointed with Lion. I mean, really really really disappointed. A lot of things are just.. they're so much worse.
08:12:43 <yitz> KirinDave: don't even say it. the fanbois are already downvoting you in every forum
08:13:05 <KirinDave> yitz: But they fixed some incredibly tedious bugs (like how spaces and multiple monitors interact) so it's hard to go back
08:13:13 <KirinDave> And the terminal.app is actually really great now.
08:13:17 <KirinDave> So...
08:13:18 <maurer_> What did Lion do that broke GHC anyways?
08:13:42 <KirinDave> maurer_: The same thing it does every 2 versions, completely rearrange all its binaries and go with a custom build of a compiler.
08:13:48 <yitz> KirinDave: i just switched from iTerm which doesn't appear to be supported anymore. Terminal in SL isn't as good, but it's usable.
08:14:02 <KirinDave> iTerm is still active
08:14:04 <KirinDave> Err, it's iTerm2
08:14:09 <KirinDave> I get updates nearly every day
08:14:13 * hackagebot samtools 0.1.3 - Binding to the C samtools library  http://hackage.haskell.org/package/samtools-0.1.3 (NicholasIngolia)
08:14:15 <KirinDave> I use iTerm2 for some things still.
08:14:36 <yitz> KirinDave: oh yeah? i looked around and didn't find that. maybe i should go back.
08:14:37 <KirinDave> I've just been drifting back to my roots to avoid how awful lion's ux is.
08:14:43 <KirinDave> Like, I use tmux and emacs -nw now.
08:14:48 <yitz> haha
08:14:49 <Cale> Just install linux
08:14:57 <Cale> You'll save a lot of trouble
08:14:59 <Cale> lol
08:15:00 <KirinDave> Cale: I'm considering. But ...
08:15:05 <yitz> KirinDave: have you ever used teco?
08:15:09 <KirinDave> yitz: Yes.
08:15:29 <yitz> KirinDave: it worked great on the pdp-11
08:15:32 <KirinDave> yitz: I may not look it or sound it, but I actually used to really love being a console rat.
08:17:47 <yitz> KirinDave: Lion is the beginning of a long and painful transition to doing software development on some future iPad-like thing. it's not going to be pretty.
08:18:15 <stepcut> lion and final cut X are not making me happy
08:18:17 <KirinDave> yitz: I'm considering just having a medium-sized ec2 instance I call out to. Even my chrome book can handle that
08:18:49 <yitz> KirinDave: yeah you can even use that on an unjailbroken iphone
08:19:34 <Cale> I actually really don't understand any of Apple's UI design anymore. Back in the 80's they were doing things which made sense. Now they're doing some blend of cargo culting their own old designs without considering the rationale behind them, and doing new things which look shiny and are impressive for 20 or 30 seconds, but make very little sense.
08:19:57 <KirinDave> cale: On the desktop os side, I agree.
08:20:16 <KirinDave> cale: Everyone is struggling on the tablet side, there is just so much that's new.
08:20:22 <KirinDave> But… I really don't understand Lion.
08:20:27 <yitz> Cale: they are transitioning from trying to win by being the best to protecting their new monopoly
08:20:43 <KirinDave> What's worst about it from my perspective is that Apple is doing really cool stuff in their platform layers.
08:20:53 <KirinDave> e.g., a strong dedication to LLVM
08:21:05 <KirinDave> Slowly switching from applescript to macruby
08:22:05 <mux> type-based dependencies sounds like duck typing for modules
08:22:15 <mux> cf mmmodularity
08:24:39 <dankna> massively multiplayer online modularity?
08:24:48 <mux> http://skilpat.tumblr.com/post/9411500320/a-modular-package-language-for-haskell
08:24:51 <yitz> mux: it sounds like there's a lot of potential there, but i'm worried that it's not addressing the most serious issues with cabal, and it will make it even more complicated to solve them.
08:25:23 <NemesisD> whats the least painful to use regex library?
08:25:33 <yitz> NemesisD: parsec
08:25:37 <dcoutts> yitz: oh I think it's all pretty good. I spent a day with them a couple months ago helping them to understand the needs of cabal.
08:25:58 <yitz> dcoutts: good to hear. i'm still worried though.
08:26:03 <mux> yitz: I'm a bit disappointed in that it seems to go the other way than SPJ's paper about packages where he was rooting for unifying module languages and main language, unlike in mmmoudlarity
08:26:03 <dcoutts> :-)
08:26:05 <NemesisD> yitz: really? you can use that to do regex matching?
08:26:30 <KirinDave> NemesisD: Sorta. If you don't want to actually use regexs
08:26:36 <dcoutts> mux: they don't feel they can go in an change the module language, which is fair enough.
08:26:40 <NemesisD> i really only need it to read standard (pcre?) regex from string and a bool as to whether or not a string (or preferably text) matches
08:26:59 <dcoutts> mux: they feel too much like outsiders to do that, so starting with something that might be implementable
08:27:12 <mux> dcoutts: fair enough indeed
08:27:13 <NemesisD> KirinDave: i intend to read regex patterns from the CLI and match Data.Text strings in a file against that
08:27:19 <Silvah> I think that regexes are frowned upon in Haskell community.
08:27:37 <NemesisD> its the format that makes sense for the application
08:27:46 <KirinDave> NemesisD: No need to justify it
08:27:57 <dcoutts> yitz: so what's your worry then?
08:28:01 <KirinDave> NemesisD: I dunno about the "most painless"
08:28:18 <KirinDave> NemesisD: But certainly the most documentation exists for Text-Regex and its children.
08:28:29 <NemesisD> KirinDave: easiest to use for this simple case, least obtuse documentation/api
08:29:11 <KirinDave> NemesisD: If you need perl-style regexs, you get an ffi interface to pcre. No one even tries there. It's just too much effort to write.
08:30:07 <mux> dcoutts: I do hope they intend on keeping version-based dependencies too? it's not like we type-based dependencies are sufficient
08:30:19 <mux> well, it's sufficient to be able to compile
08:30:26 <mux> but the behaviour might still be wrong
08:30:37 <dcoutts> mux: right, one is used to inform the other, at least that's what we were discussing a couple months ago
08:30:43 <mux> cool
08:31:07 <dcoutts> in any case we need to produce version ranges simply for export to other packaging formats
08:31:18 <Cale> NemesisD: There's the regex-pcre package
08:31:22 <dcoutts> so we'd have it even if it were to be derived information, rather than canonical
08:31:47 <yitz> dcoutts: we'll still need versioning, dependency solving, etc. for large systems that becomes really complex. this will make it even more complex.
08:31:48 <mux> this is competely off-topic, but I'm a bit worried: python is starting to grow on me
08:32:13 <dcoutts> yitz: if it translates into version ranges then it's not adding complexity
08:32:28 <dcoutts> yitz: we already need (and are working on) a better constraint solver
08:33:02 <mux> 3-SAT solvers for Cabal!
08:33:15 <yitz> dcoutts: i guess what i'm worried about is having another automated layer over the version numbers. a highly non-trivial one at that.
08:33:24 <dcoutts> mux: everyone suggests that, but I don't think it's a good approach
08:33:29 <dcoutts> mux: because of error messages
08:33:38 <mux> dcoutts: I wasn't being serious, but that's a very good point indeed
08:34:01 <dcoutts> mux: well on the face of it it's actually a perfectly sensible suggestion
08:34:22 <yitz> dcoutts: over time i have developed a whole library of shell scripts to manage the version numbers. stepping back, it's beginning to look as if i am gradually re-inventing cvs.
08:34:35 <dcoutts> yitz: heh
08:34:48 <mux> dcoutts: sounds a bit like over-engineering though, doesn't it? I don't know enough about that kind of stuff to tell
08:34:54 <dcoutts> yitz: might be interesting to blog about that, I'm sure we could all do with better tools for that
08:35:22 <dcoutts> mux: not really, custom solvers are hard, if you can just throw it at SAT then that's great.
08:35:51 <yitz> dcoutts: yeah that's on my list. still under crushing black-hole-level deadline pressure though. hope to get up for air soon.
08:36:08 <dcoutts> mux: in the end we've written a custom solver :-)  it collects lots of domain-specific info and applies heuristics, all so it has reasonable info to use to present error messages.
08:36:23 <dcoutts> yitz: know the feeling, good luck
08:36:33 <yitz> dcoutts: thanks!
08:38:24 <NemesisD> i hear good things about regex-tdfa
08:42:20 <Cale> NemesisD: Well, they all have the same ridiculously-polymorphic interface, so you should be able to switch between them easily enough.
08:42:50 <Cale> It's literally more polymorphic than perl.
08:43:07 <mux> heh, ridiculously polymorphic, true that
08:43:27 <mux> the regex-* packages type-classes are ungodly generic
08:43:52 <mux> it makes it a bit hard to browse the source, I found
08:43:53 <NemesisD> the docs sure are noobie unfriendly
08:44:04 <mux> but regex-tdfa works really fine and the maintainer is quite responsive
08:44:27 <mux> I found a small corner case bug some time ago, and he fixed it in a few days
08:56:44 <co_dh> greeting. is that true that a Field in abstract algebra just 2 groups, one of them abelian, and with a distribution of * over + ?
08:57:21 <copumpkin> commutative
08:57:39 <quicksil1er> and one of them excluding one element
08:57:48 <copumpkin> oh yeah
08:57:53 <edwardk> yeah you need both groups to be commutative or you just have a skew field/division ring
08:57:53 <copumpkin> quicksil1er: what's with the new nick?
08:58:05 <quicksil1er> copumpkin: freenode won't let me have my V back
08:58:10 <copumpkin> why not?!?
08:58:11 <quicksil1er> copumpkin: I think there has been some kind of V shortage
08:58:17 <copumpkin> you should complain
08:58:29 <quicksil1er> 11:00 [freenode] -!- quicksilver ##OpenGL Cannot change nickname while banned on channel
08:58:32 <quicksilwer> nah, it's a problem
08:58:41 <quicksilwer> I got two of them here
08:58:49 <co_dh> ok, 2 commutative group with distribution, with 0 exclude from * .
08:58:55 <quicksilwer> quicksil1er: why not just /part, /nick, and /join ?
08:58:55 <edwardk> what'd you do to antagonize the ##opengl folks?
08:59:06 <quicksil1er> edwardk: I'm not bannned there, though. As far as I can see
08:59:27 <quicksilwer> quicksil1er: yeah, they often "ban" unidentified people
08:59:28 <quicksil1er> quicksilwer: can't be bothered. I did badger a freenode op I kno wbut he wasn't around and... more important things to do.
08:59:41 <quicksilwer> but part->nick->join works fine
08:59:43 <co_dh> is that a field a 2 category ? of one object.
09:00:00 <quicksil1er> co_dh: although there are laws about how 0 and * work together.
09:00:11 <quicksil1er> (or is that derivable from distribution, perhaps)
09:00:13 <co_dh> quicksil1er:  thanks.
09:00:30 <quicksil1er> (a * x) + (-a * x) = 0 * x by definition
09:00:40 <quicksil1er> you need to know that - passes through * though.
09:02:00 <edwardk> co_dh: we usually build rings and fields as a category where the hom-sets are Ab-enriched. so its just a 1-category with more structure on the arrows (so you can add arrows)
09:02:26 <edwardk> but yes, one object
09:03:02 <quicksil1er> I think you need *either* a rule about how - and * interact, or one about how 0 and * interact.
09:03:09 <quicksil1er> I'm sure there are lots of ways to axiomatise fields.
09:03:23 <edwardk> you can go up to 2-categories and categorify them i suppose
09:03:50 <edwardk> quicksil1er: derivable. you just need cancellative zero
09:04:27 <edwardk> but that follows from the distributive laws
09:05:27 <edwardk> i find it easier to just start down with a couple of semigroups and then add the distributive laws because then you find that as you add identities they all do the right thing
09:05:50 <edwardk> and no additional axiomatization need be applied
09:12:34 <erus`> google docs new look is very bland...
09:18:42 <telephone_> I want to sign in to haskellers, and I there is an option OpenID. I have a profile in stackoverflow, can I use that? I don't know how OpenID works...
09:26:10 <roconnor> I think the Netherlands has had Functional Programmin dag for quite some time now...
09:27:07 <joe6> i have a cabal module with a dir "src/Test/<more.hs>" files. Is there anyway that I can make "src/Test.hs" to automatically import all the modules(.hs) files in the "src/Test/*.hs" dir?
09:27:24 <Cale> Rings are monoid objects in (Ab,(x),Z)  :)
09:27:25 <joe6> i am exposing only the Test module
09:28:10 <joe6> i can list all the modules in the Test dir, but I am wondering if there is a way of doing it automatically?
09:28:26 <yitz> telephone_: you needed to use some openid server to log in to SO. Use the same one to log in to haskellers.
09:28:39 <Lemmih> joe6: Nope.
09:28:52 <joe6> oh, ok...
09:28:56 <joe6> Lemmih: thanks.
09:30:42 <adrake_> is there a standard library function for "apply this function <n> times to some value", like iterate but only the nth element?
09:30:53 <roconnor> adrake_: nope
09:30:55 <adrake_> I have (!! n) . iterate f, but that seems wrong
09:30:57 <yitz> telephone_: on SO, hover over your name, and select logout. it doesn't log out right away, and it does show you what openid server you used to create your SO account.
09:31:04 <adrake_> aw. alright, I'll do that then
09:31:15 <roconnor> adrake_: I don't have much of a better solution.
09:32:06 <rwbarton> foldr (.) id (replicate n f) is an alternative but doesn't seem any better really
09:33:43 <telephone_> yitz: thank you, I found that I was using myOpenID on stackoverflow!
09:34:21 <yitz> telephone_: that'll do it :)
09:35:37 <yitz> @src iterate
09:35:38 <lambdabot> iterate f x =  x : iterate f (f x)
09:40:02 <yitz> @type iterate
09:40:03 <lambdabot> forall a. (a -> a) -> a -> [a]
09:40:17 <yitz> @type flip (scanr id) . repeat
09:40:18 <lambdabot> forall b. (b -> b) -> b -> [b]
09:40:48 <roconnor> rwbarton: ya I thought of the same, but it doesn't really seem better.
09:41:01 <roconnor> maybe it is even worse
09:41:09 <rwbarton> probably
09:41:31 <roconnor> actually I was thinking of flip (foldr ($)) (replicate n f)
09:41:40 <roconnor> which is a little different operationally.
09:42:11 <roconnor> I think
09:42:13 <roconnor> I'm not sure
09:42:14 <yitz> roconnor: isn't that what i just wrote above, more or less?
09:42:38 <roconnor> yitz: ya maybe
09:42:51 <roconnor> > flip (foldr ($)) [f g h] x
09:42:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:42:52 <lambdabot>    `GHC.Show.Show a'
09:42:52 <lambdabot>      a...
09:42:58 <roconnor> > flip (foldr ($)) [f, g, h] x
09:43:03 <lambdabot>   mueval-core: Time limit exceeded
09:43:09 <roconnor> ?
09:43:23 <roconnor> > foldr (.) id [f g h] x
09:43:24 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:43:24 <lambdabot>    `GHC.Show.Show a'
09:43:24 <lambdabot>      a...
09:43:26 <stelleg> :t flip
09:43:26 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
09:43:28 <roconnor> > foldr (.) id [f, g, h] x
09:43:35 <lambdabot>   mueval: ExitFailure 1
09:43:35 <lambdabot>  mueval-core: Time limit exceeded
09:43:39 <roconnor> @undef
09:43:42 <roconnor> > foldr (.) id [f, g, h] x
09:43:45 <lambdabot>   f (g (h x))
09:43:50 <roconnor> > flip (foldr ($)) [f, g, h] x
09:43:52 <lambdabot>   f (g (h x))
09:43:57 <roconnor> oh good it is the same
09:44:05 <roconnor> I thought it might come out in different orders
09:44:12 <yitz> @hoogle flip
09:44:13 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
09:44:13 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
09:44:29 <KirinDave> Gotta love flip
09:44:47 <yitz> stelleg: that's the real type, lambdabot has something weird.
09:45:39 <rwbarton> :t flip . flip
09:45:40 <lambdabot> forall a b a1. (a -> a1 -> b) -> a -> a1 -> b
09:46:54 <yitz> @unpl flip . flip
09:46:55 <lambdabot> (\ i b c -> i b c)
09:47:52 <tomberek> adrake_ I find myself looking for a similar function all the time. Recently i needed a monadic version of it as well.
09:48:44 <roconnor> @hoogle iterateM
09:48:44 <lambdabot> No results found
09:48:51 <stelleg> yitz: thanks
09:48:53 <yitz> @type flip flip
09:48:54 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
09:48:58 <yitz> @type flip flip flip
09:48:59 <lambdabot> forall (f :: * -> *) b (f1 :: * -> *) a b1. (Functor f, Functor f1) => f ((f1 (a -> b1) -> a -> f1 b1) -> b) -> f b
09:49:03 <yitz> @type flip flip flip flip
09:49:05 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
09:49:13 <roconnor> @type Prelude.flip Prelude.flip
09:49:13 <yitz> @type flip flip flip flip flip
09:49:14 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
09:49:14 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
09:49:40 <yitz> stabilizes after four applications
09:50:01 <roconnor> what a worthless combinator
09:50:23 <Silvah> Now apply something to it.
09:50:33 <yitz> roconnor: indeed. same for (.); it starts repeating itself after 10 applications.
09:50:41 <roconnor> lame
09:51:09 <rwbarton> @type (.) (.) (.) (.) (.) (.) (.) (.) (.) (.)
09:51:11 <lambdabot> forall a b (f :: * -> *) a1 (f1 :: * -> *). (Functor f1, Functor f) => (a1 -> a -> b) -> f1 a1 -> f1 (f a -> f b)
09:51:12 <Silvah> @type (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
09:51:14 <lambdabot> forall a b (f :: * -> *) a1 (f1 :: * -> *). (Functor f1, Functor f) => (a1 -> a -> b) -> f1 a1 -> f1 (f a -> f b)
09:51:21 <Silvah> @type (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
09:51:22 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f1, Functor f, Functor f2) => f1 (a -> b) -> f1 (f (f2 a) -> f (f2 b))
09:51:35 <Silvah> type (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
09:51:38 <rwbarton> oh you mean the real (.)?
09:51:47 <rwbarton> since (.) = fmap has interesting behavior I think
09:52:08 <yitz> rwbarton: either one. 10 applications is the same as 6, then it cycles every 4.
09:52:55 <Silvah> Ah, this is what you mean.
09:53:45 <yitz> there must be some interesting interpretation of that in category theory.
10:02:37 <nomeata> Hi. Where can I find the code that builds the packages uploaded to hackage (e.g. creates the build log and the documentation). http://code.haskell.org/~ross/hackage-scripts/ does not seem to contain that part.
10:04:36 <yitz> nomeata: cabal builds the haddocks automatically, doesn't it? then it's a matter of creating the links to it on the package page.
10:05:06 <nomeata> yitz: but still, who/what runs cabal on hackage.h.o?
10:06:23 <yitz> nomeata: yeah, not sure about that. maybe email ross. everyone's busy with hackage2 now, he may be the only one who remembers how hackage1 works :)
10:06:39 <maurer_> yitz: Does hackage2 go yet?
10:07:07 <nomeata> yitz: or maybe you know what I really want to find out: Why does haddock list type class instances in the docs on hackage, but not here on my local machine?
10:07:27 <yitz> maurer_: there was some significant progress lately - camhac or phihac or something. doesn't sound completely done yet though.
10:07:37 <maurer_> yitz: OK
10:07:52 * maurer_ has used yackage occasionally, but would like a more proper one.
10:07:54 <yitz> nomeata: hmm, that's weird.
10:08:47 <nomeata> yitz: and I was hoping for some insight, maybe a flag or somethin
10:09:00 <copumpkin> maurer_: how would the combined structure work?
10:09:26 <copumpkin> I would need an IntMap (IntMap x), I'd think?
10:09:34 <copumpkin> not just a pair of them
10:09:36 <yitz> maurer_: yeah yackage is great for a simple local archive without an interface. hackage2 will be nice for an actual viewable local repository, and for hackage mirrors.
10:09:47 <maurer_> copumpkin: So, a combined structure would go, but would be slower
10:10:10 <copumpkin> maurer_: yeah, definitely, but I don't think a pair would work :)
10:10:13 <maurer_> copumpkin: I was more thinking along the lines of arranging to have a psuedo Word64 with bitops defined such that its Data.Bits just used dual registers
10:10:14 <copumpkin> unless I'm just not clever enough
10:10:15 <nomeata> ghci :i tells me just fine about the instances.
10:10:19 <yitz> nomeata: sounds like haddock can't find the instances.
10:11:15 <maurer_> copumpkin: I think we just accidentally did cross-channel
10:11:24 <yitz> nomeata: did you build haddocks (the regular cabal way) for all of the modules containing those instances?
10:11:29 <copumpkin> I moved on purpose :P didn't think #ghc wanted to know
10:11:35 <maurer_> Yeah :)
10:11:52 <maurer_> copumpkin: But my basic idea was that you construct an unboxed datatype which knows how to do bitops over it
10:12:05 <maurer_> You might even get this if you just did IntMap's logic over a Word64
10:12:07 <nomeata> yitz: besides the base libraries that come with ghc, yes
10:12:16 <maurer_> Though I don't know what happens if you ask for a Word64# on a 32-bit platform
10:12:30 <copumpkin> Word64# only exists on a 32-bit platform, iirc
10:12:55 <yitz> nomeata: are you using the same version of cabal and haddock that hackage is?
10:13:26 <maurer_> copumpkin: ? Do you mean only exists on a 64-bit platform?
10:13:27 <nomeata> yitz: not entirely, but it has been a long-standing problem
10:13:49 <maurer_> (Basically what you really want to make this work fast is Word64# on a 32-bit platform
10:13:51 <nomeata> yitz: I’m using ghc 7.0.4 and the bundled haddock
10:13:58 <copumpkin> maurer_: I mean on a 64-bit platform, they just call it Word#. Word64# exists only because Word# is 32 bits on a 32-bit platform
10:14:08 <copumpkin> it's a mess
10:14:09 <maurer_> copumpkin: OK, sure.
10:14:12 <maurer_> In that case we're good, right?
10:14:17 <yitz> nomeata: that's beyond what hackage has. perhaps it's some kind of regression.
10:14:21 <maurer_> Just use a Word64# everywhere they used an Int
10:14:26 <maurer_> And you should be good to go
10:14:30 <maurer_> (in their IntMap)
10:14:36 <copumpkin> maurer_: well, I don't think Word64# (the type) even exists on a 64-bit build
10:14:40 <copumpkin> which makes me feel gross
10:14:53 <copumpkin> I may be wrong though
10:14:58 <copumpkin> but yeah, sure
10:15:00 <nomeata> yitz: do your locally built library docs contain instance information, then?
10:15:03 <copumpkin> I can change their code
10:15:08 <maurer_> lemme check
10:15:08 <maurer_> I run 64-bit
10:15:14 <yitz> copumpkin: hey, there's a new way to detect whether you're on a 64-bit build :)
10:15:15 <copumpkin> but it'd be nice if it wasn't twice as large
10:15:23 <copumpkin> so a data family would be nicer
10:16:21 <maurer_> copumpkin: ?
10:16:44 <maurer_> copumpkin: So, if you wanted to make this improvement, what I'd reccomend would be to polymorphize their code over Data.Bits
10:16:46 <copumpkin> using Word64# everywhere would make the IntMap spine twice as large
10:17:03 <copumpkin> people would reject that for being slow
10:17:13 <copumpkin> a data family would probably be the best bet
10:17:27 <maurer_> data family? I don't see how that helps
10:17:51 <copumpkin> same way Vector does it
10:18:18 <copumpkin> data family BitTrie a b
10:18:33 <copumpkin> data instance BitTrie Word32 b = Word32 (all sorts of unboxed nastiness here)
10:18:57 <copumpkin> you'd have an associated typeclass, but it'd give you unboxed data types for each
10:19:02 <nomeata> Or someone else: Can you check if your locally built haddock documentation contain instance information, and if so, what version of ghc/haddock you are using, and if you are using Debian’s ghc (which seems to be affected by http://bugs.debian.org/609445)?
10:19:04 <copumpkin> you can't specialize data types otherwise
10:19:05 <maurer_> Oh, OK
10:19:15 <maurer_> I misunderstood your complaint
10:20:01 <yitz> nomeata: yes
10:22:42 <yitz> nomeata: i have HP on Mac OS X, and the generic 7.0.2 tarball on Ubuntu + HP from the web site. both work fine.
10:32:44 <nomeata> yitz: ok, thx
10:37:46 <watchedman> hi all
10:37:50 <watchedman> I am soon going to start building a MMOG. I am considering several programming languages. Would Haskell be a place to look for stuff like AI just for dialogue and behavior of non-player actors?
10:38:29 <ion> yes
10:38:31 <kmc> it's a fine language for writing that
10:38:39 <kmc> i don't know of any specific library for that purpose
10:38:44 <kmc> but it's a good, general-purpose programming language
10:40:32 <joe6> is there any way I can set the "Exposed-Modules:" of the .cabal dir to include all the .hs files in a directory?
10:47:31 <monochrom> I believe no
10:51:39 <maurer_> joe6: Besides, if you are writing a library, you should be making a conscious decision about which modules to export
10:52:00 <greenland> newbie question: does cabal, like, yaknow... work? seems stuck in a loop asking to update cabal-install, and seems that 90% of anything i want to build fails. using haskell-platform on natty
10:52:25 <benmachine> greenland: cabal is a bit temperamental in my experience
10:52:26 <maurer_> greenland: It normally works, what errors are you seeing?
10:52:36 <benmachine> it works for me, but I've been using it for long enough that I know how not to upset it :)
10:52:50 <greenland> ExitFailure 1
10:52:56 <greenland> very informative
10:53:00 <maurer_> greenland: What error messoge though?
10:53:05 <maurer_> pastebin the output if you can't find it
10:54:51 <greenland> "constraint is no smaller than the instance head in the constraint" a few times for yesod... and something else random for anything else, apparently.
10:55:26 <benmachine> yesod doesn't build on ghc-7.2, it seems
10:55:46 <benmachine> maybe it deoesn't build on earlier versions either
10:56:06 <benmachine> apparently it was updated yesterday :o
10:56:06 <greenland> is there a way to constrain the database to things that will compile? or, specify the version of ghc to use?
10:56:28 <thoughtpolice_> say 'cabal install <pkg> -w <path to ghc>' if you want to use a specific GHC
10:56:34 <benmachine> greenland: not really -- how could we tell in advance what will compile where?
10:56:39 <greenland> thoughtpolice: neato
10:57:05 <greenland> apt does it... must be the super cow powers.
10:57:22 <thoughtpolice_> e.g. 7.2.1 is the default on my debian machine, but i also have 7.0.4, so for 7.0.4 i just have to say 'cabal install -w ghc-7.0.4 foo' - i've been doing this a lot since some stuff hasn't been updated for 7.2 yet
10:57:30 <thoughtpolice_> :P
10:58:03 <benmachine> greenland: if you want a bit of reading material, you could try http://www.vex.net/~trebla/haskell/sicp.xhtml
10:59:08 <greenland> bookmarked; up to my nose in lyahfgg
10:59:17 * hackagebot xhtml 3000.2.0.2 - An XHTML combinator library  http://hackage.haskell.org/package/xhtml-3000.2.0.2 (ChrisDornan)
10:59:49 <maurer_> benmachine: Actually, we do have such information in the database, we just aren't using it >_>
11:00:08 <maurer_> benmachine: e.g. hackage has data on what ghcs it built successfully against
11:00:25 <benmachine> maurer_: more than what's displayed on the page?
11:00:50 <maurer_> benmachine: I don't know that it's more than what's on the page
11:01:03 <maurer_> but what's on the page frequently has compiler data
11:01:05 <benmachine> yesod has Build failure ghc-7.2 (log)
11:01:17 <benmachine> but no Built on for other versions
11:01:37 <maurer_> benmachine: Sure, but Build failure is enough to say "hm, running 7.2? Probably won't work"
11:01:47 <maurer_> benmachine: Essentially blacklist rather than whitelist
11:02:03 <benmachine> maurer_: mm
11:02:04 <maurer_> greenland: The real answer everyone's neglecting to give you:
11:02:20 <maurer_> If you're a noob, you should be running the latest Haskell Platform, which does not include 7.2 yet.
11:02:29 <benmachine> he is :P
11:02:32 <benmachine> *they are
11:02:39 <maurer_> Things should "just work" in Haskell Paltform" land
11:02:50 <benmachine> well sure, until you want something that isn't in the platform
11:03:02 <maurer_> benmachine: Not true?
11:03:05 <thoughtpolice_> maurer_: hackage has data in the sense it knows 'yes this failed or it did not' but it does not classify those failures in any meaningful way, making it kinda useless
11:03:08 <maurer_> cabal-install still works well for platform
11:03:13 <benmachine> thoughtpolice_: there are logs
11:03:25 <thoughtpolice_> yes, it still does not *do* anything with those logs or classify those failures in any way
11:03:33 <benmachine> it shows them to you?
11:03:34 <maurer_> thoughtpolice_: There are logs for debugging, and for the purposes of someone using cabal-install, if you already know the build fails...
11:03:36 <dmos> If I want to short circuit multiple calls to '-> Maybe a' functions, but short circuit on Just a instead of Nothing, how do I do that? (ie. not a cascaded lookup, but the first success of alternatives). Thx
11:03:48 <thoughtpolice_> did this fail because you didn't have a needed C library header? or because the haddocks failed to build? hackage doesn't really seem to distinguish them at least
11:03:54 <benmachine> maurer_: having the platform doesn't make you any more likely to install yesod properly :P
11:04:17 <benmachine> dmos: "msum" perhaps
11:04:18 <thoughtpolice_> i think the inevitably plan is to have hackage 2.0 invert this and have users instead send build reports to the hackage server, and the server can instead have a matrix of platform/GHC combinations for which it works
11:04:31 <benmachine> or hmm
11:04:36 <benmachine> :t result
11:04:37 <lambdabot> Not in scope: `result'
11:04:41 <benmachine> @let result = (.)
11:04:43 <lambdabot>  Defined.
11:04:55 <benmachine> :t result getFirst . foldMap (result First)
11:04:56 <lambdabot> Not in scope: `foldMap'
11:05:02 <benmachine> :t result getFirst . Data.Foldable.foldMap (result First)
11:05:03 <lambdabot> forall a (f :: * -> *) (t :: * -> *). (Functor f, Data.Foldable.Foldable t, Monoid (f (First a))) => t (f (Maybe a)) -> f (Maybe a)
11:05:09 <benmachine> sigh
11:05:17 <monochrom> people love to butcher error messages to the point of informationless
11:05:18 <benmachine> @undefine
11:05:28 <benmachine> @let result f g x = f (g x)
11:05:29 <lambdabot>  Defined.
11:05:34 <benmachine> :t result getFirst . Data.Foldable.foldMap (result First)
11:05:35 <lambdabot> forall t a (t1 :: * -> *). (Data.Foldable.Foldable t1) => t1 (t -> Maybe a) -> t -> Maybe a
11:05:39 <benmachine> that'll do
11:06:01 <monochrom> I blame it on years of schooling that insists "express in your own words to show how you understand nothing"
11:06:01 <benmachine> monochrom: remind me, were you trebla?
11:06:06 <monochrom> yes
11:06:09 <benmachine> aha
11:06:09 <MHD> Where can I find some good resources for learning Typed Lambda Calculus?
11:06:24 <benmachine> you know how hard it is to google for your cabal packages article? :P
11:06:31 <benmachine> well
11:06:41 <benmachine> it would help if I remembered anything other than the acronym
11:06:57 <benmachine> also I keep thinking the i is installation and p is programs
11:07:04 <thoughtpolice_> MHD: 'types and programming languages' by pierce is pretty fantastic for all sorts of info on the lambda calculus in plenty of forms (untyped, simply typed, polymorphic, etc)
11:07:31 <MHD> thoughtpolice_: much appreciated.
11:07:53 <dmos> benmachine: thanks, I'll look into it.
11:10:04 <anandjeyahar> what's wrong with the line pickRandom x = randomRIO (0 length x) >>= return .(x !!)
11:10:09 <anandjeyahar> i get an error message:
11:10:24 <anandjeyahar> No instance for (Num (([a0] -> Int) -> [String] -> (Int, Int)))       arising from a use of `pickRandom'
11:10:39 <anandjeyahar> i don't understand this error. Haskell newbie here
11:10:43 <monochrom> what is "0 length x" supposed to mean?
11:10:45 <Tomsik> that: (0 length x)
11:11:14 <anandjeyahar> Ah, thanks. there is supposed to be a ,
11:11:15 <monochrom> I guess you should (0, length x)
11:11:59 <anandjeyahar> monochrom: Yep.
11:12:01 <anandjeyahar> it works
11:12:09 <anandjeyahar> Guess this means bed time for me.
11:12:22 <monochrom> you may or may not like (x !!) `fmap` randomRIO (0 length x) better. this is optional
11:12:52 <Tomsik> :t let pickRandom x = (!!) x <$> randomRIO (0, length x)
11:12:53 <lambdabot> <no location info>:
11:12:53 <lambdabot>     not an expression: `let pickRandom x = (!!) x <$> randomRIO (0, length x)'
11:12:58 <Tomsik> :t let pickRandom x = (!!) x <$> randomRIO (0, length x) in pickRandom
11:12:59 <lambdabot> forall a. [a] -> IO a
11:14:39 <NemesisD> i'm confused, are the surrounding //'s not part of a PCRE?
11:14:49 <MHD> How would one do anything else than unary arithmetic in lambda calculus?
11:15:06 <NemesisD> is that something that languages implementing regex just throw in as part of their grammar?
11:15:20 <monochrom> using church encoding, you can do all algebraic data types in lambda calculus
11:15:52 <prototrout> NemesisD: The //s are just to delimit the regex. They're not part of the regex itself. In Perl you don't even need to use /'s (e.g. s#foo#bar#)
11:16:26 <Tomsik> church encoding for data and fixed point combinator for recursion
11:16:50 <osfameron> s#foo#bar# is kinda horrible admittedly.  But s {foo} {bar}  is arguably more readable.
11:16:55 <Tomsik> something like \f x -> f (f x)
11:17:02 <MHD> Tomsik: was that an answer to my question?
11:17:04 <Tomsik> err
11:17:07 <Tomsik> MHD: yes
11:17:14 <Tomsik> except the term was all wrong
11:17:25 <MHD> Well, I meant, is there some other way of doing arithmetic than in unary church numerals?
11:17:36 <MHD> (I know about all the basics)
11:17:52 <MHD> Say, implementing binary numerals?
11:18:00 <Tomsik> Well, in theory you just use unary stuff
11:18:07 <Tomsik> you can play with binary numerals, for sure
11:18:16 <Tomsik> but that's not what you'd do on a computer in reality
11:18:36 <MHD> This is actually for a story in which the computers are magic lambda-reducing machines, so they need som efficiency...
11:19:05 <MHD> Unary is generally accepted to be slow as balls.
11:19:13 <Tomsik> (Magic? Look at Reduceron :p)
11:19:25 <kmc> MHD, you can Church-encode any data type in the lambda calculus
11:19:28 <Tomsik> Well, an easy way would be to use a list of bits for arithmetic
11:19:29 <monochrom> you can design an algebraic data type for binary numbers
11:19:33 <kmc> say,  data Num = Twice Num | Succ Num | Zero
11:19:39 <MHD> kmc: I know
11:19:58 <monochrom> in fact, just use [Bool]
11:19:58 <MHD> kmc: but how would one do that in pure simply type LC?
11:20:04 <kmc> data Bin = Zero Bin | One Bin | End
11:20:12 <MHD> ok
11:20:17 <kmc> either of these should do
11:20:44 <dainanaki> I've got a Ptr to a struct created by some C code, and it has a function that must be called to free the struct in a particular way when it's done being used. Is there a way to specify a finaliser for Ptrs that gets called when they are garbage collected?
11:20:51 <kmc> enc (Zero n) = \f g h -> f n;  enc (One n) = \f g h -> g n;  enc End = \f g h -> h
11:20:55 <MHD> so... How does that transition to untyped/simply typed lambda calculus
11:21:09 <kmc> dainanaki, not for Ptrs but for ForeignPtrs
11:21:48 <zong_sharo> what is best option for generic programming over gadts?
11:22:00 <dainanaki> ah, that's what I was looking for. I knew it was around somewhere. Thanks as always, kmc.
11:22:34 <kmc> no problem :)
11:22:36 <MHD> kmc: So decimals would be "enc (Zero n) = \f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 g -> f0 n; ..."?
11:26:20 <MHD> How would negative numbers work in lambda calculus?
11:26:45 <c_wraith> you need a more complicated representation than church numerals.
11:26:47 <c_wraith> But it can be done
11:27:06 <MHD> c_wraith: That is exactly my intention.
11:27:29 <benmachine> MHD: an obvious option is (Bool, Nat)
11:27:39 <benmachine> but I don't know how easy that is to work with
11:27:43 <MHD> benmachine, yeah
11:27:50 <MHD> that could work
11:28:03 <benmachine> likewise Either Nat Nat
11:28:35 <MHD> how would either work in LC?
11:28:47 <MHD> (I am such a noob :P)
11:28:58 <benmachine> well True is \t f -> t
11:29:01 <benmachine> and False is \t f -> f
11:29:05 <benmachine> (or can be so)
11:29:14 <benmachine> (x, y) is \p -> p x y
11:29:21 <MHD> yeah
11:29:27 <MHD> that's the cons operator
11:29:33 <benmachine> doesn't that answer your question?
11:29:39 <MHD> yeah, pretty much
11:29:42 <MHD> thanks :)
11:30:53 <benmachine> MHD: there might be an easier representation that I don't knwo about
11:31:06 <benmachine> I've never actually used negative numbers in LC
11:39:18 * hackagebot clientsession 0.7.1 - Store session data in a cookie.  http://hackage.haskell.org/package/clientsession-0.7.1 (MichaelSnoyman)
11:39:20 * hackagebot primitive 0.4.0.1 - Wrappers for primitive operations  http://hackage.haskell.org/package/primitive-0.4.0.1 (RomanLeshchinskiy)
11:41:52 <parcs> > let x | 5 <- 5 = () in x
11:41:53 <lambdabot>   ()
11:44:12 <hpc> parcs: wait what?
11:44:39 <hpc> > 5 <- 5
11:44:40 <lambdabot>   not an expression: `5 <- 5'
11:44:45 <mauke> > let x | 5 < - 5 = () in x
11:44:46 <lambdabot>   *Exception: <interactive>:3:4-19: Non-exhaustive patterns in function x
11:44:58 <ion> > let f x | Just y <- x = y in f (Just 42)
11:45:00 <lambdabot>   42
11:45:48 <hpc> oh
11:45:54 <byorgey> pattern guard
11:47:14 <hpc> i like it
11:47:40 <copumpkin> > let f (listToMaybe -> Just x) = x in f [1..]
11:47:41 <lambdabot>   1
11:48:39 <mauke> > let f (f -> x) = x in f x
11:48:43 <lambdabot>   mueval-core: Time limit exceeded
11:48:45 <sm> NemesisD: regexpr provides a good mix of pcreish features, simplicity and portability
11:49:04 <ion> > let f (listToMaybe -> mx) | Just x <- mx = x | Nothing <- mx = 0 in f []
11:49:05 <lambdabot>   0
11:49:09 <kmc> > let fix (fix -> x) = x in fix ((0:) . scanl (+) 1)
11:49:13 <lambdabot>   mueval-core: Time limit exceeded
11:49:14 <kmc> :(
11:49:46 <mauke> fix f = fix f
11:50:25 <copumpkin> > let fix f@(fix -> x) = f x in fix ((0:) . scanl (+) 1)
11:50:27 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:51:13 <copumpkin> > let fix f | x <- fix f = f x in fix ((0:) . scanl (+) 1)
11:51:15 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:51:33 <mauke> > let fix f@(fix -> f -> x) = x in fix (const ())
11:51:34 <lambdabot>   <no location info>: parse error on input `->'
11:51:45 <mauke> > let fix f@(fix -> (f -> x)) = x in fix (const ())
11:51:46 <lambdabot>   ()
11:51:50 <mauke> excellent
11:51:55 <copumpkin> hah
11:52:08 <copumpkin> most obscure syntax ever
11:53:08 <kmc> i think that's my new favorite definition of fix
11:53:22 <ion> There should be a lambdabot plugin that obfuscates code by coercing it to use view patterns, excess pointlessness (but perhaps not to the extent of @pl), fix etc.
11:53:33 <hpc> your next challenge: write a definition of fix in java that fits in a twitter post
11:53:42 <ion> Perhaps also excess pointfulness.
11:53:50 <monochrom> hahaha hpc
11:53:58 <kmc> haha
11:54:04 <kmc> i wrote the Y combinator in C++ once
11:54:10 <ion> @remember hpc your next challenge: write a definition of fix in java that fits in a twitter post
11:54:11 <lambdabot> It is forever etched in my memory.
11:54:18 * hackagebot vector 0.9 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.9 (RomanLeshchinskiy)
12:02:38 <rwbarton> we need a new lambdabot plugin that converts function definitions to ViewPatterns style
12:02:51 <rwbarton> oh oops, someone already said that :P
12:05:30 <monochrom> @pl let x=x in x
12:05:30 <lambdabot> fix id
12:05:35 <monochrom> \∩/
12:05:54 <monochrom> @pl let f x = f (g x) in f 0
12:05:54 <lambdabot> fix (. g) 0
12:05:59 <monochrom> \∩/
12:06:32 <monochrom> @pl let {f x = g (h x); g x = f (h x)} in f 0
12:06:32 <lambdabot> (line 1, column 5):
12:06:32 <lambdabot> unexpected "{"
12:06:32 <lambdabot> expecting "()", natural, identifier or "in"
12:06:49 <monochrom> oh well
12:20:19 <joe6> i want to convert these bitfields (http://codepad.org/4yKmqjSI) to haskell functions. Is language.C my best option to read such structure definitions?
12:20:40 <copumpkin> probably
12:21:47 <kmc> or you can go the hsc2hs route
12:22:05 <rwbarton> @pl let (f, g) = (\x -> g (h x), \x -> f (h x)) in f 0
12:22:06 <lambdabot> (line 1, column 5):
12:22:06 <lambdabot> unexpected "("
12:22:06 <lambdabot> expecting "()", natural, identifier or "in"
12:22:26 <kmc> you write a .hsc file using Haskell plus special directives; hsc2hs turns that into a c program, compiles and runs it, and the c program spits out Haskell source
12:22:43 <kmc> this is pretty baroque but cabal already knows how to do it flawlessly
12:24:19 * hackagebot trifecta 0.37 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.37 (EdwardKmett)
12:24:32 <kmc> or do something ugly like  grep unsigned < foo.h | awk '{print $2}' | tr -d \; | sed 's/:/ /' | while read n f; do echo "(\"$n\", f)"; done
12:35:01 <xenocryst> I'm a haskell newbie and I'm having trouble working out a way to do this. I want to take in a bunch of text and then output how frequently each character occurs. I was thinking of taking the whole block of text, and then doing a fold, for each letter, that sums its occurances
12:35:05 <xenocryst> this seems... bad, though
12:35:20 <c_wraith> why?  A fold isn't bad.
12:35:36 <xenocryst> but I'd be doing it for each individual letter, so I'd be doing at least 26 folds
12:35:47 <copumpkin> no, you'd presumably use a map as your accumulator
12:35:49 <c_wraith> oh.  Ok, I misread you.  That is a bit less-good
12:36:00 <c_wraith> but using a map as your accumulator does help with that.
12:36:22 <c_wraith> Though if your range is limited, there are sneaky-efficient tricks like accumArray
12:36:33 <xenocryst> c_wraith: how do you mean? map (foldr + text) ['a'..'z']?
12:36:41 <c_wraith> xenocryst: Data.Map
12:36:47 <xenocryst> ah, ok
12:37:08 <xenocryst> I'll read more about this. Is it just a binary search tree?
12:37:17 <copumpkin> it could be a trie, too
12:37:20 <Cale> xenocryst: internally, yeah
12:37:22 <copumpkin> depends, but probably
12:37:23 <c_wraith> xenocryst: yes, it's a balanced BST.
12:37:30 <c_wraith> well, semi-balanced
12:37:50 <monochrom> use a Data.Map or and array or a 26-tuple
12:37:58 <monochrom> s/and/an/
12:38:11 <xenocryst> monochrom: I'll go with the 26-tuple
12:38:15 <Cale> hehe
12:38:21 <c_wraith> :t accumArray
12:38:22 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
12:38:29 <monochrom> or a hashmap (package name "unordered-containers")
12:38:30 <Cale> 26-tuple is probably larger than most programs ever contain
12:38:45 <Cale> You could also just use a list of pairs of characters and counts
12:38:49 <xenocryst> I imagine it is quite a hassle to pattern match
12:38:54 <monochrom> at least it is not a 26-ary continuation
12:39:07 <monochrom> @quote 17-ary
12:39:08 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
12:39:11 <Cale> monochrom: haha, that's almost more convenient than the 26-tuple
12:39:25 <xenocryst> Cale: what do you mean by counts?
12:39:35 <Cale> [(Char, Integer)]
12:39:42 <xenocryst> Ah, right
12:39:55 <copumpkin> accumArray is probably the most efficient
12:40:02 <copumpkin> or was it array?
12:40:05 <Cale> > map (head &&& length) . group . sort $ "abracadabra"
12:40:07 <lambdabot>   [('a',5),('b',2),('c',1),('d',1),('r',2)]
12:40:10 <copumpkin> one of those array creators
12:40:15 <xenocryst> Cale: you are a magician
12:40:26 <c_wraith> accumArray is efficient, but not very functional. :)
12:40:34 <copumpkin> it's very functional!
12:40:42 <c_wraith> yay polysemy!
12:40:45 <copumpkin> it's efficient behind the scenes and functional on the surface
12:40:49 <monochrom> accumArray trivializes the problem
12:41:15 <monochrom> then again Data.Map.fromListWith does too
12:41:51 <copumpkin> different asymptotics though
12:42:17 <copumpkin> or not, maybe
12:42:18 <xenocryst> Cale: one question, why the three & instead of &&?
12:42:23 <monochrom> but you don't know how much asymptotics matter
12:42:25 <c_wraith> > accumArray (+) 0 ('a', 'z') . zip "foobar" $ repeat 1
12:42:27 <lambdabot>   array ('a','z') [('a',1),('b',1),('c',0),('d',0),('e',0),('f',1),('g',0),('...
12:42:34 <Cale> xenocryst: because I'm using the operator from Control.Arrow
12:42:42 <Cale> xenocryst: It goes along with ***
12:42:45 <c_wraith> accumArray is kind of an ugly interface for that, though.
12:42:46 <copumpkin> monochrom: you could probably make an argument that with 26 letters, the log factor is gone anyway
12:42:47 <xenocryst> ok, I haven't read about arrows yet
12:42:58 <copumpkin> monochrom: the space profile is different though
12:43:06 <Cale> It's only the instance for the normal function arrow though, so nothing too magical
12:43:11 <monochrom> accumArray has its overhead too
12:43:14 <Cale> (f &&& g) x = (f x, g x)
12:43:21 <xenocryst> oh neat
12:43:27 <Cale> (f *** g) (x,y) = (f x, g y)
12:43:52 <xenocryst> that is so friggin' cool
12:44:31 <ion> @type (&&&) `asAppliedTo` (undefined :: a -> b)
12:44:32 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
12:44:37 <ion> @type (***) `asAppliedTo` (undefined :: a -> b)
12:44:38 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
12:44:54 <confab> looks like map or zip
12:45:04 <confab> and*
12:45:30 <byorgey> (***) is very much like map
12:46:00 <confab> i was thinking (&&&) was more mappish
12:46:04 <xenocryst> I've read up to applicative functors but had to head back to school. I still have monads to get through before I can start on arrows (I'm assuming)
12:46:20 <byorgey> xenocryst: not true.
12:46:40 <byorgey> there's a lot about arrows you can learn about without having to understand monads
12:46:51 <Cale> But it does make sense to learn monads first
12:47:20 <byorgey> pragmatically speaking, yes.  but if you are excited about arrows then don't stop yourself from learning. =)
12:47:30 <c_wraith> Arrows are less useful as a general model, but they have some handy combinators.  Monads are definitely more useful in general :)
12:47:31 <xenocryst> The book I'm using is basically Learn You a Haskell but I'm not sure if it covers arrows. Would Real World Haskell or A Gentle Introduction include them?
12:47:40 <Cale> From the perspective that 1) they're more common, and 2) one of the major reasons that you'd want something to be an arrow (rather than a monad e.g.) is best explained once you know about monads
12:47:44 <kmc> xenocryst, almost nobody uses arrows
12:48:03 <kmc> except some people use the Arrow combinators for (->) specifically, i.e. ordinary functions
12:48:48 <c_wraith> apparently the new fclabels version uses Arrow subinterfaces internally, for indicating labels that can fail.
12:49:04 <c_wraith> But that isn't too visible in the external interface
12:49:40 * Cale uses arrows every day now :)
12:49:52 <Cale> (we have an arrow FRP system for our game)
12:50:49 <Cale> I have to say they're more useful with our extensions and preprocessor. Eventually we'll have to build what our preprocessor does into GHC though, since it really really hurts the error messages when you're using it.
12:54:48 <zong_sharo> is it possible to do generic programming on gadts? how?
12:55:59 <byorgey> zong_sharo: RepLib now supports GADTs, as long as they do not have any existential quantification
12:56:02 <c_wraith> which generic programming?  The term has a few meanings in haskell-land.  The new GHC feature one?
12:57:01 <zong_sharo> byorgey: and if the do?
12:57:03 <byorgey> the new Generic mechanism for GHC does not support GADTs.
12:57:38 <byorgey> zong_sharo: Well, you simply will not be able to derive generic representation types for them with RepLib.
12:58:02 <byorgey> I do not know of any Haskell generic programming frameworks that let you work with GADTs + existential quantification
12:58:08 <byorgey> although I can't say for sure that none exist.
12:59:47 <tgeeky> byorgey: that almost sounded like a meta-joke
13:00:02 <byorgey> hehe
13:09:08 <BMeph> Has anyone tried to make an FL interpreter/compiler in Haskell?
13:10:00 <tromp> what's FL?
13:13:33 <joe6> how do I use this hsc2hs macro peek_bit, template-hsc.h: http://codepad.org/pz7cUwqd, and I tried to use it as "#peek_bit unsigned int, 1"
13:13:41 <joe6> Is that how hsc2hs macros are used?
13:13:51 <joe6> I just added that line in the .hsc file.
13:14:20 * hackagebot BiobaseTurner 0.1.1.0 - Import Turner RNA parameters  http://hackage.haskell.org/package/BiobaseTurner-0.1.1.0 (ChristianHoener)
13:14:39 <joe6> the c file created is http://codepad.org/5R4XHxqe
13:14:46 <mauke> size_t with %lu :-(
13:15:22 <joe6> i this this line might be the cause of the error:     fputs ("", stdout);
13:15:39 <joe6> mauke, sorry, this is my first time trying to use hsc2hs.
13:15:54 <mauke> why are you going crazy with macros?
13:16:17 <dolio> Because macros are awesome.
13:16:39 <joe6> mauke, I have bitfields like these http://codepad.org/M8fEKNvC, that I am trying to write some haskell FFI bindings for.
13:17:02 <joe6> mauke, do you mean? #peek_bit size_t unsigned int, 1?
13:17:06 <mauke> why are you going crazy with macros?
13:17:09 <joe6> or, change the macro to have a size_t?
13:17:19 <BMeph> tromp: This is the definitive paper about it: http://theory.stanford.edu/~aiken/publications/trs/FLProject.pdf
13:17:33 <joe6> and I found this patch: http://www.haskell.org/pipermail/haskell-cafe/2008-November/050331.html
13:17:52 <joe6> mauke, I am just trying to use that patch.
13:18:50 <mauke> looks crazy
13:19:02 <joe6> the patch?
13:19:03 <mauke> what do you mean by "change the macro to have a size_t?"?
13:19:05 <mauke> yes
13:19:21 * hackagebot msgpack 0.6.1.2 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.6.1.2 (HideyukiTanaka)
13:20:44 <joe6> mauke, this line, you mean?         t x;
13:20:57 <joe6> change to "size_t t x;"?
13:21:28 <mauke> joe6: you are crazy
13:22:15 <joe6> mauke, i downloaded this patch from the haskell-cafe link. I have no idea how it is supposed to fit together. I am just trying to understand it.
13:22:38 <mauke> please stop writing programs
13:23:57 <joe6> don't normally get this attitude from #haskell
13:24:18 <mauke> me neither
13:26:04 <tac-tics> > take 3 [1..]
13:26:05 <lambdabot>   [1,2,3]
13:26:07 <joe6> got it, this is what it should be: #peek_bit 4, 1
13:27:40 <mauke> joe6: that seems unlikely
13:28:09 <joe6> mauke, what do you mean? wrong usage or wrong macro?
13:28:28 <mauke> you keep jumping to interesting conclusions
13:28:35 <mauke> "interesting" because apparently you don't know C
13:28:52 <Cale> mauke: This isn't ##C though
13:29:05 <mauke> yeah, but these are hsc2hs macros
13:29:12 <mauke> that requires some knowledge of both Haskell and C
13:29:19 <Cale> Yeah, so I just mean, you don't have to be unfriendly ;)
13:29:20 * hackagebot BiobaseVienna 0.1.0.0 - Import Vienna energy parameters  http://hackage.haskell.org/package/BiobaseVienna-0.1.0.0 (ChristianHoener)
13:29:39 <mauke> C is unfriendly and will stab you in the back
13:29:47 <mauke> copy/pasting random code around will not help you
13:29:57 <Cale> Well, that's true
13:30:14 * BMeph was immediately reminded of the adage: "A real friend stabs you in the front." ;)
13:30:19 <joe6> it's a start, though.
13:30:21 <mauke> "#peek_bit 4, 1" can't be right because #define hsc_peek_bit(t, f) proceeds to do t x;
13:30:25 <mauke> and 4 x; is a syntax error
13:30:37 <joe6> yes, that is what I am trying to understand.
13:30:47 <mauke> have you tried a C introduction?
13:31:29 <mauke> or actually, the hsc2hs manual?
13:31:42 <mauke> given that the whole thing is modeled on #peek
13:32:05 <joe6> mauke, find something else to vent about.
13:32:50 <mauke> I'm pleasantly surprised to see that template-hsc.h gets the printfs right
13:32:55 <tgeeky> now now
13:33:06 <mauke> so it's just the proposed patch that's half-broken
13:34:36 <mauke> ah, fun. hsc_haskellize is broken
13:34:53 <cheater> mauke:
13:35:17 <cheater> @@(@nixon) (@vixen)
13:35:49 <cheater> @@ (@nixon) (@vixen)
13:35:50 <lambdabot>  A man is not finished when he is defeated. He is finished when he quits. what were you saying?
13:37:02 <tech2> Winners never quit and quitters never win, but a man who never wins and never quits is just an idiot.
13:39:11 <mauke> "Inline functions are handled correctly." <- well, fuck you too
13:41:19 <mauke> does the FFI guarantee anything about the representation of signed integers?
13:42:02 <kmc> it guarantees that CInt is compatible with the platform's C 'int'
13:42:28 <mauke> :-(
13:43:06 <mauke> no two's complement?
13:43:30 <Guest57785> I'm having a play with the warp webserver. Does using liftIO inside an Enumerator monad ruin the point of using it?
13:43:46 <JoeyA> mauke: C doesn't guarantee the internal representation of signed/unsigned ints, but unsigned ints basically have to *act* like two's complement, if I'm not mistaken.
13:43:58 <monochrom> depends on what you liftIO
13:43:59 <JoeyA> In C, (unsigned int) -1 is well-defined.
13:44:23 <JoeyA> and is equivalent to UINT_MAX
13:44:47 <Guest57785> monochrom: so if I lift something that uses lazy IO does that mean it will be lazy?
13:44:54 <monochrom> yes
13:44:58 <mauke> JoeyA: unsigned ints act like 2's complement? that makes no sense
13:45:22 <mauke> JoeyA: I know C doesn't guarantee the representation of signed ints, that's why I asked about FFI
13:45:24 <JoeyA> mauke: Overflowing unsigned int will cause it to wrap around.  That's defined by the standard.
13:45:31 <mauke> I know. irrelevant.
13:45:35 <JoeyA> oh
13:46:01 <Guest57785> monochrom: thanks. Are there any easy tricks to turn a lazy IO function into a iteratee? I don't want to have to write my own libraries
13:46:10 <JoeyA> If I want the internal representation of a data type to be private, do I have to use `newtype` or `data` (create a new type) rather than `type` (create a type alias) ?
13:46:25 <mauke> JoeyA: yeah
13:46:28 <JoeyA> Thanks
13:46:37 <kmc> C doesn't guarantee 2's complement, and that's why overflow/underflow of signed int is Undefined Behavior ™
13:46:52 <mauke> kmc: I don't think that's the reason
13:47:07 <mauke> they could have made it implementation defined
13:47:08 <kmc> if the compiler can prove your program overflows a signed int it's free to replace that code with system("rm -rf /")
13:47:13 <monochrom> all iteratee/enumerator libraries come with ready-made replacements of the only 3 lazy I/O things, no?
13:47:28 <kmc> what's the precise difference between UB and ID?
13:47:36 <kmc> if it's ID then the implementation has to define something consistent?
13:47:49 <mauke> kmc: there are three classes, undefined, unspecified, and implementation defined
13:47:50 <Guest57785> monochrom: I don't know. But now you've said that I will investigate. Thank you
13:48:00 <mauke> kmc: undefined means anything can happen
13:48:18 <mauke> kmc: unspecified means the implementation has to choose an implementation
13:48:30 <mauke> kmc: implementation defined means the implementation has to choose an implementation and document it
13:48:35 <monochrom> yeah whenever you download a lib you should give its docs at least a glance cover-to-cover just so you know what is in there
13:48:48 <joe6> what is the advantag of having the high-level module Bindings.Gsl in uri: http://hackage.haskell.org/package/bindings-gsl
13:48:50 <mauke> e.g. the width of int is implementation defined because it's documented in <limits.h>
13:49:05 <joe6> I can see that it serves as a documentation wrapper for the underlying modules.
13:49:16 <joe6> but, other than that is there any other purpose to it?
13:49:44 <JoeyA> kmc: Indeed.  I fell afoul of that once when I did something like this in a loop: for (x = 1; x != 0; x += x)
13:49:52 <JoeyA> As opposed to x <<= x
13:49:57 <JoeyA> err, x <<= 1
13:50:11 <mauke> JoeyA: is that a signed integer?
13:50:18 <JoeyA> I don't remember.  Probably.
13:50:23 <mauke> JoeyA: probably still UB then
13:50:44 <joe6> sorry, forget it. found it.
13:55:13 <kmc> so why should signed integer overflow be undef instead of unspec
13:55:28 <mauke> because C says so
13:55:39 <mauke> rationale? no idea
13:56:19 <tvynr> would this be the right place to drop a question about Happy?
13:56:37 <mauke> try it
13:56:43 <monochrom> the committee met and agreed "unspecified" in voice. then someone had to write it down afterwards, and he/she made a typo. then no one caught the typo. my theory anyway
13:56:54 <tvynr> just wanted to make sure I wasn't off as to the intentions of the channel
13:56:56 <tvynr> :)
13:57:40 <JoeyA> tvynr: If you ask an intelligent off-topic question in a channel, someone will tell you and you will most likely be forgiven :-)
13:58:13 <JoeyA> If you ask if something is on-topic, you're turning one round trip into two.
14:00:20 <JoeyA> Does anyone find Kate's handling of Haskell indentation annoying?  Or am I just not used to good indenting conventions?
14:00:40 <JoeyA> (I set it to use spaces instead of tabs when I'm editing Haskell)
14:00:44 <tvynr> JoeyA: I find it annoying as well, yes.
14:00:58 <tvynr> JoeyA: I always just put everything on Normal indentation anyway.
14:01:26 <monochrom> spaces is good. but I don't know Kate
14:02:52 <JoeyA> tvynr: It reverts back to the default indentation on save: http://bugs.kde.org/show_bug.cgi?id=258980
14:03:25 <JoeyA> Since I have a (very good) habit of typing Ctrl+S on a regular basis, it's effectively impossible for me to use Normal.
14:04:01 <tvynr> so here's the problem: I'm trying to learn about monadic Happy parsers that use threaded lexers -- we're using Haskell for a language development project -- and so I've created a simple parser for Peano arithmetic.  When I run it with the invalid input "S S S" it's crashing with an "internal happy error
14:04:04 <tvynr> http://pastie.org/2456636
14:04:20 <JoeyA> I would use gedit, but I don't want to download 450MB of packages so it can save my settings to disk.
14:04:47 <tvynr> JoeyA: So it does; I remember that now.  I moved over to Vim for my Haskell editing as a result of that nonsense.  I rather want a Haskell IDE, but I haven't had a chance to try any of them out yet.
14:04:51 <JoeyA> At least it's happy :-)
14:05:05 <tvynr> JoeyA: Actually, the error in question is bound to the variable "notHappyAtAll"
14:05:20 * BMeph If you ask to ask a question, aren't you already asking one? ;)
14:05:20 <monochrom> har har
14:05:40 <mauke> can I ask whether asking questions is on-topic here?
14:05:51 <monochrom> oh but "may I ask a functor question" is different from "may I ask a question?"
14:05:59 <Twey> mauke: No it isn't — prepare to receive a hefty fine for breaking the rules.
14:06:03 <tvynr> So anyway, I'm trying to sort out what on earth I could have done wrong in this *very* simple parser.
14:06:36 <Dashkal> No, you may only ask if the question you're asking is on topic
14:07:02 <monochrom> may I ask a question that doesn't ask itself? or something?
14:11:44 <{-{-nest-}comm-}> JoeyA: yes, Kate sux goatballs @ Haskell indentation
14:12:09 <copumpkin> {-{-nest-}comm-}: o.O
14:12:19 <monochrom> that's devhc for you
14:12:23 <{-{-nest-}comm-}> nwhahahaha
14:12:30 <{-{-nest-}comm-}> hi, mauke
14:12:42 <kmc> nice nick {-{-nest-}comm-}
14:12:57 <monochrom> I didn't know you would take it so seriously and couldn't let it go
14:13:09 <kmc> > "-}"
14:13:10 <lambdabot>   "-}"
14:13:12 <kmc> > {- "-}" -}
14:13:13 <lambdabot>   <no location info>:
14:13:14 <lambdabot>      lexical error in string/character literal at end o...
14:13:33 <{-{-nest-}comm-}> guess what google autocompletes "art of" to
14:13:45 <kmc> trolling?
14:13:48 <{-{-nest-}comm-}> ind33d
14:14:33 <erus`> trolling is a art hurrr
14:21:48 <ezyang> Someone remind me what the difference between "lazy" and "call-by-need" evaluation is.
14:22:23 <monochrom> I think they're synonyms
14:22:40 <tromp> lazy can also be call-by-name?
14:22:41 <Cale> I can tell you what lazy evaluation is. Call-by-need I have to look up to make sure. ;)
14:22:58 <Cale> Lazy evaluation is outermost-first evaluation with sharing.
14:23:16 <monochrom> call-by-name omits the sharing part
14:23:17 <tromp> right; call-by-name and call-by-need differ only in sharing
14:23:32 <Cale> So call-by-name means normal-order evaluation?
14:23:38 <ezyang> I'm pretty sure laziness inclues memoization
14:23:41 <ezyang> *includes
14:23:41 <tromp> but i thought by need was the one without sharing:(
14:23:53 <ezyang> Hmm, one definition I'm looking at says that lazy evaluation is a concrete evaluation strategy
14:23:54 <copumpkin> Cale: call-by-name is outermost-first without sharing
14:24:01 <ezyang> whereas call by need is a semantic notion.
14:24:15 <copumpkin> so lots of repeated computation, potentially
14:24:17 <Cale> The call-by-X names seem really nonintuitive and overly similar to be memorable to me.
14:24:25 <Cale> I don't know where they come from.
14:25:07 <Cale> ezyang: non-strict semantics is a semantic notion, I don't think call-by-X of any kind refers to semantics
14:25:15 <tvynr> I'm relatively new to Haskell.  How do I report a bug in Happy?
14:25:16 <ezyang> Hmmmm.
14:25:24 <Cale> (The semantics shouldn't even have a notion of calls, anyway, wtf.)
14:25:31 <monochrom> well, when I read Wadler's papers, call-by-name and call-by-need are very concrete evaluation strategies (exact steps and orders)
14:25:45 <ezyang> tvynr: Ostensibly where the Happy trac is (but I don't know where it is...)
14:26:00 <tvynr> ezyang: I wouldn't've known where to start.  Thanks for the pointer.  :)
14:27:13 <Cale> or you could just send an email to Simon Marlow
14:27:21 <Cale> simonmar@microsoft.com
14:27:52 <ezyang> "Wait, he actually uses his Microsoft email?"
14:28:08 <Cale> Does he not?
14:28:31 <ezyang> He probably checks it, so it will get to him. But I always see his outbound emails from @gmail.com
14:28:48 <Cale> oh, marlowsd@gmail.com
14:29:05 <tvynr> Cale: Just found that the Happy documentation indicates that I should send it to his GMail address.
14:29:12 <sbrg> I'm about to do some heavy file management with haskell, and I was wondering what was the best way to get directory contents using haskell. I know of getDirectoryContents, but since that just returns a list of strings there's no easy way to determine what is a directory and what isn't (is there?)
14:29:27 <Cale> Interesting, I found his Microsoft address on the Happy page too :)
14:29:59 <sbrg> Anyone know of any libraries that return a structure that contains some more information?
14:30:01 <acowley> sbrg: doesDirectoryExist answers that question
14:30:08 <sbrg> acowley: ah, good point
14:30:12 <tvynr> Just for the record, it seems that a parse which reaches end of stream will produce the internal error.  I fudged in a special EOF token (even though Happy is supposed to have one of its own) and it seemed to "fix" it.
14:30:18 <monochrom> "doesDirectoryExist" may help
14:30:23 <Cale> http://hackage.haskell.org/packages/archive/directory-tree/0.10.0/doc/html/System-Directory-Tree.html -- there's this
14:30:25 <Cale> I
14:30:25 <tvynr> And this only happens when one includes a %monad directive
14:30:28 <Cale> I've never used it
14:30:34 <Cale> but it looks like it might be useful
14:31:09 <c_wraith> I've used DirectoryTree.  I even requested a feature change for it, which the maintainer decided was good. :)
14:31:44 <DukeDave> Any one with good cabal-fu around?
14:31:58 <sbrg> hmm, thanks
14:32:02 <sbrg> maybe I'll just roll my own
14:32:07 <sbrg> don't need all of what directory-tree offers
14:32:16 <acowley> sbrg: the thing to do is to bite the bullet and write the directory interface you want/need for your application (e.g. normalize paths) out of getDirectoryContents and doesDirectoryExist
14:32:37 <acowley> it forces you to think about it, and ends up as like 5 lines of code
14:32:58 <sbrg> acowley: Well. system.filepath does a lot of that stuff
14:33:41 <Cale> You could also just use the part of the directory-tree package which you need, and ignore that the rest of it exists :)
14:33:57 <acowley> It does. I've found it helpful to put those pieces -- each with its own quite long identifier -- together as a "dir" function that I then use in the few places where I need it.
14:34:48 <Cale> If you can get by with doesDirectoryExist and getDirectoryContents, then go right ahead though :)
14:35:12 <acowley> I find unsafeCoerce is pretty much all I need
14:35:30 <Cale> lol
14:35:39 <monochrom> unsafeCoerce Nothing :: [Int]
14:35:51 <mauke> unsafeCoerce unsafeCoerce :: [Int]
14:35:51 <Cale> unsafeCoerce, the universal function
14:37:41 <ion> % ghc -e 'Unsafe.Coerce.unsafeCoerce (Just 42) :: [Int]'
14:37:41 <ion> [42]
14:37:55 <ion> I did not expect that. :-)
14:38:06 <ion> Prelude> Unsafe.Coerce.unsafeCoerce (Just 42) :: [Int]
14:38:06 <ion> [42zsh: segmentation fault (core dumped)  ghci
14:38:09 <ion> Much better.
14:39:07 <acowley> that's really neat
14:39:21 <acowley> so Just is an unsafeCoerce synonym for (:[])?
14:40:55 <monochrom> it is understandable that Nothing and [] have the same representation. but Just is 1-ary while (:) is 2-ary
14:41:37 <ion> (:⊥) perhaps.
14:42:15 <acowley> I'm going to use singleton = unsafeCoerce . Just :: a -> [a] everywhere now
14:42:27 <kmc> ⊥ is a novel description for a segfault
14:42:39 <kmc> but does seem correct :)
14:43:35 <kmc> except that segfaults are usually just the best-case outcome
14:43:51 <ezyang> "Principle of Explosion"
14:43:54 <monochrom> I have recently poured over ghc-generated cmm and asm, so I know a bit about what data look like at the end
14:43:57 <kmc> in an interview, show someone broken C code and ask them the worst thing that could happen.  if they say "segfault" do not hire that person
14:44:31 <dankna> unfair question
14:44:36 <acowley> kmc: I say, "Human sacrifice, dogs and cats living together... mass hysteria!"
14:44:39 <dankna> unless you follow up with "what are the implications"
14:45:04 <dankna> if they then say "well, the program will crash" then I agree with you
14:45:42 <hpaste> “Unsafe.Coerce.unsafeCoerce (Right 'f') :: String” pasted “ion” at http://hpaste.org/50801
14:46:12 <monochrom> "Just x" in the heap is two consecutive words, first word points to Just and second word points to x. "x:[]" is 3 consecutive words, 1st word points to (:), 2nd word points to x, 3rd word points to []
14:46:19 <ion> I like when code pastes me.
14:46:28 <dankna> haha
14:46:31 <ion> monochrom: Makes sense.
14:46:47 <acowley> Interview questions are terrible. While I understand the thinking behind such questions, they often look like poorly defined questions masquerading as insightful.
14:47:00 <monochrom> now, because of type erasure, most of the time no one actually checks that the 1st word really points to Just or (:) or Nothing or whatever
14:47:01 <dankna> well
14:47:04 <kmc> interviewing is hard and there are a lot of bad interview questions
14:47:25 <dankna> the thrust of these questions is often well-intentioned
14:47:33 <ion> monochrom: Yeah, that would be redundant since the compiler always generates correct code and nobody uses unsafeCoerce.
14:47:38 <dankna> but too often they get used as pass/fail rather than pass/more-information
14:47:41 <acowley> kmc: Yeah, I'm certainly not suggesting that there's anything easy about it
14:47:55 <kmc> however a good interview is holistic; you won't be rejected on the basis of a single gotcha puzzle question
14:48:25 <ion> Err, actually unsafeCoerce probably changes the first word. At least i'd expect that.
14:48:33 <kmc> i don't think so ion
14:48:35 <kmc> changes it in place?
14:48:40 <kmc> certainly not
14:48:48 <kmc> i don't think it allocates
14:48:51 <Dashkal> I've started to strongly suspect that that point of that evil gotcha question is to either be 'passed' by admitting you don't know or it allows the canidate to filter out a bad employer.
14:48:52 <acowley> In any case, I believe my strategy of maximally utilizing Ghost Busters quotes is probably the best idea
14:48:54 <kmc> i think it's a total no-op at runtime
14:49:12 <acowley> kmc is right afaik
14:49:14 <dankna> acowley: I concur.  and if they catch the reference but say "that movie sucked", no hire!
14:49:21 * hackagebot trifecta 0.38 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.38 (EdwardKmett)
14:49:25 <ion> Hmm, true. I thought maybe it makes a copy, but you're right, no need to do that.
14:49:47 <monochrom> to distinguish between [] and (:), pointer tagging is used, i.e., you don't pass around the exact beginning address (which is 32-bit-aligned or something) of those 2 or 3 consecutive words. you passing around the address plus 1 or 2 or 3, so a receiver just looks at the lower bits to do pattern matching
14:49:56 <dainanaki> does the haskell platform come with a way to find the maximum file path length of the current system?
14:50:16 <mauke> dainanaki: "current system" is ambiguous
14:50:28 <dainanaki> the system on which the code is compiled
14:50:50 <monochrom> and so, for example, Nothing and [] look the same (unless you deference, which no one does)
14:50:53 <mauke> dainanaki: yes, that's ambiguous
14:51:06 <dainanaki> mauke: how so?
14:51:10 <sbrg> hmm. I can't use UTF-8 like æ in my code? :(
14:51:22 <mauke> dainanaki: maximum path lengths depends on the file system
14:51:31 <kmc> sbrg, two A-with-umlauts separated by a broken vertical bar?
14:51:55 <mauke> dainanaki: my current system has 13 file systems mounted
14:51:56 <sbrg> kmc: Looks fine on my mind. The nordic character ae
14:52:08 <mauke> that's æ
14:52:09 <monochrom> "Just x" and "x:blah" would look the same too, except: the heap object has 2 consecutive words, but you expect 3, so now you're at the mercy of unrelated stuff on the heap for what "blah" resolves to
14:52:17 <sbrg> my end*
14:52:23 <kmc> i'm pretty sure the bytes you sent to my IRC client were not the UTF-8 encoding of that character (æ?)
14:52:34 <kmc> you probably have your client set up for the bastardized IRC mixed Latin-1/UTF-8 encoding
14:52:52 <sbrg> kmc: Not sure. Putty is set to utf-8, but it may be my shell or some shizzle
14:52:53 <sbrg> or the client
14:53:05 <kmc> anyway make sure the bytes in your source file are really utf-8
14:53:06 <sbrg> at any rate; ghc doesn't like utf-8? Or just some?
14:53:09 <sbrg> alright
14:53:11 <kmc> what error do you get?
14:53:14 <dainanaki> mauke: hrm, I'm writing a high level library that wraps a low-level c lib that wants a CString to write a c string into, and it also wants the length of the buffer. How am I supposed to know how long to make the buffer?
14:53:18 <kmc> GHC is fine with UTF-8 in source files
14:53:20 <sbrg> lexical error in string/character literal (UTF-8 decoding error)
14:53:24 <kmc> iirc it's mandated by the standard
14:53:26 <ion> sbrg sent the line using proper UTF-8 encoding.
14:53:38 <kmc> really? maybe it's my client's fault, then
14:53:39 <mauke> dainanaki: "long enough"
14:53:41 <parcs> i got what kmc got
14:54:02 <ion> Oh, wait. Sorry. I misread. He sent one valid UTF-8 character and one extra byte that is invalid.
14:54:02 <kmc> sbrg, hexdump the file and make sure it's encoded as utf-8
14:54:04 <maurer_> ion: Are you sure?
14:54:13 <maurer_> ion: I got what kmc got, and kmc's paste came in fine for me
14:54:24 <sbrg> kmc: ah, it isn't
14:54:25 <kmc> my paste of æ?
14:54:27 <sbrg> gvim is doing latin1
14:54:28 <kmc> i didn't paste that ;)
14:54:44 <edwardk> sbrg: did you build the character using combining chars or with a combined utf8 code point?
14:54:50 <kmc> scumbag gvim, supports Unicode, outputs Latin-1
14:54:50 <sbrg> edwardk: nope.
14:54:54 <kmc> (did i do that meme right?)
14:54:58 <ion> sbrg sent C3 A6 C3. U+00E6 is C3 A6.
14:55:19 <edwardk> ah
14:55:21 <acowley> kmc: needs unicode hat
14:55:40 <acowley> it should be broken unicode to complete the circle
14:55:47 <edwardk> i just got down to where folks had actually debugged it ;)
14:55:59 <dainanaki> OK, according to wikipedia, it looks like ReiserFS accepts the longest file paths out of the common filesystems at 4032 bytes. Guess I'll go with that.
14:56:00 <Dashkal> > "λ"
14:56:01 <lambdabot>   "\955"
14:56:05 <kmc> i don't always represent human-readable text, but when i do, i use utf-8
14:56:09 <Dashkal> > putStrLn "λ"
14:56:09 <lambdabot>   <IO ()>
14:56:13 <Dashkal> meh
14:56:31 <kmc> encoding for IO operations is different from the encoding used in Haskell source files
14:56:32 <mauke> dainanaki: does the function tell you how long the actual string was?
14:56:35 <kmc> the latter is always UTF-8
14:56:38 <sbrg> kmc: Thanks. Got it working
14:56:42 <sbrg> but indeed, scumbag vim.
14:56:43 <kmc> the former is set by your locale on GHC ≥ 6.12
14:56:50 <kmc> and is something broken on earlier GHC
14:57:06 <dainanaki> mauke: it returns a null-terminated string.
14:57:19 <mauke> dainanaki: I bet it doesn't
14:58:19 <dainanaki> mauke: then how do I handle it?
14:58:22 <Draconx> dainanaki, if you have a library that (a) requires you to provide a buffer of unspecified size, (b) may potentially write any number of bytes to that buffer, and (c) provides no way to determine how big the buffer should be, the correct course of action is to immediately delete that library.
14:58:42 <mauke> dainanaki: what's the name and type of the function?
14:58:49 <dainanaki> Draconx: it knows the max amount of bytes it can write to the buffer
14:59:12 <Draconx> dainanaki, and what does it return if the buffer was not big enough?
14:59:29 <monochrom> use the logs http://tunes.org/~nef/logs/haskell/ to find out what bytes you really sent. don't assume. and don't just read the log in a web browser (which abstracts the bytes away). use wget to get the bytes verbatim, then use a hex editor to see them. don't just use a text editor (which abstracts the bytes away)
14:59:32 <dainanaki> Draconx: 0
14:59:47 <dainanaki> mauke: int git_repository_discover(char *repository_path, size_t size, const char *start_path, int across_fs, const char *ceiling_dirs)
14:59:51 <Draconx> dainanaki, what should you do if the function returns 0?
15:00:25 <dainanaki> mauke: the first arg is the buffer that it writes to, and the size_t tells how long the buffer is.
15:00:26 <monochrom> most programmers need the wake up call of seeing things at that low level so they know that WYSIWYG is a joke
15:09:21 * hackagebot hCsound 0.4.0 - interface to CSound API  http://hackage.haskell.org/package/hCsound-0.4.0 (JohnLato)
15:09:23 * hackagebot ListLike 3.1.2 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-3.1.2 (JohnLato)
15:13:37 --- mode: leguin.freenode.net set +o ChanServ
15:13:49 <monochrom> if your buffer is too small, it's a buffer overflow, so it's assigned to EOVERFLOW
15:14:02 <mauke> yeah, which has a completely different meaning :-|
15:14:25 * hackagebot listlike-instances 0.2 - Extra instances of the ListLike class  http://hackage.haskell.org/package/listlike-instances-0.2 (JohnLato)
15:14:27 * hackagebot loris 0.3 - interface to Loris API  http://hackage.haskell.org/package/loris-0.3 (JohnLato)
15:14:29 * hackagebot sndfile-enumerators 0.10.0.0 - Audio file reading/writing  http://hackage.haskell.org/package/sndfile-enumerators-0.10.0.0 (JohnLato)
15:14:34 <monochrom> but then many other errors can be coerced as some kind of overflow, too
15:16:33 <monochrom> type error is unification error --- substitution overflow
15:22:45 * hackagebot trifecta 0.39 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-0.39 (EdwardKmett)
15:23:32 <gwern> @quote netsplit
15:23:53 <benmachine> 00:03:46 -!- lambdabot [~lambdabot@li85-105.members.linode.com] has quit [*.net *.split]
15:24:30 --- mode: leguin.freenode.net set +o ChanServ
15:24:40 <aavogt> JoeyA: people usually discard information when parsing (stuff like trailing whitespace if not whitespase elsewhere)
15:24:40 <edwardk> sure
15:24:41 <edwardk> i welcome a test suite ;)
15:24:41 <aavogt> JoeyA: if you do that you won't be able to reconstruct the original from your AST
15:24:41 <JoeyA> aavogt: Indeed.  Does that make it not isomorphic, then?
15:24:55 <edwardk> JoeyA: correct. what you want is that parsing then pretty printing is idempotent
15:25:01 <Peaker_> It would be nice to provide parsing as a sort of partial lens
15:25:08 <edwardk> so if you do it again you get the same answer as if you did it once
15:25:09 <JoeyA> okay
15:25:28 <hiredman> JoeyA: it depends on how strict of an isomorphism you want
15:25:31 <edwardk> then you can turn category theoretic if you really want to and seek what the 'split' of that idempotent endomap iw
15:25:32 <roconnor> someone was pointing me to a bidirectional parsing paper that he/she though was related to lenses somehow.
15:25:33 <edwardk> er is
15:25:43 <Peaker_> Keeping around the "useless data" for printing
15:25:48 <JoeyA> I'm writing a little technical documentation, and I'm not sure "abstract syntax tree" is correct, given that the thing I'm parsing is not recursive.
15:26:00 <edwardk> peaker_: i have some old parser combinators that used to do that
15:26:13 <JoeyA> It's a list of various types of data.
15:26:18 <Peaker_> Cool! Where?
15:26:31 <edwardk> peaker_: in fact i blogged a bit about incremental folds. you can treat the metadata about the text and comments as such an incremental fold
15:26:55 <aavogt> haskell-src-exts sort of does that too, with the Annotated (or something) version of things
15:26:56 <edwardk> it was a couple years back when working with niklas broberg on the comment preserving haskell-src-exts
15:27:12 <Peaker_> I'm specifically interested in defining parsers bidirectionally without violating DRY
15:27:13 <edwardk> i was trying one approach, he went with another
15:27:24 <edwardk> Peaker: i've given up on that
15:27:31 <edwardk> i WANT to discard information during parsing
15:28:13 <edwardk> plus a space isn't always a space. it could be aligning things for semantic reasons beyond the ken of the parser
15:28:32 <Peaker_> Well, why not explicitly discard it from the full data, rather than as part of the parsing?
15:28:39 <edwardk> so if i use a refactoring browser and write the code back out, its hard to intuit which of those lined up bits of code were intentional
15:28:48 <acowley> another name for annotations attached to a parse is a ryu
15:28:49 <edwardk> because then I need an enormous AST
15:29:01 <edwardk> acowley: cute
15:29:07 <Peaker_> Why so enormous?
15:29:57 <Peaker_> Sounds like it should be a factor of  2 or so?
15:30:10 <edwardk> peaker: because let binds in expr needs to now contain the information about what the whitespace and comments were after the let, after the in, and each of the binds have to hold onto everything
15:30:27 <edwardk> and now i have to hold onto every parenthesis
15:30:40 <edwardk> i can't desugar at all during parsing
15:30:54 <edwardk> this is what made me stop writing parsers this way =)
15:31:17 <Peaker_> You can desugar post parsing into a different datatype..
15:31:32 <edwardk> its a factor of 2 or so during the initial parse, but then i have to make a slightly lighter parse tree so i can stomach working with it
15:31:50 <edwardk> so now i have 3x as much code in exchange for easier refactoring browsing
15:32:33 <edwardk> don't get me wrong, i like the idea of building a grammar that supports easy refactoring
15:33:03 <Peaker_> Unless defining the original "heavy" ast and parser/printer for that with a small dsl
15:33:05 <edwardk> but another problem is that the bidirectional parser/pretty printers have to give up the nice monadic syntax typically
15:33:27 <Peaker_> And then all the code is just heavy ast to light ast
15:33:47 <edwardk> and pretty printing has issues because i need to drag along a fresh name supply and then there are issues about alpha equivalence when i leverage it
15:34:21 <edwardk> what i'm looking at doing at the moment is going 'half way there' in trifecta.
15:34:40 <edwardk> where i'd make a Syntax class and put 'char' and a lot of other combinators in it, that can be used for both pretty printing and parsing
15:34:59 <edwardk> and then portions of the AST would work bidirectionally
15:35:52 <edwardk> the reason i want to go that far is to support typeahead during parsing
15:36:02 <edwardk> tab completion for arbitrary grammars
15:36:11 <Peaker_> I tried writing combinators that allowed defining csv format (bidirectionally) and also have up
15:36:15 <edwardk> by letting you hook in annotations about the parser
15:36:22 <Peaker_> Gave*
15:36:37 <edwardk> that much seems tractable
15:37:12 <Peaker_> Csv has some horrible escaping rules :)
15:37:49 <Peaker_> (probably the non-research department of Microsoft)
15:38:13 <edwardk> heh
15:39:18 <jmelesky> anyone have any information on pngload?
15:39:18 <edwardk> trying to figure out the right way to bolt in ctags support into my parsers
15:39:59 <edwardk> in particular trying to figure out the nicest way to generate the embedded ex command
15:41:09 <DukeDave> edwardk: What are you working on?
15:41:28 <edwardk> DukeDave: i have a parser combinator library that throws the kitchen sink in in terms of extra features.
15:41:55 <DukeDave> Aha, I just saw 'ctags' and got excited :)
15:41:55 <mm_freak> can I/O be modelled as a comonad?  i remember reading somewhere that it can
15:42:00 <edwardk> one of the things i'd like to add is an annotation or two that you can sprinkle through your grammar to get an interval map or other structure describing what i want to send to ctags
15:42:06 <edwardk> mm_freak: yeah but it was a lie
15:42:12 <edwardk> mm_freak: OI doesn't work
15:42:14 * DukeDave still wants a kick-ass vim for Haskell
15:42:27 <benmachine> edwardk: do you mean "isn't good" or "is actual fiction"
15:42:35 <mm_freak> edwardk: specific mathematical reasons?  or just the same reasons why IO "doesn't work"?
15:42:48 <edwardk> benmachine: as in has horrible intractable problems due to the fact that every functor in haskell is strong
15:43:00 <jmelesky> the email address for Marko (the pngload guy) is bouncing, and i don't know how long that's been the case
15:43:07 <edwardk> so it intrinsically admits unsafePerformIO
15:43:12 <Peaker_> Ctags, as in generating ctags?
15:43:15 <Peaker_> My pet peeve about ctags and etags is that they don't preprocess c code..
15:43:16 <Peaker_> Eclipse gets so much further mainly because of that
15:43:23 <edwardk> Peaker_: yeah
15:43:46 <edwardk> Peaker_: well you're in luck. i have a c preprocessor that is getting bolted onto trifecta, so it'll be post-preprocess ;)
15:44:13 <edwardk> so a language.c built on trifecta could spit out correct ctags in that sense
15:44:18 <mm_freak> edwardk: i can't even think of a mental model for OI
15:44:26 <mm_freak> what was the basic idea?
15:44:35 <edwardk> mm_freak: it is a mess, they wanted some kind of possible world interpretation
15:45:16 <mm_freak> edwardk: is 'extract' the problem?  or would the problems already arise with Extend?
15:45:52 <Peaker_> I think language.c is already correct in that regard, but I haven't heard of any use of it for ctags
15:46:00 <edwardk> mm_freak: the whole thing was just a bad idea. i talk in my blog about how every comonad in haskell gives rise to a monad transformer. you'd immediately get an IO monad transformer just from that
15:46:17 <mm_freak> i see
15:46:20 <thoughtpolice_> i'm honestly pretty excited edwardk has decided to give us what may end up being the ultimate parsing library. :P trifecta: parsers for real humans, real languages.
15:46:33 <thoughtpolice_> Peaker_: language.c invokes GCC to do preprocessing, then builds an AST from that result
15:46:35 <edwardk> Peaker_: well, what i want is tag file generation for arbitrary languages
15:46:39 <kmc> it's not the ultimate parsing library unless you get a prettyprinter for free
15:46:48 <kmc> it may still be a damn cool parsing library
15:46:52 <kmc> but it's not the ultimate ;)
15:46:53 <Jafet> (Real superhumans)
15:46:54 <applicative> what is the leading characteristic of this parsing utopia, trifecta?
15:47:25 <kmc> i saw one paper that promised this but it used arrows like woah and i kinda zoned out after two pages
15:47:27 <acowley> nobody notices the bugs
15:47:34 <edwardk> applicative: clang-style diagnostics, built-in syntax highlighting (hscolour-like) for your own languages
15:47:36 <acowley> applicative: very descriptive error messages
15:47:39 <edwardk> kmc: yeah and the approach is awful
15:47:46 <edwardk> all bidirectional parsing papers have been awful
15:47:57 <thoughtpolice_> i think i saw that paper too, it was on /r/haskell sometime in recent memory
15:48:10 <applicative> so I need to invent a programming language to make adequate use of it?
15:48:27 <edwardk> applicative: compatibility with monad transformers in your parser, nicer token parsers than parsec
15:48:53 <Peaker_> I like the idea of bidirectionally for free
15:48:57 <edwardk> efficient ability to 'slice' up the input and backtrack
15:49:06 <edwardk> i like the idea, but i've yet to be sold a usable implementation
15:49:06 <aavogt> edwardk: would there be some way to get highlighting for keywords that are not reserved words?
15:49:11 <Peaker_> It's hard in Haskell though
15:49:18 <edwardk> aavogt: yes, you can add a manual annotation if you want
15:49:50 <aavogt> aha, highlightToken ???
15:50:40 <edwardk> aavogt: highlight Reserved $ censor (const mempty) $ lexeme (string "qualified")
15:50:43 <edwardk> or something like that
15:50:58 <edwardk> actually with "string" the censor isn't needed
15:51:09 <edwardk> highlight Reserved $ lexeme (string "qualified")
15:51:21 <edwardk> yeah it flipped from highlightToken to highlight recently IIRC
15:52:18 <edwardk> peaker: thats why i'm leaning towards only makingbits and pieces bidirectional
15:52:41 <applicative> is the source on github or somewhere?
15:52:50 <edwardk> peaker: that way a lot of stuff like reserved word identification, etc. works (at least up to the idempotence of (pretty . parse)
15:52:55 <edwardk> yeah
15:53:05 <edwardk> http://github.com/ekmett/trifecta
15:53:58 <edwardk> haddocks: http://ekmett.github.com/trifecta/
15:54:37 <edwardk> oh nice, the 0.36.3 haddocks on hackage work
15:54:46 <edwardk> http://hackage.haskell.org/package/trifecta-0.36.3 so i'll probably get haddocks on there from here out
15:55:10 <aavogt> @hoogle censor
15:55:11 <lambdabot> Control.Monad.Writer.Class censor :: MonadWriter w m => (w -> w) -> m a -> m a
15:55:35 <edwardk> aavogt: if you want to 'unhighlight something you can use censor (const mempty)
15:57:07 <siracusa> In Cabal files, how do you specify where a data file from directory <foo> should be stored in the final installation?
15:57:43 <kmc> data file specifies you
15:57:52 <kmc> http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
15:58:52 <kmc> heh, 'censor' is a good name
15:58:58 <kmc> i would also accept 'mitm'
16:00:03 <Jafet> witm?
16:00:37 <kmc> that too
16:00:45 <edwardk> kmc: hah spoken like a true security guy ;)
16:01:39 <acowley> there should also be a censer that emits small fragments of its argument
16:02:41 <edwardk> clearly it should replace non-whitespace with *
16:03:11 <acowley> which would do an excellent job of confusing censoring and censering
16:03:20 <acowley> your users' heads will never stop spinning
16:04:22 <aavogt> edwardk: it doesn't seem to work http://hpaste.org/50802
16:04:51 <edwardk> aavogt: i don't have the highlighting turned on in the rendered fragments yet
16:05:01 <edwardk> the interval map however, is accumulated in the parser
16:07:20 <edwardk> aavogt: i just need to factor out the logic in https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Rope/Highlighted.hs#L76 into something so i can reuse it here: https://github.com/ekmett/trifecta/blob/master/Text/Trifecta/Diagnostic/Rendering/Prim.hs#L82
16:07:41 <aavogt> good to know it's easy :)
16:08:07 <edwardk> yeah i just don't want to cut and paste the same 8 lines a 3rd time ;)
16:08:30 <edwardk> so i'm looking for a useful common abstraction
16:09:01 <edwardk> but i may just bite the bullet and put it in as is
16:11:39 <Peaker_> Censor implies deletion of content imo, how about post process?
16:12:21 <aavogt> it might be nice to include some (more) functions with capabilities somewhere between parseTest and unparser
16:12:23 <edwardk> it was just that highlighting gets accumulated in a monoid
16:12:40 <edwardk> aavogt: sure, just haven't needed them yet. i welcome others
16:12:45 <edwardk> there is a parseFile as well
16:12:52 <edwardk> in Text.Trifecta.Parser.ByteString
16:13:04 <edwardk> and a parseFileEx
16:13:40 <Peaker_> Ex, as in the misc suffix of win api functions? ;)
16:13:58 <edwardk> yeah
16:14:31 <applicative> whoa, an examples folder by edwardk, who'd have imagined it possible?
16:14:38 <edwardk> hah
16:14:44 <edwardk> well its a crap example ;)
16:14:55 <edwardk> dylukes STGMA is probably a better example at this point
16:15:07 <applicative> STGMA? hmmm
16:15:28 <edwardk> https://github.com/ekmett/STGMA
16:15:44 <edwardk> https://github.com/ekmett/STGMA/blob/master/src/Scan.hs being the parser so far
16:53:15 <zrbecker> I am trying to import a module in haskell, but I can't get it to work. Here is a simple example that is not working, any help? http://pastebin.com/ZeXpddd6
16:54:21 <kmc> pastebin.com is trying to put radio shack ads over your code
16:54:28 <kmc> it is the most obnoxious pastebin site there is
16:54:39 <kmc> could you copy it to hpaste.org?
16:54:41 <shachaf> Where's mauke when you need him?
16:54:41 <nisstyre> codepad.org
16:54:43 <hpaste> glguy pasted “printf a list of args” at http://hpaste.org/50804
16:54:44 <mauke> here
16:54:44 <glguy> Do I really have to go to these lengths to printf a list of things?
16:54:45 <kmc> (mauke has a bot that does this but 's not here)
16:54:46 <nisstyre> or hpaste
16:54:51 <mauke> shachaf: I'm getting "something done fucked up"
16:54:56 <mauke> meaning posting to hpaste failed
16:55:05 <kmc> what does "printf a list of things" mean?
16:55:30 <kmc> the goal here is [PrintfableStuff] -> String ?
16:55:37 <glguy> yeah
16:55:39 <zrbecker> http://codepad.org/AidVFLtQ There.
16:55:45 <kmc> these are approximately the lengths i expect, yeah
16:55:49 <shachaf> glguy: I think some unexported functions from Text.Printf will let you do that more easily.
16:56:05 <shachaf> Or, hmm, maybe not with the existential type.
16:56:09 <glguy> shachaf: I'm certain that if they exported more functions this would be unnecessary
16:56:14 <kmc> zrbecker, ghci Test.hs
16:56:17 <kmc> or :load Test.hs
16:56:25 <mauke> glguy: why are you doing this?
16:56:35 <mauke> glguy: but have you looked at Text.Printf.Mauke?
16:56:43 <glguy> I haven't looked at that module
16:56:47 <zrbecker> k thanks that works
16:56:59 <nisstyre> glguy: the file is not in GHC's path
16:57:01 <glguy> mauke: part of an interpreter. The number of arguments and format string are not known at compile time
16:57:06 <nisstyre> er
16:57:10 <nisstyre> zrbecker:
16:57:12 <nisstyre> not glguy
16:57:16 <mauke> glguy: then you probably shouldn't use printf
16:57:25 <glguy> mauke: That isn't the question :)
16:58:09 <mike-burns> Whoa you got printf to work with a list!
16:58:53 <kmc> . o O ( vprintf )
16:59:26 * glguy changes the name :)
16:59:36 <Veinor> i guess the question is, why are you trying to use printf?
17:00:02 <mike-burns> It's the only thing on Hackage that does text formatting of that power, last I looked.
17:00:04 <glguy> To reuse the existing format string parser
17:00:10 * shachaf contemplates which of C-style and Haskell-style varargs he dislikes more.
17:00:23 <mike-burns> varargs doesn't belong in Haskell.
17:00:35 <mike-burns> Hm, that's too extreme.
17:00:42 <mike-burns> varargs isn't useful for printf in Haskell.
17:00:56 <aavogt> @hackage xformat
17:00:57 <lambdabot> http://hackage.haskell.org/package/xformat
17:01:33 <mike-burns> That's also vararg.
17:01:39 <aavogt> that one makes the "formatting string" have a type which determines the arguments to take
17:01:49 <mauke> kmc, shachaf: fixed
17:01:52 <aavogt> so you can't really manipulate the formatting string
17:02:01 <mauke> hpaste.org has dropped all languages except haskell and ruby
17:02:31 <JoeyA> Is the type ByteString defined in Data.ByteString the same type as that defined in Data.ByteString.Char8 ?
17:02:38 <JoeyA> Namely, are they interchangeable?
17:03:03 <mauke> Data.ByteString.Char8 doesn't define a type
17:03:19 <kmc> Char8 is an alternative interface to the same ByteString type
17:03:25 <kmc> it's also a terrible, terrible hack that you should avoid
17:03:46 <c_wraith> It's also so useful it's not worth avoiding, many times.
17:03:56 <mauke> just like printf
17:04:14 <totte> mauke: Curious. Why Ruby?
17:04:14 <c_wraith> pretty similary, yes
17:04:19 <c_wraith> err, similar
17:04:23 <Jafet> I stridently believe that Char8 exists to annoy us with other people's confusion about it
17:04:27 <mike-burns> Except Char8 is useful.
17:04:27 <mauke> totte: er, no idea
17:04:32 <kmc> it's kind of like if I defined a library full of useful functions on [Double] except that, secretly, it truncates all the numbers to Int first
17:05:08 <aavogt> what's so bad about that?
17:05:12 <c_wraith> kmc: It's just like you defined a library full of useful functions on Word8, but the compiler allows you to create constants > 255
17:05:26 <kmc> Char8 is useful if you want to write code that's only useful to people who speak English
17:05:44 <kmc> it's also useful if you want to encourage another generation of programmers to repeat the mistakes of the past 40 years
17:05:45 <c_wraith> kmc: Char8 is useful if you want to write code that parses text formats
17:05:53 <shachaf> aavogt: Careful, kmc will accuse you of being racist if you keep going.
17:05:56 <shachaf> Whoops, too late.
17:05:59 <penryu> also useful to people that speak American.
17:06:06 <mauke> don't be naïve
17:06:10 <kmc> shachaf, you should start a KMC Fan Club webpage
17:06:14 <kmc> you can be the founding member
17:06:16 <shachaf> Yes!
17:06:18 * shachaf is a kmc fan.
17:06:37 <JoeyA> let encode = Codec.Binary.UTF8.String.encode; pack = Data.ByteString.pack
17:06:40 <shachaf> "main is always a function here"
17:06:42 <aavogt> dynamic webscale written in C/C++
17:06:42 <dainanaki> \me too
17:06:46 * dainanaki too
17:06:55 <JoeyA> Is pack . encode slower than the functionality provided by Data.ByteString.UTF8 ?
17:07:11 <JoeyA> :i pack
17:07:45 <kmc> shachaf, no Haskell allowed, then? :(
17:08:59 <glguy> JoeyA: https://github.com/glguy/utf8-string/blob/master/Data/ByteString/UTF8.hs
17:09:04 <glguy> fromString xs = B.pack (encode xs)
17:09:24 <shachaf> kmc: main :: World -> (forall a. a, World)
17:09:28 <kmc> oh no
17:10:20 <Jafet> main :: IO RealWorld
17:10:46 <kmc> IO WebScale
17:10:49 <JoeyA> Ah, so it is the same, then.
17:10:49 * Jafet leaves it as an exercise to figure out what that would mean.
17:11:04 <kmc> SpiderSnake would be a good name for a web framework
17:11:36 <JoeyA> glguy: Thanks.  Why does it say this? "It does not exactly match the output of the Codec.Binary.UTF8.String output for invalid encodings as the number of replacement characters is sometimes longer."
17:11:41 <_Ray_> Can data constructors be used as functions in any way?
17:11:47 <kmc> in all ways
17:11:48 <JoeyA> Shouldn't it produce the same result if it's using the same function?
17:11:52 <JoeyA> Or is truncation going on?
17:11:55 <_Ray_> Huh. Interesting.
17:12:00 <kmc> :t Just
17:12:01 <lambdabot> forall a. a -> Maybe a
17:12:05 <kmc> > let f = Just in f 3
17:12:06 <lambdabot>   Just 3
17:12:14 <_Ray_> > map Just [3,5]
17:12:15 <lambdabot>   [Just 3,Just 5]
17:12:43 <glguy> JoeyA: that has to do with the decode case
17:13:01 <JoeyA> "SpiderSnake" sounds like the next major JavaScript interpreter, written in Python.
17:13:07 <glguy> JoeyA: if you try to decode garbage data, replacement characters will be inserted where garbage was found
17:13:11 <roconnor> > catMaybes [Just 3,Just 5]
17:13:12 <lambdabot>   [3,5]
17:14:33 <glguy> JoeyA: One of the decode functions tries to leave a single replacement character for each approximate garbage code point you provided. The one in Data.ByteString.UTF8 just replaces every byte of garbage with a replacement character
17:15:16 <JoeyA> glguy: Oh, so it's just a difference in implementation, then?
17:16:24 <glguy> JoeyA: yeah. For correctly UTF-8 encoded data it won't be different
17:16:26 <Jafet> I prefer the decoder that raises exceptions
17:16:50 <Jafet> That is usually what you want to happen
17:17:01 <glguy> most of the situations I have in mind would consider that the wrong behavior
17:17:08 <glguy> it's a matter of circumstance
17:17:09 <_Ray_> :src catMaybes
17:17:14 <_Ray_> @src catMaybes
17:17:14 <lambdabot> catMaybes ls = [x | Just x <- ls]
17:17:15 <kmc> you sometimes need one or the other
17:17:36 <_Ray_> huh, didn't know one could say Just x <- ls.
17:17:36 <kmc> @undo [x | Just x <- ls]
17:17:38 <lambdabot> concatMap (\ a -> case a of { Just x -> [x]; _ -> []}) ls
17:17:52 <kmc> _Ray_, yeah, pattern match failure in list comprehensions causes that element to be dropped
17:18:02 <kmc> it's probably the most useful part of the list comprehension feature
17:18:02 <edwardk> aavogt: your example should be colorful (well, i don't have a color for Constructor, but otherwise would be colorful) now
17:18:14 <_Ray_> Is it different from Just x <- ls inside the [] monad?
17:18:14 <kmc> other stuff can be easily replaced with map and filter and the code is usually shorter
17:18:26 <kmc> but if you're using that property, it's hard to come up with a similarly concise alternative
17:18:30 <kmc> _Ray_, it's the same
17:18:56 <kmc> > let f ls = do { Just x <- ls; return x } in f [ Just 3, Nothing, Just 7 ]
17:18:58 <lambdabot>   [3,7]
17:19:08 <Jafet> List comprehensions can be mechanically translated to list monad actions
17:19:09 <_Ray_> right. cool :)
17:19:10 <kmc> @undo do { Just x <- ls; return x }
17:19:10 <lambdabot> ls >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
17:19:16 <kmc> fail _ = []
17:24:16 <augur> anyone know of a blog post about non-uniform types in haskell?
17:26:50 <edwardk> did hackagebot die?
17:27:29 <kmc> of exhaustion, edwardk
17:27:31 <mauke> preflex: seen hackagebot
17:27:31 <preflex>  hackagebot was last seen on #haskell 2 hours, 13 minutes and 6 seconds ago, saying: * hackagebot sndfile-enumerators 0.10.0.0 - Audio file reading/writing  http://hackage.haskell.org/package/sndfile-enumerators-0.10.0.0 (JohnLato)
17:27:44 <edwardk> there have been updates since then
17:29:05 <JoeyA> What is the best way to use character literals when dealing with Word8 ByteStrings?
17:29:14 <JoeyA> (string literals, too)
17:29:18 <edwardk> Data.ByteString.Char8
17:29:23 <mauke> S.pack "foo"
17:29:25 <edwardk> or Data.ByteString.UTF8
17:29:33 <edwardk> the latter comes from utf8-string
17:29:48 <JoeyA> I think I'll use Char8.  The data I'm parsing is very likely not to be UTF-8.
17:29:51 <edwardk> depending on if you need non-ascii
17:30:07 <JoeyA> My literals will all be ASCII.
17:30:19 <mauke> sounds like IRC
17:30:39 <Jafet> IRC is (nearly) Char8
17:31:32 <Jafet> With some features of VT100
17:31:53 * roconnor failed to change his nick to ☃
17:34:03 <monochrom> once upon a time, they said their dates were likely not beyond year 2000 too
17:39:27 * hackagebot normaldistribution 1.1.0.3 - Minimum fuss normally distributed random values.  http://hackage.haskell.org/package/normaldistribution-1.1.0.3 (BjornBuckwalter)
17:40:42 <JoeyA> What's the difference between Data.Attoparsec and Data.Attoparsec.UTF8 ?
17:40:45 <JoeyA> err, .Char
17:41:11 <JoeyA> Ah, the functions take Word8 arguments in the former.
17:43:01 <kmc> what's the best way to deal with floating-point literals in [Maybe Bool]?
17:43:12 <coppro> what.
17:43:16 <JoeyA> lol
17:43:34 <JoeyA> data Bool = True | False | FileNotFound
17:43:36 <JoeyA> hope that helps.
17:44:36 <jmcarthur> unparser :: forall r. (a -> ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> (ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> (a -> ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> (ErrState e -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r) -> ErrLog e -> Bool -> Delta -> ByteString -> It Rope r
17:44:39 <jmcarthur> :o
17:44:42 <MacMagnus> im learning haskell, and wonder if there is a easy way to generate a random number
17:44:48 <mauke> MacMagnus: randomIO
17:44:49 <kmc> :t randomRIO
17:44:50 <lambdabot> forall a. (Random a) => (a, a) -> IO a
17:44:59 <JoeyA> > randomRIO (1, 6)
17:45:00 <lambdabot>   <IO Integer>
17:45:03 <mauke> :t randomIO
17:45:04 <lambdabot> forall a. (Random a) => IO a
17:45:17 <JoeyA> @i randomRIO
17:45:17 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
17:45:27 <JoeyA> :i randomRIO
17:45:29 <kmc> "Trifecta gives you enough rope"
17:45:36 <JoeyA> (how do you do that with lambdabot?)
17:45:41 <mauke> JoeyA: no.
17:45:43 <kmc> GHCi's :i? doesn't have
17:45:44 <edwardk> =)
17:45:48 <kmc> @hoogle randomRIO
17:45:48 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
17:45:50 <JoeyA> Oh, hoogle
17:45:51 <MacMagnus> thx :D
17:45:52 <JoeyA> duh
17:53:46 <kmc> :t let f x = readChan ?c >>= ($ x) >>= f in f
17:53:47 <lambdabot> Not in scope: `readChan'
17:54:50 <kmc> it would be fun if lambdabot supported executing concurrent code
17:55:40 <kmc> in fact, there's no reason she shouldn't execute STM actions, right?
17:56:10 <shachaf> That depends on what you mean by "reason".
17:56:17 <copumpkin> does she allow ST?
17:56:22 <kmc> yeah
17:56:27 <shachaf> > runST (return 3)
17:56:28 <lambdabot>   3
17:56:34 <shachaf> > id runST (return 3)
17:56:35 <lambdabot>   Couldn't match expected type `m t'
17:56:35 <lambdabot>         against inferred type `forall s....
17:56:41 <copumpkin> yay
17:56:44 <kmc> > runST (do { x <- newSTRef 3; modifySTRef (+1) x; readSTRef x })
17:56:45 <lambdabot>   The section `GHC.Num.+ 1' takes one argument,
17:56:45 <lambdabot>  but its type `GHC.STRef.STRe...
17:56:48 <copumpkin> > runST . return $ 3
17:56:48 <lambdabot>   Inferred type is less polymorphic than expected
17:56:49 <lambdabot>    Quantified type variable...
17:56:54 * copumpkin hugs ST
17:56:59 <JoeyA> If an exception is thrown in a thread, and nothing catches it, is the entire program brought down?
17:57:05 <kmc> yes
17:57:09 <mauke> no
17:57:11 <copumpkin> > runST $ return 3
17:57:12 <lambdabot>   3
17:57:13 <kmc> oh?
17:57:21 <copumpkin> > runST `id` return 3
17:57:22 <lambdabot>   Couldn't match expected type `m t'
17:57:22 <lambdabot>         against inferred type `forall s....
17:59:39 <hpaste> mauke pasted “threads” at http://hpaste.org/50806
18:00:22 <shachaf> mauke: Doesn't forkIO install a generic handler?
18:00:47 <mauke> no idea
18:00:57 <shachaf> @ty fix forever
18:00:58 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a
18:01:22 <JoeyA> mauke: Thanks.
18:01:48 <MacMagnus> How can I make a normal Int out of randomRIO?
18:01:54 <mauke> MacMagnus: you can't
18:02:12 <copumpkin> where's kmc's faq when you need it?
18:02:16 <MacMagnus> thats what i thought
18:02:21 <kmc> http://haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
18:02:27 <copumpkin> thank you kmc!
18:02:38 <JoeyA> > unsafePerformIO (randomRIO (1,6)) -- but that's bad...
18:02:38 <lambdabot>   Not in scope: `unsafePerformIO'
18:02:48 <mauke> did you mean: unsafeCoerce
18:02:54 <copumpkin> lol
18:03:06 <glguy> Cale's introduction to IO explains that "Note that there is no function: unsafe :: IO a -> a"
18:03:08 <MacMagnus> thanks
18:03:31 <kmc> there's no Int hidden inside IO Int
18:03:43 <glguy> lies!! you just don't want to share
18:03:51 <kmc> any more than there's a cake hidden inside a recipe
18:03:53 <Eduard_Munteanu> MacMagnus: one usual way of getting random numbers into pure functions is to get an infinite list of such numbers in IO, then pass it around.
18:03:55 <mauke> how do I convert IO Int to IO?
18:04:03 <kmc> unsafeCoerceKind
18:04:26 <Jafet> unsafePerformInt
18:04:26 <glguy> mauke: drop the last 4 characters
18:04:41 <mauke> Jafet: correct!
18:04:52 <kmc> > iterate (\x -> "IO (" ++ x ++ ")") ""
18:04:57 <lambdabot>   mueval-core: Time limit exceeded
18:05:09 <glguy> > fix ("IO ("++)
18:05:09 <Eduard_Munteanu> :t (>> return ())
18:05:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
18:05:11 <lambdabot>   "IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO...
18:05:22 <shachaf> unsafeErce
18:05:37 <kmc> > fix (\x -> "IO (" ++ x ++ ")")
18:05:38 <lambdabot>   "IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO (IO...
18:05:59 <ion> fix (("IO (" ++) . (++ ")"))
18:06:14 <mauke> > fix (printf "IO (%s)")
18:06:16 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:06:16 <lambdabot>    `Text.Printf.PrintfArg a...
18:06:21 <kmc> haha
18:06:30 <glguy> > fix (printf "IO (%s)") :: String
18:06:34 <lambdabot>   mueval-core: Time limit exceeded
18:06:35 <kmc> > fix (printf "%s" :: String -> String)
18:06:39 <lambdabot>   mueval-core: Time limit exceeded
18:06:44 <kmc> > iterate (printf "%s" :: String -> String) "☺"
18:06:45 <lambdabot>   ["\9786","\9786","\9786","\9786","\9786","\9786","\9786","\9786","\9786","\...
18:06:47 <glguy> we just need more time...
18:06:55 <ion> Why u so strict, printf?
18:07:07 <kmc> why %u so strict
18:07:34 <copumpkin> > fix (printf "ohai %s" :: String -> String)
18:07:38 <lambdabot>   mueval-core: Time limit exceeded
18:07:45 <mauke> huh
18:07:52 <mauke> it works with Text.Printf.Mauke
18:07:57 <copumpkin> see, I'd expect the original one to time out
18:08:08 <mauke> EVERYBODY UPGRADE
18:08:11 <copumpkin> (although I'd want to see a " first)
18:08:16 <Jafet> > printf "abc %s def %s" "123" :: String
18:08:17 <lambdabot>   "abc 123 def *Exception: Printf.printf: argument list ended prematurely
18:08:32 <shachaf> mauke: Are you saying mauke is a new version of augustss?
18:08:40 <mauke> apparently
18:09:06 <mauke> "abc 123 def *** Exception: Text.Printf.Mauke.printf: missing argument
18:10:24 <Jafet> "f *** Exception"
18:16:08 <tgeeky> cool. we finally have a pretty printer that curses at you!
18:19:30 <pusherman> Is there anyone kind enough to critique a library I have been workiing on. It is still very early but is intended to be a replacement for libgit. https://github.com/MarcusWalz/hgit
18:23:59 <tgeeky> looks nice to me
18:24:53 <dainanaki> pusherman: it's funny that you put this up. I've been working on something very similar.
18:26:51 <dainanaki> ok, not that similar. Mine deals with the internals and is maybe a bit lower level/
18:27:06 <tgeeky> 'bout time
18:27:17 <tgeeky> yeah this one is wrapping command line stuff
18:27:23 <tgeeky> which is fine, if it's testable
18:30:02 <pusherman> diananaki: what exactly does yours do? Mine just wraps git
18:30:28 <tgeeky> pusherman: probably mimics git's internals
18:30:43 <milktrader> What is the main Haskell repo for modules or packages?
18:31:10 <tgeeky> milktrader: hackage
18:31:17 <tgeeky> @link hackage
18:31:18 <lambdabot> Maybe you meant: kind list ping
18:31:20 <pusherman> milktrader: http://hackage.haskell.org/
18:31:59 <shachaf> @hackage -- It's its own command!
18:31:59 <lambdabot> http://hackage.haskell.org/package/-- It's its own command!
18:32:02 <shachaf> Er.
18:32:08 <tgeeky> doh!
18:32:09 <shachaf> @hackage
18:32:09 <lambdabot> http://hackage.haskell.org
18:32:17 <milktrader> perfect, thanks for hackage
18:34:03 <milktrader> already I found Haskell bindings to libsvm
18:35:43 <milktrader> in R, there is a base function that one calls to download and 'install' and 'load' packages. Is there a similar function in Haskell?
18:35:57 <shachaf> milktrader: There's cabal-install
18:36:00 <tgeeky> cabal is the package manager
18:36:02 <shachaf> `cabal install foo`
18:36:10 <shachaf> cabal is not a package manager, however, or so I'm repeatedly told.
18:36:18 <shachaf> But it'll get dependencies and such for you.
18:36:31 <tgeeky> shachaf: *scratches head*
18:36:45 <MacMagnus> ive read this, but cannot remember... how do i do a integer-division on a number?
18:36:49 <kmc> :t div
18:36:50 <lambdabot> forall a. (Integral a) => a -> a -> a
18:36:55 <kmc> > 7 `div` 2
18:36:57 <lambdabot>   3
18:37:00 <MacMagnus> thx :S
18:37:01 <shachaf> > 7 `mod` 2
18:37:02 <lambdabot>   1
18:37:03 <MacMagnus> :D
18:37:04 <shachaf> Er.
18:37:17 <kmc> > 7 {- wait for it.... -} `divMod` 2
18:37:18 <shachaf> > 7 `quot` 2
18:37:18 <lambdabot>   (3,1)
18:37:19 <lambdabot>   3
18:37:48 <kmc> @check \m n -> divMod m n == quotRem m n
18:37:50 <lambdabot>   "*Exception: divide by zero
18:37:57 <kmc> @check \m n -> n == 0 || (divMod m n == quotRem m n)
18:37:58 <lambdabot>   "Falsifiable, after 6 tests:\n1\n-6\n"
18:39:48 <milktrader> got it, cabal
18:40:34 <shachaf> @check \m -> m == 'a' ==> m == 'a'
18:40:35 <lambdabot>   No instance for (Test.QuickCheck.Testable
18:40:37 <lambdabot>                     (Test.QuickCh...
18:40:38 <shachaf> What's wrong with lambdabot?
18:40:46 <kmc> what's wrong with YOU
18:41:13 <shachaf> kmc gets straight to the point. :-(
18:41:38 <kmc> @vixen what's wrong with shachaf?
18:41:40 <lambdabot> i dunno...
18:41:54 <shachaf> @vixen what's wrong with you?
18:41:55 <lambdabot> let's don't talk about that
18:45:53 <Axman6> heh
18:52:21 <dainanaki> Axman6: I've been wanting to ask you, you are interning at Tsuru Capital right?
18:53:00 <Axman6> i did for 3 months at the end of last year
18:53:10 <dainanaki> How did you like it?
18:53:19 <Axman6> it was awesome, i'd highly recommend it
18:53:39 <dainanaki> good to hear.
18:53:53 <dainanaki> i've been obsessing about it lately.
18:58:16 <mparusinski> hello everybody
18:58:44 <mparusinski> I have a question regarding if the State monad is actually applicable to my problem
18:58:55 <dainanaki> shoot.
19:01:32 <mparusinski> I need create functions of the form (a -> m (b, a)). Those functions are suppose to help generate outputs of the form tybe b; type a is a form of a state.
19:01:43 <mparusinski> After each function call I get a new state
19:01:47 <mparusinski> of type a
19:01:57 <mparusinski> a bit like the random number generators
19:02:01 <dainanaki> That sounds exactly applicable.
19:02:05 <liyang> StateT a m b?
19:02:13 <mparusinski> next :: g -> (g, a)
19:02:15 <mparusinski> thanks
19:02:40 <byorgey> @unmtl StateT a m b
19:02:40 <lambdabot> a -> m (b, a)
19:02:41 <mparusinski> states are for the time being the most obscure monad to be but that will help understand them
19:02:44 <byorgey> tada!
19:02:58 <Axman6> @unmtl StateT b m a
19:02:58 <lambdabot> b -> m (a, b)
19:03:01 <Axman6> >_>
19:03:10 <Axman6> oh wait, the a was the state
19:03:15 <Axman6> @unmtl StateT s m a
19:03:15 <lambdabot> s -> m (a, s)
19:03:38 <byorgey> I was just trying to get it to match the type mparusinski said
19:03:50 <Axman6> yeah
19:03:59 <Axman6> i missed that it was a -> not b ->
19:06:36 <Axman6> mparusinski: StateT is exactly what you've described. if you've never used monad transformers, it's probably one of the easiest to start with
19:07:35 <mister_m> could someone explain to me how "reverse          =  foldl (flip (:)) []" works? I understand that this is an example of currying, but I'm not sure how flip is working in this context
19:08:32 <Axman6> > foldl (\xs x -> x:xs) [] [a,b,c]
19:08:33 <lambdabot>   [c,b,a]
19:08:42 <Axman6> > foldl (\xs x -> x `f` xs) [] [a,b,c]
19:08:43 <lambdabot>   No instance for (SimpleReflect.FromExpr [a])
19:08:43 <lambdabot>    arising from a use of `e_1'...
19:08:48 <Axman6> > foldl (\xs x -> x `f` xs) [] [a,b,c] :: Expr
19:08:49 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
19:08:49 <lambdabot>         against inferred ...
19:08:52 <Axman6> bleh
19:08:59 <Axman6> > foldl (\xs x -> x `f` xs) [z [a,b,c] :: Expr
19:09:00 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:09:02 <Axman6> > foldl (\xs x -> x `f` xs) z [a,b,c] :: Expr
19:09:03 <lambdabot>   f c (f b (f a z))
19:09:04 <tgeeky> > foldl (\xs x -> x `f` xs) [] [a,b,c] :: [Expr]
19:09:05 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
19:09:05 <lambdabot>    arising fr...
19:09:33 <mister_m> Axman6: that first one makes more sense
19:09:54 <Axman6> > foldl (\xs x -> x * xs) z [a,b,c] :: Expr
19:09:55 <lambdabot>   c * (b * (a * z))
19:10:03 <Axman6> where (*) = (:)
19:10:15 <Axman6> > foldl (\xs x -> xs * x) z [a,b,c] :: Expr
19:10:16 <lambdabot>   z * a * b * c
19:10:59 <Axman6> mister_m: basically, what it's doing is starting with the empty list, and adding each element from the original list to the front of the new list
19:11:37 <Axman6> it's similar to: rev xs = r xs [] where r [] ys = ys; r (x:xs) ys = rev xs (x:ys)
19:11:49 <Axman6> s/rev/r in the last clause
19:12:41 <mister_m> can I use :: Expr or something similar in ghci?
19:13:14 <azaq23> mister_m: Expr is part of the simple-reflect package. Install it and you can use it
19:14:06 <mister_m> azaq23: fantastic
19:14:35 <mister_m> Axman6: thank you for the additional examples. The first one you posted made much more sense than the seemingly empty flip(:)
19:14:45 <mister_m> flip (:) rather
19:15:04 <NemesisD> hi all. i was wondering if you guys could help me figure out if i've got the right idea for some code using enumerator
19:16:21 <NemesisD> i need to read from a file, chunk it by lines, parse each line with aeson and transform that result then encode that result and push it to stdout
19:17:22 <NemesisD> so is the proper setup then: enumerator from file handle -> enumeratee (chunking) -> enumeratee (parse) -> enumeratee (transform) -> iteratee (stdout) ?
19:17:47 <Axman6> sounds like a good place to start
19:19:57 <coppro> :won 2
19:20:37 <Axman6> how many did you :lose?
19:21:31 <mister_m> can I tell cabal to install dependencies?
19:23:16 <Eduard_Munteanu> mister_m: cabal install --only-dependencies
19:23:27 <Eduard_Munteanu> IIUC what you need.
19:23:49 <Eduard_Munteanu> Otherwise, Cabal installs (Haskell) dependencies by default.
19:24:31 <mister_m> OKay great
19:25:38 <NemesisD> so in an enumerator pipeline, its an enumerator on one end, iteratee on the other end and 0-N enumeratees in the middle?
19:25:52 <NemesisD> but never iteratees/enumerators in the middle
19:28:46 <mister_m> do I have to explicitly load simple-reflect when using ghci now
19:32:42 <Axman6> @hoogle Expr
19:32:42 <lambdabot> module Text.Parsec.Expr
19:32:42 <lambdabot> module Text.ParserCombinators.Parsec.Expr
19:32:42 <lambdabot> Text.Parsec.Expr buildExpressionParser :: Stream s m t => OperatorTable s u m a -> ParsecT s u m a -> ParsecT s u m a
19:32:46 <Axman6> bleh
19:32:51 <Axman6> @hoogle f :: Expr
19:32:51 <lambdabot> Warning: Unknown type Expr
19:32:51 <lambdabot> Prelude undefined :: a
19:32:51 <lambdabot> Prelude fst :: (a, b) -> a
19:32:55 <Axman6> :(
19:37:05 <[JJ]Albert> Haskell looks rather interesting.
19:37:20 <kmc> 9 out of 10 #haskell denizens agree
19:37:34 <[JJ]Albert> Dunno how well I'm sold on it yet. Sort of a 3 way tie between it, Ruby and Python.
19:37:39 <kmc> learn them all
19:37:44 <Axman6> except ruby
19:37:50 <kmc> Ruby and Python are pretty similar
19:37:50 <dainanaki> haters gonna hate
19:37:55 <smop> scala
19:38:03 <kmc> if you learn one you won't get much out of learning the other
19:38:13 <[JJ]Albert> True. I'm a greenhorn, so its a bit odd to point out that I'm learning C++.
19:38:13 <mauke> clearly Perl is superior
19:38:14 <kmc> whereas Haskell is totally different from most languages
19:38:22 <Axman6> if i had the choice between ruby and python, i'd definitely go with python
19:38:27 <[JJ]Albert> A sorta dirty language, C++ is.
19:38:30 <kmc> C++ is awful
19:38:30 <dainanaki> I like the metaprogrammability of ruby compared to python, personally.
19:38:34 <dainanaki> indeed.
19:38:51 <kmc> dainanaki, what features specifically?
19:38:52 <Axman6> [JJ]Albert: Haskell will teach you how beautiful code can be
19:38:57 <[JJ]Albert> But sadly, it's for a grade.
19:39:21 <kmc> what schools teach you and what employers want you to use will generally be several decades behind the state of the art in programming languages
19:39:29 <[JJ]Albert> Once I'm through with it, I'll start learning one of the 3 top modern languages.
19:39:47 <dainanaki> kmc: Metaprogramming python comes across to me as a lot more low-level.
19:39:59 <dainanaki> and underscorey
19:40:26 <cmccann> dainanaki, so basically python makes it awkward to work around the language's limitations with scary metaprogramming hacks, whereas ruby makes scary hacks look pleasant (at first)
19:40:27 <mauke> [JJ]Albert: Go, VB.NET, and Agda?
19:40:30 <Axman6> kmc: not that that's necessarilly a bad thing
19:40:43 <[JJ]Albert> Hm?
19:40:45 <Axman6> heh
19:41:19 <kmc> [JJ]Albert, the big difference between Haskell and Ruby or Python is that learning Haskell well enough for it to be a practical tool will take you a long time
19:41:39 <kmc> in one day you can pick up enough Python to do some useful things
19:41:57 <[JJ]Albert> True. I don't see it getting as much praise as the other two. I figured it had something to do with the learning curve.
19:42:08 <dainanaki> cmccann: yes. I like the clever hackishness of ruby. I don't use it for anything except little scripts anymore, but I find it to be fun to twist the system to do things oddly. It's not any weirder than type-level programming as far as I'm concerned.
19:42:09 <Axman6> but learning haskell to the point of making it a practical tool will be very beneficial
19:42:32 <[JJ]Albert> Python looks to be the one I'll probably pick up, next.
19:42:58 <Axman6> i don;t find python to be fun
19:43:03 <[JJ]Albert> Though I don't know if its been optimized all that much since I last saw it.
19:43:05 <cmccann> dainanaki, I generally agree, actually
19:43:09 <Axman6> you get stuff done, but it's meh. haskell amazes you all the time
19:43:26 <Axman6> it makes you enjoy programming
19:43:31 <kmc> Haskell *is* a better practical tool, but it's better in deep ways that take a long time to absorb
19:43:32 <cmccann> dainanaki, given how much type hackery I've done in Haskell I really can't throw stones :P
19:43:38 <dainanaki> lol.
19:43:54 <[JJ]Albert> Well I'm not here to be sold on Haskell, I just want to see the Haskell community in action.
19:43:54 <kmc> and so a lot of people bail at the stage of useless toys (Fibonacci function, whatever)
19:43:58 <kmc> and conclude that's all it can be used for
19:44:25 <dainanaki> [JJ]Albert: I think you'll find us to be pretty helpful, generally speaking :)
19:44:31 <shachaf> kmc: You should add that to the FAQ.
19:44:49 <cmccann> kmc, if you ask me Haskell mostly frontloads a lot of difficulty that other languages let you sweep under the rug until later (which often includes "after bad habits have formed")
19:44:50 <[JJ]Albert> Well thats good. You all seem to be fairly level-headed chaps.
19:45:13 <mauke> I'll do some ranting and raving later
19:45:15 <kmc> yay we're chaps
19:45:16 <Axman6> [JJ]Albert: if you're interested in becomming a better programmer, i would highly recommend haskell to you. if you just want to hack out some toys, then python or ruby might be better
19:45:26 <[JJ]Albert> Best to find yourself on shallow waters, than on the deep end of a ravine.
19:45:41 <Axman6> @where lyah
19:45:42 <lambdabot> http://www.learnyouahaskell.com/
19:45:47 <Axman6> [JJ]Albert: ^^^
19:45:49 <dainanaki> I love Haskell because there's always this frontier of the unknown for me to explore that makes my code even better. I don't really encounter that in OO languages anymore.
19:45:58 <[JJ]Albert> Well I think I may start with Python first. But Haskell appeals to me more, somehow.
19:46:13 <[JJ]Albert> Is it better optimized, would you say?
19:46:25 <kmc> dainanaki, I think the frontier in OO languages is the incorporation of old ideas from Haskell and FP
19:46:26 <Axman6> well, it's a compiled language, so... maybe?
19:46:36 <dainanaki> kmc: precisely.
19:46:37 <cmccann> kmc, ah, C#!
19:46:40 <kmc> though you get some interesting things out of the mixture
19:46:53 <[JJ]Albert> I remember there being something called Psycle that allowed Python programs to run more eifficiently.
19:46:53 <kmc> "compiled language" is a misnomer
19:47:03 <kmc> you can compile or interpret Haskell or Python
19:47:09 <cmccann> there's probably some interesting stuff on the frontiers of actual OOP but most OO languages are too dumbed-down to get there
19:47:27 <Axman6> [JJ]Albert: the only stuff that runs fast in python is the stuff actually written in C
19:47:34 <kmc> but yes, it's not hard to beat standard CPython interpreter's performance with compiled code that comes out of GHC
19:47:42 <cmccann> "compiled language" is defined as "the most common implementation is a compiler, not an interpreter" :T
19:47:46 <kmc> meh
19:48:01 <shachaf> kmc: Unless you're using String. :-)
19:48:06 <mauke> cmccann: what if it's a bytecode compiler bundled with a bytecode interpreter?
19:48:09 <[JJ]Albert> Yeh, I also need to get C down. But most of C++ is more or less a rehash of the C Syntax. Right?
19:48:17 <mauke> [JJ]Albert: what
19:48:25 <cmccann> mauke, then that's exceeded the complexity of bad terminology
19:48:28 <Axman6> C and C++ are pretty different
19:48:38 <Axman6> C is fun, C++ is not, for one
19:48:46 <[JJ]Albert> Ah, really? In syntax?
19:48:53 <shachaf> C is a much simpler language than C++.
19:48:59 <Eduard_Munteanu> Well, similarly, Java wouldn't be a pure JIT-ed language, since the Java->IR translation is AOT.
19:49:01 <mauke> [JJ]Albert: yes, C++ adds tons of syntax
19:49:07 <shachaf> Most C++ programs are valid C, with minor tweaks.
19:49:12 <dalaing> C++ is really different from C, especially if it's used in the more modern way than just C with classes tacked on
19:49:13 <[JJ]Albert> Then I'm really in a mess to learn to program eifficiently.
19:49:15 <shachaf> But it's a different language.
19:49:16 <Axman6> the syntax of C is almost all in C++ (with some different semantics sometimes), but C++ adds a crapload of ugly stuff
19:49:17 <mauke> shachaf: what
19:49:17 <dainanaki> I currently program C++ for a living. It sucks.
19:49:21 <shachaf> mauke: Is that not true?
19:49:26 <mauke> shachaf: it's obviously false
19:49:35 <shachaf> mauke: Er. I meant that backwards.
19:49:42 <[JJ]Albert> Our Teacher is a bit of an airhead, so learning C++ has became trivial for what should otherwise be natural to me.
19:49:52 <mauke> shachaf: I'd still argue with that
19:49:54 <cmccann> C++ also adds a lot of powerful tools to work around the problems associated with working in C++
19:50:01 <[JJ]Albert> I'm a poor reader, for that matter, when it comes to learning.
19:50:14 <kmc> C++ is 10% C and 90% ++
19:50:18 <[JJ]Albert> But I'm improving out of necessity.
19:50:20 <mauke> shachaf: because none of my C programs are valid C++
19:50:31 <kmc> syntactically, semantically, in terms of headaches, however else you measure it
19:50:34 <shachaf> mauke: Well, you're you. I'm talking about normal C programs.
19:50:52 <mauke> shachaf: my C programs are pretty normal
19:51:03 <shachaf> mauke: Can you give an example? There are differences but I don't think of any of them as being very major.
19:51:23 <mauke> shachaf: one uses 'new' and 'class' as variables, one has a 'delete' function, almost all of them use malloc
19:51:59 <shachaf> I use malloc with C++.
19:52:06 <mauke> then you're probably doing it wrong
19:52:07 <dalaing> I can'e see the point in doing C++ without using the STL / templates / etc...
19:52:23 <dalaing> s/can'e/can't
19:52:24 <shachaf> mauke: I don't use it very often. But it seems to work.
19:52:26 <mauke> casting malloc is an offense worse than multiplying by sizeof (char)
19:52:57 <[JJ]Albert> Well, I believe I shall see you all again in the near future, possibly. I got much to learn in basic programming.
19:52:59 <shachaf> Keywords are a point, but a translation into C++ is still trivial.
19:53:00 <Eduard_Munteanu> I think malloc()/free() are ok as long as you don't mix them with new/delete for the same objects.
19:53:24 <shachaf> [JJ]Albert: The standard procedure with this channel is to never leave.
19:53:43 <mike-burns> Stay in this channel, even if you want to talk about something unrelated to Haskell.
19:53:47 <mauke> if you cast malloc, I'm afraid I have to kick you in the shins
19:53:47 <[JJ]Albert> Oh, hehe, like some sort of horror movie?
19:54:03 <[JJ]Albert> Where someone is trapped in a house?
19:54:04 <Eduard_Munteanu> mauke: well... there's no way around it in C++
19:54:05 <cmccann> does talking about C++ count as being like a horror movie?
19:54:06 <[JJ]Albert> :P
19:54:09 <mauke> Eduard_Munteanu: yes, there is
19:54:10 <Axman6> [JJ]Albert: we'll provide you better answers about your other favourite languages than their channels will anyway :P
19:54:29 <shachaf> mauke: How about posix_memalign()?
19:54:32 <[JJ]Albert> Well yes, but I shall be back. Besides, I really must turn in.
19:54:32 <Eduard_Munteanu> How? (void *) doesn't work the same.
19:54:36 <cmccann> Axman6, yes, by saying how terrible they are
19:54:50 <Axman6> cmccann: and then giving you better help afterwards
19:54:58 <mauke> shachaf: never used it, it's neither C nor C++
19:55:13 <Axman6> "Foo is such a horrible language, but here's how you solve your problem in three simple steps"
19:55:14 <mauke> Eduard_Munteanu: by using a wrapper around malloc that does it for you
19:55:18 <[JJ]Albert> But I'm on freenode alot, so I'll pop in alot anyhow until then.
19:55:39 <shachaf> mauke: True. But it's pretty mallocy.
19:56:00 <shachaf> #haskell is a lot like a horror movie.
19:56:09 <dalaing> there's always placement new if you need something like malloc
19:56:23 <dalaing> and/or overloading operator new and friends
19:56:50 <mauke> placement new is the opposite of malloc
19:56:51 <Eduard_Munteanu> mauke: hrm. But you have to use templates if you want a wrapper that works with all types, no?
19:56:57 <mauke> FSVO "opposite"
19:57:00 <mauke> Eduard_Munteanu: yep
19:57:05 <Eduard_Munteanu> I see.
19:57:25 <mauke> but that's not a problem because C simply doesn't need those wrappers
19:57:48 <Eduard_Munteanu> Yeah, I didn't write much C++ code anyway, much less idiomatic C++.
19:57:55 <shachaf> mauke: Anyway, modulo things like keywords, I think C code is generally valid C++.
19:58:01 <dalaing> saying the difference between C and C++ programming is mostly the keywords is like saying Haskell can only be used for useless toy programs like Fibbonaci etc...
19:58:01 <shachaf> Even if not idiomatic.
19:58:25 <mauke> shachaf: apart from void * -> T * conversions
19:58:31 <dalaing> idioms count :)
19:58:36 <mauke> and scoping of struct tags
19:58:43 <mauke> and the types of constants
19:58:48 * Eduard_Munteanu knows virtually nothing of STL
19:58:50 <shachaf> mauke: What's wrong with void * -> T * conversions?
19:58:57 <mauke> shachaf: they don't exist in C++
19:59:03 <Eduard_Munteanu> They're not implicit.
19:59:16 * mauke kicks his brain
19:59:23 <shachaf> Oh.
19:59:40 <mauke> shachaf: THIS IS WHY MALLOC DOESN'T WORK* IN C++
19:59:47 <mauke> * it does work, just not idiomatically
19:59:52 <Eduard_Munteanu> :)
20:00:09 <shachaf> You can still cast it explicitly, right?
20:00:15 <mauke> shachaf: also, variable-length arrays, vararg macros, etc
20:00:21 <mauke> shachaf: see my comments above
20:00:23 <Eduard_Munteanu> shachaf: no, mauke will kick you in the shins :P
20:00:27 <mauke> and prepare for shin kicks
20:00:30 <Eduard_Munteanu> Heh.
20:01:51 <dalaing> you can use reintepret cast, but it's not portable
20:02:01 <mauke> you can use static_cast
20:02:25 * cmccann always figured the goal of coding in either C or C++ was to invoke as much undefined behavior as possible while still ending up with a "working" program
20:02:40 <dalaing> static_cast requires that there's a conversion between the types
20:02:46 <mauke> dalaing: then why does it work?
20:02:55 <dalaing> so ints and enums, or base to derived
20:03:18 <mauke> I'm not sure what reinterpret_cast does but it's probably stupid and/or misnamed
20:03:35 <Eduard_Munteanu> Well, pointers are essentially the same, no?
20:03:37 <shachaf> I always use the keyword reinterpret_cast in my C programs as a variable name.
20:03:39 <dalaing> static_cast doesn't do any run times checks, doesn't always mean it's working
20:03:39 <mauke> Eduard_Munteanu: no
20:03:41 <shachaf> I guess that's another point.
20:03:58 <mauke> dalaing: I bet reinterpet_cast doesn't do any runtime checks either
20:04:20 * Eduard_Munteanu shuts up then
20:04:34 <dalaing> it's about intent I guess
20:05:17 <dalaing> static_cast lets the guy who comes along after you know that's you're doing a known conversion via a pointer
20:05:24 <mauke> "#define compl 42" is a syntax error in C++
20:05:35 <dalaing> reinterpret_cast lets him know that craziness is happening
20:05:49 <mauke> dalaing: is that actually what the standard says?
20:06:18 <dalaing> can't remember the standard word for word
20:06:21 <dalaing> :)
20:07:25 <mauke> hmm. superkeywords
20:09:57 <dalaing> static_cast should get checked by the compiler as well, not sure how compiler-specific that is though
20:10:05 <mauke> what
20:13:35 <dalaing> I've come across some dodgy old compilers that didn't do static_cast properly - ideally the compiler uses the static type information to check that the cast is valid and rejects the code if it's not
20:13:42 <dalaing> http://en.wikibooks.org/wiki/C%2B%2B_Programming/Programming_Languages/C%2B%2B/Code/Statements/Variables/Type_Casting
20:15:42 <kmc> template<typename S, typename T> T cast_damnit_cast(S &x) { return *reinterpret_cast<T*>(&x); }
20:15:56 <NemesisD> is an enumeratee the right choice for something that takes a bytestring stream and chunks it by lines?
20:16:41 <mauke> kmc: needs more memcpy
20:18:49 <Axman6> NemesisD: sure
20:19:52 <Axman6> if you use the right package, there should already be an enumeratee that takes in bytestrings and outputs the lines in the bytestring
20:21:01 <NemesisD> Axman6: the right bytestring package or the right enumerator package (i'm using enumerator)
20:21:23 <Axman6> the latter
20:23:22 <NemesisD> i may have chosen wrong. i don't see anything in enumerator for lines
20:23:52 <Axman6> shouldn't be too difficult to implement
20:24:33 <NemesisD> yeah
20:26:31 <NemesisD> ahhh, splitWhen :: Monad m => (Word8 -> Bool) -> Enumeratee ByteString ByteString m b, so i think splitWhen (== '\n') may do it
20:28:58 <NemesisD> erm, well i'd have to convert the char to a word8 which evidently is fromIntegral . fromEnum
20:34:28 * hackagebot clientsession 0.7.2 - Store session data in a cookie.  http://hackage.haskell.org/package/clientsession-0.7.2 (MichaelSnoyman)
20:39:53 <aavogt> is there some way to set the -l flag with TH so that I can use a .so which has been compiled based on the contents of a quasiquoter?
20:48:16 <nhonhonho> @quote
20:48:16 <lambdabot> FunctorSalad says: lol I solved my typechecking problem... forgot that I overrode (.)
21:06:49 <ezyang> Is the only way into homotopy type theory through dependent types?
21:09:25 <dolio> Yes.
21:11:02 <ulfdoz> or you pay the entry.
21:11:13 <kmc> a bold assertion of a universally-quantified statement
21:13:52 <ezyang> :-)
21:13:58 <jmcarthur> structures of this form keep coming up for me:   f (Free f a)
21:15:45 <jmcarthur> that fact that it's a free monad might not even be significant. maybe i should just say it has the form     T f a = f (Either a (T f a))
21:16:59 <jmcarthur> i say this in the hopes that somebody says something to the effect of "well obviously that's just <some well-studied thing in category theory>
21:17:01 <jmcarthur> "
21:40:54 <JoeyA> The Haskell wiki warns about using FFI and concurrency at the same time.  Do I need to worry about it if I use a thread-safe C library and am not interested in sharing C objects between threads?
21:41:20 <kmc> you're probably fine
21:41:25 <kmc> does your C library keep thread-local state?
21:41:32 <kmc> or otherwise care which OS thread a call is coming from?
21:41:33 <JoeyA> (e.g. having an HDBC SQL connection, brokered by an application thread.
21:41:43 <JoeyA> kmc: Nope.
21:42:09 <kmc> http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
21:42:26 <kmc> you're probably fine
21:42:32 <kmc> (where's the wiki quote?)
21:42:46 <JoeyA> http://www.haskell.org/haskellwiki/GHC/Concurrency
21:42:54 <JoeyA> "If you are calling foreign functions in a concurrent program, you need to know about bound threads."
21:43:13 <Axman6> hmm, with MPTC's, would it be possible to define monad as: class Monad m a b where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b, and allow you to have instance (Ord a, Ord b) => Monad Set a b where...?
21:43:16 <kmc> yeah, bound threads specifically deal with the issue of thread-local state in C
21:43:25 <JoeyA> okay
21:44:01 <JoeyA> So even if a library is not threadsafe, I'm okay as long as I only use the library with one Haskell thread?
21:44:03 <edwardk> joeya: basically haskell threads and os threads are only loosely related, so if you use something like OpenGL where "bad things happen" if you communicate with it from multiple threads you need to bind a thread
21:44:18 <lewis1711> does anyone have any idea on how I'd rank a sorted list of something? something like rank :: [a] -> [Int]
21:44:21 <edwardk> well, only if its okay with calling it from multiple threads
21:44:35 <edwardk> as in multiple different threads, not necessarily at the same time
21:44:57 <lewis1711> I tried to make the base case rank [x] = [1], but that doesn't seem to be doing much
21:44:59 <JoeyA> lewis1711: zip in some indices, sort, then get the indices
21:45:30 <edwardk> @type sortBy
21:45:31 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
21:45:33 <Eduard_Munteanu> If it's sorted by the same criteria, then you'd just get [1,2,...] no?
21:45:41 <kmc> :t map fst . sortBy (comparing snd) . zip [1..]
21:45:42 <lambdabot> forall a b. (Ord b, Num a, Enum a) => [b] -> [a]
21:45:48 <JoeyA> > let xs = ["a", "b", "c"] in map snd $ sort $ zip xs [1..]
21:45:49 <lambdabot>   [1,2,3]
21:46:02 <JoeyA> > let xs = ["b", "a", "c"] in sort $ zip xs [1..]
21:46:03 <lambdabot>   [("a",2),("b",1),("c",3)]
21:46:18 <edwardk> then apply a schwartzian transform beforehand
21:46:20 <JoeyA> Note that I exploit lexical ordering of tuples here.
21:46:33 <edwardk> as shown by kmc here
21:46:54 <kmc> ?schwartzian transform"?
21:46:55 <lambdabot> Unknown command, try @list
21:47:05 <edwardk> http://en.wikipedia.org/wiki/Schwartzian_transform
21:47:20 <kmc> heh
21:47:20 <lewis1711> oh
21:47:24 <Eduard_Munteanu> > let xs = ["b", "a", "c"] in map snd . sort $ zip xs [1..]
21:47:24 <kmc> didn't know that had a name ;P
21:47:26 <lambdabot>   [2,1,3]
21:47:37 <lewis1711> what does "in" do?
21:47:44 <JoeyA> let ... in ...
21:47:45 <kmc> it's part of the "let" syntax
21:48:10 <JoeyA> > let fibs = 0 : scanl (+) 1 fibs
21:48:11 <lewis1711> oh. oh yeah. nevermind I thought let was just because it was interpreted
21:48:12 <lambdabot>   not an expression: `let fibs = 0 : scanl (+) 1 fibs'
21:48:19 <JoeyA> > let fibs = 0 : scanl (+) 1 fibs in fibs
21:48:20 <kmc> "let" establishes some local definitions for the scope of an expression: the expression after "in"
21:48:20 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:48:22 <copumpkin> it's a big fancy name for something pretty obvious
21:48:38 <kmc> copumpkin, needs moar Pattern
21:49:10 <copumpkin> sounds like a decorator pattern to me
21:49:19 <copumpkin> decorate with the function, sort by that, undecorate
21:49:36 <shachaf> Patterns are good for decorating.
21:49:44 <edwardk> but decoration sounds like it should be comonadic ;)
21:50:32 <kmc> we need some copatterns
21:52:03 <Axman6> http://en.wikipedia.org/wiki/DisplayPort#Products
21:52:11 <Axman6> The Dell 3008WFP 30-inch (76 cm), released in January 2008 was the first monitor to support DisplayPort.[37][38] The Dell 2408WFP 24-inch (61 cm) followed in April 2008.[39
21:52:26 <JoeyA> If I want to create a mutable variable that one thread sets and many threads use (namely, configuration data), would IORef be fine, or is there a concurrency-safe version I need to use?
21:52:27 <kmc> cool story
21:52:34 <kmc> JoeyA, IORef should be fine
21:52:37 <JoeyA> thanks
21:52:58 <kmc> i believe the individual read/write on IORef are atomic though i'm not sure
21:53:21 <kmc> what you don't get is take/put and the blocking that comes with
21:53:27 <kmc> that's what MVar provides
21:53:42 <kmc> if you're doing non-trivial shared-state concurrency, also look at STM
21:53:47 <Saizan> there's an atomicModifyIORef
21:54:35 <kmc> if one thread does writeIORef and another readIORef, does GHC guarantee that the read sees one or the other value?
21:54:55 <kmc> as opposed to, say, an invalid pointer causing a segfault or heap corruption?
21:55:16 <JoeyA> Is Chan essentially like MVar, except writers aren't blocked on every item?
21:55:37 <kmc> i guess that's a way to look at it
21:55:40 <JoeyA> kmc: Indeed, I'd like to know, too.
21:56:06 <JoeyA> What happens if the writer writes a whole bunch of items and the reader can't keep up?
21:56:09 <kmc> i'd go the other way and call MVar a bounded message channel
21:56:15 <kmc> JoeyA, then they pile up in the heap
21:56:22 <JoeyA> Okay
21:56:43 <kmc> GHC implements Chan as two MVars as references into a MVar-linked list
21:56:53 <JoeyA> ah
21:57:08 <kmc> the original Concurrent Haskell paper goes into more detail
21:57:37 <kmc> one fun consequence of this implementation is that you can cheaply duplicate the read end of a queue
21:57:40 <kmc> for multicasting messages
21:57:43 <lewis1711> re "let xs = ["b", "a", "c"] in map snd . sort $ zip xs [1..]" .. for ranking a list than can be compared. the problem is I have to two "b"s then they both get different ranks. which is why i tried an inductive thing before
21:58:50 <JoeyA> lewis1711: So you want duplicate rank numbers?  That method falls back to original order when two keys are the same.
22:00:24 <JoeyA> Hmm, so chan is full-duplex?
22:00:37 <lewis1711> Joey: yeah duplicate rank. I guess I could just do some thing with the index of the list (because the input list is sorted anyway), and do a recursive n+1 pattern thing
22:00:41 <kmc> what do you mean JoeyA?
22:00:46 <JoeyA> err, not sure that makes sense in this context
22:00:46 <lewis1711> but usually when I do that there's a better way *shrugs*
22:00:49 <kmc> any thread can put messages in; any thread can take messages out
22:00:54 <JoeyA> got it
22:01:45 <JoeyA> lewis1711: You could throw group in there.
22:02:40 <lewis1711> will check that out
22:02:59 <JoeyA> Hmm
22:03:44 <JoeyA> The zip xs [1..] solution above doesn't list rank per item, it lists indices of values when they're unsorted.
22:04:12 <JoeyA> > let xs = ["b", "a", "c"] in zip [1..] $ group $ sort xs
22:04:13 <lambdabot>   [(1,["a"]),(2,["b"]),(3,["c"])]
22:04:21 <JoeyA> > let xs = ["b", "a", "c", "a"] in zip [1..] $ group $ sort xs
22:04:22 <lambdabot>   [(1,["a","a"]),(2,["b"]),(3,["c"])]
22:04:49 <kmc> hey, i just pdf-ified some slides from a few Haskell talks i gave a while ago
22:04:59 <JoeyA> If you want to flatten away those inner lists, I leave that as an exercise.
22:05:06 <kmc> anyone want to take a look before i blog them to the whole world?
22:05:18 <mister_m> how do I load something I got from cabal into ghci?
22:05:36 <shachaf> kmc: You could post them on t0rch.org first.
22:05:36 <kmc> http://ugcs.net/~keegan/talks/first-class-concurrency/talk.pdf and http://ugcs.net/~keegan/talks/high-level-ffi/talk.pdf
22:05:42 <lewis1711> yeah that's close, I want [(1, "a"), (1 "a")] instead but that's close. thanks Joey
22:06:13 <shachaf> kmc: Oh, I've already seen those.
22:06:16 <kmc> let me know if anything looks formatted incorrectly, or if you think they're super ugly
22:06:36 <kmc> shachaf, but not in glorious beamer-generated PDF
22:06:44 <kmc> unless you've been watching through my window with a telescope
22:07:40 <shachaf> I liked the browser UI for the slides.
22:07:47 <shachaf> Well, except for the fact that it was pretty broken.
22:08:04 <kmc> yeah, as far as I can tell it only works in Firefox
22:08:21 <kmc> also it means the slide layout is wrong if your screen resolution / window size is not exactly the same as mine
22:08:30 <shachaf> Yep, some text was cut off.
22:09:21 <edwardk> the first class concurrency talk was pretty good
22:09:46 <kmc> markdown ⊢ pandoc → s5 html  is a nice way to make slides quickly and present them once
22:10:57 <kmc> converting to beamer was surprisingly straightforward (i'll have a small blog post about it soon, maybe tonight)
22:11:07 <edwardk> i've been debating about using pandoc or some internal format for generating usage docs, pros of pandoc: easy to generate man pages, etc. consL hard to do all my terminfo coloring without BEING pandoc.
22:11:27 <kmc> i'm just glad i can make proper pdf slides now without using much LaTeX syntax
22:11:43 <edwardk> unless i missed a module which exposes what i need
22:11:52 <kmc> you know what to do
22:11:58 <edwardk> damnit
22:12:06 <cwl> www.ai-class.com
22:12:08 <edwardk> not another project!
22:12:13 <kmc> while you're in there, rewrite all their parsers to use trifecta :D
22:12:17 <cwl> Is haskell suit for that class?
22:12:42 <edwardk> kmc: the worst part is i was eyeballing that the other day
22:13:04 <edwardk> mostly to have more test cases
22:13:10 <kmc> heh
22:13:48 <edwardk> i may port my javascript parser to trifecta though
22:15:28 <kmc> JoeyA, actually i talk about the implementation of Chan in those concurrency slides
22:15:35 <kmc> though the Concurrent Haskell paper probably makes more sense
22:16:30 <kmc> someone should make a beamer style named "SPJ" that uses Comic Sans and bright yellow on blue on black on radioactive orange
22:17:00 <shachaf> @quote comic.sans
22:17:01 <lambdabot> Taejo says: I've switched to Comic Sans -- that way everything looks like it was written by SPJ so I think I'm learning something on IRC
22:17:09 <shachaf> @quote comic.sans
22:17:10 <lambdabot> kmc says: Rule number 1 of Haskell talks: use Comic Sans MS.
22:17:29 <parcs> does spj use emacs or vim?
22:17:39 <Botje> yes.
22:18:02 <Axman6> he runs vim in an emacs shell
22:18:04 <parcs> comic sans font?
22:18:24 <kmc> http://www.ctan.org/tex-archive/macros/latex/contrib/comicsans
22:18:34 <Axman6> XD
22:19:45 <NemesisD> i've got an enumerator, a bunch of enumeratees to be applied in order and an iteratee. i'm setting it up like enumerator $$ enumeratee1 >>> enumeratee2 >>> enumeratee >>> finaliteratee  am i composing these wrong? can't get the types to work out
22:20:47 <Axman6> maybe you want =$
22:21:06 <Axman6> (=$) :: Monad m => Enumeratee ao ai m b -> Iteratee ai m b -> Iteratee ao m b
22:21:17 * Axman6 happened to have the docs for enumerator open already
22:21:55 <parcs> you can't compose enumeratees with >>>
22:22:42 <NemesisD> shoot. i couldn't find anything in Data.Enumerator that could do that (or at least nothing obvious to me)
22:22:44 <mister_m> how do I load a module I got from cabal into ghci?
22:22:55 <Axman6> oh, hmm, which package are you using NemesisD?
22:23:06 <NemesisD> Axman6: enumerator
22:23:13 <Axman6> mister_m: :module +Foo.Bar
22:23:40 <Axman6> or just :m +Foo.Bar
22:23:40 <parcs> NemesisD: try >=>
22:24:13 <NemesisD> so many exotic infix operators!
22:25:09 <Axman6> yeah :\
22:25:23 <Axman6> i was thinking earlier today that iteratees could do with nicer syntax. not sure how to fix it though
22:26:32 <NemesisD> hmm, the type isn't checking out but i'm not convinced my typesig is correct in the first place
22:28:31 <edwardk> axman6: i should probably finish up my post on how to fix the fact that iteratees don't form a monad
22:29:21 <hpaste> NemesisD pasted “Enumerator pipeline” at http://hpaste.org/50809
22:30:31 <NemesisD> oh yeah because i shouldn't be using =$
22:35:59 <NemesisD> i don't see why $$ doesn't work though
22:36:55 <NemesisD> parcs: oh wait did you mean >==> not >=>
22:40:08 <parcs> NemesisD: no
22:40:28 <parcs> the latest thing should be an $$ though, not an >=>
22:40:45 <parcs> ... $$ output
22:42:54 <parcs> also add explicit parens
22:44:18 <NemesisD> parcs: i don't really know what kleisli composition is, if i'm using >=> like i am it applies them sequentially left to right correct?
22:44:22 <mauke> HERP - the Haskell ERP
22:44:41 <NemesisD> meaning e1 >=> e2 means the output of e1 gets fed to the input of e2?
22:44:58 <parcs> forget about that klesli stuff. look at its type
22:45:06 <parcs> :t (>=>)
22:45:07 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
22:45:22 <NemesisD> ah, yes that looks like what i want
22:54:03 <NemesisD> parcs: getting closer. ok so splitLines :: Enumeratee ByteString ByteString m b; parseLine Enumerate ByteString Object m b; splitLines >=> parseLines. complains that it can't match expected type ByteString with actual type Object
22:54:58 <NemesisD> the docs say Enumeratee aouter ainner, so wouldn't this be right? splitLines feeds a bytestring into parseLine which produces an Object
22:59:06 <parcs> i forgot
22:59:17 <parcs> the types in that package are retarded
23:01:52 <NemesisD> oddly enough, even if i reverse the two in the typesig to parseLine, it still complains
23:02:02 <parcs> if you use >=> though then ao and ai have to be the same
23:02:52 <NemesisD> oh, thats the problem
23:03:21 <NemesisD> 2 one of the enumeratees changes the type
23:03:26 <NemesisD> 1 of them*
23:03:46 <parcs> yeah, i don't know what to do there
23:05:18 <NemesisD> are enumeratees not allowed to do that or is it only because i'm doing funky monadic composition stuff?
23:10:43 <parcs> try enumerator $$ enumeratee2 =$ enumeratee1 =$ iteratee
23:11:14 <parcs> (i'm just going by types)
23:11:29 <NemesisD> parcs: yeah thats my last resort, its just less readable since it lists the steps in reverse
23:17:56 <NemesisD> gah, i've tried all sorts of combinations
23:22:38 <NemesisD> i think i just need to take a step back from this and go to bed. thanks for your help parcs
23:33:21 * hackagebot iproute 1.2.2 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.2.2 (KazuYamamoto)
23:38:21 * hackagebot dns 0.2.0 - DNS libary in Haskell  http://hackage.haskell.org/package/dns-0.2.0 (KazuYamamoto)
23:43:21 * hackagebot c10k 0.5.0 - C10k server library using prefork  http://hackage.haskell.org/package/c10k-0.5.0 (KazuYamamoto)
23:43:27 <luite> dcoutts_: do you know why the setFileTimes function is not implemented in unix-compat?
23:43:46 <aki> morning
23:47:03 <dmwit> awwww yeah
23:47:05 <mister_m> I just read the first 6 chapters of LYAH. I'm trying to do the first 10 problems of the 99 problems set and some of them are actually quite tricky to figure out
23:47:07 <dmwit> I'm back, baby!
23:48:21 * hackagebot domain-auth 0.2.0 - Domain authentication library  http://hackage.haskell.org/package/domain-auth-0.2.0 (KazuYamamoto)
23:48:23 * hackagebot rpf 0.2.4 - Receiver Policy Framework  http://hackage.haskell.org/package/rpf-0.2.4 (KazuYamamoto)
23:52:21 <lewis1711> https://gist.github.com/1182983 so i am trying to have this "btree" construct have a balanaced number of ints on either side. I am at a real loss as how to procede from here though
23:58:21 * hackagebot webserver 0.4.5 - HTTP server library  http://hackage.haskell.org/package/webserver-0.4.5 (KazuYamamoto)
