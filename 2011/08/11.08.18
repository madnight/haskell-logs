00:00:59 <luite> ugh more spam....
00:03:07 <ivanm> but they selected the "#haskell" option? :/
00:04:50 <ddarius> ivanm: The more the merrier.
00:05:02 <ivanm> heh
00:08:07 <fredmorcos> is there a cryptography library in the haskell platform?
00:08:28 <ivanm> in the platform? no
00:08:31 <ivanm> available? yes
00:10:48 <fredmorcos> ivan, through hackage?
00:12:30 <fredmorcos> ivanm, ^
00:12:40 <ivanm> yes
00:13:45 <fredmorcos> is it possible to bundle a program with all included libraries and distribute it as a binary?
00:14:05 <fredmorcos> ie, statically link my imports
00:15:34 <ivanm> GHC does static linking of Haskell libraries by default
00:15:55 <ivanm> on *nix, it has some dynamic linking to C libraries; there is a way to get all of them except glibc to be linked statically though
00:17:06 <fredmorcos> c libraries shouldn't be an issue since i can simply add them as deps to the package
00:18:57 <shachaf> You can link libc statically too.
00:19:01 <shachaf> You don't want to, though. :-)
00:19:35 <pikhq> Yeah, but only because glibc is awful.
00:19:53 <pikhq> ... And incapable of working without dlopening things.
00:33:21 <tansell-laptop> Live streaming from tonight's Functional Programming Sydney - http://view.streamti.me/fp-syd starting ~20minutes
00:47:58 * hackagebot wai-logger 0.0.0 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-0.0.0 (KazuYamamoto)
01:03:36 <brisingr> man, it really is quiet in here
01:06:06 <brisingr> oh right it's late in the US
01:06:16 <brisingr> and early in Europe
01:06:46 <Saizan> also, mid-august
01:07:00 <brisingr> yeah
01:07:58 * hackagebot wai-app-file-cgi 0.3.2 - File/CGI App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.3.2 (KazuYamamoto)
01:08:00 * hackagebot mighttpd2 2.3.1 - A classical web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.3.1 (KazuYamamoto)
01:08:44 <brisingr> here goes the endless "cool snippet" question
01:09:51 <merijn> I need a HTTP library (client and server side), any recommendations?
01:10:37 <arcatan> merijn: when i last used them, http-enumerator felt the sanest
01:10:43 <arcatan> on client side, that is.
01:11:34 <merijn> arcatan: I'll look at it, thanks
01:12:20 <merijn> By the looks of it I'm stuck grabbing two different libraries, one for client and one for server side handling, bummer...
01:13:59 <Entroacceptor> use happstack for the server
01:14:56 <merijn> Entroacceptor: Seems overkill? I just want to proxy some requests, so the server consists of "inspect HTTP headers, forward request, return result"
01:18:00 <brisingr> the damn network
01:18:50 <Entroacceptor> ah. mh
01:18:58 <Entroacceptor> why do you want that?
01:19:32 <merijn> Entroacceptor: Anti-procrastination tool? :p
01:20:18 * RenJuan is underwhelmed by the offerings of haskell app servers.
01:21:16 <merijn> Entroacceptor: So you can do stuff like lock out sites like Reddit and Hacker News for 2 hours after visiting them :p
01:21:58 <kmc> i recommend reading those through RSS
01:22:15 <kmc> i also recommend becoming so frustrated with /r/programming that you swear it off
01:22:36 <Entroacceptor> merijin: just block them completely
01:22:37 <merijn> I never started visiting /r/programming so that's easy enough :p
01:24:44 <Younder> Do you know of any good reference to Cabal?
01:25:30 <ivanm> Younder: in what sense?
01:25:31 <kmc> the manual
01:25:45 <ivanm> I generally read other .cabal files... :/
01:26:11 <kmc> also http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
01:27:18 <companion_cube> real haskell programmers use cat !
01:27:32 <ivanm> companion_cube: we do? :o
01:27:46 <Younder> My compiler project is starting. It will be huge so have some patience
01:27:58 <ivanm> companion_cube: I thought it was ed...
01:28:04 <Younder> lol
01:28:39 <Younder> Like the rest of you lot I use emacs
01:28:54 <ivanm> Younder: well, not _everyone_ uses emacs
01:29:05 <Younder> ivan, vim?
01:29:17 <ivanm> I do, but some use some vi variant, others textmate, yi, leksah, eclipse, VS
01:29:22 <ivanm> have I missed any?
01:29:31 <ivanm> oh, I think someone (dibblego?) used kdevelop at one point
01:30:05 <companion_cube> "cat" has a nice flavour of category theory :°
01:30:18 <Younder> vim is also cool. eclipes not so much... It tries to do o much
01:30:31 <kmc> i use vim
01:30:35 <ivanm> *shrug* it's personal preference
01:30:44 <ivanm> some people may be used to eclipse from other languages
01:31:19 <Younder> ivan, java
01:31:33 <RenJuan> are yi and leksah redundant ?
01:31:51 <ivanm> people use it for other languages as well...
01:31:56 <RenJuan> (doesn't leksah embed yi?)
01:31:58 <ivanm> Younder: also note, that ivan is someone else here :p
01:32:01 <ivanm> RenJuan: it can
01:32:07 <ivanm> but doesn't have to
01:32:12 <ivanm> (unless that's canged in recent versions)
01:32:22 <ivanm> last I checked, it used the Gtk editing widget by default
01:37:03 <ketil> I optimistically added a `par`to my program, and ran it with -N2.  Now, the program uses more CPU (good), but runs slower (not so great), and sometimes just hangs (wtf?), and doesn't respond to ^C or produce -s output.  I think the latter two shouldn't happen.  Stock Ubuntu GHC 6.12.3
01:37:20 <RenJuan> ivanm, i just opened a .hs file in it and it's my impression i'm looking at Yi
01:37:31 <ivanm> could be
01:37:43 <earthy> ketil: 6.12.3 is somewhat old, especially when it comes to the multithreaded runtime
01:38:01 <RenJuan> (0.10.0.4)
01:38:09 <ivanm> RenJuan: yi support is still disabled by default in 0.10.0.4
01:38:27 <RenJuan> maybe I enabled it and don't remember doing so
01:38:32 <ketil> Right, I should probably go with 7.x -- but still, I expected it to be less efficient, but don't remember hearing it was unstable or dangerous?
01:38:33 <ivanm> so either you built it yourself with yi support, your package maintainer built it with yi support, or else you can't tell the difference :p
01:38:45 <RenJuan> i definitely built it myself
01:38:45 <xil> hello. I'm trying to install leksah and running into dependency problems. Right now haddock is failing because of a type error with, I think, Alex, which installed correctly. All of this is using "cabal install ..."
01:38:52 <kmc> ketil, did you build with -threaded ?
01:39:09 <ivanm> xil: can you paste the errors up somewhere?
01:39:11 <ivanm> @hpaste
01:39:12 <lambdabot> Haskell pastebin: http://hpaste.org/
01:39:13 <ivanm> xil: ^^
01:39:17 <ketil> kmc: yes.  Otherwise, it would complain about the -N.
01:39:23 <kmc> ah, yes
01:39:30 <RenJuan> and was a big fucking hassle
01:39:38 <ketil> Hm, there's some FFI involved, could that cause problems?
01:39:39 <kmc> is it actually using CPU when it hangs?
01:39:43 <kmc> yes
01:39:49 <ketil> kmc: no, CPU drops to zero.
01:40:03 <hpaste> xil pasted “leksah cabal install errors” at http://hpaste.org/50421
01:40:03 <kmc> you can use strace to discover what it's blocking on
01:40:08 <ketil> I'm looking at 'top', and was puzzled when it dissappeared.
01:40:21 <kmc> what do your foreign calls do?
01:40:33 <ivanm> xil: which version of Alex do you have?
01:40:41 <ketil> kmc: I see... FFI is used to interface to a C library that accesses data structures in a file.
01:40:41 <ivanm> alex --version
01:40:56 <RenJuan> while I don't remember enabling it, I do remember seeing it go by in the build
01:40:57 <ketil> I'll mention it to the lib developer, perhaps he has some ideas.
01:41:09 <ketil> I'll do without parallelism for now :-)
01:41:27 <ivanm> xil: if you have alex-3.*, maybe downgrade to an earlier version
01:41:39 <ivanm> preflex: seen HamishMack
01:41:39 <preflex>  HamishMack was last seen on #haskell 58 days, 15 hours, 24 minutes and 7 seconds ago, saying: fasta: :-)
01:41:40 <xil> ivanm: 3.0.1
01:41:51 <ivanm> xil: yeah, I think that's the problem
01:41:52 <xil> ivanm: I just installed it a few min ago
01:42:00 <xil> ivanm: how do I downgrade?
01:42:09 <RenJuan> ａｎｄ　Ｉ　ｄｏｎ’ｔ　ｔｈｉｎｋ　ａ　ｔｅｘｔ　ｗｉｄｇｅｔ　ｗｏｕｌｄ　ｄｏ　ｌｉｎｅ　ｎｕｍｂｅｒｉｎｇ，　ｈａｓｋｅｌｌ　ｈｉｇｈｌｉｇｈｔｉｎｇ，　ｅｖａｌ　ｏｐｔｏｎｓ，　ｅｔｃ．
01:42:21 <ivanm> xil: cabal install "alex<3"
01:42:31 <RenJuan> ｄｉｄ　ｔｈａｔ　ｃｏｍｅ　ｔｈｒｕ　ｉｎ　ａ　ｆｕｎｎｙ　ｆｏｎｔ？
01:42:33 * ivanm wonders if we have a really bad spammer
01:42:34 <erus`> @hoogle replicate
01:42:35 <lambdabot> Prelude replicate :: Int -> a -> [a]
01:42:35 <lambdabot> Data.ByteString replicate :: Int -> Word8 -> ByteString
01:42:35 <lambdabot> Data.List replicate :: Int -> a -> [a]
01:42:38 <ivanm> oh, wait
01:42:49 <ivanm> RenJuan: sorry, just saw all these boxes and didn't read the name :s
01:42:51 <xil> ivanm: also, I really appreciate you told me how to check version without me having to ask, just wanted you to know. I'm always so embarrassed when I have to ask
01:42:59 <ivanm> xil: heh, no worries ;)
01:43:05 <ivanm> we're pretty friendly here
01:43:16 <merijn> Heh
01:43:20 <ivanm> xil: so, downgrade alex and try building leksah again
01:43:21 <shachaf> xil: You shouldn't be embarrassed when you have to ask.
01:43:22 <xil> this is my absolute favorite IRC channel
01:43:31 <merijn> "pretty friendly"...you probably never went to ##c :p
01:43:35 <shachaf> If you have to ask, ask.
01:43:40 <shachaf> If you can figure it out yourself, figure it out yourself, of course. :-)
01:43:41 <merijn> This place is filled with saints compared to those guys :p
01:43:47 <ivanm> xil: if it works, send the maintainer an email letting him know about this issue
01:44:07 <kmc> you know we're friendly because we spend all day telling everyone how friendly we are
01:44:14 <xil> haha
01:44:20 <shachaf> kmc has a point.
01:44:31 <merijn> We're friendly, and we'll ban anyone who says we're not!
01:44:40 <ivanm> we're also really wise and intelligent
01:44:46 * shachaf has always suspected that "#haskell is so friendly" was a myth relayed by #haskell people.
01:44:48 <ivanm> and worthy of your money!
01:44:56 <RenJuan> something was wrong with my text buffer, was locked into a graphical font, I think from using chinese earlier in another channel.
01:45:03 <kmc> i think it's true but still a bit self-serving
01:45:05 <ivanm> RenJuan: heh
01:45:13 <ivanm> kmc: you've got a point
01:45:17 <merijn> Step #1: Be friendly. Step #2: ???. Step #3: Profit!
01:45:21 <kmc> anyway i was recently arguing for less friendliness ;P
01:45:23 <shachaf> kmc: Self-serving in what sense?
01:45:33 <ivanm> kmc: :o
01:45:40 <ivanm> shachaf: makes us feel good about ourselves
01:45:46 <RenJuan> said "and I don't think a text widget would do line numbering, haskell highlighting, eval options, etc."
01:45:56 <shachaf> kmc: "less friendliness" means "whenever someone asks a question, @where faq"?
01:46:01 <kmc> heh
01:46:01 <ivanm> RenJuan: if they add support for it it would... ;)
01:46:04 <kmc> not that
01:46:07 <merijn> No one is using haskell, but at least everyone thinks we're nice :p
01:46:13 <xil> I think, other than #httpd, the channel I like least is my distro channel. Other than #httpd I don't want to name names, but I'll just say that sometimes it's really frustrating when I spend hours figuring out something they wouldn't help me on, only to find out it was something so fundamental to the distro that there's no way a lot of the people there didn't know.
01:47:37 <RenJuan> ivan, but had they when you last saw in the Gtk Widget?
01:47:48 <ivanm> RenJuan: I never used leksah ;)
01:47:53 <RenJuan> ah
01:48:04 <xil> ivanm: worked! So were you suggesting I let the leksah people know about the version stuff, or the haddock people?
01:48:13 <ivanm> xil: leksah
01:48:45 <xil> ivanm: okay, I shall then. Thanks for the help!
01:49:25 <ivanm> np
01:49:41 <ivanm> (just for kmc) and remember, we're _not_ friendly! :p
01:50:00 <xil> haha
01:50:14 <RenJuan> step, trace, and breakpoint in the pane menu I'll take as conclusive
01:50:16 <mstevens> I know this isn't #hakyll, but can anyone help with getting cabal to install things? It complains about the wrong version of base
01:50:36 <RenJuan> wtf is hakyll?
01:50:57 <ivanm> RenJuan: a website generator written in haskell
01:51:03 <ivanm> mstevens: what version of ghc do you have?
01:51:06 <mstevens> RenJuan: it is a library for generating static websites. Allegedly installable via cabal-install.
01:51:10 <ivanm> and what version of hakyll?
01:51:20 <mstevens> ghc is 6.12.1
01:51:37 <mstevens> ivanm: I'm just doing "cabal install hakyll"
01:51:47 <ivanm> mstevens: cabal list hakyll
01:51:52 <mstevens> cabal: cannot configure snap-server-0.5.3.1. It requires base >=4.3 && <5
01:51:52 <mstevens> For the dependency on base >=4.3 && <5 there are these packages: base-4.3.0.0
01:51:52 <mstevens> and base-4.3.1.0. However none of them are available.
01:51:52 <mstevens> base-4.3.0.0 was excluded because of the top level dependency base -any
01:51:52 <mstevens> base-4.3.1.0 was excluded because of the top level dependency base -any
01:52:03 <ivanm> ahhh, snap's fault
01:52:21 <RenJuan> what is "markdown"?
01:52:34 <ivanm> mstevens: cabal install snapserver-0.5.3 && cabal install hakyll
01:52:37 <RenJuan> (hakyll talks about this)
01:52:38 <ivanm> @google wikipedia markdown
01:52:40 <lambdabot> http://en.wikipedia.org/wiki/Markdown
01:52:40 <mstevens> RenJuan: A popular simple markup language
01:52:40 <lambdabot> Title: Markdown - Wikipedia, the free encyclopedia
01:52:41 <ivanm> RenJuan: ^^
01:52:44 <RenJuan> ah
01:52:54 <RenJuan> yaml
01:53:00 <ivanm> it's used on a lot of blog sites, commenting sites, etc.
01:53:04 <ivanm> RenJuan: similar, not the same though
01:53:08 <mstevens> ivanm: There is no package named snapserver!
01:53:11 <kmc> it's not similar to yaml at all
01:53:25 <RenJuan> but it is yaml
01:53:25 <ivanm> mstevens: snap-server
01:53:27 <ivanm> sorry
01:53:38 <ivanm> kmc: well, in concept of what it's for, isn't it?
01:53:39 <kmc> RenJuan, what?
01:53:42 <kmc> ivanm, no
01:53:43 <RenJuan> answering the crying need for same
01:53:52 <ivanm> kmc: I think he explicitly means "Yet Another Markup Language"
01:53:54 <mstevens> cabal: cannot configure snap-core-0.5.3.1. It requires base >=4.3 && <5
01:54:03 <kmc> oh
01:54:04 <ivanm> RenJuan: there already is something called yaml
01:54:15 <ivanm> mstevens: OK, cabal install snap-core-0.5.3
01:54:23 <RenJuan> ur perseverating ivan
01:54:25 <kmc> markdown is for writing formatted text; yaml is for writing arbitrary structured data
01:54:28 <ivanm> keep doing that for any other snap-* packages of version 0.5.3.1
01:54:41 <ivanm> kmc: oh, I must be getting it mixed up with something else then
01:54:44 <mstevens> ivanm: if really necessary I could install a different ghc, although I would be forced to sulk.
01:55:01 <ivanm> mstevens: well, you don't have to if you get the right versions of the dependencies
01:55:18 <ivanm> but installing ghc-7.0.* should fix this
01:55:27 <Younder> mstevens, hold your hores. A new GHC?
01:55:35 <Younder> horses
01:55:37 <ivanm> Younder: he's using 6.12.1
01:55:49 <ivanm> mstevens: if you do upgrade, I suggest you don't get 7.2
01:55:54 <kmc> yaml is broadly the same kind of thing as json or xml
01:55:55 <ivanm> stick with 7.0
01:56:09 <ivanm> kmc: yeah, I didn't know they had retronymed what it stood for though
01:56:42 <shachaf> ivanm: YAML isn't "Yet Another Markup Language", it's "YAML Ain't Markup Language".
01:56:44 * RenJuan contemplates becoming an XML bigot.
01:56:49 <kmc> yeah, i didn't know that
01:57:03 <kmc> don't have an opinion about what the acronym stands for
01:57:09 <merijn> shachaf: They changed the acronym then
01:57:19 <shachaf> merijn: Yep.
01:57:22 <merijn> Because it used to be the first one when I first saw it
01:57:31 <ivanm> shachaf: right, I know that _now_
01:57:34 <RenJuan> a vicious excoriator of punk ass MLs which aren't even DSLs
01:57:52 <RenJuan> or nuthin
01:59:06 * mstevens always seems to have trouble with versions whenever I touch cabal
01:59:44 <Younder> who doesn't
01:59:58 <ivanm> Younder: I usually don't
02:00:13 <mstevens> okay, now snap-server won't build
02:00:13 <mstevens> [13 of 18] Compiling Snap.Internal.Http.Server.Date ( src/Snap/Internal/Http/Server/Date.hs, dist/build/Snap/Internal/Http/Server/Date.o )
02:00:17 <mstevens> src/Snap/Internal/Http/Server/Date.hs:65:18: Not in scope: `mask_'
02:00:23 <ivanm> *sigh*
02:00:27 * mstevens starts looking for the latest version of ghc 
02:00:47 <mstevens> you reckon 7.2 isn't trustworthy?
02:00:57 <ivanm> it isn't stable
02:01:05 <ivanm> mstevens: actually... do you need a web server?
02:01:08 <ivanm> because it's optional...
02:01:17 <ivanm> cabal install hakyll --flag=-previewServer
02:01:27 <Younder> always go for the development release
02:01:30 <ivanm> or, you could try snap-*-5.2 instead of 5.3
02:01:33 <ivanm> Younder: no
02:01:39 <ivanm> a lot of packages are broken on 7.2
02:01:49 <ivanm> and mstevens sounds like he just wants to use haskell stuff, not develop it
02:02:04 <ivanm> also, 7.2 has only snapshot versions of some boot libraries (e.g. Cabal)
02:02:09 <Younder> ivanm, well that is what has woked for me
02:02:15 <Younder> worked
02:02:17 <kmc> interesting, i didn't know that ivanm
02:02:33 <ivanm> kmc: about Cabal?
02:02:44 <ivanm> I had someone asking me about bumping some of my packages to work with 7.2
02:03:05 <mstevens> ivanm: I'm actually mildly interested in the development side too, but RIGHT NOW my interest is in using the software rather than hacking
02:03:07 <ivanm> apparently it works with the Cabal-1.11 snapshot, but I don't want to make the version deps looser until the Cabal API has been set for 1.12
02:03:12 <ivanm> mstevens: right
02:03:39 <ivanm> mstevens: so you have three options: 1) upgrade ghc, 2) build hakyll without the server component, 3) try an earlier version of snap-*
02:03:40 * mstevens bought a copy of learn you a haskell for great good
02:03:46 <ivanm> hakyll wants >= 5.1 for snap
02:03:46 <mstevens> could be interesting
02:03:58 <ivanm> so first see if building 5.2 works for you, if not try 5.1
02:04:19 * mstevens watches ghc 7.0.4 download
02:04:36 <mornfall> I wish I could express "this value is never used" in parameters that are used for type disambiguation only...
02:04:49 <ivanm> mornfall: isTypeOf stuff?
02:05:12 <mornfall> :t isTypeOf
02:05:13 <lambdabot> Not in scope: `isTypeOf'
02:05:20 <mstevens> I had a quick look at LYAHFGG, it looks promising that it may explain things in a form I can understand
02:05:23 <mstevens> like monads
02:05:33 <ivanm> @hoogle istypeof
02:05:34 <lambdabot> No results found
02:05:43 <ivanm> @hoogle isTypeof
02:05:43 <lambdabot> No results found
02:05:48 <ivanm> bah, it's in the prelude
02:05:50 <mornfall> :t asTypeOf
02:05:50 <ivanm> @hoogle typeOf
02:05:50 <lambdabot> forall a. a -> a -> a
02:05:51 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
02:05:51 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
02:05:51 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
02:05:55 <ivanm> mornfall: that's the one
02:05:59 <Younder> adowey category theory is recommended if you can stand some math
02:06:09 <mstevens> aha, jaspervdj, I can blame him
02:06:30 <mornfall> ivanm: Well, yeah, something like that. :)
02:06:56 <jaspervdj> mstevens: For what am I to blame? :-)
02:07:01 <illissius-> mornfall: you could use Tagged
02:07:09 <kmc> mornfall, you can express it indirectly
02:07:14 <illissius-> (if it's your own functions/methods)
02:07:14 <mornfall> ivanm: What tends to happen is that you have multi-param classes with methods that don't need a value of a specific parameter, but they still need to get one to pick the right method.
02:07:19 <kmc> one of edwardk's libs defines «data Proxy a = Proxy»
02:07:22 <mstevens> jaspervdj: I followed your hakyll install instructions and did not end up with an installed copy of hakyll
02:07:37 <mornfall> kmc: That's an interesting idea.
02:07:42 <kmc> http://hackage.haskell.org/package/tagged
02:07:43 <illissius-> kmc: ..and also data Tagged s a = Tagged a.
02:07:44 <illissius-> right
02:07:56 <Younder> Jeckyl and Hyde
02:08:00 <kmc> (that one can be a newtype actually)
02:08:03 <ivanm> mornfall: ahhh, yeah, I have something like that
02:08:05 <illissius-> (er, right)
02:08:26 <illissius-> it's kind of awkward to use, but on the plus side you don't have to write "undefined"
02:08:57 <mornfall> The only peeve I have with undefined, more or less, is that it's ugly.
02:09:30 <illissius-> and dirty.
02:09:37 <Younder> hyde
02:09:39 <brisingr> and... undefined
02:10:11 <jaspervdj> mstevens: Hmm, any pointer as to where it went wrong? Perhaps we should discuss this in #hakyll as to not to pollute this channel
02:10:25 <Younder> rotfl
02:10:31 <mstevens> jaspervdj: I've already been pollutign them a fair bit! but ok
02:10:53 <mornfall> illissius-: It's not dirty if it never evaluates.
02:10:55 <Younder> go cabal instead
02:11:51 <ivanm> mstevens: the problem is that it uses snap; the latest version of snap is designed for ghc-7
02:11:57 <ivanm> gah, that was for jaspervdj
02:12:16 <illissius-> mornfall: well, the dirtiness is exactly (as you said) that you can't make sure it's not evaluated beyond saying, "don't evaluate this"
02:12:20 <mstevens> ivanm: I am watching ghc 7 build now :)
02:12:28 <ivanm> mstevens: which distro?
02:12:29 <illissius-> though maybe that's not any worse than "obey the monad laws" and such
02:12:31 <illissius-> *shrug*
02:12:55 <mstevens> ivanm: the machine is debian stable, I'm building the new ghc from source now
02:13:01 <ivanm> oh, OK
02:13:09 <yitz> ivanm: perhaps we should suggest to ndm that he include the prelude in hoogle
02:13:10 <ivanm> mstevens: didn't want to bother with my alternate suggestions?
02:13:22 <ivanm> yitz: he doesn't? :O
02:13:35 <mstevens> ivanm: this one sounded like the least hassle
02:13:36 <ivanm> yitz: if you mean my attempts before, I had the name wrong (I had isTypeOf vs asTypeOf)
02:13:37 <yitz> ivanm: apparently not, as you just saw
02:13:40 <mornfall> illissius-: Yeah, a type that simply cannot evaluate would be better in this respect.
02:13:50 <ivanm> and I dind't realise hoogle was smart enough to fix typos...
02:13:52 <yitz> ivanm: actually that happened to me too earlier today, on the hoogle web site
02:13:53 <illissius-> which is what Tagged is.
02:14:00 <Rmx> Hi, I want to process webcam video flux with the repa lib and bmp io functions. How can I give adress of the video in memory to my program? (I already post yesterday about using any CV binding)
02:14:03 <yitz> @hoogle asTypeOf
02:14:04 <lambdabot> Prelude asTypeOf :: a -> a -> a
02:14:10 <yitz> ah there it is. ok.
02:14:14 <yitz> @hoogle mapM
02:14:15 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:14:15 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
02:14:16 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:14:30 <mornfall> illissius-: Yes. But it adds other ugliness.
02:14:38 <illissius-> it does
02:15:16 <Younder> A recommendation get 'The art ocfomputer programming' and 'purely functional data structures.'
02:15:18 <yitz> ivanm: hmm tried it again on the web site and it worked too. must have mistyped.
02:16:13 <mornfall> illissius-: (I have a nagging suspicion I have seen your nick around #kde-* long ago, btw?)
02:17:05 <ivanm> Younder: do you mean craft rather than art?
02:17:06 <illissius-> mornfall: your suspicion is well-founded :)
02:17:10 <illissius-> I remember you, as well
02:17:11 * frerich seems to remember mornfall and illissius from #kde-something, too
02:17:27 <Younder> ivanm nop
02:17:50 <Younder> ivanm Donald Knuth
02:18:11 <illissius-> frerich: oh? this is awkward, because in this case the recollection is not symmetric :)
02:18:15 <illissius-> what were/are you working on?
02:18:15 <stobix> @source ivanm
02:18:15 <lambdabot> ivanm not available
02:18:27 <mornfall> frerich: Wut! :D
02:18:44 <erus`> why did noone tell me about vector?
02:18:46 <illissius-> (there's also BCoppens who I've occasionally seen around here, as well as there..)
02:18:48 <ivanm> Younder: you're trying to tell me you've read all of TAOCP?
02:18:49 <erus`> its fast as me in bed
02:19:03 <Younder> ivanm yep
02:19:05 <merijn> Live's too short to read TAOCP
02:19:19 <Younder> ivanm well not all of volume IV
02:19:24 <merijn> I have volume 1-3, but every time I start I get depressed at not being smart enough...
02:19:25 <mornfall> illissius-: I tend to meet Bart from time to time even in person.
02:19:37 <ivanm> I thought that _no-one_ read all of TAOCP!
02:19:46 <ivanm> looks like it's the end times then...
02:19:47 <merijn> ivanm: Well, Knuth probably did
02:19:47 <ivanm> ;)
02:19:55 <ivanm> merijn: he wrote it, doesn't mean he read it! ;)
02:20:10 <merijn> And presumably his editor had to proofread everything
02:20:14 <flux> maybe reading/writing a book is like writing an app/debugging an app?
02:20:19 <flux> no? well I tried ;(
02:20:51 <ivanm> see the apocryphal story of Knuth and Jobs
02:21:18 <illissius-> mornfall: hmm, where?
02:21:22 * illissius- doesn't tend to meet people
02:22:03 <kmc> what's the story?
02:22:36 <mornfall> illissius-: FOSDEM, and the one BelHac I attended. And my wife tends to study in Brussels, so I drop by from time to time.
02:22:49 <Younder> ivanm, also get The art of multiprocessor programming as Knuth's assessment are grossly outdated on modern processors which do pipelineing and parallelism
02:23:16 <ehamberg> kmc: tl;dr: jobs: i read taocp. knuth: i don' believe you
02:23:29 <ehamberg> however, knuth has said it never happened
02:23:41 <flux> wasn't it "I've read all your books"? but yes, apparently it's just a story.
02:24:11 <flux> also, the fun version contains a profanity!
02:24:14 <mornfall> Hm, a MonadTrans-based instance of a monad class is bound to be overlapping, I guess?
02:24:46 <merijn> There's only three books required for everything you need to know about CS anyway :p
02:24:48 <mornfall> (A way to specify instances as fallback would be cool, too! :)
02:25:12 <merijn> Gödel, Escher & Bach, Alice in Wonderland and the wizard book :p
02:25:23 <RenJuan> plenty of people have read all of TAOCP
02:25:25 <ivanm> merijn: "Alice in Wonderland" ?
02:25:26 <mornfall> merijn: sicp, tapl and taocp! :P
02:25:31 <RenJuan> it's been out for four decades
02:25:49 <merijn> ivanm: Think about it! :p
02:25:51 <RenJuan> maybe not all of the volume in progress
02:26:13 <merijn> Every other book is just boring technical details :)
02:26:27 <ivanm> merijn: I vaguely recall starting to read it years back, but I didn't think that much of Lewis Carol's work... that said, don't see any obvious connections to CS
02:27:07 <merijn> ivanm: You don't feel lost in a bizarre and confusing world with reasonable frequency?
02:27:24 <ivanm> merijn: not when I'm programming I don't!
02:27:30 <ivanm> real world is a different story ;)
02:27:40 <merijn> Then you're either a much better or much worse programmer than me :p
02:28:38 <Younder> TAOCP is not the real world?
02:30:11 <Younder> Look Knuth is basically a librarian (abate a bright one), but he catalogues successful algorithms
02:30:58 <mornfall> I guess there's no such thing as a newtype family?
02:31:28 <Younder> He serves much the same role as 'The decline and fall of the roman empire'
02:32:00 <Younder> which noone has read eiter eh. ivanm
02:32:17 <Saizan> mornfall: you can make newtype instances of data families
02:32:26 <ivanm> doesn't that contain a lot of bending of the truth?
02:32:33 <mornfall> Saizan: With cunning newtype deriving, too?
02:33:08 <merijn> ivanm: Btw, fun fact of Lewis Caroll and Alice in Wonderland
02:33:13 <Saizan> mornfall: i think so, but i've never tried
02:33:38 <merijn> Alice in Wonderland was an allegory for developments in math during Lewis Caroll's time :)
02:33:51 <mornfall> I'll stay with a type family for a bit, and switch to that if it turns out to be tedious.
02:36:13 <sebz> is there a mathematical translation of that book somewhere?
02:36:20 <ClaudiusMaximus> ugh.    ~/opt/src/ghc-7.2.1$ make uninstall   make: *** No rule to make target `uninstall'.  Stop.
02:36:56 <ivanm> ClaudiusMaximus: that's what installing everything into it's own directory is for!
02:37:06 * shachaf puts everything in /
02:37:10 <ivanm> (I do it in my home directory on my uni machine to have something newer than 6.8)
02:37:18 <merijn> sebz: Wikipedia has some examples about math references in there. There was also some mathematician who asserts it is a satire of math developments, but I can't find any evidence for this other then his assertion
02:37:24 <ivanm> ClaudiusMaximus: I think the stow package might help you in future though
02:37:27 <Younder> shachaf, ~/
02:37:35 <shachaf> Nope, /.
02:38:00 <ClaudiusMaximus> ivanm: i did with prefix=~/opt/ so it's not too bad, not looked at stow but vaguelly heard of it
02:38:15 <erus`> what do you think a programming language for quantum computers will look like?
02:38:18 <ivanm> ClaudiusMaximus: IIUC, it provides package-manager style uninstallation, tracking, etc.
02:38:30 <sebz> it would be cool to have a parallel math commentary
02:38:33 <Younder> that's a recipie for disaster in the next OS upgrade
02:38:49 <ivanm> erus`: like same vague mixture of english terms, mathematical symbols and various brackets, etc.
02:39:04 <illissius> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
02:39:05 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
02:39:08 <illissius> woah.
02:39:14 <Younder> sorry norwegian keyboard
02:41:01 <Younder> I wan't aware xchat translated it that badly
02:42:03 <merijn> sebz: wikipedia links to http://www.maa.org/devlin/devlin_03_10.html amongst others
02:42:37 <mornfall> :t execStateT
02:42:38 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
02:42:54 <mornfall> It's always the other one. :|
02:44:14 <ddarius> GEB was a pretty crappy book.
02:44:21 <mornfall> ddarius: Aww!
02:44:27 <Iceland_jack> ddarius: Why?
02:44:32 <merijn> ddarius: Boo! Hiss!
02:45:00 <kmc> haha
02:45:06 * shachaf is somewhat surprised at the almost-uniform adoration of it.
02:45:24 <Younder> Just read Real world Haskell.
02:45:25 <mornfall> shachaf: It's cute!
02:45:27 <kmc> shachaf, but GEB is so clever! and if I say I like it, people will think I'm clever!
02:45:43 <mornfall> kmc: Not really, but it's cute.
02:46:44 <Iceland_jack> mornfall: (or you can say that GEB is cute, making everyone that thinks it's clever assume that you must be even *more* clever)
02:46:45 <kmc> it contains an accessible yet precise introduction to certain important results in metamathematics
02:46:46 <hvr> kmc: http://www.smbc-comics.com/index.php?db=comics&id=2300#comic :)
02:46:56 <kmc> that part was good
02:47:07 <Younder> If you want to be clever read Algebra by Serge Lang. The book I am currently working on
02:47:08 <kmc> the rest of the book is fun too
02:47:17 <kmc> Younder, haha
02:47:38 <mornfall> Iceland_jack: Aww! :D That's a clever ploy indeed, too bad I didn't think of it.
02:47:43 <kmc> GEB has a way of convincing people it presents a coherent statement about philosophy of mind
02:47:47 <kmc> which it doesn't at all
02:47:53 <ddarius> Iceland_jack: It's a long book for fairly little information that isn't presented all that well and seems to actively endeavor on making the topic mystifying.
02:48:00 <Iceland_jack> mornfall: of course you didn't ;)
02:48:04 <kmc> hvr, :D
02:48:07 <rostayob> what is the best way to rename a package on hackage?
02:48:10 <merijn> kmc: But if it's not research quality writing it's crap! Didn't you get the memo saying its cool for math literate people to hate on math books aimed at less math-literate people!
02:48:18 <rostayob> is there a way to redirect to the new package deleting the old one?
02:48:35 <kmc> no i didn't get that memo
02:48:45 <Saizan> rostayob: you've to mail ross to get it deprecated
02:48:53 <ddarius> merijn: While I don't agree with much of what Penrose believes, "The Road to Reality" is a pretty amazing book.  I can't believe he got it published.
02:49:14 <hvr> ddarius: why are you amazed that it got published?
02:49:15 <kmc> merijn, anyway i don't think that's the complaint against GEB
02:49:26 <erus`> what is a sensible way todo minimax so i can limit time
02:49:38 <merijn> ddarius: What's it about?
02:50:01 <Iceland_jack> ddarius: Is that the same as it being crap? :)
02:50:35 <mornfall> Is there a better way to write foo >>= \x -> case x of ...?
02:50:53 <rostayob> Saizan: cool, thanks
02:50:55 <ddarius> merijn: Complex analysis and physics.  It just really does do the math to a large extent.
02:51:14 <kmc> mornfall, there is a proposed syntax extension for «\x -> case x of ...»
02:51:20 <kmc> but it's not implemented in mainline GHC afaik
02:51:23 <merijn> Sounds like a book I should read but will probably linger on my "to read" list indefinitely
02:51:52 <merijn> Which reminds me...I still need to finish Introduction to Algorithms >.>
02:51:54 <mornfall> kmc: Has to wait then, I guess.
03:00:13 <brisingr> eureka!
03:00:27 <brisingr> I'll show them "fix"
03:01:49 <brisingr> I'll wear a magician's hat and put some show music
03:02:04 <brisingr> ta-daaaa: INFINITE RECURSION
03:03:07 <waschbaer> hey, does someone know how I can easily insert javascript into a Text.XHTML page (that is, without converting it partially to HTML entities)?
03:06:48 <Eduard_Munteanu> ddarius: it's probably not that people are stupid when it comes to math, but they think it's ok to act like you're stupid.
03:08:02 <ddarius> Eduard_Munteanu: I'm not sure how that relates to anything I've said above.
03:08:44 <Eduard_Munteanu> So it's mostly a thing of getting them started on a ruse... they might not mind actually looking through that.
03:08:52 <Eduard_Munteanu> *through that math
03:09:25 <RenJuan> "people" is a largish linguistic value
03:10:28 <RenJuan> are people with no understanding of math still people?
03:10:52 <kmc> haha
03:12:23 <RenJuan> i guess they're amathetic human beings
03:13:03 <RenJuan> somewhere between that and "vicious animal things"
03:13:22 <Eduard_Munteanu> IDK, it might be school doing that to them. But if you dumb it down enough it might not even look like math, even if it really is. (Which is in a sense counterproductive for a mathematician or scientist.)
03:13:45 <chrisdone> is there a way to override the default encoding in ghc-compiled haskell programs? if latin1 is in my environment variable, I want to override it with utf8
03:13:55 <Eduard_Munteanu> People still think math is about fractions and numbers and adding them up and... *sigh*
03:14:11 <chrisdone> I tried setUnicodeLocale "en_GB.UTF8" from http://hackage.haskell.org/packages/archive/snap-server/0.5.3.1/doc/html/src/Snap-Http-Server.html#setUnicodeLocale
03:14:22 <Eduard_Munteanu> @hoogle encoding
03:14:23 <lambdabot> Network.CGI newtype ContentEncoding
03:14:23 <lambdabot> Network.CGI ContentEncoding :: String -> ContentEncoding
03:14:23 <lambdabot> Network.HTTP.Headers HdrAcceptEncoding :: HeaderName
03:14:35 <Eduard_Munteanu> @hoogle hSetEncoding
03:14:35 <lambdabot> No results found
03:15:26 <Eduard_Munteanu> hSetEncoding :: Handle -> TextEncoding -> IO ()
03:16:00 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hSetEncoding
03:16:19 <Eduard_Munteanu> Is that what you wanted?
03:19:44 <Tasser> hpaste.org doesn't seem to work with '#ruby' - where to report?
03:20:43 <shachaf> Tasser: I think it'll only report in #haskell and #xmonad.
03:21:06 <Eduard_Munteanu> It doesn't report in #haskell all the time either, AFAIK
03:21:12 <Tasser> shachaf, too bad
03:21:25 * shachaf doesn't like the reporting feature.
03:21:32 <shachaf> Also, #ruby is the evil Ruby channel, isn't it?
03:21:48 <Eduard_Munteanu> :)
03:22:21 <Eduard_Munteanu> Well, anyway, I guess bots should be "invited" by channel staff.
03:22:26 <shachaf> I mean, evil as compared to #ruby-lang.
03:22:39 <kmc> what, there are rival ruby channels?
03:22:50 <Eduard_Munteanu> Wow, a schism!
03:23:43 <shachaf> Yep.
03:24:05 <kamaji> Are there any good API tutorials for hmatrix?
03:25:35 <Eduard_Munteanu> kamaji: I don't know, but do you need help with something in particular?
03:25:41 <mysticc> Is anybody else having problem installing checkers from cabal ??
03:27:49 <kamaji> Eduard_Munteanu: not really sure where to start
03:29:17 <Eduard_Munteanu> fromLists :: Element t => [[t]] -> Matrix t      -- might be a good place, if you're interested in doing matrix computations
03:29:42 <kamaji> oh yes, that looks just what I want, hehe
03:30:09 <kamaji> the (><) operator looks too much like kirby in pain for me to take this API seriously~
03:31:03 <Effie> is there a function with which i can round with an accuracy of two digits after the decimal point?
03:32:12 <mysticc> Can any body help with cabal install ... I am getting this error http://paste.pocoo.org/show/460199/
03:32:33 <Eduard_Munteanu> Effie: AFAIK, you'll have to write it yourself, I might be wrong though.
03:32:36 <kamaji> Effie: (/100) . round . (*100) ? :P
03:32:38 <Eduard_Munteanu> But it's not difficult at all.
03:32:51 <Eduard_Munteanu> ^
03:33:00 <kamaji> I do not condone that code
03:33:19 <kamaji> hey, round is actually a function :o
03:33:20 <Saizan> base exports a Show instance for functions now?
03:33:46 <Eduard_Munteanu> :t round
03:33:47 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
03:34:23 <Eduard_Munteanu> Well, you have to do something more.
03:34:58 <Saizan> mysticc: which version of ghc are you using?
03:35:01 <Eduard_Munteanu> > (/100) . fromIntegral . round . (*100) $ 3.257
03:35:03 <lambdabot>   3.26
03:35:26 <kamaji> won't work with other bases though
03:35:34 <Eduard_Munteanu> :t ceil
03:35:35 <lambdabot> Not in scope: `ceil'
03:35:37 <Eduard_Munteanu> :t ceiling
03:35:38 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
03:36:04 <Eduard_Munteanu> Yeah.
03:36:49 <mysticc> Saizan: 7.0.3
03:37:30 <Effie> it is good for my concern, thanks
03:39:38 <Saizan> mysticc: maybe you can just edit the sources removing the Text.Show.Functions imports
03:41:31 <mysticc> Saizan: Is this package broken .... So I will have to install it manually
03:42:20 <Saizan> mysticc: yeah, cabal unpack checkers; cd checkers-*; ..edit the sources..; cabal install
03:43:10 <Eduard_Munteanu> Alternatively you could try getting the latest Darcs version of that, if there's such a repo.
03:43:44 <Eduard_Munteanu> A lot of packages broke when going from GHC 6.x to 7.x
03:44:13 <mysticc> Thanks ... I will try the darcs one first ..
03:44:20 <Eduard_Munteanu> If there is one, mind.
03:44:32 <Eduard_Munteanu> (I didn't look myself)
03:45:09 <mysticc> Eduard_Munteanu: Yeah ... there is one :)
03:47:58 <savask> Hello. Is it possible to turn a recursive function into tail recursive one automatically?
03:48:38 <kmc> in Haskell?
03:48:42 <Botje> sure. just make the stack explicit.
03:48:56 <Botje> of course that's just shifting the problem
03:49:18 <savask> Botje: But it's not the best way, isn't it?
03:49:32 <Botje> it's the only automatic one I know.
03:49:33 <Eduard_Munteanu> Not all functions are tail recursive
03:49:57 <savask> I meant, that it will be cool if GHC could turn recursive functions into tail recursive automatically.
03:49:59 <Eduard_Munteanu> or convertible to such a form
03:50:06 <kmc> savask, no, that would be bad
03:50:10 <savask> Why?
03:50:20 <kmc> tail recursion doesn't work the same way with lazy evaluation
03:50:29 <kmc> @src foldr
03:50:29 <lambdabot> foldr f z []     = z
03:50:30 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:50:44 <kmc> this isn't tail-recursive, but it can run in constant space if the results are consumed incrementally
03:51:15 * screen|bcoppens waves at mornfall illissius_ and frerich :P
03:51:24 <savask> kmc: But if it were tail recursive won't it compile into faster code?
03:51:28 <screen|bcoppens> erm
03:51:32 <bcoppens> sigh
03:52:12 <kmc> savask, why would it?
03:52:29 <Leif_Bork> Hi! How do I find out where an exception has been raised?
03:52:33 <kmc> savask, how much do you know about the execution model of code produced by GHC?
03:52:36 <savask> kmc: I've heard that compilers can make a loop from a tail recursive function.
03:52:57 <savask> kmc: Enough.
03:53:14 <kmc> Leif_Bork, http://haskell.org/haskellwiki/FAQ#How_can_I_get_a_stack_backtrace_when_my_program_throws_an_exception.3F
03:53:32 <Eduard_Munteanu> That's tail call optimization.
03:54:00 <kmc> savask, can you rewrite foldr in a tail-recursive way, while preserving that lazy constant-space property I mentioned?
03:54:09 <kmc> savask, "Enough"?
03:54:27 <shachaf> What would be a good way to learn about the execution model of code produced by GHC?
03:54:50 <kmc> read "implementing lazy functional languages on stock hardware"
03:55:01 <kmc> and then "how to make a fast curry"
03:55:05 <Eduard_Munteanu> GHC with optimizations will already turn foldl into loops, instead of blowing the stack
03:55:19 <kmc> Eduard_Munteanu, it will turn foldl' only, i think
03:55:22 <Leif_Bork> kmc: Thank you!
03:55:37 <Eduard_Munteanu> kmc: well, thunks are a different way of blowing it, no?
03:55:48 <savask> kmc: Why it will be a problem? (I'm about foldr)
03:55:49 <kmc> shachaf, and then some of the stuff at http://hackage.haskell.org/trac/ghc/wiki/Commentary
03:56:03 <shachaf> 11:28 < kmc> shachaf, and then some of the stuff at http://hackage.haskell.org/trac/ghc/wiki/Commentary
03:56:06 <shachaf> Er.
03:56:16 <kmc> savask, why will what be a problem?
03:56:19 <kmc> i'm confused
03:56:50 <savask> kmc: Because I thought that your question means that :-P
03:57:02 <savask> "can you rewrite foldr in a tail-recursive way, while preserving that lazy constant-space property I mentioned?"
03:57:10 <kmc> i don't think you can
03:57:15 <kmc> but you should try
03:57:34 <Eduard_Munteanu> (However, I think using -O or -O2 will make stuff like "foldl' (+) 0" work fine because the strictness analyzer can make a difference)
03:57:39 <kmc> savask, say you have a tail-recursive function on lists
03:57:46 <kmc> f [] = ...;  f (x:xs) = f ( ... )
03:58:06 * hackagebot sundown 0.1 - Binding to upskirt  http://hackage.haskell.org/package/sundown-0.1 (FrancescoMazzoli)
03:58:07 <kmc> this isn't going to produce *any* result until it's walked to the end of the list
03:58:24 <kmc> Eduard_Munteanu, yeah
03:58:29 <savask> Hmm, right...
03:58:48 <chrisdone> Tasser: I can bring hpaste bot into #ruby. but ruby highlighting doesn't even work on hpaste :p
03:59:08 <Tasser> chrisdone, shame
03:59:11 <chrisdone> Eduard_Munteanu: no that's not what i wanted because that works on a per handle basis
03:59:47 <savask> But what about strict functions? Making them tail recursive won't touch their properties.
04:00:16 <kmc> well, you have to be precise about how strict
04:00:34 <kmc> but yeah
04:01:12 <savask> "length" for example.
04:03:31 <Eduard_Munteanu> I didn't even notice it was chrisdone who asked :/
04:04:43 <kmc> savask, I think in most cases, being explicit about the strictness necessary for GHC to make such a function tail recursive would be more work than making it tail-recursive yourself
04:04:50 <kmc> in some cases you want to do both though
04:04:52 <kmc> @src foldl'
04:04:52 <lambdabot> foldl' f a []     = a
04:04:52 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
04:05:30 <kmc> :t foldl' (const . (+1)) 0
04:05:31 <lambdabot> forall a b. (Num a) => [b] -> a
04:06:44 <savask> It will be still cool if compiler could do that without my help.
04:07:21 <shachaf> It would be great if the compiler could write my entire program without my help.
04:07:27 * shachaf would appreciate that.
04:07:37 <kmc> savask, it would be incorrect for GHC to change the strictness of your function without your permission
04:07:43 <kmc> "length" isn't necessarily strict, by the way
04:07:49 <kmc> if you generalize to types other than Int
04:08:25 <savask> How so?
04:08:51 <Eduard_Munteanu> If it wasn't strict, foldr might be a better idea.
04:08:52 <shachaf> instance Num [a] where { fromIntegral = flip replicate undefined; ... }; fancyLength = id
04:09:42 * Eduard_Munteanu wonders if that'll ever be the case for integer operations
04:11:02 <illissius> do the symbols for universal/existential quantification come from the alphabet of any natural language, or are they invented? do they have a name (beyond forall/exists or universal/existential quantifier)?
04:11:47 <erus`> haskell users are just nerd hipsters
04:11:50 <tarrasch> Hello, Why do 'cabal install' have so many more options than 'cabal build'?? I thouhgt of doing 'cabal build --cabal-lib-version=1.12.0', as I've just updated to ghc 7.2.1. Anyone know flags are missing?
04:12:26 <benmachine> tarrasch: install does a configure step as well, maybe look and see if it's an option to cabal configure
04:12:35 <shachaf> illissius: I think "forall/exists" are pretty much the standard names.
04:12:47 <shachaf> And that they just come from flipping around A and E.
04:12:57 <illissius> yeah, i had noticed that
04:13:10 <illissius> i had the vague impression that they must be greek until i realized that they're not
04:13:16 <shachaf> I doubt there's anything more to it.
04:13:25 <illissius> ok then :)
04:13:54 <Eduard_Munteanu> The integral sign is also just a big S
04:13:58 <shachaf> http://en.wikipedia.org/wiki/Turned_a
04:14:36 <illissius> oh hey. shachaf: thanks.
04:14:50 <Eduard_Munteanu> Hah.... "It was used in the 19th century by Charles Sanders Peirce as a logical symbol for 'un-American' "
04:15:22 <tarrasch> benmachine, yes, they flag Is found there!, thanks :)
04:15:26 <dcoutts> tarrasch: cabal install is a "do everything" command, cabal build is just for the build step of a locally unpacked package that has already been configured, it's like 'make' in a ./configure && make style build system.
04:15:29 <shachaf> Toys ∀ Kids
04:16:57 <tarrasch> dcoutts, hm ok, currently 'cabal configure' succeeds, but not 'cabal configure && cabal build', but 'cabal install' suceeds. Is this reasonable?
04:17:09 <mornfall> bcoppens: :) :)
04:17:27 <illissius> hmm, there apparently has already been a programming language called A, though obscure enough that wikipedia only has its descendent A+.
04:19:09 <illissius> bcoppens: heh. i think you managed to highlight me on my home computer (which i'm not currently in front of), so i didn't notice till now.
04:23:23 <dcoutts> tarrasch: yes it's reasonable because cabal install does more than cabal configure. In particular cabal install can rebuild dependent packages to get deps to be consistent, cabal configure is only local and has to work with what is already installed.
04:23:49 <ivanm> dcoutts: though I've found "cabal install" to be a bit funny about that
04:24:11 <ivanm> e.g. the other day I tried to compile something with profiling enabled, but one of its deps didn't have the profiling libs installed
04:24:12 <dcoutts> tarrasch: so it might be that when you did cabal install, it picked different versions of dependent packages, and those hapend to let that package build, where previously it failed to compile against the different versions
04:24:27 <ivanm> I didn't know why it was compiling those deps (since I have them built at the system level) so I killed it
04:24:28 <dcoutts> tarrasch: cabal configure did not catch it since the version constraints were too slack
04:24:46 <ivanm> when I realised what was happening, I tried doing cabal install again, but it didn't want to check about the profiling libs anymore :s
04:24:48 <dcoutts> ivanm: yes, we don't track profiled libs properly
04:25:07 <dcoutts> ivanm: because we don't yet track them separately from normal libs
04:25:34 <ivanm> ahhh
04:26:00 <ivanm> so the first time when it hasn't configured, it checks profiling libs; but then the second time it had already configured and thus thinks they're installed?
04:26:25 <tarrasch> dcoutts, interesting, so you mean only 'cabal install' can fetch packages from hackage?
04:26:45 <erus`> I have a have a big world state that i pass to functions will it copy the entire thing or just make a delta?
04:27:11 <ivanm> tarrasch: yeah, the check deps + fetch + build stuff is inbuilt into the install sub-command
04:27:34 <ivanm> erus`: if the value isn't strict, just deltas
04:27:35 <Eduard_Munteanu> erus`: it'd pass it as a pointer
04:27:59 <ivanm> well, I meant with changes, but that's more the nature of how data structures are implemented
04:28:09 <erus`> ok good
04:28:21 <erus`> because it looks nicer when i code that way :)
04:28:21 <dcoutts> tarrasch: that's right
04:28:44 <kmc> yep, with immutable data there's rarely a need to do a deep copy
04:28:47 <ivanm> erus`: have you considered using a Reader or State monad?
04:29:00 <erus`> ivan yes
04:29:16 <erus`> but it doesnt seem very functional
04:29:33 <ivanm> it's just function passing under the hood
04:29:43 <ivanm> and avoids explicitly passing around variables
04:29:44 <ivanm> up to you
04:35:04 <sebz> I'm not sure if this question makes sense, but can any language's type system be made into a category like Haskell's?
04:35:33 <sebz> I'm wondering in particular how subtyping would work
04:36:30 <bitstream0101> Anyone know why I might be able to build this main (http://hpaste.org/50429) from inside .ghci but building with Cabal gives me this strange type error (also on the paste)?
04:36:35 <frerich> Would it be correct to say that frameworks don't play as big as role in Haskell as in other (particularly imperative) languages because a framework imposes certain function signatures but in Haskell pure functions cannot call impure functions. So either your framework is impure as a whole, or you decide to not have your framework call user code but rather implement a plain library which depends on the client to call things in the right order.
04:36:44 <bitstream0101> (rather, from inside ghci with an appropriate .ghci, i meant to say)
04:36:53 <bcoppens> illissius: ah, blame irssi :P
04:38:06 * hackagebot bcrypt 0.0.2 - Haskell bindings to the bcrypt password hash  http://hackage.haskell.org/package/bcrypt-0.0.2 (AndrewMiller)
04:40:17 <kmc> frerich, pure functions can't call impure functions because there are no impure functions
04:40:19 <erus`> imagine this
04:40:25 <erus`> rougelike bomberman
04:40:41 <kmc> sebz, TaPL talks a lot about subtyping
04:40:58 <frerich> kmc: Ok, my nomenclature was imprecise I guess: pure fucntions cannot 'execute' monadic values, at least not in the IO monad. Would that be more accurate?
04:41:00 <kmc> not much about categories though
04:41:17 <kmc> frerich, sure, or simply say that evaluation can't trigger execution
04:41:35 <kmc> i'm not sure what a "framework" is, anyway
04:42:11 <frerich> kmc: I was thinking of packages which use a 'hollywood' style of programming ("Don't call us, we call you"). So instead of you driving the program, you just provide a few callbacks and then hand the 'main' control to the framework.
04:42:23 <kmc> calling back into user code is ubiquitous in functional programming
04:42:30 <kmc> "map" does it ;)
04:42:32 <kmc> it's just not a big deal
04:44:18 <frerich> True, but map does require that you pass a function (something which can be evlauated) so that map itself can be evaluated. So you cannot have a map action which is 'executed' (in which case you could pass an action to be mapped as an argument). Or is that wher e'lifting' comes into play?
04:44:43 <kmc> you'd use mapM instead
04:45:17 <kmc> it's true that the evaluation / execution distinction has an effect on library design
04:45:25 <kmc> e.g. the fact that map and mapM are distinct
04:45:36 <kmc> i'm skeptical of connecting this to "frameworks", though
04:46:47 <kmc> i think it's simply that calling back into user code is so natural a thing to do
04:47:11 <kmc> that we don't need big important labels for it
04:47:38 <kmc> when calling back into user code involves defining 100 lines of abstract proxy singleton factory iterators, then you want those terms so you can talk about it all ;P
04:47:50 <kmc> is there a particular example of a problem you think would be solved with framework style in other languages, and not in Haskell?
04:48:54 * chrisdone looks at iteratees
04:48:57 <mstevens> okay, I'm making progress, now I have the new ghc it looks like hakyll is installing ok.
04:49:24 <kmc> frerich, if you're talking about the "main loop" pattern as found in GUI libraries, etc. then I can think of a couple other reasons to avoid that in Haskell
04:50:07 <kmc> - it's not composable.  what if two libraries each impose their own main loop?
04:50:09 <frerich> kmc: Oh, that's just one example. Another example I had in mind was a SAX parser where the handler functions do I/O.
04:50:25 <kmc> - if libs need to do things asynchronously,
04:50:34 <kmc> - if libs need to do things asynchronously, they can fork their own threads; they don't have to hijack yours
04:50:44 <kmc> in some other languages threads are heinously difficult to use, or fundamentally broken
04:50:50 <kmc> and so their use is frowned upon
04:51:23 <chrisdone> i was stuck behind an old lady walking home, so i just forked a thread and went around her
04:51:26 <kmc> - callbacks are sometimes used in order to take advantage of efficient system-level APIs for event-based IO (select, epoll, etc.), but GHC's IO manager already does this for you transparently
04:52:22 <kmc> ah, the parser which invokes callbacks is an interes ting example
04:52:39 <frerich> Or that, yes!
04:52:41 <bitstream0101> http://hpaste.org/50429 anyone have any ideas as to why i'd get this type error via cabal-initiated ghc invocation and not from inside ghci?
04:52:55 <kmc> frerich, that's done so that you can perform actions incrementally, rather than building a huge structure in memory
04:52:56 <kmc> right?
04:53:21 <bitstream0101> kmc: that's right, it's a "streaming" style parser "infrastructure"
04:53:33 <erus`> do extended ascii character show up ok for you unix guys?
04:53:46 <kmc> show up where?
04:53:50 <hiptobecubic> erus`, what?
04:53:57 <nda> hi
04:54:08 <kmc> also what's "extended ascii"?
04:54:10 <frerich> kmc: Possibly, I don't have a particular use case in mind. My *actual* use case at hand is that I once wrote a little game engine in C++ which basically asked each player for a turn (Which might involve network IO if the player is connected over the network, or which might involve some file IO if the player happens to be a CPU player backed by some database) and then apply each turn, then notify each palyer (this
04:54:10 <frerich>  notification mioght result in IO again,d rawing to the screen, sending something over the wire etc).
04:54:44 <kmc> in the parser case, in Haskell you could produce a lazy data structure
04:54:49 <erus`> ▒ like that
04:54:50 <nda> @pl \(d, mv) -> if isJust mv then Just (d, fromJust mv) else Nothing
04:54:50 <lambdabot> uncurry (flip flip Nothing . liftM2 if' isJust . (Just .) . (. fromJust) . (,))
04:54:56 <frerich> kmc: So the central 'Game' was driving everything, even though itself didn't do any IO directly. I first tried to copy this design but then realized that it means that the functions doing the work have to accept actions instead of functions. Which is boring, since I hoped to keep the core of the game pure.
04:55:02 <frerich> kmc: I hope this makes a little bit of sense...
04:55:05 <erus`> kmc in gnome/kde terminal
04:55:51 <kmc> when one bit of code produces a lazy structure, and another consumes it
04:55:58 <kmc> you get an implicit coroutine between the two
04:56:12 <bitstream0101> frerich: no reason not to have the framework accept monadic operations (say, in a MonadIO guy or somesuch), but use the identity monad to wrap all of your pure stuff
04:56:17 <kmc> with an effect similar to the callback-based system
04:56:24 <kmc> but without turning your code inside-out
04:56:48 <frerich> Hmm
04:56:56 <kmc> (i think they'd accept functions that return actions, not actions themselves)
04:57:09 <kmc> anyway that design is compatible with keeping the game logic pure
04:57:57 <kmc> you have IO stuff that decides moves, and IO stuff that conveys results
04:58:05 <kmc> the function in between from moves to results is pure
05:00:39 <frerich> Hm yes, but if I let my function accept actions instead of functions (to allow that 'getting a turn' or the like is an impure operation), then the game function itself, which executes the exection, is potentially impure as well? Hm I guess it depends on what Monad is used.
05:01:27 <frerich> I need to experiment a bit with that...
05:01:39 <kmc> frerich, that's not true
05:01:40 <tswett> Is there an easy way to state Haskell's indentation rules?  Something like "a block ends when there is a line indented less than the block's first line"?
05:02:01 <kmc> frerich, btw, monads in general have nothing to do with "impure"
05:02:15 <kmc> it sounds like you were talking in terms of IO or a closely related monad
05:02:17 <frerich> kmc: Right, but I'm usually thinking of the IO monad (but it might well be the id monad or whatever)
05:02:26 <bitstream0101> frerich: technically, sure, the "framework" may end up executing impure code, but sometimes that's really what you need (e.g., you really need to query another machine via some network code etc.).  The nice thing is that Haskell lets you control when/where and what type of effects are permitted in what contexts
05:02:47 <frerich> bitstream0101: Hm yes.
05:02:49 <kmc> tswett, http://www.haskell.org/onlinereport/lexemes.html § 2.7
05:03:01 <kmc> @where layout
05:03:02 <lambdabot> http://haskell.org/onlinereport/lexemes.html#sect2.7
05:03:03 <kmc> swtee
05:03:04 <kmc> sweet
05:03:05 <tswett> frerich: you could have your game function work with arbitrary monads, preserving some niceness and allowing some neat functionality.
05:03:48 <kmc> frerich, twoPlayerGame :: (IO Move, IO Move) -> ((Move, Move) -> Result) -> (Result -> IO (), Result -> IO ())
05:03:52 <frerich> tswett: Ha! That's just waht I had in mind, having my 'applyTurn :: Game -> Turn -> Game' function change into 'applyTurn :: (Monad m) :: Game -> m Turn -> Game' and use the 'id' monad for now, but potentially IO later.
05:04:02 <kmc> there's a pure function in the middle
05:04:17 <frerich> (err that second :: should be => of course)
05:04:42 <tswett> frerich: yup.  Though it may have to return m Game instead of just game.
05:04:44 <kmc> frerich, you might also like this example:  http://paste.lisp.org/display/53766
05:04:48 <bitstream0101> frerich: I will often build a monad transfomer stack with a MonadIO m at its "base" -- makes it very explicit when and where IO-ey operations are going on because there will be explicit lifting
05:04:56 <chrisdone> frerich: https://github.com/chrisdone/hulk/blob/master/src/Hulk/Client.hs
05:04:59 <kmc> using http://hackage.haskell.org/package/MonadPrompt
05:05:53 <kmc> btw, replacing (IO T) with ((MonadIO m) => m T) can impose limitations on your implementation
05:05:58 <chrisdone> frerich: https://github.com/chrisdone/hulk/blob/master/src/Hulk/Types.hs#L169
05:06:12 <bitstream0101> kmc: such as?
05:06:31 <kmc> you can't execute a user-specified action inside "catch" or "forkIO"
05:06:38 <bitstream0101> ah, right
05:06:41 <frerich> Thanks a lot guys.
05:06:44 <frerich> That's a lot to digest :-)
05:07:05 <erus`> how do i turn 1 into '1'
05:07:12 <kmc> > show 1
05:07:13 <lambdabot>   "1"
05:07:15 <erus`> do i have todo chr . ord
05:07:18 <kmc> > head $ show 1
05:07:19 <lambdabot>   '1'
05:07:39 <kmc> (chr . ord) = id, no?
05:07:43 <opqdonut> > intToDigit 1
05:07:44 <lambdabot>   '1'
05:07:54 <erus`> aha
05:08:00 <opqdonut> resp. digitToInt
05:08:12 <opqdonut> > digitToInt 'a' -- but
05:08:14 <lambdabot>   10
05:08:28 <kmc> as it should be :)
05:08:36 <opqdonut> yeah, just something to watch out for
05:08:53 <opqdonut> > intToDigit 36
05:08:54 <lambdabot>   *Exception: Char.intToDigit: not a digit 36
05:09:01 <erus`> @hoogle intToDigit
05:09:01 <lambdabot> Data.Char intToDigit :: Int -> Char
05:16:10 <bitstream0101> http://hpaste.org/50429 anyone have any ideas?  i'm clearly missing something dead obvious, because things "just work" in ghci with a .ghci that has a few additional source directories added via -i...
05:18:30 <tswett> Huh.  It looks like what parseCpr returns and what briefModule takes are both types called "Module", but the types are nevertheless different.
05:19:15 <bitstream0101> tswett: right, which made me suspect a corrupt pkg db, as sometimes happens with cabal-dev, but even cleaning out dist and cabal-dev entirely and doing everything manually with cabal-install yields the same problem
05:19:40 <bitstream0101> (and of course I can replicate the error by issuing the ghc command line that cabal uses)
05:20:01 <tswett> > let x = y where y = 3 in x
05:20:02 <lambdabot>   3
05:20:24 <Rmx> > 2+2
05:20:25 <lambdabot>   4
05:21:21 <illissius> should special case that to print 5...
05:21:24 <tswett> Our answers differ!  One of us must have made a mistake!
05:21:52 <kmc> > let 2+2 = 3 in 2+2
05:21:53 <lambdabot>   3
05:21:56 <kmc> all better
05:22:03 <tswett> Whew.
05:22:30 <tswett> > let x + y = (x Prelude.+ y) - 1 in (1+1,2+2,3+3)
05:22:31 <lambdabot>   (1,3,5)
05:22:33 * tswett nods.
05:22:52 <flux> > let 1 + 2 = 3 in 2 + 3
05:22:54 <lambdabot>   *Exception: <interactive>:3:4-12: Non-exhaustive patterns in function +
05:22:55 <flux> :/
05:23:34 <chrisdone> bitstream0101: I have this problem in a different codebase… just gave up solving it
05:23:47 <DevHC^> > let (<) = (>) in sort [1,2,3,4]
05:23:48 <lambdabot>   [1,2,3,4]
05:23:48 <chrisdone> Mismatch: Forj/CGI.hs:39:12: “URI.URI” ≠ “network-2.2.1.10:Network.URI.URI”
05:23:53 <DevHC^> not so fancy :P
05:24:18 <chrisdone> DevHC^: this ain't no elisp, foo'
05:24:48 <illissius> people occasionally mention in here (including yesterday) that GHC's implementation of IO looks like world-passing (and indeed it does!), when in fact it has almost nothing to do with it... I'm not sure who it was, but could anyone elaborate on that, if they happen to be present?
05:24:55 <kmc> i can!
05:24:55 <bitstream0101> chrisdone: yuck; it's strange to me -- there's really not much code here.  The only thing I can think of is that parseCpr comes from a happy-generated parser module -- but I know that's very commonplace, and so I don't really know why the error is showing up.
05:24:57 <kmc> @src IO
05:24:57 <lambdabot> Source not found. My pet ferret can type better than you!
05:25:50 <kmc> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
05:25:55 <illissius> data IO a = IO (State# s -> (# State# s, a #))
05:25:58 <illissius> if I'm remember correctly
05:26:03 <illissius> oh right, I wrote ST.
05:26:07 <chrisdone> bitstream0101: it looks like ghci is loading two different version of the same package. what package are you using? you can try ghc-pkg list package and then :set -ignore-package package to one of them
05:26:13 <arash_> @src Maybe
05:26:13 <lambdabot> data Maybe a = Nothing | Just a
05:27:04 <bitstream0101> chrisdone: well, this error doesn't come from ghci, and the ghc command line invocation that makes the error show up does indeed occlude all packages first and then explicitly pull them in
05:27:36 <kmc> illissius, the thing is, that (State# s) value holds no information
05:27:46 <kmc> it doesn't exist at runtime
05:28:01 <illissius> yeah, that much I know
05:28:02 <bitstream0101> chrisdone: but it might be working in ghci because I explicitly point to the dist/build/Cpr directory where the generated Parser.hs file is.
05:28:16 <illissius> why / what information 'should' it be holding?
05:28:22 <kmc> should?
05:28:45 <kmc> you're not passing around any information about the world
05:28:56 <kmc> it's just a hack introducing artificial data dependencies
05:29:01 <illissius> iirc threading () is sufficient to make sure side effects are correctly ordered, so I'm not sure why passing a 0-byte value should be any worse
05:29:15 <illissius> oh, hmm
05:29:20 <kmc> so as to use evaluation order on impure values to implement execution
05:29:27 <kmc> i'm not saying it's 'worse'
05:29:39 <illissius> maybe my understanding of GHC was correct but of what "world-passing" means was incorrect.. ? :)
05:29:44 <kmc> seems like
05:29:51 <kmc> in the world-passing analogy for IO
05:29:59 <kmc> the functions of type World -> (a, World) are still pure functions
05:30:09 <kmc> and the World type is something huge that contains the entire state of the Universe
05:30:13 <illissius> and in that case World *really is* the World
05:30:28 <kmc> in GHC they're impure and the World type holds nothing
05:30:29 <kmc> yeah
05:31:28 <illissius> I had always assumed that "it's impossible to hold the whole World in your program, so we just use a token to represent it" was inherently part of what 'world-passing' meant
05:31:38 <illissius> but I stand corrected.
05:31:50 <chrisdone> bitstream0101: oh, i just fixed my problem by specifying a hard constraint on network-2.1 in my .cabal and removing network-2.3 from my package repo >_>
05:32:12 <Peaker> iirc: the World analogy breaks down because   undefined :: World -> (World, a)   =   forever (print x) :: World -> (World, a)      which is wrong
05:32:43 <Peaker> also, it's nicer to formulate   State s a = s -> (s, a)   than    s -> (a, s)    because then fmap = fmap . fmap :-)
05:32:47 <kmc> that's one way it breaks down
05:32:51 <kmc> heh Peaker
05:32:54 <bitstream0101> chrisdone: hrm, i don't yet have any pkgdeps besides like base >= 4 and array :(
05:33:01 <kmc> another is that things happen in the world asynchronously
05:33:12 <chrisdone> bitstream0101: are you doing cabal install to build?
05:33:19 <kmc> a file can change between you writing it and you reading it
05:33:28 <bitstream0101> chrisdone: yeah, cabal configure / build or cabal-dev install both exhibit the same problem
05:33:35 <illissius> there was a long discussion about this on cafe
05:33:38 <kmc> maybe you can fix that by making (>>=) implement an alternating game between your program and Nature
05:33:46 <illissius> (probably there was more than one, but one in the time since I've been reading it)
05:33:50 <hvr> hrm... I guess I broke http://dac4.designacourse.com:8000/  :-/
05:33:56 <Peaker> (although if you use (s -> (a, s)) then    x >>= f  =  uncurry f . x  )
05:33:57 <dcoutts> chrisdone, bitstream0101: what is the problem?
05:34:10 <chrisdone> bitstream0101: is it possible you're conflicting with an already installed package (i.e. yours)? otherwise i dunno about how happy works
05:34:26 <bitstream0101> chrisdone: quite sure that's not
05:34:34 <bitstream0101> dcoutts: http://hpaste.org/50429
05:34:56 <bitstream0101> dcoutts: odd error message from cabal-initiated compilation
05:35:18 <bitstream0101> dcoutts: i can load it just fine in .ghci, but i think i'm cheating a bit by -idist/build to pick up the generated Parser.hs ;P
05:35:25 <bitstream0101> in ghci*
05:35:37 <dcoutts> bitstream0101: this happens in cabal build?
05:35:47 <bitstream0101> dcoutts: yup
05:35:52 <dcoutts> bitstream0101: do you have an exe and lib in the same package where the exe depends on the lib?
05:36:02 <bitstream0101> dcoutts: yessir.
05:36:19 <illissius> kmc: if each >>= implies "and update the World with whatever has changed externally" in addition to whatever changes you made?
05:36:21 <dcoutts> I've seen this before, but didn't figure out what was going on
05:36:29 <dcoutts> bitstream0101: perhaps you can help me track it down?
05:36:41 <dcoutts> rather than just fixing it and moving on :-)
05:36:46 <bitstream0101> dcoutts: yeah, i'm at a loss, but would be happy to help wherever.  I'm probably going to talk to Rogan about it today too.
05:36:51 <dcoutts> I mean rather than doing the workaround
05:36:52 <illissius> that would make it basically the same as the world-token-passing model, afaict
05:36:58 <bitstream0101> dcoutts: yeah, i'll track it down
05:37:23 <dcoutts> bitstream0101: can you annotate your paste with the .cabal file, and list of main files in the project dir
05:37:39 <bitstream0101> sure. let me see if i can create a trivial version of the whole project that exhibits the same behavior.
05:37:59 <bitstream0101> (but i'll annotate the paste in the meantime)
05:38:06 * hackagebot authenticate 0.9.3 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.3 (MichaelSnoyman)
05:38:06 <dcoutts> bitstream0101: I think we're getting some modules directly and some from the lib, and so their package names do not match, hence the types do not match
05:38:07 <Peaker> It would be nice if there was a tool/ghc-opt that warned about inferred-types-are-more-general... Then people would discover "indexed monads" sooner, perhaps
05:38:08 * hackagebot http-enumerator 0.6.6 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.6.6 (MichaelSnoyman)
05:38:10 * hackagebot mime-mail 0.3.0.3 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.3.0.3 (MichaelSnoyman)
05:38:12 * hackagebot warp 0.4.3.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.4.3.1 (MichaelSnoyman)
05:40:27 <kmc> illissius, where "world-token" means something closer to what GHC does?
05:40:35 <illissius> yes
05:40:50 <kmc> the basic problem with using that as a model is that now your language needs impure functions
05:42:20 <bitstream0101> dcoutts: updated the paste http://hpaste.org/50429
05:43:35 <Aune> I'm scratching my head over the "Roll your own IRC bot" tutorial. In it Don creates a monad "type Net = ReaderT Bot IO" where Bot contains a socket. He then defines the functions like "run :: Net ()" and "eval :: String -> Net ()". But it seems like the socket is never actually passed to these functions, leaving me quite confused. I am not sure about this but it seems like the function "asks" somehow picks the data out of thin air. Can someone explai
05:43:35 <Aune> n this to me?
05:43:55 <illissius> kmc: hm. i guess if you want to avoid that, then that's a problem... given that the world itself is impure, i seem to have less of a problem with it.
05:44:06 <illissius> but of course I'm nowhere near a theorist :)
05:44:15 <bitstream0101> Aune: Look to see where there's a runReaderT invocation or somesuch
05:44:16 <roconnor> Aune: link?
05:44:20 <dcoutts> bitstream0101: Ah! I've got it
05:44:29 <bitstream0101> dcoutts: brilliant, what is it?
05:44:30 <Aune> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
05:44:55 <dcoutts> bitstream0101: so, here's the issue: ghc always prefers modules from local source files compared to ones from packages,
05:45:28 <Aune> bitstream0101, Yeah, there is a runReaderT in main
05:45:34 <bitstream0101> dcoutts: so it's picking up Module from the generated Parser.hs rather than from the package's Parser.hs
05:45:40 <dcoutts> bitstream0101: so in your exe case, since you're using the same "hs-source-dirs   : src" for both lib and exe, then ghc will just pick up the source files and use those, rather than the package ones
05:45:43 <Botje> Aune: the ReaderT carries around the socket
05:46:17 <roconnor> Aune: in  bracket connect disconnect loop, the socket produced by connect is passed as a parameter to loop
05:46:36 <bitstream0101> dcoutts: ahh! okay, that makes sense.  So do I just hack it so that Main_cpr.hs isn't in the src directory so it's not added, or is there a better solution?
05:46:48 <Aune> Botje, Yes, but I fail to see how the "plumbing" actually works.
05:46:53 <dcoutts> bitstream0101: exactly, ghc would just pick up the source files directly and use all of them, except for the generated parser module. For that module, since you didn't list it in the other-modules for the exe, cabal will not generate the parser.hs for the exe, which leaves only the module in the lib...
05:46:53 <roconnor> Aune: and then in (runReaderT run st) this socket "st" is used for the environment in run
05:47:08 <bitstream0101> dcoutts: gotcha
05:47:25 <roconnor> Aune: bracket connect disconnect loop = bracket connect (\st -> disconnect st) (\st -> loop st)
05:47:27 <Botje> Aune: the ReaderT transformer takes care of passing around the socket everywhere
05:47:49 <dcoutts> bitstream0101: so one solution is not to have the exe depend on the lib, and to list the parser in other-modules, the other is to separate the src dirs and have the exe depend on the lib
05:48:15 <Botje> > runReader (ask >>= \x -> return x * 2) 5
05:48:17 <lambdabot>   No instance for (GHC.Num.Num
05:48:17 <lambdabot>                     (Control.Monad.Trans.Reade...
05:48:23 <Botje> > runReader (ask >>= \x -> return (x * 2)) 5
05:48:24 <bitstream0101> dcoutts: yup, yup, i think i have it now.  actually, just adding the parser to other-modules and still having the exe depend on the lib was enough
05:48:25 <lambdabot>   10
05:48:33 <dcoutts> bitstream0101: what I was confused about previously was why it wasn't picking up all the modules locally, but unlisted generated files explains that perfectly.
05:48:51 <bitstream0101> dcoutts: yeah, i'd not even thought about listing the parser module there.  great catch, and much obliged.
05:49:00 <dcoutts> bitstream0101: yes that will work, it just means that you don't have it using the lib at all, so listing the dep is unnecessary
05:49:12 <bitstream0101> dcoutts: ah, good point
05:49:25 <dcoutts> bitstream0101: in theory, every module needs to be listed in the exposed-modules or other-modules
05:49:32 <dcoutts> bitstream0101: this is a case where that shows up
05:49:36 <bitstream0101> *nod*
05:49:40 <dcoutts> bitstream0101: for each component
05:50:31 <dcoutts> bitstream0101: we ought really to enforce it
05:51:10 <dcoutts> and to get ghc to look at the modules from the package rather than local files, where the local files are not listed in the other-modules
05:52:02 <bitstream0101> dcoutts: yeah, sounds like a reasonable thing to do
05:52:44 <Aune> Botje, roconnor, So if there are several instances of Net monads then the fuctions that return a Net know which instance they are working on from the one passed as a parameter to the surrounding runReader or runReaderT function?
05:53:02 <roconnor> Aune: yes
05:53:05 <bitstream0101> Aune: that's right
05:54:29 <Aune> Botje, roconnor, So the magic is not actually in the "asks" function but In the runReader(T) function, and that is where I need to take a closer look?
05:54:47 * frerich reads up about the 'Reader' monad and thinks this sounds like a good thing to play with given that almost all my functions in my little game look like 'Game -> ... -> Game'
05:54:56 <roconnor> there is magic sprinkled all over the place.
05:55:23 <Botje> frerich: you probably want state instead
05:55:48 <bitstream0101> Aune: Maybe start by looking at the implementation of runReader and do some trivial examples by hand to see what's going on.  There'll be less magic that way :P
05:56:15 <Botje> Aune: the bind method of the Reader(T) monad passes around the value you give it at the beginning
05:56:51 <Aune> bitstream0101, thanks for the tip, will do.
05:56:54 <bitstream0101> Aune: and if you desugar away the do syntax and the like, you'll see how it gets passed explicitly everywhere behind the scenes.
05:57:31 <Botje> Aune: for example, take the example I gave above and work through it using the >>= definition of the Reader monad
05:57:44 <Botje> > runReader (ask >>= \x -> return (x * 2)) 5 -- for reference
05:57:45 <lambdabot>   10
05:58:03 <bitstream0101> Yeah, that's a great small example
05:59:00 <Aune> Ok, have pen and paper, will get started right away ^^
06:00:08 <erus`> can i get pure random numbers if i use a seed
06:00:28 <Botje> sure
06:00:32 <kmc> http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/haskell98-1.1.0.1/Random.html
06:00:47 <kmc> er i guess this one is better:  http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/random-1.0.0.3/System-Random.html
06:01:25 <Botje> > take 10 . randoms $ mkStdGen 55
06:01:26 <lambdabot>   [8315571781562420686,-6707638993439578196,-8480904177449770312,-37818770327...
06:02:48 <erus`> @hoogle mkStdGen
06:02:49 <lambdabot> System.Random mkStdGen :: Int -> StdGen
06:03:10 <kmc> you can also get an infinite list of random numbers from an IO action
06:03:13 <kmc> and then pass that around
06:03:17 <blueonyx> @hoogle randoms
06:03:17 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
06:03:42 <kmc> see also http://hackage.haskell.org/packages/archive/MonadRandom/0.1.6/doc/html/Control-Monad-Random.html
06:04:28 <djahandarie> It'd be neat if you could do something like   data Blah x = Blah { hi :: x a => a -> Bool }
06:04:48 <kmc> buh?
06:04:56 <kmc> what would it mean?
06:05:08 <djahandarie> Well, x would be a typeclass rather than a type
06:05:30 <kmc> i see; polymorphism over type classes
06:05:32 <djahandarie> Yeah
06:05:46 <kmc> interesting
06:05:48 <kmc> do you have a use case?
06:05:51 <djahandarie> Yeah
06:06:37 <djahandarie> data Category cat obj = Cat { id :: forall a. (obj a) => cat a a, (.) :: forall a b c. (obj a, obj b, obj c) => cat b c -> cat a b -> cat a c }
06:06:58 <frerich> djahandarie: http://www.haskell.org/pipermail/haskell-cafe/2004-March/005979.html <-- seems somebody else wished for the same quite some time ago.
06:07:05 <djahandarie> I guess it's just a way to cheat around not properly having kinds yet
06:07:43 <Peaker> class Functor r f where fmap :: (r a, r b) => (a -> b) -> f a -> f b
06:08:03 <Peaker> instance Functor Ord Set where fmap = Set.map
06:08:08 <djahandarie> Right
06:08:34 <Peaker> but I don't think you want the variable to stand for a class, but for a whole context, so basically a tuple of instances
06:08:49 <Peaker> but then you need a syntax to specify the constraints
06:09:29 <Peaker> Perhaps need the "a" and "b" to appear in the Functor class too for this
06:09:39 <djahandarie> Well
06:12:32 <erus`> level generation in haskell
06:12:35 <erus`> what a nightmare
06:12:48 <ocharles> Hrm, can ghc be convinced to produce a 64bit binary from a 32bit compiler?
06:12:53 <ocharles> I have no idea if that makes sense or not
06:13:05 <kmc> ocharles, configuring GHC as a cross-compiler is very hard
06:13:28 <ocharles> hrm. my server is so slow to compile, but all my dev machines are 32 bit, bummer
06:13:45 <kmc> you can run 32-bit binaries on a 64-bit machine, usually
06:13:51 <ocharles> true...
06:13:55 <kmc> on x86 they will be slower, though
06:14:06 <kmc> often
06:14:09 <ocharles> dev is i686, server is x86_64
06:14:10 <kmc> and moreso with GHC
06:14:25 <ocharles> not too fussed about speed for the moment, I just want to get this website live so people can poke it
06:15:04 <erus`> -m32
06:15:09 <stianhj> ocharles: just setup a 64-bit virtual machine?
06:15:35 <ocharles> stianhj: yes, that could work
06:15:43 <ocharles> I think i'll just carry on building deps on the server though and compile there
06:15:55 <ocharles> though "cabal install" for this package keeps saying "Killed" and I have no idea what that means
06:16:07 <ocharles> I wonder if I'm using too much cpu time
06:16:27 <stianhj> i just matched my vps OS version to my "build vm"
06:17:38 <kmc> ocharles, try strace
06:17:50 <ocharles> good call
06:17:52 <kmc> it sounds like it got SIGKILL, but maybe strace will tell you why
06:17:55 <kmc> ♥ strace
06:18:07 <kmc> erus`, what about -m32
06:18:35 <erus`> magical 32bit compile
06:18:41 <kmc> ocharles, i think running the 32-bit binaries on a 64-bit OS will be less work to set up than a 64-bit VM, and perform better
06:18:53 <kmc> a chroot is kind of an intermediate solution between those two
06:18:56 <ocharles> yea, but it means I have to set up a 32bit jail
06:18:57 <kmc> erus`, for GHC?
06:18:59 <ocharles> which is a bit of a pain
06:19:05 <kmc> ocharles, you do?
06:19:12 <kmc> not on Linux
06:19:20 <ocharles> I thought I needed 32bit versions of everything it dynamically linked with?
06:19:32 <kmc> it does, but most distros have a way to make those coexist
06:19:42 <ocharles> this is debian, so it probably isn't too hard
06:20:05 <kmc> apt-get install ia32-libs
06:20:14 <ocharles> oh, slick
06:20:56 <djahandarie> Oops, got distracted there
06:21:04 <djahandarie> What we could do is just steal the stuff from KindFacts
06:21:08 <kmc> djahandarie, have you seen RMonad?
06:22:12 <djahandarie> The kind of the thing before => is Fact. We can then do things like type Transposable f = (Traversable f, Applicative f) and that gets kind of * -> Fact
06:22:26 <djahandarie> So then we can plug it in as the type variable
06:23:00 <djahandarie> Should be able to just use the usual type checking machinery for this
06:24:07 <djahandarie> And LiberalTypeSynonyms already gives you that sort of delayed checking of partially applied type synonyms
06:25:04 <djahandarie> kmc, ah, right, I have seen this. Thanks for the reminder
06:27:51 <djahandarie> It's a nifty way of doing this
06:29:46 <Aune> Botje, roconnor, So, Reader r a wraps a function from from r to a, this function is the one that actually contains the read only information. So runReader takes such a wraped function an argument for that wraped function? So in "runReader run st",  "run" is a wraped function and "st" is the argument that this function gets applied to. Then the result of this calculation is returned unwraped.
06:30:32 <Aune> Let me try to make that more readable
06:33:01 <brisingr> I'm having trouble understanding this:
06:33:04 <brisingr>   otherPrimes = nubBy (((>1).).gcd) [2..]
06:33:15 <brisingr> the nested .s freak me out
06:33:39 <merijn> brisingr: That is code-golfing only syntax, IMO
06:33:40 <zygoloid> brisingr: apply eta expansion to figure out what's going on
06:33:41 <Aune> "Reader r a" is a wraped function (r -> a). runReader takes such a wraped function and an argument "r" and returns a result "a"?
06:34:00 <Axman6> @unpl \f g x -> ((f .) . g) x
06:34:00 <lambdabot> \ f g x i -> f (g x i)
06:34:10 <Axman6> @unpl \f g -> ((f .) . g)
06:34:11 <lambdabot> \ f g d i -> f (g d i)
06:34:23 <kmc> yep Aune
06:34:25 <kamaji> I've just installed the csv package but ghci is complaining "can't find Text.CSV"...
06:34:26 <kmc> @src Reader
06:34:26 <lambdabot> Source not found. You speak an infinite deal of nothing
06:34:30 <kmc> bah
06:34:34 <brisingr> aha, thanks
06:34:44 <kmc> @unmtl Reader r a
06:34:45 <lambdabot> r -> a
06:35:17 <Botje> Aune: yes.
06:35:39 <Aune> kmc, Botje, thanks
06:35:41 <kmc> newtype Reader = Reader (r -> a)
06:35:43 <Botje> Aune: and the >>= operation composes two actions, making sure they both get the state you passed in 'at the top'
06:35:45 <kmc> runReader (Reader f) x = f x
06:36:01 <zygoloid> brisingr: there's a nice way of looking at it:
06:36:07 <kmc> Aune, you can condense that to: newtype Reader = Reader { runReader :: r -> a }
06:36:25 <kmc> er:  newtype Reader r a = Reader { runReader :: r -> a }
06:36:34 <zygoloid> brisingr: (.) is fmap for (->). so ((>1).).gcd == (fmap.fmap) (>1) gcd
06:36:58 <zygoloid> brisingr: gcd :: a -> b -> c, so fmap.fmap applies a function two functors deep. that is, it applies (>1) to the 'c'.
06:37:18 <zygoloid> @where semantic editor combinators
06:37:18 <lambdabot> I know nothing about semantic.
06:37:26 <zygoloid> @where sec
06:37:26 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
06:37:39 <zygoloid> brisingr: ^^ highly recommended reading
06:37:42 <Axman6> zygoloid: damn, that's the best explanation i've ever seen for that
06:38:02 <brisingr> thanks
06:38:11 <brisingr> thanks a lot
06:44:46 <applicative> kamaji has ghci found Text.CSV yet?
06:47:57 <mysticc> how to cabal install another version of a package
06:48:35 <ClaudiusMaximus> --constraint "packagename==versionnumber" might work
06:48:41 <dcoutts> mysticc: specify the version of the package
06:48:46 <Saizan> cabal install $pkg-$ver -- also
06:49:06 <dcoutts> or a version contraint, like: cabal install foo-1.0,  or cabal install "foo < 2"
06:49:30 <dcoutts> mysticc: see other examples in cabal install --help
06:49:43 <erus`> i have 64 places to place 5 different colour beads, what is the total combination of possitions?
06:49:45 <kamaji> applicative: Actually I was making tea
06:49:50 <kamaji> but no, it hasn't
06:50:23 <mysticc> why cabal install base not working ... It is showing "cabal: internal error: impossible
06:50:27 <kmc> erus`, each of the 64 spots can independently have one of 5 choices?
06:50:38 <kamaji> weird.. it works in Main.hs but not another file
06:50:43 <kamaji> I've probably done something stupid
06:50:54 <zygoloid> erus`: i have 64 places to place 59 identical non-beads. i also have 5 different beads to arrange into an order. what's the total combination of positions?
06:50:58 <erus`> yes but there cannot be 2 yellow sqaures
06:51:13 <kamaji> applicative: Ah, I think I had a conflicting module name
06:51:20 <zygoloid> erus`: ah, you were asking a different question, my bad :)
06:51:25 <kmc> > 5^64  -- this many erus`
06:51:26 <lambdabot>   542101086242752217003726400434970855712890625
06:51:32 <zygoloid> hmm, or maybe not?
06:51:46 <erus`> isnt it 64*63*62*61 ?
06:51:47 <frerich> zygoloid: Are you trying to employ the socratic method? :-)
06:52:01 <djahandarie> kmc, well.... this RMonad trick works, but it's hella-ugly
06:52:06 <zygoloid> frerich: not on purpose, just trying to give a hint
06:52:22 <kmc> erus`, you're not being clear about the problem
06:52:37 <erus`> kmc 5 ^ 64 would mean 2 cells can have the same bead. but there are 4 beads total
06:52:42 <Saizan> product [60..64] would be the answer to zygoloid's interpretation
06:52:48 <kmc> there were 5 beads total a moment ago
06:53:00 <erus`> i ate one
06:53:02 <kmc> nom
06:53:27 <zygoloid> erus`: then the answer is zero. you can't place all 5 beads any more :)
06:53:39 <chylli> Hi, I tried yesod init & yesod devel and got this error :  Couldn't match expected type `hamlet-0.8.2.1:Text.Css.CssTop' with actual type `hamlet-0.9.0:Text.Css.CssTop'
06:53:40 <erus`> damn
06:53:44 <chylli> what should I do ?
06:53:44 <Saizan> (or would it?)
06:54:24 <zygoloid> Saizan: yes, i think so
06:54:54 <zygoloid> 64 places for the red bead, 63 for the yellow, 62 for the green, 61 for the blue, and 60 for the one erus` ate
06:56:07 <erus`> zygoloid: is that 5 ^ 64?
06:56:12 <Saizan> yay, i can do basic combinatorics after 20hours of wake
06:56:58 <erus`> > 64 * 63 * 62 * 61
06:56:59 <lambdabot>   15249024
06:57:06 <erus`> 15 million states
06:57:24 <erus`> gonna need more ram
06:57:36 <kmc> what problem are you trying to solve?
06:57:43 <kmc> perhaps there is a more efficient solution than brute force
06:57:53 <mysticc> Any one using reactive here ??
06:57:56 <erus`> ok my game is like bomberman
06:58:23 <erus`> everyone takes a turn simultaneously and can move or bomb or rest
06:58:56 <erus`> so without walls in an 8x8 arena there are 15 million states the players could be in
06:58:59 <erus`> without bombs
06:59:00 <Saizan> mysticc: the "reactive" package is not maintained, afaict
06:59:06 <applicative> chylli, that's a little ugly.  hmmm
06:59:25 <mysticc> Saizan: Any good package to start learnig FRP
06:59:26 <kmc> erus`, why do you need to enumerate these states?
06:59:43 <mysticc> Saizan: and which is maintained :)
06:59:52 <erus`> well for each turn i have to walk the tree to see the next best move
07:00:11 <erus`> but i have allready evaluated the same position before it saves time
07:00:27 <Saizan> mysticc: not sure, a recently developed one is reactive-banana
07:00:49 <erus`> but i guess its unlikely that the same position will come up again in practise
07:00:51 <Saizan> mysticc: the classic one would be yampa
07:01:09 <mysticc> Saizan: but it does not have good documentation ... I will check yampa ... thanks ...
07:01:36 <applicative> chylli, a simple solution might be cabal update && cabal install yesod hamlet --reinstall  (adding whatever other yesod-y packages you're using to the list)
07:01:55 <applicative> chylli: then cabal install can make inferences about all of them together.
07:02:27 <BlankVerse> mysticc: what is the syntax for matching dont care in oz?
07:04:48 <peteriserins> preflex: seen conal
07:04:48 <preflex>  conal was last seen on #haskell 17 hours, 14 minutes and 57 seconds ago, saying: Axman6: ping
07:05:29 <chylli> applicative: thanks, let me try
07:07:31 <applicative> chylli, also things like this can happen if some things are installed as --user and others as superuser, you might look at ghc-pkg list
07:09:04 <chylli> applicative: ghc-pkg list shows there two version of hamlet
07:09:18 <chylli> applicative: how to fix it ? can I remove the old one ? how ?
07:09:19 <zygoloid> erus`: you can exploit the symmetries of your grid. presumably the players are symmetric and the rules are the same under the 8 symmetries of the board?
07:09:46 <zygoloid> erus`: that should give you a factor of 960 reduction in state space
07:10:02 <erus`> > 15 / 9
07:10:02 <lambdabot>   1.6666666666666667
07:10:16 <erus`> zygoloid: yup i could
07:10:40 <zygoloid> > 64*63*62*61 / 8 / 4*3*2*1
07:10:40 <lambdabot>   2859192.0
07:10:50 <chylli> applicative: both versions are in user package database
07:35:49 <applicative> chylli: sorry  I wandered off.  It shouldn't matter if the old one is still present. you can ghc-pkg unregister hamlet-xx.xxx.x
07:36:02 <applicative> chylli: if you like, i mean
07:48:08 * hackagebot file-location 0.4.0 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.0 (GregWeber)
07:56:39 <ocharles> Urgh, cabal-install is really no fun with only 256mb :(
07:56:41 <ocharles> (ram)
07:56:48 <ocharles> constantly swap heaven
07:57:20 <kmc> :(
07:57:36 <ocharles> could also be my weak sysadmin-fu :)
07:57:38 <kmc> do you have the same problems building with ghc --make directly?
07:57:54 <kmc> 256 MB is quite low :/
07:57:55 <ocharles> I've had to give up on cabal for the last 3 packages and use Setup.hs
07:57:58 <ocharles> it is
07:58:16 <kmc> though 256 MB of RAM was a huge amount back when people first started programming in Haskell
07:58:22 <ocharles> for the last 3 that use custom build types, cabal failed to install them all, and now it just failed to install snap (ExitFailure 9)
07:58:33 <kmc> i think GHC has expanded to fit the resources available to it :)
07:58:38 <kmc> which packages use custom build types?
07:58:41 <ocharles> just waiting for my load to drop below 1 to try and install with -v3 and see what's up
07:58:43 <ocharles> regular and ghc-paths
07:58:48 <kmc> ah
07:58:59 <ocharles> no idea why, doing it without cabal worked fine
07:59:49 <kmc> are you on a tiny VPS or something?
08:00:12 <dcoutts> ocharles: at what stage does it OOM?
08:00:27 <dcoutts> ocharles: it's usually during linking
08:00:29 <ocharles> kmc: a basic slice from slicehost
08:00:38 <ocharles> yay, snap installed second time round
08:00:55 <ocharles> dcoutts: I'm not sure, I'm just doing top after cabal install, and my load is always >4 and I'm using a load of swap
08:01:04 <ocharles> and it stays high for ages, which I can only guess is due to the swap
08:01:04 <kmc> ocharles, you can try ghc -split-objs
08:01:10 <kmc> or is it -no-split-objs ?
08:01:20 <kmc> you could also try using gold as the linker instead of ld, if you're not already
08:01:41 <thoughtpolice> i've noticed gold usually is much faster but sometimes can take up a lot of memory still. YMMV
08:01:44 <ocharles> well I don't really want to be doing builds on this server anyway, so I'm not sure it's worth investing time in new build processes...
08:01:48 <dcoutts> kmc: I don't think -no-split-objs would help since it's the ghc base packages using split objs that's the cause here
08:01:49 <ocharles> haven't heard of gold though
08:02:00 <kmc> ah
08:02:08 <dcoutts> ocharles: hmm, odd about the load average, cabal is totally single threaded
08:02:28 <silver> aww
08:02:29 <ocharles> I'm going to cabal install my own stuff now, i'll see what happens :)
08:02:37 <roconnor> > logBase 2 6
08:02:38 <lambdabot>   2.584962500721156
08:02:47 <ocharles> load is 0.17 before cabal install, give me half an hour and we'll see what it is ;)
08:02:57 <dcoutts> ocharles: with only 256 it's not unlikely that the addition of the cabal process and the linker together pushes things over the edge
08:03:03 <ocharles> yea
08:03:11 <ocharles> I imagine the load is from swapd
08:03:29 <roconnor> > 5*5*logBase 2 6 :: CReal
08:03:30 <lambdabot>   64.6240625180289045363434735986954127189954
08:03:31 <dcoutts> ocharles: try building on your desktop and copying to the server
08:03:32 <ocharles> "Your swap IO usage over the last 4 hours is high: 454.1474 reads/s, 130.3472 writes/s."
08:03:42 <ocharles> dcoutts: desktop is 32bit, server is 64bit
08:03:51 <ocharles> I should probably invest time in getting that to run 32bit binaries
08:04:01 <dcoutts> ocharles: mm, second person this week to have that exact problem
08:04:05 <luite> ocharles: linode has twice the ram for the same price, might make your life easier :)
08:04:08 <ocharles> for the moment, that's probably going to be the best return
08:04:13 <ocharles> luite: oh really?
08:04:25 <ocharles> luite: Do they have the same amount of ram for half the price? ;)
08:04:30 <luite> 512MB for $19.95
08:04:35 <dcoutts> luite: the other person earlier in the week was using linode with 512 and having the same issue :-)
08:04:48 <ocharles> luite: and double storage, nice
08:04:54 <luite> yeah 512 is still low, but at least it's better than 256 :)
08:04:58 <ocharles> more everything in fact...
08:05:04 <dcoutts> but less swap I'm guessing
08:05:09 <kmc> ocharles, yeah, i think you can get 32-bit binaries to work without much trouble
08:05:11 <dcoutts> otherwise it would not OOM there
08:05:20 * ocharles will consider switching next month when he has more time
08:05:26 <luite> I think you can configure your own swap, not sure though
08:05:30 <kmc> ocharles, note that GHC statically links Haskell code to other Haskell code, by default
08:05:41 <kmc> it's only libc and such that would be dynamically linked
08:05:44 <ocharles> kmc: yea, so I don't need many support libraries you mean
08:05:49 <kmc> yeah
08:05:54 * ocharles gives up and spends time on that
08:06:00 <dcoutts> ocharles: I don't recall if current ghc binary releases ship shared libs, if they do then that's worth trying
08:06:06 <kmc> is your desktop machine actually not 64-bit-capable?
08:06:10 <ocharles> it is capable
08:06:11 <kmc> or you just don't have a 64-bit OS?
08:06:17 <rwbarton> you can use ldd on the 32-bit executable to see what it needs
08:06:23 <dcoutts> ocharles: since that would avoid the "split-objs makes the linker cry" problem
08:06:32 <Axman6> or otool on OS X
08:06:51 <luite> http://library.linode.com/linode-platform/migration/migrate-server-to-linode <- yeah you can choose the size of your swap device
08:06:55 <ocharles> https://gist.github.com/1154346
08:07:04 <dcoutts> ocharles: here's a test for you: ghc --make Setup.hs -dynamic
08:07:06 <thoughtpolice> i'm pretty sure by default GHC makes it's libraries available in every way that's available for the platform; e.g. yes, base etc will have shared versions on OS X/linux
08:07:16 <thoughtpolice> since shared libs are supported on both
08:07:17 <ocharles> will ia32-libs provide all of that (debian wheezy)?
08:07:37 <thoughtpolice> yes, ia32-libs provides most of what you need, but you also need gcc-multilib
08:07:43 <ocharles> ok
08:07:44 <roconnor> > (2*5 + 2)*logBase 2 6 :: CReal
08:07:46 <lambdabot>   31.0195500086538741774448673273737981051178
08:08:34 <ocharles> thoughtpolice: this is needed even for just running 32bit binaries?
08:08:39 <thoughtpolice> oh, just running?
08:08:43 <thoughtpolice> no, i misunderstood. sorry
08:08:48 <thoughtpolice> ia32-libs should be all you need in that case
08:08:58 <ocharles> ah, yay less deps
08:09:22 <rwbarton> does that include things like libgmp?
08:09:54 <kmc> i think integer-gmp contains its own chopped & screwed copy of libgmp
08:09:56 <kmc> but not sure
08:10:10 <thoughtpolice> it does, i think when needed it applies some patches etc
08:10:11 <kmc> ocharles, you could also make an *actually* static binary
08:10:22 <thoughtpolice> although you can set a variable in your mk/build.mk to use the system GMP if you want
08:10:23 <kmc> that's more work though
08:10:27 <thoughtpolice> typically it's ok to let GHC use its own though
08:10:29 <ocharles> how'd I do that? I'm using cabal for builds atm
08:10:29 <ocharles> oh, ok
08:10:49 <thoughtpolice> you need to make the linker do a static link, so you need to say something like,
08:10:57 <thoughtpolice> ghc -optl-static ...
08:11:36 <thoughtpolice> (implicitly the default is to statically link all *haskell* libraries, but the '-optl-static' part says 'give -static to ld when it is run at the end')
08:12:36 <kmc> a lot of glibc functions don't work right in static binaries, with a standard glibc config, without extra hoop jumping
08:12:42 <kmc> foo.c:(.text+0xf): warning: Using 'gethostbyname' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
08:12:56 <kmc> s/gethostbyname/any of dozens of other functions/
08:13:16 <dcoutts> but you'd only want to link gmp statically, not glibc
08:13:24 <ocharles> lets see what happens if I just stick the normal 32bit build on the server first
08:13:30 <ocharles> almost done uploading
08:13:42 <kmc> -optl-static will link *everything* statically, right dcoutts?
08:13:57 <kmc> as in, the file you get out is an ELF static executable
08:14:41 <ocharles> ok, so I have my binary, and ia32-libs. is it just a case of ./binary, or do I need to chroot to a 32bit environment first?
08:15:56 <dcoutts> kmc: it probably applies to all packages listed after that on the command line
08:15:57 <ocharles> ./bookbrainz-server: error while loading shared libraries: libpq.so.5: wrong ELF class: ELFCLASS64 -- which looks like a problem with postgresql
08:16:00 <dcoutts> or something like that
08:16:18 <thoughtpolice> kmc: i'm pretty sure it will. glibc does not make static linking so easy on linux :(
08:16:45 <kmc> ocharles, you'll need the 32-bit libpg.so
08:16:49 <kmc> debian might have it packaged
08:16:58 <kmc> i'm wondering why it tried the 64-bit one
08:18:11 <ocharles> nope, not that I can see, hum
08:18:13 <thoughtpolice> well, ia32-libs is the 32bit versions of all the core deps. ia32-libs can't possibly know about the needed 32bit versions of *everything*, so you also need a 32bit libpq.so
08:18:19 <ocharles> yea
08:18:22 <kmc> yeah, i don't see it either :/
08:18:23 <ocharles> figured that much :)
08:18:30 <ocharles> but I think that means I need to build my own 32bit postgresql
08:18:40 <ocharles> or statically link libpq?
08:19:06 <jaspervdj> edwardk: I'm ready if you want to set up the conference call.
08:19:08 <kmc> or just get the debian libpg package for i386 architecture
08:19:12 <kmc> and suck the file out
08:19:19 <edwardk> i'll be a few minutes
08:19:30 <kmc> i don't know if there's a nice way to install it, then
08:19:42 <ocharles> kmc: I'd probably stick that in /usr/local/lib and make sure that's in my ldconfig
08:19:59 <kmc> it wouldn't actually surprise me if somebody wrote a script to turn a i386 package into a amd64 ia32-libs-blah package
08:20:08 <mornfall> ocharles: Luckily, we'll have proper multiarch in Debian in another 5 or 10 years. :P
08:20:19 <ocharles> lol :)
08:20:41 <mornfall> (By which time no-one will remember what ia32 was, too.)
08:21:02 <ocharles> I wonder how hard it is to update this gentoo to 64bit
08:21:22 <kmc> heh
08:21:55 <kmc> you'll get generally better performance if you switch your desktop to 64-bit
08:22:11 <kmc> because they fixed several flaws in the x86 architecture in x86_64
08:22:12 <mornfall> kmc: Are you sure? I would say it's about irrelevant.
08:22:22 <kmc> even aside from the word size
08:22:33 <kmc> mornfall, not in every case, and there are some factors in the other direction
08:22:43 <mornfall> Well, big pointers make (especially functional :P) programs more cache hungry.
08:22:45 <kmc> but i think it's a win, yeah
08:22:51 <kmc> that's true
08:23:08 * hackagebot temporary 1.1.2.1 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-1.1.2.1 (MaxBolingbroke)
08:23:22 <ocharles> back to installing haskell packages :)
08:23:26 <mornfall> But I guess with modern CPUs and the amounts of RAM we get, it definitely makes sense to use 64b.
08:23:35 <mornfall> My next machine will get a 64b system on it, I guess.
08:23:48 <kmc> you can still run 32-bit user code if you want
08:23:59 <kmc> ia32 has a stupidly small number of registers
08:24:04 <thoughtpolice> i only do 64bit on my machines if at all possible
08:24:04 <kmc> amd64 fixes that
08:24:14 <kmc> it also adds an IP-relative addressing mode
08:24:21 <kmc> which makes position-independent code more efficient
08:24:21 <thoughtpolice> among others, i actually like having a non-register-starved machine, yes :P
08:24:46 <kmc> in the worst case with PIC on ia32, the compiler only has 5 registers to play with
08:25:28 <mornfall> kmc: Which is not much worse than your brain anyway. :P
08:25:34 <kmc> 7±2
08:25:36 <thoughtpolice> yeah, since esp, ebp and another register (i can't remember on ia32 what the PIC reg typically is, ebx?) will be stolen
08:25:37 <kmc> ;P
08:25:43 <kmc> i think ebx thoughtpolice
08:25:48 <thoughtpolice> yeah that's what i thought
08:26:08 <thoughtpolice> i haven't run a 32bit machine, modulo windows, in a looong time :P
08:26:22 <kmc> i've been reading 32-bit more than 64-bit assembly recently
08:26:30 <kmc> 'cause the smashthestack.org wargames are 32-bit
08:26:40 <ocharles> HDBC-postgresql-2.3.2.0 failed during the configure step. The exception was:
08:26:40 <ocharles> ExitFailure 1
08:26:46 <ocharles> Sigh, I'm seeing this over and over again on this machine :(
08:26:51 <thoughtpolice> that's one thing i've noticed, i'm much better at analyzing 32-bit asm than 64bit, but i think that's because the ia32 calling convention is burned into my brain
08:26:56 <ocharles> I wish cabal was actually *informative* when it failed
08:27:01 <mornfall> Hm, I get a new laptop next summer.
08:27:02 <thoughtpolice> where the amd64 one is not
08:27:11 <mornfall> Hopefully there's actually something worth having by then.
08:27:14 <dcoutts> ocharles: you mean when something dies due to OOM?
08:27:21 <ocharles> I don't know why it died
08:27:27 <ocharles> it just failed to install, I don't think it's oom
08:27:35 <thoughtpolice> kmc: so have you used your skillz to hax the ghc gibson yet?
08:27:46 <kmc> no
08:27:55 <ocharles> Cool, ExitFailure 9 if I run it again
08:28:40 <kmc> need moar bitz
08:28:48 <ocharles> it only happens with stuff that uses a custom build strategy, I think
08:28:54 <mornfall> Lenovo TP X220 might be reasonable, I guess (anyone owns one yet?)
08:29:04 <kmc> i know people that do
08:29:17 <kmc> i'm a fan of the Lenovo X series
08:29:25 <kmc> the X220 is definitely a step down from the older one I have now, though
08:29:34 <ocharles> I have an x120e, it's horrible
08:29:36 <mornfall> I'm on X200.
08:29:40 <ocharles> it can barely stream youtube
08:29:41 <mornfall> ATM
08:29:48 <mornfall> The display is horrible.
08:30:09 <mornfall> Other than that, it's a decent box.
08:30:10 <kmc> really?
08:30:23 <kmc> i'm quite happy with the display on my X200s
08:30:30 <kmc> (it is different from the X200 though)
08:30:31 <mornfall> Well, compared to my cheap iiyama TF LED panel, yes.
08:30:41 <ocharles> I can't believe http://shop.lenovo.com/us/products/laptops/thinkpad/x-series/index.html actually says "EPIC BATTERY LIFE"
08:30:50 * ocharles shakes his head
08:31:01 <kmc> ocharles, the x100 series barely counts as a thinkpad
08:31:10 <kmc> lenovo is diluting their brand in order to sell netbook junk to The Enterprise
08:31:13 <thoughtpolice> hahahahaha
08:31:17 <ocharles> yea, it was dirt cheap though and I needed it before going to GSOC mentor summit last year
08:31:18 <dcoutts> ocharles: Exit code 9 usually means OOM, however our current System.Process API does not let Cabal detect that reliably
08:31:23 <thoughtpolice> although i must admit
08:31:29 <thoughtpolice> my new x220t does have pretty damn good battery life
08:31:31 <ocharles> dcoutts: ah, I see...
08:31:38 <kmc> tablet?
08:31:43 <bos> edwardk: ping
08:31:46 <thoughtpolice> kmc: yea
08:31:50 <ocharles> dcoutts: do I have any options doing "cabal install HDBC-postgresql" or should I try and build it myself?
08:31:52 <dcoutts> ocharles: well, not OOM strictly, but bus error / segfault or something like that, which happens to be what the OOM uses
08:31:54 <edwardk> skype: ekmett
08:32:00 <mornfall> ocharles: Oh. Mentor. *fears for life and scurries back to hacking*
08:32:10 <illissius_> bcoppens: yep.
08:32:11 <edwardk> i'll conference you in with jasper
08:32:14 <mornfall> Actually blog-writing.
08:32:24 <thoughtpolice> kmc: also i agree, i liked the older x200 models
08:32:24 <dcoutts> ocharles: I'm not quite sure what you mean, you can try the automated method, or you can try manually
08:32:37 <thoughtpolice> (they felt more sturdy, and i personally prefer having the lid lock when i close it, etc)
08:32:43 <thoughtpolice> also it did have higher res :(
08:32:44 <jaspervdj> tibbe: ping
08:32:53 <ocharles> dcoutts: I meant can I run "cabal install --some-fancy-flags HDBC-postgresql", or should I get it and runghc on Setup.hs
08:33:09 <kmc> thoughtpolice, does any current laptop by any manuf. have the 1440 x 900 (or better) 12" panel?
08:33:37 <dcoutts> ocharles: did anyone suggest you use any fancy flags?
08:33:41 <ocharles> no :)
08:33:44 <ocharles> but cabal install doesn't work
08:33:44 <thoughtpolice> kmc: the sony vaio Z series? those motherfucking laptops are insane as fuck
08:33:51 <kmc> ah, sony
08:34:00 <ocharles> I'm asking bad questions, sorry
08:34:05 <dcoutts> ocharles: you mean it reports ExitCode 9?
08:34:08 <thoughtpolice> kmc: thinner than the MBA, dual SSD's by default on raid-0, nvidia GPU, 1080p out of the box, bluray player, all kinds of crazy shit
08:34:09 <ocharles> dcoutts: indeed
08:34:15 <tibbe> jaspervdj, pong
08:34:31 <kmc> apple gives you real design.  lenovo gives you real engineering.  sony is all about brushed metal and blue LEDs designed to scream LOOKA ME I'M RICH
08:35:08 <dcoutts> ocharles: so as I mentioned before, you might be able to squeak by by having one less process in memory, ie by doing it manually. However I think it'd also be worth trying dynamic linking as I mentioned previously.
08:35:10 <thoughtpolice> mornfall: i've had my lenovo TP x220t (t => tablet) for the past few days. overall i'm very pleased with it. the screen res is only smaller than my old x200 by a tad bit, which sucks. i also got a hell of a lot of money off on it through good deals right now
08:35:18 <thoughtpolice> mornfall: overall i'm a huge fan of the thinkpad X series
08:35:26 <thoughtpolice> kmc++
08:35:30 <kmc> though the pics of the VAIO Z series make it look less gaudy than I've come to expect from them
08:35:35 <dcoutts> ocharles: test this: ghc --make Setup.hs -dynamic
08:35:38 <jaspervdj> tibbe: could you come online on skype? I'll add you to the conference call
08:35:40 <ocharles> yep, doing that now
08:35:42 <mstevens> thoughtpolice: I have an old x60s which is excellent, although it's getting a little battered these days.
08:36:13 <tibbe> jaspervdj, sec
08:36:22 <ocharles> dcoutts: I'm doing this on HDBC's Setup.hs btw, my project doesn't have that file
08:36:22 <tibbe> jaspervdj, just got back from the gym :)
08:36:27 <dcoutts> ocharles: in particular see if that's quicker or takes less memory than without the -dynamic
08:36:30 <thoughtpolice> i've really only had nothing but good experiences with the X series. and yes the x100/x120e don't count
08:36:33 <dcoutts> ocharles: shouldn't matter
08:36:34 <jaspervdj> tibbe: ah, ok, sure :-)
08:36:34 <thoughtpolice> i just pretend they don't exist, really :)
08:37:02 <ocharles> dcoutts: can't find Prelude with that, I need the "dyn" libraries first it seems
08:37:09 <thoughtpolice> mstevens: honestly i've played around with lots of their machines and my roommate has a T series (and a friend had the R or whatever,) they're all just really high quality
08:37:20 <dcoutts> ocharles: are you using debian packages of ghc?
08:37:23 <ocharles> yea
08:37:25 <ocharles> on wheezy
08:37:29 <ocharles> ghc-dynamic?
08:37:34 <kmc> i've had mixed experiences with Lenovo (actually still IBM) repair support, though
08:37:38 <tibbe> jaspervdj, wonder if the office network blocks skype
08:37:40 <dcoutts> ocharles: see if they provide shared lib versions of the ghc libs
08:37:42 <tibbe> jaspervdj, looks like it :(
08:37:49 <thoughtpolice> kmc: i've luckily never needed to go that far
08:37:50 <dcoutts> ocharles: as a debian package I mean
08:37:51 <jaspervdj> tibbe: oh noes :-(
08:37:55 <tibbe> jaspervdj, probably cause skype is one big security mess
08:37:57 <thoughtpolice> on that note, i need to take my broken old MBP to an apple store
08:38:14 <jaspervdj> tibbe: I'm not sure whether or not we can try a google+ hangout?
08:38:14 <thoughtpolice> i think it died because of a gfx card failure on the nvidia line, for which apple extended the warrenty on all machines
08:38:24 <ocharles> dcoutts: it is indeed quicker
08:38:33 <ocharles> considerably
08:38:34 <tibbe> jaspervdj, if everyone has an account, otherwise I can be on IRC
08:38:37 <luite> thoughtpolice:  to 4 years, so don't wait too long
08:38:42 <thoughtpolice> luite: yea
08:38:59 <tibbe> jaspervdj, switching computer, sec
08:39:07 <tibbe> jaspervdj: back
08:39:09 <mstevens> thoughtpolice: I had heards the quality had gone downhill since the lenovo takeover, but I've not used one of the more recent ones
08:39:21 <jaspervdj> bos: could you do a google+ hangout?
08:39:31 <thoughtpolice> mstevens: i can't compare to when they were IBM, didn't have the monies for one back then :)
08:39:35 <ocharles> dcoutts: so with -dynamic, it's good - is there a way to make 'cabal install' use that?
08:39:35 <dcoutts> ocharles: so you can try reinstalling all your Haskell libs with --enable-shared and --enable-executable-dynamic
08:39:39 <bos> jaspervdj: let's try it!
08:40:11 <dcoutts> ocharles: it probably will still compile some Setup.hs scripts with static linking, but hopefully that's small enough to work
08:40:32 <ocharles> dcoutts: well compiling HDBC-postgresql's Setup.hs without it uses too much memory
08:41:00 <kmc> i still think building these on another machine will be easiest
08:41:08 <ocharles> yep, I think I agree with you
08:41:25 <ocharles> I just have nothing else that is 64bit :)
08:41:40 <ocharles> i'll probably nuke the laptop tonight
08:41:50 <dcoutts> ocharles: you mean so much that it still dies with signal 9?
08:42:16 <ocharles> dcoutts: well, I just tried: ghc Setup.hs  and killed it myself before it finished, and load was at 1.5
08:43:00 <dcoutts> ocharles: you might be able to hack it with --ghc-options=-dynamic but I'm not 100% sure if that will not have other consequences
08:43:19 <ocharles> Linking ./dist/setup/setup ...
08:43:20 <ocharles> collect2: ld terminated with signal 9 [Killed]
08:43:21 <dcoutts> ocharles: you'd probably also want to use --disable-library-vanilla
08:43:36 <tibbe> edwardk: jasper sent you an invite
08:43:39 <ocharles> I think I'm just going to wait until I have a 64 bit machine to build on
08:43:50 <ocharles> this is just headache after headache right now
08:43:53 <dcoutts> ocharles: that was using --ghc-options=-dynamic ?
08:44:05 <ocharles> dcoutts: no, I'll try that
08:44:44 <tibbe> bos: yes
08:44:53 <tibbe> bos: before we could not here you but you could hear us?
08:44:57 <ocharles> dcoutts: does get further with that...
08:45:32 <tibbe> edwardk: you there?
08:47:48 <edwardk> bos: pong
08:49:12 <bos> edwardk: was just lookin' for you on g+ :-)
08:49:49 <ocharles> yea, I'm not getting anywhere with this, I'm going to give up and wait til I have a 64 bit build machine
08:50:00 <ocharles> thanks for the help dcoutts, kmc and everyone...
08:50:16 <kmc> good luck :
08:50:18 <kmc> :)
08:50:35 <dcoutts> ocharles: out of interest, where does it die after that?
08:50:51 <ocharles> dcoutts: https://gist.github.com/1154436
08:50:59 <ocharles> hrm
08:51:08 <ocharles> that's because I need to rebuild bytestring with dynamic
08:51:15 <dcoutts> ocharles: I mentioned you'd need to reinstall all the deps with those flags
08:51:16 <ocharles> but I'm not rebuilding everything again
08:51:17 <ocharles> yea
08:51:21 <ocharles> that's going to take hours on this machine
08:51:24 <dcoutts> fair enough :-)
08:56:57 <wjlroe> How do I unwrap a value from a monad? if I have something like  woot = do; blah <- something; (and blah is Gen a0) - quickcheck monad - how do I just return the value?
08:57:23 <kmc> there's no general way to go from M T to T
08:57:29 <kmc> there is for some specific monads
08:57:40 <kmc> but i think you're a little confused
08:57:58 <kmc> seems like probably 'something' has type (Gen T) and 'blah' then has type T
08:58:28 <kmc> when you write «do x <- a; b»  that's the same as «a >>= (\x -> b)»
08:58:32 <kmc> :t (>>=)
08:58:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:58:40 <kmc> i.e.   Gen a -> (a -> Gen b) -> Gen b
08:59:25 <wjlroe> kmc: here's some more concrete example of what I'm doing: http://hpaste.org/50434
09:00:08 <kmc> i think you want "return False" and "return (extra == x)"
09:00:18 <kmc> or you can float that "return" outside of the case
09:00:28 <wjlroe> kmc: rather overcomplicated maybe, but I'm trying to test adding a field to some json object and checking that it can be parsed again
09:00:29 <kmc> each statement in a "do" block has to be a monadic action
09:00:50 <wjlroe> kmc: this function has to return Bool because it's a test
09:00:57 <kmc> it can't return Bool
09:01:10 <kmc> since you're using "do" in the Gen monad
09:01:15 <accel> so I just wrote a mac cocoa
09:01:17 <accel> app and I have to say
09:01:18 <accel> it's beautiful
09:01:22 <kmc> and you haven't applied any kind of (Gen T -> T) function
09:01:23 <accel> almost as beautiful as hekll
09:01:24 <accel> haskell
09:01:30 <bob31> I did some mucking with cabal-install.cabl and bootstrap.sh, but cannot satisfy the base build-dep for cabal-install to link with 7.2.1
09:01:31 <accel> ... so why has no one writen a proper haskell/cocoa binding?
09:02:02 <kmc> wjlroe, can't you take 'key' and 'val' as parameters instead?
09:02:10 <kmc> then quickcheck will generate them for you
09:02:26 <wjlroe> kmc: well I suppose but I can't work out how to do that
09:02:29 <kmc> you'd explicitly invoke 'arbitrary' only when defining new instances of Arbitrary, I think
09:03:05 <wjlroe> kmc: oh actually, I'm being dense, I can just change the signature to  ... -> String -> String -> Bool
09:03:28 <kmc> yeah, try that
09:04:14 <wjlroe> kmc: well it compiles. In my book that means I've (or you have) earned me a cup of tea
09:04:21 <kmc> haha
09:04:21 <wjlroe> kmc: cheers
09:04:27 <kmc> i was just going to have some tea, actually :D
09:04:39 <wjlroe> ALL TESTS PASS. Glorious win
09:06:03 <brisingr> hey, another noobish question: I think I understand how the following is supposed to work, but it just doesn't click into place :(
09:06:06 <brisingr> fix ((1:) . (>>= \x -> [x+1, 1/(x+1)])) :: [Rational]
09:06:21 <kmc> crazy  code
09:06:33 <kmc> > fix ((1:) . (>>= \x -> [x+1, 1/(x+1)])) :: [Rational]
09:06:35 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
09:06:47 <kmc> enumerates all positive rational numbers?
09:06:54 <brisingr> I know that
09:07:00 <kmc> i didn't :D
09:07:03 <brisingr> oh oh now it makes sense
09:07:15 <brisingr> (i read it somewhere, that's why I knew)
09:07:26 <brisingr> what they did say was "no repetitions"
09:07:28 <kmc> > let xs = 1 : (xs >>= \x -> [x+1, 1/(x+1)]) in xs :: [Rational]
09:07:29 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
09:07:40 <brisingr> that's what I didn't get
09:07:46 <brisingr> the "no repetitions" part
09:07:48 <mauke> >>= is concatMap
09:07:59 <rwbarton> it's based on continued fractions essentially
09:08:03 <kmc> > let xs = 1 : concat [ [x+1, 1/(x+1)] | x <- xs] in xs :: [Rational]
09:08:04 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
09:08:14 <brisingr> so basically it progressively generates the list
09:08:16 <rwbarton> ^ this one is what I would write
09:08:23 <brisingr> based on previous combinations
09:08:56 <kmc> every rational is either 1, the successor of a rational, or the inverse of the successor of a rational
09:09:04 <brisingr> logically
09:09:12 <kmc> the last clause is awkward but it keeps you from double-counting 1, i guess
09:09:26 <brisingr> the question I had was that it said
09:09:35 <brisingr>  [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%5...
09:09:38 <copumpkin> kmc: what about 0?
09:09:41 <brisingr> and those don't repeat
09:09:44 <copumpkin> or the negative
09:09:47 <kmc> yeah, it doesn't enumerate 0
09:09:52 <kmc> i meant "positive rational" i guess
09:10:17 <copumpkin> > 1 : fix ((1 % 1 :) >=> \x -> [1+x, 1 / (1 + x)])
09:10:18 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
09:10:53 <brisingr> wait, wait
09:11:06 <brisingr> how about those larger than 1?
09:11:14 <kmc> like 3 % 1 ?
09:11:19 <brisingr> yes
09:11:25 <kmc> well, it's in the list
09:11:32 <brisingr> infinitely down the list?
09:11:34 <kmc> it's the successor of 2 which is the successor of 1
09:11:37 <kmc> it's right there
09:11:42 <brisingr> oh
09:11:43 <brisingr> oh
09:11:45 <brisingr> the damn spaces
09:11:53 <brisingr> I was grouping them wrong
09:12:00 <kmc> > map realToFrac (1 : fix ((1 % 1 :) >=> \x -> [1+x, 1 / (1 + x)])) :: [Double]
09:12:01 <lambdabot>   [1.0,2.0,0.5,3.0,0.3333333333333333,1.5,0.6666666666666666,4.0,0.25,1.33333...
09:12:20 <brisingr> damn me
09:12:21 <brisingr> thanks
09:12:35 <brisingr> can we use removeDups?
09:12:39 <kmc> exercise to the reader: enumerate the real numbers
09:12:57 <mauke> why map realToFrac when you can just remove the type annotation?
09:13:10 <kmc> cause then they're not rationals are they ;)
09:13:21 <Cale> brisingr: There shouldn't be any duplicates
09:13:53 <brisingr> I don't quite understand why
09:14:34 <Cale> What it's doing is essentially a breadth-first search on the Stern-Brocot tree.
09:15:18 <Cale> http://en.wikipedia.org/wiki/Stern%E2%80%93Brocot_tree
09:16:04 <brisingr> now I think I get it
09:16:34 <brisingr> yes, definitely
09:16:42 <kmc> "Stern was a German number theorist; Brocot was a French clockmaker"
09:16:54 <brisingr> thanks very much for your help
09:17:12 <brisingr> I should throw a big party in your honor
09:17:12 <mauke> http://blog.plover.com/math/age-fraction-2.html
09:17:35 <brisingr> look, if we ever meet at a Haskell convention I'll buy you all beers
09:17:45 <brisingr> :)
09:17:59 <brisingr> you saved my talk
09:17:59 <Cale> http://www.comlab.ox.ac.uk/people/jeremy.gibbons/publications/rationals.pdf
09:18:09 <kmc> cool!
09:18:11 <kmc> talk about?
09:18:19 <acowley> I know I came late, but I do like beer
09:18:35 <chrisdone> break on through to the other side
09:18:47 <Cale> Oh, right, it's really the Calkin-Wilf tree, which is just a rearrangement of the Stern-Brocot tree.
09:18:48 <maltem> hey guys, I heard there's a party to happen
09:18:55 <brisingr> well, you're gonna have to wait till I actually go to a haskell convention
09:19:05 <brisingr> but yeah, we can do it online I guess
09:19:06 <brisingr> :)
09:19:12 <brisingr> *party time*
09:19:33 <kmc> what's the talk about, brisingr?
09:19:42 <brisingr> the coolness of haskell
09:19:43 <acowley> beer, I think
09:19:53 <brisingr> it's not very important, but I want to make it perfect
09:19:59 <kmc> cool
09:20:05 <kmc> i am preparing a talk on a similar topic
09:20:12 <kmc> can i see your slides / whatever you prepared?
09:20:23 <kmc> mine will go online soon, within the next month i guess
09:20:29 <Cale> > let posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)]); pyth r = (x,y,z) where {m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2] in map (pyth . (+1)) posRationals
09:20:30 <lambdabot>   <no location info>: parse error on input `in'
09:20:35 <Cale> > let posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)]); pyth r = (x,y,z) where {m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2]} in map (pyth . (+1)) posRationals
09:20:36 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(8,15,17),(7,24,25),(20,21,29),(16,30,34),(10,2...
09:20:49 <brisingr> I don't even think it'll have online coverage
09:20:59 <brisingr> but I'll post the slides
09:21:05 <Cale> ^^ unique reduced Pythagorean triples
09:21:26 <brisingr> Cale: cool
09:21:44 <Cale> er
09:21:56 <Cale> not reduced :P
09:22:03 <brisingr> but still cool:)
09:22:28 <brisingr> isn't it the same thing as the list comprehension one?
09:22:36 <brisingr> but I guess much more efficient
09:22:58 <Cale> yeah, a lot more efficient, and the ordering is different
09:23:27 <kmc> @pl \x -> [x+1, 1/(x+1)]
09:23:27 <lambdabot> liftM2 (:) (1 +) (return . (1 /) . (1 +))
09:23:47 <Cale> It's more or less doing a stereographic projection of the rational points on the line to rational points on a circle, and giving the corresponding Pythagorean triples from there
09:24:02 <parcs> > take 1000000 (repeat ()) `seq` ()
09:24:03 <lambdabot>   ()
09:24:37 <Cale> (the points lying properly in the first quadrant, mapped to from the rationals greater than 1)
09:24:59 <Cale> http://en.wikipedia.org/wiki/File:Stereographic_projection_of_rational_points.png
09:25:13 <kmc> > fix ((1:).(>>=(:)<$>(1+)<*>((:[]).(1/).(1+))) :: [Rational]
09:25:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
09:25:38 <kmc> > fix ((1:).(>>=(:)<$>(1+)<*>((:[]).(1/).(1+)))) :: [Rational]
09:25:40 <lambdabot>   [1 % 1,2 % 1,1 % 2,3 % 1,1 % 3,3 % 2,2 % 3,4 % 1,1 % 4,4 % 3,3 % 4,5 % 2,2 ...
09:25:58 <kmc> HaskAPL
09:26:25 <brisingr> I thought I'd never see obfuscated haskell code
09:26:38 <Cale> and then of course we can clean that up to remove ones which have a common divisor...
09:27:00 <Cale> > let posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)]); pyth r = (x,y,z) where {m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2]} in filter (\(a,b,c) -> gcd a (gcd b c) == 1) . map (pyth . (+1)) posRationals
09:27:01 <lambdabot>   Couldn't match expected type `[(t, t, t)]'
09:27:01 <lambdabot>         against inferred type `(...
09:27:03 <Cale> oops
09:27:12 <hpaste> kmc pasted “obfuscated Haskell code” at http://hpaste.org/50436
09:27:24 <Cale> > let posRationals = 1 : (posRationals >>= \x -> [1+x, 1/(1+x)]); pyth r = (x,y,z) where {m = numerator r; n = denominator r; [x,y,z] = sort [2*m*n, m^2 - n^2, m^2 + n^2]} in filter (\(a,b,c) -> gcd a (gcd b c) == 1) . map (pyth . (+1)) $ posRationals
09:27:25 <lambdabot>   [(3,4,5),(5,12,13),(8,15,17),(7,24,25),(20,21,29),(9,40,41),(33,56,65),(28,...
09:27:28 <brisingr> kmc: no way!
09:27:36 <kmc> this is my personal best so far
09:27:47 <kmc> there have been obfuscated haskell contests, but not regularly
09:28:04 <Cheery> it's not entirely ontopic, but I'd expect to find mathematicians here.
09:28:23 <Cheery> well.. or computer scientist guys..
09:28:37 <brisingr> kmc: the problem is, I guess, that in any haskell code, if you take the time to redo the indentation and some flattening
09:28:56 <brisingr> I'm quite sure it wouldn't be so bad
09:29:09 <brisingr> that's the problem with haskell
09:29:20 <mysticc> Is there some kind of virtual environment for haskell ... I find few libraries incompatible with 7.x so I want to work on them with ghc 6.x without uninstalling the present one
09:29:22 <benmachine> Cheery: I'm doing maths at university
09:29:24 <brisingr> it's very difficult to write unmaintainable code
09:29:28 <benmachine> I'm also going to dinner though so bye
09:29:31 <kmc> brisingr, i don't agree
09:29:36 <acowley> mysticc: 7.0.x is pretty compatible
09:29:51 <kmc> mysticc, sounds a little like cabal-dev
09:29:59 <maloi> kmc: what does the code?
09:30:01 <acowley> Cheery: you should go ahead and ask your question
09:30:05 <kmc> brisingr, no language can prevent you from making a mess if you try
09:30:12 <mysticc> acowley: I want to work on reactive which shows so many errors with ghc 7.x and never installs
09:30:23 <Cheery> I've got mixed expression+ssa-form that is defined like this: http://paste.pocoo.org/show/460349/
09:30:31 <Cale> brisingr: except that some of the entries did stuff like encoding thunks in ByteStrings in the format that the GHC runtime expects and then using unsafe primitives to get them into memory and enter them.
09:30:33 <brisingr> kmc: yeah, but it can make you a hell of a time trying
09:30:37 <kmc> brisingr, i promise there's a few more surprises in my example, though it's not as messy as it could be
09:30:38 <BlankVerse> anything similar to python virtual-envs?
09:30:50 <acowley> mysticc: why not something like reactive-banana?
09:30:55 <kmc> maloi, try it :)
09:30:59 * brisingr - brb
09:30:59 <kmc> feed it some text on standard in
09:31:21 <ricree> brisingr, I've seen some scary looking things done with the type system when people are trying to be clear and concise.  I'd hate to imagine what people could come up with if they were really trying to obfuscate
09:31:22 <Cheery> now that does nice reduction, but I'm worrying about halting my compiler or 'optimizing' into programs that are larger than the originals.
09:31:29 <Cale> > let (a,b,c) = (51397555,89248188,102990037) in a^2 + b^2 == c^2
09:31:30 <ricree> Or scary to me, anyways
09:31:30 <lambdabot>   True
09:31:33 <mysticc> acowley: First wanted to try the standard one with lots of docs to get a feel of FRP :)
09:31:36 <roconnor> Cale: I didn't know that stereographic property!
09:31:40 <brisingr> I've seen a 20-line implementation of powerset
09:31:52 <BlankVerse> mysticc: last question main FoldL karna hai ya FOldR?
09:32:04 <Cale> roconnor: yeah, it's quite convenient
09:32:20 <kmc> ricree, brisingr, like this? http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html
09:32:47 <Cheery> acowley: you got the problem I see here?
09:33:12 <maloi> kmc: there is just scrolling text :)
09:33:16 <acowley> mysticc: but I think it's lack of current maintenance is a warning sign. Since there are actively maintained competitors whose authors/maintainers are also accessible promoters, you should give another library a shot. reactive-banana, as an example, draws a lot from Conal's work.
09:33:35 <rostayob> kmc: what is that lol
09:35:10 <Cale> roconnor: It's easy to prove too, because if you pick a rational point on the circle, then the line through it has rational slope and will of course hit a rational number on the x axis.
09:35:38 <roconnor> Cale: I sometimes think about using the completion of the rational unit circle points to implement S^1.
09:35:40 <mysticc> acowley: Ok ... I was reading reactive docs , but could never try the examples as I could not install it ... will check reactive banana now :) thanks ...
09:35:57 <acowley> Cheery: I may be misunderstanding your situation, but perhaps you want to decorate the grammar to carry metainformation about things like optimization
09:36:38 * brisingr is back
09:37:07 <Cheery> acowley: this should be quite clear: http://paste.pocoo.org/show/460353/
09:37:18 <Cale> roconnor: (the other direction is slightly messier)
09:37:31 <brisingr> kmc: dunno
09:38:06 <roconnor> Cale: do these rational points for a group under rotation by a rational point?  It would be nice if they did, and it seems plausible.
09:38:24 <Cheery> acowley: things I'm worrying about is that I'd be hitting fancy form of something like: start(exit) -> start(exit)  and hang up with compiling
09:38:41 <acowley> Cheery: you're right that you can't do this blindly
09:39:14 <Cheery> this is equivalent to pre-evaluating the program, and even worse, evaluating it from a middle.
09:39:27 <Cale> roconnor: sure -- if (p,q) is on the unit circle, then so is (-q,p), and so the matrix representation of the rotation has rational coefficients
09:39:33 <acowley> Cheery: but I don't see a deep problem here. You have an evaluator that tracks its depth and/or the size of the generated AST it is producing
09:40:48 <Cheery> acowley: well.. am I able to do some theorems that state if the program is of a certain form, it can be folded away?
09:42:55 <Cheery> that kind of thing would only figure out that it's doing inefficient job.. but I'd then need a way to go back.
09:44:01 <brisingr> kmc: does your program halt?
09:44:33 <acowley> The main thing that you might prove is that your optimization is semantics-preserving. Beyond that, you could think about static termination checking, but the usual thing is to have an incremental optimizer guided by heuristics (e.g. that look at code size).
09:44:44 <kmc> don't think so brisingr
09:44:53 <acowley> Cheery: going back is no problem if you're doing this with persistent structures
09:45:24 <Cheery> hmm.. would my formatting support that kind of going?
09:45:29 <acowley> optimize ast = let ast' = unroll1 ast in if codeSize ast' > threshold then ast else optimize ast'
09:45:43 <kmc> brisingr, it should generate text forever
09:46:04 <acowley> unroll1 is a transformation whose soundness you can prove
09:46:24 <brisingr> kmc, I've noticed that it sometimes generates the original text, is there a rule
09:46:30 <brisingr> or is it secret? ;)
09:46:56 <acowley> then it's just a question of when it's worth doing, and that depends on factors most likely outside of the logic embodied by your language semantics or type system
09:46:56 <kmc> it's a markov-chain text generator
09:47:22 <kmc> with a 3-character state
09:48:05 <Cheery> acowley: okay. I guess it may be solvable thing then.
09:48:13 <Cheery> proceeding with this form :)
09:48:27 <brisingr> kmc: so also useful
09:48:42 <kmc> you can call that useful ;)
09:49:09 <kmc> it uses this type R to construct a big-endian bit trie of character values
09:49:13 <kmc> and then a 3-character trie of those
09:49:18 <kmc> as an associative data structure
09:49:19 <kmc> i think
09:49:23 <kmc> it's been a while
09:49:24 <acowley> Cheery: absolutely! Just make sure you have a good representation of the syntax of your programs, and that you are designing optimization as a pure AST -> AST function
09:49:33 <kmc> brisingr, i also wrote a 'real' text generator program
09:49:38 <kmc> http://hackage.haskell.org/package/detrospector
09:50:16 <brisingr> kmc: now THAT's cool
09:50:58 <brisingr> hopefully it's not very well known or every fantasy novelist on the planet's going to generate "elvish" "dwarvish" and "orcish" languages
09:51:06 <kmc> haha
09:51:17 <kmc> markov text generators are well-known, though mine isn't
09:52:09 <acowley> Has there been any recent movement on an automated worker-wrapper transformation in the optimizer?
09:52:32 <Accidus> I have a type class C with operation op, and I want to define an instance of the form: instance (C foo, ...) => C (...). In the definition of op for this instance I want to use the op from the type foo. How do I resolve the ambiguity between the op I define and the implicit one?
09:53:23 <kmc> it is ambiguous?
09:53:28 <kmc> you're getting an error message?
09:53:37 <Accidus> Yes.
09:53:38 <kmc> often this will Just Work Out
09:53:40 <kmc> okay
09:53:58 <acowley> then It Might Be a Problem
09:54:18 <kmc> do you have any value of type 'foo'?
09:54:21 <acowley> Accidus: throw some code on hpaste
09:54:35 <acowley> we need the type of op, too
09:54:43 <Accidus> Figured as much. Of course, I might just be doing silly things. Just a sec.
09:55:24 <hpaste> Accidus pasted “EquatableFunctors” at http://hpaste.org/50438
09:56:25 <Cheery> acowley: anyway if you're interested about it. I sometimes throw messages to #compilers. :)
09:56:28 <Accidus> Yeah, so the idea is that I want to deduce equality for (m a) if I have equality for a
09:56:50 <Cheery> I'm writing this in python, although it is putting that language to real firetest.
09:57:16 <acowley> Cheery: then be careful regarding my mention of persistent data structures
09:57:36 <Accidus> And I'm trying to get the exception transformer to always yield such functors
09:57:54 <Cheery> I try think about it.. but the trend of my coding is that it never gets really huge program unless I'm certain it can hold stress :)
09:58:40 <acowley> :t liftA2 (==)
09:58:41 <lambdabot> forall a (f :: * -> *). (Eq a, Applicative f) => f a -> f a -> f Bool
09:58:41 <Cheery> the persistency might be one way to implement backtracking. but there's more of them
09:59:08 <Accidus> So liftA2 is the abstraction I need?
09:59:14 <acowley> maybe?
09:59:22 <acowley> I'm still not 100% sure what you're aiming for
09:59:33 <Accidus> Good. I guessed there was something in the libraries
09:59:35 <acowley> but eqLift sure looks like it
09:59:51 <Accidus> I will go away and look at it, but I'm still interested in my original question...
09:59:58 <acowley> I think it's a warning sign when you have class (..) => C a where. ..
10:00:12 <acowley> the problem is everything is now an instance of C
10:00:23 <acowley> so you probably just wanted a regular function with a class constraint
10:00:33 <Accidus> Yeah, and you have to fuff around with class instances
10:00:36 <acowley> like the example of liftA2 (==)
10:00:59 <acowley> if you need to do something against the Applicative instances for specific types, then you should be using newtypes
10:01:19 <Accidus> I don't understand that last sentence.
10:01:58 <acowley> The Applicative instance for a type is going to define some control flow
10:02:17 <shamster> quick question about the where clause: why is the code at http://codepad.org/1ZgvasOI giving me an error on the last line?
10:02:38 <acowley> if it's not the flow you want, then rather than create a new class that is a specialization of Applicative but implemented differently, you probably want to newtype the original type and define a new Applicative instance
10:03:46 <Accidus> acowley, I guess I need to study the applicative class better to understand that. Cool, thanks!
10:03:55 <acowley> This is more Monoid than applicative, but the article is relevant and motivates the existence of several newtypes for Maybe: http://byorgey.wordpress.com/2011/04/18/monoids-for-maybe/
10:04:05 <parcs> shamster: the where bindings have to be vertically aligned
10:05:04 <acowley> Accidus: the good news is that Functor, Applicative and Monoid cover a *huge* amount of the territory you typically find yourself in so it's not really that much to learn!
10:05:06 <shamster> parcs: Should the where typically be on its own line?
10:05:16 <shamster> and then indent the following bindings?
10:07:22 <Accidus> acowley, aye, I know.
10:08:22 <acowley> shamster: no, leave the first binding on the same line as the where
10:08:32 <shamster> acowley: thank
10:08:35 <Accidus> Weird. The documentation for Control.Applicative says that an applicative functor is a strong lax monoidal functor. Why do you need to say 'lax' there? Should just be 'strong monoidal functor'.
10:08:35 <shamster> acowley: thanks
10:09:39 <ricree> Is there a function like head, except that it accepts a default argument or something to use in case of an empty list.  Rather than having an exception?
10:10:07 <acowley> Accidus: because they satisfy no additional properties
10:10:56 <kmc> ricree, maybe you should use pattern-matching instead
10:11:07 <kmc> but you can also use  fromMaybe x . listToMaybe
10:11:24 <acowley> @hoogle headDef
10:11:24 <lambdabot> No results found
10:11:30 <acowley> ricree: http://hackage.haskell.org/packages/archive/safe/0.3/doc/html/Safe.html
10:12:34 <Accidus> Hmm... So by lax you mean that the coherence morphisms don't need to satisfy the coherence conditions?
10:13:28 <Accidus> That doesn't seem right (and isn't right a la ncatlab)
10:13:41 <acowley> No, it's that they do satisfy the coherence conditions and nothing else
10:14:03 <ricree> acowley, yeah.  headDef does seem exactly what I wanted.  Though I'll probably just stick with pattern matching rather than add another dependency
10:14:28 <acowley> ricree: imo, you have chosen wisely
10:15:11 <acowley> libraries like safe make sense if you find yourself wanting several definitions or if you can fold it into a project-specific prelude
10:15:13 <Accidus> Then I don't see why you need to say that it's lax... The notion of a strong lax monoidal functor is the same as that of a strong monoidal functor....
10:15:37 <Accidus> (only less confusing)
10:17:04 <acowley> Accidus: Ask edwardk for an example of a non-lax strong monoidal functor when he's around. He's effectively the authority.
10:17:07 <applicative> ricree is this right
10:17:09 <applicative> > > foldr const 1 []
10:17:10 <lambdabot>   <no location info>: parse error on input `>'
10:17:14 <applicative> >foldr const 1 []
10:17:18 <applicative> > foldr const 1 []
10:17:18 <lambdabot>   1
10:17:19 <roconnor> lax means that rather than (F A * F B) and F (A * B) being naturally isomorphic, they there is only a one direction natural tranformation form (F A * F B) to F (A * B), IIRC.
10:17:23 <applicative> > foldr const 1 [0]
10:17:24 <lambdabot>   0
10:17:30 <applicative> pardon cut and paste spamming
10:17:50 <acowley> roconnor: then Accidus is right that strong negates that isn't he?
10:18:14 <Accidus> acowley, Strong doesn't negate that
10:18:17 <Accidus> it adds to it
10:18:28 <roconnor> acowley: strong says something about F A * B and F A * F B being related somehow doesn't it?
10:18:45 <acowley> negate reffered to "only a one direction natural transformation"
10:18:47 <applicative> > foldr const 1 [0,10]
10:18:47 <lambdabot>   0
10:18:56 <roconnor> or is strong and strength different concepts?
10:18:59 <Accidus> But the terminology 'lax' somehow hints that there is /no/ isomorphism (which isn't exactly true according to the definitions I found)
10:19:21 <acowley> wikipedia's definitions imply that you can be strong but not lax
10:19:30 <Accidus> acowley, what? how?
10:19:36 <acowley> or at least they imply that to me, but I don't know how
10:19:57 <Accidus> I don't think so. It's just that a strong functor is automatically lax, so you don't actually have to say 'strong lax'
10:20:06 <acowley> well, for instance, they define strict
10:20:16 <Accidus> Yeah, strict implies strong
10:20:21 <Accidus> So you don't say 'strict strong'
10:20:27 <Accidus> but just 'strict monoidal functor'
10:20:54 <acowley> if the maps are identities then it is not lax
10:21:00 <Accidus> Of course it is
10:21:10 <acowley> no, that's additional structure on the map
10:21:16 <Accidus> Yeah
10:21:26 <Accidus> In particular, you have the substructure, which you can just ignore
10:21:31 <acowley> right
10:21:43 <Accidus> So if it is strict, it is also strong, and also lax
10:22:04 <acowley> no, if it is strict it is strong, but lax can not pass the additional structure through
10:22:21 <Accidus> You're not making sense.
10:22:31 <Accidus> lax means "there is a map in one direction."
10:22:45 <Accidus> strong means "there are maps in both directions, and they are invertivle"
10:22:57 <Accidus> in particular, that means there is a map in one direction
10:23:01 <Accidus> So strong implies lax
10:23:27 <roconnor> in the same way that a field is a ring.
10:23:34 <Accidus> Aye
10:24:12 <roconnor> Accidus: do you understand why lax is in the Applicative documentation now?
10:24:37 <Accidus> No. Because the usual terminology is just 'strong monoidal functor'
10:24:49 <Accidus> I don't understand why you need to include 'lax' in there.
10:25:09 <roconnor> pure :: a -> F a provides one direction of the coherenc emaps
10:25:09 <acowley> Accidus: coherence maps might be identity maps, but they might not be
10:25:31 <roconnor> acowley: but we do not provide any inverse map of type F a -> a which would be required for a strong monoidal functor.
10:25:34 <roconnor> er
10:25:37 <roconnor> for Accidus
10:26:07 <Accidus> Then why is it strong?
10:26:23 <roconnor> Accidus: that is a different use of the term strength
10:26:30 <roconnor> than the one being discussed on wikipedia
10:27:05 <Accidus> Ah. So I guess the proper term would be enriched?
10:27:17 <Accidus> enriched lax monoidal functor?
10:27:20 <copumpkin> @let popeye = uncurry (fmap . (,))
10:27:20 <lambdabot>  Defined.
10:27:51 <Accidus> (enriched in the category in which haskell has semantics (whichever that may be! :P))
10:27:59 <roconnor> Accidus: a strong functor is a functor F with a natural transformation A * F B -> F (A * B)
10:28:28 <Accidus> Yes, that's what I meant. Fine. Now I understand. Thank you!
10:29:38 <roconnor> Accidus: a lax strong monoidal functor (or whatever order the adjactives come in) is refering to such a strong functor that is also lax monoidal and persumably the strength :: A * F B -> F (A * B) operation interacts nicely with the lax monoidal functor's coherence maps in some obvious way.
10:29:55 <Accidus> Yes, I understood that.
10:30:21 <acowley> Oh, well that's much tidier. Sorry for the misdirection, Accidus!
10:30:34 <Accidus> Cool. Thank you both!
10:30:50 <Accidus> I wonder whether I would have been less confused if the documentation said 'lax monoidal strong functor'.
10:30:54 <Accidus> Probably not.
10:31:48 * acowley excels at playing the role of the person that, through nonsensical ranting, forces the production of good definitions
10:31:55 <roconnor> I think the term "strong monoidal functor" is a poor term, but I don't know enough category theory to judge their use of terminology.
10:32:08 <acowley> Accidus: they could permute them every time you reload the documentation page
10:32:18 <Accidus> lol
10:32:30 <acowley> roconnor: wikipedia talks about strong monads with the other usage of strength
10:32:33 <Accidus> roconnor, heh, the terminology 'strong' is very poor, actually.
10:33:09 <acowley> yes, they should call them super functors, because "super" is pretty unambiguous
10:34:02 <Accidus> If you look at old papers (say, the classical one by Kock that proves that all monads over Set are strong) then their terminlogy is 'strong functors'  for what we call strong functors (or enriched functors) and 'monoidal monads' to what we call strong monads.
10:35:26 <Accidus> I have a colleague that jokingly conjectures that one of the prominent category theorists probably had a small pe**s, so he called everything 'strong'.
10:36:03 <acowley> so we should be relieved we don't work with large mcfunctor manhands
10:36:12 <copumpkin> Accidus: we also have a ##categorytheory if you're interested in it for its own sake
10:36:34 <Accidus> Oh right, completely forgot about that one
10:37:19 <Accidus> Yeah, sadly I don't have time to program in Haskell full time, so my visits here are pretty infrequent and I forget the etiquette in between :(.
10:37:51 <Accidus> Off topic: what's the difference between # and ## in channel names?
10:37:55 <kmc> i think most of us don't program in Haskell full-time
10:38:10 <Accidus> I don't know. Some people around here do.
10:38:12 <copumpkin> Accidus: oh, CT questions in here are fine too :)
10:38:21 <kmc> in fact I'd wager there's an inverse correlation between time spent in #haskell and time spent writing Haskell programs longer than one line :)
10:38:23 <acowley> I always find ##categorytheory to be a good place to go to ask questions and divine the answer in the echoing silence
10:38:26 <copumpkin> just saying if you wanted more pure CT, there's more of it in there
10:38:37 <roconnor> Accidus's question was specifically about Applicative functors; definitely on topic.
10:38:40 <copumpkin> acowley: hah, I've seen some pretty good actual conversation
10:38:46 <copumpkin> roconnor: yeah, as I said, it wasn't an invitation to leave
10:38:47 <acowley> Accidus: # are official channels, ## unofficial
10:38:53 <roconnor> yep
10:38:59 <copumpkin> if Mac Lane had founded ##categorytheory
10:39:03 <copumpkin> then it'd be #categorytheory
10:39:07 <acowley> exactly
10:39:11 <brisingr> kmc: that can mean only 1 thing: people lazing around in #haskell make monster one-liners
10:39:41 <Accidus> I'm not sure I follow, but I'm not going to chase these subtleties to no end.
10:40:10 <kmc> Accidus, a lot of channels are about some software project
10:40:27 * acowley erects a Working Mathemeticians Only! sign, then puts an X through it and hangs it on ##categorytheory
10:40:29 <kmc> a ## name indicates that the channel is not affiliated with the creators of that software
10:40:47 <kmc> it's less clear what it means for "#haskell" or "#math" or "##electronics"
10:41:00 <kmc> "not endorsed by James Maxwell"
10:41:21 <roconnor> I'm pretty sure that shapr orginized the Haskell comittee. ... IIRC
10:41:23 <acowley> I like to hang about it ##copumpkin and endorse things in his name
10:41:28 <copumpkin> :O
10:41:43 <Accidus> lol
10:41:50 <Accidus> OK. Back to coding then. Thanks all!
10:42:28 <kmc> i'm picturing assembling the Haskell committee in the style of the first act of a heist movie
10:43:26 <copumpkin> hah
10:48:46 <tomh-> hey, anyone here got hipmunk-5.2.0.2 to compile on macosx?
10:51:57 <Accidus> OK. Applicative structure is /not/ what's needed here.
10:52:21 <Accidus> The type I need for lift is (a->a->Bool)->(m a -> m a->Bool)
10:52:51 <kmc> that's something comonad-ish
10:52:57 <kmc> coapplicative?
10:53:04 <copumpkin> you want something that's applicative and copointed :P
10:53:05 <Accidus> It's not coapplicative either
10:53:11 <copumpkin> but that seems kind of lame
10:53:20 <kmc> what's coapplicative get you?
10:53:22 <copumpkin> what single Bool do you want it to return?
10:53:34 <glguy> tomh-: it built just now for me after I bumped the containers dependency to work on my ghc 7
10:53:45 <Accidus> Equality :)
10:53:54 <copumpkin> oh
10:53:55 <tomh-> containers dependency?
10:54:08 <copumpkin> you want a Foldable and Applicative m
10:54:17 <copumpkin> or something
10:54:20 <copumpkin> not even, actually
10:54:21 <glguy> tomh-: I edited the cabal file to depend on containers < 0.5
10:54:23 <benmachine> Foldable's enough, isn't it?
10:54:32 <benmachine> ish.
10:54:38 <copumpkin> you want a Zip :P
10:54:40 <tomh-> glguy: I get this error, does that have something to do with it?
10:54:42 <tomh-> error: expected specifier-qualifier-list before ‘__m128’
10:54:45 <benmachine> you could write a function with Foldable but it might not be the one you want
10:54:46 <glguy> tomh-: I don't know what this package does, or how to test if it works, however
10:55:01 <glguy> tomh-: nope, that's something else
10:55:02 <tomh-> it is a physics binding
10:55:04 <tomh-> ok
10:55:07 <Accidus> Foldable is too much.
10:55:10 <tomh-> do you know how to resolve it?
10:55:11 <glguy> tomh-: I was able to build it on 10.7.1
10:55:21 <tomh-> I have macosx 10.6 :(
10:55:29 <copumpkin> eq :: (Zip f, Foldable f) => (a->a->Bool)->(m a -> m a->Bool)
10:56:09 <copumpkin> eq f xs ys = all (zipWith f xs ys)
10:56:39 <copumpkin> if you don't have a Zip, you don't have a clean notion of "pairing corresponding parts" together
10:57:12 <Accidus> Well, equal things will have corresponding parts
10:57:13 <benmachine> you do have a dirty one though!
10:57:16 <Accidus> non equal things won't
10:57:59 <copumpkin> Accidus: how do you mean? unless all elements of a list, for example, are identical, using the monadish instance will check every pair
10:58:11 <copumpkin> and the equality should probably fail for at least one of those
10:59:21 <copumpkin> oh actually
10:59:26 <Accidus> In any case, I will have this structure, because I will always have a strong monad, so I'll have the double strength function
10:59:27 <copumpkin> I meant and (zipWith f xs ys)
10:59:41 <copumpkin> Accidus: how does that help you?
10:59:58 <Accidus> A strong monad gives you a zip type
11:00:00 <copumpkin> you definitely need a Foldable to reduce it to a single Bool
11:00:06 <copumpkin> Accidus: all monads in haskell are strong
11:00:15 <Accidus> Oh, I wasn't saying that I have foldable :)
11:00:20 <copumpkin> > liftM2 (,) [1,2,3] [4,5,6]
11:00:21 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
11:00:29 <Accidus> copumpkin, that is true
11:00:31 <copumpkin> you want every pair of elements to be compared?
11:00:56 <Accidus> No.
11:01:11 <copumpkin> :t liftA2 (,)
11:01:12 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
11:01:19 <copumpkin> :t uncurry (liftA2 (,))
11:01:20 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
11:01:22 <Accidus> Hmm...
11:01:26 <copumpkin> it's the same thing
11:03:52 <Accidus> Well, what would be the zip of these two elements: Left 1 and Right 'a'?
11:04:08 <Accidus> I don't think there's any satisfying answer
11:04:24 <Accidus> But they have a well-defined result under equality: False.
11:05:19 <copumpkin> Left 1 :)
11:05:59 <copumpkin> anyway, I'm just telling you where it makes sense
11:05:59 <Accidus> What's the zip of Left 1 and Left 2?
11:06:08 <copumpkin> Left 3
11:06:13 <Accidus> Yeah, well I don't think it does.
11:06:16 <Accidus> heh
11:06:30 <Accidus> No good.
11:06:32 <copumpkin> if you have a nice Monad instance with a Monoid constraint on the left
11:06:40 <copumpkin> you're assuming it's possible to do this in general
11:06:51 <copumpkin> I'm telling you where I can see it being possible
11:07:03 <copumpkin> you're saying that it isn't good because you can think of an example that has defined equality
11:07:07 <Accidus> Well, my starting point was just axiomatising what I actually need
11:07:17 <Accidus> No. What I /need/ is equality :)
11:07:32 <Accidus> So if equality doesn't fit into that structure, it's not the structure I need
11:08:30 <copumpkin> yes, but you have no idea it's even possible to do in general, and I have a feeling it isn't
11:08:52 <Accidus> It's not. But it will be possible to do it in my case, by construction
11:09:13 <Accidus> I remind you that my starting point was to axiomatise what an Equatable type was
11:09:13 <copumpkin> so what constraints do you intend to put on m ?
11:09:29 <Accidus> That you can lift equality through it:
11:09:49 <Accidus> And usually m is going to be the result of applying a monad transformer to a monad
11:10:11 <Accidus> So both the transformer and the monad will have to be 'Equatable' in a suitable sense
11:10:50 <Accidus> And then you need to start proving^D^D^D instantiating classes to show that composing two Equatable things gives you an equatable thing
11:11:04 <copumpkin> fair enough :P
11:11:05 <Accidus> And then I run into my original problem of operation resolution.
11:11:06 <tomh-> glguy: in case you are interested, I had to add a flag -sse2 to the cabal file for the c compiler to get rid of the error
11:11:28 <glguy> interesting. I wonder if that became a default in 10.7
11:11:29 <Accidus> Which might be really easy to fix if I knew Haskell better
11:11:35 <copumpkin> brb
11:12:14 <tomh-> glguy: not sure but maybe! I tried it based on this: http://hackage.haskell.org/trac/ghc/ticket/5106
11:13:57 <ezyang> What's the difference in cost for some object that gets allocated on the heap, as opposed to getting allocated on the stack?
11:14:24 <kmc> in GHC-compiled code?
11:14:25 <pumpkin> ezyang
11:14:35 <copumpkin_> gah
11:15:03 <ezyang> yeah
11:15:19 <kmc> when do objects get allocated on the stack?
11:15:23 <chrisdone> apart from hlint, what other haskell code analysis is there?
11:15:37 <ezyang> parameter passing!
11:15:39 <kmc> chrisdone, GHC and other compilers
11:15:42 <ezyang> Granted, these are infotables..
11:15:48 <chrisdone> kmc: you suck!
11:15:51 <kmc> :(
11:16:40 <kmc> ezyang, so you're comparing a heap object construction (C x y z) with the lead-up to a function call (f x y z) ?
11:16:52 <copumpkin> I hate juniper vpn
11:16:54 <chrisdone> nah, this is true — at some point I'd like to do what tibbe started and make a proggie that takes a haskell file and output the types of all the symbols in it
11:17:00 <copumpkin> chrisdonerkebab
11:17:02 <chrisdone> (which involves GHC api)
11:17:10 <ezyang> I think so.
11:17:20 <edwardk> kmc: Coapplicative effectively does not exist
11:17:25 <kmc> what's a juniper vpn?
11:17:27 <chrisdone> c’e pumpkino
11:17:52 <kmc> chrisdone, maybe you can use scion?
11:17:53 <Accidus> So... Class operator overload resolution. How do I do it?
11:17:58 <ezyang> One side of the coin is: how much does it cost to reify the stack into the heap?
11:18:07 <chrisdone> kmc: when i can get it to compile. some day
11:18:12 <ezyang> The other side of the coin is: how much would you pay if you allocated a heap object for every function application?
11:18:32 <kmc> well, the actual allocation in both cases is just bumping a pointer
11:18:40 <chrisdone> nominolo helped me out a lot with it at camhac, but i need to spend a weekend with it. possibly this weekend actually
11:18:41 <kmc> the difference is that heap allocation will eventually trigger GC
11:18:41 <edwardk> ezyang: the stack is pretty cheap. bump counter allocation, overflow by copying. the heap is also pretty cheap with bump counter allocation, but you pay for gc
11:18:50 <kmc> edwardk, :)
11:18:55 <edwardk> hah
11:18:58 <ezyang> Yeah, so I think the GC is the main difference here.
11:19:09 <edwardk> that and cache locality
11:19:18 <edwardk> since the stack is being accessed heavily
11:19:21 <copumpkin> well, bumping the stack pointer also eventually triggers a stack growth now, doesn't it? :P
11:19:29 <kmc> GHC's garbage collector is already tuned for loads of short-lived objects
11:19:40 <acowley> I would worry about cache more than anything else
11:19:41 <edwardk> so the cache locality is going to be the larger scale effect
11:19:57 <chrisdone> ivanm's source graph is pretty schveet
11:20:02 <acowley> #haskell is of one mind
11:20:10 * chrisdone for some reason feels like adding random stuff to hpaste
11:20:28 <ezyang> I've never quite understood the cache locality effects of stack and heap.
11:20:36 <ezyang> Is the stack more local because you reuse the space more quickly?
11:20:43 <edwardk> thats part of it
11:20:52 <edwardk> its also less diffuse.
11:20:53 <acowley> yes
11:21:00 <acowley> you have a window of the stack that's in cache
11:21:00 <ezyang> Right.
11:21:11 <acowley> and it's usually looking at the address range you care about
11:21:24 <ezyang> Some context is appropriate here: I'm essentially looking at a heap structure, and trying to figure out how I would keep it on the stack instead.
11:21:32 <ezyang> Maybe monadic regions is what I want? I'm not sure.
11:21:41 <edwardk> whereas with the heap, i'll allocate a thunk one minute, then its evaluated form the next,possibly right next to each other, but i'll never reference back to the former
11:21:50 <edwardk> what are you trying to do?
11:21:55 <ezyang> Zipper fusion.
11:21:57 <edwardk> regions and laziness interact very poorly
11:23:12 <edwardk> so dealing with paths, etc/ or zip as in zipWith?
11:23:14 <ezyang> Essentially, look at the class of operations that unzip, and then zip back up a data structure. We should be able to only have allocation on the stack.
11:23:20 <ezyang> former.
11:23:29 <acowley> I usually think of Zippers as reifying stack-like information on the heap
11:23:34 <ezyang> Latter is a solved problem, I think.
11:23:59 <ezyang> acowley: right! and you end up with more modular code as a result.
11:24:04 <ezyang> But sometimes you don't need the full generality.
11:24:12 <edwardk> one issue with the stack version is the 'fmapped lens' that doesn't fit your fusion mdel
11:24:55 <edwardk> given Functor f => Lens a b -> (b -> f b) -> a -> f a
11:25:27 <edwardk> there i rezip multiple times, despite unzipping once
11:25:45 <stobix> hm, is (a.b) the same as (.b) a ?
11:25:53 <acowley> ezyang: isn't laziness going to constantly get in your way if you now want to push the heap path back onto the stack?
11:25:54 <edwardk> yes
11:26:17 <edwardk> stobix: and (.) b a
11:26:20 <edwardk> er
11:26:22 <edwardk> (.) a b
11:26:41 <stobix> ah, good
11:26:52 <Dashkal> Is category-extras known to be broken at the moment?  I'm unable to install it.  ghci 7.0.3.  haskell platform 2011.2.0.1: http://hpaste.org/50442
11:27:01 * stobix tries to understand the types of things like (.(+))
11:27:06 <acowley> but be careful about fixity precedence with infix sections
11:27:10 <edwardk> category-extras has been factored into about 15 packages
11:27:15 <ezyang> edwardk: Yeah, I'm not worrying about that use case for the moment.
11:27:16 <edwardk> what are you looking for out of it?
11:27:20 <Dashkal> Looking for Comonad
11:27:24 <edwardk> its in 'comonad'
11:27:27 <Dashkal> danke
11:27:38 <ezyang> acowley: Laziness might be annoying, yes.
11:27:39 <edwardk> there are also 'comonad-transformers' 'comonads-fd' and 'comonad-extras' for more of them
11:27:52 <edwardk> (and 'free' and 'streams' provide more
11:28:08 <Dashkal> I just wanted a look at how extend and duplicate were defined
11:28:13 <ezyang> edwardk: Something simple. Given a function which I know how to write in recursive form, and a zipper-fied version of it, I should be able to derive the original.
11:28:22 <edwardk> fair nuff
11:28:24 <acowley> So I'm really struggling writing some numerical code. One problem is that I don't know how to algebraically think about the action of adding a row or a column to a matrix. Anyone have any advice?
11:28:45 <ezyang> It is, in some ways, another way of approaching the "generic recursion" problem.
11:28:48 <edwardk> i recently had to zipper-ify some lz78 code and that was fairly unpleasant, so godspeed ;)
11:29:20 <ezyang> Yeah, that is one concern: people don't actually like writing zippers :^)
11:29:32 <ezyang> Unless you're referring to "unpleasant" in a different sense.
11:29:42 <chrisdone> *in chorus* Kids React To… Comonads!
11:29:56 <edwardk> yeah i have a couple of zipper modules out there for zipping through traversables or zipping with lenses, etc.
11:30:12 <edwardk> actually not sure if i put the latter on hackage
11:30:16 <edwardk> hrmm, guess not. i should release that
11:31:33 <ezyang> I do get the impression that once you have the infrastructure, zippers are a lot more modular and require less code.
11:31:50 <edwardk> *nods*
11:32:02 <edwardk> i actually like working with the lens based zippers
11:32:19 <acowley> edwardk: do you have any thoughts on my matrix question? Translating imperative algorithm pseudo-code of complex numerical routines to Haskell is brutal as I have far too few abstractions keeping things on rails
11:32:35 <edwardk> basically i gave an efficient lensed state monad to the snap guys, then realized i could use it as a fast zipper as well
11:33:24 <edwardk> acowley: i started writing blas bindings that tried to mix the haskell typeclasses with some universal quantification hackery to compile down imperative code where possible, but it fell off my critical path
11:33:26 <c_wraith> yeah, a lensed state monad is a zipper, give or take.
11:33:37 <cheater> why is it
11:33:44 <ezyang> acowley: I've always thought that if I'm given imperative research pseudocode, unless I'm trying to make a point I try to transcribe it faithfully.
11:34:09 <edwardk> c_wraith: the zipper stuff is basically taking that and making a list of lenses, and the efficient lensed state monad kept the state 'pre-focused down to the hole'
11:34:14 <acowley> edwardk: I'm just looking for algebra. Individual updates are so error-prone.
11:34:19 <copumpkin> acowley: you need ruby
11:34:25 <acowley> ezyang: and you're right, but the problem is in integration
11:34:31 <ezyang> edwardk, c_wraith: I should take a look at that at some point.
11:35:26 <ezyang> oh. That's really, really cute :-)
11:35:27 <acowley> ezyang: transcription is rough due to the mismatch of psuedo-code and real syntax along with periodic errors in the literature
11:36:01 <ezyang> Bah. "It's too bad the numerics community isn't in the habit of proving their code correct."
11:36:02 <acowley> ezyang: if I optimize the language for transcription, I end up sacrificing exprsesiveness for things other than matrix poking
11:36:46 <acowley> copumpkin: Is ruby an expert at distilling algebraic elegance from numeric approximations?
11:37:03 <edwardk> acowley syntactic elegance, not so much algebraic
11:37:11 <copumpkin> acowley: you wanted rails :)
11:37:24 * copumpkin hides
11:37:39 <acowley> ezyang: they live in no-man's land already between high level math and worrying about cache latency, we can't be too hard on them
11:38:04 <acowley> maybe there's a yesod plugin that could help
11:38:32 <cheater> plugin for what?
11:38:42 <maltem> I think it's troll time
11:39:04 <ezyang> Take an ST style approach: cordon off all of the mutability into a little corner so it doesn't infect the rest of your abstractions.
11:39:08 <acowley> cheater: I'm trying to follow up on copumpkin's suggestion
11:39:18 <ezyang> You have the types to do it :^)
11:39:33 <acowley> ezyang: yeah, but you can never win
11:39:34 <copumpkin> :)
11:39:51 <Saizan> edwardk: do you have a link to the lensed state monad code handy?
11:40:12 <edwardk> hrmm, its in snap head somewhere
11:40:19 <edwardk> but the type was basically:
11:40:35 <ezyang> Coworker is complaining that he realized that monads were the right thing for his situation, and he felt ashamed of it.
11:40:41 <ezyang> ^_^
11:40:59 <acowley> ezyang: everything is represented as Vector Double, so I want newtypes everywhere. I'd like dimensions in types, but my dimensions are in the tens of thousands. And the imperative specification does nasty things like suddenly referring to two distinct states of an interative algorithm, which suggests that if you're mutating you'll want snapshots
11:41:07 <edwardk> newtype Lensed s v m a = Lensed { unlensed :: Lens s v -> s -> v -> m (a, s, v) }
11:41:24 <edwardk> where the 's' that is being carried around has a v shaped hole in it that has to be plugged before moving the lens
11:42:00 <acowley> what's the 'a' for? some kind of brand?
11:42:12 <edwardk> the a is the contents of the monad
11:42:47 <edwardk> its a state monad transformer with a Lens bolted on as environment, where the 's' is the actual state but where locally we're only working with the 'v' we've extracted from it
11:42:54 <ezyang> acowley: Oh. Did the researcher in question actually implement their algorithm?
11:43:00 <edwardk> accessing 's' requires plugging the v back in first.
11:43:33 <acowley> ezyang: Of course! Conveniently in unreadable Fortran! Our difficulty is that we have a special case of it and want the performance win
11:44:21 <Saizan> so 's' is 'the_real_state - v'?
11:44:38 <copumpkin> ezyang: to the poker room!
11:44:47 <edwardk> yeah, though, it isnt using an isomorphism lens so the s has an extra v that will be thrown away already inside it
11:44:48 <copumpkin> he must be punished for his monadicity
11:45:00 <acowley> poker = return?
11:45:51 <Saizan> ah, ok
11:46:20 <edwardk> i'd started from the isomorphism lens but that bolted an existential on, which made things too expensive
11:46:59 <edwardk> basically: exists c. (s <-> (v, c)) -> v -> c -> m (a, v, c)
11:47:28 <ezyang> acowley: Note there is a trivial way to transform mutable state into persistent state. You may not be too happy about it, but it does work...
11:47:35 <edwardk> here we use s to play the role of c
11:47:49 <romanm> *Main> map length.take 4 $ [["a","b","c","d","e"]]
11:47:49 <romanm> [5]
11:47:52 <romanm> ^- what?
11:48:15 <romanm> *Main> map (take 4) $ [["a","b","c","d","e"]]
11:48:15 <romanm> [["a","b","c","d"]]
11:48:24 <byorgey> > take 4 $ [1]
11:48:25 <lambdabot>   [1]
11:48:27 <byorgey> > take 4 $ [1,2]
11:48:28 <lambdabot>   [1,2]
11:48:32 <byorgey> > take 4 $ [[1]]
11:48:33 <lambdabot>   [[1]]
11:48:33 <Saizan> so the point is not so much to rework your state so that reaching the v is O(1) but caching the fact that you've extracted that v
11:48:48 <edwardk> yeah
11:48:51 <byorgey> romanm: [["a","b","c","d"]] is a list with one element.
11:49:01 <edwardk> then subsequent manipulations remain O(1)
11:49:01 <romanm> Yes.
11:49:08 <ezyang> Is there such a thing as a "path-directed fold"? A fold, but it doesn't actually operate on the whole structure?
11:49:14 <romanm> which es passed to the function called by map
11:49:17 <romanm> so
11:49:24 <byorgey> romanm: perhaps you meant   map (length . take 4) ?
11:49:31 <romanm> I sure hope so ;)
11:49:35 <byorgey> romanm: map length . take 4 is parsed as (map length) . (take 4)
11:49:44 <romanm> oh
11:49:49 <romanm> Ic.
11:50:01 <edwardk> you took 4 elements out a single element list, then mapped length over the list
11:50:02 <romanm> function application has highest precedence
11:50:05 <edwardk> yep
11:50:15 <edwardk> nothing binds tighter than ' '
11:50:19 <byorgey> right. (other than record update but don't worry about that)
11:50:23 <edwardk> (well, except in patterns)
11:50:28 <edwardk> and records
11:50:45 <dolio> And qualification.
11:50:51 <edwardk> hahaha
11:50:55 <edwardk> true nuff
11:52:51 <byorgey> "nothing binds tighter than function application, except for @-patterns, record update and qualification". just remember this one simple rule! =P
11:53:10 <edwardk> =)
11:55:29 <kmc> so i'm thinking it would be cool to have a 'diff' function for arbitrary algebraic data
11:55:47 <Saizan> it seems you'd need kata to make sense of Module.(f x)
11:55:51 <edwardk> does gershom have one of those?
11:55:58 <kmc> and it would be fun to implement this with the new generics stuff in GHC 7.2
11:56:06 <edwardk> saizan: hah
11:56:08 <kmc> but i was wondering what form it should take
11:56:12 <kmc> what does the result look like?
11:56:17 <romanm> new generics stuff?
11:56:29 <kmc> there's http://hackage.haskell.org/packages/archive/gdiff/1.0/doc/html/Data-Generic-Diff.html but it's pretty intense
11:56:35 <kmc> i think it will take me a while to understand this
11:56:40 <kmc> and it looks pretty heavyweight to use
11:56:40 <edwardk> oh, he just has classic diff http://hackage.haskell.org/package/Diff
11:56:58 <kmc> yeah, and i also uploaded http://hackage.haskell.org/package/patience
11:57:10 <kmc> romanm, http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html
11:58:56 <acowley> edwardk: he has code that does differentiation using stream approximations of mutually recursive functions
11:59:03 <acowley> edwardk: but I don't know the package name
12:00:53 <Accidus> Okay, fixed it :/. I had a conceptual mistake. Overloading works just fine.
12:03:03 <acowley> will I ever not find "snoc" an unpleasant word?
12:03:14 * hackagebot comonad-extras 2.0.2.1 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-2.0.2.1 (EdwardKmett)
12:05:09 <dolio> acowley: No.
12:07:20 <edwardk> acowley: if you do, seek immediate medical attention, because a stroke is imminent
12:07:43 <zoomzoom> hello
12:07:48 <edwardk> it is a well known warning sign, like having one of your pupils dilate
12:07:52 <Saizan> but it has a nice sound of two pieces snapping together
12:08:26 <zoomzoom> I have a bytestring and I want to convert the first 4 characters of the bytestring and convert it to a 32 bit int and then continue processing the rest of the bytestring
12:08:26 <acowley> I'll leave a note to that effect on the fridge for the wife. <acowley> You know what's a fun word? Snoc. <wife> Hello? 911?
12:09:03 <zoomzoom> is there an easy way to do this, or do I have to call get 4 times and then convert the characters to an int manually?
12:09:11 <acowley> I have never thought of paper making a snoc sound. A snoc is wet; mucus is usually involved.
12:09:23 <kmc> @let suoɔ xs x = xs ++ [x]
12:09:24 <lambdabot>  Defined.
12:09:26 <edwardk> zoomzoom: the latter is probably the safest, otherwise you can try and use Storable to read it off somehow
12:09:38 <dolio> zoomzoom: Have you looked at binary?
12:09:44 <zoomzoom> yeah
12:09:59 <zoomzoom> do you mean Data.Binary?
12:09:59 <acowley> zoomzoom: http://hackage.haskell.org/package/bytestring-nums
12:10:02 <dolio> Yes.
12:10:17 <copumpkin> zoomzoom: getInt32le/be
12:10:26 <edwardk> bytestring-nums uses a textual representation no?
12:10:42 <acowley> I don't know
12:11:08 <copumpkin> hmm, I guess they don't have Int32 ones
12:11:11 <copumpkin> but just grab the Word32
12:11:16 <acowley> yeah it does
12:11:25 <copumpkin> I don't see them
12:11:29 <copumpkin> http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary-Get.html
12:11:30 <copumpkin> ?
12:11:41 <acowley> copumpkin: sorry, I was responding to edwardk
12:11:42 <copumpkin> oh, google gave me an old version
12:12:08 <zoomzoom> dolio, that returns a Get Word32, no?
12:12:53 <zoomzoom> I'm reading from a file, so I'm working with the IO monad
12:12:54 <edwardk> decode bs :: Int32 ?
12:13:14 <dolio> I thought you had a bytestring. Binary works on bytestrings.
12:14:45 <eyu> > poke
12:14:45 <lambdabot>   Not in scope: `poke'
12:15:07 <zoomzoom> readFile "verylargefile" >>= (fun x ->  read the first int from x, process the rest of x )
12:15:09 <edwardk> zoomzoom: Data.Binary.decode yourByteString :: Int32
12:15:38 <zoomzoom> ahhh, I see
12:15:42 <zoomzoom> very cool
12:16:04 <edwardk> if you write the rest of the 'process the rest of x' as a Get action you an do it all in binary most likely
12:16:52 <edwardk> the trick will be if you have t deal with endianness, etc. then you're stuck on your own. not sure what the default endianness is for Binary, probably network order
12:19:08 <zoomzoom> how do I browse the haskell/bytestring documentation locally?
12:19:19 <acowley> decode uses the default Binary instances, though
12:19:29 <edwardk> sure
12:19:44 <acowley> oh, super, the Int32 instance is sensible
12:19:52 <acowley> it is big-endian
12:19:59 <edwardk> i usually cabal install, then cabal unpack bytestring; and go in and cabal haddock
12:20:04 <edwardk> i'm sure there is some more official way
12:20:24 <Saizan> cabal install --enable-documentation
12:20:34 <acowley> I rarely use default Binary instances as they're usually not what I would have written (though usually for good reasons)
12:20:44 <Saizan> or documentation: True in ~/.cabal/config
12:20:50 <edwardk> the only binary instance that makes me sad is the one for [a]
12:21:05 <edwardk> that one makes me hang my head
12:21:18 <acowley> edwardk: well Int tripped me up before because it's not 4 bytes
12:21:20 <edwardk> saizan: sweet
12:21:22 <Saizan> is it still length prefixed?
12:21:38 <edwardk> i think so
12:21:48 <acowley> yes
12:22:07 <acowley> but it will put an Int, which is 8 bytes I think
12:23:15 <edwardk> saizan: handy that
12:25:24 <zoomzoom> to process a really, really huge binary file, is it safe to simply use a lazy bytestring and then recursively process the file (calling bytestring.drop wherever appropriate)
12:26:04 <edwardk> zoomzoon: it is reasonable. you may just want to do so in the Get monad though
12:26:15 <edwardk> that will deal with those concerns for you
12:26:30 <edwardk> especially if you don't have to backtrack
12:28:29 <zoomzoom> ahh, the bytestring.get concern
12:29:42 <zoomzoom> even with the get monad, I'll still get call Bytestring.drop and such
12:30:01 <zoomzoom> since the integer I'm decoding sometimes decides the size of the next block
12:30:09 <edwardk> well, you'd just use the simpler get actions
12:30:17 <zoomzoom> isn't there a stack explosion problem when dealing with a file with recursive calls?
12:30:21 <Saizan> the Get monad would probably be more appropriate for large amounts of data if it were lazier, e.g. making the instance for [a] chunked and using the lazy state monad
12:30:36 <edwardk> the get monad is basically the state monad where the state is the remainder of the lazy bytestring
12:32:35 <edwardk> so you'd (do (x :: Int32) <- get; chunks <- forM [0..x] getChunk; ....
12:32:57 <edwardk> notie you don't explicitly drop, the act of binding in te get monad says 'get and advance'
12:33:03 <edwardk> er note
12:34:08 <edwardk> then once you have the action, you just runGet yourCrazyReader yourLazyByteString
12:35:11 <augur> moin
12:35:14 <augur> edwardk! :o
12:35:21 * edwardk hides
12:35:54 <augur> :x
12:36:10 <augur> do you happen to have a copy of categories for types?
12:36:18 <edwardk> nope
12:36:21 <augur> oh :(
12:37:47 <acowley> Galerkin accepts my Ritz vectors. I'm going for a walk, bbl.
12:41:35 <zoomzoom> where's this getChunks function described?
12:41:49 <edwardk> i just made it up to describe the fact that you need to do something per chunk
12:42:08 <edwardk> and you probably want forM [0..x-1], etc.
12:42:56 <zoomzoom> but x describes the size of the next chunk, not the number of chunks
12:43:16 <zoomzoom> ie, how much you have to drop to get to the next chunk
12:43:20 <zoomzoom> which will start with a size, etc...
12:44:14 <edwardk> then x <- get; when weWantToSkip $ skip x
12:44:40 <edwardk> andyou can parse the contents of the chunk using lookAhead
12:45:15 <zoomzoom> where's the doc for all this good stuff?!?!
12:45:22 <edwardk> http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Get.html
12:45:30 <edwardk> under Parsing
12:45:40 <edwardk> when is in Control.Monad
12:48:11 <zoomzoom> wicked!
12:48:29 <zoomzoom> this stuffis yummy
12:49:56 <zoomzoom> hrmph, it'll be a Get (IO ())
12:50:07 <zoomzoom> since I need to print stuff at the same time I'm processing the file
12:50:13 <edwardk> ah
12:50:27 <zoomzoom> is that ok?
12:50:40 <edwardk> well, the IO actions would be built up as your result
12:50:43 <copumpkin> that won't print things as you go along
12:50:50 <edwardk> so you'll only get them when you're done
12:50:58 <edwardk> there is no 'Get' monad transformer
12:51:05 <copumpkin> I'm not sure why not
12:51:25 <edwardk> probably efficiency concerns
12:51:56 <zoomzoom> so I have to call splitAt (or drop or take)
12:52:00 <zoomzoom> and recurse
12:52:09 <zoomzoom> is there any performance issues when doing that?
12:52:22 <edwardk> splitAt is pretty cheap on bytestrings
12:52:28 <edwardk> since it doesn't copy any data
12:53:01 <zoomzoom> I mean with recursing in Io
12:53:03 <zoomzoom> IO
12:53:09 <edwardk> hrmm does anyone know if there is a pretty printer that uses Put?
12:53:40 <edwardk> i'm debating about tweaking my free pretty printer and making one that uses Put, just so I can call it pretty-fast ;)
12:55:20 <copumpkin> edwardk: or blaze-builder!
12:55:35 <copumpkin> that one would also be pretty-fast
12:55:41 <edwardk> hrmm
12:55:48 <edwardk> never used blaze-builder
12:56:00 <zoomzoom> let process x = let size, rst = splitAt 4 x in let (nextChunk, rst') = splitAt size rst in processChunk nextChunk >>> process rst'
12:56:03 <zoomzoom> something like that
12:56:48 <copumpkin> ugh
13:01:04 <hpaste> mikeplus64 pasted “alarm” at http://hpaste.org/50444
13:02:11 <mikeplus64> can someone give me a uh critique of my code I wrote to make an alarm?
13:02:54 <mikeplus64> oh hey hpaste.org is already abusing me for my miserable code, lol
13:05:36 <Botje> mikeplus64: lines 45--48 could be written using liftM3, but they're fine like that too.
13:06:00 <Botje> mikeplus64: it's a bit weird that you're turning a time into a string and then reading back into an int..
13:06:15 <mikeplus64> yeah
13:07:12 <Botje> mikeplus64: you can grab the hours/minutes/seconds directly from the getZonedTime thing
13:07:21 <mikeplus64> oh
13:07:33 <mikeplus64> didn't know that :)
13:08:19 <Botje> the unparseHMS could have been folded into makeString
13:08:42 <drunK> why this -> $(stringE . show =<< reify ''[]) works and this -> $(stringE . show =<< reify ''[Int]) or this -> (stringE . show =<< reify (mkName "[Int]")) does not? the latter gives an error "`[Int]' is not in scope at a reify". is there no way to do something like that?
13:09:34 <hpaste> mak__ pasted “empty do construct” at http://hpaste.org/50445
13:09:38 <mak__> hi. i get an "empty do contruct" error compiling a code example. can you tell me why?
13:09:56 <Saizan> drunK: [Int] is a compound term of [] applied to Int
13:10:40 <Saizan> drunK: to get its TH representation you can use [t| [Int] |], but that won't give you a Name
13:12:03 <Botje> mikeplus64: and you could abstract addHours/addMinutes into an addWithOverflow+parameter
13:13:03 <benmachine> they look like divMod would be useful for them
13:13:04 <mikeplus64> what do you mean?
13:13:43 <Botje> mikeplus64: you take for example h + h' and then do divMod 24
13:13:53 <Botje> > (17 + 19) `divMod` 24
13:13:54 <lambdabot>   (1,12)
13:14:08 <mikeplus64> oh, cool
13:14:20 <drunK> Saizan: so I can't get a Name of [Int]?
13:14:36 <Saizan> drunK: no, it doesn't have one
13:14:40 <Botje> mak__: sounds like an indentation issue. check that you're not mixing tabs and spaces?
13:16:09 <drunK> Saizan: that's too bad. I suppose I can't use TH to generate code like eg. [..., typeOf (undefined::[Int]), ...] by passing [Int] as one of parameters then?
13:16:48 <Saizan> drunK: you can, just pass a Type rather than a Name
13:18:26 <mak__> Botje, yes i checked, space only
13:18:37 <Saizan> ListT `AppT` ConT ''Int <- that's a representation of [Int] in TH
13:18:44 <mathijs> Hi all, I have a need for a set/antiset combo type. I have a set in which elements can be present, absent, or missing. Missing is like a debt. so missing element `union` present element = 0/absent. Should I just use 2 sets? Or is there some special construct for this?
13:19:34 <Botje> mak__: does it say which of the two is broken?
13:20:15 <Saizan> mathijs: data Presence = Present | Absent | Missing; Map Element Presence ?
13:20:46 <mak__> Botje, oh yes sorry: Interact.hs:8:31: Empty 'do' construct
13:21:32 <Botje> mak__: oh. I think your "args <- getArgs" needs to be indented at least as far as the mainWith, then
13:21:38 <mathijs> Saizan: possible. But every element is absent by default. Also, I want all set-like behaviors like union and difference.
13:22:09 <Saizan> ah, right, you can just remove the Absent constructor
13:22:14 <mathijs> so Present | Missing would be enough
13:22:15 <mathijs> yep
13:22:46 <mathijs> and then just model the set functions for this datatype. Yeah, seems easiest :)
13:22:51 <mak__> Botje, thats it. thank you, i did not realize that
13:23:23 <Saizan> Map provides its own union and difference, and more general variants, i think you should be able to implement yours on top of that without much work
13:23:24 <zoomzoom> how do I convert an Int32 to an Int?
13:23:24 <Cheery> can I in some way use strahler number to get nicest order of instructions for minimal amount of registers?
13:23:37 <Saizan> zoomzoom: fromIntegral
13:24:17 <int80_h> @hoogle readFile
13:24:18 <lambdabot> Prelude readFile :: FilePath -> IO String
13:24:18 <lambdabot> Data.ByteString readFile :: FilePath -> IO ByteString
13:24:18 <lambdabot> System.IO readFile :: FilePath -> IO String
13:24:54 <Cheery> I need to think about it a bit to figure it out. I see :)
13:25:03 <Cheery> anyway I guess I can do that
13:25:13 <Cheery> it's also quite easy to compute
13:27:12 <drunK> Saizan: I see, thank you. that clutters the syntax though, ie. instead of $(f [''Int, ''Bool, ''[Int]) I need to write $(f [ [t|Int|], [t|Bool|], [t|[Int]|] ]). or I just can't see simpler solution
13:27:42 <int80_h> am I allowed to have a - in my function name?
13:27:47 <ski> no
13:27:48 <benmachine> you could always write f [t| (Int, Bool, [Int]) |] :P
13:28:06 <ski> unless it's an operator name, in which case it must consist completely of symbols
13:28:28 <ski> > let (+--+/*) "hellp" in (+--+/*)
13:28:29 <lambdabot>   <no location info>: parse error on input `in'
13:28:33 <ski> > let (+--+/*) = "hellp" in (+--+/*)
13:28:34 <int80_h> hmm, okay. Trying to make my name more readable. right now it's moveToPreProcess.
13:28:34 <lambdabot>   "hellp"
13:29:10 <ski> int80_h : i sometimes use both camelCaps and underscore_separation, for that
13:29:29 <ski> so maybe `move_to_PreProcess'
13:30:12 <int80_h> ski: heh I thought I would combine both. move_toPreProcess.
13:30:37 <int80_h> at first it was toPreProcess, but I realized saying toFoo implies a change of one type to another
13:30:38 * benmachine sees nothing wrong with moveToPreProcess
13:30:57 <drunK> benmachine: yep, but then extracting the types becomes problematic ;p
13:31:10 <ski> (or `move_to_preProcess', if `PreProcess' is not referring to a type (or subtype) or class)
13:31:21 <benmachine> the alternative is AppT ''[] ''Int I guess
13:31:44 <benmachine> wait no
13:31:44 <Saizan> aadd some ConT's there
13:31:48 <benmachine> yes :(
13:32:41 <Saizan> maybe ' and '' should be polymorphic
13:32:42 * ski misses mmorrow's bot :/
13:37:33 <ahihi2> how do I install profiling libraries for cabal packages?
13:37:36 <ahihi2> specifically GLUT
13:38:53 <earthy> cabal configure --enable-library-profiling
13:39:46 <parcs> ahihi2: or edit ~/.cabal/config and set 'profiling' to True
13:39:55 <Saizan> cabal install -p
13:40:01 <parcs> (then reinstall everything :P)
13:40:03 <maltem> and be prepared to re-compile everything
13:40:56 <ahihi2> ok, thanks :)
13:41:29 <ahihi2> it's a relatively fresh install, so fortunately there isn't a lot
13:43:15 <zoomzoom>     Could not find module `Data.Binary':
13:43:15 <zoomzoom>       It is a member of the hidden package `ghc-binary-0.5.0.2'.
13:43:30 <zoomzoom> how do I fix this?
13:43:45 <Saizan> cabal install binary
13:45:06 <zoomzoom> and how do I use cabal to locally browse the docs?
13:45:29 <parcs> you use cabal to locally create docs
13:46:02 <zoomzoom> ahh, so how do I create the docs for bytestring and binary?
13:46:46 <monochrom> docs for bytestring comes with ghc (because bytestring comes with ghc)
13:47:48 <zoomzoom> so for binary?
13:48:30 <monochrom> you build docs for binary (because you fetch binary)
13:48:58 <Saizan> you need --enable-documentation
13:49:07 <Saizan> or documentation: True in ~/.cabal/config
13:49:16 <monochrom> if your .cabal/config or your "cabal install" has the right settings, docs get built
13:50:44 <zoomzoom> and where do I find the docs?
13:51:02 <zoomzoom> (and the docs for bytestring too!)
13:51:17 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml
13:52:28 <monochrom> but actually the output of "cabal install" contains directory names too
13:53:20 <Saizan> also: ghc-pkg field binary haddock-html
13:55:42 <ash> so.. anyone know any good tutorials for parsec? I have found the one where you write a scheme, but it seems dated
13:57:42 <ash> am I wrong in thinking that I should be using Text.Parsec not Text.ParserCombinators? I read that in 3.0 Text.ParserCombinators is a compatibility api, is it deprecated?
13:58:56 <edwardk> ash: you should be using Text.Parsec unless you have a good reason not to
13:59:20 <ash> my only good reason so far is all the guides I have found use it…
13:59:42 <edwardk> just drop the ParserCombinators from the imports and things should be basically the same
14:02:22 <sshc> Is it safe to define a constant (an integer, say) that remains constant once its defined, but the actual value can differ during different runs?
14:02:31 <sshc> What should I do / document about this value?
14:02:50 <edwardk> you can do so, some purists might be unhappy with it, but its fine
14:03:02 <elliott> sshc: a baby will cry (the baby is me)
14:03:16 <elliott> but maybe not many other babies will cry
14:03:24 <ricree> In pattern matching, what's the syntax for matching against a type but also keeping the raw argument?
14:03:42 <elliott> ricree: p@(Abc ...)
14:03:48 <thoughtpolice> you kind of see this in the standard library. clearly we should put everything inside System.Info inside IO
14:03:48 <elliott> or b@True
14:03:51 <thoughtpolice> :P
14:03:53 <elliott> (parens not always needed)
14:03:58 <edwardk> ricree: ? you mean p@(Foo bar baz) ?
14:04:01 <elliott> thoughtpolice: sounds good
14:04:11 <ricree> thanks elliott and edawrdk
14:04:35 <edwardk> technically it is matching against a constructor and also retaining the raw argument ;)
14:04:50 <ricree> I knew there was one, but I couldn't remember what it was, nor what to call it if I wanted to google it.
14:04:59 <edwardk> those are @-patterns
14:05:06 <edwardk> a nigh ungoogleable name
14:05:45 <ion> edwardk: But all tutorials pointing it out helps.
14:06:13 <benmachine> as-patterns
14:06:23 <monochrom> in fact everything in System.Info is compile-time hardcoded, cannot change between runs. (in fact even stronger: compiler's own compile-time hardcoded, i.e., already set when you built ghc)
14:06:24 <edwardk> or what ;)
14:06:29 <benmachine> @google as-pattern
14:06:30 <lambdabot> http://www.haskell.org/tutorial/patterns.html
14:06:30 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
14:06:31 <edwardk> er or that
14:06:52 <monochrom> for a real example of differing between runs, GHC.Conc.numCapabilities
14:08:05 <elliott> I kind of consider Int to break referential transparency too, so maybe I'm not the best judge
14:08:22 <elliott> well, more purity I guess than basic referential transparency
14:10:43 <copumpkin> programs are forever
14:10:59 <monochrom> the dispute can be incorporated into how strong you want referential transparency to be, e.g., do you want it to cover different runs, different compiler versions, different hardware, different universes
14:11:03 <Botje> unless they're hpaste or \bot ;)
14:11:15 <copumpkin> different universes
14:12:28 <monochrom> "I have '1+1' running on 4004 and '1+1' running on iphone 7, are they the same?" is a referential transparency question
14:14:35 <monochrom> orthogonally, you can also fudge what you mean by "same"
14:14:39 <TubeSteak> full internet table in 280MB of RAM (with sane types)! not bad!
14:14:51 <TubeSteak> *routing table
14:15:16 <copumpkin> sane types!
14:15:21 <leod> you have the whole internet in one type?
14:15:26 <leod> table*
14:15:58 <TubeSteak> i keep it in a trie
14:17:12 <erus`> i wish there were more haskell videos
14:18:19 <TubeSteak> i wonder what is the appeal of videos for programming courses
14:18:26 <monochrom> you can double the amount of haskell videos by playing them at half speed
14:18:31 <lispy> erus`: yeah, someone should make weekly videos where they build some simple hello-world-sized program using libraries from hackage each week
14:18:47 <erus`> just talking about type theory and stuff :)
14:18:50 <lispy> ah
14:18:53 <erus`> its better than reading before bed
14:19:09 <monochrom> but worse than reading after bed
14:19:10 <TubeSteak> if it's text you can search it and use it later as a reference
14:19:17 <lispy> erus`: there is a vimeo channel for galois tech talks
14:19:33 <lispy> erus`: not always haskell, but usually interesting
14:20:04 <erus`> ah
14:20:12 <erus`> im having a look
14:26:01 <rostayob1> If I'm writing FFI, assuming that that the C code itself is thread safe, is there any precautions I have to take while writing the haskell part to keep it thread safe?
14:26:12 <rostayob1> because I can't figure out what is my problem with my code
14:26:39 <monochrom> I think there is no precautions
14:27:12 <rostayob1> ok, are there any precautions :P
14:27:30 <monochrom> I mean there are no precuations, too.
14:29:28 <rostayob1> also, is there a good way to test for thread safety? because I can't reproduce the problem
14:30:45 <monochrom> arrange two threads to call the same function. but what exactly to test or expect depends on the function
14:31:13 <megajosh2> Hey, does anybody use wxHaskell?
14:31:18 <megajosh2> I'm trying to make a very simple HTML parser
14:31:30 <megajosh2> I'm not sure how I'd go about formatting the text
14:31:54 <rostayob1> megajosh2: why do you need wxHaskell to write an HTML parser?
14:32:05 <int80_h> megajosh2: I use TagSoup for that
14:32:07 <megajosh2> Well, it's going to display the text
14:32:10 <megajosh2> TagSoup eh?
14:32:17 <int80_h> yup. makes life easy
14:32:24 <monochrom> I think you should s/parser/renderer/
14:32:37 <megajosh2> Yeah, that's what I meant
14:32:40 <int80_h> ah
14:32:40 <megajosh2> 'scuse me
14:33:18 * hackagebot anansi 0.3.3 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.3.3 (JohnMillikin)
14:35:52 <rostayob1> oh, I am an idiot. I forgot to add -threaded to the GHC flags. What happens if I mark foreign functions as safe and I don't use -threaded?
14:36:10 <monochrom> should be fine
14:36:22 <rostayob1> mh. ok
14:37:07 <rostayob1> And if I don't use -threaded they will never run concurrently?
14:38:15 <rostayob1> In other words, will thread-unsafe C code work in an haskell multi threaded program if I don't use -threaded?
14:39:57 <zmaril> So randomR keeps giving me 6's.
14:40:08 <acowley> could you have guessed that?
14:40:26 <zmaril> How do you mean?
14:40:36 <acowley> 6 is a good random number
14:40:41 <zmaril> I tried evaluating [randomR (1,6) (mkStdGen x) | x <- [1..100]]
14:40:54 <zmaril> And I just keep getting 6's
14:41:05 <Phyx-> maybe 6 is just your number
14:41:27 <c_wraith> > [fst . randomR (1, 6) . mkStdGen $ x | x <- [1..10] ]
14:41:29 <lambdabot>   [6,6,6,6,6,6,6,6,6,6]
14:41:30 <acowley> rostayob1: I think so. But you should run a test to be sure: run without -threaded, fork a greenthread that prints, and make a long FFI call. See if the printing continues.
14:41:42 <zmaril> I like your style, but something seems odd when it happens a whole bunch.
14:41:53 <c_wraith> > [fst . randomR (1, 6) . mkStdGen $ x | x <- [10000..10010] ]
14:41:54 <lambdabot>   [6,6,6,6,6,6,6,6,6,6,6]
14:42:01 <c_wraith> :t mkStdGen
14:42:03 <lambdabot> Int -> StdGen
14:42:12 <c_wraith> all told, that's a bit odd.
14:42:23 <c_wraith> but mkStdGen has always been suspect.
14:42:40 <acowley> mkStdGen is a fancy version of const 6?
14:42:40 <zmaril> Yeah I am just trying to figure out if I am doing something weird.
14:43:06 <zmaril> Like it would make sense if I forget to change the seed or something
14:43:14 <zmaril> But this is odd.
14:44:11 <c_wraith> > map fst . iterate (randomR (1,6) . snd) . randomR (1,6) . mkStdGen $ 5
14:44:13 <lambdabot>   [6,2,2,1,3,2,5,1,5,4,2,2,1,2,6,4,2,4,2,3,2,4,5,4,2,1,5,1,6,4,3,2,4,5,5,3,3,...
14:44:33 <c_wraith> yeah, I think the problem is just that mkStdGen doesn't actually generate a very good spread of possible starting values
14:44:42 <rostayob1> acowley: with green thread you mean haskell RTS thread?
14:44:57 <acowley> rostayob1: yes
14:45:03 <c_wraith> > map fst . iterate (randomR (1,6) . snd) . randomR (1,6) . mkStdGen $ 11
14:45:05 <lambdabot>   [6,4,4,6,1,2,6,5,6,5,3,2,2,2,4,4,1,3,6,3,1,3,5,6,1,6,6,3,6,6,3,2,5,1,6,3,1,...
14:45:21 <zmaril>  [fst . randomR (1, 8) . mkStdGen $ x | x <- [100..110] ]
14:45:34 <c_wraith> the generator in mkStdGen is slow and low-quality anyway.
14:45:50 <zmaril> > [fst . randomR (1, 8) . mkStdGen $ x | x <- [100..110] ]
14:45:51 <rostayob1> acowley: afaik what happens is that two threads won't execute *that* function concurrently. but one thread might keep printing, right?
14:45:52 <lambdabot>   [4,2,8,6,4,2,8,6,4,2,8]
14:45:53 <c_wraith> err, I guess that would be StdGen is slow and low-quality anyway
14:46:05 <ion> > let f = liftA3 (,,) (r (1,6)) (r (1,6)) (r (1,6)); r = state . randomR in [ evalState f (mkStdGen x) | x <- [0..10] ]
14:46:07 <lambdabot>   [(6,6,4),(6,5,2),(6,4,1),(6,4,5),(6,3,3),(6,2,2),(6,1,6),(6,1,4),(6,6,3),(6...
14:46:08 <ion> [(6,6,4),(6,5,2),(6,4,1),(6,4,5),(6,3,3),(6,2,2),(6,1,6),(6,1,4),(6,6,3),(6,5,1),(6,4,6)]
14:46:11 <c_wraith> as well as mkStdGen not being very good for initializing them.
14:46:17 <zmaril> Methinks there is a problem with 6's.
14:46:20 <rostayob1> acowley: ah, no.
14:46:41 <acowley> rostayob1: what I was hoping is that the FFI call would lock everything else out for its duration
14:46:43 <zmaril> If you look at that last thing it goes up by 6
14:46:44 <c_wraith> zmaril: note what your results are.
14:46:54 <c_wraith> mkStdGen is just *bad*
14:47:01 <rostayob1> acowley: yeah that's what the ghc manual says more or less
14:47:08 <zmaril> That clears that up.
14:47:31 <acowley> rostayob1: as long as any FFI call returns before any other RTS thread has a chance to make progress, then I think you're safe
14:47:35 <c_wraith> You should really be using...  something else.
14:47:49 <acowley> I'm going to start indexing my arrays beginning with 6
14:47:57 <c_wraith> find some other instance of RandomGen to use :)
14:48:01 <rostayob1> acowley: what do you mean before any other RTS thread has a chance to make progress?
14:48:01 <ion> > let f = liftA3 (,,) (r (0,9)) (r (0,9)) (r (0,9)); r = state . randomR in [ evalState f (mkStdGen x) | x <- [0..10] ]
14:48:03 <lambdabot>   [(5,5,5),(7,8,7),(1,1,2),(5,5,4),(9,0,6),(3,3,1),(7,6,3),(1,0,5),(5,5,0),(9...
14:48:04 <ion> [(5,5,5),(7,8,7),(1,1,2),(5,5,4),(9,0,6),(3,3,1),(7,6,3),(1,0,5),(5,5,0),(9,8,2),(3,1,7)]
14:48:35 <rostayob1> acowley: ah right. yeah but doesn't -threaded imply that?
14:48:39 <ion> Should remember to use another prompt when i don’t want lambdabot to evaluate it.
14:48:49 <acowley> rostayob1: I mean if another RTS thread were running on another OS thread while your FFI call is executing (as with the threaded RTS), it could make an FFI call that would expose your thread safety issue
14:48:58 <acowley> rostayob1: yes
14:49:01 <rostayob1> acowley: sorry, doesn't not using -threaded imply that
14:49:25 <rostayob1> mhmmh
14:50:50 <acowley> rostayob1: is it not working right?
14:50:59 <rostayob1> acowley: https://github.com/rostayob/sundown/issues/1
14:51:04 <rostayob1> it's an old issue but I have some time now :P
14:51:20 <EvanR-work> can function IO be considered pure-but-nondeterministic computation?
14:51:24 <EvanR-work> functional IO
14:51:41 <rostayob1> basically i did bindings to a markdown C library ( http://hackage.haskell.org/package/sundown ) and this guy is - was - having problem while using it in a snap application
14:51:51 <ski> EvanR-work : "functional IO" being ?
14:53:00 <EvanR-work> IO in a functional language
14:53:26 <acowley> what is Splice?
14:53:37 <ski> Scheme ? SML ? Clean ? Mercury ? Haskell ?
14:53:44 <rostayob1> acowley: it has to do with heist templates
14:54:27 <ski> EvanR-work : in the former to cases it's impure, in the latter three, it's pure
14:54:32 <acowley> I'm just wondering if you're using unsafePerformIO somewhere
14:54:49 <int80_h> don't answer that without a lawyer!
14:54:58 <EvanR-work> ski: right
14:55:04 <acowley> yes you are
14:55:04 <EvanR-work> mercury?
14:55:10 <rostayob1> acowley: well I'm using unsafePerformIO to call the C function
14:55:32 <ski> EvanR-work : <http://www.mercury.csse.unimelb.edu.au/index.html>
14:55:33 <acowley> So, step 1 is to mark uses of unsafePerformIO {-# NOINLINE #-}
14:55:34 <EvanR-work> ski: im just talking about maybe having an alternative model, like non deteriministic model to cover IO as well as non IO
14:55:58 <EvanR-work> not the algebra of IO operations, but the effects
14:56:00 <acowley> rostayob1: what can happen is an unfortunate interaction with laziness
14:56:03 <rostayob1> acowley: isn't that unnecessary with GHC? anyway, will do
14:56:11 <ski> EvanR-work : in Haskell, it's deterministic, also in Clean. i'm pondering the Mercury case
14:56:43 <EvanR-work> in haskell its deterministic but then when the IO is executed you dont know what could happen
14:56:46 <ski> EvanR-work : oh -- well, there's a large difference between the effects and the actions that represent them
14:56:52 <acowley> rostayob1: I'm probably perpetuating an old wive's tale, but it's what I do
14:56:57 <EvanR-work> it could be pollQuantumGenerator :: IO A
14:57:37 <rostayob1> acowley: no apparently you need to annotate it. I don't know why I tought the opposite
14:57:48 <acowley> rostayob1: as someone who has burned themselves on the unsafePerformIO hotplate several times, I have picked up particular rituals and discipline that I look to for protection
14:57:58 <sm> blaze-from-html is pretty cool! converts valid html to equivalent haskell combinator code
14:58:15 <rostayob1> acowley: ok, go on, I'm all ears :P
14:58:25 <ski> EvanR-work : so, Haskell doesn't have non-determinacy. but Haskell has ways to *represent* non-determinacy
14:58:43 <acowley> rostayob1: step 1, NOINLINE. step 2, you're fine now :P
14:58:51 <rostayob1> acowley: oh. ok.
14:58:58 <EvanR-work> ski: yes
14:59:05 <acowley> rostayob1: but I once constructed a situation where I had a stream of lazilly evaluated unsafe IOs, and it was a disaster
14:59:27 <acowley> so I also get a little bang-happy around those parts of the code
14:59:30 <rostayob1> acowley: how so?
14:59:45 <ski> EvanR-work : i wouldn't say "function IO be considered pure-but-nondeterministic computation", since the "pure" would refer to how computation in Haskell works, while "non-deterministic" would refer to what they might *represent*
14:59:54 <ski> EvanR-work : so, imo, saying that would be confusing
15:00:28 <acowley> rostayob1: I wish I could be more specific. It ended up as a heisenbug that I fought with a for a while, then just switched to a different approach that respected IO a bit more and everything became copasetic
15:00:37 <ski> EvanR-work : if "non-deterministic" is interpreted in the same sense as "pure", then Haskell doesn't have non-deterministic I/O
15:00:38 <EvanR-work> ski: yep, im confused
15:01:34 * ski is not sure of the best terminology to use to describe the situation
15:01:38 <rostayob1> acowley: uhm ok. thanks for the hints
15:01:38 <acowley> the actual IO has to be non-deterministic. if getchar() always returned the same thing, it would not be useful
15:01:52 <rostayob1> acowley: last question: is there any tool or method to stress test thread safety?
15:02:16 <rostayob1> as it fork this function 1000 times and you should always get this?
15:02:21 <rostayob1> actually that's not too hard to do.
15:02:22 <ricree> it's non-deterministic you want?  Just wrap all your IO in unsafePerformIO  :)
15:02:49 <acowley> rostayob1: I don't know of anything extant
15:03:32 <rostayob1> acowley: ok
15:04:06 <sshc> If I use "unsafePerformIO" to define top-level mutable state, do I need to do anything else besides {-# NOINLINE #-} to make it safe?  Do I need -fno-cse?
15:04:20 <acowley> getChar is a single (deterministic, pure) value, the RTS interprets it as a non-deterministic action
15:04:33 <ski> acowley : yes. i'm trying to contrast `getChar' "representing nondeterminacy" in that sense, with `unsafePerformIO getChar' actually *being* nondeterministic
15:05:04 <acowley> ski: I would say that has to do with losing the monadic ordering of effects
15:05:43 <ski> (acowley : or take `TextIO.inputLine TextIO.stdIn' in SML, or any similar computation in a side-effectful language)
15:05:55 <acowley> use of getChar within IO means the RTS's interpretation of it respects ordering specifeid by bind, while stripping it out of IO means the RTS can evaluate/interpret it whenever it chooses
15:06:28 <ski> acowley : from a semantics perspective, it's about losing full beta-conversion
15:08:56 <ski> in Haskell, `let x = System.IO.hGetLine System.IO.stdIn in x >> x' is equivalent to `getLine >> getLine'
15:08:59 <ski> while in SML, `let val x = TextIO.inputLine TextIO.stdIn in x ; x end' is not the same as `TextIO.inputLine TextIO.stdIn ; TextIO.inputLine TextIO.stdIn'
15:09:27 <sshc> Is STM supported by hugs?
15:10:12 <c_wraith> hugs doesn't have any concurrency support, last I heard.
15:10:33 <ksf> basically all X isn't supported by hugs.
15:10:56 <ski> Hugs has `Control.Concurrent', at least
15:11:01 <sshc> Ah.  I won't need to worry about that platform, then.
15:11:17 <monochrom> hugs has forkIO and MVar etc but not STM
15:11:38 <ksf> hugs is quite dead, yes, and doesn't seem like ever having life breathed into it, again.
15:12:04 <ksf> someone might give it some love and keep it up to date with the standards, but those won't include stuff like STM.
15:12:41 <ksf> uhc will be interesting, though.
15:14:46 <elliott> With acid-state, if I have a record with no specially-handled fields in, that I just want to perform the basic record options on (more specifically, something like "a lens for each field"), I'm not sure which events I want to create. An Update and a Query event for each field?
15:15:57 <rostayob1> elliott: ? if you are modifying whatever is stored, you want an update
15:16:05 <rostayob1> if you are just reading, you want a Query
15:16:22 <elliott> rostayob1: I'm asking which events I'd want to declare for a simple record structure like this.
15:16:32 <elliott> An Update/Query pair for each record field?
15:16:46 <ash> what is the recommended way to get rid of "Could not Deduce" issues?
15:17:19 <parcs> there is no recommended way
15:17:54 <rostayob1> elliott: I'm afraid I don't understand your question. You are storing something an an AcidState, and you are asking which events to define to do stuff on that something? That depends on what you want to do really :P
15:18:09 <monochrom> use "undefined" to fix type errors
15:18:18 * hackagebot bcrypt 0.0.3 - Haskell bindings to the bcrypt password hash  http://hackage.haskell.org/package/bcrypt-0.0.3 (AndrewMiller)
15:18:35 <elliott> rostayob1: Sure... which is why I'm asking for advice based on a specific type of structure -- a simple record that I just want to access and modify each field of in a "standard" manner.
15:18:46 <parcs> the easiest way would be to delete  the offending code and to try again
15:18:49 <rostayob1> elliott: define "standard"
15:19:12 <elliott> rostayob1: Would you like a dictionary?
15:19:13 <rostayob1> anyway, you could define a getThisRecord and setThatRecord for each record sure
15:19:22 <elliott> Do you mean each record field?
15:19:33 <rostayob1> well yeah but it really depends on what you need to do...
15:19:52 <rostayob1> I mean you're asking what should you do with your state - I don't know :P
15:20:08 <rostayob1> but maybe I'm misunderstanding. also, I don't know what you mean with "standard" in this context
15:20:27 <monochrom> "standard" probably means "what other people do"
15:20:32 <elliott> Well, surely if events are properly composable, I should not need to enumerate every single possible transformation I would want to perform on my state.
15:20:37 <elliott> Especially since you have to declare them all up-front.
15:21:18 <rostayob1> elliott: declare everything up front? I don't get what the problem is. I see acid-state as a persistent state monad for what concerns me. Then I just do what I need to do with that persistent state
15:21:18 <sshc> If I use "unsafePerformIO" to define top-level mutable state, do I need to do anything else besides {-# NOINLINE #-} to make it safe?  Do I need -fno-cse?
15:21:37 <elliott> rostayob1: makeAcidic takes a list of all possible events.
15:21:45 <rostayob1> sshc: if you're using unsafePerformIO you're probably doing something wrong in the first place :P
15:22:24 <rostayob1> elliott: yes... and?
15:22:36 <elliott> rostayob1: So you have to declare all possible events on the state up-front.
15:22:46 <rostayob1> well yeah you'll need to define those events upfront, but it's your software anyway
15:23:07 <elliott> I don't follow.
15:23:08 <rostayob1> In the end you're going to be doing a small set of operation on your state
15:23:24 <rostayob1> I mean what is the problem here? I just write the events as I need them
15:23:35 <dstcruz> seems that Cabal is asking me the impossible? base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.5
15:24:05 <elliott> rostayob1: Well, it'd be nice if there was some sort of documentation for when you should add a new event as opposed to composing existing events.
15:24:43 <rostayob1> elliott: that is up to you really... are you worried about the impact in terms of performance?
15:25:09 <rostayob1> dschoepe: what package?
15:25:14 <rostayob1> sorry, dstcruz
15:25:53 <elliott> rostayob1: No; I just want to use the library correctly -- especially in terms of not violating the guarantees. I suspect that "do x <- query foo GetBlah; update foo (SetBlah (f x))" doesn't have the transactional guarantees, for instance.
15:26:28 <dstcruz> has anyone tried to install Cabal 1.10.2.0 with ghc 7.2.1?
15:26:56 <rostayob1> elliott: well of course. You are guaranteed ACID inside an update event. If you execute an event and then the other one, they're not related
15:27:27 <elliott> rostayob1: Right. But I take it I can't create an UpdateBlah :: (Int -> Int) -> Update MyState Int event, because functions aren't serialisable?
15:27:58 <elliott> It just feels like there has to be a more convenient way to do this, me being used to creating transformations on state easily in a compositional manner with lenses and the like.
15:28:14 <rostayob1> elliott: that's possible yeah. I used acid-state some times ago, but what you are saying makes sense.
15:28:40 <rostayob1> elliott: it's a matter of design here. you have to select a number of update events that you are going to use
15:28:47 <elliott> Right.
15:29:09 <elliott> I guess I can add new events without having to define any sort of migration, though?
15:29:26 <rostayob1> elliott: remember that all the changes are written to disks (not the data, the actual change). so yeah it makes sense not to be able to pass functions to events
15:29:34 <elliott> rostayob1: Yeah, that was my hunch.
15:29:47 <monochrom> sshc: I think no one has found that they need -fno-cse
15:29:55 <rostayob1> elliott: correct, you don't need to define any migration
15:29:56 <elliott> It feels... restrictively first-order, but I guess you have to sacrifice something to get all the guarantees you get from acid-state.
15:30:30 <rostayob1> elliott: well it's part having ACID and part having a persistent state anyway
15:30:31 <drunK> dstcruz: you need cabal-1.12, it's working with 7.2.1. I couldn't get 1.10.2.0 to work with it either
15:30:36 <sshc> monochrom: So it's not needed to be safe?  Can GHC ever "common" multiple references up?
15:31:03 <elliott> rostayob1: I consider persistency just another vital guarantee :P
15:31:12 <rostayob1> elliott: (btw, if you change your data types you can use this to easily migrate old data: http://hackage.haskell.org/package/safecopy )
15:31:17 <dstcruz> drunK: thanks! I'll give that a shot.
15:31:19 <rostayob1> elliott: fair enough (:
15:31:39 <monochrom> it seems not needed. ghc does some cse but apparently not to top-level unsafePerformIO's with NOINLINE
15:31:42 <elliott> rostayob1: Yeah, I am using safecopy.
15:32:06 <dstcruz> It also seems strange that Cabal wanted unix <2.5 when ghc 7.2.1 comes with unix 2.5
15:32:26 <monochrom> well, cse by its definition simply isn't applicable to top-level things
15:32:27 <rostayob1> elliott: they go well together. acid-state is one of the coolest hs libs imho.
15:33:24 <elliott> rostayob1: All we need now is the ability to serialise functions :-)
15:33:32 <sshc> monochrom: Ah, okay.  Thanks!
15:34:09 <rostayob1> elliott: that's going to be hard eheh
15:34:29 <elliott> rostayob1: One day...
15:34:44 <rostayob1> I guess you could just put the Expr there and interpret it lol
15:34:53 <int80_h> @src Int
15:34:53 <lambdabot> data Int = I# Int#
15:34:55 <rostayob1> but that would be impractical
15:35:14 <int80_h> could someone explain the implementation of Int to me?
15:35:16 <rostayob1> elliott: we'll see. the current state of things is probably a better compromise...
15:35:20 <elliott> rostayob1: Well, if you had a sufficiently stupid interpreter you could serialise the Haskell AST...
15:35:32 <elliott> (i.e. one that just tree-walks)
15:35:40 <rostayob1> int80_h: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/primitives.html have fun
15:35:49 <elliott> I doubt GHC will be serialising functions in a portable manner any time soon, though.
15:36:13 <rostayob1> elliott: you can already get the haskell AST with TH
15:36:37 <copumpkin> that's very different
15:36:45 <rostayob1> actually yeah it is.
15:36:45 <int80_h> rostayob1: eep! what have I gotten myself into?!
15:37:08 <elliott> copumpkin: rostayob1: Well, it could work -- maybe with hint
15:37:21 <elliott> int80_h: if you see #s, run away
15:37:50 <DukeDave> Hey gang, I just wanted to check my assumptions on this:
15:37:52 <DukeDave> http://hackage.haskell.org/packages/archive/wx/latest/doc/html/Graphics-UI-WX-Types.html#g:4
15:37:54 <DukeDave> If I do a `varGet myVar' >>= do stuff and return new value >>=  `varSet  myVar',
15:37:56 <DukeDave> is there any way `myVar' can be read while I'm doing stuff?
15:38:02 <rostayob1> hey, why is there a 1 after my nickname?
15:38:13 <elliott> rostayob1: rostayob0 complained
15:38:15 <rostayob1> must have left a PC on somewhere lol
15:38:27 <elliott> DukeDave: Yes.
15:39:07 <elliott> DukeDave: A shame that there's no "Var a -> (a -> IO a) -> IO a" provided there. You could use varUpdate with unsafePerformIO if you want to be terrifying...
15:39:19 <elliott> Or exploit the representation and use TVar functions directly
15:39:55 <DukeDave> elliott: My problem is that `myVar' contains three data structures, which all need to be updated in lock-step
15:40:17 <rostayob1> int80_h: :)
15:40:29 <DukeDave> I do all the updating in the "do stuff" phase, but I need to make sure no part of `myVar' is in an consistent state..
15:40:43 <DukeDave> Do we think I'm safe in that regard?
15:41:14 <DukeDave> I always "assumed" that it would be okay, until I remembered hearing about "atomically" before
15:41:19 <elliott> I suggest living in constant, crippling fear of your concurrency system. It's what I do.
15:41:55 <dstcruz> drunK: I guess there is no tarball for 1.12?
15:41:57 <rostayob1> DukeDave: shouldn't you use TMVar for stuff like this? If I understood your problem correctly, I'm kind of tired now :P
15:42:35 <drunK> dstcruz: nope, you need to get it from the repo
15:42:37 <DukeDave> But, but, aren't we supposed to be awesome at parallelism?..  http://www.economist.com/node/18750706
15:43:07 <rostayob1> oh well if the economist says it. anyway, we are.
15:43:15 <elliott> DukeDave: Well, TVars are just STM.
15:43:22 <elliott> So you could be worse off, I gather.
15:43:28 <DukeDave> rostayob1: I'm not sure!
15:43:30 <DukeDave> It's a wxHaskell application, so I've been using WX.Vars
15:43:45 <elliott> DukeDave: Yeah but look at http://hackage.haskell.org/packages/archive/wx/latest/doc/html/Graphics-UI-WX-Types.html#g:4
15:43:54 <elliott> It's all lies, they're aliases for TVar stuff
15:44:11 <elliott> It could change, but it might not :-)
15:44:18 <DukeDave> elliott: I spotted that too, which led me to think, why does "atomically" exist then?
15:44:43 <DukeDave> I don't mind if something reads `myVar' and gets an 'old' version
15:44:44 <rostayob1> DukeDave: you can pretty much know all you can do with TVars here: http://hackage.haskell.org/packages/archive/stm/2.2.0.1/doc/html/Control-Concurrent-STM-TVar.html !
15:44:58 <elliott> DukeDave: atomically :: STM a -> IO a
15:45:05 <elliott> It's basically a transaction.
15:45:13 <DukeDave> So long as no one reads `myVar' why I'm half way though a let block
15:45:15 <kmc> read the last chapter of RWH
15:45:18 <elliott> rostayob1: He'll also want to look at http://hackage.haskell.org/packages/archive/stm/2.2.0.1/doc/html/Control-Monad-STM.html
15:45:24 <elliott> DukeDave: do block, surely?
15:45:38 <elliott> But really, people can read the variable at any time, if you want the guarantees, use STM properly
15:46:21 <DukeDave> elliott: Hmm, I *think* I'll be okay, but I'm going to do a quick example on hPaste :)
15:47:32 <rostayob1> in the end concurrency is always scary, haskell makes it a little bit less scary
15:47:40 <rostayob1> maybe more than a little bit less
15:48:38 <rostayob1> DukeDave: I'm enjoying that economist article btw eheh
15:49:37 <kmc> int80_h, i can explain that implementation of Int in a bit (maybe an hour from now?)
15:49:43 <kmc> i think the GHC manual also does a good job
15:50:18 <kmc> int80_h, i don't know why people are telling you to "run away" and such
15:50:41 <elliott> kmc: internals are scary :)
15:50:41 <kmc> unboxed primitive types are ugly and low level (that's the point) and non-portable
15:50:48 <kmc> but they're not actually that difficult
15:50:51 <kmc> or unsafe
15:50:55 <elliott> they're not, but you'll sleep happier not knowing
15:51:09 <kmc> ignorance is bliss?
15:51:16 <elliott> unsafeFreezeArray# :: MutableArray# s a -> State# s -> (#State# s, Array# a#)
15:51:17 <elliott> kmc: yep
15:51:24 <kmc> then why are you programming in Haskell at all
15:51:28 <elliott> actually the array indexing functions that return a pure value are scarier.
15:51:47 <kmc> elliott, i don't think you need that particular function in order to use Int#
15:51:49 <kmc> anyway
15:51:55 <kmc> it's an annoying condescending attitude
15:52:02 * kmc is probably grumpy because he just woke up
15:52:03 <kmc> bbl
15:52:24 <rostayob1> kmc: well programming at really high level (haskell) in some sense reflects "ignorance is bliss"
15:53:18 <rostayob1> I mean I'm largely ignorant in how haskell is implemented in ghc... should I know?
15:53:54 <hpaste> DukeDave pasted “WX Vars” at http://hpaste.org/50446
15:54:24 <DukeDave> elliott: rostayob1: Feast your eyes upon that!
15:54:29 * DukeDave isn't sure how elegant this approach is
15:54:39 <elliott> DukeDave: var won't change between the calls to partA and partB. var can't change, it's a value.
15:54:49 <elliott> updateVar, however, is unsafe.
15:54:59 <elliott> someone could modify the variable in-between you reading and writing to it.
15:55:04 <elliott> and you'd just rudely overwrite their write
15:55:11 <elliott> you really want to use the STM functions instead.
15:55:23 <DukeDave> elliott: This is exactly the kind of advice I was looking for
15:55:47 <elliott> It's the advice I was trying to give :-P
15:55:51 <DukeDave> I really should guarantee that the partXs in myVar are always consistent
15:55:57 <DukeDave> Aha, thanks, I just wanted to make sure :)
15:56:18 <elliott> DukeDave: for using the STM functions, these should help:
15:56:19 <elliott> http://hackage.haskell.org/packages/archive/stm/2.2.0.1/doc/html/Control-Monad-STM.html
15:56:20 <elliott> http://hackage.haskell.org/packages/archive/stm/2.2.0.1/doc/html/Control-Concurrent-STM-TVar.html
15:56:22 <elliott> http://book.realworldhaskell.org/read/software-transactional-memory.html
15:56:32 <elliott> note that a WXVar is really just a TVar, so you can use the functions from the second module on them
15:57:44 <rostayob1> DukeDave: I think I'll feast my eyes over some book now, going to bed :)
15:57:44 <DukeDave> elliott: Thanks, I'll do some reading
15:58:00 <DukeDave> rostayob1: Enjoy :)
15:58:19 <rostayob1> but yeah RWH has a chapter on STM - in case you missed kmc comment: http://book.realworldhaskell.org/read/software-transactional-memory.html
15:58:23 <elliott> DukeDave: atomically (do x <- readTVar myVar; ...compute new value x'...; writeTVar myVar x') is probably what you want to do
15:58:26 <elliott> rostayob1: I linked it too :)
15:58:43 <rostayob1> oh ok, I really am tired eheh
15:58:49 <rostayob1> bye!
15:59:58 <DukeDave> elliott: That's reassuring
16:00:20 <DukeDave> Ah, I see my misunderstanding now
16:00:55 <DukeDave> Because the 'wrapper' functions in WX are all in the IO monad, other operations can occur in between each one
16:00:59 <elliott> yep
16:01:15 <elliott> whereas the STM monad guarantees atomicity, and you run it with "atomically"
16:01:22 * DukeDave nods
16:01:50 <DukeDave> Well I'm sure glad that the WX.Var is a TVar :D
16:02:00 <DukeDave> And that *it always will be*
16:02:13 <elliott> Keep telling yourself that!
16:02:13 * DukeDave is nominating himself lead WX maintainer
16:02:39 <elliott> Looks like it's depended on STM for three years, so the odds are on your side
16:04:58 <DukeDave> Thanks for all your help!
16:05:00 <DukeDave> elliott++
16:05:54 <elliott> np :)
16:08:20 * hackagebot bson 0.1.4 - BSON documents are JSON-like objects with a standard binary encoding  http://hackage.haskell.org/package/bson-0.1.4 (TonyHannan)
16:13:22 * hackagebot sundown 0.1.1 - Binding to upskirt  http://hackage.haskell.org/package/sundown-0.1.1 (FrancescoMazzoli)
16:13:24 * hackagebot mongoDB 1.0.2 - Driver (client) for MongoDB, a free, scalable, fast, document DBMS  http://hackage.haskell.org/package/mongoDB-1.0.2 (TonyHannan)
16:25:28 <copumpkin> anyone seen     suffix or operands invalid for `movq'
16:25:35 <copumpkin> on a 7.2.1 GHC install on mac os?
16:26:23 <copumpkin> (snow leopard)
16:29:29 <Kaidelong> @instances-importing Monoid
16:29:30 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
16:29:57 <copumpkin> anyone want to make a proposal to add bitwise monoid instances?
16:30:39 <parcs> @instances Bits
16:30:39 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
16:30:48 <Kaidelong> I was more wondering about whether there is one for (Monoid n, Monad m) => Monoid (m n)
16:30:49 <parcs> @instances-importing Bits
16:30:50 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
16:30:57 <dstcruz> copumpkin: have you gotten cabal-install working with ghc 7.2.1?
16:31:04 <Kaidelong> as opposed to just one for (->)
16:31:05 <copumpkin> dstcruz: didn't seem to need to do anything special there
16:31:11 <xil> hello. Anyone know if leksah has the ability to turn off autocompletion?
16:31:13 <copumpkin> dstcruz: but now that I'm trying to build a project, I get that error
16:31:13 <Kaidelong> well applicatives would work here rather than monads
16:31:41 <copumpkin> Kaidelong: instances like that are weird
16:32:05 <DukeDave> Grr, why am I having so much trouble formulating this with Data.Map:
16:32:07 <DukeDave> Update mapB to contain all the new things from mapA, and delete anything not in mapA;
16:32:09 <DukeDave> if a thing from mapA is already in mapB then leave it as it is in mapB, else I'll provide a function to give you its new value in mapB.
16:32:19 <Kaidelong> but in particular I was wondering how "IO ()" would behave as a monoid
16:32:35 <Peaker> Kaidelong: there's an instance for Monoid like that with Applicative, more general than Monad -- but it's going to overlap so is buried in newtypes or comments within conal's TypeCompose package
16:32:46 <Kaidelong> what disturbed me was that in the case of mappend only the first argument seemed like it would have side effects
16:32:57 <copumpkin> Kaidelong: why?
16:32:58 <DukeDave> An intersection won't add new things, and a union won't delete old things :|
16:33:09 <mustelo> is anyone familiar with decompressing pdf flatedecode'd streams?
16:33:14 <Kaidelong> copumpkin: mappend for () is not strict in both arguments
16:33:24 <Kaidelong> I think conal pointed out that was a bit of a problem
16:33:27 <copumpkin> Kaidelong: that won't affect whether the effects happen
16:33:37 <Peaker> DukeDave: basically you want the new set of keys to be identical to that of mapA?
16:33:51 <Kaidelong> hmm, it won't?
16:33:56 <copumpkin> nope
16:34:01 <Peaker> DukeDave: and for every key you want to choose from B, and if not there, then from A?
16:34:02 <copumpkin> you want mappend to be liftA2 mappend, right?
16:34:32 <DukeDave> Peaker: Exactly!
16:34:33 <Kaidelong> so if you have x = return (), and y = return (), and you did "(liftA2 mappend) x y", x and y will both be run?
16:34:35 <Kaidelong> oh
16:34:37 <Kaidelong> yes they will
16:34:40 <Kaidelong> I see now, herp
16:34:46 <copumpkin> Kaidelong: I can liftA2 (\_ _ -> 5) (putStrLn "ohai") (putStrLn "moo")
16:34:55 <copumpkin> :)
16:34:56 <DukeDave> Peaker: I think I can express it using intersection and difference
16:35:13 <Kaidelong> the way >>= works for IO is why it works, right?
16:35:26 <Peaker> DukeDave: I'd just use a map on A
16:35:30 <copumpkin> effects just always happen if you sequence
16:35:31 <Peaker> @type Map.map
16:35:32 <lambdabot> Couldn't find qualified module.
16:35:35 <Peaker> @type Data.Map.map
16:35:36 <lambdabot> forall a b k. (a -> b) -> M.Map k a -> M.Map k b
16:35:49 * BMeph always remembers the "you can make an 'ifM' function, but not an 'ifA' one" tip for Applicatives vs. Monads
16:35:54 <copumpkin> Kaidelong: the effects of a monadic action are independent of its return value
16:36:18 <DukeDave> Peaker: The mapped function would then do a look up on B ?
16:36:27 <Peaker> DukeDave: yeah:
16:36:30 <DukeDave> And if it didn't find anything return the new value
16:36:35 <DukeDave> That sounds clean
16:36:44 <Peaker> DukeDave: just   Map.mapWithKey (\key old -> fromMaybe old (Map.lookup key mapB))
16:37:00 <Peaker> apply this on mapA, that is
16:37:18 <Kaidelong> copumpkin: not sure what that means exactly, but I did realize why (liftA2 mappend) will perform all the effects
16:37:24 <DukeDave> Peaker: Cute!
16:37:33 <DukeDave> Thanks very much
16:37:37 <DukeDave> Peaker++
16:37:38 <Peaker> sure :)
16:37:57 <copumpkin> Kaidelong: the bind method for your monad (or <*> for your applicative) will be called regardless of whether you force the values anywhere
16:38:04 <Kaidelong> yeah
16:38:13 <Kaidelong> >>= forces the effects whenever the result of it is demanded
16:38:17 <Kaidelong> that was my realization
16:38:32 <copumpkin> yeah
16:38:39 <copumpkin> but >>= \_ -> x
16:38:52 <copumpkin> still makes effects happen even if the parameter is ignored
16:38:54 <copumpkin> it's just called >>
16:38:59 <Kaidelong> yeah
16:39:11 <Kaidelong> basically what I remembered was that liftM2 has to bind stuff to work
16:39:12 <int80_h> @src Just
16:39:12 <lambdabot> Source not found. Just try something else.
16:39:14 <Kaidelong> and thus I'm fine
16:39:17 <copumpkin> :)
16:39:22 <int80_h> :t Just
16:39:23 <lambdabot> forall a. a -> Maybe a
16:44:47 <Peaker> DukeDave: btw: there's an even cuter solution :-)
16:45:35 <Peaker> hmm.. maybe it's not cuter, it works nicely with conal's TMap, not so nice with Map..
16:46:18 <Peaker> conal's TMap is not on Hackage?
16:54:57 <Dashkal> I am not people.  I am a pet rock application running on a TI-83 gone sapient.
16:57:04 <Gracenotes> is there some paper/blog post/wiki page about how ML mutable references are a thorn in their implementation of hindley-milner?
16:57:15 <Gracenotes> I vaguely remember reading this, but forget from where
16:57:31 <c_wraith> Gracenotes: only polymorphic references
16:57:32 <Gracenotes> it may have been related to STVar/IOVar
16:57:36 <Gracenotes> c_wraith: yep
16:57:51 <ezyang> I briefly talk about it http://blog.ezyang.com/2010/10/ocaml-for-haskellers/ under "Eta expansion"
16:57:51 <c_wraith> and it's the same way unsafePerformIO can give you unsafeCoerce in haskell
16:58:07 <roconnor> Gracenotes: I seem to recal that they are a thorn in type safety with polymorphic references
16:58:11 <Gracenotes> er. s/Var/Ref/
16:58:25 <hpaste> int80_h pasted “troubles creating my first typeclass” at http://hpaste.org/50447
16:58:27 <ezyang> If you search for "eta expansion" you can probably find more references about it.
16:58:28 <Gracenotes> c_wraith: yeah, exactly
16:58:38 <roconnor> or maybe that is the trick, either you require monomorphic references and screw up hindley-milner, or you allow polymorphic references and screw up type safety.
16:58:48 <Gracenotes> the knowledge was imparted to me, I just forget from where
16:58:50 <Gracenotes> :P
16:59:42 <Gracenotes> monads aren't too bad of a way of going about it. at least to the end-programmer.
17:00:28 <elliott> hmm, so what does ML do? disallow polymorphic references?
17:00:51 <Draconx> elliott, it has something called the value restriction, which restricts what kind of expressions can be polymorphic.
17:01:04 <elliott> int80_h: I'm unable to understand the question in that paste.
17:02:13 <int80_h> elliott: I'm confused. I'll think about this more. But I'm questioning what ServerMOdel should look like. Does it make sense to create a data type the way I did, or am I being superfluous.
17:02:33 <elliott> int80_h: Why do you even have a typeclass?
17:02:52 <elliott> Your code is wrong, though; ServerModel is of kind * -> * but PM wants a parameter of kind *.
17:03:30 <int80_h> elliott: because each instance will depend on what Server a looks like.
17:04:14 <elliott> int80_h: I agree that you're thinking about whatever problem you have in the wrong way. Unfortunately it's so wrong that I'm not even sure what it is you're thinking, or what your problem is. I don't really know how to help.
17:04:16 <int80_h> elliot: What I need to do, but haven't done yet is define the types I will be passing as a parameter to ServerModel
17:05:05 <aavogt> if all the specific implementations like  (fooInt :: Server Int -> FilePath -> IO ();  fooDouble :: Server Double -> FilePath -> IO ())  all have   Server x as the first argument, it's better to make the foo :: Server a -> FilePath -> IO ()
17:05:35 <elliott> int80_h: Might you want a type family?
17:05:39 <elliott> For Server.
17:05:54 <int80_h> aavogt: that looks right!
17:05:55 <elliott> class IsServer a where data Server a; foo :: Server a -> FilePath -> IO ()
17:06:02 <int80_h> elliott: yes I think I want a type family
17:06:08 <elliott> instance IsServer Int where data Server Int = IntServer ...; foo (IntServer ...) fp = ...
17:06:12 <aavogt> that way you will get a better type error
17:06:19 <elliott> int80_h: Does that look right?
17:06:40 <int80_h> elliott: I'm thinking about that hold on.
17:06:50 <Peaker> int80_h: a classic mistake people new to Haskell make is model almost everything with type-classes.. A type-class shares a lot of similarity with a simple record (dictionary).. Except a type-class also does type-based selection of that dictionary.  For many purposes, you want runtime-based (dynamic) choice and *not* type-based/ad-hoc polymorphism.. If you can do it with records reasonably and not type-classes, typically that means you should
17:07:40 <Peaker> Type-classes are generally for overloading/polymorphism, not for bunching dictionaries together
17:08:17 <elliott> Peaker: Agreed, I've often found myself replacing a typeclass with a (sometimes existentially quantified) record and getting much cleaner results.
17:08:21 <int80_h> Peaker: I want to define a series of functions that have different behaviors depending on what types are passed.
17:08:57 <elliott> data Server a = Server { foo :: FilePath -> IO () }
17:09:01 <elliott> foo :: Server a -> FilePath -> IO ()
17:09:05 <elliott> int80_h: Look ma, no typeclasses :)
17:09:25 <elliott> That might not be exactly what you want, but often if you want a typeclass + data family, what you really want is a record...
17:09:43 <int80_h> elliott: you put a function in a record! I thought of doing that but wasn't sure if I would end up with something convoluted.
17:09:52 <Peaker> elliott: yeah, though I think with a bit of extra restructuring, the existential goes away too... IME, existentials have always been there for efficiency concerns
17:10:10 <elliott> int80_h: Less convoluted than a typeclass and type family
17:10:18 <Peaker> int80_h: why do you want it to depend on the *type* that's passed, rather than an explicit choice of dictionary to pass?
17:10:46 <elliott> Peaker: The usecase for the existential is when each record (which basically serves as a "plugin" -- except there's a static list of them, but anyhow) has its own state.
17:11:00 <elliott> So "data Blah = forall state. Blah { initialState :: state, ... }"
17:11:30 <Peaker> elliott: well, since the only things you can do to the existential have to be specified right there next to the existential, you can typically just "pre-apply" all these possible things you can do
17:11:43 <Peaker> elliott: and store the (thungs) of the non-existential results
17:11:46 <Peaker> thunks, that is
17:11:56 <aavogt> you can't Read / Show functions
17:12:11 <Peaker> aavogt: And?
17:12:30 <Peaker> it may sometimes be cumbersome, is that what you mean?
17:12:34 <elliott> Peaker: data Foo = forall state. Foo { initialState :: M state, wow :: (M state, (state -> state) -> M ()) -> M () }
17:12:44 <elliott> Peaker: As a simplified example similar to what I actually have, how would you reduce that?
17:12:48 <aavogt> so when you separate the data from the functions it makes sense to put the latter in a class
17:13:00 <elliott> Peaker: (Each Foo has a unique identifier, so I save it in my state monad in a (Map Identifier Any).)
17:13:10 <elliott> (It could be (Map Identifier Dynamic), but ~EFFICIENCY~.)
17:13:52 <Peaker> elliott: maybe you can reduce that example somewhat?  Also, what operations exist on M? Is it a Monad?
17:14:10 <elliott> Peaker: Yes, M is a Monad (a StateT over IO, for what it's worth)
17:14:34 <elliott> Peaker: data Foo = forall state. Foo { initialState :: M state, wow :: M state -> M () }
17:14:42 <elliott> That's about as far as I can reduce it without it failing to represent what I'd need, I think.
17:15:32 <Peaker> elliott: well,   storing just M ()  gives you everything except what you could otherwise do with:  (exists state. M state)  via the M methods
17:16:02 <elliott> Peaker: Ah, um, it's not called as "wow initialState", if that's what you mean.
17:16:16 <Peaker> elliott: how else could it be called?
17:16:40 <elliott> Peaker: Do you want me to couch it in the safe Dynamic terms, or the real-implementation unsafeCoerce terms? :-)
17:17:02 <elliott> Peaker: Basically, when the Foo is loaded, initialState is executed, and it's put into a heterogeneous map, keyed by the Foo's unique identifier.
17:17:09 <Peaker> elliott: let's say M=Identity, and there are no type-class restrictions -- then there would be nothing you could do with M state *except* give it to wow
17:17:12 <elliott> When "wow" is called, it's passed an action that retrieves this state, and another one to modify it.
17:17:33 <elliott> Peaker: M is fixed to a StateT over IO which conveniently includes this heterogeneous map.
17:17:34 <Peaker> that means you can do stuff with "M state" despite state being existential, right?
17:18:36 <Peaker> elliott: you can have Foo contain the actions that would take   M state as an argument.. These actions should not have an existential in their type.. or if they do -- either it's unusable and can be replaced with a () or Void, or usable, and then you can recursively pre-apply all possible uses, and so forth
17:19:22 <elliott> I really don't understand what you mean -- wow _is_ the action.
17:19:50 <elliott> I mean, I think the simplification you requested has muddied the issue, because it _also_ gets a mechanism to update the state.
17:20:53 <elliott> I would love to remove the existential but I doubt it's possible.
17:21:14 <Peaker> elliott: maybe if you take me up on it as a challenge in a couple of weeks, I'd be able to do it (right now I'm overloaded with tasks..)
17:21:28 <elliott> Peaker: Fair enough. :)
17:21:46 <Peaker> elliott: I think it should be provably possible to compile existentials away into non-existentials by pre-applying whatever you'd apply on them later, before "packing" them into the type
17:22:27 <Peaker> for example:   exists a. (a, a -> b)     is isomorphic to b,  unless I'm missing some bottom considerations
17:22:43 <Peaker> (as a very simple example, but I think it can generalize)
17:22:52 <Peaker> though sometimes you don't want to pre-apply because of performance implications
17:27:11 <kmc> rostayob, elliott, agreed that it's nice to use a high-level language without thinking about implementation details
17:27:23 <kmc> that's different from saying people shouldn't learn the details even when they want to
17:27:47 <kmc> the latter attitude is a common complaint about the Ruby on Rails community
17:27:59 <elliott> I don't think people are sincere when they say run away
17:28:02 <elliott> at least I'm not
17:28:03 <elliott> or, rather
17:28:09 <elliott> what I mean is something like "you might not actually care about this"
17:28:17 <kmc> sure
17:28:17 <elliott> rather than "nobody should know this"
17:28:37 <kmc> int80_h, did you figure out how Int and Int# work?
17:28:59 <dolio> It is isomorphic to b, roughly speaking.
17:31:33 <spetrea> any lisp fans here ? I don't know squat about lisp but I wanna run this https://github.com/filonenko-mikhail/restmax
17:34:27 <int80_h> kmc: No, I was looking for a way to think about the data type I wanted to make, and I thought looking into how Int is defined would help. I decided that Maybe was a better model. But now I htink I need a newtype and not a data
17:34:51 <kmc> the difference between newtype and data is slight
17:35:03 <kmc> http://haskell.org/haskellwiki/FAQ#What.27s_the_difference_between_type.2C_data.2C_and_newtype.3F
17:35:25 <kmc> you almost never *need* newtype
17:35:37 <ski> Gracenotes : that problem with mutable references in the MLs is the same as the problem you get if you use `unsafePerformIO' with references in Haskell, which is that you can then define `unsafeCoerce :: a -> b'
17:35:39 <kmc> it's a performance optimization that has slightly different semantics
17:37:13 <int80_h> kmc: looking something up in RWH...
17:38:20 <kmc> spetrea, you could try #lisp (or is it ##lisp)
17:38:38 <int80_h> kmc: RWH says a newtype can have only one value constructor with only one field. That's exactly what I have. It looked wrong to me to have a data loking that way.
17:38:48 <shapr> I'm writing my own ngram code in Haskell, without looking at any of the existing code... it's way fun!
17:38:53 <kmc> why did it look wrong int80_h
17:39:00 <kmc> what RWH said is correct
17:39:26 <int80_h> kmc: no I mean it looked wrong to express my type as a data instead of a newtype
17:39:32 <kmc> why did it look wrong int80_h
17:39:36 <ski> elliott : btw, the value restriction actually has some similarity (in when it applies) to the monomorphism restriction. the difference is (a); that the latter doesn't allow *overloaded* operations, while the former disallow any polymorphic ones, and (b) that the latter kicks in when using value bindings, while the former only kicks in when using value bindings with a non-syntactic-value body
17:39:56 <int80_h> kmc: well, because I've never seen a data with only one value constructor.
17:40:08 <int80_h> and only one parameter
17:40:13 <elliott> ski: right
17:40:48 <kmc> int80_h, it works just the same
17:41:13 <int80_h> kmc: Having never sen one before, it made me think I was misusing data.
17:41:19 <kmc> anyway, newtype is an optimization
17:41:47 <int80_h> kmc: I see, I will proceed using data as I started out doing
17:41:57 <kmc> some use cases of 'data' can be replaced with 'newtype' for a performance gain and a minor change in semantics
17:42:04 <shapr> @pl sum (Data.Map.elems uni)
17:42:05 <lambdabot> sum (Data.Map.elems uni)
17:42:06 <kmc> that doesn't mean 'data' is wrong in those cases
17:42:11 <kmc> if you're getting confused, stick to 'data'
17:42:13 * shachaf tends to think of data and newtype differently, even in cases where either would work.
17:42:33 <shapr> shachaf: why so?
17:42:36 <int80_h> kmc: my confusion cleared up a bit when I saw that what I wanted fit a newtype exactly.
17:42:39 <ski> Gracenotes : so the problem arises if you can construct a value of type `forall a. IORef (Maybe a)' (which has already allocated a reference, as opposed to allocating a reference when `a' is specialized to some concrete type in type-passing implementations)
17:42:41 <kmc> ok
17:42:48 <kmc> then maybe newtype is less confusing :)
17:43:27 <int80_h> kmc: This was more of a style problem. I wanted to make sure I wasn't going down a path where I ended up trying to fit a square in a round hole.
17:44:08 <shachaf> shapr: Well, I think of "newtype" more as super-"type" than as sub-"data".
17:44:16 <shachaf> Maybe the difference isn't that big.
17:44:21 <shapr> makes sense to me
17:44:33 <shapr> Actually, that's how I think of it too.
17:44:33 <kmc> newtype and data both introduce a new type
17:44:35 <kmc> 'type' doesn't
17:44:49 <kmc> that seems like the most fundamental difference between the three
17:44:52 <clsmith> which is confusing
17:45:14 <kmc> why clsmith?
17:45:15 <shachaf> Right, newtype is type-checked "type", whereas data introduces a whole different strictness thing.
17:45:27 * shachaf thinks quite a lot of instances of "type" should really be "newtype".
17:46:01 <clsmith> kmc: type doesn't make a new type, but newtype does, but so does data? bit weird, terminology wise
17:46:01 * int80_h waves
17:46:07 <int80_h> gotta run off to dinner
17:46:31 <monochrom> the confusion is due to reading between the names
17:46:38 <kmc> agreed that the keyword "data" is a bit arbitrary
17:46:52 <kmc> but i think "type Foo = Bar" reads fine
17:46:57 <shachaf> #define Foo Bar
17:47:00 <kmc> in C when you write "int x = 3;"
17:47:09 <kmc> you're not inventing a new int, distinct from all the previous ones
17:47:24 <kmc> you're creating a new name for an existing int
17:47:36 <kmc> the '=' sign in 'type' is pretty accurate
17:47:40 <kmc> unlike in 'data' and 'newtype'
17:47:54 <shachaf> Right, it can just be substituted.
17:47:56 <clsmith> i guess i just think the distinction between data and newtype is a bit weird
17:48:06 <copumpkin> it's subtle
17:48:07 <monochrom> the analogy breaks when you try "type Foo = Bar; for (i = 0; i < 10; i++) Foo = [Foo]"
17:48:10 <shachaf> Do you propose GADT syntax for newtype too? :-)
17:48:23 <kmc> clsmith, newtype is an optimization of certain use cases of data
17:48:42 <ski> int80_h : `newtype's are generally used when (a) you basically want a type synonym, but you want to either partially apply it, or make it cyclic, or get extra type-checking, or make it abstract so that you can make the abstract type some combination of subtype and factor type of the representation type; or (b) when you want give a type class instance (possibly derived) (possibly different from existing instance) to it
17:48:49 <kmc> except the semantics are subtly different, so it's an optimization that can't be applied automatically
17:49:03 <kmc> it's true that newtype has particular use cases
17:49:08 <clsmith> kmc: yeah, which is why i think it's weird, i guess. optimisations being a part of the language is weird
17:49:24 <kmc> but i don't think you need to understand the use cases to understand what it is
17:49:30 <kmc> clsmith, yeah, it is weird
17:49:36 <kmc> but it does change semantics
17:49:42 <kmc> you need a way to say "changing the semantics is ok"
17:49:46 <shachaf> I think the semantic difference is significant enough to merit a new construct.
17:49:54 <shachaf> I suppose in a strict language data = newtype.
17:49:54 <spetrea> kmc: I tried it man, but noone there is interested
17:50:06 <ski> shachaf : hm "super-type", how do you mean ?
17:50:21 <kmc> clsmith, there are a few cases where you explicitly want the 'data' semantics even with one-ctor, one-field data
17:50:24 <shachaf> ski: I just mean a version of the "type" keyword with extra capabiliies. :-)
17:50:29 <shachaf> (Namely, being machine-checked.)
17:50:37 <ski> clsmith : `type' *names* a type
17:50:53 <ski> shachaf : well, that's not what the term "supertype" traditionally means :)
17:51:03 <shachaf> ski: Right, I didn't intend it in that sense.
17:51:05 <clsmith> kmc: like when?
17:51:22 * shachaf hoped the quotation marks and dash would be enough to make the distinction, but probably not.
17:51:32 <kmc> http://hackage.haskell.org/packages/archive/parallel/3.1.0.1/doc/html/Control-Parallel-Strategies.html#t:Eval
17:52:45 <ski> (kmc : actually `int x = 3;' in C names a new (initialized) `int' location :)
17:52:57 <kmc> ski, right, i was glossing over that ;)
17:53:25 <shachaf> Maybe type aliases shouldn't have a keyword to indicate them.
17:53:29 <shachaf> Just "Foo = Bar".
17:53:30 * hackagebot dbus-core 0.9.2 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.9.2 (JohnMillikin)
17:53:38 <kmc> shachaf, that's how it works in Agda ;)
17:53:42 <shachaf> Of course, then people get tempted to make type functions and what not.
17:53:44 <shapr> Is there a 'best' way to use a PRNG? For example, I'm finding the number of times a letter occurs in some text, then getting the total count of all letters, thus I have the frequency. What's the best way to map System.Random.randomRs output to produce letters?
17:54:04 <ski> (so in a sense, C doesn't have call-by-value, since `f(x)' doesn't pass the "value" of `x' (i.e. the location), instead passing the *contents* of that location)
17:56:59 <clsmith> f(&x)? i don't get your point
17:57:09 <shachaf> ski: That's the sort of thing a functional programmer would say.
17:58:29 <ski> conal : btw, the "Sam Tobin-Hochstadt" you were talking to on SO is samth (now samth_away) in #scheme
17:59:30 <ski> clsmith : oh, but `f(&x)' doesn't pass the location either, it passes an r-value (a pointer) which corresponds to the location (which is an l-value) :)
17:59:51 <kmc> @arr value
17:59:51 <lambdabot> I want me grog!
18:00:13 <shachaf> ski: &x doesn't even have a location.
18:00:27 <ski> right, `&x' is an r-value
18:01:35 <ski> the point being that you can only pass r-values, not l-values
18:02:01 <clsmith> so how does f(3) fare?
18:02:11 <ski> (in C++ you can have mutable l-values (references), which you can pass, though)
18:02:12 <clsmith> oh i see what you mean
18:02:17 <clsmith> (cancel that)
18:02:38 <shachaf> ski: Right, but an l-value is also an r-value.
18:02:43 <shachaf> Or would you say it's implicitly converted? :-)
18:03:26 <ski> (i.e. you can have a mutable variable which stands for some l-value at each point in time, but which that is can be changed)
18:03:43 <ski> yes, it's an implicit conversion (between different syntactic classes, in this case)
18:04:08 <ski> in the MLs you'd write `x' (the location/reference) vs. the `!x' (the contents of it)
18:04:58 <ski> (i wouldn't say an l-value (the semantic thing, not the syntactic class is an r-value, since you need to actually read the location to do the transformation)
18:05:12 <ski> (s/class/class)/)
18:07:08 <mike-burns> These parens are hard to read. Can't you use ($) ?
18:08:02 <Eduard_Munteanu> If x is a local, then f(x) doesn't really need to do anything special, the compiler just knows where it is on the stack.
18:08:38 <Eduard_Munteanu> Or f(&x).
18:09:08 <ski> it (`f(x)') needs to read the location, and store the contents in a new location in the new activition frame
18:09:30 <ski> (`f(&x)' would convert the location to an r-value, and store that in the new location)
18:45:28 <Peaker> lvalue/rvalue are such bad names for location(mutable) and value(immutable)
18:46:54 <Maxdamantus> They're not.
18:47:20 <Maxdamantus> (depending on the domain)
18:47:35 <Maxdamantus> in C, you have immutable lvalues such as "foo"
18:48:16 <Maxdamantus> (in C, the terms refer to types of expressions)
18:48:29 <Peaker> I don't think "foo" is an lvalue
18:48:32 <Maxdamantus> It is.
18:48:45 <Maxdamantus> You can take its address, &"foo"
18:49:06 <Maxdamantus> Unary & requires that the operand be an lvalue.
18:49:08 <Peaker> I concede :-)  It is still a location, an immutable one
18:49:26 <Peaker> location/value seems like a more clear dichotomy than lvalue/rvalue
18:49:50 <Peaker> also, C could be a lot less confusing if you had array-typed rvalues
18:50:06 <Peaker> (and no array-parameter-type-desugared-to-ptr too)
18:50:09 <Maxdamantus> lvalue is fine .. rvalue should just be used rarely, because it's rarely relavent.
18:50:12 <Maxdamantus> relevant*
18:50:25 <Peaker> Maxdamantus: well, often people say "value" and they really mean "rvalue"
18:50:45 <Maxdamantus> Hm. I'm not active enough here to notice.
18:50:49 <Peaker> "lvalue" and "rvalue" imply a similarity.. But they aren't similar -- it's just that use reads of values from locations are implicit
18:51:01 <Maxdamantus> Usually when talking about programming languages, you mix terms.
18:51:38 <Maxdamantus> Because it's easier to say "assign to x" than "assign to the object aliased by the variable x"
18:52:11 <Maxdamantus> imo an rvalue is just an expression that's not an lvalue.
18:53:09 <Maxdamantus> Also, you can have array-typed rvalues, in C89.
18:53:15 <Maxdamantus> They're just not useful .. at all.
18:54:19 <Maxdamantus> struct { int a[10]; } foo(void); .. `foo().a` is an array rvalue, and can't be used for anything.
18:55:02 <copumpkin> edwardk: λ> toDouble (fromInt 101 713212352)
18:55:06 <copumpkin> 7.13212352e8
18:55:07 <Maxdamantus> (gnu89 funnily allows you to use it as the right operand of assignment)
18:55:13 <edwardk> ?
18:55:17 <Peaker> Maxdamantus: you can still say "assign to x" because x is a location
18:55:21 <copumpkin> edwardk: that's round-tripping through MPFR :)
18:55:30 <Maxdamantus> Peaker: x is a variable.
18:55:36 <edwardk> wait, you got it to work?
18:55:38 <Peaker> Maxdamantus: that's not an array-typed rvalue, it's a struct-typed rvalue, that happens to contain an array
18:55:48 <Maxdamantus> Peaker: variables only have locations in that they alias objects, which have locations.
18:55:51 <copumpkin> edwardk: started working on it again just a little while ago
18:55:51 * edwardk hugs copumpkin
18:55:53 <ski> Peaker : there's the similarity that both require to do some computation before yielding a value (either a location/l-value, or an r-value)
18:56:02 <edwardk> you rock
18:56:03 <copumpkin> edwardk: still doesn't do anything, but it took me a while to get even this far without crashing :P
18:56:15 <Maxdamantus> Peaker: no, foo() is a struct-typed rvalue.
18:56:19 <edwardk> still progress is progress!
18:56:26 <Maxdamantus> Peaker: foo().a is an array-typed rvalue.
18:56:45 <copumpkin> yep! :D
18:56:54 <copumpkin> this is a really minimal binding
18:57:00 <copumpkin> none of your fancy stuff around it
18:57:07 <copumpkin> I just wanted to get it working then hand it off to you to make it pretty
18:57:10 <edwardk> add a (+) and I can probably get the rest working
18:57:22 <copumpkin> okay :)
18:57:59 <Peaker> Maxdamantus: oh, I learned something new today :)
18:58:17 <Peaker> Maxdamantus: seems like a very special case...
18:58:25 <ski> Maxdamantus : what does gnu89 do with `bar = foo(x).a' ? assign the array to the array `bar' ?
18:58:31 <Maxdamantus> ski: yes.
18:58:48 <ski> (so it's not decaying the array to a pointer, then, i take it)
18:59:04 <Peaker> I think this is the first time I've ever seen array assignment in C..
18:59:07 <ski> Maxdamantus : and you can do that not only in array initializations ?
18:59:10 <Maxdamantus> C doesn't do that though, because the array expression on the left is still converted to a pointer (rvalue) expression.
19:00:01 <Maxdamantus> ski: in gnu89, yes.
19:00:31 <Maxdamantus> Actually, I wonder if you can use it in an array initialisation in C89.
19:00:51 <Maxdamantus> int b[10] = foo().a;
19:00:52 <Peaker> Maxdamantus: hmm.. I guess I'm a fool for listening to ##c's Zhivago who proclaimed with authority that there were indeed no array-typed rvalues in C
19:01:10 <Peaker> It doesn't allow initialization, only assignment, with gcc with no special options, at least
19:01:24 <Maxdamantus> Hm. Really?
19:01:27 <Peaker> testfoo.c:13:5: error: array initialized from non-constant array expression
19:01:38 <Maxdamantus> Interesting.
19:02:00 <Peaker> -c99 says "invalid initializer"
19:02:33 <Maxdamantus> Yeah, in C99 you can't have array-typed rvalues.
19:02:46 <Maxdamantus> They get turned into pointers, and something magical happens.
19:02:58 <Peaker> so, when converting a struct-typed lvalue to an rvalue, and then taking a member which is an array -- is the only way to create array-typed rvalues?
19:03:13 <Eduard_Munteanu> Why would you? Having the compiler do some sort of memcpy() behind your back?
19:03:34 <Peaker> I recently discovered how useful the type-safety from passing ptr-to-array is, rather than using the typical ptr-to-first-element
19:03:50 <Peaker> Sure, the syntax is a bit kludgy, but you get a size verification
19:04:06 <Draconx|Laptop> Peaker, yes; they're called "non-lvalue arrays" by the language spec.  They only occur when you return structs containing array members from functions.
19:04:30 <ski> Peaker : "converting a struct-typed lvalue to an rvalue", i thought it was already a struct-typed r-value, in Maxdamantus' example
19:04:33 <Peaker> also, I now have a COMPILE_TIME_ASSERT macro -- which is pretty great, and lots of stuff is built on top of that:  SAFE_COPY(dest, src)   COMPILE_TIME_ASSERT(sizeof dest >= sizeof src); memcpy(&dest, &src, sizeof(src));
19:04:43 <Peaker> (with the do{}while(0)/etc around it)
19:05:22 <Maxdamantus> Peaker: you can't convert a struct-typed lvalue to rvalue.
19:05:23 <Peaker> Draconx|Laptop: that's the most special special case I've ever heard of in a language, let alone C :)
19:05:43 <Peaker> Maxdamantus: well, using the term "convert" loosely (e.g: return a struct value)
19:06:12 <ski> Peaker : now if only you could do dependent types `blah foo(size_t n,int (*ptr_to_arr)[n]) { ... }' ..
19:06:24 <Peaker> spamming COMPILE_TIME_ASSERT on all the implicit assumptions possible is a huge help
19:06:38 <Peaker> ski: atslang :-)
19:08:08 <Draconx|Laptop> Peaker, er, it can happen with a union, too :)
19:08:55 <Peaker> Draconx|Laptop: C sucks :)
19:09:09 <Peaker> (and yet, no other language competes with it in that space.. so it's still the best there, heh)
19:09:45 <ski> Maxdamantus : because you've only got selective updating, but not total updating, in C ?
19:11:59 <copumpkin> ezyang: you around?
19:13:39 <copumpkin> okay, this makes no sense at all
19:13:59 <ivanm> copumpkin: what, him not being around?
19:14:00 <ivanm> ;)
19:15:08 <ski> Peaker : first i thought `exists a. (a,a -> b)' would correspond to `((),(),b)', bottoms included, but then i realized `(u0,u,b)', if at least one of `u0',`u' is `_|_', but `b' isn't, wouldn't have a correspondence in the former type
19:15:39 <Peaker> ski: well, I like to ignore bottoms.. I use partiality very very sparingly anyway
19:16:05 <Peaker> And I would love Haskell-with-unlifted-products, too
19:16:17 <Peaker> less bikeshedding on "swap" in THAT language!
19:17:39 <shachaf> How about Haskell-with-unlifted-everything?
19:17:58 * shachaf proposes yet another innovative idea.
19:23:26 * ski wonders whether in a bootstrapped priority queue you could do away with the existential as Peaker wanted
19:23:36 <Eduard_Munteanu> What's this lifting of products?
19:24:20 <edwardk> i've gradually become more convinced that lazy State, etc. aren't actually monads
19:24:22 <copumpkin> edwardk: okay, GHC bug :)
19:24:26 <edwardk> doh
19:24:29 <copumpkin> sigh
19:24:31 <Peaker> Eduard_Munteanu:   there's a difference between:  swap (x, y) = (y, x)     and   swap ~(x, y) = (y, x)        or between:  _ mappend _ = ()  and () mappend () = ()
19:24:32 <copumpkin> two of them
19:24:35 <ski> Eduard_Munteanu : `(_|_,_)',`(_,_|_)',`(_|_,_|_)',`_|_' are all distinct cases
19:24:41 <edwardk> keeping the mpfr bindings from working?
19:24:55 <copumpkin> edwardk: preventing me from writing add, which I think is otherwise quite straightforward
19:25:03 <copumpkin> and this is on 7.2.1, sadly
19:25:03 <edwardk> =(
19:25:05 <Peaker> You can unite (_|_, _|_)  and  _|_   by always irrefutably pattern matching products
19:25:18 <edwardk> peaker: the problem is seq
19:25:22 <copumpkin> let me write a simpler add for now
19:25:22 <Peaker> screw seq :-)
19:25:28 <copumpkin> to see if I can hardcode the rounding mode at least
19:25:41 <edwardk> what is the bug anyways?
19:25:52 <Peaker> edwardk: seq breaks encapsulation too -- unless you know the type anyway, in which case you can use a more specialized thingie, e.g: a type-class
19:26:08 <copumpkin> edwardk: any input registers higher than R8 seem to get corrupted somehow
19:26:14 <copumpkin> and add takes 9 parameters
19:26:17 <Peaker> unless you know the type and some strictness details that are usually implementation details
19:26:18 <edwardk> crap
19:26:23 <Eduard_Munteanu> Peaker: hm, so unlifted products would always behave like matching with irrefutable patterns?
19:26:39 <Eduard_Munteanu> (Is that what you mean?)
19:26:57 <Peaker> Eduard_Munteanu:  Yeah, which means that (a,b,c)  becomes truly isomorphic to (a,(b,c))  and  () `mappend` () = () is the same as _ `mappend` _ = ()
19:26:59 <edwardk> i wonder if we could bundle up some of the inputs
19:27:13 <Peaker> Eduard_Munteanu: less artificial/unnecessary differences -- less silly bike shedding on code -- more laws apply!
19:27:31 <Peaker> and it helps get rid of "seq" which is evil anyway...
19:27:39 <aavogt> Peaker: don't you ever use infinite lists?
19:27:57 <Peaker> aavogt: I do, why?
19:28:13 <aavogt> because if you ignore bottom I don't believe they work
19:28:18 <Eduard_Munteanu> I see.
19:28:33 <aavogt> err, assume things are strict
19:29:10 <Peaker> aavogt: yeah, I don't completely ignore bottom/strictness-analysis, I guess.. I'm speculating "why fast & loose is morally correct" paper about bottoms applies here
19:29:33 <Peaker> Eduard_Munteanu: we can get rid of the bazillions of sized-tuple types and instances
19:29:57 <Peaker> and replace them with 2 HList-like type combinators
19:30:04 <ski> Peaker : hm, maybe one might change (or add a new type with) the semantics of a pattern `(<p0>,<p1>)' to be lazy unless at least one of the patterns `<p0>' and `<p1>' are refutable ..
19:30:11 <ddarius> You can easily make a strict pair to get that behavior.
19:30:38 <edwardk> copumpkin: we could always cram the two signs into one argument as a stopgap =/
19:31:06 <copumpkin> yeah
19:31:11 <copumpkin> now I have a bug of my own, I think
19:31:17 <copumpkin> I temporarily just hardcoded the rounding mode for the addition
19:31:19 <dolio> Making (a,b,c) = (a, (b,c)) or some such still isn't particularly desirable, even if tuples are unlifted.
19:31:37 <dolio> It's just no longer semantically different.
19:31:52 <dolio> (Denotational semantics, at least.)
19:32:16 <copumpkin> edwardk
19:32:17 <copumpkin> λ> toDouble (addMPFR 0 (fromInt 10 10) (fromInt 10 100))
19:32:17 <copumpkin> 110.0
19:32:18 <copumpkin> :)
19:32:26 <edwardk> sweet!
19:32:38 <edwardk> now to entangle the signs
19:32:42 <ski> dolio : might you elaborate on what you mean ?
19:32:43 <dolio> What's the first 10?
19:32:46 <edwardk> so we have the register for the rounding modes
19:32:48 <edwardk> precision
19:33:01 <dolio> ski: It's still implemented with extra indirection even if the matches are irrefutable.
19:33:07 <dolio> Most likely.
19:33:17 <edwardk> mpfr lets you round the mantissa to a given number of bits
19:33:28 <ski> dolio : yeah .. what matters is whether that extra indirection is observable or not, i think
19:33:28 <dolio> Right.
19:33:47 <edwardk> the 9th register being corrupt may be the problem we had when we tried this before
19:33:58 <dolio> I think having 5x the overhead for a 5-tuple might matter.
19:34:04 <dolio> Sometimes.
19:34:30 <ski> well, the big-oh space complexity is the same, no ? ;)
19:34:49 <copumpkin> edwardk: yeah, it feels like a bit of a waste anyway, unless they store something other than 1, 0, or -1 in there
19:34:51 <edwardk> because i seem to recall us getting the double <-> int conversion working
19:35:13 <copumpkin> hmm, maybe
19:35:19 <copumpkin> I can't remember what we succeeded with last time
19:35:33 <edwardk> i have it on my machine here, and that seems to be where we got stuck
19:35:33 <copumpkin> or failed :P
19:35:44 <Peaker> dolio: I wouldn't expect extra indirection in practice
19:35:47 <copumpkin> I'll write a couple of test cases for the issues I encountered, and submit bugs
19:35:52 <ski> (or s/oh/theta/, i suppose)
19:35:53 <copumpkin> should I just zip up the folder and send it to you?
19:35:58 <edwardk> foreign import prim "fixed_cmm_fixedAddzh" fixedAdd#  :: CRounding#  -> CPrecision# -> CSign# -> CExp# -> ByteArray#  -> CPrecision# -> CSign# -> CExp# -> ByteArray#  -> (# CPrecision#, CSign#, CExp#, ByteArray# #)
19:36:03 <edwardk> 9 args
19:36:04 <copumpkin> ah yeah
19:36:08 <copumpkin> that was probably it then :)
19:36:11 <Peaker> dolio: seems simple to inline the extra indirection away if the tuple type isn't paramateric -- and if it is, it can be specialized until it's no longer parameteric
19:36:28 <edwardk> and worse, the arg that is being corrupted is the bytearray
19:36:29 <Peaker> dolio: are curried functions significantly less efficient than a big Product type argument?
19:36:37 <copumpkin> yeah, I used the same order in mine
19:36:39 <Peaker> (Naively, I would expect them to be)
19:36:51 <copumpkin> and got big crash cause the bytearray was a 2-digit number :P
19:36:53 <edwardk> it probably could have recovered from any other order, just giving wrong signs or precisions or something
19:36:55 <edwardk> yeah
19:36:57 <copumpkin> printf to the rescue
19:37:16 <copumpkin> want me to make a tarball or put it on github or something?
19:37:21 <copumpkin> I didn't really "design" it at all
19:37:30 <copumpkin> it does the absolute bare minimum to work
19:37:40 <edwardk> tarball it and email it. i'll check it against what i have
19:37:44 <copumpkin> ok :)
19:38:23 <edwardk> curious what other operations will want more than 9 args
19:38:26 <edwardk> er more than 8
19:38:36 <ski> Peaker : i think it used to be the case in SML implementations that tuples functions were more efficient than curried ones (hence most of the functions in the SML Basic library are tupled) -- but nowadays that isn't the case anymore
19:38:40 <edwardk> it might make more sense to pack the precision and sign together
19:38:47 <edwardk> that way i don't entangle the two
19:38:52 <copumpkin> could be
19:38:59 <edwardk> just use one value for both
19:39:01 <dolio> That's why there's so much tupling in SML, allegedly.
19:39:07 <copumpkin> edwardk: another cheap hack
19:39:20 <copumpkin> would be to pass in a haskell tuple of some of those
19:39:20 <dolio> Oh, I skimmed too fast.
19:39:21 <Peaker> ski: yeah, in both cases (curried funcs and products) -- all the information is easily visible to the optimizer.. it doesn't have to do much to see it
19:39:35 <copumpkin> and do some really ugly unpacking of that to get what we want
19:39:35 <edwardk> yeah but then you have to dereference into it
19:39:38 <copumpkin> yeah
19:39:54 <copumpkin> the code for that is already in that evil atomicModifyMutVar
19:40:00 <edwardk> sign and prec is easy enough to split, especially if we assume 0 prec is silly
19:40:02 <Peaker> so I doubt an HList like encoding of products would incur an extra indirection  cost
19:40:02 <ski> dolio : i miss curried constructors (it's iring that i need extra brackets when constructing and escpecially when matching)
19:40:02 <copumpkin> okay
19:40:09 <copumpkin> anyway, emailed it :)
19:40:13 <copumpkin> I'm gonna reduce some bugz now
19:40:54 <dolio> I don't share your pain.
19:41:18 <ski> (`fun foo (Frob (a,x,y)) = ...' gets a little bit more tiring to read (and write) than `fun foo (Frob a x y) = ...')
19:41:32 <edwardk> trying to figure out the simplest way to shift or mask off the sign/prec pair
19:41:50 <edwardk> either lsb sign or to use the actual sign and abs it
19:41:57 <dolio> Oh wait. You miss curried constructors.
19:42:04 <dolio> Man I should go to bed or something.
19:42:20 <dolio> Yes, I like curried constructors better.
19:42:20 <ski> dolio : what were you thinking i said ? :)
19:42:31 <dolio> That you miss tupled constructors.
19:42:36 <ski> hehe
19:43:29 <dolio> Okasaki's book has a few cases where he gets to do something like 'foo (Frob t) = bar t', but I don't think that's worth it.
19:44:14 <edwardk> i do occasionally wish that i could convert between Foo a b c and (a,b,c) as a no-op some times, which leads me to build horrible newtypes of tuples
19:44:35 <edwardk> when the constructor isn't being exposed but some conversion to and from a tuple is
19:44:49 <edwardk> but i usually repent and give up the performance
19:45:11 <ski> dolio : in a few cases in Haskell, i explicitly tuple (constructors as well as functions), to be able to do that
19:45:41 <dolio> I could imagine it's useful sometimes. But not as the overarching convention of the language.
19:46:20 <ski> (just saying i would still use tupling in a few cases, if curried constructors were available)
19:46:40 <ski> (but i agree with you)
19:47:24 <dolio> So, if (a,b,c) = (a, (b, c)), then what is (a, (b, c)) being optimized into? A different (a, b, c) that still exists?
19:47:49 <ski> it's also a bit irritating how `type foo = Foo of int * int' and `type foo = Foo of (int * int)' is not equivalent, in O'Caml
19:48:05 <dolio> It's not?
19:48:21 <dolio> What's the difference?
19:48:46 <ski> the former declares a constructor `Foo' taking *two* (tupled) arguments, so you can't write `Foo t' (as expression or pattern)
19:49:05 <ski> the latter declares a constructor `Foo' taking a single argument, of tuple type, so `Foo t' is allowed
19:49:14 <dolio> Oh, so it's Scala.
19:50:18 <dolio> Scala has those three cases for functions in general.
19:50:21 <ski> in SML, however, (the corresponding declaration) generates a constructor that you can use as `Foo t'
19:50:29 <dolio> Tupled, curried, and functions taking a tuple.
19:50:53 <edwardk> copumpkin: we're in business -- the precision is at least 2, so using the sign of it is fine.
19:51:06 <copumpkin> sweet!
19:51:13 <copumpkin> I imagine the bug in GHC is easy to fix, too
19:51:14 <dolio> Also you can have a curried function with multiple tupled (not just taking a tuple) argument sections.
19:51:16 <copumpkin> well, the bugs
19:51:18 <copumpkin> since I have two
19:51:30 <edwardk> the other?
19:51:31 <Peaker> dolio: functions taking a tuple are not themselves Tupled or curried?
19:51:43 <ski> dolio : and can you have tupled results, as well ?
19:51:44 <copumpkin> edwardk: http://hackage.haskell.org/trac/ghc/ticket/5422 that was the really simple one I encountered
19:51:52 <copumpkin> I imagine they just make some flawed assumptions in the codegen
19:51:59 <edwardk> ah you've submitted it already
19:52:08 <dolio> ski: No, just tuples as results.
19:52:23 <copumpkin> edwardk: well, this isn't the silent corruption one
19:52:30 <edwardk> yeah
19:52:31 <copumpkin> I need more boilerplate for that
19:52:37 <copumpkin> just making that one now
19:52:37 <dolio> Peaker: No. f(x,y) calls a function with tupled arguments, f((x,y)) is how you call a function with a tuple as an argument.
19:53:09 <edwardk> working on building a better packed Fixed type, and then going to see how well I can dash out the core of the API
19:53:11 <Peaker> dolio: like in Python?
19:53:26 <dolio> Yeah, I guess Python is the same way.
19:53:38 <edwardk> then i can see how much of my old taylor model code makes sense =)
19:53:47 <Peaker> except curried functions are not used much in Python
19:53:50 <ski> dolio : hm .. i know Scheme allows both tupled arguments and results (the intension being that since those are not first-class, it's probably more efficient than to pass/return a list/record/vector -- also the emphasis is on the arguments/results, not on that list/record/vector)
19:53:54 <edwardk> well, after unlobotomizing the intervening layers
19:54:35 <dolio> Like python the curried function syntax is pretty terrible, too.
19:54:40 <dolio> f(x)(y)(z)
19:55:13 <Peaker> Complicating the language in the name of a small efficiency (that really can be solved with an optimizer) seems like a very bad choice
19:55:40 <Peaker> I think in CL at least, the tupling of results is mainly for "magic" purposes (allowing you to do a "partial pattern match", and extend the function with new, ignored results)
19:55:41 <dolio> Also sometimes you have implicit arguments, which always go at the end of a function....
19:55:53 <ski> well, in the case of lisps, for arguments, it's sortof built into the basic syntax
19:56:08 <dolio> But that means changing the function between explicitly taking the curried argument and having it return a function may act different.
19:56:55 <dolio> foo[A : C](x: A) is sugar for foo[A](x: A)(implicit C : C[A])
19:57:10 <ski> if you call `f' on `x' by `(f x)', you might as well allow also `(f x y)' .. though i suppose another choice would be that unsugaring to a curried call of `f' to `x' and then `y'
19:57:11 <dolio> Whereas foo[A : C]: A => ...
19:57:25 <dolio> Is sugar for foo[A](implicit C : C[A]) : A => ...
19:57:59 <dolio> So foo(x) on the first is applying to the A argument, and on the second is applying to the implicit argument.
19:58:04 <ski> Peaker : in R5RS Scheme, it is an error to ignore extra results
19:58:08 <dolio> So in the latter case, you need to write foo.apply(x).
19:58:19 <Peaker> ski: so there's really no need for a special thing there..
19:58:54 <ski> Peaker : the idea is to have more symmetry by allowing continuations to take multiple arguments, as well
19:59:22 <ski> Peaker : also the difference in emphasis -- on the arguments/results vs. on the structure containing them
20:00:31 <Peaker> sounds like it should be isomorphic, except with extra conceptual/kolmogorov burden
20:02:30 <edwardk> copumpkin: heh your code is substantially the same as what we had before, sans the one argument ;)
20:02:36 <copumpkin> lol
20:02:59 <copumpkin> I'm good at writing code from memory I guess :P
20:04:10 <edwardk> in fact it is almost character for character identical to the version before we started adding in random memsets out of paranoia
20:05:17 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/5423
20:05:20 <copumpkin> wow
20:05:21 <gwern> lambdabot: @join #lesswrong
20:05:24 <copumpkin> maybe I just hacked your computer
20:05:29 <copumpkin> and stole ur codez
20:05:46 <edwardk> heh, well, it was basically stuff we stole from integer =)
20:05:54 <copumpkin> hax!
20:08:57 <ski> dolio : is `C' the name of the optional argument there ?
20:09:25 <dolio> Yeah. I'm guessing that's how it desugars. I'm not actually sure.
20:09:51 <dolio> It's also the name of the 'class' you want A to belong to, if you will.
20:10:00 <dolio> On the right hand side of the :
20:10:15 <ski> i'm not sure what `foo[A](x: A)(implicit C : C[A])' nor `foo[A](implicit C : C[A]) : A => ...' means
20:10:35 <ski> it's `value : type' or `type : value' ?
20:10:47 <dolio> value : type
20:11:02 <dolio> [_] is a type argument.
20:11:02 <copumpkin> edwardk: well, I found the first bug in the GHC source...
20:11:05 <copumpkin> http://snapplr.com/geqy >_>
20:11:12 <edwardk> ?
20:11:14 <ski> so in `[A : C]', `C' is the default value for `A' ??
20:11:18 <ski> hm
20:11:46 * ski is probably confused
20:11:48 <dolio> No, if A has kind k, then C must have kind k -> * (effectively).
20:11:54 <edwardk> the 'nobody will ever need more than 10 registers' kinda bug?
20:11:57 <copumpkin> yeah
20:12:00 <copumpkin> gah
20:12:04 <edwardk> heh
20:12:11 <edwardk> which means it is probably systemic
20:12:23 <dolio> And then [A : C] desugars into the function taking an implicit C[A].
20:12:34 <copumpkin> well, we only need a couple more :)
20:12:42 <edwardk> but why didn't the panic happen?
20:12:44 <dolio> It would be like if you could say 'forall (n : Num). n -> n -> n' in Haskell.
20:12:52 <copumpkin> oh, the panic didn't happen for real MPFR code
20:12:54 <dolio> Instead of 'forall n. Num n => n -> n -> n'
20:13:00 <copumpkin> I don't actually need more than 10 registers
20:13:05 <ski> dolio : oh, so the type of the implict argument `C' in `[A : C]' will depend on the type `A' that is passed ?
20:13:11 <copumpkin> but when I was trying to reduce the other bug, I encountered this one
20:13:16 <edwardk> ah
20:13:38 <ski> dolio : ah, i see
20:13:59 <dolio> But the [A : C] syntax sticks the C[A] at the end of the argument lists.
20:14:03 <ddarius> Maybe Simon thought, "no one will need more than 10 registers" while Simon thought, "no one will need more than 8 registers."
20:14:22 <ski> dolio : but is this implicit argument implicitly propagated in the body, or can you explicitly refer to it ? (i suppose both might hold)
20:14:30 <dolio> So if you do 'foo[A : C](x: A): B' it sticks it after the (x: A)
20:14:37 <copumpkin> ddarius: that must be it
20:14:49 <dolio> But if you do 'foo[A : C]: A => B', it comes before the A argument.
20:14:52 <edwardk> hah
20:15:02 <copumpkin> oh god
20:15:42 <copumpkin> edwardk: systemic indeed: http://hpaste.org/50455
20:15:43 <ski> dolio : ok
20:15:57 <ski> dolio : btw, O'Caml also has implicit arguments, with the restriction that at least one non-labelled argument must follow
20:16:03 <copumpkin> and there's where our 8 issues arise, too
20:16:05 <dolio> ski: You can explicitly refer to it in the body. And it's eligible to be passed implicitly to other functions requiring implicit arguments.
20:16:09 <edwardk> heh
20:16:14 <dolio> And you may not have to apply it explicitly when calling the function.
20:16:23 <ddarius> So I was right.
20:19:12 <ski> dolio : so if you say `let test ?(x = 0) ?(y = 0) () ?(z = 0) () = (x, y, z)', then `test () : ?z:int -> unit -> int * int * int', while `test ~x:2 () ~z:3 () : int * int * int'
20:20:07 <ski> (and you can commute optional and labelled arguments)
20:20:50 <dolio> Ah. Scala has default arguments like that as well, as, I think, a separate facility.
20:21:03 <dolio> Also, ad-hoc overloading, which doesn't interact well with default arguments.
20:21:53 <edwardk> In STK_CHK_GEN in mpfr_cmm_get_d you meant R5_PTR?
20:21:56 <copumpkin> ddarius: as always!
20:22:04 <dolio> I think if you have foo(x: T, y: Int = 5) and foo(x: U), it will never be able to figure out which foo you're calling.
20:22:13 <dolio> Or something along those lines.
20:22:15 <ddarius> copumpkin: Depressingly.
20:22:22 <copumpkin> edwardk: yeah
20:22:39 <dolio> Whereas if you have foo(x: T, y: Int) foo(x: T) and foo(x: U), it's fine.
20:22:46 <edwardk> that was the one character difference between yours and mine ;)
20:23:01 <copumpkin> lol
20:23:14 <copumpkin> I actually wrote this all out
20:23:20 <copumpkin> didn't copy from the integer-gmp stuff
20:23:34 <ddarius> Great minds generate boilerplate alike.
20:23:37 <copumpkin> this code was the result of starting at several crashing iterations before it :)
20:23:40 <copumpkin> indeed!
20:23:40 <edwardk> hah
20:24:09 <copumpkin> did we realize we could use printf back then?
20:24:12 <edwardk> trying to figure out the right way in cmm to take absolute value and save sign
20:24:16 <edwardk> yeah
20:24:21 <copumpkin> ah, hm
20:24:32 <edwardk> i have sign*prec in one register
20:24:35 <edwardk> i need sign and prec
20:24:49 <edwardk> sign = 1 or -1
20:24:56 <copumpkin> they really use a whole word for that? :o
20:25:01 <edwardk> yeah
20:25:13 <copumpkin> I wonder why they didn't just make prec signed
20:25:16 <copumpkin> and use that
20:25:22 <edwardk> meh
20:25:42 <copumpkin> you may have to just write some if statements in your cmm
20:25:42 <ddarius> Then they'd have to do the abs.
20:25:51 <edwardk> yeah
20:26:08 <copumpkin> or there's probably some magic bit-twiddle you can do
20:26:11 <copumpkin> that does everything and then some
20:26:30 <copumpkin> edwardk: we might as well make the MPFRs just carry two Int# then
20:26:33 <ddarius> There's -always- some magic bit twiddle.
20:26:35 <copumpkin> save memory!
20:26:42 <edwardk> thats the plan
20:26:46 <copumpkin> cool :)
20:26:55 <edwardk> abs is easy
20:27:23 <edwardk> (v + mask) ^ mask for a suitable mask
20:27:58 <copumpkin> fancy
20:28:21 <copumpkin> Forget Math.abs() for time critical code. Version 1 is 2500% faster than Math.abs(), and the funky bitwise version 2 is again 20% faster than version 1.
20:28:44 <copumpkin> they use
20:28:44 <copumpkin> i = (x ^ (x >> 31)) - (x >> 31);
20:29:05 <ddarius> x >> 31 gets the sign.
20:29:19 <ddarius> Almost.
20:29:41 <ddarius> Unless these are 64-bit ints.
20:29:53 <edwardk> you can use -(v < 0)
20:30:16 <edwardk> er with some appropriate scaling
20:30:31 <ddarius> sar x, BIT_WIDTH
20:31:13 <edwardk> sign = 1 | (v >> 31)
20:31:28 <ddarius> Oh yeah, you wanted +/-1
20:34:36 <edwardk> ah good, i can get those to share the mask calculation
20:35:00 <ion> Magic bit twiddles are even more awesome with floats.
20:35:19 <ion> Something i did once. https://gist.github.com/290066
20:35:37 <edwardk> sv = sp >> 31; sign = 1 | sv; prec = (sp + sv) ^ sv
20:35:51 <edwardk> where 31 comes from appropriate multiplication and subtraction
20:37:45 <copumpkin> ion: hah :)
20:37:58 <ddarius> ion: Looks like it could use more bithackery.
20:53:06 <Peaker> hmm.. without hoogle-awareness in the IDE/editor for Haskell, it is slightly more mentally demanding to apply functions -- the namespace is huge.. As opposed to single-dispatch which has the advantage of associating a small namespace of stuff you'll likely use (and do most of the time)
20:57:34 <copumpkin> tru dat
20:59:07 <Peaker> however.. with hoogle-aware editing, we could have awesome completions giving us our most-frequently-used functions that match the types we need..
20:59:53 <drhodes> this is something ipython/bpython . <tab> method complete makes learning libraries a breeze.
21:00:41 <mustelo> is there any way to get some sort of agda-like "show me the type of this hole" functionality?
21:02:04 <copumpkin> I use implicit parameters and the resulting type errors to get similar behavior
21:02:21 <copumpkin> you could use any type error
21:02:25 <copumpkin> but I find these more legible
21:02:31 <copumpkin> ;)
21:02:40 <parcs> sometimes the type error doesn't give you a type
21:02:50 <parcs> `No instance for (Num ())`
21:04:02 <shachaf> The type errors that you get with type classes are very annoying. I wonder if there's a reasonable thing to do about them.
21:04:15 <shachaf> > 'a' && True
21:04:16 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
21:04:16 <lambdabot>         against inferred type ...
21:04:17 <shachaf> > 1 && True
21:04:18 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
21:04:19 <lambdabot>    arising from the literal `1'...
21:04:42 <Peaker> :t (&&)
21:04:43 <lambdabot> Bool -> Bool -> Bool
21:05:01 <parcs> > negate ?x
21:05:01 <lambdabot>   mueval-core: internal error: PAP object entered!
21:05:02 <lambdabot>      (GHC version 6.12.3 f...
21:05:05 <copumpkin> nice
21:05:11 <parcs> well anyway "Unbound implicit parameter (?x::a0)"
21:05:17 <parcs> quite useful :P
21:05:22 <copumpkin> no constraint on a0?
21:05:32 <parcs> nope
21:05:40 <Peaker> shachaf: getting rid of implicit "fromInteger" could make things uglier but type errors more legible
21:05:52 <Peaker> well, not always
21:09:27 <Peaker> hmm..  if GHC has:   fromIntegral 5  &&  True     it tries to unify  Bool   with the result type of fromIntegral (say, some "Num t => t") -- instead of saying "no instance", would it be better/less confusing to say:  "Expected Bool, found: Num t => t   from use of  'fromIntegral ...'    Possible solution: Add an instance of Num to Bool?
21:12:44 <copumpkin> yeah
21:13:56 <ski> Peaker : would that also apply to `foo :: Num t => t -> Bool; foo x = x && True' ?
21:14:46 * ski thinks it should not, but wonders what Peaker meant more precisely
21:15:28 <parcs> :t let foo :: Num t => t -> Bool; foo x = x && True in foo
21:15:29 <lambdabot>     Couldn't match expected type `Bool' against inferred type `t'
21:15:29 <lambdabot>       `t' is a rigid type variable bound by
21:15:29 <lambdabot>           the type signature for `foo' at <interactive>:1:15
21:15:34 <parcs> haha
21:16:16 <ski> hm, make that
21:16:17 <shachaf> That error is even worse.
21:16:18 <ski> @type let foo x = x && True where _ = x + 0 in foo
21:16:18 <lambdabot>     No instance for (Num Bool)
21:16:18 <lambdabot>       arising from the literal `0' at <interactive>:1:36
21:16:18 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
21:17:29 <ski> shachaf : what would be better to say in that (the "rigid type variable") case, in your opinion ?
21:18:14 <shachaf> ski: I'm not sure, but mentioning the Num constraint would seem to be helpful, at least.
21:18:30 <Peaker> ski: I also wonder what I meant more precisely :-)
21:20:05 <dolio> I'm not sure how you can really do much better than what it does.
21:20:08 <ski> shachaf : well, i suppose in that case the `Num' constraint is irrelevant
21:20:15 <dolio> The error really is that there's no Num Bool instance.
21:20:24 <ski> (but it could mention it as well, to give more context to the error, yes)
21:21:00 <ski> @type let foo :: t -> Bool; foo x = x && True in foo -- see, same error without `Num'
21:21:01 <lambdabot>     Couldn't match expected type `Bool' against inferred type `t'
21:21:01 <lambdabot>       `t' is a rigid type variable bound by
21:21:01 <lambdabot>           the type signature for `foo' at <interactive>:1:11
21:21:32 <Peaker> dolio: hmm.. that's one step removed from the source of the error:  failed to unify  Num t => t,  and Bool
21:22:34 <ski> well, unification of `Num t => t' and `Bool' succeeds, adding the constraint `Num Bool', which here is unresolvable
21:22:44 <Peaker> maybe unification should fail?
21:22:52 <dolio> Why?
21:23:00 <dolio> What if there's a Num Bool instance?
21:23:07 <Peaker> then it should not fail :)
21:23:09 <ski> maybe it could do that as an optimization, i'm not sure
21:23:10 <kniu> @hoogle zipM
21:23:10 <lambdabot> Control.Monad mapAndUnzipM :: Monad m => (a -> m (b, c)) -> [a] -> m ([b], [c])
21:23:25 <kniu> @hoogle foldM
21:23:25 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
21:23:25 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
21:23:25 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
21:23:31 <kniu> @hoogle foldlM
21:23:31 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
21:24:08 <ski> @type liftM2 zip
21:24:09 <lambdabot> forall a b (m :: * -> *). (Monad m) => m [a] -> m [b] -> m [(a, b)]
21:24:17 <Peaker> I think the error: "Expected Bool (piece of code forcing it to be Bool), found "Num t => t" (piece of code forcing the Num constraint),  is perhaps more legible than a missing instance error"
21:24:21 <ski> kniu : what were you looking for ?
21:24:39 <ski> Peaker : yeah, in general we want type error slicing
21:24:57 <kniu> foldlM
21:25:06 <kniu> over Data.Seq
21:26:53 <Peaker> I sometimes comment out large sections of code, fill in some "undefined"s to see if it compiles
21:26:59 <Peaker> binary-searching a type-error :-P
21:27:45 <mustelo> edwardk, is there any chance you could build your haddocks for trifecta with links to source next time 'round?
21:28:11 <kniu> is there a "Composable" typeclass?
21:28:18 <Peaker> kniu: what's that?
21:28:22 <kniu> @hoogle (.)
21:28:22 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
21:28:23 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
21:28:23 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
21:28:47 <kniu> hm
21:28:50 <kniu> nevermind
21:29:01 <ski> Peaker : you know what type error slicing is, yes ?
21:29:21 <ski> kniu : also `Control.Arrow'
21:29:44 <kniu> probably overkill
21:32:00 <ski> Peaker : type error slicing reports all and only those locations in the source which contributed to the type error (at least one of the locations must be changed to resolve the error)
21:32:50 <Peaker> ski: ah, that would be nice, especially with infinite type errors
21:33:30 <ski> (Peaker : though it might turn out that one of those locations might e.g. be an incorrect type-signature such that when you correct it, some new locations will be reported, in which the actual logical error (apart from the signature) were -- in any case, type error slicing gives you all "roots" to start searching from, so to speak)
21:35:01 <Peaker> yeah and if type-inference+checking was done on-the-fly as you edit code, it could be differential -- and even more helpful
21:35:16 <ski> Peaker : <http://www.macs.hw.ac.uk/~sf47/cgi-bin/slicer/> has info and a demo of a type error slicer for SML
21:35:26 <Peaker> (assuming the code's ASG is valid at all times, at least)
21:35:27 <Saizan> ski: do you know of a version of that for constraint systems in general? to explain to the user why there's no solution
21:35:42 * Maxdamantus would imagine it'd be fairly annoying.
21:35:48 <ski> (/me would possibly replace "differential" with "incremental", there)
21:36:08 <Maxdamantus> You'd get distracted as you're concentrating on expressing some logc.
21:36:17 <zzo38> Can I make a Haskell program that the main function is in C?
21:36:33 <Maxdamantus> With GHC, yes.
21:36:39 <ski> Saizan : sorry, i dunno
21:37:34 <Maxdamantus> I saw it somewhere, and it involves explicit setting up of stuff.
21:37:48 <ski> (for expert systems there's often a feature to explain how the answer was derived (basically a call-trace, omitting failed search branches), maybe also being able to explain in a nice way why a query failed)
21:37:50 <Maxdamantus> Why would you want to do it, anyway?
21:38:15 <zzo38> How would I do it? And what types can I use with it?
21:38:16 <Maxdamantus> You could probably just compile the C program normally and have Haskell call it.
21:38:25 <Maxdamantus> (call main)
21:38:55 <ski> Maxdamantus : you'd get distracted by what ? type error slicing ?
21:39:10 <Saizan> zzo38: you should look at FFI
21:39:14 <Saizan> @where FFI
21:39:15 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
21:39:36 <ski> zzo38 : iirc, it's possible to from C call functions which set up the GHC runtime, and then call into Haskell. at least istr it is possible with Hugs
21:39:38 <zzo38> I am looking at FFI information already
21:39:49 * ski has never tried it, though
21:40:11 <Saizan> zzo38: http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
21:42:13 <Maxdamantus> ski: yes.
21:42:26 <zzo38> Saizan: Thanks. However, how can I use my own Haskell types with the C codes? Can this be done?
21:42:41 <ski> Maxdamantus : what would you prefer ?
21:43:31 <Maxdamantus> ski: having the programmer thinking more directly, not dictated by an alerting UI.
21:43:38 <ski> Maxdamantus : in the current situation, you get an error reporting *some* location where the error manifests (i.e. the location at which the type error was detected, which might differ between different type checking/inferring algorithms)
21:44:04 <ski> i'm not sure what you mean by "thinking more directly"
21:44:14 <Maxdamantus> Oh, maybe I've misunderstood what this is about.
21:44:47 <Maxdamantus> I'm thinking about UIs that try to tell you you've done something wrong as you're doing it.
21:45:17 <foocraft> Maxdamantus: To me, that sounds impossible, anyway.
21:45:46 <Maxdamantus> Probably, in Haskell.
21:45:58 <zzo38> It says I can use, Ptr a, FunPtr a, StablePtr a, but I don't know exactly what those mean
21:45:59 <foocraft> In anything.
21:46:08 <foocraft> How can you judge that it's wrong, when it's not done?
21:46:39 <Maxdamantus> If you're writing out statements (eg, in Java), it's easy to do notice a type error before all of the statements are written.
21:47:03 <foocraft> Oh okay, so for revery statement.
21:47:12 <foocraft> Not within a statement.
21:47:20 <foocraft> Gotcha, Maxdamantus.
21:47:30 <Maxdamantus> It might get tricky when the programmer is modifying a statement.
21:47:54 <foocraft> I don't think a statement should be long enough for this feature to show its value, Maxdamantus.
21:47:56 <Maxdamantus> (because you go into the middle of one, and the statement can repetitively become complete and incomplete (syntactically))
21:49:05 <Maxdamantus> IDEs already tend to do random stuff in statements.
21:49:27 <Maxdamantus> er, expressions*
21:50:53 <Peaker> foocraft: you can already detect a type error within a statement -- which can manifest itself as a "hole" which is a type convertor you must attend to for it to type-check (but you can defer that if it distracts you)
21:51:14 <Peaker> (technically, the hole makes it type-check all the time, but it won't run successfully)
21:52:25 <foocraft> Are we all assuming the same tool here?
21:52:42 <foocraft> "(but you can defer that if it distracts you)" is what's confusing me here.
21:53:03 <zzo38> If I have a function in C of   void xyz(void);   then is this a proper Haskell code?    foreign import ccall unsafe "xyz" xyzForeign :: ();   Sorry I don't know for sure
21:53:13 <ski> zzo38 : iirc, `Ptr a' is translated to `void *' and `FunPtr a' to `void (*)()' -- i think this should be specified in the FFI somewhere
21:53:22 <dolio> You don't always need whole expressions to find type errors.
21:53:23 <stevenwilliamfuc> hi
21:54:07 <zzo38> The function "xyz" will not do anything that changes any external state, but might be needed to yield to the operating system in some cases.
21:54:34 <dolio> If you have 'show ? + 1' the type of ? is irrelevant.
21:54:48 <zzo38> ski: And what is StablePtr a? And what do Ptr a and so on do, though?
21:54:53 <foocraft> Ah I see, dolio.
21:55:12 <ski> zzo38 : `foreign import ccall unsafe "xyz" xyzForeign :: IO ()' i think
21:55:23 <dolio> And if you build up your expressions incrementally leaving holes for things of arbitrary type....
21:55:52 <dolio> Then you could have {  } + 1, and trying to insert show ? into the hole would fail with a type error, preventing you from doing something wrong, for instance.
21:55:59 <dolio> Without the entire expression being built yet.
21:56:21 <zzo38> ski: Is it correct? Should any pragmas be needed?
21:57:35 <Peaker> dolio: it could also let you put the show in, but then you get { { ? } show } + 1     where { ? } is some unknown convertor that must be applied there
21:58:01 <dolio> Peaker: I'd rather it not stick things like that in for me.
21:58:17 <dolio> If I want to do that, I want it to make me write '? show'.
21:58:42 <Peaker> well, that ? is really just sort of a "type-error" represented as a "convertor hole" applied to show
21:58:57 <Peaker> but the UI can't outright refuse to put show there
21:59:02 <Peaker> that's be too restrictive
21:59:06 <dolio> Sure it can.
21:59:16 <dolio> That's exactly what Agda does, for instance.
21:59:17 <Peaker> what if you intend to replace the + 1?
21:59:27 <dolio> Then you should do that first.
21:59:56 <Peaker> well, that may be a win or a lose, having the UI Force the edit order on you
22:00:52 <ski> zzo38 : i think `StablePtr a' also gets translated to `void *' (but you'll probably have to call special routines to access the contents)
22:01:27 <ski> zzo38 : what does "will not do anything that changes any external state" mean more exactly ?
22:02:08 <ski> zzo38 : is it important to call that before or after doing some other operation, e.g. ?
22:02:24 <zzo38> ski: No.
22:03:05 <ski> then why do you need to call it ?
22:03:06 <zzo38> ski: It does absolutely nothing other than ensure the operating system doesn't hang.
22:03:35 * ski wonders how it can detect the OS not hanging
22:04:02 <zzo38> ski: I don't know how it does that.
22:04:08 <ski> surely if the OS has hanged, you're already screwed, and if it hasn't, what's there to check ?
22:05:18 <copumpkin> ensure might mean
22:05:22 <copumpkin> ping something to remind it it's alive
22:05:26 <copumpkin> not check
22:05:56 <ski> Peaker : you could always manually change it to `? show' first, then doing the changes in whatever order you prefer
22:06:18 <copumpkin> say your OS has a magic feature that means it hangs if you don't recite 4 8 15 16 23 42 every few minutes
22:06:28 <copumpkin> then zzo38's function recites those numbers to the OS
22:06:29 <ski> copumpkin : hm, then it certainly has a side-effect, so should be in `IO'
22:06:37 <copumpkin> yep :)
22:06:41 <ski> (so that it is timed correctly)
22:25:15 <ddarius> copumpkin: http://en.wikipedia.org/wiki/Watchdog_timer
22:26:42 <zzo38> OK I could put it in the monad, except I need to use my own monad rather than the standard IO monad because this program is not based on the standard IO monad. So that it is timed correctly.
22:42:35 <ski> zzo38 : are you sure your monad should not be based on the `IO' monad ?
22:53:10 <mustelo> edwardk, are you accepting trifecta documentation bug reports?
22:53:29 <ivanm> mustelo: dunno, but he probably accepts patches ;)
22:53:54 <mustelo> I'm happy to write it up if I get the go ahead
22:54:07 <ivanm> mustelo: he's said he accepts patches before
22:54:14 <mustelo> sounds good
22:54:46 <mustelo> although I think doc bug report #1 is "lack of tutorial"
22:55:03 <ddarius> mustelo: You do realize that the library is about a month old?
22:55:04 <ivanm> mustelo: no, it's "lack of documentation"
22:55:11 <ivanm> first get good haddock docs, _then_, tutorial
22:55:31 <mustelo> ddarius, I didn't say my expectations were reasonable :)
23:23:25 <edwardk> mustelo: i can't generate haddocks with source links. i can't build hscolour on my mac
23:23:55 <mustelo> ah well, I already built them locally anways :)
23:24:17 <edwardk> and yeah the project itself is about 2 weeks old =)
23:24:32 <mustelo> as I've been reminded
23:24:47 <edwardk> i will happily merge in documentation patches
23:25:21 <mustelo> sounds good, I have a couple small things now, would you rather I collect a larger set first?
23:25:37 <edwardk> you can send them in piecemeal
23:25:41 <edwardk> its not hard to accept on github
23:26:00 <edwardk> i don't go out of my way to reduce the patch spam i send out
23:27:05 <mustelo> cool, so is github fork+pull request your preferred method?
23:27:15 <edwardk> yeah
23:36:56 <mustelo> okay, small one coming your way
23:38:43 <NihilistDandy> Any particularly cromulent books on the lambda calculus that someone would like to recommend?
23:47:10 * hackagebot css-text 0.1.0.1 - CSS parser and renderer.  http://hackage.haskell.org/package/css-text-0.1.0.1 (MichaelSnoyman)
23:52:10 * hackagebot authenticate 0.9.3.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.9.3.1 (MichaelSnoyman)
23:52:12 * hackagebot cookie 0.3.0.1 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.3.0.1 (MichaelSnoyman)
23:57:10 * hackagebot data-object 0.3.1.7 - Represent hierachichal structures, called objects in JSON.  http://hackage.haskell.org/package/data-object-0.3.1.7 (MichaelSnoyman)
23:57:12 * hackagebot hebrew-time 0.1.0.1 - Hebrew dates and prayer times.  http://hackage.haskell.org/package/hebrew-time-0.1.0.1 (MichaelSnoyman)
