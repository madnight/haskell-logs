00:00:31 <bfig> i'm on an automated learning methods class, and they asked us to perform a stupid experiment on conceptual learning
00:01:41 <bfig> ie, grind our way to a program with some conditions, etc. So they ask us to find the average number of tries it takes to teach some given concept, and i figured why the hell not compute it theoretically, assuming we're being given independent, completely random experiences
00:01:43 <permagreen> Do you need to write using just standard haskell, or could you use a library, because there has be a couple good matrix libraries floating around
00:01:57 <RenJuan> unless the course dictates it, or you're already familiar with it probably not a good idea to do it in haskell
00:02:07 <bfig> i dont' need to do it, i'm just having fun
00:02:22 <bfig> i'm also taking a haskell class so i figured why the hell not... :p
00:02:31 <RenJuan> ah
00:02:51 <bfig> permagreen, if you tell me how to get them to use by ghci that'd be great
00:03:06 <RenJuan> anyway it's the data that drives what you talked about
00:03:17 <bfig> what do you mean?
00:04:24 <bfig> i just spent like an hour building an algorithm to give me a very compact transition matrix in haskell, now i'm not leaving till i can test it >_>
00:05:22 <bfig> i just need to build a matrix with coefficients (i,j), then map (map computeMatrixCoordinate) and use what i already wrote.
00:05:31 <bfig> permagreen, which libraries can i use_
00:07:29 <McManiaC> Phyx-: sup?
00:08:50 <Rotsor> bfig, why not start with some naive representation (like [[a]], or (Integer -> Integer -> a))?
00:09:39 <bfig> mmm i guess.
00:09:45 <permagreen> bfig: Sorry, I can't think of one off the top of my head. I'm sure there's one out there somewhere though, just a google search away
00:10:13 <elliott> bfig: hmatrix?
00:10:23 <elliott> It's based on LAPACK and that sort of stuff.
00:10:29 <elliott> Must be great, right?
00:10:30 <elliott> http://hackage.haskell.org/package/hmatrix
00:12:10 <bfig> elliott, how do i install this?
00:12:32 <elliott> bfig: cabal install hmatrix
00:12:58 <bfig> don't have cabal apparently... is that from ghci?
00:13:16 <elliott> That's cabal-install. You probably want to install the Haskell Platform.
00:13:18 <bfig> nevermind didn't double tab
00:13:27 <elliott> http://hackage.haskell.org/platform/
00:13:41 <bfig> i have ghc, what else does that have?
00:14:01 <elliott> bfig: A set of standard libraries, and cabal-install.
00:14:20 <bfig> cool. downloaded cabal, updating now...
00:26:43 <bfig> elliott, cool lib. thanks for the link
00:27:01 <elliott> bfig: np :)
00:30:11 <nyingen> could 'uncurry' be defined as uncurry f (a,b) = f a b ?
00:30:56 <elliott> :t uncurry
00:30:57 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
00:31:02 <elliott> Yes.
00:31:05 <bfig> elliott, it says it can't link gsl, i need some -dev packages
00:31:06 <elliott> (I mixed up curry and uncurry mentally there...)
00:31:11 <elliott> bfig: unsurprising
00:31:17 <bfig> i can't find gsl-dev on the ubuntu repo, any ideas?
00:31:22 <nyingen> is there any particular reason it's not defined that way in the standard lib?
00:31:29 <kizzx2> what's the best way to produce [1,2,3,4…] from [1,3…] and [2,4…] ?
00:32:35 <bfig> kizzx2,  func (x:xs) (y:ys) = x:y: func ys xs
00:32:54 <bfig> don't know about 'best' way, that will work i think
00:32:57 <elliott> bfig: http://www.google.co.uk/search?q=gsl+ubuntu → https://launchpad.net/ubuntu/+source/gsl → libgsl0-dev
00:33:07 <kizzx2> bfig: that was elegant, thanks
00:33:20 <elliott> kizzx2: use zipWith.
00:33:35 <Veinor> elliott: what's your zip function?
00:33:43 <elliott> > zipWith (\x y -> [x,y]) [1,3..] [2,4..]
00:33:44 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21...
00:33:49 <elliott> > concat $ zipWith (\x y -> [x,y]) [1,3..] [2,4..]
00:33:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
00:33:54 <kizzx2> o cool
00:34:02 <Veinor> ah
00:34:05 <elliott> Kind of ugly though, but at least it's not explicit recursion.
00:34:28 <Veinor> it'll also get base cases right
00:34:30 <kizzx2> is there anything wrong with explicit recursion?
00:34:42 <ion> Not *that* ugly. The list monad works very similarly.
00:34:45 <kizzx2>  not being easily benefited by deforestation?
00:34:52 <elliott> kizzx2: Lower level of abstraction. And perhaps less chance of optimisation, yes.
00:35:01 <Veinor> f = (join .) . zipWith (\x y -> [x,y])
00:35:08 <elliott> ion: Well, the (\x y -> [x,y]) part is the ugly part.
00:35:12 <elliott> ?pl \x y -> x:y:[]
00:35:13 <lambdabot> (. return) . (:)
00:35:17 <kizzx2> lol
00:35:18 <elliott> (. pure) . (:)
00:35:22 <elliott> Elegance mastered.
00:35:25 <ion> :-D
00:35:40 <elliott> > do return 9; return 0 :: [Int]
00:35:41 <lambdabot>   [0]
00:35:53 <elliott> > pure 9 `mappend` pure 0 :: [Int]
00:35:54 <lambdabot>   [9,0]
00:35:58 <elliott> ?pl (\x y  -> pure x `mappend` pure y)
00:35:59 <lambdabot> (. pure) . mappend . pure
00:36:17 <elliott> > ((join .) . zipWith ((. pure) . mappend . pure)) [1,3..] [2,4..]
00:36:19 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
00:36:22 <ion> > (mappend `on` pure) 1 2
00:36:23 <elliott> Veinor: What have you done.
00:36:23 <lambdabot>   No instance for (GHC.Show.Show (f a))
00:36:23 <lambdabot>    arising from a use of `M8793209848...
00:36:27 <ion> > (mappend `on` pure) 1 2 :: [Integer]
00:36:28 <lambdabot>   [1,2]
00:36:33 <elliott> ion: Hey, nice
00:36:34 <Veinor> oh god D:
00:36:38 <kizzx2> woot
00:36:39 <liyang> ?t mappend `on` pure
00:36:39 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:36:53 <liyang> :t mappend `on` pure
00:36:54 <lambdabot> forall a (f :: * -> *). (Monoid (f a), Applicative f) => a -> a -> f a
00:36:55 <elliott> join :. zipWith (mappend `on` pure)
00:36:56 <elliott> erm
00:36:58 <elliott> join .: zipWith (mappend `on` pure)
00:37:01 <liyang> I always get that raound. ¬_¬
00:37:02 <elliott> Wait, how do we generalise zipWith???
00:37:06 <elliott> Can we get it on Foldable?
00:37:13 <liyang> *wrong ^^;;
00:37:13 <elliott> IT'S TOO READABLE
00:37:21 <Veinor> haha
00:37:53 <elliott> hmph, no zips in data.foldable... I guess the only thing to do is to write it with foldr
00:39:38 <augur> bluegene q with built in transactional memory
00:39:41 <augur> crazy
00:41:34 <auastro> hi all!
00:41:36 <kizzx2> > take 10 $ zipWith (mappend `on`pure) [1,3..] [2,4..]
00:41:37 <lambdabot>   No instance for (Data.Monoid.Monoid (f a))
00:41:37 <lambdabot>    arising from a use of `e_1101...
00:41:52 <auastro> quick question for the hive mind
00:42:00 <kizzx2> > take 10 $ zipWith ((++) `on` return) [1,3..] [2,4..]
00:42:01 <lambdabot>   No instance for (Data.Monoid.Monoid (m a))
00:42:01 <lambdabot>    arising from a use of `e_1101...
00:42:40 <auastro> I have a ADT with a function in it and I want to derive a Show instance what's the best way to do this?
00:43:00 <elliott> auastro: make a Show instance for the function type.
00:43:01 <mustelo> auastro, you'll have to write it yourself
00:43:04 <elliott> or that.
00:43:09 <auastro> ok
00:43:17 <mustelo> those are the two options, yeah :)
00:43:25 <kizzx2> -XStandaloneDeriving
00:43:37 <auastro> ok
00:43:59 <auastro> instance Show (Value -> Value) where
00:44:00 <auastro>   show _ = "Primitive Function"
00:44:00 <auastro> Doesn't seem to have a good time
00:44:21 <auastro> (I'm writing an interpreter)
00:44:38 <elliott> Something like <primitive> is nicer.
00:44:47 <elliott> Or it'll show, e.g.
00:44:52 <elliott> data T = C (Value -> Value) Int
00:44:52 <elliott> as
00:44:56 <elliott> "C Primitive Function 9"
00:45:26 <kizzx2> auastro: maybe you need -FlexibleInstances?
00:45:36 <mustelo> auastro, you might need Flex... yeah
00:45:42 <auastro> yes the compiler mentions that
00:45:57 <kizzx2> auastro:  in general it's a good idea to heed the compiler :P
00:45:59 <auastro> I didn't want to enable it blindly because I don't quite know what it means
00:46:20 <bfig> how can i build a list with pairs [(0,0),(0,1)... (0,19),(1,0)...(1,19).. (19,19)] ?
00:46:27 <mustelo> auastro, it's generally considered one of the less harmful extensions, I think
00:46:29 <kizzx2> basically because flexible instances can lead the compiler to diverge
00:46:47 <kizzx2> what that means is, the worst is that your compiler crashes
00:46:57 <elliott> kizzx2: Uhh... no.
00:47:02 <elliott> Complete FUD.
00:47:08 <auastro> [(x, y) | x <- [0..19], y <- [0..19]]
00:47:24 <elliott> auastro: Basically, your instance is ((->) Value Value).
00:47:31 <bfig> ty auastro
00:47:35 <elliott> auastro: By default, only instances of the form (T a b c ...) where a, b, c are _type variables_ are allowed.
00:47:42 <elliott> (Distinct type variables)
00:47:49 <elliott> So ((->) a b) is allowed, but ((->) Value Value) isn't.
00:47:54 <elliott> It's basically harmless to enable and it's what you want here.
00:48:36 <auastro> I see
00:48:53 <auastro> I'm quite hazy on how that could lead to divergence
00:48:57 <elliott> It can't.
00:49:06 <elliott> kizzx2 is misinformed. Perhaps they are thinking of UndecidableInstances, which also cannot cause that.
00:49:27 <auastro> ok I see, how come flexible instances aren't pure haskell?
00:49:34 <elliott> Historical reasons. :-)
00:49:55 <kmc> they wanted the language to be easy to implement, to some degree
00:50:01 <elliott> It makes compiler implementation slightly more difficult because you have to check a bit more.
00:50:05 <auastro> gotcha, they seem very useful, even necessary to an extent
00:50:06 <kizzx2> i thought that's what it's meant by this page http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleInstances
00:50:08 <elliott> But Haskell is not exactly easy to implement nowadays.
00:50:22 <kmc> taken together, the typeclass restrictions give you a very straightforward way to find the correct instance for a type
00:50:23 <elliott> kizzx2: where do you see a line about diverging compilers or crashes on that page?
00:50:27 <dolio> I don't think Haskell was ever easy to implement.
00:50:28 <kmc> with all the extensions it is harder
00:50:38 <auastro> Must be much harder
00:50:39 <elliott> dolio: Maybe when it was called Miranda.
00:50:48 <elliott> :-)
00:50:52 <elliott> Sorry, do I need some (TM)s in there?
00:50:54 <dolio> Even parsing it is so terrible that nobody actually does it correctly, according to the spec.
00:50:55 <kmc> type inference for mutual polymorphic recursion :(
00:51:07 <auastro> I've implemented a Hindley Milner type inference engine in an afternoon
00:51:07 <kizzx2> "The distinctness requirement prohibits non-terminating instances like"
00:51:11 <kmc> dolio, do you refer to the "parse error" rule for layout?
00:51:13 <kmc> or something else?
00:51:35 <dolio> Yeah.
00:51:43 <auastro> but I only have a very tenuous grasp on most of the extensions.
00:51:43 <kmc> yeah that rule is pretty bad
00:51:46 <dolio> Also the way you have to handle infix operators is awful.
00:51:51 <kmc> when i first saw it i was like... "really?"
00:51:56 <kmc> how's that dolio?
00:52:03 <dolio> Locally declared fixities and whatnot.
00:52:07 <kmc> eww
00:52:17 <kmc> arguably it's an oversight that those are allowed
00:52:25 <dolio> So GHC just parses everything with some default precedence, and fixes up the parse tree afterwards.
00:52:26 <kmc> did the committee ever weigh in on that?
00:52:34 <auastro> I didn't eve know those existed
00:52:42 * kmc originalism
00:52:51 <elliott> Local fixities are awesome.
00:52:53 <elliott> :-)
00:53:00 <dolio> I thought they were intentional.
00:53:06 <auastro> I'll make sure to use them on my next project
00:53:08 <dolio> But I don't really know.
00:53:12 <kizzx2> elliott: i didn't really go and read every line but it seems like that's what the page is talking about "Tickets
00:53:13 <kizzx2> http://hackage.haskell.org/trac/haskell-prime/ticket/32
00:53:13 <kizzx2> add FlexibleInstances
00:53:13 <kizzx2> Local termination conditions
00:53:14 <kizzx2> The idea here is to impose restrictions on the form of each instance in isolation, such that context reduction will be guaranteed to terminate.
00:53:14 <kizzx2> "
00:53:36 <ion> > take 10 . join $ zipWith ((++) `on` pure) [1,3..] [2,4..]  -- kizzx2
00:53:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
00:54:48 <auastro> Thanks for the help guys btw
00:54:53 <ion> You forgot the join/concat.
00:55:06 <auastro> better get back to hacking, tx again
00:55:23 <kizzx2> elliott: there is also this thing on the Hugs page http://cvs.haskell.org/Hugs/pages/users_guide/class-extensions.html
00:55:28 <kizzx2> elliott:  This relaxation, together with the relaxation of contexts mentioned above, makes the checking of constraints undecidable in general (because you can now code arbitrary Prolog programs using instances).
00:56:33 <elliott> "together with"
00:56:39 <elliott> kizzx2: But why are you reading Hugs pages? Hugs is ancient.
00:57:04 <kizzx2> elliott: i guess it doesnt make its theories  ancient?
00:57:13 <elliott> Well, sure.
00:57:17 <elliott> But they're not good references.
00:57:22 <elliott> There's been a new standard since then.
00:57:38 <kizzx2> well yeah, i was actually wondering the same problem as auastro some time ago
00:57:49 <kizzx2> and unfortunately Haskell resources are not plentiful
00:57:55 <elliott> They aren't?
00:58:03 <kizzx2> that's where it landed in the first page in a particular google search and i read it
00:58:12 <elliott> But anyway, undecidable just means that it _could_ take forever, but both Hugs (IIRC) and GHC provide options to set the limit which is always adhered to.
00:58:17 <elliott> So the compiler will still never go wrong.
00:58:30 <auastro> elliott: much less than ruby / Java / Python
00:58:48 <kizzx2> oh yeah, i was a bit exaggerating about the "crashing" bit in an attempt to make it sound more simple
00:59:20 <NihilistDandy> poor kmc
00:59:27 <kmc> can someone PM me when it's over?
00:59:32 <NihilistDandy> The all-caps were just hyperbolic, I promise
00:59:37 <NihilistDandy> It's actually calmed down
00:59:48 <NihilistDandy> He's still dumb, just less confrontational
01:00:01 <elliott> NihilistDandy: wat
01:00:11 <NihilistDandy> elliott: #haskell-blah
01:00:12 <kmc> awkward
01:00:13 <dolio> She.
01:00:13 <kmc> so, how about those Turing machines, eh
01:00:18 <kmc> never know when they're going to stop
01:00:26 <NihilistDandy> dolio: Oh. Even more lol.
01:00:35 <NihilistDandy> kmc: i c wat u did
01:00:55 <dolio> I just use my quantum brain to tell if they're going to stop.
01:00:58 <dolio> Or my perspex machine.
01:01:14 <kmc> does it have a perspex window on the side
01:02:35 <dolio> Or the pi calculus.
01:02:41 <dolio> If you're in on the new hotness.
01:03:21 <kmc> pi calculus can't compare to Javascript
01:03:27 <elliott> perspex calculus
01:03:27 <kmc> Javascript has closures!!!1!!111
01:04:13 <companion_cube> :D
01:04:32 <companion_cube> pi calculus is webscale, on the other hand
01:04:38 <auastro> lol
01:05:37 <NihilistDandy> Pi calculus suffers from impotence mismatch
01:06:08 <ion> Tau calculus is pi calculus 2.0.
01:06:17 <dolio> Zing.
01:07:39 <kmc> zomg
01:16:12 <elliott> ion: haha wow
01:18:32 <shachaf> kmc: You may be wise in leaving that channel.
01:21:58 <kmc> permanently?
01:22:06 <kmc> i mean, i would get a lot more work done
01:24:15 <jrockway> is there a way to find the common prefix in two bytestrings without copying and without directly touching the internals?
01:24:34 <dolio> You don't have any work to do, though.
01:24:50 <shachaf> I meant temporarily, but who knows.
01:25:18 <kmc> length . takeWhile (uncurry (==)) . BS.zip  -- jrockway?
01:25:28 <kmc> it would be nice if that fuses and doesn't do any list allocation
01:25:32 <kmc> i don't know if that's the case
01:25:52 <jrockway> ah, that might be good'
01:26:05 <kmc> it may still be constant-space even with no fusion
01:26:09 <jrockway> i was doing a zip over (BS.inits x) (B.inits y) and then comparing
01:26:21 <jrockway> which is obviously not constant-space
01:26:28 <ivanm> @hoogle isPrefixOf
01:26:28 <lambdabot> Data.ByteString isPrefixOf :: ByteString -> ByteString -> Bool
01:26:29 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
01:26:29 <lambdabot> Data.ByteString.Char8 isPrefixOf :: ByteString -> ByteString -> Bool
01:26:30 <kmc> (fusion is a specific GHC optimization, but constant-space lazy producer/consumer pairs should arise from any graph-reduction model)
01:26:35 <ivanm> jrockway: ^^ ?
01:26:44 <jrockway> isPrefixOf is not quite right
01:26:46 <shachaf> ivanm: That won't find a common prefix.
01:26:49 <ivanm> oh, right
01:26:51 <jrockway> isPrefixOf "food" "foobar" would return False
01:26:54 <jrockway> but i want "foo"
01:28:26 <kmc> dolio, if i don't have a pay job then i have no excuse for not pumping out useful open-source Haskell code at high rate
01:28:59 <dolio> Not having an excuse didn't really stop me.
01:29:30 <dolio> I should really sleep some.
01:29:39 <ivanm> as should I
01:31:40 <Svrog> what's an example of something that is a functor but not an applicative functor? i kind of took it for granted functors are more general but i can't think of any functor right now that couldn't also be an applicative functor
01:32:00 <ivanm> @instances Functor
01:32:01 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
01:32:10 <ivanm> @instances-importing Control.Applicative Applicative
01:32:10 <lambdabot> ((,) a), ((->) a), Const m, ContT r m, Either e, ErrorT e m, IO, Maybe, ReaderT r m, StateT s m, WrappedArrow a b, WrappedMonad m, WriterT w m, ZipList, []
01:32:22 <shachaf> Hah, the Applicative list is longer.
01:32:24 <shachaf> QED
01:32:31 <ivanm> oh, that wasn't as helpful as I thought it would be...
01:32:40 <ivanm> @instances-importing Control.Applicative Functor
01:32:41 <lambdabot> ((,) a), ((->) r), Const m, ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WrappedArrow a b, WrappedMonad m, WriterT w m, ZipList, []
01:32:48 <ivanm> shachaf: hah!
01:33:01 <Svrog> on another note is there are reason comonad is made up of two classes instead of one?
01:33:09 <kmc> it is?
01:33:14 <Svrog> on hackage it is
01:33:16 <Svrog> well
01:33:22 <kmc> is one of them "Copointed"?
01:33:32 <Svrog> it depends on the extend class which provides extend
01:33:40 <Svrog> which used to be a part of comonad
01:34:16 <kmc> Monad could be split similarly
01:34:23 <Svrog> sure
01:34:27 <kmc> class Pointed f where { pure :: a -> f a }
01:34:32 <kmc> which would go between Functor and Applicative
01:34:51 <shachaf> kmc: Comonad seems to be backwards, actually.
01:34:52 <Svrog> i'm still confused about the usefulness of extend on its own
01:34:58 <shachaf> I mean, compared to that ordering.
01:35:21 <ivanm> Svrog: you'd have to ask edwardk about that :p
01:35:39 <Svrog> yeah, i might have to
01:37:00 <jpcooper> good morning
01:37:05 <kmc> good morning jpcooper
01:37:14 <shachaf> Greetings, jpcooper!
01:37:33 <jpcooper> is it possible to check, with the Network package, whether the other end of a socket has disconnected?
01:37:35 <Svrog> so about functors that are not applicative functors - are there any?
01:37:48 <mustelo> ugh, this talk of morning means I should sleep. must... prove things about peano naturals...
01:37:50 <Svrog> or rather functors that can't be applicative
01:37:52 <jrockway> kmc: that works quite well
01:38:04 <kmc> mustelo, playing Coq?
01:38:11 <jrockway> it's perfect for my use case where i have very long strings with an average common prefix of ""
01:38:19 <mustelo> kmc, yup, just started a few hours ago; very addicted.
01:38:20 <kmc> they should make an MMO of that
01:38:27 <mustelo> haha, yeah.
01:38:28 <jpcooper> or does hPutStr return a certain error if I try to put a string to the associated handle?
01:38:54 <mustelo> kmc, is "software foundations" the book you mentioned the other day?
01:38:57 <kmc> yes
01:39:16 <mustelo> I didn't know byorgey was an author
01:39:19 <jrockway> and in case anyone is wondering, the longest repeated string in "great expectations" is "This eBook is for the use of anyone anywhere at no cost and with almost no restrictions whatsoever.  You may copy it, give it away or re-use it under the terms of the Project Gutenberg License included with this eBook or online at www.gutenberg.org"
01:39:21 <kmc> apparently so :)
01:40:11 <kmc> yeah, Coq is basically a puzzle game
01:40:39 <kmc> someone should post a speedrun video
01:40:53 <kmc> a friend and i were racing to complete _Software Foundations_ for a while
01:40:55 <mustelo> haha, I'm pretty slow, so not me.
01:40:57 <kmc> many jokes about coqfighting etc
01:41:01 <mustelo> hahahaha
01:41:17 <mustelo> that's definitely the name of the MMO
01:41:19 <elliott> agda fragging
01:41:24 <elliott> one proof down, three to go
01:41:25 <kmc> another fun puzzle game is routing two-sided PCBs
01:41:39 <elliott> i'm here to prove theorems and compile code and I'm all out of code
01:41:55 <kmc> "if i can eliminate just one more via i'll go to sleep"
01:42:01 <kmc> *sleeps, dreams about PCB routing*
01:42:24 <kmc> @remember elliott i'm here to prove theorems and compile code and I'm all out of code
01:42:25 <lambdabot> I will remember.
01:42:31 <shachaf> kmc is experiencing -blah withdrawal already.
01:42:35 <elliott> :D
01:43:07 <elliott> i hereby title that "the story of agda"
01:53:49 <jpcooper> so can anyone advise me on connection errors in the context of Network?
01:54:24 <jpcooper> that is, how to know that a message is received
01:58:11 <mustelo> jpcooper, it's usually safe to assume that your messages get through if you're using TCP
01:58:53 <jpcooper> mustelo: what if the client on the other end disconnects before I write something to the handle?
01:59:09 <jpcooper> I would like to know that he has disconnected after I send the message somehow
02:06:49 <hpaste> jrockway pasted “zip vs. iteration” at http://hpaste.org/50516
02:07:43 <jrockway> kmc: the "iterate over each character" method seems to be faster than zipping, probably due to the allocation of the temporary pairs.  see above paste.
02:07:59 <kmc> *nod*
02:08:08 <kmc> i was hoping those pairs / conses would fuse
02:08:11 <kmc> but had no real reason to think they would
02:08:31 <shachaf> Hope-driven optimization.
02:08:45 <kmc> that's basically how fusion works
02:09:39 <shachaf> For some reason I thought that memcmp told you the first character that its inputs differed at.
02:09:42 <shachaf> But I guess not.
02:09:44 <jrockway> actually, i ended up using zipwith, which shouldn't need any intermediate values
02:09:57 <jrockway> so it's really a little boggling
02:10:18 <kmc> intermediate thunks, maybe
02:10:50 <shachaf> Won't zipWith compare the entire ByteString?
02:10:51 <jrockway> right
02:10:56 <shachaf> Are these lazy or strict?
02:10:59 <jrockway> no, look at the implementation
02:11:09 <jrockway> it's of the form (x, y) : zipWith ...
02:11:23 <jrockway> so it will only evaluate that list as far as necessary
02:14:04 <shachaf> @hoogle zipWith
02:14:04 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
02:14:04 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
02:14:04 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
02:14:09 <shachaf> Oh, it returns a list.
02:14:16 <shachaf> ...I guess returning a bytestring makes no sense.
02:15:42 * hackagebot cmdlib 0.3.2 - a library for command line parsing & online help  http://hackage.haskell.org/package/cmdlib-0.3.2 (PetrRockai)
02:18:31 <elliott> So, theoretically... with GHC, if I had a chunk of code that did absolutely no allocation and in fact should compile down to pretty much pointer twiddling, what are my chances of being able to call it from C without initialising the RTS?
02:19:32 <jrockway> assuming your preconditions are met, probably 100% :)
02:19:48 <elliott> Well, I /hope/ so. "Do NOT try to invoke any Haskell functions before calling hs_init(): bad things will undoubtedly happen."
02:20:46 <jrockway> why not just generate the C code and paste it in (via preprocessor or other means), if you are sure you don't actually need the RTS
02:21:14 <elliott> jrockway: Eh? you mean replace my pointer-twiddling Haskell with C?
02:21:32 <jrockway> hey, you're calling it from C :)
02:21:43 <shachaf> GHC doesn't really generate fast C nowadays, does it?
02:21:51 <elliott> GHC isn't generating C in this scenario.
02:21:58 <elliott> Oh, maybe it does in jrockway's.
02:22:08 <elliott> jrockway: ...anyway: Yes, but... umm, how to say this... the C code calling my Haskell code is the RTS.
02:22:18 <jrockway> ah :)
02:22:33 <elliott> It's probably best if you try not to think about it. In fact, try that really hard.
02:23:33 <kmc> woah
02:23:37 <kmc> what are you doing elliott?
02:23:50 <elliott> kmc: A REALLY BAD THING AND I'M BAD AND I FEEL BAD, OKAY?!?!
02:24:10 * elliott cries a bit.
02:24:14 <jrockway> actually, it sounds much less evil now
02:24:23 <elliott> What :)
02:24:36 <jrockway> if you were a random person writing a random application and needed to not initialize the RTS to call into haskell code, that would be scary
02:24:42 <elliott> haha
02:24:43 <jrockway> but if you're hacking GHC, then that's almost expected :)
02:24:56 <elliott> I'm actually trying to avoid touching the GHC code directly... a delicate act.
02:25:06 <elliott> I'm just going to massage it into a really disturbing shape by asking it nicely.
02:25:34 <jrockway> kmc can help out with his hope-driven optimization techniques
02:25:49 <elliott> That's the best kind of optimisation. Actually the only kind I'm good at.
02:26:31 * illissius optimizes with liberal application of unsafeThisAndThat.
02:26:50 <elliott> illissius: I'm in octothorpe land; 'round here, the trees don't even have signs letting you know they're unsafe.
02:26:57 <elliott> The trees which in this strained metaphor are made out of octothorpes.
02:27:13 <shachaf> "strained" metaphor, eh?
02:27:59 <hpaste> “elliott#” pasted “please# don't# disown# me#” at http://hpaste.org/50517
02:28:21 <illissius> i was familiar with many different names for an octothorpe, but 'octothorpe' was not one of them.
02:29:18 * elliott gently prods kmc but thinks better of it
02:29:38 <Botje> elliott: needs a "CAUTION: this file has sharp corners"
02:30:30 <elliott> Botje: I'm just going to put it in about a thousand nested archives in various platform-specific formats, burn it to a DVD, build it into a huge concrete block, drop it into the ocean, and then atomize the entire planet.
02:30:37 <elliott> I think that should do it.
02:30:44 <jrockway> Real World Haskell Volume 2: RealWorld# Haskell#
02:30:50 <elliott> :D
02:31:13 <Botje> @remember jrockway Real World Haskell Volume 2: RealWorld# Haskell#
02:31:14 <lambdabot> Nice!
02:32:13 <elliott> So, um, the idea is to have the FFI... use that thing to allocate memory.
02:32:13 <ivanm> uh..... what?
02:32:20 <elliott> Uh oh, what did ivanm see.
02:32:26 <elliott> Is my secret out? I'm a bad person.
02:32:47 <ivanm> elliott: I was referring to jrockway's quote
02:32:55 <elliott> Oh :P
02:33:05 <ivanm> what's the significance of RWH-2 being unboxed?
02:33:16 <ivanm> (not to mention concatenating the first two words together)
02:33:29 <elliott> ivanm: If you want to find out, _don't_ read http://hpaste.org/50517.
02:33:38 <elliott> And presumably that's in reference to RealWorld which actually has no octothorpe :P
02:33:41 <shachaf> @src IO
02:33:42 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
02:35:45 <illissius> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html
02:35:48 <illissius> indeed it doesn't.
02:37:58 <shachaf> illissius: I like the implementations in that file.
02:38:24 <shachaf> @ty let x = x in x -- Very useful operator, this.
02:38:26 <lambdabot> forall t. t
02:38:51 <opqdonut> aka undefined
02:39:03 <opqdonut> well okay, not operationally
02:39:14 <elliott> That's actually how GHC is implemented.
02:39:22 <elliott> It just catches all the infinite loops and rewrites them into machine code that does what you want.
02:39:23 <elliott> True facts.
02:39:55 <shachaf> > compаre True False
02:39:57 <lambdabot>   EQ
02:40:59 <tomberek> what's a good functional structure for index and update heavy applications with a rare cons thrown in?
02:41:00 <benmachine> > compare compare Prelude.compare
02:41:02 <lambdabot>   *Exception: (==): No overloading for function
02:41:11 <benmachine> :(
02:41:12 <elliott> shachaf: That's no normal c, o, m, p, a, r, e.
02:41:15 <elliott> What did you do :P
02:41:18 <elliott> :t compаre
02:41:19 <lambdabot> Not in scope: `comp'
02:41:24 <elliott> HMMMMMMMMMMmmmmmMMMMMMmmmmMMMMmmmmmmmmm
02:41:28 <elliott> :t compare
02:41:29 <benmachine> devious :O
02:41:29 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
02:41:37 <elliott> huh, benmachine's was legit?
02:41:42 <elliott> I've never seen that exception before
02:41:50 <shachaf> tomberek: Data.Sequence might be a good default.
02:41:53 <shachaf> But it depends on your application.
02:41:58 <benmachine> elliott: it's a dummy Eq instance for functions
02:42:09 <opqdonut> why is there one?
02:42:13 <tomberek> shachaf: i was looking at diffarray
02:42:19 <shachaf> opqdonut: For the Num instance.
02:42:23 <opqdonut> ah, yes
02:42:25 <elliott> ah
02:42:39 <elliott> I'm used to seeing "no (==)" not something fancy like "No overloading for function" :)
02:43:20 <ivanm> preflex: seen sw17ch
02:43:20 <preflex>  sw17ch was last seen on #haskell 86 days, 12 hours, 9 minutes and 7 seconds ago, saying: fmap gorgonzola prosciutto
02:52:16 <elliott> Out of morbid curiosity, is there any documentation on what the C wrappers generated for FFI-exported Haskell functions look like in GHC?
02:59:05 <illissius> elliott: I'm not sure, but iirc it generates a separate, physical .c file you can look at.
02:59:09 <illissius> has _stub in the name
02:59:37 <elliott> oh, it does? neat
02:59:57 <elliott> the problem is getting ghci happy with my export declaration...
03:01:06 <illissius> elliott: what are your 'larger aims', btw? i.e. what for all this memory allocation and other assorted voodoo magic?
03:02:09 <elliott> illissius: to get an implementation (targeted to the bare metal) of all the library functions the RTS needs to function
03:02:44 <elliott> admittedly, I'm mostly trying to prove myself that it's actually possible.
03:03:46 <elliott> well, now illissius is scared of me
03:05:59 <elliott> illissius: ah, looks like the stub is doing some things I don't need to care about at all (rts_lock/rts_unlock/rts_checkShedStatus), but some things I do... looks like it uses rts_evalIO even for pure functions :x
03:06:04 <elliott> thanks for the hint
03:06:23 <Taejo> does GHC's heap profile only show objects that survive GC? (it seems to, since the ordinary profile shows 25% of my alloc in a function which doesn't show up on the heap profile)
03:06:23 <illissius> yw
03:06:46 <Svrog> elliott: wasn't that already done in house (http://programatica.cs.pdx.edu/House/)? getting the rts to work on bare metal
03:06:46 <elliott> http://darcs.haskell.org/ghc/docs/comm/the-beast/fexport.html oh, this should be useful
03:06:58 <elliott> "This is identical to case (1), with the sole difference that the stub calls rts_eval rather than rts_evalIO." ...but perhaps outdated
03:07:16 <illissius> elliott: also i'm still trying to understand your earlier reply. what is the 'default implementation' (of the library functions) targeted to? what does 'library functions' mean exactly? what would the difference be vs. a normal setup?
03:07:29 <elliott> illissius: library functions meaning libc up, pretty much :)
03:07:42 <elliott> the "default" implementation comes with your favourite OS, and is targeted to your favourite OS.
03:07:50 <elliott> they're probably written in C.
03:07:54 <illissius> ah, ok
03:07:59 <illissius> starting to understand :)
03:08:17 <illissius> elliott: is this architecture-specific then?
03:08:43 <elliott> illissius: well. the allocator I just wrote should run on anything GHC does, because it's incredibly stupid :)
03:09:03 <elliott> but I wouldn't exactly say portability would be the result.
03:09:13 <elliott> you definitely need at least some assembly -- to boot the thing
03:09:35 <elliott> a reasonable person would also write malloc in asm (or maybe even C), so it's a good thing i'm not reasonable
03:09:36 <illissius> i maybe see
03:10:05 <illissius> so like HaLVM except targetting physical rather than virtual (Xen) machines then?
03:10:32 <elliott> illissius: yeah, but I'm not sure HaLVM is implemented in Haskell
03:11:52 <benmachine> elliott: I don't know if the thing you hpasted really counts as haskell :P
03:11:58 <illissius> so a reimplementation of the RTS in (mainly) Haskell to run on the bare metal.
03:12:14 <illissius> that's... ambitious.
03:13:24 <elliott> illissius: Well, no, the RTS doesn't really need changing at all.
03:13:28 <elliott> I'm just implementing everything the RTS calls.
03:13:37 <illissius> oh. right.
03:13:39 <elliott> malloc isn't part of the RTS, it's part of libc. But the RTS calls it, so I have to implement it in Haskell.
03:13:49 <elliott> That's quite a problem though, because I have to implement it without allocating any memory at all.
03:13:52 <elliott> So, octothorpe-ville.
03:13:56 <elliott> benmachine: Caskell?
03:14:04 <benmachine> elliott: kind of, C with haskell syntax, no?
03:14:12 <elliott> Heck, C's nicer than that
03:14:16 <benmachine> :P
03:14:33 <benmachine> so what's the point, if I may be so impertinent
03:14:40 <elliott> I'm annoyed that I had to introduce something ostensibly non-primitive ((), because you can't have a top-level unboxed definition)... but it should be inlined out anyway.
03:14:48 <elliott> benmachine: Because I can! Maybe!
03:14:59 <benmachine> elliott: but you can also write them in brainfuck
03:15:07 <benmachine> you're not about to go do that, I imagine
03:15:08 <elliott> Yeah, but the RTS can't call brainfuck. Well, yet.
03:15:16 <elliott> benmachine: Hey, us #esoteric folk...
03:15:24 <benmachine> :P as you wish
03:15:25 <elliott> We might do _anything_.
03:16:30 <kmc> elliott, wasn't it done for House, and *again* for HaLVM?
03:16:48 <kmc> also why is it better to reimplement the RTS in Haskell than to reimplement it in C?
03:17:27 <elliott> kmc: I think so, yes; and I'm not reimplementing the RTS.
03:17:30 <elliott> I'm not touching the RTS at all.
03:17:31 <Jester_Racer> Hi! Is there a function in the libraries that do this for me: myRepeat [1,2,5] == [1,2,5,1,2,5,1,2,5 ...] ?
03:17:39 <elliott> > cycle [9,0,9]
03:17:40 <lambdabot>   [9,0,9,9,0,9,9,0,9,9,0,9,9,0,9,9,0,9,9,0,9,9,0,9,9,0,9,9,0,9,9,0,9,9,0,9,9,...
03:17:55 <Jester_Racer> elliott: that's it :) thanks
03:18:05 <benmachine> elliott: why is it better to reimplement libc in haskell than C? :P
03:18:10 <kmc> elliott, why is it better to reimplement libc in Haskell?
03:18:13 <kmc> heh
03:18:29 <elliott> Because Haskell is better than C, obviously :)
03:18:35 <elliott> For /literally every purpose/.
03:18:42 <kmc> i would be so bold as to say that C is a better language for implementing libc
03:18:56 <elliott> Don't think of it as libc. Think of it as... weird symbols with weird calling conventions that the RTS wants.
03:19:14 <kmc> like malloc
03:19:19 <elliott> Yes.
03:19:22 <elliott> So strange.
03:19:23 <kmc> implementing malloc in Haskell without doing any Haskell allocation.
03:19:31 <elliott> Yes.
03:19:33 <floopa> @pl palindrom str = str == reverse str
03:19:33 <lambdabot> palindrom = ap (==) reverse
03:19:36 <elliott> I believe that's what I did, yes.
03:19:44 <kmc> that's stupid and pointless
03:19:47 <kmc> maybe it's a fun game, though
03:20:05 <kmc> it sounds incredibly fragile
03:20:20 <elliott> Well, it's made entirely out of primitive types.
03:20:23 <elliott> There's no justifiable reason to cons at all.
03:20:35 <kmc> you're not actually implementing it in Haskell
03:20:43 <elliott> Like I said, Caskell.
03:20:46 <kmc> you're implementing it in some other weird language GHC accepts
03:20:54 <kmc> you might as well use Cmm, which is another weird language GHC accepts
03:21:02 <elliott> Does GHC even have a Cmm parser?
03:21:03 <kmc> in fact GHC is the world's finest Cmm compiler
03:21:04 <kmc> yes
03:21:12 <kmc> parts of the RTS are written in Cmm and compiled by GHC
03:21:14 <Svrog> or could write your own compiler
03:21:14 <Taejo> it would be nice if haddock had source links to instance declarations
03:21:28 <elliott> kmc: Oh well. That's less fun.
03:21:30 <mustelo> oh, maybe just one or five more chapters of coq before sleep
03:22:03 <benmachine> elliott: I can't help but feel if you're good enough to do this there are actually useful things you could be doing :P
03:22:31 <elliott> Anyone want to pay me to rewrite large swathes libc in various constrained forms of GHC Haskell?
03:22:37 <elliott> No?? Whyever not???
03:23:40 <kmc> elliott, if you invented a Haskell EDSL which is really good for writing malloc and friends
03:23:44 <kmc> that would be cool *and* useful
03:24:03 <elliott> And which compiles to octothorpeskell?
03:24:13 <elliott> The answer is "naturally".
03:24:20 <kmc> no, which compiles to anything reasonable
03:24:41 <Svrog> kmc: i don't think an edsl is necessary
03:24:49 <elliott> That's so subjective.
03:25:41 <Svrog> i can't think of a reason why that couldn't be done in haskell directly - just not in any of the current implementations, at least not in any practical way
03:25:52 <kmc> you need a subset of Haskell which is guaranteed not to allocate
03:25:56 <elliott> Svrog: If you mean "write malloc in Haskell without using malloc" I just did it
03:25:59 <elliott> Well
03:26:00 <elliott> "Haskell"
03:26:15 <Svrog> yes, exactly, "haskell" :)
03:30:45 <kizzx2> let's say i have 3 monads of list, what's the elegant way to do (pseudo)  (++) <$> Just [1] <*> Just [2] <*> Just [3] ?
03:30:56 <kizzx2> my attempt    fred = join $ sequence [Just [1], Just [2], Just [3]]
03:31:13 <kmc> that's not what the word "monad" means
03:31:16 <kmc> a monad is a type constructor
03:31:23 <kmc> Maybe is a monad, (Just 3) is not
03:31:46 <kizzx2> kmc: ok i have 3 Reader Int [Int] and i want to run 3 of them and chain (++) the rsults
03:31:57 <kizzx2> i was using Just to illustrate what i want to do
03:32:21 <kmc> :t \r -> concat . map (runReader r)
03:32:22 <lambdabot> forall a a1. Reader a1 [a] -> [a1] -> [a]
03:32:37 <kmc> :t \r -> concat . map (flip runReader r)
03:32:39 <lambdabot> forall a a1. a1 -> [Reader a1 [a]] -> [a]
03:33:14 <elliott> I have this sneaking suspicion that rts_apply allocates.
03:34:14 <Taejo> :t foldr (liftM2 (++)) (return [])
03:34:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m [a]] -> m [a]
03:35:00 <buntfalke> Hi everyone
03:37:10 <buntfalke> There's a simple FIFO queue implemented as a list. Additionally, there is a two-list implementation of the class, where enqueue adds to the list A, dequeue removes from list B, and list A is swapped over to list B whenever B got empty.
03:37:41 <buntfalke> Which advantage does this two-list implementation have? It seems like it is more expensive with no added use...
03:38:01 <kmc> appending to the end of a singly-linked list is expensive
03:38:14 <kmc> you have to walk the whole list and copy every cons cell
03:38:29 <kmc> same for removing from the end
03:38:39 <Taejo> however, you can also trigger quadratic time in the two-list version
03:38:42 <benmachine> > fmap concat . sequence $ [Just [1], Just [2], Just [3]]
03:38:44 <lambdabot>   Just [1,2,3]
03:38:49 <benmachine> kizzx2: ^
03:38:50 <kmc> elliott, I have this sneaking suspicion that you're crazy.
03:38:56 <kmc> buntfalke, Chris Okasaki
03:39:01 <kmc> wrote a book about this and related topcis
03:39:11 <elliott> kmc: Just a suspicion?
03:39:11 <buntfalke> kmc: Why? I've been told GHC implements lists using C code, and remembers the length of the list, so it's simply (list+list->length)->next=FOO
03:39:19 <kmc> eh invents functional data structure and doesn't afraid of anything
03:39:25 <kmc> buntfalke, you've been grossly misinformed
03:39:27 <elliott> buntfalke: Whoever told you that was wrong.
03:39:32 <buntfalke> I see.
03:39:37 <kmc> data List a = Nil | Cons a (List a)
03:39:46 <kmc> aside from special syntax, that's all there is to 'List'
03:39:50 <buntfalke> I was kind of suspencting it, because else diffList wouldnt make any sense...
03:40:00 <buntfalke> (aint that so?_
03:40:01 <buntfalke> )
03:40:05 <merijn> buntfalke: Also that "C" example makes no sense in C either
03:40:24 <merijn> You can't just add the list's length to a list to find the appropriate item in a linked list...
03:40:32 <kmc> buntfalke, also note that your C example involves mutating the list in place
03:40:40 <kmc> which would totally wreck the data structure in haskell
03:40:41 <shachaf> buntfalke: Lists are also immutable, so you couldn't do that sort of thing anyway.
03:40:52 <kmc> anyone could have held onto the old list head
03:40:56 <kmc> they can't suddenly have new elements appear
03:41:01 <buntfalke> merijn: You can just do pointer arithmetic (read: add the length), dereference, and set the next pointer.
03:41:09 <kmc> that's not how linked lists work
03:41:13 <merijn> buntfalke: How do you do that in a linked list?
03:41:13 <kmc> the nodes are not contiguous in memory
03:41:24 <merijn> That only works if you can guarantee yours nodes are contiguous
03:41:48 <ceii__> but if you can guarantee they are, what you have is an array, and you don't need a next pointer
03:41:56 <merijn> That'd be more of ArrayList type deal
03:42:00 <bob31> trying to build cabal-install with 7.2.1 I modified bootstrap.sh and cabal-install.cabal. still I get this unsatisfied dependency which I don't understand
03:42:01 <bob31> Setup: At least the following dependencies are missing:
03:42:02 <bob31> base >=2.0 && <2.2
03:42:07 <kizzx2> benmachine: thanks. i was just wondering if i could it with applicative, for the sake of it
03:42:23 <benmachine> kizzx2: well, you can sequence with applicative
03:42:25 <benmachine> :t sequenceA
03:42:26 <lambdabot> Not in scope: `sequenceA'
03:42:28 <benmachine> ff
03:42:34 <benmachine> :t Data.Traversable.sequenceA
03:42:35 <Taejo> bob31: sounds like you have an ancient cabal-install.cabal
03:42:35 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
03:42:39 <bob31> bytestring is in base and is >= 0.9 and base is of course >= 3
03:42:40 <buntfalke> Ah -- more precisely: I've been told it implements lists as arrays, allocating more than needed so realloc (read: potential copy) is "seldom"
03:42:44 <bob31> Taejo: 0.10.2
03:42:52 <bob31> Taejo: couldn't find anything newer
03:43:06 <Taejo> hmm, hackage says that's the newest
03:43:11 <shachaf> buntfalke: You've been *grossly* misinformed.
03:43:18 <buntfalke> anyway -- it's been bullshit, and thus the two-list way makes sense
03:43:21 * shachaf wonders who told you that.
03:43:23 <bob31> 1st modified bootstrap shell script to not get ancient packages
03:43:24 <Taejo> bob31: but it depends on base >= 3.0 & < 5
03:43:25 <buntfalke> shachaf: yeah, got that :-)
03:43:50 <elliott> shachaf: Someone thinking of ByteStrings?
03:43:54 <Taejo> bob31: base-2 is ancient, whatever wants that needs a newer version
03:44:00 <kmc> ByteString still won't modify in place, though
03:44:01 <ivanm> is there an up-to-date tutorial on quasiquotation that takes into account the changes in TH.Quote in 7.0 ?
03:44:03 <buntfalke> shachaf: hasnt been here, so no need to worry :-)
03:44:10 <merijn> That said, I'm pretty sure someone on this planet has already imlemented queues and priority-queues in haskell already :p
03:44:19 <shachaf> elliott: ByteStrings still don't "allocate more than needed", and are immutable.
03:44:37 <ivanm> merijn: queues = Data.Sequence; there are a few PSQ implementations
03:44:46 <ivanm> and also a couple of just PQ ones
03:45:06 <elliott> shachaf: Vector?
03:45:14 <elliott> Mutable vectors, I guess.
03:45:48 <buntfalke> So: Would it make sense to implement the FIFO queue using Difference Lists?
03:46:08 <shachaf> Not really, I don't think?
03:47:30 <buntfalke> shachaf: Why not? Append to tail and remove from head are in O(1), no?
03:48:16 <shachaf> I suspect you misunderstand difference lists.
03:48:19 <shachaf> Of course, maybe I do. :-)
03:48:35 * buntfalke goes reread that article in Monad Reader 17 :-)
03:48:49 <buntfalke> thanks for the clearup on lists!
03:48:52 <kmc> it's hard to remove things from DLists
03:48:54 <kmc> afaik
03:49:05 <kmc> anyway Data.Sequence makes a pretty good queue
03:49:06 <shachaf> In Haskell the difference list representing [a,b,c] is just the function ([a,b,c] ++).
03:49:08 <kmc> or random-access list
03:49:32 <shachaf> So you can compose the functions in constant time to "append", of course.
03:49:51 <shachaf> But actually removing an element means evaluating all those compositions.
03:52:08 <bob31> Taejo: no matter which version restriction I "fix" in cabal-install.cabal, it won't be happy
03:52:13 <Yrogirg> Hey guys! What does '' mean in the definition of natural transformation  : F  G (http://ncatlab.org/nlab/show/natural+transformation)?
03:52:16 <buntfalke> kmc, shachaf: thanks!
03:52:56 <bob31> Taejo: maybe cabal-install moving into GHC would make sense, but I believe it was extracted out of GHC during 6.x
03:54:09 <ivanm> AFAICT, for the two new fields in QuasiQuoter in ghc 7.*, everyone just uses undefined or error "foo"... :s
03:54:23 <Taejo> bob31: but it's not cabal-install that has that ancient dependency: the version you're using uses base-3 or base-4
03:54:36 <blackdog> any ideas how you'd create the type "GHC.Types.Int" in TH? I thought mkName "GHC.Types.Int" might do it, but it doesn't match when i look that up in an assoclist
03:54:53 <bob31> Taejo: tried to build cabal-install 0.10.2 with 7.2.1?
03:55:26 <Taejo> I haven't but I have looked at the cabal file, and it doesn't depend on base-2
03:56:03 <bob31> Taejo: that's the tip of the iceberg :)
03:56:10 <bob31> Taejo: Cabal is now at 1.12
03:56:51 <bob31> Taejo: so one starts to bump the upper bounds just to hit confusing (to me) dependency issues
03:57:14 <bob31> is cabal-install not developed in tandem with Cabal?
03:58:14 <bob31> I found another cabal-install
03:58:16 <bob31> aaaah
03:58:17 <bob31> http://darcs.haskell.org/cabal/cabal-install/
03:58:26 <bob31> as a subdir of the Cabal darcs repo
03:58:27 <bob31> hmm
03:58:57 <bob31> wich is cabal-install 0.11.2
03:58:59 <bob31> hmm
04:03:56 <kmc> evaluate (BS.length bs)  -- should be enough to force a strict ByteString completely, right?
04:04:03 <kmc> and same for lazy, because it has to do that to each chunk?
04:04:15 <shachaf> Yep.
04:04:42 * hvr wishes that ByteString would come w/ ready to use NFData instances 
04:05:20 <hvr> actually I'd like that for all data structures in GHC-bundled user libraries
04:05:57 <shachaf> Actually everything in the world should have NFData instances.
04:06:01 <blackdog> welp, guess i'll just serialise the type to a string and then look it up. i'm dirty like that.
04:06:02 <shachaf> To deepSeq is a fundamental right.
04:10:07 <bob31> so cabal-install.cabal from that darcs repo looks better but the bootstrap.sh is still looking for ancient deps to fetch. let's try with my mods to accommodate for new version on Hackage and ghc-7.2.1/lib/7.2.1
04:10:22 <hvr> @remember shachaf To deepSeq is a fundamental right
04:10:23 <lambdabot> I will remember.
04:10:37 <shachaf> :-(
04:11:04 <shachaf> @forget shachaf To deepSeq is a fundamental right
04:11:04 <lambdabot> Done.
04:11:31 <hvr> shachaf: actually I would have subscribed to that idea :-)
04:13:32 <kmc> can you make some ultra-hack deepSeqAnything :: a -> b -> b, using GHC internals?
04:13:40 <kmc> closure layout is known for GC purposes, right?
04:13:50 <kmc> this wuold
04:13:56 <kmc> this would let you deepSeq functions :D
04:14:39 <kmc> yeah, I think vacuum could do this
04:16:30 <bob31> Taejo: now down to random >= 1 && < 1.1 not being satisfied
04:17:03 <hvr> bob31: what are you trying to do btw? just compile cabal-install w/ GHC 7.2.1?
04:17:07 <elliott> kmc: yikes
04:17:23 <kmc> actually perhaps (vacuum x `seq` ()) is already enough
04:17:28 <kmc> yikes what?
04:17:29 <elliott> hmm, is vacuum unmaintained?
04:17:33 <elliott> kmc: yikes at your idea
04:17:36 <kmc> haha
04:17:37 <bob31> hvr: yes, build cabal-install with GHC 7.2.1 without making it download old versions of libs part of GHC proper
04:17:42 <elliott> <kmc> actually perhaps (vacuum x `seq` ()) is already enough
04:17:45 <hvr> elliott: it doesn't compile w/ GHC 7.2 :-/
04:17:46 <kmc> elliott, *you* think *my* idea is a hack? ;P
04:17:48 <elliott> isn't vacuum usable for showing the unevaluated structure of things?
04:17:53 <elliott> so that would seem not to me
04:18:05 <bob31> hvr: using this http://darcs.haskell.org/cabal/cabal-install/ and a modified bootstrap.sh
04:18:09 <elliott> kmc: Shh, there's two mes, and the reasonable one thinks it's yikes
04:18:15 <elliott> The other one is currently suspended
04:18:17 <illissius> blackdog: what's wrong with ''Int?
04:18:22 <elliott> oh, there's a vacuumLazy
04:18:28 <illissius> (other than the incredibly fugly syntax)
04:18:29 <elliott> yeah, I guess vacuum is enough
04:18:38 <blackdog> illissius: ... absolutely nothing. thanks.
04:20:10 <kmc> elliott, 's okay, i delight in low-level hacks as well
04:20:15 <kmc> did you see "Executing a ByteString"?
04:20:26 <elliott> With a title like that, I'm not sure I want to.
04:20:32 <elliott> Oh dear, I remember this.
04:20:33 <elliott> I think.
04:20:34 <blackdog> illissius: i have a very limited grasp of TH :) there seems like there's an awful lot of moving parts.
04:20:47 <hvr> bob31: ic... well, I succeeded in building cabal-install from the current darcs repo with an existing `cabal` binary w/o pulling any old libraries
04:20:47 <elliott> kmc: You're a bad person, and you should feel bad.
04:21:02 <kmc> http://mainisusuallyafunction.blogspot.com/2010/09/executing-bytestring.html
04:21:15 <elliott> Yeah, I found it.
04:21:32 <bob31> hvr: which probably works due to not using bootstrap.sh
04:21:36 <hvr> bob31: the only non-GHC boot libraries needed were: HTTP-4000.1.2 mtl-2.0.1.0 network-2.3.0.5 parsec-3.1.1 random-1.0.0.3 transformers-0.2.2.0 zlib-0.5.3.1
04:21:37 <bob31> hvr: that's good info
04:21:38 <illissius> blackdog: there are, though much of it is different ways to do the same thing
04:21:51 <bob31> hvr: let me modify boostrap.sh to get random, too
04:22:14 <hvr> bob31: I just tried w/ cabal-dev, and listed the installed packages
04:22:23 <kmc> i'm a little surprised this hack doesn't run afoul of memory protection, actually
04:22:51 <kmc> most OSes try to prevent writable pages from being executed
04:23:11 <kmc> perhaps GHC disables that
04:23:34 <Taejo> kmc: doesn't the RTS overwrite thunks?
04:23:45 * kmc is only aware of one case in which the RTS generates machine code at runtime
04:23:46 <kwos> hello
04:23:49 <kmc> Taejo, thunks aren't executable
04:24:18 <Taejo> oh
04:24:19 <shachaf> kmc: Pft. C programmers take that sort of thing for granted.
04:24:20 <Taejo> TIL
04:24:43 <kmc> a thunk lives in writable dynamic heap, and contains a pointer to a static info table which contains a pointer to a static entry function
04:24:46 <merijn> afaik thunks are just pointers to code which is executable
04:24:52 <kmc> (or the table and function are next to each other, but still)
04:25:08 <shachaf> merijn: Well, not *just*, presumably. :-)
04:25:25 <merijn> shachaf: I didn't mean pointer in the C sense
04:25:45 * shachaf didn't realize there was another sense.
04:25:54 <bob31> finally
04:26:08 <bob31> so on top of the 0.11.2 darcs repo of cabal-install one only has to
04:26:13 <bob31> 1) add random to bootstrap
04:26:20 <bob31> 2) bump the versions in bootstrap
04:26:22 <merijn> shachaf: The "something which points at something else" sense?
04:26:23 <kmc> GHC's RTS does dynamic code generation to implement foreign import "wrapper"
04:26:31 <bob31> to get this working starting with GHC only
04:26:34 <merijn> Like the difference between a reference and a reference :p
04:27:20 <kmc> in C++ a reference is a euphemism for a pointer
04:27:33 <bob31> I'm relieved now, but have to admit didn't understand the dependency issues encountered before. I may have to learn cabal semantics/syntax in more detail
04:27:37 <bob31> thanks everyone
04:27:57 <bob31> I may be one of the few who wipes everything and starts off a fresh GHC
04:30:41 <kmc> rts/posix/OSMem.c:257:  if (mprotect((void*)startOfFirstPage, (size_t)size, (exec ? PROT_EXEC : 0) | PROT_READ | PROT_WRITE) != 0) {
04:33:14 <kwos> FFI questions: I have a struct that stores a bunch of flags, each a form of CInt wrapped in newtype to add type safety... I have to make that struct an instance of Storable, and while my flags are CInts the corresponding newtyped types are not Storable by default
04:33:20 <kwos> what's the best solution here?
04:33:32 <elliott> deriving (Storable) with language extension GeneralizedNewtypeDeriving
04:46:21 <Peaker> is there a nice way to convert NominalDiffTime to a nice string ("%d months, %d days, %d minutes ...")?
04:47:50 <Gracenotes> I came across this problem in python. suspect my solution there won't help you.
04:51:01 <hpc> Peaker: convert to posix time, then use formatTime?
04:51:23 <hpc> unless formatTime works on NominalDiffTime
04:53:24 <Gracenotes> I suppose the more manual solution would be using properFraction on a diff time, divMod'ing the hell out of the (seconds, microseconds) result
04:54:40 <Gracenotes> or realToFrac to get a Double or something
04:54:51 <cwl> I have post an answer here, http://stackoverflow.com/questions/7134669/why-is-this-haskell-expression-so-slow/7138228#7138228
04:55:17 <cwl> but seems too late
04:55:21 <cwl> talk about it here
04:56:03 <cwl> let's compare the solutions
04:57:19 <cwl> will the expression in [ expr | blah blah ] compute more than once
04:58:08 <Gracenotes> seems okay? main benefit of lazy array over lazy list is when you know the length, though
04:59:36 <merijn> Gracenotes: array should have efficient indexing too
05:00:37 <Gracenotes> yes
05:00:49 <hpaste> hpc pasted “Peaker: getting it to work in ghci” at http://hpaste.org/50519
05:06:55 <cwl> Gracenotes: It is very slow
05:06:58 <cwl> Gracenotes: why
05:07:38 <cwl> Gracenotes: the answer got 14 votes runs only 1 second
05:07:46 <Gracenotes> the bottleneck operation I suspect is the indexing
05:08:01 <Gracenotes> the !!
05:08:06 <cwl> Gracenotes: but the good answer use list too
05:08:12 <cwl> Gracenotes: I see
05:10:00 <Gracenotes> it would likely be faster to wrap cL with Data.Array.IArray.array, and !! with !
05:10:37 <Gracenotes> but the memo library is made for this sort of thing, so is likely to work out any performance kinks involved even with that
05:10:59 <Gracenotes> your example is likely to run fast on smaller values
05:11:17 <Gracenotes> and also works for infinitely large ones (within Integer type bounds)
05:11:46 <cwl> Gracenotes: can I use the list comprehension on array
05:12:37 <benmachine> no
05:12:46 <cwl> Gracenotes: or something similar, just to make it concise
05:12:59 <Gracenotes> with s/array/listArray/, you can feed the thunks in from a list in the much the same way you already do
05:13:27 <Gracenotes> it has to construct each of them before it gets started calculating values
05:15:23 <benmachine> Gracenotes: trouble is writing the bounds of the array correctly
05:15:39 <Gracenotes> I've always wanted a map which is lazy in keys, a bit like a list, but still well-balanced
05:15:50 <benmachine> i.e. making sure that cl ! (3*n+1) isn't out-of-bounds
05:15:54 <Gracenotes> this isn't possible without knowing the keys in advanced. somewhat obviously :)
05:17:06 <Gracenotes> benmachine: ah. you're quite right, for collatz. I think that's another benefit of using Data.MemoCombinators.
05:17:37 <benmachine> yep
05:18:46 <k0ral> hi, is there a way to perform a map on something like "x <- ioOperation arg", so that I would get "[x1, x2, x3, ..., xN] <- map ioOperation [arg] ?
05:18:51 <Gracenotes> otherwise, listArray works well for greedy-ish algorithms, like in dynamic programming problems which have proven upper bounds and provably tend towards 0 :P
05:19:01 <kmc> :t mapM -- k0ral
05:19:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
05:19:37 <hpc> :t forM
05:19:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
05:19:51 <hpc> if you prefer that style...
05:20:14 <kmc> k0ral, note that mapM f = sequence . map f
05:20:18 <kmc> :t sequence
05:20:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:20:33 <hpc> @src sequence
05:20:33 <lambdabot> sequence []     = return []
05:20:33 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:20:33 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
05:23:04 <seit> Is there a haskell equivalent of C's ternary `?` operator
05:23:18 <Botje> if then else is already an expression
05:23:26 <leod> yeah there really isn't a need
05:23:39 <shachaf> You can also make one if you want to.
05:23:58 <leod> http://www.haskell.org/haskellwiki/Ternary_operator
05:24:05 <seit> hmm, true.  I am looking for a concise single like expression
05:24:10 * seit checking link
05:24:15 * tech2 frowns
05:24:31 <ciaranm> if-else is concise
05:24:44 <tech2> terseness does not improve code, it just makes it harder to read, and you _WANT_ your code to be readable, otherwise maintenance becomes a nightmare.
05:25:08 <Gracenotes> not to say a bool/if' function wouldn't be nice
05:25:09 <leod> readability is overrated
05:25:27 <seit> tech2, I agree -- but conciseness sometimes improves readability I'd say
05:25:28 <jmcarthur> i disagree. terseness improves your code and makes it easier to read if you do it in a principled way
05:26:07 <jmcarthur> little syntactic changes here and there are not what i'm talking about though
05:26:36 <jmcarthur> or at least not primarily
05:26:52 <tech2> jmcarthur: I'm not suggesting hugely verbose code here, I'm just recommending against compressing code for no net gain to the reader.
05:27:02 <tech2> leod: you're wrong :)
05:27:15 <leod> yeah i wasn't serious
05:27:18 <jmcarthur> well sure, with that qualification (no net gain for reader) i have no choice but to go along with you
05:27:22 <tech2> hence the smiley
05:27:24 <leod> :p
05:27:37 <seit> The reason I'm asking is I have lots of single lines that look like:  myVar = (Bool) ? myVar+1 : myVar
05:27:40 <k0ral> kmc, hpc: thank you
05:28:21 <seit> and I'm trying to find the way to express it easiest/cleaniest/readable, etc.
05:28:32 <jmcarthur> seit: bool a b p = if p then a else b  -- a useful function, at least for the way i code
05:28:52 <benmachine> seit: if it is literally that, then you can do incIf b x = if b then x+1 else x
05:29:32 <seit> benmachine, jmcarthur : good idea, I'll wrap the if/then
05:31:09 <Athas> Does anyone have experience replacing use of x11 with xhb?
05:31:25 <Athas> The x11 package appears unmaintained, so I guess now's the time to switch.
05:32:08 <seit> benmachine, jmcarthur : that looks a lot cleaner in the code.  I didn't like the verboseness of having the if/then/else statements on every line
05:52:02 <kmc> anyone know if parallel --make is a planned feature for ghc
05:52:08 <kmc> or how hard it would be to implement
05:52:12 <cheater> spj couldn't
05:52:14 <cheater> apparently
05:52:22 <kmc> sheeeeiiiiiiiiiiiiiiiiiit
05:52:23 <cheater> so he'll probably work hard to do it
05:52:29 <kmc> link?
05:52:37 <cheater> someone blogged it in here
05:52:58 <cheater> but i don't remember his screen name or sign-on timestamp
05:53:13 <kmc> doh
05:54:53 <cheater> try g/re/p'ing through the conversational records on your fixed disk, i think "make" and "gcc" would be the important tags to have your computing machine look for
05:55:16 <kmc> :D
05:55:35 <shachaf> g/make|gcc/p
05:55:42 <shachaf> Why don't regexps support &? :-(
05:56:02 <cheater> no more like g/(make.*gcc|gcc.*make)/p
05:56:11 <Gracenotes> some fancy extensions do
05:56:30 <shachaf> It would be nicer than the whole lookaround mess.
05:56:35 <shachaf> Potentially.
05:56:54 <kmc> lookaround you
05:56:56 <Gracenotes> we can't use state machines for our regex! they're too inefficient!
05:56:59 <tech2> shachaf: why not just search on the resultant matching lines? (chained g/re/p)
05:57:42 <cheater> because that's not descriptive
05:57:53 <cheater> you're reducing yourself to constructive languages!!
05:58:31 <shachaf> tech2: Well, I want e.g. A&B to match only a string that matches both the pattern A and the pattern B.
05:58:34 <Gracenotes> state machines tend to be regular, too. that's a downside for most regex implementations. nevermind things like tagged fsms.
05:59:04 <jrockway> so, i'm seeing some very strange behavior.  Data.Vector.Algorithm's introsort is taking about 3-10x as long on a vector as Data.List.sort on a list.
05:59:16 <tech2> shachaf: g/make/p;g/gcc/p
05:59:24 <jrockway> any ideas why this would be?
05:59:28 <shachaf> tech2: That works in that particular case.
05:59:37 <shachaf> I meant in general, not line-wise.
05:59:42 <jrockway> (profiling reveals that the partitioning is the bottleneck, but heapsort performs just as poorly)
05:59:55 <tech2> shachaf: agreed, it fails if the patterns overlap, certainly.
06:00:09 <shachaf> That's the only interesting case. :-)
06:00:36 <shachaf> I meant that more as an "apropos" remark, not "this is what's needed here".
06:00:38 <tech2> cheater: in "the brave new world" maybe there will be a better solution, until there is however I'm happy with my constructive language ;)
06:02:26 <tech2> shachaf: I'm just trying to imagine the language/shortcut used to represent and describe the & style matches. Regex are suitably complex as-is
06:02:50 <shachaf> tech2: I think lookaround is more complicated than & would be.
06:02:59 <shachaf> And more expressive?
06:03:30 <tech2> shachaf: I think lookaround provides a level of functionality that & wouldn't, unless I'm imagining it working differently than you are.
06:03:49 <shachaf> tech2: What functionality?
06:04:17 * shachaf hasn't really thought this through or anything, and hasn't slept in quite a number of hours.
06:04:21 <shachaf> (Also, #haskell-blah.)
06:05:00 <tech2> shachaf: :) yeah, If you'd like to bail and sleep that's fine, I have things to learn anyway, but I was mostly thinking about the negative lookahead and behind assertions.
06:05:15 <Gracenotes> also, on point, people shouldn't be afraid of writing explicit parsers, assuming they know how to avoid performance kinks
06:05:29 * Gracenotes coughs at parsec
06:05:36 <tech2> heh
06:05:39 <shachaf> Gracenotes: People in this channel are deathly afraid of writing parsers.
06:05:47 <Gracenotes> oh dear
06:05:51 <tech2> odd, given the language style.
06:05:56 <shachaf> Which is why there are so few of them for Haskell.
06:06:04 * shachaf was not being completely serious there.
06:06:19 <Gracenotes> you have happy, you have parsec, you have a few dozen variants of each
06:06:22 <Gracenotes> what more do you need
06:06:43 <shachaf> Hmm, I guess there's no negative regexp either, is there?
06:07:18 * Athas really wishes cabal would compile in parallel.
06:07:27 <tech2> shachaf: what do you mean?
06:09:07 <Gracenotes> shachaf: trying to get some De Morgan's all up in this?
06:09:56 <shachaf> De Morgan's laws are my favorite laws.
06:10:21 <tech2> I wonder if I still have that little brown book somewhere... gods, it's probably still in NZ :/
06:10:25 <cheater> De Morgan's laws are best laws.
06:10:54 <cheater> what little brown book
06:11:09 <cheater> do you mean your communist party booklet
06:13:11 <tech2> cheater: a book I had to buy for a logic/philosophy course back in '96, De Morgan's laws and a whole load of other useful stuff. There's very few "technical" books I've kept over the years but that's one of them.
06:20:57 * hackagebot cmdlib 0.3.2.1 - a library for command line parsing & online help  http://hackage.haskell.org/package/cmdlib-0.3.2.1 (PetrRockai)
06:25:52 <Athas> Is Antoine Latter on this channel?
06:27:22 <kmc> cabal-version: >=1.6 is fine, right?
06:27:33 <kmc> looks like Cabal 1.6 shipped with GHC 6.10
06:27:39 <kmc> i don't aspire to support anything older than that
06:28:21 <bobsun> hello
06:28:49 <kmc> hi bobsun
06:30:08 <bobsun> :) I'm new here
06:30:27 <kmc> welcome :)
06:30:44 <bobsun> thanks
06:30:57 * hackagebot xml-hamlet 0.0.2 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.0.2 (MichaelSnoyman)
06:36:47 <cheater> hey guys
06:36:51 <cheater> is anyone here from new york?
06:37:03 <kmc> i lived there for a while
06:39:24 <cheater> kmc: see other window
06:39:43 <qnikst> is there a way to use pattern matching in lambda expression, e.g. smth like filter (\(A b) -> .. ; \(B c) -> ..) ?
06:40:11 <Saizan> (\x -> case x of A b -> ..; B c -> ...)
06:40:38 <shachaf> Anonymous case expressions would be nice.
06:40:59 <Saizan> implement them!
06:41:00 <cheater> in what way anonymous?
06:41:29 <Saizan> that you don't have to mention x
06:41:49 <Saizan> (\case of A b -> ..; B c -> ...)
06:41:50 <qnikst> Saizan: thanx
06:42:00 <cheater> oh ok saizan
06:42:02 <Gracenotes> I've always wanted case of
06:42:06 <cheater> so he means point free i think?
06:42:28 <Gracenotes> in fact it's been implemented as a patch for GHC
06:42:41 <Saizan> but not merged?
06:42:44 <Gracenotes> but people propose their own syntax extensions
06:42:56 <Gracenotes> which are (obviously) inferior
06:43:26 <kmc> the patch is on ghc trac
06:44:10 <Gracenotes> it was implemented by Max Bolingbroke shortly after ICFP 2010
06:44:20 <Gracenotes> the haskell-cafe thread is called lambda-case/lambda-if
06:47:06 <benmachine> Gracenotes: obvious to everyone except the people actually implementing it, seems to me :P
06:47:32 <benmachine> (how inferior the other extensions are)
06:47:46 <kwos> aaaargh... I have this structure that contains a pointer to char. It's used as an argument to a function (holding hostname). I do something like withCString hostname $ \hostnamePtr -> alloca $ \mystructPtr -> poke mystructPtr $ default_options { hostname = hostnamePtr }
06:47:55 <Gracenotes> Saizan: also, I would get rid of the (\ at the beginning >_>
06:48:00 <kwos> and immediatelly after peek and peekCString and get segfault
06:48:23 <Gracenotes> I take it I'm not the only one who likes using explicit case expressions a lot
06:48:34 <benmachine> I like them too
06:49:22 <kwos> it seems that a simple pointer is not marshalled properly... just doing print hostnamePtr and print =<< hostname =<< poke myStructPtr shows that the address differs
06:49:25 <kwos> how to debug this?
06:50:38 <kmc> kwos, i'm a bit confused how it all fits together
06:50:45 <kmc> can you put something on hpaste?
06:51:55 <kwos> kmc unfortunately I can't :( the idea is that I have struct and its haskell representation and I marshall a pointer to char and when I unmarshall it straight after I get a different address to the one I've marshalled
06:51:56 <benmachine> kwos: where do you get your Storable instances?
06:52:26 <kwos> benmachine: I've written my own using hsc2hs
06:52:34 <benmachine> oh right
06:52:40 <benmachine> are you sure they are correct?
06:52:40 <kwos> it's a struct with bunch of ptr to char + ints
06:52:53 <kwos> from the looks of the resulting .hs file they seem correct
06:53:10 <kwos> other values (non ptr) get marshalled correctly
06:53:14 <kwos> like flags, etc
06:53:20 <kwos> maybe it's an alighnment issue?
06:53:25 <kmc> you can't hpaste your marshalling code or at least an approximation thereof?
06:53:30 <rwbarton> "print =<< hostname =<< poke myStructPtr" <- this seems to have one or more typos, or am I really confused?
06:53:54 <kmc> kwos, i might track this down using gdb, but i have more experience spelunking in Haskell code using gdb than most people
06:54:02 <kmc> it's not pretty
06:54:56 <kwos> rwbarton: I'm poking the structure there and pringing the value of hostname which is Ptr CChar, so I get the address back
06:55:29 <kwos> kmc: I can, but I need to re-type it :)
06:55:45 <rwbarton> surely you are peeking it?
06:56:25 <kwos> so when I do print =<< peek myStructPtr then all the values, except Ptr CChars look OK
06:56:51 <rwbarton> are you doing the print from within the withCString?
06:57:11 <rwbarton> (also how can you tell whether the Ptr CChars look right, I wonder?)
06:57:23 <kwos> yeah
06:57:31 <kwos> rwbarton: I allocate it earlier with withCString
06:57:36 <kwos> it's used as an argument to a function
06:58:15 <kwos> struct { char *hostname; ... } Options;
06:58:18 <kwos> this kind of thing
06:59:13 <kwos> so I have withCString "localhost" $ \hostnamePtr -> poke optsPtr $ default_options { hostname = hostnamePtr }
06:59:36 <kwos> if I print the hostnamePtr before marshalling and after I've written it to hostnamePtr they differ
06:59:43 <kwos> while they shouldn't
06:59:59 <kwos> I'm not copying data here after all, just writing a pointer value...
07:00:19 <rwbarton> so wait
07:00:33 <rwbarton> what exactly are you doing with these prints
07:00:57 <kwos> just seeing the values stored
07:01:05 <rwbarton> I mean, where are they in relation to withCString
07:01:15 <kwos> all within withCString
07:02:49 <kwos> bah, time to learn the joy of gdb debugging.. can't hpaste code, it will be difficult to describe exactly what's going on then
07:03:06 <benmachine> kwos: what does it print if you set hostname to a null ptr? something sensible?
07:03:33 <kwos> benmachine: let's see...
07:03:47 <benmachine> nullPtr
07:03:47 <rwbarton> also when you say "if I print the hostnamePtr before marshalling and after I've written it to hostnamePtr they differ", what are the two values?
07:04:48 <kwos> benmachine: hmm.. no, not sensible
07:04:54 <kwos> benmachine: some random address
07:05:11 <hpaste> Bfig pasted “conversion problem” at http://hpaste.org/50521
07:05:16 <kwos> rwbarton: just two addresses
07:05:30 <benmachine> kwos: do it a few times, see if it's always the same?
07:06:13 <kwos> benmachine: in the same seession? hold on...
07:06:53 <benmachine> kwos: in or not in
07:07:11 <kwos> in the same session they stay the same
07:07:15 <bfig> what is the problem saying? i don't understand
07:07:18 <benmachine> oh right
07:07:22 <jaspervdj> BCoppens: About your question in #hakyll yesterday... it shouldn't be very hard
07:07:30 <kwos> not in they differ, but stay the same across different writes
07:07:49 <bfig> i get 'impossible to infer type' on (1/6) which should be a Fractional a
07:09:26 <kwos> hmmm.. this is a bit odd... i write a null Ptr and get something like 0x5c0752000000000 and the next value (also ptr) has value 0x0000000005c07e520
07:09:32 <bfig> mmm nevermind i added Fractional a => ... and it worked
07:09:32 <kwos> must be a marshalling problem
07:09:41 <kwos> although other values are written and read correctly
07:10:10 <benmachine> kwos: is it possible that something somewhere thinks your pointers are 32 bits when in fact they are 64?
07:10:46 <benmachine> (or vice versa, possibly)
07:11:15 <kwos> benmachine: yes, it looks like that's the case
07:11:25 <kwos> thanks, I'll take it from here :)
07:11:32 <benmachine> :)
07:43:33 <augur> hmm
07:43:51 <augur> how are kleisli categories employed in current haskell idiom?
07:46:04 <kmc> augur, i've almost never seen them
07:46:15 <augur> kmc: ok
07:49:26 <jmcarthur> i uses <=< a fair bit, which is kleisli composition
07:49:28 <jmcarthur> *use
07:49:50 <jmcarthur> and of course return, which is kleisli identity
07:49:58 <jmcarthur> but i never use the Kleisli newtype
07:50:29 <kmc> yeah, (<=<) and return is a nice way to think about monads
07:50:32 <kmc> the rules are super nice to state
07:50:42 <kmc> i've never had a need for the Kleisli newtype, though
07:50:55 <kmc> i've not encountered much Category-generic or Arrow-generic code
07:51:07 <kmc> maybe i should absorb some of edwardk's libs
07:52:49 <mm_freak> given the existing combinators in Control.Monad the Kleisli newtype is seldomly useful
07:53:03 <mm_freak> it's only useful in some very rare cases, where you want to make use of the arrow syntax
07:53:06 <hpc> kmc: (<=<) and return cover the category, and there's other ways to accomplish the arrow functions
07:53:25 <hpc> like with Applicative
07:53:25 <kmc> arrow syntax is kinda fugly tbh
07:53:35 <kmc> for starters, if you use it, 95% of Haskellers will be unable to read your code
07:53:39 <hpc> arrow-do is incomprehensible
07:53:50 <kmc> and i doubt there's much monadic code where the arrow syntax is clearer
07:53:54 <hpc> (&&&) and (***) are the only good thing arrow gives imo
07:53:58 <mm_freak> kmc: depends
07:54:01 <kmc> given that you have "do", Control.Monad, Control.Applicative, etc. to play with
07:54:05 <kmc> i'd love to see a counterexample, though
07:54:08 <mm_freak> kmc: in FRP the arrow syntax is very great and elegant
07:54:11 <mm_freak> in AFRP that is
07:54:19 <kmc> sure, but in those cases the type isn't a monad, is it?
07:54:29 <mm_freak> yes
07:54:35 <mm_freak> yes = right
07:55:16 <mm_freak> in fact i haven't found a way to turn an AFRP arrow into a monad…  the ArrowApply instance seems impossible to write in any reasonable way
07:56:17 <kmc> i kind of thought the idea of Arrow is that you have more ability to inspect the structure of the computation
07:56:26 <kmc> except "arr" largely ruins that
07:56:40 <mm_freak> kmc: anyway, there are some monad families, which can have both a Monad and an Arrow instance
07:56:57 <mm_freak> for those the arrow syntax is available without wrapping everything in Kleisli
07:57:36 <mm_freak> kmc: it's not that bad actually…  the only problem with 'arr' is that functions are opaque
07:57:57 <kmc> that's the problem to which i referred
07:58:00 <mm_freak> so your ability to optimize arrow syntax is limited, but there is still a lot of opportunity
07:58:02 <kmc> i don't know of another one :)
07:59:13 <mm_freak> netwire still runs at 40k FPS for reasonably complicated systems =)
08:11:04 <maltem> Extremely OT: What is more fun, functional analysis or differential geometry?
08:11:24 <maltem> (choosing courses for next year)
08:14:54 <parcs> wrong channel
08:16:15 <maltem> obviously
08:17:08 <monochrom> I like differential geometry more
08:19:02 <maltem> From looking at it, so do I :)
08:20:27 <benmachine> functional analysis *could* be fun, depending on how it's taught
08:21:32 <maltem> I guess I should just find out who is the better lecturer
08:21:36 <benmachine> maybe
08:21:42 <benmachine> it also depends on what else you want to do
08:21:53 <benmachine> differential geometry is important in general relativity, I think?
08:25:27 <maltem> is it important somewhere within mathematics?
08:26:32 <benmachine> it's important to differential geometry? :P
08:26:41 <benmachine> I don't know I only did it last term
08:33:45 <jpcooper> it's also used in quantum physics
08:35:05 <confab> differential geometry?
08:35:17 <bfig> how can i extract from i between 1 and 18 the unique (a,b,c) in {1,2,3}x{1,2}x{1,2,3} such that a + (b-1)*4 + (c-1)*8 = i ?
08:36:17 <maltem> jpcooper, you mean FA? That is actually the only argument on my list for FA, even though I don't do any physics
08:36:44 <kmc> > [ head [ (a,b,c) | a <- [1..3], b <- [1..2], c <- [1..3], a + (b-1)*4 + (c-1)*8 == i ] | i <- [1..18] ]
08:36:46 <lambdabot>   [(1,1,1),(2,1,1),(3,1,1),*Exception: Prelude.head: empty list
08:36:54 <kmc> ;P
08:36:56 <monochrom> [ (i, a, b, c) | i<-[1..18], a<-[1..3], b<-[1..3], c<-[1..3], a+(b-1)*4+(c-1)*8=i ]  may be slow
08:37:10 <kmc> > [ (i, a, b, c) | i<-[1..18], a<-[1..3], b<-[1..3], c<-[1..3], a+(b-1)*4+(c-1)*8=i ]
08:37:11 <lambdabot>   <no location info>: parse error on input `='
08:37:18 <kmc> > [ (i, a, b, c) | i<-[1..18], a<-[1..3], b<-[1..3], c<-[1..3], a+(b-1)*4+(c-1)*8==i ]
08:37:18 <lambdabot>   [(1,1,1,1),(2,2,1,1),(3,3,1,1),(5,1,2,1),(6,2,2,1),(7,3,2,1),(9,1,1,2),(9,1...
08:37:30 <kmc> looks like there's none for 4 and two for 9 ;P
08:37:37 <bfig> mmm
08:38:01 <bfig> i need to map the {1,2,3}x{1,2,3}x{1,2} to 1..19
08:38:07 <bfig> and then get the inverse :D
08:38:51 <zachk> huh
08:39:15 <maltem> bfig, inverse?
08:39:42 <benmachine> but the size of {1,2,3}x{1,2,3}x{1,2} is 18
08:39:45 <bfig> yes, i give it the function value and i get back the three numbers
08:39:56 <benmachine> whereas {1..19} is size 19
08:39:59 <bfig> well, then 1..18
08:40:03 <bfig> >_>
08:40:04 <benmachine> oh
08:40:12 <benmachine> that's easier
08:40:16 <bfig> :D
08:41:15 <maltem> let f i = filter (\(a,b,c) -> a + (b-1)*4 + (c-1)*8 = i) $ liftM3 (,,) [1,2,3] [1,2] [1,2,3] in f 5
08:41:23 <maltem> > let f i = filter (\(a,b,c) -> a + (b-1)*4 + (c-1)*8 = i) $ liftM3 (,,) [1,2,3] [1,2] [1,2,3] in f 5
08:41:24 <lambdabot>   <no location info>: parse error on input `='
08:41:30 <rwbarton> you should be multiplying by numbers like 3 and 6
08:41:37 <maltem> hmf
08:41:50 <benmachine> > let toThings x = (a,b,c) where (a,z) = divMod x 2; (b,c) = divMod z 3 in map toThings [1 .. 18]
08:41:51 <lambdabot>   [(0,0,1),(1,0,0),(1,0,1),(2,0,0),(2,0,1),(3,0,0),(3,0,1),(4,0,0),(4,0,1),(5...
08:41:59 <benmachine> oh
08:42:04 <benmachine> right
08:42:05 <benmachine> silly me
08:42:13 <benmachine> > let toThings x = (a,b,c) where (a,z) = divMod x 9; (b,c) = divMod z 3 in map toThings [1 .. 18]
08:42:14 <lambdabot>   [(0,0,1),(0,0,2),(0,1,0),(0,1,1),(0,1,2),(0,2,0),(0,2,1),(0,2,2),(1,0,0),(1...
08:42:21 <benmachine> add some ones in
08:42:39 <bfig> what does divMod do?
08:42:59 <benmachine> divMod x y = (div x y, mod x y)
08:43:02 <kmc> gives you division and modulus (remainder)
08:43:12 <kmc> > divMod 29 2
08:43:13 <lambdabot>   (14,1)
08:43:17 <benmachine> modulus is something else, I reckon
08:43:23 <kmc> guess so
08:43:23 <benmachine> 'mod' is short for 'modulo'
08:43:26 <kmc> ok
08:43:37 <kmc> modulus is something different for complex numbers, anyway
08:44:14 <kmc> @check \m n -> (n /= 0) ==> let (d,r) = divMod m n in m == n*d + r
08:44:15 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:44:16 <lambdabot>                     (Test.QuickCh...
08:44:28 <kmc> @check \m n -> (n /= 0) ==> let (d,r) = divMod m n in m == (n*d + r)
08:44:29 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:44:29 <lambdabot>                     (Test.QuickCh...
08:44:31 <maltem> isn't the modulus the number modulo which you're calculating?
08:44:43 <kmc> @type (==>)
08:44:44 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
08:45:02 <kmc> @check \m n -> (n /= 0) ==> let (d,r) = divMod m n in m == (n*d + r)
08:45:03 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:45:03 <lambdabot>                     (Test.QuickCh...
08:45:03 <kmc> @more
08:45:09 <kmc> :(
08:45:13 * kmc gives up
08:46:52 <maltem> @check \m n -> (n /= 0) ==> let (d,r) = divMod m n in m == (n*d + r :: Integer)
08:46:53 <lambdabot>   No instance for (Test.QuickCheck.Testable
08:46:53 <lambdabot>                     (Test.QuickCh...
08:46:57 <bfig> lol i'm so stupid, i should first substract 1 then use 0,1,2
08:47:00 <bfig> that's my problem
08:47:12 <bfig> this is a stupid problem >_>
08:47:20 * bfig has slept 5 hours
08:47:35 * bfig after grinding 17 hours of work
08:47:42 <tech2> ugh :/
08:47:57 <tech2> I had a 36hr day once, god that was hell, all I got out of it was pizza at midnight.
08:48:18 <bfig> also, this is uni (or as i prefer, SPARTA)
08:48:27 <bfig> no monies for me D
08:48:27 <tech2> hah, that's not work :P
08:48:28 <bfig> :D
08:48:40 <bfig> really? try organizing 15 engineers :D
08:48:55 <tech2> I'd rather lick an electric fence
08:48:59 <maltem> Who works 36 hours if it is not uni?
08:49:09 <bfig> an entrepreneur =)
08:49:09 <identity_> tech2: I just came home from my motherland where I worked 780 hours over the course of 3 months :(
08:49:13 <kmc> i kinda liked the 24 hours awake, 12 hours asleep schedule
08:49:19 <identity_> 2 months*
08:49:21 <tech2> identity_: ugh :(
08:49:33 <identity_> 65 days or so
08:49:42 <maltem> ah, that other insane thing
08:49:49 <tech2> maltem: someone who's on their first job out of uni thinking it's a good idea for career advancement
08:49:51 <bfig> > 780/90
08:49:52 <lambdabot>   8.666666666666666
08:50:01 <bfig> that's... regular work :S
08:50:12 <ddarius> > 780/60
08:50:12 <lambdabot>   13.0
08:50:20 <bfig> ahh. that sounds more standard
08:50:30 <bfig> (for it :D)
08:50:36 <identity_> bfig: well
08:50:43 <identity_> we did it in 10 days at a time orso
08:50:45 <identity_> sometimes 11
08:50:48 <maltem> tech2, but as an employee? that's tough
08:50:58 <identity_> i had 18 hour workdays out of 24 hours sometimes
08:51:10 <tech2> maltem: I was young and it was a small business in deep trouble at the time
08:52:03 <jmcarthur> at my last job we were very strongly *discouraged* from working more than 40 hours in a week
08:52:27 <maltem> tech2, ah, that sounds more humane. I was thinking of a huge company and you trying to get noticed or something
08:52:32 <bfig> jmcarthur, you certainly don't live in UrUgUaY
08:52:43 <erus`> anyone offering a webserver/shell for haskell projects?
08:52:59 <tech2> jmcarthur: was this a sane company or one afraid of people requesting overtime?
08:53:35 <jmcarthur> tech2: the pay was flat, hourly. there was no overtime
08:53:40 <jmcarthur> even if you worked more than 40
08:53:51 <jmcarthur> (it was all contracted work, so that scheme makes sense)
08:53:54 <tech2> jmcarthur: bravo them then I guess :)
08:56:32 <maltem> erus`, there are hackage, patch-tag, code.haskell.org - not sure what you mean by shell
08:56:55 <erus`> something i can run snap on
08:58:06 <maltem> oh, then the answer is probably no
08:58:12 <erus`> :(
08:58:19 <erus`> i need to build a low cost server
08:59:02 <maltem> You'd be probably best served by some cheap vhost
08:59:53 <maltem> if ~8 qualifies as low-cost
09:02:12 <maltem> erus`, if you have a really cool project then you could try to talk me into offering sub-hosting :p
09:02:44 <monochrom> amazon cloud is pretty cheap
09:02:50 <erus`> maltem: just messing about with a personal website for now
09:03:20 <kmc> Amazon has a free option
09:03:27 <monochrom> also google for "free shell" if you like
09:03:53 <monochrom> no, amazon does not have a free option, only a 1st-year-free offer
09:04:37 <maltem> maybe a disadvantage of amazon is that it's one of those mighty, potentially evil companies
09:05:05 <benmachine> as opposed to one of those little, potentially evil companies
09:05:24 <maltem> exactly :p
09:05:25 <monochrom> every successful company becomes evil
09:06:21 <monochrom> so your only choice is (winner today, evil tomorrow) vs (loser today, no tomorrow). I believe the wise choice is obvious
09:07:08 <atoll> hi
09:07:19 <atoll> Is there a way to build a lifo with lists ?
09:07:42 <monochrom> [a] is lifo
09:07:48 <Botje> you mean a queue?
09:07:53 <Botje> oh no, a stack
09:07:54 <atoll> yes
09:07:54 <Botje> buh
09:07:57 <maltem> monochrom, the second, because it can be extended to (loser today, another loser tomorrow) as opposed to (winner today, another company tomorrow, but the evil still have you data)
09:08:05 <Botje> lifo is a stack.
09:08:06 <atoll> No a queue
09:08:10 <Botje> that's fifo.
09:08:24 <atoll> No ?
09:08:27 <Botje> yes?
09:08:30 <parcs> maybe?
09:08:43 <atoll> ups u right
09:08:53 <monochrom> hmm guerilla customer :)
09:08:53 <maltem> now all go one step higher and be enlightened
09:09:07 <Botje> there's a naive way of implementing a queue using a list
09:09:20 <Botje> with enqueue x q = x:q
09:09:34 <Botje> and dequeue q = (last q, init q)
09:09:40 <Botje> but you'll find this is dog slow.
09:10:02 <atoll> Is there a way to build a fifo with lists ?
09:10:18 <Botje> are you not reading what I am typing?
09:10:18 <atoll> ups u just said it
09:10:34 <maltem> atoll, sometimes a queue is done with a pair of lists
09:10:49 <atoll> I am, but im on a super small screen, hard to read everything
09:10:51 <bfig> a stack is just a list with two operations, push and pop. push x xs = x:xs, pop (x:xs) = (x,xs)
09:10:58 <monochrom> use two lists for a queue. amortized constant time. to enqueue: cons to the 2nd list. to dequeue: head of the 1st list, or if that's empty, reverse the 2nd list, make it the 1st list, try again
09:10:58 <atoll> sorry
09:11:30 <bfig> damn i'm sleepy.
09:11:57 <monochrom> with laziness you can get constant time, but it's more elaborate
09:12:37 <monochrom> err, with laziness you can get constant time using yet another method, but it's more elaborate
09:13:21 <Cale> Finger trees solve a lot of problems handily :)
09:13:28 <jmcarthur> Data.Sequence ftw
09:13:53 <jmcarthur> i'm glad somebody else took on the job of writing such code for me
09:13:57 <Cale> Yeah, if you want a decent queue in Haskell right now, I recommend just using Data.Sequence.
09:14:36 <Cale> PSQueue is also a really good priority search queue that more people should know about.
09:14:38 <jmcarthur> although honestly i think the overall throughput of the two-lists version might be better than Data.Sequence
09:14:45 <Cale> (I think it ought to be in containers)
09:16:14 <jmcarthur> i honestly have only used priority search queues in haskell maybe three times
09:16:28 <jmcarthur> seems like something i would use more often...
09:16:31 <monochrom> actually, s/laziness/full control of laziness and eagerness/
09:17:16 <jmcarthur> i guess i haven't done tons of, say, graph algorithms
09:18:40 <erus`> > 'test blah'
09:18:41 <lambdabot>   <no location info>:
09:18:41 <lambdabot>      lexical error in string/character literal at chara...
09:18:53 <erus`> in loadSnapTH 'applicationInitializer 'site watchDirs)
09:19:06 <erus`> gedit is formatting that wrong
09:19:12 <Cale> erus`: oh, lovely
09:19:18 <monochrom> PSQueue can be used to expire bans and also allow manual unbans. using time as priority, you can quickly locate the next ban to expire and when. using search, you can quickly locate the ban to be manually unbanned
09:19:18 <erus`> i get a big red box around the '''s
09:19:21 <Phyx-> > :! uname -a
09:19:22 <lambdabot>   <no location info>: parse error on input `:!'
09:19:34 <Cale> erus`: TH steals initial single quote for quoted names
09:19:56 <Cale> erus`: (that is, in all cases where it doesn't parse as a character)
09:19:59 <erus`> is that legal?
09:20:09 <Cale> yes
09:20:22 <erus`> > lex 'elo 'elo
09:20:23 <lambdabot>   <no location info>:
09:20:23 <lambdabot>      lexical error in string/character literal at chara...
09:20:25 <Cale> Because it's part of the compiler, it can do whatever it wants :P
09:20:31 <erus`> > lex "\'elo \'elo"
09:20:33 <lambdabot>   []
09:20:34 <Phyx-> Cale: hehehe
09:20:37 <erus`> > lex "'elo 'elo"
09:20:39 <lambdabot>   []
09:20:59 <erus`> so i have to submit a patch for gedit?
09:21:11 <Cale> That might be nice :)
09:21:12 <Botje> gedit has no way of knowing you're invoking TH :)
09:21:26 <Botje> unless you're in a TH block, maybe
09:21:37 <Cale> Well, there's a way to determine whether something is a valid character constant or not.
09:21:39 <Phyx-> depends how they do hilighting
09:21:43 <maltem> erus`, well TH syntax isn't supported by most editors. It changes all the time anyways
09:22:25 <erus`> snap init project is about 1000 lines of cruft
09:22:30 <Phyx-> erus`: could you paste the code it's coloring wrong? i wanna test something
09:22:34 <erus`> is there an 'init minimal'
09:22:39 <hpc> > lex "eh? 'wut'"
09:22:40 <lambdabot>   [("eh","? 'wut'")]
09:22:46 <hpc> > lex "'w'"
09:22:47 <lambdabot>   [("'w'","")]
09:22:52 <parcs> erus`: yes, it's called don't use scaffolding :P
09:23:07 <maltem> erus`, use a hello-world example from the docs instead?
09:23:21 <hpaste> erus` pasted “gedit fuckerupper” at http://hpaste.org/50522
09:23:48 <maltem> assuming there is one
09:23:48 <Cale> erus`: You can probably get around that...
09:23:59 * Phyx- starts his current build of VSH
09:24:11 <parcs> is gedit highlighting what's between the apostrophes as if it were a string?
09:24:57 <erus`> yeah everything after the a until th closing ' is highlighted red lik an error
09:25:07 <Cale> I believe that  'applicationInitialize = mkName "applicationInitializer"
09:25:12 <Cale> er, missed an r
09:25:23 <Cale> So you could try that.
09:25:48 <erus`> i can build an atom dual core 64bit box for £150
09:25:54 <Phyx-> *waits for 14 sub projects to build*
09:25:57 * hackagebot swish 0.6.0.0 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.6.0.0 (DouglasBurke)
09:27:25 <Phyx-> heh, burning dvds and watching a video sure slows down my pc
09:28:46 <parcs> erus`: you don't have a spare computer lying around?
09:29:00 <erus`> nope
09:29:20 * Phyx- is still waiting on the compile
09:29:22 <Phyx-> sheesh
09:29:29 <erus`> actually we have one at work
09:29:54 <erus`> but i dont want my crap on the internal server
09:30:10 <erus`> *network
09:33:32 <ezyang> @seen edwardk
09:33:33 <preflex>  edwardk was last seen on #haskell 17 hours, 1 minute and 56 seconds ago, saying: * edwardk &
09:33:33 <lambdabot> Unknown command, try @list
09:37:21 <Phyx-> lol
09:37:24 <Phyx-> that's interesting
09:37:31 <Phyx-> my highlighter doesn't touch it at all
09:41:18 <Phyx-> erus`: http://i52.tinypic.com/vh95lg.png lol, prolly not right either
09:42:29 <maltem> Phyx-, these might all be not-in-scope errors?
09:43:05 <monochrom> the not-in-scope errors are fine. they are deliberately not in scope
09:43:37 <Phyx-> maltem: i know, they are. I'm just refering to how the ' and the things between them was colored
09:44:33 <bfig> how can i convert a matrix of Fractional a to a (><) to operate with them?
09:44:48 <maltem> I'd be ok with the way it is colored
09:45:11 <maltem> bfig, what library is this?
09:45:22 <bfig> hmatrix
09:45:50 <bfig> module Data.Packed.Matrix
09:46:37 <maltem> ah, (><) is that matrix-from-list function
09:46:49 <maltem> but then I don't understand what you want to convert to
09:46:50 <Phyx-> maltem: there is a coloring error there though, the closing ")" isn't colored brown
09:47:15 <maltem> point
09:47:24 <bfig> yes, i have a list with  (0,0), (0,1), (0,2)... (1,0),(1,1)... (19,19)
09:47:48 <bfig> so as i understand i should be using (19><19) myList
09:48:33 <maltem> looks fine?
09:48:45 <bfig> my list is made of fractionals
09:49:12 <maltem> ahh, now I got you
09:49:18 <bfig> bah now it worked :D
09:50:27 <maltem> Fractional is a type class, you better choose your exact number type when you work with hmatrix
09:51:10 <TotoTitus> Mentlegen
09:52:38 <Phyx-> maltem: lol, i'll add it to my todo list with a low priority
09:54:54 <maltem> bah, I should get into a habit of preparing meals in time, rather than when I'm already totally hungry
09:55:32 <TotoTitus> because you eat the edible ingridients prematurely, yes?
09:55:44 <Phyx-> maltem: i'm in the same habbit
09:55:49 <Phyx-> i tend to not eat even then
09:56:19 <ddarius> Think of how much money you save eating only once a month.
09:57:00 * maltem disregards all advice and starts cooking :p
09:57:23 <TotoTitus> and entropy caused to the universe
09:57:48 <TotoTitus> by turning regular energy into heat
09:58:15 <Phyx-> lol
09:58:21 <Phyx-> if one could live off coding...
09:59:32 <ddarius> TotoTitus: All you need to do is know everything about everything and then the entropy of the universe will be zero.
10:01:36 <TotoTitus> man, i rambled something simple, and then i got smacked by someone who actually knows physics ^^
10:01:54 <TotoTitus> as in, i have no idea how information leads to zero entropy
10:04:01 <bfig> finally, how can i access the value of the nth element of the matrix?
10:04:11 <bfig> actually of the Data.Packed.Vector
10:07:34 <rostayob> I should be able to write haskell code with UTF-8 symbols right?
10:07:42 * bfig just found it (@>n)
10:08:15 <identity_> rostayob: aye
10:08:19 <rostayob> I'm asking because if I try to use subscripts ghc goes "lexical error at character '\8321'"
10:08:22 <identity_> afaik & iirc
10:08:28 <identity_> huh
10:08:39 <rostayob> (g₁)
10:08:51 <parcs> > let g₁ = () in g₁
10:08:51 <identity_> > let æþö = "foo" in æþö
10:08:52 <lambdabot>   "foo"
10:08:52 <lambdabot>   <no location info>: lexical error at character '\8321'
10:09:05 <rostayob> eh!
10:09:14 <identity_> rostayob: lambdabot doesn't mind
10:09:18 <rostayob> it does
10:09:31 <rostayob> > let g₁ = 0 in g₁
10:09:32 <lambdabot>   <no location info>: lexical error at character '\8321'
10:09:40 <identity_> rostayob: that is a question sign on my side
10:09:47 <identity_> it's probably your terminal or whatever
10:09:48 <identity_> irc client
10:09:58 <parcs> :t generalCategory
10:09:59 <lambdabot> Char -> GeneralCategory
10:10:02 <parcs> > generalCategory '₁"
10:10:04 <lambdabot>   <no location info>:
10:10:04 <lambdabot>      lexical error in string/character literal at chara...
10:10:04 <parcs> > generalCategory '₁'
10:10:06 <lambdabot>   OtherNumber
10:10:08 <identity_> my ssh client is utf-8 capable
10:10:27 <identity_> and it's displaying the character you're typing as a ? sign
10:10:47 <rostayob> identity_: well the file is UTF-8
10:10:49 <parcs> it's a subscript 1
10:11:01 <identity_> rostayob: what about your terminal? you using vim by chance?
10:11:05 <identity_> or some other terminal editor
10:11:06 <geheimdienst> > let a² = 0 in 0
10:11:07 <lambdabot>   <no location info>: lexical error at character '\178'
10:11:08 <bfig> maltem, how do i multiply matrices with <> ?
10:11:13 <rostayob> and emacs & gedit recognise it (I'm using emacs tex input mode)
10:11:23 <rostayob> identity_: no but I'm using weechat in a terminal
10:11:28 <bfig> it says it is out of scope but i have Data.Packed, Data.Packed.Matrix, Data.Packed.Vector
10:11:28 <ddarius> > isNumber '₁'
10:11:29 <lambdabot>   True
10:11:48 <geheimdienst> > generalCategory '2'
10:11:49 <lambdabot>   DecimalNumber
10:11:53 <geheimdienst> > generalCategory '²'
10:11:54 <lambdabot>   OtherNumber
10:12:03 <identity_> hmm
10:12:08 <identity_> why can't I see that character
10:12:13 <identity_> never had a problem with utf8 before
10:12:19 <identity_> hmm, maybe it's my locale on this shell or something
10:12:22 <identity_> can that be?
10:12:47 <rostayob> geheimdienst: ok so it works as a character literal but it doesn't in the source code?
10:13:07 <ddarius> identity_: Maybe your font doesn't contain that character.
10:13:12 <identity_> ddarius: hmm
10:13:13 <identity_> perhaps
10:13:29 <identity_> rostayob: well, seeing as lambdabot does0n't mind þæö
10:14:24 <rostayob> identity_: yeah but I'm pretty sure that's an ordinary UTF-8 char...
10:14:38 <geheimdienst> rostayob: yeah. not everything you can put in a String can also be a function name. e.g. you can't have ) or . in a function name either
10:15:02 <identity_> rostayob: http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource
10:15:04 <rostayob> geheimdienst: ok so there is a range of valid characters? like only the letter-like?
10:16:04 <geheimdienst> i guess the rule is: must start with a letter, then only letters or numbers
10:16:11 <geheimdienst> > generalCategory 'f'
10:16:13 <lambdabot>   LowercaseLetter
10:16:32 <rostayob> geheimdienst: well isn't ₁ a number?
10:16:41 <rostayob> > generalCategory '₁'
10:16:42 <lambdabot>   OtherNumber
10:16:43 <geheimdienst> not in that sense :)
10:16:47 <geheimdienst> > generalCategory '2'
10:16:48 <rostayob> > generalCategory '1'
10:16:49 <lambdabot>   DecimalNumber
10:16:49 <lambdabot>   DecimalNumber
10:16:57 <rostayob> mah, ok lol
10:17:12 <incluye> > generalCategory '&'
10:17:13 <geheimdienst> > let a² = 0 in 0
10:17:13 <lambdabot>   OtherPunctuation
10:17:14 <lambdabot>   <no location info>: lexical error at character '\178'
10:17:21 <geheimdienst> i couldn't use ² either
10:17:40 <incluye> generalCategory '▁'
10:17:47 <incluye> > generalCategory '▁'
10:17:48 <lambdabot>   OtherSymbol
10:17:55 <incluye> impressive
10:18:21 <KirinDave> Hey folks
10:18:22 <mistertim> \msg lambdabot @pf \s o -> s  - size o
10:18:34 <mistertim> oops, sorry all
10:18:44 <ddarius> Yes, the report says that a "digit" is a Unicode decimal digit.
10:18:50 <KirinDave> Earlier in the year I read a paper which was basically a manual and description for the different types of deterministic and native concurrency tools in haskell
10:18:58 <KirinDave> I lost the link. Does anyone have it on hand?
10:18:58 <ddarius> So g₁ is not a valid identifier.
10:19:58 <rostayob> mh ok
10:20:00 <rostayob> but I can do
10:20:06 <rostayob> > type Iṅt = String
10:20:07 <lambdabot>   <no location info>: parse error on input `type'
10:20:09 <rostayob> that'be great
10:20:59 * hackagebot hledger-interest 1.0 - computes interest for a given account  http://hackage.haskell.org/package/hledger-interest-1.0 (PeterSimons)
10:21:15 <sm_> woah
10:22:24 <ddarius> rostayob: You could make a patch to the GHC lexer to allow these numbers as there is little reason to exclude them and try to argue that they should be included.  The code change is probably trivial.
10:22:37 <KirinDave> Dang I cannot find this paper...
10:22:54 <rostayob> ddarius: oh ok! I'll what I can do!
10:27:44 <erus`> @hoogle route
10:27:45 <lambdabot> Network.Socket AF_ROUTE :: Family
10:27:45 <lambdabot> Network.Socket.Internal AF_ROUTE :: Family
10:27:45 <lambdabot> Network.Socket DontRoute :: SocketOption
10:35:59 * hackagebot hledger-interest 1.1 - computes interest for a given account  http://hackage.haskell.org/package/hledger-interest-1.1 (PeterSimons)
10:36:49 <hpaste> def pasted “operator” at http://hpaste.org/50523
10:37:11 <gwern> @quote
10:37:11 <lambdabot> SPJ says: Haha this is good news, I have slipped functional programming into your brain without you realising it is something very weird.
10:38:03 <bfig> i have a Vector Double v of Data.Packed.Vector and one Matrix Double m from Data.Packed.Matrix, to multiply them i need to do m<>v  right?
10:43:42 <Cale> bfig: yes, that's right
10:44:07 <bfig> Cale, it's not working, where do i need to import it from? i've tried Data.Packed
10:44:19 <Cale> Maybe Numeric.Container
10:45:31 <bfig> well, that imported something :D. thanks :)
10:45:47 <Cale> http://hackage.haskell.org/packages/archive/hmatrix/0.11.0.4/doc/html/Numeric-Container.html#v:-60--62-
10:46:07 <Cale> The annoying thing is that this Mul class is not exported, and so not documented.
10:46:28 <Cale> and so you can't get here in the documentation easily by following links :P
10:46:36 <bfig> >_>
10:46:59 <bfig> i just saw that Data.Packed had a <> operation but Mul wasn't imported when i did Data.Packed(Mul) so i had no idea
10:47:18 <Cale> I don't really understand the reasoning behind it
10:47:28 <bfig> you're right in that the documentation is a bit hard to read, but i attributed it to my own newbiness
10:51:04 <erus`> @hoogle <|>
10:51:05 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
10:51:05 <lambdabot> Text.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
10:51:05 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
10:52:25 <erus`> how do i specify a literal bytestring?
10:52:28 <erus`> > "Hello" :: ByteString
10:52:29 <lambdabot>   Not in scope: type constructor or class `ByteString'
10:52:48 <erus`> > import Data.ByteString
10:52:50 <lambdabot>   <no location info>: parse error on input `import'
10:52:55 <erus`> @import Data.ByteString
10:52:55 <lambdabot> Unknown command, try @list
10:53:00 <erus`> fffuuuuu
10:53:09 <Cale> erus`: You either use the function pack
10:53:23 <Cale> or I think there's an IsString instance hanging around somewhere
10:53:39 <Cale> (which calls pack for you, but you need to turn on an extension)
10:53:42 <erus`> in the snap example they use "this"
10:53:44 <Cale> yeah
10:53:50 <erus`> overloaded strings?
10:53:56 <Cale> Yeah
10:54:03 <erus`> thanks
10:54:05 <Cale> {-# LANGUAGE OverloadedStrings #-}
10:55:07 <erus`> yey i got it working without the snap init rubbish :)
10:55:11 <erus`> thanks Cale
10:56:30 <bfig> Cale, i'm having trouble multiplying, care to look at my code?
10:56:39 <Cale> bfig: sure
10:56:58 <Cale> bfig: Because <> is very polymorphic, you may have to say exactly what result type you want.
10:57:05 <hpaste> bfig pasted “mult problem” at http://hpaste.org/50524
10:57:21 <bfig> it returns an array of zeros which is not reasonable
10:58:03 <jajamana> I cant't a test suite to run using cabal test, and Test-Suite section using exitcode-stdio-1.0. I don't get any useful error message even if I completely mess up the "main-is" line. I am following http://www.haskell.org/cabal/release/cabal-1.10.1.0/doc/users-guide/#test-suites
10:58:30 <Cale> one moment while I installl hmatrix :)
10:58:36 <jajamana> Any other examples of Test-Suite I can look at?
10:58:58 <dcoutts> jajamana: you're configureing with --enable-tests ?
10:59:50 <bfig> Cale, ty :)
11:00:04 <parcs> benmachine: did you ever get ncurses to build on arch?
11:00:04 <Cale> lol, just noticed the extra l
11:00:21 <benmachine> parcs: I have nyan working so I assume I must have done somehow
11:00:44 <benmachine> I don't remember what I did though :)
11:00:49 <jajamana> dcoutts: yes, I try to first install the lib with "cabal install --prefix=$HOME --user", when I try to configure --enable-test prior to that, cabal test tells me to configure again...
11:00:53 <hpaste> bfig pasted “mult problem” at http://hpaste.org/50525
11:01:07 <robnormal> Does anyone know if there are comparison-based sorting algorithms that will work with only partial ordering information?
11:01:33 <jajamana> dcoutts: So I suspect the configure does not take when using --user?
11:01:37 <robnormal> (cs question, I know, but the smartest CS people I know are in this chat room)
11:01:59 <dcoutts> jajamana: you need to cabal configure --enable-tests; cabal build; cabal test.  That's it. You do not need to use cabal install.
11:02:10 <bfig> robnormal, what do you want to get? if you have a partial order you won't expect a list
11:02:57 <ddarius> bfig: Have you displayed leMatrizTran to make sure that it has the value you expect?
11:03:14 <bfig> ddarius, i've displayed the thing from which it is constructed and it is reasonable
11:03:21 <Cale> bfig: So, what is the problem?
11:03:21 <bfig> at least it is non zero, with the first row nonzero
11:03:26 <bfig> maybe i need to transpose it?
11:03:35 <Cale> What's coming out 0 which shouldn't be?
11:03:58 <bfig> it's an allegedly stochastic matrix so it should always return something of |x| = 1
11:04:27 <ddarius> Well multiplying by v on the right will simply select the first column.
11:04:47 <bfig> ok, then i guess i wrote the numbers flipped
11:04:58 <jajamana> dcoutts: Thanks, that worked!
11:05:36 <robnormal> bfig: you're right. The problem I'm really trying to solve is this - sort a list of options for a user by asking the user to compare pairs of options. So the goal is to create a complete ordering with the fewest number of questions.
11:05:56 <ddarius> If you have an entire column or row of zeroes, then your matrix is singular and you certainly will have non-zero values that get mapped to zero.
11:06:14 <parcs> benmachine: does `UI.NCurses.runCurses (return ())` in ghci work for you?
11:06:55 <benmachine> parcs: Loading package ncurses-0.2 ... can't load .so/.DLL for: libpanel.so (-lpanelw: cannot open shared object file: No such file or directory)
11:06:56 <Cale> robnormal: You're looking for a minimal sorting network, I guess.
11:06:57 <jajamana> dcoutts: Well not really, anyway, intentionally failure PASSes ... bad
11:08:18 <dcoutts> jajamana: I don't understand, can you explain what you expect and what you actually get?
11:08:26 <baguasquirrel> robnormal: this sounds less like a sorting question and more like a constraint solving question
11:09:11 <bfig> robbert, finding the question which answer minimizes the amount of choices remaining should be a reasonable algorithm
11:09:13 <robnormal> Cale: reading about sorting networks now...
11:09:30 <Cale> robnormal: Or you could just do something like quicksort or mergesort or whatever your favourite sorting algorithm is, but rather than taking the comparison result from some hard-coded thing, you can just ask the user (and remember their answers)
11:09:34 <bfig> (actually which minimizes the expected value of remaining questions)
11:10:17 <robnormal> bfig: that's what I'm looking for. I was wondering if it was a problem that had already been solved.
11:10:41 <bfig> robnormal, there is an internet geenie which guesses in 20 questions a famous character from the world
11:11:04 <jajamana> dcoutts: I use HUnit.runtTestTT and I expect "cabal test" to fail when it fails
11:11:15 <bfig> robnormal, with just 20 questions (or less) the genie homes into the right answer or comes very close
11:11:28 <Cale> If a sorting algorithm is good, then it should produce decent results when used in this way
11:11:30 <bfig> taking thousands of personalities of all kinds
11:11:32 <dcoutts> jajamana: cabal test will fail when your test program returns a non-0 exit code.
11:11:44 <jajamana> dcoutts: Do I have to do the exit code myself, then...?
11:11:57 <dcoutts> jajamana: so it is your responsibility to make sure that it produces a non-0 exit code when the test suite has in fact failed
11:12:12 <jajamana> dcoutts: Ok
11:12:27 <Cale> Of course, if you have n things, there are n! permutations you're searching through regardless.
11:12:28 <bfig> you could use an automated learner that computes this values for minimizing the expected number of questions by correlating the answers, you can go really fancy with it
11:12:29 <spetrea> http://southernct.edu/~brin/images/pi.jpg
11:12:32 <robnormal> Cale: that was the idea I was going on, but then I was not entirely sure about it.
11:13:21 <bfig> but it will amount to the same: pick weights, write objective function, generate training instances, improve performance
11:13:35 <buntfalke> Hi
11:13:48 <robnormal> bfig: that's bery interesting. Of course, I was hoping to start with a simple system that would work without external data
11:13:50 <bfig> Cale, so if i transpose my matrix with ctrans shouldn't that be enough?
11:13:57 <Cale> Of course, just asking the user to pick weights and then sorting by the weights, and asking more questions on a tie would be pretty efficient.
11:14:24 <Cale> bfig: I don't understand the problem with the existing program because I don't understand what the program is intended to be computing.
11:14:37 <Cale> (and it's not a type error or anything like that :)
11:14:44 <buntfalke> Regarding report "6.3.2 The Ord Class": Why is it designed based on == and <= and not == and <? Read: Why not define compare with < instead of <=?
11:15:09 <Cale> buntfalke: Normally you define everything else with compare
11:15:09 <robnormal> Cale: that's true, but I find weights are difficult to for people to guess at. They tend to make inconsistent estimates of value
11:15:20 <bfig> Cale, the first part of the program creates a stochastic matrix with the transition probabilities from state i to state j, it is a markov chain transition matrix
11:15:53 <bfig> Cale, after that, i approximate the expected value (although now that i think of it, it computes absolute gibberish)
11:16:35 <benmachine> buntfalke: because then you'd be in here asking us why we didn't use <= and == :P
11:16:54 <buntfalke> benmachine: No. I don't see the point of testing for <= once == is ruled out.
11:17:06 <Tomsik> because <= is used more widely in mathematics and == can be derived from <=
11:17:11 <Tomsik> that'd be my guess
11:17:18 <bfig> the transition matrix is leMatrizTran. you can see it is nonzero by looking how i built it, it's just an array of [(i,j)| i<- [..], j[..]] where i map a function that computes the transition probability i->j Cale
11:17:20 <buntfalke> Cale: I don't see the point of checking for "less or equal" and not just testing for "less", after inequality is already certain.
11:17:49 <benmachine> buntfalke: I suspect that in practice neither of <= or < is more difficult to calculate
11:17:51 <Cale> buntfalke: Usually knowing that two things aren't equal doesn't help at all in determining their order.
11:18:04 <buntfalke> Tomsik: == cannot be decided if all you know is the truth-value of <=.
11:18:09 <Cale> buntfalke: (in terms of the complexity of that operation)
11:18:19 <Cale> Though that's not universally true, I guess.
11:18:29 <benmachine> Tomsik: a == b = a <= b && b <= a
11:18:35 <benmachine> er
11:18:39 <benmachine> buntfalke: that
11:18:41 <roconnor> though with real number knowing that they are unequal turns the problem of determining their order from undecidable to decidable.
11:18:50 <bfig> Cale, this is the sentence that creates the i,j entries: map cadena [ (i,j) | i <- [0..18], j <-[0..18] ]
11:18:59 <Cale> roconnor: right, I was just thinking that after I wrote that :)
11:19:01 <roconnor> *CReal numbers
11:19:08 <bfig> if you execute that in ghci you can see what's on the matrix. then it uses the constructor (19,19)
11:19:27 <buntfalke> benmachine: True, but look at report 6.3.2, you'll see this property isnt relevant to the question -- unless i totally miss the point.
11:19:47 <Cale> bfig: right
11:20:13 <benmachine> buntfalke: you're probably right, but I still don't see that < is particularly more natural than <= or vice versa
11:20:14 <bfig> Cale, then it multiplies by a stochastic vector (1,0....)
11:20:19 <buntfalke> benmachine: regarding difficulty to compute: yes, i suspect the compiler to optimize that anyway, but I suspect someone to have had something in mind when they did it the way it is :-)
11:20:57 <benmachine> buntfalke: what do you mean by the compiler optimising it? frequently it actually isn't a harder computation
11:21:00 <Cale> bfig: and I suppose you'd apply some power of the matrix to the initial state and see where things settle down?
11:21:06 <buntfalke> benmachine: because it would be the statement would be more obvious and clear: we test for equality, next we test for less-than.
11:21:31 <Athas> What's a good way to structure the tests of my project?
11:21:58 <benmachine> buntfalke: I suspect that not too much thought goes into it on the grounds that < and > and <= and >= are all basically equivalent in terms of power, so you need one and only one
11:22:06 <bfig> Cale, yes, that's the idea. the list leListEv is a recursive way to do that, it passes how many steps have already gone through, the current state vector and the current accumulated ev
11:22:08 <Cale> buntfalke: It would probably be possible to define them all in a cycle, but in practice, you only ever define compare.
11:22:13 <buntfalke> benmachine: I mean that the "or are they equal?" part of the "is it less or are the equal?"-question will never come to be evaluated.
11:22:19 <buntfalke> In other words: It's a piece of dead code.
11:22:40 <benmachine> buntfalke: that's assuming that less-than-or-equal is implemented as first checking less than, then checking equal
11:22:45 <Cale> buntfalke: That's assuming that there is an "are they equal" part of the "are they less than or equal" test.
11:22:58 <Cale> But there usually isn't.
11:23:05 <bfig> i need to actually multiply by an attenuating constant, which is 'hasn't arrived yet'
11:23:08 <benmachine> buntfalke: but you might equally well implement < by first checking if <= holds, then checking == doesn't hold
11:23:23 <buntfalke> benmachine: Well, exactly that order is enforced, since the pattern matching test for == will have been done already by the time you reach the <= test
11:23:43 <buntfalke> Cale: i see
11:23:45 <bfig> that is basically 1-(st@>18), that is the probability it doesn't reach the state
11:23:53 <benmachine> yeah, what cale said is what I meant
11:24:08 <bfig> or maybe just zero the last vector coordinate and therefore reduce the vector modulus
11:24:27 <buntfalke> benmachine: Ah, so we talked at cross purposes.
11:24:27 <bfig> yes, gonna do that. in any case, the first multiplication zeroes the vector and then it is useles to continue
11:24:40 <buntfalke> Cale, benmachine: thanks :-)
11:25:05 <benmachine> you could for example do a <= b = not (isNegative (b - a))
11:25:30 <ghartshaw> @pl h x y = map fst $ filter (f x) (g y)
11:25:30 <lambdabot> h = (map fst .) . (. g) . filter . f
11:26:17 <buntfalke> benmachine: oh. quite true! I kind of missed that there does not usually have to be two seperate "less than" and "equal to" parts of the "less or equal"-question
11:27:04 <benmachine> I mean you could equally do a < b = isNegative (a - b) but that's not the point :P
11:27:43 <Cale> yeah, often <= can also be defined in terms of other <= questions
11:29:34 <bfig> Cale, so you see, how the problem is not related to my representation but with using something wrong? the first matrix product should give the vector map cadena [ (0,j) | j <-[0..18] ]
11:29:56 <buntfalke> Cale: What would be a good example? I can see there's the possibility now, but I there's nothing common quite obvious to me yet...
11:31:20 <Cale> buntfalke: like  (x:xs) <= (y:ys) = x <= y && xs <= ys
11:31:41 <Cale> (obviously, you also need some base cases to complete that definition)
11:32:12 <bfig> Cale, take 10 preprSol shows that the matrix multiplication actually goes right
11:32:19 <Cale> Of course, it's more efficient in general to write   compare (x:xs) (y:ys) = compare x y `mappend` compare xs ys
11:32:32 <Cale> But that's another matter :)
11:32:33 <buntfalke> Cale: but this would work equally well for < instead of <=. I searched for an example where <= is far easier to implement or compute than <=
11:32:42 <Cale> buntfalke: They're usually about the same
11:33:07 <Cale> But <= has nicer properties as a relation (it's reflexive, which is usually considered desirable)
11:33:45 <buntfalke> agreed, but how does reflexivity come in handy for implementing compare?
11:34:12 <buntfalke> "(x:xs) < (y:ys) = x < y && xs < ys" seems just as simple.
11:35:28 <Twey> buntfalke: [] < []?
11:36:05 <buntfalke> Aaaaaaaah *facepalm*
11:36:20 <Twey> ☺
11:36:24 <buntfalke> :-D
11:36:27 <buntfalke> thanks Twey...
11:40:48 <jmcarthur> !decide ramen or bacon and eggs
11:40:56 <jmcarthur> no fedaykin :(
11:41:02 <ddarius> jmcarthur: Are you in Japan?
11:41:08 <jmcarthur> oh shoot
11:41:13 <jmcarthur> wrong channel :)
11:41:18 <Twey> Heh.
11:41:23 <jmcarthur> i was looking for a bot in another channel
11:41:27 <jmcarthur> sorry
11:41:27 <Twey> ‘Oh shoot, I'm meant to be in Japan!’
11:41:30 <ciaranm> yeah, haskell doesn't support randomness!
11:41:41 <ciaranm> if you asked lambdabot to decide it would always give you the same answer
11:53:32 <Athas> Which associativity is bestowed upon infix operators created via backticks?
11:54:25 <ddarius> Athas: Whichever one is specified or the default for any infix operators that don't have a fixity declaration.
11:54:26 <jmcarthur> Athas: by default it's left associative, but you can override that
11:54:37 <Athas> Thanks.
11:58:44 <parcs> Athas: infixl 9
11:59:05 <buntfalke> Athas: Also see the Box in Report 3.5
12:08:21 <ghartshaw> @pl \x f . g . h x
12:08:21 <lambdabot> (line 1, column 6):
12:08:21 <lambdabot> unexpected "."
12:08:21 <lambdabot> expecting pattern or "->"
12:08:28 <ghartshaw> @pl \x -> f . g . h x
12:08:29 <lambdabot> ((f . g) .) . h
12:10:13 <ghartshaw> @pl \x z -> f x . g y . h z
12:10:14 <lambdabot> (. ((g y .) . h)) . (.) . f
12:10:47 <erus`> people are working on ghcjs again? :D
12:13:26 <hpaste> erus` pasted “error” at http://hpaste.org/50526
12:17:40 <erus`> disregard that it builds with cabal :|
12:19:15 <Cale> Seeing http://www.reddit.com/r/programming/comments/jkstt/how_to_use_epoll_a_complete_example_in_c/ makes me tempted to write "A complete example in Haskell" which just uses forkIO ;)
12:19:54 <ion> :-)
12:19:57 <ddarius> Cale: That would be the wrong thing to do.  The right thing to do would be to stop reading /r/programming.
12:20:17 <ion> /r/painful-programming
12:26:11 <monochrom> erus`: probably because "cabal install" adds the two needed packages for you
12:32:08 <_Ray_> Where could I see an example of covariance and contravariance in Haskell?
12:33:03 <ciaranm> _Ray_: those words can mean various things. do you have a specific context in mind, or do you just want anything that's called covariant?
12:33:21 <companion_cube> _Ray_: there is no subtyping in haskell
12:33:30 <_Ray_> Specifically a covariant or contravariant type constructor, in the sense of a functor being covariant or contravariant.
12:33:44 <_Ray_> (Type constructors being endofunctors on Hask)
12:33:52 <ciaranm> functors being co- or contra- variant refers to which way around the composition goes
12:34:37 <ddarius> _Ray_: A type constructor that was an endofunctor on Hask would always be covariant.
12:34:45 <ciaranm> so Functor being covariant comes from the functor law "fmap (f . g)  ==  fmap f . fmap g"
12:35:02 <_Ray_> Whereas contravariance would have me to fmap g . fmap f?
12:35:14 <_Ray_> *have me do
12:35:18 <ciaranm> yup. there's a Data.Functor.Contravariant
12:35:48 <ciaranm> which has "contramap f . contramap g = contramap (g . f)"
12:36:05 <_Ray_> Is a type constructor covariant by virtue of being an endofunctor already, or is it because the language specifically restricts it as such? In other words, are all endofunctors covariant?
12:36:45 <koeien> is there a way to efficiently serialize graphs in haskell with fgl?
12:36:56 <ciaranm> _Ray_: i'm not sure i get your question... there are type constructors that aren't functors...
12:37:27 <_Ray_> Hrm. Such as what? Integer and Char and such?
12:37:42 <ciaranm> those are types, not type constructors
12:37:53 <ciaranm> any type constructor that doesn't say it's a functor isn't one
12:37:55 <_Ray_> Right, so what would be a type constructor that isn't a functor?
12:38:03 <_Ray_> ... oh, you're right.
12:38:18 <_Ray_> If I just data X a = Foo, X needn't be a functor
12:38:25 <ciaranm> in category theory terms, a type constructor is the bit of the functor that maps objects to objects
12:38:34 <ddarius> _Ray_: That is a functor.
12:38:55 <ciaranm> the bit that maps arrows to arrows is 'fmap', which only some types have
12:39:15 <_Ray_> ddarius, but I haven't given X a fmap, how can it be a functor? Unless you're making the distinction between functor and Functor?
12:39:43 <Tomsik> _Ray_: you haven't implemented fmap, but there is a definition of fmap that satisfies all laws
12:39:50 <_Ray_> Oh.
12:39:53 <ddarius> _Ray_: Let me reword that into "That can be made into a functor."
12:40:01 <ddarius> It also can be made into a contravariant functor.
12:40:18 <_Ray_> By implementing contramap, I gather.
12:40:49 <bfig> Cale, i almost solved it :)
12:40:59 <bfig> i'm getting what i think is rounding errors now
12:41:09 <bfig> i've changed the algo so it properly computes EV
12:41:25 <bfig> _Ray_, hey, what's up?
12:42:07 <_Ray_> Trying to understand covariance and contravariance in programming languages, from a categorical point of view :)
12:42:33 <ciaranm> _Ray_: be careful. covariance typically means something else in languages with subtyping.
12:42:53 <_Ray_> I was hoping it was a particular case of functor covariance.
12:43:12 <_Ray_> From what I've read, it means that a is a subtype of b iff F a is a subtype of F b.
12:43:37 <ciaranm> the usual starting point in OO languages is covariant return types on overridden functions
12:43:43 <ddarius> There are multiple (related) meanings of "covariant" and "contravariant."
12:44:24 <ciaranm> http://en.wikipedia.org/wiki/Covariant_return_type that sort of thing
12:44:48 <zzo38> Is there anything like:  derivable :: Name -> (Dec -> Q [Dec]) -> Q [Dec];   It would be useful to use in Template Haskell if you want to make up your own deriving of your own classes too, I would think
12:45:50 <ciaranm> "contravariant functor" is a silly name. they should be called "flipping functors" or something.
12:46:02 <hpaste> bfig pasted “calculo matrices” at http://hpaste.org/50527
12:47:04 <zzo38> It seems to me many things missing from Template Haskell
12:47:21 <edwardk> zzo38: nope, but derivable Name wouldn't cut it becaue you can do deriving for MPTCs
12:47:38 <ion> zzo38: One of them is not sucking.
12:47:47 <zzo38> edwardk: What is MPTCs?
12:48:07 <edwardk> zzo38: the idiom is to make your own deriveFoo combinator for each class you want to derive and make people put deriveFoo ''Bar  on a separate line as a splice
12:48:12 <edwardk> multi-parameter type class
12:48:13 <ion> Not that i have a better solution. But someone smarter than me might have. :-)
12:48:27 <edwardk> you can use newtype deriving to derive an instance for MonadState Foo
12:50:11 <zzo38> edwardk: Yes, you can do that, of course; use a separate splice which derives. But that is a bit mixed up because it means the derivable Haskell classes have to be considered special rather than having built-in stuff not specials.
12:50:17 <bfig> YESS!!! it WORKSSS muahahahahah
12:50:21 <edwardk> yes
12:50:21 <djh_> quick parsec question. Say I have this piece of text: [1,2,3,4], how do I make sure that [1,2,3,4] is valid, but [1,2,3,4,] isn't?
12:50:36 <edwardk> djh: sepBy
12:50:46 <djh_> my current code has this "many (digit <|> char ',' <?> "Mappings should be in the format [#,#,#..]")"
12:51:26 <edwardk> http://ekmett.github.com/trifecta/Text-Trifecta-Parser-Combinators.html#v:sepBy
12:51:36 <edwardk> (there is an analogous parser in parsec)
12:51:49 <edwardk> see the commaSep example there
12:52:02 <djh_> @edwardk thanks man I'll check that out :D
12:52:02 <lambdabot> Unknown command, try @list
12:53:40 <edwardk> sepBy p sep = (:) <$> p <*> many (sep *> p) <|> pure []
12:55:45 <zzo38> Another wrong thing in Template Haskell, is, there isn't any command to define functions usable in Template Haskell in the same module. I think it ought to have something like that; perhaps, put declaration in ${ ... } to make them work for Template Haskell with the current module. I have other ideas too
12:56:02 <edwardk> zo38: i'm sure they'd happily take a patch. the problem is hard
12:56:35 <ddarius> zzo38: That's not a design decision so much as an implementation limitation.
12:57:26 <edwardk> they've stated that they'd like it to work that way, they just don't quite know how to do it
12:57:55 <zzo38> I think I can understand the reason for that limitation but it should be easier to implement if you required ${ ... } in those cases to use them with $( ... )
12:58:26 <edwardk> TH is already really hard due to the fact that TH expansion interleaves with type checking
12:58:38 <ddarius> Whatever you did for ${ } you could just do for all $( )
13:00:22 <_Ray_> So contravariant in parameter types means that if a is a subtype of b, then functions which take b are a subtype of functions which take a.
13:01:01 <ddarius> _Ray_: Yes, but this doesn't have much to do with Haskell.
13:01:07 <ciaranm> _Ray_: hrmmmmmm. it's not normal to think of overridden functions in terms of subtypes.
13:01:09 <edwardk> Yes, a subtype of a function can 'do more and require less'
13:01:53 <_Ray_> Just thinking of which morphism this would be talking about, if the functor was "Make a function which takes type ____".
13:02:48 <ciaranm> you might be better thinking in terms of subcategories for that
13:04:09 <ddarius> The type constructor: newtype F a = F (a -> X) is contravariant because given a map from a -> b, you get a map from F b to F a by precomposition.
13:05:15 <ddarius> If you think of a <: b as being witnessed by a function a -> b, then the contravariance of parameters is due to the fact that you would precompose with this witness to witness the new subtyping constraint.
13:05:17 <_Ray_> Niiiiiice.
13:05:27 <zzo38> For example, everything from ${ ... } is moved into its own module which is then automatically imported and usable only by Template Haskell splices. You could still do it with $( ... ) and check whether it contains a declaration and in that case, move to another module; but the problem in that case is that you can put expressions as declarations in which case the ${ ... } module also using Template Haskell
13:05:30 <_Ray_> The function would be sort of a "cast"?
13:06:06 <ion> > it
13:06:07 <lambdabot>   Not in scope: `it'
13:06:22 <ddarius> _Ray_: It would be a "coercion" in Cardelli's semantics of subtyping.
13:07:36 <ddarius> There's no reason for it to be a "cast" though.  The fact that (a,b) is a subtype of a is able to be witnessed by a perfectly normal function fst :: (a, b) -> a.
13:08:41 <_Ray_> Right. Thanks :)
13:09:39 <ddarius> Of course, you don't want to allow just any function as a "coercion."  (Int, Bool) <: Int but const 1 is not a valid coercion.
13:11:15 <NihilistDandy> So haskell98 is hidden according to ghc-pkg, but I've just gotten this build failure: Implicit import declaration:
13:11:18 <NihilistDandy>     Ambiguous module name `Prelude':
13:11:21 <NihilistDandy>       it was found in multiple packages: base haskell98-2.0.0.0
13:11:22 <NihilistDandy> Thoughts?
13:11:59 <NihilistDandy> Oh, I see it
13:12:15 <NihilistDandy> This is a flaw :/
13:13:41 <zzo38> There can also be a command $import which is like import but for Template Haskell only.
13:14:12 <ddarius> zzo38: There's nothing wrong with the normal import.
13:14:52 <zzo38> True, $import would not be needed.
13:15:18 <ddarius> _Ray_: You can view Ref a as a pair of a setter, which takes an a and thus is contravariant in a, and a getter which produces an a and thus is covariant in it.  Together they make references invariant.  Mutation tends to destroy subtyping which is why so many OO libraries are broken in this regard.
13:16:23 <_Ray_> ddarius, what does it mean "to be invariant"?
13:16:38 <ddarius> Neither covariant or contravariant.
13:16:59 <edwardk> _ray_ meaning that you given just a :< b, neither Foo a <: Foo b, nor Foo b <: Foo a
13:17:14 <edwardk> if you're given just
13:18:02 <zzo38> Are there any ways to add your own stuff to the compiler, in case of errors, including your own reserved words, can make it change to a cimpilable code using your own transformation?
13:18:23 <_Ray_> Is there a way to use type constructor covariance in Haskell? Say, if b is a subtype of a, to "let the compiler know" that Just b is a subtype of Just a?
13:18:29 <_Ray_> Err, Maybe b of Maybe a.
13:18:34 <edwardk> zzo38: there is a shiny new plugin interface, but you'll probably run into limitations
13:18:34 <ddarius> _Ray_: There is no subtyping in Haskell.
13:18:49 * Eduard_Munteanu wondered what this subtyping dicussiong was about
13:18:50 <_Ray_> Is there an argument against it?
13:18:53 <edwardk> _ray_: not as such, typically what you'd do is make it an instance of Functor =P
13:18:57 <zzo38> edwardk: What does it do, what where is information?
13:19:05 <dixie> hmm. Can I and May I specify -O2 flag in .cabal file for some package? I checked bytestring cabal file and there are some "if ghc" conditiontions used.
13:19:14 <edwardk> _ray_: yes, once you introduce subtyping, type inference goes out the window fast
13:19:16 <erus`> they call it the snap framework because it makes you say 'aww snap! why didnt i write this site in python'
13:19:42 <edwardk> http://hackage.haskell.org/trac/ghc/wiki/NewPlugins
13:19:53 <erus`> i had an idea for a functional corewars type game earlier but then i realized that everything is immutable :(
13:20:02 <_Ray_> Interesting. I'll ask about this in my programming paradigms class tomorrow, should be interesting :)
13:20:02 <Eduard_Munteanu> _Ray_: subtyping was mainly developed for OO languages; however in Haskell you can already emulate some OO or otherwise avoid such patterns conveniently
13:20:05 <_Ray_> Thanks!
13:20:10 <edwardk> erus`: did you see lambda the gathering?
13:20:16 <ddarius> @where ohaskell
13:20:16 <lambdabot> I know nothing about ohaskell.
13:20:22 <ddarius> @google "O'Haskell"
13:20:23 <lambdabot> http://www.haskell.org/haskellwiki/O'Haskell
13:20:23 <lambdabot> Title: O'Haskell - HaskellWiki
13:20:36 <erus`> edwardk: nope?
13:20:39 <edwardk> http://www.icfpcontest.org/2011/06/task-description-contest-starts-now.html
13:20:48 <edwardk> was this year's ICFP programming contest
13:20:55 <edwardk> its more or less a functional core war
13:21:10 <companion_cube> wow
13:21:36 <Eduard_Munteanu> However AFAIK, there's some notion of subtyping wrt type classes that partially fits that bill in Haskell.
13:21:39 <zzo38> Does it support adding pragmas for the plugins?
13:21:52 <zzo38> Or do you require using command-line to specify?
13:21:54 <edwardk> zzo38: you now know (almost) as much as i do on the topic ;)
13:22:00 <edwardk> and yes you need to put a command-line flag
13:22:44 <bfig> now i've  decided to compute variance and i'm getting some trouble with operator scope
13:23:41 <erus`> edwardk: holy crap that is cool
13:24:35 <erus`> i dont understand the attack card
13:24:36 <edwardk> zzo38: http://www.cs.berkeley.edu/~megacz/garrows/ is probably the heaviest abuse of the plugin interface to date: http://www.cs.berkeley.edu/~megacz/garrows/
13:24:45 <edwardk> woops linked twice
13:25:14 <edwardk> erus': how so?
13:25:33 <hpaste> bfig pasted “operator scope error” at http://hpaste.org/50528
13:25:42 <edwardk> you spend n vitality from one card to do 9/10ths n vitality damage to an opponent card
13:26:06 <ddarius> edwardk: Does it round up or down?
13:26:12 <edwardk> down
13:26:17 <ddarius> Darn.
13:26:43 <edwardk> help gives 11/10ths rounded down to one of your cards, so there is an exponential in play
13:26:54 <bfig> i get an error in the where
13:27:22 <roconnor> this is gonna hurt me more than it hurts you
13:27:37 <NihilistDandy> @ask jgoerzen Any work around for MissingH on GHC 7.2.1? It seems that the build calls Prelude from base and h98 in a way that it finds unsavory
13:27:37 <lambdabot> Consider it noted.
13:28:01 <ddarius> NihilistDandy: He's usually on as CosmicRay.
13:28:30 <erus`> edwardk: so you each have n slots each or both players play in n slots?
13:28:36 <edwardk> each have
13:28:38 <ddarius> preflex: seen jgoerzen
13:28:38 <preflex>  Sorry, I haven't seen jgoerzen
13:28:50 <ddarius> NihilistDandy: Admittedly, he's virtually never on IRC.
13:28:56 <edwardk> you're more likely to catch goerzen on his blog or google+
13:29:20 <edwardk> or this archaic thing called email
13:29:21 <ddarius> Or just email him.
13:29:33 <NihilistDandy> ddarius: Oh, last I saw him on was as jgoerzen :D
13:29:36 <bfig> leListVARwrppr = 0:(\ev -> fix (\f (st,var,n,ac) -> (st,var,n,ac) : f (newState, var+ ((\x->x*x) (fromIntegral n - ev))*ac,n+1, (preVal@>18)) where newState = mul preVal leDeacum; preVal = leMatrizTran <> st))
13:29:56 <ddarius> NihilistDandy: That seems unlikely.
13:30:00 <bfig> how can i write the where? i'm getting a scope error if i get it outside of the code
13:30:06 <edwardk> bfig: the where clause doesn't have access to the contents of the lambda
13:30:17 <ddarius> Unless he just didn't say anything ever.
13:30:19 <edwardk> st, etc are only bound inside the lambda
13:30:23 <Eduard_Munteanu> bfig: which 'where'?
13:30:25 <bfig> edwardk, how can i change the code?
13:30:40 <NihilistDandy> ddarius: Maybe it's actually the email that I'm confusing for his IRC handle
13:30:54 <edwardk> fix $ \f (st, var, n,ac) -> let newState = ….; … in (st, var, n, ac) : ….
13:30:55 <ddarius> preflex: seen CosmicRay
13:30:55 <preflex>  CosmicRay was last seen on #haskell-blah 79 days, 5 minutes and 4 seconds ago, saying: nope ;-)
13:31:01 <bfig> Eduard_Munteanu, line 58: http://hpaste.org/50528
13:31:04 <edwardk> turning the here into a let inside the lambda
13:31:04 <NihilistDandy> heh
13:31:07 <edwardk> the where
13:31:18 <bfig> ok, cool. after the ->?
13:31:18 <edwardk> NihilistDandy: you had semigroup questions
13:31:20 <edwardk> yeah
13:31:23 <bfig> ty
13:31:44 <NihilistDandy> Yeah, but I may be headed out the door. I promise we'll actually talk about it, eventually :D
13:31:48 <edwardk> hahah
13:32:00 <edwardk> @ask copumpkin any luck yet?
13:32:01 <lambdabot> Consider it noted.
13:32:44 <edwardk> erus`: basically you each get 256 cards or whatever with so much life to start with all initialized to some sensible default (like Id)
13:33:46 <edwardk> but you have to be careful because if the opponent kills a particularly intricate card set up, they can animate it as a zombie and use it against you for a round, if it can be applied to the identity in a way that harms you
13:36:30 <erus`> http://www.twitch.tv/realnotch notch's livestream hes making a game in 48 hours for lundam dare
13:37:21 <edwardk> heh, he switched hosts once he realized he was in to twitch.tv for like 4 grand in live streaming fees
13:39:20 <hpaste> bfig pasted “new operator error” at http://hpaste.org/50529
13:39:53 <bfig> now i'm getting an operator error i just don't understand
13:43:33 <bfig> edwardk, any idea what that could be?
13:44:18 <edwardk> you didn't give the error, just the code
13:44:30 <zzo38> Is there a way to write a code for recovering from errors at compile-time?
13:44:44 <edwardk> zzo38: like in template haskell?
13:45:08 <edwardk> zzo38: byorgey noted recently you can use recover to do things like catch a reference to a non-existent term, etc.
13:46:28 <zzo38> edwardk: No I mean even syntax errors and so on.
13:46:41 <edwardk> zzo38: you're probably out of luck there
13:49:08 <bfig> edwardk, well, i can't really paste it here, it is like 50 lines long
13:49:15 <edwardk> that is what hpaste is for
13:49:17 <edwardk> =P
13:49:17 <bfig> it is a single error related to the infinite type
13:49:24 <edwardk> @hpaste
13:49:24 <lambdabot> Haskell pastebin: http://hpaste.org/
13:49:34 <bfig> you mean i should paste the error description? i pasted the code on hpaste just above this
13:49:48 <edwardk> yes, paste the error as well
13:49:52 <bfig> ok
13:50:29 <hpaste> bfig pasted “Error” at http://hpaste.org/50530
13:51:47 <edwardk> here is where i'm afraid i'm not going to be much help. leListVARwrppr is pretty much opaque without knowing what you're doing
13:52:00 <bfig> ok, i'll explain. it is really easy
13:52:09 <ddarius> If the ltg programs are limited to 60 seconds real-time, how can they use 10,000 CPU seconds assuming there are less than 167 cores?
13:52:11 <edwardk> i have to run, so i hope someone else can help
13:53:04 <bfig> edwardk, first i compute the expected arrival time to the well in the markov chain represented by the transition matrix leMatrizTran, that is solution n
13:53:18 <bfig> solution 150 gets fixed after that
13:53:29 <edwardk> you'd probably be better off removing fix and using explicit recursion
13:53:35 <edwardk> just to track the errors better
13:53:40 <bfig> yes i guess >_>
13:54:16 <edwardk> and you can move the outer lambda into the definition of leListVARwrpper
13:54:56 <edwardk> leListVARwrpper ev = 0: go … where go …= ...
13:55:13 <ciaranm> if i have a data (Ord x) => Stuff x = Stuff x, i can't make it a Functor since it doesn't work for arbitrary types. but it could be a Functory-thing over a subcategory of Hask containing Ordy things. can the type system model that?
13:55:40 <edwardk> ciaranm: you shoudn't have data (ORd x => Stuff x = … in the first place, it has been removed from the language
13:55:53 <edwardk> because it doesn't help, ever
13:56:02 <ciaranm> ah. i have some old books.
13:56:14 <edwardk> it was a bad idea that slipped in and didn't work as intended
13:56:37 <ddarius> edwardk: It made more sense when seq was a member of a class.
13:56:39 <edwardk> the only real remnant of it is in Complex where it just serves to keep perfectly good uses of the Complex data type at bay (like Gaussian Integers)
13:56:45 <edwardk> sure
13:57:56 <ciaranm> hrm, it strikes me as a bit odd that Stuff NotOrdable could exist as a type that you can't do anything with, rather than not being a type
13:58:29 <ddarius> ciaranm: If you can't do anything with it, it should never come up and it doesn't really matter anyway.
13:58:33 <ciaranm> maybe the idea that it's always possible to get an instance of a type is a silly one
13:59:08 <edwardk> ciaranm: well, it comes down to the fact that that Ord is just an obligation, it doesn't actually give you the Ord instance given just a value of type Stuff x
13:59:15 <edwardk> for that you want to use a GADT
13:59:20 <zzo38> I think there should be pragmas for indicating commutative and associative in case it might help with optimization and so on.
13:59:22 <edwardk> and even then you should think twice
13:59:38 <ddarius> zzo38: Such pragmas would have to be checked.
14:01:59 <zzo38> Or, more general, a OPTIMIZE pragma which can be used to indicate various things including commutative, associative, always defined, do not optimize, display optimization information, optimize for speed, optimize for size, has identity value, etc
14:03:46 <ciaranm> i mean... making a binary tree a functor strikes me as lying
14:04:22 <edwardk> ciaranm: only if you want to rely on it being sorted
14:04:34 <edwardk> ciaranm: if you do, then you don't want a functor instance
14:04:42 * ciaranm nods
14:04:52 <ddarius> There's no reason not to have the Functor instance.
14:05:15 <ciaranm> i still think i want it to be a functor over the subcategory of Ord types of Hask
14:05:26 <edwardk> ciaranm: if you just want to build up a tree, a binary tree makes a perfectly good functor, and if the values are at the leaves it makes a perfectly good monad
14:05:43 <edwardk> even there you have to rebalance the tree
14:05:54 <edwardk> so you can only apply monotone increasing functions
14:06:18 <edwardk> there is a mapMonotone in Data.Set for that purpose
14:06:25 <edwardk> but it can't enforce that condition
14:06:35 <edwardk> it just starts giving wrong answers if you violate it
14:08:47 <ciaranm> hrm. fmap can't be made to rebalance?
14:09:37 <edwardk> it isn't an fmap at that point
14:10:18 <ciaranm> please explain. i think there's something either very obvious or very subtle that i'm missing.
14:10:19 <ddarius> zzo38: The compiler isn't just going to assume some of those properties just because you say so, and checking them is Turing-hard.  Being able to specify some of those latter things isn't unreasonable, but is usually a decision that should be left to the person compiling.
14:11:51 <edwardk> well, if you start rebalancing, then fmap id = id becomes not quite an actual equality
14:12:49 <ddarius> Usually the problem is the type.  I can easily imagine a rebalance that is provably the identity function with respect to all observations.
14:13:13 <ciaranm> is that still the case if the tree definitely contains only distinct values, and that balancing always produces the same shape?
14:13:22 <ddarius> Of course, such a rebalance would then be unnecessary as far as correctness is concerned.
14:13:46 <edwardk> but ultimately, the point is moot. you can't express the type you want, so just call the operation something else and go with it ;)
14:14:03 <ciaranm> heh
14:28:01 <Athas> Man, Quickcheck is a merciless mistress.
14:28:32 <Athas> It's the first time I've run it on nontrivial transformation code, and it's finding all the obscure corner cases I knew I didn't handle, but wouldn't matter in practice.
14:28:37 <Athas> Now my honour depends on fixing them.
14:28:59 <edwardk> hahahha
14:31:05 <ddarius> Yes, obscure corner cases never happen.  This has long been witnessed by the software community.
14:31:27 <edwardk> just ask the erlang guys
14:31:40 <ddarius> or the computer security guys
14:31:48 <incluye> or twitter
14:31:49 <Athas> If they happen, they don't matter.  This code is about arranging boxes according to constraints.  At most, it's a few pixels off.
14:31:58 <incluye> rails had trouble load handling? /weird/
14:32:22 <Athas> I have such a hard time visualising geometry code.  I guess that's why I took the easy way out.
14:33:18 <ddarius> Athas: Being a few pixels off in that kind of situation can be really annoying.
14:38:52 <ddarius> Also obscure corner cases suggest that there may be a better way of structuring/thinking about your code, so that those obscure corner cases are handled correctly, i.e. aren't special cases.
14:39:34 <Athas> Yes, that's what I'm doing now.
15:10:17 <monochrom> @pl (\x m -> return x `mplus` m)
15:10:17 <lambdabot> mplus . return
15:10:26 <monochrom> oh, that's it? :)
15:36:00 * hackagebot Encode 1.3.5 - Encoding character data  http://hackage.haskell.org/package/Encode-1.3.5 (OtakarSmrz)
15:47:39 <siracusa> When building a cabalized package, is there a way to get the list of executables names from that package within one of those executables?
16:28:20 <copumpkin> edwardk: not yet, been busy this weekend
16:28:25 <copumpkin> will probably check it tomorrow
16:40:49 <hpaste> adxp pasted “FFI/pointer question” at http://hpaste.org/50532
16:41:19 <adxp> hi - have a question about that code. How should I "generically" specify a function like the above, that may return several different types?
16:41:52 <adxp> obviously, haskell needs to know the size/alignment in order to use peek, but can it ever infer that from the surrounding usage, or can I somehow specify it on an ad-hoc basis, etc?
16:41:58 <benmachine> adxp: put a Storable a context in?
16:41:58 <adxp> (how would the experts write this?)
16:42:24 <benmachine> adxp: do you understand the type signature of show?
16:42:39 <benmachine> particularly, why show :: a -> String is wrong?
16:42:45 <benmachine> :t show
16:42:47 <lambdabot> forall a. (Show a) => a -> String
16:42:59 <adxp> no, I don't understand why it's wrong
16:43:16 <Jafet> :t const ""
16:43:17 <lambdabot> forall b. b -> [Char]
16:43:26 <benmachine> well, do you understand the (Show a) => bit?
16:43:53 <benmachine> (it'd be better for me to say show :: a -> String is incomplete, rather than wrong, perhaps)
16:44:05 <adxp> I *think* so -- it's a class, right?
16:44:31 <benmachine> right
16:44:54 <benmachine> and you need it there because a needs to be in Show for show to work
16:45:01 <benmachine> in your function, you need a to be in Storable
16:45:09 <benmachine> so you need to do something similar
16:45:19 <adxp> ok, that makes sense -- how would I specify that?
16:45:24 <adxp> I tried returning IO (Storable a)
16:45:28 <adxp> but that gave another error
16:45:30 <benmachine> Storable is a class, not a type
16:45:32 <benmachine> like Show
16:45:35 <adxp> yep that was the error :)
16:45:51 <benmachine> so, do it like show does
16:46:00 <benmachine> classes go after :: and before =>
16:46:17 <adxp> aah
16:46:40 <benmachine> (if you still get it wrong I'll just tell you the answer, but I'm trying to explain the logic behind it first :P)
16:46:45 <adxp> so I want "axGetValue :: (Storable a) => CInt -> CInt -> IO a"?
16:46:48 <benmachine> right
16:46:52 <adxp> makes total sense, thanks!
16:47:05 <benmachine> np :)
17:14:02 <adxp> sorry for the n00bish questions, but: what's a good way of declaring a type to be "a Ptr to a Foo or a Bar"? (Or, better still, to a member of some class Baz.)
17:14:36 <mightybyte_> Anyone ever see GHC give an error: "FATAL:Symbol _dmAh_info_dsp already defined."?
17:15:09 <Eduard_Munteanu> adxp: you can have a pointer to an Either Foo Bar
17:15:22 <Eduard_Munteanu> Or stuff like it.
17:17:13 <adxp> Eduard_Munteanu: cool, thanks. is it a sane question to ask how to declare a type to be "a pointer to all members of some class"? (Something philosophically like data MyPtr = (Storable a) => Ptr a)
17:17:15 <_Ray_> Hrmph. When looking at the laws of Data.Functor.Contravariant, I see that "contramap f . contramap g = contramap (g . f)". However, it says that this follows from "contramap id = id" and the free theorem on the type of contramap, (a -> b) -> f b -> f a . But regular covariant Functors also have the same type and fmap id = id, so how can this second law (which isn't true for Functors) be true for contravariant functors?
17:17:39 <benmachine> adxp: not reeeeaally. I think you'd just write Storable a => Ptr a in all your typesigs
17:17:56 <benmachine> adxp: it's an unfortunate omission from the language that there aren't great ways to abbreviate class contexts
17:18:19 <benmachine> _Ray_: they don't have the same type
17:18:38 <_Ray_> oh, right
17:18:47 <Eduard_Munteanu> @free fmap
17:18:48 <lambdabot> Expected variable or '.'
17:18:50 <_Ray_> one is f b -> f a, the other f a -> f b. I suck at reading. Sorry.
17:18:55 <adxp> benmachine: mm, interesting. thanks.
17:18:56 <benmachine> :)
17:18:59 <Eduard_Munteanu> @free (a -> b) -> f a -> f b
17:18:59 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
17:19:06 <Eduard_Munteanu> Bah.
17:19:26 <benmachine> @free fmap :: (a -> b) -> f a -> f b
17:19:27 <lambdabot> Extra stuff at end of line
17:19:31 <benmachine> oh, whatever
17:19:42 <Eduard_Munteanu> @free \f x -> fmap f x
17:19:43 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
17:19:59 <Eduard_Munteanu> I forget how to use that.
17:20:05 <benmachine> @free id
17:20:06 <lambdabot> f . id = id . f
17:20:09 <benmachine> woo
17:20:14 <benmachine> (me too)
17:20:31 <Eduard_Munteanu> @free map
17:20:32 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
17:20:51 <Eduard_Munteanu> We can pretend map is fmap :)
17:22:10 <Eduard_Munteanu> _Ray_: yeah, contravariant functors turn arrows around.
17:22:29 <Eduard_Munteanu> Or equivalenty they're functors from C^op.
17:22:37 <Eduard_Munteanu> *equivalently
17:45:11 <ian__> is there a function that takes a function and an operand and repeatedly applys that function to the operand
17:45:24 <ian__> and then that function to the function's result, constructing and infinite list of the results
17:45:41 <mightybyte_> iterate
17:45:50 <ian__> thansk!
17:45:52 <mightybyte_> >:t iterate
17:45:55 <shachaf> @hoogle (a -> a) -> a -> [a]
17:45:56 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
17:45:56 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
17:45:56 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
17:46:38 <NihilistDandy> :t iterate
17:46:39 <lambdabot> forall a. (a -> a) -> a -> [a]
17:47:34 <NihilistDandy> >:t looks like an angry person doing a finger mustache
17:48:40 <ian__> lol
17:58:01 <ssbasi> ksjdaklsjd
17:59:49 <budu> hi
18:00:32 <budu> is there a way to make ghci aware of the local .inputrc
18:02:18 <NihilistDandy> budu: What isn't it doing correctly?
18:02:28 <mauke> budu: that would require making ghci use readline first
18:03:09 <mauke> NihilistDandy: everything
18:04:03 <budu> well it look like readline works, I've all the default bindings
18:04:21 <mauke> ghci doesn't use readline
18:04:27 <budu> but the ones defined in my local .inputrc aren't there
18:05:22 <ivanm> budu: it uses haskeline, a Haskell clone of readline
18:05:29 <ivanm> not a complete clone though
18:05:35 <mauke> except it's not a clone of readline
18:05:37 <ivanm> reason being due to licensing concerns with readline
18:05:42 <mauke> it doesn't even pretend
18:05:51 <ivanm> mauke: OK, what would be a better description then?
18:06:32 <mauke> it's a library for interactive line editing
18:06:47 <mauke> similar to readline
18:07:48 <ivanm> and less borked than editline? :p
18:07:52 <mauke> yeah
18:08:01 <budu> so is there a way to make it use readline
18:08:04 <ivanm> budu: http://stackoverflow.com/questions/1825547/how-to-customize-the-readline-keybindings-of-ghci
18:08:33 <mauke> has anyone thought about reimplementing haskeline on top of readline?
18:09:34 <mauke> budu: I'm not aware of one
18:09:36 <ivanm> mauke: wouldn't that just cause the same licensing concerns that got ghc to switch to editline and then haskeline?
18:09:41 <mauke> you could file a bug report / feature request
18:09:59 <mauke> ivanm: I don't know and I don't care
18:10:01 <ivanm> budu: kolmodin had a patch kept around for ghc -6.10.* to get it back to using readline; might still apply to current ghc, not sure
18:10:16 <mauke> I had a patch for 6.10.2
18:10:24 <mauke> doesn't apply to 6.10.3
18:10:39 <budu> i'll see what i can do with the .haskeline config file
18:10:40 <budu> thanks
18:10:50 <mauke> (answer: not much)
18:11:04 <ivanm> mauke: this one applied to .3 as well IIRC
18:11:56 <ivanm> see also http://hackage.haskell.org/trac/ghc/ticket/3235
18:15:57 <mauke> ooh, a broken key binding interface
18:16:30 <applicative> i hadn't known about the .haskeline file.
18:16:38 <mauke> ivanm: yes, that's why I want a Haskeline compatibility layer for readline
18:16:46 <mauke> that would make a ghci patch trivial
18:17:20 * applicative thinks, awesome! configurable BellStyle!
18:17:23 <ivanm> optional presumably?
18:17:44 <ivanm> mauke: I'm sure patches are accepted... :p
18:18:34 * applicative is pimping his haskeline
18:18:55 * ivanm just runs ghci within emacs, and thus doesn't care that much about keybindings
18:19:19 <Maxdamantus> Do you get tab complete there?
18:19:26 * Maxdamantus tries.
18:19:28 <mauke> now why the fuck are KeyBindings and CustomKeyBindings separate pages?
18:19:56 <mauke> especially since haskeline uses the broken vi model of key bindings where you have to look at KeyBindings to write your CustomKeyBindings
18:20:04 <ivanm> Maxdamantus: in chrisdone's mode, yes
18:20:11 <ivanm> but it's TAG based rather than ghci based
18:20:13 <ivanm> so not as good
18:20:20 <ivanm> but i never got used to using it, so shmeh
18:20:22 <Maxdamantus> Mm.
18:21:16 <mauke>  M-A: Option-A
18:21:18 <applicative> "Now 6.10.3 is using haskeline, with an entirely new set of bugs..."
18:21:23 <mauke> worst documentation ever.
18:21:38 <ivanm> mauke: nah, at least there's _some_
18:21:45 <ivanm> as opposed to, say, edwardk's packages... ;)
18:21:58 <mauke> ivanm: can you explain the meaning of "M-A: Option-A"?
18:22:10 <ivanm> mauke: it's the alt-a keybinding
18:22:29 <ivanm> i.e. what do you want to bind to Alt-a
18:22:46 <mauke> not quite right
18:23:39 <ivanm> mauke: OK, it's in the definition section
18:23:51 <ivanm> I've seen option used for meta/alt before
18:23:56 <ivanm> I think it's an OSX thing
18:24:14 <mauke> what it actually means: "in the following documentation, we're going to call Alt-a Option-a (except we never mention Alt anywhere and this is the only occurrence of Option) and abbreviate Option to M"
18:24:39 <ivanm> yeah, seems reasonably clear to me
18:24:59 <ivanm> but yes, they could have explicitly said that M/Option is usually Alt on most keyboards
18:25:07 <mauke> "so when you see M-a in the table below, it means you have to press Alt-a and write Meta-a in your config file because we don't actually support the M-a syntax"
18:25:22 <mauke> (bonus surprise)
18:25:24 <ivanm> Meta-a or Option-A ?
18:25:37 <ivanm> oh, meta-a
18:25:38 <applicative> my key says 'alt option'
18:25:51 <ivanm> mauke: OK, I agree with you on that one
18:26:50 <mauke> they should have used meta-a everywhere and added a note saying that the meta key is usually Alt, or Option on macs
18:28:08 <applicative> surely haskeline is maximally configurable: "* Custom tab completion functions which may run in an arbitrary monad."
18:28:40 <applicative> launchMis\t
18:29:20 <ivanm> lol
18:29:51 <mauke> haskeline++  # somewhat usable now
18:32:18 <fengshaun> is it guaranteed that a monad also obeys applicative/functor laws?
18:33:48 <ddarius> Something could have a Monad instance that is different from the given Applicative/Functor instances, but you can define the operations of Applicative/Functor in terms of the Monad operations, so there is always -a- way of making an Applicative/Functor instance that corresponds to the Monad instance.
18:35:06 <fengshaun> ddarius: oh, so just because something is a monad, doesn't mean I can use it like an applicative/functor, right?
18:36:05 <ddarius> You have to explicitly define an Applicative and Functor instance as well.
18:36:27 <fengshaun> oh ok, thanks a lot!
18:38:40 <Jafet> @src Functor
18:38:41 <lambdabot> class  Functor f  where
18:38:41 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
18:39:05 <Jafet> @slap lambdabot
18:39:05 * lambdabot jabs lambdabot with a C pointer
18:39:29 <Jafet> @vixen you like wild pointers?
18:39:30 <lambdabot> yeah, i like
18:41:24 <Jafet> :t \f x -> x >>= return . f
18:41:25 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a -> a1) -> m a -> m a1
18:42:00 <Jafet> The natural definition of fmap
19:23:18 * EvilMachine is happy to be back in his #haskell, full of friendly and reasonable people. (##linux… My god, it’s full of dicks :( )
19:24:26 * ClaudiusMaximus wonders how much longer it will take for crypto-api Crypto.CPoly to compile..
19:25:54 <EvilMachine> ClaudiusMaximus: as long as it’s better than compiling all of LibreOffice, just to, at the very end, see it abort the file merging because of "poor programming practices", which Gentoo, of all, apparently doesn’t like. ;)
19:28:30 <ClaudiusMaximus> EvilMachine: well, so far it's 45mins wall-clock time (of which about 50% is swap related)
19:39:31 <EvilMachine> ClaudiusMaximus: so it has huge stacks? or is it just lack of ram? ^^
19:41:36 <bobzhang> hi, all I tried to observe stackoverflow using such a little program "sum0 n = if n==0  then  0  else n + sum0 (n-1)"
19:42:10 <bobzhang> but it did not in ghci, I tried sum 30000, it does not stackoverflow
19:42:21 <bobzhang> how to make it stackoverflow? many thanks
19:43:55 <mustelo> bobzhang, you want it to stack overflow? I'm confused
19:44:03 <bobzhang> yeap,
19:44:45 <bobzhang> mustelo, I want to verify that cont monad is just cps transformation, if it does not stackoverflow, I can not observe the difference
19:45:13 <bobzhang> mustelo: I think it should stackoverflow, does not it?
19:46:32 <Eduard_Munteanu> 30000 is probably too low anyway
19:46:57 <bobzhang> 30000 is too low? I thought it is very large, I will try a big number late
19:47:15 <bobzhang> i tried sum0 3000000, still not...
19:48:24 <bobzhang> confused
19:48:36 <Eduard_Munteanu> > let sum0 n = if n==0  then  0  else n + sum0 (n-1) in sum0 999999
19:48:37 <lambdabot>   *Exception: stack overflow
19:49:01 <Eduard_Munteanu> bobzhang: are you compiling with optimizations?
19:49:07 <bobzhang> Eduard_Munteanu: I defined it in a file and then load it
19:49:17 <bobzhang> Eduard_Munteanu: byte code
19:49:47 <permagreen> Just tried it in ghci with 999999 and 1000000; neither stack overflow'd
19:50:03 <permagreen> Though they do take a while to run
19:50:46 <monochrom> ghci has a 512MB stack. you have to do a lot of work to blow it
19:50:57 <bobzhang> what i want is to verify that cont monad is just CPS transformation.
19:51:02 <Eduard_Munteanu> Oh.
19:51:03 <bobzhang> I have a monadic verserion
19:51:21 <bobzhang> sum1 n = if n ==0 then return 0 else sum1 (n-1) >>= \v -> return (n+v)
19:51:30 <monochrom> whereas normal executables and lambdabot are just 8MB
19:51:48 <bobzhang> In my opinion (runIdentity (sum1 30000)) will stackoverflow
19:52:03 <bobzhang> flip runCont id (sum1 30000) will not
19:52:12 <bobzhang> but they both not
19:53:00 <yourstruly> Can someone point me to a simple example of a readsPrec definition for an algebraic type?
19:53:02 <Eduard_Munteanu> What monochrom said.
19:53:35 <Eduard_Munteanu> Try compiling it, or telling ghci to use a smaller stack size
19:53:46 <aavogt> yourstruly: ghc might provide one of those if you compile with  -ddump-deriv  (and have a deriving Show somewhere)
19:53:56 <monochrom> cont monad is just cps transformation. just. it doesn't even collapse big thunks you build
19:54:09 <dylukes> Is there one that does ;~;
19:54:14 <dylukes> maybe Cont + seq
19:54:14 <dylukes> :P
19:54:37 <yourstruly> aavogt: ok, thanks
19:54:40 <monochrom> yeah you have to add your own seq's whether you cont or not
19:57:35 <yourstruly> aavogt: the code that GHC dumps out is a bit confusing, doesn't look like any other instance of Read that I've seen (like the one in RWH)
19:57:56 <bobzhang> monochrom: cont monad stackoverflow, oh my god
19:58:30 <bobzhang> main = print (flip runCont id (sum1 3000000)) stackoverflow
19:58:42 <bobzhang> I thought it should not, quite confused..
19:59:08 <monochrom> "n+v" is a big thunk if v is a big thunk. add induction.
19:59:47 <bobzhang> monochrom: yeap, it's a big thunk, but it is in heap, right?
20:00:02 <monochrom> and then you try to print it
20:00:32 <bobzhang> monochrom: so?
20:00:49 <monochrom> stack is for evaluating a big thunk
20:02:45 <bobzhang> monochrom : sum1 !n = if  n==0  then return 0 else sum1 (n-1) >>= \ v -> return (n+v)
20:03:15 <bobzhang> flip runCont id (sum1 3000000) still stackoverflow
20:03:23 <monochrom> "if n==0" does the same thing as "!n". no change
20:03:30 <monochrom> v is the big thunk
20:03:32 <Eduard_Munteanu> How about....
20:03:35 <bobzhang> yeap
20:03:36 <Eduard_Munteanu> > let sum0 n = foldl' (+) 0 [1..n] in sum0 999999
20:03:37 <lambdabot>   499999500000
20:03:42 <Eduard_Munteanu> ? :)
20:04:01 <bobzhang> Eduard_Munteanu: I know how to calculate, I just to want to verify my idea
20:04:06 <monochrom> oh we know the benefit of foldl', that's too easy :)
20:04:40 <Eduard_Munteanu> I think you do need an accumulator somewhere.
20:05:04 <Eduard_Munteanu> (and a strict one)
20:05:55 <bobzhang> for cont monad, it's cps transformation, and tail recursion, in my opinion, it should not stackoverflow..
20:06:13 <monochrom> tail recursion is irrelevant in this channel
20:06:14 <Eduard_Munteanu> bobzhang: you're thinking in C terms :)
20:06:16 <dylukes> theres not really--
20:06:19 <dylukes> monochrom beat me too it.
20:06:20 <dylukes> :P
20:06:25 <dylukes> to it*
20:06:36 <monochrom> > foldr1 (&&) (repeat False)
20:06:37 <lambdabot>   False
20:06:41 <monochrom> not tail recursion
20:06:51 <bobzhang> Eduard_Munteanu: can you explaint more clearly, it really confuses me
20:06:53 <Eduard_Munteanu> There's stack usage for recursion when it's not tail-recursive, but also you've got laziness playing a role there.
20:07:01 <monochrom> > foldl1 (&&) (repeat False)
20:07:06 <lambdabot>   mueval-core: Time limit exceeded
20:07:06 <lambdabot>  mueval: ExitFailure 1
20:07:10 <monochrom> tail recursion
20:07:30 <Eduard_Munteanu> (((1 + 2) + 3) + ... + n) is still eating up the stack
20:07:43 <monochrom> your own world is undone. go back to square one.
20:07:47 <EvilMachine> there was a nice explanation of this on the haskell wiki i think
20:07:54 <EvilMachine> the page about the 3 kinds of folds
20:08:09 <monochrom> err, your whole world is undone. go back to square one.
20:08:12 <Eduard_Munteanu> So you have to force evaluation as you go, avoiding building up a big thunk.
20:08:24 <CindyLinz> by foldl' ?
20:08:52 <bobzhang> Eduard_Munteanu: maybe you did not get my idea
20:08:54 <Eduard_Munteanu> Yes, "'" there gives strictness in the accumulator.
20:09:02 <EvilMachine> I found the page: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
20:09:08 <EvilMachine> this shoudl clarify things
20:09:18 <monochrom> (to be fair, a big thunk is okay if most of the functions involved are lazy, such as const 4 (big thunk))
20:09:25 <Eduard_Munteanu> bobzhang: in your case you've still got those >>='s chaining up
20:09:41 <EvilMachine> Eduard_Munteanu: don’t confuse people. "map'" doesn’t magically become strict. ^^
20:09:51 <EvilMachine> (unless you wrote that or i missed it. ;)
20:09:54 <Eduard_Munteanu> Regardless of whether n is strict.
20:10:19 <Eduard_Munteanu> Oh, yeah, it's not syntax or anything, foldl' is just a name.
20:10:21 <EvilMachine> monochrom: a big thunk wil mean big memory usage, right?
20:10:29 <monochrom> yes
20:10:43 <Eduard_Munteanu> EvilMachine: you know, back when I started, I thought the same thing ;)
20:10:48 <EvilMachine> monochrom: well, then it will become a problem.
20:10:52 <EvilMachine> Eduard_Munteanu: lol
20:11:58 <bobzhang> Eduard_Munteanu: sum2  n k = if n == 0 then k 0 else sum2 n (\v -> k (n + v))
20:12:13 <bobzhang> sum2 should be the same as sum1, if i use cont monad
20:12:44 <bobzhang> but sum2 does not stackoverflow
20:12:47 <bobzhang> sum1 does
20:12:49 <Eduard_Munteanu> Not really.
20:13:20 <bobzhang> Eduard_Munteanu: if you desugar the cont monad, they are the same
20:13:57 <Eduard_Munteanu> No. For instance, x >>= f stays x >>= f unless forced somehow.
20:14:47 <Eduard_Munteanu> That's why you've got strict and lazy State monads and such stuff.
20:14:49 <bobzhang> Eduard_Munteanu:  yeap, I got your idea
20:15:00 <bobzhang> Eduard_Munteanu: can you explaint it more clearly
20:15:00 <Eduard_Munteanu> I'm not sure there's a similar thing for Cont though.
20:16:23 <monochrom> for cont monad, x>>=f is just a thin wrapper of x with f as continuation.
20:16:39 <ghartshaw> @pl \y -> f xs y ++ "\n"
20:16:40 <lambdabot> (++ "\n") . f xs
20:16:40 <monochrom> @let sum1 n = if n ==0 then return 0 else sum1 (n-1) >>= \ !v -> return (n+v)
20:16:42 <lambdabot>  <local>:5:54: Illegal bang-pattern (use -XBangPatterns)
20:16:51 <Eduard_Munteanu> What exactly? The main idea was functions aren't exactly the same as their inline expansions.
20:16:55 <monochrom> @let sum1 n = if n ==0 then return 0 else sum1 (n-1) >>= \ v -> v `seq` return (n+v)
20:16:57 <lambdabot>  Defined.
20:17:03 <monochrom> flip runCont id (sum1 3000000)
20:17:06 <monochrom> > flip runCont id (sum1 3000000)
20:17:10 <lambdabot>   mueval-core: Time limit exceeded
20:17:23 <monochrom> this one takes a while but doesn't stack-overflow
20:18:05 <ghartshaw> @pl \x -> if' (elem (f x y) cs) '*' '.'
20:18:05 <lambdabot> flip (flip if' '*' . flip elem cs . flip f y) '.'
20:18:51 <Jafet> @pl \x -> if elem (f x y) xs then '*' else '.'
20:18:51 <lambdabot> flip (flip if' '*' . flip elem xs . flip f y) '.'
20:18:56 <monochrom> > flip runCont id (sum1 999999)
20:19:00 <lambdabot>   mueval-core: Time limit exceeded
20:20:04 <bobzhang> yeap , sum1 n = if  n==0  then return 0 else sum1 (n-1) >>= \ v ->  seq v (return (n+v))
20:20:11 <bobzhang> this one does not stackoverflow
20:21:00 <bobzhang> great
20:21:05 <bobzhang> main = print (runIdentity  (sum1 3000000)) this stackoverflow
20:21:12 <bobzhang> this is exactly what I want
20:22:24 <Eduard_Munteanu> You can further reduce the stack using   +RTS -K16k -RTS for instance
20:22:44 <bobzhang> so what's the difference sum1 n = if  n==0  then return 0 else sum1 (n-1) >>= \ v ->  seq v (return (n+v))
20:22:45 <Eduard_Munteanu> (as a parameter to your executable)
20:23:04 <bobzhang> and sum1 n = if n==0 then return 0 else sum1 (n-1)>>=\v -> return (n+v)
20:23:54 <monochrom> x>>=f is roughly \c -> x (\a -> f a c)
20:23:54 <Eduard_Munteanu> bobzhang: a `seq` b will force a when evaluating b
20:24:17 <ddarius> I thought you were done with Haskell, EvilMachine?
20:24:42 <EvilMachine> ddarius: lol. yeah, well. i come back for the nice people and smart discussions. :D
20:25:01 <Eduard_Munteanu> Why would you "be done" with it?
20:25:04 <EvilMachine> or was it the other way around?
20:25:19 <EvilMachine> Eduard_Munteanu: i was very frustrateted with something. i already forgot what.
20:25:43 <EvilMachine> (don’t mind the typos. i’m a liiittle bit tired)
20:26:16 <EvilMachine> but i think it was ddarius, who wisely linked me to the "that girl" text. ;)
20:27:01 <ddarius> No, I did not.
20:27:33 <EvilMachine> ok
20:27:54 <EvilMachine> ddarius: your last name isn’t "Hopek" by any chance?
20:28:21 <ddarius>  /whois ddarius
20:28:27 <EvilMachine> lol
20:28:48 <EvilMachine> ok. consider me facepalmed. :)
20:33:50 <mmos1127> Running on windows. I wrote a small parsec program. The input is a file (read via readFile)-- call it file X. I'm running it interactively (ghci). I want to edit X between runs, but it seems that ghci grabs it and I don't have permission. Does this have something to do with lazy IO?
20:34:18 <monochrom> yes, file not closed
20:34:43 <mmos1127> Is it possible to force the file closed? Should I switch to using strict ByteString?
20:34:44 <bobzhang> mmos1127: System.IO.Strict
20:35:08 <monochrom> end your parser with "eof"
20:35:57 <monochrom> "eof" doesn't consume the input to the end. rather, it just checks, "is there more?", if yes, fail
20:36:27 <ddarius> So if you are not parsing the whole file, eof will not help.
20:36:43 <monochrom> however, hopefully that failure will force you to change the rest of your parser to consume all input
20:36:47 <mmos1127> can I put something like "manyTill anyChar eof"
20:36:59 <monochrom> depends on your parser
20:37:36 <mmos1127> success-- manyTill anyChar eof works
20:38:22 <mmos1127> You are right I need to make a parser that consumes all input - I'm asking for trouble if I ignore input and thereby fail to inform the user of a specific problem
20:38:55 <shachaf> @karma+ success
20:38:55 <lambdabot> success's karma raised to 0.
20:39:25 <shachaf> @karma+ readFile)
20:39:25 <lambdabot> readFile)'s karma raised to 0.
20:39:42 <shachaf> preflex: karma read via readFile
20:39:42 <preflex>  read via readFile: -1
20:39:48 <shachaf> Hah.
20:40:29 <bfig> http://dl.dropbox.com/u/38564661/genMarkov.hs <- day's work :)
20:41:22 <ddarius> We had to chase after jfredette to fix his karma mashing.
20:44:32 <mmos1127> lets say my input to the parser is a file with a bunch of meaningful content inside brackets '[' ']' -- and I want to read all of them until eof. I'm not clear on how to structure that. It seems like at some point I have to check if there is another opening bracket or there is eof. do I put something like --  try (manyTill space '[') <|> eof
20:46:02 * hackagebot mwc-random 0.10.0.1 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.10.0.1 (BryanOSullivan)
20:46:13 <monochrom> isn't that some kind of "many (char '[' ... char ']')"?
20:46:38 <mmos1127> that sounds simpler
20:47:06 <monochrom> plus skipping spaces or whatever your grammar says to skip
20:49:10 <mmos1127> does the parser given to "many" need to fail without consuming anything.. you know, like fail on the first character.. or use "try"? I'm confused on these points.
20:50:06 <monochrom> well there is what parsec thinks it has consumed, and what readFile thinks it has consumed
20:50:46 <mmos1127> I'm just thinking of parsec at the moment.. just trying to write code that works
20:51:02 * hackagebot resource-pool 0.2.0.2 - A high-performance striped resource pooling implementation  http://hackage.haskell.org/package/resource-pool-0.2.0.2 (BryanOSullivan)
20:51:15 <monochrom> using "try" can be an "unconsume" for parsec but information-theoretically there is no way you can tell readFile "I read 10 bytes but forget it"
20:55:13 <monochrom> you have input "aaabbb" and you parse with many (char 'a'). parsec will consume just "aaa"
20:55:30 <monochrom> (readFile will consume "aaab")
20:58:03 <mmos1127> I see there is a skipMany1. Is there a skipMany (that can optionally consume zero characters)
20:58:07 <ddarius> monochrom: His question is: if p = char 'a' >> char 'b' will many p when applied to "ac" succeed or fail.
20:58:37 <monochrom> it will fail
21:00:15 <mmos1127> and will it consume the 'a'?  can you do something like (many parse1) <|> (many parse2) in general. Is the use of try needed in parse1 and parse2?
21:00:58 <monochrom> depends
21:01:06 <mmos1127> I tried skipMany and it was defined and works as expected. I don't see it in the docs but maybe I have a different version.
21:02:46 <ddarius> @hoogle skipMany
21:02:49 <lambdabot> Text.Parsec.Prim skipMany :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
21:02:49 <lambdabot> Text.ParserCombinators.ReadP skipMany :: ReadP a -> ReadP ()
21:02:49 <lambdabot> Text.ParserCombinators.Parsec.Prim skipMany :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
21:03:29 <ddarius> skipMany is in the same place many is.
21:05:05 <monochrom> (many parse1) <|> (many parse2) = many parse1  for most cases
21:08:30 <hpaste> luite pasted “yesod forms 0.3 examples” at http://hpaste.org/50536
21:11:40 <ddarius> Why is there a Firefox 6?  What happened to 5?
21:12:22 <mmos1127> Firefox has gone to a "rapid release schedule" as reported in various places.
21:12:52 <mmos1127> The thing that confuses me is that you can release as quickly as you want, and you can increment your version number however you want. These are independent issues.
21:13:05 <ddarius> So Firefox 26 should be out by the end of next year?
21:13:21 <mmos1127> Probably so.
21:13:22 <jrockway> they stopped doing version numbers, much like chrome did
21:13:28 <jrockway> now it updates itself while you sleep
21:13:42 <ddarius> (Ironically, Netscape had a version jump from 4 to 6, and 6 was a goddamn mess.)
21:13:45 <jrockway> bringing the experience linux users have had for almost 20 years to windows :)
21:14:41 <EvilMachine> ddarius: Firefox 8 is already in the making. ^^
21:14:50 * ddarius is using Firefox 3.6 anyway.
21:15:29 * djahandarie is using telnet anyway.
21:15:35 <EvilMachine> i think firefox has jumped the shark. and they consider going completely version-less in the future. because that will help with the bugs... ;)
21:15:58 <ddarius> Firefox jumped the shark when it was Firebird.
21:16:15 <EvilMachine> I think we will see Firefox 95, 98, ME, 2000, XP, Vista and THEN Firefox 7! :D
21:16:39 <jrockway> sadly, mozilla just doesn't have the infrastructure for software development that google does
21:17:09 <ddarius> EvilMachine: Then I will use Firefox 2000.
21:17:19 <EvilMachine> ddarius: actually, firefox un-jumped the shark with the help of Firebug, AdBlock Plus, etc, etc, etc. In other words: It’s the add-ons baby! But with the constant version-changing-incompatibility-blocking that seems to end now.
21:17:55 <ddarius> EvilMachine: The only add-on I use is Flashblock and occasionally Rikaichan.
21:18:04 <EvilMachine> ddarius: By that time, Firefox will be just VMWare with tabs and a url bar to tell it where to load the disk image from. ^^
21:18:27 <EvilMachine> ddarius: how do you even *live* without adblock??
21:18:29 <EvilMachine> ^^
21:19:15 * EvilMachine looks forward to VMfox. ;)
21:19:32 <EvilMachine> (or is that FireWare VM edition?
21:19:33 <EvilMachine> )
21:19:59 <jeetu> my personal fav addon is pentadactyl.
21:20:22 <EvilMachine> We already are halfway there: http://bellard.org/jslinux/
21:20:33 <EvilMachine> Who wants to be the first to port GHC to javascript? ^^
21:21:49 <ddarius> EvilMachine: There is some work on ghcjs.  So all you'd need to do is port the run-time and bootstrap GHC.
21:22:18 <EvilMachine> ddarius: Now you’re really frightening me!
21:24:31 <EvilMachine> Doesn’t Emacs have a browser that supports JavaScript? (I’m sure it does. ;) Because then I might run a VirtualBox with Windows ME, running a Windows build of Emacs, running jslinux, running ghcjs compiling ghcjs on my mobile phone. See you in a MILLION years, baby!
21:26:03 <EvilMachine> I fear that setup might bring down a K computer though. ^^
21:29:58 <EvilMachine> is it bad to have such high bandwidth that your kernel thinks you’re SYN flooded on normal file transfers? ;)
21:34:14 <ghartshaw> @hoogle if'
21:34:15 <lambdabot> No results found
21:38:14 <armence> Hello all. How is "Real World Haskell" for someone who has lots of OOP/procedural experience but very little FP experience?
21:39:18 <mustelo> armence, the usual recommendation is to try both RWH and LYAH and see which you like, or just read them both
21:39:20 <mustelo> @where lyah
21:39:21 <lambdabot> http://www.learnyouahaskell.com/
21:40:59 <armence> mustelo, I've been looking at both online. I have been finding that LYAH is really nice at introducing concepts but I just don't feel like I understand where and how to use those concepts in a wider context. (Don't know if that's clear)
21:41:23 <mustelo> then I'd say switch to RWH for a bit and see what you think :)
21:41:39 <armence> mustelo, Thanks for the advice :)
21:42:24 <mustelo> also, nothing can substitute for coming up with your own things to code up
21:46:03 * hackagebot attoparsec 0.9.1.2 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.9.1.2 (BryanOSullivan)
22:34:07 <d-day> lol...
22:34:16 <d-day> I just completed the 'saddleback search' pearl
22:34:21 <d-day> blew my frickin' mind
22:36:44 <edwardk> its probably the best pearl in the book
22:37:44 <d-day> edwardk: why didn't he take the whole thing one step further, and use it to sort double-sided lists?
22:38:17 <edwardk> probably because the pearl was pretty long by that point
22:38:22 <kmc> there's a book?
22:38:26 <edwardk> yeah
22:38:36 <edwardk> http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383
22:39:01 <edwardk> i usually recommend it to folks after LYAH/RWH because it is a good introduction to _thinking_ functionally
22:39:32 <d-day> edwardk: trying it on something like invert (\(a,b) -> a * b) (number) ...
22:39:46 <d-day> that took O(seconds) when n ~ 2000
22:39:55 <d-day> and didn't complete when n ~ 4000
22:40:09 <kmc> nice edwardk
22:40:24 <d-day> and with invertBS (...), it easily handles n ~ (2^20)
22:40:32 <d-day> in O(seconds)
22:40:48 <edwardk> kmc: in it he improves the asymptotics of saddleback search by functional reasoning as one of the random pearls
22:40:52 <zzo38> I get error trying to use C preprocessor to make it difference in GHCi than when compiling normally.
22:42:26 <mustelo> what's the title of that pearl?
22:42:42 <mustelo> ah, "improving on saddleback search"
22:42:48 <zzo38> Is it because it doesn't work with .lhs file?
22:43:24 <edwardk> mustelo: sounds right. my copy is at the office
22:44:40 <NihilistDandy> edwardk: Good recommendation
22:44:47 <NihilistDandy> Love that book
22:45:10 <d-day> I've exercised using some FPearls before, but none of them seemed as significant as an improvement as this one :o
22:45:14 <edwardk> i have other stuff by bird, but he really found his voice in that book
22:45:16 <d-day> and there are some other gems later, I read ahead :o
22:45:23 <edwardk> yeah
22:45:49 <edwardk> he took the time to really elaborate on the published pearls and fit them into a semi-coherent order, etc.
22:46:29 <ivanm> with quasiquotation: if I already have a parser for values of that type, but I want QQ with antiquotation support, do I need to write a new parser?
22:46:47 <ivanm> (and possibly a new data-type with anti-quotation values added in?)
22:47:02 <d-day> edwardk: so, for instance, if you look at something like representing numbers as lists in base negative (ternary) or larger, the lists of numbers you get are (twice) monotonically increasing.
22:47:07 <edwardk> ivanm: i always just add in a term for the antiquotes
22:47:17 <edwardk> so i wind up changing the grammar
22:47:25 <ivanm> edwardk: well, in this case I don't want people using it for "normal" usage
22:47:29 <d-day> or base phinary (there's some source out there for that)
22:47:40 <ivanm> I'm thinking of having a quasiquoter for record labels in graphviz
22:47:47 <edwardk> d-day: i always felt irrational bases were silly
22:48:00 <d-day> edwardk: yeah, irrational yes, but negative bases not necessarily
22:48:05 <d-day> though I am not sure about irrational ones
22:48:07 <edwardk> i use negative bases
22:48:13 <d-day> negative quadratic bases interest me
22:48:14 <edwardk> i use lots of non-standard bases
22:48:26 <d-day> edwardk: so the question is, with this binary sort
22:48:28 <d-day> he has a function
22:48:29 <edwardk> zeroless, skew binomial, etc.
22:48:38 <d-day> find (0, m) (n, 0) f z
22:48:49 <d-day> couldn't you do something like
22:49:00 <d-day> find (0,m) (m-n,n-m), (n,0) f z
22:49:26 <d-day> and differentiate every element in a on the left side of a double queue with its corresponding on on the right side?
22:49:56 <edwardk> i'd have to look at that with the algorithm in front of me to speak intelligently on it
22:50:30 <ivanm> edwardk: is this in any of your published (as in on hackage) software?
22:50:34 <d-day> do you know what the 'r' and 'c' in rfind and cfind he might intend to stand for?
22:50:39 <d-day> right? center?
22:51:01 <edwardk> ivanm: the quasiquotation stuff?
22:51:09 <ivanm> yeah
22:51:19 <edwardk> ivanm: i don't think i have any (interesting) quasiquoters on hackage actually
22:51:25 <ivanm> *nod*
22:51:29 <edwardk> you might want to look at the guts of jmacro though
22:51:35 <ivanm> most there seem to be unmaintained :/
22:51:36 <edwardk> gershom does it right
22:51:40 <ivanm> OK
22:51:45 <edwardk> well, thats because matt morrow wrote most of them
22:51:49 <ivanm> heh, true
22:52:03 <ivanm> edwardk: any idea what the two new constructors in QuasiQuoter are for? all packages I found just had "undefined" for them
22:52:10 <edwardk> i'll probably go collect them up and update them for current template haskell, etc.
22:53:31 <edwardk> if i had to guess? quasiquoting in Types and declarations were finally added.
22:53:49 <edwardk> yep thats it
22:53:53 <edwardk> http://hackage.haskell.org/packages/archive/template-haskell/2.5.0.0/doc/html/src/Language-Haskell-TH-Quote.html#QuasiQuoter
22:54:06 <edwardk> quoteExp, quotePat, quoteType and quoteDec
22:54:29 <edwardk> so you can finally splice them in at the top level directly without going through some silly TH intermediary
22:54:36 <edwardk> and you can splice into types
22:54:49 <edwardk> er quasiquote into
22:55:03 <d-day> edwardk: ok, in the future, for crazy people like me, I would put this book *ahead* of RWH after LYAH ... precisely because LYAH builds just enough functional programming style into your brain for you to get intrigued at this great progression in FP:Bird
22:55:27 <d-day> especially several times where he uses the (n-1) pearl to show why the (n) pearl is useful
22:55:47 <ivanm> edwardk: you mean you can have QQ in type sigs? :o
22:56:16 <edwardk> d-day: *nods* it helps to have a certain level of 'fp maturity' though before tackling the functional pearls book, be that from picking up ML or scheme, or reading a couple of random haskell books or what have you
22:56:26 <edwardk> ivanm: welcome to the future
22:56:41 <ivanm> yeah, note that the pearls book uses non-standard haskell in some cases
22:56:51 <ivanm> e.g. I think Bird uses two different definitions of delete
22:57:01 <ivanm> one of which is the standard one, the other is filter (/=x)
22:57:11 <edwardk> probably
22:57:27 <edwardk> he had his own 'squiggol' school for so long i doubt he remembers the official definitions ;)
22:57:55 <ivanm> "squiggol" ?
22:57:56 <d-day> edwardk: i assume you're rather a fan of the hylomorphism/nexus example too?
22:58:02 <d-day> ivanm: first google result
22:58:48 <ivanm> ahhh
22:58:57 <edwardk> i'm not a huge fan of hylomorphisms in general
22:59:04 <edwardk> i tend to find that they obscure meaning more than help
22:59:20 <edwardk> and that they weren't the most useful way to think about fusion opportunities that arose
22:59:48 <d-day> one thing that I'm beginning to learn (if I'm correct here)
23:00:02 <d-day> is that, unlike what I was (very recently) taught in school (all the way up through college)
23:00:19 <d-day> there are lots of things out there that are 'proof principles' instead of proofs
23:00:40 <zzo38> Is there a way to use Template Haskell to check for GHCi or not? Using C preprocessor doesn't work
23:00:40 <edwardk> ?
23:00:41 <d-day> that are as useful (if not much more useful) than having done some proofs of some things you didn't really get :O
23:00:48 <edwardk> zzo38: no idea
23:01:22 <zzo38> edwardk: oerjan is also no idea!
23:01:31 <d-day> well, like the univsrality of fold/unfold fusion
23:02:33 <edwardk> d-day: well, the unfoldr/destroy fusion school (in its later stream fusion incarnation) seems to expose more optimization opportunities in practice
23:02:43 <edwardk> even if it changes meaning
23:02:57 <edwardk> the hylo guys were never able to deliver
23:03:24 <d-day> i am trying to relate the fact that I was always taught that finding and deriving specific proofs of things you wanted to demonstrate (often by induction on Nats)
23:03:37 <d-day> was the holy grail of everything mathematical
23:03:42 <edwardk> so given 15 years of thought by some crazy smart people, i'm inclined to think of it as an intellectual dead end.
23:04:12 <d-day> and with category theory it seems that there are some things (fold fusion, least fixed point, and others?)
23:04:14 <edwardk> d-day: but that is just sort of the first-order artifact. it is better to derive tools to make it easier to define those things
23:04:20 <d-day> yeah
23:04:32 <edwardk> like with programming, the difference between writing a program and a library
23:04:46 <kmc> which is the preferred import for SYB? Data.Generics or Generics.SYB?
23:04:55 <edwardk> designing a scalable 'theory' is just as tricky as designing a scalable program
23:05:05 <dreixel> kmc: I'd say Generics.SYB
23:05:06 <kmc> i'm a little hesitant to label SYB as *the* generics system
23:05:14 <edwardk> I just pull in Data.Data ;)
23:05:16 <kmc> especially since GHC has baked-in support for another one now
23:05:16 <dreixel> but all the code really is in Data.Generics
23:05:29 <kmc> Data.Data doesn't get you mkT, everywhere, etc.
23:05:30 <kmc> afaik
23:05:40 <dreixel> right.
23:05:50 <edwardk> Data.Generics does everything else
23:05:55 <dreixel> you should use Data.Data if it's got all you need because then you do not need the syb package
23:06:05 <kmc> yeah
23:06:08 <d-day> edwardk: have you seen/read "On Noramlized Integral Table Algebras"?
23:06:16 <edwardk> not off hand
23:06:29 <d-day> also called "fusion rings" (but not related, evidently)
23:06:42 <edwardk> springer book?
23:06:50 <d-day> yep
23:07:05 <edwardk> definitely haven't read that one
23:07:36 <d-day> this seems pretty significant (but then again I'm poking around areas related to divsion algebras)
23:09:02 <edwardk> my abstract algebra experience up until fairly recently was mostly using some pretty boring introductory level concepts and some randomly weakened variants
23:09:25 <d-day> well I'm in all this crap to try to do physics, as crazy as that sounds
23:09:31 <edwardk> fair nuff
23:09:49 <d-day> and we've been known to use some pretty strange pure maths constructions and act like we're talking about physics
23:09:53 <edwardk> i'm mostly using it to model equations and tackle taylor models, etc.
23:10:14 <d-day> edwardk: and then one day, a person like you and a person like me realizes they're doing the same damn thing
23:10:32 <d-day> and since we're using haskell, Hayoo might even tell us that :o
23:10:52 <d-day> I *love* it when I can tell a friend "yeah, you just go to a search engine, and enter the types"
23:11:16 <edwardk> well, the major users of taylor models are physicists
23:11:46 <edwardk> http://bt.pa.msu.edu/index_cosy.htm
23:12:33 <edwardk> if copumpkin and i can figure out the remaining bugs blocking 'precision' from working, i can get taylor models working in haskell
23:13:15 <edwardk> which basicaly gives you something like interval models without the horrible saturation effects
23:13:35 <edwardk> or at least with the ability to push those effects down as far as you need to go
23:13:49 <d-day> what kind of physicists?
23:13:55 <d-day> and what domain(s)?
23:14:26 <edwardk> http://www.bt.pa.msu.edu/pub/ has a list of publications
23:14:51 <edwardk> i'm rather distinctly _not_ a physicist, so i hardly know what applications are relevant
23:14:57 <d-day> lol
23:15:16 <d-day> it looks like particle physics
23:15:27 <d-day> and I hadn't heard of this effort :/
23:15:34 <edwardk> i know some basic quantum mechanics, and enough to talk about quantum computation, unitary operators, bra/ket, etc.
23:15:41 <edwardk> but thats about it
23:15:56 <edwardk> oh and the random heat equations that come up when motivating fourier analysis
23:16:06 <edwardk> beyond that physics is a black box to me ;)
23:16:22 <d-day> if you get the information and heat laws down, then (almost) all of the other physics follows
23:16:38 <d-day> except some of the notions of duality
23:16:40 <luite> do you have different (non-physics?) applications for your taylor models packages yourself?
23:17:06 <edwardk> luite: i have lots of financial data available to me to play with models for
23:17:32 <edwardk> and on the other side, i have the ad package that can provide me with all the derivatives i want
23:17:49 <luite> ah I suspected as much :p
23:17:53 <d-day> i plan on tackling that package next :o
23:18:10 <edwardk> duality i'm down with, i'm mostly a computational geometer by background. duality is what drew me into category theory
23:18:39 <d-day> edwardk: yep, so you probably understand more than most experimental physicists
23:18:46 <luite> will you still join this channel after you make a fortune and buy a yacht and a few tropical islands? ;p
23:18:56 <d-day> haha, he'll give it away :o
23:19:04 <edwardk> i've made and lost at least one fortune already ;)
23:19:25 <edwardk> nah, having both had and not had money i find it is much nicer to have it ;)
23:19:40 <pikhq> edwardk: Sounds like you know enough about physics to sound like a physicist to the typical layman.
23:19:57 <edwardk> pikhq: pretty much =)
23:20:01 <luite> hehe I don't think you need to know much physics for that :)
23:20:06 <d-day> lol, true
23:20:19 <pikhq> True, only really need classical mechanics for that...
23:20:30 <edwardk> pikhq: i have a similar relationship with category theory ;)
23:20:36 <d-day> hell, in this country (US) you just need to know that balls move down ramps
23:20:55 <kmc> d-day, that's just a theory
23:20:57 <pikhq> d-day: :(
23:21:02 <luite> pikhq: nah they might've read some hawking or feynman book, or is that already not layman territory anymore?
23:21:16 <pikhq> luite: That's already *far* beyond layman territory.
23:21:23 <luite> oh :(
23:21:30 <pikhq> Well. Depends on the Hawking or Feynman, actually.
23:21:32 <edwardk> heck i loaned a half dozen feynman books to my old personal trainer ;)
23:21:35 <d-day> luite: at least if they've read Feynman, they realize how silly so many of the questions humans are compelled to ask really are
23:22:14 <edwardk> that reminds me i should go see about getting those back
23:22:24 <pikhq> The Feynman Lectures? *Very* far beyond layman.
23:22:40 <d-day> yep.
23:22:41 <pikhq> Surely You're Joking? Eh. Not necessarily.
23:23:10 <d-day> It was Susskind's lectures that convinced me of the importance of information in physics (even if you don't use his definitions verbatim)
23:23:52 <d-day> though I don't get all this quantum category stuff... yet :/
23:23:56 <edwardk> (they were the feynman lectures, six easy and not so easy pieces, the computation book, and then a couple of fluffier pieces on alice in quantumland, etc.
23:24:04 <d-day> anyhoo, good enough for the day. night
23:24:10 <edwardk> night man
23:39:32 <ddarius> d-day: Have you read Jaynes and Hestenes?
23:43:23 * ddarius doesn't actually particularly care for Feynman's views on QED.
