00:00:15 <nlogax> is it the "managing parallelism" one? i think i have it on dropbox
00:00:56 <nlogax> http://dl.dropbox.com/u/2275898/SPJ%20-%20Managing%20Parallelism.mp4
00:02:36 <ketil> nlogax, ah, nice.  It still seems to break chromium (I just get a non-working play button), but a wget appears to download the file, so it's probably a browser config issue.  Thanks!
00:03:13 <Axman6> worked fine in safari for me. but i think you had to view it on a site that wasn't vimeo for some stupid reason
00:03:26 <Axman6> going directly to vimeo said it was private for me too
00:03:49 <nlogax> same for me. but could still download it, and watch it in a window bigger than a stamp
00:05:04 <ketil> nlogax, shame about the quality, but sound is good, which is the imporant bit.  And SPJ is easily recognizable from his enthusiasm :-)
00:05:59 <nlogax> ketil: haha, yes :)
01:19:37 * hackagebot hmatrix 0.11.0.4 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.11.0.4 (AlbertoRuiz)
01:40:31 <mrcarrot> what is the best way to do bitwise xor on two integers, lets say they are 3 and 2
01:40:51 <mauke> > 3 `xor` 2  -- I bet this fails
01:40:52 <lambdabot>   Ambiguous type variable `a' in the constraint:
01:40:52 <lambdabot>    `Data.Bits.Bits a'
01:40:52 <lambdabot>      a...
01:40:57 <mauke> > 3 `xor` 2  :: Integer
01:40:58 <lambdabot>   1
01:41:08 <mrcarrot> thanks
01:41:18 <shachaf> > 1 :: Int
01:41:19 <lambdabot>   1
01:41:32 <co_dh> :t xor
01:41:33 <lambdabot> forall a. (Bits a) => a -> a -> a
01:42:51 <co_dh> :i Bits
01:43:01 <mauke> there is no :i
01:44:33 <haskellcurious> Yo anyone know about yesod?
01:45:45 <haskellcurious> In particular, I'm curious if yesod at all integrates with yhc?
01:45:51 <haskellcurious> (the js compiler)
01:46:17 <shachaf> I'd be quite surprised.
01:46:40 <haskellcurious> Hmm..
01:46:57 <haskellcurious> My goal is to use the same language on the client as the server, like a sane person should
01:47:09 <haskellcurious> shachaf do you know of any way to swing this with haskell?
01:48:13 <shachaf> I don't know whether it's all that sane, given how different/constrained the browser environment is.
01:49:13 <shachaf> At any rate, I wasn't under the impression that Yhc's JavaScript backend was actually usable/used in practice.
01:49:19 <shachaf> I might be wrong, of course. :-)
01:50:32 <haskellcurious> I see. 
01:50:39 <haskellcurious> Have you heard of a better implementation?
01:51:21 <shachaf> When I said Yhc I meant "any Haskell compiler".
01:51:36 * shachaf hopes he isn't spouting horrible lies.
01:51:55 <quicksilver> as far as I know the yhc js backend is the best one, and it's not widely used
01:52:00 <quicksilver> that doesn't necessarily mean it's not useful
01:52:07 <quicksilver> but you don't hear much talked about it.
01:52:17 <haskellcurious> what a shame
01:52:49 <haskellcurious> Have you heard of a better record implementation?
01:52:56 <haskellcurious> Something more readable like json?
01:53:02 <haskellcurious> (on an unrelated note :) )
01:53:53 <quicksilver> of all the possible criticism of haskell's records, readability is a strange one :)
01:54:10 <quicksilver> Foo { bar = "baz", bam = "bambam" } is not really so different from JSON.
01:54:38 <haskellcurious> Wait.. Apologies.. 
01:54:47 <haskellcurious> But is Foo required?
01:54:54 <quicksilver> yes. it's the constructor.
01:55:08 <quicksilver> the main thing to remember about haskell's record system is that it isn't a record system.
01:55:09 <haskellcurious> What if I just want the type to be implicit in the structure
01:55:11 <haskellcurious> like SML
01:55:35 * mauke points to HList and runs away
01:55:37 <quicksilver> haskell's "record system" is just an alternative syntax algebraid types.
01:55:41 <haskellcurious> So what if I want to define a method that takes in any record having a bar::Int member?
01:55:55 <quicksilver> as I said, it isn't a record system.
01:55:56 * shachaf was resisting doing that.
01:56:06 <haskellcurious> How do you cope :P
01:56:09 <quicksilver> it doesn't have any of the features you associate with records.
01:56:21 <shachaf> haskellcurious: When would you want that?
01:56:32 <haskellcurious> *all the time*
01:56:33 <quicksilver> class hasBar x where { bar :: Lens x Int }
01:56:42 <quicksilver> for some appropriate definition of 'Lens'
01:56:49 <quicksilver> see, perhaps, fclabels or data-accessor
01:57:04 <shachaf> quicksilver: E.g. Lens = (->)? :-)
01:57:09 <quicksilver> shachaf: no.
01:57:12 <haskellcurious> It would be great if I could just say myFunc x = x.bar + x.baz + 4
01:57:34 <haskellcurious> then I could call it like myFunc {bar=2, baz=5}
01:57:49 <quicksilver> I think we disagree about what is great.
01:57:57 <haskellcurious> SML does this very well
01:58:05 <haskellcurious> Why is that not great?
01:58:09 <shachaf> quicksilver: Why wouldn't that do it?
01:58:12 <quicksilver> although the ocaml and SML record systems do represent interesting points in the design space.
01:58:24 <shachaf> Ah, for modifications also?
01:58:27 <Peaker> haskellcurious, What's the type of myFunc, when it is defined that way?
01:58:39 <haskellcurious> It is implicit in the definition
01:58:40 <quicksilver> shachaf: because, typically, when I want hasBar I want to be able to update as well observe
01:59:03 <Peaker> haskellcurious, what will the type inference engine infer?
01:59:04 <quicksilver> Peaker: something like < bar, baz, ... > -> Int
01:59:13 <haskellcurious> I could have also typed the type definition myfunc :: {bar::Int, baz::Int}->Int
01:59:14 <quicksilver> is how ocaml/sml handle it.
01:59:24 <quicksilver> invented syntax, obviously.
01:59:37 <quicksilver> haskellcurious: the ocaml and sml systems interact badly with various aspects of the haskell type system
01:59:37 <shachaf> All syntax is invented.
01:59:43 * shachaf should goto sleep;
01:59:46 <quicksilver> which is why nobody has just ported them.
01:59:53 <haskellcurious> Actually, the ocaml type sytem will NOT do this
01:59:58 <haskellcurious> I had to quit it because of this.
02:00:05 <quicksilver> although plenty of people talk about it.
02:00:20 <haskellcurious> one language to rule them all!
02:00:33 <mauke> doesn't ocaml have dynamic records?
02:00:47 <mauke> ISTR `tags and stuff
02:01:03 <mauke> or was the extensible stuff just for objects?
02:01:16 <quicksilver> mauke: `tags are extensible variants not records
02:01:28 <mauke> ah
02:01:28 <quicksilver> but I must admit I thought they had extensible records too
02:01:56 <quicksilver> haskellcurious: basically, it's hard to make subtyping interoperate cleanly with various other features we value.
02:02:03 <quicksilver> I can't reconstruct the full argument.
02:02:38 <haskellcurious> Okay.
02:02:47 <haskellcurious> All the grapefruit etc libs are crazy
02:03:14 <quicksilver> however you can certainly model interesting things which are a bit like extensible records.
02:03:30 <mauke> olegware :-)
02:03:40 <quicksilver> the 'Attribute' concept which is used (independently) in GTK and WX is one example
02:03:53 <Peaker> haskellcurious, When using Haskell, I don't use records that much at all. I might not know what I'm missing, having never used a "record system" :)
02:04:00 <quicksilver> new Button [ title := "Click me", action := doThis ]
02:04:11 <quicksilver> looks a little bit like an anonymous/extensible record.
02:04:48 <haskellcurious> my eyes have been opened to records based programming
02:04:51 <Peaker> quicksilver, That comes at the expense of type safety, right?  If title is a mandatory attribute, and you use: new Button [] ?
02:05:02 <haskellcurious> it's so close to the spirit of functional programming imho
02:05:06 <mauke> http://homepages.cwi.nl/~ralf/HList/
02:05:13 <haskellcurious> You only specify what you want
02:05:14 <Peaker> haskellcurious, have they been opened to type-class based programming? :)
02:05:17 <haskellcurious> not how to accomplish it
02:05:21 <haskellcurious> declarative
02:05:30 <shachaf> mauke: I thought you'd run away?
02:05:33 <haskellcurious> Well, they may be soon.
02:05:35 <haskellcurious> but..
02:05:52 <haskellcurious> With declarative programming, your code often 'looks' like the interface that it produces graphically
02:05:54 <haskellcurious> that is powerful
02:06:18 <quicksilver> Peaker: erm, it's not at the expense of *all* type saftey
02:06:23 <Peaker> haskellcurious, not sure how close OCaml/SML come to this, but here is an example of a nice thing in Haskell: https://github.com/yairchu/red-black-tree
02:06:29 <quicksilver> Peaker: and it depends a little bit how elaborate you are prepared to get.
02:07:02 <quicksilver> Peaker: it trivally checks that the argument to title is a string (which is a start) and it can fairly simply make sure that you only provide attributes which are applicable to Button.
02:07:02 <haskellcurious> Yah quicksilver, and if you look ar Ur/UrWeb.
02:07:08 <haskellcurious> It si *quite* elaborate
02:07:10 <Peaker> haskellcurious, https://github.com/yairchu/red-black-tree/blob/master/AvlTree.hs <-- look at "data Tree a where .." until the end of "data HeightRule"
02:07:13 <haskellcurious> *too* elaborate
02:07:19 <quicksilver> Peaker: required arguments are, I admit, quite a bit harder.
02:07:52 <quicksilver> (required arguments force you to stop using [] and start using a custom list-ish-type which collects requirements in a type-level parameter)
02:08:04 <quicksilver> actually that may not be true.
02:08:10 <quicksilver> you can get some distance with constraints on the []
02:08:13 <Peaker> haskellcurious, That's the type of an AVL tree, that within those 9 lines - specifies the AVL invariants - such that the compiler guarantees your AVL tree is balanced with the AVL invariants 
02:08:56 <Peaker> haskellcurious, Haskell is quite expressive, but it's a hard sell since so many languages are very expressive too.  I think a more unique point about Haskell is making it relatively easy to guarantee arbitrary things with the type system, while still remaining expressive/conise
02:09:35 <haskellcurious> Yah, you don't need to sell me on those, though I appreciate it. I'll look deeper and give it a chance anyways..
02:09:41 <Peaker> I don't think guaranteed-balanced AVL trees are possible in F#, OCaml, SML, etc
02:09:55 <haskellcurious> Sure, I love those things about the type system.
02:10:08 <haskellcurious> But I want to define really expressive interfaces
02:10:20 <haskellcurious> to code that other people will call into
02:10:32 <haskellcurious> the code should be self explanatory by reading it, and records help that
02:11:27 <Peaker> haskellcurious, well, in Haskell you have to choose between ugly-syntax inextensible records whose field names are put in the modules namespace -- and anonymous products.  I find the choice OK for most things.. At worst you need a comment rather than a name, or some ugly syntax
02:12:04 <quicksilver> Peaker: however a problem with this safety is that the error messages are hideous :)
02:12:05 <haskellcurious> sad face
02:12:29 <Peaker> haskellcurious, It's important not to fall too deeply into one analyzed disadvantage and lose sight of the whole picture :)
02:12:48 <Peaker> haskellcurious, I think Haskell has plenty of very interesting advantages to make up for it
02:13:16 <haskellcurious> Yah, for most purposes I'm sure it does
02:13:22 <Peaker> quicksilver, well, the interface is wrapped with a sane API that doesn't expose the invariants at all.. it mainly protects the internal implementation from mistakes
02:13:24 <haskellcurious> But for gui programming and web development
02:13:29 <haskellcurious> well let me put it this way.
02:13:50 <haskellcurious> for how horrible html is.. I appreciate the fact that I can see what I'm programming
02:13:55 <quicksilver> Peaker: sorry I wasn't talking about the redblack stuff, I was talking about the attribute contraints.
02:14:09 <haskellcurious> (Yes I just referred to programming html in a haskell IRC channel )
02:14:18 <Peaker> quicksilver, ah, ok
02:15:02 <haskellcurious> Well I'll keep digging
02:15:26 <haskellcurious> thanks for the chat goodnightz!
02:28:31 <ketil> Repa - or other data parallel array: can I easily, and in parallel build an array [0..n+1] from a (read only) array [0..n]?
02:29:06 <ketil> I have in mind an application that needs to iterate a "growing" vector, so to speak.
02:32:17 <adlsaks> ketil:  Helpful? http://blog.wuwon.id.au/2011/01/persistent-vectors-and-hash-maps-for.html
02:32:40 <ketil> Thanks, will take a look.  It's only an idea at this point...
02:32:45 * hackagebot BNFC-meta 0.1.0.3 - Deriving Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.1.0.3 (JonasDuregard)
02:46:05 <asdfa> @pl \a b -> 2*(a + b)
02:46:05 <lambdabot> ((2 *) .) . (+)
03:19:52 <co_dh> > (2*) . (+) 1 2
03:19:52 <lambdabot>   No instance for (GHC.Num.Num (f t))
03:19:53 <lambdabot>    arising from a use of `e_1212' at <i...
03:21:17 <co_dh> > (2*) . (+)  $ 1 2
03:21:18 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
03:21:18 <lambdabot>    arising from a use of `...
03:21:34 <co_dh> > (+) 1 2
03:21:35 <lambdabot>   3
03:23:15 <co_dh> (2*). (uncurry (+)) $ (1,2)
03:33:10 <frerich> IS hlint generally considered to be a useful tool? I like running such code checkers on my programs but I'd rather not do so if it's known that a large portion of the suggested changes are actually silly.
03:34:21 <ezyang> hlint is pretty reasonable. 
03:35:43 <ManateeLazyCat> Good evening, all ! ;)
03:42:24 <apfelmus> Hello. :)
03:42:54 <apfelmus> Any git wizards available that might want to answer a newbie question?
03:43:11 <ezyang> sure. Also try #git 
03:43:14 <apfelmus> I have the following situation:
03:43:44 <apfelmus> I'm working on an example for my library,
03:43:54 <apfelmus> only to discover that my library might have a bug.
03:44:16 <ezyang> Ah, are you asking about bisection? 
03:44:24 <apfelmus> To check whether this is the case, I would like to temporarily fetch a previous version of my library.
03:44:32 <apfelmus> What is bisection?
03:44:50 <ezyang> It's a method of debugging, where you binary search the history, looking for the first commit that introduces the bug. 
03:45:03 <ezyang> but you're asking for something simpler. 
03:45:34 <ezyang> You can either: (1) do another clone (Git will hard link, so it will be quick) and then checkout the old version, or (2) stash your current changes, and then checkout the old version. 
03:46:10 <apfelmus> Ok, but wouldn't that delete the example I'm currently working on?
03:46:18 <ezyang> If you stash, it won't. 
03:46:38 <ezyang> if it's an unversioned file, Git won't touch it. 
03:46:56 <ezyang> If you have a bunch of changes you'd like to transfer over to the earlier version, that's trickier but can be done. 
03:47:18 <apfelmus> Ah. Fortunately, my file is not versioned yet.
03:47:33 <apfelmus> But it will be soon, so I can as well ask about the tricky procedure.
03:47:57 <apfelmus> So, how exactly would I transfer changes back in time?
03:48:21 <apfelmus> Or rather, I want to replace on file from the past temporarily to the future.
03:48:22 <ezyang> Make a dummy commit with all your changes, note the hash. Checkout the old version, and then cherry-pick that commit. 
03:48:51 <ezyang> You might want to create a branch for the old version (to be deleted later) if things get hairy. 
03:48:59 <ezyang> Obviously you'll need to resolve conflicts. 
03:49:20 <apfelmus> How do I create a branch? Is that like darcs tagging?
03:49:54 <ezyang> Nope, much simpler. git branch BRANCHNAME 
03:50:01 <ezyang> or, in your case, git checkout -b BRANCHNAME OLDREV 
03:50:08 <hvr> ezyang: ...is my http://stackoverflow.com/questions/5484847 question sensible at all? :-)
03:50:22 <ezyang> It totally is sensible. 
03:50:32 <ManateeLazyCat> Google's guru robot is stupid bot.
03:50:35 <ManateeLazyCat> Not funny.
03:51:22 <apfelmus> The effect of creating a branch would be that an old commit gets a new name?
03:51:31 <ezyang> Yes. 
03:51:40 <ezyang> or in the case of 'git branch', the current HEAD 
03:51:50 <hvr> ezyang: I've faced this problem in other languages as well; there I basically had a map with 3 states, cache-miss, cache-hit, cache-hit-inprogress
03:52:08 <hvr> for a given entry
03:52:23 <hvr> (cache-misses would not have been explicitly stored in the map of course)
03:52:26 <ezyang> If you use appropriate synchronization, it's not a problem. 
03:52:43 <ezyang> GHC's blackholing solution is quite elegant, in that regard. 
03:52:51 <apfelmus> ezyang: Does it make sense to create branches for old version of my library just for the sake of it?
03:52:53 <ezyang> Laziness is a /synchronization/ mechanism. Which I think is pretty cool. 
03:53:05 <ezyang> apfelmus: I don't really see the point, unless you're actually using them 
03:53:11 <ezyang> like you have a version-1 line and a version-2 line. 
03:53:16 <ezyang> "make them lazily" 
03:53:17 <hvr> ezyang: but it's not really guaranteed to be blackholed, is it?
03:53:35 <ezyang> Well, it won't get blackholed in the single-threaded case, because there's no synchronization necessary. 
03:53:50 <apfelmus> ezyang: Ok. Thanks!
03:54:07 <ezyang> and GHC is plenty allowed to call the IO action more than once, or speculatively, etc. 
03:54:28 <ezyang> So that's the price you pay. 
03:54:31 <hvr> ezyang: I just feel that, by using unsafePerformIO, I can't be sure that a given IO won't be called more than once
03:54:40 <ezyang> Correct. 
03:55:01 <ezyang> but didn't you say that the operation had no side effects? :-) 
03:55:14 <ezyang> And in normal cases, if you memoize it will not duplicate work. 
03:55:27 <hvr> ezyang: yes, but also that I wanted to coalesce multiple same-argument requests into one
03:55:49 <hvr> (I just didn't stress it enough, that it was really important to me :)
03:56:18 <hvr> the IO operations are side-effect free, but they are very expensive
03:56:19 <ezyang> hvr: I don't think GHC gives this guarantee per se, but I'm pretty sure that this is what happens. 
03:56:34 <ezyang> late threads hit the blackholed thunk and block on the first thread to finish. 
03:56:42 <ezyang> (be careful about inlining and such) 
03:57:48 <ezyang> I'm not going to guarantee it, because we don't give the guarantee. 
03:57:52 <hvr> hehe
03:58:06 <hvr> ok, let's say I doesn't trust the blackhole mechanism
03:58:12 <hvr> -es
03:58:21 <ezyang> You can reimplement it yourself, in that case :-) 
03:58:22 <hvr> which synchronization mechanism would I use?
03:58:31 <hvr> STM? MVars?
03:58:37 <ezyang> I think you might be able to get away with just MVars 
03:59:09 <ezyang> the only very slightly tricky bit is making sure each input gets its own mvar. 
03:59:14 <ezyang> which isn't too hard with a touch of laziness 
03:59:35 <ezyang> "a touch of plain bob minor" 
03:59:39 <hvr> or I could explicitly managa a Map or Hashmap?
03:59:58 <ezyang> Yes, but if you synchronize over the whole thing unrelated requests will get blocked. 
04:00:21 * hackagebot base-unicode-symbols 0.2.1.2 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.2.1.2 (RoelVanDijk)
04:01:42 <hvr> well my input could be something like a JSON parse-tree
04:01:59 <hvr> or a SOAP XML tree
04:02:25 <ezyang> Well, you'll need some efficient keying mechanism. 
04:03:02 <hvr> well, I can always serialize those to a text-stream
04:03:20 <hvr> then I have something that is Ord'able and Hashable
04:03:26 <ezyang> ...sure. 
04:03:46 <hvr> (I have to serialize them anyway sooner or later)
04:04:05 <ezyang> One thing to be afraid of is that the same input will serialize slightly differently. 
04:04:12 <ezyang> and so you won't end up getting any caching. 
04:04:21 <hvr> yes, I'm assuming normalized serialization
04:04:37 <ezyang> then serialization and hashing is probably easiest. 
04:04:39 <hvr> which for JSON at least is easy
04:05:39 <hvr> ok, and if I have hashing, can I trick lazyiness into helping me?
04:05:47 <hvr> or am I bound to hash-maps then?
04:06:14 <ezyang> hash maps are kind of tricky to default lazily 
04:06:36 <ezyang> because of buckets. 
04:06:56 <ezyang> well, because of mutation, generally speaking. 
04:07:11 <DRMacIver> It's not that hard to do good immutable hash maps.
04:07:32 <zol_> Haskell :D
04:07:46 <DRMacIver> e.g. the most trivial one to implement is HashMap k v = IntMap [(k, v)]. It's not *great*, but it works surprisingly well.
04:08:10 <ezyang> What's the flag to turn ghc into runghc? 
04:08:12 <DRMacIver> (lookup is: hash key, look it up in IntMap, look up key in assoiation list)
04:08:25 <ezyang> (the same way -interactive turns ghc into ghci) 
04:09:42 <DRMacIver> I'm not sure how the unordered-containers hash map works, but I got very good performance out of it (admittedly with a quite speialised key type)
04:09:52 <hvr> ezyang: cat runghc says
04:09:54 <hvr> exec "$executablename" -f "$bindir/ghc" ${1+"$@"}
04:10:27 <hvr> (with some env vars setup)
04:10:40 <hvr> nevermind
04:10:57 <DRMacIver> Ah, in fat, the unordered ontainers HashMap looks like it's exactly that with some specialisation.
04:11:33 <hvr> runghc seems to be an executable of its ownb
04:12:24 <ezyang> hmm 
04:12:32 <hvr> DRMacIver: I remember having seen the video presentation where the creator explained the evolution from IntMap [(k,v)] to its current form
04:12:36 <quicksilver> ezyang: http://darcs.brianweb.net/d.h.o/ghc/utils/runghc/runghc.hs
04:12:45 <quicksilver> runghc is not a simple command-line option.
04:12:47 <ezyang> I have a built checkout of GHC, and I want to use it to build (with Cabal) an unrelated package. How do I do this? 
04:12:56 <DRMacIver> hvr: Interesting. Do you remember the reasoning? 
04:13:10 <DRMacIver> hvr: Because I'm looking at the implementation and the underlying design is *really* similar. 
04:13:29 <hvr> DRMacIver: bascially unboxing iirc, but I'll find you the video
04:13:39 <kreed> Hello. I just install ghc-7.0.3 and trying to install Cabal-1.8.0.4. I have error "Setup: At least the following dependencies are missing:base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2". But I have filepath-1.2 and base-4.3.1. How I can resolve this problem?
04:15:06 <mauke> base >=4 && <3 ... right
04:15:17 <hvr> DRMacIver: http://blog.johantibell.com/2011/03/video-of-my-hashing-based-containers.html
04:16:05 <dcoutts_> ezyang: use --with-compiler= to specify the inplace ghc, and you may also need --with-hc-pkg to specify the corresponding ghc-pkg
04:16:08 <DRMacIver> hvr: thanks. 
04:16:17 <marcot> Is there a version of bracket_ that allows Monad Transformers instead of only IO?
04:16:20 <ezyang> ok. 
04:16:56 <DRMacIver> (FWIW, I wrote the equivalent implementation for the scala standard library, 'though I don't know if they've replaed it by now, and that basically was just an IntMap [(k, v)] 
04:16:59 <DRMacIver> )
04:18:43 <kreed> mauke, I try change dependies, but it didn't help
04:21:16 <hvr> DRMacIver: do you still use Scala? 
04:21:20 <DRMacIver> hvr: No
04:21:24 <DRMacIver> hvr: I gave up on it about a year ago.
04:21:28 <DRMacIver> Little longer now
04:21:29 <hvr> why?
04:22:02 <DRMacIver> About 40% frustrations with the JVM, 40% frutration with the tension between Scala-as-a-good-language and Sala-as-a-Java-substitute.
04:22:13 <DRMacIver> About 20% problems with the community I'd like not to get into :)
04:22:45 <hvr> does Scala actually suffer from trying to be a good Java-citizen?
04:22:51 <DRMacIver> Yes
04:22:54 <DRMacIver> Very definitely
04:23:08 <hvr> what's the most obvious place where you can notice it?
04:23:20 <DRMacIver> Equality testing.
04:23:23 <DRMacIver> It's totally untyped
04:23:37 <DRMacIver> It's not the biggest problem, but you see it everywhere
04:23:52 <hvr> and what would be the biggest problem then? :)
04:24:33 <DRMacIver> hvr: Sorry, I'm being summoned to a meeting. I'll answer that when I get back
04:24:41 <hvr> cu
04:28:23 <ezyang> There's no --vanilla flag for Cabal, which instructs the build to only do the basic version, no profiling/etc? 
04:28:58 <ezyang> Having to always specify --disable-library-profiling and --disable-shared is a pain... 
04:31:11 <benmachine> ezyang: .cabal/config?
04:31:26 <ezyang> Well, when I do ordinary installs I want profiling and shared setup. 
04:31:27 <hvr> benmachine: wouldn't that be global?
04:31:29 <ezyang> but not when I do dev. 
04:31:39 <benmachine> hm
04:32:49 <apfelmus> ezyang: Found the bug!
04:32:56 <dcoutts_> ezyang: each flavour (normal, profiling) can be selected independently
04:32:59 <apfelmus> ezyang: Or rather, found something even more amazing.
04:33:18 <ezyang> Hm? 
04:33:41 <dcoutts_> ezyang: so you mean, you want to have profiling by default, but you want another flag to override it and disable all other ways except for the normal way?
04:33:46 <ezyang> yeah 
04:33:48 <benmachine> dcoutts_: I had this vague idea that profiling/shared required vanilla to be built, or haddock required vanilla to be built, or something
04:34:09 <benmachine> was that wrong?
04:34:19 <ezyang> Because there's nothing more annoying than deciding to profile a library, and discovering that you need to recompile 40 packages with profiling. 
04:34:24 <apfelmus> ezyang: I thought my library had a bug, but it turns out that my example is semantically ill-defined, which the library promptly answers by going into an infinite loop.
04:34:37 <dcoutts_> benmachine: TH requires vanilla, I  think that's the only constraint
04:34:40 <ezyang> That's poor 8) 
04:35:04 <benmachine> dcoutts_: how does that work
04:35:10 <dcoutts_> ezyang: oh but that's a different problem, handling dependencies with ways properly
04:35:34 <ezyang> yeah it is, but the workaround is install everything with profiling and dyn 
04:36:33 <dcoutts_> benmachine: TH loads code, only compatible code can be loaded, ghc/ghci is built the normal way, hence requires normal way code to be available for deps when using TH
04:37:17 <dcoutts_> ezyang: and hence wanting sometimes to be able to turn that off, so another solution to your problem then would be for cabal-install to understand ways
04:37:26 <ezyang> Yep. 
04:37:38 <MasseR> Can I have class constraints with newtypes? Ie newtype DB (IConn c) => c a = DB (ReaderT c a)
04:37:52 <ezyang> MasseR: No, and you wouldn't really want it either. 
04:38:11 <benmachine> dcoutts_: eep. so do you get the vanilla version installed if there's any TH going on?
04:38:19 <benmachine> or does it just have to be built
04:38:25 <ezyang> (you can class constraint data declarations, but you still have to explicitly declare all the typeclasses at all use sites) 
04:38:40 <MasseR> ezyang: Ok
04:39:57 <benmachine> ezyang: I think you can have class constraints with newtypes (but you still don't want them)
04:40:08 <ezyang> Oh, ok :-) 
04:42:07 <DRMacIver> hvr: I'd say the biggest problem with Scala is the presence and overuse of nominal subtyping, and the omplete madness that is its interation with the implicit conversion system.
04:42:44 <DRMacIver> The way the implicit conversion system is used to bolt features onto Java libraries probably omes a close second.
04:43:17 <dcoutts_> benmachine: if TH is listed in the extensions in the .cabal file then cabal will build the vanilla version
04:44:21 <benmachine> mm, but not install it?
04:46:16 <dcoutts_> benmachine: um, not sure, I don't recall
04:47:31 <benmachine> k
04:47:47 <hvr> DRMacIver: ic
04:48:27 <hvr> DRMacIver: sounds like Scala is more like a intermediate evolutionary step
04:48:44 <hvr> that needs to leave Java behind at some point
04:48:47 <ezyang> I mean, that's what would make it successful, right? 
04:48:56 <ezyang> people can't deal with too much change at once. 
04:49:33 <mauke> "on the mutability of programming languages"
04:49:34 <DRMacIver> hvr: Maybe. I'm not sure Scala could ever leave Java behind. But it could definitely inspire a language that did.
04:49:36 <hvr> ezyang: well, yeah, it would be a huge success if Scala's ideas would infect enough people to make them ready for the next change :)
04:50:37 <DRMacIver> There are a lot of really good features in Scala. What I often think I'd really like was a language with about half of Scala's features but more of the ML heritage and not running on the JVM.
04:51:01 <qz> what's wrong with running on jvm?
04:52:18 <DRMacIver> qz: Lack of control over the compiler's optimisation, burdened by java.lang.String and java.io, burdened by the broken class file format, startup time issues, poor FFI, et.
04:53:21 <shapr> SHAZAM!
04:53:40 <shapr> also, last I checked the JVM is really bad at dealing with tail calls
04:53:44 <shapr> DRMacIver: Has that changed?
04:53:45 <qz> but its gonna take pretty long until fresh new compiler/runtime gonna match jvm quality (despite its mentioned problems)
04:54:06 <shapr> er, in what way?
04:54:14 <qz> also there's lots of code written for jvm =p
04:54:35 <mauke> emulator
04:54:36 <shapr> HotSpot VM optimizations come from David Unger's Self project...
04:55:11 <DRMacIver> shapr: Not as far as I know. There was a whole bunch of on-again off-again plans for Java 7.
04:55:20 <DRMacIver> qz: Don't buy it, sorry. 
04:55:42 <DRMacIver> qz: The JVM's optimisations are goodish if your language looks exactly like Java and is written exactly like Java.
04:55:51 <ezyang> lattices have a product construction, right? 
04:56:46 <DRMacIver> The garbage collection is a bit harder to match than hotspot itself. 
04:56:49 <qz> DRMacIver, well they work for scala also
04:57:11 <ezyang> FP languages have very different execution flow patterns. 
04:57:23 <ezyang> Pure FP and garbage, especially. 
04:57:37 <DRMacIver> qz: As long as you don't want to do things like use higher order functions, sure
04:58:10 <DRMacIver> qz: A big feature for the original design for the scala 2.8 colletion library was scuppered due the inability of hotspot to deal with FP
04:58:57 <qz> hopefully hotspot in java7 will be better at that
04:59:24 <DRMacIver> Yeah, and hopefully and $2 will buy you a cup of coffee. 
05:00:32 <DRMacIver> This is my point though: If you're developing a language for the JVM, what code the compiler optimises is completely at the whims of hotspot. It's outrageously harder to do it yourself if you want to in any way match the JVM's expectations.
05:00:37 <DRMacIver> cf. @specialized
05:02:22 <shapr> qz: the JVM is troublesome
05:02:51 <qz> DRMacIver, but what are options? build runtime from scratch like haskell? and so-many-years-after still have problems with GC?
05:04:52 <DRMacIver> qz: Good question. I'd be a much happier person if I knew what the answer was. :) 
05:05:10 <DRMacIver> qz: But I had far more frequent and regular problems with the JVM than I've ever had by not having a great GC off it.
05:05:43 <DRMacIver> frequent and significant even
05:06:07 <hpc> i haven't had any problems with GHC's runtime
05:07:15 <vegai> how do you define such a thing?
05:07:27 <vegai> I've had some blocking problems with parallel applications because I didn't build with -threaded
05:07:41 <vegai> I suppose that's sort of a "problem with GHC's runtime" even if it was mostly my fault
05:07:52 <DRMacIver> I can't really comment one way or another - I've not got enough production Haskell code to say whether I'd have problems with GHC's runtime. I'd be hard pressed to say I never had trouble with the JVM's runtime either.
05:08:33 <vegai> jvm runtime problems seem to usually fall into one of "gulps all memory on the server" and "uses all cores 100%"
05:08:43 <vegai> which also are kind of the coders' faults
05:08:45 <DRMacIver> Hell, I've had segfaults in production Java code with  no FFI. Selling the JVM as a perfectly robust solution is a bit um, questionable.
05:08:55 <vegai> indeed
05:09:13 <DRMacIver> (they were invariable hotspot bugs I think)
05:12:00 <DRMacIver> (And caused by Java, not by Scala doing something funky. Third party well tested widely deployed Java code for tat matter, which just hadn't happened to have been seen in a long running server process on our exact setup)
05:15:01 <DRMacIver> qz: FWIW, I'm not saying there are no valid use cases for the JVM. That would obviously be a silly claim. It's just that I use it as a last resort rather than a first.
05:16:41 <qz> DRMacIver, well personally biggest plus of using jvm is easy integration with existing java code
05:17:16 <DRMacIver> qz: I consider that the biggest minus. :)
05:17:35 <Athas> What is the most elegant way to define a function of type Monad m => (a -> m b) -> Map k a -> m (Map k b)?  That is, a function that is to Data.Map.map as mapM is to map.
05:17:40 <DRMacIver> Existing java code is largely shit. 
05:17:44 <DRMacIver> Anyway, we're way off topic here
05:18:19 <Athas> My immediate solution uses toList and fromList, but that is ugly.
05:19:34 <magicman> Data.Map.Map isn't an instance of Foldable or Traversable, is it?
05:19:37 <ezyang> Agh, worrying too much about asymptotics >.> 
05:19:57 <flippo> DRMacIver, existing code, you mean.  It's pretty language independent.
05:20:11 <Athas> magicman: actually it is.  Hooray!
05:20:28 <magicman> Oh, cool. Well, then you can use those :p
05:21:49 <DRMacIver> flippo: No, even against that baseline.
05:24:08 <ezyang> @pl (\x y -> x >>= \x' -> y >>= \y' -> if x' == y' then return x' else Nothing) 
05:24:08 <lambdabot> (. ((. flip (flip . ap (flip . (if' .) . (==)) return) Nothing) . (>>=))) . (>>=)
05:24:18 <ezyang> :-( 
05:25:43 <magicman> @type \x y -> x >>= \x' -> y >>= \y' -> if x' == y' then return x' else Nothing
05:25:44 <lambdabot> forall a. (Eq a) => Maybe a -> Maybe a -> Maybe a
05:27:05 <magicman> @pl (\x y -> if x == y then x else Nothing)
05:27:05 <lambdabot> flip flip Nothing . (flip =<< (if' .) . (==))
05:27:25 <levifikri> hi, can I link Haskell code to .obj C library using FFI?
05:27:54 <levifikri> I got the following error:This may be due to you not asking GHCi to load extra object files,
05:27:54 <levifikri> archives or DLLs needed by your current session.  Restart GHCi, specifying
05:27:54 <levifikri> the missing library using the -L/path/to/object/dir and -lmissinglibname
05:27:54 <levifikri> flags, or simply by naming the relevant files on the GHCi command line.
05:27:54 <levifikri> Alternatively, this link failure might indicate a bug in GHCi.
05:27:55 <levifikri> If you suspect the latter, please send a bug report to:
05:27:55 <levifikri>   glasgow-haskell-bugs@haskell.org
05:31:08 <DRMacIver> hvr: The contents of this talk don't seem to be true.
05:31:34 <hvr> DRMacIver: J.Tibell's talk?
05:31:37 <DRMacIver> Yeah
05:31:41 <DRMacIver> Unless he's talking about a different package
05:31:53 <DRMacIver> He's claiming the implementation is now based on the HAMT used in clojure, but I don't see any evidence of that in the code
05:32:50 <DRMacIver> There's a HAMT implementation on hackage, but it's by a different guy when I tried it it proved substantially slower than Data.Map
05:33:13 <ezyang> Tibell improved my implementation substantially. 
05:33:23 <ezyang> I dunno if it's beating Clojure's yet, but it is better than mine. 
05:33:45 <DRMacIver> Where is it? I don't see any evidence of that.
05:33:56 <quicksilver> it's called 'unordered-maps' or something like that
05:33:58 <copumpkin> it's on github
05:34:06 <hvr> https://github.com/tibbe/unordered-containers/
05:34:14 <quicksilver> unordered-containers
05:34:16 <quicksilver> I was close ;)
05:34:16 * hackagebot indents 0.3.1 - indentation sensitive parser-combinators for parsec  http://hackage.haskell.org/package/indents-0.3.1 (SamAnklesaria)
05:34:30 <quicksilver> it's on hackage also : http://hackage.haskell.org/package/unordered-containers
05:34:32 <DRMacIver> I'm looking there. The HashMap type isn't a HAMT. It's much closer to the original design.
05:34:51 <tibbe> DRMacIver: it was a HAMT (check the history) but the insert performance is much worse
05:34:59 <DRMacIver> Ah! Right.
05:34:59 <hvr> DRMacIver: tbh, I never looked at the actual source code :-)
05:35:01 <tibbe> DRMacIver: I'm working on making GHC have faster array copies
05:35:08 <tibbe> DRMacIver: and then switch to a HAMT
05:35:13 <DRMacIver> Ok. That answers my question. Thanks. :)
05:35:16 <tibbe> DRMacIver: it should still be faster than anything out there
05:35:16 <copumpkin> tibbe: any idea what's holding that up?
05:35:28 <tibbe> copumpkin: I guess the patches will be in 7.2?
05:35:31 <copumpkin> ah
05:35:39 <DRMacIver> tibbe: Yeah, I used it briefly and it blew the alternatives out of the water.
05:36:02 <tibbe> copumpkin: we still need to squeeze a bit more performance out of array copying. I was hoping Simon could help.
05:36:10 <tibbe> DRMacIver: :)
05:36:14 <copumpkin> tibbe: let me know if I can do anything
05:36:21 <DRMacIver> tibbe: But then I replaced it with something faster yet but more specialised to my use case
05:36:28 <tibbe> copumpkin: sure. I don't have a good idea how to make it faster right now
05:36:38 <tibbe> copumpkin: I think it needs to be an inline primop to start with
05:36:39 <DRMacIver> (Nothing you ould have done to beat that really: I realised I could turn the entire thing into a one-dimensional dense unpacked array)
05:36:39 <hvr> what's the ETA for ghc 7.2 btw?
05:36:47 <copumpkin> I have a couple, but don't have too much time for it right now
05:36:51 <copumpkin> yeah
05:37:03 <tibbe> copumpkin: we basically need the same optimizations as C's memcpy
05:37:10 <tibbe> copumpkin: inlining, unrolling, etc
05:37:11 <copumpkin> yeah
05:37:20 <tibbe> copumpkin: there's also some potential GC improvements e.g. in-line allocation
05:37:55 <quicksilver> tibbe: one possiblity is to push a memcpy primop all the way through to the backend.
05:38:02 <copumpkin> tibbe: on another note, have you considered removing the need for withSocketsDo in network and putting its behavior into a static initializer for the whole library (with the wsasocket cleanup in the destructor)
05:38:05 <tibbe> quicksilver: yes
05:38:12 <quicksilver> tibbe: LLVM has a memcpy primop, and the NCG could presumably do somethign sensible too.
05:38:12 <tibbe> on both counts
05:38:27 <tibbe> copumpkin: it's already unnecesart
05:38:29 <tibbe> y
05:38:34 <copumpkin> tibbe: even for windows?
05:38:40 <tibbe> copumpkin: yes
05:38:43 <copumpkin> ah, good
05:38:49 <copumpkin> it's always made me feel dirty to need that
05:38:54 <tibbe> right
05:39:01 <tibbe> the solution isn't beautiful but it seems to work
05:39:13 <tibbe> quicksilver: right
05:39:27 <tibbe> quicksilver: GCC has built in support for memcpy
05:39:31 <tibbe> does a lot of fancy stuff
05:39:35 <quicksilver> yes.
05:39:41 <quicksilver> it's a GCC primop, effectively.
05:39:46 <quicksilver> it only pretends to be a function call.
05:40:12 <copumpkin> tibbe: have you given any more thought to my "other approach" that I suggested?
05:40:17 <copumpkin> the different closure type
05:40:33 <tibbe> copumpkin: remind me what that was :)
05:40:40 <tibbe> variable size tuple type?
05:41:31 <copumpkin> the closure type that doesn't get entered by the GC, so you allocate memory in O(1), then do something with it to initialize it, then call unsafeCommit or something that transforms the type to something the GC Will touch again
05:42:05 <copumpkin> current newArray behavior would be what I described, a loop to initialize it, then a freeze
05:42:11 <copumpkin> or commit, I should say
05:42:57 <copumpkin> it doesn't make the memcpy primop unnecessary, but would technically allow it to just be an ffi call
05:43:08 <copumpkin> and for us to dump a lot of the combined primops I wrote
05:43:39 <tibbe> hmm
05:43:42 <tibbe> interesting
05:45:28 <copumpkin> then the difficulty is keeping what you stick into it alive between the allocation and the "commit"
05:45:35 <copumpkin> since it'll have no GC references to it
05:45:45 <copumpkin> but it may be feasible, I dunno
05:46:36 <copumpkin> unsafeAsAllHellWithNoGC :: IO a -> IO a
05:50:17 <tibbe> :)
05:51:17 <illissius> marcot: http://hackage.haskell.org/package/monad-control
05:52:15 <hpc> copumpkin: unsafeAsAllHellWithNoGC = id :D
05:59:15 <maaruks> hey  people
05:59:33 <maaruks> is this haskell ?
05:59:50 <marcot> illissius: Cool, thanks.  Exactly what I was looking for.  And it uses greek letters. =)
06:00:43 <maaruks> where can I get haskell mode for emacs ?
06:00:59 <dmwit> maaruks: THIS. IS. SPAAAAAARTAAAAAAAA!
06:01:20 <dmwit> maaruks: As for the real question, Google is probably your friend.
06:02:07 <maaruks> http://projects.haskell.org/haskellmode-emacs/  is empty
06:02:38 <maaruks> someone has deleted emacs mode   :-(
06:02:41 <tibbe> maaruks: http://code.haskell.org/haskellmode-emacs
06:03:00 <tibbe> maaruks: you can use darcs get on that url
06:03:11 <tibbe> no tarball though
06:03:25 <copumpkin> tibbe: oh, that's really obvious :P
06:03:53 <copumpkin> oh, you mean the code.haskell.org URL :)
06:04:07 <copumpkin> I thought you meant that the URL he linked to had a secret _darcs in it that was invisible in the listing
06:04:24 <tibbe> copumpkin: heh, no
06:06:19 <Blazemore> Hello everyone I have something that's been bugging me for over half an hour now
06:06:30 <Blazemore> It should be simple but I can't get my head round it so I'm hoping you can help me
06:06:50 <Blazemore> I have a type [(a,b)]
06:06:52 <maaruks> nice,  thank you
06:07:40 <Blazemore> And I want to remove duplicates like this: [(A, 0), (B, 1), (C, 10), (A, 2)] That has duplicates in it
06:08:08 <Blazemore> I need that to turn into [ (B, 1), (C, 10), (A, 2)]
06:08:24 <Blazemore> So all but the latest dictionary entry are removed
06:08:39 <dmwit> Cool, what have you tried?
06:08:47 <Blazemore> If you consider it of the form (key, value) then I want to remove duplicate keys, and keep the last one only
06:08:53 <dmwit> yep
06:08:56 <Blazemore> I was messing around with list comprehensions and guards
06:09:19 <dmwit> Oh, that sounds like a disaster waiting to happen.
06:09:34 <dmwit> If you want to write it yourself, I recommend explicit recursion.
06:09:41 <dmwit> If you want a standard library function for it, try
06:09:42 <dmwit> :t nubBy
06:09:43 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
06:10:05 <Blazemore> OK give me a sec with Hoogle
06:13:50 <Blazemore> I'm not sure how to use that in this context
06:14:05 <Blazemore> > removedup (k,v):ms	= nubBy()
06:14:05 <lambdabot>   <no location info>: parse error on input `='
06:14:11 <Blazemore> shish, you
06:14:25 <Blazemore> But I'm not sure what to put in there
06:14:32 <scree_> Blazemore: is the order of the eventual list that important to you?
06:14:56 <Blazemore> Absolutely not
06:15:49 <dmwit> Blazemore: If you're going to use nubBy, you probably don't need to pattern match or do recursion.
06:16:00 <dmwit> Blazemore: Have you read the docs for nubBy yet?
06:16:19 <dmwit> (and nub, obviously?)
06:16:29 <scree_> in that case maybe "map last . groupBy ((==) `on` fst) . stableSortBy (comparing fst)" is what you want
06:16:48 <scree_> I'm not sure about the behaviour of nubBy wrt first / last occurences
06:16:49 <dmwit> ick
06:16:55 <dmwit> That looks much more annoying.
06:16:58 <Blazemore> nub isn't what i need because it only works if the value is the same as well
06:17:04 <dmwit> I doubt he's worrying about performance yet.
06:17:12 <Blazemore> Performance can wait
06:17:12 <dmwit> Blazemore: Right, that's why you want nubBy.
06:17:34 <dmwit> Blazemore: But understanding nubBy is easier if you understand nub first. That's why I asked. =)
06:17:52 <Blazemore> So what lambda expression do I build for the first argument, or would it be clearer to write another helper function
06:18:06 <dmwit> Blazemore: The general pattern is something like this:
06:18:31 <brbr> does anyone know where i can get haskell-mode?  The link on the wiki page leads to an empty directory http://projects.haskell.org/haskellmode-emacs/
06:18:33 <dmwit> nubBy (\elem1 elem2 -> some operation that tells whether elem2 should be omitted because it is "equal" to elem1)
06:18:48 <dmwit> Blazemore: In your case, since both elements will be pairs, you might expand this pattern slightly to
06:18:58 <Blazemore> OK
06:19:07 <dmwit> nubBy (\(k1, v1) (k2, v2) -> some operation comparing k1, k2, v1, v2)
06:19:49 <dmwit> brbr: Scroll up a bit, maaruks was asking the same thing just minutes ago and got an answer while you were here. =)
06:19:49 <Blazemore> Only need to compare keys
06:19:54 <dmwit> Blazemore: Right!
06:19:58 <dmwit> Blazemore: So how would that look?
06:20:13 <Blazemore> Just a sec
06:20:34 <frerich> dmwit: thumbs up for actually growing insight instead of force-feeding information
06:20:51 <confound> dmwit: brbr wasn't here when maaruks got answered as far as I can see
06:20:58 <dmwit> Oh, huh.
06:20:59 <brbr> dmwit: I don't see it... the first message i see is: 09:22 scree_: I'm not sure about the behaviour...
06:21:00 <Blazemore> It's pretty clear I'm a student and this is coursework, so it would be bad for him to say "Yeah this is how you do it"
06:21:11 <dmwit> brbr: Anyway, the answer is "darcs get" it. =)
06:21:19 <Blazemore> FYI this isn't the whole coursework obviously, it's an auxillery function that my particular method requires
06:21:24 <dmwit> Sure.
06:23:10 <maaruks> http://code.haskell.org/haskellmode-emacs/
06:24:03 <Blazemore> > cleanup (k,v):ms	= nubBy(\(k1, v1) (k2, v2) -> k1 == v1) ms
06:24:04 <lambdabot>   <no location info>: parse error on input `='
06:24:17 <Blazemore> Parse error on input
06:24:39 <dmwit> Hm, you're comparing a key to a value?
06:24:42 <dmwit> That doesn't look right.
06:24:44 <Blazemore> lol that's why
06:24:47 <Blazemore> typo
06:24:52 <dmwit> That won't give a parse error.
06:24:58 <scree_> Blazemore: I see weird symbols in that; probably explains your parse error
06:25:02 <dmwit> Probably it's that odd control-character you've got just before the equals sign.
06:25:03 <mauke> the parse error is cleanup (k, v)
06:25:08 <mauke> the weird symbol is a tab
06:25:17 <dmwit> Oh, so it is.
06:25:17 <Blazemore> Brackets
06:25:19 <Blazemore> Tabs are fine
06:25:21 <scree_> oh, sure
06:26:01 <brbr> dmwit: darcs?  Is there a git mirror that has haskell-mode?
06:26:45 <scree_> Blazemore: so, you should note "In particular, it keeps only the first occurrence of each element" from the docs
06:26:51 <Blazemore> Ok, modules loaded: Main.
06:26:57 <Blazemore> FIRST occurence
06:27:01 <Blazemore> OK I'll reverse the list
06:27:07 <Blazemore> I see what you mean about performance
06:27:21 <Blazemore> I've got to go through and strip out my ++s anyway
06:27:30 <Blazemore> Let me test this
06:28:02 <Blazemore> Don't need to reverse, it worked
06:28:12 <Blazemore> *Main> cleanup [('A', 0), ('B', 1), ('C', 10), ('A', 2)] 
06:28:12 <Blazemore> [('B',1),('C',10),('A',2)]
06:28:26 <dmwit> Blazemore: Be careful.
06:28:37 <dmwit> Blazemore: Guessing from what you pasted above, the fact that it worked was coincidental.
06:28:44 <dmwit> Blazemore: Take a look at what cleanup says:
06:28:53 <dmwit> cleanup ((k,v):ms) = nubBy (...) ms
06:29:14 <dmwit> This says: "Match against the input list. Strip off the first element, then do something to the tail."
06:29:20 <Blazemore> Is it ignoring the initial keypair?
06:29:26 <Blazemore> I should not use recursion?
06:29:28 <dmwit> yep =)
06:29:33 <Blazemore> I should use map or somesuch?
06:29:37 <dmwit> You should not use recursion. nubBy is doing the recursion for you.
06:29:42 <dmwit> No need to map.
06:29:48 <Blazemore> I swear I could have done this with filter
06:29:54 <dmwit> No need for filter, either.
06:30:04 <dmwit> You're there, just stop ignoring the first element. =)
06:30:10 <Blazemore> Oh OK
06:30:46 <Blazemore> It's quite neat really
06:30:54 <scree_> Blazemore: FYI this is one example of why compiler warnings are your friends
06:30:58 <Blazemore> I wonder if anyone else used nubBy if they came across this problem
06:31:11 <dmwit> Blazemore: So, don't tease us! Show us what you ended up with.
06:31:20 <Blazemore> > cleanup		:: Mem -> Mem
06:31:20 <lambdabot>   Not in scope: type constructor or class `Mem'Not in scope: type constructor...
06:31:28 <scree_> Blazemore: they would tell you that you were ignoring (k, v) in the function above
06:31:29 <Blazemore> > cleanup ms	= List.nubBy(\(k1, v1) (k2, v2) -> k1 == k2) ms
06:31:30 <lambdabot>   <no location info>: parse error on input `='
06:31:38 <dmwit> Nice. =)
06:31:47 <Blazemore> I think I can use _ for the values
06:31:59 <dmwit> Yes, you can.
06:32:07 <Blazemore> Bonus styles marks ^^
06:32:10 <dmwit> If you want to get fancier, there are ways to do that, too.
06:32:15 <Blazemore> You know Graham Hutton?
06:32:20 <dmwit> For example:
06:32:20 <dmwit> :t on
06:32:21 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
06:32:28 <dmwit> :t on (==)
06:32:29 <copumpkin> some languages let you even put _ on the right-hand side of an equals sign / ->
06:32:29 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
06:32:33 <frerich> That function keeps the ('A',2) tuple but drops the earlier ('A',0)? Odd.
06:32:52 <dmwit> frerich: Scroll up for the real source.
06:33:02 <dmwit> frerich: He was only nubbing the tail of the list. =)
06:33:27 <Blazemore> Here: > cleanup ms	= List.nubBy(\(k1, _) (k2, _) -> k1 == k2) ms
06:33:32 <frerich> dmwit: Yes, but even with this final version, doesn't he have to reverse the list?
06:33:43 <Blazemore> Apparently not
06:33:47 <dmwit> frerich: Probably. I suspect that eventually he will start building up the list in the other order, though.
06:33:50 <Blazemore> Ni
06:33:52 <Blazemore> *no
06:33:55 <Blazemore> (sorry)
06:34:04 <Blazemore> because it will match and remove a duplicate if one exists
06:34:15 <dmwit> Blazemore: Well, the function you've written keeps the first occurrence of each key, whereas your specification asked to keep the last occurrence of each key.
06:34:15 <Blazemore> Then do the rest, and for the last one there will be no duplicates
06:34:21 <Blazemore> I think that's how it works
06:34:37 <Blazemore> Oh
06:34:40 <Blazemore> I do need to reverse
06:34:49 <scree_> > let cleanup ms = List.nubBy (\(k1, _) (k2, _) -> k1 == k2) ms in cleanup [('A', 0), ('B', 1), ('A', 2)]
06:34:50 <lambdabot>   Not in scope: `List.nubBy'
06:34:59 <scree_> > let cleanup ms = Data.List.nubBy (\(k1, _) (k2, _) -> k1 == k2) ms in cleanup [('A', 0), ('B', 1), ('A', 2)]
06:35:00 <lambdabot>   [('A',0),('B',1)]
06:35:04 <dmwit> Blazemore: But I suspect that when building the list, you're appending key/value pairs. It will be easier on you if you prepend them (and faster).
06:35:17 <Blazemore> Alright then
06:35:19 <Blazemore> Thanks
06:35:37 <Blazemore> FYI it's a virtual machine for executing the instructions of a small imperitive programming language
06:35:48 <dmwit> That way you won't need to reverse, and the standard functions will have more intuitive meanings for non-nubbed lists.
06:35:53 <Blazemore> If you're interested, the specification is here http://www.cs.nott.ac.uk/~gmh/afpcwk2.pdf
06:36:38 <frerich> Ouch, deadline imminent? :)
06:36:48 <Blazemore> In a way yes
06:36:56 <Blazemore> But we have 24hr late submission
06:37:02 <Blazemore> And he actually doesn't dock the usual 10%
06:37:03 <frerich> heh
06:37:13 <Blazemore> I will submit what I have so he can see it
06:37:25 <Blazemore> Then later submit the final, cleaned up and commented copy
06:37:29 <Blazemore> with spaces instead of tabs
06:37:48 <Blazemore> Does Graham Hutton ever come on here?
06:38:17 <mauke> preflex: ? who:GrahamHutton
06:38:17 <preflex>  factoid not found
06:38:40 <Blazemore> preflex: ? who:gmh
06:38:41 <preflex>  factoid not found
06:38:53 <Blazemore> preflex: ? who:DizzieHaskell
06:38:53 <preflex>  factoid not found
06:38:55 <mauke> yeah, I don't think I've ever added him
06:39:03 <Blazemore> If that isn't his online handle he missed a trick
06:39:19 <saml> hey, where is source code for AST for haskell?
07:03:04 <frerich> Hm, are there some examples where one can see when 'flip' is useful? It's one of these functions with is so primitive that you wonder why you would need it.
07:03:24 <frerich> I suspect it can be useful to bind the *second* argument of some function when currying
07:03:25 <Saizan> saml: see the haskell-src-exts package
07:03:28 * hackagebot unbounded-delays 0.1.0.1 - Unbounded thread delays and timeouts  http://hackage.haskell.org/package/unbounded-delays-0.1.0.1 (BasVanDijk)
07:03:41 <Axman6> > filter (flip elem [1..10]) [-10..1000]
07:03:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:03:44 <dmwit> frerich: Exactly. For example, I see "flip zip" from time to time.
07:03:49 <Axman6> not a particularly good example
07:03:57 <Blazemore> OK I'd better go, thanks for your help, especially dmwit
07:04:05 <dmwit> Good luck!
07:04:05 <dolio> > foldl (flip (:)) [] [1..10]
07:04:07 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
07:04:11 <Blazemore> Done it now!
07:05:03 <Botje> Bleadof: nice!
07:07:57 <frerich> dmwit: Hm, flip zip not only sounds neat, it's also pretty concise. A short way for zipWith (\x y -> (y,x))
07:08:40 <frerich> Hm, and that lambda is 'flip (,)'
07:09:49 <frerich> I get some odd joy out of writing tiny little functions which do something interesting with lists (usually lists of tuples)
07:10:00 <frerich> It's the Lego gene in me.
07:38:35 <ManateeLazyCat> @tell juhp I just push new patches, in new version of Manatee, *every* keymap will show in helper tooltip (when you press C-/ or C-?)
07:38:35 <lambdabot> Consider it noted.
07:39:07 <ManateeLazyCat> @tell juhp Now keymap problem fix, move to next problem.... :)
07:39:07 <lambdabot> Consider it noted.
07:42:48 <aaa> @pl let f n = if (x==0) then 0 else (f (n-1))+1
07:42:48 <lambdabot> (line 1, column 44):
07:42:48 <lambdabot> unexpected end of input
07:42:48 <lambdabot> expecting digit, variable, "(", operator, "+", "-", ";" or "in"
07:43:00 <augur> is undefined equal to undefined??
07:43:18 <DRMacIver> augur: undefined == undefined is undefined.
07:43:27 <augur> ahaaa lol ok
07:43:36 <aaa> @pl let f n = if (x==0) then 0 else ((f (n-1))+1)
07:43:36 <lambdabot> (line 1, column 46):
07:43:36 <lambdabot> unexpected end of input
07:43:36 <lambdabot> expecting variable, "(", operator, ";" or "in"
07:43:56 <Axman6> aaa: do you mean x==0 or n==0?
07:44:08 <aaa> @pl let f n = if (n==0) then 0 else (n*(f (n-1))+1)
07:44:08 <lambdabot> (line 1, column 48):
07:44:08 <lambdabot> unexpected end of input
07:44:08 <lambdabot> expecting variable, "(", operator, ";" or "in"
07:44:15 <byorgey> aaa: also, you need an 'in' after a 'let'
07:44:19 <byorgey> let .... in ...
07:44:33 <Saizan> @pl let f x = x
07:44:33 <lambdabot> (line 1, column 12):
07:44:33 <lambdabot> unexpected end of input
07:44:33 <lambdabot> expecting letter or digit, variable, "(", operator, ";" or "in"
07:44:33 <Axman6> or get rid of the let
07:44:43 <aaa> @pl f n = if (n==0) then 0 else (n*(f (n-1))+1)
07:44:43 <lambdabot> f = fix (ap (flip if' 0 . (0 ==)) . flip flip 1 . ((+) .) . ap (*) . (. subtract 1))
07:44:59 <Egbert9e9> guys, if i want to: a. get keybinding from anywhere on X. b. get clipboard content (the kind of highlight but now C-c kind), what libs should i be using?
07:45:00 <Axman6> @pl f n = if n == 0 then 0 else f (n-1) + 1
07:45:00 <lambdabot> f = fix (ap (flip if' 0 . (0 ==)) . flip flip 1 . ((+) .) . (. subtract 1))
07:45:25 <nihtml> @help djinn
07:45:25 <lambdabot> djinn <type>.
07:45:25 <lambdabot> Generates Haskell code from a type.
07:45:25 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
07:45:47 <dmwit> Egbert9e9: X11, I guess
07:46:09 <dmwit> ?hackage X11
07:46:09 <lambdabot> http://hackage.haskell.org/package/X11
07:47:27 <Egbert9e9> ah
07:52:34 * hackagebot seclib 0.1 - A lightweight library for Information-flow security in Haskell  http://hackage.haskell.org/package/seclib-0.1 (AlejandroRusso)
07:53:01 <Entroacceptor> information flow securityp
07:53:03 <Entroacceptor> ?
07:54:28 <dmwit> Entroacceptor: The wikipedia page on information flow is pretty good.
07:54:42 <dmwit> http://en.wikipedia.org/wiki/Information_flow_(information_theory)
07:54:51 <dmwit> Entroacceptor: ...that is, if you were just asking for some background.
07:55:05 <Entroacceptor> well, yeah
07:55:20 <Entroacceptor> I don't think I've heard that phrase before
07:55:31 <Entroacceptor> except in advertisment
07:58:38 <Entroacceptor> afk
08:01:34 * hackagebot seclib 0.2 - A lightweight library for Information-flow security in Haskell  http://hackage.haskell.org/package/seclib-0.2 (AlejandroRusso)
08:02:30 <thtg> ho
08:02:31 <thtg> hi
08:02:35 <thtg> can anyone help me?
08:03:03 <sipa> depends on what kind of problem you have
08:03:14 <thtg> ggT :: Int -> Int -> Int ggT a b  	| a>b		= ggT (a-b) b 	| b>a		= ggT a (b-a) 	| otherwise	= b   kgV :: Int -> Int -> Int kgV a b = (a * b) / (ggT a b)
08:03:16 <thtg> arg
08:03:26 <thtg> umm whats wrong with the kgV function?
08:03:28 <Saizan> hpaste.org
08:03:53 <Saizan> thtg: you can't use (/) on Int
08:04:03 <thtg> ah
08:04:04 <thtg> ok :)
08:04:08 <thtg> thank you
08:04:15 <Saizan> thtg: there's div if you want integer division
08:05:28 <thtg> kgV a b = (a * b) div (ggT a b)?
08:05:55 <jix> thtg: div is just a function so you'd have to write div (a * b) (ggT a b)
08:06:11 <jix> thtg: but you can write (a * b) `div` (ggT a b)
08:06:16 <jix> but that works with any function... not just div
08:06:24 <jix> so you could also write a `ggT` b instead of ggT a b
08:07:00 <thtg> ah alright, i guess its called infixschreibweise in german... thank you :)
08:08:11 <mauke> infix notation
08:08:18 <mauke> and that's almost german
08:08:26 <jix> yeah it's a direct translation
08:10:05 <frerich> thtg: Just to make sure you're aware of it, your 'ggT' function apparently does the same as the standard 'gcd' function in the Haskell prelude.
08:10:45 <frerich> thtg: Similarly, your 'kgV' looks like the standard 'lcm'
08:10:45 <jix> ggT is the german gcd and kgV would be lcm
08:11:27 <thtg> ok, good to know
08:11:56 <jix> größter gemeinsamer Teiler <=> greatest common divisor
08:13:12 <jix> @src lcm
08:13:12 <lambdabot> lcm _ 0     =  0
08:13:12 <lambdabot> lcm 0 _     =  0
08:13:12 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
08:13:59 * jix was wondering whether the prelude lcm would divide first
08:14:15 <mauke> @src gcd
08:14:15 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
08:14:15 <lambdabot> gcd x y = gcd' (abs x) (abs y)
08:14:15 <lambdabot>    where gcd' a 0  =  a
08:14:15 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
08:17:02 <frerich> I would be nice if you could just say 'gcd 0 0 = undefined' instead of writing it out. If the diagnostics would be a bit better, ghc could emit the same message which is given to 'error'.
08:19:04 <jix> is it possible to do something like this with tempalte haskell? like $(betterUndefined) or similar?
08:19:31 <jix> because having such a thing done automatically would also be usefull for debugging trace functions
08:21:34 <djahandarie> @src god
08:21:34 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:23:16 <acowley> Hrm, is there anything I can do about this: Warning: -fllvm is incompatible with -fPIC and -dynamic on this platform; ignoring -fllvm 
08:23:38 <Axman6> acowley: i think that's fixed in 7.0.3
08:24:13 <acowley> $ ghc --version
08:24:13 <acowley> The Glorious Glasgow Haskell Compilation System, version 7.0.3
08:25:48 <Axman6> huh, lame
08:26:43 <acowley> I don't actually understand where the -fPIC and -dynamic flags are coming from, so I'm not sure how to proceed
08:27:00 <benmachine> when are you getting that warning?
08:27:17 <acowley> I don't issue them, and they're not obviously in my /usr/bin/ghc script
08:27:29 <acowley> benmachine: $ ghc --version
08:27:29 <acowley> The Glorious Glasgow Haskell Compilation System, version 7.0.3
08:27:31 <acowley> oops
08:27:40 <acowley> benmachine: ghc -fllvm foo.hs
08:27:48 <benmachine> hm.
08:28:02 <benmachine> (which platform, btw?)
08:28:04 <poincare101> what is good beginner haskell tutorial? I am good at C, Python and Java.
08:28:21 <mauke> preflex: ? lyah
08:28:21 <preflex>  http://learnyouahaskell.com/
08:28:41 <Axman6> poincare101: the first lesson you need to learn is to forget everything you know about C, Python and Java. This can't be stressed enough
08:28:46 <acowley> benmachine: Mac OS X 10.6.6
08:28:53 <benmachine> acowley: ah right, ho hum
08:29:00 <gks> poincare101: http://learnyouahaskell.com/
08:29:08 <gks> i rather like the book so far
08:29:14 <acowley> Yes, LYAH is great
08:29:30 <poincare101> Axman6: well, that's, um, difficult. 
08:29:38 <poincare101> gks: I will start reading that.
08:29:50 <gks> I bought the ebook, but it is available free online
08:30:04 <gks> probably the best resource i've found for beginners so far
08:30:20 <Axman6> poincare101: Haskell is nothing like the imperative languages you know, knowing any of those language won't help you, and will make it harder for you to learn haskell
08:30:25 <acowley> poincare101: Don't forget it, but set it aside. You will likely need to come at Haskell afresh with as few preconceived notions as possible, but as time goes on you will be able to connect it to what you know of other languages.
08:30:40 <acowley> benmachine: Is it a hopeless situation?
08:31:50 <benmachine> acowley: honestly I have no idea
08:32:26 <acowley> Well, it's a disappointment. I had put off upgrading to 7 for a long time to get some work done, and was excited to try out the new toys.
08:33:57 <Axman6> poincare101: I don't want to scare you off, it's just helpful to know that things are very different. you will end up a better programmer for learning haskell though
08:34:21 <poincare101> Axman6: okay. I will try my best.
08:34:43 <Axman6> now go forth and read LYAH! :)
08:35:19 <benmachine> acowley: just as a complete guess, try using the -static flag?
08:35:40 <acowley> benmachine: I had tried that already :) It didn't make a difference
08:35:46 <acowley> benmachine: I also tried +fPIC!
08:35:54 <benmachine> -fno-PIC?
08:36:03 <benmachine> that might be gcc I'm thinking of though
08:36:03 <acowley> no change
08:36:15 <benmachine> ho hum
08:36:20 <benmachine> tried with verbose output?
08:37:16 <acowley> benmachine: This will take me a moment to parse...
08:39:22 <Axman6> acowley: talking to people in #ghc about it. 
08:39:39 <acowley> Well that was unilluminating for me
08:47:17 <acowley> compiling with -v5 is a good way to generate reading material
08:50:29 <byorgey> that is a lot of verbosity right there
08:54:46 * hackagebot wai-app-static 0.0.1.4 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-0.0.1.4 (MichaelSnoyman)
08:57:02 <Saizan> acowley: the gist seems to be that currently GHC supports llvm only for 32bit, becuase on 64bit it always uses -fPIC and it also thinks llvm is incompatible with that flag
08:59:04 <saml> Saizan, thank you
08:59:09 * mrcarrot is wondering why -threads is not activated when compiling stuff with -O2. a simple program i made run with double speed when used this option
09:01:28 <Saizan> the threaded runtime came later, so it's not the default :) also it can make sequential programs slower, due to locking overhead
09:02:35 <acowley> Saizan: oof, and here I sat and thought about the 64 vs 32 decision for a while. I chose.... poorly.
09:02:50 <acowley> I guess I'm off to yet another reinstall
09:05:13 <jmcarthur> Saizan: huh? i've been able to use 64 bit ghc with the llvm backend before. or does it just silently use a different backend on 64 bit when you use -fllvm?
09:05:40 <jmcarthur> granted this may have been ghc HEAD instead of a released ghc 7... i don't remember
09:06:17 <jmcarthur> oh maybe it's an os x thing
09:07:07 <mafs> Anyone have thoughts on compile issues on OS X? Ran `cabal install curl` and it's complaining about math.h; that can be fixed by referencing the OS X /Developer/SDKs/MacOSX10.6.sdk/usr/include with --extra-include-dirs, but then it complains about float.h and stdard.h: no such file or directory -- but they are in the same dir that is being included for math.h
09:07:51 <acowley> GHC and OS X seem to have a fairly tense relationship at the moment. Initial problems with 32/64 on Snow Leopard, the lack of Leopard binaries, the problems with Xcode 4. All unwelcome reminders of OS X's finickyness.
09:08:02 <jmcarthur> :\
09:09:43 <acowley> mafs: That sounds bad... is that in fact the Xcode 4 issue I was just mentioning?
09:10:12 <mafs> acowley: might be, yeah--just installed Xcode 4 last week or so
09:10:43 <acowley> mafs: search for it, people solved it my symlinking the 10.5.sdk from where Xcode 4 moves it
09:10:52 <acowley> mafs: I understand that 7.0.3 addresses it, too
09:10:59 <acowley> (GHC 7.0.3)
09:11:29 <mafs> acowley: aha, thanks. I had searched but kept finding up irrelevant results.
09:11:42 <mafs> Will go ahead and try 7.0.3, seems I'm running .0.2 too.
09:21:47 * mafs hugs acowley 
09:21:55 <mafs> thanks! worked perfectly (the 7.0.3 upgrade)
09:23:38 <acowley> Great!
09:25:13 <acowley> My download of 32-bit 7.0.3 is chugging along at 34KB/s for some reason, so I won't know if I get to play with the LLVM codegen for a while longer
09:45:40 <dolio> byorgey: Excellent library, incidentally. Dealing with names and binders is always what kills my motivation when I have the urge to write some sort of interpreter.
09:50:12 <DRMacIver> tibbe: Back in the day I looked at what would be involved with doing something similar to the Scala collection library in Haskell. The main problem seemed to be the classes get painfully large. I think the hierarchy is painful to express too. 
09:50:34 <DRMacIver> There are also some features which are basically impossible to emulate but may not be be worth emulating anyway
09:50:37 <DRMacIver> (Just got to that point in your talk)
09:51:01 <tibbe> DRMacIver: it is difficult to express with type classes
09:51:11 <tibbe> DRMacIver: type families might at least make it possible
09:51:14 <tibbe> (and not ugly)
09:51:22 <tibbe> it's a big design space
09:53:18 <DRMacIver> I wasn't actually at all convinced by the Scala design either, at least initially. Reportedly it works quite well in practice.
09:53:37 <saml> scala is the best language
09:53:41 <saml> ?
09:53:50 <DRMacIver> Mu
09:54:22 <mrcarrot> saml: what answer do you expect to get from a haskell channel, really
09:54:33 <DRMacIver> Possibly this one? :) http://therighttool.hammerprinciple.com/items/haskell/scala
09:55:43 <saml> so scala is better
09:55:55 <pumpkin> I wouldn't say that
09:55:58 <pumpkin> at all
09:56:02 <pumpkin> especially as far as language design
09:56:13 <DRMacIver> tibbe: Also related to this: Java's built in hash tables aren't actually outrageously fast. They're trivially easy to beat even in pure Java. 
09:56:26 <DRMacIver> (sorry, just commentary on the talk as I hear bits :) )
09:56:34 <tibbe> DRMacIver: I can believe that
09:56:48 <tibbe> DRMacIver: Java's hash function isn't great but cannot be changed to being in the spec
09:56:48 <DRMacIver> s/built in/standard/ even
09:56:52 <dolio> Scala is much better for interfacing with Java, if you're interested in that.
09:57:03 <DRMacIver> tibbe: Even without changing the hash function.
09:57:19 <DRMacIver> tibbe: 'though that may be because the default version isn't very resistant to bad hashing
09:57:34 <tibbe> DRMacIver: could be, I'm not quite sure
10:04:55 <rostayob> if I have something like "type Foo = Bar Whatever a", can I enforce some classes on a? it seems I can't
10:05:36 <acowley> Class constraints go on functions that use the type, or on constructors of GADTs
10:05:56 <rostayob> acowley: ok, thanks
10:06:36 <shachaf> rostayob: You can say type Foo = forall a. C a => Bar Whatever a, with RankNTypes.
10:06:55 <James> Hi
10:07:03 <saml> hi James 
10:07:17 <rostayob> shachaf: thanks
10:07:29 <saml> hi Guest79165 
10:10:16 <shachaf> rostayob: Of course, that'll be a rank-2 type.
10:10:38 <shachaf> Well, depending on the context that you use it in.
10:10:56 <rostayob> shachaf: ok, this is all really confusing
10:12:38 <dhun> hey I got a function it takes a string amoung other paramter, I defined it by patternmatiching for the sting in 100 cases, not I need to list of all  these 100 strings, any ideas?
10:13:08 <shachaf> rostayob: If you have f :: Foo -> Int, that'd be equivalent to f :: (forall a. C a => Bar Whatever a) -> Int, not to f :: forall a. C a => Bar Whatever a -> Int.
10:13:38 <shachaf> dhun: A hundred cases for a pattern-match?
10:13:43 <shachaf> You probably shouldn't do that.
10:13:46 <dhun> well acutually I don't need the string I just need to test wheather or not a string is in that list
10:14:10 <dhun> Well I think I will need to rewrite it anyway, the only question is how
10:14:30 <shachaf> Use a Data.Map or similar from Strings to whatever.
10:14:42 <dhun> yes this might to
10:16:07 <dhun> do
10:16:33 <rostayob> shachaf: ok, I don't think I really get the difference between the two versions
10:18:03 <dhun> well here is the pattern match, but it will probably make you laugh (search for templateprocessor) http://wb2pdf.svn.sourceforge.net/viewvc/wb2pdf/trunk/src2/LatexRenderer.hs?revision=506&view=markup
10:19:08 <dhun> can you have a where clause in a lambda expression?
10:19:14 <shachaf> Nope.
10:19:16 <shachaf> But you can use let.
10:19:41 <dhun> well this might do
10:19:44 <saml> i am not sure why pattern matching is useful
10:20:00 <saml> maybe it is. tht's why it's there
10:20:21 <shachaf> rostayob: Let's see. Do you see what the type of f i = (i 'c', i True) would be?
10:20:32 <shachaf> Let's say the function passed in is id.
10:20:47 <merijn> saml: What do you mean?
10:21:16 <saml> pattern matching is used for method dispatching
10:21:53 <merijn> saml: Pattern matching is just a nicer way of writing case statements. So there's 2 interpretations of your statement: 1) case statements are useless (which I assume is not what you mean) or 2) Why do we need a nicer/convenient way of writing case statements
10:22:12 <shachaf> merijn: case statements are still pattern-matching, surely?
10:22:13 <merijn> And the answer to 2 is, because it is nicer and more convenient :p
10:22:15 <saml> what?
10:22:38 <rostayob> shachaf: what would be f :: (a -> a) -> (a, a) or something like that?
10:22:40 <rostayob> ohhh right.
10:22:55 <saml> yes, pattern matching is used in case statement. and case is used widely in method dispatching
10:23:00 <saml> in haskell
10:23:07 <shachaf> rostayob: Well, what you'd *want* would be f :: (a -> a) -> (Char,Bool).
10:23:20 <shachaf> But of course that doesn't work.
10:23:40 <shachaf> > let f i = (i 'c', i True) in f id
10:23:41 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
10:23:41 <lambdabot>         against inferred type ...
10:23:42 <merijn> saml: How would you distinguish between cases without pattern matching (or something almost identical)?
10:24:06 <saml> merijn, how other OO languages do...
10:24:10 <shachaf> rostayob: Because the a can be either Bool or Char.
10:24:13 <frerich_> dhun: I'm a Haskell beginner myself, but I've been reading your latex renderer program with great interest (It's nice to see Haskell programs by other beginners because they aren't so dense :)
10:24:15 <saml> dataValue.method()
10:24:25 <saml> instead of method(dataValue)
10:24:35 <rostayob> shachaf: yeah but that function
10:24:37 <rostayob> would never work
10:24:42 <rostayob> ...right?
10:24:42 <merijn> saml: I have "Maybe a" how do I distinguish between Just a and Nothing without pattern matching?
10:24:50 <tibbe> what's the non-GADT version of:
10:24:50 <tibbe> data B where
10:24:51 <tibbe>     B :: NFData a => a -> B
10:24:57 <frerich_> dhun: I think you could simplify the nonZero function to 'hasKey k d && a /= 0 where (a, b) = getValueForKey2 k d'
10:25:07 <tibbe> data B = forall a. NFData a => B a ?
10:25:11 <acowley> data B = forall a. NFData a => B a
10:25:20 <acowley> aka "yes"
10:25:23 <saml> merijn, maybeValue.aMethod()
10:25:25 <shachaf> > let f :: (forall a. a -> a) -> (Char, Bool); f i = (i 'c', i True) in f id
10:25:26 <lambdabot>   ('c',True)
10:25:37 <merijn> saml: "dataValue.method()" assumes the datatype knows which methods it supports. And the whole niceness of type families is that you can add support later without changing the datatype
10:25:41 <saml> Just a  will have an implementation of aMethod.  Nothing will have an implementation of aMethod
10:25:50 <rostayob> shachaf: cool, I didn't know that.
10:25:52 <rostayob> thanks
10:26:06 <merijn> saml: So I need to reimplement Just a and Nothing everytime a new method needs to support Maybe a?
10:26:08 <saml> so we can solve expression problem  by leting users add .method freely
10:26:18 <saml> using typeclass 
10:26:19 <hpc> saml: that would just be putting the "methods" inside the data structure, then matching to get them out
10:26:33 <saml> yup
10:26:47 <saml> i'm arguing that that is "better"
10:26:51 <hpc> ah lol
10:26:55 <benmachine> saml: there are multiple equivalent ways to do things in programming, but you have to ask which is safer, which makes more sense, which offers you more information, etc.
10:27:00 <hpc> i thought you were arguing you didn't need pattern matches
10:27:01 <merijn> saml: Well, you have fun repeatedly implementing useless stuff, I'll be over her actually doing something :)
10:27:07 * hpc mixed conversations probably
10:27:19 <merijn> s/her/here
10:27:24 <dhun> frerich_ there are many points like that in the my code
10:27:33 <hpc> merijn: an unfortunate typo :P
10:27:44 <saml> what's proper way to solve this?
10:27:44 <merijn> hpc: I'm all over her as well :>
10:28:01 <saml> f (Just a) = ..   f Nothing = ...
10:28:05 <teki> question: i know how Ord is defined over tuples, but if I had to look that up in the source where would I go?  :info (,) gives that the Ord inheritance is in Data.Tuple, but looking at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Tuple.html doesn't contain an instance of Ord
10:28:09 <hpc> saml: in any event, i am fairly sure most OO languages desugar to the haskell way, when you compile them
10:28:15 <dhun> currently I am busy implementing features, the level of the coded is increasing, but the old code is currently not modified
10:28:25 <hpc> foo.bar(quux) => bar(foo,quux)
10:28:28 <saml> yah probably hpc .. but i don't know
10:28:30 <merijn> hpc: Most OO languages I know anyway
10:28:42 <merijn> hpc: Unless they do dynamic lookup like python/ruby
10:28:53 <benmachine> teki: it might be "magic"
10:29:05 <merijn> Anyhoo, sports time so no time to argue this topic any further :p
10:29:09 <hpc> i thought python was the most obviously like that of OO languages
10:29:10 <benmachine> teki: (this is not usual but tuples are a bit strange because they can be of arbitrary length)
10:29:19 <saml> let's say i want to extend Maybe  with NotSure
10:29:21 <hpc> seeing as how you define methods as foo(__self__, args)
10:30:22 <merijn> hpc: Python objects are just "Map String object" linking symbol names (*cough*strings*cough*) to objects (which can be functions)
10:30:32 <merijn> Anyhoo, gotta run
10:30:45 <teki> benmachine: oh, I see.  I just checked a couple other basic types all of which were in there; I guess I was confused by the lack of a pattern.
10:31:33 <benmachine> teki: I'd very much like it if tuples were made more regular, so that instances could be declared for them normally
10:31:43 <benmachine> but I've never got around to actually doing anything about it :)
10:32:12 <hpc> it would be neat if larger tuples were instead nested 2-tuples
10:32:25 <benmachine> teki: incidentally, :i Ord tells me that those instances are defined in GHC.Classes, so they might have moved
10:32:25 <hpc> and somehow exploit the fixity of (,)
10:32:39 <benmachine> teki: make sure your version of ghc/base matches the version whose docs you are reading
10:32:43 <hpc> (hypothetical fixity, because atm the parens are required)
10:32:59 <benmachine> hpc: yeah, that was my idea, one subtlety is that such a type will have extra bottoms
10:33:09 <benmachine> (which might correspond to greater overhead if you're not careful)
10:33:18 <monochrom> teki, benmachine: first you read http://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009 to see "data  (a,b)   =  (a,b)    deriving (Eq, Ord, Bounded)", "data  (a,b,c) =  (a,b,c)  deriving (Eq, Ord, Bounded)", "-- Not legal Haskell; for illustration only". Then you read http://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18200011 for what "deriving Ord" does.
10:33:22 <hpc> benmachine: eh, code that uses big tuples has more problems to worry about :D
10:33:50 <benmachine> hpc: big tuples are useful sometimes!
10:34:06 <hpc> benmachine: orly?
10:34:10 <benmachine> yes
10:34:16 <benmachine> examples left as an exercise to the reader
10:34:19 <hpc> lol
10:34:26 <benmachine> no I find them useful trying to write applicative parsers
10:34:37 <benmachine> but the example I had in mind I binned because it still didn't work
10:34:48 <acowley> Installing network-2.3.0.2 and the latest cabal-install seems unfortunately hairy
10:34:50 <benmachine> but the principle was sound
10:35:03 <benmachine> in any case, it's useful for operating on datasets in parallel, using something like a zip
10:35:26 <benmachine> acowley: are you getting that thing where you say cabal install cabal-install and it tries to install version 0.8.whatever
10:35:27 <hpc> i would think it would be nicer to manipulate nested tuples than one big flat one
10:35:43 <hpc> it would make arrow stuff not so nasty, at least
10:35:46 <benmachine> mm
10:35:52 <acowley> benmachine: I think the appeal of tuples would be mitigated with more accessible generic techniques for dealing with records
10:35:57 <benmachine> I would like (a,b,c) to be sugar for (a,(b,c))
10:36:00 <hpc> and by less nasty, i mean possible to use
10:36:06 <benmachine> acowley: possibly
10:36:18 <hpc> benmachine: same nere
10:36:20 <hpc> *here
10:36:25 <zygoloid> benmachine: so (undefined, undefined) would be a value of type (a, b, c)?
10:36:40 <acowley> benmachine: it's an issue where the latest network requries the latest cabal-install. Installing the latest cabal-install tries to install the latest network.
10:36:46 <dhun> to me it looks like using a map from string to function makes sense, but I think I can not uses where in the definition of the functions
10:36:57 <acowley> to get it all working, I have to install a slightly order network, then install the latest cabal-install, then install the latest network
10:37:29 <hpc> honestly, i couldn't give a flying crap about how many bottoms a tuple has
10:37:37 <hpc> it's "undefined" for a reason ;)
10:37:39 <acowley> hpc: You should!
10:38:21 <benmachine> zygoloid: it would unify with that, yes
10:38:45 <zygoloid> ugh, that's operationally horrible
10:38:53 <benmachine> explain
10:38:56 <acowley> Why?
10:39:10 <hpc> acowley: i would care if i dealt with code that frequently produced undefined values
10:39:36 <acowley> I really wish network had waited before requiring a feature of the latest cabal-install. This is very frustrating.
10:39:45 <acowley> hpc: think about laziness, though
10:39:57 <acowley> hpc: those bottoms are opportunities to be lazy
10:40:06 <hpc> acowley: um... yay?
10:40:39 <acowley> exactly! yay! data Stream a = Cons a (Stream a)
10:40:55 <hpc> i mean, if you stack overflow on a deep tuple, you are doing something wrong
10:41:05 <monochrom> that is not an infinite lazy tuple
10:41:12 <dhun> shachaf the problem with using let is that I can not refer to the parameter x in \x-> while I am in let
10:41:20 <benmachine> tuples can't be infinite, you'd need an infinite type
10:41:28 <tibbe> acowley: what problems are you running into?
10:41:28 <acowley> dhun: I think you can
10:41:34 <benmachine> dhun: \x -> let ... in ...
10:41:44 <dhun> like this ok
10:41:57 <monochrom> > (\x -> let f=f in x+1) 2
10:41:57 <acowley> tibbe: what I said earlier, "cabal install cabal-install-0.10.4" brings in HTTP, which tries to bring in network-2.3.0.2
10:41:58 <lambdabot>   3
10:42:18 <acowley> but network-2.3.0.2 fails to install, so I have to manually install network-2.3, then do cabal-install-0.10.4
10:42:22 <acowley> then I can do network-2.3.0.2
10:42:29 <tibbe> acowley: interesting
10:42:33 <acowley> at least, that's the dance I've worked out in this round of updating my computers
10:42:46 <tibbe> acowley: I just did cabal install cabal-install-0.10.2
10:42:47 <monochrom> I manually installed the haskell platform. No hassle.
10:42:51 <tibbe> and it worked fine
10:42:59 <hpc> > (\x -> let f = x in f + 1) 2
10:43:00 <lambdabot>   3
10:43:09 <acowley> Hrm, I've seen this four times now
10:43:30 <monochrom> you have seen the haskell platform four times? :)
10:43:50 <acowley> no, I'm not using the platform because one of my machines is OS X 10.5
10:43:53 <dhun> ok this works for me thanks
10:44:14 <acowley> there's no platform or GHC binary for 10.5, so I'm trying to be consistent and skipping the platform everywhere
10:44:19 <monochrom> oh yikes. that is why I still don't buy a mac.
10:44:24 <acowley> So I'm going from 6.12.3 to 7.0.3
10:44:33 <tibbe> acowley: I'm on 10.6.4
10:44:39 <tibbe> acowley: I also skipped the platform
10:44:45 <acowley> tibbe: this computer is 10.6.6
10:44:50 <tibbe> ok
10:44:53 <acowley> where I just had the network version problem
10:44:59 <acowley> no Xcode 4 yet
10:45:38 <tibbe> hmm
10:45:44 <tibbe> if you can reproduce it I could have a look
10:46:07 <acowley> HTTP-4000.1.1 depends on network-2.3.0.2 which failed to install.
10:46:08 <acowley> cabal-install-0.10.2 depends on network-2.3.0.2 which failed to install.
10:46:08 <acowley> network-2.3.0.2 failed during the building phase. The exception was:
10:46:08 <acowley> ExitFailure 1
10:46:42 <acowley> There, that was the result of "cabal install cabal-install-0.10.2"
10:47:07 <acowley> Which I did because an earlier install tried to install network-2.3.0.2 and failed
10:47:39 <acowley> I found a mention somewhere that the network-2.3.0.2 installation failure was due to out of date cabal-install, which is how I worked out my "fix"
10:48:38 <Chrus> going to sound stupid, but i downloaded the Haskell Platform and am confused as to where the programming environment is located.
10:48:54 <mzero> on your command line
10:48:58 <mzero> it isn't an IDE
10:48:58 <byorgey> Chrus: what do you mean by "programming environment"?
10:49:09 <Chrus> like where you enter the code
10:49:18 <Chrus> In terminal?
10:49:19 <byorgey> Chrus: There is 'ghci' which lets you interactively evaluate expressions
10:49:20 <mzero> it isn't a development environment
10:49:29 <byorgey> Chrus: just use your favorite text editor.
10:49:30 <warzl> there are a couple IDEs available though
10:49:43 <byorgey> Chrus: you may be interested in checking out leksah
10:49:47 <Chrus> I cant find the GHCI, when i went to download one they said it was already in Haskel Platform
10:49:50 <mzero> you generally use your favorite text editor, write and save code to files, then use ghc and ghci to run it
10:49:50 <warzl> google haskell IDE
10:49:59 <ckid> the following code should return the last character/digit from a string/list. how does haskell respectively the compilder know when there is one item in the list? does it secretly check it?
10:50:00 <ckid>  last :: [a] -> a last [x] = x last (_:xs) = letztes xs
10:50:01 <byorgey> @where leksah
10:50:01 <lambdabot> http://www.leksah.org/
10:50:02 <mzero> Chrus - what OS are you on?
10:50:02 <acowley> Yay! 32-bit 7.0.3 works with -fllvm
10:50:11 <ckid> sorry:  last :: [a] -> a last [x] = x last (_:xs) = last xs
10:50:24 <Chrus> Mac Os 10.6.7
10:50:30 <mzero> open a terminal window
10:50:30 <Chrus> OS*
10:50:38 <mzero> then type "ghci"
10:50:40 <byorgey> ckid: it not-at-all-secretly checks it.
10:50:52 <mzero> you should be in the interactive haskell environment at that point
10:51:10 <byorgey> ckid: it just makes sure the list is a cons (:) followed by the empty list [].
10:51:21 <Chrus> perfect thanks!
10:51:34 <acowley> last [] is a sad story
10:51:53 <mzero> you could check out leksah or EclipseFP if you want a full fledged environment --- or Barley if you want a web-page based tinkering environment!
10:53:03 <tibbe> sped up Data.Binary.Builder with up to 40% today. :)
10:53:04 <mzero> ckid:   [a] as a pattern is just a short cut for this pattern:   (a : [])
10:53:39 <mzero> and that pattern is matching against two levels of constructor:   the : constructor at top, and [] contained within
10:54:19 <Twey> As an expression too.
10:54:27 <acowley> tibbe: any particular use cases attached to that speedup?
10:54:44 <acowley> tibbe: there was a perf issue in HaXML that prompted us to use blaze
10:54:47 <tibbe> acowley: nope
10:55:08 <tibbe> acowley: should be a general speed-up from changing the internal buffer type
10:55:11 <acowley> tibbe: we wanted to go back to binary, but I have yet to re-run the performance tests
10:55:30 <acowley> tibbe: what changes?
10:55:58 <aristid> binary, cereal, blaze-builder... lots competition in that space :D
10:56:08 <tibbe> acowley: https://github.com/tibbe/binary/commit/26d9a5ceaf90d1009a72057556fc785d3d3549d9
10:56:10 <ckid> ah ok, thanks to mzero and byorgey, i now understood the pattern matching... i guess :)
10:56:30 <ckid> wasnt aware of a : []
10:56:54 <rostayob> ok, I have a proglem: I have a function with no type signature, ghc suggests one, I put the one ghc suggests and it does not work: http://hpaste.org/45163/type_issues
10:56:59 <byorgey> ckid: oh, I see, maybe you were just confused about the notation.  Yes, the pattern [x] specifically means only a one-element list whose element is called x
10:57:33 <tibbe> acowley: in summary: the amount of state that gets passed around shrinks and indexing gets more efficient (see writeNBuffer)
10:57:51 <mzero> You can think of lists being defined like this:     type List a = End | Item a (List a)     --- only the spelling is:    type [a] = [] | a : [a]
10:57:59 <aristid> tibbe: oh, blaze's Builder is moving into binary?
10:58:09 <tibbe> aristid: some good ideas from it yes
10:58:12 <tibbe> aristid: API no
10:58:29 <tibbe> aristid: and we do a bit more now, binary automatically merges adjacent bounds checks
10:58:49 <tibbe> aristid: so: a `mappend` (b `mappend` c) only does one bounds check instead of 3
10:59:01 <tibbe> (you need to check that there's enough buffer space before writing)
10:59:26 <aristid> tibbe: why not the API? compatibility would be nice..
10:59:34 <hpc> rostayob: load it into ghci without the signature and use :t
10:59:38 <hpc> see what it says
10:59:38 <tibbe> aristid: it could be simpler
10:59:49 <tibbe> aristid: much of it isn't needed for performance
11:00:08 <hpc> theoretically it shouldn't be different, but worth checking
11:00:12 <rostayob> hpc: the same as what I posted, without the explicit forall
11:00:18 <acowley> tibbe: I notice you're very particular UNPACK pragmas, does the compiler flag for that not cover these cases?
11:00:36 <aristid> tibbe: so what's the plan? will blaze-builder and binary just coexist, unmerged?
11:00:49 <tibbe> acowley: it does, but sometimes you don't want to unpack strict fields but the compiler flag will unpack those anyway
11:00:55 <tibbe> aristid: we'll see :)
11:01:10 <tibbe> aristid: the final plan is to move one builder into Data.ByteString.Builder, in the bytestring package
11:01:14 <tibbe> that's really where it belongs
11:01:29 <aristid> tibbe: maybe a possibility would be to change blaze-builder into a thin compatibility package atop binary
11:01:37 <aristid> well i guess that's a bit longer-term
11:01:53 <aristid> if there is not even agreement on the API yet :P
11:02:14 <tibbe> aristid: yes, my real goal is to figure out what is the core API necessary to write fast serialization for anything
11:02:29 <tibbe> aristid: I think I've figure out that you need exactly one low-level combinator
11:02:31 <byorgey> rostayob: I've seen situations like that before, but without being able to see the code it's hard to know what the problem is
11:02:36 <byorgey> rostayob: is the code long?
11:02:39 <tibbe> then you can get all the bounds checking optimization etc for free
11:02:52 <aristid> tibbe: the fact that the Builder stuff uses IO makes me uncomfortable, somehow :/
11:02:54 <rostayob> byorgey: no, like 3 lines, just a second
11:03:06 <byorgey> rostayob: oh, wait, I know what the problem is
11:03:14 <aristid> tibbe: what is that combinator?
11:03:16 <rostayob> byorgey: http://hpaste.org/paste/45163/type_issues_annotation#p45164
11:03:19 <byorgey> rostayob: the problem is that s is mentioned only in the constraints, and not in the type itself
11:03:41 <tibbe> aristid: writeAtMost :: Int -> (Ptr Word8 -> IO Int) -> Builder
11:03:59 <byorgey> rostayob: so there is some type s0 which is inferred from the code, but GHC has no way of knowing that it is supposed to be the same s as in the type signature
11:04:00 <rostayob> byorgey: ok, but then what type signature should I put? and isn't it a bug that ghc provides a wrong type signature?
11:04:18 <tibbe> aristid: blaze-builder gets most of its speed from writing specialized builders for specific types inside the library. That won't scale as blaze will end up depending on half of hackage eventually
11:04:25 <aristid> tibbe: and the IO Int is where the IO is necessary?
11:04:27 <byorgey> rostayob: it is not a wrong type signature.
11:04:29 <tibbe> aristid: so you need a decoupling that's efficient, that combinator is it
11:04:35 <tibbe> aristid: yes
11:04:42 <byorgey> rostayob: you need ScopedTypeVariables, just a second
11:04:51 <tibbe> aristid: but by only exposing a single IO function we can more easily switch it to e.g. ST later
11:05:06 <rostayob> byorgey: oh ok, another Language flag ehe
11:05:20 <aristid> tibbe: and benchmark it in the process, to see whether ST does not affect it adversely?
11:05:34 <byorgey> rostayob: right.  Then you can add  'forall s m a. ' before the type
11:05:50 <byorgey> rostayob: and then you will need to add a type annotation somewhere on the code that refers to s
11:06:15 <byorgey> rostayob: I don't know what the types of context, access, etc. are so I am not sure where the type annotation should be
11:06:18 <tibbe> aristid: at the moment I'm pretty sure ST would be worse
11:06:25 <tibbe> aristid: because we can't do pointer arithmetic in ST
11:06:30 <acowley> tibbe: this looks like a pretty substantial rewrite!
11:06:35 <tibbe> acowley: yes
11:06:38 <tibbe> acowley: more to come
11:06:47 <byorgey> rostayob: this way you explicitly inform GHC that 'this type here is supposed to be the same one as that type s up there'
11:06:57 <rostayob> byorgey: uhm, ok
11:07:13 <acowley> Is the unsafePerformIO worth it?
11:07:26 <rostayob> byorgey: the code is simply
11:07:29 <rostayob> run s m q = do
11:07:31 <rostayob>   (db, pool) <- context
11:07:33 <rostayob>   access s m pool $ use db q
11:07:39 <tibbe> acowley: necessary for laziness
11:07:40 <rostayob> pool is of type 'ConnPool s'
11:07:48 <byorgey> rostayob: oh, perfect
11:07:53 <tibbe> acowley: we can serialize as the lazy bytestring is consumed
11:07:53 <rostayob> so the only thing to do is to annotate context
11:07:55 <rostayob> like
11:08:00 <byorgey> rostayob: so just change it to  (db, pool :: ConnPool s) <- ...
11:08:04 <rostayob> context :: m (Database, ConnPool s)
11:08:10 <byorgey> or that
11:08:12 <rostayob> yeah or to the left, can I do that?
11:08:21 <byorgey> you can put a type annotation on any expression
11:08:37 <rostayob> oh right
11:08:51 <rostayob> byorgey: I still don't get why I need to do that.
11:09:26 <acowley> tibbe: and no trouble with serializing the same builder multiple times?
11:10:04 <byorgey> rostayob: the type says that there is some type s which is an instance of Service and so on.  But GHC has no way to infer that s is the same as the one in the type of pool
11:10:22 <rostayob> oh.. ok I get it
11:10:30 <tibbe> acowley: nope
11:10:43 <tibbe> acowley: the API is pure
11:11:00 <byorgey> rostayob: note how s does not show up in the rest of the type  WriteMode ...  m (Either Failure a)
11:11:10 <acowley> oh I see, fill doesn't call run, so the inlining doesn't bite you
11:11:34 <byorgey> rostayob: that was the giveaway to me
11:11:38 <rostayob> byorgey: yes, I missed the step in which ghc does not know that those two are the same
11:12:01 <byorgey> rostayob: ok, let me know if it works =)
11:12:09 <acowley> Oh, wait, it does
11:12:23 <acowley> despite the warnings on inlinePerformIO
11:13:05 <rostayob> byorgey: it does, thanks
11:13:12 <byorgey> rostayob: great, you're welcome
11:13:14 <tibbe> acowley: yes, the argument why this is safe is tricky and relies on the use of continuations
11:13:16 <rostayob> i'd have never figured it out eheh
11:13:27 <tibbe> acowley: the linear use is forced through the continuations
11:13:40 <tibbe> it's like we threaded another World baton around
11:13:52 <tibbe> and yes, you should be scared :)
11:13:57 <acowley> tibbe: I'm just not seeing how your ensuring linear usage
11:14:13 <tibbe> acowley: dcoutts_ told me once, I mostly forgot
11:14:19 <aristid> just put Builder inside the ghc runtime *evil suggestion*
11:14:25 <tibbe> heh
11:14:31 <tibbe> it almost is ;)
11:14:35 <acowley> I burned myself so badly once with trying to be cute about inlining some unsafe code
11:14:41 <aristid> tibbe: how so?
11:14:48 <acowley> so I'm very skeptical when I see things like this
11:15:25 <acowley> I should study it though, if enough people have convinced themselves it's safe, then it's possibly a very valuable technique
11:16:57 <tibbe> aristid: I mean it's low level enough
11:17:05 <tarrasch> Hello, I want my short haskell-program to startup very fast, is runhaskell faster than a compiled binary then?
11:17:08 <tibbe> aristid: and we use lots of knowledge of how GHC works to make it fast
11:17:16 <tibbe> tarrasch: most likely
11:17:25 <tarrasch> tibbe, Ok, thanks :)
11:17:35 <aristid> tibbe: does Builder have any pretense of being portable?
11:17:45 <tibbe> aristid: It does work on Hugs
11:17:48 <tibbe> aristid: I think
11:17:55 <tibbe> at least there's a Hugs test somewhere
11:17:59 <aristid> uh.
11:18:02 <tibbe> performance would suck of course
11:18:13 <tibbe> it uses portable APIs
11:18:21 <tibbe> there's no second implementation to test with though
11:18:23 <aristid> tibbe: but in a scary way.
11:19:30 <acowley> I feel like I need a good, clean, simple case that breaks with unsafe IO to attempt reductions to it when considering code like this
11:28:50 <mekeor> do you know how the egoshooter, which's written in Haskell,  is called
11:28:51 <mekeor> ??
11:34:57 <byorgey> mekeor: Frag?   http://www.haskell.org/haskellwiki/Frag
11:35:15 <byorgey> mekeor: in english it is called a "first-person shooter"
11:35:35 <mekeor> oh, :), thank you, byorgey
11:37:16 <mekeor> I have another, also trivial question:
11:37:16 <mekeor> how do i define a function which gets n variables and makes them to ONE?
11:38:04 <mekeor> function_name a b c = x
11:38:04 <mekeor> like this, maybe…
11:38:04 <mekeor> or in maths it would be f(x, y, z) or something similar
11:38:22 <byorgey> mekeor: just like that,  f a b c = ...
11:38:45 <mekeor> function :: ??? -> ???
11:39:42 <mekeor> whats the "prototype" (??) then?
11:39:59 <mekeor> the function-definition, the header…
11:40:25 <byorgey> yes, the type signature
11:40:46 <byorgey> it would be something like   function :: A -> B -> C -> X
11:41:04 <byorgey> where A is the type of the first argument, B is the type of the second, .... and X is the type of the result
11:41:14 <mekeor> a
11:41:25 <mekeor> thank you very much, byorgey!!
11:41:34 <byorgey> you're welcome =)
11:42:01 <mekeor> sorry about that, but i've got a last question, too:
11:42:01 <mekeor> what is the "=>" symbol in haskell called?
11:42:12 <mekeor> i often find it in the type signature of functions
11:42:22 <mekeor> do you have a link to an explanation?
11:43:05 <mekeor> unfortunately google doesn't provide searching for special characters :(
11:43:19 <byorgey> I don't know what it's called, but type class constraints come before it and the rest of the type comes after it
11:43:36 <byorgey> mekeor: read about type classes if you want to learn more about it
11:44:04 <mekeor> all right, thx again :)
11:46:25 <monochrom> => is called Sandra McIntosh
11:46:39 <aristid> monochrom: no you're not.
11:46:58 <monochrom> Right, I am not called Sandra McIntosh. => is.
11:47:29 <byorgey> "If a is an instance of Eq, Sandra McIntosh take two values of type a and return a Bool"
11:47:45 <byorgey> I like it
11:48:07 <aristid> monochrom: i guess you should have quoted it :)
11:48:16 <monochrom> yeah
11:48:38 <scree_> "equals has type Eq a Sandra McIntosh a to a to bool" would be my reading
11:49:20 <scree_> there should be more "spoken haskell" conventions
11:49:58 <scree_> I'd like a name for "<-" for one thing
11:50:34 <aristid> scree_: "from"?
11:50:44 <aristid> that, or Carl McIntosh
11:51:01 <scree_> aristid: I think "from" is too ambiguous
11:51:19 <aristid> Carl McIntosh is not ambiguous.
11:51:26 <aristid> but longer :(
11:51:39 <scree_> aristid: and naming all our symbols after members of the McIntosh family seems unnecessarily redundant
11:52:13 <aristid> scree_: we can use it to show symmetries.
11:52:19 <aristid> obviously => and <- look similar.
11:52:25 <aristid> and almost symmetric!
11:52:59 <cathper> Semibroken mirror.
11:53:05 * scree_ is unconvinced
11:53:05 <aristid> scree_: so (&&) would come from another family.
11:53:31 <aristid> McIntosh is the family of pointy looking symbols
11:53:32 <monochrom> @quote monochrom von
11:53:32 <lambdabot> monochrom says: <$> is pronounced Jacquelin von Brionée
11:53:42 <revenantphx> What's the debate here?
11:54:00 <aristid> monochrom: omg. you are mixing french and german-style noble names. EVIL
11:54:07 <cathper> Anyone knows if a method for solving the maximum weighted bipartite matching problem in haskell?
11:54:11 <cathper> https://secure.wikimedia.org/wikipedia/en/wiki/Maximum_matching#Maximum_matchings_in_bipartite_graphs
11:54:13 <scree_> so, does it have the same name in pattern guards, or is it only coincidence that those have the same syntax, so there should be different names?
11:54:50 <monochrom> The idea is to make sure that the "pronouncible name" is more difficult than the symbol itself.
11:55:21 <monochrom> There is a cult of "reading out loud helps me comprehend" among programmers, and I am mocking it.
11:56:12 <aristid> monochrom: it isn't that difficult to pronounce :)
11:56:56 <scree_> we could name these symbols after prominant donors to the haskell cause
11:57:47 <aristid> scree_: "buy your OWN symbol name"
11:58:47 <byorgey> like ^^ is pronounced "scree_ the fantastically magnificent", that sort of thing?
11:59:00 <cathper> What's wrong about thinking "running through" when you see <- in a list comprehension rather than "less than hyphen"?
11:59:14 <scree_> byorgey: I'd settle for just my name, but sure
11:59:19 <byorgey> cathper: nothing.
11:59:33 <byorgey> cathper: but some people pronounce things in their head when reading them, and some don't.
11:59:37 <Philippa> monochrom: some people are 'verbal' thinkers, for them it probably really does help
11:59:48 <Philippa> snap!
12:00:13 <byorgey> cathper: I don't think "less than hyphen", I don't pronounce it in any way at all.
12:00:21 <monochrom> I am a verbal thinker too. f <$> x <*> y is "eff blah x blah y"
12:00:45 <Philippa> (it's also partly a matter of linking informal semantics to formal, because formal ones're a pain in the arse if you don't have an existing point of reference)
12:00:45 <Philippa> "f of x and y, applicative style"
12:01:04 <Philippa> insisting on a transliteration rather than a translation is bad though
12:01:37 <byorgey> The other day I heard of people who pronounce that as "f money x splat y" or something like that
12:01:40 <Philippa> (internally I have something akin to tonal going on with that and - it's not tuple-AND)
12:01:41 <monochrom> err, "eff blah ex blah why"
12:01:42 <byorgey> maybe it was people at Galois, I'm not sure
12:01:57 * ezyang heard Galois 
12:02:09 <Philippa> ...yeah, let's talk about money and splatting
12:02:19 <byorgey> let's start rumors about Galois
12:02:20 <monochrom> in general I invent some funny sound impromptu for symbols
12:02:23 <cathper> byorgey: Well, sometimes I do. Sometimes I don't. The harder something is to understand for me, the more probable it is that I'll "pronounce it in my head", or even "talk to myself".
12:02:34 <scree> I mainly notice this when I'm trying to explain things to people without paper
12:03:20 <scree> Then trynig to pronounce a string of meaningless symbols is significantly worse than having *any* pronouncable name
12:03:28 <byorgey> cathper: fair enough.  There's no right and wrong answer here, make up whatever names you want for Haskell symbols =)
12:04:34 <scree> ls
12:04:47 <monochrom> @quote monochrom modem
12:04:47 <lambdabot> No quotes match. Just what do you think you're doing Dave?
12:04:56 <scree> oops
12:05:42 <mauke> preflex: quote monochrom modem
12:05:42 <preflex>  <monochrom> Do not try to pronounce haskell code. You are not a modem.
12:06:23 <aristid> i guess people who have trouble dealing with unverbalised symbols will have trouble with programming in general
12:06:54 <monochrom> they didn't have trouble with cobol, designed to be exactly manager-friendly english
12:08:20 <monochrom> I am or was a verbal thinker too. In my head I habitually voice out my thoughts.
12:08:55 <acowley> I usually think that I verbalize code in my head, but when I actually go to say it outloud find that I use significant whitespace in my internal monologue.
12:09:05 <acowley> Operators are just particular kinds of silence
12:09:14 <monochrom> But over the years I have developed a generalization. I can embed pictures in my voice stream. Not unlike how you would do it in html.
12:10:38 <aristid> acowley: which for things like <$> is probably just fitting: a special kind of whitespace
12:10:50 <monochrom> So with f<$>x<*>y, in my head it's like [voice] f [pic] <$> [/pic] x [pic] <*> [/pic] y [/voice]
12:11:11 <aristid> monochrom: can you also manipulate the DOM? :D
12:11:48 <monochrom> can a little bit in my head. much more successful on paper.
12:12:46 <marcot> Hi.  I have a list of values for which I want to execute an action on them.  I'm using mapM_ for it.  Now I found a case where, depending on the value, I want to interrupt the execution, and not execute any of the following values.
12:12:49 <acowley> aristid: I think so. It's much like Philippa said.
12:12:50 <cathper> Thinking "Hmm is, uhm, yes. Then, ehm, mhm. So it's sorted, and, ehh, hmm, right, it'll be linear and we get that." is not uncommon for me.
12:12:57 <marcot> Is there a haskell construct to do this cleanly?
12:13:32 <aristid> marcot: what types do the values have?
12:13:52 <marcot> aristid: The list is [String] and the action is String -> IO ()
12:14:08 <aristid> marcot: and when do you cancel?
12:15:23 <marcot> aristid: Well, I cancel when I receive a certain value x, and I call a function f :: String -> IO Bool and it returns true.
12:15:40 <acowley> oof
12:15:48 <aristid> marcot: so it's really String -> IO Bool, not String -> IO ()?
12:15:51 <acowley> a monadic predicate isn't very friendly
12:16:27 <marcot> aristid: f is called inside the (String -> IO ()) action.
12:16:36 <marcot> aristid: Are you suggesting I should change the type of the action?
12:17:04 <aristid> marcot: the cancellation must be visible form outside, so it should at least be String -> IO Bool
12:17:13 <acowley> I think I would do this recursively, to be honest
12:18:12 <marcot> Ok, recursively should do it.  Thanks.
12:19:06 <aristid> marcot: how about andM, from monad-loops?
12:19:15 <aristid> andM :: Monad m => [m Bool] -> m Bool
12:19:44 <marcot> aristid: perfect, thanks
12:19:55 <dafis> Anybody here knows how I get GHC to build with integer-simple? Setting INTEGER_LIBRARY = integer-simple in mk/build.mk doesn't do the trick, sh validate still boots integer-gmp and not integr-simple.
12:20:01 <aristid> monad-loops is a cute little package :)
12:23:36 <aristid> marcot: or better yet, anyM
12:25:07 <acowley> It is nice, but it's one of those packages that, in my usage, is right on the limit of whether or not the extra dependency and cognitive load is worth it
12:25:25 <marcot> aristid: I thought andM . map, but anyM is simpler indeed
12:26:17 <aristid> acowley: well the cognitive load can be amortised if enough packages use it
12:26:27 <acowley> andM is a good example, I'm with those who want a boolean eliminator so we could write something like, andM (p:ps) = p >>= if' (andM ps) (return False)
12:26:27 <aristid> but i agree that this is a problem
12:27:11 <aristid> acowley: a monadic if?
12:27:18 <acowley> aristid: Yes, and monad-loops does nothing wrong, it's just one of those awkward little things
12:27:29 <acowley> aristid: no, a regular if function
12:27:40 <aristid> oh, right.
12:27:50 <aristid> yeah, if should be a function.
12:27:51 <acowley> if' t _ True = t; if' _ e False = e
12:27:56 <aristid> making it syntax is one of the mistakes in haskell.
12:28:32 <acowley> I guess the then and else keywords are useful, and we probably don't want Agda-style mixfix
12:30:27 <aristid> acowley: they are useful? for what?
12:30:38 <aristid> acowley: confusing people with their indentation requirements? :P
12:31:52 <acowley> exactly, they give us something familiar to talk about when teaching Haskell
12:32:07 <acowley> people who program are used to such pain
12:32:29 <aristid> sounds convincing. not. :P
12:33:23 <acowley> Functions are very useful, but abstract. Sometimes you want some concrete pain.
12:45:16 <parcs> @src Floating
12:45:17 <lambdabot> class  (Fractional a) => Floating a  where
12:45:17 <lambdabot>     pi                                                      :: a
12:45:17 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
12:45:17 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
12:45:17 <lambdabot>     (**), logBase                                           :: a -> a -> a
12:46:01 <dafis> > pi :: CReal
12:46:01 <lambdabot>   3.1415926535897932384626433832795028841972
12:46:36 <parcs> :t 6.6
12:46:36 <lambdabot> forall t. (Fractional t) => t
12:46:42 <parcs> oh
12:46:47 <parcs> @src Fractional
12:46:47 <lambdabot> class  (Num a) => Fractional a  where
12:46:47 <lambdabot>     (/)             :: a -> a -> a
12:46:47 <lambdabot>     recip           :: a -> a
12:46:47 <lambdabot>     fromRational    :: Rational -> a
13:12:23 <ezyang> Would it be accurate to say that GADTs can be used to simulate some amount of subtyping? 
13:13:44 <dafis> I'd say yes
13:14:08 * dafis does not know what amount, though
13:19:24 * hackagebot heist-aeson 0.1 - Use JSON directly from Heist templates.  http://hackage.haskell.org/package/heist-aeson-0.1 (DavidHimmelstrup)
13:19:49 <mathijs> Hi all, I'm playing around a bit with arrows (more specifically, something like a streamprocessor). I have a function that takes as input the outputs from A and B. Since they don't produce output at the same rate, I need to combine this using Either and ArrowChoice... so far so good...
13:21:17 <mathijs> but B is the output from somehwat further down the line, so I need an ArrowLoop. but loop is a (b,d) (c,d) -> a b c. so in my case d is an output from B.
13:22:20 <mathijs> but since B doesn't produce a lot of output (just a "quit" signal basically), I can't think of a way to do this. the code will end up blocking...
13:24:25 * hackagebot heist-aeson 0.2 - Use JSON directly from Heist templates.  http://hackage.haskell.org/package/heist-aeson-0.2 (DavidHimmelstrup)
13:24:32 <Philonous> Is there an implementation of the dynamic delimited control operators as an indexed monad? 
13:26:43 <dolio> Philonous: I probably have something like that lying around somewhere.
13:26:54 <dolio> I implemented everything in Shift to Control way back.
13:27:07 <Philonous> dolio: cupto, too?
13:28:07 <dolio> Which one is that?
13:28:13 <Philonous> dolio: control0
13:28:19 <dolio> Yes.
13:28:37 <lutza> hello i must implement c preprocessor in haskell, i ended up using parsec library, now im trying to figure how to parse macro name without trailing whitespace, so i can distinguish between #define LOL (a,b) and #define LOL(a,b) ... second being function macro and first object macro... please help
13:28:46 <dolio> http://code.haskell.org/~dolio/haskell-share/shiftcont/
13:29:16 <dolio> Apparently I didn't use an indexed monad.
13:31:10 <Philonous> dolio: Ah, well, all the better, than I have something to puzzle over
13:31:40 <lutza> ^can someone respond to my question please, if its too confusing pm me and i will clarify
13:32:52 <mauke> oh god, good luck with that
13:33:07 <mauke> I think the preprocessor is the hardest part in writing a C compiler
13:33:33 <dolio> Why must you implement one? Is this an assignment of some sort?
13:33:42 <dolio> I thought there was a CPP in Haskell already.
13:33:45 <lutza> yea school asignment
13:33:51 <dolio> Ah.
13:34:07 <lutza> i just need to force Parsec parsing functions not to eat up trailing whitespace
13:34:36 <dolio> Are you using the Token modules or something?
13:34:38 <monochrom> generally you build a layer of little parsers that fill the role of "lexical scanner", e.g., identifier = do { x <- many1 letter; many space; return (Identifier x) }
13:34:43 <mauke> I thought the primitives didn't eat whitespace
13:35:20 <monochrom> generally it parses a "token" or "lexeme", then skips post-spaces, then returns the found token.
13:36:10 <lutza> yea i can write such parser problem is it wont match for reserved names
13:36:18 <lutza> but embedded identifier does it
13:36:21 <monochrom> (as for pre-spaces, one single "many space" at the very beginning of the main parser takes care of that)
13:37:00 <monochrom> oh I'm talking about the scanner level, not at the grammar level yet.
13:37:34 <dafis> lutza: use notFollowedBy perhaps
13:37:40 <monochrom> the grammar level builds on top of the scanner level, e.g., blablah = reserved <|> identifier <|> ...
13:38:16 <Taslem> Is there a simple way to go from    [Maybe a] -> Maybe [a]?
13:38:23 <benmachine> Taslem: yes
13:38:27 <Taslem> How?
13:38:32 <benmachine> well
13:38:36 <mauke> const Nothing
13:38:43 <benmachine> it depends a little on what exactly you want to happen
13:38:46 <mauke> (screw your semantics)
13:38:46 <monochrom> you have two levels. the low level parsers do nothing more than what regexes can do, and they take care of spaces. the high level parsers don't worry about spaces or lack of spaces at all.
13:38:51 <benmachine> as mauke so helpfully illustrated
13:38:54 <benmachine> @hoogle [Maybe a] -> Maybe [a]
13:38:54 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
13:38:54 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
13:38:54 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
13:38:59 <Taslem> I was thinking of removing all of the Nothing's.
13:39:03 <benmachine> oh
13:39:09 <benmachine> why would that be Maybe [a]?
13:39:10 <mauke> Taslem: then why does the result still contain Maybe?
13:39:15 <benmachine> in what cirucmstances would you get Nothing?
13:39:19 <monochrom> and yes, the Token module could be convinced to give all the low level parsers to you.
13:39:22 <Taslem> Because if it's a list of all Nothings.
13:39:31 <mauke> then you get []
13:39:32 <benmachine> ok
13:39:34 <djahandarie> That can be represented as an empty list.
13:39:38 <benmachine> when does it return Just []?
13:39:41 <Taslem> Well, I suppose.
13:39:58 <monochrom> see my http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements for a demonstrating example.
13:40:02 <djahandarie> Taslem, this is how they chose to implement it in the standard library at least.
13:40:12 <djahandarie> > catMaybe [Just 3, Nothing, Just 5]
13:40:13 <lambdabot>   Not in scope: `catMaybe'
13:40:16 <benmachine> *catMaybes
13:40:17 <djahandarie> > catMaybes [Just 3, Nothing, Just 5]
13:40:18 <lambdabot>   [3,5]
13:40:23 <lutza> dafis: notFollowedBy looks promising where can i find more about it ?
13:40:35 <benmachine> there are other ways to do it
13:40:36 <benmachine> e.g.
13:40:54 <benmachine> > let xs = [Just 3, Nothing, Just 5] in [x | Just x <- xs]
13:40:54 <lambdabot>   [3,5]
13:41:12 <benmachine> > let xs = [Just 3, Nothing, Just 5] in do Just x <- xs; return x
13:41:13 <lambdabot>   [3,5]
13:41:20 <djahandarie> benmachine, I don't know if I'd call that an 'other way'
13:41:30 <djahandarie> That's exactly how catMaybe is defined
13:41:30 <dafis> lutza: if the current parsec haddocks aren't sufficient, there's an old parsec tutorial somewhere
13:41:33 <benmachine> > let xs = [Just 3, Nothing, Just 5] in foldr (maybe (flip const) (:)) []
13:41:34 <lambdabot>   Couldn't match expected type `b -> b' against inferred type `[a]'
13:41:38 <benmachine> hmm
13:41:50 <benmachine> > let xs = [Just 3, Nothing, Just 5] in foldr (maybe id (:)) []
13:41:51 <lambdabot>   Overlapping instances for GHC.Show.Show
13:41:51 <lambdabot>                              ([Data...
13:41:55 <benmachine> blergh
13:41:57 <benmachine> > let xs = [Just 3, Nothing, Just 5] in foldr (maybe id (:)) [] xs
13:41:58 <lambdabot>   [3,5]
13:42:07 <benmachine> djahandarie: there, three different ways
13:42:12 <benmachine> of course they are all catMaybes but still
13:42:27 <benmachine> (I think catMaybes is probably actually the last one, due to fusion)
13:42:39 <benmachine> (that would be my guess anyway)
13:43:06 <djahandarie> It isn't written that way.
13:43:29 <djahandarie> I'm not sure how the list comprehension desugars and if that happens before rewrites though
13:43:52 * benmachine shrugs
13:51:27 <Taslem> Is there a better way of doing this? http://pastebin.com/exT8eB8M
13:52:12 <benmachine> Taslem: almost certainly
13:52:17 <mauke> == Nothing looks bad
13:52:22 <Taslem> Yeah, I know.
13:52:22 <benmachine> I say almost because I'm not exactly sure what you're doing
13:52:30 <mauke> that kinda looks like sequence
13:52:37 <benmachine> that does look like sequence, yes
13:52:45 <benmachine> but would you like to know how to write it anyway?
13:53:43 <benmachine> Taslem: as a general rule, avoid fromJust by using pattern-matching
13:53:46 <dafis> Taslem: case foo of { Nothing -> Nothing; Just bar -> Just (a:bar) }
13:53:53 <benmachine> right
13:54:12 <dafis> but of course, just write sequence and be done with it
13:54:12 <benmachine> Taslem: this makes it much clearer that all the cases have been covered and nothing has been covered twice
13:54:27 <Taslem> I see.
13:54:31 <ion> ghci> let xs = [Just 3, Nothing, Just 5]; for init cond iter f = do { ref <- newIORef init; fix $ \loop -> do { i <- readIORef ref; when (cond i) $ do { f i; modifyIORef ref iter; loop } } } in do ysRef <- newIORef []; for 0 (< length xs) (+1) (\i -> modifyIORef ysRef $ maybe id (:) (xs !! i)); readIORef ysRef
13:54:36 <dafis> and it doesn't introduce a spurious Eq constraint
13:54:38 <ion> [5,3]
13:54:40 <ion> whoops, wrong order :-D
13:54:42 <Taslem> But, that doesn't appear to be what I'm looking for.
13:55:00 <benmachine> ion: aaaaagh.
13:55:09 <benmachine> Taslem: what are you looking for exactly?
13:55:34 <benmachine> Taslem: as another tip, you can use guards instead of if in your function definitions, it's often clearer
13:55:35 <Taslem> It was the definition of sequence, so I got it.  
13:56:22 <ion> Fixed the incorrect order! reverse <$> readIORef ysRef
13:57:15 <ion> Side note: people actually do that in Erlang. That is, build lists in wrong order and reverse them in the end. ;-)
13:57:56 <benmachine> ion: people do it in haskell sometimes, don't ask me why >_>
13:58:43 <Twey> Taslem: Looks like a job for sequences
13:58:44 <Twey> Er
13:58:47 <ddarius> benmachine: Sometimes it's the right thing to do.  Many times exploiting laziness is instead the right thing to do in those cases.
13:58:47 <Twey> For Applicative, even
13:59:13 <Taslem> No, I don't think so.
13:59:27 <Twey> Taslem: http://pastebin.com/U5XbHa2r
14:00:47 * hackagebot testpack 2.1.0 - Test Utililty Pack for HUnit and QuickCheck  http://hackage.haskell.org/package/testpack-2.1.0 (JohnGoerzen)
14:02:35 <benmachine> Twey: surely you mean pure [] :P
14:02:41 <Twey> Haha
14:02:46 <Twey> Yeah, why not
14:02:49 <benmachine> bwim, surely you mean sequenceA >_>
14:02:57 <ddarius> benmachine: Surely you mean pure mzero.
14:02:59 <Twey> Ooh, neat
14:03:19 <Twey> Not much point in pure mzero given that it has to be a list, is there?
14:03:24 <Twey> :t sequenceA
14:03:25 <lambdabot> Not in scope: `sequenceA'
14:03:28 <Twey> :<
14:03:31 <benmachine> :t Data.Traversable.sequenceA
14:03:31 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
14:03:34 <ddarius> @hoogle sequenceA
14:03:34 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
14:03:34 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
14:03:35 <benmachine> :>
14:03:39 <Twey> Oh, there it is.
14:09:12 <argiopeweb> 'Evening folks. I'm coming from the C sockets world where casting is king, and I'm wondering how I'm going to send non-character data in Haskell. Try as I might, I can't seem to find any reference to it in the literature.  Any tips?
14:09:31 <benmachine> argiopeweb: serialise it first
14:09:37 <dmwit> ?hackage binary
14:09:37 <lambdabot> http://hackage.haskell.org/package/binary
14:09:39 <dmwit> argiopeweb: ?
14:09:40 <benmachine> e.g. the binary package, or cereal
14:09:44 <benmachine> @hackage cereal
14:09:44 <lambdabot> http://hackage.haskell.org/package/cereal
14:10:04 <mauke> argiopeweb: all you send is bytes
14:10:22 * dafis always sends bits
14:10:26 <dmwit> la, la la la la... all you send is bytes, la, la la la la
14:10:32 * dmwit channels the Beatles
14:10:53 <argiopeweb> hehe...
14:10:58 * benmachine sends carrier pigeons
14:11:16 <argiopeweb> Well, that should be plenty to answer any questions I have. Thanks. :)
14:14:14 * ddarius bytes carrier pigeons.
14:14:38 <dafis> ddarius: related to Ozzy Osbourne?
14:14:39 <hpc> om nom nom
14:14:54 * hpc bytes cookies and chips
14:15:06 <benmachine> microchips?
14:15:11 * ddarius is reminded that he has devil's food donuts.
14:15:13 <monochrom> in soviet russia, bytes carry pigeons
14:15:21 <acowley> Once, back in the 90s, I sent half a bit
14:15:25 * hpc places chips on breadboard, makes sandwich
14:15:35 <hpc> acowley: :D
14:15:48 <benmachine> both british and american chips actually work in sandwiches
14:15:51 <benmachine> I think
14:15:57 <ddarius> acowley: Did you send it to Shannon?
14:16:02 <hpc> benmachine: both work as sides
14:16:15 <acowley> ddarius: and he knew what to do with it
14:16:17 <benmachine> hpc: sides and fillings!
14:16:22 <benmachine> well, not both that is excessive
14:16:34 <hpc> too much of a good thing is never enough!
14:16:50 <ddarius> @google fat sandwiches new jersey
14:16:50 <lambdabot> http://en.wikipedia.org/wiki/Grease_Trucks
14:16:51 <lambdabot> Title: Grease Trucks - Wikipedia, the free encyclopedia
14:16:54 <ddarius> Hmm
14:19:55 * ddarius ate there pre-naming controversy.
14:20:49 <acowley> New Jersey had a naming controversy?
14:20:58 <acowley> I would have thought I'd notice
14:22:02 <acowley> We were going to call it New Guernsey
14:22:14 <acowley> I guess some people did get pretty heated
14:24:05 <benmachine> I have a cousin who lives on old jersey
14:24:14 <benmachine> it is so tiny
14:24:21 <acowley> How are the sandwiches?
14:24:59 <ddarius> Pretty much exactly what you'd expect.
14:25:50 <accel> I admit the following is Off Topic. When I say "let 1 \leq i \leq n", it means "i is any number between 1 & n". How do I concisely phrase, in LaTeX, "let i be a uniform random variable taking on integral values between 1 & n " ?
14:27:13 <benmachine> well, the notation I'm used to is i ~ Unif{1 .. n} approximately
14:27:21 <accel> I like
14:27:24 <acowley> Make a subsequent use of a function on Integers and let the reader unify
14:27:25 <accel> benmachine++
14:27:28 <benmachine> in latex you'd have some \mathrm and \dots
14:27:38 <benmachine> accel: :P
14:27:40 <benmachine> er
14:27:41 <benmachine> acowley: :P
14:28:23 <monochrom> hahaha
14:31:58 <argiopeweb> It seems that the only difference between Cereal and Binary is the interface and the fact that one returns strict bytestrings and the other lazy bytestrings. Other than that, they both serialize to big endian by default. Therefore, it would seem that the choice would come down to interface preference and possible need for lazy vs. strict. Have I missed anything, or am I roughly on track?
14:32:32 <benmachine> argiopeweb: that sounds about right
14:32:36 <mikeg> argiopeweb: http://blog.johantibell.com/2011/01/merging-binary-and-cereal.html
14:33:55 <Philonous> dolio: Your *0 variants seem to just assume an empty context when the context stack is empty, spj's implementation chooses to crash in this case. I wonder what the rationale for both designs is. Doesn't your variant allow for subtle bugs? (I mean, it's better to crash than to do something unexpected, isn't it?)
14:34:23 <dolio> It's been a long time since I wrote those.
14:35:12 <Philonous> dolio: Never mind, then. ;)
14:35:16 <dolio> I don't know why you'd want to crash, though.
14:35:25 <argiopeweb> mikeg: benmachine: Thanks. :)
14:35:49 <Philonous> dolio: Because escaping the enclosing delimiter seems like a bug
14:35:56 * hackagebot heist-aeson 0.3 - Use JSON directly from Heist templates.  http://hackage.haskell.org/package/heist-aeson-0.3 (DavidHimmelstrup)
14:37:25 <dolio> Effectively, what I did probably means that 'runWhatever' is the ultimate delimiter.
14:38:31 <dolio> Same as it's technically a delimiter even for callCC.
14:38:37 <Philonous> dolio: Yes, that's what it boils down to
14:47:59 * hackagebot hoopl 3.8.7.1 - A library to support dataflow analysis and optimization  http://hackage.haskell.org/package/hoopl-3.8.7.1 (NormanRamsey)
14:53:34 <hpc> @quote tarpit
14:53:34 <lambdabot> monochrom says: yeah, get out of Turing tarpit, provable termination, only to get into Gödel tarpit
15:04:17 <McManiaC> hmmm how can I "retry" only one section of a function in STM?
15:05:09 <McManiaC> http://npaste.de/01U/ <- I have this code, and I want to get those retries working
15:09:59 <Lemmih> McManiaC: What do you mean?
15:10:09 <augur> is it just me or is detexify pretty much useless?
15:10:27 <acowley> augur: it's just you
15:10:31 <augur> :|
15:10:40 <acowley> McManiaC: I don't really understand what you want to retry when
15:10:54 <acowley> augur: it's almost always worked great for me
15:11:05 <augur> is there a single symbol version of ++ in latex
15:11:14 <augur> ++ in mathmode is ugly, and if theres a predef i'd prefer it
15:11:30 <acowley> Ah, so you want whatever lhs2tex uses
15:11:56 <augur> lhs2tex?
15:12:13 <augur> ahh
15:12:17 <augur> literate haskell stuff
15:12:28 <sipa> .lhs is latex with embedded haskell, lhs2TeX extracts and formats the tex
15:12:38 <acowley> \newcommand{\plus}{\mathbin{+\!\!\!+}}
15:12:42 <augur> well, i dont want lhs as such, just some of the symbols since they're nice
15:12:44 <acowley> that's how they do it
15:12:46 <augur> is it
15:12:47 <augur> hmm ok
15:13:28 <acowley> I recently wrote my first paper with lhs2tex and was really impressed by it. My only issue was emacs periodically crashing.
15:13:34 <acowley> Which actually was a rather large issue
15:13:45 <acowley> but lhs2tex itself is just fantastic
15:13:50 * sipa is currently writing his first lhs2tex paper :)
15:14:09 <hpc> acowley: obligatory "don't use emacs" ;)
15:14:10 <augur> i'd write in lhs2tex if i were writing actual haskell :p
15:14:14 <acowley> sipa: The one thing I don't really know how to do well is inline code
15:14:34 * hpc actually had vim crash on him the other day, for the first time
15:14:35 <acowley> sipa: The code is just italicized so doesn't stand out very well, and the spacing can get funny
15:15:14 <acowley> hpc: but I need to work with text
15:15:22 <acowley> hpc: pretty sure emacs is the only way to do that
15:15:27 <augur> i suppose i could write this in some sort of literate agda code
15:15:34 <acowley> literate agda is great, too!
15:15:43 <augur> since its more proof-oriented
15:15:57 <acowley> I wrote a report for a class in that and loved type checking my paper
15:15:57 <augur> i'd have to learn how to use agda! oh what fun!
15:16:01 <acowley> Oh
15:16:06 <augur> i know a bit of agda
15:16:12 <augur> this might give me a reason to know more!
15:16:13 <acowley> well that would be rather crazy
15:17:02 <sipa> acowley: yeah, agree
15:17:30 * sipa loves the term "let's see if my paper still compiles" though :)
15:18:17 <acowley> literate agda was my best experience with that because you're writing about proofs but feel like someone's got your back with regard to correctness
15:19:01 <hpc> do literate agda files end with .lagda? that would be most unfortunate :P
15:19:13 <acowley> I believe so
15:19:29 <sipa> why unfortunate?
15:19:41 <hpc> it sounds silly
15:19:45 <augur> acowley: whats the \! do
15:19:56 <acowley> augur: negative horizontal space
15:19:57 <sipa> i suppose move left
15:20:02 <augur> i see i see!
15:20:05 <augur> and mathbin?
15:20:48 <sipa> The \mathbin puts the right spacing around the symbol for a binary operator
15:20:53 <sipa> (http://stackoverflow.com/questions/330010/how-do-i-show-a-caret-in-math-mode-in-latex)
15:22:27 <augur> hmm
15:25:00 <augur> do you think i should use newcommand to define semantically named operator symbols?
15:25:03 <augur> probably
15:25:08 <augur> is there a good latex style guide?
15:25:21 <McManiaC> acowley: ok, basicly I want to wait until all TMVars were filled with "()", and I made a STM "loop" which tries to call "takeTMVar" on the current TMVar, if that fails it tries the next etc
15:25:42 <acowley> augur: Not that I know of, and such a thing would probably vary a lot due to the various backgrounds of latex users
15:25:52 <McManiaC> on a successfull take it should remove the TMVar from the list and let the whole loop retry (and eventually quit if the list is empty)
15:26:03 <acowley> augur: I think newcommands are good style. I suck at latex and don't do it enough, but I like using other people's code that does!
15:26:07 <McManiaC> acowley: so I came up with this loop, including an example below: http://npaste.de/01V/
15:26:11 <McManiaC> acowley: any ideas?
15:26:18 <Lemmih> McManiaC: Keep in mind that it is atomic. The naive solution should be the right one.
15:26:41 <McManiaC> (it still doesn't quit after both threads finish)
15:26:56 <acowley> why do you put the list [m1,m2] in a TVar?
15:26:58 <int80_h> Lemmih! Hiya :)
15:27:03 <Eelis> taruti: why does System.Fuse use its own FileStat type instead of the existing FileStatus type from System.Posix?
15:27:08 <Lemmih> int80_h: Hey!
15:27:15 <McManiaC> acowley: to be able to modify it from other threads (add new threads)
15:27:26 <McManiaC> (add new TMVars)
15:27:36 <McManiaC> etc
15:27:43 <Lemmih> McManiaC: 'waitForTermination' will always retry unless 'tms' is null.
15:28:05 <acowley> ah, that's a bit awkward then, isn't it? It means you can return from waitForTermination just before another thread gets added
15:28:28 <McManiaC> Lemmih: but after the last element gets removed it shouldnt retry again?
15:28:47 <Lemmih> McManiaC: Keep in mind that other threads can't see the changes you make to the TMVars until your transaction completes.
15:29:04 <McManiaC> hmm
15:29:13 <Lemmih> McManiaC: 'retry' will undo all the modifications.
15:29:14 <McManiaC> thought so
15:29:14 <acowley> McManiaC: what imporst do I need for this code?
15:29:14 <McManiaC> damn
15:29:15 <McManiaC> ^^
15:29:22 <McManiaC> Lemmih: oh, thats new… ok
15:29:24 <McManiaC> thanks
15:29:48 <Lemmih> int80_h: How's it hanging?
15:29:56 <McManiaC> acowley: Control.Monad.STM and probably C.M.Trans for liftIO
15:30:07 <McManiaC> and C.Concurrent for that fork stuff
15:31:07 <Lemmih> McManiaC: How about: forM_ takeTMVar =<< readTVar tv ?
15:31:26 <Lemmih> McManiaC: That should be both necessary and sufficient.
15:31:41 <McManiaC> hmm
15:31:51 <Lemmih> Err, mapM_ takeTMVar =<< readTVar tv
15:33:53 <acowley> Here's what I did
15:33:54 <acowley> wait2 :: MonadIO m => TVar [TMVar ()] -> m ()
15:33:55 <acowley> wait2 = liftIO . atomically . (mapM_ takeTMVar <=< readTVar)
15:33:57 <acowley>  
15:34:11 <acowley> which is basically what Lemmih just said
15:34:45 <McManiaC> and it works? :>
15:34:57 <acowley> in so far as everything finishes? yes
15:35:14 <acowley> I don't know if it has the retry behavior you want, though
15:35:19 <McManiaC> hm
15:36:47 <acowley> I get the impression you're trying to do something more imperative
15:37:30 <acowley> If you are saying, "While waiting for all threads to finish, if another is added, wait for it, too."
15:37:39 <acowley> Then you might want to use a Chan or TChan
15:38:01 <acowley> something that lets you check whether it's empty
15:38:37 <McManiaC> uh uh
15:38:48 <McManiaC> it even seems to work, that mapM_ implementation
15:39:12 <acowley> Yes, STM applies a large hammer to the goal of "works"
15:39:47 <McManiaC> sweet :)
15:39:56 * benmachine tries not to look like a nail
15:40:00 <McManiaC> thx acowley, your solution is now in my project :D
15:40:44 <McManiaC> http://npaste.de/01W/ :)
15:41:16 <augur> byorgey: ping
15:45:57 <monochrom> atomically (unsafeIOToSTM (hit benmachine) >> when True retry)
15:46:09 <benmachine> :<
15:46:26 <monochrom> @slam monochrom
15:46:26 * lambdabot activates her slap-o-matic...
15:47:13 <monochrom> would be cool to add that to lambdabot's @slap techniques
15:48:34 <monochrom> wait, "when True" is redundant!
15:49:30 <benmachine> :O
15:50:13 <McManiaC> is there a way to catch exceptions in a MonadIO instead of IO?
15:50:40 <Mathnerd314> :t unsafeIOToSTM
15:50:41 <lambdabot> Not in scope: `unsafeIOToSTM'
15:50:54 <monochrom> is in GHC.Conc
15:51:18 * hackagebot free-theorems-seq-webui 1.0.0.2 - Taming Selective Strictness  http://hackage.haskell.org/package/free-theorems-seq-webui-1.0.0.2 (DanielSeidel)
15:52:18 <monochrom> McManiaC: MonadIO not enough. Look for http://hackage.haskell.org/package/monad-peel which does it very powerfully.
15:52:46 <Mathnerd314> :t GHC.Conc.unsafeIOToSTM
15:52:47 <lambdabot> forall a. IO a -> GHC.Conc.STM a
15:54:19 <McManiaC> monochrom: thx a lot
15:58:50 <acowley> Every time I talk myself into writing something in C++, I end up regretting it massively
16:00:16 <tromp__> at least i get paid to write c++
16:01:35 <acowley> Well, that was a depressing few hours of failing-to-code. Heading home now.
16:03:22 <parcs> @src id
16:03:22 <lambdabot> id x = x
16:03:48 <djahandarie> @. pl src id
16:03:49 <lambdabot> (line 1, column 1):
16:03:49 <lambdabot> unexpected end of input
16:03:49 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
16:06:08 <parcs> :t lazy
16:06:08 <lambdabot> Not in scope: `lazy'
16:07:15 <augur> are there any constrained techniques for enumerating lambda terms which happen to have an interesting result?
16:07:52 <augur> like, if you limit yourself to constructors as the only "functions", etc.?
16:08:18 <augur> well, the only non-lambda-defined functions, i mean
16:08:27 <augur> i suppose that does nothing, in the end
16:15:14 <bloop> Will someone link me to a good intro for Haskell? Everything I read seems to start in the middle...
16:15:21 <hpc> @where lyah
16:15:21 <lambdabot> http://www.learnyouahaskell.com/
16:15:23 <hpc> bloop: ^
16:15:27 <hpc> best tutorial
16:15:35 <bloop> thanks
16:17:21 <Fufufu> Hello.
16:17:42 <Fufufu> I'm just starting with Haskell.
16:17:52 <bloop> same :)
16:18:12 <adorablepuppy> Is there something you need help with?
16:18:30 <Fufufu> Yeah, I'm pasting the code.
16:18:41 <Fufufu> http://pastebin.com/WFjQwRyE
16:18:42 <Fufufu> : )
16:18:49 <Fufufu> Why doesn't this work?
16:19:22 * hackagebot base-unicode-symbols 0.2.1.3 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/base-unicode-symbols-0.2.1.3 (RoelVanDijk)
16:19:48 <sipa> Fufufu: function application has the highest priority of all operators
16:19:54 <sipa> so
16:19:55 <sipa> any (<=0) x:xs
16:19:58 <sipa> is the same as
16:20:01 <sipa> (any (<=0) x):xs
16:20:23 <Fufufu> I have no experience with functional language.
16:20:40 <hpc> Fufufu: also, to be nitpicky, tabs aren't recommended in haskell, due to insane defaults
16:20:41 <sipa> doesn't matter if you're willing to learn :)
16:20:47 <bloop> although I understand lambda calculus very well and have used lots of dynamically typed semi-functional languages like Lisp and Lua, Haskell is very different... How much of it is syntax and how much semantics?
16:21:01 <sipa> bloop: very little is syntax
16:21:11 <Fufufu> How do I make that work, then?
16:21:13 <hpc> bloop: you have quite the head start! :D
16:21:28 <Fufufu> I want it to return [] if any element is <= 0 : [
16:21:43 <sipa> Fufufu: i told you the problem is operator precedency
16:21:50 <hpc> Fufufu: f (x:xs) | any (<=0) (x:xs) = []
16:22:11 <sipa> the solution is indeed to put parenthesis around it
16:22:14 <Fufufu> Hpc: That's what I did.
16:22:23 <Fufufu> Ah, okay.
16:22:24 <hpc> Fufufu: note the parenthesis
16:22:28 <Fufufu> Thank you.
16:22:30 <hpc> :D
16:22:49 <Fufufu> Another question: How do I create a function in ghci?
16:23:13 <adorablepuppy> let f x y = x + y
16:23:18 <Fufufu> Do I have to use "let"?
16:23:24 <hpc> Fufufu: yes, in ghci
16:23:27 <Fufufu> Ah, okay.
16:23:32 <Fufufu> Thanks.
16:23:41 <bloop> so do Haskell functions "capture" up-variables the way Lisp does? it seems like they would have to in order for partial application to work...
16:24:08 <Fufufu> But how do I declare its type?
16:24:29 <hpc> Fufufu: let f :: Int -> Int -> Int; f x y = f + y
16:24:38 <sipa> typically, you let the compiler work that out for you though
16:24:38 <hpc> Fufufu: semicolon where the newline would be
16:24:45 <Fufufu> Ah, amazing. Thanks a lot.
16:25:13 <hpc> Fufufu: in general, it's more comfortable to interact with a file
16:25:33 <Fufufu> Probably, but I'm testing stuff.
16:25:37 <hpc> Fufufu: ie, make foo.hs, then run ghci foo.hs in another terminal; when you edit foo.hs, type ":r" in ghci to reload it
16:25:49 <Fufufu> Ah, that's great.
16:25:49 <hpc> (for future reference)
16:26:08 <Fufufu> There's so many new concepts to wrap my head around.
16:26:19 <Fufufu> It's fascinating.
16:26:33 <Fufufu> : )
16:27:40 <hpc> Fufufu: it never stops, either :D
16:28:09 <Fufufu> Still doesn't work: Couldn't match expected type 'Bool' against inferred type '[Bool]'.
16:28:10 <Fufufu> : [
16:29:13 <hpc> Fufufu: did you add parenthesis?
16:29:27 <adorablepuppy> There are many image processing libraries, is there one anyone particularly recommends? Basically I want to read a bitmap's pixels into a list, then process them somehow. Thinking about it, it would be easiest to process if I could get a list of [ x, y, (A, R, G, B)]
16:29:57 <adorablepuppy> err, I mean ( x, y, a, r, g, b) perhaps.
16:29:59 <Fufufu> Yes.
16:30:06 <Fufufu> Yes.
16:30:10 <Fufufu> (Sorry).
16:30:16 <hpc> :P
16:31:08 <Fufufu> I've got to go. I'll certainly be back.
16:31:12 <Fufufu> Thank you.
16:31:14 <Fufufu> : )
16:36:41 <adorablepuppy> I'll say that I'm not trying to display them. I'm more parsing them for input than anything
16:38:13 <bloop> I guess what's confusing me is that definitions look an awful lot like statements. In Lua, you might define a function as "local Mockingbird = function(f) return f(f) end" but that's a statement with a side effect of assigning a function to a variable. What exactly is going on in Haskell? Is it all just global type definitions?
16:39:00 <adorablepuppy> brb sorry
16:39:45 <shachaf> bloop: Well, there's no such thing as statements, or assignments.
16:40:31 <shachaf> bloop: There's binding of names to values, which can be "global" or local to a particular scope.
16:41:01 <bloop> shachaf: and they can't be rebound? is that what makes it not a side effect?
16:41:27 <shachaf> bloop: Well, they can be rebound, but that's equivalent to just using a new name.
16:42:01 <shachaf> bloop: By the way, that mockingbird combinator won't type-check in Haskell. :-)
16:42:50 <bloop> shachaf: but could you bind a name to one thing, and then to something else? I'm guessing not.
16:43:12 <shachaf> bloop: You can, but not "in a loop" or anything like that.
16:43:21 <jmcarthur> > let x = 4 in let x = True in x
16:43:21 <lambdabot>   True
16:43:28 <shachaf> (Well, unless you count recursion as being "like a loop". Which it is.)
16:43:43 <bloop> ok so you can rebind a name if you use a new scope, and it's lexical?
16:44:04 <djahandarie> Shadowing is generally a bad idea anyways
16:45:11 <shachaf> It might be simpler if you think of "let x = y in ..." as (\x -> ...) y, ignoring things like typing issues and recursion.
16:45:19 <napping> but yes, scoping is lexical and shadowing is permitted - but let is always recursive
16:45:49 <bloop> right. it's like in Lisp where a new scope is just a macro over an anonymous function call?
16:45:59 <jmcarthur> well
16:46:03 <napping> so let x = "outer" in let x = "inner "++x in x makes the infinite string "inner inner inner ..."
16:46:06 <bloop> effectively if not actually
16:46:07 <jmcarthur> you can think of it that was for the time being
16:46:12 <napping> just like you had written let x = "inner "++x in x
16:46:21 <jmcarthur> it's not a macro though
16:46:23 <dolio> It's not really like that, and there are important differences.
16:46:27 <jmcarthur> let introduces sharing, etc.
16:46:50 <jmcarthur> *that way
16:48:01 <Kaidelong> does anyone here have experience with computational fluid dynamics?
16:48:36 <Kaidelong> is working with it a reasonable personal project on a 4-core laptop or is it too difficult (either to program or to run) for me to spend personal time on?
16:49:08 <Kaidelong> I was thinking of trying to test airfoils generated by a genetic algorithm
16:49:13 * applicative has spilled beer on his laptop
16:49:40 <Kaidelong> and then realized that perhaps that is something that needs more computing power and more programmers than just me
16:50:15 <ddarius> jmcarthur: So does a lambda.  In fact, a let can (superficially) have less sharing than a lambda.
16:50:46 <Kaidelong> you can't just reduce lets to lambda expressions?
16:50:50 <ddarius> No.
16:51:08 <Kaidelong> can you do so in most MLs?
16:51:13 <ddarius> Kaidelong: You can almost certainly do something reason with regards to computational fluid dynamics.
16:51:20 <ddarius> Kaidelong: No.
16:51:25 <bloop> Kaidelong: you are probably the best judge of how much you can get done... I say if it's just for fun then jump in!
16:51:55 <Kaidelong> Okay great!
16:52:00 <Kaidelong> Any ideas where I should start?
16:52:10 <Kaidelong> spent a couple of hours looking at the equations
16:52:25 <napping> If it's just for fun, you could also do a 2D version of flow over an airfoil crossection
16:52:27 <ddarius> Kaidelong: It depends on what exactly you need.
16:53:00 <Kaidelong> 2D version would work just fine, the main thing I want to end up doing is calculate drag
16:53:16 <Kaidelong> although I'd need some other parameter involved so that the algorithm doesn't just converge on a null airfoil
16:53:18 <jmcarthur> ddarius: i was contrasting with a macro
16:53:26 <Kaidelong> maximizing lift too I guess
16:53:28 <ddarius> jmcarthur: Ah.
16:59:29 <mm_freak> on a 64 bit system, does GHC produce 64 bit binaries?
16:59:35 <hpc> mm_freak: yes
16:59:42 <mm_freak> ok, thanks
16:59:53 <hpc> i can confirm this from a lot of my stuff breaking when i built it on this laptop
17:00:01 * Kaidelong wonders why "let binding = exp1 in exp2" can't be replaced by "(\binding -> exp2) exp1"
17:00:16 <Kaidelong> in general
17:00:53 <aristid> Kaidelong: recursion?
17:01:16 <Kaidelong> ah sure, that gets in there
17:01:24 <aristid> y combinator also does not work in haskell, and fix uses explicit recursion
17:01:27 <Kaidelong> is that part of the rationale behind "let rec" in some of the MLs?
17:01:31 <azaq23> > let x = 0 : x in take 10 $ x
17:01:32 <lambdabot>   [0,0,0,0,0,0,0,0,0,0]
17:01:41 <jmcarthur> @src fix
17:01:41 <lambdabot> fix f = let x = f x in x
17:01:45 <ddarius> Recursion was not the problem I was referring to.
17:01:59 <hpc> jmcarthur: fix f = f (fix f) :P
17:02:12 * hpc not helping
17:03:02 <dolio> > let f x = x in (f 5, f 'c')
17:03:03 <lambdabot>   (5,'c')
17:03:20 <dolio> > (\f -> (f 5, f 'c')) (\x -> x)
17:03:21 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
17:03:21 <lambdabot>    arising from the literal `5...
17:03:22 <hpc> dolio: ooh, neat
17:05:20 <azaq23> > (\(f :: forall t. t -> t) -> (f 10, f 'c')) (\x -> x)
17:05:21 <lambdabot>   (10,'c')
17:05:39 <lutza> hello im trying to use parsec library, does anyone know why this line ... parse_line = many (noneOf "\n") ... in my .hs file gives me "No instance for (Text.Parsec.Prim.Stream s m Char)" error while loading file in ghci ?
17:05:56 <rdnflaneur> ?wiki Monad
17:05:56 <lambdabot> http://www.haskell.org/haskellwiki/Monad
17:05:58 <hpc> :t noneOf
17:05:59 <lambdabot> Not in scope: `noneOf'
17:06:12 <monochrom> monomorphism restriction is why. add a type signature.
17:07:14 <Kaidelong> or turn off the monomorphism restriction
17:07:16 <lutza> if i invoke this ...  parse (many (noneOf "\n")) "" "asdasd\n asdasd\n" ... in ghci it works as expected
17:08:09 <lutza> im afraid i dont know what monomophism is or how to turn it off ;/
17:08:28 <monochrom> perhaps parse_line :: Parser String
17:08:46 <Kaidelong> lutza: monomorphic types have no free variables in the type
17:09:02 <Kaidelong> polymorphic types may have one or many
17:09:27 <lutza> Kaidelong: worked, thanks a lot ! 
17:09:46 <Kaidelong> err didn't monochrom suggest that?
17:09:54 <shachaf> Kaidelong: If they have just one, they'd be monopolymorphic, I suppose?
17:10:00 <Kaidelong> anyway Parser String is a monomorphic type
17:10:27 <Kaidelong> m String is a polymorphic type
17:10:48 <Kaidelong> as is (Monad m) => m String
17:10:48 <Kaidelong> the context just constraints the polymorphism, it doesn't eliminate it
17:11:01 <co_dh_> greeting . In lattice theory , is an ideal the same as sublattice?
17:11:02 <Kaidelong> constrains
17:11:14 <monochrom> not the same
17:11:49 <napping> dolio: that sort of code should work fine with MLF type checking
17:12:32 <dolio> It requires higher-rank types.
17:12:54 <applicative> lutza:  a type signature is better, but inside ghci you type :set -XNoMonomorphismRestriction, or at the top of your module you type {-#LANGUAGE NoMonomorphismRestriction#-}
17:13:38 <Maxdamantus> Are things like that described in the report?
17:13:39 <bloop> wait someone said you can't make a Y-combinator in Haskell. Do you mean a fixed-point combinator or an anonymous recursion combinator? (or can you make either of them?)
17:14:15 <monochrom> example: the main lattice is {False, True} with False<True. a sublattice is {True}. this is not an ideal.
17:14:24 <pumpkin> bloop: you can't write the usual untyped lambda calculus y combinato
17:14:25 <pumpkin> r
17:14:26 <applicative> > fix (0:) -- already discussed, no
17:14:27 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
17:14:34 <bloop> I know that in C# for instance the typing system goes in an infinite loop if you try to define generic combinators
17:14:35 <pumpkin> but sure, we can have fixed point combinators
17:14:37 <pumpkin> :t fix
17:14:37 <lambdabot> forall a. (a -> a) -> a
17:16:26 <napping> you can probably write a fixpoint combinator by wrapping with something like newtype U = C (U -> U)
17:16:46 <ddarius> You definitely can.
17:16:46 <pumpkin> yeah
17:16:53 <monochrom> you are right that (\x -> x x) cannot be typed in haskell, similarly the usual expressions for Y
17:16:59 <hpc> @src Mu
17:16:59 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
17:17:03 <hpc> oh look, fixed point
17:17:06 <pumpkin> http://r6.ca/blog/20060919T084800Z.html
17:17:16 <pumpkin> a bit of wrapping, but not too hard to see the original
17:17:18 <monochrom> but in haskell you can just write let x =  f x in x.
17:17:36 <azaq23> one can unsafeCoerce \x -> x x though
17:17:53 <hpc> azaq23: aaa! burn it with fire
17:18:01 <monochrom> notice how nicely you can define recursion if the language provides... recursion!
17:18:28 <hpc> monochrom: it's either that or loops
17:18:31 <monochrom> To define recursion, you must first define... recursion!
17:18:34 <hpc> or goto
17:18:48 <bloop> or continuations
17:19:04 <ddarius> monochrom: Dana Scott would be rolling over in his grave if he were dead.
17:19:17 <pumpkin> instead, he's rolling over in his bed?
17:20:36 <sipa> @google recursion
17:20:37 <lambdabot> http://en.wikipedia.org/wiki/Recursion
17:20:37 <lambdabot> Title: Recursion - Wikipedia, the free encyclopedia
17:20:41 <sipa> bleh
17:20:44 <monochrom> Dana Scott computes limits.
17:21:17 <napping> dolio: MLF handles higher rank types fine (but can require annotations on function arguments). Daan Leijen and Andres Löh worked out a way to handle qualified types (type classes): http://people.cs.uu.nl/andres/qmlf-str.pdf
17:21:26 <sipa> Newton would be rolling over in his grave if his laws didn't hold.
17:21:48 <ddarius> His laws don't hold.
17:21:59 <sipa> You win.
17:22:08 <hpc> we should wrap him in copper wire and replace his tombstone with a magnet
17:22:12 <hpc> free electricity for everyone!
17:22:21 <monochrom> gravitational waves cause Newton to roll.
17:22:27 <dolio> It doesn't matter, because Haskell doesn't have MLF type checking.
17:23:36 <Kaidelong> http://uncyclopedia.wikia.com/wiki/Recursion
17:23:40 <Kaidelong> much better article
17:24:38 <monochrom> hahaha
17:24:48 <djahandarie> I like this article more: http://www.google.com/search?q=recursion
17:25:02 <monochrom> hahahahaha
17:34:43 <vr38dett> Hi all! Is this a Haskell beginner's channel or is it for advanced users?
17:34:50 <osoleve> both!
17:35:03 <osoleve> (at least, they let me stick around)
17:35:20 <vr38dett> good, couple of short questions: what's the English translation of these symbols: '<-' and '::'?
17:35:36 <c_wraith> "bind" and "has type"
17:36:14 <c_wraith> sometimes when reading code, you might pronounce <- as gets, as well
17:36:25 <bloop> what's the difference between <- and `elem` ?
17:36:25 <vr38dett> In a list comprehension, <- successively binds each element of a list to the name x?
17:36:34 <vr38dett> (if x is the name/reference, that is)
17:36:45 <c_wraith> vr38dett: yes, it does
17:36:58 <c_wraith> bloop: they're entirely different.
17:37:24 <vr38dett> cool, and '|' can be read as 'such that'?
17:37:43 <c_wraith> that's as good a reading as I've heard for that.
17:38:13 <vr38dett> useful for us newbies to be able to translate it as we're reading an expression ;)
17:38:14 <bloop> oh i see I was reading x <- y as x `elem` y... the tutorial never really talks about <- explicitly which explains why both of us are confused
17:38:34 <c_wraith> YOu could also read it as "where", but of course that's ambiguous with the keyword
17:38:52 <bloop> | means "such that" in math too so that's easy to remember
17:39:08 <c_wraith> bloop: x `f` y = f x y...  it's just a syntax for using a function as an infix operator
17:39:16 <vr38dett> I think I saw '=>' also, that is 'implies', right?
17:39:26 <geheimdienst> > 5 `elem` [1,2,3]
17:39:27 <lambdabot>   False
17:39:32 <geheimdienst> > 5 `elem` [1..7]
17:39:32 <lambdabot>   True
17:39:42 <geheimdienst> > elem 5 [1,2,3]
17:39:43 <lambdabot>   False
17:39:45 <djahandarie> vr38dett, no.
17:39:53 <c_wraith> vr38dett: You *can* read it that way, if you consider a context to be a set of predicates on type variables
17:39:54 <bloop> c_wraith: I realize that, but <- seemed to be just an infix elem without explanation, especially since the way it's explained with a math expression, it took the place of "element of"
17:40:05 <parcs> > 5 `5` 5
17:40:06 <lambdabot>   <no location info>: parse error on input `5'
17:40:13 <djahandarie> vr38dett, -> is much closer to "implies" than =>
17:41:18 <c_wraith> vr38dett: but applying math terminology to => and -> requires a good understanding of the Curry-Howard isomorphism
17:41:35 <djahandarie> Which isn't an isomorphism.
17:41:40 <bloop> is there a big difference between [ c | c <- st, c `elem` ['A'..'Z']]  and [ c | c <- ['A'..'Z'], c `elem` st]  ?
17:41:48 <vr38dett> ahh, let me read up on that in wikipedia, thanks!
17:42:21 <djahandarie> vr38dett, a good understanding of Curry-Howard requires a good understanding of Haskell or a Haskell-like language first, imo.
17:42:52 <c_wraith> bloop: they might differ in output order, but the contents will be the same
17:42:58 <djahandarie> You could try learning it the other way around, but that will be a pain and you won't get much Haskell-related enlightnment from it. Maybe it'd be interesting to learn things that way for languages like Agda though.
17:43:15 <McManiaC> whats the haddock markup to link to a function from a different module? "Foo.Bar#moep" or something like that?
17:43:43 <bloop> c_wraith: Is there also a performance difference? say, for instance, that st was gigantic?
17:44:10 <c_wraith> bloop: Oh, there will also be difference in length of output if st contains duplicates
17:44:34 <bloop> c-wraith: Aha! OK i guess my confusion stems from thinking about it in terms of sets rather than lists.
17:45:00 <c_wraith> bloop: But in the case where st is a monotonically-increasing list of characters, they'll have the same result
17:45:39 <vr38dett> djahandarie: a bit of a Catch-22, but just trying to get a handle on symbols for now, Haskell seems a bit more accessible than Math theory.
17:46:16 <djahandarie> vr38dett, you only need Curry-Howard to understand how the (->) symbol means "implies". This knowledge isn't required to use Haskell.
17:46:25 <djahandarie> vr38dett, what is your eventual goal, learning Haskell or learning math?
17:46:27 <c_wraith> vr38dett: I'd learn the basics of the language before you get too worried about the theory.  The language is great for exploring the theory, though, once you have a handle on it
17:46:41 <ManateeLazyCat> Where the author of "Learn You A Haskell for Great Food" ? I want build-in it in manatee-pdfviewer, people can read it when first use my pdf viewer. :)
17:46:51 <djahandarie> Hahaha
17:47:02 <vr38dett> djahandarie: Learning Haskell, ideally to get better at functional programming.
17:47:02 <djahandarie> "Learn You A Haskell for Great Good"
17:47:10 <c_wraith> ManateeLazyCat: it's BONUS, and he's at least logged in right now
17:47:34 <djahandarie> vr38dett, just follow one of the tutorials out there then. Like the one that was just mentioned now.
17:47:37 <djahandarie> @where lyah
17:47:37 <lambdabot> http://www.learnyouahaskell.com/
17:48:24 <ManateeLazyCat> c_wraith: I have build-in introduction (first 36 pages) in Manatee-PdfViewer, but still too big (1.3MB), i love "Learn You A Haskell For Great Food!.pdf", all just 730K
17:48:57 <ManateeLazyCat> Is introduction of RWH
17:48:58 <djahandarie> People give better food to the hobos that know Haskell compared to the ones that know HTML?
17:49:01 <ManateeLazyCat> Like this http://www.flickr.com/photos/48809572@N02/5496671763/lightbox/
17:49:56 <bloop> I think it's all fascinating. I've been more and more interested in it for the past year or so, starting with Lua, then Lisp, then combinatory logic/lambda calculus and now Haskell. I love cracking my brain open to new ways of thinking.
17:50:50 <ManateeLazyCat> @tell BONUS Can i build-in your "Learn You A Haskell For Great Food!.pdf" in my pdf viewer? (package manatee-pdfviewer), then people can read your great stuff when try my pdf viewer. :)
17:50:50 <lambdabot> Consider it noted.
17:51:27 <jmcarthur> for great food, lol
17:51:31 <dmwit> ManateeLazyCat: Huh, is it really *food* and not *good*?
17:51:36 <dmwit> Pretty funny. =)
17:51:52 * sipa will learn haskell for great food
17:51:57 <sipa> who will cook it?
17:52:04 <osoleve> this guyyyy
17:52:09 <dmwit> preflex: seen BONUS
17:52:09 <preflex>  BONUS was last seen on #haskell 1 day, 8 hours, 32 minutes and 53 seconds ago, saying: secret bonus swag indeed
17:52:12 <dmwit> preflex: seen BONUS_
17:52:12 <preflex>  BONUS_ was last seen on #haskell 1 year, 112 days, 11 hours, 13 minutes and 46 seconds ago, saying: osaunders_: usually i think it's defined as a function that uses only the stuff it takes as parameters and function application
17:53:30 <osoleve> preflex: seen preflex 
17:53:31 <preflex>  what
17:53:31 <ManateeLazyCat> OK, it's time for work. Have a nice day, all! See you guys after work. :)
17:56:49 * hackagebot mstate 0.2 - MState: A consistent State monad for concurrent applications.  http://hackage.haskell.org/package/mstate-0.2 (NilsSchweinsberg)
17:57:00 <McManiaC> yay, mstate-0.2 is now using STM and monad-peel for safer concurrency :)
17:58:06 <bloop> why do you guys think functional programming techniques are not more widely used? It's not a technology issue... most C# programmers don't even realize that half their language features are made redundant by "delegates." Is it just education?
17:58:45 <hpc> bloop: social and mental inertia would be my guess
17:58:46 <McManiaC> education & lazyness to adopt
17:58:59 <hpc> languages are popular because they are popular, and new languages are confusing because they are new
17:59:02 <djahandarie> bloop, CMU just overhauled their CS intro stuff and functional programming is pretty core to it now.
17:59:25 <hpc> strangely, haskell is neither of those :P
18:00:04 <Kaidelong> bloop: People want to believe that functional programming is not relevant because they do not want to learn it. A lot of C# programmers are actually unhappy about this, I'm not sure most of them are as you describe.
18:00:15 <Kaidelong> but a lot of people who program C# are not primarily C# programmers
18:01:37 <bloop> I've been writing C# for the past few months, and everyone is sort of in awe of how I can do so much with so little code and so few bugs.  They recognize that my code is better, but they are annoyed that they have trouble understanding (but not extending) it. I'm not being reprimanded, but it's like there's a lack of eagerness to learn which is very atypical of programmers in everythign EXCEPT higher-level techniques in programming
18:02:19 <Kaidelong> a lack of eagerness to learn is normal for programmers
18:02:35 <hpc> programmer != scientist
18:02:47 <hpc> this distinction doesn't get made enough, imo
18:02:58 <hpc> computer SCIENCE is the programming degree, for example
18:03:03 <geheimdienst> i think things are moving towards more functional programming. c++ is slowly getting closures, similar for c and obj-c. c# has them and is moving to add a little bit of type inference, and so on
18:03:13 <bloop> well they're very eager to learn about the problems they're solving...
18:03:23 <Kaidelong> C# is multi-paradigm language for all intents and purposes
18:03:32 <Kaidelong> bloop: only enough to solve it, not to solve it better
18:03:52 <Kaidelong> the people who actually are into C# are aware of and use functional programming
18:03:57 <bloop> closures don't really make sense without garbage collection though. C/C++ will never have real lambdas. They are the set of combinators that agree with hardware. That's how i think of them anyway.
18:04:09 <ddarius> (Lambda) Abstraction.  The catch-all solution to making hard problems go away.
18:04:13 <Kaidelong> a lot of people who write C# code aren't passionate about C# itself
18:04:29 <Kaidelong> they might have a background in Java, VB, PHP, many others
18:04:34 <bloop> Kaidelong: I'm not passionate about C#, I just like closures!
18:04:40 <proq> objective-C has lambdas now
18:05:15 <ddarius> My comment just a second ago was (independently) due to using lambdas in C# right now.
18:05:27 <bloop> I guess with something like C#, everyone uses it to pretend they're coding in their language of choice.
18:06:01 <Kaidelong> C# does have its own idiomatic style, but it evolved since the .NET platform was invented into something not entirely compatible with it anymore
18:06:08 <geheimdienst> c got closures at the same time that obj-c got them. i find them pretty clumsy, but of course it's better than nothing
18:06:14 <Kaidelong> the .NET platform did evolve with it though
18:06:40 <Kaidelong> and then certain things on top of C#, like WPF, have their own idioms again
18:07:04 <Kaidelong> WPF has much less focus on static typing, for example
18:07:57 <bloop> C has closures. It's called "implement a language with real closures using C." C is a language for moving memory around in pre-planned ways, not solving abstract ill-defined problems...
18:10:05 * BMeph still thinks of C as a fancy PDP-11 assembler simulator
18:11:00 <geheimdienst> c combines all the speed and flexibility of assembly with the ease of use of assembly
18:11:05 <Kaidelong> Expert F# is a good book
18:11:10 <Kaidelong> I was looking through it again today
18:11:47 <Kaidelong> the number of topics it covers is extremely broad
18:11:55 <Kaidelong> perhaps a haskell version of it would be nice
18:12:06 <bloop> I haven't even peered into F# yet. I assumed Haskell would cover a lot of the same ground on my 'journey'
18:12:13 <Kaidelong> although it's already been useful to me with my haskell programs
18:12:19 <Kaidelong> yeah F# and haskell are very similar
18:12:38 <Rotaerk> meh, they're worlds apart
18:13:02 <Kaidelong> Rotaerk: other than the typeclasses I'm not sure why
18:13:31 <Rotaerk> ubiquitously pure, lazy, and a decent type system, versus impure, strict, and a meh type system
18:13:44 <Kaidelong> purity is a real advantage and is the main reason why I use haskell
18:13:48 <ddarius> F# lacks higher kinded types.  And of course, Haskell lacks the object system of O'Caml/F#.
18:13:51 <Kaidelong> F# is easily lazy where you want it to be
18:13:59 <Kaidelong> higher kinded types/typeclasses yes
18:14:06 <Kaidelong> that is an issue
18:14:15 <Rotaerk> there's a huge difference between ubiquitous laziness and supporting laziness
18:14:23 <Kaidelong> F#'s type system is pretty decent
18:14:36 <Rotaerk> .NET's type system is terrible
18:14:37 <Kaidelong> especially compared to vanilla haskell without extensions
18:14:45 <Kaidelong> F#'s type system is not the same as .NET's
18:14:50 <Kaidelong> it is compatible with it though
18:15:10 <Rotaerk> it is corrupted by .NET's type system
18:15:30 <Rotaerk> inherent nullability of already-existing reference types
18:17:24 <mkserra> hello everybody
18:17:28 <Kaidelong> Rotaerk: .NET provides ways to set up contracts saying that fields are non-nullable. Those contracts get statically checked at compile time.
18:17:47 <Chris_> hey, i forget the terminal code for running the interpreter. Can anyone help me out?
18:17:48 <osoleve> oh man, currying just clicked thanks to lambdabot
18:17:55 <osoleve> it was like candy for my brain
18:18:16 <Guest24100> hey, i forget the terminal code for running the interpreter. Can anyone help me out?
18:18:22 <osoleve> ghci?
18:18:35 <Guest24100> thanks
18:19:44 <Rotaerk> Kaidelong, 1) that a patch-job; should be handled by the type-system; 2) doesn't that only work at compile-time if you have the most expensive version of VS
18:19:47 <mkserra> hi folks, i'm pretty new to this fascinating language, and already i have a healthy dislike for do notation
18:19:55 <mkserra> could anybody help me de-sugar this:
18:19:58 <mkserra>   do args <- getArgs 
18:20:00 <mkserra>      dict <- dict
18:20:01 <mkserra>      print $ (answers $ head args) dict
18:20:20 <Axman6> mkserra: do notation is wonderful compared to the desugared alternative
18:20:21 <mkserra> actually
18:20:22 <mkserra> this
18:20:27 <mkserra> main = let dict = return . map init . lines =<< readFile "WORD.LST"
18:20:28 <mkserra>   do args <- getArgs 
18:20:29 <dmwit> mkserra: Sure, but in the future, please use a service like hpaste.org.
18:20:30 <mkserra>      dict <- dict
18:20:31 <mkserra>      print $ (answers $ head args) dict 
18:20:34 <mkserra> oh
18:20:34 <Rotaerk> Kaidelong, also can those contracts be setup in data structures, or are they strictly for functions
18:20:40 <dmwit> mkserra: Please don't paste long code snippets in here.
18:20:45 <mkserra> thank you, i wasn't aware about the pasting
18:20:48 <Kaidelong> 1) is a matter of taste, althoough I happen to agree, 2) I'm not sure. I think the contract provider thing is free at this point, just not the unit test suite you'd tend to use with it, but there are free replacements for those.
18:21:06 <Axman6> getArgs >>= \args -> dict >>= \dist >> print (answers (head args) dict) 
18:21:09 <Kaidelong> Rotaerk: What? You mean, can you mark fields non-nullable? Yes.
18:21:19 <Rotaerk> k
18:21:53 <mkserra> thanks Axman
18:22:07 <applicative> Axman6 means getArgs >>= \args ->   dict >>= \dist ->  print (answers (head args) dict)
18:22:09 <Kaidelong> Rotaerk: also not all fields in .NET language data structures are nullable by default either, it depends on the data structure
18:22:11 <mkserra> also, is there a better, more abstract way to do it
18:22:20 <Kaidelong> although it is true for all serializable data structures, I think
18:22:23 <mkserra> something from Control.Monad ?
18:22:32 <Kaidelong> which is just about everything
18:22:34 <Axman6> uh yes
18:22:37 <Rotaerk> Kaidelong, no, every field of a reference type is nullable by default, regardless of the type containing it
18:22:38 <applicative> or maybe  getArgs >>= \args ->   dict >>= \dict ->  print (answers (head args) dict)
18:23:56 <Kaidelong> Rotaerk: You can set it up so that it requires type-level wizardry to actually get an object instance with null fields
18:24:24 <Rotaerk> how?
18:24:26 <dmwit> Axman6 also means s/dist/dict/
18:24:47 <Rotaerk> Kaidelong, i mean you can put checks in the ctor to enforce, at runtime, that the fields aren't null
18:25:03 <Rotaerk> making it a compile-time guarantee for all recipients of objects of that type
18:25:14 <Kaidelong> Rotaerk: Structs
18:25:16 <Rotaerk> though it's still gotta do a runtime check when it shouldn't have to
18:25:39 <Kaidelong> you'd have to put extra logic in to enforce that reference type arguments to the constructor are not null, though
18:25:40 <dmwit> mkserra: The code itself looks fine; I wouldn't try to "abstract" it myself unless it was a very common pattern in other do-blocks.
18:25:48 <Kaidelong> with code contracts, hopefully
18:26:00 <Rotaerk> haven't used .NET 4.0 yet
18:26:07 <applicative> mkserra: in short cases like yours, this desugaring has a certain charm, you can view ">>= \args -> " and ">>= \dict -> " as special arrows
18:26:09 <Kaidelong> this was since .NET 2.0 I think
18:26:14 <Rotaerk> contracts?
18:26:20 <Kaidelong> no not the contracts
18:26:28 <Kaidelong> I do not know if CodeContracts are default .NET 4.0
18:26:29 <mkserra> special arrows?
18:26:31 <applicative> mkserra, it's more trouble when you have several "\blah ->" balls in the air
18:26:36 <Rotaerk> contracts were introduced in VS 2010
18:26:43 <Kaidelong> oh okay then they are, good thing, yay
18:27:05 <Rotaerk> though to use their compile-time checking aspect requires a one of the high-end editions of it
18:27:20 <ddarius> Axman6: With the exception of refutable patterns, the difference between do-notation and its desugaring is rather minor.
18:27:23 <Rotaerk> if I recall correctly...
18:27:26 <applicative> mkserra, I just meant, that's sort of how I parse it visually to keep control of the order. It's not important
18:27:46 <Kaidelong> Rotaerk: Ah yes, they offer extra static checking with a higher end package
18:27:49 <Kaidelong> I remember now
18:27:53 <Kaidelong> you still get some though
18:28:14 <Kaidelong> also I tend to use them with unit tests generated for me by Pex, with NUnit as the testing engine
18:28:31 <Kaidelong> unit tests are powerful and shouldn't be laughed at
18:29:08 <mkserra> the code i pasted isn't really for use, it's just an example with which I'm trying to get familiar with monads.. what specifically made me think it must be over-complicated was the apparent redundancy of dict <- dict
18:29:41 <mkserra> I basically posted it here because I expected I must have factored it wrongly 
18:29:44 <mkserra> but apparently not?
18:29:51 <dmwit> Looks fine to me.
18:30:10 <BMeph> What would be a good symbol for "flip fmap"?
18:30:12 <mkserra> ok! 
18:30:18 <dmwit> BMeph: (>>>)
18:30:19 <dmwit> ;-)
18:30:34 <dmwit> More realistically...
18:30:36 * BMeph snickers
18:30:37 <dmwit> :t (<$)
18:30:38 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
18:30:45 <dmwit> :t (<*)
18:30:45 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
18:30:49 <dmwit> bleh
18:31:08 <dmwit> ?hoogle Functor f => f a -> (a -> b) -> f b
18:31:08 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
18:31:08 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
18:31:08 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
18:31:24 <shachaf> > reverse "<$>"
18:31:25 <lambdabot>   ">$<"
18:35:10 <mkserra> so... has anyone here done serious work with any of the declarative-style experimental GUI libraries?  
18:35:23 <mkserra> things like Fruit, FRP...
18:35:31 <juhp> @tell ManateeLazyCat thanks
18:35:31 <lambdabot> Consider it noted.
18:35:32 <dmwit> No, though many of us have done anti-serious work with them.
18:35:41 <hpc> co-serious
18:35:43 <mkserra> :)
18:36:03 <dmwit> I guess I was looking for the word "casual".
18:36:18 <dolio> mkserra: Frag was written using FRP techniques, as I recall.
18:36:22 <dolio> If that counts as serious.
18:36:46 <mkserra> I haven't played it.. does it run well?
18:36:47 <dmwit> I did a menger-sponge dealy with fieldtrip, and failed to get a couple of the others to build. Does that count?
18:36:56 <mkserra> Is Frag 100% Haskell?
18:37:00 <dolio> I haven't tried it either.
18:37:28 <mkserra> fieldtrip, haven't heard of that one
18:37:41 <mkserra> did it work out well?
18:37:46 <mkserra> in your experience anyway
18:37:49 <dmwit> fieldtrip seemed nice.
18:38:10 <BMeph> Is Clean - oops, Concurrent Clean - allowed outside of Holland? ;)
18:39:46 <mkserra> since an initial major infatuation with haskell, i've lately been trying to get a more realistic view of its weaknesses... i'm curious about some criticisms I read in blogs
18:39:50 <mkserra> like the putative difficulty of combining monads
18:40:06 <mkserra> does it make certain program designs outright impossible?
18:40:28 <lacus> Guys, I'm coming from a ruby background and want to give haskell a try. Any pointers on where to begin?
18:40:44 <jmcarthur> @where lyah
18:40:44 <lambdabot> http://www.learnyouahaskell.com/
18:40:52 <jmcarthur> @where rwh
18:40:52 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:41:02 <mkserra> isn't the lambdabot a bot
18:41:07 <Kaidelong> lacus: do something IO intensive like a text adventure to get a feel for how IO works
18:41:07 <mkserra> it answers general questions like that?
18:41:22 <jmcarthur> not very general
18:41:35 * lacus bows thankfully
18:42:04 <mkserra> but it did interpret his question? that's pretty cool...
18:42:13 * BMeph meanders iambically
18:42:36 <lacus> mkserra: i think it was triggered by @where lyah
18:42:58 <mkserra> ah
18:43:56 <lacus> a Text adventure game sounds fun, Kaidelong. good suggestion. That along with the resources from jmcarthur should be a nice starting point :-)
18:43:57 <mkserra> i haven't used irc much hitherto as you see!
18:45:03 <revenantphx> does anyone know what font this is:
18:45:05 <revenantphx> https://d3nwyuy0nl342s.cloudfront.net/img/f9b8c8cfd97b30802784065986ac0c5940f4af0e/687474703a2f2f6469657465722e706c616574696e636b2e62652f66696c65732f6f682d6d792d7a73682d7468656d652d6469657465722e706e67
18:45:42 <revenantphx> I think it's bitstream vera
18:50:10 <mkserra> suppose I am representing a 'game of life' board as a list (or set) of (x,y) tuples... would I get better performance with a list or Data.Set ?
18:50:24 <mikeg> revenantphx: looks a lot like Terminus @ 12pt
18:50:34 <revenantphx> mmk
18:50:49 <revenantphx> no, thats not it
18:50:50 <mkserra> I do some elem and intersect and such in the algorithms
18:51:04 <Kaidelong> mkserra: I'd use a map
18:51:07 <Kaidelong> or set
18:51:18 <Kaidelong> actually
18:51:22 <Kaidelong> with (x,y) tuples
18:51:25 <Kaidelong> I would use an array
18:51:41 <lacus> i'm not sure if i can use a language that lacks a for loop though... ;)
18:51:52 <Kaidelong> provided that x and y are of some type for which you know the bounds for which you can enumerate things between them
18:51:53 <mkserra> well
18:52:03 <ddarius> :t forM_
18:52:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
18:52:15 <Kaidelong> ddarius: That isn't actually a for loop
18:52:16 <mkserra> the array is fastest, I'd expect, but
18:52:20 <Kaidelong> lacus: you can write a for loop
18:52:34 <mkserra> i don't mind sacrificing performance some, for my semantic preferences
18:52:50 <mkserra> (and avoiding bounds)
18:53:09 <mkserra> can you avoid bounds with arrays; treat them as infinite?
18:53:18 <Kaidelong> while :: s -> (s -> Bool) -> (s -> s) -> s
18:53:39 <Kaidelong> would basically be like a for loop anyway
18:53:54 <Kaidelong> you could also do something like
18:54:59 <Kaidelong> whileST :: (Monad m) => s -> (s -> Bool) -> (s -> m s) -> m s
18:55:02 <Kaidelong> err
18:55:17 <Kaidelong> well yeah
18:55:32 <Maxdamantus> What about a map of coordinate tuples to arrays of booleans?
18:55:41 <ddarius> forM_ is very similar to a foreach loop.
18:55:43 <Kaidelong> lacus: basically anything you can do with a loop you can do in haskell
18:55:57 <ddarius> An actual C-style for-loop would be atrocious.
18:56:21 <lacus> i'll take your english explanation as truth for now.
18:56:29 <Maxdamantus> Map (Integer, Integer) (Array (100, 100) Bool)
18:56:41 * Maxdamantus would think that'd be reasonably fast, and avoid bound problems.
18:56:48 <Kaidelong> lacus: Just get used to using higher order functions, and recursion
18:56:58 <Kaidelong> you surely have some of the that in your ruby experience already
18:57:41 <shachaf> A Ruby user is unhappy with the lack of for loops? Ruby doesn't have them either.
18:57:52 <mkserra> thanks max, i will try that... did it already with lists but, slow ;)
18:58:05 <lacus> shachaf: it was only in jest
18:58:12 <Kaidelong> oh
18:58:15 <Kaidelong> now I feel silly
18:59:35 <mkserra> do you think experience in C is inversely correlated with ease of learning FP 
18:59:45 <lacus> don't, that was interesting. I'm going to try it out in the haskell interpreter when i figure out how to install it
19:00:07 <mkserra> or that non-programmers learn it more readily?
19:00:11 <Kaidelong> anyway a nice conceptual way to think about haskell is that it is a level of abstraction where you talk about programs rather than describe a program itself, almost like a kind of loose parallel with a shell script. the value you call "main" is the actual program that ends up running.
19:01:06 <Kaidelong> due to the way that evaluation tends to work in haskell it is probably good to think of a list as a "program that returns many values" anyway
19:01:07 <Maxdamantus> mkserra: no; because then you can imagine how certain things are implemented, and guess through logic how they're meant to work.
19:01:23 <lacus> Kaidelong: i've been mucking with xmonad for a while. I used "main" in the config file
19:02:32 <Kaidelong> anyway I think once you are comfortable with IO and randomness in haskell you are better set up to tackle other problems, and even just learning about those two you tackle a few important concepts
19:02:40 <BMeph> lacus: Haskell doesn't lack a for loop; in fact, we have a data structure for it! ;)
19:03:09 <bloop> what are the advantages to using guards rather than if-else? I'm a bit confused in a "what's this for?" way
19:03:28 <lacus> okay, I read that from "We abandon some ideas that might seem fundamental, such as having a for loop built into the language."
19:03:29 <napping`> guards chain more nicely
19:03:53 <napping`> also with Pattern guards you can see if something matches a pattern, and get the matched values out
19:04:04 <monochrom> guards are part of pattern matching. you have all conditions integrated at one place.
19:04:18 <monochrom> (if you already use pattern matching anyway)
19:04:24 <Kaidelong> patterns should really be first class values
19:04:36 <napping`> hmm, guess I should read up on what made it into Haskell 2010
19:04:50 <Kaidelong> you can model them as functions of the form "a -> Maybe b" anyway
19:04:54 <BMeph> bloop: Guards are Haskell's "gateway drug" for pattern-matching. ;)
19:04:57 <ion> “We abandon some ideas that might seem fundamental, such as tail recursion”
19:05:02 <bloop> also why do patterns need parentheses? Can you give an example where the syntax would be ambiguous without them?
19:05:16 <ion> foo x:xs
19:05:28 <monochrom> f Just x y
19:05:31 <ion> In fact, that’s not ambiguous
19:05:33 <BMeph> bloop: ^^ There ya go.
19:06:32 <Kaidelong> Value -> Maybe Representation
19:06:47 <napping`> Kaidelong: you can get pretty far like that, but the syntax is ugly, nested patterns are much trickier, and it's harder to check for coverage
19:07:06 <Kaidelong> napping`: decidably checking for it is impossible
19:07:14 <Kaidelong> but is it really that important?
19:07:31 <Kaidelong> also the original syntax could be provided as sugar I'm sure
19:07:36 <Kaidelong> see ViewPatterns
19:08:00 <Kaidelong> but why shouldn't you be able to do things like pass patterns as arguments to a function or have a list of patterns over the same data type?
19:08:59 <Kaidelong> also you can then talk about things that combine patterns
19:09:05 <napping`> you can write (\v -> case v of pat xs -> Just (xs))
19:09:15 <ddarius> Kaidelong: Instead, look at the pattern calculus.
19:09:15 <Kaidelong> like an or for patterns that tries to match the right pattern if the left fails
19:09:34 <ddarius> Particularly the paper "First class patterns" by Barry Jay and Delia Kesner.
19:09:35 <napping`> and a nice quasiquoter to build thoes from just the pattern, if you think it would be useful
19:09:58 <napping`> also what ddarius says
19:10:59 <Kaidelong> cool, more stuff to read
19:11:12 <Kaidelong> already backlogged but this looks juicy enough to open it up right now
19:11:16 <Kaidelong> thank you ddarius
19:11:54 <mm_freak> connectViaNextProxy :: MonadPeelIO m => ByteString -> Int -> (Handle -> Iteratee ByteString m b) -> Iteratee ProxyServer m b
19:12:01 <mm_freak> do you guys see a way to convert this to an enumeratee?
19:12:14 <mm_freak> the Handle parameter to the iteratee seems to make this impossible
19:12:35 <mm_freak> otherwise it seems to be a perfectly valid enumeratee
19:13:00 <lacus> Kaidelong: is there a repl for haskell
19:13:08 <mm_freak> lacus: ghci
19:13:08 <Kaidelong> lacus: GHCi
19:13:26 <lacus> ah, thanks fellas
19:13:30 <Kaidelong> although what GHCi reads and evals is not exactly exactly haskell
19:13:54 <Kaidelong> it is still useful for the same things a REPL is useful for normally though
19:14:07 <Kaidelong> and in one ways is more useful than normal due to haskell's type system
19:14:21 <Kaidelong> you can load library code and inspect the types of the values the module exposes
19:14:28 <Kaidelong> and infer a lot of information from that
19:14:31 <napping> ghci basically reads the body of a do block
19:14:41 <lacus> qsort []     = []
19:14:45 <mm_freak> napping: counter-example: 3
19:14:47 <mm_freak> > 3
19:14:48 <lambdabot>   3
19:14:49 <lacus> i tried to type that and it broke
19:14:59 <mm_freak> lacus: put a "let" before that
19:15:07 <Kaidelong> lacus: you have to write it a bit differently
19:15:14 <mm_freak> let qsort [] = []; qsort (x:xs) = …
19:15:29 <napping> mm_freak: as a pattern? I still don't see it
19:15:30 <Kaidelong> like mmfreak said
19:15:48 <mm_freak> napping: 3 :: Num a => a
19:16:02 <mm_freak> napping: an expression in a multi-line do-block in IO needs to be of type IO a
19:16:04 <lacus> better, thanks.
19:16:19 <napping> ah right - you can also evaluate single expressions
19:16:30 <Kaidelong> mm_freak: as a pattern it'd have type "(Num a, Eq a) => a -> Maybe a" wouldn't it?
19:16:32 <napping> I thought it was something about patterns that need parens
19:16:51 <mm_freak> Kaidelong: patterns don't need Eq
19:16:59 <Kaidelong> mm_freak: 3 would
19:17:08 <napping> Eq is a superclass of Num anyway
19:17:28 <mm_freak> Kaidelong: also i wouldn't know that patterns have types
19:17:43 <Kaidelong> > (\x -> case x of {3 -> True; _ -> False}) (const 5)
19:17:43 <lambdabot>   *Exception: (==): No overloading for function
19:17:48 <napping> lacus: might as well warn you now that "classes" are hardly at all like in OO languages
19:17:48 <Kaidelong> tada
19:18:06 <mm_freak> Kaidelong: that's Num-specific
19:18:09 <Kaidelong> yep
19:18:18 <Kaidelong> but the Eq constraint does become important
19:18:41 <mm_freak> lacus: might as well warn you that the list data structure is very unsuitable for quicksort…  better write a mergesort
19:18:51 <mm_freak> it will give you an orders of magnitude speedup
19:19:00 <napping> Kaidelong: class (Eq a, Show a) => Num a where ...
19:19:09 <mm_freak> Kaidelong: the Eq constraint appears to be arbitrary to most people
19:19:13 <mm_freak> including me
19:19:28 <Kaidelong> napping: Ah right, Eq is a superclass
19:19:36 <mm_freak> exactly
19:19:39 <bloop> please correct me if I'm wrong: Parentheses are used for 3 distinct things in the syntax: expression precedence grouping, tuples, and pattern matching.
19:19:55 <bloop> or are they not that distinct?
19:20:02 <mm_freak> bloop: the third is redundant, i think
19:20:02 <Kaidelong> mm_freak: You need the Eq constraint to make that kind of pattern matching work though
19:20:09 <mm_freak> Kaidelong: nope
19:20:11 <Kaidelong> or perhaps a relaxed version of it
19:20:12 <napping> I think pattern matching and precedence grouping is actually equivalent
19:20:21 <mm_freak> Kaidelong: data Int = 0 | 1 | 2 | 3 | 4 | …
19:20:23 <napping> in fact GHC parses patterns as expressions
19:20:37 <mm_freak> the language doesn't need Int to have Eq, only Num requires this, and since Int is a Num, it's also an Eq
19:20:42 <lacus> mm_freak, napping, how long have you been writing haskell?
19:20:42 <Kaidelong> mm_freak: but that's only for ints, not aribtrary nums
19:20:53 <mm_freak> lacus: a few years
19:21:21 <mm_freak> Kaidelong: the point is that Eq is not a language construct, while pattern matching is
19:21:29 <napping> Ah, one pattern where parens are important is f ((x:y):z) vs f (x:y:z)
19:21:35 <mm_freak> Kaidelong: the language would be ill-defined, if it would depend on Eq
19:21:53 <mm_freak> napping: that's operator precedence
19:22:01 <Kaidelong> mm_freak: that's what those patterns do anyway. Although I suppose you might argue for their removal
19:22:03 <mm_freak> or, in that case, associativity
19:22:28 <Kaidelong> the pattern 3 depends on you being able to compare something against fromInteger 3
19:22:39 <mm_freak> Kaidelong: if Int patterns use (==) internally, that's an implementation detail, but neither do i know, nor do i care
19:22:40 <Kaidelong> or whatever the method was
19:22:51 <mm_freak> Kaidelong: it depends on Int comparison, not on (==)
19:23:01 <mm_freak> (==) also depends on Int comparison
19:23:03 <saml> hey, how would you express function application without curring?  with curring, it was App  Expr Expr
19:23:04 <napping> that was from the earlier question of why you can't just write f Just x y and have the compiler look up the arity of Just to figure out how many arguments there are
19:23:17 <mm_freak> but that's because Int is not implemented like this:  data Int = 0 | 1 | 2 | 3 | 4 | …
19:23:24 <mm_freak> but instead uses an efficient internal representation
19:23:26 <saml> App Expr [Expr]   ?
19:23:33 <saml> where Expr has to be function?
19:23:50 <Kaidelong> mm_freak: if int was implemented like that you'd still need a method (Num a) => a -> Int
19:23:53 <napping> sounds reasonable
19:24:07 <napping> lacus: what sorts of things do you want to learn?
19:24:14 <mm_freak> Kaidelong: try it out:  data A = B | C
19:24:22 <mm_freak> Kaidelong: you can pattern-match on values of type A without Eq
19:24:28 <Kaidelong> mm_freak: I know that
19:24:44 <mm_freak> Kaidelong: good, and there is no difference to Int, except that A has a few less elements
19:24:57 <Kaidelong> mm_freak: the pattern 3 is not specific to integers
19:25:08 <bloop> one thing I always liked about lexical scoping in most langs that have it is that if you want to know what X means or where it lives, you "look up" to find it. It seems like Haskell does NOT have this property. Is it generally "look down" to the "where" or can it be either direction?
19:25:09 <mm_freak> Kaidelong: it is after compilation
19:25:55 <napping> lacus: hmm, maybe 10 years?
19:26:13 <mm_freak> bloop: that question doesn't make much sense in haskell…  memory-related stuff is an implementation detail and that information may not exist at all
19:26:26 <napping> bloop: it's still from surrounding scopes, but declarations are not necessarily in order
19:26:36 <mm_freak> bloop: for example you cannot ask for the memory address of a function, because that address may change or may not exist at all
19:26:44 <napping> let x = 1; y = (x,z); z = 2 in ...
19:27:13 <Kaidelong> bloop: Lexical scoping just means that local values declared in local scope is not visible in higher scope. As far as I'm aware haskell is lexically scoped as far as that is concerned
19:27:20 <lacus> napping: i'm not sure. I most use ruby for web stuff. I don't have any CS background, but I think writing a clone of the game "sleuth" would be awesome.
19:27:30 <napping> lacus: that's one reason handling the full language in the interpreter would be a bit tricky
19:27:39 <bloop> mm_freak: not exactly what I mean, it's more like in the case that you have a helper function, in something like Lisp it may be defined just above where it's used in the same scope, but in Haskell it might be "below" (positionally, on the page) in the "where" clause
19:27:47 <Kaidelong> oh I see now what you are asking
19:28:10 <Maxdamantus> It's just syntax.
19:28:15 <mm_freak> lacus: you may be interested in one of the haskell web frameworks…  personally i like yesod, but happstack is much easier to get into for beginners, because it uses only basic constructs
19:28:19 <Kaidelong> bloop: I imagine that after the compiler parses all the haskell code involved it has something with that property, yes
19:28:46 <Kaidelong> so it's a parsing issue/syntax
19:28:49 <mm_freak> bloop: ah, sorry…  yes, definitions may be in either direction
19:29:11 <mm_freak> x y where y = …
19:29:32 <mm_freak> they may also be far below in the current file, for example if you use a top level function
19:29:46 <bloop> is it like "where" is a sort of "reverse let" ?
19:30:17 <mm_freak> bloop: yes
19:30:44 <Maxdamantus> I don't think it's much to do with the distance .. the point is that in eg, C, you can keep searching up from use of an identifier and you'll eventually reach a declaration.
19:30:51 <lacus> mm_freak: that's a cool idea. 
19:30:53 <Maxdamantus> (except in the case of explicit declaration stuff)
19:30:56 <mm_freak> but 'where' has more valid spots:  for example you can use where-defined variables/functions inside of a pattern guard
19:31:09 <Maxdamantus> Actually, that's not true.
19:31:17 <mm_freak> f x | isBlah y = … where y = blubb x
19:31:22 <Kaidelong> Maxdamantus: You could probably write a converter that rearranges haskell code into something with that property
19:31:26 <Maxdamantus> int x; { int x; } { int x; /* here */ }
19:31:40 <Maxdamantus> s/expl/impl/
19:31:43 <Kaidelong> ah well of course you must take account of scope
19:32:56 <teratorn> anyone have a clue why cabal-install bootstrap would fail with a newly compiled ghc 7.0.3? http://paste.pocoo.org/show/363061/
19:33:10 <Maxdamantus> That last `int` shouldn't be there.
19:33:32 <mm_freak> in C it's also valid to refer to something just being defined, which is an intentional decision and solves the problems of single-pass
19:33:42 <mm_freak> struct X { struct X *next; … }
19:34:08 <mm_freak> s/the/some/
19:35:42 <Kaidelong> ddarius: I like this paper you linked me
19:36:58 <teratorn> how can I check what version of `base' I have?
19:37:26 <geheimdienst> teratorn: try "ghc-pkg list" at the command line
19:38:01 <mm_freak> teratorn: if you have the 'cabal' utility, an easy method is: cabal info base
19:38:51 <teratorn> mm_freak: trouble is I'm trying to *install* cabal, but it's giving me fits
19:39:08 <mm_freak> teratorn: your distribution doesn't give you a prebuilt binary?
19:39:15 <mm_freak> usually it's called "cabal-install"
19:39:44 <applicative> teratorn, paste what "ghc-pkg list" says.
19:39:49 <teratorn> no I'm setting up a ghc 7.0.3 from source
19:40:00 <teratorn> so I've got 4.3.1.0
19:40:09 <teratorn> but this error message is crazy
19:40:10 <teratorn> base >=4 && <3 && >=1 && <5
19:40:18 <teratorn> that is not a sane dependency
19:40:30 <mm_freak> yeah, doesn't appear sane to me
19:40:46 <applicative> i wonder if he overwrote the version of Cabal that came with ghc?
19:40:47 <mdmkolbe> What is a good resource on quotient types?  Specifically, once you have a quotient type, how do you define the operators over that quocient type?  Are there any Haskell implementations of quotient types?
19:40:58 <mm_freak> teratorn: but that dependency is meaningless, unless you use cabal to install
19:41:13 <teratorn> and it says I've already got Cabal-1.10.1.0
19:41:23 <teratorn> so why is cabal-install bootstrap trying to download and build it
19:41:30 <mm_freak> teratorn: there is a difference between cabal and cabal-install
19:41:41 <teratorn> yep, I'm aware of that
19:42:26 <mm_freak> teratorn: anything wrong with the haskell platform?
19:43:05 <teratorn> ok uhm, it seems latest cabal-install bootstrap script just doesn't work with ghc 7.0.3.... the latest Cabal it knows about is 1.8.x
19:43:24 <teratorn> so I think I can patch and fix around it
19:43:27 <adorablepuppy> I'm trying to get a bitmap's rgba data with Codec.BMP, but I'm having problems matching the expected type to actual type. http://hpaste.org/45169/codecbmp_get_rgba_data
19:44:02 <applicative> teratorn, you are using an out of date cabal-install?
19:44:41 <applicative> the current version is 0.10.2 but the paste says cabal-install-0.8.2
19:44:47 <mm_freak> adorablepuppy: look at the type of 'either'
19:45:00 <teratorn> applicative: :(
19:45:05 <mm_freak> adorablepuppy: either error id
19:45:07 <teratorn> applicative: http://www.haskell.org/cabal/download.html
19:45:18 <teratorn> I just did what Google told me to do its not my fault
19:45:21 <mm_freak> (assuming that the type is Either String SomethingElse)
19:45:29 <applicative> damn, that's irritating
19:46:09 <teratorn> clearly I should be on hackage
19:46:09 <geheimdienst> teratorn: i had the problem recently that in /usr/ there was the correct, new cabal installed (0.10 or something) but in ~/.cabal/bin, there was an old one that messed things up. unfortunately my shell preferred the old
19:46:12 <teratorn> directly
19:46:38 <mm_freak> adorablepuppy: also as a design advice you may want to use 'either' in a monadic way instead
19:46:40 <teratorn> geheimdienst: I'll keep that in mind, but I have yet to make a ~/.cabal on this account yet :)
19:46:54 <mm_freak> adorablepuppy: someEitherComp >>= either (throwIO . userError) return
19:47:13 <applicative> teratorn, you can download the tarball from hackage 
19:47:23 <mm_freak> using 'error' or 'throw' are bad ideas in general
19:47:38 <geheimdienst> okay :) i figured it out because cabal --version tells you both the library version and the utility version
19:47:48 <mm_freak> (unless you're a beginner)
19:47:54 <teratorn> applicative: great, thanks
19:48:40 <applicative> teratorn: yes the version of cabal-install you were installing has a different version of Cabal than the one you that came with ghc
19:49:40 <applicative> teratorn: it requires Cabal-1.8.*, you have Cabal-1.10.* or something
19:49:43 <teratorn> should I mail someone about http://www.haskell.org/cabal/download.html ?
19:50:13 <applicative> how do we address poor dcoutts so he finds a message? 
19:50:24 <Kaidelong> mm_freak: Out of curiousity, why is error/throw bad?
19:50:39 <Dunearhp> Is  there a path for installing the haskell-platform on ghc 7.0.3 at the moment?
19:50:44 <Kaidelong> the failure-prone computation escapes the type system?
19:50:48 <bloop> another syntax question: -> is used for type description and for case expressions. These are distinct, no?
19:51:10 <Kaidelong> I'd imagine where people use error/throw though, that's intentional
19:51:18 <Kaidelong> > head []
19:51:19 <lambdabot>   *Exception: Prelude.head: empty list
19:51:42 <applicative> Dunearhp, you can install the libraries separately.  Various delicacies may arise, depending on the platform, but even I did it, just yesterday...
19:52:45 <Kaidelong> ah this reminds me of the whole unchecked vs checked exceptions thing
19:52:52 <applicative> Dunearhp: see the source link here http://hackage.haskell.org/platform/linux.html
19:54:27 <Dunearhp> applicative: I tried it and it told me to upgrade GHC :) I'll see how I go installing the dependencies
19:54:51 <applicative> Dunearhp: 7.0.3 itself can be found here, of course http://www.haskell.org/ghc/download_ghc_7_0_3
19:54:52 <mm_freak> Kaidelong: because you need to control explicitly /when/ the exception is thrown
19:55:13 <Kaidelong> mm_freak: That sounds impossible to do in any portable way
19:55:24 <mm_freak> Kaidelong: error/throw exceptions are only thrown when forced…  throwIO exceptions are thrown when bound
19:55:25 <Kaidelong> modulo a different definition of when
19:55:26 <applicative> Dunearhp: first install that, then the Platform libraries.  
19:55:44 <mm_freak> Kaidelong: it's well possible by using 'seq' for example
19:55:47 <mm_freak> or other means to force
19:55:51 <Kaidelong> hmm, is seq portable?
19:55:55 <mm_freak> yes
19:56:02 <Kaidelong> oh I imagine it is in as far as it is in the standard
19:56:13 <Kaidelong> but didn't one haskell compiler just define seq as flip const?
19:56:30 <applicative> @type flip const
19:56:31 <lambdabot> forall b a. a -> b -> b
19:56:37 <applicative> @type seq
19:56:38 <lambdabot> forall a t. a -> t -> t
19:56:46 <mm_freak> dunno, and i'd say that's wrong
19:56:47 <applicative> awesome.
19:57:21 <mm_freak> seq is not semantically equivalent to flip const
19:57:26 <Kaidelong> yeah
19:57:29 <azaq23> @type const id
19:57:30 <lambdabot> forall a b. b -> a -> a
19:58:10 <Kaidelong> hmm
19:58:39 <Kaidelong> I guess if you make bang patterns part of the standard (is it in 2010?) you would have less excuse not to have a working seq
19:59:43 <ddarius> seq still allows the second argument to be evaluated first, it just doesn't allow the whole expression to return until both arguments are evaluated.
20:00:01 <Kaidelong> ddarius: which makes it strict in both arguments, which is still important
20:00:08 <Kaidelong> err
20:00:09 <Dunearhp> applicative: I did install ghc 7.0.3, the platform configure script didn't know what to do with it. Just found the --enable-unsupported-ghc-version option so that will probably work
20:00:13 <Kaidelong> or only in the first argument I guess
20:00:19 <Kaidelong> now that I think of it
20:00:35 <ddarius> It's strict in both arguments, but most of the time seq is used, it is used for the operational behavior which isn't guaranteed.
20:00:41 <Kaidelong> it could evaluate the second argument first, but it can return the second argument without evaluating it if it evaluates the first argument
20:00:50 <Kaidelong> ddarius: oh right!
20:00:54 <Kaidelong> I forgot the formal definition
20:01:03 <Kaidelong> it is indeed strict in both arguments
20:01:15 <Kaidelong> if it does not evaluate the right one, it still returns it if it is _|_
20:01:28 <Maxdamantus> > fix $ seq undefined
20:01:29 <lambdabot>   *Exception: Prelude.undefined
20:01:31 <Maxdamantus> > fix $ seq 42
20:01:33 <applicative> Dunearhp: yes, i used  --enable-unsupported-ghc-version.  The alternative would be to collect the git and darcs versions of all the libraries, which are presumably being updated now...
20:01:35 <lambdabot>   mueval-core: Time limit exceeded
20:07:13 <ddarius> Should I solve my problems with even more lambdas?
20:08:25 <applicative> ddarius: yes
20:08:53 <applicative> as Frege says, abstraction is a powerful lye
20:10:07 <djahandarie> ddarius, sounds like you have a lambda addiction.
20:16:55 <Guest91794> hello, I have what may be a dumb question about comparing lists
20:18:45 <Kaidelong> @src [](==)
20:18:45 <lambdabot> Source not found. Where did you learn to type?
20:18:59 <Kaidelong> I keep forgetting how to look up methods
20:19:18 <Kaidelong> @src (==)([])
20:19:18 <lambdabot> Source not found. Take a stress pill and think things over.
20:19:41 <applicative> Guest30965: what is it?
20:20:06 <Guest91794> I don't understand why [3,2,1] > [2,10,100] evaluates to true, I was thinking the 2 could be compared to 10 and be less than and thus make the whole comparison stop
20:20:14 <Kaidelong> 3 is bigger than 2
20:20:53 <applicative> Guest91794: it's a lexical comparison. like alphabetical order
20:20:58 <Guest91794> I mean I thought the first item in each list would be compared, then the second item in each list, and the third, only if the previous comparison was true
20:21:11 <Kaidelong> > "cat" > "dog"
20:21:12 <lambdabot>   False
20:21:20 <Kaidelong> > "cog" > "dog"
20:21:21 <lambdabot>   False
20:21:23 <applicative> > "aaaaaaa" > "aaaaaab"
20:21:23 <lambdabot>   False
20:21:41 <ddarius> Anonymously recursive lambda-tastic.
20:22:22 <applicative> Guest91794: so the first of your lists wins on the first entry.  
20:22:28 <applicative> or am I confused?
20:22:53 <Boxo> > [2,3] > [2,2]
20:22:53 <lambdabot>   True
20:23:04 <Kaidelong> > ((mconcat .) . zipWith compare) "cat" "cog"
20:23:05 <lambdabot>   LT
20:23:15 <applicative>  > ([3,2,1] > [2,10,100] ,  [3,2,1] > [3,10,100] )
20:23:31 <Guest91794> well i was thinking the 3 in the first list is compared to the 3 in the second list, it is greater than the 2, so then the comparison moves to the 2 and the 10 (the second items in each list)
20:23:33 <applicative> > ([3,2,1] > [2,10,100] ,  [3,2,1] > [3,10,100] )
20:23:34 <lambdabot>   (True,False)
20:23:58 <Kaidelong> Guest91794: No, it just stops, it wasn't EQ
20:24:03 <Guest91794> on the other hand, if I just do [2] > [10], it does what I expected, it evaluates to false
20:24:09 <Kaidelong> it only moves on if it has to break a tie
20:24:29 <applicative> Isn't it exactly like a dictionary?
20:24:38 <Kaidelong> > [3,3,undefined] > [3,3,3]
20:24:39 <lambdabot>   *Exception: Prelude.undefined
20:24:43 <Kaidelong> > [3,3,undefined] > [4,3,3]
20:24:44 <lambdabot>   False
20:25:03 <Kaidelong> for Guest91794 
20:26:06 <applicative> right, so Kaidelong's example shows that the evaluation doesn't bother looking at the third position.
20:26:16 <Guest91794> thinking ...
20:26:19 <Kaidelong> or second
20:26:28 <Kaidelong> > [3,3,undefined] > [4,undefined,3]
20:26:29 <lambdabot>   False
20:26:31 <Guest91794> oh
20:26:32 <applicative> > [3, undefined, undefined] > [3,3,3]
20:26:33 <lambdabot>   *Exception: Prelude.undefined
20:26:39 <applicative> > [3, undefined, undefined] > [4,3,3]
20:26:40 <lambdabot>   False
20:26:48 <Guest91794> so since the first position is true, it doesn't bother with the rest and just stops
20:26:54 <applicative> right
20:26:55 <Kaidelong> yeah
20:26:59 <Guest91794> now i get it
20:27:09 <Guest91794> told you it was a dumb question
20:27:14 <applicative> no it
20:27:18 <applicative> is a good question
20:27:26 <Kaidelong> it is the same way you order things in a dictionary
20:27:31 <Guest91794> thanks for clearing that up for me
20:27:32 <applicative> there are other possible orders.  
20:27:51 <applicative> I think this is the only one that could be general for all orderable types though
20:28:08 <applicative> oh, it could reverse them before comparing....
20:28:34 * ddarius gets bitten by mutating loop variables.
20:28:42 <Guest91794> I just mis-read the text on how the operation proceeded I guess
20:28:53 <Guest91794> (Learn You A Haskell)
20:28:56 * osoleve gets bitten by ddarius 
20:29:31 * ion gets mutated by biting loop variables
20:29:47 <ddarius> Et voila.
20:31:39 <applicative> Guest91794: the same principle is used for the comparison of pairs and other tuple types.
20:32:11 <applicative> > ("moo", 17) > ("moo", 16)
20:32:12 <lambdabot>   True
20:32:26 <applicative> > ("moo", 17) > ("mom", undefined)
20:32:26 <lambdabot>   True
20:32:54 <Guest91794> so like Kaidelong said it will only move on to "break a tie", for any kind of comparisons?
20:34:07 <applicative> Guest91794: yes, I think that's right.  I assume because no other rule could fit all cases. Of course for a particular type you can define your own comparison. 
20:34:12 <qwerty121> Hey, guys. I am new to Haskell. Is there anything wrong in this statement:  allSmall xs = [c | c<-xs , c 'elem' ['a'..'z']] 
20:34:36 <Kaidelong> well it's kind of inefficient but it should work
20:34:40 <applicative> > let  allSmall xs = [c | c<-xs , c 'elem' ['a'..'z']] in allSmall "aaa"
20:34:41 <lambdabot>   <no location info>:
20:34:41 <lambdabot>      lexical error in string/character literal at chara...
20:34:47 <Kaidelong> you could also use "all isLower"
20:34:58 <Kaidelong> > all isLower "aaa"
20:34:59 <lambdabot>   True
20:35:05 <Kaidelong> > all isLower "aaaA"
20:35:06 <lambdabot>   False
20:35:10 <applicative> > let  allSmall xs = [c | c<-xs , c `elem` ['a'..'z']] in allSmall "aaa"
20:35:10 <lambdabot>   "aaa"
20:35:10 <shachaf> I think this is filter isLower.
20:35:15 <qwerty121> Kaidelong: I am trying to make a function
20:35:23 <Kaidelong> shachaf: you are right
20:35:34 <applicative> qwerty121: you need backticks around `elem` not quotes
20:35:44 <osoleve> > filter (`elem` ['a'..'z']) "aaaaA"
20:35:45 <lambdabot>   "aaaa"
20:35:46 <qwerty121> applicative: okay. thanks :)
20:35:48 <osoleve> neat!
20:35:56 <Guest91794> incidentally I am new to Haskell AND IRC, and I think it is cool how this lambabot seems to evaluate code right here in IRC
20:36:05 <Boxo> > a 'elem' "abc"
20:36:05 <lambdabot>   <no location info>:
20:36:05 <lambdabot>      lexical error in string/character literal at chara...
20:36:06 <shachaf> It even evaluates IO commands.
20:36:10 <osoleve> Guest91794: it's actually a person
20:36:16 <Guest91794> oh
20:36:16 <Kaidelong> use isLower instead of `elem` ['a'..'z'] though
20:36:17 <Boxo> yeah, replace ' with `
20:36:25 <qwerty121> applicative:  in that case this should have wroked too  allSmall xs = [c | c<-xs , c 'elem' ['a'..'z']]
20:36:27 <qwerty121> sorry
20:36:30 <qwerty121> not that
20:36:48 <qwerty121>  allSmall xs = [c | c<-xs , elem c ['a'..'z']]
20:36:55 <qwerty121> amirite?
20:37:02 <applicative> yes, its the same
20:37:17 <applicative> > let 	allSmall xs = [c | c<-xs , elem c ['a'..'z']] in allSmall "aaa"
20:37:18 <lambdabot>   "aaa"
20:37:36 <Kaidelong> @src isLower
20:37:36 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:37:40 <Kaidelong> yep
20:37:48 <qwerty121> applicative: okay, looks like I am doing it wrong
20:37:48 <applicative> the backticks just make elem x ys into x `elem` ys
20:38:06 <applicative> as parentheses make 3 + 4 int (+) 3 4
20:38:07 <qwerty121> I am following a book called learn you a haskell, i am sure all of you have heard about
20:38:17 <qwerty121> it skips the "let " part
20:38:25 <Guest91794> qwerty i just started the same book
20:38:29 <applicative> @where lyah
20:38:29 <lambdabot> http://www.learnyouahaskell.com/
20:38:33 <applicative> good book
20:38:35 <qwerty121> Guest91794: cool *hugs*
20:38:42 <osoleve> qwerty121: the let is syntax for ghci, iirc
20:38:55 <qwerty121> osoleve: oh I see
20:38:59 <qwerty121> I am in ghci
20:39:22 <Kaidelong> osoleve: lambdabot only evaluates expressions
20:39:38 <Kaidelong> the let is binding all small, and then it gets used in an expression with in
20:39:40 <osoleve> Kaidelong: lambdabot is my hero
20:39:51 <qwerty121> Thanks guys, applicative, Kaidelong. Good time ahead :)
20:39:51 <Kaidelong> that is why the let is needed
20:40:11 <Kaidelong> it is haskell and not GHCi specific
20:40:12 <Guest91794> if lambdabot is a person that person is damn fast!
20:40:27 <Kaidelong> @commands
20:40:27 <lambdabot> Unknown command, try @list
20:40:32 <Kaidelong> @list
20:40:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:40:41 <osoleve> @karma+ Kaidelong 
20:40:42 <lambdabot> Kaidelong's karma raised to 2.
20:41:10 <Guest91794> @karma+ Kaidelong
20:41:10 <lambdabot> Kaidelong's karma raised to 3.
20:45:12 <Guest91794> thanks again, goodnight or good morning depending on where you are
21:19:17 * hackagebot TTTAS 0.4.1 - Typed Transformations of Typed Abstract Syntax  http://hackage.haskell.org/package/TTTAS-0.4.1 (MarcosViera)
22:46:31 * hackagebot TableAlgebra 0.6.1 - Ferry Table Algebra  http://hackage.haskell.org/package/TableAlgebra-0.6.1 (JeroenWeijers)
22:46:33 * hackagebot FerryCore 0.4.6.1 - Ferry Core Components  http://hackage.haskell.org/package/FerryCore-0.4.6.1 (JeroenWeijers)
23:47:41 <karp_> what is the most popular functional lazy language that is also dynamically typed?
23:48:35 <BMeph> karp_: Javascript. :)
23:48:42 <karp_> Javascript is eager
23:58:44 <c_wraith> karp_: I'm not sure there is one.  Without types, it's tough to enforce purity.  And without purity, laziness isn't much of a feature.
23:59:31 <c_wraith> actually, I suppose it's not hard to enforce purity without types...  It's just an incredible pain in the ass for the programmer.
