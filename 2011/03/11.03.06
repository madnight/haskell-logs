00:07:52 <weirdo> hey /t
00:07:54 <weirdo> oops
00:08:26 <ian_mi> copumpkin: I'm glad someone else is doing these crazy things. It feels like an abuse of haskell's type system.
00:17:06 <weirdo> i just installed ghc 7.0.2 and am trying to install leksah. however, it complains about some package "base" being of wrong version
00:18:06 <weirdo> i see now, ghc 7.0.2 has too new a 'base' package. what do i do? is leksah obsolete?
00:18:14 <weirdo> or should i use 6.8?
00:20:37 <hamishmack> weirdo: Version in https://github.com/jutaro works with ghc 7
00:20:55 <weirdo> thank you!
00:25:43 <weirdo> on another note, what's the best haskell REPL, with most bells and whistles?
00:27:37 <kosmikus> weirdo: what's wrong with ghci?
00:28:33 <weirdo> kosmikus, it's not really integrated with an editor/IDE
00:30:02 <kosmikus> oh, no idea then; my IDE is the terminal ;)
00:37:42 <Eduard_Munteanu> weirdo: some packages aren't GHC-7-ready
00:37:53 <Eduard_Munteanu> You could stick to 6.12.x until then.
00:38:17 <Eduard_Munteanu> Not, 6.8, that's old.
00:38:23 <Eduard_Munteanu> *not 6.8
00:41:55 <weirdo> that's what i'll do, thank you.
00:42:26 <Eduard_Munteanu> You should probably go the Haskell Platform way, also.
00:42:31 <Eduard_Munteanu> @where platform
00:42:32 <lambdabot> http://hackage.haskell.org/platform/
00:43:43 <ian_mi> copumpkin: traversable is great
00:43:44 <Eduard_Munteanu> (especially on Windows)
00:59:45 <weirdo> is learning haskell hard and mind-bending for a lisp/c/c#/perl programmer like me?
01:00:15 <weirdo> just realized that i need a powerful language that isn't lisp
01:00:21 <ion> Not that hard. Perhaps a bit mind-bending in a good way.
01:01:05 <weirdo> i wonder how type classes work. in c#, i had to do stuff like '(Subtype) foo' a lot
01:01:12 <weirdo> is it any different in haskell?
01:01:31 <weirdo> if so, are there any runtime type errors?
01:02:00 <ion> Forget everything you know about classes in OOP languages. Imagine they’re called pink rabbits or something. Haskell’s type classes are a different concept.
01:02:21 <weirdo> that's great :)
01:04:10 <ion> There are no runtime type errors, except if you try really hard to bend the type system, like Text.Printf.printf is doing.
01:04:17 <ion> > printf "%s" 42
01:04:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:04:19 <lambdabot>    `Text.Printf.PrintfType ...
01:04:52 <ion> > printf "%s" 42 :: String
01:04:52 <lambdabot>   "*Exception: Printf.printf: bad argument
01:06:17 <ion> I guess the best solution for printf (short of avoiding printf altogether) is Template Haskell.
01:14:40 <sayuke> how do you construct a list inside the maybe monad. For example, here I am trying to find the prime factors of a number. prime_factors n = find (\p->mod n p == 0) primes >>= \p -> return p : prime_factors (n `div` p)
01:15:08 <mreh> sounds like you might need the list monad
01:15:18 <mreh> that's a hunch
01:15:48 <sayuke> if I simply return p that line will find the first prime factor, but I want to concatenate all of them
01:16:36 <mreh> :t find
01:16:37 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
01:17:28 <dibblego> x >>= \p -> return p
01:17:29 <dibblego> x
01:17:46 <sayuke> that will return the first prime factor
01:17:56 <sayuke> how do you concatenate the rest
01:18:23 <dibblego> oh sorry I misread
01:18:29 <mreh> :t catMaybes
01:18:30 <lambdabot> forall a. [Maybe a] -> [a]
01:20:28 <mreh> sayuke: use the list monad and guard
01:20:57 <mreh> > primes
01:20:57 <lambdabot>   Not in scope: `primes'
01:21:20 <mreh> I can't remember the seive
01:22:15 <sayuke> yeah i write primes myself, its using a slightly non naive implementation
01:22:20 <sayuke> wrote*
01:24:46 <mreh> paste it in here, use the @let commadn
01:24:51 <mreh> if it's not too long
01:26:13 <sayuke> http://pastebin.com/LaW51s6b
01:26:22 <sayuke> im no haskell expert, so its not exactly elegant
01:29:06 <glguy> :t all
01:29:07 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
01:29:17 <glguy> sayuke: did you know about that function?
01:30:45 <sayuke> no
01:31:08 <sayuke> ive only started playing with haskell, going through project euler
01:31:59 * weirdo just reading "for a great good" tutorial
01:32:09 <weirdo> the type declaration for "read" is so sweet
01:33:47 <spirit> weirdo, not a surprise it's out as a book, is it?
01:34:13 <weirdo> is the book version updated compared to the online tutorial?
01:34:21 <weirdo> or the other way around?
01:34:51 <spirit> no idea.
01:37:24 <sayuke> ok I hacked around it a bit. Is there a nice way to remove my helper function? http://pastebin.com/7G4g0aCp
01:38:39 <spirit> is anyone using kate for editing haskell source code? to get the perfect settings for indentation seems a little tricky.
01:42:15 <dibblego> I use it occasionally and I gave up using it in a way that it doesn't screw up haskell
01:43:16 <spirit> so it doesn't matter what kate 'thinks'? as in the yellow highlighting and how to fold/unfold functions, classes, modules?
01:43:39 <dibblego> I just gave up, maybe you can do better
01:44:32 <dibblego> especially its strong desire you "auto-indent" (screw up) my haskell code
01:44:42 <dibblego> I couldn't find a way to tell it to stop
01:44:58 <spirit> what are you using then?
01:45:31 <dibblego> I use leksah or vim
01:45:43 <spirit> i'm totally new to haskell. used gedit for a while, but it's important to have tabs visible, so that i'm not fighting the invisible...
01:45:49 <spirit> linux?
01:46:02 <dibblego> yes
01:46:34 <spirit> how would i download leksah? tried yesterday, but it was not straigh forward
01:46:47 <dibblego> I have an install script
01:47:24 <spirit> leksah would be much better, because it's in fact a haskell project i'm working on with quite a hierarchy
01:48:07 <dibblego> http://paste.pocoo.org/show/348867/
01:48:09 <spirit> the debian 'installer' should work for ubuntu 64 bit, should it not?
01:48:26 <dibblego> I don't use ghc packages with apt-get
01:49:01 <spirit> apt-get leksah did not work anyways...
01:59:25 <weirdo> this "for great good" ebook defines a lot of stuff recursively, including a length function. does that mean that the stack doesn't grow in haskell, or is it just teaching newbies bad habits? :)
02:00:00 <ion> Look up tail call optimization.
02:00:27 <weirdo> i know about it, but stuff in the book isn't in tail position
02:00:28 <weirdo> like this:
02:00:29 <ion> Many compilers/interpreters for many languages do it.
02:00:44 <weirdo> length' (_:xs) = 1 + length' xs
02:00:55 <weirdo> there is no accumulator value, hence no TCO
02:01:09 <mreh> weirdo: the option is still there though
02:01:35 <mreh> that's more readable though, so I suspect that's why they did it that way
02:02:02 <mreh> it's certainly more declarative
02:04:59 <spirit> dibblego, i encountered one error during installation attempt. glib-0.11.2 caused it: glib-0.11.2 which failed to install.
02:04:59 <spirit> --2011-03-06 10:39:48--  http://code.haskell.org/leksah-head/leksah/data/.gtkrc-2.0
02:04:59 <spirit> Resolving code.haskell.org... 178.63.91.44, 2a01:4f8:121:6::1:10
02:04:59 <spirit> Connecting to code.haskell.org|178.63.91.44|:80... connected.
02:04:59 <spirit> HTTP request sent, awaiting response... 404 Not Found
02:05:01 <spirit> 2011-03-06 10:39:48 ERROR 404: Not Found.
02:05:56 <dibblego> http://paste.pocoo.org/show/348873/
02:07:21 <spirit> the close button style fixes the glib issue?
02:07:33 <dibblego> no I don't know about that one
02:08:23 <spirit> ah -- so where to put the style stuff?
02:08:41 <dibblego> ~/
02:08:46 <dibblego> ~/.gtkrc-2.0
02:12:08 <spirit> http://code.haskell.org/leksah-head/leksah/data/.gtkrc-2.0 not found
02:18:13 <fram> damned I got the GHC panic again, I forgot the command to see what file ghc-pkg is reading
02:24:10 <mreh> that's more readable though, so I suspect that's why they did it that way
02:24:17 <mreh> oops
02:25:35 <sdaffer> i am sullen that xmonad is written in haskel
02:49:42 <spirit> dibblego, i was missing gtk build tools earlier on, leksah installed fine now. do you know where to?
02:50:48 <dibblego> ~/.cabal/bin/leksah
02:52:08 <mreh> is an STArray/STUArray an STRef already?
02:53:00 <sipa> STRef is a type, not a class
02:53:34 <mreh> I'm being casual with my use of language
02:54:03 <c_wraith> mreh: It's mutable cell in ST
02:54:19 <c_wraith> well, an STArray is a bunch of mutable cells
02:54:26 <mreh> c_wraith: thank god for that, I just wrote a load of code, then read about STRefs
02:59:58 <spirit> dibblego, great :-) and the default haskell path? 'haskell sources for packages'?
03:00:21 <dibblego> it's all in ~/.cabal
03:00:45 <spirit> would that be .cabal
03:00:57 <spirit> or ~/.cabal/bin?
03:02:37 <spirit> dibblego, encountered this error 'leksah: internal IDE error: Can't connect to leksah-server'
03:04:58 <hamishmack> spirit: Make sure  ~/.cabal/bin is in your PATH
03:08:21 <weirdo> is there efficient call/cc in haskell?
03:10:58 <spirit> hamishmack, do i need to escape the '.'? i added /home/username/.cabal/bin to .bashrc_profile but it says it cannot find it... when cd-ing into /home/username/.cabal/bin it's there though
03:13:35 <hamishmack> are you launching leksah from bash?  Did you start a new bash after modifying .bashrc_profile?
03:18:34 <Eduard_Munteanu> weirdo: you can do call/cc in the Cont monad.
03:19:47 <spirit> i did start new terminal after changing .bashrc_profile. when i type in '$PATH' it tells me it cannot find the ~/.cabal/bin part of it, hamishmack
03:20:00 <Eduard_Munteanu> As for efficiency, IDK exactly what you're concerned about, but continuations and CPS are quite fast in Haskell
03:20:17 <mauke> spirit: what's the actual command you typed and the error message?
03:20:33 <weirdo> leksah says segmentation fault :(
03:21:00 <weirdo> segmentation fault/access violation in generated code
03:21:04 <spirit> mauke, the 1st problem seems to be i don't know how to add a hidden dir to my path in .bashrc_profile
03:21:16 <mauke> spirit: why are you talking at me?
03:21:22 <Eduard_Munteanu> Hidden?
03:21:32 <spirit> sorry
03:22:12 <spirit> '/home/username/.cabal/bin: No such file or directory' is the error message
03:22:22 <Eduard_Munteanu> Do you mean one that starts with a dot? If so, it makes no difference.
03:22:28 <mauke> and the command?
03:22:55 <spirit> the command was '$PATH' in order to check what $PATH is set to
03:23:04 <mauke> ... that's not how it works
03:23:05 <Eduard_Munteanu> That's not how you check it.
03:23:12 <spirit> it seems fine, but it cannot find the last bit, the .cabal/bin
03:23:15 <Eduard_Munteanu> 'echo $PATH' is more like it
03:23:20 <weirdo> can i make haskell dump a core in windows?
03:23:35 <spirit> ok, that works -- echo $PATH
03:24:34 <Eduard_Munteanu> weirdo: I don't think that helps much. What GHC version are you using?
03:24:54 <hamishmack> spirit: I think the PATH is probably ok
03:25:21 <spirit> yes, thanks a lot, it seems all fine now :-)
03:26:20 <weirdo> Eduard_Munteanu, haskell platform one
03:27:18 <Eduard_Munteanu> weirdo: and you built Leksah by cabal-install?
03:27:23 <weirdo> Eduard_Munteanu, yes
03:27:32 <Eduard_Munteanu> Did you 'cabal update' first?
03:27:41 <weirdo> yes, i just installed haskell platform today
03:28:22 <Eduard_Munteanu> Ok. Is this really Windows, or Wine? (I've had some problems myself with that.)
03:28:45 <weirdo> windows
03:29:26 <monadic_kid^> weirdo: there is a pre-built version for windows
03:29:31 <Eduard_Munteanu> Could you copy&paste the error message? Maybe Google helps.
03:30:24 <weirdo> there is? great :)
03:31:00 <weirdo> btw, is there some newer stuff in the one github one?
03:31:09 <weirdo> or is it just for ghc-7 compat?
03:31:56 <monadic_kid^> version 0.8.0.6 for Ghc 6.12.1 but probably works for newer versions http://leksah.org/packages/leksah-0.8.0.6.exe
03:32:51 <hamishmack> monadic_kid^: actually there is an unofficial version http://leksah.org/packages/leksah-0.8.0.6.exe that works better with ghc 6.12.3
03:33:33 <monadic_kid^> hamishmack: how is that different than the link i've provided
03:33:37 <hamishmack> Sorry meant to change the url to http://leksah.org/packages/leksah-0.9.0.0.exe
03:38:25 <weirdo> thank you all
03:38:36 <weirdo> i'm grabbing the github one that hamishmack suggested earlier
03:38:37 <weirdo> is it ok?
03:38:40 <hamishmack> weirdo: github code should work on ghc 6.12 and 7.0
03:39:22 * hackagebot combinatorial-problems 0.0.1 - A number of data structures to represent and allow the manipulation of standard combinatorial problems, used as test problems in computer science.  http://hackage.haskell.org/package/combinatorial-problems-0.0.1 (RichardSenington)
03:41:55 <hamishmack> weirdo: I would recommend using the prebuilt leksah-0.9.0.0.exe and ghc 6.12.3 on windows
03:42:34 <weirdo> okay
03:43:55 <hamishmack> weirdo: I am actually installing GHC 7.0.2 on my windows VM right now.  If it goes really well I may upload a new Leksah installer today
03:44:39 <weirdo> compiling stuff under mingw is a pain :|
03:45:34 <hamishmack> weirdo: TakeoffGW is quite nice
03:46:43 <dom1> I am logged in to code.haskell.org and want to create a new repo for a package I have created
03:46:52 <weirdo> btw, is templatehaskell good?
03:46:52 <Eduard_Munteanu> It probably is if you're not used to Unix-like environments. Also, the Windows shell makes it sucky.
03:47:06 <weirdo> does it break IDE autoident?
03:47:08 <dom1> But I don't seem to have permissions to create a directory /srv/code/largeword
03:47:13 <Eduard_Munteanu> weirdo: TH is a feature, not some other version
03:47:26 <dom1> Is there a wiki page somewhere that tells me how to set things up?
03:47:27 <Eduard_Munteanu> weirdo: as in a language feature
03:47:39 <weirdo> it's great such a thing exists
03:47:45 <weirdo> i'm used to doing stuff declaratively
03:47:56 <weirdo> and not faking everything with anonymous functions
03:48:00 <Eduard_Munteanu> It's not really easy to use, though.
03:48:28 <weirdo> oh by the way, does haskell have named function parameters?
03:48:33 <weirdo> it's another thing i love
03:48:42 <Eduard_Munteanu> Named? What do you mean?
03:48:43 <mauke> there's a library for that
03:48:49 <mauke> olegware
03:48:55 <Eduard_Munteanu> They are named... f x y = ...
03:50:09 <weirdo> stuff like (make-instance 'foo :bar 42 :baz 37)
03:50:32 <mauke> weirdo: how would that work with partial application?
03:51:03 <weirdo> mauke, putting keyword parameters first
03:51:05 <Eduard_Munteanu> I'm not familiar with Lithp, but I'm sure you can fake it somehow.
03:51:14 <spirit> inside leksah, the buttons 'source, modules, refs, docu, search' don't do anything. the editor shows my source code, i chose 'workspace' in upper right, but i don't know how to compile/interpret it
03:51:15 <Eduard_Munteanu> (if I got your intention)
03:52:20 <Eduard_Munteanu> Maybe something like fclabels or extensible records help.
03:52:36 <Eduard_Munteanu> (but it'd be in the uncurried form)
03:52:36 <weirdo> do records have literal syntax like {}?
03:52:39 <monadic_kid^> ocaml supports named parameters
03:52:42 <hamishmack> spirit: Do you already have a .cabal file?
03:53:04 <Eduard_Munteanu> weirdo: yes, though I'm not exactly sure of your question
03:53:21 <weirdo> i could do stuff like myFunction { foo: 42, bar: 69 }
03:53:30 <spirit> i have a .cabal directory
03:53:46 <spirit> did ghc-pkg recache after installation
03:53:50 <monadic_kid^> spirit: the module browser only works if you setup the path to source packages correctly , first make a worpspace then make a new package, then add new module
03:53:52 <weirdo> as long as i wouldn't have to declare every record type
03:54:08 <hamishmack> spirit: cabal packages always have a *.cabal file
03:54:10 <mauke> weirdo: you would
03:54:14 <Eduard_Munteanu> Yeah, but what if you supply only 'foo'? As mauke says, the harder part is getting partial application to work
03:54:36 <spirit> ah, i see :-) so it is indeed an ide :-) (sorry for being so slow)
03:54:41 <hamishmack> spirit: You should make a workspace then create a new package and click save
03:54:50 <weirdo> then i'll fake it with template haskell :) since i only need it for macros
03:54:58 <mauke> weirdo: http://okmij.org/ftp/Haskell/polyvariadic.html#keyword-args
03:55:12 <hamishmack> spirit: It's a bit clunky in 0.8.0.6 and has been improved somewhat in 0.9.0.0
03:55:14 <Eduard_Munteanu> Ideally you could do stuff like    (myFunction { foo: 42 }) {bar: 69}    (in your syntax)
03:55:45 <spirit> 0.9.0.0 not available yet, is it?
03:55:59 <Eduard_Munteanu> Ah, Oleg's place is always a treasure.
03:56:09 <hamishmack> spirit: It is not in Hackage DB yet
03:56:15 <spirit> ok
03:56:27 <spirit> so i cannot install it via cabal yet?
03:58:03 <weirdo> who's oleg?
03:58:08 <hamishmack> spirit: Not yet.  If you do Worksapce -> New Workspace followed by Package -> New Package you should be ok though.
03:58:09 <mreh> making a wrapper around STArray for images is very frustrating
03:58:51 <Kaidelong> Oleg Kiselyov
03:58:53 <spirit> a dir haskell-dev which holds dirs for each of my projects aka packages, would that be an advisable structure?
03:59:02 <Kaidelong> some kind of Haskell religious figure
03:59:15 <Kaidelong> mm I wonder
03:59:16 <Eduard_Munteanu> Nobody knows his true nature.
03:59:19 <Kaidelong> @quote RSA
03:59:19 <lambdabot> Robert_Dockins says: A Turing-complete type-checker isn't enough!  Our work is not complete until the parser is a universal machine as well!
03:59:26 <mreh> @quote oleg
03:59:26 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
03:59:32 <vegai> is he like Rasputin?
03:59:35 <mreh> @quote oleg already
03:59:35 <lambdabot> No quotes match. Just what do you think you're doing Dave?
03:59:49 <Eduard_Munteanu> I hear he used to come in here.
03:59:49 <Kaidelong> @quote oleg RSA
03:59:49 <lambdabot> No quotes match.
03:59:52 <Kaidelong> bah
03:59:55 <olsner> @quote oleg.*RSA
03:59:55 <lambdabot> No quotes match. Take a stress pill and think things over.
03:59:56 <Eduard_Munteanu> He probably ascended in the meanwhile.
04:00:26 <Kaidelong> I remember reading something like "implementing RSA in the type system is left for future work"
04:00:34 <Eduard_Munteanu> Heh.
04:00:44 <Eduard_Munteanu> Maybe on the ML.
04:00:45 <sipa> haha
04:01:04 <Kaidelong> Eduard_Munteanu: Apparently the haskell type system is good enough for that
04:01:15 <mreh> that's another 2001 quote
04:01:17 <Kaidelong> and by implementing it in there you prove that it is reversible!
04:01:29 <monadic_kid^> mreh: why not use a storable array or vector package?
04:01:32 <weirdo> how would you write the following lisp pseudocode? (define-packet (packet :opcode 1 :type :registered) (do-something-with packet))?
04:01:45 <mreh> monadic_kid^: I don't know... tell me :)
04:01:47 <weirdo> i'm thinking of a declarative way to, well, declare stuff in haskell
04:01:52 <mauke> @quote RSA
04:01:52 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
04:01:53 <lambdabot> like learn $ zip math haskell.
04:02:26 <olsner> @quote rsa.on.type
04:02:26 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
04:02:38 <Kaidelong> there we go
04:02:38 * Eduard_Munteanu notices some sort of Cantor argument there :)
04:02:50 <Eduard_Munteanu> Ah.
04:02:56 <Kaidelong> weirdo: What exactly does that do?
04:03:06 <Kaidelong> I'd like to try and help but I do not really know LISP very well
04:03:28 <spirit> once i have the workspace and the package, package inside folder with all my source files, do i then save? the button does not seem do much...
04:03:32 <spirit> leksah
04:04:33 <Eduard_Munteanu> I doubt Haskell's type system is expressive enough for such computations.
04:04:47 <Kaidelong> Eduard_Munteanu: you have to use peano numbers
04:04:51 <hamishmack> spirit: Yes press save.
04:05:06 <weirdo> Kaidelong, it's a sample macro call. by itself, it doesn't do anything. it *could* put 'do-something-with packet' inside an anonymous function and put it in *hash-table* as a third element of a tuple, first being opcode 1, second being type registered
04:05:08 <Eduard_Munteanu> Well yes, as long as you find a good abstraction for writing those operations.
04:05:40 <Kaidelong> weirdo: So what would its Haskell type be?
04:05:42 <hamishmack> spirit: You should be able to do Package -> Configure followed by Package -> Build
04:05:59 <Eduard_Munteanu> And well, let's exclude types reified through data, that's not fair :P
04:06:02 <weirdo> Kaidelong, it would be imperative, like <-, i believe
04:06:05 <spirit> what do i do after pressing save? i have a name and a version for the package, but no other info yet. more req'd?
04:06:44 <Kaidelong> umm, so something along the lines of "a -> ST ()"?
04:06:48 <Eduard_Munteanu> BTW, has anyone proven where Haskell's type system stands computationally? It's not Turing-complete.
04:06:52 <Kaidelong> or even just "ST ()"
04:06:58 <sipa> Kaidelong: return ()?
04:07:03 <c_wraith> @kind ST
04:07:04 <Eduard_Munteanu> I wonder if it's at least total.
04:07:04 <lambdabot> * -> * -> *
04:07:10 <Kaidelong> Eduard_Munteanu: I think it is, actually. Glasgow Haskell limits it specifically so that it isn't
04:07:25 <Kaidelong> but some extensions in Glasgow Haskell make it undecidable again
04:07:50 <Kaidelong> (it is turing complete, not total)
04:08:26 <sphynx> hi all!
04:08:38 <Eduard_Munteanu> Hrm, I'm not sure decidability is the thing here. Yes, rank-N breaks inference, but does that tell anything about what computations you can do?
04:08:45 <Kaidelong> or was it that the H98 type system was just barely decidable?
04:08:50 <Kaidelong> I forgot
04:09:37 <Eduard_Munteanu> H98 allows for full inference.
04:09:40 <Kaidelong> from what I remember, it was turing complete although it was never intended to be, and there is some kind of a combination of a hard recursion limit and other extra limitations
04:09:43 <spirit> i pressed 'close' after 'save' -- inside leksah, after i tried to tell it about my first package...
04:09:45 <Eduard_Munteanu> (and H' too)
04:09:48 <spirit> now it's all 'gone'
04:09:50 <mauke> Eduard_Munteanu: I'm pretty sure that's wrong
04:10:06 <mauke> Kaidelong: that sounds like C++
04:10:12 <augustss> Eduard_Munteanu: H-M is already very close to being Turing complete.
04:10:20 <Eduard_Munteanu> Erm, yeah, up to ambiguity, e.g. do you want Ints or Doubles?
04:10:33 <mauke> Eduard_Munteanu: no, I mean polymorphic recursion
04:10:35 <augustss> Eduard_Munteanu: H-M is equivalent to Turining machines with finite tapes.
04:10:37 <Kaidelong> sipa: Right
04:10:46 <Eduard_Munteanu> I see.
04:10:48 <Kaidelong> dummy thread variable thing
04:10:51 <Kaidelong> I always forget that
04:11:00 <hamishmack> Try creating a new package in an empty folder (select the empty folder when you asked for a location)
04:11:29 <Eduard_Munteanu> But I suppose doing arbitrary computations is still pretty hard.
04:11:30 <hamishmack> spirit: It should create a Main.hs file and etc.
04:11:34 <Kaidelong> weirdo: Could you explain what you are trying to accomplish there? As in, what the goal is.
04:11:51 <spirit> why a new package in an empty folder?
04:12:03 <spirit> i have lots of source code i want to turn into a package
04:12:04 <augustss> Eduard_Munteanu: Yes, but I'm sure you could built some handy type definitions to make it simpler. :)
04:12:23 <Eduard_Munteanu> mauke: could you expand on that? ... unless you mean stuff that implies impredicativity / rank-2/n
04:12:39 <hamishmack> spirit: It sounded like you might have been trying to create it in a folder with source already in it?
04:12:51 <spirit> yes, with source code in it
04:12:55 <spirit> so that was no good?
04:13:00 <spirit> will try again in empty folder
04:13:00 <weirdo> Kaidelong, have a nice syntax to declare some handler, e.g. code that handles a packet, or serves a web site
04:13:10 <Kaidelong> ah
04:13:25 <mauke> > let foo :: (Show a) => Int -> a -> String; foo n x | n <= 0 = show x | otherwise = foo (n - 1) (x, x) in foo 3 'A'
04:13:26 <lambdabot>   "((('A','A'),('A','A')),(('A','A'),('A','A')))"
04:13:47 <hamishmack> spirit: http://www.youtube.com/watch?v=Gk8MgmT8BDY
04:13:52 <Kaidelong> weirdo: Could you perhaps do it using "data"?
04:14:22 <Kaidelong> IE use infix/prefix constructors to build up an AST
04:14:30 <Kaidelong> and then generate the handler from it
04:14:49 <Kaidelong> might not be as pretty as what you could do with macros though
04:14:55 <Kaidelong> then there is template haskell
04:15:07 <Kaidelong> which I know nothing about
04:15:22 <weirdo> i'll probably go for template haskell
04:15:24 <weirdo> brb, phone
04:15:31 <Eduard_Munteanu> mauke: ah, makes sense, thanks.
04:15:42 <spirit> i found files foo.cabal and Setup.lhs inside the empty dir i chose for my first leksah package
04:15:53 <Kaidelong> weirdo: If you want imperative looking syntax, perhaps you might also be able to exploit the do sugar
04:16:04 <ceii_> spirit: that's the basic scaffolding for a Haskell project
04:16:54 <Eduard_Munteanu> Are we getting compiler support for Peanos any time soon?
04:17:03 <ceii_> foo.cabal is the package description, Setup.lhs is a sort for makefile on steroids
04:17:10 <ceii_> sort of*
04:17:24 <spirit> ok, but save button is not responsive. i also did package->configurepackage followed by package->buildpackage
04:17:32 <Kaidelong> Eduard_Munteanu: What's lacking now?
04:18:04 <Eduard_Munteanu> Kaidelong: well, it's a bit silly to define Fourteen as S (S (S .... Z ... )))
04:18:17 <Kaidelong> oh you mean sugar
04:18:24 <Kaidelong> Mm
04:18:28 <Kaidelong> that might be quite handy
04:18:37 <Eduard_Munteanu> I heard people were working on that.
04:18:47 <mauke> $(peano 14)
04:19:00 <Eduard_Munteanu> mauke: TH?
04:19:04 <mauke> yeah
04:19:21 <Eduard_Munteanu> Hrm, that does it I think.
04:19:52 <c_wraith> actually, it looks like there are patches likely to go into GHC 7.2 that enable an extension for type-level naturals.
04:20:06 <Eduard_Munteanu> Hm, I knew I heard something about that.
04:20:07 <mauke> instance Num Peano where fromInteger n | n <= 0 = Z | otherwise = S (fromInteger (n - 1))
04:21:03 <Eduard_Munteanu> I was a bit puzzled by a Hackage package that didn't need rank-2 types for converting Peanos to integers. :/
04:21:13 <hamishmack> spirit: What shows up in the Log pane?
04:21:39 <Eduard_Munteanu> @hoogle Data.Naturals
04:21:40 <lambdabot> No results found
04:21:42 <Eduard_Munteanu> @hoogle Data.Natural
04:21:42 <lambdabot> No results found
04:21:49 <Eduard_Munteanu> Anyway.
04:22:25 <Eduard_Munteanu> I remember I couldn't do that without a rank-2.
04:22:30 <mauke> class ToInt a where toInt :: a -> Int
04:22:50 <Eduard_Munteanu> Maybe the explanation is it only works with classes?
04:23:16 <mauke> instance ToInt Z where toInt = const 0; instance (ToInt a) => ToInt (S a) where toInt = const (succ (toInt (undefined :: a)))
04:24:23 <Eduard_Munteanu> Strange... I remember #haskell-ers suggesting rank-2s like there was no alternative.
04:24:42 <spirit> o dear, earlier on i switched to workspace pane... did not see error messages in log pane: user error (Parse of field 'name' failed)
04:24:44 <boegel> mailing lists are so quiet...?
04:25:37 <Eduard_Munteanu> It's still a bit puzzling that you can do Peano <-> Int back and forth even at runtime. There must be some reification (aka "cheating" in this context) going on.
04:25:58 <mauke> wait, are you talking about type-level naturals or not?
04:26:02 <c_wraith> type classes *are* reification
04:26:47 <Eduard_Munteanu> mauke: yes, type-level, not data.
04:26:58 <Eduard_Munteanu> c_wraith: ah, that explains it then.
04:26:58 <c_wraith> Fundamentally, classes use types as hidden function arguments.
04:27:10 <Eduard_Munteanu> Yeah, the dictionaries.
04:27:53 <c_wraith> Well, that's an implementation detail...  But it is rather instructive for thinking about the more general concept I was attempting to imply :)
04:28:21 <Eduard_Munteanu> But if this gets you reification, do you still get compile-time guarantees?
04:28:32 <Eduard_Munteanu> e.g. when implementing sized lists / vectors
04:28:38 <c_wraith> Not always.
04:28:43 <monadic_kid^> i've read jhc doesn't use dictionary passing, but something more like templates although that may not be the case now
04:28:50 <mauke> you can't easily convert Int -> type-level naturals
04:28:57 <mauke> that's what requires rank-2 AFAIK
04:29:06 <Eduard_Munteanu> Yeah.
04:29:15 <Eduard_Munteanu> (erm, actually I don't remember)
04:29:23 <Kaidelong> how'd you even type that
04:29:26 <c_wraith> monadic_kid^: with the Inlinable pragma in GHC 7, you can make GHC do a very similar thing
04:29:49 <Kaidelong> you'd have a unique type for every integer and thus a data dependency
04:30:11 <mauke> foo :: Int -> (exists a. Peano a => a)
04:30:17 <Kaidelong> oh
04:30:21 <monadic_kid^> well type families have a lot more in common with templates, and template specialization
04:30:22 <Kaidelong> herp
04:30:54 <Eduard_Munteanu> Well, that's a real exists, not a forall, you can convert.
04:31:12 <Kaidelong> mauke: How'd you find out which peano number it is, though?
04:31:36 <Eduard_Munteanu> Kaidelong: (==), or convert back?
04:31:49 <Kaidelong> hmm, type level ==?
04:31:50 <Eduard_Munteanu> Oh, I misread you.
04:32:07 <Eduard_Munteanu> It's still backed by some data representation.
04:33:06 <Eduard_Munteanu> (S a) == (S b) = a == b
04:33:15 <Eduard_Munteanu> and cases for Z, too.
04:33:29 <Kaidelong> (S (S Z)) == (S Z) then?
04:33:49 <Kaidelong> that'd not be very useful
04:33:53 <Eduard_Munteanu> Why?
04:33:55 <Kaidelong> ooh
04:34:00 <Kaidelong> =>
04:34:05 <Kaidelong> or <=>
04:34:11 <Kaidelong> or <=
04:34:16 <Kaidelong> is what you meant
04:34:16 <Eduard_Munteanu> Um?
04:34:18 <Kaidelong> any one works
04:34:22 <Eduard_Munteanu> No :)
04:34:53 <Kaidelong> so you really are saying that a unifies with S a which unifies with S b which unifies with b?
04:34:54 <mauke> why does it have a data representation?
04:35:08 <Kaidelong> or are you saying that one implies the other?
04:35:14 <Kaidelong> and vice versa
04:35:16 <mauke> Kaidelong: no, he said (S a) == (S b) is defined as a == b
04:35:21 <Eduard_Munteanu> (S (S Z)) == (S Z)   =    (S Z) == Z    = False
04:36:21 <Kaidelong> alright, I think I see now
04:36:43 <mauke> but that would still require a type-level ==
04:37:23 <Eduard_Munteanu> Oh, right, I can see why.
04:37:32 * Eduard_Munteanu wonders if '~' does it
04:37:42 <c_wraith> ~ is a compile-time check
04:37:50 <Eduard_Munteanu> Types are compile-time :)
04:38:01 <mauke> I beg to differ
04:38:15 <Eduard_Munteanu> Um, aren't they erased?
04:38:16 <Kaidelong> you can't introduce data dependencies at compile time
04:38:28 <Kaidelong> Eduard_Munteanu: not absolutely
04:38:29 <Eduard_Munteanu> Kaidelong: and that's why you want compile-time guarantees :)
04:38:30 <mauke> > let foo :: (Show a) => Int -> a -> String; foo n x | n <= 0 = show x | otherwise = foo (n - 1) (x, x) in foo 3 'A'
04:38:31 <lambdabot>   "((('A','A'),('A','A')),(('A','A'),('A','A')))"
04:38:37 <mauke> what if I call foo with user input?
04:39:15 <Kaidelong> Eduard_Munteanu: right but the whole "Int -> (exists a. Peano a)" thing is explicitly about thwarting compile time checks
04:39:22 <Eduard_Munteanu> Um, yeah, though that's just dictionary, it isn't true RTTI.
04:39:29 <Eduard_Munteanu> Yeah.
04:39:49 <Eduard_Munteanu> It's still a dirty trick.
04:39:52 <Kaidelong> although I guess since you can't actually ever find out what the result is
04:39:54 <c_wraith> Amusingly, the proposed extension introduces a new kind, type, *and* value
04:40:09 <Kaidelong> perhaps you could just optimize it away
04:40:15 <Kaidelong> unless I'm wrong on that
04:40:16 <c_wraith> That's right!  type-level naturals get their own kind, in the extension
04:40:22 <Eduard_Munteanu> Kaidelong: you can, if you put a Show constraint, for instance.
04:40:32 <Eduard_Munteanu> c_wraith: ah, nice
04:40:46 <spirit> user error name field (leksah) solved, cabal does not accept '_' good to know that :-)
04:41:14 <c_wraith> oh yeah.  that makes cabal error in an ugly way
04:41:15 <Eduard_Munteanu> Kaidelong: you can pass a continuation which does 'see' the value, but it can't expose it. Much like ST.
04:42:07 <c_wraith> isn't that exactly what existentials do?
04:42:21 <Eduard_Munteanu> It is an existential.
04:43:52 <Kaidelong> Eduard_Munteanu: undefined :: S (S (S (S (Z))))
04:43:54 <Kaidelong> =p
04:44:08 <Eduard_Munteanu> Ok, so the bottom line is, if you want assurances when you right code like Vector, don't play rank-2/typeclasses tricks.
04:44:12 <Eduard_Munteanu> Right?
04:44:17 <Eduard_Munteanu> Heh.
04:44:24 <c_wraith> What about when I wrong it?
04:44:29 <drbean> Right.
04:44:40 <Eduard_Munteanu> s/right/write/
04:45:14 <weirdo> Can't activate package C:\Users\sthalik\leksah-workspace\Setup.lhs: 1: user error (unrecognised field or section: "#!/usr/bin/runhaskell")
04:45:15 <Eduard_Munteanu> (case-sensitive 'sed' command ^^) :)
04:45:16 <Kaidelong> I can't remember when last I used SED
04:45:17 <weirdo> what's wrong?
04:45:19 <Kaidelong> sed
04:45:20 <weirdo> :-(
04:45:32 <paczesiowa> what's the most popular record library?
04:46:24 <c_wraith> weirdo: Try just removing the first line of that file.  It does nothing on windows
04:46:29 <Kaidelong> weirdo: I imagine hashbangs aren't very good on windows
04:46:35 <Axman6> paczesiowa: iTunes >_>
04:46:36 <Kaidelong> what c_wraith said
04:47:43 <weirdo> will i have to do that for every single package i create?
04:47:48 <paczesiowa> Axman6: it should work on linux and be free software:)
04:47:51 <Eduard_Munteanu> Hrm, we should have a true 'exists' in Haskell. Even if it can't infer the 'forall' form always.
04:48:10 <Kaidelong> or meshwow I suppose
04:48:13 <hamishmack> weirdo: Actually don't remove it.
04:48:18 * Axman6 notes that iTunes is free
04:48:25 <Kaidelong> meshwow doesn't have quite the same pizzaz as hashbang though
04:48:43 <hamishmack> weirdo: Leksah 0.8 uses runhaskell Setup.lhs to configure and build etc.
04:49:05 <weirdo> what do i do, then?
04:49:09 <paczesiowa> Axman6: at least 'RMS free' (preferably even more)
04:49:20 <Kaidelong> weirdo: Just remove that line
04:49:24 <hamishmack> It looks like runhaskell is not in your PATH
04:49:34 <Axman6> RMS free isn't free at all imo, but we shouldn't get into this >_>
04:49:38 <Kaidelong> hamishmack: He is on windows
04:49:41 <Eduard_Munteanu> hamishmack: he's on Win...
04:49:42 <Eduard_Munteanu> damn
04:50:09 <spirit> how do i go about re-opening a package in leksah? i pressed ctrl-s earlier on and then leksah disappeared/crashed.
04:50:11 <paczesiowa> Axman6: yes, let's get back to library that makes nested record usable
04:50:12 <Kaidelong> that said, if he is in some unix environment on windows, perhaps the path might matter
04:50:35 <weirdo> hamishmack, can i edit some leksah template so the line doesn't get added automatically?
04:50:40 <Eduard_Munteanu> Yeah, MSYS' bash or Cygwin (though that's really old).
04:51:26 <hamishmack> Kaidelong: I know but Leksah still calls runhaskell on windows (github version calls cabal)
04:51:58 <Kaidelong> easy way to test would be to see what runhaskell does on the shell
04:52:04 <Kaidelong> or alternatively
04:52:15 <Kaidelong> err, actually, I forgot how to do that on DOS
04:52:40 <Kaidelong> was it something like SETENV | SEARCHSTR "PATH"?
04:52:53 <Eduard_Munteanu> Does it have pipes? :)
04:52:58 <Kaidelong> Eduard_Munteanu: yeah
04:53:28 <hamishmack> spirit: Right click in the WOrkspace and choose "Add Package" then select the *.cabal file
04:53:58 <Eduard_Munteanu> Maybe that should read #!runhaskell
04:54:10 <Eduard_Munteanu> if runhaskell is in $PATH
04:54:40 <weirdo> #!/usr/bin/env runhaskell
04:54:59 <Eduard_Munteanu> Did that work?
04:55:29 <spirit> i have 2 workspaces, one foo.lkshs and one foo.lkshw one. i cannot right click after i have opened them
04:55:53 * Eduard_Munteanu whispers something about Vim
04:56:23 <weirdo> no
04:56:29 <weirdo> even if i remove that line, it's the same
04:56:31 <Eduard_Munteanu> *
04:56:35 <Eduard_Munteanu> **viiiiim***
04:56:48 <weirdo> i'd rather use emacs, but it still sucks
04:57:01 <Eduard_Munteanu> *emaaaacs*
04:57:44 <Eduard_Munteanu> No, really, it's perfectly doable to just use an editor and shell instead of an IDE.
04:58:40 <Eduard_Munteanu> (many developers do that anyway)
04:58:48 <Kaidelong> by the way
04:58:57 <Kaidelong> SET | FINDSTR "PATH"
04:59:19 <weirdo> i could always set it up on a linux vmware, still
04:59:27 <hamishmack> spirit: Do Workspace -> Open Workspace and select the .lkshw file
05:00:05 <Eduard_Munteanu> *plain eeeedddd*
05:00:09 <Eduard_Munteanu> :P
05:00:28 <Kaidelong> weirdo: I'd recommend using the leksah installer for windows. It worked for me without any problems
05:00:29 <Kaidelong> although I remember being very unhappy with leksah itself and going back to a text editor
05:01:44 * Eduard_Munteanu was also going to recommend an atomic force microscope and a fine needle, if everything else failed, in the spirit of xkcd
05:02:27 <spirit> best to delete the .lkshs file? or is that needed too? i have added the package now. do i then just open files via file-open? how would i add source files?
05:02:36 <Jonno_FTW> I am trying to compile lambdabot and I get the error: <command line>: unknown package: tagsoup-0.10
05:02:53 <Jonno_FTW> even though I get: Loading package tagsoup-0.12 ... linking ... done.
05:03:00 <Jonno_FTW> in the a few lines earlier
05:03:22 <hamishmack> spirit: To add new modules right click in the module tree and choose Add Module
05:04:19 <spirit> ah... is it ok to just copy my source files into the src folder of the package i just built?
05:05:10 <hamishmack> spirit: Sure
05:05:34 <hamishmack> spirit: then reference them from Main.hs and they will get built
05:06:04 <spirit> as in import module1 import module2... ?
05:06:20 <hamishmack> weirdo: What happens if you open a Command Prompt window and enter "runhaskell --version"?
05:06:26 <hamishmack> spirit: yes
05:07:22 <hamishmack> spirit: .lkshs is the session file.  It stores what files you have open etc.
05:07:31 <spirit> ah, great :-)
05:10:14 <hpaste> haskellnoob pasted "Reading two numbers from input"  http://hpaste.org/44561
05:11:50 <hpaste> haskellnoob pasted "Reading two numbers from input (annotation)"  http://hpaste.org/44562
05:15:34 <Kaidelong> @ty readInt
05:15:34 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
05:16:07 <haskellnoob> Hi. I am trying to read in two numbers from the input. Here is my code, which gives a compilation error (as mentioned there) : http://hpaste.org/44562/reading_two_numbers_from_input . How do I fix this?
05:17:16 <monadic_kid> haskellnoob: bindings are not visible in a where clause
05:17:22 <haskellnoob> Well, I forgot to mention the error there; the error is: input is not in scope at line 3
05:17:27 <Axman6> haskellnoob: input isn't in scope in the where clause
05:17:38 <Axman6> you'd need to use let there
05:17:42 <monadic_kid> haskellnoob: *bindings in a do-expresison are not visible in a where clause
05:17:59 <haskellnoob> all: thanks. Axman6: how do I use a let there?
05:18:39 <Axman6> so input <- ...; let Just (n, rest) = readInt input; Just (p,_) = readInt rest
05:18:43 <Axman6> do*
05:18:48 <monadic_kid> haskellnoob: let <binding> = <expression> but if you the expression is monadic expression you need to use <binding> <- <monadic-exp>
05:19:25 <monadic_kid> haskellnoob: *if your expressions is a monadic expression you need to use <binding> <- <monadic-exp>
05:19:29 <haskellnoob> Axman6: the do should come at the same indentation as the input -< ?
05:19:49 <haskellnoob> the *let, i meant
05:20:22 <age> I am trying to make an Expr data type that would display boolean expressions like it is done here for Int: http://goo.gl/6LRAn ; Can someone please point out what am I doing wrong: http://npaste.de/zf/ ?
05:20:30 <haskellnoob> monadic_kid: thank you
05:20:42 <haskellnoob> all: let me try this :)
05:20:55 <Axman6> haskellnoob: http://hpaste.org/paste/44562/reading_two_numbers_from_input#p44564
05:21:13 <haskellnoob> Axman6: thank you
05:21:17 <sipa> age: Data.Bool is a type, not a class, right?
05:21:21 <monadic_kid> age: better to explain what the actual problem is first
05:21:59 <mauke> age: line 6 is wrong
05:22:07 <Axman6> age: you can't just say data Foo = SomeOtherTypeThatAlreadyExistsLikeBool
05:22:27 <Axman6> you'd need something like data BoolExpr = Var Bool | ...
05:22:32 <Kaidelong> http://hpaste.org/paste/44562/reading_two_numbers_from_input#p44563 was what I did, for better or wors
05:22:51 <age> a noob I am, sorry. the poblem is that I want to be able to display functions as text
05:23:08 <Axman6> you can't
05:23:11 <Kaidelong> ah, looking at the following post, I probably did it wrong 
05:23:15 <mauke> not possible in general because the standard operations on booleans aren't overloaded
05:23:29 <age> So I want to overload them! :P
05:23:46 <mauke> step 1: define a typeclass for booleans
05:23:54 <age> "f a b = a && b; show (f) => "a && b""
05:24:01 <mauke> like Num for numbers
05:25:07 <sipa> and then redefine all operations on Bools to accept your typeclass instead of the real type Bool
05:25:25 <Kaidelong> WWHHHHYYYYY??
05:25:38 <Kaidelong> oh
05:25:47 <weirdo> can i make it so function objects are printable?
05:25:52 <Axman6> no
05:25:55 <weirdo> someone once pointed me to an extension but i forgot its name
05:25:55 <mauke> yes
05:26:02 <age> haha
05:26:06 <weirdo> i had to import it and suddenly it turned all better
05:26:11 <mauke> instance Show (a -> b) where show = "hello world"
05:26:16 <Axman6> well, you can, but it usually involves just printing the type
05:26:24 <sipa> mauke: won't typecheck :D
05:26:27 <Axman6> or printing nonsense
05:26:29 <mauke> add _
05:27:00 <weirdo> anyway, i now have inferior ghci in my emacs
05:27:14 <weirdo> thanks guys, i s'pose leksah wasn't worth it
05:29:33 <spirit> inside leksah, right-clicking Main and choosing 'edit source' does not open it. I copied source files into src dir of my new package. when adding 'import foo' lines to Main.hs I get errors: Could not find module 'Setup'
05:29:36 <Kaidelong> zomg emacs user
05:29:41 <Kaidelong> everyone attack
05:30:34 * age attacks Kaidelong
05:31:01 <Kaidelong> agghghgh C-x C-x C-x!!!
05:31:22 <hamishmack> spirit: Did you leave Setup.lhs in the same directory as the .cabal file?
05:31:38 <age> M-x butterfly-attack Kaidelong
05:31:47 <Kaidelong> where x is free
05:32:06 <age> D:
05:32:38 <Kaidelong> http://www.cs.rutgers.edu/LCSR-Computing/some-docs/emacs-chart.html
05:32:45 <Kaidelong> now I know what "C-x 5" does
05:33:16 <age> nothing?
05:33:34 <Kaidelong> age: according to that, "split-window-horizontally"
05:33:57 <age> it's C-x 2 here
05:34:15 <spirit> o dear -- i inadvertently had moved Setup.lhs inside the src dir! it's back now. how would i have my modules appear in the module tree though? the ones i had written outside leksah?
05:34:26 <malorie> > map putStrLn ["abc","def"]
05:34:27 <lambdabot>   [<IO ()>,<IO ()>]
05:35:15 <Kaidelong> "backward-kill-sentence"
05:35:17 <Kaidelong> lovely
05:35:21 <Kaidelong> what does that even mean?
05:35:24 <age> My brain cries.
05:35:46 <Zao> Kaidelong: kill == erase, backward == direction, sentence == amount
05:35:46 <mauke> delete the sentence before the cursor
05:36:02 <age> Kaidelong: sentences you to be killed backwards
05:36:34 <Kaidelong> how would you even go about carrying out such a sentence?
05:36:55 <mauke> carry-out-sentence
05:37:01 <age> you'd have to be dead first, then I'd revive you
05:37:58 <hamishmack> spirit : Edit the .cabal file and add them to "other-modules: " (just a space in between each module name)
05:39:29 <Kaidelong> mauke had me for a minute there
05:39:52 <Kaidelong> I was trying to look up carry-out-sentence in emacs
05:39:59 <Kaidelong> docs
05:40:15 <age> lol
05:40:26 <Kaidelong> interesting google result for that one
05:41:52 <Kaidelong> I take it back. Two interesting ones.
05:42:53 * hackagebot tdoc 0.2.0 - TDoc is a typed document builder with support for (X)HTML  http://hackage.haskell.org/package/tdoc-0.2.0 (NicolasPouillard)
05:45:14 <age> regarding my expression question, can someone please answer this: http://www.haskell.org/pipermail/haskell-cafe/2011-March/089898.html ?
05:47:17 <weirdo> gordon freeman!
05:47:20 <weirdo> :-D
05:47:45 <sshc> How well does GHC support 64-bit architectures?
05:47:54 <sshc> Should I be worried  at all?
05:48:03 <age> weirdo: uh, what? :_:
05:48:26 <weirdo> there's a picture of gordon freeman in "greater good"
05:48:35 <weirdo> i mean, a drawing
05:48:35 <age> yes, it's awesome!
05:48:44 <spirit> inside the .cabal file, other modules, if i put all other modules inside src folder, would i write Module.hs if Module.hs was one of the other modules i wanted to add? i got lots of parse errors... 'Parse of field 'other-modules' failed'
05:49:24 <age> is it possible to extract parameter names for a function?
05:49:54 <augustss> age: no
05:49:55 <hpc> age: as in (\x -> "x")?
05:50:11 <hpc> you would need the source, and lots of parsing hacks
05:50:20 <age> hpc: yes, that
05:51:00 <age> hmm, I would still be interested even with hacks.
05:51:34 <killing-joke> uh oh. i have driven off the paved route. error "The last statement in a 'do' construct must be an expression"
05:51:56 <aristid> killing-joke: http://hpaste.org
05:51:59 <killing-joke> is there an (E)BNF of the language i can check to see when i do this?
05:52:13 <aristid> sshc: GHC supports 64-bit architectures very well
05:53:24 <killing-joke> is there a doc or web page that i can consult to see if my expressions are syntactically valid before letting them out of my fevered brain case?
05:53:43 <mauke> why not just ask the compiler?
05:53:49 <mauke> it'll tell you if you have a syntax error
05:55:29 <killing-joke> mauke, "ask the compiler" and "ask the nice people on irc" are two ways to solve the problem, but i would like to solve problems without using those tools, if possible
05:55:41 <killing-joke> how can i put this ... the debugging needs to happen in my head
05:55:53 <mauke> well, you could learn the language first
05:56:02 <mauke> then you don't have to guess what you can write
05:57:03 <killing-joke> could you point me to a structured definition of the language? i am trying to learn it right now. thanks. :)
05:57:16 <mauke> preflex: ? report
05:57:17 <preflex>  factoid not found
05:57:18 <mauke> aww
05:57:22 <mauke> @where report
05:57:22 <lambdabot> http://www.haskell.org/onlinereport/
05:57:37 <mauke> preflex: + report http://www.haskell.org/onlinereport/
05:57:53 <mauke> @where lyah
05:57:53 <lambdabot> http://www.learnyouahaskell.com/
05:58:22 <hamishmack> spirit: other-modules: Module
05:58:42 <hamishmack> spirit: other-modules: Module1 Module2
05:58:50 <spirit> ah, so without .hs?
05:58:51 <hamishmack> spirit: no .hs
05:59:07 <killing-joke> cool! http://www.haskell.org/onlinereport/exps.html  is what i was looking for. thank you, mauke
05:59:08 <spirit> and afterwards it would appear inside the module tree?
06:00:42 <parcs> is it possible to build a 64-bit ghc that produces 32-bit binaries?
06:01:21 <hpc> someone is working on cross-compilation
06:02:32 <parcs> ah, okay. for now, a chroot will do then i guess
06:04:28 <aristid> haskell platform today? *hopes*
06:05:01 <burp> haskell platform with ghc 7?
06:05:07 <burp> today?
06:05:08 <monadic_kid> yep
06:05:15 <Axman6> hopefully
06:07:00 <hamishmack> spirit: Should do.  You may also be able to right click in the Module pane and select Add Module,  I am not sure what it does if the file already exists.
06:07:56 <mreh> i'm disappointed with the lack to native support for multi-dimensional mutable arrays
06:07:57 <parcs> aristid, burp, monadic_kid, Axman6: http://www.haskell.org/pipermail/haskell-cafe/2011-March/089900.html
06:08:04 <spirit> it does not allow to add modules that already exist via right-click. but all seems fine now :-) thanks a lot!
06:08:30 <parcs> that was posted today, so i don't think it will be released today
06:08:30 <monadic_kid> parcs: yes i've read earlier
06:09:21 <aristid> parcs: oh, they also have installers for 64-bit OS X, nice
06:10:02 <monadic_kid> i hope they provide rpms for fedora on that day but probably not
06:10:54 <Saizan> is unification for higher-rank haskell types decidable?
06:11:44 <Saizan> mreh: Data.MArray using tuples for indices is not enough native?
06:12:37 <mreh> Saizan: which library has that?
06:12:45 <Saizan> array
06:13:45 <mreh> Saizan: look again, i can't see any
06:14:26 <Saizan> mreh: what are you expecting to find?
06:15:05 <Saizan> IOArray/STArray or the unboxed variants are the ones
06:15:59 <Saizan> e.g. IOArray (Int,Int) Char is a 2d array of chars
06:16:02 * hackagebot netlines 0.2.1 - Enumerator tools for text-based network protocols  http://hackage.haskell.org/package/netlines-0.2.1 (ErtugrulSoeylemez)
06:37:08 <weirdo> how do i load a module downloaded from hackage?
06:37:44 <hpc> import Foo.Bar.Baz
06:37:44 <weirdo> i found this "show" module that supposedly prints functions into the ghci repl
06:37:47 <weirdo> thank you
06:37:49 <hpc> :P
06:38:15 <hpc> (do not confuse "package" and "module" btw; packages /contain/ modules)
06:39:01 <monadic_kid> you'll need to add the package to your cabal file first
06:39:08 * hackagebot NXT 0.1.8 - A Haskell interface to Lego Mindstorms NXT  http://hackage.haskell.org/package/NXT-0.1.8 (MitarMilutinovic)
06:39:10 <ksf> but...but... pacagkes contain presents! that's why they're under trees!
06:39:11 <monadic_kid> "Edit package"
06:39:47 <hpc> ksf: remember, if you see a heap of presents, it is only polite to start at the bottom; otherwise, everyone else has to wait for the heap to be rebuilt
06:39:50 <ksf> when you happen to use leksah, yes.
06:40:10 <ksf> indeed.
06:41:16 <killing-joke> mauke, many thanks for your help. i was able to echo some text through this filter:  "import System.IO \n main = getLine"
06:41:41 <hpc> :t getLine
06:41:42 <lambdabot> IO String
06:41:48 <killing-joke> i originally wrote way too much code, and i threw out terms until i got something that worked
06:41:49 <hpc> killing-joke: that typechecked?
06:41:57 <hpc> :t main
06:41:58 <lambdabot> Not in scope: `main'
06:42:27 <hpc> (:t main would be a nice thing to have, for reference)
06:42:55 <killing-joke> i put those two lines in a file called "filter" and did "echo 'hello' | runghc filter"
06:43:03 <mauke> hpc: IO a
06:43:22 <hpc> mauke: oh, neat
06:43:26 <hpc> thought it was IO ()
06:46:20 * paolino thinks an ssd disk is the best peripheral device  he ever bought
06:49:07 * ksf doesn't plan on buying one for say 10 years.
06:49:36 <ksf> they just don't have anything you wouldn't get from a raid, which is cheaper and has greater capacity, too.
06:50:18 <JimmyRcom> You can have ssd for operating system and have two 2tb hard drives attached too, doesn't make diff
06:51:30 <ksf> in price, yes it does. and ssds don't particularily excel when it comes to lifetime.
06:51:43 <JimmyRcom> common misconception
06:52:05 <hpc> i am pretty sure SSDs are faster than two disks of raid
06:52:05 <ksf> also when it comes to overall mtbf.
06:52:16 <hpc> and they only die faster if you write a lot to them
06:52:18 <ksf> I'm not talking about a 2-disk raid.
06:52:43 <hpc> an OS drive will last as long as the computer
06:53:01 <mreh> :t 1
06:53:02 <lambdabot> forall t. (Num t) => t
06:53:08 <JimmyRcom> They have lots of writes available and they distribute them. With trim it's a lot less writing. If sectors are unwritable, nothing catastrophic happens.
06:53:08 <hpc> :t 1 2 3
06:53:09 <lambdabot> forall t t1. (Num (t1 -> t), Num t1) => t
06:53:12 <ksf> I'm talking about a proper raid5
06:53:46 <hpc> you can't fit raid5 in a laptop
06:54:03 <ksf> I have a lian-li meditower.
06:55:06 <JimmyRcom> my desktop has a ssd port. I just unplug it and put it in my laptop. Didn't cost much for the convenience it provides
06:56:14 <JimmyRcom> the case thing has a little adapter I connect a sata to
06:56:15 <fcr> my acer aspire one has two sd cards and one ssd inside, so it should be possible to use raid5
06:56:27 <ksf> I'd do that over gigabit.
06:56:51 <ksf> or wlan, in case I'm too lazy to plug the mobile one in.
06:57:42 <basvandijk> When I have "malloc >>= \ptr -> realloc ptr >>= \rptr -> ..." which pointer do I need to free? ptr, rptr or both?
06:58:32 <mm_freak_> basvandijk: rptr
06:58:42 <basvandijk> mm_freak_: ok thanks
06:58:53 <hpc> realloc munches the interior of ptr and puts it somewhere else
06:59:01 <hpc> so ptr's memory doesn't exist anymore
06:59:25 <mm_freak_> hpc: generally it tries to avoid that, but yes, it's still safer to free rptr instead of ptr
07:00:13 <mm_freak_> i wonder how well realloc works with the with* functions
07:00:30 <hpc> mm_freak_: terrifyingly, i would suspect
07:00:31 <ksf> now, an ssd as a swap disk, that might make sense.
07:00:55 <hpc> ssd swap would be kind of bad, i would think; you need fast read and write times when swapping, because you do both
07:01:04 <hpc> ssd only has the former
07:01:13 <aristid> hpc: not true.
07:01:38 <hpc> ah, ill shut up then :P
07:02:11 <aristid> ssd are superior in every aspect but prize :)
07:02:16 <aristid> *price
07:02:34 <hpc> even lifespan?
07:02:52 <aristid> well, rotating disks break all the time, so probably yes
07:02:59 <hpc> groovy
07:03:01 <ksf> suspend to disk from/to a 50mb/s sata disk with only 1g ram takes a decent amount of time
07:03:09 <mm_freak_> i would lose one write cycle before i could even install an operating system onto an SSD
07:03:15 <ksf> that can only get worse with say 4 or 8gb.
07:03:58 <ksf> ...and that's why I want to raid them up.
07:03:59 <hpc> ksf: had a fun discussion about that on another channel; it eventually came down to the other guy mentioning that the laptop was 8 years old :P
07:04:09 <FauxFaux> Modern OSes only write out things that are actually in memory; most of your 4 or 8gb of ram would be disc cache or stuff that's already swapped (or swappable).
07:04:30 <hpc> and that it is easy to write ram to disk when there's only a few hundred megs of it
07:04:32 <ksf> well, my pc is kind of that old, but I *could* run a max. 4-disk raid, here.
07:04:42 <ksf> and still have two pata ports free.
07:04:54 <copumpkin> preflex: seen mmorrow
07:04:54 <preflex>  mmorrow was last seen on #ghc 1 year, 47 days, 12 hours, 46 minutes and 12 seconds ago, saying: * mmorrow is rtfm'ing
07:05:20 <ksf> FauxFaux, when suspending to disk, that cache is saved, though.
07:05:27 <hpc> did mmorrow die or something? :P
07:05:37 <ksf> at least under linux, and by default.
07:06:00 <hpc> swap would be free suspended memory, i would think
07:06:02 <ksf> and it makes sense, too, as otherwise, on wakeup, you'd first be busy re-reading tons of caches.
07:06:04 <hpc> it is already on the drive
07:06:06 <aristid> the biggest advantage of SSDs is fast random access IMO
07:06:35 <ksf> you get that with a raid, too.
07:06:44 <FauxFaux> ksf: No, it's not?  That'd be retarded.
07:06:47 <hpc> raid still has seek times
07:06:52 <ksf> not to mention that a truly smart fs could optimise for common tasks.
07:08:17 <ksf> reading the caches from the suspend image is definitely faster than reading it from randomly scattered places on other disks.
07:08:38 <olsner> not reading them is even faster :)
07:08:53 <aristid> ksf: you don't get microsecond-fast random access with raid, no.
07:09:10 <hpc> aristid: not unless the data is already under the needle :P
07:09:18 <ksf> yeah. and then watch your desktop grinding to a halt because it has'nt got data it commonly accesses in cache.
07:09:21 <hpc> from random spinning :D
07:11:50 <ksf> and you get raid performance for all your 4 or whatnot tb, not just for a couple of gigs.
07:12:22 <killing-joke> so i wrote a (not very discriminating) filter using "main = getLine". the 'reading of bytes' part is fairly obvious in the name of the function. but it seems that writing out those same bytes is somehow implicit.
07:12:27 <killing-joke> is there a name for this?
07:12:37 <ksf> 5-disk raid5 with 1tb each should be the way to go, right now.
07:13:06 <ksf> killing-joke, yes. common terminal behaviour.
07:13:16 <ksf> it echos stuff back at you, that's not haskell's doing.
07:13:16 <killing-joke> ksf, thanks! i'll go read now.
07:13:42 <aristid> ksf: i just have a single 160 GB SSD in my laptop, and no external drive at all. i like it.
07:14:56 <ksf> killing-joke, hSetEcho stdin False should disable that echoing.
07:15:02 <killing-joke> ah hah
07:15:10 <ksf> @hoogle hSetEcho
07:15:10 <lambdabot> System.IO hSetEcho :: Handle -> Bool -> IO ()
07:17:34 <ksf> killing-joke, it *has* to be the terminal doing the echoing, because (again by default) it's only sending data when it's got a full line of it.
07:17:59 <ksf> @hoogle hSetBuffering
07:17:59 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
07:20:40 <killing-joke> ksf, in imperative languages, you can say something like ReadBytes(stdin, buffer). the writing-out must be explicitly called as well.
07:21:38 <ksf> it's the same in haskell.
07:21:44 <killing-joke> so, like a unix guy with his first mac, i am wondering at the shiny integration and how to take it apart. :)
07:22:04 <ksf> everything in IO () is just like in any other (POSIXy) imperative language.
07:22:49 <killing-joke> ksf, i respectfully submit that printing the data back out without an explicit call seems a little un-Posixy
07:23:19 <ksf> no, it's common terminal behaviour.
07:23:30 <ksf> you won't get the same behaviour when piping data in.
07:23:48 <ksf> ...and C does the same. when you read() from stdin.
07:23:49 <killing-joke> oh. i thought i did pipe the data in.
07:24:19 <killing-joke> runghc was reading from a pipe. am i misunderstanding even that? "/
07:24:27 <ksf> ooooh. runghc.
07:24:54 <killing-joke> i am trying to be as functional as possible in my early days.
07:24:57 <ksf> runghc is by default printing the IO value of main
07:25:31 <killing-joke> i will go meditate on that, then. many thanks. :)
07:26:23 <ksf> main = return "foo"
07:26:24 <ksf> >>>
07:26:28 <hpc> getLine >>= putStrLn
07:26:34 <hpc> also
07:26:43 <ksf> % runhaskell test.hs
07:26:43 <ksf> "foo"
07:26:58 <ksf> ...note the quotes.
07:27:09 <ksf> ghc --make test.hs && ./test won't do the same.
07:27:23 <killing-joke> this is the devil's handiwork, then
07:27:30 <ksf> ask someone else whether there's a sane explanation for that inconsistency.
07:27:35 <mreh> > (1,2) < (2,1)
07:27:35 <lambdabot>   True
07:27:58 <hpc> runhaskell wraps around ghci
07:28:00 <hpc> iirc
07:28:13 <hpc> and ghci prints the value of all expressions it evaluates
07:28:17 <hpc> even if they are IO actions
07:28:19 <mm_freak_> hpc: not all
07:28:21 <ksf> that is, if main is of the type Show a => IO a, instead of just any IO a, the stuff will be printed.
07:28:23 <ion> % ghc -e '42'
07:28:23 <ion> 42
07:28:24 <ion> also
07:28:39 <mm_freak_> it doesn't print () for the result of IO actions, for example
07:28:54 <ksf> ()'d be a sane exception to that exception, yes.
07:29:21 <ksf> but I think it would print [(),(),()] if you mapM instead of mapM_
07:29:24 <mm_freak_> though it does print the other value of type (), if it's ever reached =)
07:29:36 <mm_freak_> ksf: yes, but that's not () anyway
07:29:49 <mreh> > (1,2) < (2,2)
07:29:50 <lambdabot>   True
07:30:01 <mreh> > (1,9) < (2,2)
07:30:02 <lambdabot>   True
07:30:15 <mm_freak_> mreh: lexical ordering, just like with lists
07:30:27 <mm_freak_> > "azz" < "bbb"
07:30:28 <lambdabot>   True
07:30:45 <mreh> same as big-endian?
07:30:48 <mm_freak_> > ('a', 'z', 'z') < ('b', 'b', 'b')
07:30:49 <lambdabot>   True
07:31:14 <ion> How is endianness relevant?
07:31:38 <mm_freak_> endianness is irrelevant…  the first value has the highest ordering priority
07:31:40 <mreh> significance
07:31:49 <mm_freak_> significance is a better word
07:32:06 <mreh> endianess is an ordering to significance
07:32:30 <mm_freak_> endianness is an ordering for value
07:33:12 <mm_freak_> "significance" in endianness is really just another word for "value"
07:33:22 <hpc> lists are big-endian, for example; you can compare two infinite lists and get a non-terminating answer for which is greater
07:33:47 <hpc> because the head of the list is the most significant
07:34:04 <mreh> that would only happen if they were equal
07:34:18 <hpc> er, non-non-terminating :P
07:34:27 <mreh> :)
07:34:27 <hpc> it's still morning here
07:34:39 <ion> > repeat 0 < repeat 0
07:34:43 <lambdabot>   mueval-core: Time limit exceeded
07:34:56 <mreh> (the answer is False)
07:35:00 <mm_freak_> i wouldn't call that "big endian", because that's confusing
07:35:01 <mreh> psst lambdabot
07:35:36 <rtharper> dcoutts: ping?
07:35:48 <dcoutts_> @yarr!
07:35:49 <lambdabot> Prepare to be boarded!
07:35:49 <mreh> anyway, the reason i ask is that PGM images are hard to load into a Haskell array!
07:35:50 <ion> No, the answer is not *really* false.
07:36:07 <mreh> the answer is _|_
07:36:09 <dcoutts_> rtharper: hia, how're things?
07:36:15 <ion> yes
07:36:27 <mreh> the bottom farts in your face once again
07:36:28 <rtharper> dcoutts_: fairly good! going to utrecht this summer ;=)
07:36:31 <mm_freak_> in math it would be false
07:36:36 <mm_freak_> clearly the lists are equal
07:36:53 <dcoutts_> rtharper: oh good stuff
07:37:41 <mreh> need a better term than big-endian, i think it's rather straight forward
07:37:56 <mreh> but you aren't satisfied :)
07:38:22 <mm_freak_> mreh: lexical ordering
07:38:43 <mm_freak_> just like in a dictionary
07:39:36 <mreh> oh yes, you said
07:40:39 <mreh> bum, now I need to translate this associative list into lexical ordering with respect to the index
07:40:54 <mm_freak_> sortBy
07:41:28 <mm_freak_> > sortBy (comparing fst) [(2, "abc"), (1, "def")]
07:41:29 <mreh> yeah I know, it's just more cycles I wanted to save down the drain :)
07:41:29 <lambdabot>   [(1,"def"),(2,"abc")]
07:41:40 <mreh> :t on
07:41:41 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:42:00 <mm_freak_> but you can also just use 'sort' =)
07:42:06 <mm_freak_> > sort [(2, "abc"), (1, "def")]
07:42:07 <lambdabot>   [(1,"def"),(2,"abc")]
07:42:20 <mreh> because the associative list is in lexical ordering!
07:42:46 <mreh> the right lexical ordering
07:42:56 <mreh> sortBy is more efficient
07:43:22 <mreh> or is it a divide an conquer type sort?
07:43:57 <mm_freak_> sort = sortBy (<), i think
07:44:08 <mm_freak_> > sortBy (<) "cba"
07:44:09 <lambdabot>   Couldn't match expected type `GHC.Ordering.Ordering'
07:44:09 <lambdabot>         against inferr...
07:44:20 <mm_freak_> uhm, yeah
07:44:25 <mm_freak_> > sortBy compare "cba"
07:44:26 <lambdabot>   "abc"
07:44:48 <mm_freak_> i don't think sortBy is more efficient…  if anything, then sort is more efficient, because it's specialized
07:45:17 <mm_freak_> anyway, if you want better performance, don't use lists
07:45:32 <mm_freak_> use Map or IntMap or something like that
07:45:53 <hpc> then you don't even have to sort!
07:46:05 <mreh> well, I made a generalised parser for netpbm into an associative array
07:46:17 <mreh> I'll make a specialised parser into mutable arrays
07:46:38 <mreh> associative list pardon
07:46:42 <mm_freak_> i would read into a UArray
07:47:13 <mreh> well, it depends how you're going to use it
07:47:23 <mreh> why not generalise :)
07:47:32 <mm_freak_> because you can generalize from UArray
07:47:42 <mm_freak_> or MArray
07:49:35 <DrSyzygy> :t curry
07:49:36 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
07:49:47 <DrSyzygy> :t uncurry
07:49:47 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
07:50:56 <hpc> :t curry . uncurry
07:50:56 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
07:51:02 <hpc> :t uncurry . curry
07:51:03 <lambdabot> forall a b c. ((a, b) -> c) -> (a, b) -> c
07:51:07 <hpc> fun!
07:51:19 <mm_freak_> mreh: for performance it's better to first read into the most natural low level representation and then generalize from that
07:51:42 <mm_freak_> mreh: also i see no reason to generalize it at all
07:52:17 <mm_freak_> too much generalization leads to painfully slow libraries like the original 'irc' library
07:53:59 <mm_freak_> which is the reason i'm reinventing the wheel right now for a lot of stuff
07:55:05 <hpc> mm_freak_: reinventing an awesomer wheel :P
07:55:11 <mm_freak_> hehe
07:56:27 <Saizan> the original irc library didn't feel generalized at all
07:56:50 <mm_freak_> Saizan: yes, but using lists for network protocols is a bad choice
07:57:03 <Kaidelong> isn't there a specialization pragma entirely to avoid this tradeoff?
07:57:06 <Twey> I don't think ByteString was around back then
07:57:14 <mm_freak_> also most network libraries on hackage have no run-time checks at all…  seems like because it's haskell there is no way to attack them ;)
07:57:35 <Kaidelong> mm_freak_: what kinds of runtime checks?
07:57:38 <christo_m> http://hpaste.org/44566/luaparser  <- can someone help me with some type errors
07:57:42 <christo_m> new to haskell/Parsec
07:57:55 <hpaste> christo pasted "luaparser"  http://hpaste.org/44566
07:57:58 <mm_freak_> Kaidelong: they all assume that servers are trustworthy and never time out
07:58:26 <mm_freak_> Kaidelong: most libraries for line-based protocols would die, if the server side would feed them some infinitely long line
07:59:03 <Kaidelong> mm_freak_: both should be easy to deal with in haskell though...
07:59:11 <christo_m> Maybe i should resolve all that stuff hpaste found lol :)
07:59:13 <Kaidelong> they're just parameters, in a sense
07:59:27 <Kaidelong> so you could pass them around as part of your world in IO
07:59:33 <mm_freak_> Kaidelong: yes, but nobody does it…  i do it via enumeratees
07:59:46 <mm_freak_> i released the netlines library for that purpose
08:01:23 <Saizan> christo_m: you should also add the type error
08:01:44 * Kaidelong suddenly wonders about SNOBOL style control flow for Haskell using First and catMaybes
08:02:16 <Kaidelong> or the list monad could do it too
08:02:31 <christo_m> Saizan: pardon?
08:02:37 <christo_m> Saizan: they give me a few, i didnt want to paste them all :|
08:02:51 <Saizan> christo_m: at least the one you want to ask about
08:03:22 <christo_m> Saizan: hpaste is telling me to get rid of all the do's because theyre redundant.. but every example of parsec i see uses them
08:03:34 <Kaidelong> actually the list monad is a good example
08:03:58 <Botje_> christo_m: 'do var' is the same as var
08:04:00 <Kaidelong> a : [] would be kind of like "suspend a, then fail"
08:04:06 <hpc> > do 5
08:04:07 <lambdabot>   5
08:04:15 <hpc> > do '5'
08:04:16 <lambdabot>   '5'
08:04:17 <Saizan> christo_m: do is useful only when you're composing multiple parsers, e.g. in explist, otherwise they are useless
08:06:50 <mm_freak_> :t (do 5)
08:06:51 <lambdabot> forall t. (Num t) => t
08:06:51 <christo_m> Okay, thank you
08:07:04 <hpc> :t (do 5; 6;)
08:07:05 <lambdabot> forall (m :: * -> *) a b. (Monad m, Num (m a), Num (m b)) => m b
08:07:13 <mm_freak_> huh?  what monad is that?
08:07:23 <hpc> > (do 1;2;3;4;) 5
08:07:24 <lambdabot>   4
08:07:27 <hpc> :D
08:07:38 <mm_freak_> yeah, that's the reader monad, but what monad is my example?
08:07:45 <mm_freak_> :t (do 5)
08:07:47 <lambdabot> forall t. (Num t) => t
08:07:52 <hpc> mm_freak_: not a monad; i was just blowing your mind ;)
08:08:07 <mm_freak_> then why is 'do' allowed?
08:08:16 <hpc> because do is syntactic sugar
08:08:22 <hpc> "do x" translates to "x"
08:08:27 <mm_freak_> ah, ok
08:08:33 <hpc> "do x; y" translates to x >> y
08:08:54 <mm_freak_> yeah, i was just wondering about 'do' in a non-monadic context
08:09:34 <boegel_> @seen BCoppens
08:09:34 <preflex>  BCoppens was last seen on #haskell-blah 2 days, 18 hours, 23 minutes and 4 seconds ago, saying: Itkovian: F5
08:09:34 <lambdabot> Unknown command, try @list
08:09:40 <boegel_> hmm
08:12:00 <ezyang> Ahh, gotta love STG's naming scheme: wild1_sex 
08:12:05 <ezyang> :-) 
08:12:53 <hpc> i used to do stuff like "try {...} catch (Exception up) {...; throw up;}"
08:12:57 <hpc> back when i did java
08:13:55 <ion> as <- ass; a <- as
08:14:11 <hpc> :D
08:14:19 <ion> Or more subtle: name ‘ass’ as ‘butt’ instead.
08:14:58 <hpc> i don't have anything punny in my haskell code base, yet
08:15:12 <hpc> unless you count my irc bot's derivative function
08:15:15 <Kaidelong> must be a better way to go about that than do sugar
08:15:19 <hpc> ">diff Optimus" "Optimus Prime"
08:16:57 <spirit> how to indent if<exp>then<exp>else<exp>where<exp> correctly? if i start a new line for each of the keywords -- if ident0, then and else ident1, and where? 
08:17:30 <Kaidelong> append('Optimus ',X,'Optimus Prime').
08:17:33 <Kaidelong> false.
08:17:37 <Kaidelong> prolog, you make me sad
08:17:45 <hpc> Kaidelong: :D
08:18:06 <hpc> oh, the other good pun about that bot; on the network i run it on, my nick is Spock
08:18:10 <hpc> and the bot is Data
08:18:11 <Kaidelong> oh whoops
08:18:14 <Kaidelong> I meant double quotes
08:18:29 <Kaidelong> now it works
08:18:34 <hpc> true?
08:18:35 <hpc> :D
08:19:14 <Kaidelong> > fromEnum [80, 114, 105, 109, 101] :: [Char]
08:19:14 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:19:14 <lambdabot>         against inferred ty...
08:19:25 <Kaidelong> > fromEnum . [80, 114, 105, 109, 101] :: [Char]
08:19:26 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:19:26 <lambdabot>         against inferred type...
08:19:43 <hpc> > ord . [80, 114, 105, 109, 101] :: [Char]
08:19:44 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
08:19:44 <lambdabot>         against inferred type...
08:19:55 <hpc> > toEnum . [80, 114, 105, 109, 101] :: [Char]
08:19:56 <lambdabot>   "Prime"
08:19:58 <hpc> aha!
08:20:22 <Drknzz> Hi guys! I have produced a method that outputs a list of int tuples (of three elements), how can i use each of the ints on another function that loops over the list?
08:21:47 <ion> Huh. Is . behaving as map some lambdabot magic?
08:21:48 <byorgey> Drknzz: you mean you have another function that takes three ints?
08:22:02 <Botje_> Drknzz: you can pattern match on (a,b,c)
08:22:08 <byorgey> ion: (.) is generalized to fmap in lambdabot
08:22:22 <byorgey> ion: since the normal (.) can be seen as fmap for the ((->) e) functor
08:22:38 <Drknzz> byorgey: I am trying to get a list of three ints where a^2 + b^2 = c^2 and none is greater than 10001
08:22:43 <Drknzz> I have achieved that
08:23:09 <Drknzz> But i need to see wich of those triplets sum to 1000
08:23:12 <Drknzz> Im stuck there
08:23:27 <Kaidelong> append("Optimus ",X,"Optimus Prime"), format('~s',[X]).
08:23:30 <Kaidelong> Prime
08:23:34 <Kaidelong> lovely side effect there
08:23:36 <Drknzz> Botje_: Sorry, i dont know what pattern matching, im still very noob at Haskell
08:23:45 <byorgey> > filter (\(x,y,z) -> x + y + z == 1000) [(1,2,3), (4,5,6), (500,499,1)]
08:23:46 <lambdabot>   [(500,499,1)]
08:24:04 <byorgey> Drknzz: something like that?
08:24:10 <Drknzz> byorgey: Exactly
08:24:21 <byorgey> Drknzz: if you created the original list with a list comprehension, you can also just add a guard
08:24:35 <Drknzz> byorgey: I did create it with a list comprehension
08:24:39 <Drknzz> How can i add that?
08:24:44 <byorgey> [ (x,y,z) |  x <- ... , blah blah, x + y + z == 1000 ]
08:24:50 <Drknzz> Oh
08:25:00 <Drknzz> Didnt guess that, thanks
08:25:02 <hpc> > [x | x <- [1..], x < 5]
08:25:06 <lambdabot>   mueval-core: Time limit exceeded
08:25:13 <hpc> > [x | x <- [1..], x > 5]
08:25:14 <lambdabot>   [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,...
08:25:15 <sshc> I'm going to be idle with access to only pencil and paper.  But I want to be productive with my time.  What Haskell puzzle / exercise do you suggest I work on?
08:25:30 <hpc> sshc: proofs by hand!
08:25:33 <Drknzz> Thanks byorgey
08:25:41 <byorgey> Drknzz: sure.
08:25:42 <hpc> convert maps into folds, etc
08:26:02 <ion> sshc: Evaluate [0..] by hand.
08:26:23 <Drknzz> byorgey: Another quick question. What's filter's syntax?
08:26:32 <ion> :t filter
08:26:33 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:26:37 <Botje_> sshc: work out the (a ->) monad by the types
08:26:44 <sshc> ion: Hah, that's not productive at all :P
08:26:50 <byorgey> Drknzz: no special syntax, it's just a normal function
08:26:55 <sshc> Botje_: Good suggestion 
08:27:01 <sshc> hpc: Elaborate?
08:27:06 <byorgey> Drknzz: its first argument is a function which gives True or False for each element of the list
08:27:11 <byorgey> Drknzz: its second argument is a list
08:27:16 <hpc> :t foldr
08:27:17 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:27:18 <sshc> Botje_: Huh, I've never thought about functions being monads
08:27:23 <byorgey> Drknzz: and it outputs the list of elements for which the function returned True
08:27:28 <byorgey> > filter even [1..10]
08:27:29 <lambdabot>   [2,4,6,8,10]
08:27:34 <hpc> > foldr (:) "abc" "def"
08:27:35 <lambdabot>   "defabc"
08:27:41 <Drknzz> byorgey: Oh, i realized haskell doesnt need ,'s in parameters
08:27:42 <Botje_> sshc: it's a nice trick \bot uses
08:27:54 <hpc> > foldr (\s -> (ord s:)) "" "def"
08:27:54 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:27:55 <lambdabot>         against inferred type ...
08:27:56 <sshc> Is there a collection of puzzles or exercises I can look at?
08:27:59 <Drknzz> Im too rooted in OOP :p
08:28:00 <sshc> I need to leave quite soon
08:28:01 <hpc> > foldr (\s -> ((ord s):)) "" "def"
08:28:01 <byorgey> Drknzz: right, function application is just a space =)
08:28:02 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:28:02 <lambdabot>         against inferred type ...
08:28:04 <btutt> Try doing @pl transformations by hand. :)
08:28:05 <hpc> or something like that
08:28:08 <Botje_> @pl \x -> foo x || bar x -- uses that monad
08:28:08 <lambdabot> liftM2 (||) foo bar
08:28:27 <sshc> btutt: Now *that*, in addition to figuring out functions as monads, is a good idea, thanks
08:28:27 <JimmyRcom> I keep having the need for something opposite of a fold, instead of a list of items applied to a fun, a list of funs applied to a state where there's some condition for execution, how do you usually handle it?
08:28:36 <btutt> Np
08:29:08 <byorgey> JimmyRcom: can you give an example?
08:29:19 <hpc> :t scanr
08:29:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
08:29:46 <hpc> > scanr (+) 0 [1..]
08:29:47 <lambdabot>   [*Exception: stack overflow
08:29:52 <hpc> > scanl (+) 0 [1..]
08:29:53 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
08:30:00 <hpc> something like that? ^
08:30:14 <hpc> oh, nvm, i can't read
08:30:19 <hpc> :t foldr ($)
08:30:20 <lambdabot> forall b. b -> [b -> b] -> b
08:30:50 <hpc> > foldr ($) 5 [succ, pred, succ, succ]
08:30:51 <lambdabot>   7
08:31:04 <sshc> hpc: I don't know how or have never attempted to do proofs with Haskell
08:31:09 <sshc> hpc: It sounds interesting, though
08:31:16 <byorgey> sshc:  http://www.haskell.org/haskellwiki/99_Haskell_exercises ?
08:31:36 <Kaidelong> jimmyRcom: what is the type of the function you want?
08:31:51 <Kaidelong> I can think of
08:31:56 <Kaidelong> @ty foldr (.) id
08:31:56 <lambdabot> forall b. [b -> b] -> b -> b
08:31:58 <hpc> sshc: http://en.wikipedia.org/wiki/Lambda_calculus#Reduction
08:32:05 <hpc> you rename parameters, simplify, expand, etc
08:32:08 <Kaidelong> @ty map . ($)
08:32:09 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
08:32:13 <hpc> until you show that one lambda == another
08:32:21 <Kaidelong> err oh right
08:32:25 <Kaidelong> @ty map . flip($)
08:32:26 <lambdabot> forall a b. a -> [a -> b] -> [b]
08:32:27 <Kaidelong> I meant
08:32:35 <JimmyRcom> byorgey, I've had the same problem in multiple places, eg matching opts for making a http packet. If referer does not equal default then add http referer to outgoing packet.  A set of pattern matching functions would require me to change the state so it didn't hit the addreferer function again
08:32:52 <sshc> byorgey: Yay!  I'll try to solve 26 and 27, both of which seem decent; 28 seems much easier though
08:33:10 <sshc> hpc: Thanks, I'll look at that when I get back, and probably will do them next time
08:33:42 <xxx_man> does one knows
08:33:45 <xxx_man> Henkin semantics of second order logic ?
08:34:41 <Kaidelong> @ty foldr
08:34:42 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
08:35:31 <Kaidelong> @djinn (b -> [a] -> b) -> a -> b -> b
08:35:31 <lambdabot> Error: Undefined type []
08:35:32 <spirit> i'm uncertain about how to properly indent 'where'. 
08:36:02 <aristid> spirit: more than the line before
08:36:11 <spirit> always?
08:36:21 <spirit> inside if-then-else statement too?
08:36:21 <aristid> i think so
08:36:27 <spirit> more than the else?
08:36:31 <aristid> where is not valid inside expressions
08:37:14 <spirit> so it would be on the same level as 'if'?
08:37:25 <spirit> as in -- just outside the if-then-else expression?
08:38:15 <aristid> in danger of saying too many wrong things, i will stop saying anything now. please read the documentation :)
08:38:51 <spirit> the 98 report?
08:39:06 <monadic_kid> spirit: a where a clause is part of function defintion, nothing to do with an if expression, where clause should be indentated by one space character head of function name
08:40:01 <byorgey> JimmyRcom: I would model it as just applying a big chain of functions
08:40:16 <byorgey> JimmyRcom: which you can do with  foldr (.) id  as other have pointed out
08:40:34 <byorgey> JimmyRcom: each function can decide whether to do something or to return the value un changed
08:40:44 <malorie> is there a more elegant way to write `[ (a, b, c) | a <- [True, False], b <- [True, False], c <- [True, False] ]' ?
08:41:00 <luite> replicateM 3 [True,False]
08:41:01 <byorgey> JimmyRcom: depending on the domain you can create a nice little domain-specific language for building up the functions in a nice way
08:41:07 <luite> oh
08:41:11 <luite> not quite the same, sorry
08:41:12 <monadic_kid> malorie: zip3
08:41:15 <hpc> :t replicateM
08:41:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
08:41:39 <hpc> > replicateM 3 [True, False]
08:41:40 <lambdabot>   [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[F...
08:41:46 <hpc> oh, i see
08:41:57 <monadic_kid> malorie: ignore what I wrote
08:42:07 <malorie> monadic_kid: ok ;)
08:42:37 <monadic_kid> malorie: zip3 is not the same as using a list comphrension, so yeah using list monad replicateM on list monad will do it
08:43:03 <JimmyRcom>  byorgey: thanks
08:43:19 <luite> > (,,) <$> [True,False] <*> [True,False] <*> [True,False]
08:43:20 <lambdabot>   [(True,True,True),(True,True,False),(True,False,True),(True,False,False),(F...
08:44:00 <malorie> I seriously need to re-read my book :x
08:44:17 <monadic_kid> malorie: dawm it, no replicateM isn't the same!
08:44:19 <Drknzz> Quick question. How can i tell haskell that a number cannot have the remainder of the division with any number lesser than itself on a list, except 1 and itself. In other words, how can i filter a list for primes? :p
08:44:37 <Drknzz> be 0*
08:44:50 <tenso> what is wrong with this? http://codepad.org/nbcUoIZt
08:45:04 <monadic_kid> malorie: ignoring everything i told you!
08:45:29 <monadic_kid> malorie: *juist ignoring
08:45:32 <monadic_kid> ...
08:45:36 * monadic_kid goes to bed
08:45:40 <malorie> :D
08:47:59 <Kaidelong> @pl \x y -> (,,) <$> [x,y] <*> [x,y] <*> [x,y]
08:47:59 <lambdabot> (((,,) <$>) .) . ap (ap . ((<*>) .) . ap (ap . ((<*>) .) . (. return) . (:)) ((. return) . (:))) ((. return) . (:))
08:48:15 <Kaidelong> what's with the cons
08:48:21 <Kaidelong> oh
08:48:32 <Kaidelong> @pl \[x,y] -> (,,) <$> [x,y] <*> [x,y] <*> [x,y]
08:48:32 <lambdabot> (line 1, column 2):
08:48:32 <lambdabot> unexpected "["
08:48:32 <lambdabot> expecting pattern
08:48:46 <Kaidelong> @pl \([x,y]) -> (,,) <$> [x,y] <*> [x,y] <*> [x,y]
08:48:47 <lambdabot> (line 1, column 3):
08:48:47 <lambdabot> unexpected "["
08:48:47 <lambdabot> expecting pattern
08:48:47 <tenso> sooo, anyone?
08:49:01 <Kaidelong> @pl \x -> (,,) <$> x <*> x <*> x
08:49:01 <lambdabot> ((,,) <$>) . ((<*>) =<< join (<*>))
08:49:12 <xxx_man> does one knows
08:49:16 <xxx_man> Henkin semantics of second order logic ?
08:49:27 <Kaidelong> > join (*) 3
08:49:27 <lambdabot>   9
08:50:20 <hpc> xxx_man: one here probably does knows
08:50:23 <Kaidelong> @ty (((,,) <$>) . ((<*>) =<< join (<*>)) .) . enumFromTo
08:50:24 <lambdabot>     The operator `.' [infixr 9] of a section
08:50:24 <lambdabot>         must have lower precedence than that of the operand,
08:50:24 <lambdabot>           namely `.' [infixr 9]
08:50:36 <Kaidelong> @ty ((((,,) <$>) . ((<*>) =<< join (<*>))) .) . enumFromTo
08:50:37 <lambdabot>     Occurs check: cannot construct the infinite type: a = a2 -> a -> a1
08:50:37 <lambdabot>       Expected type: f a
08:50:37 <lambdabot>       Inferred type: f (a2 -> a -> a1)
08:53:04 <ezyang> Hey guys, I think I found a bug in strict-concurrency, but I'd like someone else to verify: strict writeChan grabs a lock on the MVar before forcing its channel item; shouldn't it force the channel item before doing that? 
08:54:17 <ezyang> sauce here: http://hackage.haskell.org/packages/archive/strict-concurrency/0.2.4.1/doc/html/src/Control-Concurrent-Chan-Strict.html#writeChan 
08:56:31 <parcs> > let primesIn (n:xs) = n : primesIn (filter (\x -> x `mod` n /= 0) xs) in primesIn [2..] -- Drknzz 
08:56:32 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:57:25 <ezyang> Also, I suspect the $! is unnecessary, since strict putMVar should seq it anyway. 
08:57:40 <Drknzz> parcs, what is (n:sx) exactly, i am sorry if its a noob question, im just going through tutorials
08:57:58 <Kaidelong> Drknzz: (:) builds a list out of a head and a tail
08:58:05 <Kaidelong> n there is the head, and sx the tail
08:58:16 <Kaidelong> it works the other way too, in a pattern, it can break a list down
08:58:31 <Drknzz> Kaidelong: Oh, haskell has a really nifty amount of things
08:58:36 <Drknzz> Really good language
08:58:38 <Drknzz> Loving it
08:58:48 <parcs> what tutorial are you reading?
08:59:15 <Drknzz> http://learnyouahaskell.com/
08:59:25 <Drknzz> Im solving Project Euler problems with haskell
08:59:37 <Drknzz> To memorize haskell more easily
09:09:24 <thunkee> how can i solve type problems like in exp(length "hello")
09:09:38 <Saizan> fromIntegral
09:10:17 <Saizan> btw, it's expr (length "hello") the parens surround subexpressions like in arithmetic
09:10:27 <Saizan> s/expr/exp/
09:12:14 <ezyang> Anyway, I wrote it up here: http://stackoverflow.com/questions/5211827/strict-evaluation-techniques-for-concurrent-channels-in-haskell/5212174#5212174 
09:13:30 <Saizan> ?tye exp (fromIntegral (length "hello"))
09:13:31 <lambdabot> forall b. (Floating b) => b
09:13:41 <Saizan> > exp (fromIntegral (length "hello"))
09:13:42 <lambdabot>   148.4131591025766
09:14:06 <btutt> *wishes HDBC had Data.Text support*
09:14:10 <aavogt> > exp 1 ^ length "hello"
09:14:11 <lambdabot>   148.41315910257657
09:14:39 <aavogt> > exp 1 ^ length "hello" :: CReal
09:14:40 <lambdabot>   148.4131591025766034211155800405522796234877
09:15:59 <parcs> :t genericLength
09:16:00 <lambdabot> forall b i. (Num i) => [b] -> i
09:18:24 <aavogt> @check \n -> genericLength (replicate n ()) == (fromIntegral n :: Double)
09:18:25 <lambdabot>   "Falsifiable, after 3 tests:\n-3\n"
09:18:35 <aavogt> @check \n -> (n > 0) || genericLength (replicate n ()) == (fromIntegral n :: Double)
09:18:36 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n"
09:18:43 <aavogt> @check \n -> (n > 0) && genericLength (replicate n ()) == (fromIntegral n :: Double)
09:18:44 <lambdabot>   "Falsifiable, after 2 tests:\n0\n"
09:18:44 * hackagebot data-category 0.4.1 - Category theory  http://hackage.haskell.org/package/data-category-0.4.1 (SjoerdVisscher)
09:18:51 <parcs> n < 0 ?
09:19:07 <aavogt> @check \n -> (n <= 0) && genericLength (replicate n ()) == (fromIntegral n :: Double)
09:19:08 <lambdabot>   "Falsifiable, after 0 tests:\n3\n"
09:19:23 <parcs> @check \n -> (n <= 0) || genericLength (replicate n ()) == (fromIntegral n :: Double)
09:19:23 <lambdabot>   "OK, passed 500 tests."
09:19:35 <aavogt> oh, that's it
09:19:58 <dolio> @check \n -> n > 0 ==> genericLength (replicate n ()) == (fromIntegral n :: Double)
09:20:02 <lambdabot>   mueval-core: Time limit exceeded
09:21:13 <parcs> @type (==>)
09:21:14 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
09:22:00 <dolio> It's broken in lambdabot for some reason.
09:22:11 <dolio> @check \n -> n > 0 ==> n == 5
09:22:12 <lambdabot>   No instance for (Test.QuickCheck.Testable
09:22:12 <lambdabot>                     (Test.QuickCh...
09:23:53 <dolio> @check \n -> n == 5
09:23:53 <lambdabot>   "Falsifiable, after 0 tests:\n1\n"
09:24:17 <savask> Hello. I'm trying to parse a bytestring with Data.Binary module, but I can't perform a little "trick" there. I need to put some bytes before I will read. Like: "do {x <- get; magicPut (0 :: Word8); y <- get; return (Hehe x y)}" Is there a way to do this?
09:25:28 <parcs> y <- cons 0 <$> get ?
09:26:08 <parcs> where do you want the 0 to go?
09:27:22 <savask> parcs: After x. Like [1, 2, 3] to [2, 3] (x is 1 now) to [0, 2, 3] to [2, 3] (y is 0 now)
09:28:12 <parcs> oh
09:28:24 <savask> The problem is that I'm going to read sequences of bytes at one time.
09:29:35 <djahandarie> Haha I can't believe this package exists and is actually serious
09:29:37 <djahandarie> @hackage derp
09:29:37 <lambdabot> http://hackage.haskell.org/package/derp
09:31:51 <ami_> hi
09:32:12 <mreh> man, I was scratching my head over Data.Array.MArray.getBounds for about an hour, I didn't realise it was monadic
09:32:18 <ami_> any one there can actully tell me that what the hack is 
09:32:20 <ami_> this
09:32:32 <ami_> Haskell
09:33:21 <ami_> thats my first day 
09:33:26 <ami_> any one there
09:33:30 <ami_> for helping
09:33:45 <parcs> nope, only 745 idlers :)
09:34:19 <ami_> hey do you i need any programming experience for this
09:34:24 <ami_> learning this
09:34:32 <parcs> no but it would help
09:35:02 <ami_> actully i nkow c and c++ and know many language basica
09:35:27 <ami_> and for what applications it is used
09:35:39 <mreh> ami_ haskell is general purpose
09:36:11 <ami_> can we make gui application for liberary managenet
09:36:16 <ami_> in it
09:37:13 <mreh> not something I've done, but it is possible
09:37:45 <ami_> k
09:38:35 <mreh> guis fall into a class of problems than FRP is trying to solve nicely
09:38:53 <mreh> otherwise you can just do the whole thing in IO
09:39:59 <mreh> preflex seen edwardk
09:40:06 <mreh> , preflex seen edwardk
09:40:29 <tombee> How can I sort a list of mixed-case words into alphabetical order?
09:40:34 <preflex>  edwardk was last seen on #haskell 3 days, 46 minutes and 55 seconds ago, saying: xplat: cute
09:41:00 <mreh> > sort ["abc", "Aab", "AAA"]
09:41:00 <lambdabot>   ["AAA","Aab","abc"]
09:41:04 <mreh> like that
09:41:20 <mm_freak_> tombee: sortBy + map toLower
09:41:24 <mreh> :t
09:41:27 <mreh> :t sortBy
09:41:28 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
09:42:02 <mauke> > sort ["ABC", "aAB", "aaa"]
09:42:03 <lambdabot>   ["ABC","aAB","aaa"]
09:42:20 <tombee> > sort ["lorem", "LOREM", "lorem"]
09:42:20 <ami_> sort["A", "abc","aw","an"]
09:42:20 <lambdabot>   ["LOREM","lorem","lorem"]
09:42:22 <mm_freak_> > sortBy (comparing (map toLower)) ["AAb", "aaa"]
09:42:23 <lambdabot>   ["aaa","AAb"]
09:42:24 <tombee> cool
09:42:27 <tombee> thanks
09:42:43 <mm_freak_> tombee: my variant ignores case
09:42:52 <tombee> Yeah I need case.
09:43:01 <mm_freak_> then just 'sort'
09:43:11 <mreh> > sortBy (liftM2 (compare) toLower toLower)) ["AZ", "aa"]
09:43:12 <lambdabot>   <no location info>: parse error on input `)'
09:43:15 <mauke> > sortBy (comparing (map toLower) ++ compare) ["ABC", "aAB", "aaa"]
09:43:16 <lambdabot>   ["aaa","aAB","ABC"]
09:43:19 <mreh> > sortBy (liftM2 (compare) toLower toLower) ["AZ", "aa"]
09:43:20 <lambdabot>   Couldn't match expected type `a -> GHC.Ordering.Ordering'
09:43:20 <lambdabot>         against i...
09:43:36 <mreh> um
09:43:40 <mauke> mreh: other way round
09:44:55 <mreh> :t liftM2
09:44:56 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:45:30 <tombee> trying to find the source for sort :>
09:47:43 <ami_> hey dose there is any job or money by learning this language
09:49:16 <tombee> how can I find the source for sort? :)
09:49:31 <ami_> google it
09:49:38 <mreh> hoogle it
09:49:52 <ami_> what is hoogle
09:49:57 <mreh> @hoogle sort
09:49:58 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
09:49:58 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
09:49:58 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
09:50:08 <mreh> @where hoohle
09:50:09 <lambdabot> I know nothing about hoohle.
09:50:11 <mreh> @where hoogle
09:50:11 <lambdabot> http://haskell.org/hoogle
09:50:20 <tombee> got it :)
09:50:47 <ami_> thanks
09:51:17 <ami_> thats exciting language
09:51:27 <dv-> @src sort
09:51:27 <lambdabot> sort = sortBy compare
09:52:34 <tombee> yea what is 'compare'?
09:52:37 <tombee> I was just looking at that
09:53:06 <dv-> @src compare
09:53:06 <lambdabot> compare x y | x == y    = EQ
09:53:06 <lambdabot>             | x <= y    = LT
09:53:06 <lambdabot>             | otherwise = GT
09:53:18 <mauke> @src Ord
09:53:18 <lambdabot> class  (Eq a) => Ord a  where
09:53:18 <lambdabot>     compare      :: a -> a -> Ordering
09:56:13 <tombee> trying to write my own quicksort function for strings
09:56:17 <kmc> @src (<=)
09:56:18 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
09:56:20 * mreh still hasn't integrated hoogle into his vim
09:56:25 <mauke> tombee: why?
09:56:29 <kmc> tombee, why write it for strings? it's no harder to write it generically
09:56:30 <tombee> practise
09:56:48 <mauke> why quicksort?
09:56:59 <mreh> you only need write sort for instances of Ord
09:57:28 <tombee> hmm
09:58:28 <tombee> well my problem is that if I have ["Z", "b", "a"], my quick sort turns this so ["Z", "a", "b"]
09:59:09 <ezyang> Ah, you want a sort that has a different ordering 
09:59:24 <ezyang> Do we have newtypes of String that get this for you? :-) 
09:59:38 <aavogt> or write  sortBy
10:00:19 <kmc> it's not a bad exercise to write the specialized sort
10:00:37 <parcs> http://hackage.haskell.org/package/case-insensitive
10:00:40 <kmc> then you can also learn how to do it with sortBy, and how to do it by wrapping String in a new type
10:01:07 <ion> sortBy (comparing (map toLower))
10:01:24 <kmc> "a string-like type like: String, ByteString..."
10:01:26 <ion> (or a more Unicode-aware lowercasing function)
10:01:32 * kmc grumbles that ByteString is not string-like
10:02:26 <kmc> it's annoying how many Haskellers ignore this fact
10:02:48 <kmc> like they're trying to drag us back to a world where the only people who used computers lived in California and spoke English
10:02:52 <mreh> kmc: I view it as a stream of Word8
10:03:04 <kmc> indeed, and it's nonsense to talk about converting a byte to lower case
10:03:29 <tombee> yes 'sortBy compare' seems to do just the job
10:03:30 <ami__> i found that this language is similar to python
10:03:39 <kmc> it's ironic too because Haskell itself has one of the nicer Unicode-correct language designs
10:03:40 <mreh> heh
10:03:48 <tombee> but I think I just need to write my own compare function
10:03:49 <kmc> ami__, how so?
10:03:55 <povik> is there a function, that swaps values of Either?
10:04:05 <ami__> both r scripting
10:04:06 <ion> > text $ map toUpper "ö shuﬄe"
10:04:07 <lambdabot>   O
10:04:13 <ami__> and have list and tuples
10:04:18 <mauke> :t either Right Left
10:04:19 <lambdabot> forall a a1. Either a a1 -> Either a1 a
10:04:27 <kmc> ami__, there's no such thing as a "scripting language"
10:04:33 <kmc> the term is useless and politically charged
10:04:39 <mauke> ami__: what do you mean by "scripting"?
10:04:49 <kmc> ami__, Python and Haskell have lists and tuples, but so do like three dozen other languages
10:04:57 <ami__> line by line execution
10:04:57 <Saizan> the problem is that Data.Text appeared too late and it's still considered less efficient than managing bytes with bytestring
10:05:04 <tombee> ami__: interpreted execution then?
10:05:09 <kmc> ami__, Haskell is very far from line by line execution
10:05:12 <kmc> and is usually compiled to machine code
10:05:12 <mauke> ami__: python doesn't do that
10:05:29 <kmc> to a beginner, Python and Haskell are very similar in the key aspect of "not as terrible as Java"
10:05:32 <ami__> hey in python ve can also define functions
10:05:35 <kmc> but they're actually very different
10:06:00 <mauke> ami__: what language doesn't do that?
10:06:02 <ami__> ok bros
10:06:24 <dark> this parsec parser: mzero <|> a behaves as a. (mzero always fails, it seems). isn't there a parser x so that x <|> a always fails?
10:06:26 <kmc> ami__, are you having fun?
10:06:37 <ami__> yaa
10:06:52 <parcs> dark: undefined :P
10:07:01 <ami__> but confused in chussing the right language
10:07:10 <ami__> for my school project
10:07:11 <mauke> dark: I don't think so
10:07:20 <kmc> dark, wouldn't that defeat the purpose of (<|>)
10:07:43 <mauke> anyChar >> fail "" is close
10:09:29 <kmc> (anyChar <|> eof) >> fail ""
10:09:29 <kmc> ;)
10:11:29 <mreh> bugger, I've got two arrays installed
10:11:42 <astory> I'm confused about comparing lists using >.  Why is [3,2,1] > [2,10,100]?
10:11:51 <mreh> is that going to cause problems? cabal is telling me it's a missing dependency
10:12:03 <kmc> astory, because 3 > 2
10:12:11 <phenom_> hey folks, how is haskell suited for network services?
10:12:15 <dark> kmc, ((anyChar >> return ()) <|> eof) >> fail "" ?
10:12:17 <astory> kmc: it only compares the first element?
10:12:21 <phenom_> high availability network services ...
10:12:23 <kmc> astory, if they differ
10:12:28 <kmc> if the first element is the same, it compares the second
10:12:30 <kmc> etc.
10:12:34 <kmc> same as sorting words in the dictionary
10:12:36 <dark> this seems to "works", but I don't know why it isn't trying the other branch
10:12:37 <astory> kmc: I see, thanks.
10:12:41 <kmc> (note that strings are lists of Char)
10:12:43 <dark> "work"*
10:12:48 <astory> kmc: ah, logical
10:13:19 <ion> astory: Which section.subsection.paragraph of a book would come first? 3.2.1 or 2.10.100?
10:13:31 <astory> ion: I got it
10:13:41 <kmc> dark, Parsec's (<|>) doesn't fail over if the left parser consumed input before failing
10:13:47 <kmc> dark, that's why Parsec has "try"
10:13:56 <kmc> but, why do you need an odd parser like this?
10:14:02 <kmc> maybe you can change your design to avoid needing it
10:14:15 <dark> I think that my x should accept, but return a value indicating some kind of error, but not a parse error
10:14:26 <mauke> kmc: that '<|> eof' seems pointless
10:14:35 <kmc> yeah it was mostly a joke
10:14:40 <kmc> i guess anyChar will fail at the end of input anyway
10:14:44 <dark> I wanted it to read something, and do some check equivalent to a type check, with guard ( ). but this will make it go to another branch I think
10:14:55 <kmc> *nod*
10:15:02 <dark> maybe I should decouple parsing and checking the data consistency completly
10:15:12 <kmc> you could use... ContT
10:15:22 <mauke> hah
10:15:30 <kmc> for nonlocal exit from your parser
10:15:33 <dark> but this will mean some duplication I think
10:15:46 <dark> o.o nonlocal exit, like, continuation?
10:15:57 <kmc> ContT is the continuation monad transformerm
10:16:10 * dark doesn't feel like it
10:16:20 <kmc> yeah, it's probably not a good idea
10:17:07 <kmc> i agree you should decouple parsing from checking data consistency
10:17:40 <kmc> unfortunately that becomes harder to do the more you encode data consistency in the data's type
10:17:44 <kmc> which is a good thing generally
10:17:48 <dark> I made this into a parser because I have 'functions' (or 'commands') with a variable number of parameters. when it was fixed, I just received the parameters and returned a state monad. I could receive a list, but the command will do a different thing for 0 or 1 parameter, and I don't feel like matching
10:18:29 <dark> then I thought: maybe I could write a parser for the type 'list of tokens', that will accept 0, or 1, or whatever parameters, and combine them with <|> to build the complete command
10:19:16 <dark> (I think the code would be generally better-looking)
10:21:20 <dark> another thing that could solve it would be a high order function over lists, that would combine them.. but then I need to encode all syntax possibilities on it (like, the function might receive 2 mandatory parameters, and plus n parameters; maybe the mandatory parameters are on the end; etc)
10:22:12 <dark> encoding it as a parser of lists, the syntax rule for a specific command would be right next its definition, and not buried on some high order function
10:22:22 <monochrom> @botsnack
10:22:22 <lambdabot> :)
10:22:34 <dark> (but I think in the end I might give up this approach)
10:27:45 <Philonous> @seen edwardk
10:27:45 <lambdabot> Unknown command, try @list
10:27:46 <preflex>  edwardk was last seen on #haskell 3 days, 1 hour, 34 minutes and 9 seconds ago, saying: xplat: cute
10:29:25 <SoleSoul> Hi. I'm writing my first real Haskell application. Is it possible to use the first two chars of a string in pattern matching? I want to write a predicate that tells if a line is a comment or not.
10:30:04 <aavogt> > case "hello" of 'h':'e':_ -> True
10:30:04 <rostayob> SoleSoul: ('a' : 'b' : rest)
10:30:04 <lambdabot>   True
10:30:51 <SoleSoul> Thanks all. Going to try it.
10:30:54 <SoleSoul> :)
10:33:34 <SoleSoul> isComment ('/':'/':_) = True        isComment _ = False    <- this doesn't seem to work. What terrible mistake did I do?
10:35:05 <rostayob> SoleSoul: it should work
10:35:40 <rostayob> > case "//comment" of '/':'/':_ -> True
10:35:41 <lambdabot>   True
10:36:17 <luite> but you might want to use   "//" `isPrefixOf` xs    instead, to prevent errors when your function is presented with a string shorter than two characters
10:36:27 <rostayob> SoleSoul: you could simply do isComment = (== "//") . (take 2)
10:36:35 <rostayob> or isPrefixOf, right
10:36:49 <aavogt> @hoogle String -> String -> Maybe String
10:36:50 <lambdabot> Network.CGI.Cookie findCookie :: String -> String -> Maybe String
10:36:50 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
10:38:25 <SoleSoul> ghc complains about a being a rigid type variable when I try to use the predicate in the line: removeComments l = unlines (filter (not . isComment) (lines l))
10:39:00 <SoleSoul> 1 sec
10:39:17 <SoleSoul> it worked
10:39:39 <SoleSoul> I removed the line isComment :: a -> Bool
10:39:53 <SoleSoul> but why is it wrong?
10:39:54 <rostayob> SoleSoul: if you're parsing something, I'd suggest to use some library like parsec anyway
10:40:09 <rostayob> isComment :: String -> Bool
10:40:11 <byorgey> SoleSoul: because isComment works only for Strings, not for any type a
10:40:56 <SoleSoul> I am parsing something :) I'm very new to haskell and the amount of options is overwhelming. I am going to see what this parsec is.
10:41:12 <rostayob> SoleSoul: no if you just started, no :P
10:41:17 <rostayob> it involves monads
10:41:20 <rostayob> (parsec)
10:41:29 <SoleSoul> ok
10:41:40 <rostayob> but it's really nice and relatively simple
10:41:42 <SoleSoul> I use them anyway but without really understanding
10:41:49 <SoleSoul> for IO
10:41:57 <kmc> sigh
10:41:57 <rostayob> yeah
10:42:01 <mjrosenb> If i have a type constructor called Foo, and a constructor called Foo, is there any way to export the type from a module without exporting the value?
10:42:02 <kmc> no single monad "involves monads"
10:42:05 <SoleSoul> can't be avoided
10:42:14 <rostayob> kmc: eheh
10:42:24 <ClaudiusMaximus> mjrosenb: Foo()
10:42:29 <xxx_man> i want to know how is defined interpretation in second order logic
10:42:49 <kmc> it's not a big deal to use the function (>>=).  the scary M-word only comes in when you ask "what is the set of all types for which (>>=) is defined"
10:42:58 <djahandarie> kmc, I think that they do when they force you to work with the >>= interface and nothing else
10:43:10 <djahandarie> They at least "involve Monads", but perhaps not "monads".
10:43:11 <kmc> yeah, but that won't be the case with IO or with Parsec
10:43:18 <SoleSoul> rostayob: Do you know what was wrong in my type declaration of "isComment"? isComment :: a -> Bool
10:43:23 <kmc> some people have trouble with first-class IO, and wrongly assert that they have trouble with monads
10:43:28 <djahandarie> Huh? It is the case with IO
10:43:37 <djahandarie> You don't get bindIO and returnIO
10:43:40 <rostayob> SoleSoul: isComment works with strings only
10:43:47 <SoleSoul> ahh
10:43:51 <SoleSoul> that's why...
10:43:57 <kmc> sure, but you can mostly pretend (>>=) has the more specific type.  and you get a bunch of IO primitives too
10:44:02 <kmc> so it's not >>= and nothing else
10:44:03 <SoleSoul> I had to add String a => ... ?
10:44:17 <rostayob> SoleSoul: isComment :: String -> Bool
10:44:17 <kmc> SoleSoul, doesn't make sense, String is a type not a typeclass
10:44:26 <SoleSoul> :)
10:44:36 <SoleSoul> sorry :)
10:44:39 <SoleSoul> thanks!
10:45:03 <rostayob> kmc: you are right about monad, I still think that the first month of haskell should be with functors/monads/applicative/etc.
10:45:29 <kmc> that's, like, the opposite of what i said
10:45:38 <byorgey> mjrosenb: I am not 100% sure, but try exporting  Foo()
10:45:39 <astory> why is True > False?
10:45:46 <kmc> astory, why not?
10:45:53 <kmc> @src Bool
10:45:54 <lambdabot> data Bool = False | True deriving (Eq, Ord)
10:45:54 <byorgey> mjrosenb: which should say to export the type Foo but none of its constructors
10:45:55 <SoleSoul> this irc room is interesting as Haskell itself. any simple question brings up an in depth examination of some aspect of the language...
10:46:01 <astory> kmc: I can accept that it's arbitrary, but I was hoping there was some motivation
10:46:03 <djahandarie> How the hell did you type that so fast kmc?
10:46:06 * djahandarie must be lagging
10:46:06 <rostayob> kmc: that's why I said "I still think that..>"
10:46:09 <djahandarie> That was like an instant response lol
10:46:24 <rostayob> kmc: I think it's useless at the beginning anyway
10:46:27 <kmc> SoleSoul :)
10:46:38 <hpaste> anonimous pasted "no"  http://hpaste.org/44567
10:46:40 <Philippa> <kmc> sure, but you can mostly pretend (>>=) has the more specific type.  and you get a bunch of IO primitives too <- until you miss off return when you were trying to return a list, which confuses the hell out of most people first time
10:46:56 <kmc> yeah
10:47:09 <Philippa> (or a Maybe, or... and those're pretty common types)
10:47:18 <rostayob> kmc: moreover, haskell is really nice just playing with ghci at the beginning... I didn't even know type classes for the first month I think ehe
10:47:46 <mjrosenb> byorgey: ahh, and just Foo would have exported the type Foo and all of its constructors, which happens to jst be Foo.
10:48:09 <Philippa> kmc: we really need more research into providing good domain-specific error messages for EDSLs
10:48:16 <kmc> yeah
10:48:35 <Philippa> (the problems you get when you're using a bunch in the same code get messy, which is half the problem)
10:49:50 <hpaste> anonimous pasted "no"  http://hpaste.org/44568
10:50:25 <rostayob> not strictly haskell related, but does anybody have a clue on how to balance kd-trees? can't find anything. Also, is there any good tutorial on template haskell?
10:51:46 <byorgey> mjrosenb: right.
10:52:17 <byorgey> mjrosenb: uh, wait, no, normally if you just type  Foo it exports only the type and not its constructors
10:52:29 <byorgey> mjrosenb: but there might be some weirdness here because they have the same name
10:52:32 <byorgey> I am not quite sure.
10:52:36 <hpc> Foo(..) exports constructors
10:52:42 <hpc> and accessors, if a record
10:52:43 <byorgey> read the Report if you want to be sure =)
10:52:46 <hpc> iirc
10:53:59 <mreh> the linker is going crazy when it tries to link in my own library code
10:54:54 <astory> is there a way to get the compiler to warn you about non-exhaustive matches?
10:55:02 <hpc> yes
10:55:05 <hpc> um
10:55:12 <hpc> -Wall will do it i think
10:55:13 <rostayob> astory: -Wall doesn't?
10:55:33 <astory> rostayob: ah, I was just trying the interpreter, I should have been more specific
10:55:40 <astory> if that's the case, I'll just compile to see the warnings
10:55:49 <astory> (sorry, I'm working through the tutorial)
10:56:05 <kmc> you can run GHCi with -Wall
10:56:09 <kmc> and you probably should ;)
10:56:29 <astory> kmc: that does it, thanks :D
10:57:52 <hpc> you can set -Wall in the ghci rc, i think
11:00:26 <Jesin> hmm
11:02:24 <Jesin> pattern-matching on a newtype constructor does not change strictness in any way, correct?
11:02:52 <byorgey> Jesin: right
11:03:16 <byorgey> because at runtime it is a no-op.
11:04:16 <Jesin> newtype Tower tag a = Tower [a] deriving Show
11:04:18 <Jesin> bundle :: Num a => a -> Tower tag a -> Tower tag a
11:04:19 <Jesin> bundle x0 x' = toTower (x0:fromTower x')
11:04:21 <Jesin> -- The following forces its second argument's structure, which is very bad:
11:04:22 <Jesin> -- bundle x0 (Tower xs) = toTower (x0:xs)
11:04:24 <Jesin> ^this is just superstitious coding, then?
11:04:31 <Jesin> https://github.com/bjornbm/fad/blob/master/Numeric/FAD.hs
11:04:52 <Peaker> dibblego, Did you see the HN submission about your blog?
11:06:01 <monochrom> yeah, "bundle x0 (Tower xs)" evaluates nothing
11:06:51 <Jesin> is that worth submitting a low-priority bug report about or would that just be annoying  :p
11:07:22 <SoleSoul> for some reason, this patter matching : isEmptyLine [] = True    doesn't match an empty line received from the function lines. Am I doing it wrong?
11:07:46 <Peaker> SoleSoul, "lines" doesn't return a line, it returns a list of lines
11:07:54 <Peaker> @type lines
11:07:55 <lambdabot> String -> [String]
11:07:59 <Peaker> @src String
11:07:59 <lambdabot> type String = [Char]
11:08:16 <Peaker> [Char] -> [[Char]] -- so if you match the resulting [[Char]] against [], you get an empty list of lines
11:08:49 <SoleSoul> Peaker: I am using the predicate as an argument for "filter".
11:09:29 <SoleSoul> I thought that this way the predicate gets the lines one by one.
11:09:48 <SoleSoul> I am filtering the output of "lines" with this predicate
11:09:53 <Peaker> SoleSoul, oh, then it does
11:09:55 <Peaker> @src null
11:09:55 <lambdabot> null []     = True
11:09:55 <lambdabot> null (_:_)  = False
11:10:11 <Peaker> SoleSoul, why don't you use this function?
11:10:33 <hpc> > null []
11:10:33 <lambdabot>   True
11:10:36 <hpc> > null [[]]
11:10:36 <lambdabot>   False
11:10:40 <hpc> > map null [[]]
11:10:41 <lambdabot>   [True]
11:10:43 <hpc> :D
11:10:45 <Jesin> hmm, well
11:10:57 <Jesin> I guess https://github.com/ekmett/ad is writing a replacement autodiff package anyway
11:11:23 <SoleSoul> because I want to check whether the line is empty or comment. I wanted to combine them to one function with pattern patching
11:11:27 <Jesin> and from the looks of it he knows how newtype works
11:11:56 <SoleSoul> @src
11:11:56 <lambdabot> src <id>. Display the implementation of a standard function
11:12:21 <geheimdienst> @src length
11:12:21 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:14:26 <hpc> length [] = 0; length (x:xs) = 1 + length xs
11:15:22 <hpc> or if you are feeling crazy
11:15:40 <hpc> length = sum . (1 $>)
11:15:44 <hpc> :t ($>)
11:15:45 <lambdabot> Not in scope: `$>'
11:15:53 <hpc> :t (<$)
11:15:54 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
11:16:04 <hpc> :t sum . (<$ 1)
11:16:05 <lambdabot>     No instance for (Num [b])
11:16:05 <lambdabot>       arising from the literal `1' at <interactive>:1:10
11:16:06 <lambdabot>     Possible fix: add an instance declaration for (Num [b])
11:16:24 <Jesin> gah, he uses {-# LANGUAGE TemplateHaskell #-} though
11:16:41 <Jesin> is that really necessary?
11:16:43 <Jesin> hmm
11:18:18 <aristid> Jesin: if he uses template haskell, it is obviously necessary :)
11:18:59 <Jesin> was that sarcastic or truthful
11:19:01 <Jesin> :p
11:19:05 <Jesin> err, I mean
11:19:10 <Jesin> straightforwardly truthful
11:19:30 <Peaker> Not in H2010?
11:21:13 <Paul__> Hi
11:21:14 * hackagebot derp 0.1.5 - Derivative Parsing  http://hackage.haskell.org/package/derp-0.1.5 (DavidDarais)
11:21:39 <kmc> i am so happy we have a package named "derp"
11:21:45 <Paul__> Can anyone show me an example of list comprehension?
11:21:49 <kmc> it can be friends with "berp"
11:21:51 <Philippa> kmc: do we have a herp?
11:21:58 <kmc> > [ x^2 | x <- [1..50], odd x ]
11:21:59 <lambdabot>   [1,9,25,49,81,121,169,225,289,361,441,529,625,729,841,961,1089,1225,1369,15...
11:22:05 <kmc> squares of odd numbers from 1 to 50
11:22:24 <mreh> waaah, cabal isn't installing my library correctly
11:22:46 <mreh> atleast I assume so, when ghc tries to link it in, it does
11:22:50 <mreh> dies*
11:23:15 <hpc> :t foldl
11:23:16 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:23:28 <copumpkin> preflex: seen wli
11:23:28 <preflex>  wli was last seen on #haskell-blah 159 days, 1 hour, 55 minutes and 43 seconds ago, saying: boshhead: Instead of making the derivatives match up to the n-th order at a single point (Taylor series) you can use several points, or both ends of an interval, or similar.
11:24:10 <Paul__> Thanks kmc, is there a way to create an infinite list though, and then print the 20th element or something. That's what I'm looking for
11:24:47 <kmc> > [ x^2 | x <- [1..], odd x ] !! 20
11:24:48 <lambdabot>   1681
11:25:09 <kmc> > take 20 [ x^2 | x <- [1..], odd x ]
11:25:10 <lambdabot>   [1,9,25,49,81,121,169,225,289,361,441,529,625,729,841,961,1089,1225,1369,15...
11:25:37 <Paul__> Alright! That's really cool. Thanks :)
11:26:11 <kmc> idioms i like:  fix $ \loop -> do ...
11:26:12 <Jesin> oh, hm
11:26:14 <Jesin> https://github.com/ekmett/ad/blob/master/Numeric/AD/Internal/Classes.hs
11:26:16 <kmc> learned that from xmonad
11:26:28 <Jesin> that definition of deriveLifted, does that use Template Haskell?
11:27:02 <kmc> Jesin, it uses the TH tpes and functions
11:27:05 <kmc> like Q, Type, Dec, etc.
11:27:13 <Jesin> deriveLifted :: ([Q Pred] -> [Q Pred]) -> Q Type -> Q [Dec]
11:27:15 <Jesin> deriveLifted f _t = do
11:27:17 <Jesin>         [InstanceD cxt0 type0 dec0] <- lifted
11:27:18 <Jesin> [...]
11:27:20 <Jesin> k.
11:27:23 <kmc> oh, and it uses TH syntax extensions too
11:27:32 <kmc> you already linked it ;P
11:27:36 <kmc> lifted = [d| ... |]
11:27:40 <kmc> that's a declaration quote
11:27:42 <Jesin> hm
11:27:49 <Jesin> is that just needed for compilation, though?
11:28:26 <kmc> i don't know what you mean
11:28:38 <Jesin> hmm
11:28:46 <Jesin> well, I'm wondering
11:28:48 <kmc> the purpose of deriveLifted is to generate some Haskell code
11:28:52 <kmc> specifically, an instance declaration
11:28:53 <Jesin> if the package doesn't export Internal
11:28:57 <Philippa> do we have a good way of taking an applicative and quoting all the pure bits?
11:29:19 <Jesin> I wonder if template haskell is needed after the package is compiled
11:29:28 <Philippa> (suppose I've got an applicative but I /really/ want to do all the funky static analysis in TH at compile-time...)
11:29:31 <kmc> needed how?
11:29:34 <Jesin> in compiling other code that imports it
11:29:35 <kmc> it comes with GHC
11:29:38 <Jesin> umm, that imports AD
11:29:40 <Jesin> hm?
11:29:42 <Jesin> it does?
11:29:44 <Jesin> k.
11:29:45 <kmc> yes
11:29:46 <kmc> if your code doesn't use TH syntax
11:29:49 <Jesin> I don't have GHC 7 yet
11:29:52 <kmc> then you don't need {-# LANGUAGE TemplateHaskell #-}
11:30:01 <Philippa> (...don't mind if all I get is function values so long as I can get the code I'm splicing to use them)
11:30:05 <Jesin> right, ok
11:30:06 <kmc> even if you do import TH modules and use them
11:30:06 <kmc> it comes with GHC since long time
11:30:30 <kmc> (it kind of has to; TH is deeply integrated with the compiler for tolerably obvious reasons)
11:30:40 <Jesin> apparently this ad package is unfinished, though, the version that's up on hackage has a "build failure"
11:30:50 <Jesin> yeah  :p
11:31:10 <kmc> the perfect is the enemy of the good
11:31:32 <copumpkin> enemy is a symmetric relation
11:31:37 <copumpkin> the good is the enemy of the perfect
11:31:39 <Jesin> lol
11:31:40 <copumpkin> get rid of good shit
11:31:45 <copumpkin> it's holding up our perfection
11:32:18 <Jesin> perfection is very subject to thermodynamic disturbances
11:32:41 <mreh> i think i've broken GHC
11:32:53 <mreh> where's the nuke button?
11:33:12 <Jesin> killall -9 ghc?
11:33:14 <Jesin> :p
11:33:28 <Jesin> or whatever windows does if you're using that?
11:33:40 <mreh> ghc-pkg unregister *
11:33:40 <kmc> the windows equivalent is to power-cycle the machine
11:33:57 <mreh> ghc-pkg unregister * --force
11:34:00 <Jesin> hmm
11:34:07 <monochrom> @quote detonational
11:34:08 <lambdabot> No quotes match. Are you on drugs?
11:34:22 <ion> rm -r ~/.ghc ~/.cabal
11:34:27 <Jesin> [15:10:27]	<copumpkin>	get rid of good shit
11:34:29 <Jesin> [15:10:32]	<copumpkin>	it's holding up our perfection
11:34:34 <Jesin> that is what forks are for
11:34:45 <mreh> detonational.. that's good
11:35:04 <mreh> google ghc reinstall, and all you get is installation guides
11:35:57 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/85386/ :)
11:37:49 <mreh> manual removal time
11:38:59 <niteria> is there a function in Prelude that outputs Fractional with 2 digit precision?
11:40:14 <mauke> probably not
11:40:25 <Jesin> 2 significant digit, you mean?
11:40:26 <hygge> good evening! is there a function [a] -> (a->Bool) -> Integer, that gives the first index in the list that passes the condition?
11:40:28 <mreh> printf
11:40:43 <niteria> I want sth like printg
11:40:45 <mauke> @hoogle [a] -> (a->Bool) -> Integer
11:40:46 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:40:46 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
11:40:47 <niteria> printf
11:40:53 <mauke> niteria: why not use printf?
11:41:29 <Jesin> @hoogle findIndex
11:41:29 <lambdabot> Data.ByteString findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int
11:41:29 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
11:41:30 <lambdabot> Data.Map findIndex :: Ord k => k -> Map k a -> Int
11:42:13 <Jesin> hygge: Data.List.findIndex is probably the closest to your specifications
11:42:32 <hygge> thx Jesin and mauke 
11:42:35 <Jesin> its argument order is flipped, and it gives Int instead of Integer
11:42:43 <Jesin> but it does what you want, basically
11:42:45 <Jesin> :p
11:43:49 <niteria> mauke: i didn't know there was printf
11:44:20 <mauke> niteria: have a look at the stuff in Numeric and Text.Printf
11:46:28 <niteria> uhh, typesafe printf
11:46:42 <niteria> weird :D
11:46:44 <aristid> niteria: Text.Printf is not really typesafe
11:49:02 <niteria> if there is sscanf then I'm home
11:49:45 <mauke> there isn't AFAIK
11:50:13 <kmc> the more typesafe version of printf uses Template Haskell to generate code at compile time
11:50:22 <kmc> but really, printf is a poor fit for Haskell
11:50:25 <mauke> not mine!
11:50:49 <mauke> my TH printf just adds static type checks, then calls the other version
11:50:50 <kmc> printf works the way it does because C has very poor support for data structures
11:51:08 <kmc> in Haskell, we wouldn't specify formatting with a string; we'd specify it with a statically-typed combinator library
11:51:20 <mauke> I wouldn't
11:51:30 <burp> :t printf
11:51:30 <lambdabot> forall r. (PrintfType r) => String -> r
11:51:34 <burp> magic :D
11:51:34 <mauke> format strings are much superior
11:51:43 <kmc> most Haskell EDSLs don't use a string for syntax
11:52:36 <hpaste> allbery_b pasted "example debugStackHook output"  http://hpaste.org/44571
11:52:40 <niteria> if there was statically-typed combinator library for string formating I would use
11:52:51 <niteria> it
11:52:58 <chrisf|work> a statically-typed combinator library for format strings sounds like a headache for i18n.
11:53:28 <mauke> niteria: there are a few
11:56:33 <kmc> format strings are also a headache for i18n
11:56:36 <kmc> but a well-understood headache
11:58:37 <Philippa> static typing might even help keep track of which issues you've baked in and which combinations you've got /some/ way of displaying
12:01:17 <niteria> can where be nested?
12:01:27 <mauke> yes
12:01:36 <hpc> nested where will get scary fast though
12:01:45 <kmc> i'd prefer "let"
12:02:01 <kmc> the essential role of "where" is pretty limited
12:02:06 <kmc> to scope over multiple guards for the same equation
12:02:12 <kmc> otherwise, it's an alternative to "let"
12:02:25 <Philippa> kmc: matter of taste though, top-down vs bottom-up
12:06:57 <kmc> how can i get my libraries featured in HWN?
12:09:31 * hackagebot hdis86 0.1 - Interface to the udis86 disassembler for x86 and x86-64 / AMD64  http://hackage.haskell.org/package/hdis86-0.1 (KeeganMcAllister)
12:12:50 <niteria> what would you change? https://gist.github.com/857653
12:13:00 <niteria> to make it more haskell'ish
12:13:35 <niteria> it's supposed to solve http://www.codechef.com/problems/HS08TEST/
12:13:42 <xxx_man> does anybody from here knows henkins semantics?
12:14:14 <ddarius> xxx_man: Do you have a question related to Haskell?
12:14:24 <xxx_man> no
12:14:43 <ddarius> xxx_man: Then why are you here?
12:15:04 <xxx_man> to make fun
12:15:28 <hpc> and the truth shall set you free!
12:15:43 <hpc> ("set you free" not to be confused with "ban you from the channel" :P)
12:16:05 <saml> how is u?
12:16:27 <hpc> u is between t and v
12:16:29 <xxx_man> hpc: do u talk to me?
12:17:18 <saml> how is large scale program haskell be?
12:17:34 <Philippa> xxx_man: do you mean the Henkin semantics of second-order logic?
12:17:47 <xxx_man> yess
12:17:50 <xxx_man> exactly
12:20:10 <Philippa> xxx_man: nope, don't know shit, just know how to google and read wikipedia :-)
12:20:37 <dolio> Hey, that's the answer I gave.
12:21:03 <xxx_man> :)
12:21:04 <Philippa> I can see a vague relationship to haskell via Curry-Howard, FWIW
12:21:07 <xxx_man> not enough
12:21:23 <Philippa> don't know that it'd tell us much we didn't already know, though?
12:21:51 <xxx_man> yes
12:22:56 <Philippa> so, why do you ask other than to take the piss?
12:23:42 <pygmalion> hi all. i have a data type that is using the Day type from Data.Time.Calendar and I was hoping to compare the stored Day to today... i can't see any way within Data.Calendar to easily do this. am i missing something?
12:31:34 <aristid> oh, "Simon Haskell: Urban planner, foodie, tech-geeks": https://profiles.google.com/ :D
12:32:13 <geheimdienst> dr. horrible?
12:34:04 * povik loves haskell :)
12:35:21 <aristid> geheimdienst: isn't that accurate?
12:42:51 <tombee> is there a good way of building a table out of a [(String, String)] ?
12:43:11 <tombee> a bit like how you could use a formatted print in C or something
12:43:11 <astory> is it correct to think of $ as function composition, like f o g ?
12:43:33 <glguy> Function *application*
12:43:34 <napping> no, it's just application
12:43:36 <augustss> astory: no
12:43:52 <hpc> > succ $ 5
12:43:53 <lambdabot>   6
12:44:00 <augustss> > succ 5
12:44:00 <astory> ah, I see
12:44:00 <lambdabot>   6
12:44:01 <hpc> > succ . succ $ 5
12:44:03 <lambdabot>   7
12:44:28 <napping> it's low precedence, so it's often used to a pply a function built up with operators like .
12:44:50 <astory> thanks :D
12:44:50 <hpc> it is less often used as part of a combinator
12:44:53 <hpc> :t foldr ($)
12:44:55 <lambdabot> forall b. b -> [b -> b] -> b
12:44:59 <napping> "." is the actual composition operator
12:45:18 <hpc> > foldr 0 [succ, succ, (*2)]
12:45:19 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a1 -> a1])
12:45:19 <lambdabot>    arising from...
12:45:25 <Cale> > zipWith ($) [id, reverse, map toUpper] (words "hello there world")
12:45:26 <lambdabot>   ["hello","ereht","WORLD"]
12:45:26 <aavogt> tombee: use functions from Text.PrettyPrint, and unzip too
12:45:41 <hpc> > foldr ($) 0 [succ, succ, (*2)]
12:45:41 <lambdabot>   2
12:45:53 <hpc> > foldr ($) 0 [(*2), succ, succ]
12:45:54 <lambdabot>   4
12:46:04 <tombee> thanks aavogt, do you happen to have an example? :)
12:46:16 <aavogt> > hcat [vcat (map text $ words "hi there"), vcat (map text $ words "a b")]
12:46:17 <lambdabot>   hi
12:46:17 <lambdabot>  therea
12:46:35 <aavogt> hmm, not exactly right
12:46:48 <lysgaard> How is the syntax for loading multiple files in ghci
12:46:59 <aavogt> > hcat $ map vcat $ transpose [map text $ words "hi there", map text $ words "a b"]
12:47:00 <lambdabot>   hi
12:47:00 <lambdabot>  athere
12:47:24 <fryguybob> lysgaard: :m Module
12:47:59 <fryguybob> lysgaard: :m + Module  that is.
12:51:27 <hpc> or import
12:51:30 <hpc> import Module works fine
12:54:58 <lysgaard> fryguybob: thanks
12:59:41 <monadic_kid> leksah seriously needs splitter views
12:59:58 <Tomsik> Question time!
13:00:08 <Tomsik> I've got a laaazy list of [Double] type
13:00:28 <Tomsik> but then I want to take some n first elements out of it
13:00:38 <Tomsik> and make sure, that it's fully evaluated
13:00:55 <btutt> Lists are just lazy layabouts aren't they?
13:01:25 <Tomsik> so my alsa thing won't make this unpleasant buffer underrun sound
13:01:27 <napping> the first n, or the whole tial?
13:01:31 <dibblego> Tomsik: why do you want to make sure it is fully evaluated?
13:01:34 <hpc> take' n (x:xs) = x `seq` x:(take (n-1) xs)
13:01:39 <hpc> Tomsik: ^
13:01:40 <napping> rnf
13:01:41 <aristid> @hoogle deepseq
13:01:41 <lambdabot> No results found
13:01:45 <hpc> plus the extra patterns, etc
13:01:48 <aristid> lambdabot: :/
13:01:54 <Tomsik> I just tried to do map (\x -> seq x x) 
13:02:02 <napping> that doesn't do anything
13:02:02 <btutt> @pgk deepseq
13:02:02 <lambdabot> Maybe you meant: ask pl
13:02:09 <btutt> @pkg deepseq
13:02:10 <lambdabot> Maybe you meant: bug msg ping pl
13:02:14 <btutt> bleh
13:02:15 <napping> map is lazy as well
13:02:18 <aristid> @hackage deepseq
13:02:18 <lambdabot> http://hackage.haskell.org/package/deepseq
13:02:23 <btutt> there we go
13:02:32 <aristid> btutt: see my awesome lambdabot skillz!
13:02:36 <btutt> ;)
13:02:45 <azaq23> > let take' n xs = id $! take n xs in take' 10 [1, 2, undefined] ++ [3 ..]
13:02:47 <lambdabot>   [1,2,*Exception: Prelude.undefined
13:03:08 <btutt> @hoogle rnf
13:03:09 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
13:03:24 <hpc> Strategy is an alias for i forget what
13:03:37 <monadic_kid> there are 2 libraries with rnf
13:03:40 <hpc> oh, a -> a
13:03:40 <aristid> let take' n xs = let r = take n xs in r `deepseq` r
13:03:40 <btutt> :t Strategy
13:03:41 <lambdabot> Not in scope: data constructor `Strategy'
13:03:56 <hpc> @src Strategy
13:03:56 <lambdabot> Source not found. Take a stress pill and think things over.
13:04:59 <btutt> @src NFData
13:04:59 <lambdabot> Source not found. I am sorry.
13:06:46 <btutt> lambdabot clearly needs another physic  upgrade
13:06:49 <ezyang> Does anyone use ConstrainedClassMethods? 
13:09:18 <napping> I see t suggested from time to time
13:09:39 <Tomsik> I'm starting to wonder that maybe withArray is to blame
13:09:58 <sshc> I wonder how printf works
13:10:25 <dolio> ezyang: I'd never heard of it before.
13:10:26 <ddarius> You can look at the source code.
13:10:40 <napping> why are you asking?
13:10:57 <niteria> https://gist.github.com/857719 , can I make this faster?
13:11:02 <napping> oh, is that the flag to add back the restriction?
13:11:16 <niteria> fctrl2 is little bit faster than fctrl
13:12:31 <napping> I can't see how that restriction helps the implementation or the user
13:12:33 <niteria> but both are unbearably slow, maybe it's I/O
13:13:06 <augustss> niteria: read is slow
13:13:15 <BMeph> niteria: There is no 'maybe' here - profile it! ;)
13:14:14 <hpc> wow, that was fun
13:14:15 * BMeph prefers "iterate (*5) 1" to "map (5^) [1..]"
13:14:48 <tab> i'm feeling great disturbance in the irc channel
13:14:50 <aristid> BMeph: why?
13:14:54 <pwp> What are some of the advantages of using Haskell over other languages?
13:15:23 <napping> equational reasoning
13:15:47 <niteria> augustss: how can I replace read?
13:15:52 <napping> it's enough different from most other things it's well worth learning anyway
13:16:12 <pwp> Even if I already know another functional language?
13:16:22 <napping> which one?
13:16:28 <pwp> Scheme.
13:16:38 <mauke> pwp: static types
13:16:51 <btutt> Haskell is definitely substantially different from scheme.
13:17:16 <BMeph> aristid: It "feels" faster. ;)
13:17:48 <aristid> BMeph: heh, yeah. but have you measured it? :)
13:17:51 <hpc> scheme still makes it too easy to break refrential transparency
13:17:52 <hpc> imo
13:18:13 <astory> where can I find out implementation details of a function, specifically, what kind of sort Data.List.Sort does?
13:18:21 <pwp> What is its typical problem domain? (I realize it is a general purpose language, but that being said, so is Ruby. Still, Ruby is often used for web programming via Rails.)
13:18:25 <hpc> @hoogle sort
13:18:25 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
13:18:26 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
13:18:26 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
13:18:35 <hpc> Astro: ^
13:18:40 <hpc> look for the source of Data.List
13:18:45 <pwp> * most often, rather.
13:18:46 <hpc> it's easy to get to on hackage
13:18:54 <aristid> astory: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#sort
13:19:06 <astory> thanks, that's exactly the kind of place I was looking for
13:19:19 <BMeph> aristid: Only in GHCi.
13:19:28 <astory> , and so it's mergesort.  Logical
13:19:29 <aristid> BMeph: and it was faster?
13:19:37 <tab> pwp: it's probably better to ask what is not its typical problem domain :)
13:19:47 <aristid> astory: yep, mergesort makes a lot of sense for linked lists
13:19:52 <niteria> readInt has a funny type
13:20:02 <aristid> astory: it's an optimised variant of mergesort, tho
13:20:03 <napping> symolic stuff is pretty good
13:20:05 <pwp> Haha... Good answer. What are some of the more popular projects using it?
13:20:08 <napping> embedding languages, etc
13:20:10 <astory> aristid: I'd never thought about sorting over anything other than an array before
13:20:27 <napping> xmonad is probably the most popular
13:20:35 <aristid> astory: well, in haskell, the most popular data structure is certainly the list
13:20:45 <astory> aristid: yeah, I understand that
13:20:48 <aristid> astory: it is of course possible to use arrays, too, and also sort them ;)
13:21:00 <niteria> oh, I was looking for readDec -.-
13:21:16 <BMeph> aristid: I believe it's because the 'iterate' expression uses the relationship between adjacent entries in the list, whereas the 'map' one re-calculates each entry individually (barring heavy optimization).
13:21:44 <pwp> Cool, I haven't actually ever heard of xmonad, but a quick good search makes me think maybe I should have.
13:21:52 <napping> that's an X11 window manager, so not really much to do with the compiler/interpreter stuff
13:21:53 <Philippa> pwp: the typical /good/ problem domain is stuff that's structurally hairy from an OO POV but can be made to factor well if you think hard enough. Beyond that we don't care too much (though systems programming is a little tougher) - there's just a bunch of FFI work to be done in the worst case
13:21:56 <pwp> google, not good.
13:22:11 <Gabbie> Friend of mine swears by xmonad
13:22:26 <niteria> omg, why won't readDec "-12" work
13:22:35 * geheimdienst swears by xmonad
13:22:41 <aristid> BMeph: yes. however, if (^) was implemented by the processor natively, and you stayed in the range of Int, it might have the same speed
13:22:45 <napping> The big difference between Haskell and the ML family is purity / isolation of effects
13:22:57 <napping> that makes stuff like STM actually workable
13:22:58 <astory> napping: also, type systems
13:23:14 <napping> type systems are not too different
13:23:20 <napping> type classes, I guess
13:23:44 <aristid> napping: type clases are pretty significant, i'd say
13:23:57 <pwp> I may invest a weekend or two to learn it's syntax and maybe play with a somewhat difficult problem. Spring break is next week, so I think I will plan on busting out Haskel...
13:23:57 * BMeph swears at xmonad, occasionally... ;)
13:23:58 <napping> not compared to the difference from Scheme
13:24:14 <pwp> Sounds neat thanks guys(/girls).
13:25:02 <astory> napping: it makes a big difference if you're involved in implementing a type system, which I'm doing now for a project (ocaml -> python compiler, in ocaml)
13:25:06 <napping> has anyone tried the Haskell platform candidate?
13:25:32 <napping> ?!
13:25:32 <lambdabot> Maybe you meant: . ? @ v
13:25:40 <BMeph> aristid: Also, if the compiler knows it and exploits it. But, really, to exploit the relationship, the compiler needs to know how exponentials relate; the 'iterate' form does it automatically. :)
13:25:42 <napping> why would anyone compile to Python?
13:26:17 <napping> Javascript, JVM, CLR, C, these I understand
13:26:19 <niteria> how do I profile single file simple program?
13:26:36 <astory> napping: we're working with a large poorly written libary to do some complex networking stuff and want to present a functional interface to it
13:26:46 <monochrom> many linux distros favour python
13:27:04 <napping> and don't accept native binaries?
13:27:17 <aristid> BMeph: yes :)
13:27:41 <aristid> BMeph: relying on the compiler there seems to be ... well, maybe SPJ will implement that optimization in GHC 8 ;)
13:27:49 <napping> where is the Haskell Platform release candidate?
13:28:04 <ezyang> Hmm. I wonder if it's appropriate to say Rank2Types subsume Polymorphic components. I guess that's only true if you're using them with GADTs 
13:28:57 * BMeph wonders if "return ()" is as logically offensive as "if boolVar == True" ...
13:29:21 <niteria> Failed to load interface for `Prelude':
13:29:32 <niteria> Perhaps you haven't installed the profiling libraries for package `base'
13:29:41 <niteria> how do I install them?
13:30:33 <BMeph> aristid: Right. However, it seems not unreasonable to expect an optimized 'iterate' expression to be compiled to a (relatively) small loop.
13:30:48 <aristid> poor sigfpe being mocked for being unable to count :D
13:30:56 <c_wraith> niteria: they're usually installed by default, though I guess some OS package managers mess that up.  Look for a profiling package in your package manager
13:31:15 <napping> BMeph: no worse than const ()
13:31:15 <ddarius> aristid: We have computers to do our counting now.
13:32:34 <hpc> return () is a fine line to have in a do block
13:32:46 <hpc> if you don't want the function to have a return value
13:33:03 <thunkee> i' a bit confused why to use () with . esp with lists like with putStr.unlines 
13:33:08 <pozic> napping: where is your high performance Haskell version?
13:33:14 <napping> is the platform release available anywhere
13:33:26 <napping> pozic: other OS, unfortunately
13:33:32 <Heffalump> napping: the current RC?
13:33:40 <pozic> napping: and did you get to the 950MB/s?
13:33:40 <napping> Heffalump: sure
13:33:41 <monadic_kid> BMeph: if i have a action of type m () and the last thing it does is use an action of type m a then I have no choice but to use return ()/pure ()/ignore
13:34:04 <aristid> return x = fmap (const x) (return ())
13:34:08 <napping> pozic: I got a nice program matching the fastest Haskell program
13:34:16 <monadic_kid> BMeph: Monad m => m ()
13:34:22 <pozic> napping: what is the fastest Haskell program?
13:34:25 <Heffalump> I think details will be posted to the platform list when it's ready for general testing
13:34:32 <napping> pozic: my fastests, rather
13:34:44 <Veinor> pozic: main = return () ?
13:34:46 <Veinor> :D
13:34:48 <pozic> napping: the fastest I have seen from a Haskell program is 650MB/s.
13:35:12 <napping> pozic: a proper mapIO_ for ByteStrings is many times faster than anything you can do with the existing safe interface
13:35:32 <pozic> napping: but still slow.
13:36:07 <napping> and I came up with a safe variant of read and write that optimizes to hoist out bounds checks for a Bounded type
13:36:19 <aristid> > 650*8
13:36:20 <lambdabot>   5200
13:36:33 <niteria> what's CAF?
13:36:35 * Philippa takes pozic out of context and suggests return ()
13:36:38 <napping> pozic: Oh noes, a completely saturated SATA 6 connection takes almost a whole core
13:36:39 <aristid> pozic: you can fill USB 3 and 5 gigabit ethernet connections with that rate :)
13:36:44 <Philippa> bah, Veinor beat me to it
13:37:13 <pozic> aristid: the first version was about 50 times slower than that with GHC 7 and 300 times slower with GHC 6.12.
13:37:18 <sjanssen> niteria: Constant Applicative Form
13:37:39 <sjanssen> http://www.haskell.org/haskellwiki/Constant_applicative_form
13:37:40 <aristid> pozic: you seem to concentrate on pretty unrealistic benachmarks
13:37:56 <napping> half the performance of tuned C seems a fine target in the absence of any practical needs
13:38:15 <pozic> aristid: I am not concentrating on that in any way.
13:39:08 <pozic> aristid: I just think that a language in which types are as exactly known an they are in Haskell should be at least as fast as C++ using less lines of code/boilerplate. 
13:39:12 <jekor> I have a Handle that I put into a TVar [Handle] (connection pool). When I atomically acquire it I can use it fine. If I then put the Handle back into the pool, acquire it again, and then try to use it I get "resource vanished (Broken pipe)". Is the handle being closed by the compiler/STM interaction somehow?
13:39:24 <pozic> aristid: but all evidence suggests otherwise.
13:39:24 <aristid> pozic: then work on GHC.
13:39:40 <niteria> CAF is taking all my time
13:39:50 <napping> Heffalump: too bad, I wanted to get Agda installed, and I though I might as well get a recent GHC while I'm at it
13:39:56 <pozic> aristid: what kind of an argument is that?
13:40:02 <napping> Heffalump: happy is required, so the plain GHC isn't enough
13:40:16 <pozic> as*
13:40:34 <napping> pozic: It's not so simple when lazy evaluation and boxed types are the default
13:41:07 <sjanssen> jekor: STM shouldn't cause any problems in that area.  I would guess that the client on the other end of the Handle is closing it?
13:41:18 <pozic> I wonder how ATS would do on the task.
13:42:02 <aristid> pozic: it's not an argument. it's a suggestion to help you achieve your goals
13:42:17 <pozic> aristid: my goals are pretty much distinct from GHC.
13:42:20 <jekor> sjanssen: Before I introduced STM, it worked fine. I would use the handle and interact with the other side (same commands) to completion.
13:42:50 <jekor> I've had strange Handle-disappearing problems in the past. I just can't remember why.
13:43:11 <napping> how do you use the Handle?
13:43:32 <napping> pozic: I'm a bit surprised you say "950 MB/s" as if that's a portable number
13:43:38 <jekor>   h <- connectTo host (PortNumber 3306) -- connect
13:43:49 <monadic_kid> ATS's current syntax is eye bleeding
13:44:04 <jekor> Then it runs through a few hPut+hFlush to initialize the connection (communicating to a MySQL server).
13:44:45 <napping> pozic: ATS has linear and dependent types
13:44:57 <dolio> GHC has dependent types.
13:44:57 <pozic> napping: if you get more than 1GB/s using any Haskell implementation on whatever hardware you have you are free to show me your Haskell program. 
13:45:12 <jekor> After acquiring the handle in another thread, it runs a similar interaction (hPut/hGet).
13:45:16 <pozic> napping: otherwise that comment is pretty much useless.
13:45:40 <pozic> napping: so, perhaps linear and depedent types are a better way to write programs?
13:45:45 <jekor> At that point, if I were to continue sending more commands to the MySQL server it would work. But at that point I put the handle back into the TVar.
13:45:52 <napping> yes, on my bleeding fast T9300
13:46:10 <napping> pozic: linear and dependent types are certainly things I'd include in a new language aiming for speed
13:46:18 <napping> well, speed and safety
13:46:27 <jekor> I guess I should paste some code.
13:46:31 <pozic> napping: so, it is kind of irrelevant to the discussion then. 
13:46:33 <sjanssen> jekor: could you be hitting a server timeout?
13:47:18 <jekor> sjanssen: I don't think so. I've been running tcpdump as I test.
13:47:50 <jekor> I'm going to re-confirm that I didn't change anything unintentionally when I introduced the STM stuff.
13:48:18 <pozic> napping: you could post your code to the mailinglist. I am sure lots of people want to see fast, readable Haskell code. 
13:48:32 <napping> what about your code?
13:49:02 <napping> and on what hardware, for that matter?
13:49:26 <Cale> lambdabot: @join #proglangdesign
13:49:49 <jekor> Thanks guys. It might indeed be something unrelated.
13:50:22 <pozic> napping: I discussed this in private and I don't even have the code anymore. 
13:50:35 <napping> what hardware did you run it on, then?
13:50:51 <pozic> napping: Core i5
13:50:55 <napping> maybe I should just post the C and see if you find it's performance acceptable
13:51:24 <preyalone> Is there a way to compile a Haskell script with a different module name than Main?
13:53:21 <monochrom> yes with ghc. see the ghc user guide.
13:53:53 <basvandi`>  preyalone: see the -main-is flag
13:54:03 <preyalone> basvandi`: Thanks!
13:54:07 <hpc> jekor: are you writing your own mysql driver?
13:55:02 <jekor> hpc: I'm writing a connection pooling daemon, so it speaks just enough of the MySQL protocol to establish a connection and then relay commands/responses.
13:55:19 <pozic> preyalone: it is not Haskell anymore at that point.
13:55:20 <astory> how well does Data.Map scale?
13:55:24 <hpc> ah, i see
13:55:33 <pozic> astory: webscale
13:55:41 <hpc> pozic: lol
13:55:46 <copumpkin> astory: are you asking about its asymptotic behavior?
13:55:53 <copumpkin> that phrase never really made much sense to me
13:56:01 <astory> copumpkin: I'm more worried about using it for a large number of keys
13:56:09 <astory> like, 10s of millions
13:56:16 <preyalone> My goal is to have a Haskell equivalent of Python's if __name__=="__main__", so that my script can serve as both an API for another Haskell script, and an executable all on its own.
13:56:20 <ddarius> copumpkin: Clearly he's asking if Data.Map forms a vector space.
13:56:24 <copumpkin> lol
13:56:33 <ddarius> (Which it actually does if the values are in Num.)
13:56:35 <copumpkin> astory: it's logarithmic access time, so you should be fine
13:56:50 <hpc> preyalone: wouldn't the haskell equivalent just be to put executing stuff in main?
13:56:52 <copumpkin> astory: but if your keys are Ints, you might be better off with an IntMap
13:56:52 <napping> preyalone: I think you can compile like if it has a main:: IO() in the module, and you build with --main-is
13:56:57 <astory> ok, cool.  The tutorial seemed to imply it was implemented with lists, and I didn't see how that could be fast.
13:56:59 <napping> preyalone: check the user guide
13:57:02 <astory> copumpkin: they keys are tuples of strings :/
13:57:05 <copumpkin> ah okay
13:57:08 <ddarius> astory: It's definitely not implemented with lists.
13:57:12 <hpc> oh, for compilation
13:57:13 <copumpkin> a trie would still be a good idea for strings
13:57:21 <copumpkin> but not sure what there is lying around
13:57:26 <dolio> Tuples of strings are also not going to work great with Data.Map.
13:57:27 <niteria> delete this gist
13:57:31 <niteria> sry
13:57:41 <astory> copumpkin: I'm building an n-gram model, I need to map a short list of words to an integer
13:57:50 <astory> list of words of fixed length
13:57:59 <napping> ah, then the list of words might consume memory
13:57:59 <niteria> https://gist.github.com/857807 , can anyone tell me what's the bottleneck?
13:58:03 <pozic> astory: what is the length?
13:58:07 <astory> pozic: <10
13:58:14 <napping> though the tuples should be able to share the strings
13:58:17 <pozic> astory: how long is a word/
13:58:23 <preyalone> I'm not sure I'm using the flag correctly. http://pastebin.com/raw.php?i=G6uMqCSw
13:58:28 <astory> pozic: as long as words in English are
13:58:39 <astory> so, mostly not very long
13:58:48 <pozic> astory: I don't know what the longest word in the English language is.
13:58:57 <astory> pozic: but most words are very short
13:59:12 <pozic> astory: but that's not what I wanted to know :)
13:59:13 <gianzoo> hi everyone, does anyone know if emacs haskell-mode is still available somewhere? the link on haskellwiki points to an empty directory listing...
13:59:15 <hpc> the longest english word is some kind of disease
13:59:16 <astory> in particular, words that weren't created for the express purpose of being a very long word...
13:59:21 <hpc> so it is technically latin
13:59:42 <astory> in this case, though, I really only care about the longest word in my corpus, which probably isn't more than 20 characters
13:59:58 <copumpkin> a trie sounds like a good bet here
14:00:03 <copumpkin> but dunno
14:00:11 <astory> copumpkin: I'm not sure how I would arrange this into a trie
14:00:14 <m3ga> my daughter tells me the longest word is upercalifragilisticexpialidocious
14:00:14 <napping> a count for each tuple of words?
14:00:24 <astory> m3ga: http://en.wikipedia.org/wiki/Titin, check out the chemical name
14:00:47 <napping> I'd just try a Map [String] Int, and see how it goes
14:01:04 <napping> interning strings is an obvious improvement
14:01:18 <napping> a Trie would work like Map String (Map String (Map String Int))
14:01:19 <astory> napping: it can be Map (String, String) Int, since I'll always know the length of the tuple, in this case, 2
14:01:32 <astory> nominolo: oh, I see
14:01:41 <napping> then if you intern the words, it could be IntMap (IntMap Int), or something like that
14:02:07 <astory> napping: how do I enable that
14:02:21 <napping> enable?
14:02:31 <napping> You should have a package Data.IntMap
14:02:36 <astory> oh, there we go
14:02:45 <napping> for the rest of it, just write your code to work on those other types
14:02:49 <napping> if you like
14:03:01 <napping> rather, if you actually need more speed
14:03:16 <niteria> https://gist.github.com/857807 , can anyone tell me what's the bottleneck?
14:03:20 <ezyang> I wonder if there's any use of OverlappingInstances w/o FlexibleInstances 
14:03:40 <niteria> it spends 80% in CAF
14:03:47 <niteria> whatever it means
14:03:55 <preyalone> Does the -main-is flag take SomeModule.main as an argument?
14:04:15 <st3pcut> niteria: did you compile with -auto-all ?
14:05:18 <ddarius> :k Mu (Map Char)
14:05:19 <lambdabot> Not in scope: type constructor or class `Map'
14:05:23 <ddarius> :k Mu (M.Map Char)
14:05:24 <lambdabot> *
14:05:54 <preyalone> Nevermind, I just needed to delete .HI files.
14:06:11 <napping> niteria: maybe the (iterate (*5) 5) is getting hoisted out
14:06:27 <napping> otherwise, I don't see how you would get a CAF
14:07:11 <niteria> st3pcut: yes
14:07:18 <hpc> :k Mu
14:07:19 <lambdabot> (* -> *) -> *
14:08:26 <Jesin> Mu is a type-level fix
14:08:53 <Jesin> @src Mu
14:08:53 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
14:09:31 <pozic> If Google comes to ask for data structure advice in #haskell, they must be really getting desperate. 
14:10:07 <hpc> pozic: at least they know who to ask for help ;)
14:10:26 <pozic> hpc: nah, they just want free help.
14:10:29 <Jesin> :k Mu []
14:10:30 <lambdabot> *
14:10:41 <hpc> Mu [] == [[[[[[[... :D
14:11:02 <ddarius> Jesin: That is Tree ()
14:11:02 <mercury^> Is there any use for Mu?
14:11:12 <hpc> Mu (Either x) gives you a value of type x, plus how deep it is
14:11:17 <ddarius> mercury^: Sure.
14:11:17 <hpc> there is indeed use for Mu
14:11:24 <pozic> mercury^: some people what to make you believe there is. 
14:11:28 <pozic> want*
14:11:42 <pozic> mercury^: there are some papers about it like dataypes a la carte.
14:11:46 <hpc> say your data structure was
14:11:50 <c_wraith> > show . fix $ In . pure :: Mu []
14:11:51 <lambdabot>   Couldn't match expected type `L.Mu []'
14:11:51 <lambdabot>         against inferred type `GHC.B...
14:11:59 <pozic> Whether or not that makes it 'useful' is something entirely different, imho.
14:12:09 <Jesin> well, if you define
14:12:16 <c_wraith> I never can get that right.
14:12:20 <hpc> data MuMagic a = More a Context | End FinalState
14:12:30 <Jesin> data PreList a b = Nil | Cons a b
14:12:33 <hpc> Mu MuMagic can give you lots and lots of Context
14:12:39 <hpc> then when it ends, you have a FinalState
14:12:46 <Jesin> :p
14:13:00 <hpc> and you get all this Context by peeling layers off the onion
14:13:10 * hpc coins the term "onion-typed"
14:13:26 <ddarius> Mu MuMagic ~ (FinalState, [Context])
14:13:31 <hpc> it will be even hipper than duck-typing
14:14:13 <mercury^> Exactly. So is there any actual use or are all the datatypes you get from it isomorphic to something that would be shorter to type out directly?
14:14:30 <hpc> mercury^: it isn't isomorphic to that tuple
14:14:39 <hpc> you don't get FinalState until you have read all the Context
14:14:57 <ddarius> hpc: I don't have to look at Context to traverse Mu MuMagic
14:14:59 <hpc> so it's kind of like (Context, Context, ..., FinalState)
14:15:15 <hpc> ddarius: true, but you have to read the spine
14:15:21 <ddarius> hpc: But yes, there is a bit of difference with bottoms.
14:15:28 <napping> mercury^: to use Mu, you start with the non-recursive version
14:15:42 <ddarius> That could be gotten rid of but then I'd need to start defining non-standard types.
14:15:42 <napping> there's no way to extract a non-recursive version if you start with a closed data type
14:15:48 <ddarius> mercury^: You can always make a data type that corresponds to what you get from using Mu.
14:16:10 <hpc> napping++
14:16:12 <Jesin> just like you can always make a function
14:16:19 <Jesin> that corresponds to what you get from using fix
14:16:21 <mercury^> ddarius: Yes. The important question is whether Mu makes the code mode concise.
14:16:21 <Jesin> :p
14:16:24 <ddarius> mercury^: However, by using Mu you explicitly separate the structure so you can start doing generic programming stuff.  For example, you can make one single "fold" function for everything written as Mu f.
14:16:25 <hpc> fix takes a simple function and makes it recursive
14:16:32 <hpc> Mu takes a simple type and makes it recursive
14:16:49 <ddarius> mercury^: Well it can lead to an infinite reduction in code.
14:17:01 <napping> mercury^: if you don't use Mu, you need to define two versions of the data type
14:17:13 <napping> but, you do avoid some noise constructors
14:17:24 <ddarius> mercury^: However, in practice, people don't use it too often because it's a bit noisy.
14:17:27 <napping> I haven't seen anyone try to make a type family for folding and unfolding
14:17:46 <napping> that might let you avoid syntactic overhead and still write generic functions
14:18:48 <napping> class RecType ty base where roll :: base ty -> ty; unroll : ty -> base ty
14:18:56 <napping> doesn't even need type families, I guess
14:19:10 <hpc> Mu is a very strong type for academic tricks
14:19:18 <copumpkin> http://unarmed.shlomifish.org/909.html
14:19:31 <hpc> where you need to see how some theoretical thing behaves
14:20:03 <mercury^> ddarius: Mu constructs a terminal coalgebra, right? What is the definition of the fold?
14:20:20 <dolio> Initial algebra.
14:20:29 <hpc> holy crap!
14:20:35 <ddarius> mercury^: In Haskell initial algebras and terminal coalgebras coincide.  Mu usually suggests initial algebra.
14:20:42 <hpc> i understand terminal/initial algebra/coalgebra
14:20:43 <hpc> i think
14:21:25 <napping> mercury^: the tricks with Mu show mathematic structure underlying common things, the question is whether it's easy enough to use those definitions directly in Haskell
14:21:35 <ddarius> :t let fold f = In . fmap (fold f) . out in fold
14:21:36 <lambdabot> forall t (f :: * -> *). (Functor f) => t -> Mu f -> Mu f
14:21:42 <ddarius> Not quite right.
14:21:55 <mercury^> Ah, yeah. And inital algebras and terminal coalgebras coincide because Haskell is turing complete?
14:22:20 <ddarius> :t let fold f = f . fmap (fold f) . out in fold
14:22:21 <lambdabot> forall (f :: * -> *) b. (Functor f) => (f b -> b) -> Mu f -> b
14:22:24 <ddarius> There we go.
14:22:34 <napping> mercury^: like first class functions and lexically lightweight lambda functions make it easy to abstract out common bits of definition, even if it maybe wasn't worth the trouble to pull them out in something like C
14:23:03 <napping> I'm not sure it's worth using some of these implementations directly in Haskell, but maybe someday
14:23:27 <hpc> napping: practical applications are for grad assistants to figure out :D
14:23:35 <hpc> we can't get our hands dirty with reality!
14:24:32 <Jesin> hmm
14:24:49 <mercury^> :t in
14:24:50 <lambdabot> parse error on input `in'
14:24:51 <Jesin> is there an example of using that fold?
14:25:07 <ddarius> mercury^: It's related to Turing completeness, but not quite equivalent to it.
14:25:16 <hpc> :t fold
14:25:17 <lambdabot> Not in scope: `fold'
14:25:29 <Jesin> hmm, isn't [] the only member of Mu [], btw?
14:25:38 <ddarius> Jesin: No.
14:25:43 <hpc> Jesin: Mu [] ~ Nat
14:25:45 <Jesin> @let fold f = f . fmap (fold f) . out
14:25:46 <lambdabot>  Defined.
14:25:48 <ddarius> hpc: No.
14:26:04 <ddarius> hpc: Mu [] is Data.Tree.Tree ()
14:26:08 <hpc> no? i thought the only information you could get out was depth
14:26:11 <hpc> oh!
14:26:12 <Jesin> Mu [] = [[[[[[[...]]]]]]]
14:26:20 <hpc> because you can have several inner lists
14:26:27 <hpc> [[],[]] is Mu []
14:26:28 <Jesin> ohh
14:26:30 <Jesin> ok
14:26:34 <hpc> neat
14:27:29 <hpc> Mu Maybe ~ Nat though, yes?
14:27:41 <ddarius> > fold (:) (fix (In . (,) 1))
14:27:42 <lambdabot>   Occurs check: cannot construct the infinite type:
14:27:42 <lambdabot>    b = [f b] -> [f b]
14:27:46 <ddarius> hpc: Yes.
14:27:47 <hpc> :D
14:28:01 <ddarius> > fold (uncurry (:)) (fix (In . (,) 1))
14:28:02 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:28:04 <hpc> this is fun
14:28:07 * ddarius is always caught by the uncurry.
14:28:18 <hpc> :t uncurry
14:28:19 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:28:38 <hpc> i hate curry/uncurry tricks; they boggle the mind
14:28:47 <ddarius> There's no trick.
14:28:55 <hpc> :P
14:29:01 <preyalone> -main-as has trouble with multiple Haskell files. http://pastebin.com/raw.php?i=wyutLxem
14:29:05 <ddarius> @let unfold f = In . fmap (unfold f) . f
14:29:06 <lambdabot>  Defined.
14:29:40 <aristid> :t In . fmap (unfold f) . f
14:29:41 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Show a, SimpleReflect.FromExpr (f a), Functor f, SimpleReflect.FromExpr (f1 (f a)), Functor f1) => f1 (Mu f)
14:29:47 <aristid> :t unfold
14:29:48 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> f a) -> a -> Mu f
14:29:49 <hpc> preyalone: look at that second part, Test.main
14:29:55 <ddarius> > unfold (\n -> (n+1,n+1)) 0
14:29:56 <lambdabot>   In (1,In (2,In (3,In (4,In (5,In (6,In (7,In (8,In (9,In (10,In (11,In (12,...
14:30:01 <hpc> compare to the first one, ScriptedMain
14:30:16 <hpc> s/Test.main/Test/ and you should be fine
14:30:34 <aristid> :k Mu
14:30:35 <lambdabot> (* -> *) -> *
14:30:48 <hpc> hmm
14:30:57 <hpc> can Agda, et al have a Mu type?
14:31:07 <ddarius> > fold (\(n,sums) -> n:map (n+) sums) . unfold (\n -> (n+1,n+1)) 0
14:31:08 <lambdabot>   Couldn't match kind `(* -> *) -> *' against `* -> *'
14:31:10 <hpc> i know they can't implement fix
14:31:22 <ddarius> > fold (\(n,sums) -> n:map (n+) sums) $ unfold (\n -> (n+1,n+1)) 0
14:31:24 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
14:31:38 <aristid> ddarius: type Stream a = Mu ((,) a) ?
14:31:45 <preyalone> hpc: http://pastebin.com/raw.php?i=6BK3iXci
14:31:45 <hpc> aristid: yeppers
14:31:46 <ddarius> hpc: Mu and Nu are built into Agda.
14:31:52 <hpc> ddarius: cool
14:31:53 <ddarius> aristid: Well, Nu is normally used, but yes.
14:31:58 <aristid> :k Nu
14:31:59 <lambdabot> Not in scope: type constructor or class `Nu'
14:32:12 <aristid> sadly lambdabot does not seem to have Nu
14:32:18 <mercury^> What is Nu?
14:32:18 <ddarius> Mu = Nu in Haskell.
14:32:22 <aristid> oh.
14:32:23 <hpc> the knights who say Nu!
14:32:27 <aristid> hpc: haha
14:32:33 <mercury^> And what is the difference in Agda?
14:32:34 <hpc> (had to be said)
14:33:08 <ddarius> In Agda, the equivalent of Mu ((,) a) would be empty, while the equivalent of Nu ((,) a) would be the type of infinite streams of a.
14:33:30 <mercury^> Mu is somehow `strict' there?
14:34:02 <preyalone> hpc: The line "import ScriptedMain hiding (main)" should hide main, but -main-is Test still sees it.
14:34:07 <ddarius> Strictness doesn't have meaning in Agda, but there is some kind of thing like that that's part of what is going on.
14:35:02 <hpaste> nat pasted "fusion"  http://hpaste.org/44572
14:35:16 <dibblego> mmm fusion
14:35:56 <preyalone> hpc: https://gist.github.com/857856
14:36:10 <aristid> that's the lamest "fusion" ever oO
14:36:13 <aristid> "ro"
14:36:20 <Jesin> :k Mu ((,) Integer)
14:36:21 <lambdabot> *
14:36:25 <mercury^> Btw, if you have input into Agda development: could you suggest that unicode character classes are honored, so that one can write `3+4' without spaces?
14:36:38 <astory> how does show tell the difference between "hi" and ["h","i"]?  I thought they were equivalent.
14:36:49 <Jesin> hmm
14:36:55 <mauke> astory: they aren't
14:37:00 <aristid> astory: no, ['h','i'] would be equivalent to "hi"
14:37:01 <hpc> :t ['h','i']
14:37:02 <lambdabot> [Char]
14:37:03 <Jesin> in Haskell, does Mu ((,) Integer) have any valid members?
14:37:07 <hpc> :t ["h","i"]
14:37:08 <lambdabot> [[Char]]
14:37:09 <aristid> Jesin: yes.
14:37:29 <astory> ah, I see, thanks
14:37:32 <aristid> > unfold (\x -> (1,x))
14:37:32 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> L.Mu ((,) t))
14:37:32 <lambdabot>    arising from...
14:37:36 <hpc> astory: there's some typeclass bullshit that makes String show itself differently
14:37:38 <aristid> :t unfold (\x -> (1,x))
14:37:39 <lambdabot> forall a t. (Num t) => a -> Mu ((,) t)
14:37:40 <sipa> astory: String = [Char], "hi" :: String, ["h","i"] :: [String]
14:37:40 <hpc> someone else can explain better
14:37:53 <aristid> > unfold (\x -> (1,x)) ()
14:37:55 <lambdabot>   In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In ...
14:37:56 <Jesin> :t unfold
14:37:57 <lambdabot> forall a (f :: * -> *). (Functor f) => (a -> f a) -> a -> Mu f
14:38:06 * hackagebot tdoc 0.2.1 - TDoc is a typed document builder with support for (X)HTML  http://hackage.haskell.org/package/tdoc-0.2.1 (NicolasPouillard)
14:38:18 <aristid> > unfold (\x -> (1,x)) () :: Mu ((,) Integer)
14:38:20 <lambdabot>   In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In (1,In ...
14:38:30 <aristid> Jesin: see :)
14:42:01 <preyalone> Turns out I need to delete scriptedmain.o for test.hs to compile.
14:51:35 <Jesin> k
15:05:18 <niteria> how to convert Int to Integer?
15:05:32 <luite> fromIntegral
15:06:08 <niteria> ok, thanks
15:06:43 <niteria> toInteger works too
15:06:57 <mauke> @src fromIntegral
15:06:57 <lambdabot> fromIntegral = fromInteger . toInteger
15:17:21 <aristid> :t toInteger
15:17:22 <lambdabot> forall a. (Integral a) => a -> Integer
15:17:27 <aristid> :t toInteger :: Int -> Integer
15:17:28 <lambdabot> Int -> Integer
15:18:24 <mm_freak_> i wonder what's faster…  parsing by attoparsec or using an iteratee and the usual ByteString functions
15:18:28 <mm_freak_> i guess the former is faster
15:19:47 <cads> is there a way to make a type which is the type inhabited by legal chess positions?
15:20:02 <hpaste> byram pasted "lightworks errors"  http://hpaste.org/44574
15:22:05 <Jesin> cads: you mean *only* by legal chess positions?
15:22:38 <kmc> mm_freak_, did you see attoparsec-iteratee and attoparsec-enumerator?
15:22:46 <kmc> btw i'm very happy to see that there's now a Text version of attoparsec
15:22:52 <luite> you can have a constructor for each position :p
15:24:34 <mm_freak_> kmc: yes, but that doesn't really answer my question
15:25:13 <mm_freak_> kmc: i've used that combination in ismtp 1.x, but in ismtp 2.x i got rid of the attoparsec dependency
15:27:22 <mm_freak_> right now i'm waiting for john millikin to improve the design of enumerator, so that it's easy to support putting back values into the stream…  with that it will be much more funny to write iterateees
15:27:24 <mm_freak_> -e
15:27:54 <mm_freak_> in fact the support is there, but it breaks the monad laws
15:28:10 <mzero> cads - probably not
15:28:16 <mm_freak_> that's why i don't do it
15:34:10 <wagle> Cale: where do your fold diagrams live these days?
15:34:53 <Cale> wagle: On my semi-dead HDD which I still need to pull out of my old machine and see if I can extract anything from it.
15:35:07 <Cale> actually...
15:35:20 <Cale> oh, I do have a backup of them
15:35:29 <wagle> found it on wikipedia uploads
15:35:37 <Cale> yeah, some of them are on wikipedia
15:36:02 <wagle> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
15:36:31 <wagle> but i couldnt find an article listing them all
15:37:29 <wagle> i once spend 3 days pulling stuff off a disk that could successfully do about 1 seek every 3 seconds
15:37:50 <mzero> Toolbox:What Links Here comes up with no pages
15:38:04 <dark> wagle, this is very informative o.o
15:38:41 <mzero> http://en.wikipedia.org/wiki/Fold_(higher-order_function)
15:38:44 <mzero> but this one does
15:39:06 <fushunpoon> What's the history behind calling the Prelude "Prelude"?
15:39:22 <dark> it seems that wx is a fine library to do gui programming, haskell style. right?
15:39:34 <dark> it was ported by the parsec author
15:46:04 <gwern> > 1000000 / 1500
15:46:04 <lambdabot>   666.6666666666666
15:47:58 <dark> fushunpoon, I don't know, but in ocaml it is called 'Pervasives'
15:54:30 <fushunpoon> dark: I was just over at OCaml's channel saying that actually :P sounds funky either way
16:22:06 <lew> what underlying sort algorithm does haskell use? jw.
16:22:42 <copumpkin> I think the standard library one that comes with GHC is a mergesort
16:22:44 <c_wraith> Data.List's sort, in GHC, is a merge sort
16:22:53 <lew> ok. thanks. :)
16:22:55 <c_wraith> bottom up, stable
16:23:04 <copumpkin> lew: it's a clever one though
16:23:15 <c_wraith> Really the best you can manage with immutable linked lists as the structure you're sorting
16:25:24 <c_wraith> Also, the way it's implemented allows it to be somewhat lazy.  Which is nice.
16:25:56 <c_wraith> obviously, it has to examine every value to generate the first element, but it doesn't need to perform the full sort.
16:27:20 <c_wraith> hmm.  that's only slightly true.  I guess it has to do everything but the final merge before it's sure it's generated the first element.
16:27:38 <c_wraith> So it's going to have done O(n * log n) work before you can get the first result element
16:39:09 <ian_mi> c_wraith: wouldn't it only have to merge the first element in every merge?
16:44:13 * hackagebot silently 0.0.1 - Prevent writing to stdout in Haskel.  http://hackage.haskell.org/package/silently-0.0.1 (TrystanSpangler)
16:44:59 <Zao> Haskel, heh.
16:49:08 <sshc> I'm trying to write a function that takes a function, and fills in all the first 'Maybe' parameters with 'Nothing' (until something else is reached)
16:49:29 <kmc> what type would your function have?
16:50:24 <sshc> For example, (fillNothing (foo :: Maybe Bool -> Maybe Integer -> Integer -> String -> String)) is :: Integer -> String -> String, and is equivalent to "foo NOthing Nothing"
16:50:39 <kmc> no, i meant "what's the type of fillNothing"
16:50:45 <kmc> also, why are you trying to write this?
16:51:09 <Axman6> i think that could be possible using a type class
16:51:20 <sjanssen> a really ugly type class
16:51:22 <sshc> Axman6: How so?
16:51:27 <kmc> yes, it's not impossible, just unreasonable
16:51:34 <kmc> what problem are you actually trying to solve?
16:51:38 <sshc> How could it be done?
16:51:44 <kmc> i'm guessing some kind of "default arguments" system?
16:51:46 <sshc> Did I not explain what I was trying to solve?
16:51:54 <kmc> You didn't explain why.
16:52:06 <sshc> It houldn't be necessary for a solution
16:52:20 <rwbarton> What is fillNothing (foo :: Maybe Bool -> Maybe Integer -> a -> Bool)
16:52:45 <sshc> rwbarton: It would be equivalent to "foo Nothing Nothing", which :: a -> Bool
16:52:45 <kmc> sshc, i'm sure you've seen it before, people come here a lot asking the wrong question
16:52:49 <Axman6> I'm guessing a -> Bool
16:52:54 <dpratt71> I've been thinking (very vaguely) about implementing a specific message-based protocol in Haskell...
16:52:55 <rwbarton> sshc: but, a could be Maybe Double
16:52:58 <sshc> Even if I don't want to implement it, there's the possibility that I'd still like to know how
16:53:11 <kmc> sshc, the fact that you can't (and nobody can) write the type for fillNothing indicates that it's the answer to the wrong question
16:53:18 <sshc> rwbarton: It could, but it's general enough not to deal with it
16:53:51 <sshc> kmc: Are you saying there is no way to implement it?
16:53:57 <kmc> i didn't say that
16:54:06 <dpratt71> assuming I have a specific type for messages (Message, say) what might the API look like?
16:54:07 <kmc> i'm sure others will be happy to share some wretched hacks to achieve this function
16:54:33 <sshc> I imagine that it'd be similar to how other variadic functions are cleverly implemented
16:54:37 <sshc> like printf
16:54:47 <kmc> yeah
16:55:03 <sjanssen> sshc: yes, it would work similarly to that.  This problem has been solved before, you can probably find it with Google
16:55:03 <rwbarton> This one is worse because it needs overlapping instances
16:55:05 <kmc> but worse, because you have cases for (Maybe t) and "not (Maybe t)"
16:55:12 <kmc> which means overlapping
16:55:19 <Axman6> just need something like class FillNothing a where fill :: (Maybe b -> a) -> a; instance FillNothing a => FillNothing (Maybe b -> a) where fill f = fill (f Nothing)... but that probably won't work (and needs another instance)
16:55:51 <kmc> sshc, the problem is, you didn't frame your question as being either a practical matter or a puzzle you're curious to solve
16:56:29 <kmc> i would run screaming from any API that implemented "fillNothing", even if it's technically possible to do so
16:56:40 <kmc> but it's a fine type class puzzle
16:59:38 <sjanssen> http://www.mail-archive.com/haskell-cafe@haskell.org/msg46878.html could be adapted to solve your problem
16:59:53 <sjanssen> or http://okmij.org/ftp/Haskell/isFunction.lhs
17:00:00 <copumpkin> omfg sjanssen is back
17:00:02 <sjanssen> sshc: ^^^
17:00:03 * copumpkin cheers
17:00:04 <sjanssen> yep
17:00:13 <sjanssen> nice to see you as well, copumpkin 
17:00:47 <copumpkin> :)
17:19:35 <Philippa> hmm. We still have no good tools for modular monadic programming where the modules are generated from within the monads
17:27:01 <Saizan> you mean where you initialize something inside a monad to create a module?
17:27:20 <Philippa> that sort of thing, yeah
17:27:32 <Philippa> "initialise" isn't always the right word though
17:28:01 <Saizan> true, just the first that came to mind :)
17:28:05 <Philippa> (for example, my parsing library uses a monad to tag where it has recursion which isn't really "initialisation" - but breaking RT is /really important/ there)
17:28:10 <saml> hey how would you repsrenset AST?
17:28:15 <saml> data AST =  ?
17:28:18 <Philippa> yeah
17:28:30 <Philippa> if there're multiple sorts, use multiple datatypes
17:28:36 <saml> data AST = Bool Bool | Int Int  
17:28:41 <saml> sorts?
17:28:51 <Philippa> if you've got Terms and Types for example
17:28:59 <xenocryst> I'm having trouble understanding why this won't work (I understand this function is inefficient, but that's not the point :-))
17:29:02 <Saizan> or expressions and declarations
17:29:03 <xenocryst> isPrime n = all (\ x -> n `mod` x /= 0) [1..(floor $ sqrt n)]
17:29:05 <Philippa> or Statements and Expressions and DeclarationBlocks
17:29:06 <saml> what would be the difference? Terms have value?
17:29:15 <Philippa> depends on the language you're building an AST for
17:29:15 <saml> ah i see. thanks Philippa 
17:29:18 <xenocryst> it gives me an error at the sqrt n part
17:29:19 <kmc> data Expression = Constant Int | Sum Expression Expression
17:29:37 <kmc> :t let isPrime n = all (\ x -> n `mod` x /= 0) [1..(floor $ sqrt n)] in isPrime
17:29:38 <lambdabot> forall b. (RealFrac b, Floating b, Integral b) => b -> Bool
17:29:43 <saml> is there a language implemented in haskell? other than  haskell.  ghc code base is intimidating to read
17:29:54 <Philippa> Saizan: anyway, we've got no good mechanism to do the namespace management there :-(
17:29:59 <kmc> saml, lots of them.  it's one of the strong areas of Haskell
17:29:59 <kmc> look on hackage
17:30:09 <kmc> saml, in fact there's a tutorial about implementing Scheme in Haskell
17:30:12 <Saizan> Philippa: i've only seen some TH that emulates module level abstractions in that area, i.e. removes some need for a ReaderT or similar
17:30:21 <saml> kmc, i mean compiler. 
17:30:24 <Philippa> Saizan: yeah. At this point, cba
17:30:39 <Philippa> (but I'm going to have to go back to TH later)
17:31:25 <byorgey> xenocryst: that's because sqrt can only be called on floating point numeric types
17:31:47 <byorgey> xenocryst: but mod can only be used on integral types
17:32:11 <byorgey> xenocryst: you probably want  (floor . sqrt . fromIntegral $ n)
17:32:24 <xenocryst> byorgey: I have it declared like: Integer -> Bool. Can I convert Integer to Float for sqrt?
17:32:30 <xenocryst> ah!
17:32:33 <byorgey> xenocryst: yes, with fromIntegral
17:32:34 <xenocryst> byorgey: thanks!
17:32:37 <byorgey> sure
17:32:48 <cads> Jesin: oh yeah, I meant only legal positions - I can think of lots of way for representing arbitrary piece arrangements :)
17:36:33 <cads> though I think it would be silly, not to mention very hard, to limit it to representing only positions that can be reached strictly by legal play 
17:36:57 <mjrosenb> cads: Jesin what game is this?
17:37:22 <cads> mjrosenb: I was asking about chess
17:37:53 <mjrosenb> ahh.
17:38:27 <mjrosenb> well you could represent the board as starting position + arbitrary set of moves
17:38:48 <mjrosenb> while this would not limit you to valid positions, it would eliminate many invalid positions
17:42:14 <cads> nice
17:43:34 <mjrosenb> it is also kind of hard to use :(
17:44:30 <cads> you could decorate the data structure with a position and possible move set for each move :)
17:44:48 <cads> or even turn it into a variation tree :)
18:09:04 <parcs> does the nesting of monad transformers matter provided that they are all unique?
18:09:29 <shachaf> parcs: You mean the order?
18:09:39 <parcs> yeah
18:09:41 <shachaf> parcs: Yes.
18:09:48 <parcs> how so?
18:10:00 <mjrosenb> they don't need to be unique
18:10:16 <mjrosenb> you can have StateT a (State a) b
18:10:34 <shachaf> Yes, but even if they are unique it matters.
18:11:47 <bss03> RWH has a small section talking about the difference between the order you nest things.
18:12:32 <bss03> Like how ErrorT e (State s) a != StateT s (Error e) a... I think that was the example.
18:13:49 <kmc> @unmtl ErrorT e (State s) a
18:13:49 <lambdabot> s -> (Either e a, s)
18:13:55 <kmc> @unmtl StateT s (Error e) a
18:13:55 <lambdabot> s -> Error e (a, s)
18:14:09 <kmc> err, Error = Either here i guess
18:14:29 <shachaf> @unmtl MaybeT [] a
18:14:29 <lambdabot> [Maybe a]
18:14:30 <shachaf> @unmtl ListT Maybe a
18:14:31 <lambdabot> Maybe [a]
18:15:12 <parcs> hmm
18:17:11 <parcs> what about the Reader, Writer and State monad transformers?
18:17:39 <Philippa> you can reorder those amongst each other without it affecting anything
18:18:21 <shachaf> @unmtl StateT s (Writer w) a
18:18:21 <lambdabot> s -> (a, s, w)
18:18:21 <parcs> is there a name for the kinds of monads whose order in a monad stack matters?
18:18:35 <kmc> non-commutative?
18:18:43 <shachaf> That can't be right.
18:19:37 <Philippa> parcs: the only kind I'm familiar with that you can commute safely between is the R/W/S/etc sort (and IdT if anyone's written it) - "state-like" is a good enough descriptor
18:19:40 <Saizan> "commutative" is for those monads where liftM2 (,) and flip (liftM2 (flip (,)) are the same, roughly
18:20:02 <Philippa> if it's got a control effect, it won't commute with other monad transformers
18:20:16 <parcs> monads with more than one constructor?
18:20:31 <Philippa> no, that's irrelevant
18:21:06 <Philippa> I could have a MultiStateT that had two state fields and was equivalent to two stacked StateTs, that'd commute fine with itself and other state-like transformers
18:21:32 <Philippa> (and the data constructors are /really/ irrelevant: you don't even know they exist)
18:21:36 <napping> R/W/S are all basically state anyway, just the R and W only provide one result
18:21:57 <ddarius> napping: I wouldn't say that.
18:22:19 <napping> just provide restricted access, rather
18:23:00 <Philippa> R can make some really fundamental differences: when my parsing lib gets round to doing edwardk-style incremental parsing, the difference between reader and state is the difference between only needing to do a local reparse for context-dependence and having to reparse the rest of the sentence
18:23:31 <Philippa> (you /can't tell/ if someone rebuilt reader on top of state, from the lib's POV...)
18:48:13 <bss03> Commutitively Composable?
18:48:39 <bss03> I've never heard a specific term, but that once seems to fit.
18:48:43 * bss03 patents it.
18:49:08 <Philippa> no interesting transformer commutes with all other transformers, anyway
18:49:19 <Philippa> (IdT would)
18:49:28 <Philippa> (modulo lifts, anyway)
18:51:01 <kmc> interesting
18:51:04 <kmc> how would one prove that fact
18:51:09 <Philippa> ?
18:51:24 <Philippa> ContT :-)
18:52:08 <Philippa> about the only thing that can commute with it's IdT
18:52:30 <Philippa> (ContT can undo anything, 'nuff said?)
18:58:51 <kmc> yeah
19:00:43 <napping> Is libraries@haskell.org the right place to discuss ByteString?
19:02:18 <peter11> guys, can someone tell me how ++ works in haskell? thanks
19:02:26 <napping> that's list append
19:02:30 <parcs> @src (++)
19:02:30 <lambdabot> []     ++ ys = ys
19:02:30 <napping> @src (++)
19:02:30 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
19:02:30 <lambdabot> -- OR
19:02:36 <lambdabot> xs ++ ys = foldr (:) ys xs
19:02:42 <peter11> it appends to the end of the list?
19:02:48 <Philippa> yeah. Another list to it
19:02:57 <mjrosenb> > [1,2] ++ [3,4]
19:02:57 <parcs> to prepends to the beginning of the second list
19:02:58 <lambdabot>   [1,2,3,4]
19:02:59 <peter11> okay, so at the end and not in the beginning
19:03:00 <parcs> it*
19:03:08 <napping> The first list is copied
19:04:10 <Jesin> > flip (foldr (:)) [1,2] [3,4]
19:04:11 <lambdabot>   [1,2,3,4]
19:04:45 <peter11> excellent, thanks
19:07:06 <hpaste> max pasted "tesseract rb"  http://hpaste.org/44575
19:20:59 <peter11> checking if 2 binary trees are equal, relies on what?
19:21:09 <peter11> the depth and the height?
19:21:33 <Zao> peter11: Equal spine and equal leaves?
19:21:42 <peter11> leaves
19:22:17 <peter11> so i have to check only the leaves?
19:22:31 <kmc> peter11, why are you asking us?  you're the one who gets to define what "equality" means
19:22:52 <peter11> i agree kmc , but i want to see whats the best practice out there
19:22:58 <Zao> peter11: In order to compare leaves, you kind of need to ensure that the spine structure is the same.
19:23:04 <kmc> in Haskell? use "deriving Eq" and don't worry about it
19:23:22 <Zao> peter11: Define what you mean by equality, and implement it (or derive Eq if it'll do the Right Thing)
19:23:30 <kmc> there's no "best practice", that's like asking "is it best practice to compare characters with or without case sensitivity"
19:23:33 <kmc> it depends on the application
19:23:46 <Zao> deriving Eq will do an elementwise test, so it'll satisfy "equal spine structure and equal leaf values"
19:24:15 <Ptival> same as kmc, it completely depends on what you expect of your equality test in the first place...
19:24:22 <Zao> Other comparisons could be things like "in a depth-first traversal, is the sequence of leaf values identical?"
19:24:45 <Zao> It all depends on what _you_ mean by equality wrt. binary trees.
19:24:46 <peter11> okay
19:25:24 <peter11> alright, i was just checking for a deep check
19:26:01 <peter11> i need deep checking
19:26:15 <kmc> can you describe what that means?
19:26:31 <kmc> if you describe it in detail, then you have your algorithm
19:27:26 <peter11> i want to first check the height
19:27:39 <peter11> if equal then go inside and check every leaf
19:27:59 <peter11> if all leafs are equal then that's it, both binary trees are equal
19:28:13 <kmc> should these two trees be equal?
19:28:19 <kmc> Branch 'x' (Branch 'y' 'z')
19:28:28 <kmc> Branch (Branch 'x' 'y') 'z'
19:28:33 <kmc> with appropriate leaf constructors, i suppose
19:28:39 <kmc> same height (2)
19:28:43 <kmc> same sequence of leaves
19:28:45 <kmc> different shape
19:29:47 <peter11> check in-order traversal?
19:29:50 <kmc> if you have a type like this:
19:30:08 <kmc> yeah, they both have the same in order traversal
19:30:10 <kmc> so should they be equal or not?
19:30:14 <kmc> this is up to you.
19:30:39 <peter11> alright i see your point
19:30:59 <kmc> say you have this type:
19:31:06 <kmc> data Tree a = Leaf a | Branch (Tree a) (Tree a)
19:31:12 <kmc> deriving (Eq)
19:31:20 <kmc> then your instance works like this:
19:31:28 <kmc> instance (Eq a) => Eq (Tree a) where
19:31:37 <kmc>   (Leaf x) == (Leaf y) = (x == y)
19:31:53 <kmc>   (Branch x1 x2) == (Branch y1 y2) = (x1 == y1) && (x2 == y2)
19:32:19 <peter11> yeah
19:32:47 <peter11> and _ == _ = False
19:32:54 <kmc> right
19:32:59 <kmc> a Leaf is never equal to a Branch
19:33:09 <peter11> yeah
19:33:16 <peter11> very good, thanks for your help kmc 
19:33:21 <kmc> the derived instances are all "structural" in this way
19:33:46 <kmc> no problem :)
19:38:14 <peter11> @src (replicate)
19:38:14 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:38:40 <kmc> @src replicate
19:38:40 <lambdabot> replicate n x = take n (repeat x)
19:38:41 <peter11> @src replicate
19:38:42 <lambdabot> replicate n x = take n (repeat x)
19:38:52 <peter11> thx
19:39:14 <peter11> @src repeat
19:39:14 <lambdabot> repeat x = xs where xs = x : xs
19:41:57 <dark> > repeat 1
19:41:58 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:42:24 <dark> > replicate 5 1
19:42:25 <lambdabot>   [1,1,1,1,1]
19:43:01 <dark> @src take
19:43:02 <lambdabot> take n _      | n <= 0 =  []
19:43:02 <lambdabot> take _ []              =  []
19:43:02 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
19:43:25 <kmc> take (n+1) (x:xs) = x : take n xs -- ;)
19:43:48 <ksf> get him! he used n+k!
19:44:02 <kmc> take (S n) (Cons x xs) = x : take n xs
19:44:27 <ksf> that's another thing.
19:44:43 <dark> n+k is really nice
19:45:03 <ksf> it's been abolished.
19:45:09 <dark> really?
19:45:16 <ksf> in haskell2010, yes.
19:45:34 <dark> and current ghc accepts haskell2010 only?
19:45:38 <kmc> no
19:45:47 <rschnck> I know this is very much #not-haskell, but I was wondering if someone could help me with a quick algorithm correctness proof.
19:45:48 <kmc> GHC will accept Haskell 98 forever
19:46:03 <kmc> but maybe not as the default
19:46:18 <kmc> you can enable NPlusKPatterns, like any other 'extension'
19:46:50 <rschnck> Or if someone knows a channel for that sort of thing, even better.
19:47:05 <dark> oh.. haskell 2010 has added just.. FFI, pattern guards, and hierarchical module names? õ.o
19:47:20 <dark> what about those dozen of extensions every cool library uses
19:47:28 <kmc> http://www.haskell.org/pipermail/haskell/2009-November/021750.html
19:47:32 <kmc> the full list
19:47:40 <kmc> dark, they're moving slow
19:47:53 <kmc> the plan was to release a new spec every year, but now they're skipping 2011
19:47:56 <rschnck>  /join #algorithms
19:48:00 <rschnck> Shit, sorry :(
19:48:30 <dark> i think lots of real haskell code rely on type classes with 2 parameters
19:48:33 <kmc> some of those cool extensions are controversial for various reasons
19:48:48 <kmc> dark, lots of real haskell code over-uses type classes, imo
19:49:25 <kmc> right now it's not clear if a future version of Haskell should have multi-param type classes with fundeps, or single-param type classes with associated type synonyms, or what
19:49:36 <kmc> GHC supports both and it's a topic of active discussion which is better
19:49:46 <kmc> (GHC doesn't support all the details necessary to make them equivalent, though)
19:50:44 <kmc> of GHC's extensions to 2010 the only one I consider truly essential is Rank2Types
19:51:11 * copumpkin would add GADTs to that :D
19:51:40 <kmc> you can get rid of gadts with the finally tagless trick
19:51:41 <kmc> sort of
19:51:49 <copumpkin> you can't match on those
19:51:52 <kmc> GADTs are a lot newer
19:51:56 <copumpkin> that's what I care about
19:52:04 <kmc> "no GADTs" sucks as a restriction, but "no ST" sucks a lot more
19:52:05 <ezyang> pattern matching refining types is, IMO, the killer feature of GADTs 
19:52:27 <codolio> Also the definition of GADTs. :)
19:52:43 <kmc> and i'd wager a lot more "real world" haskell code uses rank-2 types than uses GADTs
19:52:57 <copumpkin> pfff
19:54:25 <codolio> If GADTs became standard Haskell, Oleg would lose like 30% of his hacking opportunities.
19:54:40 <kmc> think of the olegs
20:02:04 <mzero> anyone here using a MacBook Air for development?
20:02:30 <roconnor> finally tagless says that you can simulate GADTs with type classes
20:02:54 <Philippa> yeah. Usability says you don't want to have to though
20:03:25 <codolio> Exactly. All the finally tagless stuff is, "lets do GADT things without having GADTs."
20:04:16 <codolio> Also his, "how many non-GADT extensions do we need to encode the equality type."
20:04:36 <codolio> (Usefully)
20:04:45 <Philippa> yeah. Which is great if you're stuck working with a shitty language, but really? Gimme GADTs already
20:04:57 <codolio> Yeah.
20:05:16 <Philippa> (though for efficiency reasons you all too often end up wanting to transform the damn things out because the compiler's not smart enough to do it for you)
20:05:18 <codolio> That's true of a lot of his stuff.
20:05:28 <Philippa> (and when you can place the module boundary appropriately, it ought to be able to)
20:05:33 <copumpkin> mzero: yeah,
20:05:43 <codolio> It's amazing what he hacks into a poor language.
20:05:48 <codolio> But I'd rather have a good language.
20:05:53 <augur> byorgey, you up?
20:06:06 <mzero> one of the new 13" ? I'm due for a new mac and waffling between Air 13" or new MBP 15"
20:06:11 <mzero> how is GHC on it?
20:06:25 <kmc> i'm holding out for the iPad 5 with the extra camera that goes directly up your ass
20:07:01 <mzero> TMI, kmc, TMI
20:07:03 <kmc> fuck apple; don't buy their products
20:08:10 <copumpkin> mzero: it's great, and I use it for everything
20:08:31 <kmc> their goal is to trap 99% of the world in their authoritarian walled garden of software and to have the other 1% (that's you), the blessed elite, pay them dearly for the privilege of maybe doing some software development, if it's okay with apple
20:09:01 <kmc> i learned to program on junked laptops my family members gave me, all of which had BASIC built in
20:09:28 <mzero> diatribes aside, they make damn find HW in my opinion - My current MBP is 5 years old and I have little real reason to replace other than HW lust
20:09:30 <Philippa> built in, or just part of DOS?
20:09:31 <augustss> BASIC!
20:09:39 <kmc> whereas a hand-me-down these days is a shiny black box toy like last year's iPad
20:09:51 <kmc> with zero chance you'll learn to program as an idle adventure one afternoon
20:10:02 <copumpkin> augustss: yo dawg, I heard u liked haskell and basic, so I put a basic in ur haskell so u can code while u code?
20:10:11 <mzero> kmc - I learned to program on computer I soldered together myself and it had.... 5k of RAM (not a typo)
20:10:16 <mzero> but hey
20:10:21 <kmc> yeah, 5k is a lot
20:10:32 <copumpkin> back in my day, we were lucky if we got 3 bits
20:10:39 <mzero> especially when you have to fill it via a hexadecimal keypad!
20:10:40 <copumpkin> I wrote a CAS on 3 bits
20:10:51 <copumpkin> fucking lazy programmers nowadays
20:10:53 <cafesofie> 3 bits? the luxury
20:10:57 <copumpkin> needing multiple bytes of memory
20:11:00 <kmc> sure 'diatribes aside', let's ignore the consequences of our actions and buy whatever shiny toy is being fed to us
20:11:08 <cafesofie> i had to keep the program state in my own memory
20:11:13 <roconnor> mzero: pfft.  I learned to program on a computer that only had 1k of RAM
20:11:17 <cafesofie> i wrote three lisp compilers that way
20:11:42 <augustss> mzero: I think I had 8k in the first computer I built
20:11:54 <copumpkin> kmc: they don't charge you to develop for their computers
20:12:04 <mzero> no, I get the implication, kmc -- but frankly NO company is coming out clean as a whistle on that front
20:12:23 <kmc> mzero, the lesser of two evils?
20:12:29 <augustss> mzero: a hex keypad is a luxury.  I had switches to fill memory (i'm not kidding)
20:12:29 <kmc> come on people
20:12:39 <mzero> which is lesser? Dell? Acer? none of them
20:12:53 <kmc> explain how dell or acer or lenovo is trying to subvert the very idea of personal computing the way apple is
20:13:03 <kmc> copumpkin, sure, but in their ideal world only a few people even own computers
20:13:06 <Philippa> they're all building android tablets?
20:13:22 <kmc> yeah, android isn't perfect
20:13:27 * copumpkin shrugs
20:13:30 <kmc> still a good deal better than iOS
20:13:35 <copumpkin> I don't think they're trying to get rid of the personal computer
20:13:48 <Philippa> not outright, but as the main thing? Yeah
20:13:50 <mzero> seems the MacBook Air I'm thinking of buying is still one
20:13:58 <kmc> they're certainly decreasing the percentage of hand-me-down devices which are programmable
20:14:01 <kmc> which is what i care about
20:14:07 <copumpkin> mzero: anyway, it's a good machine, and everything else feels like a brick now that I have it
20:14:13 <Philippa> *shrug* - all you need is a text editor hooked up to a web server
20:14:13 <copumpkin> mzero: I got the 4GB of RAM
20:14:22 <sm> roconnor: not a zx-80 ?
20:14:23 <copumpkin> Philippa: and 16GB of RAM to appease the agda gods
20:14:24 <mzero> that's the model I'd get - maxed out 
20:14:27 <kmc> Philippa, and if you're a 12-year-old kid and you barely know what a web server is, how will you set that up?
20:14:34 <Philippa> they're /all/ programmable via the web browser, it's a question of how you get javascript into it
20:14:56 <kmc> i'm not interested in a fucking existence proof of loading code onto an iOS device; i care about it being something you might stumble into while poking around
20:14:58 <Philippa> kmc: dunno, who's doing free static web hosting these days?
20:14:59 * hackagebot wai 0.3.2 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.3.2 (MichaelSnoyman)
20:15:02 <roconnor> sm: My older brother learned on a zx80.  I learned on a zx81
20:15:04 <kmc> we're all already programmers; that's not what i'm talking about
20:15:15 <kmc> i realize 99% of people have no desire to program their computer anyway
20:15:17 <sm> ha! cool :) I had a zx-80 
20:15:18 <Philippa> people /do/ stumble into javascript via HTML
20:15:37 <roconnor> sm: awesome
20:15:44 <sm> but learned mostly on commodores, starting with the pet
20:15:46 <roconnor> the zx81 turned 30 ... was it yesterday
20:15:47 <kmc> needing a damn web host setup is a huge barrier to entry
20:16:05 <roconnor> sm: or the day before depending on your timezone
20:16:41 <shachaf> kmc: Surely someone has written LOGO for the iPad?
20:16:55 <kmc> shachaf, Apple explicitly forbids it
20:17:00 <Philippa> kmc: plenty of hits for "free web hosting"
20:17:03 <kmc> and they have removed educational software from the store before
20:17:14 <shachaf> Really? Still?
20:17:16 <kmc> they remove Scratch
20:17:19 <kmc> removed*
20:17:24 <copumpkin> kmc: forbids?
20:17:31 <roconnor> sm: after the zx81 come the apple II.  With it's lame having to type out keywords by hand.
20:17:38 <kmc> yep, you are not allowed to write programs that allow loading code or allow the user to program
20:17:40 <Philippa> plenty of them offer PHP too
20:17:48 <kmc> of course, the real ToS is that Apple can reject your app for any or no reason
20:17:58 <kmc> if they think it's a threat to their business, or they just don't like you
20:18:27 * mzero installs Haskell Platform 2011.2 for the 8th or 9th time this weekend.....
20:19:00 <kmc> now you can probably find some online Logo interpreter
20:19:03 <roconnor> mzero: you don't need the HP.  It's might even be better to not install it. :)
20:19:08 <kmc> again, i'm not saying it's impossible to learn to program on an iPad
20:19:12 <kmc> just that there's a barrier to entry
20:19:20 <kmc> and we're talking about a bored kid who is going to give up and play video games instead
20:19:24 <kmc> not some determined master hacker
20:19:25 <mzero> roconnor: I'm the packager of the Mac installer for HP... I'm testing my warz
20:19:40 <copumpkin> kmc: can you cite the passage that forbids loading code?
20:19:46 <copumpkin> there's a passage about loading code from the internet
20:19:50 <copumpkin> which I can understand
20:20:06 <kmc> what is a web browser if not something that loads code from the internet
20:20:07 <roconnor> mzero: I don't suppose I can convince you to abandon your post. :)
20:20:18 <kmc> http://computinged.wordpress.com/2010/04/15/apple-removes-scratch-from-ipadiphoneitouch/
20:20:24 <copumpkin> kmc: yeah, but we were talking about development environments
20:20:25 <mzero> You've got some sort of vendetta against HP?
20:20:29 <roconnor> yes
20:20:47 <dmwit> ?ask ManateeLazyCat Is there a preferred WordPress version you want me to try to install? If you say nothing, I will just assume you want the most recent stable version.
20:20:47 <lambdabot> Consider it noted.
20:20:56 <dark> <kmc> yep, you are not allowed to write programs that allow loading code or allow the user to program -- if this is for security, they could do as bitfrost's OLPC does
20:21:12 <mzero> 'cause newcomers to Haskell should have to suffer the endurance test of getting a Haskell environment set up?
20:21:13 <dark> so I must conclude it is not about security
20:21:16 <kmc> they could give you the damn developer key to your own hardware
20:21:17 <kmc> like OLPC does
20:21:41 <augur> anyone rock at combinatorial species? if so: are there ways for enumeration to depend on the properties of the enumerated?
20:22:03 <kmc> it looks like there's at least one Scheme app for iPad though
20:22:03 <roconnor> mzero: no.  We should make it as easy as possible to install a haskell compiler and cabal.
20:22:08 <kmc> so i don't really know what the status is
20:22:13 <kmc> but afaik Scratch is still banned
20:22:19 <kmc> and that's pretty directly offensive
20:22:59 <dark> roconnor, in windows, i think it's prudent to direct the user to HP
20:23:00 <wagle> is there a version of error that aborts the computation, but gives an exitcode of 0 or something specified?
20:23:08 <kmc> istr a c64 emulator being banned because it came with BASIC
20:23:10 <kmc> but i don't have a link
20:23:13 <dark> (or ubuntu)
20:23:13 <roconnor> dark: I don't see why the host OS is relevent.
20:23:16 <mzero> we should, roconnor - at present the easiest way is HP ---- make a better way
20:23:32 <kmc> wagle, unsafePerformIO (exitWith ExitSuccess)
20:23:52 <wagle> egad
20:23:55 <kmc> :D
20:24:01 <btutt> heh
20:24:15 <roconnor> mzero: why, what is hard at the moment for installing GHC and cabal on the Mac?  I don't have a mac so I don't really know.  Don't you make some .dmg files or something and you are done?
20:24:27 <Saizan> wagle: something like "throw ExitSuccess" should work too
20:24:29 <mzero> GHC comes with an installer, so that is easy
20:24:38 <mzero> but getting cabal-install installed is a huge pain in the arse
20:24:44 <roconnor> ah
20:24:54 <kmc> wagle, in GHC, error s = throw (ErrorCall s)
20:25:03 <kmc> you could invent your own exception and then catch it in "main"
20:25:25 <kmc> ah cool, i didn't know ExitCode is an exception but it makes sense
20:36:03 * sm completes a nice trip through the wikipedia ZX* pages.. ahh
20:36:13 <sm> better save the rest for tomorrow. night all
20:36:44 <pygmalion> does anyone have experience working with Data.Time.Calendar?
20:36:48 <Jafet> sm = spider machine?
20:37:41 <pygmalion> or time/dates in Haskell in general?
20:39:20 <kmc> a little, and i found the standard date/time libraries pretty unpleasant to use
20:39:29 <pygmalion> kmc that's what i've found so far...
20:39:30 <kmc> if you have a specific question you should probably just ask it
20:39:49 <pygmalion> hi all. i have a data type that is using the Day type from Data.Time.Calendar and I was hoping to compare the stored Day to today... i can't see any way within Data.Calendar to easily do this. am i missing something?
20:39:57 <pygmalion> (sorry for the hi all, copy/paste)
20:40:02 <kmc> i did not find a great alternative, other than using timezone-olson for tz stuff
20:40:05 <astory> is there a sort of make clean for ghc to clean up all the intermediate files it makes?
20:40:59 <kmc> pygmalion, did you look at Data.Time.Clock?
20:41:19 <kmc> pygmalion, getCurrentTime :: IO UTCTime
20:41:25 <kmc> then you can get a Day out of a UTCTime
20:44:28 <pygmalion> kmc: i tried c <- getCurrentTime // toGregorian $ utctDay c // which gave me (2011, 3, 6), but i'm not sure how to bring that into Data.Time.Calendar format (2011-03-06)
20:45:02 <kmc> the Day type is defined in Data.Time.Calendar
20:45:06 <kmc> did you mean another type from that module?
20:45:16 <kmc> there's toGregorian and fromGregorian to convert
20:45:47 <pygmalion> hmm. maybe i'm doing something wrong then. that's what i'm using. let me look again, thanks.
20:45:49 <kmc> i like that the code uses Integer not Int for the year, so this library will still be usable in the year 536870912
20:45:56 <pygmalion> hahaha
20:46:04 <kmc> where did "2011-03-06" come from?
20:46:15 <kmc> that might be the result of "show" on one of these values, but it's not a valid Haskell literal
20:46:22 <kmc> > 2011-03-06
20:46:23 <lambdabot>   2002
20:46:27 <pygmalion> yeah that's what it is, showGregorian.
20:46:28 <TTimo> lol
20:46:38 <dolio> > maxBound :: Int64
20:46:39 <lambdabot>   9223372036854775807
20:46:52 <TTimo> > maxBound :: Integer
20:46:52 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
20:46:53 <lambdabot>    arising from...
20:47:09 <pygmalion> >getCurrentTime >>= return . toGregorian . utctDay
20:47:34 <kmc> (toGregorian . utctDay) `fmap` getCurrentTime
20:47:41 <kmc> also it won't work in lambdabot, because she won't execute IO
20:48:07 <pygmalion> ah
20:48:57 <kmc> Integer is nominally unbounded but GHC on my system bounds it at a pathetic (2^64)^(2^64)
20:49:08 <pygmalion> I'm getting "Couldn't match expected type 'Day' against infered type IO (Integer, Int, Int)' now
20:49:14 <kmc> i hope this inconsistency with the Haskell spec will be corrected soon
20:49:15 <kmc> ;)
20:50:01 <kmc> well, you have two problems, one is a mismatch of Day vs (Integer, Int, Int), probably because you forgot one of those conversion functions
20:50:12 <kmc> the other problem is that you're using an IO action as if it were the result of executing that action
20:55:00 <pygmalion> kmc: i'm a little rusty... i am at a total loss as to how to escape from an IO action
20:55:09 <kmc> you don't escape
20:55:14 <kmc> you run it and get the result
20:55:25 <kmc> a value of (IO T) is not a wrapper on a T
20:55:32 <kmc> it's instructions for how to get a T by doing some IO
20:55:41 <kmc> the T doesn't exist yet, and you could execute it multiple times and get different values
20:55:53 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
20:56:07 <pygmalion> thanks
21:02:48 <pygmalion> kmc: so does this mean that there is no way to work with the current date that is NOT within IO?
21:03:23 <pygmalion> kmc: (as background, i'm trying to take diffDays between a due date and the current date for a todo list app
21:04:08 <kmc> yes, it means that, in a global sense
21:04:16 <kmc> you can run an IO action and pass the result to a pure function
21:04:29 <kmc> that's what you were doing before with "getCurrentTime >>= return . toGregorian . utctDay"
21:04:42 <kmc> but the overall expression will be an IO action
21:05:03 <kmc> the problem is that "today" is not a fixed unchanging value
21:05:11 <pygmalion> right, i see.
21:05:19 <pygmalion> "pure" vs "impure"
21:05:21 <kmc> "today" is instructions on how to build a Day by consulting the outside world
21:05:45 <kmc> it's often explained as "pure vs. impure" but i think that's misleading
21:05:59 <kmc> i'd rather think of values and evaluation, versus actions and execution
21:06:16 <kmc> because Haskell doesn't have "impure functions"
21:06:33 <kmc> and IO actions have the same evaluation properties as any other value
21:06:35 <kmc> they are first-class
21:06:46 <kmc> they're not specially "impure"
21:10:18 <djahandarie> From the viewpoint of execution, there are pure and impure functions. From the viewpoint of evaluation, there are only pure functions.
21:10:40 <kmc> djahandarie, how are there "impure functions"?
21:10:53 <kmc> there are functions and actions
21:11:01 <kmc> actions aren't functions, because they don't take arguments
21:11:19 <kmc> most languages conflate the three roles of "takes arguments", "has effects", and "delays evaluation"
21:11:24 <kmc> Haskell has separate constructs for each
21:11:25 <djahandarie> In the resulting binary there are functions that are impure.
21:11:35 <djahandarie> And that is where execution happens.
21:11:36 <copumpkin> "functions"
21:11:40 <shachaf> djahandarie: Why do you call those "functions"?
21:11:43 <copumpkin> in the resulting binary, there's no real notion of function
21:11:46 <kmc> that's an implementation detail of GHC, and needn't be the case
21:11:49 <copumpkin> there's just sequential exeuction with jumps
21:11:56 <kmc> and yeah, the code in that binary doesn't adhere to your platform's C calling convention
21:12:09 <shachaf> In the resulting binary there is only machine code.
21:12:09 <monochrom> please call them procedures and shoot Wirth and K and R for calling them functions.
21:12:13 <kmc> so it's really dubious calling them "functions"
21:12:31 <kmc> anyway it's perfectly legit to make a Haskell implementation where IO is a real algebraic data type with a non-code representation
21:12:47 <djahandarie> At which point execution doesn't exist anymore. I was talking about GHC.
21:12:54 <kmc> yes execution exists
21:13:04 <kmc> execution is what the runtime system does when it traverses that data type
21:13:18 <monochrom> "zen semantics"?
21:13:41 * copumpkin tries to come up with a clever variation on "one hand clapping"
21:13:44 * copumpkin fails
21:13:49 <shachaf> djahandarie: Anyway, if you're just talking about GHC, then these are implementation details.
21:13:50 <ddarius> @google "assignment calculus"
21:13:51 <lambdabot> http://www.assignmentexpert.com/math/calculus.html
21:13:51 <lambdabot> Title: Calculus Homework Solutions | Calculus Assignment Online
21:13:57 <ddarius> Hmm...
21:13:57 <monochrom> unsafe'one'hand
21:14:01 <kmc> GHC does all kinds of awful things on the backend that are best ignored if you're trying to explain IO to a beginner
21:14:06 <copumpkin> ddarius: excellent! thanks
21:14:10 <kmc> they're totally irrelevant and confusing too
21:14:15 <copumpkin> I've been looking for a way to apply calculus to my programs for a while
21:14:15 <monochrom> hahahaha calculus homework
21:14:18 <djahandarie> @googe "bender assignment calculus"
21:14:18 <lambdabot> No Result Found.
21:14:20 <kmc> :D
21:14:25 <djahandarie> @googe bender "assignment calculus"
21:14:25 <kmc> tropic of calculus
21:14:27 <lambdabot> http://www.cas.mcmaster.ca/~bendermm/ACslides.pdf
21:14:27 <lambdabot> Title: cache:http://www.cas.mcmaster.ca/~bendermm/ACslides.pdf - Google Search
21:14:36 <djahandarie> God damn it I just want the thesis
21:14:39 <copumpkin> at least it isn't an expert sex change
21:14:54 <kmc> copumpkin, better than a novice sex change!
21:15:02 <copumpkin> indeed :S
21:15:06 <djahandarie> kmc, if execution exists then as far as I'm concerned there are still impure and pure 'things'
21:15:20 <pikhq_> Yeah, I'd certainly consult an expert for that.
21:15:30 <kmc> it's worth saving up for
21:15:33 <kmc> djahandarie, but "function" is not a good name for them
21:15:49 <kmc> you can call an IO action "impure" but that suggests that it somehow has special evaluation properties, which is untrue
21:15:56 <monochrom> @wn function
21:15:58 <kmc> you can call "seq" on your IO action all day and nothing of consequence will happen
21:15:58 <lambdabot> *** "function" wn "WordNet (r) 2.0"
21:15:58 <lambdabot> function
21:15:59 <lambdabot>      n 1: a mathematical relation such that each element of one set is
21:17:26 <Jafet> How zen.
21:17:40 <copumpkin> lol
21:17:42 <kmc> i think the "pure vs impure" terminology encourages thinking of "IO" as a "taint bit" on (->), which is a tempting but ultimately wrong model
21:17:52 <kmc> that also obscures the real power of first-class IO
21:18:09 <peter11> @src (.)
21:18:09 <lambdabot> (f . g) x = f (g x)
21:18:09 <lambdabot> NB: In lambdabot,  (.) = fmap
21:18:09 <djahandarie> What about unsafePerformIO
21:18:10 <copumpkin> @remember WordNet [when asked for the definition of "function"] a mathematical relation such that each element of one set is
21:18:10 <lambdabot> Okay.
21:18:15 <kmc> djahandarie, what about it?
21:18:29 <djahandarie> That could result in an impure function couldn't it?
21:18:33 <kmc> yeah
21:18:37 <kmc> that's cheating ;P
21:18:44 <copumpkin> no true haskell uses unsafePerformIO evilly
21:18:47 <copumpkin> <_<
21:19:01 <kmc> to be ultra pedantic, the documentation says that any use of unsafePerformIO which would create an impure function is instead totally undefined behavior
21:19:01 <ddarius> copumpkin: Did you do anything with your picture?
21:19:15 <kmc> but that's manifestly not how it's used with existing implementations
21:19:20 <copumpkin> ddarius: my picture?
21:19:41 <copumpkin> oh!
21:19:44 <copumpkin> forgot about that
21:20:26 <kmc> djahandarie, if you implement IO with a data type and an interpreter in the RTS, then you need an extra primitive for uPIO
21:20:40 <kmc> if you implement IO the way GHC does, then everything below some level is unsafePerform'd, and you get it for free
21:21:12 <ddarius> kmc: The "special primitive" just being a call to the RTS interpreter.
21:21:21 <kmc> yeah
21:22:07 <jmcarthur> IO, like most monads, is really just an embedded language and has a very distinct flavor from other haskell code
21:22:22 <copumpkin> here we go
21:22:22 <copumpkin> http://gallery.me.com/pumpkin#100008/IMG_0114&bgcolor=black
21:22:29 <copumpkin> very appropriate for the channel
21:22:34 <copumpkin> I also dedicated the comment on it to kmc
21:22:50 <djahandarie> Haha
21:22:52 <kmc> baller
21:22:53 <kmc> ultra baller
21:22:57 <augur> lolwut copumpkin
21:23:09 <kmc> is that the one in Cambridge off Mass Ave?
21:23:13 <copumpkin> yeah
21:23:34 <rwbarton> oh yeah I've been there
21:23:34 <kmc> (why is there no Energy Ave)
21:23:36 <copumpkin> augur: kmc, um, disapproves of my apple thing
21:23:48 <augur> copumpkin: http://gallery.me.com/pumpkin#100008/photo1216784167513&bgcolor=black
21:23:50 <augur> wtf is that
21:23:57 <copumpkin> yeah, big meat
21:23:58 <copumpkin> mmm
21:24:06 <augur> oh, leg of lamb?
21:24:10 <copumpkin> no, a monster steak
21:24:10 <djahandarie> Haha people are now looking through all of your images copumpkin
21:24:12 <djahandarie> Poor move
21:24:14 <augur> oh ok
21:24:20 <copumpkin> http://www.theforge.com/
21:24:22 <augur> as long as its not some sort of sea creature
21:24:28 <copumpkin> djahandarie: they're in the public gallery, are they not? :P
21:25:13 <kmc> anything exciting on Haskell St?
21:25:16 * ddarius recalls the "sea monster nabe" he had in Kyoto.
21:25:20 <copumpkin> kmc: not at all :(
21:25:26 <copumpkin> well, nothing obvious anyway
21:25:35 <copumpkin> maybe we just didn't look deep enough
21:25:53 <copumpkin> ddarius: wow, actual sea monster! I hear that's hard to come by these days
21:26:01 <augur> copumpkin: do you know anything of species where enumeration might depend on the enumerators?
21:26:11 <augur> or whatever you want to call them
21:26:30 <copumpkin> I know nothing of species at all
21:26:35 <augur> lame!
21:26:37 <copumpkin> my math background is rather thin :P
21:27:03 <kmc> augur, code it in agda first ;)
21:27:07 <augur> kmc: :P
21:27:13 <copumpkin> agda is pretty fun if you like bugs
21:27:22 <djahandarie> I hear scala is good for that too
21:27:23 <shachaf> If IO was done using an ADT, would there be circumstances where IO values could be reasonable examined?
21:27:28 <copumpkin> djahandarie: oh yes, excellent
21:27:37 <ddarius> shachaf: Sure.
21:27:48 <ion> Yo dawg. We heard you like bugs, so we put a bug in your compiler so you can debug while you debug.
21:28:00 <copumpkin> ion: too close for comfort :P
21:28:02 <kmc> shachaf, one problem with that is monad laws
21:28:21 <kmc> if you can pattern-match the values, then (a >> b) >> c ≠ a >> (b >> c)
21:28:30 <ddarius> kmc: Just normalize the representation with respect to the monad laws.
21:29:44 <kmc> sounds messy
21:29:55 <augur> @tell byorgey tell me about the species of typed lambda terms, or similar species? :D
21:29:55 <lambdabot> Consider it noted.
21:29:59 <kmc> you could anyway provide views which do it
21:30:46 <augur> copumpkin: how about the functor that gives you typed lambda terms, ey? can we construct that do you think?
21:31:02 <augur> or even one simpler, i guess, something with just arities?
21:32:11 <siracusa> Does importing Data.Word change the defaulting rules in some way? GHC suddenly defaults to Word8 instead of Integer.
21:32:57 <copumpkin> augur: functor from what to what? :o
21:33:13 <kmc> siracusa, o.O
21:33:26 * copumpkin should really go to sleep
21:33:29 <kmc> it doesn't do it for me
21:33:30 <copumpkin> need to get up early tomorrow
21:33:44 * ddarius had an epiphany.  "Don't attribute to malice, what can be adequately explained by stupidity" has a middle level.  "Don't attribute to malice, what can be adequately explained by mental illness."
21:33:44 <kmc> my guess is you're indirectly forcing that value to type Word8
21:34:01 <kmc> ddarius, very true.
21:35:04 <siracusa> kmc: I use these functions only in a Word8 context, but I though all top level functions get the most general type, except for defaulting.
21:35:22 <kmc> did you give type signatures at top level?
21:35:22 <augur> copumpkin: presumably something like 1 to something of arity 0, and from pairs of (F,A) (F of arity n > 0, A of arity 0) to terms of arity n-1
21:35:33 <siracusa> kmc: No
21:35:34 <kmc> perhaps it's the monomorphism restriction?
21:35:54 <kmc> i suggest always doing that
21:36:57 <kmc> ghc -Wall is also useful in these situations
21:37:31 <hpaste> kevinburke pasted "awkward func"  http://hpaste.org/44576
21:38:31 * mzero wonders if kevinburke is implementing Python or JavaScript in Haskell
21:38:44 <kevinburke> mzero: not really sure i'm pretty new to this
21:38:45 <ddarius> @hackage berp
21:38:46 <lambdabot> http://hackage.haskell.org/package/berp
21:38:54 <kevinburke> well thats not rue
21:39:04 <kevinburke> theres just a few diff things i need to check and having trouble doing them
21:39:06 <ddarius> @hackage language-javascript
21:39:06 <lambdabot> http://hackage.haskell.org/package/language-javascript
21:39:43 <copumpkin> derp
21:40:13 <djahandarie> @hackage derp
21:40:14 <lambdabot> http://hackage.haskell.org/package/derp
21:40:16 <djahandarie> copumpkin, wrong package
21:40:39 <kevinburke> how can i make that less ugly?
21:41:56 <mzero> what monad is it in?
21:43:13 <copumpkin> augur: hmm, going to sleep now, but what would the morphisms be in the two categories?
21:43:19 <copumpkin> @quote lolcategory
21:43:19 <lambdabot> tensorpudding says: lolcategory demands moarphisms
21:43:33 <copumpkin> proof that you need them!
21:43:44 <augur> im not sure theres two categories involved
21:43:52 <copumpkin> or even just one
21:44:02 <augur> i dont know what the morphisms would be :)
21:44:08 <kevinburke> mzero: the idea of wrapping it in a monad was to force the statements to execute - it's a type checker
21:44:18 <copumpkin> needmoar thought, that I shall put in tomorrow :P
21:44:20 * hackagebot time-units 1.0.0 - A basic library for defining units of time as types.  http://hackage.haskell.org/package/time-units-1.0.0 (AdamWick)
21:44:23 <mzero> huh?
21:44:25 <copumpkin> actually, probably not much time
21:44:32 <copumpkin> for the coming week
21:44:41 <augur> copumpkin: this is one of the problems of not know how to apply CT!
21:44:41 <mzero> forces which statements to execute? the Haskell ones?
21:44:50 <kevinburke> yes - like checkStm
21:45:04 <mzero> I'm not sure what you mean by that
21:45:11 <mzero> what is the type of checkStm?
21:45:21 <kevinburke> if there are type checking errors we want to return errors, otherwise we don't want to do anything
21:45:28 <kevinburke> but we need to type check everything in teh document
21:45:35 <kevinburke> the return type of checkStm is just ()
21:45:41 <mzero> Context -> [Statement] -> ()
21:45:42 <mzero> ?
21:45:44 <kevinburke> or m ()
21:45:53 <mzero> why not just have it return Bool?
21:46:00 <kevinburke> i guess
21:46:07 <kevinburke> but you wouldn't use it again
21:46:12 <kevinburke> it would either return True or an error
21:46:21 <mzero> remember - just being in a monad doesn't mean that there is a forced execution
21:46:21 * hackagebot rate-limit 1.0.0 - A basic library for rate-limiting IO actions.  http://hackage.haskell.org/package/rate-limit-1.0.0 (AdamWick)
21:47:54 <mzero> so over all what you want is a functoin (checkConst) that takes some info and produces either alls fine, or  some error
21:48:12 <mzero> I'd make the whole thing return type     Either String ()
21:48:28 <jmcarthur> why not just Maybe String or something
21:48:30 <mzero> now, Either String is a monad -- and THAT is a much nicer monad to work in for what you're doing
21:48:40 <jmcarthur> oh, for the monadness
21:48:46 <mzero> because, at each stage, if something results in Left, it's done
21:49:12 <kmc> monads are not the universal hammer ;)
21:49:28 <jmcarthur> monads aren't even really a tool, IMO
21:49:33 <kmc> the monad class / syntax can be convenient shorthand, but if you're a beginner you might want to do things more straightforwardly
21:49:34 <jmcarthur> they are just a way of looking at existing ideas
21:49:37 <kmc> yeah
21:49:44 <mzero> they aren't --- but they make this kind of chaining, where you want to stop at the first failure nice
21:49:47 <kmc> really just the recognition that some existing ideas share a common structure
21:49:55 <jmcarthur> they don't make anything, is my point
21:50:11 <jmcarthur> chaining can be done without the Monad type class
21:50:13 <kmc> i feel a lot of beginners say "i need to solve problem Z, i'd better find a Z monad"
21:50:25 <Zao> Where's my Euler monad?
21:50:42 <jmcarthur> and even the chaining junk is only useful if it's useful, if you know what i mean
21:50:55 <djahandarie> Mo Monads Mo Problems
21:50:56 <kevinburke> ok
21:51:15 <mzero> true enough - one can chain with Maybe easily enough
21:51:19 <mzero> a little more painful with Either
21:51:29 <gracenotes> Some people, when confronted with a problem, think "I know, I'll use monads." Now they usually have found a terse means of describing the flavor of computation they wish to perform.
21:51:37 <kevinburke> another ieda was for debugging if you wrap in a monad it makes it easier to have putStrLn calls to figure out what's going on
21:51:38 <jmcarthur> lol
21:51:49 <kmc> kevinburke, you can use Debug.Trace for that anyway
21:51:53 <jmcarthur> kevinburke: that is IO, not all monads
21:51:54 <mzero> it does feel a bit odd to use Maybe String where Just String is the error and don't continue case, and Nothing is the keep going
21:52:02 <mzero> hence I suggested Either String a
21:52:06 <kevinburke> ok
21:52:07 <jmcarthur> kevinburke: well, IO, or any instance of MonadIO
21:52:13 <kmc> yeah, IO is a particular and very unusual monad
21:52:14 <gracenotes> mzero: done that before
21:52:14 <kevinburke> let me try rewriting a bunch of stuff
21:52:22 <gracenotes> it's not that bad. the Just String, I mean.
21:52:39 <djahandarie> The more monads we come across, the more problems we see...
21:52:42 <kmc> if all you're going to use is (>>) then you might as well write the one-liner that works with Maybe in the desired way
21:52:45 <gracenotes> of course, if the only result is Nothing, something is wrong.. unless it's effectful
21:52:49 <kmc> which is basically mplus?
21:53:02 <mzero> though, in this case, I'd be tempted to just define my own        data Checked = Fail String | OK
21:53:16 <jmcarthur> this is sounding like Alternative
21:53:18 <mzero> that way it is sort of self documenting
21:53:28 <kmc> oll korrect
21:54:11 <mzero> and a simple composition operator      andCheck :: Checked -> Checked -> Checked
21:54:32 <mzero> whcih I'd probably write     (&?) :: Checked -> Checked -> Checked
21:54:36 <mzero> and away I'd go
21:55:07 <kevinburke> so, you have every checkStm return an Either
21:55:36 <kevinburke> and every time you call checkStm you have to have "case checkStm of (Left a) -> error "theerror" (Right b) -> keep going
21:55:44 <mzero> nope
21:55:59 <mzero> if you have the Error monad in scope  (import Control.Monad.Error)
21:56:05 <mzero> then Either String a is an Error monad
21:56:05 <kmc> you can make a function that just does that
21:56:06 <mzero> so just
21:56:13 <mzero> do { check1; check2; check3 }
21:56:26 <kmc> :t either error id
21:56:26 <lambdabot> forall b. Either [Char] b -> b
21:57:43 <siracusa> kmc: This is really strange. Defining f :: Word8 -> Word8; f x = x + y and y = 10 at top-level, the inferred type for y is Word8. If I remove the definition for f the type of y gets defaulted to Integer. Is that intended?
21:58:31 <kmc> makes sense to me
21:58:41 <kmc> if you have (x + y), then x and y have to have the same type
21:58:54 <jmcarthur> siracusa: it's intended, although i disagree with the design choice myself
21:59:12 <jmcarthur> i'd rather y be polymorphic by default
21:59:30 <jmcarthur> then again, it's good practice to have explicit top-level signatures anyway, so no big deal
22:00:11 <siracusa> jmcarthur: Yeah, I'm just too lazy to write them down :-P
22:00:33 <kmc> ghc -Wall will print them for you
22:00:38 <kmc> and will also warn about defaulting
22:00:47 <kmc> defaulting is an ugly hack
22:01:02 <kmc> so is the monomorphism restriction
22:01:18 <siracusa> I disabled it, there were too many defaulting warnigs.
22:01:52 <jmcarthur> defaulting warnings are great, IMO.
22:02:11 <jmcarthur> usually they show up when i'm really depending on something being a particular type, and the default is the wrong one
22:02:21 <augur> blah. im going home
22:02:22 <augur> night
22:02:36 <kmc> you disabled -Wall because there were too many warnings?
22:02:51 <siracusa> Yep :-)
22:03:11 <kmc> i bet you could get a job running nuclear reactors in Soviet-era Ukraine
22:03:13 <Pseudonym> I've had to do that.  With Other People's Code(tm).
22:03:39 <Zao> kmc: "lightning never strikes twice", etc.
22:08:31 <mzero> http://hpaste.org/paste/44576/awkward_func_annotation#p44577
22:08:43 <mzero> kevinburke -- check out that
22:09:30 <kevinburke> mzero: what are the question marks?
22:09:40 <mzero> I defined two operators
22:09:46 <mzero> &?  and ?>
22:10:01 <mzero> first could be read "then check"
22:10:22 <mzero> the second "or else fail"
22:10:51 <kevinburke> oh
22:10:51 <kevinburke> ok
22:10:52 <mzero> not sure I have all the precedence levels right - so may need a few more parenthesis
22:11:38 <mzero> here were are using the power of non-strict eval, rather than fighting it
22:11:49 <kevinburke> oh i see
22:12:28 <kevinburke> so its like one long statement joined with &?
22:12:41 <mzero> it is one long expression
22:12:46 <kevinburke> right
22:12:47 <mzero> right
22:12:51 <mzero> :-)
22:13:10 <mzero> no need to worry that things on the right will be evaluated if they don't need to be --- 
22:13:18 <mzero> the definition of &? takes care of that
22:14:30 <mzero> whoops --- "allOk $ map"   --- not ? in there
22:15:58 <kevinburke> ok
22:16:13 <mzero> fixed and made shorter:    zipWith   is your friend
22:16:15 <kevinburke> yeah i need to refactor a lot of stuff atm
22:18:06 <poseidon> I'm going over a haskell tutorial.  It seemed to neglect what /= means.  I'm used to being expanded from the x /= 2 to the expression x = x / 2.  However, in this tutorial, it seems as though it is a boolean expression and not an assignment
22:18:20 <Pseudonym> It means !=
22:18:22 <djahandarie> @type (/=)
22:18:23 <lambdabot> forall a. (Eq a) => a -> a -> Bool
22:18:31 <djahandarie> > 3 /= 2
22:18:32 <lambdabot>   True
22:18:36 <djahandarie> > 3 /= 3
22:18:36 <lambdabot>   False
22:18:37 <Pseudonym> But it's closer to the mathematical way of expressing it.
22:18:52 <poseidon> ahhh!
22:18:58 <Pseudonym> x != y in maths would mean the factorial of x is equal to y.
22:18:59 <mzero> it's cause we wish we had ≠
22:19:09 <mzero> oh, wait, we DO have ≠
22:19:28 <Zao> mzero: Most don't.
22:19:30 <mzero> but, alas, we are all still too scared to put Unicode in our langauges
22:19:36 <poseidon> I could not find a correlation when using it in ghci.  never thought it would be not equal to
22:19:51 <djahandarie> mzero, I still don't like unicode in general
22:19:55 <mzero> Zao - I don't believe that --- I think in this day and age, almost everyone has ≠
22:19:58 <djahandarie> (For programming)
22:20:22 <shachaf> mzero: Most don't have a convenient way of typing it.
22:20:26 <Zao> mzero: You need source files in a suitable encoding, you need toolchains that understand the encoding, you need editors that can display the encoding, and most importantly... you need to be able to type it.
22:20:33 <Zao> mzero: Go write some APL, will you?
22:20:56 <shachaf> poseidon: Learning Haskell will be easier if you forget what "assignment" is, by the way. :-)
22:21:00 <ion> compose / =
22:21:03 <mzero> true - we really *should* keep the majority of the world's people from programming in scripts they are familiar with
22:21:08 <mzero> :-P
22:21:23 <mzero> Zao - we already have ALL of that
22:21:37 <ion> yes
22:21:43 <Zao> mzero: Most keyboards do not have a /= key.
22:21:47 <ion> compose / =
22:21:55 <mzero> nor a $ key
22:21:57 <Zao> Most keyboards do not have a compose key.
22:22:08 <shachaf> mzero: No OS that I know of comes with a way to type ≠ by default.
22:22:16 <Zao> mzero: You've got to look rather hard to find a keyboard without $
22:22:17 <mzero> Mac does
22:22:19 <mzero> Windows does
22:22:21 <shachaf> mzero: They do come with a way to type $.
22:22:26 <mzero> option =
22:22:28 <mzero> try it
22:22:30 <shachaf> Oh, I guess OS X does, actually.
22:22:50 <kmc> does the default X compose file not have ≠?
22:22:53 <Pseudonym> Linux doesn't, and that's all that matters.
22:22:57 <shachaf> kmc: It does.
22:23:05 <shachaf> kmc: But Compose isn't bound to anything by default.
22:23:14 <Pseudonym> I often edit source code over a vt100 connection.
22:23:19 <shachaf> mzero: How do you type /= in a new Windows instance?
22:23:20 <ion> That’s a matter of a few mouse clicks in desktop environments.
22:23:36 <mzero> I bet, when the set of symbols we use for coding was picked, no one bothered to see if those characters were common on keyboards in India, or China or Japan or Korea
22:23:48 <shachaf> ion: Sure -- but it's not default, and most people don't know how to do it.
22:23:55 <kmc> shachaf, it is if your keyboard is sufficiently awesome, i think
22:23:56 <kmc> but... yeah
22:24:05 <mzero> after all $ isn't exactly useful in places with out US currency!
22:24:28 <kmc> @let (€) = flip ($)
22:24:29 <lambdabot>  Defined.
22:24:30 <shachaf> kmc: "given a sufficiently awesome keyboard" isn't really a valid argument. :-)
22:25:22 <shachaf> Hmm, Ubuntu's default Compose mappings have dropped some keys. :-(
22:25:35 <djahandarie> I set up my compose key at one point but I broke it
22:25:38 <ion> Which ones?
22:25:45 <shachaf> It used to be that compose l - and compose l = made two different characters.
22:25:58 <ion> On my Ubuntu, compose l - makes £
22:26:09 <ion> Sorry, i misread your sentence.
22:26:19 <shachaf> Yes, but compose l = used to make one with two lines.
22:26:41 <kmc> Compose C C C P = ☭
22:26:53 <ion> hah
22:26:56 <shachaf> Huh, they took that out too.
22:26:59 <shachaf> At least, I think it used to be there.
22:27:05 <kmc> which Ubuntu version?
22:27:15 <shachaf> 10.10.
22:27:24 <ion> It’s still in the compose file but compose c c being č seems to take priority or something.
22:27:30 <shachaf> Also: compose ( r and compose ( c now make ® and ©
22:27:33 <shachaf> Which is just horrible.
22:27:39 <ion> <Multi_key> <C> <C> <C> <P>             : "☭"   U262D # HAMMER AND SICKLE
22:27:41 <kmc> ion, upper case
22:27:44 * Zao pets vim an its builtin composition.
22:27:50 <shachaf> kmc: e.Oh
22:27:52 <ion> kmc: Ah. It works indeed.
22:27:54 <shachaf> Never mind.
22:28:11 <kmc> ⊗
22:28:36 <kmc> shouldn't it be <Multi_key> <S> <S> <S> <R> anyway? ;P
22:29:27 <shachaf> Not being able to make ⓡ is still horrible.
22:29:51 <shachaf> It still lets you make Ⓡ, though.
22:30:11 <shachaf> And Ⓒ and © but not ⓒ.
22:30:16 <Pseudonym> Definitely seems wrong to make Haskell programming dependent on the whim of Steve.
22:30:46 * shachaf likes the contextless Steve that Pseudonym introduced.
22:31:16 <kmc> > map generalCategory "Ⓒ©ⓒ"
22:31:17 <lambdabot>   [OtherSymbol,OtherSymbol,OtherSymbol]
22:31:20 <Pseudonym> I'm letting inference work out which one I mean.
22:31:21 <kmc> what are they?
22:31:26 <cafesofie> Irwin?
22:31:43 <shachaf> Pseudonym: I inferred somebody named Steve who doesn't even know about Haskell but just makes random Unicode keyboard decisions on a whim.
22:32:12 <Pseudonym> That'd be him, yeah.
22:32:23 * shachaf -- never mind.
22:32:55 <shachaf> Unicode has parenthesized letter codepoints?
22:33:05 <ion> circled
22:33:17 <ion> U+24B8 CIRCLED LATIN CAPITAL LETTER C
22:33:38 <ion> It does have parenthesized ones, too. ⒜
22:34:00 <shachaf> And yet they still haven't found it in their heart to add play/pause/rewind/fast forward/stop buttons. :-(
22:35:03 <ion> shachaf: I’m sure you agree the characters they added in Unicode 6 are more important: http://www.instantfundas.com/2010/10/emoticons-cats-and-2000-new-characters.html
22:35:36 <shachaf> ion: Oh, well, cats? OK, I guess I can't argue with that.
22:35:45 <djahandarie> That's actually pretty sweet
22:36:09 <shachaf> killall -9 interactive_advertisement
22:36:22 <mzero> those parenthesized ones were there so that Unicode can round trip with JIS character sets that had them prior to Unicode
22:36:50 <shachaf> 〠
22:36:55 <ion> Lots of characters in Unicode are there only for the purpose of lossless conversion from legacy character sets.
22:37:17 <ion> such as ℃
22:37:35 <kmc> shinkansen?
22:37:44 <ion> I wish they were marked as deprecated in the spec, though. (Perhaps they are and i have not noticed.)
22:37:59 <shachaf> kill -9 $$
22:38:05 <ion> kill -9 1
22:38:19 <kmc> i like that they added both "dude on a bike" and "dude on a bike doing a sick-ass jump / wheelie"
22:39:02 <kmc> U+1F46A NORMATIVE HETEROSEXUAL FAMILY UNIT
22:40:33 <shachaf> Where is there a list of all the new code points?
22:41:35 <mzero> http://www.unicode.org/charts/PDF/Unicode-6.0/
22:41:46 <mzero> new code points for Unicode 6.0
22:42:19 <shachaf> Bah, a list of links to PDFs. Oh, well.
22:42:46 * shachaf wonders when Linux Chrome will get that native PDF viewer.
22:42:53 <mzero> hey - where's my NORMATIVE HOMOSEXUAL FAMILY UNIT?!?!??!
22:43:09 <mzero> They should have made the AND KIDS be a combining mark
22:43:20 <mzero> then it could have been added to any of the couple forms
22:43:43 <kevinburke> mzero: any way to define an infix with regular characters?
22:43:50 <kmc> chinese alternate full-width grass radical #7 with kids
22:43:54 <kmc> i like U+1F47E  ALIEN MONSTER
22:44:01 <mzero> you don't even need to define it, kevin
22:44:08 <mzero> just put the function in back ticks
22:44:37 <mzero> > (* 3) `map` [1..10]
22:44:38 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
22:44:55 <mzero> you can, I believe use infix declarations to give it a precedence
22:45:04 <kmc> mzero, the character is actually named "FAMILY" so presumably it's a font / presentation issue
22:45:11 <mzero> HEH!
22:45:24 <mzero> Glyphic variants to the rescue!
22:45:38 <kmc> i'm glad they added a floppy disk icon too
22:45:41 <ion> Where’s my NORMATIVE ALIEN MONSTER FAMILY UNIT?
22:45:41 <kmc> not a moment too soon
22:45:49 <shachaf> What's 1F4A8 supposed to be?
22:45:57 <mzero> We have Japanese phone companies to thank for all this, I think
22:46:11 <kmc> U+1F5FE  SILHOUETTE OF JAPAN
22:46:20 <ion> mzero: Please elaborate.
22:46:47 <mzero> I believe there has been an explosion of these characters being added to cell phones in Japan
22:46:57 <ion> heh
22:47:00 <mzero> they have gotten enough use that interchange became an issue
22:47:08 <liyang> shachaf: what usually preceeds a U+1F4A9.
22:47:28 * shachaf thought it was a mathematical symbol for some reason.
22:47:57 <ion> FSVO mathematics
22:48:01 <kmc> aww there's now a whole category "Romance symbols"
22:48:05 <kmc> right after "Medical symbols"
22:48:17 <adu> ?
22:48:21 <kmc> U+1F4A9  PILE OF POO  = dog dirt
22:48:24 <kmc> not kidding
22:48:57 <mzero> oh no... MORE HEARTS!
22:49:09 <mzero> there are a freakin' ton of 'em
22:49:11 <ian_mi> copumpkin: any idea how to add integer types?
22:49:18 <kmc> U+1F44A  FISTED HAND SIGN  ← finally, we can punch people in the face over the Internet!
22:50:02 <kmc> 1F42A  DROMEDARY CAMEL · has a single hump
22:50:03 <kmc> 1F42B  BACTRIAN CAMEL · has two humps
22:50:07 <Jafet> We also need a combining character for YOUR FACE
22:50:20 <adu> lol
22:50:38 <olsner> U+1F4A9 will be useful for commenting bad code
22:50:55 <adu> roflmao
22:51:16 <shachaf> And *still* no play/pause icons!
22:51:26 * shachaf is annoyed.
22:51:48 <Jafet> With enough unicode symbols, we can move GUIs back to character terminals.
22:52:07 <kmc> at least they have the inverted interrobang now
22:52:33 <shachaf> What's the meaning of 1F534 and 1F535?
22:53:10 <shachaf> Isn't Unicode not supposed to have color?
22:53:19 <mzero> LARGE RED CIRCLE, LARGE BLUE CIRCLE
22:53:49 <homie> err, colour ?
22:54:03 <shachaf> Coulour.
22:54:10 <homie> that's something todo with escape sequences not ?
22:54:30 <mzero> ▶   -- █  --  ▐▐
22:54:32 <homie> are escape sequences portable ?
22:54:36 <mzero> these aren't good enough, shachaf
22:54:44 <shachaf> mzero: They aren't.
22:54:48 <mzero> :-P
22:54:50 <homie> ok
22:55:07 <shachaf> mzero: E.g. getting two vertical bars to look nice means playing with the spacing between them in a non-portable way.
22:55:24 * shachaf eventually gave up and just made it ugly.
22:55:25 <mzero> shachaf - perhaps, if one cares that much, they should be... images
22:55:37 * mzero ducks
22:55:43 <shachaf> I guess if I cared enough I could do that.
22:55:49 <shachaf> Maybe SVG would work, in that context.
22:56:10 <shachaf> (The context was a JavaScript bookmarklet.)
23:00:31 <mzero> ah - encoding gifs as data: urls can be painful.....
23:01:40 <shachaf> mzero: Well, SVG would probably've been better and simpler anyway.
23:04:14 <shachaf> U+1F389 PARTY POOPER
23:04:48 <shachaf> Hmm, they have phases of moon. They should've added the Zork Zero moons.
23:09:26 <augur> hmm
23:09:45 <augur> i can translate the simple arity language into a haskell data type, thats good
23:10:23 <Jafet> U+3263D FULL PHOBOS AND DEIMOS
23:12:25 <augur> data Term where Var :: String -> Term n, App :: Term (S n) -> Term Z -> Term n
23:12:58 <augur> and that should generate first order lambda terms
23:13:03 <augur> without abstractions
23:14:26 <kevinburke> let's say I have a data type with a lot of different options
23:14:34 <kevinburke> and I want 4 of them to behave the same way in a certain function
23:14:48 <kevinburke> is there a way to write case _ of x1, x2, x3, x4 -> do action
23:14:55 <kevinburke> or do I have to write them all out?
23:15:43 <mzero> you have to write them out
23:15:44 <mzero> BUT
23:15:48 <kmc> sadly, there's no such construct :/
23:16:12 <mzero> define a predicate on that type, that tests if they are in the set
23:16:16 <Jafet> Well, you can use a horrible guard like x | x `elem` [A,B,C,D] ->
23:16:18 <kevinburke> oh ok
23:16:19 <kevinburke> yeah
23:16:22 <mzero> especially if you need to do this in more than on place
23:16:43 <kmc> afaik or-patterns would be a reasonable language extension
23:16:44 <mzero> ew! `elem` in a guard?!?!?!
23:17:04 <kmc> i can't think of any big difficulty
23:17:25 <Jafet> I remember seeing code like case (a,b,True) of (x,y,f x y) ->
23:17:28 <augur> kmc: variable bindings.
23:17:55 <Jafet> f a b rather
23:17:59 <augur> you'd need to restrict to the same number of to-be-bound variables
23:18:08 <kmc> augur, you'd require that they all bind the same variables of the same types
23:18:12 <kmc> (or of unifiable types, maybe)
23:18:15 <augur> kmc: and the same number.
23:18:35 <kmc> "same number" would be a consequence of "same variables", no?
23:18:44 <kmc> since you can't repeat a variable anyway
23:18:58 <augur> well yes, i suppose
23:19:00 <kmc> \(Left x | Right x) -> x :: Either a a -> a
23:19:04 <augur> the same variables in each pattern
23:19:08 <kmc> no good to say (Left x | Right y)
23:19:49 <augur> other than that tho it should be possible
