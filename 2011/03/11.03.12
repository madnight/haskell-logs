00:08:13 <Liskni_si> adnap: I think that Flexible* language extensions are okay to use no matter what
00:08:57 <Cale> adnap: It's always okay.
00:09:38 <Cale> adnap: The reason there's a FlexibleInstances extension at all is that H98 was *really* conservative about what instances it allowed.
00:09:56 <Cale> All the implementations were easily able to handle more than the standard required.
00:13:03 <Cale> It doesn't let you do anything controversial at all, it just relaxes the condition that the types in instance heads are single constructors followed by distinct type variables, to allow nested type constructors.
00:13:21 <Cale> (for example, being able to declare an instance for Maybe Int
00:13:21 <Cale> )
00:13:51 <deteego> does anyone know if there is some sought of global flag for GHC to enable LLVM by default?
00:14:18 <geheimdienst> is there a list of extensions ranked by evilness? i was wondering which extensions people consider harmless and which dangerous
00:16:27 <deteego> also is there an option in cabal to build with llvm
00:16:28 <Cale> Sorry to ask such an offtopic question here, but #ubuntu is too busy. Does anyone remember off-hand the nice command when building a .deb package to easily add a tag to the version number?
00:16:55 <Cale> Can't seem to google it.
00:18:05 <Cale> oh, dch
00:18:19 <Cale> dch -v <version>, apparently
00:18:41 <geheimdienst> you speak in riddles
00:21:06 <Cale> geheimdienst: There are a bunch of weird tools for creating debian packages and automating the various arcane policies that are in place.
00:21:21 <Cale> I can never remember what they're called or how to use them when I need to :P
00:22:11 <Cale> I end up googling it every time, but most descriptions seem to leave out the step where you change the version number.
00:22:16 <geheimdienst> sounds like it would be a good idea to make some more tools with some more switches to automate those weird tools ... er, wait
00:22:21 <geheimdienst> ;)
00:42:57 <kuribas> Hi, I am trying to install wxhaskell on ubuntu, but after I type "sudo make install", I get: wxcore-0.11.1.2: dependency "base-4.2.0.0" doesn't exist (use --force to override)
00:53:43 <kuribas> I have base-4.2.0.0, so it doesn't make sense.
00:56:10 <Heffalump> which ghc is picked up when running under sudo
00:56:11 <Heffalump> ?
00:56:19 <Heffalump> if you have multiple ones installed, that might be the issue
00:57:11 <kuribas> Only one.  ghc-6.12.1
00:57:33 <kuribas> I am trying the cabal install now.
01:03:17 <kuribas> Cabal install worked.  Maybe the source package is broken.
01:57:40 <MetaEntity> hello everyone
01:58:23 <MetaEntity> I am a looking for a good model to map an oo component model for gui in haskell
01:58:32 <MetaEntity> Does someone have an idea?
01:59:31 <MetaEntity> To do simpler: OO is very good for a gui model, how does Haskell using handle that?
02:00:14 <MetaEntity> *how does Haskell handle that?
02:05:32 <MetaEntity> nobody knows?
02:09:32 <ManateeLazyCat> Wow, ghc-7.0.2 compile speed looks much fast than ghc-6.12.xxxx
02:09:32 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
02:20:45 <gienah> MetaEntity: maybe this might help: http://yi-editor.blogspot.com/2008/12/prototypes-encoding-oo-style.html
02:22:17 <benmachine> a server I administrate recently died because an emacs process ate all the memory
02:22:59 <benmachine> it was editing a haskell file, so I'm wondering if anyone can think of scenarios in which haskell-mode might bleed bytes everywhere
02:23:04 <benmachine> and if they can be prevented
02:23:34 <benmachine> or hmm do we even have haskell-mode installed
02:24:40 <Eduard_Munteanu> They could be prevented with proper PAM limits / ulimits ;)
02:27:24 <benmachine> mm, I have a vague idea that we didn't like ulimits for some reason
02:28:00 <benmachine> I mean, yes we can do things like that but I'm looking more for possible causes
02:59:28 * hackagebot hxt-xpath 9.1.1 - The XPath modules for HXT.  http://hackage.haskell.org/package/hxt-xpath-9.1.1 (UweSchmidt)
03:01:08 <burp> when I foreign import functions that take a double as an argument, do I have to use CDouble or can I use Double?
03:01:26 <burp> sometimes I see code snippets with Double 
03:01:46 <burp> maybe CDouble is only used when further processing with Foreign.* stuff is needed
03:02:29 <ManateeLazyCat> @hoogle realToFrac
03:02:30 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
03:02:51 <DevHC> i think u SHOULD use CDouble
03:03:23 <DevHC> (ie, i think Double works only by coincidence)
03:03:29 <benmachine> yeah
03:03:37 <burp> and this coincidence always works? =)
03:03:48 <benmachine> it... might do
03:03:50 <benmachine> it might not
03:03:54 <DevHC> if u use linux on x86, for example
03:03:58 <Zao> Shaky grounds for robust software.
03:04:02 <burp> :P
03:04:06 <dcoutts> sigh, HaXml's ByteString non-pretty printer is slower than its String pretty printer
03:04:07 <benmachine> there's no guarantee that Double and CDouble correspond to the same type
03:04:12 <burp> well, -O2 will optimize the realToFrac away anyway I assume
03:04:32 <benmachine> yeah I think there are rewrite rules so that CDouble -> Double and vice versa are fast
03:04:38 <ManateeLazyCat> burp: Use realToFrac i paste
03:08:50 <ion> http://twitter.com/aras_p/status/46522232134045696 Because of all the extraneous syntactic noise in the language.
03:09:26 <benmachine> :P
03:18:42 <DevHC> ROFL
03:30:41 * hackagebot Grempa 0.1.3 - Embedded grammar DSL and LALR parser generator  http://hackage.haskell.org/package/Grempa-0.1.3 (OlleFredriksson)
03:39:14 <ManateeLazyCat> How do i know which package depend datetime ? Any lambdabot command?
03:57:14 <sonoflilit> ManateeLazyCat: you mean, which packages depend /on/ datetime?
03:57:34 <sonoflilit> Michael Snoyman wrote a web-service to do that once, you can find it on haskellers.com I think
04:01:25 <ManateeLazyCat> sonoflilit: Thanks, let me check, i got a depend problem when i compile my program on ghc-7.0.2
04:02:34 <sonoflilit> so that's not the direction you need, I think
04:02:48 <sonoflilit> you want to know which packages datetime depends on?
04:03:05 <sonoflilit> just look at the cabal file
04:03:30 <sonoflilit> http://hackage.haskell.org/package/datetime
04:03:35 <sonoflilit> Dependenciesbase (≥2 & <4), old-locale (≥1.0.0.1), old-time (≥1.0.0.1), QuickCheck (2.*), time (≥1.1.2.2)
04:03:40 <ManateeLazyCat> sonoflilit: I want know which package *depend on* datetime, 
04:03:48 * hackagebot loris 0.1 - interface to Loris API  http://hackage.haskell.org/package/loris-0.1 (JohnLato)
04:04:10 <sonoflilit> ok
04:04:15 <sonoflilit> then my first tip should work
04:04:17 <ManateeLazyCat> sonoflilit: I doubt some depend package of my program depend on datetime.
04:04:30 <ManateeLazyCat> Then make me failed.
04:04:38 * ManateeLazyCat Try again.
04:07:37 <sonoflilit> wait
04:07:41 <sonoflilit> I misread
04:07:46 <sonoflilit> my second tip should work
04:08:07 <sonoflilit> hackage can show you that, as well as cabal unpack, and probably just cabal -v
04:09:27 <dcoutts> ManateeLazyCat: http://sparky.haskell.org:8080/package/datetime/reverse
04:10:17 <ManateeLazyCat> dcoutts: Thanks, it's sweet.
04:10:28 <ManateeLazyCat> Error 591
04:10:56 <dcoutts> ManateeLazyCat: you mean an HTTP error for that page?
04:11:05 <ManateeLazyCat> dcoutts: Yep.
04:11:12 <mauke> works here
04:11:12 <dcoutts> oh, works for me
04:11:12 <ManateeLazyCat> I can't access.
04:11:34 <dcoutts> 591 isn't a valid HTTP error either, afaik
04:11:35 <ManateeLazyCat> Okay now, perhaps network just now.
04:11:55 <sonoflilit> Yesterday I tried to unpack some Template Haskell with -ddump-splices and run the unpacked code
04:12:18 <ManateeLazyCat> dcoutts: Cabal will check depend from hackage server? 
04:12:34 <ManateeLazyCat> dcoutts: I have remove datetime depend from manatee-core.cabal, but Cabal still can't work.
04:12:53 <ManateeLazyCat> dcoutts: I install manatee-core local version.
04:12:53 <sonoflilit> I was having lots of trouble, kmc helped me solve many of the errors
04:12:58 <sonoflilit> I still have some left
04:13:18 <dcoutts> ManateeLazyCat: depends what you mean precisely.
04:14:22 <sonoflilit> http://hpaste.org/paste/44711/ape_not_in_scope#p44724
04:14:38 <sonoflilit> Can anyone help resolve the strange error pasted on the end of the file?
04:14:45 <ManateeLazyCat> dcoutts: datetime depend base 3 that can't compile in ghc-7.0.2, i have remove datetime from manatee-core.cabal, still can't work, any cabal command can fix it? Thanks
04:15:12 <ManateeLazyCat> Ok, i change manatee-core's version to try.
04:16:10 <dcoutts> ManateeLazyCat: is the problem that manatee-core does not build, or that you cannot use a package that depends on manatee-core?
04:17:12 * ManateeLazyCat pasted "cabal error." at http://paste2.org/get/1298063
04:17:13 <ManateeLazyCat> dcoutts: manatee-core can, but some package depend on manatee-core can't. Cabal always report above error.
04:18:05 <ManateeLazyCat> From http://sparky.haskell.org:8080/package/datetime/reverse , only possible is Cabal still think manatee-core depend on datetime even i have remove datetime from manatee-core.cabal and build again.
04:19:55 <sonoflilit> ghc complaints that "Not in scope: `apE'", despite the said function being in the global scope
04:19:58 <benmachine> ManateeLazyCat: I believe if a package is already in the package index (because you've already installed that version) then Cabal will check its dependencies there
04:19:59 <sonoflilit> any idea?
04:20:14 <sonoflilit> (code was pasted a few lines up ^^^^)
04:20:29 <ManateeLazyCat> benmachine: Yeap, that's i think. Now i'm update version and try agai.
04:20:31 <ManateeLazyCat> again.
04:21:09 <mauke> sonoflilit: is that the only error?
04:21:15 <dcoutts> ManateeLazyCat: ok if that's what you mean, then yes, cabal looks at the available package version to determine the dependencies, then if it can it will use the installed version.
04:21:34 <dcoutts> ManateeLazyCat: so if you change the dependencies then you should bump the version
04:21:42 <sonoflilit> there were dozens before it
04:21:46 <sonoflilit> they were resolved
04:21:51 <ManateeLazyCat> dcoutts: Why old cabal haven't those problem?
04:21:56 <mauke> sonoflilit: and after it?
04:22:05 <ManateeLazyCat> dcoutts: After i change manatee-core's version, problem looks fix.
04:22:17 <dcoutts> ManateeLazyCat: it uses the same algorithm, there's been no change in that area for some time.
04:22:54 <ManateeLazyCat> dcoutts: OK, first time occur this problem.
04:23:23 <ManateeLazyCat> dcoutts: Any way can remove package information from Cabal index?
04:23:30 <sonoflilit> just six instances of said error
04:24:04 <mauke> sonoflilit: that confuses me a bit because line 188 looks like a syntax error to me
04:24:07 <dcoutts> ManateeLazyCat: you can constrain versions that cabal picks using --constraint='foo == 3.4' or whatever
04:24:30 <ManateeLazyCat> dcoutts: I see, thanks for help. :)
04:25:57 <benmachine> mauke: looks like a TH invocation to me
04:26:05 <sonoflilit> if we're looking at the same version (the last annotation), then that line is TH
04:26:36 <mauke> benmachine: doesn't TH require $( )?
04:26:55 <benmachine> mauke: not since GHC version mumblemumble
04:26:59 <sonoflilit> I left it unpacked because there was a syntax error I didn't know how to resolve in its unpacking, and it is irrelevant to my interests
04:27:06 <sonoflilit> benmachine: lol
04:27:16 <benmachine> it's a fairly new feature
04:27:25 <ManateeLazyCat> mauke: You just need $( ) when you want embedded TH function in other module.
04:27:33 <sonoflilit> to run this code you should need persistent-0.3.1.3, and to remove the "import ADB" line
04:27:34 <benmachine> but I forget whether it was new in 7 or 6.12
04:27:40 <sonoflilit> 6.12
04:27:50 <sonoflilit> as that's what I'm running
04:27:55 <benmachine> ah
04:29:01 <benmachine> sonoflilit: when you move apE to above the TH splice does it start working?
04:29:12 * ManateeLazyCat Backup http://sparky.haskell.org:8080/package , it's good tools 
04:29:13 <sonoflilit> beat you by a second
04:29:17 <sonoflilit> I just did it :)
04:29:19 <sonoflilit> and it worked
04:29:28 <sonoflilit> mauke, benmachine: thanks a lot
04:29:29 <benmachine> sonoflilit: was the splice itself causing errors?
04:29:45 <sonoflilit> the code now compiles
04:29:50 <benmachine> hmm, odd
04:30:02 <benmachine> *might* be a bug
04:30:26 <sonoflilit> should I report it?
04:30:29 <benmachine> erm
04:30:37 <benmachine> I'd come up with a smaller testcase first if you want to
04:30:39 <benmachine> but
04:30:42 <sonoflilit> of course
04:31:17 <benmachine> if you can find a version that fails without using any non-standard libraries, then that would be super great
04:31:30 * benmachine shrug
04:31:44 <benmachine> might be more effort than it's worth, especially since you're a few GHC versions behind the latest anyway
04:35:03 <manateeUser> Say hello from Manatee IRC client (build by ghc-7.0.2)
04:35:10 <ManateeLazyCat> Hmm, looks great. 
04:40:15 <kuribas> What's the function to execute a Monad n times?
04:40:29 <ManateeLazyCat> @hoogle duplicate
04:40:30 <lambdabot> No results found
04:40:34 <benmachine> kuribas: that's a vague question
04:40:51 <hpc> :t forM_ . const
04:40:52 <lambdabot>     Couldn't match expected type `[a]' against inferred type `b -> a1'
04:40:52 <lambdabot>     Probable cause: `const' is applied to too few arguments
04:40:52 <lambdabot>     In the second argument of `(.)', namely `const'
04:40:57 <hpc> :t forM_
04:40:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
04:40:58 <benmachine> kuribas: I suspect you're looking for replicateM or replicateM_
04:41:09 <hpc> :t forM_ [] . const
04:41:10 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> m ()
04:41:16 <kuribas> benmachine: yes
04:41:20 <hpc> :t repeat
04:41:21 <lambdabot> forall a. a -> [a]
04:41:26 <hpc> :t repeatM
04:41:27 <lambdabot> Not in scope: `repeatM'
04:41:31 <hpc> humbug
04:41:36 <benmachine> kuribas: but pedantically, you don't really "execute" monads :)
04:41:50 <benmachine> :t sequence . repeat
04:41:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
04:41:53 <kuribas> benmachine: Combine then then.
04:42:13 <kuribas> :t replicateM
04:42:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
04:42:20 <hpc> benmachine: that produces bottom for most monads
04:42:30 <benmachine> kuribas: it's still not exactly clear what you mean; if you gave us a type signature you are looking for, that might be more clear
04:42:36 <hpc> the state has to be threaded through infinite actions
04:42:45 <benmachine> hpc: not all monads are about threading state :)
04:43:02 <hpc> benmachine: side-effects or whatever, you know what i mean ;)
04:43:32 <benmachine> hpc: that's an even less accurate term :P
04:43:53 <benmachine> ok it isn't
04:43:59 <kuribas> benmachine: (Monad m) => Int -> m a -> m [a]
04:44:07 <hpc> it looks like replicateM is what he wants anyway, so i will withdraw and blame it on me just waking up
04:44:25 <benmachine> hpc: no blame it on me being pedantic and annoying
04:44:28 <kuribas> Yes, replicateM is probably right.
04:44:34 <hpc> benmachine: okie dokie!
04:44:38 <benmachine> :P
04:45:09 <ManateeLazyCat> @hoogle SomeException
04:45:10 <lambdabot> Control.Exception data SomeException
04:45:10 <lambdabot> Control.Exception SomeException :: e -> SomeException
04:45:10 <lambdabot> Control.Exception.Base data SomeException
04:45:23 <benmachine> > sequence (repeat (const ())) 14
04:45:23 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
04:45:32 <benmachine> woo I found a non-bottom one
04:45:45 <hpc> benmachine: quiet, you :P
04:45:47 <kuribas> I knew there was a function like that, but I couldn't remember the name.
04:46:01 <benmachine> I suspect the writer monad could also produce something useful
04:46:14 <benmachine> but Maybe and list and state and IO will all die
04:46:32 <benmachine> although IO might do something while it dies
04:46:37 <hpc> > (sequence . repeat) ([])
04:46:39 <lambdabot>   []
04:46:47 <benmachine> ah, neat
04:46:55 <benmachine> > sequence . repeat $ Nothing
04:46:55 <hpc> > (sequence . repeat) [5]
04:46:57 <lambdabot>   Nothing
04:46:57 <lambdabot>   *Exception: stack overflow
04:47:03 <hpc> > (sequence . repeat) Just 5
04:47:04 <lambdabot>   [Just 5,Just 5,Just 5,Just 5,Just 5,Just 5,Just 5,Just 5,Just 5,Just 5,Just...
04:47:09 <benmachine> hah
04:47:12 <hpc> ha!
04:47:19 <benmachine> > sequence . repeat $ Just 5 -- itym
04:47:20 <lambdabot>   *Exception: stack overflow
04:47:30 <hpc> wait, what?
04:47:35 <hpc> :t sequence . repeat
04:47:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
04:47:45 <hpc> oh, because Just is a function lol
04:47:48 <benmachine> :)
04:48:17 <hpc> > sequence (repeat 5) 4 3 2 1
04:48:18 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t3 -> t'
04:48:19 <lambdabot>         against inferred...
04:48:29 <hpc> > sequence (repeat 5) 4
04:48:29 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
04:48:55 <benmachine> > mapM 4 5 6
04:48:55 <lambdabot>   No instance for (GHC.Num.Num [a])
04:48:56 <lambdabot>    arising from the literal `5' at <inter...
04:48:58 <benmachine> aw
04:49:06 <hpc> > (do{1;2;3;4})5
04:49:06 <lambdabot>   4
04:49:23 <hpc> benmachine: we clearly need more Num instances
04:49:29 <benmachine> clearly :D
04:49:33 <benmachine> > mapM 4 [5] <*> 6
04:49:34 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[b1]'
04:49:36 <benmachine> wait no
04:49:39 <benmachine> > mapM 4 [5]
04:49:40 <lambdabot>   No instance for (GHC.Show.Show (m [b]))
04:49:40 <lambdabot>    arising from a use of `M96775447...
04:49:44 <hpc> :t mapM
04:49:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:50:04 <benmachine> > mapM (($6).4) [5]
04:50:05 <lambdabot>   No instance for (GHC.Show.Show (m [b]))
04:50:05 <lambdabot>    arising from a use of `M36334619...
04:50:05 <hpc> > mapM 4 [5] 6
04:50:06 <lambdabot>   [4]
04:50:12 <benmachine> ah
04:50:22 <benmachine> of course
04:50:24 <benmachine> :P
05:03:54 <kuribas> :t zipM
05:03:55 <lambdabot> Not in scope: `zipM'
05:04:28 <Eduard_Munteanu> :t zipWithM
05:04:29 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
05:05:01 <kuribas> That's it, thanks :-)
05:05:01 <Eduard_Munteanu> :t zipWithM (return . (,))
05:05:02 <lambdabot> forall b a b1. [a] -> [b] -> b1 -> [(a, b1)]
05:08:49 <johannes2> hi there, can someone please help me out with an issue? I need to install the ghc-binary packet
05:09:09 <mauke> what's that?
05:09:18 <johannes2> I heard that Cabal already comes with my version of GHCI 6.10.4
05:09:32 <johannes2> I don't know, it sounds like a library
05:10:04 <mauke> why do you need to install it?
05:10:33 <johannes2> they gave me an exercise at the university and the exercise needs this packet
05:10:51 <Eduard_Munteanu> Do you mean...
05:10:54 <Eduard_Munteanu> @hackage binary
05:10:54 <lambdabot> http://hackage.haskell.org/package/binary
05:11:12 <mauke> johannes2: why do you think it needs it?
05:11:21 <johannes2> looks good
05:11:23 <dcoutts> johannes2: or do you really mean 'ghc-binary' ?
05:11:51 <johannes2> haskell says:
05:11:51 <johannes2>     Could not find module `Data.Binary.Builder':
05:11:52 <johannes2>       Use -v to see a list of the files searched for.
05:12:14 <mauke> (that's actually ghc talking, not haskell)
05:12:23 <dcoutts> johannes2: ok, you need the package called binary
05:12:23 <johannes2> and the exercise says: type :set -package ghc-binary
05:12:26 <mauke> meaning you already have a ghc binary
05:12:31 <dcoutts> doh
05:12:46 <johannes2> hmm but this set command says I don't have it... :(
05:12:49 <dcoutts> Igloo: see, we should never have shipped ghc-binary :-)
05:12:58 <dcoutts> Igloo: here's a university exercise specifying it
05:13:12 <mauke> dcoutts: what is that package?
05:13:20 <dcoutts> mauke: a hack that should be ignored
05:13:29 <johannes2> oO
05:13:30 <dcoutts> it's hidden for a reason
05:13:35 <Eduard_Munteanu> johannes2: you can get it through 'cabal' or through your distribution's package management.
05:13:36 <dcoutts> you want the binary package
05:13:45 <Igloo> dcoutts: No, we should be shipping binary
05:13:56 <johannes2> okay, my distribution's packet manager doesn't have it
05:14:03 <johannes2> but doesn't cabal come with ghci?
05:14:04 <mauke> package, not packet
05:14:17 <johannes2> I mean package, sorry
05:14:38 <johannes2> I have tons of Cabal files on my computer that came with ghci
05:14:47 <johannes2> do I still need to install it?
05:14:56 <mauke> install what?
05:15:06 <johannes2> cabal
05:15:14 <mauke> huh
05:15:41 <benmachine> johannes2: there is a Cabal library that comes with ghc, and a command-line cabal tool that uses it
05:15:44 <johannes2> things like: /usr/lib/ghc-6.10.4/Cabal-1.6.0.3/*
05:15:44 <benmachine> the latter does not come with
05:15:48 <benmachine> you have to get it
05:15:56 <benmachine> it is in the haskell platform though
05:15:56 <mauke> johannes2: that's the library
05:16:11 <johannes2> ahhhh, so I still need to download the commandline tool?
05:16:13 <Eduard_Munteanu> holgr: cabal-install
05:16:19 <Eduard_Munteanu> Sorry.
05:16:26 <Eduard_Munteanu> jo: cabal-install
05:16:30 <Eduard_Munteanu> johannes2: cabal-install
05:16:34 <Eduard_Munteanu> (not Cabal)
05:16:56 <saml> hey have you done large scale web development?
05:17:19 <kuribas> Is there a function like readMaybe :: String -> Maybe a ?
05:17:36 <johannes2> okay thanks so far, I'll try it out
05:17:40 <mauke> kuribas: sort of
05:17:42 <mauke> :t reads
05:17:43 <lambdabot> forall a. (Read a) => String -> [(a, String)]
05:18:28 <Silvah> kuribas: read
05:18:42 <Silvah> > read "Just 3" :: Maybe Int
05:18:43 <lambdabot>   Just 3
05:18:53 <Eduard_Munteanu> Silvah: he wants graceful failures
05:18:58 <Eduard_Munteanu> Not that :)
05:19:03 <serpentologist> High, have someone managed to install Euterpea library (http://plucky.cs.yale.edu/cs431/software_resources.htm) in Ubuntu? I am getting an error ArrowWrap.hs:32:14:
05:19:03 <serpentologist>     `ignoreLinePragmas' is not a (visible) field of constructor `ParseMode' while trying to install it. Google seems to know nothing about it and i am a complete newbie and have no clue what to do with this.
05:19:05 <Silvah> ah
05:19:09 <Eduard_Munteanu> I assume exceptions could be used too.
05:19:18 <Eduard_Munteanu> But that'd be rather ugly.
05:20:21 <kuribas> Reads might be enough.
05:21:20 <aavogt> serpentologist: the version of whatever dependency that provides the `ParseMode' is probably not specified closely enough
05:21:30 <benmachine> :t listToMaybe . reads
05:21:31 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
05:21:51 <benmachine> :t fmap fst . listToMaybe . reads
05:21:52 <lambdabot> forall a. (Read a) => String -> Maybe a
05:22:24 <Silvah> > (fst <$> listToMaybe . reads) "5" :: Maybe Int
05:22:25 <lambdabot>   Couldn't match expected type `(Data.Maybe.Maybe GHC.Types.Int, b)'
05:22:25 <lambdabot>         ...
05:22:44 <benmachine> :t \str -> do [(x,s)] <- reads str; guard (all isSpace s); return x
05:22:45 <lambdabot>     Couldn't match expected type `(a, String)'
05:22:45 <lambdabot>            against inferred type `[a1]'
05:22:45 <lambdabot>     In the pattern: [(x, s)]
05:22:56 <benmachine> :t \str -> do [(x,s)] <- return $ reads str; guard (all isSpace s); return x
05:22:57 <lambdabot> forall (m :: * -> *) a. (MonadPlus m, Read a) => String -> m a
05:24:20 <Silvah> Seems like fmap fst . listToMaybe . reads is what kuribas needs.
05:24:37 <mauke> seems unlikely
05:24:55 <kuribas> I could use a regexp to test first...
05:24:55 <benmachine> > \str -> case reads str of [(x,s)] | all isSpace s -> Just x; _ -> Nothing
05:24:56 <lambdabot>   Overlapping instances for GHC.Show.Show
05:24:56 <lambdabot>                              (GHC.B...
05:25:04 <benmachine> er wups
05:25:07 <benmachine> :t \str -> case reads str of [(x,s)] | all isSpace s -> Just x; _ -> Nothing
05:25:07 <lambdabot> forall a. (Read a) => String -> Maybe a
05:25:15 <benmachine> kuribas: regexps are evil :P
05:25:50 <kuribas> But useful :)
05:26:06 <Eduard_Munteanu> So is the dark side, but it consumes you.
05:26:21 <mauke> regexps aren't evil
05:26:31 <mauke> it's just that haskell has no good support for them
05:26:56 <Eduard_Munteanu> Mm, I never used them from Haskell, but I quickly skimmed through some API and they seemed alright.
05:27:03 <johannes2> uh oh, I just tried: cabal install -p binary and got an error:
05:27:09 <johannes2>     Could not find module `Data.Foldable':
05:27:10 <johannes2>       Perhaps you haven't installed the profiling libraries for package `base-3.0.3.1'?
05:27:12 <kuribas> mauke: Regexp support in haskell is quite ok.
05:27:14 <Eduard_Munteanu> Well, except those functions had a bit too many params.
05:27:20 <johannes2> can someone please help me with that?
05:27:26 <mauke> johannes2: why did you use -p?
05:27:33 <aavogt> johannes2: where did your ghc come from?
05:27:33 <johannes2> they said I needed...
05:27:50 <Eduard_Munteanu> (-prof)
05:27:54 <aavogt> it tends to come with profiling libraries
05:28:37 <mauke> kuribas: how do I do something like javascript's .replace() in haskell?
05:29:44 <Eduard_Munteanu> johannes2: just remove "-p" for now
05:30:16 <kuribas> mauke: I don't know javascript...
05:30:37 <confound> "foo".replace(/oo/, "aa") == "faa"
05:31:03 <benmachine> doesn't subRegex do that, or something
05:31:26 <dino-> Yes, Text.Regex.subRegex
05:31:32 <mauke> benmachine: no, subRegex takes strings
05:31:43 <Silvah> You all know, "Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems." ;)
05:32:00 <benmachine> mauke: what did you want it to take?
05:32:02 <dino-> http://hackage.haskell.org/packages/archive/regex-compat/0.92/doc/html/Text-Regex.html
05:32:04 <mauke> benmachine: a function
05:32:07 <Jonno_FTW> s/regular expressions/XML/
05:32:13 <dino-> oh, not strings
05:32:13 <mauke> obviously
05:32:14 <Jonno_FTW> now you have 3 problems
05:32:31 <Eduard_Munteanu> Divide and duplicate.
05:32:34 <mauke> also, subRegex's documentation sucks
05:32:40 <benmachine> mauke: ok I clearly don't get how .replace works
05:33:00 <Eduard_Munteanu> Banach-Tarski really applies to some fields.
05:33:34 <mauke> 'foo'.replace(/(.)\1+/g, function (m0, m1) { return m1; })
05:33:57 <benmachine> mauke: what does that do?
05:34:10 <mauke> removes repeated characters
05:34:15 <mauke> 'foo' => 'fo'
05:34:16 <Silvah> benmachine: it scares little children
05:34:19 <benmachine> Silvah: obv
05:34:46 <benmachine> mauke: I get that the regex matches repeated characters, but the function is a mystery to me
05:34:59 <mauke> the function computes the replacement text
05:35:08 <benmachine> what are the parameters?
05:35:14 <Eduard_Munteanu> Okay, I thought that was some weird reflection stuff.
05:35:15 <Silvah> \m0 m1 -> m1
05:35:24 <Eduard_Munteanu> :t snd
05:35:24 <lambdabot> forall a b. (a, b) -> b
05:35:26 <benmachine> Silvah: sure but what is the function applied to
05:35:39 <mauke> in javascript? the matched string, all capture buffers, the source string, and the offset where the match occurred
05:35:43 <mauke> IIRC
05:35:59 <benmachine> oh, so return m1 returns the capture buffer?
05:36:06 <mauke> yes
05:36:10 <benmachine> oh
05:36:19 <benmachine> how perfectly obvious and not at all confusing :P
05:36:35 <mauke> yeah, they should have used a match object with all the context information
05:37:05 <Silvah> benmachine: what did you expect from regular expressions?
05:38:02 <mauke> so ... is there any way to do this in haskell?
05:38:28 <monadic_kid> can someone explain to me in the sdl_ttf haskell bindings why the ffi function ttfCloseFontFinal is using FunPtr when it doesn't make any sense to use it there: http://hackage.haskell.org/packages/archive/SDL-ttf/0.6.1/doc/html/src/Graphics-UI-SDL-TTF-Management.html#openFont
05:39:27 <monadic_kid> okay no worries i figured it out
05:40:34 <dino-> hm, I want to make something that internally uses matchRegexAll and takes a function to operate on the result of that.
05:40:37 <monadic_kid> openFont causes seg faults even though the call was successful
05:41:18 <tomh> hey guys, is this book a must-read for haskell devs? http://www.cis.upenn.edu/~bcpierce/tapl/
05:41:32 <monadic_kid> tomh: no
05:41:42 <johannes2> @mauke it works without -p! thanks a lot everyone!
05:41:43 <lambdabot> Unknown command, try @list
05:41:57 <monadic_kid> tomh: unless you're interested in designing a programming language
05:41:58 <tomh> monadic_kid: why not?
05:42:27 <tomh> well im interested in how they are implemented so I don't like like a douche who doesn't look into stuff more indepth :)
05:43:00 <monadic_kid> tomh: it is not a must read for all haskell developers
05:43:15 <tomh> monadic_kid: is it a good book though?
05:43:18 <Skola> how well suited is Haskell for 1. text analysis 2. throwing around & processing json?
05:43:28 <monadic_kid> tomh: that book is specifically for people who are interested in designing a type system for statically typed programming language
05:43:30 <Skola> I know those are two completely different things
05:43:44 <merijn> Skola: As suited as any other languages I'd say
05:44:05 <tomh> monadic_kid: you don't recommend it to people who want to understand why certain decisions are taken when creating type systems etc?
05:44:32 <merijn> Skola: Well, depends on the sort of text analysis I guess. In some cases It might be easier to have more control over memory for that, but in general it should be fine.
05:44:35 <Skola> merijn but for things like NLP, would you suggest it?
05:44:53 <tomh> Skola: have you seen that haskell nlp web book?
05:45:05 <merijn> Skola: Natural language processing you mean? I think it'd work fairly well for that
05:45:07 <Skola> no haven't
05:45:11 <merijn> Certainly much better then C or so
05:45:11 <Skola> yes merijn, ok
05:45:35 <merijn> I think Haskell rocks for parsing things
05:45:41 <Skola> found it tomh, thanks
05:46:03 <tomh> can you pass me the link I tried finding the url too, but didn't found it yet :p
05:46:06 <monadic_kid> tomh: my point is it really depends on what you're interested in, if you're not interested in details of type theory such as myself then it is not a "must have read" for a haskeller
05:47:23 <tomh> http://nlpwp.org/book/ there it is
05:47:56 <Skola> looks good
05:48:07 <Skola> though I'm a bit spoiled with Python's NLTK
05:48:39 <tomh> feel free to do a port :)
05:49:32 <tomh> NLP is one of the areas for which I think haskell is one of the best tools for the job
05:50:57 <dino-> mauke: Maybe: subRegexFunc f = (f .) . Text.Regex.matchRegexAll
05:51:19 <dino-> :t subRegexFunc f = (f .) . Text.Regex.matchRegexAll
05:51:20 <lambdabot> parse error on input `='
05:51:30 <dino-> :t (f .) . Text.Regex.matchRegexAll
05:51:30 <lambdabot> forall b. (SimpleReflect.FromExpr b) => Regex -> String -> b
05:52:01 <dino-> f :: Maybe (String, String, String, [String]) -> c
05:53:50 <Skola> looks like a fine book tomh
05:53:52 <Skola> thanks a lot
05:54:19 <tomh> np have fun with it :)
05:58:19 <dino-> I think that matchRegexAll is the closest you can get to that amazing set of JavaScript match results without diving down into the Text.Regex guts more.
06:30:06 <merijn> :t ()
06:30:06 <lambdabot> ()
06:35:22 <aristid> merijn: did you expect something else? oO
06:36:31 <merijn> aristid: I dunno, I was looking over some MonadPlus explanation which seemed to use it in a odd context, just confirming my suspicions :p
06:37:06 <aristid> merijn: () is, like, the most boring expression ever :P
06:40:08 <DevHC> aristid: lies
06:47:23 <JOhan___> Hi, I'm about to create a tool for game selecting based on some parameters, such as number of players and leanght of the game. The code is like this now:
06:47:26 <JOhan___> type Spel = String type Langd = [Int] type Komplex = String type Spelare = [Int] type Rspelare = [Int] type Bspelare = [Int] type Databas = [(Spel, Spelare, Rspelare, Bspelare, Komplex, Langd)]  spelen :: Databas spelen= [("Bohnanza",[2..5],[4..5],[5],"1",[15..45]),("Puerto Rico",[3..5],[3..5],[3..4],"4",[45..90])]  test:: Databas-> Spelare-> [Spel] test databas x = [n | (n,s,_,_,_,_) <-databas, x `elem` [s]] 
06:48:15 <JOhan___> hmm, that was ugly, the types are: type Spel = String type Langd = [Int] type Komplex = String type Spelare = [Int] type Rspelare = [Int] type Bspelare = [Int] type Databas = [(Spel, Spelare, Rspelare, Bspelare, Komplex, Langd)]
06:48:45 <JOhan___> the database lok like this: spelen :: Databas spelen= [("Bohnanza",[2..5],[4..5],[5],"1",[15..45]),("Puerto Rico",[3..5],[3..5],[3..4],"4",[45..90])]
06:49:10 <JOhan___> and the funktion like this: test:: Databas-> Spelare-> [Spel] test databas x = [n | (n,s,_,_,_,_) <-databas, x `elem` [s]] 
06:49:53 <JOhan___> The funktion is for choosing a game based on the number of players.
06:51:12 <JOhan___> The problems I have is with the ´elem´. I can´t get it to work as I like. 
06:51:42 <maurer_1> JOhan__: 1.) Use hpaste or some other pastebin
06:52:09 <maurer_1> JOhan__: 2.) Reduce your error to a minimal situation rather than asking us to analyze a bunch of irrelevant code.
06:52:34 <JOhan___> Ok, will try this. thanks. 
06:52:38 <merijn> What is the difference between MonadPlus and Monoid?
06:52:55 <merijn> @info Monoid
06:52:55 <lambdabot> Monoid
06:53:02 <merijn> @src Monoid
06:53:02 <lambdabot> class Monoid a where
06:53:02 <lambdabot>     mempty  :: a
06:53:02 <lambdabot>     mappend :: a -> a -> a
06:53:06 <merijn> @src MonadPlus
06:53:06 <lambdabot> Source not found. You type like i drive.
06:53:48 <merijn> @src Control.Monad.MonadPlus
06:53:48 <lambdabot> Source not found. Wrong!  You cheating scum!
06:54:42 <merijn> Oh, nevermind, I see the difference I think
06:54:43 <maurer_1> merijin: First, MonadPlus is an operation on any time, inside a monad.
06:54:56 <maurer_1> err, s/time/type/
06:55:10 <merijn> For example, [] (as in the type without parameter) can be an instance of MonadPlus, but not Monoid
06:55:21 <maurer_1> And second, there's a semantic difference where MonadPlus is used for choice (e.g. look at msum on Maybe) whereas Monoid is used for combination
06:56:03 <merijn> I overlooked the part where mappend :: a -> a -> a, whereas mplus :: m a -> m a -> m a
06:56:07 <benmachine> interesting thing about MonadPlus, you can't constrain the type parameter
06:56:19 <benmachine> so you can have (Monoid a) => Monoid (Maybe a)
06:56:32 <benmachine> but you can't do that with MonadPlus - you have to just have MonadPlus Maybe
07:05:34 <hpc> @src Maybe mplus
07:05:34 <lambdabot> Nothing `mplus` ys = ys
07:05:34 <lambdabot> xs      `mplus` ys = xs
07:05:58 <hpc> neat
07:06:13 <hpc> so foldr mplus will keep trying actions from a list until one succeeds
07:06:22 <hpc> :t foldr mplus
07:06:23 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> [m a] -> m a
07:07:21 <JOhan___> Ok, I will try again :) If x is 2, I want this to find all games that has a 2 in its "Players" (whitch is a list). Right now it will only find a direct match, aka [2..5], or [2,3,4,5]. Is there a way to do this by changing what the `elem` points at? 
07:07:25 <JOhan___> http://hpaste.org/44726/game_selector
07:07:29 <benmachine> :t msum
07:07:30 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
07:07:56 <hpc> > msum [1..5]
07:07:57 <lambdabot>   No instances for (GHC.Num.Num (m a), GHC.Enum.Enum (m a))
07:07:57 <lambdabot>    arising from a...
07:08:17 <hpc> > msum [1..5] $ 6
07:08:18 <lambdabot>   No instances for (GHC.Enum.Enum (a -> b),
07:08:18 <lambdabot>                    Control.Monad....
07:08:26 <hpc> > msum [1,2,3,45] $ 6
07:08:26 <lambdabot>   No instance for (Control.Monad.MonadPlus ((->) a))
07:08:27 <lambdabot>    arising from a use of...
07:08:30 <hpc> bah
07:08:53 <benmachine> JOhan___: x can't be 2, x is a list
07:09:25 <JOhan___> banmachine, sorry, I mean [2]
07:09:29 <benmachine> JOhan___: x could be [2], but you need to explain your matching more carefully in that case - should [2,3] match [1,2]?
07:09:47 <benmachine> what does [] match?
07:11:56 * hackagebot aeson 0.3.1.0 - Fast JSON parsing and generation  http://hackage.haskell.org/package/aeson-0.3.1.0 (BryanOSullivan)
07:12:13 <JOhan___> The [2] ( in this case) is the number of players you want to be, so there will only be one number
07:12:32 <confound> then why is it a list?
07:13:36 <gwern> > 16 * 4
07:13:36 <lambdabot>   64
07:14:16 <JOhan___> becouse the players type is a list. A certain game can have say 3-5 playsers, and i want the machine to fint that game if i give it say 2. I was using a list so I could use the `elem` funtion.
07:15:00 <hpc> :t elem
07:15:01 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:15:36 <benmachine> JOhan___: so the different possible numbers of players is a list, but x shouldn't be
07:15:53 <benmachine> JOhan___: x shouldn't be of type Players
07:25:42 <JOhan___> Thats makes sense. But if i dont write the x as a list my machine fails to find anytning at all, and gets the following error: No instance for (Num Players)       arising from the literal `3' at <interactive>:1:12 
07:27:47 <confound> maybe you should hpaste your code
07:28:10 <confound> but that sounds like you are trying to find a number in a list of players, which is never going to work
07:28:40 <confound> oh, I see
07:28:51 <confound> you did hpaste it :)
07:29:44 <confound> why does your type signature have 'Players' in it?
07:31:19 <confound> obviously if you change it to not use a list, you need to change that too
07:31:28 <JOhan___> it is refering to the type I made ( type Players = [Int]) 
07:31:41 <confound> yes, I know
07:31:52 <confound> but you aren't passing in [Int], so you need to change the type signature
07:32:04 <JOhan___> I see what you mean now :) Thanks
07:32:19 <confound> also, [s] is wrong, since s is already [Int]
07:32:32 <confound> so you have been trying to do [2] `elem` [[2..5]]
07:32:37 <confound> and you want 2 `elem` [2..5]
07:33:29 <confound> that "No instance.." is not "failing to find anything", it is a type error, btw
07:33:49 <JOhan___> I works now! Thank you wery much!
07:34:37 <JOhan___> confound++karma
07:39:26 <TheZimm> So I'm a complette beginner, and I;'ve got a few q's
07:39:52 <TheZimm> in if (p h)
07:40:02 <TheZimm> what does that mean?
07:40:38 <monadic_kid> including the "in" part?
07:41:08 <TheZimm> yeah
07:41:30 <monadic_kid> in is part of a let expression
07:41:30 <TheZimm> monadic_kid this is what im looking at and trying to understand - http://d.pr/Ee1A
07:41:50 <TheZimm> i understand the first two lines
07:42:10 <TheZimm> the third kind of but not really and then im completely lost :P
07:42:31 <monadic_kid> let <binding-expression> in <expression>
07:42:51 <monadic_kid> p is a function
07:43:07 <monadic_kid> and it's being used in the if expression
07:43:23 <TheZimm> isn't p just a list?
07:43:33 <benmachine> nope
07:43:43 <benmachine> (h:t) is the list
07:44:00 <TheZimm> inst that the same as ([h,t]) ?
07:44:08 <benmachine> no
07:44:32 <benmachine> (h:t) is a list with h the first element and t the rest of the list
07:44:35 <benmachine> not t the second element
07:46:04 <TheZimm> Okay, now I'm confused as to how you're converting the () type of list to a [] type of list (sorry i forgot the actual names of them, i just know one has a constant type where the other has diffferent types)
07:46:35 <confound> calling them both lists will confuse you
07:46:42 <confound> (1,2,3) is a tuple
07:46:56 <TheZimm> tuple, ok I shall remember that now
07:47:04 <confound> it has a fixed length and its elements can have different types
07:47:13 <TheZimm> right
07:47:21 <confound> but, in this context, (h:t) is pattern matching, not tuple construction
07:47:30 <benmachine> basically, there is an empty list, and you can make a longer list by joining a new element on to the front of another list
07:47:52 <benmachine> but there's also a pretty way of making lists using square brackets
07:48:13 <TheZimm> confound how do you differentiate the two?
07:48:17 <benmachine> if xs is a list, then x:xs is a bigger list, xs with x on the beginning
07:48:22 <confound> tuples have commas
07:48:23 <TheZimm> benmachine that's what the snippet is?
07:48:27 <TheZimm> ahh ok
07:48:36 <TheZimm> what if you ahave a tuple with a list in it?
07:48:44 <benmachine> well, tuples have commas and parentheses around them
07:48:45 <TheZimm> ahh nvm
07:48:51 <benmachine> (a,b)
07:48:54 <TheZimm> yeah
07:48:55 <Twey> ([a, b, c], [d, e, f])
07:49:08 <TheZimm> i was thinking of the a:b:[] syntax
07:49:10 <benmachine> the pretty way of making lists is [a,b,c] and that means a:b:c:[]
07:49:12 <confound> benmachine: yes, but he was asking about vs. pattern matching
07:49:16 <TheZimm> but you'd have :[] at the end
07:49:24 <benmachine> yeah
07:49:34 <Twey> ((a, b) : (c, d) : [], (f, g) : (h, i) : [])
07:49:38 <confound> TheZimm: think of (h:t) as being the same kind of thing as matching e.g. (Just x)
07:50:04 <benmachine> Twey: what do you have against e :o
07:50:14 <confound> [] ate it
07:50:16 * TheZimm doesnt know what just means :P
07:50:19 <Twey> It kicked my dog
07:50:25 <monadic_kid> :[]
07:50:26 <confound> TheZimm: ok, nevermind then
07:50:32 <benmachine> well, your dog was probably being rude to it
07:50:38 <TheZimm> lmao
07:50:43 <TheZimm> aight so
07:51:18 <benmachine> TheZimm: basically if you have a list, say, [1,2,3,4], then that's the same as 1:[2,3,4], so if you match that against (h:t) then h is set to 1 and t is set to [2,3,4]
07:51:39 <TheZimm> ahh nice!
07:51:48 <TheZimm> and if you do (h:t:y) ?
07:51:58 <TheZimm> is it 1 2 and [3,4] ?
07:52:10 <confound> yes
07:52:19 <confound> except t is confusing then because in the original it meant 'tail' :)
07:52:34 <monadic_kid> TheZimm: there is lambdabot on here, you can type in expressions
07:52:49 <TheZimm> well i have ghci
07:52:54 <TheZimm> so i just use that
07:53:16 <TheZimm> what if you wanted to get just the last element?
07:53:26 <TheZimm> and a list of the first
07:53:33 <benmachine> you can't do that as easily
07:53:45 <TheZimm> ahh ok
07:53:47 <benmachine> haskell lists are naturally more easy to play with the front than the back
07:53:52 <benmachine> +grammar
07:53:56 <TheZimm> i see
07:54:03 <confound> insert salacious joke here
07:54:08 <TheZimm> :P
07:54:08 <benmachine> :P
07:54:22 <TheZimm> filter p [] = [] defines the function of p, right?
07:54:30 <benmachine> nope
07:54:31 <confound> it defines one case of it
07:54:34 <confound> er, no
07:54:35 <benmachine> it's defining filter
07:54:41 <benmachine> p is a parameter to filter
07:54:44 * confound typed too fast
07:54:56 <confound> > init [1,2,3,4]
07:54:57 <lambdabot>   [1,2,3]
07:55:02 <confound> > last [1,2,3,4]
07:55:03 <lambdabot>   4
07:55:13 <confound> (inverse of head/tail)
07:55:29 <TheZimm> ahh ok
07:55:36 <TheZimm> im coming from c, btw :P
07:55:39 <TheZimm> well obj c
07:55:46 <benmachine> init/last are not as natural as head/tail though
07:56:04 <TheZimm> i see
07:56:06 <confound> true
07:56:06 <TheZimm> so
07:56:15 <TheZimm> filter p []
07:56:21 <TheZimm> wouldnt that mean theres two args?
07:56:24 <benmachine> yes
07:56:30 <benmachine> :t filte
07:56:31 <lambdabot> Not in scope: `filte'
07:56:31 <benmachine> er
07:56:32 * TheZimm finally got something righ
07:56:34 <benmachine> :t filter
07:56:34 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:57:00 <monadic_kid> just ignore the forall for now :P
07:57:19 <TheZimm> im just as confused to the function passing to another function thing :P
07:57:23 * rothwell binds the monadic_kid
07:57:29 <rothwell> sorry... couldn't help myself
07:58:20 * monadic_kid is raging from sdl_ttf openFont causing seg faults on exit
07:59:16 <benmachine> monadic_kid: if it only happens on exit does it matter? :P
07:59:21 <TheZimm> so, how come the filter is defined twice?
07:59:32 <monadic_kid> benmachine: matter because i'm trying to profile code!
07:59:38 <benmachine> monadic_kid: ah :(
07:59:39 <confound> it isn't
07:59:45 <benmachine> TheZimm: it does different things depending on what the list is
07:59:46 <confound> it's defined once, with pattern matching
07:59:51 <benmachine> specifically whether it is empty or not
07:59:58 <TheZimm> ohhhhh
08:00:08 <TheZimm> so if its empty then do this
08:00:15 <TheZimm> if it has a head and a tail do this?
08:00:39 <confound> right
08:00:52 * TheZimm ++
08:00:59 <TheZimm> so now sec
08:01:10 <TheZimm> does h:t automatically mean head and tail?
08:01:38 <confound> can you be more specific?
08:01:42 <hpc> TheZimm: h:t indeed means head and tail; (h:t) :: [a], h :: a, t :: [a]
08:01:59 <hpc> so [1,2,3] = (h:t), h = 1, t = [2,3]
08:02:04 <sonoflilit> how do I remove duplicates from a list?
08:02:09 <confound> nub
08:02:12 <hpc> @src nub
08:02:12 <lambdabot> nub = nubBy (==)
08:02:18 <sonoflilit> thanks
08:02:19 <hpc> bleh
08:02:42 <TheZimm> i have gotta say, this room is the best irc room ive ever been in
08:02:48 <TheZimm> thanks for everything guys!
08:02:54 <hpc> TheZimm: it totally is :D
08:03:26 <TheZimm> >init [1,2,3]
08:03:32 <TheZimm> erm
08:03:37 <TheZimm> how does that work?
08:03:44 <TheZimm> > init [1,2,3]
08:03:45 <lambdabot>   [1,2]
08:03:51 <TheZimm> there we go
08:04:07 <TheZimm> uhm what was the last element function?
08:04:18 <hpc> > last [1..5]
08:04:18 <lambdabot>   5
08:04:24 <TheZimm> ahh nice
08:04:32 <TheZimm> and 1..5 means 1,2,3,4,5 right?
08:04:37 <benmachine> right
08:04:38 <benmachine> btw
08:04:47 <benmachine> the head/init/tail/last functions don't work on empty lists
08:04:47 <hpc> TheZimm: yep; it works for any enum type
08:04:49 <benmachine> be careful about that
08:04:54 <hpc> > [False..]
08:04:55 <lambdabot>   <no location info>: parse error on input `]'
08:04:59 <hpc> > [False..True]
08:05:00 <lambdabot>   A section must be enclosed in parentheses thus: (`False..` True)Not in scop...
08:05:01 <benmachine> > [False ..]
08:05:02 <lambdabot>   [False,True]
08:05:04 <benmachine> :P
08:05:07 <hpc> :P
08:05:47 <TheZimm> aight cool!
08:05:58 <TheZimm> i love how you can name variables like t'
08:06:15 <hpc> > conanO'Brian
08:06:16 <lambdabot>   Not in scope: `conanO'Brian'
08:06:18 <hpc> :D
08:06:36 <TheZimm> hahaha
08:06:40 <TheZimm> now if (p h)
08:06:43 <TheZimm> whats that mean
08:06:46 <benmachine> fun fact: in PHP, non-breaking space is a valid identifier character wooo
08:06:46 <spirit> i'm using leksah and i'd like to add a new line to some show code. leksah turns '\n' into 'lambdan' -- how would i prevent that?
08:06:55 <hpc> > if False then 1 else 0
08:06:56 <lambdabot>   0
08:07:00 <hpc> > if True then 1 else 0
08:07:01 <lambdabot>   1
08:07:46 <TheZimm> but whats the (p h) mean?
08:07:46 <hpc> "if" is syntax, not a function, but lambdabot has if'
08:08:07 <TheZimm> i understand the if then else, not the (p h) :P
08:08:09 <hpc> TheZimm: p is some function :: Something -> Bool
08:08:15 <hpc> h :: Something
08:08:16 <sipa> TheZimm: the function p applied to h
08:08:18 <hpc> so p h :: Bool
08:08:29 <sipa> what is written p(h) in many other languages
08:08:47 <TheZimm> ahhh ok thx sipa :D
08:08:48 <hpc> in haskell, function application is just whitespace
08:08:53 <TheZimm> ya
08:08:55 <TheZimm> i can see
08:09:16 <hpc> if' p t f = if p then t else f -- <-- this is a convenience function lambdabot has
08:09:17 <TheZimm> OMG ITS ALL MAKING SENSE NO
08:09:18 <TheZimm> W
08:09:19 <hpc> :t if'
08:09:19 <lambdabot> Not in scope: `if''
08:09:26 <hpc> or used to have..
08:09:30 <monadic_kid> :t if_
08:09:31 <lambdabot> Not in scope: `if_'
08:09:42 <TheZimm> :P
08:09:46 <hpc> and my favorite, t ?? f = \p -> if p then t else f
08:09:49 <sipa> @let if' p t f = if p then t else f
08:09:51 <lambdabot>  Defined.
08:09:56 <hpc> (??) :: a -> a -> Bool -> a
08:09:59 <hpc> :t if'
08:09:59 <lambdabot> forall t. Bool -> t -> t -> t
08:10:25 <rostayob> how can I get a simple timestamp from UTCTime? and vice versa?
08:10:38 <hpc> @hoogle UTCTime
08:10:38 <lambdabot> Data.Time.Clock data UTCTime
08:10:38 <lambdabot> Data.Time.Clock UTCTime :: Day -> DiffTime -> UTCTime
08:10:38 <lambdabot> Data.Time.Clock.POSIX utcTimeToPOSIXSeconds :: UTCTime -> POSIXTime
08:10:39 <TheZimm> aight so filter goes
08:10:48 <TheZimm> filter function list
08:10:49 <TheZimm> :D
08:10:58 <TheZimm> :t filter
08:10:59 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:11:08 <hpc> > filter (== 5) [1..10]
08:11:09 <lambdabot>   [5]
08:11:18 <TheZimm> :D
08:11:26 <hpc> trick to filter is the function decides what to KEEP, not what to take away
08:11:37 <rostayob> hpc: thanks
08:11:38 <TheZimm> ahh nice
08:11:38 * hpc has forgotten that every time he has used filter
08:11:45 <confound> filter (>= 5) [1..10]
08:11:49 <confound> > filter (>= 5) [1..10]
08:11:50 <lambdabot>   [5,6,7,8,9,10]
08:12:04 <hpc> > filter (% 2) [1..]
08:12:05 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
08:12:05 <lambdabot>         against inferred type ...
08:12:07 <TheZimm> and self defined functions must be in ()?
08:12:10 <hpc> > filter (% 2) [1 ..]
08:12:11 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
08:12:11 <lambdabot>         against inferred type ...
08:12:26 <hpc> > filter ((== 0) . (% 2)) [1 ..]
08:12:30 <lambdabot>   mueval-core: Time limit exceeded
08:12:33 <confound> TheZimm: no
08:12:39 <hpc> > filter even [1 ..]
08:12:40 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
08:12:43 <robertosucks> [[1,2],[8,11,5],[4,5]] why do we receive an error from this expression?
08:13:09 <hpc> > [[1,2],[8,11,5],[4,5]]
08:13:10 <lambdabot>   [[1,2],[8,11,5],[4,5]]
08:13:15 <confound> you don't, hth
08:13:16 <TheZimm> what does the . mean in haskell?
08:13:26 <hpc> TheZimm: (f . g) x = f (g x)
08:13:31 <hpc> TheZimm: function composition
08:13:51 <robertosucks> hpc, but in the learn haskell for a great good, it says that it will return an error
08:13:53 <TheZimm> uhh
08:14:01 <TheZimm> can you explain more, im confused by that :P
08:14:10 <confound> then you misread it robertosucks 
08:14:27 <confound> got a link?
08:15:16 <robertosucks> then let me reread it
08:15:22 <parcs> TheZimm: f . g is the same as \x -> f (g x)
08:15:57 <TheZimm> parcs i have no idea what \x is or means :P
08:16:05 <rostayob> hpc: POSIXTime doesn't seem to be Int
08:16:11 * TheZimm told yall, hes a straight up noob to haskell
08:16:18 <parcs> @where lyah
08:16:18 <lambdabot> http://www.learnyouahaskell.com/
08:16:23 <parcs> TheZimm: ^
08:16:29 <rostayob> hpc: oh right, it's an instance of num..
08:16:47 <robertosucks> confound, http://pastebin.com/KuPkyu40
08:19:05 <confound> robertosucks: [] and () are not the same
08:19:14 <robertosucks> yes i know
08:19:17 <robertosucks> [] is a list
08:19:22 <robertosucks> and () is a tuple
08:19:22 <hpc> TheZimm: \x -> blah is an unnamed function, that takes a parameter x and does blah
08:19:28 <confound> you asked about a list of list, not a list of tuples
08:19:51 <TheZimm> ahh ok
08:20:03 <TheZimm> parcs thats an awesome tut, ive been looking around for a good one
08:20:03 <confound> a list of differently-sized tuples would be an error because (Int, Int, Int) is not the same type as (Int, Int), so they can't be in the same list
08:20:05 <TheZimm> thanks!
08:20:18 <rostayob> I still can't get a simple Int timestamp
08:20:32 <hpc> TheZimm: it is also a book!
08:20:32 <TheZimm> "Haskell was made by some really smart guys (with PhDs). "
08:20:33 <TheZimm> :D
08:20:37 <TheZimm> oh reallya?
08:20:37 <ukl> Hello #haskell.  I'm confuzzled about this: http://hpaste.org/44731/ -- trying to install (that is, to ./configure) haskell platform on freebsd
08:20:39 <TheZimm> i shall get it
08:20:42 <robertosucks> confound, oh ok, but ghc doenst return any error?
08:20:52 <ukl> it doesn't find my GL/gl.h although it's there -- any hints?
08:21:19 <ukl> (I know, this is somehow rather autoconf specific, but I thought I start looking for help around here)
08:21:47 <ukl> ghc is ghc 7.0.2 binary distribution for freebsd x86_64
08:22:23 <c_wraith> there's a binary distribution for bsd?
08:22:36 <Zao> c_wraith: Usually, yes.
08:22:45 <c_wraith> shows how much attention I pay
08:22:52 <Zao> It's different from the one in ports, too.
08:23:06 <hpc> cale says the only people who should ever compile ghc are devs
08:23:07 <Zao> http://haskell.org/ghc/download_ghc_7_0_2#freebsd_x86_64
08:23:20 <benmachine> hpc: and people who have all the wrong libraries :(
08:23:30 <benmachine> well actually I could get it from my system package manager
08:23:33 <benmachine> but whatever
08:24:47 <benmachine> what. ev. er.
08:25:07 <confound> robertosucks: what do you mean?
08:25:20 <confound> robertosucks: ghc doesn't for the list of lists, because it's not a type error. that's what you asked about before.
08:25:39 <confound> robertosucks: it does for the list of differently-sized tuples.
08:25:49 <robertosucks> humm ok
08:31:02 <ukl> hmm, ac_fn_c_check_header_mongrel doesnt add -I/usr/local/include to the "gcc -E conftest.c" line; therefore gcc -E fails even if I use './configure --includedir=/usr/local/include' (which should be default if I don't force a prefix, anyways, right?)
08:35:09 <robertosucks> confound, ok thanks
08:35:11 <TheZimm> 1. i love this language 2. i love this room
08:35:16 <TheZimm> thanks for everything guys!
08:35:28 <ukl> sorry for the noise, 'CPPFLAGS=-I/usr/local/include CFLAGS=-I/usr/local/include ./configure' got me slightly further
08:38:01 <rostayob> hpc: maybe it's me, but I still haven't found I way from UTCTime to INt
08:38:03 <rostayob> *Int
08:38:57 <ukl> just for reference: 'CPPFLAGS=-I/usr/local/include CFLAGS=-I/usr/local/include LDFLAGS=-L/usr/local/lib ./configure' is needed to ./configure haskell platform on FreeBSD, _regardless_ of any --prefix or --includedir arguments.
08:42:31 <confound> .w 21
08:50:48 <tswett> Does Simon Peyton-Jones come here?
08:52:07 <monadic_kid> i've known him to be here but Don comes here
08:53:48 <monadic_kid> I mean i've known him to be here
08:54:00 <monadic_kid> arrrrgh
08:54:02 <monadic_kid> i mean never!
08:54:08 <monadic_kid> I've never known him
08:54:40 <hpc> alas poor yorrick, i knew him horatio
08:55:55 <hpc> ha/1
08:56:12 <hpc> ... android, your keyboard sucks
08:56:31 <monochrom> small keyboards can't be helped
08:56:40 <sipa> hpc: install another one :)
08:56:48 <ukl> another reference: you need the devel/hs-happy port (which thankfully is available as a binary) to build happy in haskell-platform
08:57:04 * boegel tries again
08:57:15 <boegel> anyone know who maintain Haskell's mail server?
08:59:04 <hpc> so who came up with the idea to nake ghc "Glorious Glaskow Haskell Compilation System"?
08:59:13 <hpc> *name
08:59:27 <Heffalump> boegel: I think the problem is there's a general lack of sysadmin resource at the moment.
08:59:33 <merijn> hpc: I don't know, but I like him already
08:59:37 <Heffalump> but you could email the haskell-infrastructure list
08:59:44 <hpc> merijn: same
08:59:46 <boegel> Heffalump: hmmk, thx
09:00:40 <boegel> Heffalump: list, or channel?
09:01:19 <Heffalump> list. But I think you might have to join first.
09:01:41 <Heffalump> http://community.galois.com/mailman/listinfo/haskell-infrastructure
09:03:18 <chris_> Me is learning haskell!
09:03:54 <c_wraith> haskell's fun
09:04:08 <hpc> Guest48749: get to a bomb shelter, because your mind is going to be blown!
09:04:15 <Guest48749> Looks like it is
09:04:29 <Guest48749> even better than brainfuck
09:04:29 <merijn> Once the alien brain parasites are done chewing through your skull and reach your brain all the pain of Haskell goes away *twitch*
09:05:56 <c_wraith> Hmm...  I'm finding myself drawn to typeclasses to solve this again.  I *like* having the full behavior specified by the type.
09:06:58 <confound> solve what
09:07:20 <c_wraith> oh, design issues with the upcoming rework of one of my libraries on hackage
09:07:25 <confound> o
09:13:07 <hvr_> I have a "template" for haskell code, where I simply want to substitute some symbol parts; I can express this with CPP macros and the '##' concatentation operator; is there an easy way to accomplish the same w/ template-haskell?
09:13:34 <hvr_> (and keeping the actual haskell-code template readable?)
09:14:15 <c_wraith> hvr_: you should be able to do it with quote syntax fairly easily
09:14:24 <dons> hvr_: using the quasi quote syntax
09:14:59 <c_wraith> dons: quasi-quote isn't the same as quote.  quotes are haskell input...  quasi-quotes are arbitrary input.  At least, if I understand those properly. :)
09:15:01 <kmc> except that quoting/splicing is only half-implemented :/
09:15:09 <merijn> :t liftIO
09:15:10 <lambdabot>     Ambiguous occurrence `liftIO'
09:15:10 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
09:15:10 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
09:15:23 <merijn> :t Control.Monad.Logic.liftIO
09:15:24 <lambdabot> forall a (m :: * -> *). (Control.Monad.Logic.MonadIO m) => IO a -> m a
09:15:34 <hvr_> well, I looked at haskell wiki's QQ entry, but it seemed to be geared towards EDSLs
09:15:45 <c_wraith> yes, look at the Quote entry
09:15:54 <kmc> c_wraith, but (to confuse matters) what TH calls "quotation" is what Scheme et al call "quasiquotation"
09:16:06 <c_wraith> kmc: ah, that makes sense.  as to why there's so much confusion
09:16:10 <kmc> yeah
09:16:19 <kmc> it's "quasi" because you can un-quote (i.e. splice) inside it
09:16:45 <c_wraith> hvr_: [| <valid haskell code here> |] :: Q Exp
09:16:46 <kmc> `(x ,y z) ≡ (quasiquote x (unquote y) z)
09:16:59 <hvr_> c_wraith: ...where do I find the "Quote entry"? :)
09:17:17 <c_wraith> hvr_: and you can splice into quotes with the standard TH splicing mechanism, $foo
09:17:17 <merijn> Any tutorials/explanations for the working of liftIO?
09:17:31 <kmc> TH is a huge pain hvr_ and i wouldn't blame you for using something else
09:17:53 <c_wraith> hvr_: http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html
09:18:17 <c_wraith> hvr_: see the section on syntax.  It doesn't explain why you'd want to use them, but it does explain what the options are
09:18:41 <kmc> merijn, it lets you run an IO action in any monad which is an instance of MonadIO
09:18:55 <c_wraith> hvr_: it seems the manual calls them "expression quotations", regardless of the type
09:19:15 <merijn> kmc: Yeah, I gathered that, but what are the rules for making something an instance of MonadIO?
09:19:24 <kmc> the implementation is different for each monad
09:19:58 <kmc> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Control-Monad-IO-Class.html
09:20:02 <kmc> there's two laws stated there
09:23:40 <dons> c_wraith: oh good point. something simpler than quasi might be enough
09:23:50 <kmc> so ((a → IO b) ↦ (a → M b), f ↦ liftIO . f) acts like a functor from (Kleisli IO) to (Kleisli M)
09:25:09 * kmc deeply regrets not using ∘ there
09:26:55 <Jafet> Clearly you need to integrate your irc client with lhs2tex
09:28:36 <hvr_> kmc: well, CPP isn't that much better; as I have to use the { ; } notation in CPP macros  :-/
09:32:14 <Heffalump> is there documentation anywhere of the new cabal test support?
09:33:33 <hvr_> Heffalump: http://www.haskell.org/cabal/release/cabal-1.10.1.0/doc/users-guide/#test-suites
09:33:57 <hvr_> (that's the only I know of so far)
09:35:31 <c_wraith> hvr, can you give an example of the kind of code you want to substitute something into, and what kind of thing you want to substitute in?
09:36:07 <c_wraith> I feel like I should be a lot more helpful than I currently am :)
09:36:20 <TheZimm> is anyone familiar with limits (in the calculus world)?
09:36:39 <TheZimm> and if anyone is, do they know of any way to use them in haskell?
09:36:45 <chessguy> i'm trying to grok this article on infinite exhaustive search. what do the examples f, g, and h represent? http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
09:37:46 <mreh> @pl \(x, y) -> liftM (,y) . return $ x
09:37:47 <lambdabot> (line 1, column 19):
09:37:47 <lambdabot> unexpected ","
09:37:47 <lambdabot> expecting lambda abstraction or expression
09:37:57 <mreh> you what
09:38:14 <ceii> mreh: TupleSections is an extension
09:38:26 <mreh> @pl \(x, y) -> liftM (\x -> (x,y)) . return $ x
09:38:27 <lambdabot> uncurry (flip ((return .) . flip (,)))
09:38:37 <mreh> I forget myself
09:39:08 <TheZimm> hmm i shall ponder this
09:39:15 <TheZimm> later room, thanks for everything!
09:39:18 <hvr_> c_wraith: sure, gimme a few minutes
09:40:00 <sonoflilit> chessguy: I remember reading that and understanding, let me just remember
09:40:56 <merijn> Anyone got a good Iteratee/Enumerator/Enumeratee guide for my? I was reading one from the Yesod blog, but I lost track somewhere midway, and I don't even dare look at Oleg's stuff
09:41:59 <hvr_> c_wraith: http://hpaste.org/44732/macro_expansion
09:42:04 <Anpheus> I like this one:
09:42:15 <Anpheus> @pl f (x:xs) = x `seq` (x : f xs)
09:42:16 <lambdabot> f = fix ((`ap` tail) . (. head) . liftM2 (.) seq . flip ((.) . (:)))
09:42:29 <hvr_> c_wraith: it doesn't work as-is, since ghc's CPP doesn't seem to let me use '##'
09:43:15 <confound> merijn: when you find one, I would like it too :)
09:43:18 <c_wraith> crap, I don't know CPP that well.
09:43:46 <c_wraith> ## is...  what, exactly?
09:43:54 <merijn> confound: http://docs.yesodweb.com/blog/enumerators-tutorial-part-1 was okay-ish, but due to the amount of code samples I lost track of the high level overview
09:43:58 <merijn> c_wraith: concatenation
09:44:02 <hvr_> c_wraith: concatenates symbols
09:44:23 <hvr_> c_wraith: i.e. where "foo ## HNAME ## bar" becomes "fooStopSetbar"
09:44:28 <hvr_> if HNAME is bound to StopSet
09:44:31 <c_wraith> ok
09:47:19 <mreh> man debugging code written for some generic monad is always difficult
09:47:40 <mreh> type system always assumes I want the list monad when I'm working with a list
09:47:58 <mreh> because I've bound a value instead of putting it in a let clause
09:48:29 <hvr_> c_wraith: the proper term for '##' seems to be "token pasting"
09:48:55 <c_wraith> hvr_: thanks.  Gimme a few minutes to put this all together
09:50:01 <kmc> hvr_, yeah, CPP also sucks.  my views on this are at http://mainisusuallyafunction.blogspot.com/2010/10/verbose-show-and-missing-preprocessor.html
09:53:44 <hvr_> kmc: too bad that paper from 99 seems to have been forgotten
09:55:56 <sonoflilit> chessguy: I gave up. I can answer this but not from the PoV of grokking it
09:56:06 <sonoflilit> not with the time I have to think now
09:56:14 <chessguy> sonoflilit, a guess woiuld suffice
09:56:20 <chessguy> give or take an i
09:57:38 <sonoflilit> well, they are functions from an infinite sequence of bits to a number (specifically, 0 or 1, but there is no need for it to be that way in general)
09:57:43 * hackagebot http-enumerator 0.4.0.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.4.0.1 (MichaelSnoyman)
09:58:03 <sonoflilit> f and h are the same function written in two ways, g is different
09:59:02 <sonoflilit> he claims that he can determine equality of all such functions by some sort of walking their algorithms
09:59:29 <c_wraith> hvr_: http://hpaste.org/paste/44732/macro_expansion_annotation#p44733   It's not a complete copy, it's missing imports, it hasn't been tested...  But the idea is right
10:00:15 <c_wraith> hvr_: the [d| .. |] thing introduces a quotation with a type of Q [Dec]
10:01:04 <c_wraith> hvr_: the splices into quotation are all just based on getting the types right, based on the stuff in Language.Haskell.TH
10:01:08 <hvr_> c_wraith: thx, looks less wores than expected :-)
10:01:37 <chessguy> sonoflilit, their algorithms?
10:01:58 <sonoflilit> their definitions
10:02:29 <hvr_> c_wraith: is there an easy way to dump the generated haskell code pretty-printed?
10:02:44 <Anpheus> What *nix distributions do you guys use or prefer for haskelling?
10:03:00 <c_wraith> hvr_: pretty-printed?  Don't know about that.  but you can use -ddump-splices to at least get *some* representation of what's generated
10:03:06 <roconnor> Anpheus: NixOS
10:03:26 <btutt> OS X 
10:04:37 <Anpheus> Anyone else?
10:04:38 <c_wraith> hvr_: also, you can put the second instance declaration inside the same [d| ... |] quotation.  Wasn't sure if that's obvious or not, but that's why it has the type Q [Dec] instead of Q Dec
10:04:40 <iago> Anpheus, I don't know what will make a distribution to be better for haskelling.
10:05:01 <Anpheus> Well for example, Ubuntu usually lags pretty far behind on haskell platform, and cabal install can have issues on it
10:05:12 <Anpheus> I had some pretty ridiculous issues trying to get just Leksah to build reproducibly
10:05:14 <roconnor> iago: referentially transparent software updates
10:05:25 <hvr_> c_wraith: now the only part I'm not sure yet is how to instanciate the the tample
10:05:28 <hvr_> template
10:05:48 <iago> roconnor, ok, and how many headaches comes with it due its unstable state ?
10:05:49 <c_wraith> hvr_: what line of your paste was that?
10:05:54 <hvr_> c_wraith: last one
10:05:58 <c_wraith> oh, ok
10:06:11 <monochrom> I use ubuntu and follow http://www.vex.net/~trebla/haskell/haskell-platform.xhtml (of course, I wrote it)
10:06:17 <roconnor> iago: huh?  Referentally transparent updates eliminates the headaches due to unstable state
10:06:21 <hvr_> c_wraith: do I have to split into two .hs files? 
10:06:49 <c_wraith> at the top level in the file you want to put the instance in (which, due to TH's stage restrictions, can't be the same one setDefinition is defined in), you just put $(setDefinition "foo" "Foo" "ff") at the top level
10:06:57 <roconnor> iago: updates are not done in place in NixOS
10:07:05 <c_wraith> hvr_: yeah, it will need to be two .hs files, just because of the limitations of TH
10:07:09 <iago> Anpheus, well, I use Debian and it is ok. Personally I manually install GHC, cabal-install through apt, and then everything else through cabal... so I don't see a big influence of Debian here
10:07:41 <monochrom> until you are bit by a cabal-install bug in an old version
10:07:41 <c_wraith> hvr_: It's not an intrinsic limitation on the concept, but it makes it way easier to implement, and no one's complained enough about it to motivate changing it...  Or provided an implementation.
10:07:42 <hvr_> c_wraith: well, thanks again; now I seem to start understanding how to use TH/QQ instead of CPP
10:08:04 <iago> roconnor, NixOS is itself unstable
10:08:55 <roconnor> iago: in what way?
10:09:32 <aavogt> roconnor: does nixos still have the situation where there is a proliferation of ways to write the scripts for packages
10:09:47 <aavogt> derivations or what they are called
10:10:19 <roconnor> aavogt: aavogt what do you mean by proliferation of ways?
10:10:22 <iago> roconnor, NixOS website raise several warnings (it is a research project, it is not for production, etc etc)
10:11:24 <roconnor> iago: ya.  It kinda annoying that they do that.  I think the concerns are now overstated
10:11:30 <aavogt> roconnor: like 3-4 different styles are in the svn, so it's sort of raises the barrier to entry since you have to figure out which style is more appropriate
10:12:00 <roconnor> iago: I've been running for it about 16 months
10:12:15 <roconnor> aavogt: in principle there could be multiple styles, at the moment there is only one in use.
10:13:39 <roconnor> aavogt: in principle users don't need to package there own software.  In practice it seems each new user wants a few pieces of software that isn't packaged yet.
10:14:09 <aavogt> yes, it doesn't have enough users yet
10:14:44 <roconnor> still, I think the advatages of NixOS even now outweight the disadvantages due to lack of users.
10:14:56 <kmc> chessguy, sonoflilit you're talking about decidable equality for ((Integer -> Bool) -> t)?
10:15:03 <kmc> i *think* i can explain how that works
10:15:40 <iago> roconnor, I would prefer if they integrate the interesting thing (the package manager) into Debian
10:15:57 <roconnor> iago: I don't see how that is possible.
10:16:21 <roconnor> of course you can use nix right now under debian
10:16:33 <iago> I don't know if is it possible
10:17:35 <roconnor> I think package management is one of the most sigificant part of a distribution.
10:17:38 <chessguy> kmc, i was trying to grok http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
10:17:47 <kmc> yes
10:18:04 <iago> I'm just thinking in provide the same packages, the same installer, etc. just replacing the package manager; but it is true that I expect lot of stuff to be very apt-specific
10:18:24 <monochrom> aka obviously possible programs with impossible-sounding names
10:18:51 <roconnor> kmc: I would like to hear your explaination
10:18:57 <sonoflilit> me too
10:19:26 <roconnor> I only understand that topologically it must work, but I have no operational intuition for it.
10:19:31 <chessguy> kmc, what do f, g, and h represent there? search functions for integers that might be members of the cantor set?
10:19:31 <kmc> well it's not all functions of type ((Integer -> Bool) -> T), just computable ones
10:20:31 <kmc> a computable function of type ((Integer → Bool) → T) gets an argument (f :: Integer → Bool) and has to return within finite time
10:20:40 <kmc> which means it will only call f at finitely many Integer inputs
10:20:58 <mwc> Is trac.haskell.org still getting hammered because of the platform release?
10:21:20 <kmc> which means you can represent a value of type ((Integer → Bool) → T) as a binary tree with T's at the leaves and interior nodes labeled with Integers
10:21:31 <kmc> where you split on which Bool is returned by f
10:21:51 <kmc> and these trees have finite size by assumption of computability
10:22:29 <kmc> and we have (Eq T) so we can compare two such trees for equality
10:22:32 <kmc> □
10:22:39 <roconnor> kmc: such a representation isn't unique
10:22:44 <roconnor> kmc: though there is a canonical choice
10:22:56 <kmc> how so?
10:23:15 <roconnor> (leaf x) and split (leaf x) (leaf x) represent the same function
10:23:24 <kmc> mm, true
10:23:49 <roconnor> and it is unclear that such a (canoncial) tree is computatble from the functional input
10:24:04 <roconnor> (sorry to give you a hard time)
10:24:07 <kmc> i think in another post the author explicitly gives a function to build these trees
10:24:13 <roconnor> yes
10:24:28 <kmc> if you build a tree from the function, can't you canonicalize it after the fact?
10:25:27 <roconnor> kmc: in a language such as ocaml, it is pretty easy to build this function since you have intensional access to the input functiona. Then you could canonicalize it afterwards.
10:25:36 <roconnor> kmc: but in Haskell it is different.
10:25:38 <kmc> what intensional access do you have?
10:25:42 <roconnor> one sec
10:27:05 <roconnor> kmc: in ocaml you can compute the so called "intensional modulus of continuity" which in this case is the largest value that the functioncal calls it's input on.
10:27:17 <roconnor> kmc: this is the bound that you were refering to
10:27:46 <roconnor> kmc: however due to the extensional referential transparency in Haskell, you can only comput the "extensional modulus of continutity" of the input functional
10:28:13 <roconnor> kmc: this is the largest value that the functional calls on that makes a difference to the output, and is in general smaller than the intensional modulus.
10:28:22 <ddarius> @google sequentially realizable functionals citeseer
10:28:24 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary;jsessionid=AB2BD70E4136702384099DF13AD5896D?doi=10.1.1.163.609
10:29:13 <roconnor> kmc: because if in Haskell you pass to extensionally equal functionals as inputs, the output has to be the same.
10:29:25 * hpc doesn't understand half the terminology in this conversation
10:29:27 <kmc> yeah
10:29:28 <roconnor> (possibly modulo seq nonsense)
10:30:37 <roconnor> kmc: so haskell cannot build a tree that produces splits upto the intensional modulus of continuity, like you'd be inclined to implement in ocaml.
10:30:59 <roconnor> kmc: doing so would violate Haskell's referential transparency.
10:31:28 <kmc> yeah, i see
10:31:29 <kmc> interesting
10:31:36 <roconnor> kmc: yet, somehow, haskell is able to build the extensional tree which is the canonical choice
10:31:47 <kmc> how's that?
10:31:59 <roconnor> kmc: magic!
10:32:07 <roconnor> kmc: actually that is what I was hoping you would explain.
10:32:11 <kmc> aww
10:32:12 <kmc> sorry
10:33:20 <hpc> can someone link me to something that will help me understand what you all are saying?
10:33:31 <roconnor> I mean, operationally it seems that it must be computing upto the intensional modulus and then detecting that two branches are equal and identifying them before building the tree.
10:34:17 <roconnor> and somehow the haskell language conspires to (1) make this possible and (2) force you to only output results that depend on the extensional behaviour of the functional
10:34:53 <sonoflilit> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
10:35:44 <hpc> was reading that before, and most of it is over my head
10:36:07 <roconnor> hpc: I'm not sure anyone here fully understands it.
10:39:33 <hpc> current vague picture of what the code does: take an arbitrary Nat -> Bool and see if it is True for all n :: Nat
10:39:46 <hpc> (more or less arbitrary)
10:40:30 <roconnor> hpc: nope
10:40:32 <Anpheus> someone should go back in time
10:40:38 <Anpheus> and let Andrew Wiles know about this impossible haskell :D
10:41:08 <roconnor> hpc: take an arbitrary (total) (Nat -> Bool) -> Bool and see if it is True for all f :: Nat -> Bool.
10:41:29 <hpc> whoa
10:41:40 <hpc> that's... even scarier
10:41:49 <roconnor> hpc: turns out it is easier.
10:41:55 <hpc> wouldn't it derp on (const False) though?
10:42:02 <roconnor> nope
10:42:04 <hpc> or something
10:42:09 <roconnor> @bot
10:42:10 <lambdabot> :)
10:42:10 <hpc> oh nvm
10:42:16 <Anpheus> if it's lazy, it could immediately return false
10:42:53 <hpc> i mean...
10:43:07 <hpc> (const False) :: Nat -> Bool
10:43:24 <hpc> so wouldn't it always be false?
10:45:09 <roconnor> @define eq = let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq
10:45:22 <roconnor> > eq (\f -> f!!1) (\f -> f!!2)
10:45:23 <lambdabot>   Not in scope: `eq'
10:45:28 <hpc> @let
10:45:29 <lambdabot>  Defined.
10:45:32 <hpc> lol
10:45:38 * ddarius thinks that find_iii is the most easily understood definition.
10:45:40 <roconnor> @let eq = let { find p = if forsome (p . (False:)) then False : find (p . (False:)) else True : find (p . (True:)); forsome p = p (find p); eq p q = not (forsome (\a -> p a /= q a)) } in eq
10:45:41 <lambdabot>  Defined.
10:45:42 <aavogt> and @define is actually @undefined
10:45:48 <roconnor> > eq (\f -> f!!1) (\f -> f!!2)
10:45:49 <lambdabot>   False
10:45:52 <roconnor> > eq (\f -> f!!1) (\f -> f!!1)
10:45:53 <lambdabot>   True
10:46:00 <roconnor> > eq (const False) (\f -> f!!1)
10:46:02 <lambdabot>   False
10:46:18 <roconnor> > eq (const False) (\f -> f!!1 && ~(f!!1))
10:46:19 <lambdabot>   Pattern syntax in expression context: ~(f !! 1)
10:46:24 <roconnor> > eq (const False) (\f -> f!!1 && not (f!!1))
10:46:26 <lambdabot>   True
10:46:40 <roconnor> hpc: ^^
10:46:50 <hpc> i do not even
10:47:26 <roconnor> @type eq
10:47:26 <lambdabot> forall a. (Eq a) => ([Bool] -> a) -> ([Bool] -> a) -> Bool
10:48:13 * BMeph_ gets a hanky for his blown mind...
10:48:22 <pastorn> preflex: seen joe6
10:48:22 <preflex>  joe6 was last seen on #xmonad 1 hour, 10 minutes and 30 seconds ago, saying: MrElendig, that worked like a charm. Thanks  for your suggestion.
10:48:29 <ddarius> @let find_iii p = h : find_iii (p . (False:)) where h = if p (False:find_iii (p . (False:))) then False else True
10:48:30 <lambdabot>  Defined.
10:48:35 <ddarius> > find_iii (const False)
10:48:37 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
10:48:47 <hpc> > find_iii (const True)
10:48:49 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
10:48:59 <hpc> > find_iii (not)
10:49:00 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
10:49:01 <lambdabot>         against inferred typ...
10:49:07 <ddarius> > const False (find_iii (const False))
10:49:08 <hpc> :t not
10:49:08 <lambdabot> Bool -> Bool
10:49:10 <lambdabot>   False
10:49:16 <roconnor> @type find_iii
10:49:16 <lambdabot> ([Bool] -> Bool) -> [Bool]
10:49:26 <hpc> > find_iii any
10:49:27 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
10:49:27 <lambdabot>         against inferred typ...
10:49:37 <hpc> > find_iii (any (== True))
10:49:40 <lambdabot>   mueval-core: Time limit exceeded
10:49:45 <hpc> > find_iii (any (== False))
10:49:46 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
10:49:49 <roconnor> hpc: find_iii takes a predicate on [Bool] and returns a value that makes the predicate true
10:50:11 <hpc> it seems to not work in all cases ^^
10:50:20 <ddarius> hpc: You're not providing a total function.
10:50:23 <roconnor> hpc: if no value makes the predicate true it returns repeat True
10:50:31 <hpc> :t any (== True)
10:50:31 <lambdabot> [Bool] -> Bool
10:50:51 <ddarius> Also, any (== True) is or.
10:50:55 <roconnor> any (== True) (repeat False) -- fails to terminate so the function is partial
10:50:56 <ddarius> > or (repeat False)
10:50:58 <roconnor> > any (== True) (repeat False) -- fails to terminate so the function is partial
10:51:01 <lambdabot>   mueval-core: Time limit exceeded
10:51:06 <hpc> > find_iii and
10:51:08 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
10:51:11 <hpc> > find_iii or
10:51:12 <lambdabot>   thread killed
10:51:15 <lambdabot>   mueval-core: Time limit exceeded
10:51:16 <hpc> fun
10:51:30 <ddarius> > find_iii head
10:51:32 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
10:51:38 <ddarius> > find_iii (not . head)
10:51:40 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
10:51:54 <hpc> i think i will get this, once i know what cantor space has to do with it
10:51:56 <peeler> Hi, I'm trying to read a file one word at a time (where a word is defined as a sequence of non-whitespace characters), and my current implementation is bottlenecking my program, any ideas?
10:52:11 <peeler> http://hpaste.org/44734/whats_a_better_way_to_read_a
10:52:33 <ddarius> > find_iii (\a -> a !! 3 && a !! 9)
10:52:35 <lambdabot>   [False,False,False,True,True,True,True,True,True,True,True,True,True,True,T...
10:52:36 <mauke> peeler: whiteSpace already exists: isSpace
10:53:29 <mauke> peeler: can't you just use fmap words . readFile?
10:54:15 <peeler> mauke: does lazy evaluation guarantee that only one word will actually be in memory at a time that way?
10:54:22 <mauke> no
10:54:36 <peeler> (give or take size of the file buffering)
10:54:53 <mauke> it depends on how you use the list
10:55:37 * hpc is having trouble visualizing the Cantor type in that article
10:55:38 <peeler> iterating by word with someFunction (x : xs) = doSomethingWith x >> someFunction xs
10:55:53 <hpc> and what it as to do with cantor sets, specifically
10:56:16 <mauke> peeler: why not use forM_?
10:56:47 <ddarius> hpc: It's just Stream Bool which is the same as Nat -> Bool.
10:57:45 <hpc> ddarius: ooh
10:58:04 <hpc> and they are the same because the f :: Nat -> Bool ~= (!!)
10:58:20 <peeler> mauke: didn't know about that, thanks
10:58:26 <hpc> ddarius: yes?
10:58:31 <ddarius> hpc: Anyway, look at the definition of find_iii and consider what happens when p only depends on the first n cons cells.  Do induction on n.  Note that the purpose of find_iii p is to find a stream, s, such that p s == True if such a stream exists.  If one doesn't exists, it can return anything.
10:59:15 <ddarius> hpc: (!!) is one way in the isomorphism between them (if you ignore the fact that (!!) takes an Int and operates on lists, not streams.)
10:59:39 <ddarius> The other way is essentially map f [0..]
11:00:11 <hpc> i see
11:00:16 <hpc> sort of
11:00:26 <hpc> at least the Nat -> Bool part makes sense
11:01:13 <hpc> so (#) :: Bool -> (Nat -> Bool) -> Nat -> Bool
11:01:25 <ddarius> (#) is cons.
11:01:56 <hpc> and it does that by prepending the first argument to the stream the second generates
11:03:19 <hpc> and the body, \i -> if i == 0 then x else a(i-1)
11:03:32 <hpc> says, if i == 0 (we are at the head), then return the head
11:03:49 <hpc> else return the stream, but subtract one from i so we start at the front of that stream
11:03:57 <ddarius> If in find_iii p, p only depends on the head of the input, then p (False:anything) is either True or False.  If it is True, then False:anything is a valid result, otherwise True:anything is because either p (True:anything) is True, and thus p (find_iii p) = True as desired, or p always returns False, and thus anything can be returned.
11:05:22 <hpc> ddarius: and that works because (p depends on x) <=> (p x) == !(p !x)
11:05:32 <hpc> cool
11:06:02 <ddarius> What does !x mean?
11:06:16 <hpc> not x
11:06:23 <ddarius> p takes a stream.
11:06:52 <hpc> i mean
11:07:01 <hpc> eh, nvm
11:07:29 <hpc> it makes sense, even if i can't explain it
11:08:27 <hpc> ill digest that and see if the rest of the article becomes clear later
11:12:18 <ddarius> Essentially, the argument I've suggested following is to use the take lemma.
11:15:03 <Heffalump> hvr_: (belatedly) doh, thanks
11:16:26 <peeler> mauke: using fmap B.words B.getContents instead of my hGetWord resulted in a 300% speedup :)
11:17:11 <peeler> and about 2/3s the memory usage
11:18:03 <hpc> getContents is a pretty great function
11:18:24 <hpc> ddarius: what's the take lemma? google is being predictably unhelpful
11:19:14 <ddarius> hpc: One way of phrasing the question formally is: given that you know that forall xs and ys, p (take n xs ++ ys) = p xs, show that find_iii p produces a zs such that p zs = True or that p is const False.  You can do this by induction on n.  I described the n = 1 case.  n = 0 is even easier.  I haven't described the inductive case.
11:21:10 <Eduard_Munteanu> Isn't the take lemma equivalent to the principle of complete induction?
11:22:13 <ddarius> Eduard_Munteanu: No.
11:23:10 <Eduard_Munteanu> ddarius: is there a relationship between the two? Or some way to phrase the take lemma separate in a more general setting?
11:24:06 * Eduard_Munteanu remembers hearing about it here first, so he wouldn't be sure where to look
11:28:09 <tswett> @hoogle (a -> (a,b)) -> a -> [b]
11:28:09 <lambdabot> No results found
11:28:27 * tswett shrugs.
11:28:44 <ddarius> :t unfoldr
11:28:46 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:29:06 <ddarius> You could view a predicate on naturals as a stream of booleans, then the goal of induction would be to show that that stream is repeat True, you could then apply the take lemma to trying to prove that map p [0..] ~ repeat True (where ~ is bisimilarity) and that would give you something like complete induction.
11:29:08 <tswett> Ah, thank you.
11:29:12 <Eduard_Munteanu> Hm, there seems to be something in Bird & Wadler's "An Introduction To Functional Programming".
11:29:19 <ddarius> :t unfoldr . (Just .)
11:29:20 <lambdabot> forall b a. (b -> (a, b)) -> b -> [a]
11:30:01 <tswett> > unfoldr (\(x,y,z) -> Just (x,(y,z,x - 3*y + 3*z))) (0,1,4)
11:30:02 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
11:30:03 <Eduard_Munteanu> Ah.
11:30:10 <Eduard_Munteanu> Thanks.
11:30:32 <tswett> > unfoldr (\(x,y,z) -> Just (x,(y,z,x - 3*y + 3*z))) (1,0,0)
11:30:33 <lambdabot>   [1,0,0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,...
11:31:48 <tswett> Aren't linear recursive sequences supposed to increase exponentially?  :P
11:33:38 <tswett> I guess not.
11:33:58 <hpc> ddarius: holy crap, i see what find_i and forsome are doing
11:34:03 <hpc> and it is clever
11:34:46 <mercury^> :t forsome
11:34:47 <lambdabot> Not in scope: `forsome'
11:34:58 <hpc> mercury^: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
11:35:06 <mercury^> Thanks
11:35:08 <ddarius> tswett: You could view that as taking a 3 vector (x,y,z), and applying a linear transformation to it M.  Then the values you have are the x component of M^n(0,1,4).
11:36:27 <ddarius> tswett: det(M*N) = det(M)*det(N), so det(M^n) = det(M)^n, so the question is, what is the determinant of the linear transformation.
11:36:40 <tswett> Ah, yes, you're right.
11:36:56 <tswett> I would be surprised if it were anything but 1.
11:37:09 * hackagebot hamlet 0.7.2.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.7.2.1 (MichaelSnoyman)
11:37:52 <Eduard_Munteanu> Ah, I have to get some time to read that through, hpc. I almost forgot about it.
11:38:04 <tswett> Yep, it's 1.
11:39:17 <tswett> Ooh, and the Fibonacci numbers increase exponentially even though their matrix also has determinant 1.
11:39:32 <tswett> Since the determinant is the product of the eigenvalues, not just the largest eigenvalue or something.
11:40:20 <mercury^> tswett: Yes. You want to consider the spectral radius of the transformation.
11:40:22 <tswett> I wonder what this matrix's eigenstuff is.
11:40:54 <tswett> Ooh, what's a trace?  And that characteristic polynomial is something I recognize.
11:41:09 <Eduard_Munteanu> tswett: the trace is the sum on the diagonal
11:41:16 <Eduard_Munteanu> (the main diagonal)
11:41:23 <tswett> Huh.  The eigenvalues are 1, 1 and 1, and the eigenvectors are [1,1,1], 0, and 0.
11:41:36 <tswett> I should have seen that first eigenvector coming.
11:41:40 <tswett> After all:
11:41:50 <tswett> > unfoldr (\(x,y,z) -> Just (x,(y,z,x - 3*y + 3*z))) (1,1,1)
11:41:51 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:42:42 <mercury^> Eduard_Munteanu: a trace is a positive linear functional tr with the property that tr(AB) = tr(BA). If you impose that tr(1_n) = n, that determines a unique trace on the n×n matrices.
11:42:48 <mercury^> Err, tswett.
11:43:15 <tswett> mercury^: that's neat.
11:43:31 <Eduard_Munteanu> Oh, I never knew the axiomatic definition for that.
11:43:44 <tswett> I should take another linear algebra course; this stuff is exciting.  :P
11:43:46 <Eduard_Munteanu> I wouldn't have guessed that produced the sum of diagonal trace.
11:44:10 <Eduard_Munteanu> There's a similar definition for the determinant.
11:44:46 <mercury^> There is one popular defining property for the determinant. But it is also the trace on the Fock space.
11:44:48 <tswett> Yeah, multiplying matrices multiplies the determinants, doesn't it?  I guess the reason the determinant doesn't work as a trace is that it's not a linear functional.
11:44:55 <mercury^> So you can apply the Fock functor and then take the trace.
11:45:06 <Eduard_Munteanu> IIRC, it's the multilinear transform that is antisymmetric and obeys a few other properties.
11:45:30 <mercury^> Btw, traces on A all factor through K_0(A) while determinant-like stuff factors through K_1(A).
11:45:47 * ddarius simply uses f(I) = det(f)I.
11:46:00 <tswett> As far as characteristic polynomials go, can I multiply them by constants and end up with something just as good?
11:46:11 * hackagebot uu-parsinglib 2.7.0 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.0 (DoaitseSwierstra)
11:46:11 <Eduard_Munteanu> *alternating antisymmetric
11:46:23 <tswett> I like x^3 - 3x^2 + 3x - 1 better than -x^3 + 3x^2 - 3x + 1.
11:46:40 <ddarius> tswett: As far as determining eigenvalues, it would have the same roots.
11:46:41 <Eduard_Munteanu> tswett: multiplying won't make a difference for computing the eigenvalues
11:46:43 <tswett> After I learn the answer to that question, I'll have to learn what characteristic polynomials are.  :P
11:46:46 <mercury^> Eduard_Munteanu: yeah, but I could never see why that combination of properties sounds desirable.
11:47:25 <tswett> Oh, is it just the shortest polynomial whose roots are the eigenvalues?
11:47:40 <mercury^> tswett: no, it also has correct multiplicities.
11:47:45 <mercury^> The minimal polynomial is shorter.
11:48:05 * Eduard_Munteanu looks the others up
11:48:57 <tswett> Right.
11:49:12 <mercury^> tswett: and yes, you can multiply with an invertible element.
11:49:28 <mercury^> Or actually anything that is not a zero divisor I think.
11:49:56 <tswett> Ooh, I wonder if that one theorem holds for arbitrary rings.
11:50:23 <tswett> The one about ordinary generating functions being rational functions if and only if the sequence is linear recursive.
11:51:00 <Eduard_Munteanu> Well, I couldn't say it's easy to see how that axiomatic definition makes the determinant useful or unique.
11:53:00 <Eduard_Munteanu> Alternating antisymmetric probably makes sense from a permutation group point of view.
11:55:26 <Eduard_Munteanu> But it's definitely more interesting to have a few basic axioms that determine it uniquely rather than the "here's a formula, it tells you if the vectors are linearly independent" general approach.
11:56:53 <ddarius> f(I)I^-1 = det(f) is both.
11:57:31 <mercury^> `Product of spectral values' is nice enough in my opinion.
11:57:57 <mercury^> I am not a fan of defining objects by obscure properties unless those properties are very comfortable to work with.
11:58:14 <BMeph> Does anyone know of a tutorial for "debugging" a parser?
11:59:13 <Eduard_Munteanu> ddarius: how should I read that? I^-1 seems rather trivial if I is the identity matrix, unless the formula goes beyond determinant.
11:59:48 <ddarius> I is not the identity matrix here, but the pseudoscalar of the space, i.e. e_1 /\ e_2 /\ ... /\ e_n
12:00:09 <Eduard_Munteanu> Oh.
12:02:15 <ddarius> If you want det to be a multilinear transformation of vectors, you could define det(f) = det(f(e_1), ..., f(e_n)), where det(v_1, ..., v_n) = (v_1 /\ ... /\ v_n) / (e_1 /\ ... /\ e_n)
12:02:51 <Eduard_Munteanu> I take /\ to be the outer product.
12:04:36 <mercury^> Eduard_Munteanu: http://noncommutativegeometry.blogspot.com/2007/06/determinant-trace-and-noncommutative.html
12:06:00 <ddarius> Eduard_Munteanu: The outer or wedge product of geometric algebra.
12:06:29 <ddarius> Using my first characterization, the determinant is the eigenpseudoscalar of the outermorphism determined by a linear transformation.
12:06:52 <Eduard_Munteanu> mercury^: thanks. (I also always wondered how they arrived at the expression of the determinant back then.)
12:06:56 <ddarius> (or rather the eigenvalue of the pseudoscalar)
12:08:25 <Eduard_Munteanu> Hm, that also has ties with the vector product for appropriate values of n.
12:09:21 <Eduard_Munteanu> /\ vs X
12:09:48 <Twey> ʌ × — you dropped these, sir
12:12:20 <Eduard_Munteanu> Uh, unicode stuff is a pain to map and input.
12:12:50 <Twey> Not really… couple of .XCompose entries and you're set
12:15:02 <Eduard_Munteanu> And remembering those. Thankfully mauke helped me set up an irssi script some time ago so I can type latex-y stuff into it.
12:15:38 <Eduard_Munteanu> I should probably use it more often.
12:18:27 <Eduard_Munteanu> Hm, "Down with determinants" also seems like a nice alternative road through maths.
12:26:54 <ddarius> f^-1(A) = f^T(AI)f^T(I)^-1
12:27:25 <hvr_> why do I get a "Duplicate instance declarations" error when I just evaluate [d| instance Eq Int |]  ?
12:27:37 <hvr_> shouldn't that just give me a parse-tree?
12:27:58 <Saizan> it's checked too
12:28:43 <Saizan> there's a plan to introduce a way to simply get a parse tree, with no checking, but that's not implemented yet
12:30:54 <hvr_> I'm trying to replace "Int" by a string,
12:30:55 <hvr_> but
12:30:57 <hvr_> [d| instance Eq $(TH.conT $ TH.mkName "Int") |]
12:31:02 <hvr_> doesn't cut it...
12:31:19 <hvr_> which constructor should I use instead of contT?
12:35:53 <Saizan> conT should be right 
12:36:08 <hvr_> but I get "Illegal instance declaration for `Eq t_n'"
12:39:02 <Saizan> but if you allow FlexibleInstances then it seems to work out
12:39:20 <Saizan> looks like some sort of bug
12:46:33 <Jesin> hm
12:46:40 <Jesin> question about pragma syntax
12:47:07 <Jesin> is {-# INLINE foo #-} {-# INLINE baz #-} necessary
12:47:09 <Jesin> or
12:47:16 <Jesin> would {-# INLINE foo, baz #-} suffice?
12:47:18 <Jesin> :p
12:47:34 <Jesin> or whatever other syntax for that, maybe ; instead of ,
12:48:14 <mauke> preflex: ? .ua
12:48:14 <preflex>  Ukraine
12:56:11 <hvr_> Saizan: what's wrong with [d| $(varP $ mkName "x") = 3 |] btw? :-)
12:57:24 <Saizan> hvr_: no idea
13:00:39 <aavogt> @hoogle mkName
13:00:39 <lambdabot> Language.Haskell.TH mkName :: String -> Name
13:00:40 <lambdabot> Language.Haskell.TH.Syntax mkName :: String -> Name
13:00:40 <lambdabot> Language.Haskell.TH.Syntax mkNameG_d :: String -> String -> String -> Name
13:00:54 <aavogt> @hoogle letE
13:00:54 <lambdabot> Language.Haskell.TH letE :: [DecQ] -> ExpQ -> ExpQ
13:00:54 <lambdabot> Language.Haskell.TH.Lib letE :: [DecQ] -> ExpQ -> ExpQ
13:00:54 <lambdabot> Language.Haskell.TH LetE :: [Dec] -> Exp -> Exp
13:01:06 <aavogt> bah, too much spam
13:01:12 <pozic> How can I get some external analog signal into a computer?
13:01:21 <hvr_> pozic: soundcard?
13:01:44 <mreh> would it be sensible to make a failure/warnings monad
13:02:04 <mreh> I suppose that's just WriterT String Either a
13:02:06 <pozic> hvr_: that would be one way, I am just thinking of e.g. connecting an antenna to a machine and just reading random values out of it and wondered how that would work.
13:03:22 <siracusa> mreh: There's already Control.Monad.Error
13:03:30 * hackagebot alms 0.5.0 - a practical affine language  http://hackage.haskell.org/package/alms-0.5.0 (JesseTov)
13:03:45 <pozic> hvr_: To get a CPU to understand analog stuff, you need a A/D converter, but I don't know whether those are already builtin, or not, or what you can input into a machine from the 'outside', which is not already digital (like in the form of USB data).
13:03:55 <mreh> siracusa: Yeah, i was hoping to collect warnings, not fail
13:05:54 <hvr_> pozic: some cpus for embedded systems do feature A/D converters
13:06:36 <Taslem> Is there ever a time where usafePerformIO MUST be called?
13:06:37 <hvr_> pozic: but the poor-mans approach w/ off-the-shelf hardware usually is to just use the line-in of a soundcard as ADC
13:07:00 <ddarius> hvr_: It is an ADC.
13:07:02 <pozic> hvr_: and otherwise, in which 'language' or 'protocol' do you need to pass your data to the CPU? E.g. how does RS232 look like?
13:07:39 <hvr_> ddarius: yes :)
13:08:42 <ddarius> Anyway, see random.org as a place which does this and describes what post-processing is (still) needed.
13:08:56 <hpc> Taslem: it is never necessary, only convenient
13:09:38 <hpc> "convenient" meaning "this doesn't do any IO, and is referentially transparent, so why even have it in IO?"
13:09:48 <hpc> it's very rare for it to even be applicable
13:09:53 <Jesin> @src (++)
13:09:53 <lambdabot> []     ++ ys = ys
13:09:53 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:09:53 <lambdabot> -- OR
13:10:07 <Jesin> the other option was presumably
13:10:08 <parcs> or what?!
13:10:31 <Jesin> xs ++ ys = foldr (:) ys xs
13:10:35 <ninly> pozic, a lot of amateur radio operators use the method hvr_ describes to modulate/demodulate digital modes for a radio interface. sound cards are more than sufficient for this
13:10:41 <Taslem> Ah. Something I found it useful for was loading a file that acted as a source of randomness.
13:10:46 <Jesin> (++) = flip (foldr (:))
13:10:57 <Taslem> Since I didn't feel like rewriting all of my functions to be IO.
13:11:33 <hpc> if you can promise the file never changes...
13:12:04 <hpc> or rather, why not just have the file be haskell source, with a big list?
13:12:38 <hpc> (answer: neither choices are that wise :P)
13:14:16 <hpc> :t randoms
13:14:17 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
13:14:49 <Taslem> The file was just random fragments of wikipedia articles. I used it to provide phonetics for a name generator.
13:17:12 <hpc> ah
13:22:10 <Taslem> Is there any way to define a type like [E] in Show?
13:44:44 <FauxFaux> @pl (\_ -> randomIO)
13:44:44 <lambdabot> const randomIO
13:47:39 * hackagebot JSONb 1.0.4 - JSON parser that uses byte strings.  http://hackage.haskell.org/package/JSONb-1.0.4 (JasonDusek)
13:52:45 <mreh> what would be a good way of trying to parse no more than a fixed number of bytes with Parsec?
13:54:05 <Philippa> mreh: the most grammar-cross-cutting one'd be to keep the count in the state
13:54:25 <mreh> and replicateM just fails
13:54:38 <Philippa> or possibly the stream, depending on what you want to happen when that count's hit
13:54:45 <Philippa> stream's probably better, come to think of it
13:54:59 <mreh> I don't geddit
13:55:09 <Philippa> (keeping it in the stream means you keep accurate count against backtracking)
13:55:17 <Philippa> okay, you know how parsec 3 allows custom streams?
13:55:30 <mreh> there's the stream class aye
13:55:37 <Philippa> have the stream values keep track of how many bytes into the stream they are
13:55:45 <Philippa> (so put a wrapper around wherever you're getting the input from)
13:55:58 <Philippa> and fail when you try to read the nth byte / be EOF
13:56:24 <mreh> i like it
13:56:53 <mreh> grammar-cross-cutting is a new one :)
13:57:04 <Philippa> cross-cutting in the same sense as AOP, FWIW
13:57:12 <Philippa> as in "your grammar doesn't have to give a fuck" :-)
13:58:31 * ddarius wasn't going to use the term "cross cutting" but was going to suggest that as the most "general" answer.
13:58:51 <ddarius> for essentially the reasons Philippa meant by "grammar cross cutting."
13:59:03 <mreh> doesn't strike me as very declarative
14:00:02 <mreh> i suppose I can count it up in the grammar itself
14:00:27 <Philippa> it's very declarative: it declares that the stream cannot go beyond point x
14:00:43 <Philippa> (okay, it'd be more declarative with some combinators around the unfold interface I guess: that's a bit low-level)
14:01:30 <Philippa> there's nothing wrong from a declarative point of view about putting that property in the stream?
14:01:31 <mreh> i've got some images that are supposed to be 19x19, and some bugger mixed it ones short of a byte
14:02:01 <Philippa> go board?
14:02:12 <mreh> faces
14:03:08 <mreh> might just discard for now, see how many are left
14:03:27 <mreh> I was going to attempt a recovery
14:03:43 <mreh> by stuffing bits
14:10:44 * hackagebot bounded-tchan 0.1 - Bounded Transactional channels (queues)  http://hackage.haskell.org/package/bounded-tchan-0.1 (ThomasDuBuisson)
14:20:46 <mikeg> When LBS.fromChunks says it is O(c), is c the length of the input list of strict chunks?
14:21:13 <mikeg> That is to say, that LBS.fromChunks ["test"] is O(1) ?
14:23:46 <bss03> Cantor space has measure 0, but its uncountable infinite, right?
14:28:43 <bss03> http://xorshammer.wordpress.com/2008/08/21/compute-definite-integral/ <-- LeBesque intergral or "normal" integral?
14:30:24 * lispy gets ready to try the latest HP on windows
14:31:20 <bss03> by "normal" I mean Reimann.
14:33:01 <lispy> bss03: It says "The obvious thing to do is to compute a Riemann sum"
14:33:10 <lispy> bss03: So I assume they are talking about Reimann integration
14:34:34 <rwbarton> they assume in the first sentence that f is continuous, so any reasonable notion of integration will do
14:34:46 <bss03> Right, right.
14:35:28 <bss03> LeBesque only allows intergration of certain non-continuous functions.
14:36:30 <bss03> Like f: R -> R f(r) | r `eleemntOf`Q = 1 | otherwise = 0.
14:53:09 <serpentologist> Have anybody used Paul Hudak's Euterpea library? I am waiting for it to compile for more than 5 hours - is it normal?
14:54:52 <Axman6> sounds extremely abnormal. have you run out of memory?
14:55:09 <serpentologist> no
14:55:25 <serpentologist> 76.0  7.8 297:11.10 ghc
14:55:37 <serpentologist> a part of ps output
14:55:49 <serpentologist> 7.8 % of memory
14:56:07 <Axman6> it's possible the type checker has been sent into an infinite loop, but can't be sure
15:07:35 <blbrown_win3> http://pastebin.com/0944PLBm  I am trying render some pixels using gtk2hs.  Anyone see any issues here.  The screen comes up, but nothing gets rendered.  Just a grey background (Win32)
15:13:18 <tromp__> @hoogle Graphics.UI.Gtk
15:13:19 <lambdabot> No results found
15:29:22 <mwc> Oh boy, debugging parsec parsers is fun: "...unexpected end of input\nexpecting end of input"
15:29:42 <Axman6> heh
15:31:23 <djahandarie> Try debugging attoparsec parsers.
15:32:24 <djahandarie> A lot of the errors are just "[some internal function]: failed [for some reason that makes no sense]" 
15:32:29 <djahandarie> But this is what we give up for performance :)
15:34:30 <geheimdienst> "yes yes, now that my program runs 17 ms faster, i know those 4 hours of developer time have not been in vain"
15:34:31 <geheimdienst> ;)
15:35:12 <hpc> > 4 * 60 * 60 * 1000 / 17
15:35:14 <lambdabot>   847058.8235294118
15:35:27 <hpc> and the program only needs to run 900,000 times to recoup the time
15:35:33 <hpc> a bargain!
15:35:39 <sipa> you don't get it
15:35:58 <sipa> it's always worth it to optimize, just because you can!
15:36:14 <aristid> and if the code is less readable, you can't be replaced so easily
15:36:19 <aristid> it's a win-win-win-win
15:36:21 <Axman6> s/you can/it's fun!/
15:36:35 <hpc> optimizing isn't that fun, imo
15:36:50 <geheimdienst> sipa: ... and this summer spend a few more hours pulling your hair out what on earth you did back there -- just because you can
15:36:52 <geheimdienst> ;)
15:37:05 <hpc> much more fun to twist the required functionality into neat code shapes
15:45:12 <Jesin> lol, yes, what hpc said
15:48:06 <timmaxw2> Is there a good way to pronounce kinds when speaking Haskell aloud?
15:48:19 <timmaxw2> For example, how would I say "Maybe :: * -> *" with my mouth?
15:48:28 <Axman6> star to star?
15:48:40 <Boxo> Star to star!'
15:48:54 <Ptival> double question mark to question mark? :)
15:48:55 <ion> colon colon asterisk dash greater than asterisk
15:48:55 <Jesin> it's annoying that english doesn't have parentheses that are quick to say
15:48:56 <Jesin> :p
15:49:04 <timmaxw2> Okay, "star to star" it is
15:50:11 * ddarius usually reads that as "type to type."
15:50:42 <djahandarie> Set to Set
15:51:16 <ion> I’m sure there’s an Xzibit joke here somewhere.
15:52:05 <Jesin> :k (->)
15:52:06 <lambdabot> ?? -> ? -> *
15:52:24 <Jesin> why is it listed as that, instead of * -> * -> *
15:52:26 <Jesin> ?
15:52:47 <antonh> I guess you can go to a lecture on functional programming and pick up some terminology..
15:52:52 <ddarius> Jesin: Because lambdabot uses GHC and that is the kind of (->) in GHC.
15:53:09 <aristid> :k Maybe
15:53:10 <lambdabot> * -> *
15:53:11 <Jesin> is there a semantic difference?
15:53:47 <Cale> Jesin: ?? and ? have to do with unboxed types
15:54:56 <Axman6> you can have Int# -> Bool, and there -> is being used on something which doesn't have kind *
15:54:59 <Cale> http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes -- there's a diagram explaining here
15:55:40 <Jesin> "    * Kinds are now Types - The type Kind is just a synonym for Type. There are special PrimitiveTyCons that represent kinds. "
15:55:42 <Jesin> what?
15:55:44 <Jesin> :p
15:55:48 <Jesin> :t Maybe
15:55:49 <lambdabot> Not in scope: data constructor `Maybe'
15:56:02 <Cale> Jesin: This is in the GHC internals
15:56:05 <Jesin> oh wait
15:56:07 <Jesin> ok
15:56:33 <Cale> Scroll down a bit and there's an explanantion of what the # and ?? etc. kinds mean
15:56:42 <Cale> I'm not sure if there's a better place that it's documented :P
15:57:06 <geheimdienst> cale, good link, thanks
15:57:14 * hackagebot hscassandra 0.0.4 - cassandra database interface  http://hackage.haskell.org/package/hscassandra-0.0.4 (KirkPeterson)
15:57:46 <ddarius> Cale: I'm pretty sure there isn't unless it's discussed in the early papers on unboxed types, which I don't recall it being.
15:58:18 <Jesin> so
15:58:32 <Jesin> :k (->)
15:58:32 <lambdabot> ?? -> ? -> *
15:58:38 <Jesin> the fact that the first thing is ?? instead of ?
15:59:06 <Jesin> does that mean that functions cannot take unboxed tuples as arguments?
15:59:08 <Jesin> umm
15:59:21 <Jesin> I'm not sure I understand that part  :p
16:01:10 <ddarius> Jesin: That's what it means.
16:01:15 * hackagebot hscassandra 0.0.5 - cassandra database interface  http://hackage.haskell.org/package/hscassandra-0.0.5 (KirkPeterson)
16:01:18 <Axman6> “Everything we teach you in first year physics is a lie. But sometimes one has to lie to get at the truth; until you understand these lies, you cannot understand the deeper truths behind them." hmm, sounds a lot like what teaching haskell is like to someone who's never used it before
16:01:42 <dolio> They're not exactly lies.
16:02:03 <Axman6> well, sure, they're (over) simplifications
16:02:07 <dolio> They're good enough for anything most people will ever encounter in their day-to-day life.
16:02:14 <Axman6> but helpful for learning
16:02:50 <Axman6> anyone looked at the mythryl language before? it looks quite interesting: http://mythryl.org/
16:02:58 <Jesin> "monads as containers" was a helpful one for me
16:03:32 <Axman6> Jesin: yeah, that idea was helpful for me too, to actually start to use them
16:03:40 <Jesin> once I had grasped that, and wrote the findspace monad ( newtype Findspace b a = Findspace { runFind :: (a -> b) -> a } )
16:03:41 <geheimdienst> also, there's nothing wrong with starting with an example, then going to the general case. hardly a lie.
16:03:42 <Jesin> using that
16:03:55 <Jesin> I then read the "monads as computations" thing
16:03:57 <Axman6> then you get to things like the (->) monad and that starts to break down, but by that point, you start to see why it works
16:04:08 <Jesin> lol
16:04:14 <Jesin> nah, it doesn't break down in (->)
16:04:16 <aristid> Axman6: (e ->) is absolutely a container :)
16:04:17 <Jesin> :p
16:04:30 <Jesin> that's how mathematicians *define* functions.
16:04:36 <Axman6> well, so. but much less so than say Maybe or list :)
16:04:56 <Jesin> what are you talking about with "more" or "less"
16:05:02 <Jesin> :p
16:05:04 <Jesin> meh
16:05:05 <Axman6> when you think of things in a physical way like i tend to, it's less clear what is meant by a container there
16:05:19 <Jesin> well
16:05:21 <Jesin> newtype Findspace b a = Findspace { runFind :: (a -> b) -> a }
16:05:26 <Jesin> I wrote the monad instance for ^ that
16:05:33 <Jesin> using the "monads as containers" metaphor
16:05:39 <Jesin> :p
16:06:01 <Jesin> actually I wrote it with Findspace Bool in mind
16:06:09 <Jesin> and then just generalized that particular parameter
16:07:20 <Cale> Jesin: :)
16:07:29 <Cale> Jesin: I'm glad that the stuff I wrote was useful :)
16:07:34 <geheimdienst> what exactly is a findspace?
16:08:40 <geheimdienst> btw, this "?? -> ? -> *" explanation is pretty much the relevant bit of the wiki page, but with 1 or 2 good links added: http://stackoverflow.com/questions/3034264/haskell-weird-kinds
16:09:43 <Jesin> http://hpaste.org/44736/findspace_monad
16:11:29 <ddarius> Axman6: As far as I can tell, Mythryl is little more than a different front-end to SML/NJ, and I'm unclear on what it adds.
16:11:30 <Jesin> geheimdienst: it represents a set that can be searched
16:11:50 <Jesin> cantorSet :: Findspace Bool [Bool]
16:11:52 <Jesin> from that file
16:12:03 <geheimdienst> i see. thanks
16:12:08 <Jesin> is the space of all infinite lists of bools
16:12:10 <Jesin> :p
16:13:30 <Jesin> Cale: which article did you write?
16:13:44 <Jesin> "Monads as containers", "Monads as computations", or both?
16:13:46 <Cale> both
16:13:53 <Jesin> k
16:14:02 * ddarius dislikes "Monads as containers" but is fine with "monads as computations."
16:14:02 <Jesin> I particularly liked the phrase that
16:14:07 <Jesin> join "removes a level of indirection"
16:14:10 <Jesin> from the computation one
16:14:41 <Jesin> that tied in so nicely with that Findspace thing
16:14:42 <Axman6> ddarius: http://mythryl.org/my-SML_vs_Mythryl.html seems to outline the differences =) (starting with printf... maybe you're are right)
16:14:46 <Jesin> :p
16:15:15 <Jesin> ddarius: that gave me difficulties
16:15:25 <ddarius> Axman6: I'm unsure how you found it interesting.
16:15:30 <Jesin> because I initially had issues with the idea of lists
16:15:36 <Jesin> as "nondeterministic computations"
16:16:19 <Jesin> also: computations generally compute functions, which mathematically are generally seen as being from one set to another
16:17:08 <Jesin> I found the container analogy more useful at the beginning, but that's just my background, anyone else may like the other analogy better at the start I dunno
16:17:57 <Jesin> When I finally felt like I understood monads, though, it came with the realization that the "container" and "computation" metaphor could be seen as the same thing
16:18:07 <Jesin> computations are containers  :p
16:18:25 <aristid> Jesin: and some people prefer not to use metaphors at all:)
16:18:32 <Jesin> yeah
16:18:37 <Jesin> no
16:18:40 <aristid> no
16:18:41 <aristid> yeah
16:18:53 <Jesin> hm
16:19:01 <ddarius> I'm pretty sure the main value of "monads as containers" is "how to match the types up without understanding the type system."
16:19:10 <Jesin> lol, what is the ontological status of "monad" anyway
16:19:16 <Jesin> "it's a math thing", probably  :P
16:19:32 <aristid> Monad is just a typeclass :)
16:19:35 <Jesin> lol
16:19:40 <Jesin> yup
16:19:49 <Jesin> aristid: in THAT sense, though
16:20:01 <Jesin> it's possible to write instances which do not actually satisfy the monad laws
16:20:16 <Jesin> hmm
16:20:25 <Jesin> [20:02:21]	<ddarius>	I'm pretty sure the main value of "monads as containers" is "how to match the types up without understanding the type system."
16:20:38 <Jesin> what do you mean by this?  =/
16:21:11 <Jesin> I do wonder what understanding of the type system I might still be lacking
16:21:46 <Axman6> ddarius: i thin it adds generics which is nice, but aopart from that, it seems quite SML like (i've never used SML, so it's all new to me)
16:23:13 <dolio> Generics?
16:24:03 <ddarius> Axman6: Having experience with Haskell, you may find the ML module system "quite interesting" but other than that it's pretty similar to Haskell.  It's not going to open new vistas of enlightenment, and Mythryl is pretty much SML/NJ.
16:24:26 <Axman6> it's not lazy is it?
16:25:20 <btutt> Ugh. Stylized Haskell should always include parens enclosing the text form the specialized arrow
16:25:22 <ddarius> Axman6: It isn't, and that's a big difference, but lazy is unusual, eager isn't.
16:26:00 <ddarius> Axman6: It's "generic by design" page says that it "inherits generics direcltly from SML."  I.e. "generics" is used in the OO sense, which is parametric polymorphism.
16:26:07 <Axman6> I'm kind of interested in seeing what using an eager functional language is like, but SML/Mythryl look fairly ugly compared to haskell
16:26:23 <ddarius> If Haskell were the -only- language you knew, then SML might be "quite interesting."
16:26:24 <Axman6> ah, my mistake then
16:26:30 <Axman6> heh
16:26:49 <mikeg> Cale: on "monads as computations", should this read "sequence_"? sequence_ (x:xs) = x >> sequence xs
16:26:58 <djahandarie> I dare say that ASM or C would be much more interesting in that case, ddarius.
16:27:02 <btutt> F# is sorta like ML and non-lazy. it seems like the syntax might be slightly better
16:27:09 <btutt> (than SML)
16:27:11 <ddarius> djahandarie: I agree.  As would Self or Joy.
16:27:20 <Axman6> a lot of the code i tend to write involves evaluating things eagerly, so it would be nice to see what it's like
16:27:22 <dolio> F# is like ML without the interesting parts. :)
16:27:26 <ddarius> btutt: F# is a bastardized O'Caml.
16:27:30 <Axman6> but meh, I'm too find of haskell :)
16:27:53 <btutt> i was never found of ocaml syntax either
16:28:23 <Cale> mikeg: huh?
16:28:34 <Cale> oh, yes
16:30:31 <geheimdienst> Axman6: interesting that you'd want eagerness. i've written some objective-c lately, and it's the reverse. the api authors jump through a lot of hoops to be more lazy in a language that isn't really made for it. "set this property, but it doesn't do anything, the initialization will happen only later ..."
16:30:46 <Jesin> hm
16:30:48 * ddarius watches a math talk.  He knows this because there are blackboards and not whiteboards.
16:30:48 <Jesin> [20:09:26]	<Axman6>	I'm kind of interested in seeing what using an eager functional language is like, but SML/Mythryl look fairly ugly compared to haskell
16:30:52 <Jesin> Scheme is eager functional
16:30:59 <Jesin> you could try that  :p
16:31:00 <btutt> objective-c: Even more and more and more examples of spooky action at a large distance. Ugh.
16:31:08 <Cale> I wonder how that error got left in or where it came from.
16:31:13 <djahandarie> Objective-C uses quantum mechanics?
16:31:17 <Jesin> ...well, not pure functional I think, but still  :p
16:31:22 <Cale> Has it always been like that? :)
16:31:25 <Axman6> geheimdienst: don;t get me started on Obj-C -_-
16:31:34 <Heffalump> If you want compositionality you want laziness. If you want easily controllable performance, you mostly want strictness. It's a complicated trade-off IMO.
16:32:56 <Cale> hmm, there have been a bunch of edits since I wrote this, I should really look at them, but I'm too lazy
16:33:05 <btutt> ObjectiveC seems like a mess of dynamic effects and makes it more obnoxious to predict the behavior ahead of time
16:33:07 <geheimdienst> yeah, obj-c is an abomination unto the Church and the Turing and all that ... but the lazy thing is an issue too :)
16:33:09 * Jesin feeds Cale _|_
16:33:28 * Jesin pokes Cale to see if he's still alive
16:34:07 <btutt> send objects messages, but code in external libraries might hide your messages or change the context in which they run. Ugh.
16:34:57 <btutt> or indeed add code to your object by supporting additional sets of messages
16:35:14 <Cale> yeah
16:35:31 <Jesin> ok, yeah, Cale's lazy  :p
16:35:55 <Axman6> my problem with Obj-C is the seeming almost completel lack of a useful typesystem on the OO side of things
16:36:11 <btutt> its a C flavor of Smalltalk almost. Ugh.
16:36:15 <btutt> (sorta)
16:36:26 <btutt> typing? what the heck is that? :)
16:36:30 <Axman6> well, that's exactly what it is, C with a smalltalk object system
16:36:31 <Jesin> umm
16:36:31 <geheimdienst> yes, it has just enough type system to be in the way, but not enough to actually help much
16:36:45 <Jesin> [20:17:26]	<btutt>	send objects messages, but code in external libraries might hide your messages or change the context in which they run. Ugh.
16:36:47 <Jesin> what?
16:37:20 <Jesin> ...
16:37:26 <Jesin> I haven't looked into Obj-C much
16:38:04 <btutt> Java analogy: IIRC, Obj-C lets you add support for additional methods to a class in external libraries. This would be like loading part of your Java class from one .jar file and part of it from another .jar file.
16:38:55 <Jesin> hmm
16:39:08 <Jesin> Haskell does that with typeclass instances, doesn't it?
16:39:17 <btutt> The intent is sort of like the ability in Haskell to add typeclass instances outside of the main defining library, but due to Obj-C being smalltalk like makes it even worse
16:39:25 <Jesin> hm
16:39:45 <btutt> since Haskell is well typed, and Obj-C is definitely not
16:40:00 <Jesin> what about Python's duck typing?
16:40:05 <Jesin> :p
16:40:43 <btutt> Python is a dynamic system like Obj-C technically, but I don't think many people abuse it that fashion all that often.
16:40:48 <Axman6> If it looks like and quacks like a duck, it's probably duck typed, so shoot it
16:40:49 <btutt> (but that isn't duck typing)
16:41:24 * hackagebot quicklz 1.5.0.1 - binding to QuickLZ compression library  http://hackage.haskell.org/package/quicklz-1.5.0.1 (AustinSeipp)
16:41:30 <btutt> Duck typing is separate from being able to modify the system arbitrarily at run time.
16:41:30 <Jesin> hm, k.
16:41:42 <Jesin> I think Python can do that too?
16:41:57 <btutt> Yes it can, but most people don't. its more likely to happen in Obj-C
16:42:15 <Jesin> hm, ok.
16:42:25 <Jesin> I wonder if that's anything about the language itself, or just the conventions people use
16:42:30 <Jesin> heh
16:42:34 <Jesin> conventions are quite important, though
16:42:35 <parcs> @untl MaybeT Int
16:42:36 <lambdabot> Maybe you meant: unmtl unpl
16:42:41 <parcs> @unmtl MaybeT Int
16:42:41 <lambdabot> err: `MaybeT Int' is not applied to enough arguments, giving `/\A. Int (Maybe A)'
16:42:56 <btutt> Obj-C is more smalltalk like than Python from the exposed APIs to end users. So its more likely to abused that way.
16:43:12 <btutt> so part convention, part language design
16:43:16 <Jesin> k.
16:44:05 <co_dh> what's unmtl?
16:44:49 <Axman6> @unmtl MaybeT IO Bool
16:44:49 <lambdabot> IO (Maybe Bool)
16:45:04 <parcs> it gives you the resultant type given a stack of monad transformers
16:45:07 <btutt> i'd guess unwrap a level of monad transformer stack
16:45:22 <btutt> ah
16:45:40 <parcs> @hoogle Maybe Bool
16:45:41 <lambdabot> Did you mean: :: Maybe Bool /count=20
16:45:41 <lambdabot> No results found
16:45:42 <Axman6> if you have FooT, and there's a function runFooT, then it's usually the type of running that on a FooT
16:46:25 * hackagebot quicklz 1.5.0.2 - binding to QuickLZ compression library  http://hackage.haskell.org/package/quicklz-1.5.0.2 (AustinSeipp)
16:49:48 <HugoDaniel> i find myself using concatMap a lot
16:49:49 <HugoDaniel> :/
16:50:19 <HugoDaniel> is it my legacy oop background hunting me again ?
16:50:56 <co_dh> :t concatMap
16:50:58 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
16:50:58 <luite> if you replace it by >>= you are totally l33t again ;)
16:51:19 <HugoDaniel> ah, indeed
16:51:27 <HugoDaniel> :)
16:51:30 <co_dh> I believe concatMap is relate to recursive programming, not OOP
16:51:52 <co_dh> I33t?
16:52:12 <ddarius> :t flip (>>=)
16:52:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
16:52:27 <ddarius> HugoDaniel: Perhaps you want to use list comprehensions?
16:55:49 <parcs> @type ($) ($)
16:55:50 <lambdabot> forall a b. (a -> b) -> a -> b
16:56:41 <luite> parcs: in haskell, more ($) does not give you bigger types
16:57:18 <HugoDaniel> :)
16:57:27 <parcs> luite: what about infinite $es:
16:57:33 <parcs> :t fix ($)
16:57:34 <lambdabot> forall a b. a -> b
16:57:45 <parcs> eh, i guess it's not "bigger"
16:58:29 <aristid> HugoDaniel: list comprehensions or do notation are basically just concatMap too :)
17:00:31 <HugoDaniel> aristid, :) i just realised it now
17:00:32 <HugoDaniel> amazing
17:00:33 <HugoDaniel> eheh
17:10:59 <pr> :t fix
17:11:00 <lambdabot> forall a. (a -> a) -> a
17:16:26 <HugoDaniel> [toLower $ head l] ++ tail l
17:16:46 <HugoDaniel> how do i make this more elegantly ?
17:17:41 <FauxFaux> @pl [toLower $ head l] ++ tail l
17:17:42 <lambdabot> toLower (head l) : tail l
17:18:28 <HugoDaniel> anyway to do this point-free style ?
17:18:34 <geheimdienst> > let f (x:xs) = toLower x : xs in f "Lolcats"
17:18:35 <lambdabot>   "lolcats"
17:18:41 <HugoDaniel> :D
17:19:18 <geheimdienst> if you have only one thing to tack on to the front of a list, you don't need ++, you can use :
17:19:25 <igorgue> I like lambdabot solution
17:19:54 <HugoDaniel> cool
17:19:55 <geheimdienst> (especially since in this case, you're first have to specially make the list: [toLower ...])
17:20:33 <geheimdienst> the other thing is that i find (x:xs) often clearer than head/tail calls
17:20:44 <luite> @pl f (x:xs) = toLower x : xs
17:20:44 <lambdabot> f = ap ((:) . toLower . head) tail
17:20:46 <geheimdienst> you can see at a glance what's happening
17:20:51 <luite> hmm nah
17:21:16 <HugoDaniel> here is my code:
17:22:00 <xplat> for me the hard part of ‘seemingly impossible functional programs’ was seeing why find_i terminated
17:22:06 <HugoDaniel> fvName fd = (\l -> toLower (head l) : tail l) . head . words . show $ fd
17:22:13 <xplat> and that is because it makes essential use of laziness
17:23:01 <HugoDaniel> hmmm
17:23:01 <HugoDaniel> okey
17:23:45 <xplat> on each iteration the forsome is working on a predicate like \a -> p (Zero # One # Zero # Zero # ... # a)
17:23:45 <HugoDaniel> fvName fd = (\(x:xs) -> toLower x : xs) . head . words . show $ fd
17:24:04 <HugoDaniel> anyway to use guards in a lambda ?
17:24:07 <xplat> where a comes from a find call
17:24:35 <xplat> eventually as this gets longer, the predicate will return without forcing a
17:24:47 <xplat> and thus without evaluating the recursive call to find
17:25:38 <HugoDaniel> i dont like using pattern matching :( ghc always fails in runtime
17:25:44 <geheimdienst> > let fvName = (\((x:xs):_) -> toLower x : xs) . words . show in fvName "Lolcats toterlly rulez"
17:25:48 <lambdabot>   mueval-core: Time limit exceeded
17:25:49 <HugoDaniel> anyway to make ghc warn me about non-exaustive patterns ?
17:26:25 <xplat> so actually the intensional modulus plays an essential role in the proof of totality even though it can never show up in the result :)
17:26:34 * geheimdienst was a little too clever for his own good there
17:27:06 <geheimdienst> > let fvName = (\((x:xs):_) -> toLower x : xs) . words . show in fvName "Lolcats toterlly rulez"
17:27:08 <lambdabot>   "\"Lolcats"
17:27:13 <luite> HugoDaniel: it does that with -Wall
17:27:23 <HugoDaniel> cool
17:28:04 <geheimdienst> HugoDaniel: yes, patterns can fail at runtime, but head doesn't solve that problem
17:28:07 <geheimdienst> > head []
17:28:08 <lambdabot>   *Exception: Prelude.head: empty list
17:28:31 <HugoDaniel> yeah, i should be using take 1 and <$>
17:28:36 <HugoDaniel> let me switch it
17:28:41 <HugoDaniel> or spoon :P
17:28:42 <luite> and you might like hlint, for even more warnings and suggestions of how to improverize your code
17:28:53 <HugoDaniel> sweet
17:32:48 <ddarius> xplat: If you expand (#) in the definition find_i (and elsewhere) or just eta expand the right arguments of (#), they are all guarded by a lambda.
17:35:02 <roconnor> woah
17:35:11 <roconnor> how long have we be talking about seemingly impossible functions?
17:35:27 <geheimdienst> since there have been possible functions?
17:35:56 <xplat> ... there's a noncommutative geometry blog?!
17:37:03 <luite> it's rule 34, if it exists, there's a blog about it ;)
17:37:11 <ddarius> And I guess you have to eta expand the call in forsome
17:39:41 <geheimdienst> no, rule 34 would be that the geometry does ... er ... and then commutatively is being ... oh dear
17:39:54 <HugoDaniel> what is preferable: 
17:39:56 <HugoDaniel> zip [1..10] $ repeat 1
17:40:04 <HugoDaniel> map (\e -> (e,1)) [1..10]
17:40:14 <luite> map (,1) [1..10]
17:40:16 <dolio> Turn on TupleSections.
17:40:17 <HugoDaniel> or that
17:40:18 <ddarius> Do you really need to ask?
17:40:32 <HugoDaniel> i dont know :/
17:40:43 <HugoDaniel> why is zips prefered to map ?
17:40:45 <ddarius> HugoDaniel: Which one do you prefer?
17:40:51 <HugoDaniel> i prefer map
17:40:55 <geheimdienst> > [(x,1) | x <- [1..10]]
17:40:56 <lambdabot>   [(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1)]
17:40:56 <ddarius> Then use that one.
17:41:44 <HugoDaniel> oh, tuplesections are a nice
17:41:45 <HugoDaniel> :)
17:41:52 <ddarius> Incidentally, why do you prefer the map one?
17:42:30 <aristid> perceived complexity?
17:42:59 <ddarius> > flip (,) 1 . [1..10]
17:43:01 <lambdabot>   [(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1)]
17:43:01 <HugoDaniel> because repeat builds a new list ?
17:43:13 <ddarius> HugoDaniel: So?  And not much of one.
17:43:33 <HugoDaniel> hmm, then i guess zip should be prefered since it uses lazyness
17:43:33 <Axman6> that list will probably never exist
17:43:45 <Axman6> map uses laziness too
17:43:51 <ddarius> HugoDaniel: Who cares if "laziness" is used or not?
17:44:04 <HugoDaniel> isn't laziness l33t ?
17:44:42 <HugoDaniel> anyway, ill turn on the tuplesections
17:44:42 <luite> in the zip version, the 1 is shared
17:44:55 <ddarius> luite: 1 is a constant.  It's "shared" anyway.
17:45:07 <ddarius> Well, I guess fromInteger could change that.
17:45:21 <HugoDaniel> i used numbers just as an example
17:45:25 <luite> well yes, but I assumed here that 1 is just an example :)
17:45:27 <HugoDaniel> im using this pattern with other datatypes
17:46:11 <brisbin> dumb question: in (Num t) => t1 -> (t, t1) does the Num restriction apply to t and t1?
17:46:15 <ddarius> luite: Well, if 1 gets replaced by some reducible expression, then you have a point, but you could just let-bind that on the outside.
17:46:28 <brisbin> it has to right?
17:46:34 <ddarius> brisbin: It applies to t like it says.
17:46:44 <brisbin> shit nvm
17:47:03 <brisbin> brainfart thinking typles had to be same type
17:47:19 <brisbin> quite the opposite
17:48:12 <codolio> > (length "\e -> (e,1)", length "(,) `flip` 1")
17:48:14 <lambdabot>   <no location info>:
17:48:14 <lambdabot>      lexical error in string/character literal at chara...
17:48:18 <HugoDaniel> i really struggle with these kind of patterns, i wish i could understand how ghc works in these cases
17:48:21 <codolio> > (length "\\e -> (e,1)", length "(,) `flip` 1")
17:48:22 <lambdabot>   (11,12)
17:48:33 <ddarius> > length "flip (,) 1"
17:48:34 <lambdabot>   10
17:49:35 <Axman6> > length "\\e->(e,1)" -- >_>
17:49:36 <lambdabot>   9
17:49:47 <Axman6> wut?
17:49:54 <Axman6> oh right
17:50:17 <djahandarie> > length "flip(,)1"
17:50:18 <lambdabot>   8
17:50:18 <ddarius> Axman6 is shooting lasers out of his eyes.
17:50:19 <luite> HugoDaniel: you can visualize some of the data structures with vacuum and vacuum-cairo
17:50:35 <Axman6> pew pew! phear me!
17:50:46 <Axman6> please be friends with me ;9
17:50:49 <Axman6> :(*
17:51:02 * ddarius is not friends with anyone who says "pew pew."
17:51:36 <djahandarie> Does that apply for all sound effects or just select ones?
17:51:37 * geheimdienst is inches away from posting a selection of "pew pew" lolcats
17:51:41 <ddarius> > length "\\e→(e,1)"
17:51:43 <lambdabot>   8
17:51:56 <ddarius> djahandarie: Select ones.
17:51:56 <djahandarie> Oh god, unicode golfing...
17:52:18 <luite> HugoDaniel: you need cairo and graphviz for those though, if you don't have them, you could try my experimental web based thingie:  http://jabberwock.xs4all.nl/weblog/tryhaskell.mod/
17:52:22 <luite> err
17:52:23 <HugoDaniel> vacuum seems very nice
17:52:31 <ddarius> :t \e→(e,1)
17:52:32 <lambdabot> parse error (possibly incorrect indentation)
17:52:34 <luite> don't know if you can see that site
17:52:35 <ddarius> Curses.
17:53:37 <HugoDaniel> luite, very niceee :)
17:53:48 <luite> HugoDaniel: you can for example enter: > vacuum $ zip [1..10] (repeat "test")
17:54:00 <luite> and compare that with > vacuum $ map (,"test") [1..10]
17:55:05 <HugoDaniel> wo
17:55:06 <HugoDaniel> wow
17:55:07 <luite> whoops I don't have tuple sections enabled
17:55:22 <HugoDaniel> no prob. ill use a lambda
17:56:39 <dolio> The lambda could be different.
17:57:17 <dolio> (,e) is likely to be expanded to something more like 'let x = e in \y -> (y,x)' than \y -> (y, e), for instance.
17:57:39 <HugoDaniel> luite, it always shows the same image
17:58:02 <dolio> That probably won't make a difference if e is 1, though.
17:58:48 <luite> HugoDaniel: hmm, it seems to work fine here, what browser are you using?
17:59:00 <HugoDaniel> chromium
17:59:04 <HugoDaniel> in fedora
17:59:27 <luite> are you sure you are entering a different expression? :p
18:00:01 <Axman6> :t \e->e
18:00:02 <lambdabot> forall t. t -> t
18:02:56 <HugoDaniel> ghc is smart
18:02:57 <HugoDaniel> :)
18:03:00 <HugoDaniel> now i can see 
18:03:20 <HugoDaniel> map (+2) [1..10] and it automagically builds the list with the correct values, no computation needed
18:03:28 <HugoDaniel> shiznit
18:13:43 <luite> HugoDaniel: hmm, I broked it
18:14:07 <HugoDaniel> you did?
18:18:14 <luite> yeah I tried to enable TupleSections, but now it doesn't load Prelude
18:18:43 <aristid> luite: stop breaking it!
18:19:42 <HugoDaniel> if you turn -O will it produce extra optimized drawings ?
18:21:17 <luite> hehe the web thing uses hint, no optimized drawings :)
18:27:07 <luite> HugoDaniel: well vacuum only visualises data structures, not how the thing is evaluated or what the expression looks like. > vacuum $ foldr (+) 0 [1..10] -- this will give a rather boring result
18:28:50 <HugoDaniel> ah okey
18:35:44 <Jesin> :t vacuum
18:35:44 <lambdabot> Not in scope: `vacuum'
18:35:49 <Jesin> @hoogle vacuum
18:35:50 <lambdabot> No results found
18:37:27 <c_wraith> @hackage vacuum
18:37:28 <lambdabot> http://hackage.haskell.org/package/vacuum
18:42:38 <deteego> does anyone know if GHC 7.0.2 changed anything regarding quasi-quotation
18:43:01 <deteego> I am suddenly getting Parse error: naked expression at top level errors when building a yesod webserver
18:58:02 * hackagebot quicklz 1.5.0.3 - binding to QuickLZ compression library  http://hackage.haskell.org/package/quicklz-1.5.0.3 (AustinSeipp)
18:59:39 <gienah> dateego: yes, see here it suggests removing the $ http://docs.yesodweb.com/blog/hamlet6to7
19:32:36 <btutt> Hrm. is community.haskell.org still in lala land?
19:32:59 <dolio> No.
19:34:11 * hackagebot bbdb 0.3 - Ability to read, write, and examine BBDB files  http://hackage.haskell.org/package/bbdb-0.3 (HenryLaxen)
19:36:37 <miyako> hello
19:38:02 <shachaf> Why i ==> not working in @check?
19:38:18 <shachaf> @check \x -> x > 0 ==> x > 0
19:38:21 <lambdabot>   No instance for (Test.QuickCheck.Testable
19:38:23 <lambdabot>                     (Test.QuickCh...
19:44:07 <roconnor> @more
19:45:25 <dolio> It says there's no Testable instance for Gen Prop.
19:45:48 <dolio> @type (==>)
19:45:49 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
19:46:58 <dolio> I'm not sure why that's even needed.
19:48:45 <dolio> Or is Property = Gen Prop?
19:49:03 <dolio> @type forALl
19:49:04 <lambdabot> Not in scope: `forALl'
19:49:07 <dolio> @type forAll
19:49:08 <lambdabot> forall a prop. (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
19:49:27 <dolio> @check forAll undefined undefined
19:49:28 <lambdabot>   No instance for (Test.QuickCheck.Testable
19:49:28 <lambdabot>                     Test.QuickChe...
19:49:34 <dolio> Yeah, that must be it.
19:51:07 <dolio> Apparently lambdabot is missing the Testable instance for Properties somehow.
19:57:36 <Axman6> @check id :: Bool -> Bool
19:57:36 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> GHC.Bool.Bool'
19:57:53 <Axman6> @check (\x -> x :: Bool)
19:57:54 <lambdabot>   "Falsifiable, after 1 tests:\nFalse\n"
19:58:06 <Axman6> @check (\x -> x || not x)
19:58:07 <lambdabot>   "OK, passed 500 tests."
20:07:37 <djahandarie> dolio, perhaps because it resulted in 'overlapping instances' for functions?
20:07:39 <djahandarie> > id
20:07:40 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
20:07:40 <lambdabot>    arising from a use of `...
20:07:48 <djahandarie> Though it still has that problem anyways.
20:07:56 <dolio> Perhaps.
20:22:41 <dmwit> ?check id
20:22:42 <lambdabot>   "Arguments exhausted after 0 tests."
20:22:51 <dmwit> Axman6: What's going on there?
20:24:44 <shachaf> @check (\x -> x) :: Bool -> Bool
20:24:45 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool -> GHC.Bool.Bool'
20:24:54 <shachaf> @check ((\x -> x) :: Bool -> Bool)
20:24:55 <lambdabot>   "Falsifiable, after 4 tests:\nFalse\n"
20:25:11 <shachaf> Looks like this is being embedded in a text file badly or something.
20:28:03 <Axman6> dmwit: i was showing that @check isn't the same as QuickCheck, in that it only tests boolean functions, so it makes no sense for ==> to work
20:28:11 <dolio> @check ()
20:28:12 <lambdabot>   "Arguments exhausted after 0 tests."
20:28:42 <TheZimm> haskell is aweomse, just thought id say that
20:31:24 <dolio> The Testable instance for () just exhausts the arguments.
20:31:29 <dolio> And id defaults to () -> ().
20:32:20 <dmwit> Okay, the defaulting makes sense. Exhausting arguments after 0 tests still does not make sense.
20:32:26 <dmwit> (I would expect at least one test.)
20:35:29 <dolio> There are three (I think) situations for a quickcheck test.
20:35:36 <dolio> Passing, failing, and rejected.
20:36:10 <dolio> Passing means the test passed in the case of whatever was provided, failing means it failed.
20:36:31 <dolio> Rejected means the test said that the value generated was invalid.
20:36:35 <dolio> () always rejects.
20:37:04 <aavogt> @google haskell irulan
20:37:04 <dolio> id : () -> () takes an argument and rejects.
20:37:07 <lambdabot> http://www.doc.ic.ac.uk/~tora/irulan/
20:37:07 <lambdabot> Title: Irulan: High Coverage Testing of Haskell Programs
20:39:31 <dolio>  @check runs tests until it gets 500 successes, a failure, or until it makes N attempts (I don't know how many).
20:40:18 <dolio> It doesn't count attempts. So if you always reject, it will record 0 tests done.
20:59:33 <Lemon> I got two computers, one of which has an ancient version of GHC that I do not wish to use.
21:00:31 <Lemon> However, it is impossible to install a new GHC onto it due to certain limitations.
21:01:23 <Lemon> This computer, however, does have the latest compiler.
21:01:47 <Lemon> I'm trying to compile my programs here and somehow run them on the other computer.
21:02:02 <Lemon> I can't seem to be able to do it.
21:04:34 <ddarius> Typical GHC binaries don't have many dependencies.  You just compile and copy the executable.  They do need to be the same operating system and architecture though.
21:04:48 <Lemon> yeah, that didn't work.
21:05:12 <Lemon> it keeps complaining about missing or incompatible libraries.
21:05:37 <kmc> which ones?
21:05:43 <Lemon> Might be because I'm compiling it on Debian and trying to run it on RHEL.
21:05:54 <kmc> it's probably because RHEL is ancient
21:06:03 <kmc> can you give us the specific error message?
21:06:49 <Lemon> hold on
21:08:31 <Lemon> ./Tracer: /lib64/libc.so.6: version `GLIBC_2.9' not found (required by ./Tracer)
21:08:32 <Lemon> ./Tracer: /lib64/libc.so.6: version `GLIBC_2.7' not found (required by ./Tracer)
21:08:42 <Lemon> yeah
21:09:09 <kmc> both of them?
21:09:12 <kmc> strange
21:09:14 <Lemon> yes
21:09:45 <kmc> which version of RHEL are you trying to run this on?
21:10:26 <Lemon> I don't know the RHEL version, but here's `uname -a`
21:10:28 <Lemon> Linux unix39.andrew.cmu.edu 2.6.18-238.5.1.el5 #1 SMP Mon Feb 21 05:52:39 EST 2011 x86_64 x86_64 x86_64 GNU/Linux
21:10:45 <kmc> RHEL 5
21:11:01 <kmc> that's the latest RHEL 5 kernel iirc
21:11:10 <Lemon> with GHC 6.8.3
21:11:13 <Lemon> oh yeah, cutting edge.
21:11:14 <kmc> so 5.6 if you upgraded everything uniformly
21:11:52 <Lemon> I can't make any changes to the machine.
21:14:06 <kmc> can you do whatever you want to the other machine?
21:14:29 <Lemon> this one? yeah
21:14:32 <mee> Lemon: btw you find find out the redhat version by looking at /etc/redhat-release 
21:14:47 <Lemon> I don't want to have to install RHEL though
21:14:55 <kmc> well, you can install CentOS
21:15:02 <kmc> and you can do so in a VM or maybe even a chroot
21:15:06 <kmc> but, still no picnic
21:15:31 <kmc> you can try to persuade ghc to produce a really-totally-static binary
21:16:00 <Lemon> I used `ghc -static -foptl-static`
21:16:13 <kmc> and does "file" say your binary is static or dynamic?
21:16:14 <Lemon> wait, no
21:16:19 <Lemon> just -static
21:16:35 <kmc> or you can try to copy over the newer glibc and point your binary at it via LD_PRELOAD or such
21:16:39 <kmc> try -optl-static then
21:16:40 <Lemon> -foptl-static couldn't link due to undefined symbols in libx11
21:16:50 <kmc> oh, your program uses X too?
21:17:18 <Lemon> so it's "-optl-static"
21:17:26 <Lemon> yeah
21:17:29 <Lemon> It uses imlib
21:21:42 <kmc> :/
21:21:53 <kmc> i predict getting this to build statically will be a pain
21:22:34 <kmc> is it so bad to set up a CentOS 5 VM?
21:22:45 <Lemon> this is a netbook.
21:27:50 <Lemon> okay, fuck it
21:28:05 <Lemon> how old is 6.8.3 again?
21:28:28 <kmc> old
21:28:53 <kmc> what do you mean by "netbook"
21:30:02 <Lemon> atom processor, 1GB RAM.
21:30:10 <kmc> RHEL 5 is not a cutting edge distro
21:30:48 <kmc> it will run fine on that hardware, especially with no graphics
21:31:34 <kmc> it may not run concurrently with your other OS in a VM, due to lack of RAM
21:31:39 <shachaf> Oh, compiling things for RHEL 5 is fun.
21:32:27 <shachaf> Which version of RHEL 5 is it?
21:33:09 <kmc> shachaf, do they change the libc ABI version in RHEL minor version bumps?
21:33:44 <shachaf> kmc: I thought they changed it between 5.1 and 5.5.
21:33:51 <shachaf> On the other hand, no, that doesn't make sense.
21:33:53 <shachaf> Never mind.
21:34:14 <kmc> i think the sorts of people who pay for RHEL would be upset by that
21:34:27 <kmc> and the sorts of people who'd want won't run RHEL
21:34:33 <shachaf> Right, now I remember that they went to a great deal of trouble *not* to change the ABI.
21:34:49 <shachaf> To the point of adding new system calls to the kernel but not adding libc calls for them.
21:35:06 <kmc> you pay Red Hat because they backport the important fixes from upstream to the old kernel / libc / etc. so that you don't have to recompile your terrible homegrown apps
21:35:23 <kmc> shachaf, yeah, i had to use futex and inotify on RHEL 4 once
21:35:47 <kmc> it's not so bad, you just need extra header files in your project
21:35:53 <shachaf> kmc: The other odd thing is that they add system calls to syscall.h, but when you call them, they just return ENOSYS.
21:36:11 <kmc> heh
21:36:27 <shachaf> Or they added -- I think it was timerfd_create but not timerfd_settime.
21:36:33 <shachaf> Which made it useless.
21:36:35 <shachaf> Or something like that.
21:36:50 * shachaf doesn't understand the RHEL backporting philosophy.
21:37:30 <shachaf> kmc: (Well, not just header files -- you need wrappers around the system calls too. Occasionally those aren't trivial.)
21:38:14 <kmc> the wrappers are a small header file in the simple case, but you're right that it can be much worse
21:39:20 <kmc> people have argued that linux and glibc should be more tightly coupled projects
21:39:32 <shachaf> The ENOSYS/partial system calls thing doesn't make any sense to me, though.
21:39:55 <kmc> i saw some proposal on LWN about putting a libc into the kernel and then exporting it to every process through the VDSO
21:40:08 <shachaf> Is Linux usable without glibc?
21:40:18 <kmc> shachaf, so they add constants in the header file, and nothing else?
21:40:18 <shachaf> Hmm, actually, Android doesn't use it, right?
21:40:27 <kmc> shachaf, sure, lots of embedded Linux systems use an alternate libc
21:40:37 <kmc> and you can write code that doesn't use any libc
21:41:03 <kmc> android has some frankenstein's monster libc which is mostly from BSD
21:41:06 <kmc> (and is quite incomplete)
21:41:18 <kmc> uclibc is popular
21:42:12 <shachaf> kmc: More or less, as far as I could tell.
21:42:16 <kmc> i wonder if anyone's managed to run the FreeBSD userland on the Linux kernel
21:42:54 <shachaf> We ended up deciding to porting the code not to use timerfd/eventfd at all.
21:43:05 <kmc> sad
21:43:51 <kmc> shachaf, can i ask why you had to program for RHEL?
21:44:21 <shachaf> kmc: Because people use it.
21:44:34 <shachaf> It was actually mostly CentOS, I think.
21:44:37 <btutt> yep. silly customers think they know what they're doing. ;)_
21:45:50 <lispy> We don't have any packages on Hackage for doing native graphics on OSX do we?
21:45:59 <shachaf> kmc: A lot of people use RHEL/CentOS, actually.
21:46:11 <shachaf> The annoying thing is that they use 5.1 or 5.5 or something instead of upgrading.
21:47:05 <Xilon> lispy: Native as in Quartz? There are ObjC bindings that you could use...
21:47:33 <kmc> shachaf, yeah, it makes sense if you're writing software for use by Other People
21:47:37 <lispy> Xilon: Where are the bindings? I have a cabal package here that has objective-c files but cabal thinks they are linker scripts so it can't build it
21:48:18 <Xilon> lispy: the hoc package I believe
21:48:33 <lispy> hmm
21:48:48 <lispy> I can't tell if hoc is developed and it's not on hackage :(
21:48:49 <shachaf> kmc: Yes, it would be much nicer if to write software no one else used, surely. :-)
21:49:09 <lispy> not on hackage = doesn't exist
21:49:31 <btutt> think its on googlecode
21:49:48 <btutt> hoc isn't actively developed, no.
21:49:50 <Xilon> lispy: I think it's generally not recommended to use Haskell for Cocoa dev. Seems Yi uses CPP to do the Cocoa GUI (just looking at the cabal). http://code.google.com/p/hoc/
21:50:06 <Xilon> By Cocoa dev I specifically mean the GUI part
21:50:22 <shachaf> lispy: That's why I don't use GHC.
21:50:23 <lispy> I don't think I can use HOC
21:51:07 <Xilon> Wonder why Yi uses C++...
21:51:53 <blbrown_win3> http://stackoverflow.com/questions/5287622/haskell-gtk-double-buffering-with-primitives  Anyone worked with gtk/haskell and done double buffering.
21:52:19 <kmc> shachaf, i hope you don't also have to use RHEL on your development workstation
21:52:30 <shachaf> kmc: No, no, just for backports.
21:52:40 <lispy> blbrown_win3: I've done double buffering with haskell and GLUT, but not gtk.  I find gtk to be extremely painful and I avoid it whenever I can.
21:52:41 <ddarius> The IAS "camera men" are horrible.
21:52:44 <dibblego> our employer has an internal hackage-like server that you can point cabal at
21:53:00 <kmc> blbrown_win3, have you found info about doing gtk double buffering in other languages?
21:53:02 <blbrown_win3> lispy, I do to, but I was expanding
21:53:16 <blbrown_win3> kmc, yea, that is probably my next step, I guess the gtk library is just a wrapper
21:53:35 <shachaf> s/back//
21:53:46 <blbrown_win3> lispy, plus, I still don't feel you need opengl if you are doing basic 2d primitives
21:54:22 <kmc> it's not about "need", it's about what's easiest
21:54:47 <kmc> but if you need actual GUI widgets, OpenGL is no help
21:54:52 <Xilon> blbrown_win3: I thought Cairo was for 2d drawing in the GTK toolset?
21:55:03 <kmc> GTK and OpenGL are solving totally different problems
21:55:20 <blbrown_win3> kmc exactly
21:55:52 <blbrown_win3> Xilon, cairo is for vector grpahics
21:55:54 <blbrown_win3> graphics
21:56:01 <Xilon> ah
21:56:13 <blbrown_win3> Me, I just want to render a pixel and a square
21:56:32 * lispy finds the state of gui libs for haskell to be frustrating
21:56:38 <btutt> i just wish Qt had haskell bindings
21:56:44 <lispy> I just want to create a full screen opengl viewport.
21:56:57 <kmc> lispy, even GLUT will do that
21:57:18 <kmc> i've used GLUT and SDL for that (don't recall if I ever used SDL in Haskell, though)
21:57:25 <Xilon> lispy: OpenGL shouldn't be bad, but yeah, GTk/Qt/Cocoa/Win32 etc could have better support
21:57:29 <lispy> kmc: Yes, and that's what I used to use.  The thing about glut is that people have to install it separately on windows and put a dll in the right place and it's no longer maintained.
21:57:31 <blbrown_win3> lispy, I hate to be a buzz kill, but opengl shouldn't be used for everything graphics.  There are still many computers that don't support opengl acceleration
21:57:37 <lispy> The problem with SDL is LGPL
21:57:37 <kmc> oh yeah, windows
21:57:43 * hackagebot warp-static 0.0.1 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-0.0.1 (MichaelSnoyman)
21:57:57 <blbrown_win3> opengl without a graphics card can be frustrating
21:58:07 <blbrown_win3> without a 3d graphics card
21:58:12 <kmc> blbrown_win3, why is OpenGL with software rendering worse than other APIs with software rendering?
21:58:57 <lispy> blbrown_win3: I don't even know why you're telling me this.  I obviously want to use the opengl api.  So of course I'm trying to use the opengl api.  But to do that I need a gui library that can give me a suitable window.
21:59:00 <kmc> why is LGPL a problem lispy?
21:59:13 <lispy> kmc: because with GHC if you link to LGPL your code is LGPL
21:59:27 <lispy> lose of license freedom
21:59:27 <kmc> that may be true of Haskell libraries
21:59:32 <lispy> loss*
21:59:36 <blbrown_win3> kmc, because you if you invoke the 3D graphics pipeline without a 3d accelerated graphics card, you are forcing the operating system to do the software rendering which is a lot slower if it works at all
21:59:44 <kmc> erm yes
22:00:00 <pikhq_> lispy: Patently false. You "merely" need to distribute the LGPL .a's seperately.
22:00:09 <pikhq_> Erm, your own .a's, sorry.
22:00:24 <kmc> lispy, the Haskell SDL binding is BSD-licensed, only SDL itself is LGPL
22:00:46 <pikhq_> The LGPL .a's can be left alone just fine if you don't modify them. If you do, well, standard GPL stuff applies.
22:01:13 <lispy> Unless a lawyer tells me otherwise, I would consider things like that to be effectively LGPL.
22:01:29 <kmc> i would think a GHC-compiled Haskell binary containing only BSD code, which dynamically links to the already-installed LGPL SDL library, would be quite unproblematic
22:01:32 <pikhq_> lispy: Letter of the LGPL.
22:01:40 <kmc> but IANAL
22:02:00 <lispy> pikhq_: I was talking to kmc.
22:02:11 <Xilon> kmc: Wasn't that the whole point of LGPL (as opposed to GPL)?
22:02:14 <lispy> Anyway, I don't want to use LGPL things because it's a headache.
22:02:22 <btutt> The LGPL requires you to be able to re-link a different version of the LGPL library with your code. So the easiest way to comply is to rely on shared library LGPL. (IIRC)
22:02:25 <btutt> It is.
22:02:53 <shachaf> http://www.libsdl.org/license-lgpl.php
22:02:55 <lispy> LGPL and GHC do not play nicely.
22:03:02 <kmc> Xilon, yes; the problem is that GHC links all Haskell code statically by default, and this incurs extra LGPL obligations
22:03:05 <shachaf> LGPL treats static and dynamic linking differently?
22:03:10 <shachaf> That's ridiculous.
22:03:13 <kmc> but that's irrelevant in the SDL case
22:03:25 <Xilon> shachaf: That's (L)GPL :P
22:03:39 <Xilon> Viral licenses are annoying
22:03:45 <Jafet> ...and the evil virus triumphs over our bewildered heroes once again
22:03:51 <btutt> shachaf: No, but if you static link LGPL libraries then you must provide your .o's to customers so that customers can relink. (ugh)
22:03:57 <Xilon> All in the name of "freedom" :P
22:04:00 <kmc> i have a cool idea!  let's have a huge flamewar about licenses!
22:04:03 <kmc> you go first
22:04:06 <blbrown_win3> most companies don't care about open licenses, I don't know why developers are. hehe
22:04:22 <kmc> btw the last time I uploaded an FFI binding with a license different from the library it wrapped, everyone threw a huge hissy fit
22:04:22 <shachaf> btutt: That's not what that page says.
22:04:40 <blbrown_win3> damn open source developers and their sainthood
22:04:44 * lispy uses BSD3 for everything to make life simple and free
22:04:45 <kmc> but it's clearly useful to have BSD-licensed bindings to non-BSD-licensed libs
22:04:47 <kmc> as in this SDL case
22:04:54 <kmc> so i don't see why i got all this hate
22:04:57 <Xilon> blbrown_win3: Those companies can get sued
22:05:08 <kmc> the Win32 API bindings are also BSD licensed
22:05:09 <blbrown_win3> Xilon, they can and I bet they never incur major losses.  
22:05:32 <btutt> that was the idea behind the original version of the LGPL as linked to with the SDL link.
22:05:38 <lispy> So, getting back to my original need.  Why don't we have GUI bindings for OSX?
22:05:43 <systemfault> Heh.
22:05:43 <blbrown_win3> Xilon, but then I guess if an open project violates open standards, their projects reputation is hurt
22:05:46 <btutt> ObjC is a pain
22:05:50 <btutt> (thats my guess)
22:05:57 <systemfault> GPL is about freedom of the code... not the programmer.
22:05:58 <Xilon> btutt: yup
22:06:00 <pikhq_> blbrown_win3: Developers in general are pretty much *forced* to be aware of copyright law. Or else get *royally* screwed the next time a company takes notice.
22:06:23 <blbrown_win3> pikhq_, forced by whom?
22:06:43 <lispy> I really don't like the idea of having my code only work on X11 and Win32, but that seems to be what I'm faced with unless I write my own binding to OSX.
22:06:45 <pikhq_> blbrown_win3: Forced by desire-to-not-go-bankrupt.
22:07:15 <Jafet> lispy: because no one wrote them!
22:07:17 <Xilon> lispy: I'd suggest just writing the GUI in ObjC and calling into your Haskell code
22:07:39 <Xilon> Probably a pita to get working though
22:07:43 <lispy> Xilon: But, Cabal can't build objective C
22:07:44 <kmc> i suggest writing a webapp
22:07:47 <btutt> Are Quartz apis ObjC as well?
22:07:54 <kmc> (but probably not feasible, if you're talking OpenGL and such)
22:08:02 <systemfault> btutt: Yeah.. Cocoa is ObjC
22:08:04 <Xilon> btutt: I think so, but you wouldn't want to use Quartz itself
22:08:09 <lispy> kmc: webgl is viable these days it looks.
22:08:11 <gienah> lispy: there is QtHaskell, license is GPL, Qt C++ library license is LGPL
22:08:18 <lispy> kmc: input handling is still a bit sketchy though
22:08:25 <systemfault> Hmm right, Qt might be an answer.
22:08:58 <btutt> Ooh. QtHaskell... 
22:09:10 <gienah> http://qthaskell.berlios.de/
22:09:12 <Xilon> lispy: Maybe not with the "Simple" build type, but you could write a Makefile or whatever - compiling ObjC outside of Xcode is a pain anyway though. At least LLVM supports it now
22:09:18 <lispy> I should qualify.  I'm really looking for BSD3 (or BSD3 compatible) dependencies.
22:09:47 <kmc> lispy, and you already heard my argument that SDL is fine?
22:10:15 <kmc> LGPL libraries are dynamically linked by all kinds of totally closed no-source-at-all programs
22:10:16 <btutt> If its a shared library with a BSD Haskell binding you're fine
22:10:19 <kmc> that's why it exists
22:10:20 <Xilon> Btw: http://hackage.haskell.org/trac/ghc/wiki/ObjectiveC looks interesting
22:10:22 <lispy> kmc: I heard it, but it failed to persuade me.
22:10:43 <kmc> lispy, so do you think that every non-free video game etc. for Linux is in violation of the LGPL?
22:10:56 <kmc> i run Eagle CAD on my Linux machine; is it in violation by linking to glibc?
22:11:04 <kmc> i don't see what the point of LGPL is in your worldview
22:11:22 <lispy> Xilon: interesting, but that page hasn't been updated by the authors for 2 years :( http://hackage.haskell.org/trac/ghc/wiki/ObjectiveC?action=history
22:11:45 <Xilon> Yeah, it's probably a massive undertaking...
22:12:00 <btutt> Ugh. QtHaskell is a GPL binding
22:12:14 <Xilon> Would be cool to write ObjC via Haskell at runtime though
22:12:44 <kmc> we have Language.C
22:12:51 <kmc> Objective C is a pretty small extension in terms of syntax
22:13:19 <Xilon> kmc: Not in terms of runtime though
22:14:05 <btutt> *wonders if a PySide like approach for Qt would make sense in combination with the Qt binding idea of HQK*
22:14:10 <Xilon> There is a C api to ObjC though, but I'm not sure if it requires ObjC
22:16:11 <lispy> kmc: Do all those linux games use GHC?
22:17:03 <gienah> btutt: yes QtHaskell is dual licensed, the author wants payment if it is used in a commercial app that makes money, or otherwise its GPL (the author explained this to me in an email when I asked about its licensing)
22:17:26 <btutt> ugh
22:18:04 <Xilon> payment for bindings? :S
22:18:11 <lispy> kmc: and you said you're not a lawyer.  As I said before, I won't trust bundling LGPL dependencies in a GHC compiled Haskell program until a lawyer explains to me that it is safe.
22:18:23 <lispy> kmc: I don't want to spend my time doing crap like this: http://www.haskell.org/pipermail/haskell-cafe/2007-March/023164.html
22:19:11 <shachaf> lispy: I think kmc was talking about dynamic linking.
22:19:16 <kmc> lispy, er, but that's a LGPL haskell lib
22:19:31 <kmc> i'm talking about a BSD haskell lib which dynamically links a LGPL lib
22:19:37 <kmc> (written in C, not like that's relevant)
22:20:00 <kmc> what annoys me is that this shit gets in the way of writing software
22:20:21 <kmc> that's both a point against the GPL and a point against the people with paranoid / extreme anti-GPL views
22:21:02 <Xilon> I think the anti-GPL views are precisely due to issues like this
22:21:02 <systemfault> EULA.. GPL.. different views, same extremism.
22:21:17 <ddarius> The camera work for this crap is infuriating.
22:21:19 <systemfault> BSD is "balance"
22:21:36 <kmc> systemfault, ugh, i hate that kind of reasoning
22:21:52 <kmc> Xilon, except this *isn't* an issue.  like i explained, this is totally within the letter and spirit of the LGPL; lispy is just being paranoid
22:22:24 <shachaf> ddarius: For what?
22:23:03 <Xilon> kmc: It's his prerogative to want confirmation from a lawyer
22:23:31 <kmc> sure
22:24:05 <kmc> and i'm entitled to spend $600 an hour to ask a lawyer if i'm allowed to take a shit in my own home but i'm pretty sure the answer is "yes"
22:24:48 <Xilon> kmc: You don't get a license with your home with a whole bunch of legal jargon about what you can and can't do in it though ;)
22:25:06 <kmc> yes you do
22:26:06 <kmc> one major advantage of BSD is that the license is short
22:26:12 <kmc> shrug
22:26:14 <kmc> let's talk about Haskell
22:27:56 <shachaf> Is there a musical piece called "The Haskell Prelude"?
22:28:11 <gienah> lispy: clause 6 in http://code.haskell.org/gtk2hs/gtk/COPYING says that gtk2hs has a static linking exception to the LGPL, hopefully that helps
22:29:59 <mgsloan> someone should create an AST --> music in order to play the prelude
22:32:55 <lispy> gienah: Well, I'm not about to start using gtk
22:33:12 <lispy> gienah: I want people to be able to build my program, even on osx
22:34:56 <lispy> I think I sucessfully built something using gtk2hs once and then it looked ugly.
22:35:03 <lispy> Not impressed
22:36:51 <gienah> lispy: wxHaskell also has a static linking exception to the LGPL: http://haskell.org/haskellwiki/WxHaskell/License
22:37:15 <btutt> I've heard good things about wxWindows from folks in the Python universe
22:37:29 <Ptival> haskellers: how would you represent a finite set of named options? (for instance, {South, North}, {}, {West}, among the finite elements North South East West)
22:38:15 <lispy> btutt: Yeah, it's much nicer looking than gtk
22:38:23 <ddarius> shachaf: http://video.ias.edu/math-topologyrdm
22:38:51 <gienah> some trivia: micro$oft forced the name to be changed from wxWindows to wxWidgets
22:38:52 <lispy> Ptival: algebraic datatypes and list, probably
22:39:06 <Ptival> list?
22:39:23 <lispy> Yeah, you know, haskell lists
22:39:31 <lispy> > [1..3]
22:39:32 <lambdabot>   [1,2,3]
22:40:23 <Ptival> I think I should use a Data.Set
22:40:28 <lispy> data Direction = Noth | East | South | West deriving (Eq, Ord, Enum, Bounded, Show, Read); options1 = [South, North]; options2 = []; options3 = [West]
22:41:28 <Ptival> that does not enforce unicity but you can manage that for sure
22:41:33 * lispy considers wx, but that is a huge dependency for such a tiny demo program.  /me goes to see if it builds on windows/osx without installing a ton of crap.
22:41:53 <shachaf> Data.Set seems reasonable.
22:42:06 <shachaf> Clearly the correct solution is a 4-bit integer.
22:42:49 <Ptival> yes, ideally something like a bitmask would be perfect for me (but I'd like to be able to name each bit too)
22:42:56 <ddarius> data Directions = None | North | South | East | West | NorthEast | ...
22:43:49 * shachaf hopes Ptival is making a text-based adventure game.
22:43:53 <Ptival> ddarius: I need to scale this (the directions were just an example)
22:44:01 <shachaf> Aw.
22:44:07 <Ptival> sorry shachaf (but that's a good idea thanks :p)
22:44:39 <lispy> bah, wxcore won't install.
22:44:48 <lispy> GUI stuff is a pain.
22:44:53 <ddarius> Ptival: I wasn't being serious anyway.
22:45:12 <Ptival> ddarius: ok, my bad
22:45:44 <lispy> and the source for wxhaskell seems to have disappeared :(
22:45:51 * lispy concludes that wxhaskell is dead
22:46:44 <Ptival> (hopefully, parents of disappearing kids do not jump to conclusions as fast as lispy)
22:48:06 <lispy> Ptival: well, I'm not only basing it on that.  The latest news is from 2009.
22:51:14 <kamatsu> currently working on DFA minimization in Isabelle/HOL?
22:51:32 <kamatsu> does anyone have any Haskell or ML implementations of a really small (code-size wize) algorithm for doing it?
22:52:01 <kamatsu> the one i tried was unbearable to try and verify.
22:53:54 <btutt> wxHaskell bits are available via sourceforge
22:54:07 <btutt> http://sourceforge.net/projects/wxhaskell/files/
23:01:21 <rehat> hi
23:02:05 <Skola> good morning, is it true that haskell.cgi scripts run on any server with cgi support?
23:03:11 <c_wraith> Skola: that's the definition of cgi
23:04:24 <Skola> any basic scripts compiled with # ghc --make -o name.cgi name.hs
23:04:33 <Skola> script doesn't sound right, but
23:04:38 <c_wraith> program :)
23:04:39 <Skola> you get the picture
23:04:42 <Skola> yes
23:04:56 <Skola> my vocab is a bit dirty coming from Python ;)
23:04:58 <rehat> I'm kinda new with haskell.  I'm trying to make a insert sort function with a working insert function but not sure how to get it to work 
23:06:04 <c_wraith> cgi is just an interface for programs to talk to their environment with in order to standardize request handling.  Any program that uses the cgi interface (command line and environment in (stdin also for posts), stdout out) will work with a server that will call cgi programs.  language is irrelevant.
23:06:29 <Skola> thanks for enlightening me :)
23:06:52 <c_wraith> rehat: just so I can answer better, is this homework, or just something you want to learn on your own?
23:07:20 <rehat> it is hw but I'm stuck
23:07:25 <c_wraith> ok.
23:07:36 <c_wraith> Can you put whatever you've got so far on hpaste.org?
23:09:51 <rehat> http://hpaste.org/44739/insert_sort
23:10:37 <c_wraith> ok, your insert function looks good
23:10:37 <rehat> kind of lost as to what to put as the first argument of my insert function inside my insertSort function
23:11:17 <c_wraith> is there a requirement you do it with a list comprehension?  It might be easier without
23:11:38 <rehat> nah, I just thought that would work
23:11:54 <CADD> hey all, i have a question for you guys.
23:12:18 <CADD> so, i am creating a type declaration, and i need to have a list in it of unknown size
23:12:21 <rehat> I was going to do it with recursion 
23:12:22 <rehat> insertSort [] = [] insertSort (x:xs) = insert xs x ++ (insertSort xs)
23:12:40 <rehat> but still not sure what to put as the first argument of insert
23:12:55 <c_wraith> rehat: well, so, conceptually, you need to keep track of two things: a list that's being sorted, and a list of values to sort.
23:13:51 <rehat> hmm
23:13:53 <c_wraith> rehat: err, the first is a list that's being built up while kept sorted
23:13:58 <c_wraith> To be more clear about it
23:14:08 <rehat> right
23:14:46 <rehat> I'm just not clear how to build that list through another function in recursion
23:15:17 <c_wraith> So, in some sense, you have an accumulator and wish to update the accumulator with each element in this list.
23:15:45 <Jesin> um
23:15:49 <Jesin> newtype Ordinal = O [Ordinal] deriving Eq
23:15:52 <c_wraith> That's a common recursion pattern, and there's a standard higher-order function for using that pattern.
23:15:54 <Jesin> I just saw that code
23:16:23 <c_wraith> But ignore that standard function for now, and just do it by hand, I think.
23:16:31 <c_wraith> It will be more instructive, I think.
23:17:18 <Jesin> :t unfold
23:17:19 <lambdabot> Not in scope: `unfold'
23:17:20 <c_wraith> Just think of insertionsort as building up a sorted list while tearing down the unsorted list...  This will require you to write another helper function
23:17:33 <Jesin> :k Mu
23:17:33 <lambdabot> (* -> *) -> *
23:18:28 <rehat> ok I'll look into that,  thanks for the help
23:20:27 <CADD> any help? so I have a type declaration that goes something like this: data Constructor = Constructor { Number :: Int , list :: [Type] }, but it is saying that the type requires arguments, i just want it to take in a list of types that is passed in.
23:21:20 <c_wraith> CADD: do you need something like data Foo a = Constructor { number :: Int, list :: [a] } ?
23:21:24 <Jesin> @where Mu
23:21:25 <lambdabot> http://www.catb.org/jargon/html/M/mu.html
23:21:33 <Jesin> @src Mu
23:21:33 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
23:21:40 <Jesin> @hoogle Mu
23:21:40 <lambdabot> Text.Html multiple :: HtmlAttr
23:21:40 <lambdabot> Text.XHtml.Frameset multiple :: HtmlAttr
23:21:40 <lambdabot> Text.XHtml.Strict multiple :: HtmlAttr
23:21:47 <c_wraith> Jesin, it's just in lambdabot
23:22:00 <Jesin> aww
23:22:36 <Jesin> hmm, btw
23:22:39 <Jesin> isn't Mu Maybe
23:22:50 <Jesin> isomorphic to data Nat = Z | S Nat
23:22:51 <c_wraith> But it's also just that one line.  You can copy it into your own file and work with it.  Well, adding a "deriving Show" at the end
23:22:51 <Jesin> ?
23:22:55 <c_wraith> yes, it is
23:22:59 <Jesin> even with the correct deriving Ord
23:23:01 <Jesin> lol
23:23:26 <c_wraith> It's somewhat more annoying to work with, though.
23:23:36 <CADD> no, not exactly, i think i will be calling it like foo number [type, type, type, ...]
23:23:50 <emartinj> Hello. I have a problem using the ffi and is looking fore some help. Also this is my first time on IRC since the 90:s so please excuse my lack of ettiquette...
23:24:09 <c_wraith> CADD: I'm really not clear what you're looking for
23:24:20 <CADD> it worked with the previous consructor in my code, but i am passing in thoes types into a list into that constructor
23:24:56 <c_wraith> emartinj: Go ahead and ask your question...  Someone might know and chime in.  Now's not a particularly active time, though, so if you don't get an answer in a few minutes, you can ask again later
23:25:21 <CADD> so i create a type, fill it, then create a list of those types, and pass it into this constructor i am having trouble with
23:27:22 <Jesin> :t [[],[],[[].[[]]]]
23:27:23 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
23:27:23 <lambdabot>     In the first argument of `(.)', namely `[]'
23:27:23 <lambdabot>     In the expression: [] . [[]]
23:27:27 <Jesin> :t [[],[],[[],[[]]]]
23:27:28 <lambdabot> forall a. [[[[a]]]]
23:27:35 <Jesin> :t [[],[],[[],[[]]]] :: Mu []
23:27:36 <lambdabot>     Couldn't match expected type `Mu []' against inferred type `[a]'
23:27:36 <lambdabot>     In the expression: [[], [], [[], [[]]]] :: Mu []
23:27:57 <Jesin> :t [In[],In[],In[In[],In[In[]]]]
23:27:58 <lambdabot> [Mu []]
23:28:08 <Jesin> :t In[In[],In[],In[In[],In[In[]]]]
23:28:09 <lambdabot> Mu []
23:29:12 <miyako> I'm just learning haskell, and I've been working on some code, I was wondering if someone wouldn't mind taking a look and pointing out where I might look at improving
23:29:20 <emartinj> ok. I am trying to wrap a MIP solver (Coin CBC). The solver comes with a C interface and I get segfaults when using newForeignPtr to hook up a finalizer. It works when I explicity call the finalizer but I would like the convenience of having the GC help me with memory management. This is on windows 7 32 bit using the latest haskell platform. The dll loads ok and is using stdcall.
23:29:30 <miyako> *taking a loot at a short bit of code I wrote that is
23:29:33 <CADD> c_wraith: I can explain further, i am a little stuck
23:30:06 <c_wraith> > > iterate (In . Just) $ In Nothing -- Jesin, this might amuse you
23:30:07 <lambdabot>   <no location info>: parse error on input `>'
23:30:16 <c_wraith> > iterate (In . Just) $ In Nothing
23:30:18 <lambdabot>   [In Nothing,In (Just (In Nothing)),In (Just (In (Just (In Nothing)))),In (J...
23:30:51 <Jesin> XD
23:31:17 <shachaf> miyako: You should @paste it.
23:31:24 <Jesin> > iterate (Just . In) Nothing
23:31:26 <lambdabot>   [Nothing,Just (In Nothing),Just (In (Just (In Nothing))),Just (In (Just (In...
23:31:37 <miyako> @paste http://pastebin.com/0Qdsfja2 
23:31:37 <lambdabot> Haskell pastebin: http://hpaste.org/
23:31:48 <Jesin> @let this f = f Nothing
23:31:50 <lambdabot>  Defined.
23:31:50 <shachaf> That works too. :-)
23:31:58 <Jesin> > this (Just . In)
23:32:00 <lambdabot>   Just (In Nothing)
23:32:03 <Jesin> aww
23:32:07 <Jesin> @undefine
23:32:15 <Jesin> @let this f = iterate f Nothing
23:32:16 <lambdabot>  Defined.
23:32:19 <Jesin> > this (Just . In)
23:32:20 <lambdabot>   [Nothing,Just (In Nothing),Just (In (Just (In Nothing))),Just (In (Just (In...
23:32:29 <Jesin> :D
23:32:53 <miyako> I haven't really done much testing yet, just wondering if I'm even taking the right sort of approach- this is the first time I've tried to do much FP and I don't want to be writing C in haskell so to speak
23:33:02 <Jesin> > map out $ this (Just . In)
23:33:03 <lambdabot>   Couldn't match expected type `L.Mu t'
23:33:03 <lambdabot>         against inferred type `Data.M...
23:33:07 <Jesin> > map In $ this (Just . In)
23:33:09 <lambdabot>   [In Nothing,In (Just (In Nothing)),In (Just (In (Just (In Nothing)))),In (J...
23:33:23 <Jesin> @undefine
23:33:56 <Ptival> miyako: what is v2 in vertex_add_edge1?
23:34:17 <miyako> v1 and v2 are vertexes 1 and 2- perhaps I should name my variables better
23:34:31 <Ptival> but v2 is not used?
23:34:48 <miyako> your right, that's a bug
23:34:52 <miyako> :)
23:35:22 <miyako> it should be adding an edge from v1 to v2, but it's adding an edge from v1 to v1 =\
23:35:59 <Ptival> (I would also not use "i" for a name but eh ^^)
23:37:39 <Ptival> miyako: your edges will never need a source?
23:38:31 <miyako> Ptival: I thought about that, since I'm focusing specifically on a directed graph I'm not sure that I need to store the source vertex
23:40:25 <Ptival> miyako: my concern is that, in a path, I guess you will infer the source as being the previous edge's dest, but then when you do edge_cmp, you have to be conscious that edges with different sources but same destinations will be considered equal
23:40:53 <Ptival> might be safe with what you're doing with these structures, I don't know
23:41:24 <CADD> hpaste.org/44740/thanks
23:41:46 <miyako> Ptival: yeah, I was thinking about that earlier, I think I should remove the edge_cmp function because it actually doesn't make a lot of sense for what I'm doing anyway
23:41:56 <Ptival> ok
23:44:12 <CADD> the problem is in population
23:44:51 <CADD> it is saying that the type Coin requires arguments
23:45:15 <Ptival> @pl if f a b c then Nothing else Just (g a b c)
23:45:15 <lambdabot> if' (f a b c) Nothing (Just (g a b c))
23:46:28 <Ptival> @hoogle Bool -> (a -> b) -> Maybe b
23:46:28 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
23:46:28 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
23:46:28 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
23:47:11 <Ptival> @hoogle Bool -> b -> Maybe b
23:47:12 <lambdabot> Control.Exception assert :: Bool -> a -> a
23:47:12 <lambdabot> Control.OldException assert :: Bool -> a -> a
23:47:12 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
23:47:37 <CADD> anyone?
23:47:43 <CADD> please?
23:48:39 <Jonno_FTW> one moment
23:49:17 <Jonno_FTW> CADD: at what line do you get the error?
23:49:53 <CADD> in population.hs
23:49:57 <CADD> on the declaration
23:50:27 <CADD> data Population = Population { generation :: Int, coins :: [Coin] }
23:51:58 <Ptival> CADD: I get an error in getPopulation... what's that [Coin]?
23:52:41 <CADD> main is kinda important too, because that is what i am trying to do, population is going to hold a list of coins
23:53:33 <CADD> but its supposed to be a (empty) list of coins
23:53:55 <Ptival> I don't understand you
23:54:29 <CADD> coin is a custom type
23:54:31 <Jafet> The empty list is [].
23:54:37 <emartinj> I have some code using the ffi that segfaults when using ForeignPtr and a finalizer. http://hpaste.org/44741/segaulting_on_windows 
23:54:42 <CADD> and i want it to hold a list of coins
23:54:57 <Ptival> yes, but this is working
23:55:09 <emartinj> help appreciated.
23:55:13 <Ptival> for your code, the error is in getPopulation, it should return [] and not [Coin] :\
23:55:33 <CADD> it says that it requires two arguments
23:55:52 <CADD> in the type declaration
23:56:00 <CADD> for the list of coins
23:56:19 <Ptival> sure
23:56:47 <CADD> ill check that out, but, wouldnt that just return an empty list?
23:56:55 <Ptival> yes
23:57:26 <CADD> ok, yeah, i want it to return the list of coins that gets passed into the constructor
23:57:36 <Ptival> also, you do not have to write getGeneration and getPopulation...
23:58:01 <CADD> i am brand new to this :D
23:58:09 <CADD> what should it be instead?
23:58:29 <Ptival> ok, so when you write data Population = Population { generation :: Int, coins :: [Coin]} 
23:59:01 <Ptival> you get generation :: Population -> Int, and coins :: Population -> [Coin] for free
23:59:37 <CADD> ok, so how to i call them to get the ints and [Coin]
