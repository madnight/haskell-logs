00:12:54 <ZX> helo
00:18:34 <simsin> hi, i'm a newbie.  I wish to know what I had done wrong in this expression "doubleMe x = x = x"
00:18:46 <Zao> simsin: What is your intent?
00:19:53 <simsin> Zao, I was learning the language and two days ago I did it in GHCi and it works but today it isn't.  Sorry my expression should be " doubleMe x = x+ x"
00:20:32 <Zao> If you're doing it in GHCi, you probably want    let doubleMe x = x + x
00:20:58 <Zao> > let doubleMe x = x + x in doubleMe 9001
00:20:58 <lambdabot>   18002
00:21:20 <simsin> Zao, thank you very much.  I'll try that now. simsin
00:21:29 <Zao> simsin: That is, if you're doing it on directly in GHCi. If in a source file, a toplevel 'doubleMe x = x + x' is fine.
00:26:18 <simsin> now I got this: ":2:0: parse error (possibly incorrect indentation) " what could be wrong??
00:31:17 <simsin> I had it here again: "let doublÂ­eMe x = x + x not an expression: `let doubleMe x = x + x'
00:31:45 <Zao> Is that - in the middle of the word intended?
00:33:31 <simsin> the source file looks like this:let doubleMe x = x + x let squareMe x = x^2 let doubleSquareMe x = doubleMe x + squareMe x      "
00:34:30 <Zao> If it's in a source file, you probably want something along the lines of: http://hpaste.org/44617/sim
00:34:42 <hpaste> LarsViklund pasted "sim"  http://hpaste.org/44617
00:35:00 <Zao> You also seem to have missed providing an argument to 'squareMe' on line 7.
00:37:55 <simsin> Zao, thanks.  I'll do another source file to see how it goes but now here in TryHaskell it gives me this error :"
00:38:04 <simsin>  doubleMe x = x + x <no location info>: parse error on input `='
00:44:11 <simsin> Zao, no luck.  It didn't work.  Even when I use a source that works half an hour ago, I still got this 'parse' error
00:48:00 <nlogax> simsin: http://codepad.org/0jFEqtY1 if you are in ghci (or tryhaskell), you need `let`, otherwise, that seems to work fine
00:55:44 <simsin> Zao, nlogax, thank you.  I tried everything and still got a 'parse error' I'm getting frustrated.
01:19:33 <tomh> any textmate user here knows where to get the haskell bundle? it seems to be removed from the official repo
01:24:42 * hackagebot JSON-Combinator 0.2.6 - A combinator library on top of a generalised JSON type  http://hackage.haskell.org/package/JSON-Combinator-0.2.6 (TonyMorris)
01:25:42 * hackagebot hakyll 3.0.1.3 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.0.1.3 (JasperVanDerJeugt)
01:26:17 <simsin> Zao, I gave up the capital letter in the function name and use all lower case and the source file works again.  I don't even need to use 'let'
01:28:03 <Zao> simsin: Case only matters in the beginning of names.
01:28:18 <Zao> simsin: A capital letter denotes a typeclass, a type or a contructor.
01:28:31 <Zao> A lowercase letter denotes a function, a variable, or suchlike.
01:31:51 <simsin> Zao, perhaps the editor place a control character before the capital letter which was not visible to me and only visible to Haskell
01:34:43 <simsin> anyway, it works now even after I exit the compiler and return to it again.
01:35:14 <zong_sharo> hi, i'm working on transmissionbr rpc wrapper. there is a set of properties for each torrent
01:35:24 <zong_sharo> some of the is r/o and some writable
01:36:03 <zong_sharo> i want to avoid duplication
01:37:07 <zong_sharo> is there any better solution than, let say, ReadableProperty and WritableProperty typeclasses + heterogeneous list 
01:38:26 <zong_sharo> oh, /me stupid one - i need to create some interface for querying and updating those properties
01:52:28 <tomh> anyone with alex knowledge knows if its possible to have a token thats possible to appear everywhere, but only in some cases should be considered for a parse rule?
01:53:00 <tomh> other than making it optional everywhere
01:59:15 <tomh> oh wait, happy 
02:03:48 <merijn> Anyone here have Scala experience? If so, how pleasant/painful would you rate it compared to Haskell?
02:04:09 <tomh> I have
02:04:22 <tomh> I would rate it pretty painfull
02:04:55 <merijn> Guess I should just grab the chance and finally start learning Clojure if I have to develop for the JVM then
02:05:30 <tomh> I would rather use scala or java :)
02:05:38 <tomh> I cannot stand the clojure syntax
02:06:19 <tomh> I still think scala is the best jvm language out there
02:06:26 <merijn> Yes, but that's par for the course for Lisp, and I feel I should learn a Lisp at some point in my live if I want to continue to be a PL snob :p
02:07:01 <tomh> can't you just write haskell and at parentheses at every possible place you can think of?
02:07:06 <tomh> at = add
02:07:32 <zong_sharo> merijn: i know the presentation that will give you definitive answer, let me google it back 
02:10:09 <zong_sharo> merijn: found it, but probably i remember wrong
02:10:13 <zong_sharo> http://projects.tmorris.net/public/what-does-monad-mean/artifacts/1.0/html/index.html
02:10:19 <zong_sharo> http://projects.tmorris.net/public/intro-to-highlevel-programming-with-scala/artifacts/0.9/chunk-html/index.html
02:10:29 <zong_sharo> http://projects.tmorris.net/public/what-does-fp-mean/artifacts/0.4/xhtml/index.html
02:10:41 <merijn> zong_sharo: I'll look into them
02:11:32 <zong_sharo> tony moris is a functional programming evangelist, and also explains why it's awesome from c++/java/scala/f#/c# point of view
02:12:02 <tomh> hey writes pretty good stuff
02:12:08 <quicksilver> he's here, too :)
02:12:18 <zong_sharo> therefore, you can infer how is scala compares to haskell by code snippets in scala he wrote to explain haskell
02:13:05 <tomh> I had some troubles with the scala typesystem
02:13:21 <tomh> its more limited than haskell
02:13:24 <zong_sharo> yeah, the stuff he wrote is awesome
02:13:45 <tomh> or well more limited, its different
02:14:09 <zong_sharo> hm, found this trick to r/o w/o and r/w attrs : http://hackage.haskell.org/packages/archive/glib/0.11.2/doc/html/System-Glib-Attributes.html
02:14:27 <zong_sharo> looks good, is there any other alternatives? (except big typeclassing ofc)
02:14:33 <tomh> anyway, does anyone a good place to go for happy questions? :)
02:15:16 <zong_sharo> the idea is not to make list heterogeneous, but elements of list - kinda nice
02:15:38 <zong_sharo> tomh: haskell-cafe?
02:15:55 <tomh> thats the mailing list?
02:16:03 <zong_sharo> yup
02:17:45 <tomh> ah ok, thanks
02:18:12 <quicksilver> zong_sharo: that's the general way I would do the trick
02:20:58 <zong_sharo> any alternatives?
02:21:33 <zong_sharo> it's not that i don't like this ssolution, just wantcurious
02:22:11 <zong_sharo> *curious
02:28:11 <quicksilver> zong_sharo: well you can sometimes encode a little more in the AttrOp type with a phantom, or something
02:28:29 <quicksilver> but the glib interface does cover most of the possibilities I think
02:41:09 <spirit> is ubigraph still being developped?
03:34:57 <spirit> what to use for visualising graphs from haskell? interested in images as well as interactive stuff. have come across graphviz (and vacuum-ubigraph -- the haskell structure of a graph looks slightly more confusing than the graph itself though) so far
03:45:30 <frank00> mini Q on state monad:
03:45:47 <frank00> reading the "instance Monad (State s)"
03:46:07 <frank00> " (State h) >>= f " function
03:46:30 <frank00> There's a let line that goes like this "  (State g) = f a  "
03:47:15 <frank00> It left me quite puzzled! I see a constructor on the left of the = and a function + arg on the right side... what does the = mean?
03:47:39 <frank00> shouldn't it be something like "State f a" full stop?
03:48:40 <quicksilver> frank00: it's a pattern match
03:48:43 <ketil> Presumably 'f a' returns a State something, which is then pattern matched to bind the something to the g?
03:48:49 <quicksilver> that's one way to deconstruct a value
03:48:59 <quicksilver> as in "let (Just x) = blah in ..."
03:49:28 <quicksilver> f will have the type "a -> State s b"
03:49:38 <quicksilver> so f a has the type "State s b"
03:49:48 <quicksilver> and let (State g) = .... is unwrapping the State constructor.
03:52:17 <jlouis> what is the consensus: Should one stay on parsec2 rather than use parsec3 ?
03:52:38 <jlouis> network and HTTP depends on 2 but I have convergence problems because I use p3
03:54:47 <vegai> jlouis: the latest http/network don't actually
03:55:42 <tomh> anyone familiar with this error: templates/GenericTemplate.hs:64:25: Not in scope: `unsafePerformIO'
03:55:47 <tomh> from happy
03:55:54 <vegai> missing import, certainly
03:56:23 <tomh> yeah I guess so, but this is bundled haskell software
03:56:27 <tomh> isn't that supposed to work :D
03:56:50 <vegai> perhaps unsafePerformIO was somehow in scope by default in some older version of ghc..
03:56:51 <jlouis> vegai: ah, it is cabal that messes
03:59:46 <jlouis> vegai: I can probably fix the problem by not relying on network-bytestring which is deprecated :)
04:00:53 <jlouis> Or so I hope at least
04:01:25 <vegai> probably is, since network itself has Network.Bytestring
04:07:24 <tomh> seems a bug in the happy generated code
04:07:49 <tomh> they import qualified but they don't use the functions using the defined alias
04:10:13 <jimi_hendrix> accessing a random element in a list is O(n) in haskell, right?
04:11:05 <tomh> yeah
04:11:27 <jlouis> vegai: there is a big fat red marker: DEPRECATED on network-bytestring
04:11:40 <jlouis> I am inclined to think it is true
04:12:23 <jlouis> unlike cabal-install's homepage, where 0.8.2 is *still* the right one (even though 0.10 is released)
04:13:00 <jlouis> or rahter, I needed 0.10 for ghc 7.0.2
04:14:22 <jimi_hendrix> then if i want to have the equivalent of a C 2d array (like char[][]) that will be randomly accessed often, what would be the best way to do that
04:14:46 <mauke> just reading?
04:14:51 <jlouis> jimi_hendrix: there is an unboxed array package you want
04:15:01 <sipa> STUArray
04:15:02 <jlouis> not package, module
04:15:11 <jlouis> STUArray is a good bet
04:15:22 <jimi_hendrix> ok
04:22:08 <jimi_hendrix> what exactly is an unboxed array?
04:22:24 <vegai> one that is not boxed :P
04:22:33 <sipa> one whose elements are not boxed
04:22:35 <jimi_hendrix> :p
04:22:52 <jimi_hendrix> and boxing means...
04:23:11 <Botje_> jimi_hendrix: boxing enables laziness
04:23:11 <Axman6> C arrays
04:23:19 <Botje_> an unboxed number is the raw numbr
04:23:28 <Botje_> a boxed number is a tag with a pointer to the raw number
04:23:41 <Axman6> the difference between an array of ints and an array of pointers to (things that can be evaluated to) ints
04:23:48 <jimi_hendrix> Botje_, i see
04:24:10 <Botje_> if you don't need laziness in your array (and it's sometimes nice to have) go for unboxed
04:30:13 <tomh> mm with parsers, how would you guys parse tokens which should be ignored by default but parsed only when they are defined in the rules?
04:31:20 <int-e> what does "defined" mean here?
04:31:45 <tomh> the token is part of the rule
04:33:02 <tomh> for example you can write comments everywhere, but only if its in front of a function, it should be parsed as a string
04:34:08 <int-e> ah, you must have a separate lexer in mind. is that right?
04:34:20 <tomh> how do you mean seperate lexer
04:35:19 <tomh> first I create tokens using my lexer
04:35:45 <tomh> then I parse my stream of tokens
04:35:55 <tomh> I think the comment issue is part of the parser
04:36:52 <spirit> trying to install a cabal package, encoutered this error: setup: The pkg-config package librsvg-2.0 version >=2.16.0 is required but it
04:36:53 <spirit> could not be found.
04:38:06 <int-e> tomh: and since you want to parse the comments at some places, comments are still present in the token stream? I'm not sure there is an easy solution (i.e., one that doesn't require you to say "ignore comments here" everywhere you might expect a comment that should be ignored. You can probably hide a lot of that in suitable combinators.)
04:40:17 <tomh> int-e: yeah the "ignore comments here" is the only solution I can think of so far
04:40:27 <tomh> another possibility was special error handling
04:40:33 <tomh> but thats not supported by happy
04:41:20 <tomh> and I think you can get ambiguity problems with "ignore comments here" 
04:55:18 <int-e> perhaps you can cheat and make each comment a part of the next token.
04:59:13 <turiya> hi
05:00:53 <turiya> can someone give a simple example of tail recursion?
05:01:26 <aavogt> @src foldl
05:01:26 <lambdabot> foldl f z []     = z
05:01:26 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:02:44 <Entroacceptor> http://www.youtube.com/watch?v=AQaTLSAMuGM :)
05:03:02 <Eduard_Munteanu> It might help to consider it in C code as well.
05:03:23 <turiya> aavogt: i dont quite understand, what and where is the tail recursion?
05:03:38 <fabjan> turiya: it's recursive because foldl calls foldl
05:03:48 <aavogt> the foldl calls itself as the last thing it does
05:03:59 <fabjan> it's tail recursive because in fold is the last function applied in foldl
05:04:15 <fabjan> s/in fold/foldl/
05:04:27 <aavogt> compare it with a function applies another function to the result of the recursive call
05:04:46 <aavogt> @src (++)
05:04:46 <lambdabot> []     ++ ys = ys
05:04:47 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:04:47 <lambdabot> -- OR
05:04:50 <Eduard_Munteanu> void f(int a) { printf("%d\n", a); f(a + 1); }       vs.
05:04:59 <hpaste> merijn pasted "silly factorial"  http://hpaste.org/44621
05:05:05 <Eduard_Munteanu> void f(int a) { f(a + 1); printf("%d\n", a); }
05:05:18 <Eduard_Munteanu> (ignore non-termination for the moment)
05:05:33 <hpaste> merijn pasted "silly factorial"  http://hpaste.org/44623
05:05:38 <Eduard_Munteanu> The first is tail recursive and can easily be rewritten into a loop.
05:05:39 <merijn> The second one I meant
05:05:40 <turiya> i see.. (++) is not tail recursive then
05:05:54 <fabjan> @src (++)
05:05:54 <lambdabot> []     ++ ys = ys
05:05:55 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
05:05:55 <lambdabot> -- OR
05:05:56 <merijn> Note, I didn't check whether my tailFactorial was actually right :p
05:06:01 <aavogt> @more
05:06:29 <merijn> turiya: Which language(s) are you used to programming in?
05:06:38 <tomh> int-e: im pretty sure the solution will involve a hacked up solution :P, anyway I posted to the mailing list to see what other people think, if they know
05:06:55 <turiya> merjin: C and also Haskell for some time now
05:08:22 <Eduard_Munteanu> In languages such as C, non-tail-recursive functions have to build up a chain of calls which need to be unwinded at the end (since there's still something to do).
05:08:38 <merijn> turiya: Tail recursion in C is essentially when the recursive call is done inside the return statement (i.e. "int foo(int a) { return foo(a);}"), this means the compiler does not need to keep the stack frame of the original call around (since local variables can never be used after the recursive call)
05:08:43 <turiya> Eduard_Munteanu: the second one would be slower to print stuff but is there any other advantage with the first one?
05:09:25 <aib> easier to write
05:09:27 <merijn> turiya: Compare "int fact(int n) { return n + foo(n-1); }", the local variable n needs to be kept around since when foo(n-1) is done executed you still need to add n to it
05:09:28 <Eduard_Munteanu> turiya: ignoring non-termination (say you had a condition that made it terminate / return at some point), it'd have to go back through previous calls.
05:09:41 <Eduard_Munteanu> The stack would grow linearly with the number of calls.
05:10:21 <Eduard_Munteanu> It'd go up to the termination condition, and then print out stuff on the way back.
05:10:23 <merijn> turiya: So since the stack frame of the original call is still needed the stack grows until you overflow. Tail recursion allows the new call to overwrite the stack entry of the old one (since it is no longer needed) causing it to run in fixed space
05:10:39 <turiya> is stack where the local variables are stored?
05:10:45 <Eduard_Munteanu> (as in the case of naive tree traversal algorithms)
05:10:46 <merijn> turiya: In C, yes
05:10:55 <merijn> (Mind you, this does not apply to Haskell since haskell is lazy)
05:11:08 <Eduard_Munteanu> Not only local variable, but the return address and (perhaps) arguments.
05:11:23 <merijn> So tail recursion in haskell is not as beneficial as it would be in for example C
05:11:42 <merijn> (Or more like, the compile can do the same in some cases without requiring tail recursion)
05:11:44 <jho> Is there an rc file or something that gets run every time ghci is started? Mainly I'm looking to replace the Prelude> prompt with a shorter one.
05:11:46 <turiya> ok..i understand now
05:11:56 <aavogt> jho: ~/.ghci
05:12:00 <turiya> it would be a waste of stack space
05:12:21 <aavogt> you can put whatever :set prompt '>'  you do already
05:12:27 <jho> aavogt: Thanks
05:12:50 <aavogt> the prompt is pretty helpful because it tells you whether modules are compiled, interpreted, or even imported at all
05:13:17 <Eduard_Munteanu> Yeah, but that prompt can grow pretty fast with just a few imports.
05:13:40 <merijn> turiya: If you really want to gritty details of the advantages you'd probably want to example assembly and how you would implement tail recursion in assembly (probably a bunch of tutorials around for that), it shouldn't be to hard to go from C to assembler anyway
05:13:46 <aavogt> by that time you should start putting the code into a file
05:14:11 <aavogt> or that's how I deal with it anyways
05:14:15 <merijn> 2 weeks of ASM practical after I started learning C == best time investment I made in understanding languages and computers in general :D
05:14:24 <turiya> tail recursion is necessary but I understand foldl is still slow and the variants foldl' make it strict.. how are things made strict?
05:14:48 <merijn> turiya: By simply telling the compiler "make this strict"
05:14:49 <Eduard_Munteanu> :t seq
05:14:49 <lambdabot> forall a t. a -> t -> t
05:14:50 <Ke> what's there in tail recursion you can't do in C?
05:15:12 <merijn> Ke: You can't implement tail recursion in C (the compiler can, but you can't)
05:15:33 <turiya> merjin: how does the compiler do this?
05:15:51 <Entroacceptor> merijn: you can do gotos...
05:16:22 <merijn> Entroacceptor: You can fake it sorta with goto's, but that doesn't give you access to the registers and stack to override return values
05:16:23 <Eduard_Munteanu> It's a basic compiler optimization.
05:16:48 <Eduard_Munteanu> And it depends on your internal representation, e.g. if you use SSA form (which is pretty common).
05:17:07 <merijn> turiya: That's sorta tricky to explain, the easiest way to understand compilers (in my opinion anyway) is to learn how to write one
05:17:08 <Eduard_Munteanu> The compiler can see it's a tail-recursive function and replace recursivity with a loop.
05:17:16 <merijn> Which is surprisingly easy, btw
05:17:21 <Eduard_Munteanu> (which also helps inlining)
05:17:29 <Ke> merijn: point being, why does one have to study assembler
05:17:46 <Ke> at least for foldl simple while suffices
05:17:49 <turiya> merjin: i always thought writing compilers is very hard
05:18:00 <merijn> Ke: Assembler can do more then C can, if you do not understand assembler it is hard to understand how to implement these things inside a compiler
05:18:12 <confound> you can do tail recursion in perl!
05:18:42 <merijn> turiya: Writing a "real" compiler for a "real" language is hard, yeah. Writing a simple compiler for a fictional stupid language is quite easy and teaches you a lot
05:18:44 <Eduard_Munteanu> In my example, it'd replace the body of the function with something equivalent to   for (;;) printf("%d\n", a++);
05:19:16 <merijn> turiya: I don't know of any good online tutorials, though. I followed a compiler class at university
05:19:27 <turiya> i am not a cs/math person so i would not want to do that anyway.. :)
05:19:28 <merijn> Maybe someone here knows one?
05:19:42 <turiya> however i do want to increase the speed of my haskell programs
05:20:10 <Eduard_Munteanu> Tail-recursivity matters in Haskell but not as much.
05:20:53 <merijn> @quote Shootout
05:20:53 <lambdabot> MyCatVerbs says: The *real* best way to optimize a program is to tell dons that it's been added to the Shootout.
05:21:03 <Eduard_Munteanu> Heh.
05:21:06 <Ke> !
05:21:19 <turiya> i also wanted to know how to force strictness.. i did not understand much from the corresponding pages in haskell wiki
05:21:37 <turiya> !, $! etc..
05:21:38 <merijn> Speaking of haskell and strictness...
05:21:44 <Eduard_Munteanu> turiya: you'd use `seq`
05:21:54 <merijn> Anyone here read about Habit? Opinions?
05:21:57 <Eduard_Munteanu> a `seq` b    forces evaluation of a, but returns b
05:22:04 <Jafet> turiya: there is Lisp in Small Pieces, but I'm not sure if it covers non-strict evaluation.
05:22:07 <Eduard_Munteanu> @src foldl'
05:22:08 <lambdabot> foldl' f a []     = a
05:22:08 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:22:17 <turiya> i have this function "func (x:xs) = x + func (xs)"
05:22:19 <Jafet> Well, it forces evaluation of a to WHNF.
05:22:26 <turiya> i know now it is not tail recursive
05:22:53 <turiya> i want to make it strict in the first argument
05:23:00 <turiya> or rather in x
05:23:12 <Eduard_Munteanu> (yeah, you'd want deepSeq if need it to unwind more layers of laziness)
05:23:40 <Jafet> Well, x `seq` x + func xs would do it.
05:23:41 <Eduard_Munteanu> turiya: write it as a foldl first.
05:23:52 <manateeUser> @quote Haskell Platform
05:23:52 <lambdabot> No quotes match.
05:23:54 <Jafet> But that's probably not what you want.
05:23:55 <Eduard_Munteanu> Then figure how foldl' works.
05:24:05 <Eduard_Munteanu> @where platform
05:24:05 <lambdabot> http://hackage.haskell.org/platform/
05:24:46 <turiya> seq.. is that one enough for enforcing strictness?
05:24:54 <manateeUser> I remember HP release three days ago? ;p
05:25:00 <turiya> !, $! what about these?
05:25:02 <HugoDaniel> i like the way that most oop design patterns show up so naturally in haskell
05:25:27 <HugoDaniel> its like i dont even have to think about them, they are just there... built-in
05:25:30 <Eduard_Munteanu> turiya: $! is merely a combination of $ and seq
05:25:31 <manateeUser> turiya: Don't use lazy evlation.
05:26:23 <turiya> Eduard_Munteanu: i see..
05:26:55 <Jafet> @src (!)
05:26:55 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
05:27:02 <Jafet> @src ($!)
05:27:02 <lambdabot> f $! x = x `seq` f x
05:27:06 <Eduard_Munteanu> And yeah, in your case 'seq' is enough
05:27:36 <Eduard_Munteanu> As for '!', that goes into data definitions to show a field is strict.
05:28:32 <Eduard_Munteanu> Which might help even more in some cases with -funbox-strict-fields
05:28:55 <turiya> yeah, tail recursion + strictness is very important for speed
05:29:10 <Eduard_Munteanu> and unboxing
05:29:53 <turiya> hmm.. unboxing is done by the compiler?
05:30:38 <Jafet> It's something that should be done by compilers.
05:30:41 <Eduard_Munteanu> In case of '!', yes. But you can also use GHC features to write functions that operate on special unboxed types.
05:31:08 <Jafet> GHC lets you do it manually, but I've never needed it
05:31:43 <turiya> oh.. i see..
05:32:24 <Eduard_Munteanu> It's not enabled by default with optimizations since it can actually lower performance in some cases.
05:32:44 <Eduard_Munteanu> It might also be wiser to use UNPACK pragmas instead of doing -funbox-strict-fields globally.
05:33:34 <Eduard_Munteanu> (Because it's only worth it when you don't have to rebox that value immediately.)
05:34:40 <Jafet> Well, GHC liberally unboxes intermediate values of strict computations when optimization is enabled. But it would only work for func if it was written as a left fold.
05:34:48 <Jafet> (I think)
05:35:56 <Eduard_Munteanu> Yeah, though foldr isn't good here anyway since (+) is strict.
05:36:06 <Eduard_Munteanu> (for number types)
05:38:36 <Eduard_Munteanu> Last night I wondered about something... whether we had the possibility to start GC only on demand.
05:38:40 <Eduard_Munteanu> Explicit GC points.
05:38:40 <hpc> since (+) is associative, you can safely replace "foldr" with "foldl'"
05:38:50 <quicksilver> Eduard_Munteanu: System.Mem.performGC
05:39:06 <Jafet> Start, but not stop
05:39:11 <Eduard_Munteanu> quicksilver: ah, I know about that, but can you prevent GC from starting on its own?
05:39:21 <quicksilver> Eduard_Munteanu: you can tweak the settings to make it pretty unlikely
05:39:22 <sgronblo_> Are there any important haskell topics not covered by learn you a haskell?
05:39:40 <quicksilver> GC occurs under certain conditions like when the nursery is full, when memory is tight, and at least every N seconds
05:39:42 <Eduard_Munteanu> It'd be interesting to have a middle-ground between automatic and manual mem mgmt
05:39:51 <Eduard_Munteanu> Ah.
05:39:55 <hpc> sgronblo_: yes, but they aren't necessarily necessary to learn, at this point
05:39:58 <Jafet> It shouldn't be hard to write a tame GC. But it might be hard to make it fast.
05:40:01 <quicksilver> you can tune it so the nursery is very large, the memory allowance is large, and N is high.
05:40:17 * hpc assumes you are relatively new to haskell
05:40:25 <quicksilver> and then collect manually instead.
05:40:53 <sgronblo_> hpc: well I almost finished the monad chapter now
05:40:54 <Eduard_Munteanu> Does it have deadlines?
05:41:05 * Eduard_Munteanu wonders how good it is for RT stuff
05:41:33 <hpc> sgronblo_: ah, cool; i learned haskell before that chapter, but what i did was read the wikibook, write cool programs, and hang out here
05:41:49 <hpc> i suspect you will learn an awful lot by doing the same
05:42:07 <Eduard_Munteanu> Wikibooks' stuff on Haskell is quite interesting.
05:42:13 <Jafet> You could ask the people who are writing stuff on phones.
05:42:14 <sgronblo_> hpc: I am new-old to haskell. I did take a course in FP using haskell where we used hugs a looooong time ago. I am not even sure if the course covered monads. But recently out of curiosity I started re-learning haskell.
05:42:36 <hpc> sgronblo_: lol; welcome back
05:42:50 <hpc> Eduard_Munteanu: in the places where it is complete, yes :P
05:43:06 <Eduard_Munteanu> For example, I haven't seen an explicit and clear math formulation for zippers anywhere else.
05:43:07 <Jafet> I don't think anyone is going to use it for a criticality shutdown controller soon, though
05:43:11 <hpc> oh, also: wikipedia has some good stuff, on lambda calculus, combinators, folds, etc
05:43:19 <Eduard_Munteanu> (Huet's stuff was a bit intimidating, IIRC :D)
05:43:25 <sgronblo_> The monads didn't seem as scary as I had led myself to believe they were
05:43:35 <Eduard_Munteanu> And fixed points, denotational semantics...
05:43:46 <hpc> sgronblo_: they really aren't; they are just applicative with a shiny new (>>=) function
05:44:14 <hpc> people hear "omg io monad; it is magic" and write shitty tutorials when they finally realize that a monad is a burrito
05:44:17 <hpc> :D
05:44:20 <quicksilver> Eduard_Munteanu: no, the GC doesn't have anyway to impose deadlines
05:44:38 <sgronblo_> The only time I've heard of monads outside of haskell was in the history of philosophy, and they made much less sense in that context than they seem to do in haskell.
05:44:40 <quicksilver> Eduard_Munteanu: adding such features to the GC, or plugging in new GCs, would be interesting work.
05:44:55 <quicksilver> Eduard_Munteanu: on zippers, have you read mcbride?
05:45:07 <Eduard_Munteanu> Though by that time you'd make it non-stop-the-world.
05:45:37 <hpc> ooh, here's a question:
05:45:39 <Eduard_Munteanu> I'm not sure. But Wikibooks + #haskell has been alright.
05:45:45 <hpc> is it safe to unsafePerform a garbage collection?
05:45:46 <ion> @quote hpc people hear "omg io monad; it is magic" and write shitty tutorials when they finally realize that a monad is a burrito
05:45:46 <lambdabot> No quotes match. :(
05:45:48 <hpc> my gut says yes
05:45:55 <hpc> ion: @remember
05:45:59 <ion> Ah, thanks
05:46:09 <hpc> @quote hpc
05:46:09 <lambdabot> hpc says: jokes are subject to an incompleteness theorem; if you can prove they are funny, they were never good jokes to begin with
05:46:15 <ion> @remember hpc people hear "omg io monad; it is magic" and write shitty tutorials when they finally realize that a monad is a burrito
05:46:15 <lambdabot> It is forever etched in my memory.
05:46:21 <Eduard_Munteanu> hpc: might not help if you want to do it more than once.
05:46:24 <Jafet> @quote monads.are
05:46:24 <lambdabot> heatsink says: If monads are containers, the Cont monad is a klein bottle.
05:46:36 <Eduard_Munteanu> might not help == you might run into trouble
05:46:39 <hpc> @quote
05:46:40 <lambdabot> Raynes says: F# isn't a cousin [of Haskell], it's the retarded son in law.
05:46:59 <sgronblo_> Are monads used in some branch of mathematics or why was the name chosen?
05:47:10 <Eduard_Munteanu> Yes, category theory.
05:47:35 <sgronblo_> oh, is f# sort of like what PHP is to ruby or python?
05:47:48 <hpc> haskell is notorious for butchering category theory, so don't worry if stuff appears off when you read one of those articles on wikipedia
05:47:51 <hpc> fyi
05:47:55 <hpc> sgronblo_: imo, pretty much
05:48:07 <Jafet> wikipedia also butchers category theory
05:48:19 <hpc> Jafet: less than we do, i am sure
05:48:40 <hpc> you'll find no burritos there
05:49:09 <sgronblo_> so which languages do haskell experts hate the most?
05:49:16 <saml> haskell
05:49:17 <quicksilver> english
05:49:18 <ion> Haskell
05:49:27 <hpc> lojban?
05:49:30 <hpc> :P
05:49:30 <Eduard_Munteanu> Yeah, we do. Joining #math and asking about monads in Haskell will elicit some interesting reactions :P
05:49:30 <sgronblo_> ?_?
05:50:23 <hpc> sgronblo_: you will find most people here hate php for being a pile of bugs and exploits, and hate java for being a pile of verbosity, and c++ for being a pile of inconsistency
05:50:30 <hpc> and perl for being a pile of unparsability
05:50:33 <hpc> and...
05:50:34 <hpc> :P
05:50:56 <saml> we hate haskell because we actually use haskell to write software
05:51:13 <saml> we don't hate php, java, c++ because we don't use those...
05:51:17 <Eduard_Munteanu> And Python for being a duck.
05:51:26 <zygoloid> burn the python!
05:52:04 <ion> The only language we do like is BASIC. More precisely, the implementation in Amstrad CPC464.
05:52:20 <Jafet> "There are 2 kinds of languages: Those that people complain about and those that nobody uses."
05:52:22 * Eduard_Munteanu remembers Dizzy :)
05:52:26 <mux> hpc: what about php being plainly badly designed as a language, for numerous reasons? that seems much more significant to me than it being a pile of bugs
05:52:47 <zygoloid> ion: i quite like the implementation of BASIC as a haskell DSL, which internally compiles it via llvm
05:52:51 <hpc> mux: php has been patched so much that it becomes a chicken-egg problem
05:53:08 <quicksilver> ion: the BASIC implementation on the Amstrad CPC had a serious flaw.
05:53:09 <hpc> was the design originally shit or did the bugs force devs to fix things poorly?
05:53:19 <hpc> who cares, because php has been changed so much
05:53:19 <Eduard_Munteanu> Dynamic typing is more than reason :)
05:53:28 <mux> hpc: bugs (security ones or not) can be fixed; design problems can too, but it's much harder.
05:53:32 <quicksilver> ion: said system also ran 'Elite' making it impossible to spend any time programming, there were much better things to do.
05:54:30 <sgronblo_> i think its funny how php originally was a perl-style glue language but now is trying to turn into java
05:55:12 <hpc> sgronblo_: the one cool feature php has is inline html
05:55:28 <hpc> which is really also a design issue, because of the ease of which you can expose your source code
05:55:47 <hpc> it is a noble goal though, to make a script look like the text it generates
05:56:46 <frank00> gaaah I'm lost again. In a stateful do statement i see: "a <- stackManip" (signature: stackManip :: State Stack Int) and in the next line if a == 5 then [...] etc. Question is: stackManip returns a steteful computation (\s -> (a,s)), how the hell do I bind an int to it?  
05:57:01 <sgronblo_> hpc: yeah that is very umm "cool"
05:57:08 <ion> More like the ease of designing your software in a way that mixes business logic and HTML rendering all over the place. :-P
05:57:17 <hpc> sgronblo_: :P
05:57:31 <hpc> sgronblo_: http://98.169.17.243:8000/blog/view.cgi?id=5
05:57:34 <confound> among php's shark-jumping moments were when it started spawning templating systems
05:57:41 <Eduard_Munteanu> frank00: why return a stateful computation?
05:57:53 <hpc> that top code block at the top is one of my most favorite pieces of haskell i have written
05:58:36 <Eduard_Munteanu> :t evalState
05:58:37 <lambdabot> forall s a. State s a -> s -> a
05:58:44 <frank00> Eduard_Munteanu: you mean StackManip? I see that from the pasted signature?
05:59:29 <Eduard_Munteanu> frank00: but there's a '<-' there, if you're already in the State monad, further references to 'a' will not have type to State Stack Int.
06:00:17 <frank00> Eduard_Munteanu: I'll better paste the snipped (taken from lear haskell for a greater good)
06:01:57 <frank00> http://pastebin.com/MDYp7Fh0 <-- there Eduard_Munteanu , and pardon me if I use incorrect terms, I am still learning
06:02:11 <Eduard_Munteanu> > let foo = get in (flip evalState) 12 $ do { a <- foo; return a; }
06:02:12 <lambdabot>   12
06:02:39 <Eduard_Munteanu> Imagine 'foo' was your stackManip, except here it's State Integer Integer
06:03:42 <Eduard_Munteanu> frank00: ah, you're using the constructor of State directly.
06:04:19 <Eduard_Munteanu> frank00: as you probably know, 'do' notation is desugared into lambdas and (>>=). And (>>=) will take care of extracting return values and passing them around.
06:04:33 <frank00> yes
06:04:56 <frank00> (I thought it was desugared into >>)
06:05:10 <Eduard_Munteanu> :t (>>)
06:05:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
06:05:22 <Eduard_Munteanu> (>>) ignores the return value.
06:05:38 <confound> <- is desugared into >>=
06:05:46 <confound> lines without it are desugared into >>
06:05:47 <confound> (roughly)
06:05:52 <frank00> thanks confound 
06:06:16 <sgronblo_> Btw, are there any exercises specifically designed for drilling use of applicative functors and monads?
06:06:22 <Eduard_Munteanu> @src (>>)
06:06:22 <lambdabot> m >> k      = m >>= \_ -> k
06:06:35 <Eduard_Munteanu> So they're not much different.
06:07:12 <confound> yes, I was just trying to clear up frank00's confusino
06:07:14 <confound> confusion
06:07:23 <Eduard_Munteanu> In fact you can ignore the bit about (>>) and imagine it expands to lambdas that are simply ignored.
06:07:33 <frank00> ok
06:07:54 <frank00> (and thanks for having unconfounded me, confound)
06:08:08 <Eduard_Munteanu> Heh.
06:09:01 <frank00> ok Eduard_Munteanu , so we have a <- pop  , which in >>= notation will turn into...
06:09:22 <Eduard_Munteanu> frank00: pop >>= (\a -> _______)
06:09:25 <frank00> pop >>= next stuff ?
06:09:28 <frank00> great
06:10:54 <Eduard_Munteanu> And a <- pop; b <- pop    into    pop >>= (\a -> pop >>= (\b -> ______))
06:11:44 <Eduard_Munteanu> (>>=) takes care of "magically" extracting a meaningful return value from State and passing it forward.
06:20:06 <ion> frank00: I wrote a description of the state monad a while ago which may or may not be helpful: http://heh.fi/state-monad
06:22:15 <frank00> thanks Eduard_Munteanu and ion. Ion, the Sequencing state computations: the bind operator passage had me had an ephipany(sp)
06:23:40 <frank00> I dislike do notation because you're losing touch with the "functional" one, but I am sure writing a simple if cycle using >== lambda instead of do could be messy
06:26:48 <frank00> great, I feel enlightened, thanks you both Eduard_Munteanu and ion
06:27:45 * confound clicks too
06:42:32 * hackagebot graph-wrapper 0.2.2 - A wrapper around the standard Data.Graph with a less awkward interface  http://hackage.haskell.org/package/graph-wrapper-0.2.2 (MaxBolingbroke)
06:48:47 <Jesin> hmm
06:49:18 <Jesin> does anyone have a good implementation of a floored square root function on positive Integers?
06:50:56 <ion> floor . sqrt . fromIntegral
06:51:56 <quicksilver> that only works within the range of doubles
06:53:08 <Jesin> not even that
06:53:34 <Jesin> by the time the exponent gets big enough, that the relative machine epsilon goes above 1.0
06:53:40 <Jesin> err
06:53:50 <Jesin> possibly strike "relative" from that?
06:53:51 <quicksilver> that's what I meant by range, although I didn't say it precisely ;)
06:53:55 <Jesin> yeah
06:53:57 <Jesin> :p
06:54:12 <Jesin> hm
06:54:14 <quicksilver> I don't know where to find a good one
06:54:20 <quicksilver> newton converges fast on sqrt
06:54:26 <quicksilver> binary chop works OK
06:54:29 <DevHC> > floor . (sqrt :: CReal -> CReal) . fromIntegral $ 1337
06:54:31 <lambdabot>   36
06:54:35 <Jesin> yeah, I was considering binary chop
06:54:57 <DevHC> > floor . (sqrt :: CReal -> CReal) . fromIntegral $ 2^4000
06:54:58 <lambdabot>   114813069527425452423283320117768198402231770208869520047764273682576626139...
06:55:13 <DevHC> > (floor . (sqrt :: CReal -> CReal) . fromIntegral $ 2^4000) - 2^4000
06:55:15 <lambdabot>   -13182040934309431001038897942365913631840191610932727690928034502417569281...
06:55:17 <Jesin> hm, I suppose CReal would have a floor function that always works
06:55:30 <DevHC> D:
06:55:50 <Jesin> DevHC: that's supposed to happen
06:55:51 <Jesin> :p
06:56:04 <DevHC> i don't see how...
06:56:07 <quicksilver> > (floor . (sqrt :: CReal -> CReal) . fromIntegral $ 2^4000) - 2^2000
06:56:08 <Jesin> well
06:56:09 <lambdabot>   0
06:56:16 <Jesin> sqrt(2^4000) - 2^4000
06:56:25 <Jesin> is 2^2000 - 2^2000
06:56:27 <Jesin> err
06:56:31 <Jesin> 2^2000 - 2^4000
06:56:35 <Jesin> I mean.
06:56:40 <DevHC> oshi
06:56:44 <DevHC> </fail>
06:56:48 <Jesin> :p
06:57:06 <ion> The hypothetical syntactic sugar for type-restricted id would be nice here. floor . sqrt . (:: CReal) . fromIntegral
06:57:53 <Jesin> meh
06:57:59 <Jesin> I'm not sure I like that syntax
06:58:16 <Jesin> it's not so bad I guess, but...
06:58:18 <Jesin> eh
06:58:24 <Jesin> so
06:58:35 <quicksilver> I think a direct (binary chop or newton) method will be faster than CReal
06:58:42 <Jesin> hm, yeah
06:58:43 <quicksilver> CReal is quite heavyweight.
06:58:47 <quicksilver> but, maybe that's fast enough for you
06:58:55 <Jesin> I'll look at how CReal's sqrt is implemented
06:59:10 <Jesin> which CReal are we using in lambdabot?
06:59:12 <HugoDaniel> how do i convert from [(a, m b)] into m [(a, b)] ?
06:59:18 <Jesin> or, where would I find it?
06:59:18 <quicksilver> the package is call numbers
06:59:36 <Jesin> hm
07:00:14 <ion> @pl \x -> sqrt (x :: CReal)  -- The credit for the idea goes to the bug in pointfree. :-)
07:00:14 <lambdabot> sqrt . (:: CReal)
07:00:17 <quicksilver> HugoDaniel: from (a,m b) to m (a,b) is \(x,y) -> do { yy <- y; return (x,yy) }
07:00:27 <Jesin> sequence . (\(a, mb) -> mb >>= \b -> return (a,b))
07:00:29 <HugoDaniel> ah okey
07:00:30 <HugoDaniel> cool
07:00:46 <HugoDaniel> thanks :)
07:00:51 <quicksilver> HugoDaniel: then from [m (a,b)]  to m[(a,b)] is sequence
07:00:53 <quicksilver> as Jesin said.
07:01:50 <HugoDaniel> you guys are fast
07:03:43 <anincog> Could someone help me clear my mind a bit? Consider f :: a -> b -> c and g :: c -> d. Now, I know that f isn't "a function of two variables", but rather a function with values of type b -> c. The mathematician in me would still like to produce (g . f) = curry (g . uncurry f), where (.) of course isn't the usual (.). This is fine, but am I correct in believing that it is inpossible to define a general such (.) for any number of 
07:03:43 <anincog> "arguments"?
07:04:08 <anincog> *impossible
07:04:11 <quicksilver> well it's mechanical for any partiular number of arguments
07:04:19 <quicksilver> but it's a different combinator in each case
07:04:37 <quicksilver> some people have named them (.) (.:) (.::) (.:::) (.::::) and so on
07:04:54 <quicksilver> in general people don't use them much.
07:05:18 <anincog> quicksilver: Maybe I'm just not haskelly enough yet, but they do feel very pleasant at least in the form I used as an example above
07:05:53 <Jesin> @src sequence
07:05:53 <lambdabot> sequence []     = return []
07:05:53 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:05:53 <lambdabot> --OR
07:06:10 <Jesin> what's the --OR
07:06:17 <Jesin> and why isn't there anything after it
07:06:24 <paolino> suspance
07:06:31 <merijn> @more
07:06:40 <merijn> Well, that doesn't work :p
07:06:45 <paolino> @src sequence
07:06:45 <lambdabot> sequence []     = return []
07:06:45 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:06:45 <lambdabot> --OR
07:07:13 <azaq23> it's foldr (:) (return [])
07:07:23 <azaq23> @type foldr (:) (return [])
07:07:23 <lambdabot> forall a. [[a]] -> [[a]]
07:07:41 <azaq23> @type foldr (liftM2 (:)) (return [])
07:07:42 <lambdabot> forall a1 (m :: * -> *). (Monad m) => [m a1] -> m [a1]
07:07:44 <azaq23> ^
07:07:56 <Jesin> yeah, I just figured that out
07:07:56 <azaq23> lambdabot used to display the or though
07:08:46 <Jesin> I still like how that's a cartesian product on the findspace monad
07:08:48 <Jesin> :p
07:09:12 <Jesin> even on infinite lists  :p
07:10:05 <Jesin> [10:43:19]	<anincog>	Could someone help me clear my mind a bit? Consider f :: a -> b -> c and g :: c -> d. Now, I know that f isn't "a function of two variables", but rather a function with values of type b -> c. The mathematician in me would still like to produce (g . f) = curry (g . uncurry f), where (.) of course isn't the usual (.). This is fine, but am I correct in believing that it is...
07:10:07 <Jesin> ...inpossible to define a general such (.) for any number of 
07:10:09 <Jesin> anincog, umm
07:10:14 <Jesin> :t ((.).(.))
07:10:14 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
07:10:18 <Jesin> ...
07:10:21 <Jesin> -_-
07:10:32 <Jesin> Caleskell and it's (.) = fmap
07:10:34 <Jesin> err
07:10:36 <Jesin> *its
07:10:40 <deggis> i'm having a bit of headache with cabal install, ideas on what i'm doing wrong? http://deggis.iki.fi/misc/cabal_install_cabal-install.txt
07:10:47 <deggis> clean package repo, cabal install cabal-install fails
07:11:15 <azaq23> @type let (.) = P.. in ((.).(.))
07:11:16 <lambdabot> parse error on input `P..'
07:11:32 <azaq23> @type let (.) = Prelude.. in ((.).(.))
07:11:33 <lambdabot> parse error on input `Prelude..'
07:11:43 <dcoutts> deggis: see the message about "time-1.1.4 failed during the configure step."
07:12:06 <Jesin> @hoogle CReal
07:12:07 <lambdabot> No results found
07:12:09 <Jesin> umm
07:12:17 <quicksilver> dcoutts: different version of Cabal in user + global is a problem or not?
07:12:24 <Jesin> guys, where would I find the documentation for the particular CReal used in lambdabot?
07:12:30 <quicksilver> Jesin: numbers package
07:12:38 <quicksilver> Jesin: (I did answer you last time but you must have missed it ;)
07:12:58 <dcoutts> quicksilver: no, unless it means also pulling in older versions of other things
07:13:08 * quicksilver nods
07:13:09 <deggis> dcoutts: i'm getting more verbose log now.. but hm, cabal install time -v just passed
07:13:54 <deggis> the real issue here is not somehow managing to get cabal install cabal-install through, by separately installing i usually make it, but.. i'm just tired of fighting with cabal
07:15:11 <deggis> after installing that time separately the installation process passed through and i've got local cabal
07:15:35 <deggis> but i'm wondering what i did wrong earlier
07:15:36 <Jesin> k, thanks quicksilver
07:15:41 <mauke> @admin + mauke
07:15:41 <lambdabot> Not enough privileges
07:16:27 <dcoutts> deggis: btw, if you're trying to install cabal-install with ghc-7, make sure you're using cabal-install-0.10.x, not 0.8.x
07:17:22 <deggis> uh oh, it was 0.8.2 that i was using
07:18:25 <deggis> thanks, that's probably all that was wrong there
07:19:58 <dcoutts> deggis: I guess the old bootstrap was installing an old version of the time package that does not work with ghc7
07:20:34 <deggis> that would explain a lot
07:22:41 <deggis> hm, after separately installing that time package i've usually managed to get cabal installed, but encountered other similar issues after installing just a few packages more. those could be also affected by choises made by that cabal-install with 0.8.x process
07:22:45 <azaq23> @type let (.) = (Prelude..) in ((.) . (.))
07:22:46 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
07:23:30 <dcoutts> deggis: yep, just use the 0.10 version
07:24:37 <deggis> in addition to that concrete tip of cabal versions i also got the needed therapeutic "this could solve most of my problems" feeling. thanks a lot :-)
07:25:00 <dcoutts> :-) you're welcome
07:25:16 <dcoutts> deggis: you're just slightly too early for the new HP release
07:25:23 <dcoutts> with ghc 7 and the new cabal-install version
07:25:28 <dcoutts> it's due soon
07:25:49 <deggis> oh, great!
07:27:58 <HugoDaniel> i dont like to code alone :(
07:29:54 <Jesin> oh wow
07:29:56 <Jesin> the CReal code
07:30:13 <Jesin> actually *uses* a floorsqrt :: Integer -> Integer
07:30:17 <Jesin> in its implementation of sqrt
07:30:22 <Jesin> so, I guess I can grab that?
07:30:24 <Jesin> :p
07:30:50 <Jesin> floorsqrt x = until satisfy improve x
07:30:50 <paolino> what is the name of the ~ in front of a pattern ?
07:30:51 <Jesin>               where improve y = floor ((y*y+x) % (2*y))
07:30:53 <Jesin>                     satisfy y = y*y <= x && x <= (y+1)*(y+1)
07:30:55 <Jesin> hmm
07:31:11 <Botje_> paolino: lazy pattern match
07:31:20 <Jesin> isn't (floor (x % y)) just (quot x y)?
07:31:36 <Jesin> up to sign error
07:31:46 <Jesin> maybe it would be div instead of quot
07:31:51 <Botje_> paolino: if you use eg ~(x,y) to match, the tuple is not evaluated until you use x or y
07:31:52 <Jesin> but, if everything's positive, isn't it that?
07:32:21 <paolino> Botje_: mh, what it does match then ?
07:32:37 <Botje_> paolino: it still matches the same as (x,y), but the value is not evaluated yet
07:32:59 <Jesin> I'm pretty sure that means
07:33:01 <Botje_> foo (x,y) = 42 -- foo undefined = undefined
07:33:02 <Jesin> it matches everything
07:33:09 <Botje_> foo ~(x,y) = 42 -- foo undefined = 42
07:33:45 <Jesin> also, doesn't pattern-matching in a "let" or "where" automatically work like that, btw?
07:34:28 <paolino> foo x = 42 -- foo undefined = 42
07:35:40 <paolino> foo z = let (x,y) = z in 42 -- foo undefined = ?
07:36:28 <paolino> I cannot guess where it is useful in the end
07:36:52 <paolino> you have a simple example where I need that ?
07:37:33 <gracenotes> some uses of flip. partition.
07:38:00 <poucet> :t flip . partition
07:38:01 <lambdabot>     Couldn't match expected type `a -> b'
07:38:01 <lambdabot>            against inferred type `([a1], [a1])'
07:38:01 <lambdabot>     Probable cause: `partition' is applied to too many arguments
07:38:21 <paolino> not this use
07:39:22 <paolino> I've seen it used on constructors, now it's really obscure
07:39:28 <Jesin> > let foo (x,y) = 42) in foo undefined
07:39:29 <lambdabot>   <no location info>: parse error on input `)'
07:39:33 <Jesin> > let foo (x,y) = 42 in foo undefined
07:39:34 <lambdabot>   *Exception: Prelude.undefined
07:39:39 <Jesin> > let foo ~(x,y) = 42 in foo undefined
07:39:40 <lambdabot>   42
07:40:06 <Jesin> > let { foo z = let (x,y) = z in 42 } in foo undefined
07:40:07 <paolino> > let foo _ = 42 in foo undefined
07:40:07 <lambdabot>   42
07:40:08 <lambdabot>   42
07:40:09 <fryguybob> > let f n x=(x+n`div`x)`div`2; isqrt n=snd.head.dropWhile(\(a,b)->abs(a-b)>1).(zip<*>tail).iterate(f n)$n in isqrt (2^4000) - 2^2000
07:40:10 <lambdabot>   0
07:40:14 <Botje_> paolino: in a lambda pattern match, for example
07:40:28 <Botje_> paolino: or when the decision to use the matched variables depends on something else
07:40:50 <medfly> how do I do something like [[a,b] | a <- [0,1], b <- [0,1]] concisely (choosing from the same list)?
07:41:21 <djahandarie> > let f a (x,y) = if (a == 3) then 3 else x+y in (f 3 undefined, f 4 (1,2))
07:41:22 <lambdabot>   (*Exception: Prelude.undefined
07:41:28 <djahandarie> > let f a ~(x,y) = if (a == 3) then 3 else x+y in (f 3 undefined, f 4 (1,2))
07:41:29 <lambdabot>   (3,3)
07:43:03 <djahandarie> > let f a b = if (a == 3) then 3 else (let (x,y) = b in x+y) in (f 3 undefined, f 4 (1,2))
07:43:04 <lambdabot>   (3,3)
07:43:21 <paolino> > let f a z = let (x,y) = z  in  if (a == 3) then 3 else x+y in (f 3 undefined, f 4 (1,2))
07:43:22 <lambdabot>   (3,3)
07:44:05 <medfly> I will just do this ugly for now ^^
07:44:13 <quicksilver> medfly: liftM2 (,) [0,1] [0,1]
07:44:37 <quicksilver> and, therefore : join (liftM2 (,)) [0,1]
07:44:49 <djahandarie> Didn't he want a list rather than a tuple?
07:44:56 <djahandarie> > [[a,b] | a <- [0,1], b <- [0,1]]
07:44:57 <lambdabot>   [[0,0],[0,1],[1,0],[1,1]]
07:45:05 <alexbobp> merlino211: didn't even notice rc2 yet... thanks for the heads upP
07:45:20 <alexbobp> sorry, mis-directed message
07:45:46 <Jesin> > sequence . replicate 2 $ [0,1]
07:45:48 <lambdabot>   [[0,0],[0,1],[1,0],[1,1]]
07:45:50 <Jesin> :D
07:45:52 <paolino> so ~ is syntactic sugar to avoid a let ?
07:46:25 <Jesin> paolino: that's one way to think about it...
07:46:40 <Jesin> "let" itself could be seen as syntactic sugar though
07:46:55 <djahandarie> You could think of it that way. It delays the pattern matching until one of the deconstructed variables are needed.
07:47:05 <Jesin> (let (pat,tern) = arg in result)
07:47:09 <quicksilver> let and case also have slightly different polymorphism
07:47:12 <quicksilver> I think?
07:47:13 <Jesin> is equivalent to
07:47:14 <medfly> quicksilver: thanks
07:47:29 <Jesin> (\~(pat,tern) -> result) arg
07:47:34 <Jesin> :p
07:48:15 <medfly> Jesin: :-D
07:49:02 <Jesin> > sequence $ replicate 3 $ [0,1]
07:49:03 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
07:50:00 <paolino> > fix . sequence $ replicate 3 $ [0,1]
07:50:00 <lambdabot>   Couldn't match expected type `[a] -> a' against inferred type `[t]'
07:50:30 <medfly> it's not overly critical for me to do it nicely. :)
07:50:47 <Jesin> :t fix . sequence
07:50:48 <lambdabot> forall a. [[a] -> a] -> [a]
07:51:06 <quicksilver> > [1..] >>= flip replicateM [0,1]
07:51:08 <lambdabot>   [[0],[1],[0,0],[0,1],[1,0],[1,1],[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1...
07:51:13 <paolino> :t fix (sequence . replicate 3)
07:51:14 <Jesin> :t replicateM
07:51:17 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
07:51:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
07:51:21 <lambdabot>       Expected type: m [a]
07:51:25 <lambdabot>       Inferred type: m a
07:51:55 <Jesin> @src replicateM
07:51:55 <lambdabot> replicateM n x = sequence (replicate n x)
07:52:43 <djahandarie> > getZipList . Data.Traversable.sequenceA . replicate 3 $ ZipList [0,1]
07:52:45 <lambdabot>   [[0,0,0],[1,1,1]]
07:52:48 <djahandarie> Not as interesting...
07:53:13 <paolino> > replicateM 2 [0,1]
07:53:14 <lambdabot>   [[0,0],[0,1],[1,0],[1,1]]
07:53:25 <paolino> :t fix
07:53:26 <medfly> aaaaaaawww...  it ends up being too much text ^^
07:53:26 <lambdabot> forall a. (a -> a) -> a
07:53:33 <djahandarie> There should be a replicateA
07:53:50 <medfly> my homework stupidly wanted me to write down all the possibilities when there are actually 210 of them. 
07:54:04 <medfly> now I have to actually think of the problem ^^
07:54:46 <Jesin> floorsqrt :: Integer -> Integer
07:54:48 <Jesin> floorsqrt x = until satisfy improve x
07:54:49 <Jesin>               where improve y = floor ((y*y+x) % (2*y))
07:54:51 <Jesin>                     satisfy y = y*y <= x && x <= (y+1)*(y+1)
07:54:52 <Jesin> hm
07:54:56 <Jesin> I wonder what's the rate of convergence on this?
07:55:36 <medfly> I have been told these things converge pretty quickly
07:55:52 <Jesin> also
07:55:56 <Jesin> isn't that *wrong*?
07:56:04 <Jesin> shouldn't it be
07:56:17 <medfly> I am not good at checking. too sleep deprived
07:56:20 <Jesin> satisfy y = y*y <= x && x < (y+1)*(y+1)
07:56:21 <medfly> good luck! :-)
07:56:25 <Jesin> k
07:58:15 * azaq23 flashback to dumb dice possibility problems using three dices, 6^3 = 216 variations
08:00:17 <Jesin> hm
08:00:25 <Jesin> what's a decent text editor I can use on windows?
08:00:38 <poucet> gvim
08:00:54 <Jesin> I don't know vim  =/
08:01:11 <Jesin> and don't particularly want to bother learning that today
08:04:21 <fryguybob> Jesin: I use notepad++
08:06:12 <Jesin> installing that
08:07:50 <fryguybob> Also the floorsqrt above with floorsqrt (2^16000) - 2^8000  takes about 25.80 seconds for me. Whereas newton's method takes about 3 seconds.
08:09:12 <fryguybob> > let f n x=(x+n`div`x)`div`2; isqrt n=snd.head.dropWhile(\(a,b)->abs(a-b)>1).(zip<*>tail).iterate(f n)$n in isqrt (2^16000) - 2^8000
08:09:14 <lambdabot>   0
08:09:29 <fryguybob> That particular doesn't always converge though :D.
08:09:36 <fryguybob> > let f n x=(x+n`div`x)`div`2; isqrt n=snd.head.dropWhile(\(a,b)->abs(a-b)>1).(zip<*>tail).iterate(f n)$n in isqrt 3
08:09:38 <lambdabot>   2
08:10:50 <azaq23> newton does always converge for sqrt
08:14:58 <edwardk> @tell byorgey yep, Data.Distributive.fmapDefault is hosed.
08:14:58 <lambdabot> Consider it noted.
08:16:57 * hackagebot comonad-transformers 1.5.2.3 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.5.2.3 (EdwardKmett)
08:17:43 <Jesin> umm, fryguybob
08:17:57 * hackagebot distributive 0.2.0 - Haskell 98 Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.2.0 (EdwardKmett)
08:18:09 <Jesin> could you give me your newton's method code?  Also, it doesn't use floating-point representations anywhere I hope?
08:18:14 <Jesin> umm, I mean
08:18:20 <Jesin> not general newton's method
08:18:27 <Jesin> just the one for integer square root
08:19:04 <edwardk> jesin: if you want the uber-strong version there is Numeric.AD.Newton ;)
08:19:41 <quicksilver> Jesin: http://en.wikipedia.org/wiki/Integer_square_root
08:19:58 * hackagebot streams 0.6.1.2 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-0.6.1.2 (EdwardKmett)
08:20:07 <quicksilver> Jesin: it is a simple rational formula; you can rearrange it into pure integer math.
08:20:19 <Jesin> ah
08:20:40 <Jesin> I wonder, would it be better to use Rational instead?
08:22:59 * hackagebot representable-functors 0.3.0.2 - Representable functors  http://hackage.haskell.org/package/representable-functors-0.3.0.2 (EdwardKmett)
08:23:59 * hackagebot adjunctions 0.9.0.2 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.9.0.2 (EdwardKmett)
08:24:01 * hackagebot language-css 0.0.2 - CSS 2.1 syntax  http://hackage.haskell.org/package/language-css-0.0.2 (AntonKholomiov)
08:25:00 * hackagebot representable-tries 0.3.1.1 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.3.1.1 (EdwardKmett)
08:25:07 <djahandarie> Hackage is going to explode!
08:28:00 * hackagebot simple-css 0.0.4 - simple binding of css and html  http://hackage.haskell.org/package/simple-css-0.0.4 (AntonKholomiov)
08:37:03 * hackagebot temporal-music-notation 0.1.4 - music notation  http://hackage.haskell.org/package/temporal-music-notation-0.1.4 (AntonKholomiov)
08:38:03 * hackagebot temporal-music-notation-western 0.1.4 - western music notation  http://hackage.haskell.org/package/temporal-music-notation-western-0.1.4 (AntonKholomiov)
08:39:40 <Jesin> hm
08:39:54 <Jesin> I found a thing online that says
08:39:56 <Jesin>  isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2)
08:40:08 <Jesin> the head-dropwhile-iterate thing can be replaced with until
08:40:18 <Jesin> @src until
08:40:18 <lambdabot> until p f x | p x       = x
08:40:18 <lambdabot>             | otherwise = until p f (f x)
08:40:41 <mzero> Newton's method as a one-liner!
08:41:07 <mzero> @info until
08:41:08 <lambdabot> until
08:41:34 <mzero> is that part of the Prelude?
08:41:42 <parcs> @hoogle until
08:41:42 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
08:42:07 <djahandarie> > until death fight
08:42:07 <lambdabot>   Not in scope: `death'Not in scope: `fight'
08:42:19 <Jesin> > until death fight opponent
08:42:20 <lambdabot>   Not in scope: `death'Not in scope: `fight'Not in scope: `opponent'
08:42:21 <Jesin> :p
08:43:14 <Jesin> umm, regarding
08:43:16 <Jesin>  isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2)
08:43:24 <mzero> I really should go back and read the Prelude ---
08:43:31 <Jesin> I hope that always converges
08:43:40 <Jesin> instead of looping just *above* the result
08:43:50 <Jesin> I'd think div would do that, though...
08:44:11 <Jesin> :t quickcheck
08:44:12 <lambdabot> Not in scope: `quickcheck'
08:44:18 <Jesin> @hoogle quickcheck
08:44:19 <lambdabot> package QuickCheck
08:44:19 <lambdabot> module Debug.QuickCheck
08:44:19 <lambdabot> module Test.QuickCheck
09:00:10 <medfly> hmm... Haskell makes it hard to use it as a calculator when it begins to randomly complain about mixing int and float :P
09:00:46 <Jafet> @hackage numeric-prelude
09:00:46 <lambdabot> http://hackage.haskell.org/package/numeric-prelude
09:01:08 <djahandarie> He didn't say he wanted to use it for abstract algebra
09:01:12 <djahandarie> :P
09:01:22 <Jesin> :t div
09:01:23 <lambdabot> forall a. (Integral a) => a -> a -> a
09:01:29 <medfly> I just want to use ^ 
09:01:30 <medfly> :)
09:01:37 <djahandarie> :t (**)
09:01:37 <lambdabot> forall a. (Floating a) => a -> a -> a
09:01:42 <medfly> oh, good. thanks
09:02:08 <medfly> that's scary...
09:02:29 <Jafet> But with that library, you can upgrade to more sophisticated type errors!
09:02:36 <medfly> heh
09:02:46 <medfly> it somehow managed to hang
09:02:54 <djahandarie> Numeric Prelude has gotten far too large and messy to be of any use imo
09:02:58 <medfly> it better be calculating a really accurate probability there
09:03:00 <djahandarie> Just like category-extras did :)
09:03:52 <aristid> djahandarie: if haskell provides a bit more techniques to eliminate boilerplate, maybe an algebraic Num replacement might be feasible
09:03:58 <aristid> -provides+provided
09:04:05 <medfly> http://hpaste.org/44624/fancy_calculator <- what am I doing wrong?
09:04:09 <hpaste> woo pasted "fancy calculator!"  http://hpaste.org/44624
09:04:12 <medfly> Haskell is a fancy calculator for me right now.
09:04:19 <djahandarie> What sort of boilerplate?
09:04:30 <medfly> the main problem is the function prob. 
09:05:17 <Jesin> @src (^)
09:05:17 <lambdabot> x ^ 0            =  1
09:05:17 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
09:05:17 <lambdabot>   where f _ 0 y = y
09:07:34 <medfly> I am not sure what to use
09:08:01 <mzero> medfly   **
09:08:08 <mzero> :t (**)
09:08:09 <lambdabot> forall a. (Floating a) => a -> a -> a
09:08:20 <medfly> but... I have **
09:08:24 <medfly> am I doing it wrong
09:08:24 <mzero> d'oh, djahandarie already said that
09:08:26 <mzero> oy
09:08:42 <medfly> programming made me so lazy I just won't calculate this by hand.
09:08:44 * mzero goes back to coding JavaScript, which is clearly costing him IQ points
09:09:38 <medfly> I should go home... I"ll be back in a while
09:17:20 <roconnor> how does the formal semantics for ML specify IO?
09:18:06 <c_wraith> ML's formal semantics are for the type system, I thought.  Which doesn't concern itself with IO
09:18:18 <roconnor> is that all?
09:18:35 <kmc> i thought the evaluation semantics were also specified
09:19:00 <kmc> most of the important facts about the type system can't be stated without formalizing evaluation, anyway
09:19:38 <aristid> mzero: you CAN maintain your IQ points by generating javascript from haskell :)
09:20:50 <roconnor> kmc: know if IO is specified?
09:20:55 <jystic> hey everyone, i have a few functions which need to do:  f x = lift x >>= id    does f have a name?
09:21:22 <poucet> :t \x -> lift x >>= id
09:21:23 <lambdabot>     Ambiguous occurrence `lift'
09:21:23 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
09:21:23 <lambdabot>                           or `Control.Monad.Logic.lift', imported from Control.Monad.Logic
09:21:34 <roconnor> :t \x -> liftM x >>= id
09:21:35 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a1)
09:21:35 <lambdabot>     Probable cause: `id' is applied to too many arguments
09:21:35 <lambdabot>     In the second argument of `(>>=)', namely `id'
09:21:45 <kmc> :t (>>= id)
09:21:46 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
09:21:52 <c_wraith> I assume that's Control.Monad.Trans lift
09:21:54 <kmc> (>>= id)  â¡  join
09:21:57 <c_wraith> and yes, that's join . lift
09:21:58 <jystic> yes that's right
09:22:35 <jystic> ahh >>= id  ==  join
09:22:42 <c_wraith> @src join
09:22:42 <lambdabot> join x =  x >>= id
09:22:44 <Jesin> umm
09:22:45 <accel> is there a haskell DSL for building compilers? I.e. it takes a program described by a haskell DSL, then uses LLVM to generaet an elf directly (does not link againat haskell's RTS)
09:22:59 <Jesin> it seems the current Haskell Platform
09:23:03 <Jesin> uses GHC 6
09:23:10 <jystic> c_wraith, kmc thanks
09:23:12 <kmc> accel, there are DSLs for parser and a DSL for LLVM generation
09:23:14 <c_wraith> Jesin: the new platform hasn't been released yet.
09:23:20 <c_wraith> Jesin: it's available for testing, though
09:23:20 <Jesin> ok
09:23:21 <mzero> Jesin - it is due out any day now
09:23:28 <mzero> we've built release candidate installers
09:23:34 <mzero> and will be doing another RC tonight
09:23:41 <mzero> final installers expected by end of week
09:23:48 <mzero> (fingers crossed)
09:23:51 <Jesin> that's good
09:24:01 <accel> kmc: I don't want to use the haskell LLVM backend; I want to directly output a binary via LLVM
09:24:04 <Jesin> in the meantime, is GHC 7 harder to set up on windows?
09:24:07 <accel> kmc: am I understanding you correctly?
09:24:11 <mzero> there was a bug in the released cabal-install, so we're going to have to reroll for that
09:24:36 <mzero> Jesin - don't know, but doubt it --- (I'm the Mac packager)
09:24:40 <c_wraith> Roll all 18s this time.  (You're rolling for stats, right?)
09:25:03 <kmc> accel, there is a DSL for outputting LLVM code
09:25:05 <djahandarie> mzero, has the fixed one been put on cabal yet?
09:25:13 <kmc> accel, it is unrelated to the GHC LLVM backend
09:25:13 <mzero> don't know
09:25:15 <hpaste> asdf pasted "bla"  http://hpaste.org/44625
09:25:15 <accel> kmc: http://hackage.haskell.org/package/llvm ?
09:25:18 <kmc> which i guess is what you mean by "haskell LLVM backend"
09:25:21 <kmc> yes
09:25:27 <djahandarie> kmc, actually the LLVM backend uses it now, I think :)
09:25:33 <djahandarie> Or at least it was suppose to switch to it
09:25:35 <kmc> there's actually some effort to merge them... yeah, what djahandarie said
09:25:37 <accel> kmc: oso that bindings, is what you mean by "DSL for outputting LLVm bytecode" ?
09:25:42 <kmc> probably
09:25:48 <mzero> > let roll (a:b:c:z) = b:c:a:z  in roll "rfoth"
09:25:49 <lambdabot>   "forth"
09:25:50 <kmc> maybe there's something else
09:25:59 <kmc> accel, http://augustss.blogspot.com/
09:26:00 <mzero> :-)
09:26:21 <djahandarie> "atom" is a nice DSL for C
09:26:25 <djahandarie> @hackage atom
09:26:25 <lambdabot> http://hackage.haskell.org/package/atom
09:26:29 <accel> kmc++
09:26:36 <djahandarie> For realtime stuff in particular
09:27:10 <djahandarie> And accelerate is one for CUDA, though I've never used it
09:27:13 <djahandarie> @hackage accelerate
09:27:13 <lambdabot> http://hackage.haskell.org/package/accelerate
09:32:10 <accel> second silly question
09:32:18 <accel> is the haskell parser used by GHC
09:32:22 <accel> avaialble as a package on hackage?
09:34:10 <djahandarie> There is haskell-src-exts, but I have no idea how much that uses from GHC. I think it's mostly standalone
09:34:11 <kmc> not other than through the GHC API
09:34:27 <kmc> haskell-src-exts is a separate package and is used by most other haskell-code-mangling tools
09:34:32 <djahandarie> Yeah
09:35:19 <kmc> most of GHC's functionality is available as a library
09:35:21 <djahandarie> > "Like this guy"
09:35:22 <lambdabot>   "Like this guy"
09:35:25 <kmc> but it's not exactly the friendliest library
09:37:48 <moisan> join #haskell
09:38:03 <luite> good advice
09:38:04 <djahandarie> moisan, we're here already!
09:38:07 <roconnor> duplicate #haskell
09:38:21 <djahandarie> You can only duplicate #cohaskell
09:38:29 <moisan> djahandarie : wait are you a bot?
09:38:44 <djahandarie> That's the second time today I've been called a bot.
09:38:46 <accel> kmc: "ost of GHC's functionality is available as a library" <-- where is this library?
09:38:47 <djahandarie> I should be more spontaneous.
09:38:59 <kmc> accel, it comes with GHC
09:38:59 <kmc> http://www.haskell.org/haskellwiki/GHC/As_a_library
09:38:59 <luite> you have failed the turing test
09:39:05 <Jafet> Don't be silly, of course it isn't a bot.
09:39:19 <moisan> djahandarie : haha sorry I'm not be directly talked to when I enter a chatroom :P
09:39:31 <accel> never mind turing test; I can't even past the idiot test
09:39:45 <djahandarie> moisan, you accidently said "join #haskell" outloud, so I figure I'd comment :)
09:40:42 <djahandarie> Apparently he wasn't very interested. :<
09:42:04 <moisan> haha, hey I have a question, I'm working with litterate haskell files. What editor should I use for that? I usually use emacs and I could hack away to get a proper config but time is a issue here. I just want some proper code coloring, that's all
09:42:19 <kmc> allegedly emacs multi-major-mode can handle it
09:42:22 <kmc> but i never got that to work
09:42:46 <moisan> kmc : exactly my problem, I know mmm-mode could do it , but even with the haskell wiki emacs code for that I can't get it to work
09:43:05 <luite> my emacs works fin highlighting literate haskell files
09:43:11 <luite> apparently the major mode is LitHaskell
09:43:52 <moisan> luite : cool I'll check that
09:44:08 <accel> dumb question: so given these LLVM bindings
09:44:16 <accel> what part of the RTS can't be rewritten in haskell?
09:44:26 <luite> moisan: I have to admit that I installed haskell-mode, so it's probably not included by default
09:45:24 <moisan> luite : I was already using haskell-mode :P
09:45:31 <kmc> accel, why does having LLVM bindings matter for that?
09:45:40 <luite> moisan: ah Mx literate-haskell-mode
09:45:46 <luite> should do the trick then
09:46:07 <accel> given haskell can output machine code; why do we need the RTS written in C?
09:46:20 <accel> seems like it could be better written in a haskell->LLVM DSL
09:46:38 <kmc> that sounds as much "rewritten in Haskell" as main = putStr "contents of a C file here"
09:46:47 <kmc> not that there aren't advantages to this approach
09:46:52 <kmc> it would be a cool research project
09:47:01 <kmc> but it's not the same as rewriting the RTS in Haskell
09:47:04 <accel> it seems like it would be cool to ahve the haskell RTS described in haskell
09:47:07 <edwardk> kmc: =)
09:47:09 <accel> via  a DSL
09:47:13 <moisan> luite : yes and no, this is ok for bird notation, I'm in latex notation :
09:47:18 <kmc> there's no "the Haskell RTS"
09:47:26 <kmc> each Haskell implementation has its own RTS
09:47:41 <c_wraith> Hell, GHC has two different RTSs
09:47:57 <kmc> anyway this is a cool project and i encourage you to do it accel
09:47:59 <c_wraith> With really rather significant differences between them.
09:48:03 <kmc> just be sure to market it correctly ;)
09:48:04 <edwardk> more if you count all the possible ways it can be built
09:48:12 <luite> moisan: ah, sorry I only use bird style
09:48:12 <kmc> c_wraith, threading and non?
09:48:15 <roconnor> if the RTS was written in Haskell then every haskell implementation could share it?
09:48:19 <luite> perhaps I should write more papers with haskell ;)
09:48:19 <roconnor> if they wanted
09:48:20 <c_wraith> kmc: yes, those are what I was thinking about
09:48:35 <moisan> luite : no problem, I think I found how to make it work, thanks :)
09:48:44 <edwardk> the problem is that in reality said RTS has so many compiler-specific quirks sharing it is difficult
09:49:21 <kmc> you could share an RTS written in C too
09:49:38 <edwardk> in many ways you can view a lot of things as sharing ghc's rts
09:50:14 <edwardk> and then there are folks like jhc, which aggressively optimize away most of what would be included in a traditional RTS until its not there anymore
09:50:30 <aristid> edwardk: comonad broke my haskell package system!
09:50:38 <edwardk> aristid: ack!
09:50:52 <edwardk> bad comonad! no donut!
09:50:58 <edwardk> what happened?
09:51:09 <paolino> famous cabal comonad allergy
09:51:27 <aristid> edwardk: it installed containers 0.4 on my ghc 6.12 system. and then i installed additional packages, which linked against container-0.4
09:51:35 <aristid> and others link against container-0.3
09:51:40 <aristid> which results in a funny clash
09:51:46 <c_wraith> really, nothing should install containers 0.4 on ghc 6
09:52:11 <aristid> yeah, and i should always use --dry-run before using cabal install
09:52:13 <edwardk> aristid: check to  make sure your global and local caches don't have some of the same packages and versions installed. it happens some times
09:52:31 <aristid> edwardk: no, the problem is that comonad has a dependency on container-0.4
09:52:37 <aristid> unnecessarily, i think
09:52:49 <edwardk> what causes containers 4 to be problematic on 6.12?
09:52:58 <edwardk> i've never had a problem with it
09:53:08 <paolino> containers 0.4 cannot be in user space for 6.12 ?
09:53:17 <aristid> edwardk: 6.12 ships with containers 3, and if some packages link against one version and others against the other...
09:53:17 <paolino> user db
09:53:20 <roconnor> edwardk: ya, what's with all the dependecies.  You should put all those lesnes for containers into a different file.
09:53:27 <roconnor> edwardk: preferably into containers :D
09:53:43 <roconnor> but at least into its own package
09:53:46 <edwardk> roconnor: i wind up needing containers up the tree anyways
09:53:51 <roconnor> what for?
09:54:01 <edwardk> roconnor: because there are instances of Apply, etc for them.
09:54:05 <roconnor> bah
09:54:07 <roconnor> wrongness
09:54:10 <edwardk> and i'm a later layer in the 'onion'
09:54:20 * roconnor is tempted to write his own comonad packages
09:54:37 <edwardk> since containers came first, and i'm downright unlikely to get containers which is depended on in ghc's build process to depend on all my esoteric crap
09:54:58 <roconnor> put those orphan instances in their own packages
09:55:08 <edwardk> so due to the vagaries of the build process i can either layer on top of it, or i can make everyone deal with orphans. fuck that
09:55:34 <edwardk> one way works right every time, the other way makes everyone have to hunt down some package that they may not find
09:56:00 <edwardk> i believe my entire package hierarchy has like 2 orphans in it
09:56:04 <roconnor> edwardk: it doesn't work every time.  See aristid's mess
09:56:21 <aristid> edwardk: just downgrade the dependency to 0.3
09:56:23 <edwardk> roconnor: i can probably depend on containers 0.3 up
09:56:26 <paolino> so, what is wrong in having containers 0.4 in user db for 6.12 ?
09:56:42 <edwardk> i just need to check that it doesn't break anything. everything i have done so far was predicated on 0.4 from keys on up
09:56:43 <aristid> paolino: new stuff always links against the newest version you have
09:56:57 <paolino> and ?
09:57:03 <aristid> paolino: and old stuff does not
09:57:04 <roconnor> edwardk: the more unecessary dependencies you bring in the worse it is for everyone
09:57:11 <aristid> paolino: so when you mix the old and the new, you get breakage
09:57:28 <edwardk> roconnor: trust me, i know, but there is a tension between that and orphans.
09:57:34 <roconnor> edwardk: why the heck should my use of comonads bring containers into the picture when I don't even use them.
09:57:42 <roconnor> edwardk: okay
09:57:52 <roconnor> edwardk: you probably know better than I do
09:57:58 * roconnor is still tempted to write his own comonad packages
09:58:01 <edwardk> you choose to come down on the other side of that argument than i do. i've had too many little packages break due to orphans to go that way again
09:58:16 <roconnor> edwardk: did you put each oprhan instance in its own package before?
09:58:26 <jmcarthur> if we could just specify some flags along with dependencies this wouldn't be an issue
09:58:34 <paolino> aristid: old stuff inside ghc that depends on 0.3 ?
09:58:36 <jmcarthur> as much of one anything
09:58:38 <djahandarie> It would be nice if something could automatically write your dependencies for you
09:58:38 <jmcarthur> *anyway
09:58:40 <edwardk> i've tried that approach, it doesn't scale. i have 20+ packages now.
09:58:44 <aristid> paolino: for example
09:58:57 <roconnor> damn
09:58:59 <edwardk> i'd wind up with something like 50
09:59:03 * roconnor rewrites Haskell
09:59:10 * djahandarie rewrites roconnor
09:59:19 <jmcarthur> it would mean you could have all these instances in the main package and then packages that depend on it could specify which ones they actually want with cabal flags
09:59:22 <edwardk> roconnor: this is why the first item in my greenfield haskell post was a note of the need for mixin packages
09:59:37 <jmcarthur> mixin packages are another way
09:59:44 <edwardk> jmcathur: doesn't work now because you can't say i need this package with these flags
10:00:08 <jmcarthur> edwardk: that's what i was suggesting as a solution. of course we con't have it right now :P
10:00:12 <jmcarthur> *don't
10:00:14 <kmc> obviously haskell is perfect and needs no improvement, just look at how short 'quicksort' is
10:00:26 * roconnor imagines pushout packages that you automatically get when you install both package A and package B
10:00:44 <jmcarthur> roconnor: i don't like that. would mean some random package might get installed that i wasn't expecting
10:00:50 <Jesin> lol
10:00:53 <kmc> when will cabal support the quantum mechanical theory of packages
10:00:55 <Jesin> @ quicksort
10:00:57 <Jesin> :p
10:01:04 <roconnor> jmcarthur: ya fair
10:01:19 <paolino> aristid: it is still obscure to me why I have to consider the old global packages, while I can have mine in my user db
10:01:26 <jmcarthur> roconnor: i'd rather things like that appear in one or the other package and only be "activated" if the other package is detected
10:01:30 <roconnor> jmcarthur: I think orphan instance packages would work. But I have no experience.  edwardk says that it doesn't scale which surprises me.
10:01:58 <roconnor> jmcarthur: how is that not equivalent to pushout packages?
10:01:58 <jmcarthur> orphan instance packages do work so long as the library writer doesn't mind maintaining tons and tons of individual packages
10:02:11 <jmcarthur> roconnor: sounds like a pushout package could just be written by some random guy
10:02:12 <edwardk> roconnor: they are patently unsafe is what bothers me, the scalability is a side-effect
10:02:28 * hackagebot comonad 1.0.2 - Haskell 98 comonads  http://hackage.haskell.org/package/comonad-1.0.2 (EdwardKmett)
10:02:44 * monochrom pulls-back a push-out package <duck>
10:02:52 <edwardk> i relaxed the requirement on comonad's dependency for you aristid, but if you install keys, etc. it will depend on containers 0.4
10:02:53 <roconnor> edwardk: unsafe in that I might install two different orphan instances?
10:02:58 <edwardk> roconnor: yes
10:03:01 <aristid> edwardk: thanks
10:03:25 <monochrom> does keys absolutely need container-0.4?
10:03:27 <roconnor> edwardk: that doesn't seem like it would be a serious problem in practice.
10:03:27 <aristid> edwardk: do any of your packages actually depend on features new since 0.4?
10:03:36 <roconnor> but maybe it would
10:03:39 <edwardk> monochrom: yes, it uses a number of methods on Seq that aren't there before 0.4
10:04:03 <paolino> aristid: if I use comonad all my compilation must be done with containers 0.4. Which are the things that must go inside my project which needs 0.3 that cannot be recompiled ?
10:04:06 <jmcarthur> i never saw large dependency lists as a problem, personally
10:04:32 <edwardk> let me revisit that, maybe they are there in 0.3
10:04:34 <jmcarthur> i don't add dependencies just for instances, normally, but i don't mind using as many as i want for basic implementation
10:04:35 <edwardk> checking
10:04:51 <aristid> paolino: i'm not sure if recompiling all system libraries is such a good idea
10:05:07 <edwardk> containers is part of the requirements for getting ghc up and running so i don't really view it, or array as real dependencies
10:05:10 <jmcarthur> i suppose it's tougher to maintain a package with larger dependencies since things change more often
10:05:47 <aristid> edwardk: could just add a GHC 7 requirement to those packages which need containers 0.4?
10:05:53 <paolino> edwardk: that is my point, thanks for saying it
10:06:19 <edwardk> aristid: i'd rather not, since they work fine in 6.12
10:06:46 <aristid> edwardk: there are no direct problems, but indirect problems can emerge...
10:06:58 <edwardk> aristid: let me see if i can relax my requirement on containers enough that you don't have to contort your build process
10:07:10 <edwardk> clearly other packages simply need to relax their upper bounds ;)
10:07:11 <aristid> well i don't have keys installed anyways :D
10:07:37 <aristid> and comonad just for playing around
10:07:59 <edwardk> *nods*
10:09:35 * paolino thinks some clever people should resolve this build process problems
10:09:49 <jmcarthur> woot, haskell-platform 2011.2.0.0-1 in arch linux's testing repo
10:09:53 <paolino> this should be hard stuff
10:10:29 <djahandarie> jmcarthur, do you know when it went in?
10:11:04 <djahandarie> Ah, the 5th
10:11:07 <jmcarthur> it was built on march 5th it looks like
10:11:25 <djahandarie> Probably still has that cabal-install issue then
10:11:28 <jmcarthur> what's holding up the platform's release?
10:11:30 * hackagebot comonad-transformers 1.5.2.5 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.5.2.5 (EdwardKmett)
10:11:30 <jmcarthur> ah that maybe
10:12:10 <mzero> yup - we are awaiting a cabal-install minor rev to fix an issue, then we'll rebuild RC installers for the platform
10:12:25 <moisan> I'm working on constraint programming problems during my master degree and I had a look at the paper Monadic Constraint Programming. It's really nice but the related cabal package (monadiccp) fails to compile, at least on my computer. What are my options?
10:13:04 <jmcarthur> might be able to get it to build by tweaking the project a little
10:13:53 <jmcarthur> by changing Build-depends a little. i'm assuming your problem is you have ghc 7 and the package requires an older version of base
10:14:31 <djahandarie> moisan, if you show the error we can probably help more
10:14:31 * hackagebot semigroupoids 1.1.2 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-1.1.2 (EdwardKmett)
10:14:56 <moisan> jmcarthur : no I have ghc 6.12.3
10:15:29 <edwardk> working my way through relaxing the containers dependencies
10:15:31 * hackagebot comonad-transformers 1.5.2.6 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-1.5.2.6 (EdwardKmett)
10:16:12 <moisan> djahandarie : here you go : http://pastebin.com/ffi5wttJ that the whole output of the build
10:18:09 <jmcarthur> ah looks like insufficiently tight dependency constraints
10:18:32 * hackagebot keys 0.2.3 - Keyed functors and containers  http://hackage.haskell.org/package/keys-0.2.3 (EdwardKmett)
10:18:47 <jmcarthur> it probably is wanting mtl < 2
10:19:00 <moisan> jmcarthur : ok, I'm a complete newbie when it comes to hackage packages, how can I fix that?
10:19:33 * hackagebot representable-functors 0.3.0.3 - Representable functors  http://hackage.haskell.org/package/representable-functors-0.3.0.3 (EdwardKmett)
10:20:19 <jmcarthur> moisan: run 'cabal unpack monadiccp; cd monadiccp', then edit the monadiccp.cabal file. change the Build-depends field so that instead of just saying 'mtl' it says 'mtl < 2'. then run 'cabal install'
10:20:47 <jmcarthur> moisan: also report it at as a bug to the maintainer, if you are awesome :)
10:21:04 <edwardk> jmcarthur: that is pretty much what i used to get it to install a few months back
10:21:34 * hackagebot adjunctions 0.9.0.4 - Adjunctions  http://hackage.haskell.org/package/adjunctions-0.9.0.4 (EdwardKmett)
10:21:57 <jmcarthur> looks like the bugtracker has been overrun with spam :\
10:22:39 <moisan> jmcarthur : yeah I looked at the bugtracker :(
10:22:45 <moisan> jmcarthur : did that, same error
10:22:57 <jmcarthur> that keys package looks nice, edwardk :)
10:23:39 <jmcarthur> moisan: i don't see how you'd have the same error. are you sure you ran 'cabal install' and not 'cabal install monadiccp'?
10:23:44 * jmcarthur tries it locally
10:24:01 <edwardk> jmcarthur: thanks. i need to factor it out into more than one module =)
10:24:25 <moisan> jmcarthur : yes I'm sure
10:24:33 <jmcarthur> moisan: alright, i'll give it a shot
10:25:15 <jmcarthur> moisan: it worked for me
10:25:22 <edwardk> ok, theoretically i factored out all the dependencies on containers 0.4. can someone with 6.12 uninstall containers 0.4, cabal update, and then cabal install representable-tries ? it should drag in a ton of packages, and hopefully not containers 0.4
10:25:36 * hackagebot representable-tries 0.3.1.2 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.3.1.2 (EdwardKmett)
10:25:41 <jmcarthur> moisan: "Build-Depends:      base >= 2 && < 4, containers, mtl < 2, haskell98, random"
10:25:45 <jmcarthur> moisan: is that what you have?
10:26:28 <moisan> jmcarthur : dumb me, I've put mtl > 2 :\, I rerun it...
10:27:09 <moisan> jmcarthur : compiled correctly :D
10:27:13 <jmcarthur> yay!
10:27:16 <moisan> jmcarthur: thanks a lot
10:27:18 <jmcarthur> np
10:33:45 <sgronblo> Which haskell module deals with file system operations like mkdir, copying and so on?
10:34:27 <edwardk> sgronblo: like http://www.haskell.org/ghc/docs/6.12.2/html/libraries/directory-1.0.1.1/System-Directory.html#v%3AcreateDirectory ?
10:34:40 * hackagebot satchmo-backends 1.8.2 - driver for external satchmo backends  http://hackage.haskell.org/package/satchmo-backends-1.8.2 (JohannesWaldmann)
10:35:57 <sgronblo> so that would return an empty IO action?
10:36:32 <Twey> Err
10:36:35 <Twey> It returns IO ()
10:36:37 <jmcarthur> sgronblo: an action is neither full nor empty
10:36:47 <Twey> It's not really accurate to call it an âempty actionâ; the action itself carries information
10:36:53 <edwardk> it takes a filepath and returns an io action that only gives back a unit as its result. throwing exceptions on failure. not sure i'd call it an 'empty IO action'
10:37:00 <sgronblo> a unit?
10:37:01 <jmcarthur> this analogy of monads as containers is unhealthy
10:37:12 <jmcarthur> it's so popular and misleading
10:37:19 <Twey> The analogy of functors as containers is nicer
10:37:27 <jmcarthur> even then
10:37:29 <jmcarthur> IO is a functor
10:37:30 <Twey> sgronblo: ()
10:37:33 <Twey> jmcarthur: Right
10:37:34 <jmcarthur> but it doesn't contain anything
10:37:38 <ion> I think we already reached the conclusion that a monad is a burrito.
10:37:44 <Twey> No, but the interface it presents behaves as if it did
10:37:49 <edwardk> ion: wrapped around a spacesuit
10:37:50 <sgronblo> Twey: yeah, empty tuple?
10:37:57 <Twey> sgronblo: You can think of it like that
10:38:00 <Twey> sgronblo: It's the type ()
10:38:09 <Twey> It has only one non-bottom value, which is also written ()
10:38:10 <jmcarthur> Twey: i disagree. if it behaved as though it contained a string then you would always get the same string from it
10:38:28 <toki78> the state transformer monad is a container ?
10:38:36 <jmcarthur> toki78: no, it's a transformer
10:38:44 <Twey> jmcarthur: You don't get a string from it at all
10:38:49 <Twey> jmcarthur: The lid on the box is one-way :Ã¾
10:38:49 <jmcarthur> toki78: it takes a state as input and returns a state as output
10:39:01 <toki78> jmcarthur, ok
10:39:02 <sgronblo> I think I don't get this IO () quite yet
10:39:04 <jmcarthur> Twey: then my point is driven further
10:39:21 <c_wraith> sgronblo: in the case of IO, forget you've ever heard the word "monad", and just learn how to use IO.
10:39:24 <Twey> You can think of it as getting a box with a value, but you don't know what the value is yet
10:39:44 <Twey> fmap does something to this mystery value
10:39:55 <jmcarthur> Twey: you never know what the value is, if we run with the whole "you can't get it out" thing. very uncontainer-like
10:39:55 <roconnor> @wiki IO_Semantics
10:39:56 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
10:39:59 <Twey> It's a fairly decent analogy
10:39:59 <c_wraith> > fmap (*5) Nothing
10:40:00 <lambdabot>   Nothing
10:40:04 <Twey> *shrug*
10:40:11 <Twey> Helped me when I was trying to figure it all out
10:40:31 <Twey> (though âMonads as Computationsâ was more useful)
10:40:39 <sgronblo> anyway, I was kind of thinking if modeling IO as actions/monads/burritos/whatever made testing filesystem modifications any easier than in other languages where you usually end up mocking a filesystem for example
10:40:48 <jmcarthur> yeah, does Maybe String contain a string? even in behavior?
10:41:00 <roconnor> thinking of IO as a freely genreated monad is the best way I've seen IO
10:41:10 <jmcarthur> roconnor: this again ;)
10:41:23 <sgronblo> so I had the brilliant idea that a function should just return a sequence of filesystem operations to perform and they could then be inspected to see that the right actions are performed without having to perform them
10:41:28 <jmcarthur> i prefer to think of IO as an embedded, imperative language, and that's it
10:41:33 <Twey> jmcarthur: Maybe ;)
10:41:34 <roconnor> jmcarthur: I'm not alone in thinking this
10:41:52 <jmcarthur> sgronblo: sounds like something you would do with MonadPrompt
10:41:53 <Twey> Again, you can see it as performing an action on some unknown value
10:42:11 <jmcarthur> sgronblo: there also something called SpecIO, iirc, but i've never used it and don't think i understand it fully
10:42:14 <roconnor> jmcarthur: what I said is simply a more accurate version of what you said
10:42:21 <Twey> The special sauce Maybe brings to the table is that when you come to actually get the value out, there's a chance that whoops! the value was never there.
10:42:39 <jmcarthur> roconnor: i don't think either meaning gives us any clarity about it though :(
10:43:22 <roconnor> jmcarthur: I find a lot of clarity from thinking about the freely genreated monad.  At least much more clear than the State RealWorld nonsense.
10:43:37 <roconnor> jmcarthur: not that you are advocating State RealWorld
10:43:45 <jmcarthur> certainly not! :)
10:43:58 <roconnor> but that was my previous model, and that was hard to understand
10:44:05 <roconnor> since it makes no sense :D
10:44:07 <jmcarthur> i just don't have a model
10:44:15 <roconnor> heh
10:44:16 <dolio> State RealWorld doesn't even work as a model.
10:44:16 <jmcarthur> i have an operational semantics, and that's it
10:44:33 <jmcarthur> (and even that is not really *defined*)
10:44:34 <roconnor> well, having a free model is about as close to having no model as you can get while still having a model
10:44:47 <jmcarthur> yeah
10:44:52 <jmcarthur> i suppose you're right
10:45:01 <jmcarthur> basically all it tells you is that you have a monad
10:45:05 <roconnor> so I think it is a good way to introduce IO to people
10:45:08 <roconnor> right
10:45:24 <monochrom> "RealWorld# is not enough" :)
10:45:43 <roconnor> once you have a Tree of IO primatives, it is pretty intuative what it would mean to execute such a tree.
10:45:53 <c_wraith> monochrom: Is that a new Haskell action movie?
10:45:57 <edwardk> i prefer to live in MyOwnLittleWorld#. They know me there.
10:45:59 <roconnor> the Tree of IO primiative is similar but not quite the same as an imperitive langauge
10:46:16 <ion> There should be a Haskell: The Movie in the style of Erlang: The Movie.
10:46:31 <c_wraith> ion: who would have the lack of shame necessary to appear in it?
10:46:41 <mjrosenb> there is an Erlang: The Movie?
10:46:52 <monochrom> me. I will play the role of Phil Wadler.
10:47:03 <roconnor> I'd like to think that new haskell users, if taught about IO trees could intuitively grasp the leap from there to operational semantics, even if we dont' formally define it.
10:47:04 <edwardk> ion: could work, SPJ has sort of that Mr. Rogers vibe going with sweater vests and all
10:47:18 <c_wraith> mjrosenb: it's one of the most terrible "movies" ever.  Check it out.
10:47:25 <jmcarthur> Haskell: The Movie: The Trailer: The Summary: Condensed Edition
10:47:40 <jmcarthur> "Something about Haskell happens."
10:47:58 <Eduard_Munteanu> "Evaluate this!"
10:48:04 <jmcarthur> *boom*
10:48:05 <monochrom> hahaha
10:48:11 <sgronblo> so what is this unit really?
10:48:21 <roconnor> @wiki IO_Semantics
10:48:22 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
10:48:29 <roconnor> sgronblo: I suggest you read that
10:48:32 <sgronblo> all right all right
10:48:35 <edwardk> jmcarthur: i could totally see a "well-typed" logo popping up during the opening credits.
10:48:40 <roconnor> sgronblo: let me know if it is helpful
10:49:45 <sgronblo> I'll just try to get through this taste of haskell part II vid first
10:51:59 <monochrom> taste of haskell II: the vampire bites back
10:52:44 <jmcarthur> It's a documentary about the oppression of thunks. They get tired of being forced and revolt against the evil RealWorld. It focuses mainly on a thunk leading a simple, pure life and being forced to provide attack coordinates for a missile, something he just doesn't want to do.
10:53:41 <monochrom> what a lazy thunk
10:54:30 <edwardk> jmcarthur: but then its a tragedy, because being unnecessary, he finds himself garbage collected
10:54:39 <sgronblo> is haskell used in weapons technology?
10:55:03 <ville> I hear it's used to kill civilians.
10:55:20 <sgronblo> heads blow up when you try to understand monads
10:55:27 <byorgey> sgronblo: probably not, but lots of weapons technology is used in Haskell.
10:55:27 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
10:55:28 <edwardk> sgronblo: haskell programmers love to write methods called launchMissiles, however, I'm unaware of any code that _actually_ launched any missiles using Haskell that are larger than the hobby variety ;)
10:55:38 <c_wraith> sgronblo: it's possible, but not the most likely.  There are government contractors who do work in Haskell.  *shrug*
10:55:55 <sgronblo> wasnt ada the military language btw?
10:56:01 <byorgey> edwardk: I've been trying to prove that all distributives are functors via parametricity
10:56:12 <sgronblo> at least the us military
10:56:22 <c_wraith> yes, ada has a history of being required in many military apps
10:56:24 <byorgey> I haven't made too much progress yet, unless you count the fact that I understand parametricity a lot better now =)
10:56:29 <edwardk> byorgey: i just dropped fmapDefault. it can only be defined through cotraverse, and cotraverse is useless in practice. collect is more useful
10:56:52 <edwardk> i left the functor superclass in though, since i'm only interested in these where f is a functor
10:56:55 <djahandarie> cotraverse? How is that different than distribute? Or is distribute the analog of sequence?
10:56:58 * djahandarie checks
10:57:09 <byorgey> edwardk: can it really be defined via cotraverse?
10:57:14 <byorgey> edwardk: sure, the superclass is fine
10:57:17 <edwardk> byorgey: yeah
10:57:27 <byorgey> edwardk: ok, don't tell me, let me think about it for a minute
10:57:43 <edwardk> flip fmapDefault from Data.Traversable around a little
10:57:48 <djahandarie> Wait, isn't collect cotraverse?
10:57:58 <edwardk> djahandarie: no i deliberately put the fmap on the wrong side
10:58:13 <djahandarie> Hmm
10:58:34 <edwardk> it turned out that if collect was cotraverse, you'd almost always have to fmap again anyways inside of its definition
10:58:37 <edwardk> this fused better
10:59:33 <edwardk> collect led to a much nicer programming style
10:59:42 <sgronblo> in what language does nub mean essence?
11:00:00 <sgronblo> oh
11:00:00 <c_wraith> english.  Archaicly
11:00:01 <sgronblo> never mind
11:00:21 <sgronblo> yeah never heard that word used before
11:00:28 <edwardk> but defining collect in terms of distribute which was then defined in terms of cotraverse led to a lot of redundant fmaps, so i pulled cotraverse out of the class, because i never had any case that it actually was implementable as anything _but_ distribute and fmap
11:00:31 <byorgey> edwardk: but the definition of cotraverse makes use of the Functor superclass for the distributive.
11:00:55 <byorgey> I think defining fmapDefault in terms of cotraverse would lead to the exact same loop.
11:00:57 <edwardk> byorgey: yes, as does the definition of traverse
11:01:02 <roconnor> awesome.  The category of field homomorphisms isn't connected.
11:01:16 <edwardk> no, different loop, note the fmapDefault was collecting over _Identity_ by accident
11:01:33 <roconnor> and decomposes into categories of fields with the various possible characteristics.
11:01:33 <edwardk> that was why i didn't understand your first objection
11:02:16 <edwardk> i was still reading it as the loop between cotraverse and Distributive.fmapDefault, which would be identical to the one between traverse and Traversable.fmapDefault, present but broken by defining traverse
11:02:39 <byorgey> hmm, ok, I'll have to think about this more
11:02:45 <edwardk> byorgey: to make a usable fmapDefault you'd need cotraverse in the class, and to have distribute and collect defined in terms of it
11:03:01 <edwardk> but as i mentioned that leads to a crappy implementation
11:03:40 <byorgey> edwardk: oh, I see now, yes.
11:03:54 <djahandarie> It is more clear how it's the dual of Traversable with cotraverse in the class though
11:04:03 <djahandarie> Should perhaps make a note
11:04:06 <edwardk> djahandarie: i'm more concerned with usability =)
11:04:31 <edwardk> probably.
11:05:34 <byorgey> now I'm confused about how the fmapDefault for Traversable gets off the ground if you only define sequenceA instead of traverse
11:05:38 <byorgey> or doesn't it?
11:05:55 <roconnor> djahandarie: Categories for Compting Sciences
11:06:07 <roconnor> djahandarie: Category Theory for Compting Science is really really good
11:06:12 <edwardk> byorgey: they don't
11:06:30 <edwardk> you have to define traverse to get fmapDefault to work, it is an unstated assumption in Data.Traversable
11:06:32 <byorgey> ok.  That's arguably a bug in the Traversable documentation then.
11:06:36 <edwardk> yep
11:06:37 <byorgey> I see.
11:06:46 <djahandarie> roconnor, you've recommended this enough times that I think I'm going to try and get it
11:06:51 <djahandarie> Is it online somewhere?
11:06:59 <byorgey> edwardk: ok, thanks, things are clearer to me now.
11:06:59 <edwardk> i was kicking around the idea of submitting that
11:07:13 <monochrom> @wn nub
11:07:14 <lambdabot> *** "nub" wn "WordNet (r) 2.0"
11:07:14 <lambdabot> nub
11:07:14 <lambdabot>      n 1: a small lump or protuberance [syn: {nubble}]
11:07:17 <edwardk> feel free to do so ;)
11:07:39 <byorgey> edwardk: but I haven't yet given up on my project to prove functoriality of something given only distribute, via some sort of parametricity result
11:07:40 <Eduard_Munteanu> @more
11:07:41 <lambdabot>         idea or experience; "the gist of the prosecutor's
11:07:41 <lambdabot>         argument"; "the heart and soul of the Republican Party";
11:07:41 <lambdabot>         "the nub of the story" [syn: {kernel}, {substance}, {core},
11:07:43 <byorgey> edwardk: ok, perhaps I will =)
11:08:06 <monochrom> @more
11:08:18 <monochrom> @nobotsnack
11:08:18 <lambdabot> :)
11:08:34 <roconnor> byorgey: what is distrubite?
11:08:36 <monochrom> interesting
11:08:38 <edwardk> byorgey: hrmm, consider the distributive property in more depth though, when you consider it is implied for all right adjoints
11:08:44 * roconnor has gotten pretty good at parametric arguments recently
11:08:49 <quotemstr> Can you look at PEGs as a kind of parser combinator?
11:08:51 <edwardk> roconnor: http://hackage.haskell.org/packages/archive/distributive/0.1.2/doc/html/Data-Distributive.html
11:08:59 <djahandarie> Hmm, would have to get the book from Yale
11:09:07 <byorgey> roconnor: distribute :: Functor f => f (g a) -> g (f a)
11:09:16 <byorgey> for a particular g
11:09:23 <edwardk> class Functor g => Distributive g where distribute :: Functor f => f (g a) -> g (f a)
11:09:28 <mjrosenb> quotemstr: PEG?
11:09:38 <quotemstr> mjrosenb: parsing expression grammar
11:09:43 * Eduard_Munteanu saw that in connection with combining monads with comonads
11:09:43 <roconnor> byorgey: what is the claim?
11:10:06 <quotemstr> mjrosenb: Granted, they'd have a highly nonstandard "function" syntax, but it seems like a reasonable analogy.
11:10:19 <byorgey> roconnor: the claim is that g must be a little-f functor, although I don't think you can write a Functor instance
11:10:46 <Eduard_Munteanu> BTW, is there any useful monad+comonad construction?
11:10:48 <byorgey> roconnor: although I'm not even sure whether such a situation makes sense.
11:10:53 <roconnor> byorgey: what is a little-f functor?
11:11:31 <edwardk> roconnor: functor in the mathematical sense
11:11:42 <byorgey> roconnor: well, maybe let's put it this way: g must be a type constructor for which there exists a valid Functor instance.
11:11:59 <edwardk> Eduard_Munteanu: sure. but the bikleisli stuff generally sucks to use ;)
11:12:01 <byorgey> but I don't know if you can prove it constructively by writing such an instance in terms of distribute.
11:12:10 <edwardk> Eduard_Munteanu: i find in practice comonads _over_ kleisli categories work fine though
11:12:34 <roconnor> let me see if I understand.  The idea is that if there exists foo :: foall f :: Functor, f (g a) -> g (f a) then g is a functor (and maybe even fmap is definable using foo)?
11:12:34 <Eduard_Munteanu> Ah.
11:12:48 <edwardk> roconnor: thats basically what he is hunting for
11:12:58 <byorgey> roconnor: right, although I am pretty sure fmap is NOT definable using foo.
11:13:43 <edwardk> distributive may be better said as continuous, traversable as cocontinuous, not sure.
11:14:10 <Eduard_Munteanu> I found that instructive a while ago: http://blog.sigfpe.com/2008/03/transforming-comonad-with-monad.html
11:14:28 <edwardk> Eduard_Munteanu: yeah but that construction tends to suck in practice
11:14:48 <edwardk> Eduard_Munteanu: thats why i mentioned i prefer comonads in a kleisli category or monads in a cokleisli category
11:15:11 <edwardk> that way its not a distributive law, but in many ways, one being 'absorbed' into the other.
11:15:23 <Eduard_Munteanu> Would that be something like having, e.g. Stream over Identity?
11:15:29 <edwardk> this lets you pool your effects better. otherwise things explode combinatorially
11:15:29 <Eduard_Munteanu> Oh.
11:16:09 <edwardk> think of one of russell's store comonads, not empower it to use IO to memoize intermediate results
11:16:23 <Eduard_Munteanu> edwardk: are you arguing for ignoring Distributive, and just putting cojoin and counit in a Monad?
11:16:23 <edwardk> that would be a comonad over the kleisli-IO category for instance
11:16:49 <Eduard_Munteanu> Ah.
11:17:09 <rwbarton> oh interesting
11:17:16 <rwbarton> so something like w a -> IO (w (w a))?
11:17:23 <edwardk> Eduard_Munteanu: kinda though it is confusing to talk about two very different distributive classes on channel at the same time ;) i'm advocating that Distributive is a crappy abstraction to build a mixed monad-comonad soup out of
11:17:32 <edwardk> rwbarton: yeah
11:18:10 <edwardk> rwbarton: and extract :: IOStore s a -> IO a
11:18:52 <Eduard_Munteanu> Hrm, does that still obey comonad laws? :/
11:19:00 <Eduard_Munteanu> Or it's just bending it a little?
11:19:04 <edwardk> rwbarton: one of the motivating factors behind splitting extend and extract is that i can typically write an 'extend' even for these 'kleisli'd' monads, even though extract is impossible
11:19:33 <edwardk> Eduard_Munteanu: you can obey the comonad laws, just in a different category
11:19:34 <kmc> rwbarton: i finally got around to releasing my udis86 bindings, only to discover that a friend had also written some
11:19:53 <Eduard_Munteanu> So it's not an endofunctor in Hask.
11:19:57 <edwardk> kmc: hah, you have udis86 bindings as well?
11:20:05 <kmc> edwardk, did you write some?
11:20:14 <kmc> http://hackage.haskell.org/package/hdis86
11:20:36 <edwardk> Eduard_Munteanu: well, it can be an endofunctor in hask, but you'll be using it as an endofunctor over the kleisli category of IO
11:20:45 <Eduard_Munteanu> Aha.
11:20:55 <edwardk> kmc: yeah i needed them when i started porting some of my jit plumbing
11:20:56 <Eduard_Munteanu> Yeah, that's still Hask,
11:21:00 <kmc> haha
11:21:09 <edwardk> Eduard_Munteanu: depends on how anal retentive you get ;)
11:21:28 <kmc> i need to actually write a JIT one of these days
11:21:32 <kmc> a tracing JIT
11:21:37 <kmc> to really understand how they work
11:21:39 <edwardk> good you can pick up mine! =)
11:21:41 <Eduard_Munteanu> I mean, you can only have endofunctors in Haskell, mostly.
11:21:44 <kmc> i was thinking of compiling 8-bit AVR machine code
11:21:48 <kmc> for no particular reason
11:21:58 * hackagebot mutable-iter 0.6 - iteratees based upon mutable buffers  http://hackage.haskell.org/package/mutable-iter-0.6 (JohnLato)
11:22:17 <TomMD> The language-c package seems to err on C comments - is there another package I should use instead of or in conjunction with langauge-c?
11:22:21 <kmc> i could simulate thousands of $2 8 MHz microcontrollers on my 6-core 3 GHz desktop
11:22:23 <aristid> edwardk: would it make sense to have a language with direct built-in support for kleisli-ing?
11:23:05 <edwardk> aristid: they call that ML ;)
11:23:10 <kmc> edwardk, anyway if you have anything to add to my udis86 bindings i'd love to accept patches
11:23:21 <edwardk> aristid: well in the kleisli'd IO case ;)
11:23:27 <kmc> or just upload yours and Let The People Decide
11:23:28 <aristid> edwardk: i meant more generally ;)
11:23:34 <edwardk> kmc: yours seem more complete than mine
11:23:52 <edwardk> kmc: i was mostly abusing it to sanity check my own instruction decoder
11:23:57 <edwardk> so i didn't need much
11:24:01 <kmc> heh, ok
11:24:24 <jmcarthur> aristid: this might help http://www.cs.berkeley.edu/~megacz/garrows/
11:25:02 <jmcarthur> i'm not sure i like the sugar that much, but the generalization is much needed
11:25:40 <edwardk> aristid: anyways wadler's version of the arrow calculus has that general flavor, and as jmcarthur pointed out there is some nascent support for some kind of generalized arrows i need to play with still
11:25:49 <jmcarthur> it would be nice to have monad and comonad defined in terms of category, not just kleisli/cokleisli
11:25:54 <aristid> you _can_ lift all pure functions into kleisli functions, right?
11:25:59 * hackagebot sndfile-enumerators 0.8.0 - Audio file reading/writing  http://hackage.haskell.org/package/sndfile-enumerators-0.8.0 (JohnLato)
11:26:01 <Ptival> :t ($)
11:26:01 <lambdabot> forall a b. (a -> b) -> a -> b
11:26:13 <edwardk> aristid arr = Kleisli . return
11:26:25 <hpc> :t Kleisli . return
11:26:26 <lambdabot> forall a (m :: * -> *) b. m b -> Kleisli m a b
11:26:31 <jmcarthur> yeah for kleisli you can do that. not for arbitrary categories though
11:26:35 <edwardk> er arr f = Kleisli . return . f
11:26:35 <hpc> :t arr
11:26:36 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
11:26:59 <edwardk> :t (Kleisli . return .)
11:27:00 <lambdabot>     The operator `.' [infixr 9] of a section
11:27:00 <lambdabot>         must have lower precedence than that of the operand,
11:27:00 <lambdabot>           namely `.' [infixr 9]
11:27:02 <aristid> so you can strictly get rid of a -> b and replace it by Monad f => a -> f b, without making the language less expressive?
11:27:04 <edwardk> bah
11:27:12 <edwardk> :t \f -> Kleisli . return . f
11:27:13 <lambdabot> forall a (m :: * -> *) b (f :: * -> *). (Functor f) => f (m b) -> f (Kleisli m a b)
11:27:23 <aristid> :t Kleisli . return
11:27:24 <lambdabot> forall a (m :: * -> *) b. m b -> Kleisli m a b
11:27:29 <edwardk> :t \f -> Kleisli (return . f)
11:27:29 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a) -> Kleisli m a1 a
11:27:34 <edwardk> better =)
11:27:38 <edwardk> fifth times the charm
11:28:45 * Eduard_Munteanu wonders about experimenting with something funny, like CoRWS or CoST.
11:28:56 <hpc> Eduard_Munteanu: CoIO?
11:28:58 <hpc> :D
11:29:06 <Eduard_Munteanu> OI FTW
11:29:17 <aristid> jmcarthur: i don't think generalized arrows is what i was thinking of, because it seems to be merely an extension of haskell
11:29:22 <edwardk> Eduard_Munteanu: OI doesn't work in Hask
11:29:25 <Eduard_Munteanu> I wonder how much of that referential transparency breaking criticism would apply to CoST.
11:29:27 <edwardk> every functor being strong screws you
11:29:31 <aristid> jmcarthur: i was thinking of a language where EVERY function is automatically kleisli'd
11:29:31 <Eduard_Munteanu> Yeah, I know.
11:29:51 <edwardk> you need some form of substructural typing to make OI make sense
11:29:54 <hpc> edwardk: says you; OI is trivial once you figure out how to reverse the flow of time!
11:29:57 <jmcarthur> aristid: ah, and with something like an implicit stack of Identity functors or something for "pure" functions?
11:30:08 <aristid> jmcarthur: yes, something like that
11:30:11 <edwardk> hpc: thats trivial, just use the backwards state monad when defining IO!
11:30:32 <aristid> jmcarthur: well, actually pure functions can just have a polymorphic Monad in there :)
11:30:40 <dmwit> You don't even need to do anything! Physics tells us time is running backwards (in a world where left is right and right is left) via CPT symmetry. ;-)
11:30:52 <Eduard_Munteanu> CoST might be workable, right?
11:31:10 <Eduard_Munteanu> though runCoST would be really funny.
11:31:50 <edwardk> Eduard_Munteanu: i'm pretty sure that also doesn't work
11:32:22 <jmcarthur> return :: Monad (~>) m => a ~> m a; join :: Monad (~>) m => m (m a) ~> m a    -- would be pretty neat, for some Category (~>). having played with it, it's not even that painful. but most obvious instances are just in Hask, of course
11:32:50 <edwardk> jmcarthur: its in category-extras, but not turned on as the default
11:33:24 <jmcarthur> it's also in alt-stdlib
11:33:33 <edwardk> tricky one is getting folks comfortable with bind :: (a ~> m b) -> m a ~> m b
11:33:53 <edwardk> once they see that they have less trouble understanding comonads
11:33:58 <jmcarthur> i prefer that one anyway
11:34:02 <edwardk> me too
11:34:26 <Eduard_Munteanu> What was (~>)? The arrow category?
11:34:38 <edwardk> yeah
11:34:55 <edwardk> whatever category your monad is built over
11:34:58 <jmcarthur> just Category
11:34:59 <Eduard_Munteanu> I presume it won't work for all arrows then.
11:35:03 <jmcarthur> *some instance of Category
11:35:15 <Peaker> what categories are useful to build monads over?
11:35:22 <jmcarthur> Eduard_Munteanu: its a parameter of the Monad type class, in this scenario
11:35:32 <jmcarthur> Eduard_Munteanu: and requires a Category instance
11:35:42 <edwardk> peaker: almost all of them. you can get 'closure operators' as monads over posets, etc.
11:35:50 <jmcarthur> Eduard_Munteanu: so right, it's not going to work for arbitrary Monad's from Hask with arbitrary Categories
11:35:58 <edwardk> peaker: 'ceil' is a nice monad over the reals
11:36:43 <roconnor> ciel isn't even continuous
11:37:07 <jmcarthur> *monads
11:37:12 <copumpkin> why does continuity matter there?
11:37:22 <edwardk> and?
11:37:38 <roconnor> if you aren't going to talk about the topology of the reals you might as well talk about the powerset of N then.
11:38:04 <copumpkin> talking about the total order category over the reals, and ceil is a functor over that
11:38:29 <edwardk> sure. i was just giving an example in a category that you could view as a total order
11:38:45 <edwardk> something to jar someone out of the 'monads are containers' mindset
11:38:54 <jmcarthur> :D
11:38:56 <edwardk> powerset doesn't have that same oomph here =)
11:38:57 <copumpkin> monads are things
11:38:58 <roconnor> oh okay
11:39:06 <djahandarie> monads are monads
11:39:06 <copumpkin> that'll be my explanation
11:39:14 <roconnor> thought I find Cont a pretty good jarring out of thinking of monads as containers
11:39:24 <copumpkin> Cont still can be a container
11:39:25 <djahandarie> @quote dolio monads
11:39:25 <lambdabot> dolio says: Monad are just monads in the 2-category of categories.
11:39:27 <copumpkin> Cont-ainer
11:39:28 <copumpkin> ;)
11:39:34 <copumpkin> also, existential-ish thing
11:39:38 <edwardk> hahaha
11:39:58 <jmcarthur> Cont is actually a very good example of a monad that *is* a container, IMO
11:40:08 <jmcarthur> it just contains a value in its closure
11:40:14 <rwbarton> surely [] is a much better example
11:40:26 <jmcarthur> rwbarton: but the value [] contains no value
11:40:33 <copumpkin> rwbarton: it just contains multiple (or no) values at once! :P
11:40:46 <rwbarton> you can come up with many Cont values which are far weirder than anything you can make with []
11:40:55 <copumpkin> :P
11:40:57 <jmcarthur> rwbarton: but they will all contain values
11:41:09 <rwbarton> not really
11:41:09 <copumpkin> I think we need a formal definition of container before we proceed here ;)
11:41:12 <dmwit> Cont values may contain no value at all, as well, jmcarthur.
11:41:18 <edwardk_> gah, anyways Cont is just a container that is very secretive, not telling you _all_ of the things it knows about the value it has hidden away in a closure somewhere
11:41:19 <jmcarthur> dmwit: e.g.?
11:41:23 <dmwit> ?unmtl Cont a b
11:41:23 <lambdabot> (b -> a) -> a
11:41:30 <rwbarton> Cont (\f -> 0) :: Cont Int Int
11:41:39 <jmcarthur> rwbarton: that contains 0
11:41:41 <roconnor> jmcarthur, copumpkin: I was convinced that Cont isn't a container when it was showed that fmap ($a) x = fmap ($b) y doesn't imply that x = y
11:41:42 <rwbarton> no
11:41:43 <dmwit> :t const 3 -- doesn't contain a 'b'
11:41:44 <lambdabot> forall t b. (Num t) => b -> t
11:41:44 <rwbarton> it was a poor example
11:41:49 <rwbarton> Cont (\f -> 0) :: Cont Int Bool
11:41:50 <edwardk_> dmwit: find, then yoneda or codensity id ;)
11:41:52 <edwardk_> er fine
11:41:59 <rwbarton> where is the Bool?
11:42:03 <hpc> Cont ($5) :: Cont x Int
11:42:12 <copumpkin> rwbarton: iz hiding, u no can see
11:42:22 <copumpkin> ceiling cat haz it
11:42:25 <rwbarton> invizible value
11:43:07 <roconnor> rwbarton: just because a containter is empty doesn't mean it isn't a container
11:43:19 <rwbarton> Sure.
11:43:26 <rwbarton> < jmcarthur> rwbarton: but the value [] contains no value
11:43:33 <djahandarie> How do you define a container? A monad? ;)
11:43:37 <jmcarthur> roconnor: that should have been directed at me
11:43:39 <rwbarton> I was arguing that [] was a better example of a container than Cont.
11:43:47 <kmc> a container is like a tortilla
11:43:49 <Eduard_Munteanu> djahandarie: functor?
11:43:53 <jmcarthur> rwbarton: and okay, i buy your argument
11:43:58 * copumpkin eats a container
11:44:01 <rwbarton> Actually, I didn't really argue it, I just stated it. :)
11:44:03 <kmc> therefore the key difference between a container and a monad is delicious carne asada
11:44:12 <copumpkin> mmm
11:44:12 <jmcarthur> s/argument/evidence/
11:44:26 <roconnor> jmcarthur: I don't know how to define a containter, but I would at least expect (forall x. fmap ($x) a = fmap ($x) b) to imply a = b for a container
11:44:31 <roconnor> er
11:44:34 <roconnor> djahandarie: ^^
11:44:46 * fryguybob sticks with bean and cheese.
11:45:00 <djahandarie> @remember kmc [After discussing monads, containers, and tortillas] therefore the key difference between a container and a monad is delicious carne asada
11:45:00 <lambdabot> Okay.
11:45:06 <jmcarthur> roconnor: to me, the idea of something as a container is very operational. that may be where our differences come from
11:45:22 <roconnor> jmcarthur: so you don't expect containers to have this property I said?
11:45:27 <sgronblo> simon peyton jones: comic sans + ...
11:45:32 <sgronblo> internet explorer
11:45:43 <acowley> jmcarthur: I think of Functoriality as related to the essence of containers
11:45:57 <acowley> like roconnor 
11:46:03 <jmcarthur> roconnor: that looks like a fundamental property of Functor, isn't it?
11:46:13 <roconnor> jmcarthur: in fact it is false for Cont
11:46:33 <roconnor> jmcarthur: I was trying to prove it on #haskell a few weeks ago before rwbarton set me straight
11:46:40 <jmcarthur> acowley: yeah that seems to be the most common characterization of "container" apart from operational things. i never understood the significance of using the word "container" at all, if it just means functor
11:46:44 <Eduard_Munteanu> class (Functor f) => Container f where pack :: a -> f a; unpack :: f a -> a
11:47:29 <jmcarthur> Eduard_Munteanu: many Functors that can't be instances of your Container are still called containers
11:47:33 <acowley> jmcarthur: "functor" is too funny a word, and ML used it already
11:47:35 <jmcarthur> by many people, at least
11:47:48 <jmcarthur> acowley: isn't "functor" older than ML?
11:47:52 <acowley> jmcarthur: of course
11:48:03 <Eduard_Munteanu> (though fmap could be pack . f . unpack)
11:48:06 <Peaker> Eduard_Munteanu, That would be a silly class
11:48:07 <acowley> jmcarthur: but the hordes of ML programmers running around will be confused!
11:48:09 <jmcarthur> and i'd rather go with something well-defined than something interpreted in many different ways
11:48:12 <Eduard_Munteanu> Yes! :)
11:48:27 <roconnor> I think the fact that jmcarthur thought my equation was true for all functors simply shows confusion between functors and containers
11:48:38 * jmcarthur looks at roconnor's property again
11:49:12 <copumpkin> his property is private
11:49:16 <copumpkin> don't violate it
11:49:31 <acowley> this just got awkward
11:49:56 <roconnor> copumpkin: I'm an anarchist. I don't believe in private properties
11:50:13 <c_wraith> roconnor: so you won't mind if I move in to your place?
11:50:25 <jmcarthur> roconnor: what is an example of a functor that doesn't have that property? have any in mind?
11:50:28 <edwardk_> personally i tend to add up a lot of little properties to define a container, the notion of a key, selecting values by keys, mapping with keys, etc.
11:50:37 <roconnor> c_wraith: as long as I can move into yours
11:50:39 <acowley> A key!?
11:50:52 <roconnor> jmcarthur: Cont
11:51:24 <byorgey> acowley: I know what he means by that and it's a lot more sensible than you think =)
11:51:31 <roconnor> c_wraith: actually I kinda like private property =)
11:51:35 <edwardk_> acowley: http://hackage.haskell.org/packages/archive/keys/0.2.2/doc/html/Data-Key.html
11:51:53 <djahandarie> zip zap
11:52:07 <azaq23> anarchism / socialism is about public / nonprivate possession of the means of production, not anything anyone owns
11:52:10 <edwardk_> djahandarie: zip is zip, zap is zip ap ;)
11:52:12 <c_wraith> roconnor: sorry, I do believe in private property. :)
11:52:19 <roconnor> c_wraith: though I think "owners" of private proptery ought to componsate everyone else for their monopoly.  Call such componsation taxes
11:52:24 <edwardk_> er zip id
11:52:34 <djahandarie> zipWith id?
11:52:35 <edwardk_> and would be a valid definition for ap if you wanted it to be zippy
11:52:51 <edwardk_> yeah
11:53:21 <edwardk_> Zip is only in there coz i needed it for ZipWithKey
11:53:38 <edwardk_> anyways almost all of these things come for free on representable functors
11:53:46 <edwardk_> so defining two methods gives you 90% of these
11:53:48 <acowley> Hrmph, I still don't see why you would need a key to be a container
11:54:00 <djahandarie> You depend on keys for representable functors though don't you?
11:54:02 <Eduard_Munteanu> acowley: so you can lock it somehow!
11:54:04 <roconnor> jmcarthur: Set is another functor that doesn't have that property.  But it isn't a regular data type.
11:54:16 <acowley> Eduard_Munteanu: no privacy, just anarchy
11:54:22 <edwardk_> acowley: you don't. in practice, though most containers admit a key for dereferencing values
11:54:32 <edwardk_> otherwise they are kinda boring ;)
11:54:34 <acowley> Eduard_Munteanu: my container is an urn like lotteries use to mix ping pong balls
11:55:28 <edwardk_> acowley: a bag is a good example of a container it is hard to key into, but it is also not an polynomial (or exponential) functor
11:55:46 <jmcarthur> roconnor: i can see set, dubut i'm still struggling to see Cont
11:55:48 <jmcarthur> *but
11:55:53 <acowley> is that so limiting though?
11:55:58 <acowley> membership tests are useful things
11:56:11 <edwardk_> acowley: i said 'most of them' and 'tend to' i didn't prescribe the existence of bag.
11:56:28 <acowley> fair enough
11:56:43 <acowley> I'm still putting in my notebook that edwardk is a bag denier :P
11:56:56 <roconnor> [Saturday 12 February 2011] [18:39:42] <rwbarton>       so you can take Cont { \f -> f (const F
11:56:58 <roconnor> alse) + f (const True) } and Cont { \f -> f id + f not }
11:57:06 <edwardk_> you may want to hide any reference to the blog posts where i talk about species then ;)
11:57:10 * Eduard_Munteanu defines the infinitely deep bag as a hungry function
11:57:23 <roconnor> jmcarthur: rwbarton's example ^^
11:58:13 <edwardk_> acowley: anyways, once you get over the violent reaction, take a look through there, there are a number of combinators that don't exist elsewhere that turn out to be useful across a wide-array of (but not all!) containers =P
11:58:15 <c_wraith> :t fix const
11:58:15 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
11:58:16 <lambdabot>     Probable cause: `const' is applied to too few arguments
11:58:16 <lambdabot>     In the first argument of `fix', namely `const'
11:58:25 <roconnor> (f g = if g False && g True then 1 else 0)  this continuation distinguishes them.
11:58:30 <edwardk_> you can't fix const, its not broken.
11:58:34 <monochrom> > fix (const 'x')
11:58:35 <lambdabot>   'x'
11:58:37 <acowley> edwardk_: they do look very sensible
11:59:10 * hackagebot graph-wrapper 0.2.3 - A wrapper around the standard Data.Graph with a less awkward interface  http://hackage.haskell.org/package/graph-wrapper-0.2.3 (MaxBolingbroke)
11:59:16 <Eduard_Munteanu> > fix unsafePerformIO
11:59:17 <lambdabot>   Not in scope: `unsafePerformIO'
11:59:19 <Peaker> Are Type Synonym instances just a sugary way to define instances for the types we have synonyms to?
11:59:42 <Eduard_Munteanu> Well, yeah.
11:59:55 <dmwit> Well, Data.Key looks pretty nice.
11:59:57 <Eduard_Munteanu> I sometimes wonder why it ain't standard already.
11:59:58 <edwardk_> acowley: given tabulate from http://hackage.haskell.org/packages/archive/representable-functors/0.3.0.1/doc/html/Data-Functor-Representable.html and index from Indexable, turns out you can define a lot of classes
12:00:17 <Eduard_Munteanu> Though sometimes it's better to just have a newtype.
12:00:22 <dmwit> Any reason there's no instance of Key for plain old Map?
12:00:27 <dmwit> Oh, never mind.
12:00:29 <dmwit> I'm just blind.
12:00:32 <edwardk_> dmwit: there is
12:00:42 <edwardk_> dmwit: there is even an Apply instance for it
12:00:51 <edwardk_> (and Bind)
12:01:08 <edwardk_> so you can do almost-monadic things with them
12:01:11 <acowley> edwardk_: You're giving me too much to think about
12:01:26 <edwardk_> acowley: i try
12:01:27 <acowley> btw, Gibbons uses the term "metamorphism" to describe unfold . fold
12:01:30 <acowley> is that standard?
12:01:39 <edwardk_> acowley: he coined it
12:01:51 <edwardk_> there are competing notions of metamorphism
12:01:51 <Eduard_Munteanu> I'm pretty sure I've seen "metamorphism" around.
12:02:18 <Eduard_Munteanu> fold . unfold would be a hylo, to contrast.
12:02:21 <edwardk_> personally, i'm with uustalu and largely want the meertens-inspired penchant for greek/latin recursion scheme names to die
12:02:22 <acowley> well I have a very useful function which I named metamorph that I will have to write about over the next couple days, and I'm a little uneasy about the name
12:02:38 <edwardk_> acowley: i probably wouldn't use that name
12:03:07 <acowley> edwardk_: well it is what Gibbons calls a metamorphism, which is why i called it that
12:03:14 <edwardk_> ah
12:03:16 <acowley> edwardk_: but metamorphisis is such a generic word
12:03:19 <quotemstr> Because of the monad laws, each do-block is over only one monad at a time, right?
12:03:21 <edwardk_> yep
12:03:22 <monochrom> I use "function" to describe unfold.fold. every function can be rewritten that way.
12:04:03 <quotemstr> So how does the compiler know *which* Monad to use?
12:04:05 <acowley> monochrom: The key feature is that it is productive
12:04:10 <edwardk_> monochrom: though you may need some extra abuses of unfold/fold inside it and there is no guarantee you won't need to fmap over the base functor
12:04:21 <acowley> monochrom: before the fold completes
12:04:27 <Eduard_Munteanu> quotemstr: any particular situation? It's just type inference.
12:04:49 <edwardk_> quotemstr: eventually you use it in a context that involves runFoo or some such that causes unification to pick the right monad
12:05:02 <monochrom> I may even call it Backhouse normal form.
12:05:15 <quotemstr> Ah, okay. I see how it works now.
12:05:36 <monochrom> there is a series of work under the name "reductivity" by Backhouse and Henk Doornbos.
12:05:38 <quotemstr> The compiler knows that, say, putStr always returns an IO, so if you start a do-block with that, it can follow it all the way through.
12:05:41 <Peaker> How frequent is the usefulness of "family"? I don't see why to allow both:  class C c where type A c      and  type family A c.. is there a good reason to have another keyword and syntax for something that seems to be equivalent?
12:05:56 <Eduard_Munteanu> quotemstr: yeah
12:06:02 <kmc> quotemstr, yep, it's type inference as usual
12:06:15 <edwardk_> peaker; i use families quite a bit. they are useful when you don't want to incur a typeclass constraint as well. which is a second name you have to know
12:06:21 <quotemstr> Oh ---
12:06:38 <Peaker> edwardk_, ah, so instead of:  C c => A c  you can just use A c ?
12:06:41 <kmc> quotemstr, just the implications of type inference on the operator (>>=).  there's no special rule about 'do' or monads
12:06:46 <edwardk_> peaker: i find them to be quite useful when i'm just defining some simpler normalizer
12:07:09 <kmc> you can write a 'do'-block that *isn't* for a specific monad; that's how much of Control.Monad is written
12:07:13 <quotemstr> The laws say that >>= is (M p) >>= (f -> M q), but p and q don't need to have the same type, right?
12:07:18 <Peaker> edwardk_, I see, thanks. Sounds like a good enough reason indeed
12:07:19 <kmc> right, but M is M
12:07:23 <kmc> :t (>>=)
12:07:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:07:26 <edwardk_> type family x :+ y :: *; type instance S n :+ m = S (n :+ m); type instance Z :+ m = m
12:07:26 <quotemstr> I think I'm beginning to understand this. :-)
12:07:26 <hpc> you can also write a do block that isn't for any monad
12:07:29 <hpc> :t do 'a'
12:07:31 <lambdabot> Char
12:07:31 <edwardk_> no need to make up a class Add, etc.
12:07:33 <Eduard_Munteanu> quotemstr: think the compiler goes through everything you write, and picks up every function you use. Normally it tries to get the most general type, but when it sees putStrLn, it knows that's a constraint to use IO.
12:07:45 <hpc> a one-liner do block desugars to just that line
12:07:48 <kmc> :t \f a b -> do { x <- a; y <-b; return (f a b) }
12:07:48 <lambdabot> forall (m :: * -> *) t b t1. (Monad m) => (m t -> m t1 -> b) -> m t -> m t1 -> m b
12:07:54 <kmc> quotemstr, ^^^ there's a polymorphic do-block
12:07:57 <quotemstr> So in a single do-block for, e.g., IO, the state carried through the monad can change type from line to line.
12:08:01 <quotemstr> Ah.
12:08:04 <kmc> err a more useful one:
12:08:07 <kmc> :t \f a b -> do { x <- a; y <-b; return (f x y) }
12:08:08 <lambdabot> forall (m :: * -> *) t b t1. (Monad m) => (t -> t1 -> b) -> m t -> m t1 -> m b
12:08:15 <kmc> that's implementing liftM2
12:08:29 <Peaker> quotemstr, it's not typically considered to be "state carried".. it's just intermediate results and yeah, those can vary their types
12:08:30 <byorgey> quotemstr: well, "state" is an unfortunate choice of term, but yes, the "wrapped" type can change from line to line
12:08:30 <kmc> since we only use "return" and (>>=) (implicitly), the type is generic over all monads
12:09:41 <edwardk_> quotemstr: each line of the do block can incur additional constraints on the type. if you just use >>= and return you just incur the obligation to be a monad, if you use putStrLn, then it incurs the obligation that your monad is IO, but lift $ putStrLn "..." incurs the obligation that your monad is an instance of MonadIO, etc.
12:09:43 <roconnor> @free return
12:09:46 <lambdabot> Expected variable or '.'
12:10:13 <Peaker> quotemstr, some monads do carry state from one bound action to the next.. For example, the "State s" monad, defined as:   State s a = s -> (s, a).  Since  m = State s, and the "m" is always the same, the state ("s") carried between the "lines" is the same type. But the intermediate results ("a") can change
12:10:18 <byorgey> roconnor: @free seems broken
12:10:35 <Eduard_Munteanu> @free (Monad m) => a -> m a
12:10:35 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
12:10:35 <roconnor> byorgey: it just doesn't work on polymorphic functors
12:10:44 <roconnor> @free return :: a -> M a
12:10:44 <lambdabot> $map_M f . return = return . f
12:10:48 <byorgey> ah
12:10:59 <roconnor> which is kinda annoying
12:11:11 <edwardk_> that free theorem is why Pointed no longer requires a Functor superclass
12:11:20 <Eduard_Munteanu> Oh.
12:11:28 <hpc> @src Pointed
12:11:28 <lambdabot> Source not found. Where did you learn to type?
12:11:32 <hpc> @hoogle pointed
12:11:32 <lambdabot> No results found
12:11:38 <edwardk_> since any instance of Pointed that is also a Functor will, by free theorem, satisfy that, the only law you can state about it
12:11:51 <Eduard_Munteanu> edwardk_ has a Copointed and perhaps Pointed in his category-extras stuff, IIRC
12:11:52 <kmc> quotemstr, since "do" is just sugar, you really can understand all the typing implications by applying the rule for ordinary function application to the operator (>>=)
12:12:04 <edwardk_> Eduard_Munteanu: they've been factored into the pointed package
12:12:14 <Eduard_Munteanu> But you should probably look in Typeclassopedia for it.
12:12:17 <roconnor> edwardk_: I'm not entirely sure that reasoning justifies removing the superclass constraint
12:12:17 <kmc> which is an ordinary user-defined operator whose type you can query with :t
12:12:21 <Eduard_Munteanu> Ah.
12:12:48 <roconnor> edwardk_: what you have done is made typing contexts for Pointed a big pain for everyone.
12:12:56 <kmc> this is a *lot* nicer than mucking up the type system with special rules for IO and for state and for parsers and...
12:13:00 <edwardk_> roconnor: i didn't want to have them at all, but enough people bitched about wanting them that i put them in somewhere
12:13:10 <roconnor> edwardk_: since now we always have to include Functor separately
12:13:11 <hpc> what is the current source of Pointed?
12:13:23 <roconnor> heh
12:13:31 <roconnor> I'm with you on not having a pointed class
12:13:45 <Eduard_Munteanu> Maybe alternate preludes?
12:13:48 <edwardk_> i have yet to find a solid usecase for Pointed that can't be solved by changing your perspective and making something else into a semigroup/apply/bind, etc.
12:14:02 <Eduard_Munteanu> Maybe edwardk_ should work on an alternate prelude as well :)
12:14:10 <edwardk_> hpc: the pointed package on hackage
12:14:15 <roconnor> I think we should all go write our own haskell reports
12:14:16 <edwardk_> they are in Data.Pointed
12:14:28 <hpc> edwardk_: it says the package is obsolete
12:14:32 <roconnor> 'cause I'm an anarchist :)
12:14:41 <hpc> oh, nvm
12:14:42 <hpc> i suck
12:14:45 <edwardk_> Eduard_Munteanu: been there done that, got the t-shirt, hated it. i have enough trouble drumming up users without making my code deliberately incompatible with the rest of the world
12:14:45 <Eduard_Munteanu> Heh.
12:14:56 <Peaker> I wish someone implemented the class aliases extension
12:15:09 <edwardk_> http://hackage.haskell.org/package/pointed
12:15:09 <Peaker> so we can see if we can backwards compatibly repair the mess in the Prelude.  The Num class sucks
12:15:15 <kmc> isn't there a preprocessor at least Peaker?
12:15:21 <Peaker> kmc, I am not sure
12:15:47 <Eduard_Munteanu> I'd just be happy with moving all list stuff from Prelude into typeclasses.
12:15:50 <edwardk_> peaker: i don't think the prelude canbe fixed without some sort of white box inheritance mechanism enabling you to partially define superclass methods.
12:16:11 <edwardk_> when that happens i'll tune back in to the efforts to fix the prelude with greater seriousness
12:17:17 <edwardk_> Eduard_Munteanu: i'm dubious of that, the asymptotics of the implementation of them vary so much from implementation to implementation that the classes may cause more pain than they alleviate.
12:17:28 <MHD0> what the dick man, my code is completely broken.
12:18:11 <Eduard_Munteanu> edwardk_: oh it's not that, but Prelude is polluting the namespace too much because it's not using typeclasses like the rest of the world :)
12:18:29 <edwardk_> Eduard_Munteanu: there is that, the trick is that most of those classes you'd want aren't 98. =/
12:18:39 <Eduard_Munteanu> Hm, yeah.
12:19:06 <Eduard_Munteanu> So we need to wait for the next important H' first, I guess.
12:19:08 <roconnor> Eduard_Munteanu: funny, the prelude was designed with such polution in mind.
12:19:12 <byorgey> is there a standard typeclass somewhere defined like  Foo f <=> forall a. Monoid (f a) ?
12:19:23 * roconnor yearns for Haskell 1.4
12:19:25 <Eduard_Munteanu> It's a big pain when working with Bytestrings and such.
12:19:43 <hpaste> MHD0 pasted "broken types"  http://hpaste.org/44627
12:19:59 <edwardk_> e.g. even polymorphic cons needs an MPTC in order to allow bytestring consing
12:19:59 <MHD0> Can anyone tell me why it breaks?
12:19:59 <kmc> byorgey, higher-rank type constraints are a pain :/
12:20:06 <byorgey> tell me about it =(
12:20:08 <edwardk_> and that causes other problems with dictionary construction when used polymorphically
12:20:11 <hpc> prelude badly needs an upgrade
12:20:15 <kmc> MHD0, can *you* tell us what the error message is?
12:20:48 <MHD0> It says that it expects GLint but gest GLsizei in Position constructor
12:20:48 <edwardk_> byorgey: the closest i have is Plus in semigroupoids
12:20:57 <byorgey> MHD0: you are calling fromIntegral on wa, but wa is definitely not an Integral type, since it is defined as  16.0 * as
12:20:58 <kmc> well
12:21:03 <kmc> xr and yr are GLsizei
12:21:09 <kmc> your own signatures say so
12:21:12 <kmc> what's the type of Position?
12:21:21 <edwardk_> byorgey: http://hackage.haskell.org/packages/archive/semigroupoids/1.1.2/doc/html/Data-Functor-Plus.html
12:21:28 <edwardk_> it gives you <!> and zero
12:21:36 <MHD0> kmc: yeah but haskell says they arent
12:21:49 <kmc> confused
12:21:56 <byorgey> edwardk_: ah, yes, that's exactly what I want, thanks =)
12:22:04 <byorgey> I knew it rang a bell
12:22:04 <kmc> you said the type error is that Position expects GLint but gets GLsizei
12:22:11 <kmc> that would imply that xr and yr are indeed GLsizei
12:22:31 <MHD0> nvm
12:22:32 <MHD0> fuck it found it
12:22:38 <MHD0> <-- Stupid
12:22:39 <kmc> i guess we had it backwards
12:22:52 <Eduard_Munteanu> edwardk_: any luck with Yoneda on semigroupoids? /me doesn't know much, but I'm curious how far you can get with them
12:23:24 <edwardk_> Eduard_Munteanu: the yoneda lemma holds exactly when a semigroupoid is a category
12:23:31 <rwbarton> yoneda for semigroupoids sounds false, yeah
12:23:37 <rwbarton> given how you prove yoneda
12:23:57 <edwardk_> rwbarton: yep
12:24:17 <MHD0> kmc: so did i
12:25:25 * Eduard_Munteanu still finds monoidoid to be a funny name for a category.
12:25:51 <hpc> CoCont?
12:25:53 <edwardk_> =)
12:25:56 <hpc> CoConut!
12:26:00 <Eduard_Munteanu> Cocones FTW :P
12:26:05 <edwardk_> hpc: CoCont = Cont
12:26:12 <hpc> edwardk_: wha?
12:26:25 <kmc> cocoa coated cocones
12:26:40 <hpc> @unmtl Cont a b
12:26:40 <lambdabot> (b -> a) -> a
12:26:45 <Eduard_Munteanu> Hairy cocones.
12:26:51 <roconnor> hpc: the dual of Cont is Cont
12:26:52 <hpc> how is CoCont == Cont?
12:26:57 <edwardk_> if you take the the cont monad apart into the adjunction between (-> r) -| (-> r)  then if you compose it one way you get (a -> r) -> r and if you compose it the other you get (a -> r) -> r
12:27:10 <hpc> oh
12:27:22 <hpc> i understand maybe 1/4 of that
12:27:47 <edwardk_> because it is an adjunction between hask^op and hask so it gives a monad in hask, and a comonad in hask^op.... which is a monad in hask
12:27:48 <hpc> actually, everything but adjunction and (-|)
12:28:00 <acowley> edwardk_: semigroupoids looks awesome and I've never used it!
12:28:03 <roconnor> hpc: the trick is that (->) is contravarient.  So that the dual of the Cont monad is a comonad in the Hask^op, which is isomorphic to a monad in Hask.
12:28:06 <edwardk_> -| is a way to say 'adjunction'
12:28:09 <edwardk_> acowley: thanks =)
12:28:30 <byorgey> acowley: sometime we should sit down and I will pass on edwardk_'s wisdom
12:28:42 <roconnor> damn too slow
12:28:46 <byorgey> acowley: a few weeks ago I spent a couple hours on the phone with him absorbing knowledge
12:29:02 <acowley> byorgey: !
12:29:06 <edwardk_> f -| g : C -> D is a way to say that f a ~> b  is isomorphic to a ~> g b  where the former arrow is in C, and the latter arrow is in D
12:29:14 <byorgey> edwardk_: any particular reason Set is not a Plus ?
12:29:25 <edwardk_> byorgey: apathy? =)
12:29:31 <edwardk_> also its not a Functor
12:29:42 <edwardk_> Plus depends on Alt which depends on Functor, atm.
12:29:43 <Eduard_Munteanu> edwardk should definitely write some online material on category-extras
12:29:47 <edwardk_> so its not exactly what you wanted
12:30:01 <byorgey> edwardk_: ah. phooey.
12:30:06 <djahandarie> Eduard_Munteanu, no need if it slowly dies!
12:30:17 <acowley> The troubles with Set are so frustrating
12:30:24 <djahandarie> edwardk_, you should make a new category-extras which just exports all the other modules
12:30:29 <acowley> there must be a smart-ish solution
12:30:34 <djahandarie> Because otherwise it's kind of hard to find stuff
12:30:40 <edwardk_> djahandarie: working up to it. there aren't many bits and pieces of it left
12:30:44 <byorgey> acowley: there is, constraint families!
12:30:50 <byorgey> too bad no one has implemented it yet
12:30:55 <Eduard_Munteanu> Yeah, it's been blown to bits.
12:31:10 <acowley> byorgey: ah, well it's good to know there's hope
12:31:47 <byorgey> acowley: http://www.cs.kuleuven.be/%7Etoms/Research/papers/constraint_families.pdf  <-- a very nice paper
12:33:08 <edwardk> http://www.reddit.com/r/haskell/comments/fvabx/greenfield_haskell/c1j0kju is probably the most comprehensive list of what i've split it out to (lost connection, don't think link went through before i did)
12:43:58 <quuuux> hi #haskell, I have a dilemma: http://pastebin.com/1QnpF3a8
12:44:45 <quuuux> in short, I have to decide between explicit fragile enumerations & ugly pattern matching, and partial functions with errors being caught at runtime rather than compiletime
12:45:45 * edwardk returns to dead silence
12:45:54 <aristid> @pl \f -> Kleisli (return f)
12:45:54 <lambdabot> Kleisli . return
12:46:11 <aristid> @pl \f -> Kleisli (return . f)
12:46:11 <lambdabot> Kleisli . (return .)
12:46:28 <aristid> :t Kleisli . (return .)
12:46:29 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b) -> Kleisli m a b
12:46:29 <edwardk> quux: one option would be to build a huge GADT
12:47:02 <quuuux> edwardk: that's essentially alterntative 2 in the pastebin, unless I'm misunderstanding
12:47:08 <kmc> "Enum and Bounded can't be auto-derived"  for Letter, you mean?
12:47:19 <quuuux> kmc: yep
12:47:32 <kmc> quuuux, with the GADT you'd have (B :: Letter TagLabial)
12:47:40 <edwardk> quux not quite you have a bunch of _ADT_s, you could make one GADT, then be more specific
12:47:58 <kmc> for some type TagLabial (can be an empty type, doesn't matter)
12:48:09 <kmc> but then you can also use it at type "Letter t"
12:48:13 <kmc> or build a list of [exists t. Letter t]
12:48:23 <kmc> (with appropriate wrapping types, assuming you're using GHC)
12:48:29 <edwardk> data Letter a cv where B : Letter Labial Consonant
12:48:55 <roconnor> quuuux: why do you just add deriving Bounded to Letter?
12:49:04 <roconnor> (and Enum)
12:49:08 <quuuux> roconnor: because it doesn't work
12:49:12 <Peaker> edwardk, you've been using too much Agda?
12:49:18 <edwardk> roconnor: presumably so he can enumerate all of the labial consonants, etc.
12:49:27 <edwardk> peaker: the single colon?
12:49:31 <Peaker> edwardk, yeah :)
12:49:40 <kmc> you can only derive Bounded and Enum for types with only nullary constructors
12:49:50 <Philonous> Is there anything interesting one can do with fixIO? It seems to me that it is basically the same as returning a function (a->a) and applying fix to it.
12:49:51 <edwardk> peaker: heh, most of my haskell-alikes have had single : types, sometimes i slip ;)
12:49:54 <roconnor> kmc: really?
12:50:14 <kmc> yeah :/
12:50:46 <edwardk> fixIO is a special case of mfix?
12:50:50 <dmwit> quuuux: If you don't grok GADTs, you can do this with plain old phantom types in H98 as well (which are basically a poor-man's GADTs).
12:51:00 <Philonous> edwardk: Yes, fixIO is mfox for IO
12:51:04 <Philonous> mfix even
12:51:05 <byorgey> Philonous: but with EFFECTS!
12:51:23 <quuuux> hmm. I'll try something like that, thanks
12:51:23 <edwardk> dmwit but they he has to deal with the patterns he doesn't want to have to try to match
12:51:24 <opqdonut> :(
12:51:25 <kmc> dmwit, but i think groking GADTs is recommended here
12:51:33 <opqdonut> oops, that wasn't meant here
12:52:37 <dmwit> edwardk: With some smart constructors, I would think you could guarantee that you don't have to do that. But yes, it's preferable to get the compiler to tell you that kind of thing by using GADTs.
12:52:53 <dmwit> I was more suggesting that the phantom types would be a stepping stone to understanding what GADTs are all about.
12:54:33 <edwardk> in practice you could probably get away with two or three index types, e.g. to categorize consonants into  Bilibial | LabioDental | Dental | Alveolar | PostAlveolar | Retroflex | etc...   and Plosive | Nasal | Trill | TapFlap | Fricative | LateralFricative | Approximant | LateralApproximant | ... or non pulmonic, then vowels into close/open and front/central/back
12:55:19 <quuuux> edwardk: the actual code has nothing to do with phonetics, but it's quite parochial and this was a simpler example :)
12:55:32 <edwardk> so with that you can probably use a three argument gadt
12:55:36 <edwardk> fair enough =)
12:56:25 <jmcarthur> somebody remind me. why would something like 'import Foo (instance Foo Bar, instance Foo Baz)' be so against the "type class way"? because right now such an import line looks really favorable to me
12:56:30 <dmwit> parochial, nice word
12:56:52 <edwardk> i was rather looking forward to having a type for Pharyngeal Fricatives
12:57:01 <dmwit> jmcarthur: You've got to be careful that different modules use the same instances; e.g. consider looking something up in a Set using a different Ord instance than the Set was created with.
12:57:17 <quuuux> edwardk: a sound change applier in Haskell is actually on my to-do list, so it may well come to be!
12:57:30 <acowley> Can anyone recommend a haddock type thing for C?
12:57:36 <jmcarthur> dmwit: but the compiler can check that, can't it?
12:57:36 <kmc> doxygen
12:57:43 <edwardk> quuux: =)
12:57:50 <acowley> ah, right!
12:58:06 <dmwit> jmcarthur: Sounds rather like a halting-problem-esque question to me.
12:58:11 <dmwit> jmcarthur: Don't forget about closures and such.
12:58:13 <edwardk> i look forward to type checking the great vowel shift
12:58:17 <dmwit> (Which can be passed between modules.)
12:58:29 <acowley> Oh goodness I hate enterprisey tools
12:58:57 <acowley> Maybe I'll just use coqdoc
12:59:15 <kmc> coqbloq
12:59:28 <byorgey> coqdoc for C??
12:59:46 <byorgey> coqdoc is definitely the opposite of enterprisey though
12:59:50 <edwardk> kmc: that would have been a much better name for the program extension
12:59:56 <acowley> byorgey: When the new HoareWithRefs is done we'll be that much closer! ;)
13:00:06 <byorgey> acowley: haha, indeed!
13:00:22 <acowley> I actually wouldn't be *that* surprised if I got an email asking for C support in coqdoc
13:00:41 <djahandarie> Hoares and Coqs...
13:00:44 <byorgey> not only will it format your documentation, it will generate Hoare logic annotations for your code =)
13:01:11 <acowley> djahandarie: don't get me started, I almost chose a *really* unfortunate module name recently
13:01:25 <jmcarthur> dmwit: maybe this would be a case where type class constraints on data definitions would be appropriate? then it would make some sense for the instance used when it was constructed to be carried around with the structure, i think? i guess then we would also need some way to talk about that instance separately from others in scope, which might start looking like a dependently typed thing...
13:01:32 <acowley> byorgey: I want Hoare annotations for my documentation that describes my thought process
13:01:34 <kmc> acowley, worse than StrictAnal?
13:01:43 <djahandarie> Haha what the hell
13:01:48 <acowley> and thanks to France, #haskell goes blue
13:02:41 * hackagebot atom 1.0.9 - A DSL for embedded hard realtime applications.  http://hackage.haskell.org/package/atom-1.0.9 (LeePike)
13:02:53 <jmcarthur> which i guess just starts looking like agda-style implicit parameters and stuff
13:02:54 <monochrom> Hilbert's Brothel
13:04:07 <monochrom> also http://spikedmath.com/392.html
13:05:47 <quuuux> edwardk: immediate problem with the GADT-based approach: I still can't derive Enum and Bounded
13:06:32 <kmc> yeah, toEnum would be dependently typed :)
13:07:00 <Peaker> jmcarthur, I think that if you consider instances to be *inherent* relationships between the types and classes, and not separate entities, the current way they work makes more sense
13:07:02 <edwardk> quuuux: the price is that you need to implement all that by hand =/
13:07:20 <Peaker> jmcarthur, if there are multiple possible instances -- multiple newtypes make sense under that view
13:08:02 <quuuux> edwardk: yeah. Thing is, then, GADTs are only winning over alternative #2 by having marginally nicer pattern-matching
13:08:06 <Peaker> Enum is a horrible class
13:08:09 <Peaker> @src Enum
13:08:13 <lambdabot> class  Enum a   where
13:08:17 <lambdabot>     succ                     :: a -> a
13:08:18 <quuuux> Peaker: horrible, but very convenient
13:08:19 <lambdabot>     pred                     :: a -> a
13:08:23 <lambdabot>     toEnum                   :: Int -> a
13:08:25 <lambdabot> Plugin `source' failed with: thread killed
13:08:56 <edwardk> quuuux: yeah, for me that is a win, because i prefer to have total functions throughout and not to write spurious matches for 'just in case' paranoia, but feel free to do what makes sense for your usecase
13:09:34 <Eduard_Munteanu> You could generate that code somehow, if you're concerned.
13:09:42 <ion> In what way is Enum horrible?
13:09:58 <jmcarthur> Peaker: yes, i agree. it's just that i often want to use type classes for things that just don't quite fit the former view. i mean... there's nothing about the real numbers that makes them more like an additive group than a multiplicative group, and yet i have to pick one or the other for the real number type
13:09:58 <Peaker> Why did they force all Enums to be mapped to Ints? :-(
13:10:02 <quuuux> edwardk: it's all still total. The only difference is that it's BoxedLetter A and BoxedLetter B instead of Vowel A and LabialConsonant B being matched
13:10:04 <Olathe> ion: toEnum and fromEnum are horrible.
13:10:29 <monochrom> jmcarthur: perhaps use dictionary-passing by hand in the interim
13:10:30 <Peaker> jmcarthur, then don't pick :-) Make two newtypes (e.g: Sum and Product)
13:10:34 <roconnor> the real numbers do not from a group under multiplication
13:10:38 <jmcarthur> Peaker: and then i have to make a new type to get the other even though there is nothing fundamentally different
13:10:53 <jmcarthur> roconnor: i'm mixing things up then. you're right
13:11:06 <jmcarthur> okay monoid then
13:11:06 <roconnor> jmcarthur: please continue with monoid :)
13:11:08 <edwardk> quuuux: or instead of A and B
13:11:11 <Peaker> jmcarthur, If there are multiple valid instances, just refuse to choose and make them all newtypes
13:11:29 <quuuux> edwardk: oh, in that case it -is- partial, yes :) That's the current approach but the partial functions annoy me
13:11:44 <Peaker> "In the face of ambiguity refuse the temptation to guess"
13:11:49 <jmcarthur> Peaker: that's my basic policy, yes
13:11:50 <edwardk> yeah
13:12:03 <acowley> Does anyone else sometimes get a little angry about 0 and division?
13:12:08 <Peaker> jmcarthur, I don't see why that's so bad
13:12:11 <jmcarthur> Peaker: but that policy requires some demonstration that the only instance you can think of is the only one possible :\
13:12:14 <acowley> I periodically just shake my fist, then get back to things
13:12:18 <monochrom> Naw. In the face of ambiguity, exploit the window to guess the unlikely
13:12:23 <edwardk> acowley: yeah what the hell is with this 0 thing and why is it mucking up my totality!
13:12:28 <Peaker> jmcarthur, it may also be the only one practical, sensible, or such
13:12:43 <jmcarthur> Peaker: also, i still don't like that i need two distinct types just to apply different operations to the same data
13:12:43 <ion> It makes sense to me to generalize e.g. ord and chr as fromEnum and toEnum for Char. Doesnât make as much sense to have fromEnum and toEnum for e.g. Float.
13:12:47 <acowley> edwardk: exactly! The salt in the wound is how great 0 is in most contexts
13:12:53 <Peaker> The romans knew what they were talking about when banning zero!
13:12:56 <edwardk> acowley: 0 and / isn't so bad, its the NaN's that make the blood boil ;)
13:13:00 <acowley> edwardk: The real numbers are jerks
13:13:30 <edwardk> destroying perfectly good equivalence relations for the rest of us, making pointer equality not imply equality in general, etc.
13:13:39 <monochrom> example. <need-math-help> hi I need help solving equations <monochrom> Matiyevich proved it unsolvable in general
13:13:41 <acowley> Peaker: Probably, but I don't envy them their number system when it comes to doing arithmetic
13:13:55 <Peaker> jmcarthur, I don't think that's a problem.. I agree that newtype adds inconveniences though
13:14:11 <Peaker> monochrom, heh
13:14:28 <acowley> edwardk: but Num+NaN is algebraically tidy!
13:15:24 <monochrom> in fact the Greeks knew what they were doing when banning one, too.
13:15:28 <edwardk> acowley: *twitch*
13:15:35 <acowley> hahaha
13:15:40 <edwardk> monochrom: yeah they didn't think up zero for a reason!
13:15:45 <hpc> monochrom: and pythagoras for banning irrationals
13:15:53 <acowley> It's hardware support for Maybe!
13:16:10 <monochrom> there was a tribe who banned all integers greater than 2.
13:16:13 <edwardk> acowley: *cry*
13:16:16 <jmcarthur> at least with Maybe, Nothing == Nothing
13:16:32 <hpc> monochrom: that settles it! 2 is the only number
13:16:39 * hpc proposes a spoof song
13:16:40 <acowley> jmcarthur: in the Roman interpretation monochrom advocates, that is vacuous
13:16:51 <hpc> "two is the onliest number that you'll ever dooooo"
13:16:51 <djahandarie> monochrom, just need to work in base-3 then
13:16:51 <acowley> wait
13:16:54 <acowley> now I've confused myself
13:17:21 <kmc> proposal to make Nothing == Nothing and also Nothing /= Nothing in Haskell 2012
13:17:29 <djahandarie> > fmap (concat . show) . replicateM 5 $ [0..2]
13:17:30 <lambdabot>   Couldn't match expected type `[a]'
13:17:30 <lambdabot>         against inferred type `GHC.Types...
13:17:37 <djahandarie> > fmap (concat . fmap show) . replicateM 5 $ [0..2]
13:17:39 <lambdabot>   ["00000","00001","00002","00010","00011","00012","00020","00021","00022","0...
13:17:45 <monochrom> a descendent of the tribe went to parc or microsoft or apple, influencing modern gui to not have a "triple click" command, only "single click" and "double click". (I made this part up.)
13:17:47 <acowley> kmc: True
13:17:48 <edwardk> kmc: ick
13:18:03 <kuznero> Any news about when new Haskell platform will go out finally?
13:18:13 <edwardk> kmc: what part of equivalence relation is getting lost in the mix.
13:18:14 <Peaker> > fmap (concatMap show) . replicateM 5 $ [0..2]
13:18:16 <lambdabot>   ["00000","00001","00002","00010","00011","00012","00020","00021","00022","0...
13:18:17 <dolio> monochrom: My gui recognizes triple clicks sometimes.
13:18:26 <dixie> what are the haskell packages naming convetion? e.g. camelCase or some-thing... I can not find anything on haskell wiki :(
13:18:33 <dolio> It's usually, "highlight an entire line."
13:18:33 <Peaker> djahandarie, weird of you to use "fmap" in place of "map" but "concat" in place of "join" :)
13:18:40 <monochrom> indeed Backhouse's MathSPad has triple-click
13:18:44 <acowley> edwardk: reflexivity mostly?
13:18:47 <djahandarie> Peaker, I just don't use map :P
13:18:52 <edwardk> acowley: =)
13:18:56 <Peaker> djahandarie, interesting.. why do you use concat?
13:18:57 <wires> If one imports qualified Foo as X, can one also import a specific symbol Foo.bar non-qualified? (So you don't have write call X.bar all the time)
13:19:06 <quuuux> wires: two import statements
13:19:07 <Peaker> dixie, camelCase, mainly..
13:19:10 <djahandarie> Peaker, because I haven't decided not to yet
13:19:13 <kuznero> Gents, Haskell Platform 2011.02 ? :)
13:19:32 <monochrom> oh it gets better, if your expression is n-level deep, you can 1-click, 2-click, ..., n-click.
13:19:38 <edwardk> acowley: i'm still twitch that not (a <= b) and a > b are not the same thing
13:19:45 * djahandarie goes home
13:19:45 <quuuux> wires: ex.: import qualified Foo as X; import Foo (bar)
13:19:57 <wires> quuuux: w00t, thanks
13:20:00 <edwardk> er i still twitch that
13:20:06 <wires> quuuux: obvious in retrospect :\
13:20:19 <edwardk> destroys so many perfectly good type hacks
13:20:48 <acowley> edwardk: keep believing in a better world
13:21:00 <monochrom> if you 1-click on a leaf node of the expression, you select the leaf node. if you (k+1)-click there, you select the parent of what you select with k-click.
13:21:43 <edwardk> that reminds me i still need to contort the code in intervals to handle that distinction
13:22:36 <dolio> monochrom: Seems like it might be difficult to plan ahead enough at some level.
13:22:55 <edwardk> acowley: someone has to =)
13:23:02 <dolio> I might know about what I want to select, but may not be able to see that it's 8 levels easily.
13:23:14 <monochrom> ah, but you don't have to click on a leaf node to begin with. you can click on an operator, that selects the whole subtree.
13:23:24 <ddarius> dolio: As long as you underestimate, it's not a problem.
13:24:07 <Peaker> monochrom, probably best to have a different gesture for "climbing" the tree than to reclick same position
13:24:08 <dolio> ddarius: Depending on how fast you have to click, you might have to have pretty good reflexes.
13:24:23 <monochrom> also you can slow-motion it. press-hold, don't release yet; see whether the selection is large enough; if enough, release; if not enough, quickly release-press-hold, see again.
13:24:45 <Peaker> monochrom, I have a little tiny mockup of a C editor-prototype I wrote back in Python (before I discovered Haskell) -- and in it you can climb up/down the expression tree
13:25:05 <monochrom> ah, yes there is another gesture. the up-arrow key.
13:25:17 <Peaker> what UI is this, again?
13:25:30 <monochrom> Roland Backhouse's MathSPad.
13:25:32 <Peaker> What's MathSPad?
13:25:40 <monochrom> an obscure editor.
13:25:49 <fryguybob> > let p a b = not (a <= b) == (a > b) in p (-1/0) (0/0)
13:25:50 <lambdabot>   False
13:27:03 <kmc> dixie, naming packages?
13:27:13 <kmc> dixie, most packages have an all lower-case name
13:27:19 <kmc> see http://hackage.haskell.org/packages/archive/pkg-list.html
13:28:14 <dixie> kmc: thanks. I know the list of the packages.... but I was not sure if there is any preferred style of names
13:28:51 * hackagebot http-types 0.4.0 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.4.0 (AristidBreitkreuz)
13:30:26 <ddarius> dolio: We should make a game where you kill zombies by proving theorems.  Kind of like "Typing of the Dead."
13:30:47 <wires> lol
13:30:56 <shepheb> best typing tutor ever crafting by mankind
13:30:57 <dolio> Sounds good.
13:31:06 <Adamant> I'm comin' to get ya, I'm coming to get ya, spittin' out theorems, homie, I'm wit cha
13:31:17 <dolio> The program I used to learn to type wasn't nearly that interesting.
13:31:47 <Adamant> I never learned to type formally
13:31:57 <shepheb> it's kind of targeting a missing niche now, actually
13:32:19 <Adamant> not sure about that. lots of people can type, that isn't the same as typing well.
13:32:27 <shepheb> it's too scary for young kids, and by the time you're old enough, say 10, to blast zombies with keystrokes, these days you've already learned to type 60+ WPM on your own.
13:32:59 <shepheb> and probably 45 on your phone.
13:33:07 <Adamant> i taught myself how to type, but some formal instruction later in life really sped it up
13:33:41 <monochrom> kids these days learn typing by trolling facebook friends
13:34:37 <aristid> lolol monochrome
13:34:38 <jix> monochrom: can't you do that using only copy and paste?
13:34:50 <dolio> Well, technically I learned to type originally by playing MUDs.
13:34:53 <kmc> why even bother with a computer though
13:34:56 <kmc> you can troll from your phone
13:34:59 <dolio> But I was just free forming it.
13:35:24 <Adamant> kmc: people were trolling before computers were invented
13:35:33 <Adamant> see: the 60's
13:35:33 <shepheb> dolio: nothing better for working on your error rate. if you can panic-type MUD commands on the first try, you don't make many mistakes.
13:35:39 <quuuux> heh, I also learned to type on MUDs, and it shows
13:35:47 <kmc> get 'em young with the smartphone and they'll be obedient app store consumers for life
13:35:53 * hackagebot copilot 1.0.1 - A stream DSL for writing embedded C monitors.  http://hackage.haskell.org/package/copilot-1.0.1 (LeePike)
13:35:56 * Evious regularly typos 'ls' as 'l' due to many years of mudding.
13:36:00 <dolio> In high school I took a class that used some application that looked like it was DOS based or something.
13:36:03 <kmc> Evious, that's what 'alias' is for
13:36:04 <quuuux> one finger is always on the carriage return, just in case!
13:36:17 <shepheb> Evious: I had to alias ls to l on my MUD client and l to ls on my shell
13:36:20 <dolio> Where I learned the official method.
13:36:43 <Adamant> dolio: some classes still used typewriters to save money.
13:37:09 <kmc> typewriters are a good way to teach typing with zero mistakes
13:37:20 <Eduard_Munteanu> Adamant must be old.
13:37:21 <kmc> accuracy used to be a lot more important...
13:37:40 <Adamant> Eduard_Munteanu: not that old, mostly just a cheap school district
13:37:58 <Adamant> and kmc is right. newer isn't always better for everything.
13:38:03 <aristid> dolio: did you stick to the official method?
13:38:13 <kmc> Adamant, or you can just remove the "backspace" key
13:38:18 <dolio> aristid: Yes.
13:38:35 <Eduard_Munteanu> Accuracy doesn't matter anymore.
13:38:48 <dolio> aristid: Perhaps with slight variations. I don't think I ever use right shift.
13:38:51 <Adamant> kmc:  at the time, decent used typewriters were cheaper than even 8-bit bitty boxes
13:39:02 * ddarius recommends shooting the typist when they make a mistake.
13:39:10 <ddarius> Really encourages accuracy.
13:39:11 <shepheb> small electric shocks
13:39:17 <aristid> ddarius: never seen a typist making an error twice?
13:39:17 <Adamant> but not their deputy
13:39:22 <shepheb> all your graduates would have perfect accuracy
13:39:35 <Eduard_Munteanu> You can't kill him twice.
13:39:41 <Adamant> that's assuming you have any graduates
13:39:48 <ddarius> aristid: It depends on how quick they are at making errors and how quick I am with the trigger.
13:39:50 <dolio> You can if he's James Bond.
13:39:59 <quuuux> hmm. Data.Derive generates an incorrect Enum instance for my examples
13:40:11 <Eduard_Munteanu> Bruce Willis, even, in Die Hard.
13:40:43 <monochrom> Kenny can be n-killed.
13:41:31 <Eduard_Munteanu> Oh, right, Kenny should be better :)
13:42:10 <Eduard_Munteanu> fix (kill kenny)
13:42:25 <Adamant> bastards!
13:42:32 <Eduard_Munteanu> Heh.
13:43:00 <Eduard_Munteanu> Reminds me of the Kilkenny beer.
13:43:06 <monochrom> hahaha
13:43:41 <quuuux> there must be a way to get a list of all the elements of a finite sum of finite types without manually prodding around inside the structure :/
13:43:55 * hackagebot http-types 0.4.1 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.4.1 (AristidBreitkreuz)
13:53:11 <edwardk> shepheb: +1 on the fact panic typing on muds helps your speed. not so sure it helps accuracy if i'm any indication
13:54:00 <shepheb> edwardk: can be a harsh punishment for mistyping your rapidly-typed command, though
13:54:26 <shepheb> you have an incentive to be fast, but getting it right is faster than screwing it up and correcting it
13:54:29 <edwardk> shepheb: i think i spent too much time running them, and not enough time running around in them for that effect ;)
13:55:29 <ddarius> "harsh"
13:56:38 <edwardk> as for electric shocks you have to be careful, mice sometimes develop learned helplessness if you give them too many shocks, so you may wind up with grad students that just sat there
13:58:29 <ddarius> edwardk: What do grad students currently do?
13:58:53 <edwardk> ddarius: touche
13:59:49 <monochrom> they currently grade undergrad homework
14:03:30 <bos> @pl \k v -> ((k,toJSON v) :)
14:03:30 <lambdabot> ((:) .) . (. toJSON) . (,)
14:03:45 <ion> :)
14:11:30 <aristid> bos: not an improvement
14:11:41 <bos> aristid: indeed
14:11:55 <monochrom> oh wait, ghc 6.12.3 has grow-on-demand stack and so I can't really get a stack overflow, right?
14:11:56 <edwardk> fmap (:) . flip fmap toJSON . (,)
14:12:00 <edwardk> still ugly
14:12:26 <aristid> :t flip fmap toJSON
14:12:27 <lambdabot> Not in scope: `toJSON'
14:12:30 <edwardk> bos: second toJSON
14:12:57 <bos> edwardk: right
14:12:58 <aristid> :t (:) .: second undefined . (,)
14:12:59 <lambdabot>     Couldn't match expected type `(d, b)'
14:13:00 <lambdabot>            against inferred type `b1 -> (a, b1)'
14:13:00 <lambdabot>     Probable cause: `(,)' is applied to too few arguments
14:13:05 <aristid> :t (:) .: (second undefined . (,))
14:13:05 <lambdabot>     Couldn't match expected type `(d, b)'
14:13:06 <lambdabot>            against inferred type `b1 -> (a, b1)'
14:13:06 <lambdabot>     Probable cause: `(,)' is applied to too few arguments
14:13:20 <bos> edwardk: sort of
14:13:25 <aristid> :t (:) .: (second undefined .: (,))
14:13:26 <lambdabot> forall b c d. d -> b -> [(d, c)] -> [(d, c)]
14:13:28 <edwardk> at the : wasn't a smiley face
14:13:32 <edwardk> :)
14:13:39 <aristid> edwardk: lol
14:15:07 <edwardk> er bos: for most people i'd ask if uncurrying it was an option
14:16:05 <edwardk> then its (:) . second toJSON
14:16:20 <edwardk> but i suppose you could recurry that
14:17:18 <bos> edwardk: yeah
14:17:42 <aristid> :t (:) . second toJSON
14:17:43 <lambdabot> Not in scope: `toJSON'
14:18:18 <aristid> :t \f g -> curry (f . g .: uncurry)
14:18:19 <lambdabot>     Couldn't match expected type `(a, b)'
14:18:19 <lambdabot>            against inferred type `a1 -> b1 -> c'
14:18:19 <lambdabot>     In the second argument of `(.:)', namely `uncurry'
14:18:40 <edwardk> @type curry $ (:) . second ?toJSON
14:18:41 <lambdabot> forall a b c. (?toJSON::b -> c) => a -> b -> [(a, c)] -> [(a, c)]
14:18:43 <aristid> :t \f g -> curry (\x y (f . g) (uncurry x y))
14:18:44 <lambdabot> Parse error in pattern
14:18:50 <aristid> :t \f g -> curry (\x y -> (f . g) (uncurry x y))
14:18:51 <lambdabot>     Couldn't match expected type `a -> b -> c'
14:18:51 <lambdabot>            against inferred type `(a1, b1)'
14:18:52 <lambdabot>     In the first argument of `uncurry', namely `x'
14:18:58 <aristid> imma too stupid :(
14:20:31 <kmc> anyone mind if i ask an algorithms question?
14:20:36 <kmc> i promise to implement the algorithm in Haskell ;)
14:20:55 <ion> Nooooo, not an algorithm question!
14:21:21 <kmc> so i have a bunch of "bit patterns"
14:21:36 <kmc> each one is a vector where each element is 0, 1, or "don't care"
14:21:46 <edwardk> kmc: "this is #haskell not #data-structures" *cough* ;)
14:21:47 <kmc> and now i get a vector of bits and i want to find the set of matching patterns
14:22:00 <edwardk> *nods*
14:22:17 <edwardk> kmc: copumpkin was fiddling with just this problem the other week
14:22:27 <kmc> i can loop through the list of patterns, but is there a faster way?
14:22:31 <kmc> some kind of indexing structure?
14:22:50 <aristid> edwardk: want to know international category theory? i just learned that "fully faithful functors" are "volltreu" in german (i like the word, but don't know what these kind of functors are)
14:22:52 <c_wraith> this sounds like you could apply a regular expression
14:22:53 <edwardk> kmc: yes, but finding the minimal such set is not trivial
14:22:54 <kmc> for small vectors i'd just build a lookup table, and for big vectors a hash table
14:23:06 <ion> Each element is one of True, False or FileNotFound?
14:23:11 <kmc> yep :)
14:23:22 <c_wraith> I feel like you could merge all the patterns into one regular expression
14:23:29 <kmc> but i feel like there should be a clever way to pick individual bits to examine, in an order that narrows down the space quickly
14:23:30 <edwardk> aristid: they behave like bijections
14:23:43 <mzero> let m1 = (==1); m0 = (==0); mu = (const True); pattern = [m1, m1, mu, m0] in all $ zipWith ($) pattern [1,1,0,0]
14:23:44 <kmc> except i also suspect that's reducible from the optimal variable order problem for BDDs, which is NP-hard
14:23:51 <monochrom> eh?! it is ghci who has growable stack. compiled code still overflows stack.
14:23:56 <mzero> > let m1 = (==1); m0 = (==0); mu = (const True); pattern = [m1, m1, mu, m0] in all $ zipWith ($) pattern [1,1,0,0]
14:23:57 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
14:23:57 <lambdabot>         against inferred ...
14:24:41 <edwardk> kmc: in copumpkin's case we would up hunting for runs of consecutive bits we could use to partition the input into subsets, with a simple mask and select approach
14:24:57 <aristid> edwardk: so there is an associated function antifmap f y = x <=> fmap f x = y?
14:25:01 <edwardk> kmc: his problem is slightly different in that he cared about the first match in order from his set
14:25:04 <kmc> ok
14:25:22 <kmc> actually i can guarantee each input has at most one match
14:25:27 <kmc> the patterns don't overlap
14:25:59 <Eduard_Munteanu> How many patterns are there?
14:26:08 <ddarius> aristid: No, there's an antifmap (fmap f) = f
14:26:11 <kmc> my actual instance is not that bad
14:26:16 <kmc> <100 patterns, 16 bits each
14:26:17 <Eduard_Munteanu> You know, you could just check each of them until you stumble upon the right one ;)
14:26:24 <kmc> so a dumb lookup table is probably fine
14:26:53 <kmc> i know that there exists a small decoding circuit for these patterns
14:26:56 <aristid> :t \antifmap -> ((\f -> antifmap (fmap f)) :: a -> a)
14:26:57 <lambdabot>     Inferred type is less polymorphic than expected
14:26:57 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
14:26:57 <lambdabot>         antifmap :: (f a1 -> f b) -> a (bound at <interactive>:1:1)
14:27:03 <kmc> because they were designed to have that property ;)
14:27:13 <kmc> but i can't be arsed to figure it out by hand
14:28:15 <edwardk> aristid: you can view a functor as a function from c x y -> d (f x) (f y) -- when this is bijective, we know the target arrow is uniquely determined by the input arrow, and that every possible arrow is accounted for in the output, so yes, antifmap :: Functor f => (f a -> f b) -> a -> b -- would be a reasonable way to view it. full says that every arrow from (f a -> f b) is given rise to by an arrow of the form a -> b
14:29:45 <dolio> From what I hear, fully faithful has good generalizations to n-categories, but full and faithful alone don't.
14:30:32 <edwardk> clearly i should make a Volltreu class for them, since FullyFaithful is a pain to type ;)
14:30:52 <monochrom> hrm interesting, stack grows on demand, but there is still a default ceiling just to detect may-be-infinite-loop
14:31:11 <dolio> Yes.
14:31:24 <dolio> No way to turn it totally off, though, unlike the heap check.
14:31:53 <monochrom> ghci doesn't seem to have a ceiling. I wonder how high its ceiling is.
14:31:56 <dolio> I suppose increasing the stack limit to the size of your physical memory would work, though.
14:32:29 <mzero> monochrom: fix succ  ?
14:32:31 <dolio> Well, it's possible I'm wrong about being able to turn it off. But I've looked through the docs multiple times and never found it.
14:32:34 <edwardk> do you have a guarantee it won't get swapped out? if not perhaps virtual memory =)
14:34:54 <tolkad> Umm how is generic-deriving supposed to be used? http://hackage.haskell.org/package/generic-deriving
14:35:13 <tolkad> It has documentation for some specific data types and functions
14:35:22 <tolkad> but no overview of how you're supposed to use it
14:38:08 <monochrom> "+RTS -K1 -RTS" seems to set a very very high ceiling!
14:38:23 <monochrom> or generally a unitless number
14:40:18 <azaq23> tolkad: Likely one is supposed to read the referenced paper for an introduction.
14:40:25 <sshc> Are there any decent examples of using the monadic functions or properties of functions?
14:40:43 <kmc> what do you mean sshc?
14:40:55 <kmc> do you mean the "instance Monad ((->) r)"?
14:40:56 <azaq23> sshc: The Reader monad is just a newtype for the ((->) t) monad, for instance.
14:41:10 <kmc> > liftM2 (+) (2*) (3*) 5
14:41:11 <lambdabot>   25
14:41:18 <kmc> > (2*5) + (3*5)
14:41:19 <lambdabot>   25
14:41:25 <aristid> > (do a <- (+1); b <- (+2); return (a,b)) 4
14:41:26 <lambdabot>   (5,6)
14:41:36 <Eduard_Munteanu> tolkad: I'm not sure, but I could guess you need to write your datatype in terms of those primitives, or write an instance of that Representable thingy
14:42:07 <Eduard_Munteanu> So you write a single instance and get deriving for everything it provides support for.
14:42:09 <djahandarie> (do a <- 2; b <- 3; return (a, b)) 4
14:42:13 <djahandarie> > (do a <- 2; b <- 3; return (a, b)) 4
14:42:14 <lambdabot>   (2,3)
14:42:16 <Eduard_Munteanu> (Note I haven't used it before.)
14:44:14 <aristid> :t do a <- 2; b <- 3; return (a, b)
14:44:15 <lambdabot> forall (m :: * -> *) t t1. (Num (m t), Monad m, Num (m t1)) => m (t, t1)
14:44:23 <azaq23> > sequence [(+ 2), (* pi)] $ 10
14:44:24 <lambdabot>   [12.0,31.41592653589793]
14:44:58 <aristid> azaq23: that is indeed one of the coolest applications of Monad (e ->)
14:49:15 <monochrom> no, "+RTS -K100" really sets 100 as ceiling. -K10 doesn't set a ceiling.
14:51:37 <monochrom> -K63 is the largest number setting no ceiling.
14:56:20 <monochrom> heh, 63 is the threshold for ghc 6.12.3. 59 is the threshold for ghc 6.10.4
14:56:54 <aristid> 63 is much better, because 64 is a power of two
15:11:04 <lpsmith> So has anybody else tried playing with BTRFS?   Cabal seems to be rather slow on it... :-/
15:11:08 <dolio> monochrom: Ah, nice.
15:11:17 <dolio> I suppose I should have thought of that possibility.
15:11:31 <hai> what is a library situable for music analyses?
15:12:42 <lpsmith> hai, what kind of analysis do you want to do?  Is this sheet music,  wav files,  mp3s?   I suspect the library you want doesn't exist...
15:14:33 <acowley> I am kind of confused by edwardk's Apply class
15:15:21 <ddarius> acowley: Why?
15:16:43 <maurer_1> Anyone gotten HaLVM to build? I'm kind of struggling with it.
15:17:18 <acowley> ddarius: (I'm still trying to think of how to answer your question)
15:17:19 <hai> lpsmith, just wondering... i would like to rate a music (slow  ,sad, fast, happy...) looking at its rhytym
15:18:10 <lpsmith> hai, that's certainly an interesting idea,  unfortunately I don't know much about audio analysis
15:18:34 <acowley> ddarius: shoot, I need to ponder for a while. On a basic level, dropping pure is all fine and well, but I don't know what strong lax means and now I'm rather confused about how it supports ambient effects like applicative
15:19:03 <hai> but, i'm saying, there's a way to analyse an audio
15:19:53 <hai> lpsmith, i looked at haskore, but it seems only useful to create music
15:20:07 <lpsmith> hai,  yes.   For example,  if you apply a Fast Fourier Transform to an audio sample,  you can see the frequencies for example.
15:20:18 <acowley> hai: HCodecs then FFT and BPM estimation
15:22:06 <hai> acowley, please elaborate
15:22:31 <acowley> hai: I've never used HCodecs, but it seems to offer WAV reading (among others).
15:23:05 <acowley> hai: you can then do as lpsmith suggested and take an FFT and do a coarse histogram of dominant frequencies to track tone
15:23:20 <acowley> hai: and BMP is just looking at volume spikes
15:23:29 <acowley> hai: perhaps tuned to particular frequencies
15:23:40 <acowley> hai: BMP is much easier to estimate with drums
15:24:03 <Mathnerd314> "cabal: dependencies conflict: ghc-6.12.3 requires array ==0.3.0.2 however array-0.3.0.2 was excluded because ghc-6.12.3 requires array ==0.3.0.1"
15:24:39 <acowley> hai: and replace BMP with BPM in, apparently, everything I said
15:24:51 <monochrom> nuke array-0.3.0.2
15:25:13 <Mathnerd314> there's no cabal nuke :-/
15:25:35 <kmc> basic multilingual plane?
15:25:35 <kmc> ;)
15:25:53 <lpsmith> is there an easy way to re-generate the documentation provided in a binary ghc distribution?
15:25:56 <acowley> Ah yes, it is good to translate audio samples into unicode for internationalization
15:26:24 <hai> alright
15:27:04 <hai> acowley, i've just wrote a module to analyse lyrics, now the next step is to analyse the song
15:28:29 <acowley> hai: that sounds very cool! Do you have access to something like the music genome project that you could use to train a machine learning based analysis?
15:28:32 <ddarius> acowley: In "effect" terminology, Apply just doesn't necessarily have a "do nothing" "action."
15:28:39 <Mathnerd314> monochrom: do I just delete everything with array-0.3.0.2 in its name?
15:28:57 <monochrom> no, you should find out the real problem, but I have to go.
15:29:39 <hai> acowley,i thought about it, but seemed overkill
15:29:45 <acowley> Mathnerd314: ghc-pkg unregister array-0.3.0.2 is what I would try if I were trying to follow monochrom's advice
15:30:05 <hai> because the main part would be the rhytym
15:31:04 <ddarius> monochrom: Just like a Haskeller to want people to "understand."
15:31:34 <Mathnerd314> I deleted cabal/array-0.3.0.2 and ghc\package.conf.d\array-....conf; is that what ghc-pkg unregister would do?
15:31:37 <acowley> hai: Something I did many years ago in this area was to just take the volume of the lower frequencies and use that to determine tempo
15:31:44 <acowley> ddarius: that is helpful
15:31:55 <acowley> ddarius: but it is curious
15:31:57 <hai> acowley, perhaps when i finish the project...
15:32:05 <dcoutts> Mathnerd314: ghc-pkg also updates the package db cache.
15:32:28 <dcoutts> Mathnerd314: it's better to use ghc-pkg than fiddle with the files manually
15:32:38 <acowley> ddarius: You would think a do nothing effect would be trivial, yet the inability to proved a pure for, say, IntMap seems unrelated
15:32:42 <monochrom> you now need "ghc-pkg recache"
15:33:36 <acowley> hai: when you get really ambitious, you can try to figure out what key signature is in effect as that will also be a big clue into emotion. I left that job before I got that far, though!
15:34:22 * hackagebot cabal-install 0.10.2 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-0.10.2 (DuncanCoutts)
15:34:26 <ddarius> acowley: IntMap is like a specialized version of the reader monad where the "do nothing" action is to make a term that doesn't depend on the environment.
15:34:27 <dcoutts> @yarr!
15:34:27 <lambdabot> Yarrr!
15:35:09 <acowley> ddarius: like const?
15:35:13 <ddarius> That lambdabot command has seen far less use lately.
15:35:23 <ddarius> acowley: It is const.
15:36:01 <acowley> ddarius: but somehow that seems reasonable for IntMap to support actually
15:36:17 <ddarius> acowley: It could be added fairly easily.
15:36:28 <acowley> pure (x::a) = const x :: IntMap a
15:37:18 <acowley> ddarius: but IntMap and Map are the only instances of Apply that aren't Applicative according to the docs
15:37:39 <acowley> ddarius: but it seems like an accident that we don't have pure for those types
15:39:23 <acowley> ddarius: I must be missing something big, because the semigroupoids introduction makes it sound like a lack of pure is significant
15:39:44 <ddarius> It is significant.
15:40:05 <acowley> well at least I got that far :)
15:40:31 <acowley> but is it significant for IntMap and Map?
15:42:21 <ddarius> Yes.  By adding a "const" you change or lose other things.  For example, keys no longer makes sense.
15:42:24 * hackagebot hsc3-dot 0.9 - haskell supercollider graph drawing  http://hackage.haskell.org/package/hsc3-dot-0.9 (RohanDrape)
15:42:26 * hackagebot hsc3-db 0.9 - Haskell SuperCollider Unit Generator Database  http://hackage.haskell.org/package/hsc3-db-0.9 (RohanDrape)
15:42:28 <TomMD> @yarr?
15:42:28 <lambdabot> Shiver me timbers!
15:42:59 <acowley> Well, they just stop being injective
15:43:06 <acowley> or you lose that guarantee
15:43:24 * hackagebot hsc3-rec 0.9 - Haskell SuperCollider Record Variants  http://hackage.haskell.org/package/hsc3-rec-0.9 (RohanDrape)
15:44:23 <frank00> little Q from a |\|003:
15:44:45 <frank00> given a list of primes, I can successfully compute the next one
15:44:45 <frank00> isPrime pastPri num = and $ ((/=0) . (num `mod`)) <$> pastPri
15:44:46 <frank00> nextPrime pastPri   = head $ filter (isPrime pastPri) [2..] 
15:45:08 <frank00> is there a way to obtain, from the function nextPrime, an infinite list of primes?
15:45:52 <frank00> I read the way you are supposed to do it, I was just wondering if the above code is a dead end
15:48:02 <ddarius> acowley: You can easily turn any semigroup into a monoid (this is what the Maybe instance of Monoid does) just by formally adding a unit.  That's roughly what adding "const" to Map would be doing.  So, on the one hand, the difference between Apply and Applicative may not be that great, but, on the other hand, there's a big difference between a set of points and a vector space even though you get a vector space from a s
15:48:02 <ddarius> et of points simply by choosing one to be the origin.
15:48:20 <augur> ddarius!
15:48:21 <lambdabot> augur: You have 1 new message. '/msg lambdabot @messages' to read it.
15:48:23 <augur> eep
15:50:31 <acowley> ddarius: Thank you! So Applicative is Apply with out the "semi-" modifier on the monoidal part?
15:52:09 <ddarius> data ApplicativeFromApply f a = Pure a | Apply (f a); instance Apply f => Applicative (ApplicativeFromApply f) where pure = Pure; Pure f <*> Pure x = Pure (f x); Pure f <*> Apply x = fmap f x; Apply f <*> Pure x = fmap ($ x) f; Apply f <*> Apply x = Apply (f <.> x)
15:52:49 <sshc> I can't use Ï as a name for a value (let Ï = foobar), can I?
15:52:58 <ddarius> This is MaybeApply in semigroupoids
15:53:19 <azaq23> > let (Ï) = (.) in (+ 2) Ï (* pi) $ 10
15:53:20 <lambdabot>   No instance for (GHC.Num.Num (f a))
15:53:20 <lambdabot>    arising from a use of `e_1210' at <i...
15:53:23 <ddarius> sshc: Sure you can.
15:53:52 <monochrom> > let Ï=() in Ï
15:53:53 <lambdabot>   ()
15:53:56 <sshc> > let Ï = pi in Ï
15:53:57 <lambdabot>   3.141592653589793
15:53:57 <monochrom> works
15:54:00 <sshc> Huh, wow
15:54:05 <sshc> I wasn't expecting that :)
15:54:09 <sshc> Do I need an extension?
15:54:14 <ddarius> No.
15:54:16 <sshc> Or it standard Haskell 98?
15:54:49 <sshc> > let + = 3 in +
15:54:49 <lambdabot>   <no location info>: parse error on input `+'
15:55:11 <geheimdienst> > let (+) = 3 in (+)
15:55:12 <ddarius> "Haskell uses the Unicode [11] character set." - http://haskell.org/onlinereport/lexemes.html
15:55:12 <lambdabot>   3
15:55:15 <sshc> Are unicode characters treated as alphanumerical characters?
15:55:29 <ddarius> sshc: No.  They are treated by their character class.
15:55:38 <sshc> Ah,  Isee
15:55:41 <ddarius> > generalCategory 'Ï'
15:55:41 <sshc> Thanks
15:55:41 <lambdabot>   LowercaseLetter
15:55:48 <monochrom> tautological answer: unicode alphanumeric characters are treated as alphanumeric characters
15:56:17 <sshc> > let aÏ = 0 in aÏ
15:56:17 <ddarius> > generalCategory 'â'
15:56:18 <lambdabot>   0
15:56:18 <lambdabot>   MathSymbol
15:56:31 <ddarius> > generalCategory '+'
15:56:31 <lambdabot>   MathSymbol
15:56:51 <sshc> I wonder which symbol I should used for the magnitude of vectors
15:57:13 <ddarius> abs
15:57:38 <papermachine> I prefer to call it "The Situation operator".
15:57:51 <ddarius> Unfortunately, abs has a silly type for that purpose.
15:58:16 <acowley> papermachine: thank you for that
15:58:26 <ddarius> > let ÏÏ = 99 in ÏÏ
15:58:26 <lambdabot>   99
15:59:13 <sshc> Also, how are characters determined to be equivalent to "+" so that it's infix by default, or else equivalent to "a" so that it's prefix by default?
15:59:44 <monochrom> character class again
16:00:31 <sshc> monochrom: I was hoping for a more specific answer
16:00:39 <sshc> monochrom: Specifically, which attributes?
16:00:51 <monochrom> the generalCategoy function has the specific answers
16:01:43 <sshc> monochrom: Which General Categories are treated as infix and which as prefix?
16:02:02 <sshc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Char.html#t:GeneralCategory there seems to be many
16:02:16 <mm_freak_> ddarius: if your vectors have a dynamic dimension, then 'abs' is fine
16:02:41 <mm_freak_> but it cannot obey the abs/signum rule
16:02:57 <ddarius> mm_freak_: If you use multivectors then abs is fine as well.
16:03:01 <ddarius> signum is just broken
16:03:55 <mm_freak_> i think that in many cases it's fine to define the magnitude function as 'id'
16:04:18 <mm_freak_> you only need to compute the magnitude, when converting to a simple number
16:04:30 * hackagebot hsc3-lang 0.9 - Haskell SuperCollider Language  http://hackage.haskell.org/package/hsc3-lang-0.9 (RohanDrape)
16:05:12 <ddarius> I misremembered.  signum is fine, abs is broken.
16:05:21 <mm_freak_> why?
16:05:25 <mm_freak_> because of the type?
16:05:40 <drbean> Where is this Apply class? I can't find it with hoogle.
16:06:00 <mm_freak_> i think, signum is broken, because for many perfectly fine Num instances signum doesn't really make sense
16:06:14 <mm_freak_> drbean: Apply or ArrowApply?
16:06:35 <mm_freak_> or perhaps Applicative?
16:07:05 <acowley> drbean: semigroupoids
16:07:45 <ddarius> mm_freak_: Well Num as a whole is broken (in part by including abs and signum in its definition.)
16:07:52 <monochrom> @type abs
16:07:53 <lambdabot> forall a. (Num a) => a -> a
16:08:03 <acowley> I'm heading out. Thanks again ddarius!
16:08:07 <ddarius> > abs (1 :+ 0)
16:08:08 <lambdabot>   1.0 :+ 0.0
16:08:28 <monochrom> @type signum
16:08:29 <lambdabot> forall a. (Num a) => a -> a
16:09:09 <ddarius> > signum (1 :+ 1)
16:09:10 <lambdabot>   0.7071067811865475 :+ 0.7071067811865475
16:09:33 <hpc> > signum (1 :+ 1 :+ 1)
16:09:34 <lambdabot>   Precedence parsing error
16:09:34 <lambdabot>      cannot mix `Data.Complex.:+' [infix 6] and `D...
16:09:49 <hpc> :t (:+)
16:09:50 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
16:09:56 <hpc> humbug
16:10:24 <mm_freak_> if they wouldn't be called abs and signum, they may be ok
16:10:43 <mm_freak_> perhaps magnitude and direction
16:11:00 <hpc> mm_freak_: that's just convention though
16:11:06 <hpc> the inclusion itself isn't broken
16:11:57 <mm_freak_> hpc: it is, but it makes no sense for vectors
16:12:03 <monochrom> they should be called num'method'5 and num'method'6 to quench all debates about what they "mean"
16:12:22 <hpc> mm_freak_: the same mathematical notation is used for abs and magnitude
16:12:41 <mm_freak_> but â because
16:12:57 <hpc> > Just because
16:12:58 <lambdabot>   Not in scope: `because'
16:13:20 <drbean> > generalCategory 'ä¸'
16:13:21 <lambdabot>   OtherLetter
16:13:54 <frank00> wheter you did read my q or not, forget it, I solved
16:14:31 <mm_freak_> unless, of course, you define multiplication of vectors to be componentwise
16:30:32 <elliott> The Haskell Platform site says "Next release: January 2011". What method of time travel will be used to make this release available two months ago?
16:30:35 <elliott> TARDIS?
16:30:59 <elliottcable> oh gods not again
16:31:05 <hpc> elliott: the site doesn't update until it is evaluated
16:31:09 <elliott> Also "Release of 2011.2.0.0 (stable): Mar 5, 2011" which clearly didn't happen.
16:31:12 * elliottcable hides in a corner and cries
16:31:18 <elliott> hpc: Aha!
16:31:26 <elliott> hpc: Applying the power of lazy evaluation to all work.
16:31:33 <HugoDaniel> :D
16:31:34 <elliott> Actually I've been doing that for a while now, so it's old hat.
16:31:43 <elliottcable> Iâm going to sound like a dick for saying this, but I really wish Iâd registered elliott when I had the chance. Then I could be even more of a dick now and just ghost him. <,<
16:31:56 <elliott> I think I'm technically homeless, but I haven't checked yet, so it hasn't happened.
16:32:02 <elliott> I just close my eyes as I walk about my house.
16:32:27 <hpc> elliott: it's even safe! the walls don't exist yet
16:32:37 <hpc> >unsafeOpenEyeballs
16:32:41 <elliott> hpc: Hell, I'm surprised you're even receiving these messages.
16:32:51 <elliott> I'm just waving my hands about to type on a keyboard I'm not sure even exists.
16:32:51 <hpc> your tubes died?
16:32:55 <hpc> oh lol
16:33:06 <ezyang> Ooh, generalized arrows make me so excited! 
16:33:24 <elliott> ezyang: Y-eees...
16:45:03 <ezyang> In particular, staged compilation seems like a special case of partial evaluation that seems like it works much better than the general case. Though I'm not sure if that's actually true :-) 
16:51:27 <megajosh2> Hey, is there a simple way to find the directory of the file the program being executed is in?
16:51:45 <megajosh2> ...okay s/of the file//
16:53:41 <dmwit> megajosh2: exec pwd? ;-)
16:53:49 <dmwit> megajosh2: But more seriously, look in System.Directory.
16:58:40 <monochrom> System.Directory deliberately doesn't do it because it is difficult in windows
16:59:05 <monochrom> but there is an elaborate way coded up in the package FindBin
17:00:08 <megajosh2> Oh god
17:00:11 <monochrom> I know this because there was a similar question a few days ago.
17:00:37 <monochrom> "oh god" is right if you look at the method used in the source code :)
17:00:46 <megajosh2> I know
17:01:10 <monochrom> in my case I was specifically "oh god tl;dr"
17:01:45 <kmc> megajosh2, which os?
17:03:51 <kmc> megajosh2, on Linux with GHC-compiled Haskell programs this should work:
17:03:58 <kmc> takeDirectory <$> readSymbolicLink "/proc/self/exe"
17:12:10 <megajosh2> kmc: Well, I wanted something cross-platform, but I guess that's something to remember in the future
17:21:51 <sunfun> @src dropWhile
17:21:51 <lambdabot> Source not found. :(
17:21:56 <sunfun> :'(
17:22:05 <sunfun> @src takeWhile
17:22:06 <lambdabot> takeWhile _ []                 =  []
17:22:06 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
17:22:06 <lambdabot>                    | otherwise =  []
17:22:57 <sunfun> :t dropWhile
17:22:57 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
17:23:02 <sunfun> @src takeWhile
17:23:03 <lambdabot> takeWhile _ []                 =  []
17:23:03 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
17:23:03 <lambdabot>                    | otherwise =  []
17:23:08 <sunfun> @src dropWhile
17:23:08 <lambdabot> Source not found. The more you drive -- the dumber you get.
17:23:36 <napping> that's odd
17:24:01 <sunfun> why the source of dropWhile is not present?
17:24:03 <napping> dropWhile does what you'd expect
17:24:09 <dmwit> Oh, you're right, I misunderstood what getCurrentDirectory did.
17:24:48 <napping> sunfun:  http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/base-4.3.1.0/src/GHC-List.html#dropWhile
17:25:00 <kmc> sunfun, @src just looks in a text file that someone maintains
17:25:06 <sunfun> napping, i tried to write my own version of dropWhile
17:25:08 <napping> there is some source there..
17:25:09 <sunfun> ok
17:25:16 <sunfun> thanks
17:25:17 <napping> I think it's even the one GHC actually uses
17:25:23 <kmc> if you want the "real" source, look at the haddocks that napping linked
17:25:38 <kmc> probably the #1 page to bookmark if you're haskelling is http://www.haskell.org/ghc/docs/7.0-latest/html/libraries/index.html
17:25:45 <kmc> and all those have source links
17:25:46 <napping> hmm, that's straight to the source page, i think
17:26:02 <napping> yes, Haddoc now produces source pages for most modules
17:26:15 <napping> It's recent enough that I remember when it didn't do that, at least
17:26:32 <kmc> you have to pass --hyperlink-source
17:27:11 <monochrom> and the #0 page to bookmark is http://www.haskell.org/onlinereport/haskell2010/
17:27:29 <hpaste> sunfun pasted "dropWhile'"  http://hpaste.org/44630
17:27:58 * hackagebot netlines 0.3.0 - Enumerator tools for text-based network protocols  http://hackage.haskell.org/package/netlines-0.3.0 (ErtugrulSoeylemez)
17:28:01 <kmc> strange, ghc actually supports tag bits in Int#
17:28:25 <btutt> unboxed ints have tag bits? wierd
17:28:30 <kmc> they don't by default
17:28:56 <napping> sunfun: the cases look a bit strange
17:28:57 <sunfun> napping kmc, i tried to recreate dropWhile for exercise do you think it's right way?
17:29:07 <napping> why do you have p x == False, p x, and otherwise?
17:29:14 <kmc> but you can configure GHC when building to use fewer bits
17:29:17 <kmc> and most of the code will deal
17:29:23 <kmc> that is, if "The word size story" is to be believed
17:29:49 <btutt> if its not in an auto tester I wouldn't believe it. sorta like those unreg Solaris failures. ;)
17:29:51 <napping> That might be nice, if the stuff about a strict language ever gets working
17:29:54 <sunfun> napping, i suppose that p x is like p x == True
17:29:57 <monochrom> your dropWhile also does things the opposite way.
17:29:59 * hackagebot ismtp 2.0.2 - Advanced ESMTP library  http://hackage.haskell.org/package/ismtp-2.0.2 (ErtugrulSoeylemez)
17:30:12 <monochrom> oh nevermind, not opposite
17:30:13 <geheimdienst> kmc, have they made it into a musical yet?
17:30:28 <napping> sunfun: shouldn't help too much for excercies, but you could try some examples
17:30:36 <monochrom> your "| otherwise = []" is dead code.
17:30:40 <napping> also, with quickCheck
17:31:11 <napping> hmm, Ordering is a three element type
17:32:20 <napping> no Arbitrary instance, though
17:32:40 <sunfun> monochrom, i've tried dropWhile and mine with the same input and it seems to work
17:32:48 <kmc> napping, some would say it's a four-element type ;)
17:33:24 <napping> such libertines, admitting the existence of bottoms in public
17:33:34 <napping> oops
17:33:39 <monochrom> â¥
17:33:40 <kmc> sunfun, you could use QuickCheck to attain a higher degree of certainty
17:34:22 <hpaste> shit pasted "shit"  http://hpaste.org/44631
17:34:51 <Cale> lol
17:35:27 <sunfun> kmc, ok i'll try that then, thanks
17:37:14 <hpaste> 22-- pasted "testing"  http://hpaste.org/44632
17:39:44 <napping> +++ OK, passed 100 tests.
17:39:56 <shachaf> @check (==)
17:39:56 <lambdabot>   "OK, passed 500 tests."
17:40:43 <napping> wait, how does that work?
17:40:56 <augur> @check
17:40:57 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:41:02 <aavogt> napping: defaulting to ()
17:41:05 <augur> @help check
17:41:06 <lambdabot> check <expr>
17:41:06 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
17:41:20 <napping> ah, that's the trick
17:41:24 <augur> @google quickcheck
17:41:24 <lambdabot> http://en.wikipedia.org/wiki/QuickCheck
17:41:25 <lambdabot> Title: QuickCheck - Wikipedia, the free encyclopedia
17:41:40 <kmc> when will ghc --make support parallel compilation?
17:41:51 <sshc> @check (== 0)
17:41:52 <lambdabot>   "Falsifiable, after 2 tests:\n1\n"
17:41:54 <sshc> @check (== 0)
17:41:54 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n"
17:42:02 * hackagebot ismtp 2.0.3 - Advanced ESMTP library  http://hackage.haskell.org/package/ismtp-2.0.3 (ErtugrulSoeylemez)
17:42:04 <tswett> > [1,]
17:42:05 <lambdabot>   <no location info>: parse error on input `]'
17:42:17 <tswett> Aw.
17:42:32 <mm_freak_> > [1..]
17:42:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:46:54 <aavogt> kmc: doesn't linking take most of the time anyways?
17:47:22 <kmc> dunno
17:47:24 <kmc> maybe not with gold
17:47:45 <kmc> right now i'm building ghc itself with make -j 12
17:47:48 <kmc> and it's nice and speedy
17:48:26 <monochrom> I have started using the gold linker. Not error yet.
17:48:32 <kmc> i guess few haskell projects have more than a dozen modules
17:48:42 <monochrom> It is also markedly more efficient.
17:49:02 <kmc> i think ocamlc takes much less time to compile itself
17:49:19 <aavogt> or if they have that many modules, you don't need to recompile all of them
17:49:28 <kmc> aavogt, except when you cabal-install it
17:49:55 <aavogt> think of the developers
17:50:05 <kmc> i wonder where ghc spends most of its time
17:50:26 <kmc> i wonder this out loud so that other people will tell me :)
17:50:34 <geheimdienst> lambdacats
17:50:43 * geheimdienst doesn't know, but doesn't mind telling kmc something
17:50:55 <aavogt> @quote have.a.type
17:50:55 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
17:51:09 <Makoryu> ï¼ãÂ°â¿â¿Â°ï¼
17:51:11 <kmc> ghc -fvia-stack-overflow
17:51:13 <monochrom> I be damned if type inference takes more time than optimization :)
17:51:36 <geheimdienst> @quote olegfacts
17:51:36 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
17:51:43 <kmc> we need to get that supercompiler into ghc
17:51:45 <geheimdienst> @quote olegfacts .
17:51:45 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
17:51:48 <kmc> then i will know where ghc spends all its time
17:51:55 <geheimdienst> @quote OlegFacts .
17:51:56 <lambdabot> OlegFacts says: Oleg implemented first-class continuations in Haskell... in the type system
17:52:06 <Makoryu> monochrom: Are we assuming the default set of language extensions? I'm sure a complicated type-level program with a bunch of extensions would take way more time than optimization
17:52:13 <geheimdienst> @quote OlegFacts .
17:52:13 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
17:52:29 <monochrom> @quote OlegFacts
17:52:29 <lambdabot> OlegFacts says: Oleg implemented first-class continuations in Haskell... in the type system
17:52:53 <geheimdienst> only 2 oleg facts. this deperately needs extending
17:53:27 <kmc> creeepy
17:53:30 * monochrom volunteers "1 oleg equals 1000 milliolegs"
17:53:38 <shachaf> geheimdienst: There used to be a lot more but lambdabot's database got deleted.
17:53:57 <shachaf> Searching the IRC logs for "@remember OlegFacts" might yield a few.
17:54:06 <geheimdienst> good idea
17:54:07 <shachaf> (Though I know that some were added through /msg.)
17:54:19 <aavogt> or just times that they have been printed in here
17:54:38 <kmc> @quote
17:54:38 <lambdabot> islands says: how will people know I'm cool if I'm not wearing my sunglasses?
17:54:42 <geheimdienst> we could even search for @remember anything and merge it, ditto for @quote
17:54:44 <monochrom> need a persistent lambdabot
17:54:52 <kmc> @quote ubuntu.freebsd
17:54:52 <lambdabot> NIXDAEMON-COOL says: how to uncompile make into java gcc 3.3 under ubuntu freebsd ??
17:55:27 <shachaf> geheimdienst: No, some things were @forgotten for good reason.
17:56:14 <monochrom>  @forget monochrom I denounce FP
18:03:52 <kmc> cool, building ghc took 17 minutes
18:04:07 <monochrom> god, I was betting on 3 hours
18:04:46 <kmc> more cores
18:05:01 <monochrom> I will have to update my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml on how to pass time when waiting for ghc to be built
18:05:10 * kmc types "import qualified Data.Map as M" in ghci
18:05:12 <kmc> yesssssss
18:05:40 <HugoDaniel> :)
18:05:45 <HugoDaniel> that sure is handy
18:06:17 <monochrom> perhaps "you should browse youtube while it builds"
18:06:39 <parcs> doesn't ghc use cabal to build things?
18:06:49 <monochrom> not always
18:07:11 <monochrom> actually, cabal uses cabal to build things.
18:07:22 <parcs> i mean during building ghc
18:07:24 <napping> and Cabal uses ghc to build Haskell things
18:07:41 <monochrom> no, ghc doesn't use cabal to build ghc
18:08:01 <napping> ghc used complicated Makefiles to build itself long before cabal
18:08:41 <napping> nobody has managed to replace them
18:09:35 <parcs> i see
18:09:42 <monochrom> actually, why do you build ghc?
18:10:13 <napping> the last time, I was hacking on the grammar a bi
18:10:25 <kmc> i wanted to see if i could actually make it use 30-bit integers
18:10:43 <napping> t, to allow things like forM list \x -> stuff
18:10:49 <kmc> also, it seems that the TypeFamilies / GeneralizedNewtypeDeriving segfault is still not fixed :/
18:12:30 <monochrom> speaking of :/ , today I found some similar APL characters. â¢ â¥ â¨
18:13:01 <dmwit> Øª
18:13:12 <djahandarie> That's just arabic :P
18:13:21 <monochrom> hehe
18:13:39 <monochrom> "arabic letter teh"
18:13:51 <monochrom> would be awesome if it were "arabic letter heh" :)
18:14:07 <monochrom> Ø«
18:14:09 <kmc> arabic letter meh
18:14:23 <monochrom> that is "theh", which is close enough :)
18:15:14 <kmc> i wonder if there are plans to deprecate the C backend entirely
18:15:17 <kmc> in GHC
18:15:23 <kmc> the user guide says registerized via-C is deprecated
18:16:09 <Makoryu> kmc: God I hope so
18:16:15 <Makoryu> Well
18:16:16 <Makoryu> Actually
18:16:33 <kmc> i'm all for keeping the unregisterized C backend
18:16:40 <kmc> as a way to cross-compile code for esoteric platforms
18:16:47 <Makoryu> It's nice to have a--yes that, exactly
18:16:49 <Makoryu> But then
18:16:52 <kmc> it doesn't require nasty things like the Evil Mangler
18:16:57 <Makoryu> LLVM can help with that too
18:17:08 <kmc> a lot of platforms have LLVM backends but a lot more have a C compiler ;P
18:17:36 <Makoryu> Fine, throw out my impeccable logic with truth and facts!  â(ãÂ´ã°`)â 
18:17:38 <kmc> i'm not sure how much arch-specific work is required to add a new LLVM target in GHC
18:17:41 <co_dh> greeting, what's the name of the theorem for free bot here? 
18:17:52 <kmc> i've seen a few references to "registerized LLVM" versus "unregisterized LLVM"
18:18:11 <co_dh> @tf
18:18:11 <lambdabot>  Done.
18:18:13 <monochrom> @free reverse :: [a] -> [a]
18:18:14 <lambdabot> $map f . reverse = reverse . $map f
18:18:28 <co_dh> monochrom: thanks
18:18:35 <monochrom> I wonder what is done to @tf
18:18:48 <monochrom> @help tf
18:18:48 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:18:53 <co_dh> @free map :: (a->b) -> f a -> f b
18:18:53 <lambdabot> Extra stuff at end of line
18:19:03 <co_dh> :t fmap
18:19:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:19:31 <co_dh> @free forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:19:32 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
18:23:11 <roconnor> @free fmap :: (a -> b) -> F a -> F b
18:23:11 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
18:25:12 <levifikri> Hi, I have a list [1,2,3,4,5,6,7,8,9]. I want to split it into [[1,4,7], [2,5,8],[3,6,9]]. Is there any built in function for that?
18:26:05 <ion> @hoogle Integral n => n -> [a] -> [[a]]
18:26:05 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
18:26:05 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
18:26:05 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
18:26:17 <Saizan> in the split package on hackage i think, or you can write a simple loop with splitAt
18:26:22 <Saizan> or take/drop
18:26:22 <HugoDaniel> levifikri, splitAt
18:26:38 <monochrom> and then transpose
18:27:18 <monochrom> co_dh: roconnor probably wanted to show you this example:
18:27:23 <monochrom> @free fmap :: (a -> b) -> F a -> F b
18:27:24 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
18:27:31 <Saizan> > transpose . takeWhile (not . null) . map (take 3) . iterate (drop 3) $ [1,2,3,4,5,6,7,8,9]
18:27:32 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
18:28:16 <HugoDaniel> cool :)
18:28:50 <djahandarie> > tranpose . chunk 3 $ [1,2,3,4,5,6,7,8,9]
18:28:51 <lambdabot>   Not in scope: `tranpose'Not in scope: `chunk'
18:28:58 <djahandarie> Futile attempt
18:29:08 <djahandarie> > transpose . splitEvery 3 $ [1,2,3,4,5,6,7,8,9]
18:29:09 <lambdabot>   Not in scope: `splitEvery'
18:29:11 <djahandarie> :<
18:29:35 <djahandarie> > transpose . Data.List.Split.splitEvery 3 $ [1,2,3,4,5,6,7,8,9]
18:29:36 <lambdabot>   Not in scope: `Data.List.Split.splitEvery'
18:29:43 <djahandarie> Some of the more useful packages end up not being in lambdabot
18:30:03 <monochrom> no bot is perfect
18:32:33 <levifikri> cool. Thx
18:33:14 <co_dh> monochrom:  thanks !  is there a paper explain the theorem for free categoryly ? 
18:34:52 <monochrom> I don't know.
18:39:18 <dolio> Categorical Models of Parametric Polymorphism.
18:43:20 <co_dh> dolio: thanks !!  #haskell is amazing :)
18:47:52 <roconnor> @free sortBy
18:47:53 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
18:48:35 <co_dh> :t sortBy
18:48:36 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
18:49:04 <co_dh> @free [a] -> [a]
18:49:04 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
18:49:14 <co_dh> @free f :: [a]->[a]
18:49:14 <lambdabot> $map g . f = f . $map g
18:49:15 <roconnor> the free theorem says that if f is a strictly monotone function then you can pass it through sortBy
18:52:41 <roconnor> we know this without even knowing how sortBy is implemented.  Just its type.
19:01:16 <xplat> > fst (fix $ (((||) . (0 ==) <*>) *** ((&&) . (0 /=) <*>)) . (snd &&& fst) . ((. pred) *** (. pred))) 3
19:01:18 <lambdabot>   False
19:01:21 <gwern> serpentine.com was bos's domain right?
19:01:24 <djahandarie> Yes
19:01:28 <gwern> preflex: seen bos
19:01:28 <preflex>  bos was last seen on #haskell 4 hours, 44 minutes and 19 seconds ago, saying: edwardk: yeah
19:01:42 <gwern> bos: is http://www.serpentine.com/blog/2007/04/12/haskellorg-and-googles-summer-of-code/ supposed to be broken?
19:01:57 <djahandarie> The whole site seems to be down. :(
19:03:45 <gwern> djahandarie: that seems to happen fairly regularly. maybe I should just switch all my serpentine.com links to the internet archive.. kind of annoying how they keep showing up on my linkchecker reports
19:04:15 <djahandarie> Or just host bos's site for him ;)
19:04:42 <gwern> djahandarie: it's too dynamic. I like more static sites
19:29:07 <frank00> http://projecteuler.net/index.php?section=problems&id=11 <- I am a bit unsure on the best way of tackling this
19:31:22 <frank00> is there anything that looks like a matrix in haskell. I mean, with random access?
19:31:28 <Cale> Sure, an array
19:31:42 <Cale> You can use an array which is indexed by a pair.
19:32:14 <Cale> listArray ((1,1),(20,20)) listOfElements
19:32:20 <frank00> that would make this more easy
19:32:55 <Cale> Or you could use a Data.Map, which would probably be a little less efficient for this, but it's a good datastructure to know about at well.
19:33:02 <Cale> as*
19:35:44 <TTimo> So I'm checking out concurrency with forkIO, and the compiled version exits as soon as main is evaluated, to the print server, and the other forkIO'd stuff never completes or get to print all of it's work
19:36:09 <TTimo> I can add a special message in the channels to force main to wait until they all report done, but is there an easier way ?
19:36:53 <c_wraith> TTimo: the original thread is special.  The program exits when the original thread ends
19:37:23 <TTimo> yeah .. I noticed that .. I'd rather it waits till all the threads are done .. or have the original thread wait
19:37:25 <c_wraith> TTimo: You'll have to just deal with that one way or another.  using an MVar to indicate completion is a common technique for that.
19:37:26 <Cale> As far as the algorithm to use is concerned, I'd probably just do the simple thing of hanging on to (product, last position, direction) triples, starting with the easy list of "length 1" such triples, successively extending each of the entries by multiplying on the next number and moving the last position, and then removing any with a zero product.
19:37:54 <TTimo> alright
19:39:41 <frank00> thanks cale
19:56:25 <glguy> Anyone know of a better way to implement (power :: Matrix a -> Int -> Matrix a) in hmatrix than: \ m n -> optimiseMult (replicate n m)  ?
19:56:56 <napping> repeated squaring?
19:57:36 <Pseudonym> If M = Q' D Q where D is diagonal, then M^i = Q' D^i Q
19:57:52 <napping> fancy
19:57:53 <Pseudonym> Just sayin'.
19:58:07 <Pseudonym> Especially handy for computing Fibonacci numbers.
19:58:33 <napping> if you work in Q[sqrt(5)]
19:58:43 <Pseudonym> Quite.
19:59:06 <glguy> Well, now I have to figure out how to decompse my matrix as such :)
19:59:07 <Pseudonym> Know Your Eigenstuff
20:01:19 <lpsmith> Ok,  when it comes to magic variables in .cabal/config files,  is there one for $version,  as in $compiler would expand to e.g. "ghc-6.12.3",  is there one that would expand to "6.12.3"?
20:01:34 <glguy> but if M can be factored into Q Q' I could chose I as my "D"... Q' I Q 
20:01:41 <glguy> and I^i is I
20:01:57 <Pseudonym> Unfortunately that doesn't help.
20:02:02 <Pseudonym> In this case, Q' is the inverse of Q.
20:02:08 <glguy> OH
20:02:12 <glguy> that makes more sense
20:02:15 <Pseudonym> Yeah.
20:02:32 <Pseudonym> (Q' D Q) (Q' D Q) = Q' D (Q Q') D Q = Q' D^2 Q
20:03:02 <napping> what are you trying to code this for?
20:03:14 <glguy> Making my project euler 213 solution go faster :)
20:03:47 <napping> you might first try A^n = (A^(n `div` 2))^2 * (if n `mod` 2 == 1 then A else I)
20:04:12 <glguy> I did that, I didn't get much of a boost, really
20:04:57 <Pseudonym> So in that case, glguy, D = I.
20:05:00 <napping> oh, I guess you might want to factor then
20:05:17 <Pseudonym> Isn't it?
20:05:42 <Pseudonym> The transition matrix only has unitary eigenvalues, I think.
20:05:48 <Pseudonym> Hmm, maybe not.
20:06:15 <Pseudonym> But you can actually get the eventual steady state of the system just by looking at eigenvectors of the transition matrix.
20:06:22 <napping> entries are 0 or 1
20:06:29 <Pseudonym> No.
20:06:36 <Pseudonym> They're not.
20:06:57 <napping> oh, that's not so nice
20:07:14 <Pseudonym> If you're in a central square, then there's a 0.25 chance each of going to one of four destinations.
20:07:19 <napping> It's pretty block diagonal
20:07:31 <glguy> I'll toss my solution up on the pastebin in a second
20:07:31 <napping> have you tried coding the update more directly?
20:07:41 <napping> it's quite a sparse matrix
20:07:52 <glguy> it starts sparse, but it ends dense
20:08:01 <Pseudonym> You could probably throw it in FISHPACK.
20:08:03 <glguy> t^50
20:08:06 <glguy> FISHPACK?
20:08:11 <napping> start with a vector of all ones
20:08:17 <napping> then apply the matrix to the vector 50 times
20:08:26 <Pseudonym> glguy: Silly Fortran programmers and their puns.
20:08:36 <Pseudonym> It's equivalent to the discretisation of a Poisson problem.
20:08:45 <napping> v'[i] = (v'[i-1]+v'[i+1]+v'[i-30]+v'[i+30])/4, or so
20:08:57 <Pseudonym> http://www.cisl.ucar.edu/css/software/fishpack/
20:09:10 <glguy> unfortunately "Poisson problem" renders as "Math thing" on my IRC client
20:09:52 <napping> the most efficient thing to do here is probably calculate as A (... (A v) ... )
20:09:55 <Pseudonym> Imagine you have a 2D grid of numbers, with values around the edges.
20:10:32 <Pseudonym> Poisson's equation is \Nabla^2 phi = f
20:10:41 <Pseudonym> Where \Nabla^2 is the Laplacian.
20:11:50 <Pseudonym> Basically, the transition function for this problem looks very much like the discrete solution of that equation.
20:12:05 <Pseudonym> Sorry, discretisation.
20:13:39 <hpaste> glguy pasted "thing"  http://hpaste.org/44635
20:21:14 <glguy> actually, the power function isn't the slow part :)
20:21:21 <glguy> I guess its just that its a big matrix
20:27:08 <napping> is the new platform release out?
20:27:25 <napping> I thought I saw a page for it, but I don't now
20:27:31 <c_wraith> nope.  A few more days, at least.
20:27:48 <c_wraith> Release candidates are available, but they just fixed a bug, so there's another round of testing to do
20:27:52 <napping> was it up termporarily?
20:27:58 <mzero> getting close!  I'm building RC4 right now!
20:28:05 <c_wraith> no, there's the release candidate page though
20:28:15 <c_wraith> which you may have seen
20:51:10 <suitifiable> guys
20:51:13 <suitifiable> i have a sunday boner
20:52:42 <suitifiable> now its just a boner
20:53:31 <shamster_> I've got some code snippet that could use a better eye than mine. What can I do (data structure or logic-wise) to make it more efficient (speed)? http://codepad.org/IKVDKSfd
20:54:23 <shamster_> I'm parsing a text data file (mdcrd) made up of a series of doubles that represent x1 y1 z1 x2 y2 z2 x3 y3 .... zn
20:54:43 <shamster_> and trying to form Coordinates that are 3d vectors of the x,y,z components
20:55:02 <shamster_> two separate modules are listed
20:56:08 <Cale> > words "a \n b \n c"
20:56:09 <lambdabot>   ["a","b","c"]
20:56:38 <Cale> shamster_: why split it into lines if you just concat the lines together again?
20:57:00 * glguy thanks cabal for checking for the existance of profiling libraries only after building the non-profiling objects and then deleting all of the non-profiling objects when reporting the late error
20:57:03 <shamster_> > words "a b c \n d e f \n g h i"
20:57:04 <lambdabot>   ["a","b","c","d","e","f","g","h","i"]
20:57:17 <shamster_> Cale: That's a good point!
20:57:31 <Cale> shamster_: Another option would be to skip the splitEvery instead
20:57:56 <Cale> shamster_: and just maintain the structure which was present from the file (which is presumably 3 numbers per line)
20:58:01 <shamster_> Cale: how would I group them into the 3 components?
20:58:08 <shamster_> Cale: no... multiple numbers per line
20:58:11 <Cale> ah, okay
20:58:21 <Cale> In that case, just words and splitEvery
20:58:49 <Cale> But I think probably to make this much faster, you may need to get away from using String I/O
20:59:06 <djahandarie> Any reason split isn't in lambdabot btw, Cale?
20:59:36 <shamster_> Cale: assuming I can't change the data file from what it is (a long text file with numbers)... how could I do that?
21:00:52 * djahandarie calls it a night
21:02:30 <Cale> Every package that we add to lambdabot makes it respond to each request a little slower
21:02:37 <Cale> (because it has to load more and more)
21:03:18 <Cale> I suppose we could add split, but there's already a lot of stuff :)
21:03:31 <mjrosenb> @hoogle Int -> a -> [a]
21:03:31 <lambdabot> Prelude replicate :: Int -> a -> [a]
21:03:32 <lambdabot> Data.List replicate :: Int -> a -> [a]
21:03:44 <Cale> shamster_: Well, using the ByteString or Data.Text libraries.
21:04:21 <Cale> shamster_: String is convenient, but tends to be rather inefficient, as you'd expect (linked) lists of 32 bit characters to be.
21:05:08 <shamster_> Cale: does that mean moving away from the "map read" to produce something else?
21:05:29 <Cale> yeah... umm...
21:05:43 <shamster_> Cale: I guess I'm not sure where I'd introduce the ByteString or the Text
21:05:50 <shamster_> instead of the strings
21:06:00 <Cale> oh, I suppose it is a bunch of Double values, hmm
21:06:18 <Cale> I wonder if there's an efficient parser for those which uses Data.ByteString or Data.Text
21:07:00 <Cale> Data.ByteString has readInt and readInteger
21:07:09 <Cale> but nothing for floating point numbers
21:07:30 <shamster_> Data.ByteString.Lex.Lazy.Double ?
21:07:37 <Cale> http://hackage.haskell.org/packages/archive/bytestring-lexing/0.1.2/doc/html/Data-ByteString-Lex-Double.html
21:07:39 <Cale> yeah
21:07:45 <Cale> that looks like it might be good
21:13:35 <kulin> evening, is there a good way to handle a function which only works on a specific constructor of a data type? ie: data Pet = Cat String | Dog String  &  dogName :: Dog -> String
21:14:50 <kulin> like i can see pattern matching ie: dogName (Dog name) = name but that seems like a partially implemented definition of dogName :: Pet -> String
21:15:10 <shamster_> kulin: afaik that's the way to do it
21:15:48 <kulin> can the compiler statically check that the function is never called with Cat?
21:15:59 <jmcarthur> kulin: why not just have two different types?
21:16:18 <shamster_> data Dog = Dog String
21:16:21 <jmcarthur> kulin: there are a few ways to do what you ask, but i'm not sure if they are really what you want
21:16:23 <shamster_> data Cat = Cat String
21:16:33 <kulin> jmcarthur its more than i am writing a program which sort of parses a tree structure of someone else's types and i want a specific function for a specific kind of node
21:16:33 <jmcarthur> shamster_: newtype, please :)
21:17:09 <jmcarthur> kulin: well, then the only truly type safe way to do it is to return a Maybe String instead of a String, if you don't have any control over the types themselves
21:17:20 <shamster_> jmcarthur: I don't follow
21:17:33 <kulin> people love newtype for single constructor data types
21:17:43 <jmcarthur> shamster_: usually if you have a single constructor, you want newtype instead of data
21:17:50 <alpounet> shamster_, http://www.haskell.org/haskellwiki/Newtype
21:17:57 <jmcarthur> shamster_: it's very rare not to want newtype in that situation, at least
21:18:20 <jmcarthur> data is nice for records though
21:19:27 <jmcarthur> kulin: if you had control over the types then you could have two different types for it, or you could use a GADT to tag it (which is effectively two different types, but it allows you to use some polymorphism for Pet at least)
21:20:25 <kulin> i think its not worth it, i can easily do a mapMaybe or something and filter what i want
21:20:33 <kulin> just didnt want to be so verbose in my code
21:20:33 <jmcarthur> data Pet a where Cat :: String -> Pet Cat; Dog :: String -> Pet Dog;     dogName :: Pet Dog -> String
21:20:53 * hackagebot authenticate 0.8.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.8.1 (MichaelSnoyman)
21:24:09 <shamster_> once I've done a "longFile <- readFile filepath"... how do I get it to a ByteString? Or... am I missing the point that I should use something other than readFile?
21:26:40 <kulin> doesnt bytestring have its own readFile?
21:27:10 <Axman6> yes
21:28:00 <shamster_> gotcha, found it
21:28:01 <shamster_> thanks
21:38:04 <kmc> preflex, zdec base_GHCziNum_zm_info
21:38:04 <preflex>  base_GHC.Num_-_info
21:38:36 <co_dh> greeting, I'm reading quickcheck , and don't understand the following code : 
21:38:37 <co_dh> prop_RevRev xs = reverse (reverse xs) == xs   where types = xs::[Int]
21:39:04 <co_dh> the xs ::[Int] part is weild, 
21:39:08 <kmc> the variable "types" is unused, correct?
21:39:30 <co_dh> ohhh, nice hack. 
21:39:32 <co_dh> thanks kmc
21:39:33 <kmc> (xs :: [Int]) is a type signature on an expression, and is itself an expression
21:39:46 <kmc> myself i'd probably write prop_RevRev xs = reverse (reverse xs) == (xs :: [Int])
21:39:52 <kmc> or just give a signature for prop_RevRev
21:39:53 <co_dh> I would like it write as foo = xs :: [Int]. 
21:40:23 <kmc> unfortunately you can't say:
21:40:32 <kmc> prop_RevRev (xs :: [Int]) = reverse (reverse xs) == xs
21:40:35 <co_dh> yep, the types thing make me think : if the quickCheck lib check that there is a variable called types? 
21:40:39 <kmc> maybe with some GHC extension
21:40:55 <kmc> heh, no, it's really not possible for Haskell libs to do things like that ;)
21:41:03 <co_dh> kmc: thanks !!
21:41:13 <kmc> that's one of the reasons refactoring Haskell is a breeze compared to refactoring, say, Python
21:42:43 <co_dh> agree. last year, I wrote python for job. and some careless programmer introduced simple python bug as : variable typo.   That make me begin to think if python is a good idea. 
21:43:03 <co_dh> kmc : it seemed that I can always see you here. 
21:43:04 <shachaf> kmc: To be fair, if you said "def prop_RevRev(xs):\n  types = <xs::[Int]>\n  return reverse(reverse(xs)) == xs" in Python, nothing could examine the variable "types" either.
21:45:35 <shamster_> how does one turn a "Just 5" into "5" ?
21:45:46 <co_dh> :t fromJust
21:45:47 <lambdabot> forall a. Maybe a -> a
21:45:50 <kmc> shamster_, by pattern-matching
21:45:51 <shachaf> shamster_: One pattern-matches.
21:45:52 <mjrosenb> shamster_: you can pattern match or fromJust
21:45:53 <kmc> don't use fromJust.
21:45:57 <shachaf> co_dh: One does *not* use fromJust.
21:45:58 <kmc> > fromJust Nothing
21:45:59 <lambdabot>   *Exception: Maybe.fromJust: Nothing
21:46:12 <kmc> you can pattern-match with the "case" syntax
21:46:18 <shamster_> ah...
21:46:18 <kmc> if you want to use a function, use "maybe" or "fromMaybe"
21:46:18 * shachaf advises that the prefix "evil" be used instead of the prefix "unsafe".
21:46:23 <shachaf> evilPerformIO, evilFromJust, etc.
21:46:45 <co_dh> :t maybe
21:46:46 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:46:46 <mjrosenb> how do i ask lambdabot where a variable is declared?
21:46:50 <kmc> shachaf, reverse can.   http://docs.python.org/library/inspect.html
21:47:08 <co_dh> :t fromMaybe
21:47:09 <lambdabot> forall a. a -> Maybe a -> a
21:47:12 <Makoryu> shachaf: evilLaunchMissiles? ï¼ãÂ°â¿â¿Â°ï¼
21:47:23 <co_dh> > fromMaybe (Just 5 )
21:47:24 <lambdabot>   Overlapping instances for GHC.Show.Show
21:47:24 <lambdabot>                              (Data....
21:47:25 <shamster_> I'm trying to do : http://codepad.org/uIRWUDKY
21:47:28 <mjrosenb> @hoogle openTempFile
21:47:29 <lambdabot> System.IO openTempFile :: FilePath -> String -> IO (FilePath, Handle)
21:47:29 <shachaf> mjrosenb: @index in some cases.
21:47:30 <co_dh> > fromMaybe (Nothing)
21:47:31 <lambdabot>   Overlapping instances for GHC.Show.Show
21:47:31 <lambdabot>                              (Data....
21:47:35 <shachaf> mjrosenb: In general, one doesn't.
21:47:36 <shamster_> which is to say... make a [Double] from a Bytestring
21:48:23 <shamster_> but there's the error becuse readDouble is return a "Just Double"
21:48:35 <shamster_> er.. "Maybe Double" that becomes the Just Double...
21:49:00 <shachaf> kmc: Ah. Well, if you use that, you provide an "I know what I'm doing" sort of guarantee anyway, don't you?
21:52:09 <kmc> kind of
21:57:29 <shachaf> preflex: seen edwardk
21:57:29 <preflex>  edwardk was last seen on #haskell 7 hours, 25 minutes and 8 seconds ago, saying: do you have a guarantee it won't get swapped out? if not perhaps virtual memory =)
22:05:24 <dibblego> is this useful? type WriterM m w a = Writer w (m a)
22:06:54 <shachaf> dibblego: In what context?
22:08:01 <dibblego> none really, it just came up in some code I am writing
22:08:44 <dibblego> I have a couple of different values for m
22:09:00 <dibblego> also, I am using scala, which can make judgement of soundness very challenging
22:18:29 <shamster_> could anyone peek at this and tell me where my pattern matching is going wrong? http://codepad.org/9A2NvP20
22:19:42 <Saizan> ?type readDouble
22:19:43 <lambdabot> Not in scope: `readDouble'
22:19:48 <Saizan> ?hoogle readDouble
22:19:49 <lambdabot> No results found
22:20:04 <shamster_> readDouble :: ByteString -> Maybe (Double,ByteString)
22:20:29 <shachaf> shamster_: empty is treated as a variable name.
22:20:30 <Saizan> shamster_: you're not handling the Nothing case
22:20:45 <Saizan> also that
22:20:51 <shachaf> also that
22:21:03 <shamster_> shachaf: how do I match on empty, then?
22:21:31 <jedai> shamster_ : With [] is it's a list ?
22:21:49 <shachaf> shamster_: You probably don't need to, depending on the behavior of readDouble and on how you handle the Nothing case.
22:22:03 <shamster_> hmmm
22:22:08 <shachaf> In general you'll have to match on the variable and then explicitly check if it's empty.
22:22:09 <Saizan> shamster_: in general you can use the null predicate 
22:22:51 <shamster_> could you repaste from that link? (i.e. new paste) I'm not quite following the syntax you men
22:22:52 <jedai> The point is that in patterns you can use data constructor or variable names to be binded, you can't use already binded variable name
22:22:56 <shamster_> s/men/mean/
22:23:00 <Saizan> Just (d,b) -> d : if null b then [] else readDoubles b
22:23:33 <shachaf> Also, you should use unfoldr. :-)
22:23:36 <Saizan> you might need to say Data.ByteString.null, to not make it clash with list's null
22:23:53 <shachaf> Actually, don't use unfoldr.
22:23:55 <shamster_> yes, that's the case
22:25:10 <shamster_> I'm running this on a text file with a few lines of double values typed in... but it's only printing out a single value (i.e. [1.4] instead of [1.4,2.3,6.3,....]
22:25:12 <jedai> shamster_: You know you can give an alternative name to Data.ByteString for instance B so that you can write B.null instead of Data.ByteString.null ?
22:25:35 <shamster_> import qualified Data.ByteString as B
22:25:36 <shamster_> ?
22:26:16 <shachaf> shamster_: Yes. This is happening for the reasons we've mentioned.
22:26:21 <jedai> shamster_: Yes, though the qualified is not necessary, if you still want to import the names in the main namespace too
22:27:00 <jedai> as and qualified and (names to import) are independent part of the import clause
22:27:36 <shamster_> http://codepad.org/q8Z5Syy2
22:27:37 <shachaf> You can also import qualified Data.ByteString as B; import Data.ByteString (important, value)
22:28:36 <shamster_> I can't see why it's not building the list and only spitting out the first double in the file
22:29:35 <jedai> shamster_: think about what's in b after it parse the first double, and I don't think readDouble strip leading spaces
22:29:59 <shamster_> hmmmm
22:38:29 <shamster_> for those keeping score at home: added B.tail to fix the whitespace problem...
22:55:47 <kniu_> @hoogle on
22:55:47 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
22:55:47 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
22:55:47 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
22:56:41 <geheimdienst> kniu_: the one in Data.Function must be the one you're looking for. it's best to understand it in context, i think it's used a lot with sortBy
22:58:15 <shachaf> shamster_: That's rather fragile, for what it's worth.
23:00:39 <kniu_> @pl (\(_, x) _> f x || g x || h x)
23:00:39 <lambdabot> (line 1, column 11):
23:00:39 <lambdabot> unexpected ">"
23:00:39 <lambdabot> expecting pattern or "->"
23:00:45 <kniu_> @pl (\(_, x) -> f x || g x || h x)
23:00:45 <lambdabot> liftM2 (||) f (liftM2 (||) g h) . snd
23:00:57 <kniu_> hm
23:01:07 <kniu_> Not worth it.
23:03:40 <suitifiable> hey
23:03:46 <suitifiable> do you guys smell your own farts?
23:03:47 <suitifiable> i do
23:06:23 <dmwit> That joke is a bit off, suitifiable.
23:06:38 <Axman6> you're an op right?
23:07:07 <dmwit> don't think so
23:08:25 <dmwit> ChanServ says no. =P
23:08:43 * shachaf gets all nostalgic looking at at chanserv's op list.
23:09:17 --- mode: ChanServ set +o Heffalump
23:09:52 --- kick: suitifiable was kicked by Heffalump (please don't troll)
23:10:02 --- mode: Heffalump set -o Heffalump
23:16:08 <juhp> how can I "invite" lambdabot to a channel?
23:16:45 <Jafet> Bait her with candy
23:16:54 <juhp> haha
23:17:07 <Jafet> I believe Cale operates lambdabot.
23:17:25 <juhp> thanks
23:19:38 <juhp> mm what's the difference between @tell and @ask?
23:19:48 <juhp> alias?
23:20:24 <shachaf> One is for telling, the other is for asking.
23:20:36 <juhp> ok...
23:20:51 <shachaf> > nÐµxt
23:20:52 <lambdabot>   Another satisfied customer!
23:21:00 <juhp> not really
23:21:14 * shachaf just picked the habit up from dmwit.
23:21:16 <juhp> still doesn't tell what is different about them
23:21:19 <shachaf> @version
23:21:19 <lambdabot> lambdabot 4.2.2.1
23:21:19 <lambdabot> darcs get http://code.haskell.org/lambdabot
23:21:27 <gracenotes> ~~ haddock Text.Printf.printf
23:21:39 <juhp> anyway...
23:23:16 <shachaf> There's some difference, but I don't think anything noticeable.
23:24:24 <shachaf> juhp: For one of them it says "<nick> said" and for the other "<nick> asked".
23:24:31 <shachaf> juhp: Nothing beyond that, really.
23:24:38 <juhp> shachaf: cool thanks!
23:25:10 <shachaf> juhp: See http://code.haskell.org/lambdabot/Plugin/Tell.hs
23:25:21 <juhp> thanks
23:39:22 <co_dh> greeting , what's the meaning of this line of code? 
23:39:23 <co_dh> type STRep s a = State# s -> (# State# s, a #)
23:40:03 <co_dh> what is the name of # here ? so I can google myself? 
23:40:17 <Zao> magichash?
23:40:31 <co_dh> kidding?
23:40:45 <Zao> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html , hrm, not quite right.
23:41:02 <Zao> Related though.
23:41:11 <Zao> http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html#glasgow-unboxed
23:41:19 <Zao> co_dh: There you go, unboxed types and unboxed tuples.
23:41:21 <gracenotes> there are two parts. the (# a, b #) bit, and the State# bit
23:41:37 <glguy> co_dh: the extension you turn on is actually "MagicHash"
23:41:57 <gracenotes> both without the usual boxes
23:42:03 <co_dh> thanks everybody . 
