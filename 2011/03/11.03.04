01:05:22 <wagle> where would one find the source for http://hackage.haskell.org/packages/archive/xhtml/3000.2.0.1/doc/html/Text-XHtml-Transitional.html?  
01:14:33 <luite> wagle: you can click on the source links, if you just want to view the source, otherwise use  cabal unpack xhtml-3000.2.0.1
01:15:50 * wagle is blind
01:17:10 <edsko_> is it possible to impose qualifiers on associated type synonyms?
01:17:26 <edsko_> for instance, if I have a class of multidimensional keys
01:17:26 <edsko_> class MultiKey key where type Coordinate    dimen :: key -> Int proj  :: Int -> key -> Coordinate
01:17:43 <edsko_> can I require that I only want 'Coordinate' types that satisfy Ord ?
01:18:03 <wagle> luite: thanks!
01:21:37 <kosmikus> edsko_: I think you can add a superclass constraint (Ord (Coordiate key)) to the class
01:22:05 <kosmikus> edsko_: Coordinate should have a type argument in your code
01:23:37 <faanbj> @type mapM_
01:23:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
01:24:11 <edsko_> @koskimus: Ah. I didn't think that Coordinate would be inscope in the definition of the class
01:24:11 <lambdabot> Unknown command, try @list
01:24:15 <edsko_> this works:
01:24:18 <edsko_> class Ord Coordinate => MultiKey key where type Coordinate    dimen :: key -> Int proj  :: Int -> key -> Coordinate
01:24:28 <edsko_> which is slgihtly weird, as it seems Coordiante should not be in scope
01:24:33 <edsko_> (requires -XFlexibleContexts)
01:24:38 <edsko_> thanks!
01:25:29 <kosmikus> edsko_: I still don't see how you can have an "associated" type synoynm that doesn't depend on the class?
01:26:47 <kosmikus> edsko_: and of course it should be in scope. everything can be mutually recursive in Haskell.
01:27:01 <kosmikus> edsko_: it's not Agda or Coq ;)
01:27:06 <edsko_> :)
01:27:17 <edsko_> yeah, maybe I have used both of those too often :)
01:27:31 <edsko_> I guess I kinda see 'type' as a binder
01:28:49 <phr_> does anyone know if scheme has something like foldl built-in?
01:29:46 <alex404> What's the easiest way to load a function at runtime, e.g. a la read?
01:30:07 <alex404> From a text file, as well
01:30:39 <alpounet> hs-plugins, maybe ?
01:30:40 <Bynbo7> I'd guess using plugins. possibly mueval
01:31:05 <edsko_> @kosmikus: Ah, now I see why you are asking for a type argument
01:31:05 <lambdabot> Unknown command, try @list
01:31:06 <Jafet> Heh, "a la read"
01:31:31 <alex404> Cool, I have a look
01:31:37 <kosmikus> edsko_: aha :)
01:31:42 <edsko_> I thought there sort of was an implicit argument already (just like I can give a different implementation of 'dimen' for every class, I thought I could give a different implementation of 'Coordinate'
01:31:42 <merijn> alex404: Check out http://www.cse.unsw.edu.au/~dons/papers/SC05.html ?
01:31:45 <edsko_> seems I cannot
01:31:58 <merijn> alex404: It's about dynamic code loading (such as plugins, etc)
01:32:15 <kosmikus> edsko_: no
01:32:21 <alex404> merijn: Neat. Thanks.
01:32:24 <edsko_> seems inconsistent, no?
01:33:04 <kosmikus> edsko_: perhaps.
01:33:20 <kosmikus> edsko_: but associated types are really only syntactic sugar for type families these days.
01:34:43 <edsko_> kosmikus: I haven't really used either. Should I use type families instead?
01:34:44 <kosmikus> edsko_: and I guess omitting the type arguments would require something like overloaded kinds then
01:34:55 <edsko_> yes, that would make sense.
01:35:18 <kosmikus> edsko_: no, it doesn't really matter much. you should use what you think it clearer.
01:35:41 <kosmikus> edsko_: if the type only makes sense together with the methods, then leaving it in the class is fine, I think.
01:36:08 <edsko_> kosmikus: ok, I think I'll stick to that for now so
01:48:10 <illissius`> is there any higher-rank container type which can't have () as its element type?
01:48:31 <bwright> Hello :)
01:48:51 <illissius`> (so far I've found UArray which doesn't have an IArray instance in that case, but that seems like it would be trivial to rectify)
01:51:04 <mjrosenb> is there any way to recover from a pattern binding failure in a do block?
01:52:17 <Jafet> What does "recover from" involve?
01:52:36 <sipa> :t fail
01:52:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
01:52:45 <mjrosenb> i guess i am thinking of somethnig like using `mplus` for operations that return mzero
01:53:06 * mjrosenb needs to remember to use mplus more
01:55:24 <mjrosenb> i guess what i really want is to be able to have replace foo <- bar; case foo of ... with a single line
01:55:42 <mjrosenb> s/have//
01:56:42 <Jafet> bar >>= \foo -> case foo of
01:57:09 <quicksilver> mjrosenb: yes, mplus is probably a way to 'recover from' pattern bind failure
01:57:27 * sipa always wondered why there is no syntactic sugar for (\x -> case x of ...)
01:58:16 <Jafet> I thought someone proposed "case of ..."
01:58:31 <illissius`> sipa: as usual, there was a proposal, and then people couldn't agree on the syntax
01:58:53 * sipa proposes "case of ..."
01:59:01 <sipa> oh
01:59:05 <illissius`> that was the original proposal
01:59:10 <sipa> Jafet: didn't see that :)
01:59:34 <illissius`> other people wanted to have a \ in it, \case or \case of, can't remember exactly
01:59:48 <illissius`> other people proposed being able to glue together partial lambdas instead
01:59:58 <illissius`> iirc.
02:00:21 <Jafet> Meanwhile, the bike shed becomes waterlogged.
02:00:24 <sipa> glue partial lambdas together... isn't that what (.) does?
02:00:29 <merijn> The bike shed should be green!
02:00:35 <illissius`> sipa: 'vertically', so to speak
02:00:39 * mjrosenb likes the fact that case expressions are syntatic sugar for lambdas in sml
02:00:57 <mjrosenb> e.g. lambdas have the full power of case statements.
02:01:03 <illissius`> (\(Left a) -> foo) `glue` (\(Right b) -> bar)
02:01:45 <sipa> oh i see
02:01:46 <mjrosenb> illissius`: i have heard that row polymorphism can easily do magic like that
02:02:10 <mjrosenb> illissius`: however, i cannot find either of the really awesome papers on row polymorphisms.
02:02:31 <illissius`> sipa: there was also disagreement about whether it should be possible to 'partially apply' if-then-else in the same way
02:02:52 <illissius`> and whether to remove if-then-else completely in favor of a function
02:02:53 <illissius`> etc.
02:03:01 <Jafet> When haskell gets row polymorphism, syntax will be the least of concerns
02:03:57 <illissius`> mjrosenb: if you find it I'll download it to my directory containing papers-I'll-get-around-to-reading-once-I-no-longer-have-more-important-things-to-do-and-have-bought-a-Kindle-or-suchlike :)
02:04:43 <quicksilver> I wonder how a Kindle copes with the skinny fonts and maths notation often found in LaTeX paper
02:04:57 <quicksilver> they generally need high resolution to look nice since they were designed for print
02:05:21 * mjrosenb would sort of like if-then-else to take an overloaded boolean class
02:06:34 <aristid> quicksilver: the 6 inch kindle is rather small for reading papers anyways
02:06:35 <merijn> quicksilver: The answer is, reasonably well
02:06:51 <merijn> (the 10 inch version that is)
02:06:57 <illissius`> personally I'd like simply 'case of' as the syntax as well, and also the ability to glue lambdas in addition to it (haskell is very much a TMTOWTDI language)... but dunno about ifthenelse
02:07:53 <quicksilver> glued lambdas is semantically unsound (I think)
02:07:59 <luite> I used to have an eink reader, but skinny fonts were not ideal imho. they did issue a firmware upgraded that helped a bit, by making the fonts a bit thicker
02:08:00 <quicksilver> it would have to be a syntax thing
02:08:29 <quicksilver> which would make it non-abstractable, no generalisable etc
02:08:47 <merijn> quicksilver: I ordered a Kindle DX yesterday and I've tested a bunch of type theory papers which contain plenty of greek letters and stuff, they look fine on the Kindle's I tested them on at uni here. Paging through a PDF can be somewhat slow (especially the scanned sort from really old papers)
02:08:56 <quicksilver> merijn: *nod*
02:09:31 <luite> I use an ipad now, which is much smoother since it has a more powerful cpu... but the screen resolution is a bit lacking
02:09:46 <merijn> luite: Also, screen glare is a major concern for me
02:09:51 <illissius`> isn't there any way to preprocess/convert PDFs to make them more suitable for reading on an ereader? (even a 6 inch one?)
02:09:54 <Jafet> if True t _ = t; if False _ f = f
02:09:57 <illissius`> assuming a PDF of actual text, not scanned images
02:10:06 <Jafet> Unfortunately, if, then, and else are still reserved words
02:10:28 <merijn> I ordered a Kindle because my eyes tend to hurt after spending a day reading papers on screen and I want to be able to read outside in the sun during summer
02:10:30 <mjrosenb> Jafet: what is the issue with row polymorphism?
02:10:53 <merijn> But I think the benefit of portable access to papers outweighs the paging time, I can't keep printing 200 page thesis (what the hell is the plural of thesis?) every week :p
02:11:00 <quicksilver> theses
02:11:06 <Jafet> mjrosenb: nothing, until you try to merge it with all the haskell extensions
02:11:51 <luite> merijn: yeah that's a disadvantage, but I like it much better for technical reading than eink. I might order a small 6" eink for reading outdoors though, for non-technical things
02:11:55 <Jafet> I get the impression that ghc is a sort of meta space leak in that respect
02:12:06 <illissius`> quicksilver: glued lambdas as a not-just-syntax thing would be more or les like having open functions, right?
02:12:12 <illissius`> +s
02:12:59 <luite> merijn: in many situations I find the backlight to be an advantage, for example when reading in bed :)
02:13:00 <quicksilver> I'm not sure.
02:13:11 <quicksilver> I think of open functions as a static thing - they get resolved at compile time.
02:13:33 <quicksilver> having "glue" as a true function (a -> b) -> (a -> b) -> (a -> b) gives you runtime sideways composition
02:13:55 <illissius`> oh
02:13:57 <illissius`> hmm
02:14:21 <quicksilver> of course, it's no problem if you're happy with (a -> Maybe b) -> (a -> Maybe b) -> (a -> Maybe b)
02:14:34 <quicksilver> that's actually just mplus for ReadeT a Maybe
02:14:49 <quicksilver> ('catching' the Nothing 'exception')
02:15:05 <levifikri> Hi, what are technical differences between Lazy ByteString and the Strict one?
02:15:13 <quicksilver> it's when you try to catch real _|_s it starts to look strange to me.
02:15:38 <illissius`> quicksilver: oh, right
02:16:33 <ion> One is lazy and the other is strict.
02:16:42 <levifikri> I need to read and decode data with the same type from two files. And then do some calculation on those data. Then, encode the data into a file.
02:16:45 <Jafet> If   f A = foo; g B = bar;   is rewritten as   f _ A = foo; f n _ = n; g _ B = bar; g n _ = n;   then   f `glue` g   becomes   f $ g $ undefined
02:16:57 <levifikri> I tried Lazy ByteString, but it takes forever to finish
02:17:07 <illissius`> quicksilver: so glueing would basically have to involve spooning :)
02:17:10 <levifikri> althought the files size are only 200 KB each
02:17:21 <mjrosenb> illissius`: http://people.cs.uchicago.edu/~blume/papers/icfp06.pdf
02:17:24 <levifikri> seems the memory usage is too hight
02:17:32 <quicksilver> illissius`: well, implementing it in current haskell would, yes. We were talking about a language extension though I assume.
02:17:32 <mjrosenb> illissius`: yay logs!
02:17:50 <illissius`> quicksilver: well yes, but you said it would have semantic problems
02:17:56 <illissius`> were you referring to something else?
02:17:59 <quicksilver> illissius`: however I was saying that I'm not sure teh language extension would be sound if it made 'glue' into a proper first class function.
02:18:01 <illissius`> mjrosenb: thanks!
02:18:06 <quicksilver> I might be wrong anyway :)
02:18:28 <illissius`> quicksilver: yeah I'm not sure, trying to think it through
02:19:56 <levifikri> so, can I tried using ByteString, but make it strict explicitly?
02:20:06 <Jafet> quicksilver: are functions that have strange semantics, like seq, "proper first class"?
02:20:54 <illissius`> quicksilver: I think it's that if you 'replaced' all exceptions from the first function with values from the second it'd basically be try/catch in pure code which should be impossible; if you only did it for failed pattern matches then you'd be distinguishing between different kinds of bottoms in pure code, which should also be impossible (even in the first case you're distinguishing between exceptions and nonterminations)
02:22:02 <Jafet> Hm, why should that be impossible?
02:22:25 <illissius`> which part?
02:23:00 <Jafet> Giving the semantics of "redirects failed pattern matches" to a function.
02:23:51 <Jafet> That exception arises from pure evaluation, anyway, so removing it should preserve soundness.
02:24:24 <quicksilver> Jafet: yes, they're first class.
02:24:44 <quicksilver> Jafet: you can pass 'seq' to map, you can bind it to a name, you can partially apply it.
02:24:55 <quicksilver> it's a weird primitive but - allegedly - it doesn't break the semantics.
02:25:19 <quicksilver> glue would be another weird primitive and my concern is that it would be breaking.
02:25:29 <quicksilver> illissius`: right.
02:26:20 <Jafet> Well, I can't see why glue wouldn't be sound, even if it has to be implemented impurely.
02:27:17 <quicksilver> I fear it might break monotonicity, for example.
02:27:24 <illissius`> you'd be able to write a function Void -> a which doesn't always return the same value
02:27:36 <illissius`> one thing if the Void 'value' is a pattern match failure, something else otherwise
02:27:38 <illissius`> I think
02:28:28 <illissius`> (but haven't thought it through 100%)
02:29:05 <Jafet> @src Void
02:29:05 <illissius`> quicksilver: would there be any conceptual problems with compile time open functions (that you know of), or is it just a no one's bothered to try implementing them yet thing?
02:29:05 <lambdabot> Source not found. My pet ferret can type better than you!
02:29:35 <illissius`> Jafet: {-# LANGUAGE EmptyDataDecls #-} data Void :: *
02:29:40 <quicksilver> my understand is that people have tried to imlpement them
02:30:03 <quicksilver> e.g. http://lambda-the-ultimate.org/node/1453
02:30:07 <quicksilver> I haven't followed closely though
02:30:13 <illissius`> or newtype Void = Void Void, or {-# LANGUAGE Rank2Types #-} type Void = forall a. a
02:30:25 <Jafet> Well, you can't ever have a pattern match success on that Void, can you
02:30:29 <illissius`> (personally I like the last one the best :)
02:30:29 <Jafet> Other than the trivial one
02:31:37 <Jafet> So the pattern can only be x -> foo, which would always succeed. I'm afraid I still don't see it
02:31:57 <illissius`> Jafet: bah, you're forcing me to think it through :)
02:32:12 <illissius`> I was hoping someone else would do it for me and figure out whether I'm right
02:33:38 <Jafet> Sorry I can't do that, because I think you're wrong
02:39:21 <rostayob> is there any good tool to perform text search over a large number of large file (~0.5 MB each)?
02:40:25 <luite> grep?
02:40:30 <jkff> Hey folks. Is there a package for drawing graphics, which does NOT require cairo or gtk? (desirably written in Haskell fully) They're non-trivial to install, which can be very frustrating for the users of e.g. my software, so I'd like to give it a fully platform-independent backend.
02:41:08 <Jafet> There's SDL
02:41:11 <rostayob> luite: how don't know how efficient would that be
02:41:16 <Jafet> Non-trivial to use, though
02:41:30 <luite> jkff: there's wumpus, that can ouput svg or postscript
02:41:31 <rostayob> Jafet: actually SDL is the easiest graphics lib
02:41:39 <luite> without extra dependencies
02:42:00 <rostayob> but if you just have to draw shapes...
02:42:15 <jkff> Thanks luite! That's what I was looking for. Are there any others, in case wumpus fails to satisfy my requirements for some reason?
02:43:10 <kaf3ii> can anyone show me example usage of the Typeable class?
02:44:46 <luite> jkff: well there's Diagrams, the latest version of which has pluggable backends (not on hackage yet), the only backend in the repository is a cairo one, but you could make your own if you want to do some hacking :)
02:45:06 <jkff> Thanks again :)
02:46:25 <luite> but that version is quite unfinished, so it's best for if you want to hack on it, and help with the design, rather than looking for a finished complete library 
02:48:07 <jkff> Looks like the same applies to wumpus, too
02:50:34 <luite> jkff: yeah it's not completely finished but according to the author, the low level api should be fairly stable now
02:50:44 <luite> the higher level drawing api is still changing
02:50:45 <illissius`> Jafet: yeah, maybe you're right. best I could do was mkVoid1, mkVoid2 :: Void; mkVoid1 = throw PatternMatchException; mkVoid2 = throw SomeOtherException; fromVoid :: Void -> Bool; fromVoid = (\!v -> False) `glue` (\_ -> True) which returns True on a pattern-match-failure Void and forwards the bottom otherwise
02:50:53 <illissius`> maybe that's still troublesome, i dunno.
02:51:47 <jkff> luite: However the idea looks very cool - I think it would definitely make sense to give the Chart package a new backend. I think I'll contact the author of wumpus, of Chart and myself :)
02:52:25 <HugoDaniel> hi
02:52:40 <HugoDaniel> how do i transform a [Either a b] into a Either a [b] ?
02:54:00 <dibblego> sequence
02:54:02 <luite> jkff: I want to write a wumpus-core backend for diagrams, mainly to get more control over the svg output (in order to add javascript to the generated images, for interactive web graphics)
02:54:03 <alpounet> @type sequence
02:54:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:54:15 <alpounet> here, 'm' is 'Either a'
02:55:00 <dibblego> HugoDaniel: sequence
02:55:24 <HugoDaniel> oh
02:55:35 <aristid> you need mtl 2.0 to get rid of the Error constraint
02:55:56 <aristid> :t sequence :: [Either a b] -> Either a [b]
02:55:57 <lambdabot>     Overlapping instances for Monad (Either a)
02:55:57 <lambdabot>       arising from a use of `sequence' at <interactive>:1:0-7
02:55:57 <lambdabot>     Matching instances:
02:56:04 <aristid> bah.
02:56:11 <dibblego> I generally don't use Either, for this reason
02:56:24 <HugoDaniel> i was thinking about using mconcat or something
02:56:25 <aristid> dibblego: why? it's solved now. the Error constraint is gone.
02:56:45 <aristid> :t mconcat
02:56:47 <lambdabot> forall a. (Monoid a) => [a] -> a
02:56:51 <dibblego> because there is still a problem with e.g. having dependency on mtl 1.1 and mtl 2
02:56:53 <aristid> :t msum
02:56:54 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
02:57:11 <aristid> dibblego: well, right, mixing mtl 1 and 2 is bad.
02:57:31 <aristid> dibblego: but that's bad even if you don't use Either
02:57:39 <dibblego> yes
02:58:02 <dibblego> I should say, I don't use the Either monad, since I don't want the burden of deciding where to get it from
02:58:29 <aristid> dibblego: i think with ghc 7 it's actually in base
02:59:02 <dibblego> yeah, that's why category-extras won't compile iirc
02:59:52 <aristid> but that means that as soon as you use ghc 7, there is only one possible instance
03:00:17 <dibblego> yeah, that will be nice
03:00:42 <merijn> Haskell Platform with GHC7 in a few days :>
03:02:53 <HugoDaniel> :)
03:03:18 <HugoDaniel> haskell platform 2011, this feels like we are living in space
03:03:18 <aristid> ah, there is the definition of the new Either instance: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad-Instances.html
03:03:41 <HugoDaniel> future, flying cars, aliens, and haskell platform 2011
03:03:50 <aristid> HugoDaniel: not flying. but self-driving.
03:04:03 <alpounet> let's say both
03:04:14 <HugoDaniel> self-driving-congestion-avoiding cars
03:04:19 <vegai> we have cars with billions of lines of java code, actually :-S
03:04:33 <HugoDaniel> aw :/
03:04:42 <merijn> vegai: Way to be a downer...
03:04:56 <HugoDaniel> can't wait for that NullPointExceptions 
03:05:13 <HugoDaniel> or worse, StackOverflowException 
03:05:16 <vegai> http://spectrum.ieee.org/green-tech/advanced-cars/this-car-runs-on-code
03:05:43 <vegai> oops, I mean hundreds of millions and it being Java was just a guess :P
03:05:53 <vegai> still seems a bit crazy
03:06:15 <nlogax> Language.Haskell.Interpreter is mad at me for not having a package db at the standard location, how do i tell it where it is?
03:07:03 <HugoDaniel> i would only go in a self-driving car that ran haskell code without any kind of pattern matching
03:07:33 <vegai> the first comment on that page by vikash singh :-S
03:08:43 * vegai goes back to preparing hp2011 for arch so as to keep sanity...
03:10:24 <aristid> HugoDaniel: clearly there must be no partial functions in a self-driving car
03:10:30 <McManiaC> http://n-sch.de/hdocs/ghc/html/users_guide/syntax-extns.html#monad-comprehensions <- any native english speaking persons who could take a look if thats correct? anyone else with an opinion whether/what is missing there? :)
03:11:32 <merijn> HugoDaniel: And then suddenly! out of memory exception :>
03:12:43 <HugoDaniel> the greatest thing about monads is that they fail
03:13:19 <quicksilver> McManiaC: that bindings desugar is srong
03:13:20 <quicksilver> wrong.
03:13:58 <McManiaC> wrong?
03:14:27 <quicksilver> yes. List comp bindings desugar the same way as do notation bindings
03:14:39 <quicksilver> which is not as simple as your >>= suggests
03:14:48 <quicksilver> and I would assume monad comps are the same ;)
03:15:11 <McManiaC> well
03:15:39 <McManiaC> its simplified, but in general its correct
03:15:40 <quicksilver> > [ x | Just x <- [Nothing,Just 1,Nothing,Just 2]]
03:15:41 <lambdabot>   [1,2]
03:16:25 <quicksilver> [Nothing,Just 1,Nothing,Just 2] >>= \(Just x) -> return x
03:16:31 <quicksilver> > [Nothing,Just 1,Nothing,Just 2] >>= \(Just x) -> return x
03:16:31 <lambdabot>   *Exception: <interactive>:3:36-56: Non-exhaustive patterns in lambda
03:17:11 <aristid> i wonder if operational transformations work on structured data
03:17:42 <quicksilver> McManiaC: did you consider giving do notation equivalents?
03:17:53 <quicksilver> that might be more familiar to the target reader?
03:18:01 <quicksilver> (instead of desugaring 'all the way' to the basic combinators)
03:18:07 <McManiaC> hm
03:18:38 <quicksilver> and it would avoid my complaint, since do notation does that bit automatically.
03:19:02 <quicksilver> > do { Just x <- [Nothing,Just 1,Nothing,Just 2]; return x }
03:19:03 <lambdabot>   [1,2]
03:19:24 <McManiaC> quicksilver: but my example is in fact correct
03:19:25 <McManiaC> :D
03:19:45 <McManiaC> since the "x" pattern just cant fail
03:20:21 <frank00> Quick q: I have a list (let's say, [1,4,5], and I want to perform an action on every /pair/ of that list (1,4 1,5 4,5) and get a list as a result (so if the action is * the output list would be [4, 5, 20]. I feel it's not difficult write a funtion that does so, but is there a standard alternative (I don't want to reinvent the wheel)
03:20:43 <McManiaC> but hmm, I had an earlier version with do notation, might just switch back again
03:20:54 <quicksilver> McManiaC: yes, it is :)
03:20:58 <FauxFaux> @hoogle [t] -> [(t,t)]
03:20:59 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
03:20:59 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
03:20:59 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
03:21:00 <quicksilver> McManiaC: but it doesn't generalise.
03:21:18 <quicksilver> McManiaC: your example is right but the algorithm it appears to imply by generalisation is not ;)
03:23:54 <McManiaC> yep
03:25:39 <frank00> FauxFaux: was that an aswer to me?
03:25:57 * hackagebot pgm 0.1.2 - Pure Haskell implementation of PGM image format  http://hackage.haskell.org/package/pgm-0.1.2 (FrederickRoss)
03:28:12 <McManiaC> quicksilver: updated
03:28:53 <quicksilver> McManiaC: I certainly prefer that form.
03:28:58 <McManiaC> kk
03:29:01 <McManiaC> :)
03:30:34 <HugoDaniel> haskell pure implementations are usually so slow :(
03:30:39 <HugoDaniel> it shouldn't be like this...
03:31:10 <McManiaC> *haskells naive implemetations are usually slow
03:31:15 <HugoDaniel> oh
03:31:17 <McManiaC> fixed ;P
03:31:39 <HugoDaniel> most of the time i profile and then replace the pure functions with equivalent pure C functions :/
03:31:51 <HugoDaniel> thats as far as my haskell optimization skill goes
03:32:03 <Cale> It's possible to write pure code which is quite fast.
03:32:43 <Cale> But understanding the performance of pure code takes a bit of getting used to.
03:33:16 <HugoDaniel> most of the time i can't understand lazyness and some other times i can't understand stack growth
03:33:30 <HugoDaniel> when i litter my code with bang patterns it usually goes slower
03:33:34 <Cale> right
03:33:49 <Cale> Do you know how lazy evaluation works?
03:33:54 <HugoDaniel> ...which i think says a lot about the way i am reasoning :/
03:33:59 <Cale> (that it's outermost-first evaluation + sharing)
03:34:06 <HugoDaniel> no
03:34:09 <Cale> okay
03:34:43 <HugoDaniel> i should read up on that
03:34:53 <Cale> So under strict evaluation, to evaluate a function applied to some arguments, you evaluate the arguments, then substitute the values of those arguments into the body of the function where the corresponding parameters occur.
03:35:07 <HugoDaniel> hmm
03:35:14 <HugoDaniel> i know that yes
03:35:35 <HugoDaniel> i lazy evaluation there is only a reference being passed around, right ?
03:35:39 <Cale> That is, you evaluate the innermost terms first
03:35:51 <HugoDaniel> yes
03:35:54 <HugoDaniel> i see
03:35:58 <Cale> Under outermost-first evaluation, you substitute first, and only evaluate parameters when you reach them
03:36:02 <HugoDaniel> sin(cos(tan(x))) 
03:36:05 <Cale> yeah
03:36:49 <Cale> So strict evaluation would start with x there, and then tan, while lazy or outermost-first evaluation would start with sin
03:37:25 <HugoDaniel> ah, i see
03:37:28 <Cale> passing to sin the value cos(tan(x)), not yet evaluated
03:38:22 <Cale> only if sin were to pattern match on the value (or otherwise demand it by using a strict primitive function), would cos(tan(x)) be evaluated
03:38:59 * hackagebot hxt 9.1.1 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.1.1 (UweSchmidt)
03:39:00 <HugoDaniel> ah! that explains a lot :)
03:39:00 <Cale> This is a bit of a funny example, since we don't normally think of sin as pattern matching on its floating point argument, but you could imagine it as being a gigantic case discrimination :P
03:39:09 <merijn> Which is why you can do things like call functions on infinite lists, since said list does not exist yet
03:39:51 <Cale> HugoDaniel: There's a bit of an extra detail too...
03:39:59 <Cale> HugoDaniel: if we have a function like  double x = x + x
03:40:00 * hackagebot hxt-http 9.1.1 - Interface to native Haskell HTTP package HTTP  http://hackage.haskell.org/package/hxt-http-9.1.1 (UweSchmidt)
03:40:09 <Cale> where the parameter to the function occurs more than once in the body
03:40:35 <Cale> then any evaluation we do to that argument to the function will be shared between the copies in the body
03:41:00 * hackagebot hxt-cache 9.0.1 - Cache for HXT XML Documents and other binary data  http://hackage.haskell.org/package/hxt-cache-9.0.1 (UweSchmidt)
03:41:02 <HugoDaniel> hmm
03:41:13 <Cale> So instead of:
03:41:18 <Cale> double (double 5)
03:41:25 <Cale> --> double 5 + double 5
03:41:32 <Cale> --> (5 + 5) + double 5
03:41:36 <Cale> --> 10 + double 5
03:41:39 <Cale> --> 10 + (5 + 5)
03:41:41 <Cale> --> 10 + 10
03:41:44 <Cale> --> 20
03:41:49 <Cale> we have something more like
03:41:53 <Cale> double (double 5)
03:42:06 <Cale> --> let x = double 5 in x + x -- note that this is still outermost-first
03:42:14 <Cale> --> let x = 5 + 5 in x + x
03:42:19 <Cale> --> let x = 10 in x + x
03:42:30 <Cale> --> 20
03:42:52 <Cale> I'm using the let syntax here to represent the sharing.
03:43:05 <Cale> In memory, it would be two pointers pointing to the same thing
03:43:07 <HugoDaniel> allright
03:43:46 <Cale> So this saves us from wastefully evaluating double 5 twice
03:43:46 <HugoDaniel> so the more i use the same pattern, the better
03:44:17 <HugoDaniel> the more patterns i share and reuse, the better
03:44:26 <Cale> Well, usually :)
03:44:32 <HugoDaniel> :)
03:44:40 <Cale> Sometimes this can bite you in terms of memory usage
03:45:01 * hackagebot ascii 0.0.0 - Type-safe, bytestring-based ASCII values.  http://hackage.haskell.org/package/ascii-0.0.0 (MichaelSnoyman)
03:45:30 <HugoDaniel> i see yes
03:45:36 <Cale> It's somewhat rare, but if the thing being duplicated is cheap to compute, but very expensive in terms of space, you might not want the sharing to happen.
03:45:40 <Jafet> You might want to tell bm to use that notation for stepeval
03:45:51 <Jafet> ...if he's still working on it
03:46:12 <Jafet> Looks like the online demo hasn't changed, at least
03:46:57 <Cale> HugoDaniel: So, that's the difference between lazy evaluation and plain outermost-first evaluation, and that's almost all there is to it -- everything else is an implementation detail
03:47:04 <HugoDaniel> :)
03:47:05 <HugoDaniel> ahah
03:47:06 <HugoDaniel> cool
03:47:12 <HugoDaniel> thanks for the teachings
03:47:26 <harlekin> I'm trying to render a bitmap font using GLUT's renderString routine. However, it appears to only be rendered if RasterPosition is set to (0, 0). The slightest change to the coordinates makes the text disappear. Anyone experienced this?
03:47:27 <Cale> Note that this evaluation sharing of bound variables isn't the same as function memoisation.
03:47:45 <Cale> Lots of people get the idea that if you write f 5 + f 5, it'll only compute f 5 once
03:47:57 <HugoDaniel> hmm
03:48:02 <Cale> but the optimisation only applies to single variables
03:48:19 <sipa> but if i write let x = f 5 in x+x, it is only computed once, right?
03:48:23 <Cale> right
03:49:01 <HugoDaniel> :)
03:49:05 <HugoDaniel> allright! :)
03:49:56 <Cale> So that should help get you started trying to understand how things run. It still takes quite a while before it's really obvious what the performance of some piece of code will be like, but if it's small enough, you can at least do it by hand now. :)
03:53:25 <tawe> :t map map [id]
03:53:26 <lambdabot> forall a. [[a] -> [a]]
03:56:03 * hackagebot warp 0.3.2.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-0.3.2.3 (MichaelSnoyman)
03:56:05 * hackagebot hamlet 0.7.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.7.2 (MichaelSnoyman)
03:57:16 <applicative> > map map [id] <*> [ [1] ]
03:57:17 <lambdabot>   [[1]]
03:58:01 <applicative> > map map [id, (*1)] <*> [ [1] ]
03:58:02 <lambdabot>   [[1],[1]]
04:22:05 <hvr> Prelude Data.Maybe> fromJust (error "got nothing") $ Just 3
04:22:05 <hvr> *** Exception: got nothing
04:22:23 <hvr> why is fromJust strict in its default?
04:23:11 <hvr> nevermind
04:23:12 <hvr> doh
04:23:26 <opqdonut> :t (fromJust,maybe)
04:23:26 <lambdabot> forall a b a1. (Maybe a -> a, b -> (a1 -> b) -> Maybe a1 -> b)
04:24:30 * hvr confused fromJust with fromMaybe
04:24:46 <merijn> :t fromMaybe
04:24:47 <lambdabot> forall a. a -> Maybe a -> a
04:24:53 <merijn> :t maybe
04:24:53 <Jafet> The bottom of many colours
04:24:53 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:26:17 <rtharper> How many LANGUAGE extensions is too many for one file...
04:27:06 <_mpu> why is Window type absatracted from Layouts in xmonad ?
04:28:31 <Jafet> > (undefined :: *) undefined
04:28:32 <lambdabot>   <no location info>: parse error on input `*'
04:28:54 <McManiaC> rtharper: theres a limited number of extension, so if you take that number as N, the answer is probably N+1
04:28:56 <_mpu> :t ( <*> )
04:28:57 <Jafet> (Is there a way to express that)
04:28:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:28:57 <McManiaC> :>
04:29:21 <rtharper> McManiaC: I find your answer pleasing 
04:29:31 <rtharper> McManiaC: How should I reward you?
04:29:44 <McManiaC> cash please
04:29:45 <McManiaC> :D
04:29:56 <merijn> rtharper: I'd say when you're code lines is less then twice the number extension/pragma lines :p
04:30:09 <rtharper> merijn: also acceptable
04:30:27 <Jafet> Too many just means that you should be using -fglasgow-exts
04:30:54 <Eliel> isn't that the flag that is getting obsoleted in the new ghc?
04:30:56 <illissius`> it means they should get a bunch of them into the language definition already >_>
04:31:01 <Jafet> Sadly, yes.
04:31:09 <McManiaC> I thought that is depreciated, Jafet 
04:31:45 <McManiaC> <- slow typer :(
04:32:22 <Jafet> Once it's deprecated, it will be more appreciated!
04:32:50 <leino> hello all, I have a question about debugging in ghci, I hope this is the place to ask
04:33:56 <leino> my problem is that when I set some breakpoints and then run some expression to be debugged, when the expression has finished evaluating and the ghci prompt returns, if I run the expression again it doesnt stop on breakpoints
04:34:13 <leino> even though :show breaks shows my original breakpoint
04:34:16 <leino> hope that makes sense
04:37:38 <Jafet> Perhaps part of the expression wasn't evaluated the second time
04:39:04 <leino> not sure how to determine that
04:39:14 <leino> I am following the qsort debugging example at: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
04:39:18 * hackagebot blaze-from-html 0.3.1.0 - Tool to convert HTML to BlazeHtml code.  http://hackage.haskell.org/package/blaze-from-html-0.3.1.0 (JasperVanDerJeugt)
04:39:41 <leino> I load qsort.hs, set the breakpoint on line 2, run main and it works
04:39:56 <leino> if I run main again, it doesnt break, it just prints the result
04:43:24 <Jafet> Because the expression qsort [...] has already been evaluated
04:43:48 <leino> ok I think I understand
04:44:32 <leino> but if I would like to debug again, how do I do that without exiting ghci and loading the code and setting breakpoints all over again?
04:44:32 <Jafet> If you defined mymain xs = print $ qsort xs and used that, it would qsort xs each time
04:46:35 <leino> Jafet: indeed
04:46:47 <leino> thanks
04:46:47 <Jafet> Sorry my telepathy was on
04:47:06 <leino> huh?
04:52:51 <hpaste> apfelmus pasted "software stack puzzle (annotation)"  http://hpaste.org/44503
04:56:27 <Jafet> Heh
04:57:24 <Jafet> What exactly is software stack puzzle?
04:58:03 <illissius`> Jafet: see haskell-cafe
05:02:46 <taweee> @src foldl
05:02:46 <lambdabot> foldl f z []     = z
05:02:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:03:35 <taweee> @src foldr
05:03:35 <lambdabot> foldr f z []     = z
05:03:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:03:49 <Jafet> Hrm
05:04:17 <lanjiao> is there sth like unix/expect in Haskell?
05:04:26 <Jafet> I've thought about class Function, which makes any instance of it callable
05:04:56 <confound> what would you do with that?
05:05:05 <Jafet> So you can make serializable/inspectable data types and use them as functions
05:05:10 <Jafet> (re: software stack)
05:05:24 <confound> o
05:05:41 <confound> makes sense
05:05:54 <Jafet> Not sure if it conflicts with any other haskell semantics
05:13:41 <manateeUser> Good evening. :)
05:18:32 <ManateeLazyCat> Hi all. :)
05:19:15 <rribeiro> @src transpose
05:19:15 <lambdabot> transpose []             = []
05:19:15 <lambdabot> transpose ([]   : xss)   = transpose xss
05:19:15 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
05:25:31 <lionelj> what is the easiest way to write a fucntion which does that: example you give it: dog it returns ddoogg ? help please
05:26:30 <mm_freak_> > concatMap (\x -> [x,x]) "abc"
05:26:31 <lambdabot>   "aabbcc"
05:27:07 <mm_freak_> > concatMap (replicate 2) "abc"
05:27:08 <lambdabot>   "aabbcc"
05:27:10 <zygoloid> > [x | x <- "abc", _ <- [0,1]]
05:27:11 <lambdabot>   "aabbcc"
05:27:18 <lionelj> mm_freak_: is this considered advanced haskell? can it be done without concatMap? (thx)
05:27:28 <mm_freak_> lionelj: it's not
05:27:33 <mm_freak_> concatMap f = concat . map f
05:27:42 <Jafet> But that would amount to doing your homework
05:29:51 <zygoloid> > foldr(join(liftA2 (.))(:))mempty "abc"
05:29:53 <lambdabot>   "aabbcc"
05:30:26 <taweee> > (reverse . tail . reverse) [1,2,3,4,5]
05:30:27 <lionelj> mm_freak_: zygoloid : Jafet thanks guys, no this is not homework.. was just trying to find an easy way of doing it. not a haskell geek yet
05:30:27 <lambdabot>   [1,2,3,4]
05:31:02 <lionelj> zygoloid: thanks
05:31:32 <alpounet> > init [1,2,3,4,5] -- taweee 
05:31:33 <lambdabot>   [1,2,3,4]
05:31:43 <zygoloid> lionelj: if it's not homework, you might like: foldr (\x xs -> x:x:xs) []
05:31:57 <taweee> alpounet :)
05:32:06 <taweee> @src init
05:32:06 <lambdabot> init [x]    = []
05:32:07 <lambdabot> init (x:xs) = x : init xs
05:32:07 <lambdabot> init []     = undefined
05:32:15 <zygoloid> (though i prefer mm_freak's ones)
05:33:22 <Jafet> lionelj: the string "dog" is 'd' followed by "og"
05:33:51 <Jafet> Of course, some solutions here take a higher level approach...
05:33:59 <lionelj> Jafet: yeah
05:36:19 <lionelj> GHCI 7 was released yesterday? (i might be mistaken)
05:39:57 <ManateeLazyCat> Wow, ghc-7.0.2 release!
05:40:06 <ManateeLazyCat> Find time, test it.
05:41:10 <saml> how do you install cabal install with 7.0.2?
05:41:23 <saml> cabal install bootstrap.sh is bad
05:41:34 <pozic> lionelj: l [] = [];l (x:xs) = x:x:l xs
05:41:45 <dcoutts> saml: use the cabal-install-0.10 release and it's bootstrap.sh
05:42:00 <dcoutts> saml: if you find any problems with the bootstrap.sh for the latest release then I'd like to know
05:42:20 <saml> where is 0.10?
05:42:23 <saml> http://haskell.org/cabal/download.html
05:42:31 <merijn> I think the correct steps are 1) wait a few more days 2) download haskell platform with GHC7.0.2 3) Profit!
05:42:35 <saml> it's 0.8.2
05:42:40 <ManateeLazyCat> @package cabal
05:42:41 <lambdabot> http://hackage.haskell.org/package/cabal
05:42:51 <saml> i don't like haskell platform 
05:43:08 <saml> so much bloat.. and it's not unzip && set env variable && profit
05:43:09 <dcoutts> saml: sorry, it's rather new, it's not listed as the default version yet
05:43:12 <ManateeLazyCat> @package cabal-install
05:43:12 <lambdabot> http://hackage.haskell.org/package/cabal-install
05:43:23 <merijn> saml: That's ok, Haskell Platform still loves you
05:43:24 <ManateeLazyCat> saml: ^^^^
05:43:27 <dcoutts> saml: it's also on hackage, or in the release dir on http://haskell.org/cabal/release/
05:43:34 <saml> thanks
05:43:56 <lionelj> someone should update the wiki page then
05:44:05 <saml> yah someone should.. like you lionelj 
05:44:13 <dcoutts> which wiki page, about what?
05:44:15 <merijn> Also, how is Haskell Platform bloated?
05:44:23 <saml> it includes opengl.. etc
05:44:32 <saml> i need 3rd party c libaries to install it
05:44:35 <merijn> Aside from downloading stuff you might not need right now. Disk space is dirt cheap
05:44:50 <adamvh> One man's bloat is this man's batteries
05:45:03 <aristid> merijn: SSDs are not dirt cheap. but certainly cheap enough for haskell platform :D
05:45:06 <saml> i don't see anything wrong with keeping libraries light.. since cabal install is pretty good
05:45:37 <taweee> Any idea why this is wrong?: delete a xs = foldr (\x xss = if x==a then xss else (x:xss)) [] xs
05:45:39 <saml> if i want opengl, i'll install opengl libraries and use cabal install to install haskell binding
05:45:46 <ksf> the point of the platform isn't to keep it light.
05:45:55 <ksf> the point is so that people have a stable api.
05:45:58 <aristid> :t \a xs -> foldr (\x xss = if x==a then xss else (x:xss))
05:46:00 <lambdabot> parse error on input `='
05:46:02 <saml> taweee, maybe you need pattern matching?
05:46:08 <aristid> :t \a xs -> foldr (\x xss -> if x==a then xss else (x:xss))
05:46:09 <lambdabot> forall t a. (Eq a) => a -> t -> [a] -> [a] -> [a]
05:46:11 <saml> delete a [] = []
05:46:14 <lionelj> saml: http://en.wikipedia.org/wiki/Haskell_Platform#Versions
05:46:30 <aristid> taweee: the first error would be = instead of ->
05:46:38 <taweee> damn
05:46:40 <taweee> yes
05:46:52 <dcoutts> lionelj: looks right, there has not been a 2011 release yet
05:46:59 <pozic> Is the Haskell Platform already notable?
05:47:03 <pozic> Since how long? 
05:47:10 <revenantphx> saml: OpenGL libraries are usually installed by default, unless you're on Windows.
05:47:13 <saml> everyone should use haskell platform
05:47:19 <lionelj> dcoutts: alright k, i thought yesterday was a major release
05:47:23 <saml> not on freebsd, ubuntu...
05:47:23 * ksf won't.
05:47:34 <revenantphx> dcoutts: Do you know who manages the staging site for the 2011 release?
05:47:39 <revenantphx> The CSS was terrible, so I redid it.
05:47:41 <saml> but okay. it's just me. haskell platform is awesome
05:47:44 <saml> it's web scale
05:47:51 <revenantphx> and I wanted to give them updated nicer color scheme, etc.
05:48:00 <pozic> Has anyone figure out whether saml is a troll yet? 
05:48:01 <ksf> it's quite impossible to get an X without gl these days, yes.
05:48:09 <ksf> at the very least you get the mesa software renderer.
05:48:21 <dcoutts> revenantphx: dons, take a look at the new one http://code.galois.com/darcs/haskell-platform/download-website/
05:48:28 <dcoutts> revenantphx: that he's preparing
05:48:32 <revenantphx> dcoutts: Yeah, that's the shitty one.
05:48:34 <revenantphx> Here's my redo:
05:48:40 <dcoutts> heh, ok talk to dons
05:48:41 <revenantphx> http://cl.ly/4zqx
05:48:56 <revenantphx> the purple and blue is terrible imo.
05:49:09 <saml> nice purple
05:49:10 <revenantphx> That was just a "thrown together on the airplane type thing though, heh"
05:49:15 <dcoutts> revenantphx: mm, yes I quite like your colours
05:49:21 <revenantphx> Yeah, the purple I picked from my favorite swatches.
05:49:31 <dcoutts> revenantphx: I'm sure dons will be happy to take you suggestions, email him and the platform mailing list
05:49:35 <revenantphx> Kind of a plum-burgundy.
05:49:41 <levifikri> Hi, I have a binary file. I want to add some binary data to the BEGINNING of the file. What is the way to do this?
05:49:41 <dcoutts> haskell-platform@projects.haskell.org
05:49:46 <dcoutts> revenantphx: you should join ^^
05:49:53 <revenantphx> Email to subscribe?
05:49:58 <pozic> How can I simplify the following to get rid of the initial 0 element? H0 : exists _end : list Z, 0 :: ys = (0 :: other) ++ _end
05:50:14 <dcoutts> revenantphx: visit http://projects.haskell.org/cgi-bin/mailman/listinfo/haskell-platform
05:50:21 <revenantphx> down :P
05:50:30 <pozic> simpl in H0. should do that UI wise, IMHO.
05:50:37 <levifikri> I understand that we could use appendFile to add bytes to the end of the file. How about to the beginning of the file?
05:50:47 <dcoutts> revenantphx: oh, hmm
05:51:05 <pozic> levifikri: you can always seek.
05:52:37 <dcoutts> lionelj: oh, you meant a release of ghc, not the HP
05:59:21 <ksf> are we going to have these http://www.baumschule-horstmann.de/bilder/popup/b014875_Sauerkirsche_Koeroeser_Weichsel_6KW_0.jpg in july, then?
05:59:28 <mm_freak_> levifikri: if you want to prepend to the file, then you have to recreate it
05:59:47 <mm_freak_> levifikri: if you want to overwrite the beginning, then just open the file in append mode and then seek to the beginning
06:01:52 <revenantphx> ksf: Yep, followed by these for october: http://farm4.static.flickr.com/3018/2308674390_b997acb5a9.jpg
06:06:31 <MHD0> How do I make Word32# literals?
06:07:05 <copumpkin> 3##
06:07:11 * ksf dares to doubt that you want to.
06:07:26 <aristid> :t 3##
06:07:27 <lambdabot> GHC.Prim.Word#
06:07:33 <aristid> hah.
06:07:39 <MHD0> copumpkin: Gives me a type error, tells me its Word#
06:07:44 <copumpkin> oh
06:08:04 <MHD0> ksf: Implementing a TT800 in haskell
06:08:38 <copumpkin> MHD0: are you sure you even get those?
06:08:41 <taweee> Question. Now what? :)  http://pastebin.com/MmU7JkQV
06:08:44 <copumpkin> MHD0: why not just Word32?
06:08:48 <ksf> MHD0, in general, ghc unboxes them just fine.
06:08:56 <MHD0> copumpkin: Efficiency
06:09:03 <copumpkin> MHD0: premature optimization?
06:09:04 <MHD0> and fun
06:09:08 <MHD0> maybe
06:09:14 <MHD0> TT800 is pretty simple...
06:09:15 <copumpkin> I don't think GHC even makes Word32# anymore
06:09:23 <copumpkin> maybe, dunno, ask in #ghc
06:09:33 <MHD0> But isnt a Word only gurenteed to be 30 bits?
06:09:41 <copumpkin> Word isn't even mentioned in the report
06:09:46 <MHD0> oh
06:09:50 <copumpkin> but anyway
06:09:52 <copumpkin> I said Word32
06:09:58 <MHD0> ok
06:09:59 <copumpkin> there are all the sized Word types in Data.Word
06:10:05 <copumpkin> none of that nasty MagicHash crap
06:10:08 <MHD0> yeah, I know
06:10:10 <copumpkin> most of which gets done for you
06:10:14 <MHD0> ok
06:10:47 <hpc> :t 3#
06:10:49 <lambdabot> GHC.Prim.Int#
06:10:53 <hpc> :t 3###
06:10:54 <lambdabot> parse error (possibly incorrect indentation)
06:11:19 <frank00> little Q for the channel: I feel that my Haskell would benefit if I had a more solid foundation in lambda calculus. Do you know of any good books (online or not) which are nice?
06:11:41 <hpc> frank00: the wikipedia article is quite great
06:11:44 <copumpkin> frank00: the basic idea of an untyped LC can be picked up in a few minutes from the wikipedia article
06:11:53 <hpc> also look at the SKI article
06:11:53 <frank00> I will soon hold a MSc in Finance, so my math is not extremely rusty
06:11:59 <copumpkin> there are dozens of lambda calculi with different type systems though
06:11:59 <copumpkin> frank00: no math
06:12:13 <hpc> http://en.wikipedia.org/wiki/SKI_combinator_calculus http://en.wikipedia.org/wiki/Lambda_calculus
06:12:44 <taweee> what it means 'unification would give infinite type'?
06:12:59 <copumpkin> is that hugs?
06:13:02 <taweee> yes
06:13:06 <copumpkin> it means that you tried to say a = [a] or something like that
06:13:14 <copumpkin> solving that would result in [[[[[[[[[[[[[[[[[[[[[[[[[[...
06:13:19 <taweee> http://pastebin.com/MmU7JkQV
06:13:34 <frank00> hpc: , copumpkin , thanks. But will that cover, for example, monads too? 
06:13:44 <hpc> frank00: monads aren't lambda calc, per se
06:13:50 <copumpkin> frank00: those are mostly unrelated to lambda calculus
06:14:04 <frank00> ok, then I will change my initial question
06:14:05 <copumpkin> frank00: for those, I would try to get really comfortable with types
06:14:26 * ksf would think that financial maths doesn't have much in common with cs math
06:14:27 <frank00> what is good "math" stuffto learn which will help me with Haskell?
06:14:39 <copumpkin> I'm going to say not really category theory
06:14:49 <hpc> frank00: again, those wikipedia articles, i would say
06:14:51 <ksf> typed lambda calculus.
06:14:52 <hpc> also discrete math
06:15:03 <ksf> in particular, system f.
06:15:25 <ksf> also, read up on the curry-howard isomorphism and hindley-milner typing.
06:15:45 <hpc> er, do what ksf said
06:16:10 <frank00> ksf: any chance to find what you've just said in one publication? I mean, if they're related for sure there oughta be a college level book, am I wrong?
06:16:11 * ksf sticks, quite unexpectedly, a "math nerd" sticker to his chest
06:16:44 <ksf> the isomorphism is quite simple, it says that programs are proofs for their types.
06:17:44 <pozic> You can also do this with x86 assembly. push 5: push 5 ;)
06:17:46 <ksf> http://en.wikipedia.org/wiki/Type_inference , and possibly just the "typing haskell in haskell" paper
06:17:47 * hpc didn't find the curry-howard isomorphism especially useful in starting out in haskell
06:18:20 <saml> programs are proofs for their types?????????????/
06:18:41 <alpounet> @djinn (a,b) -> a
06:18:41 <lambdabot> f (a, _) = a
06:18:46 <ksf> @djinn a -> Maybe a -> a
06:18:47 <lambdabot> f a b =
06:18:47 <lambdabot>     case b of
06:18:47 <lambdabot>     Nothing -> a
06:18:47 <lambdabot>     Just c -> c
06:18:52 <frank00> I've jsut finished lyahfagg, and I feel something is not explained fully (and rightly so)
06:19:11 <saml> yah we need Effective Haskell  book
06:19:15 <saml> something like Effective Java
06:19:16 <ksf> well, it's not really necessary to understand all the nitty-gritty details to *use* haskell
06:19:18 <hpc> the type (x -> y) means "you can transform from x to y" more or less
06:19:33 <ksf> understanding how unification works, roughly, is more than enough.
06:19:37 <hpc> so the proof that you can transform x to y would be to demonstrate a transformation from x to y
06:19:38 <saml> can you write one today? so that i can read over weekend
06:19:47 <hpc> (that's my simplistic idea of it, anyway)
06:19:55 <frank00> ksf: but I *would like* to know, I am interested in things =)
06:20:50 <ksf> well, http://web.cecs.pdx.edu/~mpj/thih/  and   http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf   come to mind.
06:21:01 <hpc> oh, also the wikibook for haskell
06:21:05 <hpc> @where wikibook
06:21:16 <hpc> > 5 -- lambdabot?
06:21:20 <hpc> :(
06:21:29 <hpc> http://en.wikibooks.org/wiki/Haskell
06:21:32 <frank00> thanks folks
06:21:41 <ksf> frank00, but it might be more gainful to just read a lot of code.
06:21:49 <hpc> most of the articles are woefully inadequate, but it at least gives you stuff to google
06:22:09 <FUZxxl> saml: This means, that the typechecker can PROOF, that your program is well typed. For instance, you can PROOF, that the functor instance for lists will map the function over all elements, because there can't be any untouched element, just from their type. (If I go it right)
06:22:14 <ksf> there's also the haskell wiki, itself.
06:22:20 <frank00> ksf, I will do that too, thanks for the tip!
06:22:44 <ksf> FUZxxl, map f xs = []
06:22:53 <ksf> that's correctly typed.
06:23:04 <jacobian> @pl (\ d -> return $ position rt d)
06:23:18 <hpc> return . position rt
06:23:27 <ksf> you need to add the additional constraint "use every parameter" to get what djinn does.
06:23:28 <jacobian> ;)
06:23:46 <saml> oh man why is that so hard FUZxxl ?
06:24:02 <hpc> @djinn (a -> b) -> [a] -> [b]
06:24:06 <ksf> and it's more like that the type inference is inferring (relatively weak) premises from your code.
06:24:15 <hpc> ... i am an idiot
06:24:47 <zygoloid> -- f cannot be realized.
06:24:54 <hpc> zygoloid: harr harr :D
06:26:39 <alpounet> well
06:26:49 <alpounet> @djinn (a -> b) -> Maybe a -> Maybe b
06:26:49 <lambdabot> f a b =
06:26:49 <lambdabot>     case b of
06:26:50 <lambdabot>     Nothing -> Nothing
06:26:50 <lambdabot>     Just c -> Just (a c)
06:28:50 <djahandarie> @djinn Not (Not (((a -> b) -> a) -> a))
06:29:59 <djahandarie> That would explain it.
06:36:24 <roelvandijk> How can I test a property of type "Int -> IO Bool" with QuickCheck?
06:36:41 <roelvandijk> I found morallyDubiousIOProperty :: Testable prop => IO prop -> Property, but I'm not sure how it is useful in this instance
06:43:02 <roconnor_> roelvandijk: what property do you want to check?
06:43:22 <roelvandijk> A function which connects over USB with a microcontroller
06:43:35 <roelvandijk> Its type is (Word32 -> IO Bool)
06:43:49 <roconnor> I know, but what property do you want to check about it?
06:43:52 <ksf> that doesn't sound like something you want to do with the vanilla quickcheck harness
06:44:13 <roelvandijk> Setting a parameter to value x, then retrieving the value of the parameter and comparing that with x
06:44:19 <ksf> I'd most likely code up the harness myself, using testable instances from quickcheck.
06:44:52 <roelvandijk> I was using HUnit, but thought it would fit in with QuickCheck
06:45:07 <roelvandijk> Maybe I can just use the test data generation part
06:45:27 <roconnor> roelvandijk: how do you retrieve a value using a function of type (Word32 -> IO Bool)?
06:46:18 <roelvandijk> testFoo n = runMainboard $ get theParameter
06:46:21 <roelvandijk> Something like that
06:46:35 <roelvandijk> runMainboard runs a Monad which abstracts over communication with the microcontroller
06:47:00 <roelvandijk> I think a hpaste is appropriate here
06:47:04 <roconnor> :)
06:47:55 <hpaste> RoelvanDijk pasted "Property in IO"  http://hpaste.org/44504
06:49:16 <roconnor> _ggreg: sorry.
06:49:25 <roelvandijk> The W32LE thing is a newtype wrapper around a Word32, for serialization purposes
06:49:49 <roconnor> oh I get it now
06:53:22 <fram> After weeks of haskell I've been doing some C++ in the last few hours and, though I'm not yet very good with haskell, I must say that C++ seems very painful to me now!
06:54:13 <hpc> fram: indeed; your brain is now stuck in haskell mode! all glory to the hypnocode!
06:54:18 <fram> :)
06:54:37 <HugoDaniel> :D
06:54:44 <illissius`> fram: try using template metaprogramming :)
06:54:57 <illissius`> it'll still be very painful, just by (more or less) a constant factor
06:55:03 <fram> I was shocked by stuff like : if(a==0){...}else if(a==4){...}  what if a was 3???
06:55:39 <fram> template metaprogramming in haskell or c++?
06:55:43 <illissius`> c++
06:55:55 <fram> yeah the lib I used had a lot of that
06:55:58 <roconnor> roelvandijk: my quick look at things indicate that morallyDubiousIOProperty seems reasonable here
06:56:00 <fram> its a nightmare
06:56:00 <illissius`> heh ok
06:56:18 <hpc> getting comfortable with IO will make it easier to go back to c++
06:56:33 <HugoDaniel> fram, dont go too far
06:56:33 <roelvandijk> roconnor: That was also what I thought, but I fail to see _how_ it must use it
06:56:50 <fram> they should use haskell if they want to do complicated things with types
06:56:55 <fram> :)
06:56:57 <HugoDaniel> check out these: http://goo.gl/gML6i
06:57:11 <roconnor> roelvandijk: I think you just need to be aware that a test that fails on an input may succeed on the same input later in principle.
06:57:29 <hpc> even haskell gets ugly when you start doing sufficiently crazy type hackery
06:57:56 <illissius`> fram: c++'s type system (templates) are actually considerably more powerful for doing type-level computation
06:58:08 <illissius`> you can specialize willy-nilly, pass template metafunctions as arguments, etc.
06:58:18 <roelvandijk> roconnor: Yes, but if the property fails for any reason it is interesting to me
06:58:22 <illissius`> it's just that haskell's type system is way better at -being a type system-
06:58:33 <roconnor> roelvandijk: indeed
06:59:02 <roelvandijk> roconnor: But I fail to see how to use morallyDubiousIOProperty to test something of the form "Int -> IO Bool"
06:59:05 <hpc> HugoDaniel: 7 pages?!
06:59:06 <ksf> illissius`, enable -XUndecidableInstances and haskell's type level is TC, too.
06:59:39 <roconnor> roelvandijk: why is that different?
06:59:46 <sipa1024> illissius`: i wouldn't call it type-level computation, but compile-time computation :)
06:59:47 <ksf> omg who writes such code.
06:59:52 <ksf> the proper way is !!foo
06:59:58 <HugoDaniel> hpc, the horror!
07:00:06 <HugoDaniel> ksf :D
07:00:32 <hpc> ksf: the real question is, does it evaluate to (!foo)?fales:true, or !(foo?false:true)?
07:00:38 <hpc> SCIENCE DOESN'T KNOW!
07:00:51 <ksf> i'd expect the former.
07:01:01 <ksf> ?: generally binds quite low.
07:01:04 <illissius`> ksf: turing complete, sure, but you still can't have overlap with type families (~ template specialization), nor can you have higher-order type function (~ template template parameters)
07:01:11 <roelvandijk> roconnor: morallyDubiousIOProperty takes an "IO prop", but I have "Word32 -> IO Bool"
07:01:28 <HugoDaniel> i like to search googlecode for some fugly patterns
07:01:35 <illissius`> maybe you can do that kind of thing with FDs and OverlappingInstances instead, but i think that starts to be actually -more- ugly than C++ templates, which is no small feat.
07:01:37 <ksf> but, but, you can write a c++ compiler in type families!
07:01:40 <HugoDaniel> when im depressing about my codeskills i get a big smile :)
07:01:53 <hpc> ksf: sure, but why would you?
07:02:02 <hpc> in fact, why would you write a c++ compiler at all?
07:02:03 <hpc> :P
07:02:04 <ksf> in any case, you want to use TH for such stuff.
07:02:04 <roconnor> roelvandijk: ah
07:02:23 <ksf> which is a more appropriate comparison to templates, anyway.
07:02:23 <roconnor> roelvandijk: but that is fine isn't it
07:02:28 <hpc> HugoDaniel: hehe
07:02:44 <fram> Templates scare me. Long live Visual Basic!
07:02:53 <roelvandijk> roconnor: It looks like I have to apply my function to a value, but I want QuickCheck to generate those values for me
07:02:59 <fram> no type problems there
07:03:40 <roconnor> revenantphx: Bool is Testabel so IO Bool is Property = Gen Prop, which is again testable, Word32 -> IO Bool is Testable.
07:03:50 <roconnor> roelvandijk: it should just work.
07:04:06 <illissius`> ksf: well, it's sort of weird. C++ templates are I think in a kind of in-between space between haskell's type system and TH
07:04:28 <illissius`> like, 99% of the time people only ever use TH to automatically generate boilerplate
07:04:31 <roelvandijk> roconnor: ah, I'm beginning to see
07:04:54 <illissius`> actually, amend that: haskell's type system, TH, and RULES
07:05:05 <roconnor> so long as Word32 is Arbitrary and Show, which it is I presume.
07:05:12 <ksf> I used it once to unroll a lookup in a binary tree to straight code.
07:05:29 <roelvandijk> roconnor: Cool, it works! Already found a corner case
07:05:30 <illissius`> ksf: TH, you mean?
07:05:36 <ksf> yep
07:05:36 <roelvandijk> roconnor: I just needed to apply more coffee
07:05:37 <roconnor> :)
07:05:57 <roconnor> well, if it finds bugs, how morally dubious can it be
07:05:59 <ksf> the performance difference was staggering.
07:06:20 <ksf> between using an adt and unboxed array there was virtually no difference.
07:06:56 <roelvandijk> roconner: Indeed. Thanks for you help!
07:07:09 <ksf> back in the days, I'd write up such things by hand, but having a binary dispatch compiled from [(a,b)] is nice.
07:09:42 <illissius`> if you think of a library like Eigen for C++, which just uses operator overloading and such to turn everything into a template expression and then optimizes it all away to raw SSE code, it seems like doing that with TH would be painful (am I wrong?)
07:10:02 <hpaste> astroboy pasted "could not deduce..."  http://hpaste.org/44505
07:10:12 <ksf> the sse part, yes.
07:10:19 * ksf wishes we had inline llvm
07:10:28 <ManateeLazyCat> Next version manatee, do you like it? http://www.flickr.com/photos/48809572@N02/5496671763/sizes/l/in/photostream/
07:10:34 <illissius`> ksf: well, even ignoring the SSE part
07:10:56 * hackagebot BNFC-meta 0.1.0.2 - Deriving Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.1.0.2 (JonasDuregard)
07:11:01 <aristid> illissius`: would optimising it at runtime be acceptable?
07:11:09 <roconnor> roelvandijk: arguably I didn't do anything :D
07:11:11 <illissius`> aristid: no
07:11:15 <ManateeLazyCat> I plan remove command popup window from Manatee, instead i show every module in welcome window.
07:11:31 <ManateeLazyCat> It's will be easier for user.
07:11:35 <aristid> illissius`: why not?
07:11:43 <ksf> I don't see how dph doesn't already do what eigen does.
07:11:45 <illissius`> haskell typesystem hackery is obviously unsuited to this, and the haskell equivalent is more like RULES, which get you 70% of the way there for 10% of the cost, but can't do the rest
07:11:50 <illissius`> hmm
07:12:00 <ManateeLazyCat> @tell juhp Look http://www.flickr.com/photos/48809572@N02/5496671763/sizes/l/in/photostream/ , how do you think it?
07:12:01 <ksf> well, minus the vectorisation part, we only have a multicore backend afaik.
07:12:07 <roelvandijk> roconnor: In my experience just listening to someones problems is often enough to solve them :-)
07:12:10 <ManateeLazyCat> Oh, lambdabot is down
07:12:15 <illissius`> ksf: heh, it's sort of like the inverse of eigen then
07:12:31 <illissius`> ksf: eigen does vectorization and only recently gained minimal support for OpenMP
07:12:34 <ksf> well, dph is much about the semantics and syntax.
07:12:46 <ksf> the backends are another matter.
07:13:02 <illissius`> that's true
07:13:27 <illissius`> DPH might be a closer fit, yeah
07:13:31 <ksf> a cuda backend would be nice, too.
07:13:31 <ksf> I think it's even in the works.
07:13:47 <hpc> dph is opencl?
07:14:04 <illissius`> anyway, I suspect TH is less suited to this than C++ templates are, they're not straight analogous to each other
07:15:26 <illissius`> (it's pretty interesting how various features/subfeatures/use cases of C++ map onto features/subfeatures/use cases in Haskell in totally different places... should make a table out of it one of these days)
07:16:00 <illissius`> anyway, </irc>
07:16:06 <hpc> illissius`: also interesting how one gets so much hate and the other so much love :P
07:16:10 <hpc> or that
09:51:18 --- topic: '["Paste code/errors: http://hpaste.org", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
09:51:18 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Fri Jan 28 14:21:19 2011]
09:51:18 --- names: list (clog carlocci colbseton io2 freiksenet jjohnsson Brechreiz enthymeme Nisstyre TheMoonMaster naypalm dolio pedro3005 cheater- dogmaT dual lispy IrishDuck lopex jethomas ulfdoz empity Alkhi ormaaj _nickel pyrony notabel damex BlankVerse xplat_ mrsolo jonkri jmelesky niko Mkman jlewis ymasory pheaver waern_ judah roelvandijk yrlnry jsgf age codelurker Schmallon c_wraith kniu Athas coffeemug jql pearle shamster augur companion_cube sshc banjiewen pikhq cubi)
09:51:18 --- names: list (kelvie_` saurik MigoMipo zax_ Icewing iFire povik erg0t thetallguy1 mercury^ AnAdorableNick snearch portnov afarmer otto_s ryant5000 pimeys___ kmels bogner schroedinbug neurogeek SyntaxNinja Sunil01 ceii olsner kaini pumpkin jdsc jd10 chromakode dkasak ski ReinH davean byorgey RayNbow sipa EvanCarr1ll lkb madManchegan gio123 CosmicRay sm qz BONUS chitragupt Philippa mwc_ djahandarie EvanCarroll mafs_ tafryn msieradzki_ nothingmuch Twey phil_ darq[afk])
09:51:18 --- names: list (SimonRC Gilly david` cynick Shown owain clanehin Jantaro trez_ joaopizani hiptobecubic gdsx jrk_ jml ben Saizan mrd udoprog palmje Tinned_Tuna oc nornagon Lemmih mietek cncl_ `0660 pettter dorkitud1 defect adimit sbok troofax wolfwood ernst Kalivha freedrull npouillard jrockway reacocard sajkr suiside henr_k gereedy carrbs welterde flori mattam lunaris int-e tridactyla Raynes kosmikus zygoloid gseitz jamwt agemo Vulpyne And[y] tengen category mrshoe kalven)
09:51:18 --- names: list (magicman bhungy CindyLinz dixie Aestas dionoea Paradox924X jacobian Maxdamantus Fingerzam Laney sgtarr Counter-Strike bxc_ jlouis Rooz aiko_ MacCoaster_ hiredman Boxo earthy shiduke zomg OnionKnight aavogt @ChanServ johs lostman _erik_ snarkyboojum harlekin taruti quaestor MrDomino^ Ke raek impl tavelram ian_mi obcode appamatto edwtjo felipe_ mlh jvogel dumael stesh faanbj cafaro Jaak pastorn periodic preflex Nanar yahooooo soeren jix alip xinitrc_ deavid)
09:51:18 --- names: list (Draggor quicksilver eyck ksandstr Axman6 alexbobp vili_ Starfire FauxFaux ddarius xplat antonh thorkilnaur derrotebaron dRbiG emias dons cpa jho sophacles ec|detached srcerer Nshag KitB_ shlevy mun_ qebab electrog1ek stepnem timchen1` rokoteko whoops javecantrell joeytwiddle idoru inimino ilab dcoutts absentia mauke gerard0 Innominate cwillu_at_work etpace rup snr Khisanth hpaste scsibug go|dfish snorble jedai_ akosch fihi09` proq dankna dreixel tew88)
09:51:18 --- names: list (tessier Entroacceptor dino- Draconx dom96 alek_br xinming anonchik tlonim mapreduce maharj stepkut bqf cibs Cale miloshadzic septomin exlevan JaffaCake peterquest o^_^o dcolish mq Raku^ Samoi dleslie norm2782 ToRA alexsuraci jao jbauman_ dobblego lispy_ tomaw brisbin barik djanatyn dMazz thoughtpolice jssanders ibt anders^^ jgrimes_ nlogax Cthulhon| ion xarch_ Igloo regalia ibid flux amiri etabot nniro ocharles shachaf mikeg Veinor rwbarton araujo wto)
09:51:18 --- names: list (tlockney comex_ blackdog opqdonut Odd_Bloke ollip micahjohnston Clex ahf Muad_Dibber__ mgsloan noj steve_himself osfameron jcapper inr Cerise solarus Vq filius Philonous Zao Yahovah Colours_ funscala1 perlite tmuki mm_freak_ robinsmidsrod pingveno ixzkn tswett willb1 Ferdirand b52 Gunni borism ChongLi vizowl jystic marienz Nereid cozmic sohum phryk sonnym poindontcare lsthemes joelb nchaimov arlinius metasyntax em shepheb TacticalGrace Cobra_ davidlee luite)
09:51:18 --- names: list (gwern jaj Astro Adamant jessopher derekwright_ ArchGT nixeagle BrianHV_ ve tromp__ saiam_ guerrill1 aleator_ brushbox Arnar Liskni_si integral _2x2l Lanther geekounet setmeaway orbitz ousado_ hackagebot adnap arnihermann MK_FG Sunhay kaf3ii roconnor tomjnixon homie morphling fcr leino Evious jendap Ken`_ FireFly cognominal jaspervdj janbanan newsham dschoepe Boney MoALTz_ danvet Fuco rly Yacoby RageOfThou buntfalke jmvanel HugoDaniel ville eZet mceier moshee)
09:51:18 --- names: list (fmardini alvivi drbean tensorpudding sepp2k saml gehmehgeh mxweas duairc nff Darkone dark foo-nix mun__ nqxbwo Baughn canvon Jafet n0t dmwit_ ath drhodes_ duckinator ClaudiusMaximus Denebola`` _ggreg Sonicvan1Jr andrewsw janne- skaar_ ido__ slabanja_ sbahra plan kakeman_ mortberg wires` paulh_ pantsd lionelj kaol ziman_ pesco jackhill_ klugez KaneTW profmakx idnar ihckt_ sigue flamingspinach_ confound paolino eno__ alexsdutton DrSyzygy StoneToad phr__)
09:51:18 --- names: list (kevinww_ DustyDingo brett ehamberg ortmage1 52AAAKZJX fram kfr dqd ps-auxw Vorpal hyko- Hunner Belgarion_ Martty codemac chrisf cjay gemelen rostayob mjrosenb_ edon novas0x2a1 aristid alpounet stroan_ nimred edenc_ tamiko_ noddy2000 rapacity_ Ornedan_ copton szbalint zaphar_p1 helgikrs_ pantski_ koala_ma1 ace2001a1 hellige_ larsrh_ vegai_ jonafan Ptival hpc mux djl1 Runar sgronblo_ foamping _mpu_ beastaugh mindwarp pi8027 burp Guest17142 Bleadof solidsnack)
09:51:18 --- names: list (ahihi2_ mornfall majoh eb4890 hzh rothwell monochrom __marius1_ robinbb lantti ahihi_ siracusa amaron wagle_ Aisling Apocalis_ todos__ pozic Guest48551 almostsix iago jrib der_eq Gowilla McManiaC_ nominolo Gabbie TML__ repnop_ m4thrick jmcarthur zmbmartin dcoutts_ angstrom xenocryst ceii_ methods Botje_ m3ga_ danblick bd__ ksf TaTonka Soft [mth] dal9k zakwilson Taggnostr3 alex404__ davidL milli jem777 liyang doserj wolverian kloeri Obfuscate` birkenfeld noam)
09:51:18 --- names: list (dimmy Zeiris_ CoryDambach scree hvr dropdrive espringe krainbol1greene PHO__ Masse^^ parcs elliottt_ Eliel THC4k ivan ajhager Amadiro nixness tab Bynbo7 insomniaSalt arkx _Mitar btubbs Silex Dashkal anonus allbery_b kelvie__ joe6 ankit9 Blub\0 aculich cyanoacry caligula_ samferry poucet faj a11235_ rando ccasin thetallguy rajeshsr Neronus ajnsit Jonno_FT1 theorbtwo danten erk jonrh scm Adman65 mike1703 dilinger_ liesen_ ngochai fengshaun winxordie dfeuer_)
09:51:18 --- names: list (__nickm__ koninkje_away alios FDFlock abbe ray)
09:51:26 <ksf> \x y -> foo $ bar x y
09:51:55 <Brechreiz> How do you know bar takes two arguments?
09:52:20 <ksf> because of the way foo is used.
09:52:36 <Brechreiz> Could you elaborate?
09:52:51 <ksf> it's quite a standard pattern, actually.
09:53:31 <Brechreiz> Okay, back to the drawing board it is for me :)
09:53:31 <Boxo> (foo . ) . bar = \x -> foo . bar x = \x y -> foo (bar x y)
09:54:13 <Boxo> the definition of (.) is simple
09:54:24 <Brechreiz> @src (.)
09:54:31 <ksf> (.) = fmap
09:54:31 <Brechreiz> Oh wait, vacation :-/
09:54:52 <c_wraith> f . g = \x -> f (g x)
09:54:53 <Boxo> (.) = \f g x -> f (g x)
09:56:30 <jjohnsson> Where does a bot go for vacation?
09:57:05 <ksf> http://www.technologiesblog.eu/wp-content/uploads/2010/11/supercomputer.jpg
09:57:45 <ksf> I heard it's an all ram you can eat place.
09:59:08 <lispy> ksf: that looks like a scene from minecraft
09:59:49 <Brechreiz> Does function application bind tighter than function composition?
10:00:18 <sm> yes
10:00:26 <lispy> function application is the tightest binder
10:00:33 <confound> otherwise you'd have to write (foo) . (bar) all over the place
10:00:42 <sm> dangit freenode
10:00:44 <confound> or something
10:01:31 <roconnor> I really need to get a better grip on adjoint functors
10:04:23 <jjohnsson> ksf: looks nice.
10:12:53 <pocket_dude> Haskell is a good language for doing what? what learning Haskell will improve me as a computer programmer? is it a language that i can learn almost averything in a afternoon
10:12:53 <pocket_dude> ?
10:13:45 <byorgey> pocket_dude: short answers: pretty much anything, yes, and no
10:15:00 <pocket_dude> byorgey: and what it will improve me as a progamer?
10:15:08 <pocket_dude> what will be the changes
10:15:09 <pocket_dude> ?
10:15:19 <pumpkin> pocket_dude: getting better at problem solving
10:15:20 <ksf> haskell is like fairy dust: throughoutly awesome, but kinda hard to get.
10:15:23 <pumpkin> thinking deeply
10:15:28 <byorgey> pocket_dude: you will learn to think more abstractly, at a higher level
10:15:33 <pumpkin> it changes your thought processes
10:16:03 <pocket_dude> hummm ok
10:16:11 <pumpkin> lol
10:16:19 <pumpkin> ask an abstract question get abstract answers
10:16:49 <byorgey> I should have said "learning Haskell will make you better at writing programs involving the number 17"
10:17:03 <hpc> byorgey: it's true!
10:17:18 <byorgey> @faq can Haskell make you better at writing programs involving the number 17?
10:17:27 <hpc> Yes! Haskell can do that!
10:17:30 <byorgey> =D
10:19:20 <lionelj> why 17?
10:19:39 <monochrom> @quote monochrom 17
10:19:51 <byorgey> lionelj: why not? =)
10:19:56 <monochrom> oh lambdabot is still away
10:20:06 <monochrom> boring friday without lambdabot
10:20:19 <byorgey> lionelj: just to be silly, because it is not really possible to answer "how will Haskell make me a better programmer" in a very specific way
10:20:26 * monochrom contemplates cheating on lambdabot when she's away
10:20:35 <byorgey> gasp! you wouldn't!
10:21:09 <monochrom> but I have certain needs, you know...
10:21:32 * monochrom goes play with javabot
10:21:40 <lionelj> cause I am studying Haskell to write programs involving other numbers... like 5,7 and 11! #jk
10:21:57 <byorgey> lionelj: oh, 7 should be ok.  you might have trouble with 5 and 11 though
10:22:05 <shepheb> monochrom: good lord! cheating is one thing, but have /some/ standards.
10:22:39 <lionelj> byorgey: then I'll start with 5 and 11
10:26:27 <fram> "it changes your thought processes", he means it makes you crazy and wake up in the middle of the night, screaming, thinking you are stuck inside a monad
10:26:43 <Boxo> sounds good!
10:26:55 <ksf> @quote ksf monad
10:26:58 <ksf> gah.
10:29:48 <age> hmm
10:30:24 <age> say, I have a series of consecutive function calls. can I unfold that into one single line of operations?
10:30:38 <hpc> age: example?
10:30:55 <ksf> foldr (.) / foldr ($) ?
10:31:18 <age> hpc: http://npaste.de/zR/Haskell
10:31:52 <age> The problem is, I've used where to have variables
10:32:01 <ksf> that looks awesomely untyped.
10:32:07 <Phantom__Hoover> WHAT DID YOU DO TO LAMBDABOT YOU BASTARDS
10:32:20 <hpc> age: i have no idea how to improve that
10:32:48 <hpc> oh wait...
10:32:49 <age> ksf: what do you mean? Haskell noob here, sorry.
10:32:54 <ksf> that is, I think you should use a record or somthing.
10:33:04 * Phantom__Hoover demands ANSWERS
10:33:11 <ksf> list of bools aren't particularily useful
10:33:13 <hpc> no, i don't see the pattern
10:33:24 <hpc> *a pattern
10:33:27 <ksf> Phantom__Hoover, she's on vacation.
10:33:45 <age> hpc: not improve, just unfold it to a single line of boolean operations on a,b,c,d
10:34:00 <ion> Try pointless. I mean, pointfree. :-P
10:34:19 <ion> Im not expecting a pretty result.
10:34:29 <hpc> age: change the "where" to "let ... in"?
10:34:29 <Phantom__Hoover> ksf, HOW AM I MEANT TO ADD THINGS NOW
10:35:00 <hpc> er, "let {..;..;...} in ..."
10:36:02 <hpc> that where clause is a huge hodgepodge of stuff, and it really wouldn't be improved when translated into operations on a,b,c,d
10:36:49 <confound> age: how is that return value useful?
10:45:09 <hpaste> AlexR pasted "Timed iteration try 2"  http://hpaste.org/44514
11:19:37 <bob31> whois bob31
11:20:00 <bob31> er. wrong. anyway.
11:20:03 <confound> bob31: you are
11:20:07 <bob31> haha
11:20:15 <bob31> thanks for confirmation
11:20:22 <confound> np
11:20:23 <bob31> I was wondering about cabal-install
11:20:31 <bob31> where's the new release?
11:20:39 <bob31> 0.8.2 is the one linked in wiki
11:20:43 <saml> bob31, here
11:20:47 <saml> let me give u link. sec
11:20:50 <bob31> and I have the inofficial git mirror
11:20:54 <silver> in gentoo overlay 
11:21:18 <saml> bob31, http://haskell.org/cabal/release/   or http://hackage.haskell.org/package/cabal-install
11:21:44 <silver> Latest version available: 0.10.0
11:22:15 * dcoutts needs to update the cabal website
11:23:01 <bob31> saml: thanks! should have thought about hackage
11:23:34 <bob31> dcoutts: thanks  duncan. was getting confused in an endless loop
11:49:56 <Heffalump> anyone know if ghc 7.2 will have superclass equalities? I thought that was the reason for it that SPJ mentioned, but they're not supported in a recent 7.1 snapshot.
11:50:34 <hpaste> wjzz pasted "euler 59"  http://hpaste.org/44517
11:53:43 <pastorn> i'm starting to think that hpaste shouldn't announce by default...
11:54:26 <Saizan> me too
11:54:48 <pumpkin> Heffalump: I think it's part of the plan, yeah
11:55:00 <pumpkin> I think in Simon Marlow's roadmap he mentioned that
11:55:11 <pastorn> Heffalump:  http://haskell.org/haskellwiki/Class_alias ?
11:55:19 <pumpkin> not that
11:55:40 <pumpkin> class (F a ~ G b) => Moo ...
11:55:51 <pastorn> pumpkin: what's the matter? aren't you applying yourself today?
11:56:03 <copumpkin> :)
11:56:06 <pastorn> :D
11:56:25 <pastorn> copumpkin: that line there doesn't tell me anything :/
11:56:50 <copumpkin> pastorn: that's what you can't do now that people want to be able to do
11:57:01 <copumpkin> and what's keeping TypeFamilies from being as strong as Fundeps
11:57:11 <pastorn> ehm...
11:57:14 <pastorn> still
11:57:23 <pastorn> i have no clue about what it means
11:57:48 <pastorn> you throw in a "~" and then i should thing "yes! tilde! obviously!!!"
11:57:54 <pastorn> *think
11:58:00 <copumpkin> ~ is type-level equality
11:58:01 <kmc> (F a ~ G b) means "(F a) is the same type as (G b)"
11:58:01 <roelvandijk> "~" is type equality
11:58:17 <copumpkin> glorious 3-way stereo?
11:58:34 <kmc> it's in the same syntactic category as class constraints
11:58:37 <pastorn> copumpkin: (data Event a = NoEvent | Event a) ~ (data Maybe a = Nothing | Just a) ?
11:58:41 <roelvandijk> This is a high fidelity channel :-)
11:58:44 <copumpkin> pastorn: no
11:58:44 <kmc> no pastorn
11:58:48 <kmc> same type, not isomorphism
11:58:57 <copumpkin> Event Bool ~ Event Bool
11:59:03 <ksf> fsvo "same type".
11:59:06 <kmc> so that one is only interesting if one of F and G is a type synonym family
11:59:15 <ksf> only ground types if my terminology is correct.
11:59:27 <ksf> that is, if you have polymorphic stuff you're out of luck.
11:59:36 <kmc> type family F x; type family G x; type instance F Int = Char; type instance G Bool = Char
11:59:44 <kmc> now the constraint is satisfied for a = Int, b = Bool
12:01:26 <kmc> pastorn, it would be useful to ask "what does the tilde mean" rather than saying "i have no clue".  i don't think copumpkin assumed you'd magically know what it meant,  so much as didn't know your prior knowledge level
12:01:36 <pastorn> hehe
12:01:46 <pastorn> true
12:01:49 <pastorn> copumpkin: sorry
12:01:51 <kmc> the ~ constraints also show up with GADTs
12:02:27 <pastorn> i still don't get it, though... i haven't played any with type families on the other hand
12:02:29 <kmc> data Foo t where { MkFoo :: Foo Char }
12:02:38 <pastorn> so i don't really know what they bring to the table
12:02:40 <kmc> data Foo t where { MkFoo :: (a ~ Char) => Foo a }  -- desugared
12:03:34 <kmc> this form is used by GHC internally because it makes typechecking of GADTs more digestible
12:03:58 <kmc> yeah, it is hard to see why superclass equality constraints would be useful if you haven't used type synonym families
12:04:22 <c_wraith> Oh.  I have used them just enough to understand now why it is useful.
12:04:53 <pastorn> anyone has a simple real world example of type family stuff?
12:05:10 <thoughtp1lice> does GHC even fully support equality constraints in superclass declarations still?
12:05:15 <kmc> pastorn, http://www.haskell.org/haskellwiki/GHC/Type_families
12:05:15 <pastorn> doesn't SPJ mention hacking some cool stuff with type families in his DPH talk?
12:05:20 <thoughtp1lice> i thought that was the last remaining piece of the type families puzzle
12:05:26 <kmc> yes, they're instrumental in DPH
12:05:35 <thoughtp1lice> actually, i prefer this paper:
12:05:37 <thoughtp1lice> http://www.haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
12:05:44 <thoughtp1lice> it has a *lot* of good examples of how type families are useful
12:05:58 <pastorn> thoughtp1lice: cool, i'll look at it :)
12:06:08 <thoughtp1lice> and it's a good read of course, written by none-other than SPJ and the oleg himself
12:07:38 <thoughtpolice> hm
12:07:50 <thoughtpolice> that wiki page on type families (GHC/Type_families) seems a bit old
12:08:04 <thoughtpolice> "NB: Equalities in superclass contexts are not fully implemented on the GHC 6.10 branch"
12:08:14 <thoughtpolice> i still don't think they're fully implemented, AFAIR :(
12:08:33 <kmc> yeah, i think that's where this discussion started
12:08:35 <c_wraith> Last I heard was that as of GHC 7, it's possible to fully implement them.  But not that anyone has.
12:12:03 <hpaste> thoughtpolice pasted ":("  http://hpaste.org/44518
12:12:04 <thoughtpolice> http://hpaste.org/44518/
12:13:12 <thoughtpolice> not that I even really made sure that code made any sense whatsoever, but a :( nonetheless
12:13:23 <aristid> thoughtpolice: the error message is pretty clear
12:13:24 <c_wraith> Looks like it should compile, if not be useful
12:13:47 <thoughtpolice> c_wraith: that was the intent, but it appears that chak still has to complete that part of the type families story
12:14:05 <thoughtpolice> i watch cvs-ghc pretty much all the time, just wasn't sure if that work had slipped in with the new typechecker (among other things) or not
12:14:35 <thoughtpolice> aristid: yes, i was just making sure that superclass-context quality constraints still are not implemented in ghc7, i just wasn't sure
12:14:52 <thoughtpolice> s/quality/equality/
12:15:58 <aristid> thoughtpolice: this is something you cannot do at all with fundeps, right?
12:16:42 <thoughtpolice> you can do them with fundeps, superclass-context equality constraints just look nicer. you can replicate something similar by having a 'class C a b | a -> b' still
12:17:06 <thoughtpolice> and conceptually, type families are simpler to understand, because they really are type functions, not 'type level relations' (despite the name 'functional' dependencies)
12:17:11 <thoughtpolice> at least to me
12:17:16 <aristid> class Eq a b | a -> b, b -> a; instance Eq a a?
12:17:24 <c_wraith> I suppose part of the reason there's no rush for this is that fundeps do the job, even if they're not so pretty
12:17:38 <copumpkin> I think that one is easier to understand in one context, the other is easier to understand in another
12:17:44 <copumpkin> I don't think either one is clearly superior
12:17:44 <aristid> depending on the tasks, fundeps are actually more pretty IMHO
12:17:45 <Saizan> aristid: see oleg's TypeCast
12:17:59 <aristid> the name "oleg" instills instant fear :D
12:18:18 <siracusa> Speaking of type families, does GHC 7 already have a feature to trigger the evaluation of a type family to its reduced type?
12:18:20 <Saizan> in this case it very much should
12:19:51 <thoughtpolice> siracusa: you mean taking some instance like 'type family instance F Int = Bool', having 'F Int', and thus GHC would 'reduce it' and spit out 'Bool'?
12:20:10 <siracusa> Yes
12:20:21 <copumpkin> it tries pretty hard to avoid that
12:20:41 <siracusa> But sometimes it's useful to have it.
12:23:17 <c_wraith> Heck, it'd be nice if GHCi would evaluate type functions somehow...
12:23:20 <thoughtpolice> siracusa: according to manuel (circa early 09,) GHC will not do improvement on FD's in type signatures, but it will in the case of type families, they will be normalized, GHC just won't "spit it out" - in the case above, using TF's means that you could write "foo :: F Int -> Bool; foo = id'
12:23:42 <c_wraith> I found doing :t undefined :: F Int and seeing F Int a bit annoying.
12:23:45 <thoughtpolice> in general I think GHC tries to avoid spitting out normalized type families
12:24:42 <thoughtpolice> copumpkin: do you know why GHC tries hard to avoid normalizing type signatures?
12:24:52 <copumpkin> thoughtpolice: type FilePath = String
12:24:58 <copumpkin> :t readFile
12:25:04 <copumpkin> <_<
12:25:08 <thoughtpolice> ah, right
12:25:27 <copumpkin> I'd appreciate less normalization in agda, sometimes
12:25:38 <copumpkin> I can turn it off and on, but I'd like more control of how deep it goes
12:25:49 <Saizan> i think it should be easy to add a command to ghci for that
12:26:12 <Saizan> copumpkin: i sometimes use abstract just for that
12:26:27 <copumpkin> Saizan: well, sometimes I want more normalization of the same thing, others less
12:27:48 <jkr> is there any trickery for having field lables refer to other field labels?
12:27:51 <Saizan> yeah, i'm not even sure which UI i'd like for that, maybe placing the cursor on the redex and sending a command
12:28:13 <jkr> like data A = A {num :: Int, dub :: Int }
12:28:39 <jkr> defaultA = A{num=10, dub = 2 * (num A)}
12:28:39 <kmc> how do those refer to each other?
12:28:53 <kmc> you can do that with ordinary recursion
12:29:05 <jkr> but then if I make a new field with a differnt num, dub will be twice that one.
12:29:16 <jkr> so otherA = A{num=20}
12:29:18 <kmc> no, you can't ensure that they stay "linked" like that
12:29:20 <hpc> defaultA = A{num=10, dub = 2 . num $ defaultA}
12:29:26 <jkr> dub otherA = 40
12:29:31 <kmc> jkr, if you want them always linked, why have two fields?
12:29:44 <kmc> dub :: A -> Int; dub = (2*) . num
12:29:54 <jkr> hpc: darn, but it's what I figured.
12:30:21 <jkr> kmc: so I can have some configurable defaults.
12:30:27 <kmc> i don't understand
12:30:46 <byorgey> you could imagine being able to also set dub and have it automatically invert the relation. =)
12:30:49 <kmc> are the fields supposed to remain linked forever, or you just have a default value with some relations between t hem
12:30:54 <jkr> Say, a default directory, and a default file operation. The default operation is to put the file into the directory.
12:31:21 <jkr> It would be nice to be able to redefine either one.
12:31:27 <byorgey> jkr: why not just make a custom function which takes the value of num and then gives you such a "default" record with dub defined as double of num?
12:32:00 <byorgey> instead of insisting on using the  A { num = 20} syntax to construct otherA
12:32:27 <byorgey> mkDefault n = A { num = n, dub = 2 * n }
12:32:34 <byorgey> defaultA = mkDefault 10
12:32:37 <byorgey> otherA = mkDefault 20
12:33:00 <jkr> byorgey: hmm... that's a bit better than what I had.
12:33:50 <jkr> Should have led with the use case: I'm playing around with an EDSL for mail sorting, so would like to have operations be configurable, but also have sane defaults.
12:34:11 <jkr> Sometimes I might want the default Maildir to be different but the default operation to be the same...
12:34:51 <jkr> But the I could define a couple of functions. mkDefault, mkDefaultWithFunction, or something like that.
12:36:54 <jkr> really, I guess what I was asking for, now that I think it through, was whether there was any "this" or "self" syntax. I know there not classes, of course, but I guess that's how I was thinking.
12:37:05 <jkr> s/there/they're
12:37:31 <jkr> byorgey, kmc, hpc : thanks
12:37:42 <kmc> there's no special syntax jkr, but you can emulate it easily
12:38:00 <kmc> let self = A { num = 3, dub = 2*(num self) } in self
12:38:16 <kmc> but it sounds like this isn't the problem you're really trying to solve
12:38:38 <kmc> so much as the solution you would pick in a different language
12:39:30 <jkr> kmc: exactly. Really, this is just a project to learn, and I think I was trying to emulate xmonad's config style a bit more than is possible for what I want.
12:39:44 <kmc> if you *really* want to emulate xmonad's config style, look at the "dyre" package
12:40:12 <jkr> ehh... I'm not sure I'd wish the current state of my xmonad.hs on anyone else anyway.
12:40:36 <kmc> :D
12:40:37 <jkr> better than my .emacs, but not by much.
12:46:00 <roconnor> ddarius: reading Jaynes makes me understand why financial institutions hires physicists.
12:46:25 <roconnor> ddarius: it turns out that physicists spend most of their time solving problems of statistical inference.
12:46:43 <roconnor> ddarius: which turn out to be exactly the same as the problems facing financial institutions.
12:47:09 <djahandarie> Money is just a reflection of our world.
12:47:39 <djahandarie> Types are just a reflection of our values...
12:47:47 <kmc> haha
12:48:07 <ddarius> roconnor: Look up the Feynmann-Kac formula.
12:49:14 <McManiaC_> final patches for monad comprehensions are in: http://hackage.haskell.org/trac/ghc/ticket/4370#comment:48 :)
12:50:26 <ksf> cabal: internal error: configure install plan should have exactly one local ready package.  -- ???
12:50:39 <ddarius> roconnor: But, yeah.  Pretty much everything under statistical mechanics is just statistics and not actually physics.
12:50:45 <dcoutts_> ksf: can you reproduce it reliably?
12:51:22 <dcoutts_> ksf: see http://hackage.haskell.org/trac/hackage/ticket/805
12:51:28 <ksf> yep.
12:51:38 <dcoutts_> I currently cannot reproduce it so details would be useful
12:51:40 <ksf> but then I realised that I didn't nuke my old .cabal after upgrading
12:51:42 <dcoutts_> see the ticket ^^
12:51:48 <dcoutts_> ksf: please don't
12:51:57 <dcoutts_> there is no need to nuke anything
12:52:09 <roconnor> ddarius: btw, do you know anything about freely generated categories?
12:52:16 <ksf> well, for one, I won't be using that stuff anymore.
12:52:43 <ksf> ...and nuking bin lib logs packages and share fixed stuff.
12:52:51 <dcoutts_> sigh
12:53:07 <dcoutts_> ksf: meaning you can't reproduce it anymore?
12:53:16 <ksf> yep.
12:53:17 <ddarius> roconnor: Whatever I remember/guess.  Not anything particularly deep.
12:53:24 <ksf> but I've got -v logs.
12:53:28 <ksf> ...which don't tell anything.
12:53:31 <dcoutts_> :-)
12:53:40 <roconnor> ddarius: do you know what they are? :D
12:53:52 <ksf> now it happens again, after I did cabal update.
12:54:00 <dcoutts_> ksf: ah ok, good
12:54:45 <dcoutts_> ksf: so you're using the new cabal-install-0.10 right?
12:55:09 <dcoutts_> so what command are you running, and other stuff to paste includes ghc-pkg list
12:55:09 <ksf> http://hpaste.org/44520/cabal_error
12:55:12 <ksf> yep
12:55:23 <hpaste> ksf pasted "cabal error"  http://hpaste.org/44520
12:55:27 <ksf> that's trying to configure libmpd-0.5.0
12:55:44 <dcoutts_> ksf: running "cabal configure" in the mpd dir
12:55:50 <ddarius> roconnor: It depends on what you are freely generating from.
12:56:14 <ksf> http://hpaste.org/paste/44520/cabal_error_annotation#p44522
12:56:20 <ksf> dcoutts_, see the paste.
12:56:28 <hpaste> bobgill pasted "visudo"  http://hpaste.org/44521
12:56:34 <roconnor> ddarius: That is what I'm trying to figure out :D.  Now that you mention it, I guess there could be several choices.  I hadn't thought about that before.
12:56:52 <mreh> what is a Parsec ByteString () Char reading? A Word8 as an ASCII value?
12:56:55 <roconnor> ddarius: anyhow, I'm trying to dream up an formal language for describing diagrams that people draw on the chalkboard
12:57:03 <roconnor> ddarius: or better, find one that someone has already written.
12:57:06 <dcoutts_> ksf: yay! I can reproduce it...
12:57:15 <dcoutts_> ksf: thanks, I'll investigate
12:58:32 <Loulou> helloooo everyonr
12:59:05 <hpc> hello world!
12:59:15 <roconnor> > "hello world!"
12:59:26 <hpc>   "hello world!"
12:59:38 <roconnor> > text "hello world!"
12:59:51 * hpc is done spamming
12:59:54 <roconnor> :)
13:01:15 <mreh> @bots
13:02:53 <Veinor> poll: when I get pokemon black
13:02:59 <Veinor> should I name my 'mon after types or typeclasses?
13:03:15 <Zao> Morphism prefixes.
13:03:22 <Veinor> haha
13:04:59 * Jafet mumbles something about black not even being a colour
13:05:47 <hpc> Zao: good choice
13:09:19 <kmc> what are there like 700 goddamn pokemon now
13:09:31 <kmc> i'm starting to think they're just making them up
13:10:14 <hpc> kmc: as opposed to...?
13:10:18 <hpc> :P
13:12:25 <Veinor> it's like 700-ish, yeah
13:13:38 <Jafet> Imagine if they made that part of a junk food wrapper collection contest
13:14:15 <roconnor> adjuctions seems like lax equivalences
13:20:10 <mreh> @instances Stream
13:20:15 <mreh> oh yeah
13:20:31 <Eduard_Munteanu> @bots
13:20:56 <dcoutts_> ksf: ok, figured it out. It's a bug and it's my fault :-)
13:26:29 * hackagebot representable-tries 0.3.1 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-0.3.1 (EdwardKmett)
13:26:54 <roconnor> In the catsters video adjuctions 1 at 8 minutes she says that the trangle law means that the composition of these two 2-cells is equal to 1.  What does it mean for the composition of two cells to be equla to 1? --  http://www.youtube.com/watch?v=loOJxIOmShE
13:27:27 <mercury^> roconnor: do you know what a two cell is?
13:27:31 <Eduard_Munteanu> @bots
13:27:36 <roconnor> mercury^: kinda
13:27:42 <Eduard_Munteanu> Ah.
13:27:52 <mercury^> roconnor: 1 is the identity 2-arrow of some 1-arrow.
13:27:54 <dcoutts_> ksf: do you need a workaround or can you install libmdp? I have a workadound if you need it.
13:27:56 <mercury^> As in id.
13:28:17 <ksf> runhaskell Setup.lhs works just fine.
13:28:28 <ksf> I got all of the (bumped) dependencies needed.
13:28:43 <mercury^> roconnor: you can ask if you want to know more about that whole 2-business. :)
13:29:45 <roconnor> mercury^: so she is saying that the "composition" of eta and epsilon is the identity natural transformation from F.1 => 1.F
13:30:33 <mercury^> roconnor: I have not looked at that video, but I suppose it concerns the unit and counit of the adjoint functors?
13:30:40 <roconnor> yes
13:32:13 <mercury^> Using those you have maps R => (RL)R => R(LR) => R and L => L(RL) => (LR)L => L; They have to be identities.
13:33:48 <roconnor> mercury^: actually, how does one "compose" unit and counit since they it appears that it is neither horizontal nor vertical composition.
13:34:34 <ddarius> One of the triangle equalities is F;_F = id_F
13:34:38 <mercury^> It is vertical composition.
13:34:38 <roconnor> I mean how does one do this compostion in an abstract 2 category
13:35:05 <roconnor> oh
13:35:06 <Cale> In an abstract 2-category, it's part of the definition of the category
13:35:09 <mercury^> roconnor: you do horizontal composition with 1_R and 1_L, then compose the whole thing vertically.
13:35:18 <roconnor> mercury^: ah
13:36:08 <mercury^> roconnor: In general you would also need an associator to get from (RL)R to R(LR), but in the case of functors that is an equality.
13:36:22 <mercury^> Therefore the category of categories is also called a _strict_ 2-category.
13:36:33 <roconnor> oh?
13:37:22 <roconnor> can you clarify the difference between a strict 2-category and a general 2-category?
13:37:34 <mercury^> As an example of a 2-category that is not strict, you can consider any of the common examples of monoidal categories (sets, representations of a group, vector spaces)
13:38:16 <mercury^> roconnor: the idea behind 2-categories is that sets of morphisms from ordinary categories are replaced by categories of morphisms.
13:38:22 <mreh> No instance for (Stream ByteString m Char)
13:38:40 <mreh> what?
13:38:43 <roconnor> mercury^: yes, I understand that they are category enriched categories
13:39:10 <mreh> I've got Text.Parsec.Prim in scope
13:39:11 <roconnor> but I don't quite see where an associator fits in
13:39:12 <mercury^> But then all the structure maps and equalities, such as composition and associativity, should only hold up to isomorphism.
13:39:33 <roconnor> ah, hmm
13:40:24 <Cale> The other sort of 2-category is also known as a weak 2-category
13:40:30 <roconnor> ok, I can imagine that
13:40:34 <Cale> The strict is for contrast
13:41:05 <roconnor> thanks. I think I get this section of the video
13:42:22 <roconnor> I like this 2-cell stuff
13:42:35 <Cale> Those triangle identities are also really cute when you turn them into string diagrams
13:42:38 <roconnor> I find the idea of natural transformations more clear this way
13:42:51 <Cale> They say that you can pull a wiggle straight :)
13:43:24 <Cale> (it's always nice when the laws for the things you're defining have a nice topological presentation :)
13:43:39 <micahjohnston> does anyone want to talk about the design of a temporal/reactive functional programming system?
13:43:44 <micahjohnston> I need ideas
13:43:45 <roconnor> Cale: isn't category theory all about homotopy anyways?
13:44:26 <ddarius> mreh: The instance is in Text.Parsec.ByteString
13:44:26 <Cale> roconnor: Yeah, natural transformations can be thought of as the natural way to define homotopies of functors.
13:45:18 <ddarius> roconnor: Well, homotopy is way too specialized a concept to simply say that that is what category theory is about.
13:45:20 <mercury^> Homotopy is more about (\infty,1)-categories. There all cells of dimension greater than 1 have to be invertible.
13:45:25 <Saizan> mreh: the problem might be that you've to specify which m you want
13:46:12 <Cale> Well... suppose we have two parallel functors F, G: C -> D, then we'll define a homotopy of functors F -> G to be a functor H: C x I -> D, where I is the "interval" category with two objects and one arrow
13:46:20 <Cale> (one nonidentity arrow)
13:46:23 <Cale> satisfying:
13:46:30 <Cale> H(X,0) = FX
13:46:34 <Cale> H(X,1) = GX
13:46:37 <mercury^> roconnor: string diagrams are rather related to Poincar duality.
13:46:38 <c_wraith> Hmm.  Looks like Monad Comprehensions will be in GHC 7.2 as an extension
13:46:53 <Cale> H((a,id_0): (X,0) -> (Y,O)) = Fa
13:47:01 <Cale> H((a,id_1): (X,1) -> (Y,1)) = Ga
13:47:01 <ddarius> However, if you consider a topological as your set of objects.  Continuous paths as your arrows.  Then nice topological ideas pop out quite quickly.  For example, Hom(x,y) is only inhabited if x and y are path connected.  A homotopy is the natural notion of 2-cell.
13:47:35 <Cale> Then whenever we have such a homotopy of functors H, we have the following diagram of arrows in D
13:47:57 <Cale> er, for any a: X -> Y in C
13:48:19 <Cale> H(X,0) --- H(a,id_0) ---> H(Y,0)
13:48:30 <Cale>   |                          |
13:48:43 <hpaste> luite pasted "ghc.exe: *** Couldn't reserve space for cygwin's heap"  http://hpaste.org/44525
13:48:49 <Cale> H(id_X,u)                    H(id_Y,u)
13:48:53 <Cale>   |                          |
13:49:01 <Cale>   v                          v
13:49:07 <ddarius> I a.k.a. 2.  The collection of functors 2 -> C is isomorphic to the collection of arrows of C.  So Cx2 -> D is 2 -> D^C, i.e. it's an arrow in the functor category.
13:49:15 <Cale> H(X,1) --- H(a,id_1) ---> H(Y,1)
13:49:23 <copumpkin> fucking hpaste broke Cale's diagram
13:49:25 <luite> sorry for the paste in the middle of your diagram :)
13:49:26 <copumpkin> @get-chrisdone
13:49:44 <Cale> and H(a,u) going along the diagonal
13:49:47 <cinema> Does anybody know how to get the list of out-of-date packages on Hackage. 'cabal upgrade --dry-run' used to do that, but is deprecated now. What replaces it ?
13:49:50 <ddarius> copumpkin: Aren't you supposed to be proving stuff?
13:49:53 <mreh> turn on the lambda projectors
13:49:55 <Cale> u being the unique arrow in the category I
13:50:02 <copumpkin> ddarius: took a break to work on liopcodes :)
13:50:05 <dons> Cale: we won. -XMonadComprehensions 
13:50:11 <Cale> dons: woot!
13:50:23 * copumpkin has to run
13:50:28 <ddarius> Curses.
13:51:11 <shachaf> dons: Is that in the new GHC release?
13:51:18 <mercury^> What does it do?
13:51:20 <dcoutts_> dons, Cale: thanks to McManiaC for all the hard work
13:51:39 <Cale> We can define eta_X = H(id_X,u), and replace the H(a,id_0) and H(a,id_1) with Fa and Ga respectively
13:51:56 <dcoutts_> cinema: you can try cabal install world --dry-run, but don't rely on it too heavily yet
13:51:57 <Cale> and you'll see that that square turns into the definition of a natural transformation
13:52:15 <Cale> with the diagonal arrow helping is show that the diagram commutes :)
13:52:28 <roconnor> @free foo :: (F x -> y) -> (x -> G y)
13:52:36 <roconnor> damn no lambdabot
13:52:47 <cinema> dcoutts: Thanks. I'm going to try it
13:53:20 <dcoutts_> cinema: this is with cabal-install-0.10
13:53:44 <cinema> dcoutts_: yes, I installed it today
13:54:08 <roconnor> foo (g . $mapF f) = foo g . f
13:57:45 <revenantphx> > 1 + 1
13:57:48 <revenantphx> D:
13:58:13 <Jafet>   3
13:58:19 <dcoutts_> cinema: difference with cabal install world is that it only looks at upgrading packages that you directly installed, not all dependencies that got pulled in but you never installed explicitly
14:00:06 <cinema> dcoutts_: I installed everything by hand, so it will be perfect for me
14:00:10 <roconnor> you know, I think category theories would spend less time proving their transformations are natural if they just wrote lambda terms and said by "Renyolds abstraction theorem this is a natural transformation"
14:00:43 <ddarius> I would say often naturality is taken for granted in that kind of context.
14:01:01 <roconnor> oh
14:01:25 <ddarius> However, it's interesting to work through explicitly proving that the free monoid adjunction is an adjunction.
14:02:06 <roconnor> hey, she is just about to do that I think
14:02:07 <mercury^> In what sense is that information free?
14:02:33 <roconnor> mercury^: by renyold's abstraction theorem?
14:02:43 <mercury^> What exactly does that theorem say?
14:02:52 <roconnor> mercury^: It isn't entirely free.  You need to write a lambda term I guess
14:02:58 <dcoutts_> cinema: sorry, I should have been clearer, if cabal install world --dry-run work, then it'll (probably) work without --dry-run too. What may happen however is that cabal install world --dry-run fails to find a way of installing everything simultaneously and will fail with some message about constraint conflicts.
14:03:01 <roconnor> that probably restricts what categories you can write this for.
14:03:09 * roconnor is mostly interested in Hask
14:03:10 <mercury^> And then you know that two functors are an adjoint pair?
14:03:17 <dcoutts_> cinema: but if it works, it works, there's no need to do it by hand in that case.
14:03:36 <mercury^> Also, is it not Reynold?
14:03:43 <roconnor> mercury^: any polymorphic function F a -> G a between functors F and G is a natural transformation.
14:03:49 <hpaste> megajosh2 pasted "Parse error in build-depends"  http://hpaste.org/44526
14:04:08 <roconnor> mercury^: Reynold yes I think
14:04:55 <mercury^> roconnor: ok, but how does that show that the obvious guess for the free monoid functor is the correct choice indeed?
14:05:20 <roconnor> oh I don't think it does that
14:05:36 <mercury^> Ok. Because what ddarius said seemed to mean that.
14:06:12 <cinema> dcoutts_: oops, 'cabal install world --dry-run' gives: cabal: There is no package named 'world'.
14:06:12 <megajosh2> Hey, can anybody tell me what's wrong with my .cabal file? http://hpaste.org/44526/parse_error_in_builddepends
14:06:25 <megajosh2> It says it can't parse the Build-Depends: section
14:06:28 <megajosh2> But I'm not sure what I'm doing wrong
14:06:57 <Saizan> you need commas, i think
14:07:05 <megajosh2> Oh okay
14:07:08 <megajosh2> ...heh
14:07:11 <megajosh2> So simple
14:08:38 <dcoutts_> cinema: doh, I broke the command target parser :-) wait for the next point release
14:09:09 <cinema> dcoutts_: OK, I'll try it next time
14:09:31 <dcoutts_> cinema: thanks for the bug report :-)
14:10:13 <cinema> dcoutts_: Thanks for your help
14:17:16 <roconnor> foo (g . $mapF f) = foo g . f  implies foo ($mapF f) = foo id . f
14:23:05 <roconnor> see, now she is proving foo id is natural, but it has to be because it is polymorphic :D
14:28:47 <mercury^> roconnor: hrm, that seems to be something specific to Hask though. Polymorphism of F a  G a for Set valued functors F and G would simply mean that you have one map between F a and G a for every object a of your index category, right? It is easy to construct a counterexample then.
14:28:58 <ddarius> mercury^: Actually, it doesn't hold in Hask.
14:29:18 <mercury^> Yeah, I was wondering about that next. :)
14:29:21 <mercury^> Where does it hold then?
14:29:31 <roconnor> mercury^: yes, you need it to be parameteric for it to imply naturality
14:29:52 <mercury^> And what makes such a collection of maps parametric?
14:30:15 <Cale> mercury^: That it's a polymorphic function of type  forall a. F a -> G a
14:30:24 <roconnor> one thing that makes a collection of maps parameteric is that it can be defined in as a lambda term in system-F.
14:30:38 <Cale> That level of polymorphism is actually stronger than naturality alone
14:30:55 <Philonous> Where did edwardk's IxContT-implementation go since he chopped up category-extras?
14:31:09 <ddarius> It also covers cases not covered by naturality (but covered by dinaturality.)
14:32:14 <mercury^> Cale: stronger in what way?
14:32:41 <ddarius> roconnor: Also, what is the counit of the free monoid adjunction?
14:33:40 <roconnor> ddarius: you mean as a lambda term?
14:34:13 <ddarius> In some explicitly constructive notation.
14:35:23 <ddarius> (You could cast it as a "polymorphic" Set function though you'd need to jiggle things a bit.)
14:35:26 <roconnor> assuming you are given alpha :: (F a -> b) -> (a -> G b) and beta :: (a -> G b) -> (F a -> b) which are inverses of each other then counit = beta id
14:35:42 <ddarius> Explicitly, what is it.  I'm not giving you anything.
14:36:03 <roconnor> ddarius: why are you asking me this?
14:36:15 <ddarius> The counit is always "beta id", that doesn't tell me anything at all about the category of monoids.
14:37:26 <ddarius> However, if you want to explicitly spell out beta, that's fine as well, but more complicated than explicitly spelling out the counit.
14:37:32 <roconnor> ddarius: I don't understand the purpose of your question.  You know the answer better than I do.
14:38:56 <ddarius> roconnor: What's the point of exercises in books?  The author certainly knows the solutions better than the readers.
14:39:08 <gracenotes> @botsmack
14:39:23 <gracenotes> :(
14:39:38 <roconnor> okay, well I guess a monoid is some sort of dependent record Sigma U:Type; e : U, * : U -> U -> U.
14:39:55 <Cale> mercury^: That's a good question. It implies naturality, but when you define a natural transformation, all that's required of the components at each object is that the naturality squares commute -- the components themselves can be defined any way you like provided that happens. With polymorphic functions, you get one definition essentially, and the naturality squares are commuting for a "trivial" reason in some sense.
14:39:58 <roconnor> the projection function U :: Monoid -> Type is the forgetful functor
14:40:37 <roconnor> we should be able to build List :: Type -> Monoid
14:41:07 <roconnor> List X = {U := [X]; e := []; * = append}
14:41:25 <Cale> mercury^: I'm not 100% sure how to precisely characterise the sense in which polymorphism is stronger than naturality though -- it would be interesting to at least have some examples of natural transformations in Hask which didn't correspond to parametrically polymorphic functions.
14:41:45 <Cale> mercury^: Probably generic programming can provide some.
14:41:50 <roconnor> so counit :: List (U X) -> X  I think
14:42:06 <ddarius> roconnor: Yes.
14:42:09 <Cale> (well, in some related categories of types, anyway)
14:44:17 <roconnor> ddarius: an arrow for Monoids is a monoid homomorphism
14:44:36 <roconnor> ddarius: so the computation portion is counit = mconcat
14:44:51 <roconnor> then we have to check that counit [] = e
14:45:11 <ddarius> What's mconcat using your definitions?
14:45:18 <roconnor> and that counit x  * counit y = counit (x `mappend` y)
14:45:39 <roconnor> mconcat = foldr (*) e
14:46:11 <dolio> I don't think beta is that hard to specify.
14:46:13 <ddarius> (*) and e are free in that expression.
14:46:17 <ddarius> dolio: It isn't.
14:46:25 <roconnor> mconcat = foldr (X.*) X.e
14:46:33 <dolio> In fact, I know what beta should be, but not what counit should be off hand.
14:46:43 <ddarius> roconnor: X is free in that expression.
14:47:05 <ddarius> dolio: It's pretty much forced.
14:47:08 <roconnor> mconcat X = foldr (X.*) X.e  :D
14:47:37 <dolio> Actually, I guess I do know.
14:47:40 <roconnor> ddarius: counit is polymorphic in X
14:47:41 <ddarius> roconnor: Good.  Now we aren't completely ignoring X.
14:47:42 <roconnor> sorry
14:48:16 <roconnor> counit :: forall X:Monoid. List (U X) --> X
14:48:17 <roconnor> where
14:49:27 <roconnor> X --> Y := Sigma (f :: X.U -> Y.U). f (X.e) = Y.e /\ forall x y. f (x X.* y) = f x Y.* f y 
14:50:30 <roconnor> ddarius: what did I learn?
14:50:54 <McManiaC> dons: "we won"?
14:51:07 <ddarius> That this isn't a term in System F.  This isn't of the form forall x : *.
14:53:13 <roconnor> what if I write counit :: forall X:*, (X,X->X->X) -> [X] -> X ?
14:53:30 <ddarius> roconnor: The result should be a monoid, not a type.
14:54:39 <ddarius> Also, the free theorem for that will be "different" from the naturality condition we want (though I believe it will, in this case, imply it.)
14:55:11 <roconnor> well, if it implies it, that is just as good :D
14:55:13 <ddarius> (assuming, of course, we also provide proofs that the passed in operator is associative and the element is unit.)
14:55:56 <roconnor> ddarius: this is more or less what Janis Voigtlander does isn't it?
14:56:11 <roconnor> in "Free theorems involving type constructor classes"
14:56:40 <roconnor> hmm
14:56:53 * roconnor wonders if Monoid counts as a type constructor class.
14:57:02 <roconnor> oh right, Monids are easier
14:57:23 <roconnor> I write counit :: forall X:*, (X,X->X->X) -> [X] -> X like I do above
14:57:27 <roconnor> I get a free theorem.
14:57:45 <roconnor> I use it to easily prove the real naturality condition like you say
14:57:49 <ddarius> Not the right free theorem unless you add more stuff (namely the proofs.)
14:58:16 <ddarius> In fact, that's not the write type.  As I said, the result needs to be a monoid not a type.
14:58:19 <roconnor> so, lets call it a 50% off theorem.
14:59:49 <ddarius> There are definitely relationships between naturality, but they both provide nuances that make them not equivalent.
15:00:09 <ddarius> (And not a special case of the other.)
15:01:14 <roconnor> let me see
15:03:36 <applicative> McManiaC good work! (Now that I've figured out what 'we won' means) 
15:03:55 <roconnor> we need to show for any homomorphism h from a monoid X to a monoid Y that h (counit (e_X, *_X) l) = count (e_Y, *_Y) (fmap h l) right?
15:04:39 <McManiaC> applicative: who was fighting anyway? :D
15:04:55 <roconnor> but our free theorem says h (counit (e_X, *_X) l) = counit (h(e_X), ???) (fmap h l)
15:05:02 <roconnor> oh god, I have no idea what goes in ???
15:05:19 <applicative> McManiaC, I didn't get that part, just the result itself.
15:05:32 <McManiaC> :D
15:05:34 <McManiaC> ok
15:05:53 <applicative> which will be really wonderful. 
15:07:16 <ddarius> roconnor: Yeah, that would be because in (X, X -> X -> X, [X]) -> X, the first part isn't functorial in X.
15:08:39 <roconnor> :(
15:09:06 <roconnor> ddarius: what does lambdabot say the free theorem is?
15:09:42 <sm> what rule makes "cabal update; cabal install cabal-install" today pick version 0.8 ?
15:09:48 <ddarius> (So incidentally, when changing from forall X:Monoid. L(U(X)) -> X, to forall X:*.(X, X -> X -> X) -> [X] -> (X, X -> X -> X) You lost your functorial structure.
15:10:14 <ddarius> roconnor: It will say something, it's pretty hairy though.
15:10:53 <dcoutts_> sm: the default version specified on hackage
15:10:58 <ddarius> roconnor: As a start, you can view the type as a dinatural transformation and get the dinaturality hexagons which is usually (always?) a statement implied by the free theorem.
15:11:01 <sm> aha
15:11:15 <mreh> what Parser will just give me a bytestring
15:11:34 * sm didn't know hackage could do that
15:11:49 <dcoutts_> sm: also, cabal-install is a bit special, when I bump the default version on hackage then next time anyone does cabal update, then they'll get prompted that there's a new cabal-install release out.
15:12:07 <dcoutts_> sm: so I only want to do that once its had a bit more testing
15:12:21 <dcoutts_> sm: I've had two bugs reported already since I released
15:12:26 <dcoutts_> (and fixed too)
15:12:55 <sm> nice. I was thinking I'd give 0.10 a whirl
15:13:21 <dcoutts_> sm: go for it, cabal install cabal-install-0.10.0
15:13:35 <sm> done! thanks for the improvements
15:13:51 <nejucomo> If I run "cabal register" on a local codebase, shouldn't a different local codebase be able to depend on the former package in it's cabal metadata successfully?
15:14:02 <nejucomo> s/it's/its/
15:14:19 <dcoutts_> nejucomo: yes, though it has to be installed too
15:14:35 <dcoutts_> nejucomo: or alternatively cabal register --inplace, but that's a tad dangerous
15:14:36 <nejucomo> What's different between "registering with the compiler" and "installing" ?
15:14:59 <dcoutts_> nejucomo: it's the difference between installing the files for the package, and telling the compiler where to find those files
15:15:26 <nejucomo> That sounds as if installing is prerequisite for registration.
15:15:34 <ddarius> Also, a natural transformation on an endofunctor on the ordered set N viewed as a category is just a monotonically increasing function N -> N which would take quite a bit of cleverness to express a type in System F that all and only monotonic increasing functions on the naturals.
15:15:34 <dcoutts_> yes
15:15:55 <nejucomo> So when I run "cabal register" and it says it has registered, why doesn't it complain that it is not installed yet?
15:16:44 <nejucomo> Also, how can I install it?  If I run "cabal install <my package name>" or "cabal install ./" both fail (in different ways).
15:17:07 <dcoutts_> nejucomo: hmm, when I try to register a package that's not installed then I get a whole load of error messages. What do you get?
15:17:18 <nejucomo> btw- I'm operating almost solely based on the output of "cabal help" and experimentation with the perspective that should be sufficient (as opposed to online docs).
15:17:21 <dcoutts_> nejucomo: what ghc version are you using?
15:17:31 <dcoutts_> nejucomo: you could look at the user guide btw
15:17:35 <nejucomo> $ cabal register
15:17:36 <nejucomo> Registering slp-0.1...
15:17:53 <nejucomo> ghc version: version 6.12.3
15:18:16 <dcoutts_> nejucomo: sounds like it was already installed then, ghc-pkg would complain
15:18:26 <dcoutts_> nejucomo: does ghc-pkg check report anything about your package?
15:18:36 <dcoutts_> run $ ghc-pkg check
15:18:48 <nejucomo> But if I try "cabal info slp" is claims there's no such package, and in my other project I cannot build due to the missing dependency.
15:19:19 <nejucomo> ghc-pkg check mentions a problem in an unrelated package, and mentions two unrelated packages are broken as a result.
15:19:36 <dcoutts_> nejucomo: ok, and "ghc-pkg list slp" lists it ok?
15:19:36 <ddarius> A natural transformation between a functor, g, between two monoids viewed as categories is an element in the target monoid that commutes with everything in the image of g.
15:19:39 <nejucomo> Will those breakages affect this package even though I (don't think) there's any dependency relation?
15:20:13 <dcoutts_> nejucomo: no it's fine, all packages directly or indirectly depending on a broken package will also be listed as broken
15:20:14 <nejucomo> Is it rude to paste ~4 lines of shell here?  Do people prefer pastebin?
15:20:21 <Zao> nejucomo: Pastebin.
15:20:31 <nejucomo> dcoutts_: That's good to hear.
15:20:43 <Zao> For nothing else, highlighting and not having to scroll when talking about it.
15:20:50 <dcoutts_> nejucomo: if it's listed by ghc-pkg list, and ghc-pkg check says its ok then it should be ok
15:21:05 <nejucomo> Here's ghc-pkg list slp output: http://codepad.org/G7ozrr3h
15:21:30 <dcoutts_> nejucomo: so next issue is why configuring the other package that depends on slp is not working
15:22:02 <nejucomo> Oh weird  Now the other package (the dependent) succeeds at cabal configure and cabal build shows compile errors, not dependency problems.
15:22:13 <nejucomo> I must have missed the critical step.
15:22:32 <nejucomo> Just to be clear: as long as "cabal register" succeeds, I should be able to depend on a package locally, right?
15:22:55 <nejucomo> Sorry to waste time on a non-issue.  Thanks for the help!
15:23:02 <dcoutts_> nejucomo: more or less, but it's usually simpler to just cabal install, rather than the separate steps of copy+register
15:23:20 <dcoutts_> nejucomo: cabal register is not that frequently used really
15:23:49 <nejucomo> dcoutts_: Ok.  Actually I notice that "cabal build" does registration, so that means it is sufficient, right?  It implies building, copying, and registration?
15:24:20 <dcoutts_> nejucomo: ah, no, sorry, that's something else. That's registering it in a local db, because other components in the package may need to depend on the lib.
15:24:34 <dcoutts_> nejucomo: so build does not register it for other packages to use
15:24:47 <random100> hi, is there something already something like a Monad, except that "return" depends on the "current monad in use" ? like (return) m a = ... ?
15:25:01 <dcoutts_> nejucomo: btw, does cabal info now report it as installed? if ghc-pkg list and cabal info disagree then there's a bug I need to fix :-)
15:25:02 <nejucomo> Oh  that's good to know.  Ok, so there's a package-local registration, a per-user registration (inter-package) and a system-wide registration?
15:25:15 <dcoutts_> nejucomo: more or less, yes.
15:25:34 <nejucomo> No, cabal info says "there is no package named slp".
15:26:08 <dcoutts_> nejucomo: ah ok. I think that's fixed in the next release.
15:26:23 <dcoutts_> nejucomo: it's using the packages on hackage as a filter, which is wrong really.
15:27:23 <dcoutts_> nejucomo: yep, that now works in the 0.10 release
15:28:13 * nejucomo checks to see if smooth upgrade of ghc and/or cabal is possible with cabal.
15:32:09 <Eduard_Munteanu> random100: could you expand on that?
15:32:21 <Eduard_Munteanu> What do you want to do?
15:32:55 <ddarius> Center(M) = Nat(Id,Id)
15:34:10 <random100> Eduard_Munteanu, I basically want calculations in finite fields etc. my first idea was: calcSomething = do {setPrime 5; x <- 3 .+. 3; return x}
15:34:37 <ddarius> Nat(Id, Id) is, of course, also a monoid.
15:34:49 * random100 is a beginner
15:35:39 <Saizan> return always depends on the current monad in use..
15:35:40 <Eduard_Munteanu> random100: Oh, you want to do that calculation in Z/5Z?
15:35:47 <random100> for example
15:36:19 <Eduard_Munteanu> You can construct your own monad for that, no special kind of return is needed
15:36:48 <Eduard_Munteanu> In fact, it's something like State.
15:37:29 <ddarius> > let (x .+. y) m = (x + y) `mod` m; calcSomething = do x <- 3 .+. 3; return x; in calcSomething 5
15:37:36 <ddarius> Curse you lambdabot.
15:38:01 <random100> :D
15:38:14 <shachaf> Curse you absence-of-lambdabot, surely?
15:38:31 <ddarius> Incidentally, x <- m; return x is equivalent to m
15:38:41 <nejucomo> Is this a trinary function?  (a <op> b) c = ...
15:38:46 <ddarius> If the monad laws hold (seeing as it is one of the monad laws.)
15:39:11 <Eduard_Munteanu> It's still defined like a normal (binary) infix.
15:39:18 <Eduard_Munteanu> Except it returns a function.
15:39:23 * nejucomo has trouble parsing ddarius's example.
15:39:35 <ddarius> nejucomo: We don't even have n+k patterns now.
15:39:54 <Eduard_Munteanu> e.g. (.+.) :: Int -> Int -> (Int -> Int)
15:40:20 <wolfspaww> Hi guys, does Yampa reflects the further improvements of FRP such as those mentioned by Conal Push-Pull? If not, is there any FRP library appropriate for gamedev that have these modern improvements?
15:40:33 <nejucomo> interesting.
15:40:36 <random100> Eduard_Munteanu, ddarius, thanks
15:40:38 * nejucomo hops over to ghci.
15:40:50 <random100> Eduard_Munteanu, the State Monad looks like what I need
15:41:27 <Eduard_Munteanu> Although I'm not sure about ddarius' definition there.
15:42:05 <Eduard_Munteanu> @bot
15:42:12 * roconnor is looking forward to seeing what the catgories of adjuctions of a (co-)monad is.
15:42:17 <roconnor> *category
15:42:55 <random100> (aah... so the "return"-definitions i read so far were point-free?)
15:44:13 <Eduard_Munteanu> random100: well, many just apply the constructor
15:44:19 <Eduard_Munteanu> like return = Just
15:44:26 <random100> yep, exactly
15:45:24 <hpaste> Evious pasted "Diablo 2 CD Key Decoder"  http://hpaste.org/44530
15:46:27 <Eduard_Munteanu> Yay, FOSS cracks.
15:46:56 <ddarius> nejucomo, Eduard_Munteanu: Fun pre-2010 Haskell parsing problems: http://www.mail-archive.com/haskell@haskell.org/msg03190.html
15:50:17 <Eduard_Munteanu> So it's n+k, but for some other operator? I always thought it worked only for '+' :/
15:50:53 <ddarius> No, it's not n+k.
15:51:32 <random100> Eduard_Munteanu, ddarius, thanks a lot, might going to bother you again :), bye
15:51:51 <Eduard_Munteanu> Hrm, but I also thought we didn't have n-ary infixes.
15:52:12 <Eduard_Munteanu> Oh, wait.
15:52:27 <Eduard_Munteanu> Yeah, it's infix in the first two args only.
15:54:24 <c_wraith> oh, you can define . as (f . g) x = f (g x)
15:55:47 * hackagebot xss-sanitize 0.2.6 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.2.6 (GregWeber)
15:56:01 <hpc> ooh, that's a good lib
16:08:37 <roconnor> is the cokleisli category initial or final?
16:09:02 <roconnor> (in the category of adjuctions for a comonad)
16:12:15 <Eduard_Munteanu> roconnor: /join ##categorytheory   :)
16:19:29 <roconnor> Eduard_Munteanu: that didn't work :P
16:33:56 <napping> The new platform release is tomorrow?
16:34:16 <kmc> go to bed early because haskell platform day is tomorrow!
16:34:20 <kmc> (is it?)
16:34:31 <napping> that's what the release schedule page says
16:34:39 <napping> but then, the front page says "January 2011"
16:34:57 <dons> napping: chillax. all is in motion
16:35:07 <napping> January is just late this year?
16:35:19 <napping> I've got 7.0.2 installed already anyway
16:35:26 <blackdog> napping: it's just been lazily evaluated
16:35:40 <napping> I'd just like a newer version of the platform for the windows partition
16:36:12 <btutt> what version of GCC does windows Haskell use?
16:36:55 <kmc> windows GHC?
16:37:08 <kmc> i'm not sure
16:37:19 <napping> It includes it's own, so I've never cared
16:42:46 <mjrosenb> wait, really?
16:43:30 <kmc> think so
16:43:37 <ddarius> It used to at least.
16:44:20 <kmc> it certainly can't assume the existence of a C compiler (because Windows is a second-class OS for software development) or in any way force one to be installed (because package management is nonexistent on Windows)
16:45:42 <mjrosenb> dumb haskell syntax question of the day: I can label fields of a constructor, and i will get the accessor/selectors functions for free. Is there any way to get something like that that will return a Maybe; Just x if the field exists and is x, and Nothing if it does not exist.
16:45:46 <btutt> Software installation management is not not existent. Unix style package management is though.
16:46:21 <btutt> er, Windows has software installation management support, just not Unix style. Its called Windows Installer
16:46:37 <btutt> Windows has lots of issues, but that isn't one of them
16:46:58 <napping> that provides no way at all to ask the operating system to please go out and install a C compiler
16:47:25 <napping> thus, the haskell platforms windows installer bundling all necessary dependencies
16:47:57 <HugoDaniel> btutt, windows installer is like rpm in fedora... 
16:48:10 <kmc> or like dpkg versus apt
16:48:11 <HugoDaniel> there is no yum equivalent afaik
16:49:15 <kmc> windows is still largely based on a world where to get software you get in your car and drive to a store and buy a cardboard box with a shiny disc inside
16:50:57 <HugoDaniel> hmm, just took a quick look at the computer languages shootout
16:52:17 <HugoDaniel> haskell takes quite a beating in some of those tests
16:53:43 <Eduard_Munteanu> mjrosenb: not quite that, but you might want to take a look at http://www.haskell.org/haskellwiki/Extensible_record
16:53:49 <Bynbo7> hgolden: which ones specifically? (binary trees is known to be biased against what haskell is good at)
16:54:09 <Bynbo7> uh, HugoDaniel 
16:54:53 <HugoDaniel> k-nucleotide, fannkuch-redux 
16:54:56 <HugoDaniel> and binary trees
16:55:29 <Eduard_Munteanu> mjrosenb: the problem is, undefined fields are just that, undefined, there isn't a kosher way to check for 'undefined' in Haskell.
16:55:42 <Eduard_Munteanu> Well, besides exceptions, but that'd be slow.
16:56:09 <Bynbo7> @version
16:56:14 <Bynbo7> hmm, no \bot
16:56:15 <kmc> checking for exceptions in pure code is not kosher
16:56:26 <kmc> is there a good description of exception-handling performance in GHC?
16:56:45 <Bynbo7> i wasn't aware of exceptions being slow
16:56:45 <Eduard_Munteanu> Yeah, that was hearsay.
16:57:23 <Eduard_Munteanu> Bynbo7: they're probably alright for what they were intended for, but probably not for checking for definedness in tight CPU-bound code.
16:57:40 <kmc> probably?
16:57:41 <btutt> HugoDaniel: Windows doesn't have a dependancy resolver and downloader built in, but Windows Installer lets you wrap itself in one. Dependancy checking is certainly supported out of the box. Although to be honest, having top level products use local installations of dependancies ends up being simpler most of the time. (in terms of libraries and smaller systems) larger systems is where you'd prolly start thinking about needing a pkg manager. Most software 
16:57:41 <btutt> installations of binary code fall into the smaller system category.
16:57:46 <kmc> do you have numbers or a source for that claim?
16:58:09 <kmc> HugoDaniel, fannkuch-redux has GHC Haskell at 3x g++ on the quad-core machine
16:58:18 <kmc> there's room for improvement but i don't think that's terrible
16:58:28 <Eduard_Munteanu> Nope, sorry, but I've heard others say that.
16:59:05 <kmc> someone once told me Haskell is unusable because it has an "O(n^2) slowdown" and was entirely unable to elaborate on what that means
16:59:12 <Eduard_Munteanu> 3x gcc looks pretty usual for Haskell to me.
16:59:47 <kmc> remember that huge amounts of useful software and billions of dollars are made with implementations like Perl, CPython, PHP, and Ruby
16:59:54 <kmc> which are in the 300x - 500x C range
17:00:01 <HugoDaniel> eh
17:00:13 <HugoDaniel> i use haskell professionally, and it kicks all other languages ass!
17:00:18 <kmc> heh
17:00:28 <napping> If I recall correctly, I think exceptions do a bit of stack walking
17:00:35 <HugoDaniel> my plan is to code a brainf*ck backend to ghc
17:00:52 <HugoDaniel> napping, in C++ they do, dont know about haskell
17:01:10 <btutt> I wish GHC had an arm NCG
17:01:19 <Eduard_Munteanu> I'm pretty adamant about performace, though if it doesn't hurt the app's normal usage I guess it's fine.
17:01:28 <btutt> ;
17:01:45 <Adamant> ADAMANT NOT PRETTY! ADAMANT SMASH!
17:01:49 <Adamant> :P
17:01:51 <Eduard_Munteanu> Exceptions aren't quite fast anywhere.
17:01:52 <Bynbo7> btutt: using LLVM should help with that
17:01:54 <kmc> btutt, or even registerized via-C for ARM
17:01:59 <Eduard_Munteanu> :))
17:02:10 <kmc> (iirc registerized via-C is competitive with NCG; the main advantage of NCG is greatly reduced compile times)
17:02:10 <btutt> I didn't think ARM had a registered C?
17:02:16 <Bynbo7> i think the problem is the RTS more than the code generation
17:02:25 <HugoDaniel> yeah, i think about performance, and then i find myself doing stuff like: Map.lookup . Map.map . Map.filter . Map.map 
17:02:26 <HugoDaniel> :P
17:02:26 <btutt> or is that the GHC-iphone set of patches?
17:02:44 <kmc> btutt, neither mainline GHC nor the iPhone patches have a registerized ARM backend
17:02:47 <kmc> of any kind
17:02:53 <kmc> GHC may have supported it long ago but not recently
17:03:01 <HugoDaniel> there should be a way to do all those operations in one pass
17:03:29 <kmc> ideally the Map library should come with fusion rewrite rules so you don't have to think about it
17:04:01 <kmc> but you could use different Map API functions
17:04:26 <HugoDaniel> kmc, yeah, i learned to use the mapMaybe and others like that
17:04:45 <Eduard_Munteanu> @bots
17:04:54 <kmc> no point doing map.filter.map if you're only doing lookup on that result
17:05:40 <HugoDaniel> kmc, yeah, i end up doing that for inner maps
17:06:15 <HugoDaniel> maps inside maps
17:06:40 <Eduard_Munteanu> Ew.
17:06:47 <Eduard_Munteanu> Map.map Map.map
17:06:55 <kmc> haha
17:07:37 <kmc> if you're looking for speed improvements on Map, you might find bigger gains by moving to a different type
17:07:38 <Bynbo7> hmm, is there really much difference between Map a (Map b c) and Map (a,b) c?
17:07:55 <Bynbo7> they seem to have exactly the same amount of information
17:08:00 <Eduard_Munteanu> I've seen IntMap provide substantial speedups in some cases.
17:08:10 <Bynbo7> though, maybe the former is better in some cases
17:08:11 <hpc> Bynbo7: it's implementation details
17:08:17 <hpc> in one, you look up by a, then b
17:08:29 <kmc> fromList [('x', fromList [])]
17:08:32 <kmc> you can't represent that in the latter
17:08:36 <hpc> in the other, you are looking up by both, which is different in i don't know ways
17:08:41 <Bynbo7> ah indeed
17:08:48 <kmc> sometimes there's a difference between "no x" and "there's an x with no y"
17:09:10 <kmc> i think IntMap is substantially faster in most appropriate cases
17:09:14 <Bynbo7> maybe Map (a,b) (Maybe c) then
17:09:19 <kmc> when your keys aren't Int, you can often massage them to be
17:09:23 <Bynbo7> but that's still different
17:09:24 <kmc> i.e. EnumMap, hashmap
17:09:47 <McManiaC> C:/ghc/ghc-7.0.1.20101215/mingw/bin/ld.exe: cannot find -lxml2
17:09:51 <kmc> the performance of (Map a (Map b c)) will be totally different from (Map (a,b) c)
17:10:04 <ksf> @vixen where's lambdabot?
17:10:07 <McManiaC> I told him where libxml2.dll is, but I still get that error - ideas?
17:10:32 <Eduard_Munteanu> I still think hashtables are awesome, for example when you have a constant / limited inserts followed by huge amounts of lookups.
17:11:03 <Eduard_Munteanu> *limited number of
17:11:18 <kmc> yes, but hash-mapped tries (like "hashmap" provides) have many of those advantages but also allow graceful and efficient pure-functional updates
17:12:08 <Eduard_Munteanu> kmc: are those O(1) lookup?
17:12:14 <kmc> yes
17:12:25 <aristid> hmm, maybe "perfect hashmap" containers would be nice. which try to find a perfect hash function for the input data, even if that requires some one-time computation
17:12:57 <Eduard_Munteanu> I wonder how they fare in the shootout, many people back then were going like "so what if it's slower, it's not like you *need* hashmaps in Haskell" kinda talk :)
17:13:11 <kmc> the Algorithms 101 student complains that trees are soooo much slower than hashtables
17:13:17 <kmc> because O(log n) is soooo much slower than O(1)
17:13:29 <kmc> well, log n is less than 100
17:13:43 <Bynbo7> tibbe's new hashmap type thing is pretty cool (the HAMT based one)
17:13:43 <ksf> it's all about the cache misses, dummies.
17:13:49 <lispy_> hashtables are not really O(1) tho
17:13:53 <gwern> aristid: iirc, wouldn't perfect require you to know the input data in advance? so it'd have to be template haskell or something...
17:14:02 <ksf> and it's easy to fail on that front even if you're a hashtable.
17:14:06 <kmc> and hash tries aren't O(log (# elements)); they have a fixed maximum depth based on the number of bits in the hash value
17:14:16 <aristid> gwern: the idea is that you would determine the hash function at runtime
17:14:19 <hpc> hash tables are O(1) assuming one item to each bin
17:14:27 <kmc> and yes, caching dominates instruction count to an incredible degree
17:14:33 <ksf> the only truly O(1) cache misses hashtable I know of is hopscotch.
17:14:33 <roconnor> and assuming O(1) bins
17:14:49 <Eduard_Munteanu> It's really easy to make hashtables that are O(1) in Most Cases (tm) 
17:15:02 <Eduard_Munteanu> especially if specifically tailored to your application
17:15:04 <kmc> today's CS schools churn out a lot of people who are very opinionated about hash table performance but haven't even heard of caching
17:15:14 <dibblego> ha
17:15:42 <mathijs> Hi all, I'm trying to pattern match on a type that has ExistentialQuantification and I get some weird error about a "skolem". Do I need to enable ScopedTypeVariables and put the expected type in the match? or is there a better way?
17:15:46 <Eduard_Munteanu> The main problem I see with hashtables is that they're messy to enumerate.
17:16:13 <lispy_> mathijs: a skolem is like a type variable variable
17:16:14 <hpc> kmc: honestly... today's CS schools churn out people who are ignorant of both
17:16:18 <kmc> Eduard_Munteanu, the main problem i see is that there's no way to update them pure functionally
17:16:20 <hpc> that's a rant for later though
17:16:34 <Heffalump> it's more like a type variable constant
17:16:39 <napping> I don't know why people always talk about "perfect hashing" as if it requires a bijection onto the bins
17:16:41 <Eduard_Munteanu> kmc: hm? I'm sure somebody can concoct a DiffArray-like interface for it.
17:16:48 <kmc> which will suck, just like DiffArray does
17:16:51 <lispy_> Heffalump: hmm, an instantiated type variable?
17:17:06 <napping> The key idea is that WHP hashing n items into n^2 bins has no collisions
17:17:07 <Eduard_Munteanu> kmc: um, AFAIK, DiffArray sucks *only* because of its synchronization.
17:17:09 <kmc> and everyone knows pure functional programming is useless academic wankery, but everyone also knows that concurrent programming is serious business and the next big challenge blah blah
17:17:33 <lispy_> mathijs: more to the point, I can't recommend much without more context.  Maybe a code snippet on hpaste?
17:17:36 <kmc> and wouldn't it be nice if some people had already thought about data structures with instant snapshotting and lockless optimistic update semantics
17:17:38 <mathijs> lispy_: yeah, I had that feeling. so am I correct to assume my problem has to do with pattern matching a datatype that has ExistentialQuantification?
17:17:51 <mathijs> lispy_: sure... 1 moment
17:17:54 <napping> so, you hash n items into n bins getting O(lg n) items in the biggest bin WHP, and use a *hashtable* for the chains
17:17:54 <lispy_> kmc: maybe take this to #haskell-rant?
17:17:58 <kmc> ;)
17:18:02 <kmc> i'm done anyway
17:18:10 <Eduard_Munteanu> So an unsynchronized Diffarray could be faster, maybe.
17:18:17 <napping> and those can be square of the size, for an overall structure that is O(1) in space and time
17:18:53 <Bynbo7> is there a reason that hashtables of hashtables don't seem to be that common?
17:18:54 <lispy_> mathijs: If I understand you correctly, I think that could be a cause
17:19:03 <kmc> how will an unsynchronized DiffArray work without synchronization Eduard_Munteanu?
17:19:10 <kmc> and how well will it work in a heavily loaded concurrent situation?
17:19:13 <aavogt> mathijs: you're trying to make sure something has the same type as a variable which has ExistentialQuantification?
17:19:21 <Eduard_Munteanu> kmc: obviously it wouldn't work for concurrent programming
17:19:28 <kmc> how would it work at all, in Haskell?
17:19:30 <Eduard_Munteanu> Except when using stuff like 'par' maube
17:19:32 <Eduard_Munteanu> *maybe
17:19:36 <kmc> where things are often implicitly concurrent
17:19:42 <kmc> especially if the interface is "pure"
17:19:51 <kmc> it is worth noting that binary trees have much worse cache behavior than high-arity trees
17:20:04 <kmc> yet much of the discussion of trees vs. flat hash tables implicitly assumes binary trees
17:20:11 <lispy_> mathijs: Also, I thought that GHC removed the skolem error message.  What version of GHC is that?
17:20:35 <kmc> i thought the skolem message was new in 7.0
17:20:50 <mathijs> I'm on 7.0.1
17:21:03 <Eduard_Munteanu> I thought implicit paralelism (like 'par') didn't break *Refs / *Arrays
17:21:05 <lispy_> kmc: it was, but I opened a ticket because it was confusing.  SPJ changed it as per my request.  But, his new version may still use the word skolem in it.
17:21:24 <kmc> Eduard_Munteanu, it does once you slap unsafePerformIO . readIORef on it!
17:21:40 <Eduard_Munteanu> Grrr... so that's how DiffArray works.
17:21:53 <lispy_> kmc: skolem is not a common term in haskell literature (google for 'haskell skolem' to see what I mean).  So it seemed like a bad move to me.
17:21:56 <Eduard_Munteanu> I thought it was more subtle.
17:22:07 <kmc> you're proposing to build a mutating data structure and then paper over the mutation with unsafePerformIO and logging tricks
17:22:21 <kmc> in which case it had better be concurrency-safe
17:22:28 <mathijs> lispy_: http://hpaste.org/44531/skolem_error
17:23:00 <Eduard_Munteanu> In any case, a non-SMP-safe DiffArray could be quite useful.
17:23:27 <kmc> Eduard_Munteanu, how?
17:23:54 <Eduard_Munteanu> kmc: well it is fast and comfy to use.
17:24:01 <kmc> comfy?
17:24:17 <kmc> i'm a haskell programmer, i write some totally reasonable pure code, now I pass "+RTS -N2" and my code segfaults
17:24:22 <Eduard_Munteanu> Yes, you just (//) the changes to be done and forget about copying overhead.
17:24:43 <kmc> this is hacks upon more hacks
17:24:54 <Eduard_Munteanu> Hrm, I thought it didn't 'par' behind your back.
17:24:54 <kmc> i don't see how the result could be better overall than "hashmap"
17:25:08 <kmc> Eduard_Munteanu, i write some totally reasonable pure code with "par" in it, of course
17:25:12 <Eduard_Munteanu> :)
17:25:13 <kmc> because this is Haskell and i know "par" is safe
17:25:21 <kmc> and because it's 2011 not 2000 so my computer has more than one core
17:25:40 * Eduard_Munteanu remembers manpages mentioning which functions weren't reentrant :)
17:26:27 <kmc> nothing which claims to be a general-purpose data structure but actually breaks inexplicably on multicore will ever be accepted by the general Haskell community
17:26:31 <mathijs> lispy_: that snippet is not complete I see. I don't loop throug the pollResults yet, but that's because I first need to be able to handle 1 result
17:26:41 <kmc> because it's a huge step backward to those days of non-reentrant functions listed in manpages ;)
17:27:15 <Eduard_Munteanu> Admittedly, DiffArray's performance is considered bad, and a bug.
17:27:31 <Eduard_Munteanu> Perhaps it could be better, if they used some other kind of locking.
17:27:37 <Eduard_Munteanu> (MVars now, right?)
17:27:58 <kmc> Eduard_Munteanu, i'd just use IntMap and not worry about it
17:28:05 <kmc> so much cleaner than unsafePerformIO hacks
17:28:07 <aavogt> mathijs: how is  (sock == receiver)  supposed to work if sock has a type variable which is anything
17:28:30 <Eduard_Munteanu> Yeah, I thought it was more subtle than unsafePerformIO, somehow. I know, it's outright indecent.
17:28:56 <aavogt> what you can do is bundle with the definition of (forall a. ZMQ.Socket a), some way to say   "Am I equal to another socket with any type variable"
17:29:28 <lispy_> yeah, what aavogt said
17:29:31 <mathijs> aavogt: not anything. yeah the type states that, I see. But you can only construct them through constructors so there are limited 'a's
17:29:35 <aavogt> so       data Socket a = Socket { ... ; eqToOtherSocket :: forall b. b -> Bool }
17:29:37 <lispy_> But, I don't think that's what GHC is complaining about here
17:30:00 <lispy_> mathijs: if there are limited 'a's a GADT may be more suitable
17:30:05 <aavogt> mathijs: your definition of ZMQ.S doesn't know that there are limited 'a's
17:31:16 <lispy_> Type classes or GADTs should be able to work here though
17:31:21 <aavogt> GADT seems unnecessary though maybe the syntax is nicer
17:31:47 <lispy_> aavogt: I'm just thinking, there needs to be a mechanism to express a type variable with a constraint
17:31:58 <lispy_> and that's what comes to mind
17:32:47 <mathijs> ok, and can I just use ScopedTypeVariables to put the expected type in my case match patterns? or is that not what they were ment for?
17:33:09 <napping> they seem to work pretty well for that
17:33:11 <lispy_> they work that way, but it still won't type check
17:33:40 <napping> it always seemd a bit heavy to me, but that extension seems to be required to give any signature at all on patterns
17:33:48 <mathijs> because the ZMQ lib is not my code, so rewriting that doesn't sound nice. I'd rather bug the maintainer :)
17:33:58 <lispy_> mathijs: when you pattern match on the existential like that, you get a fresh type variable that is distinct from all other type variables.
17:34:47 <lispy_> mathijs: well, what is the final type here?  GHC claims that the final type mentions your existential type
17:35:14 <mathijs> lispy_: ah, same as using an existing variable in a match with the goal of matching equality, but actually you're shadowing the original one. but then on the type-level?
17:35:14 <lispy_> mathijs: if you could add yet another existential type to package up the returned type so that a2 no longer escapes
17:35:41 <aavogt> it doesn't look like you could even use (==) on Socket anyways http://hackage.haskell.org/packages/archive/zeromq-haskell/0.3.1/doc/html/System-ZMQ.html
17:36:02 <mathijs> aavogt: I added "deriving Eq"
17:36:12 <mathijs> that worked well
17:36:47 <aavogt> as in it was accepted, or the instance did the right thin?
17:36:57 <lispy_> mathijs: I'm not sure what you mean by shadowing, but even if you unwrap the value, use it some how (which you can't), and then wrap it up again, then in the recursive call you'd be unable to unwrap it and get back what you had.
17:37:22 <mathijs> aavogt: as in, I created a few sockets on ghci, compared them, and it seemed to work ok
17:37:54 <lispy_> mathijs: Once a type goes into an existential wrapper type, it's gone.  No one will remember it.  WHen you unwrap it, you get some new distinct type.  If you unwrap it twice, you get 2 distinct types.
17:38:33 <lispy_> IMO, existentials are hard to work with
17:38:41 <lispy_> At least in the ways people try to use them
17:38:43 <mathijs> hmm... so I probably start reading about GADTs and try to change the ZMQ library to it?
17:38:58 <lispy_> mathijs: I'd try something with type classes first
17:38:59 <aavogt> it depends what you're trying to do, you have the same restrictions with GADTs with escaping type variables
17:39:45 <mathijs> lispy_: well, the possible 'a' types are already instances of some class (SType)
17:40:05 <aavogt> mathijs: can you add a type signature to doLoop :: ZMQ.Socket a1 -> ZMQ.Socket a -> ZMQ.Socket a2 -> IO (), which uses -XRank2Types?
17:40:19 <mathijs> aavogt: I'll try
17:40:20 <lispy_> aavogt: actually, with GADTs here there could be a different constructor for each type that mathijs wants 'a' to be instaniated at.  So then no escaping required
17:40:27 <aavogt> this will probably let it accept doLoop, but push the problem elsewhere
17:41:39 <aavogt> lispy_: true, I didn't consider that
17:42:33 <mathijs> aavogt: different error, hpasted
17:42:58 <lispy_> data Socket a where IntSock :: Int -> Socket a; BoolSock :: Bool -> Socket a; etc
17:43:13 <aavogt> mathijs: like     doLoop :: (forall a. ZMQ.Socket a) -> (forall a. ZMQ.Socket a) -> (forall a. ZMQ.Socket a) -> IO ()
17:43:55 <aavogt> hmm, I guess that's not going to work
17:44:15 <mathijs> nope
17:44:24 <lispy_> The simplest solution here would be a record type, BTW
17:44:31 <mathijs> can't match a with those actual types
17:44:54 <Eduard_Munteanu> @bots
17:45:02 <lispy_> If mathijs switches to type classes he'll have this anti-pattern that has a nice record solution: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
17:45:03 <Bynbo7> @botsnak
17:45:09 <shachaf> :)
17:45:32 <aavogt> maybe push the (== controller) and similar to additional arguments to doLoop
17:45:33 <geheimdienst> :D
17:46:07 <aavogt> so       doLoop eqController  ...   :: (forall a. Socket a -> Bool) -> ...
17:46:13 * lispy_ leaves
17:46:27 <Eduard_Munteanu> shachaf just failed the reverse Turing test :P
17:46:34 <mathijs> aavogt: well there's other ways around my problem, but I want something a bit readable and elegant
17:46:39 <mathijs> lispy_: thanks for your help
17:47:06 <mjrosenb> if i have foo = let bar = baz in quux; is there any easy way to get the type of bar?
17:47:15 <mathijs> aavogt: so probably I just need to clear up ZMQ myself. it's not that big & scary
17:47:22 <aavogt> @google ghc-goals
17:47:24 <shachaf> Eduard_Munteanu: :(
17:47:52 <aavogt> mjrosenb: https://github.com/sebastiaanvisser/ghc-goals or make a type error yourself and ghc reports one of the types
17:48:47 <mathijs> jsgf: that's a coincidence :)
17:49:01 <aavogt> mathijs: well there's convenience in using the ZMQ.S wrapper, you just end up pushing the problem somewhere else
17:49:12 <aavogt> if you change the library to use something different
17:49:22 <mjrosenb> aavogt: unfortunately, it has a state transformer, and it prints the type out in a rather non-intuitive way :(
17:49:22 <mathijs> jsgf: I'm just trying to solve a problem with ZMQ here, I see you forked that on github too?
17:50:12 <mathijs> aavogt: yeah. I would like to change the polling code anyway, I want to wire it up with the IO/Event manager
17:50:32 <co_dh> greeting guys, I have a question about representable functor. is List, as a functor, representable ? if yes, by what object ? 
17:50:47 <co_dh> http://comonad.com/reader/2008/representing-adjunctions/#more-67 
17:51:15 <mathijs> aavogt: so the main problem is the wrapper S wrapper? no need to change those socket types and the SType class?
17:52:26 <aavogt> mathijs: does your Eq of Socket actually care what the type variable on Socket is?
17:52:45 <dolio> co_dh: I don't think it's representable.
17:52:46 * aavogt thinks it doesn't, because it probably compares the pointer addresses
17:53:00 <mathijs> aavogt: not at all, I just want to know which socket received a message
17:53:17 <djahandarie> So, I need something a lot faster than highlighting-kate for code highlighting Javascript. Any ideas?
17:53:17 <aavogt> @type (==)
17:53:22 <mathijs> my derived Eq indeed will just compare the Ptr
17:54:00 <aavogt> mathijs: using the Eq restricts the type of the function you need too much, which you could work around by some safe unsafeCoerce
17:54:08 <co_dh> dolio: thanks. is there a representable functor in haskell? other than the 2 example above ? is Maybe representable? 
17:55:15 <mathijs> aavogt: that doesn't ring any bells. sorry :)
17:55:31 <mathijs> aavogt: is that like "casting" in c?
17:55:45 <dolio> co_dh: VecN is representable for all N.
17:56:04 <co_dh> what's VecN?
17:56:13 <aavogt> mathijs: when you have    sock == receiver, you could have   sock == unsafeCoerce receiver, if you're too lazy to use some pointer equality that ignores the type variable on the Socket
17:56:17 <mathijs> aavogt: as in: we can just pretend all types are the same, since we will only look at the pointer
17:56:17 <dolio> VecN a is the type of n-tuples of as.
17:56:39 <dolio> And it's representable by (N ->), where N is the type with N well-defined values.
17:56:59 <aavogt> also do verify yourself that it actually works, because mistakes lead to actual crashes and maybe not all the time
17:57:22 <aavogt> mathijs: because you want a function        eqSocket :: Socket a -> Socket b -> Bool
17:57:38 <djahandarie> Oh wow, the "highlighter" package looks good.
17:57:41 <mathijs> aavogt: ah... that doesn't sound too hard
17:58:01 <aavogt> as far as I can tell, using that stops the type variable from escaping
17:59:06 <mathijs> aavogt: it's not about laziness. I'm just not too good with haskell yet :)  I think I grasp most concepts, but applying them takes time.  but the eqSocket sounds easy... I'll have a try
17:59:39 <kmc> <chrisdone> anyone got a fixed version of the split library for ghc7? some Tolkienesque error messages about skolems escaping
18:01:09 <dolio> co_dh: (T -> A) can be viewed as a T-indexed product of As, though. So I wouldn't expect sums to be representable. That includes Maybe and [].
18:01:13 <dolio> Unless I'm missing something.
18:03:47 <revenantphx> kmc: You know what that makes me think needs to be done?
18:03:55 <kmc> no
18:04:04 <co_dh> dolio: thanks !! I got a better understanding of representable. 
18:04:13 <revenantphx> A parser that reads in images in Elvish and outputs a list of...
18:04:15 <revenantphx> wait for it...
18:04:16 <revenantphx> Tolkiens.
18:04:28 <mathijs> aavogt: it worked! 
18:05:31 <mathijs> aavogt: it was actually very simple indeed. eqSocket did the trick.
18:05:49 <revenantphx> "|
18:05:52 <revenantphx> :|
18:05:57 <revenantphx> kmc: too much?
18:07:06 <roconnor> revenantphx: there were groans throughout south Kitchener
18:07:16 <revenantphx> :)
18:07:45 <kmc> haha revenantphx
18:07:52 <shlevy> revenantphx: The twittersphere is now groaning too http://twitter.com/shlevy/statuses/43864255342182400
18:08:10 <revenantphx> XD.
18:08:11 <revenantphx> Wonderful.
18:09:37 <co_dh> another question : is (x->)  the same as Hom(x, - ) as a functor? 
18:10:44 <dolio> Depends.
18:10:58 <roconnor> I pretend it is
18:11:16 <dolio> Most people like to talk about Hask as a category enriched in itself.
18:11:43 <dolio> So they'd be the same.
18:11:53 <Eduard_Munteanu> co_dh: you're welcome to ##categorytheory
18:12:04 <co_dh> thanks. 
18:12:05 <roconnor> Eduard_Munteanu: I see what you did there
18:12:13 <Eduard_Munteanu> :)
18:12:23 <roconnor> you are trying to fragment #haskell
18:12:38 <co_dh> anybody mind me ask category problem here? 
18:12:45 <Eduard_Munteanu> Yes, lower its IQ average :)
18:13:03 <dolio> Actually, it's perhaps not that simple.
18:13:03 <djahandarie> co_dh, wouldn't it make more sense to get all the people who can answer to move into ##categorytheory ? ;)
18:13:05 <Eduard_Munteanu> No, but really it'd be nice to have more people in ##categorytheory too
18:13:21 <shlevy> If only there were some way to be in #haskell and ##categorytheory at the same time...
18:13:31 <djahandarie> shlevy, but wait!
18:13:48 <djahandarie> Arg, this highlighter package totally just segfaulted my code
18:13:49 <roconnor> Eduard_Munteanu: you can joint #constructive-math too.  Now with fewer hashes
18:13:54 <roconnor> *join
18:13:55 <roconnor> *cojoin
18:14:01 <dolio> You could say that Hom(T,U) is the set of Haskell terms that represent functions from T to U or something.
18:14:01 <Eduard_Munteanu> Heh.
18:14:12 <co_dh> I don't like the idea of another ##categorytheory, because #haskell people will forget about category. 
18:14:17 <dolio> Which is similar but not the same as the type of said functions.
18:14:29 <co_dh> In fact, it's in #haskell that makes me believe category is so important. 
18:14:45 <djahandarie> co_dh, I think anyone who is getting anything out of "is (x->) the same as Hom(x , - ) as a functor" is already converted
18:15:30 <co_dh> djahandarie: converted to what ? 
18:15:42 <djahandarie> A believer. A category theory believer.
18:15:53 <co_dh> yep , I'm :)
18:16:01 <Eduard_Munteanu> All praise Yoneda.
18:16:15 <djahandarie> Listen to the word of Mac Lane!
18:16:23 <co_dh> in fact, Yoneda is something I can't understand yet. 
18:16:29 <Eduard_Munteanu> Mac Lane is just a prophet :P
18:17:34 <Eduard_Munteanu> Next thing we'll be shooting arrows at each other, arguing who's the son of Yoneda.
18:44:58 <co_dh> hi, there , is there a book or pdf explain category theory with example from Haskell? 
18:45:12 <ddarius> Not really.
18:45:23 <djahandarie> Anyone have a nicer way to write  \f g p -> f p <=< g p  ? I'm not a big fan of  liftM2 (<=<)  either, it feels a lot harder to understand.
18:45:25 <ddarius> The best you'll get is "Computational Category Theory" using ML.
18:45:38 <ddarius> And then it takes a rather concrete view, but it is interesting.
18:45:41 <djahandarie> I don't think Haskell is a particularly good language for talking about category theory anyways
18:45:55 <napping> the bottoms do mess things up a bit
18:46:21 <ddarius> djahandarie: The real question is whether category theory is a good language for talking about Haskell.
18:46:36 <co_dh> ddarius: thanks. I found Computational member:Category Theory hard to read for me. 
18:47:02 <djahandarie> I don't think that is true either. There aren't many categories used in Haskell
18:47:26 <ddarius> At one point I translated all the ML code to Haskell, but then I lost the code.  I suspect someone else has done it too.  It isn't hard to do; just a bit tedious.
18:47:40 <co_dh> so is there something explained category theory for programmer ? with example from programming language? 
18:48:03 <ddarius> There are a several things aimed at computer scientists.
18:48:16 <co_dh> ddarius: It's a good exercise . 
18:48:25 <ddarius> The one I found most approachable (of the ones I've read) are Barr and Wells ESSLLI lecture notes.
18:49:46 <co_dh> I tried Barr and Wells , but can't follow them much. I like books that have more diagrams, as Awardy's.  but Awardy's has a very few example from programmings , which make it hard for me . 
18:50:33 <napping> I haven't got too far into MacLane, but I think djahandarie is kind of right
18:50:58 <napping> most interesting categorical constructions use several categories and functors and such
18:51:31 <ddarius> It somewhat depends on how you approach it.
18:52:28 <Eduard_Munteanu> Agda/Coq might be better environments to explore such math constructs.
18:53:03 <djahandarie> ddarius, wouldn't it be full of "X from Haskell is Y from category with [Z] catches since it isn't actually it"?
18:53:20 <roconnor> can I construct records using (Foo { fieldA = e1, fieldB = e2 }) ?
18:53:33 <ksf_> djahandarie, fast and loose reasoning is morally correct.
18:53:38 <ksf_> don't bother about bottom.
18:53:58 <djahandarie> Or "X from Haskell can be precisely modeled by Y from category theory, but Y is some complicated-as-hell-thing that has no application outside of modeling Haskell" 
18:54:10 <ddarius> Like monads.
18:54:47 <napping> just the basics of thinking about functions between things rather than so much about maps is pretty useful
18:54:55 <napping> and a little bit about universiality with folds
18:55:12 <ddarius> Well, you could probably do Haskell with just symmetric monoidally closed categories, though maybe you would need closed Freyd categories.
18:57:08 <djahandarie> Is Haskell : symmetric closed monoidal category :: STLC : cartesian closed category?
18:57:50 <ddarius> No, but symmetric monoidal categories let you deal with "commutative" effects like partiality.
18:58:30 <ddarius> I believe a linear lambda calculus with multiplicative products might be the internal language of a SMCC.
18:58:46 <ddarius> If nothing else, SMCCs are often used to model linear logics/calculi.
18:59:20 * djahandarie isn't sure what a linear lambda calculus is
18:59:48 <ddarius> Oh, handy.  I was just about to @tell copumpkin Ping, which wouldn't have worked anyway since I think lambdabot is still missing.
18:59:51 <napping> Also, it seems you can make a reasonable go of internal versions of some constructions
19:00:02 <copumpkin> ddarius: ohai2u
19:00:08 <dolio> You must use arguments exactly once.
19:00:08 <copumpkin> i r lolcat
19:00:32 <napping> make something like a slice category with an "app" function for pairs, etc.
19:00:39 <dolio> \x -> x is linear
19:00:42 <ddarius> copumpkin: So the Druid thing is 4-7pm and Mo is doing something until 6:30pm, so I need to make a plan B for later than that.
19:00:44 <dolio> \x -> (x, x) is not.
19:00:50 <dolio> Nor is \x -> ().
19:00:52 <copumpkin> ddarius: oh okay
19:02:08 <ddarius> Any interesting restaurants / evening places in your part of the town that you want to see?
19:02:44 <ddarius> (Or we could try a Thai restaurant that was recommended to me in Porter Square.)
19:03:10 <copumpkin> ooh, thai sounds good
19:03:22 <copumpkin> nothing really calling to me over here
19:03:42 <djahandarie> I was about to ask what you guys talk about over dinner but I remember what happened last time I asked that question
19:03:59 <Eduard_Munteanu> Are those the places were you get the food served on a naked girl instead of a plate? oO
19:04:07 <geheimdienst> djahandarie: what happened?
19:04:09 <copumpkin> edwardk and I are hacking on mpfr for haskell
19:04:22 * shlevy just looked into #Haskell and saw discussion of food being served on naked girls
19:04:34 <copumpkin> shlevy: in boston? ddarius: we should go there
19:04:46 <ddarius> copumpkin: Heck yeah.
19:05:10 <djahandarie> geheimdienst, I don't know, but when I try to think about it the scars open
19:05:23 <shlevy> copumpkin: Alas, no. I might go to boston for naked girl food.
19:05:29 * shlevy wonders if that sounded creepy
19:05:58 <napping> um, a bit of that, and a bit of not parsing
19:06:37 <napping> what's up in Boston?
19:07:07 <napping> hacking mpfr?
19:07:21 <shlevy> napping: Not sure, but I'm pretty sure copumpkin invited me to go to a restaurant where they serve food on naked women. Also, hacking mpfr. Not sure if we'd be doing both at the same time
19:07:28 <roconnor> whats wrong with CReal?
19:07:49 <Eduard_Munteanu> No no, I was just asking if that's the kind of place.
19:07:54 <geheimdienst> shlevy: oh you should try it, mpfr hacking with naked girls instead of laptops. it's all the rage
19:08:07 <djahandarie> roconnor, it sucks!
19:08:11 <copumpkin> roconnor: fucking slow
19:08:13 <djahandarie> By sucks I mean it is too slow
19:08:18 <roconnor> slow?!
19:08:20 <copumpkin> napping: yep, lots of mpfr 
19:08:28 <roconnor> how many digits of Pi do you want? :D
19:08:31 <roconnor> *pi
19:08:34 <copumpkin> roconnor: 1
19:08:42 <ddarius> copumpkin: Ouch
19:08:54 <roconnor> i digit of pi is pretty fast to get
19:08:57 <roconnor> *1
19:09:09 <copumpkin> I want i digits of pi
19:09:19 <roconnor> copumpkin: well, if you want wrong digits of pi, then go for mpfr
19:09:28 <copumpkin> at least it's fast
19:09:34 <djahandarie> Haha, I thought it was fairly accurate?
19:09:36 <geheimdienst> copumpkin: so when you square the number of digits, you get -1?
19:09:42 <napping> you know what they say about getting wrong answers fast
19:09:52 <copumpkin> no, actually edwardk wants it for an "interval arithmetic"-like thing
19:10:06 <ddarius> Not an affine arithmetic thing?
19:10:43 <ddarius> Actually, knowing edwardk, it will be an affine arithmetic thing.
19:11:27 <co_dh> what's mpfr?
19:11:38 <roconnor> co_dh: a broken implementation of CReal
19:11:43 <Zao> Multiprecision floats
19:12:20 <Eduard_Munteanu> Arbitrary precision?
19:12:24 <napping> roconnor: actually broken broken, or just correctly rounded adjustable precision floats?
19:12:42 <dolio> mpfr is from gmp?
19:12:47 <roconnor> napping: given its complexity, I presume it is actually broken broken
19:13:06 <napping> well, that's what foundational verification is for...
19:13:15 <Eduard_Munteanu> I think I've seen some other software using MPFR, I'm not sure it's that broken
19:13:17 <roconnor> yes
19:13:31 <napping> so, good these folk are hacking on it ;)
19:13:34 <ddarius> napping is easily guided into a trap
19:13:52 <roconnor> Eduard_Munteanu: I've seen software using glibc too ;)
19:14:21 <Eduard_Munteanu> That's a feature, not a bug, (tm).
19:14:35 <roconnor> what a terrible feature
19:15:35 <dolio> Last I looked, mpfr isn't like CReal.
19:15:48 <copumpkin> ddarius: it's actually something like taylor models he wants to do
19:15:57 <dolio> It's like having Doubles of any size you request.
19:16:04 <copumpkin> yeah, it's like that
19:16:05 <ddarius> copumpkin: Indeed.  Check out affine arithmetic.
19:16:12 <roconnor> dolio: I don't think it is like that
19:16:13 <copumpkin> with very precise control of rounding moes
19:16:16 <copumpkin> roconnor: no, it is
19:16:17 <roconnor> copumpkin: really?
19:16:26 <copumpkin> yeah, you say how much precision you want and it does that
19:16:39 <roconnor> thats as bad as maple
19:16:42 <copumpkin> lol
19:16:49 <copumpkin> it's fast
19:16:53 <copumpkin> all that matters
19:16:58 <augustss> copumpkin: so errors accumulate as you compute?
19:16:58 <copumpkin> pi = 3 is super fast
19:17:03 <Eduard_Munteanu> Erm, and pardon me, but isn't fixed-point arithmetic more suitable for arbitrary precision computations?
19:17:30 <copumpkin> guys, this works best for explanations: http://www.mpfr.org/
19:17:31 <copumpkin> :P
19:17:37 <copumpkin> augustss: the taylor model thing?
19:17:42 <ddarius> augustss: That's fine with interval arithmetic, though you may end up with [-inf, inf] as your interval or something equally as useless.
19:17:52 <augustss> copumpkin: mpfr
19:17:57 <roconnor> how did the mpft team compete in the Many Digits competition?
19:18:14 <ddarius> roconnor: Iterative deepening ?
19:18:45 <roconnor> ddarius: computing the number of accurate digits you have from a fixed preceision floating point computation is really hard.
19:18:55 <roconnor> I doubt they did that
19:19:07 <ddarius> That's why you use intervals.
19:19:16 <copumpkin> augustss: yeah, but the user of it is going to be the taylor model thing which takes care to do things nicely
19:19:16 <napping> I expect it would be a lot easier to get the error analysis to go through if you can adjust precision
19:19:41 <napping> It's possible to get accurate results with 32-bit floats, after all
19:20:55 <Eduard_Munteanu> Hrm, so what's the idea, you (should) get a higher range and better speeds than fixed-point?
19:21:25 <napping> floating point lets  you control relative error, if that's an issue
19:22:07 <copumpkin> Eduard_Munteanu: people like doubles for some kinds of computations
19:22:11 <copumpkin> this gives you bigger doubles
19:22:20 <copumpkin> with way better control over rounding modes
19:22:25 <copumpkin> and is fast
19:22:55 <ddarius> Control over rounding modes is the crucial part, though extended precision can also be critical.
19:23:15 <copumpkin> so every operation that might need to round takes a rounding mode enum
19:23:18 <Eduard_Munteanu> Technically I suppose they could leverage special hardware (FPU, GPU etc.)
19:23:21 <copumpkin> and there are half a dozen options
19:23:30 <copumpkin> Eduard_Munteanu: yeah, it's full of special asm operations
19:23:34 * ksf_ is happy to leave such stuff to the numericologists.
19:34:11 <copumpkin> augustss: we found your code
19:34:19 <copumpkin> for converting doubles to gmp stuff
19:34:28 <augustss> copumpkin: which code would that be?
19:35:16 <copumpkin> voodoo: http://darcs.haskell.org/packages/integer-gmp/cbits/float.c
19:37:17 <augustss> ah, yes
19:41:55 <augustss> old sins...
19:48:26 <zzing> If you can model an imperative program with a flow chart, is there any equivalent for haskell?
19:48:40 <dibblego> expression substitution?
19:48:47 <ddarius> Higher order functions make that not very reasonable.
19:50:16 <mgsloan> zzing - http://vimeo.com/19273744 ?
19:51:30 <zzing> I don't even know what that is...
19:52:28 <joe6> is anyone aware of an equation solver in haskell?
19:53:10 <zzing> joe6: you mean a CAS?
19:53:14 <mgsloan> zzing - it's a haskell expression tree editor, mostly intended for livecoding music
19:53:33 <zzing> ?
19:53:56 <djahandarie> zzing, watch the video :)
19:53:59 <djahandarie> It's pretty neat
19:54:39 <djahandarie> (This may not be exactly what you're looking for though.)
19:55:22 <joe6> zzing, will check it out, thanks.
19:55:25 <zzing> Paper reasoning of a simple blackjack game is what I want to do.
19:55:43 <monochrom> flow chart doesn't reason either
19:56:02 <zzing> sure it does
19:56:05 <scottj> mgsloan: http://www.youtube.com/watch?v=DmtALHVRSTU seems similar
19:56:10 <mgsloan> I suppose it doesn't exactly demonstrate control /flow/ the same way as a flowchart, but it does provide a more visual syntax
19:56:12 <zzing> it is a recipe
19:56:15 <folklore> http://www.haskell.org/haskellwiki/Applications_and_libraries/Interfacing_other_languages#Obsolete
19:56:18 <folklore> wops
19:56:26 <folklore> http://haskell.org/haskellscript/
19:56:30 <folklore> page is dead
19:56:34 <folklore> where I get haskellscript
19:57:09 <monochrom> see Bird's book "introduction to functional programming using haskell" 2nd edition for how to reason with haskell programs
19:57:14 <zzing> #!runhaskell?
19:57:43 <monochrom> in fact also see Gries's book "the science of computer programming" for how to reason with imperative programs, sans diagram
19:57:57 <zzing> monochrom: The best I can do is the Hutton book
19:58:17 <mgsloan> scottj: indeed.  I like yaxu's minimalism, though.  The less screen real-estate necessary, the better
19:59:28 <folklore> does anyone know where I can get haskellscript
20:01:13 <dibblego> folklore: I don't know what haskellscript is, but I use haskell for scripting all the time
20:01:19 <dibblego> maybe that's what you want
20:01:33 <folklore> I want http://www.haskell.org/haskellscript/
20:01:34 <folklore> the dead page
20:01:49 <folklore> haskellscript is hassel with a Active Scripting interface
20:01:53 <folklore> for windows
20:01:54 <dibblego> if by dead you mean 404
20:01:56 <monochrom> there is also "reasoned programming" using a similar method as Gries's at http://www.doc.ic.ac.uk/~sue/firstyearbook.ps
20:02:00 <folklore> yes
20:02:02 <dibblego> a 404 page doesn't help me know what you want
20:02:15 <folklore> I just explained what I wanted
20:02:17 <folklore> and what it is
20:02:52 <zzing> http://replay.waybackmachine.org/20090226070100/http://www.haskell.org/haskellscript/
20:02:59 <zzing> May I suggest...
20:03:36 <folklore> thanks, they should fix the page though
20:03:41 <folklore> very unprofessional
20:03:54 <zzing> folklore: wtf?
20:03:55 <djahandarie> I'm fairly sure the project is dead.
20:04:25 <zzing> folklore: Do you have any idea what I gave you there?
20:04:42 <djahandarie> HaskellDB is still around though
20:04:51 <folklore> zzing yes an archived copy of the docs
20:04:52 <djahandarie> Not sure about that other stuff.
20:05:20 <folklore> I hope this stuff is in the most recent haskell
20:05:25 <folklore> and not dead like that webpage is
20:05:48 <zzing> folklore: Good. Be grateful you got that. Don't be a dick.
20:06:10 <djahandarie> folklore, I know HaskellDB is, and is fairly up to date. The ActiveX stuff is gone almost for sure though.
20:06:16 <folklore> the language isn't necessary, my concern is valid
20:06:29 <folklore> and I said thanks
20:06:35 <confound> just to be clear, whether you're being a dick has nothing to do with whether your concern is valid
20:06:45 <confound> (I have no opinion on the former)
20:06:47 <folklore> djhandarie, ugh why'd they remove activex?
20:06:50 <dibblego> guys, chill pill please -- this is all a bit unnecessary
20:07:04 <folklore> i'm not the one spewing profanity, this gentlemen is
20:07:05 <djahandarie> folklore, probably because no one used it, so no one updated it.
20:07:23 <folklore> I guess I won't be using it either, shame, haskell looked interesting
20:07:33 <djahandarie> Haskell has many things to offer. :)
20:07:36 <monochrom> I don't think any project's death needs to be explained at all.
20:07:41 <folklore> thanks for the help/info, have a nice day
20:08:19 <c_wraith> Is there any particular reason to prefer fundeps or type families for a library that's only expected to work on recent versions of GHC?
20:08:21 <monochrom> personally I'm ticked off by "unprofessional". who does it think it is?
20:08:27 <confound> Clearly it's because an anti-Microsoft cabal went around destroying things binding to ActiveX.
20:08:42 <confound> not because of the obvious reason that 99% of projects die out
20:08:53 <djahandarie> c_wraith, because one fits your problem nicer.
20:08:58 <zzing> My apologies for any offence to you guys, that just irked me after I went and got it for him.
20:09:03 <dibblego> monochrom: don't let such self-importance bother you
20:09:17 <djahandarie> In general, fun deps are still more expressive than type families, I think.
20:09:22 <c_wraith> djahandarie: pretty much a no reason to prefer either for my purposes.
20:09:32 <c_wraith> -a
20:10:23 <geheimdienst> well, if a company was behind haskell.org or this haskellscript thing, then it _would_ be unprofessional to have pages missing. the failure of understanding is of course that it's all an open-source effort, not a company
20:10:41 <c_wraith> The extension list is shorter with type families.  Is that a compelling reason?
20:10:50 <djahandarie> Perhaps. :)
20:11:08 <confound> geheimdienst: what does who's behind it have to do with whether or not pages for dead projects should still be around?
20:11:36 <applicative> ah we lost folklore, the source is still around, e.g., http://www.di.uminho.pt/~jno/tgz/mpi9899t3.hs.1.tgz http://www.di.uminho.pt/~jno/tgz/mpi9899t3.hs.2.tgz
20:11:55 <djahandarie> Does it work for anything recent though? I doubt it does
20:12:55 <geheimdienst> confound, i meant "unprofessional" in the sense that afaik there is no one being paid, i.e. with the profession, of maintaining haskellscript or haskell.org ...
20:13:14 <applicative> I doubt it, I was going to give a more elaborate account.  It's not like Meijer and Leijen died or something.  
20:13:15 <geheimdienst> whatever, things being open-source, some assembly is required
20:13:53 <djahandarie> And what happened to equality constraints in superclasses? I figure it was suppose to be done now that the typechecker is overhauled but I don't remember anyone saying anything about it
20:14:06 <djahandarie> I vaugely recall using it without it being rejected though...
20:15:05 <applicative> Leijen seems to have had an unlimited capacity for this kind of thing.  wxhaskell is still around. 
20:17:02 <zzing> monochrom: I like the sounds of that 'reasoned programming'. Do you happen to know if the is a high quality pdf or latex source is available? I only ask because it is straining my eyes and looks right up my alley.
20:17:29 <monochrom> no
20:18:29 <monochrom> oh interesting, just s/ps/pdf/ in the url
20:19:46 <zzing> monochrom: I have probably the best pdf I can find. It is one of those that looks subpar on a display but will blow word away on a printer.
20:20:35 <zzing> This being the source: http://pubs.doc.ic.ac.uk/reasoned-programming/   
20:20:48 <zzing> I am going for a kindle soon
20:24:17 <monochrom> interesting, it also treats functional programs
20:24:27 <zzing> hmm?
20:26:15 <monochrom> chapters 4-8 proves functional programs correct. later chapters do imperative programs.
20:27:16 <zzing> monochrom: This sounds very useful
20:27:53 <zzing> An ebook version would be useful :-)
20:28:00 <co_dh> I recommend Maarten M. Fokkinga 's Gentle Introduction to Category Theory to programmers. It helps me find a lot of example of Functor, Natural transformation and Adjoint in Haskell. 
20:28:20 <monochrom> there is also my favourite http://www.cs.utoronto.ca/~hehner/aPToP/ using a much simpler method. it's mainly imperative programming. there is a section on functional programming.
20:28:22 <ddarius> I'm not really keen on that paper, but it is worth reading.
20:28:46 <monochrom> (I need to declare my interest. Hehner is my supervisor.)
20:29:17 <zzing> I want to be able to define a well provable PLC or Microcontroller program
20:29:52 * ddarius hates Oracle.
20:30:02 <zzing> monochrom: Hello from uwindsor
20:31:03 <ddarius> I guess on the bright side, them acquiring Java hastens Java's popular demise.
20:31:29 <zzing> Think oracle made a bad buy?
20:32:09 <ddarius> No.  They didn't buy Java for the technology or stability or anything like that.
20:36:28 <btutt> They bought it for the money in mobile Java licenses. :)
20:38:09 <zzing> I was under the impression that it was usually other companies that made money on java
20:38:39 <ddarius> Buy Java, sue Google.
20:38:42 <btutt> Sun made them license the test suite or something it wasn't the VM bits that were the issue
20:38:56 <btutt> IIRC
20:44:35 <ddarius> Euler is the craziest, sane mathematician.
20:44:56 <geheimdienst> ddarius, he preferred the term cosane
20:45:08 <geheimdienst> "crazy" is offensive
20:45:22 <c_wraith> I'm not even sure where the arrow is to flip there
20:45:40 <dolio> This isn't a guy who built the railroads.
20:45:52 <dankna> I'd have to nominate Erd?s as the craziest sane mathematician.
20:46:08 <Eduard_Munteanu> Yes, Erdos was strange.
20:46:11 <zzing> ddarius: I hear he liked oil
20:46:11 <dankna> (And I suppose John Nash as the sanest crazy one.)
20:46:13 <c_wraith> I suspect that sanity might be equivalent to cosanity.  Like functors and cofunctors
20:46:18 <Eduard_Munteanu> Heh, yeah.
20:46:43 <ddarius> dankna: Possibly for the latter.  I'm less convinced for the former, but Erdos would be a good nominee.
20:46:56 * dankna nods
20:56:10 <siracusa> Why can't type synonyms of kind * -> * be used with monad transformers? Like type P a = IO a in type Foo b = StateT () P b.
20:56:59 <dibblego> oh I've never tried that -- seems a bit rude to me too
20:58:04 <ddarius> type P = IO will work (with the appropriate extensions)
20:58:19 <ddarius> Always eta reduce type synonyms.
20:59:50 <siracusa> Unfortunately I can't, it comes from a library.
21:01:17 <copumpkin> then you're screwed
21:01:29 <djahandarie> ()
21:01:38 * applicative wonders whether the library has an author
21:01:52 <ddarius> The pentagonal numebrs are pretty fantastic.
21:01:58 <copumpkin> libraries are write-once, curse many times
21:02:08 <copumpkin> ddarius: yeah?
21:02:28 <djahandarie> I want to get one of those posters with interesting geometric shapes on them
21:02:45 <djahandarie> One of my professors has one outside of his office and I always end up staring at it for extended periods of time
21:05:47 <ddarius> _n(1-x^n) = _n (-1)^n x^P(n) + _n (-1)^n x^P(-n) I guess is one way to write it.
21:06:11 <dibblego> what is the GHC extension to derive non-standard type-classes such as Functor (rather than DeriveFunctor, DeriveThis...)?
21:06:27 <ddarius> There's NewtypeDeriving or something.
21:06:55 <ddarius> There's also a few others like DerivingDataAndTypeable or some such.
21:07:23 <dibblego> GeneralizedNewtypeDeriving
21:07:25 <dibblego> that's him
21:07:53 <ddarius> Someone's burning something somewhere in my apartment complex.  Hopefully the fire alarm doesn't go off.
21:08:15 <djahandarie> Go put it out yourself
21:08:38 <copumpkin> I'm sure someone's smoking something awesome
21:08:42 <copumpkin> and won't appreciate you putting it out
21:09:04 <djahandarie> Damn druggies!
21:09:33 * ddarius actually thought of smoking meat not drugs.
21:09:39 <ddarius> We know where djahandarie's mind is.
21:10:18 <djahandarie> Aw, damn. :(
21:10:28 <copumpkin> djahandarie: yeah, what the hell
21:11:00 <ddarius> copumpkin: I appreciate you continuing the alliteration.
21:12:22 * djahandarie goes to bed
21:12:38 * ddarius has been in bed this whole time.
21:50:11 * hackagebot vty-ui 1.0 - An interactive terminal user interface library  for Vty  http://hackage.haskell.org/package/vty-ui-1.0 (JonathanDaugherty)
21:57:49 <JR_> is anybody out there familiar with parsec?
21:59:09 <JR_> i have a left recursive grammar and some of the documentation suggested that using chainl or chainr would solve the problem but i can t seem to get an example running
22:00:00 <manateeUser> Hi all. :)
22:11:31 <Gebb> @bot
22:21:18 * hackagebot JSON-Combinator 0.2.3 - A combinator library on top of a generalised JSON type  http://hackage.haskell.org/package/JSON-Combinator-0.2.3 (TonyMorris)
22:24:55 <notostraca> You Haskell people rule.  Thanks for constantly pushing the envelope when it comes to the cutting edge of research.
22:25:43 <dibblego> woot!
22:25:58 <ian_mi> why, if I use pattern matching to match a specific type in a polymorphic function, am I still expected to return a more general result?
22:27:45 <btutt> ? not sure what you mean
22:28:12 <rwbarton> what code are you trying to compile?
22:28:31 <ian_mi> hmm, I think this is called polymorphic subsumption but I'm not sure and apparently it was removed some time ago
22:29:58 <ian_mi> sorry, I just realized I was a little confused about things when I asked that question, that's not what's going on
22:30:34 <ian_mi> it's never until I ask the question that I realize what I'm doing wrong
22:30:54 <notostraca> So is the Haskell Platform still on track to release today/tomorrow (the 5th)?
22:31:50 <btutt> Patience is a virtue/ :) (have no clue)
22:32:56 <notostraca> I wish more languages did something like the Platform, it really is a good way to start development
22:34:07 <btutt> some do, and I definitely agree
22:36:21 <ian_mi> is dependant typing likely to be better supported in ghc in the near future?
22:36:57 <ian_mi> I'm working on type level naturals and fixed sized lists at the moment
22:37:39 <ManateeLazyCat> When time Paths_package.hs generate ? Looks Paths_package.hs generate after Setup.hs that i can't import Paths_package in Setup.hs
22:39:32 <btutt> i thought functional dependancies made life more complicated? am I misremembering? or did you mean something different?
22:40:03 <dibblego> functional dependencies are already supported by GHC, dependent typing is something different
22:41:08 <Eduard_Munteanu> Peanos aren't really dependent types either. IIRC, there's going to be some support for peanos in GHC.
22:42:26 <Eduard_Munteanu> Which will eliminate that silly cruft of defining TwentyOne = Succ (Succ (... Zero )...)
22:42:35 <ian_mi> hmm, that would be great
22:43:22 <ian_mi> I'm working on a linear algebra library which I think would benefit greatly from this kind of thing
22:44:05 <Eduard_Munteanu> Ah, making compile-time assurances about matrix sizes when operating on them?
22:44:12 <ian_mi> yes
22:45:40 <ian_mi> sometimes I even dream of checking that my matrix is positive definite and symmetric ;)
22:45:53 <Eduard_Munteanu> All in the type system, heh :)
22:46:29 <btutt> Has somebody done that in C++ templates? Turing completeness and all. ;)
22:46:30 <Eduard_Munteanu> If that was doable, Oleg would had done it long ago :P
22:47:47 <ManateeLazyCat> @src getDataDir
22:47:48 <Eduard_Munteanu> btutt: Turing completeness doesn't help much, since the input depends on runtime values, you still have to find a way to make static assurances.
22:47:57 <deteego> hello, does anyone know if its possible to make cabal (or if there is an actual option for source files) to hide a package
22:48:05 <ManateeLazyCat> Hmm, lambdabot still not online
22:48:48 <Eduard_Munteanu> *would have
22:49:09 <deteego> (in regards to cabal I am talking about the .cabal file)
22:49:34 <Eduard_Munteanu> ian_mi: actually, for symmetry it's probably doable
22:49:40 <ManateeLazyCat> deteego: For hide *package* should use "ghc-pkg unregister package-version"
22:50:13 <Eduard_Munteanu> As long as you have a special type constructor for symmetric matrices.
22:50:15 <numeral> is there a reason xs is used in haskell tutorials all the times?
22:50:20 <numeral> is this another foo bar thing?
22:50:22 <deteego> ManateeLazyCat: im talking about an actual option in the .cabal file, and not a command you run into ghc before building
22:50:25 <Eduard_Munteanu> (so yes, it'd reject otherwise valid symmetric matrices)
22:50:42 <deteego> ManateeLazyCat: currently I am working on a project, and for reasons I can't be bothered going into, I have to do ghc-pkg hide mtl in order to build it
22:50:51 <Eduard_Munteanu> numeral: not really.
22:51:02 <Eduard_Munteanu> numeral: think you have one 'x' and multiple.... xs
22:51:14 <Eduard_Munteanu> Therefore, (x:xs)
22:51:20 <ManateeLazyCat> deteego: You can write version in your .cabal file.
22:51:22 <deteego> ManateeLazyCat: is there some flag that cabal can pass into GHC when building so it hides mtl (or possibly even an option to hide the package in a haskell source file)
22:51:29 <numeral> yeah I got that, just the first time I've ever seen it :P
22:51:34 <numeral> actually kind of makes sense
22:52:06 <ManateeLazyCat> deteego: Which package conflict with mtl?
22:52:19 <deteego> ManateeLazyCat: transformers, its going to be fixed in 7.x iirc
22:52:20 <ManateeLazyCat> deteego: If foo conflict with mtl, you can write 'foo > version' in .cabal file. 
22:52:26 <ManateeLazyCat> deteego: Then ghc won't use mtl
22:53:16 <deteego> ManateeLazyCat: actually brb, let me check what it is
22:53:57 <ManateeLazyCat> deteego: So add transformers in build-depends to try.
22:54:27 <Eduard_Munteanu> deteego: why not use 'transformers' instead?
22:54:40 <Eduard_Munteanu> ... if you need 'mtl'.
22:54:49 * copumpkin has performed an amazing feat of engineering!
22:54:53 <deteego> this isn't my code, I am going through it now
22:55:00 <ian_mi> Eduard_Munteanu: yes, it is probably doable but much more awkward than it should be
22:55:22 <Eduard_Munteanu> copumpkin: yes... ?
22:55:25 <ian_mi> I think I'll be satisfied with sizes for now
22:55:28 <copumpkin> I took the horrible broken libopcodes API and made it pure and arbitrarily parallel
22:55:38 <copumpkin> in haskell
22:56:16 <Eduard_Munteanu> Oh, nice.
22:56:37 <hpaste> Jz pasted "6A. Triangle"  http://hpaste.org/44535
22:56:40 <Eduard_Munteanu> So you didn't need to patch the actual libopcodes?
22:56:44 <copumpkin> nope
22:56:50 <deteego> also is there any news when the next haskell platform with ghc 7 will be ready?
22:57:01 <copumpkin> deteego: next few days, I hear
22:57:28 <deteego> copumpkin: k thanks
22:57:44 <deteego> oh and one last thing, does the LLVM backend in GHC 7 work with FFI?
22:58:08 <ManateeLazyCat> I'm waiting next HP. :)
22:59:28 <deteego> Eduard_Munteanu: ok the package is using transformers (or more specifically Control.Monad)
22:59:50 <ManateeLazyCat> Which function return "/home/andy/.cabal/share/"? I need write my own getDataDir to use in Setup.hs
22:59:54 <deteego> Eduard_Munteanu: well the source file imports Control.Monad
23:00:32 <deteego> and its in build depends as well
23:00:35 <Eduard_Munteanu> deteego: mtl's been deprecated AFAIK, 'transformers' is the thing now.
23:00:45 <ManateeLazyCat> I guess must some cabal code generate 'datadir', still in search.
23:01:07 <deteego> Eduard_Munteanu: well transformers is in the .cabal file, and the source file imports Control.Monad and whatnot
23:01:32 <Eduard_Munteanu> Um, so where's the conflict with mtl?
23:01:56 <Eduard_Munteanu> Unless you have it.
23:02:21 <deteego> Eduard_Munteanu: I received the source code from someone else, and they said you need to hide mtl in order to build the cabal package
23:02:35 <deteego> if you dont hide mtl it wont build
23:02:41 <ian_mi> say you have a type constructer T such that T a is only defined for a in class C. Is there a way to have C a be implied when T a is written?
23:02:54 <btutt> ManateeLazyCat: Have you looked into ~/.cabal/config?
23:03:14 <deteego> hmm wait a sec, mtl is also there as a depend
23:03:58 <Eduard_Munteanu> ian_mi: I'm not sure anymore, IIRC adding a class constraint had no effect, unless you're using an existential.
23:03:58 <ian_mi> for example now I have to write (*) :: (Nat n, Nat k, Nat m) => Matrix n k -> Matrix k m -> Matrix n m
23:04:05 <ManateeLazyCat> btutt: My problem is i can use 'import Paths_package' in Setup.hs, because Cabal just generate Paths_package.hs *after* Setup.hs.
23:04:21 <dibblego> ian_mi: there is, or you can put it on the function signature (which is usually more appropriate)
23:04:55 <ManateeLazyCat> btutt: So i need figure out how cabal get "/home/andy/.cabal/share/" then i scan .cabal file to get package name and package version, same as getDataDir, but Setup.hs don't need depend Paths_package
23:05:00 <copumpkin> ian_mi: don't put type constraints on types
23:05:07 <copumpkin> (class constraints, I guess)
23:05:29 <ian_mi> copumpkin: I don't follow
23:05:36 <ManateeLazyCat> btutt: Or any package scan ~/.cabal/config? 
23:05:48 <copumpkin> ian_mi: "say you have a type constructer T such that T a is only defined for a in class C"
23:05:57 <copumpkin> that sounds like you put a constraint on the type?
23:05:57 <Eduard_Munteanu> deteego: why not remove 'mtl' and see if it works?
23:06:06 <Eduard_Munteanu> deteego: from the depend list
23:06:27 <btutt> i'd think cabal or cabal-install needs to parse ~/.cabal/config
23:06:54 <ian_mi> copumpkin: yes, I require the type to be a natural number, otherwise the definition doesn't make sense
23:07:04 <copumpkin> ian_mi: yes, but haskell doesn't support what you want in that sense
23:07:11 <copumpkin> so you have to put the class constraints on the functions
23:07:18 <copumpkin> class constraints on types don't do anything useful
23:07:20 <ManateeLazyCat> btutt: So i'm reading Cabal to source code ...
23:07:20 <deteego> Eduard_Munteanu: yeah made no difference
23:07:28 <deteego> Eduard_Munteanu: and it is conflicting with mtl 1.1
23:07:33 <copumpkin> you can write them, but they're less than useless
23:07:44 <Eduard_Munteanu> Do they have any effect at all? :/
23:07:49 <ManateeLazyCat> Got flat_datadirrel, continue parse....
23:08:14 <ian_mi> copumpkin: so the answer is no, it can't be inferred?
23:08:27 <copumpkin> ian_mi: yeah, it can't
23:08:42 <copumpkin> ian_mi: haskell types like to be explicit about what they're doing
23:09:20 <copumpkin> being able to do what you say kind of breaks local reasoning about some things that we care about
23:09:42 <ManateeLazyCat> Got prefixRelativeInstallDirs , closer.
23:10:04 <deteego> Eduard_Munteanu: specifically its Control.Monad.Trans.Error conflicting with Control.Monad.Error in regards to either
23:10:10 <deteego> Eduard_Munteanu: with Control.Monad.Error being part of mtl 1.1
23:10:34 <deteego> Eduard_Munteanu: and removing mtl from the .cabal files depends makes no difference
23:10:36 <Eduard_Munteanu> deteego: you could patch that up.
23:10:54 <deteego> Eduard_Munteanu: what do you mean exactly
23:11:09 * copumpkin goes to sleep
23:11:59 <Eduard_Munteanu> deteego: remove the import of Control.Monad.Error then, and use Data.Either or Control.Monad.Trans.Error only
23:13:00 <deteego> Eduard_Munteanu: Control.Monad.Error is not being imported in the source file, Control.Monad.Trans.Error is
23:15:06 <Eduard_Munteanu> There's no Control.Monad.Trans.Error in 'mtl', so something else must be importing 'either' from mtl for you.
23:15:27 <deteego> Eduard_Munteanu: Control.Monad is being imported, but only guard and join portions of it
23:22:33 <deteego> Eduard_Munteanu: ok something weird is going on
23:23:03 <deteego> Eduard_Munteanu: I commented out import           Control.Monad           (guard,join) 
23:23:13 <deteego> Eduard_Munteanu: built the project, it obviously didn't work
23:23:28 <Eduard_Munteanu> Well, yeah, that can't do it.
23:23:29 <deteego> Eduard_Munteanu: then I uncommented the file, and it built fine (without the conflict regarding mtl)
23:23:40 <Eduard_Munteanu> What other imports are there?
23:24:07 <deteego> Eduard_Munteanu: I think whats happening is another source file is using something from mtl
23:24:18 <deteego> Eduard_Munteanu: which GHC remembers, and uses instead of transformers
23:25:19 <deteego> Eduard_Munteanu: http://pastebin.com/riTJTNCd
23:25:25 <deteego> Eduard_Munteanu: those are the imports
23:26:02 <Eduard_Munteanu> Hm, that looks ok.
23:26:11 <Eduard_Munteanu> Maybe it's something cabal tells to ghc.
23:26:35 <Eduard_Munteanu> Did you do a verbose build? Maybe it passes something mtl-related to ghc.
23:27:09 <deteego> Eduard_Munteanu: whats the flag for a verbose build, is it just -v?
23:27:28 <Eduard_Munteanu> Yes.
23:29:14 <deteego> Eduard_Munteanu: ok mtl is being linked, I have no idea by what though
23:29:27 <deteego> Eduard_Munteanu: I think its a library that this package depends on
23:29:54 <deteego> Eduard_Munteanu: hmm let me check something
23:31:19 <deteego> because what I was doing previously was hiding mtl at the point when it cabal tried to build that source file (and failed0
23:31:28 <ManateeLazyCat> Have any function return default LocalBuildInfo ? 
23:32:15 <deteego> Eduard_Munteanu: ok yeah, so the issue is I the cabal package is actually using some library which pulls in MTL as a depedancy
23:32:45 <deteego> Eduard_Munteanu: and so the cabal package needs mtl to build one portion of it, and requires mtl to be hidden for another portion
23:33:20 <deteego> Eduard_Munteanu: is there a way to hind mtl in the source file to prevent matching instances?
23:34:35 <ManateeLazyCat> deteego: I don't think so you can do that.
23:35:05 <ManateeLazyCat> deteego: What's the your real problem? ghc-7.0.2 failed with some package?
23:35:18 <deteego> ManateeLazyCat: no, this is GHC 6.13
23:35:52 <deteego> ManateeLazyCat: the issue is, that this cabal package requires both mtl (through some other library which is a dependancy of this package) and transformers
23:35:57 <deteego> ManateeLazyCat: both of which conflict
23:36:14 <deteego> ManateeLazyCat: so when the package is built, it pulls mtl and transformers
23:36:54 <deteego> ManateeLazyCat: so the only way to fully build the package is to build it (at this point it stops at the source file with the conflict)
23:37:02 <deteego> ManateeLazyCat: then do a ghc-pkg hide mtl
23:37:12 <deteego> ManateeLazyCat: and do cabal build again, and it will fully build
23:37:39 <ManateeLazyCat> Yeah, it's only way.
23:37:39 <deteego> ManateeLazyCat: not a massive issue, just seeing if I could fix it, I assume that ghc 7.x will solve this problem as mtl is being removed
23:38:08 <deteego> ok thanks for the help
23:38:33 <deteego> there probably should be some option so you can do a hide <package> in the source file
23:38:39 <ManateeLazyCat> Saizan: Are you there?
23:38:46 <deteego> although I am not sure if that will cause issues
23:48:28 * hackagebot JSON-Combinator 0.2.4 - A combinator library on top of a generalised JSON type  http://hackage.haskell.org/package/JSON-Combinator-0.2.4 (TonyMorris)
