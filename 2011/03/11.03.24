00:06:43 * hackagebot sbv 0.9.15 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.15 (LeventErkok)
00:22:48 <kyagrd> What is the standard way to cite GHC? the user manual?
00:24:10 <companion_cube> i think it's by pasting full ghc source code in your article/report
00:25:25 <kyagrd> companion_cube: that exeeds the page limit ;)
00:26:16 <kyagrd> I can search in the computer science bibliography for OCaml user manual being cited, but wondering why it is hard to fild a bib entry for GHC.
00:26:16 <Jafet> *** Exception: stack overflow [Glo11]
00:28:06 <_Ray_> Hi :) Question about the do notation. If I have "do\n x <- foo\n y <- foo\n return (x+y)", where foo :: [Int], what is the type of x and y? I assumed it was type [Int], but since return :: a -> [a] (for the list monad), then this would return a [[Int]], but it doesn't.
00:29:33 <Saizan> x and y have type Int
00:30:10 <_Ray_> Oh
00:31:08 <_Ray_> So if I'm in do syntax, and say x <- foo, where foo is M a, then x :: a?
00:33:19 <Jafet> @undo do { x <- foo; y <- foo; return (x+y); }
00:33:19 <lambdabot> foo >>= \ x -> foo >>= \ y -> return (x + y)
00:33:31 <Jafet> @pl foo >>= \x -> foo >>= \y -> return (x+y)
00:33:31 <lambdabot> (`fmap` foo) . (+) =<< foo
00:33:33 <Saizan> _Ray_: yep
00:34:04 <Jafet> I expected better of you, lambdabot!
00:34:49 <RayNbow`TU> @hoogle under
00:34:49 <lambdabot> Control.Exception Underflow :: ArithException
00:34:49 <lambdabot> Control.OldException Underflow :: ArithException
00:34:49 <lambdabot> Control.Exception.Base Underflow :: ArithException
00:34:53 <RayNbow`TU> hmm
00:35:41 <RayNbow`TU> @hayoo under
00:35:41 <lambdabot> Unknown command, try @list
00:36:13 <kyagrd> Is Haskell Symposium and ICFP still being planned in Tokyo by the way?
00:37:03 <kyagrd> Radioactive contamination makes me concerned about visiting there.
00:38:03 <Skola> if I have lists [1,3,4,5,6,7] and [1,4,5,6], and I wanted to get a list of all unique sums of all pairs, yielding [4,5,6,7,8,9,10,11,12,13], is there a better way to do this than running nub on a list of all possible pairs?
00:38:12 <theorbtwo> kyagrd: I don't think there's anything to worry about, in Tokyo.
00:38:27 <theorbtwo> I expect that you will get more radiation on the flight over then on the ground.
00:38:30 <ddarius> kyagrd: You'll lie.
00:38:33 <ddarius> +v
00:39:22 <theorbtwo> ...and quite likely more then either from the security scanners, depending on how hardcore Japan is about that, and what the other country(ies) on your itineary are.
00:41:25 <Saizan> Skola: you can run nub on a list of all possibly distinct pairs at least, i.e. avoid to include both (xs !! i) + (ys !! j) and (ys !! j) + (xs !! i) in the list you're passing to nub, given that xs and ys are your input lists
00:43:04 <Skola> ah yes
00:43:42 <Skola> I should have mentioned they are likely to be one and the same list
00:44:17 <Skola> I use one list to generate the list with duplicates
00:44:37 <kyagrd> theorbtwo: Already, the J-government wanred that the water supply facilcity has radioactive contamination that can be harmful for infants.
00:48:05 <kyagrd> theorbtwo: and some Europian contries have already decided not to import Japanese agricultural products for a while.
00:49:06 <Skola> only certain vegetables
00:49:31 <Skola> from prefectures near the plant
00:49:57 <Skola> I wouldn't worry too much about the radiation though
00:50:03 <Skola> I'd worry about getting around
00:51:13 <ddarius> http://en.wikipedia.org/wiki/Banana_equivalent_dose
00:52:00 <kyagrd> ddarius: yes I heard that it is recommendend for nuclear power plants employees to eat bananas
00:52:30 <ddarius> It's recommended that everyone eat bananas, but I don't see why nuclear power plant employees would particularly.
00:53:08 <Skola> they get plenty of BED as is
00:53:28 <Skola> and yet radiation-induced illness it quite rare in them
00:53:45 <kyagrd> ddarius: I'm not good at chemistry but it has something that helps like the iodine does
00:54:27 <kyagrd> ddarius: oh, it was potassium
00:54:50 <Skola> :D
01:21:20 <kniu> @hoogle doFst
01:21:20 <lambdabot> No results found
01:21:48 <kniu> @hoogle (a -> b) -> (a, x) -> (b, x)
01:21:48 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
01:21:48 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
01:21:48 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
01:22:15 <kniu> @pl (\f (x, y) -> (f x, y))
01:22:15 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
01:22:30 <kniu> @pl (\(x, y) -> (f x, y))
01:22:30 <lambdabot> first f
01:22:34 <kniu> @hoogle firs
01:22:34 <lambdabot> Data.Monoid newtype First a
01:22:34 <lambdabot> Data.Monoid First :: Maybe a -> First a
01:22:34 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
01:23:26 <dblhelix> so, how do I decide which cabal version to list in my .cabal file? do I just list the current version (1.10.1)?
01:27:35 <kniu> @pl (\n j -> f $ g . h n j)
01:27:35 <lambdabot> ((f . (g .)) .) . h
01:27:51 <kniu> @pl (\n j -> alter $ Just . maybe n j)
01:27:51 <lambdabot> ((alter . (Just .)) .) . maybe
01:28:03 <kniu> meh, not worth it.
01:32:50 <kniu> oh wow I actually found a use for type families.
01:33:01 <kniu> Feels kind of
01:33:02 <kniu> weird.
01:41:00 <RayNbow`TU> category-extras is apparently marked as obsolete... what replaces the newtype CompF and the Composition type class?
01:58:58 <Eduard_Munteanu> RayNbow`TU: yeah, edwardk is breaking them into separate packages. He was going to make a metapackage to import them all, but I don't sure if there's anything like that yet.
01:59:21 <Eduard_Munteanu> *I'm not sure
02:02:20 <RayNbow`TU> Eduard_Munteanu: ah ok
02:03:17 <RayNbow`TU> I just noticed it was obsolete after I created a small snippet of code ( just playing around... http://hpaste.org/44991/ )
02:03:45 <Eduard_Munteanu> I'd suggest searching for "edward kmett" on Hackage.
02:04:08 <Eduard_Munteanu> Or maybe you could search for CompF/Composition directly.
02:05:08 <RayNbow`TU> I did find another package with CompF, but it didn't contain a Composition type class
02:05:40 <RayNbow`TU> (didn't check who the author was of that particular package... can't check currently as hackage is timing out on me :p)
02:11:13 <basvandijk> Hello, does the ghc C preprocessor support concatenation? For example: #define FOO(X) N ## X
02:14:11 <frerich> Hm, is there a magic convention which makes it possible to use a function like '(//)' infix, but not 'xxx'? I just notice that I can magically use 'a // b' instead of 'xxx a b' just by renaming the function.
02:14:30 <dmwit> basvandijk: I don't think so.
02:14:43 <dmwit> frerich: Yes. Letters are prefix, everything else is infix.
02:14:59 <dmwit> frerich: You can turn infix operators prefix with parens, and prefix functions infix with backticks.
02:15:06 <radiobutton> anyone care to help me make sense of this so i can implement something of a resemblance of it: http://rho.loria.fr/data/iglp1.pdf
02:15:18 <frerich> dmwit: Ah, cool, I didn't know that. I only new that prefix could become infix with backticks (e.g. `elem`)
02:16:28 <radiobutton> some of my code is less than helpful: http://hpaste.org/44992/rho_calc
02:17:01 <dmwit> You want somebody to explain a 38-page paper via IRC? O_o
02:17:06 <basvandijk> dmwit: Yes it seems so. I just read http://bit.ly/dJj5hE where Duncon says the C preprocessor runs in "traditional mode" which doesn't support string concatenation. Bummer...
02:18:27 <frerich> I recently wrote a tiny function to replace elements in an "associative list" (is that what you call [(a,b)] ?); the source code is at http://hpaste.org/44994/associative_list_replace_anno - is there something liek this in a standard module already? I couldn't find it in Data.List
02:18:53 * frerich often can't shake the sensation that he's writing functions which are available in some module already
02:19:28 <Eduard_Munteanu> radiobutton: any specific questions?
02:19:39 <dmwit> :t nubBy (equating fst)
02:19:40 <lambdabot> Not in scope: `equating'
02:19:40 <radiobutton> lol well atleast help me manage to turn the non-sense on page 8 to page 18 into something that makes sense
02:19:49 <dmwit> :t nubBy ((==) `on` fst)
02:19:49 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [(a, b)]
02:19:58 <Eduard_Munteanu> That's not really specific either.
02:20:08 <dmwit> :t \p -> nubBy ((==) `on` fst) . (p:)
02:20:09 <lambdabot> forall a b. (Eq a) => (a, b) -> [(a, b)] -> [(a, b)]
02:20:13 <dmwit> frerich: ?
02:20:38 <radiobutton> it starts with grafting and some of the math just flies over my head
02:20:50 <frerich> dmwit: Hm that looks nicer, but I didn't look at nubBy nor "on" yet. Let me do some reading. Thanks for the food for thought! :-)
02:21:46 <napping> dmwit: where is on defined
02:21:51 <Eduard_Munteanu> radiobutton: it's just formal and in-depth
02:22:01 <napping> frerich: it's probably best not to use association lists too much
02:22:07 <dmwit> napping: Data.Function, probably
02:22:11 <dmwit> ?index on
02:22:11 <lambdabot> bzzt
02:22:14 <dmwit> ?hoogle on
02:22:14 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
02:22:14 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
02:22:14 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
02:22:30 <Eduard_Munteanu> The first part looks like definitions, you should probably look for something that helps you implement what you need.
02:22:42 <dmwit> napping++ You should use Data.Map instead.
02:22:42 <napping> frerich: unionBy can probably be a bit better behaved
02:23:17 * hackagebot ascii 0.0.2.1 - Type-safe, bytestring-based ASCII values.  http://hackage.haskell.org/package/ascii-0.0.2.1 (MichaelSnoyman)
02:23:19 * hackagebot cookie 0.2.0 - HTTP cookie parsing and rendering  http://hackage.haskell.org/package/cookie-0.2.0 (MichaelSnoyman)
02:23:21 * hackagebot json-enumerator 0.0.1.1 - Pure-Haskell utilities for dealing with JSON with the enumerator package.  http://hackage.haskell.org/package/json-enumerator-0.0.1.1 (MichaelSnoyman)
02:23:23 * hackagebot mime-mail 0.2.0.1 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.2.0.1 (MichaelSnoyman)
02:23:46 <napping> remember, [] is a linked list, so it's not even going to be much more memory efficien than Map
02:24:25 * hackagebot xml-enumerator 0.2.1 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.2.1 (MichaelSnoyman)
02:24:51 <frerich> napping, dmwit: Hm yes, I see. Thanks
02:29:08 <Athas> Is there a FIFO queue data type in the standard library?
02:29:55 <napping> Data.Sequence provides O(1) (amortized) access to the ends
02:30:28 <quicksilver> yeah, Data.Sequence is a good multipurpose structure.
02:31:29 <Athas> Nifty.
02:32:37 <napping> What are you doing with a queue?
02:33:27 <drbean> What's the datatype () in http://www.haskell.org/haskellwiki/GHC/Type_families
02:33:36 <napping> Probably ()?
02:34:23 <napping> I think it's built in, but more or less data () = ()
02:35:20 <quicksilver> yes, it's a basic haskell type, but it is quite equivalent to data One = One or data Unit = Unit.
02:35:29 <quicksilver> or data Badger = Badger for that matter.
02:50:50 <RayNbow`TU> preflex: seen roconnor
02:50:50 <preflex>  roconnor was last seen on #haskell 3 hours, 40 minutes and 20 seconds ago, saying: ddarius: do you ever sleep? :D
03:03:26 <pastorn> I need to express a regexp in attoparsec
03:03:33 <pastorn> ('0'?digit | '1'["012345"] | ["abcdefABCDEF"]);
03:04:09 <napping> what syntax is that?
03:04:26 <pastorn> napping: ["xyz"] is 'one of x y or z'
03:04:40 <napping> doesn't look like any regexps I know. I read that as 'one of x y z or " '
03:04:42 <pastorn> | = or, ? = optional
03:06:43 <napping> how about parsing with "hexadecimal" and checking the range?
03:07:20 <pastorn> well, how do i solve the optional prepending '0'?
03:08:20 <pastorn> ah, making up parsec combinators for attoparsec :)
03:08:21 <pastorn> optionDefault p def = P.choice [ P.try p, return def ]
03:09:11 <napping> it's allowed
03:09:29 <napping> parseOnly hexadecimal (pack "0a") ==> Right 10
03:09:47 <pastorn> napping: that's not allowed
03:12:53 <napping> why not allow it?
03:13:06 <pastorn> napping: cuz i don wanna!
03:13:25 <pastorn> if you're usenig hex syntax you're never going to need two digits
03:14:34 <napping> if you don't want to do that, write it with satisfy and stuff
03:15:13 <napping> two digit numbers are always considered decimal?
03:15:16 <napping> Ew
03:16:11 <pastorn> napping: only values of 0-15 are allowed
04:10:18 * hackagebot timers-updatable 0.1 - timers which are updatable in the remaining time  http://hackage.haskell.org/package/timers-updatable-0.1 (PaoloVeronelli)
04:24:33 <rostayob> are there any couchdb bindings that work with the current version?
04:46:18 <Axman6> rostayob: if the current ones don't work, you should email the maintainer
04:49:26 <rostayob> Axman6: well the readme says that it's for couchdb 0.10
04:49:52 <Axman6> rostayob: sure, and it would be good to let the author know that people want to use it with later versions ;)
04:54:17 <rostayob> Axman6: yes yes, I was just asking for some bindings I wasn't aware of
04:54:41 <Axman6> afaik, there's only one couchdb binding for haskell
04:57:02 <rostayob> Axman6: ok, thanks for the help anyway
05:01:24 <artefon> o
05:03:39 <Axman6> p
05:04:31 <Jafet> Wrong, bynbo.
05:04:44 <Axman6> D:
05:09:44 <Squarism> if need to compare n=20 miljon points with each other... is that a Ordo(n2) problem?
05:09:59 <Jafet> Compare by what
05:10:51 <Jafet> And why does it matter that n=20 milyon if you're asking about the asymptote
05:13:20 <zygoloid> Squarism: what are you looking for? pairs that are equal? pairs that are 'close? the closest two distinct points? ...
05:14:01 <Squarism> zygoloid, im just trying to quatify the problem... not finding a solution... i just wonder.. how many comparrisons must be done
05:14:24 <Jafet> Compare what
05:14:41 <Squarism> it doesnt matter
05:14:54 <Jafet> Dream on. It does.
05:15:40 <Squarism> if i say i must compare n entities with each other - how many comparrisons must be done - wo utilizing any tricks
05:16:04 <pastorn> n!
05:16:18 <Jafet> Are you trying to say, you want to sort n things?
05:16:42 <Squarism> or.. i want 20 miljon rabbits to mate with each other once.. how many mate event will there be
05:16:57 <Jafet> I give up.
05:17:03 <pastorn> 10 million !
05:17:31 <Squarism> its 1 + 2 + 3 + ... (20 mil - 1)
05:17:45 <pastorn> oh, shit
05:17:49 <pastorn> it's a simple sum
05:17:51 <pastorn> sorry
05:18:19 <Squarism> so is that Ordo(n) or n^2? 
05:18:23 <Jafet> @remember Squarism wo utilizing any tricks, i want 20 miljon rabbits to mate with each other once.. how many mate event will there be
05:18:23 <lambdabot> I will never forget.
05:18:30 <Jafet> Admittedly, that was a better question.
05:18:47 <Jafet> Squarism, so what is the value of 1 + 2 + ... + (n-1)?
05:20:00 <Squarism> is that n! ? My memory says n1 = 1*2*3*..*(n-1) ?
05:20:23 <Jafet> Are you guessing at random?
05:20:28 <Squarism> oh.. n1 = n! above
05:21:03 <Axman6> it's not n!, it's just the sum from 1 to n
05:21:03 <quicksilver> it's just like a football league.
05:21:03 <quicksilver> go look at a published match schedule :P
05:21:03 <pastorn> i need some attoparsec help, this is a bit too much: http://codepad.org/oY1yO3FC
05:21:09 <Jafet> Leagues are twice as large
05:21:26 <Jafet> Otherwise yes
05:22:51 <Jafet> Also, hermaphroditic rabbits.
05:26:18 <pastorn> Jafet: ah, didn't count on that :)
05:27:59 <pastorn> could someone look at my attoparsec code? any ideas of improvement are welcome
05:33:07 <yitz> pastorn: first, i think you're missing a try on the middle case. it's likely to eat stuff and then fail
05:33:40 <pastorn> yitz: won't the outer try (map try) fix that?
05:34:21 <yitz> pastorn: generally we use <|> rather than choice, unless you've really got a list in a natural way
05:34:31 <yitz> oh lemme see
05:34:46 <yitz> yeah
05:34:59 <pastorn> yeah what?
05:36:02 <yitz> yeah now i see that map try
05:36:11 <pastorn> heh, sorry for hiding it :)
05:36:13 <yitz> you need try on the last one also?
05:36:24 <pastorn> no, that's true
05:36:26 <pastorn> i don't
05:37:16 <yitz> pastorn: also you don't need try when you are only looking at a single character
05:37:27 <pastorn> huh?
05:40:18 <yitz> pastorn: what do you want to happen if the data after the first character isn't the right thing?
05:40:32 <pastorn> after the 'r'?
05:40:43 <yitz> the whole thing to fail, or move on and try the next case?
05:40:50 <yitz> i think you want it to fail
05:40:59 <pastorn> yitz: check the regex in the comment
05:41:08 <lispy> yitz: are you sure that single chars don't get consumed on failure?
05:41:13 <yitz> say your input is '0Q' what do you want to happen?
05:41:23 <pastorn> fail
05:41:33 <lispy> yitz: I recall trying to verify this via the docs and not having much luck
05:42:03 <pastorn> new version! http://codepad.org/ebY3Gti5
05:42:07 <yitz> lispy: i don't think so. do we have attoparsec here to try it?
05:42:19 <lispy> yitz: I think we have to fire up ghci :(
05:48:56 <pastorn> shit
05:49:36 <pastorn> oh wait, nevermind
05:51:54 <yitz> lispy: right, a single character is not consumed. there's always one available for inspection at the head of the incoming stream. that's why you can avoid try altogether by factoring the grammar.
05:54:10 <pastorn> yitz: ok, fixed it: http://codepad.org/auYHxBl3
05:54:23 <pastorn> could you tell me how to do this without try?
05:56:25 <yitz> pastorn: wait, first let's get the logic. what should "25" do? I think it will succeed and return '5'.
05:57:20 <yitz> pastorn: actually c5 where c is any character
05:57:56 <pastorn> yitz: "r25" should give (Reg 2) and "5" in the remaining string
05:58:44 <mm_freak> is there anything wrong with having multiple projects in one directory?
05:58:57 <pastorn> mm_freak: oi! :)
05:59:01 <pastorn> check my paste
05:59:01 <mm_freak> i.e. multiple cabal files
05:59:29 <dcoutts> mm_freak: can't have multiple cabal files in one directory
05:59:42 <mm_freak> pastorn: what's wrong with 'try'?
05:59:45 <mm_freak> dcoutts: ok, thanks
06:00:00 <pastorn> mm_freak: some people were rage-ing
06:00:37 <yitz> pastorn: because P.choice [ P.try (P.char '0'), return '0' ] always succeeds and is ignored. then it looks for a digit and returns it.
06:00:43 <mm_freak> pastorn: but you know that your first parser never fails?
06:01:10 <mm_freak> pastorn: really, 'try' is not 'optional'
06:01:31 <pastorn> isn't this 'optional'? P.choice [ P.try (P.char '0'), return '0' ]
06:01:50 <pastorn> "r01" == "r1"
06:02:37 <yitz> pastorn: it means see if the next char is a '0'. if not, just succeed and return '0' anyway.
06:02:47 <pastorn> this is for registers in an assemler language, 16 registers in tota
06:03:42 <yitz> pastorn: it's the same as P.try (P.char '0') <|> return '0', which is the same as P.char '0' <|> return '0', which is the same as return '0'
06:03:45 * hackagebot c2hs 0.16.3 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.16.3 (DuncanCoutts)
06:03:59 <pastorn> yitz: yeah, as in the regex (here explicit): '0'? ["0123456789"]
06:04:12 <mm_freak> pastorn: yes, but you don't want optional
06:04:17 <mm_freak> you WANT the parser to fail
06:04:31 <pastorn> the 0 should be optional
06:04:33 <mm_freak> because only then the next parser is tried
06:04:35 <mm_freak> no!
06:04:41 <pastorn> mm_freak: yes!
06:04:45 <mm_freak> it is required for octal numbers
06:05:23 <pastorn> mm_freak: so you are dissalowing a coding convention where two digits are used to write numbers < 10?
06:05:52 <mm_freak> pastorn: perhaps i don't understand your code, but your first parser never fails
06:05:57 <mm_freak> so the later parsers are never tried
06:06:32 <pastorn> mm_freak: oh, i see
06:06:35 <mm_freak> a failing parser consumes input, and 'try' makes a failing parser not consume input, so it's for backtracking
06:06:50 <pastorn> if i switch places between the first two?
06:06:57 <mm_freak> because <|> (and choice) can only try further cases, if no input has been consumed
06:07:12 <yitz> pastorn: what do you "r12" to do?
06:07:18 <yitz> want
06:07:22 <pastorn> yitz: Reg 12
06:07:26 <pastorn> i just noticed that
06:07:28 <mm_freak> pastorn: then the second one never fails
06:07:32 <mm_freak> so the third one is never tried
06:07:34 <yitz> pastorn: wrong it gives you the same as r02
06:07:50 <mm_freak> you will want your individual parsers to fail, if they don't get what they want
06:08:22 <pastorn> mm_freak: without consuming input...
06:09:04 <pastorn> what about now? http://codepad.org/Qxjq7gfA
06:09:15 <mm_freak> yes, but that's not the point…  try to write your parsers individually, and only then combine them using 'try' and 'choice'
06:09:42 <pastorn> hmmm
06:10:02 <mm_freak> view your individual parsers as individual, unrelated grammars
06:10:39 <mm_freak> as such they should fail, if they don't get what they want…  a parser, which always succeeds is almost always wrong
06:11:03 <yitz> pastorn: anyway, to answer your question about try, you never need try on P.char. You only need try around an expression that consumes more than one character, if you want to go back to the first character and try something else if it fails.
06:12:52 <pastorn> ok, so how do i  write that (P.char '0') is optional
06:12:58 <pastorn> thus not failing if it's not there
06:13:29 <yitz> pastorn: P.choice [ P.try (P.char '0'), return '0' ] - just write optional (P.char '0'). But I doubt that's what you really want
06:14:08 <pastorn> yitz: but an optional '0' is allowed to be there
06:14:44 <opqdonut> can I somehow trigger memory profiling from code?
06:14:59 <opqdonut> I'd like to build a structure and then look at how much memory is consumed
06:15:16 <yitz> pastorn: what do you want "r0" to do? your parser fails on that - it succeeds on the 0, discards it, and doesn't find anything else.
06:15:23 <opqdonut> I can of course take a heap profile and keep the structure alive long enough so that I can see it in the profile
06:15:36 <opqdonut> s/take a heap profile/do normal heap profiling/
06:15:40 <pastorn> yitz: yeah, you're rigth, that's the problem
06:15:53 <pastorn> so a unique one for "r00"?
06:17:39 <yitz> pastorn: well, i would say four cases: a single digit, a single letter, 0 and a digit, 1 and a digit
06:18:29 <yitz> pastorn: or you might want to combine the first two or the second two. but don't combine a single digit with two digits.
06:18:44 <pastorn> yitz: ah
06:18:51 <pastorn> clever
06:19:01 <pastorn> and i need to run the multi-digit first?
06:19:08 <yitz> right
06:24:33 <pastorn> yitz: http://codepad.org/sTHHxQrp
06:24:41 <pastorn> looks much nicer this way, thanks :D
06:26:11 <yitz> pastorn: now you're talking!
06:28:17 <pastorn> hehe :)
06:30:01 <pastorn> mm_freak: look! look! nice code!!
06:32:28 <dagle> Installing yesod from source was not an easy task. XD
06:32:43 <pastorn> dagle: what about cabal?
06:33:19 <dagle> pastorn: I wanted to generate packages for the distro. :)
06:37:03 <dagle> I hope most of the libs written for yesod goes stable when yesod goes 1.0
06:47:21 <pastorn> yitz: i've come up with another trick parser :)
06:48:24 <newgame> hi, haskell beginner here: I heard this is the place to ask for help. I'm writing some kind of mastermind simulation in haskell and I'm stuck.
06:48:41 <pastorn> yitz: it's for bitmasks; "%1000_11_01" is a valid bitmask for $8d
06:49:15 <pastorn> but! you're *not* allowed to begin or end with '_'
06:49:27 <newgame> I created a gist (https://gist.github.com/885062) with all of my questions and the accompanying source code. I would appreciate is somebody took a look at it
06:49:28 <dagle> newgame: Please state the nature of the problem. 
06:49:34 <dagle> nvm
06:51:37 <yitz> pastorn: http://codepad.org/IcDqRq87
06:52:09 <yitz> pastorn: iow you can put in underscores wherever you want?
06:52:24 <yitz> ah, but not at the beginning or end
06:52:41 <pastorn> yitz: yes, for separating out bitmask patterns
06:53:05 <pastorn> yitz: awesome! tiger woods doesn't stand a chance!
06:54:06 <pastorn> newgame: i always like to have 'zip' as prefix
06:54:26 <yitz> pastorn: decodeBitmask <$> ("%" *> digit <*> many digitOrSep <*> digit) where ...
06:54:44 <pastorn> yitz: damn you and your applicativeness!
06:55:26 <yitz> pastorn: it happens to be short, but golf wasn't the idea. it's a clear and idiomatic way to write it i think.
06:55:27 <benmachine> * dagle materialises
06:55:28 <benmachine> < dagle> newgame: Please state the nature of the haskell emergency.
06:55:40 <yitz> pastorn: anyway i'm faithful
06:55:50 <dagle> benmachine: Somebody got the joke. :)
06:55:52 <pastorn> hehe
06:56:11 <benmachine> dagle: aw, sorry for having to make it explicit :P
06:56:11 <newgame> pastorn: you mean i should write "zip a b" instead of "a `zip` b"?
06:56:15 * benmachine lacks subtlety
06:56:47 <dagle> benmachine: I havn't seen trek in like 7 years so I have forgotten how he said it. :)
06:57:20 <benmachine> heh
06:57:27 * benmachine makes up for it in obsessiveness
06:57:35 <dagle> :)
06:57:39 <frerich> newgame: I'm not a Haskell expert (I only did a few small projects) but I think using a type class to model the position is overkill. Instead, I'd just have "type Position = (Double, Double)", one 'Button' type which is "data Button = Button { position :: Position }" and t0-t1 would just be functions (like, 't0 :: Button' with 't0 = Button (-460, 982)')
06:57:41 <pastorn> newgame: yes... and what the heck is happening in createRandomCode?
06:59:14 <yitz> pastorn: we strive for: almost as short as a regexp, faster, clearly readable even by people who have never seen haskell (or regexps) before
06:59:20 <newgame> frerich: yes, seems like a good idea. Will change that
06:59:29 <frerich> newgame: Or, you could have an array of buttons 'buttons :: [Button]' with 'buttons = [Button pos | pos <- [(-460, 982), (460, 982) ...]]'
06:59:52 <pastorn> yitz: what about minimizing the amount of magic?
07:00:08 <frerich> newgame: A 'type class' is something very different than a 'class' in e.g. java, so maybe the fact that you wrote this in JAva already got you into the wrong mindset.
07:00:31 <yitz> pastorn: magic is ok if it's readable by humans
07:01:18 <newgame> frierich: the array is even better, so i could adress the buttons with an index. And yest, I'm probably not yet in the right mindset. Therefore I have these problems ;)
07:01:51 <newgame> pastorn: createRandomCode should simply create a random list of buttons e.g. [T0,T7,T3,T3]
07:01:53 <pastorn> newgame: in createRandomCode you just want 'length' many buttons?
07:01:54 <frerich> newgame: Using my suggestion, the signature of 'calcDistanc' would be just 'calcDistanc :: Position -> Position -> Double'. If you want to get more generic later, you could still think about parametrizing 'Position' (so that it takes Ints instead of Doubles or whatever).
07:02:33 <newgame> pastorn: yest
07:02:39 <newgame> yest -> yes
07:03:53 <yitz> pastorn: oops fixed a type error sorry http://codepad.org/UDdj3KVN
07:03:54 <newgame> frierich: yes, "Position -> Position -> Double" certainly looks better than "(Position a, Position b) => a -> b -> Double"
07:04:15 <frerich> newgame: Actually, I only now realize that this is implementing (the AI part of) a mastermind game. I should look away, since I was planning to write a mastermind game myself as an exercise :)
07:04:53 * odj
07:05:50 <newgame> frerich: Are you aiming at writing a mastermind game with a graphical interface?
07:05:54 <odj> help
07:08:26 <pastorn> newgame: createRandomCode :: Int -> StdGen -> [Button]
07:08:27 <yitz> oh my i hope odj is ok
07:08:27 <pastorn> createRandomCode n gen = take n . map fromEnum . randomRs range $ gen
07:08:29 <pastorn>   where 
07:08:31 <pastorn>     range = (0, fromEnum (maxBound :: Button))
07:09:08 <frerich> newgame: No, I skipped the graphical stuff so far. All my games are on the console only. For instance, recently I did an ASCII tic tac toe game.
07:10:03 <frerich> newgame: I'm trying to not get side tarcked by such things, so my IO is always very simple (usually getLine and putStr). I concentrate on modelling types correctly (I try to express as much as possible using types) and using the standard haskell modules.
07:10:07 <pastorn> newgame: have this:
07:10:45 <pastorn> onRoundCounter :: (Int -> Int) -> StateT SimulationState IO ()
07:10:50 <pastorn> now you'll have this:
07:11:03 <pastorn> incRoundCounter = onRoundCounter (+1)
07:11:19 <pastorn> resetRoundCounter = onRoundCounter (\_ -> 1)
07:11:50 <newgame> frerich: Well, I'd be very interested in your mastermind version (when it's ready). You don't have a github account or something, that I could follow?
07:12:20 <frerich> pastorn: Isn't \_ -> 1 just an odd way to write 'const 1'?
07:12:37 <pastorn> frerich: newgame is new to haskell, don't go messin with him
07:13:06 <frerich> newgame: I do have a github account (my username is "frerich"), but I didn't upload my stuff so far, but maybe I should.
07:13:15 <newgame> pastorn: hehe, I'm trying to put your suggestions into the code now
07:13:43 <frerich> pastorn: Oh, I thought that 'const 1' was actually a bit clearer (I'm a beginner as well) than using a lambda function which ignores its first argument
07:14:06 <pastorn> frerich: if you've seen the function 'const' before, it might be
07:14:40 <newgame> frerich: I am following you know ;). Hope you upload it soon
07:14:47 <pastorn> and i consider learning lamba notation to be far more important than gettin to know all the common functions
07:15:37 <frerich> newgame: I could upload my little tic tac toe game at least
07:16:01 <frerich> newgame: I'm around here most of the time (though lurking), maybe we can compare solutions a bit
07:18:29 <pastorn> newgame: cool idea with the typeclass
07:18:38 <pastorn> good for extendability
07:18:53 <pastorn> newgame: *but*, you might want to parameterize on the return structure
07:19:10 <pastorn> meaning that you might want to encode the dimensions in which you are expecting your result
07:20:02 <newgame> frerich: yeah, why not. I guess I will lurk here around, too
07:22:05 * hackagebot compdata 0.2 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.2 (PatrickBahr)
07:22:07 * hackagebot jmacro 0.4.5 - QuasiQuotation library for programmatic generation of Javascript code.  http://hackage.haskell.org/package/jmacro-0.4.5 (GershomBazerman)
07:22:21 <newgame> pastorn: do you mean the typeclass for the position? How would I do this? Like so: class Position a b where getPosition :: a -> (b, b)
07:22:36 <pastorn> newgame: not exactly
07:22:55 <pastorn> class Pos a t where getPos :: a -> t Double
07:23:05 <pastorn> so for instance you'd have instances for
07:23:11 <pastorn> Vec2 (,)
07:23:15 <pastorn> Vec3 (,,)
07:23:17 <pastorn> etc.
07:23:23 <MasseR> win 21
07:23:44 <pastorn> newgame: this requires the MultiParameterTypeclass language extension
07:24:40 <mm_freak> pastorn: hah!  much nicer and more readable ;)
07:25:00 <mm_freak> and yeah, i like <|> much better than 'choice' =)
07:25:04 <newgame> pastorn: ah allright, I kind of understand what that means. So getPos is not constrained to a specific dimension
07:25:15 <pastorn> mm_freak: do some scrolling, there was a superior version (which i'm not very inclined to use)
07:25:33 <pastorn> newgame: yes, that way you can't do
07:25:47 <pastorn> (x,y) = getPos my3dVector
07:27:56 <newgame> pastorn: thanks for the suggestion. So what would you say is better: Having the positional information for a button in a typeclass or doing it like frerich suggested (type Position = (Double, Double)) for my particular case? Or is it a question of taste?
07:28:59 <pastorn> newgame: i quite dislike the "type" word myself
07:29:41 <pastorn> having it in a typeclass might be useful, but unless you're gonna make more instances of that class
07:30:17 <newgame> pastorn: Why is that? Is that because type just creates an alias and so you can still make mistakes (as opposed to newtype)?
07:30:46 <pastorn> that, and i find that too much of it makes the code difficult to read
07:30:48 <napping> I don't see why you would use a typeclass like that
07:30:55 <pastorn> type errors get nastier
07:31:17 <pastorn> napping: read what i wrote about having it be multiparameter
07:31:31 <pastorn> napping: and it's quite useful, to avoid corrupting the namespace
07:31:48 <pastorn> (which i consider being the primary reason for a typeclass)
07:32:33 <napping> If you will have functions with types like (Pos a (,)) => a -> ...
07:32:45 <napping> you might as well just pass them a (Double,Double), because that's all they can do with the a anyway
07:33:11 <napping> It's just putting excess junk into the namespace, compared to using pairs
07:33:23 <newgame> pastorn: I have a question regarding 'onRoundCounter :: (Int -> Int) -> StateT SimulationState IO ()'. You did not provide an implementation. Don't I need one?
07:33:39 <pastorn> newgame: yes you do
07:34:08 <pastorn> onRonudCounter f = modify (\s -> s { roundCounter = f (roundCounter s) })
07:34:29 <newgame> pastorn: ah ok, I thought the compiler would figure it out itself, so I was confused. thanks
07:34:48 <pastorn> newgame: actually it should... haskell records are a bit borked
07:35:13 <pastorn> newgame: if you find yourself wanting to compose record computations more elegantly, look at the package "fc-labels" which helps you
07:35:27 <pastorn> it gives you "on*" functions for all fields in a record (Template Haskell)
07:39:16 <newgame> pastor: I just shallowily skimmed through the introduction of "fc-labels" and it indeed looks quite elegeant. Thanks for the suggestion
07:39:57 <pastorn> newgame: your records seem so small, so i wouldn't bother with it
07:40:32 <newgame> pastorn: ok
07:45:20 <newgame> pastorn++
07:50:57 <mm_freak> pastorn: maybe in the evening, i'm at work right now
07:51:45 <mm_freak> (and yes, i'm using haskell) =)
07:52:07 <dagle> "This is your brain on drugs, this is your brain using haskell, use haskell"
07:52:24 <newgame> pastorn: I read that one can give karma to helpful answers by writing name++ (http://www.haskell.org/haskellwiki/IRC_channel). I just did pastorn++ but I don't see any status message that it worked. Does the name++ karma actually work?
07:52:35 <pastorn> @karma pastorn
07:52:36 <lambdabot> You have a karma of 2
07:52:40 <mm_freak> pastorn: did you read about enumerator?
07:52:42 <mm_freak> @karma
07:52:42 <lambdabot> You have a karma of 0
07:52:45 <mm_freak> lol
07:52:50 <Jafet> @karma C
07:52:50 <lambdabot> C has a karma of 4
07:52:51 <pastorn> mm_freak++
07:52:51 <hape01> :-)
07:53:01 <pastorn> Jafet: lolz
07:53:05 <mm_freak> hehe
07:53:10 <mm_freak> @karma php
07:53:10 <lambdabot> php has a karma of -2
07:53:10 <pastorn> mm_freak: not yet...
07:53:14 <mm_freak> lol
07:53:22 <pastorn> i'm too scared of applicative
07:53:28 <hape01> @karma lambdabot
07:53:28 <lambdabot> lambdabot has a karma of 5
07:53:39 <mm_freak> pastorn: but you are using it, and enumerator has little to do with applicative
07:53:50 <mm_freak> in fact mostly you're either writing monadic or raw iteratees
07:54:17 <pastorn> my main reason for disliking applicative is the usage of a gazillion different operators, all with different menaings (<|>, <*>, <*, *>, <$, $> etc. etc.)
07:54:41 <benmachine> newgame: it works but lambdabot semi-regularly forgets everyone's karma so it's of little actual relevance (not that internet points systems are ever that relevant)
07:54:47 <mm_freak> pastorn: the main operators are <*>, <$> and <*
07:54:53 <mm_freak> the rest is just convenience
07:55:04 <benmachine> mm_freak: why <*?
07:55:09 <pastorn> mm_freak: that doesn't help much when reading coe
07:55:15 <mm_freak> benmachine: because *> is just >>
07:55:32 <mm_freak> but there is no combinator for <* for monads
07:55:37 <benmachine> mm_freak: sure, and <* is just liftA2 const or whatever
07:55:45 <Jafet> @quote hpc magic
07:55:45 <lambdabot> No quotes match. My mind is going. I can feel it.
07:55:52 <benmachine> I don't think there is a ($>) so there's only actually about five to remember
07:55:56 <mm_freak> benmachine: of course, i'm not talking about definition, but about practical usage
07:56:01 <benmachine> and (<*) and (*>) both have useful mnemonics
07:56:12 <newgame> benmachine: ok. thanks for the clarification
07:56:14 <mm_freak> in practice you will use <$>, <*> and <*
07:56:19 <mm_freak> i also sometimes use <$
07:56:21 <benmachine> mm_freak: oh, well, I use (*>) a fair bit because it has different fixity to (>>)
07:56:24 <benmachine> so it works better with >>
07:56:26 <benmachine> er
07:56:27 <benmachine> with <*>
07:56:31 <mm_freak> true
07:56:44 <benmachine> I overuse <$ I think :)
07:56:45 <mm_freak> pastorn: coe?
07:57:25 <mm_freak> i use <$ mostly with parsers:  Blah <$ try (string "blah") <|> Blubb <$ string "blubb"
07:57:56 <mm_freak> add a line feed and some indentation and it's great
07:58:25 <pastorn> oh, i usually call that "skipping"
07:58:38 <mm_freak> pastorn: skipping?
07:58:46 <pastorn> someParser `skipping` newline
07:59:02 <mm_freak> pastorn: no, i mean haskell source code
07:59:11 <mm_freak> to make the code more readable =)
07:59:18 <quicksilver> that skipping is probably *> not $>
07:59:20 <pastorn> = someParser >>= \x -> newline >> return x
07:59:24 <yitz> i use *> instead of >> in applicative-style code just because it is symmetric to <*
07:59:25 <sipa> :t (<$)
07:59:26 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
07:59:29 <mm_freak> what is $>?
07:59:29 <pastorn> mm_freak: i call the function "skipping"
07:59:50 <mm_freak> pastorn: 
08:00:04 <mm_freak> Blah  <$ try (string "blah") <|>
08:00:08 <quicksilver> mm_freak: it doesn't exist, but I meant it to be flip (<$)
08:00:13 <mm_freak> Blubb <$ string "blubb"
08:00:27 <mm_freak> and yes, no indentation
08:00:37 <mm_freak> but some alignment =)
08:00:52 <mm_freak> quicksilver: ah, ok…  it would be great from time to time
08:02:49 <mm_freak> pastorn: someParser <* newline
08:03:17 <mm_freak> char '(' *> expr <* char ')'
08:03:22 <mm_freak> the goodies of applicative style
08:03:31 <dagle> :)
08:03:32 <pastorn> mm_freak: lolz
08:03:33 <pastorn> wtf?
08:03:52 <pastorn> goddamn operator
08:04:07 <yottis> i find applicative useful to an extent, but it's easy to write cryptic code with it
08:04:16 <n0den1te> hey guys, I was reading ch4 of RWH. At some point, the authors say that it's better to use folds instead of using straight up recursion. It doesn't seem very convincing. Can anyone elaborate?
08:04:17 * pastorn nods
08:04:19 <yottis> breaking up on multiple lines helps
08:04:38 <mm_freak> n0den1te: using folds helps composability
08:04:55 <mm_freak> foldl' (+) 0 . map (^2)
08:05:04 <mm_freak> and it makes your code shorter, of course
08:05:04 <yottis> n0den1te: and once you understand the idiom, i think it adds readability
08:05:05 <n0den1te> mm_freak: sure, they mention that too and add consistent behaviour on top of it. 
08:05:29 <n0den1te> why not use tail recursive forms if recursion causes thunks to go out of memory?
08:05:44 <mm_freak> n0den1te: because foldl' does the same implicitly =)
08:06:04 <pastorn> @src foldl'
08:06:04 <lambdabot> foldl' f a []     = a
08:06:04 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:06:10 <n0den1te> After all, functions in haskell are just a couple of lines long. :)
08:06:16 <hpc> :t char
08:06:17 <lambdabot> Char -> Doc
08:06:23 <pastorn> n0den1te: not nesecarily...
08:06:24 <mm_freak> n0den1te: also note that tail recursion doesn't help with the thunks
08:06:40 <mm_freak> n0den1te: foldl is tail-recursive, but you will still not write a good 'sum' function with it
08:06:50 <n0den1te> mm_freak: yes, the point of tail recursion is not to create thunks, I think. 
08:06:55 <mm_freak> no
08:06:58 <yottis> haskell functions typically equal to what would be one statement in other languages
08:07:08 <mm_freak> it's to convert linear stack space to constant stack space
08:07:20 <Jafet> > let sum xs = let sum' acc [] = acc; sum acc (x:xs) = sum (x + acc) xs in sum [1..1000000]
08:07:21 <lambdabot>   not an expression: `let sum xs = let sum' acc [] = acc; sum acc (x:xs) = su...
08:07:21 <yottis> so it adds modularity, the amount of code isn't necessarily that much less
08:07:27 <yottis> depends on what you do
08:07:30 <Jafet> > let sum xs = let sum' acc [] = acc; sum acc (x:xs) = sum (x + acc) xs in sum' 0 xs in sum [1..1000000]
08:07:31 <lambdabot>   *Exception: <interactive>:3:17-33: Non-exhaustive patterns in function sum'
08:07:33 <n0den1te> mm_freak: Isn't what I said equivalent to yours?
08:07:42 <Jafet> Erk
08:07:53 <Jafet> > let sum xs = let sum' acc [] = acc; sum' acc (x:xs) = sum (x + acc) xs in sum' 0 xs in sum [1..1000000]
08:07:54 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
08:08:05 <mm_freak> n0den1te: nope, thunks are about evaluation, stack is about calling
08:08:14 <mm_freak> the calling consumes less (or no) memory with TC
08:08:28 <mm_freak> but tail recursion doesn't force any thunks to get evaluated
08:08:39 <mm_freak> you need strictness for that
08:09:00 <Jafet> Okay now
08:09:00 <n0den1te> mm_freak: I thought thunks are those caching zones where the compiler can cache expressions before performing any computations on them. 
08:09:09 <Jafet> > let sum xs = let sum' acc [] = acc; sum' acc (x:xs) = sum' (x + acc) xs in sum' 0 xs in sum [1..1000000] -- "tail recursive"
08:09:10 <lambdabot>   *Exception: stack overflow
08:09:33 <mm_freak> n0den1te: no, every expression is a thunk at first
08:09:41 <Jafet> > let sum xs = foldl' (+) 0 xs in sum [1..1000000] -- strict evaluation to save space
08:09:42 <lambdabot>   500000500000
08:09:45 <jmcarthur> n0den1te: consider something like:   sum acc [] = 0; sum acc (x:xs) = sum (x + acc) xs
08:09:48 <mm_freak> then you have something, which forces evaluation of one thunk, like printing a value
08:09:58 <jmcarthur> n0den1te: the accumulator isn't being forced, even though it's tail recursive
08:10:02 <mm_freak> evaluating that thunk forces more thunks, and so on
08:10:07 <jmcarthur> woops
08:10:15 <jmcarthur> sum acc [] = acc
08:10:15 <zygoloid> n0den1te: one reason to use folds instead of recursion is that folds can fuse
08:10:17 <mm_freak> this is how your haskell program works under the hood
08:10:29 <mm_freak> also zygoloid made a good point:  fusion
08:10:39 <mm_freak> but that's not one of the main points
08:10:42 <jmcarthur> zygoloid: an unfortunate additional reason to use folds, though
08:10:43 <n0den1te> zygoloid: I'd have agreed with you said "confuse" than "can fuse" :P
08:11:17 <n0den1te> What's fusion? I mean what does it mean to fuse functions? 
08:11:24 <mm_freak> lol
08:11:37 <jmcarthur> n0den1te: sum . map f   gets fused into a single loop, for example
08:11:38 <mm_freak> fusion eliminates lists and turns list transformations into tight loops
08:11:46 <zygoloid> jmcarthur: well, the other reasons being given are 'why not to use non-strict tail recursion' not 'why use folds rather than recursion'
08:11:49 <n0den1te> jmcarthur: composing? 
08:12:00 <pastorn> is it the same as fold g . build f = g . f ?
08:12:05 <mm_freak> n0den1te: anyway, the main reason IMO is composability
08:12:06 <pastorn> (fusion, that is)
08:12:07 <jmcarthur> n0den1te: you could say that function composition is what benefits from fusion the most
08:12:23 <mm_freak> pastorn: no
08:12:28 <mm_freak> that's just a rewrite rule
08:12:39 <pastorn> where and how is fusion done then?
08:12:48 <zygoloid> fold-build fusion is one type of fusion, but it's not the definition of fusion
08:13:02 <jmcarthur> i prefer "deforestation"
08:13:12 <mm_freak> fusion does not optimize list transformations, it turns list transformations into loops, i.e. completely removes the data structure
08:13:14 <jmcarthur> i take fusion to mean a certain kind of deforestation
08:13:20 <yitz> n0den1te: the compiler fuses the function that creates a list with the function that consumes it. the result is a fast tight loop in assembler with out ever creating any list.
08:13:22 <n0den1te> err, I don't understand fusion now.... 
08:13:24 <pastorn> isn't there a deep list library where fusion is done at runtime?
08:13:42 <mm_freak> n0den1te: don't worry about it…  view it as a handy optimization for now =)
08:14:10 <n0den1te> mm_freak: Sure thing, mate. I'm still at ch4 of RWH after all. :)
08:14:14 <mm_freak> n0den1te: but in general, whenever you intuitively think that a list transformation would be implemented as a tight loop, when done in C, it probably is fused into one in haskell =)
08:14:55 <jmcarthur> n0den1te: fusion just means that if you have a function that generates a tree structure and another that recurses over it, the composition of the two functions is very fast, and there doesn't need to actually be an intermediate structure
08:14:59 <yitz> pastorn: no it's done in the compiler, as part of the optimization stage before it generates the machine code output
08:15:23 <jmcarthur> n0den1te: at least, when the appropriate rules are written into the library you are using...
08:15:30 <n0den1te> jmcarthur: so that's what mm_freak meant by one tight loop. I see... 
08:15:46 <Jafet> Fusion just means we've bumped off the original topic of explaining non-strict evaluation to nodenite
08:16:15 <mm_freak> n0den1te: anyway, again, fusion is not the main point to use combinators
08:16:15 <jmcarthur> this is what happens when people like myself walk into a conversation without knowing the topic ;)
08:16:19 <n0den1te> Jafet: :D
08:16:32 <mm_freak> combinator style is very integral in haskell, and you see its power only when using it
08:16:42 <pastorn> yitz: yes, i know this, but i'm talking about cases that the compiler misses
08:16:42 <mm_freak> mainly when having to change code
08:16:45 <mm_freak> not when originally creating it
08:16:53 <pastorn> where a deep list implementation might be benificial
08:16:55 <jmcarthur> IMO, the main reason to use folds and such is that it increases readability and decreases the number of things you have to keep in your head at once
08:17:04 <jmcarthur> that only applies with experience, though
08:17:16 <jmcarthur> to a complete newb, it makes sense that it's harder to follow
08:17:17 <yitz> pastorn: there are ways of cluing it in when it can't find it itself
08:17:32 <pastorn> yitz: like how?
08:17:37 <jmcarthur> but i promise it's worth getting used to folds
08:17:42 <yitz> pragmas
08:17:56 <pastorn> yitz: rewrite rules?
08:18:00 <yitz> yes
08:18:16 <jmcarthur> there are cases that are impossible to catch statically, though
08:18:20 <n0den1te> jmcarthur: As a newbie, I'd have stuck with straight up recursion after working my head around them than heading into unknown waters.
08:18:33 <n0den1te> It feels like going for the sea after running the mountains. :|
08:18:44 <EvanR-work> jmcarthur: to a complete noob, i have seen people have great difficulty with an accumulating for loop
08:18:48 <jmcarthur> n0den1te: the mountains were just in the way :P
08:18:55 <mm_freak> n0den1te: using combinators instead of explicit recursion can be justified with about the same reasoning as using 'while' instead of explicit 'goto' in imperative programming
08:19:06 <jmcarthur> n0den1te: the ultimate goal was the sea in the first place
08:19:25 <jmcarthur> hard to write a fold without understanding recursion in the first place
08:19:32 <jmcarthur> *to write or use
08:19:33 <zygoloid> @remember mm_freak using combinators instead of explicit recursion can be justified with about the same reasoning as using 'while' instead of explicit 'goto' in imperative programming
08:19:33 <lambdabot> I will never forget.
08:19:47 <yitz> jmcarthur is lucky that n0den1te's original metaphor didn't involve a frying pan and a fire
08:20:00 <jmcarthur> yitz: it was a convenient analogy to stretch, yes
08:20:20 <pastorn> lambdabot needs to change that string...
08:20:20 <jmcarthur> s/analogy/metaphor/  <-- better
08:20:39 <pastorn> thit should've said "mm_freak - NEVAR FORGET!"
08:21:02 <n0den1te> whoa... I'll dive into folds and see what gems I come across... :)
08:21:11 <Jafet> Or writing explicit recursion in explicit continuation passing style
08:21:12 <n0den1te> s/gems/pearls/
08:21:26 <pastorn> n0den1te: you'll notice that there are fold functions for a lot of structures
08:21:41 <n0den1te> pastorn: I saw that. You could write sum in a fold. 
08:21:49 <n0den1te> fold (+) [1..500]
08:21:57 <mm_freak> n0den1te: probably not a lot from folds alone…  as said, you will see the power when having to combine or change code =)
08:21:57 <n0den1te> foldl - tsk
08:21:58 <jmcarthur> @src sum
08:21:58 <lambdabot> sum = foldl (+) 0
08:22:08 <hpc> > foldr (+) 0 [1..500]
08:22:09 <lambdabot>   125250
08:22:11 <pastorn> n0den1te: no, i mean that there's a fold for Map, and probably for Array and other stuff
08:22:19 <mm_freak> that's why that stuff is called "combinators" =)
08:22:25 <n0den1te> pastorn: yes, that one too. all you need is a zeroth function. :)
08:22:38 <n0den1te> and substitute in place - ah, compose. :)
08:22:45 <mm_freak> so if 'while' is one level above 'goto', then folds are two levels above explicit recursion
08:23:08 <mm_freak> because 'whiles' are not composable
08:23:44 <n0den1te> > foldl (+) 0 [1..5000]
08:23:45 <lambdabot>   12502500
08:24:29 <yitz> actually i consider folds somewhat low-level too, though not as much so as raw recursion. i prefer things like iterate, map, and filter where possible.
08:24:41 <dagle> > let overninethousand = 9001 in foldl (+) 0 [1..overninethousand]
08:24:42 <lambdabot>   40513501
08:24:53 <dagle> :)
08:25:27 <benmachine> yitz: it depends. sometimes a fold is just the simplest thing
08:25:28 <pastorn> yitz: me too, i only use folds for very special cases, like creating structures etc.
08:25:40 <zygoloid> @let overninethousand = (/9000)
08:25:41 <lambdabot>  Defined.
08:25:43 <pastorn> (foldring inserts etc.)
08:26:03 <benmachine> but obviously if you are explicitly writing folds that already have a name that's bad
08:26:04 <jmcarthur> yitz: i consider those to just be specialized folds and unfolds anyway, although it's true that i rarely approach them that way directly
08:26:11 <yitz> benmachine: sometimes even raw recursion is the simplest, so i'll use that. but it's not my first choice, and neither are folds
08:26:40 <yitz> jmcarthur: right. well. folds are just specialized raw recursion. :)
08:26:53 <n0den1te> well, I got another question. If we consider folds to be reducing machines, do we have have unfolds too? expand on folds (like dumper in perl)
08:27:05 <yitz> @type unfoldr
08:27:06 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:27:09 <jmcarthur> the kinds of low level folds you are talking about are rather unspecialized, actually
08:27:21 <n0den1te> yitz: example application, please?
08:27:25 <pastorn> n0den1te: look in the Enum class
08:27:40 <yitz> jmcarthur: you can do a *lot* with iterate, map, and filter
08:27:44 <pastorn> n0den1te: there you have examples of "building" functions
08:27:58 <jmcarthur> > unfoldr (\x -> Just (x, succ x)) 0
08:27:59 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
08:28:03 <EvanR-work> you can defined sum as a fold, therefore you can define difference as an unfold ;)
08:28:13 <Jafet> Recursion, folds, combinators... eventually you reach a pointless level of abstraction.
08:28:58 <hpc> Jafet: eventually...
08:28:59 <jmcarthur> EvanR-work: huh?
08:29:00 <hpc> :P
08:29:08 <EvanR-work> jmcarthur: maybe not
08:29:11 <n0den1te> jmcarthur: urr, that's just a way of an infinite list. I had asked about the case where you fold an expression and later unfold it to see how that's traversed.. Anything like it?
08:29:23 * hpc found the other day that the fibbonaci sequence is a fixed point of the difference engine
08:29:35 <n0den1te> Jafet: The way of the Haskeller? :D
08:29:51 <mm_freak> n0den1te: scanl/scanr?
08:30:00 <n0den1te> @type scanl
08:30:01 <mm_freak> > scanl (+) 0 [1..]
08:30:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
08:30:01 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
08:30:20 <jmcarthur> n0den1te: a fold followed by an unfold? that's a case that's normally not worth analyzing. if you fold a list to an Int and then generate another list from that, the two lists have very little in common aside from that single value
08:30:23 * hackagebot http-types 0.6.0.1 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.0.1 (AristidBreitkreuz)
08:30:25 * hackagebot clientsession 0.6.0 - Store session data in a cookie.  http://hackage.haskell.org/package/clientsession-0.6.0 (MichaelSnoyman)
08:30:25 <Jafet> Or as other people call it, a pointfree level of abstraction
08:30:28 <hpc> > scanl f x [1..]
08:30:29 <lambdabot>   [x,f x 1,f (f x 1) 2,f (f (f x 1) 2) 3,f (f (f (f x 1) 2) 3) 4,f (f (f (f (...
08:30:32 <mm_freak> > scanl (+) x [y,z]
08:30:32 <lambdabot>   [x,x + y,x + y + z]
08:30:38 <mm_freak> > scanr (+) x [y,z]
08:30:39 <jmcarthur> n0den1te: an unfold followed by a fold, however, captures a huge number of recursive algorithms
08:30:39 <lambdabot>   [y + (z + x),z + x,x]
08:30:48 <n0den1te> jmcarthur: I was looking at it purely for debugging purposes. 
08:30:48 <hpc> ooh, fun
08:31:02 <EvanR-work> debug.trace
08:31:10 <hpc> an unfold followed by a fold is a paramorphism
08:31:29 <jmcarthur> hpc: hylomorphism, isn't it?
08:31:41 <hpc> hylo is the crazy fibbonacci one
08:31:45 <n0den1te> paramorphism - that's a word I'll have to look up... Trolling academics... :|
08:31:51 <hpc> para is cata . ana
08:31:57 <jmcarthur> err
08:32:01 <jmcarthur> i'm not sure you're right
08:32:03 * jmcarthur looks it up
08:32:05 <n0den1te> cata composed ana. duh.. 
08:32:10 <jmcarthur> i'm pretty sure hylo is cata . ana
08:32:12 <hpc> n0den1te: :D
08:32:13 <mm_freak> n0den1te: don't look it up
08:32:14 <Jafet> > map ($x) $ iterate (join (.)) f
08:32:16 <lambdabot>   [f x,f (f x),f (f (f (f x))),f (f (f (f (f (f (f (f x))))))),f (f (f (f (f ...
08:32:39 <hpc> no wait, you are right
08:32:40 <benmachine> jmcarthur: this is my memory too
08:32:41 <hpc> it is hylo
08:32:44 <Boxo> :t cata
08:32:45 <lambdabot> Not in scope: `cata'
08:33:02 <yitz> > let extract = concatMap (unfoldr $ listToMaybe . reads) . tails in extract "The number s are 5, 20 and 42." :: [Int] -- here is an example, n0den1te 
08:33:04 <lambdabot>   [5,5,20,20,0,42,42,2]
08:33:07 <hpc> para is the odd one
08:33:22 <Skola> what's the fastest way to remove duplicates from a list of Ints?
08:33:25 <Skola> nub is slow
08:33:27 <jmcarthur> paranormal :P
08:33:30 <yitz> hmm
08:33:35 <hpc> @src nub
08:33:35 <lambdabot> nub = nubBy (==)
08:33:42 <Skola> toList . from List is even faster
08:33:44 <EvanR-work> Skola: dont use a list
08:33:47 <Skola> but it's ugly
08:33:48 <hpc> Skola: sort, then head . group
08:33:48 <Skola> ok
08:33:51 <ion> > fix f
08:33:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:33:52 <lambdabot>    `GHC.Show.Show a'
08:33:52 <lambdabot>      a...
08:33:58 <jmcarthur> Skola: if you are willing to sort the elements then you could go through Data.Set or you could do...    map head . group . sort
08:34:01 <DRMacIver> Set.toList . Set.fromList was the fastest way I could find to do this
08:34:04 <hpc> or toList . fromList :P
08:34:15 <Jafet> Skola: nub is order-preserving.
08:34:28 <n0den1te> yitz: wait, does the :: [Int] force type to take only Ints? or does it apply to reads as well?
08:34:29 <DRMacIver> Although I had (short) Text, not Ints, and with a lot of duplication. YMMV.
08:34:41 <Jafet> I suppose you can keep the original permutation, but then nub is also lazy
08:34:45 <yitz> n0den1te: it
08:34:51 <DRMacIver> nub is also O(n^2) is it not?
08:35:02 <Skola> yes
08:35:02 <yitz> n0den1te: it's there because of reads, which is very polymorphic.
08:35:04 <hpc> DRMacIver: indeed; it has to be
08:35:06 <DRMacIver> Right
08:35:11 <hpc> DRMacIver: at least, in the worst case
08:35:18 <hpc> if all elements are the same, it is O(n)
08:35:32 <DRMacIver> True.
08:35:50 <Jafet> It can't possibly be better unless you add Ord constraint as well.
08:36:04 <hpc> how does Ord help?
08:36:17 <hpc> oh, because you can sort
08:36:19 <copumpkin> knowledge
08:36:29 <copumpkin> more knowledge = better algorithms possible ;)
08:36:42 <quicksilver> technically you don't need a full sort
08:36:45 <Jafet> battle/2
08:36:51 <quicksilver> you can just "heap" it to nub it
08:36:54 <hpc> copumpkin: duh; i mean in this specific case, what does the knowledge do?
08:37:02 <jmcarthur> with Ord, you could index the elements, sort by value and remove dups, then reorder by index and drop the indices
08:37:16 <n0den1te> ghc.6.12.3 barfs at unfoldr
08:37:29 <hpc> n0den1te: did you try to unfoldr an infinite list?
08:37:32 <hpc> er
08:37:36 <hpc> :t unfoldr
08:37:37 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:37:38 <yitz> n0den1te: ah, ok now i remember:
08:37:41 <Skola> I should work with Sets instead when I only work with Ints?
08:37:42 <yitz> > let extract = unfoldr (listToMaybe . concatMap reads . tails)  in extract "The number s are 5, 20 and 42." :: [Int]
08:37:43 <lambdabot>   [5,20,42]
08:37:43 <Jafet> You could just add the elements to a Map and refuse duplicates.
08:37:49 <Jafet> Er, Set
08:37:55 <yitz> \o/
08:38:10 <jmcarthur> @let ordNub = map snd . sortBy (comparing fst) . map head . groupBy ((==) `on` snd) . sortBy (comparing snd) . zip [0..]
08:38:10 <n0den1te> hpc: it simply says "unfoldr is not in scope"
08:38:11 <lambdabot>  Defined.
08:38:16 <EvanR-work> Skola: if you dont want duplicats and dont care about sequence order, use a set?
08:38:18 <hpc> n0den1te: then import Data.List
08:38:20 <hpc> @hoogle unfoldr
08:38:21 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
08:38:21 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
08:38:21 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
08:38:25 <jmcarthur> > ordNub [1,4,7,3,5,6,3,2,3,5,45,3,2,5]
08:38:27 <lambdabot>   [1,4,7,3,5,6,2,45]
08:38:33 <Jafet> Skola: IntSet?
08:38:37 <hpc> n0den1te: lambdabot is significantly larger than Prelude ;)
08:38:45 <dagle> :t tails
08:38:45 <jmcarthur> @check \xs -> nub xs == ordNub (xs :: [Int])
08:38:45 <lambdabot> forall a. [a] -> [[a]]
08:38:46 <lambdabot>   Not in scope: `ordNub'
08:38:47 <n0den1te> hpc: :)
08:38:51 <jmcarthur> aw
08:39:00 <mm_freak> (as a side note, 'iterate' is often more convenient than 'unfoldr')
08:39:07 <Skola> thanks Jafet / EvanR
08:39:09 <hpc> > tails [1..3]
08:39:10 <lambdabot>   [[1,2,3],[2,3],[3],[]]
08:39:15 <n0den1te> yitz: \o/ now I can read it!
08:39:17 <hpc> :t iterate
08:39:17 <lambdabot> forall a. (a -> a) -> a -> [a]
08:39:18 <Skola> <- just crawling out of the Prelude
08:39:25 <hpc> > iterate f x
08:39:26 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
08:39:31 <mm_freak> > takeWhile (< 100) . iterate (\x -> x^2 + 1) $ 0
08:39:32 <lambdabot>   [0,1,2,5,26]
08:39:58 <hpc> > iterate (\x -> x^2 + 1) $ 0
08:39:59 <lambdabot>   [0,1,2,5,26,677,458330,210066388901,44127887745906175987802,194727047691529...
08:40:05 <hpc> wow, that gets big fast
08:40:22 <mm_freak> > iterate (2^) 0
08:40:22 <lambdabot>   [0,1,2,4,16,65536,200352993040684646497907235156025575044782547556975141926...
08:40:24 <jmcarthur> one downside to my ordNub function is that it's not lazy at all
08:40:34 <zygoloid> > iterate (join (^)) 2
08:40:49 <lambdabot>   thread killed
08:40:50 <hpc> :t join (^)
08:40:57 <lambdabot> forall a. (Integral a) => a -> a
08:40:59 <hpc> :t join (**)
08:40:59 <zygoloid> > take 3 $ iterate (join (^)) 2
08:41:01 <lambdabot> forall a. (Floating a) => a -> a
08:41:04 <lambdabot>   mueval-core: Time limit exceeded
08:41:10 <zygoloid> > take 2 $ iterate (join (^)) 2
08:41:14 <lambdabot>   mueval-core: Time limit exceeded
08:41:17 <ion> haha
08:41:27 <dagle> Are you trying to crash lambdabot?
08:41:29 <hpc> > join (^) 2
08:41:34 <lambdabot>   mueval-core: Time limit exceeded
08:41:35 <hpc> wtf
08:41:47 <hpc> > join (^) x
08:41:54 <jmcarthur> > 2^2
08:41:57 <lambdabot>   mueval-core: Time limit exceeded
08:41:57 <lambdabot>  mueval: ExitFailure 1
08:42:01 <jmcarthur> :(
08:42:03 <jmcarthur> > 1
08:42:06 <hpc> > 2**2
08:42:12 <jmcarthur> lambdabot is borked
08:42:14 <hpc> i do not even
08:42:23 <zygoloid> oops
08:42:27 <lambdabot>   mueval-core: Time limit exceeded
08:42:28 <lambdabot>   mueval-core: Time limit exceeded
08:42:32 <zygoloid> yeah, so, that one grows /very/ fast
08:42:32 <hpc> let's wait for whoever it is to stop DoSing λbot
08:42:57 <n0den1te> > 2 + 2
08:42:57 <lambdabot>   4
08:43:01 <zygoloid> > iterate (join (^)) 2
08:43:02 <n0den1te> :D
08:43:12 <lambdabot>   mueval: ExitFailure 1
08:43:18 <Cale> > 2 + 2
08:43:20 <lambdabot>   4
08:43:38 <Cale> should be okay now
08:43:44 <zygoloid> > take 4 $ iterate (join (^)) 2
08:43:48 <lambdabot>   [2,4,256,323170060713110073007148766886699519604441026697154840321303454275...
08:44:05 <yitz> > iterate show "n0den1te"
08:44:06 <lambdabot>   ["n0den1te","\"n0den1te\"","\"\\\"n0den1te\\\"\"","\"\\\"\\\\\\\"n0den1te\\...
08:44:20 <zygoloid> > length . show $ iterate (join (^)) 2 !! 3
08:44:21 <lambdabot>   617
08:44:53 <ion> > map (length . show) $ iterate (join (^)) 2
08:45:23 <yitz> > length $ iterate show "n0den1te" !! 10
08:45:26 <lambdabot>   mueval-core: Time limit exceeded
08:45:36 * zygoloid ponders: let f n = f (n-1) ^ f (n-1). for which n is this larger than graham's number?
08:45:55 <zygoloid> (.. is this /first/ larger than..)
08:46:11 <yitz> zygoloid: you need to seed that recursion
08:46:17 <zygoloid> yitz: f 0 = 2
08:46:27 <yitz> zygoloid: thanks!
08:46:31 <zygoloid> no problem! :)
08:46:40 <ion> f 0 = grahamsNumber
08:47:30 <mm_freak> > let 2 + 2 = 5 in 2 + 2
08:47:31 <lambdabot>   5
08:47:42 <ion> hah
08:47:44 * zygoloid suspects n is still unimaginably large
08:48:16 <Younder> Grahams number is not actually a number
08:48:33 <Jafet> Note that f is still primitive recursive...
08:49:20 <tromp__> f is too slow groing
08:49:36 <tromp__> try f = goodstein's function
08:49:57 <anincog> any hmatrix users here?
08:50:02 <n0den1te> :t listToMaybe
08:50:07 <lambdabot> forall a. [a] -> Maybe a
08:50:18 <n0den1te> @hoogle listToMaybe
08:50:18 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
08:50:50 <tromp__> @let g b 0=b;g b n=g c$s 0n-1where s _ 0=0;s e n=mod n b*c^s 0e+s(e+1)(div n b);c=b+1
08:50:50 <lambdabot>   Float with missing exponent
08:51:11 <quicksilver> zygoloid: yes, graham's number is "unimaginably" large expressed as a simple power tower and all your recurrence does is build simple power towers.
08:51:27 <quicksilver> zygoloid: you need another level of meta-ness. But, offtopic ;)
08:51:39 <Jafet> > nub [1..100000]
08:51:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:51:48 <Jafet> > length $ nub [1..100000]
08:51:51 <lambdabot>   mueval-core: Time limit exceeded
08:51:58 <Jafet> > length $ let ordNub xs = let f s [] = []; f s (x:xs) = if Data.Set.member x s then f s xs else x: f (Data.Set.insert x s) xs in f Data.Set.empty xs in ordNub [1..100000]
08:51:59 <lambdabot>   Not in scope: `Data.Set.member'Not in scope: `Data.Set.insert'Not in scope:...
08:52:08 <Jafet> > S.empty
08:52:09 <lambdabot>   fromList []
08:52:20 <Jafet> > length $ let ordNub xs = let f s [] = []; f s (x:xs) = if S.member x s then f s xs else x: f (S.insert x s) xs in f S.empty xs in ordNub [1..100000]
08:52:21 <lambdabot>   100000
08:52:29 <Jafet> There we go
08:53:01 <Jafet> @check let ordNub xs = let f s [] = []; f s (x:xs) = if S.member x s then f s xs else x: f (S.insert x s) xs in f S.empty xs in \xs -> nub xs == ordNub (xs :: [Int])
08:53:02 <lambdabot>   "OK, passed 500 tests."
08:57:45 <tromp__> :t (!!)
08:57:46 <lambdabot> forall a. [a] -> Int -> a
09:00:31 <tromp__> @pl \n -> iterate (g (m-1)) n !! n
09:00:31 <lambdabot> (!!) =<< iterate (g (m - 1))
09:12:03 <tromp__> @pl \n -> succ n + n
09:12:03 <lambdabot> (+) =<< succ
09:13:08 <tromp__> > (+) =<< succ $ 5
09:13:08 <lambdabot>   11
09:21:37 <siracusa> > succ . join (+) $ 5
09:21:38 <lambdabot>   11
09:22:12 <aristid> > (*2) . (+0.5) $ 5
09:22:14 <lambdabot>   11.0
09:22:23 <hape01> I am installing hoogle on Windows, but dont have cygwin/mingw.  Can I go arround this blocking issue:    wget  not found - when I do "hoogle data"
09:22:49 <hape01> I cant live without hoogle anymore :-)
09:22:57 <aristid> hape01: install wget?
09:23:08 <aristid> i think you can install it without mingw
09:23:12 <hape01> aristid: wget is an ghc package? 
09:23:16 <aristid> no.
09:23:22 <hape01> i can do cabal install wget?
09:23:25 <n0den1te> no, it must be available as a cygwin package though. 
09:23:26 <aristid> no.
09:23:42 <aristid> i THINK there is a native windows version of wget somewhere
09:23:43 <hape01> but I dont have cygwin
09:23:48 <hape01> ah
09:23:51 <monochrom> install virtualbox. install linux in virtualbox. use wget inside linux inside virtualbox. transfer files.
09:24:01 <hape01> :-)
09:24:20 <hape01> monochrom: I didnt want to turn inside out
09:24:30 * aristid can't imagine developing (in any language) on windows
09:24:38 <aristid> but that's just me :P
09:24:48 <hape01> aristid: I have multiple locations, that is ok
09:24:49 <n0den1te> hape01: if you can do haskell, vbox way is straightforward. :P
09:24:52 <hape01> I prefer Ubuntu also
09:24:53 <Eduard_Munteanu> Uh, I wouldn't try Cygwin.
09:25:01 <Eduard_Munteanu> Better see if there's a wget in MSYS/MinGW
09:25:02 <monochrom> well, supposed on windows you stay inside visual studio.
09:25:22 <hape01> now I have many directions giving me some hope
09:25:40 <lpsmith> > (*) =<< succ $ 5
09:25:40 <lambdabot>   30
09:25:49 <lpsmith> > succ . join (*) $ 5
09:25:51 <lambdabot>   26
09:26:16 <aristid> > join (^) 5
09:26:17 <lambdabot>   3125
09:26:23 <benmachine> > (*) <*> succ $ 5
09:26:24 <lambdabot>   30
09:26:44 <aristid> :t iterateN
09:26:45 <lambdabot> Not in scope: `iterateN'
09:26:47 <benmachine> hape01: it strikes me as weird that hoogle needs wget
09:26:57 <aristid> @hoogle iterateN
09:26:57 <lambdabot> No results found
09:27:09 <Eduard_Munteanu> :t (^)
09:27:10 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
09:27:40 <Eduard_Munteanu> :t join
09:27:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:27:55 <benmachine> hape01: if you acquire some stuff yourself you shouldn't need it
09:27:57 <Eduard_Munteanu> :t join (^)
09:27:58 <lambdabot> forall a. (Integral a) => a -> a
09:28:47 <benmachine> hape01: how good are you at reading source?
09:28:49 <aristid> @let iterateN n f x | n <= 0 = x | otherwise = iterateN (n-1) f (f x)
09:28:51 <lambdabot>  Defined.
09:28:51 <Eduard_Munteanu> Hm, would that be (->) as a monad?
09:29:06 <benmachine> Eduard_Munteanu: ((->) r) to be precise
09:29:16 <aristid> :t flip iterateN (+)
09:29:16 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t
09:29:16 <lambdabot>     Probable cause: `+' is applied to too few arguments
09:29:17 <lambdabot>     In the second argument of `flip', namely `(+)'
09:29:18 <Eduard_Munteanu> Ah, yeah. Open-coded Reader :)
09:29:25 <aristid> :t iterateN
09:29:25 <lambdabot> forall a t. (Num a, Ord a) => a -> (t -> t) -> t -> t
09:29:26 <Eduard_Munteanu> s/O/o/
09:29:59 <Eduard_Munteanu> (why did I do that substitution :/)
09:30:15 <Eduard_Munteanu> @instances (->)
09:30:15 <aristid> > foldr (+) $ replicate 4 5
09:30:16 <lambdabot> Couldn't find class `(->)'. Try @instances-importing
09:30:16 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
09:30:16 <lambdabot>    arising from a us...
09:30:25 <Eduard_Munteanu> @instances Monad
09:30:25 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
09:30:33 <aristid>  foldr (+) 0 $ replicate 4 5
09:30:40 <aristid> > foldr (+) 0 $ replicate 4 5
09:30:40 <lambdabot>   20
09:31:08 <Eduard_Munteanu> fmap succ (+) $ 3
09:31:11 <Eduard_Munteanu> > fmap succ (+) $ 3
09:31:12 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
09:31:12 <lambdabot>    arising from a use of `...
09:32:07 <Eduard_Munteanu> > fmap succ (+) $ 3 5
09:32:08 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
09:32:08 <lambdabot>    arising from a use of `...
09:32:17 <aristid> Eduard_Munteanu: tsk.
09:32:17 <Eduard_Munteanu> Bah, that was stupid...
09:32:26 <Eduard_Munteanu> > (fmap succ (+)) 3 5
09:32:27 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
09:32:27 <lambdabot>    arising from a use of `e_135' a...
09:32:36 <aristid> :D
09:33:51 <hape01> http://users.ugent.be/~bpuype/wget       seems to work very easily on windows and helps "hoogle data" to get further
09:34:05 <Eduard_Munteanu> > (fmap (succ .) (+)) 3 5
09:34:05 <hape01> but now tar is the next problem
09:34:06 <lambdabot>   9
09:35:35 <Eduard_Munteanu> hape01: you should get a complete MSYS environment
09:35:35 <aristid> > (succ .: (+)) 3 5
09:35:37 <lambdabot>   9
09:35:51 <Eduard_Munteanu> Heh.
09:40:05 <norm2782> is anyone here using haskellmode-vim with MacVim? I can't seem to get those tooltips to work that tell you a function's type when you hover over it with the mouse...
09:40:07 <tawe> @src read
09:40:07 <lambdabot> read s = either error id (readEither s)
09:40:28 <monochrom> @src readEither
09:40:28 <lambdabot> Source not found. Are you on drugs?
09:40:35 <benmachine> that is deeply unhelpful
09:40:48 <monochrom> lambdabot is weirder and weirder. there is no readEither in the standard libs.
09:41:25 <Saizan> not even in the source?
09:41:46 <monochrom> in the standard libs, read uses reads.
09:42:07 <monochrom> by standard libs I mean haskell 2010 reference implementation
09:42:38 <tawe> :t read
09:42:39 <lambdabot> forall a. (Read a) => String -> a
09:44:02 <monochrom> someone seriously fudged @src to be a joke.
09:44:17 <quicksilver> my opinion is already on record, @src should be removed
09:44:25 <quicksilver> it is a work of fiction and causes more harm than goo
09:44:26 <quicksilver> good
09:44:45 <quicksilver> it contains partial truths as well as untruths, and doesn't help you find the real truth.
09:44:46 <monochrom>  @src is only the tip of the iceberg
09:44:57 <monochrom> :type (++)
09:44:57 <quicksilver> an LB plugin which linked to the actual source/doc links on the website would be nice.
09:45:02 <monochrom> @type (++)
09:45:02 <lambdabot> forall m. (Monoid m) => m -> m -> m
09:45:11 <quicksilver> that's a completely different problem :)
09:45:17 <quicksilver> I don't really mind that much.
09:45:17 <Eduard_Munteanu> :t is just wishful thinking :)
09:45:18 <lambdabot> parse error on input `)'
09:45:23 <benmachine> haha
09:45:27 <Eduard_Munteanu> Oops.
09:45:45 <monochrom> that is another falsehood, at least for those who have only installed a standard haskell implementation and no new-fangled libs.
09:45:59 <quicksilver> true.
09:46:06 <quicksilver> but nonetheless it bothers me less.
09:46:12 <quicksilver> just goes to show how different people are different :)
09:47:18 <monochrom> in other words, in the midst of explaining the difference between x:xs and x++xs to a beginner, you lecture on or even chastise on about types, how ++'s type is [a]->[a]->[a], etc etc, and to prove your point, you:
09:47:22 <monochrom> @type (++)
09:47:23 <lambdabot> forall m. (Monoid m) => m -> m -> m
09:47:34 <jmcarthur> AGH@!
09:47:35 <monochrom> that completely confounds your effort.
09:47:40 <jmcarthur> :)
09:48:11 <monochrom> it is frustrating and anti-climatic
09:48:47 <benmachine> @type Prelude.(++)
09:48:48 <lambdabot> Not in scope: data constructor `Prelude'
09:48:54 <benmachine> @type (Prelude.++)
09:48:55 <lambdabot> forall a. [a] -> [a] -> [a]
09:49:23 <jmcarthur> i hate doing :t (Prelude..) only for the person i'm talking to to ask what the heck (Prelude..) means
09:49:44 <benmachine> :P
09:49:49 <monochrom> make up your mind: is lambdabot here to aid explaining basic haskell to beginners? or is lambdabot here to satisfy a few privileged person's private agenda? you can choose only one, they have very different consequences.
09:50:02 <jmcarthur> i prefer the former
09:50:02 <djahandarie> Cale agreed to adding a different > and :t which would pull off of a more vanilla implementation, in addition to keeping the existing ones.
09:50:19 <djahandarie> It's just that no one has done it.
09:50:45 <Eduard_Munteanu> There seems to be a private agenda meant to instill abstract algebra values in people.
09:51:08 <benmachine> I think calling it an agenda is a bit weird
09:51:16 <benmachine> it's not like a conspiracy or anything
09:51:19 <Eduard_Munteanu> While at it, maybe Caleskell can have Ring? :P
09:51:24 <popsi> @type read
09:51:24 <lambdabot> forall a. (Read a) => String -> a
09:51:27 <popsi> hm
09:51:44 <djahandarie> Yeah, let's import all the numeric-prelude modules in lambdabot, that'll be fun.
09:51:50 <djahandarie> -_-
09:52:24 <benmachine> it can't be worse than vector-spaces or whatever it is
09:52:36 <benmachine> > 5 1 3 2 4 (7,7)
09:52:37 <lambdabot>   5
09:52:42 <djahandarie> > 5 undefined
09:52:43 <lambdabot>   5
09:53:05 <benmachine> > fst 5 snd
09:53:06 <lambdabot>   5
09:53:26 <djahandarie> > 5 (error "unsafeLaunchMissiles has been executed")
09:53:27 <lambdabot>   5
09:53:41 <djahandarie> > fst 10
09:53:41 <lambdabot>   10
09:53:48 <timestart> @type fst
09:53:49 <lambdabot> forall a b. (a, b) -> a
09:54:24 <djahandarie> > 10 :: (Int, Int) -- this is why it works
09:54:25 <lambdabot>   (10,10)
09:54:29 <aristid> @src fst
09:54:29 <lambdabot> fst (x,_) =  x
09:54:35 <timestart> yeah just realised that :)
09:54:45 <djahandarie> timestart, but this is all due to some weird package being imported
09:54:49 <djahandarie> So you can ignore it. :p
09:54:49 <byorgey> oh, we have tuple instances for Num now? fancy =)
09:55:00 <byorgey> > (1,2) + (6,2)
09:55:01 <lambdabot>   (7,4)
09:55:03 <byorgey> =D
09:55:06 <ndrsndrs> are all these mod cons listen anywhere
09:55:11 <ndrsndrs> listed
09:55:30 <byorgey> mod cons?
09:55:41 <timestart> > (1::Int, 2 :: Float) + (2::Int, 3::Float)
09:55:41 <lambdabot>   (3,5.0)
09:55:47 <kanak> Hi, is there a function that behaves like zip but performs padding on the shorter list (instead of discarding elements of the longer list)?
09:56:21 <Eduard_Munteanu> kanak: what is the padding going to be?
09:56:31 <ndrsndrs> i mean, lambdabot's extra definitions and instances and things
09:57:00 <ndrsndrs> presumably it's just some module that's being imported, but which?
09:57:10 <kanak> Eduard_Munteanu: I was hoping I could specify an element to replicate. I'm trying to perform addition of two lists, and when one of them is shorter, i just want it to continue with all zeros
09:57:38 <byorgey> kanak: I've seen things like that defined before but there's no standard one as far as I know
09:57:39 <timestart> :info Num
09:57:54 <kanak> byorgey: thanks. I'll just define my own.
09:58:21 <djahandarie> Yeah I've seen that defined before also
09:58:34 <djahandarie> It was a fairly nice definition too but I can't remember it. :p
09:59:43 <byorgey> ndrsndrs: I think it's in a module called L.hs, the lambdabot source code is at http://code.haskell.org/lambdabot but code.haskell.org seems to be down/responding slowly at the moment.
10:01:26 <ndrsndrs> ah, found it
10:01:33 <ndrsndrs> thanks
10:01:43 <benmachine> I had a function that was
10:01:43 <benmachine> zipEx :: [a] -> [b] -> ([(a,b)], Either [a] [b])
10:01:53 <ndrsndrs> (it's State/L.hs in http://hackage.haskell.org/package/lambdabot, if anyone else is wondering)
10:10:58 <xplat> > let toss = (>>= flip (zipWith const)) . drop in toss 3 [1..10] 
10:10:59 <lambdabot>   [1,2,3,4,5,6,7]
10:12:03 <djahandarie> > [1..10] >>= flip (zipWith const)
10:12:04 <lambdabot>   Couldn't match expected type `[t -> b]'
10:12:04 <lambdabot>         against inferred type `[a] ...
10:14:40 <djahandarie> > drop 3 >>= flip (zipWith const) $ [1..10]
10:14:42 <lambdabot>   [1,2,3,4,5,6,7]
10:15:03 <benmachine> > zipWith const <*> drop 3 $ [1 .. 10]
10:15:04 <lambdabot>   [1,2,3,4,5,6,7]
10:26:27 <mm_freak> ok, i have a database of servers, which can change over time…  and i have a model for it, so i can control changes…  now a lot of threads request the 'next' proxy server from this database…  it's a real database like postgresql, not an abstract notion
10:27:03 <mm_freak> first thing, which comes into mind:  well, just fetch the next entry, but that will involve a round-trip between my program and the database for every such request, of which there will be many
10:27:13 <osoleve> my copy of RWH was printed 6 days ago and it's in my hands now :3
10:27:50 <mm_freak> second idea:  keep a Map of all proxy servers in memory and update that Map every time a proxy server is added
10:28:02 <mm_freak> (or removed or changed)
10:28:40 <mm_freak> i have an Enumerator for the table, but it captures only the state at query time…  perhaps someone has an elegant solution or some experience?
10:29:46 <mm_freak> with the library i'm using (persistent) unfortunately i don't have pointers/cursors/whatever you call them
10:32:05 <xplat> @ty flip . execState .: mapM_ . (state.) . flip . ((const()&&&) .) -- hey, it's foldl
10:32:06 <lambdabot> forall a a1. (a -> a1 -> a) -> a -> [a1] -> a
10:34:00 <djahandarie> @ty flip.execState.:mapM_.state.:flip.:(const()&&&)
10:34:01 <lambdabot> forall a a1. (a1 -> a -> a) -> a -> [a1] -> a
10:39:10 * hackagebot RepLib 0.4.0 - Generic programming library with representation types  http://hackage.haskell.org/package/RepLib-0.4.0 (BrentYorgey)
10:40:10 * hackagebot unbound 0.2 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.2 (BrentYorgey)
10:40:30 <ezyang> oooh. 
10:40:37 * ezyang installs. 
10:41:29 <ezyang> aww, GHC 7 only. Guess I'll have to wait a smidge. 
10:41:29 <byorgey> ezyang: the documentation sucks, there will be a new version with nice documentation soon.
10:41:50 <byorgey> ezyang: but in the meantime you can also read our draft paper: http://www.cis.upenn.edu/~byorgey/papers/binders-unbound.pdf
10:42:49 <jmcarthur> ooh sounds nice
10:44:51 <byorgey> jmcarthur: it is =)
10:45:08 <byorgey> once I whip the documentation into shape I'll write a proper blog post about it.
10:45:09 * sm enters the ghc7 world!
10:45:25 <ezyang> ICFP deadline yum yum. 
10:45:43 <byorgey> yeah, it's always fun seeing all the cool stuff everyone has been working on in secret =)
11:14:18 * t3eblinder is confused about the new arrow library with categories :-(
11:14:35 <newgame> I have a problem with my code (https://gist.github.com/885062). See the file 'Simulation.hs'. If you execute 'testRun' you'll see that the state is not updated. Can anyone spot the bug (I suspect line 172 or 193)?
11:15:16 <mm_freak> ok, i thought of the following solution:  i create a TVar of a list of servers…  when the next is requested, it is unconsed from the list…  if the list becomes empty afterwards, the next 10 servers are loaded from the database
11:15:20 <ezyang> newgame: your puts don't do what you think they do. 
11:15:42 <mm_freak> unfortunately i cannot do this as a transaction without touching the database each time
11:15:46 <ezyang> Remember that 'st' is a pure variable, so after you do the first put, it is NOT updated. 
11:15:47 <mm_freak> is there a solution to this?
11:16:54 <ezyang> The easy fix is to coalesce those updates into one. The more sophisticated fix is to use 'modify', but you'll need to reify the record updates into functions (use a lambda) 
11:17:40 <mm_freak> summarized, i need:  from a 'TVar [Server]' test, whether the list is empty…  if yes, load database entries and refill the list, if no uncons and return the first element
11:17:45 <mm_freak> is that possible?
11:17:51 <mm_freak> as a transaction!
11:18:37 <ezyang> Is loading database entries IO? 
11:18:41 <mm_freak> yes
11:18:51 <ezyang> Hmm. Maybe you want to use unsafeIOToSTM 
11:19:10 <newgame> ezyang: ok. But I do use some functions that use modify (like incRoundCounter). Shouldn't at least they change the state?
11:19:20 <mm_freak> unsafeIOToSTM is only unsafe, if i call atomically inside the IO action, right?
11:19:27 <ezyang> newgame: Yeah, that should be fine. 
11:19:38 <ezyang> Well, that and it can result in side-effects that don't get rolled back. 
11:20:11 <mm_freak> side-effects are read-only, so it should be fine
11:20:12 <mm_freak> thanks
11:21:48 <mm_freak> hmm, no, that function seems to be a lot more unsafe than it first sounded
11:22:04 <mm_freak> "The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of unsafeIOToSTM, so make sure you don't acquire any resources that need releasing …"
11:22:42 <ezyang> Yes. 
11:22:52 <ezyang> Just arrange the resources before you enter STM. 
11:23:29 <ezyang> although, I guess if you're trying to avoid creating a connection to the server that might be problematic 
11:23:49 <ezyang> Maybe you could implement a mini garbage collector for those resources. 
11:24:38 <Panaetius> can someone explain the first answer at http://stackoverflow.com/questions/995781/haskell-polymorphism-and-lists to me please? shouldn't Shape be something like 'Shape :: IsShape a => a -> Shape a'? or how would one patternmatch against the entries in in the list or call draw on the entries?
11:25:28 <ezyang> Panaetius: The lack of the 'a' is the 'existential' bit. 
11:25:58 <ezyang> You can still pattern match against it normally. Try it. 
11:26:16 <Panaetius> so you can just do "draw $ head list" ?
11:26:23 <mm_freak> ezyang: the database connection is already established
11:26:49 <Panaetius> i.e. draw $ head shapes, in this case
11:26:59 <newgame> ezyang: I updated the gist. If you look at lines 166 - 169 I managed to get one state update (namely getting the roundCounter from 1 to 2). What would be the right way to do it (since I did not fully understand your suggestion)?
11:27:20 <ezyang> I don't know what the type of list is, but you've probably not got it quite right. 
11:27:30 <ezyang> No. You need to unwrap the value from Shape. 
11:27:34 <mm_freak> ezyang: i just fear that 'persistent' allocates resources under the hood, which could leak resources
11:27:35 <ezyang> newgame: Ok, will look. 
11:28:07 <ezyang> Well, if you're doing evil things, expect to get your hands dirty. Go check the source :-) 
11:28:36 <ezyang> top is the latest in gists, right? 
11:29:21 <ezyang> actually, I don't see the changes... 
11:29:48 <mm_freak> well, i could also just use a cache manager using my old-style MVar approach
11:29:55 <mm_freak> but the STM approach would be so much nicer
11:30:13 <newgame> ezyang: I changed
11:30:14 <ezyang> mm_freak: Can you somehow decompose this transaction? 
11:30:25 <newgame> st <- get
11:30:34 <newgame> incRoundCounter
11:30:34 <newgame>     liftIO $ print $ roundCounter st
11:30:52 <Panaetius> ezyang: ah i think I somewhat get it, the Shape constructor is like "renaming" the type or like some sort of casting? (i seem to lack the words to describe what I mean, what's the proper term for this kind of operation?)
11:30:56 <ezyang> go look at runSimulation' 
11:31:05 <ezyang> Panaetius: It is losing type information, yes. 
11:31:16 <ezyang> not sure what the vocab is :-) 
11:31:16 <newgame>     st <- get
11:31:17 <newgame>     incRoundCounter
11:31:17 <newgame>     st' <- get
11:31:17 <newgame>     liftIO $ print $ roundCounter st'
11:31:23 <ezyang> pastebin? 
11:31:30 <Panaetius> ezyang: allright, thanks :)
11:32:34 <newgame> ezyang: ah, you mean I shouldn't use those puts in runSimulation'?
11:32:53 <mm_freak> ezyang: i found a solution
11:32:58 <mm_freak> STM (IO ()) =)
11:33:21 <ezyang> ah, not bad. 
11:33:33 <ezyang> newgame: It almost certainly doesn't do what you think it does. 
11:33:38 <ezyang> the st is stale on the second put. 
11:34:16 <newgame> ezyang: alright, will change that to functions that use modify and see if that helps. thanks.
11:34:38 <ezyang> well, go and see if there's anywhere else in your source where you do that too. 
11:36:13 <monochrom> join (atomically ((x >> return (putStrLn "x")) `orElse` (y >> return (writeFile "f" "y"))))
11:38:28 <mm_freak> hmm, no
11:38:37 <mm_freak> the STM (IO ()) solution has a flaw
11:38:55 <Panaetius> iis the "wow, this is way cooler than OO" sentiment common when discovering GADT's?
11:38:56 <sipa> @pl f x >>= \y -> return (g y)
11:38:56 <lambdabot> g `fmap` f x
11:39:04 <mm_freak> the IO action needs to modify the TVar in question as part of the transaction =/
11:39:26 <mm_freak> looks like i don't get around doing a database query each time
11:39:47 <ezyang> mm_freak: Try this: 
11:39:50 <kmc> Panaetius, why compare it to OO?
11:40:05 <ezyang> actually, nvm. 
11:40:14 <kmc> Panaetius, btw nothing coherent is meant by "OO", it's a marketing term applied to a dozen unrelated language features
11:40:36 <asflierl> much like functional programming ;)
11:40:38 <mm_freak> ezyang: i can't get around this sequence:  load tvar >> load database >> write tvar
11:40:48 <kmc> asflierl, yeah, i'd say that's fair
11:41:07 <mm_freak> ezyang: since IO inside STM is unsafe (a hell of a lot), i will have to ask the database each time
11:41:43 <kmc> asflierl, most languages can make some claim to being "functional" and whether or not they do so depends on whether FP is in vogue at the moment
11:42:10 * asflierl nods.
11:42:12 <newgame> ezyang: Woow, it worked. You are a genius ;). But how can it be that one single put kind of like shadowed all other modifications? Is it because put used the "old st" that did not receive the modifications? If that is so, why would I need put at all if I have modify?
11:42:14 <kmc> a lot of people use "functional language" to mean "language very much like Haskell", even though Haskell has many unusual features
11:42:45 <mm_freak> haskell is a compositional language
11:43:04 <mm_freak> composition is the key word, when using haskell
11:43:25 <c_wraith> I've decided composition is the key word for explaining what monads are when someone really demands it, too.
11:43:25 <ezyang> newgame: I suggest 'modify' because that means there's no stale value floating around for you to accidentally use. 
11:43:32 <djahandarie> I can compose in C too!
11:43:39 <Panaetius> kmc: i'm coming from an OO background (working as .NET developer) and am currently programming a game in Haskell for fun, so I was wondering how to represent a list of buildings, with different types of buildings, and started thinking to myself "damn, this would be so much easier with subtype polymorphism", then I discovered GADT's and well, I'm somewhat awed :) given that the compiler can check this stuff and there's no need for reflect
11:43:39 <Panaetius> ion or anything
11:43:47 <mm_freak> djahandarie: write the equivalent of (.) in C
11:43:53 <asflierl> I prefer composing on the piano ;)
11:43:54 <ezyang> newgame: You're basically reading the syntax of the state monad incorrectly. 
11:43:59 <kmc> Panaetius, you don't always need different types either
11:44:12 <kmc> a lot of people from OO background assume that new behavior implies new type
11:44:32 <kmc> GADTs are really cool though
11:44:37 <dagle> Many ASM's have macros. I can compose in ASM.
11:44:38 <kmc> don't get me wrong ;)
11:44:40 <ezyang> newgame: An exercise I suggest is taking do { st <- get; set (st {a = 0}); set (st {b = 1}); } gets desugared. 
11:44:57 <ezyang> get rid of the do-notation, and then write it out manually passing state around. 
11:45:18 <mm_freak> Panaetius: non-G ADTs should be enough
11:46:14 <mm_freak> data Building = House | Pyramid
11:46:52 <newgame> ezyang: alright, thanks for the exercise. However, do you mean set = put? Because I can not finde a set function
11:47:06 <ezyang> erm, yes, that's what I mean. 
11:47:10 <mm_freak> Panaetius: but for game development (if you have time) check out a completely different paradigm:  functional reactive programming
11:48:24 <Panaetius> kmc: I was wondering, if I went the data Building = BuildingType1 | BuildingType2 | .... route, i'd have a function with several pattern matches do determine what to do with each building. now to keep it readable I'd call different helper functions in those matches (otherwise it would get huge). Am I correct that without GADT's I couldn't have the compiler ensure that those helper functions  are only called with the correct parameters ?
11:48:54 <newgame> ok, will do that. but I need a break first, you were very helpful. bye
11:49:16 <kmc> data House = House Int Bool; data Pyramid = Pyramid Char; data Building = BHouse House | BPyramid Pyramid
11:49:30 <kmc> now your helpers can take House and Pyramid and it's totally safe
11:49:41 <Panaetius> mm_freak: i remember stumbling upon that, but couldn't find good information on it. I'm using SDL, and event loops seem to be the way to go with sdl
11:49:50 <Panaetius> oh nice, I hadn't even thought of that
11:50:19 <kmc> also i bet you can structure your code to not require those helpers
11:50:47 <mm_freak> Panaetius: that's independent
11:50:51 <kmc> i mean why is it worse to have five big pattern-matching equations for one function than to have five helper functions
11:51:23 <Panaetius> so in this case the only real advantage of GADT's is that someone using my module could create a new type of building?
11:51:37 <kmc> maybe they could
11:51:52 <mm_freak> Panaetius: one thing is the system description, the other thing is the system execution…  you separate the event loop from the game behaviour
11:51:53 <kmc> you're right that GHC Haskell's fancier type features are more valuable when you want to make extensible types
11:52:08 <mm_freak> you still write this loop yourself, so you can easily use SDL
11:52:31 <Saladpie> Is anyone familiar with ADDC? And how to extract for example an Int from type ADDC Int OtherType ?
11:52:32 <Panaetius> do you have any ressources with a more in depth description?
11:52:32 <kmc> in general, approaching a problem from an OO mindset and then translating that into Haskell will cause one to use more powerful type system features than are necessary
11:52:46 <kmc> and introduce more complexity than is necessary
11:53:00 <kmc> not sure whether this applies to your situation
11:53:24 <kmc> you can read about 'existential types' to see some examples of extensible types
11:53:33 <mm_freak> Panaetius: look at the yampa resources
11:53:34 <kmc> Control.Exception works this way
11:53:41 <mm_freak> they have a good introduction
11:53:59 <mm_freak> although for games you might want to use elerea instead, because i think it's faster
11:54:29 <Panaetius> probably :) I'm trying to get more into the functional programming mindset and this is the project I chose to get more practice. so half the time i'm writing code and the other half I'm going back, 'fixing' it because I discovered some new cool feature :)
11:54:40 <Panaetius> mm_freak: thanks, I'll check it out
11:55:03 <mm_freak> and to extend kmc's point, OOP is about splitting by objects, while the usual approach in haskell is to split by properties
11:55:16 <mm_freak> in OOP you have multiple properties in one object file
11:55:23 <mm_freak> in haskell you have multiple objects in one property file
11:55:43 <mm_freak> (in a semi-direct translation, which is still somewhat idiomatic to haskell)
11:56:07 <Saladpie> Is anyone familiar with ADDC? And how to extract for example an Int from type ADDC Int OtherType ?
11:56:27 <monochrom> everyone should read about the expression problem. then they will appreciate what I say against premature generality.
11:56:37 <Panaetius> http://lambdor.net/?p=44 looks like a nice introduction
11:56:55 <Saizan> monochrom: i.e. the problem is trying to solve the expression problem?:)
11:57:31 <monochrom> the expression problem implies that there could be two conflicting directions to generalize or extend, if you are so obsessed about "unforeseen need to extend"
11:57:36 <Layla_93> Hello, I am new to haskell (and irc) :) I have a couple of questions
11:59:41 <mm_freak> Layla_93: feel free to ask =)
11:59:49 <monochrom> therefore, especially most OO teachers' dogma of "build in ways to extend" is harmful when you don't even know which direction it is going to be in the future, i.e., premature generality
12:00:05 <applicative> Layla_93: hi
12:00:24 <Panaetius> oh I don't care about extending in this case. it's my project and there's no reason anyone would/should ever use that stuff outside of it. it was more of a "huh, i could actually do this with a type class, haven't had a reason to use those before, why not give it a try" 
12:00:30 <monochrom> you build it to be extensible in one way, oops, two years later it turns out no one needs that way and the other way is needed
12:00:56 <mm_freak> monochrom: i think OOP is a good paradigm for extensibility in unforeseen directions, but it can quickly lead to messy code, really messy code
12:01:08 <mm_freak> the zend framework for PHP is my personal nightmare
12:01:17 <mm_freak> it's the one example of that
12:01:21 <monochrom> do you know of the expression problem?
12:01:22 <ezyang> imperative code is pretty good at being flexible in the face of changes. 
12:01:42 <mm_freak> i just read about it, but i'm not sure, whether i understand it
12:01:43 <Layla_93> mm_freak, applicative: thanks :D em first I need to know of good book for it (can not get many books at once , no money :( ) so I want one that has most of what I may need :)
12:02:15 <applicative> @where LYAH
12:02:15 <lambdabot> http://www.learnyouahaskell.com/
12:02:21 <applicative> @where RWH
12:02:22 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:02:22 <mm_freak> Layla_93: if you want to spend as little money as possible, spend none and read online
12:02:46 <mm_freak> when haskell pays off, you can still buy a book or release some libraries…  a good way to contribute =)
12:02:47 <applicative> these two are excellent of course ^^^ .  
12:02:50 <Layla_93> mm_freak: I have no internet at home :(
12:02:50 <Layla_93> mm_freak: only at school..
12:03:02 <mm_freak> i see, then see applicative's suggestions
12:03:15 <monochrom> the expression problem states that these two are at odds: extend by adding more types or classes or objects ; extend by adding more functions or methods.
12:03:33 <Panaetius> Layla_93: you could mirror the homepages locally
12:03:58 <Panaetius> that's what I did for lyah when I went on holidays
12:04:02 <mm_freak> (or just download the books)
12:04:20 <Layla_93> mm_freak: download books is good option :D
12:04:34 <Panaetius> is the official lyah ebook out
12:04:36 <Panaetius> ?
12:04:44 <lpsmith> http://fldit-www.cs.uni-dortmund.de/~peter/PS07/HR.pdf
12:04:45 <Layla_93> mm_freak: Is real world haskell good one? I can buy ebook now :)
12:04:52 <monochrom> it is easy to contrive a language or a whole paradigm to make one of the two easy but not both.
12:04:54 <lpsmith> Layla_93, ^^^
12:05:02 <mm_freak> monochrom: i see
12:05:07 <Layla_93> lsthemes: yay a book :D
12:05:19 <Layla_93> lpsmith: :D
12:05:25 <mm_freak> Layla_93: i don't know, i haven't read it…  my road into haskell (logic) was quite a dry, but helpful one =)
12:06:08 <mm_freak> ezyang: found a solution now…  have two threads…  one for loading the empty TVar, one for fetching the next element
12:06:17 <Layla_93> mm_freak: I have a lot of time to deepen into it (still at school :) ) plus I learned some php and perl but I feel haskell is cool :)
12:06:21 <mm_freak> i hope, this will not result in a livelock
12:06:44 <mm_freak> Layla_93: your perl and PHP knowledge won't help a lot, and in fact will rather stand in your way ;)
12:07:11 <Layla_93> mm_freak: ooh :(
12:07:13 <mm_freak> ok, let me ask this as a question:  i want to implement a database cache for, let's say, 10 entries
12:07:14 <monochrom> "you should choose OO because it is easy to extend (only in the sense of adding subclasses but I won't tell you this)" is the wrong bet if it turns out that you will only add a few subclasses but you will add tens of new methods across the whole class hierachy starting from the base class.
12:07:24 <mm_freak> one thread fills the cache, when it gets empty
12:07:27 <Panaetius> http://learnyouahaskell.com/learnyouahaskell.pdf is the only ebook version of lyah I know of and that one's incomplete
12:07:37 <mm_freak> the other thread unconses an element from the cache and returns it
12:07:50 <mm_freak> is this sane or will it yield a livelock likely?
12:07:51 <lpsmith> Layla_93, you also should check out your school's library,  and be sure to ask about interlibrary loan
12:08:10 <applicative> Layla_93 I think you should start with LYAH, just find some way to print it ...
12:08:16 <mm_freak> (talking about STM and a TVar [CacheEntry])
12:08:19 <applicative> Panaetius: what, no pictures!!
12:08:24 <Layla_93> lpsmith: I asked them to buy books on haskell they said this is not a programming language! :(
12:08:26 <Panaetius> and that
12:08:28 <lpsmith> If your library has loan agreements with other institutions,  you can choose from a much wider selection of books.
12:08:35 <monochrom> whereas for example in haskell, sml, even modula, it's pretty easy to add more functions
12:08:53 <kmc> this is one reason why those are good languages for writing compilers
12:09:18 <mm_freak> Layla_93: i love to link this article…  it doesn't solve your problem, but it's an interesting read: http://www.paulgraham.com/avg.html
12:09:30 <kmc> it's more common to want to add a new sort of program analysis than to want to add a new bit of syntax to your language
12:09:31 <Panaetius> applicative: that's why I mirrored the homepage locally, would have missed the pictures too much. and it's missing the monads section iirc. but a new version is in the works last I heard
12:09:38 <mm_freak> so if they don't acknowledge haskell as a programming language, it's good for you =)
12:10:02 <kmc> only if you see the world as a zero-sum competition
12:10:08 <lpsmith> kmc++
12:10:15 <Layla_93> mm_freak: printing out right now :D
12:10:36 <mm_freak> but read it for fun, not for education/opinion building ;)
12:10:56 <lpsmith> schools not acknowleging Haskell as a programming language certainly adds significant challenges to your own education
12:11:05 <Layla_93> mm_freak: can I use haskell in web programming? like php?
12:11:07 <kmc> most schools that try to teach Haskell do it poorly
12:11:24 <kmc> Layla_93, Haskell is a general-purpose language.  you can use it for most things people use programming languages for
12:11:42 <lpsmith> Layla_93, you might be interested in Snap, Yesod, or Happstack
12:11:42 <mm_freak> Layla_93: i use haskell for rapid web development as well as server programming
12:11:45 <mm_freak> mainly the latter
12:11:48 <Lemon> Hackage's documentations look really nice now, but hackage.haskell.org still looks like it was made in 1995.
12:11:53 <mm_freak> and i use yesod
12:11:56 <Lemon> What gives?
12:12:06 <monochrom> my humble observation is that customers ask for more features (mostly translates to more functions) rather than more classification of customers.
12:12:12 <kmc> i don't think it looks that bad Lemon
12:12:19 <Panaetius> Layla_93: there's several web frameworks in Haskell. like yesod or snap
12:12:22 <Lemon> kmc, I didn't say bad.
12:12:26 <Layla_93> then I will rewrite our school website in haskell after I learn it, just to show our teachers that they should recognise its power :D
12:12:27 <kmc> i don't think it looks that old
12:12:35 <Lemon> Inconsistent is rather my gripe.
12:12:38 <kmc> ok
12:12:41 <kmc> it is inconsistent
12:12:50 <kmc> but "made in 1995" does not convey that complaint
12:12:54 <kmc> when it's not even accurate
12:13:12 <Lemon> what's your point?
12:13:17 <Lemon> I made mine.
12:13:34 <Layla_93> is HR a good start for reading? 
12:13:40 <kmc> if hackage looked like a website from 1995 then it would have a starfield background and a "under construction" animated gif of a guy with a shovel
12:13:55 <monochrom> hahaha
12:14:00 <kmc> Layla_93, HR?
12:14:14 <enthymeme> The Haskell Report?
12:14:27 <enthymeme> maybe H98R would be a better designator?
12:14:37 <Layla_93> kmc: some one provided a link to me few moments ago "haskell road" :)
12:14:49 <mm_freak> Layla_93: the haskell road to logic
12:14:54 <Layla_93> kmc: PDF book
12:14:58 <Layla_93> mm_freak: yes this one :)
12:14:58 <mm_freak> Layla_93: it's very very very dry
12:15:00 <Panaetius> mm_freak: what would you say about web development with yesod compared to imperative stuff ?
12:15:20 <djahandarie> Yesod is nicer but errors can be scary
12:15:21 <mm_freak> Panaetius: i'm more productive with yesod than with PHP+ZF
12:15:30 <mm_freak> much more productive
12:15:50 <Layla_93> mm_freak: oh, then I will start with Learn you a haskell? link was given for pdf too..
12:15:54 <mm_freak> but yes, error messages can be very scary, because of all the TH/QQ stuff
12:15:55 <kmc> is Yesod non-imperative?
12:16:12 <djahandarie> People need to research more into generating good error messages
12:16:24 <lpsmith> djahandarie, I agree
12:16:25 <mm_freak> Layla_93: i don't know…  frankly the haskell road to logic was the only real book (or rather paper) i read
12:16:33 <mm_freak> kmc: semi-imperative
12:16:39 <djahandarie> It would be nice if some of the Hugs stuff could be ported back into GHC
12:16:44 <Panaetius> Layla_93: yes but that PDF is not complete, it contains about 70% of the chapters that are on the learn you a haskell homepage (the last 3 chapters or so are missing in the pdf)
12:16:53 <mm_freak> kmc: it uses composition of handlers and widgets as its main idiom
12:17:11 <Panaetius> Layla_93: but it should be enough for a week or so and you can just print out the rest once you get there
12:17:45 <Layla_93> If there was a good book that has everything I would buy it, I have around 35 dollars in creadit card :)
12:18:07 <Panaetius> mm_freak: hum, what would you say is the main reason for being more productive?
12:18:46 <mm_freak> Panaetius: less code, virtually no run-time errors
12:18:46 <applicative> Layla_93: It's enough to begin, I don't think LYAH is supposed to be complete yet anyway.  Maybe now it is.  
12:18:56 <Panaetius> Layla_93: http://www.amazon.com/Learn-You-Haskell-Great-Good/dp/1593272839 if you want to buy it :)
12:19:07 <mm_freak> Panaetius: and composability…  as said, yesod uses composition a lot, so you have a lot of code reuse (compared to non-haskell)
12:19:10 <applicative> Layla_93: Have you installed the GHC?  
12:19:38 <Layla_93> applicative: yup I have it :) It is easy to setup on fedora :D
12:19:53 <applicative> Layla_93: oh, excellent.
12:20:15 <mm_freak> Panaetius: also the database layer is wonderful
12:20:44 <mm_freak> typesafe, automatic migration, typesafe, typesafe, no SQL, typesafe, …
12:20:49 <Panaetius> mm_freak: haven't played with haskell and database so far. what does yesod use for database interaction?
12:21:02 <mm_freak> the 'persistent' package
12:21:25 <Layla_93> Panaetius: the book sounds good but since I have 70% of it as PDF now (which I may read in 1 day) I prefer buying something more advanced to read next weekend :)
12:21:37 <Panaetius> hmm haven't heard of that one so far. only hsqldb
12:21:54 <mm_freak> it's new
12:21:58 <applicative> Layla_93: slow down! 
12:22:18 <Layla_93> applicative: hehehe :D
12:22:19 <Panaetius> Layla_93: you can READ it on 1 day but that won't do you any good :)
12:22:28 <n0den1te> Layla_93: 1 day? good, good... :D
12:22:31 <mm_freak> Layla_93: haskell is a steep learning curve, to be honest…  it's not like PHP, which one can pick up in a matter of a few hours
12:22:52 <kmc> you have to learn a new way of thinking
12:22:56 <kmc> not just new syntax for old concepts
12:22:59 * hackagebot multiplate-simplified 0.0.0.1 - Shorter, more generic functions for Multiplate.  http://hackage.haskell.org/package/multiplate-simplified-0.0.0.1 (BalazsEndresz)
12:23:28 <mm_freak> Layla_93: i'm using it for years now and still discover new things every day =)
12:23:43 <Layla_93> mmm.. i see.. I like challenge :D
12:23:49 * Panaetius remembers how many times he had to go over the monad chapters and still isn't sure if he could implement his own monads...
12:23:58 <TomMD> data-applicative-template, mmmm
12:24:29 <Layla_93> Panaetius: monad chapters from what book? the learn you a haskell book?
12:24:33 * mm_freak remembers how many times he has gone over dozens of tutorials on iteratees, FRP and much more
12:24:45 <Panaetius> Layla_93: yes, but those are the ones missing in the PDF
12:25:01 <applicative> "Shorter more generic functions for multiplate" ... wasn't aware functions could be classified into short and long
12:25:18 <mm_freak> i think iteratees and FRP are the two concepts, which took me longest to understand
12:25:29 <mm_freak> and the largest number of attempts
12:25:37 <Panaetius> Layla_93: http://www.haskell.org/haskellwiki/99_Haskell_exercises is a nice set of small problems to get some hands on experience once you've read some/all of lyah
12:25:48 <Layla_93> Panaetius: ermm... I will try to pull the chapters from internet via firefox plugins and read at home :)
12:27:02 <Layla_93> ok I will start reading learn you a haskell, I will be back when I finish, thank you all you are great people ^_^
12:27:07 <Panaetius> mm_freak: about yesod, how/where are you hosting your pages?
12:27:54 <Panaetius> Layla_93: your welcome
12:28:06 <mm_freak> Layla_93: you're welcome and have fun…  learning haskell is a great experience
12:28:34 <mm_freak> Panaetius: mainly nginx+fastirc on linux servers
12:29:47 <Panaetius> are there any cheap hosters that provide that? i figure you have your own servers/using it at work?
12:30:16 <kmc> if you get a VPS you can install whatever you want
12:30:28 <mm_freak> former: none that i know of; latter: yes
12:31:00 <mm_freak> uhm
12:31:06 <mm_freak> s/fastirc/fastcgi/ lol
12:31:24 <kmc> you can get a pretty cheap VPS these days
12:31:24 <mm_freak> you don't need nginx…  any fastcgi-enabled httpd will do
12:31:33 <mm_freak> but nginx is great for that
12:31:42 <Panaetius> hum... i could just create an admin login at out datacenter and hope my boss doesn't notice when I quit work next month :)
12:31:55 <mm_freak> hehe
12:31:58 <kmc> < $10/mo if you don't need loads of CPU / RAM
12:32:07 <kmc> you can also get an EC2 micro instance for free
12:32:11 <mm_freak> better set up SSH, too ;)
12:33:20 <Panaetius> by the way, anyone from switzerland here who want's to hire a complete haskell noob? will code for food!
12:34:24 <mm_freak> in the distant future i might need assistance =)
12:34:30 <mm_freak> but that is distant ;)
12:34:55 <Panaetius> you're from ch?
12:35:27 <c_wraith> what kind of food?  I might be able to offer packaged ramen 3 times a day. :)
12:35:35 <kmc> nom
12:36:13 <Panaetius> 4 times a day and I want a spoon!
12:36:21 <n0den1te> Panaetius: you've stepped over monads and still consider yourself a noob? :)
12:36:37 <n0den1te> *complete noob? :D
12:37:41 <kmc> i still don't get the idea of "learning monads" as a big rite of passage
12:37:53 <n0den1te> "In point-free style of programming programs are expressed as combinations of simpler functions." Is this correct? If so, then those functions defined are just partial functions... 
12:38:03 <Panaetius> n0den1te: my main use of monads follows the 1. write code 2. try something to get it to work 3. if tries < 100 go to 1. 4. ask in #haskell ;)
12:38:04 <kmc> "monad" isn't a single concept; it's an API applied to a bunch of different crap
12:38:22 <c_wraith> n0den1te: be care, "partial function" means something entirely different from "partially applied function"
12:38:33 <mm_freak> Panaetius: uh, no…  germany
12:38:56 <n0den1te> Panaetius: fairynuff. haffun! :)
12:39:09 <Panaetius> ha! I can live on with the delusion of being the only haskell programmer in switzerland. 
12:39:35 <mm_freak> n0den1te: composition, not combination
12:39:39 <Panaetius> lately i've been thinking about getting a volleyball and painting a face on it
12:39:48 <mm_freak> function composition is a special case of function combination
12:39:54 <n0den1te> c_wraith: if partial functions are those functions you can write without having to append arguments, then yes. Otherwise, I might have meant partially applied functions by mistake. 
12:40:04 <mm_freak> instead of f (g x) better write (f . g) x
12:40:21 <c_wraith> n0den1te: partial functions are functions that are not defined for all input.  like head is not defined for empty lists
12:40:29 <mercury^> mm_freak: what is the definition of function combination?
12:40:30 <c_wraith> n0den1te: I'm pretty sure you mean partially applied functions
12:40:42 <c_wraith> > head []
12:40:43 <lambdabot>   *Exception: Prelude.head: empty list
12:40:44 <mm_freak> mercury^: any kind of using functions together =)
12:40:48 <n0den1te> c_wraith: then it's partially applied functions. :)
12:40:54 <mm_freak> i.e. combination ;)
12:41:09 <kmc> Haskell has no partially applied functions
12:41:14 <kmc> because every function takes only one argument
12:41:20 <kmc> so how could you apply only some of the arguments?
12:41:21 <n0den1te> sumPartial = foldr (+) 0
12:41:28 <n0den1te> sum = sumPartial [1...500]
12:41:39 <mercury^> mm_freak: well, there is no combination more general than application in haskell.
12:41:44 <mm_freak> n0den1te: a -> b -> c = a -> (b -> c)
12:41:50 <mm_freak> because (->) is right-associative
12:41:50 <c_wraith> kmc: that's a very pedantic viewpoint that gets in the way of useful discussion sometimes. :)
12:41:54 <n0den1te> c_wraith, mm_freak: ^^
12:42:02 <kmc> in that expression, technically "foldr" is fully applied and so is "foldr (+)"
12:42:05 <xplat> argh, why does attoparsec's 'option' have the fromMaybe composed in instead of just returning a maybe like a sane thing would?
12:42:24 <kmc> convenience? Parsec provides both forms iirc
12:42:30 <n0den1te> mm_freak: I was reading this: http://ulissesaraujo.wordpress.com/2007/12/19/catamorphisms-in-haskell/
12:44:14 <kmc> c_wraith, isn't it easier to discuss a language with a single kind of function, rather than a language with a) a concept of "arity" and b) a separate concept of "partial application"?
12:44:31 <mm_freak> n0den1te: still try to understand what kmc is saying
12:44:42 <mm_freak> he is saying this:  a -> b -> c = a -> (b -> c)
12:44:58 <n0den1te> takes an argument and returns a function. 
12:45:10 <mm_freak> this implies that functions in haskell are /always/ unary
12:45:32 <mm_freak> (+) :: Int -> (Int -> Int)
12:46:17 <kmc> so you get "partial application" for free
12:46:21 <n0den1te> mm_freak: I understood that. Argument chaining in functions is something very different from other languages I have seen. I was asking something very specific from the quoted text in the blog. 
12:46:39 <c_wraith> kmc: Simpler, but not in a way that enhances discussion.  It's often more meaningful to talk about foldr as a function of 3 arguments.
12:47:03 <kmc> c_wraith, it's often more meaningful to talk about foldr as a function of 2 arguments, as described above
12:47:04 <n0den1te> If the quoted text were true, then point free style is just composing a bunch of partially applied functions. Am I way off the mark?
12:47:06 <kmc> but this is pointless
12:47:13 <mm_freak> n0den1te: your question doesn't make sense in this context
12:47:17 <kmc> n0den1te, why is it relevant that the functions are "partially applied"
12:47:48 <mm_freak> n0den1te: composition composes unary functions
12:48:06 <mm_freak> and since haskell has only those, composition composes functions
12:48:23 <mm_freak> this will work with any function, as long as the types fit
12:48:23 <c_wraith> :t (.:)
12:48:24 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
12:48:25 <n0den1te> Emphasis is not "partially applied" functions. I was asking about what point free style has to do with composing partially applied functions. 
12:48:46 <mm_freak> well, you have to non-applied functions f and g
12:48:51 <mm_freak> and you compose them, f . g
12:49:03 <c_wraith> :t (-) .: (+)
12:49:04 <lambdabot> forall a. (Num a) => a -> a -> a -> a
12:49:09 <mm_freak> instead of writing, for example:  \x -> f (g x)
12:49:50 <c_wraith> oh, that's binary -
12:49:56 <c_wraith> :t negate .: (+)
12:49:57 <lambdabot> forall a. (Num a) => a -> a -> a
12:50:06 <frerich_> Is there a ready-made function '(a -> Int -> b) -> [a] -> [b]' which works much like map except that the given function gets the index of the currently visited element passed? I was about to write it myself, but since it's much like map - maybe somebody did it already?
12:50:22 <mm_freak> frerich_: combine zip and map
12:50:24 <c_wraith> frerich: zipWith f [0..]
12:50:35 <mm_freak> or yes, zipWith
12:51:04 <frerich_> Ok thanks, I minimize this window now and try to solve this, don't spoil the fun by giving the solution :)
12:51:18 <c_wraith> map is essentially zipWith1
12:51:40 <mm_freak> yeah
12:51:48 <kmc> ocaml calls them map2, map3, etc
12:52:32 <kmc> i would not be upset if "zip" had to be written "map2 (,)"
12:52:36 <kmc> arguably the latter is a better name
12:53:40 <Twey> I would prefer ‘map’ to have been written ‘zipWith1’
12:54:02 <Twey> Oh, somebody noted that already
12:54:09 <Athas> Is there a way to define a type-alias with a constraint such as 'type T = C v => Ty v', such that I can write 'foo :: a -> T' and have it mean the same as 'foo :: C v => a -> Ty v'?
12:54:11 <sipa> @let zipWith1 = map
12:54:11 <Twey> Hm, can that be generalised to all Functors?
12:54:11 <lambdabot>  Defined.
12:54:16 <mm_freak> i wouldn't
12:54:17 <Twey> No, just all Applicatives, I think?
12:54:24 <mm_freak> because technically a "map" is not a "zip"
12:54:28 <djahandarie> Twey, Zippable is more general than an Applicative
12:54:32 <djahandarie> And has different laws
12:54:39 <Twey> Aha
12:54:50 <djahandarie> Twey, http://hackage.haskell.org/packages/archive/keys/0.2.3/doc/html/src/Data-Key.html#Zip
12:55:02 <djahandarie> It's kind of in a weird package but that's where edwardk needed it :p
12:55:12 <c_wraith> Athas: You can't put type constraints in a type alias
12:55:12 <Panaetius> frerich_: if it doesn't have to be a list you could use Data.Vector and the imap function, might get you better performance
12:55:22 <c_wraith> Athas: at least, not in a way that does anything useful
12:55:38 <Athas> c_wraith: indeed, but my type signatures end up being hard to read.  How is this normally solved?
12:55:39 <Twey> djahandarie: Haha
12:56:10 <c_wraith> Athas: depends on how hard...  If it's bad enough, just leaving them off entirely.  Otherwise, formatting them carefully over multiple lines
12:56:40 <mm_freak> in specific cases 'transpose' is a good alternative to zipping
12:56:50 <djahandarie> Twey, since all Haskell Functors are strong though, you do get unzip for every Functor
12:56:59 <mm_freak> > map sum . transpose $ [[1,3], [2,4]]
12:57:01 <djahandarie> :t fmap fst &&& fmap snd
12:57:01 <lambdabot>   [3,7]
12:57:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> (f a, f b)
13:00:16 <n0den1te> kmc: I get your point now. You guys should be having a FAQ page about common misconceptions in haskell. :)
13:00:40 <c_wraith> there is one.
13:00:45 <c_wraith> I forgot where, though
13:00:52 <n0den1te> And yeah, how about #haskell for reinforcing fundamental concepts? You guys are great.. :)
13:01:06 <Twey> It's probably not that useful — they tend to go a bit deeper
13:01:21 <olsner> c_wraith: maybe the location is in the FAQ :P
13:01:42 <Twey> @faq Can Haskell correct misconceptions?
13:01:42 <lambdabot> The answer is: Yes! Haskell can do that.
13:01:54 <n0den1te> olsner: not to go deep down the rabbit hole. :P
13:02:04 <Twey> Interestingly, I don't think that's such a FAQ as it used to be
13:02:35 <Twey> I guess people are getting more exposure to functional programming, or at least the idea of programming in different paradigms
13:03:13 <djahandarie> I lobby this in every place I go to on the internet and I imagine most other people do also. ;)
13:03:21 <djahandarie> So I can't say I'm surprised
13:03:55 <Twey> Heh
13:04:13 <frerich_> mm_freak, c_wraith: Coolness, it works beautifully with zipWith. I have this tendency of solving 50% of my list problems with 'map', I think I should consider zipWith much more often
13:04:19 <n0den1te> I don't know very much about exposure to FP and the like. I just took it up cos I was getting bored.. :P
13:04:23 <frerich_> mm_freak, c_wraith: Thanks for the pointer!
13:05:36 <xplat> > foldr (+) 0 [1..] :: Expr
13:05:36 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + (11 + (12 + (13 + (14 + (...
13:05:38 <n0den1te> So I gave Scala a look in and the scala folks were raving about haskell. So I wanted to see what the ruckus was all about. Here I am. :)
13:06:30 <mm_freak> frerich_: i usually solve my list problems by not having lists =)
13:06:59 <n0den1te> @faq can haskell make me coffee?
13:06:59 <lambdabot> The answer is: Yes! Haskell can do that.
13:07:19 <c_wraith> n0den1te: Scala's got some really cool features, too.  It's definitely worth being familiar with both
13:07:24 <n0den1te> lambdabot: you need to go on a break. 
13:08:22 <n0den1te> c_wraith: yes, I was initially struggling with Scala's FP features. Now that I have an hang of them, working haskell has been a breeze so far. Atleast, until now. 
13:09:11 <n0den1te> (though I may get the terms wrong, like it happened with partially applied functions)
13:10:18 <lpsmith> n0den1te, lambdabot takes many breaks already,  unfortunately :-P
13:10:28 <xplat> huh, lambdabot has no Debug.SimpleReflect.op ...
13:10:41 <xplat> (or just SimpleReflect.op either)
13:11:53 <Tomsik> > unfoldr (\a -> Just (a, a^2)) 2 :: Expr
13:11:54 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
13:11:54 <lambdabot>         against inferred ...
13:12:01 <Tomsik> :t unfoldr
13:12:02 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
13:12:05 <mm_freak> is there a generalized peelIO, which covers m a -> m b?
13:12:14 <mm_freak> the one in monad-peel just covers m a -> m a
13:12:36 <Tomsik> > unfoldr (\a -> Just (a, a^2)) 2 
13:12:37 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
13:12:59 <djahandarie> > unfoldr (\a -> Just (a, a^2)) x :: Expr
13:12:59 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
13:12:59 <lambdabot>         against inferred ...
13:13:06 <djahandarie> > unfoldr (\a -> Just (a, a*a)) x :: Expr
13:13:06 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
13:13:06 <lambdabot>         against inferred ...
13:13:06 <Tomsik> What is this expr thing
13:13:32 <djahandarie> > unfoldr (\a -> Just (a, a*a)) x :: [Expr]
13:13:33 <lambdabot>   [x,x * x,x * x * (x * x),x * x * (x * x) * (x * x * (x * x)),x * x * (x * x...
13:14:55 <kmc> Tomsik, http://hackage.haskell.org/package/simple-reflect
13:15:41 <Tomsik> kewl
13:15:56 <Tomsik> > unfoldr (\a -> Just (a, a^2)) 2 :: [Expr]
13:15:57 <lambdabot>   [2,2 * 2,2 * 2 * (2 * 2),2 * 2 * (2 * 2) * (2 * 2 * (2 * 2)),2 * 2 * (2 * 2...
13:17:08 * hackagebot zlib-enum 0.2 - Enumerator interface for zlib compression  http://hackage.haskell.org/package/zlib-enum-0.2 (MalteSommerkorn)
13:25:08 <Panaetius> is there an extension so i can get scoped labels in record syntax?
13:25:24 <mm_freak> Panaetius: what is a scoped label?
13:26:35 <mm_freak> Panaetius: if you mean pattern-matching, you can do:  MyRecord { myRecordField1 = f1, myRecordField2 = f2 }
13:27:17 <Panaetius> like having two datatypes with labels of the same name (or whatever you call the label thingies in record syntax), but having them somehow scoped to their respective datatype. so you don't get "multiple declarations" compiler errors
13:27:43 <monochrom> no extension for this
13:28:36 <Panaetius> or something like this: http://research.microsoft.com/en-us/um/people/simonpj/Haskell/records.html
13:30:05 <Eduard_Munteanu> Reusable record labels would be nice.
13:30:27 <monochrom> that one is not in ghc either
13:31:07 <monochrom> it seems people have totally forgotten about it. (I certainly have.)
13:31:49 <Panaetius> so record syntax is pretty much useless in any decent size project unless you're extremely creative and have a good memory? 
13:32:30 <monochrom> perhaps it was proposed too early, in the days when not enough people were hurt. the same proposal raised today would get much more attention.
13:32:33 <Eduard_Munteanu> Not really. You might be tempted to overuse it to emulate OOP, don't do that.
13:32:47 <ddarius> Panaetius: Use modules.  Modules are how namespaces are managed.
13:33:18 <monochrom> I am extremely creative and my computer has a good memory. I think the two of us will cope. :)
13:34:26 <Panaetius> ddarius: but having dozens of modules with just a single datatype defined in them isn't really good design in my book, when those types are related and used alongside
13:34:45 <Eduard_Munteanu> Remember OOP is just POO spelt backwards, which doesn't really change things ;)
13:34:45 <ddarius> Panaetius: It's perfectly fine design.
13:35:08 <Zao> Eduard_Munteanu: And in French, it's POO forwards.
13:35:24 <domme> hey
13:35:27 <Eduard_Munteanu> Heh, yeah, actually one of my courses was named "POO" for OOP.
13:35:29 <Zao> http://fr.wikipedia.org/wiki/POO :D
13:35:29 <ddarius> Panaetius: The problem is that currently modules are flat and (in all current implementations) you can only have one to a file which is extremely heavy-weight.
13:35:47 <monochrom> did you know this is valid haskell?  data D = C1 { b::Bool } | C2 { b::Bool, x::Int } | C3 { x::Int }  it may satisfy some of your needs.
13:35:48 <domme> how do i pattern match against a newtype with record syntax?
13:36:04 <Eduard_Munteanu> http://ro.wikipedia.org/wiki/POO :)
13:36:13 <domme> i have newtype Set a = Set {list :: [a]} and want to make an instance of show for it
13:36:22 <monochrom> you can ignore the record part and just write f (Set v) = v
13:36:31 <monochrom> show (Set v) = show v
13:36:33 <Eduard_Munteanu> It seems latin people are a bit more honest about it :P
13:36:51 <monochrom> you can also write show Set{list=v} = show v
13:36:52 <domme> instance (Show a) => Show (Set a) where 
13:36:57 <domme> ah
13:37:09 <ddarius> I've suggested an extension for local modules to handle this.  Then getting what you want would just be, module Whatever where { data R = R { foo :: Int } } which is just a line or two of overhead to get what you want, and you also get a lot more besides, and you don't start conflating language features.
13:38:01 <monochrom> as another example, for my data type D above, you could write "f (C2 i j) = ..." just fine, i will be the b field, j will be the x field.
13:38:16 * hackagebot testpack 2.0.3 - Test Utililty Pack for HUnit and QuickCheck  http://hackage.haskell.org/package/testpack-2.0.3 (JohnGoerzen)
13:38:21 <Panaetius> monochrom: yes but with that I'm in an either/or dilemma with something else I wanted to do :) but I guess I'll take that route
13:38:43 <Eduard_Munteanu> domme: if you define something using record syntax, you can still refer to it in the usual "constructor-ful" syntax, just respect the order of the records.
13:39:09 <Panaetius> ddarius: that would be a nice feature indeed
13:40:09 <domme> Eduard_Munteanu: oh also useful, thanks
13:40:11 <monochrom> well yes that route satisfies some needs but not others.
13:40:11 <domme> mattam: thanks too
13:40:59 <domme> how do i do what implode is in php? like glueing a list together with a glue element between the elements
13:40:59 <monochrom> my point is some people don't even know they have this choice. it's a rarely mentioned part of standard haskell.
13:41:31 <Panaetius> hum now if only I could indent that nicely... 
13:41:58 <domme> glue ';' "hello" would give me "h;e;l;l;o" 
13:42:01 <parcs> domme: intercalate
13:42:06 <domme> ah, yeah
13:42:07 <TomMD> Heh, the Genode project noticed HaLVM and said "Hey, we want one too."
13:42:08 <dmwit> > intersperse ';' "hello"
13:42:09 <lambdabot>   "h;e;l;l;o"
13:42:20 <monochrom> as for distinct types, my current strategy is still the plain "just use different field names".
13:42:24 <dmwit> > intercalate "; " ["one", "two", "three"]
13:42:25 <lambdabot>   "one; two; three"
13:42:30 <dmwit> choose which one is appropriate
13:42:35 <kosmikus> @hoogle a -> [a] -> [a]
13:42:35 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
13:42:35 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
13:42:35 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
13:42:58 <Panaetius> like 
13:42:59 <Panaetius> data X = A {a::Int,
13:42:59 <Panaetius>             b::Bool}
13:42:59 <Panaetius>         |B {a::Int,
13:42:59 <Panaetius>             c::Float}
13:43:03 <Panaetius> would be nice
13:43:14 * Panaetius is a sucker for indentation ;)
13:43:23 <monochrom> indeed, in a rather strong sense, if after deliberate consideration, you decide to have two different types and cannot unify them as one, then it really means their natures are so different they don't deserve to share field names.
13:43:42 <Eduard_Munteanu> I wonder if the compiler could simply sugar up stuff for reusing those names by using MPTCs and fundeps.
13:44:04 <ddarius> Things like that have been suggested.
13:44:45 <xplat> 15:18 < kmc> if hackage looked like a website from 1995 then it would have a  starfield background and a "under construction" animated gif of a  guy with a shovel
13:45:09 <Eduard_Munteanu> Like for any datatype X with record getFoo, there's a class hasGetFoo a b | a -> b where getFoo :: a -> b   where b is the type of the original getFoo
13:45:22 <Panaetius> huh i retract that, you can actually write it that way... my "indentation error" was on a different line...
13:45:36 <Eduard_Munteanu> It should be relatively easy to implement :/
13:45:41 <monochrom> haskell emacs mode indents that way
13:46:08 <xplat> if hackage looked like a website from 2011 it would have 5000 widgets on the side so you can say how much you like it to your friends on every social network and bookmarking site ever invented, plus another 5000 widgets for automatically generated 'related' content
13:46:10 <monochrom> oh actually, a little bit different.
13:46:29 <monochrom> But I myself tend to write "| B" rather than "|B" anyway
13:46:47 * monochrom sprinkles spaces here and there!
13:47:31 <Panaetius> yes me too, that was a typo
13:47:41 <Eduard_Munteanu> (and of course when you make instances, a is X)
13:47:58 <monochrom> yeah I'm not sure when a criticism "it's so 1995" is raised, what is the real point and what the speaker really wants.
13:48:06 <Eduard_Munteanu> Panaetius: it's common to have '|' line up with '='.
13:48:52 <paolino> hello, how is it the new syntax for recursive do ? I don't understand the doc
13:48:56 <monochrom> for example does the speaker want "round corners" for rectangles? I for one don't miss them.
13:49:45 <monochrom> there are examples of new recursive do on http://www.haskell.org/haskellwiki/MonadFix
13:50:10 <Eduard_Munteanu> :t mfix
13:50:11 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
13:50:15 <benmachine> oh dear, uu-parsinglib has Category: Parsing, Text,
13:50:24 <benmachine> and that trailing comma seems to have put it in the "" category
13:50:30 <Panaetius> i don't know, hackage looks nice and is easily readable. I'll take it over something like http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html any day of the week
13:51:04 <domme> how do i get a list of chars from a list of integers?
13:51:12 <benmachine> domme: which chars?
13:51:24 <domme> '1','2' 
13:51:30 <domme> mh
13:51:33 <Eduard_Munteanu> domme: what about 34 ?
13:51:34 <benmachine> domme: from which integers?
13:51:37 <tromp__> > [15,42] >>= show
13:51:38 <lambdabot>   "1542"
13:51:47 <paolino> thanks, it works now
13:51:54 <domme> okay, than i rather nead a list of strings
13:52:00 <benmachine> ah
13:52:01 <domme> so map show [1..10]
13:52:03 <Eduard_Munteanu> Then just 'show' them.
13:52:06 <byorgey> > map show [15,42]
13:52:06 <lambdabot>   ["15","42"]
13:52:20 <benmachine> ...does that answer your question?
13:52:31 <domme> yep, but i guess the question was wrong :)
13:52:56 <domme> i've got a list of integers [1..10] and i wanna display them as 1;2;3;... in my show instance
13:52:59 <domme> how do i do that?
13:53:08 <monochrom> you should also be aware that "from integer to string" is in principle vague.
13:53:09 <tromp__> :t intersperse
13:53:09 <lambdabot> forall a. a -> [a] -> [a]
13:53:47 <c_wraith> ok, the icfp paper from the simons looks really intriguing.
13:53:49 <benmachine> domme: I am still confused. explain in words what you want, instead of by example
13:54:04 <Eduard_Munteanu> Formalizing stuff is hard :)
13:54:18 <timestart> explain it in haskell, problem solved!
13:54:20 <monochrom> > intercalate ";" (map show [1,2,3])
13:54:21 <lambdabot>   "1;2;3"
13:54:22 <benmachine> :P
13:54:44 <domme> oh
13:54:45 <tromp__> :t intercalate
13:54:45 <lambdabot> forall a. [a] -> [[a]] -> [a]
13:54:47 <monochrom> programming is harder than formalizing, clearly.
13:55:05 <domme> yes, that is what i was looking for, thanks monochrom 
13:55:06 <Eduard_Munteanu> Uh, that's downright intractable :P
13:55:11 <ddarius> Programming = formalizing + optimizing
13:56:20 * hackagebot polynomials-bernstein 1 - A solver for systems of polynomial equations in bernstein form  http://hackage.haskell.org/package/polynomials-bernstein-1 (PierreEtienneMeunier)
13:56:48 <monochrom> even more than that. when formalizing, you may use unexecutable or unimplemented primitives like quantifiers. you have that much more freedom and less work to do. when programming, you are confined to a much more restrictive language, availing only executable primitives.
13:58:14 <Eduard_Munteanu> Isn't that a paradox in some views of declarative/logic programming languages?
13:58:47 <Eduard_Munteanu> Like, telling the computer what (rather than how) to produce.
13:59:04 <monochrom> in that case it goes back to what ddarius says.
14:00:28 <monochrom> in a logic language you could declaratively say "all solutions to x^x = x" but it will search forever. to speed up the search, you have to refine what you say.
14:01:06 <c_wraith> How many solutions does that have anyway?  I see one obvious solution...
14:01:08 <Eduard_Munteanu> Hm, incidentally some of that looks a lot like what you can do with list comprehensions in Haskell.
14:01:14 <Skola> any suggestions for speeding up this ugly thing?: http://hpaste.org/45000/slow_stuff
14:01:14 <lpsmith> c_wraith, that's the only one
14:01:55 <lpsmith> well, one positive solution anyway
14:02:12 <lpsmith> x^x is concave up,  so you can't have more than two solutions.
14:02:40 <lpsmith> (again, on the positive part)
14:02:53 <benmachine> ±1?
14:02:54 <Eduard_Munteanu> More generally it's monotone.
14:02:55 <Skola> @ self: or a prettier way to write it down?
14:03:09 <c_wraith> Skola: instead of checking to see if each integer is in your list of sums, try to enforce increasing ordering on sums, and just taking the elements in the range you care about
14:03:11 <benmachine> I guess x^x gets messy for x < 0
14:03:53 <c_wraith> Skola: that change alone would be a huge increase in speed
14:04:09 <Skola> alright
14:04:21 <c_wraith> Skola: err, whoops, you want the values not in the list of sums.  But it's the same idea.
14:04:36 <Eduard_Munteanu> Also makes sure you're compiling with optimizations turned on.
14:04:37 <monochrom> what a timely concrete example of declarative and formalize + optimize :)
14:04:51 <Eduard_Munteanu> 'sum' there might be unhappy otherwise.
14:05:23 <lpsmith> Eduard_Munteanu, a monotone function can have an arbitrary number of intersections with y=x
14:05:36 <lpsmith> concave up can only have two,  at most
14:05:40 <Skola> c_wraith, what functions could I look into?
14:05:47 <Skola> for the sum part
14:05:51 <Eduard_Munteanu> lpsmith: um, but don't you only care about intersections with y = 0 ?
14:05:56 <monochrom> (you could translate an Euler problem statement literally into mercury or haskell. it will run with 24/7 99.9999% high availability...)
14:06:05 <benmachine> Eduard_Munteanu: the question was x^x = x
14:06:10 <Eduard_Munteanu> Oh, right.
14:07:10 <Eduard_Munteanu> The diophantine eq is probably reasonable even for x < 0.
14:08:07 <Eduard_Munteanu> Depends on whether x is negative odd/even, I guess.
14:08:29 <benmachine> monochrom: 24/7 *is* a high probability, more than three times certain :o
14:08:43 <benmachine> wait
14:08:46 <benmachine> I misread totally
14:08:47 <benmachine> ignore me
14:08:53 <Eduard_Munteanu> LOL
14:09:05 <dolio> I think you'd have to be somewhat lax to consider x^x - x = 0 a diophantine equation.
14:09:12 <monochrom> trying to turn a positive jargon into a negative one :)
14:09:29 <Eduard_Munteanu> I meant if you were only interested in integer solutions.
14:09:31 <c_wraith> Skola: I'd just make a list of all the sums, nub it, and sort it.  Then write something that traverses the list returns all the numbers not in it.
14:09:55 <Skola> ya nub takes years though
14:10:18 <c_wraith> ...  Then you have too many duplicates in your list of sums
14:10:34 <Skola> ja I have plenty alright
14:10:35 <Eduard_Munteanu> Skola: you should write your own 'nub' that takes ordering into account.
14:10:36 <Eduard_Munteanu> :t nub
14:10:37 <lambdabot> forall a. (Eq a) => [a] -> [a]
14:10:54 <Eduard_Munteanu> As you can see, the Prelude stuff doesn't.
14:11:01 <c_wraith> Oh, true.  you can beat the performance of nub by sorting first
14:11:36 <Skola> ok
14:11:46 <xplat> so what you're trying to do is, you want to print the sum of all the numbers from 1..20161 that are not the sum of two abundant numbers?
14:12:04 <Skola> yes
14:12:10 <c_wraith> You can also do a couple things to make sure you reduce the duplication involved..  like making sure that if you add the pair (x, y), you don't also add the pair (y, x)
14:12:32 <Skola> ye c_wraith like y >= x
14:12:35 <c_wraith> That change alone reduces the size of the list by a factor of two.
14:12:35 <xplat> about how many abundants do you get?
14:13:49 <Skola> 4994 if I remember correctly
14:13:50 <Eduard_Munteanu> Anyway sorting then nubbing along with Ord constraints is better than nub alone, it's O(n log n) + O(n) = O(n log n)   vs  O(n^2)
14:14:02 <Skola> in [12..20161]
14:14:25 <jmcarthur> it's not necessarily better if you are relying on laziness
14:14:35 <jmcarthur> > nub [1..]
14:14:36 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:14:47 <jmcarthur> > Set.toList $ Set.fromList [1..]
14:14:48 <lambdabot>   Not in scope: `Set.toList'Not in scope: `Set.fromList'
14:14:55 <jmcarthur> > S.toList $ S.fromList [1..]
14:14:59 <lambdabot>   mueval-core: Time limit exceeded
14:15:02 <xplat> jmcarthur: Skola eventually folds all this up into one integer, so no laziness
14:15:29 <jmcarthur> also not better if you need to ordering preserved
14:15:30 <xplat> (and i mean all of it, no take after nub)
14:15:32 <jmcarthur> *the
14:15:43 <jmcarthur> yeah, that's the more common case
14:15:44 <dolio> Sorting and nubbing the current sums does a lot of extra work.
14:15:45 <Eduard_Munteanu> Yeah, I suppose plain nub is better if you're processing streams of data (online stuff).
14:15:49 <burp> @oeis 12, 18, 20, 24, 30, 36, 40, 42, 48, 54, 56, 60, 66
14:15:49 <lambdabot>  Abundant numbers (sum of divisors of n exceeds 2n).
14:15:49 <lambdabot>  [12,18,20,24,30,36,40,42,48,54,56,60,66,70,72,78,80,84,88,90,96,100,102,104,...
14:15:53 <jmcarthur> i'm just saying, nub isn't always better
14:15:58 <jmcarthur> err
14:16:06 <jmcarthur> nub isn't always worse
14:16:14 <jmcarthur> but usually is in most cases
14:16:40 <Skola> the adding takes like 20% of the time
14:16:40 <dolio> There's already a sorted list of abundant numbers. And you only need to include (a+b), not (b+a).
14:17:18 <lpsmith> you can keep track of which elements you've seen in a set,  and get a lazy nub that's asymptotically faster than nub
14:17:29 <lpsmith> (that uses Ord)
14:17:32 <dolio> Taking any given abundant a, you can add it to the list of numbers higher than it automatically getting a sorted list of abundant numbers (a+b).
14:18:03 <jmcarthur> lpsmith: yeah that's a pretty decent one
14:18:20 <Eduard_Munteanu> Though that's a hidden time-space tradeoff.
14:18:23 <dolio> And you can merge such lists eliminating duplicates.
14:18:32 <Eduard_Munteanu> (especially for stuff like Integer)
14:18:50 <lpsmith> Eduard_Munteanu, not really;  nub keeps around all those integers in closures
14:19:19 <lpsmith> nub and my proposed ordNub should have the same asymptotic space usage
14:19:45 <lpsmith> O(n) after it produces n numbers and hasn't seen the end of the list it's processing
14:19:48 <dolio> ordNub might actually have less.
14:19:49 <xplat> for summing two sorted lists and returning things in order you could probably avoid the sort altogether by doing a \ns -> map (flip map ns . (+)) and merging all the streams
14:20:30 <xplat> which is what dolio just said except i spent all my time editing instead of typing :)
14:20:59 <monochrom> To determine whether n ∈ X+Y: compute and sort n-X, sort Y, then look for a common element between n-X and Y. about |X|*log|X| + |Y|*log|Y| + |X|+|Y| steps.
14:21:05 <dolio> nub keeps around a (hidden) list of all seen members. That's O(n).
14:21:07 <Panaetius> Skola: you could get a little performance gain by pruning sums of all entries > 20161 before doing the not member, then you wouldn't have as many comparisons for notMember. I guess that the simplest optimization without restructuring
14:21:14 <Eduard_Munteanu> lpsmith: I mean it's O(m) in space where m is the number of different n's
14:21:23 <dolio> ordNub keeps around a set of seen members. That's O(k), where k is the number of unique members seen.
14:21:37 <Skola> yes Panaetius, I should
14:21:51 <monochrom> (if you compute and sort X+Y, |X|*|Y|*(log|X| + log|Y|) steps)
14:21:58 <dolio> Oh, wait, I'm wrong.
14:22:22 <dolio> Because nub eliminates the subsequent duplicates before it can add them to the list.
14:22:27 <Skola> sums < 20162 and I y >= x
14:22:30 <xplat> monochrom: hm, neat, but you have even more ns than Ys
14:22:33 <dolio> So they're both O(k).
14:22:42 <xplat> (in this case)
14:23:44 <Eduard_Munteanu> dolio: which, the lazy ordNub, or the ordNub . sort stuff?
14:24:00 <Eduard_Munteanu> The latter shouldn't depend much on 'k' in space.
14:24:04 <monochrom> ah, then I'll have to re-think.
14:24:13 <xplat> monochrom: (or xs for that matter)
14:25:00 <xplat> it seems like there ought to be some sieve-y way to do this though, yes
14:25:14 <lpsmith> Eduard_Munteanu, right,  O(m).   That's what I said,  though I probably wasn't very clear.  
14:25:35 <lpsmith> (as the number of elements produced by nub so far equals the number of distinct elements seen)
14:25:45 <dolio> Eduard_Munteanu: nub keeps around O(k) elements. So does the lazy ordNub.
14:26:52 <Eduard_Munteanu> Ah, yes, I wasn't looking at the result.
14:27:07 <Skola> so apparantly the fastest way to do what I want
14:27:14 <Skola> involves getSequenceByID "A048242"
14:27:16 <Skola> :D
14:27:25 <parcs> @hoogle ordNub
14:27:25 <lambdabot> No results found
14:27:38 <Skola> but seriously speaking, thanks for all the ideas
14:27:59 <Eduard_Munteanu> That's + O(p) in time where p is the number of hops to your nearest OEIS source :P
14:28:07 <Skola> :D
14:28:12 <Panaetius> you could always overengineer it and implement bloom filters for the notMember function...
14:28:35 <lpsmith> parcs,  referring to something that's exactly equivalent to nub,  except the type is :: (Ord a) => [a] -> [a]
14:28:59 <lpsmith> as far as I know, that function isn't available in a standard library,  or popular hackage package
14:29:33 <Eduard_Munteanu> IMHO GHC should've really added that instead of some of the Control.Monad nonsense that made it in :)
14:29:36 <lpsmith> I have a function "nub" in data-ordlist,  but it only equivalent to the Data.List.nub on ordered lists
14:29:40 <Eduard_Munteanu> (GHC 7)
14:29:48 <sipa> :t nub
14:29:49 <lambdabot> forall a. (Eq a) => [a] -> [a]
14:29:53 <sipa> @src nub
14:29:53 <lambdabot> nub = nubBy (==)
14:29:56 <sipa> @src nubBy
14:29:57 <lambdabot> nubBy eq []             =  []
14:29:57 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
14:30:39 <lpsmith> nub [9,2,6,2,5,3,4]
14:30:42 <lpsmith> > nub [9,2,6,2,5,3,4]
14:30:43 <lambdabot>   [9,2,6,5,3,4]
14:31:00 <lpsmith> removed the duplicate 2
14:31:45 <incomprehensibly> Cale: are you doing things with FRP and the iPhone?
14:36:18 <Skola> is it possible to get a complete OEIS Sequence with the oeis package?
14:37:49 <burp> Skola: you mean, as far as OEIS have it?
14:38:15 <Skola> they have a link to the complete Sequence in question
14:38:24 <Skola> hosted by them
14:38:29 <burp> ah I see
14:38:48 <marcos> hello
14:38:50 <Skola> but I guess the Haskell package only gives us the first x terms
14:41:22 <Guest96022> newb here, simple question on 3 lines of code: http://pastebin.com/cMx1Tx7T
14:41:52 * monochrom hugs flashblock
14:42:09 * benmachine hugs monochrom 
14:42:17 <hpc> Guest96022: consider a simpler case, [1,2]
14:42:21 <byorgey> Guest96022: [sa] is the list which contains only one element, namely the list sa
14:42:24 <sipa> Guest96022: remove the [] around sa
14:42:36 <byorgey> > last [[2,3,4]]
14:42:37 <lambdabot>   [2,3,4]
14:43:18 <Guest96022> but removing the [] produces an error
14:43:32 <monochrom> I do not understand the logic behind writing "[sa]", unless the logic is influenced by the like of Perl
14:43:51 <benmachine> Guest96022: what is your aim in using the last function?
14:43:52 <hpc> Guest96022: so you want your function to reverse the list?
14:44:04 <monochrom> then perhaps "last whatever" is the wrong thing to do in the first place
14:44:09 <Guest96022> yes, i would like to reverse the list, and this was my first step
14:44:27 <sipa> Guest96022: what error do you get if you remove the [] around sa?
14:44:37 <hpc> Guest96022: so consider the base case, a list with nothing inside; you reverse it and end up with []
14:44:42 <Guest96022> i get the error : Occurs check: cannot construct the infinite type: a = [a]
14:44:50 <hpc> Guest96022: a list with one element is itself when you reverse it
14:45:06 <monochrom> reverser (x:sa) = reverser sa ++ [x]  would be closer to achieving the goal
14:45:14 <hpc> Guest96022: a list with two elements [x,y] should reverse to [y,x]
14:45:19 <sipa> Guest96022: last returns a single element, not a list
14:45:27 <sipa> Guest96022: but the [] case does return a list
14:45:35 <sipa> so maybe you want [last sa] ?
14:45:36 <hpc> Guest96022: and a list with three elements [x,y,z] should be [z,(reverse [x,y])]
14:45:46 <hpc> Guest96022: (to abuse some notation)
14:46:28 <Guest96022> ahhh
14:46:43 <Guest96022> well [last sa] doesn't give me the error, and provides me with the last element of the list
14:46:50 <sipa> yes
14:46:55 <sipa> what did you want it to do?
14:47:01 <Guest96022> that's exactly what i wanted :D
14:47:19 <benmachine> reverser [0] will error though
14:47:30 <Guest96022> i didn't realize i was making a list of list by placing sa within the brackets :/
14:48:32 <hpc> Guest96022: you'll get the hang of it soon enough
14:49:44 <Guest96022> thanks alot hpc, benmachine and sipa
14:50:04 <Guest96022> back to 'learnyouahaskellforgood' :D
14:50:14 <TomMD> lyah
14:50:21 <hpc> lyah <3
14:52:45 <Athas> I am defining a class with a method foo_, and an ordinary function foo that wraps foo_ and gives it a slightly nicer interface.  Is this naming convention kosher?
14:54:35 <benmachine> Athas: the trailing underscore conventionally means 'discard result' but that's not a hard rule, you're probably fine
14:54:46 <benmachine> see: mapM vs mapM_, sequence vs sequence_
14:57:20 <TomMD> Athas: If you don't expect anyone to call "foo_" then just have it defined in a where clause under "foo".
14:59:01 <Athas> TomMD: I expect instances of the class to define it.
14:59:15 <Athas> The type of foo_ makes implementation really convenient, while foo makes calling it really convenient.
14:59:27 <benmachine> Athas: one slightly strange thing you could do is
14:59:50 <benmachine> make foo the method, but define a fooMaker, that basically takes a function with foo_'s signature as input and outputs one that looks like foo
14:59:53 <Athas> It's part of an object system.  foo_ represents an action on an object and runs in a state monad encapsulating the object state, while foo is the function to indirectly perform an action on an object through a reference.
15:00:17 <benmachine> but my way is weird so ignore me :P
15:09:17 <frerich_> I tried to whip up a little function which can get a random value from an Enum type (e.g. Bool): http://hpaste.org/45001/random_value_from_data_type <-- unfortunately this yields an error message (quoted in the comment) which I don't understand. I don't know what to change about the type signature.
15:09:23 <frerich_> Does anybody understand what's going on?
15:10:30 <jix> frerich_: fromEnum $ maxBound works for any bounded enum so it can't infer it should be the same type you're returning
15:10:54 <frerich_> I tried using 'fromEnum (maxBound :: IO a)' but that didn't help :-/
15:11:28 <mm_freak> frerich_: use asTypeOf or ScopedTypeVariables
15:17:09 <frerich_> mm_freak: Hmm, I just read a bit about what asTypeOf does - is that like '::' except that I don't need to know exact type, instead I can give a value (of whatever type) to cast the first argument? I'm not sure how that helps me, since I have no value of type 'a'
15:17:53 <benmachine> frerich_: ah, but you can be ingenious :)
15:19:27 <benmachine> frerich_: for example, randomValue = x where x = ..., then x is type IO a
15:19:31 <frerich_> Hm, it actually works if I pass a dummy argument of type 'a' and then use 'maxBound `asTypeOf` x'
15:19:41 <frerich_> That's a bit ugly.
15:19:43 <benmachine> you don't need a dummy argument
15:20:11 <frerich_> I need to 'unwrap' the IO type, I think
15:20:21 <benmachine> you can do that in a moderately ugly way
15:20:28 <benmachine> since all you need is the type, not values
15:20:39 <benmachine> you can just do (undefined :: IO a -> a) x
15:21:40 <benmachine> and then the type will be right, and the value will be undefined, but it won't be evaluated so it's fine
15:22:18 * hackagebot polynomials-bernstein 1.1 - A solver for systems of polynomial equations in bernstein form  http://hackage.haskell.org/package/polynomials-bernstein-1.1 (PierreEtienneMeunier)
15:23:13 <frerich_> Err, that is a bit mind bending, let me digest this... undefined is just 'a'. You "cast" it to a function 'IO a -> a' and then pass 'x'. The result is a value of type 'a', which can be told without  actually evaluating the function. Did I get that right?
15:23:28 <benmachine> yes
15:23:52 <benmachine> it's the argument to asTypeOf, so the value itself won't ever be used
15:24:00 <benmachine> the second argument, that is
15:25:25 <benmachine> frerich_: using ScopedTypeVariables is much simpler, but I like the h98 way :)
15:26:12 <frerich_> benmachine: I'm still undecided whether your trick is totally cool or totally ugly, or both. In any case, my limited Haskell experience is now tainted.
15:26:18 <benmachine> frerich_: hmm, I wonder if I can find an easier way
15:26:20 <frerich_> ;-)
15:27:20 <sm> is it safe to run two lengthy multi-package cabal install's concurently on one machine ?
15:27:38 <hpc> sm: i would naively say no
15:27:43 <c_wraith> sm: I would expect not
15:27:47 <dcoutts_> sm: so would I
15:27:47 <hpc> but i am used to dpkg/apt
15:28:18 <sm> base to troops: get out of there! now, now!
15:28:20 <c_wraith> sm: even if they never install the same package, I don't expect that ghc-pkg can update package databases in an atomic and consistent way
15:28:31 <benmachine> frerich_: ah, got it!
15:28:48 <sm> too late! swap hell!
15:28:48 <benmachine> frerich_: the key is that type information in asTypeOf goes both ways
15:29:32 <benmachine> frerich_: one sec
15:30:07 <benmachine> frerich_: http://hpaste.org/45003/random_value_from_data_type_a
15:30:34 <benmachine> or hold on, I can do better
15:30:54 <dcoutts_> c_wraith: mm, for ghc-pkg I expect that with concurrent updates you would just lose one
15:31:06 <dcoutts_> c_wraith: but it'd reappear if you ran ghc-pkg recache
15:31:16 <c_wraith> dcoutts_: that's what I'd expect, too.  Not the friendliest behavior.
15:31:16 <frerich_> benmachine: Why do you still need 'x'?
15:31:21 <benmachine> frerich_: http://hpaste.org/paste/45003/random_value_from_data_type_a#p45004
15:31:26 <benmachine> frerich_: oh er, I don't :)
15:32:02 <benmachine> you can remove that
15:32:48 <frerich_> Hm I didn't realize that you can pass any (a,a) to randomRIO
15:32:59 <benmachine> any?
15:33:16 <frerich_> IFor which Random a is defined
15:33:18 <benmachine> yeah
15:33:26 <frerich_> In any case, you can have more than just numbers
15:33:32 <benmachine> mm
15:33:57 <c_wraith> You can see the context of a function as a predicate on the type variables in it.
15:34:13 <c_wraith> (Random a) => would mean "any a with Random defined"
15:34:37 <c_wraith> When viewed from that perspective, multi-parameter typeclasses encode relations between types
15:36:09 <frerich_> benmachine: I think it looks really neat, but I'm sure I will forget the hidden reasons why it works as it does. I'll just add an ' -- magic courtesy of benmachine @ #haskell'. :-}
15:38:32 <benmachine> frerich_: :)
15:41:48 <frerich_> Hm, but it doesn't seem to work; the final version I'm using is http://hpaste.org/paste/45003/random_value_from_data_type_a#p45005 but it keeps producing random values which are too large, so the toEnum invocations fail
15:42:03 <benmachine> curious.
15:42:09 <frerich_> Actually
15:42:09 <benmachine> ah
15:42:11 <frerich_> Do I need that at al
15:42:11 <frerich_> l
15:42:16 <benmachine> (toEnum r `asTypeOf` m)
15:42:16 <frerich_> 'r' has the right type already, no?
15:42:22 <benmachine> r is Int
15:42:42 <benmachine> you need m as the type of (toEnum r), not r
15:42:49 <hpc> benmachine: that's what it does
15:42:51 <benmachine> oh wait
15:42:59 <hpc> regular function application binds tightly
15:43:02 <benmachine> ok there are a few things wrong
15:43:18 <benmachine> hpc: the thing I said was the correction, not the original :)
15:43:22 <hpc> oh
15:43:23 <hpc> lol
15:43:36 <benmachine> frerich_: ok I made a few mistakes, I'm going to have to fiddle with things
15:43:39 <benmachine> I think the concept is sound
15:44:02 * ddarius fiddles with strings.
15:44:37 <benmachine> frerich_: ok I have a slightly more magic version :x
15:44:58 <benmachine> it relies on the fact that lambda bindings are monomorphic, so it's even less obvious than the previous versions
15:45:04 <frerich_> benmachine: Heh, okay. I think it would be a neat function, I recently started assembling a few functions which all work on (Enum a, Bounded a) (like 'allValues = [minBound..]', I can call that as 'allValues :: [Bool]' or so)
15:46:19 <benmachine> frerich_: http://hpaste.org/paste/45003/random_value_from_data_type_a#p45006 hlint doesn't like me
15:46:24 <benmachine> but it works
15:46:56 * frerich_ has a definition of 'polymorph' from his OO background and tries to translate that to 'monomorph'. Do you mean that lambda functions always take a concrete type (like 'Int') instead of a 'type variable'?
15:47:19 <c_wraith> monomorphic does mean not-polymorphic, yes.
15:47:24 <benmachine> frerich_: I'm not sure how exact my terminology is
15:47:31 <benmachine> how accurate it is
15:47:46 <c_wraith> > let f = id ; x = f "foo" ; y = f 5 in (x, y)
15:47:46 <benmachine> but what I mean is that a name bound by a lambda won't be "generalised"
15:47:47 <lambdabot>   ("foo",5)
15:48:16 <c_wraith> huh.  I was sure that f would get hit by the monomorphism restriction there
15:48:17 <benmachine> so in this case, m <- return maxBound (m is lambda-bound, because of the do-notation translation)
15:48:28 <c_wraith> does \bot have the monomorphism restriction turned off, now?
15:48:36 <benmachine> m is forced to have a single type, instead of (Bounded a, Enum a) => a
15:48:41 <benmachine> c_wraith: probably.
15:48:41 <frerich_> Well 'polymorph' means 'behaves differently depending on the type', which suggests something like (a -> a). 'monomorph' being the opposite suggests *either* 'only has one behaviour for one type' *or* 'only has one behaviour for all types', I'm not sure.
15:48:49 <iago> frerich_, in OO polymorphism is usually referred to subtype polymorphism, in FP it is usually referred to parametric polymorphism (I ignore the context of your phrase)
15:49:17 <blackdog> frerich_: 'morph' is actually linguistically related to 'shape'
15:49:32 <benmachine> frerich_: I can tell you how it applies to this case but I'm not sure what it means generally
15:49:35 <blackdog> so doing one action to things of many types also works.
15:49:53 <frerich_> benmachine: I think I get what you mean, the compiler doesn't infer a signature with type variables but with concrete types.
15:50:16 <benmachine> frerich_: it doesn't infer a type-class polymorphic type, at least
15:50:45 <benmachine> the name is not allowed to be used at different types in different places, I think
15:50:55 <niteria> is there a function that returns all list prefixes?
15:51:01 <dabblego> niteria: inits
15:51:01 <ezyang> :t heads 
15:51:02 <lambdabot> Not in scope: `heads'
15:51:10 <hpc> > inits [1..5]
15:51:10 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
15:51:11 * ezyang whistles innocently 
15:51:37 <frerich_> benmachine: Coolness, your latest most magical incarnation works fine for me.
15:51:53 <benmachine> frerich_: ok, I admit I'm not much clearer on the details than you :)
15:52:28 <frerich_> benmachine: Tough luck, you're embolished in a commit. As soon as my eyebrows start to raise when reading this code in a few days, I'll ping you :-P
15:52:35 <frerich_> s/commit/comment/
15:52:51 <benmachine> frerich_: :)
15:56:13 <hpc> my brain is totally fried :(
15:56:27 <hpc> i look at this assignment, and understand all the words
15:56:35 <hpc> shit, wrong tab
15:56:42 * hpc hates this class
15:56:48 <dagle> :)
16:02:51 <ddarius> hpc: If it's Mandarin Chinese class, that would be a fair start.
16:05:01 <hpc> ddarius: it's numerical analysis; this question is huge, and none of it makes sense in context
16:05:56 * hpc -> blah
16:06:47 <Missed> is haskell a good first programming language?
16:07:04 <dagle> Missed: Depends.
16:07:08 <hpc> Missed: hard to say; someone here taught it to his 8-yo child
16:07:16 <ion> Why not?
16:07:38 <hpc> ion: it assumes a strong math background
16:07:39 <chrisdb> hpc: I think you can teach the basics of most high-level programming languages to an 8 year old.
16:07:51 <chrisdb> I was playing around with VB 3 when I was around that age...
16:08:07 <hpc> i was playing Riven at that age
16:08:14 <hpc> i think i beat it at age 10
16:08:26 <ddarius> hpc: God you're young, and you aren't even the youngest.
16:08:27 <hpc> but this is off topic
16:08:39 <theorbtwo> Hm.  Neither VB 3 nor Riven existed when I was that age.
16:08:43 <Missed> oh, okay
16:08:53 <kmc> i don't think Haskell assumes any "math background"
16:08:54 <Missed> i want to learn how to program, im 14.
16:09:03 <theorbtwo> In fact, neither Visual Basic nor Myst existed at that time.
16:09:06 <kmc> Missed, why do you want to learn how to program?
16:09:14 <hpc> google says riven came out within a few months of me turning 7
16:09:19 <chrisdb> Hhhm, I was actually probably 9 given the release date for VB 3.
16:09:33 <Missed> to be a good programmer, and possibly have it as a carrer
16:09:39 <kmc> that's a good reason
16:09:50 <kmc> learning Haskell will help you become a good programmer, if you're willing to stick with it
16:09:56 <hpc> Missed: haskell isn't a "career language", but it is a great language for learning other languages from
16:10:03 <chrisdb> Well, Haskell isn't currently a language that you're likely to use in most corporate environments.
16:10:06 <kmc> learning Haskell won't help you make an awesome website or video game a week from now
16:10:12 <hpc> or at least, learning new techniques and theorems
16:10:13 <kmc> it might help you do those things in 2 years
16:10:14 <blackdog> hpc: it's a great way to be dissatisfied with other languages
16:10:16 <chrisdb> But as others say... that doesn't mean it's not valuable to learn.
16:10:20 <hpc> blackdog: haha, that too
16:10:23 <chrisdb> Don't learn Java first, it will rot your brain.
16:10:26 <Missed> I'm very willing, and yeah, im just trying to get started with programming, get something under my belt, ya know?
16:10:42 <blackdog> (cue kmc chipping me for dismissing ruby/c/python:)
16:10:43 <kmc> Missed, i recommend you also look at Python and Scheme
16:10:44 <hpc> Missed: start with learnyouahaskell and see how you fare, perhaps
16:10:45 <geheimdienst> it doesn't matter that corporations don't use haskell much. haskell makes you a better programmer, regardless of the programming language
16:10:47 <hpc> @where lyah
16:10:47 <lambdabot> http://www.learnyouahaskell.com/
16:10:59 <kmc> #haskell concludes: learning Haskell makes you awesome
16:11:05 <theorbtwo> I don't think Haskell is a good language to "get something under your belt", though.
16:11:14 <blackdog> Missed: a good idea might be to have a simple, concrete project in mind
16:11:15 <Missed> im on step 21 of tryhaskell.org
16:11:17 <hpc> Missed: i bookmarked lyah for a year or so, and when i had nothing to do i would read until i didn't understand something
16:11:18 <theorbtwo> Learing haskell probably does make you awsome, though.
16:11:22 <ion> I was wishing i’d get one of the ~1 MHz computers at that age. Alas, i had to wait a couple of years more. I learned BASIC quickly but had no resources or teachers to learn assembly or C for years to my disappointment.
16:11:23 <hpc> worked wonders
16:11:37 <Missed> what is lyah
16:11:42 <ion> @where lyah
16:11:42 <lambdabot> http://www.learnyouahaskell.com/
16:11:44 <hpc> lyah == learnyouahaskell.com
16:11:47 <Missed> oh
16:11:48 <dabblego> I use whatever the fuck is most appropriate, and that is very often haskell
16:11:48 <blackdog> build a simple website, or tracking tool at the console, or a simple game...
16:11:50 <hpc> best name for a thing, ever
16:11:52 <chrisdb> I had this cool little "portable" word processor thing that had old fashioned "line numbers" BASIC on it.
16:12:05 <chrisdb> By portable, I mean it weighed a ton but was just about moveable.
16:12:22 <hpc> chrisdb: sounds like a comodore 64 with a battery
16:12:24 <Missed> thanks guys
16:12:59 <blackdog> dabblego: it's often a social thing for me - i'd write something in haskell, but my colleagues speak ruby, and i can't be the only one who can understand it.
16:13:12 <dabblego> I also refuse to appease that attitude
16:13:22 * ddarius recommends Scheme as a first language over Haskell for several reasons, although most of them are pragmatic.
16:13:26 <dabblego> "I only speak Ruby" attracts the response, "what the fuck would you like me to do about that?"
16:13:29 <hpc> blackdog: they must be bombarded with propoganda!
16:13:38 <hpc> glorious glaskow haskell complation system forever!
16:14:15 <hpc> dabblego: if i found out everyone at my workplace knew ONLY ruby, i would probably up and leave
16:14:16 <chrisdb> ddarius: isn't Scheme a bit limited from a libraries point of view? For someone starting out, something a bit more "Batteries Included" might be easier.
16:14:29 <blackdog> dabblego: on a shorter project, the time it'd take to become conversant with haskell would be prohibitive
16:14:36 <dabblego> hpc: everyone at my work knows only one or to languages, so I taught them
16:14:43 <ddarius> chrisdb: Not in any way that would matter to someone starting out, and not compared to Haskell.
16:14:53 <dabblego> *two
16:14:54 <pumpkin> hm
16:15:00 <ian_mi> Use haskell for the creative error messages! enjoy debugging "My brain just exploded."
16:15:09 <hpc> my boss' philosophy is that a good programmer should be able to read code in any language, even if he/she can't write in it
16:15:12 <blackdog> and the libraries are still a bit rougher in haskell - many are better, but the niceties you get with ruby (say, for deployment) aren't there.
16:15:15 <chrisdb> ddarius: well, I was thinking more of Python or Ruby as "Batteries Included" alternatives.
16:15:30 <ezyang> Haskell is fairly batteries included these days. 
16:15:32 <ddarius> chrisdb: Now if they only came with pedagogy included as well.
16:15:37 <ion> hpc: [lolssdsl0lqx]sx[1+lddd*lld*-ls+dsdrll2**lo+dsld*rd*+4<kd15>q]sq[q]9ksk[d77/3*2-ss47lxx-P1+d78>0]s00[d23/.5-3*so0l0xr10P1+d24>u]dsux
16:15:38 <ddarius> ezyang: As is Scheme.
16:15:46 <dabblego> blackdog: we have our own hackage server -- I've never sen a better deployment environment
16:15:50 <hpc> ion: is that php or something? :P
16:15:53 <ion> hpc: dc
16:15:59 <Missed> the site says the tutorial is aimed at people who have experience in programming, and i have none.
16:16:00 * hpc language-trolls for justice
16:16:02 <blackdog> hpc: actually, i exaggerate - ruby'd be their main language, but most speak obj-c too, and a few have python and erlang too
16:16:19 <hpc> blackdog: yay, erlang
16:16:28 <ian_mi> hpc: +/ % #
16:16:39 <ion> hpc: I must admit i’m a bit proud of that program. I’m sure an actual guru will be able to implement it in half the code, though. :-P
16:16:54 <hpc> > fix$(<$>)<$>(:)<*>((<$>((:[{- thor's mother -}])<$>))(=<<)<$>(*)<$>(*2))$1
16:16:55 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
16:16:58 <blackdog> dabblego: that only handles code. i'm talking about migrating databases, provisioning boxes, restarting appropriate services etc
16:17:13 <dabblego> blackdog: I use haskell for that
16:17:29 <dabblego> whatever is most appropriate, which is usually haskell
16:17:31 <blackdog> dabblego: absolutely, but you had to write it yourself, right?
16:17:44 <hpc> i made my website in haskell
16:17:45 <dabblego> yes, it took me much shorter time than pissing around with "existing tools"
16:17:46 <blackdog> all i'm saying is that 'batteries included' is a relative thing.
16:18:02 <dabblego> I'm saying "batteries included" often over-estimates the utility of those batteries
16:18:11 <hpc> iirc, it's ~700 lines of connecting to database, http, html, etc
16:18:22 <hpc> written with the intention of becoming a library
16:18:24 <revenantphx> ion: hpc: what the hell is that
16:18:37 <ddarius> dabblego: Screw estimating the "utility," how's 'bout the usability?
16:18:41 <chrisdb> I keep thinking about trying one or more of the Haskell web frameworks.
16:18:46 <hpc> revenantphx: mine should be obvious :P
16:18:54 <revenantphx> yours I kind of get
16:18:56 <revenantphx> his, not at all
16:18:58 <hpc> haskell for the power series of 2 :P
16:18:59 <chrisdb> My website is currently based on Django because I'm fairly comfortable with Python.
16:19:01 <dabblego> ddarius: I don't see much of a distinction
16:19:14 <ian_mi> here's quicksort in J: (($:@(<#[) , (=#[) , $:@(>#[)) ({~ ?@#)) ^: (1<#)
16:19:22 <revenantphx> ._.
16:19:32 <ion> revenantphx: Run dc and paste it to its standard input. Its output: http://johan.kiviniemi.name/stuff/dc/mandel.output
16:19:33 <hpc> i don't know how people can use array languages
16:19:40 <hpc> (APL, J, etc)
16:19:40 <ian_mi> should be obvious to any decent programmer ofc
16:19:41 <revenantphx> lol nice.
16:20:06 <jmcarthur> what gets me about those languages is all the mismatched characters :P
16:20:11 <blackdog> ian_mi: actually, once you know it's quicksort, i can sort of see the structure:)
16:20:15 <jmcarthur> or at least, that's what they look like to my untrained eyes
16:20:16 <hpc> jmcarthur: unbalanced parens!
16:20:23 <jmcarthur> yeah
16:20:29 <ddarius> dabblego: I'm saying that even if the tools are quite useful, they can be a beast to install, maintain, and upgrade, in a way that can significantly diminish the value.
16:20:39 <dabblego> ddarius: yes I agree
16:21:04 <jmcarthur> J looks like an emoticon gone completely wrong.
16:21:13 <dabblego> we need to engage our critical faculties more effectively in making these assessments
16:21:18 <chrisdb> If it is, it's the emoticon for WTF
16:21:25 <ddarius> J is a really fun language.  It's just that the "environment" is insane.
16:21:44 <shachaf> Insane how?
16:21:59 <ddarius> shachaf: What's the standard library function to display a string?
16:22:11 <frerich_> Hm, if I have a function 'f :: IO String' how could I build a list with five times the string yielded by the IO action returned by the function? Something like '[take 5 $ repeat f]' except that it misses the 'IO String -> String' part.
16:22:16 <shachaf> The REPL. :-)
16:22:29 <dabblego> frerich: you might want replicateM
16:22:35 <frerich_> err, 'take 5 $ repeat f', without the []
16:22:40 <Zao> frerich_: Do you want to perform the action 5x or duplicate the result 5x?
16:22:44 <jmcarthur> frerich_: f is just an action, not a function
16:22:56 <frerich_> Zao: I want to perform the action five times
16:23:01 <jmcarthur> :t replicateM 5
16:23:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
16:23:08 <frerich_> jmcarthur: Oh... I thought it was a function returning an action
16:23:13 <Zao> sequence_ $ replicate 5 f
16:23:17 <Zao> Err, sequence.
16:23:23 <dabblego> frerich: if you don't care about the result, then replicateM_
16:23:31 <Zao> @src replicateM
16:23:31 <lambdabot> replicateM n x = sequence (replicate n x)
16:23:59 <jmcarthur> frerich_: it's only a function if you see -> in its type
16:24:26 <frerich_> jmcarthur: Oh; I thought something like 'x :: Int' would be a function too, taking zero arguments
16:24:29 * shachaf hasn't actually used J, though he probably should.
16:24:40 <shachaf> frerich_: No -- it's just a value.
16:24:43 * Missed is confused
16:24:46 <shachaf> @google conal everything function
16:24:53 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell/
16:24:54 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
16:25:03 <Zao> a function is something on the form of  a -> b
16:25:21 <Zao> If you're going with the narrow rigid definition of some in here :)
16:25:36 <pr> @hoogle a -> b
16:25:36 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:25:36 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
16:25:36 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
16:25:45 <shachaf> Zao: You mean the normal definition?
16:25:57 <shachaf> Why does it make any sense to say that x :: Int is a function?
16:25:57 <Zao> shachaf: "normal" to most people is the C one.
16:26:06 <shachaf> Zao: Right. Integers aren't functions in C either.
16:26:09 <shachaf> Is it because of laziness?
16:26:15 <ddarius> shachaf: The issue isn't that J is missing it, it's that it's !: with 2 as the second component, a la 'hello' 1!:2 2.
16:26:20 <Zao> Int x() on the other hand, is.
16:26:22 <shachaf> Zao: Anyway, "normal" to most people in the mathematical one.
16:26:31 <ddarius> Rather, it's 1!:2
16:27:02 <shachaf> ddarius: Ah.
16:27:09 <shachaf> 2 is just a magic constant for printing, or what?
16:27:35 <shachaf> Zao: Sure, and that would be equivalent to () -> Int, or to m Int, or something like that.
16:28:10 <shachaf> I'm still not sure why you would say that "x :: Int; x = 2" is a function of zero arguments.
16:28:35 <kmc> if you think functions are the only things which delay evaluation
16:28:42 <ion> > let f = 2 in f 3  -- But everything *is* a function!
16:28:43 <lambdabot>   2
16:28:44 <chrisdb> jmcarthur: well, something like "f :: State s Int" might be considered a covert function, even though it doesn't look like it from the type you actually write. 
16:28:53 <chrisdb> There is no -> in the written type...
16:28:58 <kmc> in most languages functions have three separate roles — argument dependence, side effects, and delayed evaluation
16:29:01 <kmc> Haskell separates these roles
16:29:15 <kmc> chrisdb, that's more tricky when "State" is a synonym
16:29:16 <shachaf> chrisdb: That's an implementation detail. State is a datatype that contains a function.
16:29:26 <geheimdienst> what is argument dependence?
16:29:56 <kmc> producing output values which depend on some input values
16:30:05 <kmc> i.e. the mathematical idea of a function
16:30:09 <geheimdienst> i see
16:30:10 <chrisdb> shachaf: I know. My point was just that not having "->" in the written type doesn't mean something's a value in the normal sense of the word "value".
16:30:26 <kmc> wait, since when are functions not values?
16:30:50 <ddarius> shachaf: http://www.jsoftware.com/help/dictionary/dx001.htm  See also http://www.jsoftware.com/help/dictionary/d310n.htm This is what you use to define new "functions."
16:31:31 <chrisdb> From a C programmer's point of view?
16:31:33 <chrisdb> shachaf: "normal" to most people is the C one.
16:31:38 <chrisdb> said someone above
16:31:50 <beastaugh> it's reasonable in some contexts to consider constants as nullary functions
16:31:50 <kmc> hundreds of languages have functions as first-class values
16:32:04 <shachaf> Functions are values even from a C programmer's point of view.
16:32:04 <kmc> but we should ignore that because C and Java don't and they're *super popular*?
16:32:13 <kmc> i think Python and Ruby are super popular too
16:32:15 <ddarius> Admittedly, if you can phrase your function tacitly, you can simply assign it to a name.
16:32:51 <frerich_> I'm sorry for launching this 'what's a function' discussion, but thanks for mentioning 'replicateM', it's exactly what I needed
16:33:09 <kmc> frerich_, that kind of thing happens a lot here
16:33:19 <ddarius> What's a monad?
16:33:39 <shachaf> @quote chocolate.robots
16:33:39 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
16:33:43 <djahandarie> @quote dolio 2-category
16:33:43 <lambdabot> dolio says: Monad are just monads in the 2-category of categories.
16:34:27 <geheimdienst> monads are the things that spawn tutorials
16:34:27 <kmc> @quote analogies.*endofunctor
16:34:28 <lambdabot> dmwit says: analogies are endofunctors in the category of bad explanations
16:34:52 <djahandarie> @quote copumpkin bicategory
16:34:52 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
16:35:35 <kmc> i wonder if lambdabot uses linear regex search for these
16:36:37 <djahandarie> I wonder if there is an ugly enough regex to crash lambdabot, or make it kill something
16:36:56 <revenantphx> shachaf: "functions" are just pointers to executable memory.
16:37:09 <revenantphx> :|
16:37:11 <revenantphx> values, yep
16:37:17 <shachaf> Yes.
16:37:45 <djahandarie> Functions are values with (->) as the top-level constructor in the type.
16:38:07 <kmc> are we all in vigorous agreement
16:38:45 <revenantphx> functions are morphisms between sets.
16:38:52 * geheimdienst purrs from his spot on the window sill
16:39:00 <kmc> functions are sets of pairs
16:39:18 <frerich_> My second standalone HAskell project: a text-mode mastermind game: https://github.com/frerich/mastermind/raw/master/mastermind.hs (that's what all the questioning in the last hours was for :-)
16:39:28 <shachaf> kmc: Sets are functions to booleans.
16:39:58 <kmc> :O
16:40:44 <niteria> is there a function Int -> [a] -> [[a]], so that concat [[a]] = [a] and map length [[a]] = n ?
16:41:05 <niteria> i mean f 2 [1,3,4,5] = [[1,3], [4,5]]
16:41:13 <djahandarie> splitAt.
16:41:22 <djahandarie> > splitAt 2 [1,3,4,5]
16:41:23 <lambdabot>   ([1,3],[4,5])
16:41:30 <niteria> cool, thanks
16:41:30 <kmc> > splitAt 2 "abcdefghijk"
16:41:31 <lambdabot>   ("ab","cdefghijk")
16:41:44 <niteria> not so cool ;p
16:41:53 <kmc> the 'split' package has something for splitting a list into n-element chunks, iirc
16:42:06 <c_wraith> This is a bit different, though.
16:42:20 <djahandarie> Yeah, split isn't imported into lambdabot for whatever reason
16:42:20 <kmc> i think that's what niteria wanted
16:42:30 <djahandarie> splitEvery 2 or something
16:42:38 <niteria> f 2 [1,2,3,4,5,6] = [[1,2],[3,4],[5,6]]
16:42:46 <djahandarie> @hackage split
16:42:46 <lambdabot> http://hackage.haskell.org/package/split
16:42:46 <niteria> thats what I wanted
16:42:49 <djahandarie> niteria, see that url
16:43:03 <c_wraith> Oh.  I missed that map
16:43:04 <djahandarie> There is no function like that in prelude or base, but there is in that package.
16:43:30 <djahandarie> > splitEvery 2 [1,2,3,4,5,6,7,8]
16:43:31 <lambdabot>   Not in scope: `splitEvery'
16:43:31 <djahandarie> [[1,2],[3,4],[5,6],[7,8]]
16:43:37 <c_wraith> I've implemented strange things before.  like a foldl' + drop combination.
16:43:47 <c_wraith> fold over the dropped values.
16:44:30 <c_wraith> which is really just a partial fold, I guess
16:44:49 <niteria> ok, cool, how to get packages?
16:45:29 <c_wraith> the usual way is to use cabal-install
16:45:56 <kmc> cabal install split
16:46:31 <niteria> ok, I just couldn't find package name ;p
16:47:24 <kmc> they're listed here: http://hackage.haskell.org/packages/archive/pkg-list.html
16:47:38 <kmc> when i need a haskell package i basically do Control-F on that page with some relevant keywords
16:47:51 <dcoutts_> kmc, niteria: I've been wondering if we should make cabal install accept module names if they're not ambigious, and if they are list the packages that provide it
16:48:01 <dcoutts_> or perhaps just have cabal list search for module names too
16:48:11 <kmc> dcoutts_, i'd favor a separate 'cabal search' or whatever
16:48:13 <dcoutts_> so you could use cabal list the.module.you.want
16:48:15 <int80_h> > import System.IO
16:48:15 <int80_h> > import System.Directory
16:48:15 <int80_h> > import System.FilePath.Posix
16:48:15 <int80_h> > import Control.Applicative
16:48:15 <int80_h> > data Entry = Entry
16:48:16 <lambdabot>   <no location info>: parse error on input `import'
16:48:16 <lambdabot>   <no location info>: parse error on input `import'
16:48:16 <lambdabot>   <no location info>: parse error on input `import'
16:48:16 <lambdabot>   <no location info>: parse error on input `import'
16:48:16 <lambdabot>   <no location info>: parse error on input `data'
16:48:18 <int80_h> >       { entryTitle :: String
16:48:19 <lambdabot>   <no location info>: parse error on input `{'
16:48:21 <int80_h> >       , entrySlug :: String -- ^ used in the URL
16:48:21 <lambdabot>   <no location info>: parse error on input `,'
16:48:23 <int80_h> >       , entryContent :: IO String
16:48:24 <lambdabot>   <no location info>: parse error on input `,'
16:48:26 <int80_h> >       }
16:48:26 <lambdabot>   <no location info>: parse error on input `}'
16:48:28 <int80_h> > loadEntries :: IO [Entry]
16:48:29 <lambdabot>   Not in scope: type constructor or class `Entry'Not in scope: `loadEntries'
16:48:30 --- mode: ChanServ set +o monochrom
16:48:31 <int80_h> > loadEntries = do
16:48:31 <lambdabot>   <no location info>: parse error on input `='
16:48:33 <int80_h> >  let directoryPath = "/home/mlitchard/playground/webTests/files"
16:48:33 <niteria> first thing I tried was cabal install Data.List.Split
16:48:34 <lambdabot>   not an expression: `let directoryPath = "/home/mlitchard/playground/webTest...
16:48:36 <int80_h> >  let processedPath = map (directoryPath </>) . filter (`notElem` [".",".."])
16:48:36 <lambdabot>   not an expression: `let processedPath = map (directoryPath </>) . filter (`...
16:48:38 <int80_h> >  entryFileNames <- processedPath <$> getDirectoryContents directoryPath
16:48:39 <lambdabot>   not an expression: `entryFileNames <- processedPath <$> getDirectoryContent...
16:48:39 --- mode: monochrom set +q int80_h!*@*
16:48:55 <geheimdienst> monochrom, thanks
16:48:58 <DevHC> olololololo
16:48:59 <dcoutts_> niteria: right, I think lots of new users get modules and packages confused
16:49:13 <dcoutts_> niteria: so perhaps instead of educating them, we just make it work :-)
16:49:15 <ddarius> monochrom: It would probably be easier to just kick him so he can rejoin.
16:49:32 --- mode: monochrom set -q int80_h!*@*
16:49:36 --- mode: monochrom set -o monochrom
16:49:44 <int80_h> http://hpaste.org/45007/problems_with_io_actions
16:49:47 <int80_h> sorry about that
16:49:56 <monochrom> hehehe
16:49:57 <dcoutts_> kmc: so I accept we should have a better search, but do you think it'd be actively bad to have cabal install Data.List.Split just work (or prompt in case of ambiguity) ?
16:49:58 <int80_h> the above is what I meant to paste
16:50:10 <kmc> dcoutts_, kind of, yeah.  it will encourage said confusion
16:50:50 <kmc> int80_h, "mapM readFile" will read each file and give you [String]
16:51:03 <kmc> "map readFile" will do no IO and give you [IO String]
16:51:15 <kmc> which sounds like what you want
16:51:43 <kmc> (to be precise i should say "mapM readFile" returns an IO action that produces [String], whereas "map readFile" returns a list of IO actions)
16:51:58 <int80_h> kmc: ah yes. I tried "map readFile" but I was getting errors, due to not being able to use show. I took that to mean I was on the wrong track. Didn't think too carefully about the error.
16:52:07 <dcoutts_> kmc: perhaps we can try and reduce that by having the message clearly say: "installing package foo, which provides the module Data.Foo"
16:52:07 <kmc> int80_h, you can't show an IO String
16:52:18 <kmc> dcoutts_, do people ever read the output of a successful command
16:52:27 <int80_h> kmc: I know, ghci assumes you automatically want to I guess.
16:52:46 <kmc> when you type an IO action at GHCi's prompt, it will execute the action and show the result
16:52:52 <dcoutts_> kmc: or if we think the confusion danger is really bad, to have it not actually do it and instead to list the package that provides it so you can cabal install
16:52:57 <kmc> dcoutts_, in my experience they don't even read the output of a failed command ;)
16:53:04 <kmc> that seems ok to me
16:53:04 <dcoutts_> kmc: true
16:53:17 <geheimdienst> kmc is a command-line nihilist
16:53:19 <dcoutts_> kmc: I'm tempted to make it work, and try and make the messages clear
16:53:38 <kmc> i guess ghc itself already has magical module → package behavior
16:53:52 <dcoutts_> kmc: I also want to use colours in the cabal output to make people read it :-)
16:53:53 <kmc> i wonder about an alternate Haskell universe where package-qualified imports are the norm
16:54:02 <kmc> dcoutts_, you should use the "blink" attribute too
16:54:07 <dcoutts_> ;-)
16:54:19 <ddarius> kmc: You just move the problem around.
16:54:27 <dcoutts_> gentoo's emerge tool has I think reasonably tasteful colour console output
16:54:39 <geheimdienst> dcoutts_, why not pull cat pictures from the internet and display cabal's output in bold white letters on them
16:54:40 <dcoutts_> like coloured * bullet points for notice, warning and error
16:54:52 <dcoutts_> geheimdienst: tricky in an xterm window
16:55:05 <kmc> int80_h, btw i sometimes find it useful to define newtypes in order to use "deriving Show" on another type
16:55:08 <ddarius> @hackage haha
16:55:08 <lambdabot> http://hackage.haskell.org/package/haha
16:55:14 <dcoutts_> geheimdienst: but I'll keep your suggestion in mind
16:55:25 <dcoutts_> cabal can has error?
16:55:28 <int80_h> kmc: could you post an example of that technique?
16:55:48 <kmc> i.e. data Val = VInt Int | VChar Char | VFun Fun deriving (Show); newtype Fun = Fun ([Val] -> Val); instance Show Fun where { show _ = "<fun>" }
16:56:12 <kmc> basically encapsulate the part that can't be derived and provide your own instance for just that
16:56:13 * ddarius sees a need for someone to combine the pony and haha packages.
16:56:26 <int80_h> kmc: thanks!
16:56:46 <kmc> at the expense of additional wrapping
16:56:48 <DevHC> int80_h: entries <- ((processedPath <$> getDirectoryContents directoryPath)  >>= mapM readFile entryFileNames >>= return . map stringToEntry)
16:56:59 <kmc> (but this is syntactic only, not a run-time expense, because of how most compilers will implement "newtype")
16:57:32 <kmc> i'm just glad that both "berp" and "derp" are Hackage packages
16:57:39 <kmc> i should contrive some way to depend on both
16:58:24 <int80_h> oh, "berp" gets a package, but not "herp"? That's discrimination maaan!
16:58:52 <monochrom> what about zerp?
16:58:52 <kmc> upload one!
16:59:26 <tengen> does ghci not interpret LANGUAGE pragmas?
16:59:27 <ddarius> @fresh
16:59:27 <lambdabot> Hadz
16:59:35 <ddarius> We haven't gotten to the e's yet.
17:00:43 <tengen> I have LANGUAGE OverloadedStrings in my file, but when I load the file in ghci, I still need to type :set -XOverloadedStrings to turn the extension on
17:00:51 <monochrom> there is also http://hackage.haskell.org/package/fst but not snd.
17:00:53 <MHD0> What kind of Arrow based utilities are out there?
17:01:18 <kmc> like so? {-# LANGUAGE OverloadedStrings #-}
17:01:20 <kmc> on the first line?
17:01:31 <tengen> kmc: yes. that's what I meant
17:02:16 * monochrom uploads "the 'last' package": "The last package was uploaded for the first time, half in jest, on May 21, 2061..." http://www.multivax.com/last_question.html
17:02:29 <djahandarie> Build-depends: herp, derp
17:02:31 <kmc> :D
17:03:11 <monochrom> "And AC said, 'let there be cabal'..."
17:03:18 <djahandarie> lol
17:16:24 <DevHC> halp! how do i @unlet (revert @let)?
17:17:51 <Rob> Does ghc's -is-main option work?  I tried `ghc -o TestPlugs  -main-is Test Test.hs' but get undefined symbol: ___stginit_ZCMain (and one other).
17:18:08 <Rob> oops I mean "-main-is"
17:18:13 <copumpkin> I've noticed that on windows too
17:18:18 <copumpkin> you on windows?
17:18:24 <DevHC> i've made bogus @lets for all lowercase identifiers of length 1 and 2, in an attempt to troll lambdabot here, but apparently lambdabot remembers @lets per "channel" D:
17:18:26 <Rob> Mac OS X
17:18:36 <copumpkin> Rob: hmm, might be worth submitting a bug report
17:18:38 <copumpkin> or asking in #ghc
17:19:08 <Rob> Okay, thanks.
17:19:28 <DevHC> Rob: as a workaround, try using "module MyModule" at the beginning of the file?
17:19:29 <kmc> @clear
17:19:29 <lambdabot> Messages cleared.
17:19:32 <kmc> hrm
17:19:49 <kmc> @undefine
17:20:15 <geheimdienst> aren't linker symbol errors sometimes a sign of a forgotten --make switch ...?
17:20:27 <kmc> often
17:21:01 <geheimdienst> rob: ^^
17:21:01 <kmc> that's an unusual symbol for such though
17:21:01 <DevHC> @let a = 1
17:21:01 <lambdabot>  Defined.
17:21:01 <DevHC> > a
17:21:01 <lambdabot>   Ambiguous occurrence `a'
17:21:01 <lambdabot>  It could refer to either `L.a', defined at <local...
17:21:01 <DevHC> @clear
17:21:01 <lambdabot> Messages cleared.
17:21:01 <DevHC> > a
17:21:01 <lambdabot>   Ambiguous occurrence `a'
17:21:01 <lambdabot>  It could refer to either `L.a', defined at <local...
17:21:01 <kmc> @undef
17:21:01 <DevHC> > c
17:21:01 <lambdabot>   c
17:21:10 <DevHC> nope, "a" is still trolling #haskell
17:21:12 <Rob> I don't know.
17:21:15 <DevHC> > map (<3)
17:21:16 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [GHC.Bool.Bool])
17:21:16 <lambdabot>    arising...
17:21:30 <kmc> > let (♥) = (<3) in map (♥)
17:21:31 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [GHC.Bool.Bool])
17:21:31 <lambdabot>    arising...
17:21:35 <kmc> :t let (♥) = (<3) in map (♥)
17:21:36 <lambdabot> parse error (possibly incorrect indentation)
17:21:39 <Rob> I'm trying DevHC's advice.
17:21:41 <niteria> is there a function to rotate a list?
17:21:49 <kmc> > cycle "abcdef"
17:21:50 <lambdabot>   "abcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefabcdefab...
17:21:50 <niteria> [1,2,3,4] -> [2,3,4,1]
17:21:51 <geheimdienst> rob, i meant you should try saying "ghc --make" ...
17:21:57 <kmc> > take 6 . drop 2 $ cycle "abcdef"
17:21:58 <lambdabot>   "cdefab"
17:23:52 <niteria> ok, thx
17:25:34 <Rob> geheimdienst: the --make works, but now the other way is too.  Sorry, I must have had a stray object lying around.  
17:25:47 <kmc> ghc -fforce-recomp will usually avoid stale-object problems
17:25:52 <kmc> but i'm not sure why that would matter without --make
17:26:39 <ddarius> > generalCategory '♥'
17:26:40 <lambdabot>   OtherSymbol
17:26:59 <Rob> Wow.  A 58 MB executable from a 10 line test program.
17:27:05 <kmc> haha
17:27:06 <geheimdienst> > generalCategoryTheory '♥'
17:27:07 <lambdabot>   Not in scope: `generalCategoryTheory'
17:27:26 <Rob> Maybe that's the System.Plugins stuff.  Or maybe they're always that big.  I've been using runhaskell.
17:27:37 <kmc> ghc produces pretty big binaries
17:27:40 <ddarius> > let ♥ = (<3) in map ♥ [1..10]
17:27:40 <lambdabot>   <no location info>: parse error on input `
17:27:46 <kmc> it statically links all Haskell code by default
17:27:53 <Rob> Oh, okay.
17:27:57 <Rob> Good to know.
17:28:07 <kmc> and the 'plugins' package depends on the 'ghc' package
17:28:18 <kmc> which means your executable basically contains a full copy of GHC
17:28:45 <Rob> Is there a flag to use dynamic linking of some kind, at least for development?
17:28:54 <Rob> It took a while to link it.
17:28:57 <kmc> yes, but i haven't tried it -- it's semi-experimental
17:28:57 <ion> -dynamic
17:29:06 <kmc> you might link faster with 'gold' instead of GNU ld or whatever else
17:30:35 <ion> Couldn’t unreferenced symbols be pruned out of a statically linked executable? Wouldn’t that also have the equivalent effect as -split-objs?
17:31:10 <kmc> not really; you don't know what refers to those symbols internally
17:31:16 <kmc> you can drop unused *sections*
17:31:35 <DevHC> i smell WPA...
17:31:48 <kmc> if you're feeling adventurous, ghc -fvia-C -optc-ffunction-sections
17:31:51 <kmc> i do not expect this to work
17:31:53 <kmc> WPA?
17:32:09 <geheimdienst> whole-program analysis
17:33:15 <pastorn> freedrull: hello
17:33:18 <Rob> Added the -dynamic flag and it complained that it couldn't find System.Plugins.  I'm too new to Haskell for this... a project for another day.
17:33:28 <freedrull> pastorn: hi
17:33:39 <kmc> Rob, you probably need to install 'plugins' with dynamic linking somehow
17:33:40 <pastorn> freedrull: how's the musicing going?
17:34:40 <Rob> An option to cabal install?
17:34:41 <freedrull> pastorn: well i finished this program for extracting lyrics from midi files, and calculating their duration...
17:34:54 <freedrull> pastorn: havn't really done much with haskell and audio yet though
17:35:08 <pastorn> ok :)
17:35:15 <freedrull> did you make anything?
17:35:20 <pastorn> then it can only get better :D
17:35:30 <pastorn> freedrull: nah, busy working on my assembler
17:35:35 <kmc> Rob, i guess so.  i haven't done this
17:35:49 <freedrull> pastorn: ohh....in haskell? what cpu?
17:36:02 <pastorn> freedrull: Interdata 16E
17:36:05 <pastorn> from 1978
17:36:21 <Rob> kmc: I do see an -enable-shared.  I'll try it later.  Thanks.
17:36:24 <freedrull> woah, never heard of it :3
17:36:34 <pastorn> freedrull: the assembler is really weird
17:36:56 <DevHC> Rob: did u really specify -main-is Test (not -main-is test)?
17:37:08 <freedrull> i have a 6502 assembler in haskell that i never finished...
17:37:19 <pastorn> freedrull: oh, cool
17:37:30 <pastorn> what were you planning to use it for? C64 or NES?
17:37:57 <kmc> i started writing an AVR disassembler for no clear reason
17:38:04 <freedrull> pastorn: c64
17:38:15 <pastorn> kmc: AVR = ATMega?
17:38:17 * ddarius wrote a 6502 emulator many years ago in x86 assembly.
17:38:23 <freedrull> maybe nes too..
17:39:05 <Rob> DevHC: Yes I did.  I'm trying to reproduce the original error now.
17:39:54 <DevHC> u should provide a name of a function after -main-is
17:40:10 <DevHC> functin of type IO ()
17:40:29 <Rob> Got it.  If I run `ghc -o TestPlugs Test.hs'  it complains that there is no main module.  But it has compiled Test.o.  Then if I had the `-main-is Test' I get my error.
17:40:37 <kmc> <pedantic>that's not a function</pedantic>
17:40:54 <Rob> s/had/add/
17:41:44 <Rob> Get the error with or without --make.
17:42:11 <DevHC> Rob: if u have
17:42:14 <DevHC> test :: IO ()
17:42:21 <DevHC> in ur code, then use: -main-is test
17:42:30 <DevHC> note, if u have
17:42:48 <DevHC> data A = Test | Bla
17:43:34 <Rob> My modules name is "Test" so I want the capital 'T'.
17:43:35 <DevHC> in ur code, it can be seen that providing an initially-upper-cased name after -main-is is an error
17:43:50 <ddarius> "Banjolele"
17:44:03 <DevHC> what does -main-is have to do with modules?
17:44:38 <Rob> According to the ghc docs: http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/options-phases.html
17:44:38 <DevHC> (rly, i dunno)
17:44:55 <Rob> You tell it what to use as the main function.
17:45:06 <Rob> You can give it the module name, function name or both.
17:45:17 <kmc> it's not a function, it's an IO action
17:45:29 <Rob> Yes, IO action.
17:45:55 <Rob> You see my non-haskell habits.
17:46:23 <DevHC> hmm
17:46:27 <DevHC> and u have main :: IO () in Test.hs?
17:47:40 <monochrom> I have no problem referring to main as a function.
17:48:56 <monochrom> It is in the same sense as: the empress dowager tells the empress, "you must not forget your primary function: to produce a heir!"
17:49:28 <kmc> yes :)
17:51:22 <kmc> gcc does not require that main is a function ;)
17:52:02 <theorbtwo> int main = 0xF00F; // muck up Pentiums.
17:52:30 <pastorn> lolwat?
17:52:37 <pastorn> what will happend with that?
17:52:58 <pastorn> theorbtwo: ??
17:53:18 <theorbtwo> pastorn: It will freeze, hard, certian Intel CPUs, unless the OS has a work-around.
17:53:24 <theorbtwo> (All major OSes do now.)
17:53:31 <pastorn> hehe, awesome
17:53:38 <pastorn> so it's an illegal instruction?
17:54:03 <kmc> an illegal instruction that the CPU fails to handle properly
17:54:14 <kmc> it's actually F0 0F C7 C8
17:54:23 <kmc> i.e. 0xC8C70FF0, this being Intel
17:54:39 <kmc> lock cmpxchg8b eax
17:54:40 <pastorn> kmc: that is... little endian?
17:54:52 <kmc> yeah
17:55:02 <pastorn> wait, little endian in little endian
17:55:12 <pastorn> tiny endian
17:55:14 <kmc> what
17:55:34 <pastorn> it flips the places for each two words, and for each four words
17:55:41 <pastorn> (words = bytes)
17:55:50 <kmc> no
17:55:54 <kmc> it's just the reverse
17:56:11 <kmc> http://drdobbs.com/architecture-and-design/184410555
17:57:16 <kmc> if you dig in the Linux source code you will find their workaround for this bug
17:57:48 <pastorn> kmc: i can't say that i have much inclination to do so
17:58:35 <Rob> DevHC: yes I have main :: IO () in Test.hs.  Everything works.  I just need to delete the Test.o so it recompiles it when I give ghc the -main-is flag.
17:58:51 <kmc> fine pastorn ;P
17:58:54 <kmc> http://lxr.linux.no/linux+v2.6.38/arch/x86/kernel/cpu/intel.c#L155
17:59:07 <kmc> and http://lxr.linux.no/linux+v2.6.38/arch/x86/mm/fault.c#L541
18:01:20 <bitwiseshiftleft> question for the room
18:01:35 <bitwiseshiftleft> I'm working on a dsl that involves a lot of string manipulation
18:01:51 <bitwiseshiftleft> with a monad called C
18:02:16 <pastorn> cool
18:02:27 <bitwiseshiftleft> so i've added an IsString instance for C (), so that I can write "foo" as a line in a do block
18:02:31 <pastorn> string manipulation is generally pretty annoying in haskell
18:02:35 <bitwiseshiftleft> yep
18:02:58 <pastorn> bitwiseshiftleft: your string resides in state?
18:03:10 <bitwiseshiftleft> no, it's for constructing strings
18:03:15 <bitwiseshiftleft> so it's getting printed
18:03:24 <bitwiseshiftleft> but anyway, i'd kind of like to be able to write "foo" bar "baz", where bar is some string variable
18:03:31 <pastorn> shouldn't it be 'C Str' then?
18:03:51 <bitwiseshiftleft> oh, sorry
18:03:53 <pastorn> not C ()
18:03:54 <bitwiseshiftleft> yeah, it's state
18:03:58 <bitwiseshiftleft> so it's C ()
18:04:00 <pastorn> ok
18:04:04 <kmc> bitwiseshiftleft, you probably can't make that work nicely
18:04:07 <bitwiseshiftleft> actually, C a, because i think the type system complains otherwise
18:04:12 <bitwiseshiftleft> kmc why not?
18:04:20 <kmc> overloading strings to be functions is likely to be a mess
18:04:24 <pastorn> kmc: yes he can, look at attoparsec
18:04:26 <kmc> have you considered making a quasiquoter instead
18:04:27 <ion> kmc: Thanks for the links. Good insight into the F00F bug. :-)
18:04:36 <kmc> attoparsec lets you write «"foo" bar "baz"» ?
18:04:58 <bitwiseshiftleft> hm.  i should check out a quasiquoter, but i'm not familiar with th yet, so i'd rather avoid it
18:05:02 <bitwiseshiftleft> for now
18:05:05 <kmc> is that really so much better than «cat ["foo", bar, "baz"]»
18:05:17 <kmc> Haskell is not the best language for syntactic flexibility
18:05:27 <niteria> $! is just strict version of $ ?
18:05:29 <bitwiseshiftleft> marginally, yes.  also, bar might be some show instance instead of a string, and then i can't cat them
18:05:31 <kmc> @src ($!)
18:05:31 <lambdabot> f $! x = x `seq` f x
18:05:32 <bitwiseshiftleft> niteria: yes
18:06:06 <niteria> can I measure time somehow from ghci?
18:06:18 <kmc> :set +s
18:06:29 <bitwiseshiftleft> so, i can actually write an IsString instance for eg String -> String -> C ()
18:06:29 <kmc> ($!) is strict in its second arg, and incidentally its first
18:06:51 <kmc> bitwiseshiftleft, http://hackage.haskell.org/packages/archive/haskell-src-meta-mwotton/0.1.0/doc/html/src/Language-Haskell-Meta-QQ-HsHere.html will let you write things like
18:07:06 <kmc> [here| two plus two is $(2 + 2) |]
18:07:10 <kmc> evaluates to "two plus two is 4"
18:07:26 <kmc> good luck finding docs or understanding that module, though
18:07:32 <bitwiseshiftleft> hm.
18:07:40 <kmc> QQ described at http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/template-haskell.html#th-quasiquotation
18:07:51 <bitwiseshiftleft> i guess that's about what i want...
18:14:26 <bitwiseshiftleft> well, thanks for the help, guys!
18:29:15 <ezrak1lty> This error from cabal install perplexes me: "base-3.0.3.1 was excluded because of the top level dependency base -any"
18:32:13 <ezrak1lty> Seems like base -any would permit base-3.0.3.1, or am I misreading it?
18:34:14 <monochrom> you should examine a lot more information such as "ghc -v", "ghc-pkg list -v", and the full output of your "cabal install <I don't know what you put here>"
18:35:34 <ezrak1lty> OK, "ghc-pkg list -v" shows that base-4.3.1 is installed, which conflicts with another message I got from cabal:
18:36:01 <ezrak1lty> cabal: cannot configure HDBC-mysql-0.6.3. It requires base >=2 && <4
18:36:25 <ezrak1lty> Is ghc-pkg capable of letting two versions of a package coexist?
18:36:39 <monochrom> yes but base-3 is obsoleted.
18:37:14 <ezrak1lty> What should I make of the fact that the latest hdbc-mysql seems to have that dependency?
18:37:23 <ezrak1lty> is it just not compatible with my new install of GHC-7?
18:38:10 <monochrom> I have never used HDBC-mysql, so I don't know how incompatible it is.
18:40:03 <ezrak1lty> OK, but I take it it's a possibility, that upgrading my compiler has scuppered some packages I used to use. . . 
18:40:53 <pastorn> ezrak1lty: a good idea with any new install of ghc is rm -rf ~/.cabal ~/.ghc
18:41:21 <monochrom> that is unnecessary and doesn't change anything.
18:41:52 <ezrak1lty> I would expect cabal to sensibly track the versions and not to confuse itself with older installations...
18:41:58 <monochrom> carefully examine the contents of ~/.ghc to see why
18:42:50 <ezrak1lty> (Or, I suppose that is the database for ghc-pkg rather than cabal.)
18:43:04 <monochrom> well OTOH if you have at most one version of ghc at all times, you could do that to regain disk space.
18:43:30 <monochrom> like you are not buying a bigger hard disk in the next 10 years.
18:43:47 <ezrak1lty> Can I expect multiple ghc versions to coexist without screwing each other up? Seems like it works alright.
18:43:56 <monochrom> yes
18:45:14 <monochrom> I use different --prefix's for different versions, but even if you don't do that, look into /usr/local/bin (say) to see why they can coexist to a very large extent.
18:45:54 <ezrak1lty> OK
18:46:12 <ezrak1lty> Well, I see that hdbc-mysql is listed with a ghc-7 build failure on Hackage, so that explains that.
19:00:44 <augur> @hoogle (|||)
19:00:44 <lambdabot> Control.Arrow (|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
19:00:53 <augur> @where (|||)
19:00:53 <lambdabot> I know nothing about (|||).
19:00:55 <augur> :|
19:15:53 <pr> @type (&&&)
19:15:54 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:16:46 <djahandarie> augur, it's in Control.Arrow with all the other arrow stuff
19:16:52 <djahandarie> @hoogle (|||)
19:16:52 <lambdabot> Control.Arrow (|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
19:17:09 <augur> djahandarie: i was lazy and wanted a link :P
19:17:33 <ddarius> @source Control.Arrow
19:17:33 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
19:25:44 <osoleve> :t interact
19:25:45 <lambdabot> (String -> String) -> IO ()
19:30:54 <manateeUser> Hi all. :)
19:31:13 <sm> hello manateeUser 
19:31:17 <parcs> what is interact supposed to do?
19:31:23 <manateeUser> Hello, sm.
19:31:31 <applicative> interact is wonderful
19:31:42 <parcs> iteract f = putStrLn . f =<< getLine, i assume?
19:32:00 <kmc> well, ever notice that UNIX pipelines are like composition of functions String -> String?
19:32:04 <manateeUser> sm, you recently how ah?
19:32:07 <applicative> it is said to be the original haskell IO 
19:32:27 <kmc> interact lets you turn a Haskell function into a pipeline-able binary in one line of code
19:32:33 <roconnor> @src interact
19:32:33 <lambdabot> interact f = do s <- getContents; putStr (f s)
19:32:34 <applicative> as kmc says, basically it takes a pure function and makes a pipeable executable
19:32:39 <sm> I'm good recently, and yourself ? any time for haskell hacking ?
19:32:48 <applicative> kmc is moving too fast for me
19:32:55 <kmc> i know kung foo
19:33:11 * kmc vanishes in a puff of smoke
19:33:57 <applicative> parcs, there is also Data.ByteString.interact, and one for Data.Text
19:34:01 <manateeUser> sm: Not much, I'm busy on My own Linux version.
19:34:11 <manateeUser> sm: Write many Python code recently.
19:34:37 <sm> nice
19:34:42 <manateeUser> sm: Manatee still in developing, but much slow than before.
19:34:57 <manateeUser> sm: Haven't so much time， you know, i need work for live.
19:35:04 <sm> yup
19:35:17 <manateeUser> sm: BTW, "you recently how ah" translated by Google, not so good. :)
19:36:49 <sm> I hope I got it right :)
19:37:19 * sm had better get off computer.. long day
19:37:34 <sm> good luck manateeUser , all
19:44:41 <Kaidelong> I need documentation for Yampa and am struggling to find any
19:44:49 <Kaidelong> if I am going to learn and use it anyway
19:44:59 <Kaidelong> I think I get the basic ideas but...
19:46:05 <Kaidelong> well if I know the meaning of the types "Signal a" and "SF a b" and "Event a" then am I fine and should just play with it?
20:00:13 <int80_h> http://hpaste.org/45009/type_signatures_in_ghci
20:01:59 <ourfrank> How would I use template haskell to generate something like "''double", without outside quotes?
20:02:10 <ourfrank> Edit: "''Double".
20:03:53 <int80_h> http://hpaste.org/45009/type_signatures_in_ghci
20:06:49 <applicative> int80_h: :set -XNoMonomorphismRestriction ?
20:07:03 <int80_h> applicative: I'll try that
20:07:40 <int80_h> applicative: can you tell me why that solves the problem?
20:07:52 <int80_h> it did, I just don't know why.
20:10:09 <applicative> it couldn't tell what monad you were working with, and couldn't find anything to default to
20:11:06 <applicative> try something simpler like "let op = (+)" with and without :set -XNoMono...
20:11:38 <int80_h> applicative: I'm trying to treat testliftIO as a string, but it seems it's type is not synonymous with String. Could you tell me what testliftIO :: (Control.Monad.IO.Class.MonadIO m) => m String
20:11:44 <sshc> ourfrank: ''Float  is like ''Double
20:11:53 <int80_h> er tell me what the above signature says?
20:13:22 <applicative> Oh, it's just " let op a b = a + b"  type inference will go differently with and without -XNoMonomorphismRestriction
20:14:19 <int80_h> applicative: I mistimed my statement. I was looking for an explaination of testliftIO :: (Control.Monad.IO.Class.MonadIO m) => m String
20:14:40 <applicative> it's a string in ANY monad
20:14:43 <helgikrs> int80_h: it tells you that it returns a String in any monad that can be lifted to IO
20:14:55 <BMeph_> In any MonadIO monad. ;)
20:15:01 <int80_h> ah, I'm misusing liftIO
20:15:12 <applicative> like BMeph_ says
20:15:57 <applicative> int80_h: with the monomorphism restriction on, ghci didn't want to infer such an 'ambiguous' type, to put it crudely and thus in accordance with my understanding
20:17:42 <rndm> does anyone have a good example of a smallish statically typed compiler (for an object oriented language) written in haskell?
20:17:44 <int80_h> see, I have a [IO String]. In ghci I can do head testIO and it will do the action I want. But I think that wouldn't work in a compiled program. I would need to do something to that [IO String] before using head on it. I thought that the thing I needed to do was liftIO. I htink that's wrong now.
20:18:09 <c_wraith> int80_h: let the types be your guide.
20:18:10 <helgikrs> @type sequence
20:18:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:18:19 <Zao> > head [print "lol", print "wtf"]
20:18:20 <lambdabot>   <IO ()>
20:18:38 <kmc> int80_h, you can write "head xs" in an IO do-block
20:18:42 <Zao> Applying head to a list of things gives you the first thing in the list of things.
20:18:47 <kmc> or «head xs >> putStr "done"»
20:19:09 <kmc> or «head xs >>= \y -> putStr ("got: " ++ y)»
20:19:25 <kmc> which is the same as «do { y <- head xs; putStr ("got: " ++ y) }»
20:19:39 <kmc> remember, IO-actions are values like any other
20:19:41 <int80_h> kmc: I am getting strange characters when you typed. could you paste whatever you just did?
20:19:55 <kmc> these? «»
20:20:00 <int80_h> kmc: yup
20:20:06 <applicative> kmc is putting french quotes around inline code
20:20:11 <kmc> those are guillemets
20:20:21 <shachaf> Compose < <?
20:20:25 <int80_h> frenchifying my haskell lecture!
20:20:26 <ion> a.k.a. double angle quotation marks
20:20:26 <kmc> yep
20:20:52 <kmc> they're not used by Haskell syntax (and can't be defined as operators), therefore they're safe to use to quote code in text without ambiguity
20:21:07 <kmc> http://hpaste.org/45010/for_int80_h
20:21:10 <shachaf> They can't be defined as operators?
20:21:15 <int80_h> aw thanks
20:21:17 <kmc> don't think so.  wrong Unicode class
20:21:25 <kmc> :t let («) = (<) in («)
20:21:25 <lambdabot> parse error (possibly incorrect indentation)
20:21:30 <kmc> actually, :t doesn't like unicode anyway
20:21:34 <kmc> > let («) = (<) in 2 « 3
20:21:35 <lambdabot>   <no location info>: lexical error at character '\171'
20:21:46 <kmc> int80_h, is your client set up for UTF-8?
20:21:59 <kmc> > generalCategory '«'
20:21:59 <lambdabot>   InitialQuote
20:22:02 <helgikrs> @let («) = (<)
20:22:02 <lambdabot>  <local>:1:1: lexical error at character '\171'
20:22:02 <kmc> > generalCategory '»'
20:22:03 <lambdabot>   FinalQuote
20:22:12 <kmc> > generalCategory '`'
20:22:13 <lambdabot>   ModifierSymbol
20:22:23 <kmc> > generalCategory '\0'
20:22:23 <lambdabot>   Control
20:22:26 <shachaf> > generalCategory '\\'
20:22:27 <lambdabot>   OtherPunctuation
20:22:28 <shachaf> > generalCategory 'a'
20:22:29 <lambdabot>   LowercaseLetter
20:22:34 <int80_h> kmc: I am thinking it's not
20:22:35 <kmc> > generalCategory '☭'
20:22:36 <lambdabot>   OtherSymbol
20:22:41 <helgikrs> @hoogle generalCategory
20:22:41 <lambdabot> Data.Char generalCategory :: Char -> GeneralCategory
20:22:41 <lambdabot> Data.Char data GeneralCategory
20:22:45 <int80_h> I'm running irssi in putty
20:22:49 <kmc> ok
20:22:55 <kmc> well anyway, i hope my code examples are useful
20:23:02 <int80_h> they always are :)
20:23:19 <kmc> it helps to think of Haskell programs as merely describing IO rather than performing it
20:23:35 <ion> You should configure PuTTY to use UTF-8. (But you should also run Irssi with UTF-8 locales to avoid a charset mismatch.)
20:23:44 <int80_h> I'm pretty sure you helped me with this problem the first time I had it. Unfortunately I can't find the results of that session. So I have to start this over and figure it out from the begining.
20:23:47 <shachaf> And run screen with -U. If you use screen.
20:23:52 <kmc> (>>=) is the fundamental operator for gluing two descriptions together
20:24:00 <ion> shachaf: That should be automatic if the locale settings are correct.
20:24:14 <djahandarie> kmc, what if I start unsafely performing IO
20:24:21 <kmc> djahandarie, heretic!
20:24:28 <kmc> burn him at the stake
20:24:32 <shachaf> Heresy is encouraged.
20:24:32 <djahandarie> :(
20:24:33 <int80_h> also, apostate!
20:24:36 <applicative> let him be anathema
20:24:47 <kmc> renegade!
20:24:49 * djahandarie notes to not mention that again
20:24:56 <shachaf> Evil one!
20:24:59 <kmc> "no! no! i do not want to go to second level with you!"
20:25:00 <ion> @faq should djahandarie use unsafePerformIO?
20:25:00 <lambdabot> The answer is: Yes! Haskell can do that.
20:25:21 <kmc> @faq Can Haskell create an IO so unsafe that even it cannot perform it?
20:25:21 <lambdabot> The answer is: Yes! Haskell can do that.
20:26:01 <shachaf> All IO is equally unsafe.
20:26:16 <kmc> let safePerformIO = unsafePerformIO . return
20:26:41 <djahandarie> I don't think that has a useful type signature..
20:26:52 <kmc> are you saying the identity function isn't useful?!?
20:27:01 <kmc> not to be confused with return . unsafePerformIO
20:27:08 <shachaf> > unsafеPerformIO (return 5)
20:27:10 <lambdabot>   5
20:27:13 <kmc> :O
20:27:18 <kmc> :t unsafePerformIO
20:27:18 <lambdabot> Not in scope: `unsafePerformIO'
20:27:27 <applicative> how did that happen??
20:27:28 <copumpkin> is return . unsafePerformIO :: IO a -> IO a safe? :o
20:27:36 <copumpkin> one of those unicode hax I'd guess
20:27:42 <c_wraith> copumpkin: it's essentially unsafeInterleaveIO
20:27:42 <kmc> copumpkin, that's unsafeInterleaveIO
20:27:45 <copumpkin> or someone undefined it in PM quickly
20:27:49 <kmc> so, no ;P
20:27:53 <copumpkin> pff
20:27:58 <copumpkin> unsafeInterlaveIO is very safe
20:28:03 <kmc> fix (return . unsafePerformIO)
20:28:10 <shachaf> unsafeInterleaveIO is evil.
20:28:26 <kmc> unsafeInterleaveIO is chaotic neutral
20:28:32 <djahandarie> kmc, that actually executed
20:28:34 <c_wraith> with emphasis on the chaotic
20:28:53 <kmc> surpriseMeIO
20:28:56 <applicative> > unsaf?PerformIO (return 5)
20:28:57 <lambdabot>   Not in scope: `unsaf'Not in scope: data constructor `PerformIO'Not in scope...
20:29:03 <applicative> > unsafePerformIO (return 5)
20:29:04 <lambdabot>   Not in scope: `unsafePerformIO'
20:29:15 <applicative> now I feel better
20:29:33 <ion> > unsafePerformIO (return 5)
20:29:34 <lambdabot>   Ambiguous type variable `m' in the constraint:
20:29:34 <lambdabot>    `GHC.Base.Monad m'
20:29:34 <lambdabot>      a...
20:29:52 <helgikrs> o.O
20:29:54 <ion> Feel free to point at me and laugh.
20:30:06 <kmc> unsafe at any speed
20:30:08 <applicative> It can't be safe, lambabot can't maintain referential transparency with it
20:30:26 <shachaf> > unsafePerformIO (return 5)
20:30:28 <lambdabot>   5
20:30:28 <shachaf> > unsafePerformIO (return 3)
20:30:30 <lambdabot>   3
20:30:39 <kmc> > "unsafePerformIO"
20:30:39 <lambdabot>   "unsafePerformIO"
20:30:49 <helgikrs> > unsafePerformIO (print 3)
20:30:50 <lambdabot>   Couldn't match expected type `Data.Functor.Identity.Identity a'
20:30:50 <lambdabot>         aga...
20:30:50 <shachaf> > "kmc"
20:30:51 <lambdabot>   "kmc"
20:31:18 <kmc> :t unsafePerformIO
20:31:18 <lambdabot> forall a. Identity a -> a
20:31:28 <applicative> aha
20:31:40 <shachaf> Pah.
20:31:45 <applicative> this is an unsafePerformIO we can all agree on
20:32:00 <helgikrs> not really that unsafe
20:32:07 <kmc> > unsafePerformIO (return 3)
20:32:11 <lambdabot>   3
20:32:12 <shachaf> Oh really, helgikrs?
20:32:16 <helgikrs> ^^
20:32:19 <shachaf> > unsafePerformIO (return undefined)
20:32:20 <lambdabot>   *Exception: Prelude.undefined
20:32:26 <shachaf> Not so safe now, is it?
20:32:41 <helgikrs> > undefined + 3
20:32:42 <lambdabot>   *Exception: Prelude.undefined
20:32:46 <ourfrank> sshc: I meant actually generating the explicit ''Double. I ended up using (AppE (VarE (mkName "mkName")) . LitE . StringL $ show typename) and it works.
20:32:50 <helgikrs> is (+) also unsafe?
20:33:27 <ion> yes
20:33:31 <shachaf> @vixen Is (+) unsafe?
20:33:34 <lambdabot> isn't it obvious?
20:33:49 <shachaf> Exactly.
20:33:52 <shachaf> @protontorpedo
20:33:52 <lambdabot> im such an asshole
20:34:12 <ion> @faq Can Haskell make (+) unsafe?
20:34:12 <lambdabot> The answer is: Yes! Haskell can do that.
20:36:10 <kmc> @quote HaskellLove
20:36:10 <lambdabot> HaskellLove says: haha fuck yeah i am ninja... anyways... when someone asks u about monads ask him is he a programmer or a mathematician... to a programer u can explain it in 5 minutes, not tell him
20:36:10 <lambdabot> how complex it is so he goes studies a hole day and at night he says : wait why the fuck do i waste time, i will never use this
20:36:51 * shachaf has never looked at it that way before.
20:37:18 <ion> You haven’t studied a hole?
20:43:53 <int80_h> so, return puts a value inside the IO monad. What could be used to take a value out of an IO monad?
20:44:10 <applicative> execution?
20:44:20 <Axman6> int80_h: in theory nothing
20:44:23 <kmc> int80_h, what can be used to take a cake out of a recipe?
20:44:29 <int80_h> hmm
20:44:33 <Axman6> that's part of the whole IO monad abstraction
20:44:35 <kmc> int80_h, (IO T) is in no way a container of T's
20:44:45 <kmc> it's a description of how you *could* generate a T by doing some IO
20:44:55 <kmc> so you can't "take the T out" anymore than you can take the cake out of a recipe
20:45:22 <kmc> http://www.haskell.org/haskellwiki/Introduction_to_IO
20:45:30 <applicative> int80_h: consider the action of finding out how many words are in the morning Times 
20:45:39 <int80_h> okay I'll have a better articulated question in a minute. I can't get my code to compile, though it works fine in ghci.
20:45:44 <kmc> at one level, Haskell programs don't perform IO, they just describe IO which could be performed
20:45:49 <applicative> int80_h: I suppose people have occasionally done that. 
20:46:02 <kmc> you have primitive steps like getChar
20:46:08 <kmc> you glue together descriptions with (>>=)
20:46:24 <kmc> the descriptions are just values and they're totally inert
20:46:56 <kmc> and you pick your favorite IO-description and name it "main"
20:47:21 <applicative> getChar is an action.  I do it again and again when reading
20:48:23 <int80_h> @src print
20:48:23 <lambdabot> print x = putStrLn (show x)
20:48:36 <int80_h> @hoogle print
20:48:36 <lambdabot> Prelude print :: Show a => a -> IO ()
20:48:36 <lambdabot> System.IO print :: Show a => a -> IO ()
20:48:36 <lambdabot> module Text.Printf
20:48:44 <int80_h> hmm
20:50:40 <kmc> the IO type comes with some primitives like, say, putChar
20:50:48 <monochrom> http://hpaste.org/45023/funny_experiment  hehe
20:51:16 <kmc> these don't really have @src because the details of how they're implemented are totally compiler-dependent
20:51:37 <kmc> reading the actual GHC source for putChar will be confusing and unenlightening if all you want to do is perform some IO
20:51:42 <BMeph_> @quote monochrom.IO
20:51:42 <lambdabot> No quotes match. Just try something else.
20:51:50 <monochrom> it has been lost.
20:51:50 <BMeph_> Aw. :(
20:52:04 <monochrom> how do I obtain the IO from IO String?
20:52:09 <shachaf> @src putChar
20:52:09 <lambdabot> putChar c = hPutChar stdout c
20:52:17 <shachaf> kmc: Seems clear enough.
20:52:21 <kmc> right, that's not what i meant ;P
20:52:29 <kmc> @src hPutChar
20:52:29 <lambdabot> Source not found. :(
20:52:52 <monochrom> I should rewire my irc client to auto-respond to "@quote monochrom" :)
20:53:00 <int80_h> monchrom: any newb can answer that, it's "five pounds of flax!"
20:54:00 <ion> How do i obtain the O from IO?
20:54:47 <BMeph_> ion: With a Red Ryder BB gun. "It'll poke your I out, kid!" ;þ
20:54:53 <shachaf> ion: "< /dev/null"
20:54:54 <int80_h> http://hpaste.org/45024/wtf
20:55:26 <int80_h> ion: show us your O face!
20:55:39 <int80_h> office space, anyone?
20:55:54 <monochrom> how do I obtain the ion from ionization? :)
20:55:55 <ion> int80_h: print isn’t :: … -> IO [Entry].
20:55:55 <jmcarthur> how do i get the spoon out of IO Spoon?
20:56:22 <kmc_> there is no spoon?
20:56:25 <monochrom> hey, "ionization" contains two "ion"s. this is a revelation!
20:56:39 <ion> revelation only contains one.
20:56:52 * int80_h founds the first church of ION.
20:57:28 <int80_h> ion: okay so this is a type mis-match problem then
20:58:05 <ion> So says my crystal ball which knows the error message you got, as opposed to, say, us.
20:58:40 <int80_h> ion: oh I'll post the error brb
20:58:52 <shachaf> /nick izat
20:59:18 <int80_h> http://hpaste.org/paste/45024/wtf_annotation#p45025
21:00:13 <int80_h> show must be able to be used inside ghci for me to see the string from the head of the list. So what's the problem then?
21:01:04 <monochrom> @type map readFile ["x", "y"]
21:01:05 <lambdabot> [IO String]
21:01:05 <applicative> int80_h: shouldn't the last line be just:   head entryFiles?
21:01:15 <monochrom> @type mapM_ readFile ["x", "y"]
21:01:15 <lambdabot> IO ()
21:01:23 <int80_h> applicative: I did that, it compiles but I don't get any output.
21:01:30 <applicative> whoops
21:01:43 <monochrom> I doubt that you really like map readFile entryFileNames
21:02:52 <int80_h> monochrom: huh?
21:03:00 <ion> ‘head $ map readFile entryFileNames’ indeed returns a value of type IO String which you can’t print directly.
21:03:22 <int80_h> ion: I can inside ghci
21:04:03 <ion> print (readFile "/etc/motd") works in your ghci?
21:04:30 <int80_h> ion: no, I get a similar error
21:05:32 <int80_h> but if I do "head entryFiles" in ghci, I get the first element of the list printed
21:05:45 <monochrom> what is printed?
21:06:02 <int80_h> expressed as characters on the terminal
21:06:28 <ion> print =<< readFile "/etc/motd" should work instead. It runs the IO action (readFile "/etc/motd") and applies print to its result value.
21:06:33 <monochrom> please remind me which modules to import for this code
21:06:58 <ion> ghci runs the IO action and prints its result value transparently.
21:07:25 <int80_h> monochrom: http://hpaste.org/paste/45024/wtf_annotation#p45026
21:08:10 <applicative> int80_h: this compiles fine for me http://hpaste.org/45027/for_int80
21:09:01 <monochrom> Well I get a type error in ghci too if I :load a file with the code.
21:09:44 <monochrom> oh, I should type in each line manually? I'll try that.
21:10:13 <int80_h> I see what fixes it, but I want to talk about it
21:10:21 <int80_h> main = loadEntries >>= putStrLn
21:10:31 <int80_h> what does >>= do again?
21:10:36 <int80_h> :t >>=
21:10:37 <lambdabot> parse error on input `>>='
21:10:45 <int80_h> :t (>>=)
21:10:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:11:01 <ion> In IO monad it runs the IO action on the left and applies the function on the right to its result value.
21:11:03 <int80_h> can we talk about that type signature?
21:11:21 <ion> …which should return an IO action as well.
21:11:23 <monochrom> ok I enter which line/command manually and it is still a type error for print $ head entryFiles
21:12:09 <ion> Say, on the left hand side: readFile "/etc/motd" :: IO String. That’s the m a.
21:12:16 <int80_h> monochrom: in ghci I would just type "head entryFiles" knowing something was going on under the hood. I knew I wouldn't be able to do that in a program I was trying to compile though
21:12:34 <ion> On the right hand side: putStrLn. That’s String -> IO (), the (a -> m b).
21:13:22 <monochrom> "head entryFiles" at ghci prompt is not "print $ head entryFiles". much more complicated.
21:13:28 <ion> ghci does the equivalent of ‘>>= print’ to it.
21:13:43 <int80_h> well thanks :)
21:13:52 <int80_h> that's my lesson for the evening
21:13:59 <monochrom> when you enter expression "blah" at ghci prompt, ghci actually do different things based on type.
21:14:19 <int80_h> I'm trying to do something much more fancy than this, but it begins with understanding this first.
21:14:36 <monochrom> 1. if blah's type is a Show instance, you do get "print blah". but IO isn't in this case.
21:15:07 <revenantphx> 1) Start playing with quartz composer
21:15:07 <revenantphx> 2) Feel sense of inability
21:15:07 <revenantphx> 3) Realize it's just functional programming (visualized)
21:15:08 <revenantphx> 4) Make awesome music visualizer and screensaver
21:15:09 <monochrom> 2. if blah's type is IO X and X is a Show instance, you get blah >>= print, as said.
21:15:20 <revenantphx> thanks haskell :D
21:15:42 <applicative> ghci does a number of things besides print.   import Text.PrettyPrint and you'll see it's different from IO and from e.g. numbers.
21:15:53 <monochrom> 3. otherwise you get an error about "no Show"
21:16:28 <int80_h> Text.PrettyPrint, thanks! I'll look that up
21:16:34 * int80_h waves
21:16:42 <dabblego> why is lambdabot's djinn broke?
21:16:58 <monochrom> I am not really thrilled by all the extra magic that ghci does in the name of helping developers and beginners alike.
21:17:00 <djahandarie> dabblego, which part of it?
21:17:12 <dabblego> missing cases in a pattern-match
21:17:13 <dabblego> @djinn (a -> Maybe a) -> a -> a
21:17:13 <lambdabot> f a b =
21:17:13 <lambdabot>     case a b of
21:17:13 <lambdabot>     Just c -> c
21:17:25 <djahandarie> Doesn't it just cut off after 3 lines?
21:17:28 <ion> monochrom: How about the extra magic lambdabot does? :-P
21:17:38 <djahandarie> Hm, maybe not
21:18:04 <monochrom> Beginners look at ghci behaviour and come back to cross-examine us "why doesn't loaded code do the same"
21:18:32 <monochrom> and especially "since ghci obeys me, I'm doing nothing wrong"
21:19:01 <monochrom> and lambdabot is ten times worse, yes.
21:19:16 <Jafet> @djinn (a -> Either b c) -> a -> (Maybe b, Maybe c)
21:19:17 <lambdabot> -- f cannot be realized.
21:19:50 <monochrom> I should remember that as one more reason why I recommend hugs for learning.
21:21:07 <rndm> what's a nice way to see if every element of a list maps to the same value?
21:22:04 <Jafet> (==1).length.group.map f
21:23:07 <rndm> i like it.  i didn't know about group
21:25:00 <copumpkin> Jafet: eww
21:25:04 <copumpkin> length!
21:25:07 <copumpkin> null . drop 1?
21:25:19 <Jafet> Oh, crap
21:25:46 <Jafet> (genericLength :: [a] -> Nat)
21:25:59 <copumpkin> that'd work
21:26:03 <copumpkin> but no natural type :(
21:26:18 <rndm> oh that's nice
21:30:28 <applicative> > group []
21:30:28 <lambdabot>   []
21:30:42 <applicative> > null . drop 1 . group $ []
21:30:43 <lambdabot>   True
21:30:58 <rndm> hehe, i just did the same test
21:31:01 <ion> @pl \x -> all (== (head x)) x
21:31:01 <lambdabot> all =<< (==) . head
21:31:32 <pastorn> gawd... why do i want <$> when i have fmap?
21:31:39 * pastorn doesn't get it
21:32:17 <rndm> > all =<< (==) . head []
21:32:18 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> GHC.Bool.Bool)
21:32:18 <lambdabot>    arising f...
21:32:29 <applicative> pastorn, it's infix?
21:32:46 <ion> > all =<< (==) . head $ []
21:32:47 <pastorn> and that's supposed to be good?
21:32:47 <lambdabot>   True
21:32:58 <ion> huh
21:33:06 <copumpkin> . head ?
21:33:21 <ion> Ah, of course. all returns True for empty lists.
21:33:27 * applicative recommends a new prelude with plus for (+) , times for (*), toThe for (^) , etc
21:33:43 <rndm> ah yeah, vacuous case
21:33:48 <copumpkin> 5 `toThePowerOf` 7
21:33:51 <pastorn> applicative: for anything but basic maths
21:34:05 <pastorn> i think $ and . is enough...
21:34:17 <ion> Why would you need $ when you have parentheses? :-P
21:34:32 <pastorn> ion: readability
21:34:47 <monochrom> religious readability
21:35:07 <pastorn> but using <$>, *>, <*> and <|> as every third token doesn't improve on readability...
21:35:14 <monochrom> one religion says parens are readable. another religion says $ is more readable.
21:35:22 <pastorn> i can't even pronounce them!
21:35:32 <shachaf> monochrom: Or sometimes . and $
21:35:59 <monochrom> <$> is pronounced Jacquelin von Brionée
21:36:14 <applicative> > fmap (+1) <$> [[1]]
21:36:15 <lambdabot>   [[2]]
21:36:28 <pastorn> @remember monochrom <$> is pronounced Jacquelin von Brionée
21:36:28 <lambdabot> It is stored.
21:36:31 <applicative> ^^ hey, pastorn, less parentheses,
21:36:37 <monochrom> and yes there is also a religion that says pronouncible code is more comprehensible
21:36:48 <ion> > fmap (+1) `fmap` [[1]]
21:36:49 <lambdabot>   [[2]]
21:37:53 <monochrom> members of said religion swear that they pronounce the code out loud as a first step to see what the code means.
21:38:03 <ion> <*> is beatboxed as a snare.
21:38:44 <pastorn> monochrom: how are you supposed to do rubber ducking otherwise?
21:39:01 <pastorn> ^^^ legitimate concern
21:39:14 <monochrom> I'm pretty sure "Eff Jacquelin von Brionée Ex Kuso Katamoto Why Kuso Katamoto" really helps you comprehend "f <$> x <*> y", yeah
21:39:46 * applicative is strangely enlightened
21:40:37 <ion> Ah, rubber ducking wasn’t an NSFW expression.
21:40:38 <pastorn> well, i can consider <$> to be "over", <*> to be "on" and <|> "alternatively", but the rest is just... i unno
21:40:46 <pastorn> *dunno
21:40:53 <pastorn> ion: heheh
21:41:51 <applicative> pastorn, what about >>= and >> , they're okay?
21:42:11 <pastorn> applicative: bind and pass
21:43:15 <pastorn> wasn't there some philosopher that said that we can't think about that which we do not have words for?
21:43:29 <monochrom> yes there was.
21:43:33 <applicative> i think you're thinking of the last page of the tractatus
21:43:48 <pastorn> applicative: the what?
21:43:51 <monochrom> He can't think about that which he does not have words for. I'm fine.
21:44:26 <monochrom> Alternatively, there is already a word for <$>. That word is <$>
21:44:29 <pastorn> oh, Wittgenstein
21:44:48 <applicative> maybe not. http://www.kfs.org/~jonathan/witt/tlph.html
21:45:23 <pastorn> "Whereof one cannot speak, thereof one must be silent"
21:45:34 <pastorn> hmmm...
21:45:51 <monochrom> Perhaps he uses his mouth to think.
21:46:05 <monochrom> I use my brain to think, thank you very much.
21:46:05 <applicative> what can't be said, can't be thought, and it can't be whistled either
21:47:20 <monochrom> Indeed if you're into visual languages and visual reasoning, I wonder how that goes with all that "you must speak" nonsense.
21:47:45 <applicative> diagrams count
21:49:04 <applicative> writing too of course
21:59:52 <applicative> monochrom, he is in fact attacking type theory, which says 'that doesn't make sense because the things you're talking about don't fit together' 
22:00:47 <pastorn> applicative: wait... wittgenstein does this?
22:00:57 <applicative> pastorn: yes, of course
22:01:23 <monochrom> what does he propose in place of type theory?
22:01:55 <applicative> monochrom, 'the mystical' i guess, but then in the last line take it back.  
22:03:33 <applicative> see for example http://www.kfs.org/~jonathan/witt/t333en.html which will look a bit idiotic at first sight
22:04:22 * applicative forgot how terrible this translation is.
22:05:34 <monochrom> I click on "German" and all I get is "(Sorry, no German text)" XD
22:06:24 <monochrom> "A translated work that has lost its original cannot be spoken"
22:07:32 <applicative> http://www.kfs.org/~jonathan/witt/tde.html he seems not to have realized his intention of making the two 'hypertexts', English and German, fit together
22:08:27 <axfan> hey guys
22:08:34 <applicative> hey axfan
22:08:36 <axfan> any tips on how to get your girlfriend into programming?
22:09:18 <ion> with sudo
22:09:19 <pastorn> axfan: scheme
22:09:26 <pastorn> axfan: or racket, as it's called now
22:09:37 <pastorn> their image intro thingy is awesome
22:09:38 <Jafet> @vixen How were you introduced to Haskell?
22:09:38 <lambdabot> Ooh, functional programmers are so hot!
22:09:55 <applicative> @vixen do you like haskell?
22:09:55 <lambdabot> Ooh, functional programmers are so hot!
22:09:56 <axfan> wait..
22:09:57 <pastorn> axfan: srsly, check it out
22:10:40 <applicative> racket's ide makes my desktop blink on os x
22:11:04 <pastorn> applicative: don't blame racket for your inferior os
22:11:09 <applicative> compared to that, monads are a picnic
22:11:11 <axfan> @Can Haskell get my girlfriend into programming?
22:11:11 <lambdabot> Maybe you meant: faq map run wn
22:11:14 <axfan> dang it didnt work
22:11:18 <axfan> XD
22:11:33 <axfan> so whats special about racket?
22:11:41 <applicative> @faq can Haskell get axfan's girlfriend into programming?
22:11:41 <lambdabot> The answer is: Yes! Haskell can do that.
22:11:48 <axfan> ohhh
22:11:49 <pastorn> axfan: if you just wanna show someone programming, don't start off with a typed langugae
22:11:50 <axfan> thats how 
22:11:50 <monochrom> @vixen Can Haskell get my girlfriend into programming?
22:11:50 <lambdabot> church is my favourite computer scientist.
22:11:56 <applicative> :)
22:11:56 <axfan> i usualy start off
22:11:57 <axfan> with html
22:12:02 <axfan> and make them learn websites
22:12:13 <pastorn> axfan: html is annoying, scheme isn't
22:12:23 <pastorn> axfan: try it out yourself, install DrRacket
22:12:30 <axfan> alright :) thanks for the tips
22:13:24 <monochrom> scheme becomes racket. I hope haskell won't become basketball
22:13:45 <monochrom> but bikini swimming suit is fine
22:14:03 <applicative> @vixen which is wierder, monads or blinking desktops?
22:14:03 <lambdabot> no
22:14:16 <ion> Well, now that “scheme” is free again, haskell could take that name.
22:14:41 <applicative> calculating is better than scheming
22:14:57 <shachaf> And so is curry.
22:16:02 <pastorn> axfan: http://docs.racket-lang.org/quick/index.html
22:16:48 <applicative> oh yeah, the circles and squares....
22:16:57 <applicative> made my desktop blink....
22:17:03 <Jafet> And triangles and crosses?
22:18:06 <axfan> thanks pastorn
22:18:11 * applicative hadn't realized the users are calling themselves racketeers, however inevitably
22:18:26 <pastorn> axfan: that documentation gets installed on your computer when installing DrRacket
22:20:52 <idnar> pastorn: what's wrong with starting off with a typed language?
22:21:37 <blackdog> idnar: a typed language might be ok
22:21:37 <pastorn> idnar: if you just want to show up what programming is like and not actually teach all the intricate details, then just skipping types completely is a good idea
22:21:42 <idnar> (I assume you mean statically typed)
22:21:50 <blackdog> haskell's pretty baroque, though. it's a research vehicle
22:21:57 <idnar> actually, hang on, do you mean statically typed?
22:22:04 <idnar> I can't imagine what an "untyped" programming language would look like
22:22:14 <pastorn> idnar: try out the racket quick start, you'll see why it's awesome
22:22:21 <applicative> > True + "True"
22:22:22 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
22:22:22 <lambdabot>         against inferred type ...
22:22:44 <pastorn> idnar: explaining that ^^^ is pretty tiresome for anyone
22:22:59 <pastorn> "why can't i do that? they both say 'True'"?
22:23:07 <pastorn> you'll be stuck for ages
22:23:09 <idnar> pastorn: so what happens if you do True + "True" in Racket?
22:23:12 <Jafet> Being a teacher is tiresome, yes.
22:23:22 <pastorn> Jafet: doesn't have to be
22:23:23 <idnar> or, well, whatever the equivalent syntax is
22:23:48 <blackdog> i think that one's a good example for why static typing's actually helpful for beginners
22:23:49 <pastorn> idnar: hang on... i'll try
22:24:09 <blackdog> i'd be more worried about explaining the monomorphism restriction
22:24:11 <Jafet> Type theory is a very useful thinking tool.
22:24:17 <pastorn>  (+ #t "#t")
22:24:19 <pastorn> . . +: expects type <number> as 1st argument, given: #t; other arguments were: "#t"
22:24:20 <Jafet> Static typing just offloads some of the thinking for you.
22:24:23 <blackdog> or any one of the type extensions
22:24:30 <pastorn> idnar: ^^^^
22:24:44 <idnar> pastorn: so, I don't really see how that's an improvement over the GHC error message
22:24:49 <pastorn> idnar: no typeclasses
22:25:03 <pastorn>     Couldn't match expected type `Bool' against inferred type `[Char]'
22:25:11 <Jafet> Is pastorn seriously arguing the merits of scheme over haskell in the channel for haskell?
22:25:16 * applicative secretly agrees the racket quickstart was awesome.
22:25:31 <pastorn> Jafet: for showing someone what programming is, not for day-to-day use
22:25:44 <idnar> pastorn: those error messages seem pretty similar to me
22:25:44 <pastorn> Jafet: try the quickstart, then come back
22:25:47 <Jafet> Nice strawman
22:25:57 <idnar> pastorn: they both basically say "expected $FOO, got something else"
22:25:57 <Jafet> I think your argument is total crap
22:26:12 <pastorn> Jafet: try it
22:26:39 <pastorn> Jafet: also, how many of your non-programmer friends have you tried showing programming to?
22:26:41 <Jafet> I like the picture language more.
22:26:48 <pastorn> Jafet: logo?
22:26:48 <idnar> either way, my point is that there's hardly any difference between a runtime type error and a compile-time type error when you're just starting out
22:26:51 <applicative> no way Racket could give the awesome ten page error messages the ghc can.
22:26:58 <Jafet> I don't teach programming to people, because I don't know anyone who wants to learn it
22:27:05 <Jafet> No, the picture language in SICP.
22:27:12 <idnar> and later on, it just means you only find out about the error later than you could have
22:27:18 <blackdog> pastorn: i've taught probably about 50 students haskell (i know it's not a huge number). it's not that tricky.
22:27:24 <Jafet> It teaches you how to compose programs in a visual way.
22:28:28 <pastorn> blackdog: how long did it take them to write code without direction?
22:28:44 <pastorn> (i.e. "write a function that does precisly *this*")
22:29:09 <blackdog> pastorn: they were writing in the first tute.
22:29:16 * applicative remembers doing stupid project euler problems after about 15 minutes
22:29:20 <blackdog> what do you mean 'without direction'?
22:29:33 <applicative> is YAHT 'direction'??
22:29:44 <idnar> meh, this is wandering into silly territory now
22:29:51 <Jafet> He wants you to confirm his silly belief that omgzors the type system bogs noobs down
22:30:09 <pastorn> blackdog: well, things like writing their own types to describe their thinking etc.
22:30:19 <blackdog> Jafet: thing is, there's a kernel of truth there. it's just surrounded by something that is something very un-kernel-like.
22:30:52 <pastorn> Jafet: if the intention is to show what programming is, not teach the fundamentals, then yes, skipping types is a good thing
22:30:59 <blackdog> pastorn: it was a few years ago now, but I think we were teaching product&sum types pretty early.
22:31:17 <Jafet> pastorn: you mean skipping strong static type theory?
22:31:19 * applicative loved getting slapped on the hand by Hugs for his nonsense from the very first minute.
22:31:28 <Jafet> You can't skip types in programming, wherever you go.
22:31:28 <boegel> y0
22:31:38 <blackdog> if soemone had started using nothing but list/string/tuple types, they'd have been gently guided away
22:31:39 <pastorn> Jafet: yes, i know
22:31:42 <boegel> only 6.30am, and I'm already idling in #haskell, w00
22:31:46 <pastorn> Jafet: just try it
22:31:57 <pastorn> then we can argue some more
22:32:08 <applicative> Jafet doesn't seem to be denying that Racket is or may be wonderful.
22:32:32 <Jafet> I don't need to try anything to tell you that you don't fully understand what type theory is.
22:32:34 <pastorn> applicative: indeed, this must be remedeed
22:32:34 <applicative> Jafet, just try PHP
22:32:42 <Jafet> applicative: never again!
22:32:57 <applicative> Jafet++
22:34:17 <boegel> is there some kind of API for Hoogle that allows you to use it from within a Haskell program?
22:34:36 <boegel> e.g. to look for all functions with a type that matches "Int -> String"?
22:34:38 <monochrom> at the level of beginner and REPL-ish, there is no distinction between "static type check" and "runtime type check". you enter (+ 't 't) you get an error message.
22:34:45 <pastorn> boegel: there's a hoogle package on hackage
22:36:23 <boegel> pastorn: yes, I know, but it didn't seem to allow me to talk to it from within Haskell (I may be mistaken)
22:37:19 <pastorn> boegel: http://hackage.haskell.org/package/hoogle
22:37:37 <idnar> nevermore!
22:45:32 * hackagebot hastache 0.1.2 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.1.2 (SergeyLymar)
22:46:32 * hackagebot yi 0.6.3.0 - The Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-0.6.3.0 (JeffWheeler)
22:46:35 * hackagebot yi-contrib 0.6.3.0 - Add-ons to Yi, the Haskell-Scriptable Editor  http://hackage.haskell.org/package/yi-contrib-0.6.3.0 (JeffWheeler)
22:47:06 <jeffwheeler> Anybody want to try installing those packages (yi, yi-contrib) on the new Haskell Platform for me? I wanna make sure they compile for somebody else before posting to haskell@.
22:47:22 <jeffwheeler> (Make sure to cabal update.)
22:52:10 * applicative is trying
22:52:38 <jeffwheeler> It should compile twice as fast as it used to, thanks to a suggestion here a few days ago. It only compiles everything once now. :)
22:52:57 <djahandarie> Turned off -prof ? :p
22:53:22 <jeffwheeler> djahandarie: which commit are you looking at?
22:53:42 <djahandarie> No commit! Just extrapolating ;)
22:54:39 <jeffwheeler> djahandarie: oh, well, I did turn off -prof (or, rather, made it a flag), but I also made the executable depend on the library, which wasn't possible in old cabal.
22:54:49 <applicative> well, i'm still compiling haskell-src-exts and pointedlist
22:54:51 <jeffwheeler> . . . unfortunately, that breaks haddock.
22:54:59 <djahandarie> :(
22:55:11 <jeffwheeler> applicative: ha, yeah . . . Yi brings a lot of dependencies.
22:55:24 <jeffwheeler> applicative: which is probably better than doing everything in yi/src/ . . .
22:56:00 <jeffwheeler> applicative: it's certainly a goal right now to way-simplify yi core.
22:56:18 <applicative> yes of course.  in general it is admirable. regex-tdfa is giving masses of errors, we'll see...
22:56:34 * hackagebot polynomials-bernstein 1.1.1 - A solver for systems of polynomial equations in bernstein form  http://hackage.haskell.org/package/polynomials-bernstein-1.1.1 (PierreEtienneMeunier)
22:56:55 * applicative thinks omg, uniplate...
22:57:35 * jeffwheeler thinks "I didn't add it, I don't even know what it does!"
22:58:28 <applicative> hm, terminfo-0.3.1.3 failed during the configure step. The exception was: ExitFailure 77 -- have to study
22:58:43 <jeffwheeler> Ah, shit. You need a package on your system, I think.
22:58:51 <jeffwheeler> are you on linux?
23:00:15 <jeffwheeler> I think Ubuntu calls the package you need libncurses5-dev.
23:00:49 <pastorn> jeffwheeler: does yi use vty?
23:00:56 <jeffwheeler> pastorn: by default, yes
23:01:05 <pastorn> heh, there are alternatives?
23:01:40 <applicative> jeffwheeler: i figured it out on to vty
23:01:45 <jeffwheeler> pastorn: yeah, there are two Gtk2Hs frontends (one of which is a terminal UI on top of the vty UI) and a (presumably totally-broken) Cocoa UI
23:04:43 <jeffwheeler> applicative: I've added a notice about the package to the release notes; thanks
23:08:21 <applicative> jeffwheeler: yi-darwin-x86-64 seems to be up and running, it even  compiled my old Yi.hs
23:08:33 <jeffwheeler> applicative: awesome!
23:08:49 <jeffwheeler> applicative: thanks a bunch :)
23:08:55 <applicative> i am only looking at the vty version 
23:09:31 <jeffwheeler> applicative: gotcha. I think the others work on the platforms where they should.
23:09:46 <jeffwheeler> (Well, except Cocoa. I doubt it even compiles.)
23:16:31 <gienah> jeffwheeler: thanks for the yi updates, will try bumping yi on gentoo
23:16:49 <jeffwheeler> gienah: I'd love that. Just about to post to haskell@.
23:17:40 <gienah> jeffwheeler: I wonder if leksah with the yi use flag will build with the new yi, will find out
23:18:11 <jeffwheeler> gienah: relatively little has actually changed, it's mostly just cleaning it up a bit and making it work with the latest haskell platform
23:24:29 <accel> is there a way to use haskell's type system
23:24:33 <accel> as a proof checker?
23:24:36 <accel> so that any program that compiles
23:24:39 <accel> is a correct mathematical proof?
23:26:48 <companion_cube> accel, maybe you should look at agda or coq for such things
23:26:51 <Axman6> accel: haskell's type system is very similar to propositional logic, and haskell programs are proofs that those types are correct
23:29:28 <shachaf> Axman6: Very similar to propositional logic with the additional axiom forall a. a. :-)
23:29:48 <Axman6> sure
23:30:54 <Axman6> accel: as long as you guarantee all your functions are total (-Wall will tell you if they're not), then they should always execute without errors. types aren’t enough to ensure that you get the correct answer though
23:31:09 <Axman6> that's when you start doing things like proof by induction
23:31:14 <shachaf> Axman6: -Wall will tell me if my functions are total?!
23:31:35 <Axman6> well, it'll tell you if any patterns aren't matched anyway
23:32:02 <shachaf> Aw.
23:32:20 <shachaf> There are a couple of functions whose totality I'd really like to know about...
23:32:38 <Axman6> such as?
23:34:52 <shachaf> For example, a function that takes an even integer > 2 and returns two primes whose sum is its argument.
23:35:41 * hackagebot snappy 0.2.0.0 - Bindings to the Google Snappy library for fast compression/decompression  http://hackage.haskell.org/package/snappy-0.2.0.0 (BryanOSullivan)
23:57:30 <gienah> jeffwheeler: yi would probably build without the doc use flag on gentoo, with the doc use flag I get an error I am trying to figure out: setup: Can't find transitive deps for haddock
23:58:11 <jeffwheeler> gienah: yeah, unfortunately we're hitting this bug: http://hackage.haskell.org/trac/hackage/ticket/656
