00:00:14 <Kaidelong> a lot of it probably has less to do with the compiler but more to do with the fact that less control flow is explicit
00:00:24 <Kaidelong> people mess up recursive functions a fair bit too
00:00:40 <Kaidelong> not that strong static typing doesn't help
00:00:44 <Kaidelong> that's also good
00:01:15 <Havelock> yeah, thanks
00:01:32 <Kaidelong> so in that sense functional programming with plenty of higher order functions could deliver a lot of the same benefits even with dynamic types
00:01:47 <geheimdienst> a good example would be null pointer exceptions. in c#, chances are you run into them and then have to figure out why this variable is null and gets accessed. this figuring out might take a long while and be quite complicated
00:01:53 <Kaidelong> foreach is harder to mess up than for and map is harder to mess up than foreach
00:02:01 <geheimdienst> in haskell, null pointer exceptions don't exist in that form. it's largely solved.
00:02:14 * shachaf wonders if he's ever had a null pointer exception.
00:02:16 <Kaidelong> geheimdienst: I think you can set up C# now so that fields aren't nullable
00:02:20 <shachaf> I've had plenty of segmentation faults, certainly.
00:02:30 <Havelock> oh yeah gehimdienst, plenty of null pointer exceptions
00:02:35 <Kaidelong> well you shouldn't ever segfault in C#/Java
00:02:45 <geheimdienst> Kaidelong: ah right, i've read about that
00:02:58 <shachaf> Kaidelong: I don't write in Java/C#. :-)
00:03:01 <geheimdienst> shachaf: segfaults? don't scare the women
00:03:06 <shachaf> Actually I have had null pointer exceptions, never mind.
00:03:19 <Kaidelong> well you can't get those in C!
00:03:39 <Kaidelong> although you can get in situations where you should get them
00:03:45 <geheimdienst> you can get the equivalent. stuff can point to NULL when you didn't expect it
00:04:03 <Kaidelong> yeah but isn't the result just that the OS kills your program?
00:04:13 <shachaf> Yes -- segmentation fault (badly misnamed, of course).
00:04:24 <Havelock> yeah
00:04:34 <Havelock> it just crashes
00:05:55 <shachaf> Fortunately, C programmers never make mistakes.
00:06:18 <Havelock> lol
00:07:13 <geheimdienst> Havelock: often, functional languages like haskell pioneer or popularize things that later get adopted by mainstream languages like c#. haskell has had a way to deal with the null-pointer problem since forever, but c# adopted that kind of thing only recently (when was it, 2-3 years ago?)
00:07:50 <Kaidelong> well all values exposed to the programmer are not nullable
00:08:00 <Havelock> thanks
00:08:05 <Kaidelong> in a sense they are more comparable to C# structs, additionally, immutable ones
00:08:40 <Kaidelong> (except for some things IE IORef, but then, you end up being unable to observe the mutations directly and the observable part is immutable)
00:09:10 <Kaidelong> They are fully constructed immediately when first created and can never be a null pointer or contain ones
00:12:08 <Jafet> fromNonNullPointer = fromJust
00:14:31 <Kaidelong> Jafet: Maybe is explicit
00:14:48 <Kaidelong> it also has a different meaning, really
00:15:00 <Kaidelong> it doesn't mean "no value here yet but there might be later"
00:15:11 <Kaidelong> it means "no sensible result was obtained"
00:18:50 <geheimdienst> good point. in imperative languages, null means both "u no can has" and "u can has, but latr". kind of odd to conflate those two ...
00:19:57 <shachaf> geheimdienst: No, the value at any particular moment is "u has" or "u do not has" (to use your terminology).
00:20:13 <shachaf> The fact that the value changes is a separate aspect of imperative programming.
00:21:18 <geheimdienst> i was thinking that because in my experience, half of all null problems are related to initialization ... things being not there yet
00:21:23 <geheimdienst> but yeah
00:23:05 <shachaf> geheimdienst: Sure, but you can say the same thing of any uninitialized value.
00:23:12 <shachaf> Anyway, we're in agreement.
00:26:52 * geheimdienst gives shachaf a Maybe Hug
00:27:24 * shachaf fromJusts it.
00:27:36 <shachaf> Uh-oh.
00:27:44 <shachaf> Do I dare?
00:27:50 * ddarius had a bunch of notes and calculations on generalized species but can't find them now.
00:28:01 <Kaidelong> well at least it won't segfault
00:28:09 <Kaidelong> you could try to map over it
00:28:45 <shachaf> ddarisu: Generalized species?
00:28:57 <Kaidelong> unless the hug was some unsafe thunk
00:29:02 <Kaidelong> then it might yet segfault
00:29:14 <shachaf> I like how mathematicians put the word "generalized" in front of things.
00:29:29 <shachaf> It's like calling something "New X".
00:29:56 <dolio> Like New Coke?
00:30:13 <geheimdienst> like javaistas add another Abstract in front of their AbstractFactoryFactory, because it's just not enough indirection yet
00:30:37 <shachaf> dolio: More like New Zimbabwe Dollar.
00:30:49 <Kaidelong> geheimdienst: that's because there isn't enough polymorphism without adding all those layers
00:31:13 <Kaidelong> there is no such thing as "Functor" in Java
00:31:22 <Kaidelong> even though you'd think it'd make sense
00:31:47 <Kaidelong> I should say abstraction more specifically
00:32:09 <Kaidelong> Java isn't abstract enough on its own without doing those sorts of things, basically
00:33:09 <dolio> Needs more stubs.
00:34:22 <geheimdienst> i think for inversion-of-control kinds of things, there's some justifiable use, but often Abstractitis and Factoritis are an irrational desire to be "neat" and "general"
00:35:05 <geheimdienst> "yes, we only have one instance implemented or planned, but possibly at some point in the far future ..."
00:37:18 <ddarius> shachaf: A species is a functor B -> Set where B is the category of finite sets and bijections.  B can be viewed as !1 where ! : Cat -> Cat is the free symmetric (strict) monoidal category construction (and 1 is the terminal category.)  We can further generalize by using presheafs over Set rather than Set, so an (A,B)-species is a functor !A -> [B^op,Set], i.e. a (!A, B) profunctor.
00:38:44 <ddarius> These form a nice bicategory.
00:39:28 <Boxo> Someone noted that the "layers of abstraction" in Java code should really be called "layers of indirection"
00:40:35 * Boxo gears up for some java-bashing
00:41:17 <Boxo> That was after I had noted that the difference between Java's and Haskell's "abstractions" was that Java's make you write more code while Haskell's let you write less code
00:43:12 <ddarius> Boxo: No, that's reasonably accurate if "layers of abstraction" means things like the factory pattern and co.  The point of those in Java is to enable later binding which is indeed largely about indirection, though does (ignoring reflection) require some interface abstraction.
00:51:51 <Boxo> Sounds right. Maybe I'll take my java-bashing elsewhere, it should be beneath #haskell anyway
00:53:39 <Younder> lol
00:54:52 <Younder> #lisp is great for language bashing.. They take a far more arrogant attitude towards their language.
00:56:43 <Younder> A constructive comparison of features might be OK. Java has, for instance, a interesting approach to multiprocessing.
01:00:14 <Entroacceptor> this channel can be pretty arrogant, too
01:05:52 <miasma> found from a monad tutorial: "Monads enable pure functional programmers to implement mutation, state, I/O, and a plethora of other things that are not functions."
01:06:01 <lins> Hi, how to compile cabal with a new compiled ghc7 where there is no cabal yet? I encounterred the problem that it siad "Setup: At least the following dependencies are missing: base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2"
01:08:31 <mjrosenb> does anyone know the homepage for gtk2hs?
01:09:06 <Younder> Do any of you do computational Category theory?
01:11:48 <siracusa> mjrosenb: http://haskell.org/gtk2hs/
01:12:00 <siracusa> But it has been down for a while.
01:13:04 <Younder> You see I am writing some verification software. I think using a category theoretical approach to analysis and a topological ordering of types allows me to inherit and verify properties of types. Which a accurate knowlege of the properties of type I should the be able to  verify programs automatically without user intervention.
01:13:37 <mjrosenb> siracusa: down as in the disk was wiped?
01:13:51 <Younder> Of course this has never actually been done...
01:15:19 <Younder> The open source program Axiom probably comes the closest.
01:15:25 <siracusa> mjrosenb: I don't know what the exact problem is but people are working on it for some time. I guess it's server related.
01:16:12 <siracusa> mjrosenb: Are you looking for certain information?
01:17:23 <mjrosenb> i am looking for the source
01:18:02 <mjrosenb> http://sourceforge.net/projects/gtk2hs does not look promising :(
01:18:29 <siracusa> @hackage gtk2hs
01:18:29 <lambdabot> http://hackage.haskell.org/package/gtk2hs
01:18:45 <mjrosenb> 404 Not Found
01:18:45 <mjrosenb> The requested resource was not found: no such package 'gtk2hs'
01:19:01 <mjrosenb> has it been renamed to gtk?
01:19:07 <mjrosenb> http://hackage.haskell.org/package/gtk appears to exist
01:19:35 <siracusa> @hackage gtk
01:19:35 <lambdabot> http://hackage.haskell.org/package/gtk
01:20:16 <siracusa> Yeah, lazy bot :-P
01:20:32 <ddarius> Younder: You may want to look at some of Joseph Goguen's work.
01:21:12 <Younder> ddarius, thanks, I'll check it out.
01:22:55 <RayNbow`TU> @. hoogle type \f g -> map f . g
01:22:57 <lambdabot> Parse error:
01:22:57 <lambdabot>   --count=20 "forall a b (f :: * -> *). (Functor f) => (a -> b) -> f [a] -> f [b]
01:22:57 <lambdabot> "
01:23:07 <RayNbow`TU> :t \f g -> map f . g
01:23:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f [a] -> f [b]
01:23:27 <RayNbow`TU> @hoogle (a -> b) -> f [a] -> f [b]
01:23:28 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
01:23:28 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
01:23:28 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
01:31:40 * hackagebot free-theorems-seq-webui 1.0.0.1 - Taming Selective Strictness  http://hackage.haskell.org/package/free-theorems-seq-webui-1.0.0.1 (DanielSeidel)
01:36:38 <ddarius> Younder: Also, relatedly, http://www.kestrel.edu/home/people/smith/
01:42:05 <RayNbow`TU> (\f g -> fmap f `fmap` g)  -- does this combinator have a name?
01:42:23 <sipa> @pl (\f g -> fmap f `fmap` g)
01:42:23 <lambdabot> fmap . fmap
01:42:38 <quicksilver> I normally write it as (fmap . fmap)
01:42:51 <quicksilver> I think some people call it fmap2
01:42:56 <quicksilver> morally it's fmap (for the composed functor)
01:43:02 <shachaf> fmap fmap fmap
01:47:35 <RayNbow`TU> > let (<$$>) = fmap fmap fmap in (read <$$> words <$$> lines) "1\n2 3" :: [[Int]]
01:47:37 <lambdabot>   [[1],[2,3]]
01:49:22 <wto> lol
01:51:02 <sipa> @pl (fmap fmap fmap)
01:51:02 <lambdabot> fmap fmap fmap
01:51:09 <sipa> :t (fmap fmap fmap)
01:51:10 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
01:55:15 <RayNbow`TU> quicksilver++
01:55:19 <RayNbow`TU> @karma quicksilver
01:55:19 <lambdabot> quicksilver has a karma of 26
01:56:08 <Jafet> @google to fmap fmap
01:56:09 <lambdabot> http://www.haskell.org/pipermail/reactive/2008-November/000049.html
01:56:09 <lambdabot> Title: [reactive] To fmap fmap or not?
01:56:49 <shachaf> fmap is the best tool for parenthesis elimination.
01:56:59 <shachaf> Especially when used unnecessarily.
01:58:05 * roelvandijk uses fmap on lisp, it is super effective!
01:59:21 <Havelock> lisp fainted!
02:07:21 <Ptival> what do I have to do in order to use :hoogle in GOA? Right now it returns "A Hoogle error occured."
02:11:39 <gienah> Ptival: can you run hoogle on the command line?
02:11:59 <Ptival> lambdabot -e ":hoogle sthg" ?
02:12:12 <co_dh> @karma co_dh
02:12:12 <lambdabot> You have a karma of 0
02:12:17 <co_dh> :(
02:13:04 <gienah> Ptival: i mean can you run hoogle in the shell or command prompt, as in, does hoogle exist on your system?
02:13:28 <Ptival> gienah: I don't think so
02:13:40 <Ptival> hoogle: command not found < if that's your question
02:13:45 <gienah> Ptival: it helps to install it :-)
02:14:00 <Ptival> I thought it came with lambdabot :)
02:14:08 <Ptival> like pl and stuff
02:14:09 <gienah> no :-/
02:14:48 <gienah> anyway its challenging to configure hoogle as you need to build your local docs with hoogle support somehow
02:15:50 <gienah> on gentoo we have not done that as yet (although i do wonder about doing it, it would require modifying almost every ebuild in the overlay)
02:16:25 <mjrosenb> gienah: i suspect that you could do it by modifying the eclass
02:16:42 <Ptival> I'm on Debian
02:17:54 <gienah> mjrosenb: yes (I submitted a sketch of doing exactly that to the devs), but then I need to add a hoogle USE flag to almost every ebuild in the overlay 
02:19:24 <gienah> Ptival: i'm not sure if the docs are built with the hoogle flag on debian or not 
02:20:33 <gienah> Ptival: debian haskell wiki is easy to find: http://wiki.debian.org/Haskell
02:50:09 <paolino> hello, shouldn't be null :: Monoid m => m -> Bool or it misses an Eq m ?
02:50:31 <paolino> :t null
02:50:32 <lambdabot> forall a. [a] -> Bool
02:51:54 <paolino> mh, maybe mempty is not what I think it is
02:52:06 <quicksilver> Monoids don't necessarily have an observable empty.
02:52:20 <quicksilver> but, yes, there is certainly (== mempty)
02:52:26 <quicksilver> in the case that Eq is supported
02:52:53 <Boxo> > mempty `mappend` mempty == mempty
02:52:54 <lambdabot>   True
02:53:20 <Boxo> what's observable?
02:56:16 <paolino> Boxo, it defaulted to () ?
02:57:06 <Boxo> > mempty
02:57:07 <lambdabot>   ()
02:57:27 <Boxo> > mempty == ()
02:57:28 <lambdabot>   True
02:57:33 <Boxo> mempty == []
02:57:39 <Boxo> > mempty == []
02:57:40 <lambdabot>   True
02:57:55 <paolino> [] has Eq
02:57:57 <Boxo> I thought (==) was transitive!!
02:58:18 <Entroacceptor> > [] == ()
02:58:19 <lambdabot>   Couldn't match expected type `[a]' against inferred type `()'
02:59:59 <paolino> @hoogle m -> Bool
03:00:00 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
03:00:00 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
03:00:00 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
03:00:17 <paolino> @hoogle Monoid m => m -> Bool
03:00:17 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
03:00:17 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
03:00:17 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
03:01:45 <paolino> mh a monoid is checkable for emptyness even without Eq
03:03:01 <paolino> well, should be
03:04:04 <quicksilver> paolino: why?
03:04:20 <quicksilver> paolino: how do you check for emptiness in the monoid of functions under composition?
03:04:54 <quicksilver> or the monoid of IO () actions under (>>)
03:05:01 <paolino> I say I should be able, but the truth is I'm not
03:05:25 <Boxo> @define p => q = not (p & (not q))
03:05:29 <zygoloid> for the former, unsafePerformIO (catch (f (unsafePerformIO (throw MyError))))
03:05:32 <Boxo> @def p => q = not (p & (not q))
03:05:32 <lambdabot> Maybe you meant: bf do let
03:05:32 * zygoloid ducks
03:05:41 <Boxo> @let p => q = not (p & (not q))
03:05:41 <lambdabot>   TemplateHaskell is not enabled
03:05:50 <Boxo> durr
03:06:09 <quicksilver> the business of observability is not really part of the algebraic structures.
03:06:29 <quicksilver> issues of computability are generally weaker than syntactically provable mathematical laws
03:09:06 <paolino> quicksilver: it's not a case then that I got this question while writing newTMonoid.
03:09:27 <paolino> observability counts there, I suppose
03:09:44 <Boxo> @check \(a,b,c) -> ((a==b) && (b==c)) ==> (a==c)
03:09:45 <lambdabot>   No instance for (Test.QuickCheck.Testable
03:09:45 <lambdabot>                     (Test.QuickCh...
03:10:20 <paolino> quicksilver: I want to retry when the monoid is empty
03:10:56 <quicksilver> I think requiring Eq and comparing to mempty is probably the way.
03:11:01 <paolino> STM.retry
03:11:03 <quicksilver> the simplest way.
03:11:17 <quicksilver> another way is to defined MonoidNull where null :: a -> Bool
03:11:30 <quicksilver> (which I suppose might be more efficient that Eq in some cases)
03:11:53 <paolino> well no chance for function composability, if it ever make sense
03:12:26 <paolino> I cannot retry on id
03:16:12 <paolino> MonoidNull (Bool,a -> a) where null = fst
03:25:44 <guiyongzhe> nickserv 2539506 peanutgyz@sina.com
03:35:03 <solrize> is there anything like python's urllib for haskell?  i.e. an http client that retrieves a url you give it
03:35:42 <tab> solrize: http-enumerator ?
03:35:50 <solrize> looking
03:35:50 <Saizan> HTTP too
03:35:56 <Saizan> or the curl bindings
03:36:14 <ManateeLazyCat> Haha, my Android news reader complete. :)
03:37:18 <ManateeLazyCat> Curl binding is cool and easy to use.
03:38:29 <solrize> ok i'll check that too, thanks
03:39:07 <solrize> http-enumerator means i have to figure out iteratee :(
03:39:18 <tab> solrize: not really
03:39:29 <solrize> oh ok
03:39:43 <tab> solrize: there's helper to do queries/response as lazy bytestring
03:40:07 <ManateeLazyCat> solrize: There have two example packages for curl binding: download-curl, manatee-curl, download-curl is simplest example that how to use curl API. manatee-curl use Haskell concurrent mechanism make curl can running in many threads.
03:40:28 <tab> solrize: httpLbs for example
03:40:48 <tab> solrize: or simpleHttp
03:41:00 <solrize> oh cool, that will make simple uses easier
03:41:13 <ManateeLazyCat> solrize: If you want figure out how to play network protocol, use Haskell library is best one, if you just want to download file, curl also is good choose.
03:41:14 <solrize> iteratee is presumably better for lots of connections
03:41:31 <tab> iteratee would be better for long connection
03:41:39 <tab> for example streaming
03:41:43 <solrize> hmm
03:42:17 <solrize> typically i want to retrieve a lot of separate urls from the same site
03:42:32 <tab> that would be fine using the lazy bytestring one
03:42:43 <solrize> ok
03:43:43 <solrize> thanks i think i can see how to do it that way
03:55:01 <Tonar> I read a page using infix operator. It suggest that (foo) a b is the same as a foo b, but ($) head tail [1..] fails and head $ tail [1..] works. Why?
03:56:02 <opqdonut> head $ tail [1..]  == ($) head (tail [1..])
03:56:36 <opqdonut> a .*. b c  ==  a .*. (b c)  ==  (.*.) a (b c)
03:56:43 <opqdonut> function application binds tighter than infix operators
03:57:04 <Younder> ugly..
03:58:17 <Younder> What does the last entry even mean?
03:59:00 * hackagebot uu-parsinglib 2.7.0.2 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.0.2 (DoaitseSwierstra)
04:00:05 <fcr> Younder: it's not ugly, in real math the same happens, like sin 30 + 1 == (sin 30) + 1
04:01:56 <Younder> fcr: ok: what does (b c) mean in this context.
04:02:06 <Veinor> (b c) is the result of applying b to c
04:02:19 <Younder> so b(c)
04:02:36 <Tonar> ah. thx. Is there kinda a reference for the order of the bindings?
04:02:36 <Veinor> so 1 + sin 30 == 1 + (sin 30) == (+) 1 (sin 30)
04:02:47 <quicksilver> Younder: in C-like languages, yes, b(c). In haskell (b c)
04:02:55 <Younder> right
04:04:37 <Jafet> Tonar: you can use :i in ghci to get the fixity and precedence of any operator
04:05:07 <Jafet> And pretend function application has precedence 11
04:10:32 <Tonar> thx
04:11:16 <Cale> Younder: Yeah, function application is just indicated with whitespace in Haskell, because it's important and incredibly common and whitespace is the quietest possible notation you can give something.
04:11:38 <Cale> Younder: The parens are only needed for grouping.
04:12:26 <Younder> (I already knew that. But I thought a more aggressive response would yield be more understandable answer..) 
04:13:18 <Jafet> "Teach a man to troll, and he will wreck an ecosystem."
04:13:28 <Younder> rotfl
04:13:52 <Cale> Oh, right, well then take my response as scripted ;)
04:15:35 <Younder> Anyhow the Haskell syntax is beautiful  in it's own right. Just different..
04:21:59 <Cale> Hey, this craftwerk library looks quite cool.
04:22:21 <Cale> It can output TikZ code! :)
04:22:44 <Younder> What is tikZ?
04:23:23 <RayNbow`TU> a package for LaTeX
04:24:32 <Cale> A very very cool package for technical drawing.
04:25:22 <Cale> http://www.ctan.org/tex-archive/graphics/pgf/base/doc/generic/pgf/pgfmanual.pdf
04:26:13 <Younder> I am struggling these days producing category diagrams in LaTex.
04:27:53 <Cale> ah, I've used TikZ for things like string diagrams, but I think a more specialised package is better if you're doing ordinary commutative diagrams (if only because people have rather refined typographical expectations when it comes to commutative diagrams)
04:28:40 <Younder> Found: commutative diagrams in Tex by Paul Taylor.
04:28:56 <Cale> Yes, that's one that I was just about to recommend :)
04:30:04 <Cale> If you're not doing anything too too complicated, it's great. It somehow produces nicer on-screen output than xy-pic too, at least my PDF reader (Evince). xy-pic is better at making more complicated diagrams though.
04:44:54 * mjrosenb usually ends up using xfig with its tex output abilitie
04:51:15 <Xilon> Is it possible to use Cabal 1.10's testsuite support yet? Any documentation on it?
04:51:58 <dcoutts_> http://www.haskell.org/cabal/release/cabal-1.10.1.0/doc/users-guide/#test-suites
04:53:58 <Xilon> Oh sweet, thanks!
04:56:29 <Phyx-> dcoutts_: oh hey, I never heard anything about that patch I sent in a month or two ago. I still have to change some things, but is it generally what you had in mind?
04:57:39 <Ptival> :pl \a b c -> c $ a `div` b
04:57:44 <Ptival> @pl \a b c -> c $ a `div` b
04:57:44 <lambdabot> (flip id .) . div
04:58:01 <mauke> @unpl (flip id .) . div
04:58:02 <lambdabot> (\ h k c -> c (div h k))
04:58:14 <otulp> How can I safely convert Double -> Word64 and Word64 -> Double? I'm writing a binary instance, and just realized that the lengths of encoded Doubles vary because it is implemented using decodeFloat :: (RealFloat a) => a -> (Integer, Int). I really want the binary to be compact and regular.
04:58:38 <mauke> define "regular"
04:59:00 <otulp> That all encoded Doubles take exactly 8 bytes.
05:00:22 <mauke> the C programmer in me is screaming "unportable!"
05:00:45 <otulp> OK.. Some other way of specifying that my doubles are to be 8 bytes long, in both the main program and in the binary instance.
05:00:46 <Zao> mauke: Since when do C programmers know such words?
05:01:07 <mauke> Zao: since 1989
05:01:23 <Botje_> are there any systems that don't support IEEE754 doubles?
05:01:33 <Botje_> apart from embedded stuff, maybe
05:02:27 <mjrosenb> Botje_: alpha
05:03:08 <mjrosenb> Botje_: 8087 will also not do IEEE, unless you bloat the code, and make it much slower
05:03:09 <otulp> Perhaps 
05:03:20 <otulp> Bleh. Mistyped.
05:03:42 <mjrosenb> and most gpu's really prefer singles over doubles
05:03:47 <Zao> mjrosenb: Or halfs.
05:04:17 <mjrosenb> Zao: talk about non-ieee compliant!
05:04:26 <mauke> bitwiseCast :: (Storable a, Storable b) => a -> b; bitwiseCast x | sizeOf x == sizeOf y = y where y = unsafePerformIO $ with x (peek . castPtr)
05:06:11 <mjrosenb> mauke: that seems ... sketchy
05:07:45 <otulp> Storable. Right. Thanks.
05:08:30 <otulp> As long as I can read whatever I wrote on the same hardware, I'm good.
05:08:40 <otulp> Portability schmortability.
05:15:51 <Jafet> Why not use decodeFloat to serialize them?
05:16:26 * Jafet produces a hand puppet
05:16:27 <Apocalisp> does this have a name?  data Foo a b = a -> (Foo a b, b)
05:16:29 <otulp> Because that gives an Integer, which is large and varied in size.
05:16:33 <Jafet> "Because I'm stupid or lazy!"
05:16:40 * Jafet stows the hand puppet
05:16:54 <Phyx-> > fromMaybe 0 Nothing
05:16:55 <lambdabot>   0
05:17:26 <Apocalisp> data Foo a b = Foo (a -> (Foo a b, b))
05:17:51 <Jafet> :t unfoldr
05:17:52 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
05:17:55 <Apocalisp> Oh it's a Mealy machine
05:23:15 <Xilon> Hmm, the Cabal 1.10 API docs mention cabal-test-quickcheck2, but I'm not able to find it on hackage?
05:23:52 <Xilon> cabal-test seems to be unrelated
05:32:50 <dcoutts_> Xilon: you can only use the test type exitcode-stdio-1.0 in the current release
05:33:34 <dcoutts_> Phyx-: hia, yeah, sorry I've not been able to apply that at the moment due to too many other simultaneous changes
05:33:49 <dcoutts_> Phyx-: and I also admit that I've not reviewed it properly
05:34:10 <_mpu> :t callcc
05:34:11 <lambdabot> Not in scope: `callcc'
05:34:16 <sipa> :t callCC
05:34:17 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
05:34:23 <_mpu> sipa: thanks
05:34:39 <foobuz> @pointfree \x -> x ++ reverse x
05:34:39 <lambdabot> Unknown command, try @list
05:34:46 <foobuz> @pf \x -> x ++ reverse x
05:34:46 <lambdabot> Maybe you meant: bf pl
05:34:50 <foobuz> @pl \x -> x ++ reverse x
05:34:50 <lambdabot> ap (++) reverse
05:36:14 <Phyx-> dcoutts_: ah ok, no prob. there's an issue with that I changed *too* much in that version I sent. It makes some hooks in Setup.lhs expect a Cabal () instead of IO (). I've been a bit too busy to fix it. But i'm done with my uni requirements soon and then I'll fix the issues I've found myself
05:36:29 <dcoutts_> Phyx-: ok, so there's detailed stuff about the patch, but then also things where I'd do the monad rather differently
05:37:04 <dcoutts_> Phyx-: and yeah, there will be tricky things to work out in integration and how it affects hooks
05:37:36 <foobuz> :t reverse >>= (++)
05:37:38 <lambdabot> forall a. [a] -> [a]
05:37:53 <foobuz> @eval
05:37:58 <foobuz> @eval fpoo
05:38:17 <Phyx-> dcoutts_: ah ok, I modelled the monad after the GHC Api, whenever you get a chance just sent me what you were thinking off for the monad
05:38:22 <dcoutts_> Phyx-: I'd suggest for the moment not trying to do a wholesale conversion but limiting the patch to making a new monad
05:39:09 <dcoutts_> Phyx-: yeah, so I'd like to go further, I'd like to lift it out of IO
05:39:18 <dcoutts_> and use an interpreter approach
05:39:28 <dcoutts_> rather than passing everything in, like loggers etc
05:41:04 <dcoutts_> Phyx-: other difficulty is that at the moment the Cabal lib cannot depend on mtl, since it's not a core lib
05:41:12 <dcoutts_> though we may be able to use bytestring these days
05:42:17 <Phyx-> ah, hmm. I had kept in mind the least amount of effort required to add the monad, most functions were IO. so i needed to be able to use liftIO, which is why it's an instance of monadIO
05:43:02 <Phyx-> dcoutts_: ah, for some reason I always thought mtl was a core lib, But yeah ok, that's a problem
05:43:43 <dcoutts_> Phyx-: I plan to split the Cabal lib into the declarative bit, and the simple build system.
05:43:46 <dcoutts_> that'll help
05:43:57 * dcoutts_ has to disappear for a bit
05:44:06 <Phyx-> ah ok, makes sense
05:44:10 <Phyx-> ok, :) ttyl
05:59:31 <jonkri> is there a way i can construct a http://hackage.haskell.org/packages/archive/xml-types/0.2/doc/html/Data-XML-Types.html#t:Name without using OverloadedStrings?
06:00:43 <sipa> fromString "blabla"
06:00:45 <sipa> ?
06:01:44 <quicksilver> jonkri: the constructor looks like it is public to me
06:01:58 <quicksilver> Name "my-name" Nothing Nothing
06:06:19 <nyuszika7h> Hi!
06:07:27 <nyuszika7h> `let add1 x = x + 1 in add1 5` nice, but do I need to redefine it every time I use it? :/
06:08:09 <Axman6> no? why would you?
06:08:19 <nyuszika7h> then how to use it after I define it?
06:08:47 <quicksilver> put it in file, normally, just as "add1 x = x + 1"
06:08:53 <Axman6> where are you trying to use it?
06:08:58 <jonkri> quicksilver, could that work when Text is Data.Text.Internal.Text? and would i not need to pack "my-name"?
06:09:00 <nyuszika7h> tryhaskell.org
06:09:07 <quicksilver> if you want it to hang around at the ghci prompt you can do "let add1 x = x + 1"
06:09:08 <jonkri> sipa, thanks, missed the typable :)
06:09:28 <quicksilver> jonkri: Ah, right. Missed that it was Text not String.
06:09:56 <quicksilver> jonkri: Name (pack "myname") Nothing Nothing, then.
06:10:45 <Xilon> nyuszika7h: Not sure about tryhaskell.org, but you should be able to just drop the "in add1 5", then use it later: add1 5
06:15:23 <Xilon> Hmm doesn't seem to work...
06:17:44 <jonkri> quicksilver, wouldn't pack result in a Data.Text and not Data.Text.Internal.Text?
06:18:32 <Axman6> jonkri: they're almost certainly the same type
06:19:53 <jonkri> Axman6, oh, the error i got had to do with laziness
06:20:01 <jonkri> thanks :)
06:26:44 <atp> type system question: is it possible (using rank 2 types, for example) to have a pair that looks like forall a . (S a, T a), i.e. where we don't care what a is, just that it's the same?
06:27:27 <atp> i tried something like data Wrapper = Wrapper forall a . (S a, T a) but then I couldn't actually get the pieces out of the wrapper
06:27:43 * hackagebot netlines 0.4.0 - Enumerator tools for text-based network protocols  http://hackage.haskell.org/package/netlines-0.4.0 (ErtugrulSoeylemez)
06:28:43 * hackagebot ihttp 0.1.0 - Incremental HTTP iteratee  http://hackage.haskell.org/package/ihttp-0.1.0 (ErtugrulSoeylemez)
06:29:04 <atp> the idea here is a concurrency application: i have a monadic value m a and an MVar a, and I want to execute m a in another thread and have it pass the extracted value back to me in the other thread
06:30:06 <atp> basically the monad in question is a state transformer around the io monad and each thread has different state
06:30:37 <atp> and i'd like to be able to pass an action over to another thread to be executed
06:32:16 <atp> i could wrap the a in Dynamic to get around the typechecker but really it seems like i should be able to tell GHC that the a in the m a is the same as the a in the MVar a without explicitly saying what that a is, because it doesn't matter
06:33:09 <atp> any ideas?
06:36:23 <ski> atp : it sounds like you actually want `exists a. (S a,T a)'
06:36:48 <mm_freak> rather sounds like atp doesn't need anything special at all
06:37:05 <ski> yeah, probably a closure would work just as fine, in this case
06:37:06 <mm_freak> MVar sounds fine for that purpose
06:37:18 <ski> ("wants" is different from "needs")
06:39:16 <atp> ski: you're right, exists is closer to what i want
06:39:55 <ski> atp : yeah, but then the way to encode this in current haskell (extension) syntax is `data Wrapper = forall a. Wrap (S a,T a)'
06:40:09 <ski> compare
06:40:39 <ski>   forall a. Wrap (_ :: (S a,T a)) :: Wrapper
06:40:49 <ski>   forall a. Wrap :: (S a,T a) -> Wrapper
06:40:58 <ski>   Wrap :: forall a. ((S a,T a) -> Wrapper)
06:41:06 <ski>   Wrap :: (exists a. (S a,T a)) -> Wrapper
06:41:38 <ski> (that's more or less the reason for using the `forall' keyword for effectively encoding an `exists')
06:41:54 <atp> i see
06:42:50 <atp> ski: thanks for your help, i think i see the way forward now
06:43:39 <ski> atp : anyway, if you can write to the `MVar a' in the `m' monad, then you can do something like `lift . putMVar mvar =<< ma' instead of `Wrap (ma,mvar)'
06:44:06 <ski> so then you get `m ()', instead of `exists a. (m a,MVar a)'
06:44:29 <ski> (i suspect mm_freak probably had something like this in mind)
06:44:51 <ski> .. or is the point that you haven't decided yet which thread should execute the `m a' action ?
06:45:37 <ski> (i.e. the executor of the `m a' action is supposed to be a different thread from the one which does the `putMVar' ?)
06:46:34 <mm_freak> i don't see why forall/exists should be needed at all
06:46:42 <mm_freak> especially with that wrapper you won't do much
06:47:30 <ski> if the `m' monad there can execute the `putMVar', then an existential is probably not needed
06:47:34 <atp> ski, mm_freak : yes, there's a much simpler way to do this. i just thought i saw a way to use existential quantification (which I'm not terribly familiar with in Haskell) and decided to play around
06:47:45 <mm_freak> data ThreadMessage = DoAndReport (IO a) (a -> IO ())
06:48:12 <mm_freak> putMVar commandVar $ ThreadMessage compute (putMVar resultVar)
06:48:24 <mm_freak> result <- takeMVar resultVar
06:48:25 <ski> atp : well, if a closure suffice, then it's probably overkill to use an existential (though sometimes it can be interesting to try it out, and maybe it can have different modularity sometimes)
06:48:31 <mm_freak> this is even easier with STM
06:48:48 <ski> mm_freak : where is `a' bound ?
06:49:24 <Cale> atp: State transforming the IO monad is something which I usually have reservations about doing, because the IO monad already has quite a lot of facilities for managing state.
06:49:35 <mm_freak> ski: usually you would use a concrete type, because otherwise it makes little sense to communicate to an existing thread
06:49:44 <Cale> (this is unrelated to your actual question, I'm aware :)
06:50:10 <ski> mm_freak : i was thinking that maybe the point was to execute the `IO a' and the `a -> IO ()' in different threads ..
06:50:18 <mm_freak> ski: but yes, if you want it to be universal, use an existential type
06:50:28 <atp> Cale: yeah, but I have an easier time reasoning about the state monad than about iorefs
06:50:32 <mm_freak> ski: yes, that's how my example works
06:50:38 <atp> Cale: iorefs seem too magical and black boxy
06:50:52 <atp> Cale: particularly in a multi-threaded situation, no?
06:50:54 <ski> also `IORef's are harder to undo
06:50:56 <Cale> atp: Well, they're like mutable references in any language.
06:51:11 <atp> ski: yes, that too
06:51:20 <mm_freak> rather than IORef i always preferred to use a Ptr
06:51:26 <ski> (of course, you can use a single `IORef' which contains a value with no `IORef's inside)
06:51:40 <mm_freak> faster and no illusion of safety =)
06:52:07 <Cale> mm_freak: That seems kinda strange.
06:52:31 <mm_freak> Cale: ?
06:52:55 <Cale> mm_freak: Well, you would be giving up some real safety that IORefs give you.
06:53:11 <Cale> (not just illusory safety)
06:53:22 <ski> (maybe mm_freak is determined to follow the motto "fail faster !" ?)
06:53:23 <mm_freak> Cale: that's my point =)
06:54:00 <ski> (i.e. if something is bound to fail, it is better to discover that earlier than later (a useful thing to consider, when doing backtracking))
06:54:07 <atp> personally, the more like the lambda calculus my program feels, the happier i am inside
06:54:23 <Cale> atp: How about using actual lambdas then? ;)
06:54:33 <mm_freak> but seriously it seems weird to me to use stateful variables for a single value…  for single values there are state monads, and for multiple values there are mutable arrays (perhaps in combination with state monads)
06:54:59 <Cale> I've often found that using StateT over IO isn't really any better than just passing parameters.
06:55:04 <mm_freak> other than global variable hacks i see no use case for IORef
06:55:10 <mjrosenb> Cale: lambdas in lambda calculus? don't be absurd.  everyone knows that lambda calculus is based on composition!
06:55:17 <ski> mm_freak : state monads do something different to references
06:55:30 <Cale> mjrosenb: what?
06:55:34 <mm_freak> Cale: StateT is better, when you use the state in two levels, which have many levels inbetween
06:55:43 <Cale> mm_freak: levels?
06:55:52 <atp> yeah, i agree with mm_freak
06:55:54 * ski thought it was recursive functions which had composition as a primitive
06:56:03 <atp> like you put one stateT inside an ErrorT and another one outside it
06:56:04 <mm_freak> Cale: call levels
06:56:05 <ski> (.. and categories)
06:56:10 <mietek> Does anyone know of a good article comparing Haskell with F#?
06:56:11 <mm_freak> function call levels
06:56:23 <mietek> And I don't mean Harrop's FUD
06:56:24 <mm_freak> often application configuration is only used in very deep call levels
06:56:26 <mjrosenb> Cale: a joke.  mostly at the expense of people who seem to spend their time getting rid of \ characters from their haskell code.
06:56:27 <Cale> mm_freak: *maybe*
06:56:34 <ski> mm_freak : do you see any value in `STRef s' ?
06:56:47 <Cale> mm_freak: but in exchange, you make lots and lots of other things awkward
06:56:48 <mm_freak> ski: nope
06:56:54 <Cale> like, actual IO actions :P
06:57:15 <Cale> You pay for it by having to lift things, and making higher order functions on IO awkward.
06:57:15 <mm_freak> Cale: if your application is written properly with separation of matters, then IO is not awkward =)
06:57:16 <ski> `STRef s' and `IORef' allow you to dynamically allocate new cells in the ambient state of the state monad
06:57:51 <mm_freak> Cale: it sounds like it would be a problem, but practice has shown for me that it's never a real problem
06:58:22 <Cale> The syntactic overhead of having to lift your IO actions and dealing with things like how to manage forkIO is enough that it often outweighs the benefits of using StateT in the first place.
06:58:50 <mm_freak> Cale: there is little overhead
06:59:07 <Cale> There's also little overhead to parameter passing :P
06:59:10 <mm_freak> Cale: but maybe your coding style differs from mine =)
06:59:27 <mm_freak> i have no problem with explicit parameter passing…  i do that often in tight loops
06:59:35 <Cale> I mean, we're not talking about very many characters textually in either case :P
06:59:50 <mm_freak> but not when i want to pass application configuration to 90% of all functions ;)
07:00:02 <Cale> StateT has its place, but I prefer things like StateT over [] to StateT over IO :P
07:00:27 <mm_freak> Cale: you would probably throw up, if you saw some of the monads i use ;)
07:00:30 <ski> @umtl StateT s (ContT o IO) a
07:00:31 <lambdabot> s -> (a -> s -> IO o) -> IO o
07:00:42 <Cale> mm_freak: If you bundle that configuration up properly, it's not much of a problem.
07:01:00 <mm_freak> MonadIO m => MaybeT r (Iteratee ByteString (StateT r' SomeConfig m)) Result
07:01:02 <Cale> If you have a dozen extra parameters on every function, that's a problem.
07:01:02 <mm_freak> ;)
07:02:13 <ski> mm_freak : heh, that reminds me i had something like `data M a = MkM (forall m. MonadFoo m => ..m..a)' in one application :)
07:02:44 <mm_freak> hehe
07:02:55 <mm_freak> i think you can use newtype in that case
07:03:09 <ski> oh, i probably used `newtype', yes
07:03:57 <mm_freak> Cale: my point is that you can save the explicit passing without giving up static guarantees, and often in further stages of the application development i was glad that i had done it that way
07:04:12 <ski> the point in my case was that i wanted to have `M a' be either `IO a' or `FooT IO a' or `FooT (FooT IO) a', or `FooT (FooT (FooT IO)) a',&c. .. whichever of those i wanted to use at the moment
07:04:42 <mm_freak> ski: that cries for an existential type, no?
07:05:06 <ski> all the levels had to support `MonadFoo'
07:05:21 <ski> an existential wouldn't help
07:05:28 <mm_freak> ah, i see
07:06:08 <ski> i wanted an operation `M X -> M Y -> M Z', where if the caller used `n' levels of `FooT' in `M Z', then `n+1' levels would be used in `M X' and `n' levels would be used in `M Y'
07:44:20 <revenantphx> Dear #haskell,
07:44:30 <revenantphx> is it possible to write conways game of life in place?
07:44:35 <revenantphx> Sincerely, Dylan
07:44:45 <joe6> is it possible to use haskell to generate C code? similar to using haskell to generate LLVM assembly?
07:44:54 <revenantphx> (well, this is actually a C question, but knowing in haskell would help too)
07:45:03 <merijn> joe6: Yes, via-c
07:45:15 <joe6> merijn, thanks.
07:45:15 <mauke> joe6: yes, putStr
07:45:31 <merijn> joe6: Of course, whether it will suit your purposes, depends on what you're trying
07:45:32 <Veinor> revenantphx: you mean in constant auxiliary storage?
07:45:38 <merijn> mauke: >.>
07:45:39 <revenantphx> like, one buffer
07:45:48 <revenantphx> iterate through it without using an auxiliary
07:45:52 <revenantphx> (IS IT POSSIBLE?)
07:45:52 <Veinor> i doubt it.
07:46:00 <revenantphx> hmk
07:46:10 <merijn> revenantphx: Depends, will a Monte Carlo implementation suffice? :D
07:46:44 <Veinor> consider:
07:46:46 <Veinor> 00
07:46:48 <Veinor> 11
07:46:55 <Veinor> after you update the upper-left, you have no way of knowing whether it was 0 or 1 before-hand
07:47:01 <Veinor> because either is consistent
07:47:50 * roconnor strongly considers unsubscribing ot the compsci reddit
07:48:17 <djahandarie> lol
07:48:27 <Veinor> I mean this isn't an iron-clad proof, you might be able to do something tricky. but i highly doubt it is.
07:48:31 <djahandarie> I'm currently subscribed to prog, haskell, math, dependent_types
07:48:47 <djahandarie> I mainly ignore prog
07:48:54 <djahandarie> And math :P
07:49:05 <roconnor> I think compsci is quickly becoming worse than prog
07:49:15 <roconnor> which is pretty impressive
07:49:29 <Axman6> how so?
07:50:12 <merijn> proggit I check occasionally when I get bored, then I remember why I only use reddit for funny pictures of cats...
07:50:23 <roconnor> http://www.reddit.com/r/compsci/comments/g49sd/studying_for_algorithms_midterm_just_had_to_say/
07:50:45 <Ptival> do you store your states as bits or a bigger representation?
07:50:46 <djahandarie> sfw?
07:50:53 <roconnor> very sfw
07:51:09 <Veinor> Ptival: 'you store them as two bits, the previous state and the current state' ;)
07:51:14 <djahandarie> *sigh*
07:51:24 <Ptival> Veinor: that's what I was going to suggest
07:51:36 <roconnor> djahandarie: I'm just glad I'm not Knuth
07:51:36 <Veinor> that's no better memory-wise though
07:51:43 <revenantphx> roconnor: nice macro
07:52:36 <imc> hello, is there a "modulo" type in haskell? (i.e. a Num 'x' s.t. x + y == (x + y) `mod` given modulo ?)
07:52:49 <Veinor> :t mod
07:52:50 <lambdabot> forall a. (Integral a) => a -> a -> a
07:53:01 <Botje_> imc: you can create one with newtype
07:53:02 <merijn> Veinor: That's not what he means
07:53:22 <Veinor> ahh
07:53:25 <merijn> He wants an instance of Num which implements arithmetic in mod N I think
07:53:56 <roconnor> it's not hard to build such an instance for specific ns
07:54:29 <imc> Botje_: not sure i understood
07:55:15 <Botje_> imc: you can do newtype Modx = Modx Int and then define a Num instance for Modx
07:55:23 <imc> oh right
07:55:26 <merijn> imc: newtype lets you take an existing data type (like Int) and specify new typeclass implementations for it
07:55:43 <imc> okay
07:56:12 <imc> i tought that its use were so common that someone already wrote that
07:56:46 <mauke> oleg did
07:57:28 <Veinor> there's no way to say, like, x :: Modulo 5
07:57:50 <imc> okay
07:58:03 <Phyx-> oleg is like southpark, he did everything
07:58:26 <djahandarie> Veinor, sure there is
07:58:38 <djahandarie> I'm not sure that's how oleg did it though
07:58:54 <djahandarie> (Well, sans that you can write a numerical literal in the type signature)
07:58:54 <Veinor> djahandarie: how?
07:59:02 <Phyx-> err, damnit, i ruined my own joke
07:59:10 <Phyx-> oleg is like the simpsons, he did everything
08:00:00 <djahandarie> Veinor, should be fairly simple if you reify the type-level nat
08:00:02 * ski . o O ( `moduloNum :: Integral i => i -> exists n. Integral n *> ()' )
08:00:31 <ski> (or something like that ..)
08:00:42 <roconnor> I meat oleg a few months ago
08:00:46 <Veinor> oh, sure
08:00:52 <roconnor> Seven feet tall he was,
08:00:58 <roconnor> with arms like tree trunks.
08:01:04 <djahandarie> Haha
08:01:08 <roconnor> His eyes were like steel: cold, hard.
08:01:08 <mjrosenb> roconnor: was he made out of meat?
08:01:20 <roconnor> Had a shock of hair, red, like the fires of Hell.
08:02:58 <revenantphx> He has seven mouths speaking in six languages, the seventh singing the song that breaks referential transparency.
08:04:20 <Phyx-> sounds like he's a hit at parties
08:05:50 <Botje_> roconnor: that sure puts some context to the 'so Oleg cornered me in a pub and explained delimited continuations to me' quote
08:06:15 <merijn> :D
08:06:39 <Veinor> for he on honey-dew hath fed, and drunk the milk of dependent types
08:06:47 <merijn> I think Oleg would implode my brain if he opened his mouth in my general vicinity
08:07:22 <poucet> @quote oleg
08:07:22 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
08:07:31 <revenantphx> Normal fanboism is annoying. Computer science fanboism is amusing. Haskell fanboism is just downright great.
08:07:33 <mjrosenb> Botje_: i've heard of delimited continuations; you know if there are any papers on it?
08:07:44 <Botje_> mjrosenb: lots.
08:08:05 <Botje_> mjrosenb: the best introduction is a presentation by oleg himself
08:08:05 <mjrosenb> FFFFFFFFFFFFFFFFFF
08:08:06 <Veinor> revenantphx: i keep parsing that as fanbo-ism
08:08:16 <Veinor> (i know the correct parse)
08:08:19 <revenantphx> what.
08:08:28 <mjrosenb> chrome seems to like redirecting lambda-the-ultimate.org to localhost:631
08:08:29 <revenantphx> It's not an ambiguous grammar.
08:08:32 <mjrosenb> thanks chrome
08:08:32 <revenantphx> You're adding tokens.
08:08:45 <revenantphx> mjrosenb: well, is that accurate?
08:08:50 <Botje_> mjrosenb: it's just shortcircuiting the way to your printer, see? :)
08:08:51 <revenantphx> …I'm guessing not.
08:08:51 <Veinor> ... i think we're miscommunicating here
08:09:14 <roconnor> @quote tolkiens
08:09:14 <lambdabot> No quotes match. You untyped fool!
08:09:44 <merijn> How many Olegs do the Epigram and Oleg (hmm, I wonder if that's a coincidence :p) papers rate as?
08:09:50 <revenantphx> Awwww
08:09:53 <revenantphx> my quote didn't come up
08:10:46 <revenantphx> Actually, I don't think it was quote,d just tweeted.
08:10:52 <Kaidelong> Epigram has one of the most bizzare syntaxes I've ever seen
08:10:54 <roconnor> @remember revenantphx A parser that reads in images in Elvish and out puts a list of... wait for it... Tolkiens.
08:10:54 <lambdabot> Okay.
08:11:00 <Kaidelong> that said, it may well be a very good one
08:11:03 <revenantphx> roconnor: :)
08:11:07 <Kaidelong> I have no idea
08:11:21 <roconnor> @forget revenantphx A parser that reads in images in Elvish and out puts a list of... wait for it... Tolkiens.
08:11:21 <lambdabot> Done.
08:11:28 <revenantphx> @quote Tolkiens
08:11:29 <lambdabot> No quotes match. The more you drive -- the dumber you get.
08:11:31 <revenantphx> D:
08:11:49 <roconnor> @remember revenantphx You know what that makes me think needs to
08:11:49 <lambdabot> Good to know.
08:11:50 <roconnor>  be done? A parser that reads in images in Elvish and out puts a list of... wait for it... Tolkiens.
08:11:53 <roconnor> crap
08:11:53 <merijn> Kaidelong: I don't really know the latest Epigram syntax. I gave up understanding The View From the Left and moved straight to Conor's PhD thesis on Oleg, things make loads more sense now
08:12:30 <merijn> In an "I stared into the dark abyss of Elder Gods and am incapable of telling whether I'm slowly getting smarter or losing my mind" sort of way
08:12:37 <revenantphx> @forget revenantphx You know what that makes me think needs to
08:12:37 <lambdabot> No match.
08:12:59 <roconnor> @quote Tolkiens
08:12:59 <lambdabot> revenantphx says: You know what that makes me think needs to be done? A parser that reads in images in Elvish and out puts a list of... wait for it... Tolkiens.
08:13:10 <revenantphx> oh, it worked.
08:13:11 <revenantphx> awesome
08:13:12 <roconnor> I fixed it in a pm
08:13:15 <revenantphx> better than my other quote
08:13:19 <revenantphx> @quote balls
08:13:20 <lambdabot> boegel says: * boegel goes to inflate Itkovian's balls
08:13:23 <revenantphx> @quote balls
08:13:23 <lambdabot> boegel says: * boegel goes to inflate Itkovian's balls
08:13:27 <revenantphx> @quote revenantphx
08:13:27 <lambdabot> revenantphx says: You know what that makes me think needs to be done? A parser that reads in images in Elvish and out puts a list of... wait for it... Tolkiens.
08:13:35 <revenantphx> @quote revenantphx
08:13:35 <lambdabot> revenantphx says: You don't need category theory to understand Haskell, though you may need it to understand #haskell.
08:13:39 <revenantphx> ...hrmmm
08:13:45 <revenantphx> @quote revenantphx Cale
08:13:45 <lambdabot> revenantphx says: Cale... I like your balls. They're shiny. You obviously take good care of them.
08:13:52 <revenantphx> Yeah there we go.
08:14:09 <merijn> I kinda like the one quote I'm mentioned in :p
08:14:17 <merijn> @quote merijn.
08:14:17 <lambdabot> roconnor says: <roconnor> merijn: I got into Haskell from Coq. <xplat> that's like getting into drinking through heroin.
08:14:33 <revenantphx> hahaha
08:14:39 <Veinor> haha
08:14:39 <revenantphx> @quote fugues
08:14:40 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
08:14:43 <revenantphx> :)
08:14:56 <Kaidelong> @quote Veinor
08:14:56 <lambdabot> Veinor says: just remember: you can't spell fundeps without fun.
08:15:02 <Kaidelong> oh my
08:15:06 <Veinor> it's true!
08:15:14 <Kaidelong> is this like Dwarf Fortress fun?
08:15:19 <Axman6> phundeps!
08:15:35 <mauke> preflex: quote
08:15:46 <preflex>  <erikh> I wonder if a vampiric blow job would be better or worse than a regular blow job
08:15:48 <Veinor> it might be
08:15:53 <Veinor> ...
08:15:54 <mauke> preflex: that was off topic
08:15:55 <revenantphx> ...
08:15:56 <Veinor> that's a hell of a quote there
08:16:10 <revenantphx> What does preflex do again?
08:16:21 <Axman6> preflex: seen revenantphx 
08:16:21 <preflex>  revenantphx was last seen on #haskell 10 seconds ago, saying: What does preflex do again?
08:16:23 <Axman6> that
08:16:26 <revenantphx> ah, right.
08:16:28 <Axman6> mainly
08:16:34 <mauke> preflex: quote revenantphx 
08:16:34 <preflex>  no quotes found for revenantphx
08:16:41 <Jafet> preflex, seen preflex
08:16:41 <preflex>  what
08:16:42 <revenantphx> preflex: quote mauke
08:16:43 <preflex>  <mauke> haskell software should move from alpha to beta to eta, then lambda
08:16:51 <revenantphx> T_T
08:17:19 <Veinor> preflex: quote
08:17:20 <preflex>  <pndc> I am reminded of a sign put up on an electronics lab to keep the cleaners out: "Danger: 12,000 millivolts!"
08:17:25 <merijn> I just keep a stripped version of lambdabot quotes on my disk so I can limit it to the more fun ones :p
08:17:40 <merijn> @quote Adamant Oleg
08:17:40 <lambdabot> Adamant says: [on the update complexity of Data.Map] I read that as "Oleg(n)"
08:18:14 <Veinor> it takes Oleg O(n) time
08:18:36 <edon> if i have a global state accessible from all threads, i should be using TMVar right?
08:18:42 <Kaidelong> @quote object
08:18:42 <lambdabot> psykotic says: monochrom, I'm reminded me of that Alan Kay quote. "i invented the term 'object-oriented' and i can tell you c++ wasn't what i had in mind"
08:18:47 <azaq23> preflex: cdecl int (*p[2])(void)
08:18:47 <preflex>  p: array[2] of pointer to function(void) returning int
08:18:48 <Kaidelong> err
08:19:02 <Kaidelong> @quote ddarius object
08:19:02 <lambdabot> ddarius says: I can make a category whose arrows are (former) presidents of the United States and objects are beach balls.
08:19:06 <Kaidelong> there we go
08:19:09 <revenantphx> edon: MVar could work too.
08:19:14 <revenantphx> edon: TMVar is STM, no
08:19:15 <revenantphx> ?
08:19:18 <Jafet> O(n) olegs sounds terrifying for complexity
08:19:20 <mauke> preflex: quote . object
08:19:21 <merijn> Anyhoo, time to go home
08:19:22 <preflex>  <cale> There should be a website called "Static Equilibrium or Not" where you rate pictures according to whether you think the depicted objects are in static equilibrium.
08:19:25 <Axman6> edon: depends, I'd use MVars unless you need the atomicity of STM
08:19:35 <revenantphx> …I want to make that website.
08:19:42 <merijn> Cale must be fun at parties :p
08:19:44 <edon> yeah i need atomicity, i'm gonna write/read to them
08:20:20 <revenantphx> I can only imagine the horror of a #haskell kegger.
08:20:42 <Axman6> edon: MVars offer that too, if you only need to use one.if you need to make atomic transations involving multiple vars, then you should use TMVars, if it's only one, you only need MVars
08:21:01 <revenantphx> I'm sure someone would walk in late, saying that they were late because they botched the heuristics on their A* driving directions program.
08:21:21 <edon> Axman6: ah i see, thanks :)
08:39:25 <sphynx> what is the most natural way to implement Universal Machine from ICFP contest in Haskell? http://www.boundvariable.org/um-spec.txt
08:39:38 <sphynx> I'm thinking about using ST monad and STUArray
08:40:33 * hackagebot web-routes 0.24.1 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.24.1 (JeremyShaw)
08:41:35 * hackagebot web-routes-mtl 0.20.1 - Extends web-routes with mtl-based MonadIO / MonadTrans RouteT instances  http://hackage.haskell.org/package/web-routes-mtl-0.20.1 (JeremyShaw)
08:41:37 * hackagebot web-routes-happstack 0.22.1 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.22.1 (JeremyShaw)
08:41:39 * hackagebot web-routes-hsp 0.21.3 - Adds XMLGenerator instance for RouteT monad  http://hackage.haskell.org/package/web-routes-hsp-0.21.3 (JeremyShaw)
08:46:02 <_Ray_> hey question. in the category hask, the morphisms are functions, and the objects are... types? or are they the values?
08:46:41 <_Ray_> does a morphism in hask map a type to another?
08:47:18 <yitz> _Ray_: types
08:48:01 <_Ray_> alright :) thanks
08:48:03 <yitz> _Ray_: just like in, say, Set, the objects are sets, not the elements of the set.
08:48:14 <_Ray_> right, right
08:54:05 <freiksenet> I want to do data structures project for my uni degree in Haskell, I wonder if there are some interesting data structures that hasn't been implemented too many times. Usually people do some trivialities like AVL/RB trees, but it probably should be something more complex in my case
08:54:33 <revenantphx> hexagonal, bidirectional mesh
08:54:34 <revenantphx> somehow.
08:54:35 <Botje_> freiksenet: finger trees are an obvious candidate
08:54:36 <revenantphx> >.>
08:54:49 <freiksenet> Botje_: finger trees are already in haskell
08:55:27 <Botje_> how about ropes?
08:55:38 <Botje_> although i think they're also on hackage
08:55:50 <Botje_> yeah, they are
08:55:58 <_Ray_> spatial data structures?
08:56:42 <sphynx> ah, I see, here we have lots of UMs from ICFP contest in Haskell :)  http://www.cse.unsw.edu.au/~dons/um.html
08:56:43 <freiksenet> _Ray_: like quadtrees?
08:57:02 <_Ray_> sure, or octrees
08:57:53 <freiksenet> sounds interesting, but I am already doing quadtrees in clojure for some other course :)
08:58:03 <djahandarie> Veinor, http://hpaste.org/44791 had to go to work but here is what I was talking about :P
09:05:00 <_Ray_> so to get it straight, a functor in hask maps Bool to [Bool], but the unit morphism maps True to [True]?
09:05:09 <_Ray_> (called "return" in haskell IIRC)
09:07:56 <doserj> _Ray_: the list functor does that, yes. There are also other functors.
09:08:02 <_Ray_> right, right
09:09:50 <djahandarie> "functor in hask" is a little sloppy
09:10:12 <djahandarie> "Endofunctor of Hask" would be more accurate
09:10:13 <_Ray_> endofunctor in hask? functor from hask to hask?
09:10:15 <_Ray_> ah
09:10:42 <edon> can i make a thread to wait on two resources, a handle and a MVar for example? How's it done?
09:12:29 <mauke> edon: sequentially
09:13:46 <edon> mauke: what if i don't know which will happen first
09:13:54 <copumpkin> is there a builtin method for rounding a double to a specific number of significant figures?
09:13:58 <mauke> edon: does it matter?
09:14:09 <mauke> you're going to wait for them both anyway
09:14:46 <djahandarie> What happened to the hpaste bot btw?
09:14:50 <copumpkin> @hoogle Double -> Int -> Double
09:14:51 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
09:14:51 <lambdabot> Prelude (^) :: (Num a, Integral b) => a -> b -> a
09:14:51 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
09:14:59 <copumpkin> scaleFloat sounds good
09:15:10 <djahandarie> > scaleFloat 3 0.4256223412
09:15:11 <copumpkin> oh maybe not
09:15:11 <lambdabot>   3.4049787296
09:15:12 <mauke> preflex: seen hpaste
09:15:13 <preflex>  hpaste was last seen on #haskell 3 days, 13 hours, 51 minutes and 49 seconds ago, saying: WilliamKnop pasted "GHC: Core lint error"  http://hpaste.org/44717
09:18:52 <edon> mauke: if i'm doing something like: l <- hGetLine h; t <- takeMVar mvar; and some other thread puts something on that mvar it will wakeup the thread?
09:19:37 <mauke> depends on where it's sleeping
09:21:39 <tswett> :t intercalate
09:21:39 <lambdabot> forall a. [a] -> [[a]] -> [a]
09:21:58 <tswett> :t intersperse
09:21:59 <lambdabot> forall a. a -> [a] -> [a]
09:22:55 <yitz> edon: wait on an empty MVar. when one of the threads is ready, let it announce who it is in the MVar.
09:26:30 <_Ray_> Hrmph. In what way is 'join' like multiplication and 'unit' like the identity element? I saw that comparisson in a monad introduction and can't wrap my head around it. It seems one couldn't "join unit", since join is a morphism that takes elements of a type B to a type A, but unit is also a morphism from type A to type B.
09:27:07 <quicksilver> _Ray_: in an algebraic sense
09:27:29 <quicksilver> _Ray_: join goes from "m m" to "m" which looks like a multiplication
09:28:08 <_Ray_> right, but unit isn't an m, unit goes from n to m
09:28:18 <roconnor> Unit goes from Id to m
09:28:55 <_Ray_> Hrm. How's that? What's Id?
09:29:11 <roconnor> Id is the identity functor
09:29:13 <_Ray_> (Sorry, not new to Haskell, but new to the category theory aspect of it)
09:29:20 <quicksilver> unit "is an m" in a sense.
09:29:23 <roconnor> return :: forall a. Id a -> m a
09:29:28 <quicksilver> at a higher algebraic level.
09:29:33 <roconnor> return :: Id => m
09:29:41 <roconnor> where => means natural transformation
09:29:49 <roconnor> aka F => G := forall a. F a -> G a.
09:30:23 <_Ray_> oh, I think I see what you're saying. if I have a [Bool], which is a "List Bool", I could also consider Bool to be "Id Bool"?
09:30:36 <quicksilver> yes.
09:31:13 <roconnor> so join :: (m . m) => m  and return :: Id => m
09:31:45 * hackagebot bindings-gts 0.1.1 - Low level bindings supporting GTS, the GNU Triangulated Surface Library  http://hackage.haskell.org/package/bindings-gts-0.1.1 (JoelCrisp)
09:31:47 <_Ray_> What would the syntax "m a" represent?
09:31:59 <roconnor> compare to the signature of a monoid where you have a type s and mult :: (s , s) -> s and identity :: () -> s
09:32:26 <roconnor> (note though I change the dot in (m . m) to a comma in (s , s) )
09:32:42 <_Ray_> hrm, I hadn't seen the identity described as () -> s
09:33:00 <_Ray_> I'd just call it an s, since it is a member of the set
09:33:06 <roconnor> _Ray_: it is unusual in algebra to describe identity like that, but it is common in category theory.
09:33:21 <roconnor> _Ray_: since in Category they cannot directly talk about elements of sets
09:33:27 <roconnor> *Category Theory
09:33:37 <_Ray_> oh, right. they're interested in the morphisms between them?
09:33:55 <roconnor> _Ray_: ya, so they fake talking about points by talking about morphisms from ()
09:34:16 <_Ray_> what would () be, formally?
09:34:20 <_Ray_> an empty category?
09:35:27 <Eduard_Munteanu> AFAIK, you could interpret "m a" as the image of 'a' through the functor 'm'.
09:35:58 <roconnor> _Ray_: (), called 1 in Category Theory, is the terminal object.
09:36:15 <roconnor> _Ray_: it is an object which for every other object A there is a unique morphism to it
09:36:20 <roconnor> A -> ()
09:36:28 <_Ray_> makes sense
09:36:58 <roconnor> In the category of sets it is any set that as exactly one member
09:37:03 <roconnor> but it doesn't matter what that member is.
09:38:08 <Eduard_Munteanu> Yeah, arrows are constant functions mapping anything to that member.
09:38:31 <roconnor> The relvent property we care about here is that (() , A) ~ A ~ (A , ()) are all isomorphic
09:38:57 <_Ray_> right
09:39:13 * _Ray_ now tries to go back and better understand the multiplication analogy
09:39:16 <roconnor> On the monad side, the relvenet property we care about is that (Id . F) ~ F ~ (F . Id) are all isomophic
09:39:41 <roconnor> (notice agian that the comma is turned into a . for composition of functors)
09:39:56 <roconnor> Here Id isn't the terminal object in any sense
09:40:05 <roconnor> but it is the identity for composition.
09:40:40 <roconnor> composition of functors
09:41:00 <_Ray_> right, so I don't care if I get an Id Bool, Bool, or Bool Id
09:41:08 <_Ray_> they're all uniquely determined up to isomorphism
09:41:12 <roconnor> nope
09:41:58 <roconnor> Bool Id isn't well typed.
09:42:49 <_Ray_> oh? wouldn't it be an analogue to multiplying (to the right) by the identity element?
09:43:40 <roconnor> let me see
09:44:24 <roconnor> in the normal monoid case we have identity :: () -> s and mult :: (s,s) -> s
09:44:57 <roconnor> (id *** identity) :: (s, ()) -> (s,s)
09:45:10 <quicksilver> _Ray_: the key point here, I think is that "an element of m" is the same thing as "a function from {1} to m"
09:45:43 <quicksilver> _Ray_: in higher algebraic contexts, like categories, we no longer have elements in the literal sense, but we use morphism "1 -> m" as a kind of proxy for the notion equivalent to elements
09:45:54 <roconnor> isoR . (id *** identity) . mult :: s -> s  where isoR :: s -> (s, ())
09:45:56 <quicksilver> _Ray_: and that's where the "natural xfm from Id to M" comes from.
09:46:08 <_Ray_> {1} being the identity?
09:46:12 <quicksilver> no
09:46:17 <quicksilver> being any set with exactly one element.
09:46:20 <roconnor> so the right identity law for monoids says that  isoR . (id *** identity) . mul = id
09:46:22 <_Ray_> right
09:46:54 <roconnor> for the corresponding law on monads
09:46:57 <_Ray_> roconnor: what does (id *** identity) mean?
09:47:04 <roconnor> @src (***)
09:47:04 <lambdabot> f *** g = first f >>> second g
09:47:13 <roconnor> @type (***)
09:47:14 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:47:24 <_Ray_> :s!
09:47:52 <roconnor> :type let (f *** g) (a,b) = (f a, g b) in (***)
09:47:57 <roconnor> @type let (f *** g) (a,b) = (f a, g b) in (***)
09:47:58 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t2 -> t3) -> (t, t2) -> (t1, t3)
09:48:45 <roconnor> there is a corresponding *** operator on functors
09:49:03 <roconnor> well on natural transformations
09:49:04 <djahandarie> Huh?
09:49:16 <djahandarie> Yeah, would make little sense on a functor
09:49:21 <_Ray_> seems like it's "lifting"
09:49:25 <roconnor> I think it is horizonal composition
09:49:49 <roconnor> @type let (f *** g) = fmap g . f in (***)
09:49:50 <lambdabot> Parse error in pattern
09:50:07 <roconnor> @type let f *** g = fmap g . f in (***)
09:50:08 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b. (Functor f, Functor f1) => f (f1 a) -> (a -> b) -> f (f1 b)
09:51:30 <_Ray_> what would the unit be, in the case of lists? (I gather join is, well, join)
09:51:54 <_Ray_> I was thinking it was f x = [x]?
09:52:09 <roconnor> @type let f *** g = fmap g . f in (***) :: forall f1 f2 g1 g2. Functor f1, Functor g1, Functor f2, Functor g2) => (forall a, f1 a -> f2 a) -> (forall a. g1 a -> g2 a) -> (forall a. f1 (g1 a) -> f2 (g2 a))
09:52:09 <lambdabot> parse error on input `,'
09:52:16 <roconnor> bah
09:52:29 <roconnor> _Ray_ that is correct
09:52:35 <roconnor> @src [] return
09:52:35 <lambdabot> return x    = [x]
09:53:04 <_Ray_> but then, isn't the type of f a -> List a? and not () -> List?
09:53:08 <_Ray_> ... oh...
09:53:13 <roconnor> anyhow there is a corresponding (***) operation on natural transformations, but it is a little unweildy to write in Haskell without some newtype support.
09:53:28 <roconnor> the type of return is Id => LIst
09:53:41 <roconnor> where recalling that F => G is shorthand for (forall a. F a -> G a)
09:53:42 <_Ray_> (a -> List a) <-> (() -> List) a?
09:53:45 <_Ray_> riiight
09:54:07 <_Ray_> I thiiiink I get it now
09:54:46 <roconnor> the version of (***) on natural transformations has type (F1 => G1) -> (F2 => G2) -> (F1 . F2) => (G1 . G2)
09:54:57 <roconnor> it isn't really hard to write.  It basically just uses fmap
09:55:52 <triyo> I got a new Mac and downloaded the latest Haskell Platform. Is there no way to run it without xcode? Can't I use macports to install gcc instead of downloading the big 4GB xcode download file?
09:55:59 <_Ray_> hrm, when I ask ghci about :t return, it says (Monad m) => a -> m a
09:56:28 <djahandarie> @djinn (Functor f1, Functor g1, Functor f2, Functor g2) => (f1 a -> g1 a) -> (f2 a -> g2 a) -> f1 (f2 a) -> g1 (g2 a)
09:56:28 <lambdabot> Error: Class not found: Functor
09:56:33 <djahandarie> :(
09:56:41 <_Ray_> oh right, but we said forall a. a -> m a is the same as writing () => m
09:56:42 <roconnor> _Ray_: ya return is defined for all monads
09:56:46 <roconnor> right
09:56:55 <mauke> > return 42 :: [] Integer
09:56:56 <lambdabot>   [42]
09:57:16 <roconnor> _Ray_, it would be better to use Id or I instead of () when talking about functors.
09:57:23 <_Ray_> alright
09:57:36 <djahandarie> I? I've never seen that used
09:57:41 <djahandarie> Usually I see Id or 1
09:57:46 <_Ray_> right, since () a is weird syntax, Id a looks better
09:57:54 <roconnor> djahandarie: it is on the wikipage for monodial categories
09:59:48 <_Ray_> is that the same => that's happening in (Monad m) => ?
09:59:53 <roconnor> no
09:59:59 <roconnor> it is a totally different meaning
10:00:04 <roconnor> ... I kinda regret using it now
10:00:10 <roconnor> since it is confusing with that
10:00:26 <_Ray_> I had gotten to decompose it into forall a, m. m a -> m m a xD
10:00:36 <roconnor> @type join
10:00:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:01:27 <_Ray_> What is (m :: * -> *)? Aren't I only asking that m implements the Monad interface?
10:01:40 <roconnor> it is stating the kind of type variable m is
10:01:57 <roconnor> type variables come in different kinds
10:03:12 <mauke> to be fully explicit, forall (m :: * -> *) (a :: *). (Monad m) => ...
10:03:40 <roconnor> mauke: good point
10:04:20 <roconnor> _Ray_: BTW, it took me 7 years or more in Haskell before I understood what I'm telling you now.
10:04:31 <_Ray_> heh xD
10:04:55 <djahandarie> I don't think you need 7 years for this... but there is some other stuff that makes me feel like I will need 7 years for :P
10:08:35 <Saizan> e.g.?
10:09:27 <djahandarie> Anything in higher category theory
10:10:13 <roconnor> djahandarie: I just started to get the hang of simple 2-category stuff
10:10:24 <roconnor> djahandarie: like the laws for ajoint functors
10:10:48 <roconnor> Univalent foundations has made me feel more bold about exploring higher categories
10:12:40 <djahandarie> I'm alright with the definitions and stuff for 2-categories and 2-functors and stuff, I just have trouble trying to do anything with them
10:12:59 <djahandarie> (Except the stuff that other people have already done)
10:13:06 <roconnor> djahandarie: you can state the laws for adjoin functors :D
10:14:22 <edon> is there an upper bound to the number of threads spawned by forkIO, forced by ghc?
10:15:01 <djahandarie> http://ncatlab.org/nlab/show/pseudofunctor#definition_21 is where my head starts to spin a little
10:15:03 <Saizan> only your ram, afaik
10:16:04 <djahandarie> copumpkin, did you ever get any 2-category related stuff done in your agda ct stuff?
10:19:48 <copumpkin> djahandarie: I don't have 2-categories as a structure, but I have all the pieces (including the proofs) to build the 2-categories of sets
10:20:01 <copumpkin> I haven't quite decided on a nice way to make a general n-category
10:20:21 <sorje> Just model an infinity category and truncate ;-P
10:21:01 <dolio> Yes, easy.
10:21:07 <roconnor> copumpkin: 2-category of types
10:21:29 <WatermelonStorm> I'm new to Haskell. I pretty much like it.
10:21:40 <djahandarie> dolio, trivial, event.
10:21:42 <djahandarie> even.
10:21:48 <djahandarie> WatermelonStorm, yeay!
10:23:37 <WatermelonStorm> I'm reading Learn You A Haskell, but the lack of programming tasks and real world usages kind of are motivation basketers.
10:24:01 <burp> @where RWH
10:24:01 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:24:02 <Twey> WatermelonStorm: Check out Real World Haskell.  It has a bunch of neat real-world–esque projects you can get stuck into.
10:24:23 <dolio> Basketer?
10:24:27 <WatermelonStorm> Twey, I know of that one, yeah, but for some reason I didn't look at it yet.
10:24:55 <dolio> Puts your motivation in a basket?
10:25:02 <dolio> Or else it gets the hose again?
10:25:09 <WatermelonStorm> "Basketer" as in that it throws my motivation into a basket. Meh, it was pretty farfetched language. 
10:25:50 <WatermelonStorm> Thanks, burp and Twey.
10:26:12 <burp> don't you have a "project" you want to do in haskell?
10:26:32 <burp> you just want to learn haskell without any target?
10:26:50 <WatermelonStorm> burp, a bot for a specific chat application on a web site. I don't know if Haskell's suitable for that, but, yeah.
10:26:57 <burp> it is :D
10:26:57 <WatermelonStorm> The protocol's documented.
10:27:15 <dolio> There's a tutorial on writing an IRC bot in haskell somewhere.
10:27:19 <burp> haskell might be suited for nearly everything =)
10:27:22 <dolio> Maybe you could adapt that.
10:27:24 <WatermelonStorm> burp: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
10:27:31 <WatermelonStorm> I was looking at that. Monads... 
10:27:46 <burp> yeah, that's a good starting point
10:28:05 <WatermelonStorm> I kind of got lost when I looked at the lower source code. Kind of.
10:28:11 <WatermelonStorm> The final one, I mean.
10:28:21 <tswett> > let f n (x:xs) = 1 : reverse (take n (x:xs)) ++ map (1+) (f x xs) in fix (f 0)
10:28:25 <lambdabot>   mueval-core: Time limit exceeded
10:28:46 <WatermelonStorm> But I last looked at it when I hardly knew anything about haskell. It's easier now.
10:28:49 <tswett> Clearly, I just need more ones in front.
10:28:53 <tswett> > let f n (x:xs) = 1 : 1 : 1 : reverse (take n (x:xs)) ++ map (1+) (f x xs) in fix (f 0)
10:28:57 <lambdabot>   mueval-core: Time limit exceeded
10:29:07 * tswett shrugs.
10:43:28 <Cale> tswett: What were you going for there?
11:06:45 <astory> if I want to sort in descending order, should I modify my sort function, or just reverse the list after the fact?
11:06:56 <roconnor> astory: modify your sort function
11:08:32 <Cale> write a sortBy
11:08:37 <Cale> :t sortBy
11:08:39 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
11:08:45 <Jafet> sortBy (flip compare)
11:08:50 <byorgey> make a newtype 'Down' with an Ord instance like   instance Ord Down where compare = flip compare
11:08:57 <byorgey> then use   ala Down sort
11:09:01 <roconnor> :t (sortBy .) . (flip compare)
11:09:02 <lambdabot>     Couldn't match expected type `a -> a -> Ordering'
11:09:02 <lambdabot>            against inferred type `Ordering'
11:09:02 <lambdabot>     Probable cause: `compare' is applied to too many arguments
11:09:02 <byorgey> using ala from the newtype package
11:09:10 <copumpkin> :t àla 
11:09:12 <lambdabot> <no location info>: not an expression: `'
11:09:16 <byorgey> oh, wait, that doesn't quite work, does it
11:09:17 <roconnor> :t sortBy (flip compare)
11:09:17 <lambdabot> forall a. (Ord a) => [a] -> [a]
11:09:36 <copumpkin> > àla ZipList Data.Traversable.traverse [[1,2,3],[4,5,6],[7,8,9]]
11:09:37 <lambdabot>   Not in scope: `
11:09:43 <copumpkin> dammit
11:09:51 <copumpkin> combine my characters
11:09:56 <roconnor> @hoogle Dual
11:09:56 <lambdabot> Data.Monoid newtype Dual a
11:09:57 <lambdabot> Data.Monoid Dual :: a -> Dual a
11:09:57 <lambdabot> Data.Monoid getDual :: Dual a -> a
11:10:05 <Jafet> forall a. (Ord a) => (?compare :: a -> a -> Ordering) -> [a] -> [a]
11:10:09 <byorgey> hmm, maybe there ought to be a version of ala that works inside a Functor
11:10:40 <djahandarie> I thought about that
11:10:47 <djahandarie> But I think ala itself covers everything
11:10:55 <djahandarie> It does require some brain wracking though so I might make another anyways
11:10:59 <byorgey> djahandarie: so how would you do my example?
11:11:15 <byorgey> or just write more examples in the documentation
11:11:33 <roconnor> :t fmap getDual . sort . fmap Dual
11:11:34 <lambdabot> forall a. (Ord a) => [a] -> [a]
11:11:43 <roconnor> > fmap getDual . sort . fmap Dual $ [1,2,3,4]
11:11:45 <lambdabot>   [1,2,3,4]
11:11:49 <copumpkin> lol
11:11:59 <roconnor> pfft
11:12:05 <roconnor> stupid deriving Ord
11:13:32 <monochrom> who is ala?
11:13:37 <ezyang> :t ala 
11:13:38 <byorgey> @package newtype
11:13:38 <lambdabot> http://hackage.haskell.org/package/newtype
11:13:38 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
11:13:49 <whald> in a cabal project, where would i put additional (python) scripts which are not exactly needed to compile/run the program, but are still possibly of use?
11:14:59 <ezyang> whald: Any directory is fine, though you'll need to tell Cabal if you want them to show up in, say, the 'bin' 
11:15:04 <djahandarie> :t \x -> ala x ((sort .) . fmap)
11:15:04 <byorgey> whald: just put them wherever you want (e.g. in a separate directory) and include them in the extra-source-files field in the .cabal file
11:15:05 <lambdabot> forall o a o'. (Ord a, Newtype a o, Newtype [a] o') => (o -> a) -> [o] -> o'
11:15:14 <djahandarie> byorgey, ^^ It hink
11:15:15 <djahandarie> think*
11:15:36 <djahandarie> > ala Dual ((sort .) . fmap) [1,2,3,4]
11:15:37 <lambdabot>   No instances for (Control.Newtype.Newtype [Data.Monoid.Dual o] o',
11:15:37 <lambdabot>         ...
11:15:54 <parcs> :t ala
11:15:55 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
11:16:01 <djahandarie> Hmm
11:16:14 <whald> byorgey, ezyang : thanks, just thought there was some common sense for the "right" path like it's with Maven
11:16:41 <byorgey> whald: ah, no, not as far as cabal is concerned
11:18:30 <parcs> :t Dual
11:18:31 <lambdabot> forall a. a -> Dual a
11:20:06 <djahandarie> Erm, I apparently forgot to provide an instance for Dual
11:20:32 <byorgey> > Dual LT `mappend` Dual EQ
11:20:32 <lambdabot>   Dual {getDual = LT}
11:20:57 <byorgey> > Dual LT `mappend` Dual GT
11:20:58 <lambdabot>   Dual {getDual = GT}
11:21:48 <parcs> > LT `mappend` GT
11:21:49 <lambdabot>   LT
11:22:01 <byorgey> Dual flips mappend
11:22:08 <djahandarie> Yes, not of any use here
11:22:16 <byorgey> i.e. Dual x `mappend` Dual y == y `mappend` x
11:22:33 <byorgey> indeed, I was trying to figure out whether the Ord instance for Dual makes sense or if it is broken
11:22:46 <byorgey> > Dual 1 < Dual 2
11:22:47 <lambdabot>   True
11:23:16 <roconnor> > Nothing < Just 3
11:23:17 <lambdabot>   True
11:23:20 <roconnor> ooh
11:23:33 <roconnor> Dual . Maybe could be useful for modelling infinity
11:23:40 <roconnor> oh no
11:23:45 <roconnor> it flips the order of the numbers too
11:23:49 <byorgey> hehe
11:23:55 * roconnor goes back to Tropical
11:24:30 <byorgey> Dual . Maybe . Neg
11:24:41 <byorgey> where the Neg instance of Num negates everything
11:24:47 <copumpkin> roconnor: for your hidden Semiring class?
11:25:42 <tswett> Cale: a complicated-looking sequence defined on one line.
11:26:04 <roconnor> I forget why I was interested in Tropical semirings
11:29:44 * tswett tries for something else.
11:29:45 <tswett> > let x = 0 : intersperse 0 (map (+1) x) in x
11:29:49 <lambdabot>   mueval-core: Time limit exceeded
11:30:27 <tswett> > 0 : intersperse 0 (map (+1) [0,1,0,2,0,1,0,3])
11:30:28 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4]
11:30:42 <tswett> lambdabot: well, then, I'm not sure what the problem is.
11:31:04 <copumpkin> > fix (interleave [0..])
11:31:06 <lambdabot>   [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8...
11:31:23 <djahandarie> @oeis 0,0,1,0,2,1,3,0,4,2,5
11:31:26 <lambdabot>  a(2n) = n, a(2n+1) = a(n).
11:31:26 <lambdabot>  [0,0,1,0,2,1,3,0,4,2,5,1,6,3,7,0,8,4,9,2,10,5,11,1,12,6,13,3,14,7,15,0,16,8,...
11:31:43 <tswett> Curious function.
11:32:12 <djahandarie> > fix (map (*2) . interleave [0..])
11:32:13 <lambdabot>   [0,0,2,0,4,4,6,0,8,8,10,8,12,12,14,0,16,16,18,16,20,20,22,16,24,24,26,24,28...
11:32:22 <copumpkin> > fix show
11:32:24 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
11:32:30 <djahandarie> @oeis 0,0,2,0,4,4,6,0,8
11:32:31 <tswett> > intersperse 0 [1..]
11:32:32 <lambdabot>   [1,0,2,0,3,0,4,0,5,0,6,0,7,0,8,0,9,0,10,0,11,0,12,0,13,0,14,0,15,0,16,0,17,...
11:32:32 <lambdabot>  Bitwise AND of n-1 and n written in base 2.
11:32:32 <lambdabot>  [0,0,2,0,4,4,6,0,8,8,10,8,12,12,14,0,16,16,18,16,20,20,22,16,24,24,26,24,28,...
11:33:39 <copumpkin> what would you guys do to round a number to n decimal digits (not significant digits)
11:34:06 <djahandarie> > showCReal 3 3.14159
11:34:07 <lambdabot>   "3.142"
11:34:30 <burp> > printf "%.3f" 1.0
11:34:31 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:34:32 <lambdabot>    `Text.Printf.PrintfType ...
11:34:35 <tswett> Multiply it by 10^n, round it to the nearest integer, then divide it by 10^n?
11:34:38 <parcs> > round (3.14159 * 10^3) / 10^3
11:34:40 <lambdabot>   Ambiguous type variable `b' in the constraints:
11:34:40 <lambdabot>    `GHC.Real.Integral b'
11:34:40 <lambdabot>   ...
11:34:43 <burp> > printf "%.3f" 1.0 :: String
11:34:45 <lambdabot>   "1.000"
11:34:53 <tswett> Anyway, "let x = 0 : intersperse 0 (map (+1) x) in x" looks like it *ought* to work.
11:34:55 <burp> ah round it, not print it :>
11:35:21 <pumpkin> burp: that works actually, but I wonder what it's doing
11:35:22 <tswett> After all, whenever I evaluate an expression of the form "0 : intersperse 0 (map (+1) x)", I get a list longer than x.
11:35:36 <tswett> Maybe intersperse is looking ahead too far or something.
11:35:48 <burp> yes what parcs said  basically
11:36:12 <burp> > (/10^3) . fromIntegral . round $ (pi * 10^3)
11:36:14 <lambdabot>   3.142
11:36:42 <tswett> @let outersperse x (y:ys) = x : y : outersperse x ys; outersperse x [] = [x]
11:36:44 <lambdabot>  Defined.
11:36:58 <tswett> > let x = outersperse 0 (map (+1) x) in x
11:37:02 <lambdabot>   mueval-core: Time limit exceeded
11:37:38 <Jafet> @undef
11:37:40 <monochrom> intersperse probably looks ahead to decide "should I intersperse?"
11:38:02 <Jafet> > let outersperse x ~(y:ys) = x : y : outersperse x ys; outersperse x [] = [x]; x = outersperse 0 (map succ x) in x
11:38:03 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
11:38:56 <tswett> > let lazy_intersperse x ys = x : head ys : lazy_intersperse x (tail ys); a007814 = 0 : lazy_intersperse 0 (map (+1) a007814) in a007814
11:38:57 <lambdabot>   [0,0,1,0,1,0,2,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,...
11:39:09 <tswett> Jafet: your second case never actually gets executed, I think.
11:39:35 <Jafet> That was your second case.
11:39:43 <tswett> > let isEmpty ~(x:xs) = False; isEmpty [] = True in isEmpty []
11:39:44 <lambdabot>   False
11:39:56 <Jafet> Er, I see
11:40:56 <Jafet> > let outersperse x ys = x : case ys of (y:ys) -> y : outersperse x ys; [] -> []; x = outersperse 0 (map succ x) in x
11:40:57 <lambdabot>   <no location info>: parse error on input `='
11:41:06 <Jafet> > let outersperse x ys = x : case ys of { (y:ys) -> y : outersperse x ys; [] -> []; } x = outersperse 0 (map succ x) in x
11:41:07 <lambdabot>   <no location info>: parse error on input `x'
11:41:11 <Jafet> > let outersperse x ys = x : case ys of { (y:ys) -> y : outersperse x ys; [] -> []; }; x = outersperse 0 (map succ x) in x
11:41:11 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
11:41:17 <Jafet> A strange loop.
11:42:52 <parcs> @oeis 0,1,0,2,0,1,0,3
11:42:54 <lambdabot>  Exponent of highest power of 2 dividing n, a.k.a. the binary carry sequence,...
11:42:54 <lambdabot>  [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1...
11:43:29 <_mpu> impressing
11:44:30 <Jafet> > fix (intersperse 0 . map succ)
11:44:34 <lambdabot>   mueval-core: Time limit exceeded
11:44:48 <Jafet> > fix ((0:) . intersperse 0 . map succ)
11:44:52 <lambdabot>   mueval-core: Time limit exceeded
11:46:28 <tswett> > let pairUp (x1:x2:xs) = (x1,x2) : pairUp xs; a000002 = 1 : 2 : 2 : concat [replicate x1 1 ++ replicate x2 2 | (x1,x2) <- pairUp (drop 3 a000002)
11:46:29 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:46:36 <tswett> > let pairUp (x1:x2:xs) = (x1,x2) : pairUp xs; a000002 = 1 : 2 : 2 : concat [replicate x1 1 ++ replicate x2 2 | (x1,x2) <- pairUp (drop 3 a000002) in a00002
11:46:37 <lambdabot>   <no location info>: parse error on input `in'
11:46:46 <tswett> > let pairUp (x1:x2:xs) = (x1,x2) : pairUp xs; a000002 = 1 : 2 : 2 : concat [replicate x1 1 ++ replicate x2 2 | (x1,x2) <- pairUp (drop 3 a000002)] in a000002
11:46:50 <lambdabot>   mueval-core: Time limit exceeded
11:48:15 <tswett> > let pairUp (x1:x2:xs) = (x1,x2) : pairUp xs; a000002 = 1 : 2 : 2 : concat [replicate x1 1 ++ replicate x2 2 | (x1,x2) <- pairUp (drop 2 a000002)] in a000002
11:48:18 <lambdabot>   mueval-core: Time limit exceeded
11:49:10 <tswett> I guess I need to provide more initial values.  :P
11:54:06 <Jafet> > iterate ((uncurry (++) . (show.length &&& return.head) =<<) . group) "1"
11:54:08 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
11:54:40 <djahandarie> @oeis 1113213211
11:54:41 <lambdabot>  Look and Say sequence: describe the previous term! (method A - initial term ...
11:54:41 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
11:55:00 <tswett> > iterate ((uncurry (++) . (show.length &&& return.head) =<<) . group) "4"
11:55:02 <lambdabot>   ["4","14","1114","3114","132114","1113122114","311311222114","1321132132211...
11:55:15 <tswett> > iterate ((uncurry (++) . (show.length &&& return.head) =<<) . group) "Q"
11:55:17 <lambdabot>   ["Q","1Q","111Q","311Q","13211Q","111312211Q","31131122211Q","1321132132211...
11:56:25 <Jafet> group seems to be made exclusively for golfing
11:56:30 <Jafet> Never once seen it in real code.
11:57:08 <maurer_> Jafet: groupBy can be useful.
11:57:36 <zygoloid> group is the go-to guy for RLE :)
11:58:15 <zygoloid> > let rle = map (head &&& length) . group in rle "foobar"
11:58:16 <lambdabot>   [('f',1),('o',2),('b',1),('a',1),('r',1)]
11:59:49 <luite_> have people here been able to install Chart-0.14 on haskell platform 2011 for windows? (this requires gtk and cairo)
12:00:00 <HaudRex> This comes up a lot lately:
12:00:01 <HaudRex> @type \f x z -> Data.Traversable.traverse f x >>= maybe z return
12:00:01 <lambdabot> forall a b (m :: * -> *). (Applicative m, Monad m) => (a -> m b) -> Maybe a -> m b -> m b
12:00:09 <HaudRex> I feel like I should be generalizing
12:00:38 <WatermelonStorm> Awesome thing you got there, zygoloid. Another reason to love Haskell. :3
12:00:44 <WatermelonStorm> Heh, I'm new to it.
12:01:50 <solitude> how can i make chat make a window to bring me to a cooler irc server?
12:02:18 <aavogt> @ty Data.Traversable.traverse ?f ?x >>= Data.Foldable.fold const z
12:02:19 <lambdabot> forall a (m :: * -> *) b (t :: * -> *) b1. (?f::a -> m b, ?x::t a, Data.Traversable.Traversable t, Applicative m, Data.Foldable.Foldable ((->) (t b -> m b1)), Monoid (m b1), Monad m) => m b1
12:02:21 <solitude> such as irc.hardchats.com ?
12:02:33 <luite_> unpossible, this is the coolest server
12:02:39 <solitude> i think not
12:06:06 <djahandarie> byorgey, yeah, there is no way to do this without OverlappingInstances
12:06:11 <djahandarie> I'll drop in a Functor version
12:06:25 * int-e wonders why gmapAccumM processes arguments from right to left rather than left to right.
12:09:08 <djahandarie> @let underF pa f = fmap unpack . f . fmap pa
12:09:09 <lambdabot>  Defined.
12:09:24 <djahandarie> > underF All sort [False, False, True]
12:09:25 <lambdabot>   [False,False,True]
12:10:06 <HaudRex> @type \f x z -> Data.Traversable.traverse f x >>= Data.Foldable.fold (const z)
12:10:07 <lambdabot>     No instance for (Data.Foldable.Foldable ((->) b))
12:10:07 <lambdabot>       arising from a use of `Data.Foldable.fold' at <interactive>:1:44-71
12:10:07 <lambdabot>     Possible fix:
12:10:48 <dolio> int-e: What does that mean? For 'C x y z' it runs the action for z first?
12:11:37 <aavogt> @ty \x -> Data.Foldable.fold (const x)
12:11:38 <lambdabot>     No instance for (Data.Foldable.Foldable ((->) b))
12:11:38 <lambdabot>       arising from a use of `Data.Foldable.fold' at <interactive>:1:6-33
12:11:38 <lambdabot>     Possible fix:
12:11:41 <Panaetius> hum, what's the best (read: most efficient) way of mapping a function over an array (2dimensional, Data.Array) when that function needs to be able to access neighboring values of the current value?
12:11:49 <aavogt> @ty \x -> Data.Foldable.foldMap (const x)
12:11:50 <lambdabot> forall a a1 (t :: * -> *). (Data.Foldable.Foldable t, Monoid a) => a -> t a1 -> a
12:12:01 <aavogt> @ty Data.Traversable.traverse ?f ?x >>= Data.Foldable.foldMap const z
12:12:03 <lambdabot>     Couldn't match expected type `t a' against inferred type `Expr'
12:12:03 <lambdabot>     In the second argument of `Data.Foldable.foldMap', namely `z'
12:12:03 <lambdabot>     In the second argument of `(>>=)', namely
12:12:11 <aavogt> @ty Data.Traversable.traverse ?f ?x >>= Data.Foldable.foldMap const ?z
12:12:13 <lambdabot> forall a (m :: * -> *) b (t :: * -> *) (t1 :: * -> *) b1. (?f::a -> m b, ?x::t a, Data.Traversable.Traversable t, Applicative m, ?z::t1 (m b1), Data.Foldable.Foldable t1, Monoid (m b1), Monad m) =>
12:12:13 <lambdabot> m b1
12:13:53 <aavogt> HaudRex: it might be better to use MonadPlus there instead?
12:13:53 <int-e> dolio: yes
12:14:19 <dolio> Looking at the type, that probably means it's a generalization of mapAccumR.
12:14:29 <HaudRex> @type mapAccumR
12:14:29 <dolio> There's another, of course.
12:14:30 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:14:44 <dolio> I couldn't tell you why they chose that one.
12:15:14 * hackagebot rmonad 0.7 - Restricted monad library  http://hackage.haskell.org/package/rmonad-0.7 (GaneshSittampalam)
12:15:35 <HaudRex> @type Data.Traversable.mapAccumR
12:15:36 <lambdabot> forall a b c (t :: * -> *). (Data.Traversable.Traversable t) => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
12:16:16 * hackagebot suitable 0.1.1 - Abstract over the constraints on the parameters to type constructors  http://hackage.haskell.org/package/suitable-0.1.1 (GaneshSittampalam)
12:17:14 <malosh> Hi. Is there a way to simulate with type families the following behaviour : class (C1 a, C2 b)=>C3 a b | a->b ? 
12:17:56 <malosh> I need to do it with a data type family (i.e. not a synonym) or else ghc complains about injectivity in the instances
12:18:22 <Heffalump> class (C1 a, C2 (F a)) => C3 a where type F a
12:18:28 <malosh> ok
12:18:34 <malosh> but this is a type synonum
12:18:39 <Heffalump> you'd have an injectivity problem with fundeps too
12:18:41 <c_wraith> no, that's a type family
12:18:51 <Heffalump> using a datatype family is equivalent to having b -> a too
12:19:04 <int-e> dolio: yeah I guess nobody really thought about the evaluation order. maybe just getting the types correct was challenge enough. :)
12:19:11 <Heffalump> as long as a (not just F a) is specified by any signature you give it should work out
12:19:13 <malosh> Ok, what's the point with injectivity then ?
12:19:26 <dolio> int-e: Heh, probably.
12:19:38 <malosh> I didn't exactly understand this error message
12:19:38 <Heffalump> ghc will complain when you try to use something like foo :: F a -> Int, because it can't figure out what a is from a call site
12:19:50 <Heffalump> but it'd equally complain about foo :: b -> Int in the fundep version if it needed to know a
12:20:35 <malosh> So there is no way to do this ?
12:20:57 <malosh> ah, ok, I see
12:21:25 <malosh> With fundeps you can always declare a and b as real types (not synonyms)
12:21:33 <malosh> so this solves my problem
12:21:38 <malosh> (would solve it)
12:22:00 <Palmik> Are there public recordings from galois talks? 
12:23:00 <gio123> there should be chanell haskell-blash
12:23:09 <gio123> do i spell corectlly?
12:23:29 <Heffalump> the fix is to have foo take an a too, or something that's an injective function of a
12:23:31 <aavogt> drop the s
12:25:14 <EvanR-work> is there a read but with type String -> Maybe a
12:25:17 <EvanR-work> to account for parse failures
12:25:52 <gio123> there should be chanell haskell-blash
12:25:53 <gio123> do i spell corectlly?
12:26:34 <aristid> gio123: #haskell-blah
12:26:43 <aristid> not blash
12:26:58 <gio123> thx
12:32:10 <parcs> EvanR-work: readS is the closest to that
12:32:23 <EvanR-work> :t readS
12:32:24 <lambdabot> Not in scope: `readS'
12:32:30 <parcs> :t reads
12:32:31 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:32:32 <parcs> sorry
12:32:51 <parcs> > reads "ee" :: Int
12:32:52 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
12:32:53 <lambdabot>         against inferred type ...
12:32:53 <EvanR-work> ok so its a short walk to what i wanted using reads as the implementation
12:33:14 <parcs> EvanR-work: but the 'safe' package in hackage contains exactly what you want
12:34:01 <rukav> what is the best way to wake up thread (notify in java) during threadDelay? Thx. 
12:34:17 <siracusa> EvanR-work: safeRead = listToMaybe . fmap fst . reads
12:35:10 <EvanR-work> rukav: dont use threadDelay for that
12:35:12 <thoughtpolice> @seen edwardk 
12:35:13 <preflex>  edwardk was last seen on #haskell 21 hours, 24 minutes and 11 seconds ago, saying: pumpkin!
12:35:13 <lambdabot> Unknown command, try @list
12:35:41 <edwardk> right here
12:35:44 <taslem> Is it possible to get a view of the arguments each function is given?
12:36:08 <tarrasch> taslem, do you mean for debugging purposes?
12:36:10 <thoughtpolice> @tell edwardk so, yesterday I discovered a segfault with the most trivial program possible using reflection, on windows and confirmed on linux w/ ghc 7. that's bad! https://gist.github.com/870196
12:36:10 <lambdabot> Consider it noted.
12:36:17 <taslem> Yeah, debugging.
12:36:25 <thoughtpolice> ah, didn't notice :>
12:36:30 <thoughtpolice> i was finding my gist snippet
12:36:49 <tarrasch> taslem, hmm... You maybe could print it with the 'debugging functions', or are you looking for some kind of gdb solution? 
12:37:05 <taslem> What debugging functions?
12:37:20 <tarrasch> taslem, checkout Debug.Trace, there is the functions trace and taceShow. 
12:37:44 <c_wraith> Just be aware that the stuff in Debug.Trace can alter execution order
12:37:44 <edwardk> thoughpolice: ack!
12:37:45 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:37:51 <tarrasch> taslem, warning though, they are magical functions that are nonpure, they have side effects that is. The side effects are simply that they print values on the screen
12:38:00 <taslem> Yeah, I see.
12:38:03 <tarrasch> taslem, what c_wraith  said
12:38:05 <edwardk> thoughtpolice: thats new
12:38:54 <edwardk> wow, reify 2 reflect :: Int blows up at ghci now
12:39:03 <thoughtpolice> edwardk: yeah, everything blows up basically
12:39:11 <thoughtpolice> :(
12:39:20 <luite_> edwardk: both thoughtpolice and I tested it on 32 bit and it crashed, but someone else tested it on amd64 linux and it worked
12:39:28 <thoughtpolice> luite_: oh really?
12:39:35 <thoughtpolice> hm, very strange
12:39:50 <thoughtpolice> i speculate it will probably work using ghc 6.12
12:39:51 <luite_> thoughtpolice: yeah, I don't remember who though
12:39:58 <thoughtpolice> wait! derp, i'm on x86_64 linux right now with ghc 7!
12:40:00 * thoughtpolice tests
12:40:26 <edwardk> it blows up on my 64 bit mac right now
12:40:35 <c_wraith> segfaults are never good
12:41:01 <edwardk> thoughtpolice: thinking something tricky changed with the way it was forcing the evaluation of the dictionary entry
12:41:05 <thoughtpolice> not when it's in haskell land, no :>
12:41:12 <edwardk> reifyIntegral 2 reflectIntegral :: Int works
12:41:19 <edwardk> er reifyIntegral 2 reflectNum
12:41:42 <edwardk> so its something in Oleg's hack to ensure that the value of reflect is forced and free the StablePointer =/
12:41:48 <thoughtpolice> edwardk: amd64 linux/ghc 7.0.2 = segfault
12:41:53 <thoughtpolice> :(
12:42:06 <luite_> hm ok, seems quite thougroughly broken then :)
12:42:17 <taslem> Thank you, I found the problem. :D 
12:42:18 <luite_> minus typo's
12:42:27 <thoughtpolice> edwardk: are there any major differences between oleg's paper and your implementation btw? aside from the use of tagged to avoid the godawful undefined's everywhere
12:42:47 <thoughtpolice> (reflection 0.1 almost made your eyes bleed, because it didn't have Tagged)
12:43:11 <edwardk> thoughtpolice: some naming differences, but thats about it
12:43:18 <edwardk> i tried to stay faithful to the paper
12:43:46 <thoughtpolice> just wondering :) i was thinking of using/writing about using reflect because few people are aware of it, but alas, it's broken badly right now it seems
12:44:37 <luite_> thoughtpolice: 18:29:03 <smarmy> ghc 6.12.3, 7.0.1, and 7.0.2 on ubuntu 10.10 x64.... no seg fault
12:45:05 <edwardk> thoughtpolice: fixing it now
12:45:22 <edwardk> if nothing else i should be able to remove the freeing of the stableptr until we figure out whats gone wrong
12:45:42 <thoughtpolice> luite_: very strange
12:45:45 <edwardk> my guess is that ghc got "smart" some how and built the dictionary for reflect twice
12:45:55 <edwardk> due to the new type checking machinery
12:46:13 <thoughtpolice> edwardk: the new typechecking machinery was my guess too, i just didn't know enough about the internals to really diagnose it
12:48:09 <edwardk> it is almost certainly the stableptr being free'd twice, which means the dictionary that contains reflect has to be being built multiple times, or something got inlined. going to first see if i can dumb things down by leaking a stableptr each time to get it working again
12:48:26 <edwardk> then i'll see if i can NOINLINE, etc. my way to a solution that works in both 7.0.2 and 6.12
12:49:11 <edwardk> ok, removing the 'freeStablePtr' machinery fixes it. i'll upload a hotfix
12:50:04 <tarrasch> Is there any cabal beginners guide one should skim through? For example I wonder now if 'cabal + sudo' = suicide or if it means succesful install. Any good reading recomendations? Preferably quite short summary of what you need to know about cabal
12:50:19 <edwardk> now to see if i can find the culprit
12:50:27 * hackagebot reflection 0.3.2 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.3.2 (EdwardKmett)
12:51:10 <lispy> tarrasch: I don't think I've ever needed sudo with cabal
12:51:27 <monochrom> what is suicide?
12:51:32 <lispy> tarrasch: One tool you should know about is 'cabal-dev'.  It sandboxes your cabal builds which saves you time later
12:51:40 <edwardk> thoughtpolice: hrmm, i have NOINLINEs everywhere i could reasonably drop them to no avail here
12:51:43 <tarrasch> sandboxes?
12:52:09 <tarrasch> monochrom, I was wondering (because I dont know) if 'sudo cabal ...' is bad (using sudo with cabal)
12:52:11 <lispy> tarrasch: Yes, builds the dependencies and the package in your current directory instead of polluting your user database
12:52:40 <tarrasch> lispy, ok, just running '$ cabal-dev' is a sort of autofix?
12:52:51 <lispy> tarrasch: the normal 'cabal' command installs things into your user package database by default.  Unfortunately, this can lead to issues later.
12:53:00 <monochrom> using defaults, cabal creates files in $HOME/.cabal. do you want those files to be owned by root?
12:53:42 <lispy> tarrasch: http://www.reddit.com/r/haskell/related/f3ykj/psa_use_cabaldev_to_solve_dependency_problems/
12:53:49 <Saizan> tarrasch: there's --root-cmd=sudo if you want to just install globally
12:54:22 <monochrom> perhaps my http://www.vex.net/~trebla/haskell/sicp.xhtml counts as guide. sadly I wrote it as a horror movie.
12:55:24 <Saizan> at least it's fun to read
12:56:21 <lispy> tarrasch: one terminology quibble: The command 'cabal' actually corresponds to the program 'cabal-install'.  There is a library known as 'Cabal' that actually does all the magic.  So sometimes you will need to clarify whether you mean the 'cabal' command provided by 'cabal-install' or if you mean the 'Cabal' library provide by the 'Cabal' package.
12:56:51 <lispy> Yay for confusing naming.
12:56:55 <dcoutts_> yeah
12:57:01 <dcoutts_> historical reasons
12:57:05 <tarrasch> lispy, that's good to know I guess. I was probably reffering to cabal-install
12:57:15 <lispy> tarrasch: I figured as much :)
12:57:18 <dcoutts_> that I hope to sort out in the not too distant future with a reshuffling of libs
12:57:23 <taslem> Is there a function that maps two lists together?
12:57:29 <lispy> taslem: zip
12:57:32 <monochrom> one way to disambiguate is to use letter cases. "Cabal" is the lib.
12:57:37 <lispy> taslem: or zipWith actually
12:57:58 <dcoutts_> tarrasch: btw, yes sudo cabal install is bad, but sudo cabal install --global is fine
12:58:01 <povik> where is the instance of Stream definition for Handle?
12:58:13 <taslem> Thanks.
12:58:32 <tarrasch> dcoutts, heh I'll keep that in mind
12:58:48 <lispy> > fibs = 0 : 1 : zipWith (+) fibs (tail fibs) -- taslem
12:58:49 <lambdabot>   <no location info>: parse error on input `='
12:58:51 <lispy> doh!
12:59:03 <lispy> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- taslem
12:59:04 <dcoutts_> tarrasch: there's a ticket open to add some check to stop people shooting themselves in the foot
12:59:04 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
12:59:30 <taslem> Yeah, I know. I just didn't know its name.
12:59:37 <lispy> cool
12:59:39 <tarrasch> Honestly I'm certain I've ran sudo cabal install without --globlal sometime. I've got nothing important that cant be reinstalled there now. Is it worth to remove it all and reinstall manually or is there some self-clean command?
12:59:50 <tarrasch> dcoutts, that sounds like a great idea :)
13:00:15 <dcoutts_> tarrasch: if you just use sudo chown you can sort out the permission problems
13:00:35 <dcoutts_> tarrasch: and there should be no need to clean or reinstall anything
13:01:03 <dcoutts_> tarrasch: e.g. sudo chown yourusername:yourusergroup -R ~/.cabal
13:01:07 <tarrasch> dcoutts, the basic idea is that everythig in my home is owned by me and everything in roots home is owned by root?
13:01:10 <monochrom> my page has how to get rid of packages
13:01:15 <dcoutts_> tarrasch: right
13:01:40 <tarrasch> dcoutts, should I also do that for root? or I guess I could not have my own files lying there
13:01:48 <pumpkin> is there some FilePath -> IO FileType function where FileType is an ADT of Directory/File/Symlink/etc.
13:01:53 <pumpkin> ?
13:01:55 <dcoutts_> tarrasch: root will be ok
13:02:30 <dcoutts_> pumpkin: there are some functions for testing for synlinks etc in System.Posix.ThingICan'tQuiteRecall
13:02:39 <dcoutts_> probably System.Posix.Directory
13:02:52 <pumpkin> I really want to decide whether something is a file or a directory and do different things depending on which I get
13:03:05 <pumpkin> I'll take a look, thanks
13:03:21 <Spockz> pumpkin: are you the same guy as copumpkin?
13:03:26 <pumpkin> Spockz: indeed
13:03:51 <dcoutts_> pumpkin: if all you need is directory vs file (ie you don't care about symlinks) then you can use the normal System.Directory, doesFileExist, doesDirectoryExist
13:04:11 <pumpkin> dcoutts_: yeah, saw those, but having two Bools seemed less pleasant than an ADT
13:04:15 <pumpkin> I'll probably just go with those, though
13:04:19 <dcoutts_> pumpkin: I agree
13:04:38 <tarrasch> Have anyone managed to succesfully install and run yesod? Am i doing something simple wrong or is it expected to be troublesome to do it with cabal?
13:05:12 <edwardk> thoughtpolice: if i remove the forcing of it in advance, i can still free the stable ptr, so it looks like somehow GHC is inlining something that it doesn't know it is inlining.
13:05:18 <edwardk> odd
13:05:30 <edwardk> basically it seems to be ignoring the NOINLINE pragma
13:06:27 <dcoutts_> tarrasch: wow, it's got a lot of deps, I count 71
13:06:47 <tarrasch> dcoutts, that means hard even for pros? :p
13:07:00 <Saizan> yesod has some problems on 7.0.2 on OSX, iirc
13:07:08 <dcoutts_> tarrasch: well there are simply more opportunities for errors
13:07:10 <tarrasch> I use 6.12 ubuntu
13:08:06 <edwardk> thoughtpolice: this is somewhat unfortunate because, while i can ship this, and it'll be slightly nicer than the hotfix if the body passed to reify doesn't use 'reflect' then the stableptr would never be freed
13:10:12 <taslem> What languages have Haskell interpreters been written in?
13:10:24 <lispy> taslem: Haskell :)
13:10:29 <monochrom> haskell and c
13:10:31 <lispy> taslem: but, mostly we use compilers
13:10:36 <taslem> Ah, I see.
13:10:41 <Phantom_Hoover> So, I think I have been linked to the stupidest monad-related thing ever.
13:10:44 <Phantom_Hoover> http://kawagner.blogspot.com/2007/02/why-monads-are-evil.html
13:11:00 <monochrom> don't be linked again
13:11:02 <edwardk> thoughtpolice: another experiment i tried somewhere along the way was replacing the MPTCs with type families, but iirc it didn't type check in 6.12, i wonder if it does now in 7.0
13:11:11 <hpc> Phantom_Hoover: kwality
13:11:16 <monochrom> take control of which web pages you actually load
13:11:25 <taslem> He's really wrong. In lot's of ways.
13:11:39 <Phantom_Hoover> Best part is where he suggests that the evil impure IO monad... with the IO monad.
13:12:26 <monochrom> generally, ignore all blogs except for a few reputable bloggers
13:12:41 <Phantom_Hoover> Indeed, but it's amusingly stupid.
13:12:53 <taslem> Liek the Flat Earth Society?
13:13:11 <Phantom_Hoover> Except without the irony which you desperately hope is there.
13:13:33 <taslem> Phantom, same goes for the Flat Earth Society. :D
13:13:41 <monochrom> there is also an evil, revenge solution at http://www.vex.net/~trebla/humour/lmcify.html if you want to use it against other people :)
13:13:44 <tarrasch> monochrom, how can you say that? What about the rising stars? Should they never be cared for?
13:16:12 <monochrom> there are so few rising stars—even risen stars—if you ignore all blogs but still hang out in #haskell, what you miss is negligible.
13:17:25 <monochrom> also, from #haskell you can discover reputable bloggers. but indirectly. first you discover reputable irc'ers in #haskell, then you observe which bloggers they find reputable.
13:17:45 <ddarius> Reputable bloggers say ignorant shit all the time.  Ignore the internet.
13:19:41 * hackagebot clientsession 0.5.0 - Store session data in a cookie.  http://hackage.haskell.org/package/clientsession-0.5.0 (MichaelSnoyman)
13:19:43 * hackagebot mime-mail 0.2.0 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.2.0 (MichaelSnoyman)
13:19:45 <monochrom> if you had a time machine, perhaps you would have enough time to exhaustively scan all blogs for rising stars. if.
13:19:45 * hackagebot wai-app-static 0.0.1.2 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-0.0.1.2 (MichaelSnoyman)
13:20:48 * hackagebot warp-static 0.0.2 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-0.0.2 (MichaelSnoyman)
13:20:50 * hackagebot xml-enumerator 0.2.0.2 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.2.0.2 (MichaelSnoyman)
13:20:56 <taslem> Is there's a function for:    (a->b) -> [a] -> [b]?
13:21:12 <taslem> Isn't that a Functor or something?
13:21:19 <Phantom_Hoover> @hoogle (a->b) -> [a] -> [b]
13:21:19 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
13:21:20 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
13:21:20 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
13:21:40 <monochrom> @type fmap
13:21:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:21:49 <monochrom> let f=[]
13:21:55 <taslem> Oh, whoops.
13:21:58 <taslem> I said the wrong type.
13:22:01 <taslem> I meant:
13:22:11 <Phantom_Hoover> [a -> b]?
13:22:12 <taslem> [a->b] -> [a] -> [b]
13:22:18 <Phantom_Hoover> Yeah, that's Applicative.
13:22:22 <monochrom> that requires an applicative
13:22:26 <Phantom_Hoover> @type (<$>)
13:22:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:22:28 <monochrom> @type <*>
13:22:29 <lambdabot> parse error on input `<*>'
13:22:33 <monochrom> @type (<*>)
13:22:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:22:38 <monochrom> let f=[]
13:22:38 <Phantom_Hoover> Oh, right.
13:22:49 <hpc> monochrom: RE reputability, you also discover the blogs of #haskellers
13:23:29 <monochrom> that special case is subsumed.
13:24:06 <monochrom> for example of course monochrom (the #haskell'er) finds http://www.vex.net/~trebla/haskell/index.xhtml (the blogger) reputable.
13:24:20 <niteria> hello, can anyone tell me what's going on in this code http://codepad.org/OMywU3lJ ?
13:24:39 <taslem> I'm not sure you saw what I said.
13:24:54 <taslem> Because I don't know of any applicatives that can do this.
13:25:06 <Phantom_Hoover> etabot, hmm, what do you do?
13:25:13 <niteria> I mean what happens behind the scenes
13:25:25 <niteria> how is 'imperativeness' acheived
13:25:49 <monochrom> > [ord, ord] <*> ['x', 'y']
13:25:50 <lambdabot>   [120,121,120,121]
13:26:05 <taslem> Niteria? Are you new to Haskell? They were using a do-block.
13:26:35 <monochrom> > toUpper 'x'
13:26:36 <niteria> i'm interested in the complexity of this thing
13:26:36 <lambdabot>   'X'
13:26:45 <monochrom> > [ord, ord . toUpper] <*> ['x', 'y']
13:26:47 <lambdabot>   [120,121,88,89]
13:26:51 <niteria> taslem: is it the same as imperative version
13:26:52 <niteria> ?
13:27:02 <taslem> What do you mean?
13:27:30 <niteria> original erastotenes sieve is O(ln ln n) afair
13:27:33 <tswett> niteria: well, "do a <- b; c; d; e <- f; g" means the same thing as "b >>= \a -> c >> d >> f >>= \e -> g".
13:27:40 <tswett> Assuming I'm not forgetting a parenthesis somewhere.
13:27:56 <niteria> I kind of know how monads work
13:28:24 <tswett> niteria: anyway, what you linked to is not actually the sieve of Eratosthenes.
13:28:38 <monochrom> considering the test "val `mod` v == 0", this is not original erastotenes sieve
13:28:46 <tswett> This runs in O(n pi(n)) time, I think, where pi(n) is the number of primes less than n.
13:29:23 <taslem> Does anyone know of a function of the type   [ a -> b ] -> [a] -> [b]  ?
13:29:26 <hpc> yeah, the only arithmetic you should need for a sieve is addition
13:29:37 <niteria> access to MArray is O(1) ?
13:29:39 <taslem> Can any of the bots tell me?
13:29:40 <Botje_> taslem: zipWith ($)
13:29:43 <mauke> taslem: liftM2 id
13:29:46 <Botje_> or zipWith id
13:29:54 <hpc> :t zipWith id
13:29:55 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
13:30:05 <Jafet> Heh, liftM2 id
13:30:08 <tswett> > zipWith ($) [(1+),(2*)] [10,20]
13:30:08 <taslem> zipWith is of type  (a->b) [a] [b], not [a->b] [a] [b]
13:30:09 <lambdabot>   [11,40]
13:30:14 <mauke> well, that's probably ap
13:30:15 <tswett> > liftM2 id [(1+),(2*)] [10,20]
13:30:16 <lambdabot>   [11,21,20,40]
13:30:21 <tswett> taslem: take your pick.
13:30:25 <mauke> > ap [(1+),(2*)] [10,20]
13:30:25 <emartinj> Hello. I've had some trouble with the ffi on windows for a few days. The program(s) are segfaulting when I use a finalizer with addForeignPtrFinalizer. Have tried multiple dlls on multiple computers. Has anyone else experienced this?
13:30:26 <scree> niteria: I think the answer you're looking for is: the assymptotic complexity of that code is the same as for the corresponding C code under some suitable correspondence
13:30:26 <lambdabot>   [11,21,20,40]
13:30:26 <hpc> taslem: zipWith id, not zipWith
13:30:29 <Botje_> :t zipWith ($) -- come again?
13:30:30 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
13:30:48 <taslem> Wait, gr. I keep writing the wrong thing.
13:30:53 <taslem> I MEANT to say:
13:31:11 <taslem> Oh no, wait...
13:31:21 <monochrom> ha, did you see what you wrote?
13:31:43 <niteria> scree: that's the answer I'm looking for ;)
13:31:54 <Jafet> I don't understand niteria's code at all.
13:32:20 <niteria> MArray is written in Haskell or in C and it's persistent?
13:32:28 <monochrom> I don't understand how to leap from "how does this code work behind the scene" to "you mean assymptotic complexity"
13:32:41 <taslem> What's zipWith id?
13:32:47 <niteria> I know how exacly C code works
13:32:54 <mauke> niteria: unlikely
13:32:55 <c_wraith> :t zipWith id
13:32:56 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
13:32:56 <maurer_> niteria: MArray is neither. MArray is a typeclass, not an implementation.
13:33:08 <joe6> Loading package llvm-0.9.1.0 ... linking ... <interactive>: /home/j/.cabal/lib/llvm-0.9.1.0/ghc-7.1.20110209/HSllvm-0.9.1.0.o: unknown symbol `LLVMInitializeMSILTargetInfo'
13:33:09 <taslem> forall?
13:33:11 <joe6> ghc: unable to load package `llvm-0.9.1.0'
13:33:19 <hpc> taslem: apply first function to first parameter; second to second, etc
13:33:22 <mauke> taslem: you can ignore everything before '.'
13:33:22 <joe6> anyone seen that llvm error?
13:33:32 <taslem> Ah, okay.
13:33:34 <scree> niteria: the important magic is STUArray, which implements a mutable array
13:33:39 <hpc> zipWith id (f:fs) (x:xs) = (f x):(zipWith id fs xs)
13:33:51 <hpc> blahblah _ _ = []
13:33:54 <taslem> Does lambdabot automatically run what we say?
13:34:10 <maurer_> taslem: If you prefix it with >
13:34:14 <taslem> Mkay.
13:34:15 <hpc> > text "it needs to start with \"> \""
13:34:16 <lambdabot>   it needs to start with "> "
13:34:22 <hpc> :P
13:34:24 <scree> niteria: to a first approximation, it's a C-like array, with O(1) access, O(1) update &c.
13:34:35 <Jafet> > fix text
13:34:36 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:34:36 <lambdabot>         against inferred ty...
13:34:45 <niteria> can it be implemented in Haskell?
13:35:01 <hpc> @let unsafePerformIO _ = text "Nice try, smartass"
13:35:02 <lambdabot>  Defined.
13:35:07 <lispy> Have you guys used the Gnuplot library on Hackage?  I'm looking for working examples and not having much luck finding it.
13:35:16 <niteria> or is it just some persistent data structure
13:35:21 <taslem> >zipWith id [not | _ <- [1..10]] [False,_ <- [1..10]]
13:35:29 <monochrom> not persistent. in-place update.
13:35:32 <Jafet> > unsafePerformIO undefined
13:35:33 <taslem> >zipWith id [not | _ <- [1..10]] [False |_ <- [1..10]]
13:35:34 <lambdabot>   Nice try, smartass
13:35:35 <mauke> niteria: I can implement anything if you give me Foreign.*
13:35:39 <hpc> taslem: "> "
13:35:45 <hpc> > "> " == ">"
13:35:45 <taslem> > zipWith id [not | _ <- [1..10]] [False,_ <- [1..10]]
13:35:46 <lambdabot>   False
13:35:46 <lambdabot>   <no location info>: parse error on input `<-'
13:35:53 <maurer_> And technically, both Foreign and IORefs are part of haskell98, so "yes"
13:36:11 <maurer_> niteria: What are you trying to accomplish?
13:36:16 <taslem> >zipWith id [not | a <- [1..10]] [False | a <- [1..10]]
13:36:21 <scree> niteria: it cannot be implemented ``from scratch'' in Haskell, no
13:36:23 <taslem> > zipWith id [not | _ <- [1..10]] [False,| <- [1..10]]
13:36:25 <lambdabot>   <no location info>: parse error on input `|'
13:36:25 <Phantom_Hoover> unsafePerformIO: the Worst Thing?
13:36:37 <taslem> > zipWith id [not | _ <- [1..10]] [False|_ <- [1..10]]
13:36:38 <lambdabot>   [True,True,True,True,True,True,True,True,True,True]
13:36:38 <Jafet> And why on earth does niteria's program have trailing spaces?
13:36:44 <Jafet> @quote unsafe
13:36:44 <lambdabot> roconnor says: or maybe unsafeHead is even more unsafe than head.
13:37:08 <monochrom> IORef is not in haskell98
13:37:09 <taslem> How exactly does the name "zipWith id" contain a space???
13:37:13 <c_wraith> Phantom_Hoover: nah, unsafePerformIO is valuable, and sometimes necessary.  But it has to be used carefully.
13:37:25 <c_wraith> taslem: it's two functions
13:37:26 <Phantom_Hoover> What's it necessary for...?
13:37:28 <taslem> @c_wraith I agree. Used it yesterday.
13:37:29 <lambdabot> Unknown command, try @list
13:37:35 <taslem> It doesn't look like it..
13:37:41 <niteria> I just wanted to know if it's some functional data structure or persistent data structure
13:37:47 <c_wraith> :t zipWith
13:37:48 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
13:37:48 <taslem> Oh, I see.
13:37:48 <joe6> lispy, check out frplot. it is a lot better than gnuplot.
13:37:49 <c_wraith> :t id
13:37:50 <lambdabot> forall a. a -> a
13:37:51 <niteria> because it's persistent, right?
13:37:57 <hpc> :t ($)
13:37:58 <lambdabot> forall a b. (a -> b) -> a -> b
13:38:02 <monochrom> not persistent. in-place update. (replay)
13:38:09 <joe6> lispy, it is gnuplot on steroids.
13:38:24 <Jafet> :t id `asTypeOf` ($)
13:38:25 <lambdabot> forall a b. (a -> b) -> a -> b
13:38:26 <scree> niteria: I think you're meaning something different by ``persistent'' than the rest of us
13:38:35 <niteria> maybe ;p
13:38:45 <c_wraith> Phantom_Hoover: The most common use is for implementing bindings to C libraries that have a pure interface.  There's no other way to maintain the pure interface in haskell than using unsafePerformIO.
13:38:47 <taslem> does id = (\a->a)?
13:38:48 <hpc> fun exercise: prove id == ($) with alpha, beta, and eta reduction
13:38:59 <hpc> (i think you only need eta)
13:39:04 <c_wraith> Phantom_Hoover: however, there are other, more clever uses of it, like Conal Elliot's "amb" operator.
13:39:06 <maurer_> talsem: Yes.
13:39:09 <maurer_> @src id
13:39:10 <lambdabot> id x = x
13:39:17 <c_wraith> err, "unamb"
13:39:36 <scree> niteria: the point is, you don't get to play with STArrays in purely functional code.  You have to do that inside the ST monad
13:39:37 <c_wraith> "amb" is explicitly in IO, because it's *not* pure.  "unamb" is pure, so not in IO.
13:40:12 <niteria> persistent = semantics are the same if it's copied on write, for me
13:40:43 <scree> niteria: then no
13:41:05 <scree> @type writeArray
13:41:06 <lambdabot> Not in scope: `writeArray'
13:41:15 <Phantom_Hoover> Does output actually break referential transparency?
13:41:22 <scree> @type Data.MArray.writeArray
13:41:23 <lambdabot> Couldn't find qualified module.
13:41:32 <jjohnsson> joe6: do you have a link for frplot?
13:41:44 <Jafet> niteria: "MArray" stands for "mutable array", and "STArray" stands for "state thread array", which are fairly obvious hints that they are not persistent.
13:41:50 <scree> @type Data.Array.MArray.writeArray
13:41:51 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *). (Data.Array.Base.MArray a e m, Ix i) => a i e -> i -> e -> m ()
13:42:24 <niteria> ok, that makes sense
13:43:02 <Jafet> Phantom_Hoover: the article "tackling the awkward squad" may be useful to you.
13:43:06 <Jafet> @where awkward
13:43:06 <lambdabot> I know nothing about awkward.
13:43:10 <Jafet> @where awkward squad
13:43:10 <lambdabot> I know nothing about awkward.
13:43:38 <monochrom> is at http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/
13:43:40 <niteria> http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/ ?
13:43:42 <niteria> ok
13:43:47 * hackagebot reflection 0.3.3 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.3.3 (EdwardKmett)
13:43:49 <edwardk> thoughtpolice: i was able to work around the shiny new inlining bug in ghc 7.0.2 by making a top level definition for reflectBefore which references the dictionary
13:44:11 <thoughtpolice> edwardk: horray! 
13:44:26 <edwardk> thoughtpolice: so reflection is back to a usable state and no longer leaks stableptrs
13:44:38 <thoughtpolice> edwardk: which inlining bug? wasn't aware there was an inlining regression in 7 (i know there were performance regressions, but those were mostly related to CPS)
13:44:46 <edwardk> thoughtpolice: i wasn't either
13:44:48 <edwardk> =)
13:45:07 <edwardk> i don't know if its hit the trac, but there is apparently one, or this would have continued to work
13:45:19 <emartinj> Asking for help with ffi related problem. Anyone here got time to look at it? 
13:45:43 <thoughtpolice> edwardk: yeah, maybe it would be nice to boil down a test case
13:45:46 <edwardk> we're building a dictionary entry for reflect, but then it is somehow being inlined because it is getting evaluated twice, despite the fact that only one context is requiring it
13:46:17 <edwardk> thoughtpolice: hard to observe because you need something with unsafePerformIO in a dictionary slot like I was using in reflection there.
13:46:33 <edwardk> i'm not aware of anything else in hackage that exploits that behavior
13:46:35 <thoughtpolice> yeah, i'd say it's an edge case probably.
13:46:36 <ddarius> hpc:  id /= ($)
13:46:41 <thoughtpolice> er, edge case more than anything
13:47:20 <edwardk> the worst thing someone else might see is a minor regression in performance or loss of sharing
13:47:26 <joe6> jjohnson, svn checkout svn://repo.hu/frtplot/trunk frtplot
13:48:08 <monochrom> @type zipWith id
13:48:09 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
13:48:11 <monochrom> @type zipWith ($)
13:48:12 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
13:48:54 <monochrom> there are also ways to show that they do the same thing, not just the same type
13:49:18 <Jafet> @check \x y -> id x y == x y
13:49:19 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> a)
13:49:19 <lambdabot>    arising from a use of `...
13:49:47 <ddarius> monochrom: They are observationally distinguishable, much like \p -> (fst p, snd p) is observationally distinguishable from id even though it too is an instance of id's type.
13:50:02 <monochrom> id x y = (\z->z) x y = x y.  A calculation is worth a thousand tests.
13:50:34 <hpc> how does one distinguish id from ($)?
13:50:47 <Jafet> One costs more
13:51:12 <hpc> at the dmv, id == $300?
13:51:20 <hpc> :P
13:51:23 <monochrom> haha
13:51:33 <hpc> :t ($300)
13:51:34 <lambdabot> forall a b. (Num a) => (a -> b) -> b
13:51:50 <thoughtpolice> edwardk: well, thanks for the quick fix. reflection is a very nice package and i wish more people were aware of it, it's one of oleg's most interesting works, and isn't too hard to digest really. i mean, you can teleport values through the type system, how much cooler does it get? :)
13:51:55 <hpc> > let id = ($300) in (+5) `id` 5
13:51:56 <lambdabot>   305
13:53:02 <_Ray_> Hey, question. If I have two types a b and some monad m, then fmap can "lift" a function a -> b to a function M a -> M b, right?
13:53:44 <Jafet> If there was a Functor instance for m, and if you meant m a -> m b
13:53:46 <Phantom_Hoover> Yes.
13:53:48 <thoughtpolice> _Ray_: indeed!
13:53:50 <Phantom_Hoover> @type liftM
13:53:51 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:53:56 <ddarius> > (($) undefined `seq` (), id undefined `seq` ())
13:53:57 <lambdabot>   ((),*Exception: Prelude.undefined
13:54:04 <_Ray_> So what's the difference between liftM and fmap then?
13:54:05 <Phantom_Hoover> What odd type names.
13:54:08 <hpc> :t fmap `asTypeOf` liftM
13:54:09 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => (a -> b) -> f a -> f b
13:54:13 <ddarius> _Ray_: The type.
13:54:25 <Phantom_Hoover> _Ray_, one of them only works on monads, the other on functors.
13:54:35 <hpc> _Ray_: one works on Functor, one on Monad; all Monads should be Functors, but hysterical raisins make that not enforced
13:54:43 <ddarius> liftM is the proof that all monads are functors.
13:54:44 <djahandarie> Hysterical raisins.
13:55:00 <djahandarie> But not the proof that all Monads are Functors.
13:55:28 <monochrom> > [($) undefined `seq` (), id undefined `seq` ()]
13:55:29 <lambdabot>   [(),*Exception: Prelude.undefined
13:55:49 <_Ray_> ah, liftM requires f to be both a Monad and a Functor
13:55:58 <ddarius> _Ray_: No, it doesn't.
13:56:43 <hpc> i refuse to accept that difference in the presence of seq == difference in general
13:56:53 <_Ray_> hrm, then I didn't get it xD. liftM seems to only require a Monad, and :t fmap in my console seems to say fmap only needs a Functor
13:57:11 <hpc> _Ray_: liftM doesn't require both monad and functor
13:57:20 <hpc> _Ray_: a monad IS a functor
13:57:39 <Jafet> But a Monad is not a Functor.
13:57:40 <monochrom> my full statement is zipWith id = zipWith ($).
13:57:43 <ddarius> hpc: Your free to refuse to accept any facts you want, but it nevertheless is true and matters occasionally.
13:57:51 <hpc> only in evil cases
13:58:00 <ddarius> No, not only in evil cases.
13:58:06 <tarrasch> @type zipWith id
13:58:07 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
13:58:08 <mauke> assume you have a type M that is an instance of Monad but not Functor
13:58:12 <Jafet> As in, there is no instance Monad m => Functor m
13:58:18 <mauke> then you can define instance Functor M where fmap = liftM
13:58:35 <hpc> Jafet: but there could be class Functor f => Monad f
13:58:47 <Jafet> What
13:58:50 <hpc> which would make a Monad a Functor
13:58:55 <hpc> @src Applicative
13:58:55 <lambdabot> class Functor f => Applicative f where
13:58:55 <lambdabot>     pure  :: a -> f a
13:58:55 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:58:58 <hpc> Jafet: ^^
13:59:18 <hpc> try making an Applicative that isn't also a Functor :P
13:59:31 <tarrasch> I agree with hpc, if i'm not mistaken its only because monad came first that we don't see class Functor f => Monad f
13:59:40 <tarrasch> came first to haskell, so to say
13:59:44 <Jafet> Anyway, what Ray seems to be confused about is what asTypeOf does.
13:59:47 <Jafet> :t asTypeOf
13:59:48 <lambdabot> forall a. a -> a -> a
13:59:56 <Jafet> Okay, that's pretty useless
14:00:00 <aavogt> it doesn't do much
14:00:01 <_Ray_> xD
14:00:20 <aavogt> hopefully it's just there for the type system / instance resolution purposes
14:00:49 <hpc> asTypeOf is mostly a hack to fix ambiguous type variables
14:00:50 <tarrasch> aavogt, it's a good thing to sometimes used monomorphized functions
14:00:57 <monochrom> main = do { x <- readLn; print (maxBound `asTypeOf x) }
14:01:11 <hpc> it does the same thing as scoped type variables, with uglier syntactic overhead
14:01:15 <monochrom> err no, that doesn't do it
14:01:20 <aavogt> monochrom: you still need some use of x
14:01:51 <hpc> do {let x = False; ...
14:01:54 <ddarius> hpc: Lexically scoped type variables are an extension.
14:02:02 <hpc> ddarius: indeed, hence the hack
14:02:14 <monochrom> what hpc says. it is an alternative to scoped type variables.
14:02:23 <aavogt> type annotations are clearer
14:02:35 <tarrasch> Do you ever need sudo cabal isntall ... --global if you're not having other users sharing your computer?
14:02:37 <yitz> @check \x y -> x + y == x `asTypeOf` y -- something asTypeOf does *not* do
14:02:38 <lambdabot>   "Falsifiable, after 0 tests:\n1\n1\n"
14:03:01 <yitz> @type (+)
14:03:02 <lambdabot> forall a. (Num a) => a -> a -> a
14:03:29 <aavogt> it's hard to see where the parens belong there
14:03:59 <hpc> aavogt: instance Num Bool where ...
14:04:07 <ddarius> tarrasch: Monad was introduced in Gofer where type constructor classes were first implemented.  There it had Functor as a superclass and map was fmap.
14:04:07 <aavogt> exactly!
14:04:11 <hpc> \x y -> (x + y == x) `asTypeOf` y
14:04:15 <monochrom> > True + False
14:04:16 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
14:04:16 <lambdabot>    arising from a use of `GHC.N...
14:04:18 <yitz> @check \x y -> (x + y) == (x `asTypeOf` y) -- something asTypeOf does *not* do
14:04:19 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n-2\n"
14:04:37 <hpc> actually, having a Num Bool instance would make for some fun modular arithmetic hackery
14:04:58 <monochrom> Word is better
14:05:12 <ddarius> Word1
14:05:20 <hpc> heh
14:07:36 <andrus> exit
14:07:39 <joe6> i am trying to use llvm with ghc-7 and the package available at http://code.haskell.org/llvm/ is old. I see that there are some patches in the _darcs directory. Is there a way for me to download/apply the patches to my local directory?
14:08:12 <joe6> darcs pull http://code.haskell.org/llvm/ : will pull the darcs repository.
14:08:26 <c_wraith> joe6: the llvm backend has been integrated into mainline ghc 7
14:09:06 <thoughtpolice> he's talking about the LLVM package
14:09:13 <thoughtpolice> that allows you to generate bitcode programatically
14:09:14 <thoughtpolice> @hackage llvm
14:09:15 <lambdabot> http://hackage.haskell.org/package/llvm
14:09:16 <c_wraith> oh, that one
14:09:27 <joe6> yes, that is the package that I am trying to get.
14:09:54 <joe6> i have this error on my ghci prompt: HSllvm-0.9.1.0.o: unknown symbol `LLVMInitializeMSILTargetInfo'
14:10:00 <c_wraith> the _darcs directory contains patches, yes.  that's its job.  It doesn't contain any patches that aren't applied with a darcs get
14:10:08 <joe6> and this person seems to have patched it, http://blog.gmane.org/gmane.comp.lang.haskell.llvm/month=20110201
14:10:31 <joe6> i am not sure how to get the patch that this person is referring to..
14:16:54 <imc> how do I write a Functor instance?
14:17:16 <imc> ghci keeps telling me that the "first argument of Functor should be of type * -> *"
14:17:30 <c_wraith> imc: what's the declaration of your type look like?
14:17:48 <aavogt> maybe your type cannot have a Functor instance
14:18:14 <imc> data Object3 s t = Object3 { matrix :: MyMatrix s, object :: t }
14:18:21 <imc> instance Functor (Object3 s t) where ...
14:18:32 <c_wraith> instance Functor (Object3 s) where
14:18:36 <imc> oh
14:18:52 <imc> that's logic
14:18:56 <c_wraith> understanding that error message is really important, though
14:19:29 <c_wraith> when you understand it, you'll be a long way to understanding lots of stuff that's new in haskell compared to more mainstream languages
14:19:51 <imc> actually I did just misread it.. as I had two of them, one for functor and one for applicative
14:20:04 <imc> fixed in one but not in the other and, well, opus
14:20:10 <imc> *oups
14:20:11 <c_wraith> there you go, then
14:21:06 <EvanR-work> can pointers be NULL in haskell?
14:21:09 <EvanR-work> referring to the ffi
14:21:19 <c_wraith> yeah, nothing prevents that.
14:21:42 <c_wraith> also, see:  http://hackage.haskell.org/packages/archive/base/4.3.1.0/doc/html/Foreign-Ptr.html#v:nullPtr
14:21:52 <edwardk> thoughtpolice: yeah, i usually wind up giving the explanation of reflection in stages, by getting folks to buy into each concept, reifying natural numbers as types, reifying lists of reifiable things as types, reifying storables as lists of naturals, reifying stable ptrs, then the small fix to avoid leaking the ptrs, and you're done
14:22:50 <edwardk> EvanR-work: Foreign.Ptr.nullPtr 
14:23:00 <EvanR-work> got it
14:23:14 <edwardk> c_wraith: missed your reply =)
14:23:33 <EvanR-work> fun for the whole family
14:24:08 <EvanR-work> im guessing if you dereference a nullPtr it crashes everything ;)
14:24:27 <EvanR-work> kind of like at least one of the ffi libs im using
14:30:20 <hvr_> what does it mean if I get
14:30:22 <hvr_> base-4.3.1.0 was excluded because of the top level dependency base -any
14:30:37 <pozic> Suppose you compute something over a list. At each step you maintain that your desired property holds, but the property you are interested in refers to indices of the list or even all the previously processed elements. Now, you cannot modify the algorithm (which has no notion of 'all previously processed elements', since doing that would only make your algorithm slower). How can this little puzzle be solved?
14:31:09 <pozic> Er the puzzle being proving its correctness.
14:32:32 <pozic> If in some way you can build proof objects as functions of the variables in the program, then it should be possible.
14:32:50 <monochrom> perhaps an example is "prove foldl (+) 0 xs = xs!!0 + xs!!1 + ... xs!!n"?
14:33:50 <monochrom> the solution is to prove a harder theorem: "foldl (+) s xs = s + xs!!0 + xs!!1 + ... xs!!n". the harder theorem is easier to prove.
14:34:39 <pozic> How can I write a correctness proof for something like this without modifying this function? maximum_subsequence_acc (xs:list Z) (longest_list_so_far reversed_pred:list Z) (current_sum max_sum:nat)  {struct xs} :  list Z
14:34:45 <pozic> monochrom: what about that case?
14:35:18 <WatermelonStorm> Gah.. Chapter 3 in Real World Haskell is a pure mess.
14:35:38 <aavogt> did you read the previous chapters?
14:35:47 <monochrom> I don't know what is inside "maximum_subsequence_acc"
14:36:09 <monochrom> also please note that suggestive names are the #1 things to be ignored in proofs.
14:36:10 <pozic> monochrom: it computes the actual list of subsequents elements (whole numbers) which is maximum over the whole list.
14:36:25 <WatermelonStorm> I scanned over them if they introduced something new, aavogt. I already read Learn You A Haskell pretty far.
14:37:39 <aavogt> WatermelonStorm: well in any case, feel free to ask questions here too
14:37:59 <monochrom> well do you have actual code? if not, I'll go back to reading books.
14:38:14 <hpc> haskell tutorials are not to be skimmed
14:38:30 <djahandarie> Skimming in general is usually a bad idea
14:38:47 <djahandarie> But on the other hand so is staring at a single sentence and getting stuck on it for a long time
14:38:49 <hpc> lyah is occasionally an exception, but it's impossible to know where beforehand
14:38:53 <pozic> monochrom: http://paste.debian.net/hidden/4e956998/
14:38:56 <monochrom> skimming works for econ 101 textbooks which are 2000 pages.
14:39:30 <_Ray_> Hrm, so if I have f :: a -> b and some monad M, then return . f gives me a function that wraps the return type of f in M, :t return .f == a -> M b. and if I have (>>=), I can use it as g :: M a -> M b, g x = bind x (return . f), which will construct a function f' :: M a -> M b, and evaluate it at x?
14:40:03 <_Ray_> err, s/bind/(>>=)/; in g's def above.
14:40:19 <hpc> :t \x -> x >>= (return . f)
14:40:20 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Show a, SimpleReflect.FromExpr a1) => m a -> m a1
14:40:24 <tarrasch> hpc, djahandarie, that's the most untrue thing I've ever heard. Everything should be skimmed
14:40:26 <hpc> yep, that's right
14:40:32 <byorgey> _Ray_: yes.  equivalently, g = fmap f
14:40:49 <byorgey> well, g = liftM f
14:40:56 <_Ray_> right, since M is a monad?
14:41:09 <_Ray_> (that's what the M in liftM stands for, I assume?)
14:41:13 <byorgey> yes.
14:41:22 <hpc> the equivalencies will become more obvious as you get better with types and classes
14:41:29 <djahandarie> tarrasch, I think you're reading the wrong material. Most stuff that I enjoy reading is really dense stuff where skipping over a single sentence means being lost for the whole paper
14:41:54 <hpc> djahandarie: you mean you can understand your papers the whole way through with just the text to work off of?
14:42:04 <hpc> :P
14:42:06 <pozic> monochrom: the implementation of the function is pretty much unimportant, but do you have any idea how to do it _without_ modifying the function?
14:42:11 <djahandarie> hpc, usually...
14:42:15 <hpc> djahandarie: those must be some easy papers :D
14:43:02 <djahandarie> I'm not talking about ttt here. Just ICFP papers or something at that level
14:43:05 <djahandarie> @where ttt
14:43:05 <lambdabot> Toposes, Triples and Theories: http://www.cwru.edu/artsci/math/wells/pub/ttt.html
14:43:15 <tarrasch> djahandarie, ah ok, you mean that sort of skim. Well what I mean it's always worth to spend a 50th of the estimated reading time the day before just quickly comfortizing your eyes with a text you're going to embark on the day after.
14:43:24 <monochrom> do you do not allow me to look at the implementation, then what I illustrated with my foldl example is all I say. no function was modified.
14:43:32 <hpc> that's quite a title
14:43:48 <monochrom> s/do you/if you/
14:43:50 <pozic> monochrom: huh? That is the implementation. 
14:43:54 <tarrasch> djahandarie, however, everyone got their own way. I guess everyone to their own.
14:44:24 <pozic> monochrom: you can look, but for the proof, you need some kind of induction principle or something else which Coq sees as a 'proof'.
14:44:38 <tarrasch> anyway, goodnight everyone!
14:44:51 <pozic> monochrom: any 'proof' will need to refer to 'already processed elements' of the _original_ input list.
14:45:11 <hpc> djahandarie: that is the coolest book ever; it has a chapter dependency graph
14:45:12 <pozic> monochrom: but this list is not present in the definition as pasted.
14:45:48 <djahandarie> You can thank ddarius for that
14:45:56 <beastaugh> hpc: that's not so uncommon in a certain type of book
14:45:56 <djahandarie> (Not for the book, for the link :P)
14:46:04 <beastaugh> TaPL has one, for example
14:46:35 <pozic> monochrom: do you understand the question I am asking? 
14:49:04 <monochrom> this one could be done using the approach as my foldl example above, but will be too hard. but there is another way, I'll illustrate with foldl again.
14:49:40 <monochrom> in short, it is the same as using invariants from imperative programming. (the best functional programs are inspired by imperative programming.)
14:51:20 <hpc> monochrom: don't let #haskell hear you say that! :P
14:51:22 <monochrom> to prove foldl (+) 0 xs = xs!!0 + ... + xs!!n, prove this: if s = xs!!0 + ... + xs!!(k-1), then foldl (+) s (drop k xs) = xs!!0 + ... + xs!!n.  The invariant is s = xs!!0 + ... + xs!!(k-1)
14:51:47 <hpc> (it is at least partially true, from my experience)
14:52:29 <aavogt> > foldl (f) s (drop 2 [a,b,c,d,e,f])
14:52:31 <lambdabot>   f (f (f (f s c) d) e) f
14:54:01 <pozic> monochrom: what was the hard way>
14:54:29 <monochrom> similarly, you prove "if P(longest_list_so_far, current_sum, take k xs), then maximum_subsequence_acc (drop k xs) longest_list_so_far current_sum) = what you want". P is a suitable statement you contrive.
14:55:27 <monochrom> insert "max_sum" "reversed_pred" etc if necessary. I don't understand the syntax.
14:56:18 <monochrom> the hard way is too hard to describe.
14:56:33 <pozic> monochrom: haha
14:56:40 <pozic> monochrom: perhaps your way is applicable. Thanks.
14:57:33 <monochrom> you should do my foldl example both ways first. the experience, though insufficient, is necessary.
14:58:22 <pozic> monochrom: you only described one way for the foldl case.
14:58:44 <monochrom> and then you should do maximum_subsequence_acc with just the maximum sum but not the best list.
14:59:06 <monochrom> 1. <monochrom> the solution is to prove a harder theorem: "foldl (+) s xs = s + xs!!0 + xs!!1 + ... xs!!n". the harder theorem is easier to prove.
14:59:26 <monochrom> 2. <monochrom> to prove foldl (+) 0 xs = xs!!0 + ... + xs!!n, prove this: if s = xs!!0 + ... + xs!!(k-1), then foldl (+) s (drop k xs) = xs!!0 + ... + xs!!n.  The invariant is s = xs!!0 + ... + xs!!(k-1)
14:59:30 <monochrom> I count 2.
14:59:54 <monochrom> please use your scrollbuffer and your ram properly. you have more than 1gb of ram; use it.
15:00:27 * djahandarie was surprised that monochrom didn't also suggest 'use your eyes properly'
15:00:42 <pozic> monochrom: I parsed it differently.
15:00:53 <monochrom> who knows, perhaps he/she ircs through a speech synthesizer.
15:01:21 <monochrom> I would use a usb connection to my brain directly if I could help it.
15:01:21 <dibblego> What is the equivalent of a generalised filter that works on Maybe prior to Control.Monad.mfilter?
15:01:51 <pozic> monochrom: no, I have a scrollback buffer. It is very unfortunate that you had to quote yourself. 
15:02:53 <aavogt> @hoogle mfilter
15:02:54 <lambdabot> No results found
15:02:57 <aavogt> @ty filterM
15:02:58 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
15:03:01 <aavogt> dibblego: that one?
15:04:06 <dibblego> aavogt: yeah thought there was something that didn't need the unwrapping
15:04:41 <aavogt> @ty mapMaybe
15:04:42 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
15:05:51 <aavogt> dibblego: I don't get the involvement of Maybe in filterM
15:06:32 <dibblego> Oh yeah good point, sorry I said mfilter (new function)
15:10:30 <hpc> @src mapMaybe
15:10:30 <lambdabot> Source not found. My mind is going. I can feel it.
15:10:38 <hpc> @djinn (a -> Maybe b) -> [a] -> [b]
15:10:38 <lambdabot> Error: Undefined type []
15:10:41 <hpc> humbug
15:11:20 <dibblego> (a -> Bool) -> Maybe a -> Maybe a
15:11:49 <monochrom> pozic: if you don't like indexing using "!!", here is a concatenative version: if s = "sum of prefix", then foldl (+) s suffix = "sum of prefix" + "sum of suffix" = "sum of prefix++suffix"
15:12:16 <niteria> Does anyone have an idea how Random.split works?
15:13:16 <niteria> I don't know how I would go about implementing it
15:13:31 <niteria> feels like magic
15:13:53 <niteria> like spliting infinite list in half :D
15:14:05 <mauke> splitting infinite lists in half is easy
15:14:14 <mauke> even elements to the left, odd elements to the right
15:14:26 <savage> BONUS: great website ;)
15:14:36 <savage> I love the drawings ^_^
15:14:37 <BONUS> hey thanks :)
15:14:43 <BONUS> book coming out in a week or so
15:14:51 <savage> did you do the drawings?
15:15:29 <niteria> mauke: I meant in 'half' like in 1/2*infinity, but that helps me with Random.split
15:16:20 <niteria> it could be implemented like that, I know next to nothing about statistics, but it seems reasonable
15:16:32 <bss03> :t Random.split
15:16:33 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
15:16:55 <savage> BONUS where is the book being published?
15:17:22 <BONUS> everywhere i think www.nostarch.com/lyah.htm
15:17:43 <BONUS> it's like 40% off on amazon for now
15:18:31 <bss03> If RandomGen = G { seed :: Int# }, then Random.split G{s} = (G n xor k, G n xor not k) where n = randomInt, k = randomInt.. or something like that.
15:19:36 <bss03> Basically, generate two new seeds, mix them a bit, so that neither is the "predecessor" of the other, and return.
15:20:15 <bss03> :t Random.random
15:20:16 <lambdabot> forall g a. (Random a, RandomGen g) => g -> (a, g)
15:20:51 <Skola> which Haskell implementation is good/best for learning?
15:21:04 <bss03> Skola: Is there really a useful one besides GHC?
15:21:05 <napping> still ghc, pretty much
15:21:21 <savage> most tutorials use GHC(i)
15:21:24 <monochrom> hugs has simpler error messages for learning.
15:21:37 <bss03> niteria: ^^ How to do Random.split above a bit ^^
15:21:39 <Skola> alright
15:22:03 <niteria> bss03: I don't know how to prove that if G gives uniform distribution, then (a, b) = split G too
15:22:21 <BONUS> yeah but hugs is hella old
15:22:22 <siracusa> Skola: Helium was designed for learning, AFAIK
15:22:30 <niteria> maybe it's obvious
15:22:33 <BONUS> ghc ftw
15:22:50 <monochrom> with GHC, be prepared to ask #haskell to explain error messages.
15:22:51 <niteria> hugs is confusing
15:22:53 <bss03> niteria.  That mostly depends on your method of turning a seed into an object.
15:23:01 <napping> Helium doesn't do the full language, but it might be helpful
15:23:10 <bss03> niteria: If some seeds are degenerate, your split has to do "magic" to avoid them.
15:23:11 <Skola> alright
15:23:25 <napping> It's intented to have good messages for what it does cover
15:23:35 <Skola> and for documentation on the libraries I use Hoogle right?
15:23:44 <niteria> when you learn, most of resources I stubled upon are about ghc
15:23:46 <monochrom> for example, you will have to ask "what is 'Bool does not match Char'?", and we will answer, it means Bool does not match Char.
15:23:51 <mauke> monochrom: I found ghci errors easier to understand than hugs (or at least not harder)
15:23:57 <bss03> niteria: If all seeds give uniform results, you jsut have to make sure the seeds you use aren't "closely related".
15:24:46 <monochrom> well hugs won't tell you about "use -XOverlappingInstances to enable it" to distract you.
15:24:48 <bss03> niteria: "closely" related means getting s2 as a "results seed" after requesting n random things starting from s1 (or vice-versa) for small n.
15:25:34 <napping> It's intented to have good messages for what it does cover
15:26:04 <bss03> niteria: Make sense?
15:26:08 <aavogt> helium development isn't terribly active
15:26:30 <bss03> @src split
15:26:31 <lambdabot> Source not found. stty: unknown mode: doofus
15:26:35 <bss03> @src Random.split
15:26:35 <lambdabot> Source not found. Sorry.
15:26:37 <bss03> :(
15:26:51 <niteria> bss03: yes, makes sense
15:27:05 <bss03> @src StdGen.split
15:27:06 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:27:09 <bss03> @src StdGen
15:27:09 <lambdabot> Source not found.
15:27:20 <niteria> but I wondered if I could split without any additional assumptions about G
15:28:20 <niteria> treating G as infinite list and spliting it into even and odd seems to give uniform distribution
15:30:31 <bss03> niteria: I imagine it doesn't work for some cases.
15:32:36 <bss03> niteria: I could see a system where uniformity was guarnateed by having taking non-uniform noise with length k less than half the key size, then reversing it and bitwise-inverting it and useing the for the next k bits.
15:32:48 <pozic> Generating random numbers is a point of debate in the first place. Some people claim that certain AI algorithms work better with real random numbers, for example.
15:33:04 <bss03> Splitting that could give some degenerate generators.
15:33:19 <pozic> You can debate about whether those 'real random numbers' even exist, too.
15:34:08 <edwardk> pozic: meh, just obtain all your bits by monitoring radioactive decay ;)
15:34:23 <pozic> edwardk: even that might not really be random.
15:34:26 <niteria> ok, I see
15:34:29 <bss03> The twister and the congruential method both have good properties no matter what the starting seed is, so my method will work fine but so will yours.
15:35:04 <bss03> edwardk: That is likely non-uniform and would need some post-processing.
15:35:06 <edwardk> pozic: well, then the smart-ass who cracks the code will give us untold insight into the structure of the universe, so i'm willing to gamble on the hypothesis they are ;)
15:35:26 <pozic> edwardk: that is just pragmatism ;)
15:36:57 <bss03> edwardk: you'd have to do the "00" -> "", "01" -> "0", "10" -> "1", "11" -> "" bit translation to get it uniform, and that can be a poor source of pseudo-random numbers, cause it blocks for arbitrarily long periods of time.
15:37:35 <bss03> (Notation == comsume -> produce)
15:37:42 <edwardk> in practice, i'm fond of systems that just let me throw entropy into a blender and pull out bits that degrade in quality if I pull to fast, as i need them
15:37:51 <edwardk> er too fast
15:38:05 <napping> bss03: you can use larger codes to throw away fewer bits, I think
15:38:25 <pozic> edwardk: I think they usually degrade if you leave them for too long in the blender.
15:38:25 <bss03> napping: Probably, I just remember that tanslation from my UG studies.
15:38:46 <niteria> bss03: isn't it just (01)*|(10)* ?
15:38:49 <napping> yeah, that's certainly an easy one
15:39:14 <napping> it just requires the assumption that each count is independent, without any distribution assumptions
15:39:28 <niteria> ah, ok, nvm, I'm little bit tired ;p
15:39:37 <edwardk> pozic: now i have visions of the http://www.willitblend.com/ guy trying out various bits and pieces of a motherboard
15:39:51 <napping> maybe that doesn't generalize so well
15:40:21 <pozic> edwardk: ah, yes, a forgotten Internet meme.
15:41:02 <bss03> I figure use the twister of the congruential method whenever you need bulk data.  Reseed based on "true random" data (e.g. radioactive decay) just before each bulk read.
15:41:10 <bss03> s/of/or/
15:41:45 <pozic> How do you get radioactive decay in a PC?
15:41:56 <bss03> pozic: kernel drivers!
15:42:32 <pozic> I mean, who actually sells those things? 
15:42:50 <pozic> I can imagine that you cannot even buy those as a normal company.
15:42:58 <bss03> pozic: Actually, I don't think there's one ofr radioactive decay, but /dev/random is post-processed random "noise" based on unpredecitable timing variantations in the operation of the physical parts of the PC.
15:43:12 <napping> http://www.aw-el.com/
15:43:17 <pozic> AFAIK, some of those generators are based on some quantum principles.
15:43:21 <bss03> /dev/urandom is the congruential method, I think.
15:43:38 <napping> It doesn't come with a source, but you can use background radiation if you are patient
15:45:04 <mreh> I'm looking for a strict minimumBy
15:45:39 <mreh> there not already being one makes me sad
15:45:43 <bss03> mreh: Maybe write minimumBy' based on foldl'?
15:46:05 <mreh> bss03: yeah, I thought of just copying the definition and changing it to foldl1'
15:47:21 <bss03> Is your list really long?
15:47:34 <mreh> bss03, 130,000 items
15:47:49 <mreh> pretty long!
15:47:50 <bss03> If not, you can probably just seq or deepSeq after the operation.
15:48:10 <mreh> seq only gives me WHNF right?
15:48:21 <bss03> Yes.  Sorry.
15:49:36 <mreh> it's the minimumBy of a list of minimumBys, my spidey senses tell me I'm doing something naively
15:49:45 <accel> What's a good book to read after Real World Haskell? (not to gain aother introduction to haskell; but to learn more about the rael world / practical / nitty gritty aspects)
15:50:19 <ezyang> non-existent "Advanced Real World Haskell" :^) 
15:50:19 <pozic> accel: there are no other real world Haskell books. Just academic books. 
15:50:25 <Saizan> accel: SPJ's book about implementing functional programming languages
15:50:49 <djahandarie> GHC source code
15:50:52 <edwardk> accel: http://www.amazon.com/Pearls-Functional-Algorithm-Design-Richard/dp/0521513383
15:51:09 <pozic> How much money did RWH make? 
15:51:12 <edwardk> accel: that is probably the best 'high end haskell thinking' book
15:51:17 <accel> edwardk: noted; thanks
15:51:35 <accel> pozic: I bought a copy.
15:51:38 <mreh> this much money
15:53:23 <edwardk> pozic: well, i viewed some slides where it said something about $128k in the first 2 months
15:53:31 <pozic> The Bird book (it is pretty new) seems not bad. 
15:53:52 <edwardk> pozic: found it again http://issuu.com/jon.schaffer/docs/reasons-to-be-excited-paper slide 60
15:54:34 <pozic> Reading books is only useful if there is still really something to learn in that area.
15:54:57 <accel> pozic: what'st eh bird book?
15:54:58 <accel> join #factor
15:55:07 <edwardk> accel: the one i linked
15:55:28 <accel> edwardk: the table of contents looks weak
15:55:42 <accel> edwardk: how does it compare to chris osaki's phd thesis?
15:55:45 <niteria> can anyone recommend something good to read about CPS or Cont Monad?
15:55:56 <edwardk> accel: it is a list of pearls, but equational reasoning is used _very_ heavily throughout
15:56:19 <pozic> edwardk: but no algorithm has ever been invented via equational reasoning, AFAIK.
15:56:22 <edwardk> accel: and they are turned out in an order of incremental complexity, so the equational reasoning tools used build as you go
15:56:33 <monochrom> my http://www.vex.net/~trebla/haskell/cont-monad.xhtml has Cont Monad
15:56:48 <pozic> edwardk: people have an idea and they implement it; later on they rationalize all kinds of ways in which they derived it.
15:56:51 <edwardk> pozic: he actually improves on at least one best known asymptotic bound mid-way through that book -- by equational reasoning!
15:57:04 <pozic> edwardk: which problem?
15:57:09 <niteria> monochrom: I'm reading it right now, I thought about something simpler :)
15:57:12 <pozic> edwardk: if true, interesting :)
15:57:14 <edwardk> i'll have to grab the book and flip through it one sec.
15:57:16 <monochrom> I would think the whole book is invented algorithms
15:57:46 <pozic> monochrom: did you also already read that book?
15:58:04 <niteria> I would like to see how CPS makes code cleaner/cooler/faster
15:58:04 <monochrom> no
15:58:42 <djahandarie> niteria, codensity monad!
15:58:51 <edwardk> pozic: if you have the book handy, it is one of the ones done in the sort of socratic dialog style with the class room
15:59:07 <pozic> edwardk: I don't have the book.
15:59:22 <djahandarie> You get a free CPS transform and possibly asymptotic gain in speed
15:59:34 <accel> edwardk: is this book good enough it's worth my time to find a pirated pdf of it to skim through the contents?
15:59:34 <pozic> edwardk: improving on the bounds of a problem which nobody knows about it also not as impressive.
15:59:43 <byorgey> http://themonadreader.wordpress.com/2011/03/15/special-poetry-and-fiction-edition/
16:00:34 <fryguybob> byorgey: Nice!
16:01:07 <edwardk> pozic: the algorithm in question has a nice hyphenated name, i'm just not placing it atm
16:01:41 <pozic> edwardk: is the problem that hard to explain? I don't care about the algorithm. Just the problem and the bound.
16:01:56 <djahandarie> byorgey, hahaha nice
16:03:05 <djahandarie> LOL @ Anonymous's submission
16:03:22 <byorgey> edwardk, pozic: saddleback search?
16:03:27 <byorgey> djahandarie: =)
16:03:33 <niteria> djahandarie: is there something noob friendly about codensity monad?
16:03:44 <edwardk> byorgey: thats it!
16:03:52 <djahandarie> niteria, hmm... nothing specifically, though I recall a sigfpe article
16:03:56 <byorgey> yeah, that chapter was cool
16:04:00 <djahandarie> But that was just about CPS transforms
16:04:16 <djahandarie> Or was it about Cont
16:04:18 * djahandarie can't remember
16:04:25 <djahandarie> Ah: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
16:04:48 <edwardk> pozic: you can skim the abstract of http://www.springerlink.com/content/6837654p2449501k/
16:05:47 <djahandarie> Hmm, sigfpe doesn't talk about the asymptotic speedups
16:05:51 <djahandarie> But edwardk does in the comments!
16:05:57 <edwardk> pozic: anyways, that was found by equational reasoning, providing a strong existential disproof of your statement ;)
16:06:18 <edwardk> djahandarie: with regards to Codensity?
16:06:23 <djahandarie> Yeah
16:06:26 <edwardk> there is a 'tutorial' of sorts, one sec.
16:06:41 <edwardk> http://www.iai.uni-bonn.de/~jv/mpc08.pdf
16:06:52 <djahandarie> He did say 'noob-friendly' too :P
16:07:03 <edwardk> That paper isn't that scary
16:07:17 <ezyang> ooh, poetry TMR is out. 
16:07:31 <djahandarie> Yeah it doesn't look too bad
16:09:13 <monochrom> there is a fundamental axiom that smart people find smart methods unimpressive.
16:10:35 <ezyang> I.e., once you understand it, it's not interseting anymore? 
16:11:43 <monochrom> no. i.e., self-interest.
16:13:28 <ezyang> Ooh. Dr. Seuss + Higher Order Programming. Awesome. 
16:13:34 <ezyang> Actually, I think he did that... 
16:13:36 <monochrom> suppose you have a lot of ___ to offer. you are inclined to give much credit to ___ and dismiss alternatives. now put "creativity" there.
16:16:59 <joe6> i downloaded a haskell package source using darcs and made some changes to it. I want to submit my changes as a patch to the package maintainer. Is there a simple way to do it?
16:17:24 <ezyang> joe6: 'darcs send' 
16:17:30 <joe6> i do not have access to code.haskell.org, so I guess darcs push is out of question, then.
16:17:36 <cathper> monochrom: I think T. Tao is a fine disproof of the hypothesis; I consider him quite smart, and as far as I have read his texts, he does not seem reluctant to credit others for their smart ways of solving problems.
16:17:40 <joe6> ezyang, thanks.
16:17:41 <ezyang> If the repo was well configured, it should try sending the patch to the right email address. If it's a mailing list you might have to sign up first. 
16:17:53 <ezyang> Make sure you've recorded patch first. 
16:18:14 <joe6> ezyang, will try that. record: is it "darcs record -am"?
16:18:23 <monochrom> cathper: credit people or credit methods?
16:18:30 <ezyang> 'darcs record' will work fine. It will ask you what hunks you want, and for a message. 
16:18:37 <ezyang> "Unlike git commit :-)" 
16:18:41 <joe6> ezyang, ok, thanks.
16:18:44 <cathper> monochrom: Actually both.
16:19:45 <cathper> monochrom: The latest (and only) example I have in mind is T's blog post regarding Dvir et al.'s proof.
16:20:00 <monochrom> crediting smart people strengthens my point, celebrating creativity and downplaying its anti-thesis, methologoly.
16:20:24 <cathper> (I've used the proof strategy to prove other things.)
16:20:37 <monochrom> look at Dijkstra for an example of putting methods above people/creativity. he denounces pulling rabbits out of the hat.
16:20:57 <hpc> but hat-rabbits are the best kind of rabbits!
16:21:03 <hpc> plus they are cute
16:22:09 <cathper> "Sorry, we're out of hat-rabbits, but we have some shoes-rabbits left?"
16:25:12 <cathper> monochrom: The credit is due to what they did and how they did it (and the thoughts behind) rather than "these smart people did this not-so-elegant thing".
16:25:17 <monochrom> then again my statement is merely "inclined to", i.e., statistical.
16:27:48 <jmcarthur> ezyang: git commit --interactive     gives you a slightly more awkward version of the same thing though
16:28:47 <frank00> pardon the naive q, but:  newtype Writer w a = Writer { runWriter :: (a, w) }  <-- why not simply = Writer (a, w)? What' the exact reason which calls for the interface?
16:29:07 <jmcarthur> frank00: basically it gives you a runWriter function "for free"
16:29:17 <monochrom> to win the function runWriter
16:29:24 <byorgey> frank00: that's record syntax; it automatically gives you a projection function  funWriter :: Writer w a -> (a, w)
16:29:27 <jmcarthur> frank00: without using the record syntax like that, you'd just have to write out runWriter manually anyway
16:29:30 <byorgey> er, runWriter
16:29:33 <byorgey> but it is fun
16:29:48 <frank00> ho, to extract the value, right? of course
16:29:50 <frank00> silly me :P
16:30:00 <monochrom> we see that you have just dealt with many fun writers recently. :)
16:30:01 <jmcarthur> no it's a common enough question for you not to feel silly :)
16:30:45 <byorgey> monochrom: indeed =)
16:33:13 <pozic> edwardk: it seems his proof/algorithm is incomplete.
16:34:35 <pozic> It can probably be trivially fixed, but as it currently is, it does not do what it claims to do. 
16:37:35 <joe6> submitted my first patch to a haskell package..
16:37:43 <joe6> thanks ezyang..
16:38:16 <joe6> using darcs, I mean. It was pretty simple, darcs record and darcs send..
16:38:18 <pozic> For someone who likes 'formal methods', he might want to start using Coq, such that he doesn't write false hoods on paper. 
16:38:50 * byorgey awards joe6 a golden hacker lambda
16:39:16 <byorgey> joe6: which package, out of curiosity?
16:39:38 <pozic> joe6pack?
16:40:45 <hpc> > pack joe6
16:40:46 <lambdabot>   Not in scope: `joe6'
16:41:00 <c_wraith> :t pack
16:41:01 <lambdabot> forall o n. (Newtype n o) => o -> n
16:41:05 <c_wraith> heh
16:41:29 <hpc> Newtype is a neat class
16:41:37 <c_wraith> yeah
16:41:56 <c_wraith> I just was expecting it to be the pack in bytestring or something.  which, come to think of it, is a bit silly
16:42:01 <c_wraith> :t B.pack
16:42:02 <lambdabot> Couldn't find qualified module.
16:42:06 <c_wraith> :t BS.pack
16:42:08 <hpc> :t BS.pack
16:42:08 <lambdabot> [Word8] -> BSC.ByteString
16:42:08 <lambdabot> [Word8] -> BSC.ByteString
16:42:39 <hpc> Newtype reminds me how surprising it is that there isn't a Bijection typeclass
16:43:04 <c_wraith> wouldn't that be an MPTC?
16:43:07 <hpc> there's a data Bi a b = Bi {from :: b -> a, to :: a -> b}
16:43:24 <roconnor> bijections are not alway canonical
16:43:33 <hpc> ah, fair
16:43:46 <hpc> Monoids aren't always canonical either though
16:43:58 <hpc> though perhaps there are "fewer" moniods than bijections
16:44:15 <roconnor> there are fewer MPTC issues with monoid
16:44:29 <hpc> MPTC == multi parameter type class?
16:44:32 <roconnor> yes
16:44:52 <roconnor> I like data Bi a b
16:44:56 <roconnor> often called Iso a b
16:45:04 <roconnor> it forms a category
16:45:11 <roconnor> actually a groupoid
16:45:33 <hpc> where the identity is from . to, and composition is \f -> from . f . to?
16:45:53 <roconnor> identity = Bi id id
16:46:09 <hpc> ah
16:46:20 <roconnor> (Bi f1 g1) `compose` (Bi f2 g2) = Bi (f1 . f2) (g2 . g1)
16:46:33 <hpc> ooh, groupoid is a Category where each morphism has an inverse
16:46:36 <roconnor> yes
16:46:36 <hpc> neat
16:46:51 <hpc> i expected it to be something nuts
16:47:00 <hpc> and it was! but it was a pleasantly simple nuts
16:47:05 <roconnor> categories are really monoidoids
16:47:09 <hpc> lol
16:47:34 <hpc> abstract nonsense at its finest!
16:48:09 <roconnor> my Multiplate paper is on the arXiv now. ... I forget who I was supposed to tell
16:49:44 <byorgey> me!
16:50:11 <roconnor> http://arxiv.org/abs/1103.2841
16:50:53 <byorgey> thanks
16:51:21 <dolio> My paper disproving Goedel's Incompleteness Theorem is on arXiv. :)
16:51:41 <roconnor> dolio: my paper proving Goedel's Incompleteness Theorem is on arXiv.
16:51:42 <accel> does it solve the halting problem and prove p != NP too ?
16:51:45 <dolio> Hahaha.
16:52:00 <roconnor> dolio: http://arxiv.org/abs/cs/0505034
16:52:05 <copumpkin> is arxiv gonna explode for having contradictory papers on it now?
16:52:08 <copumpkin> damn you guys
16:52:18 <byorgey> *POOF*
16:52:26 <byorgey> arxiv disappears in a puff of logic
16:52:38 <copumpkin> maybe it should be semantically linked somehow
16:52:54 <dolio> Is the monadic real numbers paper on there, too?
16:52:59 <copumpkin> "see also: [disproof of same statement] dolio's paper"
16:53:28 * roconnor needs to turn his 19 page paper into a 12 page ICFP paper
16:53:32 <roconnor> dolio: yes
16:53:52 <roconnor> dolio: http://arxiv.org/abs/cs/0605058
16:53:57 <Pseudonym> copumpkin, arxiv is paraconsistent.
16:54:07 <dolio> I've got that one already, actually.
16:54:48 <roconnor> oh
16:54:56 <roconnor> I should upgrate the comments on that paper
16:55:03 <roconnor> oh 
16:55:11 <dolio> Whatever happened to the Haskell implementation. Is it significantly faster than CReal?
16:55:12 <roconnor> the journal reference is there after all
16:55:21 <roconnor> it is significantly slower than CReal
16:55:25 <dolio> Oh.
16:55:51 <copumpkin> is it called fewdigits because you can only get a few digits before you give up and kill the program?
16:56:05 <hpc> lol
16:56:06 <Pseudonym> Just because arxiv asserts p and arxiv asserts ¬p, this doesn't entail that arxiv asserts p ∧ .
16:56:14 <Pseudonym> p ∧ ¬p
16:56:22 <roconnor> whee, if I cut out the appedices, it is 12 pages
16:56:27 <roconnor> perfect fit
16:56:33 <Pseudonym> Supplermentary material!
16:56:36 * copumpkin wonders what to eat for dinner
16:56:39 <byorgey> roconnor: nice =)
16:56:53 <hpc> Pseudonym: obviously arxiv posits the existence of a universe in which every paper is true
16:56:57 <Pseudonym> copumpkin: I suggest suppermentary material.
16:57:44 <copumpkin> I prefer meat
16:57:46 <Pseudonym> Mind you, that would explain why P != NP on arxiv.
16:58:20 <hpc> copumpkin: bananas, envelopes, lenses and barbed wire!
16:58:28 <copumpkin> still no meat
16:58:42 <hpc> but it has iron from the wire and fiber from the envelope paper!
16:58:45 <hpc> good enough for an engineer
16:59:32 <copumpkin> true that
16:59:37 <copumpkin> alright, gonna walk home
16:59:38 <copumpkin> bbiab
16:59:42 <Pseudonym> Deforestation == habitat destruction.
16:59:42 <_Ray_> Hey :) What am I doing wrong in here? http://hpaste.org/44807/basic_list_monad . I'm trying to get sums to be [n + m | n <- dice, m <- dice]
17:00:07 <dolio> return n + m = (return n) + m
17:00:07 <hpc> _Ray_: that's just gonna give you a bigger list
17:00:21 <dolio> You want return (n + m)
17:00:24 <hpc> or that
17:00:25 <_Ray_> ohhhh
17:00:33 <hpc> oh, sumSSSSS
17:00:36 * hpc herps a derp
17:01:00 <_Ray_> thanks :)
17:01:13 <dolio> The perils of the return name.
17:01:50 <hpc> dolio: i contend that it is in fact imperative languages that chose poorly
17:01:57 <hpc> :P
17:02:23 <dolio> I'm not sure what you mean.
17:02:33 <hpc> me neither, but i stand by my baseless assertion
17:09:09 <joe6> byorgey, llvm
17:41:46 <ezyang> How do I make +RTS -p give me profiling info for libraries that the HAskell program used too? Do I have to use some special build flags? 
17:42:02 <hpc> you need profiling versions of those libs
17:42:25 <hpc> never had to bother with that, so dunno more about installing them
17:42:43 <ezyang> In particular, this is profiling ghc itself 
17:43:01 <hpc> that's entirely beyond me :P
17:43:04 <ezyang> hpc: That's my recollection too 
17:43:12 <Saizan> you've to compile them with -auto-all -caf-all too, not just -prof
17:43:25 <ezyang> But IIRC, the profiling version of the executable won't build at all if you don't have profiling versions of the libraries. 
17:43:28 <ezyang> Hmmm. 
17:43:40 <Saizan> i.e. you already have the profiling version of them, they just don't have any cost centres
17:43:52 <ezyang> ah, makes sense. 
17:44:17 <Saizan> ghc-prof-options: -auto-all -caf-all in their cabal file should help, iirc
17:45:41 <dcoutts_> Saizan, ezyang: it's not clear to me how we should manage this better. In general there are many different options you might want for each profiling lib
17:45:56 <dcoutts_> depending on how much you want to see things from that lib show up in the profile
17:46:11 <dcoutts_> having N copies doesn't seem very nice
17:46:11 <ezyang> From a flexibility perspective, it would be great if cost centers could be tweaked at runtime. 
17:46:27 <dcoutts_> aye, unfortunately they also have a compile time cost and effect on the code
17:46:32 <ezyang> But I bet the way profile builds are actually implemented that's not very easy. 
17:46:36 <Igloo> It's worse than n copies. It's n copies /for each combination of the options for the dependencies/
17:47:15 <dcoutts_> Igloo: you mean because some SCC changes could change the ABI
17:47:25 <Igloo> Yup
17:47:32 <ezyang> I don't really mind recompiling, I guess, as long as it's easy to recompile just want I want to cabal-dev style. 
17:48:22 <ezyang> Because if I'm doing deep inner library profiling work, I don't actually want to reuse old profiling libraries. 
17:48:27 <Saizan> most of the time you're hacking the lib you want the cost centres from, so it's not much of an issue
17:48:28 <dcoutts_> right
17:49:09 <ezyang> Does cabal-dev let you do that yet? 
17:49:19 <dcoutts_> ezyang: do what?
17:49:36 <ezyang> say, "build this project, with specific profiling options for such and such libraries" 
17:50:01 <dcoutts_> ezyang: btw, you ought to be able to do the same, albeit slightly less conveniently using cabal and --prefix and --package-db flags
17:50:14 <ezyang> Yeah, that's what cabal-dev tries to manage for you :-) 
17:50:20 <dcoutts_> ezyang: and then list the deps you want to rebuild with --reinstall
17:50:28 <dcoutts_> and the prof flags
17:51:09 <Saizan> the only part that's hard is providing profiling options from the CLI, afaiu
17:51:30 <ezyang> I also kind of wonder if it's possible to compensate for the differential in SCC's that causes code being profiled to be even slower. 
17:53:38 <dcoutts_> Saizan: and that's mainly because we don't yet have any good suggestions for the CLI
17:53:48 * dcoutts_ finds the ticket in the hope that someone has a good idea
17:54:05 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/200
17:54:31 <dcoutts_> oh, and someone has a patch
17:54:49 <dcoutts_> gah, I hate that track does not let one search for tickets with attachments
17:55:20 <ezyang> y'all should start use keywords with 'patch' 
17:56:06 <dcoutts_> ezyang: ah but someone who knows the system has to do it
17:56:14 <dcoutts_> and has to notice that someone added a patch
17:56:33 <dcoutts_> but the other misfeature is that trac does not send a notification email when someone adds an attachment
17:56:36 <Igloo> Yeah, the problem is that if someone adds a patch but doesn't leave a comment, then trac doesnt' send a mail
17:56:38 <dcoutts_> only on comments
17:56:48 <ezyang> "there, fixed it for you". 
17:56:51 <ezyang> Oh, that's annoying! 
17:57:16 <dcoutts_> eZet: right, so unless they leave a comment, and someone notices and adds the patch keyword or whatever, then we miss it
17:57:23 <dcoutts_> oops, ezyang 
17:57:47 <ezyang> Can we... fix that? 
17:58:15 <dcoutts_> ezyang: probably but I suspect it'd involve python coding to patch trac
17:58:16 <ezyang> I feel like it must be fixed in a later version, or something. 
17:58:22 <ezyang> It's just so flagrant. 
17:58:23 <frank00> # instance Monad ((->) r) where  -- etc. <-- how is this monad called? Reader?
17:58:36 <hpc> that is indeed reader
17:58:36 <dcoutts_> ezyang: if someone has a moment to look into it, it'd be a great service
17:58:42 <frank00> thanks hpc
17:58:58 <hpc> albeit not in the newtype wrapper
17:59:25 <hpc> @unmtl Reader r a
17:59:26 <lambdabot> r -> a
17:59:29 <hpc> :P
17:59:40 <dcoutts_> Saizan: btw, on that ticket, there's no suggestion for cabal install, for a way to specify which deps you want to use profiling with
18:02:32 <ezyang> Hmm, adding those options didn't seem to do what I wanted it to do. 
18:05:13 <MarcWeber> dcoutts: Trying to build gtk2hs: http://dpaste.com/505240/ any idea why lines 13 instead of lines 36 are generated?
18:05:52 <ezyang> Well, here's the bug http://trac.edgewall.org/ticket/2259 
18:10:57 * hackagebot stm-io-hooks 0.7.2 - An STM monad with IO hooks  http://hackage.haskell.org/package/stm-io-hooks-0.7.2 (PeterRobinson)
18:13:12 <dcoutts_> MarcWeber: which form of code is generated depends on a setting, it's the generic signal handler system or the old style (the old style is clearly bitrotted and should probably be removed since the new stuff works fine afaik)
18:14:04 <dcoutts_> MarcWeber: I'm not sure how the build system controls the setting now though, it changed with the switch in build system from autoconf to cabal
18:14:21 <MarcWeber> and haskell.org/gtk2hs is down and referenced very often.
18:14:34 <MarcWeber> dcoutts_: I guess knowing that there is a flag already helps ..
18:30:51 <parcs> @pl \x -> [1..x]
18:30:51 <lambdabot> enumFromTo 1
18:31:31 <napping> It's small enough that I'm thinking of just working directly with the small symbols - it just has to multiply
18:31:58 <napping> oops
18:32:08 <parcs> @pl \x -> ['a'..x]
18:32:08 <lambdabot> enumFromTo 'a'
18:36:27 * _Ray_ is amazed lambdabot can do that.
18:37:50 <_Ray_> not to brown nose the language, but many things in haskell still leave me with the same feeling of awe that advanced data structures, parsers, and complicated algorithms gave me before I studied CS. and that's awesome, because it'd be extremely boring to not be amazed at anything.
18:38:42 <napping> enumFromTo is how [l..u] is defined
18:38:58 <napping> so that bit's only superficially impressive
18:39:06 <bss03> _Ray_: been playing with GADTs or Type Families?
18:39:12 <napping> eliminating the variables once it's got \x -> enumFromTo 'a' x is the interesting part
18:39:16 <ezyang> unsurprisingly, Hoopl's slow point is arfGraph. :-/ 
18:39:22 <ezyang> That's not very much for me to work on. 
18:39:22 <_Ray_> not even close, barely scratching monads and functors
18:39:33 <bss03> _Ray_: I'm still a bit wowed by them; but then, I haven't had call for them in my practical programs, yet.
18:40:12 <napping> bss03: tried Agda?
18:40:12 <bss03> _Ray_: I think I might understand the MTL now.  Been trying to document some code that uses it.
18:40:13 <parcs> @src enumFromTo
18:40:14 <lambdabot> Source not found. :(
18:41:14 <bss03> _Ray_: I was really impressed with STM, particualrly the intelligence of retry.
18:41:34 <_Ray_> software transactional memory?
18:42:19 <bss03> napping: Heard of it, not written any yet.  Haskell is pretty much what I wanted in a lanuage. Lazy; Strongly, Statically typed; with good type inference and a freely available standard.
18:42:30 <bss03> _Ray_: Yep.
18:42:35 <joe6> i am trying to read the llvm parse tree after reading the bitcode file: http://pastebin.com/z8fnzaAN
18:42:43 <joe6> any suggestions, please? 
18:43:04 <aavogt> bss03: lots of things are outside the standard
18:43:46 <bss03> aavogt: I know.  Lots of things are done outside the C and C++ standards, too.
18:44:43 <joe6> I think I am stuck at this point. I need to get the details of the ModuleValue..
18:44:52 <bss03> aavogt: I try to restrict myself to the standard when practical (even when writing C/C++), but I'm well aware the standard isn't the ends of the langauge.
18:44:56 <joe6> newtype ModuleValue = llvm-0.9.1.0:LLVM.Core.CodeGen.ModuleValue LLVM.FFI.Core.ValueRef
18:45:13 <joe6> is that even possible?
18:45:24 <napping> bss03: dependent types are nicer than the half measures
18:45:27 <bss03> Did Haskell 2010 finally make MPTCs part of the standard?  They are downright essential for most stuff.
18:45:35 <napping> bss03: Agda doesn't exactly have a fixed standard or anything
18:45:56 <bss03> napping: That would detract from it, for me.
18:46:08 <napping> It's still being developed
18:46:45 <bss03> napping: Well, since I'm woefully undereducated to help with modern efforts on functional programming, call me when you have a draft. ;)
18:47:32 <shachaf> Calling Agda "programming" is a bit of a stretch, isn't it?
18:48:41 <Saizan> joe6: llvm-0.9.1.0:LLVM.Core.CodeGen.ModuleValue is the fully qualified name of the constructor
18:49:47 <joe6> Saizan, I am trying to get the instructions in that function (for example, testa).
18:50:07 <kniu> I got a <<loop>>
18:50:18 <kniu> Any way the RTS can tell me where it came from?
18:50:20 <joe6> Saizan, I am hoping that deciphering the ModuleValue will somehow give me the tree of instructions.
18:50:39 <joe6> Saizan, I am trying something as:  castModuleValue . snd $ head values
18:50:58 <joe6> Ambiguous type variable `a0' in the constraint: (IsType a0) arising from a use of `castModuleValue'
18:51:08 <joe6> Saizan, that is what I get when I try that.
18:51:12 <Saizan> joe6: yeah, you've to specify which type you want
18:53:50 <Guest31934> hi all
18:53:55 <joe6> Saizan, that is what I am struggling with. finding out what type it could be.. and then walking down the instruction tree..(or dag, in llvm terminology).
18:55:08 <Saizan> joe6: i don't see a function to extract the instructions, actually
18:55:16 <Saizan> joe6: do you?
18:55:46 <_Ray_> How I feel when I read people in #haskell: http://www.dangerousminds.net/images/uploads/1269385664419_thumb.jpeg
18:56:16 <joe6> Saizan, modulvalues <- getModuleValues modul, where modul modul <- readBitcodeFromFile "helloO.bc"
18:56:30 <joe6> Saizan, gives me the function names.
18:56:52 <joe6> i think the type below a function is a BasicBlock.
18:57:04 <joe6> and then the BasicBlock has instructions under it.
19:00:15 <Saizan> yeah, but there's no haskell type for instructions, nor a function to extract something like that from a BasicBlock?
19:00:58 <Saizan> it might be that these bindings cover only the generating code part
19:03:16 <joe6> Saizan,there are dumpValue, dumpType, getValueName. let me see if they can do something.
19:04:43 <joe6> Saizan, i understand what you are saying. I was thinking of printing out the LLVM IR tree from Haskell. It appears that it is not possible. 
19:05:50 <joe6> Saizan, how does the llvm optimizeModule work (as you said, maybe the bindings just extend to the generating code part)..
19:07:16 <Saizan> i think optimizeModule just makes llvm do the optimizations through FFI
19:07:29 <_Ray_> :t (***)
19:07:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
19:08:51 <joe6> Saizan, makes sense..
19:09:06 <joe6> Saizan, btw, any thoughts on how I can add the type to this: http://pastebin.com/sWygsph8
19:12:40 <levi_> ..
19:13:41 <Saizan> joe6: you can "let Just mf' = castModuleValue =<< lookup "testa" funcs :: Maybe (Value Something)"
19:15:15 <levi_> i have problem on follow the steps in http://hackage.haskell.org/trac/ghc/wiki/Building/Porting. is there any advices?
19:16:14 <joe6> levi_, what problems.
19:16:59 <levi_> i donot very understand the host/build/target machine.
19:17:19 <levi_> thats 1st.
19:18:02 <levi_> i have a ubuntu and a target board. and trying to port to the board.
19:18:53 <levi_> on the ubuntu, have crosscomplier installed already.
19:20:09 <mm_freak> an iteratee receiving an EOF must never continue, right?
19:20:32 <levi_> in my case, which do host/build/target indicate?
19:23:22 <ezyang> What happens if you put an SCC in a function that gets inlined? 
19:24:28 <dcoutts_> ezyang: ghc does the right thing
19:24:34 <ezyang> ok. 
19:26:42 <joe6> levi_, normally, host would be your ubuntu machine and target in the board where you are porting to.
19:27:32 <joe6> i think in your situation, host = build machine.
19:29:19 <levi_> thx, in my case, on the target, there is no native gcc/perl/..., does port possible?
19:31:13 <kinghajj> Would anyone mind looking over some code for problems? (http://hpaste.org/44809/hduhs) It's a program to recursively traverse a directory and sum the file sizes. Problem is that for huge trees, mem usage slowly gets really high.
19:35:47 <levi_> joe6, thx, in my case, on the target, there is no native gcc/perl/..., i have just a cross compiler now, is port possible?
19:37:46 <napping> kinghajj: did you compile with -O2?
19:38:44 <napping> or take a heap profile?
19:39:00 <kinghajj> I'm not too familiar with Haskell profiling. Any reading suggestions?
19:39:19 <kinghajj> I believe the executable I tested was compiled with -O2 or -O3, but I'll try again.
19:41:25 <napping> the user's guide. +RTS -hp should record a profile something.hp while it runs
19:43:18 <kinghajj> "invalid heap profile option: -hp"
19:44:17 <napping> http://www.haskell.org/ghc/docs/7.0-latest/html/users_guide/using-ghc.html#rts-profiling
19:44:29 <napping> It's actually -hT
19:45:52 <kinghajj> Same error still, "invalid heap profile option"
19:46:09 <_Ray_> So >>= can be considered "a fun way to combine functions"? And a monad can be considered a sort of context in that respect?
19:46:11 <kinghajj> Even the ones listed in the RTS usage give errors.
19:46:48 <kinghajj> This is how I'm compiling, if that helps: ghc -O2 -threaded -rtsopts -prof --make hdu
19:47:15 <napping> and then running ./hdu +RTS -hT -RTS <options>
19:47:36 <napping> try the +RTS -? to list available RTS options
19:49:25 <kinghajj> +RTS -? prints the same usage text as when I put -hT/-hx in the RTS options.
19:49:33 <kinghajj> The first command still gives an error.
19:49:55 <napping> what usage text did you get?
19:50:05 <napping> Also, what ghc are you using?
19:50:08 <kinghajj> Usage: <prog> <args> [+RTS <rtsopts> | -RTS <args>] ... --RTS <args>
19:50:10 <napping> This works for me recently
19:50:13 <kinghajj> And then a bunch of descriptions.
19:50:28 <napping> what command line are you using to run it?
19:50:41 <kinghajj> ./hdu +RTS -hT -RTS
19:50:55 <napping> does your program need other options?
19:51:04 <kinghajj> No, it takes no command line args.
19:51:13 <kinghajj> It just uses the current working directory.
19:51:40 <kinghajj> ghc 7.0.2
19:51:48 <kinghajj> Arch Linux
19:51:59 <napping> try just ./hdu +RTS -hT
19:52:08 <kinghajj> Same thing.
19:52:16 <napping> works for me
19:52:28 <napping> ghc --make -rtsopts test -o testp
19:52:35 <napping> ./testp +RTS -hT 
19:52:38 <napping> makes testp.hp
19:53:16 <kinghajj> OK, I just recompiled with "ghc -O2 -rtsopts --make hdu" and now it seems to work!
19:53:29 <kinghajj> Maybe -threaded messes things up?
19:54:30 <napping> doesn't seem to
19:55:23 <accel> is there a haskel dsl with support of ssd block sizes?
19:55:28 <accel> i.e. to make it easy to create data structures
19:55:32 <accel> that use ssd as slow ram?
19:56:12 <_Ray_> Waaaait. Is this true? "fmap :: (Functor f) => (a -> b) -> f a -> f b" <=> "(Functor Socrates) => (Man -> Mortal) -> Socrates Man -> Socrates Mortal"
19:57:12 <kinghajj> "To make use of the profiling system all modules must be compiled and linked with the -prof option." Does this mean I need to recompile and everything to use profiling?
19:57:33 <napping> I think that's not actually necessary for basic heap profiling?
19:57:41 <napping> anyways, building with -prof should use profiling versions
19:57:54 <napping> Is your heap full of Integer?
19:58:49 <kinghajj> Well, when I built with -prof I get the usage error, but without I get a .hp file with an empty graph! It shouldn't be full of Integer, since I'm not storing the intermediate sizes, but adding them to an accumulator. I would expect any garbage to be collected.
19:59:06 <napping> but your accumulator doesn't seem to be strict
19:59:16 <napping> it's kept inside the pair, and pairs are lazy, so maybe that's trouble?
19:59:18 <kinghajj> Ah, that could be it. I'll try that.
19:59:21 <napping> how much heap do you lose?
20:00:01 <napping> That might explain 100 bytes per file, but probably less
20:02:52 <drhodes> kinghajj: within the .config file in ~/.cabal, there are two profile flags that need to be set to true for future hackage builds to be profile enabled, if you've not seen that yet.
20:03:52 <orclev> anyone happen to know if it's possible to use wx inside of ghci, or is that still broken?
20:05:42 <kinghajj> Strictness annotations seem to have done the trick. Thanks!
20:05:58 <napping> also, that if nesting looks suspicious
20:06:05 <napping> probably some kind of monad
20:06:07 <kinghajj> Yeah, it's hideous.
20:06:17 <kinghajj> I'm not too familiar with monad transformers yet, though.
20:08:43 <napping> MaybeT, perhaps
20:08:55 <kmc> MaybeT perhaps indeed
20:12:26 <orclev> ok, then perhaps a bit of advise, I'm trying to experiment with some GUI stuff in haskell, and I had picked wxHaskell because it's at least in theory cross-platform... but it's looking near impossible to get it to build on windows... any suggestions for an alternative GUI library?
20:13:45 <Axman6> orclev: gtk2hs is the most well maintained
20:14:06 <kmc> fuck windows
20:14:21 <kmc> "i'm trying to write a computer program, by the way i need to do it blindfolded with one finger"
20:14:24 <Axman6> that too
20:15:07 <ManateeLazyCat> Axman6: Yeap, 
20:15:52 <orclev> yeah well, I'm not much of a fan of it either, but if you want to write a program that's used by more than just other programmers you've got to support at least OS X if not Windows
20:16:00 <kmc> or you can support the Web
20:16:14 <orclev> yeah, but then your limiting yourself in other ways
20:16:24 <orclev> there's always mobile to, but that's another can of worms
20:16:25 <kmc> also i know a *lot* of non-programmers who use Linux
20:16:32 <kmc> but i'll admit it's still a strong minority
20:16:50 <kniu> aw jeez
20:16:51 <Axman6> wx doesn’t work very well on OS X in my experience
20:16:52 <kmc> if you go to nerd school then it's viable to run Linux even if you're not a computer expert
20:16:55 <kmc> because many people will help you
20:16:55 <kniu> I need ideas
20:17:03 <kmc> in fact you can get better help that way than if you run windows
20:17:07 <kmc> outside of nerd school it is not as easy
20:18:20 <kniu> So I got a giant [((Int, Int), (Double, Double))] values that I'm trying to turn into an Array (Int, Int) Double
20:18:23 <orclev> wx seems to be very... picky... the python bindings seem to function very well in Linux and Windows (not sure on OS X as I haven't tried it), but the other language bindings seem really hit and miss... plus I can't compile from source in windows due to a bug in mingw
20:19:04 <kmc> the limitations of webapps are decreasing by the day while the limitations of windows desktop apps are only getting worse
20:19:22 <kniu> Thing is, the accumulation can't continue until EVERY SINGLE ONE of those (Double, Double)s has been calculated for a given (Int, Int).
20:19:44 <kmc> desktop gui apps are the absolute ass-end of software development and i mean this for Linux as well
20:19:45 <kniu> Running my program requires far more memory than my computer has available.
20:20:05 <kmc> can you accumulate as you go kniu?
20:20:12 <kniu> kmc, nope.
20:20:32 <kniu> The second Double is a probability
20:20:58 <kniu> and until I know all the probabilities for a given pixel, I can't know how to weight the first Double.
20:21:24 <orclev> what's the transformation from ((Int, Int),(Double,Double)) -> ((Int,Int),Double)?
20:21:39 <kmc> snd-weighted sum apparently
20:23:34 <frank00> emh, I know this is far off topic and a bit strange to ask, but : is there anyone here who has bought Potassium iodide?
20:26:56 <kmc> kniu, can't you still do it incrementally
20:27:03 <kmc> by summing the fsts and the snds separately
20:27:07 <kmc> and then dividing when you reach the end
20:28:12 <kniu> that's not really the accumulator function.
20:28:39 <kmc> frank00, no, but i once bought dihydrogen monoxide
20:29:12 <frank00> ... kmc
20:29:23 <kmc> !!!
20:29:29 <frank00> :D
20:30:13 <orclev> careful with that stuff kmc, it's deadly
20:30:42 <shachaf> I'm sure kmc knows what he's dealing with.
20:30:51 <kmc> relax, i'm an expert
20:31:08 <kmc> safety third
20:35:20 <maurer_> kmc: Right. Awesome and Lazy come first.
20:42:43 <kmc> cool guys don't look at explosions
20:43:16 <Pseudonym> J.J. Abrams isn't that good a keyboard player.
20:45:33 <kmc> neither was J. J. Thompson
20:45:36 <kmc> Thomson*
20:46:13 <Pseudonym> You don't know that for sure.
20:46:43 <ddarius> You don't know that he doesn't know that for sure for sure.
20:48:06 * ddarius creates a sequence of sentences requiring nth-person pronouns for arbitrary n.
20:48:35 <Pseudonym> Please express that in modal logic.
20:51:37 <ddarius> K(Pseudonym, K(kmc, goodplayer(thomson, keyboard)))
20:52:11 <ddarius> Now if it were common knowledge that kmc didn't know this...
20:52:43 <applicative> kmc being excluded ...
20:53:11 <shachaf> > '�'
20:53:12 <lambdabot>   '\65533'
20:53:22 <kmc> ∈
20:53:28 <ddarius> We'll need to mix in some doxastic logiic.
20:54:50 * ddarius considers going to get some ice cream.
20:54:58 * ddarius doesn't know when the last time he had ice cream was.
20:55:09 <applicative> doxastic logic can't get the pronouns right for the standard sorts of case
20:59:15 <applicative> Jones knows that Smith knows that Jones knows that Smith knows ... where it is of interest is Jones knows that Smith knows that he himself (I,Jones) know that she herself (I, Smith) knows ...
21:00:16 <ManateeLazyCat> orclev: Don't worry, we have plan to build gtk2hs Window Installer.
21:04:09 <_Ray_> Is this true? "fmap :: (Functor f) => (a -> b) -> f a -> f b" <=> "(Functor Socrates) => (Man -> Mortal) -> Socrates Man -> Socrates Mortal"
21:04:51 <copumpkin> Mortal sounds like a predicate
21:05:10 <kmc> agda proof or it didn't happen
21:05:15 <copumpkin> :)
21:05:28 <_Ray_> I'm just wondering if there's such a connection to propositional logic inside the type system
21:05:30 <pastorn> _Ray_: that seems like something you would express in prolog, not haskell
21:05:32 * ddarius would not use an "Agda proof" for evidence that some logical thing "happened."
21:05:39 <copumpkin> _Ray_: there is definitely one
21:05:46 <copumpkin> ddarius: :(
21:06:01 <pastorn> man(socrates), mortal(X) :- man(X).
21:06:06 <Jafet> type Mortal = Died
21:06:15 <pastorn> -? mortal(X).
21:06:21 <pastorn> X = socrates.
21:06:32 <napping> (socrates : Man) -> ((m : Man) -> Mortal m) -> Mortal socrates ?
21:06:32 <copumpkin> ddarius: I implemented the grothendieck construction in agda btw
21:06:44 <ddarius> copumpkin: The small one or the big one?
21:06:59 <copumpkin> small I think? What's the difference?
21:07:04 <copumpkin> it feels rather small
21:07:17 <kmc> that's what she said
21:07:24 <_Ray_> hahaha
21:07:25 <kmc> (zing)
21:07:26 <copumpkin> :(
21:07:47 <_Ray_> nice to know that's still funny for the people with IQs above 130
21:07:56 <kmc> _Ray_, you're assuming a lot here
21:08:45 <_Ray_> I assume at least an Ms. Sc. for anyone who understands :t (***)
21:08:49 <ddarius> copumpkin: The big one takes an indexed category and produces a fibration.
21:08:53 <_Ray_> *Bs. Sc.
21:09:23 <copumpkin> ddarius: definitely not that one, then, but I can see how I might go about that too, once I have those two things available as constructs in my library
21:11:23 <ddarius> copumpkin: Do you have colimits yet?
21:11:53 <copumpkin> nope, this grothendieck construction is pretty much the only thing (along with the category of agda setoids) I've done since I last spoke to you about it
21:13:04 <ddarius> Well if you did, you could use that Grothendieck construction to prove that all presheafs are the colimit of representables.
21:13:17 <kniu> @pl (\(_, x) (_, y) -> f x y)
21:13:18 <lambdabot> (. snd) . f . snd
21:13:29 * ddarius goes searching for his copy of Categories for the Working Mathematician again.
21:14:19 <copumpkin> ddarius: ah, neat. I'll put it on my todo
21:15:32 <ddarius> Make ends and coends first.
21:16:01 <djahandarie> _Ray_, want to get your Bs. Sc. in under 30 seconds?
21:16:06 <djahandarie> :t (***)
21:16:07 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
21:16:13 <djahandarie> Replace a with (->)
21:16:19 <kmc> here in the states we call it a "BS"
21:16:23 <_Ray_> :p
21:16:28 <copumpkin> ddarius: yessiree! 
21:16:29 <kmc> named after the primary skill required to obtain one
21:16:43 <x6763-> ~nanotube@unaffiliated/nanotube * nanotube is a major troll
21:16:55 <_Ray_> that's not really true at least here (argentina). 5-6 years degree, little bullshit. except you "need" to write a thesis.
21:17:08 <_Ray_> which turns out to be a bad way to encourage academic discipline, and a good way to encourage trash papers
21:17:21 <djahandarie> _Ray_, that is really what (***) is normally used for. There are other Arrows besides (->), but normally people just use it with (->)
21:17:43 <djahandarie> If we take a look at the kind of (->), it is * -> * -> *
21:18:01 <djahandarie> Which means it does indeed fit in that type as "a".
21:18:02 <_Ray_> I didn't even know -> could have a kind
21:18:14 <Jafet> :k (->)
21:18:15 <lambdabot> ?? -> ? -> *
21:18:15 <djahandarie> It eats two things and spits another out :)
21:18:25 * _Ray_ continues reading through typeclassopedia
21:18:36 <djahandarie> (The ?? and ? are just for GHC specifics)
21:18:47 <djahandarie> (Namely unboxed stuff)
21:19:02 <djahandarie> I need to sleep though. Have fun with typeclassopedia!
21:19:04 <_Ray_> I understand the concept behind a category, a functor, and a monad. Now I just need to get an intuition for what lift, fmap, return and >>= do and how they work together.
21:19:05 <Jafet> @instances Arrow
21:19:05 <lambdabot> (->), Kleisli m
21:19:06 <_Ray_> Thanks :)
21:19:17 * ddarius won't say that saying "replace a with (->)" is like saying ":t (>>=), now replace m with nothing."
21:19:30 <Pseudonym> I would like to write most of my code in the arrow W a -> M b for some comonad W and monad M.
21:19:36 <Pseudonym> But syntax prevents this.
21:20:12 <kmc> _Ray_, (->) is a type constructor like Either
21:20:18 <kmc> which is to say it takes two types and gives you a type
21:22:05 <kmc> i can explain the ? and ?? business if you like
21:22:25 <_Ray_> I'll try to muddle through until I can understand monads intuitively
21:22:47 <_Ray_> without any analogies ("monads are like donkeys, they ..."), but without a purely mathematical symbol-replacing definition either
21:22:57 <kmc> there may not be anything left
21:23:07 <copumpkin> monads are like triples of things containing one functor and two natural transformations
21:23:08 <kmc> "Monad" is the name of a very simple, general API
21:23:21 <kmc> the particular types which implement this API don't have a whole lot in common with each other
21:23:23 <_Ray_> like, I still consider it magic that join x = x >>= id, even if the types match
21:23:34 <monochrom> use a lot of exercises and examples
21:23:46 <kmc> _Ray_, can you give a definition of what join *should* be, other than (>>= id)?
21:23:48 <_Ray_> copumpkin, yeah, that I get. A functor that takes types to types, a unit (return) and a join
21:23:52 <Pseudonym> @free join :: M (M a) -> M a
21:23:52 <lambdabot> $map_M f . join = join . $map_M ($map_M f)
21:24:04 <copumpkin> _Ray_: do you understand how return and join are natural transformations in haskell?
21:24:14 <kmc> does @free assume that M is a functor there?
21:24:19 <Pseudonym> Yes.
21:24:20 <_Ray_> That's the problem, the only things I know about join are 1) its type definition, m m a -> m a, and 2) its implementation as 'concatenate' for []
21:24:33 <Pseudonym> @free naturalTransformation :: F a -> G a
21:24:33 <lambdabot> $map_G f . naturalTransformation = naturalTransformation . $map_F f
21:24:54 <_Ray_> I can't even parse >>= id intuitively.
21:25:19 <Pseudonym> If it's not a covariant functor, then it doesn't have a easy to express free theorem.
21:25:24 <_Ray_> copumpkin: I'm not yet comfortable with the notion of "natural" transformation. Only place I saw it was the "natural" transformation between, for a vector space V, V and V**.
21:25:48 <Pseudonym> Ray: Do you understand about the "forall" in polymorphic types?
21:25:52 <_Ray_> Sure.
21:25:58 <Pseudonym> For example:
21:26:00 <Pseudonym> :t reverse
21:26:01 <lambdabot> forall a. [a] -> [a]
21:26:20 <_Ray_> forall a. M a -> M' b <-> M => M', => a natural transformation
21:26:22 <Pseudonym> Basically, saying "reverse is a natural transformation" means "that forall is _really_ a forall".
21:26:27 <_Ray_> err, M a -> M' a.
21:26:39 <Pseudonym> Meaning, reverse works for _any_ type a.
21:26:48 <_Ray_> What's the contrary to that?
21:26:50 <Pseudonym> Even if it's not printable, or equality-testable, or anything.
21:27:11 <_Ray_> The term "transformation" itself assumes something "natural transformation" doesn't?
21:27:36 <Pseudonym> "Natural" in this case means that what reverse does can't depend on any of the values in the list.
21:27:47 <ddarius> ncatlab is being puerile.
21:27:56 <copumpkin> ddarius: how so?
21:28:06 <_Ray_> See. I even learn basic English vocabulary here. :(
21:28:10 <Pseudonym> It must ONLY restructure the spine of the list, and even then, its restructuring can ONLY depend on the structure of the list.
21:28:31 <Pseudonym> Think of f :: [a] -> a
21:28:43 <Pseudonym> It could return the first element of the list, or the last, or the 42nd, or whatever.
21:28:54 <_Ray_> Pseudonym: Meaning, if I have a monad M, then forall a, a function f that takes a "M a" is natural if it does not assume anything about the things of type a that are in the M=
21:28:55 <_Ray_> *?
21:29:05 <copumpkin> _Ray_: I'd forget about the Monad bit for now
21:29:11 <Pseudonym> Yeah.
21:29:27 <Pseudonym> But which element it returns can't depend on any of the values in the list.
21:29:31 <copumpkin> _Ray_: any polymorphic function in haskell cannot know anything about the forall'd variable, unless a constraint adds information about it
21:29:34 <Pseudonym> Only its length, say.
21:29:49 <ddarius> copumpkin: I can't connect to it for some reason.
21:29:55 <_Ray_> That makes sense, fits the intuitive notion of "forall" I guess.
21:29:59 <Pseudonym> I didn't understand what "natural transformation" meant until I realised that.
21:30:22 <copumpkin> _Ray_: which is distinctly different from many OO languages, for example
21:30:22 <Pseudonym> If you think this way, it's clear why "natural" is a sensible adjective.
21:30:27 <copumpkin> which have things like instanceOf
21:30:54 <_Ray_> In this case, the language itself could provide instanceOf, but a "natural" transformation couldn't use it
21:30:59 <Pseudonym> Even in C++, you might need to be able to copy construct an object.
21:31:15 <Pseudonym> In Prolog, you might need to unify.
21:31:27 <Pseudonym> But in Haskell, the "forall" is a _real_ forall.
21:31:49 <Pseudonym> BTW, there's one exception to this, and that's "seq".
21:32:01 <Pseudonym> Any type can be forced to evaluate using seq.
21:32:05 <_Ray_> I've seen it mentioned, with regards to "forced evaluation".
21:32:09 <_Ray_> Yeah.
21:32:16 <Pseudonym> But for the purpose of free theorems, we usually ignore infinite loops and seq.
21:32:22 <copumpkin> if you had such a thing in Haskell, you could have length :: [a] -> Int return 5 if a = Bool, and a conventional length for all other types
21:32:37 <_Ray_> :t seq
21:32:38 <lambdabot> forall a t. a -> t -> t
21:33:16 <augur> is there a way to define datatypes in ghci?
21:33:25 <c_wraith> augur: no
21:33:28 <augur> lame
21:33:28 <ddarius> A natural transformation from Id to Id : G -> G where G is a group viewed as a category, is an element of G that commutes with all elements.
21:33:51 <ddarius> augur: Switch to ML.
21:33:58 <augur> ddarius: :P
21:34:04 <c_wraith> Use HUGS
21:34:14 <Pseudonym> @free id :: forall a. a -> a
21:34:14 <lambdabot> f . id = id . f
21:34:15 <ddarius> c_wraith: You can't in Hugs either.
21:34:29 * _Ray_ thinks about that group-as-category statement.
21:34:35 <augur> and prolog doesnt have ADTs does it
21:34:36 <shachaf> The rumor goes that you could in hbc, though.
21:34:50 <augur> not that this is ##prolog but
21:34:50 <kmc> back in my day *grumbles*
21:34:58 <copumpkin> kmc: yesterday?
21:35:09 <Pseudonym> augur: If A = Algebraic, then yes, but it's dynamically typed.  If A = Abstract, then no.
21:35:17 <Pseudonym> But there are strongly typed Prolog-alikes.
21:35:18 <c_wraith> there's a bug report against GHC for implementing type definitions in GHCi.  Everyone's said "it's a great idea, but someone else needs to do it"
21:35:39 <c_wraith> augur: you could do it!
21:35:51 <_Ray_> ddarius: Isn't Id the category with one element? So wouldn't there only be one transformation from Id to Id?
21:35:52 <shachaf> c_wraith: Those people are ridiculous. Someone needs to put in the effort and actually do it.
21:35:57 <shachaf> (Someone else, I mean.)
21:36:00 <c_wraith> I can only see one really obvious semantic problem with it.
21:36:00 <ddarius> The thing is the MLs have always been able to do this since the 70's.
21:36:06 <Pseudonym> Ray: Id in this case is the trivial functor.
21:36:09 <c_wraith> how do the MLs handle it?
21:36:11 <Pseudonym> data Id a = Id a
21:36:14 <augur> c_wraith: perhaps just by typical prolog fiat, i guess.
21:36:42 * Pseudonym thinks shachaf just volunteered
21:36:43 <augur> using predicates and such to represent them. not that i have any clue what a constructor would look like, etc.
21:36:58 <c_wraith> If you define a type, create a value of that type, create a different type with the same name (shadowing the first), what happens to the value of the shadowed type?
21:36:59 <shachaf> Pseudonym: I specified "Someone else", didn't I?
21:37:17 <ddarius> augur: The Herbrand universe at the base of every Prolog can already encode any polynomial algebraic data type.
21:37:27 <shachaf> c_wraith: Presumably you either (a) can't create new types of the same name or (b) it acts like a type that you haven't imported.
21:37:34 <c_wraith> augur: just use church encoding of your types
21:37:40 <kmc> c_wraith, the value still exists, if you do ":t" it gives you something unhelpful, and you can't refer to the old type directly
21:37:41 <Pseudonym> augur: In Mercury, :- type maybe(X) ---> yes(X) ; no.
21:37:46 <ddarius> c_wraith: What happens is exactly what you expect.
21:38:02 <ddarius> c_wraith: The same thing that happens if you shadow function definitions.
21:38:24 <kmc> *sigh* if Haskell had first-class types then all these scoping issues would be non-issues
21:38:33 <c_wraith> ddarius: it's a bit different when you shadow function definitions, because nothing still in scope explicitly depends on the *name* of the shadowed function
21:39:01 <ddarius> c_wraith: What depends on the name of a type?
21:39:05 <kmc> nothing in scope depends on the name of the shadowed type, just its identity
21:39:17 <c_wraith> ddarius: the :type directive
21:39:43 <c_wraith> if there was an :implementation directive for functions, that'd have the same issue with shadowing functions
21:39:46 <_Ray_> Pseudonym: If Id here is the trivial functor (I assume it's the identity), then what does "a transformation from Id to Id" mean?
21:40:02 <copumpkin> _Ray_: a very boring transformation, presumably :)
21:40:09 <ddarius> c_wraith: It would simply have a qualification as types currently do when they are imported from different modules.
21:40:13 <Pseudonym> Yup.
21:40:29 <Pseudonym> In Haskell, there's essentially only one natural transformation of that type.
21:40:41 <_Ray_> My brain's type system complains, "transformation from X to Y" requires X and Y to be sets, but here Id is a functor :(
21:40:43 <Pseudonym> In the same sense that there's only one function of type forall a b. (a,b) -> (b,a)
21:40:47 <ddarius> Where "essentially" means "I'm lying to you."
21:41:03 <Pseudonym> "Essentially" means "if you ignore seq and bottom, as previously noted".
21:41:17 <ddarius> Pseudonym: I was speaking generally as well as specifically.
21:41:48 <ddarius> My glass of pomegranate juice is too far away.
21:42:00 <_Ray_> If Id is a functor, how does "transformation from X to Y" make sense, if this requires X and Y to be sets?
21:42:11 <c_wraith> ddarius: just transform it to a closer location
21:42:52 * ddarius conformally transforms it, but it collapses into a blackhole.
21:43:06 <c_wraith> whoops.  so much for the planet
21:43:36 <ddarius> c_wraith: A blackhole generated from the mass of a 1/3rd full glass of pomegranate juice would evaporate instantaneously.
21:44:10 <c_wraith> Dunno.  That's a lot more mass than a single proton.
21:44:10 <_Ray_> Unless the glass is made from neutron star material.
21:44:14 <augur> ddarius: the radiation output, however..
21:44:31 <ddarius> augur: Yes, that would be pretty severe, but the world would survive.
21:44:44 <augur> ddarius: but the continent would be rendered lifeless, probably.
21:44:51 <augur> the explosion would be pretty massive
21:44:57 <ddarius> Yes.
21:45:08 <augur> you should calculate how massive!
21:46:05 <c_wraith> Hmm.  I've been wondering how to cause human extinction.  I should work on creating black holes with the mass of a glass 3/3rds full of pomegranate juice
21:46:40 <ddarius> Wildberger has returned from vacation.
21:47:54 <Pseudonym> I'm more of a "glass is 0% empty" kind of person.
21:50:14 <ddarius> augur: It would be about 11 megatons of TNT.
21:50:22 <augur> oh thats all?
21:50:28 <mjrosenb> Pseudonym: i'm more of a "glass is 100% empty kind of person
21:50:35 <mjrosenb> Pseudonym: i tend to get thirsty easily
21:51:24 <ddarius> augur: Yes.  It was definitely going to be far less than all the nuclear weapons detonated so far which is about 500 megatons.
21:52:01 * copumpkin pulls out his tsar bomba
21:52:05 <Jafet> What if you collapsed a nuclear weapon into a black hole? Would it take out Superman?
21:52:19 <Pseudonym> I was just thinking about tsar bomba. What was the yield of that?
21:52:27 <augur> 50mt
21:52:29 <mjrosenb> copumpkin: isn't the most powerful explosive currently a fuel-air bomb?
21:52:43 <copumpkin> mjrosenb: define powerful
21:52:53 * ddarius is more of a glass Σ_n (-1)^n full person.
21:53:02 <copumpkin> I don't think anything's ever been built that's more destructive than the tsar bomba
21:53:34 <Jafet> Fox News studio?
21:53:41 <mjrosenb> copumpkin: ability to "ruin your day" for a large number of people
21:54:54 <Jafet> @remember ddarius *ddarius is more of a glass Σ_n (-1)^n full person.
21:54:54 <lambdabot> I will remember.
21:55:11 <copumpkin> mjrosenb: the MOAB thing?
21:55:42 <copumpkin> I think that kind of thing is the most powerful thing in common use today, but is tiny by comparison
21:55:48 <copumpkin> I'm not expert though
21:56:33 <ddarius> Ah, it looks like Wildberger is consolidating his videos, probably due to new policy by youtube.
21:56:42 <Pseudonym> mjrosenb: I think FAEs have been surpassed by aluminium powder/oxidiser bombs.
21:56:46 <Pseudonym> http://en.wikipedia.org/wiki/Father_of_All_Bombs
21:57:43 <mjrosenb> Pseudonym: yeah, i was just looing on that
21:57:54 <mjrosenb> copumpkin: yeah, that is what FOAB seems to indicate.
21:57:54 <ddarius> Yay thermite.
21:58:28 <copumpkin> blast radius of 300 m vs. 8km fireball :P
21:58:50 <copumpkin> and 8km fireball _after_ having its yield halved
21:59:00 * copumpkin shudders
22:00:26 <lispy> ddarius: what new policy?
22:01:40 <_Ray_> Hrm. In the case of the list monad, does >>= take care of transforming [[a]] into [a]?
22:02:21 <lispy> :t concatMap
22:02:22 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
22:02:23 <_Ray_> let f :: Integer -> Float; f x = fromIntegral (2*x); (>>=) [1, 2, 3] (return . f) -- [2.0, 4.0, 6.0]
22:02:25 <lispy> :t (>>=)
22:02:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:02:44 <lispy> :t (=<<)
22:02:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
22:02:47 <_Ray_> Well, return . f is going to return a [Float]. So >>= must be taking care of concatenating things
22:03:02 <lispy> _Ray_: take a look at concatMap and compare to (=<<)
22:03:18 <_Ray_> Same thing, it seems
22:03:36 <lispy> ?src concatMap
22:03:36 <lambdabot> concatMap f = foldr ((++) . f) []
22:03:37 <_Ray_> So =<<, for lists, is ~ concatMap?
22:03:58 <ddarius> lispy: I meant to have an "a" there.  I'm just guessing.  Certainly youtube use to limit the length of uploaded films, but it seems those limits have been extended or something.
22:04:23 <lispy> _Ray_: yeah
22:04:47 <lispy> ddarius: There has always been some loop hole to have longer videos but I don't know what the rules are.  Maybe you have to pay for the upload?
22:05:32 <lispy> :t flip concatMap
22:05:33 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
22:05:49 <lispy> _Ray_: IIRC, for the list monad instance, (>>=) = flip concatMap
22:06:04 <_Ray_> cool :)
22:06:05 <lispy> _Ray_: as in, I think that's the literal definition
22:08:43 <lispy> Oh, I guess not
22:08:47 <lispy> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#fail
22:08:55 <lispy> m >>= k             = foldr ((++) . k) [] m
22:09:08 <lispy> There might be an efficiency reason for defining it that way
22:11:12 <_Ray_> So, just to solidify, all monads are functors, but not all functors are monads.
22:11:32 <_Ray_> Specifically, a monad (F, bind, join) "is a functor" in the sense that I can extract the functor F from it.
22:12:52 <ddarius> Yes
22:14:21 <copumpkin> yeah
22:15:23 <ddarius> @google category of elements
22:15:24 <lambdabot> http://en.wikipedia.org/wiki/Category:Chemical_elements
22:15:24 <lambdabot> Title: Category:Chemical elements - Wikipedia, the free encyclopedia
22:15:39 <ddarius> @google "category of elements"
22:15:54 <lambdabot> Plugin `search' failed with: thread killed
22:16:09 <ddarius> @google "category of elements"
22:16:15 <ddarius> Ah, yes.
22:17:48 <_Ray_> How should my brain parse "join = (>>= id)"?
22:18:00 <ddarius> Yay Euler.
22:18:24 <copumpkin> _Ray_: join x = x >>= id
22:18:52 <_Ray_> copumpkin: And what should I understand from that? (The expression x >>= id itself, I mean)
22:19:33 <_Ray_> That I'm applying the identity function to the element inside the monad, and then...
22:19:35 <geheimdienst> > let kittify = (++ "cats") in kittify "lol"
22:19:57 <geheimdienst> cale: ping? lambdabot has been drinking again
22:20:43 <ddarius> If I were lambdabot, I'd drink too.
22:21:27 <copumpkin> she was swearing at me yesterday
22:22:30 <_Ray_> copumpkin: What does >>= "do", intuitively, given a function and a monad? Apply the function to the value inside the monad?
22:24:52 <copumpkin> _Ray_: there are a few ways of viewing it
22:25:27 <copumpkin> _Ray_: one fairly common way of seeing it is as something giving you the ability to "bind a variable" inside a domain-specific language
22:25:38 <copumpkin> do x <- getLine
22:25:53 <ddarius> hypotenuse, to stretch under
22:25:58 <copumpkin> that's implemented with >>=
22:26:24 <copumpkin> _Ray_: another is to see it as splicing onto a tree (which is a similar kind of idea)
22:26:32 <_Ray_> splicing onto a tree?
22:27:03 <copumpkin> say you have an AST that has "holes" in it and is parametrized by the type of the hole
22:27:39 <copumpkin> the holes might represent variable names in your AST
22:27:49 <copumpkin> you don't care how the variables are represented
22:27:56 <copumpkin> they could be strings or some unique identifier
22:28:14 <copumpkin> then >>= has type Tree a -> (a -> Tree b) -> Tree b
22:28:36 <copumpkin> so basically, take a Tree with names `a` and a function from those names to new trees
22:28:37 <_Ray_> and what does it do in that case?
22:28:51 <copumpkin> it'd go splice those trees into the place where the variables lived before
22:29:32 <_Ray_> hrmph. I don't get why I'd want an (a -> Tree b), and not an (a -> b)
22:29:54 <copumpkin> that'd allow you to transform your names to different names
22:30:07 <copumpkin> but you don't want a Tree of Trees
22:30:11 <copumpkin> you want a Tree that's spliced together
22:30:39 <_Ray_> hrm. so (a -> Tree b) gives me a new subtree, for instance
22:30:39 <copumpkin> with Functor you could easily write Tree a -> (a -> Tree b) -> Tree (Tree b)
22:30:45 <copumpkin> yeah
22:31:04 <_Ray_> right, but then I'd have a tree of subtrees, or Tree (Tree b)
22:31:12 <_Ray_> so what does >>= do then?
22:31:19 <copumpkin> it splices them together, with a lookup
22:31:32 <copumpkin> say you have a simple AST representing mathematical expressions
22:31:45 <copumpkin> your variables are Strings
22:32:04 <copumpkin> you have something like (x + (y + 3)) represented in your AST
22:32:34 <copumpkin> can you see how the AST would look, roughly (without going into details)
22:32:39 <_Ray_> sure
22:32:58 <copumpkin> now say you had a map because from somewhere else (maybe a solver)
22:33:01 <_Ray_> + -> (x, + -> (y, 3))
22:33:12 <copumpkin> you knew that x is actually z + q
22:33:18 <copumpkin> and that y is 3
22:33:56 <copumpkin> that knowledge can be represented as String -> AST String
22:34:20 <_Ray_> hrm, ok, I see it clearly in the x -> z + q case
22:34:24 <copumpkin> where we have: knowledge "x" = Add (Var "z") (Var "q"); knowledge "y" = Con 3
22:34:26 <copumpkin> or something like that
22:35:15 <copumpkin> now, your original expression is
22:35:31 <copumpkin> Add (Var "x") (Add (Var "y") (Con 3))
22:36:01 <copumpkin> make sense?
22:36:04 <_Ray_> sure
22:36:08 <copumpkin> assuming I threw together a Monad for this Tree, 
22:36:16 <copumpkin> Add (Var "x") (Add (Var "y") (Con 3)) >>= knowledge
22:36:31 <copumpkin> would result in ((z + q) + (3 + 3))
22:36:45 <copumpkin> it would substitute the knowledge in
22:36:56 <_Ray_> and "patch the tree up"
22:36:58 <copumpkin> yeah
22:37:11 <_Ray_> or, in the case of lists, concatenate the sublists
22:37:17 <_Ray_> oooh
22:37:26 <_Ray_> that's why one needs a function from M (M a) to M a
22:37:40 <_Ray_> not necessarily the stronger M a -> a
22:37:47 <copumpkin> yeah, some notion of "flattening" the result so one can keep going
22:37:52 <copumpkin> that satisfies the laws
22:38:42 <_Ray_> so it's a bit more powerful than if the function were a -> b instead of a -> M b
22:38:57 <_Ray_> because you can do replacements such as x -> {z + y}, not just x -> y
22:39:05 <copumpkin> yeah, exactly
22:39:21 <_Ray_> or, in the list case, Int goes to several possible answers (non-deterministically)
22:39:22 <copumpkin> there's a distinct similarity between =<< (which is >>= backwards) and fmap
22:39:30 <copumpkin> or even function application
22:39:38 * shachaf likes the phrase "distinct similarity".
22:39:41 <copumpkin> fmap :: (a -> b) -> (f a -> f b)
22:39:42 <copumpkin> lol
22:39:47 <copumpkin> it's late
22:39:55 <copumpkin> =<< :: (a -> m b) -> (m a -> m b)
22:40:01 <shachaf> copumpkin: Don't worry, I would make a similar distinction.
22:40:14 <copumpkin> ($) :: (a -> b) -> (a -> b)
22:40:22 <copumpkin> might not be very obvious
22:40:45 <_Ray_> parenthesis can come and go as one wishes in type definitions?
22:40:46 <ddarius> Not all similarities are equal.
22:40:48 <copumpkin> there's also <*> :: m (a -> b) -> (m a -> m b) to complicate things
22:40:58 <shachaf> _Ray_: -> associates to the right.
22:41:04 <_Ray_> because it can also be interpreted as ($) :: (a -> b) -> a -> b
22:41:19 <shachaf> _Ray_: "also"? It's the same meaning.
22:41:22 <copumpkin> _Ray_: I choose to add those parentheses because they illustrate the symmetry a bit better, in my opinion
22:41:30 <_Ray_> right, yeah, got that
22:41:48 <shachaf> (<<=) :: (w a -> b) -> (w a -> w b)
22:41:59 <copumpkin> shush you
22:42:01 <copumpkin> :P
22:42:05 <_Ray_> same with fmap, I can consider it (a -> b) -> M a -> M b or, more lift-y, (a -> b) -> (M a -> M b)
22:42:20 <copumpkin> yeah
22:42:23 <shachaf> _Ray_: Eventually you don't really see the difference between the two expressions.
22:42:53 <_Ray_> I guess it makes sense to name the language Haskell then :p
22:43:13 <_Ray_> Did haskell curry actually invent currying?
22:43:19 <shachaf> No.
22:43:31 <_Ray_> Aww :(
22:43:37 <shachaf> That would be Schönfinkel.
22:43:42 <shachaf> And "discovererd", not "invented". :-)
22:43:52 <_Ray_> Religious debate there :p
22:43:57 <ddarius> Frege probably understood it, but Schnfinkel is usually the one attributed.
22:44:14 <_Ray_> The other day I considered discovered vs invented when talking about the Y combinator
22:44:35 <copumpkin> clearly it was it was Sir Exponential McHom NaturalIsomorphism
22:44:37 <shachaf> ddarius: I assume to one degree or another it's been understood for a long time.
22:44:43 <ddarius> "Deduced" problem averted.
22:44:46 <shachaf> ddarius: E.g. in logical implication.
22:44:51 <_Ray_> haha
22:44:57 <shachaf> Yes, that's why mathematicians call what they come up with "results".
22:45:40 * shachaf thinks other fields should take that up.
22:45:54 <shachaf> E.g. musical "pieces" should also be "results".
22:46:34 <shachaf> Is consultant_barbie in this channel?
22:47:13 <shachaf> "If we had ham, we could have ham and eggs, if we had some eggs" -- currying!
22:47:43 <_Ray_> Ok, so a monad is a mapping between types (a functor), and two functions (either join and unit or bind and unit). unit takes an a, and sends it to a M a. Or, when viewed from the category-theoretical side of it, unit is a transformation () -> M. if I have a f :: a -> M b, then bind can take a M a, apply f inside the M a to get an M (M b), and then zip stuff together to form a M b. This zipping together is called the join operation.
22:48:53 <copumpkin> unit is a transformation from Identity to M
22:49:02 <copumpkin> when people write 1 -> M
22:49:03 <_Ray_> right, 's what I meant by ()
22:49:08 <copumpkin> ah okay
22:49:13 <_Ray_> "the category with one object"
22:49:17 <copumpkin> so it's actually a -> f a
22:49:24 <copumpkin> forall a.
22:49:43 <_Ray_> right, or (I can't remember who used this notation) 1 => M, where => means "a natural transformation"
22:49:50 <copumpkin> yep
22:50:13 <_Ray_> so join = (>>= id) is true because applying /nothing/ to the elements inside a monad, then zipping them up, is equivalent to just joining them
22:51:28 <_Ray_> and x >>= f = join (fmap f x) because, if f is a functor, I am mapping f over the monadic x (to get an M (M b)), and then joining to get an M b
22:52:25 * _Ray_ feels like the first time he understood Jordan forms, small pieces of the puzzle started falling into place, and then at some point the entire puzzle was assembled at relativistic speeds.
22:52:33 <copumpkin> :)
22:52:44 <copumpkin> anyway, sleep time for me
22:53:05 <_Ray_> thanks a lot!!
22:53:10 <copumpkin> no problem
23:02:22 <ray> pseudonym: yes? i know my predicate logic
23:02:54 <Pseudonym> Sorry, I must have missed some context/
23:03:59 <_Ray_> ray: I think he was talking to me, sorry :(
23:04:26 <_Ray_> I think we've had this happen before, even :(
23:04:41 <o^_^o> > let ∞ = 1/0
23:04:48 <o^_^o> > ∞ * -1
23:05:02 <o^_^o> > ∞ = 1/0
23:05:04 <o^_^o> > ∞ * -1
23:05:06 <o^_^o> ?
23:05:15 <o^_^o> > 2 + 1
23:05:28 <Axman6> lambdabot seems to be dead
23:05:39 <Pseudonym> @botsnack
23:06:18 <_Ray_> hrm. doesn't it screw up the definition that a monad M is a triple of (F, bind, unit), but unit's type is already 1 -> M? self-referencing?
23:07:35 <Pseudonym> A group is a set G, plus a function of type GxG -> G, plus...
23:07:42 <Pseudonym> No, it doesn't.
23:08:23 <rwbarton> unit's type is 1 -> F if you like
23:08:26 <_Ray_> Well, you're mentioning G as the "set" part
23:08:30 <_Ray_> Yeah, that's what I thought
23:08:54 <_Ray_> so a monad would be a functor F, plus two functions .... 1 -> F
23:11:21 <eric__> Can anyone help me figure out how to convert an Int to a Word32? I've looked at Data.Bits, but I can't figure out how to use it
23:11:43 <Axman6> eric__: fromIntegral
23:12:03 <eric__> I tried that, but maybe I was doing it wrong. Thanks for the reply, I'll try it again
23:13:07 * hackagebot persistent 0.4.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.4.2 (MichaelSnoyman)
23:13:43 <eric__> okay, here is the error it gives me if I use fromIntegral: Couldn't match expected type `GHC.Word.Word32'
23:14:04 <eric__> I'm trying to write an Int to a file using putWord32le
23:14:28 <Axman6> paste the code
23:14:32 <eric__> this is the line: putWord32le fromIntegral(w)
23:14:41 <eric__> w is an Int that I pass in
23:14:47 <Axman6> well, that's wrong :)
23:14:52 <eric__> oops :)
23:15:24 <Axman6> what you've written there is parsed as putWord32le (fromIntegral) (w), which is giving fromIntegral as an argument to putWord32le
23:15:35 <eric__> ah
23:15:42 <Axman6> yuou need putWord32ls (fromIntegral w)
23:15:43 <Axman6> e*
23:15:49 <Palmik> try putWord32le $ fromIntegral w
23:15:58 <Palmik> or what Axman6 said
23:16:12 <eric__> oh my gosh, I'm sorry! Thanks, I can't believe it was just parens!!
23:16:34 <eric__> thanks for your help Axman6 and Palmik!
23:17:09 <ddarius> _Ray_: In general, the unit and multiplication are not necessarily functions.  They are natural transformations which are families of arrows, and the arrows can be all kinds of things.
23:17:19 <Palmik> you are welcome
23:17:34 <_Ray_> That's the meaning behind unit :: 1 => F, correct?
23:17:54 <_Ray_> What would a commutative diagram of this scenario (monads) look like?
23:18:14 <_Ray_> Say I have two categories A and B, a functor F, and a function f :: A -> B. 
23:18:19 <ddarius> A commutative diagram is just a notation for equations.
23:19:35 <_Ray_> unit would be giving me F(a) for an object a in A?
23:19:57 <_Ray_> (Visually, "lifting" a using F)
23:20:58 <ddarius> A natural transformation is not (necessarily) a function.  It can't be "applied."
23:21:11 <_Ray_> Oh :o That's new. I thought a transformation was a function.
23:21:49 <kilimanjaro> _Ray_, things mean what they are defined to mean
23:22:08 <_Ray_> How is "transformation," better yet "natural transformation" defined?
23:22:21 <ddarius> "Natural transformation" is a stand-alone term.  It is not a "special type" of "transformation," and anyway "transformation" has multiple different meanings in mathematics.
23:22:28 <RayNbow`TU> I found http://blog.ezyang.com/2010/07/flipping-arrows-in-coburger-king/ to contain a nice explanation of natural transformations
23:22:51 <RayNbow`TU> (especially because of the diagrams)
23:22:52 <ddarius> There is no general notion called "transformation" in category theory.
23:23:09 <_Ray_> But there is a notion of "natural transformation," surely?
23:23:13 <ddarius> Yes.
23:23:15 <kilimanjaro> Given two functors
23:25:23 * _Ray_ likes the presentation of that blog very much.
23:29:59 <Skola> I have a very general question about Haskell: The design agency where I work (as both a designer and light-weight programmer) has basically given me 6 months to experiment with platforms/methodologies/languages. Could I teach myself enough in this period to use Haskell productively (cgi will do for most applications)?
23:30:42 <Adamant> what's your prior experience?
23:30:57 <Skola> In Haskell? hardly any
23:31:02 <Adamant> as a programmer
23:31:09 <Skola> decent pythonista
23:31:17 <Adamant> hmm. that might be enough
23:31:34 <Adamant> I think 6 months will be pushing it, but if you're motivated, you could use it for small projects
23:31:56 <Skola> the projects are small, and I'm the only one working on the dev side of things
23:32:06 <Adamant> that helps
23:32:12 <Skola> that's why I have infinite freedom in the how part, as long as I make things work
23:32:27 <Adamant> if you're consistent, it's worth a shot
23:32:46 <Adamant> spend time on it daily and ask questions in here
23:32:53 <Adamant> good chance you will have plenty
23:33:06 <Skola> yeah this channel has already been helpful
23:33:35 <Skola> possibly because the language forces you to ask good questions, as far as I have seen
23:33:53 <Skola> it would probably be more sensible (safer) to keep things python, especially because I'm ok in Django
23:34:09 <Adamant> it would be safer, but, you won't learn nearly as much
23:34:15 <Skola> but I have half a year to experiment, an incredible luxury
23:34:18 <Adamant> yeah
23:34:19 <Skola> yeah
23:34:21 <Skola> :]
23:35:26 <Adamant> re: methologies - I'd look at the 12 things Spolsky points out as the minimum for a decent dev shop and use them as a starting point if you haven't already
23:36:12 <Adamant> I'd also look at some web libraries very different from Django if you have the time
23:36:29 <Adamant> and stuff like continuation-based web servers
23:36:44 <Skola> ok
23:37:06 <Skola> I do most of the things he says that are applicable to our studio, but a compiled language does change things a lot
23:37:11 <Adamant> yeah
23:37:40 <Adamant> do you have any friends or coworkers you can share code with?
23:38:06 <Adamant> having that to work with helps a lot if you're both serious about getting sharper
23:38:41 <Skola> we have a partner company that I talk to about code
23:38:45 <Adamant> cool
23:39:00 <Skola> but they mainly use perl and other horribleness
23:39:07 <Adamant> ah, yeah
23:39:24 <Adamant> sane subsetted Perl or full on Chthulu horror Perl
23:39:45 <Adamant> some old-school Perl guys know a pretty remarkable amount
23:39:58 <Skola> oh their lead programmer is prettyy hardcode
23:40:00 <Skola> hardcore
23:40:06 <Skola> but also very lazy
23:40:10 <Adamant> ah
23:40:45 <Skola> he's been able to do everything with perl/cgi all his life (which tells you something about his business skills)
23:41:40 <Skola> but when I first joined this studio (after an internship), I told my boss that I refuse to work with legacy perl, and I rewrote all the systems (online magazine / cms kind of stuff) the same week
23:42:25 <Skola> I like python, it was really fresh after writing javascript mainly
23:42:35 <Skola> and when I found Haskell I fell in love
23:43:45 <Skola> Would you say working though "Learn you a Haskell" or "Real World Haskell" is a good idea to begin with?
23:44:02 <jaspervdj> yeah
23:44:22 <jaspervdj> LYAH first, then RWH
23:44:27 <Skola> ok
23:44:43 <_Ray_> So, to wrap it up. Monads are a way to extend datatypes with the ability to control how functions on them are composed and applied.
23:45:10 <Skola> and as far as tools go, any essentials besides the Haskell platform / GHC?
23:45:44 <jaspervdj> you should be fine with that and a good text editor
23:46:01 <Skola> using VIM + haskellmode
23:46:35 <jaspervdj> that's perfect
23:46:53 <Skola> is it worth looking into any other/more plug-ins for vim?
23:47:18 <jaspervdj> not for the moment imo
23:47:20 <Skola> That's a question I could google, but while we're at it :]
23:47:21 <Skola> ok
23:47:23 <Skola> thanks
23:48:02 <jaspervdj> I use plain vim and I write a *lot* of haskell
23:49:33 <drbean> RayNbow`TU: http://blog.ezyang.com/2010/07/flipping-arrows-in-coburger-king/  Useful explanation of why Functor is a functor.
23:49:56 * _Ray_ is reading that
23:49:58 <Skola> <3 vim, I've even written a loveletter in it once :D
23:50:03 <geheimdienst> coburger king?
23:50:07 <Skola> (one that didn't suck)
23:50:20 <ddarius> geheimdienst: Have it their way
23:50:24 <geheimdienst> lol
23:50:25 <_Ray_> hahaha
23:50:42 <geheimdienst> conald mcdonald
23:51:00 <_Ray_> A mathematician is a machine for turning coffee into theorems. A comathematician is a machine for turning cotheorems into ffee.
23:51:01 <drbean> It's a -> t a which is the (category theory ) functor , rather than fmap.
23:51:23 <RayNbow`TU> drbean: are you sure you meant to highlight me? :)
23:51:23 <ddarius> drbean: It's both together.
23:51:54 <drbean> RayNbow`TU: You're the one who pasted the link.
23:53:21 <_Ray_> Is there a... category of categories?
23:54:09 <zul_netbsd> _Ray_: Cat is the category of categories
23:54:16 <_Ray_> I N C E P T I O N
23:54:28 <zul_netbsd> where category are objets, and arrows are functors
23:54:57 <_Ray_> Why is it called "category of small categories"?
23:55:56 <dolio> A real category of categories would lead to paradox.
23:56:04 <dolio> Like a set of all sets.
23:56:17 <_Ray_> Yeah, wiki'd that. How unfortunate :(
23:56:21 <dolio> So it's often limited to small ones.
