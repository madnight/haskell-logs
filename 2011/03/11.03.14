01:08:44 <boegel> any Flemish people here who want to compete in the VPW-2011 using Haskell? we have an open spot in our team...
01:10:20 <geheimdienst> http://pdfcast.org/pdf/procedures-equidiameetings-vpw-2011 <- this?
01:10:31 <geheimdienst> your language is funny :) i'm enjoying that document a lot. thanks.
01:23:28 <boegel> geheimdienst: no, that's something totally different (no idea what it is)
01:23:38 <boegel> geheimdienst: http://www.vlaamseprogrammeerwedstrijd.be
01:26:10 <geheimdienst> very nice, thanks :) wedstrijd is such a cute way of saying Wettstreit. i need to read more of this
01:26:20 * hackagebot data-object-json 0.3.1.6 - Serialize JSON data to/from Haskell using the data-object library.  http://hackage.haskell.org/package/data-object-json-0.3.1.6 (MichaelSnoyman)
01:26:22 * hackagebot data-object-yaml 0.3.3.5 - Serialize data to and from Yaml files  http://hackage.haskell.org/package/data-object-yaml-0.3.3.5 (MichaelSnoyman)
01:40:10 <levifikri> Hi, what is the best libarary for interfacing C with Haskell (I want to call C methods from Haskell)
01:40:33 <shachaf> @wiki FFI
01:40:34 <lambdabot> http://www.haskell.org/haskellwiki/FFI
01:43:14 <levifikri> how about c2hs? http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
01:43:31 <levifikri> how does it differ to FFI?
01:44:03 <quicksilver> c2hs is a tool for generating FFI interfaces.
01:44:17 <sipa> FFI is not a libary, that's just the haskell extension you need to interface ith other languages
01:44:26 <sipa> c2hs is a tool for simplifying it
01:47:25 <levifikri> ok thx
01:53:57 <imc> yop
01:54:37 <imc> anyone tried FRP.Reactive.GLUT + FieldTrip?
01:55:53 <imc> hacked Reactive.GLUT (thanks to formicite.com) works great, but as soon as I try rendering with FieldTrip everything is painfully slow
02:01:41 <imc> well, I guess I'll take some of the good things of FieldTrip and build a more low-level graphics lib then.
02:07:37 <levifikri> any one has a Haskell + C code, interfacing thru FFI, which can be shared? Online documentation doesn't help too much for me..
02:12:32 <co_dh> levifikri: how about you cabal install opengl , and read the source inside? 
02:13:01 <aavogt> cabal unpack is a useful command for that
02:13:19 <co_dh> or openglraw , 
02:13:28 <levifikri> hmm I guest it would be too complex sample for me.. I just want something like "hello world" application to start with.
02:18:58 <aleator> levifikri: c: int foo(int bar){return 2*bar}; haskell: foreign import ccall unsafe foo :: Int -> IO Int; main = foo 5 >>= print;
02:27:16 <co_dh> aleator: why return IO Int instead of Int? 
02:29:08 <aleator> co_dh: Was just an example, since when dealing with real c things, it is often necessary to take IO into account.
02:29:49 <co_dh> aleator: ok. thanks. in the above specific example, it's not necessary , right? 
02:30:24 <aleator> co_dh: You could import it as Int->Int.
02:30:38 <co_dh> thanks :)
02:36:05 <anonchik> 芯
02:36:17 <anonchik> oh, sorry
02:38:54 <harlekin> @pl (\(s, xs) -> liftM ((,) s) $ mapM readTVar xs)
02:38:55 <lambdabot> uncurry ((. mapM readTVar) . fmap . (,))
02:41:15 <Botje_> @pl \(s, xs) -> mapM readTVar xs >>= \xs' -> return (s, xs') -- better?
02:41:15 <lambdabot> uncurry (flip ((>>=) . mapM readTVar) . (return .) . (,))
02:41:27 <Botje_> hardly :[
02:41:44 * hackagebot gdiff-ig 0.1 - Generic diff for the instant-generics library  http://hackage.haskell.org/package/gdiff-ig-0.1 (JosePedroMagalhaes)
02:42:21 <Botje_> @pl \(s,xs) -> liftM2 (,) (return s) (mapM readTVar xs)
02:42:22 <lambdabot> uncurry ((. mapM readTVar) . fmap . (,))
02:42:40 <Botje_> heh. that's the same. okay :)
03:30:44 <_mpu> :pf \x -> x
03:31:12 <Botje_> you want @pl
03:31:42 <_mpu> @pl \b -> if b then Just x else Nothing
03:31:42 <lambdabot> flip (flip if' (Just x)) Nothing
03:31:49 <_mpu> Botje_: yes
03:33:29 <parcs> oo, lambdabot knows about if'
03:34:34 <quicksilver> well, not in any holistic sense
03:34:45 <parcs> @type \b x -> guard b >> return x :: Bool -> a -> Maybe a
03:34:46 <lambdabot>     Inferred type is less polymorphic than expected
03:34:46 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
03:34:46 <lambdabot>         x :: a -> Maybe a (bound at <interactive>:1:3)
03:34:48 <sipa> :t if'
03:34:49 <lambdabot> Not in scope: `if''
03:34:56 <quicksilver> the @pl plugin invented its own fictional if' for the purpose of making if-expressions pointfree
03:35:00 <quicksilver> that's all.
03:37:04 <ski> @type (\b x -> guard b >> return x) :: Bool -> a -> Maybe a
03:37:05 <lambdabot> forall a. Bool -> a -> Maybe a
03:37:57 <parcs> @let if' p c a = if p then c else a
03:37:58 <lambdabot>  Defined.
03:38:46 <ski> .. "predicate","consequent","alternate" ?
03:39:15 <parcs> yeah, got the terminology from the SICP lectures
03:39:36 <parcs> is there a better terminology
03:39:49 * ski has been using "condition","consequent","alternate"
03:44:13 * ski . o O ( <http://en.wikipedia.org/wiki/Derangement> )
03:47:41 <merijn> Any math/type theory people here who can explain what turnstile with added vertical bar means? I know the turnstile means "x is provable from y", but I keep encountering a variant which is a vertical bar followed by turnstile (detexify doesn't even show a similar symbol...) which seems to be related but different from the plain turnstile...
03:48:09 <_mpu> :t liftM2
03:48:10 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:49:01 <ski> merijn : sometimes it is read "forces", i think
03:49:37 <quicksilver> merijn: it varies, generically it's just another turnstile.
03:49:38 <ski> merijn : at least in Kripke semantics, `w ||- Phi' can mean that `Phi' is true in world `w'
03:49:57 <quicksilver> merijn: the most common use is for some kind of model theory implication / forcing
03:50:18 <_Ray_> Just to get this straight, is this a good definition of the Y combinator? U = 位f.f(f), Y = 位f.U (位x路f (x x))?
03:50:24 <ski> (sometimes `||-_w Phi' and `Gamma ||-_w Phi' instead, i suppose)
03:51:24 <ski> _Ray_ : do you want it for applicative order or normal order reduction ?
03:51:47 <ski> (or for call-by-value or call-by-name ?)
03:51:50 <_Ray_> Normal order, I'd think, but I'm guessing the definitions of your terms - I don't have that much experience with lambda calculus :)
03:51:55 <merijn> quicksilver, ski: I guess the Kripke semantics make the most sense. Reading Conor's thesis on Oleg, which would make it mean "we can derive p of type R in context C"
03:52:32 <ski> _Ray_ : then it works fine (iirc that's the "Turing" definition .. or maybe it was the "Ackerman" one)
03:52:38 <Eduard_Munteanu> merijn: C |- p : R   ?
03:52:53 * _Ray_ wonders if people are talking about model theory :o
03:53:10 <merijn> Eduard_Munteanu: C; P||- p : R (where P is the deletion point of p)
03:53:26 <merijn> _Ray_: We're talking type theory, I don't know who brought up model theory
03:53:28 <ski> _Ray_ : an alternative is `Y = U (\x. \f. f (x x f))'
03:54:01 <quicksilver> ski and I both brought up model theory almost simultaneously.
03:54:50 <_Ray_> Oh, cool, that actually clears some stuff up - I was working with an ugly definition: Y = (位h.位F.F(位 x.((h(h))(F))(x))) (位h.位F.F(位 x.((h(h))(F))(x))). This is U of (位h.位F.F(位 x.((h(h))(F))(x))), which can be rewritten as (位h.位F.F(位 x.(h h F)(x))). I think this one is more similar to your version, ski.
03:56:26 <Eduard_Munteanu> How about Y = \f. (\x. f (x x)) (\x. f (x x)) ? This is the TAPL variant and seems reasonable to me.
03:57:01 <_Ray_> I'm thinking (位h.位F.F(位 x.(h h F)(x))) is the same as (位h.位F.F(h h F)), isn't it?
03:57:17 <ski> _Ray_ : ok, <http://en.wikipedia.org/wiki/Fixed_point_combinator> says the latter one i gave was Turing's, so i guess the one you gave first was the Ackerman one
03:58:12 <ski> Eduard_Munteanu : yeah, that's then the Ackerman one
03:58:27 <Eduard_Munteanu> And doesn't 'Y' refer to a particular combinator, regardless of call-by-name/need?
03:58:50 <Eduard_Munteanu> At least I remember TAPL calling the call-by-name one the Z combinator.
03:59:00 <Eduard_Munteanu> Erm, call-by-value.
03:59:27 <ski> _Ray_ : your `U (\h. \F. F (\x. h h F x))' is just the call-by-value version of the (call-by-name) `U (\h. \F. F (h h F))' one
03:59:42 <_Ray_> Ah :) *goes to read* Thanks :)
04:00:21 <ski> _Ray_ : `\x. M x' (where `M' doesn't contain `x' free) is the same as `M', by eta-equivalence
04:00:22 <Eduard_Munteanu> Depending on the evaluation semantics, Y or Z may be the fixpoint combinator of choice.
04:00:42 <Eduard_Munteanu> (e.g. Y won't work in a strict language)
04:01:08 <ski> _Ray_ : but that doesn't work with call-by-value, hence we need to eta-expand
04:01:34 <ski> (merijn : what is "deletion point" ?)
04:01:46 <_Ray_> Way cool :) These terms are new to me (I won't study language theory until next semester), but it's all very interesting :)
04:02:20 <Eduard_Munteanu> _Ray_: you might want to take a look at TAPL by Benjamin Pierce
04:02:43 <Eduard_Munteanu> @where tapl
04:02:43 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
04:03:14 <Eduard_Munteanu> (not freely available though)
04:06:46 <merijn> ski: Oleg terms can have holes, the deletion point of a term p in context C is either the context (if p is a pure term) or (if p is a partial construction) the context C where all references to the partial construction p have been stripped
04:07:22 * ski idly wonders whether this is related to *the* Oleg ..
04:07:42 <merijn> ski: I have wondered whether the naming was a reference to him as well :p
04:07:44 <Eduard_Munteanu> Did they actually name something after Oleg? :)
04:07:55 <paolino> hello, did indentation rules changed ? It seems if and its else can have same indentation inside a do block 
04:07:58 <merijn> It's an anagram of Pollack's Lego
04:08:06 <Eduard_Munteanu> @quote milioleg
04:08:06 <lambdabot> No quotes match. Just what do you think you're doing Dave?
04:08:09 <Eduard_Munteanu> @quote oleg
04:08:10 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
04:08:17 <Eduard_Munteanu> @quote oleg
04:08:18 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
04:08:23 <merijn> ^ very familiar problem
04:08:24 <Eduard_Munteanu> Hrmpf.
04:08:37 <merijn> You're thinking of milli,  (two l's)
04:08:47 <Eduard_Munteanu> @quote millioleg
04:08:47 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
04:08:52 <quicksilver> paolino: yes, it's a bug in haskell2011
04:08:54 <Eduard_Munteanu> Yep, that one :)
04:09:02 <quicksilver> paolino: (a deliberate one, unfortunately)
04:09:05 <merijn> @quote milli-Oleg
04:09:05 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
04:09:26 <paolino> quicksilver: in 7.0.2 ?
04:09:57 <merijn> I'm pretty sure the OLEG thesis is enough to raise my skill above 100 milli-Olegs :p
04:10:00 <quicksilver> paolino: the bug is in haskell2010.
04:10:08 <quicksilver> paolino: ghc 7.0.2 correctly implements the standard.
04:10:15 <quicksilver> paolino: http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
04:10:49 <Eduard_Munteanu> Hm, I kinda like that change.
04:11:10 <Eduard_Munteanu> It always seemed stupid having to use two levels of indentations to write if-then-else (if you really have to).
04:12:23 <quicksilver> Eduard_Munteanu: it is much more stupid to add a bizarre exception to a rule which - although simple - was hard to explain.
04:12:39 <quicksilver> I find it hard to belive that new, more complex rule, with its weird exception is going to be easier to explain
04:12:52 <quicksilver> but it saves a few space characters and conforms to some people's aesthetics.
04:12:57 <Eduard_Munteanu> Um yeah.
04:13:22 <paolino> quicksilver: I don't understand if leaving if and else on the same level is wrong or right, I remember it was wrong
04:13:23 <silver> can we switch it off by some kind of "extension"?
04:13:27 <Eduard_Munteanu> I actually remember abusing case instead of that so I don't conform to the ugly indentation.
04:13:42 <quicksilver> paolino: it was wrong. It is now right. The language was changed in haskell 2010.
04:13:56 <quicksilver> silver: NoDoIfThenElse, perhaps? I"m not sure.
04:14:06 <paolino> ah, it's a long time
04:14:19 <Eduard_Munteanu> Actually the only reason one would use if-then-else was for writing simple, one-liners.
04:14:28 <paolino> I should try break the rules more often
04:14:29 <Eduard_Munteanu> if x then foo else bar
04:15:20 <Eduard_Munteanu> (in which case it could be replaced with a mere function)
04:15:31 <flux> eduard_munteanu, so not even when you need to a decision based on a boolean?
04:16:07 <Eduard_Munteanu> @hoogle Bool -> a -> a -> a
04:16:08 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
04:16:08 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
04:16:08 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
04:16:31 <paolino> @hoogle Bool -> a -> a
04:16:32 <lambdabot> Control.Exception assert :: Bool -> a -> a
04:16:32 <lambdabot> Control.OldException assert :: Bool -> a -> a
04:16:32 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
04:17:08 <paolino> @hoogle ifM
04:17:09 <lambdabot> System.Directory createDirectoryIfMissing :: Bool -> FilePath -> IO ()
04:17:09 <lambdabot> Network.HTTP.Headers HdrIfMatch :: HeaderName
04:17:09 <lambdabot> Network.HTTP.Headers HdrIfModifiedSince :: HeaderName
04:17:20 <Eduard_Munteanu> > let ifthenelse p t e = case p of True -> t; _ -> e  in ifthenelse (2 < 4) "Yes!" "Oh noes"
04:17:21 <lambdabot>   "Yes!"
04:17:53 <opqdonut> Eduard_Munteanu: I still think if' is a better name
04:19:19 <dibblego> the Boolean should be the last argument like all the other folds
04:19:42 <Eduard_Munteanu> :t maybe
04:19:43 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:20:26 <dibblego> (either, Either) (maybe, Maybe) (foldr, []) (if', Bool)
04:22:11 <ski> @djinn (a,a) -> (Bool -> a)
04:22:12 <lambdabot> f (a, b) c =
04:22:12 <lambdabot>     case c of
04:22:12 <lambdabot>     False -> b
04:22:24 <ski> .. aren't you forgetting a case, lambdabot ?
04:22:36 <opqdonut> :)
04:22:40 <ski> hmpf
04:22:43 <ski> @djinn (Bool -> a) -> (a,a)
04:22:44 <lambdabot> f a = (a True, a True)
04:24:13 * hackagebot xml-enumerator 0.2.0.1 - Pure-Haskell utilities for dealing with XML with the enumerator package.  http://hackage.haskell.org/package/xml-enumerator-0.2.0.1 (MichaelSnoyman)
04:33:44 <Ptival> :t (.)(.)(.)f g
04:33:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1, Show a, SimpleReflect.FromExpr b, SimpleReflect.FromExpr (f (f1 a))) => f (f1 b)
04:34:07 <Ptival> :type (.)(.)(.)f g
04:34:10 <parcs> :t flip flip flip flip flip
04:34:11 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
04:34:18 <parcs> :t flip flip flip flip flip flip flip
04:34:19 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
04:34:22 <parcs> :t flip flip flip flip flip flip
04:34:23 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => f1 ((f (a -> b) -> a -> f b) -> b1) -> f1 b1
04:34:51 <Ptival> :t \x y z -> f . g x y z
04:34:53 <lambdabot> forall t t1 t2 a b (f :: * -> *). (Show a, SimpleReflect.FromExpr b, SimpleReflect.FromExpr (t -> t1 -> t2 -> f a), Functor f) => t -> t1 -> t2 -> f b
04:35:08 <Ptival> :pl \x y z -> f . g x y z
04:35:17 <Ptival> @pl \x y z -> f . g x y z
04:35:18 <lambdabot> (((f .) .) .) . g
04:35:41 <parcs> :t iterate flip $ flip flip flip flip flip
04:35:42 <lambdabot>     Occurs check: cannot construct the infinite type:
04:35:42 <lambdabot>       f = (->) (f ((f1 (a -> b) -> a -> f1 b) -> b1))
04:35:42 <lambdabot>     Probable cause: `flip' is applied to too many arguments
04:40:12 <parcs> :t iterate ($ flip) $ flip flip flip flip flip
04:40:12 <lambdabot>     Occurs check: cannot construct the infinite type:
04:40:12 <lambdabot>       b = (f (a -> b1) -> a -> f b1) -> b
04:40:13 <lambdabot>     Probable cause: `$' is applied to too many arguments
04:41:26 <meth> what options would i use to make ghc produce the tightest assembly with nothing extra added ?
04:42:26 <ski> @djinn Maybe (Maybe a) -> Maybe a
04:42:27 <lambdabot> f a =
04:42:27 <lambdabot>     case a of
04:42:27 <lambdabot>     Nothing -> Nothing
04:42:30 <ski> @more
04:42:47 <ski> hm, something appears to be eating the rest
04:42:48 <Eduard_Munteanu> meth: if you're optimizing for size don't forget -dynamic ;)
04:43:05 <Eduard_Munteanu> *executable size
04:43:11 <parcs> -dynamic or build your libs with -split-objs if the former isn't possible
04:44:20 <meth> I'm just doing a simple hello world comparison from manual c to haskell .. the hc file was insane.. the hs is rather large too ... using -O3
04:44:44 <parcs> O3 doesn't exist
04:45:02 <meth> oh i figured it mapped to gcc or something
04:45:25 <merijn> meth: Also, the haskell code will include the haskell runtime, which is bigger then the C runtime
04:46:31 <parcs> also don't forget to strip the binary
04:46:34 <meth> but even the assembly ?
04:46:35 <merijn> meth: tbh, I don't think Haskell is well suited to "produce the tightest assembly"
04:46:59 <quicksilver> it's not assembly tightness that's the issue
04:47:01 <merijn> meth: You expect the assembly to magically run without a runtime?
04:47:03 <meth> from what i have been reading though haskell can be as fast as c so i figured the assembly would be very close ?
04:47:06 <quicksilver> (although that might be true)
04:47:19 <quicksilver> it's the many megabytes of unused libraries compiled in
04:47:21 <meth> merijn sorry not expert on assembly
04:47:30 <merijn> meth: I fail to see how binary size and speed are correlated?
04:47:51 <merijn> meth: And not to be rude, but if you have to ask these things, I don't think you are expert enough to worry about them
04:48:21 <meth> merijn no your right but just learning
04:48:23 <wto> @pl \x -> if x `elem` cons then [x,'o',x] else [x]
04:48:23 <lambdabot> ap (liftM2 if' (`elem` cons) (ap (:) (('o' :) . return))) return
04:48:44 <merijn> meth: I can tell you language speed is irrelevant for 95% of all programs and 99% of all programmers
04:49:24 * ski nervously wonders what wto is up to
04:49:25 <meth> merijn that's not the point
04:49:26 <merijn> meth: If language speed is an issue for you, you would already know. So if you just want to learn to program, don't worry about it
04:49:39 <wto> ski: I just wanted to see how bad it got :-)
04:51:03 <meth> merijn that's obvious
04:51:55 <merijn> meth: What exactly is the problem then? :>
04:52:21 <meth> "merijn no your right but just learning"
04:53:28 <merijn> The simple answer is that compiled haskell includes the code for all sorts of polymorphism, lists, tuples, etc. whereas C does not. Whether that code actually gets used or not
04:54:05 <ski> wto : yeah .. but which application do you use that in ?
04:54:11 <meth> on a mailing list some people are comparing various languages to see which is best overall for little shell programs .. so someone asked about haskell and i said it should be just as fast as c for something that simple... then i was interested to go see my self
04:54:18 <anincog> Is there a functional data structure with O(1) index-based lookup and amortized O(1) growth? Or do I have to use dynamic arrays with IOref?
04:54:30 <wto> ski: ah, a module for translating to r枚varspr氓ket :P
04:54:47 <meth> yea idk the idea i was gaining is that haskell would only compile in what was needed
04:55:13 * ski kokanon inontote poproratota rorvovaror-sospoprorkoketot
04:55:25 <meth> I'm just interested
04:55:33 * wto kokanon poproratota utotanon poproroboblolemom!
04:55:38 <Saizan> meth: i'd benchmark instead of looking at the assembly
04:55:54 <merijn> meth: Compiled code that isn't called doesn't slow down your program of course (well, it might clobber L2 cache a bit, but should hardly be noticeable)
04:56:24 <meth> hm even if it's in the assembly instructions ?
04:56:29 <ski> @let cond p f g x = if p x then f x else g x
04:56:30 <lambdabot>  Defined.
04:56:35 <meth> isn't there a load hit /
04:56:45 <Saizan> meth: also, there are some tools, "ghc-core", to get the assembly relative to just your code rather than the whole executable, for ghc compiled ones 
04:57:04 <sipa> wto, ski: funny, that's remarkably similar to a dutch language game... p-taal where every vowel X is turned into XpX, and consonants are left untouched
04:57:06 <Axman6> > let abs = cons (>0) id negate in abs (-4)
04:57:06 <lambdabot>   Not in scope: `cons'
04:57:11 <merijn> meth: Yes, but compared to the overall overhead of loading no one is going to notice on current sytems
04:57:11 <Axman6> > let abs = cond (>0) id negate in abs (-4)
04:57:13 <lambdabot>   4
04:57:25 <merijn> sipa: I've never heard of that game...
04:57:59 <sipa> merijn: depe peepee-tapaal ipis upu oponbepekepend?
04:58:24 <meth> merijn sure for a more complicated program but for the hello world i wonder how much faster the c version is.. yea i mean i was going to simply bench mark but i have many things running that i don't feel like turning off and everyone has different computers .. so i figured if assembly was same that was enough
04:58:53 <ski> > cond (`elem` cons) (\x -> [x,'o',toLower x]) return =<< "Haskell"
04:58:55 <lambdabot>   "Hohasoskokelollol"
04:58:56 <merijn> meth: I/O is so slow that any computational overhead becomes irrelevant
04:59:18 <sipa> merijn: it's not that common either, by the way, i only know some people who know how to speak it fluently
04:59:21 <_ikke_> I'm trying to edit by xmonad.hs config file. http://paste.pound-python.org/show/4143/. It's about the last line. The WM_ICON_NAME isn't always the same, but it always ends with the same part. Does someone know how I could match that?
04:59:45 <merijn> sipa: Never head of it, no. I'm amazed by the amount of supposedly Dutch things I run into in #haskell which I've never heard of :p
04:59:53 <sipa> haha
05:00:05 <merijn> _ikke_: Try the #xmonad channel?
05:00:13 <_ikke_> merijn: Hmm, let me try that
05:00:41 <ski> wto : ^ hm, can that be improved ?
05:00:49 <sipa> cond (not (`elem` cons)) (\x -> [x,'p',toLower x]) return =<< "Haskell"
05:00:51 <sipa> > cond (not (`elem` cons)) (\x -> [x,'p',toLower x]) return =<< "Haskell"
05:00:52 <lambdabot>   The section ``GHC.List.elem` L.cons' takes one argument,
05:00:52 <lambdabot>  but its type `GHC...
05:00:59 <ski> @type notElem
05:01:00 <sipa> > cond (not . (`elem` cons)) (\x -> [x,'p',toLower x]) return =<< "Haskell"
05:01:00 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
05:01:01 <lambdabot>   "Hapaskepell"
05:01:59 <hpc> sipa: lol
05:02:25 <ski> sipa : heh, sounds like <http://sv.wikipedia.org/wiki/P-spr%E5ket> :)
05:02:52 <sipa> damn you swedes have everything!
05:02:55 <ski> (and btw, "rvarsprket" means "the rogue language")
05:03:24 <sipa> i figured "r枚var" was similar to the dutch "rover"
05:03:44 <Schalken> How can I uninstall the Haskell Platform 2011 on Mac OSX? I can't find an uninstall executable or instructions anywhere. :(
05:03:54 <merijn> Well, rover is sort of similar to rogue...
05:05:16 <Botje_> Schalken: istr there being an uninstall thing in the .pkg you download
05:06:11 * ski is reminded of a paper in which Koen Claessen calls one function `rolig', and another `apa'
05:06:17 <ski> (or maybe it was two different papers)
05:06:37 <Schalken> Botje_: If I open the .pkg it immediately starts the installation wizard.
05:06:54 <Botje_> hmm, then it was a different package. sorry :/
05:18:04 <hape01> with which technique Do i relaod Haskell modues after changing them, keeping the state of the Haskell/GHC running process? 
05:19:01 <hape01> "Haskell modules"
05:19:20 <rostayob> what would be the quickest method to see if a webpage exists, in haskell?
05:20:15 <rostayob> I mean if it's not a 404
05:21:46 <merijn> hape01: You might want this article on dynamic code loading in Haskell programs? http://www.cse.unsw.edu.au/~dons/papers/SC05.html
05:21:58 <Schalken> rostayob: As a minimum you would have to make a GET request to the webserver and make sure the response code is not 4xx.
05:22:24 <Libertus> a HEAD request would be sufficient
05:25:20 <Schalken> Libertus: Oh "Asks for the response identical to the one that would correspond to a GET request, but without the response body." I thought HEAD was something different, my bad.
05:25:31 <Schalken> rostayob: What Libertus said.
05:25:44 <Libertus> :) just helping out teh internet
05:27:03 <hape01> merijn: I had a quick look on this paper of Libertus Don Stewart and Manuel M. T. Chakravarty. That is interesting. That means I will have a look at Yi and Lambdabot to get a further understanding of that.  Thank you very much
05:27:09 <hpc> HEAD == "gimme the headers only" :P
05:27:34 <hape01> -Libertus   that was a mistake
05:27:55 <Libertus> hape01: I'm honoured to be mentioned alonside such luminaries
05:28:13 <hape01> Libertus: :-)
05:28:17 <_ikke_> No one in #xmonad is responding. Can someone give me some advices as how I can match the end of a string in a manageHook list?
05:28:37 <_ikke_> advise*
05:31:15 <Botje_> what do you mean by 'the end of a string' ?
05:32:17 <dagle_> Hi, I want to print an infinit list in wxhaskell but wxhaskell seems to accumulate the data and draw it in on big chunck. How to fix that?
05:32:30 <dagle_> one*
05:34:02 <_ikke_> Botje_: stringProperty "WM_ICON_NAME" returns something like "Name - Fixed string" or "Fixed string"
05:34:17 <_ikke_> Fixed string is always the same, but there could be prepended something
05:35:51 <_mpu> how can I see the list of installed files of a given cabal package ?
05:36:05 * ski wonders what the type of `(=?)' in XMonad is ..
05:36:17 <Botje_> _ikke_: there's Data.List.isSuffixOf
05:36:59 <_ikke_> Botje_: Could I use that in that list?
05:37:00 <ski> > "Fixed string" `isSuffixOf` "Name - Fixed string"
05:37:01 <lambdabot>   True
05:37:08 <_ikke_> Ah ok
05:37:08 <rostayob> Schalken, Libertus: thanks.
05:37:13 <_ikke_> i'll try that
05:37:33 <Libertus> rostayob: I've assumed you know about Network.HTTP.*
05:37:35 <_ikke_> Does that need any imports?
05:37:39 <ski> _ikke_ : possibly you'll need to use something else/more than `(=?)' for the last line, though ..
05:37:49 <ski> (i'm not sure what, since i don't know XMonad)
05:38:06 <ski> well, `import Data.List' for `isSuffixOf'
05:38:43 <_ikke_> ok
05:38:46 <rostayob> Libertus: I'm looking into it
05:39:10 <_ikke_> I'm trying to find out what that =? means
05:40:05 <maurer_> ski:
05:40:06 <maurer_> Prelude XMonad> :t (=?)
05:40:06 <maurer_> (=?) :: Eq a => Query a -> a -> Query Bool
05:40:07 <ski> _ikke_ : if you could load your XMonad config file into `GHCi', you could probably ask it what type `(=?)' has (by typing `:type (=?)')
05:40:31 <ski> hm, ok
05:40:54 <ski> so then the question is, what are the operations on `Query' ?
05:41:28 <ski> hm, though maybe it doesn't matter
05:41:42 <ski> presumably `Query' is a `Monad', or at least a `Functor'
05:42:38 <ski> so maybe
05:42:39 <ski>   liftM ("Taak eigenschappen bewerken" `isSuffixOf`) (stringProperty "WM_ICON_NAME")
05:42:42 <ski> ?
05:43:09 <ski> hm, maybe that looks nicer as
05:43:19 <ski>   ("Taak eigenschappen bewerken" `isSuffixOf`) `liftM` stringProperty "WM_ICON_NAME"
05:43:47 <ski> _ikke_ : is that more or less what you were wanting ?
05:44:14 <ski> (i assume "Taak eigenschappen bewerken" was the suffix you wanted to check for)
05:44:19 <_ikke_> ski: Right
05:44:36 <_ikke_> What do I need foor liftM?
05:44:50 <ski> so try replacing the part to the left of `--> doFloat' at the last line with that ?
05:45:03 <ski> (maybe you need to wrap in brackets, if you use the infix version)
05:45:06 <ski> @index liftM
05:45:06 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:45:18 <ski> so, `import Control.Monad', for `liftM'
05:45:21 <ski> @index fmap
05:45:21 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:45:46 <ski> possibly `fmap' works just as well, instead of `liftM' (and then you wouldn't need to import it explicitly)
05:45:56 <_ikke_> just replace it?
05:46:44 <ski> if `Query' is a `Monad', then `liftM' works
05:46:53 <ski> if `Query' is a `Functor', then `fmap' works
05:46:58 <ski> (if both, then any works)
05:47:10 <_ikke_> ski: http://xmonad.org/xmonad-docs/xmonad/XMonad-Core.html#t%3AQuery
05:47:25 <_ikke_> Guess it's both
05:47:39 <_ikke_> Instances: Monad Query, Functor Query
05:48:07 <Schalken> Anybody know how to uninstall the haskell platform?
05:48:14 <ski> ok, then i suppose i'd use `fmap' (to avoid needing to import `Control.Monad') .. it's not really that important
05:48:26 <_ikke_> ski ok
05:48:35 <_ikke_> And how did I import isSuffixOf?
05:48:48 <ski> @index isSuffixOf
05:48:48 <lambdabot> Data.List
05:48:51 <ski> so
05:48:54 <_ikke_> `import Data.List' for `isSuffixOf'
05:48:54 <ski>   import Data.List
05:48:55 <ski> or
05:49:00 <ski>   import Data.List (isSuffixOf)
05:49:03 <_ikke_> ah ok
05:49:08 <ski> if you want to import just `isSuffixOf'
05:49:39 <ski> (instead of importing everything that is in `Data.List' into the module scope)
05:49:55 <_ikke_> Okay, it compiled
05:50:08 <_ikke_> ski: And it seems to work
05:50:10 <_ikke_> thanks a lot
05:50:13 <ski> nice :)
05:50:15 <ski> yw
05:50:45 <_ikke_> I only had a beginners course of haskell a few years ago
05:51:02 * ski has never tried XMonad (yet)
05:53:18 <_ikke_> ski: It works nice
05:54:50 <_ikke_> Nice stable
05:54:52 <_ikke_> and fast
05:55:12 <_mpu> just functional ...
05:56:14 <_Ray_> Hrm. If I use a Y combinator, on the typical fact f = \n -> if n = 0 then 1 else n*(f (n-1)), and calculate its fixed point using that Y combinator, the resulting function is still recursive, right?
05:56:26 <_Ray_> Meaning, all it does is achieve recursion without explicitly naming itself.
05:56:39 <Jafet> That's what the Y combinator is.
05:57:14 <_Ray_> Is there a generic way to eliminate recursion? (i.e. transform into iteration)
05:57:18 <Jafet> Too bad you can't actually write one of those in Haskell, eh.
05:57:31 <_mpu> use loops
05:57:33 <Jafet> What's "iteration"?
05:57:43 <_Ray_> :p
05:58:12 <_Ray_> I know specific tricks like making something tail recursive, using extra parameters, stuff like that. But I know of no general way.
05:58:18 <Jafet> Now, recursion can compute any recursive function, or depending on your definition, any primitive recursive function
05:58:24 <ski> _Ray_ : "Y Combinator in Haskell" <http://r6.ca/blog/20060919T084800Z.html>
05:58:37 <Jafet> Depending on what "loops" you allow, iteration might only express primitive recursion, or less
05:58:44 <mux> _Ray_: nope, recursion is strictly more expressive than loops and such
05:59:02 <_Ray_> Even more expressive than while loops?
05:59:06 <ski> (^ Jafet, as well)
05:59:12 <mux> obviously, since you can implement while loops using recursion
05:59:22 <zygoloid> you can simulate recursion by explicitly creating a stack and using a loop
05:59:30 <_Ray_> That only means its more or equally powerful, but is the inequality strict?
05:59:35 <mux> you can implement any kind of looping behaviour with recursion, but you cannot express some recurisve patterns with iteration
05:59:38 <zygoloid> (but only in languages which have looping constructs, that is, not haskell)
05:59:49 <mux> for instance, you cannot implement the ackerman function without recursion
06:00:15 <_Ray_> The only way I found to implement ackermann without recursion is to make my own stack and push/pop from it. That's not recursive, but it's cheating.
06:00:29 <ski> (iirc, you can write ackerman in Agda,Coq)
06:00:48 <Jafet> @src Mu
06:00:49 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
06:00:53 <Jafet> (I know)
06:01:16 <Jafet> (Which incidentally leads to a lovely answer to "How do I write a Y combinator in Haskell?" "Mu")
06:02:48 <mux> _Ray_: as far as I know you simply cannot derecursify the ackerman function completely, with or without using manual stacks (that trick doesn't always works anyways)
06:03:27 <zygoloid> mux: sure it does.
06:03:29 * ski . o O ( <http://www.dreamsongs.com/NewFiles/WhyOfY.pdf>,<ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/Y.ps.gz> )
06:03:51 <mux> zygoloid: I remember fairly well learning at school that you cannot derecursify all functions
06:03:56 <mux> was that wrong?
06:04:00 <_Ray_> mux: My computer isn't recursive, it's iterative
06:04:01 <zygoloid> mux: let me put it this way: you can write a turing machine simulator with a loop and no recursion.
06:04:07 <mux> _Ray_: that's quite irrelevant
06:04:32 <zygoloid> ackerman isn't primitive recursive. perhaps that's what you're recalling
06:05:00 <mux> no, I'm recalling specifically that you just cannot derecursify all functions
06:05:59 <mux> and as it turns out, looking on the net for iterative implementations of the ackerman function, I find stuff where people achieved eliminating some recursive calls through the use of a stack, but not all of them, which seems to prove my point
06:06:16 * _Ray_ goes to look at his old algorithms course slides
06:07:30 <_mpu> mux: if you look at compiled code of the ackerman function you won't see any recursive call, only some jumps
06:07:38 * hackagebot hakyll 2.4.4 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-2.4.4 (JasperVanDerJeugt)
06:07:41 <mux> _mpu: that is completely irrelevant
06:07:57 <_mpu> mux: why ?
06:07:58 <zygoloid> mux: it depends which primitives you have. as Jafet mentioned earlier, different looping constructs have different amounts of power. but a while loop with an arbitrary condition is as powerful as recursion, as is if + goto.
06:08:16 <mux> yeah, we use von neumann computers, I know, yeah, recursive calls end up being jumps; that doesn't change anything about what we're talking about
06:08:27 <zygoloid> (this is predicated on the assumption that we can allocate memory)
06:09:10 <quicksilver> mux: non-recursive ackerman found here : http://stackoverflow.com/questions/1094679/is-there-a-problem-that-has-only-a-recursive-solution/1095538#1095538
06:09:41 <zygoloid> if we can't allocate memory, then loops aren't necessarily enough (depending on what other primitives we have)
06:09:42 * _Ray_ was having trouble finding his old code, but yeah, that's the gist of using the stack
06:09:57 <mux> quicksilver: ah, interesting
06:10:34 <_mpu> the problem seems to be : recursive only VS what ??
06:10:56 <quicksilver> mux: not really. It's exactly what everyone has been telling you for hte last 15 minutes and you've not been listening ;)
06:11:04 <mux> quicksilver: at least this link shows I was far from being the only one thinking that; actually, the most well rated answer is "The Ackermaann function cannot be expressed without recursion" :-P
06:11:17 <quicksilver> stop press. The internet is full of ignorance.
06:11:20 <Fuco> is it possible to pattern match in lambda definition? I have a data structure Edge int int in a graph, I'd like to do somethig like (\Edge s t -> ...)
06:11:34 <quicksilver> Fingerzam: (\(Edge s t) -> ... )
06:11:37 <quicksilver> erm
06:11:39 <quicksilver> that was for Fuco 
06:11:39 <mux> quicksilver: sorry that this discussion looked that way to you...
06:11:52 <zygoloid> Fuco: you can, but you can only give one pattern (no case-style alternatives)
06:12:14 <mux> but whatever
06:12:28 <Fuco> ok
06:12:34 <Fuco> dunno why it didn't work the first time I've tried
06:12:49 <quicksilver> mux: well you separately told Ray and then mpu that they were being 'irrelevant' when in fact they'd bother given arguments that showed you could write a non-recursive ackermann.
06:12:51 <Fuco> oh right, I missed a ) @_@
06:12:53 <Fuco> thanks :)
06:13:00 <zygoloid> mux: i think this reduces to the question, "which sets of primitives are sufficient for a language to be turing-complete". that's an interesting question with surprisingly many answers
06:13:01 <quicksilver> s/bother/both/
06:13:13 <mux> quicksilver: they were both talking of things at a much lower level and I maintain those points were irrelevant
06:13:22 * zygoloid thinks of the word problem and diophantine equations
06:13:52 <Jafet> Fractran!
06:14:25 <zygoloid> mux: the lower level is at least as powerful, and does not contain recursion. therefore recursion is no more powerful than the lower level.
06:14:53 <_mpu> That's what I was stating
06:20:41 * hackagebot GLFW-b 0.0.2.2 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.0.2.2 (BrianLewis)
06:21:23 <Botje_> phew. I thought for a second it was GFWL
06:21:31 <Botje_> (games for windows live)
06:21:44 <Jafet> Bindings to that??
06:23:17 <paolino> loops without goto cannot do ackerman , maybe
06:23:38 <Jafet> goto is pretty unloopy
06:23:50 <hpc> loops can do ackermann just fine
06:23:54 <hpc> stack + while loop
06:23:55 <_Ray_> Just not fixed loops.
06:24:14 <_Ray_> Meaning, for(i = starting; i < final; i++) is strictly less expressive than while.
06:25:02 <hpc> _Ray_: untrue; consider: starting = 0, final = 1, and the last instruction of the for loop is if(condition) i--;
06:25:06 <_Ray_> All computable functions can be calculated with a primitive recursive function (clearly iteratable (made up word)) followed by a minimization or fixed point. All are things that iteration can do.
06:25:32 <_Ray_> hpc: How does that make it more expressive than while?
06:25:42 <hpc> _Ray_: it makes it exactly a expressive as a while
06:25:54 <hpc> you said "strictly less"
06:25:58 <Axman6> _Ray_: I'm sensing a programming language coming out of this...
06:26:04 <_Ray_> Err, I meant not modifying i inside the loop :p
06:26:08 <hpc> :P
06:26:09 <_Ray_> The idea is "a fixed amount of cycles."
06:26:52 * ski thinks of Matiyasevich and exponential diophantine equations ..
06:27:28 * zygoloid has been meaning to look up the proof that diophantine equations are turing-complete
06:27:44 <ski> (s/fixed loop/definite loop/)
06:27:57 <_Ray_> The way to do it with a minimization is actually fun. You can emulate a fixed-amount-of-steps Turing machine with a primitive recursive function. Call it STEP(program, input, step) = 1 if it halts here, 0 if it doesn't. You can then just compute STEP(program, input, i) for i from 0 to infinity, and seeing the least value it gets. When you find a 0, it's stopped.
06:28:12 <_Ray_> Err, 0 if it halts here, 1 if it doesn't. :)
06:28:42 <ski> <http://www.scholarpedia.org/article/Matiyasevich_theorem>
06:31:00 <zygoloid> http://mathworld.wolfram.com/PrimeDiophantineEquations.html :)
06:31:12 <Jafet> I like the Turing reduction for the correspondence problem
06:32:22 <hpc> zygoloid: i would hate having to read the proof of that
06:33:02 <Jafet> The one for Wang tilings is similar
06:33:59 <zygoloid> hpc: my understanding is that Matiyasevich gives a method for turning programs into equations, and that is the result of applying it to a primality testing program.
06:34:47 <hpc> oh, cool
06:35:03 * zygoloid has an idea for an esolang
06:50:10 <Jesin> O_O
06:50:13 <Jesin> ...
06:50:16 <Jesin> lol
06:50:18 <mercury^> zygoloid: Matiyasevich wrote a book which seems quite good, but unfortunately only parts are available online.
06:50:21 <Jesin> the Cont monad is fun
06:50:36 <Jesin> I'm turning my brain inside out trying to understand it  :D
06:51:02 <hpc> @unmtl Cont a b
06:51:02 <lambdabot> (b -> a) -> a
06:51:42 <Jesin> ^_^
06:51:54 <Jesin> it's typically written Cont r a
06:52:19 <Jesin> heh
06:52:46 <Jafet> @help unmtl
06:52:46 <lambdabot> unroll mtl monads
06:52:47 <Jesin> most monads I've worked with, that can be expressed as a newtype with (->)
06:53:09 <Jesin> have the... contained type, or whatever you call it
06:53:54 <Jesin> the one that's not specified in the "instance Monad (Thing t1 t2)" declaration, because Monads are kind *->*
06:54:05 <Jesin> on the right side of the arrow, as a return value
06:54:15 <Jesin> continuations are so backwards it's great  :p
06:55:33 <hpc> :t let fmap f m = Cont $ \c -> runCont m (c . f)
06:55:34 <lambdabot> <no location info>:
06:55:34 <lambdabot>     not an expression: `let fmap f m = Cont $ \c -> runCont m (c . f)'
06:55:37 <hpc> :t let fmap f m = Cont $ \c -> runCont m (c . f) in fmap
06:55:38 <lambdabot> Not in scope: data constructor `Cont'
06:55:41 <hpc> humbug
06:56:07 <hpc> :t \f m -> \c -> runCont m (c . f)
06:56:08 <lambdabot> forall r a a1. (a -> a1) -> Cont r a -> (a1 -> r) -> r
06:56:49 <Jesin> return x = Cont $ \k -> k x
06:56:56 <Jesin> I don't understand the join
06:56:59 <Jesin> hmm....
06:57:07 <Jesin> let's see if I can construct this
06:57:27 <hpc> :t \a -> ($ a)
06:57:27 <lambdabot> forall a b. a -> (a -> b) -> b
06:57:42 <hpc> a -> Cont b a
06:57:43 <hpc> :D
06:57:52 <Jesin> :p
06:57:56 <Jesin> yeah
06:57:57 <Jesin> but
06:57:59 <Jesin> the join
06:58:01 <Jesin> ...
06:58:02 <Jesin> O_o
06:58:08 <Jafet> @djinn a -> (a -> b) -> b
06:58:08 <lambdabot> f a b = b a
06:58:12 <Jesin> I'm trying to construct it
06:58:12 <Jafet> @djinn (a -> b) -> b
06:58:12 <lambdabot> -- f cannot be realized.
06:58:12 * djahandarie removes Jesin's enter key
06:58:17 <Jesin> sry
06:58:22 <Jesin> :(
06:58:28 <Jesin> I'll try to stop using it so much.
06:58:29 <djahandarie> It's okay, just try to fix it. :P
06:58:34 <Jafet> Little does djahandarie know, he was using the return key!
06:58:34 <Jesin> k.
06:58:38 <Jesin> XD
06:58:41 <Jesin> aaaanyway
06:58:59 <Jesin> I'm trying to construct the join for this, without cheating
06:59:11 <Jesin> (looking at the correct code)
06:59:27 <Jesin> and, this really is inside-out o_o
07:00:13 <Jesin> well, that's most obvious in writing the fmap
07:00:16 <Jesin> hm...
07:01:27 <hpc> :t runCont
07:01:28 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
07:01:47 <hpc> :t \m k -> \c -> runCont m $ \a -> runCont (k a) c
07:01:48 <lambdabot> forall a r a1. Cont r a -> (a -> Cont r a1) -> (a1 -> r) -> r
07:02:14 <hpc> :t \m k -> \c -> m $ \a -> (k a) c
07:02:15 <lambdabot> forall b t t1 t2. ((t1 -> t) -> b) -> (t1 -> t2 -> t) -> t2 -> b
07:02:20 <hpc> aha!
07:03:31 <hpc> :t (<*>)
07:03:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:04:39 <Jesin> oh wow
07:04:54 <Jesin> hm
07:04:56 <Jesin> so
07:05:25 <Jesin> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
07:05:26 <Jesin> instance Functor (Cont r) where fmap f m = Cont $ \c -> runCont m (c . f)
07:05:28 <Jesin> instance Monad (Cont r) where
07:05:29 <Jesin> 	return x = Cont $ \c -> c x
07:05:31 <Jesin> 	m >>= f = Cont $ \c -> runCont m (\a -> runCont (f a) c)
07:05:32 <Jesin> *sigh*
07:05:45 <Jesin> I'll have to mess with this more sometime
07:05:54 <Jesin> I still don't think I quite understand it
07:05:56 <Jesin> :p
07:05:59 <hpc> :t \f x -> runCont (f x) id
07:06:00 <lambdabot> forall t a. (t -> Cont a a) -> t -> a
07:06:17 <hpc> @unmtl Cont a a
07:06:17 <lambdabot> (a -> a) -> a
07:06:36 <hpc> huh, so that's the Identity monad, in Cont form
07:07:08 <Fuco> if I have a triple (a,b,c) how can I get third item?
07:07:14 <Fuco> with pair I have fst, snd...
07:08:18 <mauke> Fuco: pattern matching
07:09:15 <Jesin> hm
07:09:46 <Jesin> sometime within the last week, I kind of... stopped bothering with rigor
07:10:01 <hpc> fst, snd don't work on triples
07:10:02 <Jesin> and started using more intuitive approximations for things
07:10:02 <hpc> :t fst
07:10:03 <lambdabot> forall a b. (a, b) -> a
07:10:09 <hpc> > fst (1,2,3)
07:10:10 <lambdabot>   Couldn't match expected type `(a, b)'
07:10:10 <lambdabot>         against inferred type `(t, t1...
07:10:12 <Botje_> Fuco: define your own 'trd3 (_,_,x) = x
07:10:16 <hpc> > fst (1,(2,3))
07:10:17 <lambdabot>   1
07:10:23 <hpc> > snd (1,(2,3))
07:10:23 <lambdabot>   (2,3)
07:10:28 <hpc> > snd . snd (1,(2,3))
07:10:29 <lambdabot>   (2,3)
07:10:30 <hpc> :P
07:10:33 <Botje_> :]
07:10:35 <Jesin> this is unusual for me
07:10:37 <Jesin> :p
07:10:40 <hpc> wait, what?
07:10:45 <hpc> > snd . snd $ (1,(2,3))
07:10:46 <Fuco> indeed
07:10:46 <lambdabot>   3
07:10:55 <hpc> :t snd . snd (1,2)
07:10:56 <lambdabot> forall a b (f :: * -> *). (Num (f (a, b)), Functor f) => f b
07:11:02 <hpc> O.O
07:11:10 <Jesin> ...
07:11:15 <Jesin> Caleskell.
07:11:17 <Jesin> (.) = fmap
07:11:21 <Jesin> in lambdabot
07:11:26 <hpc> oh right
07:11:41 <hpc> wait, no that stil doesn't explain it
07:11:55 <hpc> :t snd . snd (1,(2,3))
07:11:56 <lambdabot> forall b t. (Num t, Num b) => (t, b)
07:12:08 <hpc> :t snd . snd
07:12:09 <lambdabot> forall a b a1. (a1, (a, b)) -> b
07:12:13 <djahandarie> Heh
07:12:16 <Jesin> > snd . snd (1,(2,3))
07:12:18 <lambdabot>   (2,3)
07:12:34 <Fuco> well, at least you guys have fun :D
07:12:39 <Jesin> lol
07:12:59 <djahandarie> :t \x -> snd . snd x
07:13:00 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a1, f (a, b)) -> f b
07:13:29 <djahandarie> :t \x -> snd . snd (1, x)
07:13:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> f b
07:14:03 <djahandarie> (\x -> snd . snd (1, x)) (5,6)
07:14:07 <djahandarie> > (\x -> snd . snd (1, x)) (5,6)
07:14:09 <lambdabot>   (5,6)
07:14:57 <hpc> > fix 1
07:14:58 <lambdabot>   1
07:15:05 <hpc> > fix (1,2)
07:15:06 <lambdabot>   Couldn't match expected type `a -> a'
07:15:06 <lambdabot>         against inferred type `(t, t1)'
07:15:56 <Jesin> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
07:15:58 <Jesin> what
07:16:27 <hpc> and people say perl is line noise ;)
07:16:28 <kmc> :D
07:16:55 <kmc> remember that runCont is just the unwrapper for the Cont constructor
07:17:16 <Jesin> yeah I know
07:17:38 <hpc> :t callCC
07:17:39 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
07:17:42 <kmc> you could expand that out to a couple lines with "let" and it would be a lot easier to understand
07:19:09 <kmc> :t callCC (\k -> return (Left (\x -> k (Right x))))
07:19:10 <lambdabot> forall (m :: * -> *) b b1. (MonadCont m) => m (Either (b1 -> m b) b1)
07:20:09 <kmc> ^^^^ proof of the Law of the Excluded Middle
07:20:20 <djahandarie> > 6 :: (Int, Int)
07:20:21 <lambdabot>   (6,6)
07:20:24 <djahandarie> Oh god
07:20:33 <Jesin> D:
07:20:41 <djahandarie> > (\x -> snd . snd (1, x)) (5,6) -- it is so crazy how this actually works
07:20:42 <Jesin> what did they doooooo
07:20:43 <lambdabot>   (5,6)
07:20:56 <kmc> to what extent can we think of 芦(MonadCont m) => m禄 as a modal operator for "classically provable"?
07:20:58 <Jesin> > 6 :: String
07:20:59 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
07:20:59 <lambdabot>    arising from the literal `...
07:21:01 <hygge> good morning. there must be some way do do 'x'+1 to get 'y'? like nextChar :: Char -> Char. i just cant find it. so is there?
07:21:03 <Jesin> good
07:21:08 <Jesin> at least it's not entirely perl yet
07:21:09 <kmc> > succ 'x'
07:21:10 <lambdabot>   'y'
07:21:23 <hygge> thx nice
07:21:32 <kmc> hygge, Char is an instance of the Enum class, so you can use "succ", "fromEnum", "toEnum", etc.
07:21:36 <djahandarie> hygge, succ is part of Enum. And Char is an instance of Enum, which is why you can use succ.
07:21:39 <djahandarie> Damn.
07:21:42 <Jesin> gtg
07:21:45 <kmc> also Data.Char defines "ord" and "chr" which are fromEnum / toEnum resp.
07:21:50 <djahandarie> :t succ
07:21:51 <lambdabot> forall a. (Enum a) => a -> a
07:21:58 <djahandarie> :t succ :: Char -> Char
07:21:58 <lambdabot> Char -> Char
07:29:42 <hpc> :t fromEnum
07:29:43 <lambdabot> forall a. (Enum a) => a -> Int
07:29:52 <hpc> :t toEnum . fromEnum
07:29:53 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
07:29:55 <hpc> :D
07:30:01 <kmc> :t fromEnum . toEnum
07:30:02 <lambdabot>     Ambiguous type variable `a' in the constraint:
07:30:02 <lambdabot>       `Enum a' arising from a use of `fromEnum' at <interactive>:1:0-7
07:30:02 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
07:30:17 <hpc> toEnum . fromEnum should be its own function
07:30:36 <hpc> it could be fun
07:30:37 <quicksilver> hpc: tweeNum ?
07:30:51 <hpc> safeCoerce? :P
07:30:54 <quicksilver> ;)
07:31:00 <kmc> they have that
07:31:14 <quicksilver> realToFrac is like that in spirit
07:31:20 <quicksilver> although obviously, that's different typeclasses
07:31:23 <hpc> (i know about the convertable typeclass)
07:31:27 <kmc> i think we need more functions with "reallyUnsafe" in the name
07:31:30 <quicksilver> as is fromIntegral
07:31:51 <hpc> unsafeSeriouslyDon'tRunThisFunctionGuys
07:32:03 <ceii> @hoogle reallyUnsafe
07:32:03 <lambdabot> No results found
07:32:15 <ceii> :(
07:32:15 <hpc> @hoogle unsafe
07:32:15 <lambdabot> Language.Haskell.TH unsafe :: Safety
07:32:15 <lambdabot> Language.Haskell.TH.Lib unsafe :: Safety
07:32:16 <lambdabot> module Data.ByteString.Unsafe
07:32:16 <kmc> perhaps my 芦ByteString -> (a -> b)禄 function could qualify
07:32:23 <hpc> :t unsafe
07:32:24 <lambdabot> Not in scope: `unsafe'
07:33:33 <Veinor> kmc: what kind of function is that? :P
07:33:41 <kmc> http://mainisusuallyafunction.blogspot.com/2010/09/executing-bytestring.html
07:33:51 <kmc> i lied because there's no polymorphic foreign import "dynamic"
07:33:52 <maurer_> Veinor: I assume it's "This is x86 code" ?
07:34:01 <Veinor> ...
07:34:04 <Veinor> I hate you
07:34:06 <kmc> but of course the solution is castFunPtr
07:34:22 <Veinor> :P
07:34:36 <djahandarie> kmc, that is dirty
07:35:06 <djahandarie> What led you down this path? :P
07:35:27 <kmc> shrug
07:35:39 <kmc> wanted to see if it's possible
07:35:50 <kmc> Haskell has this reputation for being super high level and abstract
07:36:01 <kmc> so i take delight in porting over all the nasty old C tricks
07:36:07 <kmc> at least wrt a particular implementation
07:36:12 <quicksilver> the fact that it works is a quirk of GHC
07:36:14 <quicksilver> right, what you said :)
07:36:17 <kmc> this kind of thing is massively impossible in standard Haskell
07:36:21 <quicksilver> not really a quirk of haskell.
07:36:27 <quicksilver> however, see Harpy
07:36:33 <quicksilver> (but I'm sure your'e aware of it)
07:36:42 <kmc> yeah, someone in the comments thread mentioned it :)
07:36:47 <kmc> there's another fancy x86 assembler library
07:36:50 <kmc> with super static checking
07:37:01 <kmc> i wouldn't call this a quirk, exactly.  i think everything I use there is part of the advertised interface of ByteString or the FFI
07:37:33 <djahandarie> The person who mentioned harpy in your comments is one of the authors of it I think
07:37:36 <kmc> hmm, there's no guarantee that ByteStrings live in a page which the CPU will let you execute
07:38:03 <quicksilver> kmc: there's no guarantee that your OS represents function pointers as a simple pointer to opcodes, either
07:38:25 <kmc> wonder if we have a binding to mprotect()
07:38:46 <maurer_> kmc: Why not use LLVM if you're generating the code in program, and harpy if you're extracting it from something already loaded (I agree their asm implementation is horrible, but they already have your function on foreing pointers)
07:38:58 <kmc> i agree maurer_
07:38:58 <LeCamarade> Two things.
07:39:06 <kmc> my blog post is not a serious solution to any problem :)
07:39:11 <maurer_> OK :)
07:39:16 <kmc> quicksilver, hmm, what does castPtrToFunPtr do in that case
07:39:25 <LeCamarade> First, I have this a-bit-aged library for doing Facebook in Haskell. It works with their old version of the API, which I gather still works.
07:39:25 <mux> kmc: it violates the C spec
07:39:25 <quicksilver> kmc: no idea ;)
07:39:38 <LeCamarade> Anybody want?
07:39:51 <kmc> LeCamarade, might as well upload it :)
07:39:55 <quicksilver> kmc: I think all castPtrToFunPtr is required to do is be correct for roundtrips
07:40:06 <LeCamarade> Second, how does one get Cabal running on a FreeBSD without sacrificing a child to the gods? I have failed. Nothing compiles well.
07:40:07 <kmc> "Note: this is valid only on architectures where data and function pointers range over the same set of addresses, and should only be used for bindings to external libraries whose interface already relies on this assumption."
07:40:25 <mux> dlsym() has the same problem
07:40:41 <kmc> so when I port GHC to 8-bit AVR this will become a problem
07:41:40 <quicksilver> mux: there is something else, though, right? dlfunc() or some such?
07:42:26 <kmc> i think in practice you can at least cast the dlsym() return value to a function pointer without ever pretending it's a valid data pointer
07:42:45 <mux> quicksilver: dlfunc() is a FreeBSD-specific function
07:43:06 <mux> quicksilver: there is no way around this in pure POSIX code
07:43:10 <quicksilver> interesting.
07:43:12 <mux> afaik
07:43:15 <kmc> what's dlfunc() do?
07:43:47 <mux> kmc: it's the same as dlsym() but for function pointers and not data pointers
07:44:53 <mux> in FreeBSD it's mostly used to avoid compiler warnings about casting a data pointer to a function pointer; I know of no architecture where there is an actual implementation difference, though it should be the case for ia64
07:45:09 <kmc> why for ia64?
07:45:22 <mux> because data pointers and function pointers are indeed different there
07:45:45 <kmc> different as in "can't dereference the same value as both", or different as in "can't losslessly cast back and forth"
07:46:06 <mux> the latter
07:46:14 <kmc> damn
07:46:20 <kmc> is it segmented or something
07:46:25 <mux> "In the specific case of 64-bit Itanium shared library builds, a virtual function pointer entry contains a pair of components (each 64 bits): the value of the target GP value and the actual function address."
07:47:09 <kmc> weird
07:47:36 <mux> yeah, I'm thinking it must have been quite hellish to port UNIX OSes to ia64
07:47:59 <maurer_> mux: I actually wish we had that in amd64/x86_64
07:48:09 <maurer_> mux: It would make certain types of protection _SO_ much easier.
07:48:28 <mux> maurer_: I'll take your word on this, I don't understand the implications of such a model of function pointers
07:48:43 <Sgeo> > do { a <- [1,2,3]; b <- [4,5,6,undefined]; return (a) }
07:48:44 <lambdabot>   [1,1,1,1,2,2,2,2,3,3,3,3]
07:50:05 <kmc> > [1,2,3] <* [4,5,6,undefined]
07:50:06 <lambdabot>   [1,1,1,1,2,2,2,2,3,3,3,3]
07:50:57 <Sgeo> @hoogle (<*)
07:50:57 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
07:50:57 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
07:50:57 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
07:51:08 <hpc> (<*) ~ (<<)
07:51:23 <kmc> :t (<<)
07:51:24 <lambdabot> Not in scope: `<<'
07:51:25 <djahandarie> Is that ascii art of a fish?
07:51:29 <hpc> :t (>>)
07:51:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:51:31 <kmc> hahaha
07:51:49 <hpc> ha
07:51:51 <maurer_> mux: Specifically, it puts additional constraints on the compiler which are near impossible to solve.
07:51:52 <kmc> i would expect (<<) to perform effects in the same order as (=<<) which is the opposite order from (<*)
07:52:04 <maurer_> mux: If the compiler is already solving these, then I don't have to think about them.
07:52:26 <hpc> kmc: it's debated what order (<<) should work in, hence "~" and not "="
07:52:34 <maurer_> mux: (Think if someone memcpys a region containing function pointers--this is near impossible under the system you're describing, and is the bane of a protection system I've come up with)
07:52:35 <kmc> is that why we don't have (<<) :D
07:53:04 <mux> maurer_: ah, I think I see what you mean
07:53:26 <hpc> kmc: the most annoying part of that omission is that libraries see it fit to reclaim (<<) for stuff not at all related to monads
07:53:37 <hpc> leading to some serious bamboozlement
07:53:38 <sipa> @src (<<)
07:53:38 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
07:53:52 <hpc> hehe, broccoli brains
07:54:32 * mux learns a new word: bamboozlement
07:54:43 <mux> I like it
07:55:13 * hpc is a cornucopia of obtuse verbiage
07:55:38 <LeCamarade> Every time I try to build cabal with a GHC 6.8, it explodes in my face and says I am passing bad args to ghc-pkg.
07:55:41 <LeCamarade> How to go around that?
07:55:48 <mux> hpc: heheh.
07:55:59 <hpc> LeCamarade: might i suggest using GHC 7?
07:56:01 <dcoutts_> LeCamarade: got any details?
07:56:01 <kmc> don't use ancient GHC
07:56:12 <kmc> or use an accordingly ancient cabal
07:56:14 <maurer_> LeCamarade: At least use 6.12, if not 7
07:56:37 <dcoutts_> LeCamarade: in principle recent cabal should work with old ghc, but it doesn't get much testing I must admit
08:00:21 <ski> @type succ `asTypeIn` \succ -> succ 'a'
08:00:41 <ski> hpc : `Cont a a' is not "Identity monad, in Cont form"
08:00:43 <ski> hpc : `runCont (calCC f) c = runCont (f k) c where runCont (k a) _ = c a' would be better, imo
08:01:14 <lambdabot> Char -> Char
08:01:32 <hpc> ski: i mean, when you call the cont with id
08:02:00 <ski> `forall r. Cont r a' is isomorphic to `Identity a', but `Cont a a' isn't
08:02:21 <LeCamarade> But I would need this Cabal to work before I upgrade GHC, no?
08:02:36 <maurer_> LeCamarde: No, GHC can bootstrap without a new cabal.
08:02:41 <maurer_> (I think)
08:02:48 <ski> @type Cont (\k -> k (k (k 42)))
08:02:50 <lambdabot> Not in scope: data constructor `Cont'
08:02:54 <dcoutts_> LeCamarade: I'd also like to get a log of what fails for you
08:03:01 <hpc> ski: wasn't talking about the type, but what happens when you run the continuation
08:03:07 <dcoutts_> LeCamarade: it may be already fixed in an even later cabal :-)
08:03:10 <hpc> :t \f -> runCont f id
08:03:11 <lambdabot> forall a. Cont a a -> a
08:03:19 <LeCamarade> No, I have the latest downloadable Cabal.
08:03:25 <LeCamarade> Lemme paste my problems/
08:03:26 <ski> @src Cont
08:03:27 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
08:03:35 <hpc> > let f = Cont ($5) in runCont f id
08:03:36 <lambdabot>   Not in scope: data constructor `Cont'
08:03:42 <ski> where did the `Cont' data constructor go ?
08:03:57 <hpc> > let f = ($5) in f id
08:03:58 <lambdabot>   5
08:04:17 <hpc> ^ is what i was referring to
08:04:25 <ski> hpc : yeah, but `Cont a a' is the type :)
08:04:56 <LeCamarade> dcoutts: Voil: http://hpaste.org/44763/cabal_balking
08:05:00 <dcoutts_> ta
08:05:25 <imc> I have an `(Actionable a) => Tree a`  structure (i.e., Actionable adds `act :: a -> IO ()`). I would like to traverse the tree and `act` on each item, but discarding the "result" (i.e. Tree (IO ()))
08:06:06 <hpc> imc: fmap act tree
08:06:10 <hpc> where Tree is a functor
08:06:23 <imc> well, Tree is a Functor
08:06:30 <hpc> problem solved!
08:06:32 <hpc> :P
08:06:33 <kmc> but that won't perform anything, just gives you a tree of actions
08:06:36 <hape01> in emacs threse is a state variable which indicates, which regular expression syntax is applied to regexp searches . One of syntax is lisp and there are others. Do you remember, which is the function to switch the syntax in emacs?
08:06:41 <imc> kmc: oh, i see
08:06:47 <imc> kmc: how to act?
08:06:54 <kmc> well that's what you asked for
08:06:58 <byorgey> make Tree an instance of Traversable
08:07:01 <kmc> (Tree (IO ())) is a tree of actions
08:07:08 <imc> byorgey: seriously
08:07:13 <hpc> :t traverse
08:07:14 <lambdabot> Not in scope: `traverse'
08:07:15 <imc> Tree *IS* a Traversable
08:07:19 <hpc> @hoogle Traversable
08:07:19 <lambdabot> module Data.Traversable
08:07:19 <lambdabot> Data.Traversable class (Functor t, Foldable t) => Traversable t
08:07:25 <kmc> then you can use sequenceA
08:07:26 <hpc> @src Traversable
08:07:26 <lambdabot> class (Functor t, Foldable t) => Traversable t where
08:07:26 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
08:07:26 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
08:07:38 <byorgey> imc: oh, this is the standard Tree from Data.Tree ?
08:07:39 <dcoutts_> LeCamarade: can you tell me what this reports: ghc-pkg list Cabal
08:07:40 <kmc> or i guess Data.Traversable.sequence
08:07:44 <imc> byorgey: of course
08:07:45 <byorgey> I thought it was your own Tree type for some reason
08:07:45 <hpc> sequenceA :: Tree (IO ()) -> IO (Tree ())
08:07:57 <kmc> hmm where's sequence_
08:07:58 <imc> hpc: wonderful
08:08:01 <hpc> what's with so much stuff missing from lambdabot?
08:08:04 <hpc> :t traverse
08:08:05 <lambdabot> Not in scope: `traverse'
08:08:09 <hpc> :t sequenceA
08:08:10 <lambdabot> Not in scope: `sequenceA'
08:08:42 <byorgey> no, just use Data.Foldable.mapM_
08:08:47 <byorgey> :t Data.Foldable.mapM_
08:08:48 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
08:08:58 <hpc> byorgey: that's too easy :P
08:09:07 <kmc> oh, you don't need Traversable if you're throwing out results?
08:09:09 <kmc> interesting
08:09:14 <byorgey> indeed, I had forgotten that
08:09:22 <ski> @type Data.Foldable.mapM_
08:09:23 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
08:09:25 <imc> mm
08:09:32 <hpc> kmc: if you throw out the results, it is a catamorphism, which is a fold
08:09:33 <ski> uh, right
08:09:33 <byorgey> if you're throwing out results you are forgetting the structure
08:09:34 <imc> so I should make my tree foldable
08:09:43 <LeCamarade> root@x2005:downloads/Cabal-1.8.0.4# ghc-pkg list Cabal                        1
08:09:43 <LeCamarade> /usr/local/lib/ghc-6.8.3/package.conf:
08:09:43 <LeCamarade>     Cabal-1.2.4.0
08:09:47 <imc> perfect
08:09:47 <LeCamarade> There.
08:09:48 <byorgey> imc: Tree already is Foldable ;)
08:09:53 <imc> naice then
08:09:55 <hpc> @src Foldable
08:09:55 <lambdabot> Source not found. My pet ferret can type better than you!
08:10:00 <LeCamarade> dcoutts: Looks reasonably good.
08:10:03 <imc> but I should use the foldable mapM_
08:10:11 <LeCamarade> Except it is 1.2, which is apparently lame.
08:10:17 <imc> as "plain" mapM_ is on lists
08:10:35 <imc> perfect
08:10:38 <imc> thank you guys
08:10:38 <byorgey> imc: right.  The Foldable mapM_ is a generalization of the mapM_ from Control.Monad
08:10:49 <LeCamarade> I wanted to cabal stuff for that box, but there is no cabal-install.
08:10:57 <byorgey> imc: standard practice is to do  import qualified Data.Foldable as F
08:10:58 <hpc> what order does mapM_ do the actions in?
08:11:01 <hpc> breadth first?
08:11:03 <byorgey> imc: then you can use  F.mapM_
08:11:13 <ski> imc : or `forM_', if you prefer
08:11:15 <byorgey> hpc: depth first
08:11:22 <byorgey> hpc: left-right
08:11:25 <hpc> groovy
08:11:37 <LeCamarade> dcoutts_: http://hpaste.org/paste/44763/cabal_balking_annotation#p44764
08:11:39 <imc> ski: from Foldable?
08:11:52 <ski> @type Data.Foldable.sequence_  -- also there's this
08:11:54 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Foldable.Foldable t, Monad m) => t (m a) -> m ()
08:11:55 <LeCamarade> (Lambdabot no longer reports pastes?)
08:11:57 <ski> imc : aye
08:12:24 <kmc> lambdabot never did (recently)
08:12:24 <byorgey> LeCamarade: lambdabot has never done that.  Sometimes there is a bot called 'hpaste' which does so.  But it appears not to be working at the moment.
08:12:28 <djahandarie> mapM_ is evil
08:12:31 <djahandarie> Use traverse_ :)
08:12:32 <ski> LeCamarade : iirc, `hpaste' is supposed to do that (and i think i saw it do that, a few days ago) ..
08:12:39 <djahandarie> (Same with mapM vs traverse)
08:12:49 <imc> djahandarie: i don't want to transform a tree, I want to "act" on a tree
08:12:52 <kmc> anyone know if GHC will use huge pages on Linux, or whether any work has gone into this feature?
08:13:15 <djahandarie> mapM is just traverse using the wrong abstraction.
08:13:23 <imc> but the order is indeed important. the tree should be a depth-first one
08:13:34 <byorgey> imc: Data.Foldable.traverse_ is the same as Data.Foldable.mapM_, but with an Applicative constraint instead of Monad
08:13:36 <djahandarie> We could totally obliterate mapM if the class hierarchy was fixed.
08:14:09 <byorgey> imc: which for IO (and for any monad, in fact) should be equivalent.
08:14:10 <imc> oh, right, traverse_ is in Foldable, that's logic
08:14:27 <ski> imc : using a continuation monad, you can do `elements :: Tree a -> M a', so you can write `do x <- elements tree; lift (doStuffOnElement x)' :)
08:14:35 <byorgey> djahandarie is right
08:15:34 <imc> ski: I will keep this in mind... maybe it's a good direction too
08:16:11 <hpc> isn't Tree also a monad?
08:16:23 <hpc> @src Tree
08:16:23 <lambdabot> Source not found. There are some things that I just don't know.
08:16:25 <ski> not the `Data.Tree' one, i think
08:16:32 <kmc> someone told me that monads are trees with grafting
08:16:39 <ski> (at least i wasn't able to make it a monad, last time i tried)
08:16:43 <hpc> it is
08:16:47 <hpc> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Tree.html
08:16:54 <ski> trees with elements at the leaves are monads, at least
08:17:28 <kmc> where (>>=) applies a function at each leaf and grafts on a subtree there?
08:17:41 <ski> yes
08:17:48 <Ptival> @hoogle (t -> m t) -> t -> t
08:17:49 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
08:17:49 <lambdabot> Data.Generics.Aliases extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
08:17:49 <lambdabot> Data.Data gfoldl :: Data a => (c (d -> b) -> d -> c b) -> (g -> c g) -> a -> c a
08:17:55 <kmc> or: where "join" takes a tree whose leaves hold trees, and does the obvious thing?
08:17:57 <ski> so `(>>=)' is then basically a single substitution
08:18:06 <ski> if you think of the leaves as the "variables"
08:18:19 <ski> kmc : indeed
08:18:26 <kmc> i see
08:18:33 <kmc> but this doesn't work if you have values at intermediate nodes?
08:18:52 <hpc> Ptival: assuming m is a CoMonad, that's (extract .)
08:18:57 <hpc> :t extract
08:18:58 <lambdabot> forall source. (Extract source) => (Int, Int) -> source -> source
08:19:08 <hpc> or whatever the opposite of return is...
08:19:11 <hpc> @hoogle comonad
08:19:11 <lambdabot> No results found
08:19:20 <ski>   extract :: Comonad w => w a -> a
08:19:38 <djahandarie> Is there a more elegant definition of transpose than 
08:19:43 <ski> kmc : it might work, but i'm not sure
08:19:46 <djahandarie> > ala ZipList Data.Traversable.traverse [[1,2,3,4],[2,3,4,5]]
08:19:47 <lambdabot>   [[1,2],[2,3],[3,4],[4,5]]
08:19:57 <ski> @type ala
08:19:58 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
08:20:21 <Ptival> kmc: actually I want to simplify this: case f t k of     Nothing -> t      Just t' -> t'
08:20:34 <kmc> :t fromMaybe
08:20:35 <lambdabot> forall a. a -> Maybe a -> a
08:20:42 <c_wraith> Cale added your library, then?
08:20:45 <djahandarie> Yes
08:21:02 <ski> @index Newtype
08:21:03 <lambdabot> bzzt
08:21:04 <kmc> Ptival, fromMaybe t (f t k)
08:21:13 <hpc> @instances Newtype
08:21:13 <lambdabot> Couldn't find class `Newtype'. Try @instances-importing
08:21:14 <kmc> see also:
08:21:15 <kmc> :t maybe
08:21:16 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:21:24 <hpc> @instances-importing Data.Newtype Newtype
08:21:25 <lambdabot> Couldn't find class `Newtype'. Try @instances-importing
08:21:29 <hpc> bleh
08:21:30 <djahandarie> Does the idea of 'transposing' generalize to any Applicative+Traversable?
08:21:51 <djahandarie> @hackage newtype
08:21:51 <lambdabot> http://hackage.haskell.org/package/newtype
08:21:55 <djahandarie> hpc, ^^
08:22:00 <ski> @type Data.Traversable.traverse
08:22:01 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
08:22:12 <ski> @type Data.Traversable.sequenceA
08:22:13 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
08:22:24 <djahandarie> So when t==f that structure is transposable
08:22:52 * ski . o O ( s/==/=/ )
08:22:57 <djahandarie> Yeah
08:23:43 <djahandarie> I guess that means you'd be calling a cartesian product a 'transpose' though and I don't know if I like that
08:26:12 <gio123> ski: did link works?
08:28:35 <Ptival> kmc: thanks
08:33:24 <spirit> how to construct the cartesian product of 2 sets? using prelude functions only? set elements are strings and for starters i'd be happy with the elements of the cartesian product to be concatenations of the string elements of the two sets.
08:34:21 <kmc> are your sets Data.Set?
08:34:38 <spirit> no, have my own implementation for that
08:34:49 <kmc> then how could you do it with prelude functions only?
08:34:58 <spirit> i seem to be struggling with simple haskell constructs, as i'm rather new
08:35:10 <kmc> that's okay :)
08:35:13 <kmc> did you implement a new data type?
08:35:28 <spirit> map (++"x") ys ...
08:35:31 <spirit> yes i did
08:35:41 <kmc> what's it look like?
08:35:47 <hpc> wouldn't the cartesian product be liftM2 (,)?
08:35:55 <hpc> oh, new data type
08:36:39 <kmc> also liftM2 isn't in Prelude
08:36:39 <hpc> :t liftM2 return
08:36:40 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a1
08:36:44 <kmc> but you can write it with "do" or with (>>=)
08:36:48 <hpc> indeed
08:37:18 <hpc> wait, what
08:37:20 <hpc> :t liftM2
08:37:20 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:37:32 <hpc> :t return
08:37:33 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:37:37 <spirit> where would i find liftM2?
08:37:38 <hpc> lol
08:37:46 <hpc> spirit: not in prelude
08:37:56 <hpc> which breaks your requirements
08:38:42 <spirit> lambdabot mimmicks ghci?
08:39:02 <hpc> yes, with lots of imports and some particularly wonky definitions in places
08:39:09 <hpc> :t 5 . Just
08:39:10 <lambdabot> forall b a. (Num b) => a -> b
08:39:16 <hpc> > 5 . Just $ 7
08:39:17 <lambdabot>   5
08:39:20 <hpc> > 5 . Just 7
08:39:21 <lambdabot>   Just 5
08:39:31 <hpc> > (do{1;2;3;4})5
08:39:31 <lambdabot>   4
08:39:44 <spirit> what package would liftM2 be part of?
08:40:06 <hpc> @hoogle liftM2
08:40:07 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:40:26 <hpc> Control.Monad (that's the module, not the package; the package is base, which everyone has)
08:43:17 <spirit> let alist = ["1","2","3]
08:43:29 <spirit> let blist = ["a","b"]
08:43:41 <ski> djahandarie : i assume you don't like to call `Functor f => f (a -> b) -> a -> f b' a `flip', either ?
08:43:53 <spirit> how would i use liftM2 in order to get the cartesian product of alist and blist?
08:44:06 <ski> that's just lists, not any new datatypes
08:44:33 <ski> i suspect the "correct" way you want to use is to use list comprehensions
08:44:37 <djahandarie> ski, I guess not. Flip doesn't really provide any intuition in the general case.
08:45:21 <spirit> my data types are too complex to paste in here...
08:45:30 <spirit> how would i apply liftM2?
08:45:36 <hpc> > let alist = ["1","2","3]; blist = ["a","b"] in liftM2 (,) alist blist
08:45:37 <lambdabot>   <no location info>:
08:45:37 <lambdabot>      lexical error in string/character literal at end o...
08:45:46 <hpc> > let {alist = ["1","2","3]; blist = ["a","b"]} in liftM2 (,) alist blist
08:45:47 <lambdabot>   <no location info>:
08:45:47 <lambdabot>      lexical error in string/character literal at end o...
08:45:50 <ski> djahandarie : if you squint and think of `f a' as the type of functions that given a "path", gives the element in the collection at that path, then you can think of the above as `flip'ping the path and the ordinary function argument :)
08:45:55 <djahandarie> hpc, forgot end quote
08:45:58 <hpc> > let {alist = ["1","2","3"]; blist = ["a","b"]} in liftM2 (,) alist blist
08:45:58 <lambdabot>   [("1","a"),("1","b"),("2","a"),("2","b"),("3","a"),("3","b")]
08:46:04 <dcoutts_> LeCamarade: ah hah, ok, it is fixed in the latest Cabal version 1.10.x
08:46:18 <ski> > let alist = ["1","2","3"]; blist = ["a","b"] in liftM2 (,) alist blist
08:46:19 <lambdabot>   [("1","a"),("1","b"),("2","a"),("2","b"),("3","a"),("3","b")]
08:46:21 <dcoutts_> oh, doh, he's disappeared
08:46:50 <dcoutts_> @tell LeCamarade the problem with cabal and ghc-6.8 is fixed in the latest Cabal version (1.10.x and later)
08:46:50 <lambdabot> Consider it noted.
08:47:43 <spirit> wow, great :-)
08:48:19 <ski> kmc : anyway, thinking through the definition at <http://hackage.haskell.org/packages/archive/containers/latest/doc/html/src/Data-Tree.html#Tree>, i agree that it satisfies the monad laws, so a monad it is
08:48:49 <rostayob> There is no way to use the constructors of some data types if they're not exported right?
08:48:57 <ski> spirit : you should probably try to write it yourself, without using `liftM2', if this is homework, though ..
08:49:11 <ski> rostayob : not directly, no
08:50:00 <ski> (teaching assistants might require you to demonstrate knowledge of what `liftM2' does / how it is implemented for lists, if you provide a `liftM2' solution)
08:50:35 <spirit> it's for my phd -- so no teaching assistance...
08:51:14 <djahandarie> It's still good to understand what you're doing anywasys
08:51:14 <ski> if you just want to solve the problem, then `liftM2' should be fine, i think
08:52:31 <mm_freak_> is it possible to build a binary, which has absolutely no run-time library dependencies other than the minimum required?
08:52:45 <mm_freak_> i'd like to deploy haskell applications to servers without having to build them there
08:53:20 <hpc> mm_freak_: aren't haskell programs link once, copy everywhere?
08:53:58 <hpc> everything is statically linked by default, unless you depend on foreign libs
08:54:14 <hpc> in which case, install the libs on both machines :P
08:54:38 <mm_freak_> hpc: # ./ihttp-test 
08:54:46 <mm_freak_> ihttp-test: error while loading shared libraries: libgmp.so.10: cannot open shared object file: No such file or directory
08:55:05 <hpc> and ihttp-test is compiled with --make?
08:55:06 <thoughtpolice> mm_freak_: when you compile, i believe the incantation is '-static -optl-static'
08:55:36 <spirit> liftM2 is implemented for lists -- does that mean i need to implement it for my own data type as well?
08:56:04 <djahandarie> You would need to make a Monad for your data type.
08:56:10 <djahandarie> Alternatively, you could make an Applicative
08:56:26 <djahandarie> > Data.Traversable.sequenceA [['1','2','3'],['a','b','c']]
08:56:27 <lambdabot>   ["1a","1b","1c","2a","2b","2c","3a","3b","3c"]
08:56:27 <hpc> most applicatives are going to also be monads
08:56:47 <spirit> how would i go about making a monad?
08:57:08 * Eduard_Munteanu thought the approximate converse was true: many monads could very well be just applicatives ;)
08:57:09 <djahandarie> This will be a very rocky path for just doing a cartesian product. :)
08:57:12 <ski> spirit : possibly .. or possibly you could just use `liftM2' in the implementation for `cartesianProduct' for your datatype
08:57:43 <spirit> liftM2 might work just like that?
08:57:45 <ski> > let alist = ["1","2","3"]; blist = ["a","b"] in liftA2 (,) alist blist  -- note `liftA2' for `Applicative', instead of `liftM2' for `Monad'
08:57:46 <lambdabot>   [("1","a"),("1","b"),("2","a"),("2","b"),("3","a"),("3","b")]
08:58:27 <ski> > let aMaybe = Just "1"; bMaybe = Just "a" in liftM2 (,) aMaybe bMaybe
08:58:28 <lambdabot>   Just ("1","a")
08:58:32 <ski> > let aMaybe = Nothing; bMaybe = Just "a" in liftM2 (,) aMaybe bMaybe
08:58:33 <lambdabot>   Nothing
08:59:13 <ski> Eduard_Munteanu : every `Monad' ought to be an `Applicative' ..
08:59:13 <sphynx> > take 1 `mappend` take 2 $ [1,2]
08:59:15 <lambdabot>   [1,1,2]
08:59:49 <sphynx> > (+1) `mappend` (*2) $ 1 
08:59:50 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:59:50 <lambdabot>    `Data.Monoid.Monoid a'
08:59:50 <lambdabot>  ...
09:00:07 <ski> > (($ 1) `mappend` ($ 2)) take "abc"
09:00:09 <lambdabot>   "aab"
09:00:10 <sphynx> how can I make this wrt Sum instance?
09:00:17 <Eduard_Munteanu> Yeah
09:00:38 <sphynx> > (+1) `mappend` (*2) $ Sum 1
09:00:39 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum t))
09:00:40 <lambdabot>    arising from a use of ...
09:01:21 <hpc> need more fmaps
09:03:01 <sphynx> > getSum $ (\x -> Sum $ getSum x + 1) `mappend` (\x -> Sum $ 2 * getSum x) $ Sum 1
09:03:02 <lambdabot>   4
09:03:48 <sphynx> > getSum $ (Sum . (+1) . getSum) `mappend` (Sum . (*2) . getSum) $ Sum 1
09:03:50 <lambdabot>   4
09:04:07 <mm_freak_> hpc: via cabal build
09:04:15 <mm_freak_> so probably with --make
09:04:19 <mm_freak_> thoughtpolice: thanks, i'll try that
09:05:37 <spirit> ah... ghci asks me to add an instance decalaration for (Monad SetSeq.SetSeq)... how would an instance declaration look like? I mean, do I need to specify loads in order to use liftM2?
09:13:11 <ski> spirit : something like
09:13:18 <ski>   instance Monad SetSeq
09:13:20 <ski>     where
09:13:24 <ski>     return x = ..x..
09:13:34 <ski>     ... >>= k = ...
09:14:34 <ski> but possibly you don't want to use `liftM2'/`liftA2' on `SetSeq' itself, instead using it on lists (or whatever) inside
09:18:35 <spirit> is SQ a haskell data type? is that the constructor for lists?
09:26:22 <kuznero> Hello all! Does anybody know what version of cabal should I use for latest and greatest haskell platform 2011?
09:27:26 <spirit> ski: what do the dots stand for in your code?
09:28:01 <quicksilver> kuznero: the one which comes with it.
09:28:12 <dcoutts_> kuznero: the HP comes with cabal
09:28:25 <kuznero> So, first I compile and install GHC 7.0.2 and then platform (+cabal included)?
09:28:30 <kuznero> Great :)
09:28:32 <kuznero> Thanks!
09:28:43 <ski> spirit : the parts of the code you have to fill in
09:29:22 <ski> spirit : what is `SQ' ?
09:29:41 <ski> (maybe it is your consructor for `SetSeq' ?)
09:30:01 <spirit> ah...
09:30:07 <quicksilver> kuznero: no, the platform comes with GHC
09:30:09 <spirit> newtype SetSeq a = SQ [a]
09:30:12 <quicksilver> kuznero: all you do is install the platform.
09:30:18 <quicksilver> batteries are included!
09:33:00 <ski> spirit : ok, so it was the data constructor for `SetSeq', yes
09:34:04 <spirit> so SQ followed by any list does yield a SetSeq
09:39:15 <ski> yes
09:39:56 <ski>   cartesianProduct (SQ aList) (SQ bList) = ..aList..bList..
09:40:07 <ski> would be one way of doing this, i suppose
09:45:02 <spirit> the monad instance declaration would resemble the one for lists? return x = SQ [x]
09:45:46 <kmc> you want SetSeq to be a monad in the same way as []?
09:45:54 <spirit> struggling with the >>= bit
09:46:43 <spirit> i think i do want it to be a monad in the same way as []
09:46:52 <kmc> SQ x >>= f = x >>= (SQ . f)
09:46:53 <spirit> would that be disadvantageous?
09:47:04 <kmc> why do you want it to be a monad? what use case do you have in mind?
09:47:40 <spirit> i'd like to be able to use liftM2
09:47:50 <kmc> hmm what i said is not quite right is it
09:47:51 <ski> cartesian product of two sets, iiuc
09:48:11 <spirit> would it be a bad choice, would it make the data structure slow e.g.?
09:48:19 <ski> (you need to wrap the result with `SQ', and replace one `SQ' by the inverse, yes)
09:48:33 * hackagebot epic 0.1.10 - Compiler for a simple functional language  http://hackage.haskell.org/package/epic-0.1.10 (EdwinBrady)
09:48:39 <ski> (.. or simply use `NewtypeDeriving')
09:48:50 <ski> @hackage monic
09:48:51 <lambdabot> http://hackage.haskell.org/package/monic
09:49:24 <kmc> spirit, does list's liftM2 do what you want?
09:49:28 <spirit> instead of newtype SetSeq a = SQ [a] -- i can use Newtypederiving and then I would not need the monad instance?
09:49:42 <kmc> not instead of
09:49:51 <kmc> newtype SetSeq a = SQ [a] deriving (Monad)
09:49:57 <spirit> ah...
09:50:06 <kmc> this is not allowed in standard Haskell but is allowed with the GHC extension GeneralizedNewtypeDeriving
09:50:16 <spirit> but i'd still need to implement return and >>=...
09:50:20 <kmc> no
09:50:26 <kmc> "deriving" means "implement this type class for me in a standard way"
09:50:39 <spirit> ok
09:50:45 <kmc> in standard Haskell you can use it for Eq, Show, and a few other standard classes with "obvious" definitions
09:50:53 <_mpu> this ghc is quite clever ...
09:50:55 <kmc> how much do you know about type classes?
09:50:58 <spirit> yeah, have some of those
09:51:22 <kmc> does list's liftM2 do what you want?
09:51:27 <kmc> even if one of the lists has duplicates?
09:51:40 <spirit> for starters i assume they do not have duplicates
09:51:54 <kmc> ok
09:51:58 <spirit> in a bit of a rush now...
09:52:06 <spirit> i'll have plenty of time to iterate my code though
09:52:16 <kmc> if list's liftM2 does not do what you want, then using list's monad instance is no use
09:52:33 <spirit> it does what i want
09:52:49 <kmc> spirit, instead of implementing 芦instance Monad SetSeq禄 you could just do 芦product (SQ x) (SQ y) = SQ (liftM2 (,) x y)禄
10:02:00 <spirit> add (Monad s) to the context of
10:02:00 <spirit>         the type signature for `cartesianProduct'
10:02:18 <spirit> how would it go about adding the context?
10:02:28 <hpc> :t liftM2
10:02:29 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:02:32 <hpc> ^ is an example
10:02:36 <hpc> (ignore the forall junk)
10:02:38 <kmc> spirit, (Monad s) => ...
10:02:41 <kmc> but, you shouldn't need that
10:02:43 <kmc> [] is already a monad
10:02:50 <kmc> you're probably doing something else wrong
10:02:51 <spirit> I already have one context, (Eq a)
10:03:02 <kmc> (Eq a, Monad s) => ...
10:03:06 <kmc> why do you need (Eq a) for cartesianProduct anyway?
10:05:49 <spirit> (s -> s -> s ) -> (m s -> m s -> m s)
10:05:52 <spirit> like that?
10:06:15 <kmc> that's your type for cartesianProduct?
10:06:16 <ski> i thought you wanted `SetSeq a -> SetSeq a -> SetSet a'
10:06:34 <badkins> I could use some tips on reducing consing in Haskell. I wonder if I'm getting bit by laziness.
10:06:41 <badkins> palindrome :: B.ByteString -> (Int,Int) -> Bool
10:06:45 <badkins> palindrome s (b,e) | b < e = (B.index s b) == (B.index s e) && (palindrome s (b+1,e-1))
10:06:46 <badkins>                    | otherwise = True
10:06:46 <badkins>  
10:07:10 <spirit> the type once was Set -> Set -> Set
10:07:21 <spirit> s -> s -> s
10:07:28 <badkins> that function conses like crazy and it's supposed to be iterating over the ByteString
10:07:47 <c_wraith> badkins: are you not allowed to use B.reverse?
10:07:57 <badkins> will that not cons ?
10:08:02 <c_wraith> badkins: also, that function doesn't cons *anything*
10:08:10 <kmc> badkins, ByteString has efficient slicing.  maybe you should use splitAt and head and last, instead of passing around these indices
10:08:17 <badkins> well the profiler says it allocated 400 million bytes
10:08:17 <kmc> (for clarity of code, not for speed)
10:08:37 * hackagebot bounded-tchan 0.2.1 - Bounded Transactional channels (queues)  http://hackage.haskell.org/package/bounded-tchan-0.2.1 (ThomasDuBuisson)
10:08:37 <monochrom> "(b,e)" allocates
10:08:39 <badkins> yeah, I have a super clear version, now I'm going for top speed even if it's not idiomatic
10:08:46 <kmc> also x+y allocates
10:08:58 <badkins> monochrom: ah
10:09:04 <c_wraith> heh.  quit passing the numbers as a pair, and it'll help
10:09:04 <kmc> badkins, did you compile with ghc -O?
10:09:12 <badkins> -O2
10:09:17 <kmc> badkins, you can replace Int with Int#
10:09:29 <kmc> and replace (+) and (-) with primitive Int# ops
10:09:38 <badkins> what's Int# ?
10:09:39 <ski> (.. or curry ?)
10:09:43 <kmc> badkins, unboxed integer
10:09:49 <badkins> cool
10:09:58 <kmc> http://haskell.org/ghc/docs/latest/html/users_guide/primitives.html
10:10:02 <kmc> (i assume you're using GHC)
10:10:21 <badkins> I found a linear time palindrome checker from Johan Jeuring, but a more concise Ruby program is running only twice as slow which boggled my mind.
10:10:26 <monochrom> yeah, currying: palindrome s b e | b < e = (B.index s b) == (B.index s e) && (palindrome s (b+1) (e-1))  would be my first attempt to begin with
10:10:28 <badkins> So I'm trying to speed it up :)
10:10:39 <kmc> (this stuff is not standard Haskell but if you need fantastic performance then you're probably stuck with non-standard extensions)
10:10:48 <badkins> hmm...
10:10:57 <badkins> I'd like to stick with standard Haskell for this purpose of comparison.
10:11:04 <c_wraith> I'm really curious how fast you find s == B.reverse s to be
10:11:20 <badkins> c_wraith: I'll try it now
10:11:29 <kmc> badkins, then you might be able to add strictness and have GHC do the unboxing for you
10:11:33 <c_wraith> I feel like the constant factors involved there will be lower than anything other than the most optimized implementations
10:11:40 <kmc> you could pass a strict pair
10:11:47 <kmc> data TwoInts = TwoInts !Int !Int
10:11:55 <kmc> badkins, there's a not-dissimilar example in RWH
10:12:23 <badkins> c_wraith: won't that require allocating an ByteString slice though?
10:12:28 <kmc> also i guess unboxing does no good unless you bypass B.index which expects a boxed Int
10:12:30 <badkins> that's what I'm trying to avoid
10:12:45 <c_wraith> badkins: it'll allocate one extra bytestring, but I bet that's still faster than most things you'll try
10:12:52 <c_wraith> allocation isn't slow.
10:12:54 <kmc> you can definitely make this faster if you rip into the guts of ByteString
10:13:07 <kmc> yeah, "allocation" means "incrementing the heap pointer"
10:13:19 <kmc> it's slow indirectly, because it will make GC happen sooner
10:13:24 <c_wraith> It's definitely suboptimal by a constant factor
10:13:39 <c_wraith> But it should be the implementation you're trying to beat.
10:14:10 <Skola> Is JSON my main option for reading/writing data (all kinds of types) to a log in Haskell?
10:14:40 <c_wraith> JSON is unusual for a log file..  Most of those are custom formats.
10:14:47 <kmc> Skola, you have tons of options
10:14:48 <c_wraith> usually column-oriented
10:14:49 <thoughtpolice> Skola: i don't know, is it? there are plenty of json libraries and libraries for other stuff. if json is a good fit for whatever reason
10:15:00 <thoughtpolice> *then use it
10:15:05 <kmc> Skola, if you need speed, and don't need compatibility to other languages, i would use Data.Binary
10:15:17 <kmc> Skola, if you want maximum simplicity i would use "deriving (Read, Show)"
10:15:17 <Skola> sorry for being so vague
10:15:35 <Skola> data goes from JS through CGI to log
10:15:45 <kmc> there are approximately 385734596734 formats with a data model equivalent to JSON
10:15:47 <kmc> or nearly so
10:15:48 <Skola> that's still pretty vague, but don't know more
10:15:58 <Skola> ok
10:15:59 <kmc> i.e. benc, BSON, YAML, XML, ASN.1 etc etc etc
10:16:11 <kmc> s-expressions
10:16:12 <kmc> too many different ways to encode a dict
10:16:58 <Skola> I'll look into your suggested options Data.Binary and deriving 
10:17:02 <Skola> cheers
10:17:44 <Skola> I have "room for exploration" on the particular project, so I'll check both
10:18:15 <spirit> if (Monad m) is part of a function signature, do i need to import anything? i get weird errors
10:18:29 <kmc> put your code on hpaste.org and we can take a look
10:18:32 <kmc> (preferably a minimal test case)
10:18:35 <mauke> what's the error message?
10:18:44 <kmc> spirit, why do you have (Monad m) if you're working with SetSeq specifically
10:18:58 <badkins> Ok, I removed the tuble (b,e) and just used b e - didn't help the allocation much at all.
10:19:13 <badkins> seems to be allocating 526 bytes per invocation of palindrome
10:19:35 <kmc> badkins, do you want to minimize allocation as a goal itself, or are you convinced allocation is causing your program to be slow?
10:19:49 <badkins> kmc: the latter 
10:20:03 <badkins> 400 million bytes of allocation for what should be an iteration seems wrong
10:20:39 <kmc> did you look at GHC's "Core" intermediate language?
10:20:53 <kmc> that might show an allocating step which got in there through some optimization or inlining
10:20:54 <badkins> no - never heard of Core
10:21:02 <kmc> the tool "ghc-core" will show you
10:21:10 <badkins> thx
10:21:17 <kmc> not the easiest to read though
10:21:30 <badkins> guess it doesn't come with the base install
10:21:37 <kmc> right
10:21:38 <spirit> I want to use liftM2, don't i need monad then?
10:22:06 <kmc> spirit, paste your code at hpaste
10:22:19 <jhala> can someone tell me the simplest way to upgrade from cabal-1.8 to cabal-1.10 ?
10:22:30 <badkins> kmc: is it possible that lazy evaluation of the recursive palindrome function is cause a bunch of thunks to be allocated ?
10:22:38 <spirit> it's too much code i fear
10:22:39 <kmc> yeah
10:22:49 <kmc> spirit, you'd write "(Monad m) => ..." if you're writing a function that's supposed to work generically for *all* monads
10:22:52 <kmc> that's why m is a type variable
10:22:54 <badkins> how do I make it strict?
10:22:59 <kmc> if you're working in a specific type like Maybe or [], there's no need
10:23:00 <kmc> bbl
10:23:04 <badkins> palindrome s b e | b < e = (B.index s b) == (B.index s e) && (palindrome s (b+1) (e-1))
10:23:04 <badkins>                  | otherwise = True
10:23:04 <badkins>  
10:23:12 <monochrom> @src (&&)
10:23:13 <lambdabot> True  && x = x
10:23:13 <lambdabot> False && _ = False
10:27:48 <spirit> ido i then have to make the type class an instance of monad?
10:28:19 <PhilRod_> is it normal that it slightly blew my mind when I found out that Bool in haskell was a non-built-in type?
10:28:42 <c_wraith> PhilRod_: slightly normal.  Most languages aren't flexible enough to allow that. :)
10:28:52 <monochrom> depends on what "normal people" you hang out with
10:29:05 <PhilRod_> monochrom: heh, true
10:29:19 <c_wraith> PhilRod_: for even more fun, consider that while lists have special syntax, their entire implementation is in libraries, too
10:30:10 <PhilRod_> c_wraith: ah, interesting. I did wonder whether they were normal types, or whether the compiler special-cased them at all (say, for performance reasons)
10:30:52 <c_wraith> well, GHC does have special cases for lists...  But entirely through mechanisms (like the RULE pragma) that are available to any library
10:31:46 <spirit> if i want to use liftM2 on a type class i wrote myself, do i need to make the type class an instance of monad?
10:32:29 <PhilRod_> c_wraith: ah, I see
10:32:37 <mauke> spirit: classes can't be instances
10:33:09 <ski> data types can be instances of type classes
10:33:50 <Saizan> a type class can be a subclass of another, at best
10:35:17 <c_wraith> arg.  why is the documentation for Data.ByteString.Internal a 404 on hackage?
10:35:26 <hpc> c_wraith: old hackage?
10:35:35 <c_wraith> yes
10:35:42 <hpc> there's still dead links to that stuff all over the place
10:35:49 <c_wraith> no, I mean..
10:35:56 <hpc> http://hackage.haskell.org/packages/archive/bytestring/0.9.0.4/doc/html/Data-ByteString-Internal.html
10:36:16 <c_wraith> yes, for many versiona go
10:36:20 <c_wraith> err, versions ago
10:36:21 <hpc> oh i see now
10:36:21 <hpc> wtf
10:36:30 <c_wraith> just going to http://hackage.haskell.org/package/bytestring and clicking on Data.ByteString.Internal 404s
10:36:51 <c_wraith> Well, I'll just assume (hah!) that .Internal hasn't changed much
10:37:04 <hpc> heh
10:37:25 <hpc> there's also :browse, if need be
10:37:55 <c_wraith> yeah, I started with that, but lots of the functions have types and names that aren't sufficient to document them
10:38:08 <c_wraith> Though I'm seeing that isn't improved by the haddock, much
10:39:07 * c_wraith goes to the source
10:39:21 <hpc> use the source, luke
10:59:53 <leifw> re: installing haskell-platform 2011 on ubuntu 10.10:
11:00:01 <leifw> what is the best way to go about this?
11:00:23 <leifw> should I download the ghc binary and haskell-platform tarball straight from haskell.org?
11:00:35 <leifw> should I install a packaged ghc and try to use that to install the platform?
11:00:37 <leifw> something else?
11:00:56 <leifw> I remember having trouble getting to a consistent system once before and I don't want to mess it up again
11:07:58 * hackagebot bounded-tchan 0.2.2 - Bounded Transactional channels (queues)  http://hackage.haskell.org/package/bounded-tchan-0.2.2 (ThomasDuBuisson)
11:10:01 <c_wraith> badkins: you still around?
11:10:11 <badkins> yes
11:10:20 <badkins> bummin' about laziness :)
11:10:35 <c_wraith> I've got a very funny implementation of palindrome for bytestrings. :)
11:11:01 <badkins> reading Don's writeup in RWH and it seems like a lot of effort to get strict evaluation, but I guess I shouldn't comlplain since laziness is a prominent attribute of Haskell.
11:11:40 <hpc> evaluation happens on its own anyway
11:11:59 <badkins> eh?
11:12:21 <hpc> as in, you can't run the program without evaluating SOMETHING :P
11:12:23 <rostayob> I have a strange issue with old-time, I get stuff like "TimeDiff {tdYear = 0, tdMonth = 0, tdDay = 0, tdHour = 0, tdMin = 0, tdSec = 9851, tdPicosec = -338699000000}"
11:12:23 <c_wraith> badkins: two different versions.  I haven't timed either.  http://hpaste.org/paste/44767/palindromes
11:12:24 <badkins> hpc: I'm trying to get a constant space evaluation.
11:12:32 <rostayob> it's like it stops at the seconds
11:12:59 * hackagebot concurrent-barrier 0.1.2 - Simple thread barriers  http://hackage.haskell.org/package/concurrent-barrier-0.1.2 (JeremyFitzhardinge)
11:13:19 <c_wraith> The second version is as overkill low-level as possible in half-haskell, half-FFI :)
11:14:20 <c_wraith> Also, my first attempt at it had an off-by-one error in the pointer reads, which is a hilariously C mistake for haskell code
11:14:30 <hpc> ha!
11:14:40 * hpc hasn't seen an off-by-one error in months
11:15:51 <ddarius> badkins: "constant space" /= "strict"
11:16:05 <c_wraith> I was like 'hey, wait, "foof" is so a palindrome!'
11:16:33 <monochrom> leifw: there is no ubuntu deb for ghc 7.0.2. see my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml for how to build the haskell platform
11:16:40 <badkins> ddarius: so strict evaluation of a tail recursive function won't run in constant space in Haskell ?
11:16:59 <c_wraith> badkins: not if it's generating a result that's not constant size.
11:17:04 <leifw> monochrom: that's why I'm wary of touching the ubuntu packages
11:17:14 <c_wraith> badkins: likewise, lazy code can run in constant space, under proper conditions
11:17:17 <monochrom> constant space = the exactly right amount of eagerness and laziness
11:17:29 <badkins> c_wraith: the result is a Bool - I hope that's constant size in Haskell :)
11:18:03 <leifw> monochrom: thanks, that's the first cogent explanation of the install process I've seen
11:18:12 <c_wraith> badkins: anyway, see the horror I unleashed in that second definition?
11:18:37 <badkins> c_wraith: not really relevant to the problem at hand
11:18:45 <c_wraith> Oh really?
11:18:55 <badkins> the question is why the following function allocates nearly half a gig of RAM:
11:18:57 <badkins> palindrome :: B.ByteString -> Int -> Int -> Bool
11:18:58 <badkins> palindrome s b e | b < e = (B.index s b) == (B.index s e) && palindrome s (b+1) (e-1)
11:18:58 <badkins>                  | otherwise = True
11:18:59 <badkins>  
11:19:04 <badkins> I'm not advocating writing it in C.
11:19:51 <badkins> it's supposed to simply iterate over an array
11:20:40 <c_wraith> I thought you said your ultimate question was how to make it fast.
11:20:53 <ddarius> badkins: That function should run in constant space.  It will generate a lot of garbage, but it will only have a constant live set and it will only use constant stack.
11:21:11 <badkins> yes, and not allocating half a gig of ram will make it faster - I can almost guarantee that even being a Haskelly newbie
11:21:41 <badkins> ddarius: ok, then I'm not communicating my goal - I don't want to allocate garbage 
11:22:03 <monochrom> I do wonder what does it allocate.
11:22:14 <c_wraith> monochrom: new I# objects
11:22:14 * ezyang wonders if some fusion is in order, then. 
11:22:37 <ddarius> monochrom: Thunks for the second argument of (&&) primarily, I'd say.
11:22:46 <hpc> badkins: "allocating garbage" isn't expensive; it happens constantly as any haskell program runs
11:22:54 <hpc> the garbage collector is specifically optimized for this
11:23:11 <c_wraith> badkins: until you have benchmark results showing that it's "slow", you shouldn't assume it is.
11:23:22 <hpc> the alternative to lots of ints is to mutate one, which is icky
11:23:44 <ddarius> This can be easily rewritten as a tail recursive loop that doesn't allocate.
11:23:56 <ddarius> Without mutation or low-level functions.
11:23:59 <badkins> c_wraith: twice the speed of interpreted Ruby isn't fast IMO
11:24:15 <c_wraith> oh?  It's twice the speed.
11:24:24 <hpc> it's webscale!
11:24:31 <c_wraith> ruby isn't as stupid-slow as python on tight loops.
11:24:40 <c_wraith> err, cpython, to be precise
11:24:49 <badkins> c_wraith: yes, and the profiler shows much time in built-ins i.e. C code, but still
11:25:32 <badkins> c_wraith: you're point re: speed vs. allocation is valid though, I'll run some more tests, maybe I'm overracting on the allocation, but it does seem extreme
11:26:11 <ezyang> badkins: Haskell will give you rope to do some heavy optimization work, but you should first figure out if it's truly necessary. 
11:26:20 <badkins> I was assuming it would be at least 10 times faster than the Ruby though
11:26:34 <ddarius> badkins: It will certainly take less time if you avoid the allocation while otherwise doing no more work, but it is indeed the case that Haskell programs allocate like crazy and are still pretty fast.
11:26:34 <c_wraith> compare it to a C implementation of the same algorithm
11:26:42 <hpc> @hoogle bytestring
11:26:43 <lambdabot> package bytestring
11:26:43 <lambdabot> module Data.ByteString
11:26:43 <lambdabot> module Text.Parsec.ByteString
11:26:44 <badkins> ezyang: it's necessary in this case since that's the entire point of this particular exercise
11:27:20 <badkins> c_wraith: great idea
11:27:43 <ezyang> Oh, sure. :-) 
11:28:00 <badkins> it could be that the Ruby impl. just got "lucky" in this case - if the Haskell is close to C and Ruby takes twice as long, then I'm chasing a red herring
11:28:10 <Skola> I've done 'cabal install hoogle', all seemed fine and dandy, but 'hoogle' on CL doesn't do anything
11:28:25 <Skola> i've tried 'cabal install hoogle' again, but it says it has been installed
11:28:40 <badkins> c_wraith: anyway, gotta run - thx for the help. If I come up with anything interesting, I'll report back.
11:28:49 <Skola> any hints on what I'm doing wrong?
11:30:27 <c_wraith> Skola: you need to generate indices for hoogle to work with, locally.  Or do you mean the program just doesn't work.
11:30:45 <Skola> prog doesn't run, ie: /bin/sh: hoogle: command not found
11:30:52 <hpc> aw, badkins left
11:31:16 <c_wraith> Skola: is ~/.cabal/bin in your path?  and if it is, is the hoogle binary in there?
11:32:30 <Skola> yes to both, sorry ;p
11:32:42 <dolio> ddarius, monochrom: I wouldn't be surprised if b and e don't get fully unboxed, either. So it might allocate for those every iteration, too.
11:32:45 <Skola> thx
11:32:59 <c_wraith> Skola: Then...  I have no clue why you get that error message.
11:34:30 <ddarius> dolio: It certainly doesn't.
11:34:41 <ddarius> s/It/They/
11:34:47 <ddarius> s/doesn't/don't/
11:35:24 <dolio> Anyhow, depending on how big the strings are, that's a lot of allocation.
11:35:44 <c_wraith> I'm assuming the test string is huge
11:35:55 <c_wraith> I'm writing up some criterion benchmarks now
11:36:03 <dolio> It can be a significant slowdown, too.
11:36:20 <dolio> Depending on just how fast you're aiming for.
11:36:45 <ddarius> dolio: The obvious tail recursive version will definitely be faster than the version mentioned above.
11:37:54 <c_wraith> ddarius: what exactly does it remove?  && is tail recursive when its first arg is True
11:37:56 <dolio> It can easily be a factor of 10 if you're shooting for a really tight loop.
11:38:46 <ddarius> (&&) isn't even recursive, so it doesn't make much sense to say it is tail recursive.
11:39:19 <c_wraith> ddarius: well, fine.  It's implemented as "replace my execution with the execution of the second argument".
11:40:21 <c_wraith> which makes that full definition properly tail-recursive
11:40:23 <dolio> Does the obvious tail-recursive version not short-circuit?
11:40:33 <dolio> Because that'd be kind of a disadvantage.
11:40:41 <ddarius> "Tail recursive" is a syntactic property.
11:41:54 <ddarius> dolio: It won't if you don't write it that way, but it would be silly to do that.
11:42:37 <dolio> What is the difference then? Use if instead of (&&)?
11:42:58 <ddarius> dolio: How would you write that function in an eager language?
11:44:13 <dolio> I'd use if instead of (&&).
11:44:23 <dolio> Except, && would still work in, say, C.
11:45:35 <ddarius> dolio: And does that not short-circuit?
11:46:21 <dolio> It does. But it's the same solution that isn't optimizing well in Haskell.
11:46:44 <burp> > let  = pi in 
11:46:45 <dolio> The only difference would be if (b+1) and (e-1) aren't allocated in the if case.
11:46:45 <lambdabot>   3.141592653589793
11:46:51 <dolio> Which may be, I'm not sure.
11:47:07 <parcs> :t 
11:47:08 <lambdabot> <no location info>: not an expression: `'
11:47:13 <dolio> I guess since if desugars to case, it will end up better.
11:47:21 <ddarius> dolio, c_wraith: You can easily check the core in each case.
11:47:23 <parcs> @let  = pi
11:47:24 <lambdabot>  Defined.
11:48:03 <dolio> Obviously the problem is that (&&) doesn't inline. :)
11:48:18 <dolio> We need to dons-ify base.
11:48:56 <Eduard_Munteanu> Hm, I wonder if GHC could leverage Graphite.
11:49:10 <Eduard_Munteanu> For loop transformations, not auto-parallelization.
11:49:40 <Eduard_Munteanu> (you know, the newer GCC transformation backend
11:49:51 <ddarius> dolio: Perhaps badkins didn't use optimizations.  I haven't looked at the core.
11:50:01 <ddarius> I'm sure it will be clear what's happening if one looks though.
11:50:09 <dolio> I thought GCC was specifically designed not to be leverageable.
11:50:30 <Eduard_Munteanu> Um, I think Graphite was conceived separately from GCC.
11:50:45 <dolio> Yeah, I'm reinstalling ghc-core.
11:50:46 <Eduard_Munteanu> (and anyway, GCC is still pretty much on par with LLVM if not better)
11:50:47 <hpc> "leverage"?
11:50:59 <hpc> what is this, a corporate java programming forum?
11:51:08 <Eduard_Munteanu> Heh.
11:51:09 * hackagebot aeson 0.3.1.1 - Fast JSON parsing and generation  http://hackage.haskell.org/package/aeson-0.3.1.1 (BryanOSullivan)
11:51:49 <Eduard_Munteanu> Well, I mean GHC probably isn't anywhere near GCC or other C compilers in terms of loop transformations and such microoptimizations.
11:52:39 <thoughtpolice> there is plenty of low-hanging fruit in the C-- optimizer to close such gaps, it's just that nobody has done it. i hope this will become easier with the new code generator (and plugins: I would like to make C-- round-trippable so you can write plugins for C-- passes)
11:53:02 <ezyang> We need to make it faster first! >:-( 
11:53:24 <pokoko222> doing algebraic structures proofs gets wierd, lot of new words, lot of new ism's :) i guess it is ok not to concentrate on remembering the words and just do the proofs formally without trying to get intuition ?
11:53:37 <dolio> Eduard_Munteanu: I meant more that GCC is designed so that you can't break out any piece of it and use it independently, because doing so might be useful for people who want to use just that piece for their proprietary optimizers or what have you.
11:53:43 <thoughtpolice> ezyang: can it bootstrap GHC yet? i haven't followed your discussions on g-h-u very closely in the past week (which is unusual, i'm normally all over g-h-u)
11:53:43 <dolio> So I've heard, at least.
11:54:09 <ezyang> thoughtpolice: Yes, GHC is bootstrappable. 
11:54:12 <dolio> Not that it lacks any particular analyses that LLVM (say) has.
11:54:24 <Eduard_Munteanu> Hm, I know its internals are supposedly really unclean and such, but still.
11:54:40 <thoughtpolice> ezyang: i assume you're moving to optimizing hoopl, then? if so, that would be very nice
11:54:40 <ezyang> It also passes all tests (with one most recent patch that hasn't been put in yet), excluding DPH. 
11:54:40 <ezyang> Yep, that's my next target. 
11:54:55 <c_wraith> ok, having my long test be a 50 MB bytestring was probably too much...
11:55:07 <c_wraith> criterion is estimating this will take about forever
11:55:08 <ddarius> dolio: I doubt that that's the case.
11:55:25 <dolio> Could well be an urban myth.
11:55:29 <thoughtpolice> ezyang: hoopl could also use some documentation love, imo. but i guess i should write the patches for that ;)
11:55:33 <Eduard_Munteanu> But still, writing C code to be compiled by GCC doesn't seem like a nice option compared to generating a GIMPLE tree directly. (I'm not a GCC expert at all so I might be wrong.)
11:56:00 <ezyang> thoughtpolice: I was working on a tutorial-ish article, but I got stuck designing the simplest possible language that could still admit data flow optimization. 
11:56:19 <thoughtpolice> the thing is, AFAIK, you can't just generate a GIMPLE tree directly. at least not one you can feed to GCC - gimple is a GCC-internal intermediate language
11:56:20 <ezyang> I originally wanted nops and unconditional jumps, but then there's no facts to transfer down teh graph... 
11:56:59 <Eduard_Munteanu> Yes, but IIRC there's been some work done so that you can hook static analysis tools straight into GCC.
11:57:18 <Eduard_Munteanu> Actually use GCC's internal machinery to do stuff for you.
11:57:20 <thoughtpolice> ezyang: indeed, I had something slightly working for a ad-hoc GRIN implementation that could do some constant propogation, but it was rather ill-formed and quickly hacked together
11:57:33 <thoughtpolice> ezyang: why not just illustrate the example that comes with hoopl in the master git repository?
11:57:49 <ezyang> thoughtpolice: I've been thinking I'll do just that; a sort of guided tour of the test suite. 
11:58:17 <thoughtpolice> that would probably be easiest, and all the work's already done (the one part that might confuse some is all the generic map_VV operations and whatnot)
11:58:40 <c_wraith> Ok, a 5 MB long palindrome is much better
11:58:52 <ezyang> It feels a little lame, since it means I don't actually write any code :-) 
11:59:07 <c_wraith> Now that it runs fast, I'll add in obvious tail-recursive versions
11:59:18 <copumpkin> the xml package seems broken
11:59:18 <copumpkin> its parser
11:59:19 <dolio> ddarius: That function actually gets pretty unpacked at -O2.
11:59:21 <copumpkin> has anyone else noticed this?
11:59:57 <dolio> Even at -O.
12:00:16 <thoughtpolice> Eduard_Munteanu: you can. but GHC also doesn't feed GCC code unless you're going -fvia-C, and even then, i'm not sure what kind of information you would propogate to GCC's optimization phase (AFAIK, you can basically insert phases after compilation steps, so if you wanted to tickle optimizations, i think you'd have to specifically craft the AST to suit what the optimizer wants, while still being semantics preserving)
12:00:54 <thoughtpolice> it would be interesting to try, though
12:01:20 <ddarius> dolio: It's also quite possible that badkins' "problems" have to do with how he is getting the bytestring.  Are there any lets in the definition?
12:02:16 <c_wraith> I forgot how fun criterion is
12:02:18 <Eduard_Munteanu> AFAIK, it goes like core -> simplifier -> (loop around) ->STG -> C / C--   so maybe there's potential to generate a better IR straight from STG. I don't know much about this sorta stuff so I might be saying something really stupid :)
12:03:12 <thoughtpolice> ezyang: true, although I think the language implemented in the hoopl test suite is probably the simplest possible source language that can allow dataflow based optimization (basically mini-c--) maybe something like GRIN would be more interesting, it's a pretty small language
12:03:35 <c_wraith> ddarius: my benchmarks show no change at all by changing && -> if
12:03:41 <ezyang> I'd believe that. 
12:04:01 <dolio> ddarius: Doesn't look like it.
12:04:01 <ddarius> dolio: As (&&) is non-recursive, I'd expect GHC to inline it completely.
12:04:16 <c_wraith> ddarius: so what change did you mean?
12:04:22 <ddarius> c_wraith: So, either badkins isn't using -O(2) or he is generating the garbage in reading in the input.
12:04:38 <thoughtpolice> Eduard_Munteanu: like I said, the c-- optimizer actually doesn't do a whole lot at the moment. there is plenty of opportunity for exotic/interesting optimizations at the C-- level. the new code generator also has a new, more modular version of the STG -> Cmm transformation, so there are probably more opportunities
12:04:47 <ddarius> The latter being quite likely.
12:05:07 <c_wraith> ddarius: or he's looking at the allocation of short-lived I# and W# objects, and deciding that's a disaster
12:05:55 <ddarius> c_wraith: Those should be unboxed if (&&) gets inlined, as you get a straight tail-recursive loop.
12:05:55 <Eduard_Munteanu> I see.
12:05:56 <thoughtpolice> a loop unroller for C-- for example, would be pretty neat to have. BSP_ already implemented a version of a loop-unroller as a core plugin, but i haven't updated it to work with the latest version of GHC plugins
12:06:00 <c_wraith> @src Word8
12:06:00 <lambdabot> Source not found. My brain just exploded
12:06:10 <thoughtpolice> ugh, i need my tax refund already. not having a machine I can develop my work on is excruciatingly painful :(
12:06:52 <ddarius> c_wraith: There was never any question (for me) of memory being retained.
12:07:38 <c_wraith> ddarius: full disclosure - here's my test code  http://hpaste.org/44768/palindroms_with_benchmarking  
12:07:51 <ddarius> thoughtpolice: Adjust your W4.
12:08:06 <ddarius> Not that that helps you much right now.
12:08:14 <thoughtpolice> hah.
12:08:31 <ddarius> c_wraith: Look at the core as dolio has done.
12:09:27 <c_wraith> I've never learned to read core
12:09:47 <thoughtpolice> c_wraith: it's pretty easy, it just takes some practice. cabal install ghc-core, it makes it much easier
12:10:07 <c_wraith> and I should go eat now...  I'll take a look at it after I get some food in me.  and I'm installing ghc-core as we speak :)
12:10:17 <dolio> A lot of times, you can look at types and be pretty confident.
12:10:35 <copumpkin> aristid: you worked with the xml package?
12:10:39 <c_wraith> ah, hell.  I think I need to install pcre
12:10:44 <dolio> The palindrome function gets worker-wrappered into something with all unboxed arguments.
12:11:11 <dolio> Int# -> Int# -> Addr# -> ForeignPtrContents -> Int# -> Int# -> Bool
12:11:37 <aristid> copumpkin: yes.
12:11:38 <dolio> The first four are an unpacked bytestring, the next two are the two integer arguments.
12:11:47 <aristid> copumpkin: i still do
12:11:49 <copumpkin> aristid: did you notice any issues with Text.XML.Input parsing?
12:11:59 <copumpkin> for example, it produces a valid "parse" for <foo></fo>
12:12:30 <copumpkin> I mean Text.XML.Light.Input
12:12:43 <c_wraith> bah.  stupid os x
12:13:01 <aristid> copumpkin: yes, it is VERY lax
12:13:05 <copumpkin> Prelude Text.XML.Light.Input> parseXMLDoc "<foo>"
12:13:06 <copumpkin> Just (Element {elName = QName {qName = "foo", qURI = Nothing, qPrefix = Nothing}, elAttribs = [], elContent = [], elLine = Just 1})
12:13:07 <copumpkin> lol
12:13:17 <copumpkin> that's one thing you could call it
12:13:42 <copumpkin> aristid: any way I can make it a little more strict (not in the haskell sense)? :)
12:15:10 * ddarius might write a small library to spit out RDL soon.
12:15:24 <copumpkin> :O
12:16:58 <aristid> copumpkin: no. use another parser if you need strictness.
12:17:10 <copumpkin> aristid: I don't really
12:17:18 <copumpkin> it just makes me uneasy
12:17:43 <ddarius> Use another parser if you want peace of mind.
12:17:47 <copumpkin> :)
12:17:53 <copumpkin> hxt is terrifyingly large
12:18:22 <Eduard_Munteanu> HXT is terrifyingly slow for some of the stuff I tried, mostly XPath :(
12:18:57 <ddarius> Clearly we need something that compiles XPath down to machine-code automata.
12:20:00 <aristid> copumpkin: have you considered using libxml2-enumerator in combination with xml-enumerator? (or xml-enumerator alone)
12:20:20 <Eduard_Munteanu> Perhaps plain, lazy Tagsoup would be better, but it'd be more work to extract what I need.
12:20:46 <c_wraith> @hoogle deepseq
12:20:46 <lambdabot> No results found
12:21:21 <Eduard_Munteanu> @hackage youshouldntfindthis
12:21:22 <lambdabot> http://hackage.haskell.org/package/youshouldntfindthis
12:21:25 <Eduard_Munteanu> Bah.
12:22:20 * hackagebot wol 0.1.2 - Send a Wake on LAN Magic Packet  http://hackage.haskell.org/package/wol-0.1.2 (TomLokhorst)
12:24:05 <copumpkin> aristid: don't really feel like dealing with all the baggage, just want something lightweight
12:24:12 <copumpkin> I'll just stick with the xml package
12:24:19 <c_wraith> @hoogle evaluate
12:24:19 <lambdabot> Control.Exception evaluate :: a -> IO a
12:24:20 <lambdabot> Control.OldException evaluate :: a -> IO a
12:24:20 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
12:26:54 <aristid> copumpkin: well, the xml package works, it just and simply has no error handling at all :)
12:27:01 <copumpkin> fair enough
12:27:05 <copumpkin> I'll assume my xml is well forme
12:27:43 <c_wraith> ok, want to hear something sad, before I *actually* go eat?  The generated code is *way* faster under 64-bit linux in VMWare than it is under OS X directly.
12:31:04 <copumpkin> aristid: I'm mostly puzzled why it'd bother returning in Maybe if the only time it fails is with no tags in the input
12:31:05 <copumpkin> it seems
12:31:35 <aristid> copumpkin: good question :D
12:31:46 <ddarius> What should it return in the no tags case?
12:32:13 <copumpkin> can't argue with that ;)
12:32:17 <copumpkin> I'd just expect it to fail a little more often
12:41:35 <ian_mi> copumpkin: have you ever written a Vec (++)?
12:45:15 <copumpkin> ian_mi: sure, that should be pretty straightforward?
12:45:31 <copumpkin> either with a well-typed foldr or just explicit recursion
12:46:26 * hackagebot mongoDB 0.9.5 - MongoDB driver  http://hackage.haskell.org/package/mongoDB-0.9.5 (TonyHannan)
12:46:31 <ian_mi> copumpkin: the problem I'm having is the type
12:46:44 <copumpkin> oh, you want to write type-level addition :)
12:46:49 <ian_mi> I tried making a Plus type family
12:47:06 <copumpkin> you need to recurse in the right way 
12:47:10 <ian_mi> the problem is I needed a Nat class to define applicative but I can't make type families a class instance
12:48:04 <copumpkin> can I see some code?
12:48:09 <ian_mi> sure
12:52:23 <ian_mi> http://hpaste.org/44770/naturals
12:52:31 <ian_mi> http://hpaste.org/44771/fixedlist
12:52:52 <ian_mi> that's everything except my attempt at type level addition
12:54:20 <ian_mi> the naming is unusual since I didn't know what these things were called
12:54:34 <copumpkin> you shouldn't need the Nat n constraint within the list
12:54:42 <copumpkin> you could write a separate constraint adder
12:55:04 <copumpkin> maybe it won't hurt though
12:55:17 <ian_mi> constraint adder?
12:55:44 <copumpkin> data IsNat n where IsNat :: Nat n => IsNat n
12:55:55 <copumpkin> lengthIsNat :: FixedList n a -> IsNat n
12:56:21 <copumpkin> then I'd probably turn on pattern guards
12:56:40 <copumpkin> and then you can write blah xs | IsNat <- lengthIsNat xs = ...
12:56:45 <copumpkin> and you'll have the Nat constraint in scope
12:58:09 <djahandarie> Hi copumpkin
12:58:13 <copumpkin> hi djahandarie 
12:58:47 <djahandarie> I got my package added to lambdabot whoo
12:58:57 <copumpkin> I don't want to hear about your package, man
12:59:17 <copumpkin> (but what is it?)
12:59:18 <djahandarie> My package is a pretty big deal.
12:59:23 <djahandarie> @vixen Do you like my package?
12:59:23 <lambdabot> i'd say i like
12:59:48 <djahandarie> > ala ZipList Data.Traversable.traverse [[1,2,3],[4,5,6]] -- this thing
12:59:49 <lambdabot>   [[1,4],[2,5],[3,6]]
12:59:52 <copumpkin> oh yeah
12:59:57 <copumpkin> nice
12:59:59 <copumpkin> :t ala
13:00:00 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
13:00:06 <copumpkin> @let la = ala
13:00:07 <lambdabot>  Defined.
13:00:20 <ian_mi> copumpkin: so pure would be defined for any FixedList but would produce a pattern match failure if not used on a Nat?
13:00:49 <copumpkin> there'd be no way to use it on anything but a nat
13:00:59 <copumpkin> you'd still want to witness naturals
13:01:09 <ian_mi> oh
13:01:35 <ian_mi> well then I still can't define Applicative for a Plus type I think
13:02:32 <djahandarie> @let 锓 = ala
13:02:32 <lambdabot>   Illegal character ''\65010''
13:02:37 <copumpkin> ian_mi: I've done it before
13:02:45 <copumpkin> well, you can't write applicative for plus
13:02:49 <copumpkin> but you can write ++
13:04:08 <ian_mi> oh :-/
13:05:06 <ezyang> Ah, I have a friend complaining about how GHC+libraries like making BC incompatible changes on point releases. 
13:05:20 <ezyang> (pointing specifically to the time when Cabal disallowed dependencies without upper bounds) 
13:06:44 <copumpkin> ian_mi: why do you need Plus in your instance?
13:08:11 <ian_mi> copumpkin: I want to be able to concat a FixedList n and a FixedList m and get a FixedList (Plus n m) and then use applicative on the result.
13:08:41 <dcoutts_> ezyang: strictly speaking, it's hackage that disallows uploads of packages that do not specify upper bounds on base
13:08:54 <ian_mi> copumpkin: specifically some vector functions I'm writing would be much easier expressed with (++) but my vector functions make heavy use of applicative
13:09:01 <dcoutts_> ezyang: and it has no particular release cycle to its updates/changes
13:09:40 <ezyang> dcoutts_: That doesn't really surprise me. But the Haskell ecosystem does seem to be in the strange twilight zone where it's considered to be too unstable and too stagnant at the same time. 
13:10:18 <ian_mi> it came up while writing the unscented transform
13:10:55 <copumpkin> ian_mi: I'll check it out later, sorry
13:11:09 <ian_mi> copumpkin: no problem, thanks for your help
13:11:33 <ezyang> But I should just shut up and make things better :-) 
13:11:35 * hackagebot HaskellForMaths 0.3.2 - Combinatorics, group theory, commutative algebra, non-commutative algebra  http://hackage.haskell.org/package/HaskellForMaths-0.3.2 (DavidAmos)
13:11:56 <ian_mi> it seems like the fact that a type class is closed under a type function would be a very natural thing to express. Perhaps I just want agda and not haskell.
13:12:35 <aristid> copumpkin: i have a stupid question... why did you ask specifically me about the xml package?
13:18:16 <jfischoff> has there been any attempts to integrate quickcheck with distributive development?
13:18:47 <jfischoff> so that anyone can submit code if it passes the quickcheck tests
13:19:15 <pozic> jfischoff: nobody did that.
13:19:22 <napping> I've heard of setting up tests as a presubmit hook
13:19:36 <napping> but never of automatically accepting patches that pass tests
13:19:39 <FauxFaux> Pending head.  (starts giggling)
13:20:12 <jfischoff> yeah, maybe they go into a special trunk
13:20:18 <jfischoff> just wondering
13:20:18 <c_wraith> napping: I'd submit a patch to remove all tests. :)
13:20:26 <c_wraith> It'd pass all tests!
13:20:36 <jfischoff> ive worked with people that have done
13:20:38 <jfischoff> that
13:21:02 <c_wraith> yikes.  I joke about breaking systems, I rarely actually do it intentionally
13:21:24 <jfischoff> yeah, the gaming world has a different concept of correctness
13:21:45 <napping> that's a pretty obvious failure mode - you'd have to check against the old tests
13:22:10 <napping> or just not allow changes to tests at all
13:22:43 <c_wraith> It's fully possible that neither of those are correct
13:23:01 <c_wraith> Really, the right thing is to have tests in a different tree, and check updates to that tree manually :)
13:23:09 <napping> I've thought of setting homework as a Coq module specification - grep the code for 
13:23:10 <c_wraith> Or, you know, not auto-accept patches :)
13:23:26 <ezyang> repo.or.cz has the concept of a 'mob' branch. 
13:23:26 <napping> "Axiom" and such, and then just run the typechecker
13:23:30 <ezyang> But I don't think it's used very much. 
13:23:45 <jfischoff> I would like to think of way auto-accept patches so I can scale a project very quickly
13:24:18 <jfischoff> Start with a spec, build the tests, and crowd source the implementation
13:24:21 <copumpkin> aristid: cause I noticed you'd written the xml monad wrapping it :)
13:24:44 <napping> I don't think that can actually be safe
13:24:46 <ezyang> jfischoff: Ever heard of the mythical man month? 
13:24:51 <napping> maybe if you required proofs
13:25:04 <jfischoff> ezyang: yes
13:25:31 <napping> and even then, it's hard to specify performance and concurrency and such
13:26:04 <jfischoff> ezyang: but I am not convinced that you can't scale because of it
13:27:17 <aristid> copumpkin: heh :)
13:27:27 <jfischoff> ezyang: repo.or.cz could be something to build off of
13:27:37 <jfischoff> ezyang: thanks :)
13:28:00 <ezyang> I mean, I think crowdsourced coding is a bad idea. But maybe that's just me. 
13:29:21 <monochrom> if you require machine-checkable proofs and you machine-check them, it will work, but even then the strategy is not to just accept every checked submission.
13:29:34 <jfischoff> ezyang: do you think parallel execution is bad? Is there is a spec with tests I don't really see the difference
13:29:53 <djahandarie> Crowdsourcing, the digital analogue of crowdsurfing...
13:30:04 <jfischoff> what if ten people wrote the same function
13:30:12 <jfischoff> and 6 of them model checked the same
13:30:20 <jfischoff> I would be fine accepting that function
13:31:48 <jfischoff> or not who knows...
13:31:59 <djahandarie> I say that we just write specifications and replace all these people with computers. ;)
13:32:21 <jfischoff> one day ... :)
13:32:27 * djahandarie encodes all his invarients in the type system and enslaves the masses
13:32:37 <napping> an infinite number of monkeys, with an infinite number of proof assistants
13:32:48 * hackagebot craftwerk 0.1 - 2D graphics library with integrated TikZ output.  http://hackage.haskell.org/package/craftwerk-0.1 (MalteHarder)
13:33:43 <djahandarie> I wish there were more newtypes in base.
13:34:08 <djahandarie> So I could show off ala more
13:34:42 <mauke> did you mean: alan moore
13:35:03 <dolio> No.
13:35:49 * hackagebot craftwerk-cairo 0.1 - Cairo backend for Craftwerk.  http://hackage.haskell.org/package/craftwerk-cairo-0.1 (MalteHarder)
13:35:51 * hackagebot craftwerk-gtk 0.1 - Gtk UI for Craftwerk.  http://hackage.haskell.org/package/craftwerk-gtk-0.1 (MalteHarder)
13:36:43 <djahandarie> :t ala WrapMonad Data.Traversable.traverse -- look at me mum, I can write sequence!
13:36:44 <lambdabot> forall (m :: * -> *) a (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
13:37:04 <ezyang> :t ala 
13:37:05 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
13:37:15 <dolio> ala is defined in lambdabot?
13:37:19 <djahandarie> Nope
13:37:25 <djahandarie> @hackage newtype
13:37:25 <lambdabot> http://hackage.haskell.org/package/newtype
13:37:31 <djahandarie> It's Conor's thingy that I packaged up
13:37:43 <dolio> Well, but it's imported now.
13:37:48 <djahandarie> Oh, yeah.
13:39:08 <djahandarie> Once you snag some newtypes from mtl or similar you can do some pretty neat stuff
13:41:17 <freedrull> i have a problem here, i dont think i can call runGetState if i'm already in the Get monad... http://hpaste.org/44777/getevents
13:41:45 <byorgey> djahandarie++
13:41:51 * byorgey <3 newtype package
13:42:06 <parcs> freedrull: runGetState isn't monadic
13:42:08 <parcs> use let
13:42:10 <djahandarie> :)
13:42:57 <freedrull> parcs: do something like let n = runGetstate?
13:43:03 <parcs> yeah
13:43:45 <freedrull> parcs, thanks
13:45:04 <djahandarie> I'm pretty interested in trying to find a way to make GHC automatically generate the Newtype instances for all newtypes.
13:45:10 <djahandarie> That'd make the library even more useful/neat
13:45:25 <ezyang> shouldn't be too hard. 
13:45:33 <dolio> @type ala Product Data.Foldable.foldMap
13:45:35 <lambdabot> forall o (t :: * -> *). (Num o, Data.Foldable.Foldable t) => t o -> o
13:45:56 <jfischoff> djahandarie: TH is easy for that
13:46:04 <jfischoff> as a stop -gap
13:46:05 <dolio> > ala Product Data.Foldable.foldMap [1..10]
13:46:06 <lambdabot>   3628800
13:46:41 <aavogt> jfischoff: even deciding which data types to generate it with?
13:46:50 <jfischoff> no
13:46:57 <aavogt> my understanding is that you can't directly query which instances already exist
13:47:06 <jfischoff> yes and no
13:47:16 <jfischoff> with my patch you can :)
13:47:17 <aavogt> but maybe you can run a separate ghci to get that information :)
13:47:31 <jfischoff> yes, actually that is how I patch ghc
13:47:44 <jfischoff> the function for get that info already existed
13:47:59 <djahandarie> I think requiring a GHC patch is going a little too hardcore for this ;)
13:48:11 <djahandarie> I'd ideally want it to be entirely transparent
13:48:22 <jfischoff> like ezyang said it would not be hard
13:48:28 <jfischoff> just no one could use it then
13:48:34 <maurer_> Querying instances sounds like it breaks separate compilation?
13:48:35 <jfischoff> that's problem I have now
13:48:50 <aavogt> jfischoff: so it's more sensible than looking at    'ghc -e ":info ClassName" | grep instance'?
13:48:51 <jfischoff> maurer: its working for me
13:49:11 <maurer_> jfischoff: Sorry, not that it would not function, but rather that it means that different compilation orders may produce different results.
13:49:12 <aavogt> in that you pick up the imports in the file you're processing a bit more automatically
13:49:27 <djahandarie> importing Control.Newtype and automatically getting instances written for whatever newtypes you have would be awesome. But I imagine it might require a LANGUAGE pragma or two in your file possibly.
13:49:32 <jfischoff> maurer: yeah I have no idea, its a hack
13:49:46 <djahandarie> Or it might just be entirely impossible.
13:49:52 <jfischoff> yeah, my patch can't do that
13:50:14 <jfischoff> I just changed reify to return instances for a type
13:50:19 <thoughtpolice> it would probably be easiest to just use TH to generate it. of course, magical autogeneration would be nice, but I think TH would work quite well for this case
13:50:25 <freedrull> parcs: like this? hmm i still get the same type error.. http://hpaste.org/paste/44777/getevents_annotation#p44781
13:50:27 <ezyang> Confusingly enough, it'd be DerivingNewtype (instead of NewtypeDeriving :-) 
13:50:31 <jfischoff> but template haskell for the newytpe class is easy
13:50:31 <djahandarie> Haha
13:50:41 <jfischoff> haha
13:50:56 <djahandarie> Maybe this is finally a reason for me to torture myself and learn template haskell
13:50:58 <parcs> freedrull: half-way there
13:50:59 <thoughtpolice> this also means that people can start generating instances now, as opposed to 'waiting for a GHC near you that supports it!' (consider distribution pick-up time)
13:51:23 <freedrull> parcs ok
13:51:26 <jfischoff> djahandarie: template haskell is fine once you get the workflow
13:51:42 <thoughtpolice> TH was also made less noisy in GHC 7, which is nice
13:51:51 <thoughtpolice> (for top-level splices at least, which is what a majority of people do anyway)
13:51:52 <djahandarie> thoughtpolice, yeah I have no intention to make something that turns the package into something entirely impossible to use
13:51:56 * hackagebot vector-space 0.7.3 - Vector & affine spaces, linear maps, and derivatives (requires ghc 6.9 or better)  http://hackage.haskell.org/package/vector-space-0.7.3 (ConalElliott)
13:52:03 <ezyang> Hmm, is there a tutorial for using TH with deriving? 
13:52:11 <aavogt> djahandarie: it's just an awkward way to write haskell you already know, which just happens to lift some restrictions
13:52:12 <parcs> freedrull: getLazyByteString is monadic, so you have to bind it to a name using <- before you can you use it there
13:52:20 <thoughtpolice> ezyang: to derive instance automatically, you mean?
13:52:26 <ezyang> yeah. 
13:52:41 <thoughtpolice> there was one that covered something like that i think, but alas, it may have gotten destroyed when haskell.org got owned
13:52:47 * thoughtpolice checks
13:52:47 <djahandarie> http://www.haskell.org/haskellwiki/Template_haskell/Instance_deriving_example ?
13:52:48 <aavogt> @hackage derive has a bunch of documentation
13:52:49 <lambdabot> http://hackage.haskell.org/package/derive has a bunch of documentation
13:52:54 <ezyang> ooh, classy. 
13:53:30 <shachaf> lambdabot: s/ /%20/g
13:53:43 <jfischoff> if you runQ [d| instance Class blah |] you will get most of what you want
13:53:47 <djahandarie> I don't think packages are allowed to have spaces in their names ;)
13:53:50 <jfischoff> in ghci I mean
13:53:59 <edon> when hSetBuffering on a handle it effects both reading and writing to that buffer, right?
13:54:50 <thoughtpolice> hopefully, once jose's new deriving mechanism goes in, we can automatically derive instances without any template haskell. this currently already exists inside GHC (using the unknown, dusty -XGenerics flag) but is rather underutilized and not well documented as a result
13:54:58 <thoughtpolice> it's being destroyed in favor of jose's approach, iirc
13:55:08 <jfischoff> yes when does that come out?
13:55:18 <thoughtpolice> not sure if they will get it in for 7.2 or for 7.4
13:55:26 <dreixel> I don't think it'll make it for 7.2
13:55:30 <thoughtpolice> 7.2 will be cut very quickly in relation to 7.0, probably sometime soon
13:55:33 <thoughtpolice> so i'd say 7.4
13:55:33 <thoughtpolice> yeah
13:55:38 <jfischoff> it looks promising, although I couldn't grasp the paper on first blush
13:56:31 <maurer_> thoughtpolice: Do you have a link to "jose's approach" ?
13:56:39 <thoughtpolice> hold on one moment
13:56:51 <dreixel> maurer_: http://www.dreixel.net/research/pdf/gdmh.pdf
13:56:58 <tehgeekmeister> does anyone know how well the dbmigrations package works with mysql at present?
13:57:04 <maurer_> dreixel: thanks
13:57:46 <thoughtpolice> dreixel: ah, from the link i take it you're him? :>
13:57:51 <thoughtpolice> (jose i mean)
13:58:05 <dreixel> thoughtpolice: yes, pretty much
13:58:12 <dreixel> (I do prefer being called Pedro, though :p)
14:01:11 <roconnor> what's the deal with ArchLinux?
14:01:22 <parcs> roconnor: what about it?
14:01:36 <roconnor> parcs: no automatic builds?
14:02:03 <roconnor> how is that possible for a distro?
14:02:14 <parcs> no, unfortunately. all packages are uploaded by the builder
14:02:43 <lpsmith> So what's the advantage of Arch?  Every time I've tried something other than Debian,  I keep coming back...
14:03:06 <Botje_> it's gentoo without the mistakes
14:03:10 <roconnor> parcs: wait, they distriubte binaries built by random people?
14:03:14 <parcs> lpsmith: http://wiki.archlinux.org/index.php/Arch_Compared_to_Other_Distributions
14:03:38 <parcs> roconnor: random, no. trusted, yes
14:03:42 <roconnor> oh okay
14:04:04 <roconnor> as long as I cannot upload binaries
14:04:20 <jaspervdj> Anyone ever bothered implementing the ping protocol in Haskell?
14:04:38 <Botje_> you mean ICMP?
14:04:51 <jaspervdj> Yes, but specifically ping
14:05:07 <maurer_> jaspervdj: Ping is not a protocol, it is a particular ICMP packet
14:05:18 <Botje_> afaik the OS handles these things
14:05:51 <lpsmith> I think what jaspervdj wants is a ping :: Address -> IO ...  function
14:05:54 <jaspervdj> The OS responds to pings, but it's possible to send these from a program
14:06:02 <Botje_> ah.
14:06:12 <ezyang> At least on Linux, you need to be root. 
14:06:16 <jaspervdj> It's basically just creating an ICMP packet and sending it, then waiting for some sort of answer
14:06:35 <jaspervdj> ezyang: Ah, I didn't know that. How does the `ping` command solve that, then?
14:06:42 <lpsmith> yeah,  ping is SetUID
14:06:53 <sipa> $ ls -l /bin/ping
14:06:53 <sipa> -rwsr-xr-x 1 root root 35648 2010-07-28 16:51 /bin/ping
14:06:59 <sipa> notice the s
14:07:14 <Botje_> huh. funny that, it's not setuid on osx :]
14:07:14 <lpsmith> jaspervdj,  the solution is to run ping using the process interface
14:07:29 <lpsmith> (at least if you are on a linux system)
14:07:39 <freedrull> parcs: bind it in the let block? 
14:07:43 <jaspervdj> Hmm. I could also just use `system "ping ..."` but that's kind of lame
14:08:03 <HugoDaniel> maccatcher package is not building in ghc 7.0.2 with parsec 3.1.1
14:08:36 <maurer_> jaspervdj: Jus topen a RAW socket via network, and push a ping request out.
14:08:40 <lpsmith> slightly less lame would be to use runProcess
14:08:49 <maurer_> jaspervdj: Of course, then your process needs to be suid
14:08:54 <parcs> freedrull: something like s <- getLazyByteString (fromIntegral size); let n = runGetState getEvent s 0; ...
14:09:04 <jaspervdj> ok
14:10:08 <parcs> freedrull: also, you can remove the "in" in your code
14:10:54 <freedrull> parcs: thanks
14:11:36 <freedrull> wow that compiled
14:13:37 <freedrull> okay so when functions are monadic, you need to bind them to a name to ...get them out of the monad? :\
14:13:50 <freedrull> and it didnt make sense that i was binding runGetState because its not monadic
14:14:33 <freedrull> maybe if i rewrote this function without do blocks i would understand it more
14:14:38 <lpsmith> freedrull, basically.   Though it's somewhat more accurate to say that bind composes monadic actions,  and that you lift pure functions into monadic ones
14:15:26 <hpc> freedrull: consider the identity monad; data Identity a = I { runId :: a }
14:15:31 <freedrull> i understand that bind composes actions, but what do you mean by lifting pure functions
14:15:57 <hpc> er, to answer that question first: lifting a pure function means changing it from (a -> b) into f a -> f b
14:16:11 <hpc> or something like that
14:16:31 <freedrull> hpc: oh ok i understand that
14:16:39 <parcs> isn't it a -> b to a -> m b in this case?
14:16:55 <lpsmith> depends on how you lift it
14:16:56 <hpc> anyhoo, here's where i was going with the identity monad
14:16:57 <lpsmith> :t liftM
14:16:58 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:17:13 <freedrull> parcs: am i lifting in my code?
14:17:18 <hpc> (>>=) :: (a -> Id b) -> Id a -> Id b
14:17:40 <hpc> if we mentally remove all the "Id" we end up with (>>=) :: (a -> b) -> a -> b
14:17:43 <hpc> which is flip ($)
14:17:45 <lpsmith> :t \f mx -> mx >>= \x -> return f x
14:17:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m b -> m a -> m b
14:17:58 <lpsmith> :t \f mx -> mx >>= \x -> return (f x)
14:17:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
14:18:14 <parcs> freedrull: yes, with your use of return
14:18:15 <hpc> if we do the same thing for return, we end up with return = id
14:18:15 <lpsmith> :t \f x -> return (f x)
14:18:16 <lambdabot> forall t a (m :: * -> *). (Monad m) => (t -> a) -> t -> m a
14:18:27 <hpc> but we need to get things OUT of the monad too
14:18:36 <hpc> which is where runId comes in
14:18:45 <lpsmith> hpc,  you don't really ever take things out of the IO monad
14:18:50 <hpc> runId is the accessor for the inside of the Id structure
14:18:56 <hpc> and yeah, you can't remove stuff from IO
14:19:42 <hpc> anyhoo, runId :: Identity a -> a
14:19:43 <freedrull> parcs: oh i see
14:20:04 <hpc> when you pass it a huge do block, that do block evaluates to something like
14:20:10 <hpc> Id {runId = 5}
14:20:38 <hpc> so runId thatThing == 5; and in "x <- thatThing", x == 5
14:21:26 <Kaidelong> lpsmith: In a sense there is one IO monad in your program which is already unwrapped and is ()
14:21:33 <Kaidelong> or I guess better to just say it is your program
14:22:00 <lpsmith> actually main can be IO anything,  but the anything is ignored
14:22:17 <hpc> lpsmith: sometimes it is printed out at the end; depends on how you run main
14:22:56 <Kaidelong> lpsmith: Windows PowerShell... it could very well be sensible to have it be something else
14:23:09 <Kaidelong> I guess that might be why it was codenamed Monad
14:23:59 <lpsmith> but powershell really didn't have anything to do with monads,  as we use the term?
14:24:05 <Kaidelong> I don't know
14:24:13 <Kaidelong> you can think of Commandlets as being a monad
14:24:25 <Kaidelong> and the thing that PowerShell pushed was Commandlets
14:25:21 <Kaidelong> when you run cmdlets on the shell to get arguments to other cmdlets it's analogous to >>=
14:25:36 <Kaidelong> the object pipes pretty much is exactly >>=
14:25:53 <lpsmith> I've not really looked at PowerShell closely
14:26:23 <Kaidelong> (thinking about it that way the people who did PowerShell might have been inspired by haskell)
14:27:08 <c_wraith> GHC is, from some viewpoints, a Microsoft Labs project to develop features for future programming languages.
14:27:54 <Kaidelong> well Microsoft Research did collaborate with others as they tend to do being R&D
14:28:32 <c_wraith> It just so happens that GHC happens to be really useful to lots of people now, too.  And honestly, that's what makes it a good proving-ground for these ideas.
14:28:52 <ezyang> "I fear that Haskell is doomed to succeed." -- Hoare 
14:29:25 <djahandarie> Heh
14:30:02 <c_wraith> ezyang: don't worry, the simons haven't bought into that "success" stuff.  :)  (If they had, there would be things like porting bugfixes to previous versions)
14:31:13 <djahandarie> Not like it matters to them, let someone else deal with 'success' ;)
14:31:24 <ezyang> GHC is a kick-ass example of how to develop a cutting-edge compiler. 
14:31:39 <ezyang> If it was only that the success of a language was determined by its compiler... 
14:31:47 <jfischoff> true
14:31:49 <jfischoff> that
14:33:41 <johs> Is there by any chance something more SLIME-like for working with Haskell in Emacs than the standard Haskell-mode?
14:34:04 <johs> (Or is there some other editor/IDE I should be using?)
14:34:43 <parcs> johs: SHIME?
14:34:47 <johs> I googled it a bit, but there doesn't seem to be an overwhelming consesus on what is best.
14:34:58 <johs> parcs: :)
14:35:38 <johs> Oh, it actually exists.
14:35:42 <johs> I thought you were joking.
14:35:46 <parcs> haha
14:37:18 <johs> parcs: (Thanks, I'll have a look.)
14:48:11 <joeyh> I need a way to call futimes(3) from haskell, to change the mtime of a symlink
14:49:28 <pozic> joeyh: if there is nothing exported already (use grep on the GHC source code for example), use the FFI.
14:49:43 <dons> joeyh: ffi binding
14:50:00 <joeyh> hmm, good thought to use grep, I have been coming up dry checking modules, and can't reach hayoo
14:50:22 <joeyh> FFI> yeah, true. That'd be something new to learn
14:50:50 <pozic> joeyh: you can download an archive of Hackage too.
14:51:08 <pozic> joeyh: I wrote some tools once to grep through all of that fast.
14:51:09 <joeyh> hmm, that might be worthwhile.. Nada in ghc source
14:51:24 <pozic> joeyh: but using the FFI is not hard. 
14:51:38 <pozic> (it could be simpler, though)
14:51:51 <joeyh> IIRC RWH has a chapter, I will refresh my memory, I only remember it looked a million times easier than perl
14:52:15 <mkscrg> yup, RWH has a great chapter on the FFI
14:54:38 <dons> joeyh: foreign import ccall "foo.h foo" c_foo :: CString -> IP ()
14:54:40 <dons> for example
14:54:44 <dons> s/IP/IO/
14:56:14 <romanandreg> quick question: do you remember a project where you were impressed by the documentation? I'm trying to figure out best ways to do documentation of source code, and I guess checking a good doc example might help a lot
14:58:20 <mkscrg> romanandreg: I would start with the libraries included with GHC. There are links to the source from the online documentation.
14:58:37 <dons> romanandreg: binary is well-documented, imo
14:59:42 <parcs> i like the documentation of network and attoparsec
15:01:48 <mkscrg> question about modules: Say I've got two executables (Main modules) in the same directory, and they import disjoint sets of local modules. I want to put those sets of modules in subdirectories, rather than have them at the same level as the executables. How does Haskell handle this?
15:02:08 <ezyang> mkscrg: "Put them in a package and instal them." 
15:02:21 <ezyang> ARe you using Cabal? 
15:03:07 <mkscrg> No, I haven't felt like the project was big enough to use Cabal. It's just two executables with one or two imports each. I guess I should look into Cabal
15:03:14 <maurer_> mkscrg: Use two executable stanzas in your .cabal with Hs-Source-Dirs
15:03:24 <romanandreg> mkscrg, dons, parcs: thanks  going to check them out
15:03:26 <dons> mkscrg: cabal init
15:03:28 <dons> will get you started
15:03:36 <maurer_> mkscrg: If not using cabal, just ghc --make on each of them, and it should do fine...
15:04:52 <maurer_> mkscrg: Oh, I see, you're looking for the "-i" switch to ghc
15:05:37 <tehgeekmeister> is there an easy way to modify a package's cabal file to see if perhaps it's constraints on dependencies are just too strict?
15:06:56 <mkscrg> maurer_: Thanks, that's exactly what I was looking for.
15:06:58 <tehgeekmeister> (trying to work around hdbc being incompatible with the latest haskell platform.)
15:07:08 <mkscrg> And I'll look into Cabal for good measure.
15:11:07 <monochrom> @quote monochrom IO.String
15:11:07 <lambdabot> monochrom says: How do I extract the IO out of IO String?
15:11:13 <dcoutts_> tehgeekmeister: it's easy enough to use cabal unpack, edit the .cabal file and cabal install
15:11:33 <BMeph> monochrom: You, Sir, are brilliant! :)
15:11:41 <edwardk> pumpkin!
15:12:58 <tehgeekmeister> dcoutts_: okay, cool, that's the info I was after.
15:13:00 <romanandreg> how can I make my local haddock to output documentation with hackage stylesheet?
15:14:09 <monochrom> by using a new enough haddock, such as what is shipped with current Haskell Platform
15:16:07 <romanandreg> monochrom: uhmm just have to update my current installation of haskell then, cool :-)
15:16:11 <romanandreg> monochrom: thanks
15:16:14 <tehgeekmeister> huh.  so i fixed the problem in the cabal file, and the package installed with no problems.  then i go to build my project that depends on it, and it complains about the cabal file for that package being incompatible.  but the package is already installed?
15:20:26 <dcoutts_> tehgeekmeister: currently, cabal assumes installed versions and available versions are the same, so if you make changes to the deps it's a good idea to bump the version, e.g. add a final digit
15:20:32 <dcoutts_> for the local variant
15:20:51 <tehgeekmeister> ahhhhh
15:20:52 <tehgeekmeister> okay.
15:25:04 <serpentologist> How to remove haskell-platform built from the source code from the system ? (http://hackage.haskell.org/platform/linux.html)
15:25:42 <HugoDaniel> isn't there a make uninstall ?
15:26:09 <dons> serpentologist: you'll have to see where it installed things, and remove it manually, at the moment
15:26:37 <HugoDaniel> serpentologist, make sure you install it locally, with something like ./configure --prefix=/home/myuser/LocalPathDir
15:27:01 <serpentologist> too late, i have it already installed
15:28:33 <HugoDaniel> ok, an approach could be to install it locally, and see the dirs and files it has created, and then remove them from your first installation
15:29:03 <HugoDaniel> if you still have the installation log
15:29:18 <serpentologist> HugoDaniel, sounds like a good idea
15:29:20 <HugoDaniel> then you just need to remove whatever it installed
15:31:14 <HugoDaniel> serpentologist, try to keep everything local, even with cabal, dont forget to add a --user flag whenever you call cabal install pkg
15:31:43 <c_wraith> cabal install defaults to --user
15:31:54 <c_wraith> it's runhaskell Setup.hs that defaults to --global
15:31:57 <HugoDaniel> ah cool :)
15:32:11 <serpentologist> HugoDaniel, cabal seems to install everything in ~/.cabal anyway
15:33:09 <c_wraith> serpentologist: well, the registered packages go in a list that's in ~/.ghc, but most stuff goes in ~/.cabal yeah
15:34:33 <joeyh> wow, hsc2hs + Foreign.Storable = awesome
15:35:36 <c_wraith> joeyh: using bindings-dsl?
15:35:49 <pozic> c_wraith: unlikely.
15:36:00 <c_wraith> as far as I can tell, bindings-dsl is what makes hsc2hs what it should be
15:36:07 <pozic> c_wraith: yeah
15:36:19 <pozic> c_wraith: but new users won't flock to that.
15:36:36 <pozic> (they should, but unless someone tells them, they won't)
15:37:03 <c_wraith> admittedly, my one project that used hsc2hs didn't use bindings-dsl...  but I didn't need more than an opaque representation of the foreign data type.
15:37:12 <joeyh> nah, but my struct only has 2 elements
15:41:54 <dons> joeyh: cool
15:42:01 <dons> using the RWH FFI chapter? or just working it out
15:42:57 <lispy> http://www.haskell.org/HOpenGL/  <-- page broken.  Who can fix it?
15:43:35 <zachk> why isnt / a visible method of the num class? 
15:43:50 <lispy> :t (/)
15:43:51 <lambdabot> forall a. (Fractional a) => a -> a -> a
15:43:58 <shachaf> zachk: Not all numbers can be (/)d.
15:44:01 <lispy> zachk: because it's Fractional
15:45:23 <joeyh> dons: RWH does not cover structs, but there is some stuff on the wiki
15:45:52 <hai> what is a efficient way to get the second half of a list? i've been wondering
15:47:11 <shachaf> hai: In general you can't.
15:47:20 <dons> hai: its a bit tricky if you don't know the length
15:47:35 <shachaf> You can keep a pointer to it or something if you know in advance.
15:47:44 * shachaf has been writing too much C++.
15:47:46 * hackagebot maccatcher 2.1.1 - Obtain the host MAC address on *NIX and Windows.  http://hackage.haskell.org/package/maccatcher-2.1.1 (JasonDusek)
15:47:48 <dons> halving is better done on non-linear structures (e.g. arrays / vectors)
15:47:50 <Botje_> hai: keep two pointers in the list, until the second reaches the end: advance first by 1 and second by 2
15:48:12 <Botje_> but you might as well just take the length and drop half 
15:48:49 <dons> its a weird operation to do on lists though
15:49:55 <zachk> o thanks for telling me its fractional :D 
15:50:06 <dino-> joeyh: YM record syntax? RWH has some info on it in Ch 3
15:50:19 <dcoutts_> dons: btw, met up with SPJ today, he was trying to remember some cabal feature you talked to him about. Recall what is was?
15:50:39 <dcoutts_> dons: he thought it wasn't cabal-dev, which was my first guess
15:50:46 <maurer_> You could always use a Seq and build up a buffer as you walk the list, and for every two items you walk you drop one off the buffer.
15:51:14 <maurer_> This would of course not be lazy, but would avoid multiple passes
15:51:38 <dons> dcoutts_: prob. cabal-dev, though i don't recall talking to SPJ about that.
15:51:48 <dons> dcoutts_: i spoke to simonmar about cabal-dev quite a bit
15:52:14 <dcoutts_> dons: ok
15:53:55 <Cale> @let secondHalf xs = fst . head . dropWhile (not . null . snd) . zip (tails xs) . iterate (drop 2) $ xs
15:53:56 <lambdabot>  Defined.
15:54:05 <Cale> > secondHalf [1,2,3,4,5]
15:54:07 <lambdabot>   [4,5]
15:54:32 <Cale> > secondHalf []
15:54:34 <lambdabot>   []
15:54:54 <Cale> > secondHalf [1..]
15:54:59 <lambdabot>   mueval-core: Time limit exceeded
15:57:58 <Cale> Still can't be lazy because this is fundamentally an operation which consumes the whole list spine, but still, using 'length' is admitting defeat ;)
15:58:28 <Cale> The first half is more interesting
15:58:43 * BMeph would use a Seq, just on "principle". ;)
15:59:30 <Cale> @let firstHalf xs = zipWith const xs . takeWhile (not . null) . iterate (drop 2) $ xs
15:59:35 <lambdabot>  Defined.
15:59:37 <Cale> > firstHalf [1..]
15:59:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:59:46 <Cale> > firstHalf [1..10]
15:59:48 <lambdabot>   [1,2,3,4,5]
15:59:50 <shachaf> hai: What are you actually trying to do?
16:00:56 <BMeph> Cale: Nicely done, Sir! :)
16:02:41 * BMeph would have held out for the "join ((. takeWhile (not . null) . iterate (drop 2)).zipWith const)" version, though...
16:12:01 * hackagebot piki 0.5.2 - Yet another text-to-html converter  http://hackage.haskell.org/package/piki-0.5.2 (KazuYamamoto)
16:24:55 <tehgeekmeister> why doesn't the pattern (a:b:[]) work?
16:25:24 <dons> work for what?
16:25:46 <monochrom> it works
16:25:48 <dons> Prelude> let f (a:b:[]) = b : a : []
16:25:49 <dons> Prelude> :t f
16:25:49 <dons> f :: [a] -> [a]
16:25:49 <tehgeekmeister> it doesn't even compile; i want to match a two element list
16:26:02 <dons> user error?
16:26:04 <monochrom> > case [(),()] of (a:b:[]) -> "success"
16:26:05 <lambdabot>   "success"
16:26:27 <monochrom> I can't reproduce your failure. what is your secret of success?
16:26:27 <tehgeekmeister> lemme check for typos
16:26:28 <Cale> tehgeekmeister: something else must be wrong
16:26:30 <dons> [a,b] would also have been accepted
16:26:30 <shachaf> You can also use [a,b].
16:26:41 <HugoDaniel> tehgeekmeister, use hpaste.org and show the code
16:26:46 <djahandarie> @quote Cale stereo
16:26:46 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
16:27:01 <HugoDaniel> ahaha, great quote :)
16:27:14 <monochrom> mine is even greater
16:27:21 <monochrom> @quote monochrom fugue
16:27:21 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
16:27:22 * shachaf wonders how Cale feels about that.
16:27:30 <HugoDaniel> :D
16:27:32 <dino-> I'll make a preliminary guess of non-exhaustive patterns
16:27:50 <HugoDaniel> tehgeekmeister, turn -Wall and use hlint
16:27:58 <HugoDaniel> warning because hlint can hurt your feelings :)
16:28:02 <Evious> I'm placing a bet on the heterogeneous list!
16:28:09 <Kaidelong> contrapuntal fugue is the same as point-counterpoint?
16:28:57 <pelotom> my money's on compiling with gcc instead of ghc
16:29:04 <djahandarie> lol
16:29:20 <tehgeekmeister> it was in a different part of that line, that error was.  d'oh.  mismatched paren.
16:29:35 * tehgeekmeister does penance for not checking his errors thoroughly enough before asking
16:29:51 <maurer_> tehgeekmeister: Turn on paren matching in your editor.
16:29:52 <Evious> Betting closed, nobody wins :(
16:30:13 <tehgeekmeister> maurer_: good idea.
16:30:32 <HugoDaniel> :)
16:30:44 <HugoDaniel> odds show that betting on parse errors is the way to go
16:30:52 <Kaidelong> hmm wait I think I get it now, contrapuntal fugue is where people would give two different answers that are both correct, simultaneously?
16:31:26 <monochrom> do you know fugue?
16:32:11 <shachaf> monochrom: I think #haskell would be more inclined to give you a Prelude.
16:32:46 <monochrom> "contrapuntal" there is redundantly added (fugues are contrapuntal) to match the pattern "adjective noun" such as "glorious stereo"
16:33:05 <Kaidelong> ah
16:33:06 <shachaf> s/glorious/majestic/
16:33:08 * hackagebot cab 0.0.1 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.0.1 (KazuYamamoto)
16:33:30 <pedro3005> hello people
16:33:34 <pedro3005> If I have something like:
16:33:34 <monochrom> fugue is a generalization of stereo, both in number of voices/parts and how they relate
16:33:37 <Kaidelong> from my understanding it is where you have two melodies going simultaneously such that it is not dissonant
16:33:41 <pedro3005> add :: (Num a) => Lisp a -> Lisp a -> a
16:33:42 <pedro3005> add (Lisp a) (Lisp b) = a + b
16:33:52 <pedro3005> that's kind of what monads are for, isn't it?
16:34:03 <Kaidelong> is it?
16:34:05 <monochrom> stereo is so boring after you have experienced Bach fugues
16:34:20 <pedro3005> I don't know, that's why I'm asking
16:34:25 <Kaidelong> pedro3005: If you have Lisp (Lisp a) -> Lisp a, then you should make a monad
16:34:31 <Kaidelong> by all means
16:34:45 <Kaidelong> you also need (a -> b) -> Lisp a -> Lisp b and a -> Lisp a
16:34:54 <Kaidelong> but I presume you have those
16:35:05 <monochrom> and after Mozart opera fugues, dolby 7.1 is such a joke.
16:36:44 <Kaidelong> instance Monad Lisp where { Lisp x >>= y = y x ; return = Lisp }
16:37:40 <Kaidelong> instance Functor Lisp where { fmap f (Lisp x) = Lisp (f x) }
16:38:07 <pedro3005> what does >>= do?
16:38:23 <napping> that's the bind operator in the class
16:38:29 <Kaidelong> instance Applicative Lisp where { Lisp x <*> Lisp y = Lisp (x y); pure = Lisp }
16:38:34 <Evious> :t (>>=)
16:38:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:38:39 <Kaidelong> those are the three instances you should make
16:39:45 <Evious> Looks like >>= takes a monad, and somehow applies a function inside it.
16:40:05 <Kaidelong> >>= takes a monad, and a kleisi arrow...
16:40:09 <Evious> The result is still a monad, so you could chain >>= indefinitely.
16:40:17 <monochrom> >>= is what you get from do-notation.
16:40:21 <Kaidelong> well that's the basic idea
16:40:29 <monochrom> @undo do { x<-m; k x }
16:40:30 <lambdabot> m >>= \ x -> k x
16:40:40 <aristid> Evious: and the "somehow" is defined by the instance. it can do basically anything, as long as it follows the "laws"
16:41:03 <Evious> It's fascinating how the only way to describe monads seems to be via fugue.
16:41:15 * Evious waits patiently for a packaged food analogy.
16:41:31 <napping> http://imgur.com/esdQM
16:41:40 <monochrom> monad is like wheat. you eat it without knowing.
16:41:48 <pedro3005> :t <*>
16:41:49 <lambdabot> parse error on input `<*>'
16:41:54 <monochrom> haha napping wins
16:41:56 <Kaidelong> @ty (<*>)
16:41:56 <Evious> :t (<*>)
16:41:56 <pedro3005> :t (<*>)
16:41:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:41:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:41:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:42:38 <pedro3005> hm I don't understand that
16:43:00 <Kaidelong> > Just (+) <*> Just 5 <*> Just 6
16:43:02 <lambdabot>   Just 11
16:43:08 <Kaidelong> > Just (+) <*> Just 5 <*> Nothing
16:43:10 <lambdabot>   Nothing
16:43:11 <monochrom> <*> and ap do the same thing if you have a monad.
16:43:13 <monochrom> @type ap
16:43:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:43:39 <Kaidelong> fmap = liftM
16:43:42 <Kaidelong> (<*>) = ap
16:43:57 <Kaidelong> although you might have more efficient implementations for them
16:44:15 <Kaidelong> pure = return too
16:44:31 <napping> More importantly, your type might be applicative without being a monad
16:44:52 <Evious> pedro3005, have you seen the Typeclassopedia article in the Monad Reader? #13, I think.
16:44:58 <napping> For A to be applicative, you have to have some way to apply an A of functions to an A of values, but not necessarily be able to bind them
16:45:06 <pedro3005> Evious, No, not yet
16:45:18 * Kaidelong thinks that things might be clearer if contexts were inferred rather than given explicitly; people would understand that (B a) => a is actually the same type as (C a) => a
16:45:24 <napping> parsers are the main example
16:45:34 <napping> the first that comes to mind, rather
16:45:40 <Evious> It goes over the commonly seen types, building up from simple ones up to monads. It may give some context :)
16:45:47 <Kaidelong> and you should always be able to infer it from the code unless there are weird type level hacks you can do with contexts
16:46:09 <c_wraith> Kaidelong: like ~ ?
16:46:25 <Kaidelong> is that something you can do to mess with this?
16:46:26 <c_wraith> admittedly, ~ still doesn't work..  but it's been documented for 3 versions of ghc!
16:46:42 <c_wraith> 3 major versions, I should say.
16:47:03 <c_wraith> I guess you could infer that ~ was necessary, but it would also make the type checker's error messages even dumber
16:47:14 <monochrom> a sign of microsoftism :)
16:47:29 <c_wraith> "this is either a type error, or you need a ~ context! I can't tell which!"
16:47:31 <napping> c_wraith: what do you mean it doesn't work?
16:47:31 <stianhj> Anyone use Vim? Are there any plugins that'll let you do indent cycling like haskell-mode in Emacs?
16:47:36 <Kaidelong> it just seems silly to me to make you A) write a bunch of contexts and B) hide the ambiguity of types that differ only by context
16:48:12 <Kaidelong> and for extensions like overlapping instances where you actually need them you can require them
16:48:24 <napping> :set -XTypeFamilies, and you can let f :: (a ~ Int) => a -> Int -> a; f = (+) if you like
16:48:27 <c_wraith> napping: ~ contexts don't seem to work properly with type families in the latest release GHC
16:48:49 <c_wraith> what about contexts like (F a ~ G a b) ?
16:49:14 <napping> I don't usually bother with stuff like that
16:49:30 <c_wraith> That's where equality constraints are really useful...
16:49:36 <c_wraith> When you couldn't fill it in otherwise
16:52:49 * ickabob
16:53:33 <tehgeekmeister> does << really not exist?
16:53:44 <Kaidelong> @ty (<<)
16:53:45 <lambdabot> Not in scope: `<<'
16:53:46 <tehgeekmeister> hoogle doesn't believe it does.  that seems weird, considering =<< exists.
16:53:50 <shachaf> @ty (<*)
16:53:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
16:53:54 <Kaidelong> that is strange
16:54:03 <Kaidelong> well nobody is going to maim you if you define it
16:54:08 <Kaidelong> (<<) = flip (>>)
16:54:12 <shachaf> Or you could just use (<*).
16:54:33 <Kaidelong> shachaf: Unless someone was naughty and did not define applicative
16:54:43 <Kaidelong> although in that case he could define it I guess!
16:54:47 <shachaf> Kaidelong: We don't talk about cases like that in here.
16:55:06 <tehgeekmeister> Kaidelong: oh.  right.
16:55:09 <Kaidelong> I think it happens in practice with a lot of haskell library code unfortunately, though
16:55:27 <shachaf> tehgeekmeister: Where do you actually want to use (<<)?
16:55:35 <shachaf> Kaidelong: Yes, exactly: "in practice".
16:55:57 <monochrom> you hurt applicative's feeling :)
16:57:58 <Kaidelong> that is an interesting username to have in a haskell channel...
16:58:00 <tehgeekmeister> shachaf: result <- fetchRow statement << execute statement [toSql email] 
16:58:36 <shachaf> Kaidelong: Which?
16:58:40 <shachaf> Oh.
16:58:53 * shachaf missed that.
16:59:18 <Kaidelong> do { execute statement [toSql email] ; result <- fetchRow statement } should have the same effect, shouldn't it?
16:59:45 <shachaf> Yep.
17:00:43 <Kaidelong> I guess it is not actually the same
17:00:51 <Kaidelong> or I cannot think of why it would be
17:00:57 <Kaidelong> but it should be true here
17:01:18 <napping> Does ByteString expose a fast way to mapM_ over the bytes?
17:02:35 <shachaf> Kaidelong: (exec >> fetch) >>= f should be the same as exec >> (fetch >>= f) by the monad laws, no?
17:02:45 <Kaidelong> @hoogle (a -> m b) -> ByteString -> m ()
17:02:46 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
17:02:46 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
17:02:46 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
17:03:05 <Kaidelong> @hoogle (a -> b) -> ByteString -> d
17:03:06 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
17:03:06 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
17:03:06 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
17:03:50 <Kaidelong> shachaf: oh yeah, that is right, I was thinking distributivity was what would be needed, but associativity works in that case
17:08:36 <Kaidelong> @ty \f -> ByteString.foldl (\a b -> (f b >> a)) (return ())
17:08:37 <lambdabot> Couldn't find qualified module.
17:08:48 <Kaidelong> @ty \f -> foldl (\a b -> (f b >> a)) (return ())
17:08:49 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (b -> m a) -> [b] -> m ()
17:09:16 <Kaidelong> napping: perhaps that could work for you
17:10:08 <Kaidelong> basically it's just mapM_ implemented as a fold
17:11:33 <Kaidelong> (good exercise to go over would be implementing stuff like map, mapM, mapM_, etc, as folds. Also implementing foldr in terms of foldl and vice versa.)
17:12:49 <McManiaC> can you get this to work? http://npaste.de/00B/ it fails with: "foo.hs:4:0:  error: missing binary operator before token "(""
17:13:45 <pumpkin> gah
17:13:49 <McManiaC> or is there a way to test for the ghc version?
17:13:54 <McManiaC> via cpp conditionals
17:14:03 <napping> Kaidelong: that's kind of slow
17:14:30 <napping> well, at least if the work you are doing is itself not very expensive
17:14:56 <lispy> I'm sort of surprised we don't have wordsBy or splitBy in Data.List
17:14:58 <Kaidelong> napping: That's a shame then. It shouldn't be really, since foldl should be strict for byte strings
17:15:10 <napping> well, for lazy bytestrings
17:15:12 <Kaidelong> IF I am reading these docs correctly
17:15:23 <lispy> oh, splitOn in Data.List.Split looks right
17:15:25 <lispy> :t splitOn
17:15:26 <lambdabot> Not in scope: `splitOn'
17:15:42 <Kaidelong> are lazy bytestrings strict in their elements?
17:15:44 <napping> Also, the implementations are based on unsafePerformIO of a loop that runs over a strict bytestring, buidling up an accumulating parameter
17:16:13 <napping> In practice it seems to help a lot to actually write specialized versions of mapM_ that can combine the sequencing of your actions and of the pointer access
17:16:45 <napping> it's done with a ForeignPtr, so I'm not sure if it would work well to turn it inside out and have the fold make many unsafePerfomIO'd "values" that read from the array
17:17:05 <Kaidelong> well then implement mapM_ yourself for that then?
17:17:08 <lispy> byorgey++
17:17:16 <Kaidelong> it seems like a bit of a "bug" that using the fold will be slow
17:17:30 <Kaidelong> since byte strings are supposed to be strict
17:17:33 <napping> Fold is plenty fast if you are actually folding a value combining function
17:17:58 <napping> but when you fold something involving >> it seems that it actually builds up the IO action in memory
17:18:28 <Kaidelong> I see, mm, I guess that makes some kind of sense
17:18:34 <Kaidelong> even if the accumulator is strict
17:18:45 <Kaidelong> an IO action is not neccessarily "run" when it is evaluated
17:18:49 <napping> folding something like (+) is pretty fast, if useless
17:20:45 <parcs> does ghc perform any arithmetic optimizations?
17:20:54 <Kaidelong> in which case you'd have to do something like "mapM_ f b = if null b then return () else do {f (head b) ; mapM_ f (tail b) }"
17:24:40 <QinGW> What is the different *typeclass* of haskell with the *interface* of java? And *instance foo a* with the implements class of java?
17:26:43 <c_wraith> QinGW: typeclasses aren't types.  Interfaces are types.  Interfaces are much less flexible than typeclasses.  But as a first approximation, they're similar.
17:29:10 <pelotom> QinGW: another difference is thaat types can be made members of a type class outside of the type's definition, whereas a java class must be declared to implement a certain interface at its definition site
17:30:06 <ubuntu_warrior> 
17:30:11 <napping> also, interfaces can't describe binary methods whose arguments are the same instance
17:32:00 <pelotom> there are a lot of things interfaces can't describe
17:34:39 <jfischoff> what are the pros of java interfaces compared to haskell type classes?
17:34:50 <napping> pros?
17:35:03 <pelotom> jfischoff: none that I can think of
17:35:06 <napping> I guess they come with a predefined type version
17:35:45 <kevinww_> I found that one good thing about OOP is classes and interfaces automatically give a namespace to the methods
17:35:59 <pelotom> jfischoff: scala's traits + implicits, however, are slightly more powerful than type classes, since they're first class
17:36:17 <pelotom> allowing you to override the type class instance explicitly
17:37:00 <napping> It is minimal
17:37:10 <napping> wrong channel.
17:37:29 <jfischoff> maybe there aren't any, but I find using interfaces easier for achieving things like a collection of renderables that all have a different render method
17:37:56 <pelotom> jfischoff: what's easier about it?
17:38:10 <jfischoff> existial types can be used, but I find that is more work, like herehttp://www.haskell.org/haskellwiki/Existential_types#Expanded_example_-_rendering_objects_in_a_raytracer
17:38:17 <jfischoff> personal preference I guess
17:38:38 <jfischoff> or maybe I just don't know the right way
17:38:52 <jfischoff> I will agree to either :)
17:39:56 <jfischoff> hey conal
17:39:59 <pelotom> jfischoff: ah, a collection of them... yeah, that's a bit trickier I guess
17:40:10 <jfischoff> that's the only real downside
17:40:14 <jfischoff> I can see
17:41:08 <conal> jfischoff: hey there. nice to see you here.
17:41:08 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
17:41:27 <pelotom> jfischoff: do you really need to define completely unrelated types for your Renderable though? couldn't they all be one algebraic datatype?
17:42:12 <augur> conal! \o/
17:42:17 <jfischoff> peletom: then you would have to define them in one place, so you could have a third party extend an api
17:42:19 <conal> augur: :)
17:42:36 <jfischoff> conal: thanks :)
17:42:54 <pelotom> jfischoff: true, the expression problem strikes again :)
17:43:06 <jfischoff> pelotom:totally
17:43:31 <napping> jfischoff: you need polymorphic variants
17:43:47 <napping> or whatever the dual to extensible records is called
17:43:48 <jfischoff> napping: do we have those?
17:44:01 <napping> no, somebody needs to organize a midnight raid on O'Caml
17:44:08 <shachaf> jfischoff: You could store a record of values/functions instead of values that must have type class functions applied to them.
17:44:18 <shachaf> Depending on how complicated your type class is.
17:44:22 <napping> maybe we would make off with parameterized modules while we are at it :)
17:45:39 <jfischoff> shachaf: good point, that works.
17:46:14 <napping> jfischoff: MLPolyR has a nice simple presentation of them
17:55:09 <jfischoff> napping: cool I'm checking it now
18:03:48 <pumpkin> preflex: seen tibbe
18:03:49 <preflex>  tibbe was last seen on #ghc 4 days, 10 hours, 20 minutes and 27 seconds ago, saying: dcoutts, will only have minimal email access
18:03:58 <pumpkin> @ask tibbe any idea what's going on with the array copy primops?
18:03:58 <lambdabot> Consider it noted.
18:05:35 <kniu> do the profiling versions of libraries have worse performance than the non-profiling versions?
18:06:13 <kniu> And what does the "Vanilla" option in .cabal/config mean?
18:06:46 <dcoutts_> kniu: it refers to libraries, as opposed to profiling libs
18:06:50 <dcoutts_> we should rename it really
18:12:32 <thoughtpolice> anybody on linux/os x who want to test something for me? i'm getting a segfault with ghc 7.0.2 using the reflection package on windows, and that's bad naturally :)
18:12:56 <thoughtpolice> (anybody with OS X/linux, or ghc 6.12 that is. cannot be sure if it's a regression, or a windows only thing)
18:13:15 <thoughtpolice> edwardk: ping since you'd be interested too, i'm sure
18:15:24 <luite> what's the code?
18:16:19 <luite> I run 32 bit by the way, is that ok?
18:17:07 <thoughtpolice> luite: sure
18:17:15 <thoughtpolice> luite: just a sec
18:17:43 <thoughtpolice> luite: cabal install reflection, then https://gist.github.com/870196
18:18:05 <thoughtpolice> luite: ghc7, or ghc 6.12?
18:18:09 <luite> 7.0.2
18:18:39 <thoughtpolice> k, i guess it's possible windows is bugged. i also speculate that perhaps reflection broke in some subtle manner, just don't know how
18:19:58 <luite> runhaskell Reflect.hs prints nothing, a compiled binary segfaults
18:20:57 <thoughtpolice> dun dun dun
18:21:00 <luite> this is with reflection-0.3.1 (and ghc 7.0.2 32 bit)
18:21:06 <thoughtpolice> guess i should bug edwardk when he's around
18:21:09 <thoughtpolice> luite: thanks a lot!
18:21:39 <luite> np :)
18:23:04 <luite> oh and I use linux
18:29:03 <smarmy> ghc 6.12.3, 7.0.1, and 7.0.2 on ubuntu 10.10 x64.... no seg fault
18:42:41 * hackagebot silently 0.0.3 - Prevent or capture writing to stdout and other handles.  http://hackage.haskell.org/package/silently-0.0.3 (TrystanSpangler)
18:54:15 <QinGW> What is binary methods?
18:57:41 <Axman6> QinGW: in relation to what?
19:09:28 <QinGW> Axman6: napping told me:" also, interfaces can't describe binary methods whose arguments are the same instance" when I asked what the difference interfaces of java with typeclasses of haskell.
19:11:00 <QinGW> Axman6: I have googled this, but I can't find the detail.
19:20:57 <Axman6> @hoogle rnf
19:20:57 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
19:22:45 <smarmy> qingw: napping in particular was referring to methods of two arguments where the arguments had the type of the interface itself
19:23:18 <smarmy> qingw: and was saying that java doesn't let you enforce that the two arguments in fact be the same underlying class when the method is invoked
19:23:34 <Axman6> damn you hoogle for being wrong
19:23:43 <Axman6> rnf is in Control.DeepSeq
19:35:30 <monochrom> "binary method" means 2-ary functions
19:38:18 <monochrom> sometimes the implicit emphasis is on the type: the 2 parameters have to be of the same type.
19:50:48 <killing-joke> http://cdsmith.wordpress.com/2011/03/13/haskells-niche-hard-problems/
19:52:40 <astory> Do I have to do anything special to get Data.MemoCombinators to work on functions of more than one input?
19:53:03 <astory> specifically, I'm implementing a dynamic programming algorithm over a 2-d table
19:53:40 <kmc> nothing special -- you'll need to build a value of type 芦Memo (A -> B -> C)禄
19:53:54 <kmc> err sorry
19:54:14 <kmc> two values of type (Memo A) and (Memo B) respectively
19:54:17 * kmc forgot how it works
19:54:27 <kmc> C (the return type) doesn't come into it
19:54:37 <kmc> anyway that's what memo2 is for
19:54:44 <kmc> if you want to see if/when your function is being evaluated, you can use Debug.Trace
19:54:46 <astory> aha!
19:54:50 <astory> I didn't see that
19:57:13 <astory> hrm, I'm still not sure how to use this, why does memo2 take Memo objects and the function?
19:58:14 <astory> ohhh
19:58:30 <astory> so if I have fun a b -> c, I'd do memo2 integral integral fun ?
19:59:05 <kmc> yeah
19:59:13 <astory> ok, I think I get it now, thanks!
19:59:44 <kmc> for each argument you give a Memo value which describes how to memoize it
19:59:56 <astory> yeah, that makes total sense.
20:02:18 * Axman6 attempts to install threadscope...
20:02:29 <kmc> astory, you can equivalently write:  integral (\x -> integral (fun x))
20:02:39 <kmc> (or various points-free variations on that)
20:02:47 <kmc> because a two-argument function is a one-arg function that returns one-arg functions
20:02:57 <astory> yeah, but I think that's unnecessarily obsucatory
20:03:00 <astory> obfuscatory*
20:03:02 <kmc> agreed
20:03:15 <astory> point-free can be good, but it can also be horrendous
20:03:33 <kmc> yeah
20:03:37 <kmc> well what i wrote wasn't points-free
20:03:44 <kmc> but it's still a lot less clear than using memo2
20:03:46 <astory> well yes
20:05:00 <djahandarie> @pl \integral -> integral (\x -> integral (fun x))
20:05:00 <lambdabot> ap id (. fun)
20:05:44 <djahandarie> @type (ap id (. fun), \integral -> integral (\x -> integral (fun x)))
20:05:45 <lambdabot> forall b t. (SimpleReflect.FromExpr b, SimpleReflect.FromExpr (String -> t)) => (((String -> b) -> b) -> b, ((String -> t) -> t) -> t)
20:06:12 <djahandarie> @type (ap id (. f), \integral -> integral (\x -> integral (f x)))
20:06:13 <lambdabot> forall b (f :: * -> *) t t1. (SimpleReflect.FromExpr (f (f b)), Functor f, SimpleReflect.FromExpr (t -> t -> t1)) => ((f b -> b) -> b, ((t -> t1) -> t1) -> t1)
20:06:29 <djahandarie> Screw it!
20:06:54 <kmc> :t ?omg ?wtf ?bbq
20:06:55 <lambdabot> forall t t1 t2. (?bbq::t1, ?wtf::t, ?omg::t -> t1 -> t2) => t2
20:07:25 <djahandarie> Ah right
20:07:37 <djahandarie> @type (ap id (. ?f), \integral -> integral (\x -> integral (?f x)))
20:07:38 <lambdabot> forall b t. (?f::t -> t -> b, Functor ((->) t)) => (((t -> b) -> b) -> b, ((t -> b) -> b) -> b)
20:07:40 <Axman6> :t let foo x = ?y + x in f
20:07:41 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
20:07:42 <Axman6> :t let foo x = ?y + x in foo
20:07:43 <lambdabot> forall a. (Num a, ?y::a) => a -> a
20:08:36 <kmc> :t \i j m f -> m (f . i) . j
20:08:37 <lambdabot> forall a b (f :: * -> *) a1 b1 (f1 :: * -> *). (Functor f, Functor f1) => f a -> f1 a1 -> (f b -> a1 -> b1) -> (a -> b) -> f1 b1
20:09:43 <Axman6> hmm, maybe installing a ner version of Xcode while ghc's compiling isn't a good idea, i might wait...
20:09:46 <Axman6> new*
20:11:26 <geheimdienst> then again, since xcode takes more than elebenty minutes to install, chances are it wouldn't even get to interfering with ghc ...
20:14:43 <QinGW> Has anyone built hoogle on local web server?
20:15:33 <QinGW> Because I have no cable at home.
20:16:03 <astory> QinGW: http://www.haskell.org/haskellwiki/Hoogle#Developers might be helpful
20:16:26 <geheimdienst> qingw, the hoogle command line tool is easy to install and does almost the same job
20:18:41 <QinGW> Thanks astory, geheimdienst
20:18:57 <Axman6> QinGW: there's a command line tool for it
20:22:23 <mkscrg> Is there a precedent for the naming of executables (Main modules)? For ex: perhaps they're not capitalized, to differentiate from other modules
20:25:09 <geheimdienst> mkscrg: i believe in your project's .cabal file, you can say "Main-is: Foo" to set the main module
20:28:05 <Cale> mkscrg: There's no particular convention, but that works.
20:28:29 <mkscrg> Cale: thanks
20:29:02 <mkscrg> geheimdienst: I meant the actual source files that declare "module Main ( main ) where ..."
21:04:58 <kisielk_home> if I have a function that needs to process two strings which are of equal length, how do I enforce that?
21:05:30 <shachaf> kisielk_home: In the type system?
21:05:54 <kisielk_home> well, either with the type system or some other method
21:06:15 <kisielk_home> in another language I might use assertions or something of the like
21:08:24 <kmc> what should it do if they aren't the same length?
21:08:39 <kmc> kill the program with an error message?
21:09:10 <kmc> http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/assertions.html
21:10:05 <copumpkin> you can build a string type that contains a type-level length
21:10:10 <copumpkin> but that's tricker to use than you might expect
21:10:53 <rwbarton> how about [(Char, Char)]
21:11:41 <shachaf> It depends on the type of function you're trying to write.
21:11:47 <copumpkin> rwbarton wins
21:12:04 <rwbarton> of course producing the [(Char, Char)] is now someone else's problem
21:12:05 <shachaf> In some cases it makes sense to make that function more general, and check for length-equality elsewhere.
21:12:11 <shachaf> But, yes, rwbarton++ :-)
21:12:12 <rwbarton> but at least you present them with the problem to be solved
21:12:22 <kisielk_home> this is a simple function for computing the hamming distance 
21:12:34 <kisielk_home> it doesn't really make sense for strings not of equal length
21:12:54 <kmc> kisielk_home, you can write it with two cases like 芦foo [] (_:_) = error "first string too short"; foo (_:_) [] = error "second string too short"禄
21:13:10 <kmc> or just leave out those cases and get an unhelpful "Pattern match failure" error
21:13:22 <copumpkin> odd to think of the kinds of constraints you can represent implicitly that way. [(x, x)] means you have two [x] of same length, and [Either x x] means you have two [x] whose lengths sum to the outer length
21:14:05 <kisielk_home> kmc, right, that's what I'm at right now
21:14:19 <kisielk_home> I'm just trying to figure out what is the "right thing" to do in this case
21:15:09 <ddarius> copumpkin: I believe such things can be relatively easily derived with the theory of species.
21:15:21 <accel> is there a ahskell dsl for describing javascript pages?
21:16:35 <copumpkin> ddarius: ah yeah
21:17:00 <ddarius> You may also find Hinze's "Manufacturing Datatypes" interesting.
21:17:47 <copumpkin> thanks
21:18:40 <Boxo> Oh man, (Either a a) = (a, Bool), just like a+a = a*2
21:20:20 <ddarius> Boxo: Up to isomorphism, most of the normal rules of ("high school") algebra hold.
21:20:31 <kmc> also up to ignoring 
21:20:53 <ddarius> It's even possible to start defining things like subtraction and division, though that takes a bit of care.
21:21:03 <Boxo> What about fractions?
21:21:03 <kmc> and derivatives!
21:21:09 <shachaf> ddarius: How does one define those?
21:21:26 <Boxo> division, fractions, doh
21:22:05 <shachaf> (a^2)/2 would correspond to an unordered pair, I suppose?
21:22:07 <shachaf> Whatever that is.
21:22:10 <Boxo> I tried to read McBride's one-hole paper but it was pretty incomprehensible
21:23:41 <yangli> 42,13,22
21:23:58 <copumpkin> shachaf: just a guess, but maybe quotients in the usual sense
21:24:04 <copumpkin> well, equivalence relation sense
21:24:19 <ddarius> shachaf: That's where the theory species comes in, but you can see such things from [a] = 1 + a + a^2 + ..., which is 1/(1-a).
21:24:25 <copumpkin> I've manipulated types to get lists
21:24:40 <ddarius> shachaf: And yes, an unordered pair would be a quotient type.
21:25:06 <shachaf> And its derivative would just be a, I suppose.
21:25:24 <ddarius> One way of viewing it is that a function {A,A} -> X is a function (A,A) -> X that must be commutative.
21:25:52 <shachaf> That makes sense.
21:26:00 <ddarius> shachaf: Yep, since you don't need to remember which component it was.
21:26:31 <shachaf> Where would one read more about this?
21:27:22 <ddarius> shachaf: Brent Yorgey has some good talks on species and references to other good resources.  The Bergeron book is quite good.
21:29:13 <BobFunk> getting a segmentation fault when trying to do a put request with the haskell libcurl bindings
21:29:26 <shachaf> Hmm, that's an expensive book.
21:29:41 <kmc> BobFunk, i think there's some "initialize curl" function/action you have to use first
21:29:45 <kmc> did you do that?
21:29:51 <BobFunk> yeah
21:30:03 <kmc> (it's poor API design that this isn't enforced by the types)
21:30:18 <shachaf> Ah, on the other hand, they have it at the library here. Though I wouldn't be able to check it out.
21:30:30 <BobFunk> this is the code im experimenting with: https://gist.github.com/870344
21:30:33 * shachaf will look into byorgey's talks.
21:31:00 <BobFunk> two curl calls though, so don't know if I need to initialize twice
21:31:14 <BobFunk> the examples I've found from the wiki didn't do that, though
21:33:00 <BobFunk> the first get request works fine, but the put request segfaults
21:33:03 <tehgeekmeister> i'm trying to use ghc -ddump-simpl to inspect how some code compiles, but i get no output (aside from the usual files being written.)
21:33:13 <tehgeekmeister> what might i be missing?
21:33:39 <kmc> try the ghc-core utility from hackage
21:36:56 <tehgeekmeister> i could not parse its output at all.  is it the same as -ddump-simpl?  do I just need to read up on that output more?
21:37:47 <BobFunk> any tips on going about figuring out what's behind a segfault from the curl bindings?
21:40:48 <BobFunk> seems to be as soon as I supply a file to upload
21:44:37 <c_wraith> BobFunk: I don't trust those bindings.  I've seen *far* too many segfaults out of them.  try the http-enumerator package.
21:45:41 <BobFunk> c_wraith: was my first choice, but seems really hard to get it to do a chunked upload over a put request
21:45:58 <BobFunk> c_wraith: at least I didn't see how to easily do that
21:46:05 <c_wraith> BobFunk: is chunked important?
21:46:37 <BobFunk> c_wraith: not loading the whole file in memory is important - and from the test I did with http-enumerator it seemed to be doing that
21:47:23 <c_wraith> BobFunk: how were you setting the request body?
21:47:35 <BobFunk> let me check
21:48:13 <BobFunk> was passing a lazy bytestring to httpLbs
21:48:27 <c_wraith> Hmm.  It really shouldn't have been loading that in one shot
21:50:34 <BobFunk> will make a simpler test with http-enumerator to see - the current code I have with that is part of a snap based web server - will try with just the upload itself, like my curl based code and see
21:56:48 <tehgeekmeister> how do i get ghc to output the core versions of prelude functions (in this case zipwith), instead of just references to zipwith, etc?
21:57:02 <tehgeekmeister> or are those not all implemented in haskell?
21:57:08 <copumpkin> they are
21:57:37 <ddarius> There's absolutely no reason to build zipWith in.
21:57:38 <copumpkin> but it can be a pain to get core versions of them, since most of the time you aren't compiling them
21:57:51 <ddarius> shachaf: I said that [a] = 1 + a + a^2 + ..., and you said that a^2/2 should be an unordered pair, and I said that's like requiring all functions on them to be commutative, which is to say, f (x,y) = f (y,x).
21:58:30 <ddarius> shachaf: So, what is Sum_n (a^n/n!), what's it's derivative, and what's an expression to summarize it (the sum)?
21:58:38 <ddarius> (And why)
21:59:04 <copumpkin> interesting
21:59:18 <tehgeekmeister> yeah, i know there's not any reason to.  i'm just curious what it compiles down to, and i don't want to look at assembly.
21:59:38 <copumpkin> tehgeekmeister: it compiles down to several intermediate representations, not just core
21:59:51 <copumpkin> but like core, they're all rather hard to get your hands on since most of the time you aren't compiling it
21:59:52 <tehgeekmeister> really what i'm trying to figure out is if the canonical zipWith implementation of fibs runs in constant memory or not.
22:00:16 <copumpkin> constant memory assuming integers not growing
22:00:19 <shachaf> ddarius: Hmm, that would be e^x, so its own derivative?
22:00:25 <tehgeekmeister> yeah, that.
22:00:47 <tehgeekmeister> i want to understand why this is, too.  it was my intuition, but i want to understand it more deeply.
22:01:17 <copumpkin> tehgeekmeister: I think abstract reasoning about the evaluation model of haskell will help more than GHC's concrete implementation
22:01:35 <ddarius> shachaf: That's the easier part (assuming you have a background in infinite series), now what does e^x represent as a data type and why does this series suggest it, and why is the derivative intuitively the data type represented by e^x?
22:01:55 <tehgeekmeister> copumpkin: i think you're right, which is why i changed tack and mentioned that.  where's best to read up more on that, anyone know?
22:02:06 <copumpkin> tehgeekmeister: not actually sure :P
22:02:20 <shachaf> Which would be {} | {a} | {a,a} | {a,a,a} | ..., I guess. An unordered set?
22:02:34 <shachaf> Or, rather, a bag?
22:02:47 <shachaf> Hmm.
22:03:12 <ddarius> tehgeekmeister: Just do call-by-need reduction.  Probably the easiest way to do this is to introduce a let expression when you need to remember sharing.
22:03:38 <dolio> Bag is right, I believe.
22:03:41 <ddarius> E.g. to take Cale's usual example, double x = x + x, double (double 2) -> let x = double 2 in x + x.
22:03:48 <copumpkin> bag is what I would have guessed
22:04:07 <copumpkin> not sure how the e^ part comes into that, or what it corresponds to in discreteland
22:04:12 <ddarius> dolio, shachaf: Well, consider the simpler {a,a} case.  Is this a 2-element bag or a 2-element set?
22:04:21 <shachaf> Bag.
22:04:40 <shachaf> Or, hmm.
22:05:22 <shachaf> The "a"s can be the same value.
22:05:23 <tehgeekmeister> my intuition was that since only the n-1th and n-2th elements are necessary to provide the nth element of the list, those are the only ones that will ever be in memory (aside from the first and second, since those are part of the definition.)
22:05:37 <shachaf> a(a-1)/2 would represent a two-element set, i guess?
22:06:01 * shachaf wonders what e would mean, as a type. "Bag ()"?
22:06:03 <tehgeekmeister> if it wasn't implemented that way, that would be problematic given how often infinite lists are used in haskell
22:07:00 <dolio> {} | {()} | {(),()} | ...
22:07:22 <shachaf> If it's a bag, {(),()} is a confusing notation.
22:08:34 <shachaf> s/ i / I / , by the way.
22:09:16 <dolio> Anyhow, depending on what you want to do with them, Bag a = a -> Nat.
22:09:42 <dolio> And Bag () = () -> Nat ~ Nat.
22:09:53 <copumpkin> Bag is Stream backwards!
22:10:05 <dolio> Which is also what the union of the unordered pairs of ()s gets you.
22:10:12 <dolio> Er, unordered tuples.
22:10:14 <geheimdienst> > reverse "Bag"
22:10:15 <lambdabot>   "gaB"
22:10:18 <shachaf> e^1 = Nat?
22:10:19 <geheimdienst> no it isn't
22:10:58 <copumpkin> > reserve "bag" == "stream"
22:11:00 <lambdabot>   True
22:11:02 <shachaf> I guess it makes sense that a bag with a whole in it is a bag with one element fewer...
22:11:05 <copumpkin> man, I was right
22:11:19 <geheimdienst> reserve, eh?
22:11:30 <copumpkin> pff
22:11:32 <Boxo> > reserve "heh"
22:11:34 <lambdabot>   "*Exception: <local>:9:0-23: Non-exhaustive patterns in function reserve
22:11:47 <Boxo> > reserve "bag"
22:11:48 <lambdabot>   "stream"
22:11:57 <Boxo> > reserve "b"
22:11:59 <lambdabot>   "*Exception: <local>:9:0-23: Non-exhaustive patterns in function reserve
22:12:05 <mzero> @src reserve
22:12:05 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
22:12:22 <mzero> > reserve "table"
22:12:23 <lambdabot>   Not in scope: `reserve'
22:12:25 <shachaf> > revers械 "Bag" -- Amateur.
22:12:27 <lambdabot>   "Stream"
22:12:36 <Axman6> o.O
22:13:11 <kmc> > "revers械"
22:13:12 <lambdabot>   "revers\1077"
22:13:14 <Axman6> > reverse "Dog"
22:13:15 <lambdabot>   "goD"
22:13:31 <shachaf> Does e really correspond to Nat?
22:13:45 <kmc> bankofam械rica.com
22:14:02 <shachaf> > "<kmc> bankofam械rica.com"
22:14:04 <lambdabot>   "<kmc> bankofam\1077rica.com"
22:14:30 <copumpkin> that's pretty sneaky :)
22:14:30 <kmc> aka xn--bankofamrica-zck.com
22:14:37 <kmc> i think there are rules against registering such domains
22:16:48 <dolio> shachaf: You didn't believe the derivations we just went through? :)
22:16:56 <copumpkin> > 械ither (+1) (*5) (Left 6)
22:16:58 <lambdabot>   No, fuck you. I'm through with these menial tasks you make me do every day....
22:17:19 <shachaf> dolio: They relied a fair amount on hand-wavey intuition as far as I'm concerned. :-)
22:17:56 * copumpkin invites shachaf to #agda
22:18:14 <copumpkin> agda doesn't appreciate hand waving either
22:18:30 <BobFunk> c_wraith: tried the http-enumerator with a lazy bytestring, and does load it all in memory it seems :(
22:18:33 <BobFunk> https://gist.github.com/870344
22:21:10 <co_dh> who made lambdabot say fuck u? 
22:21:40 <co_dh> > either (+1) (*5) (Left 6)
22:21:41 <lambdabot>   7
22:21:45 <co_dh> :t either
22:21:46 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
22:21:59 <copumpkin> co_dh: I don't think it likes me :(
22:22:10 <co_dh> lol
22:22:12 <copumpkin> > 械ither (^3) (+1) (Right 6)
22:22:14 <lambdabot>   No, fuck you. I'm through with these menial tasks you make me do every day....
22:22:34 <co_dh> > either (+1) (*2) (Right 6)
22:22:35 <lambdabot>   12
22:22:40 * shachaf finds it amusing that you people are all using the same fake 'e' that he provided.
22:22:48 <shachaf> There
22:23:15 <Boxo> > either (^3) (+1) (Right 6)
22:23:16 <lambdabot>   7
22:23:26 <shachaf> 's more where that came from, you know. , 邪, 芯, .
22:23:28 <co_dh> lol, does somebody modified lambdabot ? 
22:23:33 <c_wraith> BobFunk: what version of http-enumerator are  you using?  That doesn't look right by the docs I'm looking at
22:23:52 <copumpkin> > s芯rt [1,5.2,6,7]
22:23:54 <lambdabot>   Leave me alone, I said
22:24:01 <copumpkin> :t sort
22:24:02 <lambdabot> forall a. (Ord a) => [a] -> [a]
22:24:02 <Boxo> Never trust a paste...
22:24:15 <copumpkin> :(
22:24:40 <BobFunk> c_wraith: 0.3.1
22:24:56 <copumpkin> co_dh: nah
22:25:01 <c_wraith> oh, I'm looking at the docs for 0.4.0.1.  No wonder things don't look the same
22:25:03 <copumpkin> she just doesn't like me
22:25:14 <shachaf> @vixen Do you like copumpkin?
22:25:15 <lambdabot> yeah, i like
22:25:18 <c_wraith> what'd you do to the poor bot?
22:25:30 <nCdy> http://www.haskell.org/haskellwiki/Phooey or http://www.haskell.org/haskellwiki/Gtk2Hs
22:25:32 <BobFunk> c_wraith: gonna try to update
22:25:44 <kmc> co_dh, just a little fun with 眉帽铆k酶毛
22:25:44 <c_wraith> BobFunk: I suspect, based on the types present in 0.4.0.1, that this problem has probably been fixed
22:26:00 <nCdy> what's better for Gui , Phooey or Gtk2Hs ?
22:26:04 <BobFunk> c_wraith: that would be great
22:26:19 <kmc> nCdy, they are totally different
22:26:21 <shachaf> kmc: Come on, 'k'?
22:26:29 <shachaf> Where's your 泻?
22:26:32 <copumpkin> lol
22:26:34 <kmc> 魏    right here
22:26:44 <copumpkin> 魏mc
22:26:55 <kmc> 魏渭
22:27:02 <nCdy> kmc: hm... what's better to create simple gui apps ?
22:27:04 <kmc> ok  is bogus but that's where my keymap puts it
22:27:18 <shachaf> 泻屑
22:27:32 * shachaf feels off-topic even for #haskell.
22:27:53 <shachaf> So why does it make sense for e^x to correspond to Bag x?
22:28:30 <kmc> e^x = 1 + x + x虏/2! + x鲁/3! + ...
22:28:50 <kmc> x^n/n! is n-tuples of x, with ordering divided out
22:28:52 <shachaf> kmc: Right, but other than that.
22:28:57 <kmc> oh
22:29:03 <kmc> does there have to be a second reason?
22:30:01 <Boxo> '> "盲"
22:30:04 <Boxo> > "盲"
22:30:05 <lambdabot>   "\228"
22:30:15 <shachaf> I demand at least three reasons before accepting any proposition.
22:31:25 <shachaf> What would 2^x be?
22:32:18 <copumpkin> x -> bool?
22:32:47 <shachaf> I guess so.
22:33:03 <kmc> so 2^x = Set x, and e^x = Bag x?
22:33:06 <kmc> that's kind of weird
22:33:22 <copumpkin> 3^x is too much
22:33:25 <copumpkin> 2^x is too little
22:33:31 <copumpkin> e^x is just right
22:33:35 <kmc> True | False | FileNotFound
22:34:22 <copumpkin> True | False | FileNotFo-
22:34:23 <kmc> still weird that the difference between allowing and not allowing duplicates is a mere 0.7183
22:34:55 <kmc> so why can't i count the number of distinct bags from a set of n elements as e^n
22:35:02 <dolio> I'm not sure there's any meaning to be found in thinking about that aspect.
22:35:22 <copumpkin> e is an implementation detail for the reals, maybe?
22:35:25 <shachaf> What does ~0.71828 (e - Bool) correspond to? :-)
22:35:53 <copumpkin> shachaf: have you defined subtraction yet?
22:35:56 <shachaf> Nope.
22:35:56 <kmc> if i have a set S what significance does the number e^|S| have?
22:36:11 <shachaf> I'm not sure what subtraction would be in general.
22:36:27 <shachaf> I guess x(x-1)/2 would be two-element sets, yes?
22:36:46 <copumpkin> I feel like subtraction would need to be dependent
22:36:56 <copumpkin> a sigma carrying a proof that one of your elements is not it
22:37:16 <Boxo> (2718/1000) = Almost Bag x?
22:37:19 <dolio> There are apparently ways to define arbitrary subtraction, but it's not easy.
22:37:20 <copumpkin> or I guess some form of a subtype
22:37:44 <dolio> You need to talk about virtual species, and then normalization of some sort.
22:38:11 <dolio> And maybe Grothendiek something-or-others.
22:38:17 <dolio> Or maybe I got the mathematician wrong.
22:38:22 <Boxo> *(2718/1000)^x
22:38:51 <copumpkin> one of the reasons I started that CT library in agda was to do Grothendieck constructions for that databases-as-categories talk
22:39:09 <Boxo> what's pi^x? sqrt(2)^x?
22:39:11 * copumpkin should resume that at some point
22:46:05 <mzero> :t  let (a:b:c:d:z) = iterate(\g f -> f.g f)($) in d
22:46:06 <lambdabot> forall b. (b -> b) -> b -> b
22:46:16 <mzero> huh!
22:46:21 <mzero> when I do that in ghci I get
22:46:25 <copumpkin> that's a useful one
22:46:52 <mzero> (GHC.Prim.Any -> GHC.Prim.Any) -> GHC.Prim.Any -> GHC.Prim.Any
22:46:55 <copumpkin> lol
22:47:25 <mzero> ah ah
22:47:32 <mzero> I suspect monomorphism
22:47:37 <copumpkin> @let thrice f = f . f . f
22:47:38 <lambdabot>  Defined.
22:47:45 <copumpkin> > thrice thrice (+1) 5
22:47:47 <lambdabot>   32
22:47:57 <copumpkin> > thrice thrice thrice (+1) 0
22:47:59 <lambdabot>   *Exception: stack overflow
22:48:10 <mzero> yes - I want a family of multiple appliers
22:48:20 <copumpkin> will you apply them to themselves?
22:48:25 <copumpkin> cause that's where the fun comes in!
22:48:50 <copumpkin> or just represent your naturals as church naturals
22:49:02 <copumpkin> which are magically exactly what you want
22:49:29 <mzero> I will indeed apply them to themselves
22:49:34 <shachaf> > thrice thrice f x
22:49:36 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
22:50:06 <mzero> :t f
22:50:06 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
22:50:23 <copumpkin> > length (thrice thrice thrice (():) [])
22:50:27 <lambdabot>   mueval-core: Time limit exceeded
22:50:35 <copumpkin> predict how long it will be :)
22:55:18 <Jafet> > 3^3^3
22:55:19 <lambdabot>   7625597484987
22:59:12 <mzero> > let s=succ;p=pred;(a:b:c:d:e:f:g:h:i:j:k:z)=iterate(\g f->f.g f)($) in init$scanr($)'O'[c(j p).s,g p,id,c p,h(j s).p,e(k p),d(f p),c p,f s,h s,f(k s).s,e(i p).p]
22:59:13 <lambdabot>   "Hello World!"
22:59:30 <mzero> :-)
23:01:00 * kmc claps
23:01:18 <kmc> that's a good start for the IOHCC
23:03:25 <BobFunk> c_wraith: can't be sure if it's a question of the GC or if I'm doing something wrong - but tried with http-enumerator 0.4.0.1 and setting the request body with RequestBodyLBS
23:03:27 <Axman6> bleh, wrying to write a linked list implementation in C is nowhere near as fun as in haskell :(
23:03:38 <BobFunk> c_wraith: and still seem to load the whole file in memory
23:03:41 * Axman6 writes it in haskell then translates the operations to C
23:04:06 <kmc> ghc -fvia-C -keep-hc-files
23:04:08 <kmc> problem solved
23:04:27 <geheimdienst> trying to write a * implementation in C is nowhere near as fun as in haskell
23:04:53 <ddarius> kmc: It might be the case that he is not using GCC.
23:05:19 <kmc> nonsense, gcc is the only c compiler anyone cares about [/troll]
23:05:28 <kmc> or build an unregisterized ghc
23:05:56 <kmc> i wonder if clang can deal with registerized via-C
23:06:07 <kmc> it's supposed to support most of gcc's insanity
23:06:13 <kmc> can compile most but not all of linux
23:06:36 <kmc> the linux kernel is basically a test suite for gcc / binutils
23:07:24 <Jafet> Though never intended by any of its authors to be, I'm sure
23:09:46 <kmc> "'m doing a (free) operating system (just a hobby, won't be big and professional like gnu) for 386(486) AT clones."
23:10:12 <kmc> "It is NOT portable (uses 386 task switching etc), and it probably never will support anything other than AT-harddisks, as that's all I have"
23:11:44 <kmc> must sleep
23:16:24 <tehgeekmeister> @pl \f g x -> f . (g x)
23:16:25 <lambdabot> (.) . (.)
23:16:47 <tehgeekmeister> that is confusing.  to be expected.
23:18:14 * shachaf returns.
23:18:36 <shachaf> So what does integration of a type intuitively correspond to?
23:18:50 <numeral> wow that is the most israeli nick I've ever seen on irc
23:19:02 <shachaf> Mine?
23:19:09 <shachaf> Well, it's my name.
23:20:28 <numeral> I figured :P
23:27:36 <kisielk_home> is there a convenient way to convert a boolean to an int? or should I just write a function for that?
23:27:47 <ddarius> fromEnum
23:27:50 <c_wraith> > fromEnum False
23:27:51 <lambdabot>   0
23:31:01 <shachaf> ddarius: So is there any sort of intuition other than the infinite series for why e corresponds to Nat?
23:47:48 <Havelock> hello
23:49:18 <Havelock> I am doing a software Design assignment on haskell and I need an example task that haskell would be suitable for.
23:49:25 <Havelock> can anyone help me out?
23:49:44 <geheimdienst> managing windows!
23:49:46 <geheimdienst> ;)
23:49:49 <Havelock> lol
23:51:31 <Havelock> care to be more specific?
23:51:56 <Havelock> !ping
23:52:03 <geheimdienst> oh it's just because one of the most popular haskell programs is the xmonad window manager ...
23:52:08 <geheimdienst> but srsly, it's a general-purpose language
23:52:24 <geheimdienst> i'd say it's well-suited to, well, programming
23:52:39 <Jafet> Haskell can accomplish any task -- especially if it has already been accomplished in C.
23:53:14 <Havelock> hmm
23:53:32 <geheimdienst> i can see how you'd consider a language like R to be well-suited only for statistical stuff, or tex only well-suited for layout and typesetting, but for haskell or java or python i can't see that kind of limitation
23:53:52 <Havelock> yeah I understand
23:54:21 <Havelock> the question is a broad
23:54:26 <Havelock> I guess
23:54:49 <geheimdienst> i guess it'd be more sensible to say "haskell puts emphasis on X, Y, and Z. so if those are important for your project, haskell might be a good choice"
23:55:08 <Havelock> mathematical analysis maybe?
23:56:12 <shachaf> Writing compilers seems popular.
23:56:53 <Havelock> what haskell specific compilers, or compilers in general?
23:57:25 <geheimdienst> i can only tell you, i like haskell because of the very helpful compiler (i.e. type system). it takes a while to get anything to compile, but once it does, there's usually not many bugs there anymore
23:57:56 <geheimdienst> contrast that with python, where running the program for the first time is the start of eleventy hours of debugging
23:58:21 <geheimdienst> (or c, or objective-c, or java to some extent)
23:58:39 <Havelock> I only really know C#
23:59:35 <geheimdienst> it's a little more modern, but pretty similar to java i'd say
23:59:40 <Kaidelong> C# has the same problem
23:59:51 <Havelock> with compiling?\
