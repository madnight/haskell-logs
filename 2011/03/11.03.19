00:34:09 <mreh> hmm, lazyiness in the IO monad wasn't quite what I had thought it was like
00:34:43 <mreh> i'm wasting a load of time just experimenting with the profiler
00:56:00 <accel> if I have a C function of type: "Dog foo(Cat1, Cat2, Cat3)" and I FFI it in haskell; does it end up having type Cat1 -> Cat2 -> Cat3 -> IO (Dog) ?
00:57:53 <shachaf> accel: Modulo C types being different from Haskell types, in general, it should.
00:58:13 <accel> do C structs map to haskell records?
00:59:06 <shachaf> accel: Not on their own, as far as I know.
00:59:29 <shachaf> You know about as much about the FFI as I do, though; I'm sure you can look it up in the same places I am. :-)
00:59:42 <accel> i'm looking at chapter 17 of RWH
00:59:44 <mauke> the FFI doesn't let you pass structs directly AFAIK
01:02:05 <pastorn> you can deconstruct and construct structs through bytestrings
01:02:20 <mauke> or I could just use Storable
01:02:27 <pastorn> that too
01:03:03 <shachaf> Storable with hsc2hs, possibly.
01:04:19 <accel> hmm
01:04:24 <accel> so it sounds like FFI is not as pleasnt as I thought
01:04:37 <accel> so I should minimize the number of functions/structures haskell/C communicates with?
01:32:39 <earthy> preferably
01:32:50 <Feuerbach> I'm new to automated theorem proving. I'm looking for a tool to prove some properties of my Haskell programs. What would you advise? Right now I'm choosing from Isabelle, Coq and Agda (but also open to other suggestions)
01:32:51 <earthy> but that's simply to reduce maitenance overhead
01:33:08 <earthy> feuerbach: I hear good words about Coq
01:36:32 <accel> I heard some interesting work by this guy called Godel
01:36:44 <frerich_> Hm, a question for native english speakers: what do you call the 'grid' in a Tic Tac Toe game? 
01:36:49 <frerich_> 'Grid'? Playground?
01:36:55 <frerich_> Map?
01:37:09 <Saizan> i'd guess board
01:37:11 <accel> tic tac toe board
01:37:15 <frerich_> Board, ah
01:37:20 <frerich_> Thanks
01:42:39 <Palmik> Hmm, I have installed newer version of one package from github (I had it installed from hackage previously) because some new functionality had been added, the problem is that in my project the new functions are not in scope (as if the old version was used (I have imported the right module)), but they are in scope when I import the module in ghci, does anyone have any idea of what might be causing it? (I did cabal clean and install my project in 
01:42:41 <Palmik> question)
01:43:25 <earthy> are you using cabal to build?
01:43:43 <earthy> and how have you installed the newer version?
01:44:14 <Saizan> does your .cabal file have a version range on this dependency which excludes the version corresponding to the github one?
01:44:15 <earthy> the problem is most probably that GHC still references the older version of the package in preference to the newer version
01:44:52 <Saizan> ghc doesn't do that, afaiu
01:46:29 <Palmik> earthy, I have used cabal to build both the newer version of package and the project
01:46:54 <Palmik> Also, the newer vesion has the same version number
01:47:56 <Palmik> Ah, they do not, weird
01:52:56 <accel> hmm; how do I cfeate a FFI for a function
01:52:59 <accel> that returns a struct ?
01:53:32 <Zao> By value?
01:54:40 <accel> yeah
01:54:46 <accel> I can't reutrn by value, I can only return pointer?
01:54:56 <Zao> Isn't that a shady and platform dependant thing to do in C?
01:55:11 <accel> no; I return structs by value al the time
01:55:20 <Zao> accel: I mean ABI-wise.
01:56:21 <Zao> Personally I'd see what kind of code bindings-DSL spits out, but that's me.
01:58:38 <Zao> http://groups.google.com/group/haskell-cafe/browse_thread/thread/2f9d5f3cb954266/bfc17e861d27089c
01:59:25 <Zao> Idiomatic C tends to pass all non-primitive types by pointer, for glorious efficency and portability.
02:00:01 <Zao> (including passing in an existing instance if you don't want to allocate)
02:02:14 <accel> okay; converted all to pointers
02:02:16 <accel> rather than by value
02:03:14 <Zao> Heh, that thread mentions CLDouble. *mourns*
02:19:16 <mreh> http://www.haskell.org/haskellwiki/Memory_leak <- point 1.1 doesn't apply if your compiler uses graph reduction
02:26:47 <Saizan> wouldn't the graph get very large?
02:27:05 * hackagebot HsSyck 0.50 - Fast, lightweight YAML loader and dumper  http://hackage.haskell.org/package/HsSyck-0.50 (AudreyTang)
02:27:22 <Saizan> or does graph reduction imply parallel reduction?
02:46:19 * hackagebot hakyll 3.0.1.4 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-3.0.1.4 (JasperVanDerJeugt)
02:47:19 <accel> in the following, why oes the first ffi compile, but the second does not?
02:47:42 <accel> type MyMidi = ()
02:47:42 <accel> -- MyMidi* myMidi_create();
02:47:42 <accel> foreign import ccall "MyMidi.h myMidi_create" myMidi_create :: IO (MyMidi)
02:47:42 <accel> -- void myMidi_destroy(MyMidi* midi);
02:47:42 <accel> foreign import ccall "MyMidi.h myMidi_destroy" myMidi_destroy :: MyMidi -> IO ()
02:49:09 <pastorn> reading SPJs "Beautiful Concurrency"
02:49:15 <pastorn> "where launchMissiles :: IO () causes serious international side-effects"
02:51:32 <pastorn> accel, freedrool: tell me when either of you manages to play sounds
02:55:28 <accel> pastorn: I can play sounds in many ways.
02:55:40 <accel> pastorn: I'm just working on getting the C & haskell parts to work together now.
02:56:40 <pastorn> accel: is a function :: Instrument -> Pitch -> Duration -> Volume -> IO () anywhere in sight?
02:57:08 <pastorn> maybe Duration = (Attack, Sustain, Release) or whetever
02:57:18 <pastorn> i'm not that good with synth stuff
02:58:23 <accel> pastorn: yeah; do you want it for offline midi, offline csound, online csound, or online midi ?
02:58:33 <accel> if you want offline midi, look into haskore
02:58:35 <pastorn> lolwat?
02:58:37 <accel> if you want offline csound, look into hcsound
02:58:49 <pastorn> i just want to make my computer play shit
02:58:50 <accel> if you want online csound/midi, you need the libraries I'm writing
02:59:04 <accel> do you just want to produce a wav/midi
02:59:07 <pastorn> though i want to be able to have many concurrent sounds
02:59:11 <accel> or do you want to be able to interactively change the sound as it's playing?
02:59:14 <pastorn> so playing should be non-blocking
02:59:32 <accel> offline = "you run the progrma; it writes out a midi / wav; you can play the file later"
02:59:42 <accel> online = "you run the program; it's playing music; as you interact with it; the music changes"
02:59:47 <pastorn> hmm... changing it while playing sounds nice
03:00:00 <pastorn> but not online...
03:00:09 <pastorn> i have no devices or anything
03:00:23 <accel> you don't have speakers?
03:00:23 <pastorn> what's csound?
03:00:26 <pastorn> i do
03:00:35 <accel> they what do you mean by "no devices" ?
03:00:41 <pastorn> don't you mean "online" as in "on-line algorithm"
03:00:46 <accel> no
03:00:54 <pastorn> no, i meant a keyboard
03:01:00 <accel> I mean online as you can synthesize the music on the fly
03:01:01 <pastorn> with white and black keys
03:01:08 <pastorn> yes, i want that
03:01:08 <accel> oh; i don't have a physical keybaord either
03:01:21 <pastorn> i want to play tunes at random times
03:01:24 <accel> yeah; getting 'online' to work has been consuming the past 48 hours of my life
03:01:38 <pastorn> accel: i will give you an apple once you're done
03:01:39 <accel> if you want to play preset midi/wav files, you can just hav ea bunch of offline files played randmoly
03:01:40 <pastorn> or two
03:01:47 <pastorn> i think  i have a few left
03:01:58 <accel> the only apple I want are mac pros
03:01:59 <pastorn> shit, four apples left
03:02:13 <accel> if you're in japan; you would be king
03:02:18 <Zao> pastorn: PCs are better!
03:02:33 <pastorn> oh, this was nice
03:02:35 <pastorn> quite sour
03:02:37 <accel> hmm; maybe that joke went too far
03:02:39 <pastorn> and hard
03:02:43 <pastorn> that's how i like them
03:03:01 * accel actually sympathesizes with the victims of the japanese natural disasters
03:03:42 <accel> anyway; if you want this to work
03:03:46 <accel> you need to understand FFI's
03:03:53 <accel> http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/mark.pdf is what I'm currently reading
03:03:57 <accel> also, what OS are you on?
03:04:58 <pastorn> ubuntu 10.10
03:05:25 <accel> oh
03:05:28 <accel> my code only works on osx
03:05:41 <accel> ubuntun 10.10 is  much much easier
03:05:49 <accel> look into haskore-realtime library
03:11:25 <pastorn> accel: doesn't that API look like it wants to kill you
03:12:02 <accel> hcsound or haskore or haskore-realtime?
03:16:00 <pastorn> accel: any of tehm
03:16:12 <pastorn> accel: what's CSound?
03:16:45 <pastorn> play :: Output out => T out -> T -> IO ()Source
03:16:47 <pastorn> NICE
03:16:48 <DRMacIver> Hi. I'm trying to optimise some Haskell code. Currently it takes ~ 5 seconds on a mere 8000 records, and I'd like to get it down to well under a second. https://github.com/DRMacIver/hs-rank-aggregation
03:17:25 <DRMacIver> Currently profiling says it's spending most of its time in scoreWith, which dos a lookup in a Map (a, a) Double. 
03:17:29 <pastorn> DRMacIver: takeWhile/dropWhile is slow
03:17:51 <pastorn> DRMacIver: start by changing that to usage of break/span or whatever=
03:18:02 <pastorn> might get a little boost from that
03:18:06 <DRMacIver> pastorn: Or I could start where the profiler tells me all the time is actually taken. :)
03:18:15 <pastorn> maybe
03:18:15 <DRMacIver> Main.hs is terrible at the moment, I know, but it's not the bottleneck
03:18:32 <pastorn> you only linked a repo
03:18:39 <pastorn> so i assumed it was in the root
03:18:41 <pastorn> SILLY ME
03:19:09 <DRMacIver> No, sorry, the actually interesting code is the module Algorithms.RankAggregation, not the driver program.
03:19:57 <DRMacIver> Main.hs is just something I wrote so that I could throw lots of data at it.
03:20:28 <spetrea-home> DRMacIver: could you also post profiler output in a gist ?
03:20:47 <DRMacIver> Sure
03:21:03 <pastorn> DRMacIver: ugh... why all the types?
03:21:11 <pastorn> makes it hard to read :)
03:21:14 <pastorn> :(
03:21:37 <pastorn> at least for me ;)
03:21:56 <accel> Undefined symbols:
03:21:56 <accel>   "_myMidi_destroy", referenced from:
03:21:56 <accel>       _s12z_info in SimpleFFI.o
03:22:02 <DRMacIver> spetrea-home: https://gist.github.com/877401
03:22:03 <accel> myMidi_destroy
03:22:09 <accel> is a function available in MyMidi.o
03:22:17 <accel> 	ghc --make SimpleFFI.hs MyMidi.o
03:22:19 <accel> is my Makefile
03:22:26 <DRMacIver> pastorn: I find type signatures for top level functions greatly improves program clarity. YMMV obviously. :)
03:23:28 <accel> OSStatus myMidi_event(MyMidi* midi, UInt32 cmd, UInt32 num, UInt32 vel, UInt32 other);
03:23:29 <DRMacIver> Particulraly when it lets you make use of sensible aliases. The optimisers signatures would be a complete pain if it weren't for the type alias.
03:23:32 <accel> MyMidi* myMidi_create();
03:23:34 <accel> are all functions in MyMidi.h
03:23:37 <accel> void myMidi_destroy(MyMidi* midi);
03:23:37 <accel> do I need to make them extern
03:23:43 <accel> for the haskell site to be able to see them?
03:24:14 <pastorn> DRMacIver: maybe a Map isn't you optimal structure?
03:24:18 <DRMacIver> So I think the root of my problem here is that I have a Data.Map (a, a) Double. I'm not sure what to do about that. Is a Map a (Map a Double) likely to be significantly faster? I can see that it might be, but wouldn't want to guess.
03:24:33 <DRMacIver> pastorn: Certainly possible, but I have to do a lot of lookups, so what would you suggest?
03:24:42 <pastorn> array?
03:24:48 <pastorn> can you cache the writes?
03:24:58 <accel> gcc -fPIC MyMidi.c -c
03:24:59 <accel> ghc --make SimpleFFI.hs MyMidi.o
03:24:59 <accel> Linking SimpleFFI ...
03:24:59 <accel> ld: warning: in MyMidi.o, file was built for unsupported file format which is not the architecture being linked (i386)
03:25:04 <accel> waht oes the above mean?
03:25:09 <accel> what's wrong with the file format I've built it as?
03:25:21 <pastorn> accel: you're using x64?
03:25:35 <accel> x86-64 on osx
03:25:40 <pastorn> right
03:25:47 <pastorn> so you're *not* using i386
03:25:54 <accel> correct
03:26:02 <accel> I don't see where I specify i386
03:26:03 <accel> hmmm
03:26:13 <accel> file MyMidi.o
03:26:13 <accel> MyMidi.o: Mach-O 64-bit object x86_64
03:26:17 <pastorn> maybe we should read our errors :)
03:26:32 <pastorn> oh
03:26:43 <accel> maybe we shouldn't jump to conclusions
03:26:45 <accel> :-)
03:26:48 <pastorn> hehe
03:26:54 <Saizan> your ghc compiles to i386, while gcc defailts to x86_64
03:27:02 <pastorn> DRMacIver: so how many writes do you have?
03:27:03 <accel> Saizan: how do I fix this?
03:27:08 <accel> Saizan: do I change gcc or ghc?
03:27:12 <heatxsink> there's probably a param you pass to ghc
03:27:20 <pastorn> DRMacIver: and how many elements in your collection
03:27:27 <heatxsink> or gcc -> i386
03:27:33 <Saizan> accel: i think there's some flag you can pass to gcc
03:27:46 <accel> Saizan: why do I want to down grade my system to i386
03:27:49 <accel> when it's an x86_64 ?
03:27:51 <pastorn> DRMacIver: if there's only ever *one* collection then you might consider doing your code in the IO or ST monad for crazy performance
03:27:59 <accel> and why does ghc drop down to i386?
03:28:01 <accel> I'm on ghc 7.0
03:28:36 <Saizan> ghc 7.0.2 should have a x86_64 installer for os x
03:28:44 <pastorn> DRMacIver: if you need multiple collections (backtracking & whatnot) then Array (immutable) could prove useful, but writing is O(|arraySize|)
03:28:46 <accel> hmm
03:28:47 <accel> I built from source
03:28:48 <DRMacIver> pastorn: The collection is built up front. There are probably about 1000 entries in it (I haven't tested, though should), coming from about 10-15k writes.
03:28:52 <pastorn> that's why i asked about cached writes
03:28:52 <accel> maybe I fucked up
03:29:14 <DRMacIver> Well, that's the Map. There's a lot of list building.
03:29:17 <heatxsink> accel: ballz
03:29:25 <accel> lol
03:29:25 <pastorn> then make a Map, for fast insert, run toList, then listArray
03:29:30 <accel> it wasn't available as a mac *.dmg
03:29:54 <DRMacIver> Except the keys are strings, which makes rewriting this to use an array a significant pain in the ass.
03:30:06 <pastorn> DRMacIver: but as i said, if there only needs to only be one collection in memory, switch to ST for crazy performance
03:30:41 <accel> Saizan: is there any reason why ghc 7.0 defaults to i386?
03:30:47 <accel> Saizan: are there known problems with x86_64 ?
03:31:11 <accel> On Mac OS X 10.6 systems with 64-bit capable processors, an experimental 64 bit GHC environment is provided. Please let us know what you think:
03:31:14 <accel> hmmmm
03:31:24 <accel> i wonder what makes it experiemntal :-)
03:31:26 <Saizan> accel: i only know they struggled for a bit before being able to support x86_64 on leopard
03:31:45 <accel> alright; gcc is more mature than ghc
03:31:50 <accel> so I'll tell gcc to go 32bit
03:31:59 <accel> I dont' want ot be wondienrg if the bug is in my ffi integration
03:32:03 <accel> or ghcs 64bit 
03:32:04 <pastorn> DRMacIver: not nessecarily
03:32:06 <pastorn> hash them
03:32:22 <DRMacIver> pastorn: With due respect, this appears to be generic advice without consideration of the actual problem. So I'm pretty leery of just jumping in and rewriting the *entire* way this works to uglify it as soon as I need to do a tiny bit of optimisation.
03:32:36 <accel> Linking SimpleFFI ...
03:32:37 <accel> Undefined symbols:
03:32:37 <accel>   "_FSPathMakeRef", referenced from:
03:32:37 <accel>       _myMidi_create in MyMidi.o
03:32:37 <accel>   "_AUGraphNodeInfo", referenced from:
03:32:37 <pastorn> DRMacIver: heh, probably :{
03:32:39 <accel> okay, that problem solved
03:32:39 <pastorn> :)
03:32:44 <accel> next problem ... how do I pass -framework lines to ghc?
03:32:50 <dibblego> DRMacIver: I think you would get a speed-up by changing the Map as you say or with: data StrictPair a = S !a !a
03:32:55 <accel> -framework is like -l, but it's for mac rahter than linux
03:33:38 <Saizan> if they are still flags to the linker there's -optl
03:33:46 <accel> hmm, apaprently ghc understands -framework
03:33:52 <DRMacIver> dibblego: Hm. I'll give the strict pairs a try, as that sounds like an easy to change to see if it helps. Thanks.
03:34:01 <dibblego> DRMacIver: np
03:34:06 <Saizan> but don't paste several lines like that to the channel, especially if they aren't that much relevant
03:34:49 <accel> yeah; I hate it when people needlessly paste
03:34:50 <pastorn> @where paste
03:34:50 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
03:34:54 <accel> lambdabot whould auto kick them
03:35:41 <pacak> ???
03:35:50 <vav> lastlog
03:36:44 <Saizan> DRMacIver: you could try this http://hackage.haskell.org/package/hamtmap
03:37:36 <accel> hmm
03:37:40 <accel> how do I get a forein UInt32 ?
03:38:01 <pastorn> accel: you want one as an argument to a C function?
03:38:06 <accel> yeah
03:38:10 <pastorn> accel: in haskell uint_32 = Word32
03:38:17 <pastorn> but i don't know about marshalling
03:38:28 <accel> @hoogle Word32
03:38:28 <lambdabot> Data.Word data Word32
03:38:31 <pastorn> accel: import Data.Word
03:38:38 <accel> pastorn: it's okay; this is not for a banking application
03:39:25 <DRMacIver> dibblego: StrictPair helped a tiny bit. About half a second shaved off the runtime. Thanks
03:39:57 <DRMacIver> Saizan: Interesting. Will give it a go. Thanks.
03:40:03 <accel> @hoogle sleep
03:40:03 <lambdabot> No results found
03:40:10 <accel> does haskell have a usleep :: IO() ?
03:40:15 <accel> err, a usleep :: Int -> IO()
03:40:21 <accel> I wnat to usleep for that many micro (or milli) seconds
03:40:25 <pastorn> accel: import Controll.Concurrent (threadDelay)
03:40:56 <pastorn> accel: sleeping one second is done by 'threadDelay (10^6)'
03:41:56 <accel> damn it; i convert to haskell
03:41:58 <accel> no longer have sound
03:42:16 <DRMacIver> Hmm. hamt apparently needs to install the entire world. Oh well.
03:42:52 <accel> "0x9 << 4" = "9 * 16" right ?
03:44:27 <pastorn> DRMacIver: sounds like you're doing it wrong... you should probobly only need deepseq, hashable, text and one or two more
03:44:36 <accel> fuck
03:44:38 <siracusa> Is there a lambdabot plugin for hayoo?
03:44:39 <accel> my C code doesn't work in 32bit
03:44:59 <pastorn> siracusa: use a search keyword in your browser :)
03:45:16 <pastorn> siracusa: and no, i don't think so
03:45:23 <pastorn> @hayoo reactimate
03:45:23 <lambdabot> Unknown command, try @list
03:45:52 <pastorn> siracusa: right click in the search field and click "Add keyword..."
03:45:56 <pastorn> pretty awesome :)
03:46:27 <siracusa> pastorn: This won't work in my browser ;-)
03:46:38 <pastorn> awwww
03:49:51 <accel> woot
03:49:54 <accel> I got haskell to play midi
03:49:57 <monokrome> woot
03:50:07 <accel> next up; link it with my opengl display :-)
03:50:14 <accel> excep[t it's fucking 4:30am
03:50:16 <accel> and I should sleep
03:50:43 <monokrome> Make it play this: http://www.youtube.com/watch?v=kA5Wc1_Zghk
03:51:07 <monokrome> Because that's super awesome
03:51:30 <pastorn> accel: i can help you with GL later
03:51:36 <accel> I have GL code
03:51:40 <accel> sound was my bottleneck
03:51:46 <pastorn> go to sleep, i'll provide you with SDL initialization tomorrow :)
03:51:52 <accel> i'm using GLUT
03:51:55 <pastorn> dude
03:51:55 <accel> if you want to help
03:51:57 <pastorn> stop that
03:52:05 <monokrome> pastorn is right on this
03:52:07 <pastorn> glut = donkey ballz quality
03:52:07 <accel> stop what?
03:52:13 <pastorn> using glut
03:52:24 <pastorn> it's ok for hello world, if even that
03:52:26 <pastorn> wait
03:52:27 <pastorn> it's not
03:52:31 <accel>   (progname, _) <- getArgsAndInitialize
03:52:32 <accel>   initialDisplayMode $= [DoubleBuffered]
03:52:32 <accel>   createWindow "Hello World"
03:52:32 <monokrome> No, because that teaches you to use glut!
03:52:36 <accel> ... that is fine ....
03:52:38 <accel> what's so great about SDL?
03:52:46 <monokrome> It's not GLUT
03:52:47 <pastorn> no callbacks <3 <3 <3
03:52:47 <accel> all I need GLUT to do is give me an opengl window
03:52:48 <DRMacIver> pastorn: It was mostly text, text is just a huge install. :)
03:52:59 <accel> what? i have keyboard / display / idle callbacks in glut
03:53:04 <pastorn> accel: no, you use SDL for that
03:53:08 <DRMacIver> Saizan: Alas hamt more than doubles the runtime.
03:53:17 <accel> monokrome: I'm going ater something more like: http://www.youtube.com/watch?v=25i56AWtFqk
03:53:31 <monokrome> with MIDI?
03:53:34 <pastorn> you want it so that it's you yourself taht is responsible for repainting calls, not some weird callback system which you can't control
03:53:43 <accel> monokrome: midi + fm syntehsis
03:53:48 <monokrome> aha
03:53:50 <accel> piano is going to be a bitch to get right
03:54:00 <accel> but maybe I can just find someone who's done it right
03:54:01 <monokrome> Yes, it is.
03:54:08 <pastorn> accel: good night
03:54:14 <accel> pastorn: so basically you want
03:54:19 <accel> while(1) { .... draw() ... } ?
03:54:22 <accel> rather than dispaly callbacks?
03:54:25 <pastorn> yes
03:54:28 <accel> why?
03:54:35 <pastorn> because i can control framskipping
03:54:43 <pastorn> and event polling
03:54:46 <Jafet> This discussion should be in #haskell-game
03:54:50 <pastorn> indeed
03:54:54 <pastorn> but i'm leaving now
03:54:58 <pastorn> KTHXBAI
03:55:02 <pastorn> BBQ
03:55:06 <pastorn> LOL
03:55:15 <monokrome> Piano is harder than that.. Piano = strings
03:55:18 <accel> I thikn you forgot IHAZCHEEZBURGER
03:55:19 <Jafet> Behave or be behoven.
03:55:43 <accel> http://www.youtube.com/watch?v=ZJGfZQ1TjyU <-- this piano blew me away
03:55:49 <accel> probably the best piano I've heard so far
03:56:06 <accel> you have to love the youtube comments:
03:56:07 <accel> While programming my first library I ran into the need to have an acoustic piano sound. Since I don't have a real piano to sample, I decided to synthesize it from scratch using "traditional" subtractive synthesis technique. 
03:56:14 * monokrome isn't sure if Jafet is saying no more piano or no more opengl discussion... or both
03:56:23 <accel> this is his "first library", and he didn't "have a real piano"
03:56:31 <accel> so he just decided "oh, I'll go synthesize it"
03:56:37 <accel> i'm prettey sure it's re opengl, not re piano
03:56:40 <Saizan> DRMacIver: ah, too bad
03:56:42 <accel> since piano would be inappropriate in #haskell-game
03:56:49 <accel> and #haskell-piano is kinda empty
03:57:06 <Jafet> Piano isn't hard, you just need a decent room and mic.
03:57:08 <monokrome> This is a really good piano... Specifically because it has the character of a 40/50s recording, which is hard to simulate
03:57:16 <monokrome> pretty cool
03:57:25 <accel> wwhat is a "40/50s" recording?
03:57:38 <monokrome> These are sythesized right?
03:58:24 <accel> the descritipn claims it's synthesized
03:58:57 <accel> somehow, the sound being "soft" rather than "sharp" makes it feel more realistic
03:58:57 <monokrome> I think that it might be fake, because it really does sound like a recording from the 50s (years between 1950 and 1959)
03:59:21 <accel> given the lack of technical description, I would not be surprised
04:00:15 <accel> @hoogle threadDelay
04:00:15 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
04:00:42 <accel> hmm
04:00:46 <accel> threadDelay isn't very precise
04:00:49 <accel> is there something more precise?
04:01:53 <accel> System.Posix.Unistd.usleep provides far better timing
04:01:57 <Jafet> Microseconds not precise enough?
04:02:10 <accel> threadDelay x guarantess "not within x"
04:02:14 <accel> but does not guarantee "immediately after x"
04:02:23 <Jafet> Neither does posix.
04:02:32 <accel> so "threadDelay 300000" ends up being more like .5 seconds rather than .3 seconds
04:02:33 <Jafet> Well, posix makes the opposite guarantee.
04:02:52 <accel> Sleep for the specified duration (in microseconds).
04:02:53 <accel> GHC Note: Control.Concurrent.threadDelay is a better choice. Without the -threaded option, usleep will block all other user threads. Even with the -threaded option, usleep requires a full OS thread to itself. Control.Concurrent.threadDelay has neither of these shortcomings.
04:03:52 <accel> @t mapM_
04:03:52 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
04:03:57 <accel> :t mapM_
04:03:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:04:39 <accel> woot woot woot
04:04:44 <accel> i got a scale palyed in haskell now
04:04:52 <accel> monokrome: you seem into music
04:04:58 <accel> know of good algorithms for algorihmic composition?
04:05:04 <accel> ideally; I want to compose things like korean dramas
04:05:09 <monokrome> What do you want to do?
04:05:13 <monokrome> Example?
04:05:16 <accel> hang on
04:05:40 <mercury^> :t fmapM_
04:05:41 <lambdabot> Not in scope: `fmapM_'
04:05:42 <accel> http://www.youtube.com/watch?v=WxA8L_lQOp4 <-- first reulst on youtube
04:05:49 <accel> basically, things that are rolling chords
04:05:51 <mercury^> :t traverseM_
04:05:51 <lambdabot> Not in scope: `traverseM_'
04:06:02 <mercury^> Hmm.
04:06:12 <Jafet> These pieces aren't written by humans?
04:06:17 <Jafet> I guess that would explain a lot
04:06:21 <accel> they are written by huamns
04:06:27 <accel> I want to algorithmically syntehsize similar things
04:06:29 <accel> for background music
04:06:33 <accel> in my minecraft clone
04:06:35 <Jafet> Good luck.
04:06:40 <accel> Jafet: ?
04:06:49 <accel> except, I'm goign to call my lovecraft
04:07:14 <mercury^> What is the difference between minecraft and sauerbraten?
04:07:16 <monokrome> accel: I have done this before by programming scales alongside rhythm patterns
04:07:28 <accel> monokrome: do you ahve a technical write up?
04:07:30 <monokrome> not this style, since my music interest is unusual
04:07:35 <accel> and what are rhythm patterns?
04:08:05 * monokrome has never written a technical writeup
04:08:34 <monokrome> rhythm patterns are what I call mapping instruments to a specific rhythm :)
04:08:42 <monokrome> I guess the proper term might be quantization or something
04:08:47 <accel> scales have mathematical definitions
04:08:51 <accel> do rhythms?
04:09:01 <monokrome> Everything does - if you abstract it that way.
04:10:16 <monokrome> github seems to be down
04:10:23 <ion> accel: Not bad for a synthesized piano.
04:11:32 <xplat> 03:13 < pastorn> 134 tabs   <-- 3 digits?  don't make me laugh ... if you haven't written your own program to compact multiple tabs into one in a saved session so your browser can reload it without crashing then you are not eligible for the tab-penis competition
04:12:05 <monokrome> accel: This is pretty bland, but it will compute times on a given time signature. Only piece of audio code that I have left any more... https://github.com/monokrome/audalysis-client/blob/master/audalysis.pacemaker.js
04:12:17 <monokrome> (and it's not Haskell, because I'm just learning)
04:12:49 <accel> thanks; downloaded
04:12:56 <monokrome> but if you tell that to do 4/4, 17/16, or any other time signature (and if you assume that browsers timed things better) then it will play them
04:13:20 <Jafet> xplat: how much memory do you need to run four digits?
04:13:25 <monokrome> assuming you have the rest of that project and you assign some sort of audio event to it anyway
04:14:24 <accel> yah right
04:14:28 <accel> now trying to figure out
04:14:36 <accel> ya, right now, tring to figure out, how to change instrument
04:14:48 <monokrome> change instrument?
04:14:54 <accel> to something besides piano
04:15:02 <accel> can't figure out which midi comand it is
04:15:08 <accel> http://www.onicos.com/staff/iz/formats/midi-event.html is not intuitive
04:15:22 <ion> Program change
04:15:39 <monokrome> sounds right
04:16:19 <accel> ion: got it working; thanks!
04:16:24 <accel> it's really weird
04:16:42 <accel> when I stop asking stupid questions; #haskell gives me useful answers
04:17:58 <monokrome> accel: Did you code the syntehesis?
04:18:11 <accel> the MIDI -> PCM ?
04:18:15 <monokrome> yes
04:18:18 <accel> I've tried doing something with csound
04:18:23 <monokrome> ah
04:18:23 <accel> but it's much harder than I thought
04:18:33 <monokrome> How so?
04:18:54 <accel> It's not necessaiarly harder
04:18:57 <accel> it's only harder for me
04:18:58 <accel> due to my ignorance
04:19:03 <monokrome> oic
04:19:09 <accel> is MIDI -> PCM an easy conversion?
04:19:34 <monokrome> I don't know. I've never done MIDI directly. Shouldn't be too tough?
04:19:45 <accel> is there a well defined formula for MIDI?
04:20:00 <Zao> accel: "conversion" is an incorrect term.
04:20:07 <Zao> Rendering/interpreting is more like it.
04:20:17 <Zao> MIDI is just an instruction set/protocol.
04:20:23 <accel> you're right
04:20:35 <Zao> Note on now, velocity change nao, mute channel 10 lol.
04:21:11 <Jafet> I have a generally low opinion of MIDI
04:21:16 <Jafet> It tends to get misused a lot
04:21:18 <monokrome> It actually seems a bit counterproductive to actually code MIDI without some sort of input that you are wanting to communicate with?
04:21:26 * Zao midi controls Jafet's mood lighting.
04:21:28 <monokrome> input/output
04:21:38 <accel> monokrome: I don't understand your question
04:21:38 * Jafet does not support that vendor extension
04:21:50 * Zao abuses the drum channel.
04:21:53 <monokrome> accel: I'm wondering what you are using the MIDI for
04:22:06 <accel> i'm writing a sequencer
04:22:06 <cheater00> Jafet: also, when you try to use midi correctly, it doesn't work.
04:22:12 <monokrome> Oh, okay!
04:22:15 <Zao> I'd FFI to some existing softsynth or so.
04:22:16 <cheater00> Jafet: midi is a POS on the whole line :p
04:23:47 <accel> http://zynaddsubfx.sourceforge.net/ <-- I like their demos
04:23:54 <accel> the *.og files a the bottom
04:24:05 <accel> what's the easiest way to steal their instruments?
04:24:25 <monokrome> find ones like them
04:24:36 <cheater00> if you want really good virtual analog instruments you get either the stuff from fxpansion or from tone2
04:24:50 * cheater00 worked for both, but doesn't get paid for the plug :p
04:25:02 <monokrome> :P
04:25:17 <accel> do you still have stock?
04:25:25 <cheater00> never had any
04:25:36 <monokrome> If he had stock, then he'd possibly get paid for the plug!
04:25:37 <cheater00> get free boxes though :p
04:25:48 <cheater00> but that's about as far as it goes
04:26:01 <cheater00> and out of these two, only from fxpansion :p
04:28:04 <monokrome> DCAM: Synth Squad looks neat
04:28:48 <cheater00> iknorite
04:29:07 <cheater00> technologically the emulation quality is unsurpassed
04:29:18 * monokrome wishes he had some good tools for audio in Linux
04:29:24 <cheater00> wine it
04:29:37 * monokrome reboots into windows
04:29:47 <cheater00> speaking of which, i should get back to getting ableton working in wine
04:29:58 <monokrome> ack
04:30:01 <monokrome> Why would you do this?!
04:30:04 <cheater00> i almost had it figured out what needs to be patched, but then had no time
04:30:18 <cheater00> monokrome: because even when it's "broken" it still works better than in winaids
04:30:30 <accel> 0xB <-- this is 11 right?
04:30:36 <cheater00> yes
04:30:38 <monokrome> A wild latency nightmare appears!
04:30:45 <cheater00> monokrome: yea, no
04:30:51 <aristid> > 0xB
04:30:52 <lambdabot>   11
04:30:58 <cheater00> monokrome: latency is like 2-4x lower than in windows.
04:31:07 <monokrome> cheater00: ASIO?
04:31:10 <cheater00> yea
04:31:14 <cheater00> you just use wineasio
04:31:20 <cheater00> and jack
04:31:25 <monokrome> wha
04:31:27 <monokrome> wineasio?
04:31:29 <cheater00> yes
04:31:33 * monokrome wonders if it supports his hardware
04:31:37 <cheater00> yes
04:31:42 <cheater00> it supports anything that jack runs on
04:31:46 <cheater00> i.e. anything
04:31:46 <accel> what's the best syntehzier ?
04:31:58 <cheater00> depends what sounds you want to make
04:32:00 * monokrome thinks that XFi has severely limited support
04:32:06 <accel> http://www.fxpansion.com/index.php?page=62 ?
04:32:10 <cheater00> monokrome: almost certain it works on it
04:32:22 <paolino> supercollider is fine
04:32:26 <cheater00> accel: again, depends what sounds you want to make
04:32:39 <accel> http://zynaddsubfx.sourceforge.net/ <-- the ogg files at the bottom of this
04:32:39 <monokrome> cheater00: Stuff like this... http://goo.gl/Y4dlz
04:32:49 <cheater00> accel: cypher is for complicated sounds, amber is for pads and stuff, strobe is for leads
04:33:50 * monokrome likes amber now
04:33:52 <cheater00> monokrome: are you the same thing as monochrom?
04:34:02 <monokrome> yes
04:34:04 <monokrome> wait
04:34:05 <monokrome> no?
04:34:09 <cheater00> monokrome: ok
04:34:12 * monokrome isn't sure what you mean
04:34:18 <Jafet> He seems unsure.
04:34:28 <cheater00> monokrome: there's a regular here with the nick monochrom. he's here right now.
04:34:41 <monokrome> If there is someone named monochrom, then no. If you mean the person who made the music in that link, yes.
04:34:47 <monokrome> Oh. How interesting!
04:34:53 * monokrome waves to monochrom 
04:35:03 <cheater00> monokrome: btw, that link doesn't work for me. it uses flash, but i have flashblock on
04:35:08 <cheater00> except, there is no flash element to activate
04:35:23 <cheater00> so it just spits out the sucker
04:35:42 <cheater00> got links to a flac or something?
04:35:45 * monokrome looks on S3
04:36:07 <cheater00> btw, amber is like the only emulation ever of a divide-down organ/string synth
04:36:15 <cheater00> which makes it pretty cool
04:37:55 <monokrome> cheater00: http://media.monokro.me/audio/projects/2008/Fingy/Fingy.flac
04:37:58 <monokrome> That should work
04:38:57 <aristid> omg there's monokrome and monochrom. confusing!
04:39:25 <cheater00> i don't know what to say
04:39:30 <cheater00> it's just a single pad over and over
04:39:35 <monokrome> :)
04:39:45 <accel> can a midi channel only play a single note at a time?
04:39:50 <monokrom> aim in ur #haksell, confusin ur doodz
04:39:50 <monokrome> accel: no
04:40:02 <cheater00> accel: it can actuate only a single note at a time, yes.
04:40:23 <cheater00> accel: multiple notes can be in the actuated state, though
04:40:52 <accel> cheater00: what does "actuated" mean ?
04:41:05 <cheater00> accel: playing.
04:41:05 <accel> and what does "note velocity" mean?
04:41:20 <cheater00> it means you should first play a piano and then bother with midi.
04:41:30 <accel> I've played piano for many years
04:41:39 * monokrome is getting mad that his system wont play flac
04:41:58 <cheater00> then you surely understand that if you press a key with more velocity it's louder
04:42:33 <accel> it's not more complicated than that?
04:42:57 <cheater00> no
04:43:10 <cheater00> every note "packet" has a velocity field
04:43:23 <cheater00> what the synthesizer uses that field for is the synthesizer's business
04:43:32 <cheater00> it can be for loudness, filter cutoff, or anyt
04:43:35 <cheater00> hing else.
04:44:56 <monokrome> Oh, btw - accel: did you say something about a Minecraft clone?
04:45:13 <accel> monokrome: yeah; i'm writing one
04:45:24 <monokrome> cool
04:45:25 <accel> and I just got the midi part taken care of finally
04:45:28 <monokrome> Any links?
04:45:38 <accel> no outube videos yet
04:45:40 <accel> the graphics suck
04:45:51 <monokrome> Sounds like a Minecraft clone.
04:45:59 <accel> it sucks compared to minecraft
04:47:01 <accel> Graphics wise; Crysis :: Minecraft = Minecraft :: My clone
04:47:53 <accel> A Midi instrument ahs 127 notes. Is each node a piece of code or a time series?
04:48:10 <cheater00> midi part of minecraft?
04:48:12 <cheater00> say what?
04:48:20 <cheater00> accel: that made no sense
04:48:30 <cheater00> with the time series and node that is
04:48:54 <accel> the question is:
04:49:01 <accel> how is a single note of a instrument implemented?
04:49:07 <accel> is it just a time series, or is it a peice of code?
04:49:13 <accel> (in midi)
04:49:19 <ion> Huh?
04:49:25 <cheater00> still makes no sense
04:49:29 <monokrome> accel: Is it FOSS?
04:49:29 <Jafet> Still doesn't know what MIDI is.
04:49:31 <cheater00> explain yourself differently
04:49:43 <accel> I have a midi file; it selects a instrument + a note
04:49:53 <accel> how does this get converte to PCM?
04:50:01 <ion> In any way you want.
04:50:13 <ion> You can even blink lights instead of emitting a sound if you feel like it.
04:50:34 <aristid> accessible music
04:53:44 <monokrome> accel: MIDI provides a means of communication via events about what is happening on an instrument... How those events are processed is completely up to the device/software responding to them.
04:56:51 <xplat> 08:03 < Jafet> xplat: how much memory do you need to run four digits?
04:57:27 <xplat> Jafet: i cover most of them with an about:blank on top so my browser does not overflow the 32-bit address space :I
04:58:53 <monokrome> cheater00: Was that file I sent you earlier only 42 seconds?
04:58:56 <Jafet> Cover? As in abusing history?
05:00:07 <monokrome> cheater00: and if not, mind telling me how long this one is? http://goo.gl/FwNeZ - I think that my audio player might be messed up.
05:00:56 <Jafet> I just use an extension that loads pages on-demand.
05:02:23 <sgronblo> Can't you define data types in ghci? Using data?
05:02:38 <Saizan> no
05:02:41 <sgronblo> oh
05:04:13 <monokrome> accel: With your clone, are you following Minecraft's BSP format and all of it's technical details?
05:04:34 <xplat> Jafet: oh?  which extension is that?  sounds like it could save a lot of trouble ...
05:04:41 <sgronblo> so what I was gonna try, was to verify that haskell supports function overloading so that if you use record syntax to define two data types that both have a property called name, then they won't step on each other's toes?
05:04:48 <accel> monokrome: no; clone is too strong a word
05:04:53 <turiya> hi
05:04:54 <accel> monokrome: I just like to build a lego-like virtual world
05:04:59 <monokrome> ah
05:05:00 <xplat> accel: you're the second person i know writing a minecraft clone
05:05:18 <accel> xplat: who's the othe rperson, might have been an alt I used while I was trolling with this account
05:05:25 * monokrome recalls some had written a minecraft client in Python
05:05:39 <xplat> no, that person was the author of openpit, written in scala
05:06:03 <accel> xplat: url?
05:06:07 <turiya> i am unable to install the package hopencv even though i have all the necessary libs.. anyone has worked with hopencv before?
05:06:24 <accel> turiya: paste your error somewhere, give us a link
05:07:41 <xplat> https://github.com/bjj/Openpit
05:08:21 <turiya> accel: http://hpaste.org/44896/hopencv
05:08:42 <xplat> seems like work basically stopped in mid-october though :(
05:09:13 <accel> what's the license?
05:09:16 <accel> I don't see a COPYING file
05:09:22 <monokrome> Isn't scala interpreted through java?
05:09:22 <accel> nor an indication of what licente it is
05:09:37 <accel> monokrome: ya; but it's proably faster than my hskell implementation
05:09:47 <monokrome> but... java :(
05:10:25 <cheater00> monochrom: zes it was
05:10:48 <monokrome> Hehe. Someone's already calling me monochrom!
05:11:06 <xplat> accel: can't remember ...
05:12:58 <cheater00> This Connection is Untrusted You have asked Firefox to connect securely to media.monokro.me, but we can't confirm that your connection is secure. Normally, when you try to connect securely, sites will present trusted identification to prove that you are going to the right place. However, this site's identity can't be verified.
05:13:19 <cheater00> uh-oh
05:13:50 <xplat> minecraft itself is written in straight java
05:14:03 <monokrome> yep
05:14:19 <accel> i'm on OSX
05:14:24 <cheater00> sorry cannot dl your file monokrome 
05:14:25 <accel> what's the best way to capture video + audio ?
05:14:48 <accel> I'm on OSX: what's the best way to do a high quality capture of video + audio? I can do video capture with Glreadpixels; but audio, I don't know how to do it
05:15:09 <monokrome> Does anyone here know of a tech talk regarding haskell that will also help me learn it?
05:15:26 <accel> i found the best way to learn hskell
05:15:29 <accel> is to ask dumb questions here
05:15:33 <accel> until the ops get angry and tell me to read RWH
05:15:39 <monokrome> Yeah, but I don't like asking dumb questions here
05:15:39 <accel> then I ignore them, and ocnitnue to ask dumb questions
05:15:42 <accel> until I get kicked
05:15:47 <accel> then I start reading RWH,
05:15:48 <accel> and learn haskell
05:16:37 <monokrome> Is RWH written for beginning programmers?
05:16:54 <accel> it's written for programmers new to haskell
05:17:24 <monokrome> Oh. Perfect then. I dislike reading beginner documents :)
05:18:41 <accel> http://zynaddsubfx.sourceforge.net/demo03.ogg
05:18:44 <accel> what's going on in taht piece?
05:18:49 <accel> it sounds like it's more complicated than individual notes
05:18:52 <monokrome> ?
05:18:53 <accel> as if there's interaction between the parts
05:19:04 <monokrome> In what part?
05:19:09 <accel> with my midi synth, I don't think I can create anything like that
05:19:27 <accel> well, for one there seems to be a single continuous note
05:19:29 <accel> that is slowly rising
05:19:35 <monokrome> Well, your MIDI isn't tied to a synth yet
05:19:36 <accel> whereas in midi, i end up creating discrete notes
05:19:36 <monokrome> Right?
05:19:42 <ion> Just modulation of some filters and effects
05:19:54 <accel> hmm
05:19:58 <accel> maybe I need to read up on OSX audio units
05:20:24 <monokrome> I think that it's two separate notes/instruments, the second one has a phaser and attack
05:21:19 <monokrome> I guess it could also be a really slow flange
05:25:51 <accel> dumb question
05:25:54 <accel> generally
05:25:57 <accel> what is midi, and what is synth?
05:26:21 <ion> Synthesizer generates sound (in this case). MIDI is an event-based protocol.
05:26:41 <accel> so synth is continuous an midi discrete?
05:26:58 <ion> I guess one could say so.
05:27:04 <accel> http://zynaddsubfx.sourceforge.net/demo01.ogg <-- does this sound like FM modulation?
05:27:17 <cheater00> wow someone is super-confused
05:27:21 <accel> i.e. A sin (w_1 * t + B sin ( w_2 * t) )
05:27:25 <cheater00> accel: a synthesizer is something that makes sound
05:27:30 <xplat> midi is a protocol for communicating notes among input devices, sequencers, and synthesizers.  synth(esizer) is a component that generates sound according to midi events it receives
05:27:37 <cheater00> in the 80s, people wanted to connect such things together, to control them
05:27:44 <cheater00> using e.g. sequencers which would store notes
05:27:45 <accel> to call me confused would be an understatement; it implies I have a little bit of understanding
05:27:46 <monokrome> accel: MIDI is a protocol used in order to provide events in order to replicate the state of an instrument
05:27:59 <cheater00> the mechanical, electrical and electronic protocol for that developed in the 80s is called midi.
05:28:10 <DRMacIver> Hm. So, looks like the Map a (Map a b) is much slower than the Map (a, a) b. 
05:28:10 <cheater00> that's all
05:28:19 <accel> so midi + synth are orthagonal
05:28:22 <cheater00> you just get a midi cable and connect stuff. midi is used to connect things.
05:28:23 <cheater00> yes.
05:28:25 <DRMacIver> I wonder if using ByteStrings would help here. The performance is all in their use as map keys, so maybe not..
05:28:27 <ion> Dunnot about FM, but the low-pass filter is being modulated and there seems to be a reverb.
05:28:53 <accel> so discrete midi sounds; shoved through the right synth instrument, can come out all continuous
05:28:56 <accel> so discrete midi sounds; shoved through the right synth instrument, can come out all continuous ?
05:29:06 <ion> There are no MIDI sounds
05:29:07 <xplat> DRMacIver: you do a lot of repeated lookups in the map, so i think interning your string keys would be a big win
05:29:17 <accel> so discrete midi events; shoved through the right synth instrument, can come out all continuous ?
05:29:32 <accel> ion: btw; thanks for being pendatic; I feel like using the wrong words is part of my confusion
05:29:45 <accel> i.e. midi sound is confusing me; whereas if I say midi events, it makes much more sense
05:30:12 <ion> MIDI can say “note middle A on” and a person interpreting the command can hit the piano key with her finger. Or a synthesizer can begin generating a sine wave. Or a robot can begin turning his head.
05:30:42 <accel> can "note middle A on" = "sudo make me a sand witch", "note middle B on" = "add turkey to said sandwhich", and "note C on" = do the dishes?
05:30:53 <DRMacIver> xplat: Interning them to what? Ints?
05:31:05 <ion> Sure, if you want to interpret them that way. The MIDI standard has nothing against it.
05:31:24 <accel> so it's not anti-feminist?
05:32:25 <cheater00> accel: that's just a hypersaw with an SVF low pass filter on it, some chorus, and reverb.
05:32:46 <accel> holy shit, I don't know the matheamtical model for any of those words
05:32:50 <accel> what book do you recommend I read?
05:33:12 <cheater00> none, just get some synths and poke around.
05:33:24 <cheater00> and google each of those.
05:33:31 <cheater00> there are no books i could recommend.
05:33:45 <accel> so it's like the matrix
05:33:47 <accel> can not be taught
05:33:48 <ion> Indeed. Get an intuitive understanding of what the effects do by playing with them, and then look up how they work.
05:33:49 <accel> only experienced
05:34:29 <cheater00> yeah something like that.
05:34:32 <cheater00> welcome to the real world.
05:35:33 <cheater00> there's actually a lot of interest about digital music production in the haskell world
05:35:38 <cheater00> like, i am interested
05:35:55 <cheater00> that means that more than 1% of all people talking here are interested in that
05:36:04 <ion> me too
05:36:13 <mreh> play everything, then edit later
05:36:19 <cheater00> lately BONUS told me he's getting into it too :p
05:38:58 <paolino> time for #haskell-music
05:39:26 <monokrome> cheater00: How do you represent more than 1%? :/
05:39:58 <cheater00> paolino: nah, let's just spam this place here
05:40:03 <monokrome> 1 person = 0.142045455% of this channel's users
05:40:15 <paolino> and produce a sound for haskell.org
05:40:47 <cheater00> monochrom: i said "people talking here"
05:40:49 <cheater00> :D
05:41:06 <monokrome> Ah! Touché.
05:41:15 <paolino> cheater00: not until we have an arrow instance for music
05:41:37 * monokrome wishes that he got that joke :(
05:41:41 <DRMacIver> xplat: Interning to ints didn't seem to be a huge win. Maybe if I combine it with the nested maps and use IntMap.
05:41:54 <cheater00> actually there was recently a post about a functional style language similar to what csound and puredata do
05:42:07 <cheater00> but it was a m*ndfuck when he started using like monads or something
05:42:38 <accel> paolino: registered
05:43:01 <accel> cheater00: who is this?
05:43:05 <accel> i've been reading the csound book lately
05:43:09 <accel> and yeah, it matches haskell very closely
05:43:14 <accel> the whole data flow feel to it
05:43:18 <accel> and timing matches FRP
05:43:36 <cheater00> accel: who is what?
05:43:40 <monokrome> cheater00: In a good way or a bad way? I'd think that monads would be useful in a lot of ways
05:44:00 <cheater00> monokrome: in an "i don't get it" way
05:44:04 <monokrome> ah
05:44:26 <accel> cheater00: who wrote that post about haskell and csound/puredata
05:44:38 <ion> cheater00: Do you understand monads in general?
05:45:17 <cheater00> ion: somewhat, but not fully.
05:45:26 <paolino> there is the hutton post today about them linked on reddit
05:46:08 <cheater00> url?
05:46:26 <paolino> clean, without any mention to real world examples
05:46:48 <paolino> http://www.cs.nott.ac.uk/~gmh/monads
05:48:13 <DRMacIver> Hm. If only there were an IntMap  for specific sized integers.
05:49:12 <DRMacIver> I can probably make this a lot faster by cheating and assuming integers are always 64-bit, but that would be gross.
05:57:41 <hpc> DRMacIver: make one!
05:59:16 <hpc> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/src/Data-IntMap.html#IntMap
05:59:54 <hpc> class SmallKeyMappable a ...
05:59:59 <DRMacIver> Ah, combining the interning with the strictness helps a lot more than either on their own.
06:00:14 <hpc> data SmallKeyMappable a => SmallMap a b = ...
06:00:41 <DRMacIver> If I start rewriting the standard library as part of my "Should I be using Haskell for this project" evaluation then I think I know the answer to the question. :)
06:01:02 <hpc> ;)
06:01:38 <DRMacIver> Ah ha, this latest optimisation has moved the hot spot to something else now.
06:02:08 <parcs> DRMacIver: take a look at the unordered-containers package
06:02:13 <hpc> i was going to suggest putting it on hackage, so it IS in the standard library :P
06:02:18 <hpc> or that
06:02:21 <DevHC> @quote /me
06:02:21 * lambdabot says: trololololo
06:03:07 <DRMacIver> parcs: Hm. I tried hamt earlier. Now that my keys are strict Int pairs that might be more successful.
06:03:11 <DRMacIver> thanks
06:03:11 <DevHC> @quote /quit
06:03:11 <lambdabot> /quit says: PWNT
06:03:18 <DevHC> aw
06:06:13 <DRMacIver> Not too surprising. / isn't actually part of the IRC protocol, it's just a client convention.
06:08:06 <DevHC> /me is surprizing
06:08:15 <DevHC> ie.
06:08:17 <DevHC> @quote /me
06:08:17 * lambdabot says: trololololo
06:08:41 <Palmik> since it's predefined for that particular use of @quote? :P
06:08:47 <DevHC> orly
06:09:03 <Palmik> yarly
06:09:25 <DevHC> @remember lambdabot trololololo
06:09:25 <lambdabot> Good to know.
06:09:28 <DevHC> @quote lambdabot
06:09:28 <lambdabot> lambdabot says: i dont english make understand i do not. how to what means bot
06:09:37 <DevHC> @quote /me
06:09:37 * lambdabot says: trololololo
06:09:42 <hpc> @quote lambdabot
06:09:42 <lambdabot> lambdabot says: i 4M THe cooLES+ bo+ e\/eR
06:09:51 <hpc> @help quote
06:09:51 <lambdabot> quote <nick>
06:09:51 <lambdabot> remember <nick> <quote>
06:09:51 <lambdabot> Quote somebody, a random person, or save a memorable quote
06:09:58 <hpc> :( can't list quotes
06:10:34 * DevHC registers a million quotes while someone creates a quote listing command
06:11:39 <Zao> @quote Zao
06:11:39 <lambdabot> Zao says: Avoid Harrop At All Costs; Our new and glorious motto.
06:13:23 <hpc> @quote hpc
06:13:23 <lambdabot> hpc says: jokes are subject to an incompleteness theorem; if you can prove they are funny, they were never good jokes to begin with
06:13:36 <hpc> lol
06:13:48 <merijn> I'm pretty sure that's not right...
06:14:57 <hpc> @quote hpc
06:14:57 <lambdabot> hpc says: jokes are subject to an incompleteness theorem; if you can prove they are funny, they were never good jokes to begin with
06:15:01 <hpc> huh
06:15:29 <DevHC> @remember hpc @quote hpc
06:15:29 <lambdabot> Done.
06:15:37 <DevHC> @quote hpc
06:15:37 <lambdabot> hpc says: in soviet russia, yoda speaks flawless english
06:15:48 <mauke> DevHC: what are you doing?
06:15:53 <DevHC> trolling u.
06:16:00 <DevHC> @pl let f 4 = 4 in 1337
06:16:00 <lambdabot> 1337
06:16:02 <DevHC> @pl let f 4 = 5 in 1337
06:16:02 <lambdabot> 1337
06:16:03 --- mode: ChanServ set +o mauke
06:16:03 --- mode: mauke set +q $a:DevHC
06:16:10 <mauke> averted
06:16:53 --- mode: mauke set -o mauke
06:17:18 <TTimo> meanie
06:17:30 <alpounet> deserved
06:18:10 <hpc> he confessed :P
06:19:22 <hpc> :t let 4 = 5 in False
06:19:23 <lambdabot> Bool
06:19:29 <hpc> > let 4 = 5 in False
06:19:30 <lambdabot>   False
06:19:32 <hpc> neat
06:19:38 <hpc> > let 4 = 5 in 4
06:19:39 <lambdabot>   4
06:19:46 <hpc> > let 4 = 5 in 5
06:19:46 <lambdabot>   5
06:19:49 <hpc> ha!
06:20:10 <parcs> > π
06:20:11 <lambdabot>   Not in scope: `
06:20:19 <hpc> @let π = pi
06:20:19 <lambdabot>  Defined.
06:20:22 <hpc> > π
06:20:24 <lambdabot>   3.141592653589793
06:20:25 <hpc> :D
06:20:46 <parcs> @let τ = 2 * π
06:20:47 <lambdabot>  Defined.
06:22:23 <burp> > τ / 3
06:22:24 <lambdabot>   2.0
06:22:36 <burp> pi is 3, it's proven!
06:22:51 <hpc> @let ε = (2 ** -53) :: Double
06:22:51 <lambdabot>  <local>:3:5:
06:22:51 <lambdabot>      Precedence parsing error
06:22:51 <lambdabot>          cannot mix `**' [infixr ...
06:22:54 <hpc> humbug
06:23:00 <hpc> @let ε = (2 ** (-53)) :: Double
06:23:01 <lambdabot>  Defined.
06:23:06 <hpc> > ε
06:23:08 <lambdabot>   1.1102230246251565e-16
06:23:17 <Taejo> > τ
06:23:18 <lambdabot>   6
06:23:35 <Taejo> > let τ = 2 * π in ( τ, π )
06:23:36 <lambdabot>   (6,3)
06:23:44 <hpc> :t τ
06:23:44 <Taejo> did I miss something?
06:23:44 <lambdabot> <no location info>: not an expression: `'
06:23:50 <hpc> :t τ
06:23:51 <lambdabot> <no location info>: not an expression: `'
06:23:56 <Taejo> > π
06:23:58 <lambdabot>   3
06:24:00 <hpc> :t π
06:24:00 <lambdabot> <no location info>: not an expression: `'
06:24:02 <hpc> :(
06:24:13 <hpc> :t 2 * pi
06:24:13 <lambdabot> forall t. (Floating t) => t
06:24:14 <parcs> you can override things in a pm with lambdabot
06:32:20 <Panaetius> how can I map a function with the signature "Int->Int->Tile->IO Bool" over a "Vector (Vector Tile)" , with the two ints being the first respectively second index of of the vector? if it wasn't Monadic I'd do somethin along the lines of "imap (\x v-> imap (\y t-> f x y t) v) vector" but I'm somewhat lost doing it with monads. it should be something with liftM'ing the Vector.imap, i guess, but I can't get it to work
06:32:59 <DRMacIver> parcs: Thanks, unordered containers was a big win. Shaved another second and change off the runtime
06:33:13 <parcs> DRMacIver: nice
06:34:01 <paolino> :t sequence
06:34:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:34:17 <Panaetius> ah, thanks :)
06:34:21 <paolino> :t sequence . sequence
06:34:22 <lambdabot> forall a. [[a]] -> [[a]]
06:34:35 <hpc> sequence . sequence = id
06:35:12 <hpc> Panaetius: what i would do is what you wanted to do first, so you have Vector (Vector (IO Bool)), then do whatever needs to be done to run the actions in sequence
06:35:24 <paolino> :t \x -> sequence x >>= sequence
06:35:25 <aristid> > sequence . sequence $ [[1,2],[3,4]]
06:35:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m (m a)] -> m [a]
06:35:26 <lambdabot>   [[1,1,2,2],[1,1,2,4],[1,1,3,2],[1,1,3,4],[1,4,2,2],[1,4,2,4],[1,4,3,2],[1,4...
06:35:32 <aristid> hpc: disproved.
06:35:51 <hpc> aristid: lies! i reject your reality and substitute my own
06:35:54 <hpc> :P
06:36:11 <hpc> > sequence [[1,2],[3,4]]
06:36:12 <paolino> hpc we have a prime minister for that
06:36:12 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
06:36:45 <aristid> :t iterate sequence
06:36:46 <lambdabot> forall a. [[a]] -> [[[a]]]
06:36:48 <hpc> > last . sequence . sequence $ [[1,2],[3,4]]
06:36:49 <lambdabot>   [3,4,3,4]
06:37:03 <aristid> > iterate sequence [[1,2],[3,4]]
06:37:04 <lambdabot>   [[[1,2],[3,4]],[[1,3],[1,4],[2,3],[2,4]],[[1,1,2,2],[1,1,2,4],[1,1,3,2],[1,...
06:37:16 <aristid> > map length $ iterate sequence [[1,2],[3,4]]
06:37:20 <lambdabot>   mueval-core: Time limit exceeded
06:37:26 <DRMacIver> Hmm. Now I'm using unordered containers I can't profile. It says to make sure I've installed the profiling libraries for the package, but I don't know how to do that
06:37:27 <aristid> *sniff*
06:38:02 <hpc> > iterate sequence [[1,2],[3,4]]
06:38:02 <paolino> :t mapM sequence
06:38:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [[a]]
06:38:05 <lambdabot>   [[[1,2],[3,4]],[[1,3],[1,4],[2,3],[2,4]],[[1,1,2,2],[1,1,2,4],[1,1,3,2],[1,...
06:38:15 <jmcarthur> DRMacIver: cabal install hashable unordered-containers -p --reinstall
06:38:24 <jmcarthur> DRMacIver: -p for profiling, --reinstall because you already have it
06:38:29 <DRMacIver> Ah, thanks.
06:39:56 <paolino> Panaetius: mapM sequence matches the type, using spj theorem it should be correct
06:40:05 <jmcarthur> ninly: random highlight!
06:40:27 <parcs> DRMacIver: set library-profiling to True in ~/.cabal/config to globally enable building of profiling libraries
06:40:33 <jmcarthur> ^^
06:41:35 <DRMacIver> parcs: Ah, great. Thanks.
06:41:37 <Panaetius> paolino: so if I need Data.Vector.imap i just liftM it?
06:42:16 <DRMacIver> (I'm now having to reinstall a whole pile of dependencies. Yay)
06:42:24 <paolino> Panaetius: what is the type of imap (\x v-> imap (\y t-> f x y t) v) ?
06:42:35 <hpc> :t imap
06:42:36 <lambdabot> Not in scope: `imap'
06:42:44 <Panaetius> :t Data.Vector.imap
06:42:44 <lambdabot> Couldn't find qualified module.
06:42:59 <Panaetius> (Int -> a -> b) -> Vector a -> Vector b
06:43:03 <hpc> :t let imap = id in imap (\x v-> imap (\y t-> f x y t) v)
06:43:04 <lambdabot> forall t t1 t2 t3. (SimpleReflect.FromExpr (t -> t1 -> t2 -> t3)) => t -> t1 -> t2 -> t3
06:45:47 <paolino> Panaetius: it should be Vector (Vector Tile) -> IO [[Bool]]
06:46:07 <paolino> Vector (Vector Tile) -> [[IO Bool]]
06:47:24 <Panaetius> yeah I guess so
06:47:34 <paolino> mapM sequence $ imap (\x v-> imap (\y t-> f x y t) v) vector
06:47:52 <paolino> should be IO [[Bool]]
06:49:25 <Panaetius> uhm Couldn't match expected type `[[m0 a0]]'
06:49:25 <Panaetius>                 with actual type `V.Vector (V.Vector (IO Bool))'
06:50:21 <Panaetius> ah
06:50:24 <paolino> because imap is not (a -> b) -> Vector a -> [b]
06:51:09 <parcs> Panaetius: do you want to result of the mapping to be a list or a vector?
06:51:36 <Panaetius> i don't really care, it's discarded anyways
06:51:52 <hpc> :t mapM sequence_
06:51:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [()]
06:52:02 <hpc> :t mapM_ sequence
06:52:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m ()
06:52:56 <paolino> to use mapM_ sequence you must toList . map toList 
06:53:06 <paolino> :t toList . map toList
06:53:07 <lambdabot> Not in scope: `toList'
06:53:07 <lambdabot> Not in scope: `toList'
06:54:16 <hpc> :t let toList = const [] in toList . map toList
06:54:16 <lambdabot> forall a a1. [a1] -> [a]
06:54:27 <hpc> :t let toList = const [] in toList . fmap toList
06:54:28 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => f a1 -> [a]
06:54:43 <hpc> (where a = [whatever] and a1 = Vector whatever
06:54:44 <hpc> )
06:55:14 <paolino> if Vector is instance of Foldable
06:55:29 <Panaetius> V.mapM_ sequence $  V.imap ( \x v->V.toList (V.imap (\y t ->f x y t) v)) vector
06:55:30 <Panaetius> works
06:55:33 <Panaetius> Thanks! :)
06:55:46 <hpc> :D
06:57:09 <paolino> mh, I suppose the mapM_ is another and is working on a Vector
06:58:13 <paolino> :t Foldable.mapM_
06:58:14 <lambdabot> Couldn't find qualified module.
06:58:19 <Panaetius> yes, I imported Data.Vector as V and it's V.mapM_
06:58:27 <paolino> :t Data.Foldable.mapM_
06:58:28 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Foldable.Foldable t, Monad m) => (a -> m b) -> t a -> m ()
06:58:35 * Panaetius wonders why there's no Data.Vector.sequence, as every other monadic function seems to exist
06:58:36 <paolino> ok
06:59:05 <paolino> Panaetius: there is Data.Foldable.sequence_
06:59:38 <paolino> :t Data.Foldable.mapM_ Data.Foldable.sequence_
06:59:39 <lambdabot> forall (t :: * -> *) (m :: * -> *) a (t1 :: * -> *). (Data.Foldable.Foldable t, Monad m, Data.Foldable.Foldable t1) => t1 (t (m a)) -> m ()
07:00:01 <paolino> which avoid the toList
07:00:58 <Panaetius> hmm I'll have to give that a try (right after i committed this to my local git repo...) thanks :)
07:02:34 <DRMacIver> Ok. Time to finally go with the array approach, now that I'm already interning everything.
07:03:03 <DRMacIver> If I wanted an unboxed 2D array of doubles I could use in ST then freeze for use outside ST, which of the 500 array types do I want? :)
07:04:05 <paolino> do you write to it often ?
07:04:05 <DRMacIver> I mean, unboxed is probably not the priority, I likely have bigger performance issues than boxing, so I guess just STArray as a starting point
07:04:19 <DRMacIver> paolino: I have basically one massive chunk of writes at the beginning then it's read only
07:04:30 <paolino> then array is ok
07:05:06 <DRMacIver> Essentially I have a [(Int, Int, Double)] and I want to do the equivalent of for((i, j, x) in list) myArray[i][j] += x
07:05:16 <DRMacIver> Then freeze the array after that point
07:05:25 <aristid> :t Data.Traversable.sequence
07:05:26 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
07:05:44 <aristid> Panaetius: vector is Traversable, isn't it?
07:05:54 <paolino> DRMacIver: and STArray at the beginning because write is interleaved with read
07:06:03 <Panaetius> yes
07:06:16 <Panaetius> or
07:06:17 <Panaetius> uhm
07:06:26 <Panaetius> depends on what you mean by traversable? :)
07:06:35 <DRMacIver> paolino: Ok. 
07:06:40 <paolino> an instance of Traversable
07:06:51 <aristid> Panaetius: is it an instance of Traversable? i can't be bothered to look it up :P
07:06:57 <DRMacIver> Now let's see if I can figure out how to use STArray... I don't think I ever used it (and my Haskell is hella rusty. First non-trivial program in > a year)
07:07:35 <Panaetius> I have no idea. http://hackage.haskell.org/packages/archive/vector/0.7.0.1/doc/html/Data-Vector.html
07:08:03 <Panaetius> you can fold it, zip it, map it, access individual indices, get the head or tail
07:08:06 <paolino> you can check it up with :i Vector if it's not a synonym
07:08:12 <Panaetius> that's about all I know about Vector
07:09:36 <paolino> oh, it's not Traversable nor Foldable
07:10:05 <paolino> name duplication all around
07:10:08 <Panaetius> why would they implement fold without making it an instance of Foldable?
07:10:24 <aristid> Panaetius: bah. it SHOULD be instances of both.
07:10:29 <c_wraith> Because the unboxed versions don't have the right kinds
07:10:42 <c_wraith> and they wanted the same interface across the boxed and unboxed versions
07:10:57 <c_wraith> Though maybe the boxed ones have the right kind?
07:11:05 <c_wraith> And the instances?
07:11:09 <rostayob> wow, highlighting kate is 160MB
07:11:09 <lambdabot> rostayob: You have 1 new message. '/msg lambdabot @messages' to read it.
07:11:18 <c_wraith> Guess not.
07:11:31 <aristid> c_wraith: i think the boxed ones have the right kind. they have a foldr function with the right type, so Foldable would be posisble
07:12:02 <jmcarthur> the boxed version is missing several instances, at least last i checked
07:12:04 <c_wraith> Maybe it's just general protest against the design of those interfaces?
07:12:14 <aristid> or just lack of instances
07:12:17 <aristid> *shrug*
07:12:31 <paolino> there is Monoid
07:12:41 <jmcarthur> no Functor, Applicative, or Monad! :\
07:13:05 <paolino> it's an haskell environment
07:13:23 <aristid> jmcarthur: not even Functor? :/
07:13:35 <jmcarthur> correct
07:13:41 <paolino> it has his own fmap
07:13:47 <jmcarthur> its own map
07:13:50 <jmcarthur> but fmap is nicer
07:14:27 <jmcarthur> means you can use plug in other types or use some of the generic functions aready using fmap without rewriting them
07:14:28 <paolino> it has an 'f' in front
07:14:43 <jmcarthur> i miss <$> a lot for things lacking Functor instances
07:14:44 <c_wraith> It really looks like all the classes that the unboxed versions couldn't use were left out
07:15:08 <jmcarthur> that's probably it, but that seems like stubbornness to me
07:15:22 <paolino> c_wraith: that is not fair
07:15:34 <c_wraith> I didn't say it's a good reaso
07:15:36 <c_wraith> n
07:15:38 <aristid> couldn't there be unboxed variants of these classes? :D
07:16:01 --- mode: ChanServ set +o mauke
07:16:01 --- mode: mauke set -q $a:DevHC
07:16:07 <paolino> type familiar classes
07:16:51 --- mode: mauke set -o mauke
07:17:16 <sshc> How can I change my ~/.cabal/conf to configure GHC to link dynamically?
07:19:44 <c_wraith> I wonder if you can use ? and ?? in kind signatures, if you enable that extension explicitly
07:21:52 <sshc> Will adding --enable-executable-dynamic to the flags: field do that?
07:22:03 <Palmik> Hmm, why is this code http://codepad.org/TnjKZpDw causing this http://codepad.org/tRgdSB2H ? the rest should return [Document] in some monad, I want all the documents converted to Post, so I apply Doc data constructor on them and then typed (to cast them to post). What am I doing wrong? (The type definitions an context of the used functions http://codepad.org/raSfu7bU)
07:22:06 <sshc> (What exactly does the "flags" field set?)
07:23:40 <c_wraith> sshc: there's a flag to set it directly.  Not that I remember what it's called
07:24:54 <sshc> c_wraith: What do you remember "directly"?  Where do I pass the flag?
07:25:13 <sshc> s/remember/mean/
07:25:24 <c_wraith> sshc: there's an explicit option for it.  if your .cabal file is old, try backing it up, then creating a new one and looking for the option
07:25:44 <sshc> c_wraith: I did, but no options contain "dynamic"
07:25:59 <c_wraith> hmm.  I could have sworn there was an option for it.  *shrug&
07:26:24 <DRMacIver> Hm
07:26:32 <sshc> cabal-install version 0.10.2
07:26:32 <sshc> using version 1.10.1.0 of the Cabal library 
07:26:41 <Panaetius> :t liftIO
07:26:42 <lambdabot>     Ambiguous occurrence `liftIO'
07:26:42 <lambdabot>     It could refer to either `Control.Monad.Error.liftIO', imported from Control.Monad.Error
07:26:42 <lambdabot>                           or `Control.Monad.Logic.liftIO', imported from Control.Monad.Logic
07:26:42 <DRMacIver> Moving from using the undordered containers hash map to STUArray makes not a jot of difference performance wise
07:26:52 <DRMacIver> There's almost literally nothing in it
07:26:59 <Panaetius> :t Control.Monad.Logic.liftIO
07:27:00 <lambdabot> forall a (m :: * -> *). (Control.Monad.Logic.MonadIO m) => IO a -> m a
07:27:03 <sshc> c_wraith: Can I add it to the "flags" field?
07:27:22 <c_wraith> sshc: I don't know.
07:29:32 <DRMacIver> Is there anything obviously wrong with my use of UArray / STUArray in here? https://github.com/DRMacIver/hs-rank-aggregation/blob/master/Algorithms/RankAggregation.hs
07:31:58 <DRMacIver> Ah, if I mark updateArray as inline it's suddenly *much* better
07:32:17 <copumpkin> :o
07:32:22 <c_wraith> ...  It should inline that automatically if you're using -O2
07:33:12 <merijn> If I want to use eval in Haskell, any pointers on whether this already exists, and if not how to start implementing it?
07:33:14 <hpc> not relying on -O2 is an admirable goal
07:33:33 <hpc> merijn: eval as in mueval, or as in perl backticks?
07:33:35 <c_wraith> hpc: benchmarking without -O2 is a bit of a silly goal
07:33:50 <DRMacIver> c_wraith: I've got O3 on. Was that a bad choice?
07:33:51 <hpc> ($files = `ls -a`; for example)
07:34:01 <merijn> hpc: As in, String -> Haskell code execution
07:34:01 <hpc> @quote -O2
07:34:01 <lambdabot> dons says: looks like a job for -O2
07:34:06 <hpc> @quote -O2
07:34:06 <lambdabot> dons says: looks like a job for -O2
07:34:08 <parcs> O3 doesn't exist
07:34:13 <c_wraith> DRMacIver: 3 is not a supported optimization level in GHC.  Though I think it's the same as -O2
07:34:24 <DRMacIver> Oh. Then why the hell doesn't it complain when you use it?
07:34:38 <DRMacIver> It shaved off a lot of time when I turned it on, so I assume it's doing something valid.
07:34:44 <hpc> merijn: that's mueval
07:35:19 <merijn> lambdabot/ghci already do this, but I'm not sure how usable that code is for other applications?
07:36:07 <c_wraith> merijn: there are lots of options.  mueval is what lambdabot uses
07:36:20 <c_wraith> merijn: mueval is designed for safely sandboxed execution
07:37:00 <c_wraith> merijn: there are also hint and hs-plugins for different directions of wrapping the ghc api, as well as using the ghc api directly
07:37:31 <DRMacIver> I've currently got half the time being spent in sum2D. Any way I can ask GHC profiling to give me a more detailed breakdown of that function?
07:38:03 <merijn> c_wraith: Safety is not really an issue in my case, since this is only for local user code evaluation, although I guess not-deadlocking might be a nice goal
07:38:19 <parcs> DRMacIver: compile with -auto-all
07:38:34 <c_wraith> DRMacIver: you can use {-# SCC "foo" #-} annotations.
07:40:39 <DRMacIver> parcs: I am compiling with auto-all. I'm asking about how to get more detailed within a specific function.
07:40:47 <DRMacIver> Yeah, looks like the cost center annotations are what I need. Thanks
07:50:34 <DRMacIver> Ok, so I'm seeing a huge amount of time being spent just in readArray and writeArray. Is there anything I can do about that?
07:51:53 <copumpkin> unsafeRead and unsafewrite?
07:51:58 <DRMacIver> e.g. I've got a 2D array, but the API seems to require a lot of boxing due to the indices being tuples. 
07:52:09 <copumpkin> or do block operations on Vector
07:52:49 <DRMacIver> block operations?
07:52:58 <copumpkin> well, haven't actually looked at the code
07:53:05 <copumpkin> but avoid reading individual elements out at a time
07:53:06 <copumpkin> and writing them
07:53:42 <copumpkin> may not be possible for your particular application though
07:53:47 <DRMacIver> That's not really possible here.
07:53:50 <Botje> DRMacIver: are the strict tuples also instances of Ix?
07:54:26 <Botje> it appears so
07:54:27 <DRMacIver> Botje: Ah, I'd replaced the strict tuples with normal tuples again because they weren't and I wasn't sure how to make them so. 
07:54:37 <DRMacIver> Ah, is there a strict tuple type in the standard library?
07:54:38 <Botje> DRMacIver: Data.Strict.Tuple? :)
07:54:42 <DRMacIver> Ah ha. Thanks.
07:57:09 <copumpkin> DRMacIver: anyway, readArray and writeArray do bounds checking at every read/write
07:57:28 <copumpkin> if you're positive you're doing the right thing, the unsafe versions of those don't waste time doing that
07:58:11 <copumpkin> also,                                 sequence_ [ updateArray result ix (+t) | (ix, t) <- ls]
07:58:19 <copumpkin> how is that not just a map over the whole array?
07:58:31 <copumpkin> oh I see
07:59:12 <copumpkin> that'd still be expressed pretty nicely as a mapM_ or similar
07:59:18 <FUZxxl> Just ran pointfree '\(a,b) -> (foo:a,b)', output was first (LBrace :), where is first defined?
07:59:57 <Botje> Control.Arrow
08:00:13 <copumpkin> ??
08:00:14 <copumpkin> no
08:01:18 <FUZxxl> Oh yes.
08:01:23 <FUZxxl> Thank you.
08:01:44 <FUZxxl> But it only makes sense, if you specialize first to the function arrow.
08:03:17 <DevHC> testing
08:05:32 <DRMacIver> Botje: Strict tuples didn't appear to help at all. 
08:05:45 <DRMacIver> copumpkin: I'm reasonably positive I'm doing the right thing. Positive enough to at least try it. 
08:06:04 <iman> @quote
08:06:04 <lambdabot> LarryWall says: <TimToady> learning Haskell itself is easy--I've done it several times already
08:06:39 <aristid> LarryWall?
08:06:47 <Botje> the very same
08:06:50 <copumpkin> DRMacIver: actually....
08:06:53 * hackagebot protocol-buffers 1.8.3 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-1.8.3 (ChrisKuklewicz)
08:06:59 <copumpkin> DRMacIver: you're creating a new array and statefully mutating it
08:07:08 <copumpkin> that's the only array mutation thing you're using, right?
08:07:35 <DRMacIver> Yes
08:07:49 <DRMacIver> The arrays are only being used for fast indexing, I don't care about mutability
08:07:53 * hackagebot protocol-buffers-descriptor 1.8.3 - Text.DescriptorProto.Options and Google Protocol Buffer specifications  http://hackage.haskell.org/package/protocol-buffers-descriptor-1.8.3 (ChrisKuklewicz)
08:07:55 * hackagebot hprotoc 1.8.3 - Parse Google Protocol Buffer specifications  http://hackage.haskell.org/package/hprotoc-1.8.3 (ChrisKuklewicz)
08:08:11 <DRMacIver> But right now that initial "build the array" step is taking a lot of time.
08:08:25 <copumpkin> then drop the mutable one altogether, and go for listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
08:08:42 <copumpkin> there's really a missing function there that does exactly waht you want
08:08:47 <DRMacIver> copumpkin: That doesn't do the right thing. 
08:08:49 <copumpkin> and we've discussed adding one but it hasn't happened yet
08:09:03 <copumpkin> what'd be nice is an (i, i) -> (i -> e) -> a i e
08:09:12 <copumpkin> DRMacIver: oh?
08:09:14 <rwbarton> does listArray fuse with stuff?
08:09:20 <copumpkin> not array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e either?
08:09:24 <DRMacIver> copumpkin: The fact that it's doing adds is significant. The expectation is that there's a lot of duplication
08:09:29 <copumpkin> rwbarton: the standard arrays are horrible
08:10:01 <copumpkin> DRMacIver: frankly, I'd use repa for this :P
08:10:06 <DRMacIver> repa?
08:10:09 <copumpkin> gives you multidimensional arrays and is actually designed for speed
08:10:11 <copumpkin> @hackage repa
08:10:11 <lambdabot> http://hackage.haskell.org/package/repa
08:10:17 <rwbarton> I want the (i, i) -> (i -> e) -> a i e function sometimes but ideally you could build it out of listArray efficiently
08:10:33 <copumpkin> yeah
08:10:36 <rwbarton> DRMacIver: how about accumArray?
08:10:46 <rwbarton> :t accumArray
08:10:47 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
08:11:05 <DRMacIver> rwbarton: Ah, yes, that does do what I want.
08:11:10 <copumpkin> it's not actually specialized to Array
08:11:21 <DRMacIver> Well except that I have a UArray
08:11:35 <copumpkin> yeah, what I just said :)
08:11:38 <copumpkin> accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
08:11:39 <rwbarton> copumpkin: true, why did lambdabot say what it did then
08:11:50 <copumpkin> rwbarton: beats me! :P
08:11:57 <rwbarton> fair enough :)
08:12:04 <copumpkin> rwbarton: did you get the boston haskell announcement btw?
08:12:09 <rwbarton> yeah I saw it
08:12:39 <rwbarton> I'll probably go
08:12:52 <copumpkin> cool :)
08:14:09 <DRMacIver> No performance difference from using accumArray
08:14:21 <DRMacIver> I'll try the unsafe versions.
08:15:16 <DRMacIver> Hm. Where/what are the unsafe options? Wikis seem to claim unsafeAt for reads, but I can't find it in the docs
08:15:18 <copumpkin> hmm, accumArray should be using unsafe versions behind the scenes
08:16:09 <copumpkin> oh here
08:16:12 <copumpkin> GHC.Arr
08:16:25 <copumpkin> oh, that's where the non-polymorphic ones come from
08:16:26 <DRMacIver> copumpkin: I can't see why it would be using unsafe versions behind the scenes: There's no safety guarantee from its interface
08:16:40 <copumpkin> oh true
08:17:00 <copumpkin>     unsafeAccumArray :: Ix i => (e -> e' -> e) -> e -> (i,i) -> [(Int, e')] -> a i e
08:17:16 <copumpkin> for IArray a e
08:17:24 <copumpkin> Data.Array.Base
08:18:14 <DRMacIver> ghc seems to think that unsafeAccumArray has a different signature 
08:18:33 <DRMacIver> Ah yes. There it is: It needs an (Int, e')
08:18:34 <rwbarton> does repa have support for multidimensional rectangular arrays?  (as opposed to Vector (Vector a))
08:18:34 <copumpkin> are you using GHC.Arr? that was a mistake
08:18:37 <copumpkin> oh
08:18:54 <copumpkin> rwbarton: yeah, that's its main concern
08:19:01 <copumpkin> as well as doing them parallel-wise :P
08:19:10 <rwbarton> maybe I should look into using it as a target for image reading/writing then
08:19:20 <DRMacIver> So where are these unsafe read and write functions? I can't find them.
08:19:32 <jonkri> how can i get the output of a thread that i create using forkIO? 
08:19:48 <merijn> btw, mueval claims to defang dangerous code, is it possible to partially refang such code? :p
08:20:04 <merijn> jonkri: Use channels/mvar's to communicate?
08:20:10 <copumpkin> DRMacIver: you could always pre-apply the Ix-indexing function
08:20:14 <copumpkin> but     unsafeAt         :: Ix i => a i e -> Int -> e
08:20:14 <copumpkin>     unsafeReplace    :: Ix i => a i e -> [(Int, e)] -> a i e
08:20:19 <jonkri> merijn, thanks
08:20:20 <copumpkin> those are also in the IArray interface
08:20:22 <copumpkin> also Int-indexed
08:20:30 <DRMacIver> Ah, I see. 
08:20:37 <merijn> jonkri: See Control.Concurrent
08:20:42 <copumpkin> not sure why we have no documentation for the array package :P
08:20:45 <frerich_> I just finished (after reading the first five chapters of RWH and a bit of google research) my first Haskell project - a little Tic Tac Toe game in ASCII mode. The source code is available at http://hpaste.org/44899/tictactoe - I'd greatly appreciate any comments by people who are more familiar with Haskell (like, more idiomatic ways to express things, better ways to format the code so that it's easier on the eyes etc.) :-)
08:21:13 <DRMacIver> I could just manually convert this into a 1D array.
08:21:23 <copumpkin> if you do that, I'd definitely recommend going with Vector
08:21:30 <copumpkin> actually
08:21:44 <copumpkin> if you're just using it as a lookup table, you might as well go with one of the memoizers
08:22:58 * copumpkin shrugs :)
08:23:01 <copumpkin> too many options
08:24:30 <DRMacIver> The memoizers are surely just going to be using some sort of map behind the scenes.
08:24:37 <copumpkin> there's an array memoizer
08:24:56 <copumpkin> but if you're accumulating that won't really work
08:26:13 <sonoflilit> frerich_: This was also one of my first projects, and although I'm not the best Haskeller today, I'll have a short look
08:28:29 <DevHC> frerich_: u can use:
08:28:37 <DevHC> import System.IO (hFlush)
08:28:50 <DevHC> also
08:28:57 <DevHC> > splitAt 2 "blarg"
08:28:58 <lambdabot>   ("bl","arg")
08:29:43 <doserj> winsAnyRow = any winsRow [One .. Three]
08:31:13 <parcs> frerich_: add some AI
08:32:31 <doserj> ownCells = all (\c -> maybe False (==p) (board!c))
08:34:11 <sonoflilit> frerich_: I think you'd have shorter and more generic code if you had defined a global ixs = enumFrom One
08:34:51 <sonoflilit> you'd also be able to e.g. winsDiagonal1 = ownsCells (zip ixs $ reverse ixs)
08:35:46 <sonoflilit> most haskellers, in my impression, tend to prefer "a . b c $ d e" to "a (b c (d e))"
08:35:56 <sonoflilit> I usually agree with your choices
08:36:34 <sonoflilit> (fst c, snd c) is just like writing c, and it doesn't look clearer to me
08:37:30 <doserj> instead of your splitAt sep, you could use takeWhile (/=sep) and dropWhile (/=sep)
08:37:44 <doserj> intToCoord is unnecessary if you derive Enum
08:38:05 <sonoflilit> intToCoord is already defined, it is called toEnum
08:38:12 <sonoflilit> beat me to it :P
08:39:31 <doserj> instead of let xy = parseTurn s ; let x = fst xy ; let y = snd y you could simply do let (x,y) = parseTurn s
08:39:43 <sonoflilit> I'd use pattern matching to define (x, y) = Main.splitAt ...  instead of (fst t, snd t)
08:40:44 <sonoflilit> I'd prefer taking as much code from IO to pure
08:41:36 <hpc> doserj: or xy@(x,y) = ..
08:41:38 <sonoflilit> specifically, I'd have a "tryPlay :: String -> Maybe Turn"
08:42:11 <doserj> hpc: right, but xy isn't actually used, I think
08:42:52 <DRMacIver> Manually converting to it a 1D array doesn't appear to help.
08:44:31 <sonoflilit> no, I'd just change getTurn to be :: Board -> String -> Either String Turn
08:45:15 <sonoflilit> and move the IO up to main
08:45:20 <sonoflilit> playGame*
08:45:41 <jonkri> how can i remove a package from my local cabal repository?
08:45:55 <DRMacIver> Although weirdly it's moved the hotspot out of that part entirely.
08:46:48 <sonoflilit> all in all, it is quite clear and readable
08:46:56 <sonoflilit> now implement AI, that's where the fun begins
08:47:11 <doserj> actually, there is no need for splitAt at all. You can write "let (x,y) = read $ '('++s++')' 
08:48:09 <jonkri> i tried moving files from ~/.cabal/{lib,packages} and ~/.ghc/ out of the way but ghc still detects that it's installed
08:48:30 <doserj> ghc-pkg unregister ...
08:50:50 <doserj> isValidTurn row col = (row `elem` [0..2]) && (col `elem` [0..2]) 
08:51:49 <jonkri> thanks
08:58:40 <DRMacIver> Hm. I simply can't seem to get this down to under a second. I'm stalled at about 1.2. Very annoying.
09:01:25 <DRMacIver> (gist updated with latest profiling data if anyone cares: https://gist.github.com/877401 )
09:08:41 <olsner> DRMacIver: based on the names, I'm guessing that swap etc uses tuples? is it possible to unbox them?
09:10:42 <DRMacIver> olsner: It's probably possible, yes. They didn't seem to be taking up that much of the profile any more, so I haven't tried
09:13:58 <olsner> I was thinking it might make the other stuff in allRanksToPG faster
09:14:16 <olsner> still at best 20% of the profile there though
09:14:28 <DRMacIver> It might do. The code breaks out of tuples pretty quickly at this point
09:15:04 <DRMacIver> The code is at https://github.com/DRMacIver/hs-rank-aggregation/blob/master/Algorithms/RankAggregation.hs if you haven't seen it
09:15:24 <DRMacIver> Basically the tuples are just some intermediates generated before they get turned into an array.
09:15:57 <olsner> ooh, source, thanks :)
09:16:56 <DRMacIver> Man, GHC isn't very good at determining which of these functions to inline. I've just got another 0.2 seconds (out of 1.2) off with inline annotations.
09:16:58 <mreh> what's the default ST monad implementation? strict?
09:17:40 <mreh> what exactly is strict about it?
09:17:57 <DRMacIver> ok, that's a lie. It's actually a little over 0.1, which is less exciting.
09:20:11 <olsner> how much faster is IntMap compared to Map?
09:20:26 <bos> olsner: quite a lot faster.
09:20:27 <jmcarthur> much
09:20:44 <DRMacIver> The Maps shouldn't be a bottleneck here though. They're only being applied to < 100 elements.
09:20:51 <DRMacIver> With about two lookups per element
09:20:59 <dmwit> mreh: No, the default implementation of ST is not strict.
09:21:02 <DRMacIver> I moved all the bits where Map was actually important over to array.
09:22:48 <bos> DRMacIver: what's your code supposedta do?
09:23:15 <DRMacIver> bos: rank aggregation. :) 
09:23:33 <DRMacIver> bos: Specifically it takes a bunch of partial rankings of a set of items and combines them into a "best" overall ranking
09:24:06 <DRMacIver> like e.g. hot or not (which has lots of binary rankings) or hammer principle (which typically has > 2 items per ranking)
09:24:23 <bos> DRMacIver: i assume you're troubled by its performance?
09:24:29 <bos> (haven't been watching the conversation)
09:25:03 <DRMacIver> bos: Well, troubled would be going a bit far at this point. I could live with the current performance if I had to - it's about a factor of 8 better than when I started.
09:25:24 <olsner> maybe not "troubled" as much as "not sufficiently impressed" :)
09:25:26 <DRMacIver> but this isn't an outrageously large amount of data, and I'd like it to be able to handle larger, so I'm trying to improve it as far as I can.
09:25:33 <bos> DRMacIver: i'd imagine you're running into a bit of a choke point due to your heavy use of lists.
09:25:56 <bos> have you been shoving it through the profiler?
09:26:11 <bos> nice idiomatic code, as far as it goes, btw.
09:26:11 <DRMacIver> bos: Definitely possible. It's only just hit the point where that could be the case though - previously there were much bigger bottlenecks.
09:26:18 <DRMacIver> bos: Yes, I've been profiling religiously
09:26:50 <bos> so i'd also expect that dictionary passing could be an issue, due to heavy use of typeclasses.
09:27:14 <bos> the compiler may not be generating specialised versions of some of those functions.
09:27:47 <DRMacIver> Hm. I could try turning everything into ints. Now that I'm interning everything before passing it in that should be easy
09:27:51 <DRMacIver> I'll give that a try, thanks.
09:27:59 <DRMacIver> Or is there a way to get the compiler to specialise?
09:28:02 <bos> there is.
09:28:10 <bos> iterateUpTo :: (Eq a) => Int -> Optimiser a -> Optimiser a
09:28:26 <bos> {-# SPECIALIZE iterateUpTo :: Int -> Optimiser Int -> Optimiser Int #-}
09:28:44 <DRMacIver> Ok. Will give that a go. Thanks.
09:28:48 <bos> but i'd take a quick look through the output of ghc-core and see if the compiler isn't actually specialising for you already.
09:28:55 <DRMacIver> Ah, how do I do that?
09:29:02 <bos> cabal install ghc-core
09:29:04 <btutt> non-specialized functions use the dictionary to resolve the methods? i.e. indirect function calls?
09:29:06 <bos> ghc-core MySourceFile.hs
09:29:27 <bos> but since you're exporting everything from your module, it probably isn't specialising the functions.
09:29:34 <djahandarie> Also, if you can think of a faster implementation if you are aware of what is inside of Optimiser, you can write a specialized version by hand and make the compiler rewrite to it automatically when you have an Optimiser Int.
09:29:44 <bos> btutt: right
09:30:25 <bos> DRMacIver: do you have scala code for doing the same thing?
09:30:35 <bos> (since i gather that's your adopted homeland)
09:31:12 <DRMacIver> bos: Actually, I haven't written any Scala in about a year.
09:31:16 <bos> ah
09:31:37 <DRMacIver> bos: I have some (cringe) ruby code which does approximately the same thing, but unsurprisingly the first pass at writing this in Haskell blew this out of the water. :)
09:32:11 <DRMacIver> bos: Ah, does exporting cripple the optimiser?
09:32:28 <DRMacIver> I'm actually only exporting most of this so I could play with it in ghci
09:33:03 <bos> exporting ties its hands, yes.
09:33:09 <DRMacIver> Ok. I'll try limiting that
09:33:12 <olsner> can ghc cross-module-inline all functions or does it choose which ones to put in the .hi files?
09:33:23 <bos> for instance, the optimiser will make different decisions about inlining functions depending on whether or not they're exported.
09:33:23 <DRMacIver> oof. I've just spotted that calculating the element set is actually taking up 23% of the time when I add a call site for that.
09:33:42 <bos> DRMacIver: which function is that?
09:33:57 <bos> olsner: it's picky about what it will choose to inline by default.
09:34:00 <DRMacIver> bos: It's in the where for aggregate, which is why I didn't see it
09:34:08 <DRMacIver> until I added a cost center manually
09:34:39 <DRMacIver> uniq . sort . concat is probably not an ideal way of getting a uniq list of elements in a [[a]]. Suggestions?
09:34:45 <DRMacIver> unique
09:35:03 <bos> i usually use Set.toList . Set.fromList
09:35:53 <bos> or if i know i have ints, IntSet.toList . IntSet.fromList
09:36:06 <DRMacIver> Oh wow.
09:36:24 <DRMacIver> That knocked another half a second off the runtime. Sub-second goal achieved.
09:37:16 <bos> huzzah
09:37:16 <DRMacIver> Which isn't to say I'm going to stop. :) 
09:37:22 <olsner> was that using toList/fromList or changing the export list?
09:37:29 <DRMacIver> That was toList/fromList
09:37:34 <olsner> neat
09:38:34 <DRMacIver> export list doesn't appear to make a jot of difference.
09:39:19 <DRMacIver> I'm surprised that made such a difference actually. 
09:39:29 <aavogt> this probably makes no difference, but:  indices = [0..(length elts - 1)]
09:39:48 <aavogt> should be slower than       indices = zipWith const [0 .. ] elts
09:40:24 <DRMacIver> Looking at the profiling output before and after, elts was taking up 23% and is now taking up 7%, but changing the implementation cut the runtime in half.
09:40:31 <DRMacIver> Which doesn't seem right
09:40:43 <aavogt> oh, the Set can tell you how many elements it has
09:41:57 <DRMacIver> aavogt: True, but we're talking about a list which has 50 elements. 
09:42:04 <DRMacIver> So it's not really a big deal. :)
09:44:49 <btutt> bos: Hrm. Windows I/O isn't even close to the new IO manager approach. Its all about tell me when you're done instead of Unix's tell me when I can send without blocking. Ugh.
09:45:21 <bos> btutt: what?
09:45:46 <btutt> Windows high performance IO using IO copletion ports. its all about when the IO finishes. 
09:46:01 <bos> right.
09:46:12 <btutt> If i'm understanding things correctly the libevent like way is tell the app when the system call won't block.
09:46:32 <rpglover64> Would anyone help me understand the difference between the lazy writer monad and the strict one (I know what it means to be strict/lazy in general, but not in many specific cases)
09:46:35 <bos> yes, that's the legacy of select and poll.
09:47:28 <btutt> Do you think there's less bookeeping with the libevent way? 
09:48:09 <bos> it's just different.
09:48:18 <frerich_> sonoflilit, DevHC,doserj, parcs: Thanks a ton for your feedback! I'm currently trying to apply them, one by one.
09:48:49 <btutt> that makes sense high performance is going to hurt no matter the shape of the solution. ;)
09:49:10 <bos> rpglover64: strict writer deconstructs the state of the monad at each step.
09:49:15 <bos> rpglover64: lazy doesn't.
09:50:09 <rpglover64> bos: If you runwriter on the lazy one and ignore the monoid part, will it never even be computed?
09:50:34 <bos> rpglover64: if you don't look at the end result of the computation, nothing will happen.
09:50:54 <rpglover64> bos: and the strict one?
09:50:57 <bos> but that's true for the strict one too.
09:51:53 <rpglover64> Will switching between the two ever change semantics, or just performance?
09:52:16 <bos> it'll change semantics.
09:52:25 <aavogt> bos: is there a difference between       tell undefined   in the two?
09:52:51 <bos> aavogt: no.
09:52:54 <rpglover64> Okay; can you give an example to think about where the semantics differ?
09:56:02 <bos> rpglover64: sure.
09:56:11 <bos> fst $ runWriter (undefined >> tell "foo")
09:56:28 <bos> with the lazy writer monad, this returns ()
09:56:41 <aavogt> the ~ in the instance here http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-Writer-Lazy.html#WriterT
09:56:42 <bos> with the strict writer monad, it barfs due to the use of undefined
09:57:08 <rpglover64> Got it.
09:57:32 <rpglover64> One more question, related to something I think I recently messed up.
09:59:09 <rpglover64> If at some points I need to force the evaluation of the writer, but then I need to keep using it, but other than that I don't care about strictness, does it matter which one I use? 
10:00:13 <bos> not sure i understand your question.
10:00:40 <bos> but as a general matter, you're probably better off using the strict writer monad.
10:03:15 <rpglover64> specifically, I was doing an iterated deepening depth first search on a tree and counting nodes, so after some time bound I needed to have a result already computed; I think I didn't force the evaluation enough (evaluate only goes to WHNF... which I realize after the submission is long due), so the computation seemed to run forever
10:05:47 <bos> not sure i understand what you're trying to tell me.
10:08:13 <mreh> how can I read files into STArrays without doing a freeze . thaw?
10:08:23 <mreh> seems a bit inefficient
10:08:29 <rpglover64> I had the following code (putStr "" and yield added because I didn't know why it wasn't working): http://hpaste.org/44900/not_strict_enough
10:10:31 <DRMacIver> ok. I think enough optimising of the algorithmic code for now. Any suggestions on less stupid way to write the driver program? https://github.com/DRMacIver/hs-rank-aggregation/blob/master/Main.hs
10:13:03 <copumpkin> DRMacIver: you can use my fancy strip ;)
10:13:26 <_mpu> I want my home installed packages seen when I run ghc/ghci how can I do that ?
10:13:31 <bos> DRMacIver: consider using Data.Text.IO.interact ?
10:13:37 <copumpkin> strip = join . init . tail . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ")
10:13:40 * copumpkin shrugs ;)
10:13:43 <_mpu> (using caba)
10:13:46 <_mpu> +l
10:13:53 <copumpkin> use the split package for splitting on commas
10:14:17 <bos> Data.Text already has splitting and stripping functions, and they're much faster than acting on lists
10:14:21 <ninly> can someone help me understand what Control.Arrow.first and second do? Wiki and hoogle descriptions aren't helping, but a super-basic illustrative example will probably seal it.
10:14:33 <DRMacIver> bos: Ah, it does? Excellent. I'll take a look at Data.Text
10:14:41 <bos> ninly: first (+1) (2,3) == (3,3)
10:14:49 <jmcarthur> ninly: hey!
10:14:57 <ninly> there you are!
10:15:00 <ninly> thanks bos
10:15:04 <bos> ninly: second (++"foo") (3,"bar") == (3,"barfoo")
10:15:15 <jmcarthur> ninly: second :: (b -> c) -> (a, b) -> (a, c)
10:15:28 <jmcarthur> ninly: it just happens to have a more general type than that
10:15:45 <ninly> i see now, thanks!
10:15:58 <bos> DRMacIver: it ought to improve your performance, since the I/O should be much faster, as should Eq/Ord instances
10:15:59 <jmcarthur> ninly: if you are looking at the Control.Arrow docs, mentally replace 'a' with (->)
10:16:17 <burp> :t first
10:16:18 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
10:16:31 <jmcarthur> ninly: when i use Control.Arrow generically, i like to use (~>) for the type variable instead of 'a' because it resembles a function
10:16:48 <ninly> jmcarthur: do you happen to have that shortened factor function? i quit without copying or logging it :/
10:17:04 <ninly> ooh ~> pretty
10:17:07 <frerich_> Hm, is 'ixs' a common abbreviation for 'indices' among Haskell programmers? I never saw it before, except in Haskell programs.
10:17:08 <jmcarthur> ninly: so...    second :: (b ~> c) -> ((a, b) ~> (a, c))
10:17:25 <jmcarthur> ninly: lemme go find it
10:17:47 <jmcarthur> ninly: i think this is the one you liked?    factor n = filter ((==0) . mod n) [1..n]
10:18:00 <bos> DRMacIver: don't forget to use interact instead of getContents followed by putStr
10:18:08 <bos> just for purity and tidiness and whatnot
10:18:20 <bos> (it makes no difference to actual performance)
10:19:32 <jmcarthur> ninly: second :: Arrow (~>) => (b ~> c) -> ((a, b) ~> (a, c))     -- corrected
10:19:54 <DRMacIver> bos: I was going to avoid interact so I could improve the CLI interface a bit - e.g. letting it take either a file or stdin.
10:20:03 <bos> ah, ok
10:20:27 <bos> DRMacIver: if you want an easy time improving the CLI, look at the cmdargs package
10:20:34 <DRMacIver> Thanks. Will do.
10:20:36 <bos> all the cool kids are using it, apparently.
10:20:49 <DRMacIver> Where are the functions for splitting text?
10:21:00 <DRMacIver> Oh, I see, never mind
10:21:16 <ninly> bos, jmcarthur: thanks again, got it now! jmcarthur: same goes for our initGame.
10:21:20 <bos> DRMacIver: http://hackage.haskell.org/packages/archive/text/0.11.0.6/doc/html/Data-Text.html#g:18
10:24:35 <DRMacIver> bos: Thanks
10:24:48 <bos> np
10:24:58 <DRMacIver> The move to text gave another decent performance boost as well.
10:25:35 <jmcarthur> ninly: awesome
10:26:49 <ninly> jmcarthur: the fromList just turns it into a Set so it fits the definition of Hand, right?
10:26:50 <petoman> how
10:27:55 <iman> anyone feel like trying out my haskell powered web chat?
10:28:18 <oracle_> is there a super fast way of outputting infinite fibonacci sequences?
10:28:31 <petoman> sure !
10:28:51 <tromp__> @let fibs x y = x : fibs y (x+y) in fibs 0 1
10:28:51 <lambdabot>   Parse error: in
10:28:53 <burp> oracle_: fast in the sense of few code, or numerically fast?
10:28:59 <tromp__> > let fibs x y = x : fibs y (x+y) in fibs 0 1
10:29:00 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:29:04 <moisan> Hi, I'm trying to take an algorithm written in imperative style and use it in Haskell and I'm stuck in the situation where I have two if block one after the other. I was using guards until I spotted both "if" could be true, hence my guard code doesn't cover every case. How can I work around that?
10:29:25 <oracle_> let me try that
10:29:38 <Botje> moisan: can you show the code on a pastebin?
10:29:50 <dino-> moisan: You may be able to use pattern matching.
10:30:03 <moisan> Botje : you want the imperative style or my haskell code?
10:30:08 <oracle_> oooh cool
10:30:15 <burp> oracle_: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
10:30:16 <oracle_> burp, numerically fast i suppose
10:30:24 <moisan> dino- : you mean like "case of"
10:30:28 <oracle_> tromp__, that worked nicely ;)
10:30:31 <oracle_> burp, thanks!
10:30:46 <jmcarthur> ninly: yes
10:30:51 <dino-> moisan: Yes, with tuples.
10:31:18 <moisan> dino- : ho I'm losing you there, do you have an example of that somewhere?
10:31:47 <dino-> moisan: ok
10:32:00 <moisan> I have two cases, k > 0 and k < someOtherVariable
10:32:32 <moisan> but both can be true and that case I want to call the code of the two cases
10:33:07 <Botje> how do they compose?
10:33:13 <dmwit> moisan: Perhaps you would like
10:33:14 <dmwit> :t when
10:33:15 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:33:17 <bos> DRMacIver: nice
10:33:26 <bos> DRMacIver: so you've gone from 1.2 seconds to what?
10:33:56 <moisan> dmwit : wow I'll try that thanks
10:34:47 <dino-> moisan: also: case (k > 0, k < other) of
10:34:50 <moisan> dmwit : mmm, looking at hackage definition, I'm not really sure that's what I want
10:34:52 <dino-> And then the cases like:
10:34:58 <dino-> (True, True) -> ...
10:35:05 <dmwit> moisan: It's really hard to guess what you want, because you haven't told us.
10:35:12 <dino-> (False, True) ->
10:35:14 <moisan> dino- : ho yeah I see! that's what I want
10:35:28 <dino-> (_, _) -> ... -- everything else ?
10:35:39 <moisan> dmwit : yeah sorry It's a bit unclear but I'm already with the dino- response :D
10:36:05 <dino-> moisan: But when and unless are great for when you need that more imperative like if-with-no-else
10:36:25 <DRMacIver> bos: I'm at about 0.4 seconds from around 1.2 when you started helping.
10:36:32 <DRMacIver> bos: I started at around 5s this morning.
10:36:35 <DRMacIver> (8 without O2)
10:36:40 <moisan> dino- : k I see
10:36:49 <bos> DRMacIver: mmm, tasty 12x speedup
10:37:27 <DRMacIver> I've gotten to a point where I think the profiler is lying to me though. I find hot spots, replace them with a supposedly more optimised implementation, and the hotspot goes away in the profiler but the code doesn't get faster.
10:38:33 <bos> the profiler has a fairly substantial overhead.
10:38:51 <DRMacIver> Yeah, not surprising.
10:38:53 <bos> so if you have too many SCC annotations, just using it will tend to make the places where the annotations are appear to be more expensive.
10:39:11 <DRMacIver> Ah
10:39:18 <bos> it's a fiddly business, alas.
10:40:08 <bos> but basically, you want to start with just a few of 'em, then narrow in on the places that really seem to matter. if you end up with an SCC annotation inside an inner loop, for instance, that will kill performance *and* distort the profile something awful.
10:40:33 <bos> the presence of the annotations makes the optimiser more squirrelly around them, too.
10:40:35 <DRMacIver> Well I've finally gotten to the point where the O(n!) part of the code is an appreciable bottleneck. that's probably a good sign. :)
10:41:31 <bos> aye.
10:41:35 <revenantphx> O(n!)!?!?!?
10:41:45 <revenantphx> Call the asympcops
10:42:43 <DRMacIver> revenantphx: Yep. But it's only applied to n <= 5.
10:43:32 <DRMacIver> I mean ideally you'd apply it to the whole list and it would give you the perfect answer. But there are obvious problems with that...
10:44:48 <revenantphx> DRMacIver: what's the algorithm?
10:44:54 <revenantphx> er, I mean, what're you doing in general?
10:45:46 <DRMacIver> revenantphx: At the high level, it's rank aggregation. You take a bunch of users' rankings of items and combine them into a best "overall" ranking.
10:46:07 <revenantphx> Interesting, I have no idea how that'd be done.
10:46:11 <revenantphx> Other than… averaging.
10:46:15 <revenantphx> -_-
10:46:15 <DRMacIver> revenantphx: At the low level it's basically a massive optimisation problem where the optimisation space is all permutations of a list.
10:46:29 <DRMacIver> revenantphx: This doesn't take scores, it takes orderings.
10:46:34 <revenantphx> Oooh.
10:46:44 <revenantphx> Couldn't you convert orderings to scores though?
10:47:12 <revenantphx> Ah well, sounds interesting.
10:47:14 <DRMacIver> You could. A lot of starting points for good rank aggregation do that.
10:47:46 <DRMacIver> But it doesn't usually produce results with desirable theoretical properties, and you can produce results which look better. :)
10:47:55 <revenantphx> Interesting.
10:51:31 <somehasel> In hgci ":type <something>" shows type. Does anyone know how to print (or get a string) that describes type in Haskell program?
11:05:10 <DRMacIver> ok. Next question: I need some sort of data store for a Haskell program. Just a key/value store is fine, but I need decent concurrent reads and writes. Suggestions?
11:05:33 <DRMacIver> tokyo tyrant would be fine, so I'll probably default to that if there aren't any better suggestions. :)
11:06:41 <jystic> DRMacIver: How about MongoDB? That has a pretty nice binding for Haskell
11:07:02 <freedrool> i have to make my function an instance of functor to use it with fmap right?
11:07:39 <DRMacIver> jystic: ok, will give it a go.
11:07:42 <DRMacIver> Thanks
11:07:43 <jystic> although it requires you to run a separate server process, so it depends what you're looking for
11:08:55 <DRMacIver> No, a separate server process is fine.
11:09:39 <DRMacIver> oh, before I do that, I suppose I should cabalize the rank aggregation stuff.
11:09:50 <bos> @hoogle [Bool] -> Bool
11:09:50 <lambdabot> Prelude and :: [Bool] -> Bool
11:09:51 <lambdabot> Prelude or :: [Bool] -> Bool
11:09:51 <lambdabot> Data.List and :: [Bool] -> Bool
11:10:52 <bos> there are also riak bindings for haskell.
11:11:29 <jystic> DRMacIver: If you're running on a single server make sure you start mongod with --journal to enable journalling support
11:13:19 <jystic> bos: I've heard of that, but haven't tried it, which OSes does it run on?
11:13:38 <bos> jystic: wherever erlang runs, as far as i know
11:16:09 <frerich_> Hm, I just realized that I have a lot of functions like 'f x = g 0 x'. Now I wonder whether I should maybe rewrite that to 'f = g 0'. Is it common to use partial function applications (that's what they are, right) like that in Haskell program - or is it really a matter of taste, cosmetic stuff?
11:16:40 <jmcarthur> frerich_: it's a common matter of taste :)
11:16:50 <frerich_> heh
11:17:12 <bos> frerich_: it doesn't usually have practical consequences, except for when the dreaded monomorphism restriction bites you
11:17:35 <jmcarthur> with ghc there are some potential efficiency differences, too
11:17:49 <jmcarthur> such as whether some REWRITE rules will fire
11:18:07 <jmcarthur> actually
11:18:09 <jmcarthur> i mean inlining
11:18:25 <ddarius> It can affect sharing, though usually you'll be aware of that.
11:18:29 <ddarius> (when it matters)
11:19:16 <jmcarthur> anyway, it's usually not going to make a difference
11:20:00 <frerich_> Ok, thanks
11:24:01 <DevHC> ok, for the Nth time: can someone tell wether the following cases work as intended, and if yes, why such working is intended?
11:24:40 <DevHC> if i fail to decompose a value in a let binding, i can still use the non-decomposed value without error:
11:24:45 <DevHC> (\ xxs -> let (x:xs) = xxs in xxs) []
11:24:49 <DevHC> > (\ xxs -> let (x:xs) = xxs in xxs) []
11:24:50 <lambdabot>   []
11:25:00 <Heffalump> DevHC: that's intended, because it's lazy
11:25:04 <revenantphx> Guys… I had another weird idea.
11:25:21 <DevHC> Heffalump: wait for the 2nd part of the question.
11:25:32 <revenantphx> Write a program that reads haskell function signatures, generates Quartz Composer patches for them...
11:25:34 <DRMacIver> Hmm. redis might be closer to what I need actually, but I notice there are no fewer than three redis bindings. Is this a sign that none o them are any good?
11:25:40 <dmwit> bleh
11:25:45 <DevHC> however, if i use a lazy, irrefutable pattern, then i cannot use the non-decomposed value:
11:25:46 <revenantphx> and then also lets you convert a composition made with said patches… back into Haskell.
11:25:49 <DevHC> (\ ~xxs@(x:xs) -> xxs) []
11:25:50 <revenantphx> SHAZAM. Graphical haskell.
11:25:52 <DevHC> > (\ ~xxs@(x:xs) -> xxs) []
11:25:53 <lambdabot>   *Exception: <interactive>:3:1-20: Irrefutable pattern failed for pattern (x...
11:25:55 <revenantphx> Madness, isn't it.
11:26:11 <dmwit> I considered briefly starting a PDF parsing project, but then opened the spec.
11:26:13 <dmwit> 756 pages
11:26:14 <dmwit> yeesh
11:26:25 <ddarius> DevHC: You did it wrong.
11:26:38 <ddarius> > (\xxs@(~(x:xs)) -> xxs) []
11:26:38 <DevHC> there can't be a WRONG here
11:26:39 <lambdabot>   []
11:26:44 <DevHC> wat??
11:26:59 <ddarius> DevHC: You said \~xxs -> case xxs of (x:xs) -> xxs essentially
11:27:07 <ddarius> And ~x is just x
11:27:20 <DevHC> D:
11:27:36 <Heffalump> DevHC: well, there is a WRONG and you found it :-) At least to the extent that your questions weren't comparable.
11:28:01 <ddarius> dmwit: Write a Postscript interpreter instead.
11:28:08 <ddarius> dmwit: Then PDF is just a library for it.
11:28:26 <ddarius> dmwit: And the spec (for either) is not that bad.
11:28:30 <DevHC> ok, then: new recommendation: the compiler should warn when i do ~x
11:28:47 <Heffalump> that sounds like a reasonable feature suggestion - try the GHC trac
11:28:57 <DevHC> @where ghc trac
11:28:57 <lambdabot> http://haskell.org/ghc
11:29:03 <DevHC> @where trac
11:29:03 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
11:29:23 <DevHC> TICKET_CREATE privileges are required to perform this operation
11:30:31 <DevHC> do those accounts have something to do with wiki accounts?
11:30:53 <ddarius> dmwit: Most of the complexity in the specifications has to do with giving semantics to the operations and many of those are just the graphical operations.  Parsing PDF is rather straightforward.
11:31:13 <dmwit> hm
11:31:19 <dmwit> Actually started reading it.
11:31:41 <dmwit> The actually spec doesn't start until 19 pages in... if the rest is similarly "fluffy", this might not be so bad.
11:31:49 <ddarius> It is pretty readable.
11:32:19 <dmwit> Of course, stopping at a parser isn't really worth it.
11:32:22 <DevHC> is it feasible to make ~x an error?
11:32:24 <djahandarie> ddarius, you seem to be well-aquainted with the PDF spec.
11:32:40 <dmwit> What I want is a tool to take a two-column paper and split all the pages down the middle (so it's readable on a kindle). =P
11:32:54 <ddarius> I've read it completely as well as the various Postscript books, and I wrote a parser for it in C++ many years ago.
11:34:03 <sordina> Does anyone know how to use readPixels in opengl?
11:34:21 <sordina> I'm unclear about the pointer stuff.
11:34:48 <Saizan> i want a pdf viewer which can reflow text around tables, to get typing rules and their descriptions on the same page :)
11:35:01 <ddarius> dmwit: You can probably make something that heuristically does that, though in general, it's not possible (e.g. the pages could be two-column formatted images.)
11:38:41 <hpc> :t readPixels
11:38:41 <lambdabot> Not in scope: `readPixels'
11:39:19 <ClaudiusMaximus> sordina: i wrote some code a while ago to save from opengl to ppm image: http://gitorious.org/maximus/dr1/blobs/master/cathedral-algorithms/Snapshot.hs
11:39:44 <dmwit> ddarius: Are you allowed to render outside of teh page?
11:40:10 <jix> dmwit: I guess you can set a clipping path
11:40:13 <dmwit> ddarius: If so, the simplest thing (if it's possible) would be to just render the entire page twice, on two different pages, one with a transformation matrix that slides it to the left half a page.
11:40:22 <ClaudiusMaximus> sordina: the pointer is a pointer to memory with enough space (which reminds me that that code probably breaks for image widths not a multiple of 4...)
11:40:45 <sordina> Thanks ClaudiusMaximus! This is probably exactly what I'm looking for.
11:40:54 <harlekin> Is there a function which satisfies \a r c -> bracket a c r
11:40:55 <harlekin> ?
11:41:06 <hpc> @pl \a r c -> bracket a c r
11:41:06 <lambdabot> flip . bracket
11:41:13 <hpc> now there is ;)
11:41:16 <harlekin> That'll do. Thanks. (:
11:41:56 <sordina> ClaudiusMaximus: Is there a good guide on how to create/use/cast such pointers?
11:42:09 <siracusa> :t catch
11:42:10 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
11:42:36 <ClaudiusMaximus> sordina: to fix the potential crash in that case, look at http://www.opengl.org/wiki/Common_Mistakes#Texture_upload_and_pixel_reads (not sure what the HOpenGL way for that is)
11:42:54 <ClaudiusMaximus> sordina: not sure, probably any generic FFI documentation that handles arrays should be enough
11:43:53 <sordina> Cool. Thanks again.
11:45:18 <somehasel> In hgci ":type <something>" shows type. Does anyone know is there is a way to it in a Haskell program? I.e., programatically print (or get a string) that describes type?
11:45:49 <hpc> somehasel: you can do it with the ghc api
11:46:00 <hpc> but you need the source; types and stuff disappear in the binary
11:46:23 <Taslem> I'm having an issue with a particular pattern-matching.
11:46:28 <ClaudiusMaximus> > show (typeOf "foo")
11:46:29 <lambdabot>   "[Char]"
11:46:37 <hpc> :t typeOf
11:46:37 <lambdabot> forall a. (Typeable a) => a -> TypeRep
11:47:02 <hpc> ClaudiusMaximus: i think he wants (typeOf "foobarblah") == :t foobarblah
11:47:22 <Taslem> I made a datatype of the form  A Int | B Int | C Int | D Int | E Int
11:47:38 <somehasel> hpc: Thanks, I will investigate this.
11:47:40 <Taslem> Is there any way I could match so I could ignore what the "A/B/C/D/E" was?
11:47:40 <somehasel> hpc++
11:47:58 * hackagebot http-types 0.6.0 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.6.0 (AristidBreitkreuz)
11:48:06 <hpc> somehasel: i was going to finish with "imo, needing to mess with types like that is a symptom of doing it wrong"
11:48:32 <hpc> Taslem: magicFoo A{} = "this is awesome!"
11:48:50 <Taslem> Um? Could you explain that syntax?
11:49:01 <hpc> Taslem: it's an empty record
11:49:07 <ClaudiusMaximus> Taslem: don't think so - but if you have  data X = A{ thing :: Int } | B{ thing :: Int } ...    then you can have   foo :: X -> Int ;  foo = thing
11:49:15 <hpc> say you match a pattern of MyRecord {field1 = foo}
11:49:28 <somehasel> hpc: I am just a beginner. When I write a function, I want to see it's type in a test program. I didn't want to fire ghci.
11:49:48 <hpc> somehasel: ah, then the ghc api is not for you; it can be tricky stuff
11:49:51 <Taslem> That isn't worth the trouble. I'll just use Strings.
11:50:14 <Taslem> I need to change my stuff around anyways.
11:50:33 <Taslem> Oh, right.
11:50:43 <Taslem> I wanted to ask... Can you invent type constructors for existing types?
11:50:49 <Taslem> Like, data A = String?
11:50:55 <Taslem> Or something to that effect?
11:51:14 <hpc> no
11:51:27 <hpc> data A = A String works
11:51:35 <hpc> or newtype, if you roll that way
11:51:37 <ClaudiusMaximus> type A = String -- synonym; or   newtype A = A String -- like data but with no extra runtime cost
11:51:38 <Taslem> That is to say, making a type which is equivelant to an existing one, with a different name.
11:51:45 <hpc> ah
11:51:46 <Taslem> Ah, okay.
11:51:47 <Taslem> type.
11:51:48 <hpc> type A = String
11:51:59 <Taslem> Right, I never learned about "type" for whatever reason.
11:52:07 <hpc> an example of the type keyword in action: type String = [Char]
11:52:11 <Taslem> Okay, thanks.
11:52:47 <Taslem> Yeah, I wanted my code to be more readable, so I felt like chaning al of the properties of my data types to something more descriptive.
11:53:18 <hpc> type aliases aren't checked at compilation, so some care is needed
11:53:31 <Taslem> WHat do you mean?
11:53:55 <hpc> > let {id x = x; id :: String -> [Char]} in id "123"
11:53:55 <lambdabot>   "123"
11:54:10 <hpc> String and [Char] are the same type
11:54:21 <Taslem> So?
11:54:26 <ClaudiusMaximus> if you have type Height = Int ; type Weight = Int ; it doesn't stop you doing   foo = (1 :: Height) + (2 :: Weight)
11:54:44 <Taslem> Well, it shouldn't, should it?
11:54:46 <hpc> just a warning :P
11:55:07 <ClaudiusMaximus> if you use 'newtype' instead, the compiler will stop you performing potentially meaningless calculations
11:55:13 <hpc> http://www.chasingambulances.net/wp-content/uploads/2010/01/the_more_you_know2.jpg
11:55:21 <Taslem> Yeah, I'm just using them once, actually. :P They'll be in my data type declarations, so I know what all of their values actually mean.
11:55:26 <Zao> This is the purpose of sane hungarian by the way.
11:55:39 <gwern> (eg newtype Hieght = Height Int, etc, foo (Height 1) + (Weigh 2) might be an error)
11:55:40 <hpc> hungarian as in the notation?
11:55:48 <gwern> hpc: yeah
11:55:50 <Zao> But in more of a human-verified way, where things like cbRofl + cchBbq look horribly wrong.
11:55:57 <Taslem> Is there any actual performance issues with it though? Assuming you want it to be treated exacly the same?
11:56:08 <hpc> yeah, as far as substitutes for good type systems go, hungarian doesn't suck too bad
11:56:14 <Zao> Or whatever notation that Word used for indicating document and window coordinates.
11:56:22 <hpc> lots of extra characters though
11:56:46 <hpc> Taslem: type aliases are one of the first things to go during compilation
11:57:10 <hpc> it replaces "A" with "String" anywhere in all type signatures
11:57:11 <Taslem> So, there's no run-time slowdown from them?
11:57:13 <hpc> nope
11:57:15 <Taslem> Ah, good.
11:57:17 <smarmy> suppose i have a binary union function over trees that may produce different intensional tree structures depending on the order of arguments, but otherwise produces extensionally equivalent trees.  is that operation associative?
11:57:56 <Taslem> Can you test it?
11:57:57 <hpc> smarmy: if you can observe the difference, it isn't associative
11:58:25 <Taslem> if (t1 <<>> t2) <<>> t3 == t1 <<>> (t2 <<>> t3)    then it is associative.
11:58:35 <monochrom> yeah, depends on what the user can observe
11:58:40 <hpc> i think he meant commutative
11:58:49 <Taslem> No, he meant associative.
11:59:03 <hpc> ah
11:59:05 <Taslem> Commutative would be ruled out my "different orde rof arguments yeilding different results"
11:59:13 <smarmy> i was specifically wondering about union as mappend
11:59:26 <smarmy> but yeah, i did say "order of arguments"
11:59:30 <smarmy> my mistake
11:59:34 <Taslem> Oh, I wanted to ask something.
11:59:51 <Taslem> If a type does not derive Eq, (or have an instance for it) can you still pattern match on it?
12:00:09 <ddarius> Of course.
12:00:09 <monochrom> yes, that's the beauty of pattern matching
12:00:17 <hpc> Eq only gives you (==)
12:00:18 <ddarius> How would you define (==) otherwise?
12:00:21 <Taslem> That seems silly to me.
12:00:52 <monochrom> f (x:xs) = forkIO x >> f xs
12:01:02 <Zao> All Eq gives is a nice fancy way of hooking in more complex equality tests for things.
12:01:03 <monochrom> would have not worked if required Eq
12:01:12 <jix> Taslem: How would you test if Maybe x is Nothing without having a Eq x instance then?
12:01:29 <Taslem> You shouldn't be able to, is my point.
12:01:42 <Taslem> Because without the ability to test equality, it should be impossible to compare to ANYTHING.
12:01:42 <ddarius> Taslem: That makes no sense.
12:01:45 <hpc> so...
12:01:49 <ddarius> Taslem: That makes no sense.
12:01:50 <Taslem> That's why it wasn't a member of the Eq typeclass.
12:01:59 <hpc> Taslem: if a type isn't an instance of Eq... you couldn't do ANYTHING with it
12:02:05 <smarmy> taslem: testing whether an instance of Maybe a is Nothing is different than testing whether two instances of Maybe a are equal
12:02:07 <Taslem> My point exactly.
12:02:16 <monochrom> I think we are violently agreeing.
12:02:19 <Taslem> It's not PRACTICAL, but in pure mathematics, it would make more sense. :P
12:02:40 <Zao> Note that pattern matching is shallow, while equality tests typically are deep.
12:02:42 <monochrom> in pure mathematics, you could axiomatize any way you want.
12:02:52 <ddarius> Taslem: In the typical foundations to mathematics, you can compare everything for equality even if it makes no sense.
12:03:02 <Taslem> Actually, you cannot.
12:03:07 <monochrom> mathematics is designed not discovered.
12:03:08 <Taslem> There are non-reflexive values.
12:03:12 <ddarius> Taslem: You can also test membership between any two things even if it makes no sense.  3 ∈ 17
12:03:16 <Taslem> But they are not common though.
12:04:24 <Taslem> Well, yes and no.
12:04:51 <monochrom> {17} ∈ 3 is a type error in haskell but a perfectly fine false statement (no type error) in set theory.
12:04:53 <Taslem> You cannot find the solution to (a == b) where a and b represent a random real between 0 and 1.
12:05:02 <paolino> I want a non reflexive value for christmas if it does fit on the desk
12:05:05 <Taslem> It could be either or both or neither.
12:05:34 <Cale> In set theory, sets can act reasonably well as types when you're making statements about things, so it isn't as big a deal.
12:06:07 <hpc> Cale: where the depth of the set is the type, and Ø is polymorphic?
12:06:37 <Cale> No, I mean, if you want to say that x is a real number, you just say that x is an element of the set of real numbers.
12:06:44 <hpc> ah
12:06:49 <monochrom> "the set is the type" - Kurt McLuhan  :)
12:06:57 * hpc took it to mean the types of sets
12:07:04 <Cale> x is also a set
12:07:08 <Cale> because everything is a set
12:07:09 <geheimdienst> kurt, eh?
12:07:14 <hpc> "set of sets" :: 2, "set" :: 1, 5 :: 0
12:07:16 <hpc> that sort of thing
12:07:32 <Taslem> BUt, for instance. In a Turing-Complete language, how can you devise an algorithm to compare equality of two objects for which equality is not defined?
12:07:58 <ddarius> Taslem: If you want decidable equality, then essentially no type in Haskell has it, so you are set.
12:07:58 <Cale> Of course, there's no set of all sets in ZF and friends, but there are powersets.
12:08:15 <ddarius> Taslem: Also, "pure mathematics" doesn't concern itself with computability.
12:08:18 <Cale> So if you want to say that x is a set of real numbers, that's obviously doable :)
12:08:36 <Taslem> It has certain aspects of it, not much though.
12:11:10 <ddarius> (Incidentally, in the most common/popular set theoretic definition naturals, 3 ∈ 17 is true.)
12:12:14 <Cale> Yeah, it's nice to be able to define the ordering using the element-of relation directly :)
12:12:30 <dmwit> let n = [0 .. n-1] in ZFC
12:12:52 <hpc> capitalization! that will never compile :P
12:13:06 <dmwit> data Don'tTellMeItWon'tCompile = ZFC
12:13:24 <hpc> oh, okay :D
12:14:05 <ddarius> dmwit: That's the Von Neumann definition.  Zermelo's was 3 = {{{{}}}} usw.
12:14:28 <dmwit> "usw"?
12:14:36 <ddarius> und so weiter
12:14:56 <hpc> wouldn't 3 not be an element of 17 then?
12:15:01 <dmwit> correct
12:15:02 <ddarius> hpc: Correct.
12:15:16 <dmwit> However, 16 would be an element of 17. =)
12:15:18 <hpc> oh, von neumann is the popular one
12:15:24 <ddarius> Yes.
12:15:52 <hpc> kids these days and their alternative definitions of the naturals
12:15:56 <hpc> get off my lawn!
12:16:59 <dmwit> > read "123.456" :: Rational -- ?
12:17:00 <lambdabot>   *Exception: Prelude.read: no parse
12:17:02 <dmwit> bummer
12:17:09 <dmwit> Is there a function for this?
12:17:09 <shachaf> Zermelo's definition can't be extended to N = {N}, though.
12:17:43 <Cale> wat
12:17:50 <ddarius> It can be in a non-wellfounded set theory.
12:18:41 <siracusa> > toRational $ read "123.456"
12:18:41 <lambdabot>   *Exception: Prelude.read: no parse
12:18:50 <siracusa> > toRational $ (read "123.456" :: Double)
12:18:51 <lambdabot>   8687443681197687 % 70368744177664
12:19:07 <dmwit> I think that shows nicely why that way is insufficient. =)
12:19:35 <dmwit> > (123456 % 1000) == (8687443681197687 % 70368744177664)
12:19:35 <lambdabot>   False
12:19:48 <ddarius> > partition isDigit "123.456"
12:19:49 <lambdabot>   ("123456",".")
12:20:06 <dmwit> Yes, I can write it myself. It's not hard.
12:20:12 <dmwit> I was just curious if it was in a library somewhere.
12:20:17 <ddarius> > groupBy (liftA2 (&&) isDigit isDigit) "123.456"
12:20:17 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
12:20:17 <lambdabot>         against inferred ...
12:20:38 <ddarius> > groupBy ((==) `on` isDigit) "123.456"
12:20:38 <shachaf> dmwit: GHC does it, at least. When you type 123.456 it's initially read as a Rational.
12:20:39 <lambdabot>   ["123",".","456"]
12:20:58 <dmwit> shachaf: Good point. I'll troll around in the GHC. hierarchy.
12:22:32 <shachaf> > readFloat "123.456"
12:22:33 <lambdabot>   [(123.456,"")]
12:22:40 <shachaf> > readFloat "123.456" :: [(Rational,String)]
12:22:40 <lambdabot>   [(15432 % 125,"")]
12:22:52 <shachaf> dmwit: That should work.
12:22:54 * ddarius hasn't seen the notion of "algebra over an endo-profunctor" before.
12:23:11 <cheater-> hey guys
12:23:14 <cheater-> is Show a monadic type?
12:23:27 <ddarius> Show isn't a type.
12:23:30 <ion> > readFloat "123.456e2" :: ReadS Rational
12:23:31 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
12:23:31 <lambdabot>           ...
12:23:53 <cheater-> yeah but i'm wondering how Show gets invoked every time something pops out of the interpreter
12:24:14 <shachaf> cheater-: The interpreter calls show on it.
12:24:18 <ddarius> cheater-: Because GHCi is defined to attempt to show each result.
12:24:29 <cheater-> yeah
12:24:44 <cheater-> what is Show if not a type then?
12:24:54 <ion> > (readFloat :: ReadS Rational) "123.456e2"
12:24:54 <lambdabot>   [(61728 % 5,"")]
12:25:06 <siracusa> cheater-:  A type class
12:25:09 <cheater-> ok
12:25:16 <cheater-> there's no such thing as a monadic type class is there?
12:25:37 <shachaf> cheater-: Well, there's Monad. That's a pretty monadic type class.
12:26:02 <shachaf> Also MonadState etc.
12:26:24 <shachaf> But if you're talking about the fact that values are printed -- that's IO, not "monadic", and at any rate is something ghci does, not a property of Show.
12:26:26 <cheater-> yeah but i was told that Maybe a is a monadic type
12:26:34 <cheater-> that would be correct, right?
12:26:55 <ion> Maybe is an instance of Monad, yes.
12:27:28 <cheater-> but then Show isn't an instance of monad is it?
12:27:57 <Philonous> cheater-: Only types can be instances, not type classes
12:27:59 <shachaf> cheater-: Show is a type class, not a type.
12:28:26 <ion> Maybe is an instance of both Monad and Show.
12:28:28 <cheater-> what about Show a    for some a?
12:28:29 <paolino> "Maybe a" is instance of Show 
12:28:35 <cheater-> is that a type?
12:28:47 <napping> Not easily
12:28:48 <shachaf> cheater-: No, it's a constraint.
12:29:18 <ddarius> Maybe is an instance of Monad.  Maybe a is an instance of Show if a is an instance of Show.
12:29:49 <shachaf> > show (Nothing :: Maybe a)
12:29:49 <lambdabot>   "Nothing"
12:32:23 <ddarius> shachaf: That's using extended defaulting to default that to Maybe ().
12:32:51 <merijn> cheater-: What are you reading to learn Haskell?
12:32:52 <ddarius> > show (Nothing :: Maybe (a -> a))
12:32:52 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
12:32:52 <lambdabot>    arising from a use of `...
12:32:54 <monochrom> a type can be an instance of a type class. example: Int (type) is an instance of Show (type class)
12:33:02 <cheater-> merijn: lyah
12:33:07 <paolino> :t show (Maybe 1)
12:33:08 <lambdabot> Not in scope: data constructor `Maybe'
12:33:08 * hackagebot vector-read-instances 0.0.1.0 - Read instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-read-instances-0.0.1.0 (ChristianHoener)
12:33:10 * hackagebot vector-read-instances 0.0.1.1 - Read instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-read-instances-0.0.1.1 (ChristianHoener)
12:33:11 <cheater-> merijn: but also a lot of articles and stuff
12:33:17 <paolino> :t show (Just 1)
12:33:17 <lambdabot> String
12:33:27 <merijn> cheater-: Ah, I think the monad examples in lyah is pretty good at explaining what a monad is
12:33:29 <cheater-> merijn: i'm reading a very cool article right now: http://www.cs.nott.ac.uk/~gmh/monads
12:33:38 <cheater-> i hadn't gotten to monads in lyah yet
12:33:43 <cheater-> waiting for my copy :)
12:33:54 <merijn> cheater-: Oh, you really should the LYAH first
12:34:09 <ion> You should also a verb.
12:34:10 <merijn> Learning about monads via Maybe and List is much easier
12:34:11 <cheater-> i will, but this article i linked makes perfect sense to me
12:34:18 <merijn> eh, start with LYAH
12:34:27 <monochrom> learn everything via every way
12:34:39 <cheater-> i accidently a LYAH
12:34:39 <monochrom> and remember, the 3rd book you read is the best book
12:34:55 <merijn> monochrom: What if I only read 1? :D
12:35:03 <cheater-> monochrom: we've had a lookalike of yours here today
12:35:07 <ion> Then you didn’t read the best book yet, duh.
12:35:31 <merijn> cheater-: Ah, I see he gets to list monad later, I think the start of that article is a bit unnecessarily abstract, though
12:35:44 <cheater-> i like the way it is
12:35:49 <cheater-> makes perfect sense to me
12:36:07 <cheater-> it's the first thing on monads that made perfect streetwise sense to me!
12:36:11 <napping> It might emphasize state and sequencing a bit much
12:36:11 <merijn> Apparently not entirely, else you wouldn't need to ask ;)
12:36:19 <napping> Did you follow the link to slides about parsing?
12:36:24 <monochrom> the 3rd monochrom you meet is the best monochrom
12:36:38 <merijn> Or maybe it's not so much monads but typeclasses that are the problem when I look back at the original questions
12:36:43 <paolino> no funny analogies about monads in that post
12:36:57 <shachaf> @quote burrito
12:36:57 <lambdabot> jmcarthur says: web monads are unicorn burritos that have been laying around in the attic for a few years
12:37:07 <shachaf> @quote chocolate
12:37:07 <lambdabot> SimonBrenner says: 2kg of chocolate 'thunks' to 'force' really might 'blow your stack' later on.
12:37:20 <merijn> Of course not, Graham Hutton isn't a ex-Ruby hipster blogging about this new funky monad thing :p
12:37:34 <cheater-> merijn: oh, no, i'm not asking about a question the article left open, it's my separate consideration
12:37:59 <cheater-> napping: i've just come to the part about the state monad.
12:38:49 <shachaf> Graham Hutton's book is good.
12:42:04 <Philonous> I wonder whether it is fair to say that desugaring do-notation is a CPS transformation
12:42:32 <paolino> hutton is an open source man also
12:42:39 <hpc> that's a big promotion from "textual change" :P
12:42:43 <napping> It's not too unfair
12:42:49 <napping> You can write a CPS monad
12:43:14 <napping> and the x <- e; body turns into wrapping up the body in the lambda and passing it as an argument to something
12:44:17 <ddarius> Philonous: It isn't.
12:44:22 <Philonous> napping: But that already happens in every monad. x <- e; c becomes e >>= \x -> c, so \x -> c is the continuation, 
12:44:26 <napping> I'm not sure it's useful to think about it like that, but it doesn't seem too far wrong
12:44:37 <cheater-> oh hey, a question
12:44:38 <cheater->       -- (>>=)  :: ST a -> (a -> ST b) -> ST b
12:44:39 <cheater->       st >>= f  =  \s -> let (x,s') = st s in f x s'
12:44:44 <ddarius> Philonous: You could argue that -writing- monadic code is like writing in CPS
12:44:56 <cheater-> how is    \s -> let (x,s') = st s in f x s'    of type ST b?
12:45:28 <hpc> cheater-: is that a hypothetical definition, or actual source?
12:45:46 <cheater-> it's from this tutorial, i guess it's "actual"
12:45:49 <cheater-> http://www.cs.nott.ac.uk/~gmh/monads
12:45:50 <hpc> because that's how ST works, more or less
12:46:00 <hpc> i assume it removed the wrapping and unwrapping for readability
12:46:17 <hpc> you can read it as "type ST s a = s -> (s, a)
12:46:19 <hpc> "
12:46:20 <hpc> or whatever
12:46:21 <napping> or maybe ST is a type synonym, if it's for a tutoral and they don't actually declare a Monad instance
12:46:39 <cheater-> oh riiight it needs to be a state transformer
12:47:00 <cheater-> i thought for a sec there that ST needed to be a state, i.e. take no arguments and return something like (s, a)
12:47:15 <hpc> no, ST is the strict state monad
12:47:21 <hpc> not a transforminator
12:47:22 <hpc> ;)
12:47:34 <cheater-> they say in the tutorial ST stands for state transformer.
12:48:07 <hpc> http://www.haskell.org/haskellwiki/Monad/ST
12:48:20 <paolino> if s -> (s,a) is a state transformation
12:48:30 <iman> hey guys, if you are interested check out my haskell powered web chat: http://www.frozenhot.com
12:49:00 <cheater-> ok now... why does "st s" return (x, s')?
12:49:04 <ion> cheater: There’s also http://heh.fi/state-monad which i wrote. </shamelessplug>
12:49:05 <cheater-> where does this x come from?
12:49:09 <cheater-> oh wait
12:49:31 <cheater-> right, ok
12:50:08 <ddarius> cheater-: As others have suggested, you'll want to spend more time understanding the basics of Haskell before even bothering with monads in Haskell.
12:50:22 <Philonous> ddarius: So your point is that do notation doesn't correspond to direct style if we considered writing monadic code with explicit (>>=)s to be CPS
12:50:24 <Philonous> ?
12:50:49 <cheater-> ddarius: naw
12:50:51 <napping> cheater-: You might also read some of Wadler's early papers
12:51:03 <cheater-> got links?
12:51:11 <napping> They are quite close to the origins in denotational semantics
12:52:09 <napping> http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#essence
12:53:59 <cheater-> ion: looking at your link btw
12:54:03 <cheater-> thanks for the links everyone
12:56:15 <ddarius> Philonous: If you define (>>=) to be the (>>=) for Cont, then you are writing in CPS.  However, if you CPSed "normal" code, then you'd have stuff like, f (g x) ~> \k -> g x $ \a -> f a k <=> g x >>= f (for Cont (>>=)).
12:57:02 <hpc> O.O
12:58:43 <napping> CPS doesn't have to mean every expression is in continuation passing styel
12:59:01 <ddarius> napping: The point is, there is nothing to transform once you are in monadic style.
12:59:07 <ddarius> You just define (>>=) appropriately.
12:59:36 <ddarius> CPS transformation is a global transformation, desugaring do-notation is not.
13:00:14 * hackagebot http-enumerator 0.5.0 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.5.0 (MichaelSnoyman)
13:02:25 <Philonous> Oh, it has to be global by definition? Well that's that, then.
13:07:31 <cheater99> i've got a problem with an excercise: Define a function app :: (State -> State) -> ST State, such that fresh can be redefined by fresh = app (+1)               how is +1 of type State -> State?
13:07:51 <ddarius> Maybe you should read the context.
13:08:08 <DevHC> app = error ""
13:08:14 <ddarius> (or get more familiar with the syntax and semantics of Haskell)
13:08:54 <cheater99> ddarius: it might be i'm missing some context. can you clue me in please?
13:09:12 <cheater99> ddarius: it's getting a bit late, but i want to close off reading about the state monad :)
13:09:32 <napping> (+1) is not of type (State -> State)
13:09:33 <ddarius> The context would be the context of the exercise, try reading what was written in or before the exercise.  You know what that is, not I.
13:10:00 <napping> hmm, you say it should be? Reread the question
13:10:22 <cheater99> i'm sorry. it's still the tutorial here: http://www.cs.nott.ac.uk/~gmh/monads
13:10:53 <cheater99> napping: that's what it looks like to me?
13:11:25 <napping> Oh, State, not the monad type
13:11:29 <cheater99> napping: the argument to app is of type State -> State according to the type declaration. but then they do app (+1). So I'm assuming that +1 is magically of type State->State?
13:11:31 <napping> type State = Int
13:11:52 <napping> a few paragraphs back. ddarius wins
13:11:57 <cheater99> ohhh right!
13:12:13 <cheater99> yeah, i said i might be missing something
13:12:36 <kmc> @hoogle (MonadPlus m) => Bool -> a -> m a
13:12:36 <lambdabot> Control.Exception assert :: Bool -> a -> a
13:12:36 <lambdabot> Control.OldException assert :: Bool -> a -> a
13:12:36 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
13:12:47 <kmc> @pl \p x -> guard p >> return x
13:12:47 <lambdabot> (. return) . (>>) . guard
13:13:01 <ddarius> cheater99: I find that it is helpful to read what you're reading.
13:13:11 <cheater99> i have :)
13:13:16 <cheater99> it fell out of my head i guess :)
13:13:18 <aristid> :t \p x -> x <$ guard p
13:13:18 <lambdabot> forall a (f :: * -> *). (MonadPlus f, Functor f) => Bool -> a -> f a
13:13:34 <aristid> @pl \p x -> x <$ guard p
13:13:34 <lambdabot> flip (<$) . guard
13:13:47 <aristid> kmc: how about that version? :)
13:21:51 <kmc> :t maybe Nothing
13:21:52 <lambdabot> forall a a1. (a1 -> Maybe a) -> Maybe a1 -> Maybe a
13:21:59 <kmc> :t flip $ maybe Nothing
13:22:00 <lambdabot> forall a a1. Maybe a1 -> (a1 -> Maybe a) -> Maybe a
13:35:35 <bss03> Say I have a some single-constructor record type GlobalState { ... } and then I wrap it in an IORef.  Is there a simple way to create a StateVar for each record without using TH?
13:36:01 <bss03> If so, I think it might simplify some of the stuff I'm doing in HSNeHe.
13:36:08 <kmc> bss03, look at fclabels / data-accessor / lenses
13:36:15 <kmc> they will do the TH for you
13:36:42 <kmc> you can also do simple boilerplate generation with CPP
13:37:11 <kmc> Haskell really needs a standard textual preprocessor which is more powerful and less bad than CPP
13:38:53 <btutt> submit an m4 patch :)
13:39:05 <kmc> a patch to m4?
13:39:16 <TTimo> aaah m4
13:39:33 <btutt> no, patch for ghc to use m4
13:39:34 <kmc> you can already use m4 with GHC quite easily
13:39:36 <kmc> as far as i know, nobody does
13:39:59 <kmc> ghc -pgmF m4
13:40:10 <kmc> or: {-# OPTIONS_GHC -pgmF m4 #-}
13:40:22 <btutt> thats not so hard. cool
13:40:32 <kmc> i don't claim that m4 is the solution we want
13:40:47 <kmc> but i claim TH is emphatically the wrong solution for simple boilerplate generation
13:41:05 <btutt> too complicated? (TH)
13:41:11 <kmc> yes
13:41:25 <kmc> too complicated, and too many implementation restrictions in GHC
13:41:27 <xplat> ugh, m4
13:42:03 <xplat> i can't really see writing things like data Foo = Bar a b dnl
13:42:05 <btutt> wasn't m4 created for pascal family languages?
13:42:13 <kmc> i don't know
13:42:24 <kmc> it's used today for autoconf and sendmail configuration and some other random things
13:42:26 <bobshush> I have a question about do blocks?
13:42:33 <kmc> go ahead bobshush
13:43:22 <bobshush> I wind up getting a lot of type errors when using them and multiple IO items
13:44:16 <bobshush> So I something like do (a <- getLine; b <- getLine; c <- f a b; putStrLn c) and get a type error
13:44:45 <kmc> what's the type of f?
13:44:55 <btutt> m3 was used in Ratfor. I knew it was a non-C thingy
13:44:59 <bobshush> I can paste the actual code I'm working on somewhere if you want
13:45:05 <kmc> hpaste.org
13:45:15 <kmc> unless 'f' returns an IO action, you probably want "let c = f a b" instead
13:45:18 <aristid> :t \f -> a <- getLine; b <- getLine; c <- f a b; putStrLn c
13:45:18 <lambdabot> Parse error in pattern
13:45:20 <kmc> or you can just say "putStrLn (f a b)"
13:45:26 <bss03> Is f :: a -> b -> IO c or f :: a -> b -> c ?
13:45:27 <aristid> :t \f -> do a <- getLine; b <- getLine; c <- f a b; putStrLn c
13:45:28 <lambdabot> (String -> String -> IO String) -> IO ()
13:45:38 <mauke> I recommend not using 'do' until you understand what it does/how it desugars
13:45:39 <bobshush> in my code the analogous function is String -> [String] -> [String]
13:45:39 <kmc> or "c <- liftM2 f getLine getLine"
13:45:40 <aristid> kmc: the type of f is String -> String -> IO String :P
13:45:53 <mauke> bobshush: yeah, then you don't want <- there
13:46:11 <kmc> bobshush, <- means roughly "execute this IO action and bind the result"
13:46:16 <kmc> you can't do that if f isn't returning an IO action
13:46:31 <kmc> :t do a <- getLine; b <- getLine; c <- ?f a b; putStrLn c
13:46:31 <lambdabot> (?f::String -> String -> IO String) => IO ()
13:47:12 <mauke> :t do a <- getLine; b <- getLine; let {c = ?f a b}; putStrLn c
13:47:12 <lambdabot> (?f::String -> String -> String) => IO ()
13:47:24 <bss03> :t do a <- getLine; b <- getLine; let c = ?f a [b]; mapM_ putStrLn c
13:47:24 <lambdabot> parse error (possibly incorrect indentation)
13:47:36 <bss03> :t do a <- getLine; b <- getLine; let {c = ?f a [b];}; mapM_ putStrLn c
13:47:37 <lambdabot> (?f::String -> [String] -> [String]) => IO ()
13:48:02 <zong_sharo> if i want to create, err let's say "database application" where user will be able to create, modify or delete somethin like "tables". do i need to give up on type safety of "tables" contents?
13:48:04 <bss03> bobsushi: ^^ I think that is your f?
13:48:04 <mauke> :t putStr . unlines
13:48:05 <lambdabot> [String] -> IO ()
13:48:14 <hpc> zong_sharo: no
13:48:28 <hpc> zong_sharo: well, yes, but only a little
13:48:42 <zong_sharo> hpc: i'm not sure how i can archieve this, can you please elaborate?
13:48:50 <hpc> so take SQL
13:48:58 <hpc> it has numeric, date, string types
13:49:14 <bobshush> Oh, yeah, durr, f isn't performing an IO action. >_<
13:49:29 <hpc> so you want to put a timestamp into the database, and the database "remembers" the type, more or less
13:49:33 <hpc> it at least knows it is a time
13:49:33 <bobshush> fixed with a c <- return (f a b)
13:49:44 <kmc> bobshush, that's not the right way
13:49:46 <bobshush> is there a less hacky way to do that? let binding?
13:49:47 <kmc> "let c = f a b"
13:49:48 <zong_sharo> it's my understanding that i need to introduce explicit datatype-tag type to preseve typing information 
13:49:52 <bobshush> sweet
13:49:54 <kmc> or the other tricks i listed above
13:50:02 <kmc> bobshush, functions can't perform IO, they can only produce descriptions of IO that one could perform
13:50:10 <kmc> such a description is a first-class value and is what i mean by "IO action"
13:50:16 <zong_sharo> but it is not a static type safety as it was in original, it's a manually checked run-time type safety now
13:50:17 <bobshush> It's been a while since I've programmed in haskell, sorry
13:50:23 <kmc> no worries :)
13:50:45 <zong_sharo> which is no better than any other language does 
13:50:48 <zong_sharo> i'm right here?
13:50:48 <hpc> zong_sharo: for databases like sql, you will have to do your own safety inevitably
13:51:08 <hpc> but you can always just say "this column is Int! this column is String!"
13:51:09 <kmc> lots of people have worked on this problem
13:51:12 <bss03> I thought HaskellDB sort of did it for you.
13:51:18 <kmc> i don't have any references but you should look around
13:51:38 <zong_sharo> hpc: specific storage medium or technology is irrevelant - i'm talking about dynamic "scheme" management
13:52:11 <hpc> i have no idea what you mean by "scheme"
13:52:11 <bss03> HaskellDB could theoretically be used for type-safe tables, I think.
13:52:18 <zong_sharo> the hard part is "dynamic"
13:52:44 * hpc is confused now
13:52:53 <zong_sharo> hpc: it's what is CREATE TABLE sql commands is about
13:52:59 <kmc> s/scheme/schema/?
13:53:05 <zong_sharo> oh yeah
13:53:07 <zong_sharo> sry
13:53:09 <zong_sharo> my bad
13:53:13 <hpc> oh
13:53:36 <hpc> so "dynamic schema" == "my code ALTERs it on the fly"?
13:54:07 <bss03> You can build up record types dynamically, IIRC.  It's normally done statically, but they have to do it dynamically internally to handle projections.
13:54:14 <zong_sharo> hpc: yup, as drop and create
13:54:42 <hpc> that sounds like a million bugs begging to happen
13:55:05 <hpc> i don't database nearly enough to have more advice for that
13:55:20 <zong_sharo> bss03: i know how i can do it in "mainstream" way, but what i'm seeking here is more type safety builtin
13:55:29 <bss03> So, I think you should be able to do some of this with HaskellDB types.
13:55:38 <bss03> Note HaskellDB != HDBC.
13:55:44 <zong_sharo> i know what haskelldb is
13:56:17 <zong_sharo> despite it awfull docs and enurmous source code size i managed to figure out how it does works
13:56:37 <napping> zong_sharo: type safe database access? Check out Ur
13:57:04 <zong_sharo> but i'm failing to understand how haskelldb will help me to build an application when runtime schema alteration is a routine process
13:57:14 <zong_sharo> s/when/where/
13:57:17 <zong_sharo> oh my
13:57:21 <zong_sharo> napping: Ur ?
13:57:27 <napping> Ur/Web
13:57:49 <napping> It's not Haskell, but there is no shortage of types
13:58:08 <napping> What kind of application makes runtime schema alteration common?
13:58:22 <hpc> poorly made ones?
13:58:41 <bss03> napping: A lot of poorly made ones that allow user to create new "forms".
13:58:47 <napping> ALTER TABLE prefs ADD COLUMN user_1235_favorite_color?
13:59:05 <bss03> napping: Like some EMR systems.  Probably some CMS systems, too.
13:59:16 <kmc> methinks if you're doing this, you should not be using a relational database in the first place
13:59:30 <napping> and you can all guess how we will make room to keep track of user 1236's favorite color
13:59:31 <hpc> a haskell equivalent of PHPMyAdmin would probably be the ONLY legit use for table alteration
13:59:41 <kmc> but i know non-relational is the new hipster fad so i'll shut up and let someone who knows the field talk
14:00:51 <hpc> i like why thedailywtf stopped showing wtfs that featured that sort of hackery
14:00:58 <hpc> because they had too many of them
14:00:59 <kmc> why?
14:01:01 <kmc> hehe
14:01:08 <kmc> when all you have is a hammer...
14:01:08 <hpc> and it just got boring
14:01:11 <hpc> :P
14:01:48 <hpc> when all you have is Haskell, everything looks like a research paper
14:01:50 <zong_sharo> hpc: actually i had in mind a system for accounting all my electronic components
14:02:12 <zong_sharo> you know - you can never be sure what else you get and what else they will make some day
14:02:15 <bss03> The alternative is sometimes bunk too. Everything for all the forms jammed into one table... or maybe one for each datatype.
14:02:18 <geheimdienst> @remember hpc when all you have is Haskell, everything looks like a research paper
14:02:18 <lambdabot> Done.
14:02:22 <zong_sharo> so, it must handle any schema alterations first class
14:02:47 <kmc> zong_sharo, why are you convinced a relational database is the right framework for this problem?
14:02:52 <bobshush> sorry, connection died, didn;t mean to leave without thanking you guys
14:02:57 <bss03> That can make relations between forms really ugly.
14:03:00 <zong_sharo> kmc: i'm not
14:03:00 <bss03> bobshushi: Np.
14:03:18 <bobshush> Everyone was really helpful. ^_^
14:03:26 <kmc> zong_sharo, a related question: what kinds of joins might you want to do?
14:03:46 <zong_sharo> kmc: you want to sell me a nosql on purpose?
14:04:03 <kmc> i don't understand the question
14:04:06 <bss03> zong_sharo: You might have to combine HaskellDB record types with some Dyn/Typeable magic.  There's still some runtime checking there, but it's automated.
14:04:34 <kmc> i said i'm not an expert on sql vs nosql
14:04:35 <hpc> geheimdienst: :D
14:04:41 <zong_sharo> kmc: as far as i understand - you talking of some nosql storage. that why i'm asking, is there something special about it?
14:04:44 <kmc> so i'm just asking some basic questions about your problem
14:05:22 <kmc> is there something special about not using SQL?
14:05:29 * hpc is a fan of show/read/varchar
14:05:41 <hpc> it's how i hacked around broken date support in mysql
14:05:48 <zong_sharo> what my concerns are about is general principles of dynamic schema handling - specific storage is irrevelant
14:06:07 <kmc> SQL isn't about "storage", it's about schema
14:07:03 <kmc> another question: if you were writing this merely in-memory using Haskell types from "base" / "container", what would you use?
14:07:05 <zong_sharo> sql or nosql - either way - i want to make it both dynamically adjustable and typesafe
14:07:53 <zong_sharo> kmc: lists of tuples, till i ran in performance issues
14:08:08 <zong_sharo> or list of custom records
14:08:21 <zong_sharo> same thing anyway
14:08:56 <kmc> Map PartID (Map Attribute Value)
14:08:56 <kmc> the problem is typing Value
14:08:57 <kmc> zong_sharo, what do you mean by "typesafe"?  people mean all sorts of things by that
14:09:05 <kmc> for example, they sometimes mean "program won't segfault"; i think you will have no trouble reaching that goal
14:09:23 <kmc> zong_sharo, but tuples and records aren't dynamically adjustable
14:09:30 <bss03> zong_sharo: It seems to me that Schema modifying actions act at Type Level, as effectively, type contructors.  So, you'll have to use stuff like Typeable/Dyn to query what "shape" the thing is that you are dealing with.
14:10:42 <zong_sharo> kmc: as close as possible to how it goes in ordinary haskell programs 
14:10:57 <kmc> zong_sharo, does that include compile-time checking?
14:11:00 <kmc> and when is "compile-time"?
14:11:10 <kmc> (in general "typesafe" does not imply "statically typed")
14:11:11 <bss03> It can certainly be "type-safe", but when your types are created/altered at runtime, it seems to be that you'll have to use run-time type-safety.
14:11:27 <kmc> maybe "compile-time" is every time the schema changes
14:11:28 <zong_sharo> bss03: makes sense, that will foce to check the actual type of field or record
14:12:57 <bss03> I'm not too familiar with HaskellDB though, so while I think I how how to implement adding a column dynamically I'd be lost when trying to drop a column.
14:13:10 <zong_sharo> kmc: let me put it this way - i want to loose as less as possible of marvelous type safety of haskell, but be able to alter schema at run time
14:13:32 <aristid> zong_sharo: AFAIK relational databases don't like schema changes at all
14:13:35 <kmc> zong_sharo, if your program keeps *all* its state in the DB, it can recompile and restart itself when the schema changes
14:13:57 <kmc> see http://hackage.haskell.org/package/dyre
14:14:14 <zong_sharo> aristid: actual storage is _irrevelant_ it's quite possible that for nex couple of years it will be running on a plain text files for good
14:14:36 <kmc> zong_sharo, why are you still treating relational vs. non-relational as a question of storage backend?
14:14:43 <kmc> that is a question entirely of API and data model
14:14:47 <kmc> which seems eminently relevant
14:15:07 <zong_sharo> kmc: because i highly doubt that i will use joins at all
14:15:17 <bss03> kmc: Ooh, that would be most beatuiful and mosterous at the same time.  Something that used TH + HDBC to generate the new version based on the new schema... and then exec'd over to it. :P
14:15:27 <dark> I need a data structure that maps a pair (state, action) to a Float. It would be a Data.Map.Map, but I also need to find the action so that (state, action) has maximum value. action is an enum, so I could test it all with a fold, but I'm thinking, maybe it could be a heap? (I'm having trouble to model this)
14:15:27 <kmc> zong_sharo, then you should be free to ditch the relational model, no?
14:15:41 <hpc> relational != uses joins
14:15:55 <kmc> dark, Data.Map.findMax ?
14:16:14 <kmc> or Data.Map.maxView[WithKey]
14:16:15 <zong_sharo> kmc: yup, but i need to save _lists_ of _records_ which describe electronic components i have. sounds like table for me
14:16:42 <kmc> zong_sharo, you've prejudged the question there
14:17:03 <kmc> by saying "lists of records" rather than "map from IDs to (map from attribute name to value)"
14:17:12 <bss03> dark: A heap sounds like a good ADT for that, but I don't have a particular library in mind.
14:17:14 <dark> kmc, hmm interesting, but this retrieves the maximal key for all stored values, not all stored values for a given state
14:17:14 <hpc> in fact, it is probably impossible to check the types at compile time
14:17:21 <hpc> er, shit
14:17:29 <zong_sharo> kmc: what are you proposing exactly?
14:17:34 <hpc> (scrolled-up fail)
14:18:08 <bss03> dark: Might just work with FingerTrees / Sequences and keep them soredt as you build it.
14:18:09 <dark> maybe each state should have its own map
14:18:30 * hackagebot tls 0.5.0 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.5.0 (VincentHanquez)
14:18:33 <kmc> probably so dark
14:18:43 <kmc> Map State (Map Action Float)
14:18:49 <kmc> zong_sharo, nothing specific
14:19:12 <kmc> i'm proposing that you think about some kind of nested key-value structure
14:19:16 <kmc> and also think about tables
14:19:27 <kmc> and decide which really fits your problem
14:19:32 * hackagebot tls-extra 0.1.0 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.1.0 (VincentHanquez)
14:19:34 * hackagebot riak 0.3.2.0 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.3.2.0 (BryanOSullivan)
14:19:38 <kmc> and only secondarily worry about what kind of software implements these models
14:20:04 <hpc> and for the love of god, don't go with altering tables at runtime
14:20:09 <hpc> a structure that changes isn't a structure
14:20:13 <kmc> i did earlier say "Map PartID (Map Attribute Value)"
14:21:22 <btutt> well, altering tables isn't necessarily a bad thing. As long as you're willing to pay for the consequences
14:21:39 <kmc> but altering tables when you don't even have a good reason to *have* tables?
14:22:22 <kmc> we have statements such as "no joins, ever" and "don't care about storage backend"
14:22:40 <btutt> if your data is more document like then yeah, it'd be bad thing no question, I know there are systems where its sometimes worth the cost.
14:22:42 <kmc> why are we still talking about SQL?
14:23:00 <zong_sharo> kmc: type Resistors = [(Resistance, Tolerance, Power, Package, Qantity)] <- /me failing to see how Maps will suite better
14:23:27 <kmc> because you can't invent new tuple types at runtime
14:23:52 <btutt> i.e. customizable bug tracking systems that use SQL stores sometimes add tables/columns so that they can benefit from traditional SQL indexes
14:23:59 <btutt> etc...
14:24:29 <hpc> btutt: you have to have a really busy site for that to matter
14:25:31 <zong_sharo> kmc: sure, but this is the reason why we has this conversation in the first place
14:25:51 <dark> There is also http://hackage.haskell.org/packages/archive/heap/1.0.0/doc/html/Data-Heap.html that gives O(1) access, but I think Data.Map is enough
14:26:14 <btutt> hpc: depends on how many rows you have it isn't about business its about query response times
14:29:39 <zong_sharo> kmc: if i understand you ring, what is you talking here about is "mainstream" way to do such thing - very limited type safety, all checks carried manually in runtime, extremely prone to bugs 
14:30:02 <kmc> zong_sharo, i didn't say anything about when type checking is done
14:30:03 <zong_sharo> been there done that - i'm seeking for more type safety, not less
14:30:20 <kmc> i was questioning one of your basic assumptions
14:30:25 <kmc> anyway i have work to do so, ttyl all
14:30:40 <zong_sharo> blah
14:30:55 <napping> It sounds like you don't often need to change schema
14:31:02 <napping> and when you do, it's reasonable to recompile
14:31:11 <btutt> if your structure is alterable then you don't have manual type checking at run time you have automatic type checking at run time by doing the work to implement it.
14:31:18 <btutt> i.e. it becomes meta-data driven
14:31:20 <zong_sharo> napping: to the some extent - yes
14:31:58 <zong_sharo> napping: can you please elaborate?
14:32:13 <napping> I mean just use Haskell
14:32:18 <napping> HaskellDB, or something like that
14:33:33 * hackagebot PrimitiveArray 0.0.3.0 - Unboxed, multidimensional arrays based on the primitive  package.  http://hackage.haskell.org/package/PrimitiveArray-0.0.3.0 (ChristianHoener)
14:33:35 <zong_sharo> btutt: probably so
14:33:35 * hackagebot PrimitiveArray 0.0.3.1 - Unboxed, multidimensional arrays based on the primitive  package.  http://hackage.haskell.org/package/PrimitiveArray-0.0.3.1 (ChristianHoener)
14:34:09 <btutt> If the rate of change is slow and you need code implemented on top of new structure and you want compile time type safety then you need to re TH + HaskellDB and add the new code.
14:34:41 <btutt> But if the structure changes you allow don't need new code then the alterable strcuture needs to be meta-data driven (and checked) at run time
14:35:02 <napping> And no tools will statically check that the code matches up
14:35:15 <napping> (and in any case the database can get out of sync by e.g. restoring a backup)
14:35:52 <btutt> well nothing ever prevents operators from being stupid. :)
14:35:56 <zong_sharo> napping: it possible to store schema information inside the database
14:35:57 <btutt> GIGO
14:36:10 <btutt> Sure
14:36:26 <btutt> or acuire the data by examining the SQL meta-data
14:37:45 <zong_sharo> btutt: better not to
14:38:13 <btutt> why not? your SQL store won't lie to as long as it can give you the data. not all can
14:39:40 <zong_sharo> because show tables or whatever will significantly limit expressiveness of the schema language
14:40:33 <btutt> not sure why you think that
14:40:51 <zong_sharo> for example - strong typedefs will be not possible 
14:40:59 <dark> is there some usual structure to map certain range of floats to a value? I want to map a probability to range a value. like, [0 0.1[ to a, [0.1 1.0] to b. what I'm thinking is to map the beginning of the segment to the appropriate value (like 0.0 to a, 0.1 to b)
14:41:29 <dark> I could also do this with a function Float -> element, but this is too opaque
14:41:50 <btutt> storing the meta-data is the same as retrieving the meta-data from that perspective
14:42:04 <dark> the idea is to build the function from the structure, but also to permit pretty-printing, etc
14:42:42 <dark> I want to map a probability range to a value*
14:43:20 <zong_sharo> btutt: anyway, actual storage is irrevelant, and what you said about meta-data driven db is revelant. is there anything i can read on this subject? never done anything similiar
14:43:28 <napping> dark: storing the endpoint is probably best
14:43:39 <dark> actually, hm, http://stackoverflow.com/questions/3893281/haskell-range-map-library
14:44:48 <dark> napping, hmm. yes, i use the endpoint to decide if I found, or if I will keep going
14:44:53 <btutt> Object Relational Mapping systems are what structure altering systems usually end up like
14:45:08 <dark> unless I begin from 1.0
14:45:10 <btutt> (or at least weak forms of them)
14:45:44 <jnhnum1> I have a question about getContents: why is it that if I have "do {x <- getContents; putStrLn x}", then if I run that in ghci, it will copy what I type one character at a time, but if I compile it with ghc and run the resulting binary, it copies what I type one line at a time?
14:45:58 <napping> dark: you can use splitLookup and findMax to get the first element below the key. I'm a bit surprised it's not already provided
14:45:59 <shachaf> jnhnum1: Buffering.
14:46:20 <shachaf> jnhnum1: hSetBuffering stdin NoBuffering, or something like that.
14:46:32 <dark> napping, using just Data.Map?
14:46:45 <jnhnum1> shachaf: thanks :)
14:46:54 <napping> dark: yeah, those are on Data.Map
14:47:31 <btutt> Do you need to search on the alterable parts of the schema?
14:48:04 <btutt> If not consider adding a XML content column to include customized data
14:48:22 <btutt> that make life LOTS simpler
14:49:40 <shachaf> btutt: ...XML?
14:50:01 <zong_sharo> btutt: maybe, the catch is - i do not know how requirements will change over time, because of that i do not want to apply such stong restrictions from the begining
14:50:43 <zong_sharo> hmm, chipala doing talk on ur/web? it's must be The Real Thing then
14:50:49 <btutt> shachaf: or any other mechanism you like to embed the data in one column. :)
14:51:01 <ski> jnhnum1 : btw, `do {x <- getContents; putStrLn ((unlines . map reverse . lines) x)}' (e.g.), is simply `interact (unlines . map reverse . lines)'
14:51:04 <ski> @type interact
14:51:05 <lambdabot> (String -> String) -> IO ()
14:51:10 <ski> @src interact
14:51:10 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:51:19 <ski> (s/Ln//)
14:53:07 <jnhnum1> oh yeah I guess I knew about interact but didn't think about doing `interact id'
14:53:33 <napping> a talk? Where?
14:55:37 <zong_sharo> napping: only slides :(
15:01:53 <moisan> hi, I was wondering if we can define a function as a type or data. I want to define multiple functions (contraints) that has the same signature but works differently
15:04:36 <doserj> @type [(*2),(+2),(^2)]
15:04:36 <lambdabot> forall a. (Num a) => [a -> a]
15:04:37 <zong_sharo> @type and
15:04:37 <lambdabot> [Bool] -> Bool
15:04:55 <zong_sharo> moisan: is that are you looking for?
15:05:14 <doserj> @type [even,odd]
15:05:14 <lambdabot> forall a. (Integral a) => [a -> Bool]
15:05:47 <moisan> yep I believe that what I wanted thanks :)
15:08:45 <aristid> :t sequence . map ($)
15:08:46 <lambdabot> forall a a1. [a1 -> a] -> a1 -> [a]
15:09:00 <aristid> > sequence [even,odd] 4
15:09:01 <lambdabot>   [True,False]
15:09:32 <malosh> Hi. GHC provides decodeDouble_2Int# to decode doubles, but anyone knows how to reencode it back from int#s ?
15:09:32 <zong_sharo> @type \val -> and . map ($val)
15:09:33 <lambdabot> forall a. a -> [a -> Bool] -> Bool
15:09:39 <zong_sharo> malosh: something like this
15:10:04 <zong_sharo> ahh, sequence
15:10:06 <zong_sharo> nice
15:10:23 <shachaf> @ty \val -> all ($val)
15:10:24 <lambdabot> forall a. a -> [a -> Bool] -> Bool
15:15:07 <Volt_> Anyone know of a graphics library that would be as easy as Processing to get stuff on the screen and lets you load bitmaps? Gloss seems cool, but doesn't allow the latter.
15:15:37 <ski> @tell kmc (.. possibly `Map1 PartID (\part -> Map1 (Attribute part) (Value part))' with `Map1 :: (* -> *) -> (* -> *) -> *')
15:15:37 <lambdabot> Consider it noted.
15:15:43 <ChloroGeo> Are there any Prelude functions of the type "a -> [a] -> Int"?
15:15:57 <shachaf> @hoogle a -> [a] -> Int
15:15:58 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
15:15:58 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
15:15:58 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
15:16:11 <zong_sharo> Volt_: hieroglyph?
15:16:21 <shachaf> ChloroGeo: Are you thinking of one with an Eq constraint?
15:16:37 <ChloroGeo> elemIndex was what I was looking for.
15:16:39 <shachaf> ChloroGeo: That type isn't quite enough of a description of what you want. :-)
15:16:43 <shachaf> Ah.
15:17:01 <ChloroGeo> Because it wouldn't make sense for the function to be anything else. :P
15:17:33 <ski> > ($ 4) . [even,odd]
15:17:35 <lambdabot>   [True,False]
15:17:44 <ski> > [even,odd] `flip` 4
15:17:46 <lambdabot>   [True,False]
15:17:54 <shachaf> ChloroGeo: You might've meant \x xs -> length (filter (==x) xs)
15:18:11 <shachaf> ChloroGeo: Makes more sense than elemIndex without Maybe. :-)
15:18:12 <Boxo> :t flip
15:18:13 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:18:20 <djahandarie> > [even, odd] `Prelude.flip` 4
15:18:20 <ChloroGeo> I guess.
15:18:21 <lambdabot>   Not in scope: `Prelude.flip'
15:18:27 <zong_sharo> Volt_: nevermind - it's looks abadoned
15:18:32 <dark> ski, here ghci said Couldn't match expected type `a -> a1 -> b' against inferred type `[a2]'
15:18:34 <shachaf> (That also has an Eq constraint, of course.)
15:18:42 <ChloroGeo> What's the "proper" way to remove the "Just" from a value?
15:18:49 <djahandarie> > (Prelude.flip) [even,odd] 4
15:18:50 <lambdabot>   Not in scope: `Prelude.flip'
15:18:52 <shachaf> ChloroGeo: Pattern-match.
15:18:55 <djahandarie> Why is this not in scope?
15:18:57 <shachaf> ChloroGeo: Because it might be Nothing.
15:19:01 <ChloroGeo> Ah, right.
15:19:06 <shachaf> > (P.flip) [even,odd] 4
15:19:07 <lambdabot>   Couldn't match expected type `a -> b -> c'
15:19:07 <lambdabot>         against inferred type `[...
15:19:10 <djahandarie> Ah
15:19:11 <dark> ChloroGeo, you can give it a default value
15:19:23 <Boxo> :t fromMaybe
15:19:24 <lambdabot> forall a. a -> Maybe a -> a
15:19:25 <Volt_> zong_sharo: Aaah… I don't mind checking it out, though. Thanks.
15:19:28 <shachaf> ChloroGeo: Also, you can use fromMaybe or maybe. *Not* fromJust.
15:19:39 <ski> dark : `(.) = fmap; flip ff a = fmap ($ a) ff'
15:19:58 <ChloroGeo> What's the type of fromMaybe?
15:20:07 <dark> ski, (.) = fmap in which sense?
15:20:10 <dark> :t (.)
15:20:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:20:12 <ski> @type fromMaybe
15:20:13 <dark> :t fmap
15:20:13 <lambdabot> forall a. a -> Maybe a -> a
15:20:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:20:26 <ski> dark : in the Caleskell sense
15:20:36 <dark> the type of . here is (.) :: (b -> c) -> (a -> b) -> a -> c
15:20:42 <dark> maybe i need to import something?
15:20:44 <shachaf> @djinn a -> Maybe a -> a
15:20:45 <lambdabot> f a b =
15:20:45 <lambdabot>     case b of
15:20:46 <lambdabot>     Nothing -> a
15:20:48 <lambdabot>     Just c -> c
15:20:51 <ski> dark : which is an instance of `fmap'
15:20:52 <ChloroGeo> Oh, I see. That makes sense.
15:20:58 <shachaf> djinn++
15:21:02 <zong_sharo> Volt_: as far as i remember - it's quite impressive, both functional and performant. too bad author abadoned it after his job on a visualisation system he developed was done
15:21:06 <ski> dark : you need to make the two Caleskell definitions i provided above
15:21:24 <dark> Caleskell?
15:21:44 <dark> @hoogle (.)
15:21:45 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
15:21:45 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
15:21:45 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
15:22:07 <ski> ChloroGeo : typically you can use `case elemIndex x xs of Nothing -> ..not found..; Just i -> ..use i..'
15:22:11 <dark> hoogle can't find the (.) type lambdabot has (with Functor)
15:22:31 <ski> ChloroGeo : which is the same as `maybe (..not found..) (\i -> ..use i..) (elemIndex x xs)'
15:22:36 <ski> @src (.)
15:22:36 <lambdabot> (f . g) x = f (g x)
15:22:36 <lambdabot> NB: In lambdabot,  (.) = fmap
15:22:42 <ddarius> :t flip ((.) .)
15:22:43 <lambdabot> forall a b (f :: * -> *) a1. (Functor f) => a1 -> (a1 -> a -> b) -> f a -> f b
15:22:44 <ski> dark : see the NB ^
15:22:55 <Boxo> > odd . [1,2]
15:22:57 <lambdabot>   [True,False]
15:23:01 <bss03> I want to write a POSIX daemon in Haskell.  Normally, I'd fork + setsid + fork, but forkProcess comes with a huge honking warning.
15:23:14 <bss03> What's the best way to daemonize from within Haskell?
15:23:21 <dark> uhm. NB? but then why there is no library providing (.) as fmap, so that one would import it and be happy with it?
15:23:54 <dark> :t maybe
15:23:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:24:09 <dark> @djinn b -> (a -> b) -> Maybe a -> b
15:24:09 <lambdabot> f a b c =
15:24:09 <lambdabot>     case c of
15:24:09 <lambdabot>     Nothing -> a
15:24:09 <lambdabot>     Just d -> b d
15:24:28 <ski> dark : i dunno whether anyone has bothered to put it into any library .. we mainly use it when playing with lambdabot, and confounding newbies with strange ways of doing things
15:24:48 <bss03> dark: NB == "Nota Benne".  It's advisory information after the fact, sort of an "footnote".
15:24:49 <lispy> bss03: Doesn't snap have some daemonizing code? I know a friend of mine made a program using snap that seems to have a daemon mode.
15:24:55 <dark> uhm :d
15:25:26 <ChloroGeo> How do you make a multi-threaded program?
15:25:26 <bss03> lispy: I'll look.  I was hoping to just stick with haskell-platform and I've never used snap.
15:26:03 <bss03> ChloroGeo: forkIO
15:26:37 <lispy> bss03: I bet you'll be able to stick with the HP, you'll just have to figure out how others are doing it.
15:26:47 <bss03> forkIO just starts a new haskell thread, forkProcess is the fork() system call.
15:26:57 <lispy> I've never needed to daemonize in any language, so I'm not really knowldgable about it
15:27:37 <bss03> I'm going to be using forkIO as well, since this is going to have worker threads and whatnot, but... forkIO doesn't get me daemonization.
15:28:09 <shachaf> @hackage hdaemonize
15:28:09 <lambdabot> http://hackage.haskell.org/package/hdaemonize
15:29:28 <bss03> shachaf: Thanks!  Most likely exactly what I need.
15:30:32 <bss03> Hrm, maybe not.  It seems to just use forkProcess unsafely. :(
15:33:22 <dark> .. what is caleskell?
15:33:26 * dark reading http://ivanmiljenovic.wordpress.com/2010/07/14/data-oriented-hierarchies/
15:33:39 <bss03> dark: Cale + Haskell = Caleskell.
15:33:58 <bss03> dark: Cale is idling right now, I think.
15:34:09 <djahandarie> (Cale being the maintainer of lambdabot)
15:34:26 <djahandarie> Though he isn't the creator of all of its quirks :)
15:34:41 <djahandarie> Only responsible for keeping in them there ;)
15:34:51 <shachaf> Cale++
15:35:06 <dixie> > sum [1..1000]
15:35:07 <lambdabot>   500500
15:35:58 <dmwit> > msum [1..1000] :: Sum Int
15:35:58 <lambdabot>   No instance for (Control.Monad.MonadPlus Data.Monoid.Sum)
15:35:58 <lambdabot>    arising from a...
15:36:06 <dmwit> > mconcat [1..1000] :: Sum Int
15:36:07 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
15:36:07 <lambdabot>    arising fr...
15:36:24 <shachaf> > mconcat (map Sum [1..1000]) :: Sum Int
15:36:25 <lambdabot>   Sum {getSum = 500500}
15:36:34 <dmwit> > 1 :: Sum Int
15:36:35 <lambdabot>   No instance for (GHC.Num.Num (Data.Monoid.Sum GHC.Types.Int))
15:36:35 <lambdabot>    arising fr...
15:36:39 <dmwit> oh, that's annoying
15:36:52 <dmwit> There should really be a derived Num instance for that.
15:37:05 <djahandarie> > ala Sum Data.Foldable.foldMap [1..1000]
15:37:05 <lambdabot>   500500
15:37:16 <dmwit> :t ala
15:37:16 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
15:37:40 <dark> @src ala
15:37:40 <lambdabot> Source not found. Are you on drugs?
15:38:11 <djahandarie> @hackage newtype is where ala comes from
15:38:11 <lambdabot> http://hackage.haskell.org/package/newtype is where ala comes from
15:38:43 <aristid> djahandarie: ala seems to work only with foldMap. why not make a foldMapAla instead? :P
15:39:00 <aristid> :t ala
15:39:01 <lambdabot> forall o n b n' o'. (Newtype n o, Newtype n' o') => (o -> n) -> ((o -> n) -> b -> n') -> b -> o'
15:39:11 <smarmy> works well with traverse too
15:39:13 <djahandarie> It only seems that way because there aren't many interesting newtypes in base
15:39:14 <aristid> :t Data.Foldable.foldMap
15:39:15 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
15:39:28 <aristid> :t Data.Foldable.traverse
15:39:29 <lambdabot> Not in scope: `Data.Foldable.traverse'
15:39:34 <djahandarie> Applicative.
15:39:49 <smarmy> :t Data.Traversable.traverse
15:39:50 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
15:40:30 <djahandarie> And by Applicative I mean Traversable ;P
15:40:48 <Twey> Oh snap, there's a really annoying bot in another channel.
15:42:03 <aristid> > cycle "annoybot"
15:42:03 <lambdabot>   "annoybotannoybotannoybotannoybotannoybotannoybotannoybotannoybotannoybotan...
15:43:13 <djahandarie> Here is some nice usage of ala: https://gist.github.com/873548
15:43:44 <aristid> :t mconcat
15:43:44 <lambdabot> forall a. (Monoid a) => [a] -> a
15:43:55 <DevHC> is anyone else getting overlapped webpage sections in http://hackage.haskell.org/trac/ghc/?
15:44:00 <aristid> djahandarie: which function to use with mconcat?
15:44:12 <DevHC> for example, http://hackage.haskell.org/trac/ghc/newticket?type=feature+request, when u r not logged in yet
15:44:30 <djahandarie> aristid, I don't have a functor-base under yet, but I'm going to add it in the next version
15:45:11 <djahandarie> :t let underF _ f = fmap unpack . f . fmap pack :: (Newtype n o, Newtype n' o', Functor f) => (o -> n) -> (f n -> f n') -> f o -> f o'
15:45:12 <lambdabot> <no location info>:
15:45:12 <lambdabot>     not an expression: `let underF _ f = fmap unpack . f . fmap pack :: (Newtype n o, Newtype n' o', Functor f) => (o -> n) -> (f n -> f n') -> f o -> f o''
15:45:29 <djahandarie> @let underF _ f = fmap unpack . f . fmap pack :: (Newtype n o, Newtype n' o', Functor f) => (o -> n) -> (f n -> f n') -> f o -> f o'
15:45:29 <lambdabot>   MultiParamTypeClasses is not enabled
15:45:34 <djahandarie> lol
15:45:48 <djahandarie> Anyways, it would be something like that
15:46:59 <BMeph> :t let underF _ f = fmap unpack . f . fmap pack :: (Newtype n o, Newtype n' o', Functor f) => (o -> n) -> (f n -> f n') -> f o -> f o' in underF
15:47:00 <lambdabot>     Inferred type is less polymorphic than expected
15:47:00 <lambdabot>       Quantified type variable `f' is mentioned in the environment:
15:47:00 <lambdabot>         f :: (o -> n1) -> (f n -> f n') -> a (bound at <interactive>:1:13)
15:48:28 <djahandarie> @ty let { underF :: (Newtype n o, Newtype n' o', Functor f) => (o -> n) -> (f n -> f n') -> f o -> f o'; underF _ f = fmap unpack . f . fmap pack } in underF
15:48:29 <lambdabot> forall o n (f :: * -> *) n' o'. (Functor f, Newtype n' o', Newtype n o) => (o -> n) -> (f n -> f n') -> f o -> f o'
15:50:24 <djahandarie> This would actually be fairly useless for mconcat
15:50:51 <djahandarie> You don't really want to use things like 'mconcat' with ala. You want stuff like 'mconcatMap', which is what foldMap is
15:51:20 <ChloroGeo> When creating Modules, how do you include Types/Dattypes?
15:51:55 <ChloroGeo> Hello?
15:52:27 <ChloroGeo> HELLO?
15:52:44 <BMeph> ChloroGeo: The normal way. What, you CBA to read it? ;)
15:53:20 <ChloroGeo> Oh, okay.
15:56:46 <aristid> :t mconcat . map
15:56:46 <lambdabot>     Couldn't match expected type `[a]'
15:56:46 <lambdabot>            against inferred type `[a1] -> [b]'
15:56:46 <lambdabot>     Probable cause: `map' is applied to too few arguments
15:56:55 <aristid> :t \f -> mconcat . map f
15:56:55 <lambdabot> forall a a1. (Monoid a) => (a1 -> a) -> [a1] -> a
15:57:05 <aristid> :t ala Sum (\f -> mconcat . map f)
15:57:06 <lambdabot>     Ambiguous occurrence `Sum'
15:57:06 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
15:57:06 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
15:57:16 <aristid> :t ala Product (\f -> mconcat . map f)
15:57:16 <lambdabot> forall o. (Num o) => [o] -> o
15:57:28 <aristid> djahandarie: it works! i think
15:57:56 <aristid> > ala Product (\f -> mconcat . map f) [1,3,2]
15:57:58 <lambdabot>   6
15:58:14 <aristid> :t ala Product foldMap
15:58:14 <lambdabot> Not in scope: `foldMap'
15:58:19 <ChloroGeo> How exactly does Haskell load modules? Does it just go through all the files in the folder and check if they export a module?
15:58:21 <aristid> :t ala Product Data.Foldable.foldMap
15:58:21 <lambdabot> forall o (t :: * -> *). (Num o, Data.Foldable.Foldable t) => t o -> o
15:58:43 <aristid> djahandarie: can't you make me a version of ala that does the map itself?
15:59:33 <ChloroGeo> Is it possible to add onto existing datatypes?
15:59:37 <hpc> ChloroGeo: it loads from the bottom up, if you imagine dependencies forming a tree, with the module you want at the top
15:59:39 <ChloroGeo> Like add values to Integer, for instance?
15:59:46 <DevHC> hey hey hey hey hey hey hey HEY !
16:00:05 <hpc> ChloroGeo: no; if you define a type, then change it later, you are a liar ;)
16:00:09 <DevHC> ~xxs@(x:xs) is NOT the same as xxs@(x:xs)
16:00:14 <ChloroGeo> Wait, what?
16:00:14 <DevHC> ^ ddarius, Heffalump 
16:00:27 <hpc> ChloroGeo: because an Integer can't be two different things
16:00:32 <jmcarthur> ChloroGeo: you could make a new type that uses Integer
16:00:49 <ChloroGeo> Well, what about Num. Can't you make explicit conversions between types?
16:00:57 <ChloroGeo> For arithmetic?
16:01:02 <jmcarthur> Num is not a type
16:01:09 <ChloroGeo> I know, it's a typeclass.
16:01:13 <jmcarthur> most numeric types have conversion functions though, yea
16:01:16 <ChloroGeo> But I never bothered to look at how Num works.
16:01:19 <djahandarie> aristid, hmm?
16:01:23 <ChloroGeo> They do? That's good.
16:01:36 <ChloroGeo> Is there a standard Infinity data built into Haskell?
16:01:40 <jmcarthur> some of which may be lossy, of course
16:01:47 <hpc> ChloroGeo: what do you mean by infinity?
16:01:48 <jmcarthur> depends on the type
16:01:50 <hpc> > 1/0 :: Float
16:01:51 <lambdabot>   Infinity
16:01:55 <hpc> [1..]
16:01:56 <ChloroGeo> Okay, goota go.
16:01:57 <ChloroGeo> I see.
16:01:57 <hpc> > [1..]
16:01:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:02:59 <aristid> :t let alaMap p f = ala p (\g -> f . map g) in alaMap
16:03:00 <lambdabot> forall o n n' o'. (Newtype n' o', Newtype n o) => (o -> n) -> ([n] -> n') -> [o] -> o'
16:03:43 <aristid> djahandarie: only problem is its restriction on [] i guess
16:03:45 <djahandarie> :t let alaMap p f = ala p (\g -> f . fmap g) in alaMap
16:03:45 <lambdabot> forall o n (f :: * -> *) n' o'. (Newtype n' o', Newtype n o, Functor f) => (o -> n) -> (f n -> n') -> f o -> o'
16:03:56 <aristid> well that looks much better
16:04:33 <aristid> @let alaMap p f = ala p (\g -> f . fmap g)
16:04:34 <lambdabot>  Defined.
16:04:41 <aristid> :t alaMap Product mconcat
16:04:42 <lambdabot> forall o. (Num o) => [o] -> o
16:04:48 <djahandarie> Does this sort of thing exist anywhere except mconcat?
16:04:56 <aristid> :t msum
16:04:57 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
16:05:25 <aristid> ok that is cheating :D
16:06:14 <aristid> @hoogle [a] -> a
16:06:14 <lambdabot> Prelude head :: [a] -> a
16:06:14 <lambdabot> Prelude last :: [a] -> a
16:06:14 <lambdabot> Data.List head :: [a] -> a
16:06:25 <hpc> :k Product
16:06:25 <lambdabot> * -> *
16:06:29 <aristid> lambdabot: bad examples
16:06:43 <hpc> hilarious examples
16:06:43 <aristid> @hoogle f a -> a
16:06:43 <lambdabot> Network.BufferType buf_empty :: BufferOp a -> a
16:06:43 <lambdabot> Data.Monoid getDual :: Dual a -> a
16:06:43 <lambdabot> Foreign unsafePerformIO :: IO a -> a
16:07:12 <aristid> :t alaMap Product
16:07:14 <lambdabot> forall o (f :: * -> *) n' o'. (Functor f, Newtype n' o') => (f (Product o) -> n') -> f o -> o'
16:07:22 <aristid> :t alaMap Product getDual
16:07:22 <lambdabot>     No instance for (Functor Dual)
16:07:22 <lambdabot>       arising from a use of `alaMap' at <interactive>:1:0-21
16:07:22 <lambdabot>     Possible fix: add an instance declaration for (Functor Dual)
16:07:26 <djahandarie> This sort of thing is essentially only useful when f is also Foldable.
16:07:32 <djahandarie> In which case we would be using ala x foldMap
16:08:09 <aristid> djahandarie: so essentially foldAla and traverseAla is all we really need?
16:08:19 <aristid> :t ala Product traverse
16:08:20 <lambdabot> Not in scope: `traverse'
16:08:29 <aristid> :t ala Product Data.Traversable.traverse
16:08:29 <lambdabot>     No instance for (Applicative Product)
16:08:29 <lambdabot>       arising from a use of `Data.Traversable.traverse'
16:08:29 <lambdabot>                    at <interactive>:1:12-36
16:09:53 <djahandarie> No.
16:10:00 <djahandarie> All you need is ala. :)
16:11:02 <djahandarie> This is like looking at Monad and saying, 'so all we need is IO and List, right?' ;)
16:11:24 <smarmy> i thought all you needed was Cont...
16:11:44 <djahandarie> Hah
16:12:42 <shachaf> djahandarie: All we really need is IO.
16:12:44 <aristid> djahandarie: if it's like monads, i just need lots of examples to get it :D
16:12:58 <aristid> shachaf: you don't need functions? oO
16:13:01 <codolio> @type curry $ ala Product (uncurry . (mappend `on`))
16:13:01 <lambdabot> forall b. (Num b) => b -> b -> b
16:13:06 <shachaf> aristid: Nope.
16:13:15 <shachaf> Just some IO primitives.
16:13:25 <smarmy> :t ala Sum ($)
16:13:25 <lambdabot>     Ambiguous occurrence `Sum'
16:13:25 <lambdabot>     It could refer to either `Control.Monad.RWS.Sum', imported from Control.Monad.RWS
16:13:25 <lambdabot>                           or `Data.VectorSpace.Sum', imported from Data.VectorSpace
16:13:29 <shachaf> Haven't you heard? Haskell is the world best imperative language.
16:13:38 <aristid> :t (mappend `on`)
16:13:39 <lambdabot> forall b a. (Monoid b) => (a -> b) -> a -> a -> b
16:13:51 <aristid> shachaf: is haskell even turing-complete if you remove functions? :D
16:14:03 <hpc> wait, what?
16:14:08 <hpc> remove function names, or lambdas?
16:14:09 <djahandarie> Who, since when was Sum ambiguous?
16:14:10 <hpc> or both
16:14:17 <DevHC> > let f ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ [] = [] in f []
16:14:18 <lambdabot>   []
16:14:19 <aristid> hpc: the whole type (->)
16:14:27 <aristid> hpc: and everything that depends on it
16:14:33 <hpc> bleh
16:14:35 <shachaf> aristid: Just add some relevant IO actions.
16:14:44 <shachaf> aristid: Oh. Well, (->) is just an implementation detail.
16:14:55 <aristid> hmm.
16:15:02 <aristid> i think you're right, we can do without (->)
16:15:07 <djahandarie> Everything is just an implementation detail
16:15:09 <shachaf> http://www.haskellassemblyofgod.com/
16:15:12 <aristid> brainfuck doesn't need functions either
16:15:18 <hpc> obviously we would instead write haskell programs like so:
16:15:33 <hpc> main = "mov eax 5; ..."
16:15:48 <DevHC> srsly, why does the language, if it does at all, allow multiple ~ to be used? is it even useful?
16:16:02 <shachaf> hpc: Except that that's function application.
16:16:07 <aristid> hpc: that uses functions! evil you
16:16:16 <hpc> nonono, note the quotes
16:16:20 <hpc> main is a string
16:16:22 <aristid> mov is clearly a function in spirit
16:16:36 <hpc> :P
16:16:43 <djahandarie> lol shachaf 
16:16:43 <Twey> mov :: Register -> Value -> Register
16:16:57 <DevHC> i can think of a theoretical case: to help code generators? doubtful
16:17:01 <aristid> mov :: Register -> Value -> IO Register
16:17:09 <ddarius> mov doesn't return anything.
16:17:13 <Twey> Nah
16:17:16 <aristid> mov :: Register -> Value -> IO ()
16:17:23 <shachaf> A Haskell DSL for assembly that captured all the various type constraints could be neat.
16:17:33 <Twey> mov :: Register -> Value -> State CPU ()
16:17:39 <smarmy> that rings a bell for some reason
16:17:41 <shachaf> E.g. either argument to mov could be a memory address, but not both.
16:17:48 <hpc> shachaf: a haskell dsl for assembly would be neat, period
16:17:48 <djahandarie> There is a DSL for assembly, though I don't know how much type-safety is enforced there
16:17:54 <DevHC> mov :: ProcessorState -> Register -> Value -> ProcessorState
16:17:55 <aristid> shachaf: we need a typeclass for mov
16:18:12 <aristid> DevHC: monads make the syntax all neater!
16:18:13 <hpc> mov :: Register -> Value -> CPU ()
16:18:22 <shachaf> hpc: Well, just simple DSL with mov etc. the way it's mentioned here wouldn't be very difficult.
16:18:32 <hpc> where CPU tracks registers, ram, signals
16:18:34 <hpc> flags
16:18:35 <hpc> etc
16:18:47 <shachaf> Of course, if it integrated with GHC for inline assembly, that could be neat.
16:18:56 <DevHC> aristid: instance Monad ProcessorState where ... ?
16:19:02 <hpc> oh man
16:19:04 <djahandarie> Also an interesting Haskell EDSL is Coconut
16:19:08 <djahandarie> For SIMD
16:19:13 <aristid> DevHC: instance Monad State
16:19:23 <aristid> DevHC: then, use State ProcessorState
16:19:38 <hpc> inline assembly in haskell is unprecedented levels of crazy
16:19:50 <ddarius> hpc: It's certainly not unprecedented.
16:20:06 <hpc> eh?
16:20:19 <aristid> inline assembly in haskell could work pretty well, i think
16:20:27 <ddarius> See harpy (among other such things) and a hack that mauke did and a monad reader article.
16:20:46 <hpc> you have to keep the assembly self-contained though
16:20:46 <lispy> aristid: one of my co-workers likes the idea of inline asm in ghc
16:20:51 <lispy> at least one*
16:21:00 <lispy> But, I don't know of anyone actually working on it
16:21:05 <BMeph> ...and augustss' LLVM DSL. ;)
16:21:08 <hpc> as opposed to C where you can do hacks with it
16:21:09 <jmcarthur> shachaf: http://potential-lang.org/
16:21:45 <jmcarthur> it's an embedded assembly language in haskell
16:21:54 <jmcarthur> with type constraints like you mentioned
16:22:06 <jmcarthur> and some quasiquoter sugar for a few things
16:22:24 <shachaf> jmcarthur: Apparently Harpy does it too, to some degree.
16:23:02 <ddarius> preflex: version
16:23:02 <preflex>  3.450
16:23:07 <ddarius> preflex: source
16:23:27 <ddarius> preflex: version
16:23:27 <preflex>  3.660
16:23:28 <djahandarie> What exactly is the point of preflex existing anyways?
16:23:38 <djahandarie> preflex: version
16:23:38 <preflex>  1.997
16:23:38 <ddarius> @seen djahandarie 
16:23:38 <lambdabot> Unknown command, try @list
16:23:39 <preflex>  djahandarie was last seen on #haskell 1 second ago, saying: preflex: version
16:23:51 <lispy> djahandarie: more stable than lambdabot
16:23:55 <djahandarie> lol
16:31:36 <accel> during a tsunami, what's the best vehicle to be in?
16:31:44 <hpc> accel: submarine
16:31:58 <accel> it beats space shuttle?
16:32:06 <djahandarie> accel, the best vehicle to be in is #haskell-blah
16:32:15 <hpc> you have to land the shuttle eventually :P
16:34:17 <zong_sharo> accel: any ship will be okay too
16:34:36 <FauxFaux> Have you not seen 2012?!
16:34:50 <zong_sharo> just make sure to keep a distance from a coast
16:35:47 <zong_sharo> oh and too small and too big vessels can be bad fo ya too
16:38:06 <aristid> @src scanl
16:38:06 <lambdabot> scanl f q ls = q : case ls of
16:38:06 <lambdabot>     []   -> []
16:38:06 <lambdabot>     x:xs -> scanl f (f q x) xs
16:41:20 <aristid> @src foldr
16:41:20 <lambdabot> foldr f z []     = z
16:41:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:41:49 <aristid> @src foldl
16:41:49 <lambdabot> foldl f z []     = z
16:41:50 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:43:04 <copumpkin> > map concat $ sequence [["M"], ["u", "o"], ["", "'"], ["a"], ["m", "mm"], ["a", "e"], ["r"], [" "], ["al", "el", "Al", "El", ""], ["", " "], ["Q", "G", "Gh", "K", "Kh"], ["a", "e", "u"], ["d", "dh", "dd", "ddh", "dhdh", "dth", "th", "zz"], ["a"], ["f", "ff"], ["i", "y"]]
16:43:05 <lambdabot>   ["Muamar alQadafi","Muamar alQadafy","Muamar alQadaffi","Muamar alQadaffy",...
16:43:08 <copumpkin> http://upload.wikimedia.org/math/6/1/f/61f34aa25871e9546b6a11243e1bed31.png
16:44:25 <monochrom> eh? what is that?
16:44:31 <copumpkin> all the names of gaddafi
16:44:41 <monochrom> oh fun
16:44:42 <copumpkin> > length . map concat $ sequence [["M"], ["u", "o"], ["", "'"], ["a"], ["m", "mm"], ["a", "e"], ["r"], [" "], ["al", "el", "Al", "El", ""], ["", " "], ["Q", "G", "Gh", "K", "Kh"], ["a", "e", "u"], ["d", "dh", "dd", "ddh", "dhdh", "dth", "th", "zz"], ["a"], ["f", "ff"], ["i", "y"]]
16:44:44 <lambdabot>   76800
16:44:53 <hpc> wut
16:45:09 <djahandarie> Haha what
16:45:30 <trez> to much to handle for me
16:45:57 <monochrom> I should get that many names too. So cool. :)
16:46:14 <hpc> monochrom: just make a facebook clone and query the database!
16:46:34 <hpc> you can get 75000 no problem
16:46:43 <copumpkin> monochrom: there are quite a few chinese romanizations
16:47:04 <monochrom> chinese romanization along is not enough for 76800 names
16:47:08 <monochrom> s/alone/
16:47:10 <copumpkin> yeah :/
16:50:05 <aristid> @check \q ls -> let f = (*) in scanl f q ls == (snd $ mapAccumL (\acc x -> let next = f acc x in (next, acc)) q ls)
16:50:05 <lambdabot>   "Falsifiable, after 0 tests:\n-3\n[0,3]\n"
16:52:19 <aristid> @check \q ls -> let f = (*) in scanl f q ls == (q : (snd $ mapAccumL (\acc x -> let next = f acc x in (next, next)) q ls))
16:52:20 <lambdabot>   "OK, passed 500 tests."
16:52:41 <aristid> @check \q ls -> let f = (+) in scanl f q ls == (q : (snd $ mapAccumL (\acc x -> let next = f acc x in (next, next)) q ls))
16:52:42 <lambdabot>   "OK, passed 500 tests."
16:54:06 <aristid> scanl can be rebuilt with mapAccumL \o/
17:14:33 <sshc> Should compiling xmonad-contrib on GHC 7.0.2 take several hours to do?
17:14:54 <hpc> sshc: is it hanging or just slow?
17:15:51 <dmwit> sshc: No.
17:16:05 <dmwit> Definitely not.
17:16:06 <accel> :t mapM_
17:16:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
17:16:34 <sshc> hpc: QuiIt's quite slowly making progress
17:17:23 <sshc> IAfter upgrading GHC to 7.0.2, I've been install packages all day
17:19:22 <sshc> After approximately 8 hours, I'm installing after xmonad-contrib[4~[4~ s/after//
17:20:00 <sshc> I was hoping that a compile- tme killer would be known
17:20:30 <sshc> that if there is a common problem with compile time
17:21:45 <accel> why does the following result in type error
17:21:48 <accel> majorChord time base myMidi = do let lst = [0 4 7] :: [ Word32 ] mapM_ (\x -> startNote (60+base+x) myMidi) lst
17:21:55 <accel> hmm
17:21:56 <accel> I hsould hpaste
17:22:23 <dmwit> accel: 0 4 7 -> 0, 4, 7
17:23:09 <accel> http://hpaste.org/44901/haskell
17:23:26 <accel> oh shit
17:23:30 <accel> it's trying to apply 4 & 7
17:23:32 <accel> to the function 0?
17:23:35 <dmwit> yep
17:23:37 <hpc> > 0 4 7
17:23:38 <lambdabot>   0
17:23:40 <accel> hmm that fixed it
17:23:40 <accel> thanks
17:23:41 <hpc> fixed!
17:28:34 * BrianHV should have known that the 0 4 7 sequence referred to music before even looking at the paste...
17:39:17 * hackagebot pulse-simple 0.1.13 - binding to Simple API of pulseaudio  http://hackage.haskell.org/package/pulse-simple-0.1.13 (DaikiHanda)
17:41:16 <DevHC> quick, who is using kate?
17:41:36 <hpc> is that like charlie sheen? :P
17:41:40 * gwern uses kate inasmuch as pandoc highlights source code using kate derived stuff?
17:42:02 <DevHC> nope
17:42:37 <DevHC> i'm interested in someone who is using some version of kate's haskell mode indentation
17:43:24 <DevHC> ^ interested not in the way u ppl might think
17:43:46 <gwern> rule 34 on programming language syntax, eh
17:43:50 <hpc> hehe
17:44:21 * DevHC visits sum kde channel
17:44:28 * DevHC doesn't forget to troll there
17:44:45 <gwern> criticize their design decisions for kde 4!
17:45:21 <hpc> ask them why it's so buggy on windows!
17:46:01 <DevHC> ON WINDOWS? WTF?
17:46:16 <ian_mi> ha
17:46:24 <hpc> :P
17:46:53 <haskeller> I love suprer marioo
17:47:44 <aristid> haskeller: that statement is just as on-topic as some other stuff discussed here :D
17:47:47 <Eduard_Munteanu> Kate likes to be used :P
17:48:21 <hpc> aristid: it's okay, for haskell talk there's always -blah
17:48:24 <haskeller> what time is it there aristid 
17:48:34 <gwern> it's Miller time
17:48:39 <aristid> @time haskeller
17:48:44 <gwern> in mario land, it's hammer time
17:48:53 <hpc> stop... hammer time
17:49:00 <gwern> (get it, because of the hammer brothers... ah never mind)
17:49:01 <haskeller> sorry.
17:49:18 <haskeller> once in a life tome.
17:51:18 <haskeller> who just came home an loves synergy
17:52:33 <haskeller> is listerine common there?
17:53:53 <aristid> haskeller: i didn't think i would ever say this, but edwardk's stuff is easier to understand than what you say :P
17:57:52 <aristid> blaze-html's HtmlM is ... bah. monad abuse :(
18:00:30 <djahandarie> do notation abuse, you mean :)
18:02:27 <aristid> well, yes
18:05:39 <gwern> on unix, would it be correct to say that directories are files?
18:06:14 <gwern> I mean, wikipedia says it ('On Unix, folders are regarded as a type of file.[4]'), but...
18:06:23 * hackagebot sbv 0.9.14 - Symbolic Bit Vectors: Prove bit-precise program properties using SMT solvers.  http://hackage.haskell.org/package/sbv-0.9.14 (LeventErkok)
18:07:05 <Eduard_Munteanu> gwern: mm, I wouldn't say that's accurate
18:07:35 <sipa> file is used in two different meanings, i think
18:07:40 <sipa> 1) filesystem entry
18:07:44 <Eduard_Munteanu> Yep, dentry vs inode
18:07:55 <sipa> 2) specific type of filesystem entry
18:08:52 <aristid> i think a directory is as much of a file as a unix socket or a named pipe
18:09:57 <sipa> i once read somewhere "a file is something that looks like a sequence of bytes"
18:10:04 <sipa> that's the specific type
18:10:28 <accel> whoa
18:10:31 <accel> mind blown
18:11:03 <ion> In some operating systems you can cat(1) a directory.
18:11:30 <shachaf> ion: And hard-link them.
18:14:41 <Eduard_Munteanu> It really depends on what you think of as a file, either the name in the dir structure or some allocated storage space accesible via an inode. Those two are separate, at least in Linux.
18:19:49 <DevHC> i can cat a directory (i'm on freebsd)
18:20:26 <Eduard_Munteanu> I can 'vim' a directory :P
18:20:41 <ndrsndrs> can't cat a directory on osx, fwiw
18:20:58 <sshc> Which FRP library is the most "standard" / should I use?
18:21:26 <Eduard_Munteanu> +1 for sshc's question
18:22:24 <sshc> Yampa doesn't seem to have had any updates in years, grapefruit doesn't work on GHC 7, and reactive fails on GHC 7 with 'cabal: cannot configure category-extras-0.53.5. It requires ghc >=6.9'
18:22:37 <sshc> (Which is odd; isn't 7 >= 6.9?)
18:22:53 <Eduard_Munteanu> oO, wow, stuff that depends on edwardk's stuff
18:23:05 <Eduard_Munteanu> Neat.
18:24:02 <djahandarie> I think it's one of the few packages
18:24:23 <djahandarie> I think the new split-up packages will be adopted fairly nicely though.
18:25:09 <aristid> once people are educated as to what they can use comonads for ;)
18:26:28 <djahandarie> I think there is a nice example on sclv's blog
18:26:45 <djahandarie> http://fmapfixreturn.wordpress.com/2008/07/09/comonads-in-everyday-life/
18:26:49 <djahandarie> I think that's his blog...
18:29:17 <aristid> trusty zippers
18:31:30 <HugoDaniel> :)
18:31:33 <HugoDaniel> im going to read up on that one
18:32:32 <ian_mi> I'm already starting to use semigroupoids :)
18:33:40 <napping> You are a bit ahead of the game, then
18:35:21 <sshc> Any FRP users in here?
18:35:27 <sshc> Which library do you use??
18:39:27 <sshc> That question seems to be quite capable of silencing the channel
18:39:32 <HugoDaniel> :)
18:39:58 <sshc> FRP seem quite promising, too
18:49:32 <codolio> Heh.
19:00:40 <revenantphx> So.
19:00:50 <revenantphx> I mentioned this before, but no feedback.
19:01:31 <revenantphx> Well, nevermind.
19:15:11 <sshc> It seems somebody accidentally the slideshow at http://corp.galois.com/blog/2009/4/27/engineering-large-projects-in-haskell-a-decade-of-fp-at-galo.html
19:34:27 <rpglover64> Does anyone have any suggestion for how to parse an "if ... then ... else ..." expression using parsec?  Text.Parsec.Expr has tools to help with binary operators, but nothing for ternary operators
19:35:54 <ndrsndrs> i just do it by hand; `liftA3 IfE (res "if" *> expr) (res "then" *> expr) (res "else" *> expr) where res = reserved` seems to work ok
19:36:00 <ndrsndrs> (or something to that effect)
19:36:47 <ndrsndrs> (reserved from Text.Parsec.Token)
19:37:26 <rpglover64> ndrsndrs: does that correctly handle nested ifs? e.g. " if if True then True else False then True else False"
19:37:46 <ndrsndrs> assuming `expr` parses them, then i think so
19:38:04 <ndrsndrs> if the else is required, of course; otherwise, the normal ambiguity happens
19:38:29 <rpglover64> the else is required
19:39:09 <ndrsndrs> then i'm pretty sure it's fine
19:39:55 <ndrsndrs> i have a line that looks very much like that somewhere; i can't find the project in question at the moment (woops :[), but something like that will work
19:41:40 <ndrsndrs> found it, and that's exactly what i wrote. so it even typechecks! :)
19:45:36 <rpglover64> ndrsndrs: thanks
19:53:57 <rpglover64> Is there a way to intermingle that with stuff defined using buildExpressionParser?
19:55:09 <ndrsndrs> not sure
19:55:36 <ndrsndrs> i only used atomic expressions with bEP
19:56:15 <rpglover64> atomic expressions?
19:57:31 <ndrsndrs> things like lists, parenthesised expressions, single identifiers, etc
19:57:43 <monochrom> atomic = parens bEP <|> identifier
19:57:56 <ndrsndrs> things that were easy to parse and didn't have operators in them, anyway
19:57:59 <ddarius> You can stick arbitrary parsers into the various components of buildExpressionParser.
19:58:01 <rpglover64> ah, so no "5 + 8 + 3"
19:58:06 <ndrsndrs> (well, not outside the parens. you know what i mean.)
19:58:11 <monochrom> bEP = buildExpressionParser your'table atomic
19:58:39 <rpglover64> ... and no "5 + 8"
20:00:33 <ndrsndrs> wait, if you have "if a then b else c + d", is it interpreted as "(if a then b else c) + d" or "if a then b else (c + d)"
20:01:47 <sshc> I'm seeing this...warning.. quite frequently lately: 
20:01:47 <ndrsndrs> if the latter, then using atomic exprs with bEP is ok since anything more complex is already addressed with the main parser anyway
20:02:05 <sshc> SpecConstr
20:02:05 <sshc>     Function `$wa{v X2TlV} [lid]'
20:02:05 <sshc>       has three call patterns, but the limit is 1
20:02:05 <sshc>     Use -fspec-constr-count=n to set the bound
20:02:05 <sshc>     Use -dppr-debug to see specialisations
20:02:07 <rpglover64> the second one
20:02:40 <ndrsndrs> good because the other one would be a very silly idea :)
20:03:01 <ndrsndrs> also +1 on sshc's question because i've seen that a couple times too
20:03:08 <ndrsndrs> i think with alex/happy, iirc
20:03:41 <ndrsndrs> apparently i've been on a parsing binge recently...
20:04:02 <rpglover64> about alex/happy: why would one use them vs parsec?
20:04:27 <rpglover64> (I haven't done a lot of parsing at all)
20:04:35 <monochrom> to accomodate if-then-else: main = (reserved "if" >> main >> reserved "then" >> main >> reserved "else" >> main) <|> parens (buildExpressionParser table main) <|> identifier
20:05:03 <ddarius> They are more powerful (in a certain sense) and they will produce faster parsers.
20:05:42 <Ziphilt> i am playing with Gloss in GHCi, and whenever i close the window it produces, it kills the GHCi terminal too. this is incredibly annoying, does anyone know how to avoid this behavior?
20:05:54 <ndrsndrs> related: is there a standard way of doing user-defined precedences with happy, or do you just sort them out by hand later
20:06:06 <monochrom> if someone gave you a lex and yacc file already, easier to translate to alex and happy. some intelligent rewrite required for parsec.
20:06:12 <ndrsndrs> those were the main reason i went for parsec
20:06:32 <ndrsndrs> also, unicode input with alex
20:08:00 <ddarius> I'm pretty sure you can just give the precedence of operators in Happy as with virtually all other parser generators.
20:08:20 <ndrsndrs> i mean, languages with infix{,l,r} decls
20:08:48 <ndrsndrs> so you don't know them until you start parsing
20:09:33 <ndrsndrs> (this is a sml-based language, where you don't even know if something's infix or not by just looking, but i don't think that makes much difference here)
20:09:34 <NemesisD> anyone know of any good libraries that talk to REST apis (or any other web APIs). i'm thinking about designing a package to interface with the netflix api but i'd like to get the architecture right
20:09:38 <ddarius> Oh, then I'm pretty sure it isn't trivial to do that as parser generators are usually aimed at context-free grammars.
20:09:52 <ndrsndrs> fair enough
20:10:19 <ddarius> Usually those things are handled by using the semantic actions of the parser generator to hold the relevant information or by using multiple passes.
20:10:37 <monochrom> the ghc user guide promises -fspec-constr-count defaults to 3. if it turns out to be 1, perhaps a bug?
20:10:50 <ndrsndrs> that's what i thought, and i'l probably do something similar later
20:11:22 <ndrsndrs> my prototypey thing just regenerates the buildExpressionParser every time it hits a fixity decl. which is hilariously inefficient, i'm sure. :)
20:11:53 <ndrsndrs> but It'll Do For Now
20:13:50 <ddarius> That's perfectly reasonable as the table you are passing in probably isn't that large.
20:14:18 <ndrsndrs> no, i suppose not
20:15:46 <monochrom> oh, the whole SpecConstr business is complicated. there is some nesting or recursion involved. "the limit is 1" has nothing to do with whatever -fspec-constr-count you set.
20:15:57 <monochrom> http://hackage.haskell.org/trac/ghc/ticket/4288
20:16:48 <accel> damn it; my internet connection is so fucking unstable
20:17:10 <monochrom> it tries to protect you from procrastinating sleep
20:17:18 <accel> the only good thing is that i don't have to deal with this atrocity
20:17:20 <accel> known as google instant
20:23:19 <accel> damn it; freenode keeps on disconnecting me
20:23:24 <accel> did one of you get me banned from freenode?
20:24:08 <monochrom> "Client Quit" doesn't look like an effect of banning
20:24:19 <accel> no; that was because everything was going slow
20:24:26 <accel> so I had to disconnect everythng
20:24:31 <accel> but trying to reconnect to freenode
20:24:36 <accel> i got many connection losts
20:24:42 <monochrom> ah. banning would not lead to just being slow
20:24:57 <accel> what if it's an evil banning
20:25:03 <accel> because if it's an outright ban; I would recognise it
20:25:06 <accel> but it just randomly drops packets
20:25:07 <ddarius> I'm thinking that if accel thinks he should be banned, he would know best and should perhaps be obliged.
20:25:21 <monochrom> what if it's a virus in your computer
20:25:39 <accel> what if our universes are faling apart, like in fringe?
20:27:10 <monochrom> our universes are falling apart.
20:27:13 <lispy> ddarius: :)
20:29:09 <Ziphilt> i am playing with Gloss in GHCi, and whenever i close the window it produces, it kills the GHCi terminal too. this is incredibly annoying, does anyone know how to avoid this behavior?
20:31:33 <ian_mi> is there a command in ghci to determine the precedence of an operator?
20:31:50 <ndrsndrs> :i
20:31:55 <ian_mi> thanks
20:31:59 <ndrsndrs> (:info)
20:32:17 <ndrsndrs> also does instances of classes/instances a type has, etc
20:32:31 <ian_mi> ah
20:32:52 <accel> hmmmm
21:06:00 <ian_mi> down with pure!
21:06:06 <ian_mi> I should have done this a long time ago
21:09:35 <Axman6> ian_mi: the language or the idea? :)
21:10:29 <ian_mi> Axman6: I mean the Applicative kind
21:10:43 <Axman6> ah
21:10:51 <djahandarie> ian_mi, finally moving to point? ;)
21:11:07 <dmwit> Ziphilt: fix Gloss ;-)
21:11:23 <ian_mi> djahandarie: switching to Apply from semigroupoids
21:11:30 <Ziphilt> dmwit: well yeah maybe i will
21:11:33 <Ziphilt> :D
21:12:16 <ian_mi> pure is hard for Vecs
21:12:19 <djahandarie> You don't need to use a semigroupoid if you have an Applicative
21:12:33 <djahandarie> It's only for almost Applicatives
21:12:37 <djahandarie> You can write pure for Vec
21:12:48 <ian_mi> sure, if you use a type class
21:13:15 <ian_mi> I can't figure out a better way to do it though
21:13:39 <ian_mi> and using a type class means you lose Applicative when you do type addition
21:14:14 <djahandarie> You can write it without a typeclass.
21:14:38 <ian_mi> djahandarie: hmm, please enlighten me :)
21:14:47 <djahandarie> Split the instance into two.
21:15:09 <djahandarie> instance Applicative (Vec Z) where ...; instance Applicative (Vec n) => Applicative (Vec (S n)) where ...;
21:15:27 <Axman6> instance Applicative (Vec n a) => Applicative (Vec (S n) a) where pure a = Cons a (pure a)?
21:15:35 * Axman6 wins
21:15:55 <Axman6> apart from the extra a's
21:16:32 <ian_mi> djahandarie: right but then you have to write Applicative n a => everywhere
21:16:48 <Axman6> why?
21:17:13 <ian_mi> Applicative (Vec n a) rather
21:17:59 <pastorn> no, the instance of Applicative (Vec ...) implies it
21:18:20 <ian_mi> the type checker can't deduce that those two instances cover all instances
21:18:27 <pastorn> oh, wait
21:18:29 <djahandarie> ian_mi, yes, you are right.
21:18:39 <djahandarie> But you don't need an extra typeclass ;)
21:18:40 <pastorn> you're rigth... the Z doesn't have the implication
21:19:58 <ian_mi> the nice thing about Apply is that I can define <.> (i.e. <*>) for any Vec
21:20:47 <pastorn> When will we get type class aliases?
21:20:50 * pastorn wantz it
21:21:14 <ian_mi> what's really needed are type to data functions
21:21:58 <pastorn> ian_mi: uhm... could you explain?
21:22:51 <ian_mi> pastorn: I'm imagining pattern matching on types, such as pure' E = E, pure'
21:23:01 <ian_mi> err
21:23:06 <ian_mi> pure' Z = E
21:23:39 <pastorn> ian_mi: i don't get it :/
21:24:00 <ian_mi> pure' Z _ = E, pure' (N a) x = x : pure' a x
21:24:21 <djahandarie> He's saying you could match on the type and enforce totality with it.
21:24:30 <ian_mi> then instance Applicative (Vec n a) where pure = pure' n
21:25:00 <djahandarie> In Agda this is how you would do it (though using an implicit param)
21:28:45 <ddarius> ian_mi: You can do that with SHE.
21:29:30 <djahandarie> With curly brackets though, I think.
21:29:37 <pastorn> ewwww
21:29:39 <pastorn> agda
21:31:08 <jmcarthur> ew?
21:31:20 <pastorn> nasty stuff
21:31:26 <pastorn> also - i don't know it at all
21:31:32 <djahandarie> pastorn, clearly not, considering the previous example ;)
21:32:07 <ddarius> djahandarie: While the previous example would be natural in Agda, it doesn't require the power of dependent types.
21:32:32 <ian_mi> ddarius: haha, SHE's description doesn't inspire confidence
21:35:01 <ddarius> SHE is a huge hack.
21:35:41 <ian_mi> ahh
21:36:32 <ddarius> However, one of the things SHE demonstrates is that the power to do such things is available in Haskell.
21:36:48 <djahandarie> Including pi types!
21:36:59 <djahandarie> Although I don't know how well that works...
21:41:38 <ian_mi> http://hackage.haskell.org/trac/ghc/wiki/KindSystem seems to be in that direction
21:44:12 <djahandarie> That is no longer in progress
21:44:20 <djahandarie> It has been replaced with byorgey's typekind system
21:44:39 <djahandarie> Which achieves the same sort of end, but by merging types and kinds in a neat manner
21:46:36 <djahandarie> I think part of his work has been completed (seperating the type of type coercions from actual types)
21:46:59 <djahandarie> I have little clue how far the actual typekind stuff has gotten though
21:48:32 <djahandarie> Here are his slides on it: http://www.cis.upenn.edu/~byorgey/talks/typetype-HIW-20101001.pdf and video: http://vimeo.com/15480577
21:49:06 <ian_mi> hmm, the way he explains it it sounds like the type system becomes dependantly typed
21:50:04 <accel> how do I write a multi-threaded (with OS thread) Haskell program? I need to use usleep for timing in my program, so I actually need multiple OS threads
21:50:54 <ian_mi> I certainly hope typekinds are still being developed
21:51:44 <djahandarie> I haven't bugged him for awhile :) If it's still in progress by hacphi I'll make sure to bug him there and see if I can help out ;)
21:52:35 <ian_mi> djahandarie: awesome!
22:00:11 <ian_mi> worst joke ever (from Wikipedia's article on semirings): The term rig is also used occasionally—this originated as a joke, suggesting that rigs are rings without negative elements.
22:00:52 <ddarius> There are rngs too.
22:05:19 <accel> does forkIO create a haskell thread or an OS thread?
22:05:26 <pastorn> haskell one
22:06:06 <accel> hey; we were talking music last night
22:06:09 <accel> is there somethging like forkIO
22:06:12 <accel> but creates an OS thread?
22:08:25 <accel> forkOS
22:09:17 <ddarius> There is a many to many mapping between Haskell threads and OS threads.
22:09:48 <ddarius> This is handled by the run-time system.  The number of OS threads used is specified by a runtime option given to the threaded runtime.
22:15:59 <accel> woot, chapter 24 of RWJ
22:16:04 <accel> expalined everything well
22:16:39 <bss03> @hoogle forkOS
22:16:39 <lambdabot> Control.Concurrent forkOS :: IO () -> IO ThreadId
22:17:09 <dolio> That type...
22:17:34 <djahandarie> bss03, that doesn't create an OS thread
22:17:50 <bss03> :(
22:18:10 <bss03> I want to fork + setsid + fork, and forkProcess has a nasty warning.
22:18:29 <bss03> I was pointed at hdaemonize on hackage, but...
22:18:37 <bss03> It look like it just uses forkProcess unsafely.
22:19:34 <accel> how do I tell ghc to link in everything statically rather than dynamically?
22:19:40 <accel> (I'm writing a desktop app and distributing it to ohers)
22:28:21 <Squakmix> Is there any reason to learn haskell
22:29:05 <NemesisD> anyone ever worked with libyaml and/or xml? i'm trying to figure out which API format i want to parse, there's rss, yaml, json, and i've had really bad experiences with text.json
22:30:11 <NemesisD> i'm trying to figure out which will hurt less
22:34:08 <BrianHV> I wouldn't bother with yaml. json has basically the same functionality and is more standard
22:34:32 <BrianHV> however, I can't speak to the haskell implementations
22:35:14 <Xilon> BrianHV: Well, JSON is a subset of YAML, depends on the requirements. Typically JSON is sufficient for most cases though.
22:36:02 <Xilon> aeson is apparently quite fast for json
22:38:27 <bss03> Bwaha!
22:38:52 <bss03> forkProcess isn't actually as broken as the documentation suggests.
22:39:41 <bss03> The I/O manager will survive in GHC 6.12+, so hdaemonize is exactly what I need.
22:40:12 * bss03 looks for a way to file a documentation bug against forkProcess.
22:54:02 <NemesisD> god i'm going to be ecstatic if aeson is even a little less difficult to use than text.json
22:58:30 <appamatto> Does ghc 7 know about newtype?
22:58:39 <appamatto> I'm getting syntax errors on any usage
22:58:43 <appamatto> (in ghci)
22:58:51 <dolio> You can't declare types in ghci.
22:59:46 <kniu> would be cool if you could.
22:59:53 <appamatto> thanks :p
23:00:15 <accel> how do I build a executrable
23:00:16 <kniu> somebody should use a summer of code to give ghci crazier features.
23:00:19 <accel> with everything linked in?
23:00:26 <accel> kniu: itshould make me sandwiches
23:00:32 <kniu> accel, define "everything"
23:00:42 <accel> i want libraries linked in statically rather than dynamically
23:00:49 <kniu> try -static.
23:01:26 <accel> binary is only 7.1MB
23:01:58 <Xilon> I thought ghc did that by default?
23:02:22 <kniu> there's another flag that also tries to link any used C libraries statically.
23:02:25 <kniu> forgot what it was.
23:02:55 <kniu> oh yeah
23:03:02 <kniu> accel, ghc -static -optl-static
23:03:50 <kniu> http://www.haskell.org/pipermail/glasgow-haskell-users/2005-March/008227.html
23:03:55 <kniu> This is like
23:04:02 <kniu> the only place on the internet that even mentions this flag.
23:04:10 <kniu> I can't find it in the GHC manual.
23:05:23 <BrianHV> it looks like -optl means "pass through to the linker."  so -optl-static just means "tell the linker to use the -static flag"
23:06:19 <BrianHV> (source: http://www.cs.virginia.edu/~wh5a/blog/Some%20GHC%20notes%20for%20myself.html)
23:11:15 <GreaseMonkey> ok i'm having an issue wrt trying to print stuff in my assignment
23:11:34 <GreaseMonkey> printLetterMap c (x:xs) = do
23:11:37 <GreaseMonkey> 	print ((c, x))
23:11:39 <GreaseMonkey> 	printLetterMap (succ c) xs
23:11:41 <GreaseMonkey> i'm using hugs
23:11:53 <GreaseMonkey> w/o the "print" it acts fine but doesn't print anything
23:11:58 <GreaseMonkey> w/ it i get a type error
23:12:04 * mlh hugs GreaseMonkey 
23:12:08 <GreaseMonkey> erm
23:12:09 <GreaseMonkey> ERROR "chrthing.hs":9 - Type error in final generator
23:12:10 <GreaseMonkey> *** Term           : printLetterMap (succ c) xs
23:13:54 <Xilon> GreaseMonkey: works fine with GHC (apart from non-exhaustive patterns)
23:14:12 <GreaseMonkey> dammit >_<
23:14:41 <Saizan> that's not the full type error, is it?
23:14:44 <ddarius> Xilon: There's a case he hasn't listed that has the problem.
23:14:49 <Saizan> and use a pastebin
23:14:51 <GreaseMonkey> correct uhh
23:14:57 <GreaseMonkey> *** Type           : Maybe b
23:14:58 <GreaseMonkey> *** Does not match : IO a
23:15:37 <Saizan> so ddarius seems correct, that you're not showing the full code for printLetterMap
23:15:43 <Saizan> put it on hpaste.org
23:16:06 <GreaseMonkey> ok that's a bit unusual
23:16:16 <GreaseMonkey> printLetterMap c [] = Nothing
23:16:16 <GreaseMonkey> printLetterMap c (0:xs) = printLetterMap (succ c) xs
23:16:21 <GreaseMonkey> those are above it
23:16:27 <GreaseMonkey> seems the [] one breaks
23:17:13 <Saizan> Nothing is of type Maybe A for some A, but "do print ..; .." is of type IO B for some B, that's your problem
23:17:19 <ceii_> GreaseMonkey: in your base case, you want a no-op IO action, and that's "return ()"
23:17:24 <GreaseMonkey> hmmkay
23:17:32 <ceii_> Nothing has a completely different type
23:17:40 <GreaseMonkey> thanks
23:18:08 <GreaseMonkey> works perfectly now
23:20:12 <lispy> What does "newBoundTask: RTS is not initialised; call hs_init() first"  mean when ghc says it?
23:22:38 <Saizan> somehow they forgot to initialize the RTS in some code path?
23:23:23 <lispy> Saizan: I should mention, I use a bunch of C code
23:23:33 <lispy> I suspect the C code is not playing nicely
23:23:46 <lispy> as a paranoid attempt at debugging I changed all the FFI stuff to be "safe"
23:23:51 <lispy> No difference though
23:24:19 <lispy> I do have a "exitWith ExitSuccess" while some threads may still be running
23:24:28 <Saizan> is the C code calling into haskell?
23:26:14 <Saizan> ah, so maybe the exception thrown by exitWith goes up to the point of causing the shutdown of the RTS and after that your C code calls something that needs it
23:26:44 <lispy> That sounds likely
23:27:13 <lispy> main ends with: forever $ GLFW.waitEvents >> GLFW.swapBuffers
23:27:24 <gienah> lispy: if the main is in C then it should start like: int main (int argc, const char *argv[]) { hs_init(&argc, (char***)&argv); hs_add_root(__stginit_HaskellModule); /* ... */ }
23:29:48 <gienah> lispy: where HaskellModule is changed to the name of some haskell module you need to call, also the main end with hs_exit()
23:30:06 <gienah> s/main end/main should end/
23:31:38 <lispy> gienah: It's all in C, but I use the GLFW-b bindings
23:32:04 <lispy> gienah: and I don't actually know how much magic GLFW is doing in the background.  I should also add this is on windows.
23:32:10 <lispy> I kind of like Saizan's theory.
23:33:34 <lispy> It's not a big crash, so I may leave it for now and ask on -Cafe
23:33:47 <gienah> lispy: in case it is of any interest, here is an example of C calling Haskell: https://github.com/markwright/antlrc-examples/tree/master/src/tapl/arith 
23:35:39 <lispy> gienah: cool.  It's not what I'm doing, but good to know an example exists.
23:35:59 <lispy> I once loaded haskell code compiled as a DLL into another app.  THat was all kinds of tricky as I recall.
23:39:20 <NemesisD> Xilon: you ever used aeson?
23:44:28 <NemesisD> i guess that doesn't matter. what am i doing wrong when declaring this instance? http://hpaste.org/44903/aweson
23:58:09 <Saizan> NemesisD: ghc-pkg list aeson ?
23:59:17 <Saizan> i think you've version 0.1.0.0 installed, where the method was called fromJSON
